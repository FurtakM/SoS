// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60966 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 52263 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 52263 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 52263 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 52263 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4594 0 0
// PrepareRussian ;
 189: CALL 3007 0 0
// PrepareAlliance ;
 193: CALL 925 0 0
// MC_Start ( ) ;
 197: CALL 63146 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9382 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 85119 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 85564 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 86022 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 86299 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 85504 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 86202 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 85564 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 86022 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 86299 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 85348 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 86629 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 85504 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: IFFALSE 865
 850: PUSH
 851: LD_EXP 50
 855: PPUSH
 856: CALL_OW 255
 860: PUSH
 861: LD_INT 7
 863: EQUAL
 864: AND
 865: IFFALSE 878
 867: PUSH
 868: LD_EXP 51
 872: PPUSH
 873: CALL_OW 302
 877: AND
 878: IFFALSE 891
 880: PUSH
 881: LD_EXP 50
 885: PPUSH
 886: CALL_OW 302
 890: AND
 891: IFFALSE 903
 893: GO 895
 895: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 896: LD_STRING ACH_COMRADE
 898: PPUSH
 899: CALL_OW 543
 903: END
// every 0 0$1 trigger hack_counter >= 10 do
 904: LD_EXP 16
 908: PUSH
 909: LD_INT 10
 911: GREATEREQUAL
 912: IFFALSE 924
 914: GO 916
 916: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 917: LD_STRING ACH_HACK
 919: PPUSH
 920: CALL_OW 543
 924: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 925: LD_INT 0
 927: PPUSH
 928: PPUSH
 929: PPUSH
 930: PPUSH
// uc_side := 7 ;
 931: LD_ADDR_OWVAR 20
 935: PUSH
 936: LD_INT 7
 938: ST_TO_ADDR
// uc_nation := 1 ;
 939: LD_ADDR_OWVAR 21
 943: PUSH
 944: LD_INT 1
 946: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 947: LD_ADDR_EXP 17
 951: PUSH
 952: LD_STRING JMM
 954: PPUSH
 955: LD_EXP 1
 959: NOT
 960: PPUSH
 961: LD_STRING 12a_
 963: PPUSH
 964: CALL 17412 0 3
 968: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 71
 976: PPUSH
 977: LD_INT 23
 979: PPUSH
 980: LD_INT 0
 982: PPUSH
 983: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 987: LD_EXP 17
 991: PPUSH
 992: LD_INT 2
 994: PPUSH
 995: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 999: LD_ADDR_EXP 18
1003: PUSH
1004: LD_STRING Roth
1006: PPUSH
1007: LD_EXP 1
1011: NOT
1012: PPUSH
1013: LD_STRING 12a_
1015: PPUSH
1016: CALL 17412 0 3
1020: ST_TO_ADDR
// if Roth then
1021: LD_EXP 18
1025: IFFALSE 1045
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1027: LD_EXP 18
1031: PPUSH
1032: LD_INT 71
1034: PPUSH
1035: LD_INT 21
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 34
1049: PUSH
1050: LD_STRING Mike
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 17412 0 3
1066: ST_TO_ADDR
// if Mike then
1067: LD_EXP 34
1071: IFFALSE 1088
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1073: LD_EXP 34
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 19
1092: PUSH
1093: LD_STRING Lisa
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 17412 0 3
1109: ST_TO_ADDR
// if Lisa then
1110: LD_EXP 19
1114: IFFALSE 1131
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1116: LD_EXP 19
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 20
1135: PUSH
1136: LD_STRING Donaldson
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 17412 0 3
1152: ST_TO_ADDR
// if Donaldson then
1153: LD_EXP 20
1157: IFFALSE 1174
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1159: LD_EXP 20
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 21
1178: PUSH
1179: LD_STRING Bobby
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 17412 0 3
1195: ST_TO_ADDR
// if Bobby then
1196: LD_EXP 21
1200: IFFALSE 1217
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1202: LD_EXP 21
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 22
1221: PUSH
1222: LD_STRING Cyrus
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 17412 0 3
1238: ST_TO_ADDR
// if Cyrus then
1239: LD_EXP 22
1243: IFFALSE 1260
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1245: LD_EXP 22
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 23
1264: PUSH
1265: LD_STRING Denis
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 17412 0 3
1281: ST_TO_ADDR
// if Denis then
1282: LD_EXP 23
1286: IFFALSE 1303
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1288: LD_EXP 23
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 24
1307: PUSH
1308: LD_STRING Brown
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 17412 0 3
1324: ST_TO_ADDR
// if Brown then
1325: LD_EXP 24
1329: IFFALSE 1346
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1331: LD_EXP 24
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 25
1350: PUSH
1351: LD_STRING Gladstone
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 17412 0 3
1367: ST_TO_ADDR
// if Gladstone then
1368: LD_EXP 25
1372: IFFALSE 1389
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1374: LD_EXP 25
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 26
1393: PUSH
1394: LD_STRING Houten
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 17412 0 3
1410: ST_TO_ADDR
// if Houten then
1411: LD_EXP 26
1415: IFFALSE 1432
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1417: LD_EXP 26
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 27
1436: PUSH
1437: LD_STRING Cornell
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 17412 0 3
1453: ST_TO_ADDR
// if Cornel then
1454: LD_EXP 27
1458: IFFALSE 1475
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1460: LD_EXP 27
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1475: LD_ADDR_EXP 28
1479: PUSH
1480: LD_STRING Gary
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: LD_STRING 12a_
1491: PPUSH
1492: CALL 17412 0 3
1496: ST_TO_ADDR
// if Gary then
1497: LD_EXP 28
1501: IFFALSE 1518
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1503: LD_EXP 28
1507: PPUSH
1508: LD_INT 13
1510: PPUSH
1511: LD_INT 0
1513: PPUSH
1514: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1518: LD_ADDR_EXP 29
1522: PUSH
1523: LD_STRING Frank
1525: PPUSH
1526: LD_EXP 1
1530: NOT
1531: PPUSH
1532: LD_STRING 12a_
1534: PPUSH
1535: CALL 17412 0 3
1539: ST_TO_ADDR
// if Frank then
1540: LD_EXP 29
1544: IFFALSE 1561
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1546: LD_EXP 29
1550: PPUSH
1551: LD_INT 13
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1561: LD_ADDR_EXP 30
1565: PUSH
1566: LD_STRING Kikuchi
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 12a_
1577: PPUSH
1578: CALL 17412 0 3
1582: ST_TO_ADDR
// if Kikuchi then
1583: LD_EXP 30
1587: IFFALSE 1604
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1589: LD_EXP 30
1593: PPUSH
1594: LD_INT 13
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1604: LD_ADDR_EXP 31
1608: PUSH
1609: LD_STRING Simms
1611: PPUSH
1612: LD_EXP 1
1616: NOT
1617: PPUSH
1618: LD_STRING 12a_
1620: PPUSH
1621: CALL 17412 0 3
1625: ST_TO_ADDR
// if Simms then
1626: LD_EXP 31
1630: IFFALSE 1647
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1632: LD_EXP 31
1636: PPUSH
1637: LD_INT 13
1639: PPUSH
1640: LD_INT 0
1642: PPUSH
1643: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1647: LD_ADDR_EXP 32
1651: PUSH
1652: LD_STRING Joan
1654: PPUSH
1655: LD_EXP 1
1659: NOT
1660: PPUSH
1661: LD_STRING 12a_
1663: PPUSH
1664: CALL 17412 0 3
1668: ST_TO_ADDR
// if Joan then
1669: LD_EXP 32
1673: IFFALSE 1690
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1675: LD_EXP 32
1679: PPUSH
1680: LD_INT 13
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1690: LD_ADDR_EXP 33
1694: PUSH
1695: LD_STRING DeltaDoctor
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 12a_
1706: PPUSH
1707: CALL 17412 0 3
1711: ST_TO_ADDR
// if DeltaDoctor then
1712: LD_EXP 33
1716: IFFALSE 1733
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1718: LD_EXP 33
1722: PPUSH
1723: LD_INT 13
1725: PPUSH
1726: LD_INT 0
1728: PPUSH
1729: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1733: LD_ADDR_VAR 0 4
1737: PUSH
1738: LD_STRING 12a_others
1740: PPUSH
1741: CALL_OW 31
1745: ST_TO_ADDR
// if tmp then
1746: LD_VAR 0 4
1750: IFFALSE 1784
// for i in tmp do
1752: LD_ADDR_VAR 0 3
1756: PUSH
1757: LD_VAR 0 4
1761: PUSH
1762: FOR_IN
1763: IFFALSE 1782
// PlaceUnitArea ( i , alliance_start , false ) ;
1765: LD_VAR 0 3
1769: PPUSH
1770: LD_INT 13
1772: PPUSH
1773: LD_INT 0
1775: PPUSH
1776: CALL_OW 49
1780: GO 1762
1782: POP
1783: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 3
1789: PPUSH
1790: LD_INT 3
1792: PPUSH
1793: LD_INT 12
1795: PPUSH
1796: LD_INT 100
1798: PPUSH
1799: CALL 22432 0 5
// veh := CreateVehicle ;
1803: LD_ADDR_VAR 0 2
1807: PUSH
1808: CALL_OW 45
1812: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1813: LD_VAR 0 2
1817: PPUSH
1818: LD_INT 2
1820: PPUSH
1821: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1825: LD_VAR 0 2
1829: PPUSH
1830: LD_INT 60
1832: PPUSH
1833: LD_INT 6
1835: PPUSH
1836: LD_INT 0
1838: PPUSH
1839: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 4
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1858: LD_STRING 11_artifact_captured
1860: PPUSH
1861: LD_INT 0
1863: PPUSH
1864: CALL_OW 30
1868: IFFALSE 1944
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 3
1875: PPUSH
1876: LD_INT 3
1878: PPUSH
1879: LD_INT 12
1881: PPUSH
1882: LD_INT 100
1884: PPUSH
1885: CALL 22432 0 5
// veh := CreateVehicle ;
1889: LD_ADDR_VAR 0 2
1893: PUSH
1894: CALL_OW 45
1898: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1899: LD_VAR 0 2
1903: PPUSH
1904: LD_INT 3
1906: PPUSH
1907: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1911: LD_VAR 0 2
1915: PPUSH
1916: LD_INT 75
1918: PPUSH
1919: LD_INT 6
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1929: LD_VAR 0 2
1933: PPUSH
1934: LD_INT 4
1936: PPUSH
1937: LD_INT 50
1939: PPUSH
1940: CALL_OW 290
// end ; end ;
1944: LD_VAR 0 1
1948: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1949: LD_INT 0
1951: PPUSH
1952: PPUSH
1953: PPUSH
1954: PPUSH
// uc_side := 6 ;
1955: LD_ADDR_OWVAR 20
1959: PUSH
1960: LD_INT 6
1962: ST_TO_ADDR
// uc_nation := 3 ;
1963: LD_ADDR_OWVAR 21
1967: PUSH
1968: LD_INT 3
1970: ST_TO_ADDR
// InitHc ;
1971: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1975: LD_ADDR_EXP 35
1979: PUSH
1980: LD_STRING Gossudarov
1982: PPUSH
1983: CALL_OW 25
1987: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1988: LD_ADDR_EXP 36
1992: PUSH
1993: LD_STRING Kirilenkova
1995: PPUSH
1996: CALL_OW 25
2000: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
2001: LD_ADDR_EXP 37
2005: PUSH
2006: LD_STRING Titov
2008: PPUSH
2009: CALL_OW 25
2013: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2014: LD_ADDR_EXP 42
2018: PUSH
2019: LD_STRING Oblukov
2021: PPUSH
2022: CALL_OW 25
2026: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2027: LD_ADDR_EXP 39
2031: PUSH
2032: LD_STRING Dolgov
2034: PPUSH
2035: CALL_OW 25
2039: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2040: LD_ADDR_EXP 40
2044: PUSH
2045: LD_STRING Petrosyan
2047: PPUSH
2048: CALL_OW 25
2052: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2053: LD_ADDR_EXP 41
2057: PUSH
2058: LD_STRING Scholtze
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2066: LD_ADDR_EXP 43
2070: PUSH
2071: LD_STRING Kapitsova
2073: PPUSH
2074: CALL_OW 25
2078: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2079: LD_ADDR_VAR 0 2
2083: PUSH
2084: LD_EXP 35
2088: PUSH
2089: LD_EXP 36
2093: PUSH
2094: LD_EXP 37
2098: PUSH
2099: LD_EXP 42
2103: PUSH
2104: LD_EXP 39
2108: PUSH
2109: LD_EXP 40
2113: PUSH
2114: LD_EXP 41
2118: PUSH
2119: LD_EXP 43
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 4
2139: PPUSH
2140: LD_INT 8
2142: PPUSH
2143: CALL_OW 380
// un := CreateHuman ;
2147: LD_ADDR_VAR 0 4
2151: PUSH
2152: CALL_OW 44
2156: ST_TO_ADDR
// tmp := tmp ^ un ;
2157: LD_ADDR_VAR 0 2
2161: PUSH
2162: LD_VAR 0 2
2166: PUSH
2167: LD_VAR 0 4
2171: ADD
2172: ST_TO_ADDR
// for i in tmp do
2173: LD_ADDR_VAR 0 3
2177: PUSH
2178: LD_VAR 0 2
2182: PUSH
2183: FOR_IN
2184: IFFALSE 2203
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2186: LD_VAR 0 3
2190: PPUSH
2191: LD_INT 14
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
2201: GO 2183
2203: POP
2204: POP
// if freedom then
2205: LD_EXP 3
2209: IFFALSE 2242
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_EXP 3
2220: PPUSH
2221: CALL_OW 250
2225: PPUSH
2226: LD_EXP 3
2230: PPUSH
2231: CALL_OW 251
2235: PPUSH
2236: CALL_OW 111
2240: GO 2257
// ComMoveXY ( tmp , 70 , 48 ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 70
2249: PPUSH
2250: LD_INT 48
2252: PPUSH
2253: CALL_OW 111
// end ;
2257: LD_VAR 0 1
2261: RET
// export function PrepareBelkov ; begin
2262: LD_INT 0
2264: PPUSH
// uc_side := 4 ;
2265: LD_ADDR_OWVAR 20
2269: PUSH
2270: LD_INT 4
2272: ST_TO_ADDR
// uc_nation := 3 ;
2273: LD_ADDR_OWVAR 21
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// InitHc ;
2281: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2285: LD_ADDR_EXP 50
2289: PUSH
2290: LD_STRING Belkov
2292: PPUSH
2293: CALL_OW 25
2297: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2298: LD_EXP 50
2302: PPUSH
2303: LD_INT 14
2305: PPUSH
2306: LD_INT 0
2308: PPUSH
2309: CALL_OW 49
// end ;
2313: LD_VAR 0 1
2317: RET
// export function PrepareGnyevko ; begin
2318: LD_INT 0
2320: PPUSH
// uc_side := 4 ;
2321: LD_ADDR_OWVAR 20
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// uc_nation := 3 ;
2329: LD_ADDR_OWVAR 21
2333: PUSH
2334: LD_INT 3
2336: ST_TO_ADDR
// InitHc ;
2337: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2341: LD_ADDR_EXP 51
2345: PUSH
2346: LD_STRING Gnyevko
2348: PPUSH
2349: CALL_OW 25
2353: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2354: LD_EXP 51
2358: PPUSH
2359: LD_INT 14
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 49
// end ;
2369: LD_VAR 0 1
2373: RET
// export function PrepareBurlak ; var i , tmp ; begin
2374: LD_INT 0
2376: PPUSH
2377: PPUSH
2378: PPUSH
// uc_side := 4 ;
2379: LD_ADDR_OWVAR 20
2383: PUSH
2384: LD_INT 4
2386: ST_TO_ADDR
// uc_nation := 3 ;
2387: LD_ADDR_OWVAR 21
2391: PUSH
2392: LD_INT 3
2394: ST_TO_ADDR
// InitHc ;
2395: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2399: LD_ADDR_EXP 49
2403: PUSH
2404: LD_STRING Burlak
2406: PPUSH
2407: CALL_OW 25
2411: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2412: LD_INT 24
2414: PUSH
2415: LD_INT 23
2417: PUSH
2418: LD_INT 22
2420: PUSH
2421: LD_INT 22
2423: PUSH
2424: EMPTY
2425: LIST
2426: LIST
2427: LIST
2428: LIST
2429: PUSH
2430: LD_OWVAR 67
2434: ARRAY
2435: PPUSH
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 1
2441: PPUSH
2442: LD_INT 45
2444: PUSH
2445: LD_INT 44
2447: PUSH
2448: LD_INT 43
2450: PUSH
2451: LD_INT 42
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: PUSH
2460: LD_OWVAR 67
2464: ARRAY
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL 22432 0 5
// Masha := CreateVehicle ;
2473: LD_ADDR_EXP 52
2477: PUSH
2478: CALL_OW 45
2482: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2483: LD_EXP 52
2487: PUSH
2488: LD_EXP 49
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PPUSH
2497: LD_INT 499
2499: PPUSH
2500: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2504: LD_EXP 52
2508: PPUSH
2509: LD_INT 3
2511: PPUSH
2512: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2516: LD_EXP 52
2520: PPUSH
2521: LD_INT 1
2523: PPUSH
2524: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2528: LD_INT 1
2530: PPUSH
2531: LD_INT 18
2533: PPUSH
2534: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2538: LD_INT 35
2540: PPUSH
2541: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: LD_INT 18
2552: PPUSH
2553: EMPTY
2554: PPUSH
2555: CALL_OW 70
2559: ST_TO_ADDR
// if tmp then
2560: LD_VAR 0 3
2564: IFFALSE 2598
// for i in tmp do
2566: LD_ADDR_VAR 0 2
2570: PUSH
2571: LD_VAR 0 3
2575: PUSH
2576: FOR_IN
2577: IFFALSE 2596
// ComMoveXY ( i , 114 , 9 ) ;
2579: LD_VAR 0 2
2583: PPUSH
2584: LD_INT 114
2586: PPUSH
2587: LD_INT 9
2589: PPUSH
2590: CALL_OW 111
2594: GO 2576
2596: POP
2597: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2598: LD_INT 18
2600: PPUSH
2601: EMPTY
2602: PPUSH
2603: CALL_OW 70
2607: NOT
2608: IFFALSE 2626
2610: PUSH
2611: LD_INT 123
2613: PPUSH
2614: LD_INT 3
2616: PPUSH
2617: CALL_OW 428
2621: PUSH
2622: LD_INT 0
2624: EQUAL
2625: AND
2626: IFFALSE 2538
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2628: LD_EXP 52
2632: PPUSH
2633: LD_INT 123
2635: PPUSH
2636: LD_INT 3
2638: PPUSH
2639: LD_INT 0
2641: PPUSH
2642: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2646: LD_EXP 49
2650: PPUSH
2651: LD_INT 125
2653: PPUSH
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 0
2659: PPUSH
2660: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2664: LD_EXP 49
2668: PPUSH
2669: LD_EXP 52
2673: PPUSH
2674: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2678: LD_INT 10
2680: PPUSH
2681: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2685: LD_EXP 52
2689: PPUSH
2690: LD_INT 110
2692: PPUSH
2693: LD_INT 10
2695: PPUSH
2696: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2700: LD_ADDR_EXP 45
2704: PUSH
2705: LD_STRING Petrovova
2707: PPUSH
2708: CALL_OW 25
2712: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2713: LD_ADDR_EXP 47
2717: PUSH
2718: LD_STRING Kuzmov
2720: PPUSH
2721: CALL_OW 25
2725: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2726: LD_ADDR_EXP 46
2730: PUSH
2731: LD_STRING Kovalyuk
2733: PPUSH
2734: CALL_OW 25
2738: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2739: LD_ADDR_EXP 44
2743: PUSH
2744: LD_STRING Lipshchin
2746: PPUSH
2747: CALL_OW 25
2751: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2752: LD_ADDR_EXP 48
2756: PUSH
2757: LD_STRING Karamazov
2759: PPUSH
2760: CALL_OW 25
2764: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2765: LD_ADDR_VAR 0 3
2769: PUSH
2770: LD_EXP 45
2774: PUSH
2775: LD_EXP 47
2779: PUSH
2780: LD_EXP 46
2784: PUSH
2785: LD_EXP 44
2789: PUSH
2790: LD_EXP 48
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: ST_TO_ADDR
// for i in tmp do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 3
2811: PUSH
2812: FOR_IN
2813: IFFALSE 2852
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2815: LD_VAR 0 2
2819: PPUSH
2820: LD_INT 399
2822: PPUSH
2823: LD_INT 799
2825: PPUSH
2826: CALL_OW 12
2830: PPUSH
2831: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2835: LD_VAR 0 2
2839: PPUSH
2840: LD_INT 19
2842: PPUSH
2843: LD_INT 0
2845: PPUSH
2846: CALL_OW 49
// end ;
2850: GO 2812
2852: POP
2853: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2854: LD_VAR 0 3
2858: PPUSH
2859: LD_INT 112
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: CALL_OW 111
// AddComHold ( tmp ) ;
2869: LD_VAR 0 3
2873: PPUSH
2874: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2878: LD_ADDR_VAR 0 2
2882: PUSH
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 25
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PPUSH
2898: CALL_OW 72
2902: PUSH
2903: FOR_IN
2904: IFFALSE 2944
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2906: LD_VAR 0 2
2910: PPUSH
2911: LD_INT 20
2913: PPUSH
2914: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2918: LD_VAR 0 2
2922: PPUSH
2923: LD_INT 147
2925: PPUSH
2926: LD_INT 45
2928: PPUSH
2929: CALL_OW 178
// AddComCrawl ( i ) ;
2933: LD_VAR 0 2
2937: PPUSH
2938: CALL_OW 197
// end ;
2942: GO 2903
2944: POP
2945: POP
// repeat wait ( 0 0$1 ) ;
2946: LD_INT 35
2948: PPUSH
2949: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2953: LD_EXP 52
2957: PPUSH
2958: LD_INT 110
2960: PPUSH
2961: LD_INT 10
2963: PPUSH
2964: CALL_OW 307
2968: IFTRUE 2982
2970: PUSH
2971: LD_EXP 52
2975: PPUSH
2976: CALL_OW 305
2980: NOT
2981: OR
2982: IFFALSE 2946
// ComStop ( Burlak ) ;
2984: LD_EXP 49
2988: PPUSH
2989: CALL_OW 141
// AddComHold ( Burlak ) ;
2993: LD_EXP 49
2997: PPUSH
2998: CALL_OW 200
// end ; end_of_file
3002: LD_VAR 0 1
3006: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
3007: LD_INT 0
3009: PPUSH
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
// uc_side := 3 ;
3014: LD_ADDR_OWVAR 20
3018: PUSH
3019: LD_INT 3
3021: ST_TO_ADDR
// uc_nation := 3 ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 3
3029: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3030: LD_ADDR_EXP 53
3034: PUSH
3035: LD_INT 47
3037: PPUSH
3038: LD_INT 4
3040: PPUSH
3041: LD_STRING 
3043: PPUSH
3044: LD_INT 7
3046: PUSH
3047: LD_INT 8
3049: PUSH
3050: LD_INT 9
3052: PUSH
3053: LD_INT 10
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PUSH
3062: LD_OWVAR 67
3066: ARRAY
3067: PPUSH
3068: LD_INT 10000
3070: PUSH
3071: LD_INT 3000
3073: PUSH
3074: LD_INT 300
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: LD_INT 9
3084: PUSH
3085: LD_INT 5
3087: PUSH
3088: LD_INT 6
3090: PUSH
3091: LD_INT 6
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: LIST
3099: PPUSH
3100: CALL 26269 0 6
3104: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3105: LD_ADDR_EXP 63
3109: PUSH
3110: LD_EXP 63
3114: PPUSH
3115: LD_INT 2
3117: PPUSH
3118: LD_EXP 53
3122: PPUSH
3123: CALL_OW 1
3127: ST_TO_ADDR
// tmp := [ ] ;
3128: LD_ADDR_VAR 0 4
3132: PUSH
3133: EMPTY
3134: ST_TO_ADDR
// for i = 1 to 4 do
3135: LD_ADDR_VAR 0 2
3139: PUSH
3140: DOUBLE
3141: LD_INT 1
3143: DEC
3144: ST_TO_ADDR
3145: LD_INT 4
3147: PUSH
3148: FOR_TO
3149: IFFALSE 3242
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3151: LD_INT 22
3153: PPUSH
3154: LD_INT 3
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 43
3162: PUSH
3163: LD_INT 45
3165: PUSH
3166: LD_INT 45
3168: PUSH
3169: LD_INT 44
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: PUSH
3178: LD_VAR 0 2
3182: PUSH
3183: LD_INT 4
3185: MOD
3186: PUSH
3187: LD_INT 1
3189: PLUS
3190: ARRAY
3191: PPUSH
3192: LD_INT 100
3194: PPUSH
3195: CALL 22432 0 5
// veh := CreateVehicle ;
3199: LD_ADDR_VAR 0 3
3203: PUSH
3204: CALL_OW 45
3208: ST_TO_ADDR
// tmp := tmp ^ veh ;
3209: LD_ADDR_VAR 0 4
3213: PUSH
3214: LD_VAR 0 4
3218: PUSH
3219: LD_VAR 0 3
3223: ADD
3224: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3225: LD_VAR 0 3
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 49
// end ;
3240: GO 3148
3242: POP
3243: POP
// russian_guard := tmp ;
3244: LD_ADDR_EXP 54
3248: PUSH
3249: LD_VAR 0 4
3253: ST_TO_ADDR
// if Difficulty >= 3 then
3254: LD_OWVAR 67
3258: PUSH
3259: LD_INT 3
3261: GREATEREQUAL
3262: IFFALSE 3326
// begin bc_type := b_breastwork ;
3264: LD_ADDR_OWVAR 42
3268: PUSH
3269: LD_INT 31
3271: ST_TO_ADDR
// bc_level := 10 ;
3272: LD_ADDR_OWVAR 43
3276: PUSH
3277: LD_INT 10
3279: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3280: LD_ADDR_VAR 0 5
3284: PUSH
3285: LD_INT 96
3287: PPUSH
3288: LD_INT 105
3290: PPUSH
3291: LD_INT 3
3293: PPUSH
3294: CALL_OW 47
3298: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3299: LD_INT 0
3301: PPUSH
3302: LD_INT 9
3304: PPUSH
3305: LD_INT 10
3307: PPUSH
3308: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3312: CALL_OW 44
3316: PPUSH
3317: LD_VAR 0 5
3321: PPUSH
3322: CALL_OW 52
// end ; end ;
3326: LD_VAR 0 1
3330: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3331: LD_INT 47
3333: PPUSH
3334: CALL_OW 302
3338: IFFALSE 3346
3340: PUSH
3341: LD_EXP 7
3345: AND
3346: IFFALSE 4104
3348: GO 3350
3350: DISABLE
3351: LD_INT 0
3353: PPUSH
3354: PPUSH
3355: PPUSH
3356: PPUSH
3357: PPUSH
3358: PPUSH
3359: PPUSH
// begin enable ;
3360: ENABLE
// base := 2 ;
3361: LD_ADDR_VAR 0 3
3365: PUSH
3366: LD_INT 2
3368: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3369: LD_ADDR_VAR 0 4
3373: PUSH
3374: LD_INT 22
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 45
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 21
3394: PUSH
3395: LD_INT 1
3397: PUSH
3398: LD_INT 3
3400: PUSH
3401: LD_INT 45
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: PUSH
3410: LD_INT 22
3412: PUSH
3413: LD_INT 1
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 45
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: PUSH
3428: LD_INT 23
3430: PUSH
3431: LD_INT 1
3433: PUSH
3434: LD_INT 3
3436: PUSH
3437: LD_INT 46
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: LIST
3444: LIST
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: ST_TO_ADDR
// amount := Difficulty ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_OWVAR 67
3461: ST_TO_ADDR
// if tick > 30 30$00 then
3462: LD_OWVAR 1
3466: PUSH
3467: LD_INT 63000
3469: GREATER
3470: IFFALSE 3507
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3472: LD_ADDR_VAR 0 7
3476: PUSH
3477: LD_VAR 0 7
3481: PUSH
3482: LD_INT 2
3484: PUSH
3485: LD_INT 3
3487: PUSH
3488: LD_INT 4
3490: PUSH
3491: LD_INT 4
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: PUSH
3500: LD_OWVAR 67
3504: ARRAY
3505: PLUS
3506: ST_TO_ADDR
// for i = 1 to amount do
3507: LD_ADDR_VAR 0 1
3511: PUSH
3512: DOUBLE
3513: LD_INT 1
3515: DEC
3516: ST_TO_ADDR
3517: LD_VAR 0 7
3521: PUSH
3522: FOR_TO
3523: IFFALSE 3611
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3525: LD_ADDR_VAR 0 4
3529: PUSH
3530: LD_VAR 0 4
3534: PPUSH
3535: LD_VAR 0 4
3539: PUSH
3540: LD_INT 1
3542: PLUS
3543: PPUSH
3544: LD_INT 23
3546: PUSH
3547: LD_INT 24
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: PUSH
3554: LD_INT 1
3556: PPUSH
3557: LD_INT 2
3559: PPUSH
3560: CALL_OW 12
3564: ARRAY
3565: PUSH
3566: LD_INT 1
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: LD_INT 46
3574: PUSH
3575: LD_INT 47
3577: PUSH
3578: LD_INT 45
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 12
3596: ARRAY
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: PPUSH
3604: CALL_OW 2
3608: ST_TO_ADDR
3609: GO 3522
3611: POP
3612: POP
// p := 1 ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3621: LD_VAR 0 3
3625: PPUSH
3626: LD_VAR 0 4
3630: PPUSH
3631: CALL 85504 0 2
// repeat wait ( 0 0$1 ) ;
3635: LD_INT 35
3637: PPUSH
3638: CALL_OW 67
// p := Inc ( p ) ;
3642: LD_ADDR_VAR 0 2
3646: PUSH
3647: LD_VAR 0 2
3651: PPUSH
3652: CALL 56985 0 1
3656: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_INT 1
3664: PPUSH
3665: CALL 86960 0 2
3669: PUSH
3670: LD_VAR 0 7
3674: GREATEREQUAL
3675: IFTRUE 3687
3677: PUSH
3678: LD_VAR 0 2
3682: PUSH
3683: LD_INT 60
3685: GREATEREQUAL
3686: OR
3687: IFFALSE 3635
// wait ( 0 0$30 ) ;
3689: LD_INT 1050
3691: PPUSH
3692: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3696: LD_ADDR_VAR 0 5
3700: PUSH
3701: LD_INT 71
3703: PUSH
3704: LD_INT 19
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PUSH
3711: LD_INT 91
3713: PUSH
3714: LD_INT 67
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 52
3723: PUSH
3724: LD_INT 44
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 68
3733: PUSH
3734: LD_INT 48
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3747: LD_ADDR_VAR 0 6
3751: PUSH
3752: LD_INT 22
3754: PUSH
3755: LD_INT 3
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 21
3764: PUSH
3765: LD_INT 2
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 3
3774: PUSH
3775: LD_INT 2
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: LD_INT 52
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 34
3790: PUSH
3791: LD_INT 51
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: LIST
3811: PPUSH
3812: CALL_OW 69
3816: PUSH
3817: LD_EXP 85
3821: PUSH
3822: LD_VAR 0 3
3826: ARRAY
3827: DIFF
3828: ST_TO_ADDR
// if not attackers then
3829: LD_VAR 0 6
3833: NOT
3834: IFFALSE 3838
// exit ;
3836: GO 4104
// ru_attackers := attackers ;
3838: LD_ADDR_EXP 55
3842: PUSH
3843: LD_VAR 0 6
3847: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3848: LD_ADDR_EXP 82
3852: PUSH
3853: LD_EXP 82
3857: PPUSH
3858: LD_VAR 0 3
3862: PPUSH
3863: LD_EXP 82
3867: PUSH
3868: LD_VAR 0 3
3872: ARRAY
3873: PUSH
3874: LD_VAR 0 6
3878: DIFF
3879: PPUSH
3880: CALL_OW 1
3884: ST_TO_ADDR
// for i = 1 to attackers do
3885: LD_ADDR_VAR 0 1
3889: PUSH
3890: DOUBLE
3891: LD_INT 1
3893: DEC
3894: ST_TO_ADDR
3895: LD_VAR 0 6
3899: PUSH
3900: FOR_TO
3901: IFFALSE 3978
// begin case i mod 3 of 0 :
3903: LD_VAR 0 1
3907: PUSH
3908: LD_INT 3
3910: MOD
3911: PUSH
3912: LD_INT 0
3914: DOUBLE
3915: EQUAL
3916: IFTRUE 3920
3918: GO 3923
3920: POP
// ; 1 :
3921: GO 3976
3923: LD_INT 1
3925: DOUBLE
3926: EQUAL
3927: IFTRUE 3931
3929: GO 3949
3931: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3932: LD_VAR 0 1
3936: PPUSH
3937: LD_INT 32
3939: PPUSH
3940: LD_INT 49
3942: PPUSH
3943: CALL_OW 114
3947: GO 3976
3949: LD_INT 2
3951: DOUBLE
3952: EQUAL
3953: IFTRUE 3957
3955: GO 3975
3957: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3958: LD_VAR 0 1
3962: PPUSH
3963: LD_INT 117
3965: PPUSH
3966: LD_INT 107
3968: PPUSH
3969: CALL_OW 114
3973: GO 3976
3975: POP
// end ;
3976: GO 3900
3978: POP
3979: POP
// p := 0 ;
3980: LD_ADDR_VAR 0 2
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3988: LD_INT 35
3990: PPUSH
3991: CALL_OW 67
// p := Inc ( p ) ;
3995: LD_ADDR_VAR 0 2
3999: PUSH
4000: LD_VAR 0 2
4004: PPUSH
4005: CALL 56985 0 1
4009: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4010: LD_VAR 0 6
4014: PPUSH
4015: LD_INT 60
4017: PUSH
4018: EMPTY
4019: LIST
4020: PPUSH
4021: CALL_OW 72
4025: NOT
4026: IFTRUE 4038
4028: PUSH
4029: LD_VAR 0 2
4033: PUSH
4034: LD_INT 30
4036: GREATER
4037: OR
4038: IFFALSE 3988
// if not first_attack then
4040: LD_EXP 8
4044: NOT
4045: IFFALSE 4055
// first_attack := true ;
4047: LD_ADDR_EXP 8
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4055: LD_INT 35
4057: PPUSH
4058: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4062: LD_ADDR_VAR 0 6
4066: PUSH
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_INT 50
4074: PUSH
4075: EMPTY
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4083: LD_VAR 0 6
4087: PPUSH
4088: LD_VAR 0 5
4092: PPUSH
4093: CALL 58378 0 2
// until not attackers ;
4097: LD_VAR 0 6
4101: NOT
4102: IFFALSE 4055
// end ;
4104: PPOPN 7
4106: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4107: LD_INT 0
4109: PPUSH
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
// uc_side := 6 ;
4115: LD_ADDR_OWVAR 20
4119: PUSH
4120: LD_INT 6
4122: ST_TO_ADDR
// uc_nation := 3 ;
4123: LD_ADDR_OWVAR 21
4127: PUSH
4128: LD_INT 3
4130: ST_TO_ADDR
// InitHc ;
4131: CALL_OW 19
// InitVc ;
4135: CALL_OW 20
// tmp := [ ] ;
4139: LD_ADDR_VAR 0 3
4143: PUSH
4144: EMPTY
4145: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4146: LD_ADDR_VAR 0 2
4150: PUSH
4151: DOUBLE
4152: LD_INT 1
4154: DEC
4155: ST_TO_ADDR
4156: LD_INT 4
4158: PUSH
4159: LD_INT 5
4161: PUSH
4162: LD_INT 6
4164: PUSH
4165: LD_INT 7
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: PUSH
4174: LD_OWVAR 67
4178: ARRAY
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4435
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4183: LD_ADDR_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: PUSH
4191: LD_INT 22
4193: PUSH
4194: LD_INT 24
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4214: LD_VAR 0 5
4218: PUSH
4219: LD_INT 21
4221: DOUBLE
4222: EQUAL
4223: IFTRUE 4233
4225: LD_INT 22
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4267
4233: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4234: LD_ADDR_VAR 0 6
4238: PUSH
4239: LD_INT 45
4241: PUSH
4242: LD_INT 44
4244: PUSH
4245: LD_INT 43
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 3
4258: PPUSH
4259: CALL_OW 12
4263: ARRAY
4264: ST_TO_ADDR
4265: GO 4314
4267: LD_INT 24
4269: DOUBLE
4270: EQUAL
4271: IFTRUE 4275
4273: GO 4313
4275: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4276: LD_ADDR_VAR 0 6
4280: PUSH
4281: LD_INT 46
4283: PUSH
4284: LD_INT 47
4286: PUSH
4287: LD_INT 45
4289: PUSH
4290: LD_INT 46
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 1
4301: PPUSH
4302: LD_INT 4
4304: PPUSH
4305: CALL_OW 12
4309: ARRAY
4310: ST_TO_ADDR
4311: GO 4314
4313: POP
// uc_side := 6 ;
4314: LD_ADDR_OWVAR 20
4318: PUSH
4319: LD_INT 6
4321: ST_TO_ADDR
// uc_nation := 3 ;
4322: LD_ADDR_OWVAR 21
4326: PUSH
4327: LD_INT 3
4329: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4330: LD_VAR 0 5
4334: PPUSH
4335: LD_INT 1
4337: PUSH
4338: LD_INT 3
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: LD_INT 2
4350: PPUSH
4351: CALL_OW 12
4355: ARRAY
4356: PPUSH
4357: LD_INT 3
4359: PPUSH
4360: LD_VAR 0 6
4364: PPUSH
4365: LD_INT 70
4367: PPUSH
4368: LD_INT 90
4370: PPUSH
4371: CALL_OW 12
4375: PPUSH
4376: CALL 22432 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 4
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4390: LD_VAR 0 4
4394: PPUSH
4395: LD_INT 5
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4402: LD_VAR 0 4
4406: PPUSH
4407: LD_INT 16
4409: PPUSH
4410: LD_INT 0
4412: PPUSH
4413: CALL_OW 49
// tmp := tmp ^ veh ;
4417: LD_ADDR_VAR 0 3
4421: PUSH
4422: LD_VAR 0 3
4426: PUSH
4427: LD_VAR 0 4
4431: ADD
4432: ST_TO_ADDR
// end ;
4433: GO 4180
4435: POP
4436: POP
// if not tmp then
4437: LD_VAR 0 3
4441: NOT
4442: IFFALSE 4446
// exit ;
4444: GO 4540
// repeat wait ( 0 0$2 ) ;
4446: LD_INT 70
4448: PPUSH
4449: CALL_OW 67
// for i in tmp do
4453: LD_ADDR_VAR 0 2
4457: PUSH
4458: LD_VAR 0 3
4462: PUSH
4463: FOR_IN
4464: IFFALSE 4531
// if IsOk ( i ) then
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 302
4475: IFFALSE 4513
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4477: LD_VAR 0 2
4481: PPUSH
4482: LD_INT 22
4484: PUSH
4485: LD_INT 7
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PPUSH
4492: CALL_OW 69
4496: PPUSH
4497: LD_VAR 0 2
4501: PPUSH
4502: CALL_OW 74
4506: PPUSH
4507: CALL_OW 115
4511: GO 4529
// tmp := tmp diff i ;
4513: LD_ADDR_VAR 0 3
4517: PUSH
4518: LD_VAR 0 3
4522: PUSH
4523: LD_VAR 0 2
4527: DIFF
4528: ST_TO_ADDR
4529: GO 4463
4531: POP
4532: POP
// until not tmp ;
4533: LD_VAR 0 3
4537: NOT
4538: IFFALSE 4446
// end ;
4540: LD_VAR 0 1
4544: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4545: LD_EXP 8
4549: IFFALSE 4560
4551: PUSH
4552: LD_INT 47
4554: PPUSH
4555: CALL_OW 302
4559: AND
4560: IFFALSE 4575
4562: PUSH
4563: LD_INT 47
4565: PPUSH
4566: CALL_OW 255
4570: PUSH
4571: LD_INT 3
4573: EQUAL
4574: AND
4575: IFFALSE 4583
4577: PUSH
4578: LD_EXP 6
4582: AND
4583: IFFALSE 4593
4585: GO 4587
4587: DISABLE
// begin enable ;
4588: ENABLE
// PrepareRussianAttack ;
4589: CALL 4107 0 0
// end ; end_of_file
4593: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4594: LD_INT 0
4596: PPUSH
4597: PPUSH
4598: PPUSH
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
// uc_side := 2 ;
4605: LD_ADDR_OWVAR 20
4609: PUSH
4610: LD_INT 2
4612: ST_TO_ADDR
// uc_nation := 2 ;
4613: LD_ADDR_OWVAR 21
4617: PUSH
4618: LD_INT 2
4620: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4621: LD_INT 2
4623: PPUSH
4624: LD_INT 28
4626: PPUSH
4627: CALL 60733 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4631: LD_INT 25
4633: PPUSH
4634: LD_INT 0
4636: PUSH
4637: LD_INT 0
4639: PUSH
4640: LD_INT 6
4642: PUSH
4643: LD_INT 8
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: PPUSH
4658: CALL 8161 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4662: LD_INT 26
4664: PPUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 4
4670: PUSH
4671: LD_INT 8
4673: PUSH
4674: LD_INT 12
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_OWVAR 67
4687: ARRAY
4688: PPUSH
4689: CALL 8161 0 2
// if Difficulty > 2 then
4693: LD_OWVAR 67
4697: PUSH
4698: LD_INT 2
4700: GREATER
4701: IFFALSE 4871
// begin bc_type := b_breastwork ;
4703: LD_ADDR_OWVAR 42
4707: PUSH
4708: LD_INT 31
4710: ST_TO_ADDR
// bc_level := 8 ;
4711: LD_ADDR_OWVAR 43
4715: PUSH
4716: LD_INT 8
4718: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4719: LD_ADDR_VAR 0 5
4723: PUSH
4724: LD_INT 27
4726: PUSH
4727: LD_INT 29
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: FOR_IN
4735: IFFALSE 4869
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4737: LD_ADDR_VAR 0 6
4741: PUSH
4742: LD_VAR 0 5
4746: PPUSH
4747: LD_INT 1
4749: PPUSH
4750: CALL 60331 0 2
4754: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4755: LD_ADDR_VAR 0 3
4759: PUSH
4760: LD_VAR 0 6
4764: PUSH
4765: LD_INT 1
4767: ARRAY
4768: PPUSH
4769: LD_VAR 0 6
4773: PUSH
4774: LD_INT 2
4776: ARRAY
4777: PPUSH
4778: LD_VAR 0 6
4782: PUSH
4783: LD_INT 3
4785: ARRAY
4786: PPUSH
4787: CALL_OW 47
4791: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4792: LD_INT 0
4794: PPUSH
4795: LD_INT 5
4797: PUSH
4798: LD_OWVAR 67
4802: PLUS
4803: PPUSH
4804: CALL_OW 381
// un := CreateHuman ;
4808: LD_ADDR_VAR 0 8
4812: PUSH
4813: CALL_OW 44
4817: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4818: LD_VAR 0 8
4822: PPUSH
4823: LD_VAR 0 3
4827: PPUSH
4828: CALL_OW 254
4832: PUSH
4833: LD_INT 3
4835: MINUS
4836: PPUSH
4837: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4841: LD_VAR 0 8
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4853: LD_VAR 0 8
4857: PPUSH
4858: LD_VAR 0 3
4862: PPUSH
4863: CALL_OW 52
// end ;
4867: GO 4734
4869: POP
4870: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4871: LD_ADDR_EXP 58
4875: PUSH
4876: LD_STRING Abdul
4878: PPUSH
4879: CALL_OW 25
4883: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4884: LD_EXP 58
4888: PPUSH
4889: LD_INT 11
4891: PPUSH
4892: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4896: LD_EXP 58
4900: PPUSH
4901: LD_INT 1
4903: PPUSH
4904: CALL_OW 52
// vc_chassis := 31 ;
4908: LD_ADDR_OWVAR 37
4912: PUSH
4913: LD_INT 31
4915: ST_TO_ADDR
// vc_control := control_rider ;
4916: LD_ADDR_OWVAR 38
4920: PUSH
4921: LD_INT 4
4923: ST_TO_ADDR
// mastodont := CreateVehicle ;
4924: LD_ADDR_EXP 59
4928: PUSH
4929: CALL_OW 45
4933: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4934: LD_EXP 59
4938: PPUSH
4939: LD_INT 153
4941: PPUSH
4942: LD_INT 71
4944: PPUSH
4945: LD_INT 0
4947: PPUSH
4948: CALL_OW 48
// InitVc ;
4952: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4956: LD_ADDR_EXP 56
4960: PUSH
4961: LD_INT 1
4963: PPUSH
4964: LD_INT 3
4966: PPUSH
4967: LD_STRING kaba
4969: PPUSH
4970: LD_INT 7
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: LD_INT 9
4978: PUSH
4979: LD_INT 10
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: PPUSH
4994: LD_INT 5000
4996: PUSH
4997: LD_INT 1000
4999: PUSH
5000: LD_INT 300
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_INT 11
5010: PUSH
5011: LD_INT 5
5013: PUSH
5014: LD_INT 6
5016: PUSH
5017: LD_INT 7
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL 26269 0 6
5030: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5031: LD_ADDR_EXP 63
5035: PUSH
5036: LD_EXP 63
5040: PPUSH
5041: LD_INT 1
5043: PPUSH
5044: LD_EXP 56
5048: PPUSH
5049: CALL_OW 1
5053: ST_TO_ADDR
// tmp := [ ] ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: EMPTY
5060: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5061: LD_ADDR_OWVAR 37
5065: PUSH
5066: LD_INT 13
5068: ST_TO_ADDR
// vc_engine := engine_siberite ;
5069: LD_ADDR_OWVAR 39
5073: PUSH
5074: LD_INT 3
5076: ST_TO_ADDR
// vc_control := control_manual ;
5077: LD_ADDR_OWVAR 38
5081: PUSH
5082: LD_INT 1
5084: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5085: LD_ADDR_OWVAR 40
5089: PUSH
5090: LD_INT 31
5092: ST_TO_ADDR
// for i = 1 to 3 do
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: DOUBLE
5099: LD_INT 1
5101: DEC
5102: ST_TO_ADDR
5103: LD_INT 3
5105: PUSH
5106: FOR_TO
5107: IFFALSE 5355
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5109: LD_ADDR_VAR 0 7
5113: PUSH
5114: LD_INT 153
5116: PUSH
5117: LD_INT 71
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 155
5126: PUSH
5127: LD_INT 81
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_VAR 0 2
5142: PUSH
5143: LD_INT 2
5145: MOD
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ARRAY
5151: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 7
5160: PUSH
5161: LD_INT 8
5163: PUSH
5164: LD_INT 10
5166: PUSH
5167: LD_INT 10
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_OWVAR 67
5180: ARRAY
5181: PPUSH
5182: CALL_OW 380
// un := CreateVehicle ;
5186: LD_ADDR_VAR 0 8
5190: PUSH
5191: CALL_OW 45
5195: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5196: LD_VAR 0 8
5200: PPUSH
5201: LD_INT 0
5203: PPUSH
5204: LD_INT 5
5206: PPUSH
5207: CALL_OW 12
5211: PPUSH
5212: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5216: LD_VAR 0 8
5220: PPUSH
5221: LD_VAR 0 7
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PPUSH
5230: LD_VAR 0 7
5234: PUSH
5235: LD_INT 2
5237: ARRAY
5238: PPUSH
5239: LD_INT 6
5241: PPUSH
5242: LD_INT 0
5244: PPUSH
5245: CALL_OW 50
// un2 := CreateHuman ;
5249: LD_ADDR_VAR 0 9
5253: PUSH
5254: CALL_OW 44
5258: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5259: LD_VAR 0 9
5263: PPUSH
5264: LD_VAR 0 8
5268: PPUSH
5269: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5273: LD_ADDR_EXP 63
5277: PUSH
5278: LD_EXP 63
5282: PPUSH
5283: LD_INT 1
5285: PUSH
5286: LD_EXP 63
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: PUSH
5295: LD_INT 1
5297: PLUS
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PPUSH
5303: LD_VAR 0 8
5307: PPUSH
5308: CALL 22554 0 3
5312: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5313: LD_ADDR_EXP 63
5317: PUSH
5318: LD_EXP 63
5322: PPUSH
5323: LD_INT 1
5325: PUSH
5326: LD_EXP 63
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 1
5337: PLUS
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PPUSH
5343: LD_VAR 0 9
5347: PPUSH
5348: CALL 22554 0 3
5352: ST_TO_ADDR
// end ;
5353: GO 5106
5355: POP
5356: POP
// for i = 1 to 5 do
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: DOUBLE
5363: LD_INT 1
5365: DEC
5366: ST_TO_ADDR
5367: LD_INT 5
5369: PUSH
5370: FOR_TO
5371: IFFALSE 5464
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5373: LD_INT 13
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 1
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 28
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: LD_INT 26
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: LD_VAR 0 2
5404: PUSH
5405: LD_INT 4
5407: MOD
5408: PUSH
5409: LD_INT 1
5411: PLUS
5412: ARRAY
5413: PPUSH
5414: LD_INT 100
5416: PPUSH
5417: CALL 22432 0 5
// veh := CreateVehicle ;
5421: LD_ADDR_VAR 0 4
5425: PUSH
5426: CALL_OW 45
5430: ST_TO_ADDR
// tmp := tmp ^ veh ;
5431: LD_ADDR_VAR 0 6
5435: PUSH
5436: LD_VAR 0 6
5440: PUSH
5441: LD_VAR 0 4
5445: ADD
5446: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5447: LD_VAR 0 4
5451: PPUSH
5452: LD_INT 1
5454: PPUSH
5455: LD_INT 0
5457: PPUSH
5458: CALL_OW 49
// end ;
5462: GO 5370
5464: POP
5465: POP
// arabian_guard := tmp ;
5466: LD_ADDR_EXP 57
5470: PUSH
5471: LD_VAR 0 6
5475: ST_TO_ADDR
// end ;
5476: LD_VAR 0 1
5480: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5481: LD_INT 22
5483: PUSH
5484: LD_INT 7
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 91
5493: PUSH
5494: LD_INT 1
5496: PUSH
5497: LD_INT 12
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: IFTRUE 5530
5515: PUSH
5516: LD_EXP 59
5520: PPUSH
5521: CALL_OW 256
5525: PUSH
5526: LD_INT 990
5528: LESS
5529: OR
5530: IFTRUE 5547
5532: PUSH
5533: LD_EXP 58
5537: PPUSH
5538: CALL_OW 256
5542: PUSH
5543: LD_INT 990
5545: LESS
5546: OR
5547: IFFALSE 5692
5549: GO 5551
5551: DISABLE
// begin if IsInUnit ( Abdul ) then
5552: LD_EXP 58
5556: PPUSH
5557: CALL_OW 310
5561: IFFALSE 5572
// ComExitBuilding ( Abdul ) ;
5563: LD_EXP 58
5567: PPUSH
5568: CALL_OW 122
// if Mastodont then
5572: LD_EXP 59
5576: IFFALSE 5593
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5578: LD_EXP 59
5582: PPUSH
5583: LD_INT 205
5585: PPUSH
5586: LD_INT 132
5588: PPUSH
5589: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5593: LD_EXP 58
5597: PPUSH
5598: LD_INT 205
5600: PPUSH
5601: LD_INT 132
5603: PPUSH
5604: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5608: LD_INT 35
5610: PPUSH
5611: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5615: LD_EXP 58
5619: PPUSH
5620: LD_INT 21
5622: PPUSH
5623: CALL_OW 308
5627: IFFALSE 5608
// RemoveUnit ( Abdul ) ;
5629: LD_EXP 58
5633: PPUSH
5634: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5638: LD_INT 35
5640: PPUSH
5641: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5645: LD_EXP 59
5649: PPUSH
5650: LD_INT 21
5652: PPUSH
5653: CALL_OW 308
5657: IFTRUE 5670
5659: PUSH
5660: LD_EXP 59
5664: PPUSH
5665: CALL_OW 301
5669: OR
5670: IFFALSE 5638
// if IsOk ( Mastodont ) then
5672: LD_EXP 59
5676: PPUSH
5677: CALL_OW 302
5681: IFFALSE 5692
// RemoveUnit ( Mastodont ) ;
5683: LD_EXP 59
5687: PPUSH
5688: CALL_OW 64
// end ;
5692: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5693: LD_EXP 58
5697: PPUSH
5698: CALL_OW 301
5702: IFTRUE 5810
5704: PUSH
5705: LD_INT 22
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 2
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 25
5740: PUSH
5741: LD_INT 3
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 25
5750: PUSH
5751: LD_INT 4
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 25
5760: PUSH
5761: LD_INT 8
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PPUSH
5780: CALL_OW 69
5784: PUSH
5785: LD_INT 16
5787: PUSH
5788: LD_INT 19
5790: PUSH
5791: LD_INT 22
5793: PUSH
5794: LD_INT 22
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: LESS
5809: OR
5810: IFFALSE 6483
5812: GO 5814
5814: DISABLE
5815: LD_INT 0
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
// begin MC_Kill ( 1 ) ;
5823: LD_INT 1
5825: PPUSH
5826: CALL 61223 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: LD_INT 22
5837: PUSH
5838: LD_INT 2
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 2
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 25
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 25
5880: PUSH
5881: LD_INT 4
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 25
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL_OW 69
5914: ST_TO_ADDR
// for i in tmp do
5915: LD_ADDR_VAR 0 5
5919: PUSH
5920: LD_VAR 0 2
5924: PUSH
5925: FOR_IN
5926: IFFALSE 5942
// SetTag ( i , 10 ) ;
5928: LD_VAR 0 5
5932: PPUSH
5933: LD_INT 10
5935: PPUSH
5936: CALL_OW 109
5940: GO 5925
5942: POP
5943: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5944: LD_ADDR_VAR 0 3
5948: PUSH
5949: LD_INT 22
5951: PUSH
5952: LD_INT 2
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 21
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PPUSH
5973: CALL_OW 69
5977: PUSH
5978: LD_VAR 0 2
5982: DIFF
5983: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5984: LD_ADDR_VAR 0 1
5988: PUSH
5989: LD_INT 22
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 21
6001: PUSH
6002: LD_INT 2
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PUSH
6009: LD_INT 24
6011: PUSH
6012: LD_INT 300
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 69
6028: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
6029: LD_ADDR_VAR 0 4
6033: PUSH
6034: LD_VAR 0 1
6038: PPUSH
6039: LD_INT 33
6041: PUSH
6042: LD_INT 1
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: LD_INT 58
6051: PUSH
6052: EMPTY
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PPUSH
6059: CALL_OW 72
6063: ST_TO_ADDR
// for i in tmp do
6064: LD_ADDR_VAR 0 5
6068: PUSH
6069: LD_VAR 0 2
6073: PUSH
6074: FOR_IN
6075: IFFALSE 6259
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6077: LD_VAR 0 5
6081: PUSH
6082: LD_INT 55
6084: PUSH
6085: EMPTY
6086: LIST
6087: PPUSH
6088: CALL_OW 69
6092: IN
6093: IFFALSE 6112
// begin AddComMoveXY ( i , 209 , 132 ) ;
6095: LD_VAR 0 5
6099: PPUSH
6100: LD_INT 209
6102: PPUSH
6103: LD_INT 132
6105: PPUSH
6106: CALL_OW 171
// continue ;
6110: GO 6074
// end ; if IsInUnit ( i ) then
6112: LD_VAR 0 5
6116: PPUSH
6117: CALL_OW 310
6121: IFFALSE 6139
// begin ComExitBuilding ( i ) ;
6123: LD_VAR 0 5
6127: PPUSH
6128: CALL_OW 122
// wait ( 3 ) ;
6132: LD_INT 3
6134: PPUSH
6135: CALL_OW 67
// end ; if tmp_empty then
6139: LD_VAR 0 4
6143: IFFALSE 6242
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6145: LD_VAR 0 5
6149: PPUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: PPUSH
6165: CALL_OW 296
6169: PUSH
6170: LD_INT 25
6172: LESS
6173: IFFALSE 6242
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6175: LD_ADDR_VAR 0 6
6179: PUSH
6180: LD_VAR 0 4
6184: PPUSH
6185: LD_VAR 0 5
6189: PPUSH
6190: CALL_OW 74
6194: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6195: LD_VAR 0 5
6199: PPUSH
6200: LD_VAR 0 6
6204: PPUSH
6205: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6209: LD_VAR 0 5
6213: PPUSH
6214: LD_INT 209
6216: PPUSH
6217: LD_INT 132
6219: PPUSH
6220: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6224: LD_ADDR_VAR 0 4
6228: PUSH
6229: LD_VAR 0 4
6233: PUSH
6234: LD_VAR 0 6
6238: DIFF
6239: ST_TO_ADDR
// continue ;
6240: GO 6074
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6242: LD_VAR 0 5
6246: PPUSH
6247: LD_INT 201
6249: PPUSH
6250: LD_INT 132
6252: PPUSH
6253: CALL_OW 171
// end ;
6257: GO 6074
6259: POP
6260: POP
// for i in tmp_ape do
6261: LD_ADDR_VAR 0 5
6265: PUSH
6266: LD_VAR 0 3
6270: PUSH
6271: FOR_IN
6272: IFFALSE 6311
// begin if IsInUnit ( i ) then
6274: LD_VAR 0 5
6278: PPUSH
6279: CALL_OW 310
6283: IFFALSE 6294
// ComExitBuilding ( i ) ;
6285: LD_VAR 0 5
6289: PPUSH
6290: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6294: LD_VAR 0 5
6298: PPUSH
6299: LD_INT 201
6301: PPUSH
6302: LD_INT 132
6304: PPUSH
6305: CALL_OW 171
// end ;
6309: GO 6271
6311: POP
6312: POP
// repeat wait ( 0 0$1 ) ;
6313: LD_INT 35
6315: PPUSH
6316: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6320: LD_ADDR_VAR 0 5
6324: PUSH
6325: LD_VAR 0 2
6329: PUSH
6330: LD_VAR 0 3
6334: UNION
6335: PUSH
6336: LD_VAR 0 1
6340: UNION
6341: PUSH
6342: FOR_IN
6343: IFFALSE 6374
// if not HasTask ( i ) then
6345: LD_VAR 0 5
6349: PPUSH
6350: CALL_OW 314
6354: NOT
6355: IFFALSE 6372
// ComMoveXY ( i , 201 , 132 ) ;
6357: LD_VAR 0 5
6361: PPUSH
6362: LD_INT 201
6364: PPUSH
6365: LD_INT 132
6367: PPUSH
6368: CALL_OW 111
6372: GO 6342
6374: POP
6375: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6376: LD_INT 21
6378: PPUSH
6379: LD_INT 22
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PPUSH
6389: CALL_OW 70
6393: IFFALSE 6434
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6395: LD_ADDR_VAR 0 5
6399: PUSH
6400: LD_INT 21
6402: PPUSH
6403: LD_INT 22
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 70
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6432
// RemoveUnit ( i ) ;
6421: LD_VAR 0 5
6425: PPUSH
6426: CALL_OW 64
6430: GO 6418
6432: POP
6433: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6434: LD_INT 22
6436: PUSH
6437: LD_INT 2
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 2
6446: PUSH
6447: LD_INT 21
6449: PUSH
6450: LD_INT 1
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PUSH
6457: LD_INT 21
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PPUSH
6476: CALL_OW 69
6480: NOT
6481: IFFALSE 6313
// end ;
6483: PPOPN 6
6485: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6486: LD_EXP 10
6490: IFFALSE 6513
6492: PUSH
6493: LD_INT 92
6495: PPUSH
6496: LD_INT 40
6498: PPUSH
6499: CALL_OW 428
6503: PPUSH
6504: CALL_OW 266
6508: PUSH
6509: LD_INT 30
6511: EQUAL
6512: AND
6513: IFFALSE 6709
6515: GO 6517
6517: DISABLE
6518: LD_INT 0
6520: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_EXP 63
6530: PUSH
6531: LD_INT 1
6533: ARRAY
6534: PPUSH
6535: LD_INT 25
6537: PUSH
6538: LD_INT 4
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 72
6549: ST_TO_ADDR
// if not sci then
6550: LD_VAR 0 1
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6709
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6559: LD_ADDR_EXP 63
6563: PUSH
6564: LD_EXP 63
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: LD_EXP 63
6576: PUSH
6577: LD_INT 1
6579: ARRAY
6580: PUSH
6581: LD_VAR 0 1
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: DIFF
6590: PPUSH
6591: CALL_OW 1
6595: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 310
6609: IFFALSE 6624
// ComExitBuilding ( sci [ 1 ] ) ;
6611: LD_VAR 0 1
6615: PUSH
6616: LD_INT 1
6618: ARRAY
6619: PPUSH
6620: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6624: LD_INT 2
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: LD_INT 20
6635: PPUSH
6636: CALL 23824 0 4
6640: PUSH
6641: LD_INT 4
6643: ARRAY
6644: PUSH
6645: LD_INT 10
6647: LESS
6648: IFFALSE 6671
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 1
6657: ARRAY
6658: PPUSH
6659: LD_INT 105
6661: PPUSH
6662: LD_INT 14
6664: PPUSH
6665: CALL_OW 171
6669: GO 6690
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6671: LD_VAR 0 1
6675: PUSH
6676: LD_INT 1
6678: ARRAY
6679: PPUSH
6680: LD_INT 118
6682: PPUSH
6683: LD_INT 77
6685: PPUSH
6686: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6690: LD_VAR 0 1
6694: PUSH
6695: LD_INT 1
6697: ARRAY
6698: PPUSH
6699: LD_INT 92
6701: PPUSH
6702: LD_INT 40
6704: PPUSH
6705: CALL_OW 218
// end ;
6709: PPOPN 1
6711: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6712: LD_INT 1
6714: PPUSH
6715: CALL_OW 302
6719: IFFALSE 6727
6721: PUSH
6722: LD_EXP 10
6726: AND
6727: IFFALSE 7618
6729: GO 6731
6731: DISABLE
6732: LD_INT 0
6734: PPUSH
6735: PPUSH
6736: PPUSH
6737: PPUSH
6738: PPUSH
6739: PPUSH
6740: PPUSH
6741: PPUSH
// begin enable ;
6742: ENABLE
// base := 1 ;
6743: LD_ADDR_VAR 0 3
6747: PUSH
6748: LD_INT 1
6750: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6751: LD_ADDR_VAR 0 5
6755: PUSH
6756: LD_INT 0
6758: PUSH
6759: LD_INT 0
6761: PUSH
6762: LD_INT 0
6764: PUSH
6765: LD_INT 0
6767: PUSH
6768: LD_INT 0
6770: PUSH
6771: LD_INT 0
6773: PUSH
6774: LD_INT 0
6776: PUSH
6777: LD_INT 0
6779: PUSH
6780: LD_INT 1
6782: PUSH
6783: LD_INT 0
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: LIST
6796: LIST
6797: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6798: LD_ADDR_VAR 0 4
6802: PUSH
6803: LD_INT 13
6805: PUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 2
6811: PUSH
6812: LD_INT 26
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: PUSH
6821: LD_INT 13
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 2
6829: PUSH
6830: LD_INT 28
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 13
6841: PUSH
6842: LD_INT 1
6844: PUSH
6845: LD_INT 2
6847: PUSH
6848: LD_INT 29
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: LIST
6861: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6862: LD_ADDR_VAR 0 1
6866: PUSH
6867: DOUBLE
6868: LD_INT 1
6870: DEC
6871: ST_TO_ADDR
6872: LD_OWVAR 67
6876: PUSH
6877: LD_OWVAR 1
6881: PUSH
6882: LD_INT 21000
6884: DIV
6885: PLUS
6886: PUSH
6887: FOR_TO
6888: IFFALSE 6961
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_VAR 0 4
6899: PPUSH
6900: LD_VAR 0 4
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PPUSH
6909: LD_INT 13
6911: PUSH
6912: LD_INT 1
6914: PUSH
6915: LD_INT 2
6917: PUSH
6918: LD_INT 28
6920: PUSH
6921: LD_INT 29
6923: PUSH
6924: LD_INT 25
6926: PUSH
6927: LD_INT 26
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 1
6938: PPUSH
6939: LD_INT 4
6941: PPUSH
6942: CALL_OW 12
6946: ARRAY
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PPUSH
6954: CALL_OW 2
6958: ST_TO_ADDR
6959: GO 6887
6961: POP
6962: POP
// MC_InsertProduceList ( base , tmp ) ;
6963: LD_VAR 0 3
6967: PPUSH
6968: LD_VAR 0 4
6972: PPUSH
6973: CALL 85504 0 2
// wait ( 3 3$20 ) ;
6977: LD_INT 7000
6979: PPUSH
6980: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6984: LD_ADDR_VAR 0 6
6988: PUSH
6989: LD_INT 124
6991: PUSH
6992: LD_INT 85
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 90
7001: PUSH
7002: LD_INT 61
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PUSH
7009: LD_INT 69
7011: PUSH
7012: LD_INT 48
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: PUSH
7019: LD_INT 68
7021: PUSH
7022: LD_INT 48
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 22
7042: PUSH
7043: LD_INT 2
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 23
7052: PUSH
7053: LD_INT 2
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: LD_INT 21
7062: PUSH
7063: LD_INT 2
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 3
7072: PUSH
7073: LD_INT 2
7075: PUSH
7076: LD_INT 34
7078: PUSH
7079: LD_INT 31
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: LD_INT 34
7088: PUSH
7089: LD_INT 88
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: LD_INT 34
7098: PUSH
7099: LD_INT 32
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: PPUSH
7122: CALL_OW 69
7126: PUSH
7127: LD_EXP 82
7131: PUSH
7132: LD_VAR 0 3
7136: ARRAY
7137: PPUSH
7138: LD_INT 2
7140: PUSH
7141: LD_INT 34
7143: PUSH
7144: LD_INT 32
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 34
7153: PUSH
7154: LD_INT 88
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PPUSH
7166: CALL_OW 72
7170: DIFF
7171: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7172: LD_INT 0
7174: PPUSH
7175: LD_INT 1
7177: PPUSH
7178: CALL_OW 12
7182: IFFALSE 7332
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7184: LD_ADDR_VAR 0 1
7188: PUSH
7189: DOUBLE
7190: LD_INT 1
7192: DEC
7193: ST_TO_ADDR
7194: LD_INT 3
7196: PUSH
7197: LD_INT 4
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: LD_INT 6
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_OWVAR 67
7216: ARRAY
7217: PUSH
7218: FOR_TO
7219: IFFALSE 7328
// begin uc_side := 2 ;
7221: LD_ADDR_OWVAR 20
7225: PUSH
7226: LD_INT 2
7228: ST_TO_ADDR
// uc_nation := 2 ;
7229: LD_ADDR_OWVAR 21
7233: PUSH
7234: LD_INT 2
7236: ST_TO_ADDR
// InitHc ;
7237: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7241: LD_INT 0
7243: PPUSH
7244: LD_INT 15
7246: PUSH
7247: LD_INT 17
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PUSH
7254: LD_INT 1
7256: PPUSH
7257: LD_INT 2
7259: PPUSH
7260: CALL_OW 12
7264: ARRAY
7265: PPUSH
7266: LD_INT 8
7268: PPUSH
7269: CALL_OW 380
// un := CreateHuman ;
7273: LD_ADDR_VAR 0 2
7277: PUSH
7278: CALL_OW 44
7282: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 4
7290: PPUSH
7291: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7295: LD_VAR 0 2
7299: PPUSH
7300: LD_INT 23
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 49
// attackers := attackers union un ;
7310: LD_ADDR_VAR 0 7
7314: PUSH
7315: LD_VAR 0 7
7319: PUSH
7320: LD_VAR 0 2
7324: UNION
7325: ST_TO_ADDR
// end ;
7326: GO 7218
7328: POP
7329: POP
// end else
7330: GO 7490
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: DOUBLE
7338: LD_INT 1
7340: DEC
7341: ST_TO_ADDR
7342: LD_INT 2
7344: PUSH
7345: LD_INT 3
7347: PUSH
7348: LD_INT 4
7350: PUSH
7351: LD_INT 5
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: PUSH
7360: LD_OWVAR 67
7364: ARRAY
7365: PUSH
7366: FOR_TO
7367: IFFALSE 7488
// begin uc_side := 2 ;
7369: LD_ADDR_OWVAR 20
7373: PUSH
7374: LD_INT 2
7376: ST_TO_ADDR
// uc_nation := 2 ;
7377: LD_ADDR_OWVAR 21
7381: PUSH
7382: LD_INT 2
7384: ST_TO_ADDR
// InitHc ;
7385: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7389: LD_INT 14
7391: PPUSH
7392: LD_INT 3
7394: PPUSH
7395: LD_INT 5
7397: PPUSH
7398: LD_INT 29
7400: PUSH
7401: LD_INT 29
7403: PUSH
7404: LD_INT 26
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: LIST
7411: PUSH
7412: LD_VAR 0 1
7416: PUSH
7417: LD_INT 3
7419: MOD
7420: PUSH
7421: LD_INT 1
7423: PLUS
7424: ARRAY
7425: PPUSH
7426: LD_INT 100
7428: PPUSH
7429: CALL 22432 0 5
// un := CreateVehicle ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: CALL_OW 45
7442: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7443: LD_VAR 0 2
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7455: LD_VAR 0 2
7459: PPUSH
7460: LD_INT 23
7462: PPUSH
7463: LD_INT 0
7465: PPUSH
7466: CALL_OW 49
// attackers := attackers union un ;
7470: LD_ADDR_VAR 0 7
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_VAR 0 2
7484: UNION
7485: ST_TO_ADDR
// end ;
7486: GO 7366
7488: POP
7489: POP
// end ; if not attackers then
7490: LD_VAR 0 7
7494: NOT
7495: IFFALSE 7499
// exit ;
7497: GO 7618
// ar_attackers := attackers ;
7499: LD_ADDR_EXP 12
7503: PUSH
7504: LD_VAR 0 7
7508: ST_TO_ADDR
// p := 0 ;
7509: LD_ADDR_VAR 0 8
7513: PUSH
7514: LD_INT 0
7516: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7517: LD_INT 35
7519: PPUSH
7520: CALL_OW 67
// p := Inc ( p ) ;
7524: LD_ADDR_VAR 0 8
7528: PUSH
7529: LD_VAR 0 8
7533: PPUSH
7534: CALL 56985 0 1
7538: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7539: LD_VAR 0 7
7543: PPUSH
7544: LD_INT 60
7546: PUSH
7547: EMPTY
7548: LIST
7549: PPUSH
7550: CALL_OW 72
7554: NOT
7555: IFTRUE 7567
7557: PUSH
7558: LD_VAR 0 8
7562: PUSH
7563: LD_INT 30
7565: GREATER
7566: OR
7567: IFFALSE 7517
// repeat wait ( 0 0$1 ) ;
7569: LD_INT 35
7571: PPUSH
7572: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7576: LD_ADDR_VAR 0 7
7580: PUSH
7581: LD_VAR 0 7
7585: PPUSH
7586: LD_INT 50
7588: PUSH
7589: EMPTY
7590: LIST
7591: PPUSH
7592: CALL_OW 72
7596: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7597: LD_VAR 0 7
7601: PPUSH
7602: LD_VAR 0 6
7606: PPUSH
7607: CALL 58378 0 2
// until not attackers ;
7611: LD_VAR 0 7
7615: NOT
7616: IFFALSE 7569
// end ;
7618: PPOPN 8
7620: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7621: LD_INT 1
7623: PPUSH
7624: CALL_OW 302
7628: IFFALSE 7636
7630: PUSH
7631: LD_EXP 10
7635: AND
7636: IFFALSE 7652
7638: PUSH
7639: LD_EXP 52
7643: PPUSH
7644: LD_INT 22
7646: PPUSH
7647: CALL_OW 308
7651: AND
7652: IFFALSE 8158
7654: GO 7656
7656: DISABLE
7657: LD_INT 0
7659: PPUSH
7660: PPUSH
7661: PPUSH
7662: PPUSH
7663: PPUSH
7664: PPUSH
7665: PPUSH
7666: PPUSH
// begin base := 1 ;
7667: LD_ADDR_VAR 0 2
7671: PUSH
7672: LD_INT 1
7674: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 0
7682: PUSH
7683: LD_INT 0
7685: PUSH
7686: LD_INT 0
7688: PUSH
7689: LD_INT 0
7691: PUSH
7692: LD_INT 0
7694: PUSH
7695: LD_INT 0
7697: PUSH
7698: LD_INT 0
7700: PUSH
7701: LD_INT 0
7703: PUSH
7704: LD_INT 1
7706: PUSH
7707: LD_INT 0
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7722: LD_ADDR_VAR 0 3
7726: PUSH
7727: LD_INT 13
7729: PUSH
7730: LD_INT 1
7732: PUSH
7733: LD_INT 2
7735: PUSH
7736: LD_INT 28
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: LIST
7743: LIST
7744: PUSH
7745: LD_INT 13
7747: PUSH
7748: LD_INT 1
7750: PUSH
7751: LD_INT 2
7753: PUSH
7754: LD_INT 27
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 13
7765: PUSH
7766: LD_INT 1
7768: PUSH
7769: LD_INT 2
7771: PUSH
7772: LD_INT 25
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 11
7783: PUSH
7784: LD_INT 2
7786: PUSH
7787: LD_INT 2
7789: PUSH
7790: LD_INT 24
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: PUSH
7799: LD_INT 11
7801: PUSH
7802: LD_INT 2
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: LD_INT 24
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: LIST
7815: LIST
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: LIST
7821: LIST
7822: LIST
7823: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7824: LD_VAR 0 2
7828: PPUSH
7829: LD_VAR 0 3
7833: PPUSH
7834: CALL 85504 0 2
// wait ( 4 4$20 ) ;
7838: LD_INT 9100
7840: PPUSH
7841: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7845: LD_ADDR_VAR 0 5
7849: PUSH
7850: LD_INT 119
7852: PUSH
7853: LD_INT 9
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_EXP 82
7872: PUSH
7873: LD_VAR 0 2
7877: ARRAY
7878: PUSH
7879: LD_EXP 82
7883: PUSH
7884: LD_VAR 0 2
7888: ARRAY
7889: PPUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 34
7895: PUSH
7896: LD_INT 32
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 34
7905: PUSH
7906: LD_INT 88
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 72
7922: DIFF
7923: ST_TO_ADDR
// uc_side := 2 ;
7924: LD_ADDR_OWVAR 20
7928: PUSH
7929: LD_INT 2
7931: ST_TO_ADDR
// uc_nation := 2 ;
7932: LD_ADDR_OWVAR 21
7936: PUSH
7937: LD_INT 2
7939: ST_TO_ADDR
// InitHc ;
7940: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7944: LD_ADDR_VAR 0 1
7948: PUSH
7949: DOUBLE
7950: LD_INT 1
7952: DEC
7953: ST_TO_ADDR
7954: LD_INT 4
7956: PUSH
7957: LD_INT 5
7959: PUSH
7960: LD_INT 6
7962: PUSH
7963: LD_INT 6
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: LD_OWVAR 67
7976: ARRAY
7977: PUSH
7978: FOR_TO
7979: IFFALSE 8056
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7981: LD_INT 0
7983: PPUSH
7984: LD_INT 15
7986: PUSH
7987: LD_INT 17
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 1
7996: PPUSH
7997: LD_INT 2
7999: PPUSH
8000: CALL_OW 12
8004: ARRAY
8005: PPUSH
8006: LD_INT 8
8008: PPUSH
8009: CALL_OW 380
// un := CreateHuman ;
8013: LD_ADDR_VAR 0 7
8017: PUSH
8018: CALL_OW 44
8022: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
8023: LD_VAR 0 7
8027: PPUSH
8028: LD_INT 23
8030: PPUSH
8031: LD_INT 0
8033: PPUSH
8034: CALL_OW 49
// attackers := attackers union un ;
8038: LD_ADDR_VAR 0 6
8042: PUSH
8043: LD_VAR 0 6
8047: PUSH
8048: LD_VAR 0 7
8052: UNION
8053: ST_TO_ADDR
// end ;
8054: GO 7978
8056: POP
8057: POP
// p := 0 ;
8058: LD_ADDR_VAR 0 8
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8066: LD_INT 35
8068: PPUSH
8069: CALL_OW 67
// p := Inc ( p ) ;
8073: LD_ADDR_VAR 0 8
8077: PUSH
8078: LD_VAR 0 8
8082: PPUSH
8083: CALL 56985 0 1
8087: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8088: LD_VAR 0 6
8092: PPUSH
8093: LD_INT 60
8095: PUSH
8096: EMPTY
8097: LIST
8098: PPUSH
8099: CALL_OW 72
8103: NOT
8104: IFTRUE 8116
8106: PUSH
8107: LD_VAR 0 8
8111: PUSH
8112: LD_INT 30
8114: GREATER
8115: OR
8116: IFFALSE 8066
// SetAttitude ( 4 , 2 , att_enemy , true ) ;
8118: LD_INT 4
8120: PPUSH
8121: LD_INT 2
8123: PPUSH
8124: LD_INT 2
8126: PPUSH
8127: LD_INT 1
8129: PPUSH
8130: CALL_OW 80
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8134: LD_VAR 0 2
8138: PPUSH
8139: LD_VAR 0 6
8143: PPUSH
8144: LD_VAR 0 5
8148: PPUSH
8149: LD_VAR 0 4
8153: PPUSH
8154: CALL 85689 0 4
// end ;
8158: PPOPN 8
8160: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8161: LD_INT 0
8163: PPUSH
8164: PPUSH
8165: PPUSH
8166: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8167: LD_ADDR_VAR 0 5
8171: PUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: LD_INT 0
8179: PPUSH
8180: CALL_OW 517
8184: ST_TO_ADDR
// if not tmp then
8185: LD_VAR 0 5
8189: NOT
8190: IFFALSE 8194
// exit ;
8192: GO 8444
// arMinesList := arMinesList diff 0 ;
8194: LD_ADDR_EXP 60
8198: PUSH
8199: LD_EXP 60
8203: PUSH
8204: LD_INT 0
8206: DIFF
8207: ST_TO_ADDR
// for i := 1 to n do
8208: LD_ADDR_VAR 0 4
8212: PUSH
8213: DOUBLE
8214: LD_INT 1
8216: DEC
8217: ST_TO_ADDR
8218: LD_VAR 0 2
8222: PUSH
8223: FOR_TO
8224: IFFALSE 8442
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8226: LD_ADDR_VAR 0 6
8230: PUSH
8231: LD_INT 1
8233: PPUSH
8234: LD_VAR 0 5
8238: PUSH
8239: LD_INT 1
8241: ARRAY
8242: PPUSH
8243: CALL_OW 12
8247: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8248: LD_VAR 0 5
8252: PUSH
8253: LD_INT 1
8255: ARRAY
8256: PUSH
8257: LD_VAR 0 6
8261: ARRAY
8262: PPUSH
8263: LD_VAR 0 5
8267: PUSH
8268: LD_INT 2
8270: ARRAY
8271: PUSH
8272: LD_VAR 0 6
8276: ARRAY
8277: PPUSH
8278: LD_INT 2
8280: PPUSH
8281: LD_INT 0
8283: PPUSH
8284: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8288: LD_ADDR_EXP 60
8292: PUSH
8293: LD_EXP 60
8297: PPUSH
8298: LD_EXP 60
8302: PUSH
8303: LD_INT 1
8305: PLUS
8306: PPUSH
8307: LD_VAR 0 5
8311: PUSH
8312: LD_INT 1
8314: ARRAY
8315: PUSH
8316: LD_VAR 0 6
8320: ARRAY
8321: PPUSH
8322: CALL_OW 2
8326: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8327: LD_ADDR_EXP 60
8331: PUSH
8332: LD_EXP 60
8336: PPUSH
8337: LD_EXP 60
8341: PUSH
8342: LD_INT 1
8344: PLUS
8345: PPUSH
8346: LD_VAR 0 5
8350: PUSH
8351: LD_INT 2
8353: ARRAY
8354: PUSH
8355: LD_VAR 0 6
8359: ARRAY
8360: PPUSH
8361: CALL_OW 2
8365: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8366: LD_ADDR_VAR 0 5
8370: PUSH
8371: LD_VAR 0 5
8375: PPUSH
8376: LD_INT 1
8378: PPUSH
8379: LD_VAR 0 5
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: PPUSH
8388: LD_VAR 0 6
8392: PPUSH
8393: CALL_OW 3
8397: PPUSH
8398: CALL_OW 1
8402: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8403: LD_ADDR_VAR 0 5
8407: PUSH
8408: LD_VAR 0 5
8412: PPUSH
8413: LD_INT 2
8415: PPUSH
8416: LD_VAR 0 5
8420: PUSH
8421: LD_INT 2
8423: ARRAY
8424: PPUSH
8425: LD_VAR 0 6
8429: PPUSH
8430: CALL_OW 3
8434: PPUSH
8435: CALL_OW 1
8439: ST_TO_ADDR
// end ;
8440: GO 8223
8442: POP
8443: POP
// end ;
8444: LD_VAR 0 3
8448: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8449: LD_EXP 60
8453: IFFALSE 8684
8455: GO 8457
8457: DISABLE
8458: LD_INT 0
8460: PPUSH
8461: PPUSH
8462: PPUSH
8463: PPUSH
// begin enable ;
8464: ENABLE
// p := 1 ;
8465: LD_ADDR_VAR 0 2
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: DOUBLE
8479: LD_INT 1
8481: DEC
8482: ST_TO_ADDR
8483: LD_EXP 60
8487: PPUSH
8488: CALL 19636 0 1
8492: PUSH
8493: LD_INT 2
8495: DIV
8496: PUSH
8497: FOR_TO
8498: IFFALSE 8682
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8500: LD_ADDR_VAR 0 3
8504: PUSH
8505: LD_EXP 60
8509: PUSH
8510: LD_VAR 0 2
8514: ARRAY
8515: PPUSH
8516: LD_EXP 60
8520: PUSH
8521: LD_VAR 0 2
8525: PUSH
8526: LD_INT 1
8528: PLUS
8529: ARRAY
8530: PPUSH
8531: CALL_OW 428
8535: ST_TO_ADDR
// if tmp then
8536: LD_VAR 0 3
8540: IFFALSE 8666
// begin side := GetSide ( tmp ) ;
8542: LD_ADDR_VAR 0 4
8546: PUSH
8547: LD_VAR 0 3
8551: PPUSH
8552: CALL_OW 255
8556: ST_TO_ADDR
// if side <> 2 and side > 0 then
8557: LD_VAR 0 4
8561: PUSH
8562: LD_INT 2
8564: NONEQUAL
8565: IFFALSE 8577
8567: PUSH
8568: LD_VAR 0 4
8572: PUSH
8573: LD_INT 0
8575: GREATER
8576: AND
8577: IFFALSE 8666
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8579: LD_EXP 60
8583: PUSH
8584: LD_VAR 0 2
8588: ARRAY
8589: PPUSH
8590: LD_EXP 60
8594: PUSH
8595: LD_VAR 0 2
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 2
8607: PPUSH
8608: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8612: LD_ADDR_EXP 60
8616: PUSH
8617: LD_EXP 60
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 3
8631: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8632: LD_ADDR_EXP 60
8636: PUSH
8637: LD_EXP 60
8641: PPUSH
8642: LD_VAR 0 2
8646: PPUSH
8647: CALL_OW 3
8651: ST_TO_ADDR
// p := p - 2 ;
8652: LD_ADDR_VAR 0 2
8656: PUSH
8657: LD_VAR 0 2
8661: PUSH
8662: LD_INT 2
8664: MINUS
8665: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: LD_VAR 0 2
8675: PUSH
8676: LD_INT 2
8678: PLUS
8679: ST_TO_ADDR
// end ;
8680: GO 8497
8682: POP
8683: POP
// end ; end_of_file
8684: PPOPN 4
8686: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
8693: PPUSH
8694: PPUSH
// uc_side := 1 ;
8695: LD_ADDR_OWVAR 20
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// uc_nation := 1 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 1
8710: ST_TO_ADDR
// InitHc ;
8711: CALL_OW 19
// InitVc ;
8715: CALL_OW 20
// tmp := [ ] ;
8719: LD_ADDR_VAR 0 3
8723: PUSH
8724: EMPTY
8725: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8726: LD_ADDR_VAR 0 2
8730: PUSH
8731: DOUBLE
8732: LD_INT 1
8734: DEC
8735: ST_TO_ADDR
8736: LD_INT 6
8738: PUSH
8739: LD_INT 8
8741: PUSH
8742: LD_INT 10
8744: PUSH
8745: LD_INT 10
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_OWVAR 67
8758: ARRAY
8759: PUSH
8760: FOR_TO
8761: IFFALSE 9051
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8763: LD_ADDR_VAR 0 5
8767: PUSH
8768: LD_INT 2
8770: PUSH
8771: LD_INT 4
8773: PUSH
8774: LD_INT 5
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 1
8784: PPUSH
8785: LD_INT 3
8787: PPUSH
8788: CALL_OW 12
8792: ARRAY
8793: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8794: LD_VAR 0 5
8798: PUSH
8799: LD_INT 2
8801: DOUBLE
8802: EQUAL
8803: IFTRUE 8807
8805: GO 8841
8807: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8808: LD_ADDR_VAR 0 6
8812: PUSH
8813: LD_INT 9
8815: PUSH
8816: LD_INT 5
8818: PUSH
8819: LD_INT 7
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 1
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 12
8837: ARRAY
8838: ST_TO_ADDR
8839: GO 8930
8841: LD_INT 4
8843: DOUBLE
8844: EQUAL
8845: IFTRUE 8849
8847: GO 8887
8849: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8850: LD_ADDR_VAR 0 6
8854: PUSH
8855: LD_INT 9
8857: PUSH
8858: LD_INT 6
8860: PUSH
8861: LD_INT 6
8863: PUSH
8864: LD_INT 7
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 4
8878: PPUSH
8879: CALL_OW 12
8883: ARRAY
8884: ST_TO_ADDR
8885: GO 8930
8887: LD_INT 5
8889: DOUBLE
8890: EQUAL
8891: IFTRUE 8895
8893: GO 8929
8895: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8896: LD_ADDR_VAR 0 6
8900: PUSH
8901: LD_INT 9
8903: PUSH
8904: LD_INT 6
8906: PUSH
8907: LD_INT 7
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 3
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: ST_TO_ADDR
8927: GO 8930
8929: POP
// uc_side := 1 ;
8930: LD_ADDR_OWVAR 20
8934: PUSH
8935: LD_INT 1
8937: ST_TO_ADDR
// uc_nation := 1 ;
8938: LD_ADDR_OWVAR 21
8942: PUSH
8943: LD_INT 1
8945: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8946: LD_VAR 0 5
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_VAR 0 6
8980: PPUSH
8981: LD_INT 70
8983: PPUSH
8984: LD_INT 90
8986: PPUSH
8987: CALL_OW 12
8991: PPUSH
8992: CALL 22432 0 5
// veh := CreateVehicle ;
8996: LD_ADDR_VAR 0 4
9000: PUSH
9001: CALL_OW 45
9005: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9006: LD_VAR 0 4
9010: PPUSH
9011: LD_INT 2
9013: PPUSH
9014: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9018: LD_VAR 0 4
9022: PPUSH
9023: LD_INT 17
9025: PPUSH
9026: LD_INT 0
9028: PPUSH
9029: CALL_OW 49
// tmp := tmp ^ veh ;
9033: LD_ADDR_VAR 0 3
9037: PUSH
9038: LD_VAR 0 3
9042: PUSH
9043: LD_VAR 0 4
9047: ADD
9048: ST_TO_ADDR
// end ;
9049: GO 8760
9051: POP
9052: POP
// if not tmp then
9053: LD_VAR 0 3
9057: NOT
9058: IFFALSE 9062
// exit ;
9060: GO 9171
// if not first_powell_attack then
9062: LD_EXP 13
9066: NOT
9067: IFFALSE 9077
// first_powell_attack := true ;
9069: LD_ADDR_EXP 13
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9077: LD_INT 70
9079: PPUSH
9080: CALL_OW 67
// for i in tmp do
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: FOR_IN
9095: IFFALSE 9162
// if IsOk ( i ) then
9097: LD_VAR 0 2
9101: PPUSH
9102: CALL_OW 302
9106: IFFALSE 9144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9108: LD_VAR 0 2
9112: PPUSH
9113: LD_INT 81
9115: PUSH
9116: LD_INT 1
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: PPUSH
9128: LD_VAR 0 2
9132: PPUSH
9133: CALL_OW 74
9137: PPUSH
9138: CALL_OW 115
9142: GO 9160
// tmp := tmp diff i ;
9144: LD_ADDR_VAR 0 3
9148: PUSH
9149: LD_VAR 0 3
9153: PUSH
9154: LD_VAR 0 2
9158: DIFF
9159: ST_TO_ADDR
9160: GO 9094
9162: POP
9163: POP
// until not tmp ;
9164: LD_VAR 0 3
9168: NOT
9169: IFFALSE 9077
// end ;
9171: LD_VAR 0 1
9175: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9176: LD_INT 0
9178: PPUSH
9179: PPUSH
// uc_side := 1 ;
9180: LD_ADDR_OWVAR 20
9184: PUSH
9185: LD_INT 1
9187: ST_TO_ADDR
// uc_nation := 1 ;
9188: LD_ADDR_OWVAR 21
9192: PUSH
9193: LD_INT 1
9195: ST_TO_ADDR
// InitHc ;
9196: CALL_OW 19
// InitVc ;
9200: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9204: LD_INT 5
9206: PPUSH
9207: LD_INT 3
9209: PPUSH
9210: LD_INT 3
9212: PPUSH
9213: LD_INT 12
9215: PPUSH
9216: LD_INT 100
9218: PPUSH
9219: CALL 22432 0 5
// veh := CreateVehicle ;
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: CALL_OW 45
9232: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9233: LD_VAR 0 3
9237: PPUSH
9238: LD_INT 2
9240: PPUSH
9241: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 17
9252: PPUSH
9253: LD_INT 0
9255: PPUSH
9256: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9260: LD_VAR 0 3
9264: PPUSH
9265: LD_VAR 0 1
9269: PUSH
9270: LD_INT 1
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 1
9278: PUSH
9279: LD_INT 2
9281: ARRAY
9282: PPUSH
9283: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: LD_INT 59
9294: PPUSH
9295: LD_INT 2
9297: PPUSH
9298: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9302: LD_INT 35
9304: PPUSH
9305: CALL_OW 67
// if not IsOk ( veh ) then
9309: LD_VAR 0 3
9313: PPUSH
9314: CALL_OW 302
9318: NOT
9319: IFFALSE 9323
// exit ;
9321: GO 9377
// until IsAt ( veh , 59 , 2 ) ;
9323: LD_VAR 0 3
9327: PPUSH
9328: LD_INT 59
9330: PPUSH
9331: LD_INT 2
9333: PPUSH
9334: CALL_OW 307
9338: IFFALSE 9302
// RemoveUnit ( veh ) ;
9340: LD_VAR 0 3
9344: PPUSH
9345: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9349: LD_VAR 0 3
9353: PPUSH
9354: LD_INT 4
9356: PPUSH
9357: CALL_OW 289
9361: IFFALSE 9377
// begin wait ( 0 0$2 ) ;
9363: LD_INT 70
9365: PPUSH
9366: CALL_OW 67
// YouLost ( Artifact ) ;
9370: LD_STRING Artifact
9372: PPUSH
9373: CALL_OW 104
// end ; end ; end_of_file
9377: LD_VAR 0 2
9381: RET
// export function Action ; var tmp , i , un ; begin
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9388: LD_INT 68
9390: PPUSH
9391: LD_INT 39
9393: PPUSH
9394: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9398: LD_ADDR_VAR 0 2
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 7
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: ST_TO_ADDR
// InGameOn ;
9418: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9422: LD_VAR 0 2
9426: PPUSH
9427: LD_INT 71
9429: PPUSH
9430: LD_INT 49
9432: PPUSH
9433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9437: LD_INT 35
9439: PPUSH
9440: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9444: LD_INT 7
9446: PPUSH
9447: LD_INT 71
9449: PPUSH
9450: LD_INT 51
9452: PPUSH
9453: CALL_OW 293
9457: IFFALSE 9437
// DialogueOn ;
9459: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-1
9470: PPUSH
9471: CALL_OW 88
// if Joan then
9475: LD_EXP 32
9479: IFFALSE 9493
// Say ( Joan , D1-Joan-1 ) ;
9481: LD_EXP 32
9485: PPUSH
9486: LD_STRING D1-Joan-1
9488: PPUSH
9489: CALL_OW 88
// if Lisa then
9493: LD_EXP 19
9497: IFFALSE 9511
// Say ( Lisa , D1-Lisa-1 ) ;
9499: LD_EXP 19
9503: PPUSH
9504: LD_STRING D1-Lisa-1
9506: PPUSH
9507: CALL_OW 88
// if Joan or Lisa then
9511: LD_EXP 32
9515: IFTRUE 9523
9517: PUSH
9518: LD_EXP 19
9522: OR
9523: IFFALSE 9537
// Say ( JMM , D1-JMM-2 ) ;
9525: LD_EXP 17
9529: PPUSH
9530: LD_STRING D1-JMM-2
9532: PPUSH
9533: CALL_OW 88
// DialogueOff ;
9537: CALL_OW 7
// InGameOff ;
9541: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9545: LD_INT 71
9547: PPUSH
9548: LD_INT 50
9550: PPUSH
9551: LD_INT 7
9553: PPUSH
9554: LD_INT 30
9556: NEG
9557: PPUSH
9558: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9562: LD_INT 71
9564: PPUSH
9565: LD_INT 50
9567: PPUSH
9568: LD_INT 7
9570: PPUSH
9571: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9575: LD_STRING M1
9577: PPUSH
9578: CALL_OW 337
// SaveForQuickRestart ;
9582: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9586: LD_INT 35
9588: PPUSH
9589: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9593: LD_EXP 3
9597: IFTRUE 9609
9599: PUSH
9600: LD_OWVAR 1
9604: PUSH
9605: LD_INT 2100
9607: GREATER
9608: OR
9609: IFFALSE 9586
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9611: LD_INT 350
9613: PPUSH
9614: LD_INT 700
9616: PPUSH
9617: CALL_OW 12
9621: PPUSH
9622: CALL_OW 67
// PrepareGossudarov ;
9626: CALL 1949 0 0
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9637: LD_INT 22
9639: PUSH
9640: LD_INT 6
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 3
9649: PUSH
9650: LD_INT 24
9652: PUSH
9653: LD_INT 1000
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: IFTRUE 9688
9674: PUSH
9675: LD_INT 7
9677: PPUSH
9678: LD_EXP 35
9682: PPUSH
9683: CALL_OW 292
9687: OR
9688: IFFALSE 9630
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9690: LD_ADDR_VAR 0 2
9694: PUSH
9695: LD_INT 22
9697: PUSH
9698: LD_INT 6
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PPUSH
9705: CALL_OW 69
9709: ST_TO_ADDR
// for i in tmp do
9710: LD_ADDR_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: FOR_IN
9721: IFFALSE 9737
// SetSide ( i , 7 ) ;
9723: LD_VAR 0 3
9727: PPUSH
9728: LD_INT 7
9730: PPUSH
9731: CALL_OW 235
9735: GO 9720
9737: POP
9738: POP
// DialogueOn ;
9739: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9743: LD_EXP 17
9747: PUSH
9748: LD_EXP 18
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PPUSH
9757: LD_EXP 35
9761: PPUSH
9762: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9766: LD_EXP 35
9770: PPUSH
9771: CALL_OW 87
// if not Roth then
9775: LD_EXP 18
9779: NOT
9780: IFFALSE 9872
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9782: LD_VAR 0 2
9786: PPUSH
9787: LD_INT 3
9789: PUSH
9790: LD_INT 24
9792: PUSH
9793: LD_INT 1000
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: PPUSH
9804: CALL_OW 72
9808: IFFALSE 9822
// Say ( JMM , D2-JMM-1 ) ;
9810: LD_EXP 17
9814: PPUSH
9815: LD_STRING D2-JMM-1
9817: PPUSH
9818: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9822: LD_EXP 17
9826: PPUSH
9827: LD_STRING D2-JMM-1b
9829: PPUSH
9830: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9834: LD_EXP 35
9838: PPUSH
9839: LD_STRING D2-Gos-1
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-2
9853: PPUSH
9854: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9858: LD_EXP 35
9862: PPUSH
9863: LD_STRING D2-Gos-2
9865: PPUSH
9866: CALL_OW 88
// end else
9870: GO 10024
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 1000
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PPUSH
9894: CALL_OW 72
9898: IFFALSE 9924
// begin Say ( Roth , D2-Roth-2 ) ;
9900: LD_EXP 18
9904: PPUSH
9905: LD_STRING D2-Roth-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9912: LD_EXP 17
9916: PPUSH
9917: LD_STRING D2-JMM-1a
9919: PPUSH
9920: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9924: LD_EXP 18
9928: PPUSH
9929: LD_STRING D2-Roth-2a
9931: PPUSH
9932: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9936: LD_EXP 18
9940: PPUSH
9941: LD_STRING D2-Roth-2b
9943: PPUSH
9944: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9948: LD_EXP 17
9952: PPUSH
9953: LD_STRING D2-JMM-3
9955: PPUSH
9956: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9960: LD_VAR 0 2
9964: PPUSH
9965: LD_INT 3
9967: PUSH
9968: LD_INT 24
9970: PUSH
9971: LD_INT 1000
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: IFFALSE 10024
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9988: LD_EXP 35
9992: PPUSH
9993: LD_STRING D2-Gos-3
9995: PPUSH
9996: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
10000: LD_EXP 17
10004: PPUSH
10005: LD_STRING D2-JMM-4
10007: PPUSH
10008: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
10012: LD_EXP 35
10016: PPUSH
10017: LD_STRING D2-Gos-4
10019: PPUSH
10020: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
10024: LD_EXP 17
10028: PPUSH
10029: LD_STRING D2-JMM-5
10031: PPUSH
10032: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
10036: LD_EXP 35
10040: PPUSH
10041: LD_STRING D2-Gos-5
10043: PPUSH
10044: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
10048: LD_EXP 17
10052: PPUSH
10053: LD_STRING D2-JMM-6
10055: PPUSH
10056: CALL_OW 88
// DialogueOff ;
10060: CALL_OW 7
// wait ( 0 0$2 ) ;
10064: LD_INT 70
10066: PPUSH
10067: CALL_OW 67
// if Kirilenkova then
10071: LD_EXP 36
10075: IFFALSE 10089
// Say ( Kirilenkova , D3-Kir-1 ) ;
10077: LD_EXP 36
10081: PPUSH
10082: LD_STRING D3-Kir-1
10084: PPUSH
10085: CALL_OW 88
// gossudarov_arrive := true ;
10089: LD_ADDR_EXP 4
10093: PUSH
10094: LD_INT 1
10096: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10097: LD_INT 35
10099: PPUSH
10100: CALL_OW 67
// until ru_lab_builded ;
10104: LD_EXP 5
10108: IFFALSE 10097
// DialogueOn ;
10110: CALL_OW 6
// if Kirilenkova then
10114: LD_EXP 36
10118: IFFALSE 10134
// Say ( Kirilenkova , D3a-Kir-1 ) else
10120: LD_EXP 36
10124: PPUSH
10125: LD_STRING D3a-Kir-1
10127: PPUSH
10128: CALL_OW 88
10132: GO 10156
// begin un := SciRu ;
10134: LD_ADDR_VAR 0 4
10138: PUSH
10139: CALL 15764 0 0
10143: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10144: LD_VAR 0 4
10148: PPUSH
10149: LD_STRING D3a-Sci1-1
10151: PPUSH
10152: CALL_OW 88
// end ; if Kirilenkova or un then
10156: LD_EXP 36
10160: IFTRUE 10168
10162: PUSH
10163: LD_VAR 0 4
10167: OR
10168: IFFALSE 10182
// Say ( JMM , D3a-JMM-1 ) ;
10170: LD_EXP 17
10174: PPUSH
10175: LD_STRING D3a-JMM-1
10177: PPUSH
10178: CALL_OW 88
// DialogueOff ;
10182: CALL_OW 7
// end ;
10186: LD_VAR 0 1
10190: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10191: LD_EXP 4
10195: IFFALSE 10304
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_INT 7
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: LD_INT 25
10213: PUSH
10214: LD_INT 1
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 25
10223: PUSH
10224: LD_INT 2
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: LD_INT 25
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: PUSH
10241: LD_INT 25
10243: PUSH
10244: LD_INT 4
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 25
10253: PUSH
10254: LD_INT 5
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 25
10263: PUSH
10264: LD_INT 8
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 25
10273: PUSH
10274: LD_INT 9
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: PUSH
10300: LD_INT 7
10302: LESS
10303: AND
10304: IFFALSE 10316
10306: GO 10308
10308: DISABLE
// YouLost ( TooMany ) ;
10309: LD_STRING TooMany
10311: PPUSH
10312: CALL_OW 104
10316: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10317: LD_EXP 35
10321: PPUSH
10322: CALL_OW 255
10326: PUSH
10327: LD_INT 7
10329: EQUAL
10330: IFFALSE 10553
10332: GO 10334
10334: DISABLE
10335: LD_INT 0
10337: PPUSH
10338: PPUSH
10339: PPUSH
// begin uc_side := 3 ;
10340: LD_ADDR_OWVAR 20
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// uc_nation := 3 ;
10348: LD_ADDR_OWVAR 21
10352: PUSH
10353: LD_INT 3
10355: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10356: LD_INT 21
10358: PPUSH
10359: LD_INT 3
10361: PPUSH
10362: LD_INT 3
10364: PPUSH
10365: LD_INT 42
10367: PPUSH
10368: LD_INT 100
10370: PPUSH
10371: CALL 22432 0 5
// un := CreateVehicle ;
10375: LD_ADDR_VAR 0 3
10379: PUSH
10380: CALL_OW 45
10384: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10385: LD_VAR 0 3
10389: PPUSH
10390: LD_INT 15
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10400: LD_VAR 0 3
10404: PPUSH
10405: LD_INT 67
10407: PPUSH
10408: LD_INT 45
10410: PPUSH
10411: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10415: LD_VAR 0 3
10419: PPUSH
10420: LD_INT 70
10422: PPUSH
10423: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10427: LD_VAR 0 3
10431: PPUSH
10432: LD_INT 69
10434: PPUSH
10435: LD_INT 18
10437: PPUSH
10438: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10442: LD_VAR 0 3
10446: PPUSH
10447: LD_INT 60
10449: PPUSH
10450: LD_INT 3
10452: PPUSH
10453: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10457: LD_INT 35
10459: PPUSH
10460: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10464: LD_VAR 0 3
10468: PPUSH
10469: CALL_OW 302
10473: NOT
10474: IFTRUE 10490
10476: PUSH
10477: LD_VAR 0 3
10481: PPUSH
10482: LD_INT 17
10484: PPUSH
10485: CALL_OW 308
10489: OR
10490: IFTRUE 10509
10492: PUSH
10493: LD_VAR 0 3
10497: PPUSH
10498: LD_INT 60
10500: PPUSH
10501: LD_INT 3
10503: PPUSH
10504: CALL_OW 307
10508: OR
10509: IFFALSE 10457
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10511: LD_VAR 0 3
10515: PPUSH
10516: LD_INT 17
10518: PPUSH
10519: CALL_OW 308
10523: IFTRUE 10542
10525: PUSH
10526: LD_VAR 0 3
10530: PPUSH
10531: LD_INT 60
10533: PPUSH
10534: LD_INT 3
10536: PPUSH
10537: CALL_OW 307
10541: OR
10542: IFFALSE 10553
// RemoveUnit ( un ) ;
10544: LD_VAR 0 3
10548: PPUSH
10549: CALL_OW 64
// end ;
10553: PPOPN 3
10555: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10556: LD_EXP 4
10560: IFFALSE 10802
10562: GO 10564
10564: DISABLE
10565: LD_INT 0
10567: PPUSH
10568: PPUSH
10569: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10570: LD_INT 70
10572: PPUSH
10573: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10577: LD_ADDR_VAR 0 3
10581: PUSH
10582: LD_INT 22
10584: PUSH
10585: LD_INT 7
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 101
10594: PUSH
10595: LD_INT 3
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PPUSH
10606: CALL_OW 69
10610: ST_TO_ADDR
// until tmp ;
10611: LD_VAR 0 3
10615: IFFALSE 10570
// un := NearestUnitToUnit ( tmp , JMM ) ;
10617: LD_ADDR_VAR 0 2
10621: PUSH
10622: LD_VAR 0 3
10626: PPUSH
10627: LD_EXP 17
10631: PPUSH
10632: CALL_OW 74
10636: ST_TO_ADDR
// player_spotted := true ;
10637: LD_ADDR_EXP 7
10641: PUSH
10642: LD_INT 1
10644: ST_TO_ADDR
// tmp := SciRu ;
10645: LD_ADDR_VAR 0 3
10649: PUSH
10650: CALL 15764 0 0
10654: ST_TO_ADDR
// if not tmp then
10655: LD_VAR 0 3
10659: NOT
10660: IFFALSE 10672
// tmp := SolRu ;
10662: LD_ADDR_VAR 0 3
10666: PUSH
10667: CALL 15911 0 0
10671: ST_TO_ADDR
// DialogueOn ;
10672: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10676: LD_VAR 0 2
10680: PPUSH
10681: CALL_OW 250
10685: PPUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 251
10695: PPUSH
10696: LD_INT 7
10698: PPUSH
10699: LD_INT 8
10701: NEG
10702: PPUSH
10703: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 87
// if tmp then
10716: LD_VAR 0 3
10720: IFFALSE 10734
// Say ( tmp , D4-RSci1-1 ) ;
10722: LD_VAR 0 3
10726: PPUSH
10727: LD_STRING D4-RSci1-1
10729: PPUSH
10730: CALL_OW 88
// if Gossudarov then
10734: LD_EXP 35
10738: IFFALSE 10764
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10740: LD_EXP 35
10744: PPUSH
10745: LD_STRING D4-Gos-1
10747: PPUSH
10748: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10752: LD_EXP 17
10756: PPUSH
10757: LD_STRING D4-JMM-1
10759: PPUSH
10760: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10764: LD_VAR 0 2
10768: PPUSH
10769: CALL_OW 250
10773: PPUSH
10774: LD_VAR 0 2
10778: PPUSH
10779: CALL_OW 251
10783: PPUSH
10784: LD_INT 7
10786: PPUSH
10787: CALL_OW 331
// DialogueOff ;
10791: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10795: LD_STRING M5
10797: PPUSH
10798: CALL_OW 337
// end ;
10802: PPOPN 3
10804: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10805: LD_EXP 7
10809: IFFALSE 11408
10811: GO 10813
10813: DISABLE
10814: LD_INT 0
10816: PPUSH
10817: PPUSH
10818: PPUSH
// begin PrepareBelkov ;
10819: CALL 2262 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10823: LD_EXP 50
10827: PPUSH
10828: LD_INT 118
10830: PPUSH
10831: LD_INT 106
10833: PPUSH
10834: CALL_OW 111
// AddComHold ( Belkov ) ;
10838: LD_EXP 50
10842: PPUSH
10843: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10847: LD_INT 35
10849: PPUSH
10850: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10854: LD_EXP 50
10858: PPUSH
10859: LD_INT 118
10861: PPUSH
10862: LD_INT 106
10864: PPUSH
10865: CALL_OW 307
10869: IFFALSE 10847
// ChangeSideFog ( 4 , 7 ) ;
10871: LD_INT 4
10873: PPUSH
10874: LD_INT 7
10876: PPUSH
10877: CALL_OW 343
// if IsOk ( Belkov ) then
10881: LD_EXP 50
10885: PPUSH
10886: CALL_OW 302
10890: IFFALSE 10974
// begin InGameOn ;
10892: CALL_OW 8
// DialogueOn ;
10896: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10900: LD_EXP 50
10904: PPUSH
10905: LD_STRING D5-Bel-1
10907: PPUSH
10908: CALL_OW 94
// if Gossudarov then
10912: LD_EXP 35
10916: IFFALSE 10966
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10918: LD_EXP 35
10922: PPUSH
10923: LD_STRING D5-Gos-1
10925: PPUSH
10926: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10930: LD_EXP 17
10934: PPUSH
10935: LD_STRING D5-JMM-1
10937: PPUSH
10938: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10942: LD_EXP 35
10946: PPUSH
10947: LD_STRING D5-Gos-2
10949: PPUSH
10950: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10954: LD_EXP 17
10958: PPUSH
10959: LD_STRING D5-JMM-2
10961: PPUSH
10962: CALL_OW 88
// end ; DialogueOff ;
10966: CALL_OW 7
// InGameOff ;
10970: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10974: LD_STRING QSaveBelkov
10976: PPUSH
10977: CALL_OW 97
10981: PUSH
10982: LD_INT 1
10984: DOUBLE
10985: EQUAL
10986: IFTRUE 10990
10988: GO 11040
10990: POP
// begin DialogueOn ;
10991: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10995: LD_EXP 17
10999: PPUSH
11000: LD_STRING D5a-JMM-1
11002: PPUSH
11003: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
11007: LD_EXP 50
11011: PPUSH
11012: LD_STRING D5a-Bel-1
11014: PPUSH
11015: CALL_OW 94
// DialogueOff ;
11019: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
11023: LD_EXP 50
11027: PPUSH
11028: LD_INT 83
11030: PPUSH
11031: LD_INT 49
11033: PPUSH
11034: CALL_OW 111
// end ; 2 :
11038: GO 11073
11040: LD_INT 2
11042: DOUBLE
11043: EQUAL
11044: IFTRUE 11048
11046: GO 11072
11048: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
11049: LD_EXP 17
11053: PPUSH
11054: LD_STRING D5a-JMM-2
11056: PPUSH
11057: CALL_OW 88
// ComHold ( Belkov ) ;
11061: LD_EXP 50
11065: PPUSH
11066: CALL_OW 140
// end ; end ;
11070: GO 11073
11072: POP
// time := 0 0$00 ;
11073: LD_ADDR_VAR 0 1
11077: PUSH
11078: LD_INT 0
11080: ST_TO_ADDR
// vehSpawned := false ;
11081: LD_ADDR_VAR 0 3
11085: PUSH
11086: LD_INT 0
11088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11089: LD_INT 35
11091: PPUSH
11092: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11096: LD_VAR 0 1
11100: PUSH
11101: LD_INT 350
11103: PUSH
11104: LD_INT 175
11106: PUSH
11107: LD_INT 105
11109: PUSH
11110: LD_INT 70
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: PUSH
11119: LD_OWVAR 67
11123: ARRAY
11124: GREATEREQUAL
11125: IFFALSE 11134
11127: PUSH
11128: LD_VAR 0 3
11132: NOT
11133: AND
11134: IFFALSE 11224
// begin vehSpawned := true ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: LD_INT 1
11143: ST_TO_ADDR
// uc_side := 3 ;
11144: LD_ADDR_OWVAR 20
11148: PUSH
11149: LD_INT 3
11151: ST_TO_ADDR
// uc_nation := 3 ;
11152: LD_ADDR_OWVAR 21
11156: PUSH
11157: LD_INT 3
11159: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11160: LD_INT 22
11162: PPUSH
11163: LD_INT 3
11165: PPUSH
11166: LD_INT 3
11168: PPUSH
11169: LD_INT 43
11171: PPUSH
11172: LD_INT 100
11174: PPUSH
11175: CALL 22432 0 5
// veh := CreateVehicle ;
11179: LD_ADDR_VAR 0 2
11183: PUSH
11184: CALL_OW 45
11188: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11189: LD_VAR 0 2
11193: PPUSH
11194: LD_INT 130
11196: PPUSH
11197: LD_INT 131
11199: PPUSH
11200: LD_INT 0
11202: PPUSH
11203: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11207: LD_VAR 0 2
11211: PPUSH
11212: LD_INT 100
11214: PPUSH
11215: LD_INT 82
11217: PPUSH
11218: CALL_OW 114
// end else
11222: GO 11238
// time := time + 0 0$1 ;
11224: LD_ADDR_VAR 0 1
11228: PUSH
11229: LD_VAR 0 1
11233: PUSH
11234: LD_INT 35
11236: PLUS
11237: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11238: LD_EXP 50
11242: PPUSH
11243: CALL_OW 301
11247: IFFALSE 11264
11249: PUSH
11250: LD_EXP 50
11254: PPUSH
11255: CALL_OW 255
11259: PUSH
11260: LD_INT 4
11262: EQUAL
11263: AND
11264: IFTRUE 11306
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PPUSH
11277: CALL_OW 69
11281: PPUSH
11282: LD_EXP 50
11286: PPUSH
11287: CALL_OW 74
11291: PPUSH
11292: LD_EXP 50
11296: PPUSH
11297: CALL_OW 296
11301: PUSH
11302: LD_INT 10
11304: LESS
11305: OR
11306: IFFALSE 11089
// if IsDead ( Belkov ) then
11308: LD_EXP 50
11312: PPUSH
11313: CALL_OW 301
11317: IFFALSE 11342
// begin CenterNowOnUnits ( Belkov ) ;
11319: LD_EXP 50
11323: PPUSH
11324: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11328: LD_EXP 17
11332: PPUSH
11333: LD_STRING D5a-JMM-2a
11335: PPUSH
11336: CALL_OW 88
// exit ;
11340: GO 11408
// end ; if See ( 7 , Belkov ) then
11342: LD_INT 7
11344: PPUSH
11345: LD_EXP 50
11349: PPUSH
11350: CALL_OW 292
11354: IFFALSE 11368
// SetSide ( Belkov , 7 ) ;
11356: LD_EXP 50
11360: PPUSH
11361: LD_INT 7
11363: PPUSH
11364: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11368: LD_INT 35
11370: PPUSH
11371: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11375: LD_EXP 50
11379: PPUSH
11380: LD_INT 66
11382: PPUSH
11383: LD_INT 45
11385: PPUSH
11386: CALL_OW 297
11390: PUSH
11391: LD_INT 30
11393: LESS
11394: IFFALSE 11368
// Say ( Belkov , D6-Bel-1 ) ;
11396: LD_EXP 50
11400: PPUSH
11401: LD_STRING D6-Bel-1
11403: PPUSH
11404: CALL_OW 88
// end ;
11408: PPOPN 3
11410: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11411: LD_EXP 50
11415: PPUSH
11416: CALL_OW 302
11420: IFFALSE 11467
11422: PUSH
11423: LD_EXP 50
11427: PPUSH
11428: CALL_OW 504
11432: PUSH
11433: LD_INT 2
11435: PUSH
11436: LD_INT 34
11438: PUSH
11439: LD_INT 47
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: LD_INT 34
11448: PUSH
11449: LD_INT 45
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: PPUSH
11461: CALL_OW 69
11465: IN
11466: AND
11467: IFFALSE 11484
11469: GO 11471
11471: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11472: LD_EXP 50
11476: PPUSH
11477: LD_STRING D7-Bel-1
11479: PPUSH
11480: CALL_OW 88
11484: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11485: LD_INT 22
11487: PUSH
11488: LD_INT 7
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: LD_INT 101
11497: PUSH
11498: LD_INT 2
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: PPUSH
11509: CALL_OW 69
11513: IFFALSE 11522
11515: PUSH
11516: LD_EXP 9
11520: NOT
11521: AND
11522: IFFALSE 11536
11524: PUSH
11525: LD_EXP 49
11529: PPUSH
11530: CALL_OW 305
11534: NOT
11535: AND
11536: IFFALSE 12021
11538: GO 11540
11540: DISABLE
11541: LD_INT 0
11543: PPUSH
// begin ar_base_spotted := true ;
11544: LD_ADDR_EXP 9
11548: PUSH
11549: LD_INT 1
11551: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11552: LD_ADDR_VAR 0 1
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 21
11569: PUSH
11570: LD_INT 3
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PPUSH
11581: CALL_OW 69
11585: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11586: LD_ADDR_VAR 0 1
11590: PUSH
11591: LD_VAR 0 1
11595: PPUSH
11596: LD_EXP 17
11600: PPUSH
11601: CALL_OW 74
11605: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11606: LD_INT 7
11608: PPUSH
11609: LD_INT 3
11611: PPUSH
11612: CALL_OW 332
// DialogueOn ;
11616: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11620: LD_VAR 0 1
11624: PPUSH
11625: CALL_OW 250
11629: PPUSH
11630: LD_VAR 0 1
11634: PPUSH
11635: CALL_OW 251
11639: PPUSH
11640: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11644: LD_ADDR_VAR 0 1
11648: PUSH
11649: LD_INT 22
11651: PUSH
11652: LD_INT 7
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 23
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: PPUSH
11684: CALL_OW 69
11688: PUSH
11689: LD_EXP 17
11693: PUSH
11694: LD_EXP 21
11698: PUSH
11699: LD_EXP 22
11703: PUSH
11704: LD_EXP 29
11708: PUSH
11709: LD_EXP 18
11713: PUSH
11714: LD_EXP 27
11718: PUSH
11719: LD_EXP 23
11723: PUSH
11724: LD_EXP 25
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: DIFF
11739: ST_TO_ADDR
// if not tmp then
11740: LD_VAR 0 1
11744: NOT
11745: IFFALSE 11819
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11747: LD_ADDR_VAR 0 1
11751: PUSH
11752: LD_INT 22
11754: PUSH
11755: LD_INT 7
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 23
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 26
11774: PUSH
11775: LD_INT 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: PPUSH
11787: CALL_OW 69
11791: PUSH
11792: LD_EXP 32
11796: PUSH
11797: LD_EXP 19
11801: PUSH
11802: LD_EXP 30
11806: PUSH
11807: LD_EXP 31
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: DIFF
11818: ST_TO_ADDR
// if tmp then
11819: LD_VAR 0 1
11823: IFFALSE 11894
// case GetSex ( tmp [ 1 ] ) of sex_male :
11825: LD_VAR 0 1
11829: PUSH
11830: LD_INT 1
11832: ARRAY
11833: PPUSH
11834: CALL_OW 258
11838: PUSH
11839: LD_INT 1
11841: DOUBLE
11842: EQUAL
11843: IFTRUE 11847
11845: GO 11866
11847: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11848: LD_VAR 0 1
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_STRING D9-Sol1-1
11859: PPUSH
11860: CALL_OW 88
11864: GO 11894
11866: LD_INT 2
11868: DOUBLE
11869: EQUAL
11870: IFTRUE 11874
11872: GO 11893
11874: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11875: LD_VAR 0 1
11879: PUSH
11880: LD_INT 1
11882: ARRAY
11883: PPUSH
11884: LD_STRING D9-FSol1-1
11886: PPUSH
11887: CALL_OW 88
11891: GO 11894
11893: POP
// if Frank then
11894: LD_EXP 29
11898: IFFALSE 12002
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11900: LD_EXP 59
11904: PPUSH
11905: CALL_OW 250
11909: PPUSH
11910: LD_EXP 59
11914: PPUSH
11915: CALL_OW 251
11919: PPUSH
11920: LD_INT 7
11922: PPUSH
11923: LD_INT 8
11925: PPUSH
11926: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11930: LD_EXP 59
11934: PPUSH
11935: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11939: LD_EXP 29
11943: PPUSH
11944: LD_STRING D9-Frank-1
11946: PPUSH
11947: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11951: LD_EXP 17
11955: PPUSH
11956: LD_STRING D9-JMM-1
11958: PPUSH
11959: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11963: LD_EXP 29
11967: PPUSH
11968: LD_STRING D9-Frank-2
11970: PPUSH
11971: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11975: LD_EXP 59
11979: PPUSH
11980: CALL_OW 250
11984: PPUSH
11985: LD_EXP 59
11989: PPUSH
11990: CALL_OW 251
11994: PPUSH
11995: LD_INT 7
11997: PPUSH
11998: CALL_OW 331
// end ; DialogueOff ;
12002: CALL_OW 7
// wait ( 1 1$00 ) ;
12006: LD_INT 2100
12008: PPUSH
12009: CALL_OW 67
// ar_active_attack := true ;
12013: LD_ADDR_EXP 10
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// end ;
12021: PPOPN 1
12023: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
12024: LD_EXP 8
12028: IFTRUE 12040
12030: PUSH
12031: LD_OWVAR 1
12035: PUSH
12036: LD_INT 42000
12038: GREATEREQUAL
12039: OR
12040: IFFALSE 13104
12042: GO 12044
12044: DISABLE
12045: LD_INT 0
12047: PPUSH
12048: PPUSH
// begin selected_option := 1 ;
12049: LD_ADDR_VAR 0 2
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// wait ( 5 5$00 ) ;
12057: LD_INT 10500
12059: PPUSH
12060: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12064: LD_INT 35
12066: PPUSH
12067: CALL_OW 67
// until not ru_attackers ;
12071: LD_EXP 55
12075: NOT
12076: IFFALSE 12064
// PrepareBurlak ;
12078: CALL 2374 0 0
// repeat wait ( 0 0$2 ) ;
12082: LD_INT 70
12084: PPUSH
12085: CALL_OW 67
// until not HasTask ( Burlak ) ;
12089: LD_EXP 49
12093: PPUSH
12094: CALL_OW 314
12098: NOT
12099: IFFALSE 12082
// InGameOn ;
12101: CALL_OW 8
// DialogueOn ;
12105: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12109: LD_EXP 52
12113: PPUSH
12114: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12118: LD_EXP 49
12122: PPUSH
12123: LD_STRING D10-Bur-1
12125: PPUSH
12126: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12130: LD_EXP 50
12134: IFFALSE 12151
12136: PUSH
12137: LD_EXP 50
12141: PPUSH
12142: CALL_OW 255
12146: PUSH
12147: LD_INT 7
12149: EQUAL
12150: AND
12151: IFFALSE 12165
// Say ( Belkov , D10-Bel-1 ) ;
12153: LD_EXP 50
12157: PPUSH
12158: LD_STRING D10-Bel-1
12160: PPUSH
12161: CALL_OW 88
// if Gossudarov then
12165: LD_EXP 35
12169: IFFALSE 12183
// Say ( Gossudarov , D10-Gos-1 ) ;
12171: LD_EXP 35
12175: PPUSH
12176: LD_STRING D10-Gos-1
12178: PPUSH
12179: CALL_OW 88
// if Kirilenkova then
12183: LD_EXP 36
12187: IFFALSE 12201
// Say ( Kirilenkova , D10-Kir-1 ) ;
12189: LD_EXP 36
12193: PPUSH
12194: LD_STRING D10-Kir-1
12196: PPUSH
12197: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12201: CALL 15911 0 0
12205: PPUSH
12206: LD_STRING D10-RSol1-1
12208: PPUSH
12209: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12213: LD_EXP 49
12217: PPUSH
12218: LD_STRING D10-Bur-2
12220: PPUSH
12221: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12225: LD_EXP 17
12229: PPUSH
12230: LD_STRING D10-JMM-2
12232: PPUSH
12233: CALL_OW 88
// if Kirilenkova then
12237: LD_EXP 36
12241: IFFALSE 12257
// Say ( Kirilenkova , D10-Kir-2 ) else
12243: LD_EXP 36
12247: PPUSH
12248: LD_STRING D10-Kir-2
12250: PPUSH
12251: CALL_OW 88
12255: GO 12269
// Say ( SolRu , D10-RSol1-2 ) ;
12257: CALL 15911 0 0
12261: PPUSH
12262: LD_STRING D10-RSol1-2
12264: PPUSH
12265: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12269: LD_EXP 17
12273: PPUSH
12274: LD_STRING D10-JMM-3
12276: PPUSH
12277: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12281: LD_EXP 49
12285: PPUSH
12286: LD_STRING D10-Bur-3
12288: PPUSH
12289: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12293: LD_EXP 17
12297: PPUSH
12298: LD_STRING D10-JMM-4
12300: PPUSH
12301: CALL_OW 88
// DialogueOff ;
12305: CALL_OW 7
// InGameOff ;
12309: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12313: LD_STRING M2
12315: PPUSH
12316: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12320: LD_INT 35
12322: PPUSH
12323: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12327: LD_INT 22
12329: PUSH
12330: LD_INT 7
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 91
12339: PUSH
12340: LD_EXP 49
12344: PUSH
12345: LD_INT 8
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PPUSH
12357: CALL_OW 69
12361: IFFALSE 12320
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12363: LD_ADDR_VAR 0 1
12367: PUSH
12368: LD_INT 22
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PPUSH
12378: CALL_OW 69
12382: PUSH
12383: FOR_IN
12384: IFFALSE 12400
// SetSide ( i , 7 ) ;
12386: LD_VAR 0 1
12390: PPUSH
12391: LD_INT 7
12393: PPUSH
12394: CALL_OW 235
12398: GO 12383
12400: POP
12401: POP
// ChangeMissionObjectives ( M3 ) ;
12402: LD_STRING M3
12404: PPUSH
12405: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12409: LD_INT 35
12411: PPUSH
12412: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12416: LD_EXP 17
12420: PPUSH
12421: LD_EXP 49
12425: PPUSH
12426: CALL_OW 296
12430: PUSH
12431: LD_INT 8
12433: LESS
12434: IFFALSE 12409
// ComTurnUnit ( JMM , Burlak ) ;
12436: LD_EXP 17
12440: PPUSH
12441: LD_EXP 49
12445: PPUSH
12446: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12450: LD_EXP 49
12454: PPUSH
12455: LD_EXP 17
12459: PPUSH
12460: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12464: LD_INT 10
12466: PPUSH
12467: CALL_OW 67
// DialogueOn ;
12471: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12475: LD_EXP 17
12479: PPUSH
12480: LD_STRING D11-JMM-1
12482: PPUSH
12483: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12487: LD_EXP 49
12491: PPUSH
12492: LD_STRING D11-Bur-1
12494: PPUSH
12495: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12499: LD_EXP 17
12503: PPUSH
12504: LD_STRING D11-JMM-2
12506: PPUSH
12507: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12511: LD_EXP 49
12515: PPUSH
12516: LD_STRING D11-Bur-2
12518: PPUSH
12519: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12523: LD_EXP 17
12527: PPUSH
12528: LD_STRING D11-JMM-3
12530: PPUSH
12531: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12535: LD_EXP 49
12539: PPUSH
12540: LD_STRING D11-Bur-3
12542: PPUSH
12543: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12547: LD_EXP 17
12551: PPUSH
12552: LD_STRING D11-JMM-4
12554: PPUSH
12555: CALL_OW 88
// if ar_base_spotted then
12559: LD_EXP 9
12563: IFFALSE 12579
// Say ( Burlak , D12-Bur-1 ) else
12565: LD_EXP 49
12569: PPUSH
12570: LD_STRING D12-Bur-1
12572: PPUSH
12573: CALL_OW 88
12577: GO 12618
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 3
12584: PPUSH
12585: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12589: LD_INT 127
12591: PPUSH
12592: LD_INT 45
12594: PPUSH
12595: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12599: LD_EXP 49
12603: PPUSH
12604: LD_STRING D12-Bur-1a
12606: PPUSH
12607: CALL_OW 88
// dwait ( 0 0$2 ) ;
12611: LD_INT 70
12613: PPUSH
12614: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12618: LD_EXP 58
12622: PPUSH
12623: CALL_OW 302
12627: NOT
12628: IFFALSE 12636
// begin DialogueOff ;
12630: CALL_OW 7
// exit ;
12634: GO 13104
// end ; Say ( Burlak , D12-Bur-1b ) ;
12636: LD_EXP 49
12640: PPUSH
12641: LD_STRING D12-Bur-1b
12643: PPUSH
12644: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12648: LD_EXP 17
12652: PPUSH
12653: LD_STRING D12-JMM-1
12655: PPUSH
12656: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12660: LD_EXP 49
12664: PPUSH
12665: LD_STRING D12-Bur-2
12667: PPUSH
12668: CALL_OW 88
// if Roth then
12672: LD_EXP 18
12676: IFFALSE 12692
// Say ( Roth , D12-Roth-2 ) else
12678: LD_EXP 18
12682: PPUSH
12683: LD_STRING D12-Roth-2
12685: PPUSH
12686: CALL_OW 88
12690: GO 12704
// Say ( SciRu , D12-RSci1-2 ) ;
12692: CALL 15764 0 0
12696: PPUSH
12697: LD_STRING D12-RSci1-2
12699: PPUSH
12700: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12704: LD_EXP 17
12708: PPUSH
12709: LD_STRING D12-JMM-2
12711: PPUSH
12712: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12716: LD_EXP 49
12720: PPUSH
12721: LD_STRING D12-Bur-3
12723: PPUSH
12724: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12728: LD_EXP 17
12732: PPUSH
12733: LD_STRING D12-JMM-3
12735: PPUSH
12736: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12740: LD_EXP 49
12744: PPUSH
12745: LD_STRING D12-Bur-4
12747: PPUSH
12748: CALL_OW 88
// case Query ( QBase ) of 1 :
12752: LD_STRING QBase
12754: PPUSH
12755: CALL_OW 97
12759: PUSH
12760: LD_INT 1
12762: DOUBLE
12763: EQUAL
12764: IFTRUE 12768
12766: GO 12886
12768: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12769: LD_EXP 17
12773: PPUSH
12774: LD_STRING D13a-JMM-1
12776: PPUSH
12777: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12781: LD_EXP 49
12785: PPUSH
12786: LD_STRING D13a-Bur-1
12788: PPUSH
12789: CALL_OW 88
// if Roth then
12793: LD_EXP 18
12797: IFFALSE 12813
// Say ( Roth , D13a-Roth-1 ) else
12799: LD_EXP 18
12803: PPUSH
12804: LD_STRING D13a-Roth-1
12806: PPUSH
12807: CALL_OW 88
12811: GO 12825
// Say ( SciRu , D13a-RSci1-1 ) ;
12813: CALL 15764 0 0
12817: PPUSH
12818: LD_STRING D13a-RSci1-1
12820: PPUSH
12821: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12825: LD_EXP 17
12829: PPUSH
12830: LD_STRING D13a-JMM-2
12832: PPUSH
12833: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12837: LD_STRING QBaseAgain
12839: PPUSH
12840: CALL_OW 97
12844: PUSH
12845: LD_INT 1
12847: DOUBLE
12848: EQUAL
12849: IFTRUE 12853
12851: GO 12864
12853: POP
// selected_option := 2 ; 2 :
12854: LD_ADDR_VAR 0 2
12858: PUSH
12859: LD_INT 2
12861: ST_TO_ADDR
12862: GO 12884
12864: LD_INT 2
12866: DOUBLE
12867: EQUAL
12868: IFTRUE 12872
12870: GO 12883
12872: POP
// selected_option := 3 ; end ;
12873: LD_ADDR_VAR 0 2
12877: PUSH
12878: LD_INT 3
12880: ST_TO_ADDR
12881: GO 12884
12883: POP
// end ; 2 :
12884: GO 12925
12886: LD_INT 2
12888: DOUBLE
12889: EQUAL
12890: IFTRUE 12894
12892: GO 12905
12894: POP
// selected_option := 2 ; 3 :
12895: LD_ADDR_VAR 0 2
12899: PUSH
12900: LD_INT 2
12902: ST_TO_ADDR
12903: GO 12925
12905: LD_INT 3
12907: DOUBLE
12908: EQUAL
12909: IFTRUE 12913
12911: GO 12924
12913: POP
// selected_option := 3 ; end ;
12914: LD_ADDR_VAR 0 2
12918: PUSH
12919: LD_INT 3
12921: ST_TO_ADDR
12922: GO 12925
12924: POP
// if selected_option = 2 then
12925: LD_VAR 0 2
12929: PUSH
12930: LD_INT 2
12932: EQUAL
12933: IFFALSE 13037
// begin Say ( JMM , D13b-JMM-1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_STRING D13b-JMM-1
12942: PPUSH
12943: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12947: LD_EXP 49
12951: PPUSH
12952: LD_STRING D13b-Bur-1
12954: PPUSH
12955: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12959: LD_EXP 17
12963: PPUSH
12964: LD_STRING D13b-JMM-2
12966: PPUSH
12967: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12971: LD_EXP 58
12975: PPUSH
12976: LD_STRING D13b-Abd-2
12978: PPUSH
12979: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12983: LD_EXP 17
12987: PPUSH
12988: LD_STRING D13b-JMM-3
12990: PPUSH
12991: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12995: LD_EXP 58
12999: PPUSH
13000: LD_STRING D13b-Abd-3
13002: PPUSH
13003: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
13007: LD_EXP 17
13011: PPUSH
13012: LD_STRING D13b-JMM-4
13014: PPUSH
13015: CALL_OW 88
// ar_active_attack := true ;
13019: LD_ADDR_EXP 10
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
13027: LD_INT 1
13029: PPUSH
13030: LD_STRING 13a_negotiationWithArabs
13032: PPUSH
13033: CALL_OW 39
// end ; if selected_option = 3 then
13037: LD_VAR 0 2
13041: PUSH
13042: LD_INT 3
13044: EQUAL
13045: IFFALSE 13071
// begin Say ( JMM , D13c-JMM-1 ) ;
13047: LD_EXP 17
13051: PPUSH
13052: LD_STRING D13c-JMM-1
13054: PPUSH
13055: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
13059: LD_EXP 49
13063: PPUSH
13064: LD_STRING D13c-Bur-1
13066: PPUSH
13067: CALL_OW 88
// end ; DialogueOff ;
13071: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
13075: LD_STRING M4
13077: PPUSH
13078: CALL_OW 337
// if not ar_active_attack then
13082: LD_EXP 10
13086: NOT
13087: IFFALSE 13104
// begin wait ( 6 6$00 ) ;
13089: LD_INT 12600
13091: PPUSH
13092: CALL_OW 67
// ar_active_attack := true ;
13096: LD_ADDR_EXP 10
13100: PUSH
13101: LD_INT 1
13103: ST_TO_ADDR
// end ; end ;
13104: PPOPN 2
13106: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13107: LD_EXP 49
13111: PPUSH
13112: CALL_OW 305
13116: IFFALSE 13133
13118: PUSH
13119: LD_EXP 49
13123: PPUSH
13124: CALL_OW 255
13128: PUSH
13129: LD_INT 7
13131: EQUAL
13132: AND
13133: IFFALSE 13360
13135: GO 13137
13137: DISABLE
13138: LD_INT 0
13140: PPUSH
// begin wait ( 4 4$40 ) ;
13141: LD_INT 9800
13143: PPUSH
13144: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13148: LD_INT 35
13150: PPUSH
13151: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13155: LD_EXP 55
13159: NOT
13160: IFFALSE 13189
13162: PUSH
13163: LD_INT 22
13165: PUSH
13166: LD_INT 6
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 50
13175: PUSH
13176: EMPTY
13177: LIST
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PPUSH
13183: CALL_OW 69
13187: NOT
13188: AND
13189: IFFALSE 13148
// PrepareGnyevko ;
13191: CALL 2318 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13195: LD_EXP 51
13199: PPUSH
13200: LD_INT 124
13202: PPUSH
13203: LD_INT 118
13205: PPUSH
13206: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13210: LD_EXP 51
13214: PPUSH
13215: CALL_OW 200
// time := 0 0$00 ;
13219: LD_ADDR_VAR 0 1
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13227: LD_INT 35
13229: PPUSH
13230: CALL_OW 67
// time := time + 0 0$1 ;
13234: LD_ADDR_VAR 0 1
13238: PUSH
13239: LD_VAR 0 1
13243: PUSH
13244: LD_INT 35
13246: PLUS
13247: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13248: LD_EXP 51
13252: PPUSH
13253: LD_INT 124
13255: PPUSH
13256: LD_INT 118
13258: PPUSH
13259: CALL_OW 307
13263: IFTRUE 13275
13265: PUSH
13266: LD_VAR 0 1
13270: PUSH
13271: LD_INT 1050
13273: GREATEREQUAL
13274: OR
13275: IFFALSE 13227
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13277: LD_EXP 51
13281: PPUSH
13282: LD_STRING DBelkov-Gny-1
13284: PPUSH
13285: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13289: LD_EXP 49
13293: PPUSH
13294: LD_STRING DBelkov-Bur-1a
13296: PPUSH
13297: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13301: LD_INT 35
13303: PPUSH
13304: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13308: LD_EXP 51
13312: PPUSH
13313: LD_INT 22
13315: PUSH
13316: LD_INT 7
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PPUSH
13323: CALL_OW 69
13327: PPUSH
13328: LD_EXP 51
13332: PPUSH
13333: CALL_OW 74
13337: PPUSH
13338: CALL_OW 296
13342: PUSH
13343: LD_INT 8
13345: LESS
13346: IFFALSE 13301
// SetSide ( Gnyevko , 7 ) ;
13348: LD_EXP 51
13352: PPUSH
13353: LD_INT 7
13355: PPUSH
13356: CALL_OW 235
// end ;
13360: PPOPN 1
13362: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13363: LD_EXP 49
13367: PPUSH
13368: CALL_OW 255
13372: PUSH
13373: LD_INT 7
13375: EQUAL
13376: IFFALSE 13386
13378: GO 13380
13380: DISABLE
// begin enable ;
13381: ENABLE
// PrepareAmericanAttack ;
13382: CALL 8687 0 0
// end ;
13386: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13387: LD_INT 22
13389: PUSH
13390: LD_INT 1
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PPUSH
13397: CALL_OW 69
13401: IFFALSE 13599
13403: GO 13405
13405: DISABLE
13406: LD_INT 0
13408: PPUSH
13409: PPUSH
// begin if LoadVariable ( 12a_PowellKilled , false ) then
13410: LD_STRING 12a_PowellKilled
13412: PPUSH
13413: LD_INT 0
13415: PPUSH
13416: CALL_OW 30
13420: IFFALSE 13424
// exit ;
13422: GO 13599
// while true do
13424: LD_INT 1
13426: IFFALSE 13483
// begin wait ( 0 0$1 ) ;
13428: LD_INT 35
13430: PPUSH
13431: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13435: LD_ADDR_VAR 0 2
13439: PUSH
13440: LD_INT 22
13442: PUSH
13443: LD_INT 1
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PPUSH
13450: CALL_OW 69
13454: PPUSH
13455: LD_EXP 17
13459: PPUSH
13460: CALL_OW 74
13464: ST_TO_ADDR
// if See ( 7 , tmp ) then
13465: LD_INT 7
13467: PPUSH
13468: LD_VAR 0 2
13472: PPUSH
13473: CALL_OW 292
13477: IFFALSE 13481
// break ;
13479: GO 13483
// end ;
13481: GO 13424
// DialogueOn ;
13483: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13487: LD_VAR 0 2
13491: PPUSH
13492: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13496: LD_VAR 0 2
13500: PPUSH
13501: CALL_OW 250
13505: PPUSH
13506: LD_VAR 0 2
13510: PPUSH
13511: CALL_OW 251
13515: PPUSH
13516: LD_INT 7
13518: PPUSH
13519: LD_INT 8
13521: PPUSH
13522: CALL_OW 330
// if Denis then
13526: LD_EXP 23
13530: IFFALSE 13544
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13532: LD_EXP 23
13536: PPUSH
13537: LD_STRING DAmerAttack-Pet-1
13539: PPUSH
13540: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13544: LD_EXP 17
13548: PPUSH
13549: LD_STRING DAmerAttack-JMM-1
13551: PPUSH
13552: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13556: LD_EXP 49
13560: PPUSH
13561: LD_STRING DStop-Bur-1
13563: PPUSH
13564: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13568: LD_VAR 0 2
13572: PPUSH
13573: CALL_OW 250
13577: PPUSH
13578: LD_VAR 0 2
13582: PPUSH
13583: CALL_OW 251
13587: PPUSH
13588: LD_INT 7
13590: PPUSH
13591: CALL_OW 331
// DialogueOff ;
13595: CALL_OW 7
// end ;
13599: PPOPN 2
13601: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13602: LD_INT 22
13604: PUSH
13605: LD_INT 3
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PUSH
13612: LD_INT 21
13614: PUSH
13615: LD_INT 1
13617: PUSH
13618: EMPTY
13619: LIST
13620: LIST
13621: PUSH
13622: EMPTY
13623: LIST
13624: LIST
13625: PPUSH
13626: CALL_OW 69
13630: PUSH
13631: LD_INT 0
13633: EQUAL
13634: IFFALSE 13684
13636: GO 13638
13638: DISABLE
// begin ru_active_attack := false ;
13639: LD_ADDR_EXP 6
13643: PUSH
13644: LD_INT 0
13646: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13647: LD_STRING M5a
13649: PPUSH
13650: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13654: LD_EXP 17
13658: PPUSH
13659: LD_STRING D8-JMM-1
13661: PPUSH
13662: CALL_OW 88
// if Gossudarov then
13666: LD_EXP 35
13670: IFFALSE 13684
// Say ( Gossudarov , D8-Gos-1 ) ;
13672: LD_EXP 35
13676: PPUSH
13677: LD_STRING D8-Gos-1
13679: PPUSH
13680: CALL_OW 88
// end ;
13684: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13685: LD_INT 22
13687: PUSH
13688: LD_INT 2
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PUSH
13695: LD_INT 21
13697: PUSH
13698: LD_INT 1
13700: PUSH
13701: EMPTY
13702: LIST
13703: LIST
13704: PUSH
13705: EMPTY
13706: LIST
13707: LIST
13708: PPUSH
13709: CALL_OW 69
13713: PUSH
13714: LD_INT 0
13716: EQUAL
13717: IFFALSE 13775
13719: GO 13721
13721: DISABLE
// begin ar_active_attack := false ;
13722: LD_ADDR_EXP 10
13726: PUSH
13727: LD_INT 0
13729: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13730: LD_STRING M4c
13732: PPUSH
13733: CALL_OW 337
// if Roth then
13737: LD_EXP 18
13741: IFFALSE 13757
// Say ( Roth , DStop-Roth-1 ) else
13743: LD_EXP 18
13747: PPUSH
13748: LD_STRING DStop-Roth-1
13750: PPUSH
13751: CALL_OW 88
13755: GO 13775
// if Gossudarov then
13757: LD_EXP 35
13761: IFFALSE 13775
// Say ( Gossudarov , D8-Gos-1a ) ;
13763: LD_EXP 35
13767: PPUSH
13768: LD_STRING D8-Gos-1a
13770: PPUSH
13771: CALL_OW 88
// end ;
13775: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13776: LD_INT 3
13778: PPUSH
13779: CALL_OW 469
13783: IFFALSE 13791
13785: PUSH
13786: LD_EXP 13
13790: AND
13791: IFFALSE 13846
13793: GO 13795
13795: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13796: LD_INT 3
13798: PPUSH
13799: CALL_OW 469
13803: PPUSH
13804: CALL 9176 0 1
// if Difficulty > 2 then
13808: LD_OWVAR 67
13812: PUSH
13813: LD_INT 2
13815: GREATER
13816: IFFALSE 13846
// begin wait ( 5 5$00 ) ;
13818: LD_INT 10500
13820: PPUSH
13821: CALL_OW 67
// if FindArtifact ( 3 ) then
13825: LD_INT 3
13827: PPUSH
13828: CALL_OW 469
13832: IFFALSE 13846
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13834: LD_INT 3
13836: PPUSH
13837: CALL_OW 469
13841: PPUSH
13842: CALL 9176 0 1
// end ; end ;
13846: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13847: LD_INT 7
13849: PPUSH
13850: LD_INT 1
13852: PPUSH
13853: LD_INT 1
13855: PPUSH
13856: CALL 17559 0 3
13860: PUSH
13861: LD_INT 0
13863: EQUAL
13864: IFFALSE 13885
13866: PUSH
13867: LD_INT 7
13869: PPUSH
13870: LD_INT 3
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL 17559 0 3
13880: PUSH
13881: LD_INT 0
13883: EQUAL
13884: AND
13885: IFFALSE 13897
13887: GO 13889
13889: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13890: LD_STRING M1a
13892: PPUSH
13893: CALL_OW 337
// end ;
13897: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13898: LD_INT 22
13900: PUSH
13901: LD_INT 2
13903: PUSH
13904: EMPTY
13905: LIST
13906: LIST
13907: PUSH
13908: LD_INT 23
13910: PUSH
13911: LD_INT 2
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: PUSH
13918: LD_INT 21
13920: PUSH
13921: LD_INT 1
13923: PUSH
13924: EMPTY
13925: LIST
13926: LIST
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: LIST
13932: PPUSH
13933: CALL_OW 69
13937: PUSH
13938: LD_INT 0
13940: EQUAL
13941: IFFALSE 13988
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 3
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 23
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 21
13966: PUSH
13967: LD_INT 1
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: PPUSH
13979: CALL_OW 69
13983: PUSH
13984: LD_INT 0
13986: EQUAL
13987: AND
13988: IFFALSE 14010
13990: PUSH
13991: LD_INT 22
13993: PUSH
13994: LD_INT 1
13996: PUSH
13997: EMPTY
13998: LIST
13999: LIST
14000: PPUSH
14001: CALL_OW 69
14005: PUSH
14006: LD_INT 0
14008: EQUAL
14009: AND
14010: IFFALSE 14031
14012: PUSH
14013: LD_INT 7
14015: PPUSH
14016: LD_INT 1
14018: PPUSH
14019: LD_INT 1
14021: PPUSH
14022: CALL 17559 0 3
14026: PUSH
14027: LD_INT 0
14029: EQUAL
14030: AND
14031: IFFALSE 14052
14033: PUSH
14034: LD_INT 7
14036: PPUSH
14037: LD_INT 3
14039: PPUSH
14040: LD_INT 1
14042: PPUSH
14043: CALL 17559 0 3
14047: PUSH
14048: LD_INT 0
14050: EQUAL
14051: AND
14052: IFFALSE 14069
14054: PUSH
14055: LD_EXP 49
14059: PPUSH
14060: CALL_OW 255
14064: PUSH
14065: LD_INT 7
14067: EQUAL
14068: AND
14069: IFFALSE 14082
14071: PUSH
14072: LD_EXP 49
14076: PPUSH
14077: CALL_OW 302
14081: AND
14082: IFFALSE 15761
14084: GO 14086
14086: DISABLE
14087: LD_INT 0
14089: PPUSH
14090: PPUSH
14091: PPUSH
14092: PPUSH
14093: PPUSH
14094: PPUSH
// begin m1 := false ;
14095: LD_ADDR_VAR 0 4
14099: PUSH
14100: LD_INT 0
14102: ST_TO_ADDR
// m2 := false ;
14103: LD_ADDR_VAR 0 5
14107: PUSH
14108: LD_INT 0
14110: ST_TO_ADDR
// m3 := false ;
14111: LD_ADDR_VAR 0 6
14115: PUSH
14116: LD_INT 0
14118: ST_TO_ADDR
// if tick < 40 40$00 then
14119: LD_OWVAR 1
14123: PUSH
14124: LD_INT 84000
14126: LESS
14127: IFFALSE 14136
// SetAchievement ( ACH_ASPEED_17 ) ;
14129: LD_STRING ACH_ASPEED_17
14131: PPUSH
14132: CALL_OW 543
// wait ( 0 0$5 ) ;
14136: LD_INT 175
14138: PPUSH
14139: CALL_OW 67
// if not masha_killed then
14143: LD_EXP 11
14147: NOT
14148: IFFALSE 14170
// begin m1 := true ;
14150: LD_ADDR_VAR 0 4
14154: PUSH
14155: LD_INT 1
14157: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14158: LD_STRING Masha
14160: PPUSH
14161: LD_INT 1
14163: PPUSH
14164: CALL_OW 101
// end else
14168: GO 14181
// AddMedal ( Masha , - 1 ) ;
14170: LD_STRING Masha
14172: PPUSH
14173: LD_INT 1
14175: NEG
14176: PPUSH
14177: CALL_OW 101
// if abdul_escaped then
14181: LD_EXP 14
14185: IFFALSE 14200
// AddMedal ( Abdul , - 1 ) else
14187: LD_STRING Abdul
14189: PPUSH
14190: LD_INT 1
14192: NEG
14193: PPUSH
14194: CALL_OW 101
14198: GO 14218
// begin m2 := true ;
14200: LD_ADDR_VAR 0 5
14204: PUSH
14205: LD_INT 1
14207: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14208: LD_STRING Abdul
14210: PPUSH
14211: LD_INT 1
14213: PPUSH
14214: CALL_OW 101
// end ; if loss_counter = 0 then
14218: LD_EXP 15
14222: PUSH
14223: LD_INT 0
14225: EQUAL
14226: IFFALSE 14248
// begin m3 := true ;
14228: LD_ADDR_VAR 0 6
14232: PUSH
14233: LD_INT 1
14235: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14236: LD_STRING People
14238: PPUSH
14239: LD_INT 2
14241: PPUSH
14242: CALL_OW 101
// end else
14246: GO 14310
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14248: LD_EXP 15
14252: PUSH
14253: LD_INT 3
14255: PUSH
14256: LD_INT 2
14258: PUSH
14259: LD_INT 2
14261: PUSH
14262: LD_INT 1
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: LIST
14269: LIST
14270: PUSH
14271: LD_OWVAR 67
14275: ARRAY
14276: LESSEQUAL
14277: IFFALSE 14299
// begin AddMedal ( People , 1 ) ;
14279: LD_STRING People
14281: PPUSH
14282: LD_INT 1
14284: PPUSH
14285: CALL_OW 101
// m3 := true ;
14289: LD_ADDR_VAR 0 6
14293: PUSH
14294: LD_INT 1
14296: ST_TO_ADDR
// end else
14297: GO 14310
// AddMedal ( People , - 1 ) ;
14299: LD_STRING People
14301: PPUSH
14302: LD_INT 1
14304: NEG
14305: PPUSH
14306: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14310: LD_OWVAR 67
14314: PUSH
14315: LD_INT 3
14317: GREATEREQUAL
14318: IFFALSE 14326
14320: PUSH
14321: LD_VAR 0 4
14325: AND
14326: IFFALSE 14334
14328: PUSH
14329: LD_VAR 0 5
14333: AND
14334: IFFALSE 14342
14336: PUSH
14337: LD_VAR 0 6
14341: AND
14342: IFFALSE 14354
// SetAchievementEX ( ACH_AMER , 17 ) ;
14344: LD_STRING ACH_AMER
14346: PPUSH
14347: LD_INT 17
14349: PPUSH
14350: CALL_OW 564
// GiveMedals ( MAIN ) ;
14354: LD_STRING MAIN
14356: PPUSH
14357: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14361: LD_ADDR_VAR 0 2
14365: PUSH
14366: LD_INT 22
14368: PUSH
14369: LD_INT 7
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PUSH
14376: LD_INT 50
14378: PUSH
14379: EMPTY
14380: LIST
14381: PUSH
14382: LD_INT 2
14384: PUSH
14385: LD_INT 25
14387: PUSH
14388: LD_INT 1
14390: PUSH
14391: EMPTY
14392: LIST
14393: LIST
14394: PUSH
14395: LD_INT 25
14397: PUSH
14398: LD_INT 2
14400: PUSH
14401: EMPTY
14402: LIST
14403: LIST
14404: PUSH
14405: LD_INT 25
14407: PUSH
14408: LD_INT 3
14410: PUSH
14411: EMPTY
14412: LIST
14413: LIST
14414: PUSH
14415: LD_INT 25
14417: PUSH
14418: LD_INT 4
14420: PUSH
14421: EMPTY
14422: LIST
14423: LIST
14424: PUSH
14425: LD_INT 25
14427: PUSH
14428: LD_INT 5
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PUSH
14435: LD_INT 25
14437: PUSH
14438: LD_INT 8
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: PUSH
14445: LD_INT 25
14447: PUSH
14448: LD_INT 9
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: LIST
14461: LIST
14462: LIST
14463: LIST
14464: PUSH
14465: EMPTY
14466: LIST
14467: LIST
14468: LIST
14469: PPUSH
14470: CALL_OW 69
14474: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14475: LD_VAR 0 2
14479: PPUSH
14480: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14484: LD_ADDR_VAR 0 3
14488: PUSH
14489: LD_EXP 17
14493: PUSH
14494: LD_EXP 18
14498: PUSH
14499: LD_EXP 19
14503: PUSH
14504: LD_EXP 20
14508: PUSH
14509: LD_EXP 21
14513: PUSH
14514: LD_EXP 22
14518: PUSH
14519: LD_EXP 23
14523: PUSH
14524: LD_EXP 24
14528: PUSH
14529: LD_EXP 25
14533: PUSH
14534: LD_EXP 26
14538: PUSH
14539: LD_EXP 27
14543: PUSH
14544: LD_EXP 28
14548: PUSH
14549: LD_EXP 29
14553: PUSH
14554: LD_EXP 30
14558: PUSH
14559: LD_EXP 31
14563: PUSH
14564: LD_EXP 32
14568: PUSH
14569: LD_EXP 33
14573: PUSH
14574: LD_EXP 35
14578: PUSH
14579: LD_EXP 36
14583: PUSH
14584: LD_EXP 37
14588: PUSH
14589: LD_EXP 39
14593: PUSH
14594: LD_EXP 40
14598: PUSH
14599: LD_EXP 41
14603: PUSH
14604: LD_EXP 42
14608: PUSH
14609: LD_EXP 43
14613: PUSH
14614: LD_EXP 44
14618: PUSH
14619: LD_EXP 45
14623: PUSH
14624: LD_EXP 46
14628: PUSH
14629: LD_EXP 47
14633: PUSH
14634: LD_EXP 48
14638: PUSH
14639: LD_EXP 49
14643: PUSH
14644: LD_EXP 50
14648: PUSH
14649: LD_EXP 51
14653: PUSH
14654: LD_EXP 34
14658: PUSH
14659: EMPTY
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: LIST
14684: LIST
14685: LIST
14686: LIST
14687: LIST
14688: LIST
14689: LIST
14690: LIST
14691: LIST
14692: LIST
14693: LIST
14694: ST_TO_ADDR
// if tmp diff tmp2 then
14695: LD_VAR 0 2
14699: PUSH
14700: LD_VAR 0 3
14704: DIFF
14705: IFFALSE 14725
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14707: LD_VAR 0 2
14711: PUSH
14712: LD_VAR 0 3
14716: DIFF
14717: PPUSH
14718: LD_STRING 13a_others
14720: PPUSH
14721: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14725: LD_EXP 17
14729: PPUSH
14730: LD_STRING 13a_JMM
14732: PPUSH
14733: CALL_OW 38
// if IsOk ( Mike ) then
14737: LD_EXP 34
14741: PPUSH
14742: CALL_OW 302
14746: IFFALSE 14760
// SaveCharacters ( Mike , 13a_Mike ) ;
14748: LD_EXP 34
14752: PPUSH
14753: LD_STRING 13a_Mike
14755: PPUSH
14756: CALL_OW 38
// if IsOk ( Titov ) then
14760: LD_EXP 37
14764: PPUSH
14765: CALL_OW 302
14769: IFFALSE 14783
// SaveCharacters ( Titov , 13a_Titov ) ;
14771: LD_EXP 37
14775: PPUSH
14776: LD_STRING 13a_Titov
14778: PPUSH
14779: CALL_OW 38
// if IsOk ( Dolgov ) then
14783: LD_EXP 39
14787: PPUSH
14788: CALL_OW 302
14792: IFFALSE 14806
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14794: LD_EXP 39
14798: PPUSH
14799: LD_STRING 13a_Dolgov
14801: PPUSH
14802: CALL_OW 38
// if IsOk ( Petrosyan ) then
14806: LD_EXP 40
14810: PPUSH
14811: CALL_OW 302
14815: IFFALSE 14829
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14817: LD_EXP 40
14821: PPUSH
14822: LD_STRING 13a_Petrosyan
14824: PPUSH
14825: CALL_OW 38
// if IsOk ( Scholtze ) then
14829: LD_EXP 41
14833: PPUSH
14834: CALL_OW 302
14838: IFFALSE 14852
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14840: LD_EXP 41
14844: PPUSH
14845: LD_STRING 13a_Scholtze
14847: PPUSH
14848: CALL_OW 38
// if IsOk ( Oblukov ) then
14852: LD_EXP 42
14856: PPUSH
14857: CALL_OW 302
14861: IFFALSE 14875
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14863: LD_EXP 42
14867: PPUSH
14868: LD_STRING 13a_Oblukov
14870: PPUSH
14871: CALL_OW 38
// if IsOk ( Kapitsova ) then
14875: LD_EXP 43
14879: PPUSH
14880: CALL_OW 302
14884: IFFALSE 14898
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14886: LD_EXP 43
14890: PPUSH
14891: LD_STRING 13a_Kapitsova
14893: PPUSH
14894: CALL_OW 38
// if IsOk ( Lipshchin ) then
14898: LD_EXP 44
14902: PPUSH
14903: CALL_OW 302
14907: IFFALSE 14921
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14909: LD_EXP 44
14913: PPUSH
14914: LD_STRING 13a_Lipshchin
14916: PPUSH
14917: CALL_OW 38
// if IsOk ( Petrovova ) then
14921: LD_EXP 45
14925: PPUSH
14926: CALL_OW 302
14930: IFFALSE 14944
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14932: LD_EXP 45
14936: PPUSH
14937: LD_STRING 13a_Petrovova
14939: PPUSH
14940: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14944: LD_EXP 46
14948: PPUSH
14949: CALL_OW 302
14953: IFFALSE 14967
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14955: LD_EXP 46
14959: PPUSH
14960: LD_STRING 13a_Kovalyuk
14962: PPUSH
14963: CALL_OW 38
// if IsOk ( Kuzmov ) then
14967: LD_EXP 47
14971: PPUSH
14972: CALL_OW 302
14976: IFFALSE 14990
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14978: LD_EXP 47
14982: PPUSH
14983: LD_STRING 13a_Kuzmov
14985: PPUSH
14986: CALL_OW 38
// if IsOk ( Karamazov ) then
14990: LD_EXP 48
14994: PPUSH
14995: CALL_OW 302
14999: IFFALSE 15013
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
15001: LD_EXP 48
15005: PPUSH
15006: LD_STRING 13a_Karamazov
15008: PPUSH
15009: CALL_OW 38
// if Burlak then
15013: LD_EXP 49
15017: IFFALSE 15038
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
15019: LD_STRING enableBioCharacter(BIO_GORKI)
15021: PPUSH
15022: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
15026: LD_EXP 49
15030: PPUSH
15031: LD_STRING 13a_Burlak
15033: PPUSH
15034: CALL_OW 38
// end ; if IsOk ( Belkov ) then
15038: LD_EXP 50
15042: PPUSH
15043: CALL_OW 302
15047: IFFALSE 15061
// SaveCharacters ( Belkov , 13a_Belkov ) ;
15049: LD_EXP 50
15053: PPUSH
15054: LD_STRING 13a_Belkov
15056: PPUSH
15057: CALL_OW 38
// if IsOk ( Gnyevko ) then
15061: LD_EXP 51
15065: PPUSH
15066: CALL_OW 302
15070: IFFALSE 15084
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
15072: LD_EXP 51
15076: PPUSH
15077: LD_STRING 13a_Gnyevko
15079: PPUSH
15080: CALL_OW 38
// if IsOk ( Lisa ) then
15084: LD_EXP 19
15088: PPUSH
15089: CALL_OW 302
15093: IFFALSE 15107
// SaveCharacters ( Lisa , 13a_Lisa ) ;
15095: LD_EXP 19
15099: PPUSH
15100: LD_STRING 13a_Lisa
15102: PPUSH
15103: CALL_OW 38
// if IsOk ( Donaldson ) then
15107: LD_EXP 20
15111: PPUSH
15112: CALL_OW 302
15116: IFFALSE 15130
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
15118: LD_EXP 20
15122: PPUSH
15123: LD_STRING 13a_Donaldson
15125: PPUSH
15126: CALL_OW 38
// if IsOk ( Bobby ) then
15130: LD_EXP 21
15134: PPUSH
15135: CALL_OW 302
15139: IFFALSE 15153
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15141: LD_EXP 21
15145: PPUSH
15146: LD_STRING 13a_Bobby
15148: PPUSH
15149: CALL_OW 38
// if IsOk ( Cyrus ) then
15153: LD_EXP 22
15157: PPUSH
15158: CALL_OW 302
15162: IFFALSE 15176
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15164: LD_EXP 22
15168: PPUSH
15169: LD_STRING 13a_Cyrus
15171: PPUSH
15172: CALL_OW 38
// if IsOk ( Denis ) then
15176: LD_EXP 23
15180: PPUSH
15181: CALL_OW 302
15185: IFFALSE 15199
// SaveCharacters ( Denis , 13a_Denis ) ;
15187: LD_EXP 23
15191: PPUSH
15192: LD_STRING 13a_Denis
15194: PPUSH
15195: CALL_OW 38
// if IsOk ( Brown ) then
15199: LD_EXP 24
15203: PPUSH
15204: CALL_OW 302
15208: IFFALSE 15222
// SaveCharacters ( Brown , 13a_Brown ) ;
15210: LD_EXP 24
15214: PPUSH
15215: LD_STRING 13a_Brown
15217: PPUSH
15218: CALL_OW 38
// if IsOk ( Gladstone ) then
15222: LD_EXP 25
15226: PPUSH
15227: CALL_OW 302
15231: IFFALSE 15245
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15233: LD_EXP 25
15237: PPUSH
15238: LD_STRING 13a_Gladstone
15240: PPUSH
15241: CALL_OW 38
// if IsOk ( Houten ) then
15245: LD_EXP 26
15249: PPUSH
15250: CALL_OW 302
15254: IFFALSE 15268
// SaveCharacters ( Houten , 13a_Houten ) ;
15256: LD_EXP 26
15260: PPUSH
15261: LD_STRING 13a_Houten
15263: PPUSH
15264: CALL_OW 38
// if IsOk ( Cornel ) then
15268: LD_EXP 27
15272: PPUSH
15273: CALL_OW 302
15277: IFFALSE 15291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15279: LD_EXP 27
15283: PPUSH
15284: LD_STRING 13a_Cornel
15286: PPUSH
15287: CALL_OW 38
// if IsOk ( Gary ) then
15291: LD_EXP 28
15295: PPUSH
15296: CALL_OW 302
15300: IFFALSE 15314
// SaveCharacters ( Gary , 13a_Gary ) ;
15302: LD_EXP 28
15306: PPUSH
15307: LD_STRING 13a_Gary
15309: PPUSH
15310: CALL_OW 38
// if IsOk ( Frank ) then
15314: LD_EXP 29
15318: PPUSH
15319: CALL_OW 302
15323: IFFALSE 15337
// SaveCharacters ( Frank , 13a_Frank ) ;
15325: LD_EXP 29
15329: PPUSH
15330: LD_STRING 13a_Frank
15332: PPUSH
15333: CALL_OW 38
// if IsOk ( Kikuchi ) then
15337: LD_EXP 30
15341: PPUSH
15342: CALL_OW 302
15346: IFFALSE 15360
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15348: LD_EXP 30
15352: PPUSH
15353: LD_STRING 13a_Kikuchi
15355: PPUSH
15356: CALL_OW 38
// if IsOk ( Simms ) then
15360: LD_EXP 31
15364: PPUSH
15365: CALL_OW 302
15369: IFFALSE 15383
// SaveCharacters ( Simms , 13a_Simms ) ;
15371: LD_EXP 31
15375: PPUSH
15376: LD_STRING 13a_Simms
15378: PPUSH
15379: CALL_OW 38
// if IsOk ( Joan ) then
15383: LD_EXP 32
15387: PPUSH
15388: CALL_OW 302
15392: IFFALSE 15406
// SaveCharacters ( Joan , 13a_Joan ) ;
15394: LD_EXP 32
15398: PPUSH
15399: LD_STRING 13a_Joan
15401: PPUSH
15402: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15406: LD_EXP 33
15410: PPUSH
15411: CALL_OW 302
15415: IFFALSE 15429
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15417: LD_EXP 33
15421: PPUSH
15422: LD_STRING 13a_DeltaDoctor
15424: PPUSH
15425: CALL_OW 38
// if IsOk ( Gossudarov ) then
15429: LD_EXP 35
15433: PPUSH
15434: CALL_OW 302
15438: IFFALSE 15452
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15440: LD_EXP 35
15444: PPUSH
15445: LD_STRING 13a_Gossudarov
15447: PPUSH
15448: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15452: LD_EXP 36
15456: PPUSH
15457: CALL_OW 302
15461: IFFALSE 15475
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15463: LD_EXP 36
15467: PPUSH
15468: LD_STRING 13a_Kirilenkova
15470: PPUSH
15471: CALL_OW 38
// if IsOk ( Roth ) then
15475: LD_EXP 18
15479: PPUSH
15480: CALL_OW 302
15484: IFFALSE 15498
// SaveCharacters ( Roth , 13a_Roth ) ;
15486: LD_EXP 18
15490: PPUSH
15491: LD_STRING 13a_Roth
15493: PPUSH
15494: CALL_OW 38
// if Masha then
15498: LD_EXP 52
15502: IFFALSE 15557
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15504: LD_EXP 52
15508: PPUSH
15509: CALL_OW 265
15513: PUSH
15514: LD_EXP 52
15518: PPUSH
15519: CALL_OW 262
15523: PUSH
15524: LD_EXP 52
15528: PPUSH
15529: CALL_OW 263
15533: PUSH
15534: LD_EXP 52
15538: PPUSH
15539: CALL_OW 264
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: LIST
15548: LIST
15549: PPUSH
15550: LD_STRING 13a_Masha
15552: PPUSH
15553: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15557: LD_ADDR_VAR 0 2
15561: PUSH
15562: LD_INT 21
15564: PUSH
15565: LD_INT 3
15567: PUSH
15568: EMPTY
15569: LIST
15570: LIST
15571: PPUSH
15572: CALL_OW 69
15576: ST_TO_ADDR
// tmp2 := [ ] ;
15577: LD_ADDR_VAR 0 3
15581: PUSH
15582: EMPTY
15583: ST_TO_ADDR
// if tmp then
15584: LD_VAR 0 2
15588: IFFALSE 15739
// for i in tmp do
15590: LD_ADDR_VAR 0 1
15594: PUSH
15595: LD_VAR 0 2
15599: PUSH
15600: FOR_IN
15601: IFFALSE 15737
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15603: LD_ADDR_VAR 0 3
15607: PUSH
15608: LD_VAR 0 3
15612: PUSH
15613: LD_VAR 0 1
15617: PPUSH
15618: CALL_OW 255
15622: PUSH
15623: LD_VAR 0 1
15627: PPUSH
15628: CALL_OW 248
15632: PUSH
15633: LD_VAR 0 1
15637: PPUSH
15638: CALL_OW 266
15642: PUSH
15643: LD_VAR 0 1
15647: PPUSH
15648: CALL_OW 250
15652: PUSH
15653: LD_VAR 0 1
15657: PPUSH
15658: CALL_OW 251
15662: PUSH
15663: LD_VAR 0 1
15667: PPUSH
15668: CALL_OW 254
15672: PUSH
15673: LD_VAR 0 1
15677: PPUSH
15678: CALL_OW 267
15682: PUSH
15683: LD_VAR 0 1
15687: PPUSH
15688: LD_INT 1
15690: PPUSH
15691: CALL_OW 268
15695: PUSH
15696: LD_VAR 0 1
15700: PPUSH
15701: LD_INT 2
15703: PPUSH
15704: CALL_OW 268
15708: PUSH
15709: LD_VAR 0 1
15713: PPUSH
15714: CALL_OW 269
15718: PUSH
15719: EMPTY
15720: LIST
15721: LIST
15722: LIST
15723: LIST
15724: LIST
15725: LIST
15726: LIST
15727: LIST
15728: LIST
15729: LIST
15730: PUSH
15731: EMPTY
15732: LIST
15733: ADD
15734: ST_TO_ADDR
15735: GO 15600
15737: POP
15738: POP
// if tmp2 then
15739: LD_VAR 0 3
15743: IFFALSE 15757
// SaveVariable ( tmp2 , 13a_buildings ) ;
15745: LD_VAR 0 3
15749: PPUSH
15750: LD_STRING 13a_buildings
15752: PPUSH
15753: CALL_OW 39
// YouWin ;
15757: CALL_OW 103
// end ;
15761: PPOPN 6
15763: END
// export function SciRu ; var tmp , t ; begin
15764: LD_INT 0
15766: PPUSH
15767: PPUSH
15768: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15769: LD_ADDR_VAR 0 3
15773: PUSH
15774: LD_EXP 35
15778: PUSH
15779: LD_EXP 49
15783: PUSH
15784: LD_EXP 37
15788: PUSH
15789: LD_EXP 50
15793: PUSH
15794: LD_EXP 51
15798: PUSH
15799: LD_EXP 40
15803: PUSH
15804: LD_EXP 41
15808: PUSH
15809: LD_EXP 39
15813: PUSH
15814: EMPTY
15815: LIST
15816: LIST
15817: LIST
15818: LIST
15819: LIST
15820: LIST
15821: LIST
15822: LIST
15823: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15824: LD_ADDR_VAR 0 2
15828: PUSH
15829: LD_INT 22
15831: PUSH
15832: LD_INT 7
15834: PUSH
15835: EMPTY
15836: LIST
15837: LIST
15838: PUSH
15839: LD_INT 23
15841: PUSH
15842: LD_INT 3
15844: PUSH
15845: EMPTY
15846: LIST
15847: LIST
15848: PUSH
15849: LD_INT 25
15851: PUSH
15852: LD_INT 4
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: PUSH
15859: LD_INT 26
15861: PUSH
15862: LD_INT 1
15864: PUSH
15865: EMPTY
15866: LIST
15867: LIST
15868: PUSH
15869: EMPTY
15870: LIST
15871: LIST
15872: LIST
15873: LIST
15874: PPUSH
15875: CALL_OW 69
15879: PUSH
15880: LD_VAR 0 3
15884: DIFF
15885: ST_TO_ADDR
// if tmp then
15886: LD_VAR 0 2
15890: IFFALSE 15906
// result := tmp [ 1 ] ;
15892: LD_ADDR_VAR 0 1
15896: PUSH
15897: LD_VAR 0 2
15901: PUSH
15902: LD_INT 1
15904: ARRAY
15905: ST_TO_ADDR
// end ;
15906: LD_VAR 0 1
15910: RET
// export function SolRu ; var tmp , t ; begin
15911: LD_INT 0
15913: PPUSH
15914: PPUSH
15915: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15916: LD_ADDR_VAR 0 3
15920: PUSH
15921: LD_EXP 35
15925: PUSH
15926: LD_EXP 49
15930: PUSH
15931: LD_EXP 37
15935: PUSH
15936: LD_EXP 50
15940: PUSH
15941: LD_EXP 51
15945: PUSH
15946: LD_EXP 40
15950: PUSH
15951: LD_EXP 41
15955: PUSH
15956: LD_EXP 39
15960: PUSH
15961: EMPTY
15962: LIST
15963: LIST
15964: LIST
15965: LIST
15966: LIST
15967: LIST
15968: LIST
15969: LIST
15970: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15971: LD_ADDR_VAR 0 2
15975: PUSH
15976: LD_INT 22
15978: PUSH
15979: LD_INT 7
15981: PUSH
15982: EMPTY
15983: LIST
15984: LIST
15985: PUSH
15986: LD_INT 23
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: EMPTY
15993: LIST
15994: LIST
15995: PUSH
15996: LD_INT 25
15998: PUSH
15999: LD_INT 1
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: PUSH
16006: LD_INT 26
16008: PUSH
16009: LD_INT 1
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: PPUSH
16022: CALL_OW 69
16026: PUSH
16027: LD_VAR 0 3
16031: DIFF
16032: ST_TO_ADDR
// if tmp then
16033: LD_VAR 0 2
16037: IFFALSE 16053
// result := tmp [ 1 ] ;
16039: LD_ADDR_VAR 0 1
16043: PUSH
16044: LD_VAR 0 2
16048: PUSH
16049: LD_INT 1
16051: ARRAY
16052: ST_TO_ADDR
// end ; end_of_file
16053: LD_VAR 0 1
16057: RET
// export function CustomEvent ( event ) ; begin
16058: LD_INT 0
16060: PPUSH
// end ;
16061: LD_VAR 0 2
16065: RET
// on UnitDestroyed ( un ) do var i , side ;
16066: LD_INT 0
16068: PPUSH
16069: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
16070: LD_VAR 0 1
16074: PPUSH
16075: CALL 108114 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
16079: LD_VAR 0 1
16083: PUSH
16084: LD_INT 22
16086: PUSH
16087: LD_INT 7
16089: PUSH
16090: EMPTY
16091: LIST
16092: LIST
16093: PUSH
16094: LD_INT 2
16096: PUSH
16097: LD_INT 25
16099: PUSH
16100: LD_INT 1
16102: PUSH
16103: EMPTY
16104: LIST
16105: LIST
16106: PUSH
16107: LD_INT 25
16109: PUSH
16110: LD_INT 2
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PUSH
16117: LD_INT 25
16119: PUSH
16120: LD_INT 3
16122: PUSH
16123: EMPTY
16124: LIST
16125: LIST
16126: PUSH
16127: LD_INT 25
16129: PUSH
16130: LD_INT 4
16132: PUSH
16133: EMPTY
16134: LIST
16135: LIST
16136: PUSH
16137: LD_INT 25
16139: PUSH
16140: LD_INT 5
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 25
16149: PUSH
16150: LD_INT 8
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: LD_INT 25
16159: PUSH
16160: LD_INT 9
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: EMPTY
16168: LIST
16169: LIST
16170: LIST
16171: LIST
16172: LIST
16173: LIST
16174: LIST
16175: LIST
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: PPUSH
16181: CALL_OW 69
16185: IN
16186: IFFALSE 16202
// loss_counter := loss_counter + 1 ;
16188: LD_ADDR_EXP 15
16192: PUSH
16193: LD_EXP 15
16197: PUSH
16198: LD_INT 1
16200: PLUS
16201: ST_TO_ADDR
// if un = Abdul then
16202: LD_VAR 0 1
16206: PUSH
16207: LD_EXP 58
16211: EQUAL
16212: IFFALSE 16222
// abdul_escaped := false ;
16214: LD_ADDR_EXP 14
16218: PUSH
16219: LD_INT 0
16221: ST_TO_ADDR
// if un in ru_attackers then
16222: LD_VAR 0 1
16226: PUSH
16227: LD_EXP 55
16231: IN
16232: IFFALSE 16250
// ru_attackers := ru_attackers diff un ;
16234: LD_ADDR_EXP 55
16238: PUSH
16239: LD_EXP 55
16243: PUSH
16244: LD_VAR 0 1
16248: DIFF
16249: ST_TO_ADDR
// if un in ar_attackers then
16250: LD_VAR 0 1
16254: PUSH
16255: LD_EXP 12
16259: IN
16260: IFFALSE 16278
// ar_attackers := ar_attackers diff un ;
16262: LD_ADDR_EXP 12
16266: PUSH
16267: LD_EXP 12
16271: PUSH
16272: LD_VAR 0 1
16276: DIFF
16277: ST_TO_ADDR
// if un = JMM then
16278: LD_VAR 0 1
16282: PUSH
16283: LD_EXP 17
16287: EQUAL
16288: IFFALSE 16299
// begin YouLost ( JMM ) ;
16290: LD_STRING JMM
16292: PPUSH
16293: CALL_OW 104
// exit ;
16297: GO 16396
// end ; if un = Burlak then
16299: LD_VAR 0 1
16303: PUSH
16304: LD_EXP 49
16308: EQUAL
16309: IFFALSE 16320
// begin YouLost ( Burlak ) ;
16311: LD_STRING Burlak
16313: PPUSH
16314: CALL_OW 104
// exit ;
16318: GO 16396
// end ; if un = freedom then
16320: LD_VAR 0 1
16324: PUSH
16325: LD_EXP 3
16329: EQUAL
16330: IFFALSE 16341
// begin YouLost ( Destroyed ) ;
16332: LD_STRING Destroyed
16334: PPUSH
16335: CALL_OW 104
// exit ;
16339: GO 16396
// end ; if un = Masha then
16341: LD_VAR 0 1
16345: PUSH
16346: LD_EXP 52
16350: EQUAL
16351: IFFALSE 16368
// begin ChangeMissionObjectives ( M4b ) ;
16353: LD_STRING M4b
16355: PPUSH
16356: CALL_OW 337
// masha_killed := true ;
16360: LD_ADDR_EXP 11
16364: PUSH
16365: LD_INT 1
16367: ST_TO_ADDR
// end ; if un = Mastodont then
16368: LD_VAR 0 1
16372: PUSH
16373: LD_EXP 59
16377: EQUAL
16378: IFFALSE 16387
// ChangeMissionObjectives ( M4a ) ;
16380: LD_STRING M4a
16382: PPUSH
16383: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16387: LD_VAR 0 1
16391: PPUSH
16392: CALL 89010 0 1
// end ;
16396: PPOPN 3
16398: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16399: LD_VAR 0 1
16403: PPUSH
16404: LD_VAR 0 2
16408: PPUSH
16409: CALL 91364 0 2
// end ;
16413: PPOPN 2
16415: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16416: LD_VAR 0 1
16420: PPUSH
16421: CALL 90428 0 1
// end ;
16425: PPOPN 1
16427: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16428: LD_VAR 0 1
16432: PUSH
16433: LD_INT 22
16435: PUSH
16436: LD_INT 7
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PUSH
16443: LD_INT 30
16445: PUSH
16446: LD_INT 0
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: PUSH
16453: EMPTY
16454: LIST
16455: LIST
16456: PPUSH
16457: CALL_OW 69
16461: IN
16462: IFFALSE 16501
// begin SetBName ( building , freedom ) ;
16464: LD_VAR 0 1
16468: PPUSH
16469: LD_STRING freedom
16471: PPUSH
16472: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16476: LD_INT 0
16478: PPUSH
16479: LD_INT 7
16481: PPUSH
16482: LD_INT 0
16484: PPUSH
16485: CALL_OW 324
// freedom := building ;
16489: LD_ADDR_EXP 3
16493: PUSH
16494: LD_VAR 0 1
16498: ST_TO_ADDR
// exit ;
16499: GO 16567
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16501: LD_VAR 0 1
16505: PUSH
16506: LD_INT 22
16508: PUSH
16509: LD_INT 7
16511: PUSH
16512: EMPTY
16513: LIST
16514: LIST
16515: PUSH
16516: LD_INT 23
16518: PUSH
16519: LD_INT 3
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: PUSH
16526: LD_INT 30
16528: PUSH
16529: LD_INT 6
16531: PUSH
16532: EMPTY
16533: LIST
16534: LIST
16535: PUSH
16536: EMPTY
16537: LIST
16538: LIST
16539: LIST
16540: PPUSH
16541: CALL_OW 69
16545: IN
16546: IFFALSE 16558
// begin ru_lab_builded := true ;
16548: LD_ADDR_EXP 5
16552: PUSH
16553: LD_INT 1
16555: ST_TO_ADDR
// exit ;
16556: GO 16567
// end ; MCE_BuildingComplete ( building ) ;
16558: LD_VAR 0 1
16562: PPUSH
16563: CALL 90671 0 1
// end ;
16567: PPOPN 1
16569: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16570: LD_VAR 0 1
16574: PPUSH
16575: LD_VAR 0 2
16579: PPUSH
16580: CALL 88698 0 2
// end ;
16584: PPOPN 2
16586: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16587: LD_VAR 0 1
16591: PPUSH
16592: LD_VAR 0 2
16596: PPUSH
16597: LD_VAR 0 3
16601: PPUSH
16602: LD_VAR 0 4
16606: PPUSH
16607: LD_VAR 0 5
16611: PPUSH
16612: CALL 88316 0 5
// end ;
16616: PPOPN 5
16618: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16619: LD_VAR 0 1
16623: PPUSH
16624: LD_VAR 0 2
16628: PPUSH
16629: CALL 108172 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16633: LD_VAR 0 1
16637: PPUSH
16638: LD_VAR 0 2
16642: PPUSH
16643: CALL 87865 0 2
// end ;
16647: PPOPN 2
16649: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16650: LD_VAR 0 1
16654: PPUSH
16655: CALL_OW 263
16659: PUSH
16660: LD_INT 3
16662: EQUAL
16663: IFTRUE 16680
16665: PUSH
16666: LD_VAR 0 2
16670: PPUSH
16671: CALL_OW 263
16675: PUSH
16676: LD_INT 3
16678: EQUAL
16679: OR
16680: IFFALSE 16696
// hack_counter := hack_counter + 1 ;
16682: LD_ADDR_EXP 16
16686: PUSH
16687: LD_EXP 16
16691: PUSH
16692: LD_INT 1
16694: PLUS
16695: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16696: LD_VAR 0 1
16700: PPUSH
16701: LD_VAR 0 2
16705: PPUSH
16706: LD_VAR 0 3
16710: PPUSH
16711: LD_VAR 0 4
16715: PPUSH
16716: CALL 87697 0 4
// end ;
16720: PPOPN 4
16722: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16723: LD_VAR 0 1
16727: PUSH
16728: LD_INT 47
16730: EQUAL
16731: IFFALSE 16753
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16733: LD_VAR 0 1
16737: PPUSH
16738: CALL_OW 274
16742: PPUSH
16743: LD_INT 1
16745: PPUSH
16746: LD_INT 600
16748: PPUSH
16749: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16753: LD_VAR 0 1
16757: PPUSH
16758: LD_VAR 0 2
16762: PPUSH
16763: LD_VAR 0 3
16767: PPUSH
16768: CALL 87470 0 3
// end ;
16772: PPOPN 3
16774: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16775: LD_VAR 0 1
16779: PPUSH
16780: LD_VAR 0 2
16784: PPUSH
16785: CALL 87353 0 2
// end ;
16789: PPOPN 2
16791: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16792: LD_VAR 0 1
16796: PPUSH
16797: LD_VAR 0 2
16801: PPUSH
16802: CALL 91661 0 2
// end ;
16806: PPOPN 2
16808: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16809: LD_VAR 0 1
16813: PPUSH
16814: LD_VAR 0 2
16818: PPUSH
16819: LD_VAR 0 3
16823: PPUSH
16824: LD_VAR 0 4
16828: PPUSH
16829: CALL 91885 0 4
// end ;
16833: PPOPN 4
16835: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16836: LD_VAR 0 1
16840: PPUSH
16841: LD_VAR 0 2
16845: PPUSH
16846: CALL 87160 0 2
// end ;
16850: PPOPN 2
16852: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16853: LD_VAR 0 1
16857: PPUSH
16858: CALL 108156 0 1
// end ; end_of_file
16862: PPOPN 1
16864: END
// every 0 0$30 do var cr , time ;
16865: GO 16867
16867: DISABLE
16868: LD_INT 0
16870: PPUSH
16871: PPUSH
// begin time := 0 0$20 ;
16872: LD_ADDR_VAR 0 2
16876: PUSH
16877: LD_INT 700
16879: ST_TO_ADDR
// while game do
16880: LD_EXP 2
16884: IFFALSE 16987
// begin wait ( time ) ;
16886: LD_VAR 0 2
16890: PPUSH
16891: CALL_OW 67
// if tick > 2 2$00 then
16895: LD_OWVAR 1
16899: PUSH
16900: LD_INT 4200
16902: GREATER
16903: IFFALSE 16940
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16905: LD_ADDR_VAR 0 2
16909: PUSH
16910: LD_VAR 0 2
16914: PUSH
16915: LD_INT 140
16917: PUSH
16918: LD_INT 140
16920: PUSH
16921: LD_INT 210
16923: PUSH
16924: LD_INT 280
16926: PUSH
16927: EMPTY
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: PUSH
16933: LD_OWVAR 67
16937: ARRAY
16938: PLUS
16939: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16940: LD_INT 1
16942: PPUSH
16943: LD_INT 5
16945: PPUSH
16946: CALL_OW 12
16950: PPUSH
16951: LD_INT 70
16953: PPUSH
16954: LD_INT 49
16956: PPUSH
16957: LD_INT 25
16959: PPUSH
16960: LD_INT 1
16962: PPUSH
16963: CALL_OW 56
// if time > 3 3$00 then
16967: LD_VAR 0 2
16971: PUSH
16972: LD_INT 6300
16974: GREATER
16975: IFFALSE 16985
// time := 0 0$30 ;
16977: LD_ADDR_VAR 0 2
16981: PUSH
16982: LD_INT 1050
16984: ST_TO_ADDR
// end ;
16985: GO 16880
// end ;
16987: PPOPN 2
16989: END
// every 0 0$30 do var cr , time ;
16990: GO 16992
16992: DISABLE
16993: LD_INT 0
16995: PPUSH
16996: PPUSH
// begin time := 0 0$20 ;
16997: LD_ADDR_VAR 0 2
17001: PUSH
17002: LD_INT 700
17004: ST_TO_ADDR
// while game do
17005: LD_EXP 2
17009: IFFALSE 17102
// begin wait ( time ) ;
17011: LD_VAR 0 2
17015: PPUSH
17016: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
17020: LD_ADDR_VAR 0 2
17024: PUSH
17025: LD_VAR 0 2
17029: PUSH
17030: LD_INT 140
17032: PUSH
17033: LD_INT 175
17035: PUSH
17036: LD_INT 210
17038: PUSH
17039: LD_INT 280
17041: PUSH
17042: EMPTY
17043: LIST
17044: LIST
17045: LIST
17046: LIST
17047: PUSH
17048: LD_OWVAR 67
17052: ARRAY
17053: PLUS
17054: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
17055: LD_INT 3
17057: PPUSH
17058: LD_INT 5
17060: PPUSH
17061: CALL_OW 12
17065: PPUSH
17066: LD_INT 26
17068: PPUSH
17069: LD_INT 9
17071: PPUSH
17072: LD_INT 30
17074: PPUSH
17075: LD_INT 1
17077: PPUSH
17078: CALL_OW 56
// if time > 3 3$00 then
17082: LD_VAR 0 2
17086: PUSH
17087: LD_INT 6300
17089: GREATER
17090: IFFALSE 17100
// time := 0 0$20 ;
17092: LD_ADDR_VAR 0 2
17096: PUSH
17097: LD_INT 700
17099: ST_TO_ADDR
// end ;
17100: GO 17005
// end ;
17102: PPOPN 2
17104: END
// every 0 0$30 do var cr , time ;
17105: GO 17107
17107: DISABLE
17108: LD_INT 0
17110: PPUSH
17111: PPUSH
// begin time := 0 0$20 ;
17112: LD_ADDR_VAR 0 2
17116: PUSH
17117: LD_INT 700
17119: ST_TO_ADDR
// while game do
17120: LD_EXP 2
17124: IFFALSE 17253
// begin wait ( time ) ;
17126: LD_VAR 0 2
17130: PPUSH
17131: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
17135: LD_ADDR_VAR 0 2
17139: PUSH
17140: LD_VAR 0 2
17144: PUSH
17145: LD_INT 175
17147: PUSH
17148: LD_INT 210
17150: PUSH
17151: LD_INT 280
17153: PUSH
17154: LD_INT 350
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: LD_OWVAR 67
17167: ARRAY
17168: PLUS
17169: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17170: LD_INT 1
17172: PPUSH
17173: LD_INT 5
17175: PPUSH
17176: CALL_OW 12
17180: PPUSH
17181: LD_INT 179
17183: PPUSH
17184: LD_INT 101
17186: PPUSH
17187: LD_INT 20
17189: PPUSH
17190: LD_INT 1
17192: PPUSH
17193: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17197: LD_INT 350
17199: PPUSH
17200: LD_INT 525
17202: PPUSH
17203: CALL_OW 12
17207: PPUSH
17208: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17212: LD_INT 1
17214: PPUSH
17215: LD_INT 5
17217: PPUSH
17218: CALL_OW 12
17222: PPUSH
17223: LD_INT 9
17225: PPUSH
17226: LD_INT 1
17228: PPUSH
17229: CALL_OW 55
// if time > 4 4$00 then
17233: LD_VAR 0 2
17237: PUSH
17238: LD_INT 8400
17240: GREATER
17241: IFFALSE 17251
// time := 0 0$30 ;
17243: LD_ADDR_VAR 0 2
17247: PUSH
17248: LD_INT 1050
17250: ST_TO_ADDR
// end ;
17251: GO 17120
// end ;
17253: PPOPN 2
17255: END
// every 0 0$30 do var cr , time ;
17256: GO 17258
17258: DISABLE
17259: LD_INT 0
17261: PPUSH
17262: PPUSH
// begin time := 0 0$10 ;
17263: LD_ADDR_VAR 0 2
17267: PUSH
17268: LD_INT 350
17270: ST_TO_ADDR
// while game do
17271: LD_EXP 2
17275: IFFALSE 17409
// begin wait ( time ) ;
17277: LD_VAR 0 2
17281: PPUSH
17282: CALL_OW 67
// time := time + 0 0$10 ;
17286: LD_ADDR_VAR 0 2
17290: PUSH
17291: LD_VAR 0 2
17295: PUSH
17296: LD_INT 350
17298: PLUS
17299: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17300: LD_INT 1
17302: PPUSH
17303: LD_INT 5
17305: PPUSH
17306: CALL_OW 12
17310: PPUSH
17311: LD_INT 11
17313: PPUSH
17314: LD_INT 1
17316: PPUSH
17317: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17321: LD_ADDR_VAR 0 1
17325: PUSH
17326: LD_INT 1
17328: PPUSH
17329: LD_INT 3
17331: PPUSH
17332: CALL_OW 12
17336: ST_TO_ADDR
// if cr = 1 then
17337: LD_VAR 0 1
17341: PUSH
17342: LD_INT 1
17344: EQUAL
17345: IFFALSE 17389
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17347: LD_INT 700
17349: PPUSH
17350: LD_INT 1575
17352: PPUSH
17353: CALL_OW 12
17357: PPUSH
17358: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17362: LD_INT 1
17364: PPUSH
17365: LD_INT 5
17367: PPUSH
17368: CALL_OW 12
17372: PPUSH
17373: LD_INT 34
17375: PPUSH
17376: LD_INT 50
17378: PPUSH
17379: LD_INT 7
17381: PPUSH
17382: LD_INT 1
17384: PPUSH
17385: CALL_OW 56
// end ; if time > 4 4$00 then
17389: LD_VAR 0 2
17393: PUSH
17394: LD_INT 8400
17396: GREATER
17397: IFFALSE 17407
// time := 0 0$40 ;
17399: LD_ADDR_VAR 0 2
17403: PUSH
17404: LD_INT 1400
17406: ST_TO_ADDR
// end ;
17407: GO 17271
// end ; end_of_file
17409: PPOPN 2
17411: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17412: LD_INT 0
17414: PPUSH
17415: PPUSH
// if exist_mode then
17416: LD_VAR 0 2
17420: IFFALSE 17466
// begin unit := CreateCharacter ( prefix & ident ) ;
17422: LD_ADDR_VAR 0 5
17426: PUSH
17427: LD_VAR 0 3
17431: PUSH
17432: LD_VAR 0 1
17436: STR
17437: PPUSH
17438: CALL_OW 34
17442: ST_TO_ADDR
// if unit then
17443: LD_VAR 0 5
17447: IFFALSE 17464
// DeleteCharacters ( prefix & ident ) ;
17449: LD_VAR 0 3
17453: PUSH
17454: LD_VAR 0 1
17458: STR
17459: PPUSH
17460: CALL_OW 40
// end else
17464: GO 17481
// unit := NewCharacter ( ident ) ;
17466: LD_ADDR_VAR 0 5
17470: PUSH
17471: LD_VAR 0 1
17475: PPUSH
17476: CALL_OW 25
17480: ST_TO_ADDR
// result := unit ;
17481: LD_ADDR_VAR 0 4
17485: PUSH
17486: LD_VAR 0 5
17490: ST_TO_ADDR
// end ;
17491: LD_VAR 0 4
17495: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
17496: LD_INT 0
17498: PPUSH
17499: PPUSH
// if exist_mode then
17500: LD_VAR 0 2
17504: IFFALSE 17529
// unit := CreateCharacter ( prefix & ident ) else
17506: LD_ADDR_VAR 0 5
17510: PUSH
17511: LD_VAR 0 3
17515: PUSH
17516: LD_VAR 0 1
17520: STR
17521: PPUSH
17522: CALL_OW 34
17526: ST_TO_ADDR
17527: GO 17544
// unit := NewCharacter ( ident ) ;
17529: LD_ADDR_VAR 0 5
17533: PUSH
17534: LD_VAR 0 1
17538: PPUSH
17539: CALL_OW 25
17543: ST_TO_ADDR
// result := unit ;
17544: LD_ADDR_VAR 0 4
17548: PUSH
17549: LD_VAR 0 5
17553: ST_TO_ADDR
// end ;
17554: LD_VAR 0 4
17558: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17559: LD_INT 0
17561: PPUSH
17562: PPUSH
// if not side or not nation then
17563: LD_VAR 0 1
17567: NOT
17568: IFTRUE 17577
17570: PUSH
17571: LD_VAR 0 2
17575: NOT
17576: OR
17577: IFFALSE 17581
// exit ;
17579: GO 18375
// case nation of nation_american :
17581: LD_VAR 0 2
17585: PUSH
17586: LD_INT 1
17588: DOUBLE
17589: EQUAL
17590: IFTRUE 17594
17592: GO 17816
17594: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
17595: LD_ADDR_VAR 0 4
17599: PUSH
17600: LD_INT 35
17602: PUSH
17603: LD_INT 45
17605: PUSH
17606: LD_INT 46
17608: PUSH
17609: LD_INT 47
17611: PUSH
17612: LD_INT 82
17614: PUSH
17615: LD_INT 83
17617: PUSH
17618: LD_INT 84
17620: PUSH
17621: LD_INT 85
17623: PUSH
17624: LD_INT 86
17626: PUSH
17627: LD_INT 1
17629: PUSH
17630: LD_INT 2
17632: PUSH
17633: LD_INT 6
17635: PUSH
17636: LD_INT 15
17638: PUSH
17639: LD_INT 16
17641: PUSH
17642: LD_INT 7
17644: PUSH
17645: LD_INT 12
17647: PUSH
17648: LD_INT 13
17650: PUSH
17651: LD_INT 10
17653: PUSH
17654: LD_INT 14
17656: PUSH
17657: LD_INT 20
17659: PUSH
17660: LD_INT 21
17662: PUSH
17663: LD_INT 22
17665: PUSH
17666: LD_INT 25
17668: PUSH
17669: LD_INT 32
17671: PUSH
17672: LD_INT 27
17674: PUSH
17675: LD_INT 36
17677: PUSH
17678: LD_INT 69
17680: PUSH
17681: LD_INT 39
17683: PUSH
17684: LD_INT 34
17686: PUSH
17687: LD_INT 40
17689: PUSH
17690: LD_INT 48
17692: PUSH
17693: LD_INT 49
17695: PUSH
17696: LD_INT 50
17698: PUSH
17699: LD_INT 51
17701: PUSH
17702: LD_INT 52
17704: PUSH
17705: LD_INT 53
17707: PUSH
17708: LD_INT 54
17710: PUSH
17711: LD_INT 55
17713: PUSH
17714: LD_INT 56
17716: PUSH
17717: LD_INT 57
17719: PUSH
17720: LD_INT 58
17722: PUSH
17723: LD_INT 59
17725: PUSH
17726: LD_INT 60
17728: PUSH
17729: LD_INT 61
17731: PUSH
17732: LD_INT 62
17734: PUSH
17735: LD_INT 80
17737: PUSH
17738: LD_INT 82
17740: PUSH
17741: LD_INT 83
17743: PUSH
17744: LD_INT 84
17746: PUSH
17747: LD_INT 85
17749: PUSH
17750: LD_INT 86
17752: PUSH
17753: LD_INT 90
17755: PUSH
17756: LD_INT 93
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: LIST
17801: LIST
17802: LIST
17803: LIST
17804: LIST
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: LIST
17811: LIST
17812: LIST
17813: ST_TO_ADDR
17814: GO 18297
17816: LD_INT 2
17818: DOUBLE
17819: EQUAL
17820: IFTRUE 17824
17822: GO 18058
17824: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
17825: LD_ADDR_VAR 0 4
17829: PUSH
17830: LD_INT 35
17832: PUSH
17833: LD_INT 45
17835: PUSH
17836: LD_INT 46
17838: PUSH
17839: LD_INT 47
17841: PUSH
17842: LD_INT 82
17844: PUSH
17845: LD_INT 83
17847: PUSH
17848: LD_INT 84
17850: PUSH
17851: LD_INT 85
17853: PUSH
17854: LD_INT 87
17856: PUSH
17857: LD_INT 70
17859: PUSH
17860: LD_INT 1
17862: PUSH
17863: LD_INT 11
17865: PUSH
17866: LD_INT 3
17868: PUSH
17869: LD_INT 4
17871: PUSH
17872: LD_INT 5
17874: PUSH
17875: LD_INT 6
17877: PUSH
17878: LD_INT 15
17880: PUSH
17881: LD_INT 18
17883: PUSH
17884: LD_INT 7
17886: PUSH
17887: LD_INT 17
17889: PUSH
17890: LD_INT 8
17892: PUSH
17893: LD_INT 20
17895: PUSH
17896: LD_INT 21
17898: PUSH
17899: LD_INT 22
17901: PUSH
17902: LD_INT 72
17904: PUSH
17905: LD_INT 26
17907: PUSH
17908: LD_INT 69
17910: PUSH
17911: LD_INT 39
17913: PUSH
17914: LD_INT 40
17916: PUSH
17917: LD_INT 41
17919: PUSH
17920: LD_INT 42
17922: PUSH
17923: LD_INT 43
17925: PUSH
17926: LD_INT 48
17928: PUSH
17929: LD_INT 49
17931: PUSH
17932: LD_INT 50
17934: PUSH
17935: LD_INT 51
17937: PUSH
17938: LD_INT 52
17940: PUSH
17941: LD_INT 53
17943: PUSH
17944: LD_INT 54
17946: PUSH
17947: LD_INT 55
17949: PUSH
17950: LD_INT 56
17952: PUSH
17953: LD_INT 60
17955: PUSH
17956: LD_INT 61
17958: PUSH
17959: LD_INT 62
17961: PUSH
17962: LD_INT 66
17964: PUSH
17965: LD_INT 67
17967: PUSH
17968: LD_INT 68
17970: PUSH
17971: LD_INT 81
17973: PUSH
17974: LD_INT 82
17976: PUSH
17977: LD_INT 83
17979: PUSH
17980: LD_INT 84
17982: PUSH
17983: LD_INT 85
17985: PUSH
17986: LD_INT 87
17988: PUSH
17989: LD_INT 88
17991: PUSH
17992: LD_INT 92
17994: PUSH
17995: LD_INT 94
17997: PUSH
17998: EMPTY
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: LIST
18051: LIST
18052: LIST
18053: LIST
18054: LIST
18055: ST_TO_ADDR
18056: GO 18297
18058: LD_INT 3
18060: DOUBLE
18061: EQUAL
18062: IFTRUE 18066
18064: GO 18296
18066: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
18067: LD_ADDR_VAR 0 4
18071: PUSH
18072: LD_INT 46
18074: PUSH
18075: LD_INT 47
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: LD_INT 2
18083: PUSH
18084: LD_INT 82
18086: PUSH
18087: LD_INT 83
18089: PUSH
18090: LD_INT 84
18092: PUSH
18093: LD_INT 85
18095: PUSH
18096: LD_INT 86
18098: PUSH
18099: LD_INT 11
18101: PUSH
18102: LD_INT 9
18104: PUSH
18105: LD_INT 20
18107: PUSH
18108: LD_INT 19
18110: PUSH
18111: LD_INT 21
18113: PUSH
18114: LD_INT 24
18116: PUSH
18117: LD_INT 22
18119: PUSH
18120: LD_INT 25
18122: PUSH
18123: LD_INT 28
18125: PUSH
18126: LD_INT 29
18128: PUSH
18129: LD_INT 30
18131: PUSH
18132: LD_INT 31
18134: PUSH
18135: LD_INT 37
18137: PUSH
18138: LD_INT 38
18140: PUSH
18141: LD_INT 32
18143: PUSH
18144: LD_INT 27
18146: PUSH
18147: LD_INT 33
18149: PUSH
18150: LD_INT 69
18152: PUSH
18153: LD_INT 39
18155: PUSH
18156: LD_INT 34
18158: PUSH
18159: LD_INT 40
18161: PUSH
18162: LD_INT 71
18164: PUSH
18165: LD_INT 23
18167: PUSH
18168: LD_INT 44
18170: PUSH
18171: LD_INT 48
18173: PUSH
18174: LD_INT 49
18176: PUSH
18177: LD_INT 50
18179: PUSH
18180: LD_INT 51
18182: PUSH
18183: LD_INT 52
18185: PUSH
18186: LD_INT 53
18188: PUSH
18189: LD_INT 54
18191: PUSH
18192: LD_INT 55
18194: PUSH
18195: LD_INT 56
18197: PUSH
18198: LD_INT 57
18200: PUSH
18201: LD_INT 58
18203: PUSH
18204: LD_INT 59
18206: PUSH
18207: LD_INT 63
18209: PUSH
18210: LD_INT 64
18212: PUSH
18213: LD_INT 65
18215: PUSH
18216: LD_INT 82
18218: PUSH
18219: LD_INT 83
18221: PUSH
18222: LD_INT 84
18224: PUSH
18225: LD_INT 85
18227: PUSH
18228: LD_INT 86
18230: PUSH
18231: LD_INT 89
18233: PUSH
18234: LD_INT 91
18236: PUSH
18237: EMPTY
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: LIST
18280: LIST
18281: LIST
18282: LIST
18283: LIST
18284: LIST
18285: LIST
18286: LIST
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: LIST
18292: LIST
18293: ST_TO_ADDR
18294: GO 18297
18296: POP
// if state > - 1 and state < 3 then
18297: LD_VAR 0 3
18301: PUSH
18302: LD_INT 1
18304: NEG
18305: GREATER
18306: IFFALSE 18318
18308: PUSH
18309: LD_VAR 0 3
18313: PUSH
18314: LD_INT 3
18316: LESS
18317: AND
18318: IFFALSE 18375
// for i in result do
18320: LD_ADDR_VAR 0 5
18324: PUSH
18325: LD_VAR 0 4
18329: PUSH
18330: FOR_IN
18331: IFFALSE 18373
// if GetTech ( i , side ) <> state then
18333: LD_VAR 0 5
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: CALL_OW 321
18347: PUSH
18348: LD_VAR 0 3
18352: NONEQUAL
18353: IFFALSE 18371
// result := result diff i ;
18355: LD_ADDR_VAR 0 4
18359: PUSH
18360: LD_VAR 0 4
18364: PUSH
18365: LD_VAR 0 5
18369: DIFF
18370: ST_TO_ADDR
18371: GO 18330
18373: POP
18374: POP
// end ;
18375: LD_VAR 0 4
18379: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18380: LD_INT 0
18382: PPUSH
18383: PPUSH
18384: PPUSH
// result := true ;
18385: LD_ADDR_VAR 0 3
18389: PUSH
18390: LD_INT 1
18392: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18393: LD_ADDR_VAR 0 5
18397: PUSH
18398: LD_VAR 0 2
18402: PPUSH
18403: CALL_OW 480
18407: ST_TO_ADDR
// if not tmp then
18408: LD_VAR 0 5
18412: NOT
18413: IFFALSE 18417
// exit ;
18415: GO 18466
// for i in tmp do
18417: LD_ADDR_VAR 0 4
18421: PUSH
18422: LD_VAR 0 5
18426: PUSH
18427: FOR_IN
18428: IFFALSE 18464
// if GetTech ( i , side ) <> state_researched then
18430: LD_VAR 0 4
18434: PPUSH
18435: LD_VAR 0 1
18439: PPUSH
18440: CALL_OW 321
18444: PUSH
18445: LD_INT 2
18447: NONEQUAL
18448: IFFALSE 18462
// begin result := false ;
18450: LD_ADDR_VAR 0 3
18454: PUSH
18455: LD_INT 0
18457: ST_TO_ADDR
// exit ;
18458: POP
18459: POP
18460: GO 18466
// end ;
18462: GO 18427
18464: POP
18465: POP
// end ;
18466: LD_VAR 0 3
18470: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18471: LD_INT 0
18473: PPUSH
18474: PPUSH
18475: PPUSH
18476: PPUSH
18477: PPUSH
18478: PPUSH
18479: PPUSH
18480: PPUSH
18481: PPUSH
18482: PPUSH
18483: PPUSH
18484: PPUSH
18485: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18486: LD_VAR 0 1
18490: NOT
18491: IFTRUE 18508
18493: PUSH
18494: LD_VAR 0 1
18498: PPUSH
18499: CALL_OW 257
18503: PUSH
18504: LD_INT 9
18506: NONEQUAL
18507: OR
18508: IFFALSE 18512
// exit ;
18510: GO 19091
// side := GetSide ( unit ) ;
18512: LD_ADDR_VAR 0 9
18516: PUSH
18517: LD_VAR 0 1
18521: PPUSH
18522: CALL_OW 255
18526: ST_TO_ADDR
// tech_space := tech_spacanom ;
18527: LD_ADDR_VAR 0 12
18531: PUSH
18532: LD_INT 29
18534: ST_TO_ADDR
// tech_time := tech_taurad ;
18535: LD_ADDR_VAR 0 13
18539: PUSH
18540: LD_INT 28
18542: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18543: LD_ADDR_VAR 0 11
18547: PUSH
18548: LD_VAR 0 1
18552: PPUSH
18553: CALL_OW 310
18557: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18558: LD_VAR 0 11
18562: PPUSH
18563: CALL_OW 247
18567: PUSH
18568: LD_INT 2
18570: EQUAL
18571: IFFALSE 18575
// exit ;
18573: GO 19091
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18575: LD_ADDR_VAR 0 8
18579: PUSH
18580: LD_INT 81
18582: PUSH
18583: LD_VAR 0 9
18587: PUSH
18588: EMPTY
18589: LIST
18590: LIST
18591: PUSH
18592: LD_INT 3
18594: PUSH
18595: LD_INT 21
18597: PUSH
18598: LD_INT 3
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: PUSH
18605: EMPTY
18606: LIST
18607: LIST
18608: PUSH
18609: EMPTY
18610: LIST
18611: LIST
18612: PPUSH
18613: CALL_OW 69
18617: ST_TO_ADDR
// if not tmp then
18618: LD_VAR 0 8
18622: NOT
18623: IFFALSE 18627
// exit ;
18625: GO 19091
// if in_unit then
18627: LD_VAR 0 11
18631: IFFALSE 18655
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18633: LD_ADDR_VAR 0 10
18637: PUSH
18638: LD_VAR 0 8
18642: PPUSH
18643: LD_VAR 0 11
18647: PPUSH
18648: CALL_OW 74
18652: ST_TO_ADDR
18653: GO 18675
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18655: LD_ADDR_VAR 0 10
18659: PUSH
18660: LD_VAR 0 8
18664: PPUSH
18665: LD_VAR 0 1
18669: PPUSH
18670: CALL_OW 74
18674: ST_TO_ADDR
// if not enemy then
18675: LD_VAR 0 10
18679: NOT
18680: IFFALSE 18684
// exit ;
18682: GO 19091
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18684: LD_VAR 0 11
18688: IFFALSE 18710
18690: PUSH
18691: LD_VAR 0 11
18695: PPUSH
18696: LD_VAR 0 10
18700: PPUSH
18701: CALL_OW 296
18705: PUSH
18706: LD_INT 13
18708: GREATER
18709: AND
18710: IFTRUE 18732
18712: PUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: LD_VAR 0 10
18722: PPUSH
18723: CALL_OW 296
18727: PUSH
18728: LD_INT 12
18730: GREATER
18731: OR
18732: IFFALSE 18736
// exit ;
18734: GO 19091
// missile := [ 1 ] ;
18736: LD_ADDR_VAR 0 14
18740: PUSH
18741: LD_INT 1
18743: PUSH
18744: EMPTY
18745: LIST
18746: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18747: LD_VAR 0 9
18751: PPUSH
18752: LD_VAR 0 12
18756: PPUSH
18757: CALL_OW 325
18761: IFFALSE 18790
// missile := Replace ( missile , missile + 1 , 2 ) ;
18763: LD_ADDR_VAR 0 14
18767: PUSH
18768: LD_VAR 0 14
18772: PPUSH
18773: LD_VAR 0 14
18777: PUSH
18778: LD_INT 1
18780: PLUS
18781: PPUSH
18782: LD_INT 2
18784: PPUSH
18785: CALL_OW 1
18789: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18790: LD_VAR 0 9
18794: PPUSH
18795: LD_VAR 0 13
18799: PPUSH
18800: CALL_OW 325
18804: IFFALSE 18828
18806: PUSH
18807: LD_VAR 0 10
18811: PPUSH
18812: CALL_OW 255
18816: PPUSH
18817: LD_VAR 0 13
18821: PPUSH
18822: CALL_OW 325
18826: NOT
18827: AND
18828: IFFALSE 18857
// missile := Replace ( missile , missile + 1 , 3 ) ;
18830: LD_ADDR_VAR 0 14
18834: PUSH
18835: LD_VAR 0 14
18839: PPUSH
18840: LD_VAR 0 14
18844: PUSH
18845: LD_INT 1
18847: PLUS
18848: PPUSH
18849: LD_INT 3
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// if missile < 2 then
18857: LD_VAR 0 14
18861: PUSH
18862: LD_INT 2
18864: LESS
18865: IFFALSE 18869
// exit ;
18867: GO 19091
// x := GetX ( enemy ) ;
18869: LD_ADDR_VAR 0 4
18873: PUSH
18874: LD_VAR 0 10
18878: PPUSH
18879: CALL_OW 250
18883: ST_TO_ADDR
// y := GetY ( enemy ) ;
18884: LD_ADDR_VAR 0 5
18888: PUSH
18889: LD_VAR 0 10
18893: PPUSH
18894: CALL_OW 251
18898: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18899: LD_ADDR_VAR 0 6
18903: PUSH
18904: LD_VAR 0 4
18908: PUSH
18909: LD_INT 1
18911: NEG
18912: PPUSH
18913: LD_INT 1
18915: PPUSH
18916: CALL_OW 12
18920: PLUS
18921: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18922: LD_ADDR_VAR 0 7
18926: PUSH
18927: LD_VAR 0 5
18931: PUSH
18932: LD_INT 1
18934: NEG
18935: PPUSH
18936: LD_INT 1
18938: PPUSH
18939: CALL_OW 12
18943: PLUS
18944: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18945: LD_VAR 0 6
18949: PPUSH
18950: LD_VAR 0 7
18954: PPUSH
18955: CALL_OW 488
18959: NOT
18960: IFFALSE 18982
// begin _x := x ;
18962: LD_ADDR_VAR 0 6
18966: PUSH
18967: LD_VAR 0 4
18971: ST_TO_ADDR
// _y := y ;
18972: LD_ADDR_VAR 0 7
18976: PUSH
18977: LD_VAR 0 5
18981: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_INT 1
18989: PPUSH
18990: LD_VAR 0 14
18994: PPUSH
18995: CALL_OW 12
18999: ST_TO_ADDR
// case i of 1 :
19000: LD_VAR 0 3
19004: PUSH
19005: LD_INT 1
19007: DOUBLE
19008: EQUAL
19009: IFTRUE 19013
19011: GO 19030
19013: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_VAR 0 10
19023: PPUSH
19024: CALL_OW 115
19028: GO 19091
19030: LD_INT 2
19032: DOUBLE
19033: EQUAL
19034: IFTRUE 19038
19036: GO 19060
19038: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19039: LD_VAR 0 1
19043: PPUSH
19044: LD_VAR 0 6
19048: PPUSH
19049: LD_VAR 0 7
19053: PPUSH
19054: CALL_OW 153
19058: GO 19091
19060: LD_INT 3
19062: DOUBLE
19063: EQUAL
19064: IFTRUE 19068
19066: GO 19090
19068: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19069: LD_VAR 0 1
19073: PPUSH
19074: LD_VAR 0 6
19078: PPUSH
19079: LD_VAR 0 7
19083: PPUSH
19084: CALL_OW 154
19088: GO 19091
19090: POP
// end ;
19091: LD_VAR 0 2
19095: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19096: LD_INT 0
19098: PPUSH
19099: PPUSH
19100: PPUSH
19101: PPUSH
19102: PPUSH
19103: PPUSH
// if not unit or not building then
19104: LD_VAR 0 1
19108: NOT
19109: IFTRUE 19118
19111: PUSH
19112: LD_VAR 0 2
19116: NOT
19117: OR
19118: IFFALSE 19122
// exit ;
19120: GO 19280
// x := GetX ( building ) ;
19122: LD_ADDR_VAR 0 5
19126: PUSH
19127: LD_VAR 0 2
19131: PPUSH
19132: CALL_OW 250
19136: ST_TO_ADDR
// y := GetY ( building ) ;
19137: LD_ADDR_VAR 0 6
19141: PUSH
19142: LD_VAR 0 2
19146: PPUSH
19147: CALL_OW 251
19151: ST_TO_ADDR
// for i := 0 to 5 do
19152: LD_ADDR_VAR 0 4
19156: PUSH
19157: DOUBLE
19158: LD_INT 0
19160: DEC
19161: ST_TO_ADDR
19162: LD_INT 5
19164: PUSH
19165: FOR_TO
19166: IFFALSE 19278
// begin _x := ShiftX ( x , i , 3 ) ;
19168: LD_ADDR_VAR 0 7
19172: PUSH
19173: LD_VAR 0 5
19177: PPUSH
19178: LD_VAR 0 4
19182: PPUSH
19183: LD_INT 3
19185: PPUSH
19186: CALL_OW 272
19190: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19191: LD_ADDR_VAR 0 8
19195: PUSH
19196: LD_VAR 0 6
19200: PPUSH
19201: LD_VAR 0 4
19205: PPUSH
19206: LD_INT 3
19208: PPUSH
19209: CALL_OW 273
19213: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19214: LD_VAR 0 7
19218: PPUSH
19219: LD_VAR 0 8
19223: PPUSH
19224: CALL_OW 488
19228: NOT
19229: IFFALSE 19233
// continue ;
19231: GO 19165
// if HexInfo ( _x , _y ) = 0 then
19233: LD_VAR 0 7
19237: PPUSH
19238: LD_VAR 0 8
19242: PPUSH
19243: CALL_OW 428
19247: PUSH
19248: LD_INT 0
19250: EQUAL
19251: IFFALSE 19276
// begin ComMoveXY ( unit , _x , _y ) ;
19253: LD_VAR 0 1
19257: PPUSH
19258: LD_VAR 0 7
19262: PPUSH
19263: LD_VAR 0 8
19267: PPUSH
19268: CALL_OW 111
// exit ;
19272: POP
19273: POP
19274: GO 19280
// end ; end ;
19276: GO 19165
19278: POP
19279: POP
// end ;
19280: LD_VAR 0 3
19284: RET
// export function ScanBase ( side , base_area ) ; begin
19285: LD_INT 0
19287: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19288: LD_ADDR_VAR 0 3
19292: PUSH
19293: LD_VAR 0 2
19297: PPUSH
19298: LD_INT 81
19300: PUSH
19301: LD_VAR 0 1
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: PPUSH
19310: CALL_OW 70
19314: ST_TO_ADDR
// end ;
19315: LD_VAR 0 3
19319: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19320: LD_INT 0
19322: PPUSH
19323: PPUSH
19324: PPUSH
19325: PPUSH
// result := false ;
19326: LD_ADDR_VAR 0 2
19330: PUSH
19331: LD_INT 0
19333: ST_TO_ADDR
// side := GetSide ( unit ) ;
19334: LD_ADDR_VAR 0 3
19338: PUSH
19339: LD_VAR 0 1
19343: PPUSH
19344: CALL_OW 255
19348: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19349: LD_ADDR_VAR 0 4
19353: PUSH
19354: LD_VAR 0 1
19358: PPUSH
19359: CALL_OW 248
19363: ST_TO_ADDR
// case nat of 1 :
19364: LD_VAR 0 4
19368: PUSH
19369: LD_INT 1
19371: DOUBLE
19372: EQUAL
19373: IFTRUE 19377
19375: GO 19388
19377: POP
// tech := tech_lassight ; 2 :
19378: LD_ADDR_VAR 0 5
19382: PUSH
19383: LD_INT 12
19385: ST_TO_ADDR
19386: GO 19427
19388: LD_INT 2
19390: DOUBLE
19391: EQUAL
19392: IFTRUE 19396
19394: GO 19407
19396: POP
// tech := tech_mortar ; 3 :
19397: LD_ADDR_VAR 0 5
19401: PUSH
19402: LD_INT 41
19404: ST_TO_ADDR
19405: GO 19427
19407: LD_INT 3
19409: DOUBLE
19410: EQUAL
19411: IFTRUE 19415
19413: GO 19426
19415: POP
// tech := tech_bazooka ; end ;
19416: LD_ADDR_VAR 0 5
19420: PUSH
19421: LD_INT 44
19423: ST_TO_ADDR
19424: GO 19427
19426: POP
// if Researched ( side , tech ) then
19427: LD_VAR 0 3
19431: PPUSH
19432: LD_VAR 0 5
19436: PPUSH
19437: CALL_OW 325
19441: IFFALSE 19468
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19443: LD_ADDR_VAR 0 2
19447: PUSH
19448: LD_INT 5
19450: PUSH
19451: LD_INT 8
19453: PUSH
19454: LD_INT 9
19456: PUSH
19457: EMPTY
19458: LIST
19459: LIST
19460: LIST
19461: PUSH
19462: LD_VAR 0 4
19466: ARRAY
19467: ST_TO_ADDR
// end ;
19468: LD_VAR 0 2
19472: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19473: LD_INT 0
19475: PPUSH
19476: PPUSH
19477: PPUSH
// if not mines then
19478: LD_VAR 0 2
19482: NOT
19483: IFFALSE 19487
// exit ;
19485: GO 19631
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19487: LD_ADDR_VAR 0 5
19491: PUSH
19492: LD_INT 81
19494: PUSH
19495: LD_VAR 0 1
19499: PUSH
19500: EMPTY
19501: LIST
19502: LIST
19503: PUSH
19504: LD_INT 3
19506: PUSH
19507: LD_INT 21
19509: PUSH
19510: LD_INT 3
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: PUSH
19517: EMPTY
19518: LIST
19519: LIST
19520: PUSH
19521: EMPTY
19522: LIST
19523: LIST
19524: PPUSH
19525: CALL_OW 69
19529: ST_TO_ADDR
// for i in mines do
19530: LD_ADDR_VAR 0 4
19534: PUSH
19535: LD_VAR 0 2
19539: PUSH
19540: FOR_IN
19541: IFFALSE 19629
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19543: LD_VAR 0 4
19547: PUSH
19548: LD_INT 1
19550: ARRAY
19551: PPUSH
19552: LD_VAR 0 4
19556: PUSH
19557: LD_INT 2
19559: ARRAY
19560: PPUSH
19561: CALL_OW 458
19565: NOT
19566: IFFALSE 19570
// continue ;
19568: GO 19540
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19570: LD_VAR 0 4
19574: PUSH
19575: LD_INT 1
19577: ARRAY
19578: PPUSH
19579: LD_VAR 0 4
19583: PUSH
19584: LD_INT 2
19586: ARRAY
19587: PPUSH
19588: CALL_OW 428
19592: PUSH
19593: LD_VAR 0 5
19597: IN
19598: IFFALSE 19627
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19600: LD_VAR 0 4
19604: PUSH
19605: LD_INT 1
19607: ARRAY
19608: PPUSH
19609: LD_VAR 0 4
19613: PUSH
19614: LD_INT 2
19616: ARRAY
19617: PPUSH
19618: LD_VAR 0 1
19622: PPUSH
19623: CALL_OW 456
// end ;
19627: GO 19540
19629: POP
19630: POP
// end ;
19631: LD_VAR 0 3
19635: RET
// export function Count ( array ) ; begin
19636: LD_INT 0
19638: PPUSH
// result := array + 0 ;
19639: LD_ADDR_VAR 0 2
19643: PUSH
19644: LD_VAR 0 1
19648: PUSH
19649: LD_INT 0
19651: PLUS
19652: ST_TO_ADDR
// end ;
19653: LD_VAR 0 2
19657: RET
// export function IsEmpty ( building ) ; begin
19658: LD_INT 0
19660: PPUSH
// if not building then
19661: LD_VAR 0 1
19665: NOT
19666: IFFALSE 19670
// exit ;
19668: GO 19713
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19670: LD_ADDR_VAR 0 2
19674: PUSH
19675: LD_VAR 0 1
19679: PUSH
19680: LD_INT 22
19682: PUSH
19683: LD_VAR 0 1
19687: PPUSH
19688: CALL_OW 255
19692: PUSH
19693: EMPTY
19694: LIST
19695: LIST
19696: PUSH
19697: LD_INT 58
19699: PUSH
19700: EMPTY
19701: LIST
19702: PUSH
19703: EMPTY
19704: LIST
19705: LIST
19706: PPUSH
19707: CALL_OW 69
19711: IN
19712: ST_TO_ADDR
// end ;
19713: LD_VAR 0 2
19717: RET
// export function IsNotFull ( building ) ; var places ; begin
19718: LD_INT 0
19720: PPUSH
19721: PPUSH
// if not building then
19722: LD_VAR 0 1
19726: NOT
19727: IFFALSE 19731
// exit ;
19729: GO 19759
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19731: LD_ADDR_VAR 0 2
19735: PUSH
19736: LD_VAR 0 1
19740: PPUSH
19741: LD_INT 3
19743: PUSH
19744: LD_INT 62
19746: PUSH
19747: EMPTY
19748: LIST
19749: PUSH
19750: EMPTY
19751: LIST
19752: LIST
19753: PPUSH
19754: CALL_OW 72
19758: ST_TO_ADDR
// end ;
19759: LD_VAR 0 2
19763: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19764: LD_INT 0
19766: PPUSH
19767: PPUSH
19768: PPUSH
19769: PPUSH
// tmp := [ ] ;
19770: LD_ADDR_VAR 0 3
19774: PUSH
19775: EMPTY
19776: ST_TO_ADDR
// list := [ ] ;
19777: LD_ADDR_VAR 0 5
19781: PUSH
19782: EMPTY
19783: ST_TO_ADDR
// for i = 16 to 25 do
19784: LD_ADDR_VAR 0 4
19788: PUSH
19789: DOUBLE
19790: LD_INT 16
19792: DEC
19793: ST_TO_ADDR
19794: LD_INT 25
19796: PUSH
19797: FOR_TO
19798: IFFALSE 19871
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19800: LD_ADDR_VAR 0 3
19804: PUSH
19805: LD_VAR 0 3
19809: PUSH
19810: LD_INT 22
19812: PUSH
19813: LD_VAR 0 1
19817: PPUSH
19818: CALL_OW 255
19822: PUSH
19823: EMPTY
19824: LIST
19825: LIST
19826: PUSH
19827: LD_INT 91
19829: PUSH
19830: LD_VAR 0 1
19834: PUSH
19835: LD_INT 6
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: LIST
19842: PUSH
19843: LD_INT 30
19845: PUSH
19846: LD_VAR 0 4
19850: PUSH
19851: EMPTY
19852: LIST
19853: LIST
19854: PUSH
19855: EMPTY
19856: LIST
19857: LIST
19858: LIST
19859: PUSH
19860: EMPTY
19861: LIST
19862: PPUSH
19863: CALL_OW 69
19867: ADD
19868: ST_TO_ADDR
19869: GO 19797
19871: POP
19872: POP
// for i = 1 to tmp do
19873: LD_ADDR_VAR 0 4
19877: PUSH
19878: DOUBLE
19879: LD_INT 1
19881: DEC
19882: ST_TO_ADDR
19883: LD_VAR 0 3
19887: PUSH
19888: FOR_TO
19889: IFFALSE 19977
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19891: LD_ADDR_VAR 0 5
19895: PUSH
19896: LD_VAR 0 5
19900: PUSH
19901: LD_VAR 0 3
19905: PUSH
19906: LD_VAR 0 4
19910: ARRAY
19911: PPUSH
19912: CALL_OW 266
19916: PUSH
19917: LD_VAR 0 3
19921: PUSH
19922: LD_VAR 0 4
19926: ARRAY
19927: PPUSH
19928: CALL_OW 250
19932: PUSH
19933: LD_VAR 0 3
19937: PUSH
19938: LD_VAR 0 4
19942: ARRAY
19943: PPUSH
19944: CALL_OW 251
19948: PUSH
19949: LD_VAR 0 3
19953: PUSH
19954: LD_VAR 0 4
19958: ARRAY
19959: PPUSH
19960: CALL_OW 254
19964: PUSH
19965: EMPTY
19966: LIST
19967: LIST
19968: LIST
19969: LIST
19970: PUSH
19971: EMPTY
19972: LIST
19973: ADD
19974: ST_TO_ADDR
19975: GO 19888
19977: POP
19978: POP
// result := list ;
19979: LD_ADDR_VAR 0 2
19983: PUSH
19984: LD_VAR 0 5
19988: ST_TO_ADDR
// end ;
19989: LD_VAR 0 2
19993: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19994: LD_INT 0
19996: PPUSH
19997: PPUSH
19998: PPUSH
19999: PPUSH
20000: PPUSH
20001: PPUSH
20002: PPUSH
// if not factory then
20003: LD_VAR 0 1
20007: NOT
20008: IFFALSE 20012
// exit ;
20010: GO 20615
// if control = control_apeman then
20012: LD_VAR 0 4
20016: PUSH
20017: LD_INT 5
20019: EQUAL
20020: IFFALSE 20129
// begin tmp := UnitsInside ( factory ) ;
20022: LD_ADDR_VAR 0 8
20026: PUSH
20027: LD_VAR 0 1
20031: PPUSH
20032: CALL_OW 313
20036: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
20037: LD_VAR 0 8
20041: PPUSH
20042: LD_INT 25
20044: PUSH
20045: LD_INT 12
20047: PUSH
20048: EMPTY
20049: LIST
20050: LIST
20051: PPUSH
20052: CALL_OW 72
20056: NOT
20057: IFFALSE 20067
// control := control_manual ;
20059: LD_ADDR_VAR 0 4
20063: PUSH
20064: LD_INT 1
20066: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20067: LD_ADDR_VAR 0 8
20071: PUSH
20072: LD_VAR 0 1
20076: PPUSH
20077: CALL 19764 0 1
20081: ST_TO_ADDR
// if tmp then
20082: LD_VAR 0 8
20086: IFFALSE 20129
// begin for i in tmp do
20088: LD_ADDR_VAR 0 7
20092: PUSH
20093: LD_VAR 0 8
20097: PUSH
20098: FOR_IN
20099: IFFALSE 20127
// if i [ 1 ] = b_ext_radio then
20101: LD_VAR 0 7
20105: PUSH
20106: LD_INT 1
20108: ARRAY
20109: PUSH
20110: LD_INT 22
20112: EQUAL
20113: IFFALSE 20125
// begin control := control_remote ;
20115: LD_ADDR_VAR 0 4
20119: PUSH
20120: LD_INT 2
20122: ST_TO_ADDR
// break ;
20123: GO 20127
// end ;
20125: GO 20098
20127: POP
20128: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20129: LD_VAR 0 1
20133: PPUSH
20134: LD_VAR 0 2
20138: PPUSH
20139: LD_VAR 0 3
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: LD_VAR 0 5
20153: PPUSH
20154: CALL_OW 448
20158: IFFALSE 20193
// begin result := [ chassis , engine , control , weapon ] ;
20160: LD_ADDR_VAR 0 6
20164: PUSH
20165: LD_VAR 0 2
20169: PUSH
20170: LD_VAR 0 3
20174: PUSH
20175: LD_VAR 0 4
20179: PUSH
20180: LD_VAR 0 5
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: LIST
20189: LIST
20190: ST_TO_ADDR
// exit ;
20191: GO 20615
// end ; _chassis := AvailableChassisList ( factory ) ;
20193: LD_ADDR_VAR 0 9
20197: PUSH
20198: LD_VAR 0 1
20202: PPUSH
20203: CALL_OW 475
20207: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20208: LD_ADDR_VAR 0 11
20212: PUSH
20213: LD_VAR 0 1
20217: PPUSH
20218: CALL_OW 476
20222: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20223: LD_ADDR_VAR 0 12
20227: PUSH
20228: LD_VAR 0 1
20232: PPUSH
20233: CALL_OW 477
20237: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20238: LD_ADDR_VAR 0 10
20242: PUSH
20243: LD_VAR 0 1
20247: PPUSH
20248: CALL_OW 478
20252: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20253: LD_VAR 0 9
20257: NOT
20258: IFTRUE 20267
20260: PUSH
20261: LD_VAR 0 11
20265: NOT
20266: OR
20267: IFTRUE 20276
20269: PUSH
20270: LD_VAR 0 12
20274: NOT
20275: OR
20276: IFTRUE 20285
20278: PUSH
20279: LD_VAR 0 10
20283: NOT
20284: OR
20285: IFFALSE 20320
// begin result := [ chassis , engine , control , weapon ] ;
20287: LD_ADDR_VAR 0 6
20291: PUSH
20292: LD_VAR 0 2
20296: PUSH
20297: LD_VAR 0 3
20301: PUSH
20302: LD_VAR 0 4
20306: PUSH
20307: LD_VAR 0 5
20311: PUSH
20312: EMPTY
20313: LIST
20314: LIST
20315: LIST
20316: LIST
20317: ST_TO_ADDR
// exit ;
20318: GO 20615
// end ; if not chassis in _chassis then
20320: LD_VAR 0 2
20324: PUSH
20325: LD_VAR 0 9
20329: IN
20330: NOT
20331: IFFALSE 20357
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20333: LD_ADDR_VAR 0 2
20337: PUSH
20338: LD_VAR 0 9
20342: PUSH
20343: LD_INT 1
20345: PPUSH
20346: LD_VAR 0 9
20350: PPUSH
20351: CALL_OW 12
20355: ARRAY
20356: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20357: LD_VAR 0 2
20361: PPUSH
20362: LD_VAR 0 3
20366: PPUSH
20367: CALL 20620 0 2
20371: NOT
20372: IFFALSE 20433
// repeat engine := _engine [ 1 ] ;
20374: LD_ADDR_VAR 0 3
20378: PUSH
20379: LD_VAR 0 11
20383: PUSH
20384: LD_INT 1
20386: ARRAY
20387: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20388: LD_ADDR_VAR 0 11
20392: PUSH
20393: LD_VAR 0 11
20397: PPUSH
20398: LD_INT 1
20400: PPUSH
20401: CALL_OW 3
20405: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20406: LD_VAR 0 2
20410: PPUSH
20411: LD_VAR 0 3
20415: PPUSH
20416: CALL 20620 0 2
20420: IFTRUE 20431
20422: PUSH
20423: LD_VAR 0 11
20427: PUSH
20428: EMPTY
20429: EQUAL
20430: OR
20431: IFFALSE 20374
// if not control in _control then
20433: LD_VAR 0 4
20437: PUSH
20438: LD_VAR 0 12
20442: IN
20443: NOT
20444: IFFALSE 20470
// control := _control [ rand ( 1 , _control ) ] ;
20446: LD_ADDR_VAR 0 4
20450: PUSH
20451: LD_VAR 0 12
20455: PUSH
20456: LD_INT 1
20458: PPUSH
20459: LD_VAR 0 12
20463: PPUSH
20464: CALL_OW 12
20468: ARRAY
20469: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20470: LD_VAR 0 2
20474: PPUSH
20475: LD_VAR 0 5
20479: PPUSH
20480: CALL 20842 0 2
20484: NOT
20485: IFFALSE 20546
// repeat weapon := _weapon [ 1 ] ;
20487: LD_ADDR_VAR 0 5
20491: PUSH
20492: LD_VAR 0 10
20496: PUSH
20497: LD_INT 1
20499: ARRAY
20500: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20501: LD_ADDR_VAR 0 10
20505: PUSH
20506: LD_VAR 0 10
20510: PPUSH
20511: LD_INT 1
20513: PPUSH
20514: CALL_OW 3
20518: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20519: LD_VAR 0 2
20523: PPUSH
20524: LD_VAR 0 5
20528: PPUSH
20529: CALL 20842 0 2
20533: IFTRUE 20544
20535: PUSH
20536: LD_VAR 0 10
20540: PUSH
20541: EMPTY
20542: EQUAL
20543: OR
20544: IFFALSE 20487
// result := [ ] ;
20546: LD_ADDR_VAR 0 6
20550: PUSH
20551: EMPTY
20552: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20553: LD_VAR 0 1
20557: PPUSH
20558: LD_VAR 0 2
20562: PPUSH
20563: LD_VAR 0 3
20567: PPUSH
20568: LD_VAR 0 4
20572: PPUSH
20573: LD_VAR 0 5
20577: PPUSH
20578: CALL_OW 448
20582: IFFALSE 20615
// result := [ chassis , engine , control , weapon ] ;
20584: LD_ADDR_VAR 0 6
20588: PUSH
20589: LD_VAR 0 2
20593: PUSH
20594: LD_VAR 0 3
20598: PUSH
20599: LD_VAR 0 4
20603: PUSH
20604: LD_VAR 0 5
20608: PUSH
20609: EMPTY
20610: LIST
20611: LIST
20612: LIST
20613: LIST
20614: ST_TO_ADDR
// end ;
20615: LD_VAR 0 6
20619: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20620: LD_INT 0
20622: PPUSH
// if not chassis or not engine then
20623: LD_VAR 0 1
20627: NOT
20628: IFTRUE 20637
20630: PUSH
20631: LD_VAR 0 2
20635: NOT
20636: OR
20637: IFFALSE 20641
// exit ;
20639: GO 20837
// case engine of engine_solar :
20641: LD_VAR 0 2
20645: PUSH
20646: LD_INT 2
20648: DOUBLE
20649: EQUAL
20650: IFTRUE 20654
20652: GO 20692
20654: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20655: LD_ADDR_VAR 0 3
20659: PUSH
20660: LD_INT 11
20662: PUSH
20663: LD_INT 12
20665: PUSH
20666: LD_INT 13
20668: PUSH
20669: LD_INT 14
20671: PUSH
20672: LD_INT 1
20674: PUSH
20675: LD_INT 2
20677: PUSH
20678: LD_INT 3
20680: PUSH
20681: EMPTY
20682: LIST
20683: LIST
20684: LIST
20685: LIST
20686: LIST
20687: LIST
20688: LIST
20689: ST_TO_ADDR
20690: GO 20821
20692: LD_INT 1
20694: DOUBLE
20695: EQUAL
20696: IFTRUE 20700
20698: GO 20762
20700: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20701: LD_ADDR_VAR 0 3
20705: PUSH
20706: LD_INT 11
20708: PUSH
20709: LD_INT 12
20711: PUSH
20712: LD_INT 13
20714: PUSH
20715: LD_INT 14
20717: PUSH
20718: LD_INT 1
20720: PUSH
20721: LD_INT 2
20723: PUSH
20724: LD_INT 3
20726: PUSH
20727: LD_INT 4
20729: PUSH
20730: LD_INT 5
20732: PUSH
20733: LD_INT 21
20735: PUSH
20736: LD_INT 23
20738: PUSH
20739: LD_INT 22
20741: PUSH
20742: LD_INT 24
20744: PUSH
20745: EMPTY
20746: LIST
20747: LIST
20748: LIST
20749: LIST
20750: LIST
20751: LIST
20752: LIST
20753: LIST
20754: LIST
20755: LIST
20756: LIST
20757: LIST
20758: LIST
20759: ST_TO_ADDR
20760: GO 20821
20762: LD_INT 3
20764: DOUBLE
20765: EQUAL
20766: IFTRUE 20770
20768: GO 20820
20770: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20771: LD_ADDR_VAR 0 3
20775: PUSH
20776: LD_INT 13
20778: PUSH
20779: LD_INT 14
20781: PUSH
20782: LD_INT 2
20784: PUSH
20785: LD_INT 3
20787: PUSH
20788: LD_INT 4
20790: PUSH
20791: LD_INT 5
20793: PUSH
20794: LD_INT 21
20796: PUSH
20797: LD_INT 22
20799: PUSH
20800: LD_INT 23
20802: PUSH
20803: LD_INT 24
20805: PUSH
20806: EMPTY
20807: LIST
20808: LIST
20809: LIST
20810: LIST
20811: LIST
20812: LIST
20813: LIST
20814: LIST
20815: LIST
20816: LIST
20817: ST_TO_ADDR
20818: GO 20821
20820: POP
// result := ( chassis in result ) ;
20821: LD_ADDR_VAR 0 3
20825: PUSH
20826: LD_VAR 0 1
20830: PUSH
20831: LD_VAR 0 3
20835: IN
20836: ST_TO_ADDR
// end ;
20837: LD_VAR 0 3
20841: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20842: LD_INT 0
20844: PPUSH
// if not chassis or not weapon then
20845: LD_VAR 0 1
20849: NOT
20850: IFTRUE 20859
20852: PUSH
20853: LD_VAR 0 2
20857: NOT
20858: OR
20859: IFFALSE 20863
// exit ;
20861: GO 21957
// case weapon of us_machine_gun :
20863: LD_VAR 0 2
20867: PUSH
20868: LD_INT 2
20870: DOUBLE
20871: EQUAL
20872: IFTRUE 20876
20874: GO 20906
20876: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20877: LD_ADDR_VAR 0 3
20881: PUSH
20882: LD_INT 1
20884: PUSH
20885: LD_INT 2
20887: PUSH
20888: LD_INT 3
20890: PUSH
20891: LD_INT 4
20893: PUSH
20894: LD_INT 5
20896: PUSH
20897: EMPTY
20898: LIST
20899: LIST
20900: LIST
20901: LIST
20902: LIST
20903: ST_TO_ADDR
20904: GO 21941
20906: LD_INT 3
20908: DOUBLE
20909: EQUAL
20910: IFTRUE 20914
20912: GO 20944
20914: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20915: LD_ADDR_VAR 0 3
20919: PUSH
20920: LD_INT 1
20922: PUSH
20923: LD_INT 2
20925: PUSH
20926: LD_INT 3
20928: PUSH
20929: LD_INT 4
20931: PUSH
20932: LD_INT 5
20934: PUSH
20935: EMPTY
20936: LIST
20937: LIST
20938: LIST
20939: LIST
20940: LIST
20941: ST_TO_ADDR
20942: GO 21941
20944: LD_INT 11
20946: DOUBLE
20947: EQUAL
20948: IFTRUE 20952
20950: GO 20982
20952: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20953: LD_ADDR_VAR 0 3
20957: PUSH
20958: LD_INT 1
20960: PUSH
20961: LD_INT 2
20963: PUSH
20964: LD_INT 3
20966: PUSH
20967: LD_INT 4
20969: PUSH
20970: LD_INT 5
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: LIST
20977: LIST
20978: LIST
20979: ST_TO_ADDR
20980: GO 21941
20982: LD_INT 4
20984: DOUBLE
20985: EQUAL
20986: IFTRUE 20990
20988: GO 21016
20990: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20991: LD_ADDR_VAR 0 3
20995: PUSH
20996: LD_INT 2
20998: PUSH
20999: LD_INT 3
21001: PUSH
21002: LD_INT 4
21004: PUSH
21005: LD_INT 5
21007: PUSH
21008: EMPTY
21009: LIST
21010: LIST
21011: LIST
21012: LIST
21013: ST_TO_ADDR
21014: GO 21941
21016: LD_INT 5
21018: DOUBLE
21019: EQUAL
21020: IFTRUE 21024
21022: GO 21050
21024: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
21025: LD_ADDR_VAR 0 3
21029: PUSH
21030: LD_INT 2
21032: PUSH
21033: LD_INT 3
21035: PUSH
21036: LD_INT 4
21038: PUSH
21039: LD_INT 5
21041: PUSH
21042: EMPTY
21043: LIST
21044: LIST
21045: LIST
21046: LIST
21047: ST_TO_ADDR
21048: GO 21941
21050: LD_INT 9
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21058
21056: GO 21084
21058: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21059: LD_ADDR_VAR 0 3
21063: PUSH
21064: LD_INT 2
21066: PUSH
21067: LD_INT 3
21069: PUSH
21070: LD_INT 4
21072: PUSH
21073: LD_INT 5
21075: PUSH
21076: EMPTY
21077: LIST
21078: LIST
21079: LIST
21080: LIST
21081: ST_TO_ADDR
21082: GO 21941
21084: LD_INT 7
21086: DOUBLE
21087: EQUAL
21088: IFTRUE 21092
21090: GO 21118
21092: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21093: LD_ADDR_VAR 0 3
21097: PUSH
21098: LD_INT 2
21100: PUSH
21101: LD_INT 3
21103: PUSH
21104: LD_INT 4
21106: PUSH
21107: LD_INT 5
21109: PUSH
21110: EMPTY
21111: LIST
21112: LIST
21113: LIST
21114: LIST
21115: ST_TO_ADDR
21116: GO 21941
21118: LD_INT 12
21120: DOUBLE
21121: EQUAL
21122: IFTRUE 21126
21124: GO 21152
21126: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21127: LD_ADDR_VAR 0 3
21131: PUSH
21132: LD_INT 2
21134: PUSH
21135: LD_INT 3
21137: PUSH
21138: LD_INT 4
21140: PUSH
21141: LD_INT 5
21143: PUSH
21144: EMPTY
21145: LIST
21146: LIST
21147: LIST
21148: LIST
21149: ST_TO_ADDR
21150: GO 21941
21152: LD_INT 13
21154: DOUBLE
21155: EQUAL
21156: IFTRUE 21160
21158: GO 21186
21160: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21161: LD_ADDR_VAR 0 3
21165: PUSH
21166: LD_INT 2
21168: PUSH
21169: LD_INT 3
21171: PUSH
21172: LD_INT 4
21174: PUSH
21175: LD_INT 5
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: LIST
21182: LIST
21183: ST_TO_ADDR
21184: GO 21941
21186: LD_INT 14
21188: DOUBLE
21189: EQUAL
21190: IFTRUE 21194
21192: GO 21212
21194: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21195: LD_ADDR_VAR 0 3
21199: PUSH
21200: LD_INT 4
21202: PUSH
21203: LD_INT 5
21205: PUSH
21206: EMPTY
21207: LIST
21208: LIST
21209: ST_TO_ADDR
21210: GO 21941
21212: LD_INT 6
21214: DOUBLE
21215: EQUAL
21216: IFTRUE 21220
21218: GO 21238
21220: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_INT 4
21228: PUSH
21229: LD_INT 5
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: ST_TO_ADDR
21236: GO 21941
21238: LD_INT 10
21240: DOUBLE
21241: EQUAL
21242: IFTRUE 21246
21244: GO 21264
21246: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21247: LD_ADDR_VAR 0 3
21251: PUSH
21252: LD_INT 4
21254: PUSH
21255: LD_INT 5
21257: PUSH
21258: EMPTY
21259: LIST
21260: LIST
21261: ST_TO_ADDR
21262: GO 21941
21264: LD_INT 22
21266: DOUBLE
21267: EQUAL
21268: IFTRUE 21272
21270: GO 21298
21272: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21273: LD_ADDR_VAR 0 3
21277: PUSH
21278: LD_INT 11
21280: PUSH
21281: LD_INT 12
21283: PUSH
21284: LD_INT 13
21286: PUSH
21287: LD_INT 14
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: LIST
21294: LIST
21295: ST_TO_ADDR
21296: GO 21941
21298: LD_INT 23
21300: DOUBLE
21301: EQUAL
21302: IFTRUE 21306
21304: GO 21332
21306: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21307: LD_ADDR_VAR 0 3
21311: PUSH
21312: LD_INT 11
21314: PUSH
21315: LD_INT 12
21317: PUSH
21318: LD_INT 13
21320: PUSH
21321: LD_INT 14
21323: PUSH
21324: EMPTY
21325: LIST
21326: LIST
21327: LIST
21328: LIST
21329: ST_TO_ADDR
21330: GO 21941
21332: LD_INT 24
21334: DOUBLE
21335: EQUAL
21336: IFTRUE 21340
21338: GO 21366
21340: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_INT 11
21348: PUSH
21349: LD_INT 12
21351: PUSH
21352: LD_INT 13
21354: PUSH
21355: LD_INT 14
21357: PUSH
21358: EMPTY
21359: LIST
21360: LIST
21361: LIST
21362: LIST
21363: ST_TO_ADDR
21364: GO 21941
21366: LD_INT 30
21368: DOUBLE
21369: EQUAL
21370: IFTRUE 21374
21372: GO 21400
21374: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21375: LD_ADDR_VAR 0 3
21379: PUSH
21380: LD_INT 11
21382: PUSH
21383: LD_INT 12
21385: PUSH
21386: LD_INT 13
21388: PUSH
21389: LD_INT 14
21391: PUSH
21392: EMPTY
21393: LIST
21394: LIST
21395: LIST
21396: LIST
21397: ST_TO_ADDR
21398: GO 21941
21400: LD_INT 25
21402: DOUBLE
21403: EQUAL
21404: IFTRUE 21408
21406: GO 21426
21408: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21409: LD_ADDR_VAR 0 3
21413: PUSH
21414: LD_INT 13
21416: PUSH
21417: LD_INT 14
21419: PUSH
21420: EMPTY
21421: LIST
21422: LIST
21423: ST_TO_ADDR
21424: GO 21941
21426: LD_INT 27
21428: DOUBLE
21429: EQUAL
21430: IFTRUE 21434
21432: GO 21452
21434: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21435: LD_ADDR_VAR 0 3
21439: PUSH
21440: LD_INT 13
21442: PUSH
21443: LD_INT 14
21445: PUSH
21446: EMPTY
21447: LIST
21448: LIST
21449: ST_TO_ADDR
21450: GO 21941
21452: LD_INT 92
21454: DOUBLE
21455: EQUAL
21456: IFTRUE 21460
21458: GO 21486
21460: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21461: LD_ADDR_VAR 0 3
21465: PUSH
21466: LD_INT 11
21468: PUSH
21469: LD_INT 12
21471: PUSH
21472: LD_INT 13
21474: PUSH
21475: LD_INT 14
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: LIST
21482: LIST
21483: ST_TO_ADDR
21484: GO 21941
21486: LD_INT 28
21488: DOUBLE
21489: EQUAL
21490: IFTRUE 21494
21492: GO 21512
21494: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21495: LD_ADDR_VAR 0 3
21499: PUSH
21500: LD_INT 13
21502: PUSH
21503: LD_INT 14
21505: PUSH
21506: EMPTY
21507: LIST
21508: LIST
21509: ST_TO_ADDR
21510: GO 21941
21512: LD_INT 29
21514: DOUBLE
21515: EQUAL
21516: IFTRUE 21520
21518: GO 21538
21520: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21521: LD_ADDR_VAR 0 3
21525: PUSH
21526: LD_INT 13
21528: PUSH
21529: LD_INT 14
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: ST_TO_ADDR
21536: GO 21941
21538: LD_INT 31
21540: DOUBLE
21541: EQUAL
21542: IFTRUE 21546
21544: GO 21564
21546: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21547: LD_ADDR_VAR 0 3
21551: PUSH
21552: LD_INT 13
21554: PUSH
21555: LD_INT 14
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: ST_TO_ADDR
21562: GO 21941
21564: LD_INT 26
21566: DOUBLE
21567: EQUAL
21568: IFTRUE 21572
21570: GO 21590
21572: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21573: LD_ADDR_VAR 0 3
21577: PUSH
21578: LD_INT 13
21580: PUSH
21581: LD_INT 14
21583: PUSH
21584: EMPTY
21585: LIST
21586: LIST
21587: ST_TO_ADDR
21588: GO 21941
21590: LD_INT 42
21592: DOUBLE
21593: EQUAL
21594: IFTRUE 21598
21596: GO 21624
21598: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21599: LD_ADDR_VAR 0 3
21603: PUSH
21604: LD_INT 21
21606: PUSH
21607: LD_INT 22
21609: PUSH
21610: LD_INT 23
21612: PUSH
21613: LD_INT 24
21615: PUSH
21616: EMPTY
21617: LIST
21618: LIST
21619: LIST
21620: LIST
21621: ST_TO_ADDR
21622: GO 21941
21624: LD_INT 43
21626: DOUBLE
21627: EQUAL
21628: IFTRUE 21632
21630: GO 21658
21632: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21633: LD_ADDR_VAR 0 3
21637: PUSH
21638: LD_INT 21
21640: PUSH
21641: LD_INT 22
21643: PUSH
21644: LD_INT 23
21646: PUSH
21647: LD_INT 24
21649: PUSH
21650: EMPTY
21651: LIST
21652: LIST
21653: LIST
21654: LIST
21655: ST_TO_ADDR
21656: GO 21941
21658: LD_INT 44
21660: DOUBLE
21661: EQUAL
21662: IFTRUE 21666
21664: GO 21692
21666: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21667: LD_ADDR_VAR 0 3
21671: PUSH
21672: LD_INT 21
21674: PUSH
21675: LD_INT 22
21677: PUSH
21678: LD_INT 23
21680: PUSH
21681: LD_INT 24
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: LIST
21688: LIST
21689: ST_TO_ADDR
21690: GO 21941
21692: LD_INT 45
21694: DOUBLE
21695: EQUAL
21696: IFTRUE 21700
21698: GO 21726
21700: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21701: LD_ADDR_VAR 0 3
21705: PUSH
21706: LD_INT 21
21708: PUSH
21709: LD_INT 22
21711: PUSH
21712: LD_INT 23
21714: PUSH
21715: LD_INT 24
21717: PUSH
21718: EMPTY
21719: LIST
21720: LIST
21721: LIST
21722: LIST
21723: ST_TO_ADDR
21724: GO 21941
21726: LD_INT 49
21728: DOUBLE
21729: EQUAL
21730: IFTRUE 21734
21732: GO 21760
21734: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21735: LD_ADDR_VAR 0 3
21739: PUSH
21740: LD_INT 21
21742: PUSH
21743: LD_INT 22
21745: PUSH
21746: LD_INT 23
21748: PUSH
21749: LD_INT 24
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: LIST
21756: LIST
21757: ST_TO_ADDR
21758: GO 21941
21760: LD_INT 51
21762: DOUBLE
21763: EQUAL
21764: IFTRUE 21768
21766: GO 21794
21768: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21769: LD_ADDR_VAR 0 3
21773: PUSH
21774: LD_INT 21
21776: PUSH
21777: LD_INT 22
21779: PUSH
21780: LD_INT 23
21782: PUSH
21783: LD_INT 24
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: LIST
21790: LIST
21791: ST_TO_ADDR
21792: GO 21941
21794: LD_INT 52
21796: DOUBLE
21797: EQUAL
21798: IFTRUE 21802
21800: GO 21828
21802: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21803: LD_ADDR_VAR 0 3
21807: PUSH
21808: LD_INT 21
21810: PUSH
21811: LD_INT 22
21813: PUSH
21814: LD_INT 23
21816: PUSH
21817: LD_INT 24
21819: PUSH
21820: EMPTY
21821: LIST
21822: LIST
21823: LIST
21824: LIST
21825: ST_TO_ADDR
21826: GO 21941
21828: LD_INT 53
21830: DOUBLE
21831: EQUAL
21832: IFTRUE 21836
21834: GO 21854
21836: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21837: LD_ADDR_VAR 0 3
21841: PUSH
21842: LD_INT 23
21844: PUSH
21845: LD_INT 24
21847: PUSH
21848: EMPTY
21849: LIST
21850: LIST
21851: ST_TO_ADDR
21852: GO 21941
21854: LD_INT 46
21856: DOUBLE
21857: EQUAL
21858: IFTRUE 21862
21860: GO 21880
21862: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21863: LD_ADDR_VAR 0 3
21867: PUSH
21868: LD_INT 23
21870: PUSH
21871: LD_INT 24
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: ST_TO_ADDR
21878: GO 21941
21880: LD_INT 47
21882: DOUBLE
21883: EQUAL
21884: IFTRUE 21888
21886: GO 21906
21888: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
21889: LD_ADDR_VAR 0 3
21893: PUSH
21894: LD_INT 23
21896: PUSH
21897: LD_INT 24
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: ST_TO_ADDR
21904: GO 21941
21906: LD_INT 98
21908: DOUBLE
21909: EQUAL
21910: IFTRUE 21914
21912: GO 21940
21914: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21915: LD_ADDR_VAR 0 3
21919: PUSH
21920: LD_INT 21
21922: PUSH
21923: LD_INT 22
21925: PUSH
21926: LD_INT 23
21928: PUSH
21929: LD_INT 24
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: LIST
21936: LIST
21937: ST_TO_ADDR
21938: GO 21941
21940: POP
// result := ( chassis in result ) ;
21941: LD_ADDR_VAR 0 3
21945: PUSH
21946: LD_VAR 0 1
21950: PUSH
21951: LD_VAR 0 3
21955: IN
21956: ST_TO_ADDR
// end ;
21957: LD_VAR 0 3
21961: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21962: LD_INT 0
21964: PPUSH
21965: PPUSH
21966: PPUSH
21967: PPUSH
21968: PPUSH
21969: PPUSH
21970: PPUSH
// result := array ;
21971: LD_ADDR_VAR 0 5
21975: PUSH
21976: LD_VAR 0 1
21980: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21981: LD_VAR 0 1
21985: NOT
21986: IFTRUE 21995
21988: PUSH
21989: LD_VAR 0 2
21993: NOT
21994: OR
21995: IFTRUE 22004
21997: PUSH
21998: LD_VAR 0 3
22002: NOT
22003: OR
22004: IFTRUE 22018
22006: PUSH
22007: LD_VAR 0 2
22011: PUSH
22012: LD_VAR 0 1
22016: GREATER
22017: OR
22018: IFTRUE 22032
22020: PUSH
22021: LD_VAR 0 3
22025: PUSH
22026: LD_VAR 0 1
22030: GREATER
22031: OR
22032: IFFALSE 22036
// exit ;
22034: GO 22332
// if direction then
22036: LD_VAR 0 4
22040: IFFALSE 22104
// begin d := 1 ;
22042: LD_ADDR_VAR 0 9
22046: PUSH
22047: LD_INT 1
22049: ST_TO_ADDR
// if i_from > i_to then
22050: LD_VAR 0 2
22054: PUSH
22055: LD_VAR 0 3
22059: GREATER
22060: IFFALSE 22086
// length := ( array - i_from ) + i_to else
22062: LD_ADDR_VAR 0 11
22066: PUSH
22067: LD_VAR 0 1
22071: PUSH
22072: LD_VAR 0 2
22076: MINUS
22077: PUSH
22078: LD_VAR 0 3
22082: PLUS
22083: ST_TO_ADDR
22084: GO 22102
// length := i_to - i_from ;
22086: LD_ADDR_VAR 0 11
22090: PUSH
22091: LD_VAR 0 3
22095: PUSH
22096: LD_VAR 0 2
22100: MINUS
22101: ST_TO_ADDR
// end else
22102: GO 22165
// begin d := - 1 ;
22104: LD_ADDR_VAR 0 9
22108: PUSH
22109: LD_INT 1
22111: NEG
22112: ST_TO_ADDR
// if i_from > i_to then
22113: LD_VAR 0 2
22117: PUSH
22118: LD_VAR 0 3
22122: GREATER
22123: IFFALSE 22143
// length := i_from - i_to else
22125: LD_ADDR_VAR 0 11
22129: PUSH
22130: LD_VAR 0 2
22134: PUSH
22135: LD_VAR 0 3
22139: MINUS
22140: ST_TO_ADDR
22141: GO 22165
// length := ( array - i_to ) + i_from ;
22143: LD_ADDR_VAR 0 11
22147: PUSH
22148: LD_VAR 0 1
22152: PUSH
22153: LD_VAR 0 3
22157: MINUS
22158: PUSH
22159: LD_VAR 0 2
22163: PLUS
22164: ST_TO_ADDR
// end ; if not length then
22165: LD_VAR 0 11
22169: NOT
22170: IFFALSE 22174
// exit ;
22172: GO 22332
// tmp := array ;
22174: LD_ADDR_VAR 0 10
22178: PUSH
22179: LD_VAR 0 1
22183: ST_TO_ADDR
// for i = 1 to length do
22184: LD_ADDR_VAR 0 6
22188: PUSH
22189: DOUBLE
22190: LD_INT 1
22192: DEC
22193: ST_TO_ADDR
22194: LD_VAR 0 11
22198: PUSH
22199: FOR_TO
22200: IFFALSE 22320
// begin for j = 1 to array do
22202: LD_ADDR_VAR 0 7
22206: PUSH
22207: DOUBLE
22208: LD_INT 1
22210: DEC
22211: ST_TO_ADDR
22212: LD_VAR 0 1
22216: PUSH
22217: FOR_TO
22218: IFFALSE 22306
// begin k := j + d ;
22220: LD_ADDR_VAR 0 8
22224: PUSH
22225: LD_VAR 0 7
22229: PUSH
22230: LD_VAR 0 9
22234: PLUS
22235: ST_TO_ADDR
// if k > array then
22236: LD_VAR 0 8
22240: PUSH
22241: LD_VAR 0 1
22245: GREATER
22246: IFFALSE 22256
// k := 1 ;
22248: LD_ADDR_VAR 0 8
22252: PUSH
22253: LD_INT 1
22255: ST_TO_ADDR
// if not k then
22256: LD_VAR 0 8
22260: NOT
22261: IFFALSE 22273
// k := array ;
22263: LD_ADDR_VAR 0 8
22267: PUSH
22268: LD_VAR 0 1
22272: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22273: LD_ADDR_VAR 0 10
22277: PUSH
22278: LD_VAR 0 10
22282: PPUSH
22283: LD_VAR 0 8
22287: PPUSH
22288: LD_VAR 0 1
22292: PUSH
22293: LD_VAR 0 7
22297: ARRAY
22298: PPUSH
22299: CALL_OW 1
22303: ST_TO_ADDR
// end ;
22304: GO 22217
22306: POP
22307: POP
// array := tmp ;
22308: LD_ADDR_VAR 0 1
22312: PUSH
22313: LD_VAR 0 10
22317: ST_TO_ADDR
// end ;
22318: GO 22199
22320: POP
22321: POP
// result := array ;
22322: LD_ADDR_VAR 0 5
22326: PUSH
22327: LD_VAR 0 1
22331: ST_TO_ADDR
// end ;
22332: LD_VAR 0 5
22336: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22337: LD_INT 0
22339: PPUSH
22340: PPUSH
// result := 0 ;
22341: LD_ADDR_VAR 0 3
22345: PUSH
22346: LD_INT 0
22348: ST_TO_ADDR
// if not array or not value in array then
22349: LD_VAR 0 1
22353: NOT
22354: IFTRUE 22369
22356: PUSH
22357: LD_VAR 0 2
22361: PUSH
22362: LD_VAR 0 1
22366: IN
22367: NOT
22368: OR
22369: IFFALSE 22373
// exit ;
22371: GO 22427
// for i = 1 to array do
22373: LD_ADDR_VAR 0 4
22377: PUSH
22378: DOUBLE
22379: LD_INT 1
22381: DEC
22382: ST_TO_ADDR
22383: LD_VAR 0 1
22387: PUSH
22388: FOR_TO
22389: IFFALSE 22425
// if value = array [ i ] then
22391: LD_VAR 0 2
22395: PUSH
22396: LD_VAR 0 1
22400: PUSH
22401: LD_VAR 0 4
22405: ARRAY
22406: EQUAL
22407: IFFALSE 22423
// begin result := i ;
22409: LD_ADDR_VAR 0 3
22413: PUSH
22414: LD_VAR 0 4
22418: ST_TO_ADDR
// exit ;
22419: POP
22420: POP
22421: GO 22427
// end ;
22423: GO 22388
22425: POP
22426: POP
// end ;
22427: LD_VAR 0 3
22431: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22432: LD_INT 0
22434: PPUSH
// vc_chassis := chassis ;
22435: LD_ADDR_OWVAR 37
22439: PUSH
22440: LD_VAR 0 1
22444: ST_TO_ADDR
// vc_engine := engine ;
22445: LD_ADDR_OWVAR 39
22449: PUSH
22450: LD_VAR 0 2
22454: ST_TO_ADDR
// vc_control := control ;
22455: LD_ADDR_OWVAR 38
22459: PUSH
22460: LD_VAR 0 3
22464: ST_TO_ADDR
// vc_weapon := weapon ;
22465: LD_ADDR_OWVAR 40
22469: PUSH
22470: LD_VAR 0 4
22474: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22475: LD_ADDR_OWVAR 41
22479: PUSH
22480: LD_VAR 0 5
22484: ST_TO_ADDR
// end ;
22485: LD_VAR 0 6
22489: RET
// export function WantPlant ( unit ) ; var task ; begin
22490: LD_INT 0
22492: PPUSH
22493: PPUSH
// result := false ;
22494: LD_ADDR_VAR 0 2
22498: PUSH
22499: LD_INT 0
22501: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22502: LD_ADDR_VAR 0 3
22506: PUSH
22507: LD_VAR 0 1
22511: PPUSH
22512: CALL_OW 437
22516: ST_TO_ADDR
// if task then
22517: LD_VAR 0 3
22521: IFFALSE 22549
// if task [ 1 ] [ 1 ] = p then
22523: LD_VAR 0 3
22527: PUSH
22528: LD_INT 1
22530: ARRAY
22531: PUSH
22532: LD_INT 1
22534: ARRAY
22535: PUSH
22536: LD_STRING p
22538: EQUAL
22539: IFFALSE 22549
// result := true ;
22541: LD_ADDR_VAR 0 2
22545: PUSH
22546: LD_INT 1
22548: ST_TO_ADDR
// end ;
22549: LD_VAR 0 2
22553: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22554: LD_INT 0
22556: PPUSH
22557: PPUSH
22558: PPUSH
22559: PPUSH
// if pos < 1 then
22560: LD_VAR 0 2
22564: PUSH
22565: LD_INT 1
22567: LESS
22568: IFFALSE 22572
// exit ;
22570: GO 22875
// if pos = 1 then
22572: LD_VAR 0 2
22576: PUSH
22577: LD_INT 1
22579: EQUAL
22580: IFFALSE 22613
// result := Replace ( arr , pos [ 1 ] , value ) else
22582: LD_ADDR_VAR 0 4
22586: PUSH
22587: LD_VAR 0 1
22591: PPUSH
22592: LD_VAR 0 2
22596: PUSH
22597: LD_INT 1
22599: ARRAY
22600: PPUSH
22601: LD_VAR 0 3
22605: PPUSH
22606: CALL_OW 1
22610: ST_TO_ADDR
22611: GO 22875
// begin tmp := arr ;
22613: LD_ADDR_VAR 0 6
22617: PUSH
22618: LD_VAR 0 1
22622: ST_TO_ADDR
// s_arr := [ tmp ] ;
22623: LD_ADDR_VAR 0 7
22627: PUSH
22628: LD_VAR 0 6
22632: PUSH
22633: EMPTY
22634: LIST
22635: ST_TO_ADDR
// for i = 1 to pos - 1 do
22636: LD_ADDR_VAR 0 5
22640: PUSH
22641: DOUBLE
22642: LD_INT 1
22644: DEC
22645: ST_TO_ADDR
22646: LD_VAR 0 2
22650: PUSH
22651: LD_INT 1
22653: MINUS
22654: PUSH
22655: FOR_TO
22656: IFFALSE 22701
// begin tmp := tmp [ pos [ i ] ] ;
22658: LD_ADDR_VAR 0 6
22662: PUSH
22663: LD_VAR 0 6
22667: PUSH
22668: LD_VAR 0 2
22672: PUSH
22673: LD_VAR 0 5
22677: ARRAY
22678: ARRAY
22679: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22680: LD_ADDR_VAR 0 7
22684: PUSH
22685: LD_VAR 0 7
22689: PUSH
22690: LD_VAR 0 6
22694: PUSH
22695: EMPTY
22696: LIST
22697: ADD
22698: ST_TO_ADDR
// end ;
22699: GO 22655
22701: POP
22702: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22703: LD_ADDR_VAR 0 6
22707: PUSH
22708: LD_VAR 0 6
22712: PPUSH
22713: LD_VAR 0 2
22717: PUSH
22718: LD_VAR 0 2
22722: ARRAY
22723: PPUSH
22724: LD_VAR 0 3
22728: PPUSH
22729: CALL_OW 1
22733: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22734: LD_ADDR_VAR 0 7
22738: PUSH
22739: LD_VAR 0 7
22743: PPUSH
22744: LD_VAR 0 7
22748: PPUSH
22749: LD_VAR 0 6
22753: PPUSH
22754: CALL_OW 1
22758: ST_TO_ADDR
// for i = s_arr downto 2 do
22759: LD_ADDR_VAR 0 5
22763: PUSH
22764: DOUBLE
22765: LD_VAR 0 7
22769: INC
22770: ST_TO_ADDR
22771: LD_INT 2
22773: PUSH
22774: FOR_DOWNTO
22775: IFFALSE 22859
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22777: LD_ADDR_VAR 0 6
22781: PUSH
22782: LD_VAR 0 7
22786: PUSH
22787: LD_VAR 0 5
22791: PUSH
22792: LD_INT 1
22794: MINUS
22795: ARRAY
22796: PPUSH
22797: LD_VAR 0 2
22801: PUSH
22802: LD_VAR 0 5
22806: PUSH
22807: LD_INT 1
22809: MINUS
22810: ARRAY
22811: PPUSH
22812: LD_VAR 0 7
22816: PUSH
22817: LD_VAR 0 5
22821: ARRAY
22822: PPUSH
22823: CALL_OW 1
22827: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22828: LD_ADDR_VAR 0 7
22832: PUSH
22833: LD_VAR 0 7
22837: PPUSH
22838: LD_VAR 0 5
22842: PUSH
22843: LD_INT 1
22845: MINUS
22846: PPUSH
22847: LD_VAR 0 6
22851: PPUSH
22852: CALL_OW 1
22856: ST_TO_ADDR
// end ;
22857: GO 22774
22859: POP
22860: POP
// result := s_arr [ 1 ] ;
22861: LD_ADDR_VAR 0 4
22865: PUSH
22866: LD_VAR 0 7
22870: PUSH
22871: LD_INT 1
22873: ARRAY
22874: ST_TO_ADDR
// end ; end ;
22875: LD_VAR 0 4
22879: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22880: LD_INT 0
22882: PPUSH
22883: PPUSH
// if not list then
22884: LD_VAR 0 1
22888: NOT
22889: IFFALSE 22893
// exit ;
22891: GO 22984
// i := list [ pos1 ] ;
22893: LD_ADDR_VAR 0 5
22897: PUSH
22898: LD_VAR 0 1
22902: PUSH
22903: LD_VAR 0 2
22907: ARRAY
22908: ST_TO_ADDR
// if not i then
22909: LD_VAR 0 5
22913: NOT
22914: IFFALSE 22918
// exit ;
22916: GO 22984
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22918: LD_ADDR_VAR 0 1
22922: PUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: LD_VAR 0 2
22932: PPUSH
22933: LD_VAR 0 1
22937: PUSH
22938: LD_VAR 0 3
22942: ARRAY
22943: PPUSH
22944: CALL_OW 1
22948: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22949: LD_ADDR_VAR 0 1
22953: PUSH
22954: LD_VAR 0 1
22958: PPUSH
22959: LD_VAR 0 3
22963: PPUSH
22964: LD_VAR 0 5
22968: PPUSH
22969: CALL_OW 1
22973: ST_TO_ADDR
// result := list ;
22974: LD_ADDR_VAR 0 4
22978: PUSH
22979: LD_VAR 0 1
22983: ST_TO_ADDR
// end ;
22984: LD_VAR 0 4
22988: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22989: LD_INT 0
22991: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22992: LD_ADDR_VAR 0 5
22996: PUSH
22997: LD_VAR 0 1
23001: PPUSH
23002: CALL_OW 250
23006: PPUSH
23007: LD_VAR 0 1
23011: PPUSH
23012: CALL_OW 251
23016: PPUSH
23017: LD_VAR 0 2
23021: PPUSH
23022: LD_VAR 0 3
23026: PPUSH
23027: LD_VAR 0 4
23031: PPUSH
23032: CALL 23414 0 5
23036: ST_TO_ADDR
// end ;
23037: LD_VAR 0 5
23041: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
23042: LD_INT 0
23044: PPUSH
23045: PPUSH
23046: PPUSH
23047: PPUSH
// if not list or not unit then
23048: LD_VAR 0 2
23052: NOT
23053: IFTRUE 23062
23055: PUSH
23056: LD_VAR 0 1
23060: NOT
23061: OR
23062: IFFALSE 23066
// exit ;
23064: GO 23409
// result := [ ] ;
23066: LD_ADDR_VAR 0 5
23070: PUSH
23071: EMPTY
23072: ST_TO_ADDR
// for i in list do
23073: LD_ADDR_VAR 0 6
23077: PUSH
23078: LD_VAR 0 2
23082: PUSH
23083: FOR_IN
23084: IFFALSE 23302
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
23086: LD_ADDR_VAR 0 8
23090: PUSH
23091: LD_VAR 0 1
23095: PPUSH
23096: LD_VAR 0 6
23100: PUSH
23101: LD_INT 1
23103: ARRAY
23104: PPUSH
23105: LD_VAR 0 6
23109: PUSH
23110: LD_INT 2
23112: ARRAY
23113: PPUSH
23114: CALL_OW 297
23118: ST_TO_ADDR
// if not Count ( result ) then
23119: LD_VAR 0 5
23123: PPUSH
23124: CALL 19636 0 1
23128: NOT
23129: IFFALSE 23162
// begin result := Join ( result , [ i , tmp ] ) ;
23131: LD_ADDR_VAR 0 5
23135: PUSH
23136: LD_VAR 0 5
23140: PPUSH
23141: LD_VAR 0 6
23145: PUSH
23146: LD_VAR 0 8
23150: PUSH
23151: EMPTY
23152: LIST
23153: LIST
23154: PPUSH
23155: CALL 55612 0 2
23159: ST_TO_ADDR
// continue ;
23160: GO 23083
// end ; if result [ result ] [ 2 ] <= tmp then
23162: LD_VAR 0 5
23166: PUSH
23167: LD_VAR 0 5
23171: ARRAY
23172: PUSH
23173: LD_INT 2
23175: ARRAY
23176: PUSH
23177: LD_VAR 0 8
23181: LESSEQUAL
23182: IFFALSE 23215
// result := Join ( result , [ i , tmp ] ) else
23184: LD_ADDR_VAR 0 5
23188: PUSH
23189: LD_VAR 0 5
23193: PPUSH
23194: LD_VAR 0 6
23198: PUSH
23199: LD_VAR 0 8
23203: PUSH
23204: EMPTY
23205: LIST
23206: LIST
23207: PPUSH
23208: CALL 55612 0 2
23212: ST_TO_ADDR
23213: GO 23300
// begin for j := 1 to Count ( result ) do
23215: LD_ADDR_VAR 0 7
23219: PUSH
23220: DOUBLE
23221: LD_INT 1
23223: DEC
23224: ST_TO_ADDR
23225: LD_VAR 0 5
23229: PPUSH
23230: CALL 19636 0 1
23234: PUSH
23235: FOR_TO
23236: IFFALSE 23298
// begin if tmp < result [ j ] [ 2 ] then
23238: LD_VAR 0 8
23242: PUSH
23243: LD_VAR 0 5
23247: PUSH
23248: LD_VAR 0 7
23252: ARRAY
23253: PUSH
23254: LD_INT 2
23256: ARRAY
23257: LESS
23258: IFFALSE 23296
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23260: LD_ADDR_VAR 0 5
23264: PUSH
23265: LD_VAR 0 5
23269: PPUSH
23270: LD_VAR 0 7
23274: PPUSH
23275: LD_VAR 0 6
23279: PUSH
23280: LD_VAR 0 8
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PPUSH
23289: CALL_OW 2
23293: ST_TO_ADDR
// break ;
23294: GO 23298
// end ; end ;
23296: GO 23235
23298: POP
23299: POP
// end ; end ;
23300: GO 23083
23302: POP
23303: POP
// if result and not asc then
23304: LD_VAR 0 5
23308: IFFALSE 23317
23310: PUSH
23311: LD_VAR 0 3
23315: NOT
23316: AND
23317: IFFALSE 23334
// result := ReverseArray ( result ) ;
23319: LD_ADDR_VAR 0 5
23323: PUSH
23324: LD_VAR 0 5
23328: PPUSH
23329: CALL 50692 0 1
23333: ST_TO_ADDR
// tmp := [ ] ;
23334: LD_ADDR_VAR 0 8
23338: PUSH
23339: EMPTY
23340: ST_TO_ADDR
// if mode then
23341: LD_VAR 0 4
23345: IFFALSE 23409
// begin for i := 1 to result do
23347: LD_ADDR_VAR 0 6
23351: PUSH
23352: DOUBLE
23353: LD_INT 1
23355: DEC
23356: ST_TO_ADDR
23357: LD_VAR 0 5
23361: PUSH
23362: FOR_TO
23363: IFFALSE 23397
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23365: LD_ADDR_VAR 0 8
23369: PUSH
23370: LD_VAR 0 8
23374: PPUSH
23375: LD_VAR 0 5
23379: PUSH
23380: LD_VAR 0 6
23384: ARRAY
23385: PUSH
23386: LD_INT 1
23388: ARRAY
23389: PPUSH
23390: CALL 55612 0 2
23394: ST_TO_ADDR
23395: GO 23362
23397: POP
23398: POP
// result := tmp ;
23399: LD_ADDR_VAR 0 5
23403: PUSH
23404: LD_VAR 0 8
23408: ST_TO_ADDR
// end ; end ;
23409: LD_VAR 0 5
23413: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23414: LD_INT 0
23416: PPUSH
23417: PPUSH
23418: PPUSH
23419: PPUSH
// if not list then
23420: LD_VAR 0 3
23424: NOT
23425: IFFALSE 23429
// exit ;
23427: GO 23819
// result := [ ] ;
23429: LD_ADDR_VAR 0 6
23433: PUSH
23434: EMPTY
23435: ST_TO_ADDR
// for i in list do
23436: LD_ADDR_VAR 0 7
23440: PUSH
23441: LD_VAR 0 3
23445: PUSH
23446: FOR_IN
23447: IFFALSE 23649
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23449: LD_ADDR_VAR 0 9
23453: PUSH
23454: LD_VAR 0 7
23458: PPUSH
23459: LD_VAR 0 1
23463: PPUSH
23464: LD_VAR 0 2
23468: PPUSH
23469: CALL_OW 297
23473: ST_TO_ADDR
// if not result then
23474: LD_VAR 0 6
23478: NOT
23479: IFFALSE 23505
// result := [ [ i , tmp ] ] else
23481: LD_ADDR_VAR 0 6
23485: PUSH
23486: LD_VAR 0 7
23490: PUSH
23491: LD_VAR 0 9
23495: PUSH
23496: EMPTY
23497: LIST
23498: LIST
23499: PUSH
23500: EMPTY
23501: LIST
23502: ST_TO_ADDR
23503: GO 23647
// begin if result [ result ] [ 2 ] <= tmp then
23505: LD_VAR 0 6
23509: PUSH
23510: LD_VAR 0 6
23514: ARRAY
23515: PUSH
23516: LD_INT 2
23518: ARRAY
23519: PUSH
23520: LD_VAR 0 9
23524: LESSEQUAL
23525: IFFALSE 23567
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23527: LD_ADDR_VAR 0 6
23531: PUSH
23532: LD_VAR 0 6
23536: PPUSH
23537: LD_VAR 0 6
23541: PUSH
23542: LD_INT 1
23544: PLUS
23545: PPUSH
23546: LD_VAR 0 7
23550: PUSH
23551: LD_VAR 0 9
23555: PUSH
23556: EMPTY
23557: LIST
23558: LIST
23559: PPUSH
23560: CALL_OW 2
23564: ST_TO_ADDR
23565: GO 23647
// for j := 1 to result do
23567: LD_ADDR_VAR 0 8
23571: PUSH
23572: DOUBLE
23573: LD_INT 1
23575: DEC
23576: ST_TO_ADDR
23577: LD_VAR 0 6
23581: PUSH
23582: FOR_TO
23583: IFFALSE 23645
// begin if tmp < result [ j ] [ 2 ] then
23585: LD_VAR 0 9
23589: PUSH
23590: LD_VAR 0 6
23594: PUSH
23595: LD_VAR 0 8
23599: ARRAY
23600: PUSH
23601: LD_INT 2
23603: ARRAY
23604: LESS
23605: IFFALSE 23643
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23607: LD_ADDR_VAR 0 6
23611: PUSH
23612: LD_VAR 0 6
23616: PPUSH
23617: LD_VAR 0 8
23621: PPUSH
23622: LD_VAR 0 7
23626: PUSH
23627: LD_VAR 0 9
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: PPUSH
23636: CALL_OW 2
23640: ST_TO_ADDR
// break ;
23641: GO 23645
// end ; end ;
23643: GO 23582
23645: POP
23646: POP
// end ; end ;
23647: GO 23446
23649: POP
23650: POP
// if result and not asc then
23651: LD_VAR 0 6
23655: IFFALSE 23664
23657: PUSH
23658: LD_VAR 0 4
23662: NOT
23663: AND
23664: IFFALSE 23739
// begin tmp := result ;
23666: LD_ADDR_VAR 0 9
23670: PUSH
23671: LD_VAR 0 6
23675: ST_TO_ADDR
// for i = tmp downto 1 do
23676: LD_ADDR_VAR 0 7
23680: PUSH
23681: DOUBLE
23682: LD_VAR 0 9
23686: INC
23687: ST_TO_ADDR
23688: LD_INT 1
23690: PUSH
23691: FOR_DOWNTO
23692: IFFALSE 23737
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23694: LD_ADDR_VAR 0 6
23698: PUSH
23699: LD_VAR 0 6
23703: PPUSH
23704: LD_VAR 0 9
23708: PUSH
23709: LD_VAR 0 7
23713: MINUS
23714: PUSH
23715: LD_INT 1
23717: PLUS
23718: PPUSH
23719: LD_VAR 0 9
23723: PUSH
23724: LD_VAR 0 7
23728: ARRAY
23729: PPUSH
23730: CALL_OW 1
23734: ST_TO_ADDR
23735: GO 23691
23737: POP
23738: POP
// end ; tmp := [ ] ;
23739: LD_ADDR_VAR 0 9
23743: PUSH
23744: EMPTY
23745: ST_TO_ADDR
// if mode then
23746: LD_VAR 0 5
23750: IFFALSE 23819
// begin for i = 1 to result do
23752: LD_ADDR_VAR 0 7
23756: PUSH
23757: DOUBLE
23758: LD_INT 1
23760: DEC
23761: ST_TO_ADDR
23762: LD_VAR 0 6
23766: PUSH
23767: FOR_TO
23768: IFFALSE 23807
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23770: LD_ADDR_VAR 0 9
23774: PUSH
23775: LD_VAR 0 9
23779: PPUSH
23780: LD_VAR 0 7
23784: PPUSH
23785: LD_VAR 0 6
23789: PUSH
23790: LD_VAR 0 7
23794: ARRAY
23795: PUSH
23796: LD_INT 1
23798: ARRAY
23799: PPUSH
23800: CALL_OW 1
23804: ST_TO_ADDR
23805: GO 23767
23807: POP
23808: POP
// result := tmp ;
23809: LD_ADDR_VAR 0 6
23813: PUSH
23814: LD_VAR 0 9
23818: ST_TO_ADDR
// end ; end ;
23819: LD_VAR 0 6
23823: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23824: LD_INT 0
23826: PPUSH
23827: PPUSH
23828: PPUSH
23829: PPUSH
23830: PPUSH
23831: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23832: LD_ADDR_VAR 0 5
23836: PUSH
23837: LD_INT 0
23839: PUSH
23840: LD_INT 0
23842: PUSH
23843: LD_INT 0
23845: PUSH
23846: EMPTY
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: LIST
23852: LIST
23853: ST_TO_ADDR
// if not x or not y then
23854: LD_VAR 0 2
23858: NOT
23859: IFTRUE 23868
23861: PUSH
23862: LD_VAR 0 3
23866: NOT
23867: OR
23868: IFFALSE 23872
// exit ;
23870: GO 25528
// if not range then
23872: LD_VAR 0 4
23876: NOT
23877: IFFALSE 23887
// range := 10 ;
23879: LD_ADDR_VAR 0 4
23883: PUSH
23884: LD_INT 10
23886: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23887: LD_ADDR_VAR 0 8
23891: PUSH
23892: LD_INT 81
23894: PUSH
23895: LD_VAR 0 1
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PUSH
23904: LD_INT 92
23906: PUSH
23907: LD_VAR 0 2
23911: PUSH
23912: LD_VAR 0 3
23916: PUSH
23917: LD_VAR 0 4
23921: PUSH
23922: EMPTY
23923: LIST
23924: LIST
23925: LIST
23926: LIST
23927: PUSH
23928: LD_INT 3
23930: PUSH
23931: LD_INT 21
23933: PUSH
23934: LD_INT 3
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PUSH
23941: EMPTY
23942: LIST
23943: LIST
23944: PUSH
23945: EMPTY
23946: LIST
23947: LIST
23948: LIST
23949: PPUSH
23950: CALL_OW 69
23954: ST_TO_ADDR
// if not tmp then
23955: LD_VAR 0 8
23959: NOT
23960: IFFALSE 23964
// exit ;
23962: GO 25528
// for i in tmp do
23964: LD_ADDR_VAR 0 6
23968: PUSH
23969: LD_VAR 0 8
23973: PUSH
23974: FOR_IN
23975: IFFALSE 25503
// begin points := [ 0 , 0 , 0 ] ;
23977: LD_ADDR_VAR 0 9
23981: PUSH
23982: LD_INT 0
23984: PUSH
23985: LD_INT 0
23987: PUSH
23988: LD_INT 0
23990: PUSH
23991: EMPTY
23992: LIST
23993: LIST
23994: LIST
23995: ST_TO_ADDR
// bpoints := 1 ;
23996: LD_ADDR_VAR 0 10
24000: PUSH
24001: LD_INT 1
24003: ST_TO_ADDR
// case GetType ( i ) of unit_human :
24004: LD_VAR 0 6
24008: PPUSH
24009: CALL_OW 247
24013: PUSH
24014: LD_INT 1
24016: DOUBLE
24017: EQUAL
24018: IFTRUE 24022
24020: GO 24604
24022: POP
// begin if GetClass ( i ) = 1 then
24023: LD_VAR 0 6
24027: PPUSH
24028: CALL_OW 257
24032: PUSH
24033: LD_INT 1
24035: EQUAL
24036: IFFALSE 24057
// points := [ 10 , 5 , 3 ] ;
24038: LD_ADDR_VAR 0 9
24042: PUSH
24043: LD_INT 10
24045: PUSH
24046: LD_INT 5
24048: PUSH
24049: LD_INT 3
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: LIST
24056: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
24057: LD_VAR 0 6
24061: PPUSH
24062: CALL_OW 257
24066: PUSH
24067: LD_INT 2
24069: PUSH
24070: LD_INT 3
24072: PUSH
24073: LD_INT 4
24075: PUSH
24076: EMPTY
24077: LIST
24078: LIST
24079: LIST
24080: IN
24081: IFFALSE 24102
// points := [ 3 , 2 , 1 ] ;
24083: LD_ADDR_VAR 0 9
24087: PUSH
24088: LD_INT 3
24090: PUSH
24091: LD_INT 2
24093: PUSH
24094: LD_INT 1
24096: PUSH
24097: EMPTY
24098: LIST
24099: LIST
24100: LIST
24101: ST_TO_ADDR
// if GetClass ( i ) = 5 then
24102: LD_VAR 0 6
24106: PPUSH
24107: CALL_OW 257
24111: PUSH
24112: LD_INT 5
24114: EQUAL
24115: IFFALSE 24136
// points := [ 130 , 5 , 2 ] ;
24117: LD_ADDR_VAR 0 9
24121: PUSH
24122: LD_INT 130
24124: PUSH
24125: LD_INT 5
24127: PUSH
24128: LD_INT 2
24130: PUSH
24131: EMPTY
24132: LIST
24133: LIST
24134: LIST
24135: ST_TO_ADDR
// if GetClass ( i ) = 8 then
24136: LD_VAR 0 6
24140: PPUSH
24141: CALL_OW 257
24145: PUSH
24146: LD_INT 8
24148: EQUAL
24149: IFFALSE 24170
// points := [ 35 , 35 , 30 ] ;
24151: LD_ADDR_VAR 0 9
24155: PUSH
24156: LD_INT 35
24158: PUSH
24159: LD_INT 35
24161: PUSH
24162: LD_INT 30
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: LIST
24169: ST_TO_ADDR
// if GetClass ( i ) = 9 then
24170: LD_VAR 0 6
24174: PPUSH
24175: CALL_OW 257
24179: PUSH
24180: LD_INT 9
24182: EQUAL
24183: IFFALSE 24204
// points := [ 20 , 55 , 40 ] ;
24185: LD_ADDR_VAR 0 9
24189: PUSH
24190: LD_INT 20
24192: PUSH
24193: LD_INT 55
24195: PUSH
24196: LD_INT 40
24198: PUSH
24199: EMPTY
24200: LIST
24201: LIST
24202: LIST
24203: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
24204: LD_VAR 0 6
24208: PPUSH
24209: CALL_OW 257
24213: PUSH
24214: LD_INT 12
24216: PUSH
24217: LD_INT 16
24219: PUSH
24220: EMPTY
24221: LIST
24222: LIST
24223: IN
24224: IFFALSE 24245
// points := [ 5 , 3 , 2 ] ;
24226: LD_ADDR_VAR 0 9
24230: PUSH
24231: LD_INT 5
24233: PUSH
24234: LD_INT 3
24236: PUSH
24237: LD_INT 2
24239: PUSH
24240: EMPTY
24241: LIST
24242: LIST
24243: LIST
24244: ST_TO_ADDR
// if GetClass ( i ) = 17 then
24245: LD_VAR 0 6
24249: PPUSH
24250: CALL_OW 257
24254: PUSH
24255: LD_INT 17
24257: EQUAL
24258: IFFALSE 24279
// points := [ 100 , 50 , 75 ] ;
24260: LD_ADDR_VAR 0 9
24264: PUSH
24265: LD_INT 100
24267: PUSH
24268: LD_INT 50
24270: PUSH
24271: LD_INT 75
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: LIST
24278: ST_TO_ADDR
// if GetClass ( i ) = 15 then
24279: LD_VAR 0 6
24283: PPUSH
24284: CALL_OW 257
24288: PUSH
24289: LD_INT 15
24291: EQUAL
24292: IFFALSE 24313
// points := [ 10 , 5 , 3 ] ;
24294: LD_ADDR_VAR 0 9
24298: PUSH
24299: LD_INT 10
24301: PUSH
24302: LD_INT 5
24304: PUSH
24305: LD_INT 3
24307: PUSH
24308: EMPTY
24309: LIST
24310: LIST
24311: LIST
24312: ST_TO_ADDR
// if GetClass ( i ) = 14 then
24313: LD_VAR 0 6
24317: PPUSH
24318: CALL_OW 257
24322: PUSH
24323: LD_INT 14
24325: EQUAL
24326: IFFALSE 24347
// points := [ 10 , 0 , 0 ] ;
24328: LD_ADDR_VAR 0 9
24332: PUSH
24333: LD_INT 10
24335: PUSH
24336: LD_INT 0
24338: PUSH
24339: LD_INT 0
24341: PUSH
24342: EMPTY
24343: LIST
24344: LIST
24345: LIST
24346: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24347: LD_VAR 0 6
24351: PPUSH
24352: CALL_OW 257
24356: PUSH
24357: LD_INT 11
24359: EQUAL
24360: IFFALSE 24381
// points := [ 30 , 10 , 5 ] ;
24362: LD_ADDR_VAR 0 9
24366: PUSH
24367: LD_INT 30
24369: PUSH
24370: LD_INT 10
24372: PUSH
24373: LD_INT 5
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: LIST
24380: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24381: LD_VAR 0 1
24385: PPUSH
24386: LD_INT 5
24388: PPUSH
24389: CALL_OW 321
24393: PUSH
24394: LD_INT 2
24396: EQUAL
24397: IFFALSE 24414
// bpoints := bpoints * 1.8 ;
24399: LD_ADDR_VAR 0 10
24403: PUSH
24404: LD_VAR 0 10
24408: PUSH
24409: LD_REAL  1.80000000000000E+0000
24412: MUL
24413: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24414: LD_VAR 0 6
24418: PPUSH
24419: CALL_OW 257
24423: PUSH
24424: LD_INT 1
24426: PUSH
24427: LD_INT 2
24429: PUSH
24430: LD_INT 3
24432: PUSH
24433: LD_INT 4
24435: PUSH
24436: EMPTY
24437: LIST
24438: LIST
24439: LIST
24440: LIST
24441: IN
24442: IFFALSE 24462
24444: PUSH
24445: LD_VAR 0 1
24449: PPUSH
24450: LD_INT 51
24452: PPUSH
24453: CALL_OW 321
24457: PUSH
24458: LD_INT 2
24460: EQUAL
24461: AND
24462: IFFALSE 24479
// bpoints := bpoints * 1.2 ;
24464: LD_ADDR_VAR 0 10
24468: PUSH
24469: LD_VAR 0 10
24473: PUSH
24474: LD_REAL  1.20000000000000E+0000
24477: MUL
24478: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24479: LD_VAR 0 6
24483: PPUSH
24484: CALL_OW 257
24488: PUSH
24489: LD_INT 5
24491: PUSH
24492: LD_INT 7
24494: PUSH
24495: LD_INT 9
24497: PUSH
24498: EMPTY
24499: LIST
24500: LIST
24501: LIST
24502: IN
24503: IFFALSE 24523
24505: PUSH
24506: LD_VAR 0 1
24510: PPUSH
24511: LD_INT 52
24513: PPUSH
24514: CALL_OW 321
24518: PUSH
24519: LD_INT 2
24521: EQUAL
24522: AND
24523: IFFALSE 24540
// bpoints := bpoints * 1.5 ;
24525: LD_ADDR_VAR 0 10
24529: PUSH
24530: LD_VAR 0 10
24534: PUSH
24535: LD_REAL  1.50000000000000E+0000
24538: MUL
24539: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24540: LD_VAR 0 1
24544: PPUSH
24545: LD_INT 66
24547: PPUSH
24548: CALL_OW 321
24552: PUSH
24553: LD_INT 2
24555: EQUAL
24556: IFFALSE 24573
// bpoints := bpoints * 1.1 ;
24558: LD_ADDR_VAR 0 10
24562: PUSH
24563: LD_VAR 0 10
24567: PUSH
24568: LD_REAL  1.10000000000000E+0000
24571: MUL
24572: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24573: LD_ADDR_VAR 0 10
24577: PUSH
24578: LD_VAR 0 10
24582: PUSH
24583: LD_VAR 0 6
24587: PPUSH
24588: LD_INT 1
24590: PPUSH
24591: CALL_OW 259
24595: PUSH
24596: LD_REAL  1.15000000000000E+0000
24599: MUL
24600: MUL
24601: ST_TO_ADDR
// end ; unit_vehicle :
24602: GO 25432
24604: LD_INT 2
24606: DOUBLE
24607: EQUAL
24608: IFTRUE 24612
24610: GO 25420
24612: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24613: LD_VAR 0 6
24617: PPUSH
24618: CALL_OW 264
24622: PUSH
24623: LD_INT 2
24625: PUSH
24626: LD_INT 42
24628: PUSH
24629: LD_INT 24
24631: PUSH
24632: EMPTY
24633: LIST
24634: LIST
24635: LIST
24636: IN
24637: IFFALSE 24658
// points := [ 25 , 5 , 3 ] ;
24639: LD_ADDR_VAR 0 9
24643: PUSH
24644: LD_INT 25
24646: PUSH
24647: LD_INT 5
24649: PUSH
24650: LD_INT 3
24652: PUSH
24653: EMPTY
24654: LIST
24655: LIST
24656: LIST
24657: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24658: LD_VAR 0 6
24662: PPUSH
24663: CALL_OW 264
24667: PUSH
24668: LD_INT 4
24670: PUSH
24671: LD_INT 43
24673: PUSH
24674: LD_INT 25
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: LIST
24681: IN
24682: IFFALSE 24703
// points := [ 40 , 15 , 5 ] ;
24684: LD_ADDR_VAR 0 9
24688: PUSH
24689: LD_INT 40
24691: PUSH
24692: LD_INT 15
24694: PUSH
24695: LD_INT 5
24697: PUSH
24698: EMPTY
24699: LIST
24700: LIST
24701: LIST
24702: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24703: LD_VAR 0 6
24707: PPUSH
24708: CALL_OW 264
24712: PUSH
24713: LD_INT 3
24715: PUSH
24716: LD_INT 23
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: IN
24723: IFFALSE 24744
// points := [ 7 , 25 , 8 ] ;
24725: LD_ADDR_VAR 0 9
24729: PUSH
24730: LD_INT 7
24732: PUSH
24733: LD_INT 25
24735: PUSH
24736: LD_INT 8
24738: PUSH
24739: EMPTY
24740: LIST
24741: LIST
24742: LIST
24743: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24744: LD_VAR 0 6
24748: PPUSH
24749: CALL_OW 264
24753: PUSH
24754: LD_INT 5
24756: PUSH
24757: LD_INT 27
24759: PUSH
24760: LD_INT 44
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: LIST
24767: IN
24768: IFFALSE 24789
// points := [ 14 , 50 , 16 ] ;
24770: LD_ADDR_VAR 0 9
24774: PUSH
24775: LD_INT 14
24777: PUSH
24778: LD_INT 50
24780: PUSH
24781: LD_INT 16
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24789: LD_VAR 0 6
24793: PPUSH
24794: CALL_OW 264
24798: PUSH
24799: LD_INT 6
24801: PUSH
24802: LD_INT 46
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: IN
24809: IFFALSE 24830
// points := [ 32 , 120 , 70 ] ;
24811: LD_ADDR_VAR 0 9
24815: PUSH
24816: LD_INT 32
24818: PUSH
24819: LD_INT 120
24821: PUSH
24822: LD_INT 70
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24830: LD_VAR 0 6
24834: PPUSH
24835: CALL_OW 264
24839: PUSH
24840: LD_INT 7
24842: PUSH
24843: LD_INT 28
24845: PUSH
24846: LD_INT 45
24848: PUSH
24849: LD_INT 92
24851: PUSH
24852: EMPTY
24853: LIST
24854: LIST
24855: LIST
24856: LIST
24857: IN
24858: IFFALSE 24879
// points := [ 35 , 20 , 45 ] ;
24860: LD_ADDR_VAR 0 9
24864: PUSH
24865: LD_INT 35
24867: PUSH
24868: LD_INT 20
24870: PUSH
24871: LD_INT 45
24873: PUSH
24874: EMPTY
24875: LIST
24876: LIST
24877: LIST
24878: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24879: LD_VAR 0 6
24883: PPUSH
24884: CALL_OW 264
24888: PUSH
24889: LD_INT 47
24891: PUSH
24892: EMPTY
24893: LIST
24894: IN
24895: IFFALSE 24916
// points := [ 67 , 45 , 75 ] ;
24897: LD_ADDR_VAR 0 9
24901: PUSH
24902: LD_INT 67
24904: PUSH
24905: LD_INT 45
24907: PUSH
24908: LD_INT 75
24910: PUSH
24911: EMPTY
24912: LIST
24913: LIST
24914: LIST
24915: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24916: LD_VAR 0 6
24920: PPUSH
24921: CALL_OW 264
24925: PUSH
24926: LD_INT 26
24928: PUSH
24929: EMPTY
24930: LIST
24931: IN
24932: IFFALSE 24953
// points := [ 120 , 30 , 80 ] ;
24934: LD_ADDR_VAR 0 9
24938: PUSH
24939: LD_INT 120
24941: PUSH
24942: LD_INT 30
24944: PUSH
24945: LD_INT 80
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: LIST
24952: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24953: LD_VAR 0 6
24957: PPUSH
24958: CALL_OW 264
24962: PUSH
24963: LD_INT 22
24965: PUSH
24966: EMPTY
24967: LIST
24968: IN
24969: IFFALSE 24990
// points := [ 40 , 1 , 1 ] ;
24971: LD_ADDR_VAR 0 9
24975: PUSH
24976: LD_INT 40
24978: PUSH
24979: LD_INT 1
24981: PUSH
24982: LD_INT 1
24984: PUSH
24985: EMPTY
24986: LIST
24987: LIST
24988: LIST
24989: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24990: LD_VAR 0 6
24994: PPUSH
24995: CALL_OW 264
24999: PUSH
25000: LD_INT 29
25002: PUSH
25003: EMPTY
25004: LIST
25005: IN
25006: IFFALSE 25027
// points := [ 70 , 200 , 400 ] ;
25008: LD_ADDR_VAR 0 9
25012: PUSH
25013: LD_INT 70
25015: PUSH
25016: LD_INT 200
25018: PUSH
25019: LD_INT 400
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: LIST
25026: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
25027: LD_VAR 0 6
25031: PPUSH
25032: CALL_OW 264
25036: PUSH
25037: LD_INT 14
25039: PUSH
25040: LD_INT 53
25042: PUSH
25043: EMPTY
25044: LIST
25045: LIST
25046: IN
25047: IFFALSE 25068
// points := [ 40 , 10 , 20 ] ;
25049: LD_ADDR_VAR 0 9
25053: PUSH
25054: LD_INT 40
25056: PUSH
25057: LD_INT 10
25059: PUSH
25060: LD_INT 20
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: LIST
25067: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
25068: LD_VAR 0 6
25072: PPUSH
25073: CALL_OW 264
25077: PUSH
25078: LD_INT 9
25080: PUSH
25081: EMPTY
25082: LIST
25083: IN
25084: IFFALSE 25105
// points := [ 5 , 70 , 20 ] ;
25086: LD_ADDR_VAR 0 9
25090: PUSH
25091: LD_INT 5
25093: PUSH
25094: LD_INT 70
25096: PUSH
25097: LD_INT 20
25099: PUSH
25100: EMPTY
25101: LIST
25102: LIST
25103: LIST
25104: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
25105: LD_VAR 0 6
25109: PPUSH
25110: CALL_OW 264
25114: PUSH
25115: LD_INT 10
25117: PUSH
25118: EMPTY
25119: LIST
25120: IN
25121: IFFALSE 25142
// points := [ 35 , 110 , 70 ] ;
25123: LD_ADDR_VAR 0 9
25127: PUSH
25128: LD_INT 35
25130: PUSH
25131: LD_INT 110
25133: PUSH
25134: LD_INT 70
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: LIST
25141: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
25142: LD_VAR 0 6
25146: PPUSH
25147: CALL_OW 265
25151: PUSH
25152: LD_INT 25
25154: EQUAL
25155: IFFALSE 25176
// points := [ 80 , 65 , 100 ] ;
25157: LD_ADDR_VAR 0 9
25161: PUSH
25162: LD_INT 80
25164: PUSH
25165: LD_INT 65
25167: PUSH
25168: LD_INT 100
25170: PUSH
25171: EMPTY
25172: LIST
25173: LIST
25174: LIST
25175: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
25176: LD_VAR 0 6
25180: PPUSH
25181: CALL_OW 263
25185: PUSH
25186: LD_INT 1
25188: EQUAL
25189: IFFALSE 25224
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
25191: LD_ADDR_VAR 0 10
25195: PUSH
25196: LD_VAR 0 10
25200: PUSH
25201: LD_VAR 0 6
25205: PPUSH
25206: CALL_OW 311
25210: PPUSH
25211: LD_INT 3
25213: PPUSH
25214: CALL_OW 259
25218: PUSH
25219: LD_INT 4
25221: MUL
25222: MUL
25223: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
25224: LD_VAR 0 6
25228: PPUSH
25229: CALL_OW 263
25233: PUSH
25234: LD_INT 2
25236: EQUAL
25237: IFFALSE 25288
// begin j := IsControledBy ( i ) ;
25239: LD_ADDR_VAR 0 7
25243: PUSH
25244: LD_VAR 0 6
25248: PPUSH
25249: CALL_OW 312
25253: ST_TO_ADDR
// if j then
25254: LD_VAR 0 7
25258: IFFALSE 25288
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
25260: LD_ADDR_VAR 0 10
25264: PUSH
25265: LD_VAR 0 10
25269: PUSH
25270: LD_VAR 0 7
25274: PPUSH
25275: LD_INT 3
25277: PPUSH
25278: CALL_OW 259
25282: PUSH
25283: LD_INT 3
25285: MUL
25286: MUL
25287: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
25288: LD_VAR 0 6
25292: PPUSH
25293: CALL_OW 264
25297: PUSH
25298: LD_INT 5
25300: PUSH
25301: LD_INT 6
25303: PUSH
25304: LD_INT 46
25306: PUSH
25307: LD_INT 44
25309: PUSH
25310: LD_INT 47
25312: PUSH
25313: LD_INT 45
25315: PUSH
25316: LD_INT 28
25318: PUSH
25319: LD_INT 7
25321: PUSH
25322: LD_INT 27
25324: PUSH
25325: LD_INT 29
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: IN
25340: IFFALSE 25360
25342: PUSH
25343: LD_VAR 0 1
25347: PPUSH
25348: LD_INT 52
25350: PPUSH
25351: CALL_OW 321
25355: PUSH
25356: LD_INT 2
25358: EQUAL
25359: AND
25360: IFFALSE 25377
// bpoints := bpoints * 1.2 ;
25362: LD_ADDR_VAR 0 10
25366: PUSH
25367: LD_VAR 0 10
25371: PUSH
25372: LD_REAL  1.20000000000000E+0000
25375: MUL
25376: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25377: LD_VAR 0 6
25381: PPUSH
25382: CALL_OW 264
25386: PUSH
25387: LD_INT 6
25389: PUSH
25390: LD_INT 46
25392: PUSH
25393: LD_INT 47
25395: PUSH
25396: EMPTY
25397: LIST
25398: LIST
25399: LIST
25400: IN
25401: IFFALSE 25418
// bpoints := bpoints * 1.2 ;
25403: LD_ADDR_VAR 0 10
25407: PUSH
25408: LD_VAR 0 10
25412: PUSH
25413: LD_REAL  1.20000000000000E+0000
25416: MUL
25417: ST_TO_ADDR
// end ; unit_building :
25418: GO 25432
25420: LD_INT 3
25422: DOUBLE
25423: EQUAL
25424: IFTRUE 25428
25426: GO 25431
25428: POP
// ; end ;
25429: GO 25432
25431: POP
// for j = 1 to 3 do
25432: LD_ADDR_VAR 0 7
25436: PUSH
25437: DOUBLE
25438: LD_INT 1
25440: DEC
25441: ST_TO_ADDR
25442: LD_INT 3
25444: PUSH
25445: FOR_TO
25446: IFFALSE 25499
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25448: LD_ADDR_VAR 0 5
25452: PUSH
25453: LD_VAR 0 5
25457: PPUSH
25458: LD_VAR 0 7
25462: PPUSH
25463: LD_VAR 0 5
25467: PUSH
25468: LD_VAR 0 7
25472: ARRAY
25473: PUSH
25474: LD_VAR 0 9
25478: PUSH
25479: LD_VAR 0 7
25483: ARRAY
25484: PUSH
25485: LD_VAR 0 10
25489: MUL
25490: PLUS
25491: PPUSH
25492: CALL_OW 1
25496: ST_TO_ADDR
25497: GO 25445
25499: POP
25500: POP
// end ;
25501: GO 23974
25503: POP
25504: POP
// result := Replace ( result , 4 , tmp ) ;
25505: LD_ADDR_VAR 0 5
25509: PUSH
25510: LD_VAR 0 5
25514: PPUSH
25515: LD_INT 4
25517: PPUSH
25518: LD_VAR 0 8
25522: PPUSH
25523: CALL_OW 1
25527: ST_TO_ADDR
// end ;
25528: LD_VAR 0 5
25532: RET
// export function DangerAtRange ( unit , range ) ; begin
25533: LD_INT 0
25535: PPUSH
// if not unit then
25536: LD_VAR 0 1
25540: NOT
25541: IFFALSE 25545
// exit ;
25543: GO 25590
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25545: LD_ADDR_VAR 0 3
25549: PUSH
25550: LD_VAR 0 1
25554: PPUSH
25555: CALL_OW 255
25559: PPUSH
25560: LD_VAR 0 1
25564: PPUSH
25565: CALL_OW 250
25569: PPUSH
25570: LD_VAR 0 1
25574: PPUSH
25575: CALL_OW 251
25579: PPUSH
25580: LD_VAR 0 2
25584: PPUSH
25585: CALL 23824 0 4
25589: ST_TO_ADDR
// end ;
25590: LD_VAR 0 3
25594: RET
// export function DangerInArea ( side , area ) ; begin
25595: LD_INT 0
25597: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25598: LD_ADDR_VAR 0 3
25602: PUSH
25603: LD_VAR 0 2
25607: PPUSH
25608: LD_INT 81
25610: PUSH
25611: LD_VAR 0 1
25615: PUSH
25616: EMPTY
25617: LIST
25618: LIST
25619: PPUSH
25620: CALL_OW 70
25624: ST_TO_ADDR
// end ;
25625: LD_VAR 0 3
25629: RET
// export function IsExtension ( b ) ; begin
25630: LD_INT 0
25632: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25633: LD_ADDR_VAR 0 2
25637: PUSH
25638: LD_VAR 0 1
25642: PUSH
25643: LD_INT 23
25645: PUSH
25646: LD_INT 20
25648: PUSH
25649: LD_INT 22
25651: PUSH
25652: LD_INT 17
25654: PUSH
25655: LD_INT 24
25657: PUSH
25658: LD_INT 21
25660: PUSH
25661: LD_INT 19
25663: PUSH
25664: LD_INT 16
25666: PUSH
25667: LD_INT 25
25669: PUSH
25670: LD_INT 18
25672: PUSH
25673: EMPTY
25674: LIST
25675: LIST
25676: LIST
25677: LIST
25678: LIST
25679: LIST
25680: LIST
25681: LIST
25682: LIST
25683: LIST
25684: IN
25685: ST_TO_ADDR
// end ;
25686: LD_VAR 0 2
25690: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25691: LD_INT 0
25693: PPUSH
25694: PPUSH
25695: PPUSH
// result := [ ] ;
25696: LD_ADDR_VAR 0 4
25700: PUSH
25701: EMPTY
25702: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25703: LD_ADDR_VAR 0 5
25707: PUSH
25708: LD_VAR 0 2
25712: PPUSH
25713: LD_INT 21
25715: PUSH
25716: LD_INT 3
25718: PUSH
25719: EMPTY
25720: LIST
25721: LIST
25722: PPUSH
25723: CALL_OW 70
25727: ST_TO_ADDR
// if not tmp then
25728: LD_VAR 0 5
25732: NOT
25733: IFFALSE 25737
// exit ;
25735: GO 25801
// if checkLink then
25737: LD_VAR 0 3
25741: IFFALSE 25791
// begin for i in tmp do
25743: LD_ADDR_VAR 0 6
25747: PUSH
25748: LD_VAR 0 5
25752: PUSH
25753: FOR_IN
25754: IFFALSE 25789
// if GetBase ( i ) <> base then
25756: LD_VAR 0 6
25760: PPUSH
25761: CALL_OW 274
25765: PUSH
25766: LD_VAR 0 1
25770: NONEQUAL
25771: IFFALSE 25787
// ComLinkToBase ( base , i ) ;
25773: LD_VAR 0 1
25777: PPUSH
25778: LD_VAR 0 6
25782: PPUSH
25783: CALL_OW 169
25787: GO 25753
25789: POP
25790: POP
// end ; result := tmp ;
25791: LD_ADDR_VAR 0 4
25795: PUSH
25796: LD_VAR 0 5
25800: ST_TO_ADDR
// end ;
25801: LD_VAR 0 4
25805: RET
// export function ComComplete ( units , b ) ; var i ; begin
25806: LD_INT 0
25808: PPUSH
25809: PPUSH
// if not units then
25810: LD_VAR 0 1
25814: NOT
25815: IFFALSE 25819
// exit ;
25817: GO 25909
// for i in units do
25819: LD_ADDR_VAR 0 4
25823: PUSH
25824: LD_VAR 0 1
25828: PUSH
25829: FOR_IN
25830: IFFALSE 25907
// if BuildingStatus ( b ) = bs_build then
25832: LD_VAR 0 2
25836: PPUSH
25837: CALL_OW 461
25841: PUSH
25842: LD_INT 1
25844: EQUAL
25845: IFFALSE 25905
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25847: LD_VAR 0 4
25851: PPUSH
25852: LD_STRING h
25854: PUSH
25855: LD_VAR 0 2
25859: PPUSH
25860: CALL_OW 250
25864: PUSH
25865: LD_VAR 0 2
25869: PPUSH
25870: CALL_OW 251
25874: PUSH
25875: LD_VAR 0 2
25879: PUSH
25880: LD_INT 0
25882: PUSH
25883: LD_INT 0
25885: PUSH
25886: LD_INT 0
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: LIST
25895: LIST
25896: LIST
25897: PUSH
25898: EMPTY
25899: LIST
25900: PPUSH
25901: CALL_OW 446
25905: GO 25829
25907: POP
25908: POP
// end ;
25909: LD_VAR 0 3
25913: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25914: LD_INT 0
25916: PPUSH
25917: PPUSH
25918: PPUSH
25919: PPUSH
25920: PPUSH
25921: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25922: LD_VAR 0 1
25926: NOT
25927: IFTRUE 25944
25929: PUSH
25930: LD_VAR 0 1
25934: PPUSH
25935: CALL_OW 263
25939: PUSH
25940: LD_INT 2
25942: NONEQUAL
25943: OR
25944: IFFALSE 25948
// exit ;
25946: GO 26264
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25948: LD_ADDR_VAR 0 6
25952: PUSH
25953: LD_INT 22
25955: PUSH
25956: LD_VAR 0 1
25960: PPUSH
25961: CALL_OW 255
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: PUSH
25970: LD_INT 2
25972: PUSH
25973: LD_INT 30
25975: PUSH
25976: LD_INT 36
25978: PUSH
25979: EMPTY
25980: LIST
25981: LIST
25982: PUSH
25983: LD_INT 34
25985: PUSH
25986: LD_INT 31
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PUSH
25993: EMPTY
25994: LIST
25995: LIST
25996: LIST
25997: PUSH
25998: EMPTY
25999: LIST
26000: LIST
26001: PPUSH
26002: CALL_OW 69
26006: ST_TO_ADDR
// if not tmp then
26007: LD_VAR 0 6
26011: NOT
26012: IFFALSE 26016
// exit ;
26014: GO 26264
// result := [ ] ;
26016: LD_ADDR_VAR 0 2
26020: PUSH
26021: EMPTY
26022: ST_TO_ADDR
// for i in tmp do
26023: LD_ADDR_VAR 0 3
26027: PUSH
26028: LD_VAR 0 6
26032: PUSH
26033: FOR_IN
26034: IFFALSE 26105
// begin t := UnitsInside ( i ) ;
26036: LD_ADDR_VAR 0 4
26040: PUSH
26041: LD_VAR 0 3
26045: PPUSH
26046: CALL_OW 313
26050: ST_TO_ADDR
// if t then
26051: LD_VAR 0 4
26055: IFFALSE 26103
// for j in t do
26057: LD_ADDR_VAR 0 7
26061: PUSH
26062: LD_VAR 0 4
26066: PUSH
26067: FOR_IN
26068: IFFALSE 26101
// result := Replace ( result , result + 1 , j ) ;
26070: LD_ADDR_VAR 0 2
26074: PUSH
26075: LD_VAR 0 2
26079: PPUSH
26080: LD_VAR 0 2
26084: PUSH
26085: LD_INT 1
26087: PLUS
26088: PPUSH
26089: LD_VAR 0 7
26093: PPUSH
26094: CALL_OW 1
26098: ST_TO_ADDR
26099: GO 26067
26101: POP
26102: POP
// end ;
26103: GO 26033
26105: POP
26106: POP
// if not result then
26107: LD_VAR 0 2
26111: NOT
26112: IFFALSE 26116
// exit ;
26114: GO 26264
// mech := result [ 1 ] ;
26116: LD_ADDR_VAR 0 5
26120: PUSH
26121: LD_VAR 0 2
26125: PUSH
26126: LD_INT 1
26128: ARRAY
26129: ST_TO_ADDR
// if result > 1 then
26130: LD_VAR 0 2
26134: PUSH
26135: LD_INT 1
26137: GREATER
26138: IFFALSE 26250
// begin for i = 2 to result do
26140: LD_ADDR_VAR 0 3
26144: PUSH
26145: DOUBLE
26146: LD_INT 2
26148: DEC
26149: ST_TO_ADDR
26150: LD_VAR 0 2
26154: PUSH
26155: FOR_TO
26156: IFFALSE 26248
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
26158: LD_ADDR_VAR 0 4
26162: PUSH
26163: LD_VAR 0 2
26167: PUSH
26168: LD_VAR 0 3
26172: ARRAY
26173: PPUSH
26174: LD_INT 3
26176: PPUSH
26177: CALL_OW 259
26181: PUSH
26182: LD_VAR 0 2
26186: PUSH
26187: LD_VAR 0 3
26191: ARRAY
26192: PPUSH
26193: CALL_OW 432
26197: MINUS
26198: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
26199: LD_VAR 0 4
26203: PUSH
26204: LD_VAR 0 5
26208: PPUSH
26209: LD_INT 3
26211: PPUSH
26212: CALL_OW 259
26216: PUSH
26217: LD_VAR 0 5
26221: PPUSH
26222: CALL_OW 432
26226: MINUS
26227: GREATEREQUAL
26228: IFFALSE 26246
// mech := result [ i ] ;
26230: LD_ADDR_VAR 0 5
26234: PUSH
26235: LD_VAR 0 2
26239: PUSH
26240: LD_VAR 0 3
26244: ARRAY
26245: ST_TO_ADDR
// end ;
26246: GO 26155
26248: POP
26249: POP
// end ; ComLinkTo ( vehicle , mech ) ;
26250: LD_VAR 0 1
26254: PPUSH
26255: LD_VAR 0 5
26259: PPUSH
26260: CALL_OW 135
// end ;
26264: LD_VAR 0 2
26268: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
26269: LD_INT 0
26271: PPUSH
26272: PPUSH
26273: PPUSH
26274: PPUSH
26275: PPUSH
26276: PPUSH
26277: PPUSH
26278: PPUSH
26279: PPUSH
26280: PPUSH
26281: PPUSH
26282: PPUSH
26283: PPUSH
// result := [ ] ;
26284: LD_ADDR_VAR 0 7
26288: PUSH
26289: EMPTY
26290: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
26291: LD_VAR 0 1
26295: PPUSH
26296: CALL_OW 266
26300: PUSH
26301: LD_INT 0
26303: PUSH
26304: LD_INT 1
26306: PUSH
26307: EMPTY
26308: LIST
26309: LIST
26310: IN
26311: NOT
26312: IFFALSE 26316
// exit ;
26314: GO 27956
// if name then
26316: LD_VAR 0 3
26320: IFFALSE 26336
// SetBName ( base_dep , name ) ;
26322: LD_VAR 0 1
26326: PPUSH
26327: LD_VAR 0 3
26331: PPUSH
26332: CALL_OW 500
// base := GetBase ( base_dep ) ;
26336: LD_ADDR_VAR 0 15
26340: PUSH
26341: LD_VAR 0 1
26345: PPUSH
26346: CALL_OW 274
26350: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26351: LD_ADDR_VAR 0 16
26355: PUSH
26356: LD_VAR 0 1
26360: PPUSH
26361: CALL_OW 255
26365: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26366: LD_ADDR_VAR 0 17
26370: PUSH
26371: LD_VAR 0 1
26375: PPUSH
26376: CALL_OW 248
26380: ST_TO_ADDR
// if sources then
26381: LD_VAR 0 5
26385: IFFALSE 26432
// for i = 1 to 3 do
26387: LD_ADDR_VAR 0 8
26391: PUSH
26392: DOUBLE
26393: LD_INT 1
26395: DEC
26396: ST_TO_ADDR
26397: LD_INT 3
26399: PUSH
26400: FOR_TO
26401: IFFALSE 26430
// AddResourceType ( base , i , sources [ i ] ) ;
26403: LD_VAR 0 15
26407: PPUSH
26408: LD_VAR 0 8
26412: PPUSH
26413: LD_VAR 0 5
26417: PUSH
26418: LD_VAR 0 8
26422: ARRAY
26423: PPUSH
26424: CALL_OW 276
26428: GO 26400
26430: POP
26431: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26432: LD_ADDR_VAR 0 18
26436: PUSH
26437: LD_VAR 0 15
26441: PPUSH
26442: LD_VAR 0 2
26446: PPUSH
26447: LD_INT 1
26449: PPUSH
26450: CALL 25691 0 3
26454: ST_TO_ADDR
// InitHc ;
26455: CALL_OW 19
// InitUc ;
26459: CALL_OW 18
// uc_side := side ;
26463: LD_ADDR_OWVAR 20
26467: PUSH
26468: LD_VAR 0 16
26472: ST_TO_ADDR
// uc_nation := nation ;
26473: LD_ADDR_OWVAR 21
26477: PUSH
26478: LD_VAR 0 17
26482: ST_TO_ADDR
// if buildings then
26483: LD_VAR 0 18
26487: IFFALSE 27815
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26489: LD_ADDR_VAR 0 19
26493: PUSH
26494: LD_VAR 0 18
26498: PPUSH
26499: LD_INT 2
26501: PUSH
26502: LD_INT 30
26504: PUSH
26505: LD_INT 29
26507: PUSH
26508: EMPTY
26509: LIST
26510: LIST
26511: PUSH
26512: LD_INT 30
26514: PUSH
26515: LD_INT 30
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: LIST
26526: PPUSH
26527: CALL_OW 72
26531: ST_TO_ADDR
// if tmp then
26532: LD_VAR 0 19
26536: IFFALSE 26584
// for i in tmp do
26538: LD_ADDR_VAR 0 8
26542: PUSH
26543: LD_VAR 0 19
26547: PUSH
26548: FOR_IN
26549: IFFALSE 26582
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26551: LD_VAR 0 8
26555: PPUSH
26556: CALL_OW 250
26560: PPUSH
26561: LD_VAR 0 8
26565: PPUSH
26566: CALL_OW 251
26570: PPUSH
26571: LD_VAR 0 16
26575: PPUSH
26576: CALL_OW 441
26580: GO 26548
26582: POP
26583: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26584: LD_VAR 0 18
26588: PPUSH
26589: LD_INT 2
26591: PUSH
26592: LD_INT 30
26594: PUSH
26595: LD_INT 32
26597: PUSH
26598: EMPTY
26599: LIST
26600: LIST
26601: PUSH
26602: LD_INT 30
26604: PUSH
26605: LD_INT 33
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: PUSH
26612: EMPTY
26613: LIST
26614: LIST
26615: LIST
26616: PPUSH
26617: CALL_OW 72
26621: IFFALSE 26709
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26623: LD_ADDR_VAR 0 8
26627: PUSH
26628: LD_VAR 0 18
26632: PPUSH
26633: LD_INT 2
26635: PUSH
26636: LD_INT 30
26638: PUSH
26639: LD_INT 32
26641: PUSH
26642: EMPTY
26643: LIST
26644: LIST
26645: PUSH
26646: LD_INT 30
26648: PUSH
26649: LD_INT 33
26651: PUSH
26652: EMPTY
26653: LIST
26654: LIST
26655: PUSH
26656: EMPTY
26657: LIST
26658: LIST
26659: LIST
26660: PPUSH
26661: CALL_OW 72
26665: PUSH
26666: FOR_IN
26667: IFFALSE 26707
// begin if not GetBWeapon ( i ) then
26669: LD_VAR 0 8
26673: PPUSH
26674: CALL_OW 269
26678: NOT
26679: IFFALSE 26705
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26681: LD_VAR 0 8
26685: PPUSH
26686: LD_VAR 0 8
26690: PPUSH
26691: LD_VAR 0 2
26695: PPUSH
26696: CALL 27961 0 2
26700: PPUSH
26701: CALL_OW 431
// end ;
26705: GO 26666
26707: POP
26708: POP
// end ; for i = 1 to personel do
26709: LD_ADDR_VAR 0 8
26713: PUSH
26714: DOUBLE
26715: LD_INT 1
26717: DEC
26718: ST_TO_ADDR
26719: LD_VAR 0 6
26723: PUSH
26724: FOR_TO
26725: IFFALSE 27795
// begin if i > 4 then
26727: LD_VAR 0 8
26731: PUSH
26732: LD_INT 4
26734: GREATER
26735: IFFALSE 26739
// break ;
26737: GO 27795
// case i of 1 :
26739: LD_VAR 0 8
26743: PUSH
26744: LD_INT 1
26746: DOUBLE
26747: EQUAL
26748: IFTRUE 26752
26750: GO 26832
26752: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26753: LD_ADDR_VAR 0 12
26757: PUSH
26758: LD_VAR 0 18
26762: PPUSH
26763: LD_INT 22
26765: PUSH
26766: LD_VAR 0 16
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: PUSH
26775: LD_INT 58
26777: PUSH
26778: EMPTY
26779: LIST
26780: PUSH
26781: LD_INT 2
26783: PUSH
26784: LD_INT 30
26786: PUSH
26787: LD_INT 32
26789: PUSH
26790: EMPTY
26791: LIST
26792: LIST
26793: PUSH
26794: LD_INT 30
26796: PUSH
26797: LD_INT 4
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: PUSH
26804: LD_INT 30
26806: PUSH
26807: LD_INT 5
26809: PUSH
26810: EMPTY
26811: LIST
26812: LIST
26813: PUSH
26814: EMPTY
26815: LIST
26816: LIST
26817: LIST
26818: LIST
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: LIST
26824: PPUSH
26825: CALL_OW 72
26829: ST_TO_ADDR
26830: GO 27054
26832: LD_INT 2
26834: DOUBLE
26835: EQUAL
26836: IFTRUE 26840
26838: GO 26902
26840: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26841: LD_ADDR_VAR 0 12
26845: PUSH
26846: LD_VAR 0 18
26850: PPUSH
26851: LD_INT 22
26853: PUSH
26854: LD_VAR 0 16
26858: PUSH
26859: EMPTY
26860: LIST
26861: LIST
26862: PUSH
26863: LD_INT 2
26865: PUSH
26866: LD_INT 30
26868: PUSH
26869: LD_INT 0
26871: PUSH
26872: EMPTY
26873: LIST
26874: LIST
26875: PUSH
26876: LD_INT 30
26878: PUSH
26879: LD_INT 1
26881: PUSH
26882: EMPTY
26883: LIST
26884: LIST
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: LIST
26890: PUSH
26891: EMPTY
26892: LIST
26893: LIST
26894: PPUSH
26895: CALL_OW 72
26899: ST_TO_ADDR
26900: GO 27054
26902: LD_INT 3
26904: DOUBLE
26905: EQUAL
26906: IFTRUE 26910
26908: GO 26972
26910: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26911: LD_ADDR_VAR 0 12
26915: PUSH
26916: LD_VAR 0 18
26920: PPUSH
26921: LD_INT 22
26923: PUSH
26924: LD_VAR 0 16
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: LD_INT 2
26935: PUSH
26936: LD_INT 30
26938: PUSH
26939: LD_INT 2
26941: PUSH
26942: EMPTY
26943: LIST
26944: LIST
26945: PUSH
26946: LD_INT 30
26948: PUSH
26949: LD_INT 3
26951: PUSH
26952: EMPTY
26953: LIST
26954: LIST
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: LIST
26960: PUSH
26961: EMPTY
26962: LIST
26963: LIST
26964: PPUSH
26965: CALL_OW 72
26969: ST_TO_ADDR
26970: GO 27054
26972: LD_INT 4
26974: DOUBLE
26975: EQUAL
26976: IFTRUE 26980
26978: GO 27053
26980: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26981: LD_ADDR_VAR 0 12
26985: PUSH
26986: LD_VAR 0 18
26990: PPUSH
26991: LD_INT 22
26993: PUSH
26994: LD_VAR 0 16
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 2
27005: PUSH
27006: LD_INT 30
27008: PUSH
27009: LD_INT 6
27011: PUSH
27012: EMPTY
27013: LIST
27014: LIST
27015: PUSH
27016: LD_INT 30
27018: PUSH
27019: LD_INT 7
27021: PUSH
27022: EMPTY
27023: LIST
27024: LIST
27025: PUSH
27026: LD_INT 30
27028: PUSH
27029: LD_INT 8
27031: PUSH
27032: EMPTY
27033: LIST
27034: LIST
27035: PUSH
27036: EMPTY
27037: LIST
27038: LIST
27039: LIST
27040: LIST
27041: PUSH
27042: EMPTY
27043: LIST
27044: LIST
27045: PPUSH
27046: CALL_OW 72
27050: ST_TO_ADDR
27051: GO 27054
27053: POP
// if i = 1 then
27054: LD_VAR 0 8
27058: PUSH
27059: LD_INT 1
27061: EQUAL
27062: IFFALSE 27173
// begin tmp := [ ] ;
27064: LD_ADDR_VAR 0 19
27068: PUSH
27069: EMPTY
27070: ST_TO_ADDR
// for j in f do
27071: LD_ADDR_VAR 0 9
27075: PUSH
27076: LD_VAR 0 12
27080: PUSH
27081: FOR_IN
27082: IFFALSE 27155
// if GetBType ( j ) = b_bunker then
27084: LD_VAR 0 9
27088: PPUSH
27089: CALL_OW 266
27093: PUSH
27094: LD_INT 32
27096: EQUAL
27097: IFFALSE 27124
// tmp := Insert ( tmp , 1 , j ) else
27099: LD_ADDR_VAR 0 19
27103: PUSH
27104: LD_VAR 0 19
27108: PPUSH
27109: LD_INT 1
27111: PPUSH
27112: LD_VAR 0 9
27116: PPUSH
27117: CALL_OW 2
27121: ST_TO_ADDR
27122: GO 27153
// tmp := Insert ( tmp , tmp + 1 , j ) ;
27124: LD_ADDR_VAR 0 19
27128: PUSH
27129: LD_VAR 0 19
27133: PPUSH
27134: LD_VAR 0 19
27138: PUSH
27139: LD_INT 1
27141: PLUS
27142: PPUSH
27143: LD_VAR 0 9
27147: PPUSH
27148: CALL_OW 2
27152: ST_TO_ADDR
27153: GO 27081
27155: POP
27156: POP
// if tmp then
27157: LD_VAR 0 19
27161: IFFALSE 27173
// f := tmp ;
27163: LD_ADDR_VAR 0 12
27167: PUSH
27168: LD_VAR 0 19
27172: ST_TO_ADDR
// end ; x := personel [ i ] ;
27173: LD_ADDR_VAR 0 13
27177: PUSH
27178: LD_VAR 0 6
27182: PUSH
27183: LD_VAR 0 8
27187: ARRAY
27188: ST_TO_ADDR
// if x = - 1 then
27189: LD_VAR 0 13
27193: PUSH
27194: LD_INT 1
27196: NEG
27197: EQUAL
27198: IFFALSE 27409
// begin for j in f do
27200: LD_ADDR_VAR 0 9
27204: PUSH
27205: LD_VAR 0 12
27209: PUSH
27210: FOR_IN
27211: IFFALSE 27405
// repeat InitHc ;
27213: CALL_OW 19
// if GetBType ( j ) = b_barracks then
27217: LD_VAR 0 9
27221: PPUSH
27222: CALL_OW 266
27226: PUSH
27227: LD_INT 5
27229: EQUAL
27230: IFFALSE 27300
// begin if UnitsInside ( j ) < 3 then
27232: LD_VAR 0 9
27236: PPUSH
27237: CALL_OW 313
27241: PUSH
27242: LD_INT 3
27244: LESS
27245: IFFALSE 27281
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27247: LD_INT 0
27249: PPUSH
27250: LD_INT 5
27252: PUSH
27253: LD_INT 8
27255: PUSH
27256: LD_INT 9
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: PUSH
27264: LD_VAR 0 17
27268: ARRAY
27269: PPUSH
27270: LD_VAR 0 4
27274: PPUSH
27275: CALL_OW 380
27279: GO 27298
// PrepareHuman ( false , i , skill ) ;
27281: LD_INT 0
27283: PPUSH
27284: LD_VAR 0 8
27288: PPUSH
27289: LD_VAR 0 4
27293: PPUSH
27294: CALL_OW 380
// end else
27298: GO 27317
// PrepareHuman ( false , i , skill ) ;
27300: LD_INT 0
27302: PPUSH
27303: LD_VAR 0 8
27307: PPUSH
27308: LD_VAR 0 4
27312: PPUSH
27313: CALL_OW 380
// un := CreateHuman ;
27317: LD_ADDR_VAR 0 14
27321: PUSH
27322: CALL_OW 44
27326: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27327: LD_ADDR_VAR 0 7
27331: PUSH
27332: LD_VAR 0 7
27336: PPUSH
27337: LD_INT 1
27339: PPUSH
27340: LD_VAR 0 14
27344: PPUSH
27345: CALL_OW 2
27349: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27350: LD_VAR 0 14
27354: PPUSH
27355: LD_VAR 0 9
27359: PPUSH
27360: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27364: LD_VAR 0 9
27368: PPUSH
27369: CALL_OW 313
27373: PUSH
27374: LD_INT 6
27376: EQUAL
27377: IFTRUE 27401
27379: PUSH
27380: LD_VAR 0 9
27384: PPUSH
27385: CALL_OW 266
27389: PUSH
27390: LD_INT 32
27392: PUSH
27393: LD_INT 31
27395: PUSH
27396: EMPTY
27397: LIST
27398: LIST
27399: IN
27400: OR
27401: IFFALSE 27213
27403: GO 27210
27405: POP
27406: POP
// end else
27407: GO 27793
// for j = 1 to x do
27409: LD_ADDR_VAR 0 9
27413: PUSH
27414: DOUBLE
27415: LD_INT 1
27417: DEC
27418: ST_TO_ADDR
27419: LD_VAR 0 13
27423: PUSH
27424: FOR_TO
27425: IFFALSE 27791
// begin InitHc ;
27427: CALL_OW 19
// if not f then
27431: LD_VAR 0 12
27435: NOT
27436: IFFALSE 27525
// begin PrepareHuman ( false , i , skill ) ;
27438: LD_INT 0
27440: PPUSH
27441: LD_VAR 0 8
27445: PPUSH
27446: LD_VAR 0 4
27450: PPUSH
27451: CALL_OW 380
// un := CreateHuman ;
27455: LD_ADDR_VAR 0 14
27459: PUSH
27460: CALL_OW 44
27464: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27465: LD_ADDR_VAR 0 7
27469: PUSH
27470: LD_VAR 0 7
27474: PPUSH
27475: LD_INT 1
27477: PPUSH
27478: LD_VAR 0 14
27482: PPUSH
27483: CALL_OW 2
27487: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27488: LD_VAR 0 14
27492: PPUSH
27493: LD_VAR 0 1
27497: PPUSH
27498: CALL_OW 250
27502: PPUSH
27503: LD_VAR 0 1
27507: PPUSH
27508: CALL_OW 251
27512: PPUSH
27513: LD_INT 10
27515: PPUSH
27516: LD_INT 0
27518: PPUSH
27519: CALL_OW 50
// continue ;
27523: GO 27424
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27525: LD_VAR 0 12
27529: PUSH
27530: LD_INT 1
27532: ARRAY
27533: PPUSH
27534: CALL_OW 313
27538: IFFALSE 27566
27540: PUSH
27541: LD_VAR 0 12
27545: PUSH
27546: LD_INT 1
27548: ARRAY
27549: PPUSH
27550: CALL_OW 266
27554: PUSH
27555: LD_INT 32
27557: PUSH
27558: LD_INT 31
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: IN
27565: AND
27566: IFTRUE 27587
27568: PUSH
27569: LD_VAR 0 12
27573: PUSH
27574: LD_INT 1
27576: ARRAY
27577: PPUSH
27578: CALL_OW 313
27582: PUSH
27583: LD_INT 6
27585: EQUAL
27586: OR
27587: IFFALSE 27607
// f := Delete ( f , 1 ) ;
27589: LD_ADDR_VAR 0 12
27593: PUSH
27594: LD_VAR 0 12
27598: PPUSH
27599: LD_INT 1
27601: PPUSH
27602: CALL_OW 3
27606: ST_TO_ADDR
// if not f then
27607: LD_VAR 0 12
27611: NOT
27612: IFFALSE 27630
// begin x := x + 2 ;
27614: LD_ADDR_VAR 0 13
27618: PUSH
27619: LD_VAR 0 13
27623: PUSH
27624: LD_INT 2
27626: PLUS
27627: ST_TO_ADDR
// continue ;
27628: GO 27424
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27630: LD_VAR 0 12
27634: PUSH
27635: LD_INT 1
27637: ARRAY
27638: PPUSH
27639: CALL_OW 266
27643: PUSH
27644: LD_INT 5
27646: EQUAL
27647: IFFALSE 27721
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27649: LD_VAR 0 12
27653: PUSH
27654: LD_INT 1
27656: ARRAY
27657: PPUSH
27658: CALL_OW 313
27662: PUSH
27663: LD_INT 3
27665: LESS
27666: IFFALSE 27702
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27668: LD_INT 0
27670: PPUSH
27671: LD_INT 5
27673: PUSH
27674: LD_INT 8
27676: PUSH
27677: LD_INT 9
27679: PUSH
27680: EMPTY
27681: LIST
27682: LIST
27683: LIST
27684: PUSH
27685: LD_VAR 0 17
27689: ARRAY
27690: PPUSH
27691: LD_VAR 0 4
27695: PPUSH
27696: CALL_OW 380
27700: GO 27719
// PrepareHuman ( false , i , skill ) ;
27702: LD_INT 0
27704: PPUSH
27705: LD_VAR 0 8
27709: PPUSH
27710: LD_VAR 0 4
27714: PPUSH
27715: CALL_OW 380
// end else
27719: GO 27738
// PrepareHuman ( false , i , skill ) ;
27721: LD_INT 0
27723: PPUSH
27724: LD_VAR 0 8
27728: PPUSH
27729: LD_VAR 0 4
27733: PPUSH
27734: CALL_OW 380
// un := CreateHuman ;
27738: LD_ADDR_VAR 0 14
27742: PUSH
27743: CALL_OW 44
27747: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27748: LD_ADDR_VAR 0 7
27752: PUSH
27753: LD_VAR 0 7
27757: PPUSH
27758: LD_INT 1
27760: PPUSH
27761: LD_VAR 0 14
27765: PPUSH
27766: CALL_OW 2
27770: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27771: LD_VAR 0 14
27775: PPUSH
27776: LD_VAR 0 12
27780: PUSH
27781: LD_INT 1
27783: ARRAY
27784: PPUSH
27785: CALL_OW 52
// end ;
27789: GO 27424
27791: POP
27792: POP
// end ;
27793: GO 26724
27795: POP
27796: POP
// result := result ^ buildings ;
27797: LD_ADDR_VAR 0 7
27801: PUSH
27802: LD_VAR 0 7
27806: PUSH
27807: LD_VAR 0 18
27811: ADD
27812: ST_TO_ADDR
// end else
27813: GO 27956
// begin for i = 1 to personel do
27815: LD_ADDR_VAR 0 8
27819: PUSH
27820: DOUBLE
27821: LD_INT 1
27823: DEC
27824: ST_TO_ADDR
27825: LD_VAR 0 6
27829: PUSH
27830: FOR_TO
27831: IFFALSE 27954
// begin if i > 4 then
27833: LD_VAR 0 8
27837: PUSH
27838: LD_INT 4
27840: GREATER
27841: IFFALSE 27845
// break ;
27843: GO 27954
// x := personel [ i ] ;
27845: LD_ADDR_VAR 0 13
27849: PUSH
27850: LD_VAR 0 6
27854: PUSH
27855: LD_VAR 0 8
27859: ARRAY
27860: ST_TO_ADDR
// if x = - 1 then
27861: LD_VAR 0 13
27865: PUSH
27866: LD_INT 1
27868: NEG
27869: EQUAL
27870: IFFALSE 27874
// continue ;
27872: GO 27830
// PrepareHuman ( false , i , skill ) ;
27874: LD_INT 0
27876: PPUSH
27877: LD_VAR 0 8
27881: PPUSH
27882: LD_VAR 0 4
27886: PPUSH
27887: CALL_OW 380
// un := CreateHuman ;
27891: LD_ADDR_VAR 0 14
27895: PUSH
27896: CALL_OW 44
27900: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27901: LD_VAR 0 14
27905: PPUSH
27906: LD_VAR 0 1
27910: PPUSH
27911: CALL_OW 250
27915: PPUSH
27916: LD_VAR 0 1
27920: PPUSH
27921: CALL_OW 251
27925: PPUSH
27926: LD_INT 10
27928: PPUSH
27929: LD_INT 0
27931: PPUSH
27932: CALL_OW 50
// result := result ^ un ;
27936: LD_ADDR_VAR 0 7
27940: PUSH
27941: LD_VAR 0 7
27945: PUSH
27946: LD_VAR 0 14
27950: ADD
27951: ST_TO_ADDR
// end ;
27952: GO 27830
27954: POP
27955: POP
// end ; end ;
27956: LD_VAR 0 7
27960: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27961: LD_INT 0
27963: PPUSH
27964: PPUSH
27965: PPUSH
27966: PPUSH
27967: PPUSH
27968: PPUSH
27969: PPUSH
27970: PPUSH
27971: PPUSH
27972: PPUSH
27973: PPUSH
27974: PPUSH
27975: PPUSH
27976: PPUSH
27977: PPUSH
27978: PPUSH
// result := false ;
27979: LD_ADDR_VAR 0 3
27983: PUSH
27984: LD_INT 0
27986: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27987: LD_VAR 0 1
27991: NOT
27992: IFTRUE 28017
27994: PUSH
27995: LD_VAR 0 1
27999: PPUSH
28000: CALL_OW 266
28004: PUSH
28005: LD_INT 32
28007: PUSH
28008: LD_INT 33
28010: PUSH
28011: EMPTY
28012: LIST
28013: LIST
28014: IN
28015: NOT
28016: OR
28017: IFFALSE 28021
// exit ;
28019: GO 29156
// nat := GetNation ( tower ) ;
28021: LD_ADDR_VAR 0 12
28025: PUSH
28026: LD_VAR 0 1
28030: PPUSH
28031: CALL_OW 248
28035: ST_TO_ADDR
// side := GetSide ( tower ) ;
28036: LD_ADDR_VAR 0 16
28040: PUSH
28041: LD_VAR 0 1
28045: PPUSH
28046: CALL_OW 255
28050: ST_TO_ADDR
// x := GetX ( tower ) ;
28051: LD_ADDR_VAR 0 10
28055: PUSH
28056: LD_VAR 0 1
28060: PPUSH
28061: CALL_OW 250
28065: ST_TO_ADDR
// y := GetY ( tower ) ;
28066: LD_ADDR_VAR 0 11
28070: PUSH
28071: LD_VAR 0 1
28075: PPUSH
28076: CALL_OW 251
28080: ST_TO_ADDR
// if not x or not y then
28081: LD_VAR 0 10
28085: NOT
28086: IFTRUE 28095
28088: PUSH
28089: LD_VAR 0 11
28093: NOT
28094: OR
28095: IFFALSE 28099
// exit ;
28097: GO 29156
// weapon := 0 ;
28099: LD_ADDR_VAR 0 18
28103: PUSH
28104: LD_INT 0
28106: ST_TO_ADDR
// fac_list := [ ] ;
28107: LD_ADDR_VAR 0 17
28111: PUSH
28112: EMPTY
28113: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
28114: LD_ADDR_VAR 0 6
28118: PUSH
28119: LD_VAR 0 1
28123: PPUSH
28124: CALL_OW 274
28128: PPUSH
28129: LD_VAR 0 2
28133: PPUSH
28134: LD_INT 0
28136: PPUSH
28137: CALL 25691 0 3
28141: PPUSH
28142: LD_INT 30
28144: PUSH
28145: LD_INT 3
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: PPUSH
28152: CALL_OW 72
28156: ST_TO_ADDR
// if not factories then
28157: LD_VAR 0 6
28161: NOT
28162: IFFALSE 28166
// exit ;
28164: GO 29156
// for i in factories do
28166: LD_ADDR_VAR 0 8
28170: PUSH
28171: LD_VAR 0 6
28175: PUSH
28176: FOR_IN
28177: IFFALSE 28202
// fac_list := fac_list union AvailableWeaponList ( i ) ;
28179: LD_ADDR_VAR 0 17
28183: PUSH
28184: LD_VAR 0 17
28188: PUSH
28189: LD_VAR 0 8
28193: PPUSH
28194: CALL_OW 478
28198: UNION
28199: ST_TO_ADDR
28200: GO 28176
28202: POP
28203: POP
// if not fac_list then
28204: LD_VAR 0 17
28208: NOT
28209: IFFALSE 28213
// exit ;
28211: GO 29156
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
28213: LD_ADDR_VAR 0 5
28217: PUSH
28218: LD_INT 4
28220: PUSH
28221: LD_INT 5
28223: PUSH
28224: LD_INT 9
28226: PUSH
28227: LD_INT 10
28229: PUSH
28230: LD_INT 6
28232: PUSH
28233: LD_INT 7
28235: PUSH
28236: LD_INT 11
28238: PUSH
28239: EMPTY
28240: LIST
28241: LIST
28242: LIST
28243: LIST
28244: LIST
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 27
28250: PUSH
28251: LD_INT 28
28253: PUSH
28254: LD_INT 26
28256: PUSH
28257: LD_INT 30
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: LIST
28264: LIST
28265: PUSH
28266: LD_INT 43
28268: PUSH
28269: LD_INT 44
28271: PUSH
28272: LD_INT 46
28274: PUSH
28275: LD_INT 45
28277: PUSH
28278: LD_INT 47
28280: PUSH
28281: LD_INT 49
28283: PUSH
28284: EMPTY
28285: LIST
28286: LIST
28287: LIST
28288: LIST
28289: LIST
28290: LIST
28291: PUSH
28292: EMPTY
28293: LIST
28294: LIST
28295: LIST
28296: PUSH
28297: LD_VAR 0 12
28301: ARRAY
28302: ST_TO_ADDR
// list := list isect fac_list ;
28303: LD_ADDR_VAR 0 5
28307: PUSH
28308: LD_VAR 0 5
28312: PUSH
28313: LD_VAR 0 17
28317: ISECT
28318: ST_TO_ADDR
// if not list then
28319: LD_VAR 0 5
28323: NOT
28324: IFFALSE 28328
// exit ;
28326: GO 29156
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
28328: LD_VAR 0 12
28332: PUSH
28333: LD_INT 3
28335: EQUAL
28336: IFFALSE 28348
28338: PUSH
28339: LD_INT 49
28341: PUSH
28342: LD_VAR 0 5
28346: IN
28347: AND
28348: IFFALSE 28368
28350: PUSH
28351: LD_INT 31
28353: PPUSH
28354: LD_VAR 0 16
28358: PPUSH
28359: CALL_OW 321
28363: PUSH
28364: LD_INT 2
28366: EQUAL
28367: AND
28368: IFFALSE 28428
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28370: LD_INT 22
28372: PUSH
28373: LD_VAR 0 16
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 35
28384: PUSH
28385: LD_INT 49
28387: PUSH
28388: EMPTY
28389: LIST
28390: LIST
28391: PUSH
28392: LD_INT 91
28394: PUSH
28395: LD_VAR 0 1
28399: PUSH
28400: LD_INT 10
28402: PUSH
28403: EMPTY
28404: LIST
28405: LIST
28406: LIST
28407: PUSH
28408: EMPTY
28409: LIST
28410: LIST
28411: LIST
28412: PPUSH
28413: CALL_OW 69
28417: NOT
28418: IFFALSE 28428
// weapon := ru_time_lapser ;
28420: LD_ADDR_VAR 0 18
28424: PUSH
28425: LD_INT 49
28427: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28428: LD_VAR 0 12
28432: PUSH
28433: LD_INT 1
28435: PUSH
28436: LD_INT 2
28438: PUSH
28439: EMPTY
28440: LIST
28441: LIST
28442: IN
28443: IFFALSE 28467
28445: PUSH
28446: LD_INT 11
28448: PUSH
28449: LD_VAR 0 5
28453: IN
28454: IFTRUE 28466
28456: PUSH
28457: LD_INT 30
28459: PUSH
28460: LD_VAR 0 5
28464: IN
28465: OR
28466: AND
28467: IFFALSE 28487
28469: PUSH
28470: LD_INT 6
28472: PPUSH
28473: LD_VAR 0 16
28477: PPUSH
28478: CALL_OW 321
28482: PUSH
28483: LD_INT 2
28485: EQUAL
28486: AND
28487: IFFALSE 28654
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28489: LD_INT 22
28491: PUSH
28492: LD_VAR 0 16
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: PUSH
28501: LD_INT 2
28503: PUSH
28504: LD_INT 35
28506: PUSH
28507: LD_INT 11
28509: PUSH
28510: EMPTY
28511: LIST
28512: LIST
28513: PUSH
28514: LD_INT 35
28516: PUSH
28517: LD_INT 30
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: LIST
28528: PUSH
28529: LD_INT 91
28531: PUSH
28532: LD_VAR 0 1
28536: PUSH
28537: LD_INT 18
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: LIST
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: LIST
28549: PPUSH
28550: CALL_OW 69
28554: NOT
28555: IFFALSE 28631
28557: PUSH
28558: LD_INT 22
28560: PUSH
28561: LD_VAR 0 16
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: PUSH
28570: LD_INT 2
28572: PUSH
28573: LD_INT 30
28575: PUSH
28576: LD_INT 32
28578: PUSH
28579: EMPTY
28580: LIST
28581: LIST
28582: PUSH
28583: LD_INT 30
28585: PUSH
28586: LD_INT 33
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: PUSH
28593: EMPTY
28594: LIST
28595: LIST
28596: LIST
28597: PUSH
28598: LD_INT 91
28600: PUSH
28601: LD_VAR 0 1
28605: PUSH
28606: LD_INT 12
28608: PUSH
28609: EMPTY
28610: LIST
28611: LIST
28612: LIST
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: LIST
28618: PUSH
28619: EMPTY
28620: LIST
28621: PPUSH
28622: CALL_OW 69
28626: PUSH
28627: LD_INT 2
28629: GREATER
28630: AND
28631: IFFALSE 28654
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28633: LD_ADDR_VAR 0 18
28637: PUSH
28638: LD_INT 11
28640: PUSH
28641: LD_INT 30
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: LD_VAR 0 12
28652: ARRAY
28653: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28654: LD_VAR 0 18
28658: NOT
28659: IFFALSE 28679
28661: PUSH
28662: LD_INT 40
28664: PPUSH
28665: LD_VAR 0 16
28669: PPUSH
28670: CALL_OW 321
28674: PUSH
28675: LD_INT 2
28677: EQUAL
28678: AND
28679: IFFALSE 28715
28681: PUSH
28682: LD_INT 7
28684: PUSH
28685: LD_VAR 0 5
28689: IN
28690: IFTRUE 28702
28692: PUSH
28693: LD_INT 28
28695: PUSH
28696: LD_VAR 0 5
28700: IN
28701: OR
28702: IFTRUE 28714
28704: PUSH
28705: LD_INT 45
28707: PUSH
28708: LD_VAR 0 5
28712: IN
28713: OR
28714: AND
28715: IFFALSE 28969
// begin hex := GetHexInfo ( x , y ) ;
28717: LD_ADDR_VAR 0 4
28721: PUSH
28722: LD_VAR 0 10
28726: PPUSH
28727: LD_VAR 0 11
28731: PPUSH
28732: CALL_OW 546
28736: ST_TO_ADDR
// if hex [ 1 ] then
28737: LD_VAR 0 4
28741: PUSH
28742: LD_INT 1
28744: ARRAY
28745: IFFALSE 28749
// exit ;
28747: GO 29156
// height := hex [ 2 ] ;
28749: LD_ADDR_VAR 0 15
28753: PUSH
28754: LD_VAR 0 4
28758: PUSH
28759: LD_INT 2
28761: ARRAY
28762: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28763: LD_ADDR_VAR 0 14
28767: PUSH
28768: LD_INT 0
28770: PUSH
28771: LD_INT 2
28773: PUSH
28774: LD_INT 3
28776: PUSH
28777: LD_INT 5
28779: PUSH
28780: EMPTY
28781: LIST
28782: LIST
28783: LIST
28784: LIST
28785: ST_TO_ADDR
// for i in tmp do
28786: LD_ADDR_VAR 0 8
28790: PUSH
28791: LD_VAR 0 14
28795: PUSH
28796: FOR_IN
28797: IFFALSE 28967
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28799: LD_ADDR_VAR 0 9
28803: PUSH
28804: LD_VAR 0 10
28808: PPUSH
28809: LD_VAR 0 8
28813: PPUSH
28814: LD_INT 5
28816: PPUSH
28817: CALL_OW 272
28821: PUSH
28822: LD_VAR 0 11
28826: PPUSH
28827: LD_VAR 0 8
28831: PPUSH
28832: LD_INT 5
28834: PPUSH
28835: CALL_OW 273
28839: PUSH
28840: EMPTY
28841: LIST
28842: LIST
28843: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28844: LD_VAR 0 9
28848: PUSH
28849: LD_INT 1
28851: ARRAY
28852: PPUSH
28853: LD_VAR 0 9
28857: PUSH
28858: LD_INT 2
28860: ARRAY
28861: PPUSH
28862: CALL_OW 488
28866: IFFALSE 28965
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28868: LD_ADDR_VAR 0 4
28872: PUSH
28873: LD_VAR 0 9
28877: PUSH
28878: LD_INT 1
28880: ARRAY
28881: PPUSH
28882: LD_VAR 0 9
28886: PUSH
28887: LD_INT 2
28889: ARRAY
28890: PPUSH
28891: CALL_OW 546
28895: ST_TO_ADDR
// if hex [ 1 ] then
28896: LD_VAR 0 4
28900: PUSH
28901: LD_INT 1
28903: ARRAY
28904: IFFALSE 28908
// continue ;
28906: GO 28796
// h := hex [ 2 ] ;
28908: LD_ADDR_VAR 0 13
28912: PUSH
28913: LD_VAR 0 4
28917: PUSH
28918: LD_INT 2
28920: ARRAY
28921: ST_TO_ADDR
// if h + 7 < height then
28922: LD_VAR 0 13
28926: PUSH
28927: LD_INT 7
28929: PLUS
28930: PUSH
28931: LD_VAR 0 15
28935: LESS
28936: IFFALSE 28965
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28938: LD_ADDR_VAR 0 18
28942: PUSH
28943: LD_INT 7
28945: PUSH
28946: LD_INT 28
28948: PUSH
28949: LD_INT 45
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: LIST
28956: PUSH
28957: LD_VAR 0 12
28961: ARRAY
28962: ST_TO_ADDR
// break ;
28963: GO 28967
// end ; end ; end ;
28965: GO 28796
28967: POP
28968: POP
// end ; if not weapon then
28969: LD_VAR 0 18
28973: NOT
28974: IFFALSE 29034
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28976: LD_ADDR_VAR 0 5
28980: PUSH
28981: LD_VAR 0 5
28985: PUSH
28986: LD_INT 11
28988: PUSH
28989: LD_INT 30
28991: PUSH
28992: LD_INT 49
28994: PUSH
28995: EMPTY
28996: LIST
28997: LIST
28998: LIST
28999: DIFF
29000: ST_TO_ADDR
// if not list then
29001: LD_VAR 0 5
29005: NOT
29006: IFFALSE 29010
// exit ;
29008: GO 29156
// weapon := list [ rand ( 1 , list ) ] ;
29010: LD_ADDR_VAR 0 18
29014: PUSH
29015: LD_VAR 0 5
29019: PUSH
29020: LD_INT 1
29022: PPUSH
29023: LD_VAR 0 5
29027: PPUSH
29028: CALL_OW 12
29032: ARRAY
29033: ST_TO_ADDR
// end ; if weapon then
29034: LD_VAR 0 18
29038: IFFALSE 29156
// begin tmp := CostOfWeapon ( weapon ) ;
29040: LD_ADDR_VAR 0 14
29044: PUSH
29045: LD_VAR 0 18
29049: PPUSH
29050: CALL_OW 451
29054: ST_TO_ADDR
// j := GetBase ( tower ) ;
29055: LD_ADDR_VAR 0 9
29059: PUSH
29060: LD_VAR 0 1
29064: PPUSH
29065: CALL_OW 274
29069: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
29070: LD_VAR 0 9
29074: PPUSH
29075: LD_INT 1
29077: PPUSH
29078: CALL_OW 275
29082: PUSH
29083: LD_VAR 0 14
29087: PUSH
29088: LD_INT 1
29090: ARRAY
29091: GREATEREQUAL
29092: IFFALSE 29118
29094: PUSH
29095: LD_VAR 0 9
29099: PPUSH
29100: LD_INT 2
29102: PPUSH
29103: CALL_OW 275
29107: PUSH
29108: LD_VAR 0 14
29112: PUSH
29113: LD_INT 2
29115: ARRAY
29116: GREATEREQUAL
29117: AND
29118: IFFALSE 29144
29120: PUSH
29121: LD_VAR 0 9
29125: PPUSH
29126: LD_INT 3
29128: PPUSH
29129: CALL_OW 275
29133: PUSH
29134: LD_VAR 0 14
29138: PUSH
29139: LD_INT 3
29141: ARRAY
29142: GREATEREQUAL
29143: AND
29144: IFFALSE 29156
// result := weapon ;
29146: LD_ADDR_VAR 0 3
29150: PUSH
29151: LD_VAR 0 18
29155: ST_TO_ADDR
// end ; end ;
29156: LD_VAR 0 3
29160: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
29161: LD_INT 0
29163: PPUSH
29164: PPUSH
// result := true ;
29165: LD_ADDR_VAR 0 3
29169: PUSH
29170: LD_INT 1
29172: ST_TO_ADDR
// if array1 = array2 then
29173: LD_VAR 0 1
29177: PUSH
29178: LD_VAR 0 2
29182: EQUAL
29183: IFFALSE 29243
// begin for i = 1 to array1 do
29185: LD_ADDR_VAR 0 4
29189: PUSH
29190: DOUBLE
29191: LD_INT 1
29193: DEC
29194: ST_TO_ADDR
29195: LD_VAR 0 1
29199: PUSH
29200: FOR_TO
29201: IFFALSE 29239
// if array1 [ i ] <> array2 [ i ] then
29203: LD_VAR 0 1
29207: PUSH
29208: LD_VAR 0 4
29212: ARRAY
29213: PUSH
29214: LD_VAR 0 2
29218: PUSH
29219: LD_VAR 0 4
29223: ARRAY
29224: NONEQUAL
29225: IFFALSE 29237
// begin result := false ;
29227: LD_ADDR_VAR 0 3
29231: PUSH
29232: LD_INT 0
29234: ST_TO_ADDR
// break ;
29235: GO 29239
// end ;
29237: GO 29200
29239: POP
29240: POP
// end else
29241: GO 29251
// result := false ;
29243: LD_ADDR_VAR 0 3
29247: PUSH
29248: LD_INT 0
29250: ST_TO_ADDR
// end ;
29251: LD_VAR 0 3
29255: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
29256: LD_INT 0
29258: PPUSH
29259: PPUSH
// if not array1 or not array2 then
29260: LD_VAR 0 1
29264: NOT
29265: IFTRUE 29274
29267: PUSH
29268: LD_VAR 0 2
29272: NOT
29273: OR
29274: IFFALSE 29278
// exit ;
29276: GO 29342
// result := true ;
29278: LD_ADDR_VAR 0 3
29282: PUSH
29283: LD_INT 1
29285: ST_TO_ADDR
// for i = 1 to array1 do
29286: LD_ADDR_VAR 0 4
29290: PUSH
29291: DOUBLE
29292: LD_INT 1
29294: DEC
29295: ST_TO_ADDR
29296: LD_VAR 0 1
29300: PUSH
29301: FOR_TO
29302: IFFALSE 29340
// if array1 [ i ] <> array2 [ i ] then
29304: LD_VAR 0 1
29308: PUSH
29309: LD_VAR 0 4
29313: ARRAY
29314: PUSH
29315: LD_VAR 0 2
29319: PUSH
29320: LD_VAR 0 4
29324: ARRAY
29325: NONEQUAL
29326: IFFALSE 29338
// begin result := false ;
29328: LD_ADDR_VAR 0 3
29332: PUSH
29333: LD_INT 0
29335: ST_TO_ADDR
// break ;
29336: GO 29340
// end ;
29338: GO 29301
29340: POP
29341: POP
// end ;
29342: LD_VAR 0 3
29346: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
29347: LD_INT 0
29349: PPUSH
29350: PPUSH
29351: PPUSH
// pom := GetBase ( fac ) ;
29352: LD_ADDR_VAR 0 5
29356: PUSH
29357: LD_VAR 0 1
29361: PPUSH
29362: CALL_OW 274
29366: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
29367: LD_ADDR_VAR 0 4
29371: PUSH
29372: LD_VAR 0 2
29376: PUSH
29377: LD_INT 1
29379: ARRAY
29380: PPUSH
29381: LD_VAR 0 2
29385: PUSH
29386: LD_INT 2
29388: ARRAY
29389: PPUSH
29390: LD_VAR 0 2
29394: PUSH
29395: LD_INT 3
29397: ARRAY
29398: PPUSH
29399: LD_VAR 0 2
29403: PUSH
29404: LD_INT 4
29406: ARRAY
29407: PPUSH
29408: CALL_OW 449
29412: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29413: LD_ADDR_VAR 0 3
29417: PUSH
29418: LD_VAR 0 5
29422: PPUSH
29423: LD_INT 1
29425: PPUSH
29426: CALL_OW 275
29430: PUSH
29431: LD_VAR 0 4
29435: PUSH
29436: LD_INT 1
29438: ARRAY
29439: GREATEREQUAL
29440: IFFALSE 29466
29442: PUSH
29443: LD_VAR 0 5
29447: PPUSH
29448: LD_INT 2
29450: PPUSH
29451: CALL_OW 275
29455: PUSH
29456: LD_VAR 0 4
29460: PUSH
29461: LD_INT 2
29463: ARRAY
29464: GREATEREQUAL
29465: AND
29466: IFFALSE 29492
29468: PUSH
29469: LD_VAR 0 5
29473: PPUSH
29474: LD_INT 3
29476: PPUSH
29477: CALL_OW 275
29481: PUSH
29482: LD_VAR 0 4
29486: PUSH
29487: LD_INT 3
29489: ARRAY
29490: GREATEREQUAL
29491: AND
29492: ST_TO_ADDR
// end ;
29493: LD_VAR 0 3
29497: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29498: LD_INT 0
29500: PPUSH
29501: PPUSH
29502: PPUSH
29503: PPUSH
// pom := GetBase ( building ) ;
29504: LD_ADDR_VAR 0 3
29508: PUSH
29509: LD_VAR 0 1
29513: PPUSH
29514: CALL_OW 274
29518: ST_TO_ADDR
// if not pom then
29519: LD_VAR 0 3
29523: NOT
29524: IFFALSE 29528
// exit ;
29526: GO 29702
// btype := GetBType ( building ) ;
29528: LD_ADDR_VAR 0 5
29532: PUSH
29533: LD_VAR 0 1
29537: PPUSH
29538: CALL_OW 266
29542: ST_TO_ADDR
// if btype = b_armoury then
29543: LD_VAR 0 5
29547: PUSH
29548: LD_INT 4
29550: EQUAL
29551: IFFALSE 29561
// btype := b_barracks ;
29553: LD_ADDR_VAR 0 5
29557: PUSH
29558: LD_INT 5
29560: ST_TO_ADDR
// if btype = b_depot then
29561: LD_VAR 0 5
29565: PUSH
29566: LD_INT 0
29568: EQUAL
29569: IFFALSE 29579
// btype := b_warehouse ;
29571: LD_ADDR_VAR 0 5
29575: PUSH
29576: LD_INT 1
29578: ST_TO_ADDR
// if btype = b_workshop then
29579: LD_VAR 0 5
29583: PUSH
29584: LD_INT 2
29586: EQUAL
29587: IFFALSE 29597
// btype := b_factory ;
29589: LD_ADDR_VAR 0 5
29593: PUSH
29594: LD_INT 3
29596: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29597: LD_ADDR_VAR 0 4
29601: PUSH
29602: LD_VAR 0 5
29606: PPUSH
29607: LD_VAR 0 1
29611: PPUSH
29612: CALL_OW 248
29616: PPUSH
29617: CALL_OW 450
29621: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29622: LD_ADDR_VAR 0 2
29626: PUSH
29627: LD_VAR 0 3
29631: PPUSH
29632: LD_INT 1
29634: PPUSH
29635: CALL_OW 275
29639: PUSH
29640: LD_VAR 0 4
29644: PUSH
29645: LD_INT 1
29647: ARRAY
29648: GREATEREQUAL
29649: IFFALSE 29675
29651: PUSH
29652: LD_VAR 0 3
29656: PPUSH
29657: LD_INT 2
29659: PPUSH
29660: CALL_OW 275
29664: PUSH
29665: LD_VAR 0 4
29669: PUSH
29670: LD_INT 2
29672: ARRAY
29673: GREATEREQUAL
29674: AND
29675: IFFALSE 29701
29677: PUSH
29678: LD_VAR 0 3
29682: PPUSH
29683: LD_INT 3
29685: PPUSH
29686: CALL_OW 275
29690: PUSH
29691: LD_VAR 0 4
29695: PUSH
29696: LD_INT 3
29698: ARRAY
29699: GREATEREQUAL
29700: AND
29701: ST_TO_ADDR
// end ;
29702: LD_VAR 0 2
29706: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29707: LD_INT 0
29709: PPUSH
29710: PPUSH
29711: PPUSH
// pom := GetBase ( building ) ;
29712: LD_ADDR_VAR 0 4
29716: PUSH
29717: LD_VAR 0 1
29721: PPUSH
29722: CALL_OW 274
29726: ST_TO_ADDR
// if not pom then
29727: LD_VAR 0 4
29731: NOT
29732: IFFALSE 29736
// exit ;
29734: GO 29841
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29736: LD_ADDR_VAR 0 5
29740: PUSH
29741: LD_VAR 0 2
29745: PPUSH
29746: LD_VAR 0 1
29750: PPUSH
29751: CALL_OW 248
29755: PPUSH
29756: CALL_OW 450
29760: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29761: LD_ADDR_VAR 0 3
29765: PUSH
29766: LD_VAR 0 4
29770: PPUSH
29771: LD_INT 1
29773: PPUSH
29774: CALL_OW 275
29778: PUSH
29779: LD_VAR 0 5
29783: PUSH
29784: LD_INT 1
29786: ARRAY
29787: GREATEREQUAL
29788: IFFALSE 29814
29790: PUSH
29791: LD_VAR 0 4
29795: PPUSH
29796: LD_INT 2
29798: PPUSH
29799: CALL_OW 275
29803: PUSH
29804: LD_VAR 0 5
29808: PUSH
29809: LD_INT 2
29811: ARRAY
29812: GREATEREQUAL
29813: AND
29814: IFFALSE 29840
29816: PUSH
29817: LD_VAR 0 4
29821: PPUSH
29822: LD_INT 3
29824: PPUSH
29825: CALL_OW 275
29829: PUSH
29830: LD_VAR 0 5
29834: PUSH
29835: LD_INT 3
29837: ARRAY
29838: GREATEREQUAL
29839: AND
29840: ST_TO_ADDR
// end ;
29841: LD_VAR 0 3
29845: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29846: LD_INT 0
29848: PPUSH
29849: PPUSH
29850: PPUSH
29851: PPUSH
29852: PPUSH
29853: PPUSH
29854: PPUSH
29855: PPUSH
29856: PPUSH
29857: PPUSH
29858: PPUSH
// result := false ;
29859: LD_ADDR_VAR 0 8
29863: PUSH
29864: LD_INT 0
29866: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29867: LD_VAR 0 5
29871: NOT
29872: IFTRUE 29881
29874: PUSH
29875: LD_VAR 0 1
29879: NOT
29880: OR
29881: IFTRUE 29890
29883: PUSH
29884: LD_VAR 0 2
29888: NOT
29889: OR
29890: IFTRUE 29899
29892: PUSH
29893: LD_VAR 0 3
29897: NOT
29898: OR
29899: IFFALSE 29903
// exit ;
29901: GO 30729
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29903: LD_ADDR_VAR 0 14
29907: PUSH
29908: LD_VAR 0 1
29912: PPUSH
29913: LD_VAR 0 2
29917: PPUSH
29918: LD_VAR 0 3
29922: PPUSH
29923: LD_VAR 0 4
29927: PPUSH
29928: LD_VAR 0 5
29932: PUSH
29933: LD_INT 1
29935: ARRAY
29936: PPUSH
29937: CALL_OW 248
29941: PPUSH
29942: LD_INT 0
29944: PPUSH
29945: CALL 32010 0 6
29949: ST_TO_ADDR
// if not hexes then
29950: LD_VAR 0 14
29954: NOT
29955: IFFALSE 29959
// exit ;
29957: GO 30729
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29959: LD_ADDR_VAR 0 17
29963: PUSH
29964: LD_VAR 0 5
29968: PPUSH
29969: LD_INT 22
29971: PUSH
29972: LD_VAR 0 13
29976: PPUSH
29977: CALL_OW 255
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 2
29988: PUSH
29989: LD_INT 30
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 30
30001: PUSH
30002: LD_INT 1
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: PUSH
30009: EMPTY
30010: LIST
30011: LIST
30012: LIST
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PPUSH
30018: CALL_OW 72
30022: ST_TO_ADDR
// for i = 1 to hexes do
30023: LD_ADDR_VAR 0 9
30027: PUSH
30028: DOUBLE
30029: LD_INT 1
30031: DEC
30032: ST_TO_ADDR
30033: LD_VAR 0 14
30037: PUSH
30038: FOR_TO
30039: IFFALSE 30727
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
30041: LD_ADDR_VAR 0 13
30045: PUSH
30046: LD_VAR 0 14
30050: PUSH
30051: LD_VAR 0 9
30055: ARRAY
30056: PUSH
30057: LD_INT 1
30059: ARRAY
30060: PPUSH
30061: LD_VAR 0 14
30065: PUSH
30066: LD_VAR 0 9
30070: ARRAY
30071: PUSH
30072: LD_INT 2
30074: ARRAY
30075: PPUSH
30076: CALL_OW 428
30080: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
30081: LD_VAR 0 14
30085: PUSH
30086: LD_VAR 0 9
30090: ARRAY
30091: PUSH
30092: LD_INT 1
30094: ARRAY
30095: PPUSH
30096: LD_VAR 0 14
30100: PUSH
30101: LD_VAR 0 9
30105: ARRAY
30106: PUSH
30107: LD_INT 2
30109: ARRAY
30110: PPUSH
30111: CALL_OW 351
30115: IFTRUE 30154
30117: PUSH
30118: LD_VAR 0 14
30122: PUSH
30123: LD_VAR 0 9
30127: ARRAY
30128: PUSH
30129: LD_INT 1
30131: ARRAY
30132: PPUSH
30133: LD_VAR 0 14
30137: PUSH
30138: LD_VAR 0 9
30142: ARRAY
30143: PUSH
30144: LD_INT 2
30146: ARRAY
30147: PPUSH
30148: CALL_OW 488
30152: NOT
30153: OR
30154: IFTRUE 30171
30156: PUSH
30157: LD_VAR 0 13
30161: PPUSH
30162: CALL_OW 247
30166: PUSH
30167: LD_INT 3
30169: EQUAL
30170: OR
30171: IFFALSE 30177
// exit ;
30173: POP
30174: POP
30175: GO 30729
// if not tmp then
30177: LD_VAR 0 13
30181: NOT
30182: IFFALSE 30186
// continue ;
30184: GO 30038
// result := true ;
30186: LD_ADDR_VAR 0 8
30190: PUSH
30191: LD_INT 1
30193: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
30194: LD_VAR 0 6
30198: IFFALSE 30215
30200: PUSH
30201: LD_VAR 0 13
30205: PPUSH
30206: CALL_OW 247
30210: PUSH
30211: LD_INT 2
30213: EQUAL
30214: AND
30215: IFFALSE 30232
30217: PUSH
30218: LD_VAR 0 13
30222: PPUSH
30223: CALL_OW 263
30227: PUSH
30228: LD_INT 1
30230: EQUAL
30231: AND
30232: IFFALSE 30396
// begin if IsDrivenBy ( tmp ) then
30234: LD_VAR 0 13
30238: PPUSH
30239: CALL_OW 311
30243: IFFALSE 30247
// continue ;
30245: GO 30038
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
30247: LD_VAR 0 6
30251: PPUSH
30252: LD_INT 3
30254: PUSH
30255: LD_INT 60
30257: PUSH
30258: EMPTY
30259: LIST
30260: PUSH
30261: EMPTY
30262: LIST
30263: LIST
30264: PUSH
30265: LD_INT 3
30267: PUSH
30268: LD_INT 55
30270: PUSH
30271: EMPTY
30272: LIST
30273: PUSH
30274: EMPTY
30275: LIST
30276: LIST
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: PPUSH
30282: CALL_OW 72
30286: IFFALSE 30394
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
30288: LD_ADDR_VAR 0 18
30292: PUSH
30293: LD_VAR 0 6
30297: PPUSH
30298: LD_INT 3
30300: PUSH
30301: LD_INT 60
30303: PUSH
30304: EMPTY
30305: LIST
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 3
30313: PUSH
30314: LD_INT 55
30316: PUSH
30317: EMPTY
30318: LIST
30319: PUSH
30320: EMPTY
30321: LIST
30322: LIST
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PPUSH
30328: CALL_OW 72
30332: PUSH
30333: LD_INT 1
30335: ARRAY
30336: ST_TO_ADDR
// if IsInUnit ( driver ) then
30337: LD_VAR 0 18
30341: PPUSH
30342: CALL_OW 310
30346: IFFALSE 30357
// ComExit ( driver ) ;
30348: LD_VAR 0 18
30352: PPUSH
30353: CALL 56010 0 1
// AddComEnterUnit ( driver , tmp ) ;
30357: LD_VAR 0 18
30361: PPUSH
30362: LD_VAR 0 13
30366: PPUSH
30367: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
30371: LD_VAR 0 18
30375: PPUSH
30376: LD_VAR 0 7
30380: PPUSH
30381: CALL_OW 173
// AddComExitVehicle ( driver ) ;
30385: LD_VAR 0 18
30389: PPUSH
30390: CALL_OW 181
// end ; continue ;
30394: GO 30038
// end ; if not cleaners or not tmp in cleaners then
30396: LD_VAR 0 6
30400: NOT
30401: IFTRUE 30416
30403: PUSH
30404: LD_VAR 0 13
30408: PUSH
30409: LD_VAR 0 6
30413: IN
30414: NOT
30415: OR
30416: IFFALSE 30725
// begin if dep then
30418: LD_VAR 0 17
30422: IFFALSE 30558
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30424: LD_ADDR_VAR 0 16
30428: PUSH
30429: LD_VAR 0 17
30433: PUSH
30434: LD_INT 1
30436: ARRAY
30437: PPUSH
30438: CALL_OW 250
30442: PPUSH
30443: LD_VAR 0 17
30447: PUSH
30448: LD_INT 1
30450: ARRAY
30451: PPUSH
30452: CALL_OW 254
30456: PPUSH
30457: LD_INT 5
30459: PPUSH
30460: CALL_OW 272
30464: PUSH
30465: LD_VAR 0 17
30469: PUSH
30470: LD_INT 1
30472: ARRAY
30473: PPUSH
30474: CALL_OW 251
30478: PPUSH
30479: LD_VAR 0 17
30483: PUSH
30484: LD_INT 1
30486: ARRAY
30487: PPUSH
30488: CALL_OW 254
30492: PPUSH
30493: LD_INT 5
30495: PPUSH
30496: CALL_OW 273
30500: PUSH
30501: EMPTY
30502: LIST
30503: LIST
30504: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30505: LD_VAR 0 16
30509: PUSH
30510: LD_INT 1
30512: ARRAY
30513: PPUSH
30514: LD_VAR 0 16
30518: PUSH
30519: LD_INT 2
30521: ARRAY
30522: PPUSH
30523: CALL_OW 488
30527: IFFALSE 30558
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30529: LD_VAR 0 13
30533: PPUSH
30534: LD_VAR 0 16
30538: PUSH
30539: LD_INT 1
30541: ARRAY
30542: PPUSH
30543: LD_VAR 0 16
30547: PUSH
30548: LD_INT 2
30550: ARRAY
30551: PPUSH
30552: CALL_OW 111
// continue ;
30556: GO 30038
// end ; end ; r := GetDir ( tmp ) ;
30558: LD_ADDR_VAR 0 15
30562: PUSH
30563: LD_VAR 0 13
30567: PPUSH
30568: CALL_OW 254
30572: ST_TO_ADDR
// if r = 5 then
30573: LD_VAR 0 15
30577: PUSH
30578: LD_INT 5
30580: EQUAL
30581: IFFALSE 30591
// r := 0 ;
30583: LD_ADDR_VAR 0 15
30587: PUSH
30588: LD_INT 0
30590: ST_TO_ADDR
// for j = r to 5 do
30591: LD_ADDR_VAR 0 10
30595: PUSH
30596: DOUBLE
30597: LD_VAR 0 15
30601: DEC
30602: ST_TO_ADDR
30603: LD_INT 5
30605: PUSH
30606: FOR_TO
30607: IFFALSE 30723
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30609: LD_ADDR_VAR 0 11
30613: PUSH
30614: LD_VAR 0 13
30618: PPUSH
30619: CALL_OW 250
30623: PPUSH
30624: LD_VAR 0 10
30628: PPUSH
30629: LD_INT 2
30631: PPUSH
30632: CALL_OW 272
30636: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30637: LD_ADDR_VAR 0 12
30641: PUSH
30642: LD_VAR 0 13
30646: PPUSH
30647: CALL_OW 251
30651: PPUSH
30652: LD_VAR 0 10
30656: PPUSH
30657: LD_INT 2
30659: PPUSH
30660: CALL_OW 273
30664: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30665: LD_VAR 0 11
30669: PPUSH
30670: LD_VAR 0 12
30674: PPUSH
30675: CALL_OW 488
30679: IFFALSE 30698
30681: PUSH
30682: LD_VAR 0 11
30686: PPUSH
30687: LD_VAR 0 12
30691: PPUSH
30692: CALL_OW 428
30696: NOT
30697: AND
30698: IFFALSE 30721
// begin ComMoveXY ( tmp , _x , _y ) ;
30700: LD_VAR 0 13
30704: PPUSH
30705: LD_VAR 0 11
30709: PPUSH
30710: LD_VAR 0 12
30714: PPUSH
30715: CALL_OW 111
// break ;
30719: GO 30723
// end ; end ;
30721: GO 30606
30723: POP
30724: POP
// end ; end ;
30725: GO 30038
30727: POP
30728: POP
// end ;
30729: LD_VAR 0 8
30733: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30734: LD_INT 0
30736: PPUSH
// result := true ;
30737: LD_ADDR_VAR 0 3
30741: PUSH
30742: LD_INT 1
30744: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30745: LD_VAR 0 2
30749: PUSH
30750: LD_INT 24
30752: DOUBLE
30753: EQUAL
30754: IFTRUE 30764
30756: LD_INT 33
30758: DOUBLE
30759: EQUAL
30760: IFTRUE 30764
30762: GO 30789
30764: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30765: LD_ADDR_VAR 0 3
30769: PUSH
30770: LD_INT 32
30772: PPUSH
30773: LD_VAR 0 1
30777: PPUSH
30778: CALL_OW 321
30782: PUSH
30783: LD_INT 2
30785: EQUAL
30786: ST_TO_ADDR
30787: GO 31105
30789: LD_INT 20
30791: DOUBLE
30792: EQUAL
30793: IFTRUE 30797
30795: GO 30822
30797: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30798: LD_ADDR_VAR 0 3
30802: PUSH
30803: LD_INT 6
30805: PPUSH
30806: LD_VAR 0 1
30810: PPUSH
30811: CALL_OW 321
30815: PUSH
30816: LD_INT 2
30818: EQUAL
30819: ST_TO_ADDR
30820: GO 31105
30822: LD_INT 22
30824: DOUBLE
30825: EQUAL
30826: IFTRUE 30836
30828: LD_INT 36
30830: DOUBLE
30831: EQUAL
30832: IFTRUE 30836
30834: GO 30861
30836: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30837: LD_ADDR_VAR 0 3
30841: PUSH
30842: LD_INT 15
30844: PPUSH
30845: LD_VAR 0 1
30849: PPUSH
30850: CALL_OW 321
30854: PUSH
30855: LD_INT 2
30857: EQUAL
30858: ST_TO_ADDR
30859: GO 31105
30861: LD_INT 30
30863: DOUBLE
30864: EQUAL
30865: IFTRUE 30869
30867: GO 30894
30869: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30870: LD_ADDR_VAR 0 3
30874: PUSH
30875: LD_INT 20
30877: PPUSH
30878: LD_VAR 0 1
30882: PPUSH
30883: CALL_OW 321
30887: PUSH
30888: LD_INT 2
30890: EQUAL
30891: ST_TO_ADDR
30892: GO 31105
30894: LD_INT 28
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30908
30900: LD_INT 21
30902: DOUBLE
30903: EQUAL
30904: IFTRUE 30908
30906: GO 30933
30908: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30909: LD_ADDR_VAR 0 3
30913: PUSH
30914: LD_INT 21
30916: PPUSH
30917: LD_VAR 0 1
30921: PPUSH
30922: CALL_OW 321
30926: PUSH
30927: LD_INT 2
30929: EQUAL
30930: ST_TO_ADDR
30931: GO 31105
30933: LD_INT 16
30935: DOUBLE
30936: EQUAL
30937: IFTRUE 30941
30939: GO 30966
30941: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30942: LD_ADDR_VAR 0 3
30946: PUSH
30947: LD_INT 84
30949: PPUSH
30950: LD_VAR 0 1
30954: PPUSH
30955: CALL_OW 321
30959: PUSH
30960: LD_INT 2
30962: EQUAL
30963: ST_TO_ADDR
30964: GO 31105
30966: LD_INT 19
30968: DOUBLE
30969: EQUAL
30970: IFTRUE 30980
30972: LD_INT 23
30974: DOUBLE
30975: EQUAL
30976: IFTRUE 30980
30978: GO 31005
30980: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30981: LD_ADDR_VAR 0 3
30985: PUSH
30986: LD_INT 83
30988: PPUSH
30989: LD_VAR 0 1
30993: PPUSH
30994: CALL_OW 321
30998: PUSH
30999: LD_INT 2
31001: EQUAL
31002: ST_TO_ADDR
31003: GO 31105
31005: LD_INT 17
31007: DOUBLE
31008: EQUAL
31009: IFTRUE 31013
31011: GO 31038
31013: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
31014: LD_ADDR_VAR 0 3
31018: PUSH
31019: LD_INT 39
31021: PPUSH
31022: LD_VAR 0 1
31026: PPUSH
31027: CALL_OW 321
31031: PUSH
31032: LD_INT 2
31034: EQUAL
31035: ST_TO_ADDR
31036: GO 31105
31038: LD_INT 18
31040: DOUBLE
31041: EQUAL
31042: IFTRUE 31046
31044: GO 31071
31046: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
31047: LD_ADDR_VAR 0 3
31051: PUSH
31052: LD_INT 40
31054: PPUSH
31055: LD_VAR 0 1
31059: PPUSH
31060: CALL_OW 321
31064: PUSH
31065: LD_INT 2
31067: EQUAL
31068: ST_TO_ADDR
31069: GO 31105
31071: LD_INT 27
31073: DOUBLE
31074: EQUAL
31075: IFTRUE 31079
31077: GO 31104
31079: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
31080: LD_ADDR_VAR 0 3
31084: PUSH
31085: LD_INT 35
31087: PPUSH
31088: LD_VAR 0 1
31092: PPUSH
31093: CALL_OW 321
31097: PUSH
31098: LD_INT 2
31100: EQUAL
31101: ST_TO_ADDR
31102: GO 31105
31104: POP
// end ;
31105: LD_VAR 0 3
31109: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
31110: LD_INT 0
31112: PPUSH
31113: PPUSH
31114: PPUSH
31115: PPUSH
31116: PPUSH
31117: PPUSH
31118: PPUSH
31119: PPUSH
31120: PPUSH
31121: PPUSH
31122: PPUSH
// result := false ;
31123: LD_ADDR_VAR 0 6
31127: PUSH
31128: LD_INT 0
31130: ST_TO_ADDR
// if btype = b_depot then
31131: LD_VAR 0 2
31135: PUSH
31136: LD_INT 0
31138: EQUAL
31139: IFFALSE 31151
// begin result := true ;
31141: LD_ADDR_VAR 0 6
31145: PUSH
31146: LD_INT 1
31148: ST_TO_ADDR
// exit ;
31149: GO 32005
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
31151: LD_VAR 0 1
31155: NOT
31156: IFTRUE 31181
31158: PUSH
31159: LD_VAR 0 1
31163: PPUSH
31164: CALL_OW 266
31168: PUSH
31169: LD_INT 0
31171: PUSH
31172: LD_INT 1
31174: PUSH
31175: EMPTY
31176: LIST
31177: LIST
31178: IN
31179: NOT
31180: OR
31181: IFTRUE 31190
31183: PUSH
31184: LD_VAR 0 2
31188: NOT
31189: OR
31190: IFTRUE 31226
31192: PUSH
31193: LD_VAR 0 5
31197: PUSH
31198: LD_INT 0
31200: PUSH
31201: LD_INT 1
31203: PUSH
31204: LD_INT 2
31206: PUSH
31207: LD_INT 3
31209: PUSH
31210: LD_INT 4
31212: PUSH
31213: LD_INT 5
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: IN
31224: NOT
31225: OR
31226: IFTRUE 31245
31228: PUSH
31229: LD_VAR 0 3
31233: PPUSH
31234: LD_VAR 0 4
31238: PPUSH
31239: CALL_OW 488
31243: NOT
31244: OR
31245: IFFALSE 31249
// exit ;
31247: GO 32005
// side := GetSide ( depot ) ;
31249: LD_ADDR_VAR 0 9
31253: PUSH
31254: LD_VAR 0 1
31258: PPUSH
31259: CALL_OW 255
31263: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
31264: LD_VAR 0 9
31268: PPUSH
31269: LD_VAR 0 2
31273: PPUSH
31274: CALL 30734 0 2
31278: NOT
31279: IFFALSE 31283
// exit ;
31281: GO 32005
// pom := GetBase ( depot ) ;
31283: LD_ADDR_VAR 0 10
31287: PUSH
31288: LD_VAR 0 1
31292: PPUSH
31293: CALL_OW 274
31297: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
31298: LD_ADDR_VAR 0 11
31302: PUSH
31303: LD_VAR 0 2
31307: PPUSH
31308: LD_VAR 0 1
31312: PPUSH
31313: CALL_OW 248
31317: PPUSH
31318: CALL_OW 450
31322: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31323: LD_VAR 0 10
31327: PPUSH
31328: LD_INT 1
31330: PPUSH
31331: CALL_OW 275
31335: PUSH
31336: LD_VAR 0 11
31340: PUSH
31341: LD_INT 1
31343: ARRAY
31344: GREATEREQUAL
31345: IFFALSE 31371
31347: PUSH
31348: LD_VAR 0 10
31352: PPUSH
31353: LD_INT 2
31355: PPUSH
31356: CALL_OW 275
31360: PUSH
31361: LD_VAR 0 11
31365: PUSH
31366: LD_INT 2
31368: ARRAY
31369: GREATEREQUAL
31370: AND
31371: IFFALSE 31397
31373: PUSH
31374: LD_VAR 0 10
31378: PPUSH
31379: LD_INT 3
31381: PPUSH
31382: CALL_OW 275
31386: PUSH
31387: LD_VAR 0 11
31391: PUSH
31392: LD_INT 3
31394: ARRAY
31395: GREATEREQUAL
31396: AND
31397: NOT
31398: IFFALSE 31402
// exit ;
31400: GO 32005
// if GetBType ( depot ) = b_depot then
31402: LD_VAR 0 1
31406: PPUSH
31407: CALL_OW 266
31411: PUSH
31412: LD_INT 0
31414: EQUAL
31415: IFFALSE 31427
// dist := 28 else
31417: LD_ADDR_VAR 0 14
31421: PUSH
31422: LD_INT 28
31424: ST_TO_ADDR
31425: GO 31435
// dist := 36 ;
31427: LD_ADDR_VAR 0 14
31431: PUSH
31432: LD_INT 36
31434: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31435: LD_VAR 0 1
31439: PPUSH
31440: LD_VAR 0 3
31444: PPUSH
31445: LD_VAR 0 4
31449: PPUSH
31450: CALL_OW 297
31454: PUSH
31455: LD_VAR 0 14
31459: GREATER
31460: IFFALSE 31464
// exit ;
31462: GO 32005
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31464: LD_ADDR_VAR 0 12
31468: PUSH
31469: LD_VAR 0 2
31473: PPUSH
31474: LD_VAR 0 3
31478: PPUSH
31479: LD_VAR 0 4
31483: PPUSH
31484: LD_VAR 0 5
31488: PPUSH
31489: LD_VAR 0 1
31493: PPUSH
31494: CALL_OW 248
31498: PPUSH
31499: LD_INT 0
31501: PPUSH
31502: CALL 32010 0 6
31506: ST_TO_ADDR
// if not hexes then
31507: LD_VAR 0 12
31511: NOT
31512: IFFALSE 31516
// exit ;
31514: GO 32005
// hex := GetHexInfo ( x , y ) ;
31516: LD_ADDR_VAR 0 15
31520: PUSH
31521: LD_VAR 0 3
31525: PPUSH
31526: LD_VAR 0 4
31530: PPUSH
31531: CALL_OW 546
31535: ST_TO_ADDR
// if hex [ 1 ] then
31536: LD_VAR 0 15
31540: PUSH
31541: LD_INT 1
31543: ARRAY
31544: IFFALSE 31548
// exit ;
31546: GO 32005
// height := hex [ 2 ] ;
31548: LD_ADDR_VAR 0 13
31552: PUSH
31553: LD_VAR 0 15
31557: PUSH
31558: LD_INT 2
31560: ARRAY
31561: ST_TO_ADDR
// for i = 1 to hexes do
31562: LD_ADDR_VAR 0 7
31566: PUSH
31567: DOUBLE
31568: LD_INT 1
31570: DEC
31571: ST_TO_ADDR
31572: LD_VAR 0 12
31576: PUSH
31577: FOR_TO
31578: IFFALSE 31922
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31580: LD_VAR 0 12
31584: PUSH
31585: LD_VAR 0 7
31589: ARRAY
31590: PUSH
31591: LD_INT 1
31593: ARRAY
31594: PPUSH
31595: LD_VAR 0 12
31599: PUSH
31600: LD_VAR 0 7
31604: ARRAY
31605: PUSH
31606: LD_INT 2
31608: ARRAY
31609: PPUSH
31610: CALL_OW 488
31614: NOT
31615: IFTRUE 31657
31617: PUSH
31618: LD_VAR 0 12
31622: PUSH
31623: LD_VAR 0 7
31627: ARRAY
31628: PUSH
31629: LD_INT 1
31631: ARRAY
31632: PPUSH
31633: LD_VAR 0 12
31637: PUSH
31638: LD_VAR 0 7
31642: ARRAY
31643: PUSH
31644: LD_INT 2
31646: ARRAY
31647: PPUSH
31648: CALL_OW 428
31652: PUSH
31653: LD_INT 0
31655: GREATER
31656: OR
31657: IFTRUE 31695
31659: PUSH
31660: LD_VAR 0 12
31664: PUSH
31665: LD_VAR 0 7
31669: ARRAY
31670: PUSH
31671: LD_INT 1
31673: ARRAY
31674: PPUSH
31675: LD_VAR 0 12
31679: PUSH
31680: LD_VAR 0 7
31684: ARRAY
31685: PUSH
31686: LD_INT 2
31688: ARRAY
31689: PPUSH
31690: CALL_OW 351
31694: OR
31695: IFFALSE 31701
// exit ;
31697: POP
31698: POP
31699: GO 32005
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31701: LD_ADDR_VAR 0 8
31705: PUSH
31706: LD_VAR 0 12
31710: PUSH
31711: LD_VAR 0 7
31715: ARRAY
31716: PUSH
31717: LD_INT 1
31719: ARRAY
31720: PPUSH
31721: LD_VAR 0 12
31725: PUSH
31726: LD_VAR 0 7
31730: ARRAY
31731: PUSH
31732: LD_INT 2
31734: ARRAY
31735: PPUSH
31736: CALL_OW 546
31740: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31741: LD_VAR 0 8
31745: PUSH
31746: LD_INT 1
31748: ARRAY
31749: IFTRUE 31771
31751: PUSH
31752: LD_VAR 0 8
31756: PUSH
31757: LD_INT 2
31759: ARRAY
31760: PUSH
31761: LD_VAR 0 13
31765: PUSH
31766: LD_INT 2
31768: PLUS
31769: GREATER
31770: OR
31771: IFTRUE 31793
31773: PUSH
31774: LD_VAR 0 8
31778: PUSH
31779: LD_INT 2
31781: ARRAY
31782: PUSH
31783: LD_VAR 0 13
31787: PUSH
31788: LD_INT 2
31790: MINUS
31791: LESS
31792: OR
31793: IFTRUE 31861
31795: PUSH
31796: LD_VAR 0 8
31800: PUSH
31801: LD_INT 3
31803: ARRAY
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: LD_INT 8
31810: PUSH
31811: LD_INT 9
31813: PUSH
31814: LD_INT 10
31816: PUSH
31817: LD_INT 11
31819: PUSH
31820: LD_INT 12
31822: PUSH
31823: LD_INT 13
31825: PUSH
31826: LD_INT 16
31828: PUSH
31829: LD_INT 17
31831: PUSH
31832: LD_INT 18
31834: PUSH
31835: LD_INT 19
31837: PUSH
31838: LD_INT 20
31840: PUSH
31841: LD_INT 21
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: LIST
31848: LIST
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: IN
31859: NOT
31860: OR
31861: IFTRUE 31874
31863: PUSH
31864: LD_VAR 0 8
31868: PUSH
31869: LD_INT 5
31871: ARRAY
31872: NOT
31873: OR
31874: IFTRUE 31914
31876: PUSH
31877: LD_VAR 0 8
31881: PUSH
31882: LD_INT 6
31884: ARRAY
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 2
31891: PUSH
31892: LD_INT 7
31894: PUSH
31895: LD_INT 9
31897: PUSH
31898: LD_INT 10
31900: PUSH
31901: LD_INT 11
31903: PUSH
31904: EMPTY
31905: LIST
31906: LIST
31907: LIST
31908: LIST
31909: LIST
31910: LIST
31911: IN
31912: NOT
31913: OR
31914: IFFALSE 31920
// exit ;
31916: POP
31917: POP
31918: GO 32005
// end ;
31920: GO 31577
31922: POP
31923: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31924: LD_VAR 0 9
31928: PPUSH
31929: LD_VAR 0 3
31933: PPUSH
31934: LD_VAR 0 4
31938: PPUSH
31939: LD_INT 20
31941: PPUSH
31942: CALL 23824 0 4
31946: PUSH
31947: LD_INT 4
31949: ARRAY
31950: IFFALSE 31954
// exit ;
31952: GO 32005
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31954: LD_VAR 0 2
31958: PUSH
31959: LD_INT 29
31961: PUSH
31962: LD_INT 30
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: IN
31969: IFFALSE 31993
31971: PUSH
31972: LD_VAR 0 3
31976: PPUSH
31977: LD_VAR 0 4
31981: PPUSH
31982: LD_VAR 0 9
31986: PPUSH
31987: CALL_OW 440
31991: NOT
31992: AND
31993: IFFALSE 31997
// exit ;
31995: GO 32005
// result := true ;
31997: LD_ADDR_VAR 0 6
32001: PUSH
32002: LD_INT 1
32004: ST_TO_ADDR
// end ;
32005: LD_VAR 0 6
32009: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
32010: LD_INT 0
32012: PPUSH
32013: PPUSH
32014: PPUSH
32015: PPUSH
32016: PPUSH
32017: PPUSH
32018: PPUSH
32019: PPUSH
32020: PPUSH
32021: PPUSH
32022: PPUSH
32023: PPUSH
32024: PPUSH
32025: PPUSH
32026: PPUSH
32027: PPUSH
32028: PPUSH
32029: PPUSH
32030: PPUSH
32031: PPUSH
32032: PPUSH
32033: PPUSH
32034: PPUSH
32035: PPUSH
32036: PPUSH
32037: PPUSH
32038: PPUSH
32039: PPUSH
32040: PPUSH
32041: PPUSH
32042: PPUSH
32043: PPUSH
32044: PPUSH
32045: PPUSH
32046: PPUSH
32047: PPUSH
32048: PPUSH
32049: PPUSH
32050: PPUSH
32051: PPUSH
32052: PPUSH
32053: PPUSH
32054: PPUSH
32055: PPUSH
32056: PPUSH
32057: PPUSH
32058: PPUSH
32059: PPUSH
32060: PPUSH
32061: PPUSH
32062: PPUSH
32063: PPUSH
32064: PPUSH
32065: PPUSH
32066: PPUSH
32067: PPUSH
32068: PPUSH
32069: PPUSH
// result = [ ] ;
32070: LD_ADDR_VAR 0 7
32074: PUSH
32075: EMPTY
32076: ST_TO_ADDR
// temp_list = [ ] ;
32077: LD_ADDR_VAR 0 9
32081: PUSH
32082: EMPTY
32083: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
32084: LD_VAR 0 4
32088: PUSH
32089: LD_INT 0
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 2
32097: PUSH
32098: LD_INT 3
32100: PUSH
32101: LD_INT 4
32103: PUSH
32104: LD_INT 5
32106: PUSH
32107: EMPTY
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: IN
32115: NOT
32116: IFTRUE 32159
32118: PUSH
32119: LD_VAR 0 1
32123: PUSH
32124: LD_INT 0
32126: PUSH
32127: LD_INT 1
32129: PUSH
32130: EMPTY
32131: LIST
32132: LIST
32133: IN
32134: IFFALSE 32158
32136: PUSH
32137: LD_VAR 0 5
32141: PUSH
32142: LD_INT 1
32144: PUSH
32145: LD_INT 2
32147: PUSH
32148: LD_INT 3
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: LIST
32155: IN
32156: NOT
32157: AND
32158: OR
32159: IFFALSE 32163
// exit ;
32161: GO 50562
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
32163: LD_VAR 0 1
32167: PUSH
32168: LD_INT 6
32170: PUSH
32171: LD_INT 7
32173: PUSH
32174: LD_INT 8
32176: PUSH
32177: LD_INT 13
32179: PUSH
32180: LD_INT 12
32182: PUSH
32183: LD_INT 15
32185: PUSH
32186: LD_INT 11
32188: PUSH
32189: LD_INT 14
32191: PUSH
32192: LD_INT 10
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: LIST
32199: LIST
32200: LIST
32201: LIST
32202: LIST
32203: LIST
32204: LIST
32205: IN
32206: IFFALSE 32216
// btype = b_lab ;
32208: LD_ADDR_VAR 0 1
32212: PUSH
32213: LD_INT 6
32215: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
32216: LD_VAR 0 6
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: LD_INT 1
32226: PUSH
32227: LD_INT 2
32229: PUSH
32230: EMPTY
32231: LIST
32232: LIST
32233: LIST
32234: IN
32235: NOT
32236: IFTRUE 32304
32238: PUSH
32239: LD_VAR 0 1
32243: PUSH
32244: LD_INT 0
32246: PUSH
32247: LD_INT 1
32249: PUSH
32250: LD_INT 2
32252: PUSH
32253: LD_INT 3
32255: PUSH
32256: LD_INT 6
32258: PUSH
32259: LD_INT 36
32261: PUSH
32262: LD_INT 4
32264: PUSH
32265: LD_INT 5
32267: PUSH
32268: LD_INT 31
32270: PUSH
32271: LD_INT 32
32273: PUSH
32274: LD_INT 33
32276: PUSH
32277: EMPTY
32278: LIST
32279: LIST
32280: LIST
32281: LIST
32282: LIST
32283: LIST
32284: LIST
32285: LIST
32286: LIST
32287: LIST
32288: LIST
32289: IN
32290: NOT
32291: IFFALSE 32303
32293: PUSH
32294: LD_VAR 0 6
32298: PUSH
32299: LD_INT 1
32301: EQUAL
32302: AND
32303: OR
32304: IFTRUE 32336
32306: PUSH
32307: LD_VAR 0 1
32311: PUSH
32312: LD_INT 2
32314: PUSH
32315: LD_INT 3
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: IN
32322: NOT
32323: IFFALSE 32335
32325: PUSH
32326: LD_VAR 0 6
32330: PUSH
32331: LD_INT 2
32333: EQUAL
32334: AND
32335: OR
32336: IFFALSE 32346
// mode = 0 ;
32338: LD_ADDR_VAR 0 6
32342: PUSH
32343: LD_INT 0
32345: ST_TO_ADDR
// case mode of 0 :
32346: LD_VAR 0 6
32350: PUSH
32351: LD_INT 0
32353: DOUBLE
32354: EQUAL
32355: IFTRUE 32359
32357: GO 43812
32359: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32360: LD_ADDR_VAR 0 11
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: LD_INT 0
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: NEG
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 1
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: PUSH
32399: LD_INT 1
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 0
32408: PUSH
32409: LD_INT 1
32411: PUSH
32412: EMPTY
32413: LIST
32414: LIST
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: LD_INT 0
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 1
32429: NEG
32430: PUSH
32431: LD_INT 1
32433: NEG
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: NEG
32442: PUSH
32443: LD_INT 2
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 0
32453: PUSH
32454: LD_INT 2
32456: NEG
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: PUSH
32465: LD_INT 1
32467: NEG
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: PUSH
32476: LD_INT 2
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 0
32485: PUSH
32486: LD_INT 2
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 1
32495: NEG
32496: PUSH
32497: LD_INT 1
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: LD_INT 3
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 0
32516: PUSH
32517: LD_INT 3
32519: PUSH
32520: EMPTY
32521: LIST
32522: LIST
32523: PUSH
32524: LD_INT 1
32526: NEG
32527: PUSH
32528: LD_INT 2
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: EMPTY
32536: LIST
32537: LIST
32538: LIST
32539: LIST
32540: LIST
32541: LIST
32542: LIST
32543: LIST
32544: LIST
32545: LIST
32546: LIST
32547: LIST
32548: LIST
32549: LIST
32550: LIST
32551: LIST
32552: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32553: LD_ADDR_VAR 0 12
32557: PUSH
32558: LD_INT 0
32560: PUSH
32561: LD_INT 0
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: PUSH
32568: LD_INT 0
32570: PUSH
32571: LD_INT 1
32573: NEG
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: LD_INT 0
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: LD_INT 1
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: LD_INT 1
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 1
32611: NEG
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 1
32622: NEG
32623: PUSH
32624: LD_INT 1
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 1
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: LD_INT 1
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 2
32676: NEG
32677: PUSH
32678: LD_INT 0
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 2
32687: NEG
32688: PUSH
32689: LD_INT 1
32691: NEG
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: LD_INT 2
32699: NEG
32700: PUSH
32701: LD_INT 1
32703: PUSH
32704: EMPTY
32705: LIST
32706: LIST
32707: PUSH
32708: LD_INT 3
32710: NEG
32711: PUSH
32712: LD_INT 0
32714: PUSH
32715: EMPTY
32716: LIST
32717: LIST
32718: PUSH
32719: LD_INT 3
32721: NEG
32722: PUSH
32723: LD_INT 1
32725: NEG
32726: PUSH
32727: EMPTY
32728: LIST
32729: LIST
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32749: LD_ADDR_VAR 0 13
32753: PUSH
32754: LD_INT 0
32756: PUSH
32757: LD_INT 0
32759: PUSH
32760: EMPTY
32761: LIST
32762: LIST
32763: PUSH
32764: LD_INT 0
32766: PUSH
32767: LD_INT 1
32769: NEG
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 0
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 1
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 0
32797: PUSH
32798: LD_INT 1
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 1
32807: NEG
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 1
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: LD_INT 2
32834: NEG
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 2
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 2
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 1
32862: PUSH
32863: LD_INT 2
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: NEG
32873: PUSH
32874: LD_INT 1
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 2
32884: NEG
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: EMPTY
32891: LIST
32892: LIST
32893: PUSH
32894: LD_INT 2
32896: NEG
32897: PUSH
32898: LD_INT 3
32900: NEG
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 3
32908: NEG
32909: PUSH
32910: LD_INT 2
32912: NEG
32913: PUSH
32914: EMPTY
32915: LIST
32916: LIST
32917: PUSH
32918: LD_INT 3
32920: NEG
32921: PUSH
32922: LD_INT 3
32924: NEG
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32948: LD_ADDR_VAR 0 14
32952: PUSH
32953: LD_INT 0
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 0
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: LD_INT 0
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 1
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 0
32996: PUSH
32997: LD_INT 1
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 1
33006: NEG
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 1
33017: NEG
33018: PUSH
33019: LD_INT 1
33021: NEG
33022: PUSH
33023: EMPTY
33024: LIST
33025: LIST
33026: PUSH
33027: LD_INT 1
33029: NEG
33030: PUSH
33031: LD_INT 2
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 0
33041: PUSH
33042: LD_INT 2
33044: NEG
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 1
33052: PUSH
33053: LD_INT 1
33055: NEG
33056: PUSH
33057: EMPTY
33058: LIST
33059: LIST
33060: PUSH
33061: LD_INT 1
33063: PUSH
33064: LD_INT 2
33066: PUSH
33067: EMPTY
33068: LIST
33069: LIST
33070: PUSH
33071: LD_INT 0
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 1
33083: NEG
33084: PUSH
33085: LD_INT 1
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: NEG
33095: PUSH
33096: LD_INT 3
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: LD_INT 3
33109: NEG
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: LD_INT 2
33120: NEG
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: EMPTY
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
33144: LD_ADDR_VAR 0 15
33148: PUSH
33149: LD_INT 0
33151: PUSH
33152: LD_INT 0
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 1
33164: NEG
33165: PUSH
33166: EMPTY
33167: LIST
33168: LIST
33169: PUSH
33170: LD_INT 1
33172: PUSH
33173: LD_INT 0
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 1
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 1
33202: NEG
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: NEG
33214: PUSH
33215: LD_INT 1
33217: NEG
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: LD_INT 1
33228: NEG
33229: PUSH
33230: EMPTY
33231: LIST
33232: LIST
33233: PUSH
33234: LD_INT 2
33236: PUSH
33237: LD_INT 0
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 2
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 1
33256: NEG
33257: PUSH
33258: LD_INT 1
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: LD_INT 0
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 2
33278: NEG
33279: PUSH
33280: LD_INT 1
33282: NEG
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: LD_INT 1
33293: NEG
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 3
33301: PUSH
33302: LD_INT 0
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 3
33311: PUSH
33312: LD_INT 1
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: LIST
33323: LIST
33324: LIST
33325: LIST
33326: LIST
33327: LIST
33328: LIST
33329: LIST
33330: LIST
33331: LIST
33332: LIST
33333: LIST
33334: LIST
33335: LIST
33336: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
33337: LD_ADDR_VAR 0 16
33341: PUSH
33342: LD_INT 0
33344: PUSH
33345: LD_INT 0
33347: PUSH
33348: EMPTY
33349: LIST
33350: LIST
33351: PUSH
33352: LD_INT 0
33354: PUSH
33355: LD_INT 1
33357: NEG
33358: PUSH
33359: EMPTY
33360: LIST
33361: LIST
33362: PUSH
33363: LD_INT 1
33365: PUSH
33366: LD_INT 0
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 1
33375: PUSH
33376: LD_INT 1
33378: PUSH
33379: EMPTY
33380: LIST
33381: LIST
33382: PUSH
33383: LD_INT 0
33385: PUSH
33386: LD_INT 1
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: PUSH
33393: LD_INT 1
33395: NEG
33396: PUSH
33397: LD_INT 0
33399: PUSH
33400: EMPTY
33401: LIST
33402: LIST
33403: PUSH
33404: LD_INT 1
33406: NEG
33407: PUSH
33408: LD_INT 1
33410: NEG
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: NEG
33419: PUSH
33420: LD_INT 2
33422: NEG
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 2
33430: PUSH
33431: LD_INT 1
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 2
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 1
33450: PUSH
33451: LD_INT 2
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 2
33460: NEG
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: EMPTY
33467: LIST
33468: LIST
33469: PUSH
33470: LD_INT 2
33472: NEG
33473: PUSH
33474: LD_INT 2
33476: NEG
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 3
33484: PUSH
33485: LD_INT 2
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 3
33494: PUSH
33495: LD_INT 3
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 2
33504: PUSH
33505: LD_INT 3
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: EMPTY
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: LIST
33518: LIST
33519: LIST
33520: LIST
33521: LIST
33522: LIST
33523: LIST
33524: LIST
33525: LIST
33526: LIST
33527: LIST
33528: LIST
33529: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33530: LD_ADDR_VAR 0 17
33534: PUSH
33535: LD_INT 0
33537: PUSH
33538: LD_INT 0
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 0
33547: PUSH
33548: LD_INT 1
33550: NEG
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 1
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: LD_INT 1
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 0
33578: PUSH
33579: LD_INT 1
33581: PUSH
33582: EMPTY
33583: LIST
33584: LIST
33585: PUSH
33586: LD_INT 1
33588: NEG
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: NEG
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 1
33611: NEG
33612: PUSH
33613: LD_INT 2
33615: NEG
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: LD_INT 2
33626: NEG
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 1
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: EMPTY
33640: LIST
33641: LIST
33642: PUSH
33643: LD_INT 2
33645: PUSH
33646: LD_INT 0
33648: PUSH
33649: EMPTY
33650: LIST
33651: LIST
33652: PUSH
33653: LD_INT 2
33655: PUSH
33656: LD_INT 1
33658: PUSH
33659: EMPTY
33660: LIST
33661: LIST
33662: PUSH
33663: LD_INT 2
33665: PUSH
33666: LD_INT 2
33668: PUSH
33669: EMPTY
33670: LIST
33671: LIST
33672: PUSH
33673: LD_INT 1
33675: PUSH
33676: LD_INT 2
33678: PUSH
33679: EMPTY
33680: LIST
33681: LIST
33682: PUSH
33683: LD_INT 0
33685: PUSH
33686: LD_INT 2
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: NEG
33696: PUSH
33697: LD_INT 1
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 2
33706: NEG
33707: PUSH
33708: LD_INT 0
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 2
33717: NEG
33718: PUSH
33719: LD_INT 1
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 2
33729: NEG
33730: PUSH
33731: LD_INT 2
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: EMPTY
33740: LIST
33741: LIST
33742: LIST
33743: LIST
33744: LIST
33745: LIST
33746: LIST
33747: LIST
33748: LIST
33749: LIST
33750: LIST
33751: LIST
33752: LIST
33753: LIST
33754: LIST
33755: LIST
33756: LIST
33757: LIST
33758: LIST
33759: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33760: LD_ADDR_VAR 0 18
33764: PUSH
33765: LD_INT 0
33767: PUSH
33768: LD_INT 0
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 1
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: LD_INT 1
33811: PUSH
33812: EMPTY
33813: LIST
33814: LIST
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: LD_INT 0
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 1
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: NEG
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 1
33841: NEG
33842: PUSH
33843: LD_INT 2
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 0
33853: PUSH
33854: LD_INT 2
33856: NEG
33857: PUSH
33858: EMPTY
33859: LIST
33860: LIST
33861: PUSH
33862: LD_INT 1
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 2
33875: PUSH
33876: LD_INT 0
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 2
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 2
33895: PUSH
33896: LD_INT 2
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 1
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 0
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: LD_INT 1
33929: PUSH
33930: EMPTY
33931: LIST
33932: LIST
33933: PUSH
33934: LD_INT 2
33936: NEG
33937: PUSH
33938: LD_INT 0
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 2
33947: NEG
33948: PUSH
33949: LD_INT 1
33951: NEG
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 2
33959: NEG
33960: PUSH
33961: LD_INT 2
33963: NEG
33964: PUSH
33965: EMPTY
33966: LIST
33967: LIST
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: LIST
33976: LIST
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33990: LD_ADDR_VAR 0 19
33994: PUSH
33995: LD_INT 0
33997: PUSH
33998: LD_INT 0
34000: PUSH
34001: EMPTY
34002: LIST
34003: LIST
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: EMPTY
34023: LIST
34024: LIST
34025: PUSH
34026: LD_INT 1
34028: PUSH
34029: LD_INT 1
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 0
34038: PUSH
34039: LD_INT 1
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: LD_INT 1
34048: NEG
34049: PUSH
34050: LD_INT 0
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 1
34059: NEG
34060: PUSH
34061: LD_INT 1
34063: NEG
34064: PUSH
34065: EMPTY
34066: LIST
34067: LIST
34068: PUSH
34069: LD_INT 1
34071: NEG
34072: PUSH
34073: LD_INT 2
34075: NEG
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 0
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: EMPTY
34089: LIST
34090: LIST
34091: PUSH
34092: LD_INT 1
34094: PUSH
34095: LD_INT 1
34097: NEG
34098: PUSH
34099: EMPTY
34100: LIST
34101: LIST
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: LD_INT 0
34108: PUSH
34109: EMPTY
34110: LIST
34111: LIST
34112: PUSH
34113: LD_INT 2
34115: PUSH
34116: LD_INT 1
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: LD_INT 2
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 1
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 0
34145: PUSH
34146: LD_INT 2
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 1
34155: NEG
34156: PUSH
34157: LD_INT 1
34159: PUSH
34160: EMPTY
34161: LIST
34162: LIST
34163: PUSH
34164: LD_INT 2
34166: NEG
34167: PUSH
34168: LD_INT 0
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 2
34177: NEG
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 2
34189: NEG
34190: PUSH
34191: LD_INT 2
34193: NEG
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: LIST
34206: LIST
34207: LIST
34208: LIST
34209: LIST
34210: LIST
34211: LIST
34212: LIST
34213: LIST
34214: LIST
34215: LIST
34216: LIST
34217: LIST
34218: LIST
34219: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34220: LD_ADDR_VAR 0 20
34224: PUSH
34225: LD_INT 0
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 1
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 1
34258: PUSH
34259: LD_INT 1
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 0
34268: PUSH
34269: LD_INT 1
34271: PUSH
34272: EMPTY
34273: LIST
34274: LIST
34275: PUSH
34276: LD_INT 1
34278: NEG
34279: PUSH
34280: LD_INT 0
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 1
34289: NEG
34290: PUSH
34291: LD_INT 1
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: NEG
34302: PUSH
34303: LD_INT 2
34305: NEG
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 0
34313: PUSH
34314: LD_INT 2
34316: NEG
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: LD_INT 1
34327: NEG
34328: PUSH
34329: EMPTY
34330: LIST
34331: LIST
34332: PUSH
34333: LD_INT 2
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 2
34345: PUSH
34346: LD_INT 1
34348: PUSH
34349: EMPTY
34350: LIST
34351: LIST
34352: PUSH
34353: LD_INT 2
34355: PUSH
34356: LD_INT 2
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 1
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 0
34375: PUSH
34376: LD_INT 2
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 1
34385: NEG
34386: PUSH
34387: LD_INT 1
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 2
34396: NEG
34397: PUSH
34398: LD_INT 0
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 2
34407: NEG
34408: PUSH
34409: LD_INT 1
34411: NEG
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 2
34419: NEG
34420: PUSH
34421: LD_INT 2
34423: NEG
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: EMPTY
34430: LIST
34431: LIST
34432: LIST
34433: LIST
34434: LIST
34435: LIST
34436: LIST
34437: LIST
34438: LIST
34439: LIST
34440: LIST
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34450: LD_ADDR_VAR 0 21
34454: PUSH
34455: LD_INT 0
34457: PUSH
34458: LD_INT 0
34460: PUSH
34461: EMPTY
34462: LIST
34463: LIST
34464: PUSH
34465: LD_INT 0
34467: PUSH
34468: LD_INT 1
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 1
34488: PUSH
34489: LD_INT 1
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 0
34498: PUSH
34499: LD_INT 1
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 1
34508: NEG
34509: PUSH
34510: LD_INT 0
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: NEG
34520: PUSH
34521: LD_INT 1
34523: NEG
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: LD_INT 1
34531: NEG
34532: PUSH
34533: LD_INT 2
34535: NEG
34536: PUSH
34537: EMPTY
34538: LIST
34539: LIST
34540: PUSH
34541: LD_INT 0
34543: PUSH
34544: LD_INT 2
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: PUSH
34555: LD_INT 1
34557: NEG
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: PUSH
34566: LD_INT 0
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: PUSH
34576: LD_INT 1
34578: PUSH
34579: EMPTY
34580: LIST
34581: LIST
34582: PUSH
34583: LD_INT 2
34585: PUSH
34586: LD_INT 2
34588: PUSH
34589: EMPTY
34590: LIST
34591: LIST
34592: PUSH
34593: LD_INT 1
34595: PUSH
34596: LD_INT 2
34598: PUSH
34599: EMPTY
34600: LIST
34601: LIST
34602: PUSH
34603: LD_INT 0
34605: PUSH
34606: LD_INT 2
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 1
34615: NEG
34616: PUSH
34617: LD_INT 1
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 2
34626: NEG
34627: PUSH
34628: LD_INT 0
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 2
34637: NEG
34638: PUSH
34639: LD_INT 1
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 2
34649: NEG
34650: PUSH
34651: LD_INT 2
34653: NEG
34654: PUSH
34655: EMPTY
34656: LIST
34657: LIST
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: LIST
34663: LIST
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34680: LD_ADDR_VAR 0 22
34684: PUSH
34685: LD_INT 0
34687: PUSH
34688: LD_INT 0
34690: PUSH
34691: EMPTY
34692: LIST
34693: LIST
34694: PUSH
34695: LD_INT 0
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 1
34708: PUSH
34709: LD_INT 0
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: EMPTY
34723: LIST
34724: LIST
34725: PUSH
34726: LD_INT 0
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: EMPTY
34733: LIST
34734: LIST
34735: PUSH
34736: LD_INT 1
34738: NEG
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: EMPTY
34744: LIST
34745: LIST
34746: PUSH
34747: LD_INT 1
34749: NEG
34750: PUSH
34751: LD_INT 1
34753: NEG
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: LD_INT 2
34765: NEG
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 0
34773: PUSH
34774: LD_INT 2
34776: NEG
34777: PUSH
34778: EMPTY
34779: LIST
34780: LIST
34781: PUSH
34782: LD_INT 1
34784: PUSH
34785: LD_INT 1
34787: NEG
34788: PUSH
34789: EMPTY
34790: LIST
34791: LIST
34792: PUSH
34793: LD_INT 2
34795: PUSH
34796: LD_INT 0
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 2
34805: PUSH
34806: LD_INT 1
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 2
34815: PUSH
34816: LD_INT 2
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: LD_INT 2
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: LD_INT 2
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: LD_INT 1
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 2
34856: NEG
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: EMPTY
34862: LIST
34863: LIST
34864: PUSH
34865: LD_INT 2
34867: NEG
34868: PUSH
34869: LD_INT 1
34871: NEG
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 2
34879: NEG
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34910: LD_ADDR_VAR 0 23
34914: PUSH
34915: LD_INT 0
34917: PUSH
34918: LD_INT 0
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 0
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 1
34938: PUSH
34939: LD_INT 0
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: PUSH
34946: LD_INT 1
34948: PUSH
34949: LD_INT 1
34951: PUSH
34952: EMPTY
34953: LIST
34954: LIST
34955: PUSH
34956: LD_INT 0
34958: PUSH
34959: LD_INT 1
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 1
34968: NEG
34969: PUSH
34970: LD_INT 0
34972: PUSH
34973: EMPTY
34974: LIST
34975: LIST
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: LD_INT 1
34983: NEG
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 1
34991: NEG
34992: PUSH
34993: LD_INT 2
34995: NEG
34996: PUSH
34997: EMPTY
34998: LIST
34999: LIST
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: LD_INT 2
35006: NEG
35007: PUSH
35008: EMPTY
35009: LIST
35010: LIST
35011: PUSH
35012: LD_INT 1
35014: PUSH
35015: LD_INT 1
35017: NEG
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: LD_INT 0
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 2
35035: PUSH
35036: LD_INT 1
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: LD_INT 2
35045: PUSH
35046: LD_INT 2
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: LD_INT 2
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: LD_INT 2
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 1
35075: NEG
35076: PUSH
35077: LD_INT 1
35079: PUSH
35080: EMPTY
35081: LIST
35082: LIST
35083: PUSH
35084: LD_INT 2
35086: NEG
35087: PUSH
35088: LD_INT 0
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 2
35097: NEG
35098: PUSH
35099: LD_INT 1
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 2
35109: NEG
35110: PUSH
35111: LD_INT 2
35113: NEG
35114: PUSH
35115: EMPTY
35116: LIST
35117: LIST
35118: PUSH
35119: LD_INT 2
35121: NEG
35122: PUSH
35123: LD_INT 3
35125: NEG
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 1
35133: NEG
35134: PUSH
35135: LD_INT 3
35137: NEG
35138: PUSH
35139: EMPTY
35140: LIST
35141: LIST
35142: PUSH
35143: LD_INT 1
35145: PUSH
35146: LD_INT 2
35148: NEG
35149: PUSH
35150: EMPTY
35151: LIST
35152: LIST
35153: PUSH
35154: LD_INT 2
35156: PUSH
35157: LD_INT 1
35159: NEG
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: LIST
35175: LIST
35176: LIST
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
35190: LD_ADDR_VAR 0 24
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: EMPTY
35202: LIST
35203: LIST
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: LD_INT 1
35210: NEG
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 1
35218: PUSH
35219: LD_INT 0
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: PUSH
35226: LD_INT 1
35228: PUSH
35229: LD_INT 1
35231: PUSH
35232: EMPTY
35233: LIST
35234: LIST
35235: PUSH
35236: LD_INT 0
35238: PUSH
35239: LD_INT 1
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 1
35248: NEG
35249: PUSH
35250: LD_INT 0
35252: PUSH
35253: EMPTY
35254: LIST
35255: LIST
35256: PUSH
35257: LD_INT 1
35259: NEG
35260: PUSH
35261: LD_INT 1
35263: NEG
35264: PUSH
35265: EMPTY
35266: LIST
35267: LIST
35268: PUSH
35269: LD_INT 1
35271: NEG
35272: PUSH
35273: LD_INT 2
35275: NEG
35276: PUSH
35277: EMPTY
35278: LIST
35279: LIST
35280: PUSH
35281: LD_INT 0
35283: PUSH
35284: LD_INT 2
35286: NEG
35287: PUSH
35288: EMPTY
35289: LIST
35290: LIST
35291: PUSH
35292: LD_INT 1
35294: PUSH
35295: LD_INT 1
35297: NEG
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 2
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 2
35315: PUSH
35316: LD_INT 1
35318: PUSH
35319: EMPTY
35320: LIST
35321: LIST
35322: PUSH
35323: LD_INT 2
35325: PUSH
35326: LD_INT 2
35328: PUSH
35329: EMPTY
35330: LIST
35331: LIST
35332: PUSH
35333: LD_INT 1
35335: PUSH
35336: LD_INT 2
35338: PUSH
35339: EMPTY
35340: LIST
35341: LIST
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: LD_INT 2
35348: PUSH
35349: EMPTY
35350: LIST
35351: LIST
35352: PUSH
35353: LD_INT 1
35355: NEG
35356: PUSH
35357: LD_INT 1
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: LD_INT 2
35366: NEG
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: EMPTY
35372: LIST
35373: LIST
35374: PUSH
35375: LD_INT 2
35377: NEG
35378: PUSH
35379: LD_INT 1
35381: NEG
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 2
35389: NEG
35390: PUSH
35391: LD_INT 2
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 1
35401: PUSH
35402: LD_INT 2
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: LD_INT 2
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 3
35423: PUSH
35424: LD_INT 1
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: PUSH
35431: LD_INT 3
35433: PUSH
35434: LD_INT 2
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35466: LD_ADDR_VAR 0 25
35470: PUSH
35471: LD_INT 0
35473: PUSH
35474: LD_INT 0
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: LD_INT 1
35486: NEG
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: LD_INT 0
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 0
35514: PUSH
35515: LD_INT 1
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: NEG
35525: PUSH
35526: LD_INT 0
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: LD_INT 1
35535: NEG
35536: PUSH
35537: LD_INT 1
35539: NEG
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 1
35547: NEG
35548: PUSH
35549: LD_INT 2
35551: NEG
35552: PUSH
35553: EMPTY
35554: LIST
35555: LIST
35556: PUSH
35557: LD_INT 0
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 1
35570: PUSH
35571: LD_INT 1
35573: NEG
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 2
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 2
35591: PUSH
35592: LD_INT 1
35594: PUSH
35595: EMPTY
35596: LIST
35597: LIST
35598: PUSH
35599: LD_INT 2
35601: PUSH
35602: LD_INT 2
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: LD_INT 2
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 0
35621: PUSH
35622: LD_INT 2
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 1
35631: NEG
35632: PUSH
35633: LD_INT 1
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 2
35642: NEG
35643: PUSH
35644: LD_INT 0
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 2
35653: NEG
35654: PUSH
35655: LD_INT 1
35657: NEG
35658: PUSH
35659: EMPTY
35660: LIST
35661: LIST
35662: PUSH
35663: LD_INT 2
35665: NEG
35666: PUSH
35667: LD_INT 2
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 3
35677: PUSH
35678: LD_INT 1
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 3
35687: PUSH
35688: LD_INT 2
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 2
35697: PUSH
35698: LD_INT 3
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: LD_INT 3
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: LIST
35719: LIST
35720: LIST
35721: LIST
35722: LIST
35723: LIST
35724: LIST
35725: LIST
35726: LIST
35727: LIST
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35740: LD_ADDR_VAR 0 26
35744: PUSH
35745: LD_INT 0
35747: PUSH
35748: LD_INT 0
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: LD_INT 1
35760: NEG
35761: PUSH
35762: EMPTY
35763: LIST
35764: LIST
35765: PUSH
35766: LD_INT 1
35768: PUSH
35769: LD_INT 0
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 1
35778: PUSH
35779: LD_INT 1
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 0
35788: PUSH
35789: LD_INT 1
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: LD_INT 0
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 1
35809: NEG
35810: PUSH
35811: LD_INT 1
35813: NEG
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: LD_INT 2
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 0
35833: PUSH
35834: LD_INT 2
35836: NEG
35837: PUSH
35838: EMPTY
35839: LIST
35840: LIST
35841: PUSH
35842: LD_INT 1
35844: PUSH
35845: LD_INT 1
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 2
35855: PUSH
35856: LD_INT 0
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 2
35865: PUSH
35866: LD_INT 1
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 2
35875: PUSH
35876: LD_INT 2
35878: PUSH
35879: EMPTY
35880: LIST
35881: LIST
35882: PUSH
35883: LD_INT 1
35885: PUSH
35886: LD_INT 2
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 0
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 1
35905: NEG
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 2
35916: NEG
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 2
35927: NEG
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: NEG
35940: PUSH
35941: LD_INT 2
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 2
35951: PUSH
35952: LD_INT 3
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 1
35961: PUSH
35962: LD_INT 3
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: LD_INT 2
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 2
35982: NEG
35983: PUSH
35984: LD_INT 1
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: LIST
36006: LIST
36007: LIST
36008: LIST
36009: LIST
36010: LIST
36011: LIST
36012: LIST
36013: LIST
36014: LIST
36015: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36016: LD_ADDR_VAR 0 27
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 0
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 0
36033: PUSH
36034: LD_INT 1
36036: NEG
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: LD_INT 0
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: PUSH
36055: LD_INT 1
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 0
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: LD_INT 0
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 1
36085: NEG
36086: PUSH
36087: LD_INT 1
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 1
36097: NEG
36098: PUSH
36099: LD_INT 2
36101: NEG
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 0
36109: PUSH
36110: LD_INT 2
36112: NEG
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 1
36123: NEG
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 2
36141: PUSH
36142: LD_INT 1
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 2
36151: PUSH
36152: LD_INT 2
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: LD_INT 2
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 0
36171: PUSH
36172: LD_INT 2
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: LD_INT 2
36192: NEG
36193: PUSH
36194: LD_INT 0
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: PUSH
36201: LD_INT 2
36203: NEG
36204: PUSH
36205: LD_INT 1
36207: NEG
36208: PUSH
36209: EMPTY
36210: LIST
36211: LIST
36212: PUSH
36213: LD_INT 2
36215: NEG
36216: PUSH
36217: LD_INT 2
36219: NEG
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: NEG
36228: PUSH
36229: LD_INT 2
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 2
36238: NEG
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 3
36249: NEG
36250: PUSH
36251: LD_INT 1
36253: NEG
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 3
36261: NEG
36262: PUSH
36263: LD_INT 2
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: LIST
36275: LIST
36276: LIST
36277: LIST
36278: LIST
36279: LIST
36280: LIST
36281: LIST
36282: LIST
36283: LIST
36284: LIST
36285: LIST
36286: LIST
36287: LIST
36288: LIST
36289: LIST
36290: LIST
36291: LIST
36292: LIST
36293: LIST
36294: LIST
36295: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36296: LD_ADDR_VAR 0 28
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 0
36313: PUSH
36314: LD_INT 1
36316: NEG
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 1
36324: PUSH
36325: LD_INT 0
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 1
36334: PUSH
36335: LD_INT 1
36337: PUSH
36338: EMPTY
36339: LIST
36340: LIST
36341: PUSH
36342: LD_INT 0
36344: PUSH
36345: LD_INT 1
36347: PUSH
36348: EMPTY
36349: LIST
36350: LIST
36351: PUSH
36352: LD_INT 1
36354: NEG
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 1
36365: NEG
36366: PUSH
36367: LD_INT 1
36369: NEG
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 1
36377: NEG
36378: PUSH
36379: LD_INT 2
36381: NEG
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: LD_INT 2
36392: NEG
36393: PUSH
36394: EMPTY
36395: LIST
36396: LIST
36397: PUSH
36398: LD_INT 1
36400: PUSH
36401: LD_INT 1
36403: NEG
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 2
36421: PUSH
36422: LD_INT 1
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 2
36431: PUSH
36432: LD_INT 2
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 1
36441: PUSH
36442: LD_INT 2
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 0
36451: PUSH
36452: LD_INT 2
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 1
36461: NEG
36462: PUSH
36463: LD_INT 1
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: LD_INT 0
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 2
36483: NEG
36484: PUSH
36485: LD_INT 1
36487: NEG
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 2
36495: NEG
36496: PUSH
36497: LD_INT 2
36499: NEG
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 2
36507: NEG
36508: PUSH
36509: LD_INT 3
36511: NEG
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: NEG
36520: PUSH
36521: LD_INT 3
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 3
36531: NEG
36532: PUSH
36533: LD_INT 1
36535: NEG
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 3
36543: NEG
36544: PUSH
36545: LD_INT 2
36547: NEG
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: LIST
36557: LIST
36558: LIST
36559: LIST
36560: LIST
36561: LIST
36562: LIST
36563: LIST
36564: LIST
36565: LIST
36566: LIST
36567: LIST
36568: LIST
36569: LIST
36570: LIST
36571: LIST
36572: LIST
36573: LIST
36574: LIST
36575: LIST
36576: LIST
36577: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36578: LD_ADDR_VAR 0 29
36582: PUSH
36583: LD_INT 0
36585: PUSH
36586: LD_INT 0
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 0
36595: PUSH
36596: LD_INT 1
36598: NEG
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 1
36606: PUSH
36607: LD_INT 0
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: PUSH
36617: LD_INT 1
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: NEG
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: NEG
36648: PUSH
36649: LD_INT 1
36651: NEG
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PUSH
36657: LD_INT 1
36659: NEG
36660: PUSH
36661: LD_INT 2
36663: NEG
36664: PUSH
36665: EMPTY
36666: LIST
36667: LIST
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: LD_INT 2
36674: NEG
36675: PUSH
36676: EMPTY
36677: LIST
36678: LIST
36679: PUSH
36680: LD_INT 1
36682: PUSH
36683: LD_INT 1
36685: NEG
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 2
36693: PUSH
36694: LD_INT 0
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 2
36703: PUSH
36704: LD_INT 1
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 2
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 0
36723: PUSH
36724: LD_INT 2
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 1
36733: NEG
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: NEG
36745: PUSH
36746: LD_INT 1
36748: NEG
36749: PUSH
36750: EMPTY
36751: LIST
36752: LIST
36753: PUSH
36754: LD_INT 2
36756: NEG
36757: PUSH
36758: LD_INT 2
36760: NEG
36761: PUSH
36762: EMPTY
36763: LIST
36764: LIST
36765: PUSH
36766: LD_INT 2
36768: NEG
36769: PUSH
36770: LD_INT 3
36772: NEG
36773: PUSH
36774: EMPTY
36775: LIST
36776: LIST
36777: PUSH
36778: LD_INT 2
36780: PUSH
36781: LD_INT 1
36783: NEG
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 3
36791: PUSH
36792: LD_INT 1
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 1
36801: PUSH
36802: LD_INT 3
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 1
36811: NEG
36812: PUSH
36813: LD_INT 2
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 3
36822: NEG
36823: PUSH
36824: LD_INT 2
36826: NEG
36827: PUSH
36828: EMPTY
36829: LIST
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: LIST
36849: LIST
36850: LIST
36851: LIST
36852: LIST
36853: LIST
36854: LIST
36855: LIST
36856: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36857: LD_ADDR_VAR 0 30
36861: PUSH
36862: LD_INT 0
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: LD_INT 0
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 1
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 1
36915: NEG
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: LD_INT 1
36938: NEG
36939: PUSH
36940: LD_INT 2
36942: NEG
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 0
36950: PUSH
36951: LD_INT 2
36953: NEG
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 1
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: EMPTY
36967: LIST
36968: LIST
36969: PUSH
36970: LD_INT 2
36972: PUSH
36973: LD_INT 0
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 2
36982: PUSH
36983: LD_INT 1
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 2
36992: PUSH
36993: LD_INT 2
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 1
37002: PUSH
37003: LD_INT 2
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: LD_INT 1
37012: NEG
37013: PUSH
37014: LD_INT 1
37016: PUSH
37017: EMPTY
37018: LIST
37019: LIST
37020: PUSH
37021: LD_INT 2
37023: NEG
37024: PUSH
37025: LD_INT 0
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 2
37034: NEG
37035: PUSH
37036: LD_INT 1
37038: NEG
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 1
37046: NEG
37047: PUSH
37048: LD_INT 3
37050: NEG
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 1
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 3
37069: PUSH
37070: LD_INT 2
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 2
37079: PUSH
37080: LD_INT 3
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 2
37089: NEG
37090: PUSH
37091: LD_INT 1
37093: PUSH
37094: EMPTY
37095: LIST
37096: LIST
37097: PUSH
37098: LD_INT 3
37100: NEG
37101: PUSH
37102: LD_INT 1
37104: NEG
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: EMPTY
37111: LIST
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: LIST
37124: LIST
37125: LIST
37126: LIST
37127: LIST
37128: LIST
37129: LIST
37130: LIST
37131: LIST
37132: LIST
37133: LIST
37134: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37135: LD_ADDR_VAR 0 31
37139: PUSH
37140: LD_INT 0
37142: PUSH
37143: LD_INT 0
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 1
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 1
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 0
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: LD_INT 1
37208: NEG
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 1
37216: NEG
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: PUSH
37229: LD_INT 1
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: LD_INT 0
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 2
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 2
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 1
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 0
37279: PUSH
37280: LD_INT 2
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 1
37289: NEG
37290: PUSH
37291: LD_INT 1
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 2
37300: NEG
37301: PUSH
37302: LD_INT 1
37304: NEG
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 2
37312: NEG
37313: PUSH
37314: LD_INT 2
37316: NEG
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: LD_INT 3
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 2
37336: PUSH
37337: LD_INT 1
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 3
37347: PUSH
37348: LD_INT 1
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: PUSH
37355: LD_INT 1
37357: PUSH
37358: LD_INT 3
37360: PUSH
37361: EMPTY
37362: LIST
37363: LIST
37364: PUSH
37365: LD_INT 1
37367: NEG
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 3
37378: NEG
37379: PUSH
37380: LD_INT 2
37382: NEG
37383: PUSH
37384: EMPTY
37385: LIST
37386: LIST
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: LIST
37404: LIST
37405: LIST
37406: LIST
37407: LIST
37408: LIST
37409: LIST
37410: LIST
37411: LIST
37412: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37413: LD_ADDR_VAR 0 32
37417: PUSH
37418: LD_INT 0
37420: PUSH
37421: LD_INT 0
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 0
37430: PUSH
37431: LD_INT 1
37433: NEG
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 1
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: PUSH
37452: LD_INT 1
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 0
37461: PUSH
37462: LD_INT 1
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 1
37471: NEG
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 1
37482: NEG
37483: PUSH
37484: LD_INT 1
37486: NEG
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: NEG
37495: PUSH
37496: LD_INT 2
37498: NEG
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PUSH
37504: LD_INT 0
37506: PUSH
37507: LD_INT 2
37509: NEG
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 1
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 2
37528: PUSH
37529: LD_INT 1
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: LD_INT 2
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 1
37548: PUSH
37549: LD_INT 2
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 0
37558: PUSH
37559: LD_INT 2
37561: PUSH
37562: EMPTY
37563: LIST
37564: LIST
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: LD_INT 1
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 2
37579: NEG
37580: PUSH
37581: LD_INT 0
37583: PUSH
37584: EMPTY
37585: LIST
37586: LIST
37587: PUSH
37588: LD_INT 2
37590: NEG
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 1
37602: NEG
37603: PUSH
37604: LD_INT 3
37606: NEG
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 1
37614: PUSH
37615: LD_INT 2
37617: NEG
37618: PUSH
37619: EMPTY
37620: LIST
37621: LIST
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: LD_INT 2
37628: PUSH
37629: EMPTY
37630: LIST
37631: LIST
37632: PUSH
37633: LD_INT 2
37635: PUSH
37636: LD_INT 3
37638: PUSH
37639: EMPTY
37640: LIST
37641: LIST
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: LD_INT 1
37649: PUSH
37650: EMPTY
37651: LIST
37652: LIST
37653: PUSH
37654: LD_INT 3
37656: NEG
37657: PUSH
37658: LD_INT 1
37660: NEG
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: EMPTY
37667: LIST
37668: LIST
37669: LIST
37670: LIST
37671: LIST
37672: LIST
37673: LIST
37674: LIST
37675: LIST
37676: LIST
37677: LIST
37678: LIST
37679: LIST
37680: LIST
37681: LIST
37682: LIST
37683: LIST
37684: LIST
37685: LIST
37686: LIST
37687: LIST
37688: LIST
37689: LIST
37690: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37691: LD_ADDR_VAR 0 33
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: LD_INT 0
37701: PUSH
37702: EMPTY
37703: LIST
37704: LIST
37705: PUSH
37706: LD_INT 0
37708: PUSH
37709: LD_INT 1
37711: NEG
37712: PUSH
37713: EMPTY
37714: LIST
37715: LIST
37716: PUSH
37717: LD_INT 1
37719: PUSH
37720: LD_INT 0
37722: PUSH
37723: EMPTY
37724: LIST
37725: LIST
37726: PUSH
37727: LD_INT 1
37729: PUSH
37730: LD_INT 1
37732: PUSH
37733: EMPTY
37734: LIST
37735: LIST
37736: PUSH
37737: LD_INT 0
37739: PUSH
37740: LD_INT 1
37742: PUSH
37743: EMPTY
37744: LIST
37745: LIST
37746: PUSH
37747: LD_INT 1
37749: NEG
37750: PUSH
37751: LD_INT 0
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: NEG
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 1
37772: NEG
37773: PUSH
37774: LD_INT 2
37776: NEG
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 1
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 2
37795: PUSH
37796: LD_INT 0
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 2
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: PUSH
37816: LD_INT 2
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 0
37825: PUSH
37826: LD_INT 2
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 1
37835: NEG
37836: PUSH
37837: LD_INT 1
37839: PUSH
37840: EMPTY
37841: LIST
37842: LIST
37843: PUSH
37844: LD_INT 2
37846: NEG
37847: PUSH
37848: LD_INT 0
37850: PUSH
37851: EMPTY
37852: LIST
37853: LIST
37854: PUSH
37855: LD_INT 2
37857: NEG
37858: PUSH
37859: LD_INT 1
37861: NEG
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: PUSH
37867: LD_INT 2
37869: NEG
37870: PUSH
37871: LD_INT 2
37873: NEG
37874: PUSH
37875: EMPTY
37876: LIST
37877: LIST
37878: PUSH
37879: LD_INT 2
37881: NEG
37882: PUSH
37883: LD_INT 3
37885: NEG
37886: PUSH
37887: EMPTY
37888: LIST
37889: LIST
37890: PUSH
37891: LD_INT 2
37893: PUSH
37894: LD_INT 1
37896: NEG
37897: PUSH
37898: EMPTY
37899: LIST
37900: LIST
37901: PUSH
37902: LD_INT 3
37904: PUSH
37905: LD_INT 1
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 1
37914: PUSH
37915: LD_INT 3
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 1
37924: NEG
37925: PUSH
37926: LD_INT 2
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 3
37935: NEG
37936: PUSH
37937: LD_INT 2
37939: NEG
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: LIST
37954: LIST
37955: LIST
37956: LIST
37957: LIST
37958: LIST
37959: LIST
37960: LIST
37961: LIST
37962: LIST
37963: LIST
37964: LIST
37965: LIST
37966: LIST
37967: LIST
37968: LIST
37969: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37970: LD_ADDR_VAR 0 34
37974: PUSH
37975: LD_INT 0
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 0
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 1
37998: PUSH
37999: LD_INT 0
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 1
38008: PUSH
38009: LD_INT 1
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 0
38018: PUSH
38019: LD_INT 1
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 1
38028: NEG
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: EMPTY
38034: LIST
38035: LIST
38036: PUSH
38037: LD_INT 1
38039: NEG
38040: PUSH
38041: LD_INT 1
38043: NEG
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: LD_INT 1
38051: NEG
38052: PUSH
38053: LD_INT 2
38055: NEG
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: LD_INT 2
38066: NEG
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 1
38074: PUSH
38075: LD_INT 1
38077: NEG
38078: PUSH
38079: EMPTY
38080: LIST
38081: LIST
38082: PUSH
38083: LD_INT 2
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: EMPTY
38090: LIST
38091: LIST
38092: PUSH
38093: LD_INT 2
38095: PUSH
38096: LD_INT 2
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 1
38105: PUSH
38106: LD_INT 2
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 1
38115: NEG
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 2
38126: NEG
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 2
38137: NEG
38138: PUSH
38139: LD_INT 1
38141: NEG
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 2
38149: NEG
38150: PUSH
38151: LD_INT 2
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: LD_INT 3
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 3
38184: PUSH
38185: LD_INT 2
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: LD_INT 3
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: NEG
38205: PUSH
38206: LD_INT 1
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 3
38215: NEG
38216: PUSH
38217: LD_INT 1
38219: NEG
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: LIST
38233: LIST
38234: LIST
38235: LIST
38236: LIST
38237: LIST
38238: LIST
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38250: LD_ADDR_VAR 0 35
38254: PUSH
38255: LD_INT 0
38257: PUSH
38258: LD_INT 0
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 0
38267: PUSH
38268: LD_INT 1
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: PUSH
38279: LD_INT 0
38281: PUSH
38282: EMPTY
38283: LIST
38284: LIST
38285: PUSH
38286: LD_INT 1
38288: PUSH
38289: LD_INT 1
38291: PUSH
38292: EMPTY
38293: LIST
38294: LIST
38295: PUSH
38296: LD_INT 0
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 1
38308: NEG
38309: PUSH
38310: LD_INT 0
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: PUSH
38317: LD_INT 1
38319: NEG
38320: PUSH
38321: LD_INT 1
38323: NEG
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 2
38331: PUSH
38332: LD_INT 1
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 2
38341: NEG
38342: PUSH
38343: LD_INT 1
38345: NEG
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: LIST
38357: LIST
38358: LIST
38359: LIST
38360: LIST
38361: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38362: LD_ADDR_VAR 0 36
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 0
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 1
38390: PUSH
38391: LD_INT 0
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 1
38400: PUSH
38401: LD_INT 1
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 0
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 1
38420: NEG
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: EMPTY
38426: LIST
38427: LIST
38428: PUSH
38429: LD_INT 1
38431: NEG
38432: PUSH
38433: LD_INT 1
38435: NEG
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 1
38443: NEG
38444: PUSH
38445: LD_INT 2
38447: NEG
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38474: LD_ADDR_VAR 0 37
38478: PUSH
38479: LD_INT 0
38481: PUSH
38482: LD_INT 0
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: PUSH
38556: LD_INT 1
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: LD_INT 1
38570: PUSH
38571: EMPTY
38572: LIST
38573: LIST
38574: PUSH
38575: EMPTY
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38586: LD_ADDR_VAR 0 38
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: LD_INT 0
38596: PUSH
38597: EMPTY
38598: LIST
38599: LIST
38600: PUSH
38601: LD_INT 0
38603: PUSH
38604: LD_INT 1
38606: NEG
38607: PUSH
38608: EMPTY
38609: LIST
38610: LIST
38611: PUSH
38612: LD_INT 1
38614: PUSH
38615: LD_INT 0
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: LD_INT 1
38627: PUSH
38628: EMPTY
38629: LIST
38630: LIST
38631: PUSH
38632: LD_INT 0
38634: PUSH
38635: LD_INT 1
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 1
38644: NEG
38645: PUSH
38646: LD_INT 0
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 1
38655: NEG
38656: PUSH
38657: LD_INT 1
38659: NEG
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 2
38667: PUSH
38668: LD_INT 1
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 2
38677: NEG
38678: PUSH
38679: LD_INT 1
38681: NEG
38682: PUSH
38683: EMPTY
38684: LIST
38685: LIST
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: LIST
38691: LIST
38692: LIST
38693: LIST
38694: LIST
38695: LIST
38696: LIST
38697: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38698: LD_ADDR_VAR 0 39
38702: PUSH
38703: LD_INT 0
38705: PUSH
38706: LD_INT 0
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 0
38715: PUSH
38716: LD_INT 1
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 1
38726: PUSH
38727: LD_INT 0
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 1
38736: PUSH
38737: LD_INT 1
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 0
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: NEG
38757: PUSH
38758: LD_INT 0
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: NEG
38768: PUSH
38769: LD_INT 1
38771: NEG
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 1
38779: NEG
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: EMPTY
38800: LIST
38801: LIST
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38810: LD_ADDR_VAR 0 40
38814: PUSH
38815: LD_INT 0
38817: PUSH
38818: LD_INT 0
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 0
38827: PUSH
38828: LD_INT 1
38830: NEG
38831: PUSH
38832: EMPTY
38833: LIST
38834: LIST
38835: PUSH
38836: LD_INT 1
38838: PUSH
38839: LD_INT 0
38841: PUSH
38842: EMPTY
38843: LIST
38844: LIST
38845: PUSH
38846: LD_INT 1
38848: PUSH
38849: LD_INT 1
38851: PUSH
38852: EMPTY
38853: LIST
38854: LIST
38855: PUSH
38856: LD_INT 0
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: EMPTY
38863: LIST
38864: LIST
38865: PUSH
38866: LD_INT 1
38868: NEG
38869: PUSH
38870: LD_INT 0
38872: PUSH
38873: EMPTY
38874: LIST
38875: LIST
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: LD_INT 1
38883: NEG
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: PUSH
38892: LD_INT 1
38894: NEG
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: LIST
38921: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38922: LD_ADDR_VAR 0 41
38926: PUSH
38927: LD_INT 0
38929: PUSH
38930: LD_INT 0
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: LD_INT 0
38939: PUSH
38940: LD_INT 1
38942: NEG
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: PUSH
38961: LD_INT 1
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 0
38970: PUSH
38971: LD_INT 1
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: LD_INT 0
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 1
38991: NEG
38992: PUSH
38993: LD_INT 1
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: NEG
39004: PUSH
39005: LD_INT 2
39007: NEG
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: PUSH
39016: LD_INT 1
39018: NEG
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 2
39026: PUSH
39027: LD_INT 0
39029: PUSH
39030: EMPTY
39031: LIST
39032: LIST
39033: PUSH
39034: LD_INT 2
39036: PUSH
39037: LD_INT 1
39039: PUSH
39040: EMPTY
39041: LIST
39042: LIST
39043: PUSH
39044: LD_INT 2
39046: PUSH
39047: LD_INT 2
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PUSH
39054: LD_INT 1
39056: PUSH
39057: LD_INT 2
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: LD_INT 1
39066: NEG
39067: PUSH
39068: LD_INT 1
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: LD_INT 2
39077: NEG
39078: PUSH
39079: LD_INT 0
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 2
39088: NEG
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: EMPTY
39095: LIST
39096: LIST
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: EMPTY
39107: LIST
39108: LIST
39109: PUSH
39110: LD_INT 2
39112: NEG
39113: PUSH
39114: LD_INT 3
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: LD_INT 1
39127: NEG
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 3
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 3
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 3
39155: PUSH
39156: LD_INT 2
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 3
39165: PUSH
39166: LD_INT 3
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 2
39175: PUSH
39176: LD_INT 3
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 2
39185: NEG
39186: PUSH
39187: LD_INT 1
39189: PUSH
39190: EMPTY
39191: LIST
39192: LIST
39193: PUSH
39194: LD_INT 3
39196: NEG
39197: PUSH
39198: LD_INT 0
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 3
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: NEG
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 3
39219: NEG
39220: PUSH
39221: LD_INT 2
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 3
39231: NEG
39232: PUSH
39233: LD_INT 3
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: EMPTY
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39272: LD_ADDR_VAR 0 42
39276: PUSH
39277: LD_INT 0
39279: PUSH
39280: LD_INT 0
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 1
39292: NEG
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 1
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: PUSH
39311: LD_INT 1
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: PUSH
39318: LD_INT 0
39320: PUSH
39321: LD_INT 1
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PUSH
39328: LD_INT 1
39330: NEG
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: LD_INT 1
39345: NEG
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 1
39353: NEG
39354: PUSH
39355: LD_INT 2
39357: NEG
39358: PUSH
39359: EMPTY
39360: LIST
39361: LIST
39362: PUSH
39363: LD_INT 0
39365: PUSH
39366: LD_INT 2
39368: NEG
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 1
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 2
39387: PUSH
39388: LD_INT 1
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 2
39397: PUSH
39398: LD_INT 2
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 1
39407: PUSH
39408: LD_INT 2
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 0
39417: PUSH
39418: LD_INT 2
39420: PUSH
39421: EMPTY
39422: LIST
39423: LIST
39424: PUSH
39425: LD_INT 1
39427: NEG
39428: PUSH
39429: LD_INT 1
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 2
39438: NEG
39439: PUSH
39440: LD_INT 1
39442: NEG
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 2
39450: NEG
39451: PUSH
39452: LD_INT 2
39454: NEG
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 2
39462: NEG
39463: PUSH
39464: LD_INT 3
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 1
39474: NEG
39475: PUSH
39476: LD_INT 3
39478: NEG
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 0
39486: PUSH
39487: LD_INT 3
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 1
39497: PUSH
39498: LD_INT 2
39500: NEG
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 3
39508: PUSH
39509: LD_INT 2
39511: PUSH
39512: EMPTY
39513: LIST
39514: LIST
39515: PUSH
39516: LD_INT 3
39518: PUSH
39519: LD_INT 3
39521: PUSH
39522: EMPTY
39523: LIST
39524: LIST
39525: PUSH
39526: LD_INT 2
39528: PUSH
39529: LD_INT 3
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 1
39538: PUSH
39539: LD_INT 3
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: LD_INT 3
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 1
39558: NEG
39559: PUSH
39560: LD_INT 2
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 3
39569: NEG
39570: PUSH
39571: LD_INT 2
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 3
39581: NEG
39582: PUSH
39583: LD_INT 3
39585: NEG
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39622: LD_ADDR_VAR 0 43
39626: PUSH
39627: LD_INT 0
39629: PUSH
39630: LD_INT 0
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: PUSH
39637: LD_INT 0
39639: PUSH
39640: LD_INT 1
39642: NEG
39643: PUSH
39644: EMPTY
39645: LIST
39646: LIST
39647: PUSH
39648: LD_INT 1
39650: PUSH
39651: LD_INT 0
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 1
39660: PUSH
39661: LD_INT 1
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 0
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 1
39680: NEG
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 1
39691: NEG
39692: PUSH
39693: LD_INT 1
39695: NEG
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 0
39715: PUSH
39716: LD_INT 2
39718: NEG
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 1
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: LD_INT 0
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: LD_INT 2
39747: PUSH
39748: LD_INT 1
39750: PUSH
39751: EMPTY
39752: LIST
39753: LIST
39754: PUSH
39755: LD_INT 1
39757: PUSH
39758: LD_INT 2
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: LD_INT 0
39767: PUSH
39768: LD_INT 2
39770: PUSH
39771: EMPTY
39772: LIST
39773: LIST
39774: PUSH
39775: LD_INT 1
39777: NEG
39778: PUSH
39779: LD_INT 1
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 2
39788: NEG
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 2
39799: NEG
39800: PUSH
39801: LD_INT 1
39803: NEG
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 1
39811: NEG
39812: PUSH
39813: LD_INT 3
39815: NEG
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: LD_INT 3
39826: NEG
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 1
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: LD_INT 2
39845: PUSH
39846: LD_INT 1
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 3
39856: PUSH
39857: LD_INT 0
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 3
39866: PUSH
39867: LD_INT 1
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 1
39876: PUSH
39877: LD_INT 3
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 0
39886: PUSH
39887: LD_INT 3
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 1
39896: NEG
39897: PUSH
39898: LD_INT 2
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: PUSH
39905: LD_INT 2
39907: NEG
39908: PUSH
39909: LD_INT 1
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: LD_INT 3
39918: NEG
39919: PUSH
39920: LD_INT 0
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 3
39929: NEG
39930: PUSH
39931: LD_INT 1
39933: NEG
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: LIST
39966: LIST
39967: LIST
39968: LIST
39969: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39970: LD_ADDR_VAR 0 44
39974: PUSH
39975: LD_INT 0
39977: PUSH
39978: LD_INT 0
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: PUSH
39985: LD_INT 0
39987: PUSH
39988: LD_INT 1
39990: NEG
39991: PUSH
39992: EMPTY
39993: LIST
39994: LIST
39995: PUSH
39996: LD_INT 1
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 1
40008: PUSH
40009: LD_INT 1
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: LD_INT 1
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 1
40028: NEG
40029: PUSH
40030: LD_INT 0
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 1
40039: NEG
40040: PUSH
40041: LD_INT 1
40043: NEG
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: NEG
40052: PUSH
40053: LD_INT 2
40055: NEG
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: PUSH
40064: LD_INT 1
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 2
40074: PUSH
40075: LD_INT 0
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 2
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 2
40094: PUSH
40095: LD_INT 2
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 1
40104: PUSH
40105: LD_INT 2
40107: PUSH
40108: EMPTY
40109: LIST
40110: LIST
40111: PUSH
40112: LD_INT 1
40114: NEG
40115: PUSH
40116: LD_INT 1
40118: PUSH
40119: EMPTY
40120: LIST
40121: LIST
40122: PUSH
40123: LD_INT 2
40125: NEG
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 2
40136: NEG
40137: PUSH
40138: LD_INT 1
40140: NEG
40141: PUSH
40142: EMPTY
40143: LIST
40144: LIST
40145: PUSH
40146: LD_INT 2
40148: NEG
40149: PUSH
40150: LD_INT 2
40152: NEG
40153: PUSH
40154: EMPTY
40155: LIST
40156: LIST
40157: PUSH
40158: LD_INT 2
40160: NEG
40161: PUSH
40162: LD_INT 3
40164: NEG
40165: PUSH
40166: EMPTY
40167: LIST
40168: LIST
40169: PUSH
40170: LD_INT 2
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 3
40183: PUSH
40184: LD_INT 0
40186: PUSH
40187: EMPTY
40188: LIST
40189: LIST
40190: PUSH
40191: LD_INT 3
40193: PUSH
40194: LD_INT 1
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: PUSH
40201: LD_INT 3
40203: PUSH
40204: LD_INT 2
40206: PUSH
40207: EMPTY
40208: LIST
40209: LIST
40210: PUSH
40211: LD_INT 3
40213: PUSH
40214: LD_INT 3
40216: PUSH
40217: EMPTY
40218: LIST
40219: LIST
40220: PUSH
40221: LD_INT 2
40223: PUSH
40224: LD_INT 3
40226: PUSH
40227: EMPTY
40228: LIST
40229: LIST
40230: PUSH
40231: LD_INT 2
40233: NEG
40234: PUSH
40235: LD_INT 1
40237: PUSH
40238: EMPTY
40239: LIST
40240: LIST
40241: PUSH
40242: LD_INT 3
40244: NEG
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 3
40255: NEG
40256: PUSH
40257: LD_INT 1
40259: NEG
40260: PUSH
40261: EMPTY
40262: LIST
40263: LIST
40264: PUSH
40265: LD_INT 3
40267: NEG
40268: PUSH
40269: LD_INT 2
40271: NEG
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 3
40279: NEG
40280: PUSH
40281: LD_INT 3
40283: NEG
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: EMPTY
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: LIST
40296: LIST
40297: LIST
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: LIST
40310: LIST
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40320: LD_ADDR_VAR 0 45
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 0
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: LD_INT 1
40340: NEG
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: PUSH
40349: LD_INT 0
40351: PUSH
40352: EMPTY
40353: LIST
40354: LIST
40355: PUSH
40356: LD_INT 1
40358: PUSH
40359: LD_INT 1
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: LD_INT 1
40371: PUSH
40372: EMPTY
40373: LIST
40374: LIST
40375: PUSH
40376: LD_INT 1
40378: NEG
40379: PUSH
40380: LD_INT 0
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: EMPTY
40396: LIST
40397: LIST
40398: PUSH
40399: LD_INT 1
40401: NEG
40402: PUSH
40403: LD_INT 2
40405: NEG
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PUSH
40411: LD_INT 0
40413: PUSH
40414: LD_INT 2
40416: NEG
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 1
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 2
40435: PUSH
40436: LD_INT 1
40438: PUSH
40439: EMPTY
40440: LIST
40441: LIST
40442: PUSH
40443: LD_INT 2
40445: PUSH
40446: LD_INT 2
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: PUSH
40453: LD_INT 1
40455: PUSH
40456: LD_INT 2
40458: PUSH
40459: EMPTY
40460: LIST
40461: LIST
40462: PUSH
40463: LD_INT 0
40465: PUSH
40466: LD_INT 2
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 1
40475: NEG
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 2
40486: NEG
40487: PUSH
40488: LD_INT 1
40490: NEG
40491: PUSH
40492: EMPTY
40493: LIST
40494: LIST
40495: PUSH
40496: LD_INT 2
40498: NEG
40499: PUSH
40500: LD_INT 2
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 2
40510: NEG
40511: PUSH
40512: LD_INT 3
40514: NEG
40515: PUSH
40516: EMPTY
40517: LIST
40518: LIST
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: LD_INT 3
40526: NEG
40527: PUSH
40528: EMPTY
40529: LIST
40530: LIST
40531: PUSH
40532: LD_INT 0
40534: PUSH
40535: LD_INT 3
40537: NEG
40538: PUSH
40539: EMPTY
40540: LIST
40541: LIST
40542: PUSH
40543: LD_INT 1
40545: PUSH
40546: LD_INT 2
40548: NEG
40549: PUSH
40550: EMPTY
40551: LIST
40552: LIST
40553: PUSH
40554: LD_INT 3
40556: PUSH
40557: LD_INT 2
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: LD_INT 3
40566: PUSH
40567: LD_INT 3
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: LD_INT 3
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 1
40586: PUSH
40587: LD_INT 3
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 0
40596: PUSH
40597: LD_INT 3
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 1
40606: NEG
40607: PUSH
40608: LD_INT 2
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 3
40617: NEG
40618: PUSH
40619: LD_INT 2
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 3
40629: NEG
40630: PUSH
40631: LD_INT 3
40633: NEG
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40670: LD_ADDR_VAR 0 46
40674: PUSH
40675: LD_INT 0
40677: PUSH
40678: LD_INT 0
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 0
40687: PUSH
40688: LD_INT 1
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 1
40698: PUSH
40699: LD_INT 0
40701: PUSH
40702: EMPTY
40703: LIST
40704: LIST
40705: PUSH
40706: LD_INT 1
40708: PUSH
40709: LD_INT 1
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 0
40718: PUSH
40719: LD_INT 1
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 1
40728: NEG
40729: PUSH
40730: LD_INT 0
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: LD_INT 1
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: LD_INT 1
40751: NEG
40752: PUSH
40753: LD_INT 2
40755: NEG
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: LD_INT 2
40766: NEG
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: PUSH
40772: LD_INT 1
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 2
40785: PUSH
40786: LD_INT 0
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 2
40795: PUSH
40796: LD_INT 1
40798: PUSH
40799: EMPTY
40800: LIST
40801: LIST
40802: PUSH
40803: LD_INT 1
40805: PUSH
40806: LD_INT 2
40808: PUSH
40809: EMPTY
40810: LIST
40811: LIST
40812: PUSH
40813: LD_INT 0
40815: PUSH
40816: LD_INT 2
40818: PUSH
40819: EMPTY
40820: LIST
40821: LIST
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 1
40829: PUSH
40830: EMPTY
40831: LIST
40832: LIST
40833: PUSH
40834: LD_INT 2
40836: NEG
40837: PUSH
40838: LD_INT 0
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 2
40847: NEG
40848: PUSH
40849: LD_INT 1
40851: NEG
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 1
40859: NEG
40860: PUSH
40861: LD_INT 3
40863: NEG
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: PUSH
40869: LD_INT 0
40871: PUSH
40872: LD_INT 3
40874: NEG
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: LD_INT 1
40882: PUSH
40883: LD_INT 2
40885: NEG
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: LD_INT 2
40893: PUSH
40894: LD_INT 1
40896: NEG
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 3
40904: PUSH
40905: LD_INT 0
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 3
40914: PUSH
40915: LD_INT 1
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: PUSH
40922: LD_INT 1
40924: PUSH
40925: LD_INT 3
40927: PUSH
40928: EMPTY
40929: LIST
40930: LIST
40931: PUSH
40932: LD_INT 0
40934: PUSH
40935: LD_INT 3
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: PUSH
40942: LD_INT 1
40944: NEG
40945: PUSH
40946: LD_INT 2
40948: PUSH
40949: EMPTY
40950: LIST
40951: LIST
40952: PUSH
40953: LD_INT 2
40955: NEG
40956: PUSH
40957: LD_INT 1
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PUSH
40964: LD_INT 3
40966: NEG
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 3
40977: NEG
40978: PUSH
40979: LD_INT 1
40981: NEG
40982: PUSH
40983: EMPTY
40984: LIST
40985: LIST
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: LIST
40991: LIST
40992: LIST
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: LIST
41001: LIST
41002: LIST
41003: LIST
41004: LIST
41005: LIST
41006: LIST
41007: LIST
41008: LIST
41009: LIST
41010: LIST
41011: LIST
41012: LIST
41013: LIST
41014: LIST
41015: LIST
41016: LIST
41017: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41018: LD_ADDR_VAR 0 47
41022: PUSH
41023: LD_INT 0
41025: PUSH
41026: LD_INT 0
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 0
41035: PUSH
41036: LD_INT 1
41038: NEG
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: LD_INT 1
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: EMPTY
41051: LIST
41052: LIST
41053: PUSH
41054: LD_INT 1
41056: PUSH
41057: LD_INT 1
41059: PUSH
41060: EMPTY
41061: LIST
41062: LIST
41063: PUSH
41064: LD_INT 0
41066: PUSH
41067: LD_INT 1
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 1
41076: NEG
41077: PUSH
41078: LD_INT 0
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 1
41087: NEG
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: PUSH
41097: LD_INT 1
41099: NEG
41100: PUSH
41101: LD_INT 2
41103: NEG
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 0
41111: PUSH
41112: LD_INT 2
41114: NEG
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: PUSH
41123: LD_INT 1
41125: NEG
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: LD_INT 1
41137: NEG
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 2
41145: NEG
41146: PUSH
41147: LD_INT 2
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: LIST
41166: LIST
41167: LIST
41168: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41169: LD_ADDR_VAR 0 48
41173: PUSH
41174: LD_INT 0
41176: PUSH
41177: LD_INT 0
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 0
41186: PUSH
41187: LD_INT 1
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 1
41197: PUSH
41198: LD_INT 0
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: LD_INT 1
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 0
41217: PUSH
41218: LD_INT 1
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 1
41227: NEG
41228: PUSH
41229: LD_INT 0
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: LD_INT 1
41238: NEG
41239: PUSH
41240: LD_INT 1
41242: NEG
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: NEG
41251: PUSH
41252: LD_INT 2
41254: NEG
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 0
41262: PUSH
41263: LD_INT 2
41265: NEG
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 2
41284: PUSH
41285: LD_INT 0
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 2
41294: PUSH
41295: LD_INT 1
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: LIST
41315: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41316: LD_ADDR_VAR 0 49
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: LD_INT 0
41326: PUSH
41327: EMPTY
41328: LIST
41329: LIST
41330: PUSH
41331: LD_INT 0
41333: PUSH
41334: LD_INT 1
41336: NEG
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: PUSH
41342: LD_INT 1
41344: PUSH
41345: LD_INT 0
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: LD_INT 1
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 0
41364: PUSH
41365: LD_INT 1
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 1
41374: NEG
41375: PUSH
41376: LD_INT 0
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 1
41385: NEG
41386: PUSH
41387: LD_INT 1
41389: NEG
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: LD_INT 1
41397: PUSH
41398: LD_INT 1
41400: NEG
41401: PUSH
41402: EMPTY
41403: LIST
41404: LIST
41405: PUSH
41406: LD_INT 2
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 2
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 2
41428: PUSH
41429: LD_INT 2
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: LD_INT 2
41441: PUSH
41442: EMPTY
41443: LIST
41444: LIST
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: LIST
41450: LIST
41451: LIST
41452: LIST
41453: LIST
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41460: LD_ADDR_VAR 0 50
41464: PUSH
41465: LD_INT 0
41467: PUSH
41468: LD_INT 0
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PUSH
41475: LD_INT 0
41477: PUSH
41478: LD_INT 1
41480: NEG
41481: PUSH
41482: EMPTY
41483: LIST
41484: LIST
41485: PUSH
41486: LD_INT 1
41488: PUSH
41489: LD_INT 0
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 1
41498: PUSH
41499: LD_INT 1
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: LD_INT 0
41508: PUSH
41509: LD_INT 1
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 1
41518: NEG
41519: PUSH
41520: LD_INT 0
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 1
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: NEG
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: PUSH
41539: LD_INT 2
41541: PUSH
41542: LD_INT 1
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 2
41551: PUSH
41552: LD_INT 2
41554: PUSH
41555: EMPTY
41556: LIST
41557: LIST
41558: PUSH
41559: LD_INT 1
41561: PUSH
41562: LD_INT 2
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 0
41571: PUSH
41572: LD_INT 2
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 1
41581: NEG
41582: PUSH
41583: LD_INT 1
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: LIST
41594: LIST
41595: LIST
41596: LIST
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41604: LD_ADDR_VAR 0 51
41608: PUSH
41609: LD_INT 0
41611: PUSH
41612: LD_INT 0
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 0
41621: PUSH
41622: LD_INT 1
41624: NEG
41625: PUSH
41626: EMPTY
41627: LIST
41628: LIST
41629: PUSH
41630: LD_INT 1
41632: PUSH
41633: LD_INT 0
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: LD_INT 1
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: LD_INT 0
41652: PUSH
41653: LD_INT 1
41655: PUSH
41656: EMPTY
41657: LIST
41658: LIST
41659: PUSH
41660: LD_INT 1
41662: NEG
41663: PUSH
41664: LD_INT 0
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 1
41673: NEG
41674: PUSH
41675: LD_INT 1
41677: NEG
41678: PUSH
41679: EMPTY
41680: LIST
41681: LIST
41682: PUSH
41683: LD_INT 1
41685: PUSH
41686: LD_INT 2
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 0
41695: PUSH
41696: LD_INT 2
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 1
41705: NEG
41706: PUSH
41707: LD_INT 1
41709: PUSH
41710: EMPTY
41711: LIST
41712: LIST
41713: PUSH
41714: LD_INT 2
41716: NEG
41717: PUSH
41718: LD_INT 0
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 2
41727: NEG
41728: PUSH
41729: LD_INT 1
41731: NEG
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: EMPTY
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: LIST
41749: LIST
41750: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41751: LD_ADDR_VAR 0 52
41755: PUSH
41756: LD_INT 0
41758: PUSH
41759: LD_INT 0
41761: PUSH
41762: EMPTY
41763: LIST
41764: LIST
41765: PUSH
41766: LD_INT 0
41768: PUSH
41769: LD_INT 1
41771: NEG
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: PUSH
41777: LD_INT 1
41779: PUSH
41780: LD_INT 0
41782: PUSH
41783: EMPTY
41784: LIST
41785: LIST
41786: PUSH
41787: LD_INT 1
41789: PUSH
41790: LD_INT 1
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: PUSH
41797: LD_INT 0
41799: PUSH
41800: LD_INT 1
41802: PUSH
41803: EMPTY
41804: LIST
41805: LIST
41806: PUSH
41807: LD_INT 1
41809: NEG
41810: PUSH
41811: LD_INT 0
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 1
41820: NEG
41821: PUSH
41822: LD_INT 1
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 1
41832: NEG
41833: PUSH
41834: LD_INT 2
41836: NEG
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: LD_INT 1
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: LD_INT 2
41855: NEG
41856: PUSH
41857: LD_INT 0
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 2
41866: NEG
41867: PUSH
41868: LD_INT 1
41870: NEG
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: PUSH
41876: LD_INT 2
41878: NEG
41879: PUSH
41880: LD_INT 2
41882: NEG
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41902: LD_ADDR_VAR 0 53
41906: PUSH
41907: LD_INT 0
41909: PUSH
41910: LD_INT 0
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 0
41919: PUSH
41920: LD_INT 1
41922: NEG
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 1
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 1
41940: PUSH
41941: LD_INT 1
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: LD_INT 0
41950: PUSH
41951: LD_INT 1
41953: PUSH
41954: EMPTY
41955: LIST
41956: LIST
41957: PUSH
41958: LD_INT 1
41960: NEG
41961: PUSH
41962: LD_INT 0
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 1
41971: NEG
41972: PUSH
41973: LD_INT 1
41975: NEG
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 1
41983: NEG
41984: PUSH
41985: LD_INT 2
41987: NEG
41988: PUSH
41989: EMPTY
41990: LIST
41991: LIST
41992: PUSH
41993: LD_INT 0
41995: PUSH
41996: LD_INT 2
41998: NEG
41999: PUSH
42000: EMPTY
42001: LIST
42002: LIST
42003: PUSH
42004: LD_INT 1
42006: PUSH
42007: LD_INT 1
42009: NEG
42010: PUSH
42011: EMPTY
42012: LIST
42013: LIST
42014: PUSH
42015: LD_INT 2
42017: PUSH
42018: LD_INT 0
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 2
42027: PUSH
42028: LD_INT 1
42030: PUSH
42031: EMPTY
42032: LIST
42033: LIST
42034: PUSH
42035: LD_INT 2
42037: PUSH
42038: LD_INT 2
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: LD_INT 1
42047: PUSH
42048: LD_INT 2
42050: PUSH
42051: EMPTY
42052: LIST
42053: LIST
42054: PUSH
42055: LD_INT 0
42057: PUSH
42058: LD_INT 2
42060: PUSH
42061: EMPTY
42062: LIST
42063: LIST
42064: PUSH
42065: LD_INT 1
42067: NEG
42068: PUSH
42069: LD_INT 1
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 2
42078: NEG
42079: PUSH
42080: LD_INT 0
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 2
42089: NEG
42090: PUSH
42091: LD_INT 1
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 2
42101: NEG
42102: PUSH
42103: LD_INT 2
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: LIST
42115: LIST
42116: LIST
42117: LIST
42118: LIST
42119: LIST
42120: LIST
42121: LIST
42122: LIST
42123: LIST
42124: LIST
42125: LIST
42126: LIST
42127: LIST
42128: LIST
42129: LIST
42130: LIST
42131: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42132: LD_ADDR_VAR 0 54
42136: PUSH
42137: LD_INT 0
42139: PUSH
42140: LD_INT 0
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 0
42149: PUSH
42150: LD_INT 1
42152: NEG
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 1
42170: PUSH
42171: LD_INT 1
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 0
42180: PUSH
42181: LD_INT 1
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: PUSH
42188: LD_INT 1
42190: NEG
42191: PUSH
42192: LD_INT 0
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: LD_INT 1
42201: NEG
42202: PUSH
42203: LD_INT 1
42205: NEG
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: LD_INT 2
42217: NEG
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: LD_INT 2
42228: NEG
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: EMPTY
42242: LIST
42243: LIST
42244: PUSH
42245: LD_INT 2
42247: PUSH
42248: LD_INT 0
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 2
42257: PUSH
42258: LD_INT 1
42260: PUSH
42261: EMPTY
42262: LIST
42263: LIST
42264: PUSH
42265: LD_INT 2
42267: PUSH
42268: LD_INT 2
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 1
42277: PUSH
42278: LD_INT 2
42280: PUSH
42281: EMPTY
42282: LIST
42283: LIST
42284: PUSH
42285: LD_INT 0
42287: PUSH
42288: LD_INT 2
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 1
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 2
42308: NEG
42309: PUSH
42310: LD_INT 0
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 2
42319: NEG
42320: PUSH
42321: LD_INT 1
42323: NEG
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 2
42331: NEG
42332: PUSH
42333: LD_INT 2
42335: NEG
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: LIST
42345: LIST
42346: LIST
42347: LIST
42348: LIST
42349: LIST
42350: LIST
42351: LIST
42352: LIST
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42362: LD_ADDR_VAR 0 55
42366: PUSH
42367: LD_INT 0
42369: PUSH
42370: LD_INT 0
42372: PUSH
42373: EMPTY
42374: LIST
42375: LIST
42376: PUSH
42377: LD_INT 0
42379: PUSH
42380: LD_INT 1
42382: NEG
42383: PUSH
42384: EMPTY
42385: LIST
42386: LIST
42387: PUSH
42388: LD_INT 1
42390: PUSH
42391: LD_INT 0
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 1
42400: PUSH
42401: LD_INT 1
42403: PUSH
42404: EMPTY
42405: LIST
42406: LIST
42407: PUSH
42408: LD_INT 0
42410: PUSH
42411: LD_INT 1
42413: PUSH
42414: EMPTY
42415: LIST
42416: LIST
42417: PUSH
42418: LD_INT 1
42420: NEG
42421: PUSH
42422: LD_INT 0
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 1
42431: NEG
42432: PUSH
42433: LD_INT 1
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 1
42443: NEG
42444: PUSH
42445: LD_INT 2
42447: NEG
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 0
42455: PUSH
42456: LD_INT 2
42458: NEG
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 1
42466: PUSH
42467: LD_INT 1
42469: NEG
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 2
42477: PUSH
42478: LD_INT 0
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 2
42487: PUSH
42488: LD_INT 1
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: LD_INT 2
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 1
42507: PUSH
42508: LD_INT 2
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 0
42517: PUSH
42518: LD_INT 2
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 1
42527: NEG
42528: PUSH
42529: LD_INT 1
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PUSH
42536: LD_INT 2
42538: NEG
42539: PUSH
42540: LD_INT 0
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 2
42549: NEG
42550: PUSH
42551: LD_INT 1
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 2
42561: NEG
42562: PUSH
42563: LD_INT 2
42565: NEG
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: LIST
42575: LIST
42576: LIST
42577: LIST
42578: LIST
42579: LIST
42580: LIST
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: LIST
42588: LIST
42589: LIST
42590: LIST
42591: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42592: LD_ADDR_VAR 0 56
42596: PUSH
42597: LD_INT 0
42599: PUSH
42600: LD_INT 0
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 0
42609: PUSH
42610: LD_INT 1
42612: NEG
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 1
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: LD_INT 1
42630: PUSH
42631: LD_INT 1
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 0
42640: PUSH
42641: LD_INT 1
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: LD_INT 1
42650: NEG
42651: PUSH
42652: LD_INT 0
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: LD_INT 1
42661: NEG
42662: PUSH
42663: LD_INT 1
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 1
42673: NEG
42674: PUSH
42675: LD_INT 2
42677: NEG
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 0
42685: PUSH
42686: LD_INT 2
42688: NEG
42689: PUSH
42690: EMPTY
42691: LIST
42692: LIST
42693: PUSH
42694: LD_INT 1
42696: PUSH
42697: LD_INT 1
42699: NEG
42700: PUSH
42701: EMPTY
42702: LIST
42703: LIST
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: LD_INT 0
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: PUSH
42715: LD_INT 2
42717: PUSH
42718: LD_INT 1
42720: PUSH
42721: EMPTY
42722: LIST
42723: LIST
42724: PUSH
42725: LD_INT 2
42727: PUSH
42728: LD_INT 2
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: LD_INT 1
42737: PUSH
42738: LD_INT 2
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 0
42747: PUSH
42748: LD_INT 2
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 1
42757: NEG
42758: PUSH
42759: LD_INT 1
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 2
42768: NEG
42769: PUSH
42770: LD_INT 0
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 2
42779: NEG
42780: PUSH
42781: LD_INT 1
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 2
42791: NEG
42792: PUSH
42793: LD_INT 2
42795: NEG
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: LIST
42805: LIST
42806: LIST
42807: LIST
42808: LIST
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42822: LD_ADDR_VAR 0 57
42826: PUSH
42827: LD_INT 0
42829: PUSH
42830: LD_INT 0
42832: PUSH
42833: EMPTY
42834: LIST
42835: LIST
42836: PUSH
42837: LD_INT 0
42839: PUSH
42840: LD_INT 1
42842: NEG
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: PUSH
42848: LD_INT 1
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: LD_INT 1
42860: PUSH
42861: LD_INT 1
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 0
42870: PUSH
42871: LD_INT 1
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 1
42880: NEG
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: LD_INT 1
42891: NEG
42892: PUSH
42893: LD_INT 1
42895: NEG
42896: PUSH
42897: EMPTY
42898: LIST
42899: LIST
42900: PUSH
42901: LD_INT 1
42903: NEG
42904: PUSH
42905: LD_INT 2
42907: NEG
42908: PUSH
42909: EMPTY
42910: LIST
42911: LIST
42912: PUSH
42913: LD_INT 0
42915: PUSH
42916: LD_INT 2
42918: NEG
42919: PUSH
42920: EMPTY
42921: LIST
42922: LIST
42923: PUSH
42924: LD_INT 1
42926: PUSH
42927: LD_INT 1
42929: NEG
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 2
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 1
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 2
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 1
42967: PUSH
42968: LD_INT 2
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 0
42977: PUSH
42978: LD_INT 2
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: LD_INT 1
42987: NEG
42988: PUSH
42989: LD_INT 1
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: NEG
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 2
43009: NEG
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: NEG
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: LIST
43035: LIST
43036: LIST
43037: LIST
43038: LIST
43039: LIST
43040: LIST
43041: LIST
43042: LIST
43043: LIST
43044: LIST
43045: LIST
43046: LIST
43047: LIST
43048: LIST
43049: LIST
43050: LIST
43051: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43052: LD_ADDR_VAR 0 58
43056: PUSH
43057: LD_INT 0
43059: PUSH
43060: LD_INT 0
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: LD_INT 0
43069: PUSH
43070: LD_INT 1
43072: NEG
43073: PUSH
43074: EMPTY
43075: LIST
43076: LIST
43077: PUSH
43078: LD_INT 1
43080: PUSH
43081: LD_INT 0
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: PUSH
43088: LD_INT 1
43090: PUSH
43091: LD_INT 1
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 0
43100: PUSH
43101: LD_INT 1
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 1
43110: NEG
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 1
43121: NEG
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: LD_INT 1
43133: NEG
43134: PUSH
43135: LD_INT 2
43137: NEG
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 0
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 1
43156: PUSH
43157: LD_INT 1
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 2
43167: PUSH
43168: LD_INT 0
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 2
43177: PUSH
43178: LD_INT 1
43180: PUSH
43181: EMPTY
43182: LIST
43183: LIST
43184: PUSH
43185: LD_INT 2
43187: PUSH
43188: LD_INT 2
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: PUSH
43195: LD_INT 1
43197: PUSH
43198: LD_INT 2
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 0
43207: PUSH
43208: LD_INT 2
43210: PUSH
43211: EMPTY
43212: LIST
43213: LIST
43214: PUSH
43215: LD_INT 1
43217: NEG
43218: PUSH
43219: LD_INT 1
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: PUSH
43226: LD_INT 2
43228: NEG
43229: PUSH
43230: LD_INT 0
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 2
43239: NEG
43240: PUSH
43241: LD_INT 1
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 2
43251: NEG
43252: PUSH
43253: LD_INT 2
43255: NEG
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: EMPTY
43262: LIST
43263: LIST
43264: LIST
43265: LIST
43266: LIST
43267: LIST
43268: LIST
43269: LIST
43270: LIST
43271: LIST
43272: LIST
43273: LIST
43274: LIST
43275: LIST
43276: LIST
43277: LIST
43278: LIST
43279: LIST
43280: LIST
43281: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43282: LD_ADDR_VAR 0 59
43286: PUSH
43287: LD_INT 0
43289: PUSH
43290: LD_INT 0
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 0
43299: PUSH
43300: LD_INT 1
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 1
43310: PUSH
43311: LD_INT 0
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 1
43320: PUSH
43321: LD_INT 1
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: LD_INT 0
43330: PUSH
43331: LD_INT 1
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: PUSH
43338: LD_INT 1
43340: NEG
43341: PUSH
43342: LD_INT 0
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: EMPTY
43358: LIST
43359: LIST
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43370: LD_ADDR_VAR 0 60
43374: PUSH
43375: LD_INT 0
43377: PUSH
43378: LD_INT 0
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PUSH
43385: LD_INT 0
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: EMPTY
43393: LIST
43394: LIST
43395: PUSH
43396: LD_INT 1
43398: PUSH
43399: LD_INT 0
43401: PUSH
43402: EMPTY
43403: LIST
43404: LIST
43405: PUSH
43406: LD_INT 1
43408: PUSH
43409: LD_INT 1
43411: PUSH
43412: EMPTY
43413: LIST
43414: LIST
43415: PUSH
43416: LD_INT 0
43418: PUSH
43419: LD_INT 1
43421: PUSH
43422: EMPTY
43423: LIST
43424: LIST
43425: PUSH
43426: LD_INT 1
43428: NEG
43429: PUSH
43430: LD_INT 0
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 1
43439: NEG
43440: PUSH
43441: LD_INT 1
43443: NEG
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: EMPTY
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: LIST
43456: LIST
43457: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43458: LD_ADDR_VAR 0 61
43462: PUSH
43463: LD_INT 0
43465: PUSH
43466: LD_INT 0
43468: PUSH
43469: EMPTY
43470: LIST
43471: LIST
43472: PUSH
43473: LD_INT 0
43475: PUSH
43476: LD_INT 1
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 1
43486: PUSH
43487: LD_INT 0
43489: PUSH
43490: EMPTY
43491: LIST
43492: LIST
43493: PUSH
43494: LD_INT 1
43496: PUSH
43497: LD_INT 1
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: PUSH
43504: LD_INT 0
43506: PUSH
43507: LD_INT 1
43509: PUSH
43510: EMPTY
43511: LIST
43512: LIST
43513: PUSH
43514: LD_INT 1
43516: NEG
43517: PUSH
43518: LD_INT 0
43520: PUSH
43521: EMPTY
43522: LIST
43523: LIST
43524: PUSH
43525: LD_INT 1
43527: NEG
43528: PUSH
43529: LD_INT 1
43531: NEG
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43546: LD_ADDR_VAR 0 62
43550: PUSH
43551: LD_INT 0
43553: PUSH
43554: LD_INT 0
43556: PUSH
43557: EMPTY
43558: LIST
43559: LIST
43560: PUSH
43561: LD_INT 0
43563: PUSH
43564: LD_INT 1
43566: NEG
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 1
43574: PUSH
43575: LD_INT 0
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 1
43584: PUSH
43585: LD_INT 1
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: LD_INT 0
43594: PUSH
43595: LD_INT 1
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 1
43604: NEG
43605: PUSH
43606: LD_INT 0
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 1
43615: NEG
43616: PUSH
43617: LD_INT 1
43619: NEG
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: LIST
43629: LIST
43630: LIST
43631: LIST
43632: LIST
43633: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43634: LD_ADDR_VAR 0 63
43638: PUSH
43639: LD_INT 0
43641: PUSH
43642: LD_INT 0
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 0
43651: PUSH
43652: LD_INT 1
43654: NEG
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: LD_INT 1
43662: PUSH
43663: LD_INT 0
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PUSH
43670: LD_INT 1
43672: PUSH
43673: LD_INT 1
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 0
43682: PUSH
43683: LD_INT 1
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: LD_INT 1
43692: NEG
43693: PUSH
43694: LD_INT 0
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 1
43703: NEG
43704: PUSH
43705: LD_INT 1
43707: NEG
43708: PUSH
43709: EMPTY
43710: LIST
43711: LIST
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43722: LD_ADDR_VAR 0 64
43726: PUSH
43727: LD_INT 0
43729: PUSH
43730: LD_INT 0
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 0
43739: PUSH
43740: LD_INT 1
43742: NEG
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 1
43750: PUSH
43751: LD_INT 0
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 1
43760: PUSH
43761: LD_INT 1
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 0
43770: PUSH
43771: LD_INT 1
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 0
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 1
43791: NEG
43792: PUSH
43793: LD_INT 1
43795: NEG
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: LIST
43805: LIST
43806: LIST
43807: LIST
43808: LIST
43809: ST_TO_ADDR
// end ; 1 :
43810: GO 49707
43812: LD_INT 1
43814: DOUBLE
43815: EQUAL
43816: IFTRUE 43820
43818: GO 46443
43820: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43821: LD_ADDR_VAR 0 11
43825: PUSH
43826: LD_INT 1
43828: NEG
43829: PUSH
43830: LD_INT 3
43832: NEG
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 0
43840: PUSH
43841: LD_INT 3
43843: NEG
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 1
43851: PUSH
43852: LD_INT 2
43854: NEG
43855: PUSH
43856: EMPTY
43857: LIST
43858: LIST
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: LIST
43864: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43865: LD_ADDR_VAR 0 12
43869: PUSH
43870: LD_INT 2
43872: PUSH
43873: LD_INT 1
43875: NEG
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 3
43883: PUSH
43884: LD_INT 0
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 3
43893: PUSH
43894: LD_INT 1
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: LIST
43905: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43906: LD_ADDR_VAR 0 13
43910: PUSH
43911: LD_INT 3
43913: PUSH
43914: LD_INT 2
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: LD_INT 3
43923: PUSH
43924: LD_INT 3
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: PUSH
43931: LD_INT 2
43933: PUSH
43934: LD_INT 3
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: EMPTY
43942: LIST
43943: LIST
43944: LIST
43945: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43946: LD_ADDR_VAR 0 14
43950: PUSH
43951: LD_INT 1
43953: PUSH
43954: LD_INT 3
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 0
43963: PUSH
43964: LD_INT 3
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 1
43973: NEG
43974: PUSH
43975: LD_INT 2
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: PUSH
43982: EMPTY
43983: LIST
43984: LIST
43985: LIST
43986: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43987: LD_ADDR_VAR 0 15
43991: PUSH
43992: LD_INT 2
43994: NEG
43995: PUSH
43996: LD_INT 1
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: LD_INT 0
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 3
44016: NEG
44017: PUSH
44018: LD_INT 1
44020: NEG
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: LIST
44030: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44031: LD_ADDR_VAR 0 16
44035: PUSH
44036: LD_INT 2
44038: NEG
44039: PUSH
44040: LD_INT 3
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 3
44050: NEG
44051: PUSH
44052: LD_INT 2
44054: NEG
44055: PUSH
44056: EMPTY
44057: LIST
44058: LIST
44059: PUSH
44060: LD_INT 3
44062: NEG
44063: PUSH
44064: LD_INT 3
44066: NEG
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: EMPTY
44073: LIST
44074: LIST
44075: LIST
44076: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44077: LD_ADDR_VAR 0 17
44081: PUSH
44082: LD_INT 1
44084: NEG
44085: PUSH
44086: LD_INT 3
44088: NEG
44089: PUSH
44090: EMPTY
44091: LIST
44092: LIST
44093: PUSH
44094: LD_INT 0
44096: PUSH
44097: LD_INT 3
44099: NEG
44100: PUSH
44101: EMPTY
44102: LIST
44103: LIST
44104: PUSH
44105: LD_INT 1
44107: PUSH
44108: LD_INT 2
44110: NEG
44111: PUSH
44112: EMPTY
44113: LIST
44114: LIST
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: LIST
44120: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44121: LD_ADDR_VAR 0 18
44125: PUSH
44126: LD_INT 2
44128: PUSH
44129: LD_INT 1
44131: NEG
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 3
44139: PUSH
44140: LD_INT 0
44142: PUSH
44143: EMPTY
44144: LIST
44145: LIST
44146: PUSH
44147: LD_INT 3
44149: PUSH
44150: LD_INT 1
44152: PUSH
44153: EMPTY
44154: LIST
44155: LIST
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: LIST
44161: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44162: LD_ADDR_VAR 0 19
44166: PUSH
44167: LD_INT 3
44169: PUSH
44170: LD_INT 2
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 3
44179: PUSH
44180: LD_INT 3
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 2
44189: PUSH
44190: LD_INT 3
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: LIST
44201: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44202: LD_ADDR_VAR 0 20
44206: PUSH
44207: LD_INT 1
44209: PUSH
44210: LD_INT 3
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: LD_INT 0
44219: PUSH
44220: LD_INT 3
44222: PUSH
44223: EMPTY
44224: LIST
44225: LIST
44226: PUSH
44227: LD_INT 1
44229: NEG
44230: PUSH
44231: LD_INT 2
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: LIST
44242: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44243: LD_ADDR_VAR 0 21
44247: PUSH
44248: LD_INT 2
44250: NEG
44251: PUSH
44252: LD_INT 1
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: LD_INT 3
44261: NEG
44262: PUSH
44263: LD_INT 0
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 3
44272: NEG
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: LIST
44286: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44287: LD_ADDR_VAR 0 22
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: LD_INT 3
44298: NEG
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 3
44306: NEG
44307: PUSH
44308: LD_INT 2
44310: NEG
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 3
44318: NEG
44319: PUSH
44320: LD_INT 3
44322: NEG
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: PUSH
44328: EMPTY
44329: LIST
44330: LIST
44331: LIST
44332: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
44333: LD_ADDR_VAR 0 23
44337: PUSH
44338: LD_INT 0
44340: PUSH
44341: LD_INT 3
44343: NEG
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 1
44351: NEG
44352: PUSH
44353: LD_INT 4
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 1
44363: PUSH
44364: LD_INT 3
44366: NEG
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: LIST
44376: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
44377: LD_ADDR_VAR 0 24
44381: PUSH
44382: LD_INT 3
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 3
44394: PUSH
44395: LD_INT 1
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 4
44405: PUSH
44406: LD_INT 1
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: PUSH
44413: EMPTY
44414: LIST
44415: LIST
44416: LIST
44417: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44418: LD_ADDR_VAR 0 25
44422: PUSH
44423: LD_INT 3
44425: PUSH
44426: LD_INT 3
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 4
44435: PUSH
44436: LD_INT 3
44438: PUSH
44439: EMPTY
44440: LIST
44441: LIST
44442: PUSH
44443: LD_INT 3
44445: PUSH
44446: LD_INT 4
44448: PUSH
44449: EMPTY
44450: LIST
44451: LIST
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: LIST
44457: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44458: LD_ADDR_VAR 0 26
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 3
44468: PUSH
44469: EMPTY
44470: LIST
44471: LIST
44472: PUSH
44473: LD_INT 1
44475: PUSH
44476: LD_INT 4
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 1
44485: NEG
44486: PUSH
44487: LD_INT 3
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: LIST
44498: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44499: LD_ADDR_VAR 0 27
44503: PUSH
44504: LD_INT 3
44506: NEG
44507: PUSH
44508: LD_INT 0
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 3
44517: NEG
44518: PUSH
44519: LD_INT 1
44521: PUSH
44522: EMPTY
44523: LIST
44524: LIST
44525: PUSH
44526: LD_INT 4
44528: NEG
44529: PUSH
44530: LD_INT 1
44532: NEG
44533: PUSH
44534: EMPTY
44535: LIST
44536: LIST
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: LIST
44542: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44543: LD_ADDR_VAR 0 28
44547: PUSH
44548: LD_INT 3
44550: NEG
44551: PUSH
44552: LD_INT 3
44554: NEG
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 3
44562: NEG
44563: PUSH
44564: LD_INT 4
44566: NEG
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 4
44574: NEG
44575: PUSH
44576: LD_INT 3
44578: NEG
44579: PUSH
44580: EMPTY
44581: LIST
44582: LIST
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: LIST
44588: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44589: LD_ADDR_VAR 0 29
44593: PUSH
44594: LD_INT 1
44596: NEG
44597: PUSH
44598: LD_INT 3
44600: NEG
44601: PUSH
44602: EMPTY
44603: LIST
44604: LIST
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 3
44611: NEG
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 1
44619: PUSH
44620: LD_INT 2
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 1
44630: NEG
44631: PUSH
44632: LD_INT 4
44634: NEG
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 1
44653: PUSH
44654: LD_INT 3
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: NEG
44665: PUSH
44666: LD_INT 5
44668: NEG
44669: PUSH
44670: EMPTY
44671: LIST
44672: LIST
44673: PUSH
44674: LD_INT 0
44676: PUSH
44677: LD_INT 5
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 1
44687: PUSH
44688: LD_INT 4
44690: NEG
44691: PUSH
44692: EMPTY
44693: LIST
44694: LIST
44695: PUSH
44696: LD_INT 1
44698: NEG
44699: PUSH
44700: LD_INT 6
44702: NEG
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 0
44710: PUSH
44711: LD_INT 6
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 1
44721: PUSH
44722: LD_INT 5
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: LIST
44734: LIST
44735: LIST
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44744: LD_ADDR_VAR 0 30
44748: PUSH
44749: LD_INT 2
44751: PUSH
44752: LD_INT 1
44754: NEG
44755: PUSH
44756: EMPTY
44757: LIST
44758: LIST
44759: PUSH
44760: LD_INT 3
44762: PUSH
44763: LD_INT 0
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 3
44772: PUSH
44773: LD_INT 1
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 3
44782: PUSH
44783: LD_INT 1
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 4
44793: PUSH
44794: LD_INT 0
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 4
44803: PUSH
44804: LD_INT 1
44806: PUSH
44807: EMPTY
44808: LIST
44809: LIST
44810: PUSH
44811: LD_INT 4
44813: PUSH
44814: LD_INT 1
44816: NEG
44817: PUSH
44818: EMPTY
44819: LIST
44820: LIST
44821: PUSH
44822: LD_INT 5
44824: PUSH
44825: LD_INT 0
44827: PUSH
44828: EMPTY
44829: LIST
44830: LIST
44831: PUSH
44832: LD_INT 5
44834: PUSH
44835: LD_INT 1
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 5
44844: PUSH
44845: LD_INT 1
44847: NEG
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 6
44855: PUSH
44856: LD_INT 0
44858: PUSH
44859: EMPTY
44860: LIST
44861: LIST
44862: PUSH
44863: LD_INT 6
44865: PUSH
44866: LD_INT 1
44868: PUSH
44869: EMPTY
44870: LIST
44871: LIST
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: LIST
44877: LIST
44878: LIST
44879: LIST
44880: LIST
44881: LIST
44882: LIST
44883: LIST
44884: LIST
44885: LIST
44886: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44887: LD_ADDR_VAR 0 31
44891: PUSH
44892: LD_INT 3
44894: PUSH
44895: LD_INT 2
44897: PUSH
44898: EMPTY
44899: LIST
44900: LIST
44901: PUSH
44902: LD_INT 3
44904: PUSH
44905: LD_INT 3
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 2
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 4
44924: PUSH
44925: LD_INT 3
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 4
44934: PUSH
44935: LD_INT 4
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 3
44944: PUSH
44945: LD_INT 4
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: LD_INT 5
44954: PUSH
44955: LD_INT 4
44957: PUSH
44958: EMPTY
44959: LIST
44960: LIST
44961: PUSH
44962: LD_INT 5
44964: PUSH
44965: LD_INT 5
44967: PUSH
44968: EMPTY
44969: LIST
44970: LIST
44971: PUSH
44972: LD_INT 4
44974: PUSH
44975: LD_INT 5
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 6
44984: PUSH
44985: LD_INT 5
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: LD_INT 6
44994: PUSH
44995: LD_INT 6
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 5
45004: PUSH
45005: LD_INT 6
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
45026: LD_ADDR_VAR 0 32
45030: PUSH
45031: LD_INT 1
45033: PUSH
45034: LD_INT 3
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 0
45043: PUSH
45044: LD_INT 3
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 1
45053: NEG
45054: PUSH
45055: LD_INT 2
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 1
45064: PUSH
45065: LD_INT 4
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: LD_INT 0
45074: PUSH
45075: LD_INT 4
45077: PUSH
45078: EMPTY
45079: LIST
45080: LIST
45081: PUSH
45082: LD_INT 1
45084: NEG
45085: PUSH
45086: LD_INT 3
45088: PUSH
45089: EMPTY
45090: LIST
45091: LIST
45092: PUSH
45093: LD_INT 1
45095: PUSH
45096: LD_INT 5
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: LD_INT 5
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 1
45115: NEG
45116: PUSH
45117: LD_INT 4
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 1
45126: PUSH
45127: LD_INT 6
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 0
45136: PUSH
45137: LD_INT 6
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: LD_INT 1
45146: NEG
45147: PUSH
45148: LD_INT 5
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
45169: LD_ADDR_VAR 0 33
45173: PUSH
45174: LD_INT 2
45176: NEG
45177: PUSH
45178: LD_INT 1
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 3
45187: NEG
45188: PUSH
45189: LD_INT 0
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 3
45198: NEG
45199: PUSH
45200: LD_INT 1
45202: NEG
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 3
45210: NEG
45211: PUSH
45212: LD_INT 1
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 4
45221: NEG
45222: PUSH
45223: LD_INT 0
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PUSH
45230: LD_INT 4
45232: NEG
45233: PUSH
45234: LD_INT 1
45236: NEG
45237: PUSH
45238: EMPTY
45239: LIST
45240: LIST
45241: PUSH
45242: LD_INT 4
45244: NEG
45245: PUSH
45246: LD_INT 1
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: LD_INT 5
45255: NEG
45256: PUSH
45257: LD_INT 0
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 5
45266: NEG
45267: PUSH
45268: LD_INT 1
45270: NEG
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PUSH
45276: LD_INT 5
45278: NEG
45279: PUSH
45280: LD_INT 1
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 6
45289: NEG
45290: PUSH
45291: LD_INT 0
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 6
45300: NEG
45301: PUSH
45302: LD_INT 1
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
45324: LD_ADDR_VAR 0 34
45328: PUSH
45329: LD_INT 2
45331: NEG
45332: PUSH
45333: LD_INT 3
45335: NEG
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 3
45343: NEG
45344: PUSH
45345: LD_INT 2
45347: NEG
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 3
45355: NEG
45356: PUSH
45357: LD_INT 3
45359: NEG
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: LD_INT 3
45367: NEG
45368: PUSH
45369: LD_INT 4
45371: NEG
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 4
45379: NEG
45380: PUSH
45381: LD_INT 3
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 4
45391: NEG
45392: PUSH
45393: LD_INT 4
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 4
45403: NEG
45404: PUSH
45405: LD_INT 5
45407: NEG
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 5
45415: NEG
45416: PUSH
45417: LD_INT 4
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: LD_INT 5
45427: NEG
45428: PUSH
45429: LD_INT 5
45431: NEG
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 5
45439: NEG
45440: PUSH
45441: LD_INT 6
45443: NEG
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 6
45451: NEG
45452: PUSH
45453: LD_INT 5
45455: NEG
45456: PUSH
45457: EMPTY
45458: LIST
45459: LIST
45460: PUSH
45461: LD_INT 6
45463: NEG
45464: PUSH
45465: LD_INT 6
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: EMPTY
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45487: LD_ADDR_VAR 0 41
45491: PUSH
45492: LD_INT 0
45494: PUSH
45495: LD_INT 2
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: NEG
45506: PUSH
45507: LD_INT 3
45509: NEG
45510: PUSH
45511: EMPTY
45512: LIST
45513: LIST
45514: PUSH
45515: LD_INT 1
45517: PUSH
45518: LD_INT 2
45520: NEG
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: LIST
45530: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45531: LD_ADDR_VAR 0 42
45535: PUSH
45536: LD_INT 2
45538: PUSH
45539: LD_INT 0
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: PUSH
45546: LD_INT 2
45548: PUSH
45549: LD_INT 1
45551: NEG
45552: PUSH
45553: EMPTY
45554: LIST
45555: LIST
45556: PUSH
45557: LD_INT 3
45559: PUSH
45560: LD_INT 1
45562: PUSH
45563: EMPTY
45564: LIST
45565: LIST
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: LIST
45571: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45572: LD_ADDR_VAR 0 43
45576: PUSH
45577: LD_INT 2
45579: PUSH
45580: LD_INT 2
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 3
45589: PUSH
45590: LD_INT 2
45592: PUSH
45593: EMPTY
45594: LIST
45595: LIST
45596: PUSH
45597: LD_INT 2
45599: PUSH
45600: LD_INT 3
45602: PUSH
45603: EMPTY
45604: LIST
45605: LIST
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: LIST
45611: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45612: LD_ADDR_VAR 0 44
45616: PUSH
45617: LD_INT 0
45619: PUSH
45620: LD_INT 2
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: PUSH
45627: LD_INT 1
45629: PUSH
45630: LD_INT 3
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 1
45639: NEG
45640: PUSH
45641: LD_INT 2
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: EMPTY
45649: LIST
45650: LIST
45651: LIST
45652: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45653: LD_ADDR_VAR 0 45
45657: PUSH
45658: LD_INT 2
45660: NEG
45661: PUSH
45662: LD_INT 0
45664: PUSH
45665: EMPTY
45666: LIST
45667: LIST
45668: PUSH
45669: LD_INT 2
45671: NEG
45672: PUSH
45673: LD_INT 1
45675: PUSH
45676: EMPTY
45677: LIST
45678: LIST
45679: PUSH
45680: LD_INT 3
45682: NEG
45683: PUSH
45684: LD_INT 1
45686: NEG
45687: PUSH
45688: EMPTY
45689: LIST
45690: LIST
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: LIST
45696: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45697: LD_ADDR_VAR 0 46
45701: PUSH
45702: LD_INT 2
45704: NEG
45705: PUSH
45706: LD_INT 2
45708: NEG
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 2
45716: NEG
45717: PUSH
45718: LD_INT 3
45720: NEG
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 3
45728: NEG
45729: PUSH
45730: LD_INT 2
45732: NEG
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: LIST
45742: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45743: LD_ADDR_VAR 0 47
45747: PUSH
45748: LD_INT 2
45750: NEG
45751: PUSH
45752: LD_INT 3
45754: NEG
45755: PUSH
45756: EMPTY
45757: LIST
45758: LIST
45759: PUSH
45760: LD_INT 1
45762: NEG
45763: PUSH
45764: LD_INT 3
45766: NEG
45767: PUSH
45768: EMPTY
45769: LIST
45770: LIST
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45776: LD_ADDR_VAR 0 48
45780: PUSH
45781: LD_INT 1
45783: PUSH
45784: LD_INT 2
45786: NEG
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 2
45794: PUSH
45795: LD_INT 1
45797: NEG
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: EMPTY
45804: LIST
45805: LIST
45806: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45807: LD_ADDR_VAR 0 49
45811: PUSH
45812: LD_INT 3
45814: PUSH
45815: LD_INT 1
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 3
45824: PUSH
45825: LD_INT 2
45827: PUSH
45828: EMPTY
45829: LIST
45830: LIST
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45836: LD_ADDR_VAR 0 50
45840: PUSH
45841: LD_INT 2
45843: PUSH
45844: LD_INT 3
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 1
45853: PUSH
45854: LD_INT 3
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45865: LD_ADDR_VAR 0 51
45869: PUSH
45870: LD_INT 1
45872: NEG
45873: PUSH
45874: LD_INT 2
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 2
45883: NEG
45884: PUSH
45885: LD_INT 1
45887: PUSH
45888: EMPTY
45889: LIST
45890: LIST
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45896: LD_ADDR_VAR 0 52
45900: PUSH
45901: LD_INT 3
45903: NEG
45904: PUSH
45905: LD_INT 1
45907: NEG
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 3
45915: NEG
45916: PUSH
45917: LD_INT 2
45919: NEG
45920: PUSH
45921: EMPTY
45922: LIST
45923: LIST
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45929: LD_ADDR_VAR 0 53
45933: PUSH
45934: LD_INT 1
45936: NEG
45937: PUSH
45938: LD_INT 3
45940: NEG
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 0
45948: PUSH
45949: LD_INT 3
45951: NEG
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: PUSH
45957: LD_INT 1
45959: PUSH
45960: LD_INT 2
45962: NEG
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: LIST
45972: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45973: LD_ADDR_VAR 0 54
45977: PUSH
45978: LD_INT 2
45980: PUSH
45981: LD_INT 1
45983: NEG
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 3
45991: PUSH
45992: LD_INT 0
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: LD_INT 3
46001: PUSH
46002: LD_INT 1
46004: PUSH
46005: EMPTY
46006: LIST
46007: LIST
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: LIST
46013: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
46014: LD_ADDR_VAR 0 55
46018: PUSH
46019: LD_INT 3
46021: PUSH
46022: LD_INT 2
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 3
46031: PUSH
46032: LD_INT 3
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 2
46041: PUSH
46042: LD_INT 3
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: LIST
46053: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46054: LD_ADDR_VAR 0 56
46058: PUSH
46059: LD_INT 1
46061: PUSH
46062: LD_INT 3
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: LD_INT 0
46071: PUSH
46072: LD_INT 3
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 1
46081: NEG
46082: PUSH
46083: LD_INT 2
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: LIST
46094: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46095: LD_ADDR_VAR 0 57
46099: PUSH
46100: LD_INT 2
46102: NEG
46103: PUSH
46104: LD_INT 1
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 3
46113: NEG
46114: PUSH
46115: LD_INT 0
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 3
46124: NEG
46125: PUSH
46126: LD_INT 1
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: LIST
46138: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46139: LD_ADDR_VAR 0 58
46143: PUSH
46144: LD_INT 2
46146: NEG
46147: PUSH
46148: LD_INT 3
46150: NEG
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 3
46158: NEG
46159: PUSH
46160: LD_INT 2
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: NEG
46171: PUSH
46172: LD_INT 3
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: EMPTY
46181: LIST
46182: LIST
46183: LIST
46184: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
46185: LD_ADDR_VAR 0 59
46189: PUSH
46190: LD_INT 1
46192: NEG
46193: PUSH
46194: LD_INT 2
46196: NEG
46197: PUSH
46198: EMPTY
46199: LIST
46200: LIST
46201: PUSH
46202: LD_INT 0
46204: PUSH
46205: LD_INT 2
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 1
46215: PUSH
46216: LD_INT 1
46218: NEG
46219: PUSH
46220: EMPTY
46221: LIST
46222: LIST
46223: PUSH
46224: EMPTY
46225: LIST
46226: LIST
46227: LIST
46228: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
46229: LD_ADDR_VAR 0 60
46233: PUSH
46234: LD_INT 1
46236: PUSH
46237: LD_INT 1
46239: NEG
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 2
46247: PUSH
46248: LD_INT 0
46250: PUSH
46251: EMPTY
46252: LIST
46253: LIST
46254: PUSH
46255: LD_INT 2
46257: PUSH
46258: LD_INT 1
46260: PUSH
46261: EMPTY
46262: LIST
46263: LIST
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: LIST
46269: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
46270: LD_ADDR_VAR 0 61
46274: PUSH
46275: LD_INT 2
46277: PUSH
46278: LD_INT 1
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: LD_INT 2
46287: PUSH
46288: LD_INT 2
46290: PUSH
46291: EMPTY
46292: LIST
46293: LIST
46294: PUSH
46295: LD_INT 1
46297: PUSH
46298: LD_INT 2
46300: PUSH
46301: EMPTY
46302: LIST
46303: LIST
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: LIST
46309: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
46310: LD_ADDR_VAR 0 62
46314: PUSH
46315: LD_INT 1
46317: PUSH
46318: LD_INT 2
46320: PUSH
46321: EMPTY
46322: LIST
46323: LIST
46324: PUSH
46325: LD_INT 0
46327: PUSH
46328: LD_INT 2
46330: PUSH
46331: EMPTY
46332: LIST
46333: LIST
46334: PUSH
46335: LD_INT 1
46337: NEG
46338: PUSH
46339: LD_INT 1
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: PUSH
46346: EMPTY
46347: LIST
46348: LIST
46349: LIST
46350: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
46351: LD_ADDR_VAR 0 63
46355: PUSH
46356: LD_INT 1
46358: NEG
46359: PUSH
46360: LD_INT 1
46362: PUSH
46363: EMPTY
46364: LIST
46365: LIST
46366: PUSH
46367: LD_INT 2
46369: NEG
46370: PUSH
46371: LD_INT 0
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 2
46380: NEG
46381: PUSH
46382: LD_INT 1
46384: NEG
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: LIST
46394: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46395: LD_ADDR_VAR 0 64
46399: PUSH
46400: LD_INT 1
46402: NEG
46403: PUSH
46404: LD_INT 2
46406: NEG
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 2
46414: NEG
46415: PUSH
46416: LD_INT 1
46418: NEG
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: PUSH
46424: LD_INT 2
46426: NEG
46427: PUSH
46428: LD_INT 2
46430: NEG
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: LIST
46440: ST_TO_ADDR
// end ; 2 :
46441: GO 49707
46443: LD_INT 2
46445: DOUBLE
46446: EQUAL
46447: IFTRUE 46451
46449: GO 49706
46451: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46452: LD_ADDR_VAR 0 29
46456: PUSH
46457: LD_INT 4
46459: PUSH
46460: LD_INT 0
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: LD_INT 4
46469: PUSH
46470: LD_INT 1
46472: NEG
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 5
46480: PUSH
46481: LD_INT 0
46483: PUSH
46484: EMPTY
46485: LIST
46486: LIST
46487: PUSH
46488: LD_INT 5
46490: PUSH
46491: LD_INT 1
46493: PUSH
46494: EMPTY
46495: LIST
46496: LIST
46497: PUSH
46498: LD_INT 4
46500: PUSH
46501: LD_INT 1
46503: PUSH
46504: EMPTY
46505: LIST
46506: LIST
46507: PUSH
46508: LD_INT 3
46510: PUSH
46511: LD_INT 0
46513: PUSH
46514: EMPTY
46515: LIST
46516: LIST
46517: PUSH
46518: LD_INT 3
46520: PUSH
46521: LD_INT 1
46523: NEG
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: LD_INT 3
46531: PUSH
46532: LD_INT 2
46534: NEG
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: PUSH
46540: LD_INT 5
46542: PUSH
46543: LD_INT 2
46545: PUSH
46546: EMPTY
46547: LIST
46548: LIST
46549: PUSH
46550: LD_INT 3
46552: PUSH
46553: LD_INT 3
46555: PUSH
46556: EMPTY
46557: LIST
46558: LIST
46559: PUSH
46560: LD_INT 3
46562: PUSH
46563: LD_INT 2
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: PUSH
46570: LD_INT 4
46572: PUSH
46573: LD_INT 3
46575: PUSH
46576: EMPTY
46577: LIST
46578: LIST
46579: PUSH
46580: LD_INT 4
46582: PUSH
46583: LD_INT 4
46585: PUSH
46586: EMPTY
46587: LIST
46588: LIST
46589: PUSH
46590: LD_INT 3
46592: PUSH
46593: LD_INT 4
46595: PUSH
46596: EMPTY
46597: LIST
46598: LIST
46599: PUSH
46600: LD_INT 2
46602: PUSH
46603: LD_INT 3
46605: PUSH
46606: EMPTY
46607: LIST
46608: LIST
46609: PUSH
46610: LD_INT 2
46612: PUSH
46613: LD_INT 2
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 4
46622: PUSH
46623: LD_INT 2
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: LD_INT 2
46632: PUSH
46633: LD_INT 4
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 0
46642: PUSH
46643: LD_INT 4
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: LD_INT 0
46652: PUSH
46653: LD_INT 3
46655: PUSH
46656: EMPTY
46657: LIST
46658: LIST
46659: PUSH
46660: LD_INT 1
46662: PUSH
46663: LD_INT 4
46665: PUSH
46666: EMPTY
46667: LIST
46668: LIST
46669: PUSH
46670: LD_INT 1
46672: PUSH
46673: LD_INT 5
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PUSH
46680: LD_INT 0
46682: PUSH
46683: LD_INT 5
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 1
46692: NEG
46693: PUSH
46694: LD_INT 4
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 1
46703: NEG
46704: PUSH
46705: LD_INT 3
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: PUSH
46712: LD_INT 2
46714: PUSH
46715: LD_INT 5
46717: PUSH
46718: EMPTY
46719: LIST
46720: LIST
46721: PUSH
46722: LD_INT 2
46724: NEG
46725: PUSH
46726: LD_INT 3
46728: PUSH
46729: EMPTY
46730: LIST
46731: LIST
46732: PUSH
46733: LD_INT 3
46735: NEG
46736: PUSH
46737: LD_INT 0
46739: PUSH
46740: EMPTY
46741: LIST
46742: LIST
46743: PUSH
46744: LD_INT 3
46746: NEG
46747: PUSH
46748: LD_INT 1
46750: NEG
46751: PUSH
46752: EMPTY
46753: LIST
46754: LIST
46755: PUSH
46756: LD_INT 2
46758: NEG
46759: PUSH
46760: LD_INT 0
46762: PUSH
46763: EMPTY
46764: LIST
46765: LIST
46766: PUSH
46767: LD_INT 2
46769: NEG
46770: PUSH
46771: LD_INT 1
46773: PUSH
46774: EMPTY
46775: LIST
46776: LIST
46777: PUSH
46778: LD_INT 3
46780: NEG
46781: PUSH
46782: LD_INT 1
46784: PUSH
46785: EMPTY
46786: LIST
46787: LIST
46788: PUSH
46789: LD_INT 4
46791: NEG
46792: PUSH
46793: LD_INT 0
46795: PUSH
46796: EMPTY
46797: LIST
46798: LIST
46799: PUSH
46800: LD_INT 4
46802: NEG
46803: PUSH
46804: LD_INT 1
46806: NEG
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 4
46814: NEG
46815: PUSH
46816: LD_INT 2
46818: NEG
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 2
46826: NEG
46827: PUSH
46828: LD_INT 2
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 4
46837: NEG
46838: PUSH
46839: LD_INT 4
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 4
46849: NEG
46850: PUSH
46851: LD_INT 5
46853: NEG
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 3
46861: NEG
46862: PUSH
46863: LD_INT 4
46865: NEG
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 3
46873: NEG
46874: PUSH
46875: LD_INT 3
46877: NEG
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: PUSH
46883: LD_INT 4
46885: NEG
46886: PUSH
46887: LD_INT 3
46889: NEG
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: LD_INT 5
46897: NEG
46898: PUSH
46899: LD_INT 4
46901: NEG
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PUSH
46907: LD_INT 5
46909: NEG
46910: PUSH
46911: LD_INT 5
46913: NEG
46914: PUSH
46915: EMPTY
46916: LIST
46917: LIST
46918: PUSH
46919: LD_INT 3
46921: NEG
46922: PUSH
46923: LD_INT 5
46925: NEG
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 5
46933: NEG
46934: PUSH
46935: LD_INT 3
46937: NEG
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: EMPTY
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: LIST
46983: LIST
46984: LIST
46985: LIST
46986: LIST
46987: LIST
46988: LIST
46989: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46990: LD_ADDR_VAR 0 30
46994: PUSH
46995: LD_INT 4
46997: PUSH
46998: LD_INT 4
47000: PUSH
47001: EMPTY
47002: LIST
47003: LIST
47004: PUSH
47005: LD_INT 4
47007: PUSH
47008: LD_INT 3
47010: PUSH
47011: EMPTY
47012: LIST
47013: LIST
47014: PUSH
47015: LD_INT 5
47017: PUSH
47018: LD_INT 4
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: LD_INT 5
47027: PUSH
47028: LD_INT 5
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: PUSH
47035: LD_INT 4
47037: PUSH
47038: LD_INT 5
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 3
47047: PUSH
47048: LD_INT 4
47050: PUSH
47051: EMPTY
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 3
47057: PUSH
47058: LD_INT 3
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: PUSH
47065: LD_INT 5
47067: PUSH
47068: LD_INT 3
47070: PUSH
47071: EMPTY
47072: LIST
47073: LIST
47074: PUSH
47075: LD_INT 3
47077: PUSH
47078: LD_INT 5
47080: PUSH
47081: EMPTY
47082: LIST
47083: LIST
47084: PUSH
47085: LD_INT 0
47087: PUSH
47088: LD_INT 3
47090: PUSH
47091: EMPTY
47092: LIST
47093: LIST
47094: PUSH
47095: LD_INT 0
47097: PUSH
47098: LD_INT 2
47100: PUSH
47101: EMPTY
47102: LIST
47103: LIST
47104: PUSH
47105: LD_INT 1
47107: PUSH
47108: LD_INT 3
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: PUSH
47115: LD_INT 1
47117: PUSH
47118: LD_INT 4
47120: PUSH
47121: EMPTY
47122: LIST
47123: LIST
47124: PUSH
47125: LD_INT 0
47127: PUSH
47128: LD_INT 4
47130: PUSH
47131: EMPTY
47132: LIST
47133: LIST
47134: PUSH
47135: LD_INT 1
47137: NEG
47138: PUSH
47139: LD_INT 3
47141: PUSH
47142: EMPTY
47143: LIST
47144: LIST
47145: PUSH
47146: LD_INT 1
47148: NEG
47149: PUSH
47150: LD_INT 2
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 2
47159: PUSH
47160: LD_INT 4
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 2
47169: NEG
47170: PUSH
47171: LD_INT 2
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PUSH
47178: LD_INT 4
47180: NEG
47181: PUSH
47182: LD_INT 0
47184: PUSH
47185: EMPTY
47186: LIST
47187: LIST
47188: PUSH
47189: LD_INT 4
47191: NEG
47192: PUSH
47193: LD_INT 1
47195: NEG
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PUSH
47201: LD_INT 3
47203: NEG
47204: PUSH
47205: LD_INT 0
47207: PUSH
47208: EMPTY
47209: LIST
47210: LIST
47211: PUSH
47212: LD_INT 3
47214: NEG
47215: PUSH
47216: LD_INT 1
47218: PUSH
47219: EMPTY
47220: LIST
47221: LIST
47222: PUSH
47223: LD_INT 4
47225: NEG
47226: PUSH
47227: LD_INT 1
47229: PUSH
47230: EMPTY
47231: LIST
47232: LIST
47233: PUSH
47234: LD_INT 5
47236: NEG
47237: PUSH
47238: LD_INT 0
47240: PUSH
47241: EMPTY
47242: LIST
47243: LIST
47244: PUSH
47245: LD_INT 5
47247: NEG
47248: PUSH
47249: LD_INT 1
47251: NEG
47252: PUSH
47253: EMPTY
47254: LIST
47255: LIST
47256: PUSH
47257: LD_INT 5
47259: NEG
47260: PUSH
47261: LD_INT 2
47263: NEG
47264: PUSH
47265: EMPTY
47266: LIST
47267: LIST
47268: PUSH
47269: LD_INT 3
47271: NEG
47272: PUSH
47273: LD_INT 2
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 3
47282: NEG
47283: PUSH
47284: LD_INT 3
47286: NEG
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PUSH
47292: LD_INT 3
47294: NEG
47295: PUSH
47296: LD_INT 4
47298: NEG
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 2
47306: NEG
47307: PUSH
47308: LD_INT 3
47310: NEG
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 2
47318: NEG
47319: PUSH
47320: LD_INT 2
47322: NEG
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: LD_INT 3
47330: NEG
47331: PUSH
47332: LD_INT 2
47334: NEG
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 4
47342: NEG
47343: PUSH
47344: LD_INT 3
47346: NEG
47347: PUSH
47348: EMPTY
47349: LIST
47350: LIST
47351: PUSH
47352: LD_INT 4
47354: NEG
47355: PUSH
47356: LD_INT 4
47358: NEG
47359: PUSH
47360: EMPTY
47361: LIST
47362: LIST
47363: PUSH
47364: LD_INT 2
47366: NEG
47367: PUSH
47368: LD_INT 4
47370: NEG
47371: PUSH
47372: EMPTY
47373: LIST
47374: LIST
47375: PUSH
47376: LD_INT 4
47378: NEG
47379: PUSH
47380: LD_INT 2
47382: NEG
47383: PUSH
47384: EMPTY
47385: LIST
47386: LIST
47387: PUSH
47388: LD_INT 0
47390: PUSH
47391: LD_INT 4
47393: NEG
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: PUSH
47399: LD_INT 0
47401: PUSH
47402: LD_INT 5
47404: NEG
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: PUSH
47410: LD_INT 1
47412: PUSH
47413: LD_INT 4
47415: NEG
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: PUSH
47421: LD_INT 1
47423: PUSH
47424: LD_INT 3
47426: NEG
47427: PUSH
47428: EMPTY
47429: LIST
47430: LIST
47431: PUSH
47432: LD_INT 0
47434: PUSH
47435: LD_INT 3
47437: NEG
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PUSH
47443: LD_INT 1
47445: NEG
47446: PUSH
47447: LD_INT 4
47449: NEG
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: LD_INT 1
47457: NEG
47458: PUSH
47459: LD_INT 5
47461: NEG
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: PUSH
47467: LD_INT 2
47469: PUSH
47470: LD_INT 3
47472: NEG
47473: PUSH
47474: EMPTY
47475: LIST
47476: LIST
47477: PUSH
47478: LD_INT 2
47480: NEG
47481: PUSH
47482: LD_INT 5
47484: NEG
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: PUSH
47490: EMPTY
47491: LIST
47492: LIST
47493: LIST
47494: LIST
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: LIST
47502: LIST
47503: LIST
47504: LIST
47505: LIST
47506: LIST
47507: LIST
47508: LIST
47509: LIST
47510: LIST
47511: LIST
47512: LIST
47513: LIST
47514: LIST
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: LIST
47522: LIST
47523: LIST
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: LIST
47531: LIST
47532: LIST
47533: LIST
47534: LIST
47535: LIST
47536: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47537: LD_ADDR_VAR 0 31
47541: PUSH
47542: LD_INT 0
47544: PUSH
47545: LD_INT 4
47547: PUSH
47548: EMPTY
47549: LIST
47550: LIST
47551: PUSH
47552: LD_INT 0
47554: PUSH
47555: LD_INT 3
47557: PUSH
47558: EMPTY
47559: LIST
47560: LIST
47561: PUSH
47562: LD_INT 1
47564: PUSH
47565: LD_INT 4
47567: PUSH
47568: EMPTY
47569: LIST
47570: LIST
47571: PUSH
47572: LD_INT 1
47574: PUSH
47575: LD_INT 5
47577: PUSH
47578: EMPTY
47579: LIST
47580: LIST
47581: PUSH
47582: LD_INT 0
47584: PUSH
47585: LD_INT 5
47587: PUSH
47588: EMPTY
47589: LIST
47590: LIST
47591: PUSH
47592: LD_INT 1
47594: NEG
47595: PUSH
47596: LD_INT 4
47598: PUSH
47599: EMPTY
47600: LIST
47601: LIST
47602: PUSH
47603: LD_INT 1
47605: NEG
47606: PUSH
47607: LD_INT 3
47609: PUSH
47610: EMPTY
47611: LIST
47612: LIST
47613: PUSH
47614: LD_INT 2
47616: PUSH
47617: LD_INT 5
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 2
47626: NEG
47627: PUSH
47628: LD_INT 3
47630: PUSH
47631: EMPTY
47632: LIST
47633: LIST
47634: PUSH
47635: LD_INT 3
47637: NEG
47638: PUSH
47639: LD_INT 0
47641: PUSH
47642: EMPTY
47643: LIST
47644: LIST
47645: PUSH
47646: LD_INT 3
47648: NEG
47649: PUSH
47650: LD_INT 1
47652: NEG
47653: PUSH
47654: EMPTY
47655: LIST
47656: LIST
47657: PUSH
47658: LD_INT 2
47660: NEG
47661: PUSH
47662: LD_INT 0
47664: PUSH
47665: EMPTY
47666: LIST
47667: LIST
47668: PUSH
47669: LD_INT 2
47671: NEG
47672: PUSH
47673: LD_INT 1
47675: PUSH
47676: EMPTY
47677: LIST
47678: LIST
47679: PUSH
47680: LD_INT 3
47682: NEG
47683: PUSH
47684: LD_INT 1
47686: PUSH
47687: EMPTY
47688: LIST
47689: LIST
47690: PUSH
47691: LD_INT 4
47693: NEG
47694: PUSH
47695: LD_INT 0
47697: PUSH
47698: EMPTY
47699: LIST
47700: LIST
47701: PUSH
47702: LD_INT 4
47704: NEG
47705: PUSH
47706: LD_INT 1
47708: NEG
47709: PUSH
47710: EMPTY
47711: LIST
47712: LIST
47713: PUSH
47714: LD_INT 4
47716: NEG
47717: PUSH
47718: LD_INT 2
47720: NEG
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: LD_INT 2
47728: NEG
47729: PUSH
47730: LD_INT 2
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: LD_INT 4
47739: NEG
47740: PUSH
47741: LD_INT 4
47743: NEG
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 4
47751: NEG
47752: PUSH
47753: LD_INT 5
47755: NEG
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: PUSH
47761: LD_INT 3
47763: NEG
47764: PUSH
47765: LD_INT 4
47767: NEG
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 3
47775: NEG
47776: PUSH
47777: LD_INT 3
47779: NEG
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 4
47787: NEG
47788: PUSH
47789: LD_INT 3
47791: NEG
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: LD_INT 5
47799: NEG
47800: PUSH
47801: LD_INT 4
47803: NEG
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: LD_INT 5
47811: NEG
47812: PUSH
47813: LD_INT 5
47815: NEG
47816: PUSH
47817: EMPTY
47818: LIST
47819: LIST
47820: PUSH
47821: LD_INT 3
47823: NEG
47824: PUSH
47825: LD_INT 5
47827: NEG
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PUSH
47833: LD_INT 5
47835: NEG
47836: PUSH
47837: LD_INT 3
47839: NEG
47840: PUSH
47841: EMPTY
47842: LIST
47843: LIST
47844: PUSH
47845: LD_INT 0
47847: PUSH
47848: LD_INT 3
47850: NEG
47851: PUSH
47852: EMPTY
47853: LIST
47854: LIST
47855: PUSH
47856: LD_INT 0
47858: PUSH
47859: LD_INT 4
47861: NEG
47862: PUSH
47863: EMPTY
47864: LIST
47865: LIST
47866: PUSH
47867: LD_INT 1
47869: PUSH
47870: LD_INT 3
47872: NEG
47873: PUSH
47874: EMPTY
47875: LIST
47876: LIST
47877: PUSH
47878: LD_INT 1
47880: PUSH
47881: LD_INT 2
47883: NEG
47884: PUSH
47885: EMPTY
47886: LIST
47887: LIST
47888: PUSH
47889: LD_INT 0
47891: PUSH
47892: LD_INT 2
47894: NEG
47895: PUSH
47896: EMPTY
47897: LIST
47898: LIST
47899: PUSH
47900: LD_INT 1
47902: NEG
47903: PUSH
47904: LD_INT 3
47906: NEG
47907: PUSH
47908: EMPTY
47909: LIST
47910: LIST
47911: PUSH
47912: LD_INT 1
47914: NEG
47915: PUSH
47916: LD_INT 4
47918: NEG
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 2
47926: PUSH
47927: LD_INT 2
47929: NEG
47930: PUSH
47931: EMPTY
47932: LIST
47933: LIST
47934: PUSH
47935: LD_INT 2
47937: NEG
47938: PUSH
47939: LD_INT 4
47941: NEG
47942: PUSH
47943: EMPTY
47944: LIST
47945: LIST
47946: PUSH
47947: LD_INT 4
47949: PUSH
47950: LD_INT 0
47952: PUSH
47953: EMPTY
47954: LIST
47955: LIST
47956: PUSH
47957: LD_INT 4
47959: PUSH
47960: LD_INT 1
47962: NEG
47963: PUSH
47964: EMPTY
47965: LIST
47966: LIST
47967: PUSH
47968: LD_INT 5
47970: PUSH
47971: LD_INT 0
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PUSH
47978: LD_INT 5
47980: PUSH
47981: LD_INT 1
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: LD_INT 4
47990: PUSH
47991: LD_INT 1
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PUSH
47998: LD_INT 3
48000: PUSH
48001: LD_INT 0
48003: PUSH
48004: EMPTY
48005: LIST
48006: LIST
48007: PUSH
48008: LD_INT 3
48010: PUSH
48011: LD_INT 1
48013: NEG
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: PUSH
48019: LD_INT 3
48021: PUSH
48022: LD_INT 2
48024: NEG
48025: PUSH
48026: EMPTY
48027: LIST
48028: LIST
48029: PUSH
48030: LD_INT 5
48032: PUSH
48033: LD_INT 2
48035: PUSH
48036: EMPTY
48037: LIST
48038: LIST
48039: PUSH
48040: EMPTY
48041: LIST
48042: LIST
48043: LIST
48044: LIST
48045: LIST
48046: LIST
48047: LIST
48048: LIST
48049: LIST
48050: LIST
48051: LIST
48052: LIST
48053: LIST
48054: LIST
48055: LIST
48056: LIST
48057: LIST
48058: LIST
48059: LIST
48060: LIST
48061: LIST
48062: LIST
48063: LIST
48064: LIST
48065: LIST
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: LIST
48072: LIST
48073: LIST
48074: LIST
48075: LIST
48076: LIST
48077: LIST
48078: LIST
48079: LIST
48080: LIST
48081: LIST
48082: LIST
48083: LIST
48084: LIST
48085: LIST
48086: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
48087: LD_ADDR_VAR 0 32
48091: PUSH
48092: LD_INT 4
48094: NEG
48095: PUSH
48096: LD_INT 0
48098: PUSH
48099: EMPTY
48100: LIST
48101: LIST
48102: PUSH
48103: LD_INT 4
48105: NEG
48106: PUSH
48107: LD_INT 1
48109: NEG
48110: PUSH
48111: EMPTY
48112: LIST
48113: LIST
48114: PUSH
48115: LD_INT 3
48117: NEG
48118: PUSH
48119: LD_INT 0
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: LD_INT 3
48128: NEG
48129: PUSH
48130: LD_INT 1
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PUSH
48137: LD_INT 4
48139: NEG
48140: PUSH
48141: LD_INT 1
48143: PUSH
48144: EMPTY
48145: LIST
48146: LIST
48147: PUSH
48148: LD_INT 5
48150: NEG
48151: PUSH
48152: LD_INT 0
48154: PUSH
48155: EMPTY
48156: LIST
48157: LIST
48158: PUSH
48159: LD_INT 5
48161: NEG
48162: PUSH
48163: LD_INT 1
48165: NEG
48166: PUSH
48167: EMPTY
48168: LIST
48169: LIST
48170: PUSH
48171: LD_INT 5
48173: NEG
48174: PUSH
48175: LD_INT 2
48177: NEG
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 3
48185: NEG
48186: PUSH
48187: LD_INT 2
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 3
48196: NEG
48197: PUSH
48198: LD_INT 3
48200: NEG
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PUSH
48206: LD_INT 3
48208: NEG
48209: PUSH
48210: LD_INT 4
48212: NEG
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 2
48220: NEG
48221: PUSH
48222: LD_INT 3
48224: NEG
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: PUSH
48230: LD_INT 2
48232: NEG
48233: PUSH
48234: LD_INT 2
48236: NEG
48237: PUSH
48238: EMPTY
48239: LIST
48240: LIST
48241: PUSH
48242: LD_INT 3
48244: NEG
48245: PUSH
48246: LD_INT 2
48248: NEG
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 4
48256: NEG
48257: PUSH
48258: LD_INT 3
48260: NEG
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PUSH
48266: LD_INT 4
48268: NEG
48269: PUSH
48270: LD_INT 4
48272: NEG
48273: PUSH
48274: EMPTY
48275: LIST
48276: LIST
48277: PUSH
48278: LD_INT 2
48280: NEG
48281: PUSH
48282: LD_INT 4
48284: NEG
48285: PUSH
48286: EMPTY
48287: LIST
48288: LIST
48289: PUSH
48290: LD_INT 4
48292: NEG
48293: PUSH
48294: LD_INT 2
48296: NEG
48297: PUSH
48298: EMPTY
48299: LIST
48300: LIST
48301: PUSH
48302: LD_INT 0
48304: PUSH
48305: LD_INT 4
48307: NEG
48308: PUSH
48309: EMPTY
48310: LIST
48311: LIST
48312: PUSH
48313: LD_INT 0
48315: PUSH
48316: LD_INT 5
48318: NEG
48319: PUSH
48320: EMPTY
48321: LIST
48322: LIST
48323: PUSH
48324: LD_INT 1
48326: PUSH
48327: LD_INT 4
48329: NEG
48330: PUSH
48331: EMPTY
48332: LIST
48333: LIST
48334: PUSH
48335: LD_INT 1
48337: PUSH
48338: LD_INT 3
48340: NEG
48341: PUSH
48342: EMPTY
48343: LIST
48344: LIST
48345: PUSH
48346: LD_INT 0
48348: PUSH
48349: LD_INT 3
48351: NEG
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: LD_INT 1
48359: NEG
48360: PUSH
48361: LD_INT 4
48363: NEG
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: LD_INT 1
48371: NEG
48372: PUSH
48373: LD_INT 5
48375: NEG
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 2
48383: PUSH
48384: LD_INT 3
48386: NEG
48387: PUSH
48388: EMPTY
48389: LIST
48390: LIST
48391: PUSH
48392: LD_INT 2
48394: NEG
48395: PUSH
48396: LD_INT 5
48398: NEG
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 3
48406: PUSH
48407: LD_INT 0
48409: PUSH
48410: EMPTY
48411: LIST
48412: LIST
48413: PUSH
48414: LD_INT 3
48416: PUSH
48417: LD_INT 1
48419: NEG
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PUSH
48425: LD_INT 4
48427: PUSH
48428: LD_INT 0
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: PUSH
48435: LD_INT 4
48437: PUSH
48438: LD_INT 1
48440: PUSH
48441: EMPTY
48442: LIST
48443: LIST
48444: PUSH
48445: LD_INT 3
48447: PUSH
48448: LD_INT 1
48450: PUSH
48451: EMPTY
48452: LIST
48453: LIST
48454: PUSH
48455: LD_INT 2
48457: PUSH
48458: LD_INT 0
48460: PUSH
48461: EMPTY
48462: LIST
48463: LIST
48464: PUSH
48465: LD_INT 2
48467: PUSH
48468: LD_INT 1
48470: NEG
48471: PUSH
48472: EMPTY
48473: LIST
48474: LIST
48475: PUSH
48476: LD_INT 2
48478: PUSH
48479: LD_INT 2
48481: NEG
48482: PUSH
48483: EMPTY
48484: LIST
48485: LIST
48486: PUSH
48487: LD_INT 4
48489: PUSH
48490: LD_INT 2
48492: PUSH
48493: EMPTY
48494: LIST
48495: LIST
48496: PUSH
48497: LD_INT 4
48499: PUSH
48500: LD_INT 4
48502: PUSH
48503: EMPTY
48504: LIST
48505: LIST
48506: PUSH
48507: LD_INT 4
48509: PUSH
48510: LD_INT 3
48512: PUSH
48513: EMPTY
48514: LIST
48515: LIST
48516: PUSH
48517: LD_INT 5
48519: PUSH
48520: LD_INT 4
48522: PUSH
48523: EMPTY
48524: LIST
48525: LIST
48526: PUSH
48527: LD_INT 5
48529: PUSH
48530: LD_INT 5
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: LD_INT 4
48539: PUSH
48540: LD_INT 5
48542: PUSH
48543: EMPTY
48544: LIST
48545: LIST
48546: PUSH
48547: LD_INT 3
48549: PUSH
48550: LD_INT 4
48552: PUSH
48553: EMPTY
48554: LIST
48555: LIST
48556: PUSH
48557: LD_INT 3
48559: PUSH
48560: LD_INT 3
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PUSH
48567: LD_INT 5
48569: PUSH
48570: LD_INT 3
48572: PUSH
48573: EMPTY
48574: LIST
48575: LIST
48576: PUSH
48577: LD_INT 3
48579: PUSH
48580: LD_INT 5
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: LIST
48591: LIST
48592: LIST
48593: LIST
48594: LIST
48595: LIST
48596: LIST
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: LIST
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: LIST
48633: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48634: LD_ADDR_VAR 0 33
48638: PUSH
48639: LD_INT 4
48641: NEG
48642: PUSH
48643: LD_INT 4
48645: NEG
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: PUSH
48651: LD_INT 4
48653: NEG
48654: PUSH
48655: LD_INT 5
48657: NEG
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 3
48665: NEG
48666: PUSH
48667: LD_INT 4
48669: NEG
48670: PUSH
48671: EMPTY
48672: LIST
48673: LIST
48674: PUSH
48675: LD_INT 3
48677: NEG
48678: PUSH
48679: LD_INT 3
48681: NEG
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 4
48689: NEG
48690: PUSH
48691: LD_INT 3
48693: NEG
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_INT 5
48701: NEG
48702: PUSH
48703: LD_INT 4
48705: NEG
48706: PUSH
48707: EMPTY
48708: LIST
48709: LIST
48710: PUSH
48711: LD_INT 5
48713: NEG
48714: PUSH
48715: LD_INT 5
48717: NEG
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PUSH
48723: LD_INT 3
48725: NEG
48726: PUSH
48727: LD_INT 5
48729: NEG
48730: PUSH
48731: EMPTY
48732: LIST
48733: LIST
48734: PUSH
48735: LD_INT 5
48737: NEG
48738: PUSH
48739: LD_INT 3
48741: NEG
48742: PUSH
48743: EMPTY
48744: LIST
48745: LIST
48746: PUSH
48747: LD_INT 0
48749: PUSH
48750: LD_INT 3
48752: NEG
48753: PUSH
48754: EMPTY
48755: LIST
48756: LIST
48757: PUSH
48758: LD_INT 0
48760: PUSH
48761: LD_INT 4
48763: NEG
48764: PUSH
48765: EMPTY
48766: LIST
48767: LIST
48768: PUSH
48769: LD_INT 1
48771: PUSH
48772: LD_INT 3
48774: NEG
48775: PUSH
48776: EMPTY
48777: LIST
48778: LIST
48779: PUSH
48780: LD_INT 1
48782: PUSH
48783: LD_INT 2
48785: NEG
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: PUSH
48791: LD_INT 0
48793: PUSH
48794: LD_INT 2
48796: NEG
48797: PUSH
48798: EMPTY
48799: LIST
48800: LIST
48801: PUSH
48802: LD_INT 1
48804: NEG
48805: PUSH
48806: LD_INT 3
48808: NEG
48809: PUSH
48810: EMPTY
48811: LIST
48812: LIST
48813: PUSH
48814: LD_INT 1
48816: NEG
48817: PUSH
48818: LD_INT 4
48820: NEG
48821: PUSH
48822: EMPTY
48823: LIST
48824: LIST
48825: PUSH
48826: LD_INT 2
48828: PUSH
48829: LD_INT 2
48831: NEG
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: PUSH
48837: LD_INT 2
48839: NEG
48840: PUSH
48841: LD_INT 4
48843: NEG
48844: PUSH
48845: EMPTY
48846: LIST
48847: LIST
48848: PUSH
48849: LD_INT 4
48851: PUSH
48852: LD_INT 0
48854: PUSH
48855: EMPTY
48856: LIST
48857: LIST
48858: PUSH
48859: LD_INT 4
48861: PUSH
48862: LD_INT 1
48864: NEG
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 5
48872: PUSH
48873: LD_INT 0
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 5
48882: PUSH
48883: LD_INT 1
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 4
48892: PUSH
48893: LD_INT 1
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 3
48902: PUSH
48903: LD_INT 0
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: LD_INT 3
48912: PUSH
48913: LD_INT 1
48915: NEG
48916: PUSH
48917: EMPTY
48918: LIST
48919: LIST
48920: PUSH
48921: LD_INT 3
48923: PUSH
48924: LD_INT 2
48926: NEG
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PUSH
48932: LD_INT 5
48934: PUSH
48935: LD_INT 2
48937: PUSH
48938: EMPTY
48939: LIST
48940: LIST
48941: PUSH
48942: LD_INT 3
48944: PUSH
48945: LD_INT 3
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PUSH
48952: LD_INT 3
48954: PUSH
48955: LD_INT 2
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: PUSH
48962: LD_INT 4
48964: PUSH
48965: LD_INT 3
48967: PUSH
48968: EMPTY
48969: LIST
48970: LIST
48971: PUSH
48972: LD_INT 4
48974: PUSH
48975: LD_INT 4
48977: PUSH
48978: EMPTY
48979: LIST
48980: LIST
48981: PUSH
48982: LD_INT 3
48984: PUSH
48985: LD_INT 4
48987: PUSH
48988: EMPTY
48989: LIST
48990: LIST
48991: PUSH
48992: LD_INT 2
48994: PUSH
48995: LD_INT 3
48997: PUSH
48998: EMPTY
48999: LIST
49000: LIST
49001: PUSH
49002: LD_INT 2
49004: PUSH
49005: LD_INT 2
49007: PUSH
49008: EMPTY
49009: LIST
49010: LIST
49011: PUSH
49012: LD_INT 4
49014: PUSH
49015: LD_INT 2
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: PUSH
49022: LD_INT 2
49024: PUSH
49025: LD_INT 4
49027: PUSH
49028: EMPTY
49029: LIST
49030: LIST
49031: PUSH
49032: LD_INT 0
49034: PUSH
49035: LD_INT 4
49037: PUSH
49038: EMPTY
49039: LIST
49040: LIST
49041: PUSH
49042: LD_INT 0
49044: PUSH
49045: LD_INT 3
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PUSH
49052: LD_INT 1
49054: PUSH
49055: LD_INT 4
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: LD_INT 1
49064: PUSH
49065: LD_INT 5
49067: PUSH
49068: EMPTY
49069: LIST
49070: LIST
49071: PUSH
49072: LD_INT 0
49074: PUSH
49075: LD_INT 5
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: PUSH
49082: LD_INT 1
49084: NEG
49085: PUSH
49086: LD_INT 4
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: PUSH
49093: LD_INT 1
49095: NEG
49096: PUSH
49097: LD_INT 3
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 2
49106: PUSH
49107: LD_INT 5
49109: PUSH
49110: EMPTY
49111: LIST
49112: LIST
49113: PUSH
49114: LD_INT 2
49116: NEG
49117: PUSH
49118: LD_INT 3
49120: PUSH
49121: EMPTY
49122: LIST
49123: LIST
49124: PUSH
49125: EMPTY
49126: LIST
49127: LIST
49128: LIST
49129: LIST
49130: LIST
49131: LIST
49132: LIST
49133: LIST
49134: LIST
49135: LIST
49136: LIST
49137: LIST
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
49172: LD_ADDR_VAR 0 34
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: LD_INT 4
49182: NEG
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: LD_INT 0
49190: PUSH
49191: LD_INT 5
49193: NEG
49194: PUSH
49195: EMPTY
49196: LIST
49197: LIST
49198: PUSH
49199: LD_INT 1
49201: PUSH
49202: LD_INT 4
49204: NEG
49205: PUSH
49206: EMPTY
49207: LIST
49208: LIST
49209: PUSH
49210: LD_INT 1
49212: PUSH
49213: LD_INT 3
49215: NEG
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: PUSH
49221: LD_INT 0
49223: PUSH
49224: LD_INT 3
49226: NEG
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: PUSH
49232: LD_INT 1
49234: NEG
49235: PUSH
49236: LD_INT 4
49238: NEG
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PUSH
49244: LD_INT 1
49246: NEG
49247: PUSH
49248: LD_INT 5
49250: NEG
49251: PUSH
49252: EMPTY
49253: LIST
49254: LIST
49255: PUSH
49256: LD_INT 2
49258: PUSH
49259: LD_INT 3
49261: NEG
49262: PUSH
49263: EMPTY
49264: LIST
49265: LIST
49266: PUSH
49267: LD_INT 2
49269: NEG
49270: PUSH
49271: LD_INT 5
49273: NEG
49274: PUSH
49275: EMPTY
49276: LIST
49277: LIST
49278: PUSH
49279: LD_INT 3
49281: PUSH
49282: LD_INT 0
49284: PUSH
49285: EMPTY
49286: LIST
49287: LIST
49288: PUSH
49289: LD_INT 3
49291: PUSH
49292: LD_INT 1
49294: NEG
49295: PUSH
49296: EMPTY
49297: LIST
49298: LIST
49299: PUSH
49300: LD_INT 4
49302: PUSH
49303: LD_INT 0
49305: PUSH
49306: EMPTY
49307: LIST
49308: LIST
49309: PUSH
49310: LD_INT 4
49312: PUSH
49313: LD_INT 1
49315: PUSH
49316: EMPTY
49317: LIST
49318: LIST
49319: PUSH
49320: LD_INT 3
49322: PUSH
49323: LD_INT 1
49325: PUSH
49326: EMPTY
49327: LIST
49328: LIST
49329: PUSH
49330: LD_INT 2
49332: PUSH
49333: LD_INT 0
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: PUSH
49340: LD_INT 2
49342: PUSH
49343: LD_INT 1
49345: NEG
49346: PUSH
49347: EMPTY
49348: LIST
49349: LIST
49350: PUSH
49351: LD_INT 2
49353: PUSH
49354: LD_INT 2
49356: NEG
49357: PUSH
49358: EMPTY
49359: LIST
49360: LIST
49361: PUSH
49362: LD_INT 4
49364: PUSH
49365: LD_INT 2
49367: PUSH
49368: EMPTY
49369: LIST
49370: LIST
49371: PUSH
49372: LD_INT 4
49374: PUSH
49375: LD_INT 4
49377: PUSH
49378: EMPTY
49379: LIST
49380: LIST
49381: PUSH
49382: LD_INT 4
49384: PUSH
49385: LD_INT 3
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PUSH
49392: LD_INT 5
49394: PUSH
49395: LD_INT 4
49397: PUSH
49398: EMPTY
49399: LIST
49400: LIST
49401: PUSH
49402: LD_INT 5
49404: PUSH
49405: LD_INT 5
49407: PUSH
49408: EMPTY
49409: LIST
49410: LIST
49411: PUSH
49412: LD_INT 4
49414: PUSH
49415: LD_INT 5
49417: PUSH
49418: EMPTY
49419: LIST
49420: LIST
49421: PUSH
49422: LD_INT 3
49424: PUSH
49425: LD_INT 4
49427: PUSH
49428: EMPTY
49429: LIST
49430: LIST
49431: PUSH
49432: LD_INT 3
49434: PUSH
49435: LD_INT 3
49437: PUSH
49438: EMPTY
49439: LIST
49440: LIST
49441: PUSH
49442: LD_INT 5
49444: PUSH
49445: LD_INT 3
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 3
49454: PUSH
49455: LD_INT 5
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: LD_INT 0
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: EMPTY
49469: LIST
49470: LIST
49471: PUSH
49472: LD_INT 0
49474: PUSH
49475: LD_INT 2
49477: PUSH
49478: EMPTY
49479: LIST
49480: LIST
49481: PUSH
49482: LD_INT 1
49484: PUSH
49485: LD_INT 3
49487: PUSH
49488: EMPTY
49489: LIST
49490: LIST
49491: PUSH
49492: LD_INT 1
49494: PUSH
49495: LD_INT 4
49497: PUSH
49498: EMPTY
49499: LIST
49500: LIST
49501: PUSH
49502: LD_INT 0
49504: PUSH
49505: LD_INT 4
49507: PUSH
49508: EMPTY
49509: LIST
49510: LIST
49511: PUSH
49512: LD_INT 1
49514: NEG
49515: PUSH
49516: LD_INT 3
49518: PUSH
49519: EMPTY
49520: LIST
49521: LIST
49522: PUSH
49523: LD_INT 1
49525: NEG
49526: PUSH
49527: LD_INT 2
49529: PUSH
49530: EMPTY
49531: LIST
49532: LIST
49533: PUSH
49534: LD_INT 2
49536: PUSH
49537: LD_INT 4
49539: PUSH
49540: EMPTY
49541: LIST
49542: LIST
49543: PUSH
49544: LD_INT 2
49546: NEG
49547: PUSH
49548: LD_INT 2
49550: PUSH
49551: EMPTY
49552: LIST
49553: LIST
49554: PUSH
49555: LD_INT 4
49557: NEG
49558: PUSH
49559: LD_INT 0
49561: PUSH
49562: EMPTY
49563: LIST
49564: LIST
49565: PUSH
49566: LD_INT 4
49568: NEG
49569: PUSH
49570: LD_INT 1
49572: NEG
49573: PUSH
49574: EMPTY
49575: LIST
49576: LIST
49577: PUSH
49578: LD_INT 3
49580: NEG
49581: PUSH
49582: LD_INT 0
49584: PUSH
49585: EMPTY
49586: LIST
49587: LIST
49588: PUSH
49589: LD_INT 3
49591: NEG
49592: PUSH
49593: LD_INT 1
49595: PUSH
49596: EMPTY
49597: LIST
49598: LIST
49599: PUSH
49600: LD_INT 4
49602: NEG
49603: PUSH
49604: LD_INT 1
49606: PUSH
49607: EMPTY
49608: LIST
49609: LIST
49610: PUSH
49611: LD_INT 5
49613: NEG
49614: PUSH
49615: LD_INT 0
49617: PUSH
49618: EMPTY
49619: LIST
49620: LIST
49621: PUSH
49622: LD_INT 5
49624: NEG
49625: PUSH
49626: LD_INT 1
49628: NEG
49629: PUSH
49630: EMPTY
49631: LIST
49632: LIST
49633: PUSH
49634: LD_INT 5
49636: NEG
49637: PUSH
49638: LD_INT 2
49640: NEG
49641: PUSH
49642: EMPTY
49643: LIST
49644: LIST
49645: PUSH
49646: LD_INT 3
49648: NEG
49649: PUSH
49650: LD_INT 2
49652: PUSH
49653: EMPTY
49654: LIST
49655: LIST
49656: PUSH
49657: EMPTY
49658: LIST
49659: LIST
49660: LIST
49661: LIST
49662: LIST
49663: LIST
49664: LIST
49665: LIST
49666: LIST
49667: LIST
49668: LIST
49669: LIST
49670: LIST
49671: LIST
49672: LIST
49673: LIST
49674: LIST
49675: LIST
49676: LIST
49677: LIST
49678: LIST
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: LIST
49687: LIST
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: LIST
49693: LIST
49694: LIST
49695: LIST
49696: LIST
49697: LIST
49698: LIST
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: ST_TO_ADDR
// end ; end ;
49704: GO 49707
49706: POP
// case btype of b_depot , b_warehouse :
49707: LD_VAR 0 1
49711: PUSH
49712: LD_INT 0
49714: DOUBLE
49715: EQUAL
49716: IFTRUE 49726
49718: LD_INT 1
49720: DOUBLE
49721: EQUAL
49722: IFTRUE 49726
49724: GO 49927
49726: POP
// case nation of nation_american :
49727: LD_VAR 0 5
49731: PUSH
49732: LD_INT 1
49734: DOUBLE
49735: EQUAL
49736: IFTRUE 49740
49738: GO 49796
49740: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49741: LD_ADDR_VAR 0 9
49745: PUSH
49746: LD_VAR 0 11
49750: PUSH
49751: LD_VAR 0 12
49755: PUSH
49756: LD_VAR 0 13
49760: PUSH
49761: LD_VAR 0 14
49765: PUSH
49766: LD_VAR 0 15
49770: PUSH
49771: LD_VAR 0 16
49775: PUSH
49776: EMPTY
49777: LIST
49778: LIST
49779: LIST
49780: LIST
49781: LIST
49782: LIST
49783: PUSH
49784: LD_VAR 0 4
49788: PUSH
49789: LD_INT 1
49791: PLUS
49792: ARRAY
49793: ST_TO_ADDR
49794: GO 49925
49796: LD_INT 2
49798: DOUBLE
49799: EQUAL
49800: IFTRUE 49804
49802: GO 49860
49804: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49805: LD_ADDR_VAR 0 9
49809: PUSH
49810: LD_VAR 0 17
49814: PUSH
49815: LD_VAR 0 18
49819: PUSH
49820: LD_VAR 0 19
49824: PUSH
49825: LD_VAR 0 20
49829: PUSH
49830: LD_VAR 0 21
49834: PUSH
49835: LD_VAR 0 22
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: PUSH
49848: LD_VAR 0 4
49852: PUSH
49853: LD_INT 1
49855: PLUS
49856: ARRAY
49857: ST_TO_ADDR
49858: GO 49925
49860: LD_INT 3
49862: DOUBLE
49863: EQUAL
49864: IFTRUE 49868
49866: GO 49924
49868: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49869: LD_ADDR_VAR 0 9
49873: PUSH
49874: LD_VAR 0 23
49878: PUSH
49879: LD_VAR 0 24
49883: PUSH
49884: LD_VAR 0 25
49888: PUSH
49889: LD_VAR 0 26
49893: PUSH
49894: LD_VAR 0 27
49898: PUSH
49899: LD_VAR 0 28
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: PUSH
49912: LD_VAR 0 4
49916: PUSH
49917: LD_INT 1
49919: PLUS
49920: ARRAY
49921: ST_TO_ADDR
49922: GO 49925
49924: POP
49925: GO 50480
49927: LD_INT 2
49929: DOUBLE
49930: EQUAL
49931: IFTRUE 49941
49933: LD_INT 3
49935: DOUBLE
49936: EQUAL
49937: IFTRUE 49941
49939: GO 49997
49941: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49942: LD_ADDR_VAR 0 9
49946: PUSH
49947: LD_VAR 0 29
49951: PUSH
49952: LD_VAR 0 30
49956: PUSH
49957: LD_VAR 0 31
49961: PUSH
49962: LD_VAR 0 32
49966: PUSH
49967: LD_VAR 0 33
49971: PUSH
49972: LD_VAR 0 34
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: LIST
49981: LIST
49982: LIST
49983: LIST
49984: PUSH
49985: LD_VAR 0 4
49989: PUSH
49990: LD_INT 1
49992: PLUS
49993: ARRAY
49994: ST_TO_ADDR
49995: GO 50480
49997: LD_INT 16
49999: DOUBLE
50000: EQUAL
50001: IFTRUE 50059
50003: LD_INT 17
50005: DOUBLE
50006: EQUAL
50007: IFTRUE 50059
50009: LD_INT 18
50011: DOUBLE
50012: EQUAL
50013: IFTRUE 50059
50015: LD_INT 19
50017: DOUBLE
50018: EQUAL
50019: IFTRUE 50059
50021: LD_INT 22
50023: DOUBLE
50024: EQUAL
50025: IFTRUE 50059
50027: LD_INT 20
50029: DOUBLE
50030: EQUAL
50031: IFTRUE 50059
50033: LD_INT 21
50035: DOUBLE
50036: EQUAL
50037: IFTRUE 50059
50039: LD_INT 23
50041: DOUBLE
50042: EQUAL
50043: IFTRUE 50059
50045: LD_INT 24
50047: DOUBLE
50048: EQUAL
50049: IFTRUE 50059
50051: LD_INT 25
50053: DOUBLE
50054: EQUAL
50055: IFTRUE 50059
50057: GO 50115
50059: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
50060: LD_ADDR_VAR 0 9
50064: PUSH
50065: LD_VAR 0 35
50069: PUSH
50070: LD_VAR 0 36
50074: PUSH
50075: LD_VAR 0 37
50079: PUSH
50080: LD_VAR 0 38
50084: PUSH
50085: LD_VAR 0 39
50089: PUSH
50090: LD_VAR 0 40
50094: PUSH
50095: EMPTY
50096: LIST
50097: LIST
50098: LIST
50099: LIST
50100: LIST
50101: LIST
50102: PUSH
50103: LD_VAR 0 4
50107: PUSH
50108: LD_INT 1
50110: PLUS
50111: ARRAY
50112: ST_TO_ADDR
50113: GO 50480
50115: LD_INT 6
50117: DOUBLE
50118: EQUAL
50119: IFTRUE 50171
50121: LD_INT 7
50123: DOUBLE
50124: EQUAL
50125: IFTRUE 50171
50127: LD_INT 8
50129: DOUBLE
50130: EQUAL
50131: IFTRUE 50171
50133: LD_INT 13
50135: DOUBLE
50136: EQUAL
50137: IFTRUE 50171
50139: LD_INT 12
50141: DOUBLE
50142: EQUAL
50143: IFTRUE 50171
50145: LD_INT 15
50147: DOUBLE
50148: EQUAL
50149: IFTRUE 50171
50151: LD_INT 11
50153: DOUBLE
50154: EQUAL
50155: IFTRUE 50171
50157: LD_INT 14
50159: DOUBLE
50160: EQUAL
50161: IFTRUE 50171
50163: LD_INT 10
50165: DOUBLE
50166: EQUAL
50167: IFTRUE 50171
50169: GO 50227
50171: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
50172: LD_ADDR_VAR 0 9
50176: PUSH
50177: LD_VAR 0 41
50181: PUSH
50182: LD_VAR 0 42
50186: PUSH
50187: LD_VAR 0 43
50191: PUSH
50192: LD_VAR 0 44
50196: PUSH
50197: LD_VAR 0 45
50201: PUSH
50202: LD_VAR 0 46
50206: PUSH
50207: EMPTY
50208: LIST
50209: LIST
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: PUSH
50215: LD_VAR 0 4
50219: PUSH
50220: LD_INT 1
50222: PLUS
50223: ARRAY
50224: ST_TO_ADDR
50225: GO 50480
50227: LD_INT 36
50229: DOUBLE
50230: EQUAL
50231: IFTRUE 50235
50233: GO 50291
50235: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
50236: LD_ADDR_VAR 0 9
50240: PUSH
50241: LD_VAR 0 47
50245: PUSH
50246: LD_VAR 0 48
50250: PUSH
50251: LD_VAR 0 49
50255: PUSH
50256: LD_VAR 0 50
50260: PUSH
50261: LD_VAR 0 51
50265: PUSH
50266: LD_VAR 0 52
50270: PUSH
50271: EMPTY
50272: LIST
50273: LIST
50274: LIST
50275: LIST
50276: LIST
50277: LIST
50278: PUSH
50279: LD_VAR 0 4
50283: PUSH
50284: LD_INT 1
50286: PLUS
50287: ARRAY
50288: ST_TO_ADDR
50289: GO 50480
50291: LD_INT 4
50293: DOUBLE
50294: EQUAL
50295: IFTRUE 50317
50297: LD_INT 5
50299: DOUBLE
50300: EQUAL
50301: IFTRUE 50317
50303: LD_INT 34
50305: DOUBLE
50306: EQUAL
50307: IFTRUE 50317
50309: LD_INT 37
50311: DOUBLE
50312: EQUAL
50313: IFTRUE 50317
50315: GO 50373
50317: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
50318: LD_ADDR_VAR 0 9
50322: PUSH
50323: LD_VAR 0 53
50327: PUSH
50328: LD_VAR 0 54
50332: PUSH
50333: LD_VAR 0 55
50337: PUSH
50338: LD_VAR 0 56
50342: PUSH
50343: LD_VAR 0 57
50347: PUSH
50348: LD_VAR 0 58
50352: PUSH
50353: EMPTY
50354: LIST
50355: LIST
50356: LIST
50357: LIST
50358: LIST
50359: LIST
50360: PUSH
50361: LD_VAR 0 4
50365: PUSH
50366: LD_INT 1
50368: PLUS
50369: ARRAY
50370: ST_TO_ADDR
50371: GO 50480
50373: LD_INT 31
50375: DOUBLE
50376: EQUAL
50377: IFTRUE 50423
50379: LD_INT 32
50381: DOUBLE
50382: EQUAL
50383: IFTRUE 50423
50385: LD_INT 33
50387: DOUBLE
50388: EQUAL
50389: IFTRUE 50423
50391: LD_INT 27
50393: DOUBLE
50394: EQUAL
50395: IFTRUE 50423
50397: LD_INT 26
50399: DOUBLE
50400: EQUAL
50401: IFTRUE 50423
50403: LD_INT 28
50405: DOUBLE
50406: EQUAL
50407: IFTRUE 50423
50409: LD_INT 29
50411: DOUBLE
50412: EQUAL
50413: IFTRUE 50423
50415: LD_INT 30
50417: DOUBLE
50418: EQUAL
50419: IFTRUE 50423
50421: GO 50479
50423: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50424: LD_ADDR_VAR 0 9
50428: PUSH
50429: LD_VAR 0 59
50433: PUSH
50434: LD_VAR 0 60
50438: PUSH
50439: LD_VAR 0 61
50443: PUSH
50444: LD_VAR 0 62
50448: PUSH
50449: LD_VAR 0 63
50453: PUSH
50454: LD_VAR 0 64
50458: PUSH
50459: EMPTY
50460: LIST
50461: LIST
50462: LIST
50463: LIST
50464: LIST
50465: LIST
50466: PUSH
50467: LD_VAR 0 4
50471: PUSH
50472: LD_INT 1
50474: PLUS
50475: ARRAY
50476: ST_TO_ADDR
50477: GO 50480
50479: POP
// temp_list2 = [ ] ;
50480: LD_ADDR_VAR 0 10
50484: PUSH
50485: EMPTY
50486: ST_TO_ADDR
// for i in temp_list do
50487: LD_ADDR_VAR 0 8
50491: PUSH
50492: LD_VAR 0 9
50496: PUSH
50497: FOR_IN
50498: IFFALSE 50550
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50500: LD_ADDR_VAR 0 10
50504: PUSH
50505: LD_VAR 0 10
50509: PUSH
50510: LD_VAR 0 8
50514: PUSH
50515: LD_INT 1
50517: ARRAY
50518: PUSH
50519: LD_VAR 0 2
50523: PLUS
50524: PUSH
50525: LD_VAR 0 8
50529: PUSH
50530: LD_INT 2
50532: ARRAY
50533: PUSH
50534: LD_VAR 0 3
50538: PLUS
50539: PUSH
50540: EMPTY
50541: LIST
50542: LIST
50543: PUSH
50544: EMPTY
50545: LIST
50546: ADD
50547: ST_TO_ADDR
50548: GO 50497
50550: POP
50551: POP
// result = temp_list2 ;
50552: LD_ADDR_VAR 0 7
50556: PUSH
50557: LD_VAR 0 10
50561: ST_TO_ADDR
// end ;
50562: LD_VAR 0 7
50566: RET
// export function EnemyInRange ( unit , dist ) ; begin
50567: LD_INT 0
50569: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50570: LD_ADDR_VAR 0 3
50574: PUSH
50575: LD_VAR 0 1
50579: PPUSH
50580: CALL_OW 255
50584: PPUSH
50585: LD_VAR 0 1
50589: PPUSH
50590: CALL_OW 250
50594: PPUSH
50595: LD_VAR 0 1
50599: PPUSH
50600: CALL_OW 251
50604: PPUSH
50605: LD_VAR 0 2
50609: PPUSH
50610: CALL 23824 0 4
50614: PUSH
50615: LD_INT 4
50617: ARRAY
50618: ST_TO_ADDR
// end ;
50619: LD_VAR 0 3
50623: RET
// export function PlayerSeeMe ( unit ) ; begin
50624: LD_INT 0
50626: PPUSH
// result := See ( your_side , unit ) ;
50627: LD_ADDR_VAR 0 2
50631: PUSH
50632: LD_OWVAR 2
50636: PPUSH
50637: LD_VAR 0 1
50641: PPUSH
50642: CALL_OW 292
50646: ST_TO_ADDR
// end ;
50647: LD_VAR 0 2
50651: RET
// export function ReverseDir ( unit ) ; begin
50652: LD_INT 0
50654: PPUSH
// if not unit then
50655: LD_VAR 0 1
50659: NOT
50660: IFFALSE 50664
// exit ;
50662: GO 50687
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50664: LD_ADDR_VAR 0 2
50668: PUSH
50669: LD_VAR 0 1
50673: PPUSH
50674: CALL_OW 254
50678: PUSH
50679: LD_INT 3
50681: PLUS
50682: PUSH
50683: LD_INT 6
50685: MOD
50686: ST_TO_ADDR
// end ;
50687: LD_VAR 0 2
50691: RET
// export function ReverseArray ( array ) ; var i ; begin
50692: LD_INT 0
50694: PPUSH
50695: PPUSH
// if not array then
50696: LD_VAR 0 1
50700: NOT
50701: IFFALSE 50705
// exit ;
50703: GO 50760
// result := [ ] ;
50705: LD_ADDR_VAR 0 2
50709: PUSH
50710: EMPTY
50711: ST_TO_ADDR
// for i := array downto 1 do
50712: LD_ADDR_VAR 0 3
50716: PUSH
50717: DOUBLE
50718: LD_VAR 0 1
50722: INC
50723: ST_TO_ADDR
50724: LD_INT 1
50726: PUSH
50727: FOR_DOWNTO
50728: IFFALSE 50758
// result := Join ( result , array [ i ] ) ;
50730: LD_ADDR_VAR 0 2
50734: PUSH
50735: LD_VAR 0 2
50739: PPUSH
50740: LD_VAR 0 1
50744: PUSH
50745: LD_VAR 0 3
50749: ARRAY
50750: PPUSH
50751: CALL 55612 0 2
50755: ST_TO_ADDR
50756: GO 50727
50758: POP
50759: POP
// end ;
50760: LD_VAR 0 2
50764: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50765: LD_INT 0
50767: PPUSH
50768: PPUSH
50769: PPUSH
50770: PPUSH
50771: PPUSH
50772: PPUSH
// if not unit or not hexes then
50773: LD_VAR 0 1
50777: NOT
50778: IFTRUE 50787
50780: PUSH
50781: LD_VAR 0 2
50785: NOT
50786: OR
50787: IFFALSE 50791
// exit ;
50789: GO 50914
// dist := 9999 ;
50791: LD_ADDR_VAR 0 5
50795: PUSH
50796: LD_INT 9999
50798: ST_TO_ADDR
// for i = 1 to hexes do
50799: LD_ADDR_VAR 0 4
50803: PUSH
50804: DOUBLE
50805: LD_INT 1
50807: DEC
50808: ST_TO_ADDR
50809: LD_VAR 0 2
50813: PUSH
50814: FOR_TO
50815: IFFALSE 50902
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50817: LD_ADDR_VAR 0 6
50821: PUSH
50822: LD_VAR 0 1
50826: PPUSH
50827: LD_VAR 0 2
50831: PUSH
50832: LD_VAR 0 4
50836: ARRAY
50837: PUSH
50838: LD_INT 1
50840: ARRAY
50841: PPUSH
50842: LD_VAR 0 2
50846: PUSH
50847: LD_VAR 0 4
50851: ARRAY
50852: PUSH
50853: LD_INT 2
50855: ARRAY
50856: PPUSH
50857: CALL_OW 297
50861: ST_TO_ADDR
// if tdist < dist then
50862: LD_VAR 0 6
50866: PUSH
50867: LD_VAR 0 5
50871: LESS
50872: IFFALSE 50900
// begin hex := hexes [ i ] ;
50874: LD_ADDR_VAR 0 8
50878: PUSH
50879: LD_VAR 0 2
50883: PUSH
50884: LD_VAR 0 4
50888: ARRAY
50889: ST_TO_ADDR
// dist := tdist ;
50890: LD_ADDR_VAR 0 5
50894: PUSH
50895: LD_VAR 0 6
50899: ST_TO_ADDR
// end ; end ;
50900: GO 50814
50902: POP
50903: POP
// result := hex ;
50904: LD_ADDR_VAR 0 3
50908: PUSH
50909: LD_VAR 0 8
50913: ST_TO_ADDR
// end ;
50914: LD_VAR 0 3
50918: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50919: LD_INT 0
50921: PPUSH
50922: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50923: LD_VAR 0 1
50927: NOT
50928: IFTRUE 50967
50930: PUSH
50931: LD_VAR 0 1
50935: PUSH
50936: LD_INT 21
50938: PUSH
50939: LD_INT 2
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: PUSH
50946: LD_INT 23
50948: PUSH
50949: LD_INT 2
50951: PUSH
50952: EMPTY
50953: LIST
50954: LIST
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PPUSH
50960: CALL_OW 69
50964: IN
50965: NOT
50966: OR
50967: IFFALSE 50971
// exit ;
50969: GO 51018
// for i = 1 to 3 do
50971: LD_ADDR_VAR 0 3
50975: PUSH
50976: DOUBLE
50977: LD_INT 1
50979: DEC
50980: ST_TO_ADDR
50981: LD_INT 3
50983: PUSH
50984: FOR_TO
50985: IFFALSE 51016
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50987: LD_VAR 0 1
50991: PPUSH
50992: CALL_OW 250
50996: PPUSH
50997: LD_VAR 0 1
51001: PPUSH
51002: CALL_OW 251
51006: PPUSH
51007: LD_INT 1
51009: PPUSH
51010: CALL_OW 453
51014: GO 50984
51016: POP
51017: POP
// end ;
51018: LD_VAR 0 2
51022: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
51023: LD_INT 0
51025: PPUSH
51026: PPUSH
51027: PPUSH
51028: PPUSH
51029: PPUSH
51030: PPUSH
// if not unit or not enemy_unit then
51031: LD_VAR 0 1
51035: NOT
51036: IFTRUE 51045
51038: PUSH
51039: LD_VAR 0 2
51043: NOT
51044: OR
51045: IFFALSE 51049
// exit ;
51047: GO 51530
// if GetLives ( i ) < 250 then
51049: LD_VAR 0 4
51053: PPUSH
51054: CALL_OW 256
51058: PUSH
51059: LD_INT 250
51061: LESS
51062: IFFALSE 51075
// begin ComAutodestruct ( i ) ;
51064: LD_VAR 0 4
51068: PPUSH
51069: CALL 50919 0 1
// exit ;
51073: GO 51530
// end ; x := GetX ( enemy_unit ) ;
51075: LD_ADDR_VAR 0 7
51079: PUSH
51080: LD_VAR 0 2
51084: PPUSH
51085: CALL_OW 250
51089: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
51090: LD_ADDR_VAR 0 8
51094: PUSH
51095: LD_VAR 0 2
51099: PPUSH
51100: CALL_OW 251
51104: ST_TO_ADDR
// if not x or not y then
51105: LD_VAR 0 7
51109: NOT
51110: IFTRUE 51119
51112: PUSH
51113: LD_VAR 0 8
51117: NOT
51118: OR
51119: IFFALSE 51123
// exit ;
51121: GO 51530
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
51123: LD_ADDR_VAR 0 6
51127: PUSH
51128: LD_VAR 0 7
51132: PPUSH
51133: LD_INT 0
51135: PPUSH
51136: LD_INT 4
51138: PPUSH
51139: CALL_OW 272
51143: PUSH
51144: LD_VAR 0 8
51148: PPUSH
51149: LD_INT 0
51151: PPUSH
51152: LD_INT 4
51154: PPUSH
51155: CALL_OW 273
51159: PUSH
51160: EMPTY
51161: LIST
51162: LIST
51163: PUSH
51164: LD_VAR 0 7
51168: PPUSH
51169: LD_INT 1
51171: PPUSH
51172: LD_INT 4
51174: PPUSH
51175: CALL_OW 272
51179: PUSH
51180: LD_VAR 0 8
51184: PPUSH
51185: LD_INT 1
51187: PPUSH
51188: LD_INT 4
51190: PPUSH
51191: CALL_OW 273
51195: PUSH
51196: EMPTY
51197: LIST
51198: LIST
51199: PUSH
51200: LD_VAR 0 7
51204: PPUSH
51205: LD_INT 2
51207: PPUSH
51208: LD_INT 4
51210: PPUSH
51211: CALL_OW 272
51215: PUSH
51216: LD_VAR 0 8
51220: PPUSH
51221: LD_INT 2
51223: PPUSH
51224: LD_INT 4
51226: PPUSH
51227: CALL_OW 273
51231: PUSH
51232: EMPTY
51233: LIST
51234: LIST
51235: PUSH
51236: LD_VAR 0 7
51240: PPUSH
51241: LD_INT 3
51243: PPUSH
51244: LD_INT 4
51246: PPUSH
51247: CALL_OW 272
51251: PUSH
51252: LD_VAR 0 8
51256: PPUSH
51257: LD_INT 3
51259: PPUSH
51260: LD_INT 4
51262: PPUSH
51263: CALL_OW 273
51267: PUSH
51268: EMPTY
51269: LIST
51270: LIST
51271: PUSH
51272: LD_VAR 0 7
51276: PPUSH
51277: LD_INT 4
51279: PPUSH
51280: LD_INT 4
51282: PPUSH
51283: CALL_OW 272
51287: PUSH
51288: LD_VAR 0 8
51292: PPUSH
51293: LD_INT 4
51295: PPUSH
51296: LD_INT 4
51298: PPUSH
51299: CALL_OW 273
51303: PUSH
51304: EMPTY
51305: LIST
51306: LIST
51307: PUSH
51308: LD_VAR 0 7
51312: PPUSH
51313: LD_INT 5
51315: PPUSH
51316: LD_INT 4
51318: PPUSH
51319: CALL_OW 272
51323: PUSH
51324: LD_VAR 0 8
51328: PPUSH
51329: LD_INT 5
51331: PPUSH
51332: LD_INT 4
51334: PPUSH
51335: CALL_OW 273
51339: PUSH
51340: EMPTY
51341: LIST
51342: LIST
51343: PUSH
51344: EMPTY
51345: LIST
51346: LIST
51347: LIST
51348: LIST
51349: LIST
51350: LIST
51351: ST_TO_ADDR
// for i = tmp downto 1 do
51352: LD_ADDR_VAR 0 4
51356: PUSH
51357: DOUBLE
51358: LD_VAR 0 6
51362: INC
51363: ST_TO_ADDR
51364: LD_INT 1
51366: PUSH
51367: FOR_DOWNTO
51368: IFFALSE 51471
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51370: LD_VAR 0 6
51374: PUSH
51375: LD_VAR 0 4
51379: ARRAY
51380: PUSH
51381: LD_INT 1
51383: ARRAY
51384: PPUSH
51385: LD_VAR 0 6
51389: PUSH
51390: LD_VAR 0 4
51394: ARRAY
51395: PUSH
51396: LD_INT 2
51398: ARRAY
51399: PPUSH
51400: CALL_OW 488
51404: NOT
51405: IFTRUE 51447
51407: PUSH
51408: LD_VAR 0 6
51412: PUSH
51413: LD_VAR 0 4
51417: ARRAY
51418: PUSH
51419: LD_INT 1
51421: ARRAY
51422: PPUSH
51423: LD_VAR 0 6
51427: PUSH
51428: LD_VAR 0 4
51432: ARRAY
51433: PUSH
51434: LD_INT 2
51436: ARRAY
51437: PPUSH
51438: CALL_OW 428
51442: PUSH
51443: LD_INT 0
51445: NONEQUAL
51446: OR
51447: IFFALSE 51469
// tmp := Delete ( tmp , i ) ;
51449: LD_ADDR_VAR 0 6
51453: PUSH
51454: LD_VAR 0 6
51458: PPUSH
51459: LD_VAR 0 4
51463: PPUSH
51464: CALL_OW 3
51468: ST_TO_ADDR
51469: GO 51367
51471: POP
51472: POP
// j := GetClosestHex ( unit , tmp ) ;
51473: LD_ADDR_VAR 0 5
51477: PUSH
51478: LD_VAR 0 1
51482: PPUSH
51483: LD_VAR 0 6
51487: PPUSH
51488: CALL 50765 0 2
51492: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51493: LD_VAR 0 1
51497: PPUSH
51498: LD_VAR 0 5
51502: PUSH
51503: LD_INT 1
51505: ARRAY
51506: PPUSH
51507: LD_VAR 0 5
51511: PUSH
51512: LD_INT 2
51514: ARRAY
51515: PPUSH
51516: CALL_OW 111
// result := j ;
51520: LD_ADDR_VAR 0 3
51524: PUSH
51525: LD_VAR 0 5
51529: ST_TO_ADDR
// end ;
51530: LD_VAR 0 3
51534: RET
// export function PrepareApemanSoldier ( ) ; begin
51535: LD_INT 0
51537: PPUSH
// uc_nation := 0 ;
51538: LD_ADDR_OWVAR 21
51542: PUSH
51543: LD_INT 0
51545: ST_TO_ADDR
// hc_sex := sex_male ;
51546: LD_ADDR_OWVAR 27
51550: PUSH
51551: LD_INT 1
51553: ST_TO_ADDR
// hc_name :=  ;
51554: LD_ADDR_OWVAR 26
51558: PUSH
51559: LD_STRING 
51561: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51562: LD_ADDR_OWVAR 28
51566: PUSH
51567: LD_INT 15
51569: ST_TO_ADDR
// hc_gallery :=  ;
51570: LD_ADDR_OWVAR 33
51574: PUSH
51575: LD_STRING 
51577: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51578: LD_ADDR_OWVAR 31
51582: PUSH
51583: LD_INT 0
51585: PPUSH
51586: LD_INT 3
51588: PPUSH
51589: CALL_OW 12
51593: PUSH
51594: LD_INT 0
51596: PPUSH
51597: LD_INT 3
51599: PPUSH
51600: CALL_OW 12
51604: PUSH
51605: LD_INT 0
51607: PUSH
51608: LD_INT 0
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
51617: LD_ADDR_OWVAR 29
51621: PUSH
51622: LD_INT 10
51624: PUSH
51625: LD_INT 12
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: ST_TO_ADDR
// end ;
51632: LD_VAR 0 1
51636: RET
// export function PrepareApemanEngineer ( ) ; begin
51637: LD_INT 0
51639: PPUSH
// uc_nation := 0 ;
51640: LD_ADDR_OWVAR 21
51644: PUSH
51645: LD_INT 0
51647: ST_TO_ADDR
// hc_sex := sex_male ;
51648: LD_ADDR_OWVAR 27
51652: PUSH
51653: LD_INT 1
51655: ST_TO_ADDR
// hc_name :=  ;
51656: LD_ADDR_OWVAR 26
51660: PUSH
51661: LD_STRING 
51663: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51664: LD_ADDR_OWVAR 28
51668: PUSH
51669: LD_INT 16
51671: ST_TO_ADDR
// hc_gallery :=  ;
51672: LD_ADDR_OWVAR 33
51676: PUSH
51677: LD_STRING 
51679: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51680: LD_ADDR_OWVAR 31
51684: PUSH
51685: LD_INT 0
51687: PPUSH
51688: LD_INT 3
51690: PPUSH
51691: CALL_OW 12
51695: PUSH
51696: LD_INT 0
51698: PPUSH
51699: LD_INT 3
51701: PPUSH
51702: CALL_OW 12
51706: PUSH
51707: LD_INT 0
51709: PUSH
51710: LD_INT 0
51712: PUSH
51713: EMPTY
51714: LIST
51715: LIST
51716: LIST
51717: LIST
51718: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
51719: LD_ADDR_OWVAR 29
51723: PUSH
51724: LD_INT 10
51726: PUSH
51727: LD_INT 12
51729: PUSH
51730: EMPTY
51731: LIST
51732: LIST
51733: ST_TO_ADDR
// end ;
51734: LD_VAR 0 1
51738: RET
// export function PrepareApeman ( agressivity ) ; begin
51739: LD_INT 0
51741: PPUSH
// uc_side := 0 ;
51742: LD_ADDR_OWVAR 20
51746: PUSH
51747: LD_INT 0
51749: ST_TO_ADDR
// uc_nation := 0 ;
51750: LD_ADDR_OWVAR 21
51754: PUSH
51755: LD_INT 0
51757: ST_TO_ADDR
// hc_sex := sex_male ;
51758: LD_ADDR_OWVAR 27
51762: PUSH
51763: LD_INT 1
51765: ST_TO_ADDR
// hc_class := class_apeman ;
51766: LD_ADDR_OWVAR 28
51770: PUSH
51771: LD_INT 12
51773: ST_TO_ADDR
// hc_gallery :=  ;
51774: LD_ADDR_OWVAR 33
51778: PUSH
51779: LD_STRING 
51781: ST_TO_ADDR
// hc_name :=  ;
51782: LD_ADDR_OWVAR 26
51786: PUSH
51787: LD_STRING 
51789: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
51790: LD_ADDR_OWVAR 29
51794: PUSH
51795: LD_INT 10
51797: PUSH
51798: LD_INT 12
51800: PUSH
51801: EMPTY
51802: LIST
51803: LIST
51804: ST_TO_ADDR
// if agressivity = 0 then
51805: LD_VAR 0 1
51809: PUSH
51810: LD_INT 0
51812: EQUAL
51813: IFFALSE 51825
// hc_agressivity := 0 else
51815: LD_ADDR_OWVAR 35
51819: PUSH
51820: LD_INT 0
51822: ST_TO_ADDR
51823: GO 51846
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51825: LD_ADDR_OWVAR 35
51829: PUSH
51830: LD_VAR 0 1
51834: NEG
51835: PPUSH
51836: LD_VAR 0 1
51840: PPUSH
51841: CALL_OW 12
51845: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51846: LD_ADDR_OWVAR 31
51850: PUSH
51851: LD_INT 0
51853: PPUSH
51854: LD_INT 3
51856: PPUSH
51857: CALL_OW 12
51861: PUSH
51862: LD_INT 0
51864: PPUSH
51865: LD_INT 3
51867: PPUSH
51868: CALL_OW 12
51872: PUSH
51873: LD_INT 0
51875: PUSH
51876: LD_INT 0
51878: PUSH
51879: EMPTY
51880: LIST
51881: LIST
51882: LIST
51883: LIST
51884: ST_TO_ADDR
// end ;
51885: LD_VAR 0 2
51889: RET
// export function PrepareTiger ( agressivity ) ; begin
51890: LD_INT 0
51892: PPUSH
// uc_side := 0 ;
51893: LD_ADDR_OWVAR 20
51897: PUSH
51898: LD_INT 0
51900: ST_TO_ADDR
// uc_nation := 0 ;
51901: LD_ADDR_OWVAR 21
51905: PUSH
51906: LD_INT 0
51908: ST_TO_ADDR
// InitHc ;
51909: CALL_OW 19
// hc_class := class_tiger ;
51913: LD_ADDR_OWVAR 28
51917: PUSH
51918: LD_INT 14
51920: ST_TO_ADDR
// hc_gallery :=  ;
51921: LD_ADDR_OWVAR 33
51925: PUSH
51926: LD_STRING 
51928: ST_TO_ADDR
// hc_name :=  ;
51929: LD_ADDR_OWVAR 26
51933: PUSH
51934: LD_STRING 
51936: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51937: LD_ADDR_OWVAR 35
51941: PUSH
51942: LD_VAR 0 1
51946: NEG
51947: PPUSH
51948: LD_VAR 0 1
51952: PPUSH
51953: CALL_OW 12
51957: ST_TO_ADDR
// end ;
51958: LD_VAR 0 2
51962: RET
// export function PrepareEnchidna ( ) ; begin
51963: LD_INT 0
51965: PPUSH
// uc_side := 0 ;
51966: LD_ADDR_OWVAR 20
51970: PUSH
51971: LD_INT 0
51973: ST_TO_ADDR
// uc_nation := 0 ;
51974: LD_ADDR_OWVAR 21
51978: PUSH
51979: LD_INT 0
51981: ST_TO_ADDR
// InitHc ;
51982: CALL_OW 19
// hc_class := class_baggie ;
51986: LD_ADDR_OWVAR 28
51990: PUSH
51991: LD_INT 13
51993: ST_TO_ADDR
// hc_gallery :=  ;
51994: LD_ADDR_OWVAR 33
51998: PUSH
51999: LD_STRING 
52001: ST_TO_ADDR
// hc_name :=  ;
52002: LD_ADDR_OWVAR 26
52006: PUSH
52007: LD_STRING 
52009: ST_TO_ADDR
// end ;
52010: LD_VAR 0 1
52014: RET
// export function PrepareFrog ( ) ; begin
52015: LD_INT 0
52017: PPUSH
// uc_side := 0 ;
52018: LD_ADDR_OWVAR 20
52022: PUSH
52023: LD_INT 0
52025: ST_TO_ADDR
// uc_nation := 0 ;
52026: LD_ADDR_OWVAR 21
52030: PUSH
52031: LD_INT 0
52033: ST_TO_ADDR
// InitHc ;
52034: CALL_OW 19
// hc_class := class_frog ;
52038: LD_ADDR_OWVAR 28
52042: PUSH
52043: LD_INT 19
52045: ST_TO_ADDR
// hc_gallery :=  ;
52046: LD_ADDR_OWVAR 33
52050: PUSH
52051: LD_STRING 
52053: ST_TO_ADDR
// hc_name :=  ;
52054: LD_ADDR_OWVAR 26
52058: PUSH
52059: LD_STRING 
52061: ST_TO_ADDR
// end ;
52062: LD_VAR 0 1
52066: RET
// export function PrepareFish ( ) ; begin
52067: LD_INT 0
52069: PPUSH
// uc_side := 0 ;
52070: LD_ADDR_OWVAR 20
52074: PUSH
52075: LD_INT 0
52077: ST_TO_ADDR
// uc_nation := 0 ;
52078: LD_ADDR_OWVAR 21
52082: PUSH
52083: LD_INT 0
52085: ST_TO_ADDR
// InitHc ;
52086: CALL_OW 19
// hc_class := class_fish ;
52090: LD_ADDR_OWVAR 28
52094: PUSH
52095: LD_INT 20
52097: ST_TO_ADDR
// hc_gallery :=  ;
52098: LD_ADDR_OWVAR 33
52102: PUSH
52103: LD_STRING 
52105: ST_TO_ADDR
// hc_name :=  ;
52106: LD_ADDR_OWVAR 26
52110: PUSH
52111: LD_STRING 
52113: ST_TO_ADDR
// end ;
52114: LD_VAR 0 1
52118: RET
// export function PrepareBird ( ) ; begin
52119: LD_INT 0
52121: PPUSH
// uc_side := 0 ;
52122: LD_ADDR_OWVAR 20
52126: PUSH
52127: LD_INT 0
52129: ST_TO_ADDR
// uc_nation := 0 ;
52130: LD_ADDR_OWVAR 21
52134: PUSH
52135: LD_INT 0
52137: ST_TO_ADDR
// InitHc ;
52138: CALL_OW 19
// hc_class := class_phororhacos ;
52142: LD_ADDR_OWVAR 28
52146: PUSH
52147: LD_INT 18
52149: ST_TO_ADDR
// hc_gallery :=  ;
52150: LD_ADDR_OWVAR 33
52154: PUSH
52155: LD_STRING 
52157: ST_TO_ADDR
// hc_name :=  ;
52158: LD_ADDR_OWVAR 26
52162: PUSH
52163: LD_STRING 
52165: ST_TO_ADDR
// end ;
52166: LD_VAR 0 1
52170: RET
// export function PrepareHorse ( ) ; begin
52171: LD_INT 0
52173: PPUSH
// uc_side := 0 ;
52174: LD_ADDR_OWVAR 20
52178: PUSH
52179: LD_INT 0
52181: ST_TO_ADDR
// uc_nation := 0 ;
52182: LD_ADDR_OWVAR 21
52186: PUSH
52187: LD_INT 0
52189: ST_TO_ADDR
// InitHc ;
52190: CALL_OW 19
// hc_class := class_horse ;
52194: LD_ADDR_OWVAR 28
52198: PUSH
52199: LD_INT 21
52201: ST_TO_ADDR
// hc_gallery :=  ;
52202: LD_ADDR_OWVAR 33
52206: PUSH
52207: LD_STRING 
52209: ST_TO_ADDR
// hc_name :=  ;
52210: LD_ADDR_OWVAR 26
52214: PUSH
52215: LD_STRING 
52217: ST_TO_ADDR
// end ;
52218: LD_VAR 0 1
52222: RET
// export function PrepareMastodont ( ) ; begin
52223: LD_INT 0
52225: PPUSH
// uc_side := 0 ;
52226: LD_ADDR_OWVAR 20
52230: PUSH
52231: LD_INT 0
52233: ST_TO_ADDR
// uc_nation := 0 ;
52234: LD_ADDR_OWVAR 21
52238: PUSH
52239: LD_INT 0
52241: ST_TO_ADDR
// vc_chassis := class_mastodont ;
52242: LD_ADDR_OWVAR 37
52246: PUSH
52247: LD_INT 31
52249: ST_TO_ADDR
// vc_control := control_rider ;
52250: LD_ADDR_OWVAR 38
52254: PUSH
52255: LD_INT 4
52257: ST_TO_ADDR
// end ;
52258: LD_VAR 0 1
52262: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52263: LD_INT 0
52265: PPUSH
52266: PPUSH
52267: PPUSH
// uc_side = 0 ;
52268: LD_ADDR_OWVAR 20
52272: PUSH
52273: LD_INT 0
52275: ST_TO_ADDR
// uc_nation = 0 ;
52276: LD_ADDR_OWVAR 21
52280: PUSH
52281: LD_INT 0
52283: ST_TO_ADDR
// InitHc_All ( ) ;
52284: CALL_OW 584
// InitVc ;
52288: CALL_OW 20
// if mastodonts then
52292: LD_VAR 0 6
52296: IFFALSE 52363
// for i = 1 to mastodonts do
52298: LD_ADDR_VAR 0 11
52302: PUSH
52303: DOUBLE
52304: LD_INT 1
52306: DEC
52307: ST_TO_ADDR
52308: LD_VAR 0 6
52312: PUSH
52313: FOR_TO
52314: IFFALSE 52361
// begin vc_chassis := 31 ;
52316: LD_ADDR_OWVAR 37
52320: PUSH
52321: LD_INT 31
52323: ST_TO_ADDR
// vc_control := control_rider ;
52324: LD_ADDR_OWVAR 38
52328: PUSH
52329: LD_INT 4
52331: ST_TO_ADDR
// animal := CreateVehicle ;
52332: LD_ADDR_VAR 0 12
52336: PUSH
52337: CALL_OW 45
52341: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52342: LD_VAR 0 12
52346: PPUSH
52347: LD_VAR 0 8
52351: PPUSH
52352: LD_INT 0
52354: PPUSH
52355: CALL 54505 0 3
// end ;
52359: GO 52313
52361: POP
52362: POP
// if horses then
52363: LD_VAR 0 5
52367: IFFALSE 52434
// for i = 1 to horses do
52369: LD_ADDR_VAR 0 11
52373: PUSH
52374: DOUBLE
52375: LD_INT 1
52377: DEC
52378: ST_TO_ADDR
52379: LD_VAR 0 5
52383: PUSH
52384: FOR_TO
52385: IFFALSE 52432
// begin hc_class := 21 ;
52387: LD_ADDR_OWVAR 28
52391: PUSH
52392: LD_INT 21
52394: ST_TO_ADDR
// hc_gallery :=  ;
52395: LD_ADDR_OWVAR 33
52399: PUSH
52400: LD_STRING 
52402: ST_TO_ADDR
// animal := CreateHuman ;
52403: LD_ADDR_VAR 0 12
52407: PUSH
52408: CALL_OW 44
52412: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52413: LD_VAR 0 12
52417: PPUSH
52418: LD_VAR 0 8
52422: PPUSH
52423: LD_INT 0
52425: PPUSH
52426: CALL 54505 0 3
// end ;
52430: GO 52384
52432: POP
52433: POP
// if birds then
52434: LD_VAR 0 1
52438: IFFALSE 52505
// for i = 1 to birds do
52440: LD_ADDR_VAR 0 11
52444: PUSH
52445: DOUBLE
52446: LD_INT 1
52448: DEC
52449: ST_TO_ADDR
52450: LD_VAR 0 1
52454: PUSH
52455: FOR_TO
52456: IFFALSE 52503
// begin hc_class := 18 ;
52458: LD_ADDR_OWVAR 28
52462: PUSH
52463: LD_INT 18
52465: ST_TO_ADDR
// hc_gallery =  ;
52466: LD_ADDR_OWVAR 33
52470: PUSH
52471: LD_STRING 
52473: ST_TO_ADDR
// animal := CreateHuman ;
52474: LD_ADDR_VAR 0 12
52478: PUSH
52479: CALL_OW 44
52483: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52484: LD_VAR 0 12
52488: PPUSH
52489: LD_VAR 0 8
52493: PPUSH
52494: LD_INT 0
52496: PPUSH
52497: CALL 54505 0 3
// end ;
52501: GO 52455
52503: POP
52504: POP
// if tigers then
52505: LD_VAR 0 2
52509: IFFALSE 52593
// for i = 1 to tigers do
52511: LD_ADDR_VAR 0 11
52515: PUSH
52516: DOUBLE
52517: LD_INT 1
52519: DEC
52520: ST_TO_ADDR
52521: LD_VAR 0 2
52525: PUSH
52526: FOR_TO
52527: IFFALSE 52591
// begin hc_class = class_tiger ;
52529: LD_ADDR_OWVAR 28
52533: PUSH
52534: LD_INT 14
52536: ST_TO_ADDR
// hc_gallery =  ;
52537: LD_ADDR_OWVAR 33
52541: PUSH
52542: LD_STRING 
52544: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52545: LD_ADDR_OWVAR 35
52549: PUSH
52550: LD_INT 7
52552: NEG
52553: PPUSH
52554: LD_INT 7
52556: PPUSH
52557: CALL_OW 12
52561: ST_TO_ADDR
// animal := CreateHuman ;
52562: LD_ADDR_VAR 0 12
52566: PUSH
52567: CALL_OW 44
52571: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52572: LD_VAR 0 12
52576: PPUSH
52577: LD_VAR 0 8
52581: PPUSH
52582: LD_INT 0
52584: PPUSH
52585: CALL 54505 0 3
// end ;
52589: GO 52526
52591: POP
52592: POP
// if apemans then
52593: LD_VAR 0 3
52597: IFFALSE 52720
// for i = 1 to apemans do
52599: LD_ADDR_VAR 0 11
52603: PUSH
52604: DOUBLE
52605: LD_INT 1
52607: DEC
52608: ST_TO_ADDR
52609: LD_VAR 0 3
52613: PUSH
52614: FOR_TO
52615: IFFALSE 52718
// begin hc_class = class_apeman ;
52617: LD_ADDR_OWVAR 28
52621: PUSH
52622: LD_INT 12
52624: ST_TO_ADDR
// hc_gallery =  ;
52625: LD_ADDR_OWVAR 33
52629: PUSH
52630: LD_STRING 
52632: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52633: LD_ADDR_OWVAR 35
52637: PUSH
52638: LD_INT 2
52640: NEG
52641: PPUSH
52642: LD_INT 2
52644: PPUSH
52645: CALL_OW 12
52649: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52650: LD_ADDR_OWVAR 31
52654: PUSH
52655: LD_INT 1
52657: PPUSH
52658: LD_INT 3
52660: PPUSH
52661: CALL_OW 12
52665: PUSH
52666: LD_INT 1
52668: PPUSH
52669: LD_INT 3
52671: PPUSH
52672: CALL_OW 12
52676: PUSH
52677: LD_INT 0
52679: PUSH
52680: LD_INT 0
52682: PUSH
52683: EMPTY
52684: LIST
52685: LIST
52686: LIST
52687: LIST
52688: ST_TO_ADDR
// animal := CreateHuman ;
52689: LD_ADDR_VAR 0 12
52693: PUSH
52694: CALL_OW 44
52698: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52699: LD_VAR 0 12
52703: PPUSH
52704: LD_VAR 0 8
52708: PPUSH
52709: LD_INT 0
52711: PPUSH
52712: CALL 54505 0 3
// end ;
52716: GO 52614
52718: POP
52719: POP
// if enchidnas then
52720: LD_VAR 0 4
52724: IFFALSE 52791
// for i = 1 to enchidnas do
52726: LD_ADDR_VAR 0 11
52730: PUSH
52731: DOUBLE
52732: LD_INT 1
52734: DEC
52735: ST_TO_ADDR
52736: LD_VAR 0 4
52740: PUSH
52741: FOR_TO
52742: IFFALSE 52789
// begin hc_class = 13 ;
52744: LD_ADDR_OWVAR 28
52748: PUSH
52749: LD_INT 13
52751: ST_TO_ADDR
// hc_gallery =  ;
52752: LD_ADDR_OWVAR 33
52756: PUSH
52757: LD_STRING 
52759: ST_TO_ADDR
// animal := CreateHuman ;
52760: LD_ADDR_VAR 0 12
52764: PUSH
52765: CALL_OW 44
52769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52770: LD_VAR 0 12
52774: PPUSH
52775: LD_VAR 0 8
52779: PPUSH
52780: LD_INT 0
52782: PPUSH
52783: CALL 54505 0 3
// end ;
52787: GO 52741
52789: POP
52790: POP
// if fishes then
52791: LD_VAR 0 7
52795: IFFALSE 52862
// for i = 1 to fishes do
52797: LD_ADDR_VAR 0 11
52801: PUSH
52802: DOUBLE
52803: LD_INT 1
52805: DEC
52806: ST_TO_ADDR
52807: LD_VAR 0 7
52811: PUSH
52812: FOR_TO
52813: IFFALSE 52860
// begin hc_class = 20 ;
52815: LD_ADDR_OWVAR 28
52819: PUSH
52820: LD_INT 20
52822: ST_TO_ADDR
// hc_gallery =  ;
52823: LD_ADDR_OWVAR 33
52827: PUSH
52828: LD_STRING 
52830: ST_TO_ADDR
// animal := CreateHuman ;
52831: LD_ADDR_VAR 0 12
52835: PUSH
52836: CALL_OW 44
52840: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52841: LD_VAR 0 12
52845: PPUSH
52846: LD_VAR 0 9
52850: PPUSH
52851: LD_INT 0
52853: PPUSH
52854: CALL 54505 0 3
// end ;
52858: GO 52812
52860: POP
52861: POP
// end ;
52862: LD_VAR 0 10
52866: RET
// export function WantHeal ( sci , unit ) ; begin
52867: LD_INT 0
52869: PPUSH
// if GetTaskList ( sci ) > 0 then
52870: LD_VAR 0 1
52874: PPUSH
52875: CALL_OW 437
52879: PUSH
52880: LD_INT 0
52882: GREATER
52883: IFFALSE 52955
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52885: LD_VAR 0 1
52889: PPUSH
52890: CALL_OW 437
52894: PUSH
52895: LD_INT 1
52897: ARRAY
52898: PUSH
52899: LD_INT 1
52901: ARRAY
52902: PUSH
52903: LD_STRING l
52905: EQUAL
52906: IFFALSE 52933
52908: PUSH
52909: LD_VAR 0 1
52913: PPUSH
52914: CALL_OW 437
52918: PUSH
52919: LD_INT 1
52921: ARRAY
52922: PUSH
52923: LD_INT 4
52925: ARRAY
52926: PUSH
52927: LD_VAR 0 2
52931: EQUAL
52932: AND
52933: IFFALSE 52945
// result := true else
52935: LD_ADDR_VAR 0 3
52939: PUSH
52940: LD_INT 1
52942: ST_TO_ADDR
52943: GO 52953
// result := false ;
52945: LD_ADDR_VAR 0 3
52949: PUSH
52950: LD_INT 0
52952: ST_TO_ADDR
// end else
52953: GO 52963
// result := false ;
52955: LD_ADDR_VAR 0 3
52959: PUSH
52960: LD_INT 0
52962: ST_TO_ADDR
// end ;
52963: LD_VAR 0 3
52967: RET
// export function HealTarget ( sci ) ; begin
52968: LD_INT 0
52970: PPUSH
// if not sci then
52971: LD_VAR 0 1
52975: NOT
52976: IFFALSE 52980
// exit ;
52978: GO 53045
// result := 0 ;
52980: LD_ADDR_VAR 0 2
52984: PUSH
52985: LD_INT 0
52987: ST_TO_ADDR
// if GetTaskList ( sci ) then
52988: LD_VAR 0 1
52992: PPUSH
52993: CALL_OW 437
52997: IFFALSE 53045
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52999: LD_VAR 0 1
53003: PPUSH
53004: CALL_OW 437
53008: PUSH
53009: LD_INT 1
53011: ARRAY
53012: PUSH
53013: LD_INT 1
53015: ARRAY
53016: PUSH
53017: LD_STRING l
53019: EQUAL
53020: IFFALSE 53045
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
53022: LD_ADDR_VAR 0 2
53026: PUSH
53027: LD_VAR 0 1
53031: PPUSH
53032: CALL_OW 437
53036: PUSH
53037: LD_INT 1
53039: ARRAY
53040: PUSH
53041: LD_INT 4
53043: ARRAY
53044: ST_TO_ADDR
// end ;
53045: LD_VAR 0 2
53049: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53050: LD_INT 0
53052: PPUSH
53053: PPUSH
53054: PPUSH
53055: PPUSH
// if not base_units then
53056: LD_VAR 0 1
53060: NOT
53061: IFFALSE 53065
// exit ;
53063: GO 53152
// result := false ;
53065: LD_ADDR_VAR 0 2
53069: PUSH
53070: LD_INT 0
53072: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53073: LD_ADDR_VAR 0 5
53077: PUSH
53078: LD_VAR 0 1
53082: PPUSH
53083: LD_INT 21
53085: PUSH
53086: LD_INT 3
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: PPUSH
53093: CALL_OW 72
53097: ST_TO_ADDR
// if not tmp then
53098: LD_VAR 0 5
53102: NOT
53103: IFFALSE 53107
// exit ;
53105: GO 53152
// for i in tmp do
53107: LD_ADDR_VAR 0 3
53111: PUSH
53112: LD_VAR 0 5
53116: PUSH
53117: FOR_IN
53118: IFFALSE 53150
// begin result := EnemyInRange ( i , 22 ) ;
53120: LD_ADDR_VAR 0 2
53124: PUSH
53125: LD_VAR 0 3
53129: PPUSH
53130: LD_INT 22
53132: PPUSH
53133: CALL 50567 0 2
53137: ST_TO_ADDR
// if result then
53138: LD_VAR 0 2
53142: IFFALSE 53148
// exit ;
53144: POP
53145: POP
53146: GO 53152
// end ;
53148: GO 53117
53150: POP
53151: POP
// end ;
53152: LD_VAR 0 2
53156: RET
// export function FilterByTag ( units , tag ) ; begin
53157: LD_INT 0
53159: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
53160: LD_ADDR_VAR 0 3
53164: PUSH
53165: LD_VAR 0 1
53169: PPUSH
53170: LD_INT 120
53172: PUSH
53173: LD_VAR 0 2
53177: PUSH
53178: EMPTY
53179: LIST
53180: LIST
53181: PPUSH
53182: CALL_OW 72
53186: ST_TO_ADDR
// end ;
53187: LD_VAR 0 3
53191: RET
// export function IsDriver ( un ) ; begin
53192: LD_INT 0
53194: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53195: LD_ADDR_VAR 0 2
53199: PUSH
53200: LD_VAR 0 1
53204: PUSH
53205: LD_INT 55
53207: PUSH
53208: EMPTY
53209: LIST
53210: PPUSH
53211: CALL_OW 69
53215: IN
53216: ST_TO_ADDR
// end ;
53217: LD_VAR 0 2
53221: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53222: LD_INT 0
53224: PPUSH
53225: PPUSH
// list := [ ] ;
53226: LD_ADDR_VAR 0 5
53230: PUSH
53231: EMPTY
53232: ST_TO_ADDR
// case d of 0 :
53233: LD_VAR 0 3
53237: PUSH
53238: LD_INT 0
53240: DOUBLE
53241: EQUAL
53242: IFTRUE 53246
53244: GO 53379
53246: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53247: LD_ADDR_VAR 0 5
53251: PUSH
53252: LD_VAR 0 1
53256: PUSH
53257: LD_INT 4
53259: MINUS
53260: PUSH
53261: LD_VAR 0 2
53265: PUSH
53266: LD_INT 4
53268: MINUS
53269: PUSH
53270: LD_INT 2
53272: PUSH
53273: EMPTY
53274: LIST
53275: LIST
53276: LIST
53277: PUSH
53278: LD_VAR 0 1
53282: PUSH
53283: LD_INT 3
53285: MINUS
53286: PUSH
53287: LD_VAR 0 2
53291: PUSH
53292: LD_INT 1
53294: PUSH
53295: EMPTY
53296: LIST
53297: LIST
53298: LIST
53299: PUSH
53300: LD_VAR 0 1
53304: PUSH
53305: LD_INT 4
53307: PLUS
53308: PUSH
53309: LD_VAR 0 2
53313: PUSH
53314: LD_INT 4
53316: PUSH
53317: EMPTY
53318: LIST
53319: LIST
53320: LIST
53321: PUSH
53322: LD_VAR 0 1
53326: PUSH
53327: LD_INT 3
53329: PLUS
53330: PUSH
53331: LD_VAR 0 2
53335: PUSH
53336: LD_INT 3
53338: PLUS
53339: PUSH
53340: LD_INT 5
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: PUSH
53348: LD_VAR 0 1
53352: PUSH
53353: LD_VAR 0 2
53357: PUSH
53358: LD_INT 4
53360: PLUS
53361: PUSH
53362: LD_INT 0
53364: PUSH
53365: EMPTY
53366: LIST
53367: LIST
53368: LIST
53369: PUSH
53370: EMPTY
53371: LIST
53372: LIST
53373: LIST
53374: LIST
53375: LIST
53376: ST_TO_ADDR
// end ; 1 :
53377: GO 54077
53379: LD_INT 1
53381: DOUBLE
53382: EQUAL
53383: IFTRUE 53387
53385: GO 53520
53387: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53388: LD_ADDR_VAR 0 5
53392: PUSH
53393: LD_VAR 0 1
53397: PUSH
53398: LD_VAR 0 2
53402: PUSH
53403: LD_INT 4
53405: MINUS
53406: PUSH
53407: LD_INT 3
53409: PUSH
53410: EMPTY
53411: LIST
53412: LIST
53413: LIST
53414: PUSH
53415: LD_VAR 0 1
53419: PUSH
53420: LD_INT 3
53422: MINUS
53423: PUSH
53424: LD_VAR 0 2
53428: PUSH
53429: LD_INT 3
53431: MINUS
53432: PUSH
53433: LD_INT 2
53435: PUSH
53436: EMPTY
53437: LIST
53438: LIST
53439: LIST
53440: PUSH
53441: LD_VAR 0 1
53445: PUSH
53446: LD_INT 4
53448: MINUS
53449: PUSH
53450: LD_VAR 0 2
53454: PUSH
53455: LD_INT 1
53457: PUSH
53458: EMPTY
53459: LIST
53460: LIST
53461: LIST
53462: PUSH
53463: LD_VAR 0 1
53467: PUSH
53468: LD_VAR 0 2
53472: PUSH
53473: LD_INT 3
53475: PLUS
53476: PUSH
53477: LD_INT 0
53479: PUSH
53480: EMPTY
53481: LIST
53482: LIST
53483: LIST
53484: PUSH
53485: LD_VAR 0 1
53489: PUSH
53490: LD_INT 4
53492: PLUS
53493: PUSH
53494: LD_VAR 0 2
53498: PUSH
53499: LD_INT 4
53501: PLUS
53502: PUSH
53503: LD_INT 5
53505: PUSH
53506: EMPTY
53507: LIST
53508: LIST
53509: LIST
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: LIST
53515: LIST
53516: LIST
53517: ST_TO_ADDR
// end ; 2 :
53518: GO 54077
53520: LD_INT 2
53522: DOUBLE
53523: EQUAL
53524: IFTRUE 53528
53526: GO 53657
53528: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53529: LD_ADDR_VAR 0 5
53533: PUSH
53534: LD_VAR 0 1
53538: PUSH
53539: LD_VAR 0 2
53543: PUSH
53544: LD_INT 3
53546: MINUS
53547: PUSH
53548: LD_INT 3
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: LIST
53555: PUSH
53556: LD_VAR 0 1
53560: PUSH
53561: LD_INT 4
53563: PLUS
53564: PUSH
53565: LD_VAR 0 2
53569: PUSH
53570: LD_INT 4
53572: PUSH
53573: EMPTY
53574: LIST
53575: LIST
53576: LIST
53577: PUSH
53578: LD_VAR 0 1
53582: PUSH
53583: LD_VAR 0 2
53587: PUSH
53588: LD_INT 4
53590: PLUS
53591: PUSH
53592: LD_INT 0
53594: PUSH
53595: EMPTY
53596: LIST
53597: LIST
53598: LIST
53599: PUSH
53600: LD_VAR 0 1
53604: PUSH
53605: LD_INT 3
53607: MINUS
53608: PUSH
53609: LD_VAR 0 2
53613: PUSH
53614: LD_INT 1
53616: PUSH
53617: EMPTY
53618: LIST
53619: LIST
53620: LIST
53621: PUSH
53622: LD_VAR 0 1
53626: PUSH
53627: LD_INT 4
53629: MINUS
53630: PUSH
53631: LD_VAR 0 2
53635: PUSH
53636: LD_INT 4
53638: MINUS
53639: PUSH
53640: LD_INT 2
53642: PUSH
53643: EMPTY
53644: LIST
53645: LIST
53646: LIST
53647: PUSH
53648: EMPTY
53649: LIST
53650: LIST
53651: LIST
53652: LIST
53653: LIST
53654: ST_TO_ADDR
// end ; 3 :
53655: GO 54077
53657: LD_INT 3
53659: DOUBLE
53660: EQUAL
53661: IFTRUE 53665
53663: GO 53798
53665: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53666: LD_ADDR_VAR 0 5
53670: PUSH
53671: LD_VAR 0 1
53675: PUSH
53676: LD_INT 3
53678: PLUS
53679: PUSH
53680: LD_VAR 0 2
53684: PUSH
53685: LD_INT 4
53687: PUSH
53688: EMPTY
53689: LIST
53690: LIST
53691: LIST
53692: PUSH
53693: LD_VAR 0 1
53697: PUSH
53698: LD_INT 4
53700: PLUS
53701: PUSH
53702: LD_VAR 0 2
53706: PUSH
53707: LD_INT 4
53709: PLUS
53710: PUSH
53711: LD_INT 5
53713: PUSH
53714: EMPTY
53715: LIST
53716: LIST
53717: LIST
53718: PUSH
53719: LD_VAR 0 1
53723: PUSH
53724: LD_INT 4
53726: MINUS
53727: PUSH
53728: LD_VAR 0 2
53732: PUSH
53733: LD_INT 1
53735: PUSH
53736: EMPTY
53737: LIST
53738: LIST
53739: LIST
53740: PUSH
53741: LD_VAR 0 1
53745: PUSH
53746: LD_VAR 0 2
53750: PUSH
53751: LD_INT 4
53753: MINUS
53754: PUSH
53755: LD_INT 3
53757: PUSH
53758: EMPTY
53759: LIST
53760: LIST
53761: LIST
53762: PUSH
53763: LD_VAR 0 1
53767: PUSH
53768: LD_INT 3
53770: MINUS
53771: PUSH
53772: LD_VAR 0 2
53776: PUSH
53777: LD_INT 3
53779: MINUS
53780: PUSH
53781: LD_INT 2
53783: PUSH
53784: EMPTY
53785: LIST
53786: LIST
53787: LIST
53788: PUSH
53789: EMPTY
53790: LIST
53791: LIST
53792: LIST
53793: LIST
53794: LIST
53795: ST_TO_ADDR
// end ; 4 :
53796: GO 54077
53798: LD_INT 4
53800: DOUBLE
53801: EQUAL
53802: IFTRUE 53806
53804: GO 53939
53806: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53807: LD_ADDR_VAR 0 5
53811: PUSH
53812: LD_VAR 0 1
53816: PUSH
53817: LD_VAR 0 2
53821: PUSH
53822: LD_INT 4
53824: PLUS
53825: PUSH
53826: LD_INT 0
53828: PUSH
53829: EMPTY
53830: LIST
53831: LIST
53832: LIST
53833: PUSH
53834: LD_VAR 0 1
53838: PUSH
53839: LD_INT 3
53841: PLUS
53842: PUSH
53843: LD_VAR 0 2
53847: PUSH
53848: LD_INT 3
53850: PLUS
53851: PUSH
53852: LD_INT 5
53854: PUSH
53855: EMPTY
53856: LIST
53857: LIST
53858: LIST
53859: PUSH
53860: LD_VAR 0 1
53864: PUSH
53865: LD_INT 4
53867: PLUS
53868: PUSH
53869: LD_VAR 0 2
53873: PUSH
53874: LD_INT 4
53876: PUSH
53877: EMPTY
53878: LIST
53879: LIST
53880: LIST
53881: PUSH
53882: LD_VAR 0 1
53886: PUSH
53887: LD_VAR 0 2
53891: PUSH
53892: LD_INT 3
53894: MINUS
53895: PUSH
53896: LD_INT 3
53898: PUSH
53899: EMPTY
53900: LIST
53901: LIST
53902: LIST
53903: PUSH
53904: LD_VAR 0 1
53908: PUSH
53909: LD_INT 4
53911: MINUS
53912: PUSH
53913: LD_VAR 0 2
53917: PUSH
53918: LD_INT 4
53920: MINUS
53921: PUSH
53922: LD_INT 2
53924: PUSH
53925: EMPTY
53926: LIST
53927: LIST
53928: LIST
53929: PUSH
53930: EMPTY
53931: LIST
53932: LIST
53933: LIST
53934: LIST
53935: LIST
53936: ST_TO_ADDR
// end ; 5 :
53937: GO 54077
53939: LD_INT 5
53941: DOUBLE
53942: EQUAL
53943: IFTRUE 53947
53945: GO 54076
53947: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53948: LD_ADDR_VAR 0 5
53952: PUSH
53953: LD_VAR 0 1
53957: PUSH
53958: LD_INT 4
53960: MINUS
53961: PUSH
53962: LD_VAR 0 2
53966: PUSH
53967: LD_INT 1
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: PUSH
53975: LD_VAR 0 1
53979: PUSH
53980: LD_VAR 0 2
53984: PUSH
53985: LD_INT 4
53987: MINUS
53988: PUSH
53989: LD_INT 3
53991: PUSH
53992: EMPTY
53993: LIST
53994: LIST
53995: LIST
53996: PUSH
53997: LD_VAR 0 1
54001: PUSH
54002: LD_INT 4
54004: PLUS
54005: PUSH
54006: LD_VAR 0 2
54010: PUSH
54011: LD_INT 4
54013: PLUS
54014: PUSH
54015: LD_INT 5
54017: PUSH
54018: EMPTY
54019: LIST
54020: LIST
54021: LIST
54022: PUSH
54023: LD_VAR 0 1
54027: PUSH
54028: LD_INT 3
54030: PLUS
54031: PUSH
54032: LD_VAR 0 2
54036: PUSH
54037: LD_INT 4
54039: PUSH
54040: EMPTY
54041: LIST
54042: LIST
54043: LIST
54044: PUSH
54045: LD_VAR 0 1
54049: PUSH
54050: LD_VAR 0 2
54054: PUSH
54055: LD_INT 3
54057: PLUS
54058: PUSH
54059: LD_INT 0
54061: PUSH
54062: EMPTY
54063: LIST
54064: LIST
54065: LIST
54066: PUSH
54067: EMPTY
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: ST_TO_ADDR
// end ; end ;
54074: GO 54077
54076: POP
// result := list ;
54077: LD_ADDR_VAR 0 4
54081: PUSH
54082: LD_VAR 0 5
54086: ST_TO_ADDR
// end ;
54087: LD_VAR 0 4
54091: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54092: LD_INT 0
54094: PPUSH
54095: PPUSH
54096: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54097: LD_VAR 0 1
54101: NOT
54102: IFTRUE 54130
54104: PUSH
54105: LD_VAR 0 2
54109: PUSH
54110: LD_INT 1
54112: PUSH
54113: LD_INT 2
54115: PUSH
54116: LD_INT 3
54118: PUSH
54119: LD_INT 4
54121: PUSH
54122: EMPTY
54123: LIST
54124: LIST
54125: LIST
54126: LIST
54127: IN
54128: NOT
54129: OR
54130: IFFALSE 54134
// exit ;
54132: GO 54217
// tmp := [ ] ;
54134: LD_ADDR_VAR 0 5
54138: PUSH
54139: EMPTY
54140: ST_TO_ADDR
// for i in units do
54141: LD_ADDR_VAR 0 4
54145: PUSH
54146: LD_VAR 0 1
54150: PUSH
54151: FOR_IN
54152: IFFALSE 54186
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
54154: LD_ADDR_VAR 0 5
54158: PUSH
54159: LD_VAR 0 5
54163: PPUSH
54164: LD_VAR 0 4
54168: PPUSH
54169: LD_VAR 0 2
54173: PPUSH
54174: CALL_OW 259
54178: PPUSH
54179: CALL 55612 0 2
54183: ST_TO_ADDR
54184: GO 54151
54186: POP
54187: POP
// if not tmp then
54188: LD_VAR 0 5
54192: NOT
54193: IFFALSE 54197
// exit ;
54195: GO 54217
// result := SortListByListDesc ( units , tmp ) ;
54197: LD_ADDR_VAR 0 3
54201: PUSH
54202: LD_VAR 0 1
54206: PPUSH
54207: LD_VAR 0 5
54211: PPUSH
54212: CALL_OW 77
54216: ST_TO_ADDR
// end ;
54217: LD_VAR 0 3
54221: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54222: LD_INT 0
54224: PPUSH
54225: PPUSH
54226: PPUSH
// result := false ;
54227: LD_ADDR_VAR 0 3
54231: PUSH
54232: LD_INT 0
54234: ST_TO_ADDR
// if not building then
54235: LD_VAR 0 2
54239: NOT
54240: IFFALSE 54244
// exit ;
54242: GO 54388
// x := GetX ( building ) ;
54244: LD_ADDR_VAR 0 4
54248: PUSH
54249: LD_VAR 0 2
54253: PPUSH
54254: CALL_OW 250
54258: ST_TO_ADDR
// y := GetY ( building ) ;
54259: LD_ADDR_VAR 0 5
54263: PUSH
54264: LD_VAR 0 2
54268: PPUSH
54269: CALL_OW 251
54273: ST_TO_ADDR
// if not x or not y then
54274: LD_VAR 0 4
54278: NOT
54279: IFTRUE 54288
54281: PUSH
54282: LD_VAR 0 5
54286: NOT
54287: OR
54288: IFFALSE 54292
// exit ;
54290: GO 54388
// if GetTaskList ( unit ) then
54292: LD_VAR 0 1
54296: PPUSH
54297: CALL_OW 437
54301: IFFALSE 54388
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54303: LD_STRING e
54305: PUSH
54306: LD_VAR 0 1
54310: PPUSH
54311: CALL_OW 437
54315: PUSH
54316: LD_INT 1
54318: ARRAY
54319: PUSH
54320: LD_INT 1
54322: ARRAY
54323: EQUAL
54324: IFFALSE 54351
54326: PUSH
54327: LD_VAR 0 4
54331: PUSH
54332: LD_VAR 0 1
54336: PPUSH
54337: CALL_OW 437
54341: PUSH
54342: LD_INT 1
54344: ARRAY
54345: PUSH
54346: LD_INT 2
54348: ARRAY
54349: EQUAL
54350: AND
54351: IFFALSE 54378
54353: PUSH
54354: LD_VAR 0 5
54358: PUSH
54359: LD_VAR 0 1
54363: PPUSH
54364: CALL_OW 437
54368: PUSH
54369: LD_INT 1
54371: ARRAY
54372: PUSH
54373: LD_INT 3
54375: ARRAY
54376: EQUAL
54377: AND
54378: IFFALSE 54388
// result := true end ;
54380: LD_ADDR_VAR 0 3
54384: PUSH
54385: LD_INT 1
54387: ST_TO_ADDR
// end ;
54388: LD_VAR 0 3
54392: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54393: LD_INT 0
54395: PPUSH
// result := false ;
54396: LD_ADDR_VAR 0 4
54400: PUSH
54401: LD_INT 0
54403: ST_TO_ADDR
// if GetTaskList ( unit ) then
54404: LD_VAR 0 1
54408: PPUSH
54409: CALL_OW 437
54413: IFFALSE 54500
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54415: LD_STRING M
54417: PUSH
54418: LD_VAR 0 1
54422: PPUSH
54423: CALL_OW 437
54427: PUSH
54428: LD_INT 1
54430: ARRAY
54431: PUSH
54432: LD_INT 1
54434: ARRAY
54435: EQUAL
54436: IFFALSE 54463
54438: PUSH
54439: LD_VAR 0 2
54443: PUSH
54444: LD_VAR 0 1
54448: PPUSH
54449: CALL_OW 437
54453: PUSH
54454: LD_INT 1
54456: ARRAY
54457: PUSH
54458: LD_INT 2
54460: ARRAY
54461: EQUAL
54462: AND
54463: IFFALSE 54490
54465: PUSH
54466: LD_VAR 0 3
54470: PUSH
54471: LD_VAR 0 1
54475: PPUSH
54476: CALL_OW 437
54480: PUSH
54481: LD_INT 1
54483: ARRAY
54484: PUSH
54485: LD_INT 3
54487: ARRAY
54488: EQUAL
54489: AND
54490: IFFALSE 54500
// result := true ;
54492: LD_ADDR_VAR 0 4
54496: PUSH
54497: LD_INT 1
54499: ST_TO_ADDR
// end ; end ;
54500: LD_VAR 0 4
54504: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54505: LD_INT 0
54507: PPUSH
54508: PPUSH
54509: PPUSH
54510: PPUSH
// if not unit or not area then
54511: LD_VAR 0 1
54515: NOT
54516: IFTRUE 54525
54518: PUSH
54519: LD_VAR 0 2
54523: NOT
54524: OR
54525: IFFALSE 54529
// exit ;
54527: GO 54705
// tmp := AreaToList ( area , i ) ;
54529: LD_ADDR_VAR 0 6
54533: PUSH
54534: LD_VAR 0 2
54538: PPUSH
54539: LD_VAR 0 5
54543: PPUSH
54544: CALL_OW 517
54548: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54549: LD_ADDR_VAR 0 5
54553: PUSH
54554: DOUBLE
54555: LD_INT 1
54557: DEC
54558: ST_TO_ADDR
54559: LD_VAR 0 6
54563: PUSH
54564: LD_INT 1
54566: ARRAY
54567: PUSH
54568: FOR_TO
54569: IFFALSE 54703
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54571: LD_ADDR_VAR 0 7
54575: PUSH
54576: LD_VAR 0 6
54580: PUSH
54581: LD_INT 1
54583: ARRAY
54584: PUSH
54585: LD_VAR 0 5
54589: ARRAY
54590: PUSH
54591: LD_VAR 0 6
54595: PUSH
54596: LD_INT 2
54598: ARRAY
54599: PUSH
54600: LD_VAR 0 5
54604: ARRAY
54605: PUSH
54606: EMPTY
54607: LIST
54608: LIST
54609: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
54610: LD_INT 92
54612: PUSH
54613: LD_VAR 0 7
54617: PUSH
54618: LD_INT 1
54620: ARRAY
54621: PUSH
54622: LD_VAR 0 7
54626: PUSH
54627: LD_INT 2
54629: ARRAY
54630: PUSH
54631: LD_INT 2
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: LIST
54638: LIST
54639: PPUSH
54640: CALL_OW 69
54644: PUSH
54645: LD_INT 0
54647: EQUAL
54648: IFFALSE 54701
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54650: LD_VAR 0 1
54654: PPUSH
54655: LD_VAR 0 7
54659: PUSH
54660: LD_INT 1
54662: ARRAY
54663: PPUSH
54664: LD_VAR 0 7
54668: PUSH
54669: LD_INT 2
54671: ARRAY
54672: PPUSH
54673: LD_VAR 0 3
54677: PPUSH
54678: CALL_OW 48
// result := IsPlaced ( unit ) ;
54682: LD_ADDR_VAR 0 4
54686: PUSH
54687: LD_VAR 0 1
54691: PPUSH
54692: CALL_OW 305
54696: ST_TO_ADDR
// exit ;
54697: POP
54698: POP
54699: GO 54705
// end ; end ;
54701: GO 54568
54703: POP
54704: POP
// end ;
54705: LD_VAR 0 4
54709: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54710: LD_INT 0
54712: PPUSH
54713: PPUSH
54714: PPUSH
// if not side or side > 8 then
54715: LD_VAR 0 1
54719: NOT
54720: IFTRUE 54732
54722: PUSH
54723: LD_VAR 0 1
54727: PUSH
54728: LD_INT 8
54730: GREATER
54731: OR
54732: IFFALSE 54736
// exit ;
54734: GO 54923
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54736: LD_ADDR_VAR 0 4
54740: PUSH
54741: LD_INT 22
54743: PUSH
54744: LD_VAR 0 1
54748: PUSH
54749: EMPTY
54750: LIST
54751: LIST
54752: PUSH
54753: LD_INT 21
54755: PUSH
54756: LD_INT 3
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: EMPTY
54764: LIST
54765: LIST
54766: PPUSH
54767: CALL_OW 69
54771: ST_TO_ADDR
// if not tmp then
54772: LD_VAR 0 4
54776: NOT
54777: IFFALSE 54781
// exit ;
54779: GO 54923
// enable_addtolog := true ;
54781: LD_ADDR_OWVAR 81
54785: PUSH
54786: LD_INT 1
54788: ST_TO_ADDR
// AddToLog ( [ ) ;
54789: LD_STRING [
54791: PPUSH
54792: CALL_OW 561
// for i in tmp do
54796: LD_ADDR_VAR 0 3
54800: PUSH
54801: LD_VAR 0 4
54805: PUSH
54806: FOR_IN
54807: IFFALSE 54914
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54809: LD_STRING [
54811: PUSH
54812: LD_VAR 0 3
54816: PPUSH
54817: CALL_OW 266
54821: STR
54822: PUSH
54823: LD_STRING , 
54825: STR
54826: PUSH
54827: LD_VAR 0 3
54831: PPUSH
54832: CALL_OW 250
54836: STR
54837: PUSH
54838: LD_STRING , 
54840: STR
54841: PUSH
54842: LD_VAR 0 3
54846: PPUSH
54847: CALL_OW 251
54851: STR
54852: PUSH
54853: LD_STRING , 
54855: STR
54856: PUSH
54857: LD_VAR 0 3
54861: PPUSH
54862: CALL_OW 254
54866: STR
54867: PUSH
54868: LD_STRING , 
54870: STR
54871: PUSH
54872: LD_VAR 0 3
54876: PPUSH
54877: LD_INT 1
54879: PPUSH
54880: CALL_OW 268
54884: STR
54885: PUSH
54886: LD_STRING , 
54888: STR
54889: PUSH
54890: LD_VAR 0 3
54894: PPUSH
54895: LD_INT 2
54897: PPUSH
54898: CALL_OW 268
54902: STR
54903: PUSH
54904: LD_STRING ],
54906: STR
54907: PPUSH
54908: CALL_OW 561
// end ;
54912: GO 54806
54914: POP
54915: POP
// AddToLog ( ]; ) ;
54916: LD_STRING ];
54918: PPUSH
54919: CALL_OW 561
// end ;
54923: LD_VAR 0 2
54927: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54928: LD_INT 0
54930: PPUSH
54931: PPUSH
54932: PPUSH
54933: PPUSH
54934: PPUSH
// if not area or not rate or not max then
54935: LD_VAR 0 1
54939: NOT
54940: IFTRUE 54949
54942: PUSH
54943: LD_VAR 0 2
54947: NOT
54948: OR
54949: IFTRUE 54958
54951: PUSH
54952: LD_VAR 0 4
54956: NOT
54957: OR
54958: IFFALSE 54962
// exit ;
54960: GO 55151
// while 1 do
54962: LD_INT 1
54964: IFFALSE 55151
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54966: LD_ADDR_VAR 0 9
54970: PUSH
54971: LD_VAR 0 1
54975: PPUSH
54976: LD_INT 1
54978: PPUSH
54979: CALL_OW 287
54983: PUSH
54984: LD_INT 10
54986: MUL
54987: ST_TO_ADDR
// r := rate / 10 ;
54988: LD_ADDR_VAR 0 7
54992: PUSH
54993: LD_VAR 0 2
54997: PUSH
54998: LD_INT 10
55000: DIVREAL
55001: ST_TO_ADDR
// time := 1 1$00 ;
55002: LD_ADDR_VAR 0 8
55006: PUSH
55007: LD_INT 2100
55009: ST_TO_ADDR
// if amount < min then
55010: LD_VAR 0 9
55014: PUSH
55015: LD_VAR 0 3
55019: LESS
55020: IFFALSE 55038
// r := r * 2 else
55022: LD_ADDR_VAR 0 7
55026: PUSH
55027: LD_VAR 0 7
55031: PUSH
55032: LD_INT 2
55034: MUL
55035: ST_TO_ADDR
55036: GO 55064
// if amount > max then
55038: LD_VAR 0 9
55042: PUSH
55043: LD_VAR 0 4
55047: GREATER
55048: IFFALSE 55064
// r := r / 2 ;
55050: LD_ADDR_VAR 0 7
55054: PUSH
55055: LD_VAR 0 7
55059: PUSH
55060: LD_INT 2
55062: DIVREAL
55063: ST_TO_ADDR
// time := time / r ;
55064: LD_ADDR_VAR 0 8
55068: PUSH
55069: LD_VAR 0 8
55073: PUSH
55074: LD_VAR 0 7
55078: DIVREAL
55079: ST_TO_ADDR
// if time < 0 then
55080: LD_VAR 0 8
55084: PUSH
55085: LD_INT 0
55087: LESS
55088: IFFALSE 55105
// time := time * - 1 ;
55090: LD_ADDR_VAR 0 8
55094: PUSH
55095: LD_VAR 0 8
55099: PUSH
55100: LD_INT 1
55102: NEG
55103: MUL
55104: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
55105: LD_VAR 0 8
55109: PUSH
55110: LD_INT 35
55112: PPUSH
55113: LD_INT 875
55115: PPUSH
55116: CALL_OW 12
55120: PLUS
55121: PPUSH
55122: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55126: LD_INT 1
55128: PPUSH
55129: LD_INT 5
55131: PPUSH
55132: CALL_OW 12
55136: PPUSH
55137: LD_VAR 0 1
55141: PPUSH
55142: LD_INT 1
55144: PPUSH
55145: CALL_OW 55
// end ;
55149: GO 54962
// end ;
55151: LD_VAR 0 5
55155: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55156: LD_INT 0
55158: PPUSH
55159: PPUSH
55160: PPUSH
55161: PPUSH
55162: PPUSH
55163: PPUSH
55164: PPUSH
55165: PPUSH
// if not turrets or not factories then
55166: LD_VAR 0 1
55170: NOT
55171: IFTRUE 55180
55173: PUSH
55174: LD_VAR 0 2
55178: NOT
55179: OR
55180: IFFALSE 55184
// exit ;
55182: GO 55491
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55184: LD_ADDR_VAR 0 10
55188: PUSH
55189: LD_INT 5
55191: PUSH
55192: LD_INT 6
55194: PUSH
55195: EMPTY
55196: LIST
55197: LIST
55198: PUSH
55199: LD_INT 2
55201: PUSH
55202: LD_INT 4
55204: PUSH
55205: EMPTY
55206: LIST
55207: LIST
55208: PUSH
55209: LD_INT 3
55211: PUSH
55212: LD_INT 5
55214: PUSH
55215: EMPTY
55216: LIST
55217: LIST
55218: PUSH
55219: EMPTY
55220: LIST
55221: LIST
55222: LIST
55223: PUSH
55224: LD_INT 24
55226: PUSH
55227: LD_INT 25
55229: PUSH
55230: EMPTY
55231: LIST
55232: LIST
55233: PUSH
55234: LD_INT 23
55236: PUSH
55237: LD_INT 27
55239: PUSH
55240: EMPTY
55241: LIST
55242: LIST
55243: PUSH
55244: EMPTY
55245: LIST
55246: LIST
55247: PUSH
55248: LD_INT 42
55250: PUSH
55251: LD_INT 43
55253: PUSH
55254: EMPTY
55255: LIST
55256: LIST
55257: PUSH
55258: LD_INT 44
55260: PUSH
55261: LD_INT 46
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: PUSH
55268: LD_INT 45
55270: PUSH
55271: LD_INT 47
55273: PUSH
55274: EMPTY
55275: LIST
55276: LIST
55277: PUSH
55278: EMPTY
55279: LIST
55280: LIST
55281: LIST
55282: PUSH
55283: EMPTY
55284: LIST
55285: LIST
55286: LIST
55287: ST_TO_ADDR
// result := [ ] ;
55288: LD_ADDR_VAR 0 3
55292: PUSH
55293: EMPTY
55294: ST_TO_ADDR
// for i in turrets do
55295: LD_ADDR_VAR 0 4
55299: PUSH
55300: LD_VAR 0 1
55304: PUSH
55305: FOR_IN
55306: IFFALSE 55489
// begin nat := GetNation ( i ) ;
55308: LD_ADDR_VAR 0 7
55312: PUSH
55313: LD_VAR 0 4
55317: PPUSH
55318: CALL_OW 248
55322: ST_TO_ADDR
// weapon := 0 ;
55323: LD_ADDR_VAR 0 8
55327: PUSH
55328: LD_INT 0
55330: ST_TO_ADDR
// if not nat then
55331: LD_VAR 0 7
55335: NOT
55336: IFFALSE 55340
// continue ;
55338: GO 55305
// for j in list [ nat ] do
55340: LD_ADDR_VAR 0 5
55344: PUSH
55345: LD_VAR 0 10
55349: PUSH
55350: LD_VAR 0 7
55354: ARRAY
55355: PUSH
55356: FOR_IN
55357: IFFALSE 55398
// if GetBWeapon ( i ) = j [ 1 ] then
55359: LD_VAR 0 4
55363: PPUSH
55364: CALL_OW 269
55368: PUSH
55369: LD_VAR 0 5
55373: PUSH
55374: LD_INT 1
55376: ARRAY
55377: EQUAL
55378: IFFALSE 55396
// begin weapon := j [ 2 ] ;
55380: LD_ADDR_VAR 0 8
55384: PUSH
55385: LD_VAR 0 5
55389: PUSH
55390: LD_INT 2
55392: ARRAY
55393: ST_TO_ADDR
// break ;
55394: GO 55398
// end ;
55396: GO 55356
55398: POP
55399: POP
// if not weapon then
55400: LD_VAR 0 8
55404: NOT
55405: IFFALSE 55409
// continue ;
55407: GO 55305
// for k in factories do
55409: LD_ADDR_VAR 0 6
55413: PUSH
55414: LD_VAR 0 2
55418: PUSH
55419: FOR_IN
55420: IFFALSE 55485
// begin weapons := AvailableWeaponList ( k ) ;
55422: LD_ADDR_VAR 0 9
55426: PUSH
55427: LD_VAR 0 6
55431: PPUSH
55432: CALL_OW 478
55436: ST_TO_ADDR
// if not weapons then
55437: LD_VAR 0 9
55441: NOT
55442: IFFALSE 55446
// continue ;
55444: GO 55419
// if weapon in weapons then
55446: LD_VAR 0 8
55450: PUSH
55451: LD_VAR 0 9
55455: IN
55456: IFFALSE 55483
// begin result := [ i , weapon ] ;
55458: LD_ADDR_VAR 0 3
55462: PUSH
55463: LD_VAR 0 4
55467: PUSH
55468: LD_VAR 0 8
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: ST_TO_ADDR
// exit ;
55477: POP
55478: POP
55479: POP
55480: POP
55481: GO 55491
// end ; end ;
55483: GO 55419
55485: POP
55486: POP
// end ;
55487: GO 55305
55489: POP
55490: POP
// end ;
55491: LD_VAR 0 3
55495: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55496: LD_INT 0
55498: PPUSH
// if not side or side > 8 then
55499: LD_VAR 0 3
55503: NOT
55504: IFTRUE 55516
55506: PUSH
55507: LD_VAR 0 3
55511: PUSH
55512: LD_INT 8
55514: GREATER
55515: OR
55516: IFFALSE 55520
// exit ;
55518: GO 55579
// if not range then
55520: LD_VAR 0 4
55524: NOT
55525: IFFALSE 55536
// range := - 12 ;
55527: LD_ADDR_VAR 0 4
55531: PUSH
55532: LD_INT 12
55534: NEG
55535: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55536: LD_VAR 0 1
55540: PPUSH
55541: LD_VAR 0 2
55545: PPUSH
55546: LD_VAR 0 3
55550: PPUSH
55551: LD_VAR 0 4
55555: PPUSH
55556: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55560: LD_VAR 0 1
55564: PPUSH
55565: LD_VAR 0 2
55569: PPUSH
55570: LD_VAR 0 3
55574: PPUSH
55575: CALL_OW 331
// end ;
55579: LD_VAR 0 5
55583: RET
// export function Video ( mode ) ; begin
55584: LD_INT 0
55586: PPUSH
// ingame_video = mode ;
55587: LD_ADDR_OWVAR 52
55591: PUSH
55592: LD_VAR 0 1
55596: ST_TO_ADDR
// interface_hidden = mode ;
55597: LD_ADDR_OWVAR 54
55601: PUSH
55602: LD_VAR 0 1
55606: ST_TO_ADDR
// end ;
55607: LD_VAR 0 2
55611: RET
// export function Join ( array , element ) ; begin
55612: LD_INT 0
55614: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55615: LD_ADDR_VAR 0 3
55619: PUSH
55620: LD_VAR 0 1
55624: PPUSH
55625: LD_VAR 0 1
55629: PUSH
55630: LD_INT 1
55632: PLUS
55633: PPUSH
55634: LD_VAR 0 2
55638: PPUSH
55639: CALL_OW 1
55643: ST_TO_ADDR
// end ;
55644: LD_VAR 0 3
55648: RET
// export function JoinUnion ( array , element ) ; begin
55649: LD_INT 0
55651: PPUSH
// result := array union element ;
55652: LD_ADDR_VAR 0 3
55656: PUSH
55657: LD_VAR 0 1
55661: PUSH
55662: LD_VAR 0 2
55666: UNION
55667: ST_TO_ADDR
// end ;
55668: LD_VAR 0 3
55672: RET
// export function GetBehemoths ( side ) ; begin
55673: LD_INT 0
55675: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55676: LD_ADDR_VAR 0 2
55680: PUSH
55681: LD_INT 22
55683: PUSH
55684: LD_VAR 0 1
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: PUSH
55693: LD_INT 31
55695: PUSH
55696: LD_INT 25
55698: PUSH
55699: EMPTY
55700: LIST
55701: LIST
55702: PUSH
55703: EMPTY
55704: LIST
55705: LIST
55706: PPUSH
55707: CALL_OW 69
55711: ST_TO_ADDR
// end ;
55712: LD_VAR 0 2
55716: RET
// export function Shuffle ( array ) ; var i , index ; begin
55717: LD_INT 0
55719: PPUSH
55720: PPUSH
55721: PPUSH
// result := [ ] ;
55722: LD_ADDR_VAR 0 2
55726: PUSH
55727: EMPTY
55728: ST_TO_ADDR
// if not array then
55729: LD_VAR 0 1
55733: NOT
55734: IFFALSE 55738
// exit ;
55736: GO 55837
// Randomize ;
55738: CALL_OW 10
// for i = array downto 1 do
55742: LD_ADDR_VAR 0 3
55746: PUSH
55747: DOUBLE
55748: LD_VAR 0 1
55752: INC
55753: ST_TO_ADDR
55754: LD_INT 1
55756: PUSH
55757: FOR_DOWNTO
55758: IFFALSE 55835
// begin index := rand ( 1 , array ) ;
55760: LD_ADDR_VAR 0 4
55764: PUSH
55765: LD_INT 1
55767: PPUSH
55768: LD_VAR 0 1
55772: PPUSH
55773: CALL_OW 12
55777: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55778: LD_ADDR_VAR 0 2
55782: PUSH
55783: LD_VAR 0 2
55787: PPUSH
55788: LD_VAR 0 2
55792: PUSH
55793: LD_INT 1
55795: PLUS
55796: PPUSH
55797: LD_VAR 0 1
55801: PUSH
55802: LD_VAR 0 4
55806: ARRAY
55807: PPUSH
55808: CALL_OW 2
55812: ST_TO_ADDR
// array := Delete ( array , index ) ;
55813: LD_ADDR_VAR 0 1
55817: PUSH
55818: LD_VAR 0 1
55822: PPUSH
55823: LD_VAR 0 4
55827: PPUSH
55828: CALL_OW 3
55832: ST_TO_ADDR
// end ;
55833: GO 55757
55835: POP
55836: POP
// end ;
55837: LD_VAR 0 2
55841: RET
// export function GetBaseMaterials ( base ) ; begin
55842: LD_INT 0
55844: PPUSH
// result := [ 0 , 0 , 0 ] ;
55845: LD_ADDR_VAR 0 2
55849: PUSH
55850: LD_INT 0
55852: PUSH
55853: LD_INT 0
55855: PUSH
55856: LD_INT 0
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
// if not base then
55864: LD_VAR 0 1
55868: NOT
55869: IFFALSE 55873
// exit ;
55871: GO 55922
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55873: LD_ADDR_VAR 0 2
55877: PUSH
55878: LD_VAR 0 1
55882: PPUSH
55883: LD_INT 1
55885: PPUSH
55886: CALL_OW 275
55890: PUSH
55891: LD_VAR 0 1
55895: PPUSH
55896: LD_INT 2
55898: PPUSH
55899: CALL_OW 275
55903: PUSH
55904: LD_VAR 0 1
55908: PPUSH
55909: LD_INT 3
55911: PPUSH
55912: CALL_OW 275
55916: PUSH
55917: EMPTY
55918: LIST
55919: LIST
55920: LIST
55921: ST_TO_ADDR
// end ;
55922: LD_VAR 0 2
55926: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55927: LD_INT 0
55929: PPUSH
55930: PPUSH
// result := array ;
55931: LD_ADDR_VAR 0 3
55935: PUSH
55936: LD_VAR 0 1
55940: ST_TO_ADDR
// if size >= result then
55941: LD_VAR 0 2
55945: PUSH
55946: LD_VAR 0 3
55950: GREATEREQUAL
55951: IFFALSE 55955
// exit ;
55953: GO 56005
// if size then
55955: LD_VAR 0 2
55959: IFFALSE 56005
// for i := array downto size do
55961: LD_ADDR_VAR 0 4
55965: PUSH
55966: DOUBLE
55967: LD_VAR 0 1
55971: INC
55972: ST_TO_ADDR
55973: LD_VAR 0 2
55977: PUSH
55978: FOR_DOWNTO
55979: IFFALSE 56003
// result := Delete ( result , result ) ;
55981: LD_ADDR_VAR 0 3
55985: PUSH
55986: LD_VAR 0 3
55990: PPUSH
55991: LD_VAR 0 3
55995: PPUSH
55996: CALL_OW 3
56000: ST_TO_ADDR
56001: GO 55978
56003: POP
56004: POP
// end ;
56005: LD_VAR 0 3
56009: RET
// export function ComExit ( unit ) ; var tmp ; begin
56010: LD_INT 0
56012: PPUSH
56013: PPUSH
// if not IsInUnit ( unit ) then
56014: LD_VAR 0 1
56018: PPUSH
56019: CALL_OW 310
56023: NOT
56024: IFFALSE 56028
// exit ;
56026: GO 56088
// tmp := IsInUnit ( unit ) ;
56028: LD_ADDR_VAR 0 3
56032: PUSH
56033: LD_VAR 0 1
56037: PPUSH
56038: CALL_OW 310
56042: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
56043: LD_VAR 0 3
56047: PPUSH
56048: CALL_OW 247
56052: PUSH
56053: LD_INT 2
56055: EQUAL
56056: IFFALSE 56069
// ComExitVehicle ( unit ) else
56058: LD_VAR 0 1
56062: PPUSH
56063: CALL_OW 121
56067: GO 56078
// ComExitBuilding ( unit ) ;
56069: LD_VAR 0 1
56073: PPUSH
56074: CALL_OW 122
// result := tmp ;
56078: LD_ADDR_VAR 0 2
56082: PUSH
56083: LD_VAR 0 3
56087: ST_TO_ADDR
// end ;
56088: LD_VAR 0 2
56092: RET
// export function ComExitAll ( units ) ; var i ; begin
56093: LD_INT 0
56095: PPUSH
56096: PPUSH
// if not units then
56097: LD_VAR 0 1
56101: NOT
56102: IFFALSE 56106
// exit ;
56104: GO 56132
// for i in units do
56106: LD_ADDR_VAR 0 3
56110: PUSH
56111: LD_VAR 0 1
56115: PUSH
56116: FOR_IN
56117: IFFALSE 56130
// ComExit ( i ) ;
56119: LD_VAR 0 3
56123: PPUSH
56124: CALL 56010 0 1
56128: GO 56116
56130: POP
56131: POP
// end ;
56132: LD_VAR 0 2
56136: RET
// export function ResetHc ; begin
56137: LD_INT 0
56139: PPUSH
// InitHc ;
56140: CALL_OW 19
// hc_importance := 0 ;
56144: LD_ADDR_OWVAR 32
56148: PUSH
56149: LD_INT 0
56151: ST_TO_ADDR
// end ;
56152: LD_VAR 0 1
56156: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56157: LD_INT 0
56159: PPUSH
56160: PPUSH
56161: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56162: LD_ADDR_VAR 0 6
56166: PUSH
56167: LD_VAR 0 1
56171: PUSH
56172: LD_VAR 0 3
56176: PLUS
56177: PUSH
56178: LD_INT 2
56180: DIV
56181: ST_TO_ADDR
// if _x < 0 then
56182: LD_VAR 0 6
56186: PUSH
56187: LD_INT 0
56189: LESS
56190: IFFALSE 56207
// _x := _x * - 1 ;
56192: LD_ADDR_VAR 0 6
56196: PUSH
56197: LD_VAR 0 6
56201: PUSH
56202: LD_INT 1
56204: NEG
56205: MUL
56206: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56207: LD_ADDR_VAR 0 7
56211: PUSH
56212: LD_VAR 0 2
56216: PUSH
56217: LD_VAR 0 4
56221: PLUS
56222: PUSH
56223: LD_INT 2
56225: DIV
56226: ST_TO_ADDR
// if _y < 0 then
56227: LD_VAR 0 7
56231: PUSH
56232: LD_INT 0
56234: LESS
56235: IFFALSE 56252
// _y := _y * - 1 ;
56237: LD_ADDR_VAR 0 7
56241: PUSH
56242: LD_VAR 0 7
56246: PUSH
56247: LD_INT 1
56249: NEG
56250: MUL
56251: ST_TO_ADDR
// result := [ _x , _y ] ;
56252: LD_ADDR_VAR 0 5
56256: PUSH
56257: LD_VAR 0 6
56261: PUSH
56262: LD_VAR 0 7
56266: PUSH
56267: EMPTY
56268: LIST
56269: LIST
56270: ST_TO_ADDR
// end ;
56271: LD_VAR 0 5
56275: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56276: LD_INT 0
56278: PPUSH
56279: PPUSH
56280: PPUSH
56281: PPUSH
// task := GetTaskList ( unit ) ;
56282: LD_ADDR_VAR 0 7
56286: PUSH
56287: LD_VAR 0 1
56291: PPUSH
56292: CALL_OW 437
56296: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56297: LD_VAR 0 7
56301: NOT
56302: IFFALSE 56321
56304: PUSH
56305: LD_VAR 0 1
56309: PPUSH
56310: LD_VAR 0 2
56314: PPUSH
56315: CALL_OW 308
56319: NOT
56320: AND
56321: IFFALSE 56325
// exit ;
56323: GO 56443
// if IsInArea ( unit , area ) then
56325: LD_VAR 0 1
56329: PPUSH
56330: LD_VAR 0 2
56334: PPUSH
56335: CALL_OW 308
56339: IFFALSE 56357
// begin ComMoveToArea ( unit , goAway ) ;
56341: LD_VAR 0 1
56345: PPUSH
56346: LD_VAR 0 3
56350: PPUSH
56351: CALL_OW 113
// exit ;
56355: GO 56443
// end ; if task [ 1 ] [ 1 ] <> M then
56357: LD_VAR 0 7
56361: PUSH
56362: LD_INT 1
56364: ARRAY
56365: PUSH
56366: LD_INT 1
56368: ARRAY
56369: PUSH
56370: LD_STRING M
56372: NONEQUAL
56373: IFFALSE 56377
// exit ;
56375: GO 56443
// x := task [ 1 ] [ 2 ] ;
56377: LD_ADDR_VAR 0 5
56381: PUSH
56382: LD_VAR 0 7
56386: PUSH
56387: LD_INT 1
56389: ARRAY
56390: PUSH
56391: LD_INT 2
56393: ARRAY
56394: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56395: LD_ADDR_VAR 0 6
56399: PUSH
56400: LD_VAR 0 7
56404: PUSH
56405: LD_INT 1
56407: ARRAY
56408: PUSH
56409: LD_INT 3
56411: ARRAY
56412: ST_TO_ADDR
// if InArea ( x , y , area ) then
56413: LD_VAR 0 5
56417: PPUSH
56418: LD_VAR 0 6
56422: PPUSH
56423: LD_VAR 0 2
56427: PPUSH
56428: CALL_OW 309
56432: IFFALSE 56443
// ComStop ( unit ) ;
56434: LD_VAR 0 1
56438: PPUSH
56439: CALL_OW 141
// end ;
56443: LD_VAR 0 4
56447: RET
// export function Abs ( value ) ; begin
56448: LD_INT 0
56450: PPUSH
// result := value ;
56451: LD_ADDR_VAR 0 2
56455: PUSH
56456: LD_VAR 0 1
56460: ST_TO_ADDR
// if value < 0 then
56461: LD_VAR 0 1
56465: PUSH
56466: LD_INT 0
56468: LESS
56469: IFFALSE 56486
// result := value * - 1 ;
56471: LD_ADDR_VAR 0 2
56475: PUSH
56476: LD_VAR 0 1
56480: PUSH
56481: LD_INT 1
56483: NEG
56484: MUL
56485: ST_TO_ADDR
// end ;
56486: LD_VAR 0 2
56490: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56491: LD_INT 0
56493: PPUSH
56494: PPUSH
56495: PPUSH
56496: PPUSH
56497: PPUSH
56498: PPUSH
56499: PPUSH
56500: PPUSH
// if not unit or not building then
56501: LD_VAR 0 1
56505: NOT
56506: IFTRUE 56515
56508: PUSH
56509: LD_VAR 0 2
56513: NOT
56514: OR
56515: IFFALSE 56519
// exit ;
56517: GO 56747
// x := GetX ( building ) ;
56519: LD_ADDR_VAR 0 4
56523: PUSH
56524: LD_VAR 0 2
56528: PPUSH
56529: CALL_OW 250
56533: ST_TO_ADDR
// y := GetY ( building ) ;
56534: LD_ADDR_VAR 0 6
56538: PUSH
56539: LD_VAR 0 2
56543: PPUSH
56544: CALL_OW 251
56548: ST_TO_ADDR
// d := GetDir ( building ) ;
56549: LD_ADDR_VAR 0 8
56553: PUSH
56554: LD_VAR 0 2
56558: PPUSH
56559: CALL_OW 254
56563: ST_TO_ADDR
// r := 4 ;
56564: LD_ADDR_VAR 0 9
56568: PUSH
56569: LD_INT 4
56571: ST_TO_ADDR
// for i := 1 to 5 do
56572: LD_ADDR_VAR 0 10
56576: PUSH
56577: DOUBLE
56578: LD_INT 1
56580: DEC
56581: ST_TO_ADDR
56582: LD_INT 5
56584: PUSH
56585: FOR_TO
56586: IFFALSE 56745
// begin _x := ShiftX ( x , d , r + i ) ;
56588: LD_ADDR_VAR 0 5
56592: PUSH
56593: LD_VAR 0 4
56597: PPUSH
56598: LD_VAR 0 8
56602: PPUSH
56603: LD_VAR 0 9
56607: PUSH
56608: LD_VAR 0 10
56612: PLUS
56613: PPUSH
56614: CALL_OW 272
56618: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56619: LD_ADDR_VAR 0 7
56623: PUSH
56624: LD_VAR 0 6
56628: PPUSH
56629: LD_VAR 0 8
56633: PPUSH
56634: LD_VAR 0 9
56638: PUSH
56639: LD_VAR 0 10
56643: PLUS
56644: PPUSH
56645: CALL_OW 273
56649: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56650: LD_VAR 0 5
56654: PPUSH
56655: LD_VAR 0 7
56659: PPUSH
56660: CALL_OW 488
56664: IFFALSE 56699
56666: PUSH
56667: LD_VAR 0 5
56671: PPUSH
56672: LD_VAR 0 7
56676: PPUSH
56677: CALL_OW 428
56681: PPUSH
56682: CALL_OW 247
56686: PUSH
56687: LD_INT 3
56689: PUSH
56690: LD_INT 2
56692: PUSH
56693: EMPTY
56694: LIST
56695: LIST
56696: IN
56697: NOT
56698: AND
56699: IFFALSE 56743
// begin ComMoveXY ( unit , _x , _y ) ;
56701: LD_VAR 0 1
56705: PPUSH
56706: LD_VAR 0 5
56710: PPUSH
56711: LD_VAR 0 7
56715: PPUSH
56716: CALL_OW 111
// result := [ _x , _y ] ;
56720: LD_ADDR_VAR 0 3
56724: PUSH
56725: LD_VAR 0 5
56729: PUSH
56730: LD_VAR 0 7
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: ST_TO_ADDR
// exit ;
56739: POP
56740: POP
56741: GO 56747
// end ; end ;
56743: GO 56585
56745: POP
56746: POP
// end ;
56747: LD_VAR 0 3
56751: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56752: LD_INT 0
56754: PPUSH
56755: PPUSH
56756: PPUSH
// result := 0 ;
56757: LD_ADDR_VAR 0 3
56761: PUSH
56762: LD_INT 0
56764: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56765: LD_VAR 0 1
56769: PUSH
56770: LD_INT 0
56772: LESS
56773: IFTRUE 56785
56775: PUSH
56776: LD_VAR 0 1
56780: PUSH
56781: LD_INT 8
56783: GREATER
56784: OR
56785: IFTRUE 56797
56787: PUSH
56788: LD_VAR 0 2
56792: PUSH
56793: LD_INT 0
56795: LESS
56796: OR
56797: IFTRUE 56809
56799: PUSH
56800: LD_VAR 0 2
56804: PUSH
56805: LD_INT 8
56807: GREATER
56808: OR
56809: IFFALSE 56813
// exit ;
56811: GO 56888
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56813: LD_ADDR_VAR 0 4
56817: PUSH
56818: LD_INT 22
56820: PUSH
56821: LD_VAR 0 2
56825: PUSH
56826: EMPTY
56827: LIST
56828: LIST
56829: PPUSH
56830: CALL_OW 69
56834: PUSH
56835: FOR_IN
56836: IFFALSE 56886
// begin un := UnitShoot ( i ) ;
56838: LD_ADDR_VAR 0 5
56842: PUSH
56843: LD_VAR 0 4
56847: PPUSH
56848: CALL_OW 504
56852: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56853: LD_VAR 0 5
56857: PPUSH
56858: CALL_OW 255
56862: PUSH
56863: LD_VAR 0 1
56867: EQUAL
56868: IFFALSE 56884
// begin result := un ;
56870: LD_ADDR_VAR 0 3
56874: PUSH
56875: LD_VAR 0 5
56879: ST_TO_ADDR
// exit ;
56880: POP
56881: POP
56882: GO 56888
// end ; end ;
56884: GO 56835
56886: POP
56887: POP
// end ;
56888: LD_VAR 0 3
56892: RET
// export function GetCargoBay ( units ) ; begin
56893: LD_INT 0
56895: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56896: LD_ADDR_VAR 0 2
56900: PUSH
56901: LD_VAR 0 1
56905: PPUSH
56906: LD_INT 2
56908: PUSH
56909: LD_INT 34
56911: PUSH
56912: LD_INT 12
56914: PUSH
56915: EMPTY
56916: LIST
56917: LIST
56918: PUSH
56919: LD_INT 34
56921: PUSH
56922: LD_INT 51
56924: PUSH
56925: EMPTY
56926: LIST
56927: LIST
56928: PUSH
56929: LD_INT 34
56931: PUSH
56932: LD_INT 32
56934: PUSH
56935: EMPTY
56936: LIST
56937: LIST
56938: PUSH
56939: LD_INT 34
56941: PUSH
56942: LD_INT 89
56944: PUSH
56945: EMPTY
56946: LIST
56947: LIST
56948: PUSH
56949: EMPTY
56950: LIST
56951: LIST
56952: LIST
56953: LIST
56954: LIST
56955: PPUSH
56956: CALL_OW 72
56960: ST_TO_ADDR
// end ;
56961: LD_VAR 0 2
56965: RET
// export function Negate ( value ) ; begin
56966: LD_INT 0
56968: PPUSH
// result := not value ;
56969: LD_ADDR_VAR 0 2
56973: PUSH
56974: LD_VAR 0 1
56978: NOT
56979: ST_TO_ADDR
// end ;
56980: LD_VAR 0 2
56984: RET
// export function Inc ( value ) ; begin
56985: LD_INT 0
56987: PPUSH
// result := value + 1 ;
56988: LD_ADDR_VAR 0 2
56992: PUSH
56993: LD_VAR 0 1
56997: PUSH
56998: LD_INT 1
57000: PLUS
57001: ST_TO_ADDR
// end ;
57002: LD_VAR 0 2
57006: RET
// export function Dec ( value ) ; begin
57007: LD_INT 0
57009: PPUSH
// result := value - 1 ;
57010: LD_ADDR_VAR 0 2
57014: PUSH
57015: LD_VAR 0 1
57019: PUSH
57020: LD_INT 1
57022: MINUS
57023: ST_TO_ADDR
// end ;
57024: LD_VAR 0 2
57028: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
57029: LD_INT 0
57031: PPUSH
57032: PPUSH
57033: PPUSH
57034: PPUSH
57035: PPUSH
57036: PPUSH
57037: PPUSH
57038: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
57039: LD_VAR 0 1
57043: PPUSH
57044: LD_VAR 0 2
57048: PPUSH
57049: CALL_OW 488
57053: NOT
57054: IFTRUE 57073
57056: PUSH
57057: LD_VAR 0 3
57061: PPUSH
57062: LD_VAR 0 4
57066: PPUSH
57067: CALL_OW 488
57071: NOT
57072: OR
57073: IFFALSE 57086
// begin result := - 1 ;
57075: LD_ADDR_VAR 0 5
57079: PUSH
57080: LD_INT 1
57082: NEG
57083: ST_TO_ADDR
// exit ;
57084: GO 57321
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
57086: LD_ADDR_VAR 0 12
57090: PUSH
57091: LD_VAR 0 1
57095: PPUSH
57096: LD_VAR 0 2
57100: PPUSH
57101: LD_VAR 0 3
57105: PPUSH
57106: LD_VAR 0 4
57110: PPUSH
57111: CALL 56157 0 4
57115: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
57116: LD_ADDR_VAR 0 11
57120: PUSH
57121: LD_VAR 0 1
57125: PPUSH
57126: LD_VAR 0 2
57130: PPUSH
57131: LD_VAR 0 12
57135: PUSH
57136: LD_INT 1
57138: ARRAY
57139: PPUSH
57140: LD_VAR 0 12
57144: PUSH
57145: LD_INT 2
57147: ARRAY
57148: PPUSH
57149: CALL_OW 298
57153: ST_TO_ADDR
// distance := 9999 ;
57154: LD_ADDR_VAR 0 10
57158: PUSH
57159: LD_INT 9999
57161: ST_TO_ADDR
// for i := 0 to 5 do
57162: LD_ADDR_VAR 0 6
57166: PUSH
57167: DOUBLE
57168: LD_INT 0
57170: DEC
57171: ST_TO_ADDR
57172: LD_INT 5
57174: PUSH
57175: FOR_TO
57176: IFFALSE 57319
// begin _x := ShiftX ( x1 , i , centerDist ) ;
57178: LD_ADDR_VAR 0 7
57182: PUSH
57183: LD_VAR 0 1
57187: PPUSH
57188: LD_VAR 0 6
57192: PPUSH
57193: LD_VAR 0 11
57197: PPUSH
57198: CALL_OW 272
57202: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
57203: LD_ADDR_VAR 0 8
57207: PUSH
57208: LD_VAR 0 2
57212: PPUSH
57213: LD_VAR 0 6
57217: PPUSH
57218: LD_VAR 0 11
57222: PPUSH
57223: CALL_OW 273
57227: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
57228: LD_VAR 0 7
57232: PPUSH
57233: LD_VAR 0 8
57237: PPUSH
57238: CALL_OW 488
57242: NOT
57243: IFFALSE 57247
// continue ;
57245: GO 57175
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
57247: LD_ADDR_VAR 0 9
57251: PUSH
57252: LD_VAR 0 12
57256: PUSH
57257: LD_INT 1
57259: ARRAY
57260: PPUSH
57261: LD_VAR 0 12
57265: PUSH
57266: LD_INT 2
57268: ARRAY
57269: PPUSH
57270: LD_VAR 0 7
57274: PPUSH
57275: LD_VAR 0 8
57279: PPUSH
57280: CALL_OW 298
57284: ST_TO_ADDR
// if tmp < distance then
57285: LD_VAR 0 9
57289: PUSH
57290: LD_VAR 0 10
57294: LESS
57295: IFFALSE 57317
// begin result := i ;
57297: LD_ADDR_VAR 0 5
57301: PUSH
57302: LD_VAR 0 6
57306: ST_TO_ADDR
// distance := tmp ;
57307: LD_ADDR_VAR 0 10
57311: PUSH
57312: LD_VAR 0 9
57316: ST_TO_ADDR
// end ; end ;
57317: GO 57175
57319: POP
57320: POP
// end ;
57321: LD_VAR 0 5
57325: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57326: LD_INT 0
57328: PPUSH
57329: PPUSH
// if not driver or not IsInUnit ( driver ) then
57330: LD_VAR 0 1
57334: NOT
57335: IFTRUE 57349
57337: PUSH
57338: LD_VAR 0 1
57342: PPUSH
57343: CALL_OW 310
57347: NOT
57348: OR
57349: IFFALSE 57353
// exit ;
57351: GO 57443
// vehicle := IsInUnit ( driver ) ;
57353: LD_ADDR_VAR 0 3
57357: PUSH
57358: LD_VAR 0 1
57362: PPUSH
57363: CALL_OW 310
57367: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57368: LD_VAR 0 1
57372: PPUSH
57373: LD_STRING \
57375: PUSH
57376: LD_INT 0
57378: PUSH
57379: LD_INT 0
57381: PUSH
57382: LD_INT 0
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: LD_INT 0
57390: PUSH
57391: LD_INT 0
57393: PUSH
57394: EMPTY
57395: LIST
57396: LIST
57397: LIST
57398: LIST
57399: LIST
57400: LIST
57401: LIST
57402: PUSH
57403: LD_STRING E
57405: PUSH
57406: LD_INT 0
57408: PUSH
57409: LD_INT 0
57411: PUSH
57412: LD_VAR 0 3
57416: PUSH
57417: LD_INT 0
57419: PUSH
57420: LD_INT 0
57422: PUSH
57423: LD_INT 0
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: LIST
57430: LIST
57431: LIST
57432: LIST
57433: LIST
57434: PUSH
57435: EMPTY
57436: LIST
57437: LIST
57438: PPUSH
57439: CALL_OW 446
// end ;
57443: LD_VAR 0 2
57447: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57448: LD_INT 0
57450: PPUSH
57451: PPUSH
// if not driver or not IsInUnit ( driver ) then
57452: LD_VAR 0 1
57456: NOT
57457: IFTRUE 57471
57459: PUSH
57460: LD_VAR 0 1
57464: PPUSH
57465: CALL_OW 310
57469: NOT
57470: OR
57471: IFFALSE 57475
// exit ;
57473: GO 57565
// vehicle := IsInUnit ( driver ) ;
57475: LD_ADDR_VAR 0 3
57479: PUSH
57480: LD_VAR 0 1
57484: PPUSH
57485: CALL_OW 310
57489: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57490: LD_VAR 0 1
57494: PPUSH
57495: LD_STRING \
57497: PUSH
57498: LD_INT 0
57500: PUSH
57501: LD_INT 0
57503: PUSH
57504: LD_INT 0
57506: PUSH
57507: LD_INT 0
57509: PUSH
57510: LD_INT 0
57512: PUSH
57513: LD_INT 0
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: LIST
57520: LIST
57521: LIST
57522: LIST
57523: LIST
57524: PUSH
57525: LD_STRING E
57527: PUSH
57528: LD_INT 0
57530: PUSH
57531: LD_INT 0
57533: PUSH
57534: LD_VAR 0 3
57538: PUSH
57539: LD_INT 0
57541: PUSH
57542: LD_INT 0
57544: PUSH
57545: LD_INT 0
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: LIST
57552: LIST
57553: LIST
57554: LIST
57555: LIST
57556: PUSH
57557: EMPTY
57558: LIST
57559: LIST
57560: PPUSH
57561: CALL_OW 447
// end ;
57565: LD_VAR 0 2
57569: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57570: LD_INT 0
57572: PPUSH
57573: PPUSH
57574: PPUSH
// tmp := [ ] ;
57575: LD_ADDR_VAR 0 5
57579: PUSH
57580: EMPTY
57581: ST_TO_ADDR
// for i in units do
57582: LD_ADDR_VAR 0 4
57586: PUSH
57587: LD_VAR 0 1
57591: PUSH
57592: FOR_IN
57593: IFFALSE 57631
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57595: LD_ADDR_VAR 0 5
57599: PUSH
57600: LD_VAR 0 5
57604: PPUSH
57605: LD_VAR 0 5
57609: PUSH
57610: LD_INT 1
57612: PLUS
57613: PPUSH
57614: LD_VAR 0 4
57618: PPUSH
57619: CALL_OW 256
57623: PPUSH
57624: CALL_OW 2
57628: ST_TO_ADDR
57629: GO 57592
57631: POP
57632: POP
// if not tmp then
57633: LD_VAR 0 5
57637: NOT
57638: IFFALSE 57642
// exit ;
57640: GO 57690
// if asc then
57642: LD_VAR 0 2
57646: IFFALSE 57670
// result := SortListByListAsc ( units , tmp ) else
57648: LD_ADDR_VAR 0 3
57652: PUSH
57653: LD_VAR 0 1
57657: PPUSH
57658: LD_VAR 0 5
57662: PPUSH
57663: CALL_OW 76
57667: ST_TO_ADDR
57668: GO 57690
// result := SortListByListDesc ( units , tmp ) ;
57670: LD_ADDR_VAR 0 3
57674: PUSH
57675: LD_VAR 0 1
57679: PPUSH
57680: LD_VAR 0 5
57684: PPUSH
57685: CALL_OW 77
57689: ST_TO_ADDR
// end ;
57690: LD_VAR 0 3
57694: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57695: LD_INT 0
57697: PPUSH
57698: PPUSH
// task := GetTaskList ( mech ) ;
57699: LD_ADDR_VAR 0 4
57703: PUSH
57704: LD_VAR 0 1
57708: PPUSH
57709: CALL_OW 437
57713: ST_TO_ADDR
// if not task then
57714: LD_VAR 0 4
57718: NOT
57719: IFFALSE 57723
// exit ;
57721: GO 57767
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57723: LD_ADDR_VAR 0 3
57727: PUSH
57728: LD_VAR 0 4
57732: PUSH
57733: LD_INT 1
57735: ARRAY
57736: PUSH
57737: LD_INT 1
57739: ARRAY
57740: PUSH
57741: LD_STRING r
57743: EQUAL
57744: IFFALSE 57766
57746: PUSH
57747: LD_VAR 0 4
57751: PUSH
57752: LD_INT 1
57754: ARRAY
57755: PUSH
57756: LD_INT 4
57758: ARRAY
57759: PUSH
57760: LD_VAR 0 2
57764: EQUAL
57765: AND
57766: ST_TO_ADDR
// end ;
57767: LD_VAR 0 3
57771: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57772: LD_INT 0
57774: PPUSH
// SetDir ( unit , d ) ;
57775: LD_VAR 0 1
57779: PPUSH
57780: LD_VAR 0 4
57784: PPUSH
57785: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
57789: LD_ADDR_VAR 0 6
57793: PUSH
57794: LD_VAR 0 1
57798: PPUSH
57799: LD_VAR 0 2
57803: PPUSH
57804: LD_VAR 0 3
57808: PPUSH
57809: LD_VAR 0 5
57813: PPUSH
57814: CALL_OW 48
57818: ST_TO_ADDR
// end ;
57819: LD_VAR 0 6
57823: RET
// export function ToNaturalNumber ( number ) ; begin
57824: LD_INT 0
57826: PPUSH
// result := number div 1 ;
57827: LD_ADDR_VAR 0 2
57831: PUSH
57832: LD_VAR 0 1
57836: PUSH
57837: LD_INT 1
57839: DIV
57840: ST_TO_ADDR
// if number < 0 then
57841: LD_VAR 0 1
57845: PUSH
57846: LD_INT 0
57848: LESS
57849: IFFALSE 57859
// result := 0 ;
57851: LD_ADDR_VAR 0 2
57855: PUSH
57856: LD_INT 0
57858: ST_TO_ADDR
// end ;
57859: LD_VAR 0 2
57863: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
57864: LD_INT 0
57866: PPUSH
57867: PPUSH
57868: PPUSH
// if not buildings then
57869: LD_VAR 0 1
57873: NOT
57874: IFFALSE 57878
// exit ;
57876: GO 57993
// tmp := [ ] ;
57878: LD_ADDR_VAR 0 5
57882: PUSH
57883: EMPTY
57884: ST_TO_ADDR
// for b in buildings do
57885: LD_ADDR_VAR 0 4
57889: PUSH
57890: LD_VAR 0 1
57894: PUSH
57895: FOR_IN
57896: IFFALSE 57934
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
57898: LD_ADDR_VAR 0 5
57902: PUSH
57903: LD_VAR 0 5
57907: PPUSH
57908: LD_VAR 0 5
57912: PUSH
57913: LD_INT 1
57915: PLUS
57916: PPUSH
57917: LD_VAR 0 4
57921: PPUSH
57922: CALL_OW 266
57926: PPUSH
57927: CALL_OW 1
57931: ST_TO_ADDR
57932: GO 57895
57934: POP
57935: POP
// if not tmp then
57936: LD_VAR 0 5
57940: NOT
57941: IFFALSE 57945
// exit ;
57943: GO 57993
// if asc then
57945: LD_VAR 0 2
57949: IFFALSE 57973
// result := SortListByListAsc ( buildings , tmp ) else
57951: LD_ADDR_VAR 0 3
57955: PUSH
57956: LD_VAR 0 1
57960: PPUSH
57961: LD_VAR 0 5
57965: PPUSH
57966: CALL_OW 76
57970: ST_TO_ADDR
57971: GO 57993
// result := SortListByListDesc ( buildings , tmp ) ;
57973: LD_ADDR_VAR 0 3
57977: PUSH
57978: LD_VAR 0 1
57982: PPUSH
57983: LD_VAR 0 5
57987: PPUSH
57988: CALL_OW 77
57992: ST_TO_ADDR
// end ;
57993: LD_VAR 0 3
57997: RET
// export function SortByClass ( units , class ) ; var un ; begin
57998: LD_INT 0
58000: PPUSH
58001: PPUSH
// if not units or not class then
58002: LD_VAR 0 1
58006: NOT
58007: IFTRUE 58016
58009: PUSH
58010: LD_VAR 0 2
58014: NOT
58015: OR
58016: IFFALSE 58020
// exit ;
58018: GO 58115
// result := [ ] ;
58020: LD_ADDR_VAR 0 3
58024: PUSH
58025: EMPTY
58026: ST_TO_ADDR
// for un in units do
58027: LD_ADDR_VAR 0 4
58031: PUSH
58032: LD_VAR 0 1
58036: PUSH
58037: FOR_IN
58038: IFFALSE 58113
// if GetClass ( un ) = class then
58040: LD_VAR 0 4
58044: PPUSH
58045: CALL_OW 257
58049: PUSH
58050: LD_VAR 0 2
58054: EQUAL
58055: IFFALSE 58082
// result := Insert ( result , 1 , un ) else
58057: LD_ADDR_VAR 0 3
58061: PUSH
58062: LD_VAR 0 3
58066: PPUSH
58067: LD_INT 1
58069: PPUSH
58070: LD_VAR 0 4
58074: PPUSH
58075: CALL_OW 2
58079: ST_TO_ADDR
58080: GO 58111
// result := Replace ( result , result + 1 , un ) ;
58082: LD_ADDR_VAR 0 3
58086: PUSH
58087: LD_VAR 0 3
58091: PPUSH
58092: LD_VAR 0 3
58096: PUSH
58097: LD_INT 1
58099: PLUS
58100: PPUSH
58101: LD_VAR 0 4
58105: PPUSH
58106: CALL_OW 1
58110: ST_TO_ADDR
58111: GO 58037
58113: POP
58114: POP
// end ;
58115: LD_VAR 0 3
58119: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58120: LD_INT 0
58122: PPUSH
58123: PPUSH
58124: PPUSH
58125: PPUSH
58126: PPUSH
58127: PPUSH
58128: PPUSH
// result := [ ] ;
58129: LD_ADDR_VAR 0 4
58133: PUSH
58134: EMPTY
58135: ST_TO_ADDR
// if x - r < 0 then
58136: LD_VAR 0 1
58140: PUSH
58141: LD_VAR 0 3
58145: MINUS
58146: PUSH
58147: LD_INT 0
58149: LESS
58150: IFFALSE 58162
// min_x := 0 else
58152: LD_ADDR_VAR 0 8
58156: PUSH
58157: LD_INT 0
58159: ST_TO_ADDR
58160: GO 58178
// min_x := x - r ;
58162: LD_ADDR_VAR 0 8
58166: PUSH
58167: LD_VAR 0 1
58171: PUSH
58172: LD_VAR 0 3
58176: MINUS
58177: ST_TO_ADDR
// if y - r < 0 then
58178: LD_VAR 0 2
58182: PUSH
58183: LD_VAR 0 3
58187: MINUS
58188: PUSH
58189: LD_INT 0
58191: LESS
58192: IFFALSE 58204
// min_y := 0 else
58194: LD_ADDR_VAR 0 7
58198: PUSH
58199: LD_INT 0
58201: ST_TO_ADDR
58202: GO 58220
// min_y := y - r ;
58204: LD_ADDR_VAR 0 7
58208: PUSH
58209: LD_VAR 0 2
58213: PUSH
58214: LD_VAR 0 3
58218: MINUS
58219: ST_TO_ADDR
// max_x := x + r ;
58220: LD_ADDR_VAR 0 9
58224: PUSH
58225: LD_VAR 0 1
58229: PUSH
58230: LD_VAR 0 3
58234: PLUS
58235: ST_TO_ADDR
// max_y := y + r ;
58236: LD_ADDR_VAR 0 10
58240: PUSH
58241: LD_VAR 0 2
58245: PUSH
58246: LD_VAR 0 3
58250: PLUS
58251: ST_TO_ADDR
// for _x = min_x to max_x do
58252: LD_ADDR_VAR 0 5
58256: PUSH
58257: DOUBLE
58258: LD_VAR 0 8
58262: DEC
58263: ST_TO_ADDR
58264: LD_VAR 0 9
58268: PUSH
58269: FOR_TO
58270: IFFALSE 58371
// for _y = min_y to max_y do
58272: LD_ADDR_VAR 0 6
58276: PUSH
58277: DOUBLE
58278: LD_VAR 0 7
58282: DEC
58283: ST_TO_ADDR
58284: LD_VAR 0 10
58288: PUSH
58289: FOR_TO
58290: IFFALSE 58367
// begin if not ValidHex ( _x , _y ) then
58292: LD_VAR 0 5
58296: PPUSH
58297: LD_VAR 0 6
58301: PPUSH
58302: CALL_OW 488
58306: NOT
58307: IFFALSE 58311
// continue ;
58309: GO 58289
// if GetResourceTypeXY ( _x , _y ) then
58311: LD_VAR 0 5
58315: PPUSH
58316: LD_VAR 0 6
58320: PPUSH
58321: CALL_OW 283
58325: IFFALSE 58365
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58327: LD_ADDR_VAR 0 4
58331: PUSH
58332: LD_VAR 0 4
58336: PPUSH
58337: LD_VAR 0 4
58341: PUSH
58342: LD_INT 1
58344: PLUS
58345: PPUSH
58346: LD_VAR 0 5
58350: PUSH
58351: LD_VAR 0 6
58355: PUSH
58356: EMPTY
58357: LIST
58358: LIST
58359: PPUSH
58360: CALL_OW 1
58364: ST_TO_ADDR
// end ;
58365: GO 58289
58367: POP
58368: POP
58369: GO 58269
58371: POP
58372: POP
// end ;
58373: LD_VAR 0 4
58377: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
58378: LD_INT 0
58380: PPUSH
58381: PPUSH
58382: PPUSH
58383: PPUSH
58384: PPUSH
58385: PPUSH
58386: PPUSH
58387: PPUSH
// if not units then
58388: LD_VAR 0 1
58392: NOT
58393: IFFALSE 58397
// exit ;
58395: GO 58929
// result := UnitFilter ( units , [ f_ok ] ) ;
58397: LD_ADDR_VAR 0 3
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: LD_INT 50
58409: PUSH
58410: EMPTY
58411: LIST
58412: PPUSH
58413: CALL_OW 72
58417: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58418: LD_ADDR_VAR 0 8
58422: PUSH
58423: LD_VAR 0 1
58427: PUSH
58428: LD_INT 1
58430: ARRAY
58431: PPUSH
58432: CALL_OW 255
58436: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
58437: LD_ADDR_VAR 0 10
58441: PUSH
58442: LD_INT 29
58444: PUSH
58445: LD_INT 91
58447: PUSH
58448: LD_INT 49
58450: PUSH
58451: EMPTY
58452: LIST
58453: LIST
58454: LIST
58455: ST_TO_ADDR
// if not result then
58456: LD_VAR 0 3
58460: NOT
58461: IFFALSE 58465
// exit ;
58463: GO 58929
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58465: LD_ADDR_VAR 0 5
58469: PUSH
58470: LD_INT 81
58472: PUSH
58473: LD_VAR 0 8
58477: PUSH
58478: EMPTY
58479: LIST
58480: LIST
58481: PPUSH
58482: CALL_OW 69
58486: ST_TO_ADDR
// for i in result do
58487: LD_ADDR_VAR 0 4
58491: PUSH
58492: LD_VAR 0 3
58496: PUSH
58497: FOR_IN
58498: IFFALSE 58927
// begin tag := GetTag ( i ) + 1 ;
58500: LD_ADDR_VAR 0 9
58504: PUSH
58505: LD_VAR 0 4
58509: PPUSH
58510: CALL_OW 110
58514: PUSH
58515: LD_INT 1
58517: PLUS
58518: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
58519: LD_ADDR_VAR 0 7
58523: PUSH
58524: LD_VAR 0 4
58528: PPUSH
58529: CALL_OW 250
58533: PPUSH
58534: LD_VAR 0 4
58538: PPUSH
58539: CALL_OW 251
58543: PPUSH
58544: LD_INT 4
58546: PPUSH
58547: CALL 58120 0 3
58551: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
58552: LD_VAR 0 4
58556: PPUSH
58557: CALL_OW 247
58561: PUSH
58562: LD_INT 2
58564: EQUAL
58565: IFFALSE 58577
58567: PUSH
58568: LD_VAR 0 7
58572: PUSH
58573: LD_INT 2
58575: GREATER
58576: AND
58577: IFFALSE 58597
58579: PUSH
58580: LD_VAR 0 4
58584: PPUSH
58585: CALL_OW 264
58589: PUSH
58590: LD_VAR 0 10
58594: IN
58595: NOT
58596: AND
58597: IFFALSE 58636
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58599: LD_VAR 0 4
58603: PPUSH
58604: LD_VAR 0 7
58608: PUSH
58609: LD_INT 1
58611: ARRAY
58612: PUSH
58613: LD_INT 1
58615: ARRAY
58616: PPUSH
58617: LD_VAR 0 7
58621: PUSH
58622: LD_INT 1
58624: ARRAY
58625: PUSH
58626: LD_INT 2
58628: ARRAY
58629: PPUSH
58630: CALL_OW 116
58634: GO 58925
// if path > tag then
58636: LD_VAR 0 2
58640: PUSH
58641: LD_VAR 0 9
58645: GREATER
58646: IFFALSE 58854
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
58648: LD_ADDR_VAR 0 6
58652: PUSH
58653: LD_VAR 0 5
58657: PPUSH
58658: LD_INT 91
58660: PUSH
58661: LD_VAR 0 4
58665: PUSH
58666: LD_INT 8
58668: PUSH
58669: EMPTY
58670: LIST
58671: LIST
58672: LIST
58673: PPUSH
58674: CALL_OW 72
58678: ST_TO_ADDR
// if nearEnemy then
58679: LD_VAR 0 6
58683: IFFALSE 58752
// begin if GetWeapon ( i ) = ru_time_lapser then
58685: LD_VAR 0 4
58689: PPUSH
58690: CALL_OW 264
58694: PUSH
58695: LD_INT 49
58697: EQUAL
58698: IFFALSE 58726
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
58700: LD_VAR 0 4
58704: PPUSH
58705: LD_VAR 0 6
58709: PPUSH
58710: LD_VAR 0 4
58714: PPUSH
58715: CALL_OW 74
58719: PPUSH
58720: CALL_OW 112
58724: GO 58750
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
58726: LD_VAR 0 4
58730: PPUSH
58731: LD_VAR 0 6
58735: PPUSH
58736: LD_VAR 0 4
58740: PPUSH
58741: CALL_OW 74
58745: PPUSH
58746: CALL 60010 0 2
// end else
58750: GO 58852
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58752: LD_VAR 0 4
58756: PPUSH
58757: LD_VAR 0 2
58761: PUSH
58762: LD_VAR 0 9
58766: ARRAY
58767: PUSH
58768: LD_INT 1
58770: ARRAY
58771: PPUSH
58772: LD_VAR 0 2
58776: PUSH
58777: LD_VAR 0 9
58781: ARRAY
58782: PUSH
58783: LD_INT 2
58785: ARRAY
58786: PPUSH
58787: CALL_OW 297
58791: PUSH
58792: LD_INT 6
58794: GREATER
58795: IFFALSE 58838
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58797: LD_VAR 0 4
58801: PPUSH
58802: LD_VAR 0 2
58806: PUSH
58807: LD_VAR 0 9
58811: ARRAY
58812: PUSH
58813: LD_INT 1
58815: ARRAY
58816: PPUSH
58817: LD_VAR 0 2
58821: PUSH
58822: LD_VAR 0 9
58826: ARRAY
58827: PUSH
58828: LD_INT 2
58830: ARRAY
58831: PPUSH
58832: CALL_OW 114
58836: GO 58852
// SetTag ( i , tag ) ;
58838: LD_VAR 0 4
58842: PPUSH
58843: LD_VAR 0 9
58847: PPUSH
58848: CALL_OW 109
// end else
58852: GO 58925
// if enemy then
58854: LD_VAR 0 5
58858: IFFALSE 58925
// begin if GetWeapon ( i ) = ru_time_lapser then
58860: LD_VAR 0 4
58864: PPUSH
58865: CALL_OW 264
58869: PUSH
58870: LD_INT 49
58872: EQUAL
58873: IFFALSE 58901
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58875: LD_VAR 0 4
58879: PPUSH
58880: LD_VAR 0 5
58884: PPUSH
58885: LD_VAR 0 4
58889: PPUSH
58890: CALL_OW 74
58894: PPUSH
58895: CALL_OW 112
58899: GO 58925
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58901: LD_VAR 0 4
58905: PPUSH
58906: LD_VAR 0 5
58910: PPUSH
58911: LD_VAR 0 4
58915: PPUSH
58916: CALL_OW 74
58920: PPUSH
58921: CALL 60010 0 2
// end ; end ;
58925: GO 58497
58927: POP
58928: POP
// end ;
58929: LD_VAR 0 3
58933: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58934: LD_INT 0
58936: PPUSH
58937: PPUSH
58938: PPUSH
// if not unit or IsInUnit ( unit ) then
58939: LD_VAR 0 1
58943: NOT
58944: IFTRUE 58957
58946: PUSH
58947: LD_VAR 0 1
58951: PPUSH
58952: CALL_OW 310
58956: OR
58957: IFFALSE 58961
// exit ;
58959: GO 59052
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58961: LD_ADDR_VAR 0 4
58965: PUSH
58966: LD_VAR 0 1
58970: PPUSH
58971: CALL_OW 250
58975: PPUSH
58976: LD_VAR 0 2
58980: PPUSH
58981: LD_INT 1
58983: PPUSH
58984: CALL_OW 272
58988: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58989: LD_ADDR_VAR 0 5
58993: PUSH
58994: LD_VAR 0 1
58998: PPUSH
58999: CALL_OW 251
59003: PPUSH
59004: LD_VAR 0 2
59008: PPUSH
59009: LD_INT 1
59011: PPUSH
59012: CALL_OW 273
59016: ST_TO_ADDR
// if ValidHex ( x , y ) then
59017: LD_VAR 0 4
59021: PPUSH
59022: LD_VAR 0 5
59026: PPUSH
59027: CALL_OW 488
59031: IFFALSE 59052
// ComTurnXY ( unit , x , y ) ;
59033: LD_VAR 0 1
59037: PPUSH
59038: LD_VAR 0 4
59042: PPUSH
59043: LD_VAR 0 5
59047: PPUSH
59048: CALL_OW 118
// end ;
59052: LD_VAR 0 3
59056: RET
// export function SeeUnits ( side , units ) ; var i ; begin
59057: LD_INT 0
59059: PPUSH
59060: PPUSH
// result := false ;
59061: LD_ADDR_VAR 0 3
59065: PUSH
59066: LD_INT 0
59068: ST_TO_ADDR
// if not units then
59069: LD_VAR 0 2
59073: NOT
59074: IFFALSE 59078
// exit ;
59076: GO 59123
// for i in units do
59078: LD_ADDR_VAR 0 4
59082: PUSH
59083: LD_VAR 0 2
59087: PUSH
59088: FOR_IN
59089: IFFALSE 59121
// if See ( side , i ) then
59091: LD_VAR 0 1
59095: PPUSH
59096: LD_VAR 0 4
59100: PPUSH
59101: CALL_OW 292
59105: IFFALSE 59119
// begin result := true ;
59107: LD_ADDR_VAR 0 3
59111: PUSH
59112: LD_INT 1
59114: ST_TO_ADDR
// exit ;
59115: POP
59116: POP
59117: GO 59123
// end ;
59119: GO 59088
59121: POP
59122: POP
// end ;
59123: LD_VAR 0 3
59127: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59128: LD_INT 0
59130: PPUSH
59131: PPUSH
59132: PPUSH
59133: PPUSH
// if not unit or not points then
59134: LD_VAR 0 1
59138: NOT
59139: IFTRUE 59148
59141: PUSH
59142: LD_VAR 0 2
59146: NOT
59147: OR
59148: IFFALSE 59152
// exit ;
59150: GO 59242
// dist := 99999 ;
59152: LD_ADDR_VAR 0 5
59156: PUSH
59157: LD_INT 99999
59159: ST_TO_ADDR
// for i in points do
59160: LD_ADDR_VAR 0 4
59164: PUSH
59165: LD_VAR 0 2
59169: PUSH
59170: FOR_IN
59171: IFFALSE 59240
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59173: LD_ADDR_VAR 0 6
59177: PUSH
59178: LD_VAR 0 1
59182: PPUSH
59183: LD_VAR 0 4
59187: PUSH
59188: LD_INT 1
59190: ARRAY
59191: PPUSH
59192: LD_VAR 0 4
59196: PUSH
59197: LD_INT 2
59199: ARRAY
59200: PPUSH
59201: CALL_OW 297
59205: ST_TO_ADDR
// if tmpDist < dist then
59206: LD_VAR 0 6
59210: PUSH
59211: LD_VAR 0 5
59215: LESS
59216: IFFALSE 59238
// begin result := i ;
59218: LD_ADDR_VAR 0 3
59222: PUSH
59223: LD_VAR 0 4
59227: ST_TO_ADDR
// dist := tmpDist ;
59228: LD_ADDR_VAR 0 5
59232: PUSH
59233: LD_VAR 0 6
59237: ST_TO_ADDR
// end ; end ;
59238: GO 59170
59240: POP
59241: POP
// end ;
59242: LD_VAR 0 3
59246: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
59247: LD_INT 0
59249: PPUSH
// uc_side := side ;
59250: LD_ADDR_OWVAR 20
59254: PUSH
59255: LD_VAR 0 1
59259: ST_TO_ADDR
// uc_nation := 3 ;
59260: LD_ADDR_OWVAR 21
59264: PUSH
59265: LD_INT 3
59267: ST_TO_ADDR
// vc_chassis := 25 ;
59268: LD_ADDR_OWVAR 37
59272: PUSH
59273: LD_INT 25
59275: ST_TO_ADDR
// vc_engine := engine_siberite ;
59276: LD_ADDR_OWVAR 39
59280: PUSH
59281: LD_INT 3
59283: ST_TO_ADDR
// vc_control := control_computer ;
59284: LD_ADDR_OWVAR 38
59288: PUSH
59289: LD_INT 3
59291: ST_TO_ADDR
// vc_weapon := 59 ;
59292: LD_ADDR_OWVAR 40
59296: PUSH
59297: LD_INT 59
59299: ST_TO_ADDR
// result := CreateVehicle ;
59300: LD_ADDR_VAR 0 5
59304: PUSH
59305: CALL_OW 45
59309: ST_TO_ADDR
// SetDir ( result , d ) ;
59310: LD_VAR 0 5
59314: PPUSH
59315: LD_VAR 0 4
59319: PPUSH
59320: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
59324: LD_VAR 0 5
59328: PPUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: LD_VAR 0 3
59338: PPUSH
59339: LD_INT 0
59341: PPUSH
59342: CALL_OW 48
// end ;
59346: LD_VAR 0 5
59350: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
59351: LD_INT 0
59353: PPUSH
59354: PPUSH
59355: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59356: LD_ADDR_VAR 0 2
59360: PUSH
59361: LD_INT 0
59363: PUSH
59364: LD_INT 0
59366: PUSH
59367: LD_INT 0
59369: PUSH
59370: LD_INT 0
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: LIST
59377: LIST
59378: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
59379: LD_VAR 0 1
59383: NOT
59384: IFTRUE 59417
59386: PUSH
59387: LD_VAR 0 1
59391: PPUSH
59392: CALL_OW 264
59396: PUSH
59397: LD_INT 12
59399: PUSH
59400: LD_INT 51
59402: PUSH
59403: LD_INT 32
59405: PUSH
59406: LD_INT 89
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: LIST
59413: LIST
59414: IN
59415: NOT
59416: OR
59417: IFFALSE 59421
// exit ;
59419: GO 59519
// for i := 1 to 3 do
59421: LD_ADDR_VAR 0 3
59425: PUSH
59426: DOUBLE
59427: LD_INT 1
59429: DEC
59430: ST_TO_ADDR
59431: LD_INT 3
59433: PUSH
59434: FOR_TO
59435: IFFALSE 59517
// begin tmp := GetCargo ( cargo , i ) ;
59437: LD_ADDR_VAR 0 4
59441: PUSH
59442: LD_VAR 0 1
59446: PPUSH
59447: LD_VAR 0 3
59451: PPUSH
59452: CALL_OW 289
59456: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
59457: LD_ADDR_VAR 0 2
59461: PUSH
59462: LD_VAR 0 2
59466: PPUSH
59467: LD_VAR 0 3
59471: PPUSH
59472: LD_VAR 0 4
59476: PPUSH
59477: CALL_OW 1
59481: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
59482: LD_ADDR_VAR 0 2
59486: PUSH
59487: LD_VAR 0 2
59491: PPUSH
59492: LD_INT 4
59494: PPUSH
59495: LD_VAR 0 2
59499: PUSH
59500: LD_INT 4
59502: ARRAY
59503: PUSH
59504: LD_VAR 0 4
59508: PLUS
59509: PPUSH
59510: CALL_OW 1
59514: ST_TO_ADDR
// end ;
59515: GO 59434
59517: POP
59518: POP
// end ;
59519: LD_VAR 0 2
59523: RET
// export function Length ( array ) ; begin
59524: LD_INT 0
59526: PPUSH
// result := array + 0 ;
59527: LD_ADDR_VAR 0 2
59531: PUSH
59532: LD_VAR 0 1
59536: PUSH
59537: LD_INT 0
59539: PLUS
59540: ST_TO_ADDR
// end ;
59541: LD_VAR 0 2
59545: RET
// export function PrepareArray ( array ) ; begin
59546: LD_INT 0
59548: PPUSH
// result := array diff 0 ;
59549: LD_ADDR_VAR 0 2
59553: PUSH
59554: LD_VAR 0 1
59558: PUSH
59559: LD_INT 0
59561: DIFF
59562: ST_TO_ADDR
// if not result [ 1 ] then
59563: LD_VAR 0 2
59567: PUSH
59568: LD_INT 1
59570: ARRAY
59571: NOT
59572: IFFALSE 59592
// result := Delete ( result , 1 ) ;
59574: LD_ADDR_VAR 0 2
59578: PUSH
59579: LD_VAR 0 2
59583: PPUSH
59584: LD_INT 1
59586: PPUSH
59587: CALL_OW 3
59591: ST_TO_ADDR
// end ;
59592: LD_VAR 0 2
59596: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
59597: LD_INT 0
59599: PPUSH
59600: PPUSH
59601: PPUSH
59602: PPUSH
// sibRocketRange := 25 ;
59603: LD_ADDR_VAR 0 6
59607: PUSH
59608: LD_INT 25
59610: ST_TO_ADDR
// result := false ;
59611: LD_ADDR_VAR 0 4
59615: PUSH
59616: LD_INT 0
59618: ST_TO_ADDR
// for i := 0 to 5 do
59619: LD_ADDR_VAR 0 5
59623: PUSH
59624: DOUBLE
59625: LD_INT 0
59627: DEC
59628: ST_TO_ADDR
59629: LD_INT 5
59631: PUSH
59632: FOR_TO
59633: IFFALSE 59700
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
59635: LD_VAR 0 1
59639: PPUSH
59640: LD_VAR 0 5
59644: PPUSH
59645: LD_VAR 0 6
59649: PPUSH
59650: CALL_OW 272
59654: PPUSH
59655: LD_VAR 0 2
59659: PPUSH
59660: LD_VAR 0 5
59664: PPUSH
59665: LD_VAR 0 6
59669: PPUSH
59670: CALL_OW 273
59674: PPUSH
59675: LD_VAR 0 3
59679: PPUSH
59680: CALL_OW 309
59684: IFFALSE 59698
// begin result := true ;
59686: LD_ADDR_VAR 0 4
59690: PUSH
59691: LD_INT 1
59693: ST_TO_ADDR
// exit ;
59694: POP
59695: POP
59696: GO 59702
// end ;
59698: GO 59632
59700: POP
59701: POP
// end ;
59702: LD_VAR 0 4
59706: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
59707: LD_INT 0
59709: PPUSH
59710: PPUSH
59711: PPUSH
// if btype = b_depot then
59712: LD_VAR 0 2
59716: PUSH
59717: LD_INT 0
59719: EQUAL
59720: IFFALSE 59732
// begin result := true ;
59722: LD_ADDR_VAR 0 3
59726: PUSH
59727: LD_INT 1
59729: ST_TO_ADDR
// exit ;
59730: GO 59852
// end ; pom := GetBase ( depot ) ;
59732: LD_ADDR_VAR 0 4
59736: PUSH
59737: LD_VAR 0 1
59741: PPUSH
59742: CALL_OW 274
59746: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59747: LD_ADDR_VAR 0 5
59751: PUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: LD_VAR 0 1
59761: PPUSH
59762: CALL_OW 248
59766: PPUSH
59767: CALL_OW 450
59771: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
59772: LD_ADDR_VAR 0 3
59776: PUSH
59777: LD_VAR 0 4
59781: PPUSH
59782: LD_INT 1
59784: PPUSH
59785: CALL_OW 275
59789: PUSH
59790: LD_VAR 0 5
59794: PUSH
59795: LD_INT 1
59797: ARRAY
59798: GREATEREQUAL
59799: IFFALSE 59825
59801: PUSH
59802: LD_VAR 0 4
59806: PPUSH
59807: LD_INT 2
59809: PPUSH
59810: CALL_OW 275
59814: PUSH
59815: LD_VAR 0 5
59819: PUSH
59820: LD_INT 2
59822: ARRAY
59823: GREATEREQUAL
59824: AND
59825: IFFALSE 59851
59827: PUSH
59828: LD_VAR 0 4
59832: PPUSH
59833: LD_INT 3
59835: PPUSH
59836: CALL_OW 275
59840: PUSH
59841: LD_VAR 0 5
59845: PUSH
59846: LD_INT 3
59848: ARRAY
59849: GREATEREQUAL
59850: AND
59851: ST_TO_ADDR
// end ;
59852: LD_VAR 0 3
59856: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59857: LD_INT 0
59859: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59860: LD_VAR 0 1
59864: PPUSH
59865: LD_VAR 0 2
59869: PPUSH
59870: LD_INT 0
59872: PPUSH
59873: LD_INT 0
59875: PPUSH
59876: LD_INT 1
59878: PPUSH
59879: LD_INT 0
59881: PPUSH
59882: CALL_OW 587
// end ;
59886: LD_VAR 0 3
59890: RET
// export function CenterOnNow ( unit ) ; begin
59891: LD_INT 0
59893: PPUSH
// result := IsInUnit ( unit ) ;
59894: LD_ADDR_VAR 0 2
59898: PUSH
59899: LD_VAR 0 1
59903: PPUSH
59904: CALL_OW 310
59908: ST_TO_ADDR
// if not result then
59909: LD_VAR 0 2
59913: NOT
59914: IFFALSE 59926
// result := unit ;
59916: LD_ADDR_VAR 0 2
59920: PUSH
59921: LD_VAR 0 1
59925: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59926: LD_VAR 0 1
59930: PPUSH
59931: CALL_OW 87
// end ;
59935: LD_VAR 0 2
59939: RET
// export function ComMoveHex ( unit , hex ) ; begin
59940: LD_INT 0
59942: PPUSH
// if not hex then
59943: LD_VAR 0 2
59947: NOT
59948: IFFALSE 59952
// exit ;
59950: GO 60005
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59952: LD_VAR 0 2
59956: PUSH
59957: LD_INT 1
59959: ARRAY
59960: PPUSH
59961: LD_VAR 0 2
59965: PUSH
59966: LD_INT 2
59968: ARRAY
59969: PPUSH
59970: CALL_OW 428
59974: IFFALSE 59978
// exit ;
59976: GO 60005
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59978: LD_VAR 0 1
59982: PPUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_INT 1
59990: ARRAY
59991: PPUSH
59992: LD_VAR 0 2
59996: PUSH
59997: LD_INT 2
59999: ARRAY
60000: PPUSH
60001: CALL_OW 111
// end ;
60005: LD_VAR 0 3
60009: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
60010: LD_INT 0
60012: PPUSH
60013: PPUSH
60014: PPUSH
// if not unit or not enemy then
60015: LD_VAR 0 1
60019: NOT
60020: IFTRUE 60029
60022: PUSH
60023: LD_VAR 0 2
60027: NOT
60028: OR
60029: IFFALSE 60033
// exit ;
60031: GO 60159
// x := GetX ( enemy ) ;
60033: LD_ADDR_VAR 0 4
60037: PUSH
60038: LD_VAR 0 2
60042: PPUSH
60043: CALL_OW 250
60047: ST_TO_ADDR
// y := GetY ( enemy ) ;
60048: LD_ADDR_VAR 0 5
60052: PUSH
60053: LD_VAR 0 2
60057: PPUSH
60058: CALL_OW 251
60062: ST_TO_ADDR
// if ValidHex ( x , y ) then
60063: LD_VAR 0 4
60067: PPUSH
60068: LD_VAR 0 5
60072: PPUSH
60073: CALL_OW 488
60077: IFFALSE 60159
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
60079: LD_VAR 0 2
60083: PPUSH
60084: CALL_OW 247
60088: PUSH
60089: LD_INT 3
60091: PUSH
60092: LD_INT 2
60094: PUSH
60095: EMPTY
60096: LIST
60097: LIST
60098: IN
60099: IFTRUE 60122
60101: PUSH
60102: LD_VAR 0 1
60106: PPUSH
60107: CALL_OW 255
60111: PPUSH
60112: LD_VAR 0 2
60116: PPUSH
60117: CALL_OW 292
60121: OR
60122: IFFALSE 60140
// ComAttackUnit ( unit , enemy ) else
60124: LD_VAR 0 1
60128: PPUSH
60129: LD_VAR 0 2
60133: PPUSH
60134: CALL_OW 115
60138: GO 60159
// ComAgressiveMove ( unit , x , y ) ;
60140: LD_VAR 0 1
60144: PPUSH
60145: LD_VAR 0 4
60149: PPUSH
60150: LD_VAR 0 5
60154: PPUSH
60155: CALL_OW 114
// end ;
60159: LD_VAR 0 3
60163: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
60164: LD_INT 0
60166: PPUSH
60167: PPUSH
60168: PPUSH
// list := AreaToList ( area , 0 ) ;
60169: LD_ADDR_VAR 0 5
60173: PUSH
60174: LD_VAR 0 1
60178: PPUSH
60179: LD_INT 0
60181: PPUSH
60182: CALL_OW 517
60186: ST_TO_ADDR
// if not list then
60187: LD_VAR 0 5
60191: NOT
60192: IFFALSE 60196
// exit ;
60194: GO 60326
// if all then
60196: LD_VAR 0 2
60200: IFFALSE 60288
// begin for i := 1 to list [ 1 ] do
60202: LD_ADDR_VAR 0 4
60206: PUSH
60207: DOUBLE
60208: LD_INT 1
60210: DEC
60211: ST_TO_ADDR
60212: LD_VAR 0 5
60216: PUSH
60217: LD_INT 1
60219: ARRAY
60220: PUSH
60221: FOR_TO
60222: IFFALSE 60284
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
60224: LD_ADDR_VAR 0 3
60228: PUSH
60229: LD_VAR 0 3
60233: PPUSH
60234: LD_VAR 0 3
60238: PUSH
60239: LD_INT 1
60241: PLUS
60242: PPUSH
60243: LD_VAR 0 5
60247: PUSH
60248: LD_INT 1
60250: ARRAY
60251: PUSH
60252: LD_VAR 0 4
60256: ARRAY
60257: PUSH
60258: LD_VAR 0 5
60262: PUSH
60263: LD_INT 2
60265: ARRAY
60266: PUSH
60267: LD_VAR 0 4
60271: ARRAY
60272: PUSH
60273: EMPTY
60274: LIST
60275: LIST
60276: PPUSH
60277: CALL_OW 1
60281: ST_TO_ADDR
60282: GO 60221
60284: POP
60285: POP
// exit ;
60286: GO 60326
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
60288: LD_ADDR_VAR 0 3
60292: PUSH
60293: LD_VAR 0 5
60297: PUSH
60298: LD_INT 1
60300: ARRAY
60301: PUSH
60302: LD_INT 1
60304: ARRAY
60305: PUSH
60306: LD_VAR 0 5
60310: PUSH
60311: LD_INT 2
60313: ARRAY
60314: PUSH
60315: LD_INT 1
60317: ARRAY
60318: PUSH
60319: EMPTY
60320: LIST
60321: LIST
60322: PUSH
60323: EMPTY
60324: LIST
60325: ST_TO_ADDR
// end ;
60326: LD_VAR 0 3
60330: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
60331: LD_INT 0
60333: PPUSH
60334: PPUSH
// list := AreaToList ( area , 0 ) ;
60335: LD_ADDR_VAR 0 4
60339: PUSH
60340: LD_VAR 0 1
60344: PPUSH
60345: LD_INT 0
60347: PPUSH
60348: CALL_OW 517
60352: ST_TO_ADDR
// if not list then
60353: LD_VAR 0 4
60357: NOT
60358: IFFALSE 60362
// exit ;
60360: GO 60403
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
60362: LD_ADDR_VAR 0 3
60366: PUSH
60367: LD_VAR 0 4
60371: PUSH
60372: LD_INT 1
60374: ARRAY
60375: PUSH
60376: LD_INT 1
60378: ARRAY
60379: PUSH
60380: LD_VAR 0 4
60384: PUSH
60385: LD_INT 2
60387: ARRAY
60388: PUSH
60389: LD_INT 1
60391: ARRAY
60392: PUSH
60393: LD_VAR 0 2
60397: PUSH
60398: EMPTY
60399: LIST
60400: LIST
60401: LIST
60402: ST_TO_ADDR
// end ;
60403: LD_VAR 0 3
60407: RET
// export function First ( array ) ; begin
60408: LD_INT 0
60410: PPUSH
// if not array then
60411: LD_VAR 0 1
60415: NOT
60416: IFFALSE 60420
// exit ;
60418: GO 60434
// result := array [ 1 ] ;
60420: LD_ADDR_VAR 0 2
60424: PUSH
60425: LD_VAR 0 1
60429: PUSH
60430: LD_INT 1
60432: ARRAY
60433: ST_TO_ADDR
// end ;
60434: LD_VAR 0 2
60438: RET
// export function Last ( array ) ; begin
60439: LD_INT 0
60441: PPUSH
// if not array then
60442: LD_VAR 0 1
60446: NOT
60447: IFFALSE 60451
// exit ;
60449: GO 60467
// result := array [ array ] ;
60451: LD_ADDR_VAR 0 2
60455: PUSH
60456: LD_VAR 0 1
60460: PUSH
60461: LD_VAR 0 1
60465: ARRAY
60466: ST_TO_ADDR
// end ;
60467: LD_VAR 0 2
60471: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
60472: LD_INT 0
60474: PPUSH
60475: PPUSH
// result := [ ] ;
60476: LD_ADDR_VAR 0 5
60480: PUSH
60481: EMPTY
60482: ST_TO_ADDR
// if not array then
60483: LD_VAR 0 1
60487: NOT
60488: IFFALSE 60492
// exit ;
60490: GO 60604
// for i := 1 to array do
60492: LD_ADDR_VAR 0 6
60496: PUSH
60497: DOUBLE
60498: LD_INT 1
60500: DEC
60501: ST_TO_ADDR
60502: LD_VAR 0 1
60506: PUSH
60507: FOR_TO
60508: IFFALSE 60602
// if array [ i ] [ index ] = value then
60510: LD_VAR 0 1
60514: PUSH
60515: LD_VAR 0 6
60519: ARRAY
60520: PUSH
60521: LD_VAR 0 2
60525: ARRAY
60526: PUSH
60527: LD_VAR 0 3
60531: EQUAL
60532: IFFALSE 60600
// begin if indexColumn then
60534: LD_VAR 0 4
60538: IFFALSE 60574
// result := Join ( result , array [ i ] [ indexColumn ] ) else
60540: LD_ADDR_VAR 0 5
60544: PUSH
60545: LD_VAR 0 5
60549: PPUSH
60550: LD_VAR 0 1
60554: PUSH
60555: LD_VAR 0 6
60559: ARRAY
60560: PUSH
60561: LD_VAR 0 4
60565: ARRAY
60566: PPUSH
60567: CALL 55612 0 2
60571: ST_TO_ADDR
60572: GO 60600
// result := Join ( result , array [ i ] ) ;
60574: LD_ADDR_VAR 0 5
60578: PUSH
60579: LD_VAR 0 5
60583: PPUSH
60584: LD_VAR 0 1
60588: PUSH
60589: LD_VAR 0 6
60593: ARRAY
60594: PPUSH
60595: CALL 55612 0 2
60599: ST_TO_ADDR
// end ;
60600: GO 60507
60602: POP
60603: POP
// end ;
60604: LD_VAR 0 5
60608: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
60609: LD_INT 0
60611: PPUSH
// if not vehicles or not parkingPoint then
60612: LD_VAR 0 1
60616: NOT
60617: IFTRUE 60626
60619: PUSH
60620: LD_VAR 0 2
60624: NOT
60625: OR
60626: IFFALSE 60630
// exit ;
60628: GO 60728
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
60630: LD_ADDR_VAR 0 1
60634: PUSH
60635: LD_VAR 0 1
60639: PPUSH
60640: LD_INT 50
60642: PUSH
60643: EMPTY
60644: LIST
60645: PUSH
60646: LD_INT 3
60648: PUSH
60649: LD_INT 92
60651: PUSH
60652: LD_VAR 0 2
60656: PUSH
60657: LD_INT 1
60659: ARRAY
60660: PUSH
60661: LD_VAR 0 2
60665: PUSH
60666: LD_INT 2
60668: ARRAY
60669: PUSH
60670: LD_INT 8
60672: PUSH
60673: EMPTY
60674: LIST
60675: LIST
60676: LIST
60677: LIST
60678: PUSH
60679: EMPTY
60680: LIST
60681: LIST
60682: PUSH
60683: EMPTY
60684: LIST
60685: LIST
60686: PPUSH
60687: CALL_OW 72
60691: ST_TO_ADDR
// if not vehicles then
60692: LD_VAR 0 1
60696: NOT
60697: IFFALSE 60701
// exit ;
60699: GO 60728
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
60701: LD_VAR 0 1
60705: PPUSH
60706: LD_VAR 0 2
60710: PUSH
60711: LD_INT 1
60713: ARRAY
60714: PPUSH
60715: LD_VAR 0 2
60719: PUSH
60720: LD_INT 2
60722: ARRAY
60723: PPUSH
60724: CALL_OW 111
// end ;
60728: LD_VAR 0 3
60732: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
60733: LD_INT 0
60735: PPUSH
60736: PPUSH
60737: PPUSH
// if not side or not area then
60738: LD_VAR 0 1
60742: NOT
60743: IFTRUE 60752
60745: PUSH
60746: LD_VAR 0 2
60750: NOT
60751: OR
60752: IFFALSE 60756
// exit ;
60754: GO 60875
// tmp := AreaToList ( area , 0 ) ;
60756: LD_ADDR_VAR 0 5
60760: PUSH
60761: LD_VAR 0 2
60765: PPUSH
60766: LD_INT 0
60768: PPUSH
60769: CALL_OW 517
60773: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
60774: LD_ADDR_VAR 0 4
60778: PUSH
60779: DOUBLE
60780: LD_INT 1
60782: DEC
60783: ST_TO_ADDR
60784: LD_VAR 0 5
60788: PUSH
60789: LD_INT 1
60791: ARRAY
60792: PUSH
60793: FOR_TO
60794: IFFALSE 60873
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
60796: LD_VAR 0 5
60800: PUSH
60801: LD_INT 1
60803: ARRAY
60804: PUSH
60805: LD_VAR 0 4
60809: ARRAY
60810: PPUSH
60811: LD_VAR 0 5
60815: PUSH
60816: LD_INT 2
60818: ARRAY
60819: PUSH
60820: LD_VAR 0 4
60824: ARRAY
60825: PPUSH
60826: CALL_OW 351
60830: IFFALSE 60871
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60832: LD_VAR 0 5
60836: PUSH
60837: LD_INT 1
60839: ARRAY
60840: PUSH
60841: LD_VAR 0 4
60845: ARRAY
60846: PPUSH
60847: LD_VAR 0 5
60851: PUSH
60852: LD_INT 2
60854: ARRAY
60855: PUSH
60856: LD_VAR 0 4
60860: ARRAY
60861: PPUSH
60862: LD_VAR 0 1
60866: PPUSH
60867: CALL_OW 244
// end ;
60871: GO 60793
60873: POP
60874: POP
// end ;
60875: LD_VAR 0 3
60879: RET
// export function UniqueArray ( array ) ; var i ; begin
60880: LD_INT 0
60882: PPUSH
60883: PPUSH
// result := [ ] ;
60884: LD_ADDR_VAR 0 2
60888: PUSH
60889: EMPTY
60890: ST_TO_ADDR
// if not array then
60891: LD_VAR 0 1
60895: NOT
60896: IFFALSE 60900
// exit ;
60898: GO 60961
// for i := 1 to array do
60900: LD_ADDR_VAR 0 3
60904: PUSH
60905: DOUBLE
60906: LD_INT 1
60908: DEC
60909: ST_TO_ADDR
60910: LD_VAR 0 1
60914: PUSH
60915: FOR_TO
60916: IFFALSE 60959
// if not array [ i ] in result then
60918: LD_VAR 0 1
60922: PUSH
60923: LD_VAR 0 3
60927: ARRAY
60928: PUSH
60929: LD_VAR 0 2
60933: IN
60934: NOT
60935: IFFALSE 60957
// result := Join ( result , i ) ;
60937: LD_ADDR_VAR 0 2
60941: PUSH
60942: LD_VAR 0 2
60946: PPUSH
60947: LD_VAR 0 3
60951: PPUSH
60952: CALL 55612 0 2
60956: ST_TO_ADDR
60957: GO 60915
60959: POP
60960: POP
// end ; end_of_file
60961: LD_VAR 0 2
60965: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60966: LD_INT 0
60968: PPUSH
60969: PPUSH
// skirmish := false ;
60970: LD_ADDR_EXP 61
60974: PUSH
60975: LD_INT 0
60977: ST_TO_ADDR
// debug_mc := false ;
60978: LD_ADDR_EXP 62
60982: PUSH
60983: LD_INT 0
60985: ST_TO_ADDR
// mc_bases := [ ] ;
60986: LD_ADDR_EXP 63
60990: PUSH
60991: EMPTY
60992: ST_TO_ADDR
// mc_sides := [ ] ;
60993: LD_ADDR_EXP 89
60997: PUSH
60998: EMPTY
60999: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
61000: LD_ADDR_EXP 64
61004: PUSH
61005: EMPTY
61006: ST_TO_ADDR
// mc_building_repairs := [ ] ;
61007: LD_ADDR_EXP 65
61011: PUSH
61012: EMPTY
61013: ST_TO_ADDR
// mc_need_heal := [ ] ;
61014: LD_ADDR_EXP 66
61018: PUSH
61019: EMPTY
61020: ST_TO_ADDR
// mc_healers := [ ] ;
61021: LD_ADDR_EXP 67
61025: PUSH
61026: EMPTY
61027: ST_TO_ADDR
// mc_build_list := [ ] ;
61028: LD_ADDR_EXP 68
61032: PUSH
61033: EMPTY
61034: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
61035: LD_ADDR_EXP 95
61039: PUSH
61040: EMPTY
61041: ST_TO_ADDR
// mc_builders := [ ] ;
61042: LD_ADDR_EXP 69
61046: PUSH
61047: EMPTY
61048: ST_TO_ADDR
// mc_construct_list := [ ] ;
61049: LD_ADDR_EXP 70
61053: PUSH
61054: EMPTY
61055: ST_TO_ADDR
// mc_turret_list := [ ] ;
61056: LD_ADDR_EXP 71
61060: PUSH
61061: EMPTY
61062: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61063: LD_ADDR_EXP 72
61067: PUSH
61068: EMPTY
61069: ST_TO_ADDR
// mc_miners := [ ] ;
61070: LD_ADDR_EXP 77
61074: PUSH
61075: EMPTY
61076: ST_TO_ADDR
// mc_mines := [ ] ;
61077: LD_ADDR_EXP 76
61081: PUSH
61082: EMPTY
61083: ST_TO_ADDR
// mc_minefields := [ ] ;
61084: LD_ADDR_EXP 78
61088: PUSH
61089: EMPTY
61090: ST_TO_ADDR
// mc_crates := [ ] ;
61091: LD_ADDR_EXP 79
61095: PUSH
61096: EMPTY
61097: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61098: LD_ADDR_EXP 80
61102: PUSH
61103: EMPTY
61104: ST_TO_ADDR
// mc_crates_area := [ ] ;
61105: LD_ADDR_EXP 81
61109: PUSH
61110: EMPTY
61111: ST_TO_ADDR
// mc_vehicles := [ ] ;
61112: LD_ADDR_EXP 82
61116: PUSH
61117: EMPTY
61118: ST_TO_ADDR
// mc_attack := [ ] ;
61119: LD_ADDR_EXP 83
61123: PUSH
61124: EMPTY
61125: ST_TO_ADDR
// mc_produce := [ ] ;
61126: LD_ADDR_EXP 84
61130: PUSH
61131: EMPTY
61132: ST_TO_ADDR
// mc_defender := [ ] ;
61133: LD_ADDR_EXP 85
61137: PUSH
61138: EMPTY
61139: ST_TO_ADDR
// mc_parking := [ ] ;
61140: LD_ADDR_EXP 87
61144: PUSH
61145: EMPTY
61146: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61147: LD_ADDR_EXP 73
61151: PUSH
61152: EMPTY
61153: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61154: LD_ADDR_EXP 75
61158: PUSH
61159: EMPTY
61160: ST_TO_ADDR
// mc_scan := [ ] ;
61161: LD_ADDR_EXP 86
61165: PUSH
61166: EMPTY
61167: ST_TO_ADDR
// mc_scan_area := [ ] ;
61168: LD_ADDR_EXP 88
61172: PUSH
61173: EMPTY
61174: ST_TO_ADDR
// mc_tech := [ ] ;
61175: LD_ADDR_EXP 90
61179: PUSH
61180: EMPTY
61181: ST_TO_ADDR
// mc_class := [ ] ;
61182: LD_ADDR_EXP 104
61186: PUSH
61187: EMPTY
61188: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61189: LD_ADDR_EXP 105
61193: PUSH
61194: EMPTY
61195: ST_TO_ADDR
// mc_is_defending := [ ] ;
61196: LD_ADDR_EXP 106
61200: PUSH
61201: EMPTY
61202: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61203: LD_ADDR_EXP 97
61207: PUSH
61208: EMPTY
61209: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61210: LD_ADDR_EXP 107
61214: PUSH
61215: LD_INT 0
61217: ST_TO_ADDR
// end ;
61218: LD_VAR 0 1
61222: RET
// export function MC_Kill ( base ) ; begin
61223: LD_INT 0
61225: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61226: LD_ADDR_EXP 63
61230: PUSH
61231: LD_EXP 63
61235: PPUSH
61236: LD_VAR 0 1
61240: PPUSH
61241: EMPTY
61242: PPUSH
61243: CALL_OW 1
61247: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61248: LD_ADDR_EXP 64
61252: PUSH
61253: LD_EXP 64
61257: PPUSH
61258: LD_VAR 0 1
61262: PPUSH
61263: EMPTY
61264: PPUSH
61265: CALL_OW 1
61269: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61270: LD_ADDR_EXP 65
61274: PUSH
61275: LD_EXP 65
61279: PPUSH
61280: LD_VAR 0 1
61284: PPUSH
61285: EMPTY
61286: PPUSH
61287: CALL_OW 1
61291: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61292: LD_ADDR_EXP 66
61296: PUSH
61297: LD_EXP 66
61301: PPUSH
61302: LD_VAR 0 1
61306: PPUSH
61307: EMPTY
61308: PPUSH
61309: CALL_OW 1
61313: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61314: LD_ADDR_EXP 67
61318: PUSH
61319: LD_EXP 67
61323: PPUSH
61324: LD_VAR 0 1
61328: PPUSH
61329: EMPTY
61330: PPUSH
61331: CALL_OW 1
61335: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61336: LD_ADDR_EXP 68
61340: PUSH
61341: LD_EXP 68
61345: PPUSH
61346: LD_VAR 0 1
61350: PPUSH
61351: EMPTY
61352: PPUSH
61353: CALL_OW 1
61357: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61358: LD_ADDR_EXP 69
61362: PUSH
61363: LD_EXP 69
61367: PPUSH
61368: LD_VAR 0 1
61372: PPUSH
61373: EMPTY
61374: PPUSH
61375: CALL_OW 1
61379: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61380: LD_ADDR_EXP 70
61384: PUSH
61385: LD_EXP 70
61389: PPUSH
61390: LD_VAR 0 1
61394: PPUSH
61395: EMPTY
61396: PPUSH
61397: CALL_OW 1
61401: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61402: LD_ADDR_EXP 71
61406: PUSH
61407: LD_EXP 71
61411: PPUSH
61412: LD_VAR 0 1
61416: PPUSH
61417: EMPTY
61418: PPUSH
61419: CALL_OW 1
61423: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61424: LD_ADDR_EXP 72
61428: PUSH
61429: LD_EXP 72
61433: PPUSH
61434: LD_VAR 0 1
61438: PPUSH
61439: EMPTY
61440: PPUSH
61441: CALL_OW 1
61445: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61446: LD_ADDR_EXP 73
61450: PUSH
61451: LD_EXP 73
61455: PPUSH
61456: LD_VAR 0 1
61460: PPUSH
61461: EMPTY
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61468: LD_ADDR_EXP 74
61472: PUSH
61473: LD_EXP 74
61477: PPUSH
61478: LD_VAR 0 1
61482: PPUSH
61483: LD_INT 0
61485: PPUSH
61486: CALL_OW 1
61490: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61491: LD_ADDR_EXP 75
61495: PUSH
61496: LD_EXP 75
61500: PPUSH
61501: LD_VAR 0 1
61505: PPUSH
61506: EMPTY
61507: PPUSH
61508: CALL_OW 1
61512: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61513: LD_ADDR_EXP 76
61517: PUSH
61518: LD_EXP 76
61522: PPUSH
61523: LD_VAR 0 1
61527: PPUSH
61528: EMPTY
61529: PPUSH
61530: CALL_OW 1
61534: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61535: LD_ADDR_EXP 77
61539: PUSH
61540: LD_EXP 77
61544: PPUSH
61545: LD_VAR 0 1
61549: PPUSH
61550: EMPTY
61551: PPUSH
61552: CALL_OW 1
61556: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61557: LD_ADDR_EXP 78
61561: PUSH
61562: LD_EXP 78
61566: PPUSH
61567: LD_VAR 0 1
61571: PPUSH
61572: EMPTY
61573: PPUSH
61574: CALL_OW 1
61578: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61579: LD_ADDR_EXP 79
61583: PUSH
61584: LD_EXP 79
61588: PPUSH
61589: LD_VAR 0 1
61593: PPUSH
61594: EMPTY
61595: PPUSH
61596: CALL_OW 1
61600: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61601: LD_ADDR_EXP 80
61605: PUSH
61606: LD_EXP 80
61610: PPUSH
61611: LD_VAR 0 1
61615: PPUSH
61616: EMPTY
61617: PPUSH
61618: CALL_OW 1
61622: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61623: LD_ADDR_EXP 81
61627: PUSH
61628: LD_EXP 81
61632: PPUSH
61633: LD_VAR 0 1
61637: PPUSH
61638: EMPTY
61639: PPUSH
61640: CALL_OW 1
61644: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61645: LD_ADDR_EXP 82
61649: PUSH
61650: LD_EXP 82
61654: PPUSH
61655: LD_VAR 0 1
61659: PPUSH
61660: EMPTY
61661: PPUSH
61662: CALL_OW 1
61666: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61667: LD_ADDR_EXP 83
61671: PUSH
61672: LD_EXP 83
61676: PPUSH
61677: LD_VAR 0 1
61681: PPUSH
61682: EMPTY
61683: PPUSH
61684: CALL_OW 1
61688: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61689: LD_ADDR_EXP 84
61693: PUSH
61694: LD_EXP 84
61698: PPUSH
61699: LD_VAR 0 1
61703: PPUSH
61704: EMPTY
61705: PPUSH
61706: CALL_OW 1
61710: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61711: LD_ADDR_EXP 85
61715: PUSH
61716: LD_EXP 85
61720: PPUSH
61721: LD_VAR 0 1
61725: PPUSH
61726: EMPTY
61727: PPUSH
61728: CALL_OW 1
61732: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61733: LD_ADDR_EXP 86
61737: PUSH
61738: LD_EXP 86
61742: PPUSH
61743: LD_VAR 0 1
61747: PPUSH
61748: EMPTY
61749: PPUSH
61750: CALL_OW 1
61754: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61755: LD_ADDR_EXP 87
61759: PUSH
61760: LD_EXP 87
61764: PPUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: EMPTY
61771: PPUSH
61772: CALL_OW 1
61776: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61777: LD_ADDR_EXP 88
61781: PUSH
61782: LD_EXP 88
61786: PPUSH
61787: LD_VAR 0 1
61791: PPUSH
61792: EMPTY
61793: PPUSH
61794: CALL_OW 1
61798: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61799: LD_ADDR_EXP 90
61803: PUSH
61804: LD_EXP 90
61808: PPUSH
61809: LD_VAR 0 1
61813: PPUSH
61814: EMPTY
61815: PPUSH
61816: CALL_OW 1
61820: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61821: LD_ADDR_EXP 92
61825: PUSH
61826: LD_EXP 92
61830: PPUSH
61831: LD_VAR 0 1
61835: PPUSH
61836: EMPTY
61837: PPUSH
61838: CALL_OW 1
61842: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61843: LD_ADDR_EXP 93
61847: PUSH
61848: LD_EXP 93
61852: PPUSH
61853: LD_VAR 0 1
61857: PPUSH
61858: EMPTY
61859: PPUSH
61860: CALL_OW 1
61864: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61865: LD_ADDR_EXP 94
61869: PUSH
61870: LD_EXP 94
61874: PPUSH
61875: LD_VAR 0 1
61879: PPUSH
61880: EMPTY
61881: PPUSH
61882: CALL_OW 1
61886: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61887: LD_ADDR_EXP 95
61891: PUSH
61892: LD_EXP 95
61896: PPUSH
61897: LD_VAR 0 1
61901: PPUSH
61902: EMPTY
61903: PPUSH
61904: CALL_OW 1
61908: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61909: LD_ADDR_EXP 96
61913: PUSH
61914: LD_EXP 96
61918: PPUSH
61919: LD_VAR 0 1
61923: PPUSH
61924: EMPTY
61925: PPUSH
61926: CALL_OW 1
61930: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61931: LD_ADDR_EXP 97
61935: PUSH
61936: LD_EXP 97
61940: PPUSH
61941: LD_VAR 0 1
61945: PPUSH
61946: EMPTY
61947: PPUSH
61948: CALL_OW 1
61952: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61953: LD_ADDR_EXP 98
61957: PUSH
61958: LD_EXP 98
61962: PPUSH
61963: LD_VAR 0 1
61967: PPUSH
61968: EMPTY
61969: PPUSH
61970: CALL_OW 1
61974: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61975: LD_ADDR_EXP 99
61979: PUSH
61980: LD_EXP 99
61984: PPUSH
61985: LD_VAR 0 1
61989: PPUSH
61990: EMPTY
61991: PPUSH
61992: CALL_OW 1
61996: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61997: LD_ADDR_EXP 100
62001: PUSH
62002: LD_EXP 100
62006: PPUSH
62007: LD_VAR 0 1
62011: PPUSH
62012: EMPTY
62013: PPUSH
62014: CALL_OW 1
62018: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62019: LD_ADDR_EXP 101
62023: PUSH
62024: LD_EXP 101
62028: PPUSH
62029: LD_VAR 0 1
62033: PPUSH
62034: EMPTY
62035: PPUSH
62036: CALL_OW 1
62040: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62041: LD_ADDR_EXP 102
62045: PUSH
62046: LD_EXP 102
62050: PPUSH
62051: LD_VAR 0 1
62055: PPUSH
62056: EMPTY
62057: PPUSH
62058: CALL_OW 1
62062: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62063: LD_ADDR_EXP 103
62067: PUSH
62068: LD_EXP 103
62072: PPUSH
62073: LD_VAR 0 1
62077: PPUSH
62078: EMPTY
62079: PPUSH
62080: CALL_OW 1
62084: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62085: LD_ADDR_EXP 104
62089: PUSH
62090: LD_EXP 104
62094: PPUSH
62095: LD_VAR 0 1
62099: PPUSH
62100: EMPTY
62101: PPUSH
62102: CALL_OW 1
62106: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62107: LD_ADDR_EXP 105
62111: PUSH
62112: LD_EXP 105
62116: PPUSH
62117: LD_VAR 0 1
62121: PPUSH
62122: LD_INT 0
62124: PPUSH
62125: CALL_OW 1
62129: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62130: LD_ADDR_EXP 106
62134: PUSH
62135: LD_EXP 106
62139: PPUSH
62140: LD_VAR 0 1
62144: PPUSH
62145: LD_INT 0
62147: PPUSH
62148: CALL_OW 1
62152: ST_TO_ADDR
// end ;
62153: LD_VAR 0 2
62157: RET
// export function MC_Add ( side , units ) ; var base ; begin
62158: LD_INT 0
62160: PPUSH
62161: PPUSH
// base := mc_bases + 1 ;
62162: LD_ADDR_VAR 0 4
62166: PUSH
62167: LD_EXP 63
62171: PUSH
62172: LD_INT 1
62174: PLUS
62175: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62176: LD_ADDR_EXP 89
62180: PUSH
62181: LD_EXP 89
62185: PPUSH
62186: LD_VAR 0 4
62190: PPUSH
62191: LD_VAR 0 1
62195: PPUSH
62196: CALL_OW 1
62200: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62201: LD_ADDR_EXP 63
62205: PUSH
62206: LD_EXP 63
62210: PPUSH
62211: LD_VAR 0 4
62215: PPUSH
62216: LD_VAR 0 2
62220: PPUSH
62221: CALL_OW 1
62225: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62226: LD_ADDR_EXP 64
62230: PUSH
62231: LD_EXP 64
62235: PPUSH
62236: LD_VAR 0 4
62240: PPUSH
62241: EMPTY
62242: PPUSH
62243: CALL_OW 1
62247: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62248: LD_ADDR_EXP 65
62252: PUSH
62253: LD_EXP 65
62257: PPUSH
62258: LD_VAR 0 4
62262: PPUSH
62263: EMPTY
62264: PPUSH
62265: CALL_OW 1
62269: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62270: LD_ADDR_EXP 66
62274: PUSH
62275: LD_EXP 66
62279: PPUSH
62280: LD_VAR 0 4
62284: PPUSH
62285: EMPTY
62286: PPUSH
62287: CALL_OW 1
62291: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62292: LD_ADDR_EXP 67
62296: PUSH
62297: LD_EXP 67
62301: PPUSH
62302: LD_VAR 0 4
62306: PPUSH
62307: EMPTY
62308: PPUSH
62309: CALL_OW 1
62313: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62314: LD_ADDR_EXP 68
62318: PUSH
62319: LD_EXP 68
62323: PPUSH
62324: LD_VAR 0 4
62328: PPUSH
62329: EMPTY
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62336: LD_ADDR_EXP 69
62340: PUSH
62341: LD_EXP 69
62345: PPUSH
62346: LD_VAR 0 4
62350: PPUSH
62351: EMPTY
62352: PPUSH
62353: CALL_OW 1
62357: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62358: LD_ADDR_EXP 70
62362: PUSH
62363: LD_EXP 70
62367: PPUSH
62368: LD_VAR 0 4
62372: PPUSH
62373: EMPTY
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62380: LD_ADDR_EXP 71
62384: PUSH
62385: LD_EXP 71
62389: PPUSH
62390: LD_VAR 0 4
62394: PPUSH
62395: EMPTY
62396: PPUSH
62397: CALL_OW 1
62401: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62402: LD_ADDR_EXP 72
62406: PUSH
62407: LD_EXP 72
62411: PPUSH
62412: LD_VAR 0 4
62416: PPUSH
62417: EMPTY
62418: PPUSH
62419: CALL_OW 1
62423: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62424: LD_ADDR_EXP 73
62428: PUSH
62429: LD_EXP 73
62433: PPUSH
62434: LD_VAR 0 4
62438: PPUSH
62439: EMPTY
62440: PPUSH
62441: CALL_OW 1
62445: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62446: LD_ADDR_EXP 74
62450: PUSH
62451: LD_EXP 74
62455: PPUSH
62456: LD_VAR 0 4
62460: PPUSH
62461: LD_INT 0
62463: PPUSH
62464: CALL_OW 1
62468: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62469: LD_ADDR_EXP 75
62473: PUSH
62474: LD_EXP 75
62478: PPUSH
62479: LD_VAR 0 4
62483: PPUSH
62484: EMPTY
62485: PPUSH
62486: CALL_OW 1
62490: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62491: LD_ADDR_EXP 76
62495: PUSH
62496: LD_EXP 76
62500: PPUSH
62501: LD_VAR 0 4
62505: PPUSH
62506: EMPTY
62507: PPUSH
62508: CALL_OW 1
62512: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62513: LD_ADDR_EXP 77
62517: PUSH
62518: LD_EXP 77
62522: PPUSH
62523: LD_VAR 0 4
62527: PPUSH
62528: EMPTY
62529: PPUSH
62530: CALL_OW 1
62534: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62535: LD_ADDR_EXP 78
62539: PUSH
62540: LD_EXP 78
62544: PPUSH
62545: LD_VAR 0 4
62549: PPUSH
62550: EMPTY
62551: PPUSH
62552: CALL_OW 1
62556: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62557: LD_ADDR_EXP 79
62561: PUSH
62562: LD_EXP 79
62566: PPUSH
62567: LD_VAR 0 4
62571: PPUSH
62572: EMPTY
62573: PPUSH
62574: CALL_OW 1
62578: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62579: LD_ADDR_EXP 80
62583: PUSH
62584: LD_EXP 80
62588: PPUSH
62589: LD_VAR 0 4
62593: PPUSH
62594: EMPTY
62595: PPUSH
62596: CALL_OW 1
62600: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62601: LD_ADDR_EXP 81
62605: PUSH
62606: LD_EXP 81
62610: PPUSH
62611: LD_VAR 0 4
62615: PPUSH
62616: EMPTY
62617: PPUSH
62618: CALL_OW 1
62622: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62623: LD_ADDR_EXP 82
62627: PUSH
62628: LD_EXP 82
62632: PPUSH
62633: LD_VAR 0 4
62637: PPUSH
62638: EMPTY
62639: PPUSH
62640: CALL_OW 1
62644: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62645: LD_ADDR_EXP 83
62649: PUSH
62650: LD_EXP 83
62654: PPUSH
62655: LD_VAR 0 4
62659: PPUSH
62660: EMPTY
62661: PPUSH
62662: CALL_OW 1
62666: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62667: LD_ADDR_EXP 84
62671: PUSH
62672: LD_EXP 84
62676: PPUSH
62677: LD_VAR 0 4
62681: PPUSH
62682: EMPTY
62683: PPUSH
62684: CALL_OW 1
62688: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62689: LD_ADDR_EXP 85
62693: PUSH
62694: LD_EXP 85
62698: PPUSH
62699: LD_VAR 0 4
62703: PPUSH
62704: EMPTY
62705: PPUSH
62706: CALL_OW 1
62710: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62711: LD_ADDR_EXP 86
62715: PUSH
62716: LD_EXP 86
62720: PPUSH
62721: LD_VAR 0 4
62725: PPUSH
62726: EMPTY
62727: PPUSH
62728: CALL_OW 1
62732: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62733: LD_ADDR_EXP 87
62737: PUSH
62738: LD_EXP 87
62742: PPUSH
62743: LD_VAR 0 4
62747: PPUSH
62748: EMPTY
62749: PPUSH
62750: CALL_OW 1
62754: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62755: LD_ADDR_EXP 88
62759: PUSH
62760: LD_EXP 88
62764: PPUSH
62765: LD_VAR 0 4
62769: PPUSH
62770: EMPTY
62771: PPUSH
62772: CALL_OW 1
62776: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62777: LD_ADDR_EXP 90
62781: PUSH
62782: LD_EXP 90
62786: PPUSH
62787: LD_VAR 0 4
62791: PPUSH
62792: EMPTY
62793: PPUSH
62794: CALL_OW 1
62798: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62799: LD_ADDR_EXP 92
62803: PUSH
62804: LD_EXP 92
62808: PPUSH
62809: LD_VAR 0 4
62813: PPUSH
62814: EMPTY
62815: PPUSH
62816: CALL_OW 1
62820: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62821: LD_ADDR_EXP 93
62825: PUSH
62826: LD_EXP 93
62830: PPUSH
62831: LD_VAR 0 4
62835: PPUSH
62836: EMPTY
62837: PPUSH
62838: CALL_OW 1
62842: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62843: LD_ADDR_EXP 94
62847: PUSH
62848: LD_EXP 94
62852: PPUSH
62853: LD_VAR 0 4
62857: PPUSH
62858: EMPTY
62859: PPUSH
62860: CALL_OW 1
62864: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62865: LD_ADDR_EXP 95
62869: PUSH
62870: LD_EXP 95
62874: PPUSH
62875: LD_VAR 0 4
62879: PPUSH
62880: EMPTY
62881: PPUSH
62882: CALL_OW 1
62886: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62887: LD_ADDR_EXP 96
62891: PUSH
62892: LD_EXP 96
62896: PPUSH
62897: LD_VAR 0 4
62901: PPUSH
62902: EMPTY
62903: PPUSH
62904: CALL_OW 1
62908: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62909: LD_ADDR_EXP 97
62913: PUSH
62914: LD_EXP 97
62918: PPUSH
62919: LD_VAR 0 4
62923: PPUSH
62924: EMPTY
62925: PPUSH
62926: CALL_OW 1
62930: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62931: LD_ADDR_EXP 98
62935: PUSH
62936: LD_EXP 98
62940: PPUSH
62941: LD_VAR 0 4
62945: PPUSH
62946: EMPTY
62947: PPUSH
62948: CALL_OW 1
62952: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62953: LD_ADDR_EXP 99
62957: PUSH
62958: LD_EXP 99
62962: PPUSH
62963: LD_VAR 0 4
62967: PPUSH
62968: EMPTY
62969: PPUSH
62970: CALL_OW 1
62974: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62975: LD_ADDR_EXP 100
62979: PUSH
62980: LD_EXP 100
62984: PPUSH
62985: LD_VAR 0 4
62989: PPUSH
62990: EMPTY
62991: PPUSH
62992: CALL_OW 1
62996: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62997: LD_ADDR_EXP 101
63001: PUSH
63002: LD_EXP 101
63006: PPUSH
63007: LD_VAR 0 4
63011: PPUSH
63012: EMPTY
63013: PPUSH
63014: CALL_OW 1
63018: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
63019: LD_ADDR_EXP 102
63023: PUSH
63024: LD_EXP 102
63028: PPUSH
63029: LD_VAR 0 4
63033: PPUSH
63034: EMPTY
63035: PPUSH
63036: CALL_OW 1
63040: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
63041: LD_ADDR_EXP 103
63045: PUSH
63046: LD_EXP 103
63050: PPUSH
63051: LD_VAR 0 4
63055: PPUSH
63056: EMPTY
63057: PPUSH
63058: CALL_OW 1
63062: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63063: LD_ADDR_EXP 104
63067: PUSH
63068: LD_EXP 104
63072: PPUSH
63073: LD_VAR 0 4
63077: PPUSH
63078: EMPTY
63079: PPUSH
63080: CALL_OW 1
63084: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63085: LD_ADDR_EXP 105
63089: PUSH
63090: LD_EXP 105
63094: PPUSH
63095: LD_VAR 0 4
63099: PPUSH
63100: LD_INT 0
63102: PPUSH
63103: CALL_OW 1
63107: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63108: LD_ADDR_EXP 106
63112: PUSH
63113: LD_EXP 106
63117: PPUSH
63118: LD_VAR 0 4
63122: PPUSH
63123: LD_INT 0
63125: PPUSH
63126: CALL_OW 1
63130: ST_TO_ADDR
// result := base ;
63131: LD_ADDR_VAR 0 3
63135: PUSH
63136: LD_VAR 0 4
63140: ST_TO_ADDR
// end ;
63141: LD_VAR 0 3
63145: RET
// export function MC_Start ( ) ; var i ; begin
63146: LD_INT 0
63148: PPUSH
63149: PPUSH
// for i = 1 to mc_bases do
63150: LD_ADDR_VAR 0 2
63154: PUSH
63155: DOUBLE
63156: LD_INT 1
63158: DEC
63159: ST_TO_ADDR
63160: LD_EXP 63
63164: PUSH
63165: FOR_TO
63166: IFFALSE 64266
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63168: LD_ADDR_EXP 63
63172: PUSH
63173: LD_EXP 63
63177: PPUSH
63178: LD_VAR 0 2
63182: PPUSH
63183: LD_EXP 63
63187: PUSH
63188: LD_VAR 0 2
63192: ARRAY
63193: PUSH
63194: LD_INT 0
63196: DIFF
63197: PPUSH
63198: CALL_OW 1
63202: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63203: LD_ADDR_EXP 64
63207: PUSH
63208: LD_EXP 64
63212: PPUSH
63213: LD_VAR 0 2
63217: PPUSH
63218: EMPTY
63219: PPUSH
63220: CALL_OW 1
63224: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63225: LD_ADDR_EXP 65
63229: PUSH
63230: LD_EXP 65
63234: PPUSH
63235: LD_VAR 0 2
63239: PPUSH
63240: EMPTY
63241: PPUSH
63242: CALL_OW 1
63246: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63247: LD_ADDR_EXP 66
63251: PUSH
63252: LD_EXP 66
63256: PPUSH
63257: LD_VAR 0 2
63261: PPUSH
63262: EMPTY
63263: PPUSH
63264: CALL_OW 1
63268: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63269: LD_ADDR_EXP 67
63273: PUSH
63274: LD_EXP 67
63278: PPUSH
63279: LD_VAR 0 2
63283: PPUSH
63284: EMPTY
63285: PUSH
63286: EMPTY
63287: PUSH
63288: EMPTY
63289: LIST
63290: LIST
63291: PPUSH
63292: CALL_OW 1
63296: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63297: LD_ADDR_EXP 68
63301: PUSH
63302: LD_EXP 68
63306: PPUSH
63307: LD_VAR 0 2
63311: PPUSH
63312: EMPTY
63313: PPUSH
63314: CALL_OW 1
63318: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63319: LD_ADDR_EXP 95
63323: PUSH
63324: LD_EXP 95
63328: PPUSH
63329: LD_VAR 0 2
63333: PPUSH
63334: EMPTY
63335: PPUSH
63336: CALL_OW 1
63340: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63341: LD_ADDR_EXP 69
63345: PUSH
63346: LD_EXP 69
63350: PPUSH
63351: LD_VAR 0 2
63355: PPUSH
63356: EMPTY
63357: PPUSH
63358: CALL_OW 1
63362: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63363: LD_ADDR_EXP 70
63367: PUSH
63368: LD_EXP 70
63372: PPUSH
63373: LD_VAR 0 2
63377: PPUSH
63378: EMPTY
63379: PPUSH
63380: CALL_OW 1
63384: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63385: LD_ADDR_EXP 71
63389: PUSH
63390: LD_EXP 71
63394: PPUSH
63395: LD_VAR 0 2
63399: PPUSH
63400: LD_EXP 63
63404: PUSH
63405: LD_VAR 0 2
63409: ARRAY
63410: PPUSH
63411: LD_INT 2
63413: PUSH
63414: LD_INT 30
63416: PUSH
63417: LD_INT 32
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: PUSH
63424: LD_INT 30
63426: PUSH
63427: LD_INT 33
63429: PUSH
63430: EMPTY
63431: LIST
63432: LIST
63433: PUSH
63434: EMPTY
63435: LIST
63436: LIST
63437: LIST
63438: PPUSH
63439: CALL_OW 72
63443: PPUSH
63444: CALL_OW 1
63448: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63449: LD_ADDR_EXP 72
63453: PUSH
63454: LD_EXP 72
63458: PPUSH
63459: LD_VAR 0 2
63463: PPUSH
63464: LD_EXP 63
63468: PUSH
63469: LD_VAR 0 2
63473: ARRAY
63474: PPUSH
63475: LD_INT 2
63477: PUSH
63478: LD_INT 30
63480: PUSH
63481: LD_INT 32
63483: PUSH
63484: EMPTY
63485: LIST
63486: LIST
63487: PUSH
63488: LD_INT 30
63490: PUSH
63491: LD_INT 31
63493: PUSH
63494: EMPTY
63495: LIST
63496: LIST
63497: PUSH
63498: EMPTY
63499: LIST
63500: LIST
63501: LIST
63502: PUSH
63503: LD_INT 58
63505: PUSH
63506: EMPTY
63507: LIST
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PPUSH
63513: CALL_OW 72
63517: PPUSH
63518: CALL_OW 1
63522: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63523: LD_ADDR_EXP 73
63527: PUSH
63528: LD_EXP 73
63532: PPUSH
63533: LD_VAR 0 2
63537: PPUSH
63538: EMPTY
63539: PPUSH
63540: CALL_OW 1
63544: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63545: LD_ADDR_EXP 77
63549: PUSH
63550: LD_EXP 77
63554: PPUSH
63555: LD_VAR 0 2
63559: PPUSH
63560: EMPTY
63561: PPUSH
63562: CALL_OW 1
63566: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63567: LD_ADDR_EXP 76
63571: PUSH
63572: LD_EXP 76
63576: PPUSH
63577: LD_VAR 0 2
63581: PPUSH
63582: EMPTY
63583: PPUSH
63584: CALL_OW 1
63588: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63589: LD_ADDR_EXP 78
63593: PUSH
63594: LD_EXP 78
63598: PPUSH
63599: LD_VAR 0 2
63603: PPUSH
63604: EMPTY
63605: PPUSH
63606: CALL_OW 1
63610: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63611: LD_ADDR_EXP 79
63615: PUSH
63616: LD_EXP 79
63620: PPUSH
63621: LD_VAR 0 2
63625: PPUSH
63626: EMPTY
63627: PPUSH
63628: CALL_OW 1
63632: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63633: LD_ADDR_EXP 80
63637: PUSH
63638: LD_EXP 80
63642: PPUSH
63643: LD_VAR 0 2
63647: PPUSH
63648: EMPTY
63649: PPUSH
63650: CALL_OW 1
63654: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63655: LD_ADDR_EXP 81
63659: PUSH
63660: LD_EXP 81
63664: PPUSH
63665: LD_VAR 0 2
63669: PPUSH
63670: EMPTY
63671: PPUSH
63672: CALL_OW 1
63676: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63677: LD_ADDR_EXP 82
63681: PUSH
63682: LD_EXP 82
63686: PPUSH
63687: LD_VAR 0 2
63691: PPUSH
63692: EMPTY
63693: PPUSH
63694: CALL_OW 1
63698: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63699: LD_ADDR_EXP 83
63703: PUSH
63704: LD_EXP 83
63708: PPUSH
63709: LD_VAR 0 2
63713: PPUSH
63714: EMPTY
63715: PPUSH
63716: CALL_OW 1
63720: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
63721: LD_ADDR_EXP 84
63725: PUSH
63726: LD_EXP 84
63730: PPUSH
63731: LD_VAR 0 2
63735: PPUSH
63736: EMPTY
63737: PPUSH
63738: CALL_OW 1
63742: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63743: LD_ADDR_EXP 85
63747: PUSH
63748: LD_EXP 85
63752: PPUSH
63753: LD_VAR 0 2
63757: PPUSH
63758: EMPTY
63759: PPUSH
63760: CALL_OW 1
63764: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
63765: LD_ADDR_EXP 74
63769: PUSH
63770: LD_EXP 74
63774: PPUSH
63775: LD_VAR 0 2
63779: PPUSH
63780: LD_INT 0
63782: PPUSH
63783: CALL_OW 1
63787: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
63788: LD_ADDR_EXP 87
63792: PUSH
63793: LD_EXP 87
63797: PPUSH
63798: LD_VAR 0 2
63802: PPUSH
63803: LD_INT 0
63805: PPUSH
63806: CALL_OW 1
63810: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
63811: LD_ADDR_EXP 75
63815: PUSH
63816: LD_EXP 75
63820: PPUSH
63821: LD_VAR 0 2
63825: PPUSH
63826: EMPTY
63827: PPUSH
63828: CALL_OW 1
63832: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
63833: LD_ADDR_EXP 86
63837: PUSH
63838: LD_EXP 86
63842: PPUSH
63843: LD_VAR 0 2
63847: PPUSH
63848: LD_INT 0
63850: PPUSH
63851: CALL_OW 1
63855: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63856: LD_ADDR_EXP 88
63860: PUSH
63861: LD_EXP 88
63865: PPUSH
63866: LD_VAR 0 2
63870: PPUSH
63871: EMPTY
63872: PPUSH
63873: CALL_OW 1
63877: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63878: LD_ADDR_EXP 91
63882: PUSH
63883: LD_EXP 91
63887: PPUSH
63888: LD_VAR 0 2
63892: PPUSH
63893: LD_INT 0
63895: PPUSH
63896: CALL_OW 1
63900: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63901: LD_ADDR_EXP 92
63905: PUSH
63906: LD_EXP 92
63910: PPUSH
63911: LD_VAR 0 2
63915: PPUSH
63916: EMPTY
63917: PPUSH
63918: CALL_OW 1
63922: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63923: LD_ADDR_EXP 93
63927: PUSH
63928: LD_EXP 93
63932: PPUSH
63933: LD_VAR 0 2
63937: PPUSH
63938: EMPTY
63939: PPUSH
63940: CALL_OW 1
63944: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63945: LD_ADDR_EXP 94
63949: PUSH
63950: LD_EXP 94
63954: PPUSH
63955: LD_VAR 0 2
63959: PPUSH
63960: EMPTY
63961: PPUSH
63962: CALL_OW 1
63966: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63967: LD_ADDR_EXP 96
63971: PUSH
63972: LD_EXP 96
63976: PPUSH
63977: LD_VAR 0 2
63981: PPUSH
63982: LD_EXP 63
63986: PUSH
63987: LD_VAR 0 2
63991: ARRAY
63992: PPUSH
63993: LD_INT 2
63995: PUSH
63996: LD_INT 30
63998: PUSH
63999: LD_INT 6
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: LD_INT 30
64008: PUSH
64009: LD_INT 7
64011: PUSH
64012: EMPTY
64013: LIST
64014: LIST
64015: PUSH
64016: LD_INT 30
64018: PUSH
64019: LD_INT 8
64021: PUSH
64022: EMPTY
64023: LIST
64024: LIST
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: LIST
64030: LIST
64031: PPUSH
64032: CALL_OW 72
64036: PPUSH
64037: CALL_OW 1
64041: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
64042: LD_ADDR_EXP 97
64046: PUSH
64047: LD_EXP 97
64051: PPUSH
64052: LD_VAR 0 2
64056: PPUSH
64057: EMPTY
64058: PPUSH
64059: CALL_OW 1
64063: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64064: LD_ADDR_EXP 98
64068: PUSH
64069: LD_EXP 98
64073: PPUSH
64074: LD_VAR 0 2
64078: PPUSH
64079: EMPTY
64080: PPUSH
64081: CALL_OW 1
64085: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64086: LD_ADDR_EXP 99
64090: PUSH
64091: LD_EXP 99
64095: PPUSH
64096: LD_VAR 0 2
64100: PPUSH
64101: EMPTY
64102: PPUSH
64103: CALL_OW 1
64107: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64108: LD_ADDR_EXP 100
64112: PUSH
64113: LD_EXP 100
64117: PPUSH
64118: LD_VAR 0 2
64122: PPUSH
64123: EMPTY
64124: PPUSH
64125: CALL_OW 1
64129: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64130: LD_ADDR_EXP 101
64134: PUSH
64135: LD_EXP 101
64139: PPUSH
64140: LD_VAR 0 2
64144: PPUSH
64145: EMPTY
64146: PPUSH
64147: CALL_OW 1
64151: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64152: LD_ADDR_EXP 102
64156: PUSH
64157: LD_EXP 102
64161: PPUSH
64162: LD_VAR 0 2
64166: PPUSH
64167: EMPTY
64168: PPUSH
64169: CALL_OW 1
64173: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64174: LD_ADDR_EXP 103
64178: PUSH
64179: LD_EXP 103
64183: PPUSH
64184: LD_VAR 0 2
64188: PPUSH
64189: EMPTY
64190: PPUSH
64191: CALL_OW 1
64195: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64196: LD_ADDR_EXP 104
64200: PUSH
64201: LD_EXP 104
64205: PPUSH
64206: LD_VAR 0 2
64210: PPUSH
64211: EMPTY
64212: PPUSH
64213: CALL_OW 1
64217: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64218: LD_ADDR_EXP 105
64222: PUSH
64223: LD_EXP 105
64227: PPUSH
64228: LD_VAR 0 2
64232: PPUSH
64233: LD_INT 0
64235: PPUSH
64236: CALL_OW 1
64240: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64241: LD_ADDR_EXP 106
64245: PUSH
64246: LD_EXP 106
64250: PPUSH
64251: LD_VAR 0 2
64255: PPUSH
64256: LD_INT 0
64258: PPUSH
64259: CALL_OW 1
64263: ST_TO_ADDR
// end ;
64264: GO 63165
64266: POP
64267: POP
// MC_InitSides ( ) ;
64268: CALL 64554 0 0
// MC_InitResearch ( ) ;
64272: CALL 64293 0 0
// CustomInitMacro ( ) ;
64276: CALL 219 0 0
// skirmish := true ;
64280: LD_ADDR_EXP 61
64284: PUSH
64285: LD_INT 1
64287: ST_TO_ADDR
// end ;
64288: LD_VAR 0 1
64292: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64293: LD_INT 0
64295: PPUSH
64296: PPUSH
64297: PPUSH
64298: PPUSH
64299: PPUSH
64300: PPUSH
// if not mc_bases then
64301: LD_EXP 63
64305: NOT
64306: IFFALSE 64310
// exit ;
64308: GO 64549
// for i = 1 to 8 do
64310: LD_ADDR_VAR 0 2
64314: PUSH
64315: DOUBLE
64316: LD_INT 1
64318: DEC
64319: ST_TO_ADDR
64320: LD_INT 8
64322: PUSH
64323: FOR_TO
64324: IFFALSE 64350
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64326: LD_ADDR_EXP 90
64330: PUSH
64331: LD_EXP 90
64335: PPUSH
64336: LD_VAR 0 2
64340: PPUSH
64341: EMPTY
64342: PPUSH
64343: CALL_OW 1
64347: ST_TO_ADDR
64348: GO 64323
64350: POP
64351: POP
// tmp := [ ] ;
64352: LD_ADDR_VAR 0 5
64356: PUSH
64357: EMPTY
64358: ST_TO_ADDR
// for i = 1 to mc_sides do
64359: LD_ADDR_VAR 0 2
64363: PUSH
64364: DOUBLE
64365: LD_INT 1
64367: DEC
64368: ST_TO_ADDR
64369: LD_EXP 89
64373: PUSH
64374: FOR_TO
64375: IFFALSE 64433
// if not mc_sides [ i ] in tmp then
64377: LD_EXP 89
64381: PUSH
64382: LD_VAR 0 2
64386: ARRAY
64387: PUSH
64388: LD_VAR 0 5
64392: IN
64393: NOT
64394: IFFALSE 64431
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64396: LD_ADDR_VAR 0 5
64400: PUSH
64401: LD_VAR 0 5
64405: PPUSH
64406: LD_VAR 0 5
64410: PUSH
64411: LD_INT 1
64413: PLUS
64414: PPUSH
64415: LD_EXP 89
64419: PUSH
64420: LD_VAR 0 2
64424: ARRAY
64425: PPUSH
64426: CALL_OW 2
64430: ST_TO_ADDR
64431: GO 64374
64433: POP
64434: POP
// if not tmp then
64435: LD_VAR 0 5
64439: NOT
64440: IFFALSE 64444
// exit ;
64442: GO 64549
// for j in tmp do
64444: LD_ADDR_VAR 0 3
64448: PUSH
64449: LD_VAR 0 5
64453: PUSH
64454: FOR_IN
64455: IFFALSE 64547
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64457: LD_ADDR_VAR 0 6
64461: PUSH
64462: LD_INT 22
64464: PUSH
64465: LD_VAR 0 3
64469: PUSH
64470: EMPTY
64471: LIST
64472: LIST
64473: PPUSH
64474: CALL_OW 69
64478: ST_TO_ADDR
// if not un then
64479: LD_VAR 0 6
64483: NOT
64484: IFFALSE 64488
// continue ;
64486: GO 64454
// nation := GetNation ( un [ 1 ] ) ;
64488: LD_ADDR_VAR 0 4
64492: PUSH
64493: LD_VAR 0 6
64497: PUSH
64498: LD_INT 1
64500: ARRAY
64501: PPUSH
64502: CALL_OW 248
64506: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64507: LD_ADDR_EXP 90
64511: PUSH
64512: LD_EXP 90
64516: PPUSH
64517: LD_VAR 0 3
64521: PPUSH
64522: LD_VAR 0 3
64526: PPUSH
64527: LD_VAR 0 4
64531: PPUSH
64532: LD_INT 1
64534: PPUSH
64535: CALL 17559 0 3
64539: PPUSH
64540: CALL_OW 1
64544: ST_TO_ADDR
// end ;
64545: GO 64454
64547: POP
64548: POP
// end ;
64549: LD_VAR 0 1
64553: RET
// export function MC_InitSides ( ) ; var i ; begin
64554: LD_INT 0
64556: PPUSH
64557: PPUSH
// if not mc_bases then
64558: LD_EXP 63
64562: NOT
64563: IFFALSE 64567
// exit ;
64565: GO 64641
// for i = 1 to mc_bases do
64567: LD_ADDR_VAR 0 2
64571: PUSH
64572: DOUBLE
64573: LD_INT 1
64575: DEC
64576: ST_TO_ADDR
64577: LD_EXP 63
64581: PUSH
64582: FOR_TO
64583: IFFALSE 64639
// if mc_bases [ i ] then
64585: LD_EXP 63
64589: PUSH
64590: LD_VAR 0 2
64594: ARRAY
64595: IFFALSE 64637
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64597: LD_ADDR_EXP 89
64601: PUSH
64602: LD_EXP 89
64606: PPUSH
64607: LD_VAR 0 2
64611: PPUSH
64612: LD_EXP 63
64616: PUSH
64617: LD_VAR 0 2
64621: ARRAY
64622: PUSH
64623: LD_INT 1
64625: ARRAY
64626: PPUSH
64627: CALL_OW 255
64631: PPUSH
64632: CALL_OW 1
64636: ST_TO_ADDR
64637: GO 64582
64639: POP
64640: POP
// end ;
64641: LD_VAR 0 1
64645: RET
// every 0 0$03 trigger skirmish do
64646: LD_EXP 61
64650: IFFALSE 64804
64652: GO 64654
64654: DISABLE
// begin enable ;
64655: ENABLE
// MC_CheckBuildings ( ) ;
64656: CALL 69362 0 0
// MC_CheckPeopleLife ( ) ;
64660: CALL 69523 0 0
// RaiseSailEvent ( 100 ) ;
64664: LD_INT 100
64666: PPUSH
64667: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64671: LD_INT 103
64673: PPUSH
64674: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64678: LD_INT 104
64680: PPUSH
64681: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64685: LD_INT 105
64687: PPUSH
64688: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64692: LD_INT 106
64694: PPUSH
64695: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64699: LD_INT 107
64701: PPUSH
64702: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64706: LD_INT 108
64708: PPUSH
64709: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64713: LD_INT 109
64715: PPUSH
64716: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
64720: LD_INT 110
64722: PPUSH
64723: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
64727: LD_INT 111
64729: PPUSH
64730: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
64734: LD_INT 112
64736: PPUSH
64737: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
64741: LD_INT 113
64743: PPUSH
64744: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
64748: LD_INT 120
64750: PPUSH
64751: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
64755: LD_INT 121
64757: PPUSH
64758: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
64762: LD_INT 122
64764: PPUSH
64765: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
64769: LD_INT 123
64771: PPUSH
64772: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
64776: LD_INT 124
64778: PPUSH
64779: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
64783: LD_INT 125
64785: PPUSH
64786: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
64790: LD_INT 126
64792: PPUSH
64793: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
64797: LD_INT 200
64799: PPUSH
64800: CALL_OW 427
// end ;
64804: END
// on SailEvent ( event ) do begin if event < 100 then
64805: LD_VAR 0 1
64809: PUSH
64810: LD_INT 100
64812: LESS
64813: IFFALSE 64824
// CustomEvent ( event ) ;
64815: LD_VAR 0 1
64819: PPUSH
64820: CALL 16058 0 1
// if event = 100 then
64824: LD_VAR 0 1
64828: PUSH
64829: LD_INT 100
64831: EQUAL
64832: IFFALSE 64838
// MC_ClassManager ( ) ;
64834: CALL 65232 0 0
// if event = 101 then
64838: LD_VAR 0 1
64842: PUSH
64843: LD_INT 101
64845: EQUAL
64846: IFFALSE 64852
// MC_RepairBuildings ( ) ;
64848: CALL 70110 0 0
// if event = 102 then
64852: LD_VAR 0 1
64856: PUSH
64857: LD_INT 102
64859: EQUAL
64860: IFFALSE 64866
// MC_Heal ( ) ;
64862: CALL 71049 0 0
// if event = 103 then
64866: LD_VAR 0 1
64870: PUSH
64871: LD_INT 103
64873: EQUAL
64874: IFFALSE 64880
// MC_Build ( ) ;
64876: CALL 71475 0 0
// if event = 104 then
64880: LD_VAR 0 1
64884: PUSH
64885: LD_INT 104
64887: EQUAL
64888: IFFALSE 64894
// MC_TurretWeapon ( ) ;
64890: CALL 73123 0 0
// if event = 105 then
64894: LD_VAR 0 1
64898: PUSH
64899: LD_INT 105
64901: EQUAL
64902: IFFALSE 64908
// MC_BuildUpgrade ( ) ;
64904: CALL 72668 0 0
// if event = 106 then
64908: LD_VAR 0 1
64912: PUSH
64913: LD_INT 106
64915: EQUAL
64916: IFFALSE 64922
// MC_PlantMines ( ) ;
64918: CALL 73555 0 0
// if event = 107 then
64922: LD_VAR 0 1
64926: PUSH
64927: LD_INT 107
64929: EQUAL
64930: IFFALSE 64936
// MC_CollectCrates ( ) ;
64932: CALL 74365 0 0
// if event = 108 then
64936: LD_VAR 0 1
64940: PUSH
64941: LD_INT 108
64943: EQUAL
64944: IFFALSE 64950
// MC_LinkRemoteControl ( ) ;
64946: CALL 76239 0 0
// if event = 109 then
64950: LD_VAR 0 1
64954: PUSH
64955: LD_INT 109
64957: EQUAL
64958: IFFALSE 64964
// MC_ProduceVehicle ( ) ;
64960: CALL 76424 0 0
// if event = 110 then
64964: LD_VAR 0 1
64968: PUSH
64969: LD_INT 110
64971: EQUAL
64972: IFFALSE 64978
// MC_SendAttack ( ) ;
64974: CALL 76894 0 0
// if event = 111 then
64978: LD_VAR 0 1
64982: PUSH
64983: LD_INT 111
64985: EQUAL
64986: IFFALSE 64992
// MC_Defend ( ) ;
64988: CALL 77002 0 0
// if event = 112 then
64992: LD_VAR 0 1
64996: PUSH
64997: LD_INT 112
64999: EQUAL
65000: IFFALSE 65006
// MC_Research ( ) ;
65002: CALL 77902 0 0
// if event = 113 then
65006: LD_VAR 0 1
65010: PUSH
65011: LD_INT 113
65013: EQUAL
65014: IFFALSE 65020
// MC_MinesTrigger ( ) ;
65016: CALL 79042 0 0
// if event = 120 then
65020: LD_VAR 0 1
65024: PUSH
65025: LD_INT 120
65027: EQUAL
65028: IFFALSE 65034
// MC_RepairVehicle ( ) ;
65030: CALL 79143 0 0
// if event = 121 then
65034: LD_VAR 0 1
65038: PUSH
65039: LD_INT 121
65041: EQUAL
65042: IFFALSE 65048
// MC_TameApe ( ) ;
65044: CALL 79920 0 0
// if event = 122 then
65048: LD_VAR 0 1
65052: PUSH
65053: LD_INT 122
65055: EQUAL
65056: IFFALSE 65062
// MC_ChangeApeClass ( ) ;
65058: CALL 80765 0 0
// if event = 123 then
65062: LD_VAR 0 1
65066: PUSH
65067: LD_INT 123
65069: EQUAL
65070: IFFALSE 65076
// MC_Bazooka ( ) ;
65072: CALL 81421 0 0
// if event = 124 then
65076: LD_VAR 0 1
65080: PUSH
65081: LD_INT 124
65083: EQUAL
65084: IFFALSE 65090
// MC_TeleportExit ( ) ;
65086: CALL 81623 0 0
// if event = 125 then
65090: LD_VAR 0 1
65094: PUSH
65095: LD_INT 125
65097: EQUAL
65098: IFFALSE 65104
// MC_Deposits ( ) ;
65100: CALL 82280 0 0
// if event = 126 then
65104: LD_VAR 0 1
65108: PUSH
65109: LD_INT 126
65111: EQUAL
65112: IFFALSE 65118
// MC_RemoteDriver ( ) ;
65114: CALL 82913 0 0
// if event = 200 then
65118: LD_VAR 0 1
65122: PUSH
65123: LD_INT 200
65125: EQUAL
65126: IFFALSE 65132
// MC_Idle ( ) ;
65128: CALL 84848 0 0
// end ;
65132: PPOPN 1
65134: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65135: LD_INT 0
65137: PPUSH
65138: PPUSH
// if not mc_bases [ base ] or not tag then
65139: LD_EXP 63
65143: PUSH
65144: LD_VAR 0 1
65148: ARRAY
65149: NOT
65150: IFTRUE 65159
65152: PUSH
65153: LD_VAR 0 2
65157: NOT
65158: OR
65159: IFFALSE 65163
// exit ;
65161: GO 65227
// for i in mc_bases [ base ] union mc_ape [ base ] do
65163: LD_ADDR_VAR 0 4
65167: PUSH
65168: LD_EXP 63
65172: PUSH
65173: LD_VAR 0 1
65177: ARRAY
65178: PUSH
65179: LD_EXP 92
65183: PUSH
65184: LD_VAR 0 1
65188: ARRAY
65189: UNION
65190: PUSH
65191: FOR_IN
65192: IFFALSE 65225
// if GetTag ( i ) = tag then
65194: LD_VAR 0 4
65198: PPUSH
65199: CALL_OW 110
65203: PUSH
65204: LD_VAR 0 2
65208: EQUAL
65209: IFFALSE 65223
// SetTag ( i , 0 ) ;
65211: LD_VAR 0 4
65215: PPUSH
65216: LD_INT 0
65218: PPUSH
65219: CALL_OW 109
65223: GO 65191
65225: POP
65226: POP
// end ;
65227: LD_VAR 0 3
65231: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65232: LD_INT 0
65234: PPUSH
65235: PPUSH
65236: PPUSH
65237: PPUSH
65238: PPUSH
65239: PPUSH
65240: PPUSH
65241: PPUSH
// if not mc_bases then
65242: LD_EXP 63
65246: NOT
65247: IFFALSE 65251
// exit ;
65249: GO 65702
// for i = 1 to mc_bases do
65251: LD_ADDR_VAR 0 2
65255: PUSH
65256: DOUBLE
65257: LD_INT 1
65259: DEC
65260: ST_TO_ADDR
65261: LD_EXP 63
65265: PUSH
65266: FOR_TO
65267: IFFALSE 65700
// begin tmp := MC_ClassCheckReq ( i ) ;
65269: LD_ADDR_VAR 0 4
65273: PUSH
65274: LD_VAR 0 2
65278: PPUSH
65279: CALL 65707 0 1
65283: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65284: LD_ADDR_EXP 104
65288: PUSH
65289: LD_EXP 104
65293: PPUSH
65294: LD_VAR 0 2
65298: PPUSH
65299: LD_VAR 0 4
65303: PPUSH
65304: CALL_OW 1
65308: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65309: LD_ADDR_VAR 0 6
65313: PUSH
65314: LD_EXP 63
65318: PUSH
65319: LD_VAR 0 2
65323: ARRAY
65324: PPUSH
65325: LD_INT 2
65327: PUSH
65328: LD_INT 30
65330: PUSH
65331: LD_INT 4
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: LD_INT 30
65340: PUSH
65341: LD_INT 5
65343: PUSH
65344: EMPTY
65345: LIST
65346: LIST
65347: PUSH
65348: EMPTY
65349: LIST
65350: LIST
65351: LIST
65352: PPUSH
65353: CALL_OW 72
65357: PUSH
65358: LD_EXP 63
65362: PUSH
65363: LD_VAR 0 2
65367: ARRAY
65368: PPUSH
65369: LD_INT 2
65371: PUSH
65372: LD_INT 30
65374: PUSH
65375: LD_INT 0
65377: PUSH
65378: EMPTY
65379: LIST
65380: LIST
65381: PUSH
65382: LD_INT 30
65384: PUSH
65385: LD_INT 1
65387: PUSH
65388: EMPTY
65389: LIST
65390: LIST
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: LIST
65396: PPUSH
65397: CALL_OW 72
65401: PUSH
65402: LD_EXP 63
65406: PUSH
65407: LD_VAR 0 2
65411: ARRAY
65412: PPUSH
65413: LD_INT 30
65415: PUSH
65416: LD_INT 3
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PPUSH
65423: CALL_OW 72
65427: PUSH
65428: LD_EXP 63
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: PPUSH
65439: LD_INT 2
65441: PUSH
65442: LD_INT 30
65444: PUSH
65445: LD_INT 6
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 30
65454: PUSH
65455: LD_INT 7
65457: PUSH
65458: EMPTY
65459: LIST
65460: LIST
65461: PUSH
65462: LD_INT 30
65464: PUSH
65465: LD_INT 8
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: LIST
65476: LIST
65477: PPUSH
65478: CALL_OW 72
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: LIST
65487: LIST
65488: ST_TO_ADDR
// for j := 1 to 4 do
65489: LD_ADDR_VAR 0 3
65493: PUSH
65494: DOUBLE
65495: LD_INT 1
65497: DEC
65498: ST_TO_ADDR
65499: LD_INT 4
65501: PUSH
65502: FOR_TO
65503: IFFALSE 65696
// begin if not tmp [ j ] then
65505: LD_VAR 0 4
65509: PUSH
65510: LD_VAR 0 3
65514: ARRAY
65515: NOT
65516: IFFALSE 65520
// continue ;
65518: GO 65502
// for p in tmp [ j ] do
65520: LD_ADDR_VAR 0 5
65524: PUSH
65525: LD_VAR 0 4
65529: PUSH
65530: LD_VAR 0 3
65534: ARRAY
65535: PUSH
65536: FOR_IN
65537: IFFALSE 65692
// begin if not b [ j ] then
65539: LD_VAR 0 6
65543: PUSH
65544: LD_VAR 0 3
65548: ARRAY
65549: NOT
65550: IFFALSE 65554
// break ;
65552: GO 65692
// e := 0 ;
65554: LD_ADDR_VAR 0 7
65558: PUSH
65559: LD_INT 0
65561: ST_TO_ADDR
// for k in b [ j ] do
65562: LD_ADDR_VAR 0 8
65566: PUSH
65567: LD_VAR 0 6
65571: PUSH
65572: LD_VAR 0 3
65576: ARRAY
65577: PUSH
65578: FOR_IN
65579: IFFALSE 65606
// if IsNotFull ( k ) then
65581: LD_VAR 0 8
65585: PPUSH
65586: CALL 19718 0 1
65590: IFFALSE 65604
// begin e := k ;
65592: LD_ADDR_VAR 0 7
65596: PUSH
65597: LD_VAR 0 8
65601: ST_TO_ADDR
// break ;
65602: GO 65606
// end ;
65604: GO 65578
65606: POP
65607: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65608: LD_VAR 0 7
65612: IFFALSE 65631
65614: PUSH
65615: LD_VAR 0 5
65619: PPUSH
65620: LD_VAR 0 7
65624: PPUSH
65625: CALL 54222 0 2
65629: NOT
65630: AND
65631: IFFALSE 65690
// begin if IsInUnit ( p ) then
65633: LD_VAR 0 5
65637: PPUSH
65638: CALL_OW 310
65642: IFFALSE 65653
// ComExitBuilding ( p ) ;
65644: LD_VAR 0 5
65648: PPUSH
65649: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65653: LD_VAR 0 5
65657: PPUSH
65658: LD_VAR 0 7
65662: PPUSH
65663: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65667: LD_VAR 0 5
65671: PPUSH
65672: LD_VAR 0 3
65676: PPUSH
65677: CALL_OW 183
// AddComExitBuilding ( p ) ;
65681: LD_VAR 0 5
65685: PPUSH
65686: CALL_OW 182
// end ; end ;
65690: GO 65536
65692: POP
65693: POP
// end ;
65694: GO 65502
65696: POP
65697: POP
// end ;
65698: GO 65266
65700: POP
65701: POP
// end ;
65702: LD_VAR 0 1
65706: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65707: LD_INT 0
65709: PPUSH
65710: PPUSH
65711: PPUSH
65712: PPUSH
65713: PPUSH
65714: PPUSH
65715: PPUSH
65716: PPUSH
65717: PPUSH
65718: PPUSH
65719: PPUSH
65720: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
65721: LD_ADDR_VAR 0 2
65725: PUSH
65726: LD_INT 0
65728: PUSH
65729: LD_INT 0
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: LD_INT 0
65737: PUSH
65738: EMPTY
65739: LIST
65740: LIST
65741: LIST
65742: LIST
65743: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65744: LD_VAR 0 1
65748: NOT
65749: IFTRUE 65764
65751: PUSH
65752: LD_EXP 63
65756: PUSH
65757: LD_VAR 0 1
65761: ARRAY
65762: NOT
65763: OR
65764: IFTRUE 65812
65766: PUSH
65767: LD_EXP 63
65771: PUSH
65772: LD_VAR 0 1
65776: ARRAY
65777: PPUSH
65778: LD_INT 2
65780: PUSH
65781: LD_INT 30
65783: PUSH
65784: LD_INT 0
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PUSH
65791: LD_INT 30
65793: PUSH
65794: LD_INT 1
65796: PUSH
65797: EMPTY
65798: LIST
65799: LIST
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: LIST
65805: PPUSH
65806: CALL_OW 72
65810: NOT
65811: OR
65812: IFFALSE 65816
// exit ;
65814: GO 69357
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65816: LD_ADDR_VAR 0 4
65820: PUSH
65821: LD_EXP 63
65825: PUSH
65826: LD_VAR 0 1
65830: ARRAY
65831: PPUSH
65832: LD_INT 2
65834: PUSH
65835: LD_INT 25
65837: PUSH
65838: LD_INT 1
65840: PUSH
65841: EMPTY
65842: LIST
65843: LIST
65844: PUSH
65845: LD_INT 25
65847: PUSH
65848: LD_INT 2
65850: PUSH
65851: EMPTY
65852: LIST
65853: LIST
65854: PUSH
65855: LD_INT 25
65857: PUSH
65858: LD_INT 3
65860: PUSH
65861: EMPTY
65862: LIST
65863: LIST
65864: PUSH
65865: LD_INT 25
65867: PUSH
65868: LD_INT 4
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PUSH
65875: LD_INT 25
65877: PUSH
65878: LD_INT 5
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: PUSH
65885: LD_INT 25
65887: PUSH
65888: LD_INT 8
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 25
65897: PUSH
65898: LD_INT 9
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: PPUSH
65915: CALL_OW 72
65919: ST_TO_ADDR
// if not tmp then
65920: LD_VAR 0 4
65924: NOT
65925: IFFALSE 65929
// exit ;
65927: GO 69357
// for i in tmp do
65929: LD_ADDR_VAR 0 3
65933: PUSH
65934: LD_VAR 0 4
65938: PUSH
65939: FOR_IN
65940: IFFALSE 65971
// if GetTag ( i ) then
65942: LD_VAR 0 3
65946: PPUSH
65947: CALL_OW 110
65951: IFFALSE 65969
// tmp := tmp diff i ;
65953: LD_ADDR_VAR 0 4
65957: PUSH
65958: LD_VAR 0 4
65962: PUSH
65963: LD_VAR 0 3
65967: DIFF
65968: ST_TO_ADDR
65969: GO 65939
65971: POP
65972: POP
// if not tmp then
65973: LD_VAR 0 4
65977: NOT
65978: IFFALSE 65982
// exit ;
65980: GO 69357
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65982: LD_ADDR_VAR 0 5
65986: PUSH
65987: LD_EXP 63
65991: PUSH
65992: LD_VAR 0 1
65996: ARRAY
65997: PPUSH
65998: LD_INT 2
66000: PUSH
66001: LD_INT 25
66003: PUSH
66004: LD_INT 1
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: LD_INT 25
66013: PUSH
66014: LD_INT 5
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 25
66023: PUSH
66024: LD_INT 8
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: LD_INT 25
66033: PUSH
66034: LD_INT 9
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: PUSH
66041: EMPTY
66042: LIST
66043: LIST
66044: LIST
66045: LIST
66046: LIST
66047: PPUSH
66048: CALL_OW 72
66052: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
66053: LD_ADDR_VAR 0 6
66057: PUSH
66058: LD_EXP 63
66062: PUSH
66063: LD_VAR 0 1
66067: ARRAY
66068: PPUSH
66069: LD_INT 25
66071: PUSH
66072: LD_INT 2
66074: PUSH
66075: EMPTY
66076: LIST
66077: LIST
66078: PPUSH
66079: CALL_OW 72
66083: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66084: LD_ADDR_VAR 0 7
66088: PUSH
66089: LD_EXP 63
66093: PUSH
66094: LD_VAR 0 1
66098: ARRAY
66099: PPUSH
66100: LD_INT 25
66102: PUSH
66103: LD_INT 3
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PPUSH
66110: CALL_OW 72
66114: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66115: LD_ADDR_VAR 0 8
66119: PUSH
66120: LD_EXP 63
66124: PUSH
66125: LD_VAR 0 1
66129: ARRAY
66130: PPUSH
66131: LD_INT 25
66133: PUSH
66134: LD_INT 4
66136: PUSH
66137: EMPTY
66138: LIST
66139: LIST
66140: PUSH
66141: LD_INT 24
66143: PUSH
66144: LD_INT 251
66146: PUSH
66147: EMPTY
66148: LIST
66149: LIST
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PPUSH
66155: CALL_OW 72
66159: ST_TO_ADDR
// if mc_is_defending [ base ] then
66160: LD_EXP 106
66164: PUSH
66165: LD_VAR 0 1
66169: ARRAY
66170: IFFALSE 66631
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66172: LD_ADDR_EXP 105
66176: PUSH
66177: LD_EXP 105
66181: PPUSH
66182: LD_VAR 0 1
66186: PPUSH
66187: LD_INT 4
66189: PPUSH
66190: CALL_OW 1
66194: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66195: LD_ADDR_VAR 0 12
66199: PUSH
66200: LD_EXP 63
66204: PUSH
66205: LD_VAR 0 1
66209: ARRAY
66210: PPUSH
66211: LD_INT 2
66213: PUSH
66214: LD_INT 30
66216: PUSH
66217: LD_INT 4
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 30
66226: PUSH
66227: LD_INT 5
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: LIST
66238: PPUSH
66239: CALL_OW 72
66243: ST_TO_ADDR
// if not b then
66244: LD_VAR 0 12
66248: NOT
66249: IFFALSE 66253
// exit ;
66251: GO 69357
// p := [ ] ;
66253: LD_ADDR_VAR 0 11
66257: PUSH
66258: EMPTY
66259: ST_TO_ADDR
// if sci >= 2 then
66260: LD_VAR 0 8
66264: PUSH
66265: LD_INT 2
66267: GREATEREQUAL
66268: IFFALSE 66299
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66270: LD_ADDR_VAR 0 8
66274: PUSH
66275: LD_VAR 0 8
66279: PUSH
66280: LD_INT 1
66282: ARRAY
66283: PUSH
66284: LD_VAR 0 8
66288: PUSH
66289: LD_INT 2
66291: ARRAY
66292: PUSH
66293: EMPTY
66294: LIST
66295: LIST
66296: ST_TO_ADDR
66297: GO 66360
// if sci = 1 then
66299: LD_VAR 0 8
66303: PUSH
66304: LD_INT 1
66306: EQUAL
66307: IFFALSE 66328
// sci := [ sci [ 1 ] ] else
66309: LD_ADDR_VAR 0 8
66313: PUSH
66314: LD_VAR 0 8
66318: PUSH
66319: LD_INT 1
66321: ARRAY
66322: PUSH
66323: EMPTY
66324: LIST
66325: ST_TO_ADDR
66326: GO 66360
// if sci = 0 then
66328: LD_VAR 0 8
66332: PUSH
66333: LD_INT 0
66335: EQUAL
66336: IFFALSE 66360
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66338: LD_ADDR_VAR 0 11
66342: PUSH
66343: LD_VAR 0 4
66347: PPUSH
66348: LD_INT 4
66350: PPUSH
66351: CALL 54092 0 2
66355: PUSH
66356: LD_INT 1
66358: ARRAY
66359: ST_TO_ADDR
// if eng > 4 then
66360: LD_VAR 0 6
66364: PUSH
66365: LD_INT 4
66367: GREATER
66368: IFFALSE 66414
// for i = eng downto 4 do
66370: LD_ADDR_VAR 0 3
66374: PUSH
66375: DOUBLE
66376: LD_VAR 0 6
66380: INC
66381: ST_TO_ADDR
66382: LD_INT 4
66384: PUSH
66385: FOR_DOWNTO
66386: IFFALSE 66412
// eng := eng diff eng [ i ] ;
66388: LD_ADDR_VAR 0 6
66392: PUSH
66393: LD_VAR 0 6
66397: PUSH
66398: LD_VAR 0 6
66402: PUSH
66403: LD_VAR 0 3
66407: ARRAY
66408: DIFF
66409: ST_TO_ADDR
66410: GO 66385
66412: POP
66413: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66414: LD_ADDR_VAR 0 4
66418: PUSH
66419: LD_VAR 0 4
66423: PUSH
66424: LD_VAR 0 5
66428: PUSH
66429: LD_VAR 0 6
66433: UNION
66434: PUSH
66435: LD_VAR 0 7
66439: UNION
66440: PUSH
66441: LD_VAR 0 8
66445: UNION
66446: DIFF
66447: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66448: LD_ADDR_VAR 0 13
66452: PUSH
66453: LD_EXP 63
66457: PUSH
66458: LD_VAR 0 1
66462: ARRAY
66463: PPUSH
66464: LD_INT 2
66466: PUSH
66467: LD_INT 30
66469: PUSH
66470: LD_INT 32
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 30
66479: PUSH
66480: LD_INT 31
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PUSH
66487: EMPTY
66488: LIST
66489: LIST
66490: LIST
66491: PPUSH
66492: CALL_OW 72
66496: PUSH
66497: LD_EXP 63
66501: PUSH
66502: LD_VAR 0 1
66506: ARRAY
66507: PPUSH
66508: LD_INT 2
66510: PUSH
66511: LD_INT 30
66513: PUSH
66514: LD_INT 4
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PUSH
66521: LD_INT 30
66523: PUSH
66524: LD_INT 5
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: LIST
66535: PPUSH
66536: CALL_OW 72
66540: PUSH
66541: LD_INT 6
66543: MUL
66544: PLUS
66545: ST_TO_ADDR
// if bcount < tmp then
66546: LD_VAR 0 13
66550: PUSH
66551: LD_VAR 0 4
66555: LESS
66556: IFFALSE 66602
// for i = tmp downto bcount do
66558: LD_ADDR_VAR 0 3
66562: PUSH
66563: DOUBLE
66564: LD_VAR 0 4
66568: INC
66569: ST_TO_ADDR
66570: LD_VAR 0 13
66574: PUSH
66575: FOR_DOWNTO
66576: IFFALSE 66600
// tmp := Delete ( tmp , tmp ) ;
66578: LD_ADDR_VAR 0 4
66582: PUSH
66583: LD_VAR 0 4
66587: PPUSH
66588: LD_VAR 0 4
66592: PPUSH
66593: CALL_OW 3
66597: ST_TO_ADDR
66598: GO 66575
66600: POP
66601: POP
// result := [ tmp , 0 , 0 , p ] ;
66602: LD_ADDR_VAR 0 2
66606: PUSH
66607: LD_VAR 0 4
66611: PUSH
66612: LD_INT 0
66614: PUSH
66615: LD_INT 0
66617: PUSH
66618: LD_VAR 0 11
66622: PUSH
66623: EMPTY
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: ST_TO_ADDR
// exit ;
66629: GO 69357
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66631: LD_EXP 63
66635: PUSH
66636: LD_VAR 0 1
66640: ARRAY
66641: PPUSH
66642: LD_INT 2
66644: PUSH
66645: LD_INT 30
66647: PUSH
66648: LD_INT 6
66650: PUSH
66651: EMPTY
66652: LIST
66653: LIST
66654: PUSH
66655: LD_INT 30
66657: PUSH
66658: LD_INT 7
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 30
66667: PUSH
66668: LD_INT 8
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: EMPTY
66676: LIST
66677: LIST
66678: LIST
66679: LIST
66680: PPUSH
66681: CALL_OW 72
66685: NOT
66686: IFFALSE 66716
66688: PUSH
66689: LD_EXP 63
66693: PUSH
66694: LD_VAR 0 1
66698: ARRAY
66699: PPUSH
66700: LD_INT 30
66702: PUSH
66703: LD_INT 3
66705: PUSH
66706: EMPTY
66707: LIST
66708: LIST
66709: PPUSH
66710: CALL_OW 72
66714: NOT
66715: AND
66716: IFFALSE 66788
// begin if eng = tmp then
66718: LD_VAR 0 6
66722: PUSH
66723: LD_VAR 0 4
66727: EQUAL
66728: IFFALSE 66732
// exit ;
66730: GO 69357
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66732: LD_ADDR_EXP 105
66736: PUSH
66737: LD_EXP 105
66741: PPUSH
66742: LD_VAR 0 1
66746: PPUSH
66747: LD_INT 1
66749: PPUSH
66750: CALL_OW 1
66754: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
66755: LD_ADDR_VAR 0 2
66759: PUSH
66760: LD_INT 0
66762: PUSH
66763: LD_VAR 0 4
66767: PUSH
66768: LD_VAR 0 6
66772: DIFF
66773: PUSH
66774: LD_INT 0
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: LIST
66784: LIST
66785: ST_TO_ADDR
// exit ;
66786: GO 69357
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66788: LD_EXP 90
66792: PUSH
66793: LD_EXP 89
66797: PUSH
66798: LD_VAR 0 1
66802: ARRAY
66803: ARRAY
66804: IFFALSE 66862
66806: PUSH
66807: LD_EXP 63
66811: PUSH
66812: LD_VAR 0 1
66816: ARRAY
66817: PPUSH
66818: LD_INT 2
66820: PUSH
66821: LD_INT 30
66823: PUSH
66824: LD_INT 6
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 30
66833: PUSH
66834: LD_INT 7
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 30
66843: PUSH
66844: LD_INT 8
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: LIST
66855: LIST
66856: PPUSH
66857: CALL_OW 72
66861: AND
66862: IFFALSE 66892
66864: PUSH
66865: LD_EXP 63
66869: PUSH
66870: LD_VAR 0 1
66874: ARRAY
66875: PPUSH
66876: LD_INT 30
66878: PUSH
66879: LD_INT 3
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PPUSH
66886: CALL_OW 72
66890: NOT
66891: AND
66892: IFFALSE 67108
// begin if sci >= 6 then
66894: LD_VAR 0 8
66898: PUSH
66899: LD_INT 6
66901: GREATEREQUAL
66902: IFFALSE 66906
// exit ;
66904: GO 69357
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66906: LD_ADDR_EXP 105
66910: PUSH
66911: LD_EXP 105
66915: PPUSH
66916: LD_VAR 0 1
66920: PPUSH
66921: LD_INT 2
66923: PPUSH
66924: CALL_OW 1
66928: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66929: LD_ADDR_VAR 0 9
66933: PUSH
66934: LD_VAR 0 4
66938: PUSH
66939: LD_VAR 0 8
66943: DIFF
66944: PPUSH
66945: LD_INT 4
66947: PPUSH
66948: CALL 54092 0 2
66952: ST_TO_ADDR
// p := [ ] ;
66953: LD_ADDR_VAR 0 11
66957: PUSH
66958: EMPTY
66959: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66960: LD_VAR 0 8
66964: PUSH
66965: LD_INT 6
66967: LESS
66968: IFFALSE 66980
66970: PUSH
66971: LD_VAR 0 9
66975: PUSH
66976: LD_INT 6
66978: GREATER
66979: AND
66980: IFFALSE 67061
// begin for i = 1 to 6 - sci do
66982: LD_ADDR_VAR 0 3
66986: PUSH
66987: DOUBLE
66988: LD_INT 1
66990: DEC
66991: ST_TO_ADDR
66992: LD_INT 6
66994: PUSH
66995: LD_VAR 0 8
66999: MINUS
67000: PUSH
67001: FOR_TO
67002: IFFALSE 67057
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
67004: LD_ADDR_VAR 0 11
67008: PUSH
67009: LD_VAR 0 11
67013: PPUSH
67014: LD_VAR 0 11
67018: PUSH
67019: LD_INT 1
67021: PLUS
67022: PPUSH
67023: LD_VAR 0 9
67027: PUSH
67028: LD_INT 1
67030: ARRAY
67031: PPUSH
67032: CALL_OW 2
67036: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
67037: LD_ADDR_VAR 0 9
67041: PUSH
67042: LD_VAR 0 9
67046: PPUSH
67047: LD_INT 1
67049: PPUSH
67050: CALL_OW 3
67054: ST_TO_ADDR
// end ;
67055: GO 67001
67057: POP
67058: POP
// end else
67059: GO 67081
// if sort then
67061: LD_VAR 0 9
67065: IFFALSE 67081
// p := sort [ 1 ] ;
67067: LD_ADDR_VAR 0 11
67071: PUSH
67072: LD_VAR 0 9
67076: PUSH
67077: LD_INT 1
67079: ARRAY
67080: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67081: LD_ADDR_VAR 0 2
67085: PUSH
67086: LD_INT 0
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 0
67094: PUSH
67095: LD_VAR 0 11
67099: PUSH
67100: EMPTY
67101: LIST
67102: LIST
67103: LIST
67104: LIST
67105: ST_TO_ADDR
// exit ;
67106: GO 69357
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67108: LD_EXP 90
67112: PUSH
67113: LD_EXP 89
67117: PUSH
67118: LD_VAR 0 1
67122: ARRAY
67123: ARRAY
67124: IFFALSE 67182
67126: PUSH
67127: LD_EXP 63
67131: PUSH
67132: LD_VAR 0 1
67136: ARRAY
67137: PPUSH
67138: LD_INT 2
67140: PUSH
67141: LD_INT 30
67143: PUSH
67144: LD_INT 6
67146: PUSH
67147: EMPTY
67148: LIST
67149: LIST
67150: PUSH
67151: LD_INT 30
67153: PUSH
67154: LD_INT 7
67156: PUSH
67157: EMPTY
67158: LIST
67159: LIST
67160: PUSH
67161: LD_INT 30
67163: PUSH
67164: LD_INT 8
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: LIST
67175: LIST
67176: PPUSH
67177: CALL_OW 72
67181: AND
67182: IFFALSE 67211
67184: PUSH
67185: LD_EXP 63
67189: PUSH
67190: LD_VAR 0 1
67194: ARRAY
67195: PPUSH
67196: LD_INT 30
67198: PUSH
67199: LD_INT 3
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PPUSH
67206: CALL_OW 72
67210: AND
67211: IFFALSE 67951
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67213: LD_ADDR_EXP 105
67217: PUSH
67218: LD_EXP 105
67222: PPUSH
67223: LD_VAR 0 1
67227: PPUSH
67228: LD_INT 3
67230: PPUSH
67231: CALL_OW 1
67235: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67236: LD_ADDR_VAR 0 2
67240: PUSH
67241: LD_INT 0
67243: PUSH
67244: LD_INT 0
67246: PUSH
67247: LD_INT 0
67249: PUSH
67250: LD_INT 0
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: LIST
67257: LIST
67258: ST_TO_ADDR
// if not eng then
67259: LD_VAR 0 6
67263: NOT
67264: IFFALSE 67327
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67266: LD_ADDR_VAR 0 11
67270: PUSH
67271: LD_VAR 0 4
67275: PPUSH
67276: LD_INT 2
67278: PPUSH
67279: CALL 54092 0 2
67283: PUSH
67284: LD_INT 1
67286: ARRAY
67287: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67288: LD_ADDR_VAR 0 2
67292: PUSH
67293: LD_VAR 0 2
67297: PPUSH
67298: LD_INT 2
67300: PPUSH
67301: LD_VAR 0 11
67305: PPUSH
67306: CALL_OW 1
67310: ST_TO_ADDR
// tmp := tmp diff p ;
67311: LD_ADDR_VAR 0 4
67315: PUSH
67316: LD_VAR 0 4
67320: PUSH
67321: LD_VAR 0 11
67325: DIFF
67326: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67327: LD_VAR 0 4
67331: IFFALSE 67343
67333: PUSH
67334: LD_VAR 0 8
67338: PUSH
67339: LD_INT 6
67341: LESS
67342: AND
67343: IFFALSE 67531
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67345: LD_ADDR_VAR 0 9
67349: PUSH
67350: LD_VAR 0 4
67354: PUSH
67355: LD_VAR 0 8
67359: PUSH
67360: LD_VAR 0 7
67364: UNION
67365: DIFF
67366: PPUSH
67367: LD_INT 4
67369: PPUSH
67370: CALL 54092 0 2
67374: ST_TO_ADDR
// p := [ ] ;
67375: LD_ADDR_VAR 0 11
67379: PUSH
67380: EMPTY
67381: ST_TO_ADDR
// if sort then
67382: LD_VAR 0 9
67386: IFFALSE 67502
// for i = 1 to 6 - sci do
67388: LD_ADDR_VAR 0 3
67392: PUSH
67393: DOUBLE
67394: LD_INT 1
67396: DEC
67397: ST_TO_ADDR
67398: LD_INT 6
67400: PUSH
67401: LD_VAR 0 8
67405: MINUS
67406: PUSH
67407: FOR_TO
67408: IFFALSE 67500
// begin if i = sort then
67410: LD_VAR 0 3
67414: PUSH
67415: LD_VAR 0 9
67419: EQUAL
67420: IFFALSE 67424
// break ;
67422: GO 67500
// if GetClass ( i ) = 4 then
67424: LD_VAR 0 3
67428: PPUSH
67429: CALL_OW 257
67433: PUSH
67434: LD_INT 4
67436: EQUAL
67437: IFFALSE 67441
// continue ;
67439: GO 67407
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67441: LD_ADDR_VAR 0 11
67445: PUSH
67446: LD_VAR 0 11
67450: PPUSH
67451: LD_VAR 0 11
67455: PUSH
67456: LD_INT 1
67458: PLUS
67459: PPUSH
67460: LD_VAR 0 9
67464: PUSH
67465: LD_VAR 0 3
67469: ARRAY
67470: PPUSH
67471: CALL_OW 2
67475: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67476: LD_ADDR_VAR 0 4
67480: PUSH
67481: LD_VAR 0 4
67485: PUSH
67486: LD_VAR 0 9
67490: PUSH
67491: LD_VAR 0 3
67495: ARRAY
67496: DIFF
67497: ST_TO_ADDR
// end ;
67498: GO 67407
67500: POP
67501: POP
// if p then
67502: LD_VAR 0 11
67506: IFFALSE 67531
// result := Replace ( result , 4 , p ) ;
67508: LD_ADDR_VAR 0 2
67512: PUSH
67513: LD_VAR 0 2
67517: PPUSH
67518: LD_INT 4
67520: PPUSH
67521: LD_VAR 0 11
67525: PPUSH
67526: CALL_OW 1
67530: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67531: LD_VAR 0 4
67535: IFFALSE 67547
67537: PUSH
67538: LD_VAR 0 7
67542: PUSH
67543: LD_INT 6
67545: LESS
67546: AND
67547: IFFALSE 67735
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67549: LD_ADDR_VAR 0 9
67553: PUSH
67554: LD_VAR 0 4
67558: PUSH
67559: LD_VAR 0 8
67563: PUSH
67564: LD_VAR 0 7
67568: UNION
67569: DIFF
67570: PPUSH
67571: LD_INT 3
67573: PPUSH
67574: CALL 54092 0 2
67578: ST_TO_ADDR
// p := [ ] ;
67579: LD_ADDR_VAR 0 11
67583: PUSH
67584: EMPTY
67585: ST_TO_ADDR
// if sort then
67586: LD_VAR 0 9
67590: IFFALSE 67706
// for i = 1 to 6 - mech do
67592: LD_ADDR_VAR 0 3
67596: PUSH
67597: DOUBLE
67598: LD_INT 1
67600: DEC
67601: ST_TO_ADDR
67602: LD_INT 6
67604: PUSH
67605: LD_VAR 0 7
67609: MINUS
67610: PUSH
67611: FOR_TO
67612: IFFALSE 67704
// begin if i = sort then
67614: LD_VAR 0 3
67618: PUSH
67619: LD_VAR 0 9
67623: EQUAL
67624: IFFALSE 67628
// break ;
67626: GO 67704
// if GetClass ( i ) = 3 then
67628: LD_VAR 0 3
67632: PPUSH
67633: CALL_OW 257
67637: PUSH
67638: LD_INT 3
67640: EQUAL
67641: IFFALSE 67645
// continue ;
67643: GO 67611
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67645: LD_ADDR_VAR 0 11
67649: PUSH
67650: LD_VAR 0 11
67654: PPUSH
67655: LD_VAR 0 11
67659: PUSH
67660: LD_INT 1
67662: PLUS
67663: PPUSH
67664: LD_VAR 0 9
67668: PUSH
67669: LD_VAR 0 3
67673: ARRAY
67674: PPUSH
67675: CALL_OW 2
67679: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67680: LD_ADDR_VAR 0 4
67684: PUSH
67685: LD_VAR 0 4
67689: PUSH
67690: LD_VAR 0 9
67694: PUSH
67695: LD_VAR 0 3
67699: ARRAY
67700: DIFF
67701: ST_TO_ADDR
// end ;
67702: GO 67611
67704: POP
67705: POP
// if p then
67706: LD_VAR 0 11
67710: IFFALSE 67735
// result := Replace ( result , 3 , p ) ;
67712: LD_ADDR_VAR 0 2
67716: PUSH
67717: LD_VAR 0 2
67721: PPUSH
67722: LD_INT 3
67724: PPUSH
67725: LD_VAR 0 11
67729: PPUSH
67730: CALL_OW 1
67734: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67735: LD_VAR 0 4
67739: PUSH
67740: LD_INT 6
67742: GREATER
67743: IFFALSE 67755
67745: PUSH
67746: LD_VAR 0 6
67750: PUSH
67751: LD_INT 6
67753: LESS
67754: AND
67755: IFFALSE 67949
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67757: LD_ADDR_VAR 0 9
67761: PUSH
67762: LD_VAR 0 4
67766: PUSH
67767: LD_VAR 0 8
67771: PUSH
67772: LD_VAR 0 7
67776: UNION
67777: PUSH
67778: LD_VAR 0 6
67782: UNION
67783: DIFF
67784: PPUSH
67785: LD_INT 2
67787: PPUSH
67788: CALL 54092 0 2
67792: ST_TO_ADDR
// p := [ ] ;
67793: LD_ADDR_VAR 0 11
67797: PUSH
67798: EMPTY
67799: ST_TO_ADDR
// if sort then
67800: LD_VAR 0 9
67804: IFFALSE 67920
// for i = 1 to 6 - eng do
67806: LD_ADDR_VAR 0 3
67810: PUSH
67811: DOUBLE
67812: LD_INT 1
67814: DEC
67815: ST_TO_ADDR
67816: LD_INT 6
67818: PUSH
67819: LD_VAR 0 6
67823: MINUS
67824: PUSH
67825: FOR_TO
67826: IFFALSE 67918
// begin if i = sort then
67828: LD_VAR 0 3
67832: PUSH
67833: LD_VAR 0 9
67837: EQUAL
67838: IFFALSE 67842
// break ;
67840: GO 67918
// if GetClass ( i ) = 2 then
67842: LD_VAR 0 3
67846: PPUSH
67847: CALL_OW 257
67851: PUSH
67852: LD_INT 2
67854: EQUAL
67855: IFFALSE 67859
// continue ;
67857: GO 67825
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67859: LD_ADDR_VAR 0 11
67863: PUSH
67864: LD_VAR 0 11
67868: PPUSH
67869: LD_VAR 0 11
67873: PUSH
67874: LD_INT 1
67876: PLUS
67877: PPUSH
67878: LD_VAR 0 9
67882: PUSH
67883: LD_VAR 0 3
67887: ARRAY
67888: PPUSH
67889: CALL_OW 2
67893: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67894: LD_ADDR_VAR 0 4
67898: PUSH
67899: LD_VAR 0 4
67903: PUSH
67904: LD_VAR 0 9
67908: PUSH
67909: LD_VAR 0 3
67913: ARRAY
67914: DIFF
67915: ST_TO_ADDR
// end ;
67916: GO 67825
67918: POP
67919: POP
// if p then
67920: LD_VAR 0 11
67924: IFFALSE 67949
// result := Replace ( result , 2 , p ) ;
67926: LD_ADDR_VAR 0 2
67930: PUSH
67931: LD_VAR 0 2
67935: PPUSH
67936: LD_INT 2
67938: PPUSH
67939: LD_VAR 0 11
67943: PPUSH
67944: CALL_OW 1
67948: ST_TO_ADDR
// end ; exit ;
67949: GO 69357
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67951: LD_EXP 90
67955: PUSH
67956: LD_EXP 89
67960: PUSH
67961: LD_VAR 0 1
67965: ARRAY
67966: ARRAY
67967: NOT
67968: IFFALSE 67997
67970: PUSH
67971: LD_EXP 63
67975: PUSH
67976: LD_VAR 0 1
67980: ARRAY
67981: PPUSH
67982: LD_INT 30
67984: PUSH
67985: LD_INT 3
67987: PUSH
67988: EMPTY
67989: LIST
67990: LIST
67991: PPUSH
67992: CALL_OW 72
67996: AND
67997: IFFALSE 68011
67999: PUSH
68000: LD_EXP 68
68004: PUSH
68005: LD_VAR 0 1
68009: ARRAY
68010: AND
68011: IFFALSE 68625
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
68013: LD_ADDR_EXP 105
68017: PUSH
68018: LD_EXP 105
68022: PPUSH
68023: LD_VAR 0 1
68027: PPUSH
68028: LD_INT 5
68030: PPUSH
68031: CALL_OW 1
68035: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68036: LD_ADDR_VAR 0 2
68040: PUSH
68041: LD_INT 0
68043: PUSH
68044: LD_INT 0
68046: PUSH
68047: LD_INT 0
68049: PUSH
68050: LD_INT 0
68052: PUSH
68053: EMPTY
68054: LIST
68055: LIST
68056: LIST
68057: LIST
68058: ST_TO_ADDR
// if sci > 1 then
68059: LD_VAR 0 8
68063: PUSH
68064: LD_INT 1
68066: GREATER
68067: IFFALSE 68095
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68069: LD_ADDR_VAR 0 4
68073: PUSH
68074: LD_VAR 0 4
68078: PUSH
68079: LD_VAR 0 8
68083: PUSH
68084: LD_VAR 0 8
68088: PUSH
68089: LD_INT 1
68091: ARRAY
68092: DIFF
68093: DIFF
68094: ST_TO_ADDR
// if tmp and not sci then
68095: LD_VAR 0 4
68099: IFFALSE 68108
68101: PUSH
68102: LD_VAR 0 8
68106: NOT
68107: AND
68108: IFFALSE 68177
// begin sort := SortBySkill ( tmp , 4 ) ;
68110: LD_ADDR_VAR 0 9
68114: PUSH
68115: LD_VAR 0 4
68119: PPUSH
68120: LD_INT 4
68122: PPUSH
68123: CALL 54092 0 2
68127: ST_TO_ADDR
// if sort then
68128: LD_VAR 0 9
68132: IFFALSE 68148
// p := sort [ 1 ] ;
68134: LD_ADDR_VAR 0 11
68138: PUSH
68139: LD_VAR 0 9
68143: PUSH
68144: LD_INT 1
68146: ARRAY
68147: ST_TO_ADDR
// if p then
68148: LD_VAR 0 11
68152: IFFALSE 68177
// result := Replace ( result , 4 , p ) ;
68154: LD_ADDR_VAR 0 2
68158: PUSH
68159: LD_VAR 0 2
68163: PPUSH
68164: LD_INT 4
68166: PPUSH
68167: LD_VAR 0 11
68171: PPUSH
68172: CALL_OW 1
68176: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68177: LD_ADDR_VAR 0 4
68181: PUSH
68182: LD_VAR 0 4
68186: PUSH
68187: LD_VAR 0 7
68191: DIFF
68192: ST_TO_ADDR
// if tmp and mech < 6 then
68193: LD_VAR 0 4
68197: IFFALSE 68209
68199: PUSH
68200: LD_VAR 0 7
68204: PUSH
68205: LD_INT 6
68207: LESS
68208: AND
68209: IFFALSE 68397
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68211: LD_ADDR_VAR 0 9
68215: PUSH
68216: LD_VAR 0 4
68220: PUSH
68221: LD_VAR 0 8
68225: PUSH
68226: LD_VAR 0 7
68230: UNION
68231: DIFF
68232: PPUSH
68233: LD_INT 3
68235: PPUSH
68236: CALL 54092 0 2
68240: ST_TO_ADDR
// p := [ ] ;
68241: LD_ADDR_VAR 0 11
68245: PUSH
68246: EMPTY
68247: ST_TO_ADDR
// if sort then
68248: LD_VAR 0 9
68252: IFFALSE 68368
// for i = 1 to 6 - mech do
68254: LD_ADDR_VAR 0 3
68258: PUSH
68259: DOUBLE
68260: LD_INT 1
68262: DEC
68263: ST_TO_ADDR
68264: LD_INT 6
68266: PUSH
68267: LD_VAR 0 7
68271: MINUS
68272: PUSH
68273: FOR_TO
68274: IFFALSE 68366
// begin if i = sort then
68276: LD_VAR 0 3
68280: PUSH
68281: LD_VAR 0 9
68285: EQUAL
68286: IFFALSE 68290
// break ;
68288: GO 68366
// if GetClass ( i ) = 3 then
68290: LD_VAR 0 3
68294: PPUSH
68295: CALL_OW 257
68299: PUSH
68300: LD_INT 3
68302: EQUAL
68303: IFFALSE 68307
// continue ;
68305: GO 68273
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68307: LD_ADDR_VAR 0 11
68311: PUSH
68312: LD_VAR 0 11
68316: PPUSH
68317: LD_VAR 0 11
68321: PUSH
68322: LD_INT 1
68324: PLUS
68325: PPUSH
68326: LD_VAR 0 9
68330: PUSH
68331: LD_VAR 0 3
68335: ARRAY
68336: PPUSH
68337: CALL_OW 2
68341: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68342: LD_ADDR_VAR 0 4
68346: PUSH
68347: LD_VAR 0 4
68351: PUSH
68352: LD_VAR 0 9
68356: PUSH
68357: LD_VAR 0 3
68361: ARRAY
68362: DIFF
68363: ST_TO_ADDR
// end ;
68364: GO 68273
68366: POP
68367: POP
// if p then
68368: LD_VAR 0 11
68372: IFFALSE 68397
// result := Replace ( result , 3 , p ) ;
68374: LD_ADDR_VAR 0 2
68378: PUSH
68379: LD_VAR 0 2
68383: PPUSH
68384: LD_INT 3
68386: PPUSH
68387: LD_VAR 0 11
68391: PPUSH
68392: CALL_OW 1
68396: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68397: LD_ADDR_VAR 0 4
68401: PUSH
68402: LD_VAR 0 4
68406: PUSH
68407: LD_VAR 0 6
68411: DIFF
68412: ST_TO_ADDR
// if tmp and eng < 6 then
68413: LD_VAR 0 4
68417: IFFALSE 68429
68419: PUSH
68420: LD_VAR 0 6
68424: PUSH
68425: LD_INT 6
68427: LESS
68428: AND
68429: IFFALSE 68623
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68431: LD_ADDR_VAR 0 9
68435: PUSH
68436: LD_VAR 0 4
68440: PUSH
68441: LD_VAR 0 8
68445: PUSH
68446: LD_VAR 0 7
68450: UNION
68451: PUSH
68452: LD_VAR 0 6
68456: UNION
68457: DIFF
68458: PPUSH
68459: LD_INT 2
68461: PPUSH
68462: CALL 54092 0 2
68466: ST_TO_ADDR
// p := [ ] ;
68467: LD_ADDR_VAR 0 11
68471: PUSH
68472: EMPTY
68473: ST_TO_ADDR
// if sort then
68474: LD_VAR 0 9
68478: IFFALSE 68594
// for i = 1 to 6 - eng do
68480: LD_ADDR_VAR 0 3
68484: PUSH
68485: DOUBLE
68486: LD_INT 1
68488: DEC
68489: ST_TO_ADDR
68490: LD_INT 6
68492: PUSH
68493: LD_VAR 0 6
68497: MINUS
68498: PUSH
68499: FOR_TO
68500: IFFALSE 68592
// begin if i = sort then
68502: LD_VAR 0 3
68506: PUSH
68507: LD_VAR 0 9
68511: EQUAL
68512: IFFALSE 68516
// break ;
68514: GO 68592
// if GetClass ( i ) = 2 then
68516: LD_VAR 0 3
68520: PPUSH
68521: CALL_OW 257
68525: PUSH
68526: LD_INT 2
68528: EQUAL
68529: IFFALSE 68533
// continue ;
68531: GO 68499
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68533: LD_ADDR_VAR 0 11
68537: PUSH
68538: LD_VAR 0 11
68542: PPUSH
68543: LD_VAR 0 11
68547: PUSH
68548: LD_INT 1
68550: PLUS
68551: PPUSH
68552: LD_VAR 0 9
68556: PUSH
68557: LD_VAR 0 3
68561: ARRAY
68562: PPUSH
68563: CALL_OW 2
68567: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68568: LD_ADDR_VAR 0 4
68572: PUSH
68573: LD_VAR 0 4
68577: PUSH
68578: LD_VAR 0 9
68582: PUSH
68583: LD_VAR 0 3
68587: ARRAY
68588: DIFF
68589: ST_TO_ADDR
// end ;
68590: GO 68499
68592: POP
68593: POP
// if p then
68594: LD_VAR 0 11
68598: IFFALSE 68623
// result := Replace ( result , 2 , p ) ;
68600: LD_ADDR_VAR 0 2
68604: PUSH
68605: LD_VAR 0 2
68609: PPUSH
68610: LD_INT 2
68612: PPUSH
68613: LD_VAR 0 11
68617: PPUSH
68618: CALL_OW 1
68622: ST_TO_ADDR
// end ; exit ;
68623: GO 69357
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68625: LD_EXP 90
68629: PUSH
68630: LD_EXP 89
68634: PUSH
68635: LD_VAR 0 1
68639: ARRAY
68640: ARRAY
68641: NOT
68642: IFFALSE 68671
68644: PUSH
68645: LD_EXP 63
68649: PUSH
68650: LD_VAR 0 1
68654: ARRAY
68655: PPUSH
68656: LD_INT 30
68658: PUSH
68659: LD_INT 3
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PPUSH
68666: CALL_OW 72
68670: AND
68671: IFFALSE 68686
68673: PUSH
68674: LD_EXP 68
68678: PUSH
68679: LD_VAR 0 1
68683: ARRAY
68684: NOT
68685: AND
68686: IFFALSE 69357
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68688: LD_ADDR_EXP 105
68692: PUSH
68693: LD_EXP 105
68697: PPUSH
68698: LD_VAR 0 1
68702: PPUSH
68703: LD_INT 6
68705: PPUSH
68706: CALL_OW 1
68710: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68711: LD_ADDR_VAR 0 2
68715: PUSH
68716: LD_INT 0
68718: PUSH
68719: LD_INT 0
68721: PUSH
68722: LD_INT 0
68724: PUSH
68725: LD_INT 0
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: LIST
68732: LIST
68733: ST_TO_ADDR
// if sci >= 1 then
68734: LD_VAR 0 8
68738: PUSH
68739: LD_INT 1
68741: GREATEREQUAL
68742: IFFALSE 68764
// tmp := tmp diff sci [ 1 ] ;
68744: LD_ADDR_VAR 0 4
68748: PUSH
68749: LD_VAR 0 4
68753: PUSH
68754: LD_VAR 0 8
68758: PUSH
68759: LD_INT 1
68761: ARRAY
68762: DIFF
68763: ST_TO_ADDR
// if tmp and not sci then
68764: LD_VAR 0 4
68768: IFFALSE 68777
68770: PUSH
68771: LD_VAR 0 8
68775: NOT
68776: AND
68777: IFFALSE 68846
// begin sort := SortBySkill ( tmp , 4 ) ;
68779: LD_ADDR_VAR 0 9
68783: PUSH
68784: LD_VAR 0 4
68788: PPUSH
68789: LD_INT 4
68791: PPUSH
68792: CALL 54092 0 2
68796: ST_TO_ADDR
// if sort then
68797: LD_VAR 0 9
68801: IFFALSE 68817
// p := sort [ 1 ] ;
68803: LD_ADDR_VAR 0 11
68807: PUSH
68808: LD_VAR 0 9
68812: PUSH
68813: LD_INT 1
68815: ARRAY
68816: ST_TO_ADDR
// if p then
68817: LD_VAR 0 11
68821: IFFALSE 68846
// result := Replace ( result , 4 , p ) ;
68823: LD_ADDR_VAR 0 2
68827: PUSH
68828: LD_VAR 0 2
68832: PPUSH
68833: LD_INT 4
68835: PPUSH
68836: LD_VAR 0 11
68840: PPUSH
68841: CALL_OW 1
68845: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68846: LD_ADDR_VAR 0 4
68850: PUSH
68851: LD_VAR 0 4
68855: PUSH
68856: LD_VAR 0 7
68860: DIFF
68861: ST_TO_ADDR
// if tmp and mech < 6 then
68862: LD_VAR 0 4
68866: IFFALSE 68878
68868: PUSH
68869: LD_VAR 0 7
68873: PUSH
68874: LD_INT 6
68876: LESS
68877: AND
68878: IFFALSE 69060
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
68880: LD_ADDR_VAR 0 9
68884: PUSH
68885: LD_VAR 0 4
68889: PUSH
68890: LD_VAR 0 7
68894: DIFF
68895: PPUSH
68896: LD_INT 3
68898: PPUSH
68899: CALL 54092 0 2
68903: ST_TO_ADDR
// p := [ ] ;
68904: LD_ADDR_VAR 0 11
68908: PUSH
68909: EMPTY
68910: ST_TO_ADDR
// if sort then
68911: LD_VAR 0 9
68915: IFFALSE 69031
// for i = 1 to 6 - mech do
68917: LD_ADDR_VAR 0 3
68921: PUSH
68922: DOUBLE
68923: LD_INT 1
68925: DEC
68926: ST_TO_ADDR
68927: LD_INT 6
68929: PUSH
68930: LD_VAR 0 7
68934: MINUS
68935: PUSH
68936: FOR_TO
68937: IFFALSE 69029
// begin if i = sort then
68939: LD_VAR 0 3
68943: PUSH
68944: LD_VAR 0 9
68948: EQUAL
68949: IFFALSE 68953
// break ;
68951: GO 69029
// if GetClass ( i ) = 3 then
68953: LD_VAR 0 3
68957: PPUSH
68958: CALL_OW 257
68962: PUSH
68963: LD_INT 3
68965: EQUAL
68966: IFFALSE 68970
// continue ;
68968: GO 68936
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68970: LD_ADDR_VAR 0 11
68974: PUSH
68975: LD_VAR 0 11
68979: PPUSH
68980: LD_VAR 0 11
68984: PUSH
68985: LD_INT 1
68987: PLUS
68988: PPUSH
68989: LD_VAR 0 9
68993: PUSH
68994: LD_VAR 0 3
68998: ARRAY
68999: PPUSH
69000: CALL_OW 2
69004: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69005: LD_ADDR_VAR 0 4
69009: PUSH
69010: LD_VAR 0 4
69014: PUSH
69015: LD_VAR 0 9
69019: PUSH
69020: LD_VAR 0 3
69024: ARRAY
69025: DIFF
69026: ST_TO_ADDR
// end ;
69027: GO 68936
69029: POP
69030: POP
// if p then
69031: LD_VAR 0 11
69035: IFFALSE 69060
// result := Replace ( result , 3 , p ) ;
69037: LD_ADDR_VAR 0 2
69041: PUSH
69042: LD_VAR 0 2
69046: PPUSH
69047: LD_INT 3
69049: PPUSH
69050: LD_VAR 0 11
69054: PPUSH
69055: CALL_OW 1
69059: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69060: LD_ADDR_VAR 0 4
69064: PUSH
69065: LD_VAR 0 4
69069: PUSH
69070: LD_VAR 0 6
69074: DIFF
69075: ST_TO_ADDR
// if tmp and eng < 4 then
69076: LD_VAR 0 4
69080: IFFALSE 69092
69082: PUSH
69083: LD_VAR 0 6
69087: PUSH
69088: LD_INT 4
69090: LESS
69091: AND
69092: IFFALSE 69282
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69094: LD_ADDR_VAR 0 9
69098: PUSH
69099: LD_VAR 0 4
69103: PUSH
69104: LD_VAR 0 7
69108: PUSH
69109: LD_VAR 0 6
69113: UNION
69114: DIFF
69115: PPUSH
69116: LD_INT 2
69118: PPUSH
69119: CALL 54092 0 2
69123: ST_TO_ADDR
// p := [ ] ;
69124: LD_ADDR_VAR 0 11
69128: PUSH
69129: EMPTY
69130: ST_TO_ADDR
// if sort then
69131: LD_VAR 0 9
69135: IFFALSE 69251
// for i = 1 to 4 - eng do
69137: LD_ADDR_VAR 0 3
69141: PUSH
69142: DOUBLE
69143: LD_INT 1
69145: DEC
69146: ST_TO_ADDR
69147: LD_INT 4
69149: PUSH
69150: LD_VAR 0 6
69154: MINUS
69155: PUSH
69156: FOR_TO
69157: IFFALSE 69249
// begin if i = sort then
69159: LD_VAR 0 3
69163: PUSH
69164: LD_VAR 0 9
69168: EQUAL
69169: IFFALSE 69173
// break ;
69171: GO 69249
// if GetClass ( i ) = 2 then
69173: LD_VAR 0 3
69177: PPUSH
69178: CALL_OW 257
69182: PUSH
69183: LD_INT 2
69185: EQUAL
69186: IFFALSE 69190
// continue ;
69188: GO 69156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69190: LD_ADDR_VAR 0 11
69194: PUSH
69195: LD_VAR 0 11
69199: PPUSH
69200: LD_VAR 0 11
69204: PUSH
69205: LD_INT 1
69207: PLUS
69208: PPUSH
69209: LD_VAR 0 9
69213: PUSH
69214: LD_VAR 0 3
69218: ARRAY
69219: PPUSH
69220: CALL_OW 2
69224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69225: LD_ADDR_VAR 0 4
69229: PUSH
69230: LD_VAR 0 4
69234: PUSH
69235: LD_VAR 0 9
69239: PUSH
69240: LD_VAR 0 3
69244: ARRAY
69245: DIFF
69246: ST_TO_ADDR
// end ;
69247: GO 69156
69249: POP
69250: POP
// if p then
69251: LD_VAR 0 11
69255: IFFALSE 69280
// result := Replace ( result , 2 , p ) ;
69257: LD_ADDR_VAR 0 2
69261: PUSH
69262: LD_VAR 0 2
69266: PPUSH
69267: LD_INT 2
69269: PPUSH
69270: LD_VAR 0 11
69274: PPUSH
69275: CALL_OW 1
69279: ST_TO_ADDR
// end else
69280: GO 69326
// for i = eng downto 5 do
69282: LD_ADDR_VAR 0 3
69286: PUSH
69287: DOUBLE
69288: LD_VAR 0 6
69292: INC
69293: ST_TO_ADDR
69294: LD_INT 5
69296: PUSH
69297: FOR_DOWNTO
69298: IFFALSE 69324
// tmp := tmp union eng [ i ] ;
69300: LD_ADDR_VAR 0 4
69304: PUSH
69305: LD_VAR 0 4
69309: PUSH
69310: LD_VAR 0 6
69314: PUSH
69315: LD_VAR 0 3
69319: ARRAY
69320: UNION
69321: ST_TO_ADDR
69322: GO 69297
69324: POP
69325: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69326: LD_ADDR_VAR 0 2
69330: PUSH
69331: LD_VAR 0 2
69335: PPUSH
69336: LD_INT 1
69338: PPUSH
69339: LD_VAR 0 4
69343: PUSH
69344: LD_VAR 0 5
69348: DIFF
69349: PPUSH
69350: CALL_OW 1
69354: ST_TO_ADDR
// exit ;
69355: GO 69357
// end ; end ;
69357: LD_VAR 0 2
69361: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69362: LD_INT 0
69364: PPUSH
69365: PPUSH
69366: PPUSH
// if not mc_bases then
69367: LD_EXP 63
69371: NOT
69372: IFFALSE 69376
// exit ;
69374: GO 69518
// for i = 1 to mc_bases do
69376: LD_ADDR_VAR 0 2
69380: PUSH
69381: DOUBLE
69382: LD_INT 1
69384: DEC
69385: ST_TO_ADDR
69386: LD_EXP 63
69390: PUSH
69391: FOR_TO
69392: IFFALSE 69509
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69394: LD_ADDR_VAR 0 3
69398: PUSH
69399: LD_EXP 63
69403: PUSH
69404: LD_VAR 0 2
69408: ARRAY
69409: PPUSH
69410: LD_INT 21
69412: PUSH
69413: LD_INT 3
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: PUSH
69420: LD_INT 3
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 30
69428: PUSH
69429: LD_INT 29
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 30
69438: PUSH
69439: LD_INT 30
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: LIST
69450: PUSH
69451: EMPTY
69452: LIST
69453: LIST
69454: PUSH
69455: LD_INT 3
69457: PUSH
69458: LD_INT 24
69460: PUSH
69461: LD_INT 1000
69463: PUSH
69464: EMPTY
69465: LIST
69466: LIST
69467: PUSH
69468: EMPTY
69469: LIST
69470: LIST
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: LIST
69476: PPUSH
69477: CALL_OW 72
69481: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69482: LD_ADDR_EXP 64
69486: PUSH
69487: LD_EXP 64
69491: PPUSH
69492: LD_VAR 0 2
69496: PPUSH
69497: LD_VAR 0 3
69501: PPUSH
69502: CALL_OW 1
69506: ST_TO_ADDR
// end ;
69507: GO 69391
69509: POP
69510: POP
// RaiseSailEvent ( 101 ) ;
69511: LD_INT 101
69513: PPUSH
69514: CALL_OW 427
// end ;
69518: LD_VAR 0 1
69522: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69523: LD_INT 0
69525: PPUSH
69526: PPUSH
69527: PPUSH
69528: PPUSH
69529: PPUSH
69530: PPUSH
69531: PPUSH
// if not mc_bases then
69532: LD_EXP 63
69536: NOT
69537: IFFALSE 69541
// exit ;
69539: GO 70105
// for i = 1 to mc_bases do
69541: LD_ADDR_VAR 0 2
69545: PUSH
69546: DOUBLE
69547: LD_INT 1
69549: DEC
69550: ST_TO_ADDR
69551: LD_EXP 63
69555: PUSH
69556: FOR_TO
69557: IFFALSE 70096
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69559: LD_ADDR_VAR 0 5
69563: PUSH
69564: LD_EXP 63
69568: PUSH
69569: LD_VAR 0 2
69573: ARRAY
69574: PUSH
69575: LD_EXP 92
69579: PUSH
69580: LD_VAR 0 2
69584: ARRAY
69585: UNION
69586: PPUSH
69587: LD_INT 21
69589: PUSH
69590: LD_INT 1
69592: PUSH
69593: EMPTY
69594: LIST
69595: LIST
69596: PUSH
69597: LD_INT 1
69599: PUSH
69600: LD_INT 3
69602: PUSH
69603: LD_INT 54
69605: PUSH
69606: EMPTY
69607: LIST
69608: PUSH
69609: EMPTY
69610: LIST
69611: LIST
69612: PUSH
69613: LD_INT 3
69615: PUSH
69616: LD_INT 24
69618: PUSH
69619: LD_INT 1000
69621: PUSH
69622: EMPTY
69623: LIST
69624: LIST
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: LIST
69634: PUSH
69635: EMPTY
69636: LIST
69637: LIST
69638: PPUSH
69639: CALL_OW 72
69643: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69644: LD_ADDR_VAR 0 6
69648: PUSH
69649: LD_EXP 63
69653: PUSH
69654: LD_VAR 0 2
69658: ARRAY
69659: PPUSH
69660: LD_INT 21
69662: PUSH
69663: LD_INT 1
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 1
69672: PUSH
69673: LD_INT 3
69675: PUSH
69676: LD_INT 54
69678: PUSH
69679: EMPTY
69680: LIST
69681: PUSH
69682: EMPTY
69683: LIST
69684: LIST
69685: PUSH
69686: LD_INT 3
69688: PUSH
69689: LD_INT 24
69691: PUSH
69692: LD_INT 250
69694: PUSH
69695: EMPTY
69696: LIST
69697: LIST
69698: PUSH
69699: EMPTY
69700: LIST
69701: LIST
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: LIST
69707: PUSH
69708: EMPTY
69709: LIST
69710: LIST
69711: PPUSH
69712: CALL_OW 72
69716: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69717: LD_ADDR_VAR 0 7
69721: PUSH
69722: LD_VAR 0 5
69726: PUSH
69727: LD_VAR 0 6
69731: DIFF
69732: ST_TO_ADDR
// if not need_heal_1 then
69733: LD_VAR 0 6
69737: NOT
69738: IFFALSE 69771
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69740: LD_ADDR_EXP 66
69744: PUSH
69745: LD_EXP 66
69749: PPUSH
69750: LD_VAR 0 2
69754: PUSH
69755: LD_INT 1
69757: PUSH
69758: EMPTY
69759: LIST
69760: LIST
69761: PPUSH
69762: EMPTY
69763: PPUSH
69764: CALL 22554 0 3
69768: ST_TO_ADDR
69769: GO 69841
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69771: LD_ADDR_EXP 66
69775: PUSH
69776: LD_EXP 66
69780: PPUSH
69781: LD_VAR 0 2
69785: PUSH
69786: LD_INT 1
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PPUSH
69793: LD_EXP 66
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: PUSH
69804: LD_INT 1
69806: ARRAY
69807: PPUSH
69808: LD_INT 3
69810: PUSH
69811: LD_INT 24
69813: PUSH
69814: LD_INT 1000
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PPUSH
69825: CALL_OW 72
69829: PUSH
69830: LD_VAR 0 6
69834: UNION
69835: PPUSH
69836: CALL 22554 0 3
69840: ST_TO_ADDR
// if not need_heal_2 then
69841: LD_VAR 0 7
69845: NOT
69846: IFFALSE 69879
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
69848: LD_ADDR_EXP 66
69852: PUSH
69853: LD_EXP 66
69857: PPUSH
69858: LD_VAR 0 2
69862: PUSH
69863: LD_INT 2
69865: PUSH
69866: EMPTY
69867: LIST
69868: LIST
69869: PPUSH
69870: EMPTY
69871: PPUSH
69872: CALL 22554 0 3
69876: ST_TO_ADDR
69877: GO 69911
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
69879: LD_ADDR_EXP 66
69883: PUSH
69884: LD_EXP 66
69888: PPUSH
69889: LD_VAR 0 2
69893: PUSH
69894: LD_INT 2
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PPUSH
69901: LD_VAR 0 7
69905: PPUSH
69906: CALL 22554 0 3
69910: ST_TO_ADDR
// if need_heal_2 then
69911: LD_VAR 0 7
69915: IFFALSE 70076
// for j in need_heal_2 do
69917: LD_ADDR_VAR 0 3
69921: PUSH
69922: LD_VAR 0 7
69926: PUSH
69927: FOR_IN
69928: IFFALSE 70074
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69930: LD_ADDR_VAR 0 5
69934: PUSH
69935: LD_EXP 63
69939: PUSH
69940: LD_VAR 0 2
69944: ARRAY
69945: PPUSH
69946: LD_INT 2
69948: PUSH
69949: LD_INT 30
69951: PUSH
69952: LD_INT 6
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 30
69961: PUSH
69962: LD_INT 7
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 30
69971: PUSH
69972: LD_INT 8
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 30
69981: PUSH
69982: LD_INT 0
69984: PUSH
69985: EMPTY
69986: LIST
69987: LIST
69988: PUSH
69989: LD_INT 30
69991: PUSH
69992: LD_INT 1
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: LIST
70003: LIST
70004: LIST
70005: LIST
70006: PPUSH
70007: CALL_OW 72
70011: ST_TO_ADDR
// if tmp then
70012: LD_VAR 0 5
70016: IFFALSE 70072
// begin k := NearestUnitToUnit ( tmp , j ) ;
70018: LD_ADDR_VAR 0 4
70022: PUSH
70023: LD_VAR 0 5
70027: PPUSH
70028: LD_VAR 0 3
70032: PPUSH
70033: CALL_OW 74
70037: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
70038: LD_VAR 0 3
70042: PPUSH
70043: LD_VAR 0 4
70047: PPUSH
70048: CALL_OW 296
70052: PUSH
70053: LD_INT 5
70055: GREATER
70056: IFFALSE 70072
// ComMoveToNearbyEntrance ( j , k ) ;
70058: LD_VAR 0 3
70062: PPUSH
70063: LD_VAR 0 4
70067: PPUSH
70068: CALL 56491 0 2
// end ; end ;
70072: GO 69927
70074: POP
70075: POP
// if not need_heal_1 and not need_heal_2 then
70076: LD_VAR 0 6
70080: NOT
70081: IFFALSE 70090
70083: PUSH
70084: LD_VAR 0 7
70088: NOT
70089: AND
70090: IFFALSE 70094
// continue ;
70092: GO 69556
// end ;
70094: GO 69556
70096: POP
70097: POP
// RaiseSailEvent ( 102 ) ;
70098: LD_INT 102
70100: PPUSH
70101: CALL_OW 427
// end ;
70105: LD_VAR 0 1
70109: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70110: LD_INT 0
70112: PPUSH
70113: PPUSH
70114: PPUSH
70115: PPUSH
70116: PPUSH
70117: PPUSH
70118: PPUSH
70119: PPUSH
// if not mc_bases then
70120: LD_EXP 63
70124: NOT
70125: IFFALSE 70129
// exit ;
70127: GO 71044
// for i = 1 to mc_bases do
70129: LD_ADDR_VAR 0 2
70133: PUSH
70134: DOUBLE
70135: LD_INT 1
70137: DEC
70138: ST_TO_ADDR
70139: LD_EXP 63
70143: PUSH
70144: FOR_TO
70145: IFFALSE 71042
// begin if not mc_building_need_repair [ i ] then
70147: LD_EXP 64
70151: PUSH
70152: LD_VAR 0 2
70156: ARRAY
70157: NOT
70158: IFFALSE 70343
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70160: LD_ADDR_VAR 0 6
70164: PUSH
70165: LD_EXP 82
70169: PUSH
70170: LD_VAR 0 2
70174: ARRAY
70175: PPUSH
70176: LD_INT 3
70178: PUSH
70179: LD_INT 24
70181: PUSH
70182: LD_INT 1000
70184: PUSH
70185: EMPTY
70186: LIST
70187: LIST
70188: PUSH
70189: EMPTY
70190: LIST
70191: LIST
70192: PUSH
70193: LD_INT 2
70195: PUSH
70196: LD_INT 34
70198: PUSH
70199: LD_INT 13
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 34
70208: PUSH
70209: LD_INT 52
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PUSH
70216: LD_INT 34
70218: PUSH
70219: LD_INT 88
70221: PUSH
70222: EMPTY
70223: LIST
70224: LIST
70225: PUSH
70226: EMPTY
70227: LIST
70228: LIST
70229: LIST
70230: LIST
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PPUSH
70236: CALL_OW 72
70240: ST_TO_ADDR
// if cranes then
70241: LD_VAR 0 6
70245: IFFALSE 70307
// for j in cranes do
70247: LD_ADDR_VAR 0 3
70251: PUSH
70252: LD_VAR 0 6
70256: PUSH
70257: FOR_IN
70258: IFFALSE 70305
// if not IsInArea ( j , mc_parking [ i ] ) then
70260: LD_VAR 0 3
70264: PPUSH
70265: LD_EXP 87
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: PPUSH
70276: CALL_OW 308
70280: NOT
70281: IFFALSE 70303
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70283: LD_VAR 0 3
70287: PPUSH
70288: LD_EXP 87
70292: PUSH
70293: LD_VAR 0 2
70297: ARRAY
70298: PPUSH
70299: CALL_OW 113
70303: GO 70257
70305: POP
70306: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70307: LD_ADDR_EXP 65
70311: PUSH
70312: LD_EXP 65
70316: PPUSH
70317: LD_VAR 0 2
70321: PPUSH
70322: EMPTY
70323: PPUSH
70324: CALL_OW 1
70328: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70329: LD_VAR 0 2
70333: PPUSH
70334: LD_INT 101
70336: PPUSH
70337: CALL 65135 0 2
// continue ;
70341: GO 70144
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70343: LD_ADDR_EXP 69
70347: PUSH
70348: LD_EXP 69
70352: PPUSH
70353: LD_VAR 0 2
70357: PPUSH
70358: EMPTY
70359: PPUSH
70360: CALL_OW 1
70364: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70365: LD_VAR 0 2
70369: PPUSH
70370: LD_INT 103
70372: PPUSH
70373: CALL 65135 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70377: LD_ADDR_VAR 0 5
70381: PUSH
70382: LD_EXP 63
70386: PUSH
70387: LD_VAR 0 2
70391: ARRAY
70392: PUSH
70393: LD_EXP 92
70397: PUSH
70398: LD_VAR 0 2
70402: ARRAY
70403: UNION
70404: PPUSH
70405: LD_INT 2
70407: PUSH
70408: LD_INT 25
70410: PUSH
70411: LD_INT 2
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 25
70420: PUSH
70421: LD_INT 16
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: EMPTY
70429: LIST
70430: LIST
70431: LIST
70432: PUSH
70433: EMPTY
70434: LIST
70435: PPUSH
70436: CALL_OW 72
70440: ST_TO_ADDR
// if mc_need_heal [ i ] then
70441: LD_EXP 66
70445: PUSH
70446: LD_VAR 0 2
70450: ARRAY
70451: IFFALSE 70495
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70453: LD_ADDR_VAR 0 5
70457: PUSH
70458: LD_VAR 0 5
70462: PUSH
70463: LD_EXP 66
70467: PUSH
70468: LD_VAR 0 2
70472: ARRAY
70473: PUSH
70474: LD_INT 1
70476: ARRAY
70477: PUSH
70478: LD_EXP 66
70482: PUSH
70483: LD_VAR 0 2
70487: ARRAY
70488: PUSH
70489: LD_INT 2
70491: ARRAY
70492: UNION
70493: DIFF
70494: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70495: LD_ADDR_VAR 0 6
70499: PUSH
70500: LD_EXP 82
70504: PUSH
70505: LD_VAR 0 2
70509: ARRAY
70510: PPUSH
70511: LD_INT 2
70513: PUSH
70514: LD_INT 34
70516: PUSH
70517: LD_INT 13
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 34
70526: PUSH
70527: LD_INT 52
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 34
70536: PUSH
70537: LD_INT 88
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: PPUSH
70550: CALL_OW 72
70554: ST_TO_ADDR
// if cranes then
70555: LD_VAR 0 6
70559: IFFALSE 70731
// begin for j in cranes do
70561: LD_ADDR_VAR 0 3
70565: PUSH
70566: LD_VAR 0 6
70570: PUSH
70571: FOR_IN
70572: IFFALSE 70729
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70574: LD_VAR 0 3
70578: PPUSH
70579: CALL_OW 256
70583: PUSH
70584: LD_INT 1000
70586: EQUAL
70587: IFFALSE 70601
70589: PUSH
70590: LD_VAR 0 3
70594: PPUSH
70595: CALL_OW 314
70599: NOT
70600: AND
70601: IFFALSE 70667
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70603: LD_ADDR_VAR 0 8
70607: PUSH
70608: LD_EXP 64
70612: PUSH
70613: LD_VAR 0 2
70617: ARRAY
70618: PPUSH
70619: LD_VAR 0 3
70623: PPUSH
70624: CALL_OW 74
70628: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70629: LD_VAR 0 8
70633: PPUSH
70634: LD_INT 16
70636: PPUSH
70637: CALL 25533 0 2
70641: PUSH
70642: LD_INT 4
70644: ARRAY
70645: PUSH
70646: LD_INT 10
70648: LESS
70649: IFFALSE 70665
// ComRepairBuilding ( j , to_repair ) ;
70651: LD_VAR 0 3
70655: PPUSH
70656: LD_VAR 0 8
70660: PPUSH
70661: CALL_OW 130
// end else
70665: GO 70727
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70667: LD_VAR 0 3
70671: PPUSH
70672: CALL_OW 256
70676: PUSH
70677: LD_INT 500
70679: LESS
70680: IFFALSE 70705
70682: PUSH
70683: LD_VAR 0 3
70687: PPUSH
70688: LD_EXP 87
70692: PUSH
70693: LD_VAR 0 2
70697: ARRAY
70698: PPUSH
70699: CALL_OW 308
70703: NOT
70704: AND
70705: IFFALSE 70727
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70707: LD_VAR 0 3
70711: PPUSH
70712: LD_EXP 87
70716: PUSH
70717: LD_VAR 0 2
70721: ARRAY
70722: PPUSH
70723: CALL_OW 113
// end ;
70727: GO 70571
70729: POP
70730: POP
// end ; if tmp > 3 then
70731: LD_VAR 0 5
70735: PUSH
70736: LD_INT 3
70738: GREATER
70739: IFFALSE 70759
// tmp := ShrinkArray ( tmp , 4 ) ;
70741: LD_ADDR_VAR 0 5
70745: PUSH
70746: LD_VAR 0 5
70750: PPUSH
70751: LD_INT 4
70753: PPUSH
70754: CALL 55927 0 2
70758: ST_TO_ADDR
// if not tmp then
70759: LD_VAR 0 5
70763: NOT
70764: IFFALSE 70768
// continue ;
70766: GO 70144
// for j in tmp do
70768: LD_ADDR_VAR 0 3
70772: PUSH
70773: LD_VAR 0 5
70777: PUSH
70778: FOR_IN
70779: IFFALSE 71038
// begin if IsInUnit ( j ) then
70781: LD_VAR 0 3
70785: PPUSH
70786: CALL_OW 310
70790: IFFALSE 70801
// ComExitBuilding ( j ) ;
70792: LD_VAR 0 3
70796: PPUSH
70797: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
70801: LD_VAR 0 3
70805: PUSH
70806: LD_EXP 65
70810: PUSH
70811: LD_VAR 0 2
70815: ARRAY
70816: IN
70817: NOT
70818: IFFALSE 70876
// begin SetTag ( j , 101 ) ;
70820: LD_VAR 0 3
70824: PPUSH
70825: LD_INT 101
70827: PPUSH
70828: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
70832: LD_ADDR_EXP 65
70836: PUSH
70837: LD_EXP 65
70841: PPUSH
70842: LD_VAR 0 2
70846: PUSH
70847: LD_EXP 65
70851: PUSH
70852: LD_VAR 0 2
70856: ARRAY
70857: PUSH
70858: LD_INT 1
70860: PLUS
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PPUSH
70866: LD_VAR 0 3
70870: PPUSH
70871: CALL 22554 0 3
70875: ST_TO_ADDR
// end ; wait ( 1 ) ;
70876: LD_INT 1
70878: PPUSH
70879: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
70883: LD_ADDR_VAR 0 7
70887: PUSH
70888: LD_EXP 64
70892: PUSH
70893: LD_VAR 0 2
70897: ARRAY
70898: ST_TO_ADDR
// if mc_scan [ i ] then
70899: LD_EXP 86
70903: PUSH
70904: LD_VAR 0 2
70908: ARRAY
70909: IFFALSE 70971
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
70911: LD_ADDR_VAR 0 7
70915: PUSH
70916: LD_EXP 64
70920: PUSH
70921: LD_VAR 0 2
70925: ARRAY
70926: PPUSH
70927: LD_INT 3
70929: PUSH
70930: LD_INT 30
70932: PUSH
70933: LD_INT 32
70935: PUSH
70936: EMPTY
70937: LIST
70938: LIST
70939: PUSH
70940: LD_INT 30
70942: PUSH
70943: LD_INT 33
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 30
70952: PUSH
70953: LD_INT 31
70955: PUSH
70956: EMPTY
70957: LIST
70958: LIST
70959: PUSH
70960: EMPTY
70961: LIST
70962: LIST
70963: LIST
70964: LIST
70965: PPUSH
70966: CALL_OW 72
70970: ST_TO_ADDR
// if not to_repair_tmp then
70971: LD_VAR 0 7
70975: NOT
70976: IFFALSE 70980
// continue ;
70978: GO 70778
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70980: LD_ADDR_VAR 0 8
70984: PUSH
70985: LD_VAR 0 7
70989: PPUSH
70990: LD_VAR 0 3
70994: PPUSH
70995: CALL_OW 74
70999: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
71000: LD_VAR 0 8
71004: PPUSH
71005: LD_INT 16
71007: PPUSH
71008: CALL 25533 0 2
71012: PUSH
71013: LD_INT 4
71015: ARRAY
71016: PUSH
71017: LD_INT 14
71019: LESS
71020: IFFALSE 71036
// ComRepairBuilding ( j , to_repair ) ;
71022: LD_VAR 0 3
71026: PPUSH
71027: LD_VAR 0 8
71031: PPUSH
71032: CALL_OW 130
// end ;
71036: GO 70778
71038: POP
71039: POP
// end ;
71040: GO 70144
71042: POP
71043: POP
// end ;
71044: LD_VAR 0 1
71048: RET
// export function MC_Heal ; var i , j , tmp ; begin
71049: LD_INT 0
71051: PPUSH
71052: PPUSH
71053: PPUSH
71054: PPUSH
// if not mc_bases then
71055: LD_EXP 63
71059: NOT
71060: IFFALSE 71064
// exit ;
71062: GO 71470
// for i = 1 to mc_bases do
71064: LD_ADDR_VAR 0 2
71068: PUSH
71069: DOUBLE
71070: LD_INT 1
71072: DEC
71073: ST_TO_ADDR
71074: LD_EXP 63
71078: PUSH
71079: FOR_TO
71080: IFFALSE 71468
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71082: LD_EXP 66
71086: PUSH
71087: LD_VAR 0 2
71091: ARRAY
71092: PUSH
71093: LD_INT 1
71095: ARRAY
71096: NOT
71097: IFFALSE 71116
71099: PUSH
71100: LD_EXP 66
71104: PUSH
71105: LD_VAR 0 2
71109: ARRAY
71110: PUSH
71111: LD_INT 2
71113: ARRAY
71114: NOT
71115: AND
71116: IFFALSE 71154
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71118: LD_ADDR_EXP 67
71122: PUSH
71123: LD_EXP 67
71127: PPUSH
71128: LD_VAR 0 2
71132: PPUSH
71133: EMPTY
71134: PPUSH
71135: CALL_OW 1
71139: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71140: LD_VAR 0 2
71144: PPUSH
71145: LD_INT 102
71147: PPUSH
71148: CALL 65135 0 2
// continue ;
71152: GO 71079
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71154: LD_ADDR_VAR 0 4
71158: PUSH
71159: LD_EXP 63
71163: PUSH
71164: LD_VAR 0 2
71168: ARRAY
71169: PPUSH
71170: LD_INT 25
71172: PUSH
71173: LD_INT 4
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PPUSH
71180: CALL_OW 72
71184: ST_TO_ADDR
// if not tmp then
71185: LD_VAR 0 4
71189: NOT
71190: IFFALSE 71194
// continue ;
71192: GO 71079
// if mc_taming [ i ] then
71194: LD_EXP 94
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: IFFALSE 71228
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71206: LD_ADDR_EXP 94
71210: PUSH
71211: LD_EXP 94
71215: PPUSH
71216: LD_VAR 0 2
71220: PPUSH
71221: EMPTY
71222: PPUSH
71223: CALL_OW 1
71227: ST_TO_ADDR
// for j in tmp do
71228: LD_ADDR_VAR 0 3
71232: PUSH
71233: LD_VAR 0 4
71237: PUSH
71238: FOR_IN
71239: IFFALSE 71464
// begin if IsInUnit ( j ) then
71241: LD_VAR 0 3
71245: PPUSH
71246: CALL_OW 310
71250: IFFALSE 71261
// ComExitBuilding ( j ) ;
71252: LD_VAR 0 3
71256: PPUSH
71257: CALL_OW 122
// if not j in mc_healers [ i ] then
71261: LD_VAR 0 3
71265: PUSH
71266: LD_EXP 67
71270: PUSH
71271: LD_VAR 0 2
71275: ARRAY
71276: IN
71277: NOT
71278: IFFALSE 71324
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71280: LD_ADDR_EXP 67
71284: PUSH
71285: LD_EXP 67
71289: PPUSH
71290: LD_VAR 0 2
71294: PUSH
71295: LD_EXP 67
71299: PUSH
71300: LD_VAR 0 2
71304: ARRAY
71305: PUSH
71306: LD_INT 1
71308: PLUS
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PPUSH
71314: LD_VAR 0 3
71318: PPUSH
71319: CALL 22554 0 3
71323: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71324: LD_VAR 0 3
71328: PPUSH
71329: CALL_OW 110
71333: PUSH
71334: LD_INT 102
71336: NONEQUAL
71337: IFFALSE 71351
// SetTag ( j , 102 ) ;
71339: LD_VAR 0 3
71343: PPUSH
71344: LD_INT 102
71346: PPUSH
71347: CALL_OW 109
// Wait ( 3 ) ;
71351: LD_INT 3
71353: PPUSH
71354: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71358: LD_EXP 66
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: PUSH
71369: LD_INT 1
71371: ARRAY
71372: IFFALSE 71404
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71374: LD_VAR 0 3
71378: PPUSH
71379: LD_EXP 66
71383: PUSH
71384: LD_VAR 0 2
71388: ARRAY
71389: PUSH
71390: LD_INT 1
71392: ARRAY
71393: PUSH
71394: LD_INT 1
71396: ARRAY
71397: PPUSH
71398: CALL_OW 128
71402: GO 71462
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71404: LD_VAR 0 3
71408: PPUSH
71409: CALL_OW 314
71413: NOT
71414: IFFALSE 71432
71416: PUSH
71417: LD_EXP 66
71421: PUSH
71422: LD_VAR 0 2
71426: ARRAY
71427: PUSH
71428: LD_INT 2
71430: ARRAY
71431: AND
71432: IFFALSE 71462
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71434: LD_VAR 0 3
71438: PPUSH
71439: LD_EXP 66
71443: PUSH
71444: LD_VAR 0 2
71448: ARRAY
71449: PUSH
71450: LD_INT 2
71452: ARRAY
71453: PUSH
71454: LD_INT 1
71456: ARRAY
71457: PPUSH
71458: CALL_OW 128
// end ;
71462: GO 71238
71464: POP
71465: POP
// end ;
71466: GO 71079
71468: POP
71469: POP
// end ;
71470: LD_VAR 0 1
71474: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71475: LD_INT 0
71477: PPUSH
71478: PPUSH
71479: PPUSH
71480: PPUSH
71481: PPUSH
71482: PPUSH
// if not mc_bases then
71483: LD_EXP 63
71487: NOT
71488: IFFALSE 71492
// exit ;
71490: GO 72663
// for i = 1 to mc_bases do
71492: LD_ADDR_VAR 0 2
71496: PUSH
71497: DOUBLE
71498: LD_INT 1
71500: DEC
71501: ST_TO_ADDR
71502: LD_EXP 63
71506: PUSH
71507: FOR_TO
71508: IFFALSE 72661
// begin if mc_scan [ i ] then
71510: LD_EXP 86
71514: PUSH
71515: LD_VAR 0 2
71519: ARRAY
71520: IFFALSE 71524
// continue ;
71522: GO 71507
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71524: LD_EXP 68
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: NOT
71535: IFFALSE 71550
71537: PUSH
71538: LD_EXP 70
71542: PUSH
71543: LD_VAR 0 2
71547: ARRAY
71548: NOT
71549: AND
71550: IFFALSE 71564
71552: PUSH
71553: LD_EXP 69
71557: PUSH
71558: LD_VAR 0 2
71562: ARRAY
71563: AND
71564: IFFALSE 71602
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71566: LD_ADDR_EXP 69
71570: PUSH
71571: LD_EXP 69
71575: PPUSH
71576: LD_VAR 0 2
71580: PPUSH
71581: EMPTY
71582: PPUSH
71583: CALL_OW 1
71587: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71588: LD_VAR 0 2
71592: PPUSH
71593: LD_INT 103
71595: PPUSH
71596: CALL 65135 0 2
// continue ;
71600: GO 71507
// end ; if mc_construct_list [ i ] then
71602: LD_EXP 70
71606: PUSH
71607: LD_VAR 0 2
71611: ARRAY
71612: IFFALSE 71832
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71614: LD_ADDR_VAR 0 5
71618: PUSH
71619: LD_EXP 63
71623: PUSH
71624: LD_VAR 0 2
71628: ARRAY
71629: PPUSH
71630: LD_INT 25
71632: PUSH
71633: LD_INT 2
71635: PUSH
71636: EMPTY
71637: LIST
71638: LIST
71639: PPUSH
71640: CALL_OW 72
71644: PUSH
71645: LD_EXP 65
71649: PUSH
71650: LD_VAR 0 2
71654: ARRAY
71655: DIFF
71656: ST_TO_ADDR
// if not tmp then
71657: LD_VAR 0 5
71661: NOT
71662: IFFALSE 71666
// continue ;
71664: GO 71507
// for j in tmp do
71666: LD_ADDR_VAR 0 3
71670: PUSH
71671: LD_VAR 0 5
71675: PUSH
71676: FOR_IN
71677: IFFALSE 71828
// begin if not mc_builders [ i ] then
71679: LD_EXP 69
71683: PUSH
71684: LD_VAR 0 2
71688: ARRAY
71689: NOT
71690: IFFALSE 71748
// begin SetTag ( j , 103 ) ;
71692: LD_VAR 0 3
71696: PPUSH
71697: LD_INT 103
71699: PPUSH
71700: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71704: LD_ADDR_EXP 69
71708: PUSH
71709: LD_EXP 69
71713: PPUSH
71714: LD_VAR 0 2
71718: PUSH
71719: LD_EXP 69
71723: PUSH
71724: LD_VAR 0 2
71728: ARRAY
71729: PUSH
71730: LD_INT 1
71732: PLUS
71733: PUSH
71734: EMPTY
71735: LIST
71736: LIST
71737: PPUSH
71738: LD_VAR 0 3
71742: PPUSH
71743: CALL 22554 0 3
71747: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71748: LD_VAR 0 3
71752: PPUSH
71753: CALL_OW 310
71757: IFFALSE 71768
// ComExitBuilding ( j ) ;
71759: LD_VAR 0 3
71763: PPUSH
71764: CALL_OW 122
// wait ( 3 ) ;
71768: LD_INT 3
71770: PPUSH
71771: CALL_OW 67
// if not mc_construct_list [ i ] then
71775: LD_EXP 70
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: NOT
71786: IFFALSE 71790
// break ;
71788: GO 71828
// if not HasTask ( j ) then
71790: LD_VAR 0 3
71794: PPUSH
71795: CALL_OW 314
71799: NOT
71800: IFFALSE 71826
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
71802: LD_VAR 0 3
71806: PPUSH
71807: LD_EXP 70
71811: PUSH
71812: LD_VAR 0 2
71816: ARRAY
71817: PUSH
71818: LD_INT 1
71820: ARRAY
71821: PPUSH
71822: CALL 25806 0 2
// end ;
71826: GO 71676
71828: POP
71829: POP
// end else
71830: GO 72659
// if mc_build_list [ i ] then
71832: LD_EXP 68
71836: PUSH
71837: LD_VAR 0 2
71841: ARRAY
71842: IFFALSE 72659
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
71844: LD_EXP 68
71848: PUSH
71849: LD_VAR 0 2
71853: ARRAY
71854: PUSH
71855: LD_INT 1
71857: ARRAY
71858: PUSH
71859: LD_INT 1
71861: ARRAY
71862: PPUSH
71863: CALL 25630 0 1
71867: IFFALSE 71915
71869: PUSH
71870: LD_EXP 63
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: PPUSH
71881: LD_INT 2
71883: PUSH
71884: LD_INT 30
71886: PUSH
71887: LD_INT 2
71889: PUSH
71890: EMPTY
71891: LIST
71892: LIST
71893: PUSH
71894: LD_INT 30
71896: PUSH
71897: LD_INT 3
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: EMPTY
71905: LIST
71906: LIST
71907: LIST
71908: PPUSH
71909: CALL_OW 72
71913: NOT
71914: AND
71915: IFFALSE 72020
// begin for j = 1 to mc_build_list [ i ] do
71917: LD_ADDR_VAR 0 3
71921: PUSH
71922: DOUBLE
71923: LD_INT 1
71925: DEC
71926: ST_TO_ADDR
71927: LD_EXP 68
71931: PUSH
71932: LD_VAR 0 2
71936: ARRAY
71937: PUSH
71938: FOR_TO
71939: IFFALSE 72018
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71941: LD_EXP 68
71945: PUSH
71946: LD_VAR 0 2
71950: ARRAY
71951: PUSH
71952: LD_VAR 0 3
71956: ARRAY
71957: PUSH
71958: LD_INT 1
71960: ARRAY
71961: PUSH
71962: LD_INT 2
71964: EQUAL
71965: IFFALSE 72016
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71967: LD_ADDR_EXP 68
71971: PUSH
71972: LD_EXP 68
71976: PPUSH
71977: LD_VAR 0 2
71981: PPUSH
71982: LD_EXP 68
71986: PUSH
71987: LD_VAR 0 2
71991: ARRAY
71992: PPUSH
71993: LD_VAR 0 3
71997: PPUSH
71998: LD_INT 1
72000: PPUSH
72001: LD_INT 0
72003: PPUSH
72004: CALL 21962 0 4
72008: PPUSH
72009: CALL_OW 1
72013: ST_TO_ADDR
// break ;
72014: GO 72018
// end ;
72016: GO 71938
72018: POP
72019: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72020: LD_ADDR_VAR 0 6
72024: PUSH
72025: LD_EXP 63
72029: PUSH
72030: LD_VAR 0 2
72034: ARRAY
72035: PPUSH
72036: LD_INT 2
72038: PUSH
72039: LD_INT 30
72041: PUSH
72042: LD_INT 0
72044: PUSH
72045: EMPTY
72046: LIST
72047: LIST
72048: PUSH
72049: LD_INT 30
72051: PUSH
72052: LD_INT 1
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: LIST
72063: PPUSH
72064: CALL_OW 72
72068: ST_TO_ADDR
// for k := 1 to depot do
72069: LD_ADDR_VAR 0 4
72073: PUSH
72074: DOUBLE
72075: LD_INT 1
72077: DEC
72078: ST_TO_ADDR
72079: LD_VAR 0 6
72083: PUSH
72084: FOR_TO
72085: IFFALSE 72657
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72087: LD_EXP 68
72091: PUSH
72092: LD_VAR 0 2
72096: ARRAY
72097: PUSH
72098: LD_INT 1
72100: ARRAY
72101: PUSH
72102: LD_INT 1
72104: ARRAY
72105: PUSH
72106: LD_INT 0
72108: EQUAL
72109: IFTRUE 72204
72111: PUSH
72112: LD_VAR 0 6
72116: PUSH
72117: LD_VAR 0 4
72121: ARRAY
72122: PPUSH
72123: LD_EXP 68
72127: PUSH
72128: LD_VAR 0 2
72132: ARRAY
72133: PUSH
72134: LD_INT 1
72136: ARRAY
72137: PUSH
72138: LD_INT 1
72140: ARRAY
72141: PPUSH
72142: LD_EXP 68
72146: PUSH
72147: LD_VAR 0 2
72151: ARRAY
72152: PUSH
72153: LD_INT 1
72155: ARRAY
72156: PUSH
72157: LD_INT 2
72159: ARRAY
72160: PPUSH
72161: LD_EXP 68
72165: PUSH
72166: LD_VAR 0 2
72170: ARRAY
72171: PUSH
72172: LD_INT 1
72174: ARRAY
72175: PUSH
72176: LD_INT 3
72178: ARRAY
72179: PPUSH
72180: LD_EXP 68
72184: PUSH
72185: LD_VAR 0 2
72189: ARRAY
72190: PUSH
72191: LD_INT 1
72193: ARRAY
72194: PUSH
72195: LD_INT 4
72197: ARRAY
72198: PPUSH
72199: CALL 31110 0 5
72203: OR
72204: IFFALSE 72485
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72206: LD_ADDR_VAR 0 5
72210: PUSH
72211: LD_EXP 63
72215: PUSH
72216: LD_VAR 0 2
72220: ARRAY
72221: PPUSH
72222: LD_INT 25
72224: PUSH
72225: LD_INT 2
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PPUSH
72232: CALL_OW 72
72236: PUSH
72237: LD_EXP 65
72241: PUSH
72242: LD_VAR 0 2
72246: ARRAY
72247: DIFF
72248: ST_TO_ADDR
// if not tmp then
72249: LD_VAR 0 5
72253: NOT
72254: IFFALSE 72258
// continue ;
72256: GO 72084
// for j in tmp do
72258: LD_ADDR_VAR 0 3
72262: PUSH
72263: LD_VAR 0 5
72267: PUSH
72268: FOR_IN
72269: IFFALSE 72481
// begin if not mc_builders [ i ] then
72271: LD_EXP 69
72275: PUSH
72276: LD_VAR 0 2
72280: ARRAY
72281: NOT
72282: IFFALSE 72340
// begin SetTag ( j , 103 ) ;
72284: LD_VAR 0 3
72288: PPUSH
72289: LD_INT 103
72291: PPUSH
72292: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72296: LD_ADDR_EXP 69
72300: PUSH
72301: LD_EXP 69
72305: PPUSH
72306: LD_VAR 0 2
72310: PUSH
72311: LD_EXP 69
72315: PUSH
72316: LD_VAR 0 2
72320: ARRAY
72321: PUSH
72322: LD_INT 1
72324: PLUS
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PPUSH
72330: LD_VAR 0 3
72334: PPUSH
72335: CALL 22554 0 3
72339: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72340: LD_VAR 0 3
72344: PPUSH
72345: CALL_OW 310
72349: IFFALSE 72360
// ComExitBuilding ( j ) ;
72351: LD_VAR 0 3
72355: PPUSH
72356: CALL_OW 122
// wait ( 3 ) ;
72360: LD_INT 3
72362: PPUSH
72363: CALL_OW 67
// if not mc_build_list [ i ] then
72367: LD_EXP 68
72371: PUSH
72372: LD_VAR 0 2
72376: ARRAY
72377: NOT
72378: IFFALSE 72382
// break ;
72380: GO 72481
// if not HasTask ( j ) then
72382: LD_VAR 0 3
72386: PPUSH
72387: CALL_OW 314
72391: NOT
72392: IFFALSE 72479
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72394: LD_VAR 0 3
72398: PPUSH
72399: LD_EXP 68
72403: PUSH
72404: LD_VAR 0 2
72408: ARRAY
72409: PUSH
72410: LD_INT 1
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PPUSH
72418: LD_EXP 68
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: PUSH
72429: LD_INT 1
72431: ARRAY
72432: PUSH
72433: LD_INT 2
72435: ARRAY
72436: PPUSH
72437: LD_EXP 68
72441: PUSH
72442: LD_VAR 0 2
72446: ARRAY
72447: PUSH
72448: LD_INT 1
72450: ARRAY
72451: PUSH
72452: LD_INT 3
72454: ARRAY
72455: PPUSH
72456: LD_EXP 68
72460: PUSH
72461: LD_VAR 0 2
72465: ARRAY
72466: PUSH
72467: LD_INT 1
72469: ARRAY
72470: PUSH
72471: LD_INT 4
72473: ARRAY
72474: PPUSH
72475: CALL_OW 145
// end ;
72479: GO 72268
72481: POP
72482: POP
// end else
72483: GO 72655
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72485: LD_EXP 63
72489: PUSH
72490: LD_VAR 0 2
72494: ARRAY
72495: PPUSH
72496: LD_EXP 68
72500: PUSH
72501: LD_VAR 0 2
72505: ARRAY
72506: PUSH
72507: LD_INT 1
72509: ARRAY
72510: PUSH
72511: LD_INT 1
72513: ARRAY
72514: PPUSH
72515: LD_EXP 68
72519: PUSH
72520: LD_VAR 0 2
72524: ARRAY
72525: PUSH
72526: LD_INT 1
72528: ARRAY
72529: PUSH
72530: LD_INT 2
72532: ARRAY
72533: PPUSH
72534: LD_EXP 68
72538: PUSH
72539: LD_VAR 0 2
72543: ARRAY
72544: PUSH
72545: LD_INT 1
72547: ARRAY
72548: PUSH
72549: LD_INT 3
72551: ARRAY
72552: PPUSH
72553: LD_EXP 68
72557: PUSH
72558: LD_VAR 0 2
72562: ARRAY
72563: PUSH
72564: LD_INT 1
72566: ARRAY
72567: PUSH
72568: LD_INT 4
72570: ARRAY
72571: PPUSH
72572: LD_EXP 63
72576: PUSH
72577: LD_VAR 0 2
72581: ARRAY
72582: PPUSH
72583: LD_INT 21
72585: PUSH
72586: LD_INT 3
72588: PUSH
72589: EMPTY
72590: LIST
72591: LIST
72592: PPUSH
72593: CALL_OW 72
72597: PPUSH
72598: EMPTY
72599: PPUSH
72600: CALL 29846 0 7
72604: NOT
72605: IFFALSE 72655
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72607: LD_ADDR_EXP 68
72611: PUSH
72612: LD_EXP 68
72616: PPUSH
72617: LD_VAR 0 2
72621: PPUSH
72622: LD_EXP 68
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PPUSH
72633: LD_INT 1
72635: PPUSH
72636: LD_INT 1
72638: NEG
72639: PPUSH
72640: LD_INT 0
72642: PPUSH
72643: CALL 21962 0 4
72647: PPUSH
72648: CALL_OW 1
72652: ST_TO_ADDR
// continue ;
72653: GO 72084
// end ; end ;
72655: GO 72084
72657: POP
72658: POP
// end ; end ;
72659: GO 71507
72661: POP
72662: POP
// end ;
72663: LD_VAR 0 1
72667: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72668: LD_INT 0
72670: PPUSH
72671: PPUSH
72672: PPUSH
72673: PPUSH
72674: PPUSH
72675: PPUSH
// if not mc_bases then
72676: LD_EXP 63
72680: NOT
72681: IFFALSE 72685
// exit ;
72683: GO 73118
// for i = 1 to mc_bases do
72685: LD_ADDR_VAR 0 2
72689: PUSH
72690: DOUBLE
72691: LD_INT 1
72693: DEC
72694: ST_TO_ADDR
72695: LD_EXP 63
72699: PUSH
72700: FOR_TO
72701: IFFALSE 73116
// begin tmp := mc_build_upgrade [ i ] ;
72703: LD_ADDR_VAR 0 4
72707: PUSH
72708: LD_EXP 95
72712: PUSH
72713: LD_VAR 0 2
72717: ARRAY
72718: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72719: LD_ADDR_VAR 0 6
72723: PUSH
72724: LD_EXP 96
72728: PUSH
72729: LD_VAR 0 2
72733: ARRAY
72734: PPUSH
72735: LD_INT 2
72737: PUSH
72738: LD_INT 30
72740: PUSH
72741: LD_INT 6
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 30
72750: PUSH
72751: LD_INT 7
72753: PUSH
72754: EMPTY
72755: LIST
72756: LIST
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: LIST
72762: PPUSH
72763: CALL_OW 72
72767: ST_TO_ADDR
// if not tmp and not lab then
72768: LD_VAR 0 4
72772: NOT
72773: IFFALSE 72782
72775: PUSH
72776: LD_VAR 0 6
72780: NOT
72781: AND
72782: IFFALSE 72786
// continue ;
72784: GO 72700
// if tmp then
72786: LD_VAR 0 4
72790: IFFALSE 72910
// for j in tmp do
72792: LD_ADDR_VAR 0 3
72796: PUSH
72797: LD_VAR 0 4
72801: PUSH
72802: FOR_IN
72803: IFFALSE 72908
// begin if UpgradeCost ( j ) then
72805: LD_VAR 0 3
72809: PPUSH
72810: CALL 29498 0 1
72814: IFFALSE 72906
// begin ComUpgrade ( j ) ;
72816: LD_VAR 0 3
72820: PPUSH
72821: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
72825: LD_ADDR_EXP 95
72829: PUSH
72830: LD_EXP 95
72834: PPUSH
72835: LD_VAR 0 2
72839: PPUSH
72840: LD_EXP 95
72844: PUSH
72845: LD_VAR 0 2
72849: ARRAY
72850: PUSH
72851: LD_VAR 0 3
72855: DIFF
72856: PPUSH
72857: CALL_OW 1
72861: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72862: LD_ADDR_EXP 70
72866: PUSH
72867: LD_EXP 70
72871: PPUSH
72872: LD_VAR 0 2
72876: PUSH
72877: LD_EXP 70
72881: PUSH
72882: LD_VAR 0 2
72886: ARRAY
72887: PUSH
72888: LD_INT 1
72890: PLUS
72891: PUSH
72892: EMPTY
72893: LIST
72894: LIST
72895: PPUSH
72896: LD_VAR 0 3
72900: PPUSH
72901: CALL 22554 0 3
72905: ST_TO_ADDR
// end ; end ;
72906: GO 72802
72908: POP
72909: POP
// if not lab or not mc_lab_upgrade [ i ] then
72910: LD_VAR 0 6
72914: NOT
72915: IFTRUE 72930
72917: PUSH
72918: LD_EXP 97
72922: PUSH
72923: LD_VAR 0 2
72927: ARRAY
72928: NOT
72929: OR
72930: IFFALSE 72934
// continue ;
72932: GO 72700
// for j in lab do
72934: LD_ADDR_VAR 0 3
72938: PUSH
72939: LD_VAR 0 6
72943: PUSH
72944: FOR_IN
72945: IFFALSE 73112
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72947: LD_VAR 0 3
72951: PPUSH
72952: CALL_OW 266
72956: PUSH
72957: LD_INT 6
72959: PUSH
72960: LD_INT 7
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: IN
72967: IFFALSE 72984
72969: PUSH
72970: LD_VAR 0 3
72974: PPUSH
72975: CALL_OW 461
72979: PUSH
72980: LD_INT 1
72982: NONEQUAL
72983: AND
72984: IFFALSE 73110
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72986: LD_VAR 0 3
72990: PPUSH
72991: LD_EXP 97
72995: PUSH
72996: LD_VAR 0 2
73000: ARRAY
73001: PUSH
73002: LD_INT 1
73004: ARRAY
73005: PPUSH
73006: CALL 29707 0 2
73010: IFFALSE 73110
// begin ComCancel ( j ) ;
73012: LD_VAR 0 3
73016: PPUSH
73017: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
73021: LD_VAR 0 3
73025: PPUSH
73026: LD_EXP 97
73030: PUSH
73031: LD_VAR 0 2
73035: ARRAY
73036: PUSH
73037: LD_INT 1
73039: ARRAY
73040: PPUSH
73041: CALL_OW 207
// if not j in mc_construct_list [ i ] then
73045: LD_VAR 0 3
73049: PUSH
73050: LD_EXP 70
73054: PUSH
73055: LD_VAR 0 2
73059: ARRAY
73060: IN
73061: NOT
73062: IFFALSE 73108
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73064: LD_ADDR_EXP 70
73068: PUSH
73069: LD_EXP 70
73073: PPUSH
73074: LD_VAR 0 2
73078: PUSH
73079: LD_EXP 70
73083: PUSH
73084: LD_VAR 0 2
73088: ARRAY
73089: PUSH
73090: LD_INT 1
73092: PLUS
73093: PUSH
73094: EMPTY
73095: LIST
73096: LIST
73097: PPUSH
73098: LD_VAR 0 3
73102: PPUSH
73103: CALL 22554 0 3
73107: ST_TO_ADDR
// break ;
73108: GO 73112
// end ; end ; end ;
73110: GO 72944
73112: POP
73113: POP
// end ;
73114: GO 72700
73116: POP
73117: POP
// end ;
73118: LD_VAR 0 1
73122: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73123: LD_INT 0
73125: PPUSH
73126: PPUSH
73127: PPUSH
73128: PPUSH
73129: PPUSH
73130: PPUSH
73131: PPUSH
73132: PPUSH
73133: PPUSH
// if not mc_bases then
73134: LD_EXP 63
73138: NOT
73139: IFFALSE 73143
// exit ;
73141: GO 73550
// for i = 1 to mc_bases do
73143: LD_ADDR_VAR 0 2
73147: PUSH
73148: DOUBLE
73149: LD_INT 1
73151: DEC
73152: ST_TO_ADDR
73153: LD_EXP 63
73157: PUSH
73158: FOR_TO
73159: IFFALSE 73548
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73161: LD_EXP 71
73165: PUSH
73166: LD_VAR 0 2
73170: ARRAY
73171: NOT
73172: IFTRUE 73202
73174: PUSH
73175: LD_EXP 63
73179: PUSH
73180: LD_VAR 0 2
73184: ARRAY
73185: PPUSH
73186: LD_INT 30
73188: PUSH
73189: LD_INT 3
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PPUSH
73196: CALL_OW 72
73200: NOT
73201: OR
73202: IFFALSE 73206
// continue ;
73204: GO 73158
// busy := false ;
73206: LD_ADDR_VAR 0 8
73210: PUSH
73211: LD_INT 0
73213: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73214: LD_ADDR_VAR 0 4
73218: PUSH
73219: LD_EXP 63
73223: PUSH
73224: LD_VAR 0 2
73228: ARRAY
73229: PPUSH
73230: LD_INT 30
73232: PUSH
73233: LD_INT 3
73235: PUSH
73236: EMPTY
73237: LIST
73238: LIST
73239: PPUSH
73240: CALL_OW 72
73244: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73245: LD_ADDR_VAR 0 6
73249: PUSH
73250: LD_EXP 71
73254: PUSH
73255: LD_VAR 0 2
73259: ARRAY
73260: PPUSH
73261: LD_INT 2
73263: PUSH
73264: LD_INT 30
73266: PUSH
73267: LD_INT 32
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: PUSH
73274: LD_INT 30
73276: PUSH
73277: LD_INT 33
73279: PUSH
73280: EMPTY
73281: LIST
73282: LIST
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: LIST
73288: PPUSH
73289: CALL_OW 72
73293: ST_TO_ADDR
// if not t then
73294: LD_VAR 0 6
73298: NOT
73299: IFFALSE 73303
// continue ;
73301: GO 73158
// for j in tmp do
73303: LD_ADDR_VAR 0 3
73307: PUSH
73308: LD_VAR 0 4
73312: PUSH
73313: FOR_IN
73314: IFFALSE 73344
// if not BuildingStatus ( j ) = bs_idle then
73316: LD_VAR 0 3
73320: PPUSH
73321: CALL_OW 461
73325: PUSH
73326: LD_INT 2
73328: EQUAL
73329: NOT
73330: IFFALSE 73342
// begin busy := true ;
73332: LD_ADDR_VAR 0 8
73336: PUSH
73337: LD_INT 1
73339: ST_TO_ADDR
// break ;
73340: GO 73344
// end ;
73342: GO 73313
73344: POP
73345: POP
// if busy then
73346: LD_VAR 0 8
73350: IFFALSE 73354
// continue ;
73352: GO 73158
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73354: LD_ADDR_VAR 0 7
73358: PUSH
73359: LD_VAR 0 6
73363: PPUSH
73364: LD_INT 35
73366: PUSH
73367: LD_INT 0
73369: PUSH
73370: EMPTY
73371: LIST
73372: LIST
73373: PPUSH
73374: CALL_OW 72
73378: ST_TO_ADDR
// if tw then
73379: LD_VAR 0 7
73383: IFFALSE 73460
// begin tw := tw [ 1 ] ;
73385: LD_ADDR_VAR 0 7
73389: PUSH
73390: LD_VAR 0 7
73394: PUSH
73395: LD_INT 1
73397: ARRAY
73398: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73399: LD_ADDR_VAR 0 9
73403: PUSH
73404: LD_VAR 0 7
73408: PPUSH
73409: LD_EXP 88
73413: PUSH
73414: LD_VAR 0 2
73418: ARRAY
73419: PPUSH
73420: CALL 27961 0 2
73424: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73425: LD_EXP 102
73429: PUSH
73430: LD_VAR 0 2
73434: ARRAY
73435: IFFALSE 73458
// if not weapon in mc_allowed_tower_weapons [ i ] then
73437: LD_VAR 0 9
73441: PUSH
73442: LD_EXP 102
73446: PUSH
73447: LD_VAR 0 2
73451: ARRAY
73452: IN
73453: NOT
73454: IFFALSE 73458
// continue ;
73456: GO 73158
// end else
73458: GO 73523
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73460: LD_ADDR_VAR 0 5
73464: PUSH
73465: LD_EXP 71
73469: PUSH
73470: LD_VAR 0 2
73474: ARRAY
73475: PPUSH
73476: LD_VAR 0 4
73480: PPUSH
73481: CALL 55156 0 2
73485: ST_TO_ADDR
// if not tmp2 then
73486: LD_VAR 0 5
73490: NOT
73491: IFFALSE 73495
// continue ;
73493: GO 73158
// tw := tmp2 [ 1 ] ;
73495: LD_ADDR_VAR 0 7
73499: PUSH
73500: LD_VAR 0 5
73504: PUSH
73505: LD_INT 1
73507: ARRAY
73508: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73509: LD_ADDR_VAR 0 9
73513: PUSH
73514: LD_VAR 0 5
73518: PUSH
73519: LD_INT 2
73521: ARRAY
73522: ST_TO_ADDR
// end ; if not weapon then
73523: LD_VAR 0 9
73527: NOT
73528: IFFALSE 73532
// continue ;
73530: GO 73158
// ComPlaceWeapon ( tw , weapon ) ;
73532: LD_VAR 0 7
73536: PPUSH
73537: LD_VAR 0 9
73541: PPUSH
73542: CALL_OW 148
// end ;
73546: GO 73158
73548: POP
73549: POP
// end ;
73550: LD_VAR 0 1
73554: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73555: LD_INT 0
73557: PPUSH
73558: PPUSH
73559: PPUSH
73560: PPUSH
73561: PPUSH
73562: PPUSH
73563: PPUSH
// if not mc_bases then
73564: LD_EXP 63
73568: NOT
73569: IFFALSE 73573
// exit ;
73571: GO 74360
// for i = 1 to mc_bases do
73573: LD_ADDR_VAR 0 2
73577: PUSH
73578: DOUBLE
73579: LD_INT 1
73581: DEC
73582: ST_TO_ADDR
73583: LD_EXP 63
73587: PUSH
73588: FOR_TO
73589: IFFALSE 74358
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73591: LD_EXP 76
73595: PUSH
73596: LD_VAR 0 2
73600: ARRAY
73601: NOT
73602: IFTRUE 73628
73604: PUSH
73605: LD_EXP 76
73609: PUSH
73610: LD_VAR 0 2
73614: ARRAY
73615: PUSH
73616: LD_EXP 77
73620: PUSH
73621: LD_VAR 0 2
73625: ARRAY
73626: EQUAL
73627: OR
73628: IFTRUE 73642
73630: PUSH
73631: LD_EXP 86
73635: PUSH
73636: LD_VAR 0 2
73640: ARRAY
73641: OR
73642: IFFALSE 73646
// continue ;
73644: GO 73588
// if mc_miners [ i ] then
73646: LD_EXP 77
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: IFFALSE 74043
// begin for j = mc_miners [ i ] downto 1 do
73658: LD_ADDR_VAR 0 3
73662: PUSH
73663: DOUBLE
73664: LD_EXP 77
73668: PUSH
73669: LD_VAR 0 2
73673: ARRAY
73674: INC
73675: ST_TO_ADDR
73676: LD_INT 1
73678: PUSH
73679: FOR_DOWNTO
73680: IFFALSE 74041
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73682: LD_EXP 77
73686: PUSH
73687: LD_VAR 0 2
73691: ARRAY
73692: PUSH
73693: LD_VAR 0 3
73697: ARRAY
73698: PPUSH
73699: CALL_OW 301
73703: IFTRUE 73732
73705: PUSH
73706: LD_EXP 77
73710: PUSH
73711: LD_VAR 0 2
73715: ARRAY
73716: PUSH
73717: LD_VAR 0 3
73721: ARRAY
73722: PPUSH
73723: CALL_OW 257
73727: PUSH
73728: LD_INT 1
73730: NONEQUAL
73731: OR
73732: IFFALSE 73795
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73734: LD_ADDR_VAR 0 5
73738: PUSH
73739: LD_EXP 77
73743: PUSH
73744: LD_VAR 0 2
73748: ARRAY
73749: PUSH
73750: LD_EXP 77
73754: PUSH
73755: LD_VAR 0 2
73759: ARRAY
73760: PUSH
73761: LD_VAR 0 3
73765: ARRAY
73766: DIFF
73767: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73768: LD_ADDR_EXP 77
73772: PUSH
73773: LD_EXP 77
73777: PPUSH
73778: LD_VAR 0 2
73782: PPUSH
73783: LD_VAR 0 5
73787: PPUSH
73788: CALL_OW 1
73792: ST_TO_ADDR
// continue ;
73793: GO 73679
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73795: LD_EXP 77
73799: PUSH
73800: LD_VAR 0 2
73804: ARRAY
73805: PUSH
73806: LD_VAR 0 3
73810: ARRAY
73811: PPUSH
73812: CALL_OW 257
73816: PUSH
73817: LD_INT 1
73819: EQUAL
73820: IFFALSE 73846
73822: PUSH
73823: LD_EXP 77
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: PUSH
73834: LD_VAR 0 3
73838: ARRAY
73839: PPUSH
73840: CALL_OW 459
73844: NOT
73845: AND
73846: IFFALSE 73872
73848: PUSH
73849: LD_EXP 77
73853: PUSH
73854: LD_VAR 0 2
73858: ARRAY
73859: PUSH
73860: LD_VAR 0 3
73864: ARRAY
73865: PPUSH
73866: CALL_OW 314
73870: NOT
73871: AND
73872: IFFALSE 74039
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
73874: LD_EXP 77
73878: PUSH
73879: LD_VAR 0 2
73883: ARRAY
73884: PUSH
73885: LD_VAR 0 3
73889: ARRAY
73890: PPUSH
73891: CALL_OW 310
73895: IFFALSE 73918
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
73897: LD_EXP 77
73901: PUSH
73902: LD_VAR 0 2
73906: ARRAY
73907: PUSH
73908: LD_VAR 0 3
73912: ARRAY
73913: PPUSH
73914: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
73918: LD_EXP 77
73922: PUSH
73923: LD_VAR 0 2
73927: ARRAY
73928: PUSH
73929: LD_VAR 0 3
73933: ARRAY
73934: PPUSH
73935: CALL_OW 314
73939: NOT
73940: IFFALSE 74039
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
73942: LD_ADDR_VAR 0 7
73946: PUSH
73947: LD_VAR 0 3
73951: PUSH
73952: LD_EXP 76
73956: PUSH
73957: LD_VAR 0 2
73961: ARRAY
73962: PPUSH
73963: CALL 19636 0 1
73967: MOD
73968: PUSH
73969: LD_INT 1
73971: PLUS
73972: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73973: LD_EXP 77
73977: PUSH
73978: LD_VAR 0 2
73982: ARRAY
73983: PUSH
73984: LD_VAR 0 3
73988: ARRAY
73989: PPUSH
73990: LD_EXP 76
73994: PUSH
73995: LD_VAR 0 2
73999: ARRAY
74000: PUSH
74001: LD_VAR 0 7
74005: ARRAY
74006: PUSH
74007: LD_INT 1
74009: ARRAY
74010: PPUSH
74011: LD_EXP 76
74015: PUSH
74016: LD_VAR 0 2
74020: ARRAY
74021: PUSH
74022: LD_VAR 0 7
74026: ARRAY
74027: PUSH
74028: LD_INT 2
74030: ARRAY
74031: PPUSH
74032: LD_INT 0
74034: PPUSH
74035: CALL_OW 193
// end ; end ; end ;
74039: GO 73679
74041: POP
74042: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
74043: LD_ADDR_VAR 0 5
74047: PUSH
74048: LD_EXP 63
74052: PUSH
74053: LD_VAR 0 2
74057: ARRAY
74058: PPUSH
74059: LD_INT 2
74061: PUSH
74062: LD_INT 30
74064: PUSH
74065: LD_INT 4
74067: PUSH
74068: EMPTY
74069: LIST
74070: LIST
74071: PUSH
74072: LD_INT 30
74074: PUSH
74075: LD_INT 5
74077: PUSH
74078: EMPTY
74079: LIST
74080: LIST
74081: PUSH
74082: LD_INT 30
74084: PUSH
74085: LD_INT 32
74087: PUSH
74088: EMPTY
74089: LIST
74090: LIST
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: LIST
74096: LIST
74097: PPUSH
74098: CALL_OW 72
74102: ST_TO_ADDR
// if not tmp then
74103: LD_VAR 0 5
74107: NOT
74108: IFFALSE 74112
// continue ;
74110: GO 73588
// list := [ ] ;
74112: LD_ADDR_VAR 0 6
74116: PUSH
74117: EMPTY
74118: ST_TO_ADDR
// for j in tmp do
74119: LD_ADDR_VAR 0 3
74123: PUSH
74124: LD_VAR 0 5
74128: PUSH
74129: FOR_IN
74130: IFFALSE 74201
// begin for k in UnitsInside ( j ) do
74132: LD_ADDR_VAR 0 4
74136: PUSH
74137: LD_VAR 0 3
74141: PPUSH
74142: CALL_OW 313
74146: PUSH
74147: FOR_IN
74148: IFFALSE 74197
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74150: LD_VAR 0 4
74154: PPUSH
74155: CALL_OW 257
74159: PUSH
74160: LD_INT 1
74162: EQUAL
74163: IFFALSE 74177
74165: PUSH
74166: LD_VAR 0 4
74170: PPUSH
74171: CALL_OW 459
74175: NOT
74176: AND
74177: IFFALSE 74195
// list := list ^ k ;
74179: LD_ADDR_VAR 0 6
74183: PUSH
74184: LD_VAR 0 6
74188: PUSH
74189: LD_VAR 0 4
74193: ADD
74194: ST_TO_ADDR
74195: GO 74147
74197: POP
74198: POP
// end ;
74199: GO 74129
74201: POP
74202: POP
// list := list diff mc_miners [ i ] ;
74203: LD_ADDR_VAR 0 6
74207: PUSH
74208: LD_VAR 0 6
74212: PUSH
74213: LD_EXP 77
74217: PUSH
74218: LD_VAR 0 2
74222: ARRAY
74223: DIFF
74224: ST_TO_ADDR
// if not list then
74225: LD_VAR 0 6
74229: NOT
74230: IFFALSE 74234
// continue ;
74232: GO 73588
// k := mc_mines [ i ] - mc_miners [ i ] ;
74234: LD_ADDR_VAR 0 4
74238: PUSH
74239: LD_EXP 76
74243: PUSH
74244: LD_VAR 0 2
74248: ARRAY
74249: PUSH
74250: LD_EXP 77
74254: PUSH
74255: LD_VAR 0 2
74259: ARRAY
74260: MINUS
74261: ST_TO_ADDR
// if k > list then
74262: LD_VAR 0 4
74266: PUSH
74267: LD_VAR 0 6
74271: GREATER
74272: IFFALSE 74284
// k := list ;
74274: LD_ADDR_VAR 0 4
74278: PUSH
74279: LD_VAR 0 6
74283: ST_TO_ADDR
// for j = 1 to k do
74284: LD_ADDR_VAR 0 3
74288: PUSH
74289: DOUBLE
74290: LD_INT 1
74292: DEC
74293: ST_TO_ADDR
74294: LD_VAR 0 4
74298: PUSH
74299: FOR_TO
74300: IFFALSE 74354
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74302: LD_ADDR_EXP 77
74306: PUSH
74307: LD_EXP 77
74311: PPUSH
74312: LD_VAR 0 2
74316: PUSH
74317: LD_EXP 77
74321: PUSH
74322: LD_VAR 0 2
74326: ARRAY
74327: PUSH
74328: LD_INT 1
74330: PLUS
74331: PUSH
74332: EMPTY
74333: LIST
74334: LIST
74335: PPUSH
74336: LD_VAR 0 6
74340: PUSH
74341: LD_VAR 0 3
74345: ARRAY
74346: PPUSH
74347: CALL 22554 0 3
74351: ST_TO_ADDR
74352: GO 74299
74354: POP
74355: POP
// end ;
74356: GO 73588
74358: POP
74359: POP
// end ;
74360: LD_VAR 0 1
74364: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74365: LD_INT 0
74367: PPUSH
74368: PPUSH
74369: PPUSH
74370: PPUSH
74371: PPUSH
74372: PPUSH
74373: PPUSH
74374: PPUSH
74375: PPUSH
74376: PPUSH
74377: PPUSH
// if not mc_bases then
74378: LD_EXP 63
74382: NOT
74383: IFFALSE 74387
// exit ;
74385: GO 76234
// for i = 1 to mc_bases do
74387: LD_ADDR_VAR 0 2
74391: PUSH
74392: DOUBLE
74393: LD_INT 1
74395: DEC
74396: ST_TO_ADDR
74397: LD_EXP 63
74401: PUSH
74402: FOR_TO
74403: IFFALSE 76232
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74405: LD_EXP 63
74409: PUSH
74410: LD_VAR 0 2
74414: ARRAY
74415: NOT
74416: IFTRUE 74430
74418: PUSH
74419: LD_EXP 70
74423: PUSH
74424: LD_VAR 0 2
74428: ARRAY
74429: OR
74430: IFFALSE 74434
// continue ;
74432: GO 74402
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74434: LD_EXP 79
74438: PUSH
74439: LD_VAR 0 2
74443: ARRAY
74444: NOT
74445: IFFALSE 74459
74447: PUSH
74448: LD_EXP 80
74452: PUSH
74453: LD_VAR 0 2
74457: ARRAY
74458: AND
74459: IFFALSE 74497
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74461: LD_ADDR_EXP 80
74465: PUSH
74466: LD_EXP 80
74470: PPUSH
74471: LD_VAR 0 2
74475: PPUSH
74476: EMPTY
74477: PPUSH
74478: CALL_OW 1
74482: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74483: LD_VAR 0 2
74487: PPUSH
74488: LD_INT 107
74490: PPUSH
74491: CALL 65135 0 2
// continue ;
74495: GO 74402
// end ; target := [ ] ;
74497: LD_ADDR_VAR 0 7
74501: PUSH
74502: EMPTY
74503: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74504: LD_ADDR_VAR 0 6
74508: PUSH
74509: LD_EXP 63
74513: PUSH
74514: LD_VAR 0 2
74518: ARRAY
74519: PUSH
74520: LD_INT 1
74522: ARRAY
74523: PPUSH
74524: CALL_OW 255
74528: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74529: LD_ADDR_VAR 0 9
74533: PUSH
74534: LD_EXP 63
74538: PUSH
74539: LD_VAR 0 2
74543: ARRAY
74544: PPUSH
74545: LD_INT 2
74547: PUSH
74548: LD_INT 30
74550: PUSH
74551: LD_INT 0
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 30
74560: PUSH
74561: LD_INT 1
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: LIST
74572: PPUSH
74573: CALL_OW 72
74577: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74578: LD_ADDR_VAR 0 3
74582: PUSH
74583: DOUBLE
74584: LD_EXP 79
74588: PUSH
74589: LD_VAR 0 2
74593: ARRAY
74594: INC
74595: ST_TO_ADDR
74596: LD_INT 1
74598: PUSH
74599: FOR_DOWNTO
74600: IFFALSE 74847
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74602: LD_EXP 79
74606: PUSH
74607: LD_VAR 0 2
74611: ARRAY
74612: PUSH
74613: LD_VAR 0 3
74617: ARRAY
74618: PUSH
74619: LD_INT 2
74621: ARRAY
74622: PPUSH
74623: LD_EXP 79
74627: PUSH
74628: LD_VAR 0 2
74632: ARRAY
74633: PUSH
74634: LD_VAR 0 3
74638: ARRAY
74639: PUSH
74640: LD_INT 3
74642: ARRAY
74643: PPUSH
74644: CALL_OW 488
74648: IFFALSE 74702
74650: PUSH
74651: LD_EXP 79
74655: PUSH
74656: LD_VAR 0 2
74660: ARRAY
74661: PUSH
74662: LD_VAR 0 3
74666: ARRAY
74667: PUSH
74668: LD_INT 2
74670: ARRAY
74671: PPUSH
74672: LD_EXP 79
74676: PUSH
74677: LD_VAR 0 2
74681: ARRAY
74682: PUSH
74683: LD_VAR 0 3
74687: ARRAY
74688: PUSH
74689: LD_INT 3
74691: ARRAY
74692: PPUSH
74693: CALL_OW 284
74697: PUSH
74698: LD_INT 0
74700: EQUAL
74701: AND
74702: IFFALSE 74757
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74704: LD_ADDR_VAR 0 5
74708: PUSH
74709: LD_EXP 79
74713: PUSH
74714: LD_VAR 0 2
74718: ARRAY
74719: PPUSH
74720: LD_VAR 0 3
74724: PPUSH
74725: CALL_OW 3
74729: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74730: LD_ADDR_EXP 79
74734: PUSH
74735: LD_EXP 79
74739: PPUSH
74740: LD_VAR 0 2
74744: PPUSH
74745: LD_VAR 0 5
74749: PPUSH
74750: CALL_OW 1
74754: ST_TO_ADDR
// continue ;
74755: GO 74599
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74757: LD_VAR 0 6
74761: PPUSH
74762: LD_EXP 79
74766: PUSH
74767: LD_VAR 0 2
74771: ARRAY
74772: PUSH
74773: LD_VAR 0 3
74777: ARRAY
74778: PUSH
74779: LD_INT 2
74781: ARRAY
74782: PPUSH
74783: LD_EXP 79
74787: PUSH
74788: LD_VAR 0 2
74792: ARRAY
74793: PUSH
74794: LD_VAR 0 3
74798: ARRAY
74799: PUSH
74800: LD_INT 3
74802: ARRAY
74803: PPUSH
74804: LD_INT 30
74806: PPUSH
74807: CALL 23824 0 4
74811: PUSH
74812: LD_INT 4
74814: ARRAY
74815: PUSH
74816: LD_INT 0
74818: EQUAL
74819: IFFALSE 74845
// begin target := mc_crates [ i ] [ j ] ;
74821: LD_ADDR_VAR 0 7
74825: PUSH
74826: LD_EXP 79
74830: PUSH
74831: LD_VAR 0 2
74835: ARRAY
74836: PUSH
74837: LD_VAR 0 3
74841: ARRAY
74842: ST_TO_ADDR
// break ;
74843: GO 74847
// end ; end ;
74845: GO 74599
74847: POP
74848: POP
// if not target then
74849: LD_VAR 0 7
74853: NOT
74854: IFFALSE 74858
// continue ;
74856: GO 74402
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
74858: LD_ADDR_VAR 0 8
74862: PUSH
74863: LD_EXP 82
74867: PUSH
74868: LD_VAR 0 2
74872: ARRAY
74873: PPUSH
74874: LD_INT 2
74876: PUSH
74877: LD_INT 3
74879: PUSH
74880: LD_INT 58
74882: PUSH
74883: EMPTY
74884: LIST
74885: PUSH
74886: EMPTY
74887: LIST
74888: LIST
74889: PUSH
74890: LD_INT 61
74892: PUSH
74893: EMPTY
74894: LIST
74895: PUSH
74896: LD_INT 33
74898: PUSH
74899: LD_INT 5
74901: PUSH
74902: EMPTY
74903: LIST
74904: LIST
74905: PUSH
74906: LD_INT 33
74908: PUSH
74909: LD_INT 3
74911: PUSH
74912: EMPTY
74913: LIST
74914: LIST
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 2
74925: PUSH
74926: LD_INT 34
74928: PUSH
74929: LD_INT 32
74931: PUSH
74932: EMPTY
74933: LIST
74934: LIST
74935: PUSH
74936: LD_INT 34
74938: PUSH
74939: LD_INT 51
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: PUSH
74946: LD_INT 34
74948: PUSH
74949: LD_INT 12
74951: PUSH
74952: EMPTY
74953: LIST
74954: LIST
74955: PUSH
74956: EMPTY
74957: LIST
74958: LIST
74959: LIST
74960: LIST
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PPUSH
74966: CALL_OW 72
74970: ST_TO_ADDR
// if not cargo then
74971: LD_VAR 0 8
74975: NOT
74976: IFFALSE 75690
// begin if mc_crates_collector [ i ] < 5 then
74978: LD_EXP 80
74982: PUSH
74983: LD_VAR 0 2
74987: ARRAY
74988: PUSH
74989: LD_INT 5
74991: LESS
74992: IFFALSE 75362
// begin if mc_ape [ i ] then
74994: LD_EXP 92
74998: PUSH
74999: LD_VAR 0 2
75003: ARRAY
75004: IFFALSE 75051
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
75006: LD_ADDR_VAR 0 5
75010: PUSH
75011: LD_EXP 92
75015: PUSH
75016: LD_VAR 0 2
75020: ARRAY
75021: PPUSH
75022: LD_INT 25
75024: PUSH
75025: LD_INT 16
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 24
75034: PUSH
75035: LD_INT 750
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: PUSH
75042: EMPTY
75043: LIST
75044: LIST
75045: PPUSH
75046: CALL_OW 72
75050: ST_TO_ADDR
// if not tmp then
75051: LD_VAR 0 5
75055: NOT
75056: IFFALSE 75103
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75058: LD_ADDR_VAR 0 5
75062: PUSH
75063: LD_EXP 63
75067: PUSH
75068: LD_VAR 0 2
75072: ARRAY
75073: PPUSH
75074: LD_INT 25
75076: PUSH
75077: LD_INT 2
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 24
75086: PUSH
75087: LD_INT 750
75089: PUSH
75090: EMPTY
75091: LIST
75092: LIST
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PPUSH
75098: CALL_OW 72
75102: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75103: LD_EXP 92
75107: PUSH
75108: LD_VAR 0 2
75112: ARRAY
75113: IFFALSE 75156
75115: PUSH
75116: LD_EXP 63
75120: PUSH
75121: LD_VAR 0 2
75125: ARRAY
75126: PPUSH
75127: LD_INT 25
75129: PUSH
75130: LD_INT 2
75132: PUSH
75133: EMPTY
75134: LIST
75135: LIST
75136: PUSH
75137: LD_INT 24
75139: PUSH
75140: LD_INT 750
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PPUSH
75151: CALL_OW 72
75155: AND
75156: IFFALSE 75168
75158: PUSH
75159: LD_VAR 0 5
75163: PUSH
75164: LD_INT 5
75166: LESS
75167: AND
75168: IFFALSE 75250
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75170: LD_ADDR_VAR 0 3
75174: PUSH
75175: LD_EXP 63
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: PPUSH
75186: LD_INT 25
75188: PUSH
75189: LD_INT 2
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 24
75198: PUSH
75199: LD_INT 750
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PPUSH
75210: CALL_OW 72
75214: PUSH
75215: FOR_IN
75216: IFFALSE 75248
// begin tmp := tmp union j ;
75218: LD_ADDR_VAR 0 5
75222: PUSH
75223: LD_VAR 0 5
75227: PUSH
75228: LD_VAR 0 3
75232: UNION
75233: ST_TO_ADDR
// if tmp >= 5 then
75234: LD_VAR 0 5
75238: PUSH
75239: LD_INT 5
75241: GREATEREQUAL
75242: IFFALSE 75246
// break ;
75244: GO 75248
// end ;
75246: GO 75215
75248: POP
75249: POP
// end ; if not tmp then
75250: LD_VAR 0 5
75254: NOT
75255: IFFALSE 75259
// continue ;
75257: GO 74402
// for j in tmp do
75259: LD_ADDR_VAR 0 3
75263: PUSH
75264: LD_VAR 0 5
75268: PUSH
75269: FOR_IN
75270: IFFALSE 75360
// if not GetTag ( j ) then
75272: LD_VAR 0 3
75276: PPUSH
75277: CALL_OW 110
75281: NOT
75282: IFFALSE 75358
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75284: LD_ADDR_EXP 80
75288: PUSH
75289: LD_EXP 80
75293: PPUSH
75294: LD_VAR 0 2
75298: PUSH
75299: LD_EXP 80
75303: PUSH
75304: LD_VAR 0 2
75308: ARRAY
75309: PUSH
75310: LD_INT 1
75312: PLUS
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PPUSH
75318: LD_VAR 0 3
75322: PPUSH
75323: CALL 22554 0 3
75327: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75328: LD_VAR 0 3
75332: PPUSH
75333: LD_INT 107
75335: PPUSH
75336: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75340: LD_EXP 80
75344: PUSH
75345: LD_VAR 0 2
75349: ARRAY
75350: PUSH
75351: LD_INT 5
75353: GREATEREQUAL
75354: IFFALSE 75358
// break ;
75356: GO 75360
// end ;
75358: GO 75269
75360: POP
75361: POP
// end ; if mc_crates_collector [ i ] and target then
75362: LD_EXP 80
75366: PUSH
75367: LD_VAR 0 2
75371: ARRAY
75372: IFFALSE 75380
75374: PUSH
75375: LD_VAR 0 7
75379: AND
75380: IFFALSE 75688
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75382: LD_EXP 80
75386: PUSH
75387: LD_VAR 0 2
75391: ARRAY
75392: PUSH
75393: LD_VAR 0 7
75397: PUSH
75398: LD_INT 1
75400: ARRAY
75401: LESS
75402: IFFALSE 75422
// tmp := mc_crates_collector [ i ] else
75404: LD_ADDR_VAR 0 5
75408: PUSH
75409: LD_EXP 80
75413: PUSH
75414: LD_VAR 0 2
75418: ARRAY
75419: ST_TO_ADDR
75420: GO 75436
// tmp := target [ 1 ] ;
75422: LD_ADDR_VAR 0 5
75426: PUSH
75427: LD_VAR 0 7
75431: PUSH
75432: LD_INT 1
75434: ARRAY
75435: ST_TO_ADDR
// k := 0 ;
75436: LD_ADDR_VAR 0 4
75440: PUSH
75441: LD_INT 0
75443: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75444: LD_ADDR_VAR 0 3
75448: PUSH
75449: LD_EXP 80
75453: PUSH
75454: LD_VAR 0 2
75458: ARRAY
75459: PUSH
75460: FOR_IN
75461: IFFALSE 75686
// begin k := k + 1 ;
75463: LD_ADDR_VAR 0 4
75467: PUSH
75468: LD_VAR 0 4
75472: PUSH
75473: LD_INT 1
75475: PLUS
75476: ST_TO_ADDR
// if k > tmp then
75477: LD_VAR 0 4
75481: PUSH
75482: LD_VAR 0 5
75486: GREATER
75487: IFFALSE 75491
// break ;
75489: GO 75686
// if not GetClass ( j ) in [ 2 , 16 ] then
75491: LD_VAR 0 3
75495: PPUSH
75496: CALL_OW 257
75500: PUSH
75501: LD_INT 2
75503: PUSH
75504: LD_INT 16
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: IN
75511: NOT
75512: IFFALSE 75565
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75514: LD_ADDR_EXP 80
75518: PUSH
75519: LD_EXP 80
75523: PPUSH
75524: LD_VAR 0 2
75528: PPUSH
75529: LD_EXP 80
75533: PUSH
75534: LD_VAR 0 2
75538: ARRAY
75539: PUSH
75540: LD_VAR 0 3
75544: DIFF
75545: PPUSH
75546: CALL_OW 1
75550: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75551: LD_VAR 0 3
75555: PPUSH
75556: LD_INT 0
75558: PPUSH
75559: CALL_OW 109
// continue ;
75563: GO 75460
// end ; if IsInUnit ( j ) then
75565: LD_VAR 0 3
75569: PPUSH
75570: CALL_OW 310
75574: IFFALSE 75585
// ComExitBuilding ( j ) ;
75576: LD_VAR 0 3
75580: PPUSH
75581: CALL_OW 122
// wait ( 3 ) ;
75585: LD_INT 3
75587: PPUSH
75588: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75592: LD_VAR 0 3
75596: PPUSH
75597: CALL_OW 314
75601: IFFALSE 75639
75603: PUSH
75604: LD_VAR 0 6
75608: PPUSH
75609: LD_VAR 0 7
75613: PUSH
75614: LD_INT 2
75616: ARRAY
75617: PPUSH
75618: LD_VAR 0 7
75622: PUSH
75623: LD_INT 3
75625: ARRAY
75626: PPUSH
75627: LD_INT 30
75629: PPUSH
75630: CALL 23824 0 4
75634: PUSH
75635: LD_INT 4
75637: ARRAY
75638: AND
75639: IFFALSE 75657
// ComStandNearbyBuilding ( j , depot ) else
75641: LD_VAR 0 3
75645: PPUSH
75646: LD_VAR 0 9
75650: PPUSH
75651: CALL 19096 0 2
75655: GO 75684
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75657: LD_VAR 0 3
75661: PPUSH
75662: LD_VAR 0 7
75666: PUSH
75667: LD_INT 2
75669: ARRAY
75670: PPUSH
75671: LD_VAR 0 7
75675: PUSH
75676: LD_INT 3
75678: ARRAY
75679: PPUSH
75680: CALL_OW 117
// end ;
75684: GO 75460
75686: POP
75687: POP
// end ; end else
75688: GO 76230
// begin for j in cargo do
75690: LD_ADDR_VAR 0 3
75694: PUSH
75695: LD_VAR 0 8
75699: PUSH
75700: FOR_IN
75701: IFFALSE 76228
// begin if GetTag ( j ) <> 0 then
75703: LD_VAR 0 3
75707: PPUSH
75708: CALL_OW 110
75712: PUSH
75713: LD_INT 0
75715: NONEQUAL
75716: IFFALSE 75720
// continue ;
75718: GO 75700
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75720: LD_VAR 0 3
75724: PPUSH
75725: CALL_OW 256
75729: PUSH
75730: LD_INT 1000
75732: LESS
75733: IFFALSE 75758
75735: PUSH
75736: LD_VAR 0 3
75740: PPUSH
75741: LD_EXP 87
75745: PUSH
75746: LD_VAR 0 2
75750: ARRAY
75751: PPUSH
75752: CALL_OW 308
75756: NOT
75757: AND
75758: IFFALSE 75780
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75760: LD_VAR 0 3
75764: PPUSH
75765: LD_EXP 87
75769: PUSH
75770: LD_VAR 0 2
75774: ARRAY
75775: PPUSH
75776: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75780: LD_VAR 0 3
75784: PPUSH
75785: CALL_OW 256
75789: PUSH
75790: LD_INT 1000
75792: LESS
75793: IFFALSE 75817
75795: PUSH
75796: LD_VAR 0 3
75800: PPUSH
75801: LD_EXP 87
75805: PUSH
75806: LD_VAR 0 2
75810: ARRAY
75811: PPUSH
75812: CALL_OW 308
75816: AND
75817: IFFALSE 75821
// continue ;
75819: GO 75700
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75821: LD_VAR 0 3
75825: PPUSH
75826: CALL_OW 262
75830: PUSH
75831: LD_INT 2
75833: EQUAL
75834: IFFALSE 75851
75836: PUSH
75837: LD_VAR 0 3
75841: PPUSH
75842: CALL_OW 261
75846: PUSH
75847: LD_INT 15
75849: LESS
75850: AND
75851: IFFALSE 75855
// continue ;
75853: GO 75700
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
75855: LD_VAR 0 3
75859: PPUSH
75860: CALL_OW 262
75864: PUSH
75865: LD_INT 1
75867: EQUAL
75868: IFFALSE 75885
75870: PUSH
75871: LD_VAR 0 3
75875: PPUSH
75876: CALL_OW 261
75880: PUSH
75881: LD_INT 10
75883: LESS
75884: AND
75885: IFFALSE 76165
// begin if not depot then
75887: LD_VAR 0 9
75891: NOT
75892: IFFALSE 75896
// continue ;
75894: GO 75700
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
75896: LD_VAR 0 3
75900: PPUSH
75901: LD_VAR 0 9
75905: PPUSH
75906: LD_VAR 0 3
75910: PPUSH
75911: CALL_OW 74
75915: PPUSH
75916: CALL_OW 296
75920: PUSH
75921: LD_INT 6
75923: LESS
75924: IFFALSE 75940
// SetFuel ( j , 100 ) else
75926: LD_VAR 0 3
75930: PPUSH
75931: LD_INT 100
75933: PPUSH
75934: CALL_OW 240
75938: GO 76165
// if GetFuel ( j ) = 0 then
75940: LD_VAR 0 3
75944: PPUSH
75945: CALL_OW 261
75949: PUSH
75950: LD_INT 0
75952: EQUAL
75953: IFFALSE 76165
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
75955: LD_ADDR_EXP 82
75959: PUSH
75960: LD_EXP 82
75964: PPUSH
75965: LD_VAR 0 2
75969: PPUSH
75970: LD_EXP 82
75974: PUSH
75975: LD_VAR 0 2
75979: ARRAY
75980: PUSH
75981: LD_VAR 0 3
75985: DIFF
75986: PPUSH
75987: CALL_OW 1
75991: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75992: LD_VAR 0 3
75996: PPUSH
75997: CALL_OW 263
76001: PUSH
76002: LD_INT 1
76004: EQUAL
76005: IFFALSE 76021
// ComExitVehicle ( IsInUnit ( j ) ) ;
76007: LD_VAR 0 3
76011: PPUSH
76012: CALL_OW 310
76016: PPUSH
76017: CALL_OW 121
// if GetControl ( j ) = control_remote then
76021: LD_VAR 0 3
76025: PPUSH
76026: CALL_OW 263
76030: PUSH
76031: LD_INT 2
76033: EQUAL
76034: IFFALSE 76045
// ComUnlink ( j ) ;
76036: LD_VAR 0 3
76040: PPUSH
76041: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
76045: LD_ADDR_VAR 0 10
76049: PUSH
76050: LD_VAR 0 2
76054: PPUSH
76055: LD_INT 3
76057: PPUSH
76058: CALL 85959 0 2
76062: ST_TO_ADDR
// if fac then
76063: LD_VAR 0 10
76067: IFFALSE 76163
// begin for k in fac do
76069: LD_ADDR_VAR 0 4
76073: PUSH
76074: LD_VAR 0 10
76078: PUSH
76079: FOR_IN
76080: IFFALSE 76161
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76082: LD_ADDR_VAR 0 11
76086: PUSH
76087: LD_VAR 0 10
76091: PPUSH
76092: LD_VAR 0 3
76096: PPUSH
76097: CALL_OW 265
76101: PPUSH
76102: LD_VAR 0 3
76106: PPUSH
76107: CALL_OW 262
76111: PPUSH
76112: LD_VAR 0 3
76116: PPUSH
76117: CALL_OW 263
76121: PPUSH
76122: LD_VAR 0 3
76126: PPUSH
76127: CALL_OW 264
76131: PPUSH
76132: CALL 19994 0 5
76136: ST_TO_ADDR
// if components then
76137: LD_VAR 0 11
76141: IFFALSE 76159
// begin MC_InsertProduceList ( i , components ) ;
76143: LD_VAR 0 2
76147: PPUSH
76148: LD_VAR 0 11
76152: PPUSH
76153: CALL 85504 0 2
// break ;
76157: GO 76161
// end ; end ;
76159: GO 76079
76161: POP
76162: POP
// end ; continue ;
76163: GO 75700
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76165: LD_VAR 0 3
76169: PPUSH
76170: LD_INT 1
76172: PPUSH
76173: CALL_OW 289
76177: PUSH
76178: LD_INT 100
76180: LESS
76181: IFFALSE 76195
76183: PUSH
76184: LD_VAR 0 3
76188: PPUSH
76189: CALL_OW 314
76193: NOT
76194: AND
76195: IFFALSE 76224
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76197: LD_VAR 0 3
76201: PPUSH
76202: LD_VAR 0 7
76206: PUSH
76207: LD_INT 2
76209: ARRAY
76210: PPUSH
76211: LD_VAR 0 7
76215: PUSH
76216: LD_INT 3
76218: ARRAY
76219: PPUSH
76220: CALL_OW 117
// break ;
76224: GO 76228
// end ;
76226: GO 75700
76228: POP
76229: POP
// end ; end ;
76230: GO 74402
76232: POP
76233: POP
// end ;
76234: LD_VAR 0 1
76238: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76239: LD_INT 0
76241: PPUSH
76242: PPUSH
76243: PPUSH
76244: PPUSH
// if not mc_bases then
76245: LD_EXP 63
76249: NOT
76250: IFFALSE 76254
// exit ;
76252: GO 76419
// for i = 1 to mc_bases do
76254: LD_ADDR_VAR 0 2
76258: PUSH
76259: DOUBLE
76260: LD_INT 1
76262: DEC
76263: ST_TO_ADDR
76264: LD_EXP 63
76268: PUSH
76269: FOR_TO
76270: IFFALSE 76417
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76272: LD_ADDR_VAR 0 4
76276: PUSH
76277: LD_EXP 82
76281: PUSH
76282: LD_VAR 0 2
76286: ARRAY
76287: PUSH
76288: LD_EXP 85
76292: PUSH
76293: LD_VAR 0 2
76297: ARRAY
76298: UNION
76299: PPUSH
76300: LD_INT 33
76302: PUSH
76303: LD_INT 2
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PPUSH
76310: CALL_OW 72
76314: ST_TO_ADDR
// if tmp then
76315: LD_VAR 0 4
76319: IFFALSE 76415
// for j in tmp do
76321: LD_ADDR_VAR 0 3
76325: PUSH
76326: LD_VAR 0 4
76330: PUSH
76331: FOR_IN
76332: IFFALSE 76413
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76334: LD_VAR 0 3
76338: PPUSH
76339: CALL_OW 312
76343: NOT
76344: IFFALSE 76361
76346: PUSH
76347: LD_VAR 0 3
76351: PPUSH
76352: CALL_OW 256
76356: PUSH
76357: LD_INT 250
76359: GREATEREQUAL
76360: AND
76361: IFFALSE 76374
// Connect ( j ) else
76363: LD_VAR 0 3
76367: PPUSH
76368: CALL 25914 0 1
76372: GO 76411
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76374: LD_VAR 0 3
76378: PPUSH
76379: CALL_OW 256
76383: PUSH
76384: LD_INT 250
76386: LESS
76387: IFFALSE 76400
76389: PUSH
76390: LD_VAR 0 3
76394: PPUSH
76395: CALL_OW 312
76399: AND
76400: IFFALSE 76411
// ComUnlink ( j ) ;
76402: LD_VAR 0 3
76406: PPUSH
76407: CALL_OW 136
76411: GO 76331
76413: POP
76414: POP
// end ;
76415: GO 76269
76417: POP
76418: POP
// end ;
76419: LD_VAR 0 1
76423: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76424: LD_INT 0
76426: PPUSH
76427: PPUSH
76428: PPUSH
76429: PPUSH
76430: PPUSH
// if not mc_bases then
76431: LD_EXP 63
76435: NOT
76436: IFFALSE 76440
// exit ;
76438: GO 76889
// for i = 1 to mc_bases do
76440: LD_ADDR_VAR 0 2
76444: PUSH
76445: DOUBLE
76446: LD_INT 1
76448: DEC
76449: ST_TO_ADDR
76450: LD_EXP 63
76454: PUSH
76455: FOR_TO
76456: IFFALSE 76887
// begin if not mc_produce [ i ] then
76458: LD_EXP 84
76462: PUSH
76463: LD_VAR 0 2
76467: ARRAY
76468: NOT
76469: IFFALSE 76473
// continue ;
76471: GO 76455
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76473: LD_ADDR_VAR 0 5
76477: PUSH
76478: LD_EXP 63
76482: PUSH
76483: LD_VAR 0 2
76487: ARRAY
76488: PPUSH
76489: LD_INT 30
76491: PUSH
76492: LD_INT 3
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PPUSH
76499: CALL_OW 72
76503: ST_TO_ADDR
// if not fac then
76504: LD_VAR 0 5
76508: NOT
76509: IFFALSE 76513
// continue ;
76511: GO 76455
// for j in fac do
76513: LD_ADDR_VAR 0 3
76517: PUSH
76518: LD_VAR 0 5
76522: PUSH
76523: FOR_IN
76524: IFFALSE 76883
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76526: LD_VAR 0 3
76530: PPUSH
76531: CALL_OW 461
76535: PUSH
76536: LD_INT 2
76538: NONEQUAL
76539: IFTRUE 76559
76541: PUSH
76542: LD_VAR 0 3
76546: PPUSH
76547: LD_INT 15
76549: PPUSH
76550: CALL 25533 0 2
76554: PUSH
76555: LD_INT 4
76557: ARRAY
76558: OR
76559: IFFALSE 76563
// continue ;
76561: GO 76523
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76563: LD_VAR 0 3
76567: PPUSH
76568: LD_EXP 84
76572: PUSH
76573: LD_VAR 0 2
76577: ARRAY
76578: PUSH
76579: LD_INT 1
76581: ARRAY
76582: PUSH
76583: LD_INT 1
76585: ARRAY
76586: PPUSH
76587: LD_EXP 84
76591: PUSH
76592: LD_VAR 0 2
76596: ARRAY
76597: PUSH
76598: LD_INT 1
76600: ARRAY
76601: PUSH
76602: LD_INT 2
76604: ARRAY
76605: PPUSH
76606: LD_EXP 84
76610: PUSH
76611: LD_VAR 0 2
76615: ARRAY
76616: PUSH
76617: LD_INT 1
76619: ARRAY
76620: PUSH
76621: LD_INT 3
76623: ARRAY
76624: PPUSH
76625: LD_EXP 84
76629: PUSH
76630: LD_VAR 0 2
76634: ARRAY
76635: PUSH
76636: LD_INT 1
76638: ARRAY
76639: PUSH
76640: LD_INT 4
76642: ARRAY
76643: PPUSH
76644: CALL_OW 448
76648: IFFALSE 76743
76650: PUSH
76651: LD_VAR 0 3
76655: PPUSH
76656: LD_EXP 84
76660: PUSH
76661: LD_VAR 0 2
76665: ARRAY
76666: PUSH
76667: LD_INT 1
76669: ARRAY
76670: PUSH
76671: LD_INT 1
76673: ARRAY
76674: PUSH
76675: LD_EXP 84
76679: PUSH
76680: LD_VAR 0 2
76684: ARRAY
76685: PUSH
76686: LD_INT 1
76688: ARRAY
76689: PUSH
76690: LD_INT 2
76692: ARRAY
76693: PUSH
76694: LD_EXP 84
76698: PUSH
76699: LD_VAR 0 2
76703: ARRAY
76704: PUSH
76705: LD_INT 1
76707: ARRAY
76708: PUSH
76709: LD_INT 3
76711: ARRAY
76712: PUSH
76713: LD_EXP 84
76717: PUSH
76718: LD_VAR 0 2
76722: ARRAY
76723: PUSH
76724: LD_INT 1
76726: ARRAY
76727: PUSH
76728: LD_INT 4
76730: ARRAY
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: LIST
76736: LIST
76737: PPUSH
76738: CALL 29347 0 2
76742: AND
76743: IFFALSE 76881
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76745: LD_VAR 0 3
76749: PPUSH
76750: LD_EXP 84
76754: PUSH
76755: LD_VAR 0 2
76759: ARRAY
76760: PUSH
76761: LD_INT 1
76763: ARRAY
76764: PUSH
76765: LD_INT 1
76767: ARRAY
76768: PPUSH
76769: LD_EXP 84
76773: PUSH
76774: LD_VAR 0 2
76778: ARRAY
76779: PUSH
76780: LD_INT 1
76782: ARRAY
76783: PUSH
76784: LD_INT 2
76786: ARRAY
76787: PPUSH
76788: LD_EXP 84
76792: PUSH
76793: LD_VAR 0 2
76797: ARRAY
76798: PUSH
76799: LD_INT 1
76801: ARRAY
76802: PUSH
76803: LD_INT 3
76805: ARRAY
76806: PPUSH
76807: LD_EXP 84
76811: PUSH
76812: LD_VAR 0 2
76816: ARRAY
76817: PUSH
76818: LD_INT 1
76820: ARRAY
76821: PUSH
76822: LD_INT 4
76824: ARRAY
76825: PPUSH
76826: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76830: LD_ADDR_VAR 0 4
76834: PUSH
76835: LD_EXP 84
76839: PUSH
76840: LD_VAR 0 2
76844: ARRAY
76845: PPUSH
76846: LD_INT 1
76848: PPUSH
76849: CALL_OW 3
76853: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76854: LD_ADDR_EXP 84
76858: PUSH
76859: LD_EXP 84
76863: PPUSH
76864: LD_VAR 0 2
76868: PPUSH
76869: LD_VAR 0 4
76873: PPUSH
76874: CALL_OW 1
76878: ST_TO_ADDR
// break ;
76879: GO 76883
// end ; end ;
76881: GO 76523
76883: POP
76884: POP
// end ;
76885: GO 76455
76887: POP
76888: POP
// end ;
76889: LD_VAR 0 1
76893: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
76894: LD_INT 0
76896: PPUSH
76897: PPUSH
76898: PPUSH
// if not mc_bases then
76899: LD_EXP 63
76903: NOT
76904: IFFALSE 76908
// exit ;
76906: GO 76997
// for i = 1 to mc_bases do
76908: LD_ADDR_VAR 0 2
76912: PUSH
76913: DOUBLE
76914: LD_INT 1
76916: DEC
76917: ST_TO_ADDR
76918: LD_EXP 63
76922: PUSH
76923: FOR_TO
76924: IFFALSE 76995
// begin if mc_attack [ i ] then
76926: LD_EXP 83
76930: PUSH
76931: LD_VAR 0 2
76935: ARRAY
76936: IFFALSE 76993
// begin tmp := mc_attack [ i ] [ 1 ] ;
76938: LD_ADDR_VAR 0 3
76942: PUSH
76943: LD_EXP 83
76947: PUSH
76948: LD_VAR 0 2
76952: ARRAY
76953: PUSH
76954: LD_INT 1
76956: ARRAY
76957: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
76958: LD_ADDR_EXP 83
76962: PUSH
76963: LD_EXP 83
76967: PPUSH
76968: LD_VAR 0 2
76972: PPUSH
76973: EMPTY
76974: PPUSH
76975: CALL_OW 1
76979: ST_TO_ADDR
// Attack ( tmp ) ;
76980: LD_VAR 0 3
76984: PPUSH
76985: CALL 114588 0 1
// exit ;
76989: POP
76990: POP
76991: GO 76997
// end ; end ;
76993: GO 76923
76995: POP
76996: POP
// end ;
76997: LD_VAR 0 1
77001: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
77002: LD_INT 0
77004: PPUSH
77005: PPUSH
77006: PPUSH
77007: PPUSH
77008: PPUSH
77009: PPUSH
77010: PPUSH
// if not mc_bases then
77011: LD_EXP 63
77015: NOT
77016: IFFALSE 77020
// exit ;
77018: GO 77897
// for i = 1 to mc_bases do
77020: LD_ADDR_VAR 0 2
77024: PUSH
77025: DOUBLE
77026: LD_INT 1
77028: DEC
77029: ST_TO_ADDR
77030: LD_EXP 63
77034: PUSH
77035: FOR_TO
77036: IFFALSE 77895
// begin if not mc_bases [ i ] then
77038: LD_EXP 63
77042: PUSH
77043: LD_VAR 0 2
77047: ARRAY
77048: NOT
77049: IFFALSE 77053
// continue ;
77051: GO 77035
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
77053: LD_ADDR_VAR 0 7
77057: PUSH
77058: LD_EXP 63
77062: PUSH
77063: LD_VAR 0 2
77067: ARRAY
77068: PUSH
77069: LD_INT 1
77071: ARRAY
77072: PPUSH
77073: CALL 19320 0 1
77077: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77078: LD_ADDR_EXP 86
77082: PUSH
77083: LD_EXP 86
77087: PPUSH
77088: LD_VAR 0 2
77092: PPUSH
77093: LD_EXP 63
77097: PUSH
77098: LD_VAR 0 2
77102: ARRAY
77103: PUSH
77104: LD_INT 1
77106: ARRAY
77107: PPUSH
77108: CALL_OW 255
77112: PPUSH
77113: LD_EXP 88
77117: PUSH
77118: LD_VAR 0 2
77122: ARRAY
77123: PPUSH
77124: CALL 19285 0 2
77128: PPUSH
77129: CALL_OW 1
77133: ST_TO_ADDR
// if not mc_scan [ i ] then
77134: LD_EXP 86
77138: PUSH
77139: LD_VAR 0 2
77143: ARRAY
77144: NOT
77145: IFFALSE 77329
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77147: LD_ADDR_EXP 106
77151: PUSH
77152: LD_EXP 106
77156: PPUSH
77157: LD_VAR 0 2
77161: PPUSH
77162: LD_INT 0
77164: PPUSH
77165: CALL_OW 1
77169: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77170: LD_ADDR_VAR 0 4
77174: PUSH
77175: LD_EXP 63
77179: PUSH
77180: LD_VAR 0 2
77184: ARRAY
77185: PPUSH
77186: LD_INT 2
77188: PUSH
77189: LD_INT 25
77191: PUSH
77192: LD_INT 5
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 25
77201: PUSH
77202: LD_INT 8
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: LD_INT 25
77211: PUSH
77212: LD_INT 9
77214: PUSH
77215: EMPTY
77216: LIST
77217: LIST
77218: PUSH
77219: EMPTY
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: PPUSH
77225: CALL_OW 72
77229: ST_TO_ADDR
// if not tmp then
77230: LD_VAR 0 4
77234: NOT
77235: IFFALSE 77239
// continue ;
77237: GO 77035
// for j in tmp do
77239: LD_ADDR_VAR 0 3
77243: PUSH
77244: LD_VAR 0 4
77248: PUSH
77249: FOR_IN
77250: IFFALSE 77327
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77252: LD_VAR 0 3
77256: PPUSH
77257: CALL_OW 310
77261: PPUSH
77262: CALL_OW 266
77266: PUSH
77267: LD_INT 5
77269: EQUAL
77270: IFFALSE 77287
77272: PUSH
77273: LD_VAR 0 3
77277: PPUSH
77278: CALL_OW 257
77282: PUSH
77283: LD_INT 1
77285: EQUAL
77286: AND
77287: IFFALSE 77301
77289: PUSH
77290: LD_VAR 0 3
77294: PPUSH
77295: CALL_OW 459
77299: NOT
77300: AND
77301: IFFALSE 77309
77303: PUSH
77304: LD_VAR 0 7
77308: AND
77309: IFFALSE 77325
// ComChangeProfession ( j , class ) ;
77311: LD_VAR 0 3
77315: PPUSH
77316: LD_VAR 0 7
77320: PPUSH
77321: CALL_OW 123
77325: GO 77249
77327: POP
77328: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77329: LD_EXP 86
77333: PUSH
77334: LD_VAR 0 2
77338: ARRAY
77339: IFFALSE 77354
77341: PUSH
77342: LD_EXP 106
77346: PUSH
77347: LD_VAR 0 2
77351: ARRAY
77352: NOT
77353: AND
77354: IFFALSE 77369
77356: PUSH
77357: LD_EXP 85
77361: PUSH
77362: LD_VAR 0 2
77366: ARRAY
77367: NOT
77368: AND
77369: IFFALSE 77520
77371: PUSH
77372: LD_EXP 63
77376: PUSH
77377: LD_VAR 0 2
77381: ARRAY
77382: PPUSH
77383: LD_INT 50
77385: PUSH
77386: EMPTY
77387: LIST
77388: PUSH
77389: LD_INT 2
77391: PUSH
77392: LD_INT 30
77394: PUSH
77395: LD_INT 32
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PUSH
77402: LD_INT 30
77404: PUSH
77405: LD_INT 33
77407: PUSH
77408: EMPTY
77409: LIST
77410: LIST
77411: PUSH
77412: LD_INT 30
77414: PUSH
77415: LD_INT 4
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PUSH
77422: LD_INT 30
77424: PUSH
77425: LD_INT 5
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: PPUSH
77443: CALL_OW 72
77447: PUSH
77448: LD_INT 4
77450: LESS
77451: IFTRUE 77519
77453: PUSH
77454: LD_EXP 63
77458: PUSH
77459: LD_VAR 0 2
77463: ARRAY
77464: PPUSH
77465: LD_INT 3
77467: PUSH
77468: LD_INT 24
77470: PUSH
77471: LD_INT 1000
77473: PUSH
77474: EMPTY
77475: LIST
77476: LIST
77477: PUSH
77478: EMPTY
77479: LIST
77480: LIST
77481: PUSH
77482: LD_INT 2
77484: PUSH
77485: LD_INT 30
77487: PUSH
77488: LD_INT 0
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 30
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: EMPTY
77506: LIST
77507: LIST
77508: LIST
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: PPUSH
77514: CALL_OW 72
77518: OR
77519: AND
77520: IFFALSE 77773
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77522: LD_ADDR_EXP 106
77526: PUSH
77527: LD_EXP 106
77531: PPUSH
77532: LD_VAR 0 2
77536: PPUSH
77537: LD_INT 1
77539: PPUSH
77540: CALL_OW 1
77544: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77545: LD_ADDR_VAR 0 4
77549: PUSH
77550: LD_EXP 63
77554: PUSH
77555: LD_VAR 0 2
77559: ARRAY
77560: PPUSH
77561: LD_INT 2
77563: PUSH
77564: LD_INT 25
77566: PUSH
77567: LD_INT 1
77569: PUSH
77570: EMPTY
77571: LIST
77572: LIST
77573: PUSH
77574: LD_INT 25
77576: PUSH
77577: LD_INT 5
77579: PUSH
77580: EMPTY
77581: LIST
77582: LIST
77583: PUSH
77584: LD_INT 25
77586: PUSH
77587: LD_INT 8
77589: PUSH
77590: EMPTY
77591: LIST
77592: LIST
77593: PUSH
77594: LD_INT 25
77596: PUSH
77597: LD_INT 9
77599: PUSH
77600: EMPTY
77601: LIST
77602: LIST
77603: PUSH
77604: EMPTY
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: PPUSH
77611: CALL_OW 72
77615: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77616: LD_ADDR_VAR 0 4
77620: PUSH
77621: LD_VAR 0 4
77625: PUSH
77626: LD_VAR 0 4
77630: PPUSH
77631: LD_INT 18
77633: PPUSH
77634: CALL 53157 0 2
77638: DIFF
77639: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77640: LD_VAR 0 4
77644: NOT
77645: IFFALSE 77693
77647: PUSH
77648: LD_EXP 63
77652: PUSH
77653: LD_VAR 0 2
77657: ARRAY
77658: PPUSH
77659: LD_INT 2
77661: PUSH
77662: LD_INT 30
77664: PUSH
77665: LD_INT 4
77667: PUSH
77668: EMPTY
77669: LIST
77670: LIST
77671: PUSH
77672: LD_INT 30
77674: PUSH
77675: LD_INT 5
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: LIST
77686: PPUSH
77687: CALL_OW 72
77691: NOT
77692: AND
77693: IFFALSE 77755
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77695: LD_ADDR_VAR 0 4
77699: PUSH
77700: LD_EXP 63
77704: PUSH
77705: LD_VAR 0 2
77709: ARRAY
77710: PPUSH
77711: LD_INT 2
77713: PUSH
77714: LD_INT 25
77716: PUSH
77717: LD_INT 2
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 25
77726: PUSH
77727: LD_INT 3
77729: PUSH
77730: EMPTY
77731: LIST
77732: LIST
77733: PUSH
77734: LD_INT 25
77736: PUSH
77737: LD_INT 4
77739: PUSH
77740: EMPTY
77741: LIST
77742: LIST
77743: PUSH
77744: EMPTY
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: PPUSH
77750: CALL_OW 72
77754: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77755: LD_VAR 0 2
77759: PPUSH
77760: LD_VAR 0 4
77764: PPUSH
77765: CALL 119357 0 2
// exit ;
77769: POP
77770: POP
77771: GO 77897
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77773: LD_EXP 86
77777: PUSH
77778: LD_VAR 0 2
77782: ARRAY
77783: IFFALSE 77798
77785: PUSH
77786: LD_EXP 106
77790: PUSH
77791: LD_VAR 0 2
77795: ARRAY
77796: NOT
77797: AND
77798: IFFALSE 77812
77800: PUSH
77801: LD_EXP 85
77805: PUSH
77806: LD_VAR 0 2
77810: ARRAY
77811: AND
77812: IFFALSE 77893
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77814: LD_ADDR_EXP 106
77818: PUSH
77819: LD_EXP 106
77823: PPUSH
77824: LD_VAR 0 2
77828: PPUSH
77829: LD_INT 1
77831: PPUSH
77832: CALL_OW 1
77836: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77837: LD_ADDR_VAR 0 4
77841: PUSH
77842: LD_EXP 85
77846: PUSH
77847: LD_VAR 0 2
77851: ARRAY
77852: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77853: LD_ADDR_EXP 85
77857: PUSH
77858: LD_EXP 85
77862: PPUSH
77863: LD_VAR 0 2
77867: PPUSH
77868: EMPTY
77869: PPUSH
77870: CALL_OW 1
77874: ST_TO_ADDR
// Defend ( i , tmp ) ;
77875: LD_VAR 0 2
77879: PPUSH
77880: LD_VAR 0 4
77884: PPUSH
77885: CALL 119961 0 2
// exit ;
77889: POP
77890: POP
77891: GO 77897
// end ; end ;
77893: GO 77035
77895: POP
77896: POP
// end ;
77897: LD_VAR 0 1
77901: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
77902: LD_INT 0
77904: PPUSH
77905: PPUSH
77906: PPUSH
77907: PPUSH
77908: PPUSH
77909: PPUSH
77910: PPUSH
77911: PPUSH
77912: PPUSH
77913: PPUSH
77914: PPUSH
// if not mc_bases then
77915: LD_EXP 63
77919: NOT
77920: IFFALSE 77924
// exit ;
77922: GO 79037
// for i = 1 to mc_bases do
77924: LD_ADDR_VAR 0 2
77928: PUSH
77929: DOUBLE
77930: LD_INT 1
77932: DEC
77933: ST_TO_ADDR
77934: LD_EXP 63
77938: PUSH
77939: FOR_TO
77940: IFFALSE 79035
// begin tmp := mc_lab [ i ] ;
77942: LD_ADDR_VAR 0 6
77946: PUSH
77947: LD_EXP 96
77951: PUSH
77952: LD_VAR 0 2
77956: ARRAY
77957: ST_TO_ADDR
// if not tmp then
77958: LD_VAR 0 6
77962: NOT
77963: IFFALSE 77967
// continue ;
77965: GO 77939
// idle_lab := 0 ;
77967: LD_ADDR_VAR 0 11
77971: PUSH
77972: LD_INT 0
77974: ST_TO_ADDR
// for j in tmp do
77975: LD_ADDR_VAR 0 3
77979: PUSH
77980: LD_VAR 0 6
77984: PUSH
77985: FOR_IN
77986: IFFALSE 79031
// begin researching := false ;
77988: LD_ADDR_VAR 0 10
77992: PUSH
77993: LD_INT 0
77995: ST_TO_ADDR
// side := GetSide ( j ) ;
77996: LD_ADDR_VAR 0 4
78000: PUSH
78001: LD_VAR 0 3
78005: PPUSH
78006: CALL_OW 255
78010: ST_TO_ADDR
// if not mc_tech [ side ] then
78011: LD_EXP 90
78015: PUSH
78016: LD_VAR 0 4
78020: ARRAY
78021: NOT
78022: IFFALSE 78026
// continue ;
78024: GO 77985
// if BuildingStatus ( j ) = bs_idle then
78026: LD_VAR 0 3
78030: PPUSH
78031: CALL_OW 461
78035: PUSH
78036: LD_INT 2
78038: EQUAL
78039: IFFALSE 78231
// begin if idle_lab and UnitsInside ( j ) < 6 then
78041: LD_VAR 0 11
78045: IFFALSE 78062
78047: PUSH
78048: LD_VAR 0 3
78052: PPUSH
78053: CALL_OW 313
78057: PUSH
78058: LD_INT 6
78060: LESS
78061: AND
78062: IFFALSE 78133
// begin tmp2 := UnitsInside ( idle_lab ) ;
78064: LD_ADDR_VAR 0 9
78068: PUSH
78069: LD_VAR 0 11
78073: PPUSH
78074: CALL_OW 313
78078: ST_TO_ADDR
// if tmp2 then
78079: LD_VAR 0 9
78083: IFFALSE 78125
// for x in tmp2 do
78085: LD_ADDR_VAR 0 7
78089: PUSH
78090: LD_VAR 0 9
78094: PUSH
78095: FOR_IN
78096: IFFALSE 78123
// begin ComExitBuilding ( x ) ;
78098: LD_VAR 0 7
78102: PPUSH
78103: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78107: LD_VAR 0 7
78111: PPUSH
78112: LD_VAR 0 3
78116: PPUSH
78117: CALL_OW 180
// end ;
78121: GO 78095
78123: POP
78124: POP
// idle_lab := 0 ;
78125: LD_ADDR_VAR 0 11
78129: PUSH
78130: LD_INT 0
78132: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78133: LD_ADDR_VAR 0 5
78137: PUSH
78138: LD_EXP 90
78142: PUSH
78143: LD_VAR 0 4
78147: ARRAY
78148: PUSH
78149: FOR_IN
78150: IFFALSE 78212
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78152: LD_VAR 0 3
78156: PPUSH
78157: LD_VAR 0 5
78161: PPUSH
78162: CALL_OW 430
78166: IFFALSE 78184
78168: PUSH
78169: LD_VAR 0 4
78173: PPUSH
78174: LD_VAR 0 5
78178: PPUSH
78179: CALL 18380 0 2
78183: AND
78184: IFFALSE 78210
// begin researching := true ;
78186: LD_ADDR_VAR 0 10
78190: PUSH
78191: LD_INT 1
78193: ST_TO_ADDR
// ComResearch ( j , t ) ;
78194: LD_VAR 0 3
78198: PPUSH
78199: LD_VAR 0 5
78203: PPUSH
78204: CALL_OW 124
// break ;
78208: GO 78212
// end ;
78210: GO 78149
78212: POP
78213: POP
// if not researching then
78214: LD_VAR 0 10
78218: NOT
78219: IFFALSE 78231
// idle_lab := j ;
78221: LD_ADDR_VAR 0 11
78225: PUSH
78226: LD_VAR 0 3
78230: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78231: LD_VAR 0 3
78235: PPUSH
78236: CALL_OW 461
78240: PUSH
78241: LD_INT 10
78243: EQUAL
78244: IFFALSE 78850
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78246: LD_EXP 92
78250: PUSH
78251: LD_VAR 0 2
78255: ARRAY
78256: NOT
78257: IFFALSE 78272
78259: PUSH
78260: LD_EXP 93
78264: PUSH
78265: LD_VAR 0 2
78269: ARRAY
78270: NOT
78271: AND
78272: IFFALSE 78290
78274: PUSH
78275: LD_EXP 90
78279: PUSH
78280: LD_VAR 0 4
78284: ARRAY
78285: PUSH
78286: LD_INT 1
78288: GREATER
78289: AND
78290: IFFALSE 78421
// begin ComCancel ( j ) ;
78292: LD_VAR 0 3
78296: PPUSH
78297: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78301: LD_ADDR_EXP 90
78305: PUSH
78306: LD_EXP 90
78310: PPUSH
78311: LD_VAR 0 4
78315: PPUSH
78316: LD_EXP 90
78320: PUSH
78321: LD_VAR 0 4
78325: ARRAY
78326: PPUSH
78327: LD_EXP 90
78331: PUSH
78332: LD_VAR 0 4
78336: ARRAY
78337: PUSH
78338: LD_INT 1
78340: MINUS
78341: PPUSH
78342: LD_EXP 90
78346: PUSH
78347: LD_VAR 0 4
78351: ARRAY
78352: PPUSH
78353: LD_INT 0
78355: PPUSH
78356: CALL 21962 0 4
78360: PPUSH
78361: CALL_OW 1
78365: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78366: LD_ADDR_EXP 90
78370: PUSH
78371: LD_EXP 90
78375: PPUSH
78376: LD_VAR 0 4
78380: PPUSH
78381: LD_EXP 90
78385: PUSH
78386: LD_VAR 0 4
78390: ARRAY
78391: PPUSH
78392: LD_EXP 90
78396: PUSH
78397: LD_VAR 0 4
78401: ARRAY
78402: PPUSH
78403: LD_INT 1
78405: PPUSH
78406: LD_INT 0
78408: PPUSH
78409: CALL 21962 0 4
78413: PPUSH
78414: CALL_OW 1
78418: ST_TO_ADDR
// continue ;
78419: GO 77985
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78421: LD_EXP 92
78425: PUSH
78426: LD_VAR 0 2
78430: ARRAY
78431: IFFALSE 78446
78433: PUSH
78434: LD_EXP 93
78438: PUSH
78439: LD_VAR 0 2
78443: ARRAY
78444: NOT
78445: AND
78446: IFFALSE 78573
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78448: LD_ADDR_EXP 93
78452: PUSH
78453: LD_EXP 93
78457: PPUSH
78458: LD_VAR 0 2
78462: PUSH
78463: LD_EXP 93
78467: PUSH
78468: LD_VAR 0 2
78472: ARRAY
78473: PUSH
78474: LD_INT 1
78476: PLUS
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PPUSH
78482: LD_EXP 92
78486: PUSH
78487: LD_VAR 0 2
78491: ARRAY
78492: PUSH
78493: LD_INT 1
78495: ARRAY
78496: PPUSH
78497: CALL 22554 0 3
78501: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78502: LD_EXP 92
78506: PUSH
78507: LD_VAR 0 2
78511: ARRAY
78512: PUSH
78513: LD_INT 1
78515: ARRAY
78516: PPUSH
78517: LD_INT 112
78519: PPUSH
78520: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78524: LD_ADDR_VAR 0 9
78528: PUSH
78529: LD_EXP 92
78533: PUSH
78534: LD_VAR 0 2
78538: ARRAY
78539: PPUSH
78540: LD_INT 1
78542: PPUSH
78543: CALL_OW 3
78547: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78548: LD_ADDR_EXP 92
78552: PUSH
78553: LD_EXP 92
78557: PPUSH
78558: LD_VAR 0 2
78562: PPUSH
78563: LD_VAR 0 9
78567: PPUSH
78568: CALL_OW 1
78572: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78573: LD_EXP 92
78577: PUSH
78578: LD_VAR 0 2
78582: ARRAY
78583: IFFALSE 78597
78585: PUSH
78586: LD_EXP 93
78590: PUSH
78591: LD_VAR 0 2
78595: ARRAY
78596: AND
78597: IFFALSE 78621
78599: PUSH
78600: LD_EXP 93
78604: PUSH
78605: LD_VAR 0 2
78609: ARRAY
78610: PUSH
78611: LD_INT 1
78613: ARRAY
78614: PPUSH
78615: CALL_OW 310
78619: NOT
78620: AND
78621: IFFALSE 78638
78623: PUSH
78624: LD_VAR 0 3
78628: PPUSH
78629: CALL_OW 313
78633: PUSH
78634: LD_INT 6
78636: EQUAL
78637: AND
78638: IFFALSE 78694
// begin tmp2 := UnitsInside ( j ) ;
78640: LD_ADDR_VAR 0 9
78644: PUSH
78645: LD_VAR 0 3
78649: PPUSH
78650: CALL_OW 313
78654: ST_TO_ADDR
// if tmp2 = 6 then
78655: LD_VAR 0 9
78659: PUSH
78660: LD_INT 6
78662: EQUAL
78663: IFFALSE 78694
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78665: LD_VAR 0 9
78669: PUSH
78670: LD_INT 1
78672: ARRAY
78673: PPUSH
78674: LD_INT 112
78676: PPUSH
78677: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78681: LD_VAR 0 9
78685: PUSH
78686: LD_INT 1
78688: ARRAY
78689: PPUSH
78690: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78694: LD_EXP 93
78698: PUSH
78699: LD_VAR 0 2
78703: ARRAY
78704: IFFALSE 78728
78706: PUSH
78707: LD_EXP 93
78711: PUSH
78712: LD_VAR 0 2
78716: ARRAY
78717: PUSH
78718: LD_INT 1
78720: ARRAY
78721: PPUSH
78722: CALL_OW 314
78726: NOT
78727: AND
78728: IFFALSE 78752
78730: PUSH
78731: LD_EXP 93
78735: PUSH
78736: LD_VAR 0 2
78740: ARRAY
78741: PUSH
78742: LD_INT 1
78744: ARRAY
78745: PPUSH
78746: CALL_OW 310
78750: NOT
78751: AND
78752: IFFALSE 78778
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78754: LD_EXP 93
78758: PUSH
78759: LD_VAR 0 2
78763: ARRAY
78764: PUSH
78765: LD_INT 1
78767: ARRAY
78768: PPUSH
78769: LD_VAR 0 3
78773: PPUSH
78774: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78778: LD_EXP 93
78782: PUSH
78783: LD_VAR 0 2
78787: ARRAY
78788: PUSH
78789: LD_INT 1
78791: ARRAY
78792: PPUSH
78793: CALL_OW 310
78797: IFFALSE 78829
78799: PUSH
78800: LD_EXP 93
78804: PUSH
78805: LD_VAR 0 2
78809: ARRAY
78810: PUSH
78811: LD_INT 1
78813: ARRAY
78814: PPUSH
78815: CALL_OW 310
78819: PPUSH
78820: CALL_OW 461
78824: PUSH
78825: LD_INT 3
78827: NONEQUAL
78828: AND
78829: IFFALSE 78850
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78831: LD_EXP 93
78835: PUSH
78836: LD_VAR 0 2
78840: ARRAY
78841: PUSH
78842: LD_INT 1
78844: ARRAY
78845: PPUSH
78846: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78850: LD_VAR 0 3
78854: PPUSH
78855: CALL_OW 461
78859: PUSH
78860: LD_INT 6
78862: EQUAL
78863: IFFALSE 78875
78865: PUSH
78866: LD_VAR 0 6
78870: PUSH
78871: LD_INT 1
78873: GREATER
78874: AND
78875: IFFALSE 79029
// begin sci := [ ] ;
78877: LD_ADDR_VAR 0 8
78881: PUSH
78882: EMPTY
78883: ST_TO_ADDR
// for x in ( tmp diff j ) do
78884: LD_ADDR_VAR 0 7
78888: PUSH
78889: LD_VAR 0 6
78893: PUSH
78894: LD_VAR 0 3
78898: DIFF
78899: PUSH
78900: FOR_IN
78901: IFFALSE 78953
// begin if sci = 6 then
78903: LD_VAR 0 8
78907: PUSH
78908: LD_INT 6
78910: EQUAL
78911: IFFALSE 78915
// break ;
78913: GO 78953
// if BuildingStatus ( x ) = bs_idle then
78915: LD_VAR 0 7
78919: PPUSH
78920: CALL_OW 461
78924: PUSH
78925: LD_INT 2
78927: EQUAL
78928: IFFALSE 78951
// sci := sci ^ UnitsInside ( x ) ;
78930: LD_ADDR_VAR 0 8
78934: PUSH
78935: LD_VAR 0 8
78939: PUSH
78940: LD_VAR 0 7
78944: PPUSH
78945: CALL_OW 313
78949: ADD
78950: ST_TO_ADDR
// end ;
78951: GO 78900
78953: POP
78954: POP
// if not sci then
78955: LD_VAR 0 8
78959: NOT
78960: IFFALSE 78964
// continue ;
78962: GO 77985
// for x in sci do
78964: LD_ADDR_VAR 0 7
78968: PUSH
78969: LD_VAR 0 8
78973: PUSH
78974: FOR_IN
78975: IFFALSE 79027
// if IsInUnit ( x ) and not HasTask ( x ) then
78977: LD_VAR 0 7
78981: PPUSH
78982: CALL_OW 310
78986: IFFALSE 79000
78988: PUSH
78989: LD_VAR 0 7
78993: PPUSH
78994: CALL_OW 314
78998: NOT
78999: AND
79000: IFFALSE 79025
// begin ComExitBuilding ( x ) ;
79002: LD_VAR 0 7
79006: PPUSH
79007: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
79011: LD_VAR 0 7
79015: PPUSH
79016: LD_VAR 0 3
79020: PPUSH
79021: CALL_OW 180
// end ;
79025: GO 78974
79027: POP
79028: POP
// end ; end ;
79029: GO 77985
79031: POP
79032: POP
// end ;
79033: GO 77939
79035: POP
79036: POP
// end ;
79037: LD_VAR 0 1
79041: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
79042: LD_INT 0
79044: PPUSH
79045: PPUSH
// if not mc_bases then
79046: LD_EXP 63
79050: NOT
79051: IFFALSE 79055
// exit ;
79053: GO 79138
// for i = 1 to mc_bases do
79055: LD_ADDR_VAR 0 2
79059: PUSH
79060: DOUBLE
79061: LD_INT 1
79063: DEC
79064: ST_TO_ADDR
79065: LD_EXP 63
79069: PUSH
79070: FOR_TO
79071: IFFALSE 79136
// if mc_mines [ i ] and mc_miners [ i ] then
79073: LD_EXP 76
79077: PUSH
79078: LD_VAR 0 2
79082: ARRAY
79083: IFFALSE 79097
79085: PUSH
79086: LD_EXP 77
79090: PUSH
79091: LD_VAR 0 2
79095: ARRAY
79096: AND
79097: IFFALSE 79134
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79099: LD_EXP 77
79103: PUSH
79104: LD_VAR 0 2
79108: ARRAY
79109: PUSH
79110: LD_INT 1
79112: ARRAY
79113: PPUSH
79114: CALL_OW 255
79118: PPUSH
79119: LD_EXP 76
79123: PUSH
79124: LD_VAR 0 2
79128: ARRAY
79129: PPUSH
79130: CALL 19473 0 2
79134: GO 79070
79136: POP
79137: POP
// end ;
79138: LD_VAR 0 1
79142: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79143: LD_INT 0
79145: PPUSH
79146: PPUSH
79147: PPUSH
79148: PPUSH
79149: PPUSH
79150: PPUSH
79151: PPUSH
79152: PPUSH
// if not mc_bases or not mc_parking then
79153: LD_EXP 63
79157: NOT
79158: IFTRUE 79167
79160: PUSH
79161: LD_EXP 87
79165: NOT
79166: OR
79167: IFFALSE 79171
// exit ;
79169: GO 79915
// for i = 1 to mc_bases do
79171: LD_ADDR_VAR 0 2
79175: PUSH
79176: DOUBLE
79177: LD_INT 1
79179: DEC
79180: ST_TO_ADDR
79181: LD_EXP 63
79185: PUSH
79186: FOR_TO
79187: IFFALSE 79913
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79189: LD_EXP 63
79193: PUSH
79194: LD_VAR 0 2
79198: ARRAY
79199: NOT
79200: IFTRUE 79215
79202: PUSH
79203: LD_EXP 87
79207: PUSH
79208: LD_VAR 0 2
79212: ARRAY
79213: NOT
79214: OR
79215: IFFALSE 79219
// continue ;
79217: GO 79186
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79219: LD_ADDR_VAR 0 5
79223: PUSH
79224: LD_EXP 63
79228: PUSH
79229: LD_VAR 0 2
79233: ARRAY
79234: PUSH
79235: LD_INT 1
79237: ARRAY
79238: PPUSH
79239: CALL_OW 255
79243: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79244: LD_ADDR_VAR 0 6
79248: PUSH
79249: LD_EXP 63
79253: PUSH
79254: LD_VAR 0 2
79258: ARRAY
79259: PPUSH
79260: LD_INT 30
79262: PUSH
79263: LD_INT 3
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PPUSH
79270: CALL_OW 72
79274: ST_TO_ADDR
// if not fac then
79275: LD_VAR 0 6
79279: NOT
79280: IFFALSE 79331
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79282: LD_ADDR_VAR 0 6
79286: PUSH
79287: LD_EXP 63
79291: PUSH
79292: LD_VAR 0 2
79296: ARRAY
79297: PPUSH
79298: LD_INT 2
79300: PUSH
79301: LD_INT 30
79303: PUSH
79304: LD_INT 0
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: PUSH
79311: LD_INT 30
79313: PUSH
79314: LD_INT 1
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: LIST
79325: PPUSH
79326: CALL_OW 72
79330: ST_TO_ADDR
// if not fac then
79331: LD_VAR 0 6
79335: NOT
79336: IFFALSE 79340
// continue ;
79338: GO 79186
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79340: LD_ADDR_VAR 0 7
79344: PUSH
79345: LD_EXP 87
79349: PUSH
79350: LD_VAR 0 2
79354: ARRAY
79355: PPUSH
79356: LD_INT 22
79358: PUSH
79359: LD_VAR 0 5
79363: PUSH
79364: EMPTY
79365: LIST
79366: LIST
79367: PUSH
79368: LD_INT 21
79370: PUSH
79371: LD_INT 2
79373: PUSH
79374: EMPTY
79375: LIST
79376: LIST
79377: PUSH
79378: LD_INT 3
79380: PUSH
79381: LD_INT 60
79383: PUSH
79384: EMPTY
79385: LIST
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 3
79393: PUSH
79394: LD_INT 24
79396: PUSH
79397: LD_INT 1000
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: PPUSH
79414: CALL_OW 70
79418: ST_TO_ADDR
// for j in fac do
79419: LD_ADDR_VAR 0 3
79423: PUSH
79424: LD_VAR 0 6
79428: PUSH
79429: FOR_IN
79430: IFFALSE 79525
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79432: LD_ADDR_VAR 0 7
79436: PUSH
79437: LD_VAR 0 7
79441: PUSH
79442: LD_INT 22
79444: PUSH
79445: LD_VAR 0 5
79449: PUSH
79450: EMPTY
79451: LIST
79452: LIST
79453: PUSH
79454: LD_INT 91
79456: PUSH
79457: LD_VAR 0 3
79461: PUSH
79462: LD_INT 15
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: LIST
79469: PUSH
79470: LD_INT 21
79472: PUSH
79473: LD_INT 2
79475: PUSH
79476: EMPTY
79477: LIST
79478: LIST
79479: PUSH
79480: LD_INT 3
79482: PUSH
79483: LD_INT 60
79485: PUSH
79486: EMPTY
79487: LIST
79488: PUSH
79489: EMPTY
79490: LIST
79491: LIST
79492: PUSH
79493: LD_INT 3
79495: PUSH
79496: LD_INT 24
79498: PUSH
79499: LD_INT 1000
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: PPUSH
79517: CALL_OW 69
79521: UNION
79522: ST_TO_ADDR
79523: GO 79429
79525: POP
79526: POP
// if not vehs then
79527: LD_VAR 0 7
79531: NOT
79532: IFFALSE 79558
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79534: LD_ADDR_EXP 75
79538: PUSH
79539: LD_EXP 75
79543: PPUSH
79544: LD_VAR 0 2
79548: PPUSH
79549: EMPTY
79550: PPUSH
79551: CALL_OW 1
79555: ST_TO_ADDR
// continue ;
79556: GO 79186
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79558: LD_ADDR_VAR 0 8
79562: PUSH
79563: LD_EXP 63
79567: PUSH
79568: LD_VAR 0 2
79572: ARRAY
79573: PPUSH
79574: LD_INT 30
79576: PUSH
79577: LD_INT 3
79579: PUSH
79580: EMPTY
79581: LIST
79582: LIST
79583: PPUSH
79584: CALL_OW 72
79588: ST_TO_ADDR
// if tmp then
79589: LD_VAR 0 8
79593: IFFALSE 79696
// begin for j in tmp do
79595: LD_ADDR_VAR 0 3
79599: PUSH
79600: LD_VAR 0 8
79604: PUSH
79605: FOR_IN
79606: IFFALSE 79694
// for k in UnitsInside ( j ) do
79608: LD_ADDR_VAR 0 4
79612: PUSH
79613: LD_VAR 0 3
79617: PPUSH
79618: CALL_OW 313
79622: PUSH
79623: FOR_IN
79624: IFFALSE 79690
// if k then
79626: LD_VAR 0 4
79630: IFFALSE 79688
// if not k in mc_repair_vehicle [ i ] then
79632: LD_VAR 0 4
79636: PUSH
79637: LD_EXP 75
79641: PUSH
79642: LD_VAR 0 2
79646: ARRAY
79647: IN
79648: NOT
79649: IFFALSE 79688
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79651: LD_ADDR_EXP 75
79655: PUSH
79656: LD_EXP 75
79660: PPUSH
79661: LD_VAR 0 2
79665: PPUSH
79666: LD_EXP 75
79670: PUSH
79671: LD_VAR 0 2
79675: ARRAY
79676: PUSH
79677: LD_VAR 0 4
79681: UNION
79682: PPUSH
79683: CALL_OW 1
79687: ST_TO_ADDR
79688: GO 79623
79690: POP
79691: POP
79692: GO 79605
79694: POP
79695: POP
// end ; if not mc_repair_vehicle [ i ] then
79696: LD_EXP 75
79700: PUSH
79701: LD_VAR 0 2
79705: ARRAY
79706: NOT
79707: IFFALSE 79711
// continue ;
79709: GO 79186
// for j in mc_repair_vehicle [ i ] do
79711: LD_ADDR_VAR 0 3
79715: PUSH
79716: LD_EXP 75
79720: PUSH
79721: LD_VAR 0 2
79725: ARRAY
79726: PUSH
79727: FOR_IN
79728: IFFALSE 79909
// begin if GetClass ( j ) <> 3 then
79730: LD_VAR 0 3
79734: PPUSH
79735: CALL_OW 257
79739: PUSH
79740: LD_INT 3
79742: NONEQUAL
79743: IFFALSE 79784
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79745: LD_ADDR_EXP 75
79749: PUSH
79750: LD_EXP 75
79754: PPUSH
79755: LD_VAR 0 2
79759: PPUSH
79760: LD_EXP 75
79764: PUSH
79765: LD_VAR 0 2
79769: ARRAY
79770: PUSH
79771: LD_VAR 0 3
79775: DIFF
79776: PPUSH
79777: CALL_OW 1
79781: ST_TO_ADDR
// continue ;
79782: GO 79727
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79784: LD_VAR 0 3
79788: PPUSH
79789: CALL_OW 311
79793: NOT
79794: IFFALSE 79819
79796: PUSH
79797: LD_VAR 0 3
79801: PUSH
79802: LD_EXP 66
79806: PUSH
79807: LD_VAR 0 2
79811: ARRAY
79812: PUSH
79813: LD_INT 1
79815: ARRAY
79816: IN
79817: NOT
79818: AND
79819: IFFALSE 79844
79821: PUSH
79822: LD_VAR 0 3
79826: PUSH
79827: LD_EXP 66
79831: PUSH
79832: LD_VAR 0 2
79836: ARRAY
79837: PUSH
79838: LD_INT 2
79840: ARRAY
79841: IN
79842: NOT
79843: AND
79844: IFFALSE 79907
// begin if IsInUnit ( j ) then
79846: LD_VAR 0 3
79850: PPUSH
79851: CALL_OW 310
79855: IFFALSE 79868
// ComExitBuilding ( j ) else
79857: LD_VAR 0 3
79861: PPUSH
79862: CALL_OW 122
79866: GO 79907
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79868: LD_VAR 0 3
79872: PPUSH
79873: LD_VAR 0 7
79877: PUSH
79878: LD_INT 1
79880: ARRAY
79881: PPUSH
79882: CALL 57695 0 2
79886: NOT
79887: IFFALSE 79907
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79889: LD_VAR 0 3
79893: PPUSH
79894: LD_VAR 0 7
79898: PUSH
79899: LD_INT 1
79901: ARRAY
79902: PPUSH
79903: CALL_OW 129
// end ; end ;
79907: GO 79727
79909: POP
79910: POP
// end ;
79911: GO 79186
79913: POP
79914: POP
// end ;
79915: LD_VAR 0 1
79919: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79920: LD_INT 0
79922: PPUSH
79923: PPUSH
79924: PPUSH
79925: PPUSH
79926: PPUSH
79927: PPUSH
79928: PPUSH
79929: PPUSH
79930: PPUSH
79931: PPUSH
79932: PPUSH
// if not mc_bases then
79933: LD_EXP 63
79937: NOT
79938: IFFALSE 79942
// exit ;
79940: GO 80760
// for i = 1 to mc_bases do
79942: LD_ADDR_VAR 0 2
79946: PUSH
79947: DOUBLE
79948: LD_INT 1
79950: DEC
79951: ST_TO_ADDR
79952: LD_EXP 63
79956: PUSH
79957: FOR_TO
79958: IFFALSE 80758
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
79960: LD_EXP 91
79964: PUSH
79965: LD_VAR 0 2
79969: ARRAY
79970: NOT
79971: IFTRUE 79989
79973: PUSH
79974: LD_EXP 66
79978: PUSH
79979: LD_VAR 0 2
79983: ARRAY
79984: PUSH
79985: LD_INT 1
79987: ARRAY
79988: OR
79989: IFTRUE 80007
79991: PUSH
79992: LD_EXP 66
79996: PUSH
79997: LD_VAR 0 2
80001: ARRAY
80002: PUSH
80003: LD_INT 2
80005: ARRAY
80006: OR
80007: IFTRUE 80030
80009: PUSH
80010: LD_EXP 89
80014: PUSH
80015: LD_VAR 0 2
80019: ARRAY
80020: PPUSH
80021: LD_INT 1
80023: PPUSH
80024: CALL_OW 325
80028: NOT
80029: OR
80030: IFTRUE 80044
80032: PUSH
80033: LD_EXP 86
80037: PUSH
80038: LD_VAR 0 2
80042: ARRAY
80043: OR
80044: IFFALSE 80048
// continue ;
80046: GO 79957
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
80048: LD_ADDR_VAR 0 8
80052: PUSH
80053: LD_EXP 63
80057: PUSH
80058: LD_VAR 0 2
80062: ARRAY
80063: PPUSH
80064: LD_INT 25
80066: PUSH
80067: LD_INT 4
80069: PUSH
80070: EMPTY
80071: LIST
80072: LIST
80073: PUSH
80074: LD_INT 50
80076: PUSH
80077: EMPTY
80078: LIST
80079: PUSH
80080: LD_INT 3
80082: PUSH
80083: LD_INT 60
80085: PUSH
80086: EMPTY
80087: LIST
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: LIST
80097: PPUSH
80098: CALL_OW 72
80102: PUSH
80103: LD_EXP 67
80107: PUSH
80108: LD_VAR 0 2
80112: ARRAY
80113: DIFF
80114: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80115: LD_ADDR_VAR 0 9
80119: PUSH
80120: LD_EXP 63
80124: PUSH
80125: LD_VAR 0 2
80129: ARRAY
80130: PPUSH
80131: LD_INT 2
80133: PUSH
80134: LD_INT 30
80136: PUSH
80137: LD_INT 0
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: PUSH
80144: LD_INT 30
80146: PUSH
80147: LD_INT 1
80149: PUSH
80150: EMPTY
80151: LIST
80152: LIST
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: LIST
80158: PPUSH
80159: CALL_OW 72
80163: ST_TO_ADDR
// if not tmp or not dep then
80164: LD_VAR 0 8
80168: NOT
80169: IFTRUE 80178
80171: PUSH
80172: LD_VAR 0 9
80176: NOT
80177: OR
80178: IFFALSE 80182
// continue ;
80180: GO 79957
// side := GetSide ( tmp [ 1 ] ) ;
80182: LD_ADDR_VAR 0 11
80186: PUSH
80187: LD_VAR 0 8
80191: PUSH
80192: LD_INT 1
80194: ARRAY
80195: PPUSH
80196: CALL_OW 255
80200: ST_TO_ADDR
// dep := dep [ 1 ] ;
80201: LD_ADDR_VAR 0 9
80205: PUSH
80206: LD_VAR 0 9
80210: PUSH
80211: LD_INT 1
80213: ARRAY
80214: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80215: LD_ADDR_VAR 0 7
80219: PUSH
80220: LD_EXP 91
80224: PUSH
80225: LD_VAR 0 2
80229: ARRAY
80230: PPUSH
80231: LD_INT 22
80233: PUSH
80234: LD_INT 0
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 25
80243: PUSH
80244: LD_INT 12
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PPUSH
80255: CALL_OW 70
80259: PUSH
80260: LD_INT 22
80262: PUSH
80263: LD_INT 0
80265: PUSH
80266: EMPTY
80267: LIST
80268: LIST
80269: PUSH
80270: LD_INT 25
80272: PUSH
80273: LD_INT 12
80275: PUSH
80276: EMPTY
80277: LIST
80278: LIST
80279: PUSH
80280: LD_INT 91
80282: PUSH
80283: LD_VAR 0 9
80287: PUSH
80288: LD_INT 20
80290: PUSH
80291: EMPTY
80292: LIST
80293: LIST
80294: LIST
80295: PUSH
80296: EMPTY
80297: LIST
80298: LIST
80299: LIST
80300: PPUSH
80301: CALL_OW 69
80305: UNION
80306: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80307: LD_ADDR_VAR 0 10
80311: PUSH
80312: LD_EXP 91
80316: PUSH
80317: LD_VAR 0 2
80321: ARRAY
80322: PPUSH
80323: LD_INT 81
80325: PUSH
80326: LD_VAR 0 11
80330: PUSH
80331: EMPTY
80332: LIST
80333: LIST
80334: PPUSH
80335: CALL_OW 70
80339: ST_TO_ADDR
// if not apes or danger_at_area then
80340: LD_VAR 0 7
80344: NOT
80345: IFTRUE 80353
80347: PUSH
80348: LD_VAR 0 10
80352: OR
80353: IFFALSE 80403
// begin if mc_taming [ i ] then
80355: LD_EXP 94
80359: PUSH
80360: LD_VAR 0 2
80364: ARRAY
80365: IFFALSE 80401
// begin MC_Reset ( i , 121 ) ;
80367: LD_VAR 0 2
80371: PPUSH
80372: LD_INT 121
80374: PPUSH
80375: CALL 65135 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80379: LD_ADDR_EXP 94
80383: PUSH
80384: LD_EXP 94
80388: PPUSH
80389: LD_VAR 0 2
80393: PPUSH
80394: EMPTY
80395: PPUSH
80396: CALL_OW 1
80400: ST_TO_ADDR
// end ; continue ;
80401: GO 79957
// end ; for j in tmp do
80403: LD_ADDR_VAR 0 3
80407: PUSH
80408: LD_VAR 0 8
80412: PUSH
80413: FOR_IN
80414: IFFALSE 80754
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80416: LD_VAR 0 3
80420: PUSH
80421: LD_EXP 94
80425: PUSH
80426: LD_VAR 0 2
80430: ARRAY
80431: IN
80432: NOT
80433: IFFALSE 80451
80435: PUSH
80436: LD_EXP 94
80440: PUSH
80441: LD_VAR 0 2
80445: ARRAY
80446: PUSH
80447: LD_INT 3
80449: LESS
80450: AND
80451: IFFALSE 80509
// begin SetTag ( j , 121 ) ;
80453: LD_VAR 0 3
80457: PPUSH
80458: LD_INT 121
80460: PPUSH
80461: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80465: LD_ADDR_EXP 94
80469: PUSH
80470: LD_EXP 94
80474: PPUSH
80475: LD_VAR 0 2
80479: PUSH
80480: LD_EXP 94
80484: PUSH
80485: LD_VAR 0 2
80489: ARRAY
80490: PUSH
80491: LD_INT 1
80493: PLUS
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: PPUSH
80499: LD_VAR 0 3
80503: PPUSH
80504: CALL 22554 0 3
80508: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80509: LD_VAR 0 3
80513: PUSH
80514: LD_EXP 94
80518: PUSH
80519: LD_VAR 0 2
80523: ARRAY
80524: IN
80525: IFFALSE 80752
// begin if GetClass ( j ) <> 4 then
80527: LD_VAR 0 3
80531: PPUSH
80532: CALL_OW 257
80536: PUSH
80537: LD_INT 4
80539: NONEQUAL
80540: IFFALSE 80593
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80542: LD_ADDR_EXP 94
80546: PUSH
80547: LD_EXP 94
80551: PPUSH
80552: LD_VAR 0 2
80556: PPUSH
80557: LD_EXP 94
80561: PUSH
80562: LD_VAR 0 2
80566: ARRAY
80567: PUSH
80568: LD_VAR 0 3
80572: DIFF
80573: PPUSH
80574: CALL_OW 1
80578: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80579: LD_VAR 0 3
80583: PPUSH
80584: LD_INT 0
80586: PPUSH
80587: CALL_OW 109
// continue ;
80591: GO 80413
// end ; if IsInUnit ( j ) then
80593: LD_VAR 0 3
80597: PPUSH
80598: CALL_OW 310
80602: IFFALSE 80613
// ComExitBuilding ( j ) ;
80604: LD_VAR 0 3
80608: PPUSH
80609: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80613: LD_ADDR_VAR 0 6
80617: PUSH
80618: LD_VAR 0 7
80622: PPUSH
80623: LD_VAR 0 3
80627: PPUSH
80628: CALL_OW 74
80632: ST_TO_ADDR
// if not ape then
80633: LD_VAR 0 6
80637: NOT
80638: IFFALSE 80642
// break ;
80640: GO 80754
// x := GetX ( ape ) ;
80642: LD_ADDR_VAR 0 4
80646: PUSH
80647: LD_VAR 0 6
80651: PPUSH
80652: CALL_OW 250
80656: ST_TO_ADDR
// y := GetY ( ape ) ;
80657: LD_ADDR_VAR 0 5
80661: PUSH
80662: LD_VAR 0 6
80666: PPUSH
80667: CALL_OW 251
80671: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80672: LD_VAR 0 4
80676: PPUSH
80677: LD_VAR 0 5
80681: PPUSH
80682: CALL_OW 488
80686: NOT
80687: IFTRUE 80717
80689: PUSH
80690: LD_VAR 0 11
80694: PPUSH
80695: LD_VAR 0 4
80699: PPUSH
80700: LD_VAR 0 5
80704: PPUSH
80705: LD_INT 20
80707: PPUSH
80708: CALL 23824 0 4
80712: PUSH
80713: LD_INT 4
80715: ARRAY
80716: OR
80717: IFFALSE 80721
// break ;
80719: GO 80754
// if not HasTask ( j ) then
80721: LD_VAR 0 3
80725: PPUSH
80726: CALL_OW 314
80730: NOT
80731: IFFALSE 80752
// ComTameXY ( j , x , y ) ;
80733: LD_VAR 0 3
80737: PPUSH
80738: LD_VAR 0 4
80742: PPUSH
80743: LD_VAR 0 5
80747: PPUSH
80748: CALL_OW 131
// end ; end ;
80752: GO 80413
80754: POP
80755: POP
// end ;
80756: GO 79957
80758: POP
80759: POP
// end ;
80760: LD_VAR 0 1
80764: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80765: LD_INT 0
80767: PPUSH
80768: PPUSH
80769: PPUSH
80770: PPUSH
80771: PPUSH
80772: PPUSH
80773: PPUSH
80774: PPUSH
// if not mc_bases then
80775: LD_EXP 63
80779: NOT
80780: IFFALSE 80784
// exit ;
80782: GO 81416
// for i = 1 to mc_bases do
80784: LD_ADDR_VAR 0 2
80788: PUSH
80789: DOUBLE
80790: LD_INT 1
80792: DEC
80793: ST_TO_ADDR
80794: LD_EXP 63
80798: PUSH
80799: FOR_TO
80800: IFFALSE 81414
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80802: LD_EXP 92
80806: PUSH
80807: LD_VAR 0 2
80811: ARRAY
80812: NOT
80813: IFTRUE 80843
80815: PUSH
80816: LD_EXP 92
80820: PUSH
80821: LD_VAR 0 2
80825: ARRAY
80826: PPUSH
80827: LD_INT 25
80829: PUSH
80830: LD_INT 12
80832: PUSH
80833: EMPTY
80834: LIST
80835: LIST
80836: PPUSH
80837: CALL_OW 72
80841: NOT
80842: OR
80843: IFFALSE 80847
// continue ;
80845: GO 80799
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80847: LD_ADDR_VAR 0 5
80851: PUSH
80852: LD_EXP 92
80856: PUSH
80857: LD_VAR 0 2
80861: ARRAY
80862: PUSH
80863: LD_INT 1
80865: ARRAY
80866: PPUSH
80867: CALL_OW 255
80871: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80872: LD_VAR 0 5
80876: PPUSH
80877: LD_INT 2
80879: PPUSH
80880: CALL_OW 325
80884: IFFALSE 81137
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80886: LD_ADDR_VAR 0 4
80890: PUSH
80891: LD_EXP 92
80895: PUSH
80896: LD_VAR 0 2
80900: ARRAY
80901: PPUSH
80902: LD_INT 25
80904: PUSH
80905: LD_INT 16
80907: PUSH
80908: EMPTY
80909: LIST
80910: LIST
80911: PPUSH
80912: CALL_OW 72
80916: ST_TO_ADDR
// if tmp < 6 then
80917: LD_VAR 0 4
80921: PUSH
80922: LD_INT 6
80924: LESS
80925: IFFALSE 81137
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80927: LD_ADDR_VAR 0 6
80931: PUSH
80932: LD_EXP 63
80936: PUSH
80937: LD_VAR 0 2
80941: ARRAY
80942: PPUSH
80943: LD_INT 2
80945: PUSH
80946: LD_INT 30
80948: PUSH
80949: LD_INT 0
80951: PUSH
80952: EMPTY
80953: LIST
80954: LIST
80955: PUSH
80956: LD_INT 30
80958: PUSH
80959: LD_INT 1
80961: PUSH
80962: EMPTY
80963: LIST
80964: LIST
80965: PUSH
80966: EMPTY
80967: LIST
80968: LIST
80969: LIST
80970: PPUSH
80971: CALL_OW 72
80975: ST_TO_ADDR
// if depot then
80976: LD_VAR 0 6
80980: IFFALSE 81137
// begin selected := 0 ;
80982: LD_ADDR_VAR 0 7
80986: PUSH
80987: LD_INT 0
80989: ST_TO_ADDR
// for j in depot do
80990: LD_ADDR_VAR 0 3
80994: PUSH
80995: LD_VAR 0 6
80999: PUSH
81000: FOR_IN
81001: IFFALSE 81032
// begin if UnitsInside ( j ) < 6 then
81003: LD_VAR 0 3
81007: PPUSH
81008: CALL_OW 313
81012: PUSH
81013: LD_INT 6
81015: LESS
81016: IFFALSE 81030
// begin selected := j ;
81018: LD_ADDR_VAR 0 7
81022: PUSH
81023: LD_VAR 0 3
81027: ST_TO_ADDR
// break ;
81028: GO 81032
// end ; end ;
81030: GO 81000
81032: POP
81033: POP
// if selected then
81034: LD_VAR 0 7
81038: IFFALSE 81137
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81040: LD_ADDR_VAR 0 3
81044: PUSH
81045: LD_EXP 92
81049: PUSH
81050: LD_VAR 0 2
81054: ARRAY
81055: PPUSH
81056: LD_INT 25
81058: PUSH
81059: LD_INT 12
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PPUSH
81066: CALL_OW 72
81070: PUSH
81071: FOR_IN
81072: IFFALSE 81135
// if not HasTask ( j ) then
81074: LD_VAR 0 3
81078: PPUSH
81079: CALL_OW 314
81083: NOT
81084: IFFALSE 81133
// begin if not IsInUnit ( j ) then
81086: LD_VAR 0 3
81090: PPUSH
81091: CALL_OW 310
81095: NOT
81096: IFFALSE 81112
// ComEnterUnit ( j , selected ) ;
81098: LD_VAR 0 3
81102: PPUSH
81103: LD_VAR 0 7
81107: PPUSH
81108: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81112: LD_VAR 0 3
81116: PPUSH
81117: LD_INT 16
81119: PPUSH
81120: CALL_OW 183
// AddComExitBuilding ( j ) ;
81124: LD_VAR 0 3
81128: PPUSH
81129: CALL_OW 182
// end ;
81133: GO 81071
81135: POP
81136: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81137: LD_VAR 0 5
81141: PPUSH
81142: LD_INT 11
81144: PPUSH
81145: CALL_OW 325
81149: IFFALSE 81412
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81151: LD_ADDR_VAR 0 4
81155: PUSH
81156: LD_EXP 92
81160: PUSH
81161: LD_VAR 0 2
81165: ARRAY
81166: PPUSH
81167: LD_INT 25
81169: PUSH
81170: LD_INT 16
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PPUSH
81177: CALL_OW 72
81181: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81182: LD_VAR 0 4
81186: PUSH
81187: LD_INT 6
81189: GREATEREQUAL
81190: IFTRUE 81207
81192: PUSH
81193: LD_VAR 0 5
81197: PPUSH
81198: LD_INT 2
81200: PPUSH
81201: CALL_OW 325
81205: NOT
81206: OR
81207: IFFALSE 81412
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81209: LD_ADDR_VAR 0 8
81213: PUSH
81214: LD_EXP 63
81218: PUSH
81219: LD_VAR 0 2
81223: ARRAY
81224: PPUSH
81225: LD_INT 2
81227: PUSH
81228: LD_INT 30
81230: PUSH
81231: LD_INT 4
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 30
81240: PUSH
81241: LD_INT 5
81243: PUSH
81244: EMPTY
81245: LIST
81246: LIST
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: LIST
81252: PPUSH
81253: CALL_OW 72
81257: ST_TO_ADDR
// if barracks then
81258: LD_VAR 0 8
81262: IFFALSE 81412
// begin selected := 0 ;
81264: LD_ADDR_VAR 0 7
81268: PUSH
81269: LD_INT 0
81271: ST_TO_ADDR
// for j in barracks do
81272: LD_ADDR_VAR 0 3
81276: PUSH
81277: LD_VAR 0 8
81281: PUSH
81282: FOR_IN
81283: IFFALSE 81314
// begin if UnitsInside ( j ) < 6 then
81285: LD_VAR 0 3
81289: PPUSH
81290: CALL_OW 313
81294: PUSH
81295: LD_INT 6
81297: LESS
81298: IFFALSE 81312
// begin selected := j ;
81300: LD_ADDR_VAR 0 7
81304: PUSH
81305: LD_VAR 0 3
81309: ST_TO_ADDR
// break ;
81310: GO 81314
// end ; end ;
81312: GO 81282
81314: POP
81315: POP
// if selected then
81316: LD_VAR 0 7
81320: IFFALSE 81412
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81322: LD_ADDR_VAR 0 3
81326: PUSH
81327: LD_EXP 92
81331: PUSH
81332: LD_VAR 0 2
81336: ARRAY
81337: PPUSH
81338: LD_INT 25
81340: PUSH
81341: LD_INT 12
81343: PUSH
81344: EMPTY
81345: LIST
81346: LIST
81347: PPUSH
81348: CALL_OW 72
81352: PUSH
81353: FOR_IN
81354: IFFALSE 81410
// if not IsInUnit ( j ) and not HasTask ( j ) then
81356: LD_VAR 0 3
81360: PPUSH
81361: CALL_OW 310
81365: NOT
81366: IFFALSE 81380
81368: PUSH
81369: LD_VAR 0 3
81373: PPUSH
81374: CALL_OW 314
81378: NOT
81379: AND
81380: IFFALSE 81408
// begin ComEnterUnit ( j , selected ) ;
81382: LD_VAR 0 3
81386: PPUSH
81387: LD_VAR 0 7
81391: PPUSH
81392: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81396: LD_VAR 0 3
81400: PPUSH
81401: LD_INT 15
81403: PPUSH
81404: CALL_OW 183
// end ;
81408: GO 81353
81410: POP
81411: POP
// end ; end ; end ; end ; end ;
81412: GO 80799
81414: POP
81415: POP
// end ;
81416: LD_VAR 0 1
81420: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81421: LD_INT 0
81423: PPUSH
81424: PPUSH
81425: PPUSH
81426: PPUSH
// if not mc_bases then
81427: LD_EXP 63
81431: NOT
81432: IFFALSE 81436
// exit ;
81434: GO 81618
// for i = 1 to mc_bases do
81436: LD_ADDR_VAR 0 2
81440: PUSH
81441: DOUBLE
81442: LD_INT 1
81444: DEC
81445: ST_TO_ADDR
81446: LD_EXP 63
81450: PUSH
81451: FOR_TO
81452: IFFALSE 81616
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81454: LD_ADDR_VAR 0 4
81458: PUSH
81459: LD_EXP 63
81463: PUSH
81464: LD_VAR 0 2
81468: ARRAY
81469: PPUSH
81470: LD_INT 25
81472: PUSH
81473: LD_INT 9
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PPUSH
81480: CALL_OW 72
81484: ST_TO_ADDR
// if not tmp then
81485: LD_VAR 0 4
81489: NOT
81490: IFFALSE 81494
// continue ;
81492: GO 81451
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81494: LD_EXP 89
81498: PUSH
81499: LD_VAR 0 2
81503: ARRAY
81504: PPUSH
81505: LD_INT 29
81507: PPUSH
81508: CALL_OW 325
81512: NOT
81513: IFFALSE 81536
81515: PUSH
81516: LD_EXP 89
81520: PUSH
81521: LD_VAR 0 2
81525: ARRAY
81526: PPUSH
81527: LD_INT 28
81529: PPUSH
81530: CALL_OW 325
81534: NOT
81535: AND
81536: IFFALSE 81540
// continue ;
81538: GO 81451
// for j in tmp do
81540: LD_ADDR_VAR 0 3
81544: PUSH
81545: LD_VAR 0 4
81549: PUSH
81550: FOR_IN
81551: IFFALSE 81612
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81553: LD_VAR 0 3
81557: PUSH
81558: LD_EXP 66
81562: PUSH
81563: LD_VAR 0 2
81567: ARRAY
81568: PUSH
81569: LD_INT 1
81571: ARRAY
81572: IN
81573: NOT
81574: IFFALSE 81599
81576: PUSH
81577: LD_VAR 0 3
81581: PUSH
81582: LD_EXP 66
81586: PUSH
81587: LD_VAR 0 2
81591: ARRAY
81592: PUSH
81593: LD_INT 2
81595: ARRAY
81596: IN
81597: NOT
81598: AND
81599: IFFALSE 81610
// ComSpaceTimeShoot ( j ) ;
81601: LD_VAR 0 3
81605: PPUSH
81606: CALL 18471 0 1
81610: GO 81550
81612: POP
81613: POP
// end ;
81614: GO 81451
81616: POP
81617: POP
// end ;
81618: LD_VAR 0 1
81622: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81623: LD_INT 0
81625: PPUSH
81626: PPUSH
81627: PPUSH
81628: PPUSH
81629: PPUSH
81630: PPUSH
81631: PPUSH
81632: PPUSH
81633: PPUSH
// if not mc_bases then
81634: LD_EXP 63
81638: NOT
81639: IFFALSE 81643
// exit ;
81641: GO 82275
// for i = 1 to mc_bases do
81643: LD_ADDR_VAR 0 2
81647: PUSH
81648: DOUBLE
81649: LD_INT 1
81651: DEC
81652: ST_TO_ADDR
81653: LD_EXP 63
81657: PUSH
81658: FOR_TO
81659: IFFALSE 82273
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81661: LD_EXP 98
81665: PUSH
81666: LD_VAR 0 2
81670: ARRAY
81671: NOT
81672: IFTRUE 81698
81674: PUSH
81675: LD_INT 38
81677: PPUSH
81678: LD_EXP 89
81682: PUSH
81683: LD_VAR 0 2
81687: ARRAY
81688: PPUSH
81689: CALL_OW 321
81693: PUSH
81694: LD_INT 2
81696: NONEQUAL
81697: OR
81698: IFFALSE 81702
// continue ;
81700: GO 81658
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81702: LD_ADDR_VAR 0 8
81706: PUSH
81707: LD_EXP 63
81711: PUSH
81712: LD_VAR 0 2
81716: ARRAY
81717: PPUSH
81718: LD_INT 30
81720: PUSH
81721: LD_INT 34
81723: PUSH
81724: EMPTY
81725: LIST
81726: LIST
81727: PPUSH
81728: CALL_OW 72
81732: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81733: LD_ADDR_VAR 0 9
81737: PUSH
81738: LD_EXP 63
81742: PUSH
81743: LD_VAR 0 2
81747: ARRAY
81748: PPUSH
81749: LD_INT 25
81751: PUSH
81752: LD_INT 4
81754: PUSH
81755: EMPTY
81756: LIST
81757: LIST
81758: PPUSH
81759: CALL_OW 72
81763: PPUSH
81764: LD_INT 0
81766: PPUSH
81767: CALL 53157 0 2
81771: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81772: LD_VAR 0 9
81776: NOT
81777: IFTRUE 81786
81779: PUSH
81780: LD_VAR 0 8
81784: NOT
81785: OR
81786: IFTRUE 81808
81788: PUSH
81789: LD_EXP 63
81793: PUSH
81794: LD_VAR 0 2
81798: ARRAY
81799: PPUSH
81800: LD_INT 124
81802: PPUSH
81803: CALL 53157 0 2
81807: OR
81808: IFFALSE 81812
// continue ;
81810: GO 81658
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81812: LD_EXP 99
81816: PUSH
81817: LD_VAR 0 2
81821: ARRAY
81822: PUSH
81823: LD_EXP 98
81827: PUSH
81828: LD_VAR 0 2
81832: ARRAY
81833: LESS
81834: IFFALSE 81854
81836: PUSH
81837: LD_EXP 99
81841: PUSH
81842: LD_VAR 0 2
81846: ARRAY
81847: PUSH
81848: LD_VAR 0 8
81852: LESS
81853: AND
81854: IFFALSE 82271
// begin tmp := sci [ 1 ] ;
81856: LD_ADDR_VAR 0 7
81860: PUSH
81861: LD_VAR 0 9
81865: PUSH
81866: LD_INT 1
81868: ARRAY
81869: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81870: LD_VAR 0 7
81874: PPUSH
81875: LD_INT 124
81877: PPUSH
81878: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81882: LD_ADDR_VAR 0 3
81886: PUSH
81887: DOUBLE
81888: LD_EXP 98
81892: PUSH
81893: LD_VAR 0 2
81897: ARRAY
81898: INC
81899: ST_TO_ADDR
81900: LD_EXP 98
81904: PUSH
81905: LD_VAR 0 2
81909: ARRAY
81910: PUSH
81911: FOR_DOWNTO
81912: IFFALSE 82257
// begin if IsInUnit ( tmp ) then
81914: LD_VAR 0 7
81918: PPUSH
81919: CALL_OW 310
81923: IFFALSE 81934
// ComExitBuilding ( tmp ) ;
81925: LD_VAR 0 7
81929: PPUSH
81930: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81934: LD_INT 35
81936: PPUSH
81937: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81941: LD_VAR 0 7
81945: PPUSH
81946: CALL_OW 310
81950: NOT
81951: IFFALSE 81965
81953: PUSH
81954: LD_VAR 0 7
81958: PPUSH
81959: CALL_OW 314
81963: NOT
81964: AND
81965: IFFALSE 81934
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81967: LD_ADDR_VAR 0 6
81971: PUSH
81972: LD_VAR 0 7
81976: PPUSH
81977: CALL_OW 250
81981: PUSH
81982: LD_VAR 0 7
81986: PPUSH
81987: CALL_OW 251
81991: PUSH
81992: EMPTY
81993: LIST
81994: LIST
81995: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
81996: LD_INT 35
81998: PPUSH
81999: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
82003: LD_ADDR_VAR 0 4
82007: PUSH
82008: LD_EXP 98
82012: PUSH
82013: LD_VAR 0 2
82017: ARRAY
82018: PUSH
82019: LD_VAR 0 3
82023: ARRAY
82024: PUSH
82025: LD_INT 1
82027: ARRAY
82028: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
82029: LD_ADDR_VAR 0 5
82033: PUSH
82034: LD_EXP 98
82038: PUSH
82039: LD_VAR 0 2
82043: ARRAY
82044: PUSH
82045: LD_VAR 0 3
82049: ARRAY
82050: PUSH
82051: LD_INT 2
82053: ARRAY
82054: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
82055: LD_VAR 0 7
82059: PPUSH
82060: LD_INT 10
82062: PPUSH
82063: CALL 25533 0 2
82067: PUSH
82068: LD_INT 4
82070: ARRAY
82071: IFFALSE 82109
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82073: LD_VAR 0 7
82077: PPUSH
82078: LD_VAR 0 6
82082: PUSH
82083: LD_INT 1
82085: ARRAY
82086: PPUSH
82087: LD_VAR 0 6
82091: PUSH
82092: LD_INT 2
82094: ARRAY
82095: PPUSH
82096: CALL_OW 111
// wait ( 0 0$10 ) ;
82100: LD_INT 350
82102: PPUSH
82103: CALL_OW 67
// end else
82107: GO 82135
// begin ComMoveXY ( tmp , x , y ) ;
82109: LD_VAR 0 7
82113: PPUSH
82114: LD_VAR 0 4
82118: PPUSH
82119: LD_VAR 0 5
82123: PPUSH
82124: CALL_OW 111
// wait ( 0 0$3 ) ;
82128: LD_INT 105
82130: PPUSH
82131: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82135: LD_VAR 0 7
82139: PPUSH
82140: LD_VAR 0 4
82144: PPUSH
82145: LD_VAR 0 5
82149: PPUSH
82150: CALL_OW 307
82154: IFFALSE 81996
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82156: LD_VAR 0 7
82160: PPUSH
82161: LD_VAR 0 4
82165: PPUSH
82166: LD_VAR 0 5
82170: PPUSH
82171: LD_VAR 0 8
82175: PUSH
82176: LD_VAR 0 3
82180: ARRAY
82181: PPUSH
82182: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82186: LD_INT 35
82188: PPUSH
82189: CALL_OW 67
// until not HasTask ( tmp ) ;
82193: LD_VAR 0 7
82197: PPUSH
82198: CALL_OW 314
82202: NOT
82203: IFFALSE 82186
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82205: LD_ADDR_EXP 99
82209: PUSH
82210: LD_EXP 99
82214: PPUSH
82215: LD_VAR 0 2
82219: PUSH
82220: LD_EXP 99
82224: PUSH
82225: LD_VAR 0 2
82229: ARRAY
82230: PUSH
82231: LD_INT 1
82233: PLUS
82234: PUSH
82235: EMPTY
82236: LIST
82237: LIST
82238: PPUSH
82239: LD_VAR 0 8
82243: PUSH
82244: LD_VAR 0 3
82248: ARRAY
82249: PPUSH
82250: CALL 22554 0 3
82254: ST_TO_ADDR
// end ;
82255: GO 81911
82257: POP
82258: POP
// MC_Reset ( i , 124 ) ;
82259: LD_VAR 0 2
82263: PPUSH
82264: LD_INT 124
82266: PPUSH
82267: CALL 65135 0 2
// end ; end ;
82271: GO 81658
82273: POP
82274: POP
// end ;
82275: LD_VAR 0 1
82279: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82280: LD_INT 0
82282: PPUSH
82283: PPUSH
82284: PPUSH
// if not mc_bases then
82285: LD_EXP 63
82289: NOT
82290: IFFALSE 82294
// exit ;
82292: GO 82908
// for i = 1 to mc_bases do
82294: LD_ADDR_VAR 0 2
82298: PUSH
82299: DOUBLE
82300: LD_INT 1
82302: DEC
82303: ST_TO_ADDR
82304: LD_EXP 63
82308: PUSH
82309: FOR_TO
82310: IFFALSE 82906
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82312: LD_ADDR_VAR 0 3
82316: PUSH
82317: LD_EXP 63
82321: PUSH
82322: LD_VAR 0 2
82326: ARRAY
82327: PPUSH
82328: LD_INT 25
82330: PUSH
82331: LD_INT 4
82333: PUSH
82334: EMPTY
82335: LIST
82336: LIST
82337: PPUSH
82338: CALL_OW 72
82342: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82343: LD_VAR 0 3
82347: NOT
82348: IFTRUE 82363
82350: PUSH
82351: LD_EXP 100
82355: PUSH
82356: LD_VAR 0 2
82360: ARRAY
82361: NOT
82362: OR
82363: IFTRUE 82411
82365: PUSH
82366: LD_EXP 63
82370: PUSH
82371: LD_VAR 0 2
82375: ARRAY
82376: PPUSH
82377: LD_INT 2
82379: PUSH
82380: LD_INT 30
82382: PUSH
82383: LD_INT 0
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 30
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: EMPTY
82401: LIST
82402: LIST
82403: LIST
82404: PPUSH
82405: CALL_OW 72
82409: NOT
82410: OR
82411: IFFALSE 82461
// begin if mc_deposits_finder [ i ] then
82413: LD_EXP 101
82417: PUSH
82418: LD_VAR 0 2
82422: ARRAY
82423: IFFALSE 82459
// begin MC_Reset ( i , 125 ) ;
82425: LD_VAR 0 2
82429: PPUSH
82430: LD_INT 125
82432: PPUSH
82433: CALL 65135 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82437: LD_ADDR_EXP 101
82441: PUSH
82442: LD_EXP 101
82446: PPUSH
82447: LD_VAR 0 2
82451: PPUSH
82452: EMPTY
82453: PPUSH
82454: CALL_OW 1
82458: ST_TO_ADDR
// end ; continue ;
82459: GO 82309
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82461: LD_EXP 100
82465: PUSH
82466: LD_VAR 0 2
82470: ARRAY
82471: PUSH
82472: LD_INT 1
82474: ARRAY
82475: PUSH
82476: LD_INT 3
82478: ARRAY
82479: PUSH
82480: LD_INT 1
82482: EQUAL
82483: IFFALSE 82509
82485: PUSH
82486: LD_INT 20
82488: PPUSH
82489: LD_EXP 89
82493: PUSH
82494: LD_VAR 0 2
82498: ARRAY
82499: PPUSH
82500: CALL_OW 321
82504: PUSH
82505: LD_INT 2
82507: NONEQUAL
82508: AND
82509: IFFALSE 82559
// begin if mc_deposits_finder [ i ] then
82511: LD_EXP 101
82515: PUSH
82516: LD_VAR 0 2
82520: ARRAY
82521: IFFALSE 82557
// begin MC_Reset ( i , 125 ) ;
82523: LD_VAR 0 2
82527: PPUSH
82528: LD_INT 125
82530: PPUSH
82531: CALL 65135 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82535: LD_ADDR_EXP 101
82539: PUSH
82540: LD_EXP 101
82544: PPUSH
82545: LD_VAR 0 2
82549: PPUSH
82550: EMPTY
82551: PPUSH
82552: CALL_OW 1
82556: ST_TO_ADDR
// end ; continue ;
82557: GO 82309
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82559: LD_EXP 100
82563: PUSH
82564: LD_VAR 0 2
82568: ARRAY
82569: PUSH
82570: LD_INT 1
82572: ARRAY
82573: PUSH
82574: LD_INT 1
82576: ARRAY
82577: PPUSH
82578: LD_EXP 100
82582: PUSH
82583: LD_VAR 0 2
82587: ARRAY
82588: PUSH
82589: LD_INT 1
82591: ARRAY
82592: PUSH
82593: LD_INT 2
82595: ARRAY
82596: PPUSH
82597: LD_EXP 89
82601: PUSH
82602: LD_VAR 0 2
82606: ARRAY
82607: PPUSH
82608: CALL_OW 440
82612: IFFALSE 82655
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82614: LD_ADDR_EXP 100
82618: PUSH
82619: LD_EXP 100
82623: PPUSH
82624: LD_VAR 0 2
82628: PPUSH
82629: LD_EXP 100
82633: PUSH
82634: LD_VAR 0 2
82638: ARRAY
82639: PPUSH
82640: LD_INT 1
82642: PPUSH
82643: CALL_OW 3
82647: PPUSH
82648: CALL_OW 1
82652: ST_TO_ADDR
82653: GO 82904
// begin if not mc_deposits_finder [ i ] then
82655: LD_EXP 101
82659: PUSH
82660: LD_VAR 0 2
82664: ARRAY
82665: NOT
82666: IFFALSE 82718
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82668: LD_ADDR_EXP 101
82672: PUSH
82673: LD_EXP 101
82677: PPUSH
82678: LD_VAR 0 2
82682: PPUSH
82683: LD_VAR 0 3
82687: PUSH
82688: LD_INT 1
82690: ARRAY
82691: PUSH
82692: EMPTY
82693: LIST
82694: PPUSH
82695: CALL_OW 1
82699: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82700: LD_VAR 0 3
82704: PUSH
82705: LD_INT 1
82707: ARRAY
82708: PPUSH
82709: LD_INT 125
82711: PPUSH
82712: CALL_OW 109
// end else
82716: GO 82904
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82718: LD_EXP 101
82722: PUSH
82723: LD_VAR 0 2
82727: ARRAY
82728: PUSH
82729: LD_INT 1
82731: ARRAY
82732: PPUSH
82733: CALL_OW 310
82737: IFFALSE 82760
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82739: LD_EXP 101
82743: PUSH
82744: LD_VAR 0 2
82748: ARRAY
82749: PUSH
82750: LD_INT 1
82752: ARRAY
82753: PPUSH
82754: CALL_OW 122
82758: GO 82904
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82760: LD_EXP 101
82764: PUSH
82765: LD_VAR 0 2
82769: ARRAY
82770: PUSH
82771: LD_INT 1
82773: ARRAY
82774: PPUSH
82775: CALL_OW 314
82779: NOT
82780: IFFALSE 82845
82782: PUSH
82783: LD_EXP 101
82787: PUSH
82788: LD_VAR 0 2
82792: ARRAY
82793: PUSH
82794: LD_INT 1
82796: ARRAY
82797: PPUSH
82798: LD_EXP 100
82802: PUSH
82803: LD_VAR 0 2
82807: ARRAY
82808: PUSH
82809: LD_INT 1
82811: ARRAY
82812: PUSH
82813: LD_INT 1
82815: ARRAY
82816: PPUSH
82817: LD_EXP 100
82821: PUSH
82822: LD_VAR 0 2
82826: ARRAY
82827: PUSH
82828: LD_INT 1
82830: ARRAY
82831: PUSH
82832: LD_INT 2
82834: ARRAY
82835: PPUSH
82836: CALL_OW 297
82840: PUSH
82841: LD_INT 6
82843: GREATER
82844: AND
82845: IFFALSE 82904
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82847: LD_EXP 101
82851: PUSH
82852: LD_VAR 0 2
82856: ARRAY
82857: PUSH
82858: LD_INT 1
82860: ARRAY
82861: PPUSH
82862: LD_EXP 100
82866: PUSH
82867: LD_VAR 0 2
82871: ARRAY
82872: PUSH
82873: LD_INT 1
82875: ARRAY
82876: PUSH
82877: LD_INT 1
82879: ARRAY
82880: PPUSH
82881: LD_EXP 100
82885: PUSH
82886: LD_VAR 0 2
82890: ARRAY
82891: PUSH
82892: LD_INT 1
82894: ARRAY
82895: PUSH
82896: LD_INT 2
82898: ARRAY
82899: PPUSH
82900: CALL_OW 111
// end ; end ; end ;
82904: GO 82309
82906: POP
82907: POP
// end ;
82908: LD_VAR 0 1
82912: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82913: LD_INT 0
82915: PPUSH
82916: PPUSH
82917: PPUSH
82918: PPUSH
82919: PPUSH
82920: PPUSH
82921: PPUSH
82922: PPUSH
82923: PPUSH
82924: PPUSH
82925: PPUSH
// if not mc_bases then
82926: LD_EXP 63
82930: NOT
82931: IFFALSE 82935
// exit ;
82933: GO 83895
// for i = 1 to mc_bases do
82935: LD_ADDR_VAR 0 2
82939: PUSH
82940: DOUBLE
82941: LD_INT 1
82943: DEC
82944: ST_TO_ADDR
82945: LD_EXP 63
82949: PUSH
82950: FOR_TO
82951: IFFALSE 83893
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82953: LD_EXP 63
82957: PUSH
82958: LD_VAR 0 2
82962: ARRAY
82963: NOT
82964: IFTRUE 82978
82966: PUSH
82967: LD_EXP 86
82971: PUSH
82972: LD_VAR 0 2
82976: ARRAY
82977: OR
82978: IFFALSE 82982
// continue ;
82980: GO 82950
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82982: LD_ADDR_VAR 0 7
82986: PUSH
82987: LD_EXP 63
82991: PUSH
82992: LD_VAR 0 2
82996: ARRAY
82997: PUSH
82998: LD_INT 1
83000: ARRAY
83001: PPUSH
83002: CALL_OW 248
83006: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
83007: LD_VAR 0 7
83011: PUSH
83012: LD_INT 3
83014: EQUAL
83015: IFTRUE 83057
83017: PUSH
83018: LD_EXP 82
83022: PUSH
83023: LD_VAR 0 2
83027: ARRAY
83028: PUSH
83029: LD_EXP 85
83033: PUSH
83034: LD_VAR 0 2
83038: ARRAY
83039: UNION
83040: PPUSH
83041: LD_INT 33
83043: PUSH
83044: LD_INT 2
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PPUSH
83051: CALL_OW 72
83055: NOT
83056: OR
83057: IFFALSE 83061
// continue ;
83059: GO 82950
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83061: LD_ADDR_VAR 0 9
83065: PUSH
83066: LD_EXP 63
83070: PUSH
83071: LD_VAR 0 2
83075: ARRAY
83076: PPUSH
83077: LD_INT 30
83079: PUSH
83080: LD_INT 36
83082: PUSH
83083: EMPTY
83084: LIST
83085: LIST
83086: PPUSH
83087: CALL_OW 72
83091: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83092: LD_ADDR_VAR 0 10
83096: PUSH
83097: LD_EXP 82
83101: PUSH
83102: LD_VAR 0 2
83106: ARRAY
83107: PPUSH
83108: LD_INT 34
83110: PUSH
83111: LD_INT 31
83113: PUSH
83114: EMPTY
83115: LIST
83116: LIST
83117: PPUSH
83118: CALL_OW 72
83122: ST_TO_ADDR
// if not cts and not mcts then
83123: LD_VAR 0 9
83127: NOT
83128: IFFALSE 83137
83130: PUSH
83131: LD_VAR 0 10
83135: NOT
83136: AND
83137: IFFALSE 83141
// continue ;
83139: GO 82950
// x := cts ;
83141: LD_ADDR_VAR 0 11
83145: PUSH
83146: LD_VAR 0 9
83150: ST_TO_ADDR
// if not x then
83151: LD_VAR 0 11
83155: NOT
83156: IFFALSE 83168
// x := mcts ;
83158: LD_ADDR_VAR 0 11
83162: PUSH
83163: LD_VAR 0 10
83167: ST_TO_ADDR
// if not x then
83168: LD_VAR 0 11
83172: NOT
83173: IFFALSE 83177
// continue ;
83175: GO 82950
// if mc_remote_driver [ i ] then
83177: LD_EXP 103
83181: PUSH
83182: LD_VAR 0 2
83186: ARRAY
83187: IFFALSE 83586
// for j in mc_remote_driver [ i ] do
83189: LD_ADDR_VAR 0 3
83193: PUSH
83194: LD_EXP 103
83198: PUSH
83199: LD_VAR 0 2
83203: ARRAY
83204: PUSH
83205: FOR_IN
83206: IFFALSE 83584
// begin if GetClass ( j ) <> 3 then
83208: LD_VAR 0 3
83212: PPUSH
83213: CALL_OW 257
83217: PUSH
83218: LD_INT 3
83220: NONEQUAL
83221: IFFALSE 83274
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83223: LD_ADDR_EXP 103
83227: PUSH
83228: LD_EXP 103
83232: PPUSH
83233: LD_VAR 0 2
83237: PPUSH
83238: LD_EXP 103
83242: PUSH
83243: LD_VAR 0 2
83247: ARRAY
83248: PUSH
83249: LD_VAR 0 3
83253: DIFF
83254: PPUSH
83255: CALL_OW 1
83259: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83260: LD_VAR 0 3
83264: PPUSH
83265: LD_INT 0
83267: PPUSH
83268: CALL_OW 109
// continue ;
83272: GO 83205
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83274: LD_EXP 82
83278: PUSH
83279: LD_VAR 0 2
83283: ARRAY
83284: PPUSH
83285: LD_INT 34
83287: PUSH
83288: LD_INT 31
83290: PUSH
83291: EMPTY
83292: LIST
83293: LIST
83294: PUSH
83295: LD_INT 58
83297: PUSH
83298: EMPTY
83299: LIST
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PPUSH
83305: CALL_OW 72
83309: IFFALSE 83323
83311: PUSH
83312: LD_VAR 0 3
83316: PPUSH
83317: CALL 53192 0 1
83321: NOT
83322: AND
83323: IFFALSE 83394
// begin if IsInUnit ( j ) then
83325: LD_VAR 0 3
83329: PPUSH
83330: CALL_OW 310
83334: IFFALSE 83345
// ComExitBuilding ( j ) ;
83336: LD_VAR 0 3
83340: PPUSH
83341: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83345: LD_VAR 0 3
83349: PPUSH
83350: LD_EXP 82
83354: PUSH
83355: LD_VAR 0 2
83359: ARRAY
83360: PPUSH
83361: LD_INT 34
83363: PUSH
83364: LD_INT 31
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 58
83373: PUSH
83374: EMPTY
83375: LIST
83376: PUSH
83377: EMPTY
83378: LIST
83379: LIST
83380: PPUSH
83381: CALL_OW 72
83385: PUSH
83386: LD_INT 1
83388: ARRAY
83389: PPUSH
83390: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83394: LD_VAR 0 3
83398: PPUSH
83399: CALL_OW 310
83403: NOT
83404: IFTRUE 83440
83406: PUSH
83407: LD_VAR 0 3
83411: PPUSH
83412: CALL_OW 310
83416: PPUSH
83417: CALL_OW 266
83421: PUSH
83422: LD_INT 36
83424: NONEQUAL
83425: IFFALSE 83439
83427: PUSH
83428: LD_VAR 0 3
83432: PPUSH
83433: CALL 53192 0 1
83437: NOT
83438: AND
83439: OR
83440: IFFALSE 83582
// begin if IsInUnit ( j ) then
83442: LD_VAR 0 3
83446: PPUSH
83447: CALL_OW 310
83451: IFFALSE 83462
// ComExitBuilding ( j ) ;
83453: LD_VAR 0 3
83457: PPUSH
83458: CALL_OW 122
// ct := 0 ;
83462: LD_ADDR_VAR 0 8
83466: PUSH
83467: LD_INT 0
83469: ST_TO_ADDR
// for k in x do
83470: LD_ADDR_VAR 0 4
83474: PUSH
83475: LD_VAR 0 11
83479: PUSH
83480: FOR_IN
83481: IFFALSE 83560
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83483: LD_VAR 0 4
83487: PPUSH
83488: CALL_OW 264
83492: PUSH
83493: LD_INT 31
83495: EQUAL
83496: IFFALSE 83510
83498: PUSH
83499: LD_VAR 0 4
83503: PPUSH
83504: CALL_OW 311
83508: NOT
83509: AND
83510: IFTRUE 83544
83512: PUSH
83513: LD_VAR 0 4
83517: PPUSH
83518: CALL_OW 266
83522: PUSH
83523: LD_INT 36
83525: EQUAL
83526: IFFALSE 83543
83528: PUSH
83529: LD_VAR 0 4
83533: PPUSH
83534: CALL_OW 313
83538: PUSH
83539: LD_INT 3
83541: LESS
83542: AND
83543: OR
83544: IFFALSE 83558
// begin ct := k ;
83546: LD_ADDR_VAR 0 8
83550: PUSH
83551: LD_VAR 0 4
83555: ST_TO_ADDR
// break ;
83556: GO 83560
// end ;
83558: GO 83480
83560: POP
83561: POP
// if ct then
83562: LD_VAR 0 8
83566: IFFALSE 83582
// ComEnterUnit ( j , ct ) ;
83568: LD_VAR 0 3
83572: PPUSH
83573: LD_VAR 0 8
83577: PPUSH
83578: CALL_OW 120
// end ; end ;
83582: GO 83205
83584: POP
83585: POP
// places := 0 ;
83586: LD_ADDR_VAR 0 5
83590: PUSH
83591: LD_INT 0
83593: ST_TO_ADDR
// for j = 1 to x do
83594: LD_ADDR_VAR 0 3
83598: PUSH
83599: DOUBLE
83600: LD_INT 1
83602: DEC
83603: ST_TO_ADDR
83604: LD_VAR 0 11
83608: PUSH
83609: FOR_TO
83610: IFFALSE 83686
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83612: LD_VAR 0 11
83616: PUSH
83617: LD_VAR 0 3
83621: ARRAY
83622: PPUSH
83623: CALL_OW 264
83627: PUSH
83628: LD_INT 31
83630: EQUAL
83631: IFFALSE 83649
// places := places + 1 else
83633: LD_ADDR_VAR 0 5
83637: PUSH
83638: LD_VAR 0 5
83642: PUSH
83643: LD_INT 1
83645: PLUS
83646: ST_TO_ADDR
83647: GO 83684
// if GetBType ( x [ j ] ) = b_control_tower then
83649: LD_VAR 0 11
83653: PUSH
83654: LD_VAR 0 3
83658: ARRAY
83659: PPUSH
83660: CALL_OW 266
83664: PUSH
83665: LD_INT 36
83667: EQUAL
83668: IFFALSE 83684
// places := places + 3 ;
83670: LD_ADDR_VAR 0 5
83674: PUSH
83675: LD_VAR 0 5
83679: PUSH
83680: LD_INT 3
83682: PLUS
83683: ST_TO_ADDR
83684: GO 83609
83686: POP
83687: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83688: LD_VAR 0 5
83692: PUSH
83693: LD_INT 0
83695: EQUAL
83696: IFTRUE 83716
83698: PUSH
83699: LD_VAR 0 5
83703: PUSH
83704: LD_EXP 103
83708: PUSH
83709: LD_VAR 0 2
83713: ARRAY
83714: LESSEQUAL
83715: OR
83716: IFFALSE 83720
// continue ;
83718: GO 82950
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83720: LD_ADDR_VAR 0 6
83724: PUSH
83725: LD_EXP 63
83729: PUSH
83730: LD_VAR 0 2
83734: ARRAY
83735: PPUSH
83736: LD_INT 25
83738: PUSH
83739: LD_INT 3
83741: PUSH
83742: EMPTY
83743: LIST
83744: LIST
83745: PPUSH
83746: CALL_OW 72
83750: PUSH
83751: LD_EXP 103
83755: PUSH
83756: LD_VAR 0 2
83760: ARRAY
83761: DIFF
83762: PPUSH
83763: LD_INT 3
83765: PPUSH
83766: CALL 54092 0 2
83770: ST_TO_ADDR
// for j in tmp do
83771: LD_ADDR_VAR 0 3
83775: PUSH
83776: LD_VAR 0 6
83780: PUSH
83781: FOR_IN
83782: IFFALSE 83817
// if GetTag ( j ) > 0 then
83784: LD_VAR 0 3
83788: PPUSH
83789: CALL_OW 110
83793: PUSH
83794: LD_INT 0
83796: GREATER
83797: IFFALSE 83815
// tmp := tmp diff j ;
83799: LD_ADDR_VAR 0 6
83803: PUSH
83804: LD_VAR 0 6
83808: PUSH
83809: LD_VAR 0 3
83813: DIFF
83814: ST_TO_ADDR
83815: GO 83781
83817: POP
83818: POP
// if not tmp then
83819: LD_VAR 0 6
83823: NOT
83824: IFFALSE 83828
// continue ;
83826: GO 82950
// if places then
83828: LD_VAR 0 5
83832: IFFALSE 83891
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83834: LD_ADDR_EXP 103
83838: PUSH
83839: LD_EXP 103
83843: PPUSH
83844: LD_VAR 0 2
83848: PPUSH
83849: LD_EXP 103
83853: PUSH
83854: LD_VAR 0 2
83858: ARRAY
83859: PUSH
83860: LD_VAR 0 6
83864: PUSH
83865: LD_INT 1
83867: ARRAY
83868: UNION
83869: PPUSH
83870: CALL_OW 1
83874: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83875: LD_VAR 0 6
83879: PUSH
83880: LD_INT 1
83882: ARRAY
83883: PPUSH
83884: LD_INT 126
83886: PPUSH
83887: CALL_OW 109
// end ; end ;
83891: GO 82950
83893: POP
83894: POP
// end ;
83895: LD_VAR 0 1
83899: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83900: LD_INT 0
83902: PPUSH
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
83907: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83908: LD_VAR 0 1
83912: NOT
83913: IFTRUE 83922
83915: PUSH
83916: LD_VAR 0 2
83920: NOT
83921: OR
83922: IFTRUE 83931
83924: PUSH
83925: LD_VAR 0 3
83929: NOT
83930: OR
83931: IFTRUE 83979
83933: PUSH
83934: LD_VAR 0 4
83938: PUSH
83939: LD_INT 1
83941: PUSH
83942: LD_INT 2
83944: PUSH
83945: LD_INT 3
83947: PUSH
83948: LD_INT 4
83950: PUSH
83951: LD_INT 5
83953: PUSH
83954: LD_INT 8
83956: PUSH
83957: LD_INT 9
83959: PUSH
83960: LD_INT 15
83962: PUSH
83963: LD_INT 16
83965: PUSH
83966: EMPTY
83967: LIST
83968: LIST
83969: LIST
83970: LIST
83971: LIST
83972: LIST
83973: LIST
83974: LIST
83975: LIST
83976: IN
83977: NOT
83978: OR
83979: IFFALSE 83983
// exit ;
83981: GO 84843
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83983: LD_ADDR_VAR 0 2
83987: PUSH
83988: LD_VAR 0 2
83992: PPUSH
83993: LD_INT 21
83995: PUSH
83996: LD_INT 3
83998: PUSH
83999: EMPTY
84000: LIST
84001: LIST
84002: PUSH
84003: LD_INT 24
84005: PUSH
84006: LD_INT 250
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PPUSH
84017: CALL_OW 72
84021: ST_TO_ADDR
// case class of 1 , 15 :
84022: LD_VAR 0 4
84026: PUSH
84027: LD_INT 1
84029: DOUBLE
84030: EQUAL
84031: IFTRUE 84041
84033: LD_INT 15
84035: DOUBLE
84036: EQUAL
84037: IFTRUE 84041
84039: GO 84126
84041: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
84042: LD_ADDR_VAR 0 8
84046: PUSH
84047: LD_VAR 0 2
84051: PPUSH
84052: LD_INT 2
84054: PUSH
84055: LD_INT 30
84057: PUSH
84058: LD_INT 32
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: PUSH
84065: LD_INT 30
84067: PUSH
84068: LD_INT 31
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: PPUSH
84080: CALL_OW 72
84084: PUSH
84085: LD_VAR 0 2
84089: PPUSH
84090: LD_INT 2
84092: PUSH
84093: LD_INT 30
84095: PUSH
84096: LD_INT 4
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 30
84105: PUSH
84106: LD_INT 5
84108: PUSH
84109: EMPTY
84110: LIST
84111: LIST
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: PPUSH
84118: CALL_OW 72
84122: ADD
84123: ST_TO_ADDR
84124: GO 84372
84126: LD_INT 2
84128: DOUBLE
84129: EQUAL
84130: IFTRUE 84140
84132: LD_INT 16
84134: DOUBLE
84135: EQUAL
84136: IFTRUE 84140
84138: GO 84186
84140: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84141: LD_ADDR_VAR 0 8
84145: PUSH
84146: LD_VAR 0 2
84150: PPUSH
84151: LD_INT 2
84153: PUSH
84154: LD_INT 30
84156: PUSH
84157: LD_INT 0
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 30
84166: PUSH
84167: LD_INT 1
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: PUSH
84174: EMPTY
84175: LIST
84176: LIST
84177: LIST
84178: PPUSH
84179: CALL_OW 72
84183: ST_TO_ADDR
84184: GO 84372
84186: LD_INT 3
84188: DOUBLE
84189: EQUAL
84190: IFTRUE 84194
84192: GO 84240
84194: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84195: LD_ADDR_VAR 0 8
84199: PUSH
84200: LD_VAR 0 2
84204: PPUSH
84205: LD_INT 2
84207: PUSH
84208: LD_INT 30
84210: PUSH
84211: LD_INT 2
84213: PUSH
84214: EMPTY
84215: LIST
84216: LIST
84217: PUSH
84218: LD_INT 30
84220: PUSH
84221: LD_INT 3
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: EMPTY
84229: LIST
84230: LIST
84231: LIST
84232: PPUSH
84233: CALL_OW 72
84237: ST_TO_ADDR
84238: GO 84372
84240: LD_INT 4
84242: DOUBLE
84243: EQUAL
84244: IFTRUE 84248
84246: GO 84305
84248: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84249: LD_ADDR_VAR 0 8
84253: PUSH
84254: LD_VAR 0 2
84258: PPUSH
84259: LD_INT 2
84261: PUSH
84262: LD_INT 30
84264: PUSH
84265: LD_INT 6
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 30
84274: PUSH
84275: LD_INT 7
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 30
84284: PUSH
84285: LD_INT 8
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: EMPTY
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: PPUSH
84298: CALL_OW 72
84302: ST_TO_ADDR
84303: GO 84372
84305: LD_INT 5
84307: DOUBLE
84308: EQUAL
84309: IFTRUE 84325
84311: LD_INT 8
84313: DOUBLE
84314: EQUAL
84315: IFTRUE 84325
84317: LD_INT 9
84319: DOUBLE
84320: EQUAL
84321: IFTRUE 84325
84323: GO 84371
84325: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84326: LD_ADDR_VAR 0 8
84330: PUSH
84331: LD_VAR 0 2
84335: PPUSH
84336: LD_INT 2
84338: PUSH
84339: LD_INT 30
84341: PUSH
84342: LD_INT 4
84344: PUSH
84345: EMPTY
84346: LIST
84347: LIST
84348: PUSH
84349: LD_INT 30
84351: PUSH
84352: LD_INT 5
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: LIST
84363: PPUSH
84364: CALL_OW 72
84368: ST_TO_ADDR
84369: GO 84372
84371: POP
// if not tmp then
84372: LD_VAR 0 8
84376: NOT
84377: IFFALSE 84381
// exit ;
84379: GO 84843
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84381: LD_VAR 0 4
84385: PUSH
84386: LD_INT 1
84388: PUSH
84389: LD_INT 15
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: IN
84396: IFFALSE 84410
84398: PUSH
84399: LD_EXP 72
84403: PUSH
84404: LD_VAR 0 1
84408: ARRAY
84409: AND
84410: IFFALSE 84566
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84412: LD_ADDR_VAR 0 9
84416: PUSH
84417: LD_EXP 72
84421: PUSH
84422: LD_VAR 0 1
84426: ARRAY
84427: PUSH
84428: LD_INT 1
84430: ARRAY
84431: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84432: LD_VAR 0 9
84436: PUSH
84437: LD_EXP 73
84441: PUSH
84442: LD_VAR 0 1
84446: ARRAY
84447: IN
84448: NOT
84449: IFFALSE 84564
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84451: LD_ADDR_EXP 73
84455: PUSH
84456: LD_EXP 73
84460: PPUSH
84461: LD_VAR 0 1
84465: PUSH
84466: LD_EXP 73
84470: PUSH
84471: LD_VAR 0 1
84475: ARRAY
84476: PUSH
84477: LD_INT 1
84479: PLUS
84480: PUSH
84481: EMPTY
84482: LIST
84483: LIST
84484: PPUSH
84485: LD_VAR 0 9
84489: PPUSH
84490: CALL 22554 0 3
84494: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84495: LD_ADDR_EXP 72
84499: PUSH
84500: LD_EXP 72
84504: PPUSH
84505: LD_VAR 0 1
84509: PPUSH
84510: LD_EXP 72
84514: PUSH
84515: LD_VAR 0 1
84519: ARRAY
84520: PUSH
84521: LD_VAR 0 9
84525: DIFF
84526: PPUSH
84527: CALL_OW 1
84531: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84532: LD_VAR 0 3
84536: PPUSH
84537: LD_EXP 73
84541: PUSH
84542: LD_VAR 0 1
84546: ARRAY
84547: PUSH
84548: LD_EXP 73
84552: PUSH
84553: LD_VAR 0 1
84557: ARRAY
84558: ARRAY
84559: PPUSH
84560: CALL_OW 120
// end ; exit ;
84564: GO 84843
// end ; if tmp > 1 then
84566: LD_VAR 0 8
84570: PUSH
84571: LD_INT 1
84573: GREATER
84574: IFFALSE 84678
// for i = 2 to tmp do
84576: LD_ADDR_VAR 0 6
84580: PUSH
84581: DOUBLE
84582: LD_INT 2
84584: DEC
84585: ST_TO_ADDR
84586: LD_VAR 0 8
84590: PUSH
84591: FOR_TO
84592: IFFALSE 84676
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84594: LD_VAR 0 8
84598: PUSH
84599: LD_VAR 0 6
84603: ARRAY
84604: PPUSH
84605: CALL_OW 461
84609: PUSH
84610: LD_INT 6
84612: EQUAL
84613: IFFALSE 84674
// begin x := tmp [ i ] ;
84615: LD_ADDR_VAR 0 9
84619: PUSH
84620: LD_VAR 0 8
84624: PUSH
84625: LD_VAR 0 6
84629: ARRAY
84630: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84631: LD_ADDR_VAR 0 8
84635: PUSH
84636: LD_VAR 0 8
84640: PPUSH
84641: LD_VAR 0 6
84645: PPUSH
84646: CALL_OW 3
84650: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84651: LD_ADDR_VAR 0 8
84655: PUSH
84656: LD_VAR 0 8
84660: PPUSH
84661: LD_INT 1
84663: PPUSH
84664: LD_VAR 0 9
84668: PPUSH
84669: CALL_OW 2
84673: ST_TO_ADDR
// end ;
84674: GO 84591
84676: POP
84677: POP
// for i in tmp do
84678: LD_ADDR_VAR 0 6
84682: PUSH
84683: LD_VAR 0 8
84687: PUSH
84688: FOR_IN
84689: IFFALSE 84716
// begin if IsNotFull ( i ) then
84691: LD_VAR 0 6
84695: PPUSH
84696: CALL 19718 0 1
84700: IFFALSE 84714
// begin j := i ;
84702: LD_ADDR_VAR 0 7
84706: PUSH
84707: LD_VAR 0 6
84711: ST_TO_ADDR
// break ;
84712: GO 84716
// end ; end ;
84714: GO 84688
84716: POP
84717: POP
// if j then
84718: LD_VAR 0 7
84722: IFFALSE 84740
// ComEnterUnit ( unit , j ) else
84724: LD_VAR 0 3
84728: PPUSH
84729: LD_VAR 0 7
84733: PPUSH
84734: CALL_OW 120
84738: GO 84843
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84740: LD_ADDR_VAR 0 10
84744: PUSH
84745: LD_VAR 0 2
84749: PPUSH
84750: LD_INT 2
84752: PUSH
84753: LD_INT 30
84755: PUSH
84756: LD_INT 0
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 30
84765: PUSH
84766: LD_INT 1
84768: PUSH
84769: EMPTY
84770: LIST
84771: LIST
84772: PUSH
84773: EMPTY
84774: LIST
84775: LIST
84776: LIST
84777: PPUSH
84778: CALL_OW 72
84782: ST_TO_ADDR
// if depot then
84783: LD_VAR 0 10
84787: IFFALSE 84843
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84789: LD_ADDR_VAR 0 10
84793: PUSH
84794: LD_VAR 0 10
84798: PPUSH
84799: LD_VAR 0 3
84803: PPUSH
84804: CALL_OW 74
84808: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84809: LD_VAR 0 3
84813: PPUSH
84814: LD_VAR 0 10
84818: PPUSH
84819: CALL_OW 296
84823: PUSH
84824: LD_INT 10
84826: GREATER
84827: IFFALSE 84843
// ComStandNearbyBuilding ( unit , depot ) ;
84829: LD_VAR 0 3
84833: PPUSH
84834: LD_VAR 0 10
84838: PPUSH
84839: CALL 19096 0 2
// end ; end ; end ;
84843: LD_VAR 0 5
84847: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84848: LD_INT 0
84850: PPUSH
84851: PPUSH
84852: PPUSH
84853: PPUSH
// if not mc_bases then
84854: LD_EXP 63
84858: NOT
84859: IFFALSE 84863
// exit ;
84861: GO 85114
// for i = 1 to mc_bases do
84863: LD_ADDR_VAR 0 2
84867: PUSH
84868: DOUBLE
84869: LD_INT 1
84871: DEC
84872: ST_TO_ADDR
84873: LD_EXP 63
84877: PUSH
84878: FOR_TO
84879: IFFALSE 85112
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84881: LD_ADDR_VAR 0 4
84885: PUSH
84886: LD_EXP 63
84890: PUSH
84891: LD_VAR 0 2
84895: ARRAY
84896: PPUSH
84897: LD_INT 21
84899: PUSH
84900: LD_INT 1
84902: PUSH
84903: EMPTY
84904: LIST
84905: LIST
84906: PPUSH
84907: CALL_OW 72
84911: PUSH
84912: LD_EXP 92
84916: PUSH
84917: LD_VAR 0 2
84921: ARRAY
84922: UNION
84923: ST_TO_ADDR
// if not tmp then
84924: LD_VAR 0 4
84928: NOT
84929: IFFALSE 84933
// continue ;
84931: GO 84878
// for j in tmp do
84933: LD_ADDR_VAR 0 3
84937: PUSH
84938: LD_VAR 0 4
84942: PUSH
84943: FOR_IN
84944: IFFALSE 85108
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84946: LD_VAR 0 3
84950: PPUSH
84951: CALL_OW 110
84955: NOT
84956: IFFALSE 84970
84958: PUSH
84959: LD_VAR 0 3
84963: PPUSH
84964: CALL_OW 314
84968: NOT
84969: AND
84970: IFFALSE 84984
84972: PUSH
84973: LD_VAR 0 3
84977: PPUSH
84978: CALL_OW 311
84982: NOT
84983: AND
84984: IFFALSE 84998
84986: PUSH
84987: LD_VAR 0 3
84991: PPUSH
84992: CALL_OW 310
84996: NOT
84997: AND
84998: IFFALSE 85023
85000: PUSH
85001: LD_VAR 0 3
85005: PUSH
85006: LD_EXP 66
85010: PUSH
85011: LD_VAR 0 2
85015: ARRAY
85016: PUSH
85017: LD_INT 1
85019: ARRAY
85020: IN
85021: NOT
85022: AND
85023: IFFALSE 85048
85025: PUSH
85026: LD_VAR 0 3
85030: PUSH
85031: LD_EXP 66
85035: PUSH
85036: LD_VAR 0 2
85040: ARRAY
85041: PUSH
85042: LD_INT 2
85044: ARRAY
85045: IN
85046: NOT
85047: AND
85048: IFFALSE 85069
85050: PUSH
85051: LD_VAR 0 3
85055: PUSH
85056: LD_EXP 75
85060: PUSH
85061: LD_VAR 0 2
85065: ARRAY
85066: IN
85067: NOT
85068: AND
85069: IFFALSE 85106
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85071: LD_VAR 0 2
85075: PPUSH
85076: LD_EXP 63
85080: PUSH
85081: LD_VAR 0 2
85085: ARRAY
85086: PPUSH
85087: LD_VAR 0 3
85091: PPUSH
85092: LD_VAR 0 3
85096: PPUSH
85097: CALL_OW 257
85101: PPUSH
85102: CALL 83900 0 4
// end ;
85106: GO 84943
85108: POP
85109: POP
// end ;
85110: GO 84878
85112: POP
85113: POP
// end ;
85114: LD_VAR 0 1
85118: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85119: LD_INT 0
85121: PPUSH
85122: PPUSH
85123: PPUSH
85124: PPUSH
85125: PPUSH
85126: PPUSH
// if not mc_bases [ base ] then
85127: LD_EXP 63
85131: PUSH
85132: LD_VAR 0 1
85136: ARRAY
85137: NOT
85138: IFFALSE 85142
// exit ;
85140: GO 85343
// tmp := [ ] ;
85142: LD_ADDR_VAR 0 6
85146: PUSH
85147: EMPTY
85148: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85149: LD_ADDR_VAR 0 7
85153: PUSH
85154: LD_VAR 0 3
85158: PPUSH
85159: LD_INT 0
85161: PPUSH
85162: CALL_OW 517
85166: ST_TO_ADDR
// if not list then
85167: LD_VAR 0 7
85171: NOT
85172: IFFALSE 85176
// exit ;
85174: GO 85343
// c := Count ( list [ 1 ] ) ;
85176: LD_ADDR_VAR 0 9
85180: PUSH
85181: LD_VAR 0 7
85185: PUSH
85186: LD_INT 1
85188: ARRAY
85189: PPUSH
85190: CALL 19636 0 1
85194: ST_TO_ADDR
// if amount > c then
85195: LD_VAR 0 2
85199: PUSH
85200: LD_VAR 0 9
85204: GREATER
85205: IFFALSE 85217
// amount := c ;
85207: LD_ADDR_VAR 0 2
85211: PUSH
85212: LD_VAR 0 9
85216: ST_TO_ADDR
// for i := 1 to amount do
85217: LD_ADDR_VAR 0 5
85221: PUSH
85222: DOUBLE
85223: LD_INT 1
85225: DEC
85226: ST_TO_ADDR
85227: LD_VAR 0 2
85231: PUSH
85232: FOR_TO
85233: IFFALSE 85291
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85235: LD_ADDR_VAR 0 6
85239: PUSH
85240: LD_VAR 0 6
85244: PPUSH
85245: LD_VAR 0 5
85249: PPUSH
85250: LD_VAR 0 7
85254: PUSH
85255: LD_INT 1
85257: ARRAY
85258: PUSH
85259: LD_VAR 0 5
85263: ARRAY
85264: PUSH
85265: LD_VAR 0 7
85269: PUSH
85270: LD_INT 2
85272: ARRAY
85273: PUSH
85274: LD_VAR 0 5
85278: ARRAY
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PPUSH
85284: CALL_OW 1
85288: ST_TO_ADDR
85289: GO 85232
85291: POP
85292: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85293: LD_ADDR_EXP 76
85297: PUSH
85298: LD_EXP 76
85302: PPUSH
85303: LD_VAR 0 1
85307: PPUSH
85308: LD_VAR 0 6
85312: PPUSH
85313: CALL_OW 1
85317: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85318: LD_ADDR_EXP 78
85322: PUSH
85323: LD_EXP 78
85327: PPUSH
85328: LD_VAR 0 1
85332: PPUSH
85333: LD_VAR 0 3
85337: PPUSH
85338: CALL_OW 1
85342: ST_TO_ADDR
// end ;
85343: LD_VAR 0 4
85347: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85348: LD_INT 0
85350: PPUSH
// if not mc_bases [ base ] then
85351: LD_EXP 63
85355: PUSH
85356: LD_VAR 0 1
85360: ARRAY
85361: NOT
85362: IFFALSE 85366
// exit ;
85364: GO 85391
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85366: LD_ADDR_EXP 68
85370: PUSH
85371: LD_EXP 68
85375: PPUSH
85376: LD_VAR 0 1
85380: PPUSH
85381: LD_VAR 0 2
85385: PPUSH
85386: CALL_OW 1
85390: ST_TO_ADDR
// end ;
85391: LD_VAR 0 3
85395: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85396: LD_INT 0
85398: PPUSH
// if not mc_bases [ base ] then
85399: LD_EXP 63
85403: PUSH
85404: LD_VAR 0 1
85408: ARRAY
85409: NOT
85410: IFFALSE 85414
// exit ;
85412: GO 85451
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85414: LD_ADDR_EXP 68
85418: PUSH
85419: LD_EXP 68
85423: PPUSH
85424: LD_VAR 0 1
85428: PPUSH
85429: LD_EXP 68
85433: PUSH
85434: LD_VAR 0 1
85438: ARRAY
85439: PUSH
85440: LD_VAR 0 2
85444: UNION
85445: PPUSH
85446: CALL_OW 1
85450: ST_TO_ADDR
// end ;
85451: LD_VAR 0 3
85455: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85456: LD_INT 0
85458: PPUSH
// if not mc_bases [ base ] then
85459: LD_EXP 63
85463: PUSH
85464: LD_VAR 0 1
85468: ARRAY
85469: NOT
85470: IFFALSE 85474
// exit ;
85472: GO 85499
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85474: LD_ADDR_EXP 84
85478: PUSH
85479: LD_EXP 84
85483: PPUSH
85484: LD_VAR 0 1
85488: PPUSH
85489: LD_VAR 0 2
85493: PPUSH
85494: CALL_OW 1
85498: ST_TO_ADDR
// end ;
85499: LD_VAR 0 3
85503: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85504: LD_INT 0
85506: PPUSH
// if not mc_bases [ base ] then
85507: LD_EXP 63
85511: PUSH
85512: LD_VAR 0 1
85516: ARRAY
85517: NOT
85518: IFFALSE 85522
// exit ;
85520: GO 85559
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85522: LD_ADDR_EXP 84
85526: PUSH
85527: LD_EXP 84
85531: PPUSH
85532: LD_VAR 0 1
85536: PPUSH
85537: LD_EXP 84
85541: PUSH
85542: LD_VAR 0 1
85546: ARRAY
85547: PUSH
85548: LD_VAR 0 2
85552: ADD
85553: PPUSH
85554: CALL_OW 1
85558: ST_TO_ADDR
// end ;
85559: LD_VAR 0 3
85563: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85564: LD_INT 0
85566: PPUSH
// if not mc_bases [ base ] then
85567: LD_EXP 63
85571: PUSH
85572: LD_VAR 0 1
85576: ARRAY
85577: NOT
85578: IFFALSE 85582
// exit ;
85580: GO 85636
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85582: LD_ADDR_EXP 85
85586: PUSH
85587: LD_EXP 85
85591: PPUSH
85592: LD_VAR 0 1
85596: PPUSH
85597: LD_VAR 0 2
85601: PPUSH
85602: CALL_OW 1
85606: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85607: LD_ADDR_EXP 74
85611: PUSH
85612: LD_EXP 74
85616: PPUSH
85617: LD_VAR 0 1
85621: PPUSH
85622: LD_VAR 0 2
85626: PUSH
85627: LD_INT 0
85629: PLUS
85630: PPUSH
85631: CALL_OW 1
85635: ST_TO_ADDR
// end ;
85636: LD_VAR 0 3
85640: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85641: LD_INT 0
85643: PPUSH
// if not mc_bases [ base ] then
85644: LD_EXP 63
85648: PUSH
85649: LD_VAR 0 1
85653: ARRAY
85654: NOT
85655: IFFALSE 85659
// exit ;
85657: GO 85684
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85659: LD_ADDR_EXP 74
85663: PUSH
85664: LD_EXP 74
85668: PPUSH
85669: LD_VAR 0 1
85673: PPUSH
85674: LD_VAR 0 2
85678: PPUSH
85679: CALL_OW 1
85683: ST_TO_ADDR
// end ;
85684: LD_VAR 0 3
85688: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85689: LD_INT 0
85691: PPUSH
85692: PPUSH
85693: PPUSH
85694: PPUSH
// if not mc_bases [ base ] then
85695: LD_EXP 63
85699: PUSH
85700: LD_VAR 0 1
85704: ARRAY
85705: NOT
85706: IFFALSE 85710
// exit ;
85708: GO 85775
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85710: LD_ADDR_EXP 83
85714: PUSH
85715: LD_EXP 83
85719: PPUSH
85720: LD_VAR 0 1
85724: PUSH
85725: LD_EXP 83
85729: PUSH
85730: LD_VAR 0 1
85734: ARRAY
85735: PUSH
85736: LD_INT 1
85738: PLUS
85739: PUSH
85740: EMPTY
85741: LIST
85742: LIST
85743: PPUSH
85744: LD_VAR 0 1
85748: PUSH
85749: LD_VAR 0 2
85753: PUSH
85754: LD_VAR 0 3
85758: PUSH
85759: LD_VAR 0 4
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: PPUSH
85770: CALL 22554 0 3
85774: ST_TO_ADDR
// end ;
85775: LD_VAR 0 5
85779: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85780: LD_INT 0
85782: PPUSH
// if not mc_bases [ base ] then
85783: LD_EXP 63
85787: PUSH
85788: LD_VAR 0 1
85792: ARRAY
85793: NOT
85794: IFFALSE 85798
// exit ;
85796: GO 85823
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85798: LD_ADDR_EXP 100
85802: PUSH
85803: LD_EXP 100
85807: PPUSH
85808: LD_VAR 0 1
85812: PPUSH
85813: LD_VAR 0 2
85817: PPUSH
85818: CALL_OW 1
85822: ST_TO_ADDR
// end ;
85823: LD_VAR 0 3
85827: RET
// export function MC_GetMinesField ( base ) ; begin
85828: LD_INT 0
85830: PPUSH
// result := mc_mines [ base ] ;
85831: LD_ADDR_VAR 0 2
85835: PUSH
85836: LD_EXP 76
85840: PUSH
85841: LD_VAR 0 1
85845: ARRAY
85846: ST_TO_ADDR
// end ;
85847: LD_VAR 0 2
85851: RET
// export function MC_GetProduceList ( base ) ; begin
85852: LD_INT 0
85854: PPUSH
// result := mc_produce [ base ] ;
85855: LD_ADDR_VAR 0 2
85859: PUSH
85860: LD_EXP 84
85864: PUSH
85865: LD_VAR 0 1
85869: ARRAY
85870: ST_TO_ADDR
// end ;
85871: LD_VAR 0 2
85875: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85876: LD_INT 0
85878: PPUSH
85879: PPUSH
// if not mc_bases then
85880: LD_EXP 63
85884: NOT
85885: IFFALSE 85889
// exit ;
85887: GO 85954
// if mc_bases [ base ] then
85889: LD_EXP 63
85893: PUSH
85894: LD_VAR 0 1
85898: ARRAY
85899: IFFALSE 85954
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85901: LD_ADDR_VAR 0 3
85905: PUSH
85906: LD_EXP 63
85910: PUSH
85911: LD_VAR 0 1
85915: ARRAY
85916: PPUSH
85917: LD_INT 30
85919: PUSH
85920: LD_VAR 0 2
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: PPUSH
85929: CALL_OW 72
85933: ST_TO_ADDR
// if result then
85934: LD_VAR 0 3
85938: IFFALSE 85954
// result := result [ 1 ] ;
85940: LD_ADDR_VAR 0 3
85944: PUSH
85945: LD_VAR 0 3
85949: PUSH
85950: LD_INT 1
85952: ARRAY
85953: ST_TO_ADDR
// end ; end ;
85954: LD_VAR 0 3
85958: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85959: LD_INT 0
85961: PPUSH
85962: PPUSH
// if not mc_bases then
85963: LD_EXP 63
85967: NOT
85968: IFFALSE 85972
// exit ;
85970: GO 86017
// if mc_bases [ base ] then
85972: LD_EXP 63
85976: PUSH
85977: LD_VAR 0 1
85981: ARRAY
85982: IFFALSE 86017
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85984: LD_ADDR_VAR 0 3
85988: PUSH
85989: LD_EXP 63
85993: PUSH
85994: LD_VAR 0 1
85998: ARRAY
85999: PPUSH
86000: LD_INT 30
86002: PUSH
86003: LD_VAR 0 2
86007: PUSH
86008: EMPTY
86009: LIST
86010: LIST
86011: PPUSH
86012: CALL_OW 72
86016: ST_TO_ADDR
// end ;
86017: LD_VAR 0 3
86021: RET
// export function MC_SetTame ( base , area ) ; begin
86022: LD_INT 0
86024: PPUSH
// if not mc_bases or not base then
86025: LD_EXP 63
86029: NOT
86030: IFTRUE 86039
86032: PUSH
86033: LD_VAR 0 1
86037: NOT
86038: OR
86039: IFFALSE 86043
// exit ;
86041: GO 86068
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
86043: LD_ADDR_EXP 91
86047: PUSH
86048: LD_EXP 91
86052: PPUSH
86053: LD_VAR 0 1
86057: PPUSH
86058: LD_VAR 0 2
86062: PPUSH
86063: CALL_OW 1
86067: ST_TO_ADDR
// end ;
86068: LD_VAR 0 3
86072: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86073: LD_INT 0
86075: PPUSH
86076: PPUSH
// if not mc_bases or not base then
86077: LD_EXP 63
86081: NOT
86082: IFTRUE 86091
86084: PUSH
86085: LD_VAR 0 1
86089: NOT
86090: OR
86091: IFFALSE 86095
// exit ;
86093: GO 86197
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86095: LD_ADDR_VAR 0 4
86099: PUSH
86100: LD_EXP 63
86104: PUSH
86105: LD_VAR 0 1
86109: ARRAY
86110: PPUSH
86111: LD_INT 30
86113: PUSH
86114: LD_VAR 0 2
86118: PUSH
86119: EMPTY
86120: LIST
86121: LIST
86122: PPUSH
86123: CALL_OW 72
86127: ST_TO_ADDR
// if not tmp then
86128: LD_VAR 0 4
86132: NOT
86133: IFFALSE 86137
// exit ;
86135: GO 86197
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86137: LD_ADDR_EXP 95
86141: PUSH
86142: LD_EXP 95
86146: PPUSH
86147: LD_VAR 0 1
86151: PPUSH
86152: LD_EXP 95
86156: PUSH
86157: LD_VAR 0 1
86161: ARRAY
86162: PPUSH
86163: LD_EXP 95
86167: PUSH
86168: LD_VAR 0 1
86172: ARRAY
86173: PUSH
86174: LD_INT 1
86176: PLUS
86177: PPUSH
86178: LD_VAR 0 4
86182: PUSH
86183: LD_INT 1
86185: ARRAY
86186: PPUSH
86187: CALL_OW 2
86191: PPUSH
86192: CALL_OW 1
86196: ST_TO_ADDR
// end ;
86197: LD_VAR 0 3
86201: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86202: LD_INT 0
86204: PPUSH
86205: PPUSH
// if not mc_bases or not base or not kinds then
86206: LD_EXP 63
86210: NOT
86211: IFTRUE 86220
86213: PUSH
86214: LD_VAR 0 1
86218: NOT
86219: OR
86220: IFTRUE 86229
86222: PUSH
86223: LD_VAR 0 2
86227: NOT
86228: OR
86229: IFFALSE 86233
// exit ;
86231: GO 86294
// for i in kinds do
86233: LD_ADDR_VAR 0 4
86237: PUSH
86238: LD_VAR 0 2
86242: PUSH
86243: FOR_IN
86244: IFFALSE 86292
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86246: LD_ADDR_EXP 97
86250: PUSH
86251: LD_EXP 97
86255: PPUSH
86256: LD_VAR 0 1
86260: PUSH
86261: LD_EXP 97
86265: PUSH
86266: LD_VAR 0 1
86270: ARRAY
86271: PUSH
86272: LD_INT 1
86274: PLUS
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PPUSH
86280: LD_VAR 0 4
86284: PPUSH
86285: CALL 22554 0 3
86289: ST_TO_ADDR
86290: GO 86243
86292: POP
86293: POP
// end ;
86294: LD_VAR 0 3
86298: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86299: LD_INT 0
86301: PPUSH
// if not mc_bases or not base or not areas then
86302: LD_EXP 63
86306: NOT
86307: IFTRUE 86316
86309: PUSH
86310: LD_VAR 0 1
86314: NOT
86315: OR
86316: IFTRUE 86325
86318: PUSH
86319: LD_VAR 0 2
86323: NOT
86324: OR
86325: IFFALSE 86329
// exit ;
86327: GO 86354
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86329: LD_ADDR_EXP 81
86333: PUSH
86334: LD_EXP 81
86338: PPUSH
86339: LD_VAR 0 1
86343: PPUSH
86344: LD_VAR 0 2
86348: PPUSH
86349: CALL_OW 1
86353: ST_TO_ADDR
// end ;
86354: LD_VAR 0 3
86358: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86359: LD_INT 0
86361: PPUSH
// if not mc_bases or not base or not teleports_exit then
86362: LD_EXP 63
86366: NOT
86367: IFTRUE 86376
86369: PUSH
86370: LD_VAR 0 1
86374: NOT
86375: OR
86376: IFTRUE 86385
86378: PUSH
86379: LD_VAR 0 2
86383: NOT
86384: OR
86385: IFFALSE 86389
// exit ;
86387: GO 86414
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86389: LD_ADDR_EXP 98
86393: PUSH
86394: LD_EXP 98
86398: PPUSH
86399: LD_VAR 0 1
86403: PPUSH
86404: LD_VAR 0 2
86408: PPUSH
86409: CALL_OW 1
86413: ST_TO_ADDR
// end ;
86414: LD_VAR 0 3
86418: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86419: LD_INT 0
86421: PPUSH
86422: PPUSH
86423: PPUSH
// if not mc_bases or not base or not ext_list then
86424: LD_EXP 63
86428: NOT
86429: IFTRUE 86438
86431: PUSH
86432: LD_VAR 0 1
86436: NOT
86437: OR
86438: IFTRUE 86447
86440: PUSH
86441: LD_VAR 0 5
86445: NOT
86446: OR
86447: IFFALSE 86451
// exit ;
86449: GO 86624
// tmp := GetFacExtXYD ( x , y , d ) ;
86451: LD_ADDR_VAR 0 8
86455: PUSH
86456: LD_VAR 0 2
86460: PPUSH
86461: LD_VAR 0 3
86465: PPUSH
86466: LD_VAR 0 4
86470: PPUSH
86471: CALL 53222 0 3
86475: ST_TO_ADDR
// if not tmp then
86476: LD_VAR 0 8
86480: NOT
86481: IFFALSE 86485
// exit ;
86483: GO 86624
// for i in tmp do
86485: LD_ADDR_VAR 0 7
86489: PUSH
86490: LD_VAR 0 8
86494: PUSH
86495: FOR_IN
86496: IFFALSE 86622
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86498: LD_ADDR_EXP 68
86502: PUSH
86503: LD_EXP 68
86507: PPUSH
86508: LD_VAR 0 1
86512: PPUSH
86513: LD_EXP 68
86517: PUSH
86518: LD_VAR 0 1
86522: ARRAY
86523: PPUSH
86524: LD_EXP 68
86528: PUSH
86529: LD_VAR 0 1
86533: ARRAY
86534: PUSH
86535: LD_INT 1
86537: PLUS
86538: PPUSH
86539: LD_VAR 0 5
86543: PUSH
86544: LD_INT 1
86546: ARRAY
86547: PUSH
86548: LD_VAR 0 7
86552: PUSH
86553: LD_INT 1
86555: ARRAY
86556: PUSH
86557: LD_VAR 0 7
86561: PUSH
86562: LD_INT 2
86564: ARRAY
86565: PUSH
86566: LD_VAR 0 7
86570: PUSH
86571: LD_INT 3
86573: ARRAY
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: LIST
86579: LIST
86580: PPUSH
86581: CALL_OW 2
86585: PPUSH
86586: CALL_OW 1
86590: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86591: LD_ADDR_VAR 0 5
86595: PUSH
86596: LD_VAR 0 5
86600: PPUSH
86601: LD_INT 1
86603: PPUSH
86604: CALL_OW 3
86608: ST_TO_ADDR
// if not ext_list then
86609: LD_VAR 0 5
86613: NOT
86614: IFFALSE 86620
// exit ;
86616: POP
86617: POP
86618: GO 86624
// end ;
86620: GO 86495
86622: POP
86623: POP
// end ;
86624: LD_VAR 0 6
86628: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86629: LD_INT 0
86631: PPUSH
// if not mc_bases or not base or not weapon_list then
86632: LD_EXP 63
86636: NOT
86637: IFTRUE 86646
86639: PUSH
86640: LD_VAR 0 1
86644: NOT
86645: OR
86646: IFTRUE 86655
86648: PUSH
86649: LD_VAR 0 2
86653: NOT
86654: OR
86655: IFFALSE 86659
// exit ;
86657: GO 86684
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86659: LD_ADDR_EXP 102
86663: PUSH
86664: LD_EXP 102
86668: PPUSH
86669: LD_VAR 0 1
86673: PPUSH
86674: LD_VAR 0 2
86678: PPUSH
86679: CALL_OW 1
86683: ST_TO_ADDR
// end ;
86684: LD_VAR 0 3
86688: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86689: LD_INT 0
86691: PPUSH
// if not mc_bases or not base or not tech_list then
86692: LD_EXP 63
86696: NOT
86697: IFTRUE 86706
86699: PUSH
86700: LD_VAR 0 1
86704: NOT
86705: OR
86706: IFTRUE 86715
86708: PUSH
86709: LD_VAR 0 2
86713: NOT
86714: OR
86715: IFFALSE 86719
// exit ;
86717: GO 86744
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86719: LD_ADDR_EXP 90
86723: PUSH
86724: LD_EXP 90
86728: PPUSH
86729: LD_VAR 0 1
86733: PPUSH
86734: LD_VAR 0 2
86738: PPUSH
86739: CALL_OW 1
86743: ST_TO_ADDR
// end ;
86744: LD_VAR 0 3
86748: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86749: LD_INT 0
86751: PPUSH
// if not mc_bases or not parking_area or not base then
86752: LD_EXP 63
86756: NOT
86757: IFTRUE 86766
86759: PUSH
86760: LD_VAR 0 2
86764: NOT
86765: OR
86766: IFTRUE 86775
86768: PUSH
86769: LD_VAR 0 1
86773: NOT
86774: OR
86775: IFFALSE 86779
// exit ;
86777: GO 86804
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86779: LD_ADDR_EXP 87
86783: PUSH
86784: LD_EXP 87
86788: PPUSH
86789: LD_VAR 0 1
86793: PPUSH
86794: LD_VAR 0 2
86798: PPUSH
86799: CALL_OW 1
86803: ST_TO_ADDR
// end ;
86804: LD_VAR 0 3
86808: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86809: LD_INT 0
86811: PPUSH
// if not mc_bases or not base or not scan_area then
86812: LD_EXP 63
86816: NOT
86817: IFTRUE 86826
86819: PUSH
86820: LD_VAR 0 1
86824: NOT
86825: OR
86826: IFTRUE 86835
86828: PUSH
86829: LD_VAR 0 2
86833: NOT
86834: OR
86835: IFFALSE 86839
// exit ;
86837: GO 86864
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86839: LD_ADDR_EXP 88
86843: PUSH
86844: LD_EXP 88
86848: PPUSH
86849: LD_VAR 0 1
86853: PPUSH
86854: LD_VAR 0 2
86858: PPUSH
86859: CALL_OW 1
86863: ST_TO_ADDR
// end ;
86864: LD_VAR 0 3
86868: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86869: LD_INT 0
86871: PPUSH
86872: PPUSH
// if not mc_bases or not base then
86873: LD_EXP 63
86877: NOT
86878: IFTRUE 86887
86880: PUSH
86881: LD_VAR 0 1
86885: NOT
86886: OR
86887: IFFALSE 86891
// exit ;
86889: GO 86955
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86891: LD_ADDR_VAR 0 3
86895: PUSH
86896: LD_INT 1
86898: PUSH
86899: LD_INT 2
86901: PUSH
86902: LD_INT 3
86904: PUSH
86905: LD_INT 4
86907: PUSH
86908: LD_INT 11
86910: PUSH
86911: EMPTY
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: LIST
86917: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86918: LD_ADDR_EXP 90
86922: PUSH
86923: LD_EXP 90
86927: PPUSH
86928: LD_VAR 0 1
86932: PPUSH
86933: LD_EXP 90
86937: PUSH
86938: LD_VAR 0 1
86942: ARRAY
86943: PUSH
86944: LD_VAR 0 3
86948: DIFF
86949: PPUSH
86950: CALL_OW 1
86954: ST_TO_ADDR
// end ;
86955: LD_VAR 0 2
86959: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86960: LD_INT 0
86962: PPUSH
// result := mc_vehicles [ base ] ;
86963: LD_ADDR_VAR 0 3
86967: PUSH
86968: LD_EXP 82
86972: PUSH
86973: LD_VAR 0 1
86977: ARRAY
86978: ST_TO_ADDR
// if onlyCombat then
86979: LD_VAR 0 2
86983: IFFALSE 87155
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86985: LD_ADDR_VAR 0 3
86989: PUSH
86990: LD_VAR 0 3
86994: PUSH
86995: LD_VAR 0 3
86999: PPUSH
87000: LD_INT 2
87002: PUSH
87003: LD_INT 34
87005: PUSH
87006: LD_INT 12
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 34
87015: PUSH
87016: LD_INT 51
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 34
87025: PUSH
87026: LD_INT 89
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 34
87035: PUSH
87036: LD_INT 32
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: PUSH
87043: LD_INT 34
87045: PUSH
87046: LD_INT 13
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PUSH
87053: LD_INT 34
87055: PUSH
87056: LD_INT 52
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 34
87065: PUSH
87066: LD_INT 88
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: PUSH
87073: LD_INT 34
87075: PUSH
87076: LD_INT 14
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 34
87085: PUSH
87086: LD_INT 53
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 34
87095: PUSH
87096: LD_INT 98
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 34
87105: PUSH
87106: LD_INT 31
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 34
87115: PUSH
87116: LD_INT 48
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 34
87125: PUSH
87126: LD_INT 8
87128: PUSH
87129: EMPTY
87130: LIST
87131: LIST
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: LIST
87137: LIST
87138: LIST
87139: LIST
87140: LIST
87141: LIST
87142: LIST
87143: LIST
87144: LIST
87145: LIST
87146: LIST
87147: LIST
87148: PPUSH
87149: CALL_OW 72
87153: DIFF
87154: ST_TO_ADDR
// end ; end_of_file
87155: LD_VAR 0 3
87159: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87160: LD_INT 0
87162: PPUSH
87163: PPUSH
87164: PPUSH
// if not mc_bases or not skirmish then
87165: LD_EXP 63
87169: NOT
87170: IFTRUE 87179
87172: PUSH
87173: LD_EXP 61
87177: NOT
87178: OR
87179: IFFALSE 87183
// exit ;
87181: GO 87348
// for i = 1 to mc_bases do
87183: LD_ADDR_VAR 0 4
87187: PUSH
87188: DOUBLE
87189: LD_INT 1
87191: DEC
87192: ST_TO_ADDR
87193: LD_EXP 63
87197: PUSH
87198: FOR_TO
87199: IFFALSE 87346
// begin if sci in mc_bases [ i ] then
87201: LD_VAR 0 2
87205: PUSH
87206: LD_EXP 63
87210: PUSH
87211: LD_VAR 0 4
87215: ARRAY
87216: IN
87217: IFFALSE 87344
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87219: LD_ADDR_EXP 92
87223: PUSH
87224: LD_EXP 92
87228: PPUSH
87229: LD_VAR 0 4
87233: PUSH
87234: LD_EXP 92
87238: PUSH
87239: LD_VAR 0 4
87243: ARRAY
87244: PUSH
87245: LD_INT 1
87247: PLUS
87248: PUSH
87249: EMPTY
87250: LIST
87251: LIST
87252: PPUSH
87253: LD_VAR 0 1
87257: PPUSH
87258: CALL 22554 0 3
87262: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87263: LD_ADDR_VAR 0 5
87267: PUSH
87268: LD_EXP 63
87272: PUSH
87273: LD_VAR 0 4
87277: ARRAY
87278: PPUSH
87279: LD_INT 2
87281: PUSH
87282: LD_INT 30
87284: PUSH
87285: LD_INT 0
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 30
87294: PUSH
87295: LD_INT 1
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: LIST
87306: PPUSH
87307: CALL_OW 72
87311: PPUSH
87312: LD_VAR 0 1
87316: PPUSH
87317: CALL_OW 74
87321: ST_TO_ADDR
// if tmp then
87322: LD_VAR 0 5
87326: IFFALSE 87342
// ComStandNearbyBuilding ( ape , tmp ) ;
87328: LD_VAR 0 1
87332: PPUSH
87333: LD_VAR 0 5
87337: PPUSH
87338: CALL 19096 0 2
// break ;
87342: GO 87346
// end ; end ;
87344: GO 87198
87346: POP
87347: POP
// end ;
87348: LD_VAR 0 3
87352: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87353: LD_INT 0
87355: PPUSH
87356: PPUSH
87357: PPUSH
// if not mc_bases or not skirmish then
87358: LD_EXP 63
87362: NOT
87363: IFTRUE 87372
87365: PUSH
87366: LD_EXP 61
87370: NOT
87371: OR
87372: IFFALSE 87376
// exit ;
87374: GO 87465
// for i = 1 to mc_bases do
87376: LD_ADDR_VAR 0 4
87380: PUSH
87381: DOUBLE
87382: LD_INT 1
87384: DEC
87385: ST_TO_ADDR
87386: LD_EXP 63
87390: PUSH
87391: FOR_TO
87392: IFFALSE 87463
// begin if building in mc_busy_turret_list [ i ] then
87394: LD_VAR 0 1
87398: PUSH
87399: LD_EXP 73
87403: PUSH
87404: LD_VAR 0 4
87408: ARRAY
87409: IN
87410: IFFALSE 87461
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87412: LD_ADDR_VAR 0 5
87416: PUSH
87417: LD_EXP 73
87421: PUSH
87422: LD_VAR 0 4
87426: ARRAY
87427: PUSH
87428: LD_VAR 0 1
87432: DIFF
87433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87434: LD_ADDR_EXP 73
87438: PUSH
87439: LD_EXP 73
87443: PPUSH
87444: LD_VAR 0 4
87448: PPUSH
87449: LD_VAR 0 5
87453: PPUSH
87454: CALL_OW 1
87458: ST_TO_ADDR
// break ;
87459: GO 87463
// end ; end ;
87461: GO 87391
87463: POP
87464: POP
// end ;
87465: LD_VAR 0 3
87469: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87470: LD_INT 0
87472: PPUSH
87473: PPUSH
87474: PPUSH
// if not mc_bases or not skirmish then
87475: LD_EXP 63
87479: NOT
87480: IFTRUE 87489
87482: PUSH
87483: LD_EXP 61
87487: NOT
87488: OR
87489: IFFALSE 87493
// exit ;
87491: GO 87692
// for i = 1 to mc_bases do
87493: LD_ADDR_VAR 0 5
87497: PUSH
87498: DOUBLE
87499: LD_INT 1
87501: DEC
87502: ST_TO_ADDR
87503: LD_EXP 63
87507: PUSH
87508: FOR_TO
87509: IFFALSE 87690
// if building in mc_bases [ i ] then
87511: LD_VAR 0 1
87515: PUSH
87516: LD_EXP 63
87520: PUSH
87521: LD_VAR 0 5
87525: ARRAY
87526: IN
87527: IFFALSE 87688
// begin tmp := mc_bases [ i ] diff building ;
87529: LD_ADDR_VAR 0 6
87533: PUSH
87534: LD_EXP 63
87538: PUSH
87539: LD_VAR 0 5
87543: ARRAY
87544: PUSH
87545: LD_VAR 0 1
87549: DIFF
87550: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87551: LD_ADDR_EXP 63
87555: PUSH
87556: LD_EXP 63
87560: PPUSH
87561: LD_VAR 0 5
87565: PPUSH
87566: LD_VAR 0 6
87570: PPUSH
87571: CALL_OW 1
87575: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87576: LD_VAR 0 1
87580: PUSH
87581: LD_EXP 71
87585: PUSH
87586: LD_VAR 0 5
87590: ARRAY
87591: IN
87592: IFFALSE 87631
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87594: LD_ADDR_EXP 71
87598: PUSH
87599: LD_EXP 71
87603: PPUSH
87604: LD_VAR 0 5
87608: PPUSH
87609: LD_EXP 71
87613: PUSH
87614: LD_VAR 0 5
87618: ARRAY
87619: PUSH
87620: LD_VAR 0 1
87624: DIFF
87625: PPUSH
87626: CALL_OW 1
87630: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87631: LD_VAR 0 1
87635: PUSH
87636: LD_EXP 72
87640: PUSH
87641: LD_VAR 0 5
87645: ARRAY
87646: IN
87647: IFFALSE 87686
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87649: LD_ADDR_EXP 72
87653: PUSH
87654: LD_EXP 72
87658: PPUSH
87659: LD_VAR 0 5
87663: PPUSH
87664: LD_EXP 72
87668: PUSH
87669: LD_VAR 0 5
87673: ARRAY
87674: PUSH
87675: LD_VAR 0 1
87679: DIFF
87680: PPUSH
87681: CALL_OW 1
87685: ST_TO_ADDR
// break ;
87686: GO 87690
// end ;
87688: GO 87508
87690: POP
87691: POP
// end ;
87692: LD_VAR 0 4
87696: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87697: LD_INT 0
87699: PPUSH
87700: PPUSH
87701: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87702: LD_EXP 63
87706: NOT
87707: IFTRUE 87716
87709: PUSH
87710: LD_EXP 61
87714: NOT
87715: OR
87716: IFTRUE 87731
87718: PUSH
87719: LD_VAR 0 3
87723: PUSH
87724: LD_EXP 89
87728: IN
87729: NOT
87730: OR
87731: IFFALSE 87735
// exit ;
87733: GO 87860
// for i = 1 to mc_vehicles do
87735: LD_ADDR_VAR 0 6
87739: PUSH
87740: DOUBLE
87741: LD_INT 1
87743: DEC
87744: ST_TO_ADDR
87745: LD_EXP 82
87749: PUSH
87750: FOR_TO
87751: IFFALSE 87858
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87753: LD_VAR 0 2
87757: PUSH
87758: LD_EXP 82
87762: PUSH
87763: LD_VAR 0 6
87767: ARRAY
87768: IN
87769: IFTRUE 87789
87771: PUSH
87772: LD_VAR 0 1
87776: PUSH
87777: LD_EXP 82
87781: PUSH
87782: LD_VAR 0 6
87786: ARRAY
87787: IN
87788: OR
87789: IFFALSE 87856
// begin tmp := mc_vehicles [ i ] diff old ;
87791: LD_ADDR_VAR 0 7
87795: PUSH
87796: LD_EXP 82
87800: PUSH
87801: LD_VAR 0 6
87805: ARRAY
87806: PUSH
87807: LD_VAR 0 2
87811: DIFF
87812: ST_TO_ADDR
// tmp := tmp diff new ;
87813: LD_ADDR_VAR 0 7
87817: PUSH
87818: LD_VAR 0 7
87822: PUSH
87823: LD_VAR 0 1
87827: DIFF
87828: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87829: LD_ADDR_EXP 82
87833: PUSH
87834: LD_EXP 82
87838: PPUSH
87839: LD_VAR 0 6
87843: PPUSH
87844: LD_VAR 0 7
87848: PPUSH
87849: CALL_OW 1
87853: ST_TO_ADDR
// break ;
87854: GO 87858
// end ;
87856: GO 87750
87858: POP
87859: POP
// end ;
87860: LD_VAR 0 5
87864: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87865: LD_INT 0
87867: PPUSH
87868: PPUSH
87869: PPUSH
87870: PPUSH
// if not mc_bases or not skirmish then
87871: LD_EXP 63
87875: NOT
87876: IFTRUE 87885
87878: PUSH
87879: LD_EXP 61
87883: NOT
87884: OR
87885: IFFALSE 87889
// exit ;
87887: GO 88311
// repeat wait ( 0 0$1 ) ;
87889: LD_INT 35
87891: PPUSH
87892: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
87896: LD_EXP 107
87900: NOT
87901: IFFALSE 87889
// mc_block_vehicle_constructed_thread := true ;
87903: LD_ADDR_EXP 107
87907: PUSH
87908: LD_INT 1
87910: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
87911: LD_ADDR_VAR 0 5
87915: PUSH
87916: LD_VAR 0 1
87920: PPUSH
87921: CALL_OW 255
87925: ST_TO_ADDR
// for i = 1 to mc_bases do
87926: LD_ADDR_VAR 0 4
87930: PUSH
87931: DOUBLE
87932: LD_INT 1
87934: DEC
87935: ST_TO_ADDR
87936: LD_EXP 63
87940: PUSH
87941: FOR_TO
87942: IFFALSE 88301
// begin if factory in mc_bases [ i ] then
87944: LD_VAR 0 2
87948: PUSH
87949: LD_EXP 63
87953: PUSH
87954: LD_VAR 0 4
87958: ARRAY
87959: IN
87960: IFFALSE 88299
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87962: LD_EXP 85
87966: PUSH
87967: LD_VAR 0 4
87971: ARRAY
87972: PUSH
87973: LD_EXP 74
87977: PUSH
87978: LD_VAR 0 4
87982: ARRAY
87983: LESS
87984: IFFALSE 88073
87986: PUSH
87987: LD_VAR 0 1
87991: PPUSH
87992: CALL_OW 264
87996: PUSH
87997: LD_INT 31
87999: PUSH
88000: LD_INT 32
88002: PUSH
88003: LD_INT 51
88005: PUSH
88006: LD_INT 89
88008: PUSH
88009: LD_INT 12
88011: PUSH
88012: LD_INT 30
88014: PUSH
88015: LD_INT 98
88017: PUSH
88018: LD_INT 11
88020: PUSH
88021: LD_INT 53
88023: PUSH
88024: LD_INT 14
88026: PUSH
88027: LD_INT 91
88029: PUSH
88030: LD_INT 29
88032: PUSH
88033: LD_INT 99
88035: PUSH
88036: LD_INT 13
88038: PUSH
88039: LD_INT 52
88041: PUSH
88042: LD_INT 88
88044: PUSH
88045: LD_INT 48
88047: PUSH
88048: LD_INT 8
88050: PUSH
88051: EMPTY
88052: LIST
88053: LIST
88054: LIST
88055: LIST
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: IN
88071: NOT
88072: AND
88073: IFFALSE 88121
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88075: LD_ADDR_EXP 85
88079: PUSH
88080: LD_EXP 85
88084: PPUSH
88085: LD_VAR 0 4
88089: PUSH
88090: LD_EXP 85
88094: PUSH
88095: LD_VAR 0 4
88099: ARRAY
88100: PUSH
88101: LD_INT 1
88103: PLUS
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PPUSH
88109: LD_VAR 0 1
88113: PPUSH
88114: CALL 22554 0 3
88118: ST_TO_ADDR
88119: GO 88165
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88121: LD_ADDR_EXP 82
88125: PUSH
88126: LD_EXP 82
88130: PPUSH
88131: LD_VAR 0 4
88135: PUSH
88136: LD_EXP 82
88140: PUSH
88141: LD_VAR 0 4
88145: ARRAY
88146: PUSH
88147: LD_INT 1
88149: PLUS
88150: PUSH
88151: EMPTY
88152: LIST
88153: LIST
88154: PPUSH
88155: LD_VAR 0 1
88159: PPUSH
88160: CALL 22554 0 3
88164: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88165: LD_ADDR_EXP 107
88169: PUSH
88170: LD_INT 0
88172: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88173: LD_VAR 0 1
88177: PPUSH
88178: CALL_OW 263
88182: PUSH
88183: LD_INT 2
88185: EQUAL
88186: IFFALSE 88215
// begin repeat wait ( 0 0$3 ) ;
88188: LD_INT 105
88190: PPUSH
88191: CALL_OW 67
// Connect ( vehicle ) ;
88195: LD_VAR 0 1
88199: PPUSH
88200: CALL 25914 0 1
// until IsControledBy ( vehicle ) ;
88204: LD_VAR 0 1
88208: PPUSH
88209: CALL_OW 312
88213: IFFALSE 88188
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88215: LD_VAR 0 1
88219: PPUSH
88220: LD_EXP 87
88224: PUSH
88225: LD_VAR 0 4
88229: ARRAY
88230: PPUSH
88231: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88235: LD_VAR 0 1
88239: PPUSH
88240: CALL_OW 263
88244: PUSH
88245: LD_INT 1
88247: NONEQUAL
88248: IFFALSE 88252
// break ;
88250: GO 88301
// repeat wait ( 0 0$1 ) ;
88252: LD_INT 35
88254: PPUSH
88255: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88259: LD_VAR 0 1
88263: PPUSH
88264: LD_EXP 87
88268: PUSH
88269: LD_VAR 0 4
88273: ARRAY
88274: PPUSH
88275: CALL_OW 308
88279: IFFALSE 88252
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88281: LD_VAR 0 1
88285: PPUSH
88286: CALL_OW 311
88290: PPUSH
88291: CALL_OW 121
// exit ;
88295: POP
88296: POP
88297: GO 88311
// end ; end ;
88299: GO 87941
88301: POP
88302: POP
// mc_block_vehicle_constructed_thread := false ;
88303: LD_ADDR_EXP 107
88307: PUSH
88308: LD_INT 0
88310: ST_TO_ADDR
// end ;
88311: LD_VAR 0 3
88315: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88316: LD_INT 0
88318: PPUSH
88319: PPUSH
88320: PPUSH
88321: PPUSH
// if not mc_bases or not skirmish then
88322: LD_EXP 63
88326: NOT
88327: IFTRUE 88336
88329: PUSH
88330: LD_EXP 61
88334: NOT
88335: OR
88336: IFFALSE 88340
// exit ;
88338: GO 88693
// repeat wait ( 0 0$1 ) ;
88340: LD_INT 35
88342: PPUSH
88343: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88347: LD_VAR 0 2
88351: PPUSH
88352: LD_VAR 0 3
88356: PPUSH
88357: CALL_OW 284
88361: IFFALSE 88340
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88363: LD_VAR 0 2
88367: PPUSH
88368: LD_VAR 0 3
88372: PPUSH
88373: CALL_OW 283
88377: PUSH
88378: LD_INT 4
88380: EQUAL
88381: IFFALSE 88385
// exit ;
88383: GO 88693
// for i = 1 to mc_bases do
88385: LD_ADDR_VAR 0 7
88389: PUSH
88390: DOUBLE
88391: LD_INT 1
88393: DEC
88394: ST_TO_ADDR
88395: LD_EXP 63
88399: PUSH
88400: FOR_TO
88401: IFFALSE 88691
// begin if mc_crates_area [ i ] then
88403: LD_EXP 81
88407: PUSH
88408: LD_VAR 0 7
88412: ARRAY
88413: IFFALSE 88524
// for j in mc_crates_area [ i ] do
88415: LD_ADDR_VAR 0 8
88419: PUSH
88420: LD_EXP 81
88424: PUSH
88425: LD_VAR 0 7
88429: ARRAY
88430: PUSH
88431: FOR_IN
88432: IFFALSE 88522
// if InArea ( x , y , j ) then
88434: LD_VAR 0 2
88438: PPUSH
88439: LD_VAR 0 3
88443: PPUSH
88444: LD_VAR 0 8
88448: PPUSH
88449: CALL_OW 309
88453: IFFALSE 88520
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88455: LD_ADDR_EXP 79
88459: PUSH
88460: LD_EXP 79
88464: PPUSH
88465: LD_VAR 0 7
88469: PUSH
88470: LD_EXP 79
88474: PUSH
88475: LD_VAR 0 7
88479: ARRAY
88480: PUSH
88481: LD_INT 1
88483: PLUS
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PPUSH
88489: LD_VAR 0 4
88493: PUSH
88494: LD_VAR 0 2
88498: PUSH
88499: LD_VAR 0 3
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: LIST
88508: PPUSH
88509: CALL 22554 0 3
88513: ST_TO_ADDR
// exit ;
88514: POP
88515: POP
88516: POP
88517: POP
88518: GO 88693
// end ;
88520: GO 88431
88522: POP
88523: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88524: LD_ADDR_VAR 0 9
88528: PUSH
88529: LD_EXP 63
88533: PUSH
88534: LD_VAR 0 7
88538: ARRAY
88539: PPUSH
88540: LD_INT 2
88542: PUSH
88543: LD_INT 30
88545: PUSH
88546: LD_INT 0
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 30
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: EMPTY
88564: LIST
88565: LIST
88566: LIST
88567: PPUSH
88568: CALL_OW 72
88572: ST_TO_ADDR
// if not depot then
88573: LD_VAR 0 9
88577: NOT
88578: IFFALSE 88582
// continue ;
88580: GO 88400
// for j in depot do
88582: LD_ADDR_VAR 0 8
88586: PUSH
88587: LD_VAR 0 9
88591: PUSH
88592: FOR_IN
88593: IFFALSE 88687
// if GetDistUnitXY ( j , x , y ) < 30 then
88595: LD_VAR 0 8
88599: PPUSH
88600: LD_VAR 0 2
88604: PPUSH
88605: LD_VAR 0 3
88609: PPUSH
88610: CALL_OW 297
88614: PUSH
88615: LD_INT 30
88617: LESS
88618: IFFALSE 88685
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88620: LD_ADDR_EXP 79
88624: PUSH
88625: LD_EXP 79
88629: PPUSH
88630: LD_VAR 0 7
88634: PUSH
88635: LD_EXP 79
88639: PUSH
88640: LD_VAR 0 7
88644: ARRAY
88645: PUSH
88646: LD_INT 1
88648: PLUS
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PPUSH
88654: LD_VAR 0 4
88658: PUSH
88659: LD_VAR 0 2
88663: PUSH
88664: LD_VAR 0 3
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: LIST
88673: PPUSH
88674: CALL 22554 0 3
88678: ST_TO_ADDR
// exit ;
88679: POP
88680: POP
88681: POP
88682: POP
88683: GO 88693
// end ;
88685: GO 88592
88687: POP
88688: POP
// end ;
88689: GO 88400
88691: POP
88692: POP
// end ;
88693: LD_VAR 0 6
88697: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88698: LD_INT 0
88700: PPUSH
88701: PPUSH
88702: PPUSH
88703: PPUSH
// if not mc_bases or not skirmish then
88704: LD_EXP 63
88708: NOT
88709: IFTRUE 88718
88711: PUSH
88712: LD_EXP 61
88716: NOT
88717: OR
88718: IFFALSE 88722
// exit ;
88720: GO 89005
// side := GetSide ( lab ) ;
88722: LD_ADDR_VAR 0 4
88726: PUSH
88727: LD_VAR 0 2
88731: PPUSH
88732: CALL_OW 255
88736: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88737: LD_VAR 0 4
88741: PUSH
88742: LD_EXP 89
88746: IN
88747: NOT
88748: IFTRUE 88757
88750: PUSH
88751: LD_EXP 90
88755: NOT
88756: OR
88757: IFTRUE 88766
88759: PUSH
88760: LD_EXP 63
88764: NOT
88765: OR
88766: IFFALSE 88770
// exit ;
88768: GO 89005
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88770: LD_ADDR_EXP 90
88774: PUSH
88775: LD_EXP 90
88779: PPUSH
88780: LD_VAR 0 4
88784: PPUSH
88785: LD_EXP 90
88789: PUSH
88790: LD_VAR 0 4
88794: ARRAY
88795: PUSH
88796: LD_VAR 0 1
88800: DIFF
88801: PPUSH
88802: CALL_OW 1
88806: ST_TO_ADDR
// for i = 1 to mc_bases do
88807: LD_ADDR_VAR 0 5
88811: PUSH
88812: DOUBLE
88813: LD_INT 1
88815: DEC
88816: ST_TO_ADDR
88817: LD_EXP 63
88821: PUSH
88822: FOR_TO
88823: IFFALSE 89003
// begin if lab in mc_bases [ i ] then
88825: LD_VAR 0 2
88829: PUSH
88830: LD_EXP 63
88834: PUSH
88835: LD_VAR 0 5
88839: ARRAY
88840: IN
88841: IFFALSE 89001
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88843: LD_VAR 0 1
88847: PUSH
88848: LD_INT 11
88850: PUSH
88851: LD_INT 4
88853: PUSH
88854: LD_INT 3
88856: PUSH
88857: LD_INT 2
88859: PUSH
88860: EMPTY
88861: LIST
88862: LIST
88863: LIST
88864: LIST
88865: IN
88866: IFFALSE 88880
88868: PUSH
88869: LD_EXP 93
88873: PUSH
88874: LD_VAR 0 5
88878: ARRAY
88879: AND
88880: IFFALSE 89001
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88882: LD_ADDR_VAR 0 6
88886: PUSH
88887: LD_EXP 93
88891: PUSH
88892: LD_VAR 0 5
88896: ARRAY
88897: PUSH
88898: LD_INT 1
88900: ARRAY
88901: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88902: LD_ADDR_EXP 93
88906: PUSH
88907: LD_EXP 93
88911: PPUSH
88912: LD_VAR 0 5
88916: PPUSH
88917: EMPTY
88918: PPUSH
88919: CALL_OW 1
88923: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88924: LD_VAR 0 6
88928: PPUSH
88929: LD_INT 0
88931: PPUSH
88932: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88936: LD_VAR 0 6
88940: PPUSH
88941: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88945: LD_ADDR_EXP 92
88949: PUSH
88950: LD_EXP 92
88954: PPUSH
88955: LD_VAR 0 5
88959: PPUSH
88960: LD_EXP 92
88964: PUSH
88965: LD_VAR 0 5
88969: ARRAY
88970: PPUSH
88971: LD_INT 1
88973: PPUSH
88974: LD_VAR 0 6
88978: PPUSH
88979: CALL_OW 2
88983: PPUSH
88984: CALL_OW 1
88988: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88989: LD_VAR 0 5
88993: PPUSH
88994: LD_INT 112
88996: PPUSH
88997: CALL 65135 0 2
// end ; end ; end ;
89001: GO 88822
89003: POP
89004: POP
// end ;
89005: LD_VAR 0 3
89009: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
89010: LD_INT 0
89012: PPUSH
89013: PPUSH
89014: PPUSH
89015: PPUSH
89016: PPUSH
89017: PPUSH
89018: PPUSH
89019: PPUSH
// if not mc_bases or not skirmish then
89020: LD_EXP 63
89024: NOT
89025: IFTRUE 89034
89027: PUSH
89028: LD_EXP 61
89032: NOT
89033: OR
89034: IFFALSE 89038
// exit ;
89036: GO 90423
// for i = 1 to mc_bases do
89038: LD_ADDR_VAR 0 3
89042: PUSH
89043: DOUBLE
89044: LD_INT 1
89046: DEC
89047: ST_TO_ADDR
89048: LD_EXP 63
89052: PUSH
89053: FOR_TO
89054: IFFALSE 90421
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
89056: LD_VAR 0 1
89060: PUSH
89061: LD_EXP 63
89065: PUSH
89066: LD_VAR 0 3
89070: ARRAY
89071: IN
89072: IFTRUE 89092
89074: PUSH
89075: LD_VAR 0 1
89079: PUSH
89080: LD_EXP 70
89084: PUSH
89085: LD_VAR 0 3
89089: ARRAY
89090: IN
89091: OR
89092: IFTRUE 89112
89094: PUSH
89095: LD_VAR 0 1
89099: PUSH
89100: LD_EXP 85
89104: PUSH
89105: LD_VAR 0 3
89109: ARRAY
89110: IN
89111: OR
89112: IFTRUE 89132
89114: PUSH
89115: LD_VAR 0 1
89119: PUSH
89120: LD_EXP 82
89124: PUSH
89125: LD_VAR 0 3
89129: ARRAY
89130: IN
89131: OR
89132: IFTRUE 89152
89134: PUSH
89135: LD_VAR 0 1
89139: PUSH
89140: LD_EXP 92
89144: PUSH
89145: LD_VAR 0 3
89149: ARRAY
89150: IN
89151: OR
89152: IFTRUE 89172
89154: PUSH
89155: LD_VAR 0 1
89159: PUSH
89160: LD_EXP 93
89164: PUSH
89165: LD_VAR 0 3
89169: ARRAY
89170: IN
89171: OR
89172: IFFALSE 90419
// begin if un in mc_ape [ i ] then
89174: LD_VAR 0 1
89178: PUSH
89179: LD_EXP 92
89183: PUSH
89184: LD_VAR 0 3
89188: ARRAY
89189: IN
89190: IFFALSE 89229
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89192: LD_ADDR_EXP 92
89196: PUSH
89197: LD_EXP 92
89201: PPUSH
89202: LD_VAR 0 3
89206: PPUSH
89207: LD_EXP 92
89211: PUSH
89212: LD_VAR 0 3
89216: ARRAY
89217: PUSH
89218: LD_VAR 0 1
89222: DIFF
89223: PPUSH
89224: CALL_OW 1
89228: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89229: LD_VAR 0 1
89233: PUSH
89234: LD_EXP 93
89238: PUSH
89239: LD_VAR 0 3
89243: ARRAY
89244: IN
89245: IFFALSE 89269
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89247: LD_ADDR_EXP 93
89251: PUSH
89252: LD_EXP 93
89256: PPUSH
89257: LD_VAR 0 3
89261: PPUSH
89262: EMPTY
89263: PPUSH
89264: CALL_OW 1
89268: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89269: LD_VAR 0 1
89273: PPUSH
89274: CALL_OW 247
89278: PUSH
89279: LD_INT 2
89281: EQUAL
89282: IFFALSE 89363
89284: PUSH
89285: LD_VAR 0 1
89289: PPUSH
89290: CALL_OW 110
89294: PUSH
89295: LD_INT 20
89297: EQUAL
89298: IFTRUE 89318
89300: PUSH
89301: LD_VAR 0 1
89305: PUSH
89306: LD_EXP 85
89310: PUSH
89311: LD_VAR 0 3
89315: ARRAY
89316: IN
89317: OR
89318: IFTRUE 89362
89320: PUSH
89321: LD_VAR 0 1
89325: PPUSH
89326: CALL_OW 264
89330: PUSH
89331: LD_INT 12
89333: PUSH
89334: LD_INT 51
89336: PUSH
89337: LD_INT 89
89339: PUSH
89340: LD_INT 32
89342: PUSH
89343: LD_INT 13
89345: PUSH
89346: LD_INT 52
89348: PUSH
89349: LD_INT 31
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: IN
89361: OR
89362: AND
89363: IFFALSE 89671
// begin if un in mc_defender [ i ] then
89365: LD_VAR 0 1
89369: PUSH
89370: LD_EXP 85
89374: PUSH
89375: LD_VAR 0 3
89379: ARRAY
89380: IN
89381: IFFALSE 89420
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89383: LD_ADDR_EXP 85
89387: PUSH
89388: LD_EXP 85
89392: PPUSH
89393: LD_VAR 0 3
89397: PPUSH
89398: LD_EXP 85
89402: PUSH
89403: LD_VAR 0 3
89407: ARRAY
89408: PUSH
89409: LD_VAR 0 1
89413: DIFF
89414: PPUSH
89415: CALL_OW 1
89419: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89420: LD_ADDR_VAR 0 8
89424: PUSH
89425: LD_VAR 0 3
89429: PPUSH
89430: LD_INT 3
89432: PPUSH
89433: CALL 85959 0 2
89437: ST_TO_ADDR
// if fac then
89438: LD_VAR 0 8
89442: IFFALSE 89671
// begin for j in fac do
89444: LD_ADDR_VAR 0 4
89448: PUSH
89449: LD_VAR 0 8
89453: PUSH
89454: FOR_IN
89455: IFFALSE 89669
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89457: LD_ADDR_VAR 0 9
89461: PUSH
89462: LD_VAR 0 8
89466: PPUSH
89467: LD_VAR 0 1
89471: PPUSH
89472: CALL_OW 265
89476: PPUSH
89477: LD_VAR 0 1
89481: PPUSH
89482: CALL_OW 262
89486: PPUSH
89487: LD_VAR 0 1
89491: PPUSH
89492: CALL_OW 263
89496: PPUSH
89497: LD_VAR 0 1
89501: PPUSH
89502: CALL_OW 264
89506: PPUSH
89507: CALL 19994 0 5
89511: ST_TO_ADDR
// if components then
89512: LD_VAR 0 9
89516: IFFALSE 89667
// begin if GetWeapon ( un ) = ar_control_tower then
89518: LD_VAR 0 1
89522: PPUSH
89523: CALL_OW 264
89527: PUSH
89528: LD_INT 31
89530: EQUAL
89531: IFFALSE 89648
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89533: LD_VAR 0 1
89537: PPUSH
89538: CALL_OW 311
89542: PPUSH
89543: LD_INT 0
89545: PPUSH
89546: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89550: LD_ADDR_EXP 103
89554: PUSH
89555: LD_EXP 103
89559: PPUSH
89560: LD_VAR 0 3
89564: PPUSH
89565: LD_EXP 103
89569: PUSH
89570: LD_VAR 0 3
89574: ARRAY
89575: PUSH
89576: LD_VAR 0 1
89580: PPUSH
89581: CALL_OW 311
89585: DIFF
89586: PPUSH
89587: CALL_OW 1
89591: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89592: LD_ADDR_VAR 0 7
89596: PUSH
89597: LD_EXP 84
89601: PUSH
89602: LD_VAR 0 3
89606: ARRAY
89607: PPUSH
89608: LD_INT 1
89610: PPUSH
89611: LD_VAR 0 9
89615: PPUSH
89616: CALL_OW 2
89620: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89621: LD_ADDR_EXP 84
89625: PUSH
89626: LD_EXP 84
89630: PPUSH
89631: LD_VAR 0 3
89635: PPUSH
89636: LD_VAR 0 7
89640: PPUSH
89641: CALL_OW 1
89645: ST_TO_ADDR
// end else
89646: GO 89665
// MC_InsertProduceList ( i , [ components ] ) ;
89648: LD_VAR 0 3
89652: PPUSH
89653: LD_VAR 0 9
89657: PUSH
89658: EMPTY
89659: LIST
89660: PPUSH
89661: CALL 85504 0 2
// break ;
89665: GO 89669
// end ; end ;
89667: GO 89454
89669: POP
89670: POP
// end ; end ; if GetType ( un ) = unit_building then
89671: LD_VAR 0 1
89675: PPUSH
89676: CALL_OW 247
89680: PUSH
89681: LD_INT 3
89683: EQUAL
89684: IFFALSE 90087
// begin btype := GetBType ( un ) ;
89686: LD_ADDR_VAR 0 5
89690: PUSH
89691: LD_VAR 0 1
89695: PPUSH
89696: CALL_OW 266
89700: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89701: LD_VAR 0 5
89705: PUSH
89706: LD_INT 29
89708: PUSH
89709: LD_INT 30
89711: PUSH
89712: EMPTY
89713: LIST
89714: LIST
89715: IN
89716: IFFALSE 89789
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89718: LD_VAR 0 1
89722: PPUSH
89723: CALL_OW 250
89727: PPUSH
89728: LD_VAR 0 1
89732: PPUSH
89733: CALL_OW 251
89737: PPUSH
89738: LD_VAR 0 1
89742: PPUSH
89743: CALL_OW 255
89747: PPUSH
89748: CALL_OW 440
89752: NOT
89753: IFFALSE 89789
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89755: LD_VAR 0 1
89759: PPUSH
89760: CALL_OW 250
89764: PPUSH
89765: LD_VAR 0 1
89769: PPUSH
89770: CALL_OW 251
89774: PPUSH
89775: LD_VAR 0 1
89779: PPUSH
89780: CALL_OW 255
89784: PPUSH
89785: CALL_OW 441
// end ; if btype = b_warehouse then
89789: LD_VAR 0 5
89793: PUSH
89794: LD_INT 1
89796: EQUAL
89797: IFFALSE 89815
// begin btype := b_depot ;
89799: LD_ADDR_VAR 0 5
89803: PUSH
89804: LD_INT 0
89806: ST_TO_ADDR
// pos := 1 ;
89807: LD_ADDR_VAR 0 6
89811: PUSH
89812: LD_INT 1
89814: ST_TO_ADDR
// end ; if btype = b_factory then
89815: LD_VAR 0 5
89819: PUSH
89820: LD_INT 3
89822: EQUAL
89823: IFFALSE 89841
// begin btype := b_workshop ;
89825: LD_ADDR_VAR 0 5
89829: PUSH
89830: LD_INT 2
89832: ST_TO_ADDR
// pos := 1 ;
89833: LD_ADDR_VAR 0 6
89837: PUSH
89838: LD_INT 1
89840: ST_TO_ADDR
// end ; if btype = b_barracks then
89841: LD_VAR 0 5
89845: PUSH
89846: LD_INT 5
89848: EQUAL
89849: IFFALSE 89859
// btype := b_armoury ;
89851: LD_ADDR_VAR 0 5
89855: PUSH
89856: LD_INT 4
89858: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89859: LD_VAR 0 5
89863: PUSH
89864: LD_INT 7
89866: PUSH
89867: LD_INT 8
89869: PUSH
89870: EMPTY
89871: LIST
89872: LIST
89873: IN
89874: IFFALSE 89884
// btype := b_lab ;
89876: LD_ADDR_VAR 0 5
89880: PUSH
89881: LD_INT 6
89883: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89884: LD_ADDR_EXP 68
89888: PUSH
89889: LD_EXP 68
89893: PPUSH
89894: LD_VAR 0 3
89898: PUSH
89899: LD_EXP 68
89903: PUSH
89904: LD_VAR 0 3
89908: ARRAY
89909: PUSH
89910: LD_INT 1
89912: PLUS
89913: PUSH
89914: EMPTY
89915: LIST
89916: LIST
89917: PPUSH
89918: LD_VAR 0 5
89922: PUSH
89923: LD_VAR 0 1
89927: PPUSH
89928: CALL_OW 250
89932: PUSH
89933: LD_VAR 0 1
89937: PPUSH
89938: CALL_OW 251
89942: PUSH
89943: LD_VAR 0 1
89947: PPUSH
89948: CALL_OW 254
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: PPUSH
89959: CALL 22554 0 3
89963: ST_TO_ADDR
// if pos = 1 then
89964: LD_VAR 0 6
89968: PUSH
89969: LD_INT 1
89971: EQUAL
89972: IFFALSE 90087
// begin tmp := mc_build_list [ i ] ;
89974: LD_ADDR_VAR 0 7
89978: PUSH
89979: LD_EXP 68
89983: PUSH
89984: LD_VAR 0 3
89988: ARRAY
89989: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89990: LD_VAR 0 7
89994: PPUSH
89995: LD_INT 2
89997: PUSH
89998: LD_INT 30
90000: PUSH
90001: LD_INT 0
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 30
90010: PUSH
90011: LD_INT 1
90013: PUSH
90014: EMPTY
90015: LIST
90016: LIST
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: LIST
90022: PPUSH
90023: CALL_OW 72
90027: IFFALSE 90037
// pos := 2 ;
90029: LD_ADDR_VAR 0 6
90033: PUSH
90034: LD_INT 2
90036: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
90037: LD_ADDR_VAR 0 7
90041: PUSH
90042: LD_VAR 0 7
90046: PPUSH
90047: LD_VAR 0 6
90051: PPUSH
90052: LD_VAR 0 7
90056: PPUSH
90057: CALL 22880 0 3
90061: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90062: LD_ADDR_EXP 68
90066: PUSH
90067: LD_EXP 68
90071: PPUSH
90072: LD_VAR 0 3
90076: PPUSH
90077: LD_VAR 0 7
90081: PPUSH
90082: CALL_OW 1
90086: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90087: LD_VAR 0 1
90091: PUSH
90092: LD_EXP 63
90096: PUSH
90097: LD_VAR 0 3
90101: ARRAY
90102: IN
90103: IFFALSE 90142
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90105: LD_ADDR_EXP 63
90109: PUSH
90110: LD_EXP 63
90114: PPUSH
90115: LD_VAR 0 3
90119: PPUSH
90120: LD_EXP 63
90124: PUSH
90125: LD_VAR 0 3
90129: ARRAY
90130: PUSH
90131: LD_VAR 0 1
90135: DIFF
90136: PPUSH
90137: CALL_OW 1
90141: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90142: LD_VAR 0 1
90146: PUSH
90147: LD_EXP 70
90151: PUSH
90152: LD_VAR 0 3
90156: ARRAY
90157: IN
90158: IFFALSE 90197
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90160: LD_ADDR_EXP 70
90164: PUSH
90165: LD_EXP 70
90169: PPUSH
90170: LD_VAR 0 3
90174: PPUSH
90175: LD_EXP 70
90179: PUSH
90180: LD_VAR 0 3
90184: ARRAY
90185: PUSH
90186: LD_VAR 0 1
90190: DIFF
90191: PPUSH
90192: CALL_OW 1
90196: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90197: LD_VAR 0 1
90201: PUSH
90202: LD_EXP 82
90206: PUSH
90207: LD_VAR 0 3
90211: ARRAY
90212: IN
90213: IFFALSE 90252
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90215: LD_ADDR_EXP 82
90219: PUSH
90220: LD_EXP 82
90224: PPUSH
90225: LD_VAR 0 3
90229: PPUSH
90230: LD_EXP 82
90234: PUSH
90235: LD_VAR 0 3
90239: ARRAY
90240: PUSH
90241: LD_VAR 0 1
90245: DIFF
90246: PPUSH
90247: CALL_OW 1
90251: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90252: LD_VAR 0 1
90256: PUSH
90257: LD_EXP 85
90261: PUSH
90262: LD_VAR 0 3
90266: ARRAY
90267: IN
90268: IFFALSE 90307
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90270: LD_ADDR_EXP 85
90274: PUSH
90275: LD_EXP 85
90279: PPUSH
90280: LD_VAR 0 3
90284: PPUSH
90285: LD_EXP 85
90289: PUSH
90290: LD_VAR 0 3
90294: ARRAY
90295: PUSH
90296: LD_VAR 0 1
90300: DIFF
90301: PPUSH
90302: CALL_OW 1
90306: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90307: LD_VAR 0 1
90311: PUSH
90312: LD_EXP 72
90316: PUSH
90317: LD_VAR 0 3
90321: ARRAY
90322: IN
90323: IFFALSE 90362
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90325: LD_ADDR_EXP 72
90329: PUSH
90330: LD_EXP 72
90334: PPUSH
90335: LD_VAR 0 3
90339: PPUSH
90340: LD_EXP 72
90344: PUSH
90345: LD_VAR 0 3
90349: ARRAY
90350: PUSH
90351: LD_VAR 0 1
90355: DIFF
90356: PPUSH
90357: CALL_OW 1
90361: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90362: LD_VAR 0 1
90366: PUSH
90367: LD_EXP 71
90371: PUSH
90372: LD_VAR 0 3
90376: ARRAY
90377: IN
90378: IFFALSE 90417
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90380: LD_ADDR_EXP 71
90384: PUSH
90385: LD_EXP 71
90389: PPUSH
90390: LD_VAR 0 3
90394: PPUSH
90395: LD_EXP 71
90399: PUSH
90400: LD_VAR 0 3
90404: ARRAY
90405: PUSH
90406: LD_VAR 0 1
90410: DIFF
90411: PPUSH
90412: CALL_OW 1
90416: ST_TO_ADDR
// end ; break ;
90417: GO 90421
// end ;
90419: GO 89053
90421: POP
90422: POP
// end ;
90423: LD_VAR 0 2
90427: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90428: LD_INT 0
90430: PPUSH
90431: PPUSH
90432: PPUSH
// if not mc_bases or not skirmish then
90433: LD_EXP 63
90437: NOT
90438: IFTRUE 90447
90440: PUSH
90441: LD_EXP 61
90445: NOT
90446: OR
90447: IFFALSE 90451
// exit ;
90449: GO 90666
// for i = 1 to mc_bases do
90451: LD_ADDR_VAR 0 3
90455: PUSH
90456: DOUBLE
90457: LD_INT 1
90459: DEC
90460: ST_TO_ADDR
90461: LD_EXP 63
90465: PUSH
90466: FOR_TO
90467: IFFALSE 90664
// begin if building in mc_construct_list [ i ] then
90469: LD_VAR 0 1
90473: PUSH
90474: LD_EXP 70
90478: PUSH
90479: LD_VAR 0 3
90483: ARRAY
90484: IN
90485: IFFALSE 90662
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90487: LD_ADDR_EXP 70
90491: PUSH
90492: LD_EXP 70
90496: PPUSH
90497: LD_VAR 0 3
90501: PPUSH
90502: LD_EXP 70
90506: PUSH
90507: LD_VAR 0 3
90511: ARRAY
90512: PUSH
90513: LD_VAR 0 1
90517: DIFF
90518: PPUSH
90519: CALL_OW 1
90523: ST_TO_ADDR
// if building in mc_lab [ i ] then
90524: LD_VAR 0 1
90528: PUSH
90529: LD_EXP 96
90533: PUSH
90534: LD_VAR 0 3
90538: ARRAY
90539: IN
90540: IFFALSE 90595
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90542: LD_ADDR_EXP 97
90546: PUSH
90547: LD_EXP 97
90551: PPUSH
90552: LD_VAR 0 3
90556: PPUSH
90557: LD_EXP 97
90561: PUSH
90562: LD_VAR 0 3
90566: ARRAY
90567: PPUSH
90568: LD_INT 1
90570: PPUSH
90571: LD_EXP 97
90575: PUSH
90576: LD_VAR 0 3
90580: ARRAY
90581: PPUSH
90582: LD_INT 0
90584: PPUSH
90585: CALL 21962 0 4
90589: PPUSH
90590: CALL_OW 1
90594: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90595: LD_VAR 0 1
90599: PUSH
90600: LD_EXP 63
90604: PUSH
90605: LD_VAR 0 3
90609: ARRAY
90610: IN
90611: NOT
90612: IFFALSE 90658
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90614: LD_ADDR_EXP 63
90618: PUSH
90619: LD_EXP 63
90623: PPUSH
90624: LD_VAR 0 3
90628: PUSH
90629: LD_EXP 63
90633: PUSH
90634: LD_VAR 0 3
90638: ARRAY
90639: PUSH
90640: LD_INT 1
90642: PLUS
90643: PUSH
90644: EMPTY
90645: LIST
90646: LIST
90647: PPUSH
90648: LD_VAR 0 1
90652: PPUSH
90653: CALL 22554 0 3
90657: ST_TO_ADDR
// exit ;
90658: POP
90659: POP
90660: GO 90666
// end ; end ;
90662: GO 90466
90664: POP
90665: POP
// end ;
90666: LD_VAR 0 2
90670: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90671: LD_INT 0
90673: PPUSH
90674: PPUSH
90675: PPUSH
90676: PPUSH
90677: PPUSH
90678: PPUSH
90679: PPUSH
// if not mc_bases or not skirmish then
90680: LD_EXP 63
90684: NOT
90685: IFTRUE 90694
90687: PUSH
90688: LD_EXP 61
90692: NOT
90693: OR
90694: IFFALSE 90698
// exit ;
90696: GO 91359
// for i = 1 to mc_bases do
90698: LD_ADDR_VAR 0 3
90702: PUSH
90703: DOUBLE
90704: LD_INT 1
90706: DEC
90707: ST_TO_ADDR
90708: LD_EXP 63
90712: PUSH
90713: FOR_TO
90714: IFFALSE 91357
// begin if building in mc_construct_list [ i ] then
90716: LD_VAR 0 1
90720: PUSH
90721: LD_EXP 70
90725: PUSH
90726: LD_VAR 0 3
90730: ARRAY
90731: IN
90732: IFFALSE 91355
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90734: LD_ADDR_EXP 70
90738: PUSH
90739: LD_EXP 70
90743: PPUSH
90744: LD_VAR 0 3
90748: PPUSH
90749: LD_EXP 70
90753: PUSH
90754: LD_VAR 0 3
90758: ARRAY
90759: PUSH
90760: LD_VAR 0 1
90764: DIFF
90765: PPUSH
90766: CALL_OW 1
90770: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90771: LD_ADDR_EXP 63
90775: PUSH
90776: LD_EXP 63
90780: PPUSH
90781: LD_VAR 0 3
90785: PUSH
90786: LD_EXP 63
90790: PUSH
90791: LD_VAR 0 3
90795: ARRAY
90796: PUSH
90797: LD_INT 1
90799: PLUS
90800: PUSH
90801: EMPTY
90802: LIST
90803: LIST
90804: PPUSH
90805: LD_VAR 0 1
90809: PPUSH
90810: CALL 22554 0 3
90814: ST_TO_ADDR
// btype := GetBType ( building ) ;
90815: LD_ADDR_VAR 0 5
90819: PUSH
90820: LD_VAR 0 1
90824: PPUSH
90825: CALL_OW 266
90829: ST_TO_ADDR
// side := GetSide ( building ) ;
90830: LD_ADDR_VAR 0 8
90834: PUSH
90835: LD_VAR 0 1
90839: PPUSH
90840: CALL_OW 255
90844: ST_TO_ADDR
// if btype = b_lab then
90845: LD_VAR 0 5
90849: PUSH
90850: LD_INT 6
90852: EQUAL
90853: IFFALSE 90903
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90855: LD_ADDR_EXP 96
90859: PUSH
90860: LD_EXP 96
90864: PPUSH
90865: LD_VAR 0 3
90869: PUSH
90870: LD_EXP 96
90874: PUSH
90875: LD_VAR 0 3
90879: ARRAY
90880: PUSH
90881: LD_INT 1
90883: PLUS
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PPUSH
90889: LD_VAR 0 1
90893: PPUSH
90894: CALL 22554 0 3
90898: ST_TO_ADDR
// exit ;
90899: POP
90900: POP
90901: GO 91359
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90903: LD_VAR 0 5
90907: PUSH
90908: LD_INT 0
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: LD_INT 4
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: LIST
90921: IN
90922: IFFALSE 91046
// begin if btype = b_armoury then
90924: LD_VAR 0 5
90928: PUSH
90929: LD_INT 4
90931: EQUAL
90932: IFFALSE 90942
// btype := b_barracks ;
90934: LD_ADDR_VAR 0 5
90938: PUSH
90939: LD_INT 5
90941: ST_TO_ADDR
// if btype = b_depot then
90942: LD_VAR 0 5
90946: PUSH
90947: LD_INT 0
90949: EQUAL
90950: IFFALSE 90960
// btype := b_warehouse ;
90952: LD_ADDR_VAR 0 5
90956: PUSH
90957: LD_INT 1
90959: ST_TO_ADDR
// if btype = b_workshop then
90960: LD_VAR 0 5
90964: PUSH
90965: LD_INT 2
90967: EQUAL
90968: IFFALSE 90978
// btype := b_factory ;
90970: LD_ADDR_VAR 0 5
90974: PUSH
90975: LD_INT 3
90977: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90978: LD_VAR 0 5
90982: PPUSH
90983: LD_VAR 0 8
90987: PPUSH
90988: CALL_OW 323
90992: PUSH
90993: LD_INT 1
90995: EQUAL
90996: IFFALSE 91042
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90998: LD_ADDR_EXP 95
91002: PUSH
91003: LD_EXP 95
91007: PPUSH
91008: LD_VAR 0 3
91012: PUSH
91013: LD_EXP 95
91017: PUSH
91018: LD_VAR 0 3
91022: ARRAY
91023: PUSH
91024: LD_INT 1
91026: PLUS
91027: PUSH
91028: EMPTY
91029: LIST
91030: LIST
91031: PPUSH
91032: LD_VAR 0 1
91036: PPUSH
91037: CALL 22554 0 3
91041: ST_TO_ADDR
// exit ;
91042: POP
91043: POP
91044: GO 91359
// end ; if btype in [ b_bunker , b_turret ] then
91046: LD_VAR 0 5
91050: PUSH
91051: LD_INT 32
91053: PUSH
91054: LD_INT 33
91056: PUSH
91057: EMPTY
91058: LIST
91059: LIST
91060: IN
91061: IFFALSE 91351
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91063: LD_ADDR_EXP 71
91067: PUSH
91068: LD_EXP 71
91072: PPUSH
91073: LD_VAR 0 3
91077: PUSH
91078: LD_EXP 71
91082: PUSH
91083: LD_VAR 0 3
91087: ARRAY
91088: PUSH
91089: LD_INT 1
91091: PLUS
91092: PUSH
91093: EMPTY
91094: LIST
91095: LIST
91096: PPUSH
91097: LD_VAR 0 1
91101: PPUSH
91102: CALL 22554 0 3
91106: ST_TO_ADDR
// if btype = b_bunker then
91107: LD_VAR 0 5
91111: PUSH
91112: LD_INT 32
91114: EQUAL
91115: IFFALSE 91351
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91117: LD_ADDR_EXP 72
91121: PUSH
91122: LD_EXP 72
91126: PPUSH
91127: LD_VAR 0 3
91131: PUSH
91132: LD_EXP 72
91136: PUSH
91137: LD_VAR 0 3
91141: ARRAY
91142: PUSH
91143: LD_INT 1
91145: PLUS
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PPUSH
91151: LD_VAR 0 1
91155: PPUSH
91156: CALL 22554 0 3
91160: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91161: LD_ADDR_VAR 0 6
91165: PUSH
91166: LD_EXP 63
91170: PUSH
91171: LD_VAR 0 3
91175: ARRAY
91176: PPUSH
91177: LD_INT 25
91179: PUSH
91180: LD_INT 1
91182: PUSH
91183: EMPTY
91184: LIST
91185: LIST
91186: PUSH
91187: LD_INT 3
91189: PUSH
91190: LD_INT 54
91192: PUSH
91193: EMPTY
91194: LIST
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: PPUSH
91204: CALL_OW 72
91208: ST_TO_ADDR
// if tmp then
91209: LD_VAR 0 6
91213: IFFALSE 91219
// exit ;
91215: POP
91216: POP
91217: GO 91359
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91219: LD_ADDR_VAR 0 6
91223: PUSH
91224: LD_EXP 63
91228: PUSH
91229: LD_VAR 0 3
91233: ARRAY
91234: PPUSH
91235: LD_INT 2
91237: PUSH
91238: LD_INT 30
91240: PUSH
91241: LD_INT 4
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 30
91250: PUSH
91251: LD_INT 5
91253: PUSH
91254: EMPTY
91255: LIST
91256: LIST
91257: PUSH
91258: EMPTY
91259: LIST
91260: LIST
91261: LIST
91262: PPUSH
91263: CALL_OW 72
91267: ST_TO_ADDR
// if not tmp then
91268: LD_VAR 0 6
91272: NOT
91273: IFFALSE 91279
// exit ;
91275: POP
91276: POP
91277: GO 91359
// for j in tmp do
91279: LD_ADDR_VAR 0 4
91283: PUSH
91284: LD_VAR 0 6
91288: PUSH
91289: FOR_IN
91290: IFFALSE 91349
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91292: LD_ADDR_VAR 0 7
91296: PUSH
91297: LD_VAR 0 4
91301: PPUSH
91302: CALL_OW 313
91306: PPUSH
91307: LD_INT 25
91309: PUSH
91310: LD_INT 1
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PPUSH
91317: CALL_OW 72
91321: ST_TO_ADDR
// if units then
91322: LD_VAR 0 7
91326: IFFALSE 91347
// begin ComExitBuilding ( units [ 1 ] ) ;
91328: LD_VAR 0 7
91332: PUSH
91333: LD_INT 1
91335: ARRAY
91336: PPUSH
91337: CALL_OW 122
// exit ;
91341: POP
91342: POP
91343: POP
91344: POP
91345: GO 91359
// end ; end ;
91347: GO 91289
91349: POP
91350: POP
// end ; end ; exit ;
91351: POP
91352: POP
91353: GO 91359
// end ; end ;
91355: GO 90713
91357: POP
91358: POP
// end ;
91359: LD_VAR 0 2
91363: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91364: LD_INT 0
91366: PPUSH
91367: PPUSH
91368: PPUSH
91369: PPUSH
91370: PPUSH
91371: PPUSH
91372: PPUSH
// if not mc_bases or not skirmish then
91373: LD_EXP 63
91377: NOT
91378: IFTRUE 91387
91380: PUSH
91381: LD_EXP 61
91385: NOT
91386: OR
91387: IFFALSE 91391
// exit ;
91389: GO 91656
// btype := GetBType ( building ) ;
91391: LD_ADDR_VAR 0 6
91395: PUSH
91396: LD_VAR 0 1
91400: PPUSH
91401: CALL_OW 266
91405: ST_TO_ADDR
// x := GetX ( building ) ;
91406: LD_ADDR_VAR 0 7
91410: PUSH
91411: LD_VAR 0 1
91415: PPUSH
91416: CALL_OW 250
91420: ST_TO_ADDR
// y := GetY ( building ) ;
91421: LD_ADDR_VAR 0 8
91425: PUSH
91426: LD_VAR 0 1
91430: PPUSH
91431: CALL_OW 251
91435: ST_TO_ADDR
// d := GetDir ( building ) ;
91436: LD_ADDR_VAR 0 9
91440: PUSH
91441: LD_VAR 0 1
91445: PPUSH
91446: CALL_OW 254
91450: ST_TO_ADDR
// for i = 1 to mc_bases do
91451: LD_ADDR_VAR 0 4
91455: PUSH
91456: DOUBLE
91457: LD_INT 1
91459: DEC
91460: ST_TO_ADDR
91461: LD_EXP 63
91465: PUSH
91466: FOR_TO
91467: IFFALSE 91654
// begin if not mc_build_list [ i ] then
91469: LD_EXP 68
91473: PUSH
91474: LD_VAR 0 4
91478: ARRAY
91479: NOT
91480: IFFALSE 91484
// continue ;
91482: GO 91466
// for j := 1 to mc_build_list [ i ] do
91484: LD_ADDR_VAR 0 5
91488: PUSH
91489: DOUBLE
91490: LD_INT 1
91492: DEC
91493: ST_TO_ADDR
91494: LD_EXP 68
91498: PUSH
91499: LD_VAR 0 4
91503: ARRAY
91504: PUSH
91505: FOR_TO
91506: IFFALSE 91650
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91508: LD_VAR 0 6
91512: PUSH
91513: LD_VAR 0 7
91517: PUSH
91518: LD_VAR 0 8
91522: PUSH
91523: LD_VAR 0 9
91527: PUSH
91528: EMPTY
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: PPUSH
91534: LD_EXP 68
91538: PUSH
91539: LD_VAR 0 4
91543: ARRAY
91544: PUSH
91545: LD_VAR 0 5
91549: ARRAY
91550: PPUSH
91551: CALL 29161 0 2
91555: IFFALSE 91648
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91557: LD_ADDR_EXP 68
91561: PUSH
91562: LD_EXP 68
91566: PPUSH
91567: LD_VAR 0 4
91571: PPUSH
91572: LD_EXP 68
91576: PUSH
91577: LD_VAR 0 4
91581: ARRAY
91582: PPUSH
91583: LD_VAR 0 5
91587: PPUSH
91588: CALL_OW 3
91592: PPUSH
91593: CALL_OW 1
91597: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91598: LD_ADDR_EXP 70
91602: PUSH
91603: LD_EXP 70
91607: PPUSH
91608: LD_VAR 0 4
91612: PUSH
91613: LD_EXP 70
91617: PUSH
91618: LD_VAR 0 4
91622: ARRAY
91623: PUSH
91624: LD_INT 1
91626: PLUS
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PPUSH
91632: LD_VAR 0 1
91636: PPUSH
91637: CALL 22554 0 3
91641: ST_TO_ADDR
// exit ;
91642: POP
91643: POP
91644: POP
91645: POP
91646: GO 91656
// end ;
91648: GO 91505
91650: POP
91651: POP
// end ;
91652: GO 91466
91654: POP
91655: POP
// end ;
91656: LD_VAR 0 3
91660: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91661: LD_INT 0
91663: PPUSH
91664: PPUSH
91665: PPUSH
// if not mc_bases or not skirmish then
91666: LD_EXP 63
91670: NOT
91671: IFTRUE 91680
91673: PUSH
91674: LD_EXP 61
91678: NOT
91679: OR
91680: IFFALSE 91684
// exit ;
91682: GO 91880
// for i = 1 to mc_bases do
91684: LD_ADDR_VAR 0 4
91688: PUSH
91689: DOUBLE
91690: LD_INT 1
91692: DEC
91693: ST_TO_ADDR
91694: LD_EXP 63
91698: PUSH
91699: FOR_TO
91700: IFFALSE 91789
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91702: LD_VAR 0 1
91706: PUSH
91707: LD_EXP 71
91711: PUSH
91712: LD_VAR 0 4
91716: ARRAY
91717: IN
91718: IFFALSE 91739
91720: PUSH
91721: LD_VAR 0 1
91725: PUSH
91726: LD_EXP 72
91730: PUSH
91731: LD_VAR 0 4
91735: ARRAY
91736: IN
91737: NOT
91738: AND
91739: IFFALSE 91787
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91741: LD_ADDR_EXP 72
91745: PUSH
91746: LD_EXP 72
91750: PPUSH
91751: LD_VAR 0 4
91755: PUSH
91756: LD_EXP 72
91760: PUSH
91761: LD_VAR 0 4
91765: ARRAY
91766: PUSH
91767: LD_INT 1
91769: PLUS
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PPUSH
91775: LD_VAR 0 1
91779: PPUSH
91780: CALL 22554 0 3
91784: ST_TO_ADDR
// break ;
91785: GO 91789
// end ; end ;
91787: GO 91699
91789: POP
91790: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91791: LD_VAR 0 1
91795: PPUSH
91796: CALL_OW 257
91800: PUSH
91801: LD_EXP 89
91805: IN
91806: IFFALSE 91823
91808: PUSH
91809: LD_VAR 0 1
91813: PPUSH
91814: CALL_OW 266
91818: PUSH
91819: LD_INT 5
91821: EQUAL
91822: AND
91823: IFFALSE 91840
91825: PUSH
91826: LD_VAR 0 2
91830: PPUSH
91831: CALL_OW 110
91835: PUSH
91836: LD_INT 18
91838: NONEQUAL
91839: AND
91840: IFFALSE 91880
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91842: LD_VAR 0 2
91846: PPUSH
91847: CALL_OW 257
91851: PUSH
91852: LD_INT 5
91854: PUSH
91855: LD_INT 8
91857: PUSH
91858: LD_INT 9
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: LIST
91865: IN
91866: IFFALSE 91880
// SetClass ( unit , 1 ) ;
91868: LD_VAR 0 2
91872: PPUSH
91873: LD_INT 1
91875: PPUSH
91876: CALL_OW 336
// end ;
91880: LD_VAR 0 3
91884: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91885: LD_INT 0
91887: PPUSH
91888: PPUSH
// if not mc_bases or not skirmish then
91889: LD_EXP 63
91893: NOT
91894: IFTRUE 91903
91896: PUSH
91897: LD_EXP 61
91901: NOT
91902: OR
91903: IFFALSE 91907
// exit ;
91905: GO 92023
// if GetLives ( abandoned_vehicle ) > 250 then
91907: LD_VAR 0 2
91911: PPUSH
91912: CALL_OW 256
91916: PUSH
91917: LD_INT 250
91919: GREATER
91920: IFFALSE 91924
// exit ;
91922: GO 92023
// for i = 1 to mc_bases do
91924: LD_ADDR_VAR 0 6
91928: PUSH
91929: DOUBLE
91930: LD_INT 1
91932: DEC
91933: ST_TO_ADDR
91934: LD_EXP 63
91938: PUSH
91939: FOR_TO
91940: IFFALSE 92021
// begin if driver in mc_bases [ i ] then
91942: LD_VAR 0 1
91946: PUSH
91947: LD_EXP 63
91951: PUSH
91952: LD_VAR 0 6
91956: ARRAY
91957: IN
91958: IFFALSE 92019
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91960: LD_VAR 0 1
91964: PPUSH
91965: LD_EXP 63
91969: PUSH
91970: LD_VAR 0 6
91974: ARRAY
91975: PPUSH
91976: LD_INT 2
91978: PUSH
91979: LD_INT 30
91981: PUSH
91982: LD_INT 0
91984: PUSH
91985: EMPTY
91986: LIST
91987: LIST
91988: PUSH
91989: LD_INT 30
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: EMPTY
91996: LIST
91997: LIST
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: LIST
92003: PPUSH
92004: CALL_OW 72
92008: PUSH
92009: LD_INT 1
92011: ARRAY
92012: PPUSH
92013: CALL 56491 0 2
// break ;
92017: GO 92021
// end ; end ;
92019: GO 91939
92021: POP
92022: POP
// end ; end_of_file end_of_file
92023: LD_VAR 0 5
92027: RET
// export globalGameSaveCounter ; every 0 0$1 do
92028: GO 92030
92030: DISABLE
// begin enable ;
92031: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
92032: LD_STRING updateTimer(
92034: PUSH
92035: LD_OWVAR 1
92039: STR
92040: PUSH
92041: LD_STRING );
92043: STR
92044: PPUSH
92045: CALL_OW 559
// end ;
92049: END
// every 0 0$1 do
92050: GO 92052
92052: DISABLE
// begin globalGameSaveCounter := 0 ;
92053: LD_ADDR_EXP 108
92057: PUSH
92058: LD_INT 0
92060: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92061: LD_STRING setGameSaveCounter(0)
92063: PPUSH
92064: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92068: LD_STRING initStreamRollete();
92070: PPUSH
92071: CALL_OW 559
// InitStreamMode ;
92075: CALL 93427 0 0
// DefineStreamItems ( false ) ;
92079: LD_INT 0
92081: PPUSH
92082: CALL 93891 0 1
// end ;
92086: END
// export function SOS_MapStart ( ) ; begin
92087: LD_INT 0
92089: PPUSH
// if streamModeActive then
92090: LD_EXP 109
92094: IFFALSE 92103
// DefineStreamItems ( true ) ;
92096: LD_INT 1
92098: PPUSH
92099: CALL 93891 0 1
// ToLua ( LFC_UNITS_CUSTOM_ICON = {}; ) ;
92103: LD_STRING LFC_UNITS_CUSTOM_ICON = {};
92105: PPUSH
92106: CALL_OW 559
// UpdateLuaVariables ( ) ;
92110: CALL 92127 0 0
// UpdateFactoryWaypoints ( ) ;
92114: CALL 107013 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92118: CALL 107265 0 0
// end ;
92122: LD_VAR 0 1
92126: RET
// function UpdateLuaVariables ( ) ; begin
92127: LD_INT 0
92129: PPUSH
// if globalGameSaveCounter then
92130: LD_EXP 108
92134: IFFALSE 92168
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92136: LD_ADDR_EXP 108
92140: PUSH
92141: LD_EXP 108
92145: PPUSH
92146: CALL 56985 0 1
92150: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92151: LD_STRING setGameSaveCounter(
92153: PUSH
92154: LD_EXP 108
92158: STR
92159: PUSH
92160: LD_STRING )
92162: STR
92163: PPUSH
92164: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92168: LD_STRING setGameDifficulty(
92170: PUSH
92171: LD_OWVAR 67
92175: STR
92176: PUSH
92177: LD_STRING )
92179: STR
92180: PPUSH
92181: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92185: LD_STRING displayDifficulty(
92187: PUSH
92188: LD_OWVAR 67
92192: STR
92193: PUSH
92194: LD_STRING )
92196: STR
92197: PPUSH
92198: CALL_OW 559
// end ;
92202: LD_VAR 0 1
92206: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92207: LD_INT 0
92209: PPUSH
// if p2 = stream_mode then
92210: LD_VAR 0 2
92214: PUSH
92215: LD_INT 100
92217: EQUAL
92218: IFFALSE 93221
// begin if not StreamModeActive then
92220: LD_EXP 109
92224: NOT
92225: IFFALSE 92235
// StreamModeActive := true ;
92227: LD_ADDR_EXP 109
92231: PUSH
92232: LD_INT 1
92234: ST_TO_ADDR
// if p3 = 0 then
92235: LD_VAR 0 3
92239: PUSH
92240: LD_INT 0
92242: EQUAL
92243: IFFALSE 92249
// InitStreamMode ;
92245: CALL 93427 0 0
// if p3 = 1 then
92249: LD_VAR 0 3
92253: PUSH
92254: LD_INT 1
92256: EQUAL
92257: IFFALSE 92267
// sRocket := true ;
92259: LD_ADDR_EXP 114
92263: PUSH
92264: LD_INT 1
92266: ST_TO_ADDR
// if p3 = 2 then
92267: LD_VAR 0 3
92271: PUSH
92272: LD_INT 2
92274: EQUAL
92275: IFFALSE 92285
// sSpeed := true ;
92277: LD_ADDR_EXP 113
92281: PUSH
92282: LD_INT 1
92284: ST_TO_ADDR
// if p3 = 3 then
92285: LD_VAR 0 3
92289: PUSH
92290: LD_INT 3
92292: EQUAL
92293: IFFALSE 92303
// sEngine := true ;
92295: LD_ADDR_EXP 115
92299: PUSH
92300: LD_INT 1
92302: ST_TO_ADDR
// if p3 = 4 then
92303: LD_VAR 0 3
92307: PUSH
92308: LD_INT 4
92310: EQUAL
92311: IFFALSE 92321
// sSpec := true ;
92313: LD_ADDR_EXP 112
92317: PUSH
92318: LD_INT 1
92320: ST_TO_ADDR
// if p3 = 5 then
92321: LD_VAR 0 3
92325: PUSH
92326: LD_INT 5
92328: EQUAL
92329: IFFALSE 92339
// sLevel := true ;
92331: LD_ADDR_EXP 116
92335: PUSH
92336: LD_INT 1
92338: ST_TO_ADDR
// if p3 = 6 then
92339: LD_VAR 0 3
92343: PUSH
92344: LD_INT 6
92346: EQUAL
92347: IFFALSE 92357
// sArmoury := true ;
92349: LD_ADDR_EXP 117
92353: PUSH
92354: LD_INT 1
92356: ST_TO_ADDR
// if p3 = 7 then
92357: LD_VAR 0 3
92361: PUSH
92362: LD_INT 7
92364: EQUAL
92365: IFFALSE 92375
// sRadar := true ;
92367: LD_ADDR_EXP 118
92371: PUSH
92372: LD_INT 1
92374: ST_TO_ADDR
// if p3 = 8 then
92375: LD_VAR 0 3
92379: PUSH
92380: LD_INT 8
92382: EQUAL
92383: IFFALSE 92393
// sBunker := true ;
92385: LD_ADDR_EXP 119
92389: PUSH
92390: LD_INT 1
92392: ST_TO_ADDR
// if p3 = 9 then
92393: LD_VAR 0 3
92397: PUSH
92398: LD_INT 9
92400: EQUAL
92401: IFFALSE 92411
// sHack := true ;
92403: LD_ADDR_EXP 120
92407: PUSH
92408: LD_INT 1
92410: ST_TO_ADDR
// if p3 = 10 then
92411: LD_VAR 0 3
92415: PUSH
92416: LD_INT 10
92418: EQUAL
92419: IFFALSE 92429
// sFire := true ;
92421: LD_ADDR_EXP 121
92425: PUSH
92426: LD_INT 1
92428: ST_TO_ADDR
// if p3 = 11 then
92429: LD_VAR 0 3
92433: PUSH
92434: LD_INT 11
92436: EQUAL
92437: IFFALSE 92447
// sRefresh := true ;
92439: LD_ADDR_EXP 122
92443: PUSH
92444: LD_INT 1
92446: ST_TO_ADDR
// if p3 = 12 then
92447: LD_VAR 0 3
92451: PUSH
92452: LD_INT 12
92454: EQUAL
92455: IFFALSE 92465
// sExp := true ;
92457: LD_ADDR_EXP 123
92461: PUSH
92462: LD_INT 1
92464: ST_TO_ADDR
// if p3 = 13 then
92465: LD_VAR 0 3
92469: PUSH
92470: LD_INT 13
92472: EQUAL
92473: IFFALSE 92483
// sDepot := true ;
92475: LD_ADDR_EXP 124
92479: PUSH
92480: LD_INT 1
92482: ST_TO_ADDR
// if p3 = 14 then
92483: LD_VAR 0 3
92487: PUSH
92488: LD_INT 14
92490: EQUAL
92491: IFFALSE 92501
// sFlag := true ;
92493: LD_ADDR_EXP 125
92497: PUSH
92498: LD_INT 1
92500: ST_TO_ADDR
// if p3 = 15 then
92501: LD_VAR 0 3
92505: PUSH
92506: LD_INT 15
92508: EQUAL
92509: IFFALSE 92519
// sKamikadze := true ;
92511: LD_ADDR_EXP 133
92515: PUSH
92516: LD_INT 1
92518: ST_TO_ADDR
// if p3 = 16 then
92519: LD_VAR 0 3
92523: PUSH
92524: LD_INT 16
92526: EQUAL
92527: IFFALSE 92537
// sTroll := true ;
92529: LD_ADDR_EXP 134
92533: PUSH
92534: LD_INT 1
92536: ST_TO_ADDR
// if p3 = 17 then
92537: LD_VAR 0 3
92541: PUSH
92542: LD_INT 17
92544: EQUAL
92545: IFFALSE 92555
// sSlow := true ;
92547: LD_ADDR_EXP 135
92551: PUSH
92552: LD_INT 1
92554: ST_TO_ADDR
// if p3 = 18 then
92555: LD_VAR 0 3
92559: PUSH
92560: LD_INT 18
92562: EQUAL
92563: IFFALSE 92573
// sLack := true ;
92565: LD_ADDR_EXP 136
92569: PUSH
92570: LD_INT 1
92572: ST_TO_ADDR
// if p3 = 19 then
92573: LD_VAR 0 3
92577: PUSH
92578: LD_INT 19
92580: EQUAL
92581: IFFALSE 92591
// sTank := true ;
92583: LD_ADDR_EXP 138
92587: PUSH
92588: LD_INT 1
92590: ST_TO_ADDR
// if p3 = 20 then
92591: LD_VAR 0 3
92595: PUSH
92596: LD_INT 20
92598: EQUAL
92599: IFFALSE 92609
// sRemote := true ;
92601: LD_ADDR_EXP 139
92605: PUSH
92606: LD_INT 1
92608: ST_TO_ADDR
// if p3 = 21 then
92609: LD_VAR 0 3
92613: PUSH
92614: LD_INT 21
92616: EQUAL
92617: IFFALSE 92627
// sPowell := true ;
92619: LD_ADDR_EXP 140
92623: PUSH
92624: LD_INT 1
92626: ST_TO_ADDR
// if p3 = 22 then
92627: LD_VAR 0 3
92631: PUSH
92632: LD_INT 22
92634: EQUAL
92635: IFFALSE 92645
// sTeleport := true ;
92637: LD_ADDR_EXP 143
92641: PUSH
92642: LD_INT 1
92644: ST_TO_ADDR
// if p3 = 23 then
92645: LD_VAR 0 3
92649: PUSH
92650: LD_INT 23
92652: EQUAL
92653: IFFALSE 92663
// sOilTower := true ;
92655: LD_ADDR_EXP 145
92659: PUSH
92660: LD_INT 1
92662: ST_TO_ADDR
// if p3 = 24 then
92663: LD_VAR 0 3
92667: PUSH
92668: LD_INT 24
92670: EQUAL
92671: IFFALSE 92681
// sShovel := true ;
92673: LD_ADDR_EXP 146
92677: PUSH
92678: LD_INT 1
92680: ST_TO_ADDR
// if p3 = 25 then
92681: LD_VAR 0 3
92685: PUSH
92686: LD_INT 25
92688: EQUAL
92689: IFFALSE 92699
// sSheik := true ;
92691: LD_ADDR_EXP 147
92695: PUSH
92696: LD_INT 1
92698: ST_TO_ADDR
// if p3 = 26 then
92699: LD_VAR 0 3
92703: PUSH
92704: LD_INT 26
92706: EQUAL
92707: IFFALSE 92717
// sEarthquake := true ;
92709: LD_ADDR_EXP 149
92713: PUSH
92714: LD_INT 1
92716: ST_TO_ADDR
// if p3 = 27 then
92717: LD_VAR 0 3
92721: PUSH
92722: LD_INT 27
92724: EQUAL
92725: IFFALSE 92735
// sAI := true ;
92727: LD_ADDR_EXP 150
92731: PUSH
92732: LD_INT 1
92734: ST_TO_ADDR
// if p3 = 28 then
92735: LD_VAR 0 3
92739: PUSH
92740: LD_INT 28
92742: EQUAL
92743: IFFALSE 92753
// sCargo := true ;
92745: LD_ADDR_EXP 153
92749: PUSH
92750: LD_INT 1
92752: ST_TO_ADDR
// if p3 = 29 then
92753: LD_VAR 0 3
92757: PUSH
92758: LD_INT 29
92760: EQUAL
92761: IFFALSE 92771
// sDLaser := true ;
92763: LD_ADDR_EXP 154
92767: PUSH
92768: LD_INT 1
92770: ST_TO_ADDR
// if p3 = 30 then
92771: LD_VAR 0 3
92775: PUSH
92776: LD_INT 30
92778: EQUAL
92779: IFFALSE 92789
// sExchange := true ;
92781: LD_ADDR_EXP 155
92785: PUSH
92786: LD_INT 1
92788: ST_TO_ADDR
// if p3 = 31 then
92789: LD_VAR 0 3
92793: PUSH
92794: LD_INT 31
92796: EQUAL
92797: IFFALSE 92807
// sFac := true ;
92799: LD_ADDR_EXP 156
92803: PUSH
92804: LD_INT 1
92806: ST_TO_ADDR
// if p3 = 32 then
92807: LD_VAR 0 3
92811: PUSH
92812: LD_INT 32
92814: EQUAL
92815: IFFALSE 92825
// sPower := true ;
92817: LD_ADDR_EXP 157
92821: PUSH
92822: LD_INT 1
92824: ST_TO_ADDR
// if p3 = 33 then
92825: LD_VAR 0 3
92829: PUSH
92830: LD_INT 33
92832: EQUAL
92833: IFFALSE 92843
// sRandom := true ;
92835: LD_ADDR_EXP 158
92839: PUSH
92840: LD_INT 1
92842: ST_TO_ADDR
// if p3 = 34 then
92843: LD_VAR 0 3
92847: PUSH
92848: LD_INT 34
92850: EQUAL
92851: IFFALSE 92861
// sShield := true ;
92853: LD_ADDR_EXP 159
92857: PUSH
92858: LD_INT 1
92860: ST_TO_ADDR
// if p3 = 35 then
92861: LD_VAR 0 3
92865: PUSH
92866: LD_INT 35
92868: EQUAL
92869: IFFALSE 92879
// sTime := true ;
92871: LD_ADDR_EXP 160
92875: PUSH
92876: LD_INT 1
92878: ST_TO_ADDR
// if p3 = 36 then
92879: LD_VAR 0 3
92883: PUSH
92884: LD_INT 36
92886: EQUAL
92887: IFFALSE 92897
// sTools := true ;
92889: LD_ADDR_EXP 161
92893: PUSH
92894: LD_INT 1
92896: ST_TO_ADDR
// if p3 = 101 then
92897: LD_VAR 0 3
92901: PUSH
92902: LD_INT 101
92904: EQUAL
92905: IFFALSE 92915
// sSold := true ;
92907: LD_ADDR_EXP 126
92911: PUSH
92912: LD_INT 1
92914: ST_TO_ADDR
// if p3 = 102 then
92915: LD_VAR 0 3
92919: PUSH
92920: LD_INT 102
92922: EQUAL
92923: IFFALSE 92933
// sDiff := true ;
92925: LD_ADDR_EXP 127
92929: PUSH
92930: LD_INT 1
92932: ST_TO_ADDR
// if p3 = 103 then
92933: LD_VAR 0 3
92937: PUSH
92938: LD_INT 103
92940: EQUAL
92941: IFFALSE 92951
// sFog := true ;
92943: LD_ADDR_EXP 130
92947: PUSH
92948: LD_INT 1
92950: ST_TO_ADDR
// if p3 = 104 then
92951: LD_VAR 0 3
92955: PUSH
92956: LD_INT 104
92958: EQUAL
92959: IFFALSE 92969
// sReset := true ;
92961: LD_ADDR_EXP 131
92965: PUSH
92966: LD_INT 1
92968: ST_TO_ADDR
// if p3 = 105 then
92969: LD_VAR 0 3
92973: PUSH
92974: LD_INT 105
92976: EQUAL
92977: IFFALSE 92987
// sSun := true ;
92979: LD_ADDR_EXP 132
92983: PUSH
92984: LD_INT 1
92986: ST_TO_ADDR
// if p3 = 106 then
92987: LD_VAR 0 3
92991: PUSH
92992: LD_INT 106
92994: EQUAL
92995: IFFALSE 93005
// sTiger := true ;
92997: LD_ADDR_EXP 128
93001: PUSH
93002: LD_INT 1
93004: ST_TO_ADDR
// if p3 = 107 then
93005: LD_VAR 0 3
93009: PUSH
93010: LD_INT 107
93012: EQUAL
93013: IFFALSE 93023
// sBomb := true ;
93015: LD_ADDR_EXP 129
93019: PUSH
93020: LD_INT 1
93022: ST_TO_ADDR
// if p3 = 108 then
93023: LD_VAR 0 3
93027: PUSH
93028: LD_INT 108
93030: EQUAL
93031: IFFALSE 93041
// sWound := true ;
93033: LD_ADDR_EXP 137
93037: PUSH
93038: LD_INT 1
93040: ST_TO_ADDR
// if p3 = 109 then
93041: LD_VAR 0 3
93045: PUSH
93046: LD_INT 109
93048: EQUAL
93049: IFFALSE 93059
// sBetray := true ;
93051: LD_ADDR_EXP 141
93055: PUSH
93056: LD_INT 1
93058: ST_TO_ADDR
// if p3 = 110 then
93059: LD_VAR 0 3
93063: PUSH
93064: LD_INT 110
93066: EQUAL
93067: IFFALSE 93077
// sContamin := true ;
93069: LD_ADDR_EXP 142
93073: PUSH
93074: LD_INT 1
93076: ST_TO_ADDR
// if p3 = 111 then
93077: LD_VAR 0 3
93081: PUSH
93082: LD_INT 111
93084: EQUAL
93085: IFFALSE 93095
// sOil := true ;
93087: LD_ADDR_EXP 144
93091: PUSH
93092: LD_INT 1
93094: ST_TO_ADDR
// if p3 = 112 then
93095: LD_VAR 0 3
93099: PUSH
93100: LD_INT 112
93102: EQUAL
93103: IFFALSE 93113
// sStu := true ;
93105: LD_ADDR_EXP 148
93109: PUSH
93110: LD_INT 1
93112: ST_TO_ADDR
// if p3 = 113 then
93113: LD_VAR 0 3
93117: PUSH
93118: LD_INT 113
93120: EQUAL
93121: IFFALSE 93131
// sBazooka := true ;
93123: LD_ADDR_EXP 151
93127: PUSH
93128: LD_INT 1
93130: ST_TO_ADDR
// if p3 = 114 then
93131: LD_VAR 0 3
93135: PUSH
93136: LD_INT 114
93138: EQUAL
93139: IFFALSE 93149
// sMortar := true ;
93141: LD_ADDR_EXP 152
93145: PUSH
93146: LD_INT 1
93148: ST_TO_ADDR
// if p3 = 115 then
93149: LD_VAR 0 3
93153: PUSH
93154: LD_INT 115
93156: EQUAL
93157: IFFALSE 93167
// sRanger := true ;
93159: LD_ADDR_EXP 162
93163: PUSH
93164: LD_INT 1
93166: ST_TO_ADDR
// if p3 = 116 then
93167: LD_VAR 0 3
93171: PUSH
93172: LD_INT 116
93174: EQUAL
93175: IFFALSE 93185
// sComputer := true ;
93177: LD_ADDR_EXP 163
93181: PUSH
93182: LD_INT 1
93184: ST_TO_ADDR
// if p3 = 117 then
93185: LD_VAR 0 3
93189: PUSH
93190: LD_INT 117
93192: EQUAL
93193: IFFALSE 93203
// s30 := true ;
93195: LD_ADDR_EXP 164
93199: PUSH
93200: LD_INT 1
93202: ST_TO_ADDR
// if p3 = 118 then
93203: LD_VAR 0 3
93207: PUSH
93208: LD_INT 118
93210: EQUAL
93211: IFFALSE 93221
// s60 := true ;
93213: LD_ADDR_EXP 165
93217: PUSH
93218: LD_INT 1
93220: ST_TO_ADDR
// end ; if p2 = hack_mode then
93221: LD_VAR 0 2
93225: PUSH
93226: LD_INT 101
93228: EQUAL
93229: IFFALSE 93357
// begin case p3 of 1 :
93231: LD_VAR 0 3
93235: PUSH
93236: LD_INT 1
93238: DOUBLE
93239: EQUAL
93240: IFTRUE 93244
93242: GO 93251
93244: POP
// hHackUnlimitedResources ; 2 :
93245: CALL 105620 0 0
93249: GO 93357
93251: LD_INT 2
93253: DOUBLE
93254: EQUAL
93255: IFTRUE 93259
93257: GO 93266
93259: POP
// hHackSetLevel10 ; 3 :
93260: CALL 105753 0 0
93264: GO 93357
93266: LD_INT 3
93268: DOUBLE
93269: EQUAL
93270: IFTRUE 93274
93272: GO 93281
93274: POP
// hHackSetLevel10YourUnits ; 4 :
93275: CALL 105838 0 0
93279: GO 93357
93281: LD_INT 4
93283: DOUBLE
93284: EQUAL
93285: IFTRUE 93289
93287: GO 93296
93289: POP
// hHackInvincible ; 5 :
93290: CALL 106286 0 0
93294: GO 93357
93296: LD_INT 5
93298: DOUBLE
93299: EQUAL
93300: IFTRUE 93304
93302: GO 93311
93304: POP
// hHackInvisible ; 6 :
93305: CALL 106397 0 0
93309: GO 93357
93311: LD_INT 6
93313: DOUBLE
93314: EQUAL
93315: IFTRUE 93319
93317: GO 93326
93319: POP
// hHackChangeYourSide ; 7 :
93320: CALL 106454 0 0
93324: GO 93357
93326: LD_INT 7
93328: DOUBLE
93329: EQUAL
93330: IFTRUE 93334
93332: GO 93341
93334: POP
// hHackChangeUnitSide ; 8 :
93335: CALL 106496 0 0
93339: GO 93357
93341: LD_INT 8
93343: DOUBLE
93344: EQUAL
93345: IFTRUE 93349
93347: GO 93356
93349: POP
// hHackFog ; end ;
93350: CALL 106597 0 0
93354: GO 93357
93356: POP
// end ; if p2 = game_save_mode then
93357: LD_VAR 0 2
93361: PUSH
93362: LD_INT 102
93364: EQUAL
93365: IFFALSE 93422
// begin if p3 = 1 then
93367: LD_VAR 0 3
93371: PUSH
93372: LD_INT 1
93374: EQUAL
93375: IFFALSE 93387
// globalGameSaveCounter := p4 ;
93377: LD_ADDR_EXP 108
93381: PUSH
93382: LD_VAR 0 4
93386: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93387: LD_VAR 0 3
93391: PUSH
93392: LD_INT 2
93394: EQUAL
93395: IFFALSE 93403
93397: PUSH
93398: LD_EXP 108
93402: AND
93403: IFFALSE 93422
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93405: LD_STRING setGameSaveCounter(
93407: PUSH
93408: LD_EXP 108
93412: STR
93413: PUSH
93414: LD_STRING )
93416: STR
93417: PPUSH
93418: CALL_OW 559
// end ; end ;
93422: LD_VAR 0 7
93426: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93427: LD_INT 0
93429: PPUSH
// streamModeActive := false ;
93430: LD_ADDR_EXP 109
93434: PUSH
93435: LD_INT 0
93437: ST_TO_ADDR
// normalCounter := 36 ;
93438: LD_ADDR_EXP 110
93442: PUSH
93443: LD_INT 36
93445: ST_TO_ADDR
// hardcoreCounter := 18 ;
93446: LD_ADDR_EXP 111
93450: PUSH
93451: LD_INT 18
93453: ST_TO_ADDR
// sRocket := false ;
93454: LD_ADDR_EXP 114
93458: PUSH
93459: LD_INT 0
93461: ST_TO_ADDR
// sSpeed := false ;
93462: LD_ADDR_EXP 113
93466: PUSH
93467: LD_INT 0
93469: ST_TO_ADDR
// sEngine := false ;
93470: LD_ADDR_EXP 115
93474: PUSH
93475: LD_INT 0
93477: ST_TO_ADDR
// sSpec := false ;
93478: LD_ADDR_EXP 112
93482: PUSH
93483: LD_INT 0
93485: ST_TO_ADDR
// sLevel := false ;
93486: LD_ADDR_EXP 116
93490: PUSH
93491: LD_INT 0
93493: ST_TO_ADDR
// sArmoury := false ;
93494: LD_ADDR_EXP 117
93498: PUSH
93499: LD_INT 0
93501: ST_TO_ADDR
// sRadar := false ;
93502: LD_ADDR_EXP 118
93506: PUSH
93507: LD_INT 0
93509: ST_TO_ADDR
// sBunker := false ;
93510: LD_ADDR_EXP 119
93514: PUSH
93515: LD_INT 0
93517: ST_TO_ADDR
// sHack := false ;
93518: LD_ADDR_EXP 120
93522: PUSH
93523: LD_INT 0
93525: ST_TO_ADDR
// sFire := false ;
93526: LD_ADDR_EXP 121
93530: PUSH
93531: LD_INT 0
93533: ST_TO_ADDR
// sRefresh := false ;
93534: LD_ADDR_EXP 122
93538: PUSH
93539: LD_INT 0
93541: ST_TO_ADDR
// sExp := false ;
93542: LD_ADDR_EXP 123
93546: PUSH
93547: LD_INT 0
93549: ST_TO_ADDR
// sDepot := false ;
93550: LD_ADDR_EXP 124
93554: PUSH
93555: LD_INT 0
93557: ST_TO_ADDR
// sFlag := false ;
93558: LD_ADDR_EXP 125
93562: PUSH
93563: LD_INT 0
93565: ST_TO_ADDR
// sKamikadze := false ;
93566: LD_ADDR_EXP 133
93570: PUSH
93571: LD_INT 0
93573: ST_TO_ADDR
// sTroll := false ;
93574: LD_ADDR_EXP 134
93578: PUSH
93579: LD_INT 0
93581: ST_TO_ADDR
// sSlow := false ;
93582: LD_ADDR_EXP 135
93586: PUSH
93587: LD_INT 0
93589: ST_TO_ADDR
// sLack := false ;
93590: LD_ADDR_EXP 136
93594: PUSH
93595: LD_INT 0
93597: ST_TO_ADDR
// sTank := false ;
93598: LD_ADDR_EXP 138
93602: PUSH
93603: LD_INT 0
93605: ST_TO_ADDR
// sRemote := false ;
93606: LD_ADDR_EXP 139
93610: PUSH
93611: LD_INT 0
93613: ST_TO_ADDR
// sPowell := false ;
93614: LD_ADDR_EXP 140
93618: PUSH
93619: LD_INT 0
93621: ST_TO_ADDR
// sTeleport := false ;
93622: LD_ADDR_EXP 143
93626: PUSH
93627: LD_INT 0
93629: ST_TO_ADDR
// sOilTower := false ;
93630: LD_ADDR_EXP 145
93634: PUSH
93635: LD_INT 0
93637: ST_TO_ADDR
// sShovel := false ;
93638: LD_ADDR_EXP 146
93642: PUSH
93643: LD_INT 0
93645: ST_TO_ADDR
// sSheik := false ;
93646: LD_ADDR_EXP 147
93650: PUSH
93651: LD_INT 0
93653: ST_TO_ADDR
// sEarthquake := false ;
93654: LD_ADDR_EXP 149
93658: PUSH
93659: LD_INT 0
93661: ST_TO_ADDR
// sAI := false ;
93662: LD_ADDR_EXP 150
93666: PUSH
93667: LD_INT 0
93669: ST_TO_ADDR
// sCargo := false ;
93670: LD_ADDR_EXP 153
93674: PUSH
93675: LD_INT 0
93677: ST_TO_ADDR
// sDLaser := false ;
93678: LD_ADDR_EXP 154
93682: PUSH
93683: LD_INT 0
93685: ST_TO_ADDR
// sExchange := false ;
93686: LD_ADDR_EXP 155
93690: PUSH
93691: LD_INT 0
93693: ST_TO_ADDR
// sFac := false ;
93694: LD_ADDR_EXP 156
93698: PUSH
93699: LD_INT 0
93701: ST_TO_ADDR
// sPower := false ;
93702: LD_ADDR_EXP 157
93706: PUSH
93707: LD_INT 0
93709: ST_TO_ADDR
// sRandom := false ;
93710: LD_ADDR_EXP 158
93714: PUSH
93715: LD_INT 0
93717: ST_TO_ADDR
// sShield := false ;
93718: LD_ADDR_EXP 159
93722: PUSH
93723: LD_INT 0
93725: ST_TO_ADDR
// sTime := false ;
93726: LD_ADDR_EXP 160
93730: PUSH
93731: LD_INT 0
93733: ST_TO_ADDR
// sTools := false ;
93734: LD_ADDR_EXP 161
93738: PUSH
93739: LD_INT 0
93741: ST_TO_ADDR
// sSold := false ;
93742: LD_ADDR_EXP 126
93746: PUSH
93747: LD_INT 0
93749: ST_TO_ADDR
// sDiff := false ;
93750: LD_ADDR_EXP 127
93754: PUSH
93755: LD_INT 0
93757: ST_TO_ADDR
// sFog := false ;
93758: LD_ADDR_EXP 130
93762: PUSH
93763: LD_INT 0
93765: ST_TO_ADDR
// sReset := false ;
93766: LD_ADDR_EXP 131
93770: PUSH
93771: LD_INT 0
93773: ST_TO_ADDR
// sSun := false ;
93774: LD_ADDR_EXP 132
93778: PUSH
93779: LD_INT 0
93781: ST_TO_ADDR
// sTiger := false ;
93782: LD_ADDR_EXP 128
93786: PUSH
93787: LD_INT 0
93789: ST_TO_ADDR
// sBomb := false ;
93790: LD_ADDR_EXP 129
93794: PUSH
93795: LD_INT 0
93797: ST_TO_ADDR
// sWound := false ;
93798: LD_ADDR_EXP 137
93802: PUSH
93803: LD_INT 0
93805: ST_TO_ADDR
// sBetray := false ;
93806: LD_ADDR_EXP 141
93810: PUSH
93811: LD_INT 0
93813: ST_TO_ADDR
// sContamin := false ;
93814: LD_ADDR_EXP 142
93818: PUSH
93819: LD_INT 0
93821: ST_TO_ADDR
// sOil := false ;
93822: LD_ADDR_EXP 144
93826: PUSH
93827: LD_INT 0
93829: ST_TO_ADDR
// sStu := false ;
93830: LD_ADDR_EXP 148
93834: PUSH
93835: LD_INT 0
93837: ST_TO_ADDR
// sBazooka := false ;
93838: LD_ADDR_EXP 151
93842: PUSH
93843: LD_INT 0
93845: ST_TO_ADDR
// sMortar := false ;
93846: LD_ADDR_EXP 152
93850: PUSH
93851: LD_INT 0
93853: ST_TO_ADDR
// sRanger := false ;
93854: LD_ADDR_EXP 162
93858: PUSH
93859: LD_INT 0
93861: ST_TO_ADDR
// sComputer := false ;
93862: LD_ADDR_EXP 163
93866: PUSH
93867: LD_INT 0
93869: ST_TO_ADDR
// s30 := false ;
93870: LD_ADDR_EXP 164
93874: PUSH
93875: LD_INT 0
93877: ST_TO_ADDR
// s60 := false ;
93878: LD_ADDR_EXP 165
93882: PUSH
93883: LD_INT 0
93885: ST_TO_ADDR
// end ;
93886: LD_VAR 0 1
93890: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93891: LD_INT 0
93893: PPUSH
93894: PPUSH
93895: PPUSH
93896: PPUSH
93897: PPUSH
93898: PPUSH
93899: PPUSH
// result := [ ] ;
93900: LD_ADDR_VAR 0 2
93904: PUSH
93905: EMPTY
93906: ST_TO_ADDR
// if campaign_id = 1 then
93907: LD_OWVAR 69
93911: PUSH
93912: LD_INT 1
93914: EQUAL
93915: IFFALSE 97081
// begin case mission_number of 1 :
93917: LD_OWVAR 70
93921: PUSH
93922: LD_INT 1
93924: DOUBLE
93925: EQUAL
93926: IFTRUE 93930
93928: GO 94006
93930: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93931: LD_ADDR_VAR 0 2
93935: PUSH
93936: LD_INT 2
93938: PUSH
93939: LD_INT 4
93941: PUSH
93942: LD_INT 11
93944: PUSH
93945: LD_INT 12
93947: PUSH
93948: LD_INT 15
93950: PUSH
93951: LD_INT 16
93953: PUSH
93954: LD_INT 22
93956: PUSH
93957: LD_INT 23
93959: PUSH
93960: LD_INT 26
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 101
93976: PUSH
93977: LD_INT 102
93979: PUSH
93980: LD_INT 106
93982: PUSH
93983: LD_INT 116
93985: PUSH
93986: LD_INT 117
93988: PUSH
93989: LD_INT 118
93991: PUSH
93992: EMPTY
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: ST_TO_ADDR
94004: GO 97079
94006: LD_INT 2
94008: DOUBLE
94009: EQUAL
94010: IFTRUE 94014
94012: GO 94098
94014: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
94015: LD_ADDR_VAR 0 2
94019: PUSH
94020: LD_INT 2
94022: PUSH
94023: LD_INT 4
94025: PUSH
94026: LD_INT 11
94028: PUSH
94029: LD_INT 12
94031: PUSH
94032: LD_INT 15
94034: PUSH
94035: LD_INT 16
94037: PUSH
94038: LD_INT 22
94040: PUSH
94041: LD_INT 23
94043: PUSH
94044: LD_INT 26
94046: PUSH
94047: EMPTY
94048: LIST
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: PUSH
94058: LD_INT 101
94060: PUSH
94061: LD_INT 102
94063: PUSH
94064: LD_INT 105
94066: PUSH
94067: LD_INT 106
94069: PUSH
94070: LD_INT 108
94072: PUSH
94073: LD_INT 116
94075: PUSH
94076: LD_INT 117
94078: PUSH
94079: LD_INT 118
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: ST_TO_ADDR
94096: GO 97079
94098: LD_INT 3
94100: DOUBLE
94101: EQUAL
94102: IFTRUE 94106
94104: GO 94194
94106: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94107: LD_ADDR_VAR 0 2
94111: PUSH
94112: LD_INT 2
94114: PUSH
94115: LD_INT 4
94117: PUSH
94118: LD_INT 5
94120: PUSH
94121: LD_INT 11
94123: PUSH
94124: LD_INT 12
94126: PUSH
94127: LD_INT 15
94129: PUSH
94130: LD_INT 16
94132: PUSH
94133: LD_INT 22
94135: PUSH
94136: LD_INT 26
94138: PUSH
94139: LD_INT 36
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 101
94156: PUSH
94157: LD_INT 102
94159: PUSH
94160: LD_INT 105
94162: PUSH
94163: LD_INT 106
94165: PUSH
94166: LD_INT 108
94168: PUSH
94169: LD_INT 116
94171: PUSH
94172: LD_INT 117
94174: PUSH
94175: LD_INT 118
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: ST_TO_ADDR
94192: GO 97079
94194: LD_INT 4
94196: DOUBLE
94197: EQUAL
94198: IFTRUE 94202
94200: GO 94298
94202: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94203: LD_ADDR_VAR 0 2
94207: PUSH
94208: LD_INT 2
94210: PUSH
94211: LD_INT 4
94213: PUSH
94214: LD_INT 5
94216: PUSH
94217: LD_INT 8
94219: PUSH
94220: LD_INT 11
94222: PUSH
94223: LD_INT 12
94225: PUSH
94226: LD_INT 15
94228: PUSH
94229: LD_INT 16
94231: PUSH
94232: LD_INT 22
94234: PUSH
94235: LD_INT 23
94237: PUSH
94238: LD_INT 26
94240: PUSH
94241: LD_INT 36
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 101
94260: PUSH
94261: LD_INT 102
94263: PUSH
94264: LD_INT 105
94266: PUSH
94267: LD_INT 106
94269: PUSH
94270: LD_INT 108
94272: PUSH
94273: LD_INT 116
94275: PUSH
94276: LD_INT 117
94278: PUSH
94279: LD_INT 118
94281: PUSH
94282: EMPTY
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: LIST
94289: LIST
94290: LIST
94291: PUSH
94292: EMPTY
94293: LIST
94294: LIST
94295: ST_TO_ADDR
94296: GO 97079
94298: LD_INT 5
94300: DOUBLE
94301: EQUAL
94302: IFTRUE 94306
94304: GO 94418
94306: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94307: LD_ADDR_VAR 0 2
94311: PUSH
94312: LD_INT 2
94314: PUSH
94315: LD_INT 4
94317: PUSH
94318: LD_INT 5
94320: PUSH
94321: LD_INT 6
94323: PUSH
94324: LD_INT 8
94326: PUSH
94327: LD_INT 11
94329: PUSH
94330: LD_INT 12
94332: PUSH
94333: LD_INT 15
94335: PUSH
94336: LD_INT 16
94338: PUSH
94339: LD_INT 22
94341: PUSH
94342: LD_INT 23
94344: PUSH
94345: LD_INT 25
94347: PUSH
94348: LD_INT 26
94350: PUSH
94351: LD_INT 36
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: PUSH
94370: LD_INT 101
94372: PUSH
94373: LD_INT 102
94375: PUSH
94376: LD_INT 105
94378: PUSH
94379: LD_INT 106
94381: PUSH
94382: LD_INT 108
94384: PUSH
94385: LD_INT 109
94387: PUSH
94388: LD_INT 112
94390: PUSH
94391: LD_INT 116
94393: PUSH
94394: LD_INT 117
94396: PUSH
94397: LD_INT 118
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: ST_TO_ADDR
94416: GO 97079
94418: LD_INT 6
94420: DOUBLE
94421: EQUAL
94422: IFTRUE 94426
94424: GO 94558
94426: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94427: LD_ADDR_VAR 0 2
94431: PUSH
94432: LD_INT 2
94434: PUSH
94435: LD_INT 4
94437: PUSH
94438: LD_INT 5
94440: PUSH
94441: LD_INT 6
94443: PUSH
94444: LD_INT 8
94446: PUSH
94447: LD_INT 11
94449: PUSH
94450: LD_INT 12
94452: PUSH
94453: LD_INT 15
94455: PUSH
94456: LD_INT 16
94458: PUSH
94459: LD_INT 20
94461: PUSH
94462: LD_INT 21
94464: PUSH
94465: LD_INT 22
94467: PUSH
94468: LD_INT 23
94470: PUSH
94471: LD_INT 25
94473: PUSH
94474: LD_INT 26
94476: PUSH
94477: LD_INT 30
94479: PUSH
94480: LD_INT 31
94482: PUSH
94483: LD_INT 32
94485: PUSH
94486: LD_INT 36
94488: PUSH
94489: EMPTY
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: PUSH
94510: LD_INT 101
94512: PUSH
94513: LD_INT 102
94515: PUSH
94516: LD_INT 105
94518: PUSH
94519: LD_INT 106
94521: PUSH
94522: LD_INT 108
94524: PUSH
94525: LD_INT 109
94527: PUSH
94528: LD_INT 112
94530: PUSH
94531: LD_INT 116
94533: PUSH
94534: LD_INT 117
94536: PUSH
94537: LD_INT 118
94539: PUSH
94540: EMPTY
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: LIST
94551: PUSH
94552: EMPTY
94553: LIST
94554: LIST
94555: ST_TO_ADDR
94556: GO 97079
94558: LD_INT 7
94560: DOUBLE
94561: EQUAL
94562: IFTRUE 94566
94564: GO 94678
94566: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94567: LD_ADDR_VAR 0 2
94571: PUSH
94572: LD_INT 2
94574: PUSH
94575: LD_INT 4
94577: PUSH
94578: LD_INT 5
94580: PUSH
94581: LD_INT 7
94583: PUSH
94584: LD_INT 11
94586: PUSH
94587: LD_INT 12
94589: PUSH
94590: LD_INT 15
94592: PUSH
94593: LD_INT 16
94595: PUSH
94596: LD_INT 20
94598: PUSH
94599: LD_INT 21
94601: PUSH
94602: LD_INT 22
94604: PUSH
94605: LD_INT 23
94607: PUSH
94608: LD_INT 25
94610: PUSH
94611: LD_INT 26
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 101
94632: PUSH
94633: LD_INT 102
94635: PUSH
94636: LD_INT 103
94638: PUSH
94639: LD_INT 105
94641: PUSH
94642: LD_INT 106
94644: PUSH
94645: LD_INT 108
94647: PUSH
94648: LD_INT 112
94650: PUSH
94651: LD_INT 116
94653: PUSH
94654: LD_INT 117
94656: PUSH
94657: LD_INT 118
94659: PUSH
94660: EMPTY
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: LIST
94668: LIST
94669: LIST
94670: LIST
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: ST_TO_ADDR
94676: GO 97079
94678: LD_INT 8
94680: DOUBLE
94681: EQUAL
94682: IFTRUE 94686
94684: GO 94826
94686: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94687: LD_ADDR_VAR 0 2
94691: PUSH
94692: LD_INT 2
94694: PUSH
94695: LD_INT 4
94697: PUSH
94698: LD_INT 5
94700: PUSH
94701: LD_INT 6
94703: PUSH
94704: LD_INT 7
94706: PUSH
94707: LD_INT 8
94709: PUSH
94710: LD_INT 11
94712: PUSH
94713: LD_INT 12
94715: PUSH
94716: LD_INT 15
94718: PUSH
94719: LD_INT 16
94721: PUSH
94722: LD_INT 20
94724: PUSH
94725: LD_INT 21
94727: PUSH
94728: LD_INT 22
94730: PUSH
94731: LD_INT 23
94733: PUSH
94734: LD_INT 25
94736: PUSH
94737: LD_INT 26
94739: PUSH
94740: LD_INT 30
94742: PUSH
94743: LD_INT 31
94745: PUSH
94746: LD_INT 32
94748: PUSH
94749: LD_INT 36
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 101
94776: PUSH
94777: LD_INT 102
94779: PUSH
94780: LD_INT 103
94782: PUSH
94783: LD_INT 105
94785: PUSH
94786: LD_INT 106
94788: PUSH
94789: LD_INT 108
94791: PUSH
94792: LD_INT 109
94794: PUSH
94795: LD_INT 112
94797: PUSH
94798: LD_INT 116
94800: PUSH
94801: LD_INT 117
94803: PUSH
94804: LD_INT 118
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: PUSH
94820: EMPTY
94821: LIST
94822: LIST
94823: ST_TO_ADDR
94824: GO 97079
94826: LD_INT 9
94828: DOUBLE
94829: EQUAL
94830: IFTRUE 94834
94832: GO 94982
94834: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94835: LD_ADDR_VAR 0 2
94839: PUSH
94840: LD_INT 2
94842: PUSH
94843: LD_INT 4
94845: PUSH
94846: LD_INT 5
94848: PUSH
94849: LD_INT 6
94851: PUSH
94852: LD_INT 7
94854: PUSH
94855: LD_INT 8
94857: PUSH
94858: LD_INT 11
94860: PUSH
94861: LD_INT 12
94863: PUSH
94864: LD_INT 15
94866: PUSH
94867: LD_INT 16
94869: PUSH
94870: LD_INT 20
94872: PUSH
94873: LD_INT 21
94875: PUSH
94876: LD_INT 22
94878: PUSH
94879: LD_INT 23
94881: PUSH
94882: LD_INT 25
94884: PUSH
94885: LD_INT 26
94887: PUSH
94888: LD_INT 28
94890: PUSH
94891: LD_INT 30
94893: PUSH
94894: LD_INT 31
94896: PUSH
94897: LD_INT 32
94899: PUSH
94900: LD_INT 36
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: LIST
94911: LIST
94912: LIST
94913: LIST
94914: LIST
94915: LIST
94916: LIST
94917: LIST
94918: LIST
94919: LIST
94920: LIST
94921: LIST
94922: LIST
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 101
94928: PUSH
94929: LD_INT 102
94931: PUSH
94932: LD_INT 103
94934: PUSH
94935: LD_INT 105
94937: PUSH
94938: LD_INT 106
94940: PUSH
94941: LD_INT 108
94943: PUSH
94944: LD_INT 109
94946: PUSH
94947: LD_INT 112
94949: PUSH
94950: LD_INT 114
94952: PUSH
94953: LD_INT 116
94955: PUSH
94956: LD_INT 117
94958: PUSH
94959: LD_INT 118
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: LIST
94971: LIST
94972: LIST
94973: LIST
94974: LIST
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: ST_TO_ADDR
94980: GO 97079
94982: LD_INT 10
94984: DOUBLE
94985: EQUAL
94986: IFTRUE 94990
94988: GO 95186
94990: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94991: LD_ADDR_VAR 0 2
94995: PUSH
94996: LD_INT 2
94998: PUSH
94999: LD_INT 4
95001: PUSH
95002: LD_INT 5
95004: PUSH
95005: LD_INT 6
95007: PUSH
95008: LD_INT 7
95010: PUSH
95011: LD_INT 8
95013: PUSH
95014: LD_INT 9
95016: PUSH
95017: LD_INT 10
95019: PUSH
95020: LD_INT 11
95022: PUSH
95023: LD_INT 12
95025: PUSH
95026: LD_INT 13
95028: PUSH
95029: LD_INT 14
95031: PUSH
95032: LD_INT 15
95034: PUSH
95035: LD_INT 16
95037: PUSH
95038: LD_INT 17
95040: PUSH
95041: LD_INT 18
95043: PUSH
95044: LD_INT 19
95046: PUSH
95047: LD_INT 20
95049: PUSH
95050: LD_INT 21
95052: PUSH
95053: LD_INT 22
95055: PUSH
95056: LD_INT 23
95058: PUSH
95059: LD_INT 24
95061: PUSH
95062: LD_INT 25
95064: PUSH
95065: LD_INT 26
95067: PUSH
95068: LD_INT 28
95070: PUSH
95071: LD_INT 30
95073: PUSH
95074: LD_INT 31
95076: PUSH
95077: LD_INT 32
95079: PUSH
95080: LD_INT 36
95082: PUSH
95083: EMPTY
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 101
95116: PUSH
95117: LD_INT 102
95119: PUSH
95120: LD_INT 103
95122: PUSH
95123: LD_INT 104
95125: PUSH
95126: LD_INT 105
95128: PUSH
95129: LD_INT 106
95131: PUSH
95132: LD_INT 107
95134: PUSH
95135: LD_INT 108
95137: PUSH
95138: LD_INT 109
95140: PUSH
95141: LD_INT 110
95143: PUSH
95144: LD_INT 111
95146: PUSH
95147: LD_INT 112
95149: PUSH
95150: LD_INT 114
95152: PUSH
95153: LD_INT 116
95155: PUSH
95156: LD_INT 117
95158: PUSH
95159: LD_INT 118
95161: PUSH
95162: EMPTY
95163: LIST
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: ST_TO_ADDR
95184: GO 97079
95186: LD_INT 11
95188: DOUBLE
95189: EQUAL
95190: IFTRUE 95194
95192: GO 95398
95194: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95195: LD_ADDR_VAR 0 2
95199: PUSH
95200: LD_INT 2
95202: PUSH
95203: LD_INT 3
95205: PUSH
95206: LD_INT 4
95208: PUSH
95209: LD_INT 5
95211: PUSH
95212: LD_INT 6
95214: PUSH
95215: LD_INT 7
95217: PUSH
95218: LD_INT 8
95220: PUSH
95221: LD_INT 9
95223: PUSH
95224: LD_INT 10
95226: PUSH
95227: LD_INT 11
95229: PUSH
95230: LD_INT 12
95232: PUSH
95233: LD_INT 13
95235: PUSH
95236: LD_INT 14
95238: PUSH
95239: LD_INT 15
95241: PUSH
95242: LD_INT 16
95244: PUSH
95245: LD_INT 17
95247: PUSH
95248: LD_INT 18
95250: PUSH
95251: LD_INT 19
95253: PUSH
95254: LD_INT 20
95256: PUSH
95257: LD_INT 21
95259: PUSH
95260: LD_INT 22
95262: PUSH
95263: LD_INT 23
95265: PUSH
95266: LD_INT 24
95268: PUSH
95269: LD_INT 25
95271: PUSH
95272: LD_INT 26
95274: PUSH
95275: LD_INT 28
95277: PUSH
95278: LD_INT 30
95280: PUSH
95281: LD_INT 31
95283: PUSH
95284: LD_INT 32
95286: PUSH
95287: LD_INT 34
95289: PUSH
95290: LD_INT 36
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 101
95328: PUSH
95329: LD_INT 102
95331: PUSH
95332: LD_INT 103
95334: PUSH
95335: LD_INT 104
95337: PUSH
95338: LD_INT 105
95340: PUSH
95341: LD_INT 106
95343: PUSH
95344: LD_INT 107
95346: PUSH
95347: LD_INT 108
95349: PUSH
95350: LD_INT 109
95352: PUSH
95353: LD_INT 110
95355: PUSH
95356: LD_INT 111
95358: PUSH
95359: LD_INT 112
95361: PUSH
95362: LD_INT 114
95364: PUSH
95365: LD_INT 116
95367: PUSH
95368: LD_INT 117
95370: PUSH
95371: LD_INT 118
95373: PUSH
95374: EMPTY
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: ST_TO_ADDR
95396: GO 97079
95398: LD_INT 12
95400: DOUBLE
95401: EQUAL
95402: IFTRUE 95406
95404: GO 95626
95406: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95407: LD_ADDR_VAR 0 2
95411: PUSH
95412: LD_INT 1
95414: PUSH
95415: LD_INT 2
95417: PUSH
95418: LD_INT 3
95420: PUSH
95421: LD_INT 4
95423: PUSH
95424: LD_INT 5
95426: PUSH
95427: LD_INT 6
95429: PUSH
95430: LD_INT 7
95432: PUSH
95433: LD_INT 8
95435: PUSH
95436: LD_INT 9
95438: PUSH
95439: LD_INT 10
95441: PUSH
95442: LD_INT 11
95444: PUSH
95445: LD_INT 12
95447: PUSH
95448: LD_INT 13
95450: PUSH
95451: LD_INT 14
95453: PUSH
95454: LD_INT 15
95456: PUSH
95457: LD_INT 16
95459: PUSH
95460: LD_INT 17
95462: PUSH
95463: LD_INT 18
95465: PUSH
95466: LD_INT 19
95468: PUSH
95469: LD_INT 20
95471: PUSH
95472: LD_INT 21
95474: PUSH
95475: LD_INT 22
95477: PUSH
95478: LD_INT 23
95480: PUSH
95481: LD_INT 24
95483: PUSH
95484: LD_INT 25
95486: PUSH
95487: LD_INT 26
95489: PUSH
95490: LD_INT 27
95492: PUSH
95493: LD_INT 28
95495: PUSH
95496: LD_INT 30
95498: PUSH
95499: LD_INT 31
95501: PUSH
95502: LD_INT 32
95504: PUSH
95505: LD_INT 33
95507: PUSH
95508: LD_INT 34
95510: PUSH
95511: LD_INT 36
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: PUSH
95550: LD_INT 101
95552: PUSH
95553: LD_INT 102
95555: PUSH
95556: LD_INT 103
95558: PUSH
95559: LD_INT 104
95561: PUSH
95562: LD_INT 105
95564: PUSH
95565: LD_INT 106
95567: PUSH
95568: LD_INT 107
95570: PUSH
95571: LD_INT 108
95573: PUSH
95574: LD_INT 109
95576: PUSH
95577: LD_INT 110
95579: PUSH
95580: LD_INT 111
95582: PUSH
95583: LD_INT 112
95585: PUSH
95586: LD_INT 113
95588: PUSH
95589: LD_INT 114
95591: PUSH
95592: LD_INT 116
95594: PUSH
95595: LD_INT 117
95597: PUSH
95598: LD_INT 118
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: ST_TO_ADDR
95624: GO 97079
95626: LD_INT 13
95628: DOUBLE
95629: EQUAL
95630: IFTRUE 95634
95632: GO 95842
95634: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95635: LD_ADDR_VAR 0 2
95639: PUSH
95640: LD_INT 1
95642: PUSH
95643: LD_INT 2
95645: PUSH
95646: LD_INT 3
95648: PUSH
95649: LD_INT 4
95651: PUSH
95652: LD_INT 5
95654: PUSH
95655: LD_INT 8
95657: PUSH
95658: LD_INT 9
95660: PUSH
95661: LD_INT 10
95663: PUSH
95664: LD_INT 11
95666: PUSH
95667: LD_INT 12
95669: PUSH
95670: LD_INT 14
95672: PUSH
95673: LD_INT 15
95675: PUSH
95676: LD_INT 16
95678: PUSH
95679: LD_INT 17
95681: PUSH
95682: LD_INT 18
95684: PUSH
95685: LD_INT 19
95687: PUSH
95688: LD_INT 20
95690: PUSH
95691: LD_INT 21
95693: PUSH
95694: LD_INT 22
95696: PUSH
95697: LD_INT 23
95699: PUSH
95700: LD_INT 24
95702: PUSH
95703: LD_INT 25
95705: PUSH
95706: LD_INT 26
95708: PUSH
95709: LD_INT 27
95711: PUSH
95712: LD_INT 28
95714: PUSH
95715: LD_INT 30
95717: PUSH
95718: LD_INT 31
95720: PUSH
95721: LD_INT 32
95723: PUSH
95724: LD_INT 33
95726: PUSH
95727: LD_INT 34
95729: PUSH
95730: LD_INT 36
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: PUSH
95766: LD_INT 101
95768: PUSH
95769: LD_INT 102
95771: PUSH
95772: LD_INT 103
95774: PUSH
95775: LD_INT 104
95777: PUSH
95778: LD_INT 105
95780: PUSH
95781: LD_INT 106
95783: PUSH
95784: LD_INT 107
95786: PUSH
95787: LD_INT 108
95789: PUSH
95790: LD_INT 109
95792: PUSH
95793: LD_INT 110
95795: PUSH
95796: LD_INT 111
95798: PUSH
95799: LD_INT 112
95801: PUSH
95802: LD_INT 113
95804: PUSH
95805: LD_INT 114
95807: PUSH
95808: LD_INT 116
95810: PUSH
95811: LD_INT 117
95813: PUSH
95814: LD_INT 118
95816: PUSH
95817: EMPTY
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: LIST
95830: LIST
95831: LIST
95832: LIST
95833: LIST
95834: LIST
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: ST_TO_ADDR
95840: GO 97079
95842: LD_INT 14
95844: DOUBLE
95845: EQUAL
95846: IFTRUE 95850
95848: GO 96074
95850: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95851: LD_ADDR_VAR 0 2
95855: PUSH
95856: LD_INT 1
95858: PUSH
95859: LD_INT 2
95861: PUSH
95862: LD_INT 3
95864: PUSH
95865: LD_INT 4
95867: PUSH
95868: LD_INT 5
95870: PUSH
95871: LD_INT 6
95873: PUSH
95874: LD_INT 7
95876: PUSH
95877: LD_INT 8
95879: PUSH
95880: LD_INT 9
95882: PUSH
95883: LD_INT 10
95885: PUSH
95886: LD_INT 11
95888: PUSH
95889: LD_INT 12
95891: PUSH
95892: LD_INT 13
95894: PUSH
95895: LD_INT 14
95897: PUSH
95898: LD_INT 15
95900: PUSH
95901: LD_INT 16
95903: PUSH
95904: LD_INT 17
95906: PUSH
95907: LD_INT 18
95909: PUSH
95910: LD_INT 19
95912: PUSH
95913: LD_INT 20
95915: PUSH
95916: LD_INT 21
95918: PUSH
95919: LD_INT 22
95921: PUSH
95922: LD_INT 23
95924: PUSH
95925: LD_INT 24
95927: PUSH
95928: LD_INT 25
95930: PUSH
95931: LD_INT 26
95933: PUSH
95934: LD_INT 27
95936: PUSH
95937: LD_INT 28
95939: PUSH
95940: LD_INT 29
95942: PUSH
95943: LD_INT 30
95945: PUSH
95946: LD_INT 31
95948: PUSH
95949: LD_INT 32
95951: PUSH
95952: LD_INT 33
95954: PUSH
95955: LD_INT 34
95957: PUSH
95958: LD_INT 36
95960: PUSH
95961: EMPTY
95962: LIST
95963: LIST
95964: LIST
95965: LIST
95966: LIST
95967: LIST
95968: LIST
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 101
96000: PUSH
96001: LD_INT 102
96003: PUSH
96004: LD_INT 103
96006: PUSH
96007: LD_INT 104
96009: PUSH
96010: LD_INT 105
96012: PUSH
96013: LD_INT 106
96015: PUSH
96016: LD_INT 107
96018: PUSH
96019: LD_INT 108
96021: PUSH
96022: LD_INT 109
96024: PUSH
96025: LD_INT 110
96027: PUSH
96028: LD_INT 111
96030: PUSH
96031: LD_INT 112
96033: PUSH
96034: LD_INT 113
96036: PUSH
96037: LD_INT 114
96039: PUSH
96040: LD_INT 116
96042: PUSH
96043: LD_INT 117
96045: PUSH
96046: LD_INT 118
96048: PUSH
96049: EMPTY
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: PUSH
96068: EMPTY
96069: LIST
96070: LIST
96071: ST_TO_ADDR
96072: GO 97079
96074: LD_INT 15
96076: DOUBLE
96077: EQUAL
96078: IFTRUE 96082
96080: GO 96306
96082: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96083: LD_ADDR_VAR 0 2
96087: PUSH
96088: LD_INT 1
96090: PUSH
96091: LD_INT 2
96093: PUSH
96094: LD_INT 3
96096: PUSH
96097: LD_INT 4
96099: PUSH
96100: LD_INT 5
96102: PUSH
96103: LD_INT 6
96105: PUSH
96106: LD_INT 7
96108: PUSH
96109: LD_INT 8
96111: PUSH
96112: LD_INT 9
96114: PUSH
96115: LD_INT 10
96117: PUSH
96118: LD_INT 11
96120: PUSH
96121: LD_INT 12
96123: PUSH
96124: LD_INT 13
96126: PUSH
96127: LD_INT 14
96129: PUSH
96130: LD_INT 15
96132: PUSH
96133: LD_INT 16
96135: PUSH
96136: LD_INT 17
96138: PUSH
96139: LD_INT 18
96141: PUSH
96142: LD_INT 19
96144: PUSH
96145: LD_INT 20
96147: PUSH
96148: LD_INT 21
96150: PUSH
96151: LD_INT 22
96153: PUSH
96154: LD_INT 23
96156: PUSH
96157: LD_INT 24
96159: PUSH
96160: LD_INT 25
96162: PUSH
96163: LD_INT 26
96165: PUSH
96166: LD_INT 27
96168: PUSH
96169: LD_INT 28
96171: PUSH
96172: LD_INT 29
96174: PUSH
96175: LD_INT 30
96177: PUSH
96178: LD_INT 31
96180: PUSH
96181: LD_INT 32
96183: PUSH
96184: LD_INT 33
96186: PUSH
96187: LD_INT 34
96189: PUSH
96190: LD_INT 36
96192: PUSH
96193: EMPTY
96194: LIST
96195: LIST
96196: LIST
96197: LIST
96198: LIST
96199: LIST
96200: LIST
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: PUSH
96230: LD_INT 101
96232: PUSH
96233: LD_INT 102
96235: PUSH
96236: LD_INT 103
96238: PUSH
96239: LD_INT 104
96241: PUSH
96242: LD_INT 105
96244: PUSH
96245: LD_INT 106
96247: PUSH
96248: LD_INT 107
96250: PUSH
96251: LD_INT 108
96253: PUSH
96254: LD_INT 109
96256: PUSH
96257: LD_INT 110
96259: PUSH
96260: LD_INT 111
96262: PUSH
96263: LD_INT 112
96265: PUSH
96266: LD_INT 113
96268: PUSH
96269: LD_INT 114
96271: PUSH
96272: LD_INT 116
96274: PUSH
96275: LD_INT 117
96277: PUSH
96278: LD_INT 118
96280: PUSH
96281: EMPTY
96282: LIST
96283: LIST
96284: LIST
96285: LIST
96286: LIST
96287: LIST
96288: LIST
96289: LIST
96290: LIST
96291: LIST
96292: LIST
96293: LIST
96294: LIST
96295: LIST
96296: LIST
96297: LIST
96298: LIST
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: ST_TO_ADDR
96304: GO 97079
96306: LD_INT 16
96308: DOUBLE
96309: EQUAL
96310: IFTRUE 96314
96312: GO 96450
96314: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96315: LD_ADDR_VAR 0 2
96319: PUSH
96320: LD_INT 2
96322: PUSH
96323: LD_INT 4
96325: PUSH
96326: LD_INT 5
96328: PUSH
96329: LD_INT 7
96331: PUSH
96332: LD_INT 11
96334: PUSH
96335: LD_INT 12
96337: PUSH
96338: LD_INT 15
96340: PUSH
96341: LD_INT 16
96343: PUSH
96344: LD_INT 20
96346: PUSH
96347: LD_INT 21
96349: PUSH
96350: LD_INT 22
96352: PUSH
96353: LD_INT 23
96355: PUSH
96356: LD_INT 25
96358: PUSH
96359: LD_INT 26
96361: PUSH
96362: LD_INT 30
96364: PUSH
96365: LD_INT 31
96367: PUSH
96368: LD_INT 32
96370: PUSH
96371: LD_INT 33
96373: PUSH
96374: LD_INT 34
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: LIST
96381: LIST
96382: LIST
96383: LIST
96384: LIST
96385: LIST
96386: LIST
96387: LIST
96388: LIST
96389: LIST
96390: LIST
96391: LIST
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: PUSH
96398: LD_INT 101
96400: PUSH
96401: LD_INT 102
96403: PUSH
96404: LD_INT 103
96406: PUSH
96407: LD_INT 106
96409: PUSH
96410: LD_INT 108
96412: PUSH
96413: LD_INT 112
96415: PUSH
96416: LD_INT 113
96418: PUSH
96419: LD_INT 114
96421: PUSH
96422: LD_INT 116
96424: PUSH
96425: LD_INT 117
96427: PUSH
96428: LD_INT 118
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: LIST
96438: LIST
96439: LIST
96440: LIST
96441: LIST
96442: LIST
96443: PUSH
96444: EMPTY
96445: LIST
96446: LIST
96447: ST_TO_ADDR
96448: GO 97079
96450: LD_INT 17
96452: DOUBLE
96453: EQUAL
96454: IFTRUE 96458
96456: GO 96682
96458: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96459: LD_ADDR_VAR 0 2
96463: PUSH
96464: LD_INT 1
96466: PUSH
96467: LD_INT 2
96469: PUSH
96470: LD_INT 3
96472: PUSH
96473: LD_INT 4
96475: PUSH
96476: LD_INT 5
96478: PUSH
96479: LD_INT 6
96481: PUSH
96482: LD_INT 7
96484: PUSH
96485: LD_INT 8
96487: PUSH
96488: LD_INT 9
96490: PUSH
96491: LD_INT 10
96493: PUSH
96494: LD_INT 11
96496: PUSH
96497: LD_INT 12
96499: PUSH
96500: LD_INT 13
96502: PUSH
96503: LD_INT 14
96505: PUSH
96506: LD_INT 15
96508: PUSH
96509: LD_INT 16
96511: PUSH
96512: LD_INT 17
96514: PUSH
96515: LD_INT 18
96517: PUSH
96518: LD_INT 19
96520: PUSH
96521: LD_INT 20
96523: PUSH
96524: LD_INT 21
96526: PUSH
96527: LD_INT 22
96529: PUSH
96530: LD_INT 23
96532: PUSH
96533: LD_INT 24
96535: PUSH
96536: LD_INT 25
96538: PUSH
96539: LD_INT 26
96541: PUSH
96542: LD_INT 27
96544: PUSH
96545: LD_INT 28
96547: PUSH
96548: LD_INT 29
96550: PUSH
96551: LD_INT 30
96553: PUSH
96554: LD_INT 31
96556: PUSH
96557: LD_INT 32
96559: PUSH
96560: LD_INT 33
96562: PUSH
96563: LD_INT 34
96565: PUSH
96566: LD_INT 36
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: PUSH
96606: LD_INT 101
96608: PUSH
96609: LD_INT 102
96611: PUSH
96612: LD_INT 103
96614: PUSH
96615: LD_INT 104
96617: PUSH
96618: LD_INT 105
96620: PUSH
96621: LD_INT 106
96623: PUSH
96624: LD_INT 107
96626: PUSH
96627: LD_INT 108
96629: PUSH
96630: LD_INT 109
96632: PUSH
96633: LD_INT 110
96635: PUSH
96636: LD_INT 111
96638: PUSH
96639: LD_INT 112
96641: PUSH
96642: LD_INT 113
96644: PUSH
96645: LD_INT 114
96647: PUSH
96648: LD_INT 116
96650: PUSH
96651: LD_INT 117
96653: PUSH
96654: LD_INT 118
96656: PUSH
96657: EMPTY
96658: LIST
96659: LIST
96660: LIST
96661: LIST
96662: LIST
96663: LIST
96664: LIST
96665: LIST
96666: LIST
96667: LIST
96668: LIST
96669: LIST
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: LIST
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: ST_TO_ADDR
96680: GO 97079
96682: LD_INT 18
96684: DOUBLE
96685: EQUAL
96686: IFTRUE 96690
96688: GO 96838
96690: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96691: LD_ADDR_VAR 0 2
96695: PUSH
96696: LD_INT 2
96698: PUSH
96699: LD_INT 4
96701: PUSH
96702: LD_INT 5
96704: PUSH
96705: LD_INT 7
96707: PUSH
96708: LD_INT 11
96710: PUSH
96711: LD_INT 12
96713: PUSH
96714: LD_INT 15
96716: PUSH
96717: LD_INT 16
96719: PUSH
96720: LD_INT 20
96722: PUSH
96723: LD_INT 21
96725: PUSH
96726: LD_INT 22
96728: PUSH
96729: LD_INT 23
96731: PUSH
96732: LD_INT 25
96734: PUSH
96735: LD_INT 26
96737: PUSH
96738: LD_INT 30
96740: PUSH
96741: LD_INT 31
96743: PUSH
96744: LD_INT 32
96746: PUSH
96747: LD_INT 33
96749: PUSH
96750: LD_INT 34
96752: PUSH
96753: LD_INT 35
96755: PUSH
96756: LD_INT 36
96758: PUSH
96759: EMPTY
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: LIST
96767: LIST
96768: LIST
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: LIST
96774: LIST
96775: LIST
96776: LIST
96777: LIST
96778: LIST
96779: LIST
96780: LIST
96781: PUSH
96782: LD_INT 101
96784: PUSH
96785: LD_INT 102
96787: PUSH
96788: LD_INT 103
96790: PUSH
96791: LD_INT 106
96793: PUSH
96794: LD_INT 108
96796: PUSH
96797: LD_INT 112
96799: PUSH
96800: LD_INT 113
96802: PUSH
96803: LD_INT 114
96805: PUSH
96806: LD_INT 115
96808: PUSH
96809: LD_INT 116
96811: PUSH
96812: LD_INT 117
96814: PUSH
96815: LD_INT 118
96817: PUSH
96818: EMPTY
96819: LIST
96820: LIST
96821: LIST
96822: LIST
96823: LIST
96824: LIST
96825: LIST
96826: LIST
96827: LIST
96828: LIST
96829: LIST
96830: LIST
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: ST_TO_ADDR
96836: GO 97079
96838: LD_INT 19
96840: DOUBLE
96841: EQUAL
96842: IFTRUE 96846
96844: GO 97078
96846: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96847: LD_ADDR_VAR 0 2
96851: PUSH
96852: LD_INT 1
96854: PUSH
96855: LD_INT 2
96857: PUSH
96858: LD_INT 3
96860: PUSH
96861: LD_INT 4
96863: PUSH
96864: LD_INT 5
96866: PUSH
96867: LD_INT 6
96869: PUSH
96870: LD_INT 7
96872: PUSH
96873: LD_INT 8
96875: PUSH
96876: LD_INT 9
96878: PUSH
96879: LD_INT 10
96881: PUSH
96882: LD_INT 11
96884: PUSH
96885: LD_INT 12
96887: PUSH
96888: LD_INT 13
96890: PUSH
96891: LD_INT 14
96893: PUSH
96894: LD_INT 15
96896: PUSH
96897: LD_INT 16
96899: PUSH
96900: LD_INT 17
96902: PUSH
96903: LD_INT 18
96905: PUSH
96906: LD_INT 19
96908: PUSH
96909: LD_INT 20
96911: PUSH
96912: LD_INT 21
96914: PUSH
96915: LD_INT 22
96917: PUSH
96918: LD_INT 23
96920: PUSH
96921: LD_INT 24
96923: PUSH
96924: LD_INT 25
96926: PUSH
96927: LD_INT 26
96929: PUSH
96930: LD_INT 27
96932: PUSH
96933: LD_INT 28
96935: PUSH
96936: LD_INT 29
96938: PUSH
96939: LD_INT 30
96941: PUSH
96942: LD_INT 31
96944: PUSH
96945: LD_INT 32
96947: PUSH
96948: LD_INT 33
96950: PUSH
96951: LD_INT 34
96953: PUSH
96954: LD_INT 35
96956: PUSH
96957: LD_INT 36
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: PUSH
96998: LD_INT 101
97000: PUSH
97001: LD_INT 102
97003: PUSH
97004: LD_INT 103
97006: PUSH
97007: LD_INT 104
97009: PUSH
97010: LD_INT 105
97012: PUSH
97013: LD_INT 106
97015: PUSH
97016: LD_INT 107
97018: PUSH
97019: LD_INT 108
97021: PUSH
97022: LD_INT 109
97024: PUSH
97025: LD_INT 110
97027: PUSH
97028: LD_INT 111
97030: PUSH
97031: LD_INT 112
97033: PUSH
97034: LD_INT 113
97036: PUSH
97037: LD_INT 114
97039: PUSH
97040: LD_INT 115
97042: PUSH
97043: LD_INT 116
97045: PUSH
97046: LD_INT 117
97048: PUSH
97049: LD_INT 118
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: LIST
97056: LIST
97057: LIST
97058: LIST
97059: LIST
97060: LIST
97061: LIST
97062: LIST
97063: LIST
97064: LIST
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: PUSH
97072: EMPTY
97073: LIST
97074: LIST
97075: ST_TO_ADDR
97076: GO 97079
97078: POP
// end else
97079: GO 97310
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97081: LD_ADDR_VAR 0 2
97085: PUSH
97086: LD_INT 1
97088: PUSH
97089: LD_INT 2
97091: PUSH
97092: LD_INT 3
97094: PUSH
97095: LD_INT 4
97097: PUSH
97098: LD_INT 5
97100: PUSH
97101: LD_INT 6
97103: PUSH
97104: LD_INT 7
97106: PUSH
97107: LD_INT 8
97109: PUSH
97110: LD_INT 9
97112: PUSH
97113: LD_INT 10
97115: PUSH
97116: LD_INT 11
97118: PUSH
97119: LD_INT 12
97121: PUSH
97122: LD_INT 13
97124: PUSH
97125: LD_INT 14
97127: PUSH
97128: LD_INT 15
97130: PUSH
97131: LD_INT 16
97133: PUSH
97134: LD_INT 17
97136: PUSH
97137: LD_INT 18
97139: PUSH
97140: LD_INT 19
97142: PUSH
97143: LD_INT 20
97145: PUSH
97146: LD_INT 21
97148: PUSH
97149: LD_INT 22
97151: PUSH
97152: LD_INT 23
97154: PUSH
97155: LD_INT 24
97157: PUSH
97158: LD_INT 25
97160: PUSH
97161: LD_INT 26
97163: PUSH
97164: LD_INT 27
97166: PUSH
97167: LD_INT 28
97169: PUSH
97170: LD_INT 29
97172: PUSH
97173: LD_INT 30
97175: PUSH
97176: LD_INT 31
97178: PUSH
97179: LD_INT 32
97181: PUSH
97182: LD_INT 33
97184: PUSH
97185: LD_INT 34
97187: PUSH
97188: LD_INT 35
97190: PUSH
97191: LD_INT 36
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: LIST
97198: LIST
97199: LIST
97200: LIST
97201: LIST
97202: LIST
97203: LIST
97204: LIST
97205: LIST
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: PUSH
97232: LD_INT 101
97234: PUSH
97235: LD_INT 102
97237: PUSH
97238: LD_INT 103
97240: PUSH
97241: LD_INT 104
97243: PUSH
97244: LD_INT 105
97246: PUSH
97247: LD_INT 106
97249: PUSH
97250: LD_INT 107
97252: PUSH
97253: LD_INT 108
97255: PUSH
97256: LD_INT 109
97258: PUSH
97259: LD_INT 110
97261: PUSH
97262: LD_INT 111
97264: PUSH
97265: LD_INT 112
97267: PUSH
97268: LD_INT 113
97270: PUSH
97271: LD_INT 114
97273: PUSH
97274: LD_INT 115
97276: PUSH
97277: LD_INT 116
97279: PUSH
97280: LD_INT 117
97282: PUSH
97283: LD_INT 118
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: LIST
97293: LIST
97294: LIST
97295: LIST
97296: LIST
97297: LIST
97298: LIST
97299: LIST
97300: LIST
97301: LIST
97302: LIST
97303: LIST
97304: LIST
97305: PUSH
97306: EMPTY
97307: LIST
97308: LIST
97309: ST_TO_ADDR
// if result then
97310: LD_VAR 0 2
97314: IFFALSE 98100
// begin normal :=  ;
97316: LD_ADDR_VAR 0 5
97320: PUSH
97321: LD_STRING 
97323: ST_TO_ADDR
// hardcore :=  ;
97324: LD_ADDR_VAR 0 6
97328: PUSH
97329: LD_STRING 
97331: ST_TO_ADDR
// active :=  ;
97332: LD_ADDR_VAR 0 7
97336: PUSH
97337: LD_STRING 
97339: ST_TO_ADDR
// for i = 1 to normalCounter do
97340: LD_ADDR_VAR 0 8
97344: PUSH
97345: DOUBLE
97346: LD_INT 1
97348: DEC
97349: ST_TO_ADDR
97350: LD_EXP 110
97354: PUSH
97355: FOR_TO
97356: IFFALSE 97457
// begin tmp := 0 ;
97358: LD_ADDR_VAR 0 3
97362: PUSH
97363: LD_STRING 0
97365: ST_TO_ADDR
// if result [ 1 ] then
97366: LD_VAR 0 2
97370: PUSH
97371: LD_INT 1
97373: ARRAY
97374: IFFALSE 97439
// if result [ 1 ] [ 1 ] = i then
97376: LD_VAR 0 2
97380: PUSH
97381: LD_INT 1
97383: ARRAY
97384: PUSH
97385: LD_INT 1
97387: ARRAY
97388: PUSH
97389: LD_VAR 0 8
97393: EQUAL
97394: IFFALSE 97439
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97396: LD_ADDR_VAR 0 2
97400: PUSH
97401: LD_VAR 0 2
97405: PPUSH
97406: LD_INT 1
97408: PPUSH
97409: LD_VAR 0 2
97413: PUSH
97414: LD_INT 1
97416: ARRAY
97417: PPUSH
97418: LD_INT 1
97420: PPUSH
97421: CALL_OW 3
97425: PPUSH
97426: CALL_OW 1
97430: ST_TO_ADDR
// tmp := 1 ;
97431: LD_ADDR_VAR 0 3
97435: PUSH
97436: LD_STRING 1
97438: ST_TO_ADDR
// end ; normal := normal & tmp ;
97439: LD_ADDR_VAR 0 5
97443: PUSH
97444: LD_VAR 0 5
97448: PUSH
97449: LD_VAR 0 3
97453: STR
97454: ST_TO_ADDR
// end ;
97455: GO 97355
97457: POP
97458: POP
// for i = 1 to hardcoreCounter do
97459: LD_ADDR_VAR 0 8
97463: PUSH
97464: DOUBLE
97465: LD_INT 1
97467: DEC
97468: ST_TO_ADDR
97469: LD_EXP 111
97473: PUSH
97474: FOR_TO
97475: IFFALSE 97580
// begin tmp := 0 ;
97477: LD_ADDR_VAR 0 3
97481: PUSH
97482: LD_STRING 0
97484: ST_TO_ADDR
// if result [ 2 ] then
97485: LD_VAR 0 2
97489: PUSH
97490: LD_INT 2
97492: ARRAY
97493: IFFALSE 97562
// if result [ 2 ] [ 1 ] = 100 + i then
97495: LD_VAR 0 2
97499: PUSH
97500: LD_INT 2
97502: ARRAY
97503: PUSH
97504: LD_INT 1
97506: ARRAY
97507: PUSH
97508: LD_INT 100
97510: PUSH
97511: LD_VAR 0 8
97515: PLUS
97516: EQUAL
97517: IFFALSE 97562
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97519: LD_ADDR_VAR 0 2
97523: PUSH
97524: LD_VAR 0 2
97528: PPUSH
97529: LD_INT 2
97531: PPUSH
97532: LD_VAR 0 2
97536: PUSH
97537: LD_INT 2
97539: ARRAY
97540: PPUSH
97541: LD_INT 1
97543: PPUSH
97544: CALL_OW 3
97548: PPUSH
97549: CALL_OW 1
97553: ST_TO_ADDR
// tmp := 1 ;
97554: LD_ADDR_VAR 0 3
97558: PUSH
97559: LD_STRING 1
97561: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97562: LD_ADDR_VAR 0 6
97566: PUSH
97567: LD_VAR 0 6
97571: PUSH
97572: LD_VAR 0 3
97576: STR
97577: ST_TO_ADDR
// end ;
97578: GO 97474
97580: POP
97581: POP
// if isGameLoad then
97582: LD_VAR 0 1
97586: IFFALSE 98061
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97588: LD_ADDR_VAR 0 4
97592: PUSH
97593: LD_EXP 114
97597: PUSH
97598: LD_EXP 113
97602: PUSH
97603: LD_EXP 115
97607: PUSH
97608: LD_EXP 112
97612: PUSH
97613: LD_EXP 116
97617: PUSH
97618: LD_EXP 117
97622: PUSH
97623: LD_EXP 118
97627: PUSH
97628: LD_EXP 119
97632: PUSH
97633: LD_EXP 120
97637: PUSH
97638: LD_EXP 121
97642: PUSH
97643: LD_EXP 122
97647: PUSH
97648: LD_EXP 123
97652: PUSH
97653: LD_EXP 124
97657: PUSH
97658: LD_EXP 125
97662: PUSH
97663: LD_EXP 133
97667: PUSH
97668: LD_EXP 134
97672: PUSH
97673: LD_EXP 135
97677: PUSH
97678: LD_EXP 136
97682: PUSH
97683: LD_EXP 138
97687: PUSH
97688: LD_EXP 139
97692: PUSH
97693: LD_EXP 140
97697: PUSH
97698: LD_EXP 143
97702: PUSH
97703: LD_EXP 145
97707: PUSH
97708: LD_EXP 146
97712: PUSH
97713: LD_EXP 147
97717: PUSH
97718: LD_EXP 149
97722: PUSH
97723: LD_EXP 150
97727: PUSH
97728: LD_EXP 153
97732: PUSH
97733: LD_EXP 154
97737: PUSH
97738: LD_EXP 155
97742: PUSH
97743: LD_EXP 156
97747: PUSH
97748: LD_EXP 157
97752: PUSH
97753: LD_EXP 158
97757: PUSH
97758: LD_EXP 159
97762: PUSH
97763: LD_EXP 160
97767: PUSH
97768: LD_EXP 161
97772: PUSH
97773: LD_EXP 126
97777: PUSH
97778: LD_EXP 127
97782: PUSH
97783: LD_EXP 130
97787: PUSH
97788: LD_EXP 131
97792: PUSH
97793: LD_EXP 132
97797: PUSH
97798: LD_EXP 128
97802: PUSH
97803: LD_EXP 129
97807: PUSH
97808: LD_EXP 137
97812: PUSH
97813: LD_EXP 141
97817: PUSH
97818: LD_EXP 142
97822: PUSH
97823: LD_EXP 144
97827: PUSH
97828: LD_EXP 148
97832: PUSH
97833: LD_EXP 151
97837: PUSH
97838: LD_EXP 152
97842: PUSH
97843: LD_EXP 162
97847: PUSH
97848: LD_EXP 163
97852: PUSH
97853: LD_EXP 164
97857: PUSH
97858: LD_EXP 165
97862: PUSH
97863: EMPTY
97864: LIST
97865: LIST
97866: LIST
97867: LIST
97868: LIST
97869: LIST
97870: LIST
97871: LIST
97872: LIST
97873: LIST
97874: LIST
97875: LIST
97876: LIST
97877: LIST
97878: LIST
97879: LIST
97880: LIST
97881: LIST
97882: LIST
97883: LIST
97884: LIST
97885: LIST
97886: LIST
97887: LIST
97888: LIST
97889: LIST
97890: LIST
97891: LIST
97892: LIST
97893: LIST
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: LIST
97907: LIST
97908: LIST
97909: LIST
97910: LIST
97911: LIST
97912: LIST
97913: LIST
97914: LIST
97915: LIST
97916: LIST
97917: LIST
97918: ST_TO_ADDR
// tmp :=  ;
97919: LD_ADDR_VAR 0 3
97923: PUSH
97924: LD_STRING 
97926: ST_TO_ADDR
// for i = 1 to normalCounter do
97927: LD_ADDR_VAR 0 8
97931: PUSH
97932: DOUBLE
97933: LD_INT 1
97935: DEC
97936: ST_TO_ADDR
97937: LD_EXP 110
97941: PUSH
97942: FOR_TO
97943: IFFALSE 97979
// begin if flags [ i ] then
97945: LD_VAR 0 4
97949: PUSH
97950: LD_VAR 0 8
97954: ARRAY
97955: IFFALSE 97977
// tmp := tmp & i & ; ;
97957: LD_ADDR_VAR 0 3
97961: PUSH
97962: LD_VAR 0 3
97966: PUSH
97967: LD_VAR 0 8
97971: STR
97972: PUSH
97973: LD_STRING ;
97975: STR
97976: ST_TO_ADDR
// end ;
97977: GO 97942
97979: POP
97980: POP
// for i = 1 to hardcoreCounter do
97981: LD_ADDR_VAR 0 8
97985: PUSH
97986: DOUBLE
97987: LD_INT 1
97989: DEC
97990: ST_TO_ADDR
97991: LD_EXP 111
97995: PUSH
97996: FOR_TO
97997: IFFALSE 98043
// begin if flags [ normalCounter + i ] then
97999: LD_VAR 0 4
98003: PUSH
98004: LD_EXP 110
98008: PUSH
98009: LD_VAR 0 8
98013: PLUS
98014: ARRAY
98015: IFFALSE 98041
// tmp := tmp & ( 100 + i ) & ; ;
98017: LD_ADDR_VAR 0 3
98021: PUSH
98022: LD_VAR 0 3
98026: PUSH
98027: LD_INT 100
98029: PUSH
98030: LD_VAR 0 8
98034: PLUS
98035: STR
98036: PUSH
98037: LD_STRING ;
98039: STR
98040: ST_TO_ADDR
// end ;
98041: GO 97996
98043: POP
98044: POP
// if tmp then
98045: LD_VAR 0 3
98049: IFFALSE 98061
// active := tmp ;
98051: LD_ADDR_VAR 0 7
98055: PUSH
98056: LD_VAR 0 3
98060: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
98061: LD_STRING getStreamItemsFromMission("
98063: PUSH
98064: LD_VAR 0 5
98068: STR
98069: PUSH
98070: LD_STRING ","
98072: STR
98073: PUSH
98074: LD_VAR 0 6
98078: STR
98079: PUSH
98080: LD_STRING ","
98082: STR
98083: PUSH
98084: LD_VAR 0 7
98088: STR
98089: PUSH
98090: LD_STRING ")
98092: STR
98093: PPUSH
98094: CALL_OW 559
// end else
98098: GO 98107
// ToLua ( getStreamItemsFromMission("","","") ) ;
98100: LD_STRING getStreamItemsFromMission("","","")
98102: PPUSH
98103: CALL_OW 559
// end ;
98107: LD_VAR 0 2
98111: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98112: LD_EXP 109
98116: IFFALSE 98124
98118: PUSH
98119: LD_EXP 114
98123: AND
98124: IFFALSE 98248
98126: GO 98128
98128: DISABLE
98129: LD_INT 0
98131: PPUSH
98132: PPUSH
// begin enable ;
98133: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98134: LD_ADDR_VAR 0 2
98138: PUSH
98139: LD_INT 22
98141: PUSH
98142: LD_OWVAR 2
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 2
98153: PUSH
98154: LD_INT 34
98156: PUSH
98157: LD_INT 7
98159: PUSH
98160: EMPTY
98161: LIST
98162: LIST
98163: PUSH
98164: LD_INT 34
98166: PUSH
98167: LD_INT 45
98169: PUSH
98170: EMPTY
98171: LIST
98172: LIST
98173: PUSH
98174: LD_INT 34
98176: PUSH
98177: LD_INT 28
98179: PUSH
98180: EMPTY
98181: LIST
98182: LIST
98183: PUSH
98184: LD_INT 34
98186: PUSH
98187: LD_INT 47
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PUSH
98194: EMPTY
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: LIST
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PPUSH
98205: CALL_OW 69
98209: ST_TO_ADDR
// if not tmp then
98210: LD_VAR 0 2
98214: NOT
98215: IFFALSE 98219
// exit ;
98217: GO 98248
// for i in tmp do
98219: LD_ADDR_VAR 0 1
98223: PUSH
98224: LD_VAR 0 2
98228: PUSH
98229: FOR_IN
98230: IFFALSE 98246
// begin SetLives ( i , 0 ) ;
98232: LD_VAR 0 1
98236: PPUSH
98237: LD_INT 0
98239: PPUSH
98240: CALL_OW 234
// end ;
98244: GO 98229
98246: POP
98247: POP
// end ;
98248: PPOPN 2
98250: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98251: LD_EXP 109
98255: IFFALSE 98263
98257: PUSH
98258: LD_EXP 115
98262: AND
98263: IFFALSE 98347
98265: GO 98267
98267: DISABLE
98268: LD_INT 0
98270: PPUSH
98271: PPUSH
// begin enable ;
98272: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98273: LD_ADDR_VAR 0 2
98277: PUSH
98278: LD_INT 22
98280: PUSH
98281: LD_OWVAR 2
98285: PUSH
98286: EMPTY
98287: LIST
98288: LIST
98289: PUSH
98290: LD_INT 32
98292: PUSH
98293: LD_INT 3
98295: PUSH
98296: EMPTY
98297: LIST
98298: LIST
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PPUSH
98304: CALL_OW 69
98308: ST_TO_ADDR
// if not tmp then
98309: LD_VAR 0 2
98313: NOT
98314: IFFALSE 98318
// exit ;
98316: GO 98347
// for i in tmp do
98318: LD_ADDR_VAR 0 1
98322: PUSH
98323: LD_VAR 0 2
98327: PUSH
98328: FOR_IN
98329: IFFALSE 98345
// begin SetLives ( i , 0 ) ;
98331: LD_VAR 0 1
98335: PPUSH
98336: LD_INT 0
98338: PPUSH
98339: CALL_OW 234
// end ;
98343: GO 98328
98345: POP
98346: POP
// end ;
98347: PPOPN 2
98349: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98350: LD_EXP 109
98354: IFFALSE 98362
98356: PUSH
98357: LD_EXP 112
98361: AND
98362: IFFALSE 98455
98364: GO 98366
98366: DISABLE
98367: LD_INT 0
98369: PPUSH
// begin enable ;
98370: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98371: LD_ADDR_VAR 0 1
98375: PUSH
98376: LD_INT 22
98378: PUSH
98379: LD_OWVAR 2
98383: PUSH
98384: EMPTY
98385: LIST
98386: LIST
98387: PUSH
98388: LD_INT 2
98390: PUSH
98391: LD_INT 25
98393: PUSH
98394: LD_INT 5
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 25
98403: PUSH
98404: LD_INT 9
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 25
98413: PUSH
98414: LD_INT 8
98416: PUSH
98417: EMPTY
98418: LIST
98419: LIST
98420: PUSH
98421: EMPTY
98422: LIST
98423: LIST
98424: LIST
98425: LIST
98426: PUSH
98427: EMPTY
98428: LIST
98429: LIST
98430: PPUSH
98431: CALL_OW 69
98435: PUSH
98436: FOR_IN
98437: IFFALSE 98453
// begin SetClass ( i , 1 ) ;
98439: LD_VAR 0 1
98443: PPUSH
98444: LD_INT 1
98446: PPUSH
98447: CALL_OW 336
// end ;
98451: GO 98436
98453: POP
98454: POP
// end ;
98455: PPOPN 1
98457: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98458: LD_EXP 109
98462: IFFALSE 98470
98464: PUSH
98465: LD_EXP 113
98469: AND
98470: IFFALSE 98482
98472: PUSH
98473: LD_OWVAR 65
98477: PUSH
98478: LD_INT 7
98480: LESS
98481: AND
98482: IFFALSE 98496
98484: GO 98486
98486: DISABLE
// begin enable ;
98487: ENABLE
// game_speed := 7 ;
98488: LD_ADDR_OWVAR 65
98492: PUSH
98493: LD_INT 7
98495: ST_TO_ADDR
// end ;
98496: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98497: LD_EXP 109
98501: IFFALSE 98509
98503: PUSH
98504: LD_EXP 116
98508: AND
98509: IFFALSE 98711
98511: GO 98513
98513: DISABLE
98514: LD_INT 0
98516: PPUSH
98517: PPUSH
98518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98519: LD_ADDR_VAR 0 3
98523: PUSH
98524: LD_INT 81
98526: PUSH
98527: LD_OWVAR 2
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 21
98538: PUSH
98539: LD_INT 1
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PPUSH
98550: CALL_OW 69
98554: ST_TO_ADDR
// if not tmp then
98555: LD_VAR 0 3
98559: NOT
98560: IFFALSE 98564
// exit ;
98562: GO 98711
// if tmp > 5 then
98564: LD_VAR 0 3
98568: PUSH
98569: LD_INT 5
98571: GREATER
98572: IFFALSE 98584
// k := 5 else
98574: LD_ADDR_VAR 0 2
98578: PUSH
98579: LD_INT 5
98581: ST_TO_ADDR
98582: GO 98594
// k := tmp ;
98584: LD_ADDR_VAR 0 2
98588: PUSH
98589: LD_VAR 0 3
98593: ST_TO_ADDR
// for i := 1 to k do
98594: LD_ADDR_VAR 0 1
98598: PUSH
98599: DOUBLE
98600: LD_INT 1
98602: DEC
98603: ST_TO_ADDR
98604: LD_VAR 0 2
98608: PUSH
98609: FOR_TO
98610: IFFALSE 98709
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98612: LD_VAR 0 3
98616: PUSH
98617: LD_VAR 0 1
98621: ARRAY
98622: PPUSH
98623: LD_VAR 0 1
98627: PUSH
98628: LD_INT 4
98630: MOD
98631: PUSH
98632: LD_INT 1
98634: PLUS
98635: PPUSH
98636: CALL_OW 259
98640: PUSH
98641: LD_INT 10
98643: LESS
98644: IFFALSE 98707
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98646: LD_VAR 0 3
98650: PUSH
98651: LD_VAR 0 1
98655: ARRAY
98656: PPUSH
98657: LD_VAR 0 1
98661: PUSH
98662: LD_INT 4
98664: MOD
98665: PUSH
98666: LD_INT 1
98668: PLUS
98669: PPUSH
98670: LD_VAR 0 3
98674: PUSH
98675: LD_VAR 0 1
98679: ARRAY
98680: PPUSH
98681: LD_VAR 0 1
98685: PUSH
98686: LD_INT 4
98688: MOD
98689: PUSH
98690: LD_INT 1
98692: PLUS
98693: PPUSH
98694: CALL_OW 259
98698: PUSH
98699: LD_INT 1
98701: PLUS
98702: PPUSH
98703: CALL_OW 237
98707: GO 98609
98709: POP
98710: POP
// end ;
98711: PPOPN 3
98713: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98714: LD_EXP 109
98718: IFFALSE 98726
98720: PUSH
98721: LD_EXP 117
98725: AND
98726: IFFALSE 98746
98728: GO 98730
98730: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98731: LD_INT 4
98733: PPUSH
98734: LD_OWVAR 2
98738: PPUSH
98739: LD_INT 0
98741: PPUSH
98742: CALL_OW 324
98746: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98747: LD_EXP 109
98751: IFFALSE 98759
98753: PUSH
98754: LD_EXP 146
98758: AND
98759: IFFALSE 98779
98761: GO 98763
98763: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98764: LD_INT 19
98766: PPUSH
98767: LD_OWVAR 2
98771: PPUSH
98772: LD_INT 0
98774: PPUSH
98775: CALL_OW 324
98779: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98780: LD_EXP 109
98784: IFFALSE 98792
98786: PUSH
98787: LD_EXP 118
98791: AND
98792: IFFALSE 98894
98794: GO 98796
98796: DISABLE
98797: LD_INT 0
98799: PPUSH
98800: PPUSH
// begin enable ;
98801: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98802: LD_ADDR_VAR 0 2
98806: PUSH
98807: LD_INT 22
98809: PUSH
98810: LD_OWVAR 2
98814: PUSH
98815: EMPTY
98816: LIST
98817: LIST
98818: PUSH
98819: LD_INT 2
98821: PUSH
98822: LD_INT 34
98824: PUSH
98825: LD_INT 11
98827: PUSH
98828: EMPTY
98829: LIST
98830: LIST
98831: PUSH
98832: LD_INT 34
98834: PUSH
98835: LD_INT 30
98837: PUSH
98838: EMPTY
98839: LIST
98840: LIST
98841: PUSH
98842: EMPTY
98843: LIST
98844: LIST
98845: LIST
98846: PUSH
98847: EMPTY
98848: LIST
98849: LIST
98850: PPUSH
98851: CALL_OW 69
98855: ST_TO_ADDR
// if not tmp then
98856: LD_VAR 0 2
98860: NOT
98861: IFFALSE 98865
// exit ;
98863: GO 98894
// for i in tmp do
98865: LD_ADDR_VAR 0 1
98869: PUSH
98870: LD_VAR 0 2
98874: PUSH
98875: FOR_IN
98876: IFFALSE 98892
// begin SetLives ( i , 0 ) ;
98878: LD_VAR 0 1
98882: PPUSH
98883: LD_INT 0
98885: PPUSH
98886: CALL_OW 234
// end ;
98890: GO 98875
98892: POP
98893: POP
// end ;
98894: PPOPN 2
98896: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98897: LD_EXP 109
98901: IFFALSE 98909
98903: PUSH
98904: LD_EXP 119
98908: AND
98909: IFFALSE 98929
98911: GO 98913
98913: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98914: LD_INT 32
98916: PPUSH
98917: LD_OWVAR 2
98921: PPUSH
98922: LD_INT 0
98924: PPUSH
98925: CALL_OW 324
98929: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98930: LD_EXP 109
98934: IFFALSE 98942
98936: PUSH
98937: LD_EXP 120
98941: AND
98942: IFFALSE 99125
98944: GO 98946
98946: DISABLE
98947: LD_INT 0
98949: PPUSH
98950: PPUSH
98951: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98952: LD_ADDR_VAR 0 2
98956: PUSH
98957: LD_INT 22
98959: PUSH
98960: LD_OWVAR 2
98964: PUSH
98965: EMPTY
98966: LIST
98967: LIST
98968: PUSH
98969: LD_INT 33
98971: PUSH
98972: LD_INT 3
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: PPUSH
98983: CALL_OW 69
98987: ST_TO_ADDR
// if not tmp then
98988: LD_VAR 0 2
98992: NOT
98993: IFFALSE 98997
// exit ;
98995: GO 99125
// side := 0 ;
98997: LD_ADDR_VAR 0 3
99001: PUSH
99002: LD_INT 0
99004: ST_TO_ADDR
// for i := 1 to 8 do
99005: LD_ADDR_VAR 0 1
99009: PUSH
99010: DOUBLE
99011: LD_INT 1
99013: DEC
99014: ST_TO_ADDR
99015: LD_INT 8
99017: PUSH
99018: FOR_TO
99019: IFFALSE 99069
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
99021: LD_OWVAR 2
99025: PUSH
99026: LD_VAR 0 1
99030: NONEQUAL
99031: IFFALSE 99053
99033: PUSH
99034: LD_OWVAR 2
99038: PPUSH
99039: LD_VAR 0 1
99043: PPUSH
99044: CALL_OW 81
99048: PUSH
99049: LD_INT 2
99051: EQUAL
99052: AND
99053: IFFALSE 99067
// begin side := i ;
99055: LD_ADDR_VAR 0 3
99059: PUSH
99060: LD_VAR 0 1
99064: ST_TO_ADDR
// break ;
99065: GO 99069
// end ;
99067: GO 99018
99069: POP
99070: POP
// if not side then
99071: LD_VAR 0 3
99075: NOT
99076: IFFALSE 99080
// exit ;
99078: GO 99125
// for i := 1 to tmp do
99080: LD_ADDR_VAR 0 1
99084: PUSH
99085: DOUBLE
99086: LD_INT 1
99088: DEC
99089: ST_TO_ADDR
99090: LD_VAR 0 2
99094: PUSH
99095: FOR_TO
99096: IFFALSE 99123
// if Prob ( 60 ) then
99098: LD_INT 60
99100: PPUSH
99101: CALL_OW 13
99105: IFFALSE 99121
// SetSide ( i , side ) ;
99107: LD_VAR 0 1
99111: PPUSH
99112: LD_VAR 0 3
99116: PPUSH
99117: CALL_OW 235
99121: GO 99095
99123: POP
99124: POP
// end ;
99125: PPOPN 3
99127: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99128: LD_EXP 109
99132: IFFALSE 99140
99134: PUSH
99135: LD_EXP 122
99139: AND
99140: IFFALSE 99259
99142: GO 99144
99144: DISABLE
99145: LD_INT 0
99147: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99148: LD_ADDR_VAR 0 1
99152: PUSH
99153: LD_INT 22
99155: PUSH
99156: LD_OWVAR 2
99160: PUSH
99161: EMPTY
99162: LIST
99163: LIST
99164: PUSH
99165: LD_INT 21
99167: PUSH
99168: LD_INT 1
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: PUSH
99175: LD_INT 3
99177: PUSH
99178: LD_INT 23
99180: PUSH
99181: LD_INT 0
99183: PUSH
99184: EMPTY
99185: LIST
99186: LIST
99187: PUSH
99188: EMPTY
99189: LIST
99190: LIST
99191: PUSH
99192: EMPTY
99193: LIST
99194: LIST
99195: LIST
99196: PPUSH
99197: CALL_OW 69
99201: PUSH
99202: FOR_IN
99203: IFFALSE 99257
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99205: LD_VAR 0 1
99209: PPUSH
99210: CALL_OW 257
99214: PUSH
99215: LD_INT 1
99217: PUSH
99218: LD_INT 2
99220: PUSH
99221: LD_INT 3
99223: PUSH
99224: LD_INT 4
99226: PUSH
99227: EMPTY
99228: LIST
99229: LIST
99230: LIST
99231: LIST
99232: IN
99233: IFFALSE 99255
// SetClass ( un , rand ( 1 , 4 ) ) ;
99235: LD_VAR 0 1
99239: PPUSH
99240: LD_INT 1
99242: PPUSH
99243: LD_INT 4
99245: PPUSH
99246: CALL_OW 12
99250: PPUSH
99251: CALL_OW 336
99255: GO 99202
99257: POP
99258: POP
// end ;
99259: PPOPN 1
99261: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99262: LD_EXP 109
99266: IFFALSE 99274
99268: PUSH
99269: LD_EXP 121
99273: AND
99274: IFFALSE 99353
99276: GO 99278
99278: DISABLE
99279: LD_INT 0
99281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99282: LD_ADDR_VAR 0 1
99286: PUSH
99287: LD_INT 22
99289: PUSH
99290: LD_OWVAR 2
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: PUSH
99299: LD_INT 21
99301: PUSH
99302: LD_INT 3
99304: PUSH
99305: EMPTY
99306: LIST
99307: LIST
99308: PUSH
99309: EMPTY
99310: LIST
99311: LIST
99312: PPUSH
99313: CALL_OW 69
99317: ST_TO_ADDR
// if not tmp then
99318: LD_VAR 0 1
99322: NOT
99323: IFFALSE 99327
// exit ;
99325: GO 99353
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99327: LD_VAR 0 1
99331: PUSH
99332: LD_INT 1
99334: PPUSH
99335: LD_VAR 0 1
99339: PPUSH
99340: CALL_OW 12
99344: ARRAY
99345: PPUSH
99346: LD_INT 100
99348: PPUSH
99349: CALL_OW 234
// end ;
99353: PPOPN 1
99355: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99356: LD_EXP 109
99360: IFFALSE 99368
99362: PUSH
99363: LD_EXP 123
99367: AND
99368: IFFALSE 99466
99370: GO 99372
99372: DISABLE
99373: LD_INT 0
99375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99376: LD_ADDR_VAR 0 1
99380: PUSH
99381: LD_INT 22
99383: PUSH
99384: LD_OWVAR 2
99388: PUSH
99389: EMPTY
99390: LIST
99391: LIST
99392: PUSH
99393: LD_INT 21
99395: PUSH
99396: LD_INT 1
99398: PUSH
99399: EMPTY
99400: LIST
99401: LIST
99402: PUSH
99403: EMPTY
99404: LIST
99405: LIST
99406: PPUSH
99407: CALL_OW 69
99411: ST_TO_ADDR
// if not tmp then
99412: LD_VAR 0 1
99416: NOT
99417: IFFALSE 99421
// exit ;
99419: GO 99466
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99421: LD_VAR 0 1
99425: PUSH
99426: LD_INT 1
99428: PPUSH
99429: LD_VAR 0 1
99433: PPUSH
99434: CALL_OW 12
99438: ARRAY
99439: PPUSH
99440: LD_INT 1
99442: PPUSH
99443: LD_INT 4
99445: PPUSH
99446: CALL_OW 12
99450: PPUSH
99451: LD_INT 3000
99453: PPUSH
99454: LD_INT 9000
99456: PPUSH
99457: CALL_OW 12
99461: PPUSH
99462: CALL_OW 492
// end ;
99466: PPOPN 1
99468: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99469: LD_EXP 109
99473: IFFALSE 99481
99475: PUSH
99476: LD_EXP 124
99480: AND
99481: IFFALSE 99501
99483: GO 99485
99485: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99486: LD_INT 1
99488: PPUSH
99489: LD_OWVAR 2
99493: PPUSH
99494: LD_INT 0
99496: PPUSH
99497: CALL_OW 324
99501: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99502: LD_EXP 109
99506: IFFALSE 99514
99508: PUSH
99509: LD_EXP 125
99513: AND
99514: IFFALSE 99597
99516: GO 99518
99518: DISABLE
99519: LD_INT 0
99521: PPUSH
99522: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99523: LD_ADDR_VAR 0 2
99527: PUSH
99528: LD_INT 22
99530: PUSH
99531: LD_OWVAR 2
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: PUSH
99540: LD_INT 21
99542: PUSH
99543: LD_INT 3
99545: PUSH
99546: EMPTY
99547: LIST
99548: LIST
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: PPUSH
99554: CALL_OW 69
99558: ST_TO_ADDR
// if not tmp then
99559: LD_VAR 0 2
99563: NOT
99564: IFFALSE 99568
// exit ;
99566: GO 99597
// for i in tmp do
99568: LD_ADDR_VAR 0 1
99572: PUSH
99573: LD_VAR 0 2
99577: PUSH
99578: FOR_IN
99579: IFFALSE 99595
// SetBLevel ( i , 10 ) ;
99581: LD_VAR 0 1
99585: PPUSH
99586: LD_INT 10
99588: PPUSH
99589: CALL_OW 241
99593: GO 99578
99595: POP
99596: POP
// end ;
99597: PPOPN 2
99599: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99600: LD_EXP 109
99604: IFFALSE 99612
99606: PUSH
99607: LD_EXP 126
99611: AND
99612: IFFALSE 99723
99614: GO 99616
99616: DISABLE
99617: LD_INT 0
99619: PPUSH
99620: PPUSH
99621: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99622: LD_ADDR_VAR 0 3
99626: PUSH
99627: LD_INT 22
99629: PUSH
99630: LD_OWVAR 2
99634: PUSH
99635: EMPTY
99636: LIST
99637: LIST
99638: PUSH
99639: LD_INT 25
99641: PUSH
99642: LD_INT 1
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: PUSH
99649: EMPTY
99650: LIST
99651: LIST
99652: PPUSH
99653: CALL_OW 69
99657: ST_TO_ADDR
// if not tmp then
99658: LD_VAR 0 3
99662: NOT
99663: IFFALSE 99667
// exit ;
99665: GO 99723
// un := tmp [ rand ( 1 , tmp ) ] ;
99667: LD_ADDR_VAR 0 2
99671: PUSH
99672: LD_VAR 0 3
99676: PUSH
99677: LD_INT 1
99679: PPUSH
99680: LD_VAR 0 3
99684: PPUSH
99685: CALL_OW 12
99689: ARRAY
99690: ST_TO_ADDR
// if Crawls ( un ) then
99691: LD_VAR 0 2
99695: PPUSH
99696: CALL_OW 318
99700: IFFALSE 99711
// ComWalk ( un ) ;
99702: LD_VAR 0 2
99706: PPUSH
99707: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99711: LD_VAR 0 2
99715: PPUSH
99716: LD_INT 5
99718: PPUSH
99719: CALL_OW 336
// end ;
99723: PPOPN 3
99725: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99726: LD_EXP 109
99730: IFFALSE 99738
99732: PUSH
99733: LD_EXP 127
99737: AND
99738: IFFALSE 99750
99740: PUSH
99741: LD_OWVAR 67
99745: PUSH
99746: LD_INT 4
99748: LESS
99749: AND
99750: IFFALSE 99769
99752: GO 99754
99754: DISABLE
// begin Difficulty := Difficulty + 1 ;
99755: LD_ADDR_OWVAR 67
99759: PUSH
99760: LD_OWVAR 67
99764: PUSH
99765: LD_INT 1
99767: PLUS
99768: ST_TO_ADDR
// end ;
99769: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99770: LD_EXP 109
99774: IFFALSE 99782
99776: PUSH
99777: LD_EXP 128
99781: AND
99782: IFFALSE 99885
99784: GO 99786
99786: DISABLE
99787: LD_INT 0
99789: PPUSH
// begin for i := 1 to 5 do
99790: LD_ADDR_VAR 0 1
99794: PUSH
99795: DOUBLE
99796: LD_INT 1
99798: DEC
99799: ST_TO_ADDR
99800: LD_INT 5
99802: PUSH
99803: FOR_TO
99804: IFFALSE 99883
// begin uc_nation := nation_nature ;
99806: LD_ADDR_OWVAR 21
99810: PUSH
99811: LD_INT 0
99813: ST_TO_ADDR
// uc_side := 0 ;
99814: LD_ADDR_OWVAR 20
99818: PUSH
99819: LD_INT 0
99821: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99822: LD_ADDR_OWVAR 29
99826: PUSH
99827: LD_INT 12
99829: PUSH
99830: LD_INT 12
99832: PUSH
99833: EMPTY
99834: LIST
99835: LIST
99836: ST_TO_ADDR
// hc_agressivity := 20 ;
99837: LD_ADDR_OWVAR 35
99841: PUSH
99842: LD_INT 20
99844: ST_TO_ADDR
// hc_class := class_tiger ;
99845: LD_ADDR_OWVAR 28
99849: PUSH
99850: LD_INT 14
99852: ST_TO_ADDR
// hc_gallery :=  ;
99853: LD_ADDR_OWVAR 33
99857: PUSH
99858: LD_STRING 
99860: ST_TO_ADDR
// hc_name :=  ;
99861: LD_ADDR_OWVAR 26
99865: PUSH
99866: LD_STRING 
99868: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99869: CALL_OW 44
99873: PPUSH
99874: LD_INT 0
99876: PPUSH
99877: CALL_OW 51
// end ;
99881: GO 99803
99883: POP
99884: POP
// end ;
99885: PPOPN 1
99887: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99888: LD_EXP 109
99892: IFFALSE 99900
99894: PUSH
99895: LD_EXP 129
99899: AND
99900: IFFALSE 99909
99902: GO 99904
99904: DISABLE
// StreamSibBomb ;
99905: CALL 99910 0 0
99909: END
// export function StreamSibBomb ; var i , x , y ; begin
99910: LD_INT 0
99912: PPUSH
99913: PPUSH
99914: PPUSH
99915: PPUSH
// result := false ;
99916: LD_ADDR_VAR 0 1
99920: PUSH
99921: LD_INT 0
99923: ST_TO_ADDR
// for i := 1 to 16 do
99924: LD_ADDR_VAR 0 2
99928: PUSH
99929: DOUBLE
99930: LD_INT 1
99932: DEC
99933: ST_TO_ADDR
99934: LD_INT 16
99936: PUSH
99937: FOR_TO
99938: IFFALSE 100137
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99940: LD_ADDR_VAR 0 3
99944: PUSH
99945: LD_INT 10
99947: PUSH
99948: LD_INT 20
99950: PUSH
99951: LD_INT 30
99953: PUSH
99954: LD_INT 40
99956: PUSH
99957: LD_INT 50
99959: PUSH
99960: LD_INT 60
99962: PUSH
99963: LD_INT 70
99965: PUSH
99966: LD_INT 80
99968: PUSH
99969: LD_INT 90
99971: PUSH
99972: LD_INT 100
99974: PUSH
99975: LD_INT 110
99977: PUSH
99978: LD_INT 120
99980: PUSH
99981: LD_INT 130
99983: PUSH
99984: LD_INT 140
99986: PUSH
99987: LD_INT 150
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: LIST
99994: LIST
99995: LIST
99996: LIST
99997: LIST
99998: LIST
99999: LIST
100000: LIST
100001: LIST
100002: LIST
100003: LIST
100004: LIST
100005: LIST
100006: PUSH
100007: LD_INT 1
100009: PPUSH
100010: LD_INT 15
100012: PPUSH
100013: CALL_OW 12
100017: ARRAY
100018: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
100019: LD_ADDR_VAR 0 4
100023: PUSH
100024: LD_INT 10
100026: PUSH
100027: LD_INT 20
100029: PUSH
100030: LD_INT 30
100032: PUSH
100033: LD_INT 40
100035: PUSH
100036: LD_INT 50
100038: PUSH
100039: LD_INT 60
100041: PUSH
100042: LD_INT 70
100044: PUSH
100045: LD_INT 80
100047: PUSH
100048: LD_INT 90
100050: PUSH
100051: LD_INT 100
100053: PUSH
100054: LD_INT 110
100056: PUSH
100057: LD_INT 120
100059: PUSH
100060: LD_INT 130
100062: PUSH
100063: LD_INT 140
100065: PUSH
100066: LD_INT 150
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: LIST
100073: LIST
100074: LIST
100075: LIST
100076: LIST
100077: LIST
100078: LIST
100079: LIST
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: LIST
100085: PUSH
100086: LD_INT 1
100088: PPUSH
100089: LD_INT 15
100091: PPUSH
100092: CALL_OW 12
100096: ARRAY
100097: ST_TO_ADDR
// if ValidHex ( x , y ) then
100098: LD_VAR 0 3
100102: PPUSH
100103: LD_VAR 0 4
100107: PPUSH
100108: CALL_OW 488
100112: IFFALSE 100135
// begin result := [ x , y ] ;
100114: LD_ADDR_VAR 0 1
100118: PUSH
100119: LD_VAR 0 3
100123: PUSH
100124: LD_VAR 0 4
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: ST_TO_ADDR
// break ;
100133: GO 100137
// end ; end ;
100135: GO 99937
100137: POP
100138: POP
// if result then
100139: LD_VAR 0 1
100143: IFFALSE 100203
// begin ToLua ( playSibBomb() ) ;
100145: LD_STRING playSibBomb()
100147: PPUSH
100148: CALL_OW 559
// wait ( 0 0$14 ) ;
100152: LD_INT 490
100154: PPUSH
100155: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100159: LD_VAR 0 1
100163: PUSH
100164: LD_INT 1
100166: ARRAY
100167: PPUSH
100168: LD_VAR 0 1
100172: PUSH
100173: LD_INT 2
100175: ARRAY
100176: PPUSH
100177: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100181: LD_VAR 0 1
100185: PUSH
100186: LD_INT 1
100188: ARRAY
100189: PPUSH
100190: LD_VAR 0 1
100194: PUSH
100195: LD_INT 2
100197: ARRAY
100198: PPUSH
100199: CALL_OW 429
// end ; end ;
100203: LD_VAR 0 1
100207: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100208: LD_EXP 109
100212: IFFALSE 100220
100214: PUSH
100215: LD_EXP 131
100219: AND
100220: IFFALSE 100232
100222: GO 100224
100224: DISABLE
// YouLost (  ) ;
100225: LD_STRING 
100227: PPUSH
100228: CALL_OW 104
100232: END
// every 0 0$1 trigger StreamModeActive and sFog do
100233: LD_EXP 109
100237: IFFALSE 100245
100239: PUSH
100240: LD_EXP 130
100244: AND
100245: IFFALSE 100259
100247: GO 100249
100249: DISABLE
// FogOff ( your_side ) ;
100250: LD_OWVAR 2
100254: PPUSH
100255: CALL_OW 344
100259: END
// every 0 0$1 trigger StreamModeActive and sSun do
100260: LD_EXP 109
100264: IFFALSE 100272
100266: PUSH
100267: LD_EXP 132
100271: AND
100272: IFFALSE 100300
100274: GO 100276
100276: DISABLE
// begin solar_recharge_percent := 0 ;
100277: LD_ADDR_OWVAR 79
100281: PUSH
100282: LD_INT 0
100284: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100285: LD_INT 10500
100287: PPUSH
100288: CALL_OW 67
// solar_recharge_percent := 100 ;
100292: LD_ADDR_OWVAR 79
100296: PUSH
100297: LD_INT 100
100299: ST_TO_ADDR
// end ;
100300: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100301: LD_EXP 109
100305: IFFALSE 100313
100307: PUSH
100308: LD_EXP 133
100312: AND
100313: IFFALSE 100552
100315: GO 100317
100317: DISABLE
100318: LD_INT 0
100320: PPUSH
100321: PPUSH
100322: PPUSH
// begin tmp := [ ] ;
100323: LD_ADDR_VAR 0 3
100327: PUSH
100328: EMPTY
100329: ST_TO_ADDR
// for i := 1 to 6 do
100330: LD_ADDR_VAR 0 1
100334: PUSH
100335: DOUBLE
100336: LD_INT 1
100338: DEC
100339: ST_TO_ADDR
100340: LD_INT 6
100342: PUSH
100343: FOR_TO
100344: IFFALSE 100449
// begin uc_nation := nation_nature ;
100346: LD_ADDR_OWVAR 21
100350: PUSH
100351: LD_INT 0
100353: ST_TO_ADDR
// uc_side := 0 ;
100354: LD_ADDR_OWVAR 20
100358: PUSH
100359: LD_INT 0
100361: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100362: LD_ADDR_OWVAR 29
100366: PUSH
100367: LD_INT 12
100369: PUSH
100370: LD_INT 12
100372: PUSH
100373: EMPTY
100374: LIST
100375: LIST
100376: ST_TO_ADDR
// hc_agressivity := 20 ;
100377: LD_ADDR_OWVAR 35
100381: PUSH
100382: LD_INT 20
100384: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100385: LD_ADDR_OWVAR 28
100389: PUSH
100390: LD_INT 17
100392: ST_TO_ADDR
// hc_gallery :=  ;
100393: LD_ADDR_OWVAR 33
100397: PUSH
100398: LD_STRING 
100400: ST_TO_ADDR
// hc_name :=  ;
100401: LD_ADDR_OWVAR 26
100405: PUSH
100406: LD_STRING 
100408: ST_TO_ADDR
// un := CreateHuman ;
100409: LD_ADDR_VAR 0 2
100413: PUSH
100414: CALL_OW 44
100418: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100419: LD_VAR 0 2
100423: PPUSH
100424: LD_INT 1
100426: PPUSH
100427: CALL_OW 51
// tmp := tmp ^ un ;
100431: LD_ADDR_VAR 0 3
100435: PUSH
100436: LD_VAR 0 3
100440: PUSH
100441: LD_VAR 0 2
100445: ADD
100446: ST_TO_ADDR
// end ;
100447: GO 100343
100449: POP
100450: POP
// repeat wait ( 0 0$1 ) ;
100451: LD_INT 35
100453: PPUSH
100454: CALL_OW 67
// for un in tmp do
100458: LD_ADDR_VAR 0 2
100462: PUSH
100463: LD_VAR 0 3
100467: PUSH
100468: FOR_IN
100469: IFFALSE 100543
// begin if IsDead ( un ) then
100471: LD_VAR 0 2
100475: PPUSH
100476: CALL_OW 301
100480: IFFALSE 100500
// begin tmp := tmp diff un ;
100482: LD_ADDR_VAR 0 3
100486: PUSH
100487: LD_VAR 0 3
100491: PUSH
100492: LD_VAR 0 2
100496: DIFF
100497: ST_TO_ADDR
// continue ;
100498: GO 100468
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100500: LD_VAR 0 2
100504: PPUSH
100505: LD_INT 3
100507: PUSH
100508: LD_INT 22
100510: PUSH
100511: LD_INT 0
100513: PUSH
100514: EMPTY
100515: LIST
100516: LIST
100517: PUSH
100518: EMPTY
100519: LIST
100520: LIST
100521: PPUSH
100522: CALL_OW 69
100526: PPUSH
100527: LD_VAR 0 2
100531: PPUSH
100532: CALL_OW 74
100536: PPUSH
100537: CALL_OW 115
// end ;
100541: GO 100468
100543: POP
100544: POP
// until not tmp ;
100545: LD_VAR 0 3
100549: NOT
100550: IFFALSE 100451
// end ;
100552: PPOPN 3
100554: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100555: LD_EXP 109
100559: IFFALSE 100567
100561: PUSH
100562: LD_EXP 134
100566: AND
100567: IFFALSE 100621
100569: GO 100571
100571: DISABLE
// begin ToLua ( displayTroll(); ) ;
100572: LD_STRING displayTroll();
100574: PPUSH
100575: CALL_OW 559
// wait ( 3 3$00 ) ;
100579: LD_INT 6300
100581: PPUSH
100582: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100586: LD_STRING hideTroll();
100588: PPUSH
100589: CALL_OW 559
// wait ( 1 1$00 ) ;
100593: LD_INT 2100
100595: PPUSH
100596: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100600: LD_STRING displayTroll();
100602: PPUSH
100603: CALL_OW 559
// wait ( 1 1$00 ) ;
100607: LD_INT 2100
100609: PPUSH
100610: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100614: LD_STRING hideTroll();
100616: PPUSH
100617: CALL_OW 559
// end ;
100621: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100622: LD_EXP 109
100626: IFFALSE 100634
100628: PUSH
100629: LD_EXP 135
100633: AND
100634: IFFALSE 100697
100636: GO 100638
100638: DISABLE
100639: LD_INT 0
100641: PPUSH
// begin p := 0 ;
100642: LD_ADDR_VAR 0 1
100646: PUSH
100647: LD_INT 0
100649: ST_TO_ADDR
// repeat game_speed := 1 ;
100650: LD_ADDR_OWVAR 65
100654: PUSH
100655: LD_INT 1
100657: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100658: LD_INT 35
100660: PPUSH
100661: CALL_OW 67
// p := p + 1 ;
100665: LD_ADDR_VAR 0 1
100669: PUSH
100670: LD_VAR 0 1
100674: PUSH
100675: LD_INT 1
100677: PLUS
100678: ST_TO_ADDR
// until p >= 60 ;
100679: LD_VAR 0 1
100683: PUSH
100684: LD_INT 60
100686: GREATEREQUAL
100687: IFFALSE 100650
// game_speed := 4 ;
100689: LD_ADDR_OWVAR 65
100693: PUSH
100694: LD_INT 4
100696: ST_TO_ADDR
// end ;
100697: PPOPN 1
100699: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100700: LD_EXP 109
100704: IFFALSE 100712
100706: PUSH
100707: LD_EXP 136
100711: AND
100712: IFFALSE 100858
100714: GO 100716
100716: DISABLE
100717: LD_INT 0
100719: PPUSH
100720: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100721: LD_ADDR_VAR 0 1
100725: PUSH
100726: LD_INT 22
100728: PUSH
100729: LD_OWVAR 2
100733: PUSH
100734: EMPTY
100735: LIST
100736: LIST
100737: PUSH
100738: LD_INT 2
100740: PUSH
100741: LD_INT 30
100743: PUSH
100744: LD_INT 0
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: LD_INT 30
100753: PUSH
100754: LD_INT 1
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PUSH
100761: EMPTY
100762: LIST
100763: LIST
100764: LIST
100765: PUSH
100766: EMPTY
100767: LIST
100768: LIST
100769: PPUSH
100770: CALL_OW 69
100774: ST_TO_ADDR
// if not depot then
100775: LD_VAR 0 1
100779: NOT
100780: IFFALSE 100784
// exit ;
100782: GO 100858
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100784: LD_ADDR_VAR 0 2
100788: PUSH
100789: LD_VAR 0 1
100793: PUSH
100794: LD_INT 1
100796: PPUSH
100797: LD_VAR 0 1
100801: PPUSH
100802: CALL_OW 12
100806: ARRAY
100807: PPUSH
100808: CALL_OW 274
100812: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100813: LD_VAR 0 2
100817: PPUSH
100818: LD_INT 1
100820: PPUSH
100821: LD_INT 0
100823: PPUSH
100824: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100828: LD_VAR 0 2
100832: PPUSH
100833: LD_INT 2
100835: PPUSH
100836: LD_INT 0
100838: PPUSH
100839: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100843: LD_VAR 0 2
100847: PPUSH
100848: LD_INT 3
100850: PPUSH
100851: LD_INT 0
100853: PPUSH
100854: CALL_OW 277
// end ;
100858: PPOPN 2
100860: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100861: LD_EXP 109
100865: IFFALSE 100873
100867: PUSH
100868: LD_EXP 137
100872: AND
100873: IFFALSE 100970
100875: GO 100877
100877: DISABLE
100878: LD_INT 0
100880: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100881: LD_ADDR_VAR 0 1
100885: PUSH
100886: LD_INT 22
100888: PUSH
100889: LD_OWVAR 2
100893: PUSH
100894: EMPTY
100895: LIST
100896: LIST
100897: PUSH
100898: LD_INT 21
100900: PUSH
100901: LD_INT 1
100903: PUSH
100904: EMPTY
100905: LIST
100906: LIST
100907: PUSH
100908: LD_INT 3
100910: PUSH
100911: LD_INT 23
100913: PUSH
100914: LD_INT 0
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PUSH
100921: EMPTY
100922: LIST
100923: LIST
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: LIST
100929: PPUSH
100930: CALL_OW 69
100934: ST_TO_ADDR
// if not tmp then
100935: LD_VAR 0 1
100939: NOT
100940: IFFALSE 100944
// exit ;
100942: GO 100970
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100944: LD_VAR 0 1
100948: PUSH
100949: LD_INT 1
100951: PPUSH
100952: LD_VAR 0 1
100956: PPUSH
100957: CALL_OW 12
100961: ARRAY
100962: PPUSH
100963: LD_INT 200
100965: PPUSH
100966: CALL_OW 234
// end ;
100970: PPOPN 1
100972: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100973: LD_EXP 109
100977: IFFALSE 100985
100979: PUSH
100980: LD_EXP 138
100984: AND
100985: IFFALSE 101064
100987: GO 100989
100989: DISABLE
100990: LD_INT 0
100992: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100993: LD_ADDR_VAR 0 1
100997: PUSH
100998: LD_INT 22
101000: PUSH
101001: LD_OWVAR 2
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: PUSH
101010: LD_INT 21
101012: PUSH
101013: LD_INT 2
101015: PUSH
101016: EMPTY
101017: LIST
101018: LIST
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: PPUSH
101024: CALL_OW 69
101028: ST_TO_ADDR
// if not tmp then
101029: LD_VAR 0 1
101033: NOT
101034: IFFALSE 101038
// exit ;
101036: GO 101064
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
101038: LD_VAR 0 1
101042: PUSH
101043: LD_INT 1
101045: PPUSH
101046: LD_VAR 0 1
101050: PPUSH
101051: CALL_OW 12
101055: ARRAY
101056: PPUSH
101057: LD_INT 60
101059: PPUSH
101060: CALL_OW 234
// end ;
101064: PPOPN 1
101066: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101067: LD_EXP 109
101071: IFFALSE 101079
101073: PUSH
101074: LD_EXP 139
101078: AND
101079: IFFALSE 101178
101081: GO 101083
101083: DISABLE
101084: LD_INT 0
101086: PPUSH
101087: PPUSH
// begin enable ;
101088: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101089: LD_ADDR_VAR 0 1
101093: PUSH
101094: LD_INT 22
101096: PUSH
101097: LD_OWVAR 2
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: PUSH
101106: LD_INT 61
101108: PUSH
101109: EMPTY
101110: LIST
101111: PUSH
101112: LD_INT 33
101114: PUSH
101115: LD_INT 2
101117: PUSH
101118: EMPTY
101119: LIST
101120: LIST
101121: PUSH
101122: EMPTY
101123: LIST
101124: LIST
101125: LIST
101126: PPUSH
101127: CALL_OW 69
101131: ST_TO_ADDR
// if not tmp then
101132: LD_VAR 0 1
101136: NOT
101137: IFFALSE 101141
// exit ;
101139: GO 101178
// for i in tmp do
101141: LD_ADDR_VAR 0 2
101145: PUSH
101146: LD_VAR 0 1
101150: PUSH
101151: FOR_IN
101152: IFFALSE 101176
// if IsControledBy ( i ) then
101154: LD_VAR 0 2
101158: PPUSH
101159: CALL_OW 312
101163: IFFALSE 101174
// ComUnlink ( i ) ;
101165: LD_VAR 0 2
101169: PPUSH
101170: CALL_OW 136
101174: GO 101151
101176: POP
101177: POP
// end ;
101178: PPOPN 2
101180: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101181: LD_EXP 109
101185: IFFALSE 101193
101187: PUSH
101188: LD_EXP 140
101192: AND
101193: IFFALSE 101333
101195: GO 101197
101197: DISABLE
101198: LD_INT 0
101200: PPUSH
101201: PPUSH
// begin ToLua ( displayPowell(); ) ;
101202: LD_STRING displayPowell();
101204: PPUSH
101205: CALL_OW 559
// uc_side := 0 ;
101209: LD_ADDR_OWVAR 20
101213: PUSH
101214: LD_INT 0
101216: ST_TO_ADDR
// uc_nation := 2 ;
101217: LD_ADDR_OWVAR 21
101221: PUSH
101222: LD_INT 2
101224: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101225: LD_ADDR_OWVAR 37
101229: PUSH
101230: LD_INT 14
101232: ST_TO_ADDR
// vc_engine := engine_siberite ;
101233: LD_ADDR_OWVAR 39
101237: PUSH
101238: LD_INT 3
101240: ST_TO_ADDR
// vc_control := control_apeman ;
101241: LD_ADDR_OWVAR 38
101245: PUSH
101246: LD_INT 5
101248: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101249: LD_ADDR_OWVAR 40
101253: PUSH
101254: LD_INT 29
101256: ST_TO_ADDR
// un := CreateVehicle ;
101257: LD_ADDR_VAR 0 2
101261: PUSH
101262: CALL_OW 45
101266: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101267: LD_VAR 0 2
101271: PPUSH
101272: LD_INT 1
101274: PPUSH
101275: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101279: LD_INT 35
101281: PPUSH
101282: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101286: LD_VAR 0 2
101290: PPUSH
101291: LD_INT 22
101293: PUSH
101294: LD_OWVAR 2
101298: PUSH
101299: EMPTY
101300: LIST
101301: LIST
101302: PPUSH
101303: CALL_OW 69
101307: PPUSH
101308: LD_VAR 0 2
101312: PPUSH
101313: CALL_OW 74
101317: PPUSH
101318: CALL_OW 115
// until IsDead ( un ) ;
101322: LD_VAR 0 2
101326: PPUSH
101327: CALL_OW 301
101331: IFFALSE 101279
// end ;
101333: PPOPN 2
101335: END
// every 0 0$1 trigger StreamModeActive and sStu do
101336: LD_EXP 109
101340: IFFALSE 101348
101342: PUSH
101343: LD_EXP 148
101347: AND
101348: IFFALSE 101364
101350: GO 101352
101352: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101353: LD_STRING displayStucuk();
101355: PPUSH
101356: CALL_OW 559
// ResetFog ;
101360: CALL_OW 335
// end ;
101364: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101365: LD_EXP 109
101369: IFFALSE 101377
101371: PUSH
101372: LD_EXP 141
101376: AND
101377: IFFALSE 101518
101379: GO 101381
101381: DISABLE
101382: LD_INT 0
101384: PPUSH
101385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101386: LD_ADDR_VAR 0 2
101390: PUSH
101391: LD_INT 22
101393: PUSH
101394: LD_OWVAR 2
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: PUSH
101403: LD_INT 21
101405: PUSH
101406: LD_INT 1
101408: PUSH
101409: EMPTY
101410: LIST
101411: LIST
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PPUSH
101417: CALL_OW 69
101421: ST_TO_ADDR
// if not tmp then
101422: LD_VAR 0 2
101426: NOT
101427: IFFALSE 101431
// exit ;
101429: GO 101518
// un := tmp [ rand ( 1 , tmp ) ] ;
101431: LD_ADDR_VAR 0 1
101435: PUSH
101436: LD_VAR 0 2
101440: PUSH
101441: LD_INT 1
101443: PPUSH
101444: LD_VAR 0 2
101448: PPUSH
101449: CALL_OW 12
101453: ARRAY
101454: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101455: LD_VAR 0 1
101459: PPUSH
101460: LD_INT 0
101462: PPUSH
101463: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101467: LD_VAR 0 1
101471: PPUSH
101472: LD_OWVAR 3
101476: PUSH
101477: LD_VAR 0 1
101481: DIFF
101482: PPUSH
101483: LD_VAR 0 1
101487: PPUSH
101488: CALL_OW 74
101492: PPUSH
101493: CALL_OW 115
// wait ( 0 0$20 ) ;
101497: LD_INT 700
101499: PPUSH
101500: CALL_OW 67
// SetSide ( un , your_side ) ;
101504: LD_VAR 0 1
101508: PPUSH
101509: LD_OWVAR 2
101513: PPUSH
101514: CALL_OW 235
// end ;
101518: PPOPN 2
101520: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101521: LD_EXP 109
101525: IFFALSE 101533
101527: PUSH
101528: LD_EXP 142
101532: AND
101533: IFFALSE 101639
101535: GO 101537
101537: DISABLE
101538: LD_INT 0
101540: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101541: LD_ADDR_VAR 0 1
101545: PUSH
101546: LD_INT 22
101548: PUSH
101549: LD_OWVAR 2
101553: PUSH
101554: EMPTY
101555: LIST
101556: LIST
101557: PUSH
101558: LD_INT 2
101560: PUSH
101561: LD_INT 30
101563: PUSH
101564: LD_INT 0
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: PUSH
101571: LD_INT 30
101573: PUSH
101574: LD_INT 1
101576: PUSH
101577: EMPTY
101578: LIST
101579: LIST
101580: PUSH
101581: EMPTY
101582: LIST
101583: LIST
101584: LIST
101585: PUSH
101586: EMPTY
101587: LIST
101588: LIST
101589: PPUSH
101590: CALL_OW 69
101594: ST_TO_ADDR
// if not depot then
101595: LD_VAR 0 1
101599: NOT
101600: IFFALSE 101604
// exit ;
101602: GO 101639
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101604: LD_VAR 0 1
101608: PUSH
101609: LD_INT 1
101611: ARRAY
101612: PPUSH
101613: CALL_OW 250
101617: PPUSH
101618: LD_VAR 0 1
101622: PUSH
101623: LD_INT 1
101625: ARRAY
101626: PPUSH
101627: CALL_OW 251
101631: PPUSH
101632: LD_INT 70
101634: PPUSH
101635: CALL_OW 495
// end ;
101639: PPOPN 1
101641: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101642: LD_EXP 109
101646: IFFALSE 101654
101648: PUSH
101649: LD_EXP 143
101653: AND
101654: IFFALSE 101865
101656: GO 101658
101658: DISABLE
101659: LD_INT 0
101661: PPUSH
101662: PPUSH
101663: PPUSH
101664: PPUSH
101665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101666: LD_ADDR_VAR 0 5
101670: PUSH
101671: LD_INT 22
101673: PUSH
101674: LD_OWVAR 2
101678: PUSH
101679: EMPTY
101680: LIST
101681: LIST
101682: PUSH
101683: LD_INT 21
101685: PUSH
101686: LD_INT 1
101688: PUSH
101689: EMPTY
101690: LIST
101691: LIST
101692: PUSH
101693: EMPTY
101694: LIST
101695: LIST
101696: PPUSH
101697: CALL_OW 69
101701: ST_TO_ADDR
// if not tmp then
101702: LD_VAR 0 5
101706: NOT
101707: IFFALSE 101711
// exit ;
101709: GO 101865
// for i in tmp do
101711: LD_ADDR_VAR 0 1
101715: PUSH
101716: LD_VAR 0 5
101720: PUSH
101721: FOR_IN
101722: IFFALSE 101863
// begin d := rand ( 0 , 5 ) ;
101724: LD_ADDR_VAR 0 4
101728: PUSH
101729: LD_INT 0
101731: PPUSH
101732: LD_INT 5
101734: PPUSH
101735: CALL_OW 12
101739: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101740: LD_ADDR_VAR 0 2
101744: PUSH
101745: LD_VAR 0 1
101749: PPUSH
101750: CALL_OW 250
101754: PPUSH
101755: LD_VAR 0 4
101759: PPUSH
101760: LD_INT 3
101762: PPUSH
101763: LD_INT 12
101765: PPUSH
101766: CALL_OW 12
101770: PPUSH
101771: CALL_OW 272
101775: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101776: LD_ADDR_VAR 0 3
101780: PUSH
101781: LD_VAR 0 1
101785: PPUSH
101786: CALL_OW 251
101790: PPUSH
101791: LD_VAR 0 4
101795: PPUSH
101796: LD_INT 3
101798: PPUSH
101799: LD_INT 12
101801: PPUSH
101802: CALL_OW 12
101806: PPUSH
101807: CALL_OW 273
101811: ST_TO_ADDR
// if ValidHex ( x , y ) then
101812: LD_VAR 0 2
101816: PPUSH
101817: LD_VAR 0 3
101821: PPUSH
101822: CALL_OW 488
101826: IFFALSE 101861
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101828: LD_VAR 0 1
101832: PPUSH
101833: LD_VAR 0 2
101837: PPUSH
101838: LD_VAR 0 3
101842: PPUSH
101843: LD_INT 3
101845: PPUSH
101846: LD_INT 6
101848: PPUSH
101849: CALL_OW 12
101853: PPUSH
101854: LD_INT 1
101856: PPUSH
101857: CALL_OW 483
// end ;
101861: GO 101721
101863: POP
101864: POP
// end ;
101865: PPOPN 5
101867: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101868: LD_EXP 109
101872: IFFALSE 101880
101874: PUSH
101875: LD_EXP 144
101879: AND
101880: IFFALSE 101974
101882: GO 101884
101884: DISABLE
101885: LD_INT 0
101887: PPUSH
101888: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101889: LD_ADDR_VAR 0 2
101893: PUSH
101894: LD_INT 22
101896: PUSH
101897: LD_OWVAR 2
101901: PUSH
101902: EMPTY
101903: LIST
101904: LIST
101905: PUSH
101906: LD_INT 32
101908: PUSH
101909: LD_INT 1
101911: PUSH
101912: EMPTY
101913: LIST
101914: LIST
101915: PUSH
101916: LD_INT 21
101918: PUSH
101919: LD_INT 2
101921: PUSH
101922: EMPTY
101923: LIST
101924: LIST
101925: PUSH
101926: EMPTY
101927: LIST
101928: LIST
101929: LIST
101930: PPUSH
101931: CALL_OW 69
101935: ST_TO_ADDR
// if not tmp then
101936: LD_VAR 0 2
101940: NOT
101941: IFFALSE 101945
// exit ;
101943: GO 101974
// for i in tmp do
101945: LD_ADDR_VAR 0 1
101949: PUSH
101950: LD_VAR 0 2
101954: PUSH
101955: FOR_IN
101956: IFFALSE 101972
// SetFuel ( i , 0 ) ;
101958: LD_VAR 0 1
101962: PPUSH
101963: LD_INT 0
101965: PPUSH
101966: CALL_OW 240
101970: GO 101955
101972: POP
101973: POP
// end ;
101974: PPOPN 2
101976: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101977: LD_EXP 109
101981: IFFALSE 101989
101983: PUSH
101984: LD_EXP 145
101988: AND
101989: IFFALSE 102055
101991: GO 101993
101993: DISABLE
101994: LD_INT 0
101996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101997: LD_ADDR_VAR 0 1
102001: PUSH
102002: LD_INT 22
102004: PUSH
102005: LD_OWVAR 2
102009: PUSH
102010: EMPTY
102011: LIST
102012: LIST
102013: PUSH
102014: LD_INT 30
102016: PUSH
102017: LD_INT 29
102019: PUSH
102020: EMPTY
102021: LIST
102022: LIST
102023: PUSH
102024: EMPTY
102025: LIST
102026: LIST
102027: PPUSH
102028: CALL_OW 69
102032: ST_TO_ADDR
// if not tmp then
102033: LD_VAR 0 1
102037: NOT
102038: IFFALSE 102042
// exit ;
102040: GO 102055
// DestroyUnit ( tmp [ 1 ] ) ;
102042: LD_VAR 0 1
102046: PUSH
102047: LD_INT 1
102049: ARRAY
102050: PPUSH
102051: CALL_OW 65
// end ;
102055: PPOPN 1
102057: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
102058: LD_EXP 109
102062: IFFALSE 102070
102064: PUSH
102065: LD_EXP 147
102069: AND
102070: IFFALSE 102199
102072: GO 102074
102074: DISABLE
102075: LD_INT 0
102077: PPUSH
// begin uc_side := 0 ;
102078: LD_ADDR_OWVAR 20
102082: PUSH
102083: LD_INT 0
102085: ST_TO_ADDR
// uc_nation := nation_arabian ;
102086: LD_ADDR_OWVAR 21
102090: PUSH
102091: LD_INT 2
102093: ST_TO_ADDR
// hc_gallery :=  ;
102094: LD_ADDR_OWVAR 33
102098: PUSH
102099: LD_STRING 
102101: ST_TO_ADDR
// hc_name :=  ;
102102: LD_ADDR_OWVAR 26
102106: PUSH
102107: LD_STRING 
102109: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102110: LD_INT 1
102112: PPUSH
102113: LD_INT 11
102115: PPUSH
102116: LD_INT 10
102118: PPUSH
102119: CALL_OW 380
// un := CreateHuman ;
102123: LD_ADDR_VAR 0 1
102127: PUSH
102128: CALL_OW 44
102132: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102133: LD_VAR 0 1
102137: PPUSH
102138: LD_INT 1
102140: PPUSH
102141: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102145: LD_INT 35
102147: PPUSH
102148: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102152: LD_VAR 0 1
102156: PPUSH
102157: LD_INT 22
102159: PUSH
102160: LD_OWVAR 2
102164: PUSH
102165: EMPTY
102166: LIST
102167: LIST
102168: PPUSH
102169: CALL_OW 69
102173: PPUSH
102174: LD_VAR 0 1
102178: PPUSH
102179: CALL_OW 74
102183: PPUSH
102184: CALL_OW 115
// until IsDead ( un ) ;
102188: LD_VAR 0 1
102192: PPUSH
102193: CALL_OW 301
102197: IFFALSE 102145
// end ;
102199: PPOPN 1
102201: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102202: LD_EXP 109
102206: IFFALSE 102214
102208: PUSH
102209: LD_EXP 149
102213: AND
102214: IFFALSE 102226
102216: GO 102218
102218: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102219: LD_STRING earthquake(getX(game), 0, 32)
102221: PPUSH
102222: CALL_OW 559
102226: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102227: LD_EXP 109
102231: IFFALSE 102239
102233: PUSH
102234: LD_EXP 150
102238: AND
102239: IFFALSE 102330
102241: GO 102243
102243: DISABLE
102244: LD_INT 0
102246: PPUSH
// begin enable ;
102247: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102248: LD_ADDR_VAR 0 1
102252: PUSH
102253: LD_INT 22
102255: PUSH
102256: LD_OWVAR 2
102260: PUSH
102261: EMPTY
102262: LIST
102263: LIST
102264: PUSH
102265: LD_INT 21
102267: PUSH
102268: LD_INT 2
102270: PUSH
102271: EMPTY
102272: LIST
102273: LIST
102274: PUSH
102275: LD_INT 33
102277: PUSH
102278: LD_INT 3
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PUSH
102285: EMPTY
102286: LIST
102287: LIST
102288: LIST
102289: PPUSH
102290: CALL_OW 69
102294: ST_TO_ADDR
// if not tmp then
102295: LD_VAR 0 1
102299: NOT
102300: IFFALSE 102304
// exit ;
102302: GO 102330
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102304: LD_VAR 0 1
102308: PUSH
102309: LD_INT 1
102311: PPUSH
102312: LD_VAR 0 1
102316: PPUSH
102317: CALL_OW 12
102321: ARRAY
102322: PPUSH
102323: LD_INT 1
102325: PPUSH
102326: CALL_OW 234
// end ;
102330: PPOPN 1
102332: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102333: LD_EXP 109
102337: IFFALSE 102345
102339: PUSH
102340: LD_EXP 151
102344: AND
102345: IFFALSE 102486
102347: GO 102349
102349: DISABLE
102350: LD_INT 0
102352: PPUSH
102353: PPUSH
102354: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102355: LD_ADDR_VAR 0 3
102359: PUSH
102360: LD_INT 22
102362: PUSH
102363: LD_OWVAR 2
102367: PUSH
102368: EMPTY
102369: LIST
102370: LIST
102371: PUSH
102372: LD_INT 25
102374: PUSH
102375: LD_INT 1
102377: PUSH
102378: EMPTY
102379: LIST
102380: LIST
102381: PUSH
102382: EMPTY
102383: LIST
102384: LIST
102385: PPUSH
102386: CALL_OW 69
102390: ST_TO_ADDR
// if not tmp then
102391: LD_VAR 0 3
102395: NOT
102396: IFFALSE 102400
// exit ;
102398: GO 102486
// un := tmp [ rand ( 1 , tmp ) ] ;
102400: LD_ADDR_VAR 0 2
102404: PUSH
102405: LD_VAR 0 3
102409: PUSH
102410: LD_INT 1
102412: PPUSH
102413: LD_VAR 0 3
102417: PPUSH
102418: CALL_OW 12
102422: ARRAY
102423: ST_TO_ADDR
// if Crawls ( un ) then
102424: LD_VAR 0 2
102428: PPUSH
102429: CALL_OW 318
102433: IFFALSE 102444
// ComWalk ( un ) ;
102435: LD_VAR 0 2
102439: PPUSH
102440: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102444: LD_VAR 0 2
102448: PPUSH
102449: LD_INT 9
102451: PPUSH
102452: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102456: LD_INT 28
102458: PPUSH
102459: LD_OWVAR 2
102463: PPUSH
102464: LD_INT 2
102466: PPUSH
102467: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102471: LD_INT 29
102473: PPUSH
102474: LD_OWVAR 2
102478: PPUSH
102479: LD_INT 2
102481: PPUSH
102482: CALL_OW 322
// end ;
102486: PPOPN 3
102488: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102489: LD_EXP 109
102493: IFFALSE 102501
102495: PUSH
102496: LD_EXP 152
102500: AND
102501: IFFALSE 102612
102503: GO 102505
102505: DISABLE
102506: LD_INT 0
102508: PPUSH
102509: PPUSH
102510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102511: LD_ADDR_VAR 0 3
102515: PUSH
102516: LD_INT 22
102518: PUSH
102519: LD_OWVAR 2
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: PUSH
102528: LD_INT 25
102530: PUSH
102531: LD_INT 1
102533: PUSH
102534: EMPTY
102535: LIST
102536: LIST
102537: PUSH
102538: EMPTY
102539: LIST
102540: LIST
102541: PPUSH
102542: CALL_OW 69
102546: ST_TO_ADDR
// if not tmp then
102547: LD_VAR 0 3
102551: NOT
102552: IFFALSE 102556
// exit ;
102554: GO 102612
// un := tmp [ rand ( 1 , tmp ) ] ;
102556: LD_ADDR_VAR 0 2
102560: PUSH
102561: LD_VAR 0 3
102565: PUSH
102566: LD_INT 1
102568: PPUSH
102569: LD_VAR 0 3
102573: PPUSH
102574: CALL_OW 12
102578: ARRAY
102579: ST_TO_ADDR
// if Crawls ( un ) then
102580: LD_VAR 0 2
102584: PPUSH
102585: CALL_OW 318
102589: IFFALSE 102600
// ComWalk ( un ) ;
102591: LD_VAR 0 2
102595: PPUSH
102596: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102600: LD_VAR 0 2
102604: PPUSH
102605: LD_INT 8
102607: PPUSH
102608: CALL_OW 336
// end ;
102612: PPOPN 3
102614: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102615: LD_EXP 109
102619: IFFALSE 102627
102621: PUSH
102622: LD_EXP 153
102626: AND
102627: IFFALSE 102771
102629: GO 102631
102631: DISABLE
102632: LD_INT 0
102634: PPUSH
102635: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102636: LD_ADDR_VAR 0 2
102640: PUSH
102641: LD_INT 22
102643: PUSH
102644: LD_OWVAR 2
102648: PUSH
102649: EMPTY
102650: LIST
102651: LIST
102652: PUSH
102653: LD_INT 21
102655: PUSH
102656: LD_INT 2
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: PUSH
102663: LD_INT 2
102665: PUSH
102666: LD_INT 34
102668: PUSH
102669: LD_INT 12
102671: PUSH
102672: EMPTY
102673: LIST
102674: LIST
102675: PUSH
102676: LD_INT 34
102678: PUSH
102679: LD_INT 51
102681: PUSH
102682: EMPTY
102683: LIST
102684: LIST
102685: PUSH
102686: LD_INT 34
102688: PUSH
102689: LD_INT 32
102691: PUSH
102692: EMPTY
102693: LIST
102694: LIST
102695: PUSH
102696: EMPTY
102697: LIST
102698: LIST
102699: LIST
102700: LIST
102701: PUSH
102702: EMPTY
102703: LIST
102704: LIST
102705: LIST
102706: PPUSH
102707: CALL_OW 69
102711: ST_TO_ADDR
// if not tmp then
102712: LD_VAR 0 2
102716: NOT
102717: IFFALSE 102721
// exit ;
102719: GO 102771
// for i in tmp do
102721: LD_ADDR_VAR 0 1
102725: PUSH
102726: LD_VAR 0 2
102730: PUSH
102731: FOR_IN
102732: IFFALSE 102769
// if GetCargo ( i , mat_artifact ) = 0 then
102734: LD_VAR 0 1
102738: PPUSH
102739: LD_INT 4
102741: PPUSH
102742: CALL_OW 289
102746: PUSH
102747: LD_INT 0
102749: EQUAL
102750: IFFALSE 102767
// SetCargo ( i , mat_siberit , 100 ) ;
102752: LD_VAR 0 1
102756: PPUSH
102757: LD_INT 3
102759: PPUSH
102760: LD_INT 100
102762: PPUSH
102763: CALL_OW 290
102767: GO 102731
102769: POP
102770: POP
// end ;
102771: PPOPN 2
102773: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102774: LD_EXP 109
102778: IFFALSE 102786
102780: PUSH
102781: LD_EXP 154
102785: AND
102786: IFFALSE 102969
102788: GO 102790
102790: DISABLE
102791: LD_INT 0
102793: PPUSH
102794: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102795: LD_ADDR_VAR 0 2
102799: PUSH
102800: LD_INT 22
102802: PUSH
102803: LD_OWVAR 2
102807: PUSH
102808: EMPTY
102809: LIST
102810: LIST
102811: PPUSH
102812: CALL_OW 69
102816: ST_TO_ADDR
// if not tmp then
102817: LD_VAR 0 2
102821: NOT
102822: IFFALSE 102826
// exit ;
102824: GO 102969
// for i := 1 to 2 do
102826: LD_ADDR_VAR 0 1
102830: PUSH
102831: DOUBLE
102832: LD_INT 1
102834: DEC
102835: ST_TO_ADDR
102836: LD_INT 2
102838: PUSH
102839: FOR_TO
102840: IFFALSE 102967
// begin uc_side := your_side ;
102842: LD_ADDR_OWVAR 20
102846: PUSH
102847: LD_OWVAR 2
102851: ST_TO_ADDR
// uc_nation := nation_american ;
102852: LD_ADDR_OWVAR 21
102856: PUSH
102857: LD_INT 1
102859: ST_TO_ADDR
// vc_chassis := us_morphling ;
102860: LD_ADDR_OWVAR 37
102864: PUSH
102865: LD_INT 5
102867: ST_TO_ADDR
// vc_engine := engine_siberite ;
102868: LD_ADDR_OWVAR 39
102872: PUSH
102873: LD_INT 3
102875: ST_TO_ADDR
// vc_control := control_computer ;
102876: LD_ADDR_OWVAR 38
102880: PUSH
102881: LD_INT 3
102883: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102884: LD_ADDR_OWVAR 40
102888: PUSH
102889: LD_INT 10
102891: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102892: LD_VAR 0 2
102896: PUSH
102897: LD_INT 1
102899: ARRAY
102900: PPUSH
102901: CALL_OW 310
102905: NOT
102906: IFFALSE 102953
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102908: CALL_OW 45
102912: PPUSH
102913: LD_VAR 0 2
102917: PUSH
102918: LD_INT 1
102920: ARRAY
102921: PPUSH
102922: CALL_OW 250
102926: PPUSH
102927: LD_VAR 0 2
102931: PUSH
102932: LD_INT 1
102934: ARRAY
102935: PPUSH
102936: CALL_OW 251
102940: PPUSH
102941: LD_INT 12
102943: PPUSH
102944: LD_INT 1
102946: PPUSH
102947: CALL_OW 50
102951: GO 102965
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102953: CALL_OW 45
102957: PPUSH
102958: LD_INT 1
102960: PPUSH
102961: CALL_OW 51
// end ;
102965: GO 102839
102967: POP
102968: POP
// end ;
102969: PPOPN 2
102971: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102972: LD_EXP 109
102976: IFFALSE 102984
102978: PUSH
102979: LD_EXP 155
102983: AND
102984: IFFALSE 103206
102986: GO 102988
102988: DISABLE
102989: LD_INT 0
102991: PPUSH
102992: PPUSH
102993: PPUSH
102994: PPUSH
102995: PPUSH
102996: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102997: LD_ADDR_VAR 0 6
103001: PUSH
103002: LD_INT 22
103004: PUSH
103005: LD_OWVAR 2
103009: PUSH
103010: EMPTY
103011: LIST
103012: LIST
103013: PUSH
103014: LD_INT 21
103016: PUSH
103017: LD_INT 1
103019: PUSH
103020: EMPTY
103021: LIST
103022: LIST
103023: PUSH
103024: LD_INT 3
103026: PUSH
103027: LD_INT 23
103029: PUSH
103030: LD_INT 0
103032: PUSH
103033: EMPTY
103034: LIST
103035: LIST
103036: PUSH
103037: EMPTY
103038: LIST
103039: LIST
103040: PUSH
103041: EMPTY
103042: LIST
103043: LIST
103044: LIST
103045: PPUSH
103046: CALL_OW 69
103050: ST_TO_ADDR
// if not tmp then
103051: LD_VAR 0 6
103055: NOT
103056: IFFALSE 103060
// exit ;
103058: GO 103206
// s1 := rand ( 1 , 4 ) ;
103060: LD_ADDR_VAR 0 2
103064: PUSH
103065: LD_INT 1
103067: PPUSH
103068: LD_INT 4
103070: PPUSH
103071: CALL_OW 12
103075: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103076: LD_ADDR_VAR 0 4
103080: PUSH
103081: LD_VAR 0 6
103085: PUSH
103086: LD_INT 1
103088: ARRAY
103089: PPUSH
103090: LD_VAR 0 2
103094: PPUSH
103095: CALL_OW 259
103099: ST_TO_ADDR
// if s1 = 1 then
103100: LD_VAR 0 2
103104: PUSH
103105: LD_INT 1
103107: EQUAL
103108: IFFALSE 103128
// s2 := rand ( 2 , 4 ) else
103110: LD_ADDR_VAR 0 3
103114: PUSH
103115: LD_INT 2
103117: PPUSH
103118: LD_INT 4
103120: PPUSH
103121: CALL_OW 12
103125: ST_TO_ADDR
103126: GO 103136
// s2 := 1 ;
103128: LD_ADDR_VAR 0 3
103132: PUSH
103133: LD_INT 1
103135: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103136: LD_ADDR_VAR 0 5
103140: PUSH
103141: LD_VAR 0 6
103145: PUSH
103146: LD_INT 1
103148: ARRAY
103149: PPUSH
103150: LD_VAR 0 3
103154: PPUSH
103155: CALL_OW 259
103159: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103160: LD_VAR 0 6
103164: PUSH
103165: LD_INT 1
103167: ARRAY
103168: PPUSH
103169: LD_VAR 0 2
103173: PPUSH
103174: LD_VAR 0 5
103178: PPUSH
103179: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103183: LD_VAR 0 6
103187: PUSH
103188: LD_INT 1
103190: ARRAY
103191: PPUSH
103192: LD_VAR 0 3
103196: PPUSH
103197: LD_VAR 0 4
103201: PPUSH
103202: CALL_OW 237
// end ;
103206: PPOPN 6
103208: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103209: LD_EXP 109
103213: IFFALSE 103221
103215: PUSH
103216: LD_EXP 156
103220: AND
103221: IFFALSE 103300
103223: GO 103225
103225: DISABLE
103226: LD_INT 0
103228: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103229: LD_ADDR_VAR 0 1
103233: PUSH
103234: LD_INT 22
103236: PUSH
103237: LD_OWVAR 2
103241: PUSH
103242: EMPTY
103243: LIST
103244: LIST
103245: PUSH
103246: LD_INT 30
103248: PUSH
103249: LD_INT 3
103251: PUSH
103252: EMPTY
103253: LIST
103254: LIST
103255: PUSH
103256: EMPTY
103257: LIST
103258: LIST
103259: PPUSH
103260: CALL_OW 69
103264: ST_TO_ADDR
// if not tmp then
103265: LD_VAR 0 1
103269: NOT
103270: IFFALSE 103274
// exit ;
103272: GO 103300
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103274: LD_VAR 0 1
103278: PUSH
103279: LD_INT 1
103281: PPUSH
103282: LD_VAR 0 1
103286: PPUSH
103287: CALL_OW 12
103291: ARRAY
103292: PPUSH
103293: LD_INT 1
103295: PPUSH
103296: CALL_OW 234
// end ;
103300: PPOPN 1
103302: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103303: LD_EXP 109
103307: IFFALSE 103315
103309: PUSH
103310: LD_EXP 157
103314: AND
103315: IFFALSE 103427
103317: GO 103319
103319: DISABLE
103320: LD_INT 0
103322: PPUSH
103323: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103324: LD_ADDR_VAR 0 2
103328: PUSH
103329: LD_INT 22
103331: PUSH
103332: LD_OWVAR 2
103336: PUSH
103337: EMPTY
103338: LIST
103339: LIST
103340: PUSH
103341: LD_INT 2
103343: PUSH
103344: LD_INT 30
103346: PUSH
103347: LD_INT 27
103349: PUSH
103350: EMPTY
103351: LIST
103352: LIST
103353: PUSH
103354: LD_INT 30
103356: PUSH
103357: LD_INT 26
103359: PUSH
103360: EMPTY
103361: LIST
103362: LIST
103363: PUSH
103364: LD_INT 30
103366: PUSH
103367: LD_INT 28
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PUSH
103374: EMPTY
103375: LIST
103376: LIST
103377: LIST
103378: LIST
103379: PUSH
103380: EMPTY
103381: LIST
103382: LIST
103383: PPUSH
103384: CALL_OW 69
103388: ST_TO_ADDR
// if not tmp then
103389: LD_VAR 0 2
103393: NOT
103394: IFFALSE 103398
// exit ;
103396: GO 103427
// for i in tmp do
103398: LD_ADDR_VAR 0 1
103402: PUSH
103403: LD_VAR 0 2
103407: PUSH
103408: FOR_IN
103409: IFFALSE 103425
// SetLives ( i , 1 ) ;
103411: LD_VAR 0 1
103415: PPUSH
103416: LD_INT 1
103418: PPUSH
103419: CALL_OW 234
103423: GO 103408
103425: POP
103426: POP
// end ;
103427: PPOPN 2
103429: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103430: LD_EXP 109
103434: IFFALSE 103442
103436: PUSH
103437: LD_EXP 158
103441: AND
103442: IFFALSE 103729
103444: GO 103446
103446: DISABLE
103447: LD_INT 0
103449: PPUSH
103450: PPUSH
103451: PPUSH
// begin i := rand ( 1 , 7 ) ;
103452: LD_ADDR_VAR 0 1
103456: PUSH
103457: LD_INT 1
103459: PPUSH
103460: LD_INT 7
103462: PPUSH
103463: CALL_OW 12
103467: ST_TO_ADDR
// case i of 1 :
103468: LD_VAR 0 1
103472: PUSH
103473: LD_INT 1
103475: DOUBLE
103476: EQUAL
103477: IFTRUE 103481
103479: GO 103491
103481: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103482: LD_STRING earthquake(getX(game), 0, 32)
103484: PPUSH
103485: CALL_OW 559
103489: GO 103729
103491: LD_INT 2
103493: DOUBLE
103494: EQUAL
103495: IFTRUE 103499
103497: GO 103513
103499: POP
// begin ToLua ( displayStucuk(); ) ;
103500: LD_STRING displayStucuk();
103502: PPUSH
103503: CALL_OW 559
// ResetFog ;
103507: CALL_OW 335
// end ; 3 :
103511: GO 103729
103513: LD_INT 3
103515: DOUBLE
103516: EQUAL
103517: IFTRUE 103521
103519: GO 103625
103521: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103522: LD_ADDR_VAR 0 2
103526: PUSH
103527: LD_INT 22
103529: PUSH
103530: LD_OWVAR 2
103534: PUSH
103535: EMPTY
103536: LIST
103537: LIST
103538: PUSH
103539: LD_INT 25
103541: PUSH
103542: LD_INT 1
103544: PUSH
103545: EMPTY
103546: LIST
103547: LIST
103548: PUSH
103549: EMPTY
103550: LIST
103551: LIST
103552: PPUSH
103553: CALL_OW 69
103557: ST_TO_ADDR
// if not tmp then
103558: LD_VAR 0 2
103562: NOT
103563: IFFALSE 103567
// exit ;
103565: GO 103729
// un := tmp [ rand ( 1 , tmp ) ] ;
103567: LD_ADDR_VAR 0 3
103571: PUSH
103572: LD_VAR 0 2
103576: PUSH
103577: LD_INT 1
103579: PPUSH
103580: LD_VAR 0 2
103584: PPUSH
103585: CALL_OW 12
103589: ARRAY
103590: ST_TO_ADDR
// if Crawls ( un ) then
103591: LD_VAR 0 3
103595: PPUSH
103596: CALL_OW 318
103600: IFFALSE 103611
// ComWalk ( un ) ;
103602: LD_VAR 0 3
103606: PPUSH
103607: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103611: LD_VAR 0 3
103615: PPUSH
103616: LD_INT 8
103618: PPUSH
103619: CALL_OW 336
// end ; 4 :
103623: GO 103729
103625: LD_INT 4
103627: DOUBLE
103628: EQUAL
103629: IFTRUE 103633
103631: GO 103707
103633: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103634: LD_ADDR_VAR 0 2
103638: PUSH
103639: LD_INT 22
103641: PUSH
103642: LD_OWVAR 2
103646: PUSH
103647: EMPTY
103648: LIST
103649: LIST
103650: PUSH
103651: LD_INT 30
103653: PUSH
103654: LD_INT 29
103656: PUSH
103657: EMPTY
103658: LIST
103659: LIST
103660: PUSH
103661: EMPTY
103662: LIST
103663: LIST
103664: PPUSH
103665: CALL_OW 69
103669: ST_TO_ADDR
// if not tmp then
103670: LD_VAR 0 2
103674: NOT
103675: IFFALSE 103679
// exit ;
103677: GO 103729
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103679: LD_VAR 0 2
103683: PUSH
103684: LD_INT 1
103686: ARRAY
103687: PPUSH
103688: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103692: LD_VAR 0 2
103696: PUSH
103697: LD_INT 1
103699: ARRAY
103700: PPUSH
103701: CALL_OW 65
// end ; 5 .. 7 :
103705: GO 103729
103707: LD_INT 5
103709: DOUBLE
103710: GREATEREQUAL
103711: IFFALSE 103719
103713: LD_INT 7
103715: DOUBLE
103716: LESSEQUAL
103717: IFTRUE 103721
103719: GO 103728
103721: POP
// StreamSibBomb ; end ;
103722: CALL 99910 0 0
103726: GO 103729
103728: POP
// end ;
103729: PPOPN 3
103731: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103732: LD_EXP 109
103736: IFFALSE 103744
103738: PUSH
103739: LD_EXP 159
103743: AND
103744: IFFALSE 103900
103746: GO 103748
103748: DISABLE
103749: LD_INT 0
103751: PPUSH
103752: PPUSH
103753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103754: LD_ADDR_VAR 0 2
103758: PUSH
103759: LD_INT 81
103761: PUSH
103762: LD_OWVAR 2
103766: PUSH
103767: EMPTY
103768: LIST
103769: LIST
103770: PUSH
103771: LD_INT 2
103773: PUSH
103774: LD_INT 21
103776: PUSH
103777: LD_INT 1
103779: PUSH
103780: EMPTY
103781: LIST
103782: LIST
103783: PUSH
103784: LD_INT 21
103786: PUSH
103787: LD_INT 2
103789: PUSH
103790: EMPTY
103791: LIST
103792: LIST
103793: PUSH
103794: EMPTY
103795: LIST
103796: LIST
103797: LIST
103798: PUSH
103799: EMPTY
103800: LIST
103801: LIST
103802: PPUSH
103803: CALL_OW 69
103807: ST_TO_ADDR
// if not tmp then
103808: LD_VAR 0 2
103812: NOT
103813: IFFALSE 103817
// exit ;
103815: GO 103900
// p := 0 ;
103817: LD_ADDR_VAR 0 3
103821: PUSH
103822: LD_INT 0
103824: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103825: LD_INT 35
103827: PPUSH
103828: CALL_OW 67
// p := p + 1 ;
103832: LD_ADDR_VAR 0 3
103836: PUSH
103837: LD_VAR 0 3
103841: PUSH
103842: LD_INT 1
103844: PLUS
103845: ST_TO_ADDR
// for i in tmp do
103846: LD_ADDR_VAR 0 1
103850: PUSH
103851: LD_VAR 0 2
103855: PUSH
103856: FOR_IN
103857: IFFALSE 103888
// if GetLives ( i ) < 1000 then
103859: LD_VAR 0 1
103863: PPUSH
103864: CALL_OW 256
103868: PUSH
103869: LD_INT 1000
103871: LESS
103872: IFFALSE 103886
// SetLives ( i , 1000 ) ;
103874: LD_VAR 0 1
103878: PPUSH
103879: LD_INT 1000
103881: PPUSH
103882: CALL_OW 234
103886: GO 103856
103888: POP
103889: POP
// until p > 20 ;
103890: LD_VAR 0 3
103894: PUSH
103895: LD_INT 20
103897: GREATER
103898: IFFALSE 103825
// end ;
103900: PPOPN 3
103902: END
// every 0 0$1 trigger StreamModeActive and sTime do
103903: LD_EXP 109
103907: IFFALSE 103915
103909: PUSH
103910: LD_EXP 160
103914: AND
103915: IFFALSE 103950
103917: GO 103919
103919: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103920: LD_INT 28
103922: PPUSH
103923: LD_OWVAR 2
103927: PPUSH
103928: LD_INT 2
103930: PPUSH
103931: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103935: LD_INT 30
103937: PPUSH
103938: LD_OWVAR 2
103942: PPUSH
103943: LD_INT 2
103945: PPUSH
103946: CALL_OW 322
// end ;
103950: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103951: LD_EXP 109
103955: IFFALSE 103963
103957: PUSH
103958: LD_EXP 161
103962: AND
103963: IFFALSE 104084
103965: GO 103967
103967: DISABLE
103968: LD_INT 0
103970: PPUSH
103971: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103972: LD_ADDR_VAR 0 2
103976: PUSH
103977: LD_INT 22
103979: PUSH
103980: LD_OWVAR 2
103984: PUSH
103985: EMPTY
103986: LIST
103987: LIST
103988: PUSH
103989: LD_INT 21
103991: PUSH
103992: LD_INT 1
103994: PUSH
103995: EMPTY
103996: LIST
103997: LIST
103998: PUSH
103999: LD_INT 3
104001: PUSH
104002: LD_INT 23
104004: PUSH
104005: LD_INT 0
104007: PUSH
104008: EMPTY
104009: LIST
104010: LIST
104011: PUSH
104012: EMPTY
104013: LIST
104014: LIST
104015: PUSH
104016: EMPTY
104017: LIST
104018: LIST
104019: LIST
104020: PPUSH
104021: CALL_OW 69
104025: ST_TO_ADDR
// if not tmp then
104026: LD_VAR 0 2
104030: NOT
104031: IFFALSE 104035
// exit ;
104033: GO 104084
// for i in tmp do
104035: LD_ADDR_VAR 0 1
104039: PUSH
104040: LD_VAR 0 2
104044: PUSH
104045: FOR_IN
104046: IFFALSE 104082
// begin if Crawls ( i ) then
104048: LD_VAR 0 1
104052: PPUSH
104053: CALL_OW 318
104057: IFFALSE 104068
// ComWalk ( i ) ;
104059: LD_VAR 0 1
104063: PPUSH
104064: CALL_OW 138
// SetClass ( i , 2 ) ;
104068: LD_VAR 0 1
104072: PPUSH
104073: LD_INT 2
104075: PPUSH
104076: CALL_OW 336
// end ;
104080: GO 104045
104082: POP
104083: POP
// end ;
104084: PPOPN 2
104086: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104087: LD_EXP 109
104091: IFFALSE 104099
104093: PUSH
104094: LD_EXP 162
104098: AND
104099: IFFALSE 104389
104101: GO 104103
104103: DISABLE
104104: LD_INT 0
104106: PPUSH
104107: PPUSH
104108: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104109: LD_OWVAR 2
104113: PPUSH
104114: LD_INT 9
104116: PPUSH
104117: LD_INT 1
104119: PPUSH
104120: LD_INT 1
104122: PPUSH
104123: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104127: LD_INT 9
104129: PPUSH
104130: LD_OWVAR 2
104134: PPUSH
104135: CALL_OW 343
// uc_side := 9 ;
104139: LD_ADDR_OWVAR 20
104143: PUSH
104144: LD_INT 9
104146: ST_TO_ADDR
// uc_nation := 2 ;
104147: LD_ADDR_OWVAR 21
104151: PUSH
104152: LD_INT 2
104154: ST_TO_ADDR
// hc_name := Dark Warrior ;
104155: LD_ADDR_OWVAR 26
104159: PUSH
104160: LD_STRING Dark Warrior
104162: ST_TO_ADDR
// hc_gallery :=  ;
104163: LD_ADDR_OWVAR 33
104167: PUSH
104168: LD_STRING 
104170: ST_TO_ADDR
// hc_noskilllimit := true ;
104171: LD_ADDR_OWVAR 76
104175: PUSH
104176: LD_INT 1
104178: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104179: LD_ADDR_OWVAR 31
104183: PUSH
104184: LD_INT 30
104186: PUSH
104187: LD_INT 30
104189: PUSH
104190: LD_INT 30
104192: PUSH
104193: LD_INT 30
104195: PUSH
104196: EMPTY
104197: LIST
104198: LIST
104199: LIST
104200: LIST
104201: ST_TO_ADDR
// un := CreateHuman ;
104202: LD_ADDR_VAR 0 3
104206: PUSH
104207: CALL_OW 44
104211: ST_TO_ADDR
// hc_noskilllimit := false ;
104212: LD_ADDR_OWVAR 76
104216: PUSH
104217: LD_INT 0
104219: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104220: LD_VAR 0 3
104224: PPUSH
104225: LD_INT 1
104227: PPUSH
104228: CALL_OW 51
// ToLua ( playRanger() ) ;
104232: LD_STRING playRanger()
104234: PPUSH
104235: CALL_OW 559
// p := 0 ;
104239: LD_ADDR_VAR 0 2
104243: PUSH
104244: LD_INT 0
104246: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104247: LD_INT 35
104249: PPUSH
104250: CALL_OW 67
// p := p + 1 ;
104254: LD_ADDR_VAR 0 2
104258: PUSH
104259: LD_VAR 0 2
104263: PUSH
104264: LD_INT 1
104266: PLUS
104267: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104268: LD_VAR 0 3
104272: PPUSH
104273: CALL_OW 256
104277: PUSH
104278: LD_INT 1000
104280: LESS
104281: IFFALSE 104295
// SetLives ( un , 1000 ) ;
104283: LD_VAR 0 3
104287: PPUSH
104288: LD_INT 1000
104290: PPUSH
104291: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104295: LD_VAR 0 3
104299: PPUSH
104300: LD_INT 81
104302: PUSH
104303: LD_OWVAR 2
104307: PUSH
104308: EMPTY
104309: LIST
104310: LIST
104311: PUSH
104312: LD_INT 91
104314: PUSH
104315: LD_VAR 0 3
104319: PUSH
104320: LD_INT 30
104322: PUSH
104323: EMPTY
104324: LIST
104325: LIST
104326: LIST
104327: PUSH
104328: EMPTY
104329: LIST
104330: LIST
104331: PPUSH
104332: CALL_OW 69
104336: PPUSH
104337: LD_VAR 0 3
104341: PPUSH
104342: CALL_OW 74
104346: PPUSH
104347: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104351: LD_VAR 0 2
104355: PUSH
104356: LD_INT 80
104358: GREATER
104359: IFTRUE 104372
104361: PUSH
104362: LD_VAR 0 3
104366: PPUSH
104367: CALL_OW 301
104371: OR
104372: IFFALSE 104247
// if un then
104374: LD_VAR 0 3
104378: IFFALSE 104389
// RemoveUnit ( un ) ;
104380: LD_VAR 0 3
104384: PPUSH
104385: CALL_OW 64
// end ;
104389: PPOPN 3
104391: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104392: LD_EXP 163
104396: IFFALSE 104512
104398: GO 104400
104400: DISABLE
104401: LD_INT 0
104403: PPUSH
104404: PPUSH
104405: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104406: LD_ADDR_VAR 0 2
104410: PUSH
104411: LD_INT 81
104413: PUSH
104414: LD_OWVAR 2
104418: PUSH
104419: EMPTY
104420: LIST
104421: LIST
104422: PUSH
104423: LD_INT 21
104425: PUSH
104426: LD_INT 1
104428: PUSH
104429: EMPTY
104430: LIST
104431: LIST
104432: PUSH
104433: EMPTY
104434: LIST
104435: LIST
104436: PPUSH
104437: CALL_OW 69
104441: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104442: LD_STRING playComputer()
104444: PPUSH
104445: CALL_OW 559
// if not tmp then
104449: LD_VAR 0 2
104453: NOT
104454: IFFALSE 104458
// exit ;
104456: GO 104512
// for i in tmp do
104458: LD_ADDR_VAR 0 1
104462: PUSH
104463: LD_VAR 0 2
104467: PUSH
104468: FOR_IN
104469: IFFALSE 104510
// for j := 1 to 4 do
104471: LD_ADDR_VAR 0 3
104475: PUSH
104476: DOUBLE
104477: LD_INT 1
104479: DEC
104480: ST_TO_ADDR
104481: LD_INT 4
104483: PUSH
104484: FOR_TO
104485: IFFALSE 104506
// SetSkill ( i , j , 10 ) ;
104487: LD_VAR 0 1
104491: PPUSH
104492: LD_VAR 0 3
104496: PPUSH
104497: LD_INT 10
104499: PPUSH
104500: CALL_OW 237
104504: GO 104484
104506: POP
104507: POP
104508: GO 104468
104510: POP
104511: POP
// end ;
104512: PPOPN 3
104514: END
// every 0 0$1 trigger s30 do var i , tmp ;
104515: LD_EXP 164
104519: IFFALSE 104588
104521: GO 104523
104523: DISABLE
104524: LD_INT 0
104526: PPUSH
104527: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104528: LD_ADDR_VAR 0 2
104532: PUSH
104533: LD_INT 22
104535: PUSH
104536: LD_OWVAR 2
104540: PUSH
104541: EMPTY
104542: LIST
104543: LIST
104544: PPUSH
104545: CALL_OW 69
104549: ST_TO_ADDR
// if not tmp then
104550: LD_VAR 0 2
104554: NOT
104555: IFFALSE 104559
// exit ;
104557: GO 104588
// for i in tmp do
104559: LD_ADDR_VAR 0 1
104563: PUSH
104564: LD_VAR 0 2
104568: PUSH
104569: FOR_IN
104570: IFFALSE 104586
// SetLives ( i , 300 ) ;
104572: LD_VAR 0 1
104576: PPUSH
104577: LD_INT 300
104579: PPUSH
104580: CALL_OW 234
104584: GO 104569
104586: POP
104587: POP
// end ;
104588: PPOPN 2
104590: END
// every 0 0$1 trigger s60 do var i , tmp ;
104591: LD_EXP 165
104595: IFFALSE 104664
104597: GO 104599
104599: DISABLE
104600: LD_INT 0
104602: PPUSH
104603: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104604: LD_ADDR_VAR 0 2
104608: PUSH
104609: LD_INT 22
104611: PUSH
104612: LD_OWVAR 2
104616: PUSH
104617: EMPTY
104618: LIST
104619: LIST
104620: PPUSH
104621: CALL_OW 69
104625: ST_TO_ADDR
// if not tmp then
104626: LD_VAR 0 2
104630: NOT
104631: IFFALSE 104635
// exit ;
104633: GO 104664
// for i in tmp do
104635: LD_ADDR_VAR 0 1
104639: PUSH
104640: LD_VAR 0 2
104644: PUSH
104645: FOR_IN
104646: IFFALSE 104662
// SetLives ( i , 600 ) ;
104648: LD_VAR 0 1
104652: PPUSH
104653: LD_INT 600
104655: PPUSH
104656: CALL_OW 234
104660: GO 104645
104662: POP
104663: POP
// end ;
104664: PPOPN 2
104666: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104667: LD_INT 0
104669: PPUSH
// case cmd of 301 :
104670: LD_VAR 0 1
104674: PUSH
104675: LD_INT 301
104677: DOUBLE
104678: EQUAL
104679: IFTRUE 104683
104681: GO 104715
104683: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104684: LD_VAR 0 6
104688: PPUSH
104689: LD_VAR 0 7
104693: PPUSH
104694: LD_VAR 0 8
104698: PPUSH
104699: LD_VAR 0 4
104703: PPUSH
104704: LD_VAR 0 5
104708: PPUSH
104709: CALL 105928 0 5
104713: GO 104836
104715: LD_INT 302
104717: DOUBLE
104718: EQUAL
104719: IFTRUE 104723
104721: GO 104760
104723: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104724: LD_VAR 0 6
104728: PPUSH
104729: LD_VAR 0 7
104733: PPUSH
104734: LD_VAR 0 8
104738: PPUSH
104739: LD_VAR 0 9
104743: PPUSH
104744: LD_VAR 0 4
104748: PPUSH
104749: LD_VAR 0 5
104753: PPUSH
104754: CALL 106019 0 6
104758: GO 104836
104760: LD_INT 303
104762: DOUBLE
104763: EQUAL
104764: IFTRUE 104768
104766: GO 104805
104768: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104769: LD_VAR 0 6
104773: PPUSH
104774: LD_VAR 0 7
104778: PPUSH
104779: LD_VAR 0 8
104783: PPUSH
104784: LD_VAR 0 9
104788: PPUSH
104789: LD_VAR 0 4
104793: PPUSH
104794: LD_VAR 0 5
104798: PPUSH
104799: CALL 104841 0 6
104803: GO 104836
104805: LD_INT 304
104807: DOUBLE
104808: EQUAL
104809: IFTRUE 104813
104811: GO 104835
104813: POP
// hHackTeleport ( unit , x , y ) ; end ;
104814: LD_VAR 0 2
104818: PPUSH
104819: LD_VAR 0 4
104823: PPUSH
104824: LD_VAR 0 5
104828: PPUSH
104829: CALL 106612 0 3
104833: GO 104836
104835: POP
// end ;
104836: LD_VAR 0 12
104840: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104841: LD_INT 0
104843: PPUSH
104844: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104845: LD_VAR 0 1
104849: PUSH
104850: LD_INT 1
104852: LESS
104853: IFTRUE 104865
104855: PUSH
104856: LD_VAR 0 1
104860: PUSH
104861: LD_INT 3
104863: GREATER
104864: OR
104865: IFTRUE 104883
104867: PUSH
104868: LD_VAR 0 5
104872: PPUSH
104873: LD_VAR 0 6
104877: PPUSH
104878: CALL_OW 428
104882: OR
104883: IFFALSE 104887
// exit ;
104885: GO 105615
// uc_side := your_side ;
104887: LD_ADDR_OWVAR 20
104891: PUSH
104892: LD_OWVAR 2
104896: ST_TO_ADDR
// uc_nation := nation ;
104897: LD_ADDR_OWVAR 21
104901: PUSH
104902: LD_VAR 0 1
104906: ST_TO_ADDR
// bc_level = 1 ;
104907: LD_ADDR_OWVAR 43
104911: PUSH
104912: LD_INT 1
104914: ST_TO_ADDR
// case btype of 1 :
104915: LD_VAR 0 2
104919: PUSH
104920: LD_INT 1
104922: DOUBLE
104923: EQUAL
104924: IFTRUE 104928
104926: GO 104939
104928: POP
// bc_type := b_depot ; 2 :
104929: LD_ADDR_OWVAR 42
104933: PUSH
104934: LD_INT 0
104936: ST_TO_ADDR
104937: GO 105559
104939: LD_INT 2
104941: DOUBLE
104942: EQUAL
104943: IFTRUE 104947
104945: GO 104958
104947: POP
// bc_type := b_warehouse ; 3 :
104948: LD_ADDR_OWVAR 42
104952: PUSH
104953: LD_INT 1
104955: ST_TO_ADDR
104956: GO 105559
104958: LD_INT 3
104960: DOUBLE
104961: EQUAL
104962: IFTRUE 104966
104964: GO 104977
104966: POP
// bc_type := b_lab ; 4 .. 9 :
104967: LD_ADDR_OWVAR 42
104971: PUSH
104972: LD_INT 6
104974: ST_TO_ADDR
104975: GO 105559
104977: LD_INT 4
104979: DOUBLE
104980: GREATEREQUAL
104981: IFFALSE 104989
104983: LD_INT 9
104985: DOUBLE
104986: LESSEQUAL
104987: IFTRUE 104991
104989: GO 105051
104991: POP
// begin bc_type := b_lab_half ;
104992: LD_ADDR_OWVAR 42
104996: PUSH
104997: LD_INT 7
104999: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
105000: LD_ADDR_OWVAR 44
105004: PUSH
105005: LD_INT 10
105007: PUSH
105008: LD_INT 11
105010: PUSH
105011: LD_INT 12
105013: PUSH
105014: LD_INT 15
105016: PUSH
105017: LD_INT 14
105019: PUSH
105020: LD_INT 13
105022: PUSH
105023: EMPTY
105024: LIST
105025: LIST
105026: LIST
105027: LIST
105028: LIST
105029: LIST
105030: PUSH
105031: LD_VAR 0 2
105035: PUSH
105036: LD_INT 3
105038: MINUS
105039: ARRAY
105040: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
105041: LD_ADDR_OWVAR 45
105045: PUSH
105046: LD_INT 9
105048: ST_TO_ADDR
// end ; 10 .. 13 :
105049: GO 105559
105051: LD_INT 10
105053: DOUBLE
105054: GREATEREQUAL
105055: IFFALSE 105063
105057: LD_INT 13
105059: DOUBLE
105060: LESSEQUAL
105061: IFTRUE 105065
105063: GO 105142
105065: POP
// begin bc_type := b_lab_full ;
105066: LD_ADDR_OWVAR 42
105070: PUSH
105071: LD_INT 8
105073: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105074: LD_ADDR_OWVAR 44
105078: PUSH
105079: LD_INT 10
105081: PUSH
105082: LD_INT 12
105084: PUSH
105085: LD_INT 14
105087: PUSH
105088: LD_INT 13
105090: PUSH
105091: EMPTY
105092: LIST
105093: LIST
105094: LIST
105095: LIST
105096: PUSH
105097: LD_VAR 0 2
105101: PUSH
105102: LD_INT 9
105104: MINUS
105105: ARRAY
105106: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105107: LD_ADDR_OWVAR 45
105111: PUSH
105112: LD_INT 11
105114: PUSH
105115: LD_INT 15
105117: PUSH
105118: LD_INT 12
105120: PUSH
105121: LD_INT 15
105123: PUSH
105124: EMPTY
105125: LIST
105126: LIST
105127: LIST
105128: LIST
105129: PUSH
105130: LD_VAR 0 2
105134: PUSH
105135: LD_INT 9
105137: MINUS
105138: ARRAY
105139: ST_TO_ADDR
// end ; 14 :
105140: GO 105559
105142: LD_INT 14
105144: DOUBLE
105145: EQUAL
105146: IFTRUE 105150
105148: GO 105161
105150: POP
// bc_type := b_workshop ; 15 :
105151: LD_ADDR_OWVAR 42
105155: PUSH
105156: LD_INT 2
105158: ST_TO_ADDR
105159: GO 105559
105161: LD_INT 15
105163: DOUBLE
105164: EQUAL
105165: IFTRUE 105169
105167: GO 105180
105169: POP
// bc_type := b_factory ; 16 :
105170: LD_ADDR_OWVAR 42
105174: PUSH
105175: LD_INT 3
105177: ST_TO_ADDR
105178: GO 105559
105180: LD_INT 16
105182: DOUBLE
105183: EQUAL
105184: IFTRUE 105188
105186: GO 105199
105188: POP
// bc_type := b_ext_gun ; 17 :
105189: LD_ADDR_OWVAR 42
105193: PUSH
105194: LD_INT 17
105196: ST_TO_ADDR
105197: GO 105559
105199: LD_INT 17
105201: DOUBLE
105202: EQUAL
105203: IFTRUE 105207
105205: GO 105235
105207: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105208: LD_ADDR_OWVAR 42
105212: PUSH
105213: LD_INT 19
105215: PUSH
105216: LD_INT 23
105218: PUSH
105219: LD_INT 19
105221: PUSH
105222: EMPTY
105223: LIST
105224: LIST
105225: LIST
105226: PUSH
105227: LD_VAR 0 1
105231: ARRAY
105232: ST_TO_ADDR
105233: GO 105559
105235: LD_INT 18
105237: DOUBLE
105238: EQUAL
105239: IFTRUE 105243
105241: GO 105254
105243: POP
// bc_type := b_ext_radar ; 19 :
105244: LD_ADDR_OWVAR 42
105248: PUSH
105249: LD_INT 20
105251: ST_TO_ADDR
105252: GO 105559
105254: LD_INT 19
105256: DOUBLE
105257: EQUAL
105258: IFTRUE 105262
105260: GO 105273
105262: POP
// bc_type := b_ext_radio ; 20 :
105263: LD_ADDR_OWVAR 42
105267: PUSH
105268: LD_INT 22
105270: ST_TO_ADDR
105271: GO 105559
105273: LD_INT 20
105275: DOUBLE
105276: EQUAL
105277: IFTRUE 105281
105279: GO 105292
105281: POP
// bc_type := b_ext_siberium ; 21 :
105282: LD_ADDR_OWVAR 42
105286: PUSH
105287: LD_INT 21
105289: ST_TO_ADDR
105290: GO 105559
105292: LD_INT 21
105294: DOUBLE
105295: EQUAL
105296: IFTRUE 105300
105298: GO 105311
105300: POP
// bc_type := b_ext_computer ; 22 :
105301: LD_ADDR_OWVAR 42
105305: PUSH
105306: LD_INT 24
105308: ST_TO_ADDR
105309: GO 105559
105311: LD_INT 22
105313: DOUBLE
105314: EQUAL
105315: IFTRUE 105319
105317: GO 105330
105319: POP
// bc_type := b_ext_track ; 23 :
105320: LD_ADDR_OWVAR 42
105324: PUSH
105325: LD_INT 16
105327: ST_TO_ADDR
105328: GO 105559
105330: LD_INT 23
105332: DOUBLE
105333: EQUAL
105334: IFTRUE 105338
105336: GO 105349
105338: POP
// bc_type := b_ext_laser ; 24 :
105339: LD_ADDR_OWVAR 42
105343: PUSH
105344: LD_INT 25
105346: ST_TO_ADDR
105347: GO 105559
105349: LD_INT 24
105351: DOUBLE
105352: EQUAL
105353: IFTRUE 105357
105355: GO 105368
105357: POP
// bc_type := b_control_tower ; 25 :
105358: LD_ADDR_OWVAR 42
105362: PUSH
105363: LD_INT 36
105365: ST_TO_ADDR
105366: GO 105559
105368: LD_INT 25
105370: DOUBLE
105371: EQUAL
105372: IFTRUE 105376
105374: GO 105387
105376: POP
// bc_type := b_breastwork ; 26 :
105377: LD_ADDR_OWVAR 42
105381: PUSH
105382: LD_INT 31
105384: ST_TO_ADDR
105385: GO 105559
105387: LD_INT 26
105389: DOUBLE
105390: EQUAL
105391: IFTRUE 105395
105393: GO 105406
105395: POP
// bc_type := b_bunker ; 27 :
105396: LD_ADDR_OWVAR 42
105400: PUSH
105401: LD_INT 32
105403: ST_TO_ADDR
105404: GO 105559
105406: LD_INT 27
105408: DOUBLE
105409: EQUAL
105410: IFTRUE 105414
105412: GO 105425
105414: POP
// bc_type := b_turret ; 28 :
105415: LD_ADDR_OWVAR 42
105419: PUSH
105420: LD_INT 33
105422: ST_TO_ADDR
105423: GO 105559
105425: LD_INT 28
105427: DOUBLE
105428: EQUAL
105429: IFTRUE 105433
105431: GO 105444
105433: POP
// bc_type := b_armoury ; 29 :
105434: LD_ADDR_OWVAR 42
105438: PUSH
105439: LD_INT 4
105441: ST_TO_ADDR
105442: GO 105559
105444: LD_INT 29
105446: DOUBLE
105447: EQUAL
105448: IFTRUE 105452
105450: GO 105463
105452: POP
// bc_type := b_barracks ; 30 :
105453: LD_ADDR_OWVAR 42
105457: PUSH
105458: LD_INT 5
105460: ST_TO_ADDR
105461: GO 105559
105463: LD_INT 30
105465: DOUBLE
105466: EQUAL
105467: IFTRUE 105471
105469: GO 105482
105471: POP
// bc_type := b_solar_power ; 31 :
105472: LD_ADDR_OWVAR 42
105476: PUSH
105477: LD_INT 27
105479: ST_TO_ADDR
105480: GO 105559
105482: LD_INT 31
105484: DOUBLE
105485: EQUAL
105486: IFTRUE 105490
105488: GO 105501
105490: POP
// bc_type := b_oil_power ; 32 :
105491: LD_ADDR_OWVAR 42
105495: PUSH
105496: LD_INT 26
105498: ST_TO_ADDR
105499: GO 105559
105501: LD_INT 32
105503: DOUBLE
105504: EQUAL
105505: IFTRUE 105509
105507: GO 105520
105509: POP
// bc_type := b_siberite_power ; 33 :
105510: LD_ADDR_OWVAR 42
105514: PUSH
105515: LD_INT 28
105517: ST_TO_ADDR
105518: GO 105559
105520: LD_INT 33
105522: DOUBLE
105523: EQUAL
105524: IFTRUE 105528
105526: GO 105539
105528: POP
// bc_type := b_oil_mine ; 34 :
105529: LD_ADDR_OWVAR 42
105533: PUSH
105534: LD_INT 29
105536: ST_TO_ADDR
105537: GO 105559
105539: LD_INT 34
105541: DOUBLE
105542: EQUAL
105543: IFTRUE 105547
105545: GO 105558
105547: POP
// bc_type := b_siberite_mine ; end ;
105548: LD_ADDR_OWVAR 42
105552: PUSH
105553: LD_INT 30
105555: ST_TO_ADDR
105556: GO 105559
105558: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105559: LD_ADDR_VAR 0 8
105563: PUSH
105564: LD_VAR 0 5
105568: PPUSH
105569: LD_VAR 0 6
105573: PPUSH
105574: LD_VAR 0 3
105578: PPUSH
105579: CALL_OW 47
105583: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105584: LD_OWVAR 42
105588: PUSH
105589: LD_INT 32
105591: PUSH
105592: LD_INT 33
105594: PUSH
105595: EMPTY
105596: LIST
105597: LIST
105598: IN
105599: IFFALSE 105615
// PlaceWeaponTurret ( b , weapon ) ;
105601: LD_VAR 0 8
105605: PPUSH
105606: LD_VAR 0 4
105610: PPUSH
105611: CALL_OW 431
// end ;
105615: LD_VAR 0 7
105619: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105620: LD_INT 0
105622: PPUSH
105623: PPUSH
105624: PPUSH
105625: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105626: LD_ADDR_VAR 0 4
105630: PUSH
105631: LD_INT 22
105633: PUSH
105634: LD_OWVAR 2
105638: PUSH
105639: EMPTY
105640: LIST
105641: LIST
105642: PUSH
105643: LD_INT 2
105645: PUSH
105646: LD_INT 30
105648: PUSH
105649: LD_INT 0
105651: PUSH
105652: EMPTY
105653: LIST
105654: LIST
105655: PUSH
105656: LD_INT 30
105658: PUSH
105659: LD_INT 1
105661: PUSH
105662: EMPTY
105663: LIST
105664: LIST
105665: PUSH
105666: EMPTY
105667: LIST
105668: LIST
105669: LIST
105670: PUSH
105671: EMPTY
105672: LIST
105673: LIST
105674: PPUSH
105675: CALL_OW 69
105679: ST_TO_ADDR
// if not tmp then
105680: LD_VAR 0 4
105684: NOT
105685: IFFALSE 105689
// exit ;
105687: GO 105748
// for i in tmp do
105689: LD_ADDR_VAR 0 2
105693: PUSH
105694: LD_VAR 0 4
105698: PUSH
105699: FOR_IN
105700: IFFALSE 105746
// for j = 1 to 3 do
105702: LD_ADDR_VAR 0 3
105706: PUSH
105707: DOUBLE
105708: LD_INT 1
105710: DEC
105711: ST_TO_ADDR
105712: LD_INT 3
105714: PUSH
105715: FOR_TO
105716: IFFALSE 105742
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105718: LD_VAR 0 2
105722: PPUSH
105723: CALL_OW 274
105727: PPUSH
105728: LD_VAR 0 3
105732: PPUSH
105733: LD_INT 99999
105735: PPUSH
105736: CALL_OW 277
105740: GO 105715
105742: POP
105743: POP
105744: GO 105699
105746: POP
105747: POP
// end ;
105748: LD_VAR 0 1
105752: RET
// export function hHackSetLevel10 ; var i , j ; begin
105753: LD_INT 0
105755: PPUSH
105756: PPUSH
105757: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105758: LD_ADDR_VAR 0 2
105762: PUSH
105763: LD_INT 21
105765: PUSH
105766: LD_INT 1
105768: PUSH
105769: EMPTY
105770: LIST
105771: LIST
105772: PPUSH
105773: CALL_OW 69
105777: PUSH
105778: FOR_IN
105779: IFFALSE 105831
// if IsSelected ( i ) then
105781: LD_VAR 0 2
105785: PPUSH
105786: CALL_OW 306
105790: IFFALSE 105829
// begin for j := 1 to 4 do
105792: LD_ADDR_VAR 0 3
105796: PUSH
105797: DOUBLE
105798: LD_INT 1
105800: DEC
105801: ST_TO_ADDR
105802: LD_INT 4
105804: PUSH
105805: FOR_TO
105806: IFFALSE 105827
// SetSkill ( i , j , 10 ) ;
105808: LD_VAR 0 2
105812: PPUSH
105813: LD_VAR 0 3
105817: PPUSH
105818: LD_INT 10
105820: PPUSH
105821: CALL_OW 237
105825: GO 105805
105827: POP
105828: POP
// end ;
105829: GO 105778
105831: POP
105832: POP
// end ;
105833: LD_VAR 0 1
105837: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105838: LD_INT 0
105840: PPUSH
105841: PPUSH
105842: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105843: LD_ADDR_VAR 0 2
105847: PUSH
105848: LD_INT 22
105850: PUSH
105851: LD_OWVAR 2
105855: PUSH
105856: EMPTY
105857: LIST
105858: LIST
105859: PUSH
105860: LD_INT 21
105862: PUSH
105863: LD_INT 1
105865: PUSH
105866: EMPTY
105867: LIST
105868: LIST
105869: PUSH
105870: EMPTY
105871: LIST
105872: LIST
105873: PPUSH
105874: CALL_OW 69
105878: PUSH
105879: FOR_IN
105880: IFFALSE 105921
// begin for j := 1 to 4 do
105882: LD_ADDR_VAR 0 3
105886: PUSH
105887: DOUBLE
105888: LD_INT 1
105890: DEC
105891: ST_TO_ADDR
105892: LD_INT 4
105894: PUSH
105895: FOR_TO
105896: IFFALSE 105917
// SetSkill ( i , j , 10 ) ;
105898: LD_VAR 0 2
105902: PPUSH
105903: LD_VAR 0 3
105907: PPUSH
105908: LD_INT 10
105910: PPUSH
105911: CALL_OW 237
105915: GO 105895
105917: POP
105918: POP
// end ;
105919: GO 105879
105921: POP
105922: POP
// end ;
105923: LD_VAR 0 1
105927: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105928: LD_INT 0
105930: PPUSH
// uc_side := your_side ;
105931: LD_ADDR_OWVAR 20
105935: PUSH
105936: LD_OWVAR 2
105940: ST_TO_ADDR
// uc_nation := nation ;
105941: LD_ADDR_OWVAR 21
105945: PUSH
105946: LD_VAR 0 1
105950: ST_TO_ADDR
// InitHc ;
105951: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105955: LD_INT 0
105957: PPUSH
105958: LD_VAR 0 2
105962: PPUSH
105963: LD_VAR 0 3
105967: PPUSH
105968: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105972: LD_VAR 0 4
105976: PPUSH
105977: LD_VAR 0 5
105981: PPUSH
105982: CALL_OW 428
105986: PUSH
105987: LD_INT 0
105989: EQUAL
105990: IFFALSE 106014
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105992: CALL_OW 44
105996: PPUSH
105997: LD_VAR 0 4
106001: PPUSH
106002: LD_VAR 0 5
106006: PPUSH
106007: LD_INT 1
106009: PPUSH
106010: CALL_OW 48
// end ;
106014: LD_VAR 0 6
106018: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
106019: LD_INT 0
106021: PPUSH
106022: PPUSH
// uc_side := your_side ;
106023: LD_ADDR_OWVAR 20
106027: PUSH
106028: LD_OWVAR 2
106032: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
106033: LD_VAR 0 1
106037: PUSH
106038: LD_INT 1
106040: PUSH
106041: LD_INT 2
106043: PUSH
106044: LD_INT 3
106046: PUSH
106047: LD_INT 4
106049: PUSH
106050: LD_INT 5
106052: PUSH
106053: EMPTY
106054: LIST
106055: LIST
106056: LIST
106057: LIST
106058: LIST
106059: IN
106060: IFFALSE 106072
// uc_nation := nation_american else
106062: LD_ADDR_OWVAR 21
106066: PUSH
106067: LD_INT 1
106069: ST_TO_ADDR
106070: GO 106115
// if chassis in [ 11 , 12 , 13 , 14 ] then
106072: LD_VAR 0 1
106076: PUSH
106077: LD_INT 11
106079: PUSH
106080: LD_INT 12
106082: PUSH
106083: LD_INT 13
106085: PUSH
106086: LD_INT 14
106088: PUSH
106089: EMPTY
106090: LIST
106091: LIST
106092: LIST
106093: LIST
106094: IN
106095: IFFALSE 106107
// uc_nation := nation_arabian else
106097: LD_ADDR_OWVAR 21
106101: PUSH
106102: LD_INT 2
106104: ST_TO_ADDR
106105: GO 106115
// uc_nation := nation_russian ;
106107: LD_ADDR_OWVAR 21
106111: PUSH
106112: LD_INT 3
106114: ST_TO_ADDR
// vc_chassis := chassis ;
106115: LD_ADDR_OWVAR 37
106119: PUSH
106120: LD_VAR 0 1
106124: ST_TO_ADDR
// vc_engine := engine ;
106125: LD_ADDR_OWVAR 39
106129: PUSH
106130: LD_VAR 0 2
106134: ST_TO_ADDR
// vc_control := control ;
106135: LD_ADDR_OWVAR 38
106139: PUSH
106140: LD_VAR 0 3
106144: ST_TO_ADDR
// vc_weapon := weapon ;
106145: LD_ADDR_OWVAR 40
106149: PUSH
106150: LD_VAR 0 4
106154: ST_TO_ADDR
// un := CreateVehicle ;
106155: LD_ADDR_VAR 0 8
106159: PUSH
106160: CALL_OW 45
106164: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106165: LD_VAR 0 8
106169: PPUSH
106170: LD_INT 0
106172: PPUSH
106173: LD_INT 5
106175: PPUSH
106176: CALL_OW 12
106180: PPUSH
106181: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106185: LD_VAR 0 8
106189: PPUSH
106190: LD_VAR 0 5
106194: PPUSH
106195: LD_VAR 0 6
106199: PPUSH
106200: LD_INT 1
106202: PPUSH
106203: CALL_OW 48
// end ;
106207: LD_VAR 0 7
106211: RET
// export hInvincible ; every 1 do
106212: GO 106214
106214: DISABLE
// hInvincible := [ ] ;
106215: LD_ADDR_EXP 166
106219: PUSH
106220: EMPTY
106221: ST_TO_ADDR
106222: END
// every 10 do var i ;
106223: GO 106225
106225: DISABLE
106226: LD_INT 0
106228: PPUSH
// begin enable ;
106229: ENABLE
// if not hInvincible then
106230: LD_EXP 166
106234: NOT
106235: IFFALSE 106239
// exit ;
106237: GO 106283
// for i in hInvincible do
106239: LD_ADDR_VAR 0 1
106243: PUSH
106244: LD_EXP 166
106248: PUSH
106249: FOR_IN
106250: IFFALSE 106281
// if GetLives ( i ) < 1000 then
106252: LD_VAR 0 1
106256: PPUSH
106257: CALL_OW 256
106261: PUSH
106262: LD_INT 1000
106264: LESS
106265: IFFALSE 106279
// SetLives ( i , 1000 ) ;
106267: LD_VAR 0 1
106271: PPUSH
106272: LD_INT 1000
106274: PPUSH
106275: CALL_OW 234
106279: GO 106249
106281: POP
106282: POP
// end ;
106283: PPOPN 1
106285: END
// export function hHackInvincible ; var i ; begin
106286: LD_INT 0
106288: PPUSH
106289: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106290: LD_ADDR_VAR 0 2
106294: PUSH
106295: LD_INT 2
106297: PUSH
106298: LD_INT 21
106300: PUSH
106301: LD_INT 1
106303: PUSH
106304: EMPTY
106305: LIST
106306: LIST
106307: PUSH
106308: LD_INT 21
106310: PUSH
106311: LD_INT 2
106313: PUSH
106314: EMPTY
106315: LIST
106316: LIST
106317: PUSH
106318: EMPTY
106319: LIST
106320: LIST
106321: LIST
106322: PPUSH
106323: CALL_OW 69
106327: PUSH
106328: FOR_IN
106329: IFFALSE 106390
// if IsSelected ( i ) then
106331: LD_VAR 0 2
106335: PPUSH
106336: CALL_OW 306
106340: IFFALSE 106388
// begin if i in hInvincible then
106342: LD_VAR 0 2
106346: PUSH
106347: LD_EXP 166
106351: IN
106352: IFFALSE 106372
// hInvincible := hInvincible diff i else
106354: LD_ADDR_EXP 166
106358: PUSH
106359: LD_EXP 166
106363: PUSH
106364: LD_VAR 0 2
106368: DIFF
106369: ST_TO_ADDR
106370: GO 106388
// hInvincible := hInvincible union i ;
106372: LD_ADDR_EXP 166
106376: PUSH
106377: LD_EXP 166
106381: PUSH
106382: LD_VAR 0 2
106386: UNION
106387: ST_TO_ADDR
// end ;
106388: GO 106328
106390: POP
106391: POP
// end ;
106392: LD_VAR 0 1
106396: RET
// export function hHackInvisible ; var i , j ; begin
106397: LD_INT 0
106399: PPUSH
106400: PPUSH
106401: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106402: LD_ADDR_VAR 0 2
106406: PUSH
106407: LD_INT 21
106409: PUSH
106410: LD_INT 1
106412: PUSH
106413: EMPTY
106414: LIST
106415: LIST
106416: PPUSH
106417: CALL_OW 69
106421: PUSH
106422: FOR_IN
106423: IFFALSE 106447
// if IsSelected ( i ) then
106425: LD_VAR 0 2
106429: PPUSH
106430: CALL_OW 306
106434: IFFALSE 106445
// ComForceInvisible ( i ) ;
106436: LD_VAR 0 2
106440: PPUSH
106441: CALL_OW 496
106445: GO 106422
106447: POP
106448: POP
// end ;
106449: LD_VAR 0 1
106453: RET
// export function hHackChangeYourSide ; begin
106454: LD_INT 0
106456: PPUSH
// if your_side = 8 then
106457: LD_OWVAR 2
106461: PUSH
106462: LD_INT 8
106464: EQUAL
106465: IFFALSE 106477
// your_side := 0 else
106467: LD_ADDR_OWVAR 2
106471: PUSH
106472: LD_INT 0
106474: ST_TO_ADDR
106475: GO 106491
// your_side := your_side + 1 ;
106477: LD_ADDR_OWVAR 2
106481: PUSH
106482: LD_OWVAR 2
106486: PUSH
106487: LD_INT 1
106489: PLUS
106490: ST_TO_ADDR
// end ;
106491: LD_VAR 0 1
106495: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106496: LD_INT 0
106498: PPUSH
106499: PPUSH
106500: PPUSH
// for i in all_units do
106501: LD_ADDR_VAR 0 2
106505: PUSH
106506: LD_OWVAR 3
106510: PUSH
106511: FOR_IN
106512: IFFALSE 106590
// if IsSelected ( i ) then
106514: LD_VAR 0 2
106518: PPUSH
106519: CALL_OW 306
106523: IFFALSE 106588
// begin j := GetSide ( i ) ;
106525: LD_ADDR_VAR 0 3
106529: PUSH
106530: LD_VAR 0 2
106534: PPUSH
106535: CALL_OW 255
106539: ST_TO_ADDR
// if j = 8 then
106540: LD_VAR 0 3
106544: PUSH
106545: LD_INT 8
106547: EQUAL
106548: IFFALSE 106560
// j := 0 else
106550: LD_ADDR_VAR 0 3
106554: PUSH
106555: LD_INT 0
106557: ST_TO_ADDR
106558: GO 106574
// j := j + 1 ;
106560: LD_ADDR_VAR 0 3
106564: PUSH
106565: LD_VAR 0 3
106569: PUSH
106570: LD_INT 1
106572: PLUS
106573: ST_TO_ADDR
// SetSide ( i , j ) ;
106574: LD_VAR 0 2
106578: PPUSH
106579: LD_VAR 0 3
106583: PPUSH
106584: CALL_OW 235
// end ;
106588: GO 106511
106590: POP
106591: POP
// end ;
106592: LD_VAR 0 1
106596: RET
// export function hHackFog ; begin
106597: LD_INT 0
106599: PPUSH
// FogOff ( true ) ;
106600: LD_INT 1
106602: PPUSH
106603: CALL_OW 344
// end ;
106607: LD_VAR 0 1
106611: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106612: LD_INT 0
106614: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106615: LD_VAR 0 1
106619: PPUSH
106620: LD_VAR 0 2
106624: PPUSH
106625: LD_VAR 0 3
106629: PPUSH
106630: LD_INT 1
106632: PPUSH
106633: LD_INT 1
106635: PPUSH
106636: CALL_OW 483
// CenterOnXY ( x , y ) ;
106640: LD_VAR 0 2
106644: PPUSH
106645: LD_VAR 0 3
106649: PPUSH
106650: CALL_OW 84
// end ;
106654: LD_VAR 0 4
106658: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106659: LD_INT 0
106661: PPUSH
106662: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106663: LD_VAR 0 1
106667: NOT
106668: IFTRUE 106687
106670: PUSH
106671: LD_VAR 0 2
106675: PPUSH
106676: LD_VAR 0 3
106680: PPUSH
106681: CALL_OW 488
106685: NOT
106686: OR
106687: IFTRUE 106722
106689: PUSH
106690: LD_VAR 0 1
106694: PPUSH
106695: CALL_OW 266
106699: PUSH
106700: LD_INT 3
106702: NONEQUAL
106703: IFFALSE 106721
106705: PUSH
106706: LD_VAR 0 1
106710: PPUSH
106711: CALL_OW 247
106715: PUSH
106716: LD_INT 1
106718: EQUAL
106719: NOT
106720: AND
106721: OR
106722: IFFALSE 106726
// exit ;
106724: GO 107008
// if GetType ( factory ) = unit_human then
106726: LD_VAR 0 1
106730: PPUSH
106731: CALL_OW 247
106735: PUSH
106736: LD_INT 1
106738: EQUAL
106739: IFFALSE 106756
// factory := IsInUnit ( factory ) ;
106741: LD_ADDR_VAR 0 1
106745: PUSH
106746: LD_VAR 0 1
106750: PPUSH
106751: CALL_OW 310
106755: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106756: LD_VAR 0 1
106760: PPUSH
106761: CALL_OW 266
106765: PUSH
106766: LD_INT 3
106768: NONEQUAL
106769: IFFALSE 106773
// exit ;
106771: GO 107008
// for i := 1 to Count ( factoryWaypoints ) do
106773: LD_ADDR_VAR 0 5
106777: PUSH
106778: DOUBLE
106779: LD_INT 1
106781: DEC
106782: ST_TO_ADDR
106783: LD_EXP 167
106787: PPUSH
106788: CALL 19636 0 1
106792: PUSH
106793: FOR_TO
106794: IFFALSE 106956
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
106796: LD_VAR 0 2
106800: PPUSH
106801: LD_VAR 0 3
106805: PPUSH
106806: CALL_OW 428
106810: PUSH
106811: LD_EXP 167
106815: PUSH
106816: LD_VAR 0 5
106820: ARRAY
106821: PUSH
106822: LD_INT 2
106824: ARRAY
106825: EQUAL
106826: IFFALSE 106858
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106828: LD_ADDR_EXP 167
106832: PUSH
106833: LD_EXP 167
106837: PPUSH
106838: LD_VAR 0 5
106842: PPUSH
106843: CALL_OW 3
106847: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106848: CALL 107013 0 0
// exit ;
106852: POP
106853: POP
106854: GO 107008
// end else
106856: GO 106954
// if factory = factoryWaypoints [ i ] [ 2 ] then
106858: LD_VAR 0 1
106862: PUSH
106863: LD_EXP 167
106867: PUSH
106868: LD_VAR 0 5
106872: ARRAY
106873: PUSH
106874: LD_INT 2
106876: ARRAY
106877: EQUAL
106878: IFFALSE 106954
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106880: LD_ADDR_EXP 167
106884: PUSH
106885: LD_EXP 167
106889: PPUSH
106890: LD_VAR 0 5
106894: PPUSH
106895: CALL_OW 3
106899: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106900: LD_ADDR_EXP 167
106904: PUSH
106905: LD_EXP 167
106909: PPUSH
106910: LD_VAR 0 1
106914: PPUSH
106915: CALL_OW 255
106919: PUSH
106920: LD_VAR 0 1
106924: PUSH
106925: LD_VAR 0 2
106929: PUSH
106930: LD_VAR 0 3
106934: PUSH
106935: EMPTY
106936: LIST
106937: LIST
106938: LIST
106939: LIST
106940: PPUSH
106941: CALL 55612 0 2
106945: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106946: CALL 107013 0 0
// exit ;
106950: POP
106951: POP
106952: GO 107008
// end ; end ;
106954: GO 106793
106956: POP
106957: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106958: LD_ADDR_EXP 167
106962: PUSH
106963: LD_EXP 167
106967: PPUSH
106968: LD_VAR 0 1
106972: PPUSH
106973: CALL_OW 255
106977: PUSH
106978: LD_VAR 0 1
106982: PUSH
106983: LD_VAR 0 2
106987: PUSH
106988: LD_VAR 0 3
106992: PUSH
106993: EMPTY
106994: LIST
106995: LIST
106996: LIST
106997: LIST
106998: PPUSH
106999: CALL 55612 0 2
107003: ST_TO_ADDR
// UpdateFactoryWaypoints ;
107004: CALL 107013 0 0
// end ;
107008: LD_VAR 0 4
107012: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
107013: LD_INT 0
107015: PPUSH
107016: PPUSH
107017: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
107018: LD_STRING resetFactoryWaypoint();
107020: PPUSH
107021: CALL_OW 559
// if factoryWaypoints then
107025: LD_EXP 167
107029: IFFALSE 107150
// begin list := factoryWaypoints ;
107031: LD_ADDR_VAR 0 3
107035: PUSH
107036: LD_EXP 167
107040: ST_TO_ADDR
// for i := 1 to list do
107041: LD_ADDR_VAR 0 2
107045: PUSH
107046: DOUBLE
107047: LD_INT 1
107049: DEC
107050: ST_TO_ADDR
107051: LD_VAR 0 3
107055: PUSH
107056: FOR_TO
107057: IFFALSE 107148
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107059: LD_STRING setFactoryWaypointXY(
107061: PUSH
107062: LD_VAR 0 3
107066: PUSH
107067: LD_VAR 0 2
107071: ARRAY
107072: PUSH
107073: LD_INT 1
107075: ARRAY
107076: STR
107077: PUSH
107078: LD_STRING ,
107080: STR
107081: PUSH
107082: LD_VAR 0 3
107086: PUSH
107087: LD_VAR 0 2
107091: ARRAY
107092: PUSH
107093: LD_INT 2
107095: ARRAY
107096: STR
107097: PUSH
107098: LD_STRING ,
107100: STR
107101: PUSH
107102: LD_VAR 0 3
107106: PUSH
107107: LD_VAR 0 2
107111: ARRAY
107112: PUSH
107113: LD_INT 3
107115: ARRAY
107116: STR
107117: PUSH
107118: LD_STRING ,
107120: STR
107121: PUSH
107122: LD_VAR 0 3
107126: PUSH
107127: LD_VAR 0 2
107131: ARRAY
107132: PUSH
107133: LD_INT 4
107135: ARRAY
107136: STR
107137: PUSH
107138: LD_STRING )
107140: STR
107141: PPUSH
107142: CALL_OW 559
107146: GO 107056
107148: POP
107149: POP
// end ; end ;
107150: LD_VAR 0 1
107154: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107155: LD_INT 0
107157: PPUSH
// if HexInfo ( x , y ) = warehouse then
107158: LD_VAR 0 2
107162: PPUSH
107163: LD_VAR 0 3
107167: PPUSH
107168: CALL_OW 428
107172: PUSH
107173: LD_VAR 0 1
107177: EQUAL
107178: IFFALSE 107205
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107180: LD_ADDR_EXP 169
107184: PUSH
107185: LD_EXP 169
107189: PPUSH
107190: LD_VAR 0 1
107194: PPUSH
107195: LD_INT 0
107197: PPUSH
107198: CALL_OW 1
107202: ST_TO_ADDR
107203: GO 107256
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107205: LD_ADDR_EXP 169
107209: PUSH
107210: LD_EXP 169
107214: PPUSH
107215: LD_VAR 0 1
107219: PPUSH
107220: LD_VAR 0 1
107224: PPUSH
107225: CALL_OW 255
107229: PUSH
107230: LD_VAR 0 1
107234: PUSH
107235: LD_VAR 0 2
107239: PUSH
107240: LD_VAR 0 3
107244: PUSH
107245: EMPTY
107246: LIST
107247: LIST
107248: LIST
107249: LIST
107250: PPUSH
107251: CALL_OW 1
107255: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107256: CALL 107265 0 0
// end ;
107260: LD_VAR 0 4
107264: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107265: LD_INT 0
107267: PPUSH
107268: PPUSH
107269: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107270: LD_STRING resetWarehouseGatheringPoints();
107272: PPUSH
107273: CALL_OW 559
// if warehouseGatheringPoints then
107277: LD_EXP 169
107281: IFFALSE 107407
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107283: LD_ADDR_VAR 0 3
107287: PUSH
107288: LD_EXP 169
107292: PPUSH
107293: CALL 59546 0 1
107297: ST_TO_ADDR
// for i := 1 to list do
107298: LD_ADDR_VAR 0 2
107302: PUSH
107303: DOUBLE
107304: LD_INT 1
107306: DEC
107307: ST_TO_ADDR
107308: LD_VAR 0 3
107312: PUSH
107313: FOR_TO
107314: IFFALSE 107405
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107316: LD_STRING setWarehouseGatheringPointXY(
107318: PUSH
107319: LD_VAR 0 3
107323: PUSH
107324: LD_VAR 0 2
107328: ARRAY
107329: PUSH
107330: LD_INT 1
107332: ARRAY
107333: STR
107334: PUSH
107335: LD_STRING ,
107337: STR
107338: PUSH
107339: LD_VAR 0 3
107343: PUSH
107344: LD_VAR 0 2
107348: ARRAY
107349: PUSH
107350: LD_INT 2
107352: ARRAY
107353: STR
107354: PUSH
107355: LD_STRING ,
107357: STR
107358: PUSH
107359: LD_VAR 0 3
107363: PUSH
107364: LD_VAR 0 2
107368: ARRAY
107369: PUSH
107370: LD_INT 3
107372: ARRAY
107373: STR
107374: PUSH
107375: LD_STRING ,
107377: STR
107378: PUSH
107379: LD_VAR 0 3
107383: PUSH
107384: LD_VAR 0 2
107388: ARRAY
107389: PUSH
107390: LD_INT 4
107392: ARRAY
107393: STR
107394: PUSH
107395: LD_STRING )
107397: STR
107398: PPUSH
107399: CALL_OW 559
107403: GO 107313
107405: POP
107406: POP
// end ; end ;
107407: LD_VAR 0 1
107411: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107412: LD_EXP 169
107416: IFFALSE 108111
107418: GO 107420
107420: DISABLE
107421: LD_INT 0
107423: PPUSH
107424: PPUSH
107425: PPUSH
107426: PPUSH
107427: PPUSH
107428: PPUSH
107429: PPUSH
107430: PPUSH
107431: PPUSH
// begin enable ;
107432: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107433: LD_ADDR_VAR 0 3
107437: PUSH
107438: LD_EXP 169
107442: PPUSH
107443: CALL 59546 0 1
107447: ST_TO_ADDR
// if not list then
107448: LD_VAR 0 3
107452: NOT
107453: IFFALSE 107457
// exit ;
107455: GO 108111
// for i := 1 to list do
107457: LD_ADDR_VAR 0 1
107461: PUSH
107462: DOUBLE
107463: LD_INT 1
107465: DEC
107466: ST_TO_ADDR
107467: LD_VAR 0 3
107471: PUSH
107472: FOR_TO
107473: IFFALSE 108109
// begin depot := list [ i ] [ 2 ] ;
107475: LD_ADDR_VAR 0 8
107479: PUSH
107480: LD_VAR 0 3
107484: PUSH
107485: LD_VAR 0 1
107489: ARRAY
107490: PUSH
107491: LD_INT 2
107493: ARRAY
107494: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107495: LD_ADDR_VAR 0 5
107499: PUSH
107500: LD_VAR 0 3
107504: PUSH
107505: LD_VAR 0 1
107509: ARRAY
107510: PUSH
107511: LD_INT 1
107513: ARRAY
107514: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107515: LD_VAR 0 8
107519: PPUSH
107520: CALL_OW 301
107524: IFTRUE 107543
107526: PUSH
107527: LD_VAR 0 5
107531: PUSH
107532: LD_VAR 0 8
107536: PPUSH
107537: CALL_OW 255
107541: NONEQUAL
107542: OR
107543: IFFALSE 107572
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107545: LD_ADDR_EXP 169
107549: PUSH
107550: LD_EXP 169
107554: PPUSH
107555: LD_VAR 0 8
107559: PPUSH
107560: LD_INT 0
107562: PPUSH
107563: CALL_OW 1
107567: ST_TO_ADDR
// exit ;
107568: POP
107569: POP
107570: GO 108111
// end ; x := list [ i ] [ 3 ] ;
107572: LD_ADDR_VAR 0 6
107576: PUSH
107577: LD_VAR 0 3
107581: PUSH
107582: LD_VAR 0 1
107586: ARRAY
107587: PUSH
107588: LD_INT 3
107590: ARRAY
107591: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107592: LD_ADDR_VAR 0 7
107596: PUSH
107597: LD_VAR 0 3
107601: PUSH
107602: LD_VAR 0 1
107606: ARRAY
107607: PUSH
107608: LD_INT 4
107610: ARRAY
107611: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107612: LD_ADDR_VAR 0 9
107616: PUSH
107617: LD_VAR 0 6
107621: PPUSH
107622: LD_VAR 0 7
107626: PPUSH
107627: LD_INT 16
107629: PPUSH
107630: CALL 58120 0 3
107634: ST_TO_ADDR
// if not cratesNearbyPoint then
107635: LD_VAR 0 9
107639: NOT
107640: IFFALSE 107646
// exit ;
107642: POP
107643: POP
107644: GO 108111
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107646: LD_ADDR_VAR 0 4
107650: PUSH
107651: LD_INT 22
107653: PUSH
107654: LD_VAR 0 5
107658: PUSH
107659: EMPTY
107660: LIST
107661: LIST
107662: PUSH
107663: LD_INT 3
107665: PUSH
107666: LD_INT 60
107668: PUSH
107669: EMPTY
107670: LIST
107671: PUSH
107672: EMPTY
107673: LIST
107674: LIST
107675: PUSH
107676: LD_INT 91
107678: PUSH
107679: LD_VAR 0 8
107683: PUSH
107684: LD_INT 6
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: LIST
107691: PUSH
107692: LD_INT 2
107694: PUSH
107695: LD_INT 25
107697: PUSH
107698: LD_INT 2
107700: PUSH
107701: EMPTY
107702: LIST
107703: LIST
107704: PUSH
107705: LD_INT 25
107707: PUSH
107708: LD_INT 16
107710: PUSH
107711: EMPTY
107712: LIST
107713: LIST
107714: PUSH
107715: EMPTY
107716: LIST
107717: LIST
107718: LIST
107719: PUSH
107720: EMPTY
107721: LIST
107722: LIST
107723: LIST
107724: LIST
107725: PPUSH
107726: CALL_OW 69
107730: PUSH
107731: LD_VAR 0 8
107735: PPUSH
107736: CALL_OW 313
107740: PPUSH
107741: LD_INT 3
107743: PUSH
107744: LD_INT 60
107746: PUSH
107747: EMPTY
107748: LIST
107749: PUSH
107750: EMPTY
107751: LIST
107752: LIST
107753: PUSH
107754: LD_INT 2
107756: PUSH
107757: LD_INT 25
107759: PUSH
107760: LD_INT 2
107762: PUSH
107763: EMPTY
107764: LIST
107765: LIST
107766: PUSH
107767: LD_INT 25
107769: PUSH
107770: LD_INT 16
107772: PUSH
107773: EMPTY
107774: LIST
107775: LIST
107776: PUSH
107777: EMPTY
107778: LIST
107779: LIST
107780: LIST
107781: PUSH
107782: EMPTY
107783: LIST
107784: LIST
107785: PPUSH
107786: CALL_OW 72
107790: UNION
107791: ST_TO_ADDR
// if tmp then
107792: LD_VAR 0 4
107796: IFFALSE 107876
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107798: LD_ADDR_VAR 0 4
107802: PUSH
107803: LD_VAR 0 4
107807: PPUSH
107808: LD_INT 3
107810: PPUSH
107811: CALL 55927 0 2
107815: ST_TO_ADDR
// for j in tmp do
107816: LD_ADDR_VAR 0 2
107820: PUSH
107821: LD_VAR 0 4
107825: PUSH
107826: FOR_IN
107827: IFFALSE 107870
// begin if IsInUnit ( j ) then
107829: LD_VAR 0 2
107833: PPUSH
107834: CALL_OW 310
107838: IFFALSE 107849
// ComExit ( j ) ;
107840: LD_VAR 0 2
107844: PPUSH
107845: CALL 56010 0 1
// AddComCollect ( j , x , y ) ;
107849: LD_VAR 0 2
107853: PPUSH
107854: LD_VAR 0 6
107858: PPUSH
107859: LD_VAR 0 7
107863: PPUSH
107864: CALL_OW 177
// end ;
107868: GO 107826
107870: POP
107871: POP
// exit ;
107872: POP
107873: POP
107874: GO 108111
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107876: LD_ADDR_VAR 0 4
107880: PUSH
107881: LD_INT 22
107883: PUSH
107884: LD_VAR 0 5
107888: PUSH
107889: EMPTY
107890: LIST
107891: LIST
107892: PUSH
107893: LD_INT 91
107895: PUSH
107896: LD_VAR 0 8
107900: PUSH
107901: LD_INT 8
107903: PUSH
107904: EMPTY
107905: LIST
107906: LIST
107907: LIST
107908: PUSH
107909: LD_INT 2
107911: PUSH
107912: LD_INT 34
107914: PUSH
107915: LD_INT 12
107917: PUSH
107918: EMPTY
107919: LIST
107920: LIST
107921: PUSH
107922: LD_INT 34
107924: PUSH
107925: LD_INT 51
107927: PUSH
107928: EMPTY
107929: LIST
107930: LIST
107931: PUSH
107932: LD_INT 34
107934: PUSH
107935: LD_INT 32
107937: PUSH
107938: EMPTY
107939: LIST
107940: LIST
107941: PUSH
107942: LD_INT 34
107944: PUSH
107945: LD_INT 89
107947: PUSH
107948: EMPTY
107949: LIST
107950: LIST
107951: PUSH
107952: EMPTY
107953: LIST
107954: LIST
107955: LIST
107956: LIST
107957: LIST
107958: PUSH
107959: EMPTY
107960: LIST
107961: LIST
107962: LIST
107963: PPUSH
107964: CALL_OW 69
107968: ST_TO_ADDR
// if tmp then
107969: LD_VAR 0 4
107973: IFFALSE 108107
// begin for j in tmp do
107975: LD_ADDR_VAR 0 2
107979: PUSH
107980: LD_VAR 0 4
107984: PUSH
107985: FOR_IN
107986: IFFALSE 108105
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107988: LD_VAR 0 2
107992: PPUSH
107993: CALL_OW 262
107997: PUSH
107998: LD_INT 3
108000: EQUAL
108001: IFTRUE 108018
108003: PUSH
108004: LD_VAR 0 2
108008: PPUSH
108009: CALL_OW 261
108013: PUSH
108014: LD_INT 20
108016: GREATER
108017: OR
108018: IFFALSE 108032
108020: PUSH
108021: LD_VAR 0 2
108025: PPUSH
108026: CALL_OW 314
108030: NOT
108031: AND
108032: IFFALSE 108062
108034: PUSH
108035: LD_VAR 0 2
108039: PPUSH
108040: CALL_OW 263
108044: PUSH
108045: LD_INT 1
108047: NONEQUAL
108048: IFTRUE 108061
108050: PUSH
108051: LD_VAR 0 2
108055: PPUSH
108056: CALL_OW 311
108060: OR
108061: AND
108062: IFFALSE 108103
// begin ComCollect ( j , x , y ) ;
108064: LD_VAR 0 2
108068: PPUSH
108069: LD_VAR 0 6
108073: PPUSH
108074: LD_VAR 0 7
108078: PPUSH
108079: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108083: LD_VAR 0 2
108087: PPUSH
108088: LD_VAR 0 8
108092: PPUSH
108093: CALL_OW 172
// exit ;
108097: POP
108098: POP
108099: POP
108100: POP
108101: GO 108111
// end ;
108103: GO 107985
108105: POP
108106: POP
// end ; end ;
108107: GO 107472
108109: POP
108110: POP
// end ; end_of_file
108111: PPOPN 9
108113: END
// export function SOS_UnitDestroyed ( un ) ; begin
108114: LD_INT 0
108116: PPUSH
// ComRadiation ( un ) ;
108117: LD_VAR 0 1
108121: PPUSH
108122: CALL 109284 0 1
// end ;
108126: LD_VAR 0 2
108130: RET
// export function SOS_UnitKamikazed ( un ) ; begin
108131: LD_INT 0
108133: PPUSH
// ComRadiation ( un ) ;
108134: LD_VAR 0 1
108138: PPUSH
108139: CALL 109284 0 1
// end ;
108143: LD_VAR 0 2
108147: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108148: LD_INT 0
108150: PPUSH
// end ;
108151: LD_VAR 0 4
108155: RET
// export function SOS_Command ( cmd ) ; begin
108156: LD_INT 0
108158: PPUSH
// end ;
108159: LD_VAR 0 2
108163: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108164: LD_INT 0
108166: PPUSH
// end ;
108167: LD_VAR 0 6
108171: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
108172: LD_INT 0
108174: PPUSH
108175: PPUSH
108176: PPUSH
108177: PPUSH
108178: PPUSH
// if not vehicle or not factory then
108179: LD_VAR 0 1
108183: NOT
108184: IFTRUE 108193
108186: PUSH
108187: LD_VAR 0 2
108191: NOT
108192: OR
108193: IFFALSE 108197
// exit ;
108195: GO 108859
// weapon := GetWeapon ( vehicle ) ;
108197: LD_ADDR_VAR 0 7
108201: PUSH
108202: LD_VAR 0 1
108206: PPUSH
108207: CALL_OW 264
108211: ST_TO_ADDR
// if weapon = ar_miner then
108212: LD_VAR 0 7
108216: PUSH
108217: LD_INT 81
108219: EQUAL
108220: IFFALSE 108277
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
108222: LD_ADDR_EXP 178
108226: PUSH
108227: LD_EXP 178
108231: PPUSH
108232: LD_EXP 178
108236: PUSH
108237: LD_INT 1
108239: PLUS
108240: PPUSH
108241: LD_VAR 0 1
108245: PPUSH
108246: CALL_OW 1
108250: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108251: LD_ADDR_EXP 179
108255: PUSH
108256: LD_EXP 179
108260: PPUSH
108261: LD_EXP 179
108265: PUSH
108266: LD_INT 1
108268: PLUS
108269: PPUSH
108270: EMPTY
108271: PPUSH
108272: CALL_OW 1
108276: ST_TO_ADDR
// end ; if not factoryWaypoints then
108277: LD_EXP 167
108281: NOT
108282: IFFALSE 108286
// exit ;
108284: GO 108859
// for i := 1 to Count ( factoryWaypoints ) do
108286: LD_ADDR_VAR 0 4
108290: PUSH
108291: DOUBLE
108292: LD_INT 1
108294: DEC
108295: ST_TO_ADDR
108296: LD_EXP 167
108300: PPUSH
108301: CALL 19636 0 1
108305: PUSH
108306: FOR_TO
108307: IFFALSE 108857
// if factoryWaypoints [ i ] [ 2 ] = factory then
108309: LD_EXP 167
108313: PUSH
108314: LD_VAR 0 4
108318: ARRAY
108319: PUSH
108320: LD_INT 2
108322: ARRAY
108323: PUSH
108324: LD_VAR 0 2
108328: EQUAL
108329: IFFALSE 108855
// begin if GetControl ( vehicle ) = control_manual then
108331: LD_VAR 0 1
108335: PPUSH
108336: CALL_OW 263
108340: PUSH
108341: LD_INT 1
108343: EQUAL
108344: IFFALSE 108708
// begin driver := IsDrivenBy ( vehicle ) ;
108346: LD_ADDR_VAR 0 5
108350: PUSH
108351: LD_VAR 0 1
108355: PPUSH
108356: CALL_OW 311
108360: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
108361: LD_VAR 0 5
108365: PUSH
108366: LD_EXP 168
108370: IN
108371: IFTRUE 108385
108373: PUSH
108374: LD_VAR 0 1
108378: PUSH
108379: LD_EXP 168
108383: IN
108384: OR
108385: IFFALSE 108391
// exit ;
108387: POP
108388: POP
108389: GO 108859
// if not HasTask ( driver ) then
108391: LD_VAR 0 5
108395: PPUSH
108396: CALL_OW 314
108400: NOT
108401: IFFALSE 108706
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
108403: LD_ADDR_EXP 168
108407: PUSH
108408: LD_EXP 168
108412: PPUSH
108413: LD_VAR 0 5
108417: PPUSH
108418: CALL 55612 0 2
108422: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
108423: LD_ADDR_EXP 168
108427: PUSH
108428: LD_EXP 168
108432: PPUSH
108433: LD_VAR 0 1
108437: PPUSH
108438: CALL 55612 0 2
108442: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108443: LD_ADDR_VAR 0 6
108447: PUSH
108448: LD_EXP 167
108452: PUSH
108453: LD_VAR 0 4
108457: ARRAY
108458: PUSH
108459: LD_INT 3
108461: ARRAY
108462: PPUSH
108463: LD_EXP 167
108467: PUSH
108468: LD_VAR 0 4
108472: ARRAY
108473: PUSH
108474: LD_INT 4
108476: ARRAY
108477: PPUSH
108478: CALL_OW 428
108482: ST_TO_ADDR
// if hex then
108483: LD_VAR 0 6
108487: IFFALSE 108505
// ComMoveUnit ( driver , hex ) else
108489: LD_VAR 0 5
108493: PPUSH
108494: LD_VAR 0 6
108498: PPUSH
108499: CALL_OW 112
108503: GO 108589
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
108505: LD_VAR 0 1
108509: PPUSH
108510: LD_EXP 167
108514: PUSH
108515: LD_VAR 0 4
108519: ARRAY
108520: PUSH
108521: LD_INT 3
108523: ARRAY
108524: PPUSH
108525: LD_EXP 167
108529: PUSH
108530: LD_VAR 0 4
108534: ARRAY
108535: PUSH
108536: LD_INT 4
108538: ARRAY
108539: PPUSH
108540: CALL_OW 297
108544: PUSH
108545: LD_INT 0
108547: GREATER
108548: IFFALSE 108589
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108550: LD_VAR 0 5
108554: PPUSH
108555: LD_EXP 167
108559: PUSH
108560: LD_VAR 0 4
108564: ARRAY
108565: PUSH
108566: LD_INT 3
108568: ARRAY
108569: PPUSH
108570: LD_EXP 167
108574: PUSH
108575: LD_VAR 0 4
108579: ARRAY
108580: PUSH
108581: LD_INT 4
108583: ARRAY
108584: PPUSH
108585: CALL_OW 111
// AddComExitVehicle ( driver ) ;
108589: LD_VAR 0 5
108593: PPUSH
108594: CALL_OW 181
// if Multiplayer then
108598: LD_OWVAR 4
108602: IFFALSE 108651
// begin repeat wait ( 10 ) ;
108604: LD_INT 10
108606: PPUSH
108607: CALL_OW 67
// until not IsInUnit ( driver ) ;
108611: LD_VAR 0 5
108615: PPUSH
108616: CALL_OW 310
108620: NOT
108621: IFFALSE 108604
// if not HasTask ( driver ) then
108623: LD_VAR 0 5
108627: PPUSH
108628: CALL_OW 314
108632: NOT
108633: IFFALSE 108649
// ComEnterUnit ( driver , factory ) ;
108635: LD_VAR 0 5
108639: PPUSH
108640: LD_VAR 0 2
108644: PPUSH
108645: CALL_OW 120
// end else
108649: GO 108665
// AddComEnterUnit ( driver , factory ) ;
108651: LD_VAR 0 5
108655: PPUSH
108656: LD_VAR 0 2
108660: PPUSH
108661: CALL_OW 180
// wait ( 0 0$1 ) ;
108665: LD_INT 35
108667: PPUSH
108668: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
108672: LD_ADDR_EXP 168
108676: PUSH
108677: LD_EXP 168
108681: PUSH
108682: LD_VAR 0 5
108686: DIFF
108687: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
108688: LD_ADDR_EXP 168
108692: PUSH
108693: LD_EXP 168
108697: PUSH
108698: LD_VAR 0 1
108702: DIFF
108703: ST_TO_ADDR
// break ;
108704: GO 108857
// end ; end else
108706: GO 108855
// if GetControl ( vehicle ) = control_remote then
108708: LD_VAR 0 1
108712: PPUSH
108713: CALL_OW 263
108717: PUSH
108718: LD_INT 2
108720: EQUAL
108721: IFFALSE 108807
// begin wait ( 0 0$2 ) ;
108723: LD_INT 70
108725: PPUSH
108726: CALL_OW 67
// repeat wait ( 10 ) ;
108730: LD_INT 10
108732: PPUSH
108733: CALL_OW 67
// Connect ( vehicle ) ;
108737: LD_VAR 0 1
108741: PPUSH
108742: CALL 25914 0 1
// until IsControledBy ( vehicle ) ;
108746: LD_VAR 0 1
108750: PPUSH
108751: CALL_OW 312
108755: IFFALSE 108730
// wait ( 10 ) ;
108757: LD_INT 10
108759: PPUSH
108760: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108764: LD_VAR 0 1
108768: PPUSH
108769: LD_EXP 167
108773: PUSH
108774: LD_VAR 0 4
108778: ARRAY
108779: PUSH
108780: LD_INT 3
108782: ARRAY
108783: PPUSH
108784: LD_EXP 167
108788: PUSH
108789: LD_VAR 0 4
108793: ARRAY
108794: PUSH
108795: LD_INT 4
108797: ARRAY
108798: PPUSH
108799: CALL_OW 111
// break ;
108803: GO 108857
// end else
108805: GO 108855
// begin wait ( 0 0$3 ) ;
108807: LD_INT 105
108809: PPUSH
108810: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108814: LD_VAR 0 1
108818: PPUSH
108819: LD_EXP 167
108823: PUSH
108824: LD_VAR 0 4
108828: ARRAY
108829: PUSH
108830: LD_INT 3
108832: ARRAY
108833: PPUSH
108834: LD_EXP 167
108838: PUSH
108839: LD_VAR 0 4
108843: ARRAY
108844: PUSH
108845: LD_INT 4
108847: ARRAY
108848: PPUSH
108849: CALL_OW 111
// break ;
108853: GO 108857
// end ; end ;
108855: GO 108306
108857: POP
108858: POP
// end ;
108859: LD_VAR 0 3
108863: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108864: LD_INT 0
108866: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108867: LD_VAR 0 1
108871: PUSH
108872: LD_INT 250
108874: EQUAL
108875: IFFALSE 108892
108877: PUSH
108878: LD_VAR 0 2
108882: PPUSH
108883: CALL_OW 264
108887: PUSH
108888: LD_INT 81
108890: EQUAL
108891: AND
108892: IFFALSE 108913
// MinerPlaceMine ( unit , x , y ) ;
108894: LD_VAR 0 2
108898: PPUSH
108899: LD_VAR 0 4
108903: PPUSH
108904: LD_VAR 0 5
108908: PPUSH
108909: CALL 112259 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108913: LD_VAR 0 1
108917: PUSH
108918: LD_INT 251
108920: EQUAL
108921: IFFALSE 108938
108923: PUSH
108924: LD_VAR 0 2
108928: PPUSH
108929: CALL_OW 264
108933: PUSH
108934: LD_INT 81
108936: EQUAL
108937: AND
108938: IFFALSE 108959
// MinerDetonateMine ( unit , x , y ) ;
108940: LD_VAR 0 2
108944: PPUSH
108945: LD_VAR 0 4
108949: PPUSH
108950: LD_VAR 0 5
108954: PPUSH
108955: CALL 112666 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108959: LD_VAR 0 1
108963: PUSH
108964: LD_INT 252
108966: EQUAL
108967: IFFALSE 108984
108969: PUSH
108970: LD_VAR 0 2
108974: PPUSH
108975: CALL_OW 264
108979: PUSH
108980: LD_INT 81
108982: EQUAL
108983: AND
108984: IFFALSE 109005
// MinerCreateMinefield ( unit , x , y ) ;
108986: LD_VAR 0 2
108990: PPUSH
108991: LD_VAR 0 4
108995: PPUSH
108996: LD_VAR 0 5
109000: PPUSH
109001: CALL 112898 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
109005: LD_VAR 0 1
109009: PUSH
109010: LD_INT 253
109012: EQUAL
109013: IFFALSE 109030
109015: PUSH
109016: LD_VAR 0 2
109020: PPUSH
109021: CALL_OW 257
109025: PUSH
109026: LD_INT 5
109028: EQUAL
109029: AND
109030: IFFALSE 109051
// ComBinocular ( unit , x , y ) ;
109032: LD_VAR 0 2
109036: PPUSH
109037: LD_VAR 0 4
109041: PPUSH
109042: LD_VAR 0 5
109046: PPUSH
109047: CALL 113273 0 3
// if selectedUnit then
109051: LD_VAR 0 3
109055: IFFALSE 109115
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
109057: LD_VAR 0 1
109061: PUSH
109062: LD_INT 254
109064: EQUAL
109065: IFFALSE 109082
109067: PUSH
109068: LD_VAR 0 2
109072: PPUSH
109073: CALL_OW 264
109077: PUSH
109078: LD_INT 99
109080: EQUAL
109081: AND
109082: IFFALSE 109099
109084: PUSH
109085: LD_VAR 0 3
109089: PPUSH
109090: CALL_OW 263
109094: PUSH
109095: LD_INT 3
109097: EQUAL
109098: AND
109099: IFFALSE 109115
// HackDestroyVehicle ( unit , selectedUnit ) ;
109101: LD_VAR 0 2
109105: PPUSH
109106: LD_VAR 0 3
109110: PPUSH
109111: CALL 111449 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
109115: LD_VAR 0 1
109119: PUSH
109120: LD_INT 255
109122: EQUAL
109123: IFFALSE 109147
109125: PUSH
109126: LD_VAR 0 2
109130: PPUSH
109131: CALL_OW 264
109135: PUSH
109136: LD_INT 14
109138: PUSH
109139: LD_INT 53
109141: PUSH
109142: EMPTY
109143: LIST
109144: LIST
109145: IN
109146: AND
109147: IFFALSE 109165
109149: PUSH
109150: LD_VAR 0 4
109154: PPUSH
109155: LD_VAR 0 5
109159: PPUSH
109160: CALL_OW 488
109164: AND
109165: IFFALSE 109189
// CutTreeXYR ( unit , x , y , 12 ) ;
109167: LD_VAR 0 2
109171: PPUSH
109172: LD_VAR 0 4
109176: PPUSH
109177: LD_VAR 0 5
109181: PPUSH
109182: LD_INT 12
109184: PPUSH
109185: CALL 109380 0 4
// if cmd = 256 then
109189: LD_VAR 0 1
109193: PUSH
109194: LD_INT 256
109196: EQUAL
109197: IFFALSE 109218
// SetFactoryWaypoint ( unit , x , y ) ;
109199: LD_VAR 0 2
109203: PPUSH
109204: LD_VAR 0 4
109208: PPUSH
109209: LD_VAR 0 5
109213: PPUSH
109214: CALL 106659 0 3
// if cmd = 257 then
109218: LD_VAR 0 1
109222: PUSH
109223: LD_INT 257
109225: EQUAL
109226: IFFALSE 109247
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109228: LD_VAR 0 2
109232: PPUSH
109233: LD_VAR 0 4
109237: PPUSH
109238: LD_VAR 0 5
109242: PPUSH
109243: CALL 107155 0 3
// if cmd = 258 then
109247: LD_VAR 0 1
109251: PUSH
109252: LD_INT 258
109254: EQUAL
109255: IFFALSE 109279
// BurnTreeXYR ( unit , x , y , 8 ) ;
109257: LD_VAR 0 2
109261: PPUSH
109262: LD_VAR 0 4
109266: PPUSH
109267: LD_VAR 0 5
109271: PPUSH
109272: LD_INT 8
109274: PPUSH
109275: CALL 109802 0 4
// end ;
109279: LD_VAR 0 6
109283: RET
// export function ComRadiation ( un ) ; var eff ; begin
109284: LD_INT 0
109286: PPUSH
109287: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
109288: LD_VAR 0 1
109292: PPUSH
109293: CALL_OW 264
109297: PUSH
109298: LD_INT 91
109300: NONEQUAL
109301: IFFALSE 109305
// exit ;
109303: GO 109375
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109305: LD_INT 68
109307: PPUSH
109308: LD_VAR 0 1
109312: PPUSH
109313: CALL_OW 255
109317: PPUSH
109318: CALL_OW 321
109322: PUSH
109323: LD_INT 2
109325: EQUAL
109326: IFFALSE 109338
// eff := 50 else
109328: LD_ADDR_VAR 0 3
109332: PUSH
109333: LD_INT 50
109335: ST_TO_ADDR
109336: GO 109346
// eff := 25 ;
109338: LD_ADDR_VAR 0 3
109342: PUSH
109343: LD_INT 25
109345: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109346: LD_VAR 0 1
109350: PPUSH
109351: CALL_OW 250
109355: PPUSH
109356: LD_VAR 0 1
109360: PPUSH
109361: CALL_OW 251
109365: PPUSH
109366: LD_VAR 0 3
109370: PPUSH
109371: CALL_OW 495
// end ;
109375: LD_VAR 0 2
109379: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109380: LD_INT 0
109382: PPUSH
109383: PPUSH
109384: PPUSH
109385: PPUSH
109386: PPUSH
109387: PPUSH
109388: PPUSH
109389: PPUSH
109390: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109391: LD_VAR 0 1
109395: PPUSH
109396: CALL_OW 302
109400: NOT
109401: IFTRUE 109420
109403: PUSH
109404: LD_VAR 0 2
109408: PPUSH
109409: LD_VAR 0 3
109413: PPUSH
109414: CALL_OW 488
109418: NOT
109419: OR
109420: IFTRUE 109429
109422: PUSH
109423: LD_VAR 0 4
109427: NOT
109428: OR
109429: IFFALSE 109433
// exit ;
109431: GO 109797
// if Count ( GetTaskList ( bulldozer ) ) > 10 then
109433: LD_VAR 0 1
109437: PPUSH
109438: CALL_OW 437
109442: PPUSH
109443: CALL 19636 0 1
109447: PUSH
109448: LD_INT 10
109450: GREATER
109451: IFFALSE 109455
// exit ;
109453: GO 109797
// list := [ ] ;
109455: LD_ADDR_VAR 0 13
109459: PUSH
109460: EMPTY
109461: ST_TO_ADDR
// if x - r < 0 then
109462: LD_VAR 0 2
109466: PUSH
109467: LD_VAR 0 4
109471: MINUS
109472: PUSH
109473: LD_INT 0
109475: LESS
109476: IFFALSE 109488
// min_x := 0 else
109478: LD_ADDR_VAR 0 7
109482: PUSH
109483: LD_INT 0
109485: ST_TO_ADDR
109486: GO 109504
// min_x := x - r ;
109488: LD_ADDR_VAR 0 7
109492: PUSH
109493: LD_VAR 0 2
109497: PUSH
109498: LD_VAR 0 4
109502: MINUS
109503: ST_TO_ADDR
// if y - r < 0 then
109504: LD_VAR 0 3
109508: PUSH
109509: LD_VAR 0 4
109513: MINUS
109514: PUSH
109515: LD_INT 0
109517: LESS
109518: IFFALSE 109530
// min_y := 0 else
109520: LD_ADDR_VAR 0 8
109524: PUSH
109525: LD_INT 0
109527: ST_TO_ADDR
109528: GO 109546
// min_y := y - r ;
109530: LD_ADDR_VAR 0 8
109534: PUSH
109535: LD_VAR 0 3
109539: PUSH
109540: LD_VAR 0 4
109544: MINUS
109545: ST_TO_ADDR
// max_x := x + r ;
109546: LD_ADDR_VAR 0 9
109550: PUSH
109551: LD_VAR 0 2
109555: PUSH
109556: LD_VAR 0 4
109560: PLUS
109561: ST_TO_ADDR
// max_y := y + r ;
109562: LD_ADDR_VAR 0 10
109566: PUSH
109567: LD_VAR 0 3
109571: PUSH
109572: LD_VAR 0 4
109576: PLUS
109577: ST_TO_ADDR
// for _x = min_x to max_x do
109578: LD_ADDR_VAR 0 11
109582: PUSH
109583: DOUBLE
109584: LD_VAR 0 7
109588: DEC
109589: ST_TO_ADDR
109590: LD_VAR 0 9
109594: PUSH
109595: FOR_TO
109596: IFFALSE 109715
// for _y = min_y to max_y do
109598: LD_ADDR_VAR 0 12
109602: PUSH
109603: DOUBLE
109604: LD_VAR 0 8
109608: DEC
109609: ST_TO_ADDR
109610: LD_VAR 0 10
109614: PUSH
109615: FOR_TO
109616: IFFALSE 109711
// begin if not ValidHex ( _x , _y ) then
109618: LD_VAR 0 11
109622: PPUSH
109623: LD_VAR 0 12
109627: PPUSH
109628: CALL_OW 488
109632: NOT
109633: IFFALSE 109637
// continue ;
109635: GO 109615
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109637: LD_VAR 0 11
109641: PPUSH
109642: LD_VAR 0 12
109646: PPUSH
109647: CALL_OW 351
109651: IFFALSE 109669
109653: PUSH
109654: LD_VAR 0 11
109658: PPUSH
109659: LD_VAR 0 12
109663: PPUSH
109664: CALL_OW 554
109668: AND
109669: IFFALSE 109709
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109671: LD_ADDR_VAR 0 13
109675: PUSH
109676: LD_VAR 0 13
109680: PPUSH
109681: LD_VAR 0 13
109685: PUSH
109686: LD_INT 1
109688: PLUS
109689: PPUSH
109690: LD_VAR 0 11
109694: PUSH
109695: LD_VAR 0 12
109699: PUSH
109700: EMPTY
109701: LIST
109702: LIST
109703: PPUSH
109704: CALL_OW 2
109708: ST_TO_ADDR
// end ;
109709: GO 109615
109711: POP
109712: POP
109713: GO 109595
109715: POP
109716: POP
// if not list then
109717: LD_VAR 0 13
109721: NOT
109722: IFFALSE 109726
// exit ;
109724: GO 109797
// for i in list do
109726: LD_ADDR_VAR 0 6
109730: PUSH
109731: LD_VAR 0 13
109735: PUSH
109736: FOR_IN
109737: IFFALSE 109795
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109739: LD_VAR 0 1
109743: PPUSH
109744: LD_STRING M
109746: PUSH
109747: LD_VAR 0 6
109751: PUSH
109752: LD_INT 1
109754: ARRAY
109755: PUSH
109756: LD_VAR 0 6
109760: PUSH
109761: LD_INT 2
109763: ARRAY
109764: PUSH
109765: LD_INT 0
109767: PUSH
109768: LD_INT 0
109770: PUSH
109771: LD_INT 0
109773: PUSH
109774: LD_INT 0
109776: PUSH
109777: EMPTY
109778: LIST
109779: LIST
109780: LIST
109781: LIST
109782: LIST
109783: LIST
109784: LIST
109785: PUSH
109786: EMPTY
109787: LIST
109788: PPUSH
109789: CALL_OW 447
109793: GO 109736
109795: POP
109796: POP
// end ;
109797: LD_VAR 0 5
109801: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
109802: LD_INT 0
109804: PPUSH
109805: PPUSH
109806: PPUSH
109807: PPUSH
109808: PPUSH
109809: PPUSH
109810: PPUSH
109811: PPUSH
109812: PPUSH
109813: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109814: LD_VAR 0 1
109818: PPUSH
109819: CALL_OW 302
109823: NOT
109824: IFTRUE 109843
109826: PUSH
109827: LD_VAR 0 2
109831: PPUSH
109832: LD_VAR 0 3
109836: PPUSH
109837: CALL_OW 488
109841: NOT
109842: OR
109843: IFTRUE 109852
109845: PUSH
109846: LD_VAR 0 4
109850: NOT
109851: OR
109852: IFFALSE 109856
// exit ;
109854: GO 110395
// if Count ( GetTaskList ( flame ) ) > 10 then
109856: LD_VAR 0 1
109860: PPUSH
109861: CALL_OW 437
109865: PPUSH
109866: CALL 19636 0 1
109870: PUSH
109871: LD_INT 10
109873: GREATER
109874: IFFALSE 109878
// exit ;
109876: GO 110395
// list := [ ] ;
109878: LD_ADDR_VAR 0 13
109882: PUSH
109883: EMPTY
109884: ST_TO_ADDR
// if x - r < 0 then
109885: LD_VAR 0 2
109889: PUSH
109890: LD_VAR 0 4
109894: MINUS
109895: PUSH
109896: LD_INT 0
109898: LESS
109899: IFFALSE 109911
// min_x := 0 else
109901: LD_ADDR_VAR 0 7
109905: PUSH
109906: LD_INT 0
109908: ST_TO_ADDR
109909: GO 109927
// min_x := x - r ;
109911: LD_ADDR_VAR 0 7
109915: PUSH
109916: LD_VAR 0 2
109920: PUSH
109921: LD_VAR 0 4
109925: MINUS
109926: ST_TO_ADDR
// if y - r < 0 then
109927: LD_VAR 0 3
109931: PUSH
109932: LD_VAR 0 4
109936: MINUS
109937: PUSH
109938: LD_INT 0
109940: LESS
109941: IFFALSE 109953
// min_y := 0 else
109943: LD_ADDR_VAR 0 8
109947: PUSH
109948: LD_INT 0
109950: ST_TO_ADDR
109951: GO 109969
// min_y := y - r ;
109953: LD_ADDR_VAR 0 8
109957: PUSH
109958: LD_VAR 0 3
109962: PUSH
109963: LD_VAR 0 4
109967: MINUS
109968: ST_TO_ADDR
// max_x := x + r ;
109969: LD_ADDR_VAR 0 9
109973: PUSH
109974: LD_VAR 0 2
109978: PUSH
109979: LD_VAR 0 4
109983: PLUS
109984: ST_TO_ADDR
// max_y := y + r ;
109985: LD_ADDR_VAR 0 10
109989: PUSH
109990: LD_VAR 0 3
109994: PUSH
109995: LD_VAR 0 4
109999: PLUS
110000: ST_TO_ADDR
// for _x = min_x to max_x do
110001: LD_ADDR_VAR 0 11
110005: PUSH
110006: DOUBLE
110007: LD_VAR 0 7
110011: DEC
110012: ST_TO_ADDR
110013: LD_VAR 0 9
110017: PUSH
110018: FOR_TO
110019: IFFALSE 110138
// for _y = min_y to max_y do
110021: LD_ADDR_VAR 0 12
110025: PUSH
110026: DOUBLE
110027: LD_VAR 0 8
110031: DEC
110032: ST_TO_ADDR
110033: LD_VAR 0 10
110037: PUSH
110038: FOR_TO
110039: IFFALSE 110134
// begin if not ValidHex ( _x , _y ) then
110041: LD_VAR 0 11
110045: PPUSH
110046: LD_VAR 0 12
110050: PPUSH
110051: CALL_OW 488
110055: NOT
110056: IFFALSE 110060
// continue ;
110058: GO 110038
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
110060: LD_VAR 0 11
110064: PPUSH
110065: LD_VAR 0 12
110069: PPUSH
110070: CALL_OW 351
110074: IFFALSE 110092
110076: PUSH
110077: LD_VAR 0 11
110081: PPUSH
110082: LD_VAR 0 12
110086: PPUSH
110087: CALL_OW 554
110091: AND
110092: IFFALSE 110132
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
110094: LD_ADDR_VAR 0 13
110098: PUSH
110099: LD_VAR 0 13
110103: PPUSH
110104: LD_VAR 0 13
110108: PUSH
110109: LD_INT 1
110111: PLUS
110112: PPUSH
110113: LD_VAR 0 11
110117: PUSH
110118: LD_VAR 0 12
110122: PUSH
110123: EMPTY
110124: LIST
110125: LIST
110126: PPUSH
110127: CALL_OW 2
110131: ST_TO_ADDR
// end ;
110132: GO 110038
110134: POP
110135: POP
110136: GO 110018
110138: POP
110139: POP
// if not list then
110140: LD_VAR 0 13
110144: NOT
110145: IFFALSE 110149
// exit ;
110147: GO 110395
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
110149: LD_ADDR_VAR 0 13
110153: PUSH
110154: LD_VAR 0 1
110158: PPUSH
110159: LD_VAR 0 13
110163: PPUSH
110164: LD_INT 1
110166: PPUSH
110167: LD_INT 1
110169: PPUSH
110170: CALL 23042 0 4
110174: ST_TO_ADDR
// ComStop ( flame ) ;
110175: LD_VAR 0 1
110179: PPUSH
110180: CALL_OW 141
// for i in list do
110184: LD_ADDR_VAR 0 6
110188: PUSH
110189: LD_VAR 0 13
110193: PUSH
110194: FOR_IN
110195: IFFALSE 110226
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
110197: LD_VAR 0 1
110201: PPUSH
110202: LD_VAR 0 6
110206: PUSH
110207: LD_INT 1
110209: ARRAY
110210: PPUSH
110211: LD_VAR 0 6
110215: PUSH
110216: LD_INT 2
110218: ARRAY
110219: PPUSH
110220: CALL_OW 176
110224: GO 110194
110226: POP
110227: POP
// repeat wait ( 0 0$1 ) ;
110228: LD_INT 35
110230: PPUSH
110231: CALL_OW 67
// task := GetTaskList ( flame ) ;
110235: LD_ADDR_VAR 0 14
110239: PUSH
110240: LD_VAR 0 1
110244: PPUSH
110245: CALL_OW 437
110249: ST_TO_ADDR
// if not task then
110250: LD_VAR 0 14
110254: NOT
110255: IFFALSE 110259
// exit ;
110257: GO 110395
// if task [ 1 ] [ 1 ] <> | then
110259: LD_VAR 0 14
110263: PUSH
110264: LD_INT 1
110266: ARRAY
110267: PUSH
110268: LD_INT 1
110270: ARRAY
110271: PUSH
110272: LD_STRING |
110274: NONEQUAL
110275: IFFALSE 110279
// exit ;
110277: GO 110395
// _x := task [ 1 ] [ 2 ] ;
110279: LD_ADDR_VAR 0 11
110283: PUSH
110284: LD_VAR 0 14
110288: PUSH
110289: LD_INT 1
110291: ARRAY
110292: PUSH
110293: LD_INT 2
110295: ARRAY
110296: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
110297: LD_ADDR_VAR 0 12
110301: PUSH
110302: LD_VAR 0 14
110306: PUSH
110307: LD_INT 1
110309: ARRAY
110310: PUSH
110311: LD_INT 3
110313: ARRAY
110314: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
110315: LD_VAR 0 11
110319: PPUSH
110320: LD_VAR 0 12
110324: PPUSH
110325: CALL_OW 351
110329: NOT
110330: IFTRUE 110349
110332: PUSH
110333: LD_VAR 0 11
110337: PPUSH
110338: LD_VAR 0 12
110342: PPUSH
110343: CALL_OW 554
110347: NOT
110348: OR
110349: IFFALSE 110383
// begin task := Delete ( task , 1 ) ;
110351: LD_ADDR_VAR 0 14
110355: PUSH
110356: LD_VAR 0 14
110360: PPUSH
110361: LD_INT 1
110363: PPUSH
110364: CALL_OW 3
110368: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
110369: LD_VAR 0 1
110373: PPUSH
110374: LD_VAR 0 14
110378: PPUSH
110379: CALL_OW 446
// end ; until not HasTask ( flame ) ;
110383: LD_VAR 0 1
110387: PPUSH
110388: CALL_OW 314
110392: NOT
110393: IFFALSE 110228
// end ;
110395: LD_VAR 0 5
110399: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110400: LD_EXP 171
110404: NOT
110405: IFFALSE 110455
110407: GO 110409
110409: DISABLE
// begin initHack := true ;
110410: LD_ADDR_EXP 171
110414: PUSH
110415: LD_INT 1
110417: ST_TO_ADDR
// hackTanks := [ ] ;
110418: LD_ADDR_EXP 172
110422: PUSH
110423: EMPTY
110424: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110425: LD_ADDR_EXP 173
110429: PUSH
110430: EMPTY
110431: ST_TO_ADDR
// hackLimit := 3 ;
110432: LD_ADDR_EXP 174
110436: PUSH
110437: LD_INT 3
110439: ST_TO_ADDR
// hackDist := 12 ;
110440: LD_ADDR_EXP 175
110444: PUSH
110445: LD_INT 12
110447: ST_TO_ADDR
// hackCounter := [ ] ;
110448: LD_ADDR_EXP 176
110452: PUSH
110453: EMPTY
110454: ST_TO_ADDR
// end ;
110455: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110456: LD_EXP 171
110460: IFFALSE 110478
110462: PUSH
110463: LD_INT 34
110465: PUSH
110466: LD_INT 99
110468: PUSH
110469: EMPTY
110470: LIST
110471: LIST
110472: PPUSH
110473: CALL_OW 69
110477: AND
110478: IFFALSE 110731
110480: GO 110482
110482: DISABLE
110483: LD_INT 0
110485: PPUSH
110486: PPUSH
// begin enable ;
110487: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110488: LD_ADDR_VAR 0 1
110492: PUSH
110493: LD_INT 34
110495: PUSH
110496: LD_INT 99
110498: PUSH
110499: EMPTY
110500: LIST
110501: LIST
110502: PPUSH
110503: CALL_OW 69
110507: PUSH
110508: FOR_IN
110509: IFFALSE 110729
// begin if not i in hackTanks then
110511: LD_VAR 0 1
110515: PUSH
110516: LD_EXP 172
110520: IN
110521: NOT
110522: IFFALSE 110605
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110524: LD_ADDR_EXP 172
110528: PUSH
110529: LD_EXP 172
110533: PPUSH
110534: LD_EXP 172
110538: PUSH
110539: LD_INT 1
110541: PLUS
110542: PPUSH
110543: LD_VAR 0 1
110547: PPUSH
110548: CALL_OW 1
110552: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110553: LD_ADDR_EXP 173
110557: PUSH
110558: LD_EXP 173
110562: PPUSH
110563: LD_EXP 173
110567: PUSH
110568: LD_INT 1
110570: PLUS
110571: PPUSH
110572: EMPTY
110573: PPUSH
110574: CALL_OW 1
110578: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110579: LD_ADDR_EXP 176
110583: PUSH
110584: LD_EXP 176
110588: PPUSH
110589: LD_EXP 176
110593: PUSH
110594: LD_INT 1
110596: PLUS
110597: PPUSH
110598: EMPTY
110599: PPUSH
110600: CALL_OW 1
110604: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110605: LD_VAR 0 1
110609: PPUSH
110610: CALL_OW 302
110614: NOT
110615: IFFALSE 110628
// begin HackUnlinkAll ( i ) ;
110617: LD_VAR 0 1
110621: PPUSH
110622: CALL 110734 0 1
// continue ;
110626: GO 110508
// end ; HackCheckCapturedStatus ( i ) ;
110628: LD_VAR 0 1
110632: PPUSH
110633: CALL 111179 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110637: LD_ADDR_VAR 0 2
110641: PUSH
110642: LD_INT 81
110644: PUSH
110645: LD_VAR 0 1
110649: PPUSH
110650: CALL_OW 255
110654: PUSH
110655: EMPTY
110656: LIST
110657: LIST
110658: PUSH
110659: LD_INT 33
110661: PUSH
110662: LD_INT 3
110664: PUSH
110665: EMPTY
110666: LIST
110667: LIST
110668: PUSH
110669: LD_INT 91
110671: PUSH
110672: LD_VAR 0 1
110676: PUSH
110677: LD_EXP 175
110681: PUSH
110682: EMPTY
110683: LIST
110684: LIST
110685: LIST
110686: PUSH
110687: LD_INT 50
110689: PUSH
110690: EMPTY
110691: LIST
110692: PUSH
110693: EMPTY
110694: LIST
110695: LIST
110696: LIST
110697: LIST
110698: PPUSH
110699: CALL_OW 69
110703: ST_TO_ADDR
// if not tmp then
110704: LD_VAR 0 2
110708: NOT
110709: IFFALSE 110713
// continue ;
110711: GO 110508
// HackLink ( i , tmp ) ;
110713: LD_VAR 0 1
110717: PPUSH
110718: LD_VAR 0 2
110722: PPUSH
110723: CALL 110870 0 2
// end ;
110727: GO 110508
110729: POP
110730: POP
// end ;
110731: PPOPN 2
110733: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110734: LD_INT 0
110736: PPUSH
110737: PPUSH
110738: PPUSH
// if not hack in hackTanks then
110739: LD_VAR 0 1
110743: PUSH
110744: LD_EXP 172
110748: IN
110749: NOT
110750: IFFALSE 110754
// exit ;
110752: GO 110865
// index := GetElementIndex ( hackTanks , hack ) ;
110754: LD_ADDR_VAR 0 4
110758: PUSH
110759: LD_EXP 172
110763: PPUSH
110764: LD_VAR 0 1
110768: PPUSH
110769: CALL 22337 0 2
110773: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110774: LD_EXP 173
110778: PUSH
110779: LD_VAR 0 4
110783: ARRAY
110784: IFFALSE 110865
// begin for i in hackTanksCaptured [ index ] do
110786: LD_ADDR_VAR 0 3
110790: PUSH
110791: LD_EXP 173
110795: PUSH
110796: LD_VAR 0 4
110800: ARRAY
110801: PUSH
110802: FOR_IN
110803: IFFALSE 110829
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110805: LD_VAR 0 3
110809: PUSH
110810: LD_INT 1
110812: ARRAY
110813: PPUSH
110814: LD_VAR 0 3
110818: PUSH
110819: LD_INT 2
110821: ARRAY
110822: PPUSH
110823: CALL_OW 235
110827: GO 110802
110829: POP
110830: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110831: LD_ADDR_EXP 173
110835: PUSH
110836: LD_EXP 173
110840: PPUSH
110841: LD_VAR 0 4
110845: PPUSH
110846: EMPTY
110847: PPUSH
110848: CALL_OW 1
110852: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110853: LD_VAR 0 1
110857: PPUSH
110858: LD_INT 0
110860: PPUSH
110861: CALL_OW 505
// end ; end ;
110865: LD_VAR 0 2
110869: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110870: LD_INT 0
110872: PPUSH
110873: PPUSH
110874: PPUSH
// if not hack in hackTanks or not vehicles then
110875: LD_VAR 0 1
110879: PUSH
110880: LD_EXP 172
110884: IN
110885: NOT
110886: IFTRUE 110895
110888: PUSH
110889: LD_VAR 0 2
110893: NOT
110894: OR
110895: IFFALSE 110899
// exit ;
110897: GO 111174
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110899: LD_ADDR_VAR 0 2
110903: PUSH
110904: LD_VAR 0 1
110908: PPUSH
110909: LD_VAR 0 2
110913: PPUSH
110914: LD_INT 1
110916: PPUSH
110917: LD_INT 1
110919: PPUSH
110920: CALL 22989 0 4
110924: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110925: LD_ADDR_VAR 0 5
110929: PUSH
110930: LD_EXP 172
110934: PPUSH
110935: LD_VAR 0 1
110939: PPUSH
110940: CALL 22337 0 2
110944: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110945: LD_EXP 173
110949: PUSH
110950: LD_VAR 0 5
110954: ARRAY
110955: PUSH
110956: LD_EXP 174
110960: LESS
110961: IFFALSE 111150
// begin for i := 1 to vehicles do
110963: LD_ADDR_VAR 0 4
110967: PUSH
110968: DOUBLE
110969: LD_INT 1
110971: DEC
110972: ST_TO_ADDR
110973: LD_VAR 0 2
110977: PUSH
110978: FOR_TO
110979: IFFALSE 111148
// begin if hackTanksCaptured [ index ] = hackLimit then
110981: LD_EXP 173
110985: PUSH
110986: LD_VAR 0 5
110990: ARRAY
110991: PUSH
110992: LD_EXP 174
110996: EQUAL
110997: IFFALSE 111001
// break ;
110999: GO 111148
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
111001: LD_ADDR_EXP 176
111005: PUSH
111006: LD_EXP 176
111010: PPUSH
111011: LD_VAR 0 5
111015: PPUSH
111016: LD_EXP 176
111020: PUSH
111021: LD_VAR 0 5
111025: ARRAY
111026: PUSH
111027: LD_INT 1
111029: PLUS
111030: PPUSH
111031: CALL_OW 1
111035: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
111036: LD_ADDR_EXP 173
111040: PUSH
111041: LD_EXP 173
111045: PPUSH
111046: LD_VAR 0 5
111050: PUSH
111051: LD_EXP 173
111055: PUSH
111056: LD_VAR 0 5
111060: ARRAY
111061: PUSH
111062: LD_INT 1
111064: PLUS
111065: PUSH
111066: EMPTY
111067: LIST
111068: LIST
111069: PPUSH
111070: LD_VAR 0 2
111074: PUSH
111075: LD_VAR 0 4
111079: ARRAY
111080: PUSH
111081: LD_VAR 0 2
111085: PUSH
111086: LD_VAR 0 4
111090: ARRAY
111091: PPUSH
111092: CALL_OW 255
111096: PUSH
111097: EMPTY
111098: LIST
111099: LIST
111100: PPUSH
111101: CALL 22554 0 3
111105: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
111106: LD_VAR 0 2
111110: PUSH
111111: LD_VAR 0 4
111115: ARRAY
111116: PPUSH
111117: LD_VAR 0 1
111121: PPUSH
111122: CALL_OW 255
111126: PPUSH
111127: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
111131: LD_VAR 0 2
111135: PUSH
111136: LD_VAR 0 4
111140: ARRAY
111141: PPUSH
111142: CALL_OW 141
// end ;
111146: GO 110978
111148: POP
111149: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111150: LD_VAR 0 1
111154: PPUSH
111155: LD_EXP 173
111159: PUSH
111160: LD_VAR 0 5
111164: ARRAY
111165: PUSH
111166: LD_INT 0
111168: PLUS
111169: PPUSH
111170: CALL_OW 505
// end ;
111174: LD_VAR 0 3
111178: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
111179: LD_INT 0
111181: PPUSH
111182: PPUSH
111183: PPUSH
111184: PPUSH
// if not hack in hackTanks then
111185: LD_VAR 0 1
111189: PUSH
111190: LD_EXP 172
111194: IN
111195: NOT
111196: IFFALSE 111200
// exit ;
111198: GO 111444
// index := GetElementIndex ( hackTanks , hack ) ;
111200: LD_ADDR_VAR 0 4
111204: PUSH
111205: LD_EXP 172
111209: PPUSH
111210: LD_VAR 0 1
111214: PPUSH
111215: CALL 22337 0 2
111219: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111220: LD_ADDR_VAR 0 3
111224: PUSH
111225: DOUBLE
111226: LD_EXP 173
111230: PUSH
111231: LD_VAR 0 4
111235: ARRAY
111236: INC
111237: ST_TO_ADDR
111238: LD_INT 1
111240: PUSH
111241: FOR_DOWNTO
111242: IFFALSE 111418
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111244: LD_ADDR_VAR 0 5
111248: PUSH
111249: LD_EXP 173
111253: PUSH
111254: LD_VAR 0 4
111258: ARRAY
111259: PUSH
111260: LD_VAR 0 3
111264: ARRAY
111265: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111266: LD_VAR 0 5
111270: PUSH
111271: LD_INT 1
111273: ARRAY
111274: PPUSH
111275: CALL_OW 302
111279: NOT
111280: IFTRUE 111308
111282: PUSH
111283: LD_VAR 0 5
111287: PUSH
111288: LD_INT 1
111290: ARRAY
111291: PPUSH
111292: CALL_OW 255
111296: PUSH
111297: LD_VAR 0 1
111301: PPUSH
111302: CALL_OW 255
111306: NONEQUAL
111307: OR
111308: IFFALSE 111416
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111310: LD_VAR 0 5
111314: PUSH
111315: LD_INT 1
111317: ARRAY
111318: PPUSH
111319: CALL_OW 305
111323: IFFALSE 111351
111325: PUSH
111326: LD_VAR 0 5
111330: PUSH
111331: LD_INT 1
111333: ARRAY
111334: PPUSH
111335: CALL_OW 255
111339: PUSH
111340: LD_VAR 0 1
111344: PPUSH
111345: CALL_OW 255
111349: EQUAL
111350: AND
111351: IFFALSE 111375
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111353: LD_VAR 0 5
111357: PUSH
111358: LD_INT 1
111360: ARRAY
111361: PPUSH
111362: LD_VAR 0 5
111366: PUSH
111367: LD_INT 2
111369: ARRAY
111370: PPUSH
111371: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111375: LD_ADDR_EXP 173
111379: PUSH
111380: LD_EXP 173
111384: PPUSH
111385: LD_VAR 0 4
111389: PPUSH
111390: LD_EXP 173
111394: PUSH
111395: LD_VAR 0 4
111399: ARRAY
111400: PPUSH
111401: LD_VAR 0 3
111405: PPUSH
111406: CALL_OW 3
111410: PPUSH
111411: CALL_OW 1
111415: ST_TO_ADDR
// end ; end ;
111416: GO 111241
111418: POP
111419: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111420: LD_VAR 0 1
111424: PPUSH
111425: LD_EXP 173
111429: PUSH
111430: LD_VAR 0 4
111434: ARRAY
111435: PUSH
111436: LD_INT 0
111438: PLUS
111439: PPUSH
111440: CALL_OW 505
// end ;
111444: LD_VAR 0 2
111448: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111449: LD_INT 0
111451: PPUSH
111452: PPUSH
111453: PPUSH
111454: PPUSH
// if not hack in hackTanks then
111455: LD_VAR 0 1
111459: PUSH
111460: LD_EXP 172
111464: IN
111465: NOT
111466: IFFALSE 111470
// exit ;
111468: GO 111555
// index := GetElementIndex ( hackTanks , hack ) ;
111470: LD_ADDR_VAR 0 5
111474: PUSH
111475: LD_EXP 172
111479: PPUSH
111480: LD_VAR 0 1
111484: PPUSH
111485: CALL 22337 0 2
111489: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111490: LD_ADDR_VAR 0 4
111494: PUSH
111495: DOUBLE
111496: LD_INT 1
111498: DEC
111499: ST_TO_ADDR
111500: LD_EXP 173
111504: PUSH
111505: LD_VAR 0 5
111509: ARRAY
111510: PUSH
111511: FOR_TO
111512: IFFALSE 111553
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111514: LD_EXP 173
111518: PUSH
111519: LD_VAR 0 5
111523: ARRAY
111524: PUSH
111525: LD_VAR 0 4
111529: ARRAY
111530: PUSH
111531: LD_INT 1
111533: ARRAY
111534: PUSH
111535: LD_VAR 0 2
111539: EQUAL
111540: IFFALSE 111551
// KillUnit ( vehicle ) ;
111542: LD_VAR 0 2
111546: PPUSH
111547: CALL_OW 66
111551: GO 111511
111553: POP
111554: POP
// end ;
111555: LD_VAR 0 3
111559: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
111560: LD_EXP 177
111564: NOT
111565: IFFALSE 111698
111567: GO 111569
111569: DISABLE
111570: LD_INT 0
111572: PPUSH
// begin initMiner := true ;
111573: LD_ADDR_EXP 177
111577: PUSH
111578: LD_INT 1
111580: ST_TO_ADDR
// minersList := [ ] ;
111581: LD_ADDR_EXP 178
111585: PUSH
111586: EMPTY
111587: ST_TO_ADDR
// minerMinesList := [ ] ;
111588: LD_ADDR_EXP 179
111592: PUSH
111593: EMPTY
111594: ST_TO_ADDR
// minesLimitPerVehicle := 10 ;
111595: LD_ADDR_EXP 180
111599: PUSH
111600: LD_INT 10
111602: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111603: LD_ADDR_VAR 0 1
111607: PUSH
111608: LD_INT 34
111610: PUSH
111611: LD_INT 81
111613: PUSH
111614: EMPTY
111615: LIST
111616: LIST
111617: PPUSH
111618: CALL_OW 69
111622: PUSH
111623: FOR_IN
111624: IFFALSE 111696
// begin if not i in minersList then
111626: LD_VAR 0 1
111630: PUSH
111631: LD_EXP 178
111635: IN
111636: NOT
111637: IFFALSE 111694
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111639: LD_ADDR_EXP 178
111643: PUSH
111644: LD_EXP 178
111648: PPUSH
111649: LD_EXP 178
111653: PUSH
111654: LD_INT 1
111656: PLUS
111657: PPUSH
111658: LD_VAR 0 1
111662: PPUSH
111663: CALL_OW 1
111667: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111668: LD_ADDR_EXP 179
111672: PUSH
111673: LD_EXP 179
111677: PPUSH
111678: LD_EXP 179
111682: PUSH
111683: LD_INT 1
111685: PLUS
111686: PPUSH
111687: EMPTY
111688: PPUSH
111689: CALL_OW 1
111693: ST_TO_ADDR
// end end ;
111694: GO 111623
111696: POP
111697: POP
// end ;
111698: PPOPN 1
111700: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
111701: LD_EXP 177
111705: IFFALSE 111736
111707: PUSH
111708: LD_EXP 179
111712: PPUSH
111713: CALL 19636 0 1
111717: IFTRUE 111735
111719: PUSH
111720: LD_INT 34
111722: PUSH
111723: LD_INT 81
111725: PUSH
111726: EMPTY
111727: LIST
111728: LIST
111729: PPUSH
111730: CALL_OW 69
111734: OR
111735: AND
111736: IFFALSE 112256
111738: GO 111740
111740: DISABLE
111741: LD_INT 0
111743: PPUSH
111744: PPUSH
111745: PPUSH
111746: PPUSH
// begin enable ;
111747: ENABLE
// for i := minerMinesList downto 1 do
111748: LD_ADDR_VAR 0 1
111752: PUSH
111753: DOUBLE
111754: LD_EXP 179
111758: INC
111759: ST_TO_ADDR
111760: LD_INT 1
111762: PUSH
111763: FOR_DOWNTO
111764: IFFALSE 112254
// begin side := GetSide ( minersList [ i ] ) ;
111766: LD_ADDR_VAR 0 3
111770: PUSH
111771: LD_EXP 178
111775: PUSH
111776: LD_VAR 0 1
111780: ARRAY
111781: PPUSH
111782: CALL_OW 255
111786: ST_TO_ADDR
// if IsLive ( minersList [ i ] ) and side in [ your_side , 9 ] then
111787: LD_EXP 178
111791: PUSH
111792: LD_VAR 0 1
111796: ARRAY
111797: PPUSH
111798: CALL_OW 300
111802: IFFALSE 111823
111804: PUSH
111805: LD_VAR 0 3
111809: PUSH
111810: LD_OWVAR 2
111814: PUSH
111815: LD_INT 9
111817: PUSH
111818: EMPTY
111819: LIST
111820: LIST
111821: IN
111822: AND
111823: IFFALSE 111856
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
111825: LD_EXP 178
111829: PUSH
111830: LD_VAR 0 1
111834: ARRAY
111835: PPUSH
111836: LD_EXP 179
111840: PUSH
111841: LD_VAR 0 1
111845: ARRAY
111846: PPUSH
111847: CALL 19636 0 1
111851: PPUSH
111852: CALL_OW 505
// if not minerMinesList [ i ] then
111856: LD_EXP 179
111860: PUSH
111861: LD_VAR 0 1
111865: ARRAY
111866: NOT
111867: IFFALSE 111871
// continue ;
111869: GO 111763
// for j := minerMinesList [ i ] downto 1 do
111871: LD_ADDR_VAR 0 2
111875: PUSH
111876: DOUBLE
111877: LD_EXP 179
111881: PUSH
111882: LD_VAR 0 1
111886: ARRAY
111887: INC
111888: ST_TO_ADDR
111889: LD_INT 1
111891: PUSH
111892: FOR_DOWNTO
111893: IFFALSE 112250
// begin if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
111895: LD_EXP 178
111899: PUSH
111900: LD_VAR 0 1
111904: ARRAY
111905: PPUSH
111906: CALL_OW 301
111910: IFTRUE 111930
111912: PUSH
111913: LD_EXP 178
111917: PUSH
111918: LD_VAR 0 1
111922: ARRAY
111923: PPUSH
111924: CALL_OW 305
111928: NOT
111929: OR
111930: IFFALSE 112021
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111932: LD_EXP 179
111936: PUSH
111937: LD_VAR 0 1
111941: ARRAY
111942: PUSH
111943: LD_VAR 0 2
111947: ARRAY
111948: PUSH
111949: LD_INT 1
111951: ARRAY
111952: PPUSH
111953: LD_EXP 179
111957: PUSH
111958: LD_VAR 0 1
111962: ARRAY
111963: PUSH
111964: LD_VAR 0 2
111968: ARRAY
111969: PUSH
111970: LD_INT 2
111972: ARRAY
111973: PPUSH
111974: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111978: LD_ADDR_EXP 179
111982: PUSH
111983: LD_EXP 179
111987: PPUSH
111988: LD_VAR 0 1
111992: PPUSH
111993: LD_EXP 179
111997: PUSH
111998: LD_VAR 0 1
112002: ARRAY
112003: PPUSH
112004: LD_VAR 0 2
112008: PPUSH
112009: CALL_OW 3
112013: PPUSH
112014: CALL_OW 1
112018: ST_TO_ADDR
// continue ;
112019: GO 111892
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
112021: LD_ADDR_VAR 0 4
112025: PUSH
112026: LD_EXP 179
112030: PUSH
112031: LD_VAR 0 1
112035: ARRAY
112036: PUSH
112037: LD_VAR 0 2
112041: ARRAY
112042: PUSH
112043: LD_INT 1
112045: ARRAY
112046: PPUSH
112047: LD_EXP 179
112051: PUSH
112052: LD_VAR 0 1
112056: ARRAY
112057: PUSH
112058: LD_VAR 0 2
112062: ARRAY
112063: PUSH
112064: LD_INT 2
112066: ARRAY
112067: PPUSH
112068: CALL_OW 428
112072: ST_TO_ADDR
// if not tmp then
112073: LD_VAR 0 4
112077: NOT
112078: IFFALSE 112082
// continue ;
112080: GO 111892
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
112082: LD_VAR 0 4
112086: PUSH
112087: LD_INT 81
112089: PUSH
112090: LD_VAR 0 3
112094: PUSH
112095: EMPTY
112096: LIST
112097: LIST
112098: PPUSH
112099: CALL_OW 69
112103: IN
112104: IFFALSE 112154
112106: PUSH
112107: LD_EXP 179
112111: PUSH
112112: LD_VAR 0 1
112116: ARRAY
112117: PUSH
112118: LD_VAR 0 2
112122: ARRAY
112123: PUSH
112124: LD_INT 1
112126: ARRAY
112127: PPUSH
112128: LD_EXP 179
112132: PUSH
112133: LD_VAR 0 1
112137: ARRAY
112138: PUSH
112139: LD_VAR 0 2
112143: ARRAY
112144: PUSH
112145: LD_INT 2
112147: ARRAY
112148: PPUSH
112149: CALL_OW 458
112153: AND
112154: IFFALSE 112248
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
112156: LD_EXP 179
112160: PUSH
112161: LD_VAR 0 1
112165: ARRAY
112166: PUSH
112167: LD_VAR 0 2
112171: ARRAY
112172: PUSH
112173: LD_INT 1
112175: ARRAY
112176: PPUSH
112177: LD_EXP 179
112181: PUSH
112182: LD_VAR 0 1
112186: ARRAY
112187: PUSH
112188: LD_VAR 0 2
112192: ARRAY
112193: PUSH
112194: LD_INT 2
112196: ARRAY
112197: PPUSH
112198: LD_VAR 0 3
112202: PPUSH
112203: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
112207: LD_ADDR_EXP 179
112211: PUSH
112212: LD_EXP 179
112216: PPUSH
112217: LD_VAR 0 1
112221: PPUSH
112222: LD_EXP 179
112226: PUSH
112227: LD_VAR 0 1
112231: ARRAY
112232: PPUSH
112233: LD_VAR 0 2
112237: PPUSH
112238: CALL_OW 3
112242: PPUSH
112243: CALL_OW 1
112247: ST_TO_ADDR
// end ; end ;
112248: GO 111892
112250: POP
112251: POP
// end ;
112252: GO 111763
112254: POP
112255: POP
// end ;
112256: PPOPN 4
112258: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
112259: LD_INT 0
112261: PPUSH
112262: PPUSH
112263: PPUSH
112264: PPUSH
// result := false ;
112265: LD_ADDR_VAR 0 4
112269: PUSH
112270: LD_INT 0
112272: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
112273: LD_VAR 0 1
112277: PPUSH
112278: CALL_OW 264
112282: PUSH
112283: LD_INT 81
112285: EQUAL
112286: NOT
112287: IFFALSE 112291
// exit ;
112289: GO 112661
// side := GetSide ( unit ) ;
112291: LD_ADDR_VAR 0 6
112295: PUSH
112296: LD_VAR 0 1
112300: PPUSH
112301: CALL_OW 255
112305: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
112306: LD_ADDR_VAR 0 5
112310: PUSH
112311: LD_EXP 178
112315: PPUSH
112316: LD_VAR 0 1
112320: PPUSH
112321: CALL 22337 0 2
112325: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
112326: LD_EXP 179
112330: PUSH
112331: LD_VAR 0 5
112335: ARRAY
112336: PUSH
112337: LD_EXP 180
112341: GREATEREQUAL
112342: IFFALSE 112346
// exit ;
112344: GO 112661
// ComMoveXY ( unit , x , y ) ;
112346: LD_VAR 0 1
112350: PPUSH
112351: LD_VAR 0 2
112355: PPUSH
112356: LD_VAR 0 3
112360: PPUSH
112361: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112365: LD_INT 35
112367: PPUSH
112368: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
112372: LD_VAR 0 1
112376: PPUSH
112377: LD_VAR 0 2
112381: PPUSH
112382: LD_VAR 0 3
112386: PPUSH
112387: CALL 54393 0 3
112391: NOT
112392: IFFALSE 112405
112394: PUSH
112395: LD_VAR 0 1
112399: PPUSH
112400: CALL_OW 314
112404: AND
112405: IFFALSE 112409
// exit ;
112407: GO 112661
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112409: LD_VAR 0 2
112413: PPUSH
112414: LD_VAR 0 3
112418: PPUSH
112419: CALL_OW 428
112423: PUSH
112424: LD_VAR 0 1
112428: EQUAL
112429: IFFALSE 112443
112431: PUSH
112432: LD_VAR 0 1
112436: PPUSH
112437: CALL_OW 314
112441: NOT
112442: AND
112443: IFFALSE 112365
// if MineAtPos ( x , y ) then
112445: LD_VAR 0 2
112449: PPUSH
112450: LD_VAR 0 3
112454: PPUSH
112455: CALL_OW 458
112459: IFFALSE 112463
// exit ;
112461: GO 112661
// if your_side = side then
112463: LD_OWVAR 2
112467: PUSH
112468: LD_VAR 0 6
112472: EQUAL
112473: IFFALSE 112492
// PlaySoundXY ( x , y , PlantMine ) ;
112475: LD_VAR 0 2
112479: PPUSH
112480: LD_VAR 0 3
112484: PPUSH
112485: LD_STRING PlantMine
112487: PPUSH
112488: CALL_OW 366
// repeat wait ( 1 ) ;
112492: LD_INT 1
112494: PPUSH
112495: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
112499: LD_VAR 0 2
112503: PPUSH
112504: LD_VAR 0 3
112508: PPUSH
112509: LD_VAR 0 6
112513: PPUSH
112514: LD_INT 0
112516: PPUSH
112517: CALL_OW 454
112521: IFFALSE 112492
// if MineAtPos ( x , y ) then
112523: LD_VAR 0 2
112527: PPUSH
112528: LD_VAR 0 3
112532: PPUSH
112533: CALL_OW 458
112537: IFFALSE 112653
// begin for i in minerMinesList [ index ] do
112539: LD_ADDR_VAR 0 7
112543: PUSH
112544: LD_EXP 179
112548: PUSH
112549: LD_VAR 0 5
112553: ARRAY
112554: PUSH
112555: FOR_IN
112556: IFFALSE 112598
// if i [ 1 ] = x and i [ 2 ] = y then
112558: LD_VAR 0 7
112562: PUSH
112563: LD_INT 1
112565: ARRAY
112566: PUSH
112567: LD_VAR 0 2
112571: EQUAL
112572: IFFALSE 112590
112574: PUSH
112575: LD_VAR 0 7
112579: PUSH
112580: LD_INT 2
112582: ARRAY
112583: PUSH
112584: LD_VAR 0 3
112588: EQUAL
112589: AND
112590: IFFALSE 112596
// exit ;
112592: POP
112593: POP
112594: GO 112661
112596: GO 112555
112598: POP
112599: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112600: LD_ADDR_EXP 179
112604: PUSH
112605: LD_EXP 179
112609: PPUSH
112610: LD_VAR 0 5
112614: PUSH
112615: LD_EXP 179
112619: PUSH
112620: LD_VAR 0 5
112624: ARRAY
112625: PUSH
112626: LD_INT 1
112628: PLUS
112629: PUSH
112630: EMPTY
112631: LIST
112632: LIST
112633: PPUSH
112634: LD_VAR 0 2
112638: PUSH
112639: LD_VAR 0 3
112643: PUSH
112644: EMPTY
112645: LIST
112646: LIST
112647: PPUSH
112648: CALL 22554 0 3
112652: ST_TO_ADDR
// end ; result := true ;
112653: LD_ADDR_VAR 0 4
112657: PUSH
112658: LD_INT 1
112660: ST_TO_ADDR
// end ;
112661: LD_VAR 0 4
112665: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112666: LD_INT 0
112668: PPUSH
112669: PPUSH
112670: PPUSH
// if not unit in minersList then
112671: LD_VAR 0 1
112675: PUSH
112676: LD_EXP 178
112680: IN
112681: NOT
112682: IFFALSE 112686
// exit ;
112684: GO 112893
// index := GetElementIndex ( minersList , unit ) ;
112686: LD_ADDR_VAR 0 6
112690: PUSH
112691: LD_EXP 178
112695: PPUSH
112696: LD_VAR 0 1
112700: PPUSH
112701: CALL 22337 0 2
112705: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112706: LD_ADDR_VAR 0 5
112710: PUSH
112711: DOUBLE
112712: LD_EXP 179
112716: PUSH
112717: LD_VAR 0 6
112721: ARRAY
112722: INC
112723: ST_TO_ADDR
112724: LD_INT 1
112726: PUSH
112727: FOR_DOWNTO
112728: IFFALSE 112891
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112730: LD_EXP 179
112734: PUSH
112735: LD_VAR 0 6
112739: ARRAY
112740: PUSH
112741: LD_VAR 0 5
112745: ARRAY
112746: PUSH
112747: LD_INT 1
112749: ARRAY
112750: PPUSH
112751: LD_EXP 179
112755: PUSH
112756: LD_VAR 0 6
112760: ARRAY
112761: PUSH
112762: LD_VAR 0 5
112766: ARRAY
112767: PUSH
112768: LD_INT 2
112770: ARRAY
112771: PPUSH
112772: LD_VAR 0 2
112776: PPUSH
112777: LD_VAR 0 3
112781: PPUSH
112782: CALL_OW 298
112786: PUSH
112787: LD_INT 6
112789: LESS
112790: IFFALSE 112889
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112792: LD_EXP 179
112796: PUSH
112797: LD_VAR 0 6
112801: ARRAY
112802: PUSH
112803: LD_VAR 0 5
112807: ARRAY
112808: PUSH
112809: LD_INT 1
112811: ARRAY
112812: PPUSH
112813: LD_EXP 179
112817: PUSH
112818: LD_VAR 0 6
112822: ARRAY
112823: PUSH
112824: LD_VAR 0 5
112828: ARRAY
112829: PUSH
112830: LD_INT 2
112832: ARRAY
112833: PPUSH
112834: LD_VAR 0 1
112838: PPUSH
112839: CALL_OW 255
112843: PPUSH
112844: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112848: LD_ADDR_EXP 179
112852: PUSH
112853: LD_EXP 179
112857: PPUSH
112858: LD_VAR 0 6
112862: PPUSH
112863: LD_EXP 179
112867: PUSH
112868: LD_VAR 0 6
112872: ARRAY
112873: PPUSH
112874: LD_VAR 0 5
112878: PPUSH
112879: CALL_OW 3
112883: PPUSH
112884: CALL_OW 1
112888: ST_TO_ADDR
// end ; end ;
112889: GO 112727
112891: POP
112892: POP
// end ;
112893: LD_VAR 0 4
112897: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112898: LD_INT 0
112900: PPUSH
112901: PPUSH
112902: PPUSH
112903: PPUSH
112904: PPUSH
112905: PPUSH
112906: PPUSH
112907: PPUSH
112908: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112909: LD_VAR 0 1
112913: PPUSH
112914: CALL_OW 264
112918: PUSH
112919: LD_INT 81
112921: EQUAL
112922: NOT
112923: IFTRUE 112938
112925: PUSH
112926: LD_VAR 0 1
112930: PUSH
112931: LD_EXP 178
112935: IN
112936: NOT
112937: OR
112938: IFFALSE 112942
// exit ;
112940: GO 113268
// index := GetElementIndex ( minersList , unit ) ;
112942: LD_ADDR_VAR 0 6
112946: PUSH
112947: LD_EXP 178
112951: PPUSH
112952: LD_VAR 0 1
112956: PPUSH
112957: CALL 22337 0 2
112961: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112962: LD_ADDR_VAR 0 8
112966: PUSH
112967: LD_EXP 180
112971: PUSH
112972: LD_EXP 179
112976: PUSH
112977: LD_VAR 0 6
112981: ARRAY
112982: MINUS
112983: ST_TO_ADDR
// if not minesFreeAmount then
112984: LD_VAR 0 8
112988: NOT
112989: IFFALSE 112993
// exit ;
112991: GO 113268
// tmp := [ ] ;
112993: LD_ADDR_VAR 0 7
112997: PUSH
112998: EMPTY
112999: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
113000: LD_ADDR_VAR 0 5
113004: PUSH
113005: DOUBLE
113006: LD_INT 1
113008: DEC
113009: ST_TO_ADDR
113010: LD_VAR 0 8
113014: PUSH
113015: FOR_TO
113016: IFFALSE 113215
// begin _d := rand ( 0 , 5 ) ;
113018: LD_ADDR_VAR 0 11
113022: PUSH
113023: LD_INT 0
113025: PPUSH
113026: LD_INT 5
113028: PPUSH
113029: CALL_OW 12
113033: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
113034: LD_ADDR_VAR 0 12
113038: PUSH
113039: LD_INT 2
113041: PPUSH
113042: LD_INT 6
113044: PPUSH
113045: CALL_OW 12
113049: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
113050: LD_ADDR_VAR 0 9
113054: PUSH
113055: LD_VAR 0 2
113059: PPUSH
113060: LD_VAR 0 11
113064: PPUSH
113065: LD_VAR 0 12
113069: PPUSH
113070: CALL_OW 272
113074: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
113075: LD_ADDR_VAR 0 10
113079: PUSH
113080: LD_VAR 0 3
113084: PPUSH
113085: LD_VAR 0 11
113089: PPUSH
113090: LD_VAR 0 12
113094: PPUSH
113095: CALL_OW 273
113099: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
113100: LD_VAR 0 9
113104: PPUSH
113105: LD_VAR 0 10
113109: PPUSH
113110: CALL_OW 488
113114: IFFALSE 113138
113116: PUSH
113117: LD_VAR 0 9
113121: PUSH
113122: LD_VAR 0 10
113126: PUSH
113127: EMPTY
113128: LIST
113129: LIST
113130: PUSH
113131: LD_VAR 0 7
113135: IN
113136: NOT
113137: AND
113138: IFFALSE 113157
113140: PUSH
113141: LD_VAR 0 9
113145: PPUSH
113146: LD_VAR 0 10
113150: PPUSH
113151: CALL_OW 458
113155: NOT
113156: AND
113157: IFFALSE 113199
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
113159: LD_ADDR_VAR 0 7
113163: PUSH
113164: LD_VAR 0 7
113168: PPUSH
113169: LD_VAR 0 7
113173: PUSH
113174: LD_INT 1
113176: PLUS
113177: PPUSH
113178: LD_VAR 0 9
113182: PUSH
113183: LD_VAR 0 10
113187: PUSH
113188: EMPTY
113189: LIST
113190: LIST
113191: PPUSH
113192: CALL_OW 1
113196: ST_TO_ADDR
113197: GO 113213
// i := i - 1 ;
113199: LD_ADDR_VAR 0 5
113203: PUSH
113204: LD_VAR 0 5
113208: PUSH
113209: LD_INT 1
113211: MINUS
113212: ST_TO_ADDR
// end ;
113213: GO 113015
113215: POP
113216: POP
// for i in tmp do
113217: LD_ADDR_VAR 0 5
113221: PUSH
113222: LD_VAR 0 7
113226: PUSH
113227: FOR_IN
113228: IFFALSE 113266
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
113230: LD_VAR 0 1
113234: PPUSH
113235: LD_VAR 0 5
113239: PUSH
113240: LD_INT 1
113242: ARRAY
113243: PPUSH
113244: LD_VAR 0 5
113248: PUSH
113249: LD_INT 2
113251: ARRAY
113252: PPUSH
113253: CALL 112259 0 3
113257: NOT
113258: IFFALSE 113264
// exit ;
113260: POP
113261: POP
113262: GO 113268
113264: GO 113227
113266: POP
113267: POP
// end ;
113268: LD_VAR 0 4
113272: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
113273: LD_INT 0
113275: PPUSH
113276: PPUSH
113277: PPUSH
113278: PPUSH
113279: PPUSH
113280: PPUSH
113281: PPUSH
113282: PPUSH
113283: PPUSH
// if GetClass ( unit ) <> class_sniper then
113284: LD_VAR 0 1
113288: PPUSH
113289: CALL_OW 257
113293: PUSH
113294: LD_INT 5
113296: NONEQUAL
113297: IFFALSE 113301
// exit ;
113299: GO 113771
// dist := 8 ;
113301: LD_ADDR_VAR 0 5
113305: PUSH
113306: LD_INT 8
113308: ST_TO_ADDR
// viewRange := 12 ;
113309: LD_ADDR_VAR 0 8
113313: PUSH
113314: LD_INT 12
113316: ST_TO_ADDR
// side := GetSide ( unit ) ;
113317: LD_ADDR_VAR 0 6
113321: PUSH
113322: LD_VAR 0 1
113326: PPUSH
113327: CALL_OW 255
113331: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113332: LD_INT 61
113334: PPUSH
113335: LD_VAR 0 6
113339: PPUSH
113340: CALL_OW 321
113344: PUSH
113345: LD_INT 2
113347: EQUAL
113348: IFFALSE 113358
// viewRange := 16 ;
113350: LD_ADDR_VAR 0 8
113354: PUSH
113355: LD_INT 16
113357: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113358: LD_VAR 0 1
113362: PPUSH
113363: LD_VAR 0 2
113367: PPUSH
113368: LD_VAR 0 3
113372: PPUSH
113373: CALL_OW 297
113377: PUSH
113378: LD_VAR 0 5
113382: GREATER
113383: IFFALSE 113462
// begin ComMoveXY ( unit , x , y ) ;
113385: LD_VAR 0 1
113389: PPUSH
113390: LD_VAR 0 2
113394: PPUSH
113395: LD_VAR 0 3
113399: PPUSH
113400: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113404: LD_INT 35
113406: PPUSH
113407: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113411: LD_VAR 0 1
113415: PPUSH
113416: LD_VAR 0 2
113420: PPUSH
113421: LD_VAR 0 3
113425: PPUSH
113426: CALL 54393 0 3
113430: NOT
113431: IFFALSE 113435
// exit ;
113433: GO 113771
// until GetDistUnitXY ( unit , x , y ) < dist ;
113435: LD_VAR 0 1
113439: PPUSH
113440: LD_VAR 0 2
113444: PPUSH
113445: LD_VAR 0 3
113449: PPUSH
113450: CALL_OW 297
113454: PUSH
113455: LD_VAR 0 5
113459: LESS
113460: IFFALSE 113404
// end ; ComTurnXY ( unit , x , y ) ;
113462: LD_VAR 0 1
113466: PPUSH
113467: LD_VAR 0 2
113471: PPUSH
113472: LD_VAR 0 3
113476: PPUSH
113477: CALL_OW 118
// repeat if Multiplayer then
113481: LD_OWVAR 4
113485: IFFALSE 113496
// wait ( 35 ) else
113487: LD_INT 35
113489: PPUSH
113490: CALL_OW 67
113494: GO 113503
// wait ( 5 ) ;
113496: LD_INT 5
113498: PPUSH
113499: CALL_OW 67
// _d := GetDir ( unit ) ;
113503: LD_ADDR_VAR 0 11
113507: PUSH
113508: LD_VAR 0 1
113512: PPUSH
113513: CALL_OW 254
113517: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
113518: LD_ADDR_VAR 0 7
113522: PUSH
113523: LD_VAR 0 1
113527: PPUSH
113528: CALL_OW 250
113532: PPUSH
113533: LD_VAR 0 1
113537: PPUSH
113538: CALL_OW 251
113542: PPUSH
113543: LD_VAR 0 2
113547: PPUSH
113548: LD_VAR 0 3
113552: PPUSH
113553: CALL 57029 0 4
113557: ST_TO_ADDR
// until dir = _d ;
113558: LD_VAR 0 7
113562: PUSH
113563: LD_VAR 0 11
113567: EQUAL
113568: IFFALSE 113481
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
113570: LD_ADDR_VAR 0 9
113574: PUSH
113575: LD_VAR 0 1
113579: PPUSH
113580: CALL_OW 250
113584: PPUSH
113585: LD_VAR 0 7
113589: PPUSH
113590: LD_VAR 0 5
113594: PPUSH
113595: CALL_OW 272
113599: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
113600: LD_ADDR_VAR 0 10
113604: PUSH
113605: LD_VAR 0 1
113609: PPUSH
113610: CALL_OW 251
113614: PPUSH
113615: LD_VAR 0 7
113619: PPUSH
113620: LD_VAR 0 5
113624: PPUSH
113625: CALL_OW 273
113629: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113630: LD_VAR 0 9
113634: PPUSH
113635: LD_VAR 0 10
113639: PPUSH
113640: CALL_OW 488
113644: NOT
113645: IFFALSE 113649
// exit ;
113647: GO 113771
// ComAnimCustom ( unit , 1 ) ;
113649: LD_VAR 0 1
113653: PPUSH
113654: LD_INT 1
113656: PPUSH
113657: CALL_OW 592
// p := 0 ;
113661: LD_ADDR_VAR 0 12
113665: PUSH
113666: LD_INT 0
113668: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113669: LD_VAR 0 9
113673: PPUSH
113674: LD_VAR 0 10
113678: PPUSH
113679: LD_VAR 0 6
113683: PPUSH
113684: LD_VAR 0 8
113688: PPUSH
113689: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
113693: LD_INT 35
113695: PPUSH
113696: CALL_OW 67
// p := Inc ( p ) ;
113700: LD_ADDR_VAR 0 12
113704: PUSH
113705: LD_VAR 0 12
113709: PPUSH
113710: CALL 56985 0 1
113714: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
113715: LD_VAR 0 12
113719: PUSH
113720: LD_INT 3
113722: EQUAL
113723: IFTRUE 113737
113725: PUSH
113726: LD_VAR 0 1
113730: PPUSH
113731: CALL_OW 302
113735: NOT
113736: OR
113737: IFTRUE 113750
113739: PUSH
113740: LD_VAR 0 1
113744: PPUSH
113745: CALL_OW 301
113749: OR
113750: IFFALSE 113693
// RemoveSeeing ( _x , _y , side ) ;
113752: LD_VAR 0 9
113756: PPUSH
113757: LD_VAR 0 10
113761: PPUSH
113762: LD_VAR 0 6
113766: PPUSH
113767: CALL_OW 331
// end ;
113771: LD_VAR 0 4
113775: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
113776: LD_INT 0
113778: PPUSH
113779: PPUSH
113780: PPUSH
113781: PPUSH
113782: PPUSH
113783: PPUSH
113784: PPUSH
113785: PPUSH
113786: PPUSH
113787: PPUSH
113788: PPUSH
// if not unit then
113789: LD_VAR 0 1
113793: NOT
113794: IFFALSE 113798
// exit ;
113796: GO 114069
// side := GetSide ( unit ) ;
113798: LD_ADDR_VAR 0 3
113802: PUSH
113803: LD_VAR 0 1
113807: PPUSH
113808: CALL_OW 255
113812: ST_TO_ADDR
// x := GetX ( unit ) ;
113813: LD_ADDR_VAR 0 5
113817: PUSH
113818: LD_VAR 0 1
113822: PPUSH
113823: CALL_OW 250
113827: ST_TO_ADDR
// y := GetY ( unit ) ;
113828: LD_ADDR_VAR 0 6
113832: PUSH
113833: LD_VAR 0 1
113837: PPUSH
113838: CALL_OW 251
113842: ST_TO_ADDR
// r := 8 ;
113843: LD_ADDR_VAR 0 4
113847: PUSH
113848: LD_INT 8
113850: ST_TO_ADDR
// if x - r < 0 then
113851: LD_VAR 0 5
113855: PUSH
113856: LD_VAR 0 4
113860: MINUS
113861: PUSH
113862: LD_INT 0
113864: LESS
113865: IFFALSE 113877
// min_x := 0 else
113867: LD_ADDR_VAR 0 7
113871: PUSH
113872: LD_INT 0
113874: ST_TO_ADDR
113875: GO 113893
// min_x := x - r ;
113877: LD_ADDR_VAR 0 7
113881: PUSH
113882: LD_VAR 0 5
113886: PUSH
113887: LD_VAR 0 4
113891: MINUS
113892: ST_TO_ADDR
// if y - r < 0 then
113893: LD_VAR 0 6
113897: PUSH
113898: LD_VAR 0 4
113902: MINUS
113903: PUSH
113904: LD_INT 0
113906: LESS
113907: IFFALSE 113919
// min_y := 0 else
113909: LD_ADDR_VAR 0 8
113913: PUSH
113914: LD_INT 0
113916: ST_TO_ADDR
113917: GO 113935
// min_y := y - r ;
113919: LD_ADDR_VAR 0 8
113923: PUSH
113924: LD_VAR 0 6
113928: PUSH
113929: LD_VAR 0 4
113933: MINUS
113934: ST_TO_ADDR
// max_x := x + r ;
113935: LD_ADDR_VAR 0 9
113939: PUSH
113940: LD_VAR 0 5
113944: PUSH
113945: LD_VAR 0 4
113949: PLUS
113950: ST_TO_ADDR
// max_y := y + r ;
113951: LD_ADDR_VAR 0 10
113955: PUSH
113956: LD_VAR 0 6
113960: PUSH
113961: LD_VAR 0 4
113965: PLUS
113966: ST_TO_ADDR
// for _x = min_x to max_x do
113967: LD_ADDR_VAR 0 11
113971: PUSH
113972: DOUBLE
113973: LD_VAR 0 7
113977: DEC
113978: ST_TO_ADDR
113979: LD_VAR 0 9
113983: PUSH
113984: FOR_TO
113985: IFFALSE 114067
// for _y = min_y to max_y do
113987: LD_ADDR_VAR 0 12
113991: PUSH
113992: DOUBLE
113993: LD_VAR 0 8
113997: DEC
113998: ST_TO_ADDR
113999: LD_VAR 0 10
114003: PUSH
114004: FOR_TO
114005: IFFALSE 114063
// begin if not ValidHex ( _x , _y ) then
114007: LD_VAR 0 11
114011: PPUSH
114012: LD_VAR 0 12
114016: PPUSH
114017: CALL_OW 488
114021: NOT
114022: IFFALSE 114026
// continue ;
114024: GO 114004
// if MineAtPos ( _x , _y ) then
114026: LD_VAR 0 11
114030: PPUSH
114031: LD_VAR 0 12
114035: PPUSH
114036: CALL_OW 458
114040: IFFALSE 114061
// ViewMineAtPos ( _x , _y , side ) ;
114042: LD_VAR 0 11
114046: PPUSH
114047: LD_VAR 0 12
114051: PPUSH
114052: LD_VAR 0 3
114056: PPUSH
114057: CALL_OW 457
// end ;
114061: GO 114004
114063: POP
114064: POP
114065: GO 113984
114067: POP
114068: POP
// end ;
114069: LD_VAR 0 2
114073: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer , side ; begin
114074: LD_INT 0
114076: PPUSH
114077: PPUSH
114078: PPUSH
114079: PPUSH
114080: PPUSH
114081: PPUSH
114082: PPUSH
// if not units then
114083: LD_VAR 0 1
114087: NOT
114088: IFFALSE 114092
// exit ;
114090: GO 114556
// scaners := [ ] ;
114092: LD_ADDR_VAR 0 6
114096: PUSH
114097: EMPTY
114098: ST_TO_ADDR
// for i in units do
114099: LD_ADDR_VAR 0 3
114103: PUSH
114104: LD_VAR 0 1
114108: PUSH
114109: FOR_IN
114110: IFFALSE 114267
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
114112: LD_VAR 0 3
114116: PPUSH
114117: CALL_OW 264
114121: PUSH
114122: LD_INT 11
114124: NONEQUAL
114125: IFTRUE 114139
114127: PUSH
114128: LD_VAR 0 3
114132: PPUSH
114133: CALL_OW 302
114137: NOT
114138: OR
114139: IFTRUE 114156
114141: PUSH
114142: LD_VAR 0 3
114146: PPUSH
114147: CALL_OW 110
114151: PUSH
114152: LD_INT 502
114154: EQUAL
114155: OR
114156: IFFALSE 114160
// continue ;
114158: GO 114109
// ComStop ( i ) ;
114160: LD_VAR 0 3
114164: PPUSH
114165: CALL_OW 141
// x := GetX ( i ) ;
114169: LD_ADDR_VAR 0 4
114173: PUSH
114174: LD_VAR 0 3
114178: PPUSH
114179: CALL_OW 250
114183: ST_TO_ADDR
// y := GetY ( i ) ;
114184: LD_ADDR_VAR 0 5
114188: PUSH
114189: LD_VAR 0 3
114193: PPUSH
114194: CALL_OW 251
114198: ST_TO_ADDR
// if GetSide ( i ) = your_side then
114199: LD_VAR 0 3
114203: PPUSH
114204: CALL_OW 255
114208: PUSH
114209: LD_OWVAR 2
114213: EQUAL
114214: IFFALSE 114233
// PlaySoundXY ( x , y , mineDetector ) ;
114216: LD_VAR 0 4
114220: PPUSH
114221: LD_VAR 0 5
114225: PPUSH
114226: LD_STRING mineDetector
114228: PPUSH
114229: CALL_OW 366
// scaners := Join ( scaners , i ) ;
114233: LD_ADDR_VAR 0 6
114237: PUSH
114238: LD_VAR 0 6
114242: PPUSH
114243: LD_VAR 0 3
114247: PPUSH
114248: CALL 55612 0 2
114252: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
114253: LD_VAR 0 3
114257: PPUSH
114258: LD_INT 502
114260: PPUSH
114261: CALL_OW 109
// end ;
114265: GO 114109
114267: POP
114268: POP
// if not scaners then
114269: LD_VAR 0 6
114273: NOT
114274: IFFALSE 114278
// exit ;
114276: GO 114556
// wait ( 3 ) ;
114278: LD_INT 3
114280: PPUSH
114281: CALL_OW 67
// timer := 6 ;
114285: LD_ADDR_VAR 0 7
114289: PUSH
114290: LD_INT 6
114292: ST_TO_ADDR
// repeat for i in scaners do
114293: LD_ADDR_VAR 0 3
114297: PUSH
114298: LD_VAR 0 6
114302: PUSH
114303: FOR_IN
114304: IFFALSE 114454
// begin side := GetSide ( i ) ;
114306: LD_ADDR_VAR 0 8
114310: PUSH
114311: LD_VAR 0 3
114315: PPUSH
114316: CALL_OW 255
114320: ST_TO_ADDR
// if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
114321: LD_VAR 0 3
114325: PPUSH
114326: CALL_OW 302
114330: NOT
114331: IFTRUE 114344
114333: PUSH
114334: LD_VAR 0 3
114338: PPUSH
114339: CALL_OW 314
114343: OR
114344: IFTRUE 114375
114346: PUSH
114347: LD_VAR 0 3
114351: PPUSH
114352: CALL_OW 263
114356: PUSH
114357: LD_INT 1
114359: EQUAL
114360: IFFALSE 114374
114362: PUSH
114363: LD_VAR 0 3
114367: PPUSH
114368: CALL_OW 311
114372: NOT
114373: AND
114374: OR
114375: IFFALSE 114419
// begin SetUnitDisplayNumber ( i , 0 ) ;
114377: LD_VAR 0 3
114381: PPUSH
114382: LD_INT 0
114384: PPUSH
114385: CALL_OW 505
// SetTag ( i , 0 ) ;
114389: LD_VAR 0 3
114393: PPUSH
114394: LD_INT 0
114396: PPUSH
114397: CALL_OW 109
// scaners := scaners diff i ;
114401: LD_ADDR_VAR 0 6
114405: PUSH
114406: LD_VAR 0 6
114410: PUSH
114411: LD_VAR 0 3
114415: DIFF
114416: ST_TO_ADDR
// continue ;
114417: GO 114303
// end ; if side in [ your_side , 9 ] then
114419: LD_VAR 0 8
114423: PUSH
114424: LD_OWVAR 2
114428: PUSH
114429: LD_INT 9
114431: PUSH
114432: EMPTY
114433: LIST
114434: LIST
114435: IN
114436: IFFALSE 114452
// SetUnitDisplayNumber ( i , timer ) ;
114438: LD_VAR 0 3
114442: PPUSH
114443: LD_VAR 0 7
114447: PPUSH
114448: CALL_OW 505
// end ;
114452: GO 114303
114454: POP
114455: POP
// if not scaners then
114456: LD_VAR 0 6
114460: NOT
114461: IFFALSE 114465
// exit ;
114463: GO 114556
// timer := Dec ( timer ) ;
114465: LD_ADDR_VAR 0 7
114469: PUSH
114470: LD_VAR 0 7
114474: PPUSH
114475: CALL 57007 0 1
114479: ST_TO_ADDR
// wait ( 0 0$1 ) ;
114480: LD_INT 35
114482: PPUSH
114483: CALL_OW 67
// until timer = 0 ;
114487: LD_VAR 0 7
114491: PUSH
114492: LD_INT 0
114494: EQUAL
114495: IFFALSE 114293
// if not scaners then
114497: LD_VAR 0 6
114501: NOT
114502: IFFALSE 114506
// exit ;
114504: GO 114556
// for i in scaners do
114506: LD_ADDR_VAR 0 3
114510: PUSH
114511: LD_VAR 0 6
114515: PUSH
114516: FOR_IN
114517: IFFALSE 114554
// begin SetUnitDisplayNumber ( i , 0 ) ;
114519: LD_VAR 0 3
114523: PPUSH
114524: LD_INT 0
114526: PPUSH
114527: CALL_OW 505
// SetTag ( i , 0 ) ;
114531: LD_VAR 0 3
114535: PPUSH
114536: LD_INT 0
114538: PPUSH
114539: CALL_OW 109
// RevealDetectorMine ( i ) ;
114543: LD_VAR 0 3
114547: PPUSH
114548: CALL 113776 0 1
// end ;
114552: GO 114516
114554: POP
114555: POP
// end ;
114556: LD_VAR 0 2
114560: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
114561: LD_INT 0
114563: PPUSH
// if p1 = mine_detector_mode then
114564: LD_VAR 0 2
114568: PUSH
114569: LD_INT 103
114571: EQUAL
114572: IFFALSE 114583
// DetectMine ( units ) ;
114574: LD_VAR 0 1
114578: PPUSH
114579: CALL 114074 0 1
// end ; end_of_file
114583: LD_VAR 0 7
114587: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114588: LD_INT 0
114590: PPUSH
114591: PPUSH
114592: PPUSH
114593: PPUSH
114594: PPUSH
114595: PPUSH
114596: PPUSH
114597: PPUSH
114598: PPUSH
114599: PPUSH
114600: PPUSH
114601: PPUSH
114602: PPUSH
114603: PPUSH
114604: PPUSH
114605: PPUSH
114606: PPUSH
114607: PPUSH
114608: PPUSH
114609: PPUSH
114610: PPUSH
114611: PPUSH
114612: PPUSH
114613: PPUSH
114614: PPUSH
114615: PPUSH
114616: PPUSH
114617: PPUSH
114618: PPUSH
114619: PPUSH
114620: PPUSH
114621: PPUSH
114622: PPUSH
114623: PPUSH
// if not list then
114624: LD_VAR 0 1
114628: NOT
114629: IFFALSE 114633
// exit ;
114631: GO 119352
// base := list [ 1 ] ;
114633: LD_ADDR_VAR 0 3
114637: PUSH
114638: LD_VAR 0 1
114642: PUSH
114643: LD_INT 1
114645: ARRAY
114646: ST_TO_ADDR
// group := list [ 2 ] ;
114647: LD_ADDR_VAR 0 4
114651: PUSH
114652: LD_VAR 0 1
114656: PUSH
114657: LD_INT 2
114659: ARRAY
114660: ST_TO_ADDR
// path := list [ 3 ] ;
114661: LD_ADDR_VAR 0 5
114665: PUSH
114666: LD_VAR 0 1
114670: PUSH
114671: LD_INT 3
114673: ARRAY
114674: ST_TO_ADDR
// flags := list [ 4 ] ;
114675: LD_ADDR_VAR 0 6
114679: PUSH
114680: LD_VAR 0 1
114684: PUSH
114685: LD_INT 4
114687: ARRAY
114688: ST_TO_ADDR
// mined := [ ] ;
114689: LD_ADDR_VAR 0 27
114693: PUSH
114694: EMPTY
114695: ST_TO_ADDR
// bombed := [ ] ;
114696: LD_ADDR_VAR 0 28
114700: PUSH
114701: EMPTY
114702: ST_TO_ADDR
// healers := [ ] ;
114703: LD_ADDR_VAR 0 31
114707: PUSH
114708: EMPTY
114709: ST_TO_ADDR
// to_heal := [ ] ;
114710: LD_ADDR_VAR 0 30
114714: PUSH
114715: EMPTY
114716: ST_TO_ADDR
// repairs := [ ] ;
114717: LD_ADDR_VAR 0 33
114721: PUSH
114722: EMPTY
114723: ST_TO_ADDR
// to_repair := [ ] ;
114724: LD_ADDR_VAR 0 32
114728: PUSH
114729: EMPTY
114730: ST_TO_ADDR
// if not group or not path then
114731: LD_VAR 0 4
114735: NOT
114736: IFTRUE 114745
114738: PUSH
114739: LD_VAR 0 5
114743: NOT
114744: OR
114745: IFFALSE 114749
// exit ;
114747: GO 119352
// side := GetSide ( group [ 1 ] ) ;
114749: LD_ADDR_VAR 0 35
114753: PUSH
114754: LD_VAR 0 4
114758: PUSH
114759: LD_INT 1
114761: ARRAY
114762: PPUSH
114763: CALL_OW 255
114767: ST_TO_ADDR
// if flags then
114768: LD_VAR 0 6
114772: IFFALSE 114916
// begin f_ignore_area := flags [ 1 ] ;
114774: LD_ADDR_VAR 0 17
114778: PUSH
114779: LD_VAR 0 6
114783: PUSH
114784: LD_INT 1
114786: ARRAY
114787: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114788: LD_ADDR_VAR 0 18
114792: PUSH
114793: LD_VAR 0 6
114797: PUSH
114798: LD_INT 2
114800: ARRAY
114801: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114802: LD_ADDR_VAR 0 19
114806: PUSH
114807: LD_VAR 0 6
114811: PUSH
114812: LD_INT 3
114814: ARRAY
114815: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114816: LD_ADDR_VAR 0 20
114820: PUSH
114821: LD_VAR 0 6
114825: PUSH
114826: LD_INT 4
114828: ARRAY
114829: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114830: LD_ADDR_VAR 0 21
114834: PUSH
114835: LD_VAR 0 6
114839: PUSH
114840: LD_INT 5
114842: ARRAY
114843: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114844: LD_ADDR_VAR 0 22
114848: PUSH
114849: LD_VAR 0 6
114853: PUSH
114854: LD_INT 6
114856: ARRAY
114857: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114858: LD_ADDR_VAR 0 23
114862: PUSH
114863: LD_VAR 0 6
114867: PUSH
114868: LD_INT 7
114870: ARRAY
114871: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114872: LD_ADDR_VAR 0 24
114876: PUSH
114877: LD_VAR 0 6
114881: PUSH
114882: LD_INT 8
114884: ARRAY
114885: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114886: LD_ADDR_VAR 0 25
114890: PUSH
114891: LD_VAR 0 6
114895: PUSH
114896: LD_INT 9
114898: ARRAY
114899: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114900: LD_ADDR_VAR 0 26
114904: PUSH
114905: LD_VAR 0 6
114909: PUSH
114910: LD_INT 10
114912: ARRAY
114913: ST_TO_ADDR
// end else
114914: GO 114996
// begin f_ignore_area := false ;
114916: LD_ADDR_VAR 0 17
114920: PUSH
114921: LD_INT 0
114923: ST_TO_ADDR
// f_capture := false ;
114924: LD_ADDR_VAR 0 18
114928: PUSH
114929: LD_INT 0
114931: ST_TO_ADDR
// f_ignore_civ := false ;
114932: LD_ADDR_VAR 0 19
114936: PUSH
114937: LD_INT 0
114939: ST_TO_ADDR
// f_murder := false ;
114940: LD_ADDR_VAR 0 20
114944: PUSH
114945: LD_INT 0
114947: ST_TO_ADDR
// f_mines := false ;
114948: LD_ADDR_VAR 0 21
114952: PUSH
114953: LD_INT 0
114955: ST_TO_ADDR
// f_repair := false ;
114956: LD_ADDR_VAR 0 22
114960: PUSH
114961: LD_INT 0
114963: ST_TO_ADDR
// f_heal := false ;
114964: LD_ADDR_VAR 0 23
114968: PUSH
114969: LD_INT 0
114971: ST_TO_ADDR
// f_spacetime := false ;
114972: LD_ADDR_VAR 0 24
114976: PUSH
114977: LD_INT 0
114979: ST_TO_ADDR
// f_attack_depot := false ;
114980: LD_ADDR_VAR 0 25
114984: PUSH
114985: LD_INT 0
114987: ST_TO_ADDR
// f_crawl := false ;
114988: LD_ADDR_VAR 0 26
114992: PUSH
114993: LD_INT 0
114995: ST_TO_ADDR
// end ; if f_heal then
114996: LD_VAR 0 23
115000: IFFALSE 115027
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
115002: LD_ADDR_VAR 0 31
115006: PUSH
115007: LD_VAR 0 4
115011: PPUSH
115012: LD_INT 25
115014: PUSH
115015: LD_INT 4
115017: PUSH
115018: EMPTY
115019: LIST
115020: LIST
115021: PPUSH
115022: CALL_OW 72
115026: ST_TO_ADDR
// if f_repair then
115027: LD_VAR 0 22
115031: IFFALSE 115058
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
115033: LD_ADDR_VAR 0 33
115037: PUSH
115038: LD_VAR 0 4
115042: PPUSH
115043: LD_INT 25
115045: PUSH
115046: LD_INT 3
115048: PUSH
115049: EMPTY
115050: LIST
115051: LIST
115052: PPUSH
115053: CALL_OW 72
115057: ST_TO_ADDR
// units_path := [ ] ;
115058: LD_ADDR_VAR 0 16
115062: PUSH
115063: EMPTY
115064: ST_TO_ADDR
// for i = 1 to group do
115065: LD_ADDR_VAR 0 7
115069: PUSH
115070: DOUBLE
115071: LD_INT 1
115073: DEC
115074: ST_TO_ADDR
115075: LD_VAR 0 4
115079: PUSH
115080: FOR_TO
115081: IFFALSE 115110
// units_path := Replace ( units_path , i , path ) ;
115083: LD_ADDR_VAR 0 16
115087: PUSH
115088: LD_VAR 0 16
115092: PPUSH
115093: LD_VAR 0 7
115097: PPUSH
115098: LD_VAR 0 5
115102: PPUSH
115103: CALL_OW 1
115107: ST_TO_ADDR
115108: GO 115080
115110: POP
115111: POP
// repeat for i = group downto 1 do
115112: LD_ADDR_VAR 0 7
115116: PUSH
115117: DOUBLE
115118: LD_VAR 0 4
115122: INC
115123: ST_TO_ADDR
115124: LD_INT 1
115126: PUSH
115127: FOR_DOWNTO
115128: IFFALSE 119304
// begin wait ( 5 ) ;
115130: LD_INT 5
115132: PPUSH
115133: CALL_OW 67
// tmp := [ ] ;
115137: LD_ADDR_VAR 0 14
115141: PUSH
115142: EMPTY
115143: ST_TO_ADDR
// attacking := false ;
115144: LD_ADDR_VAR 0 29
115148: PUSH
115149: LD_INT 0
115151: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
115152: LD_VAR 0 4
115156: PUSH
115157: LD_VAR 0 7
115161: ARRAY
115162: PPUSH
115163: CALL_OW 301
115167: IFTRUE 115182
115169: PUSH
115170: LD_VAR 0 4
115174: PUSH
115175: LD_VAR 0 7
115179: ARRAY
115180: NOT
115181: OR
115182: IFFALSE 115291
// begin if GetType ( group [ i ] ) = unit_human then
115184: LD_VAR 0 4
115188: PUSH
115189: LD_VAR 0 7
115193: ARRAY
115194: PPUSH
115195: CALL_OW 247
115199: PUSH
115200: LD_INT 1
115202: EQUAL
115203: IFFALSE 115249
// begin to_heal := to_heal diff group [ i ] ;
115205: LD_ADDR_VAR 0 30
115209: PUSH
115210: LD_VAR 0 30
115214: PUSH
115215: LD_VAR 0 4
115219: PUSH
115220: LD_VAR 0 7
115224: ARRAY
115225: DIFF
115226: ST_TO_ADDR
// healers := healers diff group [ i ] ;
115227: LD_ADDR_VAR 0 31
115231: PUSH
115232: LD_VAR 0 31
115236: PUSH
115237: LD_VAR 0 4
115241: PUSH
115242: LD_VAR 0 7
115246: ARRAY
115247: DIFF
115248: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
115249: LD_ADDR_VAR 0 4
115253: PUSH
115254: LD_VAR 0 4
115258: PPUSH
115259: LD_VAR 0 7
115263: PPUSH
115264: CALL_OW 3
115268: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
115269: LD_ADDR_VAR 0 16
115273: PUSH
115274: LD_VAR 0 16
115278: PPUSH
115279: LD_VAR 0 7
115283: PPUSH
115284: CALL_OW 3
115288: ST_TO_ADDR
// continue ;
115289: GO 115127
// end ; if f_repair then
115291: LD_VAR 0 22
115295: IFFALSE 115792
// begin if GetType ( group [ i ] ) = unit_vehicle then
115297: LD_VAR 0 4
115301: PUSH
115302: LD_VAR 0 7
115306: ARRAY
115307: PPUSH
115308: CALL_OW 247
115312: PUSH
115313: LD_INT 2
115315: EQUAL
115316: IFFALSE 115510
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
115318: LD_VAR 0 4
115322: PUSH
115323: LD_VAR 0 7
115327: ARRAY
115328: PPUSH
115329: CALL_OW 256
115333: PUSH
115334: LD_INT 700
115336: LESS
115337: IFFALSE 115358
115339: PUSH
115340: LD_VAR 0 4
115344: PUSH
115345: LD_VAR 0 7
115349: ARRAY
115350: PUSH
115351: LD_VAR 0 32
115355: IN
115356: NOT
115357: AND
115358: IFFALSE 115382
// to_repair := to_repair union group [ i ] ;
115360: LD_ADDR_VAR 0 32
115364: PUSH
115365: LD_VAR 0 32
115369: PUSH
115370: LD_VAR 0 4
115374: PUSH
115375: LD_VAR 0 7
115379: ARRAY
115380: UNION
115381: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
115382: LD_VAR 0 4
115386: PUSH
115387: LD_VAR 0 7
115391: ARRAY
115392: PPUSH
115393: CALL_OW 256
115397: PUSH
115398: LD_INT 1000
115400: EQUAL
115401: IFFALSE 115421
115403: PUSH
115404: LD_VAR 0 4
115408: PUSH
115409: LD_VAR 0 7
115413: ARRAY
115414: PUSH
115415: LD_VAR 0 32
115419: IN
115420: AND
115421: IFFALSE 115445
// to_repair := to_repair diff group [ i ] ;
115423: LD_ADDR_VAR 0 32
115427: PUSH
115428: LD_VAR 0 32
115432: PUSH
115433: LD_VAR 0 4
115437: PUSH
115438: LD_VAR 0 7
115442: ARRAY
115443: DIFF
115444: ST_TO_ADDR
// if group [ i ] in to_repair then
115445: LD_VAR 0 4
115449: PUSH
115450: LD_VAR 0 7
115454: ARRAY
115455: PUSH
115456: LD_VAR 0 32
115460: IN
115461: IFFALSE 115508
// begin if not IsInArea ( group [ i ] , f_repair ) then
115463: LD_VAR 0 4
115467: PUSH
115468: LD_VAR 0 7
115472: ARRAY
115473: PPUSH
115474: LD_VAR 0 22
115478: PPUSH
115479: CALL_OW 308
115483: NOT
115484: IFFALSE 115506
// ComMoveToArea ( group [ i ] , f_repair ) ;
115486: LD_VAR 0 4
115490: PUSH
115491: LD_VAR 0 7
115495: ARRAY
115496: PPUSH
115497: LD_VAR 0 22
115501: PPUSH
115502: CALL_OW 113
// continue ;
115506: GO 115127
// end ; end else
115508: GO 115792
// if group [ i ] in repairs then
115510: LD_VAR 0 4
115514: PUSH
115515: LD_VAR 0 7
115519: ARRAY
115520: PUSH
115521: LD_VAR 0 33
115525: IN
115526: IFFALSE 115792
// begin if IsInUnit ( group [ i ] ) then
115528: LD_VAR 0 4
115532: PUSH
115533: LD_VAR 0 7
115537: ARRAY
115538: PPUSH
115539: CALL_OW 310
115543: IFFALSE 115613
// begin z := IsInUnit ( group [ i ] ) ;
115545: LD_ADDR_VAR 0 13
115549: PUSH
115550: LD_VAR 0 4
115554: PUSH
115555: LD_VAR 0 7
115559: ARRAY
115560: PPUSH
115561: CALL_OW 310
115565: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115566: LD_VAR 0 13
115570: PUSH
115571: LD_VAR 0 32
115575: IN
115576: IFFALSE 115594
115578: PUSH
115579: LD_VAR 0 13
115583: PPUSH
115584: LD_VAR 0 22
115588: PPUSH
115589: CALL_OW 308
115593: AND
115594: IFFALSE 115611
// ComExitVehicle ( group [ i ] ) ;
115596: LD_VAR 0 4
115600: PUSH
115601: LD_VAR 0 7
115605: ARRAY
115606: PPUSH
115607: CALL_OW 121
// end else
115611: GO 115792
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115613: LD_ADDR_VAR 0 13
115617: PUSH
115618: LD_VAR 0 4
115622: PPUSH
115623: LD_INT 95
115625: PUSH
115626: LD_VAR 0 22
115630: PUSH
115631: EMPTY
115632: LIST
115633: LIST
115634: PUSH
115635: LD_INT 58
115637: PUSH
115638: EMPTY
115639: LIST
115640: PUSH
115641: EMPTY
115642: LIST
115643: LIST
115644: PPUSH
115645: CALL_OW 72
115649: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115650: LD_VAR 0 4
115654: PUSH
115655: LD_VAR 0 7
115659: ARRAY
115660: PPUSH
115661: CALL_OW 314
115665: NOT
115666: IFFALSE 115790
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115668: LD_ADDR_VAR 0 10
115672: PUSH
115673: LD_VAR 0 13
115677: PPUSH
115678: LD_VAR 0 4
115682: PUSH
115683: LD_VAR 0 7
115687: ARRAY
115688: PPUSH
115689: CALL_OW 74
115693: ST_TO_ADDR
// if not x then
115694: LD_VAR 0 10
115698: NOT
115699: IFFALSE 115703
// continue ;
115701: GO 115127
// if GetLives ( x ) < 1000 then
115703: LD_VAR 0 10
115707: PPUSH
115708: CALL_OW 256
115712: PUSH
115713: LD_INT 1000
115715: LESS
115716: IFFALSE 115740
// ComRepairVehicle ( group [ i ] , x ) else
115718: LD_VAR 0 4
115722: PUSH
115723: LD_VAR 0 7
115727: ARRAY
115728: PPUSH
115729: LD_VAR 0 10
115733: PPUSH
115734: CALL_OW 129
115738: GO 115790
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115740: LD_VAR 0 23
115744: IFFALSE 115767
115746: PUSH
115747: LD_VAR 0 4
115751: PUSH
115752: LD_VAR 0 7
115756: ARRAY
115757: PPUSH
115758: CALL_OW 256
115762: PUSH
115763: LD_INT 1000
115765: LESS
115766: AND
115767: NOT
115768: IFFALSE 115790
// ComEnterUnit ( group [ i ] , x ) ;
115770: LD_VAR 0 4
115774: PUSH
115775: LD_VAR 0 7
115779: ARRAY
115780: PPUSH
115781: LD_VAR 0 10
115785: PPUSH
115786: CALL_OW 120
// end ; continue ;
115790: GO 115127
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115792: LD_VAR 0 23
115796: IFFALSE 115819
115798: PUSH
115799: LD_VAR 0 4
115803: PUSH
115804: LD_VAR 0 7
115808: ARRAY
115809: PPUSH
115810: CALL_OW 247
115814: PUSH
115815: LD_INT 1
115817: EQUAL
115818: AND
115819: IFFALSE 116303
// begin if group [ i ] in healers then
115821: LD_VAR 0 4
115825: PUSH
115826: LD_VAR 0 7
115830: ARRAY
115831: PUSH
115832: LD_VAR 0 31
115836: IN
115837: IFFALSE 116114
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115839: LD_VAR 0 4
115843: PUSH
115844: LD_VAR 0 7
115848: ARRAY
115849: PPUSH
115850: LD_VAR 0 23
115854: PPUSH
115855: CALL_OW 308
115859: NOT
115860: IFFALSE 115880
115862: PUSH
115863: LD_VAR 0 4
115867: PUSH
115868: LD_VAR 0 7
115872: ARRAY
115873: PPUSH
115874: CALL_OW 314
115878: NOT
115879: AND
115880: IFFALSE 115904
// ComMoveToArea ( group [ i ] , f_heal ) else
115882: LD_VAR 0 4
115886: PUSH
115887: LD_VAR 0 7
115891: ARRAY
115892: PPUSH
115893: LD_VAR 0 23
115897: PPUSH
115898: CALL_OW 113
115902: GO 116112
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115904: LD_VAR 0 4
115908: PUSH
115909: LD_VAR 0 7
115913: ARRAY
115914: PPUSH
115915: CALL 52968 0 1
115919: PPUSH
115920: CALL_OW 256
115924: PUSH
115925: LD_INT 1000
115927: EQUAL
115928: IFFALSE 115947
// ComStop ( group [ i ] ) else
115930: LD_VAR 0 4
115934: PUSH
115935: LD_VAR 0 7
115939: ARRAY
115940: PPUSH
115941: CALL_OW 141
115945: GO 116112
// if not HasTask ( group [ i ] ) and to_heal then
115947: LD_VAR 0 4
115951: PUSH
115952: LD_VAR 0 7
115956: ARRAY
115957: PPUSH
115958: CALL_OW 314
115962: NOT
115963: IFFALSE 115971
115965: PUSH
115966: LD_VAR 0 30
115970: AND
115971: IFFALSE 116112
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115973: LD_ADDR_VAR 0 13
115977: PUSH
115978: LD_VAR 0 30
115982: PPUSH
115983: LD_INT 3
115985: PUSH
115986: LD_INT 54
115988: PUSH
115989: EMPTY
115990: LIST
115991: PUSH
115992: EMPTY
115993: LIST
115994: LIST
115995: PPUSH
115996: CALL_OW 72
116000: PPUSH
116001: LD_VAR 0 4
116005: PUSH
116006: LD_VAR 0 7
116010: ARRAY
116011: PPUSH
116012: CALL_OW 74
116016: ST_TO_ADDR
// if z then
116017: LD_VAR 0 13
116021: IFFALSE 116112
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
116023: LD_INT 91
116025: PUSH
116026: LD_VAR 0 13
116030: PUSH
116031: LD_INT 10
116033: PUSH
116034: EMPTY
116035: LIST
116036: LIST
116037: LIST
116038: PUSH
116039: LD_INT 81
116041: PUSH
116042: LD_VAR 0 13
116046: PPUSH
116047: CALL_OW 255
116051: PUSH
116052: EMPTY
116053: LIST
116054: LIST
116055: PUSH
116056: EMPTY
116057: LIST
116058: LIST
116059: PPUSH
116060: CALL_OW 69
116064: PUSH
116065: LD_INT 0
116067: EQUAL
116068: IFFALSE 116092
// ComHeal ( group [ i ] , z ) else
116070: LD_VAR 0 4
116074: PUSH
116075: LD_VAR 0 7
116079: ARRAY
116080: PPUSH
116081: LD_VAR 0 13
116085: PPUSH
116086: CALL_OW 128
116090: GO 116112
// ComMoveToArea ( group [ i ] , f_heal ) ;
116092: LD_VAR 0 4
116096: PUSH
116097: LD_VAR 0 7
116101: ARRAY
116102: PPUSH
116103: LD_VAR 0 23
116107: PPUSH
116108: CALL_OW 113
// end ; continue ;
116112: GO 115127
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
116114: LD_VAR 0 4
116118: PUSH
116119: LD_VAR 0 7
116123: ARRAY
116124: PPUSH
116125: CALL_OW 256
116129: PUSH
116130: LD_INT 700
116132: LESS
116133: IFFALSE 116154
116135: PUSH
116136: LD_VAR 0 4
116140: PUSH
116141: LD_VAR 0 7
116145: ARRAY
116146: PUSH
116147: LD_VAR 0 30
116151: IN
116152: NOT
116153: AND
116154: IFFALSE 116178
// to_heal := to_heal union group [ i ] ;
116156: LD_ADDR_VAR 0 30
116160: PUSH
116161: LD_VAR 0 30
116165: PUSH
116166: LD_VAR 0 4
116170: PUSH
116171: LD_VAR 0 7
116175: ARRAY
116176: UNION
116177: ST_TO_ADDR
// if group [ i ] in to_heal then
116178: LD_VAR 0 4
116182: PUSH
116183: LD_VAR 0 7
116187: ARRAY
116188: PUSH
116189: LD_VAR 0 30
116193: IN
116194: IFFALSE 116303
// begin if GetLives ( group [ i ] ) = 1000 then
116196: LD_VAR 0 4
116200: PUSH
116201: LD_VAR 0 7
116205: ARRAY
116206: PPUSH
116207: CALL_OW 256
116211: PUSH
116212: LD_INT 1000
116214: EQUAL
116215: IFFALSE 116241
// to_heal := to_heal diff group [ i ] else
116217: LD_ADDR_VAR 0 30
116221: PUSH
116222: LD_VAR 0 30
116226: PUSH
116227: LD_VAR 0 4
116231: PUSH
116232: LD_VAR 0 7
116236: ARRAY
116237: DIFF
116238: ST_TO_ADDR
116239: GO 116303
// begin if not IsInArea ( group [ i ] , to_heal ) then
116241: LD_VAR 0 4
116245: PUSH
116246: LD_VAR 0 7
116250: ARRAY
116251: PPUSH
116252: LD_VAR 0 30
116256: PPUSH
116257: CALL_OW 308
116261: NOT
116262: IFFALSE 116286
// ComMoveToArea ( group [ i ] , f_heal ) else
116264: LD_VAR 0 4
116268: PUSH
116269: LD_VAR 0 7
116273: ARRAY
116274: PPUSH
116275: LD_VAR 0 23
116279: PPUSH
116280: CALL_OW 113
116284: GO 116301
// ComHold ( group [ i ] ) ;
116286: LD_VAR 0 4
116290: PUSH
116291: LD_VAR 0 7
116295: ARRAY
116296: PPUSH
116297: CALL_OW 140
// continue ;
116301: GO 115127
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
116303: LD_VAR 0 4
116307: PUSH
116308: LD_VAR 0 7
116312: ARRAY
116313: PPUSH
116314: LD_INT 10
116316: PPUSH
116317: CALL 50567 0 2
116321: NOT
116322: IFFALSE 116340
116324: PUSH
116325: LD_VAR 0 16
116329: PUSH
116330: LD_VAR 0 7
116334: ARRAY
116335: PUSH
116336: EMPTY
116337: EQUAL
116338: NOT
116339: AND
116340: IFFALSE 116606
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
116342: LD_VAR 0 4
116346: PUSH
116347: LD_VAR 0 7
116351: ARRAY
116352: PPUSH
116353: CALL_OW 262
116357: PUSH
116358: LD_INT 1
116360: PUSH
116361: LD_INT 2
116363: PUSH
116364: EMPTY
116365: LIST
116366: LIST
116367: IN
116368: IFFALSE 116409
// if GetFuel ( group [ i ] ) < 10 then
116370: LD_VAR 0 4
116374: PUSH
116375: LD_VAR 0 7
116379: ARRAY
116380: PPUSH
116381: CALL_OW 261
116385: PUSH
116386: LD_INT 10
116388: LESS
116389: IFFALSE 116409
// SetFuel ( group [ i ] , 12 ) ;
116391: LD_VAR 0 4
116395: PUSH
116396: LD_VAR 0 7
116400: ARRAY
116401: PPUSH
116402: LD_INT 12
116404: PPUSH
116405: CALL_OW 240
// if units_path [ i ] then
116409: LD_VAR 0 16
116413: PUSH
116414: LD_VAR 0 7
116418: ARRAY
116419: IFFALSE 116604
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
116421: LD_VAR 0 4
116425: PUSH
116426: LD_VAR 0 7
116430: ARRAY
116431: PPUSH
116432: LD_VAR 0 16
116436: PUSH
116437: LD_VAR 0 7
116441: ARRAY
116442: PUSH
116443: LD_INT 1
116445: ARRAY
116446: PUSH
116447: LD_INT 1
116449: ARRAY
116450: PPUSH
116451: LD_VAR 0 16
116455: PUSH
116456: LD_VAR 0 7
116460: ARRAY
116461: PUSH
116462: LD_INT 1
116464: ARRAY
116465: PUSH
116466: LD_INT 2
116468: ARRAY
116469: PPUSH
116470: CALL_OW 297
116474: PUSH
116475: LD_INT 6
116477: GREATER
116478: IFFALSE 116553
// begin if not HasTask ( group [ i ] ) then
116480: LD_VAR 0 4
116484: PUSH
116485: LD_VAR 0 7
116489: ARRAY
116490: PPUSH
116491: CALL_OW 314
116495: NOT
116496: IFFALSE 116551
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
116498: LD_VAR 0 4
116502: PUSH
116503: LD_VAR 0 7
116507: ARRAY
116508: PPUSH
116509: LD_VAR 0 16
116513: PUSH
116514: LD_VAR 0 7
116518: ARRAY
116519: PUSH
116520: LD_INT 1
116522: ARRAY
116523: PUSH
116524: LD_INT 1
116526: ARRAY
116527: PPUSH
116528: LD_VAR 0 16
116532: PUSH
116533: LD_VAR 0 7
116537: ARRAY
116538: PUSH
116539: LD_INT 1
116541: ARRAY
116542: PUSH
116543: LD_INT 2
116545: ARRAY
116546: PPUSH
116547: CALL_OW 114
// end else
116551: GO 116604
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
116553: LD_ADDR_VAR 0 15
116557: PUSH
116558: LD_VAR 0 16
116562: PUSH
116563: LD_VAR 0 7
116567: ARRAY
116568: PPUSH
116569: LD_INT 1
116571: PPUSH
116572: CALL_OW 3
116576: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
116577: LD_ADDR_VAR 0 16
116581: PUSH
116582: LD_VAR 0 16
116586: PPUSH
116587: LD_VAR 0 7
116591: PPUSH
116592: LD_VAR 0 15
116596: PPUSH
116597: CALL_OW 1
116601: ST_TO_ADDR
// continue ;
116602: GO 115127
// end ; end ; end else
116604: GO 119302
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116606: LD_ADDR_VAR 0 14
116610: PUSH
116611: LD_INT 81
116613: PUSH
116614: LD_VAR 0 4
116618: PUSH
116619: LD_VAR 0 7
116623: ARRAY
116624: PPUSH
116625: CALL_OW 255
116629: PUSH
116630: EMPTY
116631: LIST
116632: LIST
116633: PPUSH
116634: CALL_OW 69
116638: ST_TO_ADDR
// if not tmp then
116639: LD_VAR 0 14
116643: NOT
116644: IFFALSE 116648
// continue ;
116646: GO 115127
// if f_ignore_area then
116648: LD_VAR 0 17
116652: IFFALSE 116740
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116654: LD_ADDR_VAR 0 15
116658: PUSH
116659: LD_VAR 0 14
116663: PPUSH
116664: LD_INT 3
116666: PUSH
116667: LD_INT 92
116669: PUSH
116670: LD_VAR 0 17
116674: PUSH
116675: LD_INT 1
116677: ARRAY
116678: PUSH
116679: LD_VAR 0 17
116683: PUSH
116684: LD_INT 2
116686: ARRAY
116687: PUSH
116688: LD_VAR 0 17
116692: PUSH
116693: LD_INT 3
116695: ARRAY
116696: PUSH
116697: EMPTY
116698: LIST
116699: LIST
116700: LIST
116701: LIST
116702: PUSH
116703: EMPTY
116704: LIST
116705: LIST
116706: PPUSH
116707: CALL_OW 72
116711: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116712: LD_VAR 0 14
116716: PUSH
116717: LD_VAR 0 15
116721: DIFF
116722: IFFALSE 116740
// tmp := tmp diff tmp2 ;
116724: LD_ADDR_VAR 0 14
116728: PUSH
116729: LD_VAR 0 14
116733: PUSH
116734: LD_VAR 0 15
116738: DIFF
116739: ST_TO_ADDR
// end ; if not f_murder then
116740: LD_VAR 0 20
116744: NOT
116745: IFFALSE 116803
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116747: LD_ADDR_VAR 0 15
116751: PUSH
116752: LD_VAR 0 14
116756: PPUSH
116757: LD_INT 3
116759: PUSH
116760: LD_INT 50
116762: PUSH
116763: EMPTY
116764: LIST
116765: PUSH
116766: EMPTY
116767: LIST
116768: LIST
116769: PPUSH
116770: CALL_OW 72
116774: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116775: LD_VAR 0 14
116779: PUSH
116780: LD_VAR 0 15
116784: DIFF
116785: IFFALSE 116803
// tmp := tmp diff tmp2 ;
116787: LD_ADDR_VAR 0 14
116791: PUSH
116792: LD_VAR 0 14
116796: PUSH
116797: LD_VAR 0 15
116801: DIFF
116802: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116803: LD_ADDR_VAR 0 14
116807: PUSH
116808: LD_VAR 0 4
116812: PUSH
116813: LD_VAR 0 7
116817: ARRAY
116818: PPUSH
116819: LD_VAR 0 14
116823: PPUSH
116824: LD_INT 1
116826: PPUSH
116827: LD_INT 1
116829: PPUSH
116830: CALL 22989 0 4
116834: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116835: LD_VAR 0 4
116839: PUSH
116840: LD_VAR 0 7
116844: ARRAY
116845: PPUSH
116846: CALL_OW 257
116850: PUSH
116851: LD_INT 1
116853: EQUAL
116854: IFFALSE 117314
// begin if WantPlant ( group [ i ] ) then
116856: LD_VAR 0 4
116860: PUSH
116861: LD_VAR 0 7
116865: ARRAY
116866: PPUSH
116867: CALL 22490 0 1
116871: IFFALSE 116875
// continue ;
116873: GO 115127
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116875: LD_VAR 0 18
116879: IFFALSE 116899
116881: PUSH
116882: LD_VAR 0 4
116886: PUSH
116887: LD_VAR 0 7
116891: ARRAY
116892: PPUSH
116893: CALL_OW 310
116897: NOT
116898: AND
116899: IFFALSE 116942
116901: PUSH
116902: LD_VAR 0 14
116906: PUSH
116907: LD_INT 1
116909: ARRAY
116910: PUSH
116911: LD_VAR 0 14
116915: PPUSH
116916: LD_INT 21
116918: PUSH
116919: LD_INT 2
116921: PUSH
116922: EMPTY
116923: LIST
116924: LIST
116925: PUSH
116926: LD_INT 58
116928: PUSH
116929: EMPTY
116930: LIST
116931: PUSH
116932: EMPTY
116933: LIST
116934: LIST
116935: PPUSH
116936: CALL_OW 72
116940: IN
116941: AND
116942: IFFALSE 116978
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116944: LD_VAR 0 4
116948: PUSH
116949: LD_VAR 0 7
116953: ARRAY
116954: PPUSH
116955: LD_VAR 0 14
116959: PUSH
116960: LD_INT 1
116962: ARRAY
116963: PPUSH
116964: CALL_OW 120
// attacking := true ;
116968: LD_ADDR_VAR 0 29
116972: PUSH
116973: LD_INT 1
116975: ST_TO_ADDR
// continue ;
116976: GO 115127
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116978: LD_VAR 0 26
116982: IFFALSE 117005
116984: PUSH
116985: LD_VAR 0 4
116989: PUSH
116990: LD_VAR 0 7
116994: ARRAY
116995: PPUSH
116996: CALL_OW 257
117000: PUSH
117001: LD_INT 1
117003: EQUAL
117004: AND
117005: IFFALSE 117028
117007: PUSH
117008: LD_VAR 0 4
117012: PUSH
117013: LD_VAR 0 7
117017: ARRAY
117018: PPUSH
117019: CALL_OW 256
117023: PUSH
117024: LD_INT 800
117026: LESS
117027: AND
117028: IFFALSE 117048
117030: PUSH
117031: LD_VAR 0 4
117035: PUSH
117036: LD_VAR 0 7
117040: ARRAY
117041: PPUSH
117042: CALL_OW 318
117046: NOT
117047: AND
117048: IFFALSE 117065
// ComCrawl ( group [ i ] ) ;
117050: LD_VAR 0 4
117054: PUSH
117055: LD_VAR 0 7
117059: ARRAY
117060: PPUSH
117061: CALL_OW 137
// if f_mines then
117065: LD_VAR 0 21
117069: IFFALSE 117314
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
117071: LD_VAR 0 14
117075: PUSH
117076: LD_INT 1
117078: ARRAY
117079: PPUSH
117080: CALL_OW 247
117084: PUSH
117085: LD_INT 3
117087: EQUAL
117088: IFFALSE 117107
117090: PUSH
117091: LD_VAR 0 14
117095: PUSH
117096: LD_INT 1
117098: ARRAY
117099: PUSH
117100: LD_VAR 0 27
117104: IN
117105: NOT
117106: AND
117107: IFFALSE 117314
// begin x := GetX ( tmp [ 1 ] ) ;
117109: LD_ADDR_VAR 0 10
117113: PUSH
117114: LD_VAR 0 14
117118: PUSH
117119: LD_INT 1
117121: ARRAY
117122: PPUSH
117123: CALL_OW 250
117127: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
117128: LD_ADDR_VAR 0 11
117132: PUSH
117133: LD_VAR 0 14
117137: PUSH
117138: LD_INT 1
117140: ARRAY
117141: PPUSH
117142: CALL_OW 251
117146: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
117147: LD_ADDR_VAR 0 12
117151: PUSH
117152: LD_VAR 0 4
117156: PUSH
117157: LD_VAR 0 7
117161: ARRAY
117162: PPUSH
117163: CALL 50652 0 1
117167: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
117168: LD_VAR 0 4
117172: PUSH
117173: LD_VAR 0 7
117177: ARRAY
117178: PPUSH
117179: LD_VAR 0 10
117183: PPUSH
117184: LD_VAR 0 11
117188: PPUSH
117189: LD_VAR 0 14
117193: PUSH
117194: LD_INT 1
117196: ARRAY
117197: PPUSH
117198: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
117202: LD_VAR 0 4
117206: PUSH
117207: LD_VAR 0 7
117211: ARRAY
117212: PPUSH
117213: LD_VAR 0 10
117217: PPUSH
117218: LD_VAR 0 12
117222: PPUSH
117223: LD_INT 7
117225: PPUSH
117226: CALL_OW 272
117230: PPUSH
117231: LD_VAR 0 11
117235: PPUSH
117236: LD_VAR 0 12
117240: PPUSH
117241: LD_INT 7
117243: PPUSH
117244: CALL_OW 273
117248: PPUSH
117249: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
117253: LD_VAR 0 4
117257: PUSH
117258: LD_VAR 0 7
117262: ARRAY
117263: PPUSH
117264: LD_INT 71
117266: PPUSH
117267: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
117271: LD_ADDR_VAR 0 27
117275: PUSH
117276: LD_VAR 0 27
117280: PPUSH
117281: LD_VAR 0 27
117285: PUSH
117286: LD_INT 1
117288: PLUS
117289: PPUSH
117290: LD_VAR 0 14
117294: PUSH
117295: LD_INT 1
117297: ARRAY
117298: PPUSH
117299: CALL_OW 1
117303: ST_TO_ADDR
// attacking := true ;
117304: LD_ADDR_VAR 0 29
117308: PUSH
117309: LD_INT 1
117311: ST_TO_ADDR
// continue ;
117312: GO 115127
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
117314: LD_VAR 0 4
117318: PUSH
117319: LD_VAR 0 7
117323: ARRAY
117324: PPUSH
117325: CALL_OW 257
117329: PUSH
117330: LD_INT 17
117332: EQUAL
117333: IFFALSE 117357
117335: PUSH
117336: LD_VAR 0 4
117340: PUSH
117341: LD_VAR 0 7
117345: ARRAY
117346: PPUSH
117347: CALL_OW 110
117351: PUSH
117352: LD_INT 71
117354: EQUAL
117355: NOT
117356: AND
117357: IFFALSE 117503
// begin attacking := false ;
117359: LD_ADDR_VAR 0 29
117363: PUSH
117364: LD_INT 0
117366: ST_TO_ADDR
// k := 5 ;
117367: LD_ADDR_VAR 0 9
117371: PUSH
117372: LD_INT 5
117374: ST_TO_ADDR
// if tmp < k then
117375: LD_VAR 0 14
117379: PUSH
117380: LD_VAR 0 9
117384: LESS
117385: IFFALSE 117397
// k := tmp ;
117387: LD_ADDR_VAR 0 9
117391: PUSH
117392: LD_VAR 0 14
117396: ST_TO_ADDR
// for j = 1 to k do
117397: LD_ADDR_VAR 0 8
117401: PUSH
117402: DOUBLE
117403: LD_INT 1
117405: DEC
117406: ST_TO_ADDR
117407: LD_VAR 0 9
117411: PUSH
117412: FOR_TO
117413: IFFALSE 117501
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
117415: LD_VAR 0 14
117419: PUSH
117420: LD_VAR 0 8
117424: ARRAY
117425: PUSH
117426: LD_VAR 0 14
117430: PPUSH
117431: LD_INT 58
117433: PUSH
117434: EMPTY
117435: LIST
117436: PPUSH
117437: CALL_OW 72
117441: IN
117442: NOT
117443: IFFALSE 117499
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117445: LD_VAR 0 4
117449: PUSH
117450: LD_VAR 0 7
117454: ARRAY
117455: PPUSH
117456: LD_VAR 0 14
117460: PUSH
117461: LD_VAR 0 8
117465: ARRAY
117466: PPUSH
117467: CALL_OW 115
// attacking := true ;
117471: LD_ADDR_VAR 0 29
117475: PUSH
117476: LD_INT 1
117478: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
117479: LD_VAR 0 4
117483: PUSH
117484: LD_VAR 0 7
117488: ARRAY
117489: PPUSH
117490: LD_INT 71
117492: PPUSH
117493: CALL_OW 109
// continue ;
117497: GO 117412
// end ; end ;
117499: GO 117412
117501: POP
117502: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
117503: LD_VAR 0 4
117507: PUSH
117508: LD_VAR 0 7
117512: ARRAY
117513: PPUSH
117514: CALL_OW 257
117518: PUSH
117519: LD_INT 8
117521: EQUAL
117522: IFTRUE 117560
117524: PUSH
117525: LD_VAR 0 4
117529: PUSH
117530: LD_VAR 0 7
117534: ARRAY
117535: PPUSH
117536: CALL_OW 264
117540: PUSH
117541: LD_INT 28
117543: PUSH
117544: LD_INT 45
117546: PUSH
117547: LD_INT 7
117549: PUSH
117550: LD_INT 47
117552: PUSH
117553: EMPTY
117554: LIST
117555: LIST
117556: LIST
117557: LIST
117558: IN
117559: OR
117560: IFFALSE 117816
// begin attacking := false ;
117562: LD_ADDR_VAR 0 29
117566: PUSH
117567: LD_INT 0
117569: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
117570: LD_VAR 0 14
117574: PUSH
117575: LD_INT 1
117577: ARRAY
117578: PPUSH
117579: CALL_OW 266
117583: PUSH
117584: LD_INT 32
117586: PUSH
117587: LD_INT 31
117589: PUSH
117590: LD_INT 33
117592: PUSH
117593: LD_INT 4
117595: PUSH
117596: LD_INT 5
117598: PUSH
117599: EMPTY
117600: LIST
117601: LIST
117602: LIST
117603: LIST
117604: LIST
117605: IN
117606: IFFALSE 117792
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117608: LD_ADDR_VAR 0 9
117612: PUSH
117613: LD_VAR 0 14
117617: PUSH
117618: LD_INT 1
117620: ARRAY
117621: PPUSH
117622: CALL_OW 266
117626: PPUSH
117627: LD_VAR 0 14
117631: PUSH
117632: LD_INT 1
117634: ARRAY
117635: PPUSH
117636: CALL_OW 250
117640: PPUSH
117641: LD_VAR 0 14
117645: PUSH
117646: LD_INT 1
117648: ARRAY
117649: PPUSH
117650: CALL_OW 251
117654: PPUSH
117655: LD_VAR 0 14
117659: PUSH
117660: LD_INT 1
117662: ARRAY
117663: PPUSH
117664: CALL_OW 254
117668: PPUSH
117669: LD_VAR 0 14
117673: PUSH
117674: LD_INT 1
117676: ARRAY
117677: PPUSH
117678: CALL_OW 248
117682: PPUSH
117683: LD_INT 0
117685: PPUSH
117686: CALL 32010 0 6
117690: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117691: LD_ADDR_VAR 0 8
117695: PUSH
117696: LD_VAR 0 4
117700: PUSH
117701: LD_VAR 0 7
117705: ARRAY
117706: PPUSH
117707: LD_VAR 0 9
117711: PPUSH
117712: CALL 50765 0 2
117716: ST_TO_ADDR
// if j then
117717: LD_VAR 0 8
117721: IFFALSE 117790
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117723: LD_VAR 0 8
117727: PUSH
117728: LD_INT 1
117730: ARRAY
117731: PPUSH
117732: LD_VAR 0 8
117736: PUSH
117737: LD_INT 2
117739: ARRAY
117740: PPUSH
117741: CALL_OW 488
117745: IFFALSE 117790
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117747: LD_VAR 0 4
117751: PUSH
117752: LD_VAR 0 7
117756: ARRAY
117757: PPUSH
117758: LD_VAR 0 8
117762: PUSH
117763: LD_INT 1
117765: ARRAY
117766: PPUSH
117767: LD_VAR 0 8
117771: PUSH
117772: LD_INT 2
117774: ARRAY
117775: PPUSH
117776: CALL_OW 116
// attacking := true ;
117780: LD_ADDR_VAR 0 29
117784: PUSH
117785: LD_INT 1
117787: ST_TO_ADDR
// continue ;
117788: GO 115127
// end ; end else
117790: GO 117816
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117792: LD_VAR 0 4
117796: PUSH
117797: LD_VAR 0 7
117801: ARRAY
117802: PPUSH
117803: LD_VAR 0 14
117807: PUSH
117808: LD_INT 1
117810: ARRAY
117811: PPUSH
117812: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117816: LD_VAR 0 4
117820: PUSH
117821: LD_VAR 0 7
117825: ARRAY
117826: PPUSH
117827: CALL_OW 265
117831: PUSH
117832: LD_INT 11
117834: EQUAL
117835: IFFALSE 118113
// begin k := 10 ;
117837: LD_ADDR_VAR 0 9
117841: PUSH
117842: LD_INT 10
117844: ST_TO_ADDR
// x := 0 ;
117845: LD_ADDR_VAR 0 10
117849: PUSH
117850: LD_INT 0
117852: ST_TO_ADDR
// if tmp < k then
117853: LD_VAR 0 14
117857: PUSH
117858: LD_VAR 0 9
117862: LESS
117863: IFFALSE 117875
// k := tmp ;
117865: LD_ADDR_VAR 0 9
117869: PUSH
117870: LD_VAR 0 14
117874: ST_TO_ADDR
// for j = k downto 1 do
117875: LD_ADDR_VAR 0 8
117879: PUSH
117880: DOUBLE
117881: LD_VAR 0 9
117885: INC
117886: ST_TO_ADDR
117887: LD_INT 1
117889: PUSH
117890: FOR_DOWNTO
117891: IFFALSE 117966
// begin if GetType ( tmp [ j ] ) = unit_human then
117893: LD_VAR 0 14
117897: PUSH
117898: LD_VAR 0 8
117902: ARRAY
117903: PPUSH
117904: CALL_OW 247
117908: PUSH
117909: LD_INT 1
117911: EQUAL
117912: IFFALSE 117964
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117914: LD_VAR 0 4
117918: PUSH
117919: LD_VAR 0 7
117923: ARRAY
117924: PPUSH
117925: LD_VAR 0 14
117929: PUSH
117930: LD_VAR 0 8
117934: ARRAY
117935: PPUSH
117936: CALL 51023 0 2
// x := tmp [ j ] ;
117940: LD_ADDR_VAR 0 10
117944: PUSH
117945: LD_VAR 0 14
117949: PUSH
117950: LD_VAR 0 8
117954: ARRAY
117955: ST_TO_ADDR
// attacking := true ;
117956: LD_ADDR_VAR 0 29
117960: PUSH
117961: LD_INT 1
117963: ST_TO_ADDR
// end ; end ;
117964: GO 117890
117966: POP
117967: POP
// if not x then
117968: LD_VAR 0 10
117972: NOT
117973: IFFALSE 118113
// begin attacking := true ;
117975: LD_ADDR_VAR 0 29
117979: PUSH
117980: LD_INT 1
117982: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117983: LD_VAR 0 4
117987: PUSH
117988: LD_VAR 0 7
117992: ARRAY
117993: PPUSH
117994: CALL_OW 250
117998: PPUSH
117999: LD_VAR 0 4
118003: PUSH
118004: LD_VAR 0 7
118008: ARRAY
118009: PPUSH
118010: CALL_OW 251
118014: PPUSH
118015: CALL_OW 546
118019: PUSH
118020: LD_INT 2
118022: ARRAY
118023: PUSH
118024: LD_VAR 0 14
118028: PUSH
118029: LD_INT 1
118031: ARRAY
118032: PPUSH
118033: CALL_OW 250
118037: PPUSH
118038: LD_VAR 0 14
118042: PUSH
118043: LD_INT 1
118045: ARRAY
118046: PPUSH
118047: CALL_OW 251
118051: PPUSH
118052: CALL_OW 546
118056: PUSH
118057: LD_INT 2
118059: ARRAY
118060: EQUAL
118061: IFFALSE 118089
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
118063: LD_VAR 0 4
118067: PUSH
118068: LD_VAR 0 7
118072: ARRAY
118073: PPUSH
118074: LD_VAR 0 14
118078: PUSH
118079: LD_INT 1
118081: ARRAY
118082: PPUSH
118083: CALL 51023 0 2
118087: GO 118113
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118089: LD_VAR 0 4
118093: PUSH
118094: LD_VAR 0 7
118098: ARRAY
118099: PPUSH
118100: LD_VAR 0 14
118104: PUSH
118105: LD_INT 1
118107: ARRAY
118108: PPUSH
118109: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
118113: LD_VAR 0 4
118117: PUSH
118118: LD_VAR 0 7
118122: ARRAY
118123: PPUSH
118124: CALL_OW 264
118128: PUSH
118129: LD_INT 29
118131: EQUAL
118132: IFFALSE 118502
// begin if WantsToAttack ( group [ i ] ) in bombed then
118134: LD_VAR 0 4
118138: PUSH
118139: LD_VAR 0 7
118143: ARRAY
118144: PPUSH
118145: CALL_OW 319
118149: PUSH
118150: LD_VAR 0 28
118154: IN
118155: IFFALSE 118159
// continue ;
118157: GO 115127
// k := 8 ;
118159: LD_ADDR_VAR 0 9
118163: PUSH
118164: LD_INT 8
118166: ST_TO_ADDR
// x := 0 ;
118167: LD_ADDR_VAR 0 10
118171: PUSH
118172: LD_INT 0
118174: ST_TO_ADDR
// if tmp < k then
118175: LD_VAR 0 14
118179: PUSH
118180: LD_VAR 0 9
118184: LESS
118185: IFFALSE 118197
// k := tmp ;
118187: LD_ADDR_VAR 0 9
118191: PUSH
118192: LD_VAR 0 14
118196: ST_TO_ADDR
// for j = 1 to k do
118197: LD_ADDR_VAR 0 8
118201: PUSH
118202: DOUBLE
118203: LD_INT 1
118205: DEC
118206: ST_TO_ADDR
118207: LD_VAR 0 9
118211: PUSH
118212: FOR_TO
118213: IFFALSE 118347
// begin if GetType ( tmp [ j ] ) = unit_building then
118215: LD_VAR 0 14
118219: PUSH
118220: LD_VAR 0 8
118224: ARRAY
118225: PPUSH
118226: CALL_OW 247
118230: PUSH
118231: LD_INT 3
118233: EQUAL
118234: IFFALSE 118345
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
118236: LD_VAR 0 14
118240: PUSH
118241: LD_VAR 0 8
118245: ARRAY
118246: PUSH
118247: LD_VAR 0 28
118251: IN
118252: NOT
118253: IFFALSE 118272
118255: PUSH
118256: LD_VAR 0 14
118260: PUSH
118261: LD_VAR 0 8
118265: ARRAY
118266: PPUSH
118267: CALL_OW 313
118271: AND
118272: IFFALSE 118345
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118274: LD_VAR 0 4
118278: PUSH
118279: LD_VAR 0 7
118283: ARRAY
118284: PPUSH
118285: LD_VAR 0 14
118289: PUSH
118290: LD_VAR 0 8
118294: ARRAY
118295: PPUSH
118296: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
118300: LD_ADDR_VAR 0 28
118304: PUSH
118305: LD_VAR 0 28
118309: PPUSH
118310: LD_VAR 0 28
118314: PUSH
118315: LD_INT 1
118317: PLUS
118318: PPUSH
118319: LD_VAR 0 14
118323: PUSH
118324: LD_VAR 0 8
118328: ARRAY
118329: PPUSH
118330: CALL_OW 1
118334: ST_TO_ADDR
// attacking := true ;
118335: LD_ADDR_VAR 0 29
118339: PUSH
118340: LD_INT 1
118342: ST_TO_ADDR
// break ;
118343: GO 118347
// end ; end ;
118345: GO 118212
118347: POP
118348: POP
// if not attacking and f_attack_depot then
118349: LD_VAR 0 29
118353: NOT
118354: IFFALSE 118362
118356: PUSH
118357: LD_VAR 0 25
118361: AND
118362: IFFALSE 118457
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118364: LD_ADDR_VAR 0 13
118368: PUSH
118369: LD_VAR 0 14
118373: PPUSH
118374: LD_INT 2
118376: PUSH
118377: LD_INT 30
118379: PUSH
118380: LD_INT 0
118382: PUSH
118383: EMPTY
118384: LIST
118385: LIST
118386: PUSH
118387: LD_INT 30
118389: PUSH
118390: LD_INT 1
118392: PUSH
118393: EMPTY
118394: LIST
118395: LIST
118396: PUSH
118397: EMPTY
118398: LIST
118399: LIST
118400: LIST
118401: PPUSH
118402: CALL_OW 72
118406: ST_TO_ADDR
// if z then
118407: LD_VAR 0 13
118411: IFFALSE 118457
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
118413: LD_VAR 0 4
118417: PUSH
118418: LD_VAR 0 7
118422: ARRAY
118423: PPUSH
118424: LD_VAR 0 13
118428: PPUSH
118429: LD_VAR 0 4
118433: PUSH
118434: LD_VAR 0 7
118438: ARRAY
118439: PPUSH
118440: CALL_OW 74
118444: PPUSH
118445: CALL_OW 115
// attacking := true ;
118449: LD_ADDR_VAR 0 29
118453: PUSH
118454: LD_INT 1
118456: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
118457: LD_VAR 0 4
118461: PUSH
118462: LD_VAR 0 7
118466: ARRAY
118467: PPUSH
118468: CALL_OW 256
118472: PUSH
118473: LD_INT 500
118475: LESS
118476: IFFALSE 118502
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118478: LD_VAR 0 4
118482: PUSH
118483: LD_VAR 0 7
118487: ARRAY
118488: PPUSH
118489: LD_VAR 0 14
118493: PUSH
118494: LD_INT 1
118496: ARRAY
118497: PPUSH
118498: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
118502: LD_VAR 0 4
118506: PUSH
118507: LD_VAR 0 7
118511: ARRAY
118512: PPUSH
118513: CALL_OW 264
118517: PUSH
118518: LD_INT 49
118520: EQUAL
118521: IFFALSE 118642
// begin if not HasTask ( group [ i ] ) then
118523: LD_VAR 0 4
118527: PUSH
118528: LD_VAR 0 7
118532: ARRAY
118533: PPUSH
118534: CALL_OW 314
118538: NOT
118539: IFFALSE 118642
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
118541: LD_ADDR_VAR 0 9
118545: PUSH
118546: LD_INT 81
118548: PUSH
118549: LD_VAR 0 4
118553: PUSH
118554: LD_VAR 0 7
118558: ARRAY
118559: PPUSH
118560: CALL_OW 255
118564: PUSH
118565: EMPTY
118566: LIST
118567: LIST
118568: PPUSH
118569: CALL_OW 69
118573: PPUSH
118574: LD_VAR 0 4
118578: PUSH
118579: LD_VAR 0 7
118583: ARRAY
118584: PPUSH
118585: CALL_OW 74
118589: ST_TO_ADDR
// if k then
118590: LD_VAR 0 9
118594: IFFALSE 118642
// if GetDistUnits ( group [ i ] , k ) > 10 then
118596: LD_VAR 0 4
118600: PUSH
118601: LD_VAR 0 7
118605: ARRAY
118606: PPUSH
118607: LD_VAR 0 9
118611: PPUSH
118612: CALL_OW 296
118616: PUSH
118617: LD_INT 10
118619: GREATER
118620: IFFALSE 118642
// ComMoveUnit ( group [ i ] , k ) ;
118622: LD_VAR 0 4
118626: PUSH
118627: LD_VAR 0 7
118631: ARRAY
118632: PPUSH
118633: LD_VAR 0 9
118637: PPUSH
118638: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118642: LD_VAR 0 4
118646: PUSH
118647: LD_VAR 0 7
118651: ARRAY
118652: PPUSH
118653: CALL_OW 256
118657: PUSH
118658: LD_INT 250
118660: LESS
118661: IFFALSE 118705
118663: PUSH
118664: LD_VAR 0 4
118668: PUSH
118669: LD_VAR 0 7
118673: ARRAY
118674: PUSH
118675: LD_INT 21
118677: PUSH
118678: LD_INT 2
118680: PUSH
118681: EMPTY
118682: LIST
118683: LIST
118684: PUSH
118685: LD_INT 23
118687: PUSH
118688: LD_INT 2
118690: PUSH
118691: EMPTY
118692: LIST
118693: LIST
118694: PUSH
118695: EMPTY
118696: LIST
118697: LIST
118698: PPUSH
118699: CALL_OW 69
118703: IN
118704: AND
118705: IFFALSE 118832
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118707: LD_ADDR_VAR 0 9
118711: PUSH
118712: LD_OWVAR 3
118716: PUSH
118717: LD_VAR 0 4
118721: PUSH
118722: LD_VAR 0 7
118726: ARRAY
118727: DIFF
118728: PPUSH
118729: LD_VAR 0 4
118733: PUSH
118734: LD_VAR 0 7
118738: ARRAY
118739: PPUSH
118740: CALL_OW 74
118744: ST_TO_ADDR
// if not k then
118745: LD_VAR 0 9
118749: NOT
118750: IFFALSE 118754
// continue ;
118752: GO 115127
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118754: LD_VAR 0 9
118758: PUSH
118759: LD_INT 81
118761: PUSH
118762: LD_VAR 0 4
118766: PUSH
118767: LD_VAR 0 7
118771: ARRAY
118772: PPUSH
118773: CALL_OW 255
118777: PUSH
118778: EMPTY
118779: LIST
118780: LIST
118781: PPUSH
118782: CALL_OW 69
118786: IN
118787: IFFALSE 118815
118789: PUSH
118790: LD_VAR 0 9
118794: PPUSH
118795: LD_VAR 0 4
118799: PUSH
118800: LD_VAR 0 7
118804: ARRAY
118805: PPUSH
118806: CALL_OW 296
118810: PUSH
118811: LD_INT 5
118813: LESS
118814: AND
118815: IFFALSE 118832
// ComAutodestruct ( group [ i ] ) ;
118817: LD_VAR 0 4
118821: PUSH
118822: LD_VAR 0 7
118826: ARRAY
118827: PPUSH
118828: CALL 50919 0 1
// end ; if f_attack_depot then
118832: LD_VAR 0 25
118836: IFFALSE 118948
// begin k := 6 ;
118838: LD_ADDR_VAR 0 9
118842: PUSH
118843: LD_INT 6
118845: ST_TO_ADDR
// if tmp < k then
118846: LD_VAR 0 14
118850: PUSH
118851: LD_VAR 0 9
118855: LESS
118856: IFFALSE 118868
// k := tmp ;
118858: LD_ADDR_VAR 0 9
118862: PUSH
118863: LD_VAR 0 14
118867: ST_TO_ADDR
// for j = 1 to k do
118868: LD_ADDR_VAR 0 8
118872: PUSH
118873: DOUBLE
118874: LD_INT 1
118876: DEC
118877: ST_TO_ADDR
118878: LD_VAR 0 9
118882: PUSH
118883: FOR_TO
118884: IFFALSE 118946
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118886: LD_VAR 0 8
118890: PPUSH
118891: CALL_OW 266
118895: PUSH
118896: LD_INT 0
118898: PUSH
118899: LD_INT 1
118901: PUSH
118902: EMPTY
118903: LIST
118904: LIST
118905: IN
118906: IFFALSE 118944
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118908: LD_VAR 0 4
118912: PUSH
118913: LD_VAR 0 7
118917: ARRAY
118918: PPUSH
118919: LD_VAR 0 14
118923: PUSH
118924: LD_VAR 0 8
118928: ARRAY
118929: PPUSH
118930: CALL_OW 115
// attacking := true ;
118934: LD_ADDR_VAR 0 29
118938: PUSH
118939: LD_INT 1
118941: ST_TO_ADDR
// break ;
118942: GO 118946
// end ;
118944: GO 118883
118946: POP
118947: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118948: LD_VAR 0 4
118952: PUSH
118953: LD_VAR 0 7
118957: ARRAY
118958: PPUSH
118959: CALL_OW 302
118963: IFFALSE 118972
118965: PUSH
118966: LD_VAR 0 29
118970: NOT
118971: AND
118972: IFFALSE 119302
// begin if GetTag ( group [ i ] ) = 71 then
118974: LD_VAR 0 4
118978: PUSH
118979: LD_VAR 0 7
118983: ARRAY
118984: PPUSH
118985: CALL_OW 110
118989: PUSH
118990: LD_INT 71
118992: EQUAL
118993: IFFALSE 119034
// begin if HasTask ( group [ i ] ) then
118995: LD_VAR 0 4
118999: PUSH
119000: LD_VAR 0 7
119004: ARRAY
119005: PPUSH
119006: CALL_OW 314
119010: IFFALSE 119016
// continue else
119012: GO 115127
119014: GO 119034
// SetTag ( group [ i ] , 0 ) ;
119016: LD_VAR 0 4
119020: PUSH
119021: LD_VAR 0 7
119025: ARRAY
119026: PPUSH
119027: LD_INT 0
119029: PPUSH
119030: CALL_OW 109
// end ; k := 8 ;
119034: LD_ADDR_VAR 0 9
119038: PUSH
119039: LD_INT 8
119041: ST_TO_ADDR
// x := 0 ;
119042: LD_ADDR_VAR 0 10
119046: PUSH
119047: LD_INT 0
119049: ST_TO_ADDR
// if tmp < k then
119050: LD_VAR 0 14
119054: PUSH
119055: LD_VAR 0 9
119059: LESS
119060: IFFALSE 119072
// k := tmp ;
119062: LD_ADDR_VAR 0 9
119066: PUSH
119067: LD_VAR 0 14
119071: ST_TO_ADDR
// for j = 1 to k do
119072: LD_ADDR_VAR 0 8
119076: PUSH
119077: DOUBLE
119078: LD_INT 1
119080: DEC
119081: ST_TO_ADDR
119082: LD_VAR 0 9
119086: PUSH
119087: FOR_TO
119088: IFFALSE 119194
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
119090: LD_VAR 0 14
119094: PUSH
119095: LD_VAR 0 8
119099: ARRAY
119100: PPUSH
119101: CALL_OW 247
119105: PUSH
119106: LD_INT 1
119108: EQUAL
119109: IFFALSE 119172
119111: PUSH
119112: LD_VAR 0 14
119116: PUSH
119117: LD_VAR 0 8
119121: ARRAY
119122: PPUSH
119123: CALL_OW 256
119127: PUSH
119128: LD_INT 250
119130: LESS
119131: IFFALSE 119139
119133: PUSH
119134: LD_VAR 0 20
119138: AND
119139: IFTRUE 119171
119141: PUSH
119142: LD_VAR 0 20
119146: NOT
119147: IFFALSE 119170
119149: PUSH
119150: LD_VAR 0 14
119154: PUSH
119155: LD_VAR 0 8
119159: ARRAY
119160: PPUSH
119161: CALL_OW 256
119165: PUSH
119166: LD_INT 250
119168: GREATEREQUAL
119169: AND
119170: OR
119171: AND
119172: IFFALSE 119192
// begin x := tmp [ j ] ;
119174: LD_ADDR_VAR 0 10
119178: PUSH
119179: LD_VAR 0 14
119183: PUSH
119184: LD_VAR 0 8
119188: ARRAY
119189: ST_TO_ADDR
// break ;
119190: GO 119194
// end ;
119192: GO 119087
119194: POP
119195: POP
// if x then
119196: LD_VAR 0 10
119200: IFFALSE 119224
// ComAttackUnit ( group [ i ] , x ) else
119202: LD_VAR 0 4
119206: PUSH
119207: LD_VAR 0 7
119211: ARRAY
119212: PPUSH
119213: LD_VAR 0 10
119217: PPUSH
119218: CALL_OW 115
119222: GO 119248
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
119224: LD_VAR 0 4
119228: PUSH
119229: LD_VAR 0 7
119233: ARRAY
119234: PPUSH
119235: LD_VAR 0 14
119239: PUSH
119240: LD_INT 1
119242: ARRAY
119243: PPUSH
119244: CALL_OW 115
// if not HasTask ( group [ i ] ) then
119248: LD_VAR 0 4
119252: PUSH
119253: LD_VAR 0 7
119257: ARRAY
119258: PPUSH
119259: CALL_OW 314
119263: NOT
119264: IFFALSE 119302
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
119266: LD_VAR 0 4
119270: PUSH
119271: LD_VAR 0 7
119275: ARRAY
119276: PPUSH
119277: LD_VAR 0 14
119281: PPUSH
119282: LD_VAR 0 4
119286: PUSH
119287: LD_VAR 0 7
119291: ARRAY
119292: PPUSH
119293: CALL_OW 74
119297: PPUSH
119298: CALL_OW 115
// end ; end ; end ;
119302: GO 115127
119304: POP
119305: POP
// wait ( 0 0$2 ) ;
119306: LD_INT 70
119308: PPUSH
119309: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
119313: LD_VAR 0 4
119317: NOT
119318: IFTRUE 119329
119320: PUSH
119321: LD_VAR 0 4
119325: PUSH
119326: EMPTY
119327: EQUAL
119328: OR
119329: IFTRUE 119350
119331: PUSH
119332: LD_INT 81
119334: PUSH
119335: LD_VAR 0 35
119339: PUSH
119340: EMPTY
119341: LIST
119342: LIST
119343: PPUSH
119344: CALL_OW 69
119348: NOT
119349: OR
119350: IFFALSE 115112
// end ;
119352: LD_VAR 0 2
119356: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
119357: LD_INT 0
119359: PPUSH
119360: PPUSH
119361: PPUSH
119362: PPUSH
119363: PPUSH
119364: PPUSH
// if not base or not mc_bases [ base ] or not solds then
119365: LD_VAR 0 1
119369: NOT
119370: IFTRUE 119385
119372: PUSH
119373: LD_EXP 63
119377: PUSH
119378: LD_VAR 0 1
119382: ARRAY
119383: NOT
119384: OR
119385: IFTRUE 119394
119387: PUSH
119388: LD_VAR 0 2
119392: NOT
119393: OR
119394: IFFALSE 119398
// exit ;
119396: GO 119956
// side := mc_sides [ base ] ;
119398: LD_ADDR_VAR 0 6
119402: PUSH
119403: LD_EXP 89
119407: PUSH
119408: LD_VAR 0 1
119412: ARRAY
119413: ST_TO_ADDR
// if not side then
119414: LD_VAR 0 6
119418: NOT
119419: IFFALSE 119423
// exit ;
119421: GO 119956
// for i in solds do
119423: LD_ADDR_VAR 0 7
119427: PUSH
119428: LD_VAR 0 2
119432: PUSH
119433: FOR_IN
119434: IFFALSE 119495
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
119436: LD_VAR 0 7
119440: PPUSH
119441: CALL_OW 310
119445: PPUSH
119446: CALL_OW 266
119450: PUSH
119451: LD_INT 32
119453: PUSH
119454: LD_INT 31
119456: PUSH
119457: EMPTY
119458: LIST
119459: LIST
119460: IN
119461: IFFALSE 119481
// solds := solds diff i else
119463: LD_ADDR_VAR 0 2
119467: PUSH
119468: LD_VAR 0 2
119472: PUSH
119473: LD_VAR 0 7
119477: DIFF
119478: ST_TO_ADDR
119479: GO 119493
// SetTag ( i , 18 ) ;
119481: LD_VAR 0 7
119485: PPUSH
119486: LD_INT 18
119488: PPUSH
119489: CALL_OW 109
119493: GO 119433
119495: POP
119496: POP
// if not solds then
119497: LD_VAR 0 2
119501: NOT
119502: IFFALSE 119506
// exit ;
119504: GO 119956
// repeat wait ( 0 0$2 ) ;
119506: LD_INT 70
119508: PPUSH
119509: CALL_OW 67
// enemy := mc_scan [ base ] ;
119513: LD_ADDR_VAR 0 4
119517: PUSH
119518: LD_EXP 86
119522: PUSH
119523: LD_VAR 0 1
119527: ARRAY
119528: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119529: LD_EXP 63
119533: PUSH
119534: LD_VAR 0 1
119538: ARRAY
119539: NOT
119540: IFTRUE 119557
119542: PUSH
119543: LD_EXP 63
119547: PUSH
119548: LD_VAR 0 1
119552: ARRAY
119553: PUSH
119554: EMPTY
119555: EQUAL
119556: OR
119557: IFFALSE 119594
// begin for i in solds do
119559: LD_ADDR_VAR 0 7
119563: PUSH
119564: LD_VAR 0 2
119568: PUSH
119569: FOR_IN
119570: IFFALSE 119583
// ComStop ( i ) ;
119572: LD_VAR 0 7
119576: PPUSH
119577: CALL_OW 141
119581: GO 119569
119583: POP
119584: POP
// solds := [ ] ;
119585: LD_ADDR_VAR 0 2
119589: PUSH
119590: EMPTY
119591: ST_TO_ADDR
// exit ;
119592: GO 119956
// end ; for i in solds do
119594: LD_ADDR_VAR 0 7
119598: PUSH
119599: LD_VAR 0 2
119603: PUSH
119604: FOR_IN
119605: IFFALSE 119926
// begin if IsInUnit ( i ) then
119607: LD_VAR 0 7
119611: PPUSH
119612: CALL_OW 310
119616: IFFALSE 119627
// ComExitBuilding ( i ) ;
119618: LD_VAR 0 7
119622: PPUSH
119623: CALL_OW 122
// if GetLives ( i ) > 500 then
119627: LD_VAR 0 7
119631: PPUSH
119632: CALL_OW 256
119636: PUSH
119637: LD_INT 500
119639: GREATER
119640: IFFALSE 119693
// begin e := NearestUnitToUnit ( enemy , i ) ;
119642: LD_ADDR_VAR 0 5
119646: PUSH
119647: LD_VAR 0 4
119651: PPUSH
119652: LD_VAR 0 7
119656: PPUSH
119657: CALL_OW 74
119661: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119662: LD_VAR 0 7
119666: PPUSH
119667: LD_VAR 0 5
119671: PPUSH
119672: CALL_OW 250
119676: PPUSH
119677: LD_VAR 0 5
119681: PPUSH
119682: CALL_OW 251
119686: PPUSH
119687: CALL_OW 114
// end else
119691: GO 119924
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119693: LD_VAR 0 7
119697: PPUSH
119698: LD_EXP 63
119702: PUSH
119703: LD_VAR 0 1
119707: ARRAY
119708: PPUSH
119709: LD_INT 2
119711: PUSH
119712: LD_INT 30
119714: PUSH
119715: LD_INT 0
119717: PUSH
119718: EMPTY
119719: LIST
119720: LIST
119721: PUSH
119722: LD_INT 30
119724: PUSH
119725: LD_INT 1
119727: PUSH
119728: EMPTY
119729: LIST
119730: LIST
119731: PUSH
119732: LD_INT 30
119734: PUSH
119735: LD_INT 6
119737: PUSH
119738: EMPTY
119739: LIST
119740: LIST
119741: PUSH
119742: EMPTY
119743: LIST
119744: LIST
119745: LIST
119746: LIST
119747: PPUSH
119748: CALL_OW 72
119752: PPUSH
119753: LD_VAR 0 7
119757: PPUSH
119758: CALL_OW 74
119762: PPUSH
119763: CALL_OW 296
119767: PUSH
119768: LD_INT 10
119770: GREATER
119771: IFFALSE 119924
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119773: LD_ADDR_VAR 0 8
119777: PUSH
119778: LD_EXP 63
119782: PUSH
119783: LD_VAR 0 1
119787: ARRAY
119788: PPUSH
119789: LD_INT 2
119791: PUSH
119792: LD_INT 30
119794: PUSH
119795: LD_INT 0
119797: PUSH
119798: EMPTY
119799: LIST
119800: LIST
119801: PUSH
119802: LD_INT 30
119804: PUSH
119805: LD_INT 1
119807: PUSH
119808: EMPTY
119809: LIST
119810: LIST
119811: PUSH
119812: LD_INT 30
119814: PUSH
119815: LD_INT 6
119817: PUSH
119818: EMPTY
119819: LIST
119820: LIST
119821: PUSH
119822: EMPTY
119823: LIST
119824: LIST
119825: LIST
119826: LIST
119827: PPUSH
119828: CALL_OW 72
119832: PPUSH
119833: LD_VAR 0 7
119837: PPUSH
119838: CALL_OW 74
119842: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119843: LD_VAR 0 7
119847: PPUSH
119848: LD_VAR 0 8
119852: PPUSH
119853: CALL_OW 250
119857: PPUSH
119858: LD_INT 3
119860: PPUSH
119861: LD_INT 5
119863: PPUSH
119864: CALL_OW 272
119868: PPUSH
119869: LD_VAR 0 8
119873: PPUSH
119874: CALL_OW 251
119878: PPUSH
119879: LD_INT 3
119881: PPUSH
119882: LD_INT 5
119884: PPUSH
119885: CALL_OW 273
119889: PPUSH
119890: CALL_OW 111
// SetTag ( i , 0 ) ;
119894: LD_VAR 0 7
119898: PPUSH
119899: LD_INT 0
119901: PPUSH
119902: CALL_OW 109
// solds := solds diff i ;
119906: LD_ADDR_VAR 0 2
119910: PUSH
119911: LD_VAR 0 2
119915: PUSH
119916: LD_VAR 0 7
119920: DIFF
119921: ST_TO_ADDR
// continue ;
119922: GO 119604
// end ; end ;
119924: GO 119604
119926: POP
119927: POP
// until not solds or not enemy ;
119928: LD_VAR 0 2
119932: NOT
119933: IFTRUE 119942
119935: PUSH
119936: LD_VAR 0 4
119940: NOT
119941: OR
119942: IFFALSE 119506
// MC_Reset ( base , 18 ) ;
119944: LD_VAR 0 1
119948: PPUSH
119949: LD_INT 18
119951: PPUSH
119952: CALL 65135 0 2
// end ;
119956: LD_VAR 0 3
119960: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119961: LD_INT 0
119963: PPUSH
119964: PPUSH
119965: PPUSH
119966: PPUSH
119967: PPUSH
119968: PPUSH
119969: PPUSH
119970: PPUSH
119971: PPUSH
119972: PPUSH
119973: PPUSH
119974: PPUSH
119975: PPUSH
119976: PPUSH
119977: PPUSH
119978: PPUSH
119979: PPUSH
119980: PPUSH
119981: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119982: LD_ADDR_VAR 0 12
119986: PUSH
119987: LD_EXP 63
119991: PUSH
119992: LD_VAR 0 1
119996: ARRAY
119997: PPUSH
119998: LD_INT 25
120000: PUSH
120001: LD_INT 3
120003: PUSH
120004: EMPTY
120005: LIST
120006: LIST
120007: PPUSH
120008: CALL_OW 72
120012: ST_TO_ADDR
// if mc_remote_driver [ base ] then
120013: LD_EXP 103
120017: PUSH
120018: LD_VAR 0 1
120022: ARRAY
120023: IFFALSE 120047
// mechs := mechs diff mc_remote_driver [ base ] ;
120025: LD_ADDR_VAR 0 12
120029: PUSH
120030: LD_VAR 0 12
120034: PUSH
120035: LD_EXP 103
120039: PUSH
120040: LD_VAR 0 1
120044: ARRAY
120045: DIFF
120046: ST_TO_ADDR
// for i in mechs do
120047: LD_ADDR_VAR 0 4
120051: PUSH
120052: LD_VAR 0 12
120056: PUSH
120057: FOR_IN
120058: IFFALSE 120093
// if GetTag ( i ) > 0 then
120060: LD_VAR 0 4
120064: PPUSH
120065: CALL_OW 110
120069: PUSH
120070: LD_INT 0
120072: GREATER
120073: IFFALSE 120091
// mechs := mechs diff i ;
120075: LD_ADDR_VAR 0 12
120079: PUSH
120080: LD_VAR 0 12
120084: PUSH
120085: LD_VAR 0 4
120089: DIFF
120090: ST_TO_ADDR
120091: GO 120057
120093: POP
120094: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
120095: LD_ADDR_VAR 0 8
120099: PUSH
120100: LD_EXP 63
120104: PUSH
120105: LD_VAR 0 1
120109: ARRAY
120110: PPUSH
120111: LD_INT 2
120113: PUSH
120114: LD_INT 25
120116: PUSH
120117: LD_INT 1
120119: PUSH
120120: EMPTY
120121: LIST
120122: LIST
120123: PUSH
120124: LD_INT 25
120126: PUSH
120127: LD_INT 5
120129: PUSH
120130: EMPTY
120131: LIST
120132: LIST
120133: PUSH
120134: LD_INT 25
120136: PUSH
120137: LD_INT 8
120139: PUSH
120140: EMPTY
120141: LIST
120142: LIST
120143: PUSH
120144: LD_INT 25
120146: PUSH
120147: LD_INT 9
120149: PUSH
120150: EMPTY
120151: LIST
120152: LIST
120153: PUSH
120154: EMPTY
120155: LIST
120156: LIST
120157: LIST
120158: LIST
120159: LIST
120160: PPUSH
120161: CALL_OW 72
120165: ST_TO_ADDR
// if not defenders and not solds then
120166: LD_VAR 0 2
120170: NOT
120171: IFFALSE 120180
120173: PUSH
120174: LD_VAR 0 8
120178: NOT
120179: AND
120180: IFFALSE 120184
// exit ;
120182: GO 122006
// depot_under_attack := false ;
120184: LD_ADDR_VAR 0 16
120188: PUSH
120189: LD_INT 0
120191: ST_TO_ADDR
// sold_defenders := [ ] ;
120192: LD_ADDR_VAR 0 17
120196: PUSH
120197: EMPTY
120198: ST_TO_ADDR
// if mechs then
120199: LD_VAR 0 12
120203: IFFALSE 120358
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
120205: LD_ADDR_VAR 0 4
120209: PUSH
120210: LD_VAR 0 2
120214: PPUSH
120215: LD_INT 21
120217: PUSH
120218: LD_INT 2
120220: PUSH
120221: EMPTY
120222: LIST
120223: LIST
120224: PPUSH
120225: CALL_OW 72
120229: PUSH
120230: FOR_IN
120231: IFFALSE 120356
// begin if GetTag ( i ) <> 20 then
120233: LD_VAR 0 4
120237: PPUSH
120238: CALL_OW 110
120242: PUSH
120243: LD_INT 20
120245: NONEQUAL
120246: IFFALSE 120260
// SetTag ( i , 20 ) ;
120248: LD_VAR 0 4
120252: PPUSH
120253: LD_INT 20
120255: PPUSH
120256: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
120260: LD_VAR 0 4
120264: PPUSH
120265: CALL_OW 263
120269: PUSH
120270: LD_INT 1
120272: EQUAL
120273: IFFALSE 120287
120275: PUSH
120276: LD_VAR 0 4
120280: PPUSH
120281: CALL_OW 311
120285: NOT
120286: AND
120287: IFFALSE 120354
// begin un := mechs [ 1 ] ;
120289: LD_ADDR_VAR 0 10
120293: PUSH
120294: LD_VAR 0 12
120298: PUSH
120299: LD_INT 1
120301: ARRAY
120302: ST_TO_ADDR
// ComExit ( un ) ;
120303: LD_VAR 0 10
120307: PPUSH
120308: CALL 56010 0 1
// AddComEnterUnit ( un , i ) ;
120312: LD_VAR 0 10
120316: PPUSH
120317: LD_VAR 0 4
120321: PPUSH
120322: CALL_OW 180
// SetTag ( un , 19 ) ;
120326: LD_VAR 0 10
120330: PPUSH
120331: LD_INT 19
120333: PPUSH
120334: CALL_OW 109
// mechs := mechs diff un ;
120338: LD_ADDR_VAR 0 12
120342: PUSH
120343: LD_VAR 0 12
120347: PUSH
120348: LD_VAR 0 10
120352: DIFF
120353: ST_TO_ADDR
// end ; end ;
120354: GO 120230
120356: POP
120357: POP
// if solds then
120358: LD_VAR 0 8
120362: IFFALSE 120421
// for i in solds do
120364: LD_ADDR_VAR 0 4
120368: PUSH
120369: LD_VAR 0 8
120373: PUSH
120374: FOR_IN
120375: IFFALSE 120419
// if not GetTag ( i ) then
120377: LD_VAR 0 4
120381: PPUSH
120382: CALL_OW 110
120386: NOT
120387: IFFALSE 120417
// begin defenders := defenders union i ;
120389: LD_ADDR_VAR 0 2
120393: PUSH
120394: LD_VAR 0 2
120398: PUSH
120399: LD_VAR 0 4
120403: UNION
120404: ST_TO_ADDR
// SetTag ( i , 18 ) ;
120405: LD_VAR 0 4
120409: PPUSH
120410: LD_INT 18
120412: PPUSH
120413: CALL_OW 109
// end ;
120417: GO 120374
120419: POP
120420: POP
// repeat wait ( 0 0$2 ) ;
120421: LD_INT 70
120423: PPUSH
120424: CALL_OW 67
// enemy := mc_scan [ base ] ;
120428: LD_ADDR_VAR 0 21
120432: PUSH
120433: LD_EXP 86
120437: PUSH
120438: LD_VAR 0 1
120442: ARRAY
120443: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120444: LD_EXP 63
120448: PUSH
120449: LD_VAR 0 1
120453: ARRAY
120454: NOT
120455: IFTRUE 120472
120457: PUSH
120458: LD_EXP 63
120462: PUSH
120463: LD_VAR 0 1
120467: ARRAY
120468: PUSH
120469: EMPTY
120470: EQUAL
120471: OR
120472: IFFALSE 120509
// begin for i in defenders do
120474: LD_ADDR_VAR 0 4
120478: PUSH
120479: LD_VAR 0 2
120483: PUSH
120484: FOR_IN
120485: IFFALSE 120498
// ComStop ( i ) ;
120487: LD_VAR 0 4
120491: PPUSH
120492: CALL_OW 141
120496: GO 120484
120498: POP
120499: POP
// defenders := [ ] ;
120500: LD_ADDR_VAR 0 2
120504: PUSH
120505: EMPTY
120506: ST_TO_ADDR
// exit ;
120507: GO 122006
// end ; for i in defenders do
120509: LD_ADDR_VAR 0 4
120513: PUSH
120514: LD_VAR 0 2
120518: PUSH
120519: FOR_IN
120520: IFFALSE 121454
// begin e := NearestUnitToUnit ( enemy , i ) ;
120522: LD_ADDR_VAR 0 13
120526: PUSH
120527: LD_VAR 0 21
120531: PPUSH
120532: LD_VAR 0 4
120536: PPUSH
120537: CALL_OW 74
120541: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120542: LD_ADDR_VAR 0 7
120546: PUSH
120547: LD_EXP 63
120551: PUSH
120552: LD_VAR 0 1
120556: ARRAY
120557: PPUSH
120558: LD_INT 2
120560: PUSH
120561: LD_INT 30
120563: PUSH
120564: LD_INT 0
120566: PUSH
120567: EMPTY
120568: LIST
120569: LIST
120570: PUSH
120571: LD_INT 30
120573: PUSH
120574: LD_INT 1
120576: PUSH
120577: EMPTY
120578: LIST
120579: LIST
120580: PUSH
120581: EMPTY
120582: LIST
120583: LIST
120584: LIST
120585: PPUSH
120586: CALL_OW 72
120590: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
120591: LD_ADDR_VAR 0 16
120595: PUSH
120596: LD_VAR 0 7
120600: NOT
120601: IFTRUE 120631
120603: PUSH
120604: LD_VAR 0 7
120608: PPUSH
120609: LD_INT 3
120611: PUSH
120612: LD_INT 24
120614: PUSH
120615: LD_INT 600
120617: PUSH
120618: EMPTY
120619: LIST
120620: LIST
120621: PUSH
120622: EMPTY
120623: LIST
120624: LIST
120625: PPUSH
120626: CALL_OW 72
120630: OR
120631: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
120632: LD_VAR 0 4
120636: PPUSH
120637: CALL_OW 247
120641: PUSH
120642: LD_INT 2
120644: DOUBLE
120645: EQUAL
120646: IFTRUE 120650
120648: GO 121066
120650: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120651: LD_VAR 0 4
120655: PPUSH
120656: CALL_OW 256
120660: PUSH
120661: LD_INT 1000
120663: EQUAL
120664: IFFALSE 120710
120666: PUSH
120667: LD_VAR 0 4
120671: PPUSH
120672: LD_VAR 0 13
120676: PPUSH
120677: CALL_OW 296
120681: PUSH
120682: LD_INT 40
120684: LESS
120685: IFTRUE 120709
120687: PUSH
120688: LD_VAR 0 13
120692: PPUSH
120693: LD_EXP 88
120697: PUSH
120698: LD_VAR 0 1
120702: ARRAY
120703: PPUSH
120704: CALL_OW 308
120708: OR
120709: AND
120710: IFFALSE 120836
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120712: LD_VAR 0 4
120716: PPUSH
120717: CALL_OW 262
120721: PUSH
120722: LD_INT 1
120724: EQUAL
120725: IFFALSE 120742
120727: PUSH
120728: LD_VAR 0 4
120732: PPUSH
120733: CALL_OW 261
120737: PUSH
120738: LD_INT 30
120740: LESS
120741: AND
120742: IFFALSE 120750
120744: PUSH
120745: LD_VAR 0 7
120749: AND
120750: IFFALSE 120820
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120752: LD_VAR 0 4
120756: PPUSH
120757: LD_VAR 0 7
120761: PPUSH
120762: LD_VAR 0 4
120766: PPUSH
120767: CALL_OW 74
120771: PPUSH
120772: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120776: LD_VAR 0 4
120780: PPUSH
120781: LD_VAR 0 7
120785: PPUSH
120786: LD_VAR 0 4
120790: PPUSH
120791: CALL_OW 74
120795: PPUSH
120796: CALL_OW 296
120800: PUSH
120801: LD_INT 6
120803: LESS
120804: IFFALSE 120818
// SetFuel ( i , 100 ) ;
120806: LD_VAR 0 4
120810: PPUSH
120811: LD_INT 100
120813: PPUSH
120814: CALL_OW 240
// end else
120818: GO 120834
// ComAttackUnit ( i , e ) ;
120820: LD_VAR 0 4
120824: PPUSH
120825: LD_VAR 0 13
120829: PPUSH
120830: CALL_OW 115
// end else
120834: GO 120943
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120836: LD_VAR 0 13
120840: PPUSH
120841: LD_EXP 88
120845: PUSH
120846: LD_VAR 0 1
120850: ARRAY
120851: PPUSH
120852: CALL_OW 308
120856: NOT
120857: IFFALSE 120879
120859: PUSH
120860: LD_VAR 0 4
120864: PPUSH
120865: LD_VAR 0 13
120869: PPUSH
120870: CALL_OW 296
120874: PUSH
120875: LD_INT 40
120877: GREATEREQUAL
120878: AND
120879: IFTRUE 120896
120881: PUSH
120882: LD_VAR 0 4
120886: PPUSH
120887: CALL_OW 256
120891: PUSH
120892: LD_INT 650
120894: LESSEQUAL
120895: OR
120896: IFFALSE 120921
120898: PUSH
120899: LD_VAR 0 4
120903: PPUSH
120904: LD_EXP 87
120908: PUSH
120909: LD_VAR 0 1
120913: ARRAY
120914: PPUSH
120915: CALL_OW 308
120919: NOT
120920: AND
120921: IFFALSE 120943
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120923: LD_VAR 0 4
120927: PPUSH
120928: LD_EXP 87
120932: PUSH
120933: LD_VAR 0 1
120937: ARRAY
120938: PPUSH
120939: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120943: LD_VAR 0 4
120947: PPUSH
120948: CALL_OW 256
120952: PUSH
120953: LD_INT 1000
120955: LESS
120956: IFFALSE 120973
120958: PUSH
120959: LD_VAR 0 4
120963: PPUSH
120964: CALL_OW 263
120968: PUSH
120969: LD_INT 1
120971: EQUAL
120972: AND
120973: IFFALSE 120986
120975: PUSH
120976: LD_VAR 0 4
120980: PPUSH
120981: CALL_OW 311
120985: AND
120986: IFFALSE 121010
120988: PUSH
120989: LD_VAR 0 4
120993: PPUSH
120994: LD_EXP 87
120998: PUSH
120999: LD_VAR 0 1
121003: ARRAY
121004: PPUSH
121005: CALL_OW 308
121009: AND
121010: IFFALSE 121064
// begin mech := IsDrivenBy ( i ) ;
121012: LD_ADDR_VAR 0 9
121016: PUSH
121017: LD_VAR 0 4
121021: PPUSH
121022: CALL_OW 311
121026: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
121027: LD_VAR 0 9
121031: PPUSH
121032: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
121036: LD_VAR 0 9
121040: PPUSH
121041: LD_VAR 0 4
121045: PPUSH
121046: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
121050: LD_VAR 0 9
121054: PPUSH
121055: LD_VAR 0 4
121059: PPUSH
121060: CALL_OW 180
// end ; end ; unit_human :
121064: GO 121425
121066: LD_INT 1
121068: DOUBLE
121069: EQUAL
121070: IFTRUE 121074
121072: GO 121424
121074: POP
// begin b := IsInUnit ( i ) ;
121075: LD_ADDR_VAR 0 18
121079: PUSH
121080: LD_VAR 0 4
121084: PPUSH
121085: CALL_OW 310
121089: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
121090: LD_ADDR_VAR 0 19
121094: PUSH
121095: LD_VAR 0 18
121099: NOT
121100: IFTRUE 121124
121102: PUSH
121103: LD_VAR 0 18
121107: PPUSH
121108: CALL_OW 266
121112: PUSH
121113: LD_INT 32
121115: PUSH
121116: LD_INT 31
121118: PUSH
121119: EMPTY
121120: LIST
121121: LIST
121122: IN
121123: OR
121124: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
121125: LD_VAR 0 18
121129: PPUSH
121130: CALL_OW 266
121134: PUSH
121135: LD_INT 5
121137: EQUAL
121138: IFFALSE 121170
121140: PUSH
121141: LD_VAR 0 4
121145: PPUSH
121146: CALL_OW 257
121150: PUSH
121151: LD_INT 1
121153: PUSH
121154: LD_INT 2
121156: PUSH
121157: LD_INT 3
121159: PUSH
121160: LD_INT 4
121162: PUSH
121163: EMPTY
121164: LIST
121165: LIST
121166: LIST
121167: LIST
121168: IN
121169: AND
121170: IFFALSE 121207
// begin class := AllowSpecClass ( i ) ;
121172: LD_ADDR_VAR 0 20
121176: PUSH
121177: LD_VAR 0 4
121181: PPUSH
121182: CALL 19320 0 1
121186: ST_TO_ADDR
// if class then
121187: LD_VAR 0 20
121191: IFFALSE 121207
// ComChangeProfession ( i , class ) ;
121193: LD_VAR 0 4
121197: PPUSH
121198: LD_VAR 0 20
121202: PPUSH
121203: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
121207: LD_VAR 0 16
121211: IFTRUE 121238
121213: PUSH
121214: LD_VAR 0 2
121218: PPUSH
121219: LD_INT 21
121221: PUSH
121222: LD_INT 2
121224: PUSH
121225: EMPTY
121226: LIST
121227: LIST
121228: PPUSH
121229: CALL_OW 72
121233: PUSH
121234: LD_INT 1
121236: LESSEQUAL
121237: OR
121238: IFFALSE 121246
121240: PUSH
121241: LD_VAR 0 19
121245: AND
121246: IFFALSE 121261
121248: PUSH
121249: LD_VAR 0 4
121253: PUSH
121254: LD_VAR 0 17
121258: IN
121259: NOT
121260: AND
121261: IFFALSE 121356
// begin if b then
121263: LD_VAR 0 18
121267: IFFALSE 121318
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
121269: LD_VAR 0 18
121273: PPUSH
121274: LD_VAR 0 21
121278: PPUSH
121279: LD_VAR 0 18
121283: PPUSH
121284: CALL_OW 74
121288: PPUSH
121289: CALL_OW 296
121293: PUSH
121294: LD_INT 10
121296: LESS
121297: IFFALSE 121314
121299: PUSH
121300: LD_VAR 0 18
121304: PPUSH
121305: CALL_OW 461
121309: PUSH
121310: LD_INT 7
121312: NONEQUAL
121313: AND
121314: IFFALSE 121318
// continue ;
121316: GO 120519
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
121318: LD_ADDR_VAR 0 17
121322: PUSH
121323: LD_VAR 0 17
121327: PPUSH
121328: LD_VAR 0 17
121332: PUSH
121333: LD_INT 1
121335: PLUS
121336: PPUSH
121337: LD_VAR 0 4
121341: PPUSH
121342: CALL_OW 1
121346: ST_TO_ADDR
// ComExitBuilding ( i ) ;
121347: LD_VAR 0 4
121351: PPUSH
121352: CALL_OW 122
// end ; if sold_defenders then
121356: LD_VAR 0 17
121360: IFFALSE 121422
// if i in sold_defenders then
121362: LD_VAR 0 4
121366: PUSH
121367: LD_VAR 0 17
121371: IN
121372: IFFALSE 121422
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
121374: LD_VAR 0 4
121378: PPUSH
121379: CALL_OW 314
121383: NOT
121384: IFFALSE 121406
121386: PUSH
121387: LD_VAR 0 4
121391: PPUSH
121392: LD_VAR 0 13
121396: PPUSH
121397: CALL_OW 296
121401: PUSH
121402: LD_INT 30
121404: LESS
121405: AND
121406: IFFALSE 121422
// ComAttackUnit ( i , e ) ;
121408: LD_VAR 0 4
121412: PPUSH
121413: LD_VAR 0 13
121417: PPUSH
121418: CALL_OW 115
// end ; end ; end ;
121422: GO 121425
121424: POP
// if IsDead ( i ) then
121425: LD_VAR 0 4
121429: PPUSH
121430: CALL_OW 301
121434: IFFALSE 121452
// defenders := defenders diff i ;
121436: LD_ADDR_VAR 0 2
121440: PUSH
121441: LD_VAR 0 2
121445: PUSH
121446: LD_VAR 0 4
121450: DIFF
121451: ST_TO_ADDR
// end ;
121452: GO 120519
121454: POP
121455: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
121456: LD_VAR 0 21
121460: NOT
121461: IFTRUE 121470
121463: PUSH
121464: LD_VAR 0 2
121468: NOT
121469: OR
121470: IFTRUE 121485
121472: PUSH
121473: LD_EXP 63
121477: PUSH
121478: LD_VAR 0 1
121482: ARRAY
121483: NOT
121484: OR
121485: IFFALSE 120421
// MC_Reset ( base , 18 ) ;
121487: LD_VAR 0 1
121491: PPUSH
121492: LD_INT 18
121494: PPUSH
121495: CALL 65135 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121499: LD_ADDR_VAR 0 2
121503: PUSH
121504: LD_VAR 0 2
121508: PUSH
121509: LD_VAR 0 2
121513: PPUSH
121514: LD_INT 2
121516: PUSH
121517: LD_INT 25
121519: PUSH
121520: LD_INT 1
121522: PUSH
121523: EMPTY
121524: LIST
121525: LIST
121526: PUSH
121527: LD_INT 25
121529: PUSH
121530: LD_INT 5
121532: PUSH
121533: EMPTY
121534: LIST
121535: LIST
121536: PUSH
121537: LD_INT 25
121539: PUSH
121540: LD_INT 8
121542: PUSH
121543: EMPTY
121544: LIST
121545: LIST
121546: PUSH
121547: LD_INT 25
121549: PUSH
121550: LD_INT 9
121552: PUSH
121553: EMPTY
121554: LIST
121555: LIST
121556: PUSH
121557: EMPTY
121558: LIST
121559: LIST
121560: LIST
121561: LIST
121562: LIST
121563: PPUSH
121564: CALL_OW 72
121568: DIFF
121569: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
121570: LD_VAR 0 21
121574: NOT
121575: IFFALSE 121598
121577: PUSH
121578: LD_VAR 0 2
121582: PPUSH
121583: LD_INT 21
121585: PUSH
121586: LD_INT 2
121588: PUSH
121589: EMPTY
121590: LIST
121591: LIST
121592: PPUSH
121593: CALL_OW 72
121597: AND
121598: IFFALSE 121942
// begin tmp := FilterByTag ( defenders , 19 ) ;
121600: LD_ADDR_VAR 0 11
121604: PUSH
121605: LD_VAR 0 2
121609: PPUSH
121610: LD_INT 19
121612: PPUSH
121613: CALL 53157 0 2
121617: ST_TO_ADDR
// if tmp then
121618: LD_VAR 0 11
121622: IFFALSE 121692
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
121624: LD_ADDR_VAR 0 11
121628: PUSH
121629: LD_VAR 0 11
121633: PPUSH
121634: LD_INT 25
121636: PUSH
121637: LD_INT 3
121639: PUSH
121640: EMPTY
121641: LIST
121642: LIST
121643: PPUSH
121644: CALL_OW 72
121648: ST_TO_ADDR
// if tmp then
121649: LD_VAR 0 11
121653: IFFALSE 121692
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
121655: LD_ADDR_EXP 75
121659: PUSH
121660: LD_EXP 75
121664: PPUSH
121665: LD_VAR 0 1
121669: PPUSH
121670: LD_EXP 75
121674: PUSH
121675: LD_VAR 0 1
121679: ARRAY
121680: PUSH
121681: LD_VAR 0 11
121685: UNION
121686: PPUSH
121687: CALL_OW 1
121691: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121692: LD_VAR 0 1
121696: PPUSH
121697: LD_INT 19
121699: PPUSH
121700: CALL 65135 0 2
// repeat wait ( 0 0$1 ) ;
121704: LD_INT 35
121706: PPUSH
121707: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121711: LD_EXP 63
121715: PUSH
121716: LD_VAR 0 1
121720: ARRAY
121721: NOT
121722: IFTRUE 121739
121724: PUSH
121725: LD_EXP 63
121729: PUSH
121730: LD_VAR 0 1
121734: ARRAY
121735: PUSH
121736: EMPTY
121737: EQUAL
121738: OR
121739: IFFALSE 121776
// begin for i in defenders do
121741: LD_ADDR_VAR 0 4
121745: PUSH
121746: LD_VAR 0 2
121750: PUSH
121751: FOR_IN
121752: IFFALSE 121765
// ComStop ( i ) ;
121754: LD_VAR 0 4
121758: PPUSH
121759: CALL_OW 141
121763: GO 121751
121765: POP
121766: POP
// defenders := [ ] ;
121767: LD_ADDR_VAR 0 2
121771: PUSH
121772: EMPTY
121773: ST_TO_ADDR
// exit ;
121774: GO 122006
// end ; for i in defenders do
121776: LD_ADDR_VAR 0 4
121780: PUSH
121781: LD_VAR 0 2
121785: PUSH
121786: FOR_IN
121787: IFFALSE 121876
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121789: LD_VAR 0 4
121793: PPUSH
121794: LD_EXP 87
121798: PUSH
121799: LD_VAR 0 1
121803: ARRAY
121804: PPUSH
121805: CALL_OW 308
121809: NOT
121810: IFFALSE 121834
// ComMoveToArea ( i , mc_parking [ base ] ) else
121812: LD_VAR 0 4
121816: PPUSH
121817: LD_EXP 87
121821: PUSH
121822: LD_VAR 0 1
121826: ARRAY
121827: PPUSH
121828: CALL_OW 113
121832: GO 121874
// if GetControl ( i ) = control_manual then
121834: LD_VAR 0 4
121838: PPUSH
121839: CALL_OW 263
121843: PUSH
121844: LD_INT 1
121846: EQUAL
121847: IFFALSE 121874
// if IsDrivenBy ( i ) then
121849: LD_VAR 0 4
121853: PPUSH
121854: CALL_OW 311
121858: IFFALSE 121874
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121860: LD_VAR 0 4
121864: PPUSH
121865: CALL_OW 311
121869: PPUSH
121870: CALL_OW 121
// end ;
121874: GO 121786
121876: POP
121877: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121878: LD_VAR 0 2
121882: PPUSH
121883: LD_INT 95
121885: PUSH
121886: LD_EXP 87
121890: PUSH
121891: LD_VAR 0 1
121895: ARRAY
121896: PUSH
121897: EMPTY
121898: LIST
121899: LIST
121900: PPUSH
121901: CALL_OW 72
121905: PUSH
121906: LD_VAR 0 2
121910: EQUAL
121911: IFTRUE 121925
121913: PUSH
121914: LD_EXP 86
121918: PUSH
121919: LD_VAR 0 1
121923: ARRAY
121924: OR
121925: IFTRUE 121940
121927: PUSH
121928: LD_EXP 63
121932: PUSH
121933: LD_VAR 0 1
121937: ARRAY
121938: NOT
121939: OR
121940: IFFALSE 121704
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121942: LD_ADDR_EXP 85
121946: PUSH
121947: LD_EXP 85
121951: PPUSH
121952: LD_VAR 0 1
121956: PPUSH
121957: LD_VAR 0 2
121961: PPUSH
121962: LD_INT 21
121964: PUSH
121965: LD_INT 2
121967: PUSH
121968: EMPTY
121969: LIST
121970: LIST
121971: PPUSH
121972: CALL_OW 72
121976: PPUSH
121977: CALL_OW 1
121981: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121982: LD_VAR 0 1
121986: PPUSH
121987: LD_INT 19
121989: PPUSH
121990: CALL 65135 0 2
// MC_Reset ( base , 20 ) ;
121994: LD_VAR 0 1
121998: PPUSH
121999: LD_INT 20
122001: PPUSH
122002: CALL 65135 0 2
// end ; end_of_file
122006: LD_VAR 0 3
122010: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
122011: LD_VAR 0 1
122015: PUSH
122016: LD_INT 200
122018: DOUBLE
122019: GREATEREQUAL
122020: IFFALSE 122028
122022: LD_INT 299
122024: DOUBLE
122025: LESSEQUAL
122026: IFTRUE 122030
122028: GO 122062
122030: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
122031: LD_VAR 0 1
122035: PPUSH
122036: LD_VAR 0 2
122040: PPUSH
122041: LD_VAR 0 3
122045: PPUSH
122046: LD_VAR 0 4
122050: PPUSH
122051: LD_VAR 0 5
122055: PPUSH
122056: CALL 108864 0 5
122060: GO 122139
122062: LD_INT 300
122064: DOUBLE
122065: GREATEREQUAL
122066: IFFALSE 122074
122068: LD_INT 399
122070: DOUBLE
122071: LESSEQUAL
122072: IFTRUE 122076
122074: GO 122138
122076: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
122077: LD_VAR 0 1
122081: PPUSH
122082: LD_VAR 0 2
122086: PPUSH
122087: LD_VAR 0 3
122091: PPUSH
122092: LD_VAR 0 4
122096: PPUSH
122097: LD_VAR 0 5
122101: PPUSH
122102: LD_VAR 0 6
122106: PPUSH
122107: LD_VAR 0 7
122111: PPUSH
122112: LD_VAR 0 8
122116: PPUSH
122117: LD_VAR 0 9
122121: PPUSH
122122: LD_VAR 0 10
122126: PPUSH
122127: LD_VAR 0 11
122131: PPUSH
122132: CALL 104667 0 11
122136: GO 122139
122138: POP
// end ;
122139: PPOPN 11
122141: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
122142: LD_VAR 0 1
122146: PPUSH
122147: LD_VAR 0 2
122151: PPUSH
122152: LD_VAR 0 3
122156: PPUSH
122157: LD_VAR 0 4
122161: PPUSH
122162: LD_VAR 0 5
122166: PPUSH
122167: CALL 108164 0 5
// end ; end_of_file
122171: PPOPN 5
122173: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
122174: LD_VAR 0 1
122178: PPUSH
122179: LD_VAR 0 2
122183: PPUSH
122184: LD_VAR 0 3
122188: PPUSH
122189: LD_VAR 0 4
122193: PPUSH
122194: LD_VAR 0 5
122198: PPUSH
122199: LD_VAR 0 6
122203: PPUSH
122204: CALL 92207 0 6
// end ;
122208: PPOPN 6
122210: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
122211: LD_INT 0
122213: PPUSH
// begin if not units then
122214: LD_VAR 0 1
122218: NOT
122219: IFFALSE 122223
// exit ;
122221: GO 122257
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
122223: LD_VAR 0 1
122227: PPUSH
122228: LD_VAR 0 2
122232: PPUSH
122233: LD_VAR 0 3
122237: PPUSH
122238: LD_VAR 0 4
122242: PPUSH
122243: LD_VAR 0 5
122247: PPUSH
122248: LD_VAR 0 6
122252: PPUSH
122253: CALL 114561 0 6
// end ;
122257: PPOPN 7
122259: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
122260: CALL 92087 0 0
// end ;
122264: PPOPN 1
122266: END
