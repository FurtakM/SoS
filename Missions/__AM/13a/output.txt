// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 84838 0 0
// InitMacro ;
  23: CALL 54359 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48167 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48167 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48167 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48167 0 9
// PrepareArabian ;
 172: CALL 3956 0 0
// PrepareRussian ;
 176: CALL 2927 0 0
// PrepareAlliance ;
 180: CALL 892 0 0
// MC_Start ( ) ;
 184: CALL 56524 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7318 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 83
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 84
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 78066 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 54
 281: PPUSH
 282: CALL 78492 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 78950 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 79219 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 109
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 78432 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 79126 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 51
 390: PPUSH
 391: CALL 78492 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 78950 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 79219 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 78276 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 79537 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 78432 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 52
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 10
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 11
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// abdul_escaped := true ;
 779: LD_ADDR_EXP 12
 783: PUSH
 784: LD_INT 1
 786: ST_TO_ADDR
// loss_counter := 0 ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 0
 794: ST_TO_ADDR
// hack_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// end ;
 803: LD_VAR 0 1
 807: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 808: LD_EXP 48
 812: PPUSH
 813: CALL_OW 255
 817: PUSH
 818: LD_INT 7
 820: EQUAL
 821: PUSH
 822: LD_EXP 47
 826: PPUSH
 827: CALL_OW 255
 831: PUSH
 832: LD_INT 7
 834: EQUAL
 835: AND
 836: PUSH
 837: LD_EXP 48
 841: PPUSH
 842: CALL_OW 302
 846: AND
 847: PUSH
 848: LD_EXP 47
 852: PPUSH
 853: CALL_OW 302
 857: AND
 858: IFFALSE 870
 860: GO 862
 862: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 863: LD_STRING ACH_COMRADE
 865: PPUSH
 866: CALL_OW 543
 870: END
// every 0 0$1 trigger hack_counter >= 10 do
 871: LD_EXP 14
 875: PUSH
 876: LD_INT 10
 878: GREATEREQUAL
 879: IFFALSE 891
 881: GO 883
 883: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 884: LD_STRING ACH_HACK
 886: PPUSH
 887: CALL_OW 543
 891: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 892: LD_INT 0
 894: PPUSH
 895: PPUSH
 896: PPUSH
 897: PPUSH
// uc_side := 7 ;
 898: LD_ADDR_OWVAR 20
 902: PUSH
 903: LD_INT 7
 905: ST_TO_ADDR
// uc_nation := 1 ;
 906: LD_ADDR_OWVAR 21
 910: PUSH
 911: LD_INT 1
 913: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 914: LD_ADDR_EXP 15
 918: PUSH
 919: LD_STRING JMM
 921: PPUSH
 922: LD_EXP 1
 926: NOT
 927: PPUSH
 928: LD_STRING 12a_
 930: PPUSH
 931: CALL 14804 0 3
 935: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 936: LD_EXP 15
 940: PPUSH
 941: LD_INT 71
 943: PPUSH
 944: LD_INT 23
 946: PPUSH
 947: LD_INT 0
 949: PPUSH
 950: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 954: LD_EXP 15
 958: PPUSH
 959: LD_INT 2
 961: PPUSH
 962: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 966: LD_ADDR_EXP 16
 970: PUSH
 971: LD_STRING Roth
 973: PPUSH
 974: LD_EXP 1
 978: NOT
 979: PPUSH
 980: LD_STRING 12a_
 982: PPUSH
 983: CALL 14804 0 3
 987: ST_TO_ADDR
// if Roth then
 988: LD_EXP 16
 992: IFFALSE 1012
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 994: LD_EXP 16
 998: PPUSH
 999: LD_INT 71
1001: PPUSH
1002: LD_INT 21
1004: PPUSH
1005: LD_INT 0
1007: PPUSH
1008: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1012: LD_ADDR_EXP 17
1016: PUSH
1017: LD_STRING Lisa
1019: PPUSH
1020: LD_EXP 1
1024: NOT
1025: PPUSH
1026: LD_STRING 12a_
1028: PPUSH
1029: CALL 14804 0 3
1033: ST_TO_ADDR
// if Lisa then
1034: LD_EXP 17
1038: IFFALSE 1055
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1040: LD_EXP 17
1044: PPUSH
1045: LD_INT 13
1047: PPUSH
1048: LD_INT 0
1050: PPUSH
1051: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1055: LD_ADDR_EXP 18
1059: PUSH
1060: LD_STRING Donaldson
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_STRING 12a_
1071: PPUSH
1072: CALL 14804 0 3
1076: ST_TO_ADDR
// if Donaldson then
1077: LD_EXP 18
1081: IFFALSE 1098
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1083: LD_EXP 18
1087: PPUSH
1088: LD_INT 13
1090: PPUSH
1091: LD_INT 0
1093: PPUSH
1094: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1098: LD_ADDR_EXP 19
1102: PUSH
1103: LD_STRING Bobby
1105: PPUSH
1106: LD_EXP 1
1110: NOT
1111: PPUSH
1112: LD_STRING 12a_
1114: PPUSH
1115: CALL 14804 0 3
1119: ST_TO_ADDR
// if Bobby then
1120: LD_EXP 19
1124: IFFALSE 1141
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1126: LD_EXP 19
1130: PPUSH
1131: LD_INT 13
1133: PPUSH
1134: LD_INT 0
1136: PPUSH
1137: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1141: LD_ADDR_EXP 20
1145: PUSH
1146: LD_STRING Cyrus
1148: PPUSH
1149: LD_EXP 1
1153: NOT
1154: PPUSH
1155: LD_STRING 12a_
1157: PPUSH
1158: CALL 14804 0 3
1162: ST_TO_ADDR
// if Cyrus then
1163: LD_EXP 20
1167: IFFALSE 1184
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1169: LD_EXP 20
1173: PPUSH
1174: LD_INT 13
1176: PPUSH
1177: LD_INT 0
1179: PPUSH
1180: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1184: LD_ADDR_EXP 21
1188: PUSH
1189: LD_STRING Denis
1191: PPUSH
1192: LD_EXP 1
1196: NOT
1197: PPUSH
1198: LD_STRING 12a_
1200: PPUSH
1201: CALL 14804 0 3
1205: ST_TO_ADDR
// if Denis then
1206: LD_EXP 21
1210: IFFALSE 1227
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1212: LD_EXP 21
1216: PPUSH
1217: LD_INT 13
1219: PPUSH
1220: LD_INT 0
1222: PPUSH
1223: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1227: LD_ADDR_EXP 22
1231: PUSH
1232: LD_STRING Brown
1234: PPUSH
1235: LD_EXP 1
1239: NOT
1240: PPUSH
1241: LD_STRING 12a_
1243: PPUSH
1244: CALL 14804 0 3
1248: ST_TO_ADDR
// if Brown then
1249: LD_EXP 22
1253: IFFALSE 1270
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1255: LD_EXP 22
1259: PPUSH
1260: LD_INT 13
1262: PPUSH
1263: LD_INT 0
1265: PPUSH
1266: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1270: LD_ADDR_EXP 23
1274: PUSH
1275: LD_STRING Gladstone
1277: PPUSH
1278: LD_EXP 1
1282: NOT
1283: PPUSH
1284: LD_STRING 12a_
1286: PPUSH
1287: CALL 14804 0 3
1291: ST_TO_ADDR
// if Gladstone then
1292: LD_EXP 23
1296: IFFALSE 1313
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1298: LD_EXP 23
1302: PPUSH
1303: LD_INT 13
1305: PPUSH
1306: LD_INT 0
1308: PPUSH
1309: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1313: LD_ADDR_EXP 24
1317: PUSH
1318: LD_STRING Houten
1320: PPUSH
1321: LD_EXP 1
1325: NOT
1326: PPUSH
1327: LD_STRING 12a_
1329: PPUSH
1330: CALL 14804 0 3
1334: ST_TO_ADDR
// if Houten then
1335: LD_EXP 24
1339: IFFALSE 1356
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1341: LD_EXP 24
1345: PPUSH
1346: LD_INT 13
1348: PPUSH
1349: LD_INT 0
1351: PPUSH
1352: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1356: LD_ADDR_EXP 25
1360: PUSH
1361: LD_STRING Cornell
1363: PPUSH
1364: LD_EXP 1
1368: NOT
1369: PPUSH
1370: LD_STRING 12a_
1372: PPUSH
1373: CALL 14804 0 3
1377: ST_TO_ADDR
// if Cornel then
1378: LD_EXP 25
1382: IFFALSE 1399
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1384: LD_EXP 25
1388: PPUSH
1389: LD_INT 13
1391: PPUSH
1392: LD_INT 0
1394: PPUSH
1395: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1399: LD_ADDR_EXP 26
1403: PUSH
1404: LD_STRING Gary
1406: PPUSH
1407: LD_EXP 1
1411: NOT
1412: PPUSH
1413: LD_STRING 12a_
1415: PPUSH
1416: CALL 14804 0 3
1420: ST_TO_ADDR
// if Gary then
1421: LD_EXP 26
1425: IFFALSE 1442
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1427: LD_EXP 26
1431: PPUSH
1432: LD_INT 13
1434: PPUSH
1435: LD_INT 0
1437: PPUSH
1438: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1442: LD_ADDR_EXP 27
1446: PUSH
1447: LD_STRING Frank
1449: PPUSH
1450: LD_EXP 1
1454: NOT
1455: PPUSH
1456: LD_STRING 12a_
1458: PPUSH
1459: CALL 14804 0 3
1463: ST_TO_ADDR
// if Frank then
1464: LD_EXP 27
1468: IFFALSE 1485
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1470: LD_EXP 27
1474: PPUSH
1475: LD_INT 13
1477: PPUSH
1478: LD_INT 0
1480: PPUSH
1481: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1485: LD_ADDR_EXP 28
1489: PUSH
1490: LD_STRING Kikuchi
1492: PPUSH
1493: LD_EXP 1
1497: NOT
1498: PPUSH
1499: LD_STRING 12a_
1501: PPUSH
1502: CALL 14804 0 3
1506: ST_TO_ADDR
// if Kikuchi then
1507: LD_EXP 28
1511: IFFALSE 1528
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1513: LD_EXP 28
1517: PPUSH
1518: LD_INT 13
1520: PPUSH
1521: LD_INT 0
1523: PPUSH
1524: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1528: LD_ADDR_EXP 29
1532: PUSH
1533: LD_STRING Simms
1535: PPUSH
1536: LD_EXP 1
1540: NOT
1541: PPUSH
1542: LD_STRING 12a_
1544: PPUSH
1545: CALL 14804 0 3
1549: ST_TO_ADDR
// if Simms then
1550: LD_EXP 29
1554: IFFALSE 1571
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1556: LD_EXP 29
1560: PPUSH
1561: LD_INT 13
1563: PPUSH
1564: LD_INT 0
1566: PPUSH
1567: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1571: LD_ADDR_EXP 30
1575: PUSH
1576: LD_STRING Joan
1578: PPUSH
1579: LD_EXP 1
1583: NOT
1584: PPUSH
1585: LD_STRING 12a_
1587: PPUSH
1588: CALL 14804 0 3
1592: ST_TO_ADDR
// if Joan then
1593: LD_EXP 30
1597: IFFALSE 1614
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1599: LD_EXP 30
1603: PPUSH
1604: LD_INT 13
1606: PPUSH
1607: LD_INT 0
1609: PPUSH
1610: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1614: LD_ADDR_EXP 31
1618: PUSH
1619: LD_STRING DeltaDoctor
1621: PPUSH
1622: LD_EXP 1
1626: NOT
1627: PPUSH
1628: LD_STRING 12a_
1630: PPUSH
1631: CALL 14804 0 3
1635: ST_TO_ADDR
// if DeltaDoctor then
1636: LD_EXP 31
1640: IFFALSE 1657
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1642: LD_EXP 31
1646: PPUSH
1647: LD_INT 13
1649: PPUSH
1650: LD_INT 0
1652: PPUSH
1653: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1657: LD_ADDR_VAR 0 4
1661: PUSH
1662: LD_STRING 12a_others
1664: PPUSH
1665: CALL_OW 31
1669: ST_TO_ADDR
// if tmp then
1670: LD_VAR 0 4
1674: IFFALSE 1708
// for i in tmp do
1676: LD_ADDR_VAR 0 3
1680: PUSH
1681: LD_VAR 0 4
1685: PUSH
1686: FOR_IN
1687: IFFALSE 1706
// PlaceUnitArea ( i , alliance_start , false ) ;
1689: LD_VAR 0 3
1693: PPUSH
1694: LD_INT 13
1696: PPUSH
1697: LD_INT 0
1699: PPUSH
1700: CALL_OW 49
1704: GO 1686
1706: POP
1707: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1708: LD_INT 3
1710: PPUSH
1711: LD_INT 3
1713: PPUSH
1714: LD_INT 3
1716: PPUSH
1717: LD_INT 12
1719: PPUSH
1720: LD_INT 100
1722: PPUSH
1723: CALL 19668 0 5
// veh := CreateVehicle ;
1727: LD_ADDR_VAR 0 2
1731: PUSH
1732: CALL_OW 45
1736: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1737: LD_VAR 0 2
1741: PPUSH
1742: LD_INT 2
1744: PPUSH
1745: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1749: LD_VAR 0 2
1753: PPUSH
1754: LD_INT 60
1756: PPUSH
1757: LD_INT 6
1759: PPUSH
1760: LD_INT 0
1762: PPUSH
1763: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1767: LD_VAR 0 2
1771: PPUSH
1772: LD_INT 4
1774: PPUSH
1775: LD_INT 30
1777: PPUSH
1778: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1782: LD_STRING 11_artifact_captured
1784: PPUSH
1785: LD_INT 0
1787: PPUSH
1788: CALL_OW 30
1792: IFFALSE 1868
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1794: LD_INT 3
1796: PPUSH
1797: LD_INT 3
1799: PPUSH
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 12
1805: PPUSH
1806: LD_INT 100
1808: PPUSH
1809: CALL 19668 0 5
// veh := CreateVehicle ;
1813: LD_ADDR_VAR 0 2
1817: PUSH
1818: CALL_OW 45
1822: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1823: LD_VAR 0 2
1827: PPUSH
1828: LD_INT 3
1830: PPUSH
1831: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1835: LD_VAR 0 2
1839: PPUSH
1840: LD_INT 75
1842: PPUSH
1843: LD_INT 6
1845: PPUSH
1846: LD_INT 0
1848: PPUSH
1849: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1853: LD_VAR 0 2
1857: PPUSH
1858: LD_INT 4
1860: PPUSH
1861: LD_INT 50
1863: PPUSH
1864: CALL_OW 290
// end ; end ;
1868: LD_VAR 0 1
1872: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1873: LD_INT 0
1875: PPUSH
1876: PPUSH
1877: PPUSH
1878: PPUSH
// uc_side := 6 ;
1879: LD_ADDR_OWVAR 20
1883: PUSH
1884: LD_INT 6
1886: ST_TO_ADDR
// uc_nation := 3 ;
1887: LD_ADDR_OWVAR 21
1891: PUSH
1892: LD_INT 3
1894: ST_TO_ADDR
// InitHc ;
1895: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1899: LD_ADDR_EXP 32
1903: PUSH
1904: LD_STRING Gossudarov
1906: PPUSH
1907: CALL_OW 25
1911: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1912: LD_ADDR_EXP 33
1916: PUSH
1917: LD_STRING Kirilenkova
1919: PPUSH
1920: CALL_OW 25
1924: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1925: LD_ADDR_EXP 34
1929: PUSH
1930: LD_STRING Titov
1932: PPUSH
1933: CALL_OW 25
1937: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1938: LD_ADDR_EXP 39
1942: PUSH
1943: LD_STRING Oblukov
1945: PPUSH
1946: CALL_OW 25
1950: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1951: LD_ADDR_EXP 36
1955: PUSH
1956: LD_STRING Dolgov
1958: PPUSH
1959: CALL_OW 25
1963: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1964: LD_ADDR_EXP 37
1968: PUSH
1969: LD_STRING Petrosyan
1971: PPUSH
1972: CALL_OW 25
1976: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1977: LD_ADDR_EXP 38
1981: PUSH
1982: LD_STRING Scholtze
1984: PPUSH
1985: CALL_OW 25
1989: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1990: LD_ADDR_EXP 40
1994: PUSH
1995: LD_STRING Kapitsova
1997: PPUSH
1998: CALL_OW 25
2002: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2003: LD_ADDR_VAR 0 2
2007: PUSH
2008: LD_EXP 32
2012: PUSH
2013: LD_EXP 33
2017: PUSH
2018: LD_EXP 34
2022: PUSH
2023: LD_EXP 39
2027: PUSH
2028: LD_EXP 36
2032: PUSH
2033: LD_EXP 37
2037: PUSH
2038: LD_EXP 38
2042: PUSH
2043: LD_EXP 40
2047: PUSH
2048: EMPTY
2049: LIST
2050: LIST
2051: LIST
2052: LIST
2053: LIST
2054: LIST
2055: LIST
2056: LIST
2057: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2058: LD_INT 1
2060: PPUSH
2061: LD_INT 4
2063: PPUSH
2064: LD_INT 8
2066: PPUSH
2067: CALL_OW 380
// un := CreateHuman ;
2071: LD_ADDR_VAR 0 4
2075: PUSH
2076: CALL_OW 44
2080: ST_TO_ADDR
// tmp := tmp ^ un ;
2081: LD_ADDR_VAR 0 2
2085: PUSH
2086: LD_VAR 0 2
2090: PUSH
2091: LD_VAR 0 4
2095: ADD
2096: ST_TO_ADDR
// for i in tmp do
2097: LD_ADDR_VAR 0 3
2101: PUSH
2102: LD_VAR 0 2
2106: PUSH
2107: FOR_IN
2108: IFFALSE 2127
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2110: LD_VAR 0 3
2114: PPUSH
2115: LD_INT 14
2117: PPUSH
2118: LD_INT 0
2120: PPUSH
2121: CALL_OW 49
2125: GO 2107
2127: POP
2128: POP
// if freedom then
2129: LD_EXP 3
2133: IFFALSE 2166
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2135: LD_VAR 0 2
2139: PPUSH
2140: LD_EXP 3
2144: PPUSH
2145: CALL_OW 250
2149: PPUSH
2150: LD_EXP 3
2154: PPUSH
2155: CALL_OW 251
2159: PPUSH
2160: CALL_OW 111
2164: GO 2181
// ComMoveXY ( tmp , 70 , 48 ) ;
2166: LD_VAR 0 2
2170: PPUSH
2171: LD_INT 70
2173: PPUSH
2174: LD_INT 48
2176: PPUSH
2177: CALL_OW 111
// end ;
2181: LD_VAR 0 1
2185: RET
// export function PrepareBelkov ; begin
2186: LD_INT 0
2188: PPUSH
// uc_side := 4 ;
2189: LD_ADDR_OWVAR 20
2193: PUSH
2194: LD_INT 4
2196: ST_TO_ADDR
// uc_nation := 3 ;
2197: LD_ADDR_OWVAR 21
2201: PUSH
2202: LD_INT 3
2204: ST_TO_ADDR
// InitHc ;
2205: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2209: LD_ADDR_EXP 47
2213: PUSH
2214: LD_STRING Belkov
2216: PPUSH
2217: CALL_OW 25
2221: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2222: LD_EXP 47
2226: PPUSH
2227: LD_INT 14
2229: PPUSH
2230: LD_INT 0
2232: PPUSH
2233: CALL_OW 49
// end ;
2237: LD_VAR 0 1
2241: RET
// export function PrepareGnyevko ; begin
2242: LD_INT 0
2244: PPUSH
// uc_side := 4 ;
2245: LD_ADDR_OWVAR 20
2249: PUSH
2250: LD_INT 4
2252: ST_TO_ADDR
// uc_nation := 3 ;
2253: LD_ADDR_OWVAR 21
2257: PUSH
2258: LD_INT 3
2260: ST_TO_ADDR
// InitHc ;
2261: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2265: LD_ADDR_EXP 48
2269: PUSH
2270: LD_STRING Gnyevko
2272: PPUSH
2273: CALL_OW 25
2277: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 14
2285: PPUSH
2286: LD_INT 0
2288: PPUSH
2289: CALL_OW 49
// end ;
2293: LD_VAR 0 1
2297: RET
// export function PrepareBurlak ; var i , tmp ; begin
2298: LD_INT 0
2300: PPUSH
2301: PPUSH
2302: PPUSH
// uc_side := 4 ;
2303: LD_ADDR_OWVAR 20
2307: PUSH
2308: LD_INT 4
2310: ST_TO_ADDR
// uc_nation := 3 ;
2311: LD_ADDR_OWVAR 21
2315: PUSH
2316: LD_INT 3
2318: ST_TO_ADDR
// InitHc ;
2319: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2323: LD_ADDR_EXP 46
2327: PUSH
2328: LD_STRING Burlak
2330: PPUSH
2331: CALL_OW 25
2335: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2336: LD_INT 24
2338: PUSH
2339: LD_INT 23
2341: PUSH
2342: LD_INT 22
2344: PUSH
2345: LD_INT 22
2347: PUSH
2348: EMPTY
2349: LIST
2350: LIST
2351: LIST
2352: LIST
2353: PUSH
2354: LD_OWVAR 67
2358: ARRAY
2359: PPUSH
2360: LD_INT 1
2362: PPUSH
2363: LD_INT 1
2365: PPUSH
2366: LD_INT 45
2368: PUSH
2369: LD_INT 44
2371: PUSH
2372: LD_INT 43
2374: PUSH
2375: LD_INT 42
2377: PUSH
2378: EMPTY
2379: LIST
2380: LIST
2381: LIST
2382: LIST
2383: PUSH
2384: LD_OWVAR 67
2388: ARRAY
2389: PPUSH
2390: LD_INT 0
2392: PPUSH
2393: CALL 19668 0 5
// Masha := CreateVehicle ;
2397: LD_ADDR_EXP 49
2401: PUSH
2402: CALL_OW 45
2406: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2407: LD_EXP 49
2411: PUSH
2412: LD_EXP 46
2416: PUSH
2417: EMPTY
2418: LIST
2419: LIST
2420: PPUSH
2421: LD_INT 499
2423: PPUSH
2424: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2428: LD_EXP 49
2432: PPUSH
2433: LD_INT 3
2435: PPUSH
2436: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2440: LD_EXP 49
2444: PPUSH
2445: LD_INT 1
2447: PPUSH
2448: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2452: LD_INT 1
2454: PPUSH
2455: LD_INT 18
2457: PPUSH
2458: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2462: LD_INT 35
2464: PPUSH
2465: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2469: LD_ADDR_VAR 0 3
2473: PUSH
2474: LD_INT 18
2476: PPUSH
2477: EMPTY
2478: PPUSH
2479: CALL_OW 70
2483: ST_TO_ADDR
// if tmp then
2484: LD_VAR 0 3
2488: IFFALSE 2522
// for i in tmp do
2490: LD_ADDR_VAR 0 2
2494: PUSH
2495: LD_VAR 0 3
2499: PUSH
2500: FOR_IN
2501: IFFALSE 2520
// ComMoveXY ( i , 114 , 9 ) ;
2503: LD_VAR 0 2
2507: PPUSH
2508: LD_INT 114
2510: PPUSH
2511: LD_INT 9
2513: PPUSH
2514: CALL_OW 111
2518: GO 2500
2520: POP
2521: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2522: LD_INT 18
2524: PPUSH
2525: EMPTY
2526: PPUSH
2527: CALL_OW 70
2531: NOT
2532: PUSH
2533: LD_INT 123
2535: PPUSH
2536: LD_INT 3
2538: PPUSH
2539: CALL_OW 428
2543: PUSH
2544: LD_INT 0
2546: EQUAL
2547: AND
2548: IFFALSE 2462
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2550: LD_EXP 49
2554: PPUSH
2555: LD_INT 123
2557: PPUSH
2558: LD_INT 3
2560: PPUSH
2561: LD_INT 0
2563: PPUSH
2564: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2568: LD_EXP 46
2572: PPUSH
2573: LD_INT 125
2575: PPUSH
2576: LD_INT 1
2578: PPUSH
2579: LD_INT 0
2581: PPUSH
2582: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2586: LD_EXP 46
2590: PPUSH
2591: LD_EXP 49
2595: PPUSH
2596: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2600: LD_INT 10
2602: PPUSH
2603: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2607: LD_EXP 49
2611: PPUSH
2612: LD_INT 110
2614: PPUSH
2615: LD_INT 10
2617: PPUSH
2618: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2622: LD_ADDR_EXP 42
2626: PUSH
2627: LD_STRING Petrovova
2629: PPUSH
2630: CALL_OW 25
2634: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2635: LD_ADDR_EXP 44
2639: PUSH
2640: LD_STRING Kuzmov
2642: PPUSH
2643: CALL_OW 25
2647: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2648: LD_ADDR_EXP 43
2652: PUSH
2653: LD_STRING Kovalyuk
2655: PPUSH
2656: CALL_OW 25
2660: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2661: LD_ADDR_EXP 41
2665: PUSH
2666: LD_STRING Lipshchin
2668: PPUSH
2669: CALL_OW 25
2673: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2674: LD_ADDR_EXP 45
2678: PUSH
2679: LD_STRING Karamazov
2681: PPUSH
2682: CALL_OW 25
2686: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2687: LD_ADDR_VAR 0 3
2691: PUSH
2692: LD_EXP 42
2696: PUSH
2697: LD_EXP 44
2701: PUSH
2702: LD_EXP 43
2706: PUSH
2707: LD_EXP 41
2711: PUSH
2712: LD_EXP 45
2716: PUSH
2717: EMPTY
2718: LIST
2719: LIST
2720: LIST
2721: LIST
2722: LIST
2723: ST_TO_ADDR
// for i in tmp do
2724: LD_ADDR_VAR 0 2
2728: PUSH
2729: LD_VAR 0 3
2733: PUSH
2734: FOR_IN
2735: IFFALSE 2774
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2737: LD_VAR 0 2
2741: PPUSH
2742: LD_INT 399
2744: PPUSH
2745: LD_INT 799
2747: PPUSH
2748: CALL_OW 12
2752: PPUSH
2753: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2757: LD_VAR 0 2
2761: PPUSH
2762: LD_INT 19
2764: PPUSH
2765: LD_INT 0
2767: PPUSH
2768: CALL_OW 49
// end ;
2772: GO 2734
2774: POP
2775: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2776: LD_VAR 0 3
2780: PPUSH
2781: LD_INT 116
2783: PPUSH
2784: LD_INT 8
2786: PPUSH
2787: CALL_OW 111
// AddComHold ( tmp ) ;
2791: LD_VAR 0 3
2795: PPUSH
2796: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2800: LD_ADDR_VAR 0 2
2804: PUSH
2805: LD_VAR 0 3
2809: PPUSH
2810: LD_INT 25
2812: PUSH
2813: LD_INT 1
2815: PUSH
2816: EMPTY
2817: LIST
2818: LIST
2819: PPUSH
2820: CALL_OW 72
2824: PUSH
2825: FOR_IN
2826: IFFALSE 2866
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2828: LD_VAR 0 2
2832: PPUSH
2833: LD_INT 20
2835: PPUSH
2836: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2840: LD_VAR 0 2
2844: PPUSH
2845: LD_INT 147
2847: PPUSH
2848: LD_INT 45
2850: PPUSH
2851: CALL_OW 178
// AddComCrawl ( i ) ;
2855: LD_VAR 0 2
2859: PPUSH
2860: CALL_OW 197
// end ;
2864: GO 2825
2866: POP
2867: POP
// repeat wait ( 0 0$1 ) ;
2868: LD_INT 35
2870: PPUSH
2871: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2875: LD_EXP 49
2879: PPUSH
2880: LD_INT 110
2882: PPUSH
2883: LD_INT 10
2885: PPUSH
2886: CALL_OW 307
2890: PUSH
2891: LD_EXP 49
2895: PPUSH
2896: CALL_OW 305
2900: NOT
2901: OR
2902: IFFALSE 2868
// ComStop ( Burlak ) ;
2904: LD_EXP 46
2908: PPUSH
2909: CALL_OW 141
// AddComHold ( Burlak ) ;
2913: LD_EXP 46
2917: PPUSH
2918: CALL_OW 200
// end ; end_of_file
2922: LD_VAR 0 1
2926: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2927: LD_INT 0
2929: PPUSH
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
// uc_side := 3 ;
2934: LD_ADDR_OWVAR 20
2938: PUSH
2939: LD_INT 3
2941: ST_TO_ADDR
// uc_nation := 3 ;
2942: LD_ADDR_OWVAR 21
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2950: LD_ADDR_EXP 50
2954: PUSH
2955: LD_INT 47
2957: PPUSH
2958: LD_INT 4
2960: PPUSH
2961: LD_STRING 
2963: PPUSH
2964: LD_INT 7
2966: PUSH
2967: LD_INT 8
2969: PUSH
2970: LD_INT 9
2972: PUSH
2973: LD_INT 10
2975: PUSH
2976: EMPTY
2977: LIST
2978: LIST
2979: LIST
2980: LIST
2981: PUSH
2982: LD_OWVAR 67
2986: ARRAY
2987: PPUSH
2988: LD_INT 10000
2990: PUSH
2991: LD_INT 3000
2993: PUSH
2994: LD_INT 300
2996: PUSH
2997: EMPTY
2998: LIST
2999: LIST
3000: LIST
3001: PPUSH
3002: LD_INT 9
3004: PUSH
3005: LD_INT 5
3007: PUSH
3008: LD_INT 6
3010: PUSH
3011: LD_INT 6
3013: PUSH
3014: EMPTY
3015: LIST
3016: LIST
3017: LIST
3018: LIST
3019: PPUSH
3020: CALL 23114 0 6
3024: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3025: LD_ADDR_EXP 59
3029: PUSH
3030: LD_EXP 59
3034: PPUSH
3035: LD_INT 2
3037: PPUSH
3038: LD_EXP 50
3042: PPUSH
3043: CALL_OW 1
3047: ST_TO_ADDR
// tmp := [ ] ;
3048: LD_ADDR_VAR 0 4
3052: PUSH
3053: EMPTY
3054: ST_TO_ADDR
// for i = 1 to 4 do
3055: LD_ADDR_VAR 0 2
3059: PUSH
3060: DOUBLE
3061: LD_INT 1
3063: DEC
3064: ST_TO_ADDR
3065: LD_INT 4
3067: PUSH
3068: FOR_TO
3069: IFFALSE 3162
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3071: LD_INT 22
3073: PPUSH
3074: LD_INT 3
3076: PPUSH
3077: LD_INT 3
3079: PPUSH
3080: LD_INT 43
3082: PUSH
3083: LD_INT 45
3085: PUSH
3086: LD_INT 45
3088: PUSH
3089: LD_INT 44
3091: PUSH
3092: EMPTY
3093: LIST
3094: LIST
3095: LIST
3096: LIST
3097: PUSH
3098: LD_VAR 0 2
3102: PUSH
3103: LD_INT 4
3105: MOD
3106: PUSH
3107: LD_INT 1
3109: PLUS
3110: ARRAY
3111: PPUSH
3112: LD_INT 100
3114: PPUSH
3115: CALL 19668 0 5
// veh := CreateVehicle ;
3119: LD_ADDR_VAR 0 3
3123: PUSH
3124: CALL_OW 45
3128: ST_TO_ADDR
// tmp := tmp ^ veh ;
3129: LD_ADDR_VAR 0 4
3133: PUSH
3134: LD_VAR 0 4
3138: PUSH
3139: LD_VAR 0 3
3143: ADD
3144: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3145: LD_VAR 0 3
3149: PPUSH
3150: LD_INT 2
3152: PPUSH
3153: LD_INT 0
3155: PPUSH
3156: CALL_OW 49
// end ;
3160: GO 3068
3162: POP
3163: POP
// russian_guard := tmp ;
3164: LD_ADDR_EXP 51
3168: PUSH
3169: LD_VAR 0 4
3173: ST_TO_ADDR
// if Difficulty >= 3 then
3174: LD_OWVAR 67
3178: PUSH
3179: LD_INT 3
3181: GREATEREQUAL
3182: IFFALSE 3246
// begin bc_type := b_breastwork ;
3184: LD_ADDR_OWVAR 42
3188: PUSH
3189: LD_INT 31
3191: ST_TO_ADDR
// bc_level := 10 ;
3192: LD_ADDR_OWVAR 43
3196: PUSH
3197: LD_INT 10
3199: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3200: LD_ADDR_VAR 0 5
3204: PUSH
3205: LD_INT 96
3207: PPUSH
3208: LD_INT 105
3210: PPUSH
3211: LD_INT 3
3213: PPUSH
3214: CALL_OW 47
3218: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3219: LD_INT 0
3221: PPUSH
3222: LD_INT 9
3224: PPUSH
3225: LD_INT 10
3227: PPUSH
3228: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3232: CALL_OW 44
3236: PPUSH
3237: LD_VAR 0 5
3241: PPUSH
3242: CALL_OW 52
// end ; end ;
3246: LD_VAR 0 1
3250: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3251: LD_INT 47
3253: PPUSH
3254: CALL_OW 302
3258: PUSH
3259: LD_EXP 6
3263: AND
3264: IFFALSE 3953
3266: GO 3268
3268: DISABLE
3269: LD_INT 0
3271: PPUSH
3272: PPUSH
3273: PPUSH
3274: PPUSH
3275: PPUSH
3276: PPUSH
3277: PPUSH
// begin enable ;
3278: ENABLE
// base := 2 ;
3279: LD_ADDR_VAR 0 2
3283: PUSH
3284: LD_INT 2
3286: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3287: LD_ADDR_VAR 0 4
3291: PUSH
3292: LD_INT 0
3294: PUSH
3295: LD_INT 0
3297: PUSH
3298: LD_INT 0
3300: PUSH
3301: LD_INT 0
3303: PUSH
3304: LD_INT 0
3306: PUSH
3307: LD_INT 0
3309: PUSH
3310: LD_INT 0
3312: PUSH
3313: LD_INT 0
3315: PUSH
3316: LD_INT 1
3318: PUSH
3319: LD_INT 0
3321: PUSH
3322: EMPTY
3323: LIST
3324: LIST
3325: LIST
3326: LIST
3327: LIST
3328: LIST
3329: LIST
3330: LIST
3331: LIST
3332: LIST
3333: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3334: LD_ADDR_VAR 0 3
3338: PUSH
3339: LD_INT 22
3341: PUSH
3342: LD_INT 1
3344: PUSH
3345: LD_INT 3
3347: PUSH
3348: LD_INT 45
3350: PUSH
3351: EMPTY
3352: LIST
3353: LIST
3354: LIST
3355: LIST
3356: PUSH
3357: LD_INT 21
3359: PUSH
3360: LD_INT 1
3362: PUSH
3363: LD_INT 3
3365: PUSH
3366: LD_INT 45
3368: PUSH
3369: EMPTY
3370: LIST
3371: LIST
3372: LIST
3373: LIST
3374: PUSH
3375: LD_INT 22
3377: PUSH
3378: LD_INT 1
3380: PUSH
3381: LD_INT 3
3383: PUSH
3384: LD_INT 45
3386: PUSH
3387: EMPTY
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: PUSH
3393: LD_INT 23
3395: PUSH
3396: LD_INT 1
3398: PUSH
3399: LD_INT 3
3401: PUSH
3402: LD_INT 46
3404: PUSH
3405: EMPTY
3406: LIST
3407: LIST
3408: LIST
3409: LIST
3410: PUSH
3411: EMPTY
3412: LIST
3413: LIST
3414: LIST
3415: LIST
3416: ST_TO_ADDR
// amount := Difficulty ;
3417: LD_ADDR_VAR 0 7
3421: PUSH
3422: LD_OWVAR 67
3426: ST_TO_ADDR
// if tick > 30 30$00 then
3427: LD_OWVAR 1
3431: PUSH
3432: LD_INT 63000
3434: GREATER
3435: IFFALSE 3472
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3437: LD_ADDR_VAR 0 7
3441: PUSH
3442: LD_VAR 0 7
3446: PUSH
3447: LD_INT 2
3449: PUSH
3450: LD_INT 3
3452: PUSH
3453: LD_INT 4
3455: PUSH
3456: LD_INT 4
3458: PUSH
3459: EMPTY
3460: LIST
3461: LIST
3462: LIST
3463: LIST
3464: PUSH
3465: LD_OWVAR 67
3469: ARRAY
3470: PLUS
3471: ST_TO_ADDR
// for i = 1 to amount do
3472: LD_ADDR_VAR 0 1
3476: PUSH
3477: DOUBLE
3478: LD_INT 1
3480: DEC
3481: ST_TO_ADDR
3482: LD_VAR 0 7
3486: PUSH
3487: FOR_TO
3488: IFFALSE 3576
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3490: LD_ADDR_VAR 0 3
3494: PUSH
3495: LD_VAR 0 3
3499: PPUSH
3500: LD_VAR 0 3
3504: PUSH
3505: LD_INT 1
3507: PLUS
3508: PPUSH
3509: LD_INT 23
3511: PUSH
3512: LD_INT 24
3514: PUSH
3515: EMPTY
3516: LIST
3517: LIST
3518: PUSH
3519: LD_INT 1
3521: PPUSH
3522: LD_INT 2
3524: PPUSH
3525: CALL_OW 12
3529: ARRAY
3530: PUSH
3531: LD_INT 1
3533: PUSH
3534: LD_INT 3
3536: PUSH
3537: LD_INT 46
3539: PUSH
3540: LD_INT 47
3542: PUSH
3543: LD_INT 45
3545: PUSH
3546: EMPTY
3547: LIST
3548: LIST
3549: LIST
3550: PUSH
3551: LD_INT 1
3553: PPUSH
3554: LD_INT 3
3556: PPUSH
3557: CALL_OW 12
3561: ARRAY
3562: PUSH
3563: EMPTY
3564: LIST
3565: LIST
3566: LIST
3567: LIST
3568: PPUSH
3569: CALL_OW 2
3573: ST_TO_ADDR
3574: GO 3487
3576: POP
3577: POP
// MC_InsertProduceList ( base , tmp ) ;
3578: LD_VAR 0 2
3582: PPUSH
3583: LD_VAR 0 3
3587: PPUSH
3588: CALL 78432 0 2
// repeat wait ( 0 0$1 ) ;
3592: LD_INT 35
3594: PPUSH
3595: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3599: LD_VAR 0 2
3603: PPUSH
3604: LD_INT 1
3606: PPUSH
3607: CALL 79850 0 2
3611: PUSH
3612: LD_VAR 0 7
3616: GREATEREQUAL
3617: IFFALSE 3592
// wait ( 0 0$30 ) ;
3619: LD_INT 1050
3621: PPUSH
3622: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3626: LD_ADDR_VAR 0 5
3630: PUSH
3631: LD_INT 71
3633: PUSH
3634: LD_INT 19
3636: PUSH
3637: EMPTY
3638: LIST
3639: LIST
3640: PUSH
3641: LD_INT 91
3643: PUSH
3644: LD_INT 67
3646: PUSH
3647: EMPTY
3648: LIST
3649: LIST
3650: PUSH
3651: LD_INT 52
3653: PUSH
3654: LD_INT 44
3656: PUSH
3657: EMPTY
3658: LIST
3659: LIST
3660: PUSH
3661: LD_INT 68
3663: PUSH
3664: LD_INT 48
3666: PUSH
3667: EMPTY
3668: LIST
3669: LIST
3670: PUSH
3671: EMPTY
3672: LIST
3673: LIST
3674: LIST
3675: LIST
3676: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3677: LD_ADDR_VAR 0 6
3681: PUSH
3682: LD_EXP 78
3686: PUSH
3687: LD_VAR 0 2
3691: ARRAY
3692: PUSH
3693: LD_EXP 78
3697: PUSH
3698: LD_VAR 0 2
3702: ARRAY
3703: PPUSH
3704: LD_INT 2
3706: PUSH
3707: LD_INT 34
3709: PUSH
3710: LD_INT 51
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 34
3719: PUSH
3720: LD_INT 52
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: PPUSH
3732: CALL_OW 72
3736: DIFF
3737: ST_TO_ADDR
// if not attackers then
3738: LD_VAR 0 6
3742: NOT
3743: IFFALSE 3747
// exit ;
3745: GO 3953
// ru_attackers := attackers ;
3747: LD_ADDR_EXP 52
3751: PUSH
3752: LD_VAR 0 6
3756: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3757: LD_ADDR_EXP 78
3761: PUSH
3762: LD_EXP 78
3766: PPUSH
3767: LD_VAR 0 2
3771: PPUSH
3772: LD_EXP 78
3776: PUSH
3777: LD_VAR 0 2
3781: ARRAY
3782: PUSH
3783: LD_VAR 0 6
3787: DIFF
3788: PPUSH
3789: CALL_OW 1
3793: ST_TO_ADDR
// for i = 1 to attackers do
3794: LD_ADDR_VAR 0 1
3798: PUSH
3799: DOUBLE
3800: LD_INT 1
3802: DEC
3803: ST_TO_ADDR
3804: LD_VAR 0 6
3808: PUSH
3809: FOR_TO
3810: IFFALSE 3887
// begin case i mod 3 of 0 :
3812: LD_VAR 0 1
3816: PUSH
3817: LD_INT 3
3819: MOD
3820: PUSH
3821: LD_INT 0
3823: DOUBLE
3824: EQUAL
3825: IFTRUE 3829
3827: GO 3832
3829: POP
// ; 1 :
3830: GO 3885
3832: LD_INT 1
3834: DOUBLE
3835: EQUAL
3836: IFTRUE 3840
3838: GO 3858
3840: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3841: LD_VAR 0 1
3845: PPUSH
3846: LD_INT 32
3848: PPUSH
3849: LD_INT 49
3851: PPUSH
3852: CALL_OW 114
3856: GO 3885
3858: LD_INT 2
3860: DOUBLE
3861: EQUAL
3862: IFTRUE 3866
3864: GO 3884
3866: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3867: LD_VAR 0 1
3871: PPUSH
3872: LD_INT 117
3874: PPUSH
3875: LD_INT 107
3877: PPUSH
3878: CALL_OW 114
3882: GO 3885
3884: POP
// end ;
3885: GO 3809
3887: POP
3888: POP
// repeat wait ( 0 0$1 ) ;
3889: LD_INT 35
3891: PPUSH
3892: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3896: LD_VAR 0 6
3900: PPUSH
3901: LD_INT 60
3903: PUSH
3904: EMPTY
3905: LIST
3906: PPUSH
3907: CALL_OW 72
3911: NOT
3912: IFFALSE 3889
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3914: LD_VAR 0 2
3918: PPUSH
3919: LD_VAR 0 6
3923: PPUSH
3924: LD_VAR 0 5
3928: PPUSH
3929: LD_VAR 0 4
3933: PPUSH
3934: CALL 78617 0 4
// if not first_attack then
3938: LD_EXP 7
3942: NOT
3943: IFFALSE 3953
// first_attack := true ;
3945: LD_ADDR_EXP 7
3949: PUSH
3950: LD_INT 1
3952: ST_TO_ADDR
// end ; end_of_file
3953: PPOPN 7
3955: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3956: LD_INT 0
3958: PPUSH
3959: PPUSH
3960: PPUSH
3961: PPUSH
3962: PPUSH
3963: PPUSH
3964: PPUSH
// uc_side := 2 ;
3965: LD_ADDR_OWVAR 20
3969: PUSH
3970: LD_INT 2
3972: ST_TO_ADDR
// uc_nation := 2 ;
3973: LD_ADDR_OWVAR 21
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3981: LD_ADDR_EXP 55
3985: PUSH
3986: LD_STRING Abdul
3988: PPUSH
3989: CALL_OW 25
3993: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3994: LD_EXP 55
3998: PPUSH
3999: LD_INT 11
4001: PPUSH
4002: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4006: LD_EXP 55
4010: PPUSH
4011: LD_INT 1
4013: PPUSH
4014: CALL_OW 52
// vc_chassis := 31 ;
4018: LD_ADDR_OWVAR 37
4022: PUSH
4023: LD_INT 31
4025: ST_TO_ADDR
// vc_control := control_rider ;
4026: LD_ADDR_OWVAR 38
4030: PUSH
4031: LD_INT 4
4033: ST_TO_ADDR
// mastodont := CreateVehicle ;
4034: LD_ADDR_EXP 56
4038: PUSH
4039: CALL_OW 45
4043: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4044: LD_EXP 56
4048: PPUSH
4049: LD_INT 153
4051: PPUSH
4052: LD_INT 71
4054: PPUSH
4055: LD_INT 0
4057: PPUSH
4058: CALL_OW 48
// InitVc ;
4062: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4066: LD_ADDR_EXP 53
4070: PUSH
4071: LD_INT 1
4073: PPUSH
4074: LD_INT 3
4076: PPUSH
4077: LD_STRING 
4079: PPUSH
4080: LD_INT 7
4082: PUSH
4083: LD_INT 8
4085: PUSH
4086: LD_INT 9
4088: PUSH
4089: LD_INT 10
4091: PUSH
4092: EMPTY
4093: LIST
4094: LIST
4095: LIST
4096: LIST
4097: PUSH
4098: LD_OWVAR 67
4102: ARRAY
4103: PPUSH
4104: LD_INT 5000
4106: PUSH
4107: LD_INT 1000
4109: PUSH
4110: LD_INT 300
4112: PUSH
4113: EMPTY
4114: LIST
4115: LIST
4116: LIST
4117: PPUSH
4118: LD_INT 18
4120: PUSH
4121: LD_INT 5
4123: PUSH
4124: LD_INT 6
4126: PUSH
4127: LD_INT 9
4129: PUSH
4130: EMPTY
4131: LIST
4132: LIST
4133: LIST
4134: LIST
4135: PPUSH
4136: CALL 23114 0 6
4140: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4141: LD_ADDR_EXP 59
4145: PUSH
4146: LD_EXP 59
4150: PPUSH
4151: LD_INT 1
4153: PPUSH
4154: LD_EXP 53
4158: PPUSH
4159: CALL_OW 1
4163: ST_TO_ADDR
// tmp := [ ] ;
4164: LD_ADDR_VAR 0 4
4168: PUSH
4169: EMPTY
4170: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4171: LD_ADDR_OWVAR 37
4175: PUSH
4176: LD_INT 14
4178: ST_TO_ADDR
// vc_engine := engine_siberite ;
4179: LD_ADDR_OWVAR 39
4183: PUSH
4184: LD_INT 3
4186: ST_TO_ADDR
// vc_control := control_manual ;
4187: LD_ADDR_OWVAR 38
4191: PUSH
4192: LD_INT 1
4194: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4195: LD_ADDR_OWVAR 40
4199: PUSH
4200: LD_INT 31
4202: ST_TO_ADDR
// for i = 1 to 3 do
4203: LD_ADDR_VAR 0 2
4207: PUSH
4208: DOUBLE
4209: LD_INT 1
4211: DEC
4212: ST_TO_ADDR
4213: LD_INT 3
4215: PUSH
4216: FOR_TO
4217: IFFALSE 4465
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4219: LD_ADDR_VAR 0 5
4223: PUSH
4224: LD_INT 153
4226: PUSH
4227: LD_INT 71
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: PUSH
4234: LD_INT 155
4236: PUSH
4237: LD_INT 81
4239: PUSH
4240: EMPTY
4241: LIST
4242: LIST
4243: PUSH
4244: EMPTY
4245: LIST
4246: LIST
4247: PUSH
4248: LD_VAR 0 2
4252: PUSH
4253: LD_INT 2
4255: MOD
4256: PUSH
4257: LD_INT 1
4259: PLUS
4260: ARRAY
4261: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4262: LD_INT 0
4264: PPUSH
4265: LD_INT 3
4267: PPUSH
4268: LD_INT 7
4270: PUSH
4271: LD_INT 8
4273: PUSH
4274: LD_INT 10
4276: PUSH
4277: LD_INT 10
4279: PUSH
4280: EMPTY
4281: LIST
4282: LIST
4283: LIST
4284: LIST
4285: PUSH
4286: LD_OWVAR 67
4290: ARRAY
4291: PPUSH
4292: CALL_OW 380
// un := CreateVehicle ;
4296: LD_ADDR_VAR 0 6
4300: PUSH
4301: CALL_OW 45
4305: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4306: LD_VAR 0 6
4310: PPUSH
4311: LD_INT 0
4313: PPUSH
4314: LD_INT 5
4316: PPUSH
4317: CALL_OW 12
4321: PPUSH
4322: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4326: LD_VAR 0 6
4330: PPUSH
4331: LD_VAR 0 5
4335: PUSH
4336: LD_INT 1
4338: ARRAY
4339: PPUSH
4340: LD_VAR 0 5
4344: PUSH
4345: LD_INT 2
4347: ARRAY
4348: PPUSH
4349: LD_INT 6
4351: PPUSH
4352: LD_INT 0
4354: PPUSH
4355: CALL_OW 50
// un2 := CreateHuman ;
4359: LD_ADDR_VAR 0 7
4363: PUSH
4364: CALL_OW 44
4368: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4369: LD_VAR 0 7
4373: PPUSH
4374: LD_VAR 0 6
4378: PPUSH
4379: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4383: LD_ADDR_EXP 59
4387: PUSH
4388: LD_EXP 59
4392: PPUSH
4393: LD_INT 1
4395: PUSH
4396: LD_EXP 59
4400: PUSH
4401: LD_INT 1
4403: ARRAY
4404: PUSH
4405: LD_INT 1
4407: PLUS
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: PPUSH
4413: LD_VAR 0 6
4417: PPUSH
4418: CALL 19790 0 3
4422: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4423: LD_ADDR_EXP 59
4427: PUSH
4428: LD_EXP 59
4432: PPUSH
4433: LD_INT 1
4435: PUSH
4436: LD_EXP 59
4440: PUSH
4441: LD_INT 1
4443: ARRAY
4444: PUSH
4445: LD_INT 1
4447: PLUS
4448: PUSH
4449: EMPTY
4450: LIST
4451: LIST
4452: PPUSH
4453: LD_VAR 0 7
4457: PPUSH
4458: CALL 19790 0 3
4462: ST_TO_ADDR
// end ;
4463: GO 4216
4465: POP
4466: POP
// for i = 1 to 5 do
4467: LD_ADDR_VAR 0 2
4471: PUSH
4472: DOUBLE
4473: LD_INT 1
4475: DEC
4476: ST_TO_ADDR
4477: LD_INT 5
4479: PUSH
4480: FOR_TO
4481: IFFALSE 4574
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4483: LD_INT 14
4485: PPUSH
4486: LD_INT 3
4488: PPUSH
4489: LD_INT 1
4491: PPUSH
4492: LD_INT 25
4494: PUSH
4495: LD_INT 28
4497: PUSH
4498: LD_INT 28
4500: PUSH
4501: LD_INT 26
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: LIST
4508: LIST
4509: PUSH
4510: LD_VAR 0 2
4514: PUSH
4515: LD_INT 4
4517: MOD
4518: PUSH
4519: LD_INT 1
4521: PLUS
4522: ARRAY
4523: PPUSH
4524: LD_INT 100
4526: PPUSH
4527: CALL 19668 0 5
// veh := CreateVehicle ;
4531: LD_ADDR_VAR 0 3
4535: PUSH
4536: CALL_OW 45
4540: ST_TO_ADDR
// tmp := tmp ^ veh ;
4541: LD_ADDR_VAR 0 4
4545: PUSH
4546: LD_VAR 0 4
4550: PUSH
4551: LD_VAR 0 3
4555: ADD
4556: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4557: LD_VAR 0 3
4561: PPUSH
4562: LD_INT 1
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: CALL_OW 49
// end ;
4572: GO 4480
4574: POP
4575: POP
// arabian_guard := tmp ;
4576: LD_ADDR_EXP 54
4580: PUSH
4581: LD_VAR 0 4
4585: ST_TO_ADDR
// end ;
4586: LD_VAR 0 1
4590: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4591: LD_INT 22
4593: PUSH
4594: LD_INT 7
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 91
4603: PUSH
4604: LD_INT 1
4606: PUSH
4607: LD_INT 12
4609: PUSH
4610: EMPTY
4611: LIST
4612: LIST
4613: LIST
4614: PUSH
4615: EMPTY
4616: LIST
4617: LIST
4618: PPUSH
4619: CALL_OW 69
4623: PUSH
4624: LD_EXP 56
4628: PPUSH
4629: CALL_OW 256
4633: PUSH
4634: LD_INT 990
4636: LESS
4637: OR
4638: PUSH
4639: LD_EXP 55
4643: PPUSH
4644: CALL_OW 256
4648: PUSH
4649: LD_INT 990
4651: LESS
4652: OR
4653: IFFALSE 4796
4655: GO 4657
4657: DISABLE
// begin if IsInUnit ( Abdul ) then
4658: LD_EXP 55
4662: PPUSH
4663: CALL_OW 310
4667: IFFALSE 4678
// ComExitBuilding ( Abdul ) ;
4669: LD_EXP 55
4673: PPUSH
4674: CALL_OW 122
// if Mastodont then
4678: LD_EXP 56
4682: IFFALSE 4699
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4684: LD_EXP 56
4688: PPUSH
4689: LD_INT 205
4691: PPUSH
4692: LD_INT 132
4694: PPUSH
4695: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4699: LD_EXP 55
4703: PPUSH
4704: LD_INT 205
4706: PPUSH
4707: LD_INT 132
4709: PPUSH
4710: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4714: LD_INT 35
4716: PPUSH
4717: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4721: LD_EXP 55
4725: PPUSH
4726: LD_INT 21
4728: PPUSH
4729: CALL_OW 308
4733: IFFALSE 4714
// RemoveUnit ( Abdul ) ;
4735: LD_EXP 55
4739: PPUSH
4740: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4751: LD_EXP 56
4755: PPUSH
4756: LD_INT 21
4758: PPUSH
4759: CALL_OW 308
4763: PUSH
4764: LD_EXP 56
4768: PPUSH
4769: CALL_OW 301
4773: OR
4774: IFFALSE 4744
// if IsOk ( Mastodont ) then
4776: LD_EXP 56
4780: PPUSH
4781: CALL_OW 302
4785: IFFALSE 4796
// RemoveUnit ( Mastodont ) ;
4787: LD_EXP 56
4791: PPUSH
4792: CALL_OW 64
// end ;
4796: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4797: LD_EXP 55
4801: PPUSH
4802: CALL_OW 301
4806: PUSH
4807: LD_INT 22
4809: PUSH
4810: LD_INT 2
4812: PUSH
4813: EMPTY
4814: LIST
4815: LIST
4816: PUSH
4817: LD_INT 2
4819: PUSH
4820: LD_INT 25
4822: PUSH
4823: LD_INT 1
4825: PUSH
4826: EMPTY
4827: LIST
4828: LIST
4829: PUSH
4830: LD_INT 25
4832: PUSH
4833: LD_INT 2
4835: PUSH
4836: EMPTY
4837: LIST
4838: LIST
4839: PUSH
4840: LD_INT 25
4842: PUSH
4843: LD_INT 3
4845: PUSH
4846: EMPTY
4847: LIST
4848: LIST
4849: PUSH
4850: LD_INT 25
4852: PUSH
4853: LD_INT 4
4855: PUSH
4856: EMPTY
4857: LIST
4858: LIST
4859: PUSH
4860: LD_INT 25
4862: PUSH
4863: LD_INT 8
4865: PUSH
4866: EMPTY
4867: LIST
4868: LIST
4869: PUSH
4870: EMPTY
4871: LIST
4872: LIST
4873: LIST
4874: LIST
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: PPUSH
4882: CALL_OW 69
4886: PUSH
4887: LD_INT 16
4889: PUSH
4890: LD_INT 19
4892: PUSH
4893: LD_INT 22
4895: PUSH
4896: LD_INT 22
4898: PUSH
4899: EMPTY
4900: LIST
4901: LIST
4902: LIST
4903: LIST
4904: PUSH
4905: LD_OWVAR 67
4909: ARRAY
4910: LESS
4911: OR
4912: IFFALSE 5585
4914: GO 4916
4916: DISABLE
4917: LD_INT 0
4919: PPUSH
4920: PPUSH
4921: PPUSH
4922: PPUSH
4923: PPUSH
4924: PPUSH
// begin MC_Kill ( 1 ) ;
4925: LD_INT 1
4927: PPUSH
4928: CALL 54601 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4932: LD_ADDR_VAR 0 2
4936: PUSH
4937: LD_INT 22
4939: PUSH
4940: LD_INT 2
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 2
4949: PUSH
4950: LD_INT 25
4952: PUSH
4953: LD_INT 1
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PUSH
4960: LD_INT 25
4962: PUSH
4963: LD_INT 2
4965: PUSH
4966: EMPTY
4967: LIST
4968: LIST
4969: PUSH
4970: LD_INT 25
4972: PUSH
4973: LD_INT 3
4975: PUSH
4976: EMPTY
4977: LIST
4978: LIST
4979: PUSH
4980: LD_INT 25
4982: PUSH
4983: LD_INT 4
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 25
4992: PUSH
4993: LD_INT 8
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: PPUSH
5012: CALL_OW 69
5016: ST_TO_ADDR
// for i in tmp do
5017: LD_ADDR_VAR 0 5
5021: PUSH
5022: LD_VAR 0 2
5026: PUSH
5027: FOR_IN
5028: IFFALSE 5044
// SetTag ( i , 10 ) ;
5030: LD_VAR 0 5
5034: PPUSH
5035: LD_INT 10
5037: PPUSH
5038: CALL_OW 109
5042: GO 5027
5044: POP
5045: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5046: LD_ADDR_VAR 0 3
5050: PUSH
5051: LD_INT 22
5053: PUSH
5054: LD_INT 2
5056: PUSH
5057: EMPTY
5058: LIST
5059: LIST
5060: PUSH
5061: LD_INT 21
5063: PUSH
5064: LD_INT 1
5066: PUSH
5067: EMPTY
5068: LIST
5069: LIST
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PPUSH
5075: CALL_OW 69
5079: PUSH
5080: LD_VAR 0 2
5084: DIFF
5085: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5086: LD_ADDR_VAR 0 1
5090: PUSH
5091: LD_INT 22
5093: PUSH
5094: LD_INT 2
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 21
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: LD_INT 24
5113: PUSH
5114: LD_INT 300
5116: PUSH
5117: EMPTY
5118: LIST
5119: LIST
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: LIST
5125: PPUSH
5126: CALL_OW 69
5130: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5131: LD_ADDR_VAR 0 4
5135: PUSH
5136: LD_VAR 0 1
5140: PPUSH
5141: LD_INT 33
5143: PUSH
5144: LD_INT 1
5146: PUSH
5147: EMPTY
5148: LIST
5149: LIST
5150: PUSH
5151: LD_INT 58
5153: PUSH
5154: EMPTY
5155: LIST
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: PPUSH
5161: CALL_OW 72
5165: ST_TO_ADDR
// for i in tmp do
5166: LD_ADDR_VAR 0 5
5170: PUSH
5171: LD_VAR 0 2
5175: PUSH
5176: FOR_IN
5177: IFFALSE 5361
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5179: LD_VAR 0 5
5183: PUSH
5184: LD_INT 55
5186: PUSH
5187: EMPTY
5188: LIST
5189: PPUSH
5190: CALL_OW 69
5194: IN
5195: IFFALSE 5214
// begin AddComMoveXY ( i , 209 , 132 ) ;
5197: LD_VAR 0 5
5201: PPUSH
5202: LD_INT 209
5204: PPUSH
5205: LD_INT 132
5207: PPUSH
5208: CALL_OW 171
// continue ;
5212: GO 5176
// end ; if IsInUnit ( i ) then
5214: LD_VAR 0 5
5218: PPUSH
5219: CALL_OW 310
5223: IFFALSE 5241
// begin ComExitBuilding ( i ) ;
5225: LD_VAR 0 5
5229: PPUSH
5230: CALL_OW 122
// wait ( 3 ) ;
5234: LD_INT 3
5236: PPUSH
5237: CALL_OW 67
// end ; if tmp_empty then
5241: LD_VAR 0 4
5245: IFFALSE 5344
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5247: LD_VAR 0 5
5251: PPUSH
5252: LD_VAR 0 4
5256: PPUSH
5257: LD_VAR 0 5
5261: PPUSH
5262: CALL_OW 74
5266: PPUSH
5267: CALL_OW 296
5271: PUSH
5272: LD_INT 25
5274: LESS
5275: IFFALSE 5344
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5277: LD_ADDR_VAR 0 6
5281: PUSH
5282: LD_VAR 0 4
5286: PPUSH
5287: LD_VAR 0 5
5291: PPUSH
5292: CALL_OW 74
5296: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5297: LD_VAR 0 5
5301: PPUSH
5302: LD_VAR 0 6
5306: PPUSH
5307: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5311: LD_VAR 0 5
5315: PPUSH
5316: LD_INT 209
5318: PPUSH
5319: LD_INT 132
5321: PPUSH
5322: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5326: LD_ADDR_VAR 0 4
5330: PUSH
5331: LD_VAR 0 4
5335: PUSH
5336: LD_VAR 0 6
5340: DIFF
5341: ST_TO_ADDR
// continue ;
5342: GO 5176
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5344: LD_VAR 0 5
5348: PPUSH
5349: LD_INT 201
5351: PPUSH
5352: LD_INT 132
5354: PPUSH
5355: CALL_OW 171
// end ;
5359: GO 5176
5361: POP
5362: POP
// for i in tmp_ape do
5363: LD_ADDR_VAR 0 5
5367: PUSH
5368: LD_VAR 0 3
5372: PUSH
5373: FOR_IN
5374: IFFALSE 5413
// begin if IsInUnit ( i ) then
5376: LD_VAR 0 5
5380: PPUSH
5381: CALL_OW 310
5385: IFFALSE 5396
// ComExitBuilding ( i ) ;
5387: LD_VAR 0 5
5391: PPUSH
5392: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5396: LD_VAR 0 5
5400: PPUSH
5401: LD_INT 201
5403: PPUSH
5404: LD_INT 132
5406: PPUSH
5407: CALL_OW 171
// end ;
5411: GO 5373
5413: POP
5414: POP
// repeat wait ( 0 0$1 ) ;
5415: LD_INT 35
5417: PPUSH
5418: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5422: LD_ADDR_VAR 0 5
5426: PUSH
5427: LD_VAR 0 2
5431: PUSH
5432: LD_VAR 0 3
5436: UNION
5437: PUSH
5438: LD_VAR 0 1
5442: UNION
5443: PUSH
5444: FOR_IN
5445: IFFALSE 5476
// if not HasTask ( i ) then
5447: LD_VAR 0 5
5451: PPUSH
5452: CALL_OW 314
5456: NOT
5457: IFFALSE 5474
// ComMoveXY ( i , 201 , 132 ) ;
5459: LD_VAR 0 5
5463: PPUSH
5464: LD_INT 201
5466: PPUSH
5467: LD_INT 132
5469: PPUSH
5470: CALL_OW 111
5474: GO 5444
5476: POP
5477: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5478: LD_INT 21
5480: PPUSH
5481: LD_INT 22
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PPUSH
5491: CALL_OW 70
5495: IFFALSE 5536
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5497: LD_ADDR_VAR 0 5
5501: PUSH
5502: LD_INT 21
5504: PPUSH
5505: LD_INT 22
5507: PUSH
5508: LD_INT 2
5510: PUSH
5511: EMPTY
5512: LIST
5513: LIST
5514: PPUSH
5515: CALL_OW 70
5519: PUSH
5520: FOR_IN
5521: IFFALSE 5534
// RemoveUnit ( i ) ;
5523: LD_VAR 0 5
5527: PPUSH
5528: CALL_OW 64
5532: GO 5520
5534: POP
5535: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5536: LD_INT 22
5538: PUSH
5539: LD_INT 2
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 2
5548: PUSH
5549: LD_INT 21
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: EMPTY
5556: LIST
5557: LIST
5558: PUSH
5559: LD_INT 21
5561: PUSH
5562: LD_INT 2
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: PUSH
5569: EMPTY
5570: LIST
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: PPUSH
5578: CALL_OW 69
5582: NOT
5583: IFFALSE 5415
// end ;
5585: PPOPN 6
5587: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5588: LD_EXP 9
5592: PUSH
5593: LD_INT 92
5595: PPUSH
5596: LD_INT 40
5598: PPUSH
5599: CALL_OW 428
5603: PPUSH
5604: CALL_OW 266
5608: PUSH
5609: LD_INT 30
5611: EQUAL
5612: AND
5613: IFFALSE 5809
5615: GO 5617
5617: DISABLE
5618: LD_INT 0
5620: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5621: LD_ADDR_VAR 0 1
5625: PUSH
5626: LD_EXP 59
5630: PUSH
5631: LD_INT 1
5633: ARRAY
5634: PPUSH
5635: LD_INT 25
5637: PUSH
5638: LD_INT 4
5640: PUSH
5641: EMPTY
5642: LIST
5643: LIST
5644: PPUSH
5645: CALL_OW 72
5649: ST_TO_ADDR
// if not sci then
5650: LD_VAR 0 1
5654: NOT
5655: IFFALSE 5659
// exit ;
5657: GO 5809
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5659: LD_ADDR_EXP 59
5663: PUSH
5664: LD_EXP 59
5668: PPUSH
5669: LD_INT 1
5671: PPUSH
5672: LD_EXP 59
5676: PUSH
5677: LD_INT 1
5679: ARRAY
5680: PUSH
5681: LD_VAR 0 1
5685: PUSH
5686: LD_INT 1
5688: ARRAY
5689: DIFF
5690: PPUSH
5691: CALL_OW 1
5695: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5696: LD_VAR 0 1
5700: PUSH
5701: LD_INT 1
5703: ARRAY
5704: PPUSH
5705: CALL_OW 310
5709: IFFALSE 5724
// ComExitBuilding ( sci [ 1 ] ) ;
5711: LD_VAR 0 1
5715: PUSH
5716: LD_INT 1
5718: ARRAY
5719: PPUSH
5720: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5724: LD_INT 2
5726: PPUSH
5727: LD_INT 105
5729: PPUSH
5730: LD_INT 14
5732: PPUSH
5733: LD_INT 20
5735: PPUSH
5736: CALL 20686 0 4
5740: PUSH
5741: LD_INT 4
5743: ARRAY
5744: PUSH
5745: LD_INT 10
5747: LESS
5748: IFFALSE 5771
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5750: LD_VAR 0 1
5754: PUSH
5755: LD_INT 1
5757: ARRAY
5758: PPUSH
5759: LD_INT 105
5761: PPUSH
5762: LD_INT 14
5764: PPUSH
5765: CALL_OW 171
5769: GO 5790
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5771: LD_VAR 0 1
5775: PUSH
5776: LD_INT 1
5778: ARRAY
5779: PPUSH
5780: LD_INT 118
5782: PPUSH
5783: LD_INT 77
5785: PPUSH
5786: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5790: LD_VAR 0 1
5794: PUSH
5795: LD_INT 1
5797: ARRAY
5798: PPUSH
5799: LD_INT 92
5801: PPUSH
5802: LD_INT 40
5804: PPUSH
5805: CALL_OW 218
// end ;
5809: PPOPN 1
5811: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5812: LD_INT 1
5814: PPUSH
5815: CALL_OW 302
5819: PUSH
5820: LD_EXP 9
5824: AND
5825: IFFALSE 6304
5827: GO 5829
5829: DISABLE
5830: LD_INT 0
5832: PPUSH
5833: PPUSH
5834: PPUSH
5835: PPUSH
5836: PPUSH
5837: PPUSH
// begin enable ;
5838: ENABLE
// base := 1 ;
5839: LD_ADDR_VAR 0 2
5843: PUSH
5844: LD_INT 1
5846: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5847: LD_ADDR_VAR 0 4
5851: PUSH
5852: LD_INT 0
5854: PUSH
5855: LD_INT 0
5857: PUSH
5858: LD_INT 0
5860: PUSH
5861: LD_INT 0
5863: PUSH
5864: LD_INT 0
5866: PUSH
5867: LD_INT 0
5869: PUSH
5870: LD_INT 0
5872: PUSH
5873: LD_INT 0
5875: PUSH
5876: LD_INT 1
5878: PUSH
5879: LD_INT 0
5881: PUSH
5882: EMPTY
5883: LIST
5884: LIST
5885: LIST
5886: LIST
5887: LIST
5888: LIST
5889: LIST
5890: LIST
5891: LIST
5892: LIST
5893: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5894: LD_ADDR_VAR 0 3
5898: PUSH
5899: LD_INT 14
5901: PUSH
5902: LD_INT 1
5904: PUSH
5905: LD_INT 2
5907: PUSH
5908: LD_INT 26
5910: PUSH
5911: EMPTY
5912: LIST
5913: LIST
5914: LIST
5915: LIST
5916: PUSH
5917: LD_INT 14
5919: PUSH
5920: LD_INT 1
5922: PUSH
5923: LD_INT 2
5925: PUSH
5926: LD_INT 28
5928: PUSH
5929: EMPTY
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: PUSH
5935: LD_INT 13
5937: PUSH
5938: LD_INT 1
5940: PUSH
5941: LD_INT 2
5943: PUSH
5944: LD_INT 29
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: LIST
5957: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5958: LD_ADDR_VAR 0 1
5962: PUSH
5963: DOUBLE
5964: LD_INT 1
5966: DEC
5967: ST_TO_ADDR
5968: LD_OWVAR 67
5972: PUSH
5973: LD_OWVAR 1
5977: PUSH
5978: LD_INT 21000
5980: DIV
5981: PLUS
5982: PUSH
5983: FOR_TO
5984: IFFALSE 6076
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5986: LD_ADDR_VAR 0 3
5990: PUSH
5991: LD_VAR 0 3
5995: PPUSH
5996: LD_VAR 0 3
6000: PUSH
6001: LD_INT 1
6003: PLUS
6004: PPUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 14
6010: PUSH
6011: EMPTY
6012: LIST
6013: LIST
6014: PUSH
6015: LD_INT 1
6017: PPUSH
6018: LD_INT 2
6020: PPUSH
6021: CALL_OW 12
6025: ARRAY
6026: PUSH
6027: LD_INT 1
6029: PUSH
6030: LD_INT 2
6032: PUSH
6033: LD_INT 28
6035: PUSH
6036: LD_INT 29
6038: PUSH
6039: LD_INT 25
6041: PUSH
6042: LD_INT 26
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: PUSH
6051: LD_INT 1
6053: PPUSH
6054: LD_INT 4
6056: PPUSH
6057: CALL_OW 12
6061: ARRAY
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: PPUSH
6069: CALL_OW 2
6073: ST_TO_ADDR
6074: GO 5983
6076: POP
6077: POP
// MC_InsertProduceList ( base , tmp ) ;
6078: LD_VAR 0 2
6082: PPUSH
6083: LD_VAR 0 3
6087: PPUSH
6088: CALL 78432 0 2
// repeat wait ( 0 0$1 ) ;
6092: LD_INT 35
6094: PPUSH
6095: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6099: LD_EXP 78
6103: PUSH
6104: LD_VAR 0 2
6108: ARRAY
6109: PUSH
6110: LD_INT 6
6112: GREATER
6113: IFFALSE 6092
// wait ( 0 0$20 ) ;
6115: LD_INT 700
6117: PPUSH
6118: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6122: LD_ADDR_VAR 0 5
6126: PUSH
6127: LD_INT 124
6129: PUSH
6130: LD_INT 85
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 90
6139: PUSH
6140: LD_INT 61
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: PUSH
6147: LD_INT 69
6149: PUSH
6150: LD_INT 48
6152: PUSH
6153: EMPTY
6154: LIST
6155: LIST
6156: PUSH
6157: LD_INT 68
6159: PUSH
6160: LD_INT 48
6162: PUSH
6163: EMPTY
6164: LIST
6165: LIST
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6173: LD_ADDR_VAR 0 6
6177: PUSH
6178: LD_EXP 78
6182: PUSH
6183: LD_VAR 0 2
6187: ARRAY
6188: PUSH
6189: LD_EXP 78
6193: PUSH
6194: LD_VAR 0 2
6198: ARRAY
6199: PPUSH
6200: LD_INT 2
6202: PUSH
6203: LD_INT 34
6205: PUSH
6206: LD_INT 32
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PUSH
6213: LD_INT 34
6215: PUSH
6216: LD_EXP 109
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: PUSH
6225: EMPTY
6226: LIST
6227: LIST
6228: LIST
6229: PPUSH
6230: CALL_OW 72
6234: DIFF
6235: ST_TO_ADDR
// if not attackers then
6236: LD_VAR 0 6
6240: NOT
6241: IFFALSE 6245
// exit ;
6243: GO 6304
// ar_attackers := attackers ;
6245: LD_ADDR_EXP 10
6249: PUSH
6250: LD_VAR 0 6
6254: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6255: LD_INT 35
6257: PPUSH
6258: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6262: LD_VAR 0 6
6266: PPUSH
6267: LD_INT 60
6269: PUSH
6270: EMPTY
6271: LIST
6272: PPUSH
6273: CALL_OW 72
6277: NOT
6278: IFFALSE 6255
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6280: LD_VAR 0 2
6284: PPUSH
6285: LD_VAR 0 6
6289: PPUSH
6290: LD_VAR 0 5
6294: PPUSH
6295: LD_VAR 0 4
6299: PPUSH
6300: CALL 78617 0 4
// end ;
6304: PPOPN 6
6306: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6307: LD_INT 1
6309: PPUSH
6310: CALL_OW 302
6314: PUSH
6315: LD_EXP 9
6319: AND
6320: PUSH
6321: LD_EXP 49
6325: PPUSH
6326: LD_INT 22
6328: PPUSH
6329: CALL_OW 308
6333: AND
6334: PUSH
6335: LD_INT 1
6337: PPUSH
6338: CALL 78780 0 1
6342: PUSH
6343: LD_INT 0
6345: EQUAL
6346: AND
6347: PUSH
6348: LD_EXP 10
6352: NOT
6353: AND
6354: IFFALSE 6842
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// begin base := 1 ;
6368: LD_ADDR_VAR 0 2
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6376: LD_ADDR_VAR 0 4
6380: PUSH
6381: LD_INT 0
6383: PUSH
6384: LD_INT 0
6386: PUSH
6387: LD_INT 0
6389: PUSH
6390: LD_INT 0
6392: PUSH
6393: LD_INT 0
6395: PUSH
6396: LD_INT 0
6398: PUSH
6399: LD_INT 0
6401: PUSH
6402: LD_INT 0
6404: PUSH
6405: LD_INT 1
6407: PUSH
6408: LD_INT 0
6410: PUSH
6411: EMPTY
6412: LIST
6413: LIST
6414: LIST
6415: LIST
6416: LIST
6417: LIST
6418: LIST
6419: LIST
6420: LIST
6421: LIST
6422: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6423: LD_ADDR_VAR 0 3
6427: PUSH
6428: LD_INT 13
6430: PUSH
6431: LD_INT 1
6433: PUSH
6434: LD_INT 2
6436: PUSH
6437: LD_INT 28
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 13
6448: PUSH
6449: LD_INT 1
6451: PUSH
6452: LD_INT 2
6454: PUSH
6455: LD_INT 27
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: PUSH
6464: LD_INT 13
6466: PUSH
6467: LD_INT 1
6469: PUSH
6470: LD_INT 2
6472: PUSH
6473: LD_INT 25
6475: PUSH
6476: EMPTY
6477: LIST
6478: LIST
6479: LIST
6480: LIST
6481: PUSH
6482: LD_INT 11
6484: PUSH
6485: LD_INT 2
6487: PUSH
6488: LD_INT 2
6490: PUSH
6491: LD_INT 24
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: LIST
6498: LIST
6499: PUSH
6500: LD_INT 11
6502: PUSH
6503: LD_INT 2
6505: PUSH
6506: LD_INT 2
6508: PUSH
6509: LD_INT 24
6511: PUSH
6512: EMPTY
6513: LIST
6514: LIST
6515: LIST
6516: LIST
6517: PUSH
6518: EMPTY
6519: LIST
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_VAR 0 3
6534: PPUSH
6535: CALL 78432 0 2
// repeat wait ( 0 0$1 ) ;
6539: LD_INT 35
6541: PPUSH
6542: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6546: LD_EXP 78
6550: PUSH
6551: LD_VAR 0 2
6555: ARRAY
6556: PUSH
6557: LD_INT 6
6559: GREATEREQUAL
6560: IFFALSE 6539
// wait ( 0 0$20 ) ;
6562: LD_INT 700
6564: PPUSH
6565: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6569: LD_ADDR_VAR 0 5
6573: PUSH
6574: LD_INT 119
6576: PUSH
6577: LD_INT 9
6579: PUSH
6580: EMPTY
6581: LIST
6582: LIST
6583: PUSH
6584: EMPTY
6585: LIST
6586: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6587: LD_ADDR_VAR 0 6
6591: PUSH
6592: LD_EXP 78
6596: PUSH
6597: LD_VAR 0 2
6601: ARRAY
6602: PUSH
6603: LD_EXP 78
6607: PUSH
6608: LD_VAR 0 2
6612: ARRAY
6613: PPUSH
6614: LD_INT 2
6616: PUSH
6617: LD_INT 34
6619: PUSH
6620: LD_INT 32
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: LD_INT 34
6629: PUSH
6630: LD_EXP 109
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PUSH
6639: EMPTY
6640: LIST
6641: LIST
6642: LIST
6643: PPUSH
6644: CALL_OW 72
6648: DIFF
6649: ST_TO_ADDR
// if not attackers then
6650: LD_VAR 0 6
6654: NOT
6655: IFFALSE 6659
// exit ;
6657: GO 6842
// uc_side := 2 ;
6659: LD_ADDR_OWVAR 20
6663: PUSH
6664: LD_INT 2
6666: ST_TO_ADDR
// uc_nation := 2 ;
6667: LD_ADDR_OWVAR 21
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// InitHc ;
6675: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6679: LD_ADDR_VAR 0 1
6683: PUSH
6684: DOUBLE
6685: LD_INT 1
6687: DEC
6688: ST_TO_ADDR
6689: LD_INT 4
6691: PUSH
6692: LD_INT 5
6694: PUSH
6695: LD_INT 6
6697: PUSH
6698: LD_INT 6
6700: PUSH
6701: EMPTY
6702: LIST
6703: LIST
6704: LIST
6705: LIST
6706: PUSH
6707: LD_OWVAR 67
6711: ARRAY
6712: PUSH
6713: FOR_TO
6714: IFFALSE 6791
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6716: LD_INT 0
6718: PPUSH
6719: LD_INT 15
6721: PUSH
6722: LD_INT 17
6724: PUSH
6725: EMPTY
6726: LIST
6727: LIST
6728: PUSH
6729: LD_INT 1
6731: PPUSH
6732: LD_INT 2
6734: PPUSH
6735: CALL_OW 12
6739: ARRAY
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: CALL_OW 380
// un := CreateHuman ;
6748: LD_ADDR_VAR 0 7
6752: PUSH
6753: CALL_OW 44
6757: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6758: LD_VAR 0 7
6762: PPUSH
6763: LD_INT 23
6765: PPUSH
6766: LD_INT 0
6768: PPUSH
6769: CALL_OW 49
// attackers := attackers union un ;
6773: LD_ADDR_VAR 0 6
6777: PUSH
6778: LD_VAR 0 6
6782: PUSH
6783: LD_VAR 0 7
6787: UNION
6788: ST_TO_ADDR
// end ;
6789: GO 6713
6791: POP
6792: POP
// repeat wait ( 0 0$1 ) ;
6793: LD_INT 35
6795: PPUSH
6796: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6800: LD_VAR 0 6
6804: PPUSH
6805: LD_INT 60
6807: PUSH
6808: EMPTY
6809: LIST
6810: PPUSH
6811: CALL_OW 72
6815: NOT
6816: IFFALSE 6793
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6818: LD_VAR 0 2
6822: PPUSH
6823: LD_VAR 0 6
6827: PPUSH
6828: LD_VAR 0 5
6832: PPUSH
6833: LD_VAR 0 4
6837: PPUSH
6838: CALL 78617 0 4
// end ; end_of_file
6842: PPOPN 7
6844: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6845: LD_INT 0
6847: PPUSH
6848: PPUSH
6849: PPUSH
6850: PPUSH
6851: PPUSH
6852: PPUSH
// uc_side := 1 ;
6853: LD_ADDR_OWVAR 20
6857: PUSH
6858: LD_INT 1
6860: ST_TO_ADDR
// uc_nation := 1 ;
6861: LD_ADDR_OWVAR 21
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// InitHc ;
6869: CALL_OW 19
// InitVc ;
6873: CALL_OW 20
// tmp := [ ] ;
6877: LD_ADDR_VAR 0 3
6881: PUSH
6882: EMPTY
6883: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6884: LD_ADDR_VAR 0 2
6888: PUSH
6889: DOUBLE
6890: LD_INT 1
6892: DEC
6893: ST_TO_ADDR
6894: LD_INT 6
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: LD_INT 10
6902: PUSH
6903: LD_INT 10
6905: PUSH
6906: EMPTY
6907: LIST
6908: LIST
6909: LIST
6910: LIST
6911: PUSH
6912: LD_OWVAR 67
6916: ARRAY
6917: PUSH
6918: FOR_TO
6919: IFFALSE 7193
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6921: LD_ADDR_VAR 0 5
6925: PUSH
6926: LD_INT 2
6928: PUSH
6929: LD_INT 4
6931: PUSH
6932: LD_INT 5
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: LIST
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_INT 3
6945: PPUSH
6946: CALL_OW 12
6950: ARRAY
6951: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6952: LD_VAR 0 5
6956: PUSH
6957: LD_INT 2
6959: DOUBLE
6960: EQUAL
6961: IFTRUE 6965
6963: GO 6999
6965: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6966: LD_ADDR_VAR 0 6
6970: PUSH
6971: LD_INT 9
6973: PUSH
6974: LD_INT 5
6976: PUSH
6977: LD_INT 7
6979: PUSH
6980: EMPTY
6981: LIST
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 1
6987: PPUSH
6988: LD_INT 3
6990: PPUSH
6991: CALL_OW 12
6995: ARRAY
6996: ST_TO_ADDR
6997: GO 7088
6999: LD_INT 4
7001: DOUBLE
7002: EQUAL
7003: IFTRUE 7007
7005: GO 7045
7007: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7008: LD_ADDR_VAR 0 6
7012: PUSH
7013: LD_INT 9
7015: PUSH
7016: LD_INT 6
7018: PUSH
7019: LD_INT 6
7021: PUSH
7022: LD_INT 7
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: LIST
7029: LIST
7030: PUSH
7031: LD_INT 1
7033: PPUSH
7034: LD_INT 4
7036: PPUSH
7037: CALL_OW 12
7041: ARRAY
7042: ST_TO_ADDR
7043: GO 7088
7045: LD_INT 5
7047: DOUBLE
7048: EQUAL
7049: IFTRUE 7053
7051: GO 7087
7053: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7054: LD_ADDR_VAR 0 6
7058: PUSH
7059: LD_INT 9
7061: PUSH
7062: LD_INT 6
7064: PUSH
7065: LD_INT 7
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: LIST
7072: PUSH
7073: LD_INT 1
7075: PPUSH
7076: LD_INT 3
7078: PPUSH
7079: CALL_OW 12
7083: ARRAY
7084: ST_TO_ADDR
7085: GO 7088
7087: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7088: LD_VAR 0 5
7092: PPUSH
7093: LD_INT 1
7095: PUSH
7096: LD_INT 3
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: PUSH
7103: LD_INT 1
7105: PPUSH
7106: LD_INT 2
7108: PPUSH
7109: CALL_OW 12
7113: ARRAY
7114: PPUSH
7115: LD_INT 3
7117: PPUSH
7118: LD_VAR 0 6
7122: PPUSH
7123: LD_INT 70
7125: PPUSH
7126: LD_INT 90
7128: PPUSH
7129: CALL_OW 12
7133: PPUSH
7134: CALL 19668 0 5
// veh := CreateVehicle ;
7138: LD_ADDR_VAR 0 4
7142: PUSH
7143: CALL_OW 45
7147: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7148: LD_VAR 0 4
7152: PPUSH
7153: LD_INT 2
7155: PPUSH
7156: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7160: LD_VAR 0 4
7164: PPUSH
7165: LD_INT 17
7167: PPUSH
7168: LD_INT 0
7170: PPUSH
7171: CALL_OW 49
// tmp := tmp ^ veh ;
7175: LD_ADDR_VAR 0 3
7179: PUSH
7180: LD_VAR 0 3
7184: PUSH
7185: LD_VAR 0 4
7189: ADD
7190: ST_TO_ADDR
// end ;
7191: GO 6918
7193: POP
7194: POP
// if not tmp then
7195: LD_VAR 0 3
7199: NOT
7200: IFFALSE 7204
// exit ;
7202: GO 7313
// if not first_powell_attack then
7204: LD_EXP 11
7208: NOT
7209: IFFALSE 7219
// first_powell_attack := true ;
7211: LD_ADDR_EXP 11
7215: PUSH
7216: LD_INT 1
7218: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7219: LD_INT 70
7221: PPUSH
7222: CALL_OW 67
// for i in tmp do
7226: LD_ADDR_VAR 0 2
7230: PUSH
7231: LD_VAR 0 3
7235: PUSH
7236: FOR_IN
7237: IFFALSE 7304
// if IsOk ( i ) then
7239: LD_VAR 0 2
7243: PPUSH
7244: CALL_OW 302
7248: IFFALSE 7286
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 81
7257: PUSH
7258: LD_INT 1
7260: PUSH
7261: EMPTY
7262: LIST
7263: LIST
7264: PPUSH
7265: CALL_OW 69
7269: PPUSH
7270: LD_VAR 0 2
7274: PPUSH
7275: CALL_OW 74
7279: PPUSH
7280: CALL_OW 115
7284: GO 7302
// tmp := tmp diff i ;
7286: LD_ADDR_VAR 0 3
7290: PUSH
7291: LD_VAR 0 3
7295: PUSH
7296: LD_VAR 0 2
7300: DIFF
7301: ST_TO_ADDR
7302: GO 7236
7304: POP
7305: POP
// until not tmp ;
7306: LD_VAR 0 3
7310: NOT
7311: IFFALSE 7219
// end ; end_of_file
7313: LD_VAR 0 1
7317: RET
// export function Action ; var tmp , i , un ; begin
7318: LD_INT 0
7320: PPUSH
7321: PPUSH
7322: PPUSH
7323: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7324: LD_INT 68
7326: PPUSH
7327: LD_INT 39
7329: PPUSH
7330: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7334: LD_ADDR_VAR 0 2
7338: PUSH
7339: LD_INT 22
7341: PUSH
7342: LD_INT 7
7344: PUSH
7345: EMPTY
7346: LIST
7347: LIST
7348: PPUSH
7349: CALL_OW 69
7353: ST_TO_ADDR
// InGameOn ;
7354: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7358: LD_VAR 0 2
7362: PPUSH
7363: LD_INT 71
7365: PPUSH
7366: LD_INT 49
7368: PPUSH
7369: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7373: LD_INT 35
7375: PPUSH
7376: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7380: LD_INT 7
7382: PPUSH
7383: LD_INT 71
7385: PPUSH
7386: LD_INT 51
7388: PPUSH
7389: CALL_OW 293
7393: IFFALSE 7373
// DialogueOn ;
7395: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D1-JMM-1
7406: PPUSH
7407: CALL_OW 88
// if Joan then
7411: LD_EXP 30
7415: IFFALSE 7429
// Say ( Joan , D1-Joan-1 ) ;
7417: LD_EXP 30
7421: PPUSH
7422: LD_STRING D1-Joan-1
7424: PPUSH
7425: CALL_OW 88
// if Lisa then
7429: LD_EXP 17
7433: IFFALSE 7447
// Say ( Lisa , D1-Lisa-1 ) ;
7435: LD_EXP 17
7439: PPUSH
7440: LD_STRING D1-Lisa-1
7442: PPUSH
7443: CALL_OW 88
// if Joan or Lisa then
7447: LD_EXP 30
7451: PUSH
7452: LD_EXP 17
7456: OR
7457: IFFALSE 7471
// Say ( JMM , D1-JMM-2 ) ;
7459: LD_EXP 15
7463: PPUSH
7464: LD_STRING D1-JMM-2
7466: PPUSH
7467: CALL_OW 88
// DialogueOff ;
7471: CALL_OW 7
// InGameOff ;
7475: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7479: LD_INT 71
7481: PPUSH
7482: LD_INT 50
7484: PPUSH
7485: LD_INT 7
7487: PPUSH
7488: LD_INT 30
7490: NEG
7491: PPUSH
7492: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7496: LD_INT 71
7498: PPUSH
7499: LD_INT 50
7501: PPUSH
7502: LD_INT 7
7504: PPUSH
7505: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7509: LD_STRING M1
7511: PPUSH
7512: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7516: LD_INT 35
7518: PPUSH
7519: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7523: LD_EXP 3
7527: PUSH
7528: LD_OWVAR 1
7532: PUSH
7533: LD_INT 2100
7535: GREATER
7536: OR
7537: IFFALSE 7516
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7539: LD_INT 350
7541: PPUSH
7542: LD_INT 700
7544: PPUSH
7545: CALL_OW 12
7549: PPUSH
7550: CALL_OW 67
// PrepareGossudarov ;
7554: CALL 1873 0 0
// repeat wait ( 0 0$1 ) ;
7558: LD_INT 35
7560: PPUSH
7561: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7565: LD_INT 22
7567: PUSH
7568: LD_INT 6
7570: PUSH
7571: EMPTY
7572: LIST
7573: LIST
7574: PUSH
7575: LD_INT 3
7577: PUSH
7578: LD_INT 24
7580: PUSH
7581: LD_INT 1000
7583: PUSH
7584: EMPTY
7585: LIST
7586: LIST
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PPUSH
7596: CALL_OW 69
7600: PUSH
7601: LD_INT 7
7603: PPUSH
7604: LD_EXP 32
7608: PPUSH
7609: CALL_OW 292
7613: OR
7614: IFFALSE 7558
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7616: LD_ADDR_VAR 0 2
7620: PUSH
7621: LD_INT 22
7623: PUSH
7624: LD_INT 6
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PPUSH
7631: CALL_OW 69
7635: ST_TO_ADDR
// for i in tmp do
7636: LD_ADDR_VAR 0 3
7640: PUSH
7641: LD_VAR 0 2
7645: PUSH
7646: FOR_IN
7647: IFFALSE 7663
// SetSide ( i , 7 ) ;
7649: LD_VAR 0 3
7653: PPUSH
7654: LD_INT 7
7656: PPUSH
7657: CALL_OW 235
7661: GO 7646
7663: POP
7664: POP
// DialogueOn ;
7665: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7669: LD_EXP 15
7673: PUSH
7674: LD_EXP 16
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: LD_EXP 32
7687: PPUSH
7688: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7692: LD_EXP 32
7696: PPUSH
7697: CALL_OW 87
// if not Roth then
7701: LD_EXP 16
7705: NOT
7706: IFFALSE 7798
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7708: LD_VAR 0 2
7712: PPUSH
7713: LD_INT 3
7715: PUSH
7716: LD_INT 24
7718: PUSH
7719: LD_INT 1000
7721: PUSH
7722: EMPTY
7723: LIST
7724: LIST
7725: PUSH
7726: EMPTY
7727: LIST
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: IFFALSE 7748
// Say ( JMM , D2-JMM-1 ) ;
7736: LD_EXP 15
7740: PPUSH
7741: LD_STRING D2-JMM-1
7743: PPUSH
7744: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7748: LD_EXP 15
7752: PPUSH
7753: LD_STRING D2-JMM-1b
7755: PPUSH
7756: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7760: LD_EXP 32
7764: PPUSH
7765: LD_STRING D2-Gos-1
7767: PPUSH
7768: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7772: LD_EXP 15
7776: PPUSH
7777: LD_STRING D2-JMM-2
7779: PPUSH
7780: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7784: LD_EXP 32
7788: PPUSH
7789: LD_STRING D2-Gos-2
7791: PPUSH
7792: CALL_OW 88
// end else
7796: GO 7950
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7798: LD_VAR 0 2
7802: PPUSH
7803: LD_INT 3
7805: PUSH
7806: LD_INT 24
7808: PUSH
7809: LD_INT 1000
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PPUSH
7820: CALL_OW 72
7824: IFFALSE 7850
// begin Say ( Roth , D2-Roth-2 ) ;
7826: LD_EXP 16
7830: PPUSH
7831: LD_STRING D2-Roth-2
7833: PPUSH
7834: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7838: LD_EXP 15
7842: PPUSH
7843: LD_STRING D2-JMM-1a
7845: PPUSH
7846: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7850: LD_EXP 16
7854: PPUSH
7855: LD_STRING D2-Roth-2a
7857: PPUSH
7858: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7862: LD_EXP 16
7866: PPUSH
7867: LD_STRING D2-Roth-2b
7869: PPUSH
7870: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7874: LD_EXP 15
7878: PPUSH
7879: LD_STRING D2-JMM-3
7881: PPUSH
7882: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7886: LD_VAR 0 2
7890: PPUSH
7891: LD_INT 3
7893: PUSH
7894: LD_INT 24
7896: PUSH
7897: LD_INT 1000
7899: PUSH
7900: EMPTY
7901: LIST
7902: LIST
7903: PUSH
7904: EMPTY
7905: LIST
7906: LIST
7907: PPUSH
7908: CALL_OW 72
7912: IFFALSE 7950
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7914: LD_EXP 32
7918: PPUSH
7919: LD_STRING D2-Gos-3
7921: PPUSH
7922: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7926: LD_EXP 15
7930: PPUSH
7931: LD_STRING D2-JMM-4
7933: PPUSH
7934: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7938: LD_EXP 32
7942: PPUSH
7943: LD_STRING D2-Gos-4
7945: PPUSH
7946: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7950: LD_EXP 15
7954: PPUSH
7955: LD_STRING D2-JMM-5
7957: PPUSH
7958: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7962: LD_EXP 32
7966: PPUSH
7967: LD_STRING D2-Gos-5
7969: PPUSH
7970: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7974: LD_EXP 15
7978: PPUSH
7979: LD_STRING D2-JMM-6
7981: PPUSH
7982: CALL_OW 88
// DialogueOff ;
7986: CALL_OW 7
// wait ( 0 0$2 ) ;
7990: LD_INT 70
7992: PPUSH
7993: CALL_OW 67
// if Kirilenkova then
7997: LD_EXP 33
8001: IFFALSE 8015
// Say ( Kirilenkova , D3-Kir-1 ) ;
8003: LD_EXP 33
8007: PPUSH
8008: LD_STRING D3-Kir-1
8010: PPUSH
8011: CALL_OW 88
// gossudarov_arrive := true ;
8015: LD_ADDR_EXP 4
8019: PUSH
8020: LD_INT 1
8022: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8023: LD_INT 35
8025: PPUSH
8026: CALL_OW 67
// until ru_lab_builded ;
8030: LD_EXP 5
8034: IFFALSE 8023
// DialogueOn ;
8036: CALL_OW 6
// if Kirilenkova then
8040: LD_EXP 33
8044: IFFALSE 8060
// Say ( Kirilenkova , D3a-Kir-1 ) else
8046: LD_EXP 33
8050: PPUSH
8051: LD_STRING D3a-Kir-1
8053: PPUSH
8054: CALL_OW 88
8058: GO 8082
// begin un := SciRu ;
8060: LD_ADDR_VAR 0 4
8064: PUSH
8065: CALL 13219 0 0
8069: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8070: LD_VAR 0 4
8074: PPUSH
8075: LD_STRING D3a-Sci1-1
8077: PPUSH
8078: CALL_OW 88
// end ; if Kirilenkova or un then
8082: LD_EXP 33
8086: PUSH
8087: LD_VAR 0 4
8091: OR
8092: IFFALSE 8106
// Say ( JMM , D3a-JMM-1 ) ;
8094: LD_EXP 15
8098: PPUSH
8099: LD_STRING D3a-JMM-1
8101: PPUSH
8102: CALL_OW 88
// DialogueOff ;
8106: CALL_OW 7
// end ;
8110: LD_VAR 0 1
8114: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8115: LD_EXP 4
8119: PUSH
8120: LD_INT 22
8122: PUSH
8123: LD_INT 7
8125: PUSH
8126: EMPTY
8127: LIST
8128: LIST
8129: PUSH
8130: LD_INT 2
8132: PUSH
8133: LD_INT 25
8135: PUSH
8136: LD_INT 1
8138: PUSH
8139: EMPTY
8140: LIST
8141: LIST
8142: PUSH
8143: LD_INT 25
8145: PUSH
8146: LD_INT 2
8148: PUSH
8149: EMPTY
8150: LIST
8151: LIST
8152: PUSH
8153: LD_INT 25
8155: PUSH
8156: LD_INT 3
8158: PUSH
8159: EMPTY
8160: LIST
8161: LIST
8162: PUSH
8163: LD_INT 25
8165: PUSH
8166: LD_INT 4
8168: PUSH
8169: EMPTY
8170: LIST
8171: LIST
8172: PUSH
8173: LD_INT 25
8175: PUSH
8176: LD_INT 5
8178: PUSH
8179: EMPTY
8180: LIST
8181: LIST
8182: PUSH
8183: LD_INT 25
8185: PUSH
8186: LD_INT 8
8188: PUSH
8189: EMPTY
8190: LIST
8191: LIST
8192: PUSH
8193: LD_INT 25
8195: PUSH
8196: LD_INT 9
8198: PUSH
8199: EMPTY
8200: LIST
8201: LIST
8202: PUSH
8203: EMPTY
8204: LIST
8205: LIST
8206: LIST
8207: LIST
8208: LIST
8209: LIST
8210: LIST
8211: LIST
8212: PUSH
8213: EMPTY
8214: LIST
8215: LIST
8216: PPUSH
8217: CALL_OW 69
8221: PUSH
8222: LD_INT 7
8224: LESS
8225: AND
8226: IFFALSE 8238
8228: GO 8230
8230: DISABLE
// YouLost ( TooMany ) ;
8231: LD_STRING TooMany
8233: PPUSH
8234: CALL_OW 104
8238: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8239: LD_EXP 32
8243: PPUSH
8244: CALL_OW 255
8248: PUSH
8249: LD_INT 7
8251: EQUAL
8252: IFFALSE 8469
8254: GO 8256
8256: DISABLE
8257: LD_INT 0
8259: PPUSH
8260: PPUSH
8261: PPUSH
// begin uc_side := 3 ;
8262: LD_ADDR_OWVAR 20
8266: PUSH
8267: LD_INT 3
8269: ST_TO_ADDR
// uc_nation := 3 ;
8270: LD_ADDR_OWVAR 21
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8278: LD_INT 21
8280: PPUSH
8281: LD_INT 3
8283: PPUSH
8284: LD_INT 3
8286: PPUSH
8287: LD_INT 42
8289: PPUSH
8290: LD_INT 100
8292: PPUSH
8293: CALL 19668 0 5
// un := CreateVehicle ;
8297: LD_ADDR_VAR 0 3
8301: PUSH
8302: CALL_OW 45
8306: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8307: LD_VAR 0 3
8311: PPUSH
8312: LD_INT 15
8314: PPUSH
8315: LD_INT 0
8317: PPUSH
8318: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8322: LD_VAR 0 3
8326: PPUSH
8327: LD_INT 67
8329: PPUSH
8330: LD_INT 45
8332: PPUSH
8333: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8337: LD_VAR 0 3
8341: PPUSH
8342: LD_INT 70
8344: PPUSH
8345: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8349: LD_VAR 0 3
8353: PPUSH
8354: LD_INT 69
8356: PPUSH
8357: LD_INT 18
8359: PPUSH
8360: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8364: LD_VAR 0 3
8368: PPUSH
8369: LD_INT 60
8371: PPUSH
8372: LD_INT 3
8374: PPUSH
8375: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8379: LD_INT 35
8381: PPUSH
8382: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8386: LD_VAR 0 3
8390: PPUSH
8391: CALL_OW 302
8395: NOT
8396: PUSH
8397: LD_VAR 0 3
8401: PPUSH
8402: LD_INT 17
8404: PPUSH
8405: CALL_OW 308
8409: OR
8410: PUSH
8411: LD_VAR 0 3
8415: PPUSH
8416: LD_INT 60
8418: PPUSH
8419: LD_INT 3
8421: PPUSH
8422: CALL_OW 307
8426: OR
8427: IFFALSE 8379
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8429: LD_VAR 0 3
8433: PPUSH
8434: LD_INT 17
8436: PPUSH
8437: CALL_OW 308
8441: PUSH
8442: LD_VAR 0 3
8446: PPUSH
8447: LD_INT 60
8449: PPUSH
8450: LD_INT 3
8452: PPUSH
8453: CALL_OW 307
8457: OR
8458: IFFALSE 8469
// RemoveUnit ( un ) ;
8460: LD_VAR 0 3
8464: PPUSH
8465: CALL_OW 64
// end ;
8469: PPOPN 3
8471: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8472: LD_EXP 4
8476: IFFALSE 8718
8478: GO 8480
8480: DISABLE
8481: LD_INT 0
8483: PPUSH
8484: PPUSH
8485: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8486: LD_INT 70
8488: PPUSH
8489: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8493: LD_ADDR_VAR 0 3
8497: PUSH
8498: LD_INT 22
8500: PUSH
8501: LD_INT 7
8503: PUSH
8504: EMPTY
8505: LIST
8506: LIST
8507: PUSH
8508: LD_INT 101
8510: PUSH
8511: LD_INT 3
8513: PUSH
8514: EMPTY
8515: LIST
8516: LIST
8517: PUSH
8518: EMPTY
8519: LIST
8520: LIST
8521: PPUSH
8522: CALL_OW 69
8526: ST_TO_ADDR
// until tmp ;
8527: LD_VAR 0 3
8531: IFFALSE 8486
// un := NearestUnitToUnit ( tmp , JMM ) ;
8533: LD_ADDR_VAR 0 2
8537: PUSH
8538: LD_VAR 0 3
8542: PPUSH
8543: LD_EXP 15
8547: PPUSH
8548: CALL_OW 74
8552: ST_TO_ADDR
// player_spotted := true ;
8553: LD_ADDR_EXP 6
8557: PUSH
8558: LD_INT 1
8560: ST_TO_ADDR
// tmp := SciRu ;
8561: LD_ADDR_VAR 0 3
8565: PUSH
8566: CALL 13219 0 0
8570: ST_TO_ADDR
// if not tmp then
8571: LD_VAR 0 3
8575: NOT
8576: IFFALSE 8588
// tmp := SolRu ;
8578: LD_ADDR_VAR 0 3
8582: PUSH
8583: CALL 13366 0 0
8587: ST_TO_ADDR
// DialogueOn ;
8588: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8592: LD_VAR 0 2
8596: PPUSH
8597: CALL_OW 250
8601: PPUSH
8602: LD_VAR 0 2
8606: PPUSH
8607: CALL_OW 251
8611: PPUSH
8612: LD_INT 7
8614: PPUSH
8615: LD_INT 8
8617: NEG
8618: PPUSH
8619: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8623: LD_VAR 0 2
8627: PPUSH
8628: CALL_OW 87
// if tmp then
8632: LD_VAR 0 3
8636: IFFALSE 8650
// Say ( tmp , D4-RSci1-1 ) ;
8638: LD_VAR 0 3
8642: PPUSH
8643: LD_STRING D4-RSci1-1
8645: PPUSH
8646: CALL_OW 88
// if Gossudarov then
8650: LD_EXP 32
8654: IFFALSE 8680
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8656: LD_EXP 32
8660: PPUSH
8661: LD_STRING D4-Gos-1
8663: PPUSH
8664: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8668: LD_EXP 15
8672: PPUSH
8673: LD_STRING D4-JMM-1
8675: PPUSH
8676: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8680: LD_VAR 0 2
8684: PPUSH
8685: CALL_OW 250
8689: PPUSH
8690: LD_VAR 0 2
8694: PPUSH
8695: CALL_OW 251
8699: PPUSH
8700: LD_INT 7
8702: PPUSH
8703: CALL_OW 331
// DialogueOff ;
8707: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8711: LD_STRING M5
8713: PPUSH
8714: CALL_OW 337
// end ;
8718: PPOPN 3
8720: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8721: LD_EXP 6
8725: IFFALSE 9318
8727: GO 8729
8729: DISABLE
8730: LD_INT 0
8732: PPUSH
8733: PPUSH
8734: PPUSH
// begin PrepareBelkov ;
8735: CALL 2186 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8739: LD_EXP 47
8743: PPUSH
8744: LD_INT 118
8746: PPUSH
8747: LD_INT 106
8749: PPUSH
8750: CALL_OW 111
// AddComHold ( Belkov ) ;
8754: LD_EXP 47
8758: PPUSH
8759: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8763: LD_INT 35
8765: PPUSH
8766: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 118
8777: PPUSH
8778: LD_INT 106
8780: PPUSH
8781: CALL_OW 307
8785: IFFALSE 8763
// ChangeSideFog ( 4 , 7 ) ;
8787: LD_INT 4
8789: PPUSH
8790: LD_INT 7
8792: PPUSH
8793: CALL_OW 343
// if IsOk ( Belkov ) then
8797: LD_EXP 47
8801: PPUSH
8802: CALL_OW 302
8806: IFFALSE 8890
// begin InGameOn ;
8808: CALL_OW 8
// DialogueOn ;
8812: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8816: LD_EXP 47
8820: PPUSH
8821: LD_STRING D5-Bel-1
8823: PPUSH
8824: CALL_OW 94
// if Gossudarov then
8828: LD_EXP 32
8832: IFFALSE 8882
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8834: LD_EXP 32
8838: PPUSH
8839: LD_STRING D5-Gos-1
8841: PPUSH
8842: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8846: LD_EXP 15
8850: PPUSH
8851: LD_STRING D5-JMM-1
8853: PPUSH
8854: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8858: LD_EXP 32
8862: PPUSH
8863: LD_STRING D5-Gos-2
8865: PPUSH
8866: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8870: LD_EXP 15
8874: PPUSH
8875: LD_STRING D5-JMM-2
8877: PPUSH
8878: CALL_OW 88
// end ; DialogueOff ;
8882: CALL_OW 7
// InGameOff ;
8886: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8890: LD_STRING QSaveBelkov
8892: PPUSH
8893: CALL_OW 97
8897: PUSH
8898: LD_INT 1
8900: DOUBLE
8901: EQUAL
8902: IFTRUE 8906
8904: GO 8956
8906: POP
// begin DialogueOn ;
8907: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8911: LD_EXP 15
8915: PPUSH
8916: LD_STRING D5a-JMM-1
8918: PPUSH
8919: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8923: LD_EXP 47
8927: PPUSH
8928: LD_STRING D5a-Bel-1
8930: PPUSH
8931: CALL_OW 94
// DialogueOff ;
8935: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8939: LD_EXP 47
8943: PPUSH
8944: LD_INT 83
8946: PPUSH
8947: LD_INT 49
8949: PPUSH
8950: CALL_OW 111
// end ; 2 :
8954: GO 8989
8956: LD_INT 2
8958: DOUBLE
8959: EQUAL
8960: IFTRUE 8964
8962: GO 8988
8964: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8965: LD_EXP 15
8969: PPUSH
8970: LD_STRING D5a-JMM-2
8972: PPUSH
8973: CALL_OW 88
// ComHold ( Belkov ) ;
8977: LD_EXP 47
8981: PPUSH
8982: CALL_OW 140
// end ; end ;
8986: GO 8989
8988: POP
// time := 0 0$00 ;
8989: LD_ADDR_VAR 0 1
8993: PUSH
8994: LD_INT 0
8996: ST_TO_ADDR
// vehSpawned := false ;
8997: LD_ADDR_VAR 0 3
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9005: LD_INT 35
9007: PPUSH
9008: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9012: LD_VAR 0 1
9016: PUSH
9017: LD_INT 350
9019: PUSH
9020: LD_INT 175
9022: PUSH
9023: LD_INT 105
9025: PUSH
9026: LD_INT 70
9028: PUSH
9029: EMPTY
9030: LIST
9031: LIST
9032: LIST
9033: LIST
9034: PUSH
9035: LD_OWVAR 67
9039: ARRAY
9040: GREATEREQUAL
9041: PUSH
9042: LD_VAR 0 3
9046: NOT
9047: AND
9048: IFFALSE 9138
// begin vehSpawned := true ;
9050: LD_ADDR_VAR 0 3
9054: PUSH
9055: LD_INT 1
9057: ST_TO_ADDR
// uc_side := 3 ;
9058: LD_ADDR_OWVAR 20
9062: PUSH
9063: LD_INT 3
9065: ST_TO_ADDR
// uc_nation := 3 ;
9066: LD_ADDR_OWVAR 21
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9074: LD_INT 22
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 3
9082: PPUSH
9083: LD_INT 43
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 19668 0 5
// veh := CreateVehicle ;
9093: LD_ADDR_VAR 0 2
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9103: LD_VAR 0 2
9107: PPUSH
9108: LD_INT 130
9110: PPUSH
9111: LD_INT 131
9113: PPUSH
9114: LD_INT 0
9116: PPUSH
9117: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9121: LD_VAR 0 2
9125: PPUSH
9126: LD_INT 100
9128: PPUSH
9129: LD_INT 82
9131: PPUSH
9132: CALL_OW 114
// end else
9136: GO 9152
// time := time + 0 0$1 ;
9138: LD_ADDR_VAR 0 1
9142: PUSH
9143: LD_VAR 0 1
9147: PUSH
9148: LD_INT 35
9150: PLUS
9151: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9152: LD_EXP 47
9156: PPUSH
9157: CALL_OW 301
9161: PUSH
9162: LD_EXP 47
9166: PPUSH
9167: CALL_OW 255
9171: PUSH
9172: LD_INT 4
9174: EQUAL
9175: AND
9176: PUSH
9177: LD_INT 22
9179: PUSH
9180: LD_INT 7
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: PPUSH
9187: CALL_OW 69
9191: PPUSH
9192: LD_EXP 47
9196: PPUSH
9197: CALL_OW 74
9201: PPUSH
9202: LD_EXP 47
9206: PPUSH
9207: CALL_OW 296
9211: PUSH
9212: LD_INT 10
9214: LESS
9215: OR
9216: IFFALSE 9005
// if IsDead ( Belkov ) then
9218: LD_EXP 47
9222: PPUSH
9223: CALL_OW 301
9227: IFFALSE 9252
// begin CenterNowOnUnits ( Belkov ) ;
9229: LD_EXP 47
9233: PPUSH
9234: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9238: LD_EXP 15
9242: PPUSH
9243: LD_STRING D5a-JMM-2a
9245: PPUSH
9246: CALL_OW 88
// exit ;
9250: GO 9318
// end ; if See ( 7 , Belkov ) then
9252: LD_INT 7
9254: PPUSH
9255: LD_EXP 47
9259: PPUSH
9260: CALL_OW 292
9264: IFFALSE 9278
// SetSide ( Belkov , 7 ) ;
9266: LD_EXP 47
9270: PPUSH
9271: LD_INT 7
9273: PPUSH
9274: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9278: LD_INT 35
9280: PPUSH
9281: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9285: LD_EXP 47
9289: PPUSH
9290: LD_INT 66
9292: PPUSH
9293: LD_INT 45
9295: PPUSH
9296: CALL_OW 297
9300: PUSH
9301: LD_INT 30
9303: LESS
9304: IFFALSE 9278
// Say ( Belkov , D6-Bel-1 ) ;
9306: LD_EXP 47
9310: PPUSH
9311: LD_STRING D6-Bel-1
9313: PPUSH
9314: CALL_OW 88
// end ;
9318: PPOPN 3
9320: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9321: LD_EXP 47
9325: PPUSH
9326: CALL_OW 302
9330: PUSH
9331: LD_EXP 47
9335: PPUSH
9336: CALL_OW 504
9340: PUSH
9341: LD_INT 2
9343: PUSH
9344: LD_INT 34
9346: PUSH
9347: LD_INT 47
9349: PUSH
9350: EMPTY
9351: LIST
9352: LIST
9353: PUSH
9354: LD_INT 34
9356: PUSH
9357: LD_INT 45
9359: PUSH
9360: EMPTY
9361: LIST
9362: LIST
9363: PUSH
9364: EMPTY
9365: LIST
9366: LIST
9367: LIST
9368: PPUSH
9369: CALL_OW 69
9373: IN
9374: AND
9375: IFFALSE 9392
9377: GO 9379
9379: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9380: LD_EXP 47
9384: PPUSH
9385: LD_STRING D7-Bel-1
9387: PPUSH
9388: CALL_OW 88
9392: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9393: LD_INT 22
9395: PUSH
9396: LD_INT 7
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: PUSH
9403: LD_INT 101
9405: PUSH
9406: LD_INT 2
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PUSH
9413: EMPTY
9414: LIST
9415: LIST
9416: PPUSH
9417: CALL_OW 69
9421: PUSH
9422: LD_EXP 8
9426: NOT
9427: AND
9428: PUSH
9429: LD_EXP 46
9433: PPUSH
9434: CALL_OW 305
9438: NOT
9439: AND
9440: IFFALSE 9910
9442: GO 9444
9444: DISABLE
9445: LD_INT 0
9447: PPUSH
// begin ar_base_spotted := true ;
9448: LD_ADDR_EXP 8
9452: PUSH
9453: LD_INT 1
9455: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9456: LD_ADDR_VAR 0 1
9460: PUSH
9461: LD_INT 22
9463: PUSH
9464: LD_INT 2
9466: PUSH
9467: EMPTY
9468: LIST
9469: LIST
9470: PUSH
9471: LD_INT 21
9473: PUSH
9474: LD_INT 3
9476: PUSH
9477: EMPTY
9478: LIST
9479: LIST
9480: PUSH
9481: EMPTY
9482: LIST
9483: LIST
9484: PPUSH
9485: CALL_OW 69
9489: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9490: LD_ADDR_VAR 0 1
9494: PUSH
9495: LD_VAR 0 1
9499: PPUSH
9500: LD_EXP 15
9504: PPUSH
9505: CALL_OW 74
9509: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9510: LD_INT 7
9512: PPUSH
9513: LD_INT 3
9515: PPUSH
9516: CALL_OW 332
// DialogueOn ;
9520: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9524: LD_VAR 0 1
9528: PPUSH
9529: CALL_OW 250
9533: PPUSH
9534: LD_VAR 0 1
9538: PPUSH
9539: CALL_OW 251
9543: PPUSH
9544: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9548: LD_ADDR_VAR 0 1
9552: PUSH
9553: LD_INT 22
9555: PUSH
9556: LD_INT 7
9558: PUSH
9559: EMPTY
9560: LIST
9561: LIST
9562: PUSH
9563: LD_INT 23
9565: PUSH
9566: LD_INT 1
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: PUSH
9573: LD_INT 26
9575: PUSH
9576: LD_INT 1
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: EMPTY
9584: LIST
9585: LIST
9586: LIST
9587: PPUSH
9588: CALL_OW 69
9592: PUSH
9593: LD_EXP 15
9597: PUSH
9598: LD_EXP 19
9602: PUSH
9603: LD_EXP 20
9607: PUSH
9608: LD_EXP 27
9612: PUSH
9613: LD_EXP 16
9617: PUSH
9618: LD_EXP 25
9622: PUSH
9623: LD_EXP 21
9627: PUSH
9628: LD_EXP 23
9632: PUSH
9633: EMPTY
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: LIST
9641: LIST
9642: DIFF
9643: ST_TO_ADDR
// if not tmp then
9644: LD_VAR 0 1
9648: NOT
9649: IFFALSE 9723
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9651: LD_ADDR_VAR 0 1
9655: PUSH
9656: LD_INT 22
9658: PUSH
9659: LD_INT 7
9661: PUSH
9662: EMPTY
9663: LIST
9664: LIST
9665: PUSH
9666: LD_INT 23
9668: PUSH
9669: LD_INT 1
9671: PUSH
9672: EMPTY
9673: LIST
9674: LIST
9675: PUSH
9676: LD_INT 26
9678: PUSH
9679: LD_INT 2
9681: PUSH
9682: EMPTY
9683: LIST
9684: LIST
9685: PUSH
9686: EMPTY
9687: LIST
9688: LIST
9689: LIST
9690: PPUSH
9691: CALL_OW 69
9695: PUSH
9696: LD_EXP 30
9700: PUSH
9701: LD_EXP 17
9705: PUSH
9706: LD_EXP 28
9710: PUSH
9711: LD_EXP 29
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: LIST
9720: LIST
9721: DIFF
9722: ST_TO_ADDR
// if tmp then
9723: LD_VAR 0 1
9727: IFFALSE 9798
// case GetSex ( tmp [ 1 ] ) of sex_male :
9729: LD_VAR 0 1
9733: PUSH
9734: LD_INT 1
9736: ARRAY
9737: PPUSH
9738: CALL_OW 258
9742: PUSH
9743: LD_INT 1
9745: DOUBLE
9746: EQUAL
9747: IFTRUE 9751
9749: GO 9770
9751: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9752: LD_VAR 0 1
9756: PUSH
9757: LD_INT 1
9759: ARRAY
9760: PPUSH
9761: LD_STRING D9-Sol1-1
9763: PPUSH
9764: CALL_OW 88
9768: GO 9798
9770: LD_INT 2
9772: DOUBLE
9773: EQUAL
9774: IFTRUE 9778
9776: GO 9797
9778: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9779: LD_VAR 0 1
9783: PUSH
9784: LD_INT 1
9786: ARRAY
9787: PPUSH
9788: LD_STRING D9-FSol1-1
9790: PPUSH
9791: CALL_OW 88
9795: GO 9798
9797: POP
// if Frank then
9798: LD_EXP 27
9802: IFFALSE 9906
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9804: LD_EXP 56
9808: PPUSH
9809: CALL_OW 250
9813: PPUSH
9814: LD_EXP 56
9818: PPUSH
9819: CALL_OW 251
9823: PPUSH
9824: LD_INT 7
9826: PPUSH
9827: LD_INT 8
9829: PPUSH
9830: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9834: LD_EXP 56
9838: PPUSH
9839: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9843: LD_EXP 27
9847: PPUSH
9848: LD_STRING D9-Frank-1
9850: PPUSH
9851: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9855: LD_EXP 15
9859: PPUSH
9860: LD_STRING D9-JMM-1
9862: PPUSH
9863: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9867: LD_EXP 27
9871: PPUSH
9872: LD_STRING D9-Frank-2
9874: PPUSH
9875: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9879: LD_EXP 56
9883: PPUSH
9884: CALL_OW 250
9888: PPUSH
9889: LD_EXP 56
9893: PPUSH
9894: CALL_OW 251
9898: PPUSH
9899: LD_INT 7
9901: PPUSH
9902: CALL_OW 331
// end ; DialogueOff ;
9906: CALL_OW 7
// end ;
9910: PPOPN 1
9912: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9913: LD_EXP 7
9917: PUSH
9918: LD_OWVAR 1
9922: PUSH
9923: LD_INT 42000
9925: GREATEREQUAL
9926: OR
9927: IFFALSE 10954
9929: GO 9931
9931: DISABLE
9932: LD_INT 0
9934: PPUSH
9935: PPUSH
// begin selected_option := 1 ;
9936: LD_ADDR_VAR 0 2
9940: PUSH
9941: LD_INT 1
9943: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9944: LD_INT 10500
9946: PPUSH
9947: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9951: LD_INT 35
9953: PPUSH
9954: CALL_OW 67
// until not ru_attackers ;
9958: LD_EXP 52
9962: NOT
9963: IFFALSE 9951
// PrepareBurlak ;
9965: CALL 2298 0 0
// repeat wait ( 0 0$2 ) ;
9969: LD_INT 70
9971: PPUSH
9972: CALL_OW 67
// until not HasTask ( Burlak ) ;
9976: LD_EXP 46
9980: PPUSH
9981: CALL_OW 314
9985: NOT
9986: IFFALSE 9969
// InGameOn ;
9988: CALL_OW 8
// DialogueOn ;
9992: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9996: LD_EXP 49
10000: PPUSH
10001: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10005: LD_EXP 46
10009: PPUSH
10010: LD_STRING D10-Bur-1
10012: PPUSH
10013: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10017: LD_EXP 47
10021: PUSH
10022: LD_EXP 47
10026: PPUSH
10027: CALL_OW 255
10031: PUSH
10032: LD_INT 7
10034: EQUAL
10035: AND
10036: IFFALSE 10050
// Say ( Belkov , D10-Bel-1 ) ;
10038: LD_EXP 47
10042: PPUSH
10043: LD_STRING D10-Bel-1
10045: PPUSH
10046: CALL_OW 88
// if Gossudarov then
10050: LD_EXP 32
10054: IFFALSE 10068
// Say ( Gossudarov , D10-Gos-1 ) ;
10056: LD_EXP 32
10060: PPUSH
10061: LD_STRING D10-Gos-1
10063: PPUSH
10064: CALL_OW 88
// if Kirilenkova then
10068: LD_EXP 33
10072: IFFALSE 10086
// Say ( Kirilenkova , D10-Kir-1 ) ;
10074: LD_EXP 33
10078: PPUSH
10079: LD_STRING D10-Kir-1
10081: PPUSH
10082: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10086: CALL 13366 0 0
10090: PPUSH
10091: LD_STRING D10-RSol1-1
10093: PPUSH
10094: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10098: LD_EXP 46
10102: PPUSH
10103: LD_STRING D10-Bur-2
10105: PPUSH
10106: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10110: LD_EXP 15
10114: PPUSH
10115: LD_STRING D10-JMM-2
10117: PPUSH
10118: CALL_OW 88
// if Kirilenkova then
10122: LD_EXP 33
10126: IFFALSE 10142
// Say ( Kirilenkova , D10-Kir-2 ) else
10128: LD_EXP 33
10132: PPUSH
10133: LD_STRING D10-Kir-2
10135: PPUSH
10136: CALL_OW 88
10140: GO 10154
// Say ( SolRu , D10-RSol1-2 ) ;
10142: CALL 13366 0 0
10146: PPUSH
10147: LD_STRING D10-RSol1-2
10149: PPUSH
10150: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10154: LD_EXP 15
10158: PPUSH
10159: LD_STRING D10-JMM-3
10161: PPUSH
10162: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10166: LD_EXP 46
10170: PPUSH
10171: LD_STRING D10-Bur-3
10173: PPUSH
10174: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10178: LD_EXP 15
10182: PPUSH
10183: LD_STRING D10-JMM-4
10185: PPUSH
10186: CALL_OW 88
// DialogueOff ;
10190: CALL_OW 7
// InGameOff ;
10194: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10198: LD_STRING M2
10200: PPUSH
10201: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10205: LD_INT 35
10207: PPUSH
10208: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10212: LD_INT 22
10214: PUSH
10215: LD_INT 7
10217: PUSH
10218: EMPTY
10219: LIST
10220: LIST
10221: PUSH
10222: LD_INT 91
10224: PUSH
10225: LD_EXP 46
10229: PUSH
10230: LD_INT 8
10232: PUSH
10233: EMPTY
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: IFFALSE 10205
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10248: LD_ADDR_VAR 0 1
10252: PUSH
10253: LD_INT 22
10255: PUSH
10256: LD_INT 4
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PPUSH
10263: CALL_OW 69
10267: PUSH
10268: FOR_IN
10269: IFFALSE 10285
// SetSide ( i , 7 ) ;
10271: LD_VAR 0 1
10275: PPUSH
10276: LD_INT 7
10278: PPUSH
10279: CALL_OW 235
10283: GO 10268
10285: POP
10286: POP
// ChangeMissionObjectives ( M3 ) ;
10287: LD_STRING M3
10289: PPUSH
10290: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10294: LD_INT 35
10296: PPUSH
10297: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10301: LD_EXP 15
10305: PPUSH
10306: LD_EXP 46
10310: PPUSH
10311: CALL_OW 296
10315: PUSH
10316: LD_INT 8
10318: LESS
10319: IFFALSE 10294
// ComTurnUnit ( JMM , Burlak ) ;
10321: LD_EXP 15
10325: PPUSH
10326: LD_EXP 46
10330: PPUSH
10331: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10335: LD_EXP 46
10339: PPUSH
10340: LD_EXP 15
10344: PPUSH
10345: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10349: LD_INT 10
10351: PPUSH
10352: CALL_OW 67
// DialogueOn ;
10356: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10360: LD_EXP 15
10364: PPUSH
10365: LD_STRING D11-JMM-1
10367: PPUSH
10368: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10372: LD_EXP 46
10376: PPUSH
10377: LD_STRING D11-Bur-1
10379: PPUSH
10380: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10384: LD_EXP 15
10388: PPUSH
10389: LD_STRING D11-JMM-2
10391: PPUSH
10392: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10396: LD_EXP 46
10400: PPUSH
10401: LD_STRING D11-Bur-2
10403: PPUSH
10404: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D11-JMM-3
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D11-Bur-3
10427: PPUSH
10428: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10432: LD_EXP 15
10436: PPUSH
10437: LD_STRING D11-JMM-4
10439: PPUSH
10440: CALL_OW 88
// if ar_base_spotted then
10444: LD_EXP 8
10448: IFFALSE 10464
// Say ( Burlak , D12-Bur-1 ) else
10450: LD_EXP 46
10454: PPUSH
10455: LD_STRING D12-Bur-1
10457: PPUSH
10458: CALL_OW 88
10462: GO 10503
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10464: LD_INT 7
10466: PPUSH
10467: LD_INT 3
10469: PPUSH
10470: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10474: LD_INT 127
10476: PPUSH
10477: LD_INT 45
10479: PPUSH
10480: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10484: LD_EXP 46
10488: PPUSH
10489: LD_STRING D12-Bur-1a
10491: PPUSH
10492: CALL_OW 88
// dwait ( 0 0$2 ) ;
10496: LD_INT 70
10498: PPUSH
10499: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10503: LD_EXP 46
10507: PPUSH
10508: LD_STRING D12-Bur-1b
10510: PPUSH
10511: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10515: LD_EXP 15
10519: PPUSH
10520: LD_STRING D12-JMM-1
10522: PPUSH
10523: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10527: LD_EXP 46
10531: PPUSH
10532: LD_STRING D12-Bur-2
10534: PPUSH
10535: CALL_OW 88
// if Roth then
10539: LD_EXP 16
10543: IFFALSE 10559
// Say ( Roth , D12-Roth-2 ) else
10545: LD_EXP 16
10549: PPUSH
10550: LD_STRING D12-Roth-2
10552: PPUSH
10553: CALL_OW 88
10557: GO 10571
// Say ( SciRu , D12-RSci1-2 ) ;
10559: CALL 13219 0 0
10563: PPUSH
10564: LD_STRING D12-RSci1-2
10566: PPUSH
10567: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10571: LD_EXP 15
10575: PPUSH
10576: LD_STRING D12-JMM-2
10578: PPUSH
10579: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10583: LD_EXP 46
10587: PPUSH
10588: LD_STRING D12-Bur-3
10590: PPUSH
10591: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10595: LD_EXP 15
10599: PPUSH
10600: LD_STRING D12-JMM-3
10602: PPUSH
10603: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10607: LD_EXP 46
10611: PPUSH
10612: LD_STRING D12-Bur-4
10614: PPUSH
10615: CALL_OW 88
// case Query ( QBase ) of 1 :
10619: LD_STRING QBase
10621: PPUSH
10622: CALL_OW 97
10626: PUSH
10627: LD_INT 1
10629: DOUBLE
10630: EQUAL
10631: IFTRUE 10635
10633: GO 10753
10635: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10636: LD_EXP 15
10640: PPUSH
10641: LD_STRING D13a-JMM-1
10643: PPUSH
10644: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10648: LD_EXP 46
10652: PPUSH
10653: LD_STRING D13a-Bur-1
10655: PPUSH
10656: CALL_OW 88
// if Roth then
10660: LD_EXP 16
10664: IFFALSE 10680
// Say ( Roth , D13a-Roth-1 ) else
10666: LD_EXP 16
10670: PPUSH
10671: LD_STRING D13a-Roth-1
10673: PPUSH
10674: CALL_OW 88
10678: GO 10692
// Say ( SciRu , D13a-RSci1-1 ) ;
10680: CALL 13219 0 0
10684: PPUSH
10685: LD_STRING D13a-RSci1-1
10687: PPUSH
10688: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10692: LD_EXP 15
10696: PPUSH
10697: LD_STRING D13a-JMM-2
10699: PPUSH
10700: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10704: LD_STRING QBaseAgain
10706: PPUSH
10707: CALL_OW 97
10711: PUSH
10712: LD_INT 1
10714: DOUBLE
10715: EQUAL
10716: IFTRUE 10720
10718: GO 10731
10720: POP
// selected_option := 2 ; 2 :
10721: LD_ADDR_VAR 0 2
10725: PUSH
10726: LD_INT 2
10728: ST_TO_ADDR
10729: GO 10751
10731: LD_INT 2
10733: DOUBLE
10734: EQUAL
10735: IFTRUE 10739
10737: GO 10750
10739: POP
// selected_option := 3 ; end ;
10740: LD_ADDR_VAR 0 2
10744: PUSH
10745: LD_INT 3
10747: ST_TO_ADDR
10748: GO 10751
10750: POP
// end ; 2 :
10751: GO 10792
10753: LD_INT 2
10755: DOUBLE
10756: EQUAL
10757: IFTRUE 10761
10759: GO 10772
10761: POP
// selected_option := 2 ; 3 :
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_INT 2
10769: ST_TO_ADDR
10770: GO 10792
10772: LD_INT 3
10774: DOUBLE
10775: EQUAL
10776: IFTRUE 10780
10778: GO 10791
10780: POP
// selected_option := 3 ; end ;
10781: LD_ADDR_VAR 0 2
10785: PUSH
10786: LD_INT 3
10788: ST_TO_ADDR
10789: GO 10792
10791: POP
// if selected_option = 2 then
10792: LD_VAR 0 2
10796: PUSH
10797: LD_INT 2
10799: EQUAL
10800: IFFALSE 10894
// begin Say ( JMM , D13b-JMM-1 ) ;
10802: LD_EXP 15
10806: PPUSH
10807: LD_STRING D13b-JMM-1
10809: PPUSH
10810: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10814: LD_EXP 46
10818: PPUSH
10819: LD_STRING D13b-Bur-1
10821: PPUSH
10822: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10826: LD_EXP 15
10830: PPUSH
10831: LD_STRING D13b-JMM-2
10833: PPUSH
10834: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10838: LD_EXP 55
10842: PPUSH
10843: LD_STRING D13b-Abd-2
10845: PPUSH
10846: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10850: LD_EXP 15
10854: PPUSH
10855: LD_STRING D13b-JMM-3
10857: PPUSH
10858: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10862: LD_EXP 55
10866: PPUSH
10867: LD_STRING D13b-Abd-3
10869: PPUSH
10870: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10874: LD_EXP 15
10878: PPUSH
10879: LD_STRING D13b-JMM-4
10881: PPUSH
10882: CALL_OW 88
// ar_active_attack := true ;
10886: LD_ADDR_EXP 9
10890: PUSH
10891: LD_INT 1
10893: ST_TO_ADDR
// end ; if selected_option = 3 then
10894: LD_VAR 0 2
10898: PUSH
10899: LD_INT 3
10901: EQUAL
10902: IFFALSE 10928
// begin Say ( JMM , D13c-JMM-1 ) ;
10904: LD_EXP 15
10908: PPUSH
10909: LD_STRING D13c-JMM-1
10911: PPUSH
10912: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10916: LD_EXP 46
10920: PPUSH
10921: LD_STRING D13c-Bur-1
10923: PPUSH
10924: CALL_OW 88
// end ; DialogueOff ;
10928: CALL_OW 7
// if not ar_active_attack then
10932: LD_EXP 9
10936: NOT
10937: IFFALSE 10954
// begin wait ( 6 6$00 ) ;
10939: LD_INT 12600
10941: PPUSH
10942: CALL_OW 67
// ar_active_attack := true ;
10946: LD_ADDR_EXP 9
10950: PUSH
10951: LD_INT 1
10953: ST_TO_ADDR
// end ; end ;
10954: PPOPN 2
10956: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10957: LD_EXP 46
10961: PPUSH
10962: CALL_OW 305
10966: PUSH
10967: LD_EXP 46
10971: PPUSH
10972: CALL_OW 255
10976: PUSH
10977: LD_INT 7
10979: EQUAL
10980: AND
10981: IFFALSE 11177
10983: GO 10985
10985: DISABLE
10986: LD_INT 0
10988: PPUSH
// begin wait ( 4 4$40 ) ;
10989: LD_INT 9800
10991: PPUSH
10992: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10996: LD_INT 35
10998: PPUSH
10999: CALL_OW 67
// until not ru_attackers ;
11003: LD_EXP 52
11007: NOT
11008: IFFALSE 10996
// PrepareGnyevko ;
11010: CALL 2242 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11014: LD_EXP 48
11018: PPUSH
11019: LD_INT 124
11021: PPUSH
11022: LD_INT 118
11024: PPUSH
11025: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11029: LD_EXP 48
11033: PPUSH
11034: CALL_OW 200
// time := 0 0$00 ;
11038: LD_ADDR_VAR 0 1
11042: PUSH
11043: LD_INT 0
11045: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11046: LD_INT 35
11048: PPUSH
11049: CALL_OW 67
// time := time + 0 0$1 ;
11053: LD_ADDR_VAR 0 1
11057: PUSH
11058: LD_VAR 0 1
11062: PUSH
11063: LD_INT 35
11065: PLUS
11066: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11067: LD_EXP 48
11071: PPUSH
11072: LD_INT 124
11074: PPUSH
11075: LD_INT 118
11077: PPUSH
11078: CALL_OW 307
11082: PUSH
11083: LD_VAR 0 1
11087: PUSH
11088: LD_INT 1050
11090: GREATEREQUAL
11091: OR
11092: IFFALSE 11046
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11094: LD_EXP 48
11098: PPUSH
11099: LD_STRING DBelkov-Gny-1
11101: PPUSH
11102: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11106: LD_EXP 46
11110: PPUSH
11111: LD_STRING DBelkov-Bur-1a
11113: PPUSH
11114: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11118: LD_INT 35
11120: PPUSH
11121: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11125: LD_EXP 48
11129: PPUSH
11130: LD_INT 22
11132: PUSH
11133: LD_INT 7
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PPUSH
11145: LD_EXP 48
11149: PPUSH
11150: CALL_OW 74
11154: PPUSH
11155: CALL_OW 296
11159: PUSH
11160: LD_INT 8
11162: LESS
11163: IFFALSE 11118
// SetSide ( Gnyevko , 7 ) ;
11165: LD_EXP 48
11169: PPUSH
11170: LD_INT 7
11172: PPUSH
11173: CALL_OW 235
// end ;
11177: PPOPN 1
11179: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11180: LD_EXP 46
11184: PPUSH
11185: CALL_OW 255
11189: PUSH
11190: LD_INT 7
11192: EQUAL
11193: IFFALSE 11203
11195: GO 11197
11197: DISABLE
// begin enable ;
11198: ENABLE
// PrepareAmericanAttack ;
11199: CALL 6845 0 0
// end ;
11203: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11204: LD_INT 22
11206: PUSH
11207: LD_INT 1
11209: PUSH
11210: EMPTY
11211: LIST
11212: LIST
11213: PPUSH
11214: CALL_OW 69
11218: IFFALSE 11402
11220: GO 11222
11222: DISABLE
11223: LD_INT 0
11225: PPUSH
11226: PPUSH
// begin while true do
11227: LD_INT 1
11229: IFFALSE 11286
// begin wait ( 0 0$1 ) ;
11231: LD_INT 35
11233: PPUSH
11234: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11238: LD_ADDR_VAR 0 2
11242: PUSH
11243: LD_INT 22
11245: PUSH
11246: LD_INT 1
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PPUSH
11253: CALL_OW 69
11257: PPUSH
11258: LD_EXP 15
11262: PPUSH
11263: CALL_OW 74
11267: ST_TO_ADDR
// if See ( 7 , tmp ) then
11268: LD_INT 7
11270: PPUSH
11271: LD_VAR 0 2
11275: PPUSH
11276: CALL_OW 292
11280: IFFALSE 11284
// break ;
11282: GO 11286
// end ;
11284: GO 11227
// DialogueOn ;
11286: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11290: LD_VAR 0 2
11294: PPUSH
11295: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11299: LD_VAR 0 2
11303: PPUSH
11304: CALL_OW 250
11308: PPUSH
11309: LD_VAR 0 2
11313: PPUSH
11314: CALL_OW 251
11318: PPUSH
11319: LD_INT 7
11321: PPUSH
11322: LD_INT 8
11324: PPUSH
11325: CALL_OW 330
// if Denis then
11329: LD_EXP 21
11333: IFFALSE 11347
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11335: LD_EXP 21
11339: PPUSH
11340: LD_STRING DAmerAttack-Pet-1
11342: PPUSH
11343: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11347: LD_EXP 15
11351: PPUSH
11352: LD_STRING DAmerAttack-JMM-1
11354: PPUSH
11355: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11359: LD_EXP 46
11363: PPUSH
11364: LD_STRING DStop-Bur-1
11366: PPUSH
11367: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11371: LD_VAR 0 2
11375: PPUSH
11376: CALL_OW 250
11380: PPUSH
11381: LD_VAR 0 2
11385: PPUSH
11386: CALL_OW 251
11390: PPUSH
11391: LD_INT 7
11393: PPUSH
11394: CALL_OW 331
// DialogueOff ;
11398: CALL_OW 7
// end ;
11402: PPOPN 2
11404: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11405: LD_INT 22
11407: PUSH
11408: LD_INT 3
11410: PUSH
11411: EMPTY
11412: LIST
11413: LIST
11414: PUSH
11415: LD_INT 21
11417: PUSH
11418: LD_INT 1
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: PPUSH
11429: CALL_OW 69
11433: PUSH
11434: LD_INT 0
11436: EQUAL
11437: IFFALSE 11479
11439: GO 11441
11441: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11442: LD_STRING M5a
11444: PPUSH
11445: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11449: LD_EXP 15
11453: PPUSH
11454: LD_STRING D8-JMM-1
11456: PPUSH
11457: CALL_OW 88
// if Gossudarov then
11461: LD_EXP 32
11465: IFFALSE 11479
// Say ( Gossudarov , D8-Gos-1 ) ;
11467: LD_EXP 32
11471: PPUSH
11472: LD_STRING D8-Gos-1
11474: PPUSH
11475: CALL_OW 88
// end ;
11479: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11480: LD_INT 22
11482: PUSH
11483: LD_INT 2
11485: PUSH
11486: EMPTY
11487: LIST
11488: LIST
11489: PUSH
11490: LD_INT 21
11492: PUSH
11493: LD_INT 1
11495: PUSH
11496: EMPTY
11497: LIST
11498: LIST
11499: PUSH
11500: EMPTY
11501: LIST
11502: LIST
11503: PPUSH
11504: CALL_OW 69
11508: PUSH
11509: LD_INT 0
11511: EQUAL
11512: IFFALSE 11562
11514: GO 11516
11516: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11517: LD_STRING M4c
11519: PPUSH
11520: CALL_OW 337
// if Roth then
11524: LD_EXP 16
11528: IFFALSE 11544
// Say ( Roth , DStop-Roth-1 ) else
11530: LD_EXP 16
11534: PPUSH
11535: LD_STRING DStop-Roth-1
11537: PPUSH
11538: CALL_OW 88
11542: GO 11562
// if Gossudarov then
11544: LD_EXP 32
11548: IFFALSE 11562
// Say ( Gossudarov , D8-Gos-1a ) ;
11550: LD_EXP 32
11554: PPUSH
11555: LD_STRING D8-Gos-1a
11557: PPUSH
11558: CALL_OW 88
// end ;
11562: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11563: LD_INT 7
11565: PPUSH
11566: LD_INT 1
11568: PPUSH
11569: LD_INT 1
11571: PPUSH
11572: CALL 14867 0 3
11576: PUSH
11577: LD_INT 0
11579: EQUAL
11580: PUSH
11581: LD_INT 7
11583: PPUSH
11584: LD_INT 3
11586: PPUSH
11587: LD_INT 1
11589: PPUSH
11590: CALL 14867 0 3
11594: PUSH
11595: LD_INT 0
11597: EQUAL
11598: AND
11599: IFFALSE 11611
11601: GO 11603
11603: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11604: LD_STRING M1a
11606: PPUSH
11607: CALL_OW 337
// end ;
11611: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11612: LD_INT 22
11614: PUSH
11615: LD_INT 2
11617: PUSH
11618: EMPTY
11619: LIST
11620: LIST
11621: PUSH
11622: LD_INT 21
11624: PUSH
11625: LD_INT 1
11627: PUSH
11628: EMPTY
11629: LIST
11630: LIST
11631: PUSH
11632: EMPTY
11633: LIST
11634: LIST
11635: PPUSH
11636: CALL_OW 69
11640: PUSH
11641: LD_INT 0
11643: EQUAL
11644: PUSH
11645: LD_INT 22
11647: PUSH
11648: LD_INT 3
11650: PUSH
11651: EMPTY
11652: LIST
11653: LIST
11654: PUSH
11655: LD_INT 21
11657: PUSH
11658: LD_INT 1
11660: PUSH
11661: EMPTY
11662: LIST
11663: LIST
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PPUSH
11669: CALL_OW 69
11673: PUSH
11674: LD_INT 0
11676: EQUAL
11677: AND
11678: PUSH
11679: LD_INT 22
11681: PUSH
11682: LD_INT 1
11684: PUSH
11685: EMPTY
11686: LIST
11687: LIST
11688: PPUSH
11689: CALL_OW 69
11693: PUSH
11694: LD_INT 0
11696: EQUAL
11697: AND
11698: PUSH
11699: LD_INT 7
11701: PPUSH
11702: LD_INT 1
11704: PPUSH
11705: LD_INT 1
11707: PPUSH
11708: CALL 14867 0 3
11712: PUSH
11713: LD_INT 0
11715: EQUAL
11716: AND
11717: PUSH
11718: LD_INT 7
11720: PPUSH
11721: LD_INT 3
11723: PPUSH
11724: LD_INT 1
11726: PPUSH
11727: CALL 14867 0 3
11731: PUSH
11732: LD_INT 0
11734: EQUAL
11735: AND
11736: IFFALSE 13216
11738: GO 11740
11740: DISABLE
11741: LD_INT 0
11743: PPUSH
11744: PPUSH
11745: PPUSH
11746: PPUSH
11747: PPUSH
11748: PPUSH
// begin m1 := false ;
11749: LD_ADDR_VAR 0 4
11753: PUSH
11754: LD_INT 0
11756: ST_TO_ADDR
// m2 := false ;
11757: LD_ADDR_VAR 0 5
11761: PUSH
11762: LD_INT 0
11764: ST_TO_ADDR
// m3 := false ;
11765: LD_ADDR_VAR 0 6
11769: PUSH
11770: LD_INT 0
11772: ST_TO_ADDR
// if tick < 40 40$00 then
11773: LD_OWVAR 1
11777: PUSH
11778: LD_INT 84000
11780: LESS
11781: IFFALSE 11790
// SetAchievement ( ACH_ASPEED_17 ) ;
11783: LD_STRING ACH_ASPEED_17
11785: PPUSH
11786: CALL_OW 543
// wait ( 0 0$5 ) ;
11790: LD_INT 175
11792: PPUSH
11793: CALL_OW 67
// if not IsDead ( Masha ) then
11797: LD_EXP 49
11801: PPUSH
11802: CALL_OW 301
11806: NOT
11807: IFFALSE 11829
// begin m1 := true ;
11809: LD_ADDR_VAR 0 4
11813: PUSH
11814: LD_INT 1
11816: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11817: LD_STRING Masha
11819: PPUSH
11820: LD_INT 1
11822: PPUSH
11823: CALL_OW 101
// end else
11827: GO 11840
// AddMedal ( Masha , - 1 ) ;
11829: LD_STRING Masha
11831: PPUSH
11832: LD_INT 1
11834: NEG
11835: PPUSH
11836: CALL_OW 101
// if abdul_escaped then
11840: LD_EXP 12
11844: IFFALSE 11859
// AddMedal ( Abdul , - 1 ) else
11846: LD_STRING Abdul
11848: PPUSH
11849: LD_INT 1
11851: NEG
11852: PPUSH
11853: CALL_OW 101
11857: GO 11877
// begin m2 := true ;
11859: LD_ADDR_VAR 0 5
11863: PUSH
11864: LD_INT 1
11866: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11867: LD_STRING Abdul
11869: PPUSH
11870: LD_INT 1
11872: PPUSH
11873: CALL_OW 101
// end ; if loss_counter = 0 then
11877: LD_EXP 13
11881: PUSH
11882: LD_INT 0
11884: EQUAL
11885: IFFALSE 11907
// begin m3 := true ;
11887: LD_ADDR_VAR 0 6
11891: PUSH
11892: LD_INT 1
11894: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11895: LD_STRING People
11897: PPUSH
11898: LD_INT 2
11900: PPUSH
11901: CALL_OW 101
// end else
11905: GO 11969
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11907: LD_EXP 13
11911: PUSH
11912: LD_INT 3
11914: PUSH
11915: LD_INT 2
11917: PUSH
11918: LD_INT 2
11920: PUSH
11921: LD_INT 1
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: LIST
11928: LIST
11929: PUSH
11930: LD_OWVAR 67
11934: ARRAY
11935: LESSEQUAL
11936: IFFALSE 11958
// begin AddMedal ( People , 1 ) ;
11938: LD_STRING People
11940: PPUSH
11941: LD_INT 1
11943: PPUSH
11944: CALL_OW 101
// m3 := true ;
11948: LD_ADDR_VAR 0 6
11952: PUSH
11953: LD_INT 1
11955: ST_TO_ADDR
// end else
11956: GO 11969
// AddMedal ( People , - 1 ) ;
11958: LD_STRING People
11960: PPUSH
11961: LD_INT 1
11963: NEG
11964: PPUSH
11965: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11969: LD_OWVAR 67
11973: PUSH
11974: LD_INT 3
11976: GREATEREQUAL
11977: PUSH
11978: LD_VAR 0 4
11982: AND
11983: PUSH
11984: LD_VAR 0 5
11988: AND
11989: PUSH
11990: LD_VAR 0 6
11994: AND
11995: IFFALSE 12007
// SetAchievementEX ( ACH_AMER , 17 ) ;
11997: LD_STRING ACH_AMER
11999: PPUSH
12000: LD_INT 17
12002: PPUSH
12003: CALL_OW 564
// GiveMedals ( MAIN ) ;
12007: LD_STRING MAIN
12009: PPUSH
12010: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12014: LD_ADDR_VAR 0 2
12018: PUSH
12019: LD_INT 22
12021: PUSH
12022: LD_INT 7
12024: PUSH
12025: EMPTY
12026: LIST
12027: LIST
12028: PUSH
12029: LD_INT 2
12031: PUSH
12032: LD_INT 25
12034: PUSH
12035: LD_INT 1
12037: PUSH
12038: EMPTY
12039: LIST
12040: LIST
12041: PUSH
12042: LD_INT 25
12044: PUSH
12045: LD_INT 2
12047: PUSH
12048: EMPTY
12049: LIST
12050: LIST
12051: PUSH
12052: LD_INT 25
12054: PUSH
12055: LD_INT 3
12057: PUSH
12058: EMPTY
12059: LIST
12060: LIST
12061: PUSH
12062: LD_INT 25
12064: PUSH
12065: LD_INT 4
12067: PUSH
12068: EMPTY
12069: LIST
12070: LIST
12071: PUSH
12072: LD_INT 25
12074: PUSH
12075: LD_INT 5
12077: PUSH
12078: EMPTY
12079: LIST
12080: LIST
12081: PUSH
12082: LD_INT 25
12084: PUSH
12085: LD_INT 8
12087: PUSH
12088: EMPTY
12089: LIST
12090: LIST
12091: PUSH
12092: LD_INT 25
12094: PUSH
12095: LD_INT 9
12097: PUSH
12098: EMPTY
12099: LIST
12100: LIST
12101: PUSH
12102: EMPTY
12103: LIST
12104: LIST
12105: LIST
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: PUSH
12112: EMPTY
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12121: LD_VAR 0 2
12125: PPUSH
12126: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12130: LD_ADDR_VAR 0 3
12134: PUSH
12135: LD_EXP 15
12139: PUSH
12140: LD_EXP 16
12144: PUSH
12145: LD_EXP 17
12149: PUSH
12150: LD_EXP 18
12154: PUSH
12155: LD_EXP 19
12159: PUSH
12160: LD_EXP 20
12164: PUSH
12165: LD_EXP 21
12169: PUSH
12170: LD_EXP 22
12174: PUSH
12175: LD_EXP 23
12179: PUSH
12180: LD_EXP 24
12184: PUSH
12185: LD_EXP 25
12189: PUSH
12190: LD_EXP 26
12194: PUSH
12195: LD_EXP 27
12199: PUSH
12200: LD_EXP 28
12204: PUSH
12205: LD_EXP 29
12209: PUSH
12210: LD_EXP 30
12214: PUSH
12215: LD_EXP 31
12219: PUSH
12220: LD_EXP 32
12224: PUSH
12225: LD_EXP 33
12229: PUSH
12230: LD_EXP 34
12234: PUSH
12235: LD_EXP 36
12239: PUSH
12240: LD_EXP 37
12244: PUSH
12245: LD_EXP 38
12249: PUSH
12250: LD_EXP 39
12254: PUSH
12255: LD_EXP 40
12259: PUSH
12260: LD_EXP 41
12264: PUSH
12265: LD_EXP 42
12269: PUSH
12270: LD_EXP 43
12274: PUSH
12275: LD_EXP 44
12279: PUSH
12280: LD_EXP 45
12284: PUSH
12285: LD_EXP 46
12289: PUSH
12290: LD_EXP 47
12294: PUSH
12295: LD_EXP 48
12299: PUSH
12300: EMPTY
12301: LIST
12302: LIST
12303: LIST
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: ST_TO_ADDR
// if tmp diff tmp2 then
12335: LD_VAR 0 2
12339: PUSH
12340: LD_VAR 0 3
12344: DIFF
12345: IFFALSE 12365
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12347: LD_VAR 0 2
12351: PUSH
12352: LD_VAR 0 3
12356: DIFF
12357: PPUSH
12358: LD_STRING 13a_others
12360: PPUSH
12361: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12365: LD_EXP 15
12369: PPUSH
12370: LD_STRING 13a_JMM
12372: PPUSH
12373: CALL_OW 38
// if Titov then
12377: LD_EXP 34
12381: IFFALSE 12395
// SaveCharacters ( Titov , 13a_Titov ) ;
12383: LD_EXP 34
12387: PPUSH
12388: LD_STRING 13a_Titov
12390: PPUSH
12391: CALL_OW 38
// if Dolgov then
12395: LD_EXP 36
12399: IFFALSE 12413
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12401: LD_EXP 36
12405: PPUSH
12406: LD_STRING 13a_Dolgov
12408: PPUSH
12409: CALL_OW 38
// if Petrosyan then
12413: LD_EXP 37
12417: IFFALSE 12431
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12419: LD_EXP 37
12423: PPUSH
12424: LD_STRING 13a_Petrosyan
12426: PPUSH
12427: CALL_OW 38
// if Scholtze then
12431: LD_EXP 38
12435: IFFALSE 12449
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12437: LD_EXP 38
12441: PPUSH
12442: LD_STRING 13a_Scholtze
12444: PPUSH
12445: CALL_OW 38
// if Oblukov then
12449: LD_EXP 39
12453: IFFALSE 12467
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12455: LD_EXP 39
12459: PPUSH
12460: LD_STRING 13a_Oblukov
12462: PPUSH
12463: CALL_OW 38
// if Kapitsova then
12467: LD_EXP 40
12471: IFFALSE 12485
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12473: LD_EXP 40
12477: PPUSH
12478: LD_STRING 13a_Kapitsova
12480: PPUSH
12481: CALL_OW 38
// if Lipshchin then
12485: LD_EXP 41
12489: IFFALSE 12503
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12491: LD_EXP 41
12495: PPUSH
12496: LD_STRING 13a_Lipshchin
12498: PPUSH
12499: CALL_OW 38
// if Petrovova then
12503: LD_EXP 42
12507: IFFALSE 12521
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12509: LD_EXP 42
12513: PPUSH
12514: LD_STRING 13a_Petrovova
12516: PPUSH
12517: CALL_OW 38
// if Kovalyuk then
12521: LD_EXP 43
12525: IFFALSE 12539
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12527: LD_EXP 43
12531: PPUSH
12532: LD_STRING 13a_Kovalyuk
12534: PPUSH
12535: CALL_OW 38
// if Kuzmov then
12539: LD_EXP 44
12543: IFFALSE 12557
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12545: LD_EXP 44
12549: PPUSH
12550: LD_STRING 13a_Kuzmov
12552: PPUSH
12553: CALL_OW 38
// if Karamazov then
12557: LD_EXP 45
12561: IFFALSE 12575
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12563: LD_EXP 45
12567: PPUSH
12568: LD_STRING 13a_Karamazov
12570: PPUSH
12571: CALL_OW 38
// if Burlak then
12575: LD_EXP 46
12579: IFFALSE 12593
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12581: LD_EXP 46
12585: PPUSH
12586: LD_STRING 13a_Burlak
12588: PPUSH
12589: CALL_OW 38
// if Belkov then
12593: LD_EXP 47
12597: IFFALSE 12611
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12599: LD_EXP 47
12603: PPUSH
12604: LD_STRING 13a_Belkov
12606: PPUSH
12607: CALL_OW 38
// if Gnyevko then
12611: LD_EXP 48
12615: IFFALSE 12629
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12617: LD_EXP 48
12621: PPUSH
12622: LD_STRING 13a_Gnyevko
12624: PPUSH
12625: CALL_OW 38
// if Lisa then
12629: LD_EXP 17
12633: IFFALSE 12647
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12635: LD_EXP 17
12639: PPUSH
12640: LD_STRING 13a_Lisa
12642: PPUSH
12643: CALL_OW 38
// if Donaldson then
12647: LD_EXP 18
12651: IFFALSE 12665
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12653: LD_EXP 18
12657: PPUSH
12658: LD_STRING 13a_Donaldson
12660: PPUSH
12661: CALL_OW 38
// if Bobby then
12665: LD_EXP 19
12669: IFFALSE 12683
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12671: LD_EXP 19
12675: PPUSH
12676: LD_STRING 13a_Bobby
12678: PPUSH
12679: CALL_OW 38
// if Cyrus then
12683: LD_EXP 20
12687: IFFALSE 12701
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12689: LD_EXP 20
12693: PPUSH
12694: LD_STRING 13a_Cyrus
12696: PPUSH
12697: CALL_OW 38
// if Denis then
12701: LD_EXP 21
12705: IFFALSE 12719
// SaveCharacters ( Denis , 13a_Denis ) ;
12707: LD_EXP 21
12711: PPUSH
12712: LD_STRING 13a_Denis
12714: PPUSH
12715: CALL_OW 38
// if Brown then
12719: LD_EXP 22
12723: IFFALSE 12737
// SaveCharacters ( Brown , 13a_Brown ) ;
12725: LD_EXP 22
12729: PPUSH
12730: LD_STRING 13a_Brown
12732: PPUSH
12733: CALL_OW 38
// if Gladstone then
12737: LD_EXP 23
12741: IFFALSE 12755
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12743: LD_EXP 23
12747: PPUSH
12748: LD_STRING 13a_Gladstone
12750: PPUSH
12751: CALL_OW 38
// if Houten then
12755: LD_EXP 24
12759: IFFALSE 12773
// SaveCharacters ( Houten , 13a_Houten ) ;
12761: LD_EXP 24
12765: PPUSH
12766: LD_STRING 13a_Houten
12768: PPUSH
12769: CALL_OW 38
// if Cornel then
12773: LD_EXP 25
12777: IFFALSE 12791
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12779: LD_EXP 25
12783: PPUSH
12784: LD_STRING 13a_Cornel
12786: PPUSH
12787: CALL_OW 38
// if Gary then
12791: LD_EXP 26
12795: IFFALSE 12809
// SaveCharacters ( Gary , 13a_Gary ) ;
12797: LD_EXP 26
12801: PPUSH
12802: LD_STRING 13a_Gary
12804: PPUSH
12805: CALL_OW 38
// if Frank then
12809: LD_EXP 27
12813: IFFALSE 12827
// SaveCharacters ( Frank , 13a_Frank ) ;
12815: LD_EXP 27
12819: PPUSH
12820: LD_STRING 13a_Frank
12822: PPUSH
12823: CALL_OW 38
// if Kikuchi then
12827: LD_EXP 28
12831: IFFALSE 12845
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12833: LD_EXP 28
12837: PPUSH
12838: LD_STRING 13a_Kikuchi
12840: PPUSH
12841: CALL_OW 38
// if Simms then
12845: LD_EXP 29
12849: IFFALSE 12863
// SaveCharacters ( Simms , 13a_Simms ) ;
12851: LD_EXP 29
12855: PPUSH
12856: LD_STRING 13a_Simms
12858: PPUSH
12859: CALL_OW 38
// if Joan then
12863: LD_EXP 30
12867: IFFALSE 12881
// SaveCharacters ( Joan , 13a_Joan ) ;
12869: LD_EXP 30
12873: PPUSH
12874: LD_STRING 13a_Joan
12876: PPUSH
12877: CALL_OW 38
// if DeltaDoctor then
12881: LD_EXP 31
12885: IFFALSE 12899
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12887: LD_EXP 31
12891: PPUSH
12892: LD_STRING 13a_DeltaDoctor
12894: PPUSH
12895: CALL_OW 38
// if Gossudarov then
12899: LD_EXP 32
12903: IFFALSE 12917
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12905: LD_EXP 32
12909: PPUSH
12910: LD_STRING 13a_Gossudarov
12912: PPUSH
12913: CALL_OW 38
// if Kirilenkova then
12917: LD_EXP 33
12921: IFFALSE 12935
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12923: LD_EXP 33
12927: PPUSH
12928: LD_STRING 13a_Kirilenkova
12930: PPUSH
12931: CALL_OW 38
// if Roth then
12935: LD_EXP 16
12939: IFFALSE 12953
// SaveCharacters ( Roth , 13a_Roth ) ;
12941: LD_EXP 16
12945: PPUSH
12946: LD_STRING 13a_Roth
12948: PPUSH
12949: CALL_OW 38
// if Masha then
12953: LD_EXP 49
12957: IFFALSE 13012
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12959: LD_EXP 49
12963: PPUSH
12964: CALL_OW 265
12968: PUSH
12969: LD_EXP 49
12973: PPUSH
12974: CALL_OW 262
12978: PUSH
12979: LD_EXP 49
12983: PPUSH
12984: CALL_OW 263
12988: PUSH
12989: LD_EXP 49
12993: PPUSH
12994: CALL_OW 264
12998: PUSH
12999: EMPTY
13000: LIST
13001: LIST
13002: LIST
13003: LIST
13004: PPUSH
13005: LD_STRING 13a_Masha
13007: PPUSH
13008: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13012: LD_ADDR_VAR 0 2
13016: PUSH
13017: LD_INT 21
13019: PUSH
13020: LD_INT 3
13022: PUSH
13023: EMPTY
13024: LIST
13025: LIST
13026: PPUSH
13027: CALL_OW 69
13031: ST_TO_ADDR
// tmp2 := [ ] ;
13032: LD_ADDR_VAR 0 3
13036: PUSH
13037: EMPTY
13038: ST_TO_ADDR
// if tmp then
13039: LD_VAR 0 2
13043: IFFALSE 13194
// for i in tmp do
13045: LD_ADDR_VAR 0 1
13049: PUSH
13050: LD_VAR 0 2
13054: PUSH
13055: FOR_IN
13056: IFFALSE 13192
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13058: LD_ADDR_VAR 0 3
13062: PUSH
13063: LD_VAR 0 3
13067: PUSH
13068: LD_VAR 0 1
13072: PPUSH
13073: CALL_OW 255
13077: PUSH
13078: LD_VAR 0 1
13082: PPUSH
13083: CALL_OW 248
13087: PUSH
13088: LD_VAR 0 1
13092: PPUSH
13093: CALL_OW 266
13097: PUSH
13098: LD_VAR 0 1
13102: PPUSH
13103: CALL_OW 250
13107: PUSH
13108: LD_VAR 0 1
13112: PPUSH
13113: CALL_OW 251
13117: PUSH
13118: LD_VAR 0 1
13122: PPUSH
13123: CALL_OW 254
13127: PUSH
13128: LD_VAR 0 1
13132: PPUSH
13133: CALL_OW 267
13137: PUSH
13138: LD_VAR 0 1
13142: PPUSH
13143: LD_INT 1
13145: PPUSH
13146: CALL_OW 268
13150: PUSH
13151: LD_VAR 0 1
13155: PPUSH
13156: LD_INT 2
13158: PPUSH
13159: CALL_OW 268
13163: PUSH
13164: LD_VAR 0 1
13168: PPUSH
13169: CALL_OW 269
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: PUSH
13186: EMPTY
13187: LIST
13188: ADD
13189: ST_TO_ADDR
13190: GO 13055
13192: POP
13193: POP
// if tmp2 then
13194: LD_VAR 0 3
13198: IFFALSE 13212
// SaveVariable ( tmp2 , 13a_buildings ) ;
13200: LD_VAR 0 3
13204: PPUSH
13205: LD_STRING 13a_buildings
13207: PPUSH
13208: CALL_OW 39
// YouWin ;
13212: CALL_OW 103
// end ;
13216: PPOPN 6
13218: END
// export function SciRu ; var tmp , t ; begin
13219: LD_INT 0
13221: PPUSH
13222: PPUSH
13223: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13224: LD_ADDR_VAR 0 3
13228: PUSH
13229: LD_EXP 32
13233: PUSH
13234: LD_EXP 46
13238: PUSH
13239: LD_EXP 34
13243: PUSH
13244: LD_EXP 47
13248: PUSH
13249: LD_EXP 48
13253: PUSH
13254: LD_EXP 37
13258: PUSH
13259: LD_EXP 38
13263: PUSH
13264: LD_EXP 36
13268: PUSH
13269: EMPTY
13270: LIST
13271: LIST
13272: LIST
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13279: LD_ADDR_VAR 0 2
13283: PUSH
13284: LD_INT 22
13286: PUSH
13287: LD_INT 7
13289: PUSH
13290: EMPTY
13291: LIST
13292: LIST
13293: PUSH
13294: LD_INT 23
13296: PUSH
13297: LD_INT 3
13299: PUSH
13300: EMPTY
13301: LIST
13302: LIST
13303: PUSH
13304: LD_INT 25
13306: PUSH
13307: LD_INT 4
13309: PUSH
13310: EMPTY
13311: LIST
13312: LIST
13313: PUSH
13314: LD_INT 26
13316: PUSH
13317: LD_INT 1
13319: PUSH
13320: EMPTY
13321: LIST
13322: LIST
13323: PUSH
13324: EMPTY
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: PPUSH
13330: CALL_OW 69
13334: PUSH
13335: LD_VAR 0 3
13339: DIFF
13340: ST_TO_ADDR
// if tmp then
13341: LD_VAR 0 2
13345: IFFALSE 13361
// result := tmp [ 1 ] ;
13347: LD_ADDR_VAR 0 1
13351: PUSH
13352: LD_VAR 0 2
13356: PUSH
13357: LD_INT 1
13359: ARRAY
13360: ST_TO_ADDR
// end ;
13361: LD_VAR 0 1
13365: RET
// export function SolRu ; var tmp , t ; begin
13366: LD_INT 0
13368: PPUSH
13369: PPUSH
13370: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13371: LD_ADDR_VAR 0 3
13375: PUSH
13376: LD_EXP 32
13380: PUSH
13381: LD_EXP 46
13385: PUSH
13386: LD_EXP 34
13390: PUSH
13391: LD_EXP 47
13395: PUSH
13396: LD_EXP 48
13400: PUSH
13401: LD_EXP 37
13405: PUSH
13406: LD_EXP 38
13410: PUSH
13411: LD_EXP 36
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: LIST
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13426: LD_ADDR_VAR 0 2
13430: PUSH
13431: LD_INT 22
13433: PUSH
13434: LD_INT 7
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: PUSH
13441: LD_INT 23
13443: PUSH
13444: LD_INT 3
13446: PUSH
13447: EMPTY
13448: LIST
13449: LIST
13450: PUSH
13451: LD_INT 25
13453: PUSH
13454: LD_INT 1
13456: PUSH
13457: EMPTY
13458: LIST
13459: LIST
13460: PUSH
13461: LD_INT 26
13463: PUSH
13464: LD_INT 1
13466: PUSH
13467: EMPTY
13468: LIST
13469: LIST
13470: PUSH
13471: EMPTY
13472: LIST
13473: LIST
13474: LIST
13475: LIST
13476: PPUSH
13477: CALL_OW 69
13481: PUSH
13482: LD_VAR 0 3
13486: DIFF
13487: ST_TO_ADDR
// if tmp then
13488: LD_VAR 0 2
13492: IFFALSE 13508
// result := tmp [ 1 ] ;
13494: LD_ADDR_VAR 0 1
13498: PUSH
13499: LD_VAR 0 2
13503: PUSH
13504: LD_INT 1
13506: ARRAY
13507: ST_TO_ADDR
// end ; end_of_file
13508: LD_VAR 0 1
13512: RET
// export function CustomEvent ( event ) ; begin
13513: LD_INT 0
13515: PPUSH
// end ;
13516: LD_VAR 0 2
13520: RET
// on UnitDestroyed ( un ) do var i , side ;
13521: LD_INT 0
13523: PPUSH
13524: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13525: LD_VAR 0 1
13529: PUSH
13530: LD_INT 22
13532: PUSH
13533: LD_INT 7
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: PUSH
13540: LD_INT 2
13542: PUSH
13543: LD_INT 25
13545: PUSH
13546: LD_INT 1
13548: PUSH
13549: EMPTY
13550: LIST
13551: LIST
13552: PUSH
13553: LD_INT 25
13555: PUSH
13556: LD_INT 2
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PUSH
13563: LD_INT 25
13565: PUSH
13566: LD_INT 3
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: PUSH
13573: LD_INT 25
13575: PUSH
13576: LD_INT 4
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 25
13585: PUSH
13586: LD_INT 5
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: LD_INT 25
13595: PUSH
13596: LD_INT 8
13598: PUSH
13599: EMPTY
13600: LIST
13601: LIST
13602: PUSH
13603: LD_INT 25
13605: PUSH
13606: LD_INT 9
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PUSH
13613: EMPTY
13614: LIST
13615: LIST
13616: LIST
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PPUSH
13627: CALL_OW 69
13631: IN
13632: IFFALSE 13648
// loss_counter := loss_counter + 1 ;
13634: LD_ADDR_EXP 13
13638: PUSH
13639: LD_EXP 13
13643: PUSH
13644: LD_INT 1
13646: PLUS
13647: ST_TO_ADDR
// if un = Abdul then
13648: LD_VAR 0 1
13652: PUSH
13653: LD_EXP 55
13657: EQUAL
13658: IFFALSE 13668
// abdul_escaped := false ;
13660: LD_ADDR_EXP 12
13664: PUSH
13665: LD_INT 0
13667: ST_TO_ADDR
// if un in ru_attackers then
13668: LD_VAR 0 1
13672: PUSH
13673: LD_EXP 52
13677: IN
13678: IFFALSE 13696
// ru_attackers := ru_attackers diff un ;
13680: LD_ADDR_EXP 52
13684: PUSH
13685: LD_EXP 52
13689: PUSH
13690: LD_VAR 0 1
13694: DIFF
13695: ST_TO_ADDR
// if un in ar_attackers then
13696: LD_VAR 0 1
13700: PUSH
13701: LD_EXP 10
13705: IN
13706: IFFALSE 13724
// ar_attackers := ar_attackers diff un ;
13708: LD_ADDR_EXP 10
13712: PUSH
13713: LD_EXP 10
13717: PUSH
13718: LD_VAR 0 1
13722: DIFF
13723: ST_TO_ADDR
// if un = JMM then
13724: LD_VAR 0 1
13728: PUSH
13729: LD_EXP 15
13733: EQUAL
13734: IFFALSE 13745
// begin YouLost ( JMM ) ;
13736: LD_STRING JMM
13738: PPUSH
13739: CALL_OW 104
// exit ;
13743: GO 13834
// end ; if un = Burlak then
13745: LD_VAR 0 1
13749: PUSH
13750: LD_EXP 46
13754: EQUAL
13755: IFFALSE 13766
// begin YouLost ( Burlak ) ;
13757: LD_STRING Burlak
13759: PPUSH
13760: CALL_OW 104
// exit ;
13764: GO 13834
// end ; if un = freedom then
13766: LD_VAR 0 1
13770: PUSH
13771: LD_EXP 3
13775: EQUAL
13776: IFFALSE 13787
// begin YouLost ( Destroyed ) ;
13778: LD_STRING Destroyed
13780: PPUSH
13781: CALL_OW 104
// exit ;
13785: GO 13834
// end ; if un = Masha then
13787: LD_VAR 0 1
13791: PUSH
13792: LD_EXP 49
13796: EQUAL
13797: IFFALSE 13806
// ChangeMissionObjectives ( M4b ) ;
13799: LD_STRING M4b
13801: PPUSH
13802: CALL_OW 337
// if un = Mastodont then
13806: LD_VAR 0 1
13810: PUSH
13811: LD_EXP 56
13815: EQUAL
13816: IFFALSE 13825
// ChangeMissionObjectives ( M4a ) ;
13818: LD_STRING M4a
13820: PPUSH
13821: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13825: LD_VAR 0 1
13829: PPUSH
13830: CALL 81852 0 1
// end ;
13834: PPOPN 3
13836: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13837: LD_VAR 0 1
13841: PPUSH
13842: LD_VAR 0 2
13846: PPUSH
13847: CALL 84186 0 2
// end ;
13851: PPOPN 2
13853: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13854: LD_VAR 0 1
13858: PPUSH
13859: CALL 83254 0 1
// end ;
13863: PPOPN 1
13865: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13866: LD_VAR 0 1
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 7
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PUSH
13881: LD_INT 30
13883: PUSH
13884: LD_INT 0
13886: PUSH
13887: EMPTY
13888: LIST
13889: LIST
13890: PUSH
13891: EMPTY
13892: LIST
13893: LIST
13894: PPUSH
13895: CALL_OW 69
13899: IN
13900: IFFALSE 13939
// begin SetBName ( building , freedom ) ;
13902: LD_VAR 0 1
13906: PPUSH
13907: LD_STRING freedom
13909: PPUSH
13910: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13914: LD_INT 0
13916: PPUSH
13917: LD_INT 7
13919: PPUSH
13920: LD_INT 0
13922: PPUSH
13923: CALL_OW 324
// freedom := building ;
13927: LD_ADDR_EXP 3
13931: PUSH
13932: LD_VAR 0 1
13936: ST_TO_ADDR
// exit ;
13937: GO 14005
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13939: LD_VAR 0 1
13943: PUSH
13944: LD_INT 22
13946: PUSH
13947: LD_INT 7
13949: PUSH
13950: EMPTY
13951: LIST
13952: LIST
13953: PUSH
13954: LD_INT 23
13956: PUSH
13957: LD_INT 3
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: PUSH
13964: LD_INT 30
13966: PUSH
13967: LD_INT 6
13969: PUSH
13970: EMPTY
13971: LIST
13972: LIST
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: LIST
13978: PPUSH
13979: CALL_OW 69
13983: IN
13984: IFFALSE 13996
// begin ru_lab_builded := true ;
13986: LD_ADDR_EXP 5
13990: PUSH
13991: LD_INT 1
13993: ST_TO_ADDR
// exit ;
13994: GO 14005
// end ; MCE_BuildingComplete ( building ) ;
13996: LD_VAR 0 1
14000: PPUSH
14001: CALL 83495 0 1
// end ;
14005: PPOPN 1
14007: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14008: LD_VAR 0 1
14012: PPUSH
14013: LD_VAR 0 2
14017: PPUSH
14018: CALL 81548 0 2
// end ;
14022: PPOPN 2
14024: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14025: LD_VAR 0 1
14029: PPUSH
14030: LD_VAR 0 2
14034: PPUSH
14035: LD_VAR 0 3
14039: PPUSH
14040: LD_VAR 0 4
14044: PPUSH
14045: LD_VAR 0 5
14049: PPUSH
14050: CALL 81168 0 5
// end ;
14054: PPOPN 5
14056: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14057: LD_VAR 0 1
14061: PPUSH
14062: LD_VAR 0 2
14066: PPUSH
14067: CALL 80749 0 2
// end ;
14071: PPOPN 2
14073: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14074: LD_VAR 0 1
14078: PPUSH
14079: CALL_OW 263
14083: PUSH
14084: LD_INT 3
14086: EQUAL
14087: PUSH
14088: LD_VAR 0 2
14092: PPUSH
14093: CALL_OW 263
14097: PUSH
14098: LD_INT 3
14100: EQUAL
14101: OR
14102: IFFALSE 14118
// hack_counter := hack_counter + 1 ;
14104: LD_ADDR_EXP 14
14108: PUSH
14109: LD_EXP 14
14113: PUSH
14114: LD_INT 1
14116: PLUS
14117: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14118: LD_VAR 0 1
14122: PPUSH
14123: LD_VAR 0 2
14127: PPUSH
14128: LD_VAR 0 3
14132: PPUSH
14133: LD_VAR 0 4
14137: PPUSH
14138: CALL 80587 0 4
// end ;
14142: PPOPN 4
14144: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14145: LD_VAR 0 1
14149: PPUSH
14150: LD_VAR 0 2
14154: PPUSH
14155: LD_VAR 0 3
14159: PPUSH
14160: CALL 80362 0 3
// end ;
14164: PPOPN 3
14166: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14167: LD_VAR 0 1
14171: PPUSH
14172: LD_VAR 0 2
14176: PPUSH
14177: CALL 80247 0 2
// end ;
14181: PPOPN 2
14183: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14184: LD_VAR 0 1
14188: PPUSH
14189: LD_VAR 0 2
14193: PPUSH
14194: CALL 84481 0 2
// end ;
14198: PPOPN 2
14200: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14201: LD_VAR 0 1
14205: PPUSH
14206: LD_VAR 0 2
14210: PPUSH
14211: LD_VAR 0 3
14215: PPUSH
14216: LD_VAR 0 4
14220: PPUSH
14221: CALL 84697 0 4
// end ;
14225: PPOPN 4
14227: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14228: LD_VAR 0 1
14232: PPUSH
14233: LD_VAR 0 2
14237: PPUSH
14238: CALL 80056 0 2
// end ;
14242: PPOPN 2
14244: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14245: LD_VAR 0 1
14249: PPUSH
14250: CALL 98284 0 1
// end ; end_of_file
14254: PPOPN 1
14256: END
// every 0 0$30 do var cr , time ;
14257: GO 14259
14259: DISABLE
14260: LD_INT 0
14262: PPUSH
14263: PPUSH
// begin time := 0 0$20 ;
14264: LD_ADDR_VAR 0 2
14268: PUSH
14269: LD_INT 700
14271: ST_TO_ADDR
// while game do
14272: LD_EXP 2
14276: IFFALSE 14379
// begin wait ( time ) ;
14278: LD_VAR 0 2
14282: PPUSH
14283: CALL_OW 67
// if tick > 2 2$00 then
14287: LD_OWVAR 1
14291: PUSH
14292: LD_INT 4200
14294: GREATER
14295: IFFALSE 14332
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14297: LD_ADDR_VAR 0 2
14301: PUSH
14302: LD_VAR 0 2
14306: PUSH
14307: LD_INT 140
14309: PUSH
14310: LD_INT 140
14312: PUSH
14313: LD_INT 210
14315: PUSH
14316: LD_INT 280
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: LIST
14323: LIST
14324: PUSH
14325: LD_OWVAR 67
14329: ARRAY
14330: PLUS
14331: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14332: LD_INT 1
14334: PPUSH
14335: LD_INT 5
14337: PPUSH
14338: CALL_OW 12
14342: PPUSH
14343: LD_INT 70
14345: PPUSH
14346: LD_INT 49
14348: PPUSH
14349: LD_INT 25
14351: PPUSH
14352: LD_INT 1
14354: PPUSH
14355: CALL_OW 56
// if time > 3 3$00 then
14359: LD_VAR 0 2
14363: PUSH
14364: LD_INT 6300
14366: GREATER
14367: IFFALSE 14377
// time := 0 0$30 ;
14369: LD_ADDR_VAR 0 2
14373: PUSH
14374: LD_INT 1050
14376: ST_TO_ADDR
// end ;
14377: GO 14272
// end ;
14379: PPOPN 2
14381: END
// every 0 0$30 do var cr , time ;
14382: GO 14384
14384: DISABLE
14385: LD_INT 0
14387: PPUSH
14388: PPUSH
// begin time := 0 0$20 ;
14389: LD_ADDR_VAR 0 2
14393: PUSH
14394: LD_INT 700
14396: ST_TO_ADDR
// while game do
14397: LD_EXP 2
14401: IFFALSE 14494
// begin wait ( time ) ;
14403: LD_VAR 0 2
14407: PPUSH
14408: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14412: LD_ADDR_VAR 0 2
14416: PUSH
14417: LD_VAR 0 2
14421: PUSH
14422: LD_INT 140
14424: PUSH
14425: LD_INT 175
14427: PUSH
14428: LD_INT 210
14430: PUSH
14431: LD_INT 280
14433: PUSH
14434: EMPTY
14435: LIST
14436: LIST
14437: LIST
14438: LIST
14439: PUSH
14440: LD_OWVAR 67
14444: ARRAY
14445: PLUS
14446: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14447: LD_INT 3
14449: PPUSH
14450: LD_INT 5
14452: PPUSH
14453: CALL_OW 12
14457: PPUSH
14458: LD_INT 26
14460: PPUSH
14461: LD_INT 9
14463: PPUSH
14464: LD_INT 30
14466: PPUSH
14467: LD_INT 1
14469: PPUSH
14470: CALL_OW 56
// if time > 3 3$00 then
14474: LD_VAR 0 2
14478: PUSH
14479: LD_INT 6300
14481: GREATER
14482: IFFALSE 14492
// time := 0 0$20 ;
14484: LD_ADDR_VAR 0 2
14488: PUSH
14489: LD_INT 700
14491: ST_TO_ADDR
// end ;
14492: GO 14397
// end ;
14494: PPOPN 2
14496: END
// every 0 0$30 do var cr , time ;
14497: GO 14499
14499: DISABLE
14500: LD_INT 0
14502: PPUSH
14503: PPUSH
// begin time := 0 0$20 ;
14504: LD_ADDR_VAR 0 2
14508: PUSH
14509: LD_INT 700
14511: ST_TO_ADDR
// while game do
14512: LD_EXP 2
14516: IFFALSE 14645
// begin wait ( time ) ;
14518: LD_VAR 0 2
14522: PPUSH
14523: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14527: LD_ADDR_VAR 0 2
14531: PUSH
14532: LD_VAR 0 2
14536: PUSH
14537: LD_INT 175
14539: PUSH
14540: LD_INT 210
14542: PUSH
14543: LD_INT 280
14545: PUSH
14546: LD_INT 350
14548: PUSH
14549: EMPTY
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: PUSH
14555: LD_OWVAR 67
14559: ARRAY
14560: PLUS
14561: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14562: LD_INT 1
14564: PPUSH
14565: LD_INT 5
14567: PPUSH
14568: CALL_OW 12
14572: PPUSH
14573: LD_INT 179
14575: PPUSH
14576: LD_INT 101
14578: PPUSH
14579: LD_INT 20
14581: PPUSH
14582: LD_INT 1
14584: PPUSH
14585: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14589: LD_INT 350
14591: PPUSH
14592: LD_INT 525
14594: PPUSH
14595: CALL_OW 12
14599: PPUSH
14600: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14604: LD_INT 1
14606: PPUSH
14607: LD_INT 5
14609: PPUSH
14610: CALL_OW 12
14614: PPUSH
14615: LD_INT 9
14617: PPUSH
14618: LD_INT 1
14620: PPUSH
14621: CALL_OW 55
// if time > 4 4$00 then
14625: LD_VAR 0 2
14629: PUSH
14630: LD_INT 8400
14632: GREATER
14633: IFFALSE 14643
// time := 0 0$30 ;
14635: LD_ADDR_VAR 0 2
14639: PUSH
14640: LD_INT 1050
14642: ST_TO_ADDR
// end ;
14643: GO 14512
// end ;
14645: PPOPN 2
14647: END
// every 0 0$30 do var cr , time ;
14648: GO 14650
14650: DISABLE
14651: LD_INT 0
14653: PPUSH
14654: PPUSH
// begin time := 0 0$10 ;
14655: LD_ADDR_VAR 0 2
14659: PUSH
14660: LD_INT 350
14662: ST_TO_ADDR
// while game do
14663: LD_EXP 2
14667: IFFALSE 14801
// begin wait ( time ) ;
14669: LD_VAR 0 2
14673: PPUSH
14674: CALL_OW 67
// time := time + 0 0$10 ;
14678: LD_ADDR_VAR 0 2
14682: PUSH
14683: LD_VAR 0 2
14687: PUSH
14688: LD_INT 350
14690: PLUS
14691: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14692: LD_INT 1
14694: PPUSH
14695: LD_INT 5
14697: PPUSH
14698: CALL_OW 12
14702: PPUSH
14703: LD_INT 11
14705: PPUSH
14706: LD_INT 1
14708: PPUSH
14709: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14713: LD_ADDR_VAR 0 1
14717: PUSH
14718: LD_INT 1
14720: PPUSH
14721: LD_INT 3
14723: PPUSH
14724: CALL_OW 12
14728: ST_TO_ADDR
// if cr = 1 then
14729: LD_VAR 0 1
14733: PUSH
14734: LD_INT 1
14736: EQUAL
14737: IFFALSE 14781
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14739: LD_INT 700
14741: PPUSH
14742: LD_INT 1575
14744: PPUSH
14745: CALL_OW 12
14749: PPUSH
14750: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14754: LD_INT 1
14756: PPUSH
14757: LD_INT 5
14759: PPUSH
14760: CALL_OW 12
14764: PPUSH
14765: LD_INT 34
14767: PPUSH
14768: LD_INT 50
14770: PPUSH
14771: LD_INT 7
14773: PPUSH
14774: LD_INT 1
14776: PPUSH
14777: CALL_OW 56
// end ; if time > 4 4$00 then
14781: LD_VAR 0 2
14785: PUSH
14786: LD_INT 8400
14788: GREATER
14789: IFFALSE 14799
// time := 0 0$40 ;
14791: LD_ADDR_VAR 0 2
14795: PUSH
14796: LD_INT 1400
14798: ST_TO_ADDR
// end ;
14799: GO 14663
// end ; end_of_file
14801: PPOPN 2
14803: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14804: LD_INT 0
14806: PPUSH
14807: PPUSH
// if exist_mode then
14808: LD_VAR 0 2
14812: IFFALSE 14837
// unit := CreateCharacter ( prefix & ident ) else
14814: LD_ADDR_VAR 0 5
14818: PUSH
14819: LD_VAR 0 3
14823: PUSH
14824: LD_VAR 0 1
14828: STR
14829: PPUSH
14830: CALL_OW 34
14834: ST_TO_ADDR
14835: GO 14852
// unit := NewCharacter ( ident ) ;
14837: LD_ADDR_VAR 0 5
14841: PUSH
14842: LD_VAR 0 1
14846: PPUSH
14847: CALL_OW 25
14851: ST_TO_ADDR
// result := unit ;
14852: LD_ADDR_VAR 0 4
14856: PUSH
14857: LD_VAR 0 5
14861: ST_TO_ADDR
// end ;
14862: LD_VAR 0 4
14866: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14867: LD_INT 0
14869: PPUSH
14870: PPUSH
// if not side or not nation then
14871: LD_VAR 0 1
14875: NOT
14876: PUSH
14877: LD_VAR 0 2
14881: NOT
14882: OR
14883: IFFALSE 14887
// exit ;
14885: GO 15655
// case nation of nation_american :
14887: LD_VAR 0 2
14891: PUSH
14892: LD_INT 1
14894: DOUBLE
14895: EQUAL
14896: IFTRUE 14900
14898: GO 15114
14900: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14901: LD_ADDR_VAR 0 4
14905: PUSH
14906: LD_INT 35
14908: PUSH
14909: LD_INT 45
14911: PUSH
14912: LD_INT 46
14914: PUSH
14915: LD_INT 47
14917: PUSH
14918: LD_INT 82
14920: PUSH
14921: LD_INT 83
14923: PUSH
14924: LD_INT 84
14926: PUSH
14927: LD_INT 85
14929: PUSH
14930: LD_INT 86
14932: PUSH
14933: LD_INT 1
14935: PUSH
14936: LD_INT 2
14938: PUSH
14939: LD_INT 6
14941: PUSH
14942: LD_INT 15
14944: PUSH
14945: LD_INT 16
14947: PUSH
14948: LD_INT 7
14950: PUSH
14951: LD_INT 12
14953: PUSH
14954: LD_INT 13
14956: PUSH
14957: LD_INT 10
14959: PUSH
14960: LD_INT 14
14962: PUSH
14963: LD_INT 20
14965: PUSH
14966: LD_INT 21
14968: PUSH
14969: LD_INT 22
14971: PUSH
14972: LD_INT 25
14974: PUSH
14975: LD_INT 32
14977: PUSH
14978: LD_INT 27
14980: PUSH
14981: LD_INT 36
14983: PUSH
14984: LD_INT 69
14986: PUSH
14987: LD_INT 39
14989: PUSH
14990: LD_INT 34
14992: PUSH
14993: LD_INT 40
14995: PUSH
14996: LD_INT 48
14998: PUSH
14999: LD_INT 49
15001: PUSH
15002: LD_INT 50
15004: PUSH
15005: LD_INT 51
15007: PUSH
15008: LD_INT 52
15010: PUSH
15011: LD_INT 53
15013: PUSH
15014: LD_INT 54
15016: PUSH
15017: LD_INT 55
15019: PUSH
15020: LD_INT 56
15022: PUSH
15023: LD_INT 57
15025: PUSH
15026: LD_INT 58
15028: PUSH
15029: LD_INT 59
15031: PUSH
15032: LD_INT 60
15034: PUSH
15035: LD_INT 61
15037: PUSH
15038: LD_INT 62
15040: PUSH
15041: LD_INT 80
15043: PUSH
15044: LD_INT 82
15046: PUSH
15047: LD_INT 83
15049: PUSH
15050: LD_INT 84
15052: PUSH
15053: LD_INT 85
15055: PUSH
15056: LD_INT 86
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: LIST
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: LIST
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: ST_TO_ADDR
15112: GO 15579
15114: LD_INT 2
15116: DOUBLE
15117: EQUAL
15118: IFTRUE 15122
15120: GO 15348
15122: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15123: LD_ADDR_VAR 0 4
15127: PUSH
15128: LD_INT 35
15130: PUSH
15131: LD_INT 45
15133: PUSH
15134: LD_INT 46
15136: PUSH
15137: LD_INT 47
15139: PUSH
15140: LD_INT 82
15142: PUSH
15143: LD_INT 83
15145: PUSH
15146: LD_INT 84
15148: PUSH
15149: LD_INT 85
15151: PUSH
15152: LD_INT 87
15154: PUSH
15155: LD_INT 70
15157: PUSH
15158: LD_INT 1
15160: PUSH
15161: LD_INT 11
15163: PUSH
15164: LD_INT 3
15166: PUSH
15167: LD_INT 4
15169: PUSH
15170: LD_INT 5
15172: PUSH
15173: LD_INT 6
15175: PUSH
15176: LD_INT 15
15178: PUSH
15179: LD_INT 18
15181: PUSH
15182: LD_INT 7
15184: PUSH
15185: LD_INT 17
15187: PUSH
15188: LD_INT 8
15190: PUSH
15191: LD_INT 20
15193: PUSH
15194: LD_INT 21
15196: PUSH
15197: LD_INT 22
15199: PUSH
15200: LD_INT 72
15202: PUSH
15203: LD_INT 26
15205: PUSH
15206: LD_INT 69
15208: PUSH
15209: LD_INT 39
15211: PUSH
15212: LD_INT 40
15214: PUSH
15215: LD_INT 41
15217: PUSH
15218: LD_INT 42
15220: PUSH
15221: LD_INT 43
15223: PUSH
15224: LD_INT 48
15226: PUSH
15227: LD_INT 49
15229: PUSH
15230: LD_INT 50
15232: PUSH
15233: LD_INT 51
15235: PUSH
15236: LD_INT 52
15238: PUSH
15239: LD_INT 53
15241: PUSH
15242: LD_INT 54
15244: PUSH
15245: LD_INT 55
15247: PUSH
15248: LD_INT 56
15250: PUSH
15251: LD_INT 60
15253: PUSH
15254: LD_INT 61
15256: PUSH
15257: LD_INT 62
15259: PUSH
15260: LD_INT 66
15262: PUSH
15263: LD_INT 67
15265: PUSH
15266: LD_INT 68
15268: PUSH
15269: LD_INT 81
15271: PUSH
15272: LD_INT 82
15274: PUSH
15275: LD_INT 83
15277: PUSH
15278: LD_INT 84
15280: PUSH
15281: LD_INT 85
15283: PUSH
15284: LD_INT 87
15286: PUSH
15287: LD_INT 88
15289: PUSH
15290: EMPTY
15291: LIST
15292: LIST
15293: LIST
15294: LIST
15295: LIST
15296: LIST
15297: LIST
15298: LIST
15299: LIST
15300: LIST
15301: LIST
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: LIST
15317: LIST
15318: LIST
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: ST_TO_ADDR
15346: GO 15579
15348: LD_INT 3
15350: DOUBLE
15351: EQUAL
15352: IFTRUE 15356
15354: GO 15578
15356: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15357: LD_ADDR_VAR 0 4
15361: PUSH
15362: LD_INT 46
15364: PUSH
15365: LD_INT 47
15367: PUSH
15368: LD_INT 1
15370: PUSH
15371: LD_INT 2
15373: PUSH
15374: LD_INT 82
15376: PUSH
15377: LD_INT 83
15379: PUSH
15380: LD_INT 84
15382: PUSH
15383: LD_INT 85
15385: PUSH
15386: LD_INT 86
15388: PUSH
15389: LD_INT 11
15391: PUSH
15392: LD_INT 9
15394: PUSH
15395: LD_INT 20
15397: PUSH
15398: LD_INT 19
15400: PUSH
15401: LD_INT 21
15403: PUSH
15404: LD_INT 24
15406: PUSH
15407: LD_INT 22
15409: PUSH
15410: LD_INT 25
15412: PUSH
15413: LD_INT 28
15415: PUSH
15416: LD_INT 29
15418: PUSH
15419: LD_INT 30
15421: PUSH
15422: LD_INT 31
15424: PUSH
15425: LD_INT 37
15427: PUSH
15428: LD_INT 38
15430: PUSH
15431: LD_INT 32
15433: PUSH
15434: LD_INT 27
15436: PUSH
15437: LD_INT 33
15439: PUSH
15440: LD_INT 69
15442: PUSH
15443: LD_INT 39
15445: PUSH
15446: LD_INT 34
15448: PUSH
15449: LD_INT 40
15451: PUSH
15452: LD_INT 71
15454: PUSH
15455: LD_INT 23
15457: PUSH
15458: LD_INT 44
15460: PUSH
15461: LD_INT 48
15463: PUSH
15464: LD_INT 49
15466: PUSH
15467: LD_INT 50
15469: PUSH
15470: LD_INT 51
15472: PUSH
15473: LD_INT 52
15475: PUSH
15476: LD_INT 53
15478: PUSH
15479: LD_INT 54
15481: PUSH
15482: LD_INT 55
15484: PUSH
15485: LD_INT 56
15487: PUSH
15488: LD_INT 57
15490: PUSH
15491: LD_INT 58
15493: PUSH
15494: LD_INT 59
15496: PUSH
15497: LD_INT 63
15499: PUSH
15500: LD_INT 64
15502: PUSH
15503: LD_INT 65
15505: PUSH
15506: LD_INT 82
15508: PUSH
15509: LD_INT 83
15511: PUSH
15512: LD_INT 84
15514: PUSH
15515: LD_INT 85
15517: PUSH
15518: LD_INT 86
15520: PUSH
15521: EMPTY
15522: LIST
15523: LIST
15524: LIST
15525: LIST
15526: LIST
15527: LIST
15528: LIST
15529: LIST
15530: LIST
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: LIST
15544: LIST
15545: LIST
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: LIST
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: ST_TO_ADDR
15576: GO 15579
15578: POP
// if state > - 1 and state < 3 then
15579: LD_VAR 0 3
15583: PUSH
15584: LD_INT 1
15586: NEG
15587: GREATER
15588: PUSH
15589: LD_VAR 0 3
15593: PUSH
15594: LD_INT 3
15596: LESS
15597: AND
15598: IFFALSE 15655
// for i in result do
15600: LD_ADDR_VAR 0 5
15604: PUSH
15605: LD_VAR 0 4
15609: PUSH
15610: FOR_IN
15611: IFFALSE 15653
// if GetTech ( i , side ) <> state then
15613: LD_VAR 0 5
15617: PPUSH
15618: LD_VAR 0 1
15622: PPUSH
15623: CALL_OW 321
15627: PUSH
15628: LD_VAR 0 3
15632: NONEQUAL
15633: IFFALSE 15651
// result := result diff i ;
15635: LD_ADDR_VAR 0 4
15639: PUSH
15640: LD_VAR 0 4
15644: PUSH
15645: LD_VAR 0 5
15649: DIFF
15650: ST_TO_ADDR
15651: GO 15610
15653: POP
15654: POP
// end ;
15655: LD_VAR 0 4
15659: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15660: LD_INT 0
15662: PPUSH
15663: PPUSH
15664: PPUSH
// result := true ;
15665: LD_ADDR_VAR 0 3
15669: PUSH
15670: LD_INT 1
15672: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15673: LD_ADDR_VAR 0 5
15677: PUSH
15678: LD_VAR 0 2
15682: PPUSH
15683: CALL_OW 480
15687: ST_TO_ADDR
// if not tmp then
15688: LD_VAR 0 5
15692: NOT
15693: IFFALSE 15697
// exit ;
15695: GO 15746
// for i in tmp do
15697: LD_ADDR_VAR 0 4
15701: PUSH
15702: LD_VAR 0 5
15706: PUSH
15707: FOR_IN
15708: IFFALSE 15744
// if GetTech ( i , side ) <> state_researched then
15710: LD_VAR 0 4
15714: PPUSH
15715: LD_VAR 0 1
15719: PPUSH
15720: CALL_OW 321
15724: PUSH
15725: LD_INT 2
15727: NONEQUAL
15728: IFFALSE 15742
// begin result := false ;
15730: LD_ADDR_VAR 0 3
15734: PUSH
15735: LD_INT 0
15737: ST_TO_ADDR
// exit ;
15738: POP
15739: POP
15740: GO 15746
// end ;
15742: GO 15707
15744: POP
15745: POP
// end ;
15746: LD_VAR 0 3
15750: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15751: LD_INT 0
15753: PPUSH
15754: PPUSH
15755: PPUSH
15756: PPUSH
15757: PPUSH
15758: PPUSH
15759: PPUSH
15760: PPUSH
15761: PPUSH
15762: PPUSH
15763: PPUSH
15764: PPUSH
15765: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15766: LD_VAR 0 1
15770: NOT
15771: PUSH
15772: LD_VAR 0 1
15776: PPUSH
15777: CALL_OW 257
15781: PUSH
15782: LD_INT 9
15784: NONEQUAL
15785: OR
15786: IFFALSE 15790
// exit ;
15788: GO 16363
// side := GetSide ( unit ) ;
15790: LD_ADDR_VAR 0 9
15794: PUSH
15795: LD_VAR 0 1
15799: PPUSH
15800: CALL_OW 255
15804: ST_TO_ADDR
// tech_space := tech_spacanom ;
15805: LD_ADDR_VAR 0 12
15809: PUSH
15810: LD_INT 29
15812: ST_TO_ADDR
// tech_time := tech_taurad ;
15813: LD_ADDR_VAR 0 13
15817: PUSH
15818: LD_INT 28
15820: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15821: LD_ADDR_VAR 0 11
15825: PUSH
15826: LD_VAR 0 1
15830: PPUSH
15831: CALL_OW 310
15835: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15836: LD_VAR 0 11
15840: PPUSH
15841: CALL_OW 247
15845: PUSH
15846: LD_INT 2
15848: EQUAL
15849: IFFALSE 15853
// exit ;
15851: GO 16363
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15853: LD_ADDR_VAR 0 8
15857: PUSH
15858: LD_INT 81
15860: PUSH
15861: LD_VAR 0 9
15865: PUSH
15866: EMPTY
15867: LIST
15868: LIST
15869: PUSH
15870: LD_INT 3
15872: PUSH
15873: LD_INT 21
15875: PUSH
15876: LD_INT 3
15878: PUSH
15879: EMPTY
15880: LIST
15881: LIST
15882: PUSH
15883: EMPTY
15884: LIST
15885: LIST
15886: PUSH
15887: EMPTY
15888: LIST
15889: LIST
15890: PPUSH
15891: CALL_OW 69
15895: ST_TO_ADDR
// if not tmp then
15896: LD_VAR 0 8
15900: NOT
15901: IFFALSE 15905
// exit ;
15903: GO 16363
// if in_unit then
15905: LD_VAR 0 11
15909: IFFALSE 15933
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15911: LD_ADDR_VAR 0 10
15915: PUSH
15916: LD_VAR 0 8
15920: PPUSH
15921: LD_VAR 0 11
15925: PPUSH
15926: CALL_OW 74
15930: ST_TO_ADDR
15931: GO 15953
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15933: LD_ADDR_VAR 0 10
15937: PUSH
15938: LD_VAR 0 8
15942: PPUSH
15943: LD_VAR 0 1
15947: PPUSH
15948: CALL_OW 74
15952: ST_TO_ADDR
// if not enemy then
15953: LD_VAR 0 10
15957: NOT
15958: IFFALSE 15962
// exit ;
15960: GO 16363
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15962: LD_VAR 0 11
15966: PUSH
15967: LD_VAR 0 11
15971: PPUSH
15972: LD_VAR 0 10
15976: PPUSH
15977: CALL_OW 296
15981: PUSH
15982: LD_INT 13
15984: GREATER
15985: AND
15986: PUSH
15987: LD_VAR 0 1
15991: PPUSH
15992: LD_VAR 0 10
15996: PPUSH
15997: CALL_OW 296
16001: PUSH
16002: LD_INT 12
16004: GREATER
16005: OR
16006: IFFALSE 16010
// exit ;
16008: GO 16363
// missile := [ 1 ] ;
16010: LD_ADDR_VAR 0 14
16014: PUSH
16015: LD_INT 1
16017: PUSH
16018: EMPTY
16019: LIST
16020: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16021: LD_VAR 0 9
16025: PPUSH
16026: LD_VAR 0 12
16030: PPUSH
16031: CALL_OW 325
16035: IFFALSE 16064
// missile := Insert ( missile , missile + 1 , 2 ) ;
16037: LD_ADDR_VAR 0 14
16041: PUSH
16042: LD_VAR 0 14
16046: PPUSH
16047: LD_VAR 0 14
16051: PUSH
16052: LD_INT 1
16054: PLUS
16055: PPUSH
16056: LD_INT 2
16058: PPUSH
16059: CALL_OW 2
16063: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16064: LD_VAR 0 9
16068: PPUSH
16069: LD_VAR 0 13
16073: PPUSH
16074: CALL_OW 325
16078: PUSH
16079: LD_VAR 0 10
16083: PPUSH
16084: CALL_OW 255
16088: PPUSH
16089: LD_VAR 0 13
16093: PPUSH
16094: CALL_OW 325
16098: NOT
16099: AND
16100: IFFALSE 16129
// missile := Insert ( missile , missile + 1 , 3 ) ;
16102: LD_ADDR_VAR 0 14
16106: PUSH
16107: LD_VAR 0 14
16111: PPUSH
16112: LD_VAR 0 14
16116: PUSH
16117: LD_INT 1
16119: PLUS
16120: PPUSH
16121: LD_INT 3
16123: PPUSH
16124: CALL_OW 2
16128: ST_TO_ADDR
// if missile < 2 then
16129: LD_VAR 0 14
16133: PUSH
16134: LD_INT 2
16136: LESS
16137: IFFALSE 16141
// exit ;
16139: GO 16363
// x := GetX ( enemy ) ;
16141: LD_ADDR_VAR 0 4
16145: PUSH
16146: LD_VAR 0 10
16150: PPUSH
16151: CALL_OW 250
16155: ST_TO_ADDR
// y := GetY ( enemy ) ;
16156: LD_ADDR_VAR 0 5
16160: PUSH
16161: LD_VAR 0 10
16165: PPUSH
16166: CALL_OW 251
16170: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16171: LD_ADDR_VAR 0 6
16175: PUSH
16176: LD_VAR 0 4
16180: PUSH
16181: LD_INT 1
16183: NEG
16184: PPUSH
16185: LD_INT 1
16187: PPUSH
16188: CALL_OW 12
16192: PLUS
16193: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16194: LD_ADDR_VAR 0 7
16198: PUSH
16199: LD_VAR 0 5
16203: PUSH
16204: LD_INT 1
16206: NEG
16207: PPUSH
16208: LD_INT 1
16210: PPUSH
16211: CALL_OW 12
16215: PLUS
16216: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16217: LD_VAR 0 6
16221: PPUSH
16222: LD_VAR 0 7
16226: PPUSH
16227: CALL_OW 488
16231: NOT
16232: IFFALSE 16254
// begin _x := x ;
16234: LD_ADDR_VAR 0 6
16238: PUSH
16239: LD_VAR 0 4
16243: ST_TO_ADDR
// _y := y ;
16244: LD_ADDR_VAR 0 7
16248: PUSH
16249: LD_VAR 0 5
16253: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16254: LD_ADDR_VAR 0 3
16258: PUSH
16259: LD_INT 1
16261: PPUSH
16262: LD_VAR 0 14
16266: PPUSH
16267: CALL_OW 12
16271: ST_TO_ADDR
// case i of 1 :
16272: LD_VAR 0 3
16276: PUSH
16277: LD_INT 1
16279: DOUBLE
16280: EQUAL
16281: IFTRUE 16285
16283: GO 16302
16285: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16286: LD_VAR 0 1
16290: PPUSH
16291: LD_VAR 0 10
16295: PPUSH
16296: CALL_OW 115
16300: GO 16363
16302: LD_INT 2
16304: DOUBLE
16305: EQUAL
16306: IFTRUE 16310
16308: GO 16332
16310: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16311: LD_VAR 0 1
16315: PPUSH
16316: LD_VAR 0 6
16320: PPUSH
16321: LD_VAR 0 7
16325: PPUSH
16326: CALL_OW 153
16330: GO 16363
16332: LD_INT 3
16334: DOUBLE
16335: EQUAL
16336: IFTRUE 16340
16338: GO 16362
16340: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16341: LD_VAR 0 1
16345: PPUSH
16346: LD_VAR 0 6
16350: PPUSH
16351: LD_VAR 0 7
16355: PPUSH
16356: CALL_OW 154
16360: GO 16363
16362: POP
// end ;
16363: LD_VAR 0 2
16367: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16368: LD_INT 0
16370: PPUSH
16371: PPUSH
16372: PPUSH
16373: PPUSH
16374: PPUSH
16375: PPUSH
// if not unit or not building then
16376: LD_VAR 0 1
16380: NOT
16381: PUSH
16382: LD_VAR 0 2
16386: NOT
16387: OR
16388: IFFALSE 16392
// exit ;
16390: GO 16550
// x := GetX ( building ) ;
16392: LD_ADDR_VAR 0 5
16396: PUSH
16397: LD_VAR 0 2
16401: PPUSH
16402: CALL_OW 250
16406: ST_TO_ADDR
// y := GetY ( building ) ;
16407: LD_ADDR_VAR 0 6
16411: PUSH
16412: LD_VAR 0 2
16416: PPUSH
16417: CALL_OW 251
16421: ST_TO_ADDR
// for i = 0 to 5 do
16422: LD_ADDR_VAR 0 4
16426: PUSH
16427: DOUBLE
16428: LD_INT 0
16430: DEC
16431: ST_TO_ADDR
16432: LD_INT 5
16434: PUSH
16435: FOR_TO
16436: IFFALSE 16548
// begin _x := ShiftX ( x , i , 3 ) ;
16438: LD_ADDR_VAR 0 7
16442: PUSH
16443: LD_VAR 0 5
16447: PPUSH
16448: LD_VAR 0 4
16452: PPUSH
16453: LD_INT 3
16455: PPUSH
16456: CALL_OW 272
16460: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16461: LD_ADDR_VAR 0 8
16465: PUSH
16466: LD_VAR 0 6
16470: PPUSH
16471: LD_VAR 0 4
16475: PPUSH
16476: LD_INT 3
16478: PPUSH
16479: CALL_OW 273
16483: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16484: LD_VAR 0 7
16488: PPUSH
16489: LD_VAR 0 8
16493: PPUSH
16494: CALL_OW 488
16498: NOT
16499: IFFALSE 16503
// continue ;
16501: GO 16435
// if HexInfo ( _x , _y ) = 0 then
16503: LD_VAR 0 7
16507: PPUSH
16508: LD_VAR 0 8
16512: PPUSH
16513: CALL_OW 428
16517: PUSH
16518: LD_INT 0
16520: EQUAL
16521: IFFALSE 16546
// begin ComMoveXY ( unit , _x , _y ) ;
16523: LD_VAR 0 1
16527: PPUSH
16528: LD_VAR 0 7
16532: PPUSH
16533: LD_VAR 0 8
16537: PPUSH
16538: CALL_OW 111
// exit ;
16542: POP
16543: POP
16544: GO 16550
// end ; end ;
16546: GO 16435
16548: POP
16549: POP
// end ;
16550: LD_VAR 0 3
16554: RET
// export function ScanBase ( side , base_area ) ; begin
16555: LD_INT 0
16557: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16558: LD_ADDR_VAR 0 3
16562: PUSH
16563: LD_VAR 0 2
16567: PPUSH
16568: LD_INT 81
16570: PUSH
16571: LD_VAR 0 1
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PPUSH
16580: CALL_OW 70
16584: ST_TO_ADDR
// end ;
16585: LD_VAR 0 3
16589: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16590: LD_INT 0
16592: PPUSH
16593: PPUSH
16594: PPUSH
16595: PPUSH
// result := false ;
16596: LD_ADDR_VAR 0 2
16600: PUSH
16601: LD_INT 0
16603: ST_TO_ADDR
// side := GetSide ( unit ) ;
16604: LD_ADDR_VAR 0 3
16608: PUSH
16609: LD_VAR 0 1
16613: PPUSH
16614: CALL_OW 255
16618: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16619: LD_ADDR_VAR 0 4
16623: PUSH
16624: LD_VAR 0 1
16628: PPUSH
16629: CALL_OW 248
16633: ST_TO_ADDR
// case nat of 1 :
16634: LD_VAR 0 4
16638: PUSH
16639: LD_INT 1
16641: DOUBLE
16642: EQUAL
16643: IFTRUE 16647
16645: GO 16658
16647: POP
// tech := tech_lassight ; 2 :
16648: LD_ADDR_VAR 0 5
16652: PUSH
16653: LD_INT 12
16655: ST_TO_ADDR
16656: GO 16697
16658: LD_INT 2
16660: DOUBLE
16661: EQUAL
16662: IFTRUE 16666
16664: GO 16677
16666: POP
// tech := tech_mortar ; 3 :
16667: LD_ADDR_VAR 0 5
16671: PUSH
16672: LD_INT 41
16674: ST_TO_ADDR
16675: GO 16697
16677: LD_INT 3
16679: DOUBLE
16680: EQUAL
16681: IFTRUE 16685
16683: GO 16696
16685: POP
// tech := tech_bazooka ; end ;
16686: LD_ADDR_VAR 0 5
16690: PUSH
16691: LD_INT 44
16693: ST_TO_ADDR
16694: GO 16697
16696: POP
// if Researched ( side , tech ) then
16697: LD_VAR 0 3
16701: PPUSH
16702: LD_VAR 0 5
16706: PPUSH
16707: CALL_OW 325
16711: IFFALSE 16738
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16713: LD_ADDR_VAR 0 2
16717: PUSH
16718: LD_INT 5
16720: PUSH
16721: LD_INT 8
16723: PUSH
16724: LD_INT 9
16726: PUSH
16727: EMPTY
16728: LIST
16729: LIST
16730: LIST
16731: PUSH
16732: LD_VAR 0 4
16736: ARRAY
16737: ST_TO_ADDR
// end ;
16738: LD_VAR 0 2
16742: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16743: LD_INT 0
16745: PPUSH
16746: PPUSH
16747: PPUSH
// if not mines then
16748: LD_VAR 0 2
16752: NOT
16753: IFFALSE 16757
// exit ;
16755: GO 16901
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16757: LD_ADDR_VAR 0 5
16761: PUSH
16762: LD_INT 81
16764: PUSH
16765: LD_VAR 0 1
16769: PUSH
16770: EMPTY
16771: LIST
16772: LIST
16773: PUSH
16774: LD_INT 3
16776: PUSH
16777: LD_INT 21
16779: PUSH
16780: LD_INT 3
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PPUSH
16795: CALL_OW 69
16799: ST_TO_ADDR
// for i in mines do
16800: LD_ADDR_VAR 0 4
16804: PUSH
16805: LD_VAR 0 2
16809: PUSH
16810: FOR_IN
16811: IFFALSE 16899
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16813: LD_VAR 0 4
16817: PUSH
16818: LD_INT 1
16820: ARRAY
16821: PPUSH
16822: LD_VAR 0 4
16826: PUSH
16827: LD_INT 2
16829: ARRAY
16830: PPUSH
16831: CALL_OW 458
16835: NOT
16836: IFFALSE 16840
// continue ;
16838: GO 16810
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16840: LD_VAR 0 4
16844: PUSH
16845: LD_INT 1
16847: ARRAY
16848: PPUSH
16849: LD_VAR 0 4
16853: PUSH
16854: LD_INT 2
16856: ARRAY
16857: PPUSH
16858: CALL_OW 428
16862: PUSH
16863: LD_VAR 0 5
16867: IN
16868: IFFALSE 16897
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16870: LD_VAR 0 4
16874: PUSH
16875: LD_INT 1
16877: ARRAY
16878: PPUSH
16879: LD_VAR 0 4
16883: PUSH
16884: LD_INT 2
16886: ARRAY
16887: PPUSH
16888: LD_VAR 0 1
16892: PPUSH
16893: CALL_OW 456
// end ;
16897: GO 16810
16899: POP
16900: POP
// end ;
16901: LD_VAR 0 3
16905: RET
// export function Count ( array ) ; var i ; begin
16906: LD_INT 0
16908: PPUSH
16909: PPUSH
// result := 0 ;
16910: LD_ADDR_VAR 0 2
16914: PUSH
16915: LD_INT 0
16917: ST_TO_ADDR
// for i in array do
16918: LD_ADDR_VAR 0 3
16922: PUSH
16923: LD_VAR 0 1
16927: PUSH
16928: FOR_IN
16929: IFFALSE 16953
// if i then
16931: LD_VAR 0 3
16935: IFFALSE 16951
// result := result + 1 ;
16937: LD_ADDR_VAR 0 2
16941: PUSH
16942: LD_VAR 0 2
16946: PUSH
16947: LD_INT 1
16949: PLUS
16950: ST_TO_ADDR
16951: GO 16928
16953: POP
16954: POP
// end ;
16955: LD_VAR 0 2
16959: RET
// export function IsEmpty ( building ) ; begin
16960: LD_INT 0
16962: PPUSH
// if not building then
16963: LD_VAR 0 1
16967: NOT
16968: IFFALSE 16972
// exit ;
16970: GO 17015
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16972: LD_ADDR_VAR 0 2
16976: PUSH
16977: LD_VAR 0 1
16981: PUSH
16982: LD_INT 22
16984: PUSH
16985: LD_VAR 0 1
16989: PPUSH
16990: CALL_OW 255
16994: PUSH
16995: EMPTY
16996: LIST
16997: LIST
16998: PUSH
16999: LD_INT 58
17001: PUSH
17002: EMPTY
17003: LIST
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: PPUSH
17009: CALL_OW 69
17013: IN
17014: ST_TO_ADDR
// end ;
17015: LD_VAR 0 2
17019: RET
// export function IsNotFull ( building ) ; begin
17020: LD_INT 0
17022: PPUSH
// if not building then
17023: LD_VAR 0 1
17027: NOT
17028: IFFALSE 17032
// exit ;
17030: GO 17051
// result := UnitsInside ( building ) < 6 ;
17032: LD_ADDR_VAR 0 2
17036: PUSH
17037: LD_VAR 0 1
17041: PPUSH
17042: CALL_OW 313
17046: PUSH
17047: LD_INT 6
17049: LESS
17050: ST_TO_ADDR
// end ;
17051: LD_VAR 0 2
17055: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17056: LD_INT 0
17058: PPUSH
17059: PPUSH
17060: PPUSH
17061: PPUSH
// tmp := [ ] ;
17062: LD_ADDR_VAR 0 3
17066: PUSH
17067: EMPTY
17068: ST_TO_ADDR
// list := [ ] ;
17069: LD_ADDR_VAR 0 5
17073: PUSH
17074: EMPTY
17075: ST_TO_ADDR
// for i = 16 to 25 do
17076: LD_ADDR_VAR 0 4
17080: PUSH
17081: DOUBLE
17082: LD_INT 16
17084: DEC
17085: ST_TO_ADDR
17086: LD_INT 25
17088: PUSH
17089: FOR_TO
17090: IFFALSE 17163
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17092: LD_ADDR_VAR 0 3
17096: PUSH
17097: LD_VAR 0 3
17101: PUSH
17102: LD_INT 22
17104: PUSH
17105: LD_VAR 0 1
17109: PPUSH
17110: CALL_OW 255
17114: PUSH
17115: EMPTY
17116: LIST
17117: LIST
17118: PUSH
17119: LD_INT 91
17121: PUSH
17122: LD_VAR 0 1
17126: PUSH
17127: LD_INT 6
17129: PUSH
17130: EMPTY
17131: LIST
17132: LIST
17133: LIST
17134: PUSH
17135: LD_INT 30
17137: PUSH
17138: LD_VAR 0 4
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: PUSH
17147: EMPTY
17148: LIST
17149: LIST
17150: LIST
17151: PUSH
17152: EMPTY
17153: LIST
17154: PPUSH
17155: CALL_OW 69
17159: ADD
17160: ST_TO_ADDR
17161: GO 17089
17163: POP
17164: POP
// for i = 1 to tmp do
17165: LD_ADDR_VAR 0 4
17169: PUSH
17170: DOUBLE
17171: LD_INT 1
17173: DEC
17174: ST_TO_ADDR
17175: LD_VAR 0 3
17179: PUSH
17180: FOR_TO
17181: IFFALSE 17269
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17183: LD_ADDR_VAR 0 5
17187: PUSH
17188: LD_VAR 0 5
17192: PUSH
17193: LD_VAR 0 3
17197: PUSH
17198: LD_VAR 0 4
17202: ARRAY
17203: PPUSH
17204: CALL_OW 266
17208: PUSH
17209: LD_VAR 0 3
17213: PUSH
17214: LD_VAR 0 4
17218: ARRAY
17219: PPUSH
17220: CALL_OW 250
17224: PUSH
17225: LD_VAR 0 3
17229: PUSH
17230: LD_VAR 0 4
17234: ARRAY
17235: PPUSH
17236: CALL_OW 251
17240: PUSH
17241: LD_VAR 0 3
17245: PUSH
17246: LD_VAR 0 4
17250: ARRAY
17251: PPUSH
17252: CALL_OW 254
17256: PUSH
17257: EMPTY
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: PUSH
17263: EMPTY
17264: LIST
17265: ADD
17266: ST_TO_ADDR
17267: GO 17180
17269: POP
17270: POP
// result := list ;
17271: LD_ADDR_VAR 0 2
17275: PUSH
17276: LD_VAR 0 5
17280: ST_TO_ADDR
// end ;
17281: LD_VAR 0 2
17285: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17286: LD_INT 0
17288: PPUSH
17289: PPUSH
17290: PPUSH
17291: PPUSH
17292: PPUSH
17293: PPUSH
17294: PPUSH
// if not factory then
17295: LD_VAR 0 1
17299: NOT
17300: IFFALSE 17304
// exit ;
17302: GO 17897
// if control = control_apeman then
17304: LD_VAR 0 4
17308: PUSH
17309: LD_INT 5
17311: EQUAL
17312: IFFALSE 17421
// begin tmp := UnitsInside ( factory ) ;
17314: LD_ADDR_VAR 0 8
17318: PUSH
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL_OW 313
17328: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17329: LD_VAR 0 8
17333: PPUSH
17334: LD_INT 25
17336: PUSH
17337: LD_INT 12
17339: PUSH
17340: EMPTY
17341: LIST
17342: LIST
17343: PPUSH
17344: CALL_OW 72
17348: NOT
17349: IFFALSE 17359
// control := control_manual ;
17351: LD_ADDR_VAR 0 4
17355: PUSH
17356: LD_INT 1
17358: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17359: LD_ADDR_VAR 0 8
17363: PUSH
17364: LD_VAR 0 1
17368: PPUSH
17369: CALL 17056 0 1
17373: ST_TO_ADDR
// if tmp then
17374: LD_VAR 0 8
17378: IFFALSE 17421
// begin for i in tmp do
17380: LD_ADDR_VAR 0 7
17384: PUSH
17385: LD_VAR 0 8
17389: PUSH
17390: FOR_IN
17391: IFFALSE 17419
// if i [ 1 ] = b_ext_radio then
17393: LD_VAR 0 7
17397: PUSH
17398: LD_INT 1
17400: ARRAY
17401: PUSH
17402: LD_INT 22
17404: EQUAL
17405: IFFALSE 17417
// begin control := control_remote ;
17407: LD_ADDR_VAR 0 4
17411: PUSH
17412: LD_INT 2
17414: ST_TO_ADDR
// break ;
17415: GO 17419
// end ;
17417: GO 17390
17419: POP
17420: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17421: LD_VAR 0 1
17425: PPUSH
17426: LD_VAR 0 2
17430: PPUSH
17431: LD_VAR 0 3
17435: PPUSH
17436: LD_VAR 0 4
17440: PPUSH
17441: LD_VAR 0 5
17445: PPUSH
17446: CALL_OW 448
17450: IFFALSE 17485
// begin result := [ chassis , engine , control , weapon ] ;
17452: LD_ADDR_VAR 0 6
17456: PUSH
17457: LD_VAR 0 2
17461: PUSH
17462: LD_VAR 0 3
17466: PUSH
17467: LD_VAR 0 4
17471: PUSH
17472: LD_VAR 0 5
17476: PUSH
17477: EMPTY
17478: LIST
17479: LIST
17480: LIST
17481: LIST
17482: ST_TO_ADDR
// exit ;
17483: GO 17897
// end ; _chassis := AvailableChassisList ( factory ) ;
17485: LD_ADDR_VAR 0 9
17489: PUSH
17490: LD_VAR 0 1
17494: PPUSH
17495: CALL_OW 475
17499: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17500: LD_ADDR_VAR 0 11
17504: PUSH
17505: LD_VAR 0 1
17509: PPUSH
17510: CALL_OW 476
17514: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17515: LD_ADDR_VAR 0 12
17519: PUSH
17520: LD_VAR 0 1
17524: PPUSH
17525: CALL_OW 477
17529: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17530: LD_ADDR_VAR 0 10
17534: PUSH
17535: LD_VAR 0 1
17539: PPUSH
17540: CALL_OW 478
17544: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17545: LD_VAR 0 9
17549: NOT
17550: PUSH
17551: LD_VAR 0 11
17555: NOT
17556: OR
17557: PUSH
17558: LD_VAR 0 12
17562: NOT
17563: OR
17564: PUSH
17565: LD_VAR 0 10
17569: NOT
17570: OR
17571: IFFALSE 17606
// begin result := [ chassis , engine , control , weapon ] ;
17573: LD_ADDR_VAR 0 6
17577: PUSH
17578: LD_VAR 0 2
17582: PUSH
17583: LD_VAR 0 3
17587: PUSH
17588: LD_VAR 0 4
17592: PUSH
17593: LD_VAR 0 5
17597: PUSH
17598: EMPTY
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: ST_TO_ADDR
// exit ;
17604: GO 17897
// end ; if not chassis in _chassis then
17606: LD_VAR 0 2
17610: PUSH
17611: LD_VAR 0 9
17615: IN
17616: NOT
17617: IFFALSE 17643
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17619: LD_ADDR_VAR 0 2
17623: PUSH
17624: LD_VAR 0 9
17628: PUSH
17629: LD_INT 1
17631: PPUSH
17632: LD_VAR 0 9
17636: PPUSH
17637: CALL_OW 12
17641: ARRAY
17642: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17643: LD_VAR 0 2
17647: PPUSH
17648: LD_VAR 0 3
17652: PPUSH
17653: CALL 17902 0 2
17657: NOT
17658: IFFALSE 17717
// repeat engine := _engine [ 1 ] ;
17660: LD_ADDR_VAR 0 3
17664: PUSH
17665: LD_VAR 0 11
17669: PUSH
17670: LD_INT 1
17672: ARRAY
17673: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17674: LD_ADDR_VAR 0 11
17678: PUSH
17679: LD_VAR 0 11
17683: PPUSH
17684: LD_INT 1
17686: PPUSH
17687: CALL_OW 3
17691: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17692: LD_VAR 0 2
17696: PPUSH
17697: LD_VAR 0 3
17701: PPUSH
17702: CALL 17902 0 2
17706: PUSH
17707: LD_VAR 0 11
17711: PUSH
17712: EMPTY
17713: EQUAL
17714: OR
17715: IFFALSE 17660
// if not control in _control then
17717: LD_VAR 0 4
17721: PUSH
17722: LD_VAR 0 12
17726: IN
17727: NOT
17728: IFFALSE 17754
// control := _control [ rand ( 1 , _control ) ] ;
17730: LD_ADDR_VAR 0 4
17734: PUSH
17735: LD_VAR 0 12
17739: PUSH
17740: LD_INT 1
17742: PPUSH
17743: LD_VAR 0 12
17747: PPUSH
17748: CALL_OW 12
17752: ARRAY
17753: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17754: LD_VAR 0 2
17758: PPUSH
17759: LD_VAR 0 5
17763: PPUSH
17764: CALL 18122 0 2
17768: NOT
17769: IFFALSE 17828
// repeat weapon := _weapon [ 1 ] ;
17771: LD_ADDR_VAR 0 5
17775: PUSH
17776: LD_VAR 0 10
17780: PUSH
17781: LD_INT 1
17783: ARRAY
17784: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17785: LD_ADDR_VAR 0 10
17789: PUSH
17790: LD_VAR 0 10
17794: PPUSH
17795: LD_INT 1
17797: PPUSH
17798: CALL_OW 3
17802: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17803: LD_VAR 0 2
17807: PPUSH
17808: LD_VAR 0 5
17812: PPUSH
17813: CALL 18122 0 2
17817: PUSH
17818: LD_VAR 0 10
17822: PUSH
17823: EMPTY
17824: EQUAL
17825: OR
17826: IFFALSE 17771
// result := [ ] ;
17828: LD_ADDR_VAR 0 6
17832: PUSH
17833: EMPTY
17834: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17835: LD_VAR 0 1
17839: PPUSH
17840: LD_VAR 0 2
17844: PPUSH
17845: LD_VAR 0 3
17849: PPUSH
17850: LD_VAR 0 4
17854: PPUSH
17855: LD_VAR 0 5
17859: PPUSH
17860: CALL_OW 448
17864: IFFALSE 17897
// result := [ chassis , engine , control , weapon ] ;
17866: LD_ADDR_VAR 0 6
17870: PUSH
17871: LD_VAR 0 2
17875: PUSH
17876: LD_VAR 0 3
17880: PUSH
17881: LD_VAR 0 4
17885: PUSH
17886: LD_VAR 0 5
17890: PUSH
17891: EMPTY
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: ST_TO_ADDR
// end ;
17897: LD_VAR 0 6
17901: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17902: LD_INT 0
17904: PPUSH
// if not chassis or not engine then
17905: LD_VAR 0 1
17909: NOT
17910: PUSH
17911: LD_VAR 0 2
17915: NOT
17916: OR
17917: IFFALSE 17921
// exit ;
17919: GO 18117
// case engine of engine_solar :
17921: LD_VAR 0 2
17925: PUSH
17926: LD_INT 2
17928: DOUBLE
17929: EQUAL
17930: IFTRUE 17934
17932: GO 17972
17934: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17935: LD_ADDR_VAR 0 3
17939: PUSH
17940: LD_INT 11
17942: PUSH
17943: LD_INT 12
17945: PUSH
17946: LD_INT 13
17948: PUSH
17949: LD_INT 14
17951: PUSH
17952: LD_INT 1
17954: PUSH
17955: LD_INT 2
17957: PUSH
17958: LD_INT 3
17960: PUSH
17961: EMPTY
17962: LIST
17963: LIST
17964: LIST
17965: LIST
17966: LIST
17967: LIST
17968: LIST
17969: ST_TO_ADDR
17970: GO 18101
17972: LD_INT 1
17974: DOUBLE
17975: EQUAL
17976: IFTRUE 17980
17978: GO 18042
17980: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17981: LD_ADDR_VAR 0 3
17985: PUSH
17986: LD_INT 11
17988: PUSH
17989: LD_INT 12
17991: PUSH
17992: LD_INT 13
17994: PUSH
17995: LD_INT 14
17997: PUSH
17998: LD_INT 1
18000: PUSH
18001: LD_INT 2
18003: PUSH
18004: LD_INT 3
18006: PUSH
18007: LD_INT 4
18009: PUSH
18010: LD_INT 5
18012: PUSH
18013: LD_INT 21
18015: PUSH
18016: LD_INT 23
18018: PUSH
18019: LD_INT 22
18021: PUSH
18022: LD_INT 24
18024: PUSH
18025: EMPTY
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: ST_TO_ADDR
18040: GO 18101
18042: LD_INT 3
18044: DOUBLE
18045: EQUAL
18046: IFTRUE 18050
18048: GO 18100
18050: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18051: LD_ADDR_VAR 0 3
18055: PUSH
18056: LD_INT 13
18058: PUSH
18059: LD_INT 14
18061: PUSH
18062: LD_INT 2
18064: PUSH
18065: LD_INT 3
18067: PUSH
18068: LD_INT 4
18070: PUSH
18071: LD_INT 5
18073: PUSH
18074: LD_INT 21
18076: PUSH
18077: LD_INT 22
18079: PUSH
18080: LD_INT 23
18082: PUSH
18083: LD_INT 24
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: LIST
18093: LIST
18094: LIST
18095: LIST
18096: LIST
18097: ST_TO_ADDR
18098: GO 18101
18100: POP
// result := ( chassis in result ) ;
18101: LD_ADDR_VAR 0 3
18105: PUSH
18106: LD_VAR 0 1
18110: PUSH
18111: LD_VAR 0 3
18115: IN
18116: ST_TO_ADDR
// end ;
18117: LD_VAR 0 3
18121: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18122: LD_INT 0
18124: PPUSH
// if not chassis or not weapon then
18125: LD_VAR 0 1
18129: NOT
18130: PUSH
18131: LD_VAR 0 2
18135: NOT
18136: OR
18137: IFFALSE 18141
// exit ;
18139: GO 19203
// case weapon of us_machine_gun :
18141: LD_VAR 0 2
18145: PUSH
18146: LD_INT 2
18148: DOUBLE
18149: EQUAL
18150: IFTRUE 18154
18152: GO 18184
18154: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18155: LD_ADDR_VAR 0 3
18159: PUSH
18160: LD_INT 1
18162: PUSH
18163: LD_INT 2
18165: PUSH
18166: LD_INT 3
18168: PUSH
18169: LD_INT 4
18171: PUSH
18172: LD_INT 5
18174: PUSH
18175: EMPTY
18176: LIST
18177: LIST
18178: LIST
18179: LIST
18180: LIST
18181: ST_TO_ADDR
18182: GO 19187
18184: LD_INT 3
18186: DOUBLE
18187: EQUAL
18188: IFTRUE 18192
18190: GO 18222
18192: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18193: LD_ADDR_VAR 0 3
18197: PUSH
18198: LD_INT 1
18200: PUSH
18201: LD_INT 2
18203: PUSH
18204: LD_INT 3
18206: PUSH
18207: LD_INT 4
18209: PUSH
18210: LD_INT 5
18212: PUSH
18213: EMPTY
18214: LIST
18215: LIST
18216: LIST
18217: LIST
18218: LIST
18219: ST_TO_ADDR
18220: GO 19187
18222: LD_INT 11
18224: DOUBLE
18225: EQUAL
18226: IFTRUE 18230
18228: GO 18260
18230: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18231: LD_ADDR_VAR 0 3
18235: PUSH
18236: LD_INT 1
18238: PUSH
18239: LD_INT 2
18241: PUSH
18242: LD_INT 3
18244: PUSH
18245: LD_INT 4
18247: PUSH
18248: LD_INT 5
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: ST_TO_ADDR
18258: GO 19187
18260: LD_INT 4
18262: DOUBLE
18263: EQUAL
18264: IFTRUE 18268
18266: GO 18294
18268: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18269: LD_ADDR_VAR 0 3
18273: PUSH
18274: LD_INT 2
18276: PUSH
18277: LD_INT 3
18279: PUSH
18280: LD_INT 4
18282: PUSH
18283: LD_INT 5
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: LIST
18290: LIST
18291: ST_TO_ADDR
18292: GO 19187
18294: LD_INT 5
18296: DOUBLE
18297: EQUAL
18298: IFTRUE 18302
18300: GO 18328
18302: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18303: LD_ADDR_VAR 0 3
18307: PUSH
18308: LD_INT 2
18310: PUSH
18311: LD_INT 3
18313: PUSH
18314: LD_INT 4
18316: PUSH
18317: LD_INT 5
18319: PUSH
18320: EMPTY
18321: LIST
18322: LIST
18323: LIST
18324: LIST
18325: ST_TO_ADDR
18326: GO 19187
18328: LD_INT 9
18330: DOUBLE
18331: EQUAL
18332: IFTRUE 18336
18334: GO 18362
18336: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18337: LD_ADDR_VAR 0 3
18341: PUSH
18342: LD_INT 2
18344: PUSH
18345: LD_INT 3
18347: PUSH
18348: LD_INT 4
18350: PUSH
18351: LD_INT 5
18353: PUSH
18354: EMPTY
18355: LIST
18356: LIST
18357: LIST
18358: LIST
18359: ST_TO_ADDR
18360: GO 19187
18362: LD_INT 7
18364: DOUBLE
18365: EQUAL
18366: IFTRUE 18370
18368: GO 18396
18370: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: LD_INT 4
18384: PUSH
18385: LD_INT 5
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: ST_TO_ADDR
18394: GO 19187
18396: LD_INT 12
18398: DOUBLE
18399: EQUAL
18400: IFTRUE 18404
18402: GO 18430
18404: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18405: LD_ADDR_VAR 0 3
18409: PUSH
18410: LD_INT 2
18412: PUSH
18413: LD_INT 3
18415: PUSH
18416: LD_INT 4
18418: PUSH
18419: LD_INT 5
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: LIST
18426: LIST
18427: ST_TO_ADDR
18428: GO 19187
18430: LD_INT 13
18432: DOUBLE
18433: EQUAL
18434: IFTRUE 18438
18436: GO 18464
18438: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18439: LD_ADDR_VAR 0 3
18443: PUSH
18444: LD_INT 2
18446: PUSH
18447: LD_INT 3
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: LD_INT 5
18455: PUSH
18456: EMPTY
18457: LIST
18458: LIST
18459: LIST
18460: LIST
18461: ST_TO_ADDR
18462: GO 19187
18464: LD_INT 14
18466: DOUBLE
18467: EQUAL
18468: IFTRUE 18472
18470: GO 18490
18472: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18473: LD_ADDR_VAR 0 3
18477: PUSH
18478: LD_INT 4
18480: PUSH
18481: LD_INT 5
18483: PUSH
18484: EMPTY
18485: LIST
18486: LIST
18487: ST_TO_ADDR
18488: GO 19187
18490: LD_INT 6
18492: DOUBLE
18493: EQUAL
18494: IFTRUE 18498
18496: GO 18516
18498: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18499: LD_ADDR_VAR 0 3
18503: PUSH
18504: LD_INT 4
18506: PUSH
18507: LD_INT 5
18509: PUSH
18510: EMPTY
18511: LIST
18512: LIST
18513: ST_TO_ADDR
18514: GO 19187
18516: LD_INT 10
18518: DOUBLE
18519: EQUAL
18520: IFTRUE 18524
18522: GO 18542
18524: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18525: LD_ADDR_VAR 0 3
18529: PUSH
18530: LD_INT 4
18532: PUSH
18533: LD_INT 5
18535: PUSH
18536: EMPTY
18537: LIST
18538: LIST
18539: ST_TO_ADDR
18540: GO 19187
18542: LD_INT 22
18544: DOUBLE
18545: EQUAL
18546: IFTRUE 18550
18548: GO 18576
18550: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18551: LD_ADDR_VAR 0 3
18555: PUSH
18556: LD_INT 11
18558: PUSH
18559: LD_INT 12
18561: PUSH
18562: LD_INT 13
18564: PUSH
18565: LD_INT 14
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: ST_TO_ADDR
18574: GO 19187
18576: LD_INT 23
18578: DOUBLE
18579: EQUAL
18580: IFTRUE 18584
18582: GO 18610
18584: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_INT 11
18592: PUSH
18593: LD_INT 12
18595: PUSH
18596: LD_INT 13
18598: PUSH
18599: LD_INT 14
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: ST_TO_ADDR
18608: GO 19187
18610: LD_INT 24
18612: DOUBLE
18613: EQUAL
18614: IFTRUE 18618
18616: GO 18644
18618: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_INT 11
18626: PUSH
18627: LD_INT 12
18629: PUSH
18630: LD_INT 13
18632: PUSH
18633: LD_INT 14
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: ST_TO_ADDR
18642: GO 19187
18644: LD_INT 30
18646: DOUBLE
18647: EQUAL
18648: IFTRUE 18652
18650: GO 18678
18652: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18653: LD_ADDR_VAR 0 3
18657: PUSH
18658: LD_INT 11
18660: PUSH
18661: LD_INT 12
18663: PUSH
18664: LD_INT 13
18666: PUSH
18667: LD_INT 14
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
18676: GO 19187
18678: LD_INT 25
18680: DOUBLE
18681: EQUAL
18682: IFTRUE 18686
18684: GO 18704
18686: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18687: LD_ADDR_VAR 0 3
18691: PUSH
18692: LD_INT 13
18694: PUSH
18695: LD_INT 14
18697: PUSH
18698: EMPTY
18699: LIST
18700: LIST
18701: ST_TO_ADDR
18702: GO 19187
18704: LD_INT 27
18706: DOUBLE
18707: EQUAL
18708: IFTRUE 18712
18710: GO 18730
18712: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18713: LD_ADDR_VAR 0 3
18717: PUSH
18718: LD_INT 13
18720: PUSH
18721: LD_INT 14
18723: PUSH
18724: EMPTY
18725: LIST
18726: LIST
18727: ST_TO_ADDR
18728: GO 19187
18730: LD_EXP 108
18734: DOUBLE
18735: EQUAL
18736: IFTRUE 18740
18738: GO 18766
18740: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18741: LD_ADDR_VAR 0 3
18745: PUSH
18746: LD_INT 11
18748: PUSH
18749: LD_INT 12
18751: PUSH
18752: LD_INT 13
18754: PUSH
18755: LD_INT 14
18757: PUSH
18758: EMPTY
18759: LIST
18760: LIST
18761: LIST
18762: LIST
18763: ST_TO_ADDR
18764: GO 19187
18766: LD_INT 28
18768: DOUBLE
18769: EQUAL
18770: IFTRUE 18774
18772: GO 18792
18774: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18775: LD_ADDR_VAR 0 3
18779: PUSH
18780: LD_INT 13
18782: PUSH
18783: LD_INT 14
18785: PUSH
18786: EMPTY
18787: LIST
18788: LIST
18789: ST_TO_ADDR
18790: GO 19187
18792: LD_INT 29
18794: DOUBLE
18795: EQUAL
18796: IFTRUE 18800
18798: GO 18818
18800: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18801: LD_ADDR_VAR 0 3
18805: PUSH
18806: LD_INT 13
18808: PUSH
18809: LD_INT 14
18811: PUSH
18812: EMPTY
18813: LIST
18814: LIST
18815: ST_TO_ADDR
18816: GO 19187
18818: LD_INT 31
18820: DOUBLE
18821: EQUAL
18822: IFTRUE 18826
18824: GO 18844
18826: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18827: LD_ADDR_VAR 0 3
18831: PUSH
18832: LD_INT 13
18834: PUSH
18835: LD_INT 14
18837: PUSH
18838: EMPTY
18839: LIST
18840: LIST
18841: ST_TO_ADDR
18842: GO 19187
18844: LD_INT 26
18846: DOUBLE
18847: EQUAL
18848: IFTRUE 18852
18850: GO 18870
18852: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_INT 13
18860: PUSH
18861: LD_INT 14
18863: PUSH
18864: EMPTY
18865: LIST
18866: LIST
18867: ST_TO_ADDR
18868: GO 19187
18870: LD_INT 42
18872: DOUBLE
18873: EQUAL
18874: IFTRUE 18878
18876: GO 18904
18878: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18879: LD_ADDR_VAR 0 3
18883: PUSH
18884: LD_INT 21
18886: PUSH
18887: LD_INT 22
18889: PUSH
18890: LD_INT 23
18892: PUSH
18893: LD_INT 24
18895: PUSH
18896: EMPTY
18897: LIST
18898: LIST
18899: LIST
18900: LIST
18901: ST_TO_ADDR
18902: GO 19187
18904: LD_INT 43
18906: DOUBLE
18907: EQUAL
18908: IFTRUE 18912
18910: GO 18938
18912: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18913: LD_ADDR_VAR 0 3
18917: PUSH
18918: LD_INT 21
18920: PUSH
18921: LD_INT 22
18923: PUSH
18924: LD_INT 23
18926: PUSH
18927: LD_INT 24
18929: PUSH
18930: EMPTY
18931: LIST
18932: LIST
18933: LIST
18934: LIST
18935: ST_TO_ADDR
18936: GO 19187
18938: LD_INT 44
18940: DOUBLE
18941: EQUAL
18942: IFTRUE 18946
18944: GO 18972
18946: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18947: LD_ADDR_VAR 0 3
18951: PUSH
18952: LD_INT 21
18954: PUSH
18955: LD_INT 22
18957: PUSH
18958: LD_INT 23
18960: PUSH
18961: LD_INT 24
18963: PUSH
18964: EMPTY
18965: LIST
18966: LIST
18967: LIST
18968: LIST
18969: ST_TO_ADDR
18970: GO 19187
18972: LD_INT 45
18974: DOUBLE
18975: EQUAL
18976: IFTRUE 18980
18978: GO 19006
18980: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18981: LD_ADDR_VAR 0 3
18985: PUSH
18986: LD_INT 21
18988: PUSH
18989: LD_INT 22
18991: PUSH
18992: LD_INT 23
18994: PUSH
18995: LD_INT 24
18997: PUSH
18998: EMPTY
18999: LIST
19000: LIST
19001: LIST
19002: LIST
19003: ST_TO_ADDR
19004: GO 19187
19006: LD_INT 49
19008: DOUBLE
19009: EQUAL
19010: IFTRUE 19014
19012: GO 19040
19014: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19015: LD_ADDR_VAR 0 3
19019: PUSH
19020: LD_INT 21
19022: PUSH
19023: LD_INT 22
19025: PUSH
19026: LD_INT 23
19028: PUSH
19029: LD_INT 24
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: LIST
19036: LIST
19037: ST_TO_ADDR
19038: GO 19187
19040: LD_INT 51
19042: DOUBLE
19043: EQUAL
19044: IFTRUE 19048
19046: GO 19074
19048: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19049: LD_ADDR_VAR 0 3
19053: PUSH
19054: LD_INT 21
19056: PUSH
19057: LD_INT 22
19059: PUSH
19060: LD_INT 23
19062: PUSH
19063: LD_INT 24
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: LIST
19070: LIST
19071: ST_TO_ADDR
19072: GO 19187
19074: LD_INT 52
19076: DOUBLE
19077: EQUAL
19078: IFTRUE 19082
19080: GO 19108
19082: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19083: LD_ADDR_VAR 0 3
19087: PUSH
19088: LD_INT 21
19090: PUSH
19091: LD_INT 22
19093: PUSH
19094: LD_INT 23
19096: PUSH
19097: LD_INT 24
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: LIST
19104: LIST
19105: ST_TO_ADDR
19106: GO 19187
19108: LD_INT 53
19110: DOUBLE
19111: EQUAL
19112: IFTRUE 19116
19114: GO 19134
19116: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19117: LD_ADDR_VAR 0 3
19121: PUSH
19122: LD_INT 23
19124: PUSH
19125: LD_INT 24
19127: PUSH
19128: EMPTY
19129: LIST
19130: LIST
19131: ST_TO_ADDR
19132: GO 19187
19134: LD_INT 46
19136: DOUBLE
19137: EQUAL
19138: IFTRUE 19142
19140: GO 19160
19142: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19143: LD_ADDR_VAR 0 3
19147: PUSH
19148: LD_INT 23
19150: PUSH
19151: LD_INT 24
19153: PUSH
19154: EMPTY
19155: LIST
19156: LIST
19157: ST_TO_ADDR
19158: GO 19187
19160: LD_INT 47
19162: DOUBLE
19163: EQUAL
19164: IFTRUE 19168
19166: GO 19186
19168: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19169: LD_ADDR_VAR 0 3
19173: PUSH
19174: LD_INT 23
19176: PUSH
19177: LD_INT 24
19179: PUSH
19180: EMPTY
19181: LIST
19182: LIST
19183: ST_TO_ADDR
19184: GO 19187
19186: POP
// result := ( chassis in result ) ;
19187: LD_ADDR_VAR 0 3
19191: PUSH
19192: LD_VAR 0 1
19196: PUSH
19197: LD_VAR 0 3
19201: IN
19202: ST_TO_ADDR
// end ;
19203: LD_VAR 0 3
19207: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19208: LD_INT 0
19210: PPUSH
19211: PPUSH
19212: PPUSH
19213: PPUSH
19214: PPUSH
19215: PPUSH
19216: PPUSH
// result := array ;
19217: LD_ADDR_VAR 0 5
19221: PUSH
19222: LD_VAR 0 1
19226: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19227: LD_VAR 0 1
19231: NOT
19232: PUSH
19233: LD_VAR 0 2
19237: NOT
19238: OR
19239: PUSH
19240: LD_VAR 0 3
19244: NOT
19245: OR
19246: PUSH
19247: LD_VAR 0 2
19251: PUSH
19252: LD_VAR 0 1
19256: GREATER
19257: OR
19258: PUSH
19259: LD_VAR 0 3
19263: PUSH
19264: LD_VAR 0 1
19268: GREATER
19269: OR
19270: IFFALSE 19274
// exit ;
19272: GO 19570
// if direction then
19274: LD_VAR 0 4
19278: IFFALSE 19342
// begin d := 1 ;
19280: LD_ADDR_VAR 0 9
19284: PUSH
19285: LD_INT 1
19287: ST_TO_ADDR
// if i_from > i_to then
19288: LD_VAR 0 2
19292: PUSH
19293: LD_VAR 0 3
19297: GREATER
19298: IFFALSE 19324
// length := ( array - i_from ) + i_to else
19300: LD_ADDR_VAR 0 11
19304: PUSH
19305: LD_VAR 0 1
19309: PUSH
19310: LD_VAR 0 2
19314: MINUS
19315: PUSH
19316: LD_VAR 0 3
19320: PLUS
19321: ST_TO_ADDR
19322: GO 19340
// length := i_to - i_from ;
19324: LD_ADDR_VAR 0 11
19328: PUSH
19329: LD_VAR 0 3
19333: PUSH
19334: LD_VAR 0 2
19338: MINUS
19339: ST_TO_ADDR
// end else
19340: GO 19403
// begin d := - 1 ;
19342: LD_ADDR_VAR 0 9
19346: PUSH
19347: LD_INT 1
19349: NEG
19350: ST_TO_ADDR
// if i_from > i_to then
19351: LD_VAR 0 2
19355: PUSH
19356: LD_VAR 0 3
19360: GREATER
19361: IFFALSE 19381
// length := i_from - i_to else
19363: LD_ADDR_VAR 0 11
19367: PUSH
19368: LD_VAR 0 2
19372: PUSH
19373: LD_VAR 0 3
19377: MINUS
19378: ST_TO_ADDR
19379: GO 19403
// length := ( array - i_to ) + i_from ;
19381: LD_ADDR_VAR 0 11
19385: PUSH
19386: LD_VAR 0 1
19390: PUSH
19391: LD_VAR 0 3
19395: MINUS
19396: PUSH
19397: LD_VAR 0 2
19401: PLUS
19402: ST_TO_ADDR
// end ; if not length then
19403: LD_VAR 0 11
19407: NOT
19408: IFFALSE 19412
// exit ;
19410: GO 19570
// tmp := array ;
19412: LD_ADDR_VAR 0 10
19416: PUSH
19417: LD_VAR 0 1
19421: ST_TO_ADDR
// for i = 1 to length do
19422: LD_ADDR_VAR 0 6
19426: PUSH
19427: DOUBLE
19428: LD_INT 1
19430: DEC
19431: ST_TO_ADDR
19432: LD_VAR 0 11
19436: PUSH
19437: FOR_TO
19438: IFFALSE 19558
// begin for j = 1 to array do
19440: LD_ADDR_VAR 0 7
19444: PUSH
19445: DOUBLE
19446: LD_INT 1
19448: DEC
19449: ST_TO_ADDR
19450: LD_VAR 0 1
19454: PUSH
19455: FOR_TO
19456: IFFALSE 19544
// begin k := j + d ;
19458: LD_ADDR_VAR 0 8
19462: PUSH
19463: LD_VAR 0 7
19467: PUSH
19468: LD_VAR 0 9
19472: PLUS
19473: ST_TO_ADDR
// if k > array then
19474: LD_VAR 0 8
19478: PUSH
19479: LD_VAR 0 1
19483: GREATER
19484: IFFALSE 19494
// k := 1 ;
19486: LD_ADDR_VAR 0 8
19490: PUSH
19491: LD_INT 1
19493: ST_TO_ADDR
// if not k then
19494: LD_VAR 0 8
19498: NOT
19499: IFFALSE 19511
// k := array ;
19501: LD_ADDR_VAR 0 8
19505: PUSH
19506: LD_VAR 0 1
19510: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19511: LD_ADDR_VAR 0 10
19515: PUSH
19516: LD_VAR 0 10
19520: PPUSH
19521: LD_VAR 0 8
19525: PPUSH
19526: LD_VAR 0 1
19530: PUSH
19531: LD_VAR 0 7
19535: ARRAY
19536: PPUSH
19537: CALL_OW 1
19541: ST_TO_ADDR
// end ;
19542: GO 19455
19544: POP
19545: POP
// array := tmp ;
19546: LD_ADDR_VAR 0 1
19550: PUSH
19551: LD_VAR 0 10
19555: ST_TO_ADDR
// end ;
19556: GO 19437
19558: POP
19559: POP
// result := array ;
19560: LD_ADDR_VAR 0 5
19564: PUSH
19565: LD_VAR 0 1
19569: ST_TO_ADDR
// end ;
19570: LD_VAR 0 5
19574: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19575: LD_INT 0
19577: PPUSH
19578: PPUSH
// result := 0 ;
19579: LD_ADDR_VAR 0 3
19583: PUSH
19584: LD_INT 0
19586: ST_TO_ADDR
// if not array or not value in array then
19587: LD_VAR 0 1
19591: NOT
19592: PUSH
19593: LD_VAR 0 2
19597: PUSH
19598: LD_VAR 0 1
19602: IN
19603: NOT
19604: OR
19605: IFFALSE 19609
// exit ;
19607: GO 19663
// for i = 1 to array do
19609: LD_ADDR_VAR 0 4
19613: PUSH
19614: DOUBLE
19615: LD_INT 1
19617: DEC
19618: ST_TO_ADDR
19619: LD_VAR 0 1
19623: PUSH
19624: FOR_TO
19625: IFFALSE 19661
// if value = array [ i ] then
19627: LD_VAR 0 2
19631: PUSH
19632: LD_VAR 0 1
19636: PUSH
19637: LD_VAR 0 4
19641: ARRAY
19642: EQUAL
19643: IFFALSE 19659
// begin result := i ;
19645: LD_ADDR_VAR 0 3
19649: PUSH
19650: LD_VAR 0 4
19654: ST_TO_ADDR
// exit ;
19655: POP
19656: POP
19657: GO 19663
// end ;
19659: GO 19624
19661: POP
19662: POP
// end ;
19663: LD_VAR 0 3
19667: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19668: LD_INT 0
19670: PPUSH
// vc_chassis := chassis ;
19671: LD_ADDR_OWVAR 37
19675: PUSH
19676: LD_VAR 0 1
19680: ST_TO_ADDR
// vc_engine := engine ;
19681: LD_ADDR_OWVAR 39
19685: PUSH
19686: LD_VAR 0 2
19690: ST_TO_ADDR
// vc_control := control ;
19691: LD_ADDR_OWVAR 38
19695: PUSH
19696: LD_VAR 0 3
19700: ST_TO_ADDR
// vc_weapon := weapon ;
19701: LD_ADDR_OWVAR 40
19705: PUSH
19706: LD_VAR 0 4
19710: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19711: LD_ADDR_OWVAR 41
19715: PUSH
19716: LD_VAR 0 5
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 6
19725: RET
// export function WantPlant ( unit ) ; var task ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
// result := false ;
19730: LD_ADDR_VAR 0 2
19734: PUSH
19735: LD_INT 0
19737: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19738: LD_ADDR_VAR 0 3
19742: PUSH
19743: LD_VAR 0 1
19747: PPUSH
19748: CALL_OW 437
19752: ST_TO_ADDR
// if task then
19753: LD_VAR 0 3
19757: IFFALSE 19785
// if task [ 1 ] [ 1 ] = p then
19759: LD_VAR 0 3
19763: PUSH
19764: LD_INT 1
19766: ARRAY
19767: PUSH
19768: LD_INT 1
19770: ARRAY
19771: PUSH
19772: LD_STRING p
19774: EQUAL
19775: IFFALSE 19785
// result := true ;
19777: LD_ADDR_VAR 0 2
19781: PUSH
19782: LD_INT 1
19784: ST_TO_ADDR
// end ;
19785: LD_VAR 0 2
19789: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19790: LD_INT 0
19792: PPUSH
19793: PPUSH
19794: PPUSH
19795: PPUSH
// if pos < 1 then
19796: LD_VAR 0 2
19800: PUSH
19801: LD_INT 1
19803: LESS
19804: IFFALSE 19808
// exit ;
19806: GO 20111
// if pos = 1 then
19808: LD_VAR 0 2
19812: PUSH
19813: LD_INT 1
19815: EQUAL
19816: IFFALSE 19849
// result := Replace ( arr , pos [ 1 ] , value ) else
19818: LD_ADDR_VAR 0 4
19822: PUSH
19823: LD_VAR 0 1
19827: PPUSH
19828: LD_VAR 0 2
19832: PUSH
19833: LD_INT 1
19835: ARRAY
19836: PPUSH
19837: LD_VAR 0 3
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
19847: GO 20111
// begin tmp := arr ;
19849: LD_ADDR_VAR 0 6
19853: PUSH
19854: LD_VAR 0 1
19858: ST_TO_ADDR
// s_arr := [ tmp ] ;
19859: LD_ADDR_VAR 0 7
19863: PUSH
19864: LD_VAR 0 6
19868: PUSH
19869: EMPTY
19870: LIST
19871: ST_TO_ADDR
// for i = 1 to pos - 1 do
19872: LD_ADDR_VAR 0 5
19876: PUSH
19877: DOUBLE
19878: LD_INT 1
19880: DEC
19881: ST_TO_ADDR
19882: LD_VAR 0 2
19886: PUSH
19887: LD_INT 1
19889: MINUS
19890: PUSH
19891: FOR_TO
19892: IFFALSE 19937
// begin tmp := tmp [ pos [ i ] ] ;
19894: LD_ADDR_VAR 0 6
19898: PUSH
19899: LD_VAR 0 6
19903: PUSH
19904: LD_VAR 0 2
19908: PUSH
19909: LD_VAR 0 5
19913: ARRAY
19914: ARRAY
19915: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19916: LD_ADDR_VAR 0 7
19920: PUSH
19921: LD_VAR 0 7
19925: PUSH
19926: LD_VAR 0 6
19930: PUSH
19931: EMPTY
19932: LIST
19933: ADD
19934: ST_TO_ADDR
// end ;
19935: GO 19891
19937: POP
19938: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19939: LD_ADDR_VAR 0 6
19943: PUSH
19944: LD_VAR 0 6
19948: PPUSH
19949: LD_VAR 0 2
19953: PUSH
19954: LD_VAR 0 2
19958: ARRAY
19959: PPUSH
19960: LD_VAR 0 3
19964: PPUSH
19965: CALL_OW 1
19969: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19970: LD_ADDR_VAR 0 7
19974: PUSH
19975: LD_VAR 0 7
19979: PPUSH
19980: LD_VAR 0 7
19984: PPUSH
19985: LD_VAR 0 6
19989: PPUSH
19990: CALL_OW 1
19994: ST_TO_ADDR
// for i = s_arr downto 2 do
19995: LD_ADDR_VAR 0 5
19999: PUSH
20000: DOUBLE
20001: LD_VAR 0 7
20005: INC
20006: ST_TO_ADDR
20007: LD_INT 2
20009: PUSH
20010: FOR_DOWNTO
20011: IFFALSE 20095
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20013: LD_ADDR_VAR 0 6
20017: PUSH
20018: LD_VAR 0 7
20022: PUSH
20023: LD_VAR 0 5
20027: PUSH
20028: LD_INT 1
20030: MINUS
20031: ARRAY
20032: PPUSH
20033: LD_VAR 0 2
20037: PUSH
20038: LD_VAR 0 5
20042: PUSH
20043: LD_INT 1
20045: MINUS
20046: ARRAY
20047: PPUSH
20048: LD_VAR 0 7
20052: PUSH
20053: LD_VAR 0 5
20057: ARRAY
20058: PPUSH
20059: CALL_OW 1
20063: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20064: LD_ADDR_VAR 0 7
20068: PUSH
20069: LD_VAR 0 7
20073: PPUSH
20074: LD_VAR 0 5
20078: PUSH
20079: LD_INT 1
20081: MINUS
20082: PPUSH
20083: LD_VAR 0 6
20087: PPUSH
20088: CALL_OW 1
20092: ST_TO_ADDR
// end ;
20093: GO 20010
20095: POP
20096: POP
// result := s_arr [ 1 ] ;
20097: LD_ADDR_VAR 0 4
20101: PUSH
20102: LD_VAR 0 7
20106: PUSH
20107: LD_INT 1
20109: ARRAY
20110: ST_TO_ADDR
// end ; end ;
20111: LD_VAR 0 4
20115: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20116: LD_INT 0
20118: PPUSH
20119: PPUSH
// if not list then
20120: LD_VAR 0 1
20124: NOT
20125: IFFALSE 20129
// exit ;
20127: GO 20220
// i := list [ pos1 ] ;
20129: LD_ADDR_VAR 0 5
20133: PUSH
20134: LD_VAR 0 1
20138: PUSH
20139: LD_VAR 0 2
20143: ARRAY
20144: ST_TO_ADDR
// if not i then
20145: LD_VAR 0 5
20149: NOT
20150: IFFALSE 20154
// exit ;
20152: GO 20220
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20154: LD_ADDR_VAR 0 1
20158: PUSH
20159: LD_VAR 0 1
20163: PPUSH
20164: LD_VAR 0 2
20168: PPUSH
20169: LD_VAR 0 1
20173: PUSH
20174: LD_VAR 0 3
20178: ARRAY
20179: PPUSH
20180: CALL_OW 1
20184: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20185: LD_ADDR_VAR 0 1
20189: PUSH
20190: LD_VAR 0 1
20194: PPUSH
20195: LD_VAR 0 3
20199: PPUSH
20200: LD_VAR 0 5
20204: PPUSH
20205: CALL_OW 1
20209: ST_TO_ADDR
// result := list ;
20210: LD_ADDR_VAR 0 4
20214: PUSH
20215: LD_VAR 0 1
20219: ST_TO_ADDR
// end ;
20220: LD_VAR 0 4
20224: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20225: LD_INT 0
20227: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20228: LD_ADDR_VAR 0 5
20232: PUSH
20233: LD_VAR 0 1
20237: PPUSH
20238: CALL_OW 250
20242: PPUSH
20243: LD_VAR 0 1
20247: PPUSH
20248: CALL_OW 251
20252: PPUSH
20253: LD_VAR 0 2
20257: PPUSH
20258: LD_VAR 0 3
20262: PPUSH
20263: LD_VAR 0 4
20267: PPUSH
20268: CALL 20278 0 5
20272: ST_TO_ADDR
// end ;
20273: LD_VAR 0 5
20277: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20278: LD_INT 0
20280: PPUSH
20281: PPUSH
20282: PPUSH
20283: PPUSH
// if not list then
20284: LD_VAR 0 3
20288: NOT
20289: IFFALSE 20293
// exit ;
20291: GO 20681
// result := [ ] ;
20293: LD_ADDR_VAR 0 6
20297: PUSH
20298: EMPTY
20299: ST_TO_ADDR
// for i in list do
20300: LD_ADDR_VAR 0 7
20304: PUSH
20305: LD_VAR 0 3
20309: PUSH
20310: FOR_IN
20311: IFFALSE 20513
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20313: LD_ADDR_VAR 0 9
20317: PUSH
20318: LD_VAR 0 7
20322: PPUSH
20323: LD_VAR 0 1
20327: PPUSH
20328: LD_VAR 0 2
20332: PPUSH
20333: CALL_OW 297
20337: ST_TO_ADDR
// if not result then
20338: LD_VAR 0 6
20342: NOT
20343: IFFALSE 20369
// result := [ [ i , tmp ] ] else
20345: LD_ADDR_VAR 0 6
20349: PUSH
20350: LD_VAR 0 7
20354: PUSH
20355: LD_VAR 0 9
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: PUSH
20364: EMPTY
20365: LIST
20366: ST_TO_ADDR
20367: GO 20511
// begin if result [ result ] [ 2 ] < tmp then
20369: LD_VAR 0 6
20373: PUSH
20374: LD_VAR 0 6
20378: ARRAY
20379: PUSH
20380: LD_INT 2
20382: ARRAY
20383: PUSH
20384: LD_VAR 0 9
20388: LESS
20389: IFFALSE 20431
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20391: LD_ADDR_VAR 0 6
20395: PUSH
20396: LD_VAR 0 6
20400: PPUSH
20401: LD_VAR 0 6
20405: PUSH
20406: LD_INT 1
20408: PLUS
20409: PPUSH
20410: LD_VAR 0 7
20414: PUSH
20415: LD_VAR 0 9
20419: PUSH
20420: EMPTY
20421: LIST
20422: LIST
20423: PPUSH
20424: CALL_OW 2
20428: ST_TO_ADDR
20429: GO 20511
// for j = 1 to result do
20431: LD_ADDR_VAR 0 8
20435: PUSH
20436: DOUBLE
20437: LD_INT 1
20439: DEC
20440: ST_TO_ADDR
20441: LD_VAR 0 6
20445: PUSH
20446: FOR_TO
20447: IFFALSE 20509
// begin if tmp < result [ j ] [ 2 ] then
20449: LD_VAR 0 9
20453: PUSH
20454: LD_VAR 0 6
20458: PUSH
20459: LD_VAR 0 8
20463: ARRAY
20464: PUSH
20465: LD_INT 2
20467: ARRAY
20468: LESS
20469: IFFALSE 20507
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20471: LD_ADDR_VAR 0 6
20475: PUSH
20476: LD_VAR 0 6
20480: PPUSH
20481: LD_VAR 0 8
20485: PPUSH
20486: LD_VAR 0 7
20490: PUSH
20491: LD_VAR 0 9
20495: PUSH
20496: EMPTY
20497: LIST
20498: LIST
20499: PPUSH
20500: CALL_OW 2
20504: ST_TO_ADDR
// break ;
20505: GO 20509
// end ; end ;
20507: GO 20446
20509: POP
20510: POP
// end ; end ;
20511: GO 20310
20513: POP
20514: POP
// if result and not asc then
20515: LD_VAR 0 6
20519: PUSH
20520: LD_VAR 0 4
20524: NOT
20525: AND
20526: IFFALSE 20601
// begin tmp := result ;
20528: LD_ADDR_VAR 0 9
20532: PUSH
20533: LD_VAR 0 6
20537: ST_TO_ADDR
// for i = tmp downto 1 do
20538: LD_ADDR_VAR 0 7
20542: PUSH
20543: DOUBLE
20544: LD_VAR 0 9
20548: INC
20549: ST_TO_ADDR
20550: LD_INT 1
20552: PUSH
20553: FOR_DOWNTO
20554: IFFALSE 20599
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20556: LD_ADDR_VAR 0 6
20560: PUSH
20561: LD_VAR 0 6
20565: PPUSH
20566: LD_VAR 0 9
20570: PUSH
20571: LD_VAR 0 7
20575: MINUS
20576: PUSH
20577: LD_INT 1
20579: PLUS
20580: PPUSH
20581: LD_VAR 0 9
20585: PUSH
20586: LD_VAR 0 7
20590: ARRAY
20591: PPUSH
20592: CALL_OW 1
20596: ST_TO_ADDR
20597: GO 20553
20599: POP
20600: POP
// end ; tmp := [ ] ;
20601: LD_ADDR_VAR 0 9
20605: PUSH
20606: EMPTY
20607: ST_TO_ADDR
// if mode then
20608: LD_VAR 0 5
20612: IFFALSE 20681
// begin for i = 1 to result do
20614: LD_ADDR_VAR 0 7
20618: PUSH
20619: DOUBLE
20620: LD_INT 1
20622: DEC
20623: ST_TO_ADDR
20624: LD_VAR 0 6
20628: PUSH
20629: FOR_TO
20630: IFFALSE 20669
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20632: LD_ADDR_VAR 0 9
20636: PUSH
20637: LD_VAR 0 9
20641: PPUSH
20642: LD_VAR 0 7
20646: PPUSH
20647: LD_VAR 0 6
20651: PUSH
20652: LD_VAR 0 7
20656: ARRAY
20657: PUSH
20658: LD_INT 1
20660: ARRAY
20661: PPUSH
20662: CALL_OW 1
20666: ST_TO_ADDR
20667: GO 20629
20669: POP
20670: POP
// result := tmp ;
20671: LD_ADDR_VAR 0 6
20675: PUSH
20676: LD_VAR 0 9
20680: ST_TO_ADDR
// end ; end ;
20681: LD_VAR 0 6
20685: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20686: LD_INT 0
20688: PPUSH
20689: PPUSH
20690: PPUSH
20691: PPUSH
20692: PPUSH
20693: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20694: LD_ADDR_VAR 0 5
20698: PUSH
20699: LD_INT 0
20701: PUSH
20702: LD_INT 0
20704: PUSH
20705: LD_INT 0
20707: PUSH
20708: EMPTY
20709: PUSH
20710: EMPTY
20711: LIST
20712: LIST
20713: LIST
20714: LIST
20715: ST_TO_ADDR
// if not x or not y then
20716: LD_VAR 0 2
20720: NOT
20721: PUSH
20722: LD_VAR 0 3
20726: NOT
20727: OR
20728: IFFALSE 20732
// exit ;
20730: GO 22384
// if not range then
20732: LD_VAR 0 4
20736: NOT
20737: IFFALSE 20747
// range := 10 ;
20739: LD_ADDR_VAR 0 4
20743: PUSH
20744: LD_INT 10
20746: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20747: LD_ADDR_VAR 0 8
20751: PUSH
20752: LD_INT 81
20754: PUSH
20755: LD_VAR 0 1
20759: PUSH
20760: EMPTY
20761: LIST
20762: LIST
20763: PUSH
20764: LD_INT 92
20766: PUSH
20767: LD_VAR 0 2
20771: PUSH
20772: LD_VAR 0 3
20776: PUSH
20777: LD_VAR 0 4
20781: PUSH
20782: EMPTY
20783: LIST
20784: LIST
20785: LIST
20786: LIST
20787: PUSH
20788: LD_INT 3
20790: PUSH
20791: LD_INT 21
20793: PUSH
20794: LD_INT 3
20796: PUSH
20797: EMPTY
20798: LIST
20799: LIST
20800: PUSH
20801: EMPTY
20802: LIST
20803: LIST
20804: PUSH
20805: EMPTY
20806: LIST
20807: LIST
20808: LIST
20809: PPUSH
20810: CALL_OW 69
20814: ST_TO_ADDR
// if not tmp then
20815: LD_VAR 0 8
20819: NOT
20820: IFFALSE 20824
// exit ;
20822: GO 22384
// for i in tmp do
20824: LD_ADDR_VAR 0 6
20828: PUSH
20829: LD_VAR 0 8
20833: PUSH
20834: FOR_IN
20835: IFFALSE 22359
// begin points := [ 0 , 0 , 0 ] ;
20837: LD_ADDR_VAR 0 9
20841: PUSH
20842: LD_INT 0
20844: PUSH
20845: LD_INT 0
20847: PUSH
20848: LD_INT 0
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: LIST
20855: ST_TO_ADDR
// bpoints := 1 ;
20856: LD_ADDR_VAR 0 10
20860: PUSH
20861: LD_INT 1
20863: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20864: LD_VAR 0 6
20868: PPUSH
20869: CALL_OW 247
20873: PUSH
20874: LD_INT 1
20876: DOUBLE
20877: EQUAL
20878: IFTRUE 20882
20880: GO 21460
20882: POP
// begin if GetClass ( i ) = 1 then
20883: LD_VAR 0 6
20887: PPUSH
20888: CALL_OW 257
20892: PUSH
20893: LD_INT 1
20895: EQUAL
20896: IFFALSE 20917
// points := [ 10 , 5 , 3 ] ;
20898: LD_ADDR_VAR 0 9
20902: PUSH
20903: LD_INT 10
20905: PUSH
20906: LD_INT 5
20908: PUSH
20909: LD_INT 3
20911: PUSH
20912: EMPTY
20913: LIST
20914: LIST
20915: LIST
20916: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 257
20926: PUSH
20927: LD_INT 2
20929: PUSH
20930: LD_INT 3
20932: PUSH
20933: LD_INT 4
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: IN
20941: IFFALSE 20962
// points := [ 3 , 2 , 1 ] ;
20943: LD_ADDR_VAR 0 9
20947: PUSH
20948: LD_INT 3
20950: PUSH
20951: LD_INT 2
20953: PUSH
20954: LD_INT 1
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 257
20971: PUSH
20972: LD_INT 5
20974: EQUAL
20975: IFFALSE 20996
// points := [ 130 , 5 , 2 ] ;
20977: LD_ADDR_VAR 0 9
20981: PUSH
20982: LD_INT 130
20984: PUSH
20985: LD_INT 5
20987: PUSH
20988: LD_INT 2
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: LIST
20995: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20996: LD_VAR 0 6
21000: PPUSH
21001: CALL_OW 257
21005: PUSH
21006: LD_INT 8
21008: EQUAL
21009: IFFALSE 21030
// points := [ 35 , 35 , 30 ] ;
21011: LD_ADDR_VAR 0 9
21015: PUSH
21016: LD_INT 35
21018: PUSH
21019: LD_INT 35
21021: PUSH
21022: LD_INT 30
21024: PUSH
21025: EMPTY
21026: LIST
21027: LIST
21028: LIST
21029: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21030: LD_VAR 0 6
21034: PPUSH
21035: CALL_OW 257
21039: PUSH
21040: LD_INT 9
21042: EQUAL
21043: IFFALSE 21064
// points := [ 20 , 55 , 40 ] ;
21045: LD_ADDR_VAR 0 9
21049: PUSH
21050: LD_INT 20
21052: PUSH
21053: LD_INT 55
21055: PUSH
21056: LD_INT 40
21058: PUSH
21059: EMPTY
21060: LIST
21061: LIST
21062: LIST
21063: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21064: LD_VAR 0 6
21068: PPUSH
21069: CALL_OW 257
21073: PUSH
21074: LD_INT 12
21076: PUSH
21077: LD_INT 16
21079: PUSH
21080: EMPTY
21081: LIST
21082: LIST
21083: IN
21084: IFFALSE 21105
// points := [ 5 , 3 , 2 ] ;
21086: LD_ADDR_VAR 0 9
21090: PUSH
21091: LD_INT 5
21093: PUSH
21094: LD_INT 3
21096: PUSH
21097: LD_INT 2
21099: PUSH
21100: EMPTY
21101: LIST
21102: LIST
21103: LIST
21104: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21105: LD_VAR 0 6
21109: PPUSH
21110: CALL_OW 257
21114: PUSH
21115: LD_INT 17
21117: EQUAL
21118: IFFALSE 21139
// points := [ 100 , 50 , 75 ] ;
21120: LD_ADDR_VAR 0 9
21124: PUSH
21125: LD_INT 100
21127: PUSH
21128: LD_INT 50
21130: PUSH
21131: LD_INT 75
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: LIST
21138: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21139: LD_VAR 0 6
21143: PPUSH
21144: CALL_OW 257
21148: PUSH
21149: LD_INT 15
21151: EQUAL
21152: IFFALSE 21173
// points := [ 10 , 5 , 3 ] ;
21154: LD_ADDR_VAR 0 9
21158: PUSH
21159: LD_INT 10
21161: PUSH
21162: LD_INT 5
21164: PUSH
21165: LD_INT 3
21167: PUSH
21168: EMPTY
21169: LIST
21170: LIST
21171: LIST
21172: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21173: LD_VAR 0 6
21177: PPUSH
21178: CALL_OW 257
21182: PUSH
21183: LD_INT 14
21185: EQUAL
21186: IFFALSE 21207
// points := [ 10 , 0 , 0 ] ;
21188: LD_ADDR_VAR 0 9
21192: PUSH
21193: LD_INT 10
21195: PUSH
21196: LD_INT 0
21198: PUSH
21199: LD_INT 0
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: LIST
21206: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21207: LD_VAR 0 6
21211: PPUSH
21212: CALL_OW 257
21216: PUSH
21217: LD_INT 11
21219: EQUAL
21220: IFFALSE 21241
// points := [ 30 , 10 , 5 ] ;
21222: LD_ADDR_VAR 0 9
21226: PUSH
21227: LD_INT 30
21229: PUSH
21230: LD_INT 10
21232: PUSH
21233: LD_INT 5
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21241: LD_VAR 0 1
21245: PPUSH
21246: LD_INT 5
21248: PPUSH
21249: CALL_OW 321
21253: PUSH
21254: LD_INT 2
21256: EQUAL
21257: IFFALSE 21274
// bpoints := bpoints * 1.8 ;
21259: LD_ADDR_VAR 0 10
21263: PUSH
21264: LD_VAR 0 10
21268: PUSH
21269: LD_REAL  1.80000000000000E+0000
21272: MUL
21273: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21274: LD_VAR 0 6
21278: PPUSH
21279: CALL_OW 257
21283: PUSH
21284: LD_INT 1
21286: PUSH
21287: LD_INT 2
21289: PUSH
21290: LD_INT 3
21292: PUSH
21293: LD_INT 4
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: LIST
21300: LIST
21301: IN
21302: PUSH
21303: LD_VAR 0 1
21307: PPUSH
21308: LD_INT 51
21310: PPUSH
21311: CALL_OW 321
21315: PUSH
21316: LD_INT 2
21318: EQUAL
21319: AND
21320: IFFALSE 21337
// bpoints := bpoints * 1.2 ;
21322: LD_ADDR_VAR 0 10
21326: PUSH
21327: LD_VAR 0 10
21331: PUSH
21332: LD_REAL  1.20000000000000E+0000
21335: MUL
21336: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21337: LD_VAR 0 6
21341: PPUSH
21342: CALL_OW 257
21346: PUSH
21347: LD_INT 5
21349: PUSH
21350: LD_INT 7
21352: PUSH
21353: LD_INT 9
21355: PUSH
21356: EMPTY
21357: LIST
21358: LIST
21359: LIST
21360: IN
21361: PUSH
21362: LD_VAR 0 1
21366: PPUSH
21367: LD_INT 52
21369: PPUSH
21370: CALL_OW 321
21374: PUSH
21375: LD_INT 2
21377: EQUAL
21378: AND
21379: IFFALSE 21396
// bpoints := bpoints * 1.5 ;
21381: LD_ADDR_VAR 0 10
21385: PUSH
21386: LD_VAR 0 10
21390: PUSH
21391: LD_REAL  1.50000000000000E+0000
21394: MUL
21395: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21396: LD_VAR 0 1
21400: PPUSH
21401: LD_INT 66
21403: PPUSH
21404: CALL_OW 321
21408: PUSH
21409: LD_INT 2
21411: EQUAL
21412: IFFALSE 21429
// bpoints := bpoints * 1.1 ;
21414: LD_ADDR_VAR 0 10
21418: PUSH
21419: LD_VAR 0 10
21423: PUSH
21424: LD_REAL  1.10000000000000E+0000
21427: MUL
21428: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21429: LD_ADDR_VAR 0 10
21433: PUSH
21434: LD_VAR 0 10
21438: PUSH
21439: LD_VAR 0 6
21443: PPUSH
21444: LD_INT 1
21446: PPUSH
21447: CALL_OW 259
21451: PUSH
21452: LD_REAL  1.15000000000000E+0000
21455: MUL
21456: MUL
21457: ST_TO_ADDR
// end ; unit_vehicle :
21458: GO 22288
21460: LD_INT 2
21462: DOUBLE
21463: EQUAL
21464: IFTRUE 21468
21466: GO 22276
21468: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21469: LD_VAR 0 6
21473: PPUSH
21474: CALL_OW 264
21478: PUSH
21479: LD_INT 2
21481: PUSH
21482: LD_INT 42
21484: PUSH
21485: LD_INT 24
21487: PUSH
21488: EMPTY
21489: LIST
21490: LIST
21491: LIST
21492: IN
21493: IFFALSE 21514
// points := [ 25 , 5 , 3 ] ;
21495: LD_ADDR_VAR 0 9
21499: PUSH
21500: LD_INT 25
21502: PUSH
21503: LD_INT 5
21505: PUSH
21506: LD_INT 3
21508: PUSH
21509: EMPTY
21510: LIST
21511: LIST
21512: LIST
21513: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21514: LD_VAR 0 6
21518: PPUSH
21519: CALL_OW 264
21523: PUSH
21524: LD_INT 4
21526: PUSH
21527: LD_INT 43
21529: PUSH
21530: LD_INT 25
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: LIST
21537: IN
21538: IFFALSE 21559
// points := [ 40 , 15 , 5 ] ;
21540: LD_ADDR_VAR 0 9
21544: PUSH
21545: LD_INT 40
21547: PUSH
21548: LD_INT 15
21550: PUSH
21551: LD_INT 5
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: LIST
21558: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21559: LD_VAR 0 6
21563: PPUSH
21564: CALL_OW 264
21568: PUSH
21569: LD_INT 3
21571: PUSH
21572: LD_INT 23
21574: PUSH
21575: EMPTY
21576: LIST
21577: LIST
21578: IN
21579: IFFALSE 21600
// points := [ 7 , 25 , 8 ] ;
21581: LD_ADDR_VAR 0 9
21585: PUSH
21586: LD_INT 7
21588: PUSH
21589: LD_INT 25
21591: PUSH
21592: LD_INT 8
21594: PUSH
21595: EMPTY
21596: LIST
21597: LIST
21598: LIST
21599: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21600: LD_VAR 0 6
21604: PPUSH
21605: CALL_OW 264
21609: PUSH
21610: LD_INT 5
21612: PUSH
21613: LD_INT 27
21615: PUSH
21616: LD_INT 44
21618: PUSH
21619: EMPTY
21620: LIST
21621: LIST
21622: LIST
21623: IN
21624: IFFALSE 21645
// points := [ 14 , 50 , 16 ] ;
21626: LD_ADDR_VAR 0 9
21630: PUSH
21631: LD_INT 14
21633: PUSH
21634: LD_INT 50
21636: PUSH
21637: LD_INT 16
21639: PUSH
21640: EMPTY
21641: LIST
21642: LIST
21643: LIST
21644: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21645: LD_VAR 0 6
21649: PPUSH
21650: CALL_OW 264
21654: PUSH
21655: LD_INT 6
21657: PUSH
21658: LD_INT 46
21660: PUSH
21661: EMPTY
21662: LIST
21663: LIST
21664: IN
21665: IFFALSE 21686
// points := [ 32 , 120 , 70 ] ;
21667: LD_ADDR_VAR 0 9
21671: PUSH
21672: LD_INT 32
21674: PUSH
21675: LD_INT 120
21677: PUSH
21678: LD_INT 70
21680: PUSH
21681: EMPTY
21682: LIST
21683: LIST
21684: LIST
21685: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21686: LD_VAR 0 6
21690: PPUSH
21691: CALL_OW 264
21695: PUSH
21696: LD_INT 7
21698: PUSH
21699: LD_INT 28
21701: PUSH
21702: LD_INT 45
21704: PUSH
21705: LD_EXP 108
21709: PUSH
21710: EMPTY
21711: LIST
21712: LIST
21713: LIST
21714: LIST
21715: IN
21716: IFFALSE 21737
// points := [ 35 , 20 , 45 ] ;
21718: LD_ADDR_VAR 0 9
21722: PUSH
21723: LD_INT 35
21725: PUSH
21726: LD_INT 20
21728: PUSH
21729: LD_INT 45
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: LIST
21736: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21737: LD_VAR 0 6
21741: PPUSH
21742: CALL_OW 264
21746: PUSH
21747: LD_INT 47
21749: PUSH
21750: EMPTY
21751: LIST
21752: IN
21753: IFFALSE 21774
// points := [ 67 , 45 , 75 ] ;
21755: LD_ADDR_VAR 0 9
21759: PUSH
21760: LD_INT 67
21762: PUSH
21763: LD_INT 45
21765: PUSH
21766: LD_INT 75
21768: PUSH
21769: EMPTY
21770: LIST
21771: LIST
21772: LIST
21773: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21774: LD_VAR 0 6
21778: PPUSH
21779: CALL_OW 264
21783: PUSH
21784: LD_INT 26
21786: PUSH
21787: EMPTY
21788: LIST
21789: IN
21790: IFFALSE 21811
// points := [ 120 , 30 , 80 ] ;
21792: LD_ADDR_VAR 0 9
21796: PUSH
21797: LD_INT 120
21799: PUSH
21800: LD_INT 30
21802: PUSH
21803: LD_INT 80
21805: PUSH
21806: EMPTY
21807: LIST
21808: LIST
21809: LIST
21810: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21811: LD_VAR 0 6
21815: PPUSH
21816: CALL_OW 264
21820: PUSH
21821: LD_INT 22
21823: PUSH
21824: EMPTY
21825: LIST
21826: IN
21827: IFFALSE 21848
// points := [ 40 , 1 , 1 ] ;
21829: LD_ADDR_VAR 0 9
21833: PUSH
21834: LD_INT 40
21836: PUSH
21837: LD_INT 1
21839: PUSH
21840: LD_INT 1
21842: PUSH
21843: EMPTY
21844: LIST
21845: LIST
21846: LIST
21847: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21848: LD_VAR 0 6
21852: PPUSH
21853: CALL_OW 264
21857: PUSH
21858: LD_INT 29
21860: PUSH
21861: EMPTY
21862: LIST
21863: IN
21864: IFFALSE 21885
// points := [ 70 , 200 , 400 ] ;
21866: LD_ADDR_VAR 0 9
21870: PUSH
21871: LD_INT 70
21873: PUSH
21874: LD_INT 200
21876: PUSH
21877: LD_INT 400
21879: PUSH
21880: EMPTY
21881: LIST
21882: LIST
21883: LIST
21884: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21885: LD_VAR 0 6
21889: PPUSH
21890: CALL_OW 264
21894: PUSH
21895: LD_INT 14
21897: PUSH
21898: LD_INT 53
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: IN
21905: IFFALSE 21926
// points := [ 40 , 10 , 20 ] ;
21907: LD_ADDR_VAR 0 9
21911: PUSH
21912: LD_INT 40
21914: PUSH
21915: LD_INT 10
21917: PUSH
21918: LD_INT 20
21920: PUSH
21921: EMPTY
21922: LIST
21923: LIST
21924: LIST
21925: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21926: LD_VAR 0 6
21930: PPUSH
21931: CALL_OW 264
21935: PUSH
21936: LD_INT 9
21938: PUSH
21939: EMPTY
21940: LIST
21941: IN
21942: IFFALSE 21963
// points := [ 5 , 70 , 20 ] ;
21944: LD_ADDR_VAR 0 9
21948: PUSH
21949: LD_INT 5
21951: PUSH
21952: LD_INT 70
21954: PUSH
21955: LD_INT 20
21957: PUSH
21958: EMPTY
21959: LIST
21960: LIST
21961: LIST
21962: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21963: LD_VAR 0 6
21967: PPUSH
21968: CALL_OW 264
21972: PUSH
21973: LD_INT 10
21975: PUSH
21976: EMPTY
21977: LIST
21978: IN
21979: IFFALSE 22000
// points := [ 35 , 110 , 70 ] ;
21981: LD_ADDR_VAR 0 9
21985: PUSH
21986: LD_INT 35
21988: PUSH
21989: LD_INT 110
21991: PUSH
21992: LD_INT 70
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: LIST
21999: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22000: LD_VAR 0 6
22004: PPUSH
22005: CALL_OW 265
22009: PUSH
22010: LD_INT 25
22012: EQUAL
22013: IFFALSE 22034
// points := [ 80 , 65 , 100 ] ;
22015: LD_ADDR_VAR 0 9
22019: PUSH
22020: LD_INT 80
22022: PUSH
22023: LD_INT 65
22025: PUSH
22026: LD_INT 100
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: LIST
22033: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22034: LD_VAR 0 6
22038: PPUSH
22039: CALL_OW 263
22043: PUSH
22044: LD_INT 1
22046: EQUAL
22047: IFFALSE 22082
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22049: LD_ADDR_VAR 0 10
22053: PUSH
22054: LD_VAR 0 10
22058: PUSH
22059: LD_VAR 0 6
22063: PPUSH
22064: CALL_OW 311
22068: PPUSH
22069: LD_INT 3
22071: PPUSH
22072: CALL_OW 259
22076: PUSH
22077: LD_INT 4
22079: MUL
22080: MUL
22081: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22082: LD_VAR 0 6
22086: PPUSH
22087: CALL_OW 263
22091: PUSH
22092: LD_INT 2
22094: EQUAL
22095: IFFALSE 22146
// begin j := IsControledBy ( i ) ;
22097: LD_ADDR_VAR 0 7
22101: PUSH
22102: LD_VAR 0 6
22106: PPUSH
22107: CALL_OW 312
22111: ST_TO_ADDR
// if j then
22112: LD_VAR 0 7
22116: IFFALSE 22146
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22118: LD_ADDR_VAR 0 10
22122: PUSH
22123: LD_VAR 0 10
22127: PUSH
22128: LD_VAR 0 7
22132: PPUSH
22133: LD_INT 3
22135: PPUSH
22136: CALL_OW 259
22140: PUSH
22141: LD_INT 3
22143: MUL
22144: MUL
22145: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22146: LD_VAR 0 6
22150: PPUSH
22151: CALL_OW 264
22155: PUSH
22156: LD_INT 5
22158: PUSH
22159: LD_INT 6
22161: PUSH
22162: LD_INT 46
22164: PUSH
22165: LD_INT 44
22167: PUSH
22168: LD_INT 47
22170: PUSH
22171: LD_INT 45
22173: PUSH
22174: LD_INT 28
22176: PUSH
22177: LD_INT 7
22179: PUSH
22180: LD_INT 27
22182: PUSH
22183: LD_INT 29
22185: PUSH
22186: EMPTY
22187: LIST
22188: LIST
22189: LIST
22190: LIST
22191: LIST
22192: LIST
22193: LIST
22194: LIST
22195: LIST
22196: LIST
22197: IN
22198: PUSH
22199: LD_VAR 0 1
22203: PPUSH
22204: LD_INT 52
22206: PPUSH
22207: CALL_OW 321
22211: PUSH
22212: LD_INT 2
22214: EQUAL
22215: AND
22216: IFFALSE 22233
// bpoints := bpoints * 1.2 ;
22218: LD_ADDR_VAR 0 10
22222: PUSH
22223: LD_VAR 0 10
22227: PUSH
22228: LD_REAL  1.20000000000000E+0000
22231: MUL
22232: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22233: LD_VAR 0 6
22237: PPUSH
22238: CALL_OW 264
22242: PUSH
22243: LD_INT 6
22245: PUSH
22246: LD_INT 46
22248: PUSH
22249: LD_INT 47
22251: PUSH
22252: EMPTY
22253: LIST
22254: LIST
22255: LIST
22256: IN
22257: IFFALSE 22274
// bpoints := bpoints * 1.2 ;
22259: LD_ADDR_VAR 0 10
22263: PUSH
22264: LD_VAR 0 10
22268: PUSH
22269: LD_REAL  1.20000000000000E+0000
22272: MUL
22273: ST_TO_ADDR
// end ; unit_building :
22274: GO 22288
22276: LD_INT 3
22278: DOUBLE
22279: EQUAL
22280: IFTRUE 22284
22282: GO 22287
22284: POP
// ; end ;
22285: GO 22288
22287: POP
// for j = 1 to 3 do
22288: LD_ADDR_VAR 0 7
22292: PUSH
22293: DOUBLE
22294: LD_INT 1
22296: DEC
22297: ST_TO_ADDR
22298: LD_INT 3
22300: PUSH
22301: FOR_TO
22302: IFFALSE 22355
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22304: LD_ADDR_VAR 0 5
22308: PUSH
22309: LD_VAR 0 5
22313: PPUSH
22314: LD_VAR 0 7
22318: PPUSH
22319: LD_VAR 0 5
22323: PUSH
22324: LD_VAR 0 7
22328: ARRAY
22329: PUSH
22330: LD_VAR 0 9
22334: PUSH
22335: LD_VAR 0 7
22339: ARRAY
22340: PUSH
22341: LD_VAR 0 10
22345: MUL
22346: PLUS
22347: PPUSH
22348: CALL_OW 1
22352: ST_TO_ADDR
22353: GO 22301
22355: POP
22356: POP
// end ;
22357: GO 20834
22359: POP
22360: POP
// result := Replace ( result , 4 , tmp ) ;
22361: LD_ADDR_VAR 0 5
22365: PUSH
22366: LD_VAR 0 5
22370: PPUSH
22371: LD_INT 4
22373: PPUSH
22374: LD_VAR 0 8
22378: PPUSH
22379: CALL_OW 1
22383: ST_TO_ADDR
// end ;
22384: LD_VAR 0 5
22388: RET
// export function DangerAtRange ( unit , range ) ; begin
22389: LD_INT 0
22391: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22392: LD_ADDR_VAR 0 3
22396: PUSH
22397: LD_VAR 0 1
22401: PPUSH
22402: CALL_OW 255
22406: PPUSH
22407: LD_VAR 0 1
22411: PPUSH
22412: CALL_OW 250
22416: PPUSH
22417: LD_VAR 0 1
22421: PPUSH
22422: CALL_OW 251
22426: PPUSH
22427: LD_VAR 0 2
22431: PPUSH
22432: CALL 20686 0 4
22436: ST_TO_ADDR
// end ;
22437: LD_VAR 0 3
22441: RET
// export function DangerInArea ( side , area ) ; begin
22442: LD_INT 0
22444: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22445: LD_ADDR_VAR 0 3
22449: PUSH
22450: LD_VAR 0 2
22454: PPUSH
22455: LD_INT 81
22457: PUSH
22458: LD_VAR 0 1
22462: PUSH
22463: EMPTY
22464: LIST
22465: LIST
22466: PPUSH
22467: CALL_OW 70
22471: ST_TO_ADDR
// end ;
22472: LD_VAR 0 3
22476: RET
// export function IsExtension ( b ) ; begin
22477: LD_INT 0
22479: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22480: LD_ADDR_VAR 0 2
22484: PUSH
22485: LD_VAR 0 1
22489: PUSH
22490: LD_INT 23
22492: PUSH
22493: LD_INT 20
22495: PUSH
22496: LD_INT 22
22498: PUSH
22499: LD_INT 17
22501: PUSH
22502: LD_INT 24
22504: PUSH
22505: LD_INT 21
22507: PUSH
22508: LD_INT 19
22510: PUSH
22511: LD_INT 16
22513: PUSH
22514: LD_INT 25
22516: PUSH
22517: LD_INT 18
22519: PUSH
22520: EMPTY
22521: LIST
22522: LIST
22523: LIST
22524: LIST
22525: LIST
22526: LIST
22527: LIST
22528: LIST
22529: LIST
22530: LIST
22531: IN
22532: ST_TO_ADDR
// end ;
22533: LD_VAR 0 2
22537: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22538: LD_INT 0
22540: PPUSH
22541: PPUSH
22542: PPUSH
// result := [ ] ;
22543: LD_ADDR_VAR 0 4
22547: PUSH
22548: EMPTY
22549: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22550: LD_ADDR_VAR 0 5
22554: PUSH
22555: LD_VAR 0 2
22559: PPUSH
22560: LD_INT 21
22562: PUSH
22563: LD_INT 3
22565: PUSH
22566: EMPTY
22567: LIST
22568: LIST
22569: PPUSH
22570: CALL_OW 70
22574: ST_TO_ADDR
// if not tmp then
22575: LD_VAR 0 5
22579: NOT
22580: IFFALSE 22584
// exit ;
22582: GO 22648
// if checkLink then
22584: LD_VAR 0 3
22588: IFFALSE 22638
// begin for i in tmp do
22590: LD_ADDR_VAR 0 6
22594: PUSH
22595: LD_VAR 0 5
22599: PUSH
22600: FOR_IN
22601: IFFALSE 22636
// if GetBase ( i ) <> base then
22603: LD_VAR 0 6
22607: PPUSH
22608: CALL_OW 274
22612: PUSH
22613: LD_VAR 0 1
22617: NONEQUAL
22618: IFFALSE 22634
// ComLinkToBase ( base , i ) ;
22620: LD_VAR 0 1
22624: PPUSH
22625: LD_VAR 0 6
22629: PPUSH
22630: CALL_OW 169
22634: GO 22600
22636: POP
22637: POP
// end ; result := tmp ;
22638: LD_ADDR_VAR 0 4
22642: PUSH
22643: LD_VAR 0 5
22647: ST_TO_ADDR
// end ;
22648: LD_VAR 0 4
22652: RET
// export function ComComplete ( units , b ) ; var i ; begin
22653: LD_INT 0
22655: PPUSH
22656: PPUSH
// if not units then
22657: LD_VAR 0 1
22661: NOT
22662: IFFALSE 22666
// exit ;
22664: GO 22756
// for i in units do
22666: LD_ADDR_VAR 0 4
22670: PUSH
22671: LD_VAR 0 1
22675: PUSH
22676: FOR_IN
22677: IFFALSE 22754
// if BuildingStatus ( b ) = bs_build then
22679: LD_VAR 0 2
22683: PPUSH
22684: CALL_OW 461
22688: PUSH
22689: LD_INT 1
22691: EQUAL
22692: IFFALSE 22752
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22694: LD_VAR 0 4
22698: PPUSH
22699: LD_STRING h
22701: PUSH
22702: LD_VAR 0 2
22706: PPUSH
22707: CALL_OW 250
22711: PUSH
22712: LD_VAR 0 2
22716: PPUSH
22717: CALL_OW 251
22721: PUSH
22722: LD_VAR 0 2
22726: PUSH
22727: LD_INT 0
22729: PUSH
22730: LD_INT 0
22732: PUSH
22733: LD_INT 0
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: LIST
22740: LIST
22741: LIST
22742: LIST
22743: LIST
22744: PUSH
22745: EMPTY
22746: LIST
22747: PPUSH
22748: CALL_OW 446
22752: GO 22676
22754: POP
22755: POP
// end ;
22756: LD_VAR 0 3
22760: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22761: LD_INT 0
22763: PPUSH
22764: PPUSH
22765: PPUSH
22766: PPUSH
22767: PPUSH
22768: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22769: LD_VAR 0 1
22773: NOT
22774: PUSH
22775: LD_VAR 0 1
22779: PPUSH
22780: CALL_OW 263
22784: PUSH
22785: LD_INT 2
22787: NONEQUAL
22788: OR
22789: IFFALSE 22793
// exit ;
22791: GO 23109
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22793: LD_ADDR_VAR 0 6
22797: PUSH
22798: LD_INT 22
22800: PUSH
22801: LD_VAR 0 1
22805: PPUSH
22806: CALL_OW 255
22810: PUSH
22811: EMPTY
22812: LIST
22813: LIST
22814: PUSH
22815: LD_INT 2
22817: PUSH
22818: LD_INT 30
22820: PUSH
22821: LD_INT 36
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: PUSH
22828: LD_INT 34
22830: PUSH
22831: LD_INT 31
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: PUSH
22838: EMPTY
22839: LIST
22840: LIST
22841: LIST
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PPUSH
22847: CALL_OW 69
22851: ST_TO_ADDR
// if not tmp then
22852: LD_VAR 0 6
22856: NOT
22857: IFFALSE 22861
// exit ;
22859: GO 23109
// result := [ ] ;
22861: LD_ADDR_VAR 0 2
22865: PUSH
22866: EMPTY
22867: ST_TO_ADDR
// for i in tmp do
22868: LD_ADDR_VAR 0 3
22872: PUSH
22873: LD_VAR 0 6
22877: PUSH
22878: FOR_IN
22879: IFFALSE 22950
// begin t := UnitsInside ( i ) ;
22881: LD_ADDR_VAR 0 4
22885: PUSH
22886: LD_VAR 0 3
22890: PPUSH
22891: CALL_OW 313
22895: ST_TO_ADDR
// if t then
22896: LD_VAR 0 4
22900: IFFALSE 22948
// for j in t do
22902: LD_ADDR_VAR 0 7
22906: PUSH
22907: LD_VAR 0 4
22911: PUSH
22912: FOR_IN
22913: IFFALSE 22946
// result := Replace ( result , result + 1 , j ) ;
22915: LD_ADDR_VAR 0 2
22919: PUSH
22920: LD_VAR 0 2
22924: PPUSH
22925: LD_VAR 0 2
22929: PUSH
22930: LD_INT 1
22932: PLUS
22933: PPUSH
22934: LD_VAR 0 7
22938: PPUSH
22939: CALL_OW 1
22943: ST_TO_ADDR
22944: GO 22912
22946: POP
22947: POP
// end ;
22948: GO 22878
22950: POP
22951: POP
// if not result then
22952: LD_VAR 0 2
22956: NOT
22957: IFFALSE 22961
// exit ;
22959: GO 23109
// mech := result [ 1 ] ;
22961: LD_ADDR_VAR 0 5
22965: PUSH
22966: LD_VAR 0 2
22970: PUSH
22971: LD_INT 1
22973: ARRAY
22974: ST_TO_ADDR
// if result > 1 then
22975: LD_VAR 0 2
22979: PUSH
22980: LD_INT 1
22982: GREATER
22983: IFFALSE 23095
// begin for i = 2 to result do
22985: LD_ADDR_VAR 0 3
22989: PUSH
22990: DOUBLE
22991: LD_INT 2
22993: DEC
22994: ST_TO_ADDR
22995: LD_VAR 0 2
22999: PUSH
23000: FOR_TO
23001: IFFALSE 23093
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23003: LD_ADDR_VAR 0 4
23007: PUSH
23008: LD_VAR 0 2
23012: PUSH
23013: LD_VAR 0 3
23017: ARRAY
23018: PPUSH
23019: LD_INT 3
23021: PPUSH
23022: CALL_OW 259
23026: PUSH
23027: LD_VAR 0 2
23031: PUSH
23032: LD_VAR 0 3
23036: ARRAY
23037: PPUSH
23038: CALL_OW 432
23042: MINUS
23043: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23044: LD_VAR 0 4
23048: PUSH
23049: LD_VAR 0 5
23053: PPUSH
23054: LD_INT 3
23056: PPUSH
23057: CALL_OW 259
23061: PUSH
23062: LD_VAR 0 5
23066: PPUSH
23067: CALL_OW 432
23071: MINUS
23072: GREATEREQUAL
23073: IFFALSE 23091
// mech := result [ i ] ;
23075: LD_ADDR_VAR 0 5
23079: PUSH
23080: LD_VAR 0 2
23084: PUSH
23085: LD_VAR 0 3
23089: ARRAY
23090: ST_TO_ADDR
// end ;
23091: GO 23000
23093: POP
23094: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23095: LD_VAR 0 1
23099: PPUSH
23100: LD_VAR 0 5
23104: PPUSH
23105: CALL_OW 135
// end ;
23109: LD_VAR 0 2
23113: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23114: LD_INT 0
23116: PPUSH
23117: PPUSH
23118: PPUSH
23119: PPUSH
23120: PPUSH
23121: PPUSH
23122: PPUSH
23123: PPUSH
23124: PPUSH
23125: PPUSH
23126: PPUSH
23127: PPUSH
23128: PPUSH
// result := [ ] ;
23129: LD_ADDR_VAR 0 7
23133: PUSH
23134: EMPTY
23135: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23136: LD_VAR 0 1
23140: PPUSH
23141: CALL_OW 266
23145: PUSH
23146: LD_INT 0
23148: PUSH
23149: LD_INT 1
23151: PUSH
23152: EMPTY
23153: LIST
23154: LIST
23155: IN
23156: NOT
23157: IFFALSE 23161
// exit ;
23159: GO 24795
// if name then
23161: LD_VAR 0 3
23165: IFFALSE 23181
// SetBName ( base_dep , name ) ;
23167: LD_VAR 0 1
23171: PPUSH
23172: LD_VAR 0 3
23176: PPUSH
23177: CALL_OW 500
// base := GetBase ( base_dep ) ;
23181: LD_ADDR_VAR 0 15
23185: PUSH
23186: LD_VAR 0 1
23190: PPUSH
23191: CALL_OW 274
23195: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23196: LD_ADDR_VAR 0 16
23200: PUSH
23201: LD_VAR 0 1
23205: PPUSH
23206: CALL_OW 255
23210: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23211: LD_ADDR_VAR 0 17
23215: PUSH
23216: LD_VAR 0 1
23220: PPUSH
23221: CALL_OW 248
23225: ST_TO_ADDR
// if sources then
23226: LD_VAR 0 5
23230: IFFALSE 23277
// for i = 1 to 3 do
23232: LD_ADDR_VAR 0 8
23236: PUSH
23237: DOUBLE
23238: LD_INT 1
23240: DEC
23241: ST_TO_ADDR
23242: LD_INT 3
23244: PUSH
23245: FOR_TO
23246: IFFALSE 23275
// AddResourceType ( base , i , sources [ i ] ) ;
23248: LD_VAR 0 15
23252: PPUSH
23253: LD_VAR 0 8
23257: PPUSH
23258: LD_VAR 0 5
23262: PUSH
23263: LD_VAR 0 8
23267: ARRAY
23268: PPUSH
23269: CALL_OW 276
23273: GO 23245
23275: POP
23276: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23277: LD_ADDR_VAR 0 18
23281: PUSH
23282: LD_VAR 0 15
23286: PPUSH
23287: LD_VAR 0 2
23291: PPUSH
23292: LD_INT 1
23294: PPUSH
23295: CALL 22538 0 3
23299: ST_TO_ADDR
// InitHc ;
23300: CALL_OW 19
// InitUc ;
23304: CALL_OW 18
// uc_side := side ;
23308: LD_ADDR_OWVAR 20
23312: PUSH
23313: LD_VAR 0 16
23317: ST_TO_ADDR
// uc_nation := nation ;
23318: LD_ADDR_OWVAR 21
23322: PUSH
23323: LD_VAR 0 17
23327: ST_TO_ADDR
// if buildings then
23328: LD_VAR 0 18
23332: IFFALSE 24654
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23334: LD_ADDR_VAR 0 19
23338: PUSH
23339: LD_VAR 0 18
23343: PPUSH
23344: LD_INT 2
23346: PUSH
23347: LD_INT 30
23349: PUSH
23350: LD_INT 29
23352: PUSH
23353: EMPTY
23354: LIST
23355: LIST
23356: PUSH
23357: LD_INT 30
23359: PUSH
23360: LD_INT 30
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PUSH
23367: EMPTY
23368: LIST
23369: LIST
23370: LIST
23371: PPUSH
23372: CALL_OW 72
23376: ST_TO_ADDR
// if tmp then
23377: LD_VAR 0 19
23381: IFFALSE 23429
// for i in tmp do
23383: LD_ADDR_VAR 0 8
23387: PUSH
23388: LD_VAR 0 19
23392: PUSH
23393: FOR_IN
23394: IFFALSE 23427
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23396: LD_VAR 0 8
23400: PPUSH
23401: CALL_OW 250
23405: PPUSH
23406: LD_VAR 0 8
23410: PPUSH
23411: CALL_OW 251
23415: PPUSH
23416: LD_VAR 0 16
23420: PPUSH
23421: CALL_OW 441
23425: GO 23393
23427: POP
23428: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23429: LD_VAR 0 18
23433: PPUSH
23434: LD_INT 2
23436: PUSH
23437: LD_INT 30
23439: PUSH
23440: LD_INT 32
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 30
23449: PUSH
23450: LD_INT 33
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: LIST
23461: PPUSH
23462: CALL_OW 72
23466: IFFALSE 23554
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23468: LD_ADDR_VAR 0 8
23472: PUSH
23473: LD_VAR 0 18
23477: PPUSH
23478: LD_INT 2
23480: PUSH
23481: LD_INT 30
23483: PUSH
23484: LD_INT 32
23486: PUSH
23487: EMPTY
23488: LIST
23489: LIST
23490: PUSH
23491: LD_INT 30
23493: PUSH
23494: LD_INT 33
23496: PUSH
23497: EMPTY
23498: LIST
23499: LIST
23500: PUSH
23501: EMPTY
23502: LIST
23503: LIST
23504: LIST
23505: PPUSH
23506: CALL_OW 72
23510: PUSH
23511: FOR_IN
23512: IFFALSE 23552
// begin if not GetBWeapon ( i ) then
23514: LD_VAR 0 8
23518: PPUSH
23519: CALL_OW 269
23523: NOT
23524: IFFALSE 23550
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23526: LD_VAR 0 8
23530: PPUSH
23531: LD_VAR 0 8
23535: PPUSH
23536: LD_VAR 0 2
23540: PPUSH
23541: CALL 24800 0 2
23545: PPUSH
23546: CALL_OW 431
// end ;
23550: GO 23511
23552: POP
23553: POP
// end ; for i = 1 to personel do
23554: LD_ADDR_VAR 0 8
23558: PUSH
23559: DOUBLE
23560: LD_INT 1
23562: DEC
23563: ST_TO_ADDR
23564: LD_VAR 0 6
23568: PUSH
23569: FOR_TO
23570: IFFALSE 24634
// begin if i > 4 then
23572: LD_VAR 0 8
23576: PUSH
23577: LD_INT 4
23579: GREATER
23580: IFFALSE 23584
// break ;
23582: GO 24634
// case i of 1 :
23584: LD_VAR 0 8
23588: PUSH
23589: LD_INT 1
23591: DOUBLE
23592: EQUAL
23593: IFTRUE 23597
23595: GO 23677
23597: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23598: LD_ADDR_VAR 0 12
23602: PUSH
23603: LD_VAR 0 18
23607: PPUSH
23608: LD_INT 22
23610: PUSH
23611: LD_VAR 0 16
23615: PUSH
23616: EMPTY
23617: LIST
23618: LIST
23619: PUSH
23620: LD_INT 58
23622: PUSH
23623: EMPTY
23624: LIST
23625: PUSH
23626: LD_INT 2
23628: PUSH
23629: LD_INT 30
23631: PUSH
23632: LD_INT 32
23634: PUSH
23635: EMPTY
23636: LIST
23637: LIST
23638: PUSH
23639: LD_INT 30
23641: PUSH
23642: LD_INT 4
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: LD_INT 30
23651: PUSH
23652: LD_INT 5
23654: PUSH
23655: EMPTY
23656: LIST
23657: LIST
23658: PUSH
23659: EMPTY
23660: LIST
23661: LIST
23662: LIST
23663: LIST
23664: PUSH
23665: EMPTY
23666: LIST
23667: LIST
23668: LIST
23669: PPUSH
23670: CALL_OW 72
23674: ST_TO_ADDR
23675: GO 23899
23677: LD_INT 2
23679: DOUBLE
23680: EQUAL
23681: IFTRUE 23685
23683: GO 23747
23685: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23686: LD_ADDR_VAR 0 12
23690: PUSH
23691: LD_VAR 0 18
23695: PPUSH
23696: LD_INT 22
23698: PUSH
23699: LD_VAR 0 16
23703: PUSH
23704: EMPTY
23705: LIST
23706: LIST
23707: PUSH
23708: LD_INT 2
23710: PUSH
23711: LD_INT 30
23713: PUSH
23714: LD_INT 0
23716: PUSH
23717: EMPTY
23718: LIST
23719: LIST
23720: PUSH
23721: LD_INT 30
23723: PUSH
23724: LD_INT 1
23726: PUSH
23727: EMPTY
23728: LIST
23729: LIST
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: LIST
23735: PUSH
23736: EMPTY
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: ST_TO_ADDR
23745: GO 23899
23747: LD_INT 3
23749: DOUBLE
23750: EQUAL
23751: IFTRUE 23755
23753: GO 23817
23755: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23756: LD_ADDR_VAR 0 12
23760: PUSH
23761: LD_VAR 0 18
23765: PPUSH
23766: LD_INT 22
23768: PUSH
23769: LD_VAR 0 16
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PUSH
23778: LD_INT 2
23780: PUSH
23781: LD_INT 30
23783: PUSH
23784: LD_INT 2
23786: PUSH
23787: EMPTY
23788: LIST
23789: LIST
23790: PUSH
23791: LD_INT 30
23793: PUSH
23794: LD_INT 3
23796: PUSH
23797: EMPTY
23798: LIST
23799: LIST
23800: PUSH
23801: EMPTY
23802: LIST
23803: LIST
23804: LIST
23805: PUSH
23806: EMPTY
23807: LIST
23808: LIST
23809: PPUSH
23810: CALL_OW 72
23814: ST_TO_ADDR
23815: GO 23899
23817: LD_INT 4
23819: DOUBLE
23820: EQUAL
23821: IFTRUE 23825
23823: GO 23898
23825: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23826: LD_ADDR_VAR 0 12
23830: PUSH
23831: LD_VAR 0 18
23835: PPUSH
23836: LD_INT 22
23838: PUSH
23839: LD_VAR 0 16
23843: PUSH
23844: EMPTY
23845: LIST
23846: LIST
23847: PUSH
23848: LD_INT 2
23850: PUSH
23851: LD_INT 30
23853: PUSH
23854: LD_INT 6
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: LD_INT 30
23863: PUSH
23864: LD_INT 7
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PUSH
23871: LD_INT 30
23873: PUSH
23874: LD_INT 8
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: PUSH
23881: EMPTY
23882: LIST
23883: LIST
23884: LIST
23885: LIST
23886: PUSH
23887: EMPTY
23888: LIST
23889: LIST
23890: PPUSH
23891: CALL_OW 72
23895: ST_TO_ADDR
23896: GO 23899
23898: POP
// if i = 1 then
23899: LD_VAR 0 8
23903: PUSH
23904: LD_INT 1
23906: EQUAL
23907: IFFALSE 24018
// begin tmp := [ ] ;
23909: LD_ADDR_VAR 0 19
23913: PUSH
23914: EMPTY
23915: ST_TO_ADDR
// for j in f do
23916: LD_ADDR_VAR 0 9
23920: PUSH
23921: LD_VAR 0 12
23925: PUSH
23926: FOR_IN
23927: IFFALSE 24000
// if GetBType ( j ) = b_bunker then
23929: LD_VAR 0 9
23933: PPUSH
23934: CALL_OW 266
23938: PUSH
23939: LD_INT 32
23941: EQUAL
23942: IFFALSE 23969
// tmp := Insert ( tmp , 1 , j ) else
23944: LD_ADDR_VAR 0 19
23948: PUSH
23949: LD_VAR 0 19
23953: PPUSH
23954: LD_INT 1
23956: PPUSH
23957: LD_VAR 0 9
23961: PPUSH
23962: CALL_OW 2
23966: ST_TO_ADDR
23967: GO 23998
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23969: LD_ADDR_VAR 0 19
23973: PUSH
23974: LD_VAR 0 19
23978: PPUSH
23979: LD_VAR 0 19
23983: PUSH
23984: LD_INT 1
23986: PLUS
23987: PPUSH
23988: LD_VAR 0 9
23992: PPUSH
23993: CALL_OW 2
23997: ST_TO_ADDR
23998: GO 23926
24000: POP
24001: POP
// if tmp then
24002: LD_VAR 0 19
24006: IFFALSE 24018
// f := tmp ;
24008: LD_ADDR_VAR 0 12
24012: PUSH
24013: LD_VAR 0 19
24017: ST_TO_ADDR
// end ; x := personel [ i ] ;
24018: LD_ADDR_VAR 0 13
24022: PUSH
24023: LD_VAR 0 6
24027: PUSH
24028: LD_VAR 0 8
24032: ARRAY
24033: ST_TO_ADDR
// if x = - 1 then
24034: LD_VAR 0 13
24038: PUSH
24039: LD_INT 1
24041: NEG
24042: EQUAL
24043: IFFALSE 24252
// begin for j in f do
24045: LD_ADDR_VAR 0 9
24049: PUSH
24050: LD_VAR 0 12
24054: PUSH
24055: FOR_IN
24056: IFFALSE 24248
// repeat InitHc ;
24058: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24062: LD_VAR 0 9
24066: PPUSH
24067: CALL_OW 266
24071: PUSH
24072: LD_INT 5
24074: EQUAL
24075: IFFALSE 24145
// begin if UnitsInside ( j ) < 3 then
24077: LD_VAR 0 9
24081: PPUSH
24082: CALL_OW 313
24086: PUSH
24087: LD_INT 3
24089: LESS
24090: IFFALSE 24126
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24092: LD_INT 0
24094: PPUSH
24095: LD_INT 5
24097: PUSH
24098: LD_INT 8
24100: PUSH
24101: LD_INT 9
24103: PUSH
24104: EMPTY
24105: LIST
24106: LIST
24107: LIST
24108: PUSH
24109: LD_VAR 0 17
24113: ARRAY
24114: PPUSH
24115: LD_VAR 0 4
24119: PPUSH
24120: CALL_OW 380
24124: GO 24143
// PrepareHuman ( false , i , skill ) ;
24126: LD_INT 0
24128: PPUSH
24129: LD_VAR 0 8
24133: PPUSH
24134: LD_VAR 0 4
24138: PPUSH
24139: CALL_OW 380
// end else
24143: GO 24162
// PrepareHuman ( false , i , skill ) ;
24145: LD_INT 0
24147: PPUSH
24148: LD_VAR 0 8
24152: PPUSH
24153: LD_VAR 0 4
24157: PPUSH
24158: CALL_OW 380
// un := CreateHuman ;
24162: LD_ADDR_VAR 0 14
24166: PUSH
24167: CALL_OW 44
24171: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24172: LD_ADDR_VAR 0 7
24176: PUSH
24177: LD_VAR 0 7
24181: PPUSH
24182: LD_INT 1
24184: PPUSH
24185: LD_VAR 0 14
24189: PPUSH
24190: CALL_OW 2
24194: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24195: LD_VAR 0 14
24199: PPUSH
24200: LD_VAR 0 9
24204: PPUSH
24205: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24209: LD_VAR 0 9
24213: PPUSH
24214: CALL_OW 313
24218: PUSH
24219: LD_INT 6
24221: EQUAL
24222: PUSH
24223: LD_VAR 0 9
24227: PPUSH
24228: CALL_OW 266
24232: PUSH
24233: LD_INT 32
24235: PUSH
24236: LD_INT 31
24238: PUSH
24239: EMPTY
24240: LIST
24241: LIST
24242: IN
24243: OR
24244: IFFALSE 24058
24246: GO 24055
24248: POP
24249: POP
// end else
24250: GO 24632
// for j = 1 to x do
24252: LD_ADDR_VAR 0 9
24256: PUSH
24257: DOUBLE
24258: LD_INT 1
24260: DEC
24261: ST_TO_ADDR
24262: LD_VAR 0 13
24266: PUSH
24267: FOR_TO
24268: IFFALSE 24630
// begin InitHc ;
24270: CALL_OW 19
// if not f then
24274: LD_VAR 0 12
24278: NOT
24279: IFFALSE 24368
// begin PrepareHuman ( false , i , skill ) ;
24281: LD_INT 0
24283: PPUSH
24284: LD_VAR 0 8
24288: PPUSH
24289: LD_VAR 0 4
24293: PPUSH
24294: CALL_OW 380
// un := CreateHuman ;
24298: LD_ADDR_VAR 0 14
24302: PUSH
24303: CALL_OW 44
24307: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24308: LD_ADDR_VAR 0 7
24312: PUSH
24313: LD_VAR 0 7
24317: PPUSH
24318: LD_INT 1
24320: PPUSH
24321: LD_VAR 0 14
24325: PPUSH
24326: CALL_OW 2
24330: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24331: LD_VAR 0 14
24335: PPUSH
24336: LD_VAR 0 1
24340: PPUSH
24341: CALL_OW 250
24345: PPUSH
24346: LD_VAR 0 1
24350: PPUSH
24351: CALL_OW 251
24355: PPUSH
24356: LD_INT 10
24358: PPUSH
24359: LD_INT 0
24361: PPUSH
24362: CALL_OW 50
// continue ;
24366: GO 24267
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24368: LD_VAR 0 12
24372: PUSH
24373: LD_INT 1
24375: ARRAY
24376: PPUSH
24377: CALL_OW 313
24381: PUSH
24382: LD_VAR 0 12
24386: PUSH
24387: LD_INT 1
24389: ARRAY
24390: PPUSH
24391: CALL_OW 266
24395: PUSH
24396: LD_INT 32
24398: PUSH
24399: LD_INT 31
24401: PUSH
24402: EMPTY
24403: LIST
24404: LIST
24405: IN
24406: AND
24407: PUSH
24408: LD_VAR 0 12
24412: PUSH
24413: LD_INT 1
24415: ARRAY
24416: PPUSH
24417: CALL_OW 313
24421: PUSH
24422: LD_INT 6
24424: EQUAL
24425: OR
24426: IFFALSE 24446
// f := Delete ( f , 1 ) ;
24428: LD_ADDR_VAR 0 12
24432: PUSH
24433: LD_VAR 0 12
24437: PPUSH
24438: LD_INT 1
24440: PPUSH
24441: CALL_OW 3
24445: ST_TO_ADDR
// if not f then
24446: LD_VAR 0 12
24450: NOT
24451: IFFALSE 24469
// begin x := x + 2 ;
24453: LD_ADDR_VAR 0 13
24457: PUSH
24458: LD_VAR 0 13
24462: PUSH
24463: LD_INT 2
24465: PLUS
24466: ST_TO_ADDR
// continue ;
24467: GO 24267
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24469: LD_VAR 0 12
24473: PUSH
24474: LD_INT 1
24476: ARRAY
24477: PPUSH
24478: CALL_OW 266
24482: PUSH
24483: LD_INT 5
24485: EQUAL
24486: IFFALSE 24560
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24488: LD_VAR 0 12
24492: PUSH
24493: LD_INT 1
24495: ARRAY
24496: PPUSH
24497: CALL_OW 313
24501: PUSH
24502: LD_INT 3
24504: LESS
24505: IFFALSE 24541
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24507: LD_INT 0
24509: PPUSH
24510: LD_INT 5
24512: PUSH
24513: LD_INT 8
24515: PUSH
24516: LD_INT 9
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: LIST
24523: PUSH
24524: LD_VAR 0 17
24528: ARRAY
24529: PPUSH
24530: LD_VAR 0 4
24534: PPUSH
24535: CALL_OW 380
24539: GO 24558
// PrepareHuman ( false , i , skill ) ;
24541: LD_INT 0
24543: PPUSH
24544: LD_VAR 0 8
24548: PPUSH
24549: LD_VAR 0 4
24553: PPUSH
24554: CALL_OW 380
// end else
24558: GO 24577
// PrepareHuman ( false , i , skill ) ;
24560: LD_INT 0
24562: PPUSH
24563: LD_VAR 0 8
24567: PPUSH
24568: LD_VAR 0 4
24572: PPUSH
24573: CALL_OW 380
// un := CreateHuman ;
24577: LD_ADDR_VAR 0 14
24581: PUSH
24582: CALL_OW 44
24586: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24587: LD_ADDR_VAR 0 7
24591: PUSH
24592: LD_VAR 0 7
24596: PPUSH
24597: LD_INT 1
24599: PPUSH
24600: LD_VAR 0 14
24604: PPUSH
24605: CALL_OW 2
24609: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24610: LD_VAR 0 14
24614: PPUSH
24615: LD_VAR 0 12
24619: PUSH
24620: LD_INT 1
24622: ARRAY
24623: PPUSH
24624: CALL_OW 52
// end ;
24628: GO 24267
24630: POP
24631: POP
// end ;
24632: GO 23569
24634: POP
24635: POP
// result := result ^ buildings ;
24636: LD_ADDR_VAR 0 7
24640: PUSH
24641: LD_VAR 0 7
24645: PUSH
24646: LD_VAR 0 18
24650: ADD
24651: ST_TO_ADDR
// end else
24652: GO 24795
// begin for i = 1 to personel do
24654: LD_ADDR_VAR 0 8
24658: PUSH
24659: DOUBLE
24660: LD_INT 1
24662: DEC
24663: ST_TO_ADDR
24664: LD_VAR 0 6
24668: PUSH
24669: FOR_TO
24670: IFFALSE 24793
// begin if i > 4 then
24672: LD_VAR 0 8
24676: PUSH
24677: LD_INT 4
24679: GREATER
24680: IFFALSE 24684
// break ;
24682: GO 24793
// x := personel [ i ] ;
24684: LD_ADDR_VAR 0 13
24688: PUSH
24689: LD_VAR 0 6
24693: PUSH
24694: LD_VAR 0 8
24698: ARRAY
24699: ST_TO_ADDR
// if x = - 1 then
24700: LD_VAR 0 13
24704: PUSH
24705: LD_INT 1
24707: NEG
24708: EQUAL
24709: IFFALSE 24713
// continue ;
24711: GO 24669
// PrepareHuman ( false , i , skill ) ;
24713: LD_INT 0
24715: PPUSH
24716: LD_VAR 0 8
24720: PPUSH
24721: LD_VAR 0 4
24725: PPUSH
24726: CALL_OW 380
// un := CreateHuman ;
24730: LD_ADDR_VAR 0 14
24734: PUSH
24735: CALL_OW 44
24739: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24740: LD_VAR 0 14
24744: PPUSH
24745: LD_VAR 0 1
24749: PPUSH
24750: CALL_OW 250
24754: PPUSH
24755: LD_VAR 0 1
24759: PPUSH
24760: CALL_OW 251
24764: PPUSH
24765: LD_INT 10
24767: PPUSH
24768: LD_INT 0
24770: PPUSH
24771: CALL_OW 50
// result := result ^ un ;
24775: LD_ADDR_VAR 0 7
24779: PUSH
24780: LD_VAR 0 7
24784: PUSH
24785: LD_VAR 0 14
24789: ADD
24790: ST_TO_ADDR
// end ;
24791: GO 24669
24793: POP
24794: POP
// end ; end ;
24795: LD_VAR 0 7
24799: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24800: LD_INT 0
24802: PPUSH
24803: PPUSH
24804: PPUSH
24805: PPUSH
24806: PPUSH
24807: PPUSH
24808: PPUSH
24809: PPUSH
24810: PPUSH
24811: PPUSH
24812: PPUSH
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
// result := false ;
24818: LD_ADDR_VAR 0 3
24822: PUSH
24823: LD_INT 0
24825: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24826: LD_VAR 0 1
24830: NOT
24831: PUSH
24832: LD_VAR 0 1
24836: PPUSH
24837: CALL_OW 266
24841: PUSH
24842: LD_INT 32
24844: PUSH
24845: LD_INT 33
24847: PUSH
24848: EMPTY
24849: LIST
24850: LIST
24851: IN
24852: NOT
24853: OR
24854: IFFALSE 24858
// exit ;
24856: GO 25967
// nat := GetNation ( tower ) ;
24858: LD_ADDR_VAR 0 12
24862: PUSH
24863: LD_VAR 0 1
24867: PPUSH
24868: CALL_OW 248
24872: ST_TO_ADDR
// side := GetSide ( tower ) ;
24873: LD_ADDR_VAR 0 16
24877: PUSH
24878: LD_VAR 0 1
24882: PPUSH
24883: CALL_OW 255
24887: ST_TO_ADDR
// x := GetX ( tower ) ;
24888: LD_ADDR_VAR 0 10
24892: PUSH
24893: LD_VAR 0 1
24897: PPUSH
24898: CALL_OW 250
24902: ST_TO_ADDR
// y := GetY ( tower ) ;
24903: LD_ADDR_VAR 0 11
24907: PUSH
24908: LD_VAR 0 1
24912: PPUSH
24913: CALL_OW 251
24917: ST_TO_ADDR
// if not x or not y then
24918: LD_VAR 0 10
24922: NOT
24923: PUSH
24924: LD_VAR 0 11
24928: NOT
24929: OR
24930: IFFALSE 24934
// exit ;
24932: GO 25967
// weapon := 0 ;
24934: LD_ADDR_VAR 0 18
24938: PUSH
24939: LD_INT 0
24941: ST_TO_ADDR
// fac_list := [ ] ;
24942: LD_ADDR_VAR 0 17
24946: PUSH
24947: EMPTY
24948: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24949: LD_ADDR_VAR 0 6
24953: PUSH
24954: LD_VAR 0 1
24958: PPUSH
24959: CALL_OW 274
24963: PPUSH
24964: LD_VAR 0 2
24968: PPUSH
24969: LD_INT 0
24971: PPUSH
24972: CALL 22538 0 3
24976: PPUSH
24977: LD_INT 30
24979: PUSH
24980: LD_INT 3
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 72
24991: ST_TO_ADDR
// if not factories then
24992: LD_VAR 0 6
24996: NOT
24997: IFFALSE 25001
// exit ;
24999: GO 25967
// for i in factories do
25001: LD_ADDR_VAR 0 8
25005: PUSH
25006: LD_VAR 0 6
25010: PUSH
25011: FOR_IN
25012: IFFALSE 25037
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25014: LD_ADDR_VAR 0 17
25018: PUSH
25019: LD_VAR 0 17
25023: PUSH
25024: LD_VAR 0 8
25028: PPUSH
25029: CALL_OW 478
25033: UNION
25034: ST_TO_ADDR
25035: GO 25011
25037: POP
25038: POP
// if not fac_list then
25039: LD_VAR 0 17
25043: NOT
25044: IFFALSE 25048
// exit ;
25046: GO 25967
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25048: LD_ADDR_VAR 0 5
25052: PUSH
25053: LD_INT 4
25055: PUSH
25056: LD_INT 5
25058: PUSH
25059: LD_INT 9
25061: PUSH
25062: LD_INT 10
25064: PUSH
25065: LD_INT 6
25067: PUSH
25068: LD_INT 7
25070: PUSH
25071: LD_INT 11
25073: PUSH
25074: EMPTY
25075: LIST
25076: LIST
25077: LIST
25078: LIST
25079: LIST
25080: LIST
25081: LIST
25082: PUSH
25083: LD_INT 27
25085: PUSH
25086: LD_INT 28
25088: PUSH
25089: LD_INT 26
25091: PUSH
25092: LD_INT 30
25094: PUSH
25095: EMPTY
25096: LIST
25097: LIST
25098: LIST
25099: LIST
25100: PUSH
25101: LD_INT 43
25103: PUSH
25104: LD_INT 44
25106: PUSH
25107: LD_INT 46
25109: PUSH
25110: LD_INT 45
25112: PUSH
25113: LD_INT 47
25115: PUSH
25116: LD_INT 49
25118: PUSH
25119: EMPTY
25120: LIST
25121: LIST
25122: LIST
25123: LIST
25124: LIST
25125: LIST
25126: PUSH
25127: EMPTY
25128: LIST
25129: LIST
25130: LIST
25131: PUSH
25132: LD_VAR 0 12
25136: ARRAY
25137: ST_TO_ADDR
// list := list isect fac_list ;
25138: LD_ADDR_VAR 0 5
25142: PUSH
25143: LD_VAR 0 5
25147: PUSH
25148: LD_VAR 0 17
25152: ISECT
25153: ST_TO_ADDR
// if not list then
25154: LD_VAR 0 5
25158: NOT
25159: IFFALSE 25163
// exit ;
25161: GO 25967
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25163: LD_VAR 0 12
25167: PUSH
25168: LD_INT 3
25170: EQUAL
25171: PUSH
25172: LD_INT 49
25174: PUSH
25175: LD_VAR 0 5
25179: IN
25180: AND
25181: PUSH
25182: LD_INT 31
25184: PPUSH
25185: LD_VAR 0 16
25189: PPUSH
25190: CALL_OW 321
25194: PUSH
25195: LD_INT 2
25197: EQUAL
25198: AND
25199: IFFALSE 25259
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25201: LD_INT 22
25203: PUSH
25204: LD_VAR 0 16
25208: PUSH
25209: EMPTY
25210: LIST
25211: LIST
25212: PUSH
25213: LD_INT 35
25215: PUSH
25216: LD_INT 49
25218: PUSH
25219: EMPTY
25220: LIST
25221: LIST
25222: PUSH
25223: LD_INT 91
25225: PUSH
25226: LD_VAR 0 1
25230: PUSH
25231: LD_INT 10
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: LIST
25238: PUSH
25239: EMPTY
25240: LIST
25241: LIST
25242: LIST
25243: PPUSH
25244: CALL_OW 69
25248: NOT
25249: IFFALSE 25259
// weapon := ru_time_lapser ;
25251: LD_ADDR_VAR 0 18
25255: PUSH
25256: LD_INT 49
25258: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25259: LD_VAR 0 12
25263: PUSH
25264: LD_INT 1
25266: PUSH
25267: LD_INT 2
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: IN
25274: PUSH
25275: LD_INT 11
25277: PUSH
25278: LD_VAR 0 5
25282: IN
25283: PUSH
25284: LD_INT 30
25286: PUSH
25287: LD_VAR 0 5
25291: IN
25292: OR
25293: AND
25294: PUSH
25295: LD_INT 6
25297: PPUSH
25298: LD_VAR 0 16
25302: PPUSH
25303: CALL_OW 321
25307: PUSH
25308: LD_INT 2
25310: EQUAL
25311: AND
25312: IFFALSE 25477
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25314: LD_INT 22
25316: PUSH
25317: LD_VAR 0 16
25321: PUSH
25322: EMPTY
25323: LIST
25324: LIST
25325: PUSH
25326: LD_INT 2
25328: PUSH
25329: LD_INT 35
25331: PUSH
25332: LD_INT 11
25334: PUSH
25335: EMPTY
25336: LIST
25337: LIST
25338: PUSH
25339: LD_INT 35
25341: PUSH
25342: LD_INT 30
25344: PUSH
25345: EMPTY
25346: LIST
25347: LIST
25348: PUSH
25349: EMPTY
25350: LIST
25351: LIST
25352: LIST
25353: PUSH
25354: LD_INT 91
25356: PUSH
25357: LD_VAR 0 1
25361: PUSH
25362: LD_INT 18
25364: PUSH
25365: EMPTY
25366: LIST
25367: LIST
25368: LIST
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: LIST
25374: PPUSH
25375: CALL_OW 69
25379: NOT
25380: PUSH
25381: LD_INT 22
25383: PUSH
25384: LD_VAR 0 16
25388: PUSH
25389: EMPTY
25390: LIST
25391: LIST
25392: PUSH
25393: LD_INT 2
25395: PUSH
25396: LD_INT 30
25398: PUSH
25399: LD_INT 32
25401: PUSH
25402: EMPTY
25403: LIST
25404: LIST
25405: PUSH
25406: LD_INT 30
25408: PUSH
25409: LD_INT 33
25411: PUSH
25412: EMPTY
25413: LIST
25414: LIST
25415: PUSH
25416: EMPTY
25417: LIST
25418: LIST
25419: LIST
25420: PUSH
25421: LD_INT 91
25423: PUSH
25424: LD_VAR 0 1
25428: PUSH
25429: LD_INT 12
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: LIST
25436: PUSH
25437: EMPTY
25438: LIST
25439: LIST
25440: LIST
25441: PUSH
25442: EMPTY
25443: LIST
25444: PPUSH
25445: CALL_OW 69
25449: PUSH
25450: LD_INT 2
25452: GREATER
25453: AND
25454: IFFALSE 25477
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25456: LD_ADDR_VAR 0 18
25460: PUSH
25461: LD_INT 11
25463: PUSH
25464: LD_INT 30
25466: PUSH
25467: EMPTY
25468: LIST
25469: LIST
25470: PUSH
25471: LD_VAR 0 12
25475: ARRAY
25476: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25477: LD_VAR 0 18
25481: NOT
25482: PUSH
25483: LD_INT 40
25485: PPUSH
25486: LD_VAR 0 16
25490: PPUSH
25491: CALL_OW 321
25495: PUSH
25496: LD_INT 2
25498: EQUAL
25499: AND
25500: PUSH
25501: LD_INT 7
25503: PUSH
25504: LD_VAR 0 5
25508: IN
25509: PUSH
25510: LD_INT 28
25512: PUSH
25513: LD_VAR 0 5
25517: IN
25518: OR
25519: PUSH
25520: LD_INT 45
25522: PUSH
25523: LD_VAR 0 5
25527: IN
25528: OR
25529: AND
25530: IFFALSE 25784
// begin hex := GetHexInfo ( x , y ) ;
25532: LD_ADDR_VAR 0 4
25536: PUSH
25537: LD_VAR 0 10
25541: PPUSH
25542: LD_VAR 0 11
25546: PPUSH
25547: CALL_OW 546
25551: ST_TO_ADDR
// if hex [ 1 ] then
25552: LD_VAR 0 4
25556: PUSH
25557: LD_INT 1
25559: ARRAY
25560: IFFALSE 25564
// exit ;
25562: GO 25967
// height := hex [ 2 ] ;
25564: LD_ADDR_VAR 0 15
25568: PUSH
25569: LD_VAR 0 4
25573: PUSH
25574: LD_INT 2
25576: ARRAY
25577: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25578: LD_ADDR_VAR 0 14
25582: PUSH
25583: LD_INT 0
25585: PUSH
25586: LD_INT 2
25588: PUSH
25589: LD_INT 3
25591: PUSH
25592: LD_INT 5
25594: PUSH
25595: EMPTY
25596: LIST
25597: LIST
25598: LIST
25599: LIST
25600: ST_TO_ADDR
// for i in tmp do
25601: LD_ADDR_VAR 0 8
25605: PUSH
25606: LD_VAR 0 14
25610: PUSH
25611: FOR_IN
25612: IFFALSE 25782
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25614: LD_ADDR_VAR 0 9
25618: PUSH
25619: LD_VAR 0 10
25623: PPUSH
25624: LD_VAR 0 8
25628: PPUSH
25629: LD_INT 5
25631: PPUSH
25632: CALL_OW 272
25636: PUSH
25637: LD_VAR 0 11
25641: PPUSH
25642: LD_VAR 0 8
25646: PPUSH
25647: LD_INT 5
25649: PPUSH
25650: CALL_OW 273
25654: PUSH
25655: EMPTY
25656: LIST
25657: LIST
25658: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25659: LD_VAR 0 9
25663: PUSH
25664: LD_INT 1
25666: ARRAY
25667: PPUSH
25668: LD_VAR 0 9
25672: PUSH
25673: LD_INT 2
25675: ARRAY
25676: PPUSH
25677: CALL_OW 488
25681: IFFALSE 25780
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25683: LD_ADDR_VAR 0 4
25687: PUSH
25688: LD_VAR 0 9
25692: PUSH
25693: LD_INT 1
25695: ARRAY
25696: PPUSH
25697: LD_VAR 0 9
25701: PUSH
25702: LD_INT 2
25704: ARRAY
25705: PPUSH
25706: CALL_OW 546
25710: ST_TO_ADDR
// if hex [ 1 ] then
25711: LD_VAR 0 4
25715: PUSH
25716: LD_INT 1
25718: ARRAY
25719: IFFALSE 25723
// continue ;
25721: GO 25611
// h := hex [ 2 ] ;
25723: LD_ADDR_VAR 0 13
25727: PUSH
25728: LD_VAR 0 4
25732: PUSH
25733: LD_INT 2
25735: ARRAY
25736: ST_TO_ADDR
// if h + 7 < height then
25737: LD_VAR 0 13
25741: PUSH
25742: LD_INT 7
25744: PLUS
25745: PUSH
25746: LD_VAR 0 15
25750: LESS
25751: IFFALSE 25780
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25753: LD_ADDR_VAR 0 18
25757: PUSH
25758: LD_INT 7
25760: PUSH
25761: LD_INT 28
25763: PUSH
25764: LD_INT 45
25766: PUSH
25767: EMPTY
25768: LIST
25769: LIST
25770: LIST
25771: PUSH
25772: LD_VAR 0 12
25776: ARRAY
25777: ST_TO_ADDR
// break ;
25778: GO 25782
// end ; end ; end ;
25780: GO 25611
25782: POP
25783: POP
// end ; if not weapon then
25784: LD_VAR 0 18
25788: NOT
25789: IFFALSE 25849
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25791: LD_ADDR_VAR 0 5
25795: PUSH
25796: LD_VAR 0 5
25800: PUSH
25801: LD_INT 11
25803: PUSH
25804: LD_INT 30
25806: PUSH
25807: LD_INT 49
25809: PUSH
25810: EMPTY
25811: LIST
25812: LIST
25813: LIST
25814: DIFF
25815: ST_TO_ADDR
// if not list then
25816: LD_VAR 0 5
25820: NOT
25821: IFFALSE 25825
// exit ;
25823: GO 25967
// weapon := list [ rand ( 1 , list ) ] ;
25825: LD_ADDR_VAR 0 18
25829: PUSH
25830: LD_VAR 0 5
25834: PUSH
25835: LD_INT 1
25837: PPUSH
25838: LD_VAR 0 5
25842: PPUSH
25843: CALL_OW 12
25847: ARRAY
25848: ST_TO_ADDR
// end ; if weapon then
25849: LD_VAR 0 18
25853: IFFALSE 25967
// begin tmp := CostOfWeapon ( weapon ) ;
25855: LD_ADDR_VAR 0 14
25859: PUSH
25860: LD_VAR 0 18
25864: PPUSH
25865: CALL_OW 451
25869: ST_TO_ADDR
// j := GetBase ( tower ) ;
25870: LD_ADDR_VAR 0 9
25874: PUSH
25875: LD_VAR 0 1
25879: PPUSH
25880: CALL_OW 274
25884: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25885: LD_VAR 0 9
25889: PPUSH
25890: LD_INT 1
25892: PPUSH
25893: CALL_OW 275
25897: PUSH
25898: LD_VAR 0 14
25902: PUSH
25903: LD_INT 1
25905: ARRAY
25906: GREATEREQUAL
25907: PUSH
25908: LD_VAR 0 9
25912: PPUSH
25913: LD_INT 2
25915: PPUSH
25916: CALL_OW 275
25920: PUSH
25921: LD_VAR 0 14
25925: PUSH
25926: LD_INT 2
25928: ARRAY
25929: GREATEREQUAL
25930: AND
25931: PUSH
25932: LD_VAR 0 9
25936: PPUSH
25937: LD_INT 3
25939: PPUSH
25940: CALL_OW 275
25944: PUSH
25945: LD_VAR 0 14
25949: PUSH
25950: LD_INT 3
25952: ARRAY
25953: GREATEREQUAL
25954: AND
25955: IFFALSE 25967
// result := weapon ;
25957: LD_ADDR_VAR 0 3
25961: PUSH
25962: LD_VAR 0 18
25966: ST_TO_ADDR
// end ; end ;
25967: LD_VAR 0 3
25971: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25972: LD_INT 0
25974: PPUSH
25975: PPUSH
// result := true ;
25976: LD_ADDR_VAR 0 3
25980: PUSH
25981: LD_INT 1
25983: ST_TO_ADDR
// if array1 = array2 then
25984: LD_VAR 0 1
25988: PUSH
25989: LD_VAR 0 2
25993: EQUAL
25994: IFFALSE 26054
// begin for i = 1 to array1 do
25996: LD_ADDR_VAR 0 4
26000: PUSH
26001: DOUBLE
26002: LD_INT 1
26004: DEC
26005: ST_TO_ADDR
26006: LD_VAR 0 1
26010: PUSH
26011: FOR_TO
26012: IFFALSE 26050
// if array1 [ i ] <> array2 [ i ] then
26014: LD_VAR 0 1
26018: PUSH
26019: LD_VAR 0 4
26023: ARRAY
26024: PUSH
26025: LD_VAR 0 2
26029: PUSH
26030: LD_VAR 0 4
26034: ARRAY
26035: NONEQUAL
26036: IFFALSE 26048
// begin result := false ;
26038: LD_ADDR_VAR 0 3
26042: PUSH
26043: LD_INT 0
26045: ST_TO_ADDR
// break ;
26046: GO 26050
// end ;
26048: GO 26011
26050: POP
26051: POP
// end else
26052: GO 26062
// result := false ;
26054: LD_ADDR_VAR 0 3
26058: PUSH
26059: LD_INT 0
26061: ST_TO_ADDR
// end ;
26062: LD_VAR 0 3
26066: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26067: LD_INT 0
26069: PPUSH
26070: PPUSH
// if not array1 or not array2 then
26071: LD_VAR 0 1
26075: NOT
26076: PUSH
26077: LD_VAR 0 2
26081: NOT
26082: OR
26083: IFFALSE 26087
// exit ;
26085: GO 26151
// result := true ;
26087: LD_ADDR_VAR 0 3
26091: PUSH
26092: LD_INT 1
26094: ST_TO_ADDR
// for i = 1 to array1 do
26095: LD_ADDR_VAR 0 4
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_VAR 0 1
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26149
// if array1 [ i ] <> array2 [ i ] then
26113: LD_VAR 0 1
26117: PUSH
26118: LD_VAR 0 4
26122: ARRAY
26123: PUSH
26124: LD_VAR 0 2
26128: PUSH
26129: LD_VAR 0 4
26133: ARRAY
26134: NONEQUAL
26135: IFFALSE 26147
// begin result := false ;
26137: LD_ADDR_VAR 0 3
26141: PUSH
26142: LD_INT 0
26144: ST_TO_ADDR
// break ;
26145: GO 26149
// end ;
26147: GO 26110
26149: POP
26150: POP
// end ;
26151: LD_VAR 0 3
26155: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26156: LD_INT 0
26158: PPUSH
26159: PPUSH
26160: PPUSH
// pom := GetBase ( fac ) ;
26161: LD_ADDR_VAR 0 5
26165: PUSH
26166: LD_VAR 0 1
26170: PPUSH
26171: CALL_OW 274
26175: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26176: LD_ADDR_VAR 0 4
26180: PUSH
26181: LD_VAR 0 2
26185: PUSH
26186: LD_INT 1
26188: ARRAY
26189: PPUSH
26190: LD_VAR 0 2
26194: PUSH
26195: LD_INT 2
26197: ARRAY
26198: PPUSH
26199: LD_VAR 0 2
26203: PUSH
26204: LD_INT 3
26206: ARRAY
26207: PPUSH
26208: LD_VAR 0 2
26212: PUSH
26213: LD_INT 4
26215: ARRAY
26216: PPUSH
26217: CALL_OW 449
26221: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26222: LD_ADDR_VAR 0 3
26226: PUSH
26227: LD_VAR 0 5
26231: PPUSH
26232: LD_INT 1
26234: PPUSH
26235: CALL_OW 275
26239: PUSH
26240: LD_VAR 0 4
26244: PUSH
26245: LD_INT 1
26247: ARRAY
26248: GREATEREQUAL
26249: PUSH
26250: LD_VAR 0 5
26254: PPUSH
26255: LD_INT 2
26257: PPUSH
26258: CALL_OW 275
26262: PUSH
26263: LD_VAR 0 4
26267: PUSH
26268: LD_INT 2
26270: ARRAY
26271: GREATEREQUAL
26272: AND
26273: PUSH
26274: LD_VAR 0 5
26278: PPUSH
26279: LD_INT 3
26281: PPUSH
26282: CALL_OW 275
26286: PUSH
26287: LD_VAR 0 4
26291: PUSH
26292: LD_INT 3
26294: ARRAY
26295: GREATEREQUAL
26296: AND
26297: ST_TO_ADDR
// end ;
26298: LD_VAR 0 3
26302: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26303: LD_INT 0
26305: PPUSH
26306: PPUSH
26307: PPUSH
26308: PPUSH
// pom := GetBase ( building ) ;
26309: LD_ADDR_VAR 0 3
26313: PUSH
26314: LD_VAR 0 1
26318: PPUSH
26319: CALL_OW 274
26323: ST_TO_ADDR
// if not pom then
26324: LD_VAR 0 3
26328: NOT
26329: IFFALSE 26333
// exit ;
26331: GO 26503
// btype := GetBType ( building ) ;
26333: LD_ADDR_VAR 0 5
26337: PUSH
26338: LD_VAR 0 1
26342: PPUSH
26343: CALL_OW 266
26347: ST_TO_ADDR
// if btype = b_armoury then
26348: LD_VAR 0 5
26352: PUSH
26353: LD_INT 4
26355: EQUAL
26356: IFFALSE 26366
// btype := b_barracks ;
26358: LD_ADDR_VAR 0 5
26362: PUSH
26363: LD_INT 5
26365: ST_TO_ADDR
// if btype = b_depot then
26366: LD_VAR 0 5
26370: PUSH
26371: LD_INT 0
26373: EQUAL
26374: IFFALSE 26384
// btype := b_warehouse ;
26376: LD_ADDR_VAR 0 5
26380: PUSH
26381: LD_INT 1
26383: ST_TO_ADDR
// if btype = b_workshop then
26384: LD_VAR 0 5
26388: PUSH
26389: LD_INT 2
26391: EQUAL
26392: IFFALSE 26402
// btype := b_factory ;
26394: LD_ADDR_VAR 0 5
26398: PUSH
26399: LD_INT 3
26401: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26402: LD_ADDR_VAR 0 4
26406: PUSH
26407: LD_VAR 0 5
26411: PPUSH
26412: LD_VAR 0 1
26416: PPUSH
26417: CALL_OW 248
26421: PPUSH
26422: CALL_OW 450
26426: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26427: LD_ADDR_VAR 0 2
26431: PUSH
26432: LD_VAR 0 3
26436: PPUSH
26437: LD_INT 1
26439: PPUSH
26440: CALL_OW 275
26444: PUSH
26445: LD_VAR 0 4
26449: PUSH
26450: LD_INT 1
26452: ARRAY
26453: GREATEREQUAL
26454: PUSH
26455: LD_VAR 0 3
26459: PPUSH
26460: LD_INT 2
26462: PPUSH
26463: CALL_OW 275
26467: PUSH
26468: LD_VAR 0 4
26472: PUSH
26473: LD_INT 2
26475: ARRAY
26476: GREATEREQUAL
26477: AND
26478: PUSH
26479: LD_VAR 0 3
26483: PPUSH
26484: LD_INT 3
26486: PPUSH
26487: CALL_OW 275
26491: PUSH
26492: LD_VAR 0 4
26496: PUSH
26497: LD_INT 3
26499: ARRAY
26500: GREATEREQUAL
26501: AND
26502: ST_TO_ADDR
// end ;
26503: LD_VAR 0 2
26507: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26508: LD_INT 0
26510: PPUSH
26511: PPUSH
26512: PPUSH
// pom := GetBase ( building ) ;
26513: LD_ADDR_VAR 0 4
26517: PUSH
26518: LD_VAR 0 1
26522: PPUSH
26523: CALL_OW 274
26527: ST_TO_ADDR
// if not pom then
26528: LD_VAR 0 4
26532: NOT
26533: IFFALSE 26537
// exit ;
26535: GO 26638
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26537: LD_ADDR_VAR 0 5
26541: PUSH
26542: LD_VAR 0 2
26546: PPUSH
26547: LD_VAR 0 1
26551: PPUSH
26552: CALL_OW 248
26556: PPUSH
26557: CALL_OW 450
26561: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26562: LD_ADDR_VAR 0 3
26566: PUSH
26567: LD_VAR 0 4
26571: PPUSH
26572: LD_INT 1
26574: PPUSH
26575: CALL_OW 275
26579: PUSH
26580: LD_VAR 0 5
26584: PUSH
26585: LD_INT 1
26587: ARRAY
26588: GREATEREQUAL
26589: PUSH
26590: LD_VAR 0 4
26594: PPUSH
26595: LD_INT 2
26597: PPUSH
26598: CALL_OW 275
26602: PUSH
26603: LD_VAR 0 5
26607: PUSH
26608: LD_INT 2
26610: ARRAY
26611: GREATEREQUAL
26612: AND
26613: PUSH
26614: LD_VAR 0 4
26618: PPUSH
26619: LD_INT 3
26621: PPUSH
26622: CALL_OW 275
26626: PUSH
26627: LD_VAR 0 5
26631: PUSH
26632: LD_INT 3
26634: ARRAY
26635: GREATEREQUAL
26636: AND
26637: ST_TO_ADDR
// end ;
26638: LD_VAR 0 3
26642: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26643: LD_INT 0
26645: PPUSH
26646: PPUSH
26647: PPUSH
26648: PPUSH
26649: PPUSH
26650: PPUSH
26651: PPUSH
26652: PPUSH
26653: PPUSH
26654: PPUSH
26655: PPUSH
// result := false ;
26656: LD_ADDR_VAR 0 8
26660: PUSH
26661: LD_INT 0
26663: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26664: LD_VAR 0 5
26668: NOT
26669: PUSH
26670: LD_VAR 0 1
26674: NOT
26675: OR
26676: PUSH
26677: LD_VAR 0 2
26681: NOT
26682: OR
26683: PUSH
26684: LD_VAR 0 3
26688: NOT
26689: OR
26690: IFFALSE 26694
// exit ;
26692: GO 27508
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26694: LD_ADDR_VAR 0 14
26698: PUSH
26699: LD_VAR 0 1
26703: PPUSH
26704: LD_VAR 0 2
26708: PPUSH
26709: LD_VAR 0 3
26713: PPUSH
26714: LD_VAR 0 4
26718: PPUSH
26719: LD_VAR 0 5
26723: PUSH
26724: LD_INT 1
26726: ARRAY
26727: PPUSH
26728: CALL_OW 248
26732: PPUSH
26733: LD_INT 0
26735: PPUSH
26736: CALL 28745 0 6
26740: ST_TO_ADDR
// if not hexes then
26741: LD_VAR 0 14
26745: NOT
26746: IFFALSE 26750
// exit ;
26748: GO 27508
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26750: LD_ADDR_VAR 0 17
26754: PUSH
26755: LD_VAR 0 5
26759: PPUSH
26760: LD_INT 22
26762: PUSH
26763: LD_VAR 0 13
26767: PPUSH
26768: CALL_OW 255
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PUSH
26777: LD_INT 2
26779: PUSH
26780: LD_INT 30
26782: PUSH
26783: LD_INT 0
26785: PUSH
26786: EMPTY
26787: LIST
26788: LIST
26789: PUSH
26790: LD_INT 30
26792: PUSH
26793: LD_INT 1
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: EMPTY
26801: LIST
26802: LIST
26803: LIST
26804: PUSH
26805: EMPTY
26806: LIST
26807: LIST
26808: PPUSH
26809: CALL_OW 72
26813: ST_TO_ADDR
// for i = 1 to hexes do
26814: LD_ADDR_VAR 0 9
26818: PUSH
26819: DOUBLE
26820: LD_INT 1
26822: DEC
26823: ST_TO_ADDR
26824: LD_VAR 0 14
26828: PUSH
26829: FOR_TO
26830: IFFALSE 27506
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26832: LD_ADDR_VAR 0 13
26836: PUSH
26837: LD_VAR 0 14
26841: PUSH
26842: LD_VAR 0 9
26846: ARRAY
26847: PUSH
26848: LD_INT 1
26850: ARRAY
26851: PPUSH
26852: LD_VAR 0 14
26856: PUSH
26857: LD_VAR 0 9
26861: ARRAY
26862: PUSH
26863: LD_INT 2
26865: ARRAY
26866: PPUSH
26867: CALL_OW 428
26871: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26872: LD_VAR 0 14
26876: PUSH
26877: LD_VAR 0 9
26881: ARRAY
26882: PUSH
26883: LD_INT 1
26885: ARRAY
26886: PPUSH
26887: LD_VAR 0 14
26891: PUSH
26892: LD_VAR 0 9
26896: ARRAY
26897: PUSH
26898: LD_INT 2
26900: ARRAY
26901: PPUSH
26902: CALL_OW 351
26906: PUSH
26907: LD_VAR 0 14
26911: PUSH
26912: LD_VAR 0 9
26916: ARRAY
26917: PUSH
26918: LD_INT 1
26920: ARRAY
26921: PPUSH
26922: LD_VAR 0 14
26926: PUSH
26927: LD_VAR 0 9
26931: ARRAY
26932: PUSH
26933: LD_INT 2
26935: ARRAY
26936: PPUSH
26937: CALL_OW 488
26941: NOT
26942: OR
26943: PUSH
26944: LD_VAR 0 13
26948: PPUSH
26949: CALL_OW 247
26953: PUSH
26954: LD_INT 3
26956: EQUAL
26957: OR
26958: IFFALSE 26964
// exit ;
26960: POP
26961: POP
26962: GO 27508
// if not tmp then
26964: LD_VAR 0 13
26968: NOT
26969: IFFALSE 26973
// continue ;
26971: GO 26829
// result := true ;
26973: LD_ADDR_VAR 0 8
26977: PUSH
26978: LD_INT 1
26980: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26981: LD_VAR 0 6
26985: PUSH
26986: LD_VAR 0 13
26990: PPUSH
26991: CALL_OW 247
26995: PUSH
26996: LD_INT 2
26998: EQUAL
26999: AND
27000: PUSH
27001: LD_VAR 0 13
27005: PPUSH
27006: CALL_OW 263
27010: PUSH
27011: LD_INT 1
27013: EQUAL
27014: AND
27015: IFFALSE 27179
// begin if IsDrivenBy ( tmp ) then
27017: LD_VAR 0 13
27021: PPUSH
27022: CALL_OW 311
27026: IFFALSE 27030
// continue ;
27028: GO 26829
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27030: LD_VAR 0 6
27034: PPUSH
27035: LD_INT 3
27037: PUSH
27038: LD_INT 60
27040: PUSH
27041: EMPTY
27042: LIST
27043: PUSH
27044: EMPTY
27045: LIST
27046: LIST
27047: PUSH
27048: LD_INT 3
27050: PUSH
27051: LD_INT 55
27053: PUSH
27054: EMPTY
27055: LIST
27056: PUSH
27057: EMPTY
27058: LIST
27059: LIST
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: PPUSH
27065: CALL_OW 72
27069: IFFALSE 27177
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27071: LD_ADDR_VAR 0 18
27075: PUSH
27076: LD_VAR 0 6
27080: PPUSH
27081: LD_INT 3
27083: PUSH
27084: LD_INT 60
27086: PUSH
27087: EMPTY
27088: LIST
27089: PUSH
27090: EMPTY
27091: LIST
27092: LIST
27093: PUSH
27094: LD_INT 3
27096: PUSH
27097: LD_INT 55
27099: PUSH
27100: EMPTY
27101: LIST
27102: PUSH
27103: EMPTY
27104: LIST
27105: LIST
27106: PUSH
27107: EMPTY
27108: LIST
27109: LIST
27110: PPUSH
27111: CALL_OW 72
27115: PUSH
27116: LD_INT 1
27118: ARRAY
27119: ST_TO_ADDR
// if IsInUnit ( driver ) then
27120: LD_VAR 0 18
27124: PPUSH
27125: CALL_OW 310
27129: IFFALSE 27140
// ComExit ( driver ) ;
27131: LD_VAR 0 18
27135: PPUSH
27136: CALL 51929 0 1
// AddComEnterUnit ( driver , tmp ) ;
27140: LD_VAR 0 18
27144: PPUSH
27145: LD_VAR 0 13
27149: PPUSH
27150: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27154: LD_VAR 0 18
27158: PPUSH
27159: LD_VAR 0 7
27163: PPUSH
27164: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27168: LD_VAR 0 18
27172: PPUSH
27173: CALL_OW 181
// end ; continue ;
27177: GO 26829
// end ; if not cleaners or not tmp in cleaners then
27179: LD_VAR 0 6
27183: NOT
27184: PUSH
27185: LD_VAR 0 13
27189: PUSH
27190: LD_VAR 0 6
27194: IN
27195: NOT
27196: OR
27197: IFFALSE 27504
// begin if dep then
27199: LD_VAR 0 17
27203: IFFALSE 27339
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27205: LD_ADDR_VAR 0 16
27209: PUSH
27210: LD_VAR 0 17
27214: PUSH
27215: LD_INT 1
27217: ARRAY
27218: PPUSH
27219: CALL_OW 250
27223: PPUSH
27224: LD_VAR 0 17
27228: PUSH
27229: LD_INT 1
27231: ARRAY
27232: PPUSH
27233: CALL_OW 254
27237: PPUSH
27238: LD_INT 5
27240: PPUSH
27241: CALL_OW 272
27245: PUSH
27246: LD_VAR 0 17
27250: PUSH
27251: LD_INT 1
27253: ARRAY
27254: PPUSH
27255: CALL_OW 251
27259: PPUSH
27260: LD_VAR 0 17
27264: PUSH
27265: LD_INT 1
27267: ARRAY
27268: PPUSH
27269: CALL_OW 254
27273: PPUSH
27274: LD_INT 5
27276: PPUSH
27277: CALL_OW 273
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27286: LD_VAR 0 16
27290: PUSH
27291: LD_INT 1
27293: ARRAY
27294: PPUSH
27295: LD_VAR 0 16
27299: PUSH
27300: LD_INT 2
27302: ARRAY
27303: PPUSH
27304: CALL_OW 488
27308: IFFALSE 27339
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27310: LD_VAR 0 13
27314: PPUSH
27315: LD_VAR 0 16
27319: PUSH
27320: LD_INT 1
27322: ARRAY
27323: PPUSH
27324: LD_VAR 0 16
27328: PUSH
27329: LD_INT 2
27331: ARRAY
27332: PPUSH
27333: CALL_OW 111
// continue ;
27337: GO 26829
// end ; end ; r := GetDir ( tmp ) ;
27339: LD_ADDR_VAR 0 15
27343: PUSH
27344: LD_VAR 0 13
27348: PPUSH
27349: CALL_OW 254
27353: ST_TO_ADDR
// if r = 5 then
27354: LD_VAR 0 15
27358: PUSH
27359: LD_INT 5
27361: EQUAL
27362: IFFALSE 27372
// r := 0 ;
27364: LD_ADDR_VAR 0 15
27368: PUSH
27369: LD_INT 0
27371: ST_TO_ADDR
// for j = r to 5 do
27372: LD_ADDR_VAR 0 10
27376: PUSH
27377: DOUBLE
27378: LD_VAR 0 15
27382: DEC
27383: ST_TO_ADDR
27384: LD_INT 5
27386: PUSH
27387: FOR_TO
27388: IFFALSE 27502
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27390: LD_ADDR_VAR 0 11
27394: PUSH
27395: LD_VAR 0 13
27399: PPUSH
27400: CALL_OW 250
27404: PPUSH
27405: LD_VAR 0 10
27409: PPUSH
27410: LD_INT 2
27412: PPUSH
27413: CALL_OW 272
27417: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27418: LD_ADDR_VAR 0 12
27422: PUSH
27423: LD_VAR 0 13
27427: PPUSH
27428: CALL_OW 251
27432: PPUSH
27433: LD_VAR 0 10
27437: PPUSH
27438: LD_INT 2
27440: PPUSH
27441: CALL_OW 273
27445: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27446: LD_VAR 0 11
27450: PPUSH
27451: LD_VAR 0 12
27455: PPUSH
27456: CALL_OW 488
27460: PUSH
27461: LD_VAR 0 11
27465: PPUSH
27466: LD_VAR 0 12
27470: PPUSH
27471: CALL_OW 428
27475: NOT
27476: AND
27477: IFFALSE 27500
// begin ComMoveXY ( tmp , _x , _y ) ;
27479: LD_VAR 0 13
27483: PPUSH
27484: LD_VAR 0 11
27488: PPUSH
27489: LD_VAR 0 12
27493: PPUSH
27494: CALL_OW 111
// break ;
27498: GO 27502
// end ; end ;
27500: GO 27387
27502: POP
27503: POP
// end ; end ;
27504: GO 26829
27506: POP
27507: POP
// end ;
27508: LD_VAR 0 8
27512: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27513: LD_INT 0
27515: PPUSH
// result := true ;
27516: LD_ADDR_VAR 0 3
27520: PUSH
27521: LD_INT 1
27523: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27524: LD_VAR 0 2
27528: PUSH
27529: LD_INT 24
27531: DOUBLE
27532: EQUAL
27533: IFTRUE 27543
27535: LD_INT 33
27537: DOUBLE
27538: EQUAL
27539: IFTRUE 27543
27541: GO 27568
27543: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27544: LD_ADDR_VAR 0 3
27548: PUSH
27549: LD_INT 32
27551: PPUSH
27552: LD_VAR 0 1
27556: PPUSH
27557: CALL_OW 321
27561: PUSH
27562: LD_INT 2
27564: EQUAL
27565: ST_TO_ADDR
27566: GO 27888
27568: LD_INT 20
27570: DOUBLE
27571: EQUAL
27572: IFTRUE 27576
27574: GO 27601
27576: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27577: LD_ADDR_VAR 0 3
27581: PUSH
27582: LD_INT 6
27584: PPUSH
27585: LD_VAR 0 1
27589: PPUSH
27590: CALL_OW 321
27594: PUSH
27595: LD_INT 2
27597: EQUAL
27598: ST_TO_ADDR
27599: GO 27888
27601: LD_INT 22
27603: DOUBLE
27604: EQUAL
27605: IFTRUE 27615
27607: LD_INT 36
27609: DOUBLE
27610: EQUAL
27611: IFTRUE 27615
27613: GO 27640
27615: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27616: LD_ADDR_VAR 0 3
27620: PUSH
27621: LD_INT 15
27623: PPUSH
27624: LD_VAR 0 1
27628: PPUSH
27629: CALL_OW 321
27633: PUSH
27634: LD_INT 2
27636: EQUAL
27637: ST_TO_ADDR
27638: GO 27888
27640: LD_INT 30
27642: DOUBLE
27643: EQUAL
27644: IFTRUE 27648
27646: GO 27673
27648: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27649: LD_ADDR_VAR 0 3
27653: PUSH
27654: LD_INT 20
27656: PPUSH
27657: LD_VAR 0 1
27661: PPUSH
27662: CALL_OW 321
27666: PUSH
27667: LD_INT 2
27669: EQUAL
27670: ST_TO_ADDR
27671: GO 27888
27673: LD_INT 28
27675: DOUBLE
27676: EQUAL
27677: IFTRUE 27687
27679: LD_INT 21
27681: DOUBLE
27682: EQUAL
27683: IFTRUE 27687
27685: GO 27712
27687: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27688: LD_ADDR_VAR 0 3
27692: PUSH
27693: LD_INT 21
27695: PPUSH
27696: LD_VAR 0 1
27700: PPUSH
27701: CALL_OW 321
27705: PUSH
27706: LD_INT 2
27708: EQUAL
27709: ST_TO_ADDR
27710: GO 27888
27712: LD_INT 16
27714: DOUBLE
27715: EQUAL
27716: IFTRUE 27720
27718: GO 27747
27720: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27721: LD_ADDR_VAR 0 3
27725: PUSH
27726: LD_EXP 115
27730: PPUSH
27731: LD_VAR 0 1
27735: PPUSH
27736: CALL_OW 321
27740: PUSH
27741: LD_INT 2
27743: EQUAL
27744: ST_TO_ADDR
27745: GO 27888
27747: LD_INT 19
27749: DOUBLE
27750: EQUAL
27751: IFTRUE 27761
27753: LD_INT 23
27755: DOUBLE
27756: EQUAL
27757: IFTRUE 27761
27759: GO 27788
27761: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27762: LD_ADDR_VAR 0 3
27766: PUSH
27767: LD_EXP 114
27771: PPUSH
27772: LD_VAR 0 1
27776: PPUSH
27777: CALL_OW 321
27781: PUSH
27782: LD_INT 2
27784: EQUAL
27785: ST_TO_ADDR
27786: GO 27888
27788: LD_INT 17
27790: DOUBLE
27791: EQUAL
27792: IFTRUE 27796
27794: GO 27821
27796: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27797: LD_ADDR_VAR 0 3
27801: PUSH
27802: LD_INT 39
27804: PPUSH
27805: LD_VAR 0 1
27809: PPUSH
27810: CALL_OW 321
27814: PUSH
27815: LD_INT 2
27817: EQUAL
27818: ST_TO_ADDR
27819: GO 27888
27821: LD_INT 18
27823: DOUBLE
27824: EQUAL
27825: IFTRUE 27829
27827: GO 27854
27829: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27830: LD_ADDR_VAR 0 3
27834: PUSH
27835: LD_INT 40
27837: PPUSH
27838: LD_VAR 0 1
27842: PPUSH
27843: CALL_OW 321
27847: PUSH
27848: LD_INT 2
27850: EQUAL
27851: ST_TO_ADDR
27852: GO 27888
27854: LD_INT 27
27856: DOUBLE
27857: EQUAL
27858: IFTRUE 27862
27860: GO 27887
27862: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27863: LD_ADDR_VAR 0 3
27867: PUSH
27868: LD_INT 35
27870: PPUSH
27871: LD_VAR 0 1
27875: PPUSH
27876: CALL_OW 321
27880: PUSH
27881: LD_INT 2
27883: EQUAL
27884: ST_TO_ADDR
27885: GO 27888
27887: POP
// end ;
27888: LD_VAR 0 3
27892: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27893: LD_INT 0
27895: PPUSH
27896: PPUSH
27897: PPUSH
27898: PPUSH
27899: PPUSH
27900: PPUSH
27901: PPUSH
27902: PPUSH
27903: PPUSH
27904: PPUSH
27905: PPUSH
// result := false ;
27906: LD_ADDR_VAR 0 6
27910: PUSH
27911: LD_INT 0
27913: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27914: LD_VAR 0 1
27918: NOT
27919: PUSH
27920: LD_VAR 0 1
27924: PPUSH
27925: CALL_OW 266
27929: PUSH
27930: LD_INT 0
27932: PUSH
27933: LD_INT 1
27935: PUSH
27936: EMPTY
27937: LIST
27938: LIST
27939: IN
27940: NOT
27941: OR
27942: PUSH
27943: LD_VAR 0 2
27947: NOT
27948: OR
27949: PUSH
27950: LD_VAR 0 5
27954: PUSH
27955: LD_INT 0
27957: PUSH
27958: LD_INT 1
27960: PUSH
27961: LD_INT 2
27963: PUSH
27964: LD_INT 3
27966: PUSH
27967: LD_INT 4
27969: PUSH
27970: LD_INT 5
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: LIST
27977: LIST
27978: LIST
27979: LIST
27980: IN
27981: NOT
27982: OR
27983: PUSH
27984: LD_VAR 0 3
27988: PPUSH
27989: LD_VAR 0 4
27993: PPUSH
27994: CALL_OW 488
27998: NOT
27999: OR
28000: IFFALSE 28004
// exit ;
28002: GO 28740
// side := GetSide ( depot ) ;
28004: LD_ADDR_VAR 0 9
28008: PUSH
28009: LD_VAR 0 1
28013: PPUSH
28014: CALL_OW 255
28018: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28019: LD_VAR 0 9
28023: PPUSH
28024: LD_VAR 0 2
28028: PPUSH
28029: CALL 27513 0 2
28033: NOT
28034: IFFALSE 28038
// exit ;
28036: GO 28740
// pom := GetBase ( depot ) ;
28038: LD_ADDR_VAR 0 10
28042: PUSH
28043: LD_VAR 0 1
28047: PPUSH
28048: CALL_OW 274
28052: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28053: LD_ADDR_VAR 0 11
28057: PUSH
28058: LD_VAR 0 2
28062: PPUSH
28063: LD_VAR 0 1
28067: PPUSH
28068: CALL_OW 248
28072: PPUSH
28073: CALL_OW 450
28077: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28078: LD_VAR 0 10
28082: PPUSH
28083: LD_INT 1
28085: PPUSH
28086: CALL_OW 275
28090: PUSH
28091: LD_VAR 0 11
28095: PUSH
28096: LD_INT 1
28098: ARRAY
28099: GREATEREQUAL
28100: PUSH
28101: LD_VAR 0 10
28105: PPUSH
28106: LD_INT 2
28108: PPUSH
28109: CALL_OW 275
28113: PUSH
28114: LD_VAR 0 11
28118: PUSH
28119: LD_INT 2
28121: ARRAY
28122: GREATEREQUAL
28123: AND
28124: PUSH
28125: LD_VAR 0 10
28129: PPUSH
28130: LD_INT 3
28132: PPUSH
28133: CALL_OW 275
28137: PUSH
28138: LD_VAR 0 11
28142: PUSH
28143: LD_INT 3
28145: ARRAY
28146: GREATEREQUAL
28147: AND
28148: NOT
28149: IFFALSE 28153
// exit ;
28151: GO 28740
// if GetBType ( depot ) = b_depot then
28153: LD_VAR 0 1
28157: PPUSH
28158: CALL_OW 266
28162: PUSH
28163: LD_INT 0
28165: EQUAL
28166: IFFALSE 28178
// dist := 28 else
28168: LD_ADDR_VAR 0 14
28172: PUSH
28173: LD_INT 28
28175: ST_TO_ADDR
28176: GO 28186
// dist := 36 ;
28178: LD_ADDR_VAR 0 14
28182: PUSH
28183: LD_INT 36
28185: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28186: LD_VAR 0 1
28190: PPUSH
28191: LD_VAR 0 3
28195: PPUSH
28196: LD_VAR 0 4
28200: PPUSH
28201: CALL_OW 297
28205: PUSH
28206: LD_VAR 0 14
28210: GREATER
28211: IFFALSE 28215
// exit ;
28213: GO 28740
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28215: LD_ADDR_VAR 0 12
28219: PUSH
28220: LD_VAR 0 2
28224: PPUSH
28225: LD_VAR 0 3
28229: PPUSH
28230: LD_VAR 0 4
28234: PPUSH
28235: LD_VAR 0 5
28239: PPUSH
28240: LD_VAR 0 1
28244: PPUSH
28245: CALL_OW 248
28249: PPUSH
28250: LD_INT 0
28252: PPUSH
28253: CALL 28745 0 6
28257: ST_TO_ADDR
// if not hexes then
28258: LD_VAR 0 12
28262: NOT
28263: IFFALSE 28267
// exit ;
28265: GO 28740
// hex := GetHexInfo ( x , y ) ;
28267: LD_ADDR_VAR 0 15
28271: PUSH
28272: LD_VAR 0 3
28276: PPUSH
28277: LD_VAR 0 4
28281: PPUSH
28282: CALL_OW 546
28286: ST_TO_ADDR
// if hex [ 1 ] then
28287: LD_VAR 0 15
28291: PUSH
28292: LD_INT 1
28294: ARRAY
28295: IFFALSE 28299
// exit ;
28297: GO 28740
// height := hex [ 2 ] ;
28299: LD_ADDR_VAR 0 13
28303: PUSH
28304: LD_VAR 0 15
28308: PUSH
28309: LD_INT 2
28311: ARRAY
28312: ST_TO_ADDR
// for i = 1 to hexes do
28313: LD_ADDR_VAR 0 7
28317: PUSH
28318: DOUBLE
28319: LD_INT 1
28321: DEC
28322: ST_TO_ADDR
28323: LD_VAR 0 12
28327: PUSH
28328: FOR_TO
28329: IFFALSE 28659
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28331: LD_VAR 0 12
28335: PUSH
28336: LD_VAR 0 7
28340: ARRAY
28341: PUSH
28342: LD_INT 1
28344: ARRAY
28345: PPUSH
28346: LD_VAR 0 12
28350: PUSH
28351: LD_VAR 0 7
28355: ARRAY
28356: PUSH
28357: LD_INT 2
28359: ARRAY
28360: PPUSH
28361: CALL_OW 488
28365: NOT
28366: PUSH
28367: LD_VAR 0 12
28371: PUSH
28372: LD_VAR 0 7
28376: ARRAY
28377: PUSH
28378: LD_INT 1
28380: ARRAY
28381: PPUSH
28382: LD_VAR 0 12
28386: PUSH
28387: LD_VAR 0 7
28391: ARRAY
28392: PUSH
28393: LD_INT 2
28395: ARRAY
28396: PPUSH
28397: CALL_OW 428
28401: PUSH
28402: LD_INT 0
28404: GREATER
28405: OR
28406: PUSH
28407: LD_VAR 0 12
28411: PUSH
28412: LD_VAR 0 7
28416: ARRAY
28417: PUSH
28418: LD_INT 1
28420: ARRAY
28421: PPUSH
28422: LD_VAR 0 12
28426: PUSH
28427: LD_VAR 0 7
28431: ARRAY
28432: PUSH
28433: LD_INT 2
28435: ARRAY
28436: PPUSH
28437: CALL_OW 351
28441: OR
28442: IFFALSE 28448
// exit ;
28444: POP
28445: POP
28446: GO 28740
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28448: LD_ADDR_VAR 0 8
28452: PUSH
28453: LD_VAR 0 12
28457: PUSH
28458: LD_VAR 0 7
28462: ARRAY
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: PPUSH
28468: LD_VAR 0 12
28472: PUSH
28473: LD_VAR 0 7
28477: ARRAY
28478: PUSH
28479: LD_INT 2
28481: ARRAY
28482: PPUSH
28483: CALL_OW 546
28487: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28488: LD_VAR 0 8
28492: PUSH
28493: LD_INT 1
28495: ARRAY
28496: PUSH
28497: LD_VAR 0 8
28501: PUSH
28502: LD_INT 2
28504: ARRAY
28505: PUSH
28506: LD_VAR 0 13
28510: PUSH
28511: LD_INT 2
28513: PLUS
28514: GREATER
28515: OR
28516: PUSH
28517: LD_VAR 0 8
28521: PUSH
28522: LD_INT 2
28524: ARRAY
28525: PUSH
28526: LD_VAR 0 13
28530: PUSH
28531: LD_INT 2
28533: MINUS
28534: LESS
28535: OR
28536: PUSH
28537: LD_VAR 0 8
28541: PUSH
28542: LD_INT 3
28544: ARRAY
28545: PUSH
28546: LD_INT 0
28548: PUSH
28549: LD_INT 8
28551: PUSH
28552: LD_INT 9
28554: PUSH
28555: LD_INT 10
28557: PUSH
28558: LD_INT 11
28560: PUSH
28561: LD_INT 12
28563: PUSH
28564: LD_INT 13
28566: PUSH
28567: LD_INT 16
28569: PUSH
28570: LD_INT 17
28572: PUSH
28573: LD_INT 18
28575: PUSH
28576: LD_INT 19
28578: PUSH
28579: LD_INT 20
28581: PUSH
28582: LD_INT 21
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: LIST
28589: LIST
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: IN
28600: NOT
28601: OR
28602: PUSH
28603: LD_VAR 0 8
28607: PUSH
28608: LD_INT 5
28610: ARRAY
28611: NOT
28612: OR
28613: PUSH
28614: LD_VAR 0 8
28618: PUSH
28619: LD_INT 6
28621: ARRAY
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: LD_INT 2
28628: PUSH
28629: LD_INT 7
28631: PUSH
28632: LD_INT 9
28634: PUSH
28635: LD_INT 10
28637: PUSH
28638: LD_INT 11
28640: PUSH
28641: EMPTY
28642: LIST
28643: LIST
28644: LIST
28645: LIST
28646: LIST
28647: LIST
28648: IN
28649: NOT
28650: OR
28651: IFFALSE 28657
// exit ;
28653: POP
28654: POP
28655: GO 28740
// end ;
28657: GO 28328
28659: POP
28660: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28661: LD_VAR 0 9
28665: PPUSH
28666: LD_VAR 0 3
28670: PPUSH
28671: LD_VAR 0 4
28675: PPUSH
28676: LD_INT 20
28678: PPUSH
28679: CALL 20686 0 4
28683: PUSH
28684: LD_INT 4
28686: ARRAY
28687: IFFALSE 28691
// exit ;
28689: GO 28740
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28691: LD_VAR 0 2
28695: PUSH
28696: LD_INT 29
28698: PUSH
28699: LD_INT 30
28701: PUSH
28702: EMPTY
28703: LIST
28704: LIST
28705: IN
28706: PUSH
28707: LD_VAR 0 3
28711: PPUSH
28712: LD_VAR 0 4
28716: PPUSH
28717: LD_VAR 0 9
28721: PPUSH
28722: CALL_OW 440
28726: NOT
28727: AND
28728: IFFALSE 28732
// exit ;
28730: GO 28740
// result := true ;
28732: LD_ADDR_VAR 0 6
28736: PUSH
28737: LD_INT 1
28739: ST_TO_ADDR
// end ;
28740: LD_VAR 0 6
28744: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28745: LD_INT 0
28747: PPUSH
28748: PPUSH
28749: PPUSH
28750: PPUSH
28751: PPUSH
28752: PPUSH
28753: PPUSH
28754: PPUSH
28755: PPUSH
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
28760: PPUSH
28761: PPUSH
28762: PPUSH
28763: PPUSH
28764: PPUSH
28765: PPUSH
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
28770: PPUSH
28771: PPUSH
28772: PPUSH
28773: PPUSH
28774: PPUSH
28775: PPUSH
28776: PPUSH
28777: PPUSH
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
28793: PPUSH
28794: PPUSH
28795: PPUSH
28796: PPUSH
28797: PPUSH
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
// result = [ ] ;
28805: LD_ADDR_VAR 0 7
28809: PUSH
28810: EMPTY
28811: ST_TO_ADDR
// temp_list = [ ] ;
28812: LD_ADDR_VAR 0 9
28816: PUSH
28817: EMPTY
28818: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28819: LD_VAR 0 4
28823: PUSH
28824: LD_INT 0
28826: PUSH
28827: LD_INT 1
28829: PUSH
28830: LD_INT 2
28832: PUSH
28833: LD_INT 3
28835: PUSH
28836: LD_INT 4
28838: PUSH
28839: LD_INT 5
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: LIST
28846: LIST
28847: LIST
28848: LIST
28849: IN
28850: NOT
28851: PUSH
28852: LD_VAR 0 1
28856: PUSH
28857: LD_INT 0
28859: PUSH
28860: LD_INT 1
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: IN
28867: PUSH
28868: LD_VAR 0 5
28872: PUSH
28873: LD_INT 1
28875: PUSH
28876: LD_INT 2
28878: PUSH
28879: LD_INT 3
28881: PUSH
28882: EMPTY
28883: LIST
28884: LIST
28885: LIST
28886: IN
28887: NOT
28888: AND
28889: OR
28890: IFFALSE 28894
// exit ;
28892: GO 47285
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28894: LD_VAR 0 1
28898: PUSH
28899: LD_INT 6
28901: PUSH
28902: LD_INT 7
28904: PUSH
28905: LD_INT 8
28907: PUSH
28908: LD_INT 13
28910: PUSH
28911: LD_INT 12
28913: PUSH
28914: LD_INT 15
28916: PUSH
28917: LD_INT 11
28919: PUSH
28920: LD_INT 14
28922: PUSH
28923: LD_INT 10
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: LIST
28930: LIST
28931: LIST
28932: LIST
28933: LIST
28934: LIST
28935: LIST
28936: IN
28937: IFFALSE 28947
// btype = b_lab ;
28939: LD_ADDR_VAR 0 1
28943: PUSH
28944: LD_INT 6
28946: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28947: LD_VAR 0 6
28951: PUSH
28952: LD_INT 0
28954: PUSH
28955: LD_INT 1
28957: PUSH
28958: LD_INT 2
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: LIST
28965: IN
28966: NOT
28967: PUSH
28968: LD_VAR 0 1
28972: PUSH
28973: LD_INT 0
28975: PUSH
28976: LD_INT 1
28978: PUSH
28979: LD_INT 2
28981: PUSH
28982: LD_INT 3
28984: PUSH
28985: LD_INT 6
28987: PUSH
28988: LD_INT 36
28990: PUSH
28991: LD_INT 4
28993: PUSH
28994: LD_INT 5
28996: PUSH
28997: LD_INT 31
28999: PUSH
29000: LD_INT 32
29002: PUSH
29003: LD_INT 33
29005: PUSH
29006: EMPTY
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: LIST
29018: IN
29019: NOT
29020: PUSH
29021: LD_VAR 0 6
29025: PUSH
29026: LD_INT 1
29028: EQUAL
29029: AND
29030: OR
29031: PUSH
29032: LD_VAR 0 1
29036: PUSH
29037: LD_INT 2
29039: PUSH
29040: LD_INT 3
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: IN
29047: NOT
29048: PUSH
29049: LD_VAR 0 6
29053: PUSH
29054: LD_INT 2
29056: EQUAL
29057: AND
29058: OR
29059: IFFALSE 29069
// mode = 0 ;
29061: LD_ADDR_VAR 0 6
29065: PUSH
29066: LD_INT 0
29068: ST_TO_ADDR
// case mode of 0 :
29069: LD_VAR 0 6
29073: PUSH
29074: LD_INT 0
29076: DOUBLE
29077: EQUAL
29078: IFTRUE 29082
29080: GO 40535
29082: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29083: LD_ADDR_VAR 0 11
29087: PUSH
29088: LD_INT 0
29090: PUSH
29091: LD_INT 0
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 0
29100: PUSH
29101: LD_INT 1
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 1
29111: PUSH
29112: LD_INT 0
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: LD_INT 1
29124: PUSH
29125: EMPTY
29126: LIST
29127: LIST
29128: PUSH
29129: LD_INT 0
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: EMPTY
29136: LIST
29137: LIST
29138: PUSH
29139: LD_INT 1
29141: NEG
29142: PUSH
29143: LD_INT 0
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 1
29152: NEG
29153: PUSH
29154: LD_INT 1
29156: NEG
29157: PUSH
29158: EMPTY
29159: LIST
29160: LIST
29161: PUSH
29162: LD_INT 1
29164: NEG
29165: PUSH
29166: LD_INT 2
29168: NEG
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 0
29176: PUSH
29177: LD_INT 2
29179: NEG
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 1
29187: PUSH
29188: LD_INT 1
29190: NEG
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 2
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: PUSH
29206: LD_INT 0
29208: PUSH
29209: LD_INT 2
29211: PUSH
29212: EMPTY
29213: LIST
29214: LIST
29215: PUSH
29216: LD_INT 1
29218: NEG
29219: PUSH
29220: LD_INT 1
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 1
29229: PUSH
29230: LD_INT 3
29232: PUSH
29233: EMPTY
29234: LIST
29235: LIST
29236: PUSH
29237: LD_INT 0
29239: PUSH
29240: LD_INT 3
29242: PUSH
29243: EMPTY
29244: LIST
29245: LIST
29246: PUSH
29247: LD_INT 1
29249: NEG
29250: PUSH
29251: LD_INT 2
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: LIST
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29276: LD_ADDR_VAR 0 12
29280: PUSH
29281: LD_INT 0
29283: PUSH
29284: LD_INT 0
29286: PUSH
29287: EMPTY
29288: LIST
29289: LIST
29290: PUSH
29291: LD_INT 0
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: PUSH
29305: LD_INT 0
29307: PUSH
29308: EMPTY
29309: LIST
29310: LIST
29311: PUSH
29312: LD_INT 1
29314: PUSH
29315: LD_INT 1
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 0
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 1
29334: NEG
29335: PUSH
29336: LD_INT 0
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: LD_INT 1
29349: NEG
29350: PUSH
29351: EMPTY
29352: LIST
29353: LIST
29354: PUSH
29355: LD_INT 1
29357: PUSH
29358: LD_INT 1
29360: NEG
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 2
29368: PUSH
29369: LD_INT 0
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 2
29378: PUSH
29379: LD_INT 1
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 1
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 3
29433: NEG
29434: PUSH
29435: LD_INT 0
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 3
29444: NEG
29445: PUSH
29446: LD_INT 1
29448: NEG
29449: PUSH
29450: EMPTY
29451: LIST
29452: LIST
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: LIST
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29472: LD_ADDR_VAR 0 13
29476: PUSH
29477: LD_INT 0
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: EMPTY
29484: LIST
29485: LIST
29486: PUSH
29487: LD_INT 0
29489: PUSH
29490: LD_INT 1
29492: NEG
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 1
29500: PUSH
29501: LD_INT 0
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 1
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: LD_INT 1
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 1
29530: NEG
29531: PUSH
29532: LD_INT 0
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: LD_INT 1
29545: NEG
29546: PUSH
29547: EMPTY
29548: LIST
29549: LIST
29550: PUSH
29551: LD_INT 1
29553: NEG
29554: PUSH
29555: LD_INT 2
29557: NEG
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: PUSH
29563: LD_INT 2
29565: PUSH
29566: LD_INT 1
29568: PUSH
29569: EMPTY
29570: LIST
29571: LIST
29572: PUSH
29573: LD_INT 2
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: EMPTY
29580: LIST
29581: LIST
29582: PUSH
29583: LD_INT 1
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: EMPTY
29590: LIST
29591: LIST
29592: PUSH
29593: LD_INT 2
29595: NEG
29596: PUSH
29597: LD_INT 1
29599: NEG
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: PUSH
29605: LD_INT 2
29607: NEG
29608: PUSH
29609: LD_INT 2
29611: NEG
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 2
29619: NEG
29620: PUSH
29621: LD_INT 3
29623: NEG
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 3
29631: NEG
29632: PUSH
29633: LD_INT 2
29635: NEG
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 3
29643: NEG
29644: PUSH
29645: LD_INT 3
29647: NEG
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: EMPTY
29654: LIST
29655: LIST
29656: LIST
29657: LIST
29658: LIST
29659: LIST
29660: LIST
29661: LIST
29662: LIST
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29671: LD_ADDR_VAR 0 14
29675: PUSH
29676: LD_INT 0
29678: PUSH
29679: LD_INT 0
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: PUSH
29686: LD_INT 0
29688: PUSH
29689: LD_INT 1
29691: NEG
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 1
29699: PUSH
29700: LD_INT 0
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 1
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 0
29719: PUSH
29720: LD_INT 1
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 1
29729: NEG
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: LD_INT 1
29744: NEG
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 2
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 0
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 1
29775: PUSH
29776: LD_INT 1
29778: NEG
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: PUSH
29787: LD_INT 2
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 0
29796: PUSH
29797: LD_INT 2
29799: PUSH
29800: EMPTY
29801: LIST
29802: LIST
29803: PUSH
29804: LD_INT 1
29806: NEG
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: LD_INT 3
29821: NEG
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: PUSH
29827: LD_INT 0
29829: PUSH
29830: LD_INT 3
29832: NEG
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 1
29840: PUSH
29841: LD_INT 2
29843: NEG
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: LIST
29853: LIST
29854: LIST
29855: LIST
29856: LIST
29857: LIST
29858: LIST
29859: LIST
29860: LIST
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: LIST
29866: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29867: LD_ADDR_VAR 0 15
29871: PUSH
29872: LD_INT 0
29874: PUSH
29875: LD_INT 0
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 0
29884: PUSH
29885: LD_INT 1
29887: NEG
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 1
29895: PUSH
29896: LD_INT 0
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 1
29905: PUSH
29906: LD_INT 1
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 0
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: NEG
29926: PUSH
29927: LD_INT 0
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: LD_INT 1
29940: NEG
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 2
29959: PUSH
29960: LD_INT 0
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 2
29969: PUSH
29970: LD_INT 1
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 1
29979: NEG
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 2
29990: NEG
29991: PUSH
29992: LD_INT 0
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 2
30001: NEG
30002: PUSH
30003: LD_INT 1
30005: NEG
30006: PUSH
30007: EMPTY
30008: LIST
30009: LIST
30010: PUSH
30011: LD_INT 2
30013: PUSH
30014: LD_INT 1
30016: NEG
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 3
30024: PUSH
30025: LD_INT 0
30027: PUSH
30028: EMPTY
30029: LIST
30030: LIST
30031: PUSH
30032: LD_INT 3
30034: PUSH
30035: LD_INT 1
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30060: LD_ADDR_VAR 0 16
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: EMPTY
30072: LIST
30073: LIST
30074: PUSH
30075: LD_INT 0
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: LD_INT 0
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 1
30098: PUSH
30099: LD_INT 1
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 0
30108: PUSH
30109: LD_INT 1
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 1
30118: NEG
30119: PUSH
30120: LD_INT 0
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: LD_INT 1
30133: NEG
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 1
30141: NEG
30142: PUSH
30143: LD_INT 2
30145: NEG
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: PUSH
30151: LD_INT 2
30153: PUSH
30154: LD_INT 1
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 2
30163: PUSH
30164: LD_INT 2
30166: PUSH
30167: EMPTY
30168: LIST
30169: LIST
30170: PUSH
30171: LD_INT 1
30173: PUSH
30174: LD_INT 2
30176: PUSH
30177: EMPTY
30178: LIST
30179: LIST
30180: PUSH
30181: LD_INT 2
30183: NEG
30184: PUSH
30185: LD_INT 1
30187: NEG
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: PUSH
30193: LD_INT 2
30195: NEG
30196: PUSH
30197: LD_INT 2
30199: NEG
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: LD_INT 3
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 3
30217: PUSH
30218: LD_INT 3
30220: PUSH
30221: EMPTY
30222: LIST
30223: LIST
30224: PUSH
30225: LD_INT 2
30227: PUSH
30228: LD_INT 3
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30253: LD_ADDR_VAR 0 17
30257: PUSH
30258: LD_INT 0
30260: PUSH
30261: LD_INT 0
30263: PUSH
30264: EMPTY
30265: LIST
30266: LIST
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: LD_INT 1
30273: NEG
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PUSH
30279: LD_INT 1
30281: PUSH
30282: LD_INT 0
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 1
30291: PUSH
30292: LD_INT 1
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: LD_INT 1
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 1
30311: NEG
30312: PUSH
30313: LD_INT 0
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: NEG
30323: PUSH
30324: LD_INT 1
30326: NEG
30327: PUSH
30328: EMPTY
30329: LIST
30330: LIST
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: LD_INT 2
30338: NEG
30339: PUSH
30340: EMPTY
30341: LIST
30342: LIST
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 1
30357: PUSH
30358: LD_INT 1
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 2
30368: PUSH
30369: LD_INT 0
30371: PUSH
30372: EMPTY
30373: LIST
30374: LIST
30375: PUSH
30376: LD_INT 2
30378: PUSH
30379: LD_INT 1
30381: PUSH
30382: EMPTY
30383: LIST
30384: LIST
30385: PUSH
30386: LD_INT 2
30388: PUSH
30389: LD_INT 2
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 1
30398: PUSH
30399: LD_INT 2
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: LD_INT 2
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: LD_INT 1
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 2
30429: NEG
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: LD_INT 1
30444: NEG
30445: PUSH
30446: EMPTY
30447: LIST
30448: LIST
30449: PUSH
30450: LD_INT 2
30452: NEG
30453: PUSH
30454: LD_INT 2
30456: NEG
30457: PUSH
30458: EMPTY
30459: LIST
30460: LIST
30461: PUSH
30462: EMPTY
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30483: LD_ADDR_VAR 0 18
30487: PUSH
30488: LD_INT 0
30490: PUSH
30491: LD_INT 0
30493: PUSH
30494: EMPTY
30495: LIST
30496: LIST
30497: PUSH
30498: LD_INT 0
30500: PUSH
30501: LD_INT 1
30503: NEG
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 1
30511: PUSH
30512: LD_INT 0
30514: PUSH
30515: EMPTY
30516: LIST
30517: LIST
30518: PUSH
30519: LD_INT 1
30521: PUSH
30522: LD_INT 1
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 0
30531: PUSH
30532: LD_INT 1
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PUSH
30539: LD_INT 1
30541: NEG
30542: PUSH
30543: LD_INT 0
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 1
30552: NEG
30553: PUSH
30554: LD_INT 1
30556: NEG
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: LD_INT 2
30568: NEG
30569: PUSH
30570: EMPTY
30571: LIST
30572: LIST
30573: PUSH
30574: LD_INT 0
30576: PUSH
30577: LD_INT 2
30579: NEG
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 1
30587: PUSH
30588: LD_INT 1
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 2
30598: PUSH
30599: LD_INT 0
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 2
30608: PUSH
30609: LD_INT 1
30611: PUSH
30612: EMPTY
30613: LIST
30614: LIST
30615: PUSH
30616: LD_INT 2
30618: PUSH
30619: LD_INT 2
30621: PUSH
30622: EMPTY
30623: LIST
30624: LIST
30625: PUSH
30626: LD_INT 1
30628: PUSH
30629: LD_INT 2
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: LD_INT 2
30641: PUSH
30642: EMPTY
30643: LIST
30644: LIST
30645: PUSH
30646: LD_INT 1
30648: NEG
30649: PUSH
30650: LD_INT 1
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 2
30659: NEG
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 2
30682: NEG
30683: PUSH
30684: LD_INT 2
30686: NEG
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: LIST
30696: LIST
30697: LIST
30698: LIST
30699: LIST
30700: LIST
30701: LIST
30702: LIST
30703: LIST
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30713: LD_ADDR_VAR 0 19
30717: PUSH
30718: LD_INT 0
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 0
30730: PUSH
30731: LD_INT 1
30733: NEG
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 1
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: LD_INT 1
30754: PUSH
30755: EMPTY
30756: LIST
30757: LIST
30758: PUSH
30759: LD_INT 0
30761: PUSH
30762: LD_INT 1
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 1
30771: NEG
30772: PUSH
30773: LD_INT 0
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 1
30786: NEG
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 2
30798: NEG
30799: PUSH
30800: EMPTY
30801: LIST
30802: LIST
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: PUSH
30818: LD_INT 1
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 2
30828: PUSH
30829: LD_INT 0
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 2
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: EMPTY
30843: LIST
30844: LIST
30845: PUSH
30846: LD_INT 2
30848: PUSH
30849: LD_INT 2
30851: PUSH
30852: EMPTY
30853: LIST
30854: LIST
30855: PUSH
30856: LD_INT 1
30858: PUSH
30859: LD_INT 2
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: LD_INT 2
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: LD_INT 1
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 2
30889: NEG
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: LD_INT 1
30904: NEG
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 2
30912: NEG
30913: PUSH
30914: LD_INT 2
30916: NEG
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: LIST
30929: LIST
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30943: LD_ADDR_VAR 0 20
30947: PUSH
30948: LD_INT 0
30950: PUSH
30951: LD_INT 0
30953: PUSH
30954: EMPTY
30955: LIST
30956: LIST
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: LD_INT 1
30963: NEG
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 1
30971: PUSH
30972: LD_INT 0
30974: PUSH
30975: EMPTY
30976: LIST
30977: LIST
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: LD_INT 1
30984: PUSH
30985: EMPTY
30986: LIST
30987: LIST
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: LD_INT 1
30994: PUSH
30995: EMPTY
30996: LIST
30997: LIST
30998: PUSH
30999: LD_INT 1
31001: NEG
31002: PUSH
31003: LD_INT 0
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: LD_INT 1
31016: NEG
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: LD_INT 2
31028: NEG
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: PUSH
31034: LD_INT 0
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 1
31047: PUSH
31048: LD_INT 1
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 2
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 2
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: EMPTY
31073: LIST
31074: LIST
31075: PUSH
31076: LD_INT 2
31078: PUSH
31079: LD_INT 2
31081: PUSH
31082: EMPTY
31083: LIST
31084: LIST
31085: PUSH
31086: LD_INT 1
31088: PUSH
31089: LD_INT 2
31091: PUSH
31092: EMPTY
31093: LIST
31094: LIST
31095: PUSH
31096: LD_INT 0
31098: PUSH
31099: LD_INT 2
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 1
31108: NEG
31109: PUSH
31110: LD_INT 1
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 2
31119: NEG
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 1
31134: NEG
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 2
31142: NEG
31143: PUSH
31144: LD_INT 2
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: LIST
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31173: LD_ADDR_VAR 0 21
31177: PUSH
31178: LD_INT 0
31180: PUSH
31181: LD_INT 0
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: LD_INT 1
31193: NEG
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: EMPTY
31206: LIST
31207: LIST
31208: PUSH
31209: LD_INT 1
31211: PUSH
31212: LD_INT 1
31214: PUSH
31215: EMPTY
31216: LIST
31217: LIST
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 1
31254: NEG
31255: PUSH
31256: LD_INT 2
31258: NEG
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 0
31266: PUSH
31267: LD_INT 2
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 1
31277: PUSH
31278: LD_INT 1
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 2
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: PUSH
31299: LD_INT 1
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: LD_INT 2
31308: PUSH
31309: LD_INT 2
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 1
31318: PUSH
31319: LD_INT 2
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 0
31328: PUSH
31329: LD_INT 2
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: LD_INT 1
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 2
31349: NEG
31350: PUSH
31351: LD_INT 0
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: LD_INT 1
31364: NEG
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 2
31372: NEG
31373: PUSH
31374: LD_INT 2
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: LIST
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31403: LD_ADDR_VAR 0 22
31407: PUSH
31408: LD_INT 0
31410: PUSH
31411: LD_INT 0
31413: PUSH
31414: EMPTY
31415: LIST
31416: LIST
31417: PUSH
31418: LD_INT 0
31420: PUSH
31421: LD_INT 1
31423: NEG
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 1
31431: PUSH
31432: LD_INT 0
31434: PUSH
31435: EMPTY
31436: LIST
31437: LIST
31438: PUSH
31439: LD_INT 1
31441: PUSH
31442: LD_INT 1
31444: PUSH
31445: EMPTY
31446: LIST
31447: LIST
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: LD_INT 1
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 1
31461: NEG
31462: PUSH
31463: LD_INT 0
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: LD_INT 1
31476: NEG
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 1
31484: NEG
31485: PUSH
31486: LD_INT 2
31488: NEG
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 2
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: LD_INT 1
31510: NEG
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 2
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 2
31528: PUSH
31529: LD_INT 1
31531: PUSH
31532: EMPTY
31533: LIST
31534: LIST
31535: PUSH
31536: LD_INT 2
31538: PUSH
31539: LD_INT 2
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: PUSH
31549: LD_INT 2
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 0
31558: PUSH
31559: LD_INT 2
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: NEG
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 2
31579: NEG
31580: PUSH
31581: LD_INT 0
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: LD_INT 1
31594: NEG
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 2
31602: NEG
31603: PUSH
31604: LD_INT 2
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31633: LD_ADDR_VAR 0 23
31637: PUSH
31638: LD_INT 0
31640: PUSH
31641: LD_INT 0
31643: PUSH
31644: EMPTY
31645: LIST
31646: LIST
31647: PUSH
31648: LD_INT 0
31650: PUSH
31651: LD_INT 1
31653: NEG
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: LD_INT 1
31671: PUSH
31672: LD_INT 1
31674: PUSH
31675: EMPTY
31676: LIST
31677: LIST
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: LD_INT 1
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 1
31691: NEG
31692: PUSH
31693: LD_INT 0
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 1
31706: NEG
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 1
31714: NEG
31715: PUSH
31716: LD_INT 2
31718: NEG
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 0
31726: PUSH
31727: LD_INT 2
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 1
31737: PUSH
31738: LD_INT 1
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 2
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 2
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: EMPTY
31763: LIST
31764: LIST
31765: PUSH
31766: LD_INT 2
31768: PUSH
31769: LD_INT 2
31771: PUSH
31772: EMPTY
31773: LIST
31774: LIST
31775: PUSH
31776: LD_INT 1
31778: PUSH
31779: LD_INT 2
31781: PUSH
31782: EMPTY
31783: LIST
31784: LIST
31785: PUSH
31786: LD_INT 0
31788: PUSH
31789: LD_INT 2
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 1
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 2
31809: NEG
31810: PUSH
31811: LD_INT 0
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 2
31820: NEG
31821: PUSH
31822: LD_INT 1
31824: NEG
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 2
31832: NEG
31833: PUSH
31834: LD_INT 2
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 2
31844: NEG
31845: PUSH
31846: LD_INT 3
31848: NEG
31849: PUSH
31850: EMPTY
31851: LIST
31852: LIST
31853: PUSH
31854: LD_INT 1
31856: NEG
31857: PUSH
31858: LD_INT 3
31860: NEG
31861: PUSH
31862: EMPTY
31863: LIST
31864: LIST
31865: PUSH
31866: LD_INT 1
31868: PUSH
31869: LD_INT 2
31871: NEG
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 2
31879: PUSH
31880: LD_INT 1
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: LIST
31909: LIST
31910: LIST
31911: LIST
31912: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31913: LD_ADDR_VAR 0 24
31917: PUSH
31918: LD_INT 0
31920: PUSH
31921: LD_INT 0
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 0
31930: PUSH
31931: LD_INT 1
31933: NEG
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 1
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PUSH
31949: LD_INT 1
31951: PUSH
31952: LD_INT 1
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 0
31961: PUSH
31962: LD_INT 1
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 1
31971: NEG
31972: PUSH
31973: LD_INT 0
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 1
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: NEG
31995: PUSH
31996: LD_INT 2
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 0
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: PUSH
32018: LD_INT 1
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 2
32028: PUSH
32029: LD_INT 0
32031: PUSH
32032: EMPTY
32033: LIST
32034: LIST
32035: PUSH
32036: LD_INT 2
32038: PUSH
32039: LD_INT 1
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: PUSH
32049: LD_INT 2
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 1
32058: PUSH
32059: LD_INT 2
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: LD_INT 2
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: NEG
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: NEG
32090: PUSH
32091: LD_INT 0
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: LD_INT 1
32104: NEG
32105: PUSH
32106: EMPTY
32107: LIST
32108: LIST
32109: PUSH
32110: LD_INT 2
32112: NEG
32113: PUSH
32114: LD_INT 2
32116: NEG
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: PUSH
32125: LD_INT 2
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 2
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 3
32146: PUSH
32147: LD_INT 1
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 3
32156: PUSH
32157: LD_INT 2
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32189: LD_ADDR_VAR 0 25
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: LD_INT 1
32209: NEG
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 1
32217: PUSH
32218: LD_INT 0
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 1
32247: NEG
32248: PUSH
32249: LD_INT 0
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 1
32270: NEG
32271: PUSH
32272: LD_INT 2
32274: NEG
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 1
32293: PUSH
32294: LD_INT 1
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 2
32304: PUSH
32305: LD_INT 0
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 2
32314: PUSH
32315: LD_INT 1
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: LD_INT 2
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: LD_INT 2
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 1
32354: NEG
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: NEG
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 1
32380: NEG
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 2
32388: NEG
32389: PUSH
32390: LD_INT 2
32392: NEG
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PUSH
32398: LD_INT 3
32400: PUSH
32401: LD_INT 1
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 3
32410: PUSH
32411: LD_INT 2
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: LD_INT 3
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 1
32430: PUSH
32431: LD_INT 3
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32463: LD_ADDR_VAR 0 26
32467: PUSH
32468: LD_INT 0
32470: PUSH
32471: LD_INT 0
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 0
32480: PUSH
32481: LD_INT 1
32483: NEG
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: LD_INT 0
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: NEG
32545: PUSH
32546: LD_INT 2
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: LD_INT 2
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 2
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: PUSH
32609: LD_INT 2
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: LD_INT 2
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 1
32628: NEG
32629: PUSH
32630: LD_INT 1
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: NEG
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 1
32654: NEG
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 2
32662: NEG
32663: PUSH
32664: LD_INT 2
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 2
32674: PUSH
32675: LD_INT 3
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 1
32684: PUSH
32685: LD_INT 3
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: LD_INT 2
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 2
32705: NEG
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32739: LD_ADDR_VAR 0 27
32743: PUSH
32744: LD_INT 0
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: EMPTY
32751: LIST
32752: LIST
32753: PUSH
32754: LD_INT 0
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 1
32767: PUSH
32768: LD_INT 0
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 0
32787: PUSH
32788: LD_INT 1
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PUSH
32795: LD_INT 1
32797: NEG
32798: PUSH
32799: LD_INT 0
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: LD_INT 1
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: NEG
32821: PUSH
32822: LD_INT 2
32824: NEG
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 0
32832: PUSH
32833: LD_INT 2
32835: NEG
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 1
32843: PUSH
32844: LD_INT 1
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 2
32854: PUSH
32855: LD_INT 0
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 2
32864: PUSH
32865: LD_INT 1
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 2
32874: PUSH
32875: LD_INT 2
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 1
32884: PUSH
32885: LD_INT 2
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: LD_INT 0
32894: PUSH
32895: LD_INT 2
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: NEG
32905: PUSH
32906: LD_INT 1
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 2
32915: NEG
32916: PUSH
32917: LD_INT 0
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: LD_INT 1
32930: NEG
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 2
32938: NEG
32939: PUSH
32940: LD_INT 2
32942: NEG
32943: PUSH
32944: EMPTY
32945: LIST
32946: LIST
32947: PUSH
32948: LD_INT 1
32950: NEG
32951: PUSH
32952: LD_INT 2
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: LD_INT 1
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 3
32972: NEG
32973: PUSH
32974: LD_INT 1
32976: NEG
32977: PUSH
32978: EMPTY
32979: LIST
32980: LIST
32981: PUSH
32982: LD_INT 3
32984: NEG
32985: PUSH
32986: LD_INT 2
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33019: LD_ADDR_VAR 0 28
33023: PUSH
33024: LD_INT 0
33026: PUSH
33027: LD_INT 0
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 0
33036: PUSH
33037: LD_INT 1
33039: NEG
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 0
33067: PUSH
33068: LD_INT 1
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: NEG
33078: PUSH
33079: LD_INT 0
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: NEG
33101: PUSH
33102: LD_INT 2
33104: NEG
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: LD_INT 2
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 2
33134: PUSH
33135: LD_INT 0
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 2
33154: PUSH
33155: LD_INT 2
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 0
33174: PUSH
33175: LD_INT 2
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: NEG
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 2
33195: NEG
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 2
33218: NEG
33219: PUSH
33220: LD_INT 2
33222: NEG
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 2
33230: NEG
33231: PUSH
33232: LD_INT 3
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 1
33242: NEG
33243: PUSH
33244: LD_INT 3
33246: NEG
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 3
33254: NEG
33255: PUSH
33256: LD_INT 1
33258: NEG
33259: PUSH
33260: EMPTY
33261: LIST
33262: LIST
33263: PUSH
33264: LD_INT 3
33266: NEG
33267: PUSH
33268: LD_INT 2
33270: NEG
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: EMPTY
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33301: LD_ADDR_VAR 0 29
33305: PUSH
33306: LD_INT 0
33308: PUSH
33309: LD_INT 0
33311: PUSH
33312: EMPTY
33313: LIST
33314: LIST
33315: PUSH
33316: LD_INT 0
33318: PUSH
33319: LD_INT 1
33321: NEG
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: LD_INT 0
33332: PUSH
33333: EMPTY
33334: LIST
33335: LIST
33336: PUSH
33337: LD_INT 1
33339: PUSH
33340: LD_INT 1
33342: PUSH
33343: EMPTY
33344: LIST
33345: LIST
33346: PUSH
33347: LD_INT 0
33349: PUSH
33350: LD_INT 1
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: LD_INT 0
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 1
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 1
33382: NEG
33383: PUSH
33384: LD_INT 2
33386: NEG
33387: PUSH
33388: EMPTY
33389: LIST
33390: LIST
33391: PUSH
33392: LD_INT 0
33394: PUSH
33395: LD_INT 2
33397: NEG
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: LD_INT 1
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 2
33416: PUSH
33417: LD_INT 0
33419: PUSH
33420: EMPTY
33421: LIST
33422: LIST
33423: PUSH
33424: LD_INT 2
33426: PUSH
33427: LD_INT 1
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 1
33436: PUSH
33437: LD_INT 2
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 0
33446: PUSH
33447: LD_INT 2
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 1
33456: NEG
33457: PUSH
33458: LD_INT 1
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 2
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 2
33479: NEG
33480: PUSH
33481: LD_INT 2
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 2
33491: NEG
33492: PUSH
33493: LD_INT 3
33495: NEG
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PUSH
33501: LD_INT 2
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 3
33514: PUSH
33515: LD_INT 1
33517: PUSH
33518: EMPTY
33519: LIST
33520: LIST
33521: PUSH
33522: LD_INT 1
33524: PUSH
33525: LD_INT 3
33527: PUSH
33528: EMPTY
33529: LIST
33530: LIST
33531: PUSH
33532: LD_INT 1
33534: NEG
33535: PUSH
33536: LD_INT 2
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 3
33545: NEG
33546: PUSH
33547: LD_INT 2
33549: NEG
33550: PUSH
33551: EMPTY
33552: LIST
33553: LIST
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33580: LD_ADDR_VAR 0 30
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 0
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 1
33608: PUSH
33609: LD_INT 0
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 1
33621: PUSH
33622: EMPTY
33623: LIST
33624: LIST
33625: PUSH
33626: LD_INT 0
33628: PUSH
33629: LD_INT 1
33631: PUSH
33632: EMPTY
33633: LIST
33634: LIST
33635: PUSH
33636: LD_INT 1
33638: NEG
33639: PUSH
33640: LD_INT 0
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 1
33653: NEG
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: NEG
33662: PUSH
33663: LD_INT 2
33665: NEG
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 2
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 1
33684: PUSH
33685: LD_INT 1
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 2
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 2
33705: PUSH
33706: LD_INT 1
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 2
33715: PUSH
33716: LD_INT 2
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: LD_INT 1
33725: PUSH
33726: LD_INT 2
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 1
33735: NEG
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: NEG
33747: PUSH
33748: LD_INT 0
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 1
33769: NEG
33770: PUSH
33771: LD_INT 3
33773: NEG
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 1
33781: PUSH
33782: LD_INT 2
33784: NEG
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 3
33792: PUSH
33793: LD_INT 2
33795: PUSH
33796: EMPTY
33797: LIST
33798: LIST
33799: PUSH
33800: LD_INT 2
33802: PUSH
33803: LD_INT 3
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 2
33812: NEG
33813: PUSH
33814: LD_INT 1
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 3
33823: NEG
33824: PUSH
33825: LD_INT 1
33827: NEG
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: EMPTY
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33858: LD_ADDR_VAR 0 31
33862: PUSH
33863: LD_INT 0
33865: PUSH
33866: LD_INT 0
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 0
33875: PUSH
33876: LD_INT 1
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: LD_INT 0
33889: PUSH
33890: EMPTY
33891: LIST
33892: LIST
33893: PUSH
33894: LD_INT 1
33896: PUSH
33897: LD_INT 1
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 0
33906: PUSH
33907: LD_INT 1
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 1
33916: NEG
33917: PUSH
33918: LD_INT 0
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 1
33939: NEG
33940: PUSH
33941: LD_INT 2
33943: NEG
33944: PUSH
33945: EMPTY
33946: LIST
33947: LIST
33948: PUSH
33949: LD_INT 1
33951: PUSH
33952: LD_INT 1
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 2
33962: PUSH
33963: LD_INT 0
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 2
33982: PUSH
33983: LD_INT 2
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: NEG
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 2
34023: NEG
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 2
34035: NEG
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 2
34047: NEG
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 3
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 3
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 1
34090: NEG
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 3
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34136: LD_ADDR_VAR 0 32
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 1
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 1
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 1
34194: NEG
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: LD_INT 1
34209: NEG
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 1
34240: PUSH
34241: LD_INT 1
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 2
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 2
34261: PUSH
34262: LD_INT 2
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 1
34271: PUSH
34272: LD_INT 2
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 0
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: NEG
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 3
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: PUSH
34338: LD_INT 2
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 3
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: PUSH
34359: LD_INT 3
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 2
34368: NEG
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 3
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: NEG
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34414: LD_ADDR_VAR 0 33
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: LD_INT 2
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 2
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 2
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: PUSH
34539: LD_INT 2
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: LD_INT 0
34548: PUSH
34549: LD_INT 2
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 1
34558: NEG
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 2
34569: NEG
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 2
34580: NEG
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: LD_INT 2
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 2
34604: NEG
34605: PUSH
34606: LD_INT 3
34608: NEG
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: LD_INT 2
34616: PUSH
34617: LD_INT 1
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 3
34627: PUSH
34628: LD_INT 1
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: PUSH
34638: LD_INT 3
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 1
34647: NEG
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 3
34658: NEG
34659: PUSH
34660: LD_INT 2
34662: NEG
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34693: LD_ADDR_VAR 0 34
34697: PUSH
34698: LD_INT 0
34700: PUSH
34701: LD_INT 0
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: PUSH
34708: LD_INT 0
34710: PUSH
34711: LD_INT 1
34713: NEG
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 1
34721: PUSH
34722: LD_INT 0
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 1
34731: PUSH
34732: LD_INT 1
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 0
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 1
34751: NEG
34752: PUSH
34753: LD_INT 0
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 1
34762: NEG
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: EMPTY
34769: LIST
34770: LIST
34771: PUSH
34772: LD_INT 1
34774: NEG
34775: PUSH
34776: LD_INT 2
34778: NEG
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 0
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: PUSH
34798: LD_INT 1
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 2
34818: PUSH
34819: LD_INT 2
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: LD_INT 2
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 1
34838: NEG
34839: PUSH
34840: LD_INT 1
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 2
34849: NEG
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 1
34864: NEG
34865: PUSH
34866: EMPTY
34867: LIST
34868: LIST
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: LD_INT 2
34876: NEG
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 1
34884: NEG
34885: PUSH
34886: LD_INT 3
34888: NEG
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: PUSH
34894: LD_INT 1
34896: PUSH
34897: LD_INT 2
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 3
34907: PUSH
34908: LD_INT 2
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 2
34917: PUSH
34918: LD_INT 3
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: NEG
34928: PUSH
34929: LD_INT 1
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 3
34938: NEG
34939: PUSH
34940: LD_INT 1
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34973: LD_ADDR_VAR 0 35
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: LD_INT 0
34983: PUSH
34984: EMPTY
34985: LIST
34986: LIST
34987: PUSH
34988: LD_INT 0
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 0
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: LD_INT 1
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 0
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 1
35031: NEG
35032: PUSH
35033: LD_INT 0
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: LD_INT 1
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 2
35064: NEG
35065: PUSH
35066: LD_INT 1
35068: NEG
35069: PUSH
35070: EMPTY
35071: LIST
35072: LIST
35073: PUSH
35074: EMPTY
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35085: LD_ADDR_VAR 0 36
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: LD_INT 2
35181: PUSH
35182: EMPTY
35183: LIST
35184: LIST
35185: PUSH
35186: EMPTY
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: LIST
35193: LIST
35194: LIST
35195: LIST
35196: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35197: LD_ADDR_VAR 0 37
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: LD_INT 0
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 0
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 1
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 0
35245: PUSH
35246: LD_INT 1
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 1
35270: NEG
35271: PUSH
35272: EMPTY
35273: LIST
35274: LIST
35275: PUSH
35276: LD_INT 1
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: LD_INT 1
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: EMPTY
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35309: LD_ADDR_VAR 0 38
35313: PUSH
35314: LD_INT 0
35316: PUSH
35317: LD_INT 0
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 0
35326: PUSH
35327: LD_INT 1
35329: NEG
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: PUSH
35338: LD_INT 0
35340: PUSH
35341: EMPTY
35342: LIST
35343: LIST
35344: PUSH
35345: LD_INT 1
35347: PUSH
35348: LD_INT 1
35350: PUSH
35351: EMPTY
35352: LIST
35353: LIST
35354: PUSH
35355: LD_INT 0
35357: PUSH
35358: LD_INT 1
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 0
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: LD_INT 1
35382: NEG
35383: PUSH
35384: EMPTY
35385: LIST
35386: LIST
35387: PUSH
35388: LD_INT 2
35390: PUSH
35391: LD_INT 1
35393: PUSH
35394: EMPTY
35395: LIST
35396: LIST
35397: PUSH
35398: LD_INT 2
35400: NEG
35401: PUSH
35402: LD_INT 1
35404: NEG
35405: PUSH
35406: EMPTY
35407: LIST
35408: LIST
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35421: LD_ADDR_VAR 0 39
35425: PUSH
35426: LD_INT 0
35428: PUSH
35429: LD_INT 0
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 0
35438: PUSH
35439: LD_INT 1
35441: NEG
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: LD_INT 0
35452: PUSH
35453: EMPTY
35454: LIST
35455: LIST
35456: PUSH
35457: LD_INT 1
35459: PUSH
35460: LD_INT 1
35462: PUSH
35463: EMPTY
35464: LIST
35465: LIST
35466: PUSH
35467: LD_INT 0
35469: PUSH
35470: LD_INT 1
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: LD_INT 0
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: NEG
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 2
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: LD_INT 2
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: EMPTY
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35533: LD_ADDR_VAR 0 40
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: LD_INT 0
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 0
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 1
35561: PUSH
35562: LD_INT 0
35564: PUSH
35565: EMPTY
35566: LIST
35567: LIST
35568: PUSH
35569: LD_INT 1
35571: PUSH
35572: LD_INT 1
35574: PUSH
35575: EMPTY
35576: LIST
35577: LIST
35578: PUSH
35579: LD_INT 0
35581: PUSH
35582: LD_INT 1
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 0
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: NEG
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 1
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: NEG
35626: PUSH
35627: LD_INT 1
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35645: LD_ADDR_VAR 0 41
35649: PUSH
35650: LD_INT 0
35652: PUSH
35653: LD_INT 0
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 0
35662: PUSH
35663: LD_INT 1
35665: NEG
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 1
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: EMPTY
35678: LIST
35679: LIST
35680: PUSH
35681: LD_INT 1
35683: PUSH
35684: LD_INT 1
35686: PUSH
35687: EMPTY
35688: LIST
35689: LIST
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: LD_INT 1
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 0
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: EMPTY
35721: LIST
35722: LIST
35723: PUSH
35724: LD_INT 1
35726: NEG
35727: PUSH
35728: LD_INT 2
35730: NEG
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: PUSH
35739: LD_INT 1
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 2
35749: PUSH
35750: LD_INT 0
35752: PUSH
35753: EMPTY
35754: LIST
35755: LIST
35756: PUSH
35757: LD_INT 2
35759: PUSH
35760: LD_INT 1
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 2
35769: PUSH
35770: LD_INT 2
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 1
35779: PUSH
35780: LD_INT 2
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: NEG
35790: PUSH
35791: LD_INT 1
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 2
35800: NEG
35801: PUSH
35802: LD_INT 0
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 2
35811: NEG
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: EMPTY
35818: LIST
35819: LIST
35820: PUSH
35821: LD_INT 2
35823: NEG
35824: PUSH
35825: LD_INT 2
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 2
35835: NEG
35836: PUSH
35837: LD_INT 3
35839: NEG
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 2
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 3
35858: PUSH
35859: LD_INT 0
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 3
35868: PUSH
35869: LD_INT 1
35871: PUSH
35872: EMPTY
35873: LIST
35874: LIST
35875: PUSH
35876: LD_INT 3
35878: PUSH
35879: LD_INT 2
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 3
35888: PUSH
35889: LD_INT 3
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 3
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: NEG
35909: PUSH
35910: LD_INT 1
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 3
35919: NEG
35920: PUSH
35921: LD_INT 0
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: NEG
35931: PUSH
35932: LD_INT 1
35934: NEG
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 3
35942: NEG
35943: PUSH
35944: LD_INT 2
35946: NEG
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 3
35954: NEG
35955: PUSH
35956: LD_INT 3
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35995: LD_ADDR_VAR 0 42
35999: PUSH
36000: LD_INT 0
36002: PUSH
36003: LD_INT 0
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 0
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: PUSH
36024: LD_INT 0
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 0
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: NEG
36054: PUSH
36055: LD_INT 0
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 1
36064: NEG
36065: PUSH
36066: LD_INT 1
36068: NEG
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 1
36076: NEG
36077: PUSH
36078: LD_INT 2
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 0
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 1
36099: PUSH
36100: LD_INT 1
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 2
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: LD_INT 2
36133: PUSH
36134: EMPTY
36135: LIST
36136: LIST
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 2
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 1
36150: NEG
36151: PUSH
36152: LD_INT 1
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 2
36161: NEG
36162: PUSH
36163: LD_INT 1
36165: NEG
36166: PUSH
36167: EMPTY
36168: LIST
36169: LIST
36170: PUSH
36171: LD_INT 2
36173: NEG
36174: PUSH
36175: LD_INT 2
36177: NEG
36178: PUSH
36179: EMPTY
36180: LIST
36181: LIST
36182: PUSH
36183: LD_INT 2
36185: NEG
36186: PUSH
36187: LD_INT 3
36189: NEG
36190: PUSH
36191: EMPTY
36192: LIST
36193: LIST
36194: PUSH
36195: LD_INT 1
36197: NEG
36198: PUSH
36199: LD_INT 3
36201: NEG
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 0
36209: PUSH
36210: LD_INT 3
36212: NEG
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: PUSH
36221: LD_INT 2
36223: NEG
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 3
36231: PUSH
36232: LD_INT 2
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 3
36241: PUSH
36242: LD_INT 3
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 2
36251: PUSH
36252: LD_INT 3
36254: PUSH
36255: EMPTY
36256: LIST
36257: LIST
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: LD_INT 3
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: LD_INT 3
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 2
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 3
36292: NEG
36293: PUSH
36294: LD_INT 2
36296: NEG
36297: PUSH
36298: EMPTY
36299: LIST
36300: LIST
36301: PUSH
36302: LD_INT 3
36304: NEG
36305: PUSH
36306: LD_INT 3
36308: NEG
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36345: LD_ADDR_VAR 0 43
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: LD_INT 0
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 1
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 0
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: LD_INT 1
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 0
36393: PUSH
36394: LD_INT 1
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 1
36403: NEG
36404: PUSH
36405: LD_INT 0
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 1
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 1
36426: NEG
36427: PUSH
36428: LD_INT 2
36430: NEG
36431: PUSH
36432: EMPTY
36433: LIST
36434: LIST
36435: PUSH
36436: LD_INT 0
36438: PUSH
36439: LD_INT 2
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 1
36449: PUSH
36450: LD_INT 1
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 2
36460: PUSH
36461: LD_INT 0
36463: PUSH
36464: EMPTY
36465: LIST
36466: LIST
36467: PUSH
36468: LD_INT 2
36470: PUSH
36471: LD_INT 1
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: LD_INT 1
36480: PUSH
36481: LD_INT 2
36483: PUSH
36484: EMPTY
36485: LIST
36486: LIST
36487: PUSH
36488: LD_INT 0
36490: PUSH
36491: LD_INT 2
36493: PUSH
36494: EMPTY
36495: LIST
36496: LIST
36497: PUSH
36498: LD_INT 1
36500: NEG
36501: PUSH
36502: LD_INT 1
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 2
36511: NEG
36512: PUSH
36513: LD_INT 0
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 2
36522: NEG
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: NEG
36535: PUSH
36536: LD_INT 3
36538: NEG
36539: PUSH
36540: EMPTY
36541: LIST
36542: LIST
36543: PUSH
36544: LD_INT 0
36546: PUSH
36547: LD_INT 3
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: LD_INT 2
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 2
36568: PUSH
36569: LD_INT 1
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 3
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 3
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: LD_INT 3
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 0
36609: PUSH
36610: LD_INT 3
36612: PUSH
36613: EMPTY
36614: LIST
36615: LIST
36616: PUSH
36617: LD_INT 1
36619: NEG
36620: PUSH
36621: LD_INT 2
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 2
36630: NEG
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 3
36641: NEG
36642: PUSH
36643: LD_INT 0
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 3
36652: NEG
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: EMPTY
36659: LIST
36660: LIST
36661: PUSH
36662: EMPTY
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36693: LD_ADDR_VAR 0 44
36697: PUSH
36698: LD_INT 0
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: EMPTY
36705: LIST
36706: LIST
36707: PUSH
36708: LD_INT 0
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 1
36721: PUSH
36722: LD_INT 0
36724: PUSH
36725: EMPTY
36726: LIST
36727: LIST
36728: PUSH
36729: LD_INT 1
36731: PUSH
36732: LD_INT 1
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 0
36741: PUSH
36742: LD_INT 1
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 1
36751: NEG
36752: PUSH
36753: LD_INT 0
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: LD_INT 1
36766: NEG
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 2
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 1
36786: PUSH
36787: LD_INT 1
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 2
36797: PUSH
36798: LD_INT 0
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: PUSH
36808: LD_INT 1
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 2
36817: PUSH
36818: LD_INT 2
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 1
36827: PUSH
36828: LD_INT 2
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 1
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 2
36848: NEG
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: NEG
36872: PUSH
36873: LD_INT 2
36875: NEG
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 2
36883: NEG
36884: PUSH
36885: LD_INT 3
36887: NEG
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 2
36895: PUSH
36896: LD_INT 1
36898: NEG
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 3
36906: PUSH
36907: LD_INT 0
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 3
36916: PUSH
36917: LD_INT 1
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 3
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: LD_INT 3
36936: PUSH
36937: LD_INT 3
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 3
36949: PUSH
36950: EMPTY
36951: LIST
36952: LIST
36953: PUSH
36954: LD_INT 2
36956: NEG
36957: PUSH
36958: LD_INT 1
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 3
36967: NEG
36968: PUSH
36969: LD_INT 0
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 3
36978: NEG
36979: PUSH
36980: LD_INT 1
36982: NEG
36983: PUSH
36984: EMPTY
36985: LIST
36986: LIST
36987: PUSH
36988: LD_INT 3
36990: NEG
36991: PUSH
36992: LD_INT 2
36994: NEG
36995: PUSH
36996: EMPTY
36997: LIST
36998: LIST
36999: PUSH
37000: LD_INT 3
37002: NEG
37003: PUSH
37004: LD_INT 3
37006: NEG
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: EMPTY
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37043: LD_ADDR_VAR 0 45
37047: PUSH
37048: LD_INT 0
37050: PUSH
37051: LD_INT 0
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 0
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 1
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 1
37081: PUSH
37082: LD_INT 1
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 0
37091: PUSH
37092: LD_INT 1
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 1
37101: NEG
37102: PUSH
37103: LD_INT 0
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: LD_INT 1
37116: NEG
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 1
37124: NEG
37125: PUSH
37126: LD_INT 2
37128: NEG
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 0
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 1
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: PUSH
37159: LD_INT 1
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 2
37168: PUSH
37169: LD_INT 2
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 1
37178: PUSH
37179: LD_INT 2
37181: PUSH
37182: EMPTY
37183: LIST
37184: LIST
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: LD_INT 2
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PUSH
37196: LD_INT 1
37198: NEG
37199: PUSH
37200: LD_INT 1
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 2
37209: NEG
37210: PUSH
37211: LD_INT 1
37213: NEG
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 2
37221: NEG
37222: PUSH
37223: LD_INT 2
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 2
37233: NEG
37234: PUSH
37235: LD_INT 3
37237: NEG
37238: PUSH
37239: EMPTY
37240: LIST
37241: LIST
37242: PUSH
37243: LD_INT 1
37245: NEG
37246: PUSH
37247: LD_INT 3
37249: NEG
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 0
37257: PUSH
37258: LD_INT 3
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: LD_INT 2
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 3
37279: PUSH
37280: LD_INT 2
37282: PUSH
37283: EMPTY
37284: LIST
37285: LIST
37286: PUSH
37287: LD_INT 3
37289: PUSH
37290: LD_INT 3
37292: PUSH
37293: EMPTY
37294: LIST
37295: LIST
37296: PUSH
37297: LD_INT 2
37299: PUSH
37300: LD_INT 3
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: LD_INT 3
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 0
37319: PUSH
37320: LD_INT 3
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: LD_INT 2
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 3
37340: NEG
37341: PUSH
37342: LD_INT 2
37344: NEG
37345: PUSH
37346: EMPTY
37347: LIST
37348: LIST
37349: PUSH
37350: LD_INT 3
37352: NEG
37353: PUSH
37354: LD_INT 3
37356: NEG
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37393: LD_ADDR_VAR 0 46
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: LD_INT 0
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: LD_INT 1
37413: NEG
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 1
37431: PUSH
37432: LD_INT 1
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 0
37441: PUSH
37442: LD_INT 1
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 1
37451: NEG
37452: PUSH
37453: LD_INT 0
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: NEG
37463: PUSH
37464: LD_INT 1
37466: NEG
37467: PUSH
37468: EMPTY
37469: LIST
37470: LIST
37471: PUSH
37472: LD_INT 1
37474: NEG
37475: PUSH
37476: LD_INT 2
37478: NEG
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: LD_INT 2
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: PUSH
37498: LD_INT 1
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 2
37508: PUSH
37509: LD_INT 0
37511: PUSH
37512: EMPTY
37513: LIST
37514: LIST
37515: PUSH
37516: LD_INT 2
37518: PUSH
37519: LD_INT 1
37521: PUSH
37522: EMPTY
37523: LIST
37524: LIST
37525: PUSH
37526: LD_INT 1
37528: PUSH
37529: LD_INT 2
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 0
37538: PUSH
37539: LD_INT 2
37541: PUSH
37542: EMPTY
37543: LIST
37544: LIST
37545: PUSH
37546: LD_INT 1
37548: NEG
37549: PUSH
37550: LD_INT 1
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 2
37559: NEG
37560: PUSH
37561: LD_INT 0
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 2
37570: NEG
37571: PUSH
37572: LD_INT 1
37574: NEG
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 1
37582: NEG
37583: PUSH
37584: LD_INT 3
37586: NEG
37587: PUSH
37588: EMPTY
37589: LIST
37590: LIST
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: LD_INT 3
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 1
37605: PUSH
37606: LD_INT 2
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 2
37616: PUSH
37617: LD_INT 1
37619: NEG
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 3
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 3
37637: PUSH
37638: LD_INT 1
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: LD_INT 3
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: LD_INT 3
37660: PUSH
37661: EMPTY
37662: LIST
37663: LIST
37664: PUSH
37665: LD_INT 1
37667: NEG
37668: PUSH
37669: LD_INT 2
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 2
37678: NEG
37679: PUSH
37680: LD_INT 1
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 3
37689: NEG
37690: PUSH
37691: LD_INT 0
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 3
37700: NEG
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: EMPTY
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37741: LD_ADDR_VAR 0 47
37745: PUSH
37746: LD_INT 0
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: EMPTY
37753: LIST
37754: LIST
37755: PUSH
37756: LD_INT 0
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 1
37769: PUSH
37770: LD_INT 0
37772: PUSH
37773: EMPTY
37774: LIST
37775: LIST
37776: PUSH
37777: LD_INT 1
37779: PUSH
37780: LD_INT 1
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 0
37789: PUSH
37790: LD_INT 1
37792: PUSH
37793: EMPTY
37794: LIST
37795: LIST
37796: PUSH
37797: LD_INT 1
37799: NEG
37800: PUSH
37801: LD_INT 0
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 1
37810: NEG
37811: PUSH
37812: LD_INT 1
37814: NEG
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: LD_INT 2
37826: NEG
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 0
37834: PUSH
37835: LD_INT 2
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 1
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 2
37856: NEG
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 2
37868: NEG
37869: PUSH
37870: LD_INT 2
37872: NEG
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37892: LD_ADDR_VAR 0 48
37896: PUSH
37897: LD_INT 0
37899: PUSH
37900: LD_INT 0
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 0
37909: PUSH
37910: LD_INT 1
37912: NEG
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 1
37920: PUSH
37921: LD_INT 0
37923: PUSH
37924: EMPTY
37925: LIST
37926: LIST
37927: PUSH
37928: LD_INT 1
37930: PUSH
37931: LD_INT 1
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 0
37940: PUSH
37941: LD_INT 1
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 1
37950: NEG
37951: PUSH
37952: LD_INT 0
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 1
37961: NEG
37962: PUSH
37963: LD_INT 1
37965: NEG
37966: PUSH
37967: EMPTY
37968: LIST
37969: LIST
37970: PUSH
37971: LD_INT 1
37973: NEG
37974: PUSH
37975: LD_INT 2
37977: NEG
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 1
37996: PUSH
37997: LD_INT 1
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 2
38007: PUSH
38008: LD_INT 0
38010: PUSH
38011: EMPTY
38012: LIST
38013: LIST
38014: PUSH
38015: LD_INT 2
38017: PUSH
38018: LD_INT 1
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PUSH
38025: EMPTY
38026: LIST
38027: LIST
38028: LIST
38029: LIST
38030: LIST
38031: LIST
38032: LIST
38033: LIST
38034: LIST
38035: LIST
38036: LIST
38037: LIST
38038: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38039: LD_ADDR_VAR 0 49
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: LD_INT 0
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: LD_INT 1
38059: NEG
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: PUSH
38068: LD_INT 0
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: LD_INT 1
38080: PUSH
38081: EMPTY
38082: LIST
38083: LIST
38084: PUSH
38085: LD_INT 0
38087: PUSH
38088: LD_INT 1
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: NEG
38098: PUSH
38099: LD_INT 0
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: LD_INT 1
38112: NEG
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: LD_INT 1
38123: NEG
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 2
38131: PUSH
38132: LD_INT 0
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 2
38141: PUSH
38142: LD_INT 1
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 2
38151: PUSH
38152: LD_INT 2
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 1
38161: PUSH
38162: LD_INT 2
38164: PUSH
38165: EMPTY
38166: LIST
38167: LIST
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: LIST
38173: LIST
38174: LIST
38175: LIST
38176: LIST
38177: LIST
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38183: LD_ADDR_VAR 0 50
38187: PUSH
38188: LD_INT 0
38190: PUSH
38191: LD_INT 0
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 0
38200: PUSH
38201: LD_INT 1
38203: NEG
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 1
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: LD_INT 1
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 0
38231: PUSH
38232: LD_INT 1
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 1
38256: NEG
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 2
38264: PUSH
38265: LD_INT 1
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PUSH
38272: LD_INT 2
38274: PUSH
38275: LD_INT 2
38277: PUSH
38278: EMPTY
38279: LIST
38280: LIST
38281: PUSH
38282: LD_INT 1
38284: PUSH
38285: LD_INT 2
38287: PUSH
38288: EMPTY
38289: LIST
38290: LIST
38291: PUSH
38292: LD_INT 0
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: EMPTY
38299: LIST
38300: LIST
38301: PUSH
38302: LD_INT 1
38304: NEG
38305: PUSH
38306: LD_INT 1
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: EMPTY
38314: LIST
38315: LIST
38316: LIST
38317: LIST
38318: LIST
38319: LIST
38320: LIST
38321: LIST
38322: LIST
38323: LIST
38324: LIST
38325: LIST
38326: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38327: LD_ADDR_VAR 0 51
38331: PUSH
38332: LD_INT 0
38334: PUSH
38335: LD_INT 0
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 0
38344: PUSH
38345: LD_INT 1
38347: NEG
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: LD_INT 1
38368: PUSH
38369: EMPTY
38370: LIST
38371: LIST
38372: PUSH
38373: LD_INT 0
38375: PUSH
38376: LD_INT 1
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 1
38385: NEG
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: NEG
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: LD_INT 2
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 0
38418: PUSH
38419: LD_INT 2
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 1
38428: NEG
38429: PUSH
38430: LD_INT 1
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 2
38439: NEG
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 2
38450: NEG
38451: PUSH
38452: LD_INT 1
38454: NEG
38455: PUSH
38456: EMPTY
38457: LIST
38458: LIST
38459: PUSH
38460: EMPTY
38461: LIST
38462: LIST
38463: LIST
38464: LIST
38465: LIST
38466: LIST
38467: LIST
38468: LIST
38469: LIST
38470: LIST
38471: LIST
38472: LIST
38473: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38474: LD_ADDR_VAR 0 52
38478: PUSH
38479: LD_INT 0
38481: PUSH
38482: LD_INT 0
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: LD_INT 0
38491: PUSH
38492: LD_INT 1
38494: NEG
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: LD_INT 1
38512: PUSH
38513: LD_INT 1
38515: PUSH
38516: EMPTY
38517: LIST
38518: LIST
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 1
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 1
38532: NEG
38533: PUSH
38534: LD_INT 0
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: LD_INT 1
38547: NEG
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 1
38555: NEG
38556: PUSH
38557: LD_INT 2
38559: NEG
38560: PUSH
38561: EMPTY
38562: LIST
38563: LIST
38564: PUSH
38565: LD_INT 1
38567: NEG
38568: PUSH
38569: LD_INT 1
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 2
38578: NEG
38579: PUSH
38580: LD_INT 0
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 2
38589: NEG
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 2
38601: NEG
38602: PUSH
38603: LD_INT 2
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: EMPTY
38612: LIST
38613: LIST
38614: LIST
38615: LIST
38616: LIST
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38625: LD_ADDR_VAR 0 53
38629: PUSH
38630: LD_INT 0
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: LD_INT 0
38642: PUSH
38643: LD_INT 1
38645: NEG
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 1
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 1
38663: PUSH
38664: LD_INT 1
38666: PUSH
38667: EMPTY
38668: LIST
38669: LIST
38670: PUSH
38671: LD_INT 0
38673: PUSH
38674: LD_INT 1
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 1
38683: NEG
38684: PUSH
38685: LD_INT 0
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: NEG
38695: PUSH
38696: LD_INT 1
38698: NEG
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: LD_INT 2
38710: NEG
38711: PUSH
38712: EMPTY
38713: LIST
38714: LIST
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: PUSH
38730: LD_INT 1
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 2
38740: PUSH
38741: LD_INT 0
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: PUSH
38748: LD_INT 2
38750: PUSH
38751: LD_INT 1
38753: PUSH
38754: EMPTY
38755: LIST
38756: LIST
38757: PUSH
38758: LD_INT 2
38760: PUSH
38761: LD_INT 2
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 1
38770: PUSH
38771: LD_INT 2
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: LD_INT 2
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: LD_INT 1
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 2
38801: NEG
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: LD_INT 1
38816: NEG
38817: PUSH
38818: EMPTY
38819: LIST
38820: LIST
38821: PUSH
38822: LD_INT 2
38824: NEG
38825: PUSH
38826: LD_INT 2
38828: NEG
38829: PUSH
38830: EMPTY
38831: LIST
38832: LIST
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: LIST
38838: LIST
38839: LIST
38840: LIST
38841: LIST
38842: LIST
38843: LIST
38844: LIST
38845: LIST
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38855: LD_ADDR_VAR 0 54
38859: PUSH
38860: LD_INT 0
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 0
38872: PUSH
38873: LD_INT 1
38875: NEG
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 1
38883: PUSH
38884: LD_INT 0
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: PUSH
38891: LD_INT 1
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: EMPTY
38898: LIST
38899: LIST
38900: PUSH
38901: LD_INT 0
38903: PUSH
38904: LD_INT 1
38906: PUSH
38907: EMPTY
38908: LIST
38909: LIST
38910: PUSH
38911: LD_INT 1
38913: NEG
38914: PUSH
38915: LD_INT 0
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 1
38928: NEG
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 1
38936: NEG
38937: PUSH
38938: LD_INT 2
38940: NEG
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: NEG
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 2
38970: PUSH
38971: LD_INT 0
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 2
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 2
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 1
39000: PUSH
39001: LD_INT 2
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 2
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: LD_INT 1
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 2
39031: NEG
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: LD_INT 1
39046: NEG
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 2
39054: NEG
39055: PUSH
39056: LD_INT 2
39058: NEG
39059: PUSH
39060: EMPTY
39061: LIST
39062: LIST
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: LIST
39068: LIST
39069: LIST
39070: LIST
39071: LIST
39072: LIST
39073: LIST
39074: LIST
39075: LIST
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39085: LD_ADDR_VAR 0 55
39089: PUSH
39090: LD_INT 0
39092: PUSH
39093: LD_INT 0
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: LD_INT 0
39102: PUSH
39103: LD_INT 1
39105: NEG
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 1
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: PUSH
39124: LD_INT 1
39126: PUSH
39127: EMPTY
39128: LIST
39129: LIST
39130: PUSH
39131: LD_INT 0
39133: PUSH
39134: LD_INT 1
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 1
39143: NEG
39144: PUSH
39145: LD_INT 0
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 1
39154: NEG
39155: PUSH
39156: LD_INT 1
39158: NEG
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 2
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 0
39178: PUSH
39179: LD_INT 2
39181: NEG
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 1
39189: PUSH
39190: LD_INT 1
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: EMPTY
39215: LIST
39216: LIST
39217: PUSH
39218: LD_INT 2
39220: PUSH
39221: LD_INT 2
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PUSH
39228: LD_INT 1
39230: PUSH
39231: LD_INT 2
39233: PUSH
39234: EMPTY
39235: LIST
39236: LIST
39237: PUSH
39238: LD_INT 0
39240: PUSH
39241: LD_INT 2
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 1
39250: NEG
39251: PUSH
39252: LD_INT 1
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 2
39261: NEG
39262: PUSH
39263: LD_INT 0
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 1
39276: NEG
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 2
39284: NEG
39285: PUSH
39286: LD_INT 2
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: LIST
39301: LIST
39302: LIST
39303: LIST
39304: LIST
39305: LIST
39306: LIST
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39315: LD_ADDR_VAR 0 56
39319: PUSH
39320: LD_INT 0
39322: PUSH
39323: LD_INT 0
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: PUSH
39330: LD_INT 0
39332: PUSH
39333: LD_INT 1
39335: NEG
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 1
39343: PUSH
39344: LD_INT 0
39346: PUSH
39347: EMPTY
39348: LIST
39349: LIST
39350: PUSH
39351: LD_INT 1
39353: PUSH
39354: LD_INT 1
39356: PUSH
39357: EMPTY
39358: LIST
39359: LIST
39360: PUSH
39361: LD_INT 0
39363: PUSH
39364: LD_INT 1
39366: PUSH
39367: EMPTY
39368: LIST
39369: LIST
39370: PUSH
39371: LD_INT 1
39373: NEG
39374: PUSH
39375: LD_INT 0
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 1
39384: NEG
39385: PUSH
39386: LD_INT 1
39388: NEG
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: LD_INT 2
39400: NEG
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: PUSH
39406: LD_INT 0
39408: PUSH
39409: LD_INT 2
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 1
39419: PUSH
39420: LD_INT 1
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 2
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 2
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: EMPTY
39445: LIST
39446: LIST
39447: PUSH
39448: LD_INT 2
39450: PUSH
39451: LD_INT 2
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 1
39460: PUSH
39461: LD_INT 2
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 0
39470: PUSH
39471: LD_INT 2
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 1
39480: NEG
39481: PUSH
39482: LD_INT 1
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 2
39491: NEG
39492: PUSH
39493: LD_INT 0
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: LD_INT 1
39506: NEG
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 2
39514: NEG
39515: PUSH
39516: LD_INT 2
39518: NEG
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: LIST
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39545: LD_ADDR_VAR 0 57
39549: PUSH
39550: LD_INT 0
39552: PUSH
39553: LD_INT 0
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: LD_INT 1
39565: NEG
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 1
39573: PUSH
39574: LD_INT 0
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: PUSH
39581: LD_INT 1
39583: PUSH
39584: LD_INT 1
39586: PUSH
39587: EMPTY
39588: LIST
39589: LIST
39590: PUSH
39591: LD_INT 0
39593: PUSH
39594: LD_INT 1
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 1
39603: NEG
39604: PUSH
39605: LD_INT 0
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 1
39614: NEG
39615: PUSH
39616: LD_INT 1
39618: NEG
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 1
39626: NEG
39627: PUSH
39628: LD_INT 2
39630: NEG
39631: PUSH
39632: EMPTY
39633: LIST
39634: LIST
39635: PUSH
39636: LD_INT 0
39638: PUSH
39639: LD_INT 2
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 1
39649: PUSH
39650: LD_INT 1
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 2
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: EMPTY
39675: LIST
39676: LIST
39677: PUSH
39678: LD_INT 2
39680: PUSH
39681: LD_INT 2
39683: PUSH
39684: EMPTY
39685: LIST
39686: LIST
39687: PUSH
39688: LD_INT 1
39690: PUSH
39691: LD_INT 2
39693: PUSH
39694: EMPTY
39695: LIST
39696: LIST
39697: PUSH
39698: LD_INT 0
39700: PUSH
39701: LD_INT 2
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: NEG
39711: PUSH
39712: LD_INT 1
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 2
39721: NEG
39722: PUSH
39723: LD_INT 0
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: LD_INT 1
39736: NEG
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 2
39744: NEG
39745: PUSH
39746: LD_INT 2
39748: NEG
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: LIST
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39775: LD_ADDR_VAR 0 58
39779: PUSH
39780: LD_INT 0
39782: PUSH
39783: LD_INT 0
39785: PUSH
39786: EMPTY
39787: LIST
39788: LIST
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: LD_INT 1
39795: NEG
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: EMPTY
39808: LIST
39809: LIST
39810: PUSH
39811: LD_INT 1
39813: PUSH
39814: LD_INT 1
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 1
39833: NEG
39834: PUSH
39835: LD_INT 0
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: LD_INT 1
39848: NEG
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 1
39856: NEG
39857: PUSH
39858: LD_INT 2
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 0
39868: PUSH
39869: LD_INT 2
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 1
39879: PUSH
39880: LD_INT 1
39882: NEG
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 2
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 2
39900: PUSH
39901: LD_INT 1
39903: PUSH
39904: EMPTY
39905: LIST
39906: LIST
39907: PUSH
39908: LD_INT 2
39910: PUSH
39911: LD_INT 2
39913: PUSH
39914: EMPTY
39915: LIST
39916: LIST
39917: PUSH
39918: LD_INT 1
39920: PUSH
39921: LD_INT 2
39923: PUSH
39924: EMPTY
39925: LIST
39926: LIST
39927: PUSH
39928: LD_INT 0
39930: PUSH
39931: LD_INT 2
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 1
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 2
39951: NEG
39952: PUSH
39953: LD_INT 0
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 2
39962: NEG
39963: PUSH
39964: LD_INT 1
39966: NEG
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 2
39974: NEG
39975: PUSH
39976: LD_INT 2
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: LIST
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40005: LD_ADDR_VAR 0 59
40009: PUSH
40010: LD_INT 0
40012: PUSH
40013: LD_INT 0
40015: PUSH
40016: EMPTY
40017: LIST
40018: LIST
40019: PUSH
40020: LD_INT 0
40022: PUSH
40023: LD_INT 1
40025: NEG
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 1
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: EMPTY
40038: LIST
40039: LIST
40040: PUSH
40041: LD_INT 1
40043: PUSH
40044: LD_INT 1
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: PUSH
40051: LD_INT 0
40053: PUSH
40054: LD_INT 1
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 1
40063: NEG
40064: PUSH
40065: LD_INT 0
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 1
40074: NEG
40075: PUSH
40076: LD_INT 1
40078: NEG
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: EMPTY
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40093: LD_ADDR_VAR 0 60
40097: PUSH
40098: LD_INT 0
40100: PUSH
40101: LD_INT 0
40103: PUSH
40104: EMPTY
40105: LIST
40106: LIST
40107: PUSH
40108: LD_INT 0
40110: PUSH
40111: LD_INT 1
40113: NEG
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: PUSH
40122: LD_INT 0
40124: PUSH
40125: EMPTY
40126: LIST
40127: LIST
40128: PUSH
40129: LD_INT 1
40131: PUSH
40132: LD_INT 1
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 0
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: EMPTY
40146: LIST
40147: LIST
40148: PUSH
40149: LD_INT 1
40151: NEG
40152: PUSH
40153: LD_INT 0
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: PUSH
40160: LD_INT 1
40162: NEG
40163: PUSH
40164: LD_INT 1
40166: NEG
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: LIST
40176: LIST
40177: LIST
40178: LIST
40179: LIST
40180: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40181: LD_ADDR_VAR 0 61
40185: PUSH
40186: LD_INT 0
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 1
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: PUSH
40220: LD_INT 1
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 1
40239: NEG
40240: PUSH
40241: LD_INT 0
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 1
40254: NEG
40255: PUSH
40256: EMPTY
40257: LIST
40258: LIST
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40269: LD_ADDR_VAR 0 62
40273: PUSH
40274: LD_INT 0
40276: PUSH
40277: LD_INT 0
40279: PUSH
40280: EMPTY
40281: LIST
40282: LIST
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: LD_INT 1
40289: NEG
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 1
40297: PUSH
40298: LD_INT 0
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: PUSH
40308: LD_INT 1
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 0
40317: PUSH
40318: LD_INT 1
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 1
40327: NEG
40328: PUSH
40329: LD_INT 0
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: NEG
40339: PUSH
40340: LD_INT 1
40342: NEG
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: LIST
40352: LIST
40353: LIST
40354: LIST
40355: LIST
40356: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40357: LD_ADDR_VAR 0 63
40361: PUSH
40362: LD_INT 0
40364: PUSH
40365: LD_INT 0
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 0
40374: PUSH
40375: LD_INT 1
40377: NEG
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 1
40385: PUSH
40386: LD_INT 0
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 1
40395: PUSH
40396: LD_INT 1
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 0
40405: PUSH
40406: LD_INT 1
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: LD_INT 0
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 1
40430: NEG
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40445: LD_ADDR_VAR 0 64
40449: PUSH
40450: LD_INT 0
40452: PUSH
40453: LD_INT 0
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: LD_INT 1
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 1
40473: PUSH
40474: LD_INT 0
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 1
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 0
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: NEG
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 1
40518: NEG
40519: PUSH
40520: EMPTY
40521: LIST
40522: LIST
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: LIST
40528: LIST
40529: LIST
40530: LIST
40531: LIST
40532: ST_TO_ADDR
// end ; 1 :
40533: GO 46430
40535: LD_INT 1
40537: DOUBLE
40538: EQUAL
40539: IFTRUE 40543
40541: GO 43166
40543: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40544: LD_ADDR_VAR 0 11
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 3
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 0
40563: PUSH
40564: LD_INT 3
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 1
40574: PUSH
40575: LD_INT 2
40577: NEG
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: LIST
40587: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40588: LD_ADDR_VAR 0 12
40592: PUSH
40593: LD_INT 2
40595: PUSH
40596: LD_INT 1
40598: NEG
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 3
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 3
40616: PUSH
40617: LD_INT 1
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: LIST
40628: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40629: LD_ADDR_VAR 0 13
40633: PUSH
40634: LD_INT 3
40636: PUSH
40637: LD_INT 2
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: PUSH
40644: LD_INT 3
40646: PUSH
40647: LD_INT 3
40649: PUSH
40650: EMPTY
40651: LIST
40652: LIST
40653: PUSH
40654: LD_INT 2
40656: PUSH
40657: LD_INT 3
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: LIST
40668: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40669: LD_ADDR_VAR 0 14
40673: PUSH
40674: LD_INT 1
40676: PUSH
40677: LD_INT 3
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 0
40686: PUSH
40687: LD_INT 3
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 1
40696: NEG
40697: PUSH
40698: LD_INT 2
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: EMPTY
40706: LIST
40707: LIST
40708: LIST
40709: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40710: LD_ADDR_VAR 0 15
40714: PUSH
40715: LD_INT 2
40717: NEG
40718: PUSH
40719: LD_INT 1
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 3
40728: NEG
40729: PUSH
40730: LD_INT 0
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 3
40739: NEG
40740: PUSH
40741: LD_INT 1
40743: NEG
40744: PUSH
40745: EMPTY
40746: LIST
40747: LIST
40748: PUSH
40749: EMPTY
40750: LIST
40751: LIST
40752: LIST
40753: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40754: LD_ADDR_VAR 0 16
40758: PUSH
40759: LD_INT 2
40761: NEG
40762: PUSH
40763: LD_INT 3
40765: NEG
40766: PUSH
40767: EMPTY
40768: LIST
40769: LIST
40770: PUSH
40771: LD_INT 3
40773: NEG
40774: PUSH
40775: LD_INT 2
40777: NEG
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 3
40785: NEG
40786: PUSH
40787: LD_INT 3
40789: NEG
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: LIST
40799: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40800: LD_ADDR_VAR 0 17
40804: PUSH
40805: LD_INT 1
40807: NEG
40808: PUSH
40809: LD_INT 3
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 0
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 1
40830: PUSH
40831: LD_INT 2
40833: NEG
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: LIST
40843: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40844: LD_ADDR_VAR 0 18
40848: PUSH
40849: LD_INT 2
40851: PUSH
40852: LD_INT 1
40854: NEG
40855: PUSH
40856: EMPTY
40857: LIST
40858: LIST
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: LD_INT 0
40865: PUSH
40866: EMPTY
40867: LIST
40868: LIST
40869: PUSH
40870: LD_INT 3
40872: PUSH
40873: LD_INT 1
40875: PUSH
40876: EMPTY
40877: LIST
40878: LIST
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: LIST
40884: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40885: LD_ADDR_VAR 0 19
40889: PUSH
40890: LD_INT 3
40892: PUSH
40893: LD_INT 2
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: LD_INT 3
40905: PUSH
40906: EMPTY
40907: LIST
40908: LIST
40909: PUSH
40910: LD_INT 2
40912: PUSH
40913: LD_INT 3
40915: PUSH
40916: EMPTY
40917: LIST
40918: LIST
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: LIST
40924: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40925: LD_ADDR_VAR 0 20
40929: PUSH
40930: LD_INT 1
40932: PUSH
40933: LD_INT 3
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: PUSH
40940: LD_INT 0
40942: PUSH
40943: LD_INT 3
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 1
40952: NEG
40953: PUSH
40954: LD_INT 2
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: LIST
40965: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40966: LD_ADDR_VAR 0 21
40970: PUSH
40971: LD_INT 2
40973: NEG
40974: PUSH
40975: LD_INT 1
40977: PUSH
40978: EMPTY
40979: LIST
40980: LIST
40981: PUSH
40982: LD_INT 3
40984: NEG
40985: PUSH
40986: LD_INT 0
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 3
40995: NEG
40996: PUSH
40997: LD_INT 1
40999: NEG
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41010: LD_ADDR_VAR 0 22
41014: PUSH
41015: LD_INT 2
41017: NEG
41018: PUSH
41019: LD_INT 3
41021: NEG
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 3
41029: NEG
41030: PUSH
41031: LD_INT 2
41033: NEG
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: LD_INT 3
41041: NEG
41042: PUSH
41043: LD_INT 3
41045: NEG
41046: PUSH
41047: EMPTY
41048: LIST
41049: LIST
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: LIST
41055: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41056: LD_ADDR_VAR 0 23
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: LD_INT 3
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 1
41074: NEG
41075: PUSH
41076: LD_INT 4
41078: NEG
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 1
41086: PUSH
41087: LD_INT 3
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: LIST
41099: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41100: LD_ADDR_VAR 0 24
41104: PUSH
41105: LD_INT 3
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 3
41117: PUSH
41118: LD_INT 1
41120: NEG
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 4
41128: PUSH
41129: LD_INT 1
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41141: LD_ADDR_VAR 0 25
41145: PUSH
41146: LD_INT 3
41148: PUSH
41149: LD_INT 3
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 4
41158: PUSH
41159: LD_INT 3
41161: PUSH
41162: EMPTY
41163: LIST
41164: LIST
41165: PUSH
41166: LD_INT 3
41168: PUSH
41169: LD_INT 4
41171: PUSH
41172: EMPTY
41173: LIST
41174: LIST
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: LIST
41180: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41181: LD_ADDR_VAR 0 26
41185: PUSH
41186: LD_INT 0
41188: PUSH
41189: LD_INT 3
41191: PUSH
41192: EMPTY
41193: LIST
41194: LIST
41195: PUSH
41196: LD_INT 1
41198: PUSH
41199: LD_INT 4
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 1
41208: NEG
41209: PUSH
41210: LD_INT 3
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: LIST
41221: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41222: LD_ADDR_VAR 0 27
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: LD_INT 0
41233: PUSH
41234: EMPTY
41235: LIST
41236: LIST
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: LD_INT 1
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 4
41251: NEG
41252: PUSH
41253: LD_INT 1
41255: NEG
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41266: LD_ADDR_VAR 0 28
41270: PUSH
41271: LD_INT 3
41273: NEG
41274: PUSH
41275: LD_INT 3
41277: NEG
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: LD_INT 3
41285: NEG
41286: PUSH
41287: LD_INT 4
41289: NEG
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: LD_INT 4
41297: NEG
41298: PUSH
41299: LD_INT 3
41301: NEG
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: PUSH
41307: EMPTY
41308: LIST
41309: LIST
41310: LIST
41311: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41312: LD_ADDR_VAR 0 29
41316: PUSH
41317: LD_INT 1
41319: NEG
41320: PUSH
41321: LD_INT 3
41323: NEG
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 0
41331: PUSH
41332: LD_INT 3
41334: NEG
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 1
41342: PUSH
41343: LD_INT 2
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 1
41353: NEG
41354: PUSH
41355: LD_INT 4
41357: NEG
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: LD_INT 0
41365: PUSH
41366: LD_INT 4
41368: NEG
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 1
41376: PUSH
41377: LD_INT 3
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 1
41387: NEG
41388: PUSH
41389: LD_INT 5
41391: NEG
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 0
41399: PUSH
41400: LD_INT 5
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 1
41410: PUSH
41411: LD_INT 4
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 6
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: LD_INT 0
41433: PUSH
41434: LD_INT 6
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 1
41444: PUSH
41445: LD_INT 5
41447: NEG
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: EMPTY
41454: LIST
41455: LIST
41456: LIST
41457: LIST
41458: LIST
41459: LIST
41460: LIST
41461: LIST
41462: LIST
41463: LIST
41464: LIST
41465: LIST
41466: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41467: LD_ADDR_VAR 0 30
41471: PUSH
41472: LD_INT 2
41474: PUSH
41475: LD_INT 1
41477: NEG
41478: PUSH
41479: EMPTY
41480: LIST
41481: LIST
41482: PUSH
41483: LD_INT 3
41485: PUSH
41486: LD_INT 0
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 3
41495: PUSH
41496: LD_INT 1
41498: PUSH
41499: EMPTY
41500: LIST
41501: LIST
41502: PUSH
41503: LD_INT 3
41505: PUSH
41506: LD_INT 1
41508: NEG
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 4
41516: PUSH
41517: LD_INT 0
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 4
41526: PUSH
41527: LD_INT 1
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 4
41536: PUSH
41537: LD_INT 1
41539: NEG
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 5
41547: PUSH
41548: LD_INT 0
41550: PUSH
41551: EMPTY
41552: LIST
41553: LIST
41554: PUSH
41555: LD_INT 5
41557: PUSH
41558: LD_INT 1
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: PUSH
41565: LD_INT 5
41567: PUSH
41568: LD_INT 1
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 6
41578: PUSH
41579: LD_INT 0
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 6
41588: PUSH
41589: LD_INT 1
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: LIST
41601: LIST
41602: LIST
41603: LIST
41604: LIST
41605: LIST
41606: LIST
41607: LIST
41608: LIST
41609: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41610: LD_ADDR_VAR 0 31
41614: PUSH
41615: LD_INT 3
41617: PUSH
41618: LD_INT 2
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 3
41627: PUSH
41628: LD_INT 3
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 2
41637: PUSH
41638: LD_INT 3
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 4
41647: PUSH
41648: LD_INT 3
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 4
41657: PUSH
41658: LD_INT 4
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 3
41667: PUSH
41668: LD_INT 4
41670: PUSH
41671: EMPTY
41672: LIST
41673: LIST
41674: PUSH
41675: LD_INT 5
41677: PUSH
41678: LD_INT 4
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: PUSH
41685: LD_INT 5
41687: PUSH
41688: LD_INT 5
41690: PUSH
41691: EMPTY
41692: LIST
41693: LIST
41694: PUSH
41695: LD_INT 4
41697: PUSH
41698: LD_INT 5
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 6
41707: PUSH
41708: LD_INT 5
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 6
41717: PUSH
41718: LD_INT 6
41720: PUSH
41721: EMPTY
41722: LIST
41723: LIST
41724: PUSH
41725: LD_INT 5
41727: PUSH
41728: LD_INT 6
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: LIST
41741: LIST
41742: LIST
41743: LIST
41744: LIST
41745: LIST
41746: LIST
41747: LIST
41748: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41749: LD_ADDR_VAR 0 32
41753: PUSH
41754: LD_INT 1
41756: PUSH
41757: LD_INT 3
41759: PUSH
41760: EMPTY
41761: LIST
41762: LIST
41763: PUSH
41764: LD_INT 0
41766: PUSH
41767: LD_INT 3
41769: PUSH
41770: EMPTY
41771: LIST
41772: LIST
41773: PUSH
41774: LD_INT 1
41776: NEG
41777: PUSH
41778: LD_INT 2
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 1
41787: PUSH
41788: LD_INT 4
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: PUSH
41795: LD_INT 0
41797: PUSH
41798: LD_INT 4
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 1
41807: NEG
41808: PUSH
41809: LD_INT 3
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: PUSH
41819: LD_INT 5
41821: PUSH
41822: EMPTY
41823: LIST
41824: LIST
41825: PUSH
41826: LD_INT 0
41828: PUSH
41829: LD_INT 5
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: PUSH
41836: LD_INT 1
41838: NEG
41839: PUSH
41840: LD_INT 4
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 1
41849: PUSH
41850: LD_INT 6
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 0
41859: PUSH
41860: LD_INT 6
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: PUSH
41867: LD_INT 1
41869: NEG
41870: PUSH
41871: LD_INT 5
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: LIST
41882: LIST
41883: LIST
41884: LIST
41885: LIST
41886: LIST
41887: LIST
41888: LIST
41889: LIST
41890: LIST
41891: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41892: LD_ADDR_VAR 0 33
41896: PUSH
41897: LD_INT 2
41899: NEG
41900: PUSH
41901: LD_INT 1
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 3
41910: NEG
41911: PUSH
41912: LD_INT 0
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 3
41921: NEG
41922: PUSH
41923: LD_INT 1
41925: NEG
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 3
41933: NEG
41934: PUSH
41935: LD_INT 1
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 4
41944: NEG
41945: PUSH
41946: LD_INT 0
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 4
41955: NEG
41956: PUSH
41957: LD_INT 1
41959: NEG
41960: PUSH
41961: EMPTY
41962: LIST
41963: LIST
41964: PUSH
41965: LD_INT 4
41967: NEG
41968: PUSH
41969: LD_INT 1
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 5
41978: NEG
41979: PUSH
41980: LD_INT 0
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 5
41989: NEG
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: NEG
42002: PUSH
42003: LD_INT 1
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 6
42012: NEG
42013: PUSH
42014: LD_INT 0
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 6
42023: NEG
42024: PUSH
42025: LD_INT 1
42027: NEG
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: EMPTY
42034: LIST
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: LIST
42041: LIST
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42047: LD_ADDR_VAR 0 34
42051: PUSH
42052: LD_INT 2
42054: NEG
42055: PUSH
42056: LD_INT 3
42058: NEG
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: NEG
42067: PUSH
42068: LD_INT 2
42070: NEG
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: LD_INT 3
42078: NEG
42079: PUSH
42080: LD_INT 3
42082: NEG
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 3
42090: NEG
42091: PUSH
42092: LD_INT 4
42094: NEG
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 4
42102: NEG
42103: PUSH
42104: LD_INT 3
42106: NEG
42107: PUSH
42108: EMPTY
42109: LIST
42110: LIST
42111: PUSH
42112: LD_INT 4
42114: NEG
42115: PUSH
42116: LD_INT 4
42118: NEG
42119: PUSH
42120: EMPTY
42121: LIST
42122: LIST
42123: PUSH
42124: LD_INT 4
42126: NEG
42127: PUSH
42128: LD_INT 5
42130: NEG
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 5
42138: NEG
42139: PUSH
42140: LD_INT 4
42142: NEG
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 5
42150: NEG
42151: PUSH
42152: LD_INT 5
42154: NEG
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 5
42162: NEG
42163: PUSH
42164: LD_INT 6
42166: NEG
42167: PUSH
42168: EMPTY
42169: LIST
42170: LIST
42171: PUSH
42172: LD_INT 6
42174: NEG
42175: PUSH
42176: LD_INT 5
42178: NEG
42179: PUSH
42180: EMPTY
42181: LIST
42182: LIST
42183: PUSH
42184: LD_INT 6
42186: NEG
42187: PUSH
42188: LD_INT 6
42190: NEG
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: LIST
42203: LIST
42204: LIST
42205: LIST
42206: LIST
42207: LIST
42208: LIST
42209: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42210: LD_ADDR_VAR 0 41
42214: PUSH
42215: LD_INT 0
42217: PUSH
42218: LD_INT 2
42220: NEG
42221: PUSH
42222: EMPTY
42223: LIST
42224: LIST
42225: PUSH
42226: LD_INT 1
42228: NEG
42229: PUSH
42230: LD_INT 3
42232: NEG
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: LD_INT 1
42240: PUSH
42241: LD_INT 2
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: LIST
42253: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42254: LD_ADDR_VAR 0 42
42258: PUSH
42259: LD_INT 2
42261: PUSH
42262: LD_INT 0
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: PUSH
42272: LD_INT 1
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 3
42282: PUSH
42283: LD_INT 1
42285: PUSH
42286: EMPTY
42287: LIST
42288: LIST
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: LIST
42294: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42295: LD_ADDR_VAR 0 43
42299: PUSH
42300: LD_INT 2
42302: PUSH
42303: LD_INT 2
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 3
42312: PUSH
42313: LD_INT 2
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PUSH
42320: LD_INT 2
42322: PUSH
42323: LD_INT 3
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: LIST
42334: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42335: LD_ADDR_VAR 0 44
42339: PUSH
42340: LD_INT 0
42342: PUSH
42343: LD_INT 2
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: LD_INT 3
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 1
42362: NEG
42363: PUSH
42364: LD_INT 2
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: LIST
42375: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42376: LD_ADDR_VAR 0 45
42380: PUSH
42381: LD_INT 2
42383: NEG
42384: PUSH
42385: LD_INT 0
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 2
42394: NEG
42395: PUSH
42396: LD_INT 1
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 3
42405: NEG
42406: PUSH
42407: LD_INT 1
42409: NEG
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: LIST
42419: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42420: LD_ADDR_VAR 0 46
42424: PUSH
42425: LD_INT 2
42427: NEG
42428: PUSH
42429: LD_INT 2
42431: NEG
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 2
42439: NEG
42440: PUSH
42441: LD_INT 3
42443: NEG
42444: PUSH
42445: EMPTY
42446: LIST
42447: LIST
42448: PUSH
42449: LD_INT 3
42451: NEG
42452: PUSH
42453: LD_INT 2
42455: NEG
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: LIST
42465: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42466: LD_ADDR_VAR 0 47
42470: PUSH
42471: LD_INT 2
42473: NEG
42474: PUSH
42475: LD_INT 3
42477: NEG
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 1
42485: NEG
42486: PUSH
42487: LD_INT 3
42489: NEG
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42499: LD_ADDR_VAR 0 48
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: LD_INT 2
42509: NEG
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 2
42517: PUSH
42518: LD_INT 1
42520: NEG
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: EMPTY
42527: LIST
42528: LIST
42529: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42530: LD_ADDR_VAR 0 49
42534: PUSH
42535: LD_INT 3
42537: PUSH
42538: LD_INT 1
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 3
42547: PUSH
42548: LD_INT 2
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42559: LD_ADDR_VAR 0 50
42563: PUSH
42564: LD_INT 2
42566: PUSH
42567: LD_INT 3
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 1
42576: PUSH
42577: LD_INT 3
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42588: LD_ADDR_VAR 0 51
42592: PUSH
42593: LD_INT 1
42595: NEG
42596: PUSH
42597: LD_INT 2
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 2
42606: NEG
42607: PUSH
42608: LD_INT 1
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: EMPTY
42616: LIST
42617: LIST
42618: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42619: LD_ADDR_VAR 0 52
42623: PUSH
42624: LD_INT 3
42626: NEG
42627: PUSH
42628: LD_INT 1
42630: NEG
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: LD_INT 2
42642: NEG
42643: PUSH
42644: EMPTY
42645: LIST
42646: LIST
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42652: LD_ADDR_VAR 0 53
42656: PUSH
42657: LD_INT 1
42659: NEG
42660: PUSH
42661: LD_INT 3
42663: NEG
42664: PUSH
42665: EMPTY
42666: LIST
42667: LIST
42668: PUSH
42669: LD_INT 0
42671: PUSH
42672: LD_INT 3
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 1
42682: PUSH
42683: LD_INT 2
42685: NEG
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: LIST
42695: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42696: LD_ADDR_VAR 0 54
42700: PUSH
42701: LD_INT 2
42703: PUSH
42704: LD_INT 1
42706: NEG
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 3
42714: PUSH
42715: LD_INT 0
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 3
42724: PUSH
42725: LD_INT 1
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: LIST
42736: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42737: LD_ADDR_VAR 0 55
42741: PUSH
42742: LD_INT 3
42744: PUSH
42745: LD_INT 2
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: PUSH
42755: LD_INT 3
42757: PUSH
42758: EMPTY
42759: LIST
42760: LIST
42761: PUSH
42762: LD_INT 2
42764: PUSH
42765: LD_INT 3
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: LIST
42776: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42777: LD_ADDR_VAR 0 56
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: LD_INT 3
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 0
42794: PUSH
42795: LD_INT 3
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: LD_INT 1
42804: NEG
42805: PUSH
42806: LD_INT 2
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: LIST
42817: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42818: LD_ADDR_VAR 0 57
42822: PUSH
42823: LD_INT 2
42825: NEG
42826: PUSH
42827: LD_INT 1
42829: PUSH
42830: EMPTY
42831: LIST
42832: LIST
42833: PUSH
42834: LD_INT 3
42836: NEG
42837: PUSH
42838: LD_INT 0
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 3
42847: NEG
42848: PUSH
42849: LD_INT 1
42851: NEG
42852: PUSH
42853: EMPTY
42854: LIST
42855: LIST
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: LIST
42861: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42862: LD_ADDR_VAR 0 58
42866: PUSH
42867: LD_INT 2
42869: NEG
42870: PUSH
42871: LD_INT 3
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 3
42881: NEG
42882: PUSH
42883: LD_INT 2
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 3
42893: NEG
42894: PUSH
42895: LD_INT 3
42897: NEG
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: LIST
42907: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42908: LD_ADDR_VAR 0 59
42912: PUSH
42913: LD_INT 1
42915: NEG
42916: PUSH
42917: LD_INT 2
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 0
42927: PUSH
42928: LD_INT 2
42930: NEG
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 1
42938: PUSH
42939: LD_INT 1
42941: NEG
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: LIST
42951: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42952: LD_ADDR_VAR 0 60
42956: PUSH
42957: LD_INT 1
42959: PUSH
42960: LD_INT 1
42962: NEG
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 2
42970: PUSH
42971: LD_INT 0
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 2
42980: PUSH
42981: LD_INT 1
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: LIST
42992: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42993: LD_ADDR_VAR 0 61
42997: PUSH
42998: LD_INT 2
43000: PUSH
43001: LD_INT 1
43003: PUSH
43004: EMPTY
43005: LIST
43006: LIST
43007: PUSH
43008: LD_INT 2
43010: PUSH
43011: LD_INT 2
43013: PUSH
43014: EMPTY
43015: LIST
43016: LIST
43017: PUSH
43018: LD_INT 1
43020: PUSH
43021: LD_INT 2
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: LIST
43032: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43033: LD_ADDR_VAR 0 62
43037: PUSH
43038: LD_INT 1
43040: PUSH
43041: LD_INT 2
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 0
43050: PUSH
43051: LD_INT 2
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 1
43060: NEG
43061: PUSH
43062: LD_INT 1
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: LIST
43073: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43074: LD_ADDR_VAR 0 63
43078: PUSH
43079: LD_INT 1
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: PUSH
43086: EMPTY
43087: LIST
43088: LIST
43089: PUSH
43090: LD_INT 2
43092: NEG
43093: PUSH
43094: LD_INT 0
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 2
43103: NEG
43104: PUSH
43105: LD_INT 1
43107: NEG
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: LIST
43117: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43118: LD_ADDR_VAR 0 64
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: LD_INT 2
43129: NEG
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: PUSH
43135: LD_INT 2
43137: NEG
43138: PUSH
43139: LD_INT 1
43141: NEG
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 2
43149: NEG
43150: PUSH
43151: LD_INT 2
43153: NEG
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: EMPTY
43160: LIST
43161: LIST
43162: LIST
43163: ST_TO_ADDR
// end ; 2 :
43164: GO 46430
43166: LD_INT 2
43168: DOUBLE
43169: EQUAL
43170: IFTRUE 43174
43172: GO 46429
43174: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43175: LD_ADDR_VAR 0 29
43179: PUSH
43180: LD_INT 4
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 4
43192: PUSH
43193: LD_INT 1
43195: NEG
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 5
43203: PUSH
43204: LD_INT 0
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 5
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 4
43223: PUSH
43224: LD_INT 1
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 3
43233: PUSH
43234: LD_INT 0
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 3
43243: PUSH
43244: LD_INT 1
43246: NEG
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 3
43254: PUSH
43255: LD_INT 2
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 5
43265: PUSH
43266: LD_INT 2
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 3
43275: PUSH
43276: LD_INT 3
43278: PUSH
43279: EMPTY
43280: LIST
43281: LIST
43282: PUSH
43283: LD_INT 3
43285: PUSH
43286: LD_INT 2
43288: PUSH
43289: EMPTY
43290: LIST
43291: LIST
43292: PUSH
43293: LD_INT 4
43295: PUSH
43296: LD_INT 3
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 4
43305: PUSH
43306: LD_INT 4
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 3
43315: PUSH
43316: LD_INT 4
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 2
43325: PUSH
43326: LD_INT 3
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 2
43335: PUSH
43336: LD_INT 2
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 4
43345: PUSH
43346: LD_INT 2
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 2
43355: PUSH
43356: LD_INT 4
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 0
43365: PUSH
43366: LD_INT 4
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: PUSH
43373: LD_INT 0
43375: PUSH
43376: LD_INT 3
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 1
43385: PUSH
43386: LD_INT 4
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 1
43395: PUSH
43396: LD_INT 5
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 0
43405: PUSH
43406: LD_INT 5
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: LD_INT 1
43415: NEG
43416: PUSH
43417: LD_INT 4
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: LD_INT 3
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 2
43437: PUSH
43438: LD_INT 5
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 2
43447: NEG
43448: PUSH
43449: LD_INT 3
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 3
43458: NEG
43459: PUSH
43460: LD_INT 0
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 3
43469: NEG
43470: PUSH
43471: LD_INT 1
43473: NEG
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: NEG
43482: PUSH
43483: LD_INT 0
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 2
43492: NEG
43493: PUSH
43494: LD_INT 1
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: NEG
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 4
43514: NEG
43515: PUSH
43516: LD_INT 0
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 4
43525: NEG
43526: PUSH
43527: LD_INT 1
43529: NEG
43530: PUSH
43531: EMPTY
43532: LIST
43533: LIST
43534: PUSH
43535: LD_INT 4
43537: NEG
43538: PUSH
43539: LD_INT 2
43541: NEG
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 2
43549: NEG
43550: PUSH
43551: LD_INT 2
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 4
43560: NEG
43561: PUSH
43562: LD_INT 4
43564: NEG
43565: PUSH
43566: EMPTY
43567: LIST
43568: LIST
43569: PUSH
43570: LD_INT 4
43572: NEG
43573: PUSH
43574: LD_INT 5
43576: NEG
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 3
43584: NEG
43585: PUSH
43586: LD_INT 4
43588: NEG
43589: PUSH
43590: EMPTY
43591: LIST
43592: LIST
43593: PUSH
43594: LD_INT 3
43596: NEG
43597: PUSH
43598: LD_INT 3
43600: NEG
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 4
43608: NEG
43609: PUSH
43610: LD_INT 3
43612: NEG
43613: PUSH
43614: EMPTY
43615: LIST
43616: LIST
43617: PUSH
43618: LD_INT 5
43620: NEG
43621: PUSH
43622: LD_INT 4
43624: NEG
43625: PUSH
43626: EMPTY
43627: LIST
43628: LIST
43629: PUSH
43630: LD_INT 5
43632: NEG
43633: PUSH
43634: LD_INT 5
43636: NEG
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 3
43644: NEG
43645: PUSH
43646: LD_INT 5
43648: NEG
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 5
43656: NEG
43657: PUSH
43658: LD_INT 3
43660: NEG
43661: PUSH
43662: EMPTY
43663: LIST
43664: LIST
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: LIST
43674: LIST
43675: LIST
43676: LIST
43677: LIST
43678: LIST
43679: LIST
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43713: LD_ADDR_VAR 0 30
43717: PUSH
43718: LD_INT 4
43720: PUSH
43721: LD_INT 4
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: PUSH
43728: LD_INT 4
43730: PUSH
43731: LD_INT 3
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 5
43740: PUSH
43741: LD_INT 4
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 5
43750: PUSH
43751: LD_INT 5
43753: PUSH
43754: EMPTY
43755: LIST
43756: LIST
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: LD_INT 5
43763: PUSH
43764: EMPTY
43765: LIST
43766: LIST
43767: PUSH
43768: LD_INT 3
43770: PUSH
43771: LD_INT 4
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 3
43780: PUSH
43781: LD_INT 3
43783: PUSH
43784: EMPTY
43785: LIST
43786: LIST
43787: PUSH
43788: LD_INT 5
43790: PUSH
43791: LD_INT 3
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: PUSH
43801: LD_INT 5
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 0
43810: PUSH
43811: LD_INT 3
43813: PUSH
43814: EMPTY
43815: LIST
43816: LIST
43817: PUSH
43818: LD_INT 0
43820: PUSH
43821: LD_INT 2
43823: PUSH
43824: EMPTY
43825: LIST
43826: LIST
43827: PUSH
43828: LD_INT 1
43830: PUSH
43831: LD_INT 3
43833: PUSH
43834: EMPTY
43835: LIST
43836: LIST
43837: PUSH
43838: LD_INT 1
43840: PUSH
43841: LD_INT 4
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: LD_INT 0
43850: PUSH
43851: LD_INT 4
43853: PUSH
43854: EMPTY
43855: LIST
43856: LIST
43857: PUSH
43858: LD_INT 1
43860: NEG
43861: PUSH
43862: LD_INT 3
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 1
43871: NEG
43872: PUSH
43873: LD_INT 2
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 2
43882: PUSH
43883: LD_INT 4
43885: PUSH
43886: EMPTY
43887: LIST
43888: LIST
43889: PUSH
43890: LD_INT 2
43892: NEG
43893: PUSH
43894: LD_INT 2
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 4
43903: NEG
43904: PUSH
43905: LD_INT 0
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 4
43914: NEG
43915: PUSH
43916: LD_INT 1
43918: NEG
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 3
43926: NEG
43927: PUSH
43928: LD_INT 0
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: NEG
43938: PUSH
43939: LD_INT 1
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 4
43948: NEG
43949: PUSH
43950: LD_INT 1
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 5
43959: NEG
43960: PUSH
43961: LD_INT 0
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 5
43970: NEG
43971: PUSH
43972: LD_INT 1
43974: NEG
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: NEG
43983: PUSH
43984: LD_INT 2
43986: NEG
43987: PUSH
43988: EMPTY
43989: LIST
43990: LIST
43991: PUSH
43992: LD_INT 3
43994: NEG
43995: PUSH
43996: LD_INT 2
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: LD_INT 3
44009: NEG
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 3
44017: NEG
44018: PUSH
44019: LD_INT 4
44021: NEG
44022: PUSH
44023: EMPTY
44024: LIST
44025: LIST
44026: PUSH
44027: LD_INT 2
44029: NEG
44030: PUSH
44031: LD_INT 3
44033: NEG
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 2
44041: NEG
44042: PUSH
44043: LD_INT 2
44045: NEG
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 3
44053: NEG
44054: PUSH
44055: LD_INT 2
44057: NEG
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PUSH
44063: LD_INT 4
44065: NEG
44066: PUSH
44067: LD_INT 3
44069: NEG
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: LD_INT 4
44077: NEG
44078: PUSH
44079: LD_INT 4
44081: NEG
44082: PUSH
44083: EMPTY
44084: LIST
44085: LIST
44086: PUSH
44087: LD_INT 2
44089: NEG
44090: PUSH
44091: LD_INT 4
44093: NEG
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 4
44101: NEG
44102: PUSH
44103: LD_INT 2
44105: NEG
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PUSH
44111: LD_INT 0
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: LD_INT 5
44127: NEG
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 1
44135: PUSH
44136: LD_INT 4
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 1
44146: PUSH
44147: LD_INT 3
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 0
44157: PUSH
44158: LD_INT 3
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 1
44168: NEG
44169: PUSH
44170: LD_INT 4
44172: NEG
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 1
44180: NEG
44181: PUSH
44182: LD_INT 5
44184: NEG
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 2
44192: PUSH
44193: LD_INT 3
44195: NEG
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 2
44203: NEG
44204: PUSH
44205: LD_INT 5
44207: NEG
44208: PUSH
44209: EMPTY
44210: LIST
44211: LIST
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: LIST
44217: LIST
44218: LIST
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: LIST
44224: LIST
44225: LIST
44226: LIST
44227: LIST
44228: LIST
44229: LIST
44230: LIST
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44260: LD_ADDR_VAR 0 31
44264: PUSH
44265: LD_INT 0
44267: PUSH
44268: LD_INT 4
44270: PUSH
44271: EMPTY
44272: LIST
44273: LIST
44274: PUSH
44275: LD_INT 0
44277: PUSH
44278: LD_INT 3
44280: PUSH
44281: EMPTY
44282: LIST
44283: LIST
44284: PUSH
44285: LD_INT 1
44287: PUSH
44288: LD_INT 4
44290: PUSH
44291: EMPTY
44292: LIST
44293: LIST
44294: PUSH
44295: LD_INT 1
44297: PUSH
44298: LD_INT 5
44300: PUSH
44301: EMPTY
44302: LIST
44303: LIST
44304: PUSH
44305: LD_INT 0
44307: PUSH
44308: LD_INT 5
44310: PUSH
44311: EMPTY
44312: LIST
44313: LIST
44314: PUSH
44315: LD_INT 1
44317: NEG
44318: PUSH
44319: LD_INT 4
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 1
44328: NEG
44329: PUSH
44330: LD_INT 3
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 2
44339: PUSH
44340: LD_INT 5
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 2
44349: NEG
44350: PUSH
44351: LD_INT 3
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 3
44360: NEG
44361: PUSH
44362: LD_INT 0
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 3
44371: NEG
44372: PUSH
44373: LD_INT 1
44375: NEG
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: PUSH
44381: LD_INT 2
44383: NEG
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 1
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 3
44405: NEG
44406: PUSH
44407: LD_INT 1
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 4
44416: NEG
44417: PUSH
44418: LD_INT 0
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: NEG
44428: PUSH
44429: LD_INT 1
44431: NEG
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 4
44439: NEG
44440: PUSH
44441: LD_INT 2
44443: NEG
44444: PUSH
44445: EMPTY
44446: LIST
44447: LIST
44448: PUSH
44449: LD_INT 2
44451: NEG
44452: PUSH
44453: LD_INT 2
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 4
44462: NEG
44463: PUSH
44464: LD_INT 4
44466: NEG
44467: PUSH
44468: EMPTY
44469: LIST
44470: LIST
44471: PUSH
44472: LD_INT 4
44474: NEG
44475: PUSH
44476: LD_INT 5
44478: NEG
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 3
44486: NEG
44487: PUSH
44488: LD_INT 4
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 3
44498: NEG
44499: PUSH
44500: LD_INT 3
44502: NEG
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 4
44510: NEG
44511: PUSH
44512: LD_INT 3
44514: NEG
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 5
44522: NEG
44523: PUSH
44524: LD_INT 4
44526: NEG
44527: PUSH
44528: EMPTY
44529: LIST
44530: LIST
44531: PUSH
44532: LD_INT 5
44534: NEG
44535: PUSH
44536: LD_INT 5
44538: NEG
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: PUSH
44544: LD_INT 3
44546: NEG
44547: PUSH
44548: LD_INT 5
44550: NEG
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 5
44558: NEG
44559: PUSH
44560: LD_INT 3
44562: NEG
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 0
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: LD_INT 4
44584: NEG
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 1
44592: PUSH
44593: LD_INT 3
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 1
44603: PUSH
44604: LD_INT 2
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 0
44614: PUSH
44615: LD_INT 2
44617: NEG
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 1
44625: NEG
44626: PUSH
44627: LD_INT 3
44629: NEG
44630: PUSH
44631: EMPTY
44632: LIST
44633: LIST
44634: PUSH
44635: LD_INT 1
44637: NEG
44638: PUSH
44639: LD_INT 4
44641: NEG
44642: PUSH
44643: EMPTY
44644: LIST
44645: LIST
44646: PUSH
44647: LD_INT 2
44649: PUSH
44650: LD_INT 2
44652: NEG
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 2
44660: NEG
44661: PUSH
44662: LD_INT 4
44664: NEG
44665: PUSH
44666: EMPTY
44667: LIST
44668: LIST
44669: PUSH
44670: LD_INT 4
44672: PUSH
44673: LD_INT 0
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: LD_INT 4
44682: PUSH
44683: LD_INT 1
44685: NEG
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 5
44693: PUSH
44694: LD_INT 0
44696: PUSH
44697: EMPTY
44698: LIST
44699: LIST
44700: PUSH
44701: LD_INT 5
44703: PUSH
44704: LD_INT 1
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 4
44713: PUSH
44714: LD_INT 1
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 3
44723: PUSH
44724: LD_INT 0
44726: PUSH
44727: EMPTY
44728: LIST
44729: LIST
44730: PUSH
44731: LD_INT 3
44733: PUSH
44734: LD_INT 1
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 2
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 5
44755: PUSH
44756: LD_INT 2
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: LIST
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44810: LD_ADDR_VAR 0 32
44814: PUSH
44815: LD_INT 4
44817: NEG
44818: PUSH
44819: LD_INT 0
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 4
44828: NEG
44829: PUSH
44830: LD_INT 1
44832: NEG
44833: PUSH
44834: EMPTY
44835: LIST
44836: LIST
44837: PUSH
44838: LD_INT 3
44840: NEG
44841: PUSH
44842: LD_INT 0
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 3
44851: NEG
44852: PUSH
44853: LD_INT 1
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 5
44873: NEG
44874: PUSH
44875: LD_INT 0
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 5
44884: NEG
44885: PUSH
44886: LD_INT 1
44888: NEG
44889: PUSH
44890: EMPTY
44891: LIST
44892: LIST
44893: PUSH
44894: LD_INT 5
44896: NEG
44897: PUSH
44898: LD_INT 2
44900: NEG
44901: PUSH
44902: EMPTY
44903: LIST
44904: LIST
44905: PUSH
44906: LD_INT 3
44908: NEG
44909: PUSH
44910: LD_INT 2
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 3
44919: NEG
44920: PUSH
44921: LD_INT 3
44923: NEG
44924: PUSH
44925: EMPTY
44926: LIST
44927: LIST
44928: PUSH
44929: LD_INT 3
44931: NEG
44932: PUSH
44933: LD_INT 4
44935: NEG
44936: PUSH
44937: EMPTY
44938: LIST
44939: LIST
44940: PUSH
44941: LD_INT 2
44943: NEG
44944: PUSH
44945: LD_INT 3
44947: NEG
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 2
44955: NEG
44956: PUSH
44957: LD_INT 2
44959: NEG
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 3
44967: NEG
44968: PUSH
44969: LD_INT 2
44971: NEG
44972: PUSH
44973: EMPTY
44974: LIST
44975: LIST
44976: PUSH
44977: LD_INT 4
44979: NEG
44980: PUSH
44981: LD_INT 3
44983: NEG
44984: PUSH
44985: EMPTY
44986: LIST
44987: LIST
44988: PUSH
44989: LD_INT 4
44991: NEG
44992: PUSH
44993: LD_INT 4
44995: NEG
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: LD_INT 2
45003: NEG
45004: PUSH
45005: LD_INT 4
45007: NEG
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 4
45015: NEG
45016: PUSH
45017: LD_INT 2
45019: NEG
45020: PUSH
45021: EMPTY
45022: LIST
45023: LIST
45024: PUSH
45025: LD_INT 0
45027: PUSH
45028: LD_INT 4
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 0
45038: PUSH
45039: LD_INT 5
45041: NEG
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 1
45049: PUSH
45050: LD_INT 4
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 1
45060: PUSH
45061: LD_INT 3
45063: NEG
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 0
45071: PUSH
45072: LD_INT 3
45074: NEG
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: LD_INT 1
45082: NEG
45083: PUSH
45084: LD_INT 4
45086: NEG
45087: PUSH
45088: EMPTY
45089: LIST
45090: LIST
45091: PUSH
45092: LD_INT 1
45094: NEG
45095: PUSH
45096: LD_INT 5
45098: NEG
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: LD_INT 2
45106: PUSH
45107: LD_INT 3
45109: NEG
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 2
45117: NEG
45118: PUSH
45119: LD_INT 5
45121: NEG
45122: PUSH
45123: EMPTY
45124: LIST
45125: LIST
45126: PUSH
45127: LD_INT 3
45129: PUSH
45130: LD_INT 0
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 3
45139: PUSH
45140: LD_INT 1
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 4
45150: PUSH
45151: LD_INT 0
45153: PUSH
45154: EMPTY
45155: LIST
45156: LIST
45157: PUSH
45158: LD_INT 4
45160: PUSH
45161: LD_INT 1
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 3
45170: PUSH
45171: LD_INT 1
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 2
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PUSH
45188: LD_INT 2
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 2
45201: PUSH
45202: LD_INT 2
45204: NEG
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 4
45212: PUSH
45213: LD_INT 2
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 4
45222: PUSH
45223: LD_INT 4
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PUSH
45230: LD_INT 4
45232: PUSH
45233: LD_INT 3
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: LD_INT 5
45242: PUSH
45243: LD_INT 4
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 5
45252: PUSH
45253: LD_INT 5
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 4
45262: PUSH
45263: LD_INT 5
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: LD_INT 3
45272: PUSH
45273: LD_INT 4
45275: PUSH
45276: EMPTY
45277: LIST
45278: LIST
45279: PUSH
45280: LD_INT 3
45282: PUSH
45283: LD_INT 3
45285: PUSH
45286: EMPTY
45287: LIST
45288: LIST
45289: PUSH
45290: LD_INT 5
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: EMPTY
45297: LIST
45298: LIST
45299: PUSH
45300: LD_INT 3
45302: PUSH
45303: LD_INT 5
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: LIST
45314: LIST
45315: LIST
45316: LIST
45317: LIST
45318: LIST
45319: LIST
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45357: LD_ADDR_VAR 0 33
45361: PUSH
45362: LD_INT 4
45364: NEG
45365: PUSH
45366: LD_INT 4
45368: NEG
45369: PUSH
45370: EMPTY
45371: LIST
45372: LIST
45373: PUSH
45374: LD_INT 4
45376: NEG
45377: PUSH
45378: LD_INT 5
45380: NEG
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 3
45388: NEG
45389: PUSH
45390: LD_INT 4
45392: NEG
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: LD_INT 3
45400: NEG
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: PUSH
45410: LD_INT 4
45412: NEG
45413: PUSH
45414: LD_INT 3
45416: NEG
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 5
45424: NEG
45425: PUSH
45426: LD_INT 4
45428: NEG
45429: PUSH
45430: EMPTY
45431: LIST
45432: LIST
45433: PUSH
45434: LD_INT 5
45436: NEG
45437: PUSH
45438: LD_INT 5
45440: NEG
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 3
45448: NEG
45449: PUSH
45450: LD_INT 5
45452: NEG
45453: PUSH
45454: EMPTY
45455: LIST
45456: LIST
45457: PUSH
45458: LD_INT 5
45460: NEG
45461: PUSH
45462: LD_INT 3
45464: NEG
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PUSH
45470: LD_INT 0
45472: PUSH
45473: LD_INT 3
45475: NEG
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 4
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 1
45494: PUSH
45495: LD_INT 3
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 2
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 0
45516: PUSH
45517: LD_INT 2
45519: NEG
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 1
45527: NEG
45528: PUSH
45529: LD_INT 3
45531: NEG
45532: PUSH
45533: EMPTY
45534: LIST
45535: LIST
45536: PUSH
45537: LD_INT 1
45539: NEG
45540: PUSH
45541: LD_INT 4
45543: NEG
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: LD_INT 2
45554: NEG
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 2
45562: NEG
45563: PUSH
45564: LD_INT 4
45566: NEG
45567: PUSH
45568: EMPTY
45569: LIST
45570: LIST
45571: PUSH
45572: LD_INT 4
45574: PUSH
45575: LD_INT 0
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: LD_INT 4
45584: PUSH
45585: LD_INT 1
45587: NEG
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 5
45595: PUSH
45596: LD_INT 0
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: LD_INT 5
45605: PUSH
45606: LD_INT 1
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 4
45615: PUSH
45616: LD_INT 1
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 3
45625: PUSH
45626: LD_INT 0
45628: PUSH
45629: EMPTY
45630: LIST
45631: LIST
45632: PUSH
45633: LD_INT 3
45635: PUSH
45636: LD_INT 1
45638: NEG
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: PUSH
45644: LD_INT 3
45646: PUSH
45647: LD_INT 2
45649: NEG
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: LD_INT 5
45657: PUSH
45658: LD_INT 2
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 3
45667: PUSH
45668: LD_INT 3
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: PUSH
45675: LD_INT 3
45677: PUSH
45678: LD_INT 2
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 4
45687: PUSH
45688: LD_INT 3
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: LD_INT 4
45697: PUSH
45698: LD_INT 4
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 3
45707: PUSH
45708: LD_INT 4
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 2
45717: PUSH
45718: LD_INT 3
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 2
45727: PUSH
45728: LD_INT 2
45730: PUSH
45731: EMPTY
45732: LIST
45733: LIST
45734: PUSH
45735: LD_INT 4
45737: PUSH
45738: LD_INT 2
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 2
45747: PUSH
45748: LD_INT 4
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 0
45757: PUSH
45758: LD_INT 4
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 0
45767: PUSH
45768: LD_INT 3
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 1
45777: PUSH
45778: LD_INT 4
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 1
45787: PUSH
45788: LD_INT 5
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: LD_INT 0
45797: PUSH
45798: LD_INT 5
45800: PUSH
45801: EMPTY
45802: LIST
45803: LIST
45804: PUSH
45805: LD_INT 1
45807: NEG
45808: PUSH
45809: LD_INT 4
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: LD_INT 3
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 2
45829: PUSH
45830: LD_INT 5
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_INT 2
45839: NEG
45840: PUSH
45841: LD_INT 3
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: LIST
45852: LIST
45853: LIST
45854: LIST
45855: LIST
45856: LIST
45857: LIST
45858: LIST
45859: LIST
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45895: LD_ADDR_VAR 0 34
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: LD_INT 4
45905: NEG
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 5
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 1
45924: PUSH
45925: LD_INT 4
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 1
45935: PUSH
45936: LD_INT 3
45938: NEG
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: LD_INT 3
45949: NEG
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 1
45957: NEG
45958: PUSH
45959: LD_INT 4
45961: NEG
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: PUSH
45967: LD_INT 1
45969: NEG
45970: PUSH
45971: LD_INT 5
45973: NEG
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 2
45981: PUSH
45982: LD_INT 3
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 2
45992: NEG
45993: PUSH
45994: LD_INT 5
45996: NEG
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: LD_INT 3
46004: PUSH
46005: LD_INT 0
46007: PUSH
46008: EMPTY
46009: LIST
46010: LIST
46011: PUSH
46012: LD_INT 3
46014: PUSH
46015: LD_INT 1
46017: NEG
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 4
46025: PUSH
46026: LD_INT 0
46028: PUSH
46029: EMPTY
46030: LIST
46031: LIST
46032: PUSH
46033: LD_INT 4
46035: PUSH
46036: LD_INT 1
46038: PUSH
46039: EMPTY
46040: LIST
46041: LIST
46042: PUSH
46043: LD_INT 3
46045: PUSH
46046: LD_INT 1
46048: PUSH
46049: EMPTY
46050: LIST
46051: LIST
46052: PUSH
46053: LD_INT 2
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: LD_INT 2
46065: PUSH
46066: LD_INT 1
46068: NEG
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 2
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 4
46087: PUSH
46088: LD_INT 2
46090: PUSH
46091: EMPTY
46092: LIST
46093: LIST
46094: PUSH
46095: LD_INT 4
46097: PUSH
46098: LD_INT 4
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 4
46107: PUSH
46108: LD_INT 3
46110: PUSH
46111: EMPTY
46112: LIST
46113: LIST
46114: PUSH
46115: LD_INT 5
46117: PUSH
46118: LD_INT 4
46120: PUSH
46121: EMPTY
46122: LIST
46123: LIST
46124: PUSH
46125: LD_INT 5
46127: PUSH
46128: LD_INT 5
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 4
46137: PUSH
46138: LD_INT 5
46140: PUSH
46141: EMPTY
46142: LIST
46143: LIST
46144: PUSH
46145: LD_INT 3
46147: PUSH
46148: LD_INT 4
46150: PUSH
46151: EMPTY
46152: LIST
46153: LIST
46154: PUSH
46155: LD_INT 3
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 5
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 3
46177: PUSH
46178: LD_INT 5
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 0
46187: PUSH
46188: LD_INT 3
46190: PUSH
46191: EMPTY
46192: LIST
46193: LIST
46194: PUSH
46195: LD_INT 0
46197: PUSH
46198: LD_INT 2
46200: PUSH
46201: EMPTY
46202: LIST
46203: LIST
46204: PUSH
46205: LD_INT 1
46207: PUSH
46208: LD_INT 3
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 1
46217: PUSH
46218: LD_INT 4
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 0
46227: PUSH
46228: LD_INT 4
46230: PUSH
46231: EMPTY
46232: LIST
46233: LIST
46234: PUSH
46235: LD_INT 1
46237: NEG
46238: PUSH
46239: LD_INT 3
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 1
46248: NEG
46249: PUSH
46250: LD_INT 2
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 2
46259: PUSH
46260: LD_INT 4
46262: PUSH
46263: EMPTY
46264: LIST
46265: LIST
46266: PUSH
46267: LD_INT 2
46269: NEG
46270: PUSH
46271: LD_INT 2
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 4
46280: NEG
46281: PUSH
46282: LD_INT 0
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 4
46291: NEG
46292: PUSH
46293: LD_INT 1
46295: NEG
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: NEG
46304: PUSH
46305: LD_INT 0
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: LD_INT 1
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 4
46325: NEG
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 5
46336: NEG
46337: PUSH
46338: LD_INT 0
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 5
46347: NEG
46348: PUSH
46349: LD_INT 1
46351: NEG
46352: PUSH
46353: EMPTY
46354: LIST
46355: LIST
46356: PUSH
46357: LD_INT 5
46359: NEG
46360: PUSH
46361: LD_INT 2
46363: NEG
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: LD_INT 3
46371: NEG
46372: PUSH
46373: LD_INT 2
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: LIST
46384: LIST
46385: LIST
46386: LIST
46387: LIST
46388: LIST
46389: LIST
46390: LIST
46391: LIST
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: ST_TO_ADDR
// end ; end ;
46427: GO 46430
46429: POP
// case btype of b_depot , b_warehouse :
46430: LD_VAR 0 1
46434: PUSH
46435: LD_INT 0
46437: DOUBLE
46438: EQUAL
46439: IFTRUE 46449
46441: LD_INT 1
46443: DOUBLE
46444: EQUAL
46445: IFTRUE 46449
46447: GO 46650
46449: POP
// case nation of nation_american :
46450: LD_VAR 0 5
46454: PUSH
46455: LD_INT 1
46457: DOUBLE
46458: EQUAL
46459: IFTRUE 46463
46461: GO 46519
46463: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46464: LD_ADDR_VAR 0 9
46468: PUSH
46469: LD_VAR 0 11
46473: PUSH
46474: LD_VAR 0 12
46478: PUSH
46479: LD_VAR 0 13
46483: PUSH
46484: LD_VAR 0 14
46488: PUSH
46489: LD_VAR 0 15
46493: PUSH
46494: LD_VAR 0 16
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: LIST
46503: LIST
46504: LIST
46505: LIST
46506: PUSH
46507: LD_VAR 0 4
46511: PUSH
46512: LD_INT 1
46514: PLUS
46515: ARRAY
46516: ST_TO_ADDR
46517: GO 46648
46519: LD_INT 2
46521: DOUBLE
46522: EQUAL
46523: IFTRUE 46527
46525: GO 46583
46527: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46528: LD_ADDR_VAR 0 9
46532: PUSH
46533: LD_VAR 0 17
46537: PUSH
46538: LD_VAR 0 18
46542: PUSH
46543: LD_VAR 0 19
46547: PUSH
46548: LD_VAR 0 20
46552: PUSH
46553: LD_VAR 0 21
46557: PUSH
46558: LD_VAR 0 22
46562: PUSH
46563: EMPTY
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: PUSH
46571: LD_VAR 0 4
46575: PUSH
46576: LD_INT 1
46578: PLUS
46579: ARRAY
46580: ST_TO_ADDR
46581: GO 46648
46583: LD_INT 3
46585: DOUBLE
46586: EQUAL
46587: IFTRUE 46591
46589: GO 46647
46591: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46592: LD_ADDR_VAR 0 9
46596: PUSH
46597: LD_VAR 0 23
46601: PUSH
46602: LD_VAR 0 24
46606: PUSH
46607: LD_VAR 0 25
46611: PUSH
46612: LD_VAR 0 26
46616: PUSH
46617: LD_VAR 0 27
46621: PUSH
46622: LD_VAR 0 28
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: PUSH
46635: LD_VAR 0 4
46639: PUSH
46640: LD_INT 1
46642: PLUS
46643: ARRAY
46644: ST_TO_ADDR
46645: GO 46648
46647: POP
46648: GO 47203
46650: LD_INT 2
46652: DOUBLE
46653: EQUAL
46654: IFTRUE 46664
46656: LD_INT 3
46658: DOUBLE
46659: EQUAL
46660: IFTRUE 46664
46662: GO 46720
46664: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46665: LD_ADDR_VAR 0 9
46669: PUSH
46670: LD_VAR 0 29
46674: PUSH
46675: LD_VAR 0 30
46679: PUSH
46680: LD_VAR 0 31
46684: PUSH
46685: LD_VAR 0 32
46689: PUSH
46690: LD_VAR 0 33
46694: PUSH
46695: LD_VAR 0 34
46699: PUSH
46700: EMPTY
46701: LIST
46702: LIST
46703: LIST
46704: LIST
46705: LIST
46706: LIST
46707: PUSH
46708: LD_VAR 0 4
46712: PUSH
46713: LD_INT 1
46715: PLUS
46716: ARRAY
46717: ST_TO_ADDR
46718: GO 47203
46720: LD_INT 16
46722: DOUBLE
46723: EQUAL
46724: IFTRUE 46782
46726: LD_INT 17
46728: DOUBLE
46729: EQUAL
46730: IFTRUE 46782
46732: LD_INT 18
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46782
46738: LD_INT 19
46740: DOUBLE
46741: EQUAL
46742: IFTRUE 46782
46744: LD_INT 22
46746: DOUBLE
46747: EQUAL
46748: IFTRUE 46782
46750: LD_INT 20
46752: DOUBLE
46753: EQUAL
46754: IFTRUE 46782
46756: LD_INT 21
46758: DOUBLE
46759: EQUAL
46760: IFTRUE 46782
46762: LD_INT 23
46764: DOUBLE
46765: EQUAL
46766: IFTRUE 46782
46768: LD_INT 24
46770: DOUBLE
46771: EQUAL
46772: IFTRUE 46782
46774: LD_INT 25
46776: DOUBLE
46777: EQUAL
46778: IFTRUE 46782
46780: GO 46838
46782: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46783: LD_ADDR_VAR 0 9
46787: PUSH
46788: LD_VAR 0 35
46792: PUSH
46793: LD_VAR 0 36
46797: PUSH
46798: LD_VAR 0 37
46802: PUSH
46803: LD_VAR 0 38
46807: PUSH
46808: LD_VAR 0 39
46812: PUSH
46813: LD_VAR 0 40
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: LIST
46822: LIST
46823: LIST
46824: LIST
46825: PUSH
46826: LD_VAR 0 4
46830: PUSH
46831: LD_INT 1
46833: PLUS
46834: ARRAY
46835: ST_TO_ADDR
46836: GO 47203
46838: LD_INT 6
46840: DOUBLE
46841: EQUAL
46842: IFTRUE 46894
46844: LD_INT 7
46846: DOUBLE
46847: EQUAL
46848: IFTRUE 46894
46850: LD_INT 8
46852: DOUBLE
46853: EQUAL
46854: IFTRUE 46894
46856: LD_INT 13
46858: DOUBLE
46859: EQUAL
46860: IFTRUE 46894
46862: LD_INT 12
46864: DOUBLE
46865: EQUAL
46866: IFTRUE 46894
46868: LD_INT 15
46870: DOUBLE
46871: EQUAL
46872: IFTRUE 46894
46874: LD_INT 11
46876: DOUBLE
46877: EQUAL
46878: IFTRUE 46894
46880: LD_INT 14
46882: DOUBLE
46883: EQUAL
46884: IFTRUE 46894
46886: LD_INT 10
46888: DOUBLE
46889: EQUAL
46890: IFTRUE 46894
46892: GO 46950
46894: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46895: LD_ADDR_VAR 0 9
46899: PUSH
46900: LD_VAR 0 41
46904: PUSH
46905: LD_VAR 0 42
46909: PUSH
46910: LD_VAR 0 43
46914: PUSH
46915: LD_VAR 0 44
46919: PUSH
46920: LD_VAR 0 45
46924: PUSH
46925: LD_VAR 0 46
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: PUSH
46938: LD_VAR 0 4
46942: PUSH
46943: LD_INT 1
46945: PLUS
46946: ARRAY
46947: ST_TO_ADDR
46948: GO 47203
46950: LD_INT 36
46952: DOUBLE
46953: EQUAL
46954: IFTRUE 46958
46956: GO 47014
46958: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46959: LD_ADDR_VAR 0 9
46963: PUSH
46964: LD_VAR 0 47
46968: PUSH
46969: LD_VAR 0 48
46973: PUSH
46974: LD_VAR 0 49
46978: PUSH
46979: LD_VAR 0 50
46983: PUSH
46984: LD_VAR 0 51
46988: PUSH
46989: LD_VAR 0 52
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: LIST
46998: LIST
46999: LIST
47000: LIST
47001: PUSH
47002: LD_VAR 0 4
47006: PUSH
47007: LD_INT 1
47009: PLUS
47010: ARRAY
47011: ST_TO_ADDR
47012: GO 47203
47014: LD_INT 4
47016: DOUBLE
47017: EQUAL
47018: IFTRUE 47040
47020: LD_INT 5
47022: DOUBLE
47023: EQUAL
47024: IFTRUE 47040
47026: LD_INT 34
47028: DOUBLE
47029: EQUAL
47030: IFTRUE 47040
47032: LD_INT 37
47034: DOUBLE
47035: EQUAL
47036: IFTRUE 47040
47038: GO 47096
47040: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47041: LD_ADDR_VAR 0 9
47045: PUSH
47046: LD_VAR 0 53
47050: PUSH
47051: LD_VAR 0 54
47055: PUSH
47056: LD_VAR 0 55
47060: PUSH
47061: LD_VAR 0 56
47065: PUSH
47066: LD_VAR 0 57
47070: PUSH
47071: LD_VAR 0 58
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: PUSH
47084: LD_VAR 0 4
47088: PUSH
47089: LD_INT 1
47091: PLUS
47092: ARRAY
47093: ST_TO_ADDR
47094: GO 47203
47096: LD_INT 31
47098: DOUBLE
47099: EQUAL
47100: IFTRUE 47146
47102: LD_INT 32
47104: DOUBLE
47105: EQUAL
47106: IFTRUE 47146
47108: LD_INT 33
47110: DOUBLE
47111: EQUAL
47112: IFTRUE 47146
47114: LD_INT 27
47116: DOUBLE
47117: EQUAL
47118: IFTRUE 47146
47120: LD_INT 26
47122: DOUBLE
47123: EQUAL
47124: IFTRUE 47146
47126: LD_INT 28
47128: DOUBLE
47129: EQUAL
47130: IFTRUE 47146
47132: LD_INT 29
47134: DOUBLE
47135: EQUAL
47136: IFTRUE 47146
47138: LD_INT 30
47140: DOUBLE
47141: EQUAL
47142: IFTRUE 47146
47144: GO 47202
47146: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47147: LD_ADDR_VAR 0 9
47151: PUSH
47152: LD_VAR 0 59
47156: PUSH
47157: LD_VAR 0 60
47161: PUSH
47162: LD_VAR 0 61
47166: PUSH
47167: LD_VAR 0 62
47171: PUSH
47172: LD_VAR 0 63
47176: PUSH
47177: LD_VAR 0 64
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: PUSH
47190: LD_VAR 0 4
47194: PUSH
47195: LD_INT 1
47197: PLUS
47198: ARRAY
47199: ST_TO_ADDR
47200: GO 47203
47202: POP
// temp_list2 = [ ] ;
47203: LD_ADDR_VAR 0 10
47207: PUSH
47208: EMPTY
47209: ST_TO_ADDR
// for i in temp_list do
47210: LD_ADDR_VAR 0 8
47214: PUSH
47215: LD_VAR 0 9
47219: PUSH
47220: FOR_IN
47221: IFFALSE 47273
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47223: LD_ADDR_VAR 0 10
47227: PUSH
47228: LD_VAR 0 10
47232: PUSH
47233: LD_VAR 0 8
47237: PUSH
47238: LD_INT 1
47240: ARRAY
47241: PUSH
47242: LD_VAR 0 2
47246: PLUS
47247: PUSH
47248: LD_VAR 0 8
47252: PUSH
47253: LD_INT 2
47255: ARRAY
47256: PUSH
47257: LD_VAR 0 3
47261: PLUS
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PUSH
47267: EMPTY
47268: LIST
47269: ADD
47270: ST_TO_ADDR
47271: GO 47220
47273: POP
47274: POP
// result = temp_list2 ;
47275: LD_ADDR_VAR 0 7
47279: PUSH
47280: LD_VAR 0 10
47284: ST_TO_ADDR
// end ;
47285: LD_VAR 0 7
47289: RET
// export function EnemyInRange ( unit , dist ) ; begin
47290: LD_INT 0
47292: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47293: LD_ADDR_VAR 0 3
47297: PUSH
47298: LD_VAR 0 1
47302: PPUSH
47303: CALL_OW 255
47307: PPUSH
47308: LD_VAR 0 1
47312: PPUSH
47313: CALL_OW 250
47317: PPUSH
47318: LD_VAR 0 1
47322: PPUSH
47323: CALL_OW 251
47327: PPUSH
47328: LD_VAR 0 2
47332: PPUSH
47333: CALL 20686 0 4
47337: PUSH
47338: LD_INT 4
47340: ARRAY
47341: ST_TO_ADDR
// end ;
47342: LD_VAR 0 3
47346: RET
// export function PlayerSeeMe ( unit ) ; begin
47347: LD_INT 0
47349: PPUSH
// result := See ( your_side , unit ) ;
47350: LD_ADDR_VAR 0 2
47354: PUSH
47355: LD_OWVAR 2
47359: PPUSH
47360: LD_VAR 0 1
47364: PPUSH
47365: CALL_OW 292
47369: ST_TO_ADDR
// end ;
47370: LD_VAR 0 2
47374: RET
// export function ReverseDir ( unit ) ; begin
47375: LD_INT 0
47377: PPUSH
// if not unit then
47378: LD_VAR 0 1
47382: NOT
47383: IFFALSE 47387
// exit ;
47385: GO 47410
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47387: LD_ADDR_VAR 0 2
47391: PUSH
47392: LD_VAR 0 1
47396: PPUSH
47397: CALL_OW 254
47401: PUSH
47402: LD_INT 3
47404: PLUS
47405: PUSH
47406: LD_INT 6
47408: MOD
47409: ST_TO_ADDR
// end ;
47410: LD_VAR 0 2
47414: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47415: LD_INT 0
47417: PPUSH
47418: PPUSH
47419: PPUSH
47420: PPUSH
47421: PPUSH
// if not hexes then
47422: LD_VAR 0 2
47426: NOT
47427: IFFALSE 47431
// exit ;
47429: GO 47579
// dist := 9999 ;
47431: LD_ADDR_VAR 0 5
47435: PUSH
47436: LD_INT 9999
47438: ST_TO_ADDR
// for i = 1 to hexes do
47439: LD_ADDR_VAR 0 4
47443: PUSH
47444: DOUBLE
47445: LD_INT 1
47447: DEC
47448: ST_TO_ADDR
47449: LD_VAR 0 2
47453: PUSH
47454: FOR_TO
47455: IFFALSE 47567
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47457: LD_VAR 0 1
47461: PPUSH
47462: LD_VAR 0 2
47466: PUSH
47467: LD_VAR 0 4
47471: ARRAY
47472: PUSH
47473: LD_INT 1
47475: ARRAY
47476: PPUSH
47477: LD_VAR 0 2
47481: PUSH
47482: LD_VAR 0 4
47486: ARRAY
47487: PUSH
47488: LD_INT 2
47490: ARRAY
47491: PPUSH
47492: CALL_OW 297
47496: PUSH
47497: LD_VAR 0 5
47501: LESS
47502: IFFALSE 47565
// begin hex := hexes [ i ] ;
47504: LD_ADDR_VAR 0 7
47508: PUSH
47509: LD_VAR 0 2
47513: PUSH
47514: LD_VAR 0 4
47518: ARRAY
47519: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47520: LD_ADDR_VAR 0 5
47524: PUSH
47525: LD_VAR 0 1
47529: PPUSH
47530: LD_VAR 0 2
47534: PUSH
47535: LD_VAR 0 4
47539: ARRAY
47540: PUSH
47541: LD_INT 1
47543: ARRAY
47544: PPUSH
47545: LD_VAR 0 2
47549: PUSH
47550: LD_VAR 0 4
47554: ARRAY
47555: PUSH
47556: LD_INT 2
47558: ARRAY
47559: PPUSH
47560: CALL_OW 297
47564: ST_TO_ADDR
// end ; end ;
47565: GO 47454
47567: POP
47568: POP
// result := hex ;
47569: LD_ADDR_VAR 0 3
47573: PUSH
47574: LD_VAR 0 7
47578: ST_TO_ADDR
// end ;
47579: LD_VAR 0 3
47583: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47584: LD_INT 0
47586: PPUSH
47587: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47588: LD_VAR 0 1
47592: NOT
47593: PUSH
47594: LD_VAR 0 1
47598: PUSH
47599: LD_INT 21
47601: PUSH
47602: LD_INT 2
47604: PUSH
47605: EMPTY
47606: LIST
47607: LIST
47608: PUSH
47609: LD_INT 23
47611: PUSH
47612: LD_INT 2
47614: PUSH
47615: EMPTY
47616: LIST
47617: LIST
47618: PUSH
47619: EMPTY
47620: LIST
47621: LIST
47622: PPUSH
47623: CALL_OW 69
47627: IN
47628: NOT
47629: OR
47630: IFFALSE 47634
// exit ;
47632: GO 47681
// for i = 1 to 3 do
47634: LD_ADDR_VAR 0 3
47638: PUSH
47639: DOUBLE
47640: LD_INT 1
47642: DEC
47643: ST_TO_ADDR
47644: LD_INT 3
47646: PUSH
47647: FOR_TO
47648: IFFALSE 47679
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47650: LD_VAR 0 1
47654: PPUSH
47655: CALL_OW 250
47659: PPUSH
47660: LD_VAR 0 1
47664: PPUSH
47665: CALL_OW 251
47669: PPUSH
47670: LD_INT 1
47672: PPUSH
47673: CALL_OW 453
47677: GO 47647
47679: POP
47680: POP
// end ;
47681: LD_VAR 0 2
47685: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47686: LD_INT 0
47688: PPUSH
47689: PPUSH
47690: PPUSH
47691: PPUSH
47692: PPUSH
47693: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47694: LD_VAR 0 1
47698: NOT
47699: PUSH
47700: LD_VAR 0 2
47704: NOT
47705: OR
47706: PUSH
47707: LD_VAR 0 1
47711: PPUSH
47712: CALL_OW 314
47716: OR
47717: IFFALSE 47721
// exit ;
47719: GO 48162
// x := GetX ( enemy_unit ) ;
47721: LD_ADDR_VAR 0 7
47725: PUSH
47726: LD_VAR 0 2
47730: PPUSH
47731: CALL_OW 250
47735: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47736: LD_ADDR_VAR 0 8
47740: PUSH
47741: LD_VAR 0 2
47745: PPUSH
47746: CALL_OW 251
47750: ST_TO_ADDR
// if not x or not y then
47751: LD_VAR 0 7
47755: NOT
47756: PUSH
47757: LD_VAR 0 8
47761: NOT
47762: OR
47763: IFFALSE 47767
// exit ;
47765: GO 48162
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47767: LD_ADDR_VAR 0 6
47771: PUSH
47772: LD_VAR 0 7
47776: PPUSH
47777: LD_INT 0
47779: PPUSH
47780: LD_INT 4
47782: PPUSH
47783: CALL_OW 272
47787: PUSH
47788: LD_VAR 0 8
47792: PPUSH
47793: LD_INT 0
47795: PPUSH
47796: LD_INT 4
47798: PPUSH
47799: CALL_OW 273
47803: PUSH
47804: EMPTY
47805: LIST
47806: LIST
47807: PUSH
47808: LD_VAR 0 7
47812: PPUSH
47813: LD_INT 1
47815: PPUSH
47816: LD_INT 4
47818: PPUSH
47819: CALL_OW 272
47823: PUSH
47824: LD_VAR 0 8
47828: PPUSH
47829: LD_INT 1
47831: PPUSH
47832: LD_INT 4
47834: PPUSH
47835: CALL_OW 273
47839: PUSH
47840: EMPTY
47841: LIST
47842: LIST
47843: PUSH
47844: LD_VAR 0 7
47848: PPUSH
47849: LD_INT 2
47851: PPUSH
47852: LD_INT 4
47854: PPUSH
47855: CALL_OW 272
47859: PUSH
47860: LD_VAR 0 8
47864: PPUSH
47865: LD_INT 2
47867: PPUSH
47868: LD_INT 4
47870: PPUSH
47871: CALL_OW 273
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PUSH
47880: LD_VAR 0 7
47884: PPUSH
47885: LD_INT 3
47887: PPUSH
47888: LD_INT 4
47890: PPUSH
47891: CALL_OW 272
47895: PUSH
47896: LD_VAR 0 8
47900: PPUSH
47901: LD_INT 3
47903: PPUSH
47904: LD_INT 4
47906: PPUSH
47907: CALL_OW 273
47911: PUSH
47912: EMPTY
47913: LIST
47914: LIST
47915: PUSH
47916: LD_VAR 0 7
47920: PPUSH
47921: LD_INT 4
47923: PPUSH
47924: LD_INT 4
47926: PPUSH
47927: CALL_OW 272
47931: PUSH
47932: LD_VAR 0 8
47936: PPUSH
47937: LD_INT 4
47939: PPUSH
47940: LD_INT 4
47942: PPUSH
47943: CALL_OW 273
47947: PUSH
47948: EMPTY
47949: LIST
47950: LIST
47951: PUSH
47952: LD_VAR 0 7
47956: PPUSH
47957: LD_INT 5
47959: PPUSH
47960: LD_INT 4
47962: PPUSH
47963: CALL_OW 272
47967: PUSH
47968: LD_VAR 0 8
47972: PPUSH
47973: LD_INT 5
47975: PPUSH
47976: LD_INT 4
47978: PPUSH
47979: CALL_OW 273
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: LIST
47992: LIST
47993: LIST
47994: LIST
47995: ST_TO_ADDR
// for i = tmp downto 1 do
47996: LD_ADDR_VAR 0 4
48000: PUSH
48001: DOUBLE
48002: LD_VAR 0 6
48006: INC
48007: ST_TO_ADDR
48008: LD_INT 1
48010: PUSH
48011: FOR_DOWNTO
48012: IFFALSE 48113
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48014: LD_VAR 0 6
48018: PUSH
48019: LD_VAR 0 4
48023: ARRAY
48024: PUSH
48025: LD_INT 1
48027: ARRAY
48028: PPUSH
48029: LD_VAR 0 6
48033: PUSH
48034: LD_VAR 0 4
48038: ARRAY
48039: PUSH
48040: LD_INT 2
48042: ARRAY
48043: PPUSH
48044: CALL_OW 488
48048: NOT
48049: PUSH
48050: LD_VAR 0 6
48054: PUSH
48055: LD_VAR 0 4
48059: ARRAY
48060: PUSH
48061: LD_INT 1
48063: ARRAY
48064: PPUSH
48065: LD_VAR 0 6
48069: PUSH
48070: LD_VAR 0 4
48074: ARRAY
48075: PUSH
48076: LD_INT 2
48078: ARRAY
48079: PPUSH
48080: CALL_OW 428
48084: PUSH
48085: LD_INT 0
48087: NONEQUAL
48088: OR
48089: IFFALSE 48111
// tmp := Delete ( tmp , i ) ;
48091: LD_ADDR_VAR 0 6
48095: PUSH
48096: LD_VAR 0 6
48100: PPUSH
48101: LD_VAR 0 4
48105: PPUSH
48106: CALL_OW 3
48110: ST_TO_ADDR
48111: GO 48011
48113: POP
48114: POP
// j := GetClosestHex ( unit , tmp ) ;
48115: LD_ADDR_VAR 0 5
48119: PUSH
48120: LD_VAR 0 1
48124: PPUSH
48125: LD_VAR 0 6
48129: PPUSH
48130: CALL 47415 0 2
48134: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48135: LD_VAR 0 1
48139: PPUSH
48140: LD_VAR 0 5
48144: PUSH
48145: LD_INT 1
48147: ARRAY
48148: PPUSH
48149: LD_VAR 0 5
48153: PUSH
48154: LD_INT 2
48156: ARRAY
48157: PPUSH
48158: CALL_OW 111
// end ;
48162: LD_VAR 0 3
48166: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48167: LD_INT 0
48169: PPUSH
48170: PPUSH
48171: PPUSH
// uc_side = 0 ;
48172: LD_ADDR_OWVAR 20
48176: PUSH
48177: LD_INT 0
48179: ST_TO_ADDR
// uc_nation = 0 ;
48180: LD_ADDR_OWVAR 21
48184: PUSH
48185: LD_INT 0
48187: ST_TO_ADDR
// InitHc_All ( ) ;
48188: CALL_OW 584
// InitVc ;
48192: CALL_OW 20
// if mastodonts then
48196: LD_VAR 0 6
48200: IFFALSE 48267
// for i = 1 to mastodonts do
48202: LD_ADDR_VAR 0 11
48206: PUSH
48207: DOUBLE
48208: LD_INT 1
48210: DEC
48211: ST_TO_ADDR
48212: LD_VAR 0 6
48216: PUSH
48217: FOR_TO
48218: IFFALSE 48265
// begin vc_chassis := 31 ;
48220: LD_ADDR_OWVAR 37
48224: PUSH
48225: LD_INT 31
48227: ST_TO_ADDR
// vc_control := control_rider ;
48228: LD_ADDR_OWVAR 38
48232: PUSH
48233: LD_INT 4
48235: ST_TO_ADDR
// animal := CreateVehicle ;
48236: LD_ADDR_VAR 0 12
48240: PUSH
48241: CALL_OW 45
48245: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48246: LD_VAR 0 12
48250: PPUSH
48251: LD_VAR 0 8
48255: PPUSH
48256: LD_INT 0
48258: PPUSH
48259: CALL 50455 0 3
// end ;
48263: GO 48217
48265: POP
48266: POP
// if horses then
48267: LD_VAR 0 5
48271: IFFALSE 48338
// for i = 1 to horses do
48273: LD_ADDR_VAR 0 11
48277: PUSH
48278: DOUBLE
48279: LD_INT 1
48281: DEC
48282: ST_TO_ADDR
48283: LD_VAR 0 5
48287: PUSH
48288: FOR_TO
48289: IFFALSE 48336
// begin hc_class := 21 ;
48291: LD_ADDR_OWVAR 28
48295: PUSH
48296: LD_INT 21
48298: ST_TO_ADDR
// hc_gallery :=  ;
48299: LD_ADDR_OWVAR 33
48303: PUSH
48304: LD_STRING 
48306: ST_TO_ADDR
// animal := CreateHuman ;
48307: LD_ADDR_VAR 0 12
48311: PUSH
48312: CALL_OW 44
48316: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48317: LD_VAR 0 12
48321: PPUSH
48322: LD_VAR 0 8
48326: PPUSH
48327: LD_INT 0
48329: PPUSH
48330: CALL 50455 0 3
// end ;
48334: GO 48288
48336: POP
48337: POP
// if birds then
48338: LD_VAR 0 1
48342: IFFALSE 48409
// for i = 1 to birds do
48344: LD_ADDR_VAR 0 11
48348: PUSH
48349: DOUBLE
48350: LD_INT 1
48352: DEC
48353: ST_TO_ADDR
48354: LD_VAR 0 1
48358: PUSH
48359: FOR_TO
48360: IFFALSE 48407
// begin hc_class = 18 ;
48362: LD_ADDR_OWVAR 28
48366: PUSH
48367: LD_INT 18
48369: ST_TO_ADDR
// hc_gallery =  ;
48370: LD_ADDR_OWVAR 33
48374: PUSH
48375: LD_STRING 
48377: ST_TO_ADDR
// animal := CreateHuman ;
48378: LD_ADDR_VAR 0 12
48382: PUSH
48383: CALL_OW 44
48387: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48388: LD_VAR 0 12
48392: PPUSH
48393: LD_VAR 0 8
48397: PPUSH
48398: LD_INT 0
48400: PPUSH
48401: CALL 50455 0 3
// end ;
48405: GO 48359
48407: POP
48408: POP
// if tigers then
48409: LD_VAR 0 2
48413: IFFALSE 48497
// for i = 1 to tigers do
48415: LD_ADDR_VAR 0 11
48419: PUSH
48420: DOUBLE
48421: LD_INT 1
48423: DEC
48424: ST_TO_ADDR
48425: LD_VAR 0 2
48429: PUSH
48430: FOR_TO
48431: IFFALSE 48495
// begin hc_class = class_tiger ;
48433: LD_ADDR_OWVAR 28
48437: PUSH
48438: LD_INT 14
48440: ST_TO_ADDR
// hc_gallery =  ;
48441: LD_ADDR_OWVAR 33
48445: PUSH
48446: LD_STRING 
48448: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48449: LD_ADDR_OWVAR 35
48453: PUSH
48454: LD_INT 7
48456: NEG
48457: PPUSH
48458: LD_INT 7
48460: PPUSH
48461: CALL_OW 12
48465: ST_TO_ADDR
// animal := CreateHuman ;
48466: LD_ADDR_VAR 0 12
48470: PUSH
48471: CALL_OW 44
48475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48476: LD_VAR 0 12
48480: PPUSH
48481: LD_VAR 0 8
48485: PPUSH
48486: LD_INT 0
48488: PPUSH
48489: CALL 50455 0 3
// end ;
48493: GO 48430
48495: POP
48496: POP
// if apemans then
48497: LD_VAR 0 3
48501: IFFALSE 48624
// for i = 1 to apemans do
48503: LD_ADDR_VAR 0 11
48507: PUSH
48508: DOUBLE
48509: LD_INT 1
48511: DEC
48512: ST_TO_ADDR
48513: LD_VAR 0 3
48517: PUSH
48518: FOR_TO
48519: IFFALSE 48622
// begin hc_class = class_apeman ;
48521: LD_ADDR_OWVAR 28
48525: PUSH
48526: LD_INT 12
48528: ST_TO_ADDR
// hc_gallery =  ;
48529: LD_ADDR_OWVAR 33
48533: PUSH
48534: LD_STRING 
48536: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48537: LD_ADDR_OWVAR 35
48541: PUSH
48542: LD_INT 2
48544: NEG
48545: PPUSH
48546: LD_INT 2
48548: PPUSH
48549: CALL_OW 12
48553: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48554: LD_ADDR_OWVAR 31
48558: PUSH
48559: LD_INT 1
48561: PPUSH
48562: LD_INT 3
48564: PPUSH
48565: CALL_OW 12
48569: PUSH
48570: LD_INT 1
48572: PPUSH
48573: LD_INT 3
48575: PPUSH
48576: CALL_OW 12
48580: PUSH
48581: LD_INT 0
48583: PUSH
48584: LD_INT 0
48586: PUSH
48587: EMPTY
48588: LIST
48589: LIST
48590: LIST
48591: LIST
48592: ST_TO_ADDR
// animal := CreateHuman ;
48593: LD_ADDR_VAR 0 12
48597: PUSH
48598: CALL_OW 44
48602: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48603: LD_VAR 0 12
48607: PPUSH
48608: LD_VAR 0 8
48612: PPUSH
48613: LD_INT 0
48615: PPUSH
48616: CALL 50455 0 3
// end ;
48620: GO 48518
48622: POP
48623: POP
// if enchidnas then
48624: LD_VAR 0 4
48628: IFFALSE 48695
// for i = 1 to enchidnas do
48630: LD_ADDR_VAR 0 11
48634: PUSH
48635: DOUBLE
48636: LD_INT 1
48638: DEC
48639: ST_TO_ADDR
48640: LD_VAR 0 4
48644: PUSH
48645: FOR_TO
48646: IFFALSE 48693
// begin hc_class = 13 ;
48648: LD_ADDR_OWVAR 28
48652: PUSH
48653: LD_INT 13
48655: ST_TO_ADDR
// hc_gallery =  ;
48656: LD_ADDR_OWVAR 33
48660: PUSH
48661: LD_STRING 
48663: ST_TO_ADDR
// animal := CreateHuman ;
48664: LD_ADDR_VAR 0 12
48668: PUSH
48669: CALL_OW 44
48673: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48674: LD_VAR 0 12
48678: PPUSH
48679: LD_VAR 0 8
48683: PPUSH
48684: LD_INT 0
48686: PPUSH
48687: CALL 50455 0 3
// end ;
48691: GO 48645
48693: POP
48694: POP
// if fishes then
48695: LD_VAR 0 7
48699: IFFALSE 48766
// for i = 1 to fishes do
48701: LD_ADDR_VAR 0 11
48705: PUSH
48706: DOUBLE
48707: LD_INT 1
48709: DEC
48710: ST_TO_ADDR
48711: LD_VAR 0 7
48715: PUSH
48716: FOR_TO
48717: IFFALSE 48764
// begin hc_class = 20 ;
48719: LD_ADDR_OWVAR 28
48723: PUSH
48724: LD_INT 20
48726: ST_TO_ADDR
// hc_gallery =  ;
48727: LD_ADDR_OWVAR 33
48731: PUSH
48732: LD_STRING 
48734: ST_TO_ADDR
// animal := CreateHuman ;
48735: LD_ADDR_VAR 0 12
48739: PUSH
48740: CALL_OW 44
48744: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48745: LD_VAR 0 12
48749: PPUSH
48750: LD_VAR 0 9
48754: PPUSH
48755: LD_INT 0
48757: PPUSH
48758: CALL 50455 0 3
// end ;
48762: GO 48716
48764: POP
48765: POP
// end ;
48766: LD_VAR 0 10
48770: RET
// export function WantHeal ( sci , unit ) ; begin
48771: LD_INT 0
48773: PPUSH
// if GetTaskList ( sci ) > 0 then
48774: LD_VAR 0 1
48778: PPUSH
48779: CALL_OW 437
48783: PUSH
48784: LD_INT 0
48786: GREATER
48787: IFFALSE 48857
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48789: LD_VAR 0 1
48793: PPUSH
48794: CALL_OW 437
48798: PUSH
48799: LD_INT 1
48801: ARRAY
48802: PUSH
48803: LD_INT 1
48805: ARRAY
48806: PUSH
48807: LD_STRING l
48809: EQUAL
48810: PUSH
48811: LD_VAR 0 1
48815: PPUSH
48816: CALL_OW 437
48820: PUSH
48821: LD_INT 1
48823: ARRAY
48824: PUSH
48825: LD_INT 4
48827: ARRAY
48828: PUSH
48829: LD_VAR 0 2
48833: EQUAL
48834: AND
48835: IFFALSE 48847
// result := true else
48837: LD_ADDR_VAR 0 3
48841: PUSH
48842: LD_INT 1
48844: ST_TO_ADDR
48845: GO 48855
// result := false ;
48847: LD_ADDR_VAR 0 3
48851: PUSH
48852: LD_INT 0
48854: ST_TO_ADDR
// end else
48855: GO 48865
// result := false ;
48857: LD_ADDR_VAR 0 3
48861: PUSH
48862: LD_INT 0
48864: ST_TO_ADDR
// end ;
48865: LD_VAR 0 3
48869: RET
// export function HealTarget ( sci ) ; begin
48870: LD_INT 0
48872: PPUSH
// if not sci then
48873: LD_VAR 0 1
48877: NOT
48878: IFFALSE 48882
// exit ;
48880: GO 48947
// result := 0 ;
48882: LD_ADDR_VAR 0 2
48886: PUSH
48887: LD_INT 0
48889: ST_TO_ADDR
// if GetTaskList ( sci ) then
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 437
48899: IFFALSE 48947
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48901: LD_VAR 0 1
48905: PPUSH
48906: CALL_OW 437
48910: PUSH
48911: LD_INT 1
48913: ARRAY
48914: PUSH
48915: LD_INT 1
48917: ARRAY
48918: PUSH
48919: LD_STRING l
48921: EQUAL
48922: IFFALSE 48947
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48924: LD_ADDR_VAR 0 2
48928: PUSH
48929: LD_VAR 0 1
48933: PPUSH
48934: CALL_OW 437
48938: PUSH
48939: LD_INT 1
48941: ARRAY
48942: PUSH
48943: LD_INT 4
48945: ARRAY
48946: ST_TO_ADDR
// end ;
48947: LD_VAR 0 2
48951: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48952: LD_INT 0
48954: PPUSH
48955: PPUSH
48956: PPUSH
48957: PPUSH
// if not base_units then
48958: LD_VAR 0 1
48962: NOT
48963: IFFALSE 48967
// exit ;
48965: GO 49054
// result := false ;
48967: LD_ADDR_VAR 0 2
48971: PUSH
48972: LD_INT 0
48974: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48975: LD_ADDR_VAR 0 5
48979: PUSH
48980: LD_VAR 0 1
48984: PPUSH
48985: LD_INT 21
48987: PUSH
48988: LD_INT 3
48990: PUSH
48991: EMPTY
48992: LIST
48993: LIST
48994: PPUSH
48995: CALL_OW 72
48999: ST_TO_ADDR
// if not tmp then
49000: LD_VAR 0 5
49004: NOT
49005: IFFALSE 49009
// exit ;
49007: GO 49054
// for i in tmp do
49009: LD_ADDR_VAR 0 3
49013: PUSH
49014: LD_VAR 0 5
49018: PUSH
49019: FOR_IN
49020: IFFALSE 49052
// begin result := EnemyInRange ( i , 22 ) ;
49022: LD_ADDR_VAR 0 2
49026: PUSH
49027: LD_VAR 0 3
49031: PPUSH
49032: LD_INT 22
49034: PPUSH
49035: CALL 47290 0 2
49039: ST_TO_ADDR
// if result then
49040: LD_VAR 0 2
49044: IFFALSE 49050
// exit ;
49046: POP
49047: POP
49048: GO 49054
// end ;
49050: GO 49019
49052: POP
49053: POP
// end ;
49054: LD_VAR 0 2
49058: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
49059: LD_INT 0
49061: PPUSH
49062: PPUSH
// if not units then
49063: LD_VAR 0 1
49067: NOT
49068: IFFALSE 49072
// exit ;
49070: GO 49142
// result := [ ] ;
49072: LD_ADDR_VAR 0 3
49076: PUSH
49077: EMPTY
49078: ST_TO_ADDR
// for i in units do
49079: LD_ADDR_VAR 0 4
49083: PUSH
49084: LD_VAR 0 1
49088: PUSH
49089: FOR_IN
49090: IFFALSE 49140
// if GetTag ( i ) = tag then
49092: LD_VAR 0 4
49096: PPUSH
49097: CALL_OW 110
49101: PUSH
49102: LD_VAR 0 2
49106: EQUAL
49107: IFFALSE 49138
// result := Replace ( result , result + 1 , i ) ;
49109: LD_ADDR_VAR 0 3
49113: PUSH
49114: LD_VAR 0 3
49118: PPUSH
49119: LD_VAR 0 3
49123: PUSH
49124: LD_INT 1
49126: PLUS
49127: PPUSH
49128: LD_VAR 0 4
49132: PPUSH
49133: CALL_OW 1
49137: ST_TO_ADDR
49138: GO 49089
49140: POP
49141: POP
// end ;
49142: LD_VAR 0 3
49146: RET
// export function IsDriver ( un ) ; begin
49147: LD_INT 0
49149: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49150: LD_ADDR_VAR 0 2
49154: PUSH
49155: LD_VAR 0 1
49159: PUSH
49160: LD_INT 55
49162: PUSH
49163: EMPTY
49164: LIST
49165: PPUSH
49166: CALL_OW 69
49170: IN
49171: ST_TO_ADDR
// end ;
49172: LD_VAR 0 2
49176: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49177: LD_INT 0
49179: PPUSH
49180: PPUSH
// list := [ ] ;
49181: LD_ADDR_VAR 0 5
49185: PUSH
49186: EMPTY
49187: ST_TO_ADDR
// case d of 0 :
49188: LD_VAR 0 3
49192: PUSH
49193: LD_INT 0
49195: DOUBLE
49196: EQUAL
49197: IFTRUE 49201
49199: GO 49334
49201: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49202: LD_ADDR_VAR 0 5
49206: PUSH
49207: LD_VAR 0 1
49211: PUSH
49212: LD_INT 4
49214: MINUS
49215: PUSH
49216: LD_VAR 0 2
49220: PUSH
49221: LD_INT 4
49223: MINUS
49224: PUSH
49225: LD_INT 2
49227: PUSH
49228: EMPTY
49229: LIST
49230: LIST
49231: LIST
49232: PUSH
49233: LD_VAR 0 1
49237: PUSH
49238: LD_INT 3
49240: MINUS
49241: PUSH
49242: LD_VAR 0 2
49246: PUSH
49247: LD_INT 1
49249: PUSH
49250: EMPTY
49251: LIST
49252: LIST
49253: LIST
49254: PUSH
49255: LD_VAR 0 1
49259: PUSH
49260: LD_INT 4
49262: PLUS
49263: PUSH
49264: LD_VAR 0 2
49268: PUSH
49269: LD_INT 4
49271: PUSH
49272: EMPTY
49273: LIST
49274: LIST
49275: LIST
49276: PUSH
49277: LD_VAR 0 1
49281: PUSH
49282: LD_INT 3
49284: PLUS
49285: PUSH
49286: LD_VAR 0 2
49290: PUSH
49291: LD_INT 3
49293: PLUS
49294: PUSH
49295: LD_INT 5
49297: PUSH
49298: EMPTY
49299: LIST
49300: LIST
49301: LIST
49302: PUSH
49303: LD_VAR 0 1
49307: PUSH
49308: LD_VAR 0 2
49312: PUSH
49313: LD_INT 4
49315: PLUS
49316: PUSH
49317: LD_INT 0
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: LIST
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: ST_TO_ADDR
// end ; 1 :
49332: GO 50032
49334: LD_INT 1
49336: DOUBLE
49337: EQUAL
49338: IFTRUE 49342
49340: GO 49475
49342: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49343: LD_ADDR_VAR 0 5
49347: PUSH
49348: LD_VAR 0 1
49352: PUSH
49353: LD_VAR 0 2
49357: PUSH
49358: LD_INT 4
49360: MINUS
49361: PUSH
49362: LD_INT 3
49364: PUSH
49365: EMPTY
49366: LIST
49367: LIST
49368: LIST
49369: PUSH
49370: LD_VAR 0 1
49374: PUSH
49375: LD_INT 3
49377: MINUS
49378: PUSH
49379: LD_VAR 0 2
49383: PUSH
49384: LD_INT 3
49386: MINUS
49387: PUSH
49388: LD_INT 2
49390: PUSH
49391: EMPTY
49392: LIST
49393: LIST
49394: LIST
49395: PUSH
49396: LD_VAR 0 1
49400: PUSH
49401: LD_INT 4
49403: MINUS
49404: PUSH
49405: LD_VAR 0 2
49409: PUSH
49410: LD_INT 1
49412: PUSH
49413: EMPTY
49414: LIST
49415: LIST
49416: LIST
49417: PUSH
49418: LD_VAR 0 1
49422: PUSH
49423: LD_VAR 0 2
49427: PUSH
49428: LD_INT 3
49430: PLUS
49431: PUSH
49432: LD_INT 0
49434: PUSH
49435: EMPTY
49436: LIST
49437: LIST
49438: LIST
49439: PUSH
49440: LD_VAR 0 1
49444: PUSH
49445: LD_INT 4
49447: PLUS
49448: PUSH
49449: LD_VAR 0 2
49453: PUSH
49454: LD_INT 4
49456: PLUS
49457: PUSH
49458: LD_INT 5
49460: PUSH
49461: EMPTY
49462: LIST
49463: LIST
49464: LIST
49465: PUSH
49466: EMPTY
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: ST_TO_ADDR
// end ; 2 :
49473: GO 50032
49475: LD_INT 2
49477: DOUBLE
49478: EQUAL
49479: IFTRUE 49483
49481: GO 49612
49483: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49484: LD_ADDR_VAR 0 5
49488: PUSH
49489: LD_VAR 0 1
49493: PUSH
49494: LD_VAR 0 2
49498: PUSH
49499: LD_INT 3
49501: MINUS
49502: PUSH
49503: LD_INT 3
49505: PUSH
49506: EMPTY
49507: LIST
49508: LIST
49509: LIST
49510: PUSH
49511: LD_VAR 0 1
49515: PUSH
49516: LD_INT 4
49518: PLUS
49519: PUSH
49520: LD_VAR 0 2
49524: PUSH
49525: LD_INT 4
49527: PUSH
49528: EMPTY
49529: LIST
49530: LIST
49531: LIST
49532: PUSH
49533: LD_VAR 0 1
49537: PUSH
49538: LD_VAR 0 2
49542: PUSH
49543: LD_INT 4
49545: PLUS
49546: PUSH
49547: LD_INT 0
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: LIST
49554: PUSH
49555: LD_VAR 0 1
49559: PUSH
49560: LD_INT 3
49562: MINUS
49563: PUSH
49564: LD_VAR 0 2
49568: PUSH
49569: LD_INT 1
49571: PUSH
49572: EMPTY
49573: LIST
49574: LIST
49575: LIST
49576: PUSH
49577: LD_VAR 0 1
49581: PUSH
49582: LD_INT 4
49584: MINUS
49585: PUSH
49586: LD_VAR 0 2
49590: PUSH
49591: LD_INT 4
49593: MINUS
49594: PUSH
49595: LD_INT 2
49597: PUSH
49598: EMPTY
49599: LIST
49600: LIST
49601: LIST
49602: PUSH
49603: EMPTY
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: ST_TO_ADDR
// end ; 3 :
49610: GO 50032
49612: LD_INT 3
49614: DOUBLE
49615: EQUAL
49616: IFTRUE 49620
49618: GO 49753
49620: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49621: LD_ADDR_VAR 0 5
49625: PUSH
49626: LD_VAR 0 1
49630: PUSH
49631: LD_INT 3
49633: PLUS
49634: PUSH
49635: LD_VAR 0 2
49639: PUSH
49640: LD_INT 4
49642: PUSH
49643: EMPTY
49644: LIST
49645: LIST
49646: LIST
49647: PUSH
49648: LD_VAR 0 1
49652: PUSH
49653: LD_INT 4
49655: PLUS
49656: PUSH
49657: LD_VAR 0 2
49661: PUSH
49662: LD_INT 4
49664: PLUS
49665: PUSH
49666: LD_INT 5
49668: PUSH
49669: EMPTY
49670: LIST
49671: LIST
49672: LIST
49673: PUSH
49674: LD_VAR 0 1
49678: PUSH
49679: LD_INT 4
49681: MINUS
49682: PUSH
49683: LD_VAR 0 2
49687: PUSH
49688: LD_INT 1
49690: PUSH
49691: EMPTY
49692: LIST
49693: LIST
49694: LIST
49695: PUSH
49696: LD_VAR 0 1
49700: PUSH
49701: LD_VAR 0 2
49705: PUSH
49706: LD_INT 4
49708: MINUS
49709: PUSH
49710: LD_INT 3
49712: PUSH
49713: EMPTY
49714: LIST
49715: LIST
49716: LIST
49717: PUSH
49718: LD_VAR 0 1
49722: PUSH
49723: LD_INT 3
49725: MINUS
49726: PUSH
49727: LD_VAR 0 2
49731: PUSH
49732: LD_INT 3
49734: MINUS
49735: PUSH
49736: LD_INT 2
49738: PUSH
49739: EMPTY
49740: LIST
49741: LIST
49742: LIST
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: LIST
49748: LIST
49749: LIST
49750: ST_TO_ADDR
// end ; 4 :
49751: GO 50032
49753: LD_INT 4
49755: DOUBLE
49756: EQUAL
49757: IFTRUE 49761
49759: GO 49894
49761: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49762: LD_ADDR_VAR 0 5
49766: PUSH
49767: LD_VAR 0 1
49771: PUSH
49772: LD_VAR 0 2
49776: PUSH
49777: LD_INT 4
49779: PLUS
49780: PUSH
49781: LD_INT 0
49783: PUSH
49784: EMPTY
49785: LIST
49786: LIST
49787: LIST
49788: PUSH
49789: LD_VAR 0 1
49793: PUSH
49794: LD_INT 3
49796: PLUS
49797: PUSH
49798: LD_VAR 0 2
49802: PUSH
49803: LD_INT 3
49805: PLUS
49806: PUSH
49807: LD_INT 5
49809: PUSH
49810: EMPTY
49811: LIST
49812: LIST
49813: LIST
49814: PUSH
49815: LD_VAR 0 1
49819: PUSH
49820: LD_INT 4
49822: PLUS
49823: PUSH
49824: LD_VAR 0 2
49828: PUSH
49829: LD_INT 4
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: LIST
49836: PUSH
49837: LD_VAR 0 1
49841: PUSH
49842: LD_VAR 0 2
49846: PUSH
49847: LD_INT 3
49849: MINUS
49850: PUSH
49851: LD_INT 3
49853: PUSH
49854: EMPTY
49855: LIST
49856: LIST
49857: LIST
49858: PUSH
49859: LD_VAR 0 1
49863: PUSH
49864: LD_INT 4
49866: MINUS
49867: PUSH
49868: LD_VAR 0 2
49872: PUSH
49873: LD_INT 4
49875: MINUS
49876: PUSH
49877: LD_INT 2
49879: PUSH
49880: EMPTY
49881: LIST
49882: LIST
49883: LIST
49884: PUSH
49885: EMPTY
49886: LIST
49887: LIST
49888: LIST
49889: LIST
49890: LIST
49891: ST_TO_ADDR
// end ; 5 :
49892: GO 50032
49894: LD_INT 5
49896: DOUBLE
49897: EQUAL
49898: IFTRUE 49902
49900: GO 50031
49902: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49903: LD_ADDR_VAR 0 5
49907: PUSH
49908: LD_VAR 0 1
49912: PUSH
49913: LD_INT 4
49915: MINUS
49916: PUSH
49917: LD_VAR 0 2
49921: PUSH
49922: LD_INT 1
49924: PUSH
49925: EMPTY
49926: LIST
49927: LIST
49928: LIST
49929: PUSH
49930: LD_VAR 0 1
49934: PUSH
49935: LD_VAR 0 2
49939: PUSH
49940: LD_INT 4
49942: MINUS
49943: PUSH
49944: LD_INT 3
49946: PUSH
49947: EMPTY
49948: LIST
49949: LIST
49950: LIST
49951: PUSH
49952: LD_VAR 0 1
49956: PUSH
49957: LD_INT 4
49959: PLUS
49960: PUSH
49961: LD_VAR 0 2
49965: PUSH
49966: LD_INT 4
49968: PLUS
49969: PUSH
49970: LD_INT 5
49972: PUSH
49973: EMPTY
49974: LIST
49975: LIST
49976: LIST
49977: PUSH
49978: LD_VAR 0 1
49982: PUSH
49983: LD_INT 3
49985: PLUS
49986: PUSH
49987: LD_VAR 0 2
49991: PUSH
49992: LD_INT 4
49994: PUSH
49995: EMPTY
49996: LIST
49997: LIST
49998: LIST
49999: PUSH
50000: LD_VAR 0 1
50004: PUSH
50005: LD_VAR 0 2
50009: PUSH
50010: LD_INT 3
50012: PLUS
50013: PUSH
50014: LD_INT 0
50016: PUSH
50017: EMPTY
50018: LIST
50019: LIST
50020: LIST
50021: PUSH
50022: EMPTY
50023: LIST
50024: LIST
50025: LIST
50026: LIST
50027: LIST
50028: ST_TO_ADDR
// end ; end ;
50029: GO 50032
50031: POP
// result := list ;
50032: LD_ADDR_VAR 0 4
50036: PUSH
50037: LD_VAR 0 5
50041: ST_TO_ADDR
// end ;
50042: LD_VAR 0 4
50046: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50047: LD_INT 0
50049: PPUSH
50050: PPUSH
50051: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50052: LD_VAR 0 1
50056: NOT
50057: PUSH
50058: LD_VAR 0 2
50062: PUSH
50063: LD_INT 1
50065: PUSH
50066: LD_INT 2
50068: PUSH
50069: LD_INT 3
50071: PUSH
50072: LD_INT 4
50074: PUSH
50075: EMPTY
50076: LIST
50077: LIST
50078: LIST
50079: LIST
50080: IN
50081: NOT
50082: OR
50083: IFFALSE 50087
// exit ;
50085: GO 50179
// tmp := [ ] ;
50087: LD_ADDR_VAR 0 5
50091: PUSH
50092: EMPTY
50093: ST_TO_ADDR
// for i in units do
50094: LD_ADDR_VAR 0 4
50098: PUSH
50099: LD_VAR 0 1
50103: PUSH
50104: FOR_IN
50105: IFFALSE 50148
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50107: LD_ADDR_VAR 0 5
50111: PUSH
50112: LD_VAR 0 5
50116: PPUSH
50117: LD_VAR 0 5
50121: PUSH
50122: LD_INT 1
50124: PLUS
50125: PPUSH
50126: LD_VAR 0 4
50130: PPUSH
50131: LD_VAR 0 2
50135: PPUSH
50136: CALL_OW 259
50140: PPUSH
50141: CALL_OW 2
50145: ST_TO_ADDR
50146: GO 50104
50148: POP
50149: POP
// if not tmp then
50150: LD_VAR 0 5
50154: NOT
50155: IFFALSE 50159
// exit ;
50157: GO 50179
// result := SortListByListDesc ( units , tmp ) ;
50159: LD_ADDR_VAR 0 3
50163: PUSH
50164: LD_VAR 0 1
50168: PPUSH
50169: LD_VAR 0 5
50173: PPUSH
50174: CALL_OW 77
50178: ST_TO_ADDR
// end ;
50179: LD_VAR 0 3
50183: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50184: LD_INT 0
50186: PPUSH
50187: PPUSH
50188: PPUSH
// result := false ;
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_INT 0
50196: ST_TO_ADDR
// x := GetX ( building ) ;
50197: LD_ADDR_VAR 0 4
50201: PUSH
50202: LD_VAR 0 2
50206: PPUSH
50207: CALL_OW 250
50211: ST_TO_ADDR
// y := GetY ( building ) ;
50212: LD_ADDR_VAR 0 5
50216: PUSH
50217: LD_VAR 0 2
50221: PPUSH
50222: CALL_OW 251
50226: ST_TO_ADDR
// if not building or not x or not y then
50227: LD_VAR 0 2
50231: NOT
50232: PUSH
50233: LD_VAR 0 4
50237: NOT
50238: OR
50239: PUSH
50240: LD_VAR 0 5
50244: NOT
50245: OR
50246: IFFALSE 50250
// exit ;
50248: GO 50342
// if GetTaskList ( unit ) then
50250: LD_VAR 0 1
50254: PPUSH
50255: CALL_OW 437
50259: IFFALSE 50342
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50261: LD_STRING e
50263: PUSH
50264: LD_VAR 0 1
50268: PPUSH
50269: CALL_OW 437
50273: PUSH
50274: LD_INT 1
50276: ARRAY
50277: PUSH
50278: LD_INT 1
50280: ARRAY
50281: EQUAL
50282: PUSH
50283: LD_VAR 0 4
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: CALL_OW 437
50297: PUSH
50298: LD_INT 1
50300: ARRAY
50301: PUSH
50302: LD_INT 2
50304: ARRAY
50305: EQUAL
50306: AND
50307: PUSH
50308: LD_VAR 0 5
50312: PUSH
50313: LD_VAR 0 1
50317: PPUSH
50318: CALL_OW 437
50322: PUSH
50323: LD_INT 1
50325: ARRAY
50326: PUSH
50327: LD_INT 3
50329: ARRAY
50330: EQUAL
50331: AND
50332: IFFALSE 50342
// result := true end ;
50334: LD_ADDR_VAR 0 3
50338: PUSH
50339: LD_INT 1
50341: ST_TO_ADDR
// end ;
50342: LD_VAR 0 3
50346: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50347: LD_INT 0
50349: PPUSH
// result := false ;
50350: LD_ADDR_VAR 0 4
50354: PUSH
50355: LD_INT 0
50357: ST_TO_ADDR
// if GetTaskList ( unit ) then
50358: LD_VAR 0 1
50362: PPUSH
50363: CALL_OW 437
50367: IFFALSE 50450
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50369: LD_STRING M
50371: PUSH
50372: LD_VAR 0 1
50376: PPUSH
50377: CALL_OW 437
50381: PUSH
50382: LD_INT 1
50384: ARRAY
50385: PUSH
50386: LD_INT 1
50388: ARRAY
50389: EQUAL
50390: PUSH
50391: LD_VAR 0 2
50395: PUSH
50396: LD_VAR 0 1
50400: PPUSH
50401: CALL_OW 437
50405: PUSH
50406: LD_INT 1
50408: ARRAY
50409: PUSH
50410: LD_INT 2
50412: ARRAY
50413: EQUAL
50414: AND
50415: PUSH
50416: LD_VAR 0 3
50420: PUSH
50421: LD_VAR 0 1
50425: PPUSH
50426: CALL_OW 437
50430: PUSH
50431: LD_INT 1
50433: ARRAY
50434: PUSH
50435: LD_INT 3
50437: ARRAY
50438: EQUAL
50439: AND
50440: IFFALSE 50450
// result := true ;
50442: LD_ADDR_VAR 0 4
50446: PUSH
50447: LD_INT 1
50449: ST_TO_ADDR
// end ; end ;
50450: LD_VAR 0 4
50454: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50455: LD_INT 0
50457: PPUSH
50458: PPUSH
50459: PPUSH
50460: PPUSH
// if not unit or not area then
50461: LD_VAR 0 1
50465: NOT
50466: PUSH
50467: LD_VAR 0 2
50471: NOT
50472: OR
50473: IFFALSE 50477
// exit ;
50475: GO 50641
// tmp := AreaToList ( area , i ) ;
50477: LD_ADDR_VAR 0 6
50481: PUSH
50482: LD_VAR 0 2
50486: PPUSH
50487: LD_VAR 0 5
50491: PPUSH
50492: CALL_OW 517
50496: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50497: LD_ADDR_VAR 0 5
50501: PUSH
50502: DOUBLE
50503: LD_INT 1
50505: DEC
50506: ST_TO_ADDR
50507: LD_VAR 0 6
50511: PUSH
50512: LD_INT 1
50514: ARRAY
50515: PUSH
50516: FOR_TO
50517: IFFALSE 50639
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50519: LD_ADDR_VAR 0 7
50523: PUSH
50524: LD_VAR 0 6
50528: PUSH
50529: LD_INT 1
50531: ARRAY
50532: PUSH
50533: LD_VAR 0 5
50537: ARRAY
50538: PUSH
50539: LD_VAR 0 6
50543: PUSH
50544: LD_INT 2
50546: ARRAY
50547: PUSH
50548: LD_VAR 0 5
50552: ARRAY
50553: PUSH
50554: EMPTY
50555: LIST
50556: LIST
50557: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50558: LD_VAR 0 7
50562: PUSH
50563: LD_INT 1
50565: ARRAY
50566: PPUSH
50567: LD_VAR 0 7
50571: PUSH
50572: LD_INT 2
50574: ARRAY
50575: PPUSH
50576: CALL_OW 428
50580: PUSH
50581: LD_INT 0
50583: EQUAL
50584: IFFALSE 50637
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50586: LD_VAR 0 1
50590: PPUSH
50591: LD_VAR 0 7
50595: PUSH
50596: LD_INT 1
50598: ARRAY
50599: PPUSH
50600: LD_VAR 0 7
50604: PUSH
50605: LD_INT 2
50607: ARRAY
50608: PPUSH
50609: LD_VAR 0 3
50613: PPUSH
50614: CALL_OW 48
// result := IsPlaced ( unit ) ;
50618: LD_ADDR_VAR 0 4
50622: PUSH
50623: LD_VAR 0 1
50627: PPUSH
50628: CALL_OW 305
50632: ST_TO_ADDR
// exit ;
50633: POP
50634: POP
50635: GO 50641
// end ; end ;
50637: GO 50516
50639: POP
50640: POP
// end ;
50641: LD_VAR 0 4
50645: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50646: LD_INT 0
50648: PPUSH
50649: PPUSH
50650: PPUSH
// if not side or side > 8 then
50651: LD_VAR 0 1
50655: NOT
50656: PUSH
50657: LD_VAR 0 1
50661: PUSH
50662: LD_INT 8
50664: GREATER
50665: OR
50666: IFFALSE 50670
// exit ;
50668: GO 50857
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50670: LD_ADDR_VAR 0 4
50674: PUSH
50675: LD_INT 22
50677: PUSH
50678: LD_VAR 0 1
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: PUSH
50687: LD_INT 21
50689: PUSH
50690: LD_INT 3
50692: PUSH
50693: EMPTY
50694: LIST
50695: LIST
50696: PUSH
50697: EMPTY
50698: LIST
50699: LIST
50700: PPUSH
50701: CALL_OW 69
50705: ST_TO_ADDR
// if not tmp then
50706: LD_VAR 0 4
50710: NOT
50711: IFFALSE 50715
// exit ;
50713: GO 50857
// enable_addtolog := true ;
50715: LD_ADDR_OWVAR 81
50719: PUSH
50720: LD_INT 1
50722: ST_TO_ADDR
// AddToLog ( [ ) ;
50723: LD_STRING [
50725: PPUSH
50726: CALL_OW 561
// for i in tmp do
50730: LD_ADDR_VAR 0 3
50734: PUSH
50735: LD_VAR 0 4
50739: PUSH
50740: FOR_IN
50741: IFFALSE 50848
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50743: LD_STRING [
50745: PUSH
50746: LD_VAR 0 3
50750: PPUSH
50751: CALL_OW 266
50755: STR
50756: PUSH
50757: LD_STRING , 
50759: STR
50760: PUSH
50761: LD_VAR 0 3
50765: PPUSH
50766: CALL_OW 250
50770: STR
50771: PUSH
50772: LD_STRING , 
50774: STR
50775: PUSH
50776: LD_VAR 0 3
50780: PPUSH
50781: CALL_OW 251
50785: STR
50786: PUSH
50787: LD_STRING , 
50789: STR
50790: PUSH
50791: LD_VAR 0 3
50795: PPUSH
50796: CALL_OW 254
50800: STR
50801: PUSH
50802: LD_STRING , 
50804: STR
50805: PUSH
50806: LD_VAR 0 3
50810: PPUSH
50811: LD_INT 1
50813: PPUSH
50814: CALL_OW 268
50818: STR
50819: PUSH
50820: LD_STRING , 
50822: STR
50823: PUSH
50824: LD_VAR 0 3
50828: PPUSH
50829: LD_INT 2
50831: PPUSH
50832: CALL_OW 268
50836: STR
50837: PUSH
50838: LD_STRING ],
50840: STR
50841: PPUSH
50842: CALL_OW 561
// end ;
50846: GO 50740
50848: POP
50849: POP
// AddToLog ( ]; ) ;
50850: LD_STRING ];
50852: PPUSH
50853: CALL_OW 561
// end ;
50857: LD_VAR 0 2
50861: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50862: LD_INT 0
50864: PPUSH
50865: PPUSH
50866: PPUSH
50867: PPUSH
50868: PPUSH
// if not area or not rate or not max then
50869: LD_VAR 0 1
50873: NOT
50874: PUSH
50875: LD_VAR 0 2
50879: NOT
50880: OR
50881: PUSH
50882: LD_VAR 0 4
50886: NOT
50887: OR
50888: IFFALSE 50892
// exit ;
50890: GO 51084
// while 1 do
50892: LD_INT 1
50894: IFFALSE 51084
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50896: LD_ADDR_VAR 0 9
50900: PUSH
50901: LD_VAR 0 1
50905: PPUSH
50906: LD_INT 1
50908: PPUSH
50909: CALL_OW 287
50913: PUSH
50914: LD_INT 10
50916: MUL
50917: ST_TO_ADDR
// r := rate / 10 ;
50918: LD_ADDR_VAR 0 7
50922: PUSH
50923: LD_VAR 0 2
50927: PUSH
50928: LD_INT 10
50930: DIVREAL
50931: ST_TO_ADDR
// time := 1 1$00 ;
50932: LD_ADDR_VAR 0 8
50936: PUSH
50937: LD_INT 2100
50939: ST_TO_ADDR
// if amount < min then
50940: LD_VAR 0 9
50944: PUSH
50945: LD_VAR 0 3
50949: LESS
50950: IFFALSE 50968
// r := r * 2 else
50952: LD_ADDR_VAR 0 7
50956: PUSH
50957: LD_VAR 0 7
50961: PUSH
50962: LD_INT 2
50964: MUL
50965: ST_TO_ADDR
50966: GO 50994
// if amount > max then
50968: LD_VAR 0 9
50972: PUSH
50973: LD_VAR 0 4
50977: GREATER
50978: IFFALSE 50994
// r := r / 2 ;
50980: LD_ADDR_VAR 0 7
50984: PUSH
50985: LD_VAR 0 7
50989: PUSH
50990: LD_INT 2
50992: DIVREAL
50993: ST_TO_ADDR
// time := time / r ;
50994: LD_ADDR_VAR 0 8
50998: PUSH
50999: LD_VAR 0 8
51003: PUSH
51004: LD_VAR 0 7
51008: DIVREAL
51009: ST_TO_ADDR
// if time < 0 then
51010: LD_VAR 0 8
51014: PUSH
51015: LD_INT 0
51017: LESS
51018: IFFALSE 51035
// time := time * - 1 ;
51020: LD_ADDR_VAR 0 8
51024: PUSH
51025: LD_VAR 0 8
51029: PUSH
51030: LD_INT 1
51032: NEG
51033: MUL
51034: ST_TO_ADDR
// wait ( time ) ;
51035: LD_VAR 0 8
51039: PPUSH
51040: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
51044: LD_INT 35
51046: PPUSH
51047: LD_INT 875
51049: PPUSH
51050: CALL_OW 12
51054: PPUSH
51055: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51059: LD_INT 1
51061: PPUSH
51062: LD_INT 5
51064: PPUSH
51065: CALL_OW 12
51069: PPUSH
51070: LD_VAR 0 1
51074: PPUSH
51075: LD_INT 1
51077: PPUSH
51078: CALL_OW 55
// end ;
51082: GO 50892
// end ;
51084: LD_VAR 0 5
51088: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51089: LD_INT 0
51091: PPUSH
51092: PPUSH
51093: PPUSH
51094: PPUSH
51095: PPUSH
51096: PPUSH
51097: PPUSH
51098: PPUSH
// if not turrets or not factories then
51099: LD_VAR 0 1
51103: NOT
51104: PUSH
51105: LD_VAR 0 2
51109: NOT
51110: OR
51111: IFFALSE 51115
// exit ;
51113: GO 51422
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51115: LD_ADDR_VAR 0 10
51119: PUSH
51120: LD_INT 5
51122: PUSH
51123: LD_INT 6
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: PUSH
51130: LD_INT 2
51132: PUSH
51133: LD_INT 4
51135: PUSH
51136: EMPTY
51137: LIST
51138: LIST
51139: PUSH
51140: LD_INT 3
51142: PUSH
51143: LD_INT 5
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: PUSH
51150: EMPTY
51151: LIST
51152: LIST
51153: LIST
51154: PUSH
51155: LD_INT 24
51157: PUSH
51158: LD_INT 25
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: PUSH
51165: LD_INT 23
51167: PUSH
51168: LD_INT 27
51170: PUSH
51171: EMPTY
51172: LIST
51173: LIST
51174: PUSH
51175: EMPTY
51176: LIST
51177: LIST
51178: PUSH
51179: LD_INT 42
51181: PUSH
51182: LD_INT 43
51184: PUSH
51185: EMPTY
51186: LIST
51187: LIST
51188: PUSH
51189: LD_INT 44
51191: PUSH
51192: LD_INT 46
51194: PUSH
51195: EMPTY
51196: LIST
51197: LIST
51198: PUSH
51199: LD_INT 45
51201: PUSH
51202: LD_INT 47
51204: PUSH
51205: EMPTY
51206: LIST
51207: LIST
51208: PUSH
51209: EMPTY
51210: LIST
51211: LIST
51212: LIST
51213: PUSH
51214: EMPTY
51215: LIST
51216: LIST
51217: LIST
51218: ST_TO_ADDR
// result := [ ] ;
51219: LD_ADDR_VAR 0 3
51223: PUSH
51224: EMPTY
51225: ST_TO_ADDR
// for i in turrets do
51226: LD_ADDR_VAR 0 4
51230: PUSH
51231: LD_VAR 0 1
51235: PUSH
51236: FOR_IN
51237: IFFALSE 51420
// begin nat := GetNation ( i ) ;
51239: LD_ADDR_VAR 0 7
51243: PUSH
51244: LD_VAR 0 4
51248: PPUSH
51249: CALL_OW 248
51253: ST_TO_ADDR
// weapon := 0 ;
51254: LD_ADDR_VAR 0 8
51258: PUSH
51259: LD_INT 0
51261: ST_TO_ADDR
// if not nat then
51262: LD_VAR 0 7
51266: NOT
51267: IFFALSE 51271
// continue ;
51269: GO 51236
// for j in list [ nat ] do
51271: LD_ADDR_VAR 0 5
51275: PUSH
51276: LD_VAR 0 10
51280: PUSH
51281: LD_VAR 0 7
51285: ARRAY
51286: PUSH
51287: FOR_IN
51288: IFFALSE 51329
// if GetBWeapon ( i ) = j [ 1 ] then
51290: LD_VAR 0 4
51294: PPUSH
51295: CALL_OW 269
51299: PUSH
51300: LD_VAR 0 5
51304: PUSH
51305: LD_INT 1
51307: ARRAY
51308: EQUAL
51309: IFFALSE 51327
// begin weapon := j [ 2 ] ;
51311: LD_ADDR_VAR 0 8
51315: PUSH
51316: LD_VAR 0 5
51320: PUSH
51321: LD_INT 2
51323: ARRAY
51324: ST_TO_ADDR
// break ;
51325: GO 51329
// end ;
51327: GO 51287
51329: POP
51330: POP
// if not weapon then
51331: LD_VAR 0 8
51335: NOT
51336: IFFALSE 51340
// continue ;
51338: GO 51236
// for k in factories do
51340: LD_ADDR_VAR 0 6
51344: PUSH
51345: LD_VAR 0 2
51349: PUSH
51350: FOR_IN
51351: IFFALSE 51416
// begin weapons := AvailableWeaponList ( k ) ;
51353: LD_ADDR_VAR 0 9
51357: PUSH
51358: LD_VAR 0 6
51362: PPUSH
51363: CALL_OW 478
51367: ST_TO_ADDR
// if not weapons then
51368: LD_VAR 0 9
51372: NOT
51373: IFFALSE 51377
// continue ;
51375: GO 51350
// if weapon in weapons then
51377: LD_VAR 0 8
51381: PUSH
51382: LD_VAR 0 9
51386: IN
51387: IFFALSE 51414
// begin result := [ i , weapon ] ;
51389: LD_ADDR_VAR 0 3
51393: PUSH
51394: LD_VAR 0 4
51398: PUSH
51399: LD_VAR 0 8
51403: PUSH
51404: EMPTY
51405: LIST
51406: LIST
51407: ST_TO_ADDR
// exit ;
51408: POP
51409: POP
51410: POP
51411: POP
51412: GO 51422
// end ; end ;
51414: GO 51350
51416: POP
51417: POP
// end ;
51418: GO 51236
51420: POP
51421: POP
// end ;
51422: LD_VAR 0 3
51426: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51427: LD_INT 0
51429: PPUSH
// if not side or side > 8 then
51430: LD_VAR 0 3
51434: NOT
51435: PUSH
51436: LD_VAR 0 3
51440: PUSH
51441: LD_INT 8
51443: GREATER
51444: OR
51445: IFFALSE 51449
// exit ;
51447: GO 51508
// if not range then
51449: LD_VAR 0 4
51453: NOT
51454: IFFALSE 51465
// range := - 12 ;
51456: LD_ADDR_VAR 0 4
51460: PUSH
51461: LD_INT 12
51463: NEG
51464: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51465: LD_VAR 0 1
51469: PPUSH
51470: LD_VAR 0 2
51474: PPUSH
51475: LD_VAR 0 3
51479: PPUSH
51480: LD_VAR 0 4
51484: PPUSH
51485: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51489: LD_VAR 0 1
51493: PPUSH
51494: LD_VAR 0 2
51498: PPUSH
51499: LD_VAR 0 3
51503: PPUSH
51504: CALL_OW 331
// end ;
51508: LD_VAR 0 5
51512: RET
// export function Video ( mode ) ; begin
51513: LD_INT 0
51515: PPUSH
// ingame_video = mode ;
51516: LD_ADDR_OWVAR 52
51520: PUSH
51521: LD_VAR 0 1
51525: ST_TO_ADDR
// interface_hidden = mode ;
51526: LD_ADDR_OWVAR 54
51530: PUSH
51531: LD_VAR 0 1
51535: ST_TO_ADDR
// end ;
51536: LD_VAR 0 2
51540: RET
// export function Join ( array , element ) ; begin
51541: LD_INT 0
51543: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51544: LD_ADDR_VAR 0 3
51548: PUSH
51549: LD_VAR 0 1
51553: PPUSH
51554: LD_VAR 0 1
51558: PUSH
51559: LD_INT 1
51561: PLUS
51562: PPUSH
51563: LD_VAR 0 2
51567: PPUSH
51568: CALL_OW 1
51572: ST_TO_ADDR
// end ;
51573: LD_VAR 0 3
51577: RET
// export function JoinUnion ( array , element ) ; begin
51578: LD_INT 0
51580: PPUSH
// result := array union element ;
51581: LD_ADDR_VAR 0 3
51585: PUSH
51586: LD_VAR 0 1
51590: PUSH
51591: LD_VAR 0 2
51595: UNION
51596: ST_TO_ADDR
// end ;
51597: LD_VAR 0 3
51601: RET
// export function GetBehemoths ( side ) ; begin
51602: LD_INT 0
51604: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51605: LD_ADDR_VAR 0 2
51609: PUSH
51610: LD_INT 22
51612: PUSH
51613: LD_VAR 0 1
51617: PUSH
51618: EMPTY
51619: LIST
51620: LIST
51621: PUSH
51622: LD_INT 31
51624: PUSH
51625: LD_INT 25
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: PUSH
51632: EMPTY
51633: LIST
51634: LIST
51635: PPUSH
51636: CALL_OW 69
51640: ST_TO_ADDR
// end ;
51641: LD_VAR 0 2
51645: RET
// export function Shuffle ( array ) ; var i , index ; begin
51646: LD_INT 0
51648: PPUSH
51649: PPUSH
51650: PPUSH
// result := [ ] ;
51651: LD_ADDR_VAR 0 2
51655: PUSH
51656: EMPTY
51657: ST_TO_ADDR
// if not array then
51658: LD_VAR 0 1
51662: NOT
51663: IFFALSE 51667
// exit ;
51665: GO 51766
// Randomize ;
51667: CALL_OW 10
// for i = array downto 1 do
51671: LD_ADDR_VAR 0 3
51675: PUSH
51676: DOUBLE
51677: LD_VAR 0 1
51681: INC
51682: ST_TO_ADDR
51683: LD_INT 1
51685: PUSH
51686: FOR_DOWNTO
51687: IFFALSE 51764
// begin index := rand ( 1 , array ) ;
51689: LD_ADDR_VAR 0 4
51693: PUSH
51694: LD_INT 1
51696: PPUSH
51697: LD_VAR 0 1
51701: PPUSH
51702: CALL_OW 12
51706: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51707: LD_ADDR_VAR 0 2
51711: PUSH
51712: LD_VAR 0 2
51716: PPUSH
51717: LD_VAR 0 2
51721: PUSH
51722: LD_INT 1
51724: PLUS
51725: PPUSH
51726: LD_VAR 0 1
51730: PUSH
51731: LD_VAR 0 4
51735: ARRAY
51736: PPUSH
51737: CALL_OW 2
51741: ST_TO_ADDR
// array := Delete ( array , index ) ;
51742: LD_ADDR_VAR 0 1
51746: PUSH
51747: LD_VAR 0 1
51751: PPUSH
51752: LD_VAR 0 4
51756: PPUSH
51757: CALL_OW 3
51761: ST_TO_ADDR
// end ;
51762: GO 51686
51764: POP
51765: POP
// end ;
51766: LD_VAR 0 2
51770: RET
// export function GetBaseMaterials ( base ) ; begin
51771: LD_INT 0
51773: PPUSH
// result := [ 0 , 0 , 0 ] ;
51774: LD_ADDR_VAR 0 2
51778: PUSH
51779: LD_INT 0
51781: PUSH
51782: LD_INT 0
51784: PUSH
51785: LD_INT 0
51787: PUSH
51788: EMPTY
51789: LIST
51790: LIST
51791: LIST
51792: ST_TO_ADDR
// if not base then
51793: LD_VAR 0 1
51797: NOT
51798: IFFALSE 51802
// exit ;
51800: GO 51851
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51802: LD_ADDR_VAR 0 2
51806: PUSH
51807: LD_VAR 0 1
51811: PPUSH
51812: LD_INT 1
51814: PPUSH
51815: CALL_OW 275
51819: PUSH
51820: LD_VAR 0 1
51824: PPUSH
51825: LD_INT 2
51827: PPUSH
51828: CALL_OW 275
51832: PUSH
51833: LD_VAR 0 1
51837: PPUSH
51838: LD_INT 3
51840: PPUSH
51841: CALL_OW 275
51845: PUSH
51846: EMPTY
51847: LIST
51848: LIST
51849: LIST
51850: ST_TO_ADDR
// end ;
51851: LD_VAR 0 2
51855: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51856: LD_INT 0
51858: PPUSH
51859: PPUSH
// result := array ;
51860: LD_ADDR_VAR 0 3
51864: PUSH
51865: LD_VAR 0 1
51869: ST_TO_ADDR
// if size > 0 then
51870: LD_VAR 0 2
51874: PUSH
51875: LD_INT 0
51877: GREATER
51878: IFFALSE 51924
// for i := array downto size do
51880: LD_ADDR_VAR 0 4
51884: PUSH
51885: DOUBLE
51886: LD_VAR 0 1
51890: INC
51891: ST_TO_ADDR
51892: LD_VAR 0 2
51896: PUSH
51897: FOR_DOWNTO
51898: IFFALSE 51922
// result := Delete ( result , result ) ;
51900: LD_ADDR_VAR 0 3
51904: PUSH
51905: LD_VAR 0 3
51909: PPUSH
51910: LD_VAR 0 3
51914: PPUSH
51915: CALL_OW 3
51919: ST_TO_ADDR
51920: GO 51897
51922: POP
51923: POP
// end ;
51924: LD_VAR 0 3
51928: RET
// export function ComExit ( unit ) ; var tmp ; begin
51929: LD_INT 0
51931: PPUSH
51932: PPUSH
// if not IsInUnit ( unit ) then
51933: LD_VAR 0 1
51937: PPUSH
51938: CALL_OW 310
51942: NOT
51943: IFFALSE 51947
// exit ;
51945: GO 52007
// tmp := IsInUnit ( unit ) ;
51947: LD_ADDR_VAR 0 3
51951: PUSH
51952: LD_VAR 0 1
51956: PPUSH
51957: CALL_OW 310
51961: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51962: LD_VAR 0 3
51966: PPUSH
51967: CALL_OW 247
51971: PUSH
51972: LD_INT 2
51974: EQUAL
51975: IFFALSE 51988
// ComExitVehicle ( unit ) else
51977: LD_VAR 0 1
51981: PPUSH
51982: CALL_OW 121
51986: GO 51997
// ComExitBuilding ( unit ) ;
51988: LD_VAR 0 1
51992: PPUSH
51993: CALL_OW 122
// result := tmp ;
51997: LD_ADDR_VAR 0 2
52001: PUSH
52002: LD_VAR 0 3
52006: ST_TO_ADDR
// end ;
52007: LD_VAR 0 2
52011: RET
// export function ComExitAll ( units ) ; var i ; begin
52012: LD_INT 0
52014: PPUSH
52015: PPUSH
// if not units then
52016: LD_VAR 0 1
52020: NOT
52021: IFFALSE 52025
// exit ;
52023: GO 52051
// for i in units do
52025: LD_ADDR_VAR 0 3
52029: PUSH
52030: LD_VAR 0 1
52034: PUSH
52035: FOR_IN
52036: IFFALSE 52049
// ComExit ( i ) ;
52038: LD_VAR 0 3
52042: PPUSH
52043: CALL 51929 0 1
52047: GO 52035
52049: POP
52050: POP
// end ;
52051: LD_VAR 0 2
52055: RET
// export function ResetHc ; begin
52056: LD_INT 0
52058: PPUSH
// InitHc ;
52059: CALL_OW 19
// hc_importance := 0 ;
52063: LD_ADDR_OWVAR 32
52067: PUSH
52068: LD_INT 0
52070: ST_TO_ADDR
// end ;
52071: LD_VAR 0 1
52075: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52076: LD_INT 0
52078: PPUSH
52079: PPUSH
52080: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52081: LD_ADDR_VAR 0 6
52085: PUSH
52086: LD_VAR 0 1
52090: PUSH
52091: LD_VAR 0 3
52095: PLUS
52096: PUSH
52097: LD_INT 2
52099: DIV
52100: ST_TO_ADDR
// if _x < 0 then
52101: LD_VAR 0 6
52105: PUSH
52106: LD_INT 0
52108: LESS
52109: IFFALSE 52126
// _x := _x * - 1 ;
52111: LD_ADDR_VAR 0 6
52115: PUSH
52116: LD_VAR 0 6
52120: PUSH
52121: LD_INT 1
52123: NEG
52124: MUL
52125: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52126: LD_ADDR_VAR 0 7
52130: PUSH
52131: LD_VAR 0 2
52135: PUSH
52136: LD_VAR 0 4
52140: PLUS
52141: PUSH
52142: LD_INT 2
52144: DIV
52145: ST_TO_ADDR
// if _y < 0 then
52146: LD_VAR 0 7
52150: PUSH
52151: LD_INT 0
52153: LESS
52154: IFFALSE 52171
// _y := _y * - 1 ;
52156: LD_ADDR_VAR 0 7
52160: PUSH
52161: LD_VAR 0 7
52165: PUSH
52166: LD_INT 1
52168: NEG
52169: MUL
52170: ST_TO_ADDR
// result := [ _x , _y ] ;
52171: LD_ADDR_VAR 0 5
52175: PUSH
52176: LD_VAR 0 6
52180: PUSH
52181: LD_VAR 0 7
52185: PUSH
52186: EMPTY
52187: LIST
52188: LIST
52189: ST_TO_ADDR
// end ;
52190: LD_VAR 0 5
52194: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52195: LD_INT 0
52197: PPUSH
52198: PPUSH
52199: PPUSH
52200: PPUSH
// task := GetTaskList ( unit ) ;
52201: LD_ADDR_VAR 0 7
52205: PUSH
52206: LD_VAR 0 1
52210: PPUSH
52211: CALL_OW 437
52215: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52216: LD_VAR 0 7
52220: NOT
52221: PUSH
52222: LD_VAR 0 1
52226: PPUSH
52227: LD_VAR 0 2
52231: PPUSH
52232: CALL_OW 308
52236: NOT
52237: AND
52238: IFFALSE 52242
// exit ;
52240: GO 52360
// if IsInArea ( unit , area ) then
52242: LD_VAR 0 1
52246: PPUSH
52247: LD_VAR 0 2
52251: PPUSH
52252: CALL_OW 308
52256: IFFALSE 52274
// begin ComMoveToArea ( unit , goAway ) ;
52258: LD_VAR 0 1
52262: PPUSH
52263: LD_VAR 0 3
52267: PPUSH
52268: CALL_OW 113
// exit ;
52272: GO 52360
// end ; if task [ 1 ] [ 1 ] <> M then
52274: LD_VAR 0 7
52278: PUSH
52279: LD_INT 1
52281: ARRAY
52282: PUSH
52283: LD_INT 1
52285: ARRAY
52286: PUSH
52287: LD_STRING M
52289: NONEQUAL
52290: IFFALSE 52294
// exit ;
52292: GO 52360
// x := task [ 1 ] [ 2 ] ;
52294: LD_ADDR_VAR 0 5
52298: PUSH
52299: LD_VAR 0 7
52303: PUSH
52304: LD_INT 1
52306: ARRAY
52307: PUSH
52308: LD_INT 2
52310: ARRAY
52311: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52312: LD_ADDR_VAR 0 6
52316: PUSH
52317: LD_VAR 0 7
52321: PUSH
52322: LD_INT 1
52324: ARRAY
52325: PUSH
52326: LD_INT 3
52328: ARRAY
52329: ST_TO_ADDR
// if InArea ( x , y , area ) then
52330: LD_VAR 0 5
52334: PPUSH
52335: LD_VAR 0 6
52339: PPUSH
52340: LD_VAR 0 2
52344: PPUSH
52345: CALL_OW 309
52349: IFFALSE 52360
// ComStop ( unit ) ;
52351: LD_VAR 0 1
52355: PPUSH
52356: CALL_OW 141
// end ;
52360: LD_VAR 0 4
52364: RET
// export function Abs ( value ) ; begin
52365: LD_INT 0
52367: PPUSH
// result := value ;
52368: LD_ADDR_VAR 0 2
52372: PUSH
52373: LD_VAR 0 1
52377: ST_TO_ADDR
// if value < 0 then
52378: LD_VAR 0 1
52382: PUSH
52383: LD_INT 0
52385: LESS
52386: IFFALSE 52403
// result := value * - 1 ;
52388: LD_ADDR_VAR 0 2
52392: PUSH
52393: LD_VAR 0 1
52397: PUSH
52398: LD_INT 1
52400: NEG
52401: MUL
52402: ST_TO_ADDR
// end ;
52403: LD_VAR 0 2
52407: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52408: LD_INT 0
52410: PPUSH
52411: PPUSH
52412: PPUSH
52413: PPUSH
52414: PPUSH
52415: PPUSH
52416: PPUSH
52417: PPUSH
// if not unit or not building then
52418: LD_VAR 0 1
52422: NOT
52423: PUSH
52424: LD_VAR 0 2
52428: NOT
52429: OR
52430: IFFALSE 52434
// exit ;
52432: GO 52660
// x := GetX ( building ) ;
52434: LD_ADDR_VAR 0 4
52438: PUSH
52439: LD_VAR 0 2
52443: PPUSH
52444: CALL_OW 250
52448: ST_TO_ADDR
// y := GetY ( building ) ;
52449: LD_ADDR_VAR 0 6
52453: PUSH
52454: LD_VAR 0 2
52458: PPUSH
52459: CALL_OW 251
52463: ST_TO_ADDR
// d := GetDir ( building ) ;
52464: LD_ADDR_VAR 0 8
52468: PUSH
52469: LD_VAR 0 2
52473: PPUSH
52474: CALL_OW 254
52478: ST_TO_ADDR
// r := 4 ;
52479: LD_ADDR_VAR 0 9
52483: PUSH
52484: LD_INT 4
52486: ST_TO_ADDR
// for i := 1 to 5 do
52487: LD_ADDR_VAR 0 10
52491: PUSH
52492: DOUBLE
52493: LD_INT 1
52495: DEC
52496: ST_TO_ADDR
52497: LD_INT 5
52499: PUSH
52500: FOR_TO
52501: IFFALSE 52658
// begin _x := ShiftX ( x , d , r + i ) ;
52503: LD_ADDR_VAR 0 5
52507: PUSH
52508: LD_VAR 0 4
52512: PPUSH
52513: LD_VAR 0 8
52517: PPUSH
52518: LD_VAR 0 9
52522: PUSH
52523: LD_VAR 0 10
52527: PLUS
52528: PPUSH
52529: CALL_OW 272
52533: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52534: LD_ADDR_VAR 0 7
52538: PUSH
52539: LD_VAR 0 6
52543: PPUSH
52544: LD_VAR 0 8
52548: PPUSH
52549: LD_VAR 0 9
52553: PUSH
52554: LD_VAR 0 10
52558: PLUS
52559: PPUSH
52560: CALL_OW 273
52564: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52565: LD_VAR 0 5
52569: PPUSH
52570: LD_VAR 0 7
52574: PPUSH
52575: CALL_OW 488
52579: PUSH
52580: LD_VAR 0 5
52584: PPUSH
52585: LD_VAR 0 7
52589: PPUSH
52590: CALL_OW 428
52594: PPUSH
52595: CALL_OW 247
52599: PUSH
52600: LD_INT 3
52602: PUSH
52603: LD_INT 2
52605: PUSH
52606: EMPTY
52607: LIST
52608: LIST
52609: IN
52610: NOT
52611: AND
52612: IFFALSE 52656
// begin ComMoveXY ( unit , _x , _y ) ;
52614: LD_VAR 0 1
52618: PPUSH
52619: LD_VAR 0 5
52623: PPUSH
52624: LD_VAR 0 7
52628: PPUSH
52629: CALL_OW 111
// result := [ _x , _y ] ;
52633: LD_ADDR_VAR 0 3
52637: PUSH
52638: LD_VAR 0 5
52642: PUSH
52643: LD_VAR 0 7
52647: PUSH
52648: EMPTY
52649: LIST
52650: LIST
52651: ST_TO_ADDR
// exit ;
52652: POP
52653: POP
52654: GO 52660
// end ; end ;
52656: GO 52500
52658: POP
52659: POP
// end ;
52660: LD_VAR 0 3
52664: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52665: LD_INT 0
52667: PPUSH
52668: PPUSH
52669: PPUSH
// result := 0 ;
52670: LD_ADDR_VAR 0 3
52674: PUSH
52675: LD_INT 0
52677: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52678: LD_VAR 0 1
52682: PUSH
52683: LD_INT 0
52685: LESS
52686: PUSH
52687: LD_VAR 0 1
52691: PUSH
52692: LD_INT 8
52694: GREATER
52695: OR
52696: PUSH
52697: LD_VAR 0 2
52701: PUSH
52702: LD_INT 0
52704: LESS
52705: OR
52706: PUSH
52707: LD_VAR 0 2
52711: PUSH
52712: LD_INT 8
52714: GREATER
52715: OR
52716: IFFALSE 52720
// exit ;
52718: GO 52795
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52720: LD_ADDR_VAR 0 4
52724: PUSH
52725: LD_INT 22
52727: PUSH
52728: LD_VAR 0 2
52732: PUSH
52733: EMPTY
52734: LIST
52735: LIST
52736: PPUSH
52737: CALL_OW 69
52741: PUSH
52742: FOR_IN
52743: IFFALSE 52793
// begin un := UnitShoot ( i ) ;
52745: LD_ADDR_VAR 0 5
52749: PUSH
52750: LD_VAR 0 4
52754: PPUSH
52755: CALL_OW 504
52759: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52760: LD_VAR 0 5
52764: PPUSH
52765: CALL_OW 255
52769: PUSH
52770: LD_VAR 0 1
52774: EQUAL
52775: IFFALSE 52791
// begin result := un ;
52777: LD_ADDR_VAR 0 3
52781: PUSH
52782: LD_VAR 0 5
52786: ST_TO_ADDR
// exit ;
52787: POP
52788: POP
52789: GO 52795
// end ; end ;
52791: GO 52742
52793: POP
52794: POP
// end ;
52795: LD_VAR 0 3
52799: RET
// export function GetCargoBay ( units ) ; begin
52800: LD_INT 0
52802: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52803: LD_ADDR_VAR 0 2
52807: PUSH
52808: LD_VAR 0 1
52812: PPUSH
52813: LD_INT 2
52815: PUSH
52816: LD_INT 34
52818: PUSH
52819: LD_INT 12
52821: PUSH
52822: EMPTY
52823: LIST
52824: LIST
52825: PUSH
52826: LD_INT 34
52828: PUSH
52829: LD_INT 51
52831: PUSH
52832: EMPTY
52833: LIST
52834: LIST
52835: PUSH
52836: LD_INT 34
52838: PUSH
52839: LD_INT 32
52841: PUSH
52842: EMPTY
52843: LIST
52844: LIST
52845: PUSH
52846: LD_INT 34
52848: PUSH
52849: LD_EXP 104
52853: PUSH
52854: EMPTY
52855: LIST
52856: LIST
52857: PUSH
52858: EMPTY
52859: LIST
52860: LIST
52861: LIST
52862: LIST
52863: LIST
52864: PPUSH
52865: CALL_OW 72
52869: ST_TO_ADDR
// end ;
52870: LD_VAR 0 2
52874: RET
// export function Negate ( value ) ; begin
52875: LD_INT 0
52877: PPUSH
// result := not value ;
52878: LD_ADDR_VAR 0 2
52882: PUSH
52883: LD_VAR 0 1
52887: NOT
52888: ST_TO_ADDR
// end ;
52889: LD_VAR 0 2
52893: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
52894: LD_INT 0
52896: PPUSH
// if x1 = x2 then
52897: LD_VAR 0 1
52901: PUSH
52902: LD_VAR 0 3
52906: EQUAL
52907: IFFALSE 52941
// begin if y1 > y2 then
52909: LD_VAR 0 2
52913: PUSH
52914: LD_VAR 0 4
52918: GREATER
52919: IFFALSE 52931
// result := 0 else
52921: LD_ADDR_VAR 0 5
52925: PUSH
52926: LD_INT 0
52928: ST_TO_ADDR
52929: GO 52939
// result := 3 ;
52931: LD_ADDR_VAR 0 5
52935: PUSH
52936: LD_INT 3
52938: ST_TO_ADDR
// exit ;
52939: GO 53027
// end ; if y1 = y2 then
52941: LD_VAR 0 2
52945: PUSH
52946: LD_VAR 0 4
52950: EQUAL
52951: IFFALSE 52985
// begin if x1 > x2 then
52953: LD_VAR 0 1
52957: PUSH
52958: LD_VAR 0 3
52962: GREATER
52963: IFFALSE 52975
// result := 1 else
52965: LD_ADDR_VAR 0 5
52969: PUSH
52970: LD_INT 1
52972: ST_TO_ADDR
52973: GO 52983
// result := 4 ;
52975: LD_ADDR_VAR 0 5
52979: PUSH
52980: LD_INT 4
52982: ST_TO_ADDR
// exit ;
52983: GO 53027
// end ; if x1 > x2 and y1 > y2 then
52985: LD_VAR 0 1
52989: PUSH
52990: LD_VAR 0 3
52994: GREATER
52995: PUSH
52996: LD_VAR 0 2
53000: PUSH
53001: LD_VAR 0 4
53005: GREATER
53006: AND
53007: IFFALSE 53019
// result := 2 else
53009: LD_ADDR_VAR 0 5
53013: PUSH
53014: LD_INT 2
53016: ST_TO_ADDR
53017: GO 53027
// result := 5 ;
53019: LD_ADDR_VAR 0 5
53023: PUSH
53024: LD_INT 5
53026: ST_TO_ADDR
// end ;
53027: LD_VAR 0 5
53031: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53032: LD_INT 0
53034: PPUSH
53035: PPUSH
// if not driver or not IsInUnit ( driver ) then
53036: LD_VAR 0 1
53040: NOT
53041: PUSH
53042: LD_VAR 0 1
53046: PPUSH
53047: CALL_OW 310
53051: NOT
53052: OR
53053: IFFALSE 53057
// exit ;
53055: GO 53147
// vehicle := IsInUnit ( driver ) ;
53057: LD_ADDR_VAR 0 3
53061: PUSH
53062: LD_VAR 0 1
53066: PPUSH
53067: CALL_OW 310
53071: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53072: LD_VAR 0 1
53076: PPUSH
53077: LD_STRING \
53079: PUSH
53080: LD_INT 0
53082: PUSH
53083: LD_INT 0
53085: PUSH
53086: LD_INT 0
53088: PUSH
53089: LD_INT 0
53091: PUSH
53092: LD_INT 0
53094: PUSH
53095: LD_INT 0
53097: PUSH
53098: EMPTY
53099: LIST
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: LIST
53105: LIST
53106: PUSH
53107: LD_STRING E
53109: PUSH
53110: LD_INT 0
53112: PUSH
53113: LD_INT 0
53115: PUSH
53116: LD_VAR 0 3
53120: PUSH
53121: LD_INT 0
53123: PUSH
53124: LD_INT 0
53126: PUSH
53127: LD_INT 0
53129: PUSH
53130: EMPTY
53131: LIST
53132: LIST
53133: LIST
53134: LIST
53135: LIST
53136: LIST
53137: LIST
53138: PUSH
53139: EMPTY
53140: LIST
53141: LIST
53142: PPUSH
53143: CALL_OW 446
// end ;
53147: LD_VAR 0 2
53151: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53152: LD_INT 0
53154: PPUSH
53155: PPUSH
// if not driver or not IsInUnit ( driver ) then
53156: LD_VAR 0 1
53160: NOT
53161: PUSH
53162: LD_VAR 0 1
53166: PPUSH
53167: CALL_OW 310
53171: NOT
53172: OR
53173: IFFALSE 53177
// exit ;
53175: GO 53267
// vehicle := IsInUnit ( driver ) ;
53177: LD_ADDR_VAR 0 3
53181: PUSH
53182: LD_VAR 0 1
53186: PPUSH
53187: CALL_OW 310
53191: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53192: LD_VAR 0 1
53196: PPUSH
53197: LD_STRING \
53199: PUSH
53200: LD_INT 0
53202: PUSH
53203: LD_INT 0
53205: PUSH
53206: LD_INT 0
53208: PUSH
53209: LD_INT 0
53211: PUSH
53212: LD_INT 0
53214: PUSH
53215: LD_INT 0
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: LIST
53222: LIST
53223: LIST
53224: LIST
53225: LIST
53226: PUSH
53227: LD_STRING E
53229: PUSH
53230: LD_INT 0
53232: PUSH
53233: LD_INT 0
53235: PUSH
53236: LD_VAR 0 3
53240: PUSH
53241: LD_INT 0
53243: PUSH
53244: LD_INT 0
53246: PUSH
53247: LD_INT 0
53249: PUSH
53250: EMPTY
53251: LIST
53252: LIST
53253: LIST
53254: LIST
53255: LIST
53256: LIST
53257: LIST
53258: PUSH
53259: EMPTY
53260: LIST
53261: LIST
53262: PPUSH
53263: CALL_OW 447
// end ;
53267: LD_VAR 0 2
53271: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53272: LD_INT 0
53274: PPUSH
53275: PPUSH
53276: PPUSH
// tmp := [ ] ;
53277: LD_ADDR_VAR 0 5
53281: PUSH
53282: EMPTY
53283: ST_TO_ADDR
// for i in units do
53284: LD_ADDR_VAR 0 4
53288: PUSH
53289: LD_VAR 0 1
53293: PUSH
53294: FOR_IN
53295: IFFALSE 53333
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53297: LD_ADDR_VAR 0 5
53301: PUSH
53302: LD_VAR 0 5
53306: PPUSH
53307: LD_VAR 0 5
53311: PUSH
53312: LD_INT 1
53314: PLUS
53315: PPUSH
53316: LD_VAR 0 4
53320: PPUSH
53321: CALL_OW 256
53325: PPUSH
53326: CALL_OW 2
53330: ST_TO_ADDR
53331: GO 53294
53333: POP
53334: POP
// if not tmp then
53335: LD_VAR 0 5
53339: NOT
53340: IFFALSE 53344
// exit ;
53342: GO 53392
// if asc then
53344: LD_VAR 0 2
53348: IFFALSE 53372
// result := SortListByListAsc ( units , tmp ) else
53350: LD_ADDR_VAR 0 3
53354: PUSH
53355: LD_VAR 0 1
53359: PPUSH
53360: LD_VAR 0 5
53364: PPUSH
53365: CALL_OW 76
53369: ST_TO_ADDR
53370: GO 53392
// result := SortListByListDesc ( units , tmp ) ;
53372: LD_ADDR_VAR 0 3
53376: PUSH
53377: LD_VAR 0 1
53381: PPUSH
53382: LD_VAR 0 5
53386: PPUSH
53387: CALL_OW 77
53391: ST_TO_ADDR
// end ;
53392: LD_VAR 0 3
53396: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53397: LD_INT 0
53399: PPUSH
53400: PPUSH
// task := GetTaskList ( mech ) ;
53401: LD_ADDR_VAR 0 4
53405: PUSH
53406: LD_VAR 0 1
53410: PPUSH
53411: CALL_OW 437
53415: ST_TO_ADDR
// if not task then
53416: LD_VAR 0 4
53420: NOT
53421: IFFALSE 53425
// exit ;
53423: GO 53467
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53425: LD_ADDR_VAR 0 3
53429: PUSH
53430: LD_VAR 0 4
53434: PUSH
53435: LD_INT 1
53437: ARRAY
53438: PUSH
53439: LD_INT 1
53441: ARRAY
53442: PUSH
53443: LD_STRING r
53445: EQUAL
53446: PUSH
53447: LD_VAR 0 4
53451: PUSH
53452: LD_INT 1
53454: ARRAY
53455: PUSH
53456: LD_INT 4
53458: ARRAY
53459: PUSH
53460: LD_VAR 0 2
53464: EQUAL
53465: AND
53466: ST_TO_ADDR
// end ;
53467: LD_VAR 0 3
53471: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53472: LD_INT 0
53474: PPUSH
// SetDir ( unit , d ) ;
53475: LD_VAR 0 1
53479: PPUSH
53480: LD_VAR 0 4
53484: PPUSH
53485: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53489: LD_VAR 0 1
53493: PPUSH
53494: LD_VAR 0 2
53498: PPUSH
53499: LD_VAR 0 3
53503: PPUSH
53504: LD_VAR 0 5
53508: PPUSH
53509: CALL_OW 48
// end ;
53513: LD_VAR 0 6
53517: RET
// export function ToNaturalNumber ( number ) ; begin
53518: LD_INT 0
53520: PPUSH
// result := number div 1 ;
53521: LD_ADDR_VAR 0 2
53525: PUSH
53526: LD_VAR 0 1
53530: PUSH
53531: LD_INT 1
53533: DIV
53534: ST_TO_ADDR
// if number < 0 then
53535: LD_VAR 0 1
53539: PUSH
53540: LD_INT 0
53542: LESS
53543: IFFALSE 53553
// result := 0 ;
53545: LD_ADDR_VAR 0 2
53549: PUSH
53550: LD_INT 0
53552: ST_TO_ADDR
// end ;
53553: LD_VAR 0 2
53557: RET
// export function SortByClass ( units , class ) ; var un ; begin
53558: LD_INT 0
53560: PPUSH
53561: PPUSH
// if not units or not class then
53562: LD_VAR 0 1
53566: NOT
53567: PUSH
53568: LD_VAR 0 2
53572: NOT
53573: OR
53574: IFFALSE 53578
// exit ;
53576: GO 53673
// result := [ ] ;
53578: LD_ADDR_VAR 0 3
53582: PUSH
53583: EMPTY
53584: ST_TO_ADDR
// for un in units do
53585: LD_ADDR_VAR 0 4
53589: PUSH
53590: LD_VAR 0 1
53594: PUSH
53595: FOR_IN
53596: IFFALSE 53671
// if GetClass ( un ) = class then
53598: LD_VAR 0 4
53602: PPUSH
53603: CALL_OW 257
53607: PUSH
53608: LD_VAR 0 2
53612: EQUAL
53613: IFFALSE 53640
// result := Insert ( result , 1 , un ) else
53615: LD_ADDR_VAR 0 3
53619: PUSH
53620: LD_VAR 0 3
53624: PPUSH
53625: LD_INT 1
53627: PPUSH
53628: LD_VAR 0 4
53632: PPUSH
53633: CALL_OW 2
53637: ST_TO_ADDR
53638: GO 53669
// result := Replace ( result , result + 1 , un ) ;
53640: LD_ADDR_VAR 0 3
53644: PUSH
53645: LD_VAR 0 3
53649: PPUSH
53650: LD_VAR 0 3
53654: PUSH
53655: LD_INT 1
53657: PLUS
53658: PPUSH
53659: LD_VAR 0 4
53663: PPUSH
53664: CALL_OW 1
53668: ST_TO_ADDR
53669: GO 53595
53671: POP
53672: POP
// end ;
53673: LD_VAR 0 3
53677: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53678: LD_INT 0
53680: PPUSH
53681: PPUSH
53682: PPUSH
53683: PPUSH
53684: PPUSH
53685: PPUSH
53686: PPUSH
// result := [ ] ;
53687: LD_ADDR_VAR 0 4
53691: PUSH
53692: EMPTY
53693: ST_TO_ADDR
// if x - r < 0 then
53694: LD_VAR 0 1
53698: PUSH
53699: LD_VAR 0 3
53703: MINUS
53704: PUSH
53705: LD_INT 0
53707: LESS
53708: IFFALSE 53720
// min_x := 0 else
53710: LD_ADDR_VAR 0 8
53714: PUSH
53715: LD_INT 0
53717: ST_TO_ADDR
53718: GO 53736
// min_x := x - r ;
53720: LD_ADDR_VAR 0 8
53724: PUSH
53725: LD_VAR 0 1
53729: PUSH
53730: LD_VAR 0 3
53734: MINUS
53735: ST_TO_ADDR
// if y - r < 0 then
53736: LD_VAR 0 2
53740: PUSH
53741: LD_VAR 0 3
53745: MINUS
53746: PUSH
53747: LD_INT 0
53749: LESS
53750: IFFALSE 53762
// min_y := 0 else
53752: LD_ADDR_VAR 0 7
53756: PUSH
53757: LD_INT 0
53759: ST_TO_ADDR
53760: GO 53778
// min_y := y - r ;
53762: LD_ADDR_VAR 0 7
53766: PUSH
53767: LD_VAR 0 2
53771: PUSH
53772: LD_VAR 0 3
53776: MINUS
53777: ST_TO_ADDR
// max_x := x + r ;
53778: LD_ADDR_VAR 0 9
53782: PUSH
53783: LD_VAR 0 1
53787: PUSH
53788: LD_VAR 0 3
53792: PLUS
53793: ST_TO_ADDR
// max_y := y + r ;
53794: LD_ADDR_VAR 0 10
53798: PUSH
53799: LD_VAR 0 2
53803: PUSH
53804: LD_VAR 0 3
53808: PLUS
53809: ST_TO_ADDR
// for _x = min_x to max_x do
53810: LD_ADDR_VAR 0 5
53814: PUSH
53815: DOUBLE
53816: LD_VAR 0 8
53820: DEC
53821: ST_TO_ADDR
53822: LD_VAR 0 9
53826: PUSH
53827: FOR_TO
53828: IFFALSE 53929
// for _y = min_y to max_y do
53830: LD_ADDR_VAR 0 6
53834: PUSH
53835: DOUBLE
53836: LD_VAR 0 7
53840: DEC
53841: ST_TO_ADDR
53842: LD_VAR 0 10
53846: PUSH
53847: FOR_TO
53848: IFFALSE 53925
// begin if not ValidHex ( _x , _y ) then
53850: LD_VAR 0 5
53854: PPUSH
53855: LD_VAR 0 6
53859: PPUSH
53860: CALL_OW 488
53864: NOT
53865: IFFALSE 53869
// continue ;
53867: GO 53847
// if GetResourceTypeXY ( _x , _y ) then
53869: LD_VAR 0 5
53873: PPUSH
53874: LD_VAR 0 6
53878: PPUSH
53879: CALL_OW 283
53883: IFFALSE 53923
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53885: LD_ADDR_VAR 0 4
53889: PUSH
53890: LD_VAR 0 4
53894: PPUSH
53895: LD_VAR 0 4
53899: PUSH
53900: LD_INT 1
53902: PLUS
53903: PPUSH
53904: LD_VAR 0 5
53908: PUSH
53909: LD_VAR 0 6
53913: PUSH
53914: EMPTY
53915: LIST
53916: LIST
53917: PPUSH
53918: CALL_OW 1
53922: ST_TO_ADDR
// end ;
53923: GO 53847
53925: POP
53926: POP
53927: GO 53827
53929: POP
53930: POP
// end ;
53931: LD_VAR 0 4
53935: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
53936: LD_INT 0
53938: PPUSH
53939: PPUSH
53940: PPUSH
53941: PPUSH
53942: PPUSH
53943: PPUSH
// if not units then
53944: LD_VAR 0 1
53948: NOT
53949: IFFALSE 53953
// exit ;
53951: GO 54354
// result := UnitFilter ( units , [ f_ok ] ) ;
53953: LD_ADDR_VAR 0 3
53957: PUSH
53958: LD_VAR 0 1
53962: PPUSH
53963: LD_INT 50
53965: PUSH
53966: EMPTY
53967: LIST
53968: PPUSH
53969: CALL_OW 72
53973: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53974: LD_ADDR_VAR 0 7
53978: PUSH
53979: LD_VAR 0 1
53983: PUSH
53984: LD_INT 1
53986: ARRAY
53987: PPUSH
53988: CALL_OW 255
53992: ST_TO_ADDR
// if not result then
53993: LD_VAR 0 3
53997: NOT
53998: IFFALSE 54002
// exit ;
54000: GO 54354
// for i in result do
54002: LD_ADDR_VAR 0 4
54006: PUSH
54007: LD_VAR 0 3
54011: PUSH
54012: FOR_IN
54013: IFFALSE 54352
// begin tag := GetTag ( i ) + 1 ;
54015: LD_ADDR_VAR 0 8
54019: PUSH
54020: LD_VAR 0 4
54024: PPUSH
54025: CALL_OW 110
54029: PUSH
54030: LD_INT 1
54032: PLUS
54033: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54034: LD_ADDR_VAR 0 6
54038: PUSH
54039: LD_VAR 0 4
54043: PPUSH
54044: CALL_OW 250
54048: PPUSH
54049: LD_VAR 0 4
54053: PPUSH
54054: CALL_OW 251
54058: PPUSH
54059: LD_INT 6
54061: PPUSH
54062: CALL 53678 0 3
54066: ST_TO_ADDR
// if cr then
54067: LD_VAR 0 6
54071: IFFALSE 54110
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
54073: LD_VAR 0 4
54077: PPUSH
54078: LD_VAR 0 6
54082: PUSH
54083: LD_INT 1
54085: ARRAY
54086: PUSH
54087: LD_INT 1
54089: ARRAY
54090: PPUSH
54091: LD_VAR 0 6
54095: PUSH
54096: LD_INT 1
54098: ARRAY
54099: PUSH
54100: LD_INT 2
54102: ARRAY
54103: PPUSH
54104: CALL_OW 116
54108: GO 54350
// if path > tag then
54110: LD_VAR 0 2
54114: PUSH
54115: LD_VAR 0 8
54119: GREATER
54120: IFFALSE 54298
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
54122: LD_ADDR_VAR 0 5
54126: PUSH
54127: LD_INT 81
54129: PUSH
54130: LD_VAR 0 7
54134: PUSH
54135: EMPTY
54136: LIST
54137: LIST
54138: PUSH
54139: LD_INT 91
54141: PUSH
54142: LD_VAR 0 4
54146: PUSH
54147: LD_INT 12
54149: PUSH
54150: EMPTY
54151: LIST
54152: LIST
54153: LIST
54154: PUSH
54155: EMPTY
54156: LIST
54157: LIST
54158: PPUSH
54159: CALL_OW 69
54163: ST_TO_ADDR
// if enemy then
54164: LD_VAR 0 5
54168: IFFALSE 54196
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54170: LD_VAR 0 4
54174: PPUSH
54175: LD_VAR 0 5
54179: PPUSH
54180: LD_VAR 0 4
54184: PPUSH
54185: CALL_OW 74
54189: PPUSH
54190: CALL_OW 115
54194: GO 54296
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54196: LD_VAR 0 4
54200: PPUSH
54201: LD_VAR 0 2
54205: PUSH
54206: LD_VAR 0 8
54210: ARRAY
54211: PUSH
54212: LD_INT 1
54214: ARRAY
54215: PPUSH
54216: LD_VAR 0 2
54220: PUSH
54221: LD_VAR 0 8
54225: ARRAY
54226: PUSH
54227: LD_INT 2
54229: ARRAY
54230: PPUSH
54231: CALL_OW 297
54235: PUSH
54236: LD_INT 6
54238: GREATER
54239: IFFALSE 54282
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54241: LD_VAR 0 4
54245: PPUSH
54246: LD_VAR 0 2
54250: PUSH
54251: LD_VAR 0 8
54255: ARRAY
54256: PUSH
54257: LD_INT 1
54259: ARRAY
54260: PPUSH
54261: LD_VAR 0 2
54265: PUSH
54266: LD_VAR 0 8
54270: ARRAY
54271: PUSH
54272: LD_INT 2
54274: ARRAY
54275: PPUSH
54276: CALL_OW 114
54280: GO 54296
// SetTag ( i , tag ) ;
54282: LD_VAR 0 4
54286: PPUSH
54287: LD_VAR 0 8
54291: PPUSH
54292: CALL_OW 109
// end else
54296: GO 54350
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54298: LD_ADDR_VAR 0 5
54302: PUSH
54303: LD_INT 81
54305: PUSH
54306: LD_VAR 0 7
54310: PUSH
54311: EMPTY
54312: LIST
54313: LIST
54314: PPUSH
54315: CALL_OW 69
54319: ST_TO_ADDR
// if enemy then
54320: LD_VAR 0 5
54324: IFFALSE 54350
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54326: LD_VAR 0 4
54330: PPUSH
54331: LD_VAR 0 5
54335: PPUSH
54336: LD_VAR 0 4
54340: PPUSH
54341: CALL_OW 74
54345: PPUSH
54346: CALL_OW 115
// end ; end ;
54350: GO 54012
54352: POP
54353: POP
// end ; end_of_file
54354: LD_VAR 0 3
54358: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54359: LD_INT 0
54361: PPUSH
54362: PPUSH
// skirmish := false ;
54363: LD_ADDR_EXP 57
54367: PUSH
54368: LD_INT 0
54370: ST_TO_ADDR
// debug_mc := false ;
54371: LD_ADDR_EXP 58
54375: PUSH
54376: LD_INT 0
54378: ST_TO_ADDR
// mc_bases := [ ] ;
54379: LD_ADDR_EXP 59
54383: PUSH
54384: EMPTY
54385: ST_TO_ADDR
// mc_sides := [ ] ;
54386: LD_ADDR_EXP 85
54390: PUSH
54391: EMPTY
54392: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54393: LD_ADDR_EXP 60
54397: PUSH
54398: EMPTY
54399: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54400: LD_ADDR_EXP 61
54404: PUSH
54405: EMPTY
54406: ST_TO_ADDR
// mc_need_heal := [ ] ;
54407: LD_ADDR_EXP 62
54411: PUSH
54412: EMPTY
54413: ST_TO_ADDR
// mc_healers := [ ] ;
54414: LD_ADDR_EXP 63
54418: PUSH
54419: EMPTY
54420: ST_TO_ADDR
// mc_build_list := [ ] ;
54421: LD_ADDR_EXP 64
54425: PUSH
54426: EMPTY
54427: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54428: LD_ADDR_EXP 91
54432: PUSH
54433: EMPTY
54434: ST_TO_ADDR
// mc_builders := [ ] ;
54435: LD_ADDR_EXP 65
54439: PUSH
54440: EMPTY
54441: ST_TO_ADDR
// mc_construct_list := [ ] ;
54442: LD_ADDR_EXP 66
54446: PUSH
54447: EMPTY
54448: ST_TO_ADDR
// mc_turret_list := [ ] ;
54449: LD_ADDR_EXP 67
54453: PUSH
54454: EMPTY
54455: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54456: LD_ADDR_EXP 68
54460: PUSH
54461: EMPTY
54462: ST_TO_ADDR
// mc_miners := [ ] ;
54463: LD_ADDR_EXP 73
54467: PUSH
54468: EMPTY
54469: ST_TO_ADDR
// mc_mines := [ ] ;
54470: LD_ADDR_EXP 72
54474: PUSH
54475: EMPTY
54476: ST_TO_ADDR
// mc_minefields := [ ] ;
54477: LD_ADDR_EXP 74
54481: PUSH
54482: EMPTY
54483: ST_TO_ADDR
// mc_crates := [ ] ;
54484: LD_ADDR_EXP 75
54488: PUSH
54489: EMPTY
54490: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54491: LD_ADDR_EXP 76
54495: PUSH
54496: EMPTY
54497: ST_TO_ADDR
// mc_crates_area := [ ] ;
54498: LD_ADDR_EXP 77
54502: PUSH
54503: EMPTY
54504: ST_TO_ADDR
// mc_vehicles := [ ] ;
54505: LD_ADDR_EXP 78
54509: PUSH
54510: EMPTY
54511: ST_TO_ADDR
// mc_attack := [ ] ;
54512: LD_ADDR_EXP 79
54516: PUSH
54517: EMPTY
54518: ST_TO_ADDR
// mc_produce := [ ] ;
54519: LD_ADDR_EXP 80
54523: PUSH
54524: EMPTY
54525: ST_TO_ADDR
// mc_defender := [ ] ;
54526: LD_ADDR_EXP 81
54530: PUSH
54531: EMPTY
54532: ST_TO_ADDR
// mc_parking := [ ] ;
54533: LD_ADDR_EXP 83
54537: PUSH
54538: EMPTY
54539: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54540: LD_ADDR_EXP 69
54544: PUSH
54545: EMPTY
54546: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54547: LD_ADDR_EXP 71
54551: PUSH
54552: EMPTY
54553: ST_TO_ADDR
// mc_scan := [ ] ;
54554: LD_ADDR_EXP 82
54558: PUSH
54559: EMPTY
54560: ST_TO_ADDR
// mc_scan_area := [ ] ;
54561: LD_ADDR_EXP 84
54565: PUSH
54566: EMPTY
54567: ST_TO_ADDR
// mc_tech := [ ] ;
54568: LD_ADDR_EXP 86
54572: PUSH
54573: EMPTY
54574: ST_TO_ADDR
// mc_class := [ ] ;
54575: LD_ADDR_EXP 100
54579: PUSH
54580: EMPTY
54581: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54582: LD_ADDR_EXP 101
54586: PUSH
54587: EMPTY
54588: ST_TO_ADDR
// mc_is_defending := [ ] ;
54589: LD_ADDR_EXP 102
54593: PUSH
54594: EMPTY
54595: ST_TO_ADDR
// end ;
54596: LD_VAR 0 1
54600: RET
// export function MC_Kill ( base ) ; begin
54601: LD_INT 0
54603: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54604: LD_ADDR_EXP 59
54608: PUSH
54609: LD_EXP 59
54613: PPUSH
54614: LD_VAR 0 1
54618: PPUSH
54619: EMPTY
54620: PPUSH
54621: CALL_OW 1
54625: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54626: LD_ADDR_EXP 60
54630: PUSH
54631: LD_EXP 60
54635: PPUSH
54636: LD_VAR 0 1
54640: PPUSH
54641: EMPTY
54642: PPUSH
54643: CALL_OW 1
54647: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54648: LD_ADDR_EXP 61
54652: PUSH
54653: LD_EXP 61
54657: PPUSH
54658: LD_VAR 0 1
54662: PPUSH
54663: EMPTY
54664: PPUSH
54665: CALL_OW 1
54669: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54670: LD_ADDR_EXP 62
54674: PUSH
54675: LD_EXP 62
54679: PPUSH
54680: LD_VAR 0 1
54684: PPUSH
54685: EMPTY
54686: PPUSH
54687: CALL_OW 1
54691: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54692: LD_ADDR_EXP 63
54696: PUSH
54697: LD_EXP 63
54701: PPUSH
54702: LD_VAR 0 1
54706: PPUSH
54707: EMPTY
54708: PPUSH
54709: CALL_OW 1
54713: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54714: LD_ADDR_EXP 64
54718: PUSH
54719: LD_EXP 64
54723: PPUSH
54724: LD_VAR 0 1
54728: PPUSH
54729: EMPTY
54730: PPUSH
54731: CALL_OW 1
54735: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54736: LD_ADDR_EXP 65
54740: PUSH
54741: LD_EXP 65
54745: PPUSH
54746: LD_VAR 0 1
54750: PPUSH
54751: EMPTY
54752: PPUSH
54753: CALL_OW 1
54757: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54758: LD_ADDR_EXP 66
54762: PUSH
54763: LD_EXP 66
54767: PPUSH
54768: LD_VAR 0 1
54772: PPUSH
54773: EMPTY
54774: PPUSH
54775: CALL_OW 1
54779: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54780: LD_ADDR_EXP 67
54784: PUSH
54785: LD_EXP 67
54789: PPUSH
54790: LD_VAR 0 1
54794: PPUSH
54795: EMPTY
54796: PPUSH
54797: CALL_OW 1
54801: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54802: LD_ADDR_EXP 68
54806: PUSH
54807: LD_EXP 68
54811: PPUSH
54812: LD_VAR 0 1
54816: PPUSH
54817: EMPTY
54818: PPUSH
54819: CALL_OW 1
54823: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54824: LD_ADDR_EXP 69
54828: PUSH
54829: LD_EXP 69
54833: PPUSH
54834: LD_VAR 0 1
54838: PPUSH
54839: EMPTY
54840: PPUSH
54841: CALL_OW 1
54845: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54846: LD_ADDR_EXP 70
54850: PUSH
54851: LD_EXP 70
54855: PPUSH
54856: LD_VAR 0 1
54860: PPUSH
54861: LD_INT 0
54863: PPUSH
54864: CALL_OW 1
54868: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54869: LD_ADDR_EXP 71
54873: PUSH
54874: LD_EXP 71
54878: PPUSH
54879: LD_VAR 0 1
54883: PPUSH
54884: EMPTY
54885: PPUSH
54886: CALL_OW 1
54890: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54891: LD_ADDR_EXP 72
54895: PUSH
54896: LD_EXP 72
54900: PPUSH
54901: LD_VAR 0 1
54905: PPUSH
54906: EMPTY
54907: PPUSH
54908: CALL_OW 1
54912: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54913: LD_ADDR_EXP 73
54917: PUSH
54918: LD_EXP 73
54922: PPUSH
54923: LD_VAR 0 1
54927: PPUSH
54928: EMPTY
54929: PPUSH
54930: CALL_OW 1
54934: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54935: LD_ADDR_EXP 74
54939: PUSH
54940: LD_EXP 74
54944: PPUSH
54945: LD_VAR 0 1
54949: PPUSH
54950: EMPTY
54951: PPUSH
54952: CALL_OW 1
54956: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54957: LD_ADDR_EXP 75
54961: PUSH
54962: LD_EXP 75
54966: PPUSH
54967: LD_VAR 0 1
54971: PPUSH
54972: EMPTY
54973: PPUSH
54974: CALL_OW 1
54978: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54979: LD_ADDR_EXP 76
54983: PUSH
54984: LD_EXP 76
54988: PPUSH
54989: LD_VAR 0 1
54993: PPUSH
54994: EMPTY
54995: PPUSH
54996: CALL_OW 1
55000: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55001: LD_ADDR_EXP 77
55005: PUSH
55006: LD_EXP 77
55010: PPUSH
55011: LD_VAR 0 1
55015: PPUSH
55016: EMPTY
55017: PPUSH
55018: CALL_OW 1
55022: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55023: LD_ADDR_EXP 78
55027: PUSH
55028: LD_EXP 78
55032: PPUSH
55033: LD_VAR 0 1
55037: PPUSH
55038: EMPTY
55039: PPUSH
55040: CALL_OW 1
55044: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55045: LD_ADDR_EXP 79
55049: PUSH
55050: LD_EXP 79
55054: PPUSH
55055: LD_VAR 0 1
55059: PPUSH
55060: EMPTY
55061: PPUSH
55062: CALL_OW 1
55066: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55067: LD_ADDR_EXP 80
55071: PUSH
55072: LD_EXP 80
55076: PPUSH
55077: LD_VAR 0 1
55081: PPUSH
55082: EMPTY
55083: PPUSH
55084: CALL_OW 1
55088: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55089: LD_ADDR_EXP 81
55093: PUSH
55094: LD_EXP 81
55098: PPUSH
55099: LD_VAR 0 1
55103: PPUSH
55104: EMPTY
55105: PPUSH
55106: CALL_OW 1
55110: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55111: LD_ADDR_EXP 82
55115: PUSH
55116: LD_EXP 82
55120: PPUSH
55121: LD_VAR 0 1
55125: PPUSH
55126: EMPTY
55127: PPUSH
55128: CALL_OW 1
55132: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55133: LD_ADDR_EXP 83
55137: PUSH
55138: LD_EXP 83
55142: PPUSH
55143: LD_VAR 0 1
55147: PPUSH
55148: EMPTY
55149: PPUSH
55150: CALL_OW 1
55154: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55155: LD_ADDR_EXP 84
55159: PUSH
55160: LD_EXP 84
55164: PPUSH
55165: LD_VAR 0 1
55169: PPUSH
55170: EMPTY
55171: PPUSH
55172: CALL_OW 1
55176: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55177: LD_ADDR_EXP 86
55181: PUSH
55182: LD_EXP 86
55186: PPUSH
55187: LD_VAR 0 1
55191: PPUSH
55192: EMPTY
55193: PPUSH
55194: CALL_OW 1
55198: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55199: LD_ADDR_EXP 88
55203: PUSH
55204: LD_EXP 88
55208: PPUSH
55209: LD_VAR 0 1
55213: PPUSH
55214: EMPTY
55215: PPUSH
55216: CALL_OW 1
55220: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55221: LD_ADDR_EXP 89
55225: PUSH
55226: LD_EXP 89
55230: PPUSH
55231: LD_VAR 0 1
55235: PPUSH
55236: EMPTY
55237: PPUSH
55238: CALL_OW 1
55242: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55243: LD_ADDR_EXP 90
55247: PUSH
55248: LD_EXP 90
55252: PPUSH
55253: LD_VAR 0 1
55257: PPUSH
55258: EMPTY
55259: PPUSH
55260: CALL_OW 1
55264: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55265: LD_ADDR_EXP 91
55269: PUSH
55270: LD_EXP 91
55274: PPUSH
55275: LD_VAR 0 1
55279: PPUSH
55280: EMPTY
55281: PPUSH
55282: CALL_OW 1
55286: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55287: LD_ADDR_EXP 92
55291: PUSH
55292: LD_EXP 92
55296: PPUSH
55297: LD_VAR 0 1
55301: PPUSH
55302: EMPTY
55303: PPUSH
55304: CALL_OW 1
55308: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55309: LD_ADDR_EXP 93
55313: PUSH
55314: LD_EXP 93
55318: PPUSH
55319: LD_VAR 0 1
55323: PPUSH
55324: EMPTY
55325: PPUSH
55326: CALL_OW 1
55330: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55331: LD_ADDR_EXP 94
55335: PUSH
55336: LD_EXP 94
55340: PPUSH
55341: LD_VAR 0 1
55345: PPUSH
55346: EMPTY
55347: PPUSH
55348: CALL_OW 1
55352: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55353: LD_ADDR_EXP 95
55357: PUSH
55358: LD_EXP 95
55362: PPUSH
55363: LD_VAR 0 1
55367: PPUSH
55368: EMPTY
55369: PPUSH
55370: CALL_OW 1
55374: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55375: LD_ADDR_EXP 96
55379: PUSH
55380: LD_EXP 96
55384: PPUSH
55385: LD_VAR 0 1
55389: PPUSH
55390: EMPTY
55391: PPUSH
55392: CALL_OW 1
55396: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55397: LD_ADDR_EXP 97
55401: PUSH
55402: LD_EXP 97
55406: PPUSH
55407: LD_VAR 0 1
55411: PPUSH
55412: EMPTY
55413: PPUSH
55414: CALL_OW 1
55418: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55419: LD_ADDR_EXP 98
55423: PUSH
55424: LD_EXP 98
55428: PPUSH
55429: LD_VAR 0 1
55433: PPUSH
55434: EMPTY
55435: PPUSH
55436: CALL_OW 1
55440: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55441: LD_ADDR_EXP 99
55445: PUSH
55446: LD_EXP 99
55450: PPUSH
55451: LD_VAR 0 1
55455: PPUSH
55456: EMPTY
55457: PPUSH
55458: CALL_OW 1
55462: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55463: LD_ADDR_EXP 100
55467: PUSH
55468: LD_EXP 100
55472: PPUSH
55473: LD_VAR 0 1
55477: PPUSH
55478: EMPTY
55479: PPUSH
55480: CALL_OW 1
55484: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55485: LD_ADDR_EXP 101
55489: PUSH
55490: LD_EXP 101
55494: PPUSH
55495: LD_VAR 0 1
55499: PPUSH
55500: LD_INT 0
55502: PPUSH
55503: CALL_OW 1
55507: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55508: LD_ADDR_EXP 102
55512: PUSH
55513: LD_EXP 102
55517: PPUSH
55518: LD_VAR 0 1
55522: PPUSH
55523: LD_INT 0
55525: PPUSH
55526: CALL_OW 1
55530: ST_TO_ADDR
// end ;
55531: LD_VAR 0 2
55535: RET
// export function MC_Add ( side , units ) ; var base ; begin
55536: LD_INT 0
55538: PPUSH
55539: PPUSH
// base := mc_bases + 1 ;
55540: LD_ADDR_VAR 0 4
55544: PUSH
55545: LD_EXP 59
55549: PUSH
55550: LD_INT 1
55552: PLUS
55553: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55554: LD_ADDR_EXP 85
55558: PUSH
55559: LD_EXP 85
55563: PPUSH
55564: LD_VAR 0 4
55568: PPUSH
55569: LD_VAR 0 1
55573: PPUSH
55574: CALL_OW 1
55578: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55579: LD_ADDR_EXP 59
55583: PUSH
55584: LD_EXP 59
55588: PPUSH
55589: LD_VAR 0 4
55593: PPUSH
55594: LD_VAR 0 2
55598: PPUSH
55599: CALL_OW 1
55603: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55604: LD_ADDR_EXP 60
55608: PUSH
55609: LD_EXP 60
55613: PPUSH
55614: LD_VAR 0 4
55618: PPUSH
55619: EMPTY
55620: PPUSH
55621: CALL_OW 1
55625: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55626: LD_ADDR_EXP 61
55630: PUSH
55631: LD_EXP 61
55635: PPUSH
55636: LD_VAR 0 4
55640: PPUSH
55641: EMPTY
55642: PPUSH
55643: CALL_OW 1
55647: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55648: LD_ADDR_EXP 62
55652: PUSH
55653: LD_EXP 62
55657: PPUSH
55658: LD_VAR 0 4
55662: PPUSH
55663: EMPTY
55664: PPUSH
55665: CALL_OW 1
55669: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55670: LD_ADDR_EXP 63
55674: PUSH
55675: LD_EXP 63
55679: PPUSH
55680: LD_VAR 0 4
55684: PPUSH
55685: EMPTY
55686: PPUSH
55687: CALL_OW 1
55691: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55692: LD_ADDR_EXP 64
55696: PUSH
55697: LD_EXP 64
55701: PPUSH
55702: LD_VAR 0 4
55706: PPUSH
55707: EMPTY
55708: PPUSH
55709: CALL_OW 1
55713: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55714: LD_ADDR_EXP 65
55718: PUSH
55719: LD_EXP 65
55723: PPUSH
55724: LD_VAR 0 4
55728: PPUSH
55729: EMPTY
55730: PPUSH
55731: CALL_OW 1
55735: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55736: LD_ADDR_EXP 66
55740: PUSH
55741: LD_EXP 66
55745: PPUSH
55746: LD_VAR 0 4
55750: PPUSH
55751: EMPTY
55752: PPUSH
55753: CALL_OW 1
55757: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55758: LD_ADDR_EXP 67
55762: PUSH
55763: LD_EXP 67
55767: PPUSH
55768: LD_VAR 0 4
55772: PPUSH
55773: EMPTY
55774: PPUSH
55775: CALL_OW 1
55779: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55780: LD_ADDR_EXP 68
55784: PUSH
55785: LD_EXP 68
55789: PPUSH
55790: LD_VAR 0 4
55794: PPUSH
55795: EMPTY
55796: PPUSH
55797: CALL_OW 1
55801: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55802: LD_ADDR_EXP 69
55806: PUSH
55807: LD_EXP 69
55811: PPUSH
55812: LD_VAR 0 4
55816: PPUSH
55817: EMPTY
55818: PPUSH
55819: CALL_OW 1
55823: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55824: LD_ADDR_EXP 70
55828: PUSH
55829: LD_EXP 70
55833: PPUSH
55834: LD_VAR 0 4
55838: PPUSH
55839: LD_INT 0
55841: PPUSH
55842: CALL_OW 1
55846: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55847: LD_ADDR_EXP 71
55851: PUSH
55852: LD_EXP 71
55856: PPUSH
55857: LD_VAR 0 4
55861: PPUSH
55862: EMPTY
55863: PPUSH
55864: CALL_OW 1
55868: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55869: LD_ADDR_EXP 72
55873: PUSH
55874: LD_EXP 72
55878: PPUSH
55879: LD_VAR 0 4
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55891: LD_ADDR_EXP 73
55895: PUSH
55896: LD_EXP 73
55900: PPUSH
55901: LD_VAR 0 4
55905: PPUSH
55906: EMPTY
55907: PPUSH
55908: CALL_OW 1
55912: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55913: LD_ADDR_EXP 74
55917: PUSH
55918: LD_EXP 74
55922: PPUSH
55923: LD_VAR 0 4
55927: PPUSH
55928: EMPTY
55929: PPUSH
55930: CALL_OW 1
55934: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55935: LD_ADDR_EXP 75
55939: PUSH
55940: LD_EXP 75
55944: PPUSH
55945: LD_VAR 0 4
55949: PPUSH
55950: EMPTY
55951: PPUSH
55952: CALL_OW 1
55956: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55957: LD_ADDR_EXP 76
55961: PUSH
55962: LD_EXP 76
55966: PPUSH
55967: LD_VAR 0 4
55971: PPUSH
55972: EMPTY
55973: PPUSH
55974: CALL_OW 1
55978: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55979: LD_ADDR_EXP 77
55983: PUSH
55984: LD_EXP 77
55988: PPUSH
55989: LD_VAR 0 4
55993: PPUSH
55994: EMPTY
55995: PPUSH
55996: CALL_OW 1
56000: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56001: LD_ADDR_EXP 78
56005: PUSH
56006: LD_EXP 78
56010: PPUSH
56011: LD_VAR 0 4
56015: PPUSH
56016: EMPTY
56017: PPUSH
56018: CALL_OW 1
56022: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56023: LD_ADDR_EXP 79
56027: PUSH
56028: LD_EXP 79
56032: PPUSH
56033: LD_VAR 0 4
56037: PPUSH
56038: EMPTY
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56045: LD_ADDR_EXP 80
56049: PUSH
56050: LD_EXP 80
56054: PPUSH
56055: LD_VAR 0 4
56059: PPUSH
56060: EMPTY
56061: PPUSH
56062: CALL_OW 1
56066: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56067: LD_ADDR_EXP 81
56071: PUSH
56072: LD_EXP 81
56076: PPUSH
56077: LD_VAR 0 4
56081: PPUSH
56082: EMPTY
56083: PPUSH
56084: CALL_OW 1
56088: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56089: LD_ADDR_EXP 82
56093: PUSH
56094: LD_EXP 82
56098: PPUSH
56099: LD_VAR 0 4
56103: PPUSH
56104: EMPTY
56105: PPUSH
56106: CALL_OW 1
56110: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56111: LD_ADDR_EXP 83
56115: PUSH
56116: LD_EXP 83
56120: PPUSH
56121: LD_VAR 0 4
56125: PPUSH
56126: EMPTY
56127: PPUSH
56128: CALL_OW 1
56132: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56133: LD_ADDR_EXP 84
56137: PUSH
56138: LD_EXP 84
56142: PPUSH
56143: LD_VAR 0 4
56147: PPUSH
56148: EMPTY
56149: PPUSH
56150: CALL_OW 1
56154: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56155: LD_ADDR_EXP 86
56159: PUSH
56160: LD_EXP 86
56164: PPUSH
56165: LD_VAR 0 4
56169: PPUSH
56170: EMPTY
56171: PPUSH
56172: CALL_OW 1
56176: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56177: LD_ADDR_EXP 88
56181: PUSH
56182: LD_EXP 88
56186: PPUSH
56187: LD_VAR 0 4
56191: PPUSH
56192: EMPTY
56193: PPUSH
56194: CALL_OW 1
56198: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56199: LD_ADDR_EXP 89
56203: PUSH
56204: LD_EXP 89
56208: PPUSH
56209: LD_VAR 0 4
56213: PPUSH
56214: EMPTY
56215: PPUSH
56216: CALL_OW 1
56220: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56221: LD_ADDR_EXP 90
56225: PUSH
56226: LD_EXP 90
56230: PPUSH
56231: LD_VAR 0 4
56235: PPUSH
56236: EMPTY
56237: PPUSH
56238: CALL_OW 1
56242: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56243: LD_ADDR_EXP 91
56247: PUSH
56248: LD_EXP 91
56252: PPUSH
56253: LD_VAR 0 4
56257: PPUSH
56258: EMPTY
56259: PPUSH
56260: CALL_OW 1
56264: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56265: LD_ADDR_EXP 92
56269: PUSH
56270: LD_EXP 92
56274: PPUSH
56275: LD_VAR 0 4
56279: PPUSH
56280: EMPTY
56281: PPUSH
56282: CALL_OW 1
56286: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56287: LD_ADDR_EXP 93
56291: PUSH
56292: LD_EXP 93
56296: PPUSH
56297: LD_VAR 0 4
56301: PPUSH
56302: EMPTY
56303: PPUSH
56304: CALL_OW 1
56308: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56309: LD_ADDR_EXP 94
56313: PUSH
56314: LD_EXP 94
56318: PPUSH
56319: LD_VAR 0 4
56323: PPUSH
56324: EMPTY
56325: PPUSH
56326: CALL_OW 1
56330: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56331: LD_ADDR_EXP 95
56335: PUSH
56336: LD_EXP 95
56340: PPUSH
56341: LD_VAR 0 4
56345: PPUSH
56346: EMPTY
56347: PPUSH
56348: CALL_OW 1
56352: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56353: LD_ADDR_EXP 96
56357: PUSH
56358: LD_EXP 96
56362: PPUSH
56363: LD_VAR 0 4
56367: PPUSH
56368: EMPTY
56369: PPUSH
56370: CALL_OW 1
56374: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56375: LD_ADDR_EXP 97
56379: PUSH
56380: LD_EXP 97
56384: PPUSH
56385: LD_VAR 0 4
56389: PPUSH
56390: EMPTY
56391: PPUSH
56392: CALL_OW 1
56396: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56397: LD_ADDR_EXP 98
56401: PUSH
56402: LD_EXP 98
56406: PPUSH
56407: LD_VAR 0 4
56411: PPUSH
56412: EMPTY
56413: PPUSH
56414: CALL_OW 1
56418: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56419: LD_ADDR_EXP 99
56423: PUSH
56424: LD_EXP 99
56428: PPUSH
56429: LD_VAR 0 4
56433: PPUSH
56434: EMPTY
56435: PPUSH
56436: CALL_OW 1
56440: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56441: LD_ADDR_EXP 100
56445: PUSH
56446: LD_EXP 100
56450: PPUSH
56451: LD_VAR 0 4
56455: PPUSH
56456: EMPTY
56457: PPUSH
56458: CALL_OW 1
56462: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56463: LD_ADDR_EXP 101
56467: PUSH
56468: LD_EXP 101
56472: PPUSH
56473: LD_VAR 0 4
56477: PPUSH
56478: LD_INT 0
56480: PPUSH
56481: CALL_OW 1
56485: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56486: LD_ADDR_EXP 102
56490: PUSH
56491: LD_EXP 102
56495: PPUSH
56496: LD_VAR 0 4
56500: PPUSH
56501: LD_INT 0
56503: PPUSH
56504: CALL_OW 1
56508: ST_TO_ADDR
// result := base ;
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: LD_VAR 0 4
56518: ST_TO_ADDR
// end ;
56519: LD_VAR 0 3
56523: RET
// export function MC_Start ( ) ; var i ; begin
56524: LD_INT 0
56526: PPUSH
56527: PPUSH
// for i = 1 to mc_bases do
56528: LD_ADDR_VAR 0 2
56532: PUSH
56533: DOUBLE
56534: LD_INT 1
56536: DEC
56537: ST_TO_ADDR
56538: LD_EXP 59
56542: PUSH
56543: FOR_TO
56544: IFFALSE 57644
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56546: LD_ADDR_EXP 59
56550: PUSH
56551: LD_EXP 59
56555: PPUSH
56556: LD_VAR 0 2
56560: PPUSH
56561: LD_EXP 59
56565: PUSH
56566: LD_VAR 0 2
56570: ARRAY
56571: PUSH
56572: LD_INT 0
56574: DIFF
56575: PPUSH
56576: CALL_OW 1
56580: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56581: LD_ADDR_EXP 60
56585: PUSH
56586: LD_EXP 60
56590: PPUSH
56591: LD_VAR 0 2
56595: PPUSH
56596: EMPTY
56597: PPUSH
56598: CALL_OW 1
56602: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56603: LD_ADDR_EXP 61
56607: PUSH
56608: LD_EXP 61
56612: PPUSH
56613: LD_VAR 0 2
56617: PPUSH
56618: EMPTY
56619: PPUSH
56620: CALL_OW 1
56624: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56625: LD_ADDR_EXP 62
56629: PUSH
56630: LD_EXP 62
56634: PPUSH
56635: LD_VAR 0 2
56639: PPUSH
56640: EMPTY
56641: PPUSH
56642: CALL_OW 1
56646: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56647: LD_ADDR_EXP 63
56651: PUSH
56652: LD_EXP 63
56656: PPUSH
56657: LD_VAR 0 2
56661: PPUSH
56662: EMPTY
56663: PUSH
56664: EMPTY
56665: PUSH
56666: EMPTY
56667: LIST
56668: LIST
56669: PPUSH
56670: CALL_OW 1
56674: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56675: LD_ADDR_EXP 64
56679: PUSH
56680: LD_EXP 64
56684: PPUSH
56685: LD_VAR 0 2
56689: PPUSH
56690: EMPTY
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56697: LD_ADDR_EXP 91
56701: PUSH
56702: LD_EXP 91
56706: PPUSH
56707: LD_VAR 0 2
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56719: LD_ADDR_EXP 65
56723: PUSH
56724: LD_EXP 65
56728: PPUSH
56729: LD_VAR 0 2
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56741: LD_ADDR_EXP 66
56745: PUSH
56746: LD_EXP 66
56750: PPUSH
56751: LD_VAR 0 2
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56763: LD_ADDR_EXP 67
56767: PUSH
56768: LD_EXP 67
56772: PPUSH
56773: LD_VAR 0 2
56777: PPUSH
56778: LD_EXP 59
56782: PUSH
56783: LD_VAR 0 2
56787: ARRAY
56788: PPUSH
56789: LD_INT 2
56791: PUSH
56792: LD_INT 30
56794: PUSH
56795: LD_INT 32
56797: PUSH
56798: EMPTY
56799: LIST
56800: LIST
56801: PUSH
56802: LD_INT 30
56804: PUSH
56805: LD_INT 33
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PUSH
56812: EMPTY
56813: LIST
56814: LIST
56815: LIST
56816: PPUSH
56817: CALL_OW 72
56821: PPUSH
56822: CALL_OW 1
56826: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56827: LD_ADDR_EXP 68
56831: PUSH
56832: LD_EXP 68
56836: PPUSH
56837: LD_VAR 0 2
56841: PPUSH
56842: LD_EXP 59
56846: PUSH
56847: LD_VAR 0 2
56851: ARRAY
56852: PPUSH
56853: LD_INT 2
56855: PUSH
56856: LD_INT 30
56858: PUSH
56859: LD_INT 32
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PUSH
56866: LD_INT 30
56868: PUSH
56869: LD_INT 31
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: EMPTY
56877: LIST
56878: LIST
56879: LIST
56880: PUSH
56881: LD_INT 58
56883: PUSH
56884: EMPTY
56885: LIST
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: PPUSH
56891: CALL_OW 72
56895: PPUSH
56896: CALL_OW 1
56900: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56901: LD_ADDR_EXP 69
56905: PUSH
56906: LD_EXP 69
56910: PPUSH
56911: LD_VAR 0 2
56915: PPUSH
56916: EMPTY
56917: PPUSH
56918: CALL_OW 1
56922: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56923: LD_ADDR_EXP 73
56927: PUSH
56928: LD_EXP 73
56932: PPUSH
56933: LD_VAR 0 2
56937: PPUSH
56938: EMPTY
56939: PPUSH
56940: CALL_OW 1
56944: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56945: LD_ADDR_EXP 72
56949: PUSH
56950: LD_EXP 72
56954: PPUSH
56955: LD_VAR 0 2
56959: PPUSH
56960: EMPTY
56961: PPUSH
56962: CALL_OW 1
56966: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56967: LD_ADDR_EXP 74
56971: PUSH
56972: LD_EXP 74
56976: PPUSH
56977: LD_VAR 0 2
56981: PPUSH
56982: EMPTY
56983: PPUSH
56984: CALL_OW 1
56988: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
56989: LD_ADDR_EXP 75
56993: PUSH
56994: LD_EXP 75
56998: PPUSH
56999: LD_VAR 0 2
57003: PPUSH
57004: EMPTY
57005: PPUSH
57006: CALL_OW 1
57010: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57011: LD_ADDR_EXP 76
57015: PUSH
57016: LD_EXP 76
57020: PPUSH
57021: LD_VAR 0 2
57025: PPUSH
57026: EMPTY
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57033: LD_ADDR_EXP 77
57037: PUSH
57038: LD_EXP 77
57042: PPUSH
57043: LD_VAR 0 2
57047: PPUSH
57048: EMPTY
57049: PPUSH
57050: CALL_OW 1
57054: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57055: LD_ADDR_EXP 78
57059: PUSH
57060: LD_EXP 78
57064: PPUSH
57065: LD_VAR 0 2
57069: PPUSH
57070: EMPTY
57071: PPUSH
57072: CALL_OW 1
57076: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57077: LD_ADDR_EXP 79
57081: PUSH
57082: LD_EXP 79
57086: PPUSH
57087: LD_VAR 0 2
57091: PPUSH
57092: EMPTY
57093: PPUSH
57094: CALL_OW 1
57098: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57099: LD_ADDR_EXP 80
57103: PUSH
57104: LD_EXP 80
57108: PPUSH
57109: LD_VAR 0 2
57113: PPUSH
57114: EMPTY
57115: PPUSH
57116: CALL_OW 1
57120: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57121: LD_ADDR_EXP 81
57125: PUSH
57126: LD_EXP 81
57130: PPUSH
57131: LD_VAR 0 2
57135: PPUSH
57136: EMPTY
57137: PPUSH
57138: CALL_OW 1
57142: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57143: LD_ADDR_EXP 70
57147: PUSH
57148: LD_EXP 70
57152: PPUSH
57153: LD_VAR 0 2
57157: PPUSH
57158: LD_INT 0
57160: PPUSH
57161: CALL_OW 1
57165: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57166: LD_ADDR_EXP 83
57170: PUSH
57171: LD_EXP 83
57175: PPUSH
57176: LD_VAR 0 2
57180: PPUSH
57181: LD_INT 0
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57189: LD_ADDR_EXP 71
57193: PUSH
57194: LD_EXP 71
57198: PPUSH
57199: LD_VAR 0 2
57203: PPUSH
57204: EMPTY
57205: PPUSH
57206: CALL_OW 1
57210: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57211: LD_ADDR_EXP 82
57215: PUSH
57216: LD_EXP 82
57220: PPUSH
57221: LD_VAR 0 2
57225: PPUSH
57226: LD_INT 0
57228: PPUSH
57229: CALL_OW 1
57233: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57234: LD_ADDR_EXP 84
57238: PUSH
57239: LD_EXP 84
57243: PPUSH
57244: LD_VAR 0 2
57248: PPUSH
57249: EMPTY
57250: PPUSH
57251: CALL_OW 1
57255: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57256: LD_ADDR_EXP 87
57260: PUSH
57261: LD_EXP 87
57265: PPUSH
57266: LD_VAR 0 2
57270: PPUSH
57271: LD_INT 0
57273: PPUSH
57274: CALL_OW 1
57278: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57279: LD_ADDR_EXP 88
57283: PUSH
57284: LD_EXP 88
57288: PPUSH
57289: LD_VAR 0 2
57293: PPUSH
57294: EMPTY
57295: PPUSH
57296: CALL_OW 1
57300: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57301: LD_ADDR_EXP 89
57305: PUSH
57306: LD_EXP 89
57310: PPUSH
57311: LD_VAR 0 2
57315: PPUSH
57316: EMPTY
57317: PPUSH
57318: CALL_OW 1
57322: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57323: LD_ADDR_EXP 90
57327: PUSH
57328: LD_EXP 90
57332: PPUSH
57333: LD_VAR 0 2
57337: PPUSH
57338: EMPTY
57339: PPUSH
57340: CALL_OW 1
57344: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57345: LD_ADDR_EXP 92
57349: PUSH
57350: LD_EXP 92
57354: PPUSH
57355: LD_VAR 0 2
57359: PPUSH
57360: LD_EXP 59
57364: PUSH
57365: LD_VAR 0 2
57369: ARRAY
57370: PPUSH
57371: LD_INT 2
57373: PUSH
57374: LD_INT 30
57376: PUSH
57377: LD_INT 6
57379: PUSH
57380: EMPTY
57381: LIST
57382: LIST
57383: PUSH
57384: LD_INT 30
57386: PUSH
57387: LD_INT 7
57389: PUSH
57390: EMPTY
57391: LIST
57392: LIST
57393: PUSH
57394: LD_INT 30
57396: PUSH
57397: LD_INT 8
57399: PUSH
57400: EMPTY
57401: LIST
57402: LIST
57403: PUSH
57404: EMPTY
57405: LIST
57406: LIST
57407: LIST
57408: LIST
57409: PPUSH
57410: CALL_OW 72
57414: PPUSH
57415: CALL_OW 1
57419: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57420: LD_ADDR_EXP 93
57424: PUSH
57425: LD_EXP 93
57429: PPUSH
57430: LD_VAR 0 2
57434: PPUSH
57435: EMPTY
57436: PPUSH
57437: CALL_OW 1
57441: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57442: LD_ADDR_EXP 94
57446: PUSH
57447: LD_EXP 94
57451: PPUSH
57452: LD_VAR 0 2
57456: PPUSH
57457: EMPTY
57458: PPUSH
57459: CALL_OW 1
57463: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57464: LD_ADDR_EXP 95
57468: PUSH
57469: LD_EXP 95
57473: PPUSH
57474: LD_VAR 0 2
57478: PPUSH
57479: EMPTY
57480: PPUSH
57481: CALL_OW 1
57485: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57486: LD_ADDR_EXP 96
57490: PUSH
57491: LD_EXP 96
57495: PPUSH
57496: LD_VAR 0 2
57500: PPUSH
57501: EMPTY
57502: PPUSH
57503: CALL_OW 1
57507: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57508: LD_ADDR_EXP 97
57512: PUSH
57513: LD_EXP 97
57517: PPUSH
57518: LD_VAR 0 2
57522: PPUSH
57523: EMPTY
57524: PPUSH
57525: CALL_OW 1
57529: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57530: LD_ADDR_EXP 98
57534: PUSH
57535: LD_EXP 98
57539: PPUSH
57540: LD_VAR 0 2
57544: PPUSH
57545: EMPTY
57546: PPUSH
57547: CALL_OW 1
57551: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57552: LD_ADDR_EXP 99
57556: PUSH
57557: LD_EXP 99
57561: PPUSH
57562: LD_VAR 0 2
57566: PPUSH
57567: EMPTY
57568: PPUSH
57569: CALL_OW 1
57573: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57574: LD_ADDR_EXP 100
57578: PUSH
57579: LD_EXP 100
57583: PPUSH
57584: LD_VAR 0 2
57588: PPUSH
57589: EMPTY
57590: PPUSH
57591: CALL_OW 1
57595: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57596: LD_ADDR_EXP 101
57600: PUSH
57601: LD_EXP 101
57605: PPUSH
57606: LD_VAR 0 2
57610: PPUSH
57611: LD_INT 0
57613: PPUSH
57614: CALL_OW 1
57618: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57619: LD_ADDR_EXP 102
57623: PUSH
57624: LD_EXP 102
57628: PPUSH
57629: LD_VAR 0 2
57633: PPUSH
57634: LD_INT 0
57636: PPUSH
57637: CALL_OW 1
57641: ST_TO_ADDR
// end ;
57642: GO 56543
57644: POP
57645: POP
// MC_InitSides ( ) ;
57646: CALL 57932 0 0
// MC_InitResearch ( ) ;
57650: CALL 57671 0 0
// CustomInitMacro ( ) ;
57654: CALL 206 0 0
// skirmish := true ;
57658: LD_ADDR_EXP 57
57662: PUSH
57663: LD_INT 1
57665: ST_TO_ADDR
// end ;
57666: LD_VAR 0 1
57670: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57671: LD_INT 0
57673: PPUSH
57674: PPUSH
57675: PPUSH
57676: PPUSH
57677: PPUSH
57678: PPUSH
// if not mc_bases then
57679: LD_EXP 59
57683: NOT
57684: IFFALSE 57688
// exit ;
57686: GO 57927
// for i = 1 to 8 do
57688: LD_ADDR_VAR 0 2
57692: PUSH
57693: DOUBLE
57694: LD_INT 1
57696: DEC
57697: ST_TO_ADDR
57698: LD_INT 8
57700: PUSH
57701: FOR_TO
57702: IFFALSE 57728
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57704: LD_ADDR_EXP 86
57708: PUSH
57709: LD_EXP 86
57713: PPUSH
57714: LD_VAR 0 2
57718: PPUSH
57719: EMPTY
57720: PPUSH
57721: CALL_OW 1
57725: ST_TO_ADDR
57726: GO 57701
57728: POP
57729: POP
// tmp := [ ] ;
57730: LD_ADDR_VAR 0 5
57734: PUSH
57735: EMPTY
57736: ST_TO_ADDR
// for i = 1 to mc_sides do
57737: LD_ADDR_VAR 0 2
57741: PUSH
57742: DOUBLE
57743: LD_INT 1
57745: DEC
57746: ST_TO_ADDR
57747: LD_EXP 85
57751: PUSH
57752: FOR_TO
57753: IFFALSE 57811
// if not mc_sides [ i ] in tmp then
57755: LD_EXP 85
57759: PUSH
57760: LD_VAR 0 2
57764: ARRAY
57765: PUSH
57766: LD_VAR 0 5
57770: IN
57771: NOT
57772: IFFALSE 57809
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57774: LD_ADDR_VAR 0 5
57778: PUSH
57779: LD_VAR 0 5
57783: PPUSH
57784: LD_VAR 0 5
57788: PUSH
57789: LD_INT 1
57791: PLUS
57792: PPUSH
57793: LD_EXP 85
57797: PUSH
57798: LD_VAR 0 2
57802: ARRAY
57803: PPUSH
57804: CALL_OW 2
57808: ST_TO_ADDR
57809: GO 57752
57811: POP
57812: POP
// if not tmp then
57813: LD_VAR 0 5
57817: NOT
57818: IFFALSE 57822
// exit ;
57820: GO 57927
// for j in tmp do
57822: LD_ADDR_VAR 0 3
57826: PUSH
57827: LD_VAR 0 5
57831: PUSH
57832: FOR_IN
57833: IFFALSE 57925
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57835: LD_ADDR_VAR 0 6
57839: PUSH
57840: LD_INT 22
57842: PUSH
57843: LD_VAR 0 3
57847: PUSH
57848: EMPTY
57849: LIST
57850: LIST
57851: PPUSH
57852: CALL_OW 69
57856: ST_TO_ADDR
// if not un then
57857: LD_VAR 0 6
57861: NOT
57862: IFFALSE 57866
// continue ;
57864: GO 57832
// nation := GetNation ( un [ 1 ] ) ;
57866: LD_ADDR_VAR 0 4
57870: PUSH
57871: LD_VAR 0 6
57875: PUSH
57876: LD_INT 1
57878: ARRAY
57879: PPUSH
57880: CALL_OW 248
57884: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57885: LD_ADDR_EXP 86
57889: PUSH
57890: LD_EXP 86
57894: PPUSH
57895: LD_VAR 0 3
57899: PPUSH
57900: LD_VAR 0 3
57904: PPUSH
57905: LD_VAR 0 4
57909: PPUSH
57910: LD_INT 1
57912: PPUSH
57913: CALL 14867 0 3
57917: PPUSH
57918: CALL_OW 1
57922: ST_TO_ADDR
// end ;
57923: GO 57832
57925: POP
57926: POP
// end ;
57927: LD_VAR 0 1
57931: RET
// export function MC_InitSides ( ) ; var i ; begin
57932: LD_INT 0
57934: PPUSH
57935: PPUSH
// if not mc_bases then
57936: LD_EXP 59
57940: NOT
57941: IFFALSE 57945
// exit ;
57943: GO 58019
// for i = 1 to mc_bases do
57945: LD_ADDR_VAR 0 2
57949: PUSH
57950: DOUBLE
57951: LD_INT 1
57953: DEC
57954: ST_TO_ADDR
57955: LD_EXP 59
57959: PUSH
57960: FOR_TO
57961: IFFALSE 58017
// if mc_bases [ i ] then
57963: LD_EXP 59
57967: PUSH
57968: LD_VAR 0 2
57972: ARRAY
57973: IFFALSE 58015
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57975: LD_ADDR_EXP 85
57979: PUSH
57980: LD_EXP 85
57984: PPUSH
57985: LD_VAR 0 2
57989: PPUSH
57990: LD_EXP 59
57994: PUSH
57995: LD_VAR 0 2
57999: ARRAY
58000: PUSH
58001: LD_INT 1
58003: ARRAY
58004: PPUSH
58005: CALL_OW 255
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
58015: GO 57960
58017: POP
58018: POP
// end ;
58019: LD_VAR 0 1
58023: RET
// every 0 0$03 trigger skirmish do
58024: LD_EXP 57
58028: IFFALSE 58182
58030: GO 58032
58032: DISABLE
// begin enable ;
58033: ENABLE
// MC_CheckBuildings ( ) ;
58034: CALL 62680 0 0
// MC_CheckPeopleLife ( ) ;
58038: CALL 62841 0 0
// RaiseSailEvent ( 100 ) ;
58042: LD_INT 100
58044: PPUSH
58045: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58049: LD_INT 103
58051: PPUSH
58052: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58056: LD_INT 104
58058: PPUSH
58059: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58063: LD_INT 105
58065: PPUSH
58066: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58070: LD_INT 106
58072: PPUSH
58073: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58077: LD_INT 107
58079: PPUSH
58080: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58084: LD_INT 108
58086: PPUSH
58087: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58091: LD_INT 109
58093: PPUSH
58094: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58098: LD_INT 110
58100: PPUSH
58101: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58105: LD_INT 111
58107: PPUSH
58108: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58112: LD_INT 112
58114: PPUSH
58115: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58119: LD_INT 113
58121: PPUSH
58122: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58126: LD_INT 120
58128: PPUSH
58129: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58133: LD_INT 121
58135: PPUSH
58136: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58140: LD_INT 122
58142: PPUSH
58143: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58147: LD_INT 123
58149: PPUSH
58150: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58154: LD_INT 124
58156: PPUSH
58157: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58161: LD_INT 125
58163: PPUSH
58164: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58168: LD_INT 126
58170: PPUSH
58171: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58175: LD_INT 200
58177: PPUSH
58178: CALL_OW 427
// end ;
58182: END
// on SailEvent ( event ) do begin if event < 100 then
58183: LD_VAR 0 1
58187: PUSH
58188: LD_INT 100
58190: LESS
58191: IFFALSE 58202
// CustomEvent ( event ) ;
58193: LD_VAR 0 1
58197: PPUSH
58198: CALL 13513 0 1
// if event = 100 then
58202: LD_VAR 0 1
58206: PUSH
58207: LD_INT 100
58209: EQUAL
58210: IFFALSE 58216
// MC_ClassManager ( ) ;
58212: CALL 58608 0 0
// if event = 101 then
58216: LD_VAR 0 1
58220: PUSH
58221: LD_INT 101
58223: EQUAL
58224: IFFALSE 58230
// MC_RepairBuildings ( ) ;
58226: CALL 63426 0 0
// if event = 102 then
58230: LD_VAR 0 1
58234: PUSH
58235: LD_INT 102
58237: EQUAL
58238: IFFALSE 58244
// MC_Heal ( ) ;
58240: CALL 64333 0 0
// if event = 103 then
58244: LD_VAR 0 1
58248: PUSH
58249: LD_INT 103
58251: EQUAL
58252: IFFALSE 58258
// MC_Build ( ) ;
58254: CALL 64755 0 0
// if event = 104 then
58258: LD_VAR 0 1
58262: PUSH
58263: LD_INT 104
58265: EQUAL
58266: IFFALSE 58272
// MC_TurretWeapon ( ) ;
58268: CALL 66396 0 0
// if event = 105 then
58272: LD_VAR 0 1
58276: PUSH
58277: LD_INT 105
58279: EQUAL
58280: IFFALSE 58286
// MC_BuildUpgrade ( ) ;
58282: CALL 65947 0 0
// if event = 106 then
58286: LD_VAR 0 1
58290: PUSH
58291: LD_INT 106
58293: EQUAL
58294: IFFALSE 58300
// MC_PlantMines ( ) ;
58296: CALL 66826 0 0
// if event = 107 then
58300: LD_VAR 0 1
58304: PUSH
58305: LD_INT 107
58307: EQUAL
58308: IFFALSE 58314
// MC_CollectCrates ( ) ;
58310: CALL 67617 0 0
// if event = 108 then
58314: LD_VAR 0 1
58318: PUSH
58319: LD_INT 108
58321: EQUAL
58322: IFFALSE 58328
// MC_LinkRemoteControl ( ) ;
58324: CALL 69467 0 0
// if event = 109 then
58328: LD_VAR 0 1
58332: PUSH
58333: LD_INT 109
58335: EQUAL
58336: IFFALSE 58342
// MC_ProduceVehicle ( ) ;
58338: CALL 69648 0 0
// if event = 110 then
58342: LD_VAR 0 1
58346: PUSH
58347: LD_INT 110
58349: EQUAL
58350: IFFALSE 58356
// MC_SendAttack ( ) ;
58352: CALL 70114 0 0
// if event = 111 then
58356: LD_VAR 0 1
58360: PUSH
58361: LD_INT 111
58363: EQUAL
58364: IFFALSE 58370
// MC_Defend ( ) ;
58366: CALL 70222 0 0
// if event = 112 then
58370: LD_VAR 0 1
58374: PUSH
58375: LD_INT 112
58377: EQUAL
58378: IFFALSE 58384
// MC_Research ( ) ;
58380: CALL 70955 0 0
// if event = 113 then
58384: LD_VAR 0 1
58388: PUSH
58389: LD_INT 113
58391: EQUAL
58392: IFFALSE 58398
// MC_MinesTrigger ( ) ;
58394: CALL 72069 0 0
// if event = 120 then
58398: LD_VAR 0 1
58402: PUSH
58403: LD_INT 120
58405: EQUAL
58406: IFFALSE 58412
// MC_RepairVehicle ( ) ;
58408: CALL 72168 0 0
// if event = 121 then
58412: LD_VAR 0 1
58416: PUSH
58417: LD_INT 121
58419: EQUAL
58420: IFFALSE 58426
// MC_TameApe ( ) ;
58422: CALL 72909 0 0
// if event = 122 then
58426: LD_VAR 0 1
58430: PUSH
58431: LD_INT 122
58433: EQUAL
58434: IFFALSE 58440
// MC_ChangeApeClass ( ) ;
58436: CALL 73738 0 0
// if event = 123 then
58440: LD_VAR 0 1
58444: PUSH
58445: LD_INT 123
58447: EQUAL
58448: IFFALSE 58454
// MC_Bazooka ( ) ;
58450: CALL 74388 0 0
// if event = 124 then
58454: LD_VAR 0 1
58458: PUSH
58459: LD_INT 124
58461: EQUAL
58462: IFFALSE 58468
// MC_TeleportExit ( ) ;
58464: CALL 74586 0 0
// if event = 125 then
58468: LD_VAR 0 1
58472: PUSH
58473: LD_INT 125
58475: EQUAL
58476: IFFALSE 58482
// MC_Deposits ( ) ;
58478: CALL 75233 0 0
// if event = 126 then
58482: LD_VAR 0 1
58486: PUSH
58487: LD_INT 126
58489: EQUAL
58490: IFFALSE 58496
// MC_RemoteDriver ( ) ;
58492: CALL 75858 0 0
// if event = 200 then
58496: LD_VAR 0 1
58500: PUSH
58501: LD_INT 200
58503: EQUAL
58504: IFFALSE 58510
// MC_Idle ( ) ;
58506: CALL 77807 0 0
// end ;
58510: PPOPN 1
58512: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58513: LD_INT 0
58515: PPUSH
58516: PPUSH
// if not mc_bases [ base ] or not tag then
58517: LD_EXP 59
58521: PUSH
58522: LD_VAR 0 1
58526: ARRAY
58527: NOT
58528: PUSH
58529: LD_VAR 0 2
58533: NOT
58534: OR
58535: IFFALSE 58539
// exit ;
58537: GO 58603
// for i in mc_bases [ base ] union mc_ape [ base ] do
58539: LD_ADDR_VAR 0 4
58543: PUSH
58544: LD_EXP 59
58548: PUSH
58549: LD_VAR 0 1
58553: ARRAY
58554: PUSH
58555: LD_EXP 88
58559: PUSH
58560: LD_VAR 0 1
58564: ARRAY
58565: UNION
58566: PUSH
58567: FOR_IN
58568: IFFALSE 58601
// if GetTag ( i ) = tag then
58570: LD_VAR 0 4
58574: PPUSH
58575: CALL_OW 110
58579: PUSH
58580: LD_VAR 0 2
58584: EQUAL
58585: IFFALSE 58599
// SetTag ( i , 0 ) ;
58587: LD_VAR 0 4
58591: PPUSH
58592: LD_INT 0
58594: PPUSH
58595: CALL_OW 109
58599: GO 58567
58601: POP
58602: POP
// end ;
58603: LD_VAR 0 3
58607: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58608: LD_INT 0
58610: PPUSH
58611: PPUSH
58612: PPUSH
58613: PPUSH
58614: PPUSH
58615: PPUSH
58616: PPUSH
58617: PPUSH
// if not mc_bases then
58618: LD_EXP 59
58622: NOT
58623: IFFALSE 58627
// exit ;
58625: GO 59085
// for i = 1 to mc_bases do
58627: LD_ADDR_VAR 0 2
58631: PUSH
58632: DOUBLE
58633: LD_INT 1
58635: DEC
58636: ST_TO_ADDR
58637: LD_EXP 59
58641: PUSH
58642: FOR_TO
58643: IFFALSE 59083
// begin tmp := MC_ClassCheckReq ( i ) ;
58645: LD_ADDR_VAR 0 4
58649: PUSH
58650: LD_VAR 0 2
58654: PPUSH
58655: CALL 59090 0 1
58659: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58660: LD_ADDR_EXP 100
58664: PUSH
58665: LD_EXP 100
58669: PPUSH
58670: LD_VAR 0 2
58674: PPUSH
58675: LD_VAR 0 4
58679: PPUSH
58680: CALL_OW 1
58684: ST_TO_ADDR
// if not tmp then
58685: LD_VAR 0 4
58689: NOT
58690: IFFALSE 58694
// continue ;
58692: GO 58642
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58694: LD_ADDR_VAR 0 6
58698: PUSH
58699: LD_EXP 59
58703: PUSH
58704: LD_VAR 0 2
58708: ARRAY
58709: PPUSH
58710: LD_INT 2
58712: PUSH
58713: LD_INT 30
58715: PUSH
58716: LD_INT 4
58718: PUSH
58719: EMPTY
58720: LIST
58721: LIST
58722: PUSH
58723: LD_INT 30
58725: PUSH
58726: LD_INT 5
58728: PUSH
58729: EMPTY
58730: LIST
58731: LIST
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: LIST
58737: PPUSH
58738: CALL_OW 72
58742: PUSH
58743: LD_EXP 59
58747: PUSH
58748: LD_VAR 0 2
58752: ARRAY
58753: PPUSH
58754: LD_INT 2
58756: PUSH
58757: LD_INT 30
58759: PUSH
58760: LD_INT 0
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: PUSH
58767: LD_INT 30
58769: PUSH
58770: LD_INT 1
58772: PUSH
58773: EMPTY
58774: LIST
58775: LIST
58776: PUSH
58777: EMPTY
58778: LIST
58779: LIST
58780: LIST
58781: PPUSH
58782: CALL_OW 72
58786: PUSH
58787: LD_EXP 59
58791: PUSH
58792: LD_VAR 0 2
58796: ARRAY
58797: PPUSH
58798: LD_INT 30
58800: PUSH
58801: LD_INT 3
58803: PUSH
58804: EMPTY
58805: LIST
58806: LIST
58807: PPUSH
58808: CALL_OW 72
58812: PUSH
58813: LD_EXP 59
58817: PUSH
58818: LD_VAR 0 2
58822: ARRAY
58823: PPUSH
58824: LD_INT 2
58826: PUSH
58827: LD_INT 30
58829: PUSH
58830: LD_INT 6
58832: PUSH
58833: EMPTY
58834: LIST
58835: LIST
58836: PUSH
58837: LD_INT 30
58839: PUSH
58840: LD_INT 7
58842: PUSH
58843: EMPTY
58844: LIST
58845: LIST
58846: PUSH
58847: LD_INT 30
58849: PUSH
58850: LD_INT 8
58852: PUSH
58853: EMPTY
58854: LIST
58855: LIST
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: LIST
58861: LIST
58862: PPUSH
58863: CALL_OW 72
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: LIST
58872: LIST
58873: ST_TO_ADDR
// for j = 1 to 4 do
58874: LD_ADDR_VAR 0 3
58878: PUSH
58879: DOUBLE
58880: LD_INT 1
58882: DEC
58883: ST_TO_ADDR
58884: LD_INT 4
58886: PUSH
58887: FOR_TO
58888: IFFALSE 59079
// begin if not tmp [ j ] then
58890: LD_VAR 0 4
58894: PUSH
58895: LD_VAR 0 3
58899: ARRAY
58900: NOT
58901: IFFALSE 58905
// continue ;
58903: GO 58887
// for p in tmp [ j ] do
58905: LD_ADDR_VAR 0 5
58909: PUSH
58910: LD_VAR 0 4
58914: PUSH
58915: LD_VAR 0 3
58919: ARRAY
58920: PUSH
58921: FOR_IN
58922: IFFALSE 59075
// begin if not b [ j ] then
58924: LD_VAR 0 6
58928: PUSH
58929: LD_VAR 0 3
58933: ARRAY
58934: NOT
58935: IFFALSE 58939
// break ;
58937: GO 59075
// e := 0 ;
58939: LD_ADDR_VAR 0 7
58943: PUSH
58944: LD_INT 0
58946: ST_TO_ADDR
// for k in b [ j ] do
58947: LD_ADDR_VAR 0 8
58951: PUSH
58952: LD_VAR 0 6
58956: PUSH
58957: LD_VAR 0 3
58961: ARRAY
58962: PUSH
58963: FOR_IN
58964: IFFALSE 58991
// if IsNotFull ( k ) then
58966: LD_VAR 0 8
58970: PPUSH
58971: CALL 17020 0 1
58975: IFFALSE 58989
// begin e := k ;
58977: LD_ADDR_VAR 0 7
58981: PUSH
58982: LD_VAR 0 8
58986: ST_TO_ADDR
// break ;
58987: GO 58991
// end ;
58989: GO 58963
58991: POP
58992: POP
// if e and not UnitGoingToBuilding ( p , e ) then
58993: LD_VAR 0 7
58997: PUSH
58998: LD_VAR 0 5
59002: PPUSH
59003: LD_VAR 0 7
59007: PPUSH
59008: CALL 50184 0 2
59012: NOT
59013: AND
59014: IFFALSE 59073
// begin if IsInUnit ( p ) then
59016: LD_VAR 0 5
59020: PPUSH
59021: CALL_OW 310
59025: IFFALSE 59036
// ComExitBuilding ( p ) ;
59027: LD_VAR 0 5
59031: PPUSH
59032: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59036: LD_VAR 0 5
59040: PPUSH
59041: LD_VAR 0 7
59045: PPUSH
59046: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59050: LD_VAR 0 5
59054: PPUSH
59055: LD_VAR 0 3
59059: PPUSH
59060: CALL_OW 183
// AddComExitBuilding ( p ) ;
59064: LD_VAR 0 5
59068: PPUSH
59069: CALL_OW 182
// end ; end ;
59073: GO 58921
59075: POP
59076: POP
// end ;
59077: GO 58887
59079: POP
59080: POP
// end ;
59081: GO 58642
59083: POP
59084: POP
// end ;
59085: LD_VAR 0 1
59089: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59090: LD_INT 0
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
59097: PPUSH
59098: PPUSH
59099: PPUSH
59100: PPUSH
59101: PPUSH
59102: PPUSH
59103: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59104: LD_VAR 0 1
59108: NOT
59109: PUSH
59110: LD_EXP 59
59114: PUSH
59115: LD_VAR 0 1
59119: ARRAY
59120: NOT
59121: OR
59122: PUSH
59123: LD_EXP 59
59127: PUSH
59128: LD_VAR 0 1
59132: ARRAY
59133: PPUSH
59134: LD_INT 2
59136: PUSH
59137: LD_INT 30
59139: PUSH
59140: LD_INT 0
59142: PUSH
59143: EMPTY
59144: LIST
59145: LIST
59146: PUSH
59147: LD_INT 30
59149: PUSH
59150: LD_INT 1
59152: PUSH
59153: EMPTY
59154: LIST
59155: LIST
59156: PUSH
59157: EMPTY
59158: LIST
59159: LIST
59160: LIST
59161: PPUSH
59162: CALL_OW 72
59166: NOT
59167: OR
59168: IFFALSE 59172
// exit ;
59170: GO 62675
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59172: LD_ADDR_VAR 0 4
59176: PUSH
59177: LD_EXP 59
59181: PUSH
59182: LD_VAR 0 1
59186: ARRAY
59187: PPUSH
59188: LD_INT 2
59190: PUSH
59191: LD_INT 25
59193: PUSH
59194: LD_INT 1
59196: PUSH
59197: EMPTY
59198: LIST
59199: LIST
59200: PUSH
59201: LD_INT 25
59203: PUSH
59204: LD_INT 2
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: PUSH
59211: LD_INT 25
59213: PUSH
59214: LD_INT 3
59216: PUSH
59217: EMPTY
59218: LIST
59219: LIST
59220: PUSH
59221: LD_INT 25
59223: PUSH
59224: LD_INT 4
59226: PUSH
59227: EMPTY
59228: LIST
59229: LIST
59230: PUSH
59231: LD_INT 25
59233: PUSH
59234: LD_INT 5
59236: PUSH
59237: EMPTY
59238: LIST
59239: LIST
59240: PUSH
59241: LD_INT 25
59243: PUSH
59244: LD_INT 8
59246: PUSH
59247: EMPTY
59248: LIST
59249: LIST
59250: PUSH
59251: LD_INT 25
59253: PUSH
59254: LD_INT 9
59256: PUSH
59257: EMPTY
59258: LIST
59259: LIST
59260: PUSH
59261: EMPTY
59262: LIST
59263: LIST
59264: LIST
59265: LIST
59266: LIST
59267: LIST
59268: LIST
59269: LIST
59270: PPUSH
59271: CALL_OW 72
59275: ST_TO_ADDR
// if not tmp then
59276: LD_VAR 0 4
59280: NOT
59281: IFFALSE 59285
// exit ;
59283: GO 62675
// for i in tmp do
59285: LD_ADDR_VAR 0 3
59289: PUSH
59290: LD_VAR 0 4
59294: PUSH
59295: FOR_IN
59296: IFFALSE 59327
// if GetTag ( i ) then
59298: LD_VAR 0 3
59302: PPUSH
59303: CALL_OW 110
59307: IFFALSE 59325
// tmp := tmp diff i ;
59309: LD_ADDR_VAR 0 4
59313: PUSH
59314: LD_VAR 0 4
59318: PUSH
59319: LD_VAR 0 3
59323: DIFF
59324: ST_TO_ADDR
59325: GO 59295
59327: POP
59328: POP
// if not tmp then
59329: LD_VAR 0 4
59333: NOT
59334: IFFALSE 59338
// exit ;
59336: GO 62675
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59338: LD_ADDR_VAR 0 5
59342: PUSH
59343: LD_EXP 59
59347: PUSH
59348: LD_VAR 0 1
59352: ARRAY
59353: PPUSH
59354: LD_INT 2
59356: PUSH
59357: LD_INT 25
59359: PUSH
59360: LD_INT 1
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 25
59369: PUSH
59370: LD_INT 5
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: LD_INT 25
59379: PUSH
59380: LD_INT 8
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: LD_INT 25
59389: PUSH
59390: LD_INT 9
59392: PUSH
59393: EMPTY
59394: LIST
59395: LIST
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: LIST
59401: LIST
59402: LIST
59403: PPUSH
59404: CALL_OW 72
59408: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59409: LD_ADDR_VAR 0 6
59413: PUSH
59414: LD_EXP 59
59418: PUSH
59419: LD_VAR 0 1
59423: ARRAY
59424: PPUSH
59425: LD_INT 25
59427: PUSH
59428: LD_INT 2
59430: PUSH
59431: EMPTY
59432: LIST
59433: LIST
59434: PPUSH
59435: CALL_OW 72
59439: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59440: LD_ADDR_VAR 0 7
59444: PUSH
59445: LD_EXP 59
59449: PUSH
59450: LD_VAR 0 1
59454: ARRAY
59455: PPUSH
59456: LD_INT 25
59458: PUSH
59459: LD_INT 3
59461: PUSH
59462: EMPTY
59463: LIST
59464: LIST
59465: PPUSH
59466: CALL_OW 72
59470: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59471: LD_ADDR_VAR 0 8
59475: PUSH
59476: LD_EXP 59
59480: PUSH
59481: LD_VAR 0 1
59485: ARRAY
59486: PPUSH
59487: LD_INT 25
59489: PUSH
59490: LD_INT 4
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 24
59499: PUSH
59500: LD_INT 251
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: EMPTY
59508: LIST
59509: LIST
59510: PPUSH
59511: CALL_OW 72
59515: ST_TO_ADDR
// if mc_is_defending [ base ] then
59516: LD_EXP 102
59520: PUSH
59521: LD_VAR 0 1
59525: ARRAY
59526: IFFALSE 59987
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59528: LD_ADDR_EXP 101
59532: PUSH
59533: LD_EXP 101
59537: PPUSH
59538: LD_VAR 0 1
59542: PPUSH
59543: LD_INT 4
59545: PPUSH
59546: CALL_OW 1
59550: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59551: LD_ADDR_VAR 0 12
59555: PUSH
59556: LD_EXP 59
59560: PUSH
59561: LD_VAR 0 1
59565: ARRAY
59566: PPUSH
59567: LD_INT 2
59569: PUSH
59570: LD_INT 30
59572: PUSH
59573: LD_INT 4
59575: PUSH
59576: EMPTY
59577: LIST
59578: LIST
59579: PUSH
59580: LD_INT 30
59582: PUSH
59583: LD_INT 5
59585: PUSH
59586: EMPTY
59587: LIST
59588: LIST
59589: PUSH
59590: EMPTY
59591: LIST
59592: LIST
59593: LIST
59594: PPUSH
59595: CALL_OW 72
59599: ST_TO_ADDR
// if not b then
59600: LD_VAR 0 12
59604: NOT
59605: IFFALSE 59609
// exit ;
59607: GO 62675
// p := [ ] ;
59609: LD_ADDR_VAR 0 11
59613: PUSH
59614: EMPTY
59615: ST_TO_ADDR
// if sci >= 2 then
59616: LD_VAR 0 8
59620: PUSH
59621: LD_INT 2
59623: GREATEREQUAL
59624: IFFALSE 59655
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59626: LD_ADDR_VAR 0 8
59630: PUSH
59631: LD_VAR 0 8
59635: PUSH
59636: LD_INT 1
59638: ARRAY
59639: PUSH
59640: LD_VAR 0 8
59644: PUSH
59645: LD_INT 2
59647: ARRAY
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: ST_TO_ADDR
59653: GO 59716
// if sci = 1 then
59655: LD_VAR 0 8
59659: PUSH
59660: LD_INT 1
59662: EQUAL
59663: IFFALSE 59684
// sci := [ sci [ 1 ] ] else
59665: LD_ADDR_VAR 0 8
59669: PUSH
59670: LD_VAR 0 8
59674: PUSH
59675: LD_INT 1
59677: ARRAY
59678: PUSH
59679: EMPTY
59680: LIST
59681: ST_TO_ADDR
59682: GO 59716
// if sci = 0 then
59684: LD_VAR 0 8
59688: PUSH
59689: LD_INT 0
59691: EQUAL
59692: IFFALSE 59716
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59694: LD_ADDR_VAR 0 11
59698: PUSH
59699: LD_VAR 0 4
59703: PPUSH
59704: LD_INT 4
59706: PPUSH
59707: CALL 50047 0 2
59711: PUSH
59712: LD_INT 1
59714: ARRAY
59715: ST_TO_ADDR
// if eng > 4 then
59716: LD_VAR 0 6
59720: PUSH
59721: LD_INT 4
59723: GREATER
59724: IFFALSE 59770
// for i = eng downto 4 do
59726: LD_ADDR_VAR 0 3
59730: PUSH
59731: DOUBLE
59732: LD_VAR 0 6
59736: INC
59737: ST_TO_ADDR
59738: LD_INT 4
59740: PUSH
59741: FOR_DOWNTO
59742: IFFALSE 59768
// eng := eng diff eng [ i ] ;
59744: LD_ADDR_VAR 0 6
59748: PUSH
59749: LD_VAR 0 6
59753: PUSH
59754: LD_VAR 0 6
59758: PUSH
59759: LD_VAR 0 3
59763: ARRAY
59764: DIFF
59765: ST_TO_ADDR
59766: GO 59741
59768: POP
59769: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59770: LD_ADDR_VAR 0 4
59774: PUSH
59775: LD_VAR 0 4
59779: PUSH
59780: LD_VAR 0 5
59784: PUSH
59785: LD_VAR 0 6
59789: UNION
59790: PUSH
59791: LD_VAR 0 7
59795: UNION
59796: PUSH
59797: LD_VAR 0 8
59801: UNION
59802: DIFF
59803: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59804: LD_ADDR_VAR 0 13
59808: PUSH
59809: LD_EXP 59
59813: PUSH
59814: LD_VAR 0 1
59818: ARRAY
59819: PPUSH
59820: LD_INT 2
59822: PUSH
59823: LD_INT 30
59825: PUSH
59826: LD_INT 32
59828: PUSH
59829: EMPTY
59830: LIST
59831: LIST
59832: PUSH
59833: LD_INT 30
59835: PUSH
59836: LD_INT 31
59838: PUSH
59839: EMPTY
59840: LIST
59841: LIST
59842: PUSH
59843: EMPTY
59844: LIST
59845: LIST
59846: LIST
59847: PPUSH
59848: CALL_OW 72
59852: PUSH
59853: LD_EXP 59
59857: PUSH
59858: LD_VAR 0 1
59862: ARRAY
59863: PPUSH
59864: LD_INT 2
59866: PUSH
59867: LD_INT 30
59869: PUSH
59870: LD_INT 4
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PUSH
59877: LD_INT 30
59879: PUSH
59880: LD_INT 5
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: PUSH
59887: EMPTY
59888: LIST
59889: LIST
59890: LIST
59891: PPUSH
59892: CALL_OW 72
59896: PUSH
59897: LD_INT 6
59899: MUL
59900: PLUS
59901: ST_TO_ADDR
// if bcount < tmp then
59902: LD_VAR 0 13
59906: PUSH
59907: LD_VAR 0 4
59911: LESS
59912: IFFALSE 59958
// for i = tmp downto bcount do
59914: LD_ADDR_VAR 0 3
59918: PUSH
59919: DOUBLE
59920: LD_VAR 0 4
59924: INC
59925: ST_TO_ADDR
59926: LD_VAR 0 13
59930: PUSH
59931: FOR_DOWNTO
59932: IFFALSE 59956
// tmp := Delete ( tmp , tmp ) ;
59934: LD_ADDR_VAR 0 4
59938: PUSH
59939: LD_VAR 0 4
59943: PPUSH
59944: LD_VAR 0 4
59948: PPUSH
59949: CALL_OW 3
59953: ST_TO_ADDR
59954: GO 59931
59956: POP
59957: POP
// result := [ tmp , 0 , 0 , p ] ;
59958: LD_ADDR_VAR 0 2
59962: PUSH
59963: LD_VAR 0 4
59967: PUSH
59968: LD_INT 0
59970: PUSH
59971: LD_INT 0
59973: PUSH
59974: LD_VAR 0 11
59978: PUSH
59979: EMPTY
59980: LIST
59981: LIST
59982: LIST
59983: LIST
59984: ST_TO_ADDR
// exit ;
59985: GO 62675
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59987: LD_EXP 59
59991: PUSH
59992: LD_VAR 0 1
59996: ARRAY
59997: PPUSH
59998: LD_INT 2
60000: PUSH
60001: LD_INT 30
60003: PUSH
60004: LD_INT 6
60006: PUSH
60007: EMPTY
60008: LIST
60009: LIST
60010: PUSH
60011: LD_INT 30
60013: PUSH
60014: LD_INT 7
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 30
60023: PUSH
60024: LD_INT 8
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: EMPTY
60032: LIST
60033: LIST
60034: LIST
60035: LIST
60036: PPUSH
60037: CALL_OW 72
60041: NOT
60042: PUSH
60043: LD_EXP 59
60047: PUSH
60048: LD_VAR 0 1
60052: ARRAY
60053: PPUSH
60054: LD_INT 30
60056: PUSH
60057: LD_INT 3
60059: PUSH
60060: EMPTY
60061: LIST
60062: LIST
60063: PPUSH
60064: CALL_OW 72
60068: NOT
60069: AND
60070: IFFALSE 60142
// begin if eng = tmp then
60072: LD_VAR 0 6
60076: PUSH
60077: LD_VAR 0 4
60081: EQUAL
60082: IFFALSE 60086
// exit ;
60084: GO 62675
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60086: LD_ADDR_EXP 101
60090: PUSH
60091: LD_EXP 101
60095: PPUSH
60096: LD_VAR 0 1
60100: PPUSH
60101: LD_INT 1
60103: PPUSH
60104: CALL_OW 1
60108: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60109: LD_ADDR_VAR 0 2
60113: PUSH
60114: LD_INT 0
60116: PUSH
60117: LD_VAR 0 4
60121: PUSH
60122: LD_VAR 0 6
60126: DIFF
60127: PUSH
60128: LD_INT 0
60130: PUSH
60131: LD_INT 0
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: LIST
60138: LIST
60139: ST_TO_ADDR
// exit ;
60140: GO 62675
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60142: LD_EXP 86
60146: PUSH
60147: LD_EXP 85
60151: PUSH
60152: LD_VAR 0 1
60156: ARRAY
60157: ARRAY
60158: PUSH
60159: LD_EXP 59
60163: PUSH
60164: LD_VAR 0 1
60168: ARRAY
60169: PPUSH
60170: LD_INT 2
60172: PUSH
60173: LD_INT 30
60175: PUSH
60176: LD_INT 6
60178: PUSH
60179: EMPTY
60180: LIST
60181: LIST
60182: PUSH
60183: LD_INT 30
60185: PUSH
60186: LD_INT 7
60188: PUSH
60189: EMPTY
60190: LIST
60191: LIST
60192: PUSH
60193: LD_INT 30
60195: PUSH
60196: LD_INT 8
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: PUSH
60203: EMPTY
60204: LIST
60205: LIST
60206: LIST
60207: LIST
60208: PPUSH
60209: CALL_OW 72
60213: AND
60214: PUSH
60215: LD_EXP 59
60219: PUSH
60220: LD_VAR 0 1
60224: ARRAY
60225: PPUSH
60226: LD_INT 30
60228: PUSH
60229: LD_INT 3
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: PPUSH
60236: CALL_OW 72
60240: NOT
60241: AND
60242: IFFALSE 60456
// begin if sci >= 6 then
60244: LD_VAR 0 8
60248: PUSH
60249: LD_INT 6
60251: GREATEREQUAL
60252: IFFALSE 60256
// exit ;
60254: GO 62675
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60256: LD_ADDR_EXP 101
60260: PUSH
60261: LD_EXP 101
60265: PPUSH
60266: LD_VAR 0 1
60270: PPUSH
60271: LD_INT 2
60273: PPUSH
60274: CALL_OW 1
60278: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60279: LD_ADDR_VAR 0 9
60283: PUSH
60284: LD_VAR 0 4
60288: PUSH
60289: LD_VAR 0 8
60293: DIFF
60294: PPUSH
60295: LD_INT 4
60297: PPUSH
60298: CALL 50047 0 2
60302: ST_TO_ADDR
// p := [ ] ;
60303: LD_ADDR_VAR 0 11
60307: PUSH
60308: EMPTY
60309: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60310: LD_VAR 0 8
60314: PUSH
60315: LD_INT 6
60317: LESS
60318: PUSH
60319: LD_VAR 0 9
60323: PUSH
60324: LD_INT 6
60326: GREATER
60327: AND
60328: IFFALSE 60409
// begin for i = 1 to 6 - sci do
60330: LD_ADDR_VAR 0 3
60334: PUSH
60335: DOUBLE
60336: LD_INT 1
60338: DEC
60339: ST_TO_ADDR
60340: LD_INT 6
60342: PUSH
60343: LD_VAR 0 8
60347: MINUS
60348: PUSH
60349: FOR_TO
60350: IFFALSE 60405
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60352: LD_ADDR_VAR 0 11
60356: PUSH
60357: LD_VAR 0 11
60361: PPUSH
60362: LD_VAR 0 11
60366: PUSH
60367: LD_INT 1
60369: PLUS
60370: PPUSH
60371: LD_VAR 0 9
60375: PUSH
60376: LD_INT 1
60378: ARRAY
60379: PPUSH
60380: CALL_OW 2
60384: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60385: LD_ADDR_VAR 0 9
60389: PUSH
60390: LD_VAR 0 9
60394: PPUSH
60395: LD_INT 1
60397: PPUSH
60398: CALL_OW 3
60402: ST_TO_ADDR
// end ;
60403: GO 60349
60405: POP
60406: POP
// end else
60407: GO 60429
// if sort then
60409: LD_VAR 0 9
60413: IFFALSE 60429
// p := sort [ 1 ] ;
60415: LD_ADDR_VAR 0 11
60419: PUSH
60420: LD_VAR 0 9
60424: PUSH
60425: LD_INT 1
60427: ARRAY
60428: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60429: LD_ADDR_VAR 0 2
60433: PUSH
60434: LD_INT 0
60436: PUSH
60437: LD_INT 0
60439: PUSH
60440: LD_INT 0
60442: PUSH
60443: LD_VAR 0 11
60447: PUSH
60448: EMPTY
60449: LIST
60450: LIST
60451: LIST
60452: LIST
60453: ST_TO_ADDR
// exit ;
60454: GO 62675
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60456: LD_EXP 86
60460: PUSH
60461: LD_EXP 85
60465: PUSH
60466: LD_VAR 0 1
60470: ARRAY
60471: ARRAY
60472: PUSH
60473: LD_EXP 59
60477: PUSH
60478: LD_VAR 0 1
60482: ARRAY
60483: PPUSH
60484: LD_INT 2
60486: PUSH
60487: LD_INT 30
60489: PUSH
60490: LD_INT 6
60492: PUSH
60493: EMPTY
60494: LIST
60495: LIST
60496: PUSH
60497: LD_INT 30
60499: PUSH
60500: LD_INT 7
60502: PUSH
60503: EMPTY
60504: LIST
60505: LIST
60506: PUSH
60507: LD_INT 30
60509: PUSH
60510: LD_INT 8
60512: PUSH
60513: EMPTY
60514: LIST
60515: LIST
60516: PUSH
60517: EMPTY
60518: LIST
60519: LIST
60520: LIST
60521: LIST
60522: PPUSH
60523: CALL_OW 72
60527: AND
60528: PUSH
60529: LD_EXP 59
60533: PUSH
60534: LD_VAR 0 1
60538: ARRAY
60539: PPUSH
60540: LD_INT 30
60542: PUSH
60543: LD_INT 3
60545: PUSH
60546: EMPTY
60547: LIST
60548: LIST
60549: PPUSH
60550: CALL_OW 72
60554: AND
60555: IFFALSE 61289
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60557: LD_ADDR_EXP 101
60561: PUSH
60562: LD_EXP 101
60566: PPUSH
60567: LD_VAR 0 1
60571: PPUSH
60572: LD_INT 3
60574: PPUSH
60575: CALL_OW 1
60579: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60580: LD_ADDR_VAR 0 2
60584: PUSH
60585: LD_INT 0
60587: PUSH
60588: LD_INT 0
60590: PUSH
60591: LD_INT 0
60593: PUSH
60594: LD_INT 0
60596: PUSH
60597: EMPTY
60598: LIST
60599: LIST
60600: LIST
60601: LIST
60602: ST_TO_ADDR
// if not eng then
60603: LD_VAR 0 6
60607: NOT
60608: IFFALSE 60671
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60610: LD_ADDR_VAR 0 11
60614: PUSH
60615: LD_VAR 0 4
60619: PPUSH
60620: LD_INT 2
60622: PPUSH
60623: CALL 50047 0 2
60627: PUSH
60628: LD_INT 1
60630: ARRAY
60631: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60632: LD_ADDR_VAR 0 2
60636: PUSH
60637: LD_VAR 0 2
60641: PPUSH
60642: LD_INT 2
60644: PPUSH
60645: LD_VAR 0 11
60649: PPUSH
60650: CALL_OW 1
60654: ST_TO_ADDR
// tmp := tmp diff p ;
60655: LD_ADDR_VAR 0 4
60659: PUSH
60660: LD_VAR 0 4
60664: PUSH
60665: LD_VAR 0 11
60669: DIFF
60670: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60671: LD_VAR 0 4
60675: PUSH
60676: LD_VAR 0 8
60680: PUSH
60681: LD_INT 6
60683: LESS
60684: AND
60685: IFFALSE 60873
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60687: LD_ADDR_VAR 0 9
60691: PUSH
60692: LD_VAR 0 4
60696: PUSH
60697: LD_VAR 0 8
60701: PUSH
60702: LD_VAR 0 7
60706: UNION
60707: DIFF
60708: PPUSH
60709: LD_INT 4
60711: PPUSH
60712: CALL 50047 0 2
60716: ST_TO_ADDR
// p := [ ] ;
60717: LD_ADDR_VAR 0 11
60721: PUSH
60722: EMPTY
60723: ST_TO_ADDR
// if sort then
60724: LD_VAR 0 9
60728: IFFALSE 60844
// for i = 1 to 6 - sci do
60730: LD_ADDR_VAR 0 3
60734: PUSH
60735: DOUBLE
60736: LD_INT 1
60738: DEC
60739: ST_TO_ADDR
60740: LD_INT 6
60742: PUSH
60743: LD_VAR 0 8
60747: MINUS
60748: PUSH
60749: FOR_TO
60750: IFFALSE 60842
// begin if i = sort then
60752: LD_VAR 0 3
60756: PUSH
60757: LD_VAR 0 9
60761: EQUAL
60762: IFFALSE 60766
// break ;
60764: GO 60842
// if GetClass ( i ) = 4 then
60766: LD_VAR 0 3
60770: PPUSH
60771: CALL_OW 257
60775: PUSH
60776: LD_INT 4
60778: EQUAL
60779: IFFALSE 60783
// continue ;
60781: GO 60749
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60783: LD_ADDR_VAR 0 11
60787: PUSH
60788: LD_VAR 0 11
60792: PPUSH
60793: LD_VAR 0 11
60797: PUSH
60798: LD_INT 1
60800: PLUS
60801: PPUSH
60802: LD_VAR 0 9
60806: PUSH
60807: LD_VAR 0 3
60811: ARRAY
60812: PPUSH
60813: CALL_OW 2
60817: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60818: LD_ADDR_VAR 0 4
60822: PUSH
60823: LD_VAR 0 4
60827: PUSH
60828: LD_VAR 0 9
60832: PUSH
60833: LD_VAR 0 3
60837: ARRAY
60838: DIFF
60839: ST_TO_ADDR
// end ;
60840: GO 60749
60842: POP
60843: POP
// if p then
60844: LD_VAR 0 11
60848: IFFALSE 60873
// result := Replace ( result , 4 , p ) ;
60850: LD_ADDR_VAR 0 2
60854: PUSH
60855: LD_VAR 0 2
60859: PPUSH
60860: LD_INT 4
60862: PPUSH
60863: LD_VAR 0 11
60867: PPUSH
60868: CALL_OW 1
60872: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60873: LD_VAR 0 4
60877: PUSH
60878: LD_VAR 0 7
60882: PUSH
60883: LD_INT 6
60885: LESS
60886: AND
60887: IFFALSE 61075
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60889: LD_ADDR_VAR 0 9
60893: PUSH
60894: LD_VAR 0 4
60898: PUSH
60899: LD_VAR 0 8
60903: PUSH
60904: LD_VAR 0 7
60908: UNION
60909: DIFF
60910: PPUSH
60911: LD_INT 3
60913: PPUSH
60914: CALL 50047 0 2
60918: ST_TO_ADDR
// p := [ ] ;
60919: LD_ADDR_VAR 0 11
60923: PUSH
60924: EMPTY
60925: ST_TO_ADDR
// if sort then
60926: LD_VAR 0 9
60930: IFFALSE 61046
// for i = 1 to 6 - mech do
60932: LD_ADDR_VAR 0 3
60936: PUSH
60937: DOUBLE
60938: LD_INT 1
60940: DEC
60941: ST_TO_ADDR
60942: LD_INT 6
60944: PUSH
60945: LD_VAR 0 7
60949: MINUS
60950: PUSH
60951: FOR_TO
60952: IFFALSE 61044
// begin if i = sort then
60954: LD_VAR 0 3
60958: PUSH
60959: LD_VAR 0 9
60963: EQUAL
60964: IFFALSE 60968
// break ;
60966: GO 61044
// if GetClass ( i ) = 3 then
60968: LD_VAR 0 3
60972: PPUSH
60973: CALL_OW 257
60977: PUSH
60978: LD_INT 3
60980: EQUAL
60981: IFFALSE 60985
// continue ;
60983: GO 60951
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60985: LD_ADDR_VAR 0 11
60989: PUSH
60990: LD_VAR 0 11
60994: PPUSH
60995: LD_VAR 0 11
60999: PUSH
61000: LD_INT 1
61002: PLUS
61003: PPUSH
61004: LD_VAR 0 9
61008: PUSH
61009: LD_VAR 0 3
61013: ARRAY
61014: PPUSH
61015: CALL_OW 2
61019: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61020: LD_ADDR_VAR 0 4
61024: PUSH
61025: LD_VAR 0 4
61029: PUSH
61030: LD_VAR 0 9
61034: PUSH
61035: LD_VAR 0 3
61039: ARRAY
61040: DIFF
61041: ST_TO_ADDR
// end ;
61042: GO 60951
61044: POP
61045: POP
// if p then
61046: LD_VAR 0 11
61050: IFFALSE 61075
// result := Replace ( result , 3 , p ) ;
61052: LD_ADDR_VAR 0 2
61056: PUSH
61057: LD_VAR 0 2
61061: PPUSH
61062: LD_INT 3
61064: PPUSH
61065: LD_VAR 0 11
61069: PPUSH
61070: CALL_OW 1
61074: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61075: LD_VAR 0 4
61079: PUSH
61080: LD_INT 6
61082: GREATER
61083: PUSH
61084: LD_VAR 0 6
61088: PUSH
61089: LD_INT 6
61091: LESS
61092: AND
61093: IFFALSE 61287
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61095: LD_ADDR_VAR 0 9
61099: PUSH
61100: LD_VAR 0 4
61104: PUSH
61105: LD_VAR 0 8
61109: PUSH
61110: LD_VAR 0 7
61114: UNION
61115: PUSH
61116: LD_VAR 0 6
61120: UNION
61121: DIFF
61122: PPUSH
61123: LD_INT 2
61125: PPUSH
61126: CALL 50047 0 2
61130: ST_TO_ADDR
// p := [ ] ;
61131: LD_ADDR_VAR 0 11
61135: PUSH
61136: EMPTY
61137: ST_TO_ADDR
// if sort then
61138: LD_VAR 0 9
61142: IFFALSE 61258
// for i = 1 to 6 - eng do
61144: LD_ADDR_VAR 0 3
61148: PUSH
61149: DOUBLE
61150: LD_INT 1
61152: DEC
61153: ST_TO_ADDR
61154: LD_INT 6
61156: PUSH
61157: LD_VAR 0 6
61161: MINUS
61162: PUSH
61163: FOR_TO
61164: IFFALSE 61256
// begin if i = sort then
61166: LD_VAR 0 3
61170: PUSH
61171: LD_VAR 0 9
61175: EQUAL
61176: IFFALSE 61180
// break ;
61178: GO 61256
// if GetClass ( i ) = 2 then
61180: LD_VAR 0 3
61184: PPUSH
61185: CALL_OW 257
61189: PUSH
61190: LD_INT 2
61192: EQUAL
61193: IFFALSE 61197
// continue ;
61195: GO 61163
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61197: LD_ADDR_VAR 0 11
61201: PUSH
61202: LD_VAR 0 11
61206: PPUSH
61207: LD_VAR 0 11
61211: PUSH
61212: LD_INT 1
61214: PLUS
61215: PPUSH
61216: LD_VAR 0 9
61220: PUSH
61221: LD_VAR 0 3
61225: ARRAY
61226: PPUSH
61227: CALL_OW 2
61231: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61232: LD_ADDR_VAR 0 4
61236: PUSH
61237: LD_VAR 0 4
61241: PUSH
61242: LD_VAR 0 9
61246: PUSH
61247: LD_VAR 0 3
61251: ARRAY
61252: DIFF
61253: ST_TO_ADDR
// end ;
61254: GO 61163
61256: POP
61257: POP
// if p then
61258: LD_VAR 0 11
61262: IFFALSE 61287
// result := Replace ( result , 2 , p ) ;
61264: LD_ADDR_VAR 0 2
61268: PUSH
61269: LD_VAR 0 2
61273: PPUSH
61274: LD_INT 2
61276: PPUSH
61277: LD_VAR 0 11
61281: PPUSH
61282: CALL_OW 1
61286: ST_TO_ADDR
// end ; exit ;
61287: GO 62675
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61289: LD_EXP 86
61293: PUSH
61294: LD_EXP 85
61298: PUSH
61299: LD_VAR 0 1
61303: ARRAY
61304: ARRAY
61305: NOT
61306: PUSH
61307: LD_EXP 59
61311: PUSH
61312: LD_VAR 0 1
61316: ARRAY
61317: PPUSH
61318: LD_INT 30
61320: PUSH
61321: LD_INT 3
61323: PUSH
61324: EMPTY
61325: LIST
61326: LIST
61327: PPUSH
61328: CALL_OW 72
61332: AND
61333: PUSH
61334: LD_EXP 64
61338: PUSH
61339: LD_VAR 0 1
61343: ARRAY
61344: AND
61345: IFFALSE 61953
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61347: LD_ADDR_EXP 101
61351: PUSH
61352: LD_EXP 101
61356: PPUSH
61357: LD_VAR 0 1
61361: PPUSH
61362: LD_INT 5
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61370: LD_ADDR_VAR 0 2
61374: PUSH
61375: LD_INT 0
61377: PUSH
61378: LD_INT 0
61380: PUSH
61381: LD_INT 0
61383: PUSH
61384: LD_INT 0
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: LIST
61391: LIST
61392: ST_TO_ADDR
// if sci > 1 then
61393: LD_VAR 0 8
61397: PUSH
61398: LD_INT 1
61400: GREATER
61401: IFFALSE 61429
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61403: LD_ADDR_VAR 0 4
61407: PUSH
61408: LD_VAR 0 4
61412: PUSH
61413: LD_VAR 0 8
61417: PUSH
61418: LD_VAR 0 8
61422: PUSH
61423: LD_INT 1
61425: ARRAY
61426: DIFF
61427: DIFF
61428: ST_TO_ADDR
// if tmp and not sci then
61429: LD_VAR 0 4
61433: PUSH
61434: LD_VAR 0 8
61438: NOT
61439: AND
61440: IFFALSE 61509
// begin sort := SortBySkill ( tmp , 4 ) ;
61442: LD_ADDR_VAR 0 9
61446: PUSH
61447: LD_VAR 0 4
61451: PPUSH
61452: LD_INT 4
61454: PPUSH
61455: CALL 50047 0 2
61459: ST_TO_ADDR
// if sort then
61460: LD_VAR 0 9
61464: IFFALSE 61480
// p := sort [ 1 ] ;
61466: LD_ADDR_VAR 0 11
61470: PUSH
61471: LD_VAR 0 9
61475: PUSH
61476: LD_INT 1
61478: ARRAY
61479: ST_TO_ADDR
// if p then
61480: LD_VAR 0 11
61484: IFFALSE 61509
// result := Replace ( result , 4 , p ) ;
61486: LD_ADDR_VAR 0 2
61490: PUSH
61491: LD_VAR 0 2
61495: PPUSH
61496: LD_INT 4
61498: PPUSH
61499: LD_VAR 0 11
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61509: LD_ADDR_VAR 0 4
61513: PUSH
61514: LD_VAR 0 4
61518: PUSH
61519: LD_VAR 0 7
61523: DIFF
61524: ST_TO_ADDR
// if tmp and mech < 6 then
61525: LD_VAR 0 4
61529: PUSH
61530: LD_VAR 0 7
61534: PUSH
61535: LD_INT 6
61537: LESS
61538: AND
61539: IFFALSE 61727
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61541: LD_ADDR_VAR 0 9
61545: PUSH
61546: LD_VAR 0 4
61550: PUSH
61551: LD_VAR 0 8
61555: PUSH
61556: LD_VAR 0 7
61560: UNION
61561: DIFF
61562: PPUSH
61563: LD_INT 3
61565: PPUSH
61566: CALL 50047 0 2
61570: ST_TO_ADDR
// p := [ ] ;
61571: LD_ADDR_VAR 0 11
61575: PUSH
61576: EMPTY
61577: ST_TO_ADDR
// if sort then
61578: LD_VAR 0 9
61582: IFFALSE 61698
// for i = 1 to 6 - mech do
61584: LD_ADDR_VAR 0 3
61588: PUSH
61589: DOUBLE
61590: LD_INT 1
61592: DEC
61593: ST_TO_ADDR
61594: LD_INT 6
61596: PUSH
61597: LD_VAR 0 7
61601: MINUS
61602: PUSH
61603: FOR_TO
61604: IFFALSE 61696
// begin if i = sort then
61606: LD_VAR 0 3
61610: PUSH
61611: LD_VAR 0 9
61615: EQUAL
61616: IFFALSE 61620
// break ;
61618: GO 61696
// if GetClass ( i ) = 3 then
61620: LD_VAR 0 3
61624: PPUSH
61625: CALL_OW 257
61629: PUSH
61630: LD_INT 3
61632: EQUAL
61633: IFFALSE 61637
// continue ;
61635: GO 61603
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61637: LD_ADDR_VAR 0 11
61641: PUSH
61642: LD_VAR 0 11
61646: PPUSH
61647: LD_VAR 0 11
61651: PUSH
61652: LD_INT 1
61654: PLUS
61655: PPUSH
61656: LD_VAR 0 9
61660: PUSH
61661: LD_VAR 0 3
61665: ARRAY
61666: PPUSH
61667: CALL_OW 2
61671: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61672: LD_ADDR_VAR 0 4
61676: PUSH
61677: LD_VAR 0 4
61681: PUSH
61682: LD_VAR 0 9
61686: PUSH
61687: LD_VAR 0 3
61691: ARRAY
61692: DIFF
61693: ST_TO_ADDR
// end ;
61694: GO 61603
61696: POP
61697: POP
// if p then
61698: LD_VAR 0 11
61702: IFFALSE 61727
// result := Replace ( result , 3 , p ) ;
61704: LD_ADDR_VAR 0 2
61708: PUSH
61709: LD_VAR 0 2
61713: PPUSH
61714: LD_INT 3
61716: PPUSH
61717: LD_VAR 0 11
61721: PPUSH
61722: CALL_OW 1
61726: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61727: LD_ADDR_VAR 0 4
61731: PUSH
61732: LD_VAR 0 4
61736: PUSH
61737: LD_VAR 0 6
61741: DIFF
61742: ST_TO_ADDR
// if tmp and eng < 6 then
61743: LD_VAR 0 4
61747: PUSH
61748: LD_VAR 0 6
61752: PUSH
61753: LD_INT 6
61755: LESS
61756: AND
61757: IFFALSE 61951
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61759: LD_ADDR_VAR 0 9
61763: PUSH
61764: LD_VAR 0 4
61768: PUSH
61769: LD_VAR 0 8
61773: PUSH
61774: LD_VAR 0 7
61778: UNION
61779: PUSH
61780: LD_VAR 0 6
61784: UNION
61785: DIFF
61786: PPUSH
61787: LD_INT 2
61789: PPUSH
61790: CALL 50047 0 2
61794: ST_TO_ADDR
// p := [ ] ;
61795: LD_ADDR_VAR 0 11
61799: PUSH
61800: EMPTY
61801: ST_TO_ADDR
// if sort then
61802: LD_VAR 0 9
61806: IFFALSE 61922
// for i = 1 to 6 - eng do
61808: LD_ADDR_VAR 0 3
61812: PUSH
61813: DOUBLE
61814: LD_INT 1
61816: DEC
61817: ST_TO_ADDR
61818: LD_INT 6
61820: PUSH
61821: LD_VAR 0 6
61825: MINUS
61826: PUSH
61827: FOR_TO
61828: IFFALSE 61920
// begin if i = sort then
61830: LD_VAR 0 3
61834: PUSH
61835: LD_VAR 0 9
61839: EQUAL
61840: IFFALSE 61844
// break ;
61842: GO 61920
// if GetClass ( i ) = 2 then
61844: LD_VAR 0 3
61848: PPUSH
61849: CALL_OW 257
61853: PUSH
61854: LD_INT 2
61856: EQUAL
61857: IFFALSE 61861
// continue ;
61859: GO 61827
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61861: LD_ADDR_VAR 0 11
61865: PUSH
61866: LD_VAR 0 11
61870: PPUSH
61871: LD_VAR 0 11
61875: PUSH
61876: LD_INT 1
61878: PLUS
61879: PPUSH
61880: LD_VAR 0 9
61884: PUSH
61885: LD_VAR 0 3
61889: ARRAY
61890: PPUSH
61891: CALL_OW 2
61895: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61896: LD_ADDR_VAR 0 4
61900: PUSH
61901: LD_VAR 0 4
61905: PUSH
61906: LD_VAR 0 9
61910: PUSH
61911: LD_VAR 0 3
61915: ARRAY
61916: DIFF
61917: ST_TO_ADDR
// end ;
61918: GO 61827
61920: POP
61921: POP
// if p then
61922: LD_VAR 0 11
61926: IFFALSE 61951
// result := Replace ( result , 2 , p ) ;
61928: LD_ADDR_VAR 0 2
61932: PUSH
61933: LD_VAR 0 2
61937: PPUSH
61938: LD_INT 2
61940: PPUSH
61941: LD_VAR 0 11
61945: PPUSH
61946: CALL_OW 1
61950: ST_TO_ADDR
// end ; exit ;
61951: GO 62675
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61953: LD_EXP 86
61957: PUSH
61958: LD_EXP 85
61962: PUSH
61963: LD_VAR 0 1
61967: ARRAY
61968: ARRAY
61969: NOT
61970: PUSH
61971: LD_EXP 59
61975: PUSH
61976: LD_VAR 0 1
61980: ARRAY
61981: PPUSH
61982: LD_INT 30
61984: PUSH
61985: LD_INT 3
61987: PUSH
61988: EMPTY
61989: LIST
61990: LIST
61991: PPUSH
61992: CALL_OW 72
61996: AND
61997: PUSH
61998: LD_EXP 64
62002: PUSH
62003: LD_VAR 0 1
62007: ARRAY
62008: NOT
62009: AND
62010: IFFALSE 62675
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62012: LD_ADDR_EXP 101
62016: PUSH
62017: LD_EXP 101
62021: PPUSH
62022: LD_VAR 0 1
62026: PPUSH
62027: LD_INT 6
62029: PPUSH
62030: CALL_OW 1
62034: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62035: LD_ADDR_VAR 0 2
62039: PUSH
62040: LD_INT 0
62042: PUSH
62043: LD_INT 0
62045: PUSH
62046: LD_INT 0
62048: PUSH
62049: LD_INT 0
62051: PUSH
62052: EMPTY
62053: LIST
62054: LIST
62055: LIST
62056: LIST
62057: ST_TO_ADDR
// if sci >= 1 then
62058: LD_VAR 0 8
62062: PUSH
62063: LD_INT 1
62065: GREATEREQUAL
62066: IFFALSE 62088
// tmp := tmp diff sci [ 1 ] ;
62068: LD_ADDR_VAR 0 4
62072: PUSH
62073: LD_VAR 0 4
62077: PUSH
62078: LD_VAR 0 8
62082: PUSH
62083: LD_INT 1
62085: ARRAY
62086: DIFF
62087: ST_TO_ADDR
// if tmp and not sci then
62088: LD_VAR 0 4
62092: PUSH
62093: LD_VAR 0 8
62097: NOT
62098: AND
62099: IFFALSE 62168
// begin sort := SortBySkill ( tmp , 4 ) ;
62101: LD_ADDR_VAR 0 9
62105: PUSH
62106: LD_VAR 0 4
62110: PPUSH
62111: LD_INT 4
62113: PPUSH
62114: CALL 50047 0 2
62118: ST_TO_ADDR
// if sort then
62119: LD_VAR 0 9
62123: IFFALSE 62139
// p := sort [ 1 ] ;
62125: LD_ADDR_VAR 0 11
62129: PUSH
62130: LD_VAR 0 9
62134: PUSH
62135: LD_INT 1
62137: ARRAY
62138: ST_TO_ADDR
// if p then
62139: LD_VAR 0 11
62143: IFFALSE 62168
// result := Replace ( result , 4 , p ) ;
62145: LD_ADDR_VAR 0 2
62149: PUSH
62150: LD_VAR 0 2
62154: PPUSH
62155: LD_INT 4
62157: PPUSH
62158: LD_VAR 0 11
62162: PPUSH
62163: CALL_OW 1
62167: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62168: LD_ADDR_VAR 0 4
62172: PUSH
62173: LD_VAR 0 4
62177: PUSH
62178: LD_VAR 0 7
62182: DIFF
62183: ST_TO_ADDR
// if tmp and mech < 6 then
62184: LD_VAR 0 4
62188: PUSH
62189: LD_VAR 0 7
62193: PUSH
62194: LD_INT 6
62196: LESS
62197: AND
62198: IFFALSE 62380
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62200: LD_ADDR_VAR 0 9
62204: PUSH
62205: LD_VAR 0 4
62209: PUSH
62210: LD_VAR 0 7
62214: DIFF
62215: PPUSH
62216: LD_INT 3
62218: PPUSH
62219: CALL 50047 0 2
62223: ST_TO_ADDR
// p := [ ] ;
62224: LD_ADDR_VAR 0 11
62228: PUSH
62229: EMPTY
62230: ST_TO_ADDR
// if sort then
62231: LD_VAR 0 9
62235: IFFALSE 62351
// for i = 1 to 6 - mech do
62237: LD_ADDR_VAR 0 3
62241: PUSH
62242: DOUBLE
62243: LD_INT 1
62245: DEC
62246: ST_TO_ADDR
62247: LD_INT 6
62249: PUSH
62250: LD_VAR 0 7
62254: MINUS
62255: PUSH
62256: FOR_TO
62257: IFFALSE 62349
// begin if i = sort then
62259: LD_VAR 0 3
62263: PUSH
62264: LD_VAR 0 9
62268: EQUAL
62269: IFFALSE 62273
// break ;
62271: GO 62349
// if GetClass ( i ) = 3 then
62273: LD_VAR 0 3
62277: PPUSH
62278: CALL_OW 257
62282: PUSH
62283: LD_INT 3
62285: EQUAL
62286: IFFALSE 62290
// continue ;
62288: GO 62256
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62290: LD_ADDR_VAR 0 11
62294: PUSH
62295: LD_VAR 0 11
62299: PPUSH
62300: LD_VAR 0 11
62304: PUSH
62305: LD_INT 1
62307: PLUS
62308: PPUSH
62309: LD_VAR 0 9
62313: PUSH
62314: LD_VAR 0 3
62318: ARRAY
62319: PPUSH
62320: CALL_OW 2
62324: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62325: LD_ADDR_VAR 0 4
62329: PUSH
62330: LD_VAR 0 4
62334: PUSH
62335: LD_VAR 0 9
62339: PUSH
62340: LD_VAR 0 3
62344: ARRAY
62345: DIFF
62346: ST_TO_ADDR
// end ;
62347: GO 62256
62349: POP
62350: POP
// if p then
62351: LD_VAR 0 11
62355: IFFALSE 62380
// result := Replace ( result , 3 , p ) ;
62357: LD_ADDR_VAR 0 2
62361: PUSH
62362: LD_VAR 0 2
62366: PPUSH
62367: LD_INT 3
62369: PPUSH
62370: LD_VAR 0 11
62374: PPUSH
62375: CALL_OW 1
62379: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62380: LD_ADDR_VAR 0 4
62384: PUSH
62385: LD_VAR 0 4
62389: PUSH
62390: LD_VAR 0 6
62394: DIFF
62395: ST_TO_ADDR
// if tmp and eng < 4 then
62396: LD_VAR 0 4
62400: PUSH
62401: LD_VAR 0 6
62405: PUSH
62406: LD_INT 4
62408: LESS
62409: AND
62410: IFFALSE 62600
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62412: LD_ADDR_VAR 0 9
62416: PUSH
62417: LD_VAR 0 4
62421: PUSH
62422: LD_VAR 0 7
62426: PUSH
62427: LD_VAR 0 6
62431: UNION
62432: DIFF
62433: PPUSH
62434: LD_INT 2
62436: PPUSH
62437: CALL 50047 0 2
62441: ST_TO_ADDR
// p := [ ] ;
62442: LD_ADDR_VAR 0 11
62446: PUSH
62447: EMPTY
62448: ST_TO_ADDR
// if sort then
62449: LD_VAR 0 9
62453: IFFALSE 62569
// for i = 1 to 4 - eng do
62455: LD_ADDR_VAR 0 3
62459: PUSH
62460: DOUBLE
62461: LD_INT 1
62463: DEC
62464: ST_TO_ADDR
62465: LD_INT 4
62467: PUSH
62468: LD_VAR 0 6
62472: MINUS
62473: PUSH
62474: FOR_TO
62475: IFFALSE 62567
// begin if i = sort then
62477: LD_VAR 0 3
62481: PUSH
62482: LD_VAR 0 9
62486: EQUAL
62487: IFFALSE 62491
// break ;
62489: GO 62567
// if GetClass ( i ) = 2 then
62491: LD_VAR 0 3
62495: PPUSH
62496: CALL_OW 257
62500: PUSH
62501: LD_INT 2
62503: EQUAL
62504: IFFALSE 62508
// continue ;
62506: GO 62474
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62508: LD_ADDR_VAR 0 11
62512: PUSH
62513: LD_VAR 0 11
62517: PPUSH
62518: LD_VAR 0 11
62522: PUSH
62523: LD_INT 1
62525: PLUS
62526: PPUSH
62527: LD_VAR 0 9
62531: PUSH
62532: LD_VAR 0 3
62536: ARRAY
62537: PPUSH
62538: CALL_OW 2
62542: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62543: LD_ADDR_VAR 0 4
62547: PUSH
62548: LD_VAR 0 4
62552: PUSH
62553: LD_VAR 0 9
62557: PUSH
62558: LD_VAR 0 3
62562: ARRAY
62563: DIFF
62564: ST_TO_ADDR
// end ;
62565: GO 62474
62567: POP
62568: POP
// if p then
62569: LD_VAR 0 11
62573: IFFALSE 62598
// result := Replace ( result , 2 , p ) ;
62575: LD_ADDR_VAR 0 2
62579: PUSH
62580: LD_VAR 0 2
62584: PPUSH
62585: LD_INT 2
62587: PPUSH
62588: LD_VAR 0 11
62592: PPUSH
62593: CALL_OW 1
62597: ST_TO_ADDR
// end else
62598: GO 62644
// for i = eng downto 5 do
62600: LD_ADDR_VAR 0 3
62604: PUSH
62605: DOUBLE
62606: LD_VAR 0 6
62610: INC
62611: ST_TO_ADDR
62612: LD_INT 5
62614: PUSH
62615: FOR_DOWNTO
62616: IFFALSE 62642
// tmp := tmp union eng [ i ] ;
62618: LD_ADDR_VAR 0 4
62622: PUSH
62623: LD_VAR 0 4
62627: PUSH
62628: LD_VAR 0 6
62632: PUSH
62633: LD_VAR 0 3
62637: ARRAY
62638: UNION
62639: ST_TO_ADDR
62640: GO 62615
62642: POP
62643: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62644: LD_ADDR_VAR 0 2
62648: PUSH
62649: LD_VAR 0 2
62653: PPUSH
62654: LD_INT 1
62656: PPUSH
62657: LD_VAR 0 4
62661: PUSH
62662: LD_VAR 0 5
62666: DIFF
62667: PPUSH
62668: CALL_OW 1
62672: ST_TO_ADDR
// exit ;
62673: GO 62675
// end ; end ;
62675: LD_VAR 0 2
62679: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62680: LD_INT 0
62682: PPUSH
62683: PPUSH
62684: PPUSH
// if not mc_bases then
62685: LD_EXP 59
62689: NOT
62690: IFFALSE 62694
// exit ;
62692: GO 62836
// for i = 1 to mc_bases do
62694: LD_ADDR_VAR 0 2
62698: PUSH
62699: DOUBLE
62700: LD_INT 1
62702: DEC
62703: ST_TO_ADDR
62704: LD_EXP 59
62708: PUSH
62709: FOR_TO
62710: IFFALSE 62827
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62712: LD_ADDR_VAR 0 3
62716: PUSH
62717: LD_EXP 59
62721: PUSH
62722: LD_VAR 0 2
62726: ARRAY
62727: PPUSH
62728: LD_INT 21
62730: PUSH
62731: LD_INT 3
62733: PUSH
62734: EMPTY
62735: LIST
62736: LIST
62737: PUSH
62738: LD_INT 3
62740: PUSH
62741: LD_INT 2
62743: PUSH
62744: LD_INT 30
62746: PUSH
62747: LD_INT 29
62749: PUSH
62750: EMPTY
62751: LIST
62752: LIST
62753: PUSH
62754: LD_INT 30
62756: PUSH
62757: LD_INT 30
62759: PUSH
62760: EMPTY
62761: LIST
62762: LIST
62763: PUSH
62764: EMPTY
62765: LIST
62766: LIST
62767: LIST
62768: PUSH
62769: EMPTY
62770: LIST
62771: LIST
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: LD_INT 24
62778: PUSH
62779: LD_INT 1000
62781: PUSH
62782: EMPTY
62783: LIST
62784: LIST
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: PUSH
62790: EMPTY
62791: LIST
62792: LIST
62793: LIST
62794: PPUSH
62795: CALL_OW 72
62799: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62800: LD_ADDR_EXP 60
62804: PUSH
62805: LD_EXP 60
62809: PPUSH
62810: LD_VAR 0 2
62814: PPUSH
62815: LD_VAR 0 3
62819: PPUSH
62820: CALL_OW 1
62824: ST_TO_ADDR
// end ;
62825: GO 62709
62827: POP
62828: POP
// RaiseSailEvent ( 101 ) ;
62829: LD_INT 101
62831: PPUSH
62832: CALL_OW 427
// end ;
62836: LD_VAR 0 1
62840: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62841: LD_INT 0
62843: PPUSH
62844: PPUSH
62845: PPUSH
62846: PPUSH
62847: PPUSH
62848: PPUSH
62849: PPUSH
// if not mc_bases then
62850: LD_EXP 59
62854: NOT
62855: IFFALSE 62859
// exit ;
62857: GO 63421
// for i = 1 to mc_bases do
62859: LD_ADDR_VAR 0 2
62863: PUSH
62864: DOUBLE
62865: LD_INT 1
62867: DEC
62868: ST_TO_ADDR
62869: LD_EXP 59
62873: PUSH
62874: FOR_TO
62875: IFFALSE 63412
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62877: LD_ADDR_VAR 0 5
62881: PUSH
62882: LD_EXP 59
62886: PUSH
62887: LD_VAR 0 2
62891: ARRAY
62892: PUSH
62893: LD_EXP 88
62897: PUSH
62898: LD_VAR 0 2
62902: ARRAY
62903: UNION
62904: PPUSH
62905: LD_INT 21
62907: PUSH
62908: LD_INT 1
62910: PUSH
62911: EMPTY
62912: LIST
62913: LIST
62914: PUSH
62915: LD_INT 1
62917: PUSH
62918: LD_INT 3
62920: PUSH
62921: LD_INT 54
62923: PUSH
62924: EMPTY
62925: LIST
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: PUSH
62931: LD_INT 3
62933: PUSH
62934: LD_INT 24
62936: PUSH
62937: LD_INT 1000
62939: PUSH
62940: EMPTY
62941: LIST
62942: LIST
62943: PUSH
62944: EMPTY
62945: LIST
62946: LIST
62947: PUSH
62948: EMPTY
62949: LIST
62950: LIST
62951: LIST
62952: PUSH
62953: EMPTY
62954: LIST
62955: LIST
62956: PPUSH
62957: CALL_OW 72
62961: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62962: LD_ADDR_VAR 0 6
62966: PUSH
62967: LD_EXP 59
62971: PUSH
62972: LD_VAR 0 2
62976: ARRAY
62977: PPUSH
62978: LD_INT 21
62980: PUSH
62981: LD_INT 1
62983: PUSH
62984: EMPTY
62985: LIST
62986: LIST
62987: PUSH
62988: LD_INT 1
62990: PUSH
62991: LD_INT 3
62993: PUSH
62994: LD_INT 54
62996: PUSH
62997: EMPTY
62998: LIST
62999: PUSH
63000: EMPTY
63001: LIST
63002: LIST
63003: PUSH
63004: LD_INT 3
63006: PUSH
63007: LD_INT 24
63009: PUSH
63010: LD_INT 250
63012: PUSH
63013: EMPTY
63014: LIST
63015: LIST
63016: PUSH
63017: EMPTY
63018: LIST
63019: LIST
63020: PUSH
63021: EMPTY
63022: LIST
63023: LIST
63024: LIST
63025: PUSH
63026: EMPTY
63027: LIST
63028: LIST
63029: PPUSH
63030: CALL_OW 72
63034: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63035: LD_ADDR_VAR 0 7
63039: PUSH
63040: LD_VAR 0 5
63044: PUSH
63045: LD_VAR 0 6
63049: DIFF
63050: ST_TO_ADDR
// if not need_heal_1 then
63051: LD_VAR 0 6
63055: NOT
63056: IFFALSE 63089
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63058: LD_ADDR_EXP 62
63062: PUSH
63063: LD_EXP 62
63067: PPUSH
63068: LD_VAR 0 2
63072: PUSH
63073: LD_INT 1
63075: PUSH
63076: EMPTY
63077: LIST
63078: LIST
63079: PPUSH
63080: EMPTY
63081: PPUSH
63082: CALL 19790 0 3
63086: ST_TO_ADDR
63087: GO 63159
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63089: LD_ADDR_EXP 62
63093: PUSH
63094: LD_EXP 62
63098: PPUSH
63099: LD_VAR 0 2
63103: PUSH
63104: LD_INT 1
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PPUSH
63111: LD_EXP 62
63115: PUSH
63116: LD_VAR 0 2
63120: ARRAY
63121: PUSH
63122: LD_INT 1
63124: ARRAY
63125: PPUSH
63126: LD_INT 3
63128: PUSH
63129: LD_INT 24
63131: PUSH
63132: LD_INT 1000
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PPUSH
63143: CALL_OW 72
63147: PUSH
63148: LD_VAR 0 6
63152: UNION
63153: PPUSH
63154: CALL 19790 0 3
63158: ST_TO_ADDR
// if not need_heal_2 then
63159: LD_VAR 0 7
63163: NOT
63164: IFFALSE 63197
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63166: LD_ADDR_EXP 62
63170: PUSH
63171: LD_EXP 62
63175: PPUSH
63176: LD_VAR 0 2
63180: PUSH
63181: LD_INT 2
63183: PUSH
63184: EMPTY
63185: LIST
63186: LIST
63187: PPUSH
63188: EMPTY
63189: PPUSH
63190: CALL 19790 0 3
63194: ST_TO_ADDR
63195: GO 63229
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63197: LD_ADDR_EXP 62
63201: PUSH
63202: LD_EXP 62
63206: PPUSH
63207: LD_VAR 0 2
63211: PUSH
63212: LD_INT 2
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: PPUSH
63219: LD_VAR 0 7
63223: PPUSH
63224: CALL 19790 0 3
63228: ST_TO_ADDR
// if need_heal_2 then
63229: LD_VAR 0 7
63233: IFFALSE 63394
// for j in need_heal_2 do
63235: LD_ADDR_VAR 0 3
63239: PUSH
63240: LD_VAR 0 7
63244: PUSH
63245: FOR_IN
63246: IFFALSE 63392
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63248: LD_ADDR_VAR 0 5
63252: PUSH
63253: LD_EXP 59
63257: PUSH
63258: LD_VAR 0 2
63262: ARRAY
63263: PPUSH
63264: LD_INT 2
63266: PUSH
63267: LD_INT 30
63269: PUSH
63270: LD_INT 6
63272: PUSH
63273: EMPTY
63274: LIST
63275: LIST
63276: PUSH
63277: LD_INT 30
63279: PUSH
63280: LD_INT 7
63282: PUSH
63283: EMPTY
63284: LIST
63285: LIST
63286: PUSH
63287: LD_INT 30
63289: PUSH
63290: LD_INT 8
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: PUSH
63297: LD_INT 30
63299: PUSH
63300: LD_INT 0
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: PUSH
63307: LD_INT 30
63309: PUSH
63310: LD_INT 1
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: LIST
63321: LIST
63322: LIST
63323: LIST
63324: PPUSH
63325: CALL_OW 72
63329: ST_TO_ADDR
// if tmp then
63330: LD_VAR 0 5
63334: IFFALSE 63390
// begin k := NearestUnitToUnit ( tmp , j ) ;
63336: LD_ADDR_VAR 0 4
63340: PUSH
63341: LD_VAR 0 5
63345: PPUSH
63346: LD_VAR 0 3
63350: PPUSH
63351: CALL_OW 74
63355: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63356: LD_VAR 0 3
63360: PPUSH
63361: LD_VAR 0 4
63365: PPUSH
63366: CALL_OW 296
63370: PUSH
63371: LD_INT 5
63373: GREATER
63374: IFFALSE 63390
// ComMoveToNearbyEntrance ( j , k ) ;
63376: LD_VAR 0 3
63380: PPUSH
63381: LD_VAR 0 4
63385: PPUSH
63386: CALL 52408 0 2
// end ; end ;
63390: GO 63245
63392: POP
63393: POP
// if not need_heal_1 and not need_heal_2 then
63394: LD_VAR 0 6
63398: NOT
63399: PUSH
63400: LD_VAR 0 7
63404: NOT
63405: AND
63406: IFFALSE 63410
// continue ;
63408: GO 62874
// end ;
63410: GO 62874
63412: POP
63413: POP
// RaiseSailEvent ( 102 ) ;
63414: LD_INT 102
63416: PPUSH
63417: CALL_OW 427
// end ;
63421: LD_VAR 0 1
63425: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63426: LD_INT 0
63428: PPUSH
63429: PPUSH
63430: PPUSH
63431: PPUSH
63432: PPUSH
63433: PPUSH
63434: PPUSH
63435: PPUSH
// if not mc_bases then
63436: LD_EXP 59
63440: NOT
63441: IFFALSE 63445
// exit ;
63443: GO 64328
// for i = 1 to mc_bases do
63445: LD_ADDR_VAR 0 2
63449: PUSH
63450: DOUBLE
63451: LD_INT 1
63453: DEC
63454: ST_TO_ADDR
63455: LD_EXP 59
63459: PUSH
63460: FOR_TO
63461: IFFALSE 64326
// begin if not mc_building_need_repair [ i ] then
63463: LD_EXP 60
63467: PUSH
63468: LD_VAR 0 2
63472: ARRAY
63473: NOT
63474: IFFALSE 63661
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63476: LD_ADDR_VAR 0 6
63480: PUSH
63481: LD_EXP 78
63485: PUSH
63486: LD_VAR 0 2
63490: ARRAY
63491: PPUSH
63492: LD_INT 3
63494: PUSH
63495: LD_INT 24
63497: PUSH
63498: LD_INT 1000
63500: PUSH
63501: EMPTY
63502: LIST
63503: LIST
63504: PUSH
63505: EMPTY
63506: LIST
63507: LIST
63508: PUSH
63509: LD_INT 2
63511: PUSH
63512: LD_INT 34
63514: PUSH
63515: LD_INT 13
63517: PUSH
63518: EMPTY
63519: LIST
63520: LIST
63521: PUSH
63522: LD_INT 34
63524: PUSH
63525: LD_INT 52
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 34
63534: PUSH
63535: LD_EXP 109
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: EMPTY
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: PUSH
63550: EMPTY
63551: LIST
63552: LIST
63553: PPUSH
63554: CALL_OW 72
63558: ST_TO_ADDR
// if cranes then
63559: LD_VAR 0 6
63563: IFFALSE 63625
// for j in cranes do
63565: LD_ADDR_VAR 0 3
63569: PUSH
63570: LD_VAR 0 6
63574: PUSH
63575: FOR_IN
63576: IFFALSE 63623
// if not IsInArea ( j , mc_parking [ i ] ) then
63578: LD_VAR 0 3
63582: PPUSH
63583: LD_EXP 83
63587: PUSH
63588: LD_VAR 0 2
63592: ARRAY
63593: PPUSH
63594: CALL_OW 308
63598: NOT
63599: IFFALSE 63621
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63601: LD_VAR 0 3
63605: PPUSH
63606: LD_EXP 83
63610: PUSH
63611: LD_VAR 0 2
63615: ARRAY
63616: PPUSH
63617: CALL_OW 113
63621: GO 63575
63623: POP
63624: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63625: LD_ADDR_EXP 61
63629: PUSH
63630: LD_EXP 61
63634: PPUSH
63635: LD_VAR 0 2
63639: PPUSH
63640: EMPTY
63641: PPUSH
63642: CALL_OW 1
63646: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63647: LD_VAR 0 2
63651: PPUSH
63652: LD_INT 101
63654: PPUSH
63655: CALL 58513 0 2
// continue ;
63659: GO 63460
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63661: LD_ADDR_EXP 65
63665: PUSH
63666: LD_EXP 65
63670: PPUSH
63671: LD_VAR 0 2
63675: PPUSH
63676: EMPTY
63677: PPUSH
63678: CALL_OW 1
63682: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63683: LD_VAR 0 2
63687: PPUSH
63688: LD_INT 103
63690: PPUSH
63691: CALL 58513 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63695: LD_ADDR_VAR 0 5
63699: PUSH
63700: LD_EXP 59
63704: PUSH
63705: LD_VAR 0 2
63709: ARRAY
63710: PUSH
63711: LD_EXP 88
63715: PUSH
63716: LD_VAR 0 2
63720: ARRAY
63721: UNION
63722: PPUSH
63723: LD_INT 2
63725: PUSH
63726: LD_INT 25
63728: PUSH
63729: LD_INT 2
63731: PUSH
63732: EMPTY
63733: LIST
63734: LIST
63735: PUSH
63736: LD_INT 25
63738: PUSH
63739: LD_INT 16
63741: PUSH
63742: EMPTY
63743: LIST
63744: LIST
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: LIST
63750: PUSH
63751: EMPTY
63752: LIST
63753: PPUSH
63754: CALL_OW 72
63758: ST_TO_ADDR
// if mc_need_heal [ i ] then
63759: LD_EXP 62
63763: PUSH
63764: LD_VAR 0 2
63768: ARRAY
63769: IFFALSE 63813
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63771: LD_ADDR_VAR 0 5
63775: PUSH
63776: LD_VAR 0 5
63780: PUSH
63781: LD_EXP 62
63785: PUSH
63786: LD_VAR 0 2
63790: ARRAY
63791: PUSH
63792: LD_INT 1
63794: ARRAY
63795: PUSH
63796: LD_EXP 62
63800: PUSH
63801: LD_VAR 0 2
63805: ARRAY
63806: PUSH
63807: LD_INT 2
63809: ARRAY
63810: UNION
63811: DIFF
63812: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63813: LD_ADDR_VAR 0 6
63817: PUSH
63818: LD_EXP 78
63822: PUSH
63823: LD_VAR 0 2
63827: ARRAY
63828: PPUSH
63829: LD_INT 2
63831: PUSH
63832: LD_INT 34
63834: PUSH
63835: LD_INT 13
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: PUSH
63842: LD_INT 34
63844: PUSH
63845: LD_INT 52
63847: PUSH
63848: EMPTY
63849: LIST
63850: LIST
63851: PUSH
63852: LD_INT 34
63854: PUSH
63855: LD_EXP 109
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: PPUSH
63870: CALL_OW 72
63874: ST_TO_ADDR
// if cranes then
63875: LD_VAR 0 6
63879: IFFALSE 64015
// begin for j in cranes do
63881: LD_ADDR_VAR 0 3
63885: PUSH
63886: LD_VAR 0 6
63890: PUSH
63891: FOR_IN
63892: IFFALSE 64013
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63894: LD_VAR 0 3
63898: PPUSH
63899: CALL_OW 256
63903: PUSH
63904: LD_INT 1000
63906: EQUAL
63907: PUSH
63908: LD_VAR 0 3
63912: PPUSH
63913: CALL_OW 314
63917: NOT
63918: AND
63919: IFFALSE 63953
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63921: LD_VAR 0 3
63925: PPUSH
63926: LD_EXP 60
63930: PUSH
63931: LD_VAR 0 2
63935: ARRAY
63936: PPUSH
63937: LD_VAR 0 3
63941: PPUSH
63942: CALL_OW 74
63946: PPUSH
63947: CALL_OW 130
63951: GO 64011
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63953: LD_VAR 0 3
63957: PPUSH
63958: CALL_OW 256
63962: PUSH
63963: LD_INT 500
63965: LESS
63966: PUSH
63967: LD_VAR 0 3
63971: PPUSH
63972: LD_EXP 83
63976: PUSH
63977: LD_VAR 0 2
63981: ARRAY
63982: PPUSH
63983: CALL_OW 308
63987: NOT
63988: AND
63989: IFFALSE 64011
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63991: LD_VAR 0 3
63995: PPUSH
63996: LD_EXP 83
64000: PUSH
64001: LD_VAR 0 2
64005: ARRAY
64006: PPUSH
64007: CALL_OW 113
// end ;
64011: GO 63891
64013: POP
64014: POP
// end ; if tmp > 3 then
64015: LD_VAR 0 5
64019: PUSH
64020: LD_INT 3
64022: GREATER
64023: IFFALSE 64043
// tmp := ShrinkArray ( tmp , 4 ) ;
64025: LD_ADDR_VAR 0 5
64029: PUSH
64030: LD_VAR 0 5
64034: PPUSH
64035: LD_INT 4
64037: PPUSH
64038: CALL 51856 0 2
64042: ST_TO_ADDR
// if not tmp then
64043: LD_VAR 0 5
64047: NOT
64048: IFFALSE 64052
// continue ;
64050: GO 63460
// for j in tmp do
64052: LD_ADDR_VAR 0 3
64056: PUSH
64057: LD_VAR 0 5
64061: PUSH
64062: FOR_IN
64063: IFFALSE 64322
// begin if IsInUnit ( j ) then
64065: LD_VAR 0 3
64069: PPUSH
64070: CALL_OW 310
64074: IFFALSE 64085
// ComExitBuilding ( j ) ;
64076: LD_VAR 0 3
64080: PPUSH
64081: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64085: LD_VAR 0 3
64089: PUSH
64090: LD_EXP 61
64094: PUSH
64095: LD_VAR 0 2
64099: ARRAY
64100: IN
64101: NOT
64102: IFFALSE 64160
// begin SetTag ( j , 101 ) ;
64104: LD_VAR 0 3
64108: PPUSH
64109: LD_INT 101
64111: PPUSH
64112: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64116: LD_ADDR_EXP 61
64120: PUSH
64121: LD_EXP 61
64125: PPUSH
64126: LD_VAR 0 2
64130: PUSH
64131: LD_EXP 61
64135: PUSH
64136: LD_VAR 0 2
64140: ARRAY
64141: PUSH
64142: LD_INT 1
64144: PLUS
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PPUSH
64150: LD_VAR 0 3
64154: PPUSH
64155: CALL 19790 0 3
64159: ST_TO_ADDR
// end ; wait ( 1 ) ;
64160: LD_INT 1
64162: PPUSH
64163: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64167: LD_ADDR_VAR 0 7
64171: PUSH
64172: LD_EXP 60
64176: PUSH
64177: LD_VAR 0 2
64181: ARRAY
64182: ST_TO_ADDR
// if mc_scan [ i ] then
64183: LD_EXP 82
64187: PUSH
64188: LD_VAR 0 2
64192: ARRAY
64193: IFFALSE 64255
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64195: LD_ADDR_VAR 0 7
64199: PUSH
64200: LD_EXP 60
64204: PUSH
64205: LD_VAR 0 2
64209: ARRAY
64210: PPUSH
64211: LD_INT 3
64213: PUSH
64214: LD_INT 30
64216: PUSH
64217: LD_INT 32
64219: PUSH
64220: EMPTY
64221: LIST
64222: LIST
64223: PUSH
64224: LD_INT 30
64226: PUSH
64227: LD_INT 33
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 30
64236: PUSH
64237: LD_INT 31
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: EMPTY
64245: LIST
64246: LIST
64247: LIST
64248: LIST
64249: PPUSH
64250: CALL_OW 72
64254: ST_TO_ADDR
// if not to_repair_tmp then
64255: LD_VAR 0 7
64259: NOT
64260: IFFALSE 64264
// continue ;
64262: GO 64062
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64264: LD_ADDR_VAR 0 8
64268: PUSH
64269: LD_VAR 0 7
64273: PPUSH
64274: LD_VAR 0 3
64278: PPUSH
64279: CALL_OW 74
64283: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64284: LD_VAR 0 8
64288: PPUSH
64289: LD_INT 16
64291: PPUSH
64292: CALL 22389 0 2
64296: PUSH
64297: LD_INT 4
64299: ARRAY
64300: PUSH
64301: LD_INT 10
64303: LESS
64304: IFFALSE 64320
// ComRepairBuilding ( j , to_repair ) ;
64306: LD_VAR 0 3
64310: PPUSH
64311: LD_VAR 0 8
64315: PPUSH
64316: CALL_OW 130
// end ;
64320: GO 64062
64322: POP
64323: POP
// end ;
64324: GO 63460
64326: POP
64327: POP
// end ;
64328: LD_VAR 0 1
64332: RET
// export function MC_Heal ; var i , j , tmp ; begin
64333: LD_INT 0
64335: PPUSH
64336: PPUSH
64337: PPUSH
64338: PPUSH
// if not mc_bases then
64339: LD_EXP 59
64343: NOT
64344: IFFALSE 64348
// exit ;
64346: GO 64750
// for i = 1 to mc_bases do
64348: LD_ADDR_VAR 0 2
64352: PUSH
64353: DOUBLE
64354: LD_INT 1
64356: DEC
64357: ST_TO_ADDR
64358: LD_EXP 59
64362: PUSH
64363: FOR_TO
64364: IFFALSE 64748
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64366: LD_EXP 62
64370: PUSH
64371: LD_VAR 0 2
64375: ARRAY
64376: PUSH
64377: LD_INT 1
64379: ARRAY
64380: NOT
64381: PUSH
64382: LD_EXP 62
64386: PUSH
64387: LD_VAR 0 2
64391: ARRAY
64392: PUSH
64393: LD_INT 2
64395: ARRAY
64396: NOT
64397: AND
64398: IFFALSE 64436
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64400: LD_ADDR_EXP 63
64404: PUSH
64405: LD_EXP 63
64409: PPUSH
64410: LD_VAR 0 2
64414: PPUSH
64415: EMPTY
64416: PPUSH
64417: CALL_OW 1
64421: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64422: LD_VAR 0 2
64426: PPUSH
64427: LD_INT 102
64429: PPUSH
64430: CALL 58513 0 2
// continue ;
64434: GO 64363
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64436: LD_ADDR_VAR 0 4
64440: PUSH
64441: LD_EXP 59
64445: PUSH
64446: LD_VAR 0 2
64450: ARRAY
64451: PPUSH
64452: LD_INT 25
64454: PUSH
64455: LD_INT 4
64457: PUSH
64458: EMPTY
64459: LIST
64460: LIST
64461: PPUSH
64462: CALL_OW 72
64466: ST_TO_ADDR
// if not tmp then
64467: LD_VAR 0 4
64471: NOT
64472: IFFALSE 64476
// continue ;
64474: GO 64363
// if mc_taming [ i ] then
64476: LD_EXP 90
64480: PUSH
64481: LD_VAR 0 2
64485: ARRAY
64486: IFFALSE 64510
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64488: LD_ADDR_EXP 90
64492: PUSH
64493: LD_EXP 90
64497: PPUSH
64498: LD_VAR 0 2
64502: PPUSH
64503: EMPTY
64504: PPUSH
64505: CALL_OW 1
64509: ST_TO_ADDR
// for j in tmp do
64510: LD_ADDR_VAR 0 3
64514: PUSH
64515: LD_VAR 0 4
64519: PUSH
64520: FOR_IN
64521: IFFALSE 64744
// begin if IsInUnit ( j ) then
64523: LD_VAR 0 3
64527: PPUSH
64528: CALL_OW 310
64532: IFFALSE 64543
// ComExitBuilding ( j ) ;
64534: LD_VAR 0 3
64538: PPUSH
64539: CALL_OW 122
// if not j in mc_healers [ i ] then
64543: LD_VAR 0 3
64547: PUSH
64548: LD_EXP 63
64552: PUSH
64553: LD_VAR 0 2
64557: ARRAY
64558: IN
64559: NOT
64560: IFFALSE 64606
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64562: LD_ADDR_EXP 63
64566: PUSH
64567: LD_EXP 63
64571: PPUSH
64572: LD_VAR 0 2
64576: PUSH
64577: LD_EXP 63
64581: PUSH
64582: LD_VAR 0 2
64586: ARRAY
64587: PUSH
64588: LD_INT 1
64590: PLUS
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PPUSH
64596: LD_VAR 0 3
64600: PPUSH
64601: CALL 19790 0 3
64605: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64606: LD_VAR 0 3
64610: PPUSH
64611: CALL_OW 110
64615: PUSH
64616: LD_INT 102
64618: NONEQUAL
64619: IFFALSE 64633
// SetTag ( j , 102 ) ;
64621: LD_VAR 0 3
64625: PPUSH
64626: LD_INT 102
64628: PPUSH
64629: CALL_OW 109
// Wait ( 3 ) ;
64633: LD_INT 3
64635: PPUSH
64636: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64640: LD_EXP 62
64644: PUSH
64645: LD_VAR 0 2
64649: ARRAY
64650: PUSH
64651: LD_INT 1
64653: ARRAY
64654: IFFALSE 64686
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64656: LD_VAR 0 3
64660: PPUSH
64661: LD_EXP 62
64665: PUSH
64666: LD_VAR 0 2
64670: ARRAY
64671: PUSH
64672: LD_INT 1
64674: ARRAY
64675: PUSH
64676: LD_INT 1
64678: ARRAY
64679: PPUSH
64680: CALL_OW 128
64684: GO 64742
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64686: LD_VAR 0 3
64690: PPUSH
64691: CALL_OW 314
64695: NOT
64696: PUSH
64697: LD_EXP 62
64701: PUSH
64702: LD_VAR 0 2
64706: ARRAY
64707: PUSH
64708: LD_INT 2
64710: ARRAY
64711: AND
64712: IFFALSE 64742
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64714: LD_VAR 0 3
64718: PPUSH
64719: LD_EXP 62
64723: PUSH
64724: LD_VAR 0 2
64728: ARRAY
64729: PUSH
64730: LD_INT 2
64732: ARRAY
64733: PUSH
64734: LD_INT 1
64736: ARRAY
64737: PPUSH
64738: CALL_OW 128
// end ;
64742: GO 64520
64744: POP
64745: POP
// end ;
64746: GO 64363
64748: POP
64749: POP
// end ;
64750: LD_VAR 0 1
64754: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64755: LD_INT 0
64757: PPUSH
64758: PPUSH
64759: PPUSH
64760: PPUSH
64761: PPUSH
// if not mc_bases then
64762: LD_EXP 59
64766: NOT
64767: IFFALSE 64771
// exit ;
64769: GO 65942
// for i = 1 to mc_bases do
64771: LD_ADDR_VAR 0 2
64775: PUSH
64776: DOUBLE
64777: LD_INT 1
64779: DEC
64780: ST_TO_ADDR
64781: LD_EXP 59
64785: PUSH
64786: FOR_TO
64787: IFFALSE 65940
// begin if mc_scan [ i ] then
64789: LD_EXP 82
64793: PUSH
64794: LD_VAR 0 2
64798: ARRAY
64799: IFFALSE 64803
// continue ;
64801: GO 64786
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64803: LD_EXP 64
64807: PUSH
64808: LD_VAR 0 2
64812: ARRAY
64813: NOT
64814: PUSH
64815: LD_EXP 66
64819: PUSH
64820: LD_VAR 0 2
64824: ARRAY
64825: NOT
64826: AND
64827: PUSH
64828: LD_EXP 65
64832: PUSH
64833: LD_VAR 0 2
64837: ARRAY
64838: AND
64839: IFFALSE 64877
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64841: LD_ADDR_EXP 65
64845: PUSH
64846: LD_EXP 65
64850: PPUSH
64851: LD_VAR 0 2
64855: PPUSH
64856: EMPTY
64857: PPUSH
64858: CALL_OW 1
64862: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64863: LD_VAR 0 2
64867: PPUSH
64868: LD_INT 103
64870: PPUSH
64871: CALL 58513 0 2
// continue ;
64875: GO 64786
// end ; if mc_construct_list [ i ] then
64877: LD_EXP 66
64881: PUSH
64882: LD_VAR 0 2
64886: ARRAY
64887: IFFALSE 65107
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64889: LD_ADDR_VAR 0 4
64893: PUSH
64894: LD_EXP 59
64898: PUSH
64899: LD_VAR 0 2
64903: ARRAY
64904: PPUSH
64905: LD_INT 25
64907: PUSH
64908: LD_INT 2
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PPUSH
64915: CALL_OW 72
64919: PUSH
64920: LD_EXP 61
64924: PUSH
64925: LD_VAR 0 2
64929: ARRAY
64930: DIFF
64931: ST_TO_ADDR
// if not tmp then
64932: LD_VAR 0 4
64936: NOT
64937: IFFALSE 64941
// continue ;
64939: GO 64786
// for j in tmp do
64941: LD_ADDR_VAR 0 3
64945: PUSH
64946: LD_VAR 0 4
64950: PUSH
64951: FOR_IN
64952: IFFALSE 65103
// begin if not mc_builders [ i ] then
64954: LD_EXP 65
64958: PUSH
64959: LD_VAR 0 2
64963: ARRAY
64964: NOT
64965: IFFALSE 65023
// begin SetTag ( j , 103 ) ;
64967: LD_VAR 0 3
64971: PPUSH
64972: LD_INT 103
64974: PPUSH
64975: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64979: LD_ADDR_EXP 65
64983: PUSH
64984: LD_EXP 65
64988: PPUSH
64989: LD_VAR 0 2
64993: PUSH
64994: LD_EXP 65
64998: PUSH
64999: LD_VAR 0 2
65003: ARRAY
65004: PUSH
65005: LD_INT 1
65007: PLUS
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PPUSH
65013: LD_VAR 0 3
65017: PPUSH
65018: CALL 19790 0 3
65022: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65023: LD_VAR 0 3
65027: PPUSH
65028: CALL_OW 310
65032: IFFALSE 65043
// ComExitBuilding ( j ) ;
65034: LD_VAR 0 3
65038: PPUSH
65039: CALL_OW 122
// wait ( 3 ) ;
65043: LD_INT 3
65045: PPUSH
65046: CALL_OW 67
// if not mc_construct_list [ i ] then
65050: LD_EXP 66
65054: PUSH
65055: LD_VAR 0 2
65059: ARRAY
65060: NOT
65061: IFFALSE 65065
// break ;
65063: GO 65103
// if not HasTask ( j ) then
65065: LD_VAR 0 3
65069: PPUSH
65070: CALL_OW 314
65074: NOT
65075: IFFALSE 65101
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65077: LD_VAR 0 3
65081: PPUSH
65082: LD_EXP 66
65086: PUSH
65087: LD_VAR 0 2
65091: ARRAY
65092: PUSH
65093: LD_INT 1
65095: ARRAY
65096: PPUSH
65097: CALL 22653 0 2
// end ;
65101: GO 64951
65103: POP
65104: POP
// end else
65105: GO 65938
// if mc_build_list [ i ] then
65107: LD_EXP 64
65111: PUSH
65112: LD_VAR 0 2
65116: ARRAY
65117: IFFALSE 65938
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65119: LD_ADDR_VAR 0 5
65123: PUSH
65124: LD_EXP 59
65128: PUSH
65129: LD_VAR 0 2
65133: ARRAY
65134: PPUSH
65135: LD_INT 2
65137: PUSH
65138: LD_INT 30
65140: PUSH
65141: LD_INT 0
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 30
65150: PUSH
65151: LD_INT 1
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PUSH
65158: EMPTY
65159: LIST
65160: LIST
65161: LIST
65162: PPUSH
65163: CALL_OW 72
65167: ST_TO_ADDR
// if depot then
65168: LD_VAR 0 5
65172: IFFALSE 65190
// depot := depot [ 1 ] else
65174: LD_ADDR_VAR 0 5
65178: PUSH
65179: LD_VAR 0 5
65183: PUSH
65184: LD_INT 1
65186: ARRAY
65187: ST_TO_ADDR
65188: GO 65198
// depot := 0 ;
65190: LD_ADDR_VAR 0 5
65194: PUSH
65195: LD_INT 0
65197: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65198: LD_EXP 64
65202: PUSH
65203: LD_VAR 0 2
65207: ARRAY
65208: PUSH
65209: LD_INT 1
65211: ARRAY
65212: PUSH
65213: LD_INT 1
65215: ARRAY
65216: PPUSH
65217: CALL 22477 0 1
65221: PUSH
65222: LD_EXP 59
65226: PUSH
65227: LD_VAR 0 2
65231: ARRAY
65232: PPUSH
65233: LD_INT 2
65235: PUSH
65236: LD_INT 30
65238: PUSH
65239: LD_INT 2
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: LD_INT 30
65248: PUSH
65249: LD_INT 3
65251: PUSH
65252: EMPTY
65253: LIST
65254: LIST
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: LIST
65260: PPUSH
65261: CALL_OW 72
65265: NOT
65266: AND
65267: IFFALSE 65372
// begin for j = 1 to mc_build_list [ i ] do
65269: LD_ADDR_VAR 0 3
65273: PUSH
65274: DOUBLE
65275: LD_INT 1
65277: DEC
65278: ST_TO_ADDR
65279: LD_EXP 64
65283: PUSH
65284: LD_VAR 0 2
65288: ARRAY
65289: PUSH
65290: FOR_TO
65291: IFFALSE 65370
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65293: LD_EXP 64
65297: PUSH
65298: LD_VAR 0 2
65302: ARRAY
65303: PUSH
65304: LD_VAR 0 3
65308: ARRAY
65309: PUSH
65310: LD_INT 1
65312: ARRAY
65313: PUSH
65314: LD_INT 2
65316: EQUAL
65317: IFFALSE 65368
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65319: LD_ADDR_EXP 64
65323: PUSH
65324: LD_EXP 64
65328: PPUSH
65329: LD_VAR 0 2
65333: PPUSH
65334: LD_EXP 64
65338: PUSH
65339: LD_VAR 0 2
65343: ARRAY
65344: PPUSH
65345: LD_VAR 0 3
65349: PPUSH
65350: LD_INT 1
65352: PPUSH
65353: LD_INT 0
65355: PPUSH
65356: CALL 19208 0 4
65360: PPUSH
65361: CALL_OW 1
65365: ST_TO_ADDR
// break ;
65366: GO 65370
// end ;
65368: GO 65290
65370: POP
65371: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65372: LD_EXP 64
65376: PUSH
65377: LD_VAR 0 2
65381: ARRAY
65382: PUSH
65383: LD_INT 1
65385: ARRAY
65386: PUSH
65387: LD_INT 1
65389: ARRAY
65390: PUSH
65391: LD_INT 0
65393: EQUAL
65394: PUSH
65395: LD_VAR 0 5
65399: PUSH
65400: LD_VAR 0 5
65404: PPUSH
65405: LD_EXP 64
65409: PUSH
65410: LD_VAR 0 2
65414: ARRAY
65415: PUSH
65416: LD_INT 1
65418: ARRAY
65419: PUSH
65420: LD_INT 1
65422: ARRAY
65423: PPUSH
65424: LD_EXP 64
65428: PUSH
65429: LD_VAR 0 2
65433: ARRAY
65434: PUSH
65435: LD_INT 1
65437: ARRAY
65438: PUSH
65439: LD_INT 2
65441: ARRAY
65442: PPUSH
65443: LD_EXP 64
65447: PUSH
65448: LD_VAR 0 2
65452: ARRAY
65453: PUSH
65454: LD_INT 1
65456: ARRAY
65457: PUSH
65458: LD_INT 3
65460: ARRAY
65461: PPUSH
65462: LD_EXP 64
65466: PUSH
65467: LD_VAR 0 2
65471: ARRAY
65472: PUSH
65473: LD_INT 1
65475: ARRAY
65476: PUSH
65477: LD_INT 4
65479: ARRAY
65480: PPUSH
65481: CALL 27893 0 5
65485: AND
65486: OR
65487: IFFALSE 65768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65489: LD_ADDR_VAR 0 4
65493: PUSH
65494: LD_EXP 59
65498: PUSH
65499: LD_VAR 0 2
65503: ARRAY
65504: PPUSH
65505: LD_INT 25
65507: PUSH
65508: LD_INT 2
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PPUSH
65515: CALL_OW 72
65519: PUSH
65520: LD_EXP 61
65524: PUSH
65525: LD_VAR 0 2
65529: ARRAY
65530: DIFF
65531: ST_TO_ADDR
// if not tmp then
65532: LD_VAR 0 4
65536: NOT
65537: IFFALSE 65541
// continue ;
65539: GO 64786
// for j in tmp do
65541: LD_ADDR_VAR 0 3
65545: PUSH
65546: LD_VAR 0 4
65550: PUSH
65551: FOR_IN
65552: IFFALSE 65764
// begin if not mc_builders [ i ] then
65554: LD_EXP 65
65558: PUSH
65559: LD_VAR 0 2
65563: ARRAY
65564: NOT
65565: IFFALSE 65623
// begin SetTag ( j , 103 ) ;
65567: LD_VAR 0 3
65571: PPUSH
65572: LD_INT 103
65574: PPUSH
65575: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65579: LD_ADDR_EXP 65
65583: PUSH
65584: LD_EXP 65
65588: PPUSH
65589: LD_VAR 0 2
65593: PUSH
65594: LD_EXP 65
65598: PUSH
65599: LD_VAR 0 2
65603: ARRAY
65604: PUSH
65605: LD_INT 1
65607: PLUS
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PPUSH
65613: LD_VAR 0 3
65617: PPUSH
65618: CALL 19790 0 3
65622: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65623: LD_VAR 0 3
65627: PPUSH
65628: CALL_OW 310
65632: IFFALSE 65643
// ComExitBuilding ( j ) ;
65634: LD_VAR 0 3
65638: PPUSH
65639: CALL_OW 122
// wait ( 3 ) ;
65643: LD_INT 3
65645: PPUSH
65646: CALL_OW 67
// if not mc_build_list [ i ] then
65650: LD_EXP 64
65654: PUSH
65655: LD_VAR 0 2
65659: ARRAY
65660: NOT
65661: IFFALSE 65665
// break ;
65663: GO 65764
// if not HasTask ( j ) then
65665: LD_VAR 0 3
65669: PPUSH
65670: CALL_OW 314
65674: NOT
65675: IFFALSE 65762
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65677: LD_VAR 0 3
65681: PPUSH
65682: LD_EXP 64
65686: PUSH
65687: LD_VAR 0 2
65691: ARRAY
65692: PUSH
65693: LD_INT 1
65695: ARRAY
65696: PUSH
65697: LD_INT 1
65699: ARRAY
65700: PPUSH
65701: LD_EXP 64
65705: PUSH
65706: LD_VAR 0 2
65710: ARRAY
65711: PUSH
65712: LD_INT 1
65714: ARRAY
65715: PUSH
65716: LD_INT 2
65718: ARRAY
65719: PPUSH
65720: LD_EXP 64
65724: PUSH
65725: LD_VAR 0 2
65729: ARRAY
65730: PUSH
65731: LD_INT 1
65733: ARRAY
65734: PUSH
65735: LD_INT 3
65737: ARRAY
65738: PPUSH
65739: LD_EXP 64
65743: PUSH
65744: LD_VAR 0 2
65748: ARRAY
65749: PUSH
65750: LD_INT 1
65752: ARRAY
65753: PUSH
65754: LD_INT 4
65756: ARRAY
65757: PPUSH
65758: CALL_OW 145
// end ;
65762: GO 65551
65764: POP
65765: POP
// end else
65766: GO 65938
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65768: LD_EXP 59
65772: PUSH
65773: LD_VAR 0 2
65777: ARRAY
65778: PPUSH
65779: LD_EXP 64
65783: PUSH
65784: LD_VAR 0 2
65788: ARRAY
65789: PUSH
65790: LD_INT 1
65792: ARRAY
65793: PUSH
65794: LD_INT 1
65796: ARRAY
65797: PPUSH
65798: LD_EXP 64
65802: PUSH
65803: LD_VAR 0 2
65807: ARRAY
65808: PUSH
65809: LD_INT 1
65811: ARRAY
65812: PUSH
65813: LD_INT 2
65815: ARRAY
65816: PPUSH
65817: LD_EXP 64
65821: PUSH
65822: LD_VAR 0 2
65826: ARRAY
65827: PUSH
65828: LD_INT 1
65830: ARRAY
65831: PUSH
65832: LD_INT 3
65834: ARRAY
65835: PPUSH
65836: LD_EXP 64
65840: PUSH
65841: LD_VAR 0 2
65845: ARRAY
65846: PUSH
65847: LD_INT 1
65849: ARRAY
65850: PUSH
65851: LD_INT 4
65853: ARRAY
65854: PPUSH
65855: LD_EXP 59
65859: PUSH
65860: LD_VAR 0 2
65864: ARRAY
65865: PPUSH
65866: LD_INT 21
65868: PUSH
65869: LD_INT 3
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PPUSH
65876: CALL_OW 72
65880: PPUSH
65881: EMPTY
65882: PPUSH
65883: CALL 26643 0 7
65887: NOT
65888: IFFALSE 65938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65890: LD_ADDR_EXP 64
65894: PUSH
65895: LD_EXP 64
65899: PPUSH
65900: LD_VAR 0 2
65904: PPUSH
65905: LD_EXP 64
65909: PUSH
65910: LD_VAR 0 2
65914: ARRAY
65915: PPUSH
65916: LD_INT 1
65918: PPUSH
65919: LD_INT 1
65921: NEG
65922: PPUSH
65923: LD_INT 0
65925: PPUSH
65926: CALL 19208 0 4
65930: PPUSH
65931: CALL_OW 1
65935: ST_TO_ADDR
// continue ;
65936: GO 64786
// end ; end ; end ;
65938: GO 64786
65940: POP
65941: POP
// end ;
65942: LD_VAR 0 1
65946: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65947: LD_INT 0
65949: PPUSH
65950: PPUSH
65951: PPUSH
65952: PPUSH
65953: PPUSH
65954: PPUSH
// if not mc_bases then
65955: LD_EXP 59
65959: NOT
65960: IFFALSE 65964
// exit ;
65962: GO 66391
// for i = 1 to mc_bases do
65964: LD_ADDR_VAR 0 2
65968: PUSH
65969: DOUBLE
65970: LD_INT 1
65972: DEC
65973: ST_TO_ADDR
65974: LD_EXP 59
65978: PUSH
65979: FOR_TO
65980: IFFALSE 66389
// begin tmp := mc_build_upgrade [ i ] ;
65982: LD_ADDR_VAR 0 4
65986: PUSH
65987: LD_EXP 91
65991: PUSH
65992: LD_VAR 0 2
65996: ARRAY
65997: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
65998: LD_ADDR_VAR 0 6
66002: PUSH
66003: LD_EXP 92
66007: PUSH
66008: LD_VAR 0 2
66012: ARRAY
66013: PPUSH
66014: LD_INT 2
66016: PUSH
66017: LD_INT 30
66019: PUSH
66020: LD_INT 6
66022: PUSH
66023: EMPTY
66024: LIST
66025: LIST
66026: PUSH
66027: LD_INT 30
66029: PUSH
66030: LD_INT 7
66032: PUSH
66033: EMPTY
66034: LIST
66035: LIST
66036: PUSH
66037: EMPTY
66038: LIST
66039: LIST
66040: LIST
66041: PPUSH
66042: CALL_OW 72
66046: ST_TO_ADDR
// if not tmp and not lab then
66047: LD_VAR 0 4
66051: NOT
66052: PUSH
66053: LD_VAR 0 6
66057: NOT
66058: AND
66059: IFFALSE 66063
// continue ;
66061: GO 65979
// if tmp then
66063: LD_VAR 0 4
66067: IFFALSE 66187
// for j in tmp do
66069: LD_ADDR_VAR 0 3
66073: PUSH
66074: LD_VAR 0 4
66078: PUSH
66079: FOR_IN
66080: IFFALSE 66185
// begin if UpgradeCost ( j ) then
66082: LD_VAR 0 3
66086: PPUSH
66087: CALL 26303 0 1
66091: IFFALSE 66183
// begin ComUpgrade ( j ) ;
66093: LD_VAR 0 3
66097: PPUSH
66098: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66102: LD_ADDR_EXP 91
66106: PUSH
66107: LD_EXP 91
66111: PPUSH
66112: LD_VAR 0 2
66116: PPUSH
66117: LD_EXP 91
66121: PUSH
66122: LD_VAR 0 2
66126: ARRAY
66127: PUSH
66128: LD_VAR 0 3
66132: DIFF
66133: PPUSH
66134: CALL_OW 1
66138: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66139: LD_ADDR_EXP 66
66143: PUSH
66144: LD_EXP 66
66148: PPUSH
66149: LD_VAR 0 2
66153: PUSH
66154: LD_EXP 66
66158: PUSH
66159: LD_VAR 0 2
66163: ARRAY
66164: PUSH
66165: LD_INT 1
66167: PLUS
66168: PUSH
66169: EMPTY
66170: LIST
66171: LIST
66172: PPUSH
66173: LD_VAR 0 3
66177: PPUSH
66178: CALL 19790 0 3
66182: ST_TO_ADDR
// end ; end ;
66183: GO 66079
66185: POP
66186: POP
// if not lab or not mc_lab_upgrade [ i ] then
66187: LD_VAR 0 6
66191: NOT
66192: PUSH
66193: LD_EXP 93
66197: PUSH
66198: LD_VAR 0 2
66202: ARRAY
66203: NOT
66204: OR
66205: IFFALSE 66209
// continue ;
66207: GO 65979
// for j in lab do
66209: LD_ADDR_VAR 0 3
66213: PUSH
66214: LD_VAR 0 6
66218: PUSH
66219: FOR_IN
66220: IFFALSE 66385
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66222: LD_VAR 0 3
66226: PPUSH
66227: CALL_OW 266
66231: PUSH
66232: LD_INT 6
66234: PUSH
66235: LD_INT 7
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: IN
66242: PUSH
66243: LD_VAR 0 3
66247: PPUSH
66248: CALL_OW 461
66252: PUSH
66253: LD_INT 1
66255: NONEQUAL
66256: AND
66257: IFFALSE 66383
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66259: LD_VAR 0 3
66263: PPUSH
66264: LD_EXP 93
66268: PUSH
66269: LD_VAR 0 2
66273: ARRAY
66274: PUSH
66275: LD_INT 1
66277: ARRAY
66278: PPUSH
66279: CALL 26508 0 2
66283: IFFALSE 66383
// begin ComCancel ( j ) ;
66285: LD_VAR 0 3
66289: PPUSH
66290: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66294: LD_VAR 0 3
66298: PPUSH
66299: LD_EXP 93
66303: PUSH
66304: LD_VAR 0 2
66308: ARRAY
66309: PUSH
66310: LD_INT 1
66312: ARRAY
66313: PPUSH
66314: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66318: LD_VAR 0 3
66322: PUSH
66323: LD_EXP 66
66327: PUSH
66328: LD_VAR 0 2
66332: ARRAY
66333: IN
66334: NOT
66335: IFFALSE 66381
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66337: LD_ADDR_EXP 66
66341: PUSH
66342: LD_EXP 66
66346: PPUSH
66347: LD_VAR 0 2
66351: PUSH
66352: LD_EXP 66
66356: PUSH
66357: LD_VAR 0 2
66361: ARRAY
66362: PUSH
66363: LD_INT 1
66365: PLUS
66366: PUSH
66367: EMPTY
66368: LIST
66369: LIST
66370: PPUSH
66371: LD_VAR 0 3
66375: PPUSH
66376: CALL 19790 0 3
66380: ST_TO_ADDR
// break ;
66381: GO 66385
// end ; end ; end ;
66383: GO 66219
66385: POP
66386: POP
// end ;
66387: GO 65979
66389: POP
66390: POP
// end ;
66391: LD_VAR 0 1
66395: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66396: LD_INT 0
66398: PPUSH
66399: PPUSH
66400: PPUSH
66401: PPUSH
66402: PPUSH
66403: PPUSH
66404: PPUSH
66405: PPUSH
66406: PPUSH
// if not mc_bases then
66407: LD_EXP 59
66411: NOT
66412: IFFALSE 66416
// exit ;
66414: GO 66821
// for i = 1 to mc_bases do
66416: LD_ADDR_VAR 0 2
66420: PUSH
66421: DOUBLE
66422: LD_INT 1
66424: DEC
66425: ST_TO_ADDR
66426: LD_EXP 59
66430: PUSH
66431: FOR_TO
66432: IFFALSE 66819
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66434: LD_EXP 67
66438: PUSH
66439: LD_VAR 0 2
66443: ARRAY
66444: NOT
66445: PUSH
66446: LD_EXP 59
66450: PUSH
66451: LD_VAR 0 2
66455: ARRAY
66456: PPUSH
66457: LD_INT 30
66459: PUSH
66460: LD_INT 3
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PPUSH
66467: CALL_OW 72
66471: NOT
66472: OR
66473: IFFALSE 66477
// continue ;
66475: GO 66431
// busy := false ;
66477: LD_ADDR_VAR 0 8
66481: PUSH
66482: LD_INT 0
66484: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66485: LD_ADDR_VAR 0 4
66489: PUSH
66490: LD_EXP 59
66494: PUSH
66495: LD_VAR 0 2
66499: ARRAY
66500: PPUSH
66501: LD_INT 30
66503: PUSH
66504: LD_INT 3
66506: PUSH
66507: EMPTY
66508: LIST
66509: LIST
66510: PPUSH
66511: CALL_OW 72
66515: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66516: LD_ADDR_VAR 0 6
66520: PUSH
66521: LD_EXP 67
66525: PUSH
66526: LD_VAR 0 2
66530: ARRAY
66531: PPUSH
66532: LD_INT 2
66534: PUSH
66535: LD_INT 30
66537: PUSH
66538: LD_INT 32
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 30
66547: PUSH
66548: LD_INT 33
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: EMPTY
66556: LIST
66557: LIST
66558: LIST
66559: PPUSH
66560: CALL_OW 72
66564: ST_TO_ADDR
// if not t then
66565: LD_VAR 0 6
66569: NOT
66570: IFFALSE 66574
// continue ;
66572: GO 66431
// for j in tmp do
66574: LD_ADDR_VAR 0 3
66578: PUSH
66579: LD_VAR 0 4
66583: PUSH
66584: FOR_IN
66585: IFFALSE 66615
// if not BuildingStatus ( j ) = bs_idle then
66587: LD_VAR 0 3
66591: PPUSH
66592: CALL_OW 461
66596: PUSH
66597: LD_INT 2
66599: EQUAL
66600: NOT
66601: IFFALSE 66613
// begin busy := true ;
66603: LD_ADDR_VAR 0 8
66607: PUSH
66608: LD_INT 1
66610: ST_TO_ADDR
// break ;
66611: GO 66615
// end ;
66613: GO 66584
66615: POP
66616: POP
// if busy then
66617: LD_VAR 0 8
66621: IFFALSE 66625
// continue ;
66623: GO 66431
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66625: LD_ADDR_VAR 0 7
66629: PUSH
66630: LD_VAR 0 6
66634: PPUSH
66635: LD_INT 35
66637: PUSH
66638: LD_INT 0
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PPUSH
66645: CALL_OW 72
66649: ST_TO_ADDR
// if tw then
66650: LD_VAR 0 7
66654: IFFALSE 66731
// begin tw := tw [ 1 ] ;
66656: LD_ADDR_VAR 0 7
66660: PUSH
66661: LD_VAR 0 7
66665: PUSH
66666: LD_INT 1
66668: ARRAY
66669: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66670: LD_ADDR_VAR 0 9
66674: PUSH
66675: LD_VAR 0 7
66679: PPUSH
66680: LD_EXP 84
66684: PUSH
66685: LD_VAR 0 2
66689: ARRAY
66690: PPUSH
66691: CALL 24800 0 2
66695: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66696: LD_EXP 98
66700: PUSH
66701: LD_VAR 0 2
66705: ARRAY
66706: IFFALSE 66729
// if not weapon in mc_allowed_tower_weapons [ i ] then
66708: LD_VAR 0 9
66712: PUSH
66713: LD_EXP 98
66717: PUSH
66718: LD_VAR 0 2
66722: ARRAY
66723: IN
66724: NOT
66725: IFFALSE 66729
// continue ;
66727: GO 66431
// end else
66729: GO 66794
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66731: LD_ADDR_VAR 0 5
66735: PUSH
66736: LD_EXP 67
66740: PUSH
66741: LD_VAR 0 2
66745: ARRAY
66746: PPUSH
66747: LD_VAR 0 4
66751: PPUSH
66752: CALL 51089 0 2
66756: ST_TO_ADDR
// if not tmp2 then
66757: LD_VAR 0 5
66761: NOT
66762: IFFALSE 66766
// continue ;
66764: GO 66431
// tw := tmp2 [ 1 ] ;
66766: LD_ADDR_VAR 0 7
66770: PUSH
66771: LD_VAR 0 5
66775: PUSH
66776: LD_INT 1
66778: ARRAY
66779: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66780: LD_ADDR_VAR 0 9
66784: PUSH
66785: LD_VAR 0 5
66789: PUSH
66790: LD_INT 2
66792: ARRAY
66793: ST_TO_ADDR
// end ; if not weapon then
66794: LD_VAR 0 9
66798: NOT
66799: IFFALSE 66803
// continue ;
66801: GO 66431
// ComPlaceWeapon ( tw , weapon ) ;
66803: LD_VAR 0 7
66807: PPUSH
66808: LD_VAR 0 9
66812: PPUSH
66813: CALL_OW 148
// end ;
66817: GO 66431
66819: POP
66820: POP
// end ;
66821: LD_VAR 0 1
66825: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66826: LD_INT 0
66828: PPUSH
66829: PPUSH
66830: PPUSH
66831: PPUSH
66832: PPUSH
66833: PPUSH
66834: PPUSH
// if not mc_bases then
66835: LD_EXP 59
66839: NOT
66840: IFFALSE 66844
// exit ;
66842: GO 67612
// for i = 1 to mc_bases do
66844: LD_ADDR_VAR 0 2
66848: PUSH
66849: DOUBLE
66850: LD_INT 1
66852: DEC
66853: ST_TO_ADDR
66854: LD_EXP 59
66858: PUSH
66859: FOR_TO
66860: IFFALSE 67610
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66862: LD_EXP 72
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: NOT
66873: PUSH
66874: LD_EXP 72
66878: PUSH
66879: LD_VAR 0 2
66883: ARRAY
66884: PUSH
66885: LD_EXP 73
66889: PUSH
66890: LD_VAR 0 2
66894: ARRAY
66895: EQUAL
66896: OR
66897: PUSH
66898: LD_EXP 82
66902: PUSH
66903: LD_VAR 0 2
66907: ARRAY
66908: OR
66909: IFFALSE 66913
// continue ;
66911: GO 66859
// if mc_miners [ i ] then
66913: LD_EXP 73
66917: PUSH
66918: LD_VAR 0 2
66922: ARRAY
66923: IFFALSE 67297
// begin for j = mc_miners [ i ] downto 1 do
66925: LD_ADDR_VAR 0 3
66929: PUSH
66930: DOUBLE
66931: LD_EXP 73
66935: PUSH
66936: LD_VAR 0 2
66940: ARRAY
66941: INC
66942: ST_TO_ADDR
66943: LD_INT 1
66945: PUSH
66946: FOR_DOWNTO
66947: IFFALSE 67295
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66949: LD_EXP 73
66953: PUSH
66954: LD_VAR 0 2
66958: ARRAY
66959: PUSH
66960: LD_VAR 0 3
66964: ARRAY
66965: PPUSH
66966: CALL_OW 301
66970: PUSH
66971: LD_EXP 73
66975: PUSH
66976: LD_VAR 0 2
66980: ARRAY
66981: PUSH
66982: LD_VAR 0 3
66986: ARRAY
66987: PPUSH
66988: CALL_OW 257
66992: PUSH
66993: LD_INT 1
66995: NONEQUAL
66996: OR
66997: IFFALSE 67060
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
66999: LD_ADDR_VAR 0 5
67003: PUSH
67004: LD_EXP 73
67008: PUSH
67009: LD_VAR 0 2
67013: ARRAY
67014: PUSH
67015: LD_EXP 73
67019: PUSH
67020: LD_VAR 0 2
67024: ARRAY
67025: PUSH
67026: LD_VAR 0 3
67030: ARRAY
67031: DIFF
67032: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67033: LD_ADDR_EXP 73
67037: PUSH
67038: LD_EXP 73
67042: PPUSH
67043: LD_VAR 0 2
67047: PPUSH
67048: LD_VAR 0 5
67052: PPUSH
67053: CALL_OW 1
67057: ST_TO_ADDR
// continue ;
67058: GO 66946
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67060: LD_EXP 73
67064: PUSH
67065: LD_VAR 0 2
67069: ARRAY
67070: PUSH
67071: LD_VAR 0 3
67075: ARRAY
67076: PPUSH
67077: CALL_OW 257
67081: PUSH
67082: LD_INT 1
67084: EQUAL
67085: PUSH
67086: LD_EXP 73
67090: PUSH
67091: LD_VAR 0 2
67095: ARRAY
67096: PUSH
67097: LD_VAR 0 3
67101: ARRAY
67102: PPUSH
67103: CALL_OW 459
67107: NOT
67108: AND
67109: PUSH
67110: LD_EXP 73
67114: PUSH
67115: LD_VAR 0 2
67119: ARRAY
67120: PUSH
67121: LD_VAR 0 3
67125: ARRAY
67126: PPUSH
67127: CALL_OW 314
67131: NOT
67132: AND
67133: IFFALSE 67293
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67135: LD_EXP 73
67139: PUSH
67140: LD_VAR 0 2
67144: ARRAY
67145: PUSH
67146: LD_VAR 0 3
67150: ARRAY
67151: PPUSH
67152: CALL_OW 310
67156: IFFALSE 67179
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67158: LD_EXP 73
67162: PUSH
67163: LD_VAR 0 2
67167: ARRAY
67168: PUSH
67169: LD_VAR 0 3
67173: ARRAY
67174: PPUSH
67175: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67179: LD_EXP 73
67183: PUSH
67184: LD_VAR 0 2
67188: ARRAY
67189: PUSH
67190: LD_VAR 0 3
67194: ARRAY
67195: PPUSH
67196: CALL_OW 314
67200: NOT
67201: IFFALSE 67293
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67203: LD_ADDR_VAR 0 7
67207: PUSH
67208: LD_INT 1
67210: PPUSH
67211: LD_EXP 72
67215: PUSH
67216: LD_VAR 0 2
67220: ARRAY
67221: PPUSH
67222: CALL_OW 12
67226: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67227: LD_EXP 73
67231: PUSH
67232: LD_VAR 0 2
67236: ARRAY
67237: PUSH
67238: LD_VAR 0 3
67242: ARRAY
67243: PPUSH
67244: LD_EXP 72
67248: PUSH
67249: LD_VAR 0 2
67253: ARRAY
67254: PUSH
67255: LD_VAR 0 7
67259: ARRAY
67260: PUSH
67261: LD_INT 1
67263: ARRAY
67264: PPUSH
67265: LD_EXP 72
67269: PUSH
67270: LD_VAR 0 2
67274: ARRAY
67275: PUSH
67276: LD_VAR 0 7
67280: ARRAY
67281: PUSH
67282: LD_INT 2
67284: ARRAY
67285: PPUSH
67286: LD_INT 0
67288: PPUSH
67289: CALL_OW 193
// end ; end ; end ;
67293: GO 66946
67295: POP
67296: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67297: LD_ADDR_VAR 0 5
67301: PUSH
67302: LD_EXP 59
67306: PUSH
67307: LD_VAR 0 2
67311: ARRAY
67312: PPUSH
67313: LD_INT 2
67315: PUSH
67316: LD_INT 30
67318: PUSH
67319: LD_INT 4
67321: PUSH
67322: EMPTY
67323: LIST
67324: LIST
67325: PUSH
67326: LD_INT 30
67328: PUSH
67329: LD_INT 5
67331: PUSH
67332: EMPTY
67333: LIST
67334: LIST
67335: PUSH
67336: LD_INT 30
67338: PUSH
67339: LD_INT 32
67341: PUSH
67342: EMPTY
67343: LIST
67344: LIST
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: LIST
67350: LIST
67351: PPUSH
67352: CALL_OW 72
67356: ST_TO_ADDR
// if not tmp then
67357: LD_VAR 0 5
67361: NOT
67362: IFFALSE 67366
// continue ;
67364: GO 66859
// list := [ ] ;
67366: LD_ADDR_VAR 0 6
67370: PUSH
67371: EMPTY
67372: ST_TO_ADDR
// for j in tmp do
67373: LD_ADDR_VAR 0 3
67377: PUSH
67378: LD_VAR 0 5
67382: PUSH
67383: FOR_IN
67384: IFFALSE 67453
// begin for k in UnitsInside ( j ) do
67386: LD_ADDR_VAR 0 4
67390: PUSH
67391: LD_VAR 0 3
67395: PPUSH
67396: CALL_OW 313
67400: PUSH
67401: FOR_IN
67402: IFFALSE 67449
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67404: LD_VAR 0 4
67408: PPUSH
67409: CALL_OW 257
67413: PUSH
67414: LD_INT 1
67416: EQUAL
67417: PUSH
67418: LD_VAR 0 4
67422: PPUSH
67423: CALL_OW 459
67427: NOT
67428: AND
67429: IFFALSE 67447
// list := list ^ k ;
67431: LD_ADDR_VAR 0 6
67435: PUSH
67436: LD_VAR 0 6
67440: PUSH
67441: LD_VAR 0 4
67445: ADD
67446: ST_TO_ADDR
67447: GO 67401
67449: POP
67450: POP
// end ;
67451: GO 67383
67453: POP
67454: POP
// list := list diff mc_miners [ i ] ;
67455: LD_ADDR_VAR 0 6
67459: PUSH
67460: LD_VAR 0 6
67464: PUSH
67465: LD_EXP 73
67469: PUSH
67470: LD_VAR 0 2
67474: ARRAY
67475: DIFF
67476: ST_TO_ADDR
// if not list then
67477: LD_VAR 0 6
67481: NOT
67482: IFFALSE 67486
// continue ;
67484: GO 66859
// k := mc_mines [ i ] - mc_miners [ i ] ;
67486: LD_ADDR_VAR 0 4
67490: PUSH
67491: LD_EXP 72
67495: PUSH
67496: LD_VAR 0 2
67500: ARRAY
67501: PUSH
67502: LD_EXP 73
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: MINUS
67513: ST_TO_ADDR
// if k > list then
67514: LD_VAR 0 4
67518: PUSH
67519: LD_VAR 0 6
67523: GREATER
67524: IFFALSE 67536
// k := list ;
67526: LD_ADDR_VAR 0 4
67530: PUSH
67531: LD_VAR 0 6
67535: ST_TO_ADDR
// for j = 1 to k do
67536: LD_ADDR_VAR 0 3
67540: PUSH
67541: DOUBLE
67542: LD_INT 1
67544: DEC
67545: ST_TO_ADDR
67546: LD_VAR 0 4
67550: PUSH
67551: FOR_TO
67552: IFFALSE 67606
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67554: LD_ADDR_EXP 73
67558: PUSH
67559: LD_EXP 73
67563: PPUSH
67564: LD_VAR 0 2
67568: PUSH
67569: LD_EXP 73
67573: PUSH
67574: LD_VAR 0 2
67578: ARRAY
67579: PUSH
67580: LD_INT 1
67582: PLUS
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PPUSH
67588: LD_VAR 0 6
67592: PUSH
67593: LD_VAR 0 3
67597: ARRAY
67598: PPUSH
67599: CALL 19790 0 3
67603: ST_TO_ADDR
67604: GO 67551
67606: POP
67607: POP
// end ;
67608: GO 66859
67610: POP
67611: POP
// end ;
67612: LD_VAR 0 1
67616: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67617: LD_INT 0
67619: PPUSH
67620: PPUSH
67621: PPUSH
67622: PPUSH
67623: PPUSH
67624: PPUSH
67625: PPUSH
67626: PPUSH
67627: PPUSH
67628: PPUSH
67629: PPUSH
// if not mc_bases then
67630: LD_EXP 59
67634: NOT
67635: IFFALSE 67639
// exit ;
67637: GO 69462
// for i = 1 to mc_bases do
67639: LD_ADDR_VAR 0 2
67643: PUSH
67644: DOUBLE
67645: LD_INT 1
67647: DEC
67648: ST_TO_ADDR
67649: LD_EXP 59
67653: PUSH
67654: FOR_TO
67655: IFFALSE 69460
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67657: LD_EXP 59
67661: PUSH
67662: LD_VAR 0 2
67666: ARRAY
67667: NOT
67668: PUSH
67669: LD_EXP 66
67673: PUSH
67674: LD_VAR 0 2
67678: ARRAY
67679: OR
67680: IFFALSE 67684
// continue ;
67682: GO 67654
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67684: LD_EXP 75
67688: PUSH
67689: LD_VAR 0 2
67693: ARRAY
67694: NOT
67695: PUSH
67696: LD_EXP 76
67700: PUSH
67701: LD_VAR 0 2
67705: ARRAY
67706: AND
67707: IFFALSE 67745
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67709: LD_ADDR_EXP 76
67713: PUSH
67714: LD_EXP 76
67718: PPUSH
67719: LD_VAR 0 2
67723: PPUSH
67724: EMPTY
67725: PPUSH
67726: CALL_OW 1
67730: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67731: LD_VAR 0 2
67735: PPUSH
67736: LD_INT 107
67738: PPUSH
67739: CALL 58513 0 2
// continue ;
67743: GO 67654
// end ; target := [ ] ;
67745: LD_ADDR_VAR 0 7
67749: PUSH
67750: EMPTY
67751: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67752: LD_ADDR_VAR 0 6
67756: PUSH
67757: LD_EXP 59
67761: PUSH
67762: LD_VAR 0 2
67766: ARRAY
67767: PUSH
67768: LD_INT 1
67770: ARRAY
67771: PPUSH
67772: CALL_OW 255
67776: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67777: LD_ADDR_VAR 0 9
67781: PUSH
67782: LD_EXP 59
67786: PUSH
67787: LD_VAR 0 2
67791: ARRAY
67792: PPUSH
67793: LD_INT 2
67795: PUSH
67796: LD_INT 30
67798: PUSH
67799: LD_INT 0
67801: PUSH
67802: EMPTY
67803: LIST
67804: LIST
67805: PUSH
67806: LD_INT 30
67808: PUSH
67809: LD_INT 1
67811: PUSH
67812: EMPTY
67813: LIST
67814: LIST
67815: PUSH
67816: EMPTY
67817: LIST
67818: LIST
67819: LIST
67820: PPUSH
67821: CALL_OW 72
67825: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67826: LD_ADDR_VAR 0 3
67830: PUSH
67831: DOUBLE
67832: LD_EXP 75
67836: PUSH
67837: LD_VAR 0 2
67841: ARRAY
67842: INC
67843: ST_TO_ADDR
67844: LD_INT 1
67846: PUSH
67847: FOR_DOWNTO
67848: IFFALSE 68093
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67850: LD_EXP 75
67854: PUSH
67855: LD_VAR 0 2
67859: ARRAY
67860: PUSH
67861: LD_VAR 0 3
67865: ARRAY
67866: PUSH
67867: LD_INT 2
67869: ARRAY
67870: PPUSH
67871: LD_EXP 75
67875: PUSH
67876: LD_VAR 0 2
67880: ARRAY
67881: PUSH
67882: LD_VAR 0 3
67886: ARRAY
67887: PUSH
67888: LD_INT 3
67890: ARRAY
67891: PPUSH
67892: CALL_OW 488
67896: PUSH
67897: LD_EXP 75
67901: PUSH
67902: LD_VAR 0 2
67906: ARRAY
67907: PUSH
67908: LD_VAR 0 3
67912: ARRAY
67913: PUSH
67914: LD_INT 2
67916: ARRAY
67917: PPUSH
67918: LD_EXP 75
67922: PUSH
67923: LD_VAR 0 2
67927: ARRAY
67928: PUSH
67929: LD_VAR 0 3
67933: ARRAY
67934: PUSH
67935: LD_INT 3
67937: ARRAY
67938: PPUSH
67939: CALL_OW 284
67943: PUSH
67944: LD_INT 0
67946: EQUAL
67947: AND
67948: IFFALSE 68003
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67950: LD_ADDR_VAR 0 5
67954: PUSH
67955: LD_EXP 75
67959: PUSH
67960: LD_VAR 0 2
67964: ARRAY
67965: PPUSH
67966: LD_VAR 0 3
67970: PPUSH
67971: CALL_OW 3
67975: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67976: LD_ADDR_EXP 75
67980: PUSH
67981: LD_EXP 75
67985: PPUSH
67986: LD_VAR 0 2
67990: PPUSH
67991: LD_VAR 0 5
67995: PPUSH
67996: CALL_OW 1
68000: ST_TO_ADDR
// continue ;
68001: GO 67847
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68003: LD_VAR 0 6
68007: PPUSH
68008: LD_EXP 75
68012: PUSH
68013: LD_VAR 0 2
68017: ARRAY
68018: PUSH
68019: LD_VAR 0 3
68023: ARRAY
68024: PUSH
68025: LD_INT 2
68027: ARRAY
68028: PPUSH
68029: LD_EXP 75
68033: PUSH
68034: LD_VAR 0 2
68038: ARRAY
68039: PUSH
68040: LD_VAR 0 3
68044: ARRAY
68045: PUSH
68046: LD_INT 3
68048: ARRAY
68049: PPUSH
68050: LD_INT 30
68052: PPUSH
68053: CALL 20686 0 4
68057: PUSH
68058: LD_INT 4
68060: ARRAY
68061: PUSH
68062: LD_INT 0
68064: EQUAL
68065: IFFALSE 68091
// begin target := mc_crates [ i ] [ j ] ;
68067: LD_ADDR_VAR 0 7
68071: PUSH
68072: LD_EXP 75
68076: PUSH
68077: LD_VAR 0 2
68081: ARRAY
68082: PUSH
68083: LD_VAR 0 3
68087: ARRAY
68088: ST_TO_ADDR
// break ;
68089: GO 68093
// end ; end ;
68091: GO 67847
68093: POP
68094: POP
// if not target then
68095: LD_VAR 0 7
68099: NOT
68100: IFFALSE 68104
// continue ;
68102: GO 67654
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68104: LD_ADDR_VAR 0 8
68108: PUSH
68109: LD_EXP 78
68113: PUSH
68114: LD_VAR 0 2
68118: ARRAY
68119: PPUSH
68120: LD_INT 2
68122: PUSH
68123: LD_INT 3
68125: PUSH
68126: LD_INT 58
68128: PUSH
68129: EMPTY
68130: LIST
68131: PUSH
68132: EMPTY
68133: LIST
68134: LIST
68135: PUSH
68136: LD_INT 61
68138: PUSH
68139: EMPTY
68140: LIST
68141: PUSH
68142: LD_INT 33
68144: PUSH
68145: LD_INT 5
68147: PUSH
68148: EMPTY
68149: LIST
68150: LIST
68151: PUSH
68152: LD_INT 33
68154: PUSH
68155: LD_INT 3
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: EMPTY
68163: LIST
68164: LIST
68165: LIST
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: LD_INT 34
68174: PUSH
68175: LD_INT 32
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 34
68184: PUSH
68185: LD_INT 51
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 34
68194: PUSH
68195: LD_INT 12
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: EMPTY
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: PUSH
68208: EMPTY
68209: LIST
68210: LIST
68211: PPUSH
68212: CALL_OW 72
68216: ST_TO_ADDR
// if not cargo then
68217: LD_VAR 0 8
68221: NOT
68222: IFFALSE 68928
// begin if mc_crates_collector [ i ] < 5 then
68224: LD_EXP 76
68228: PUSH
68229: LD_VAR 0 2
68233: ARRAY
68234: PUSH
68235: LD_INT 5
68237: LESS
68238: IFFALSE 68604
// begin if mc_ape [ i ] then
68240: LD_EXP 88
68244: PUSH
68245: LD_VAR 0 2
68249: ARRAY
68250: IFFALSE 68297
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68252: LD_ADDR_VAR 0 5
68256: PUSH
68257: LD_EXP 88
68261: PUSH
68262: LD_VAR 0 2
68266: ARRAY
68267: PPUSH
68268: LD_INT 25
68270: PUSH
68271: LD_INT 16
68273: PUSH
68274: EMPTY
68275: LIST
68276: LIST
68277: PUSH
68278: LD_INT 24
68280: PUSH
68281: LD_INT 750
68283: PUSH
68284: EMPTY
68285: LIST
68286: LIST
68287: PUSH
68288: EMPTY
68289: LIST
68290: LIST
68291: PPUSH
68292: CALL_OW 72
68296: ST_TO_ADDR
// if not tmp then
68297: LD_VAR 0 5
68301: NOT
68302: IFFALSE 68349
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68304: LD_ADDR_VAR 0 5
68308: PUSH
68309: LD_EXP 59
68313: PUSH
68314: LD_VAR 0 2
68318: ARRAY
68319: PPUSH
68320: LD_INT 25
68322: PUSH
68323: LD_INT 2
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 24
68332: PUSH
68333: LD_INT 750
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PPUSH
68344: CALL_OW 72
68348: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68349: LD_EXP 88
68353: PUSH
68354: LD_VAR 0 2
68358: ARRAY
68359: PUSH
68360: LD_EXP 59
68364: PUSH
68365: LD_VAR 0 2
68369: ARRAY
68370: PPUSH
68371: LD_INT 25
68373: PUSH
68374: LD_INT 2
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 24
68383: PUSH
68384: LD_INT 750
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PPUSH
68395: CALL_OW 72
68399: AND
68400: PUSH
68401: LD_VAR 0 5
68405: PUSH
68406: LD_INT 5
68408: LESS
68409: AND
68410: IFFALSE 68492
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68412: LD_ADDR_VAR 0 3
68416: PUSH
68417: LD_EXP 59
68421: PUSH
68422: LD_VAR 0 2
68426: ARRAY
68427: PPUSH
68428: LD_INT 25
68430: PUSH
68431: LD_INT 2
68433: PUSH
68434: EMPTY
68435: LIST
68436: LIST
68437: PUSH
68438: LD_INT 24
68440: PUSH
68441: LD_INT 750
68443: PUSH
68444: EMPTY
68445: LIST
68446: LIST
68447: PUSH
68448: EMPTY
68449: LIST
68450: LIST
68451: PPUSH
68452: CALL_OW 72
68456: PUSH
68457: FOR_IN
68458: IFFALSE 68490
// begin tmp := tmp union j ;
68460: LD_ADDR_VAR 0 5
68464: PUSH
68465: LD_VAR 0 5
68469: PUSH
68470: LD_VAR 0 3
68474: UNION
68475: ST_TO_ADDR
// if tmp >= 5 then
68476: LD_VAR 0 5
68480: PUSH
68481: LD_INT 5
68483: GREATEREQUAL
68484: IFFALSE 68488
// break ;
68486: GO 68490
// end ;
68488: GO 68457
68490: POP
68491: POP
// end ; if not tmp then
68492: LD_VAR 0 5
68496: NOT
68497: IFFALSE 68501
// continue ;
68499: GO 67654
// for j in tmp do
68501: LD_ADDR_VAR 0 3
68505: PUSH
68506: LD_VAR 0 5
68510: PUSH
68511: FOR_IN
68512: IFFALSE 68602
// if not GetTag ( j ) then
68514: LD_VAR 0 3
68518: PPUSH
68519: CALL_OW 110
68523: NOT
68524: IFFALSE 68600
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68526: LD_ADDR_EXP 76
68530: PUSH
68531: LD_EXP 76
68535: PPUSH
68536: LD_VAR 0 2
68540: PUSH
68541: LD_EXP 76
68545: PUSH
68546: LD_VAR 0 2
68550: ARRAY
68551: PUSH
68552: LD_INT 1
68554: PLUS
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PPUSH
68560: LD_VAR 0 3
68564: PPUSH
68565: CALL 19790 0 3
68569: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68570: LD_VAR 0 3
68574: PPUSH
68575: LD_INT 107
68577: PPUSH
68578: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68582: LD_EXP 76
68586: PUSH
68587: LD_VAR 0 2
68591: ARRAY
68592: PUSH
68593: LD_INT 5
68595: GREATEREQUAL
68596: IFFALSE 68600
// break ;
68598: GO 68602
// end ;
68600: GO 68511
68602: POP
68603: POP
// end ; if mc_crates_collector [ i ] and target then
68604: LD_EXP 76
68608: PUSH
68609: LD_VAR 0 2
68613: ARRAY
68614: PUSH
68615: LD_VAR 0 7
68619: AND
68620: IFFALSE 68926
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68622: LD_EXP 76
68626: PUSH
68627: LD_VAR 0 2
68631: ARRAY
68632: PUSH
68633: LD_VAR 0 7
68637: PUSH
68638: LD_INT 1
68640: ARRAY
68641: LESS
68642: IFFALSE 68662
// tmp := mc_crates_collector [ i ] else
68644: LD_ADDR_VAR 0 5
68648: PUSH
68649: LD_EXP 76
68653: PUSH
68654: LD_VAR 0 2
68658: ARRAY
68659: ST_TO_ADDR
68660: GO 68676
// tmp := target [ 1 ] ;
68662: LD_ADDR_VAR 0 5
68666: PUSH
68667: LD_VAR 0 7
68671: PUSH
68672: LD_INT 1
68674: ARRAY
68675: ST_TO_ADDR
// k := 0 ;
68676: LD_ADDR_VAR 0 4
68680: PUSH
68681: LD_INT 0
68683: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68684: LD_ADDR_VAR 0 3
68688: PUSH
68689: LD_EXP 76
68693: PUSH
68694: LD_VAR 0 2
68698: ARRAY
68699: PUSH
68700: FOR_IN
68701: IFFALSE 68924
// begin k := k + 1 ;
68703: LD_ADDR_VAR 0 4
68707: PUSH
68708: LD_VAR 0 4
68712: PUSH
68713: LD_INT 1
68715: PLUS
68716: ST_TO_ADDR
// if k > tmp then
68717: LD_VAR 0 4
68721: PUSH
68722: LD_VAR 0 5
68726: GREATER
68727: IFFALSE 68731
// break ;
68729: GO 68924
// if not GetClass ( j ) in [ 2 , 16 ] then
68731: LD_VAR 0 3
68735: PPUSH
68736: CALL_OW 257
68740: PUSH
68741: LD_INT 2
68743: PUSH
68744: LD_INT 16
68746: PUSH
68747: EMPTY
68748: LIST
68749: LIST
68750: IN
68751: NOT
68752: IFFALSE 68805
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68754: LD_ADDR_EXP 76
68758: PUSH
68759: LD_EXP 76
68763: PPUSH
68764: LD_VAR 0 2
68768: PPUSH
68769: LD_EXP 76
68773: PUSH
68774: LD_VAR 0 2
68778: ARRAY
68779: PUSH
68780: LD_VAR 0 3
68784: DIFF
68785: PPUSH
68786: CALL_OW 1
68790: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68791: LD_VAR 0 3
68795: PPUSH
68796: LD_INT 0
68798: PPUSH
68799: CALL_OW 109
// continue ;
68803: GO 68700
// end ; if IsInUnit ( j ) then
68805: LD_VAR 0 3
68809: PPUSH
68810: CALL_OW 310
68814: IFFALSE 68825
// ComExitBuilding ( j ) ;
68816: LD_VAR 0 3
68820: PPUSH
68821: CALL_OW 122
// wait ( 3 ) ;
68825: LD_INT 3
68827: PPUSH
68828: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68832: LD_VAR 0 3
68836: PPUSH
68837: CALL_OW 314
68841: PUSH
68842: LD_VAR 0 6
68846: PPUSH
68847: LD_VAR 0 7
68851: PUSH
68852: LD_INT 2
68854: ARRAY
68855: PPUSH
68856: LD_VAR 0 7
68860: PUSH
68861: LD_INT 3
68863: ARRAY
68864: PPUSH
68865: LD_INT 30
68867: PPUSH
68868: CALL 20686 0 4
68872: PUSH
68873: LD_INT 4
68875: ARRAY
68876: AND
68877: IFFALSE 68895
// ComStandNearbyBuilding ( j , depot ) else
68879: LD_VAR 0 3
68883: PPUSH
68884: LD_VAR 0 9
68888: PPUSH
68889: CALL 16368 0 2
68893: GO 68922
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68895: LD_VAR 0 3
68899: PPUSH
68900: LD_VAR 0 7
68904: PUSH
68905: LD_INT 2
68907: ARRAY
68908: PPUSH
68909: LD_VAR 0 7
68913: PUSH
68914: LD_INT 3
68916: ARRAY
68917: PPUSH
68918: CALL_OW 117
// end ;
68922: GO 68700
68924: POP
68925: POP
// end ; end else
68926: GO 69458
// begin for j in cargo do
68928: LD_ADDR_VAR 0 3
68932: PUSH
68933: LD_VAR 0 8
68937: PUSH
68938: FOR_IN
68939: IFFALSE 69456
// begin if GetTag ( j ) <> 0 then
68941: LD_VAR 0 3
68945: PPUSH
68946: CALL_OW 110
68950: PUSH
68951: LD_INT 0
68953: NONEQUAL
68954: IFFALSE 68958
// continue ;
68956: GO 68938
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68958: LD_VAR 0 3
68962: PPUSH
68963: CALL_OW 256
68967: PUSH
68968: LD_INT 1000
68970: LESS
68971: PUSH
68972: LD_VAR 0 3
68976: PPUSH
68977: LD_EXP 83
68981: PUSH
68982: LD_VAR 0 2
68986: ARRAY
68987: PPUSH
68988: CALL_OW 308
68992: NOT
68993: AND
68994: IFFALSE 69016
// ComMoveToArea ( j , mc_parking [ i ] ) ;
68996: LD_VAR 0 3
69000: PPUSH
69001: LD_EXP 83
69005: PUSH
69006: LD_VAR 0 2
69010: ARRAY
69011: PPUSH
69012: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69016: LD_VAR 0 3
69020: PPUSH
69021: CALL_OW 256
69025: PUSH
69026: LD_INT 1000
69028: LESS
69029: PUSH
69030: LD_VAR 0 3
69034: PPUSH
69035: LD_EXP 83
69039: PUSH
69040: LD_VAR 0 2
69044: ARRAY
69045: PPUSH
69046: CALL_OW 308
69050: AND
69051: IFFALSE 69055
// continue ;
69053: GO 68938
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69055: LD_VAR 0 3
69059: PPUSH
69060: CALL_OW 262
69064: PUSH
69065: LD_INT 2
69067: EQUAL
69068: PUSH
69069: LD_VAR 0 3
69073: PPUSH
69074: CALL_OW 261
69078: PUSH
69079: LD_INT 15
69081: LESS
69082: AND
69083: IFFALSE 69087
// continue ;
69085: GO 68938
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69087: LD_VAR 0 3
69091: PPUSH
69092: CALL_OW 262
69096: PUSH
69097: LD_INT 1
69099: EQUAL
69100: PUSH
69101: LD_VAR 0 3
69105: PPUSH
69106: CALL_OW 261
69110: PUSH
69111: LD_INT 10
69113: LESS
69114: AND
69115: IFFALSE 69395
// begin if not depot then
69117: LD_VAR 0 9
69121: NOT
69122: IFFALSE 69126
// continue ;
69124: GO 68938
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69126: LD_VAR 0 3
69130: PPUSH
69131: LD_VAR 0 9
69135: PPUSH
69136: LD_VAR 0 3
69140: PPUSH
69141: CALL_OW 74
69145: PPUSH
69146: CALL_OW 296
69150: PUSH
69151: LD_INT 6
69153: LESS
69154: IFFALSE 69170
// SetFuel ( j , 100 ) else
69156: LD_VAR 0 3
69160: PPUSH
69161: LD_INT 100
69163: PPUSH
69164: CALL_OW 240
69168: GO 69395
// if GetFuel ( j ) = 0 then
69170: LD_VAR 0 3
69174: PPUSH
69175: CALL_OW 261
69179: PUSH
69180: LD_INT 0
69182: EQUAL
69183: IFFALSE 69395
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69185: LD_ADDR_EXP 78
69189: PUSH
69190: LD_EXP 78
69194: PPUSH
69195: LD_VAR 0 2
69199: PPUSH
69200: LD_EXP 78
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: PUSH
69211: LD_VAR 0 3
69215: DIFF
69216: PPUSH
69217: CALL_OW 1
69221: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69222: LD_VAR 0 3
69226: PPUSH
69227: CALL_OW 263
69231: PUSH
69232: LD_INT 1
69234: EQUAL
69235: IFFALSE 69251
// ComExitVehicle ( IsInUnit ( j ) ) ;
69237: LD_VAR 0 3
69241: PPUSH
69242: CALL_OW 310
69246: PPUSH
69247: CALL_OW 121
// if GetControl ( j ) = control_remote then
69251: LD_VAR 0 3
69255: PPUSH
69256: CALL_OW 263
69260: PUSH
69261: LD_INT 2
69263: EQUAL
69264: IFFALSE 69275
// ComUnlink ( j ) ;
69266: LD_VAR 0 3
69270: PPUSH
69271: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69275: LD_ADDR_VAR 0 10
69279: PUSH
69280: LD_VAR 0 2
69284: PPUSH
69285: LD_INT 3
69287: PPUSH
69288: CALL 78887 0 2
69292: ST_TO_ADDR
// if fac then
69293: LD_VAR 0 10
69297: IFFALSE 69393
// begin for k in fac do
69299: LD_ADDR_VAR 0 4
69303: PUSH
69304: LD_VAR 0 10
69308: PUSH
69309: FOR_IN
69310: IFFALSE 69391
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69312: LD_ADDR_VAR 0 11
69316: PUSH
69317: LD_VAR 0 10
69321: PPUSH
69322: LD_VAR 0 3
69326: PPUSH
69327: CALL_OW 265
69331: PPUSH
69332: LD_VAR 0 3
69336: PPUSH
69337: CALL_OW 262
69341: PPUSH
69342: LD_VAR 0 3
69346: PPUSH
69347: CALL_OW 263
69351: PPUSH
69352: LD_VAR 0 3
69356: PPUSH
69357: CALL_OW 264
69361: PPUSH
69362: CALL 17286 0 5
69366: ST_TO_ADDR
// if components then
69367: LD_VAR 0 11
69371: IFFALSE 69389
// begin MC_InsertProduceList ( i , components ) ;
69373: LD_VAR 0 2
69377: PPUSH
69378: LD_VAR 0 11
69382: PPUSH
69383: CALL 78432 0 2
// break ;
69387: GO 69391
// end ; end ;
69389: GO 69309
69391: POP
69392: POP
// end ; continue ;
69393: GO 68938
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69395: LD_VAR 0 3
69399: PPUSH
69400: LD_INT 1
69402: PPUSH
69403: CALL_OW 289
69407: PUSH
69408: LD_INT 100
69410: LESS
69411: PUSH
69412: LD_VAR 0 3
69416: PPUSH
69417: CALL_OW 314
69421: NOT
69422: AND
69423: IFFALSE 69452
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69425: LD_VAR 0 3
69429: PPUSH
69430: LD_VAR 0 7
69434: PUSH
69435: LD_INT 2
69437: ARRAY
69438: PPUSH
69439: LD_VAR 0 7
69443: PUSH
69444: LD_INT 3
69446: ARRAY
69447: PPUSH
69448: CALL_OW 117
// break ;
69452: GO 69456
// end ;
69454: GO 68938
69456: POP
69457: POP
// end ; end ;
69458: GO 67654
69460: POP
69461: POP
// end ;
69462: LD_VAR 0 1
69466: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69467: LD_INT 0
69469: PPUSH
69470: PPUSH
69471: PPUSH
69472: PPUSH
// if not mc_bases then
69473: LD_EXP 59
69477: NOT
69478: IFFALSE 69482
// exit ;
69480: GO 69643
// for i = 1 to mc_bases do
69482: LD_ADDR_VAR 0 2
69486: PUSH
69487: DOUBLE
69488: LD_INT 1
69490: DEC
69491: ST_TO_ADDR
69492: LD_EXP 59
69496: PUSH
69497: FOR_TO
69498: IFFALSE 69641
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69500: LD_ADDR_VAR 0 4
69504: PUSH
69505: LD_EXP 78
69509: PUSH
69510: LD_VAR 0 2
69514: ARRAY
69515: PUSH
69516: LD_EXP 81
69520: PUSH
69521: LD_VAR 0 2
69525: ARRAY
69526: UNION
69527: PPUSH
69528: LD_INT 33
69530: PUSH
69531: LD_INT 2
69533: PUSH
69534: EMPTY
69535: LIST
69536: LIST
69537: PPUSH
69538: CALL_OW 72
69542: ST_TO_ADDR
// if tmp then
69543: LD_VAR 0 4
69547: IFFALSE 69639
// for j in tmp do
69549: LD_ADDR_VAR 0 3
69553: PUSH
69554: LD_VAR 0 4
69558: PUSH
69559: FOR_IN
69560: IFFALSE 69637
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69562: LD_VAR 0 3
69566: PPUSH
69567: CALL_OW 312
69571: NOT
69572: PUSH
69573: LD_VAR 0 3
69577: PPUSH
69578: CALL_OW 256
69582: PUSH
69583: LD_INT 250
69585: GREATEREQUAL
69586: AND
69587: IFFALSE 69600
// Connect ( j ) else
69589: LD_VAR 0 3
69593: PPUSH
69594: CALL 22761 0 1
69598: GO 69635
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69600: LD_VAR 0 3
69604: PPUSH
69605: CALL_OW 256
69609: PUSH
69610: LD_INT 250
69612: LESS
69613: PUSH
69614: LD_VAR 0 3
69618: PPUSH
69619: CALL_OW 312
69623: AND
69624: IFFALSE 69635
// ComUnlink ( j ) ;
69626: LD_VAR 0 3
69630: PPUSH
69631: CALL_OW 136
69635: GO 69559
69637: POP
69638: POP
// end ;
69639: GO 69497
69641: POP
69642: POP
// end ;
69643: LD_VAR 0 1
69647: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69648: LD_INT 0
69650: PPUSH
69651: PPUSH
69652: PPUSH
69653: PPUSH
69654: PPUSH
// if not mc_bases then
69655: LD_EXP 59
69659: NOT
69660: IFFALSE 69664
// exit ;
69662: GO 70109
// for i = 1 to mc_bases do
69664: LD_ADDR_VAR 0 2
69668: PUSH
69669: DOUBLE
69670: LD_INT 1
69672: DEC
69673: ST_TO_ADDR
69674: LD_EXP 59
69678: PUSH
69679: FOR_TO
69680: IFFALSE 70107
// begin if not mc_produce [ i ] then
69682: LD_EXP 80
69686: PUSH
69687: LD_VAR 0 2
69691: ARRAY
69692: NOT
69693: IFFALSE 69697
// continue ;
69695: GO 69679
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69697: LD_ADDR_VAR 0 5
69701: PUSH
69702: LD_EXP 59
69706: PUSH
69707: LD_VAR 0 2
69711: ARRAY
69712: PPUSH
69713: LD_INT 30
69715: PUSH
69716: LD_INT 3
69718: PUSH
69719: EMPTY
69720: LIST
69721: LIST
69722: PPUSH
69723: CALL_OW 72
69727: ST_TO_ADDR
// if not fac then
69728: LD_VAR 0 5
69732: NOT
69733: IFFALSE 69737
// continue ;
69735: GO 69679
// for j in fac do
69737: LD_ADDR_VAR 0 3
69741: PUSH
69742: LD_VAR 0 5
69746: PUSH
69747: FOR_IN
69748: IFFALSE 70103
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69750: LD_VAR 0 3
69754: PPUSH
69755: CALL_OW 461
69759: PUSH
69760: LD_INT 2
69762: NONEQUAL
69763: PUSH
69764: LD_VAR 0 3
69768: PPUSH
69769: LD_INT 15
69771: PPUSH
69772: CALL 22389 0 2
69776: PUSH
69777: LD_INT 4
69779: ARRAY
69780: OR
69781: IFFALSE 69785
// continue ;
69783: GO 69747
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69785: LD_VAR 0 3
69789: PPUSH
69790: LD_EXP 80
69794: PUSH
69795: LD_VAR 0 2
69799: ARRAY
69800: PUSH
69801: LD_INT 1
69803: ARRAY
69804: PUSH
69805: LD_INT 1
69807: ARRAY
69808: PPUSH
69809: LD_EXP 80
69813: PUSH
69814: LD_VAR 0 2
69818: ARRAY
69819: PUSH
69820: LD_INT 1
69822: ARRAY
69823: PUSH
69824: LD_INT 2
69826: ARRAY
69827: PPUSH
69828: LD_EXP 80
69832: PUSH
69833: LD_VAR 0 2
69837: ARRAY
69838: PUSH
69839: LD_INT 1
69841: ARRAY
69842: PUSH
69843: LD_INT 3
69845: ARRAY
69846: PPUSH
69847: LD_EXP 80
69851: PUSH
69852: LD_VAR 0 2
69856: ARRAY
69857: PUSH
69858: LD_INT 1
69860: ARRAY
69861: PUSH
69862: LD_INT 4
69864: ARRAY
69865: PPUSH
69866: CALL_OW 448
69870: PUSH
69871: LD_VAR 0 3
69875: PPUSH
69876: LD_EXP 80
69880: PUSH
69881: LD_VAR 0 2
69885: ARRAY
69886: PUSH
69887: LD_INT 1
69889: ARRAY
69890: PUSH
69891: LD_INT 1
69893: ARRAY
69894: PUSH
69895: LD_EXP 80
69899: PUSH
69900: LD_VAR 0 2
69904: ARRAY
69905: PUSH
69906: LD_INT 1
69908: ARRAY
69909: PUSH
69910: LD_INT 2
69912: ARRAY
69913: PUSH
69914: LD_EXP 80
69918: PUSH
69919: LD_VAR 0 2
69923: ARRAY
69924: PUSH
69925: LD_INT 1
69927: ARRAY
69928: PUSH
69929: LD_INT 3
69931: ARRAY
69932: PUSH
69933: LD_EXP 80
69937: PUSH
69938: LD_VAR 0 2
69942: ARRAY
69943: PUSH
69944: LD_INT 1
69946: ARRAY
69947: PUSH
69948: LD_INT 4
69950: ARRAY
69951: PUSH
69952: EMPTY
69953: LIST
69954: LIST
69955: LIST
69956: LIST
69957: PPUSH
69958: CALL 26156 0 2
69962: AND
69963: IFFALSE 70101
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69965: LD_VAR 0 3
69969: PPUSH
69970: LD_EXP 80
69974: PUSH
69975: LD_VAR 0 2
69979: ARRAY
69980: PUSH
69981: LD_INT 1
69983: ARRAY
69984: PUSH
69985: LD_INT 1
69987: ARRAY
69988: PPUSH
69989: LD_EXP 80
69993: PUSH
69994: LD_VAR 0 2
69998: ARRAY
69999: PUSH
70000: LD_INT 1
70002: ARRAY
70003: PUSH
70004: LD_INT 2
70006: ARRAY
70007: PPUSH
70008: LD_EXP 80
70012: PUSH
70013: LD_VAR 0 2
70017: ARRAY
70018: PUSH
70019: LD_INT 1
70021: ARRAY
70022: PUSH
70023: LD_INT 3
70025: ARRAY
70026: PPUSH
70027: LD_EXP 80
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: PUSH
70038: LD_INT 1
70040: ARRAY
70041: PUSH
70042: LD_INT 4
70044: ARRAY
70045: PPUSH
70046: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70050: LD_ADDR_VAR 0 4
70054: PUSH
70055: LD_EXP 80
70059: PUSH
70060: LD_VAR 0 2
70064: ARRAY
70065: PPUSH
70066: LD_INT 1
70068: PPUSH
70069: CALL_OW 3
70073: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70074: LD_ADDR_EXP 80
70078: PUSH
70079: LD_EXP 80
70083: PPUSH
70084: LD_VAR 0 2
70088: PPUSH
70089: LD_VAR 0 4
70093: PPUSH
70094: CALL_OW 1
70098: ST_TO_ADDR
// break ;
70099: GO 70103
// end ; end ;
70101: GO 69747
70103: POP
70104: POP
// end ;
70105: GO 69679
70107: POP
70108: POP
// end ;
70109: LD_VAR 0 1
70113: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70114: LD_INT 0
70116: PPUSH
70117: PPUSH
70118: PPUSH
// if not mc_bases then
70119: LD_EXP 59
70123: NOT
70124: IFFALSE 70128
// exit ;
70126: GO 70217
// for i = 1 to mc_bases do
70128: LD_ADDR_VAR 0 2
70132: PUSH
70133: DOUBLE
70134: LD_INT 1
70136: DEC
70137: ST_TO_ADDR
70138: LD_EXP 59
70142: PUSH
70143: FOR_TO
70144: IFFALSE 70215
// begin if mc_attack [ i ] then
70146: LD_EXP 79
70150: PUSH
70151: LD_VAR 0 2
70155: ARRAY
70156: IFFALSE 70213
// begin tmp := mc_attack [ i ] [ 1 ] ;
70158: LD_ADDR_VAR 0 3
70162: PUSH
70163: LD_EXP 79
70167: PUSH
70168: LD_VAR 0 2
70172: ARRAY
70173: PUSH
70174: LD_INT 1
70176: ARRAY
70177: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70178: LD_ADDR_EXP 79
70182: PUSH
70183: LD_EXP 79
70187: PPUSH
70188: LD_VAR 0 2
70192: PPUSH
70193: EMPTY
70194: PPUSH
70195: CALL_OW 1
70199: ST_TO_ADDR
// Attack ( tmp ) ;
70200: LD_VAR 0 3
70204: PPUSH
70205: CALL 102193 0 1
// exit ;
70209: POP
70210: POP
70211: GO 70217
// end ; end ;
70213: GO 70143
70215: POP
70216: POP
// end ;
70217: LD_VAR 0 1
70221: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70222: LD_INT 0
70224: PPUSH
70225: PPUSH
70226: PPUSH
70227: PPUSH
70228: PPUSH
70229: PPUSH
70230: PPUSH
// if not mc_bases then
70231: LD_EXP 59
70235: NOT
70236: IFFALSE 70240
// exit ;
70238: GO 70950
// for i = 1 to mc_bases do
70240: LD_ADDR_VAR 0 2
70244: PUSH
70245: DOUBLE
70246: LD_INT 1
70248: DEC
70249: ST_TO_ADDR
70250: LD_EXP 59
70254: PUSH
70255: FOR_TO
70256: IFFALSE 70948
// begin if not mc_bases [ i ] then
70258: LD_EXP 59
70262: PUSH
70263: LD_VAR 0 2
70267: ARRAY
70268: NOT
70269: IFFALSE 70273
// continue ;
70271: GO 70255
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70273: LD_ADDR_VAR 0 7
70277: PUSH
70278: LD_EXP 59
70282: PUSH
70283: LD_VAR 0 2
70287: ARRAY
70288: PUSH
70289: LD_INT 1
70291: ARRAY
70292: PPUSH
70293: CALL 16590 0 1
70297: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70298: LD_ADDR_EXP 82
70302: PUSH
70303: LD_EXP 82
70307: PPUSH
70308: LD_VAR 0 2
70312: PPUSH
70313: LD_EXP 59
70317: PUSH
70318: LD_VAR 0 2
70322: ARRAY
70323: PUSH
70324: LD_INT 1
70326: ARRAY
70327: PPUSH
70328: CALL_OW 255
70332: PPUSH
70333: LD_EXP 84
70337: PUSH
70338: LD_VAR 0 2
70342: ARRAY
70343: PPUSH
70344: CALL 16555 0 2
70348: PPUSH
70349: CALL_OW 1
70353: ST_TO_ADDR
// if not mc_scan [ i ] then
70354: LD_EXP 82
70358: PUSH
70359: LD_VAR 0 2
70363: ARRAY
70364: NOT
70365: IFFALSE 70543
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70367: LD_ADDR_EXP 102
70371: PUSH
70372: LD_EXP 102
70376: PPUSH
70377: LD_VAR 0 2
70381: PPUSH
70382: LD_INT 0
70384: PPUSH
70385: CALL_OW 1
70389: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70390: LD_ADDR_VAR 0 4
70394: PUSH
70395: LD_EXP 59
70399: PUSH
70400: LD_VAR 0 2
70404: ARRAY
70405: PPUSH
70406: LD_INT 2
70408: PUSH
70409: LD_INT 25
70411: PUSH
70412: LD_INT 5
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 25
70421: PUSH
70422: LD_INT 8
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 25
70431: PUSH
70432: LD_INT 9
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: PPUSH
70445: CALL_OW 72
70449: ST_TO_ADDR
// if not tmp then
70450: LD_VAR 0 4
70454: NOT
70455: IFFALSE 70459
// continue ;
70457: GO 70255
// for j in tmp do
70459: LD_ADDR_VAR 0 3
70463: PUSH
70464: LD_VAR 0 4
70468: PUSH
70469: FOR_IN
70470: IFFALSE 70541
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70472: LD_VAR 0 3
70476: PPUSH
70477: CALL_OW 310
70481: PPUSH
70482: CALL_OW 266
70486: PUSH
70487: LD_INT 5
70489: EQUAL
70490: PUSH
70491: LD_VAR 0 3
70495: PPUSH
70496: CALL_OW 257
70500: PUSH
70501: LD_INT 1
70503: EQUAL
70504: AND
70505: PUSH
70506: LD_VAR 0 3
70510: PPUSH
70511: CALL_OW 459
70515: NOT
70516: AND
70517: PUSH
70518: LD_VAR 0 7
70522: AND
70523: IFFALSE 70539
// ComChangeProfession ( j , class ) ;
70525: LD_VAR 0 3
70529: PPUSH
70530: LD_VAR 0 7
70534: PPUSH
70535: CALL_OW 123
70539: GO 70469
70541: POP
70542: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
70543: LD_EXP 82
70547: PUSH
70548: LD_VAR 0 2
70552: ARRAY
70553: PUSH
70554: LD_EXP 102
70558: PUSH
70559: LD_VAR 0 2
70563: ARRAY
70564: NOT
70565: AND
70566: PUSH
70567: LD_EXP 81
70571: PUSH
70572: LD_VAR 0 2
70576: ARRAY
70577: NOT
70578: AND
70579: IFFALSE 70830
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70581: LD_ADDR_EXP 102
70585: PUSH
70586: LD_EXP 102
70590: PPUSH
70591: LD_VAR 0 2
70595: PPUSH
70596: LD_INT 1
70598: PPUSH
70599: CALL_OW 1
70603: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70604: LD_ADDR_VAR 0 4
70608: PUSH
70609: LD_EXP 59
70613: PUSH
70614: LD_VAR 0 2
70618: ARRAY
70619: PPUSH
70620: LD_INT 2
70622: PUSH
70623: LD_INT 25
70625: PUSH
70626: LD_INT 1
70628: PUSH
70629: EMPTY
70630: LIST
70631: LIST
70632: PUSH
70633: LD_INT 25
70635: PUSH
70636: LD_INT 5
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 25
70645: PUSH
70646: LD_INT 8
70648: PUSH
70649: EMPTY
70650: LIST
70651: LIST
70652: PUSH
70653: LD_INT 25
70655: PUSH
70656: LD_INT 9
70658: PUSH
70659: EMPTY
70660: LIST
70661: LIST
70662: PUSH
70663: EMPTY
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: PPUSH
70670: CALL_OW 72
70674: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70675: LD_ADDR_VAR 0 4
70679: PUSH
70680: LD_VAR 0 4
70684: PUSH
70685: LD_VAR 0 4
70689: PPUSH
70690: LD_INT 18
70692: PPUSH
70693: CALL 49059 0 2
70697: DIFF
70698: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70699: LD_VAR 0 4
70703: NOT
70704: PUSH
70705: LD_EXP 59
70709: PUSH
70710: LD_VAR 0 2
70714: ARRAY
70715: PPUSH
70716: LD_INT 2
70718: PUSH
70719: LD_INT 30
70721: PUSH
70722: LD_INT 4
70724: PUSH
70725: EMPTY
70726: LIST
70727: LIST
70728: PUSH
70729: LD_INT 30
70731: PUSH
70732: LD_INT 5
70734: PUSH
70735: EMPTY
70736: LIST
70737: LIST
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: LIST
70743: PPUSH
70744: CALL_OW 72
70748: NOT
70749: AND
70750: IFFALSE 70812
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70752: LD_ADDR_VAR 0 4
70756: PUSH
70757: LD_EXP 59
70761: PUSH
70762: LD_VAR 0 2
70766: ARRAY
70767: PPUSH
70768: LD_INT 2
70770: PUSH
70771: LD_INT 25
70773: PUSH
70774: LD_INT 2
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 25
70783: PUSH
70784: LD_INT 3
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 25
70793: PUSH
70794: LD_INT 4
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: LIST
70805: LIST
70806: PPUSH
70807: CALL_OW 72
70811: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70812: LD_VAR 0 2
70816: PPUSH
70817: LD_VAR 0 4
70821: PPUSH
70822: CALL 106902 0 2
// exit ;
70826: POP
70827: POP
70828: GO 70950
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70830: LD_EXP 82
70834: PUSH
70835: LD_VAR 0 2
70839: ARRAY
70840: PUSH
70841: LD_EXP 102
70845: PUSH
70846: LD_VAR 0 2
70850: ARRAY
70851: NOT
70852: AND
70853: PUSH
70854: LD_EXP 81
70858: PUSH
70859: LD_VAR 0 2
70863: ARRAY
70864: AND
70865: IFFALSE 70946
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70867: LD_ADDR_EXP 102
70871: PUSH
70872: LD_EXP 102
70876: PPUSH
70877: LD_VAR 0 2
70881: PPUSH
70882: LD_INT 1
70884: PPUSH
70885: CALL_OW 1
70889: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
70890: LD_ADDR_VAR 0 4
70894: PUSH
70895: LD_EXP 81
70899: PUSH
70900: LD_VAR 0 2
70904: ARRAY
70905: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
70906: LD_ADDR_EXP 81
70910: PUSH
70911: LD_EXP 81
70915: PPUSH
70916: LD_VAR 0 2
70920: PPUSH
70921: EMPTY
70922: PPUSH
70923: CALL_OW 1
70927: ST_TO_ADDR
// Defend ( i , tmp ) ;
70928: LD_VAR 0 2
70932: PPUSH
70933: LD_VAR 0 4
70937: PPUSH
70938: CALL 107472 0 2
// exit ;
70942: POP
70943: POP
70944: GO 70950
// end ; end ;
70946: GO 70255
70948: POP
70949: POP
// end ;
70950: LD_VAR 0 1
70954: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
70955: LD_INT 0
70957: PPUSH
70958: PPUSH
70959: PPUSH
70960: PPUSH
70961: PPUSH
70962: PPUSH
70963: PPUSH
70964: PPUSH
70965: PPUSH
70966: PPUSH
70967: PPUSH
// if not mc_bases then
70968: LD_EXP 59
70972: NOT
70973: IFFALSE 70977
// exit ;
70975: GO 72064
// for i = 1 to mc_bases do
70977: LD_ADDR_VAR 0 2
70981: PUSH
70982: DOUBLE
70983: LD_INT 1
70985: DEC
70986: ST_TO_ADDR
70987: LD_EXP 59
70991: PUSH
70992: FOR_TO
70993: IFFALSE 72062
// begin tmp := mc_lab [ i ] ;
70995: LD_ADDR_VAR 0 6
70999: PUSH
71000: LD_EXP 92
71004: PUSH
71005: LD_VAR 0 2
71009: ARRAY
71010: ST_TO_ADDR
// if not tmp then
71011: LD_VAR 0 6
71015: NOT
71016: IFFALSE 71020
// continue ;
71018: GO 70992
// idle_lab := 0 ;
71020: LD_ADDR_VAR 0 11
71024: PUSH
71025: LD_INT 0
71027: ST_TO_ADDR
// for j in tmp do
71028: LD_ADDR_VAR 0 3
71032: PUSH
71033: LD_VAR 0 6
71037: PUSH
71038: FOR_IN
71039: IFFALSE 72058
// begin researching := false ;
71041: LD_ADDR_VAR 0 10
71045: PUSH
71046: LD_INT 0
71048: ST_TO_ADDR
// side := GetSide ( j ) ;
71049: LD_ADDR_VAR 0 4
71053: PUSH
71054: LD_VAR 0 3
71058: PPUSH
71059: CALL_OW 255
71063: ST_TO_ADDR
// if not mc_tech [ side ] then
71064: LD_EXP 86
71068: PUSH
71069: LD_VAR 0 4
71073: ARRAY
71074: NOT
71075: IFFALSE 71079
// continue ;
71077: GO 71038
// if BuildingStatus ( j ) = bs_idle then
71079: LD_VAR 0 3
71083: PPUSH
71084: CALL_OW 461
71088: PUSH
71089: LD_INT 2
71091: EQUAL
71092: IFFALSE 71280
// begin if idle_lab and UnitsInside ( j ) < 6 then
71094: LD_VAR 0 11
71098: PUSH
71099: LD_VAR 0 3
71103: PPUSH
71104: CALL_OW 313
71108: PUSH
71109: LD_INT 6
71111: LESS
71112: AND
71113: IFFALSE 71184
// begin tmp2 := UnitsInside ( idle_lab ) ;
71115: LD_ADDR_VAR 0 9
71119: PUSH
71120: LD_VAR 0 11
71124: PPUSH
71125: CALL_OW 313
71129: ST_TO_ADDR
// if tmp2 then
71130: LD_VAR 0 9
71134: IFFALSE 71176
// for x in tmp2 do
71136: LD_ADDR_VAR 0 7
71140: PUSH
71141: LD_VAR 0 9
71145: PUSH
71146: FOR_IN
71147: IFFALSE 71174
// begin ComExitBuilding ( x ) ;
71149: LD_VAR 0 7
71153: PPUSH
71154: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71158: LD_VAR 0 7
71162: PPUSH
71163: LD_VAR 0 3
71167: PPUSH
71168: CALL_OW 180
// end ;
71172: GO 71146
71174: POP
71175: POP
// idle_lab := 0 ;
71176: LD_ADDR_VAR 0 11
71180: PUSH
71181: LD_INT 0
71183: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71184: LD_ADDR_VAR 0 5
71188: PUSH
71189: LD_EXP 86
71193: PUSH
71194: LD_VAR 0 4
71198: ARRAY
71199: PUSH
71200: FOR_IN
71201: IFFALSE 71261
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71203: LD_VAR 0 3
71207: PPUSH
71208: LD_VAR 0 5
71212: PPUSH
71213: CALL_OW 430
71217: PUSH
71218: LD_VAR 0 4
71222: PPUSH
71223: LD_VAR 0 5
71227: PPUSH
71228: CALL 15660 0 2
71232: AND
71233: IFFALSE 71259
// begin researching := true ;
71235: LD_ADDR_VAR 0 10
71239: PUSH
71240: LD_INT 1
71242: ST_TO_ADDR
// ComResearch ( j , t ) ;
71243: LD_VAR 0 3
71247: PPUSH
71248: LD_VAR 0 5
71252: PPUSH
71253: CALL_OW 124
// break ;
71257: GO 71261
// end ;
71259: GO 71200
71261: POP
71262: POP
// if not researching then
71263: LD_VAR 0 10
71267: NOT
71268: IFFALSE 71280
// idle_lab := j ;
71270: LD_ADDR_VAR 0 11
71274: PUSH
71275: LD_VAR 0 3
71279: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71280: LD_VAR 0 3
71284: PPUSH
71285: CALL_OW 461
71289: PUSH
71290: LD_INT 10
71292: EQUAL
71293: IFFALSE 71881
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71295: LD_EXP 88
71299: PUSH
71300: LD_VAR 0 2
71304: ARRAY
71305: NOT
71306: PUSH
71307: LD_EXP 89
71311: PUSH
71312: LD_VAR 0 2
71316: ARRAY
71317: NOT
71318: AND
71319: PUSH
71320: LD_EXP 86
71324: PUSH
71325: LD_VAR 0 4
71329: ARRAY
71330: PUSH
71331: LD_INT 1
71333: GREATER
71334: AND
71335: IFFALSE 71466
// begin ComCancel ( j ) ;
71337: LD_VAR 0 3
71341: PPUSH
71342: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71346: LD_ADDR_EXP 86
71350: PUSH
71351: LD_EXP 86
71355: PPUSH
71356: LD_VAR 0 4
71360: PPUSH
71361: LD_EXP 86
71365: PUSH
71366: LD_VAR 0 4
71370: ARRAY
71371: PPUSH
71372: LD_EXP 86
71376: PUSH
71377: LD_VAR 0 4
71381: ARRAY
71382: PUSH
71383: LD_INT 1
71385: MINUS
71386: PPUSH
71387: LD_EXP 86
71391: PUSH
71392: LD_VAR 0 4
71396: ARRAY
71397: PPUSH
71398: LD_INT 0
71400: PPUSH
71401: CALL 19208 0 4
71405: PPUSH
71406: CALL_OW 1
71410: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71411: LD_ADDR_EXP 86
71415: PUSH
71416: LD_EXP 86
71420: PPUSH
71421: LD_VAR 0 4
71425: PPUSH
71426: LD_EXP 86
71430: PUSH
71431: LD_VAR 0 4
71435: ARRAY
71436: PPUSH
71437: LD_EXP 86
71441: PUSH
71442: LD_VAR 0 4
71446: ARRAY
71447: PPUSH
71448: LD_INT 1
71450: PPUSH
71451: LD_INT 0
71453: PPUSH
71454: CALL 19208 0 4
71458: PPUSH
71459: CALL_OW 1
71463: ST_TO_ADDR
// continue ;
71464: GO 71038
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71466: LD_EXP 88
71470: PUSH
71471: LD_VAR 0 2
71475: ARRAY
71476: PUSH
71477: LD_EXP 89
71481: PUSH
71482: LD_VAR 0 2
71486: ARRAY
71487: NOT
71488: AND
71489: IFFALSE 71616
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71491: LD_ADDR_EXP 89
71495: PUSH
71496: LD_EXP 89
71500: PPUSH
71501: LD_VAR 0 2
71505: PUSH
71506: LD_EXP 89
71510: PUSH
71511: LD_VAR 0 2
71515: ARRAY
71516: PUSH
71517: LD_INT 1
71519: PLUS
71520: PUSH
71521: EMPTY
71522: LIST
71523: LIST
71524: PPUSH
71525: LD_EXP 88
71529: PUSH
71530: LD_VAR 0 2
71534: ARRAY
71535: PUSH
71536: LD_INT 1
71538: ARRAY
71539: PPUSH
71540: CALL 19790 0 3
71544: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71545: LD_EXP 88
71549: PUSH
71550: LD_VAR 0 2
71554: ARRAY
71555: PUSH
71556: LD_INT 1
71558: ARRAY
71559: PPUSH
71560: LD_INT 112
71562: PPUSH
71563: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71567: LD_ADDR_VAR 0 9
71571: PUSH
71572: LD_EXP 88
71576: PUSH
71577: LD_VAR 0 2
71581: ARRAY
71582: PPUSH
71583: LD_INT 1
71585: PPUSH
71586: CALL_OW 3
71590: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71591: LD_ADDR_EXP 88
71595: PUSH
71596: LD_EXP 88
71600: PPUSH
71601: LD_VAR 0 2
71605: PPUSH
71606: LD_VAR 0 9
71610: PPUSH
71611: CALL_OW 1
71615: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71616: LD_EXP 88
71620: PUSH
71621: LD_VAR 0 2
71625: ARRAY
71626: PUSH
71627: LD_EXP 89
71631: PUSH
71632: LD_VAR 0 2
71636: ARRAY
71637: AND
71638: PUSH
71639: LD_EXP 89
71643: PUSH
71644: LD_VAR 0 2
71648: ARRAY
71649: PUSH
71650: LD_INT 1
71652: ARRAY
71653: PPUSH
71654: CALL_OW 310
71658: NOT
71659: AND
71660: PUSH
71661: LD_VAR 0 3
71665: PPUSH
71666: CALL_OW 313
71670: PUSH
71671: LD_INT 6
71673: EQUAL
71674: AND
71675: IFFALSE 71731
// begin tmp2 := UnitsInside ( j ) ;
71677: LD_ADDR_VAR 0 9
71681: PUSH
71682: LD_VAR 0 3
71686: PPUSH
71687: CALL_OW 313
71691: ST_TO_ADDR
// if tmp2 = 6 then
71692: LD_VAR 0 9
71696: PUSH
71697: LD_INT 6
71699: EQUAL
71700: IFFALSE 71731
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71702: LD_VAR 0 9
71706: PUSH
71707: LD_INT 1
71709: ARRAY
71710: PPUSH
71711: LD_INT 112
71713: PPUSH
71714: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71718: LD_VAR 0 9
71722: PUSH
71723: LD_INT 1
71725: ARRAY
71726: PPUSH
71727: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71731: LD_EXP 89
71735: PUSH
71736: LD_VAR 0 2
71740: ARRAY
71741: PUSH
71742: LD_EXP 89
71746: PUSH
71747: LD_VAR 0 2
71751: ARRAY
71752: PUSH
71753: LD_INT 1
71755: ARRAY
71756: PPUSH
71757: CALL_OW 314
71761: NOT
71762: AND
71763: PUSH
71764: LD_EXP 89
71768: PUSH
71769: LD_VAR 0 2
71773: ARRAY
71774: PUSH
71775: LD_INT 1
71777: ARRAY
71778: PPUSH
71779: CALL_OW 310
71783: NOT
71784: AND
71785: IFFALSE 71811
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71787: LD_EXP 89
71791: PUSH
71792: LD_VAR 0 2
71796: ARRAY
71797: PUSH
71798: LD_INT 1
71800: ARRAY
71801: PPUSH
71802: LD_VAR 0 3
71806: PPUSH
71807: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71811: LD_EXP 89
71815: PUSH
71816: LD_VAR 0 2
71820: ARRAY
71821: PUSH
71822: LD_INT 1
71824: ARRAY
71825: PPUSH
71826: CALL_OW 310
71830: PUSH
71831: LD_EXP 89
71835: PUSH
71836: LD_VAR 0 2
71840: ARRAY
71841: PUSH
71842: LD_INT 1
71844: ARRAY
71845: PPUSH
71846: CALL_OW 310
71850: PPUSH
71851: CALL_OW 461
71855: PUSH
71856: LD_INT 3
71858: NONEQUAL
71859: AND
71860: IFFALSE 71881
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
71862: LD_EXP 89
71866: PUSH
71867: LD_VAR 0 2
71871: ARRAY
71872: PUSH
71873: LD_INT 1
71875: ARRAY
71876: PPUSH
71877: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
71881: LD_VAR 0 3
71885: PPUSH
71886: CALL_OW 461
71890: PUSH
71891: LD_INT 6
71893: EQUAL
71894: PUSH
71895: LD_VAR 0 6
71899: PUSH
71900: LD_INT 1
71902: GREATER
71903: AND
71904: IFFALSE 72056
// begin sci := [ ] ;
71906: LD_ADDR_VAR 0 8
71910: PUSH
71911: EMPTY
71912: ST_TO_ADDR
// for x in ( tmp diff j ) do
71913: LD_ADDR_VAR 0 7
71917: PUSH
71918: LD_VAR 0 6
71922: PUSH
71923: LD_VAR 0 3
71927: DIFF
71928: PUSH
71929: FOR_IN
71930: IFFALSE 71982
// begin if sci = 6 then
71932: LD_VAR 0 8
71936: PUSH
71937: LD_INT 6
71939: EQUAL
71940: IFFALSE 71944
// break ;
71942: GO 71982
// if BuildingStatus ( x ) = bs_idle then
71944: LD_VAR 0 7
71948: PPUSH
71949: CALL_OW 461
71953: PUSH
71954: LD_INT 2
71956: EQUAL
71957: IFFALSE 71980
// sci := sci ^ UnitsInside ( x ) ;
71959: LD_ADDR_VAR 0 8
71963: PUSH
71964: LD_VAR 0 8
71968: PUSH
71969: LD_VAR 0 7
71973: PPUSH
71974: CALL_OW 313
71978: ADD
71979: ST_TO_ADDR
// end ;
71980: GO 71929
71982: POP
71983: POP
// if not sci then
71984: LD_VAR 0 8
71988: NOT
71989: IFFALSE 71993
// continue ;
71991: GO 71038
// for x in sci do
71993: LD_ADDR_VAR 0 7
71997: PUSH
71998: LD_VAR 0 8
72002: PUSH
72003: FOR_IN
72004: IFFALSE 72054
// if IsInUnit ( x ) and not HasTask ( x ) then
72006: LD_VAR 0 7
72010: PPUSH
72011: CALL_OW 310
72015: PUSH
72016: LD_VAR 0 7
72020: PPUSH
72021: CALL_OW 314
72025: NOT
72026: AND
72027: IFFALSE 72052
// begin ComExitBuilding ( x ) ;
72029: LD_VAR 0 7
72033: PPUSH
72034: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72038: LD_VAR 0 7
72042: PPUSH
72043: LD_VAR 0 3
72047: PPUSH
72048: CALL_OW 180
// end ;
72052: GO 72003
72054: POP
72055: POP
// end ; end ;
72056: GO 71038
72058: POP
72059: POP
// end ;
72060: GO 70992
72062: POP
72063: POP
// end ;
72064: LD_VAR 0 1
72068: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72069: LD_INT 0
72071: PPUSH
72072: PPUSH
// if not mc_bases then
72073: LD_EXP 59
72077: NOT
72078: IFFALSE 72082
// exit ;
72080: GO 72163
// for i = 1 to mc_bases do
72082: LD_ADDR_VAR 0 2
72086: PUSH
72087: DOUBLE
72088: LD_INT 1
72090: DEC
72091: ST_TO_ADDR
72092: LD_EXP 59
72096: PUSH
72097: FOR_TO
72098: IFFALSE 72161
// if mc_mines [ i ] and mc_miners [ i ] then
72100: LD_EXP 72
72104: PUSH
72105: LD_VAR 0 2
72109: ARRAY
72110: PUSH
72111: LD_EXP 73
72115: PUSH
72116: LD_VAR 0 2
72120: ARRAY
72121: AND
72122: IFFALSE 72159
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72124: LD_EXP 73
72128: PUSH
72129: LD_VAR 0 2
72133: ARRAY
72134: PUSH
72135: LD_INT 1
72137: ARRAY
72138: PPUSH
72139: CALL_OW 255
72143: PPUSH
72144: LD_EXP 72
72148: PUSH
72149: LD_VAR 0 2
72153: ARRAY
72154: PPUSH
72155: CALL 16743 0 2
72159: GO 72097
72161: POP
72162: POP
// end ;
72163: LD_VAR 0 1
72167: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72168: LD_INT 0
72170: PPUSH
72171: PPUSH
72172: PPUSH
72173: PPUSH
72174: PPUSH
72175: PPUSH
72176: PPUSH
72177: PPUSH
// if not mc_bases or not mc_parking then
72178: LD_EXP 59
72182: NOT
72183: PUSH
72184: LD_EXP 83
72188: NOT
72189: OR
72190: IFFALSE 72194
// exit ;
72192: GO 72904
// for i = 1 to mc_bases do
72194: LD_ADDR_VAR 0 2
72198: PUSH
72199: DOUBLE
72200: LD_INT 1
72202: DEC
72203: ST_TO_ADDR
72204: LD_EXP 59
72208: PUSH
72209: FOR_TO
72210: IFFALSE 72902
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72212: LD_EXP 59
72216: PUSH
72217: LD_VAR 0 2
72221: ARRAY
72222: NOT
72223: PUSH
72224: LD_EXP 83
72228: PUSH
72229: LD_VAR 0 2
72233: ARRAY
72234: NOT
72235: OR
72236: IFFALSE 72240
// continue ;
72238: GO 72209
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72240: LD_ADDR_VAR 0 5
72244: PUSH
72245: LD_EXP 59
72249: PUSH
72250: LD_VAR 0 2
72254: ARRAY
72255: PUSH
72256: LD_INT 1
72258: ARRAY
72259: PPUSH
72260: CALL_OW 255
72264: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72265: LD_ADDR_VAR 0 6
72269: PUSH
72270: LD_EXP 59
72274: PUSH
72275: LD_VAR 0 2
72279: ARRAY
72280: PPUSH
72281: LD_INT 30
72283: PUSH
72284: LD_INT 3
72286: PUSH
72287: EMPTY
72288: LIST
72289: LIST
72290: PPUSH
72291: CALL_OW 72
72295: ST_TO_ADDR
// if not fac then
72296: LD_VAR 0 6
72300: NOT
72301: IFFALSE 72352
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72303: LD_ADDR_VAR 0 6
72307: PUSH
72308: LD_EXP 59
72312: PUSH
72313: LD_VAR 0 2
72317: ARRAY
72318: PPUSH
72319: LD_INT 2
72321: PUSH
72322: LD_INT 30
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: EMPTY
72329: LIST
72330: LIST
72331: PUSH
72332: LD_INT 30
72334: PUSH
72335: LD_INT 1
72337: PUSH
72338: EMPTY
72339: LIST
72340: LIST
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: LIST
72346: PPUSH
72347: CALL_OW 72
72351: ST_TO_ADDR
// if not fac then
72352: LD_VAR 0 6
72356: NOT
72357: IFFALSE 72361
// continue ;
72359: GO 72209
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72361: LD_ADDR_VAR 0 7
72365: PUSH
72366: LD_EXP 83
72370: PUSH
72371: LD_VAR 0 2
72375: ARRAY
72376: PPUSH
72377: LD_INT 22
72379: PUSH
72380: LD_VAR 0 5
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: LD_INT 21
72391: PUSH
72392: LD_INT 2
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 3
72401: PUSH
72402: LD_INT 24
72404: PUSH
72405: LD_INT 1000
72407: PUSH
72408: EMPTY
72409: LIST
72410: LIST
72411: PUSH
72412: EMPTY
72413: LIST
72414: LIST
72415: PUSH
72416: EMPTY
72417: LIST
72418: LIST
72419: LIST
72420: PPUSH
72421: CALL_OW 70
72425: ST_TO_ADDR
// for j in fac do
72426: LD_ADDR_VAR 0 3
72430: PUSH
72431: LD_VAR 0 6
72435: PUSH
72436: FOR_IN
72437: IFFALSE 72518
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72439: LD_ADDR_VAR 0 7
72443: PUSH
72444: LD_VAR 0 7
72448: PUSH
72449: LD_INT 22
72451: PUSH
72452: LD_VAR 0 5
72456: PUSH
72457: EMPTY
72458: LIST
72459: LIST
72460: PUSH
72461: LD_INT 91
72463: PUSH
72464: LD_VAR 0 3
72468: PUSH
72469: LD_INT 15
72471: PUSH
72472: EMPTY
72473: LIST
72474: LIST
72475: LIST
72476: PUSH
72477: LD_INT 21
72479: PUSH
72480: LD_INT 2
72482: PUSH
72483: EMPTY
72484: LIST
72485: LIST
72486: PUSH
72487: LD_INT 3
72489: PUSH
72490: LD_INT 24
72492: PUSH
72493: LD_INT 1000
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: EMPTY
72505: LIST
72506: LIST
72507: LIST
72508: LIST
72509: PPUSH
72510: CALL_OW 69
72514: UNION
72515: ST_TO_ADDR
72516: GO 72436
72518: POP
72519: POP
// if not vehs then
72520: LD_VAR 0 7
72524: NOT
72525: IFFALSE 72551
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72527: LD_ADDR_EXP 71
72531: PUSH
72532: LD_EXP 71
72536: PPUSH
72537: LD_VAR 0 2
72541: PPUSH
72542: EMPTY
72543: PPUSH
72544: CALL_OW 1
72548: ST_TO_ADDR
// continue ;
72549: GO 72209
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72551: LD_ADDR_VAR 0 8
72555: PUSH
72556: LD_EXP 59
72560: PUSH
72561: LD_VAR 0 2
72565: ARRAY
72566: PPUSH
72567: LD_INT 30
72569: PUSH
72570: LD_INT 3
72572: PUSH
72573: EMPTY
72574: LIST
72575: LIST
72576: PPUSH
72577: CALL_OW 72
72581: ST_TO_ADDR
// if tmp then
72582: LD_VAR 0 8
72586: IFFALSE 72689
// begin for j in tmp do
72588: LD_ADDR_VAR 0 3
72592: PUSH
72593: LD_VAR 0 8
72597: PUSH
72598: FOR_IN
72599: IFFALSE 72687
// for k in UnitsInside ( j ) do
72601: LD_ADDR_VAR 0 4
72605: PUSH
72606: LD_VAR 0 3
72610: PPUSH
72611: CALL_OW 313
72615: PUSH
72616: FOR_IN
72617: IFFALSE 72683
// if k then
72619: LD_VAR 0 4
72623: IFFALSE 72681
// if not k in mc_repair_vehicle [ i ] then
72625: LD_VAR 0 4
72629: PUSH
72630: LD_EXP 71
72634: PUSH
72635: LD_VAR 0 2
72639: ARRAY
72640: IN
72641: NOT
72642: IFFALSE 72681
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72644: LD_ADDR_EXP 71
72648: PUSH
72649: LD_EXP 71
72653: PPUSH
72654: LD_VAR 0 2
72658: PPUSH
72659: LD_EXP 71
72663: PUSH
72664: LD_VAR 0 2
72668: ARRAY
72669: PUSH
72670: LD_VAR 0 4
72674: UNION
72675: PPUSH
72676: CALL_OW 1
72680: ST_TO_ADDR
72681: GO 72616
72683: POP
72684: POP
72685: GO 72598
72687: POP
72688: POP
// end ; if not mc_repair_vehicle [ i ] then
72689: LD_EXP 71
72693: PUSH
72694: LD_VAR 0 2
72698: ARRAY
72699: NOT
72700: IFFALSE 72704
// continue ;
72702: GO 72209
// for j in mc_repair_vehicle [ i ] do
72704: LD_ADDR_VAR 0 3
72708: PUSH
72709: LD_EXP 71
72713: PUSH
72714: LD_VAR 0 2
72718: ARRAY
72719: PUSH
72720: FOR_IN
72721: IFFALSE 72898
// begin if GetClass ( j ) <> 3 then
72723: LD_VAR 0 3
72727: PPUSH
72728: CALL_OW 257
72732: PUSH
72733: LD_INT 3
72735: NONEQUAL
72736: IFFALSE 72777
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72738: LD_ADDR_EXP 71
72742: PUSH
72743: LD_EXP 71
72747: PPUSH
72748: LD_VAR 0 2
72752: PPUSH
72753: LD_EXP 71
72757: PUSH
72758: LD_VAR 0 2
72762: ARRAY
72763: PUSH
72764: LD_VAR 0 3
72768: DIFF
72769: PPUSH
72770: CALL_OW 1
72774: ST_TO_ADDR
// continue ;
72775: GO 72720
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72777: LD_VAR 0 3
72781: PPUSH
72782: CALL_OW 311
72786: NOT
72787: PUSH
72788: LD_VAR 0 3
72792: PUSH
72793: LD_EXP 62
72797: PUSH
72798: LD_VAR 0 2
72802: ARRAY
72803: PUSH
72804: LD_INT 1
72806: ARRAY
72807: IN
72808: NOT
72809: AND
72810: PUSH
72811: LD_VAR 0 3
72815: PUSH
72816: LD_EXP 62
72820: PUSH
72821: LD_VAR 0 2
72825: ARRAY
72826: PUSH
72827: LD_INT 2
72829: ARRAY
72830: IN
72831: NOT
72832: AND
72833: IFFALSE 72896
// begin if IsInUnit ( j ) then
72835: LD_VAR 0 3
72839: PPUSH
72840: CALL_OW 310
72844: IFFALSE 72857
// ComExitBuilding ( j ) else
72846: LD_VAR 0 3
72850: PPUSH
72851: CALL_OW 122
72855: GO 72896
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
72857: LD_VAR 0 3
72861: PPUSH
72862: LD_VAR 0 7
72866: PUSH
72867: LD_INT 1
72869: ARRAY
72870: PPUSH
72871: CALL 53397 0 2
72875: NOT
72876: IFFALSE 72896
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
72878: LD_VAR 0 3
72882: PPUSH
72883: LD_VAR 0 7
72887: PUSH
72888: LD_INT 1
72890: ARRAY
72891: PPUSH
72892: CALL_OW 129
// end ; end ;
72896: GO 72720
72898: POP
72899: POP
// end ;
72900: GO 72209
72902: POP
72903: POP
// end ;
72904: LD_VAR 0 1
72908: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
72909: LD_INT 0
72911: PPUSH
72912: PPUSH
72913: PPUSH
72914: PPUSH
72915: PPUSH
72916: PPUSH
72917: PPUSH
72918: PPUSH
72919: PPUSH
72920: PPUSH
72921: PPUSH
// if not mc_bases then
72922: LD_EXP 59
72926: NOT
72927: IFFALSE 72931
// exit ;
72929: GO 73733
// for i = 1 to mc_bases do
72931: LD_ADDR_VAR 0 2
72935: PUSH
72936: DOUBLE
72937: LD_INT 1
72939: DEC
72940: ST_TO_ADDR
72941: LD_EXP 59
72945: PUSH
72946: FOR_TO
72947: IFFALSE 73731
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
72949: LD_EXP 87
72953: PUSH
72954: LD_VAR 0 2
72958: ARRAY
72959: NOT
72960: PUSH
72961: LD_EXP 62
72965: PUSH
72966: LD_VAR 0 2
72970: ARRAY
72971: PUSH
72972: LD_INT 1
72974: ARRAY
72975: OR
72976: PUSH
72977: LD_EXP 62
72981: PUSH
72982: LD_VAR 0 2
72986: ARRAY
72987: PUSH
72988: LD_INT 2
72990: ARRAY
72991: OR
72992: PUSH
72993: LD_EXP 85
72997: PUSH
72998: LD_VAR 0 2
73002: ARRAY
73003: PPUSH
73004: LD_INT 1
73006: PPUSH
73007: CALL_OW 325
73011: NOT
73012: OR
73013: PUSH
73014: LD_EXP 82
73018: PUSH
73019: LD_VAR 0 2
73023: ARRAY
73024: OR
73025: IFFALSE 73029
// continue ;
73027: GO 72946
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73029: LD_ADDR_VAR 0 8
73033: PUSH
73034: LD_EXP 59
73038: PUSH
73039: LD_VAR 0 2
73043: ARRAY
73044: PPUSH
73045: LD_INT 25
73047: PUSH
73048: LD_INT 4
73050: PUSH
73051: EMPTY
73052: LIST
73053: LIST
73054: PUSH
73055: LD_INT 50
73057: PUSH
73058: EMPTY
73059: LIST
73060: PUSH
73061: LD_INT 3
73063: PUSH
73064: LD_INT 60
73066: PUSH
73067: EMPTY
73068: LIST
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: LIST
73078: PPUSH
73079: CALL_OW 72
73083: PUSH
73084: LD_EXP 63
73088: PUSH
73089: LD_VAR 0 2
73093: ARRAY
73094: DIFF
73095: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73096: LD_ADDR_VAR 0 9
73100: PUSH
73101: LD_EXP 59
73105: PUSH
73106: LD_VAR 0 2
73110: ARRAY
73111: PPUSH
73112: LD_INT 2
73114: PUSH
73115: LD_INT 30
73117: PUSH
73118: LD_INT 0
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 30
73127: PUSH
73128: LD_INT 1
73130: PUSH
73131: EMPTY
73132: LIST
73133: LIST
73134: PUSH
73135: EMPTY
73136: LIST
73137: LIST
73138: LIST
73139: PPUSH
73140: CALL_OW 72
73144: ST_TO_ADDR
// if not tmp or not dep then
73145: LD_VAR 0 8
73149: NOT
73150: PUSH
73151: LD_VAR 0 9
73155: NOT
73156: OR
73157: IFFALSE 73161
// continue ;
73159: GO 72946
// side := GetSide ( tmp [ 1 ] ) ;
73161: LD_ADDR_VAR 0 11
73165: PUSH
73166: LD_VAR 0 8
73170: PUSH
73171: LD_INT 1
73173: ARRAY
73174: PPUSH
73175: CALL_OW 255
73179: ST_TO_ADDR
// dep := dep [ 1 ] ;
73180: LD_ADDR_VAR 0 9
73184: PUSH
73185: LD_VAR 0 9
73189: PUSH
73190: LD_INT 1
73192: ARRAY
73193: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73194: LD_ADDR_VAR 0 7
73198: PUSH
73199: LD_EXP 87
73203: PUSH
73204: LD_VAR 0 2
73208: ARRAY
73209: PPUSH
73210: LD_INT 22
73212: PUSH
73213: LD_INT 0
73215: PUSH
73216: EMPTY
73217: LIST
73218: LIST
73219: PUSH
73220: LD_INT 25
73222: PUSH
73223: LD_INT 12
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PPUSH
73234: CALL_OW 70
73238: PUSH
73239: LD_INT 22
73241: PUSH
73242: LD_INT 0
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: PUSH
73249: LD_INT 25
73251: PUSH
73252: LD_INT 12
73254: PUSH
73255: EMPTY
73256: LIST
73257: LIST
73258: PUSH
73259: LD_INT 91
73261: PUSH
73262: LD_VAR 0 9
73266: PUSH
73267: LD_INT 20
73269: PUSH
73270: EMPTY
73271: LIST
73272: LIST
73273: LIST
73274: PUSH
73275: EMPTY
73276: LIST
73277: LIST
73278: LIST
73279: PPUSH
73280: CALL_OW 69
73284: UNION
73285: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73286: LD_ADDR_VAR 0 10
73290: PUSH
73291: LD_EXP 87
73295: PUSH
73296: LD_VAR 0 2
73300: ARRAY
73301: PPUSH
73302: LD_INT 81
73304: PUSH
73305: LD_VAR 0 11
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: PPUSH
73314: CALL_OW 70
73318: ST_TO_ADDR
// if not apes or danger_at_area then
73319: LD_VAR 0 7
73323: NOT
73324: PUSH
73325: LD_VAR 0 10
73329: OR
73330: IFFALSE 73380
// begin if mc_taming [ i ] then
73332: LD_EXP 90
73336: PUSH
73337: LD_VAR 0 2
73341: ARRAY
73342: IFFALSE 73378
// begin MC_Reset ( i , 121 ) ;
73344: LD_VAR 0 2
73348: PPUSH
73349: LD_INT 121
73351: PPUSH
73352: CALL 58513 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73356: LD_ADDR_EXP 90
73360: PUSH
73361: LD_EXP 90
73365: PPUSH
73366: LD_VAR 0 2
73370: PPUSH
73371: EMPTY
73372: PPUSH
73373: CALL_OW 1
73377: ST_TO_ADDR
// end ; continue ;
73378: GO 72946
// end ; for j in tmp do
73380: LD_ADDR_VAR 0 3
73384: PUSH
73385: LD_VAR 0 8
73389: PUSH
73390: FOR_IN
73391: IFFALSE 73727
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73393: LD_VAR 0 3
73397: PUSH
73398: LD_EXP 90
73402: PUSH
73403: LD_VAR 0 2
73407: ARRAY
73408: IN
73409: NOT
73410: PUSH
73411: LD_EXP 90
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PUSH
73422: LD_INT 3
73424: LESS
73425: AND
73426: IFFALSE 73484
// begin SetTag ( j , 121 ) ;
73428: LD_VAR 0 3
73432: PPUSH
73433: LD_INT 121
73435: PPUSH
73436: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73440: LD_ADDR_EXP 90
73444: PUSH
73445: LD_EXP 90
73449: PPUSH
73450: LD_VAR 0 2
73454: PUSH
73455: LD_EXP 90
73459: PUSH
73460: LD_VAR 0 2
73464: ARRAY
73465: PUSH
73466: LD_INT 1
73468: PLUS
73469: PUSH
73470: EMPTY
73471: LIST
73472: LIST
73473: PPUSH
73474: LD_VAR 0 3
73478: PPUSH
73479: CALL 19790 0 3
73483: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73484: LD_VAR 0 3
73488: PUSH
73489: LD_EXP 90
73493: PUSH
73494: LD_VAR 0 2
73498: ARRAY
73499: IN
73500: IFFALSE 73725
// begin if GetClass ( j ) <> 4 then
73502: LD_VAR 0 3
73506: PPUSH
73507: CALL_OW 257
73511: PUSH
73512: LD_INT 4
73514: NONEQUAL
73515: IFFALSE 73568
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73517: LD_ADDR_EXP 90
73521: PUSH
73522: LD_EXP 90
73526: PPUSH
73527: LD_VAR 0 2
73531: PPUSH
73532: LD_EXP 90
73536: PUSH
73537: LD_VAR 0 2
73541: ARRAY
73542: PUSH
73543: LD_VAR 0 3
73547: DIFF
73548: PPUSH
73549: CALL_OW 1
73553: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73554: LD_VAR 0 3
73558: PPUSH
73559: LD_INT 0
73561: PPUSH
73562: CALL_OW 109
// continue ;
73566: GO 73390
// end ; if IsInUnit ( j ) then
73568: LD_VAR 0 3
73572: PPUSH
73573: CALL_OW 310
73577: IFFALSE 73588
// ComExitBuilding ( j ) ;
73579: LD_VAR 0 3
73583: PPUSH
73584: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73588: LD_ADDR_VAR 0 6
73592: PUSH
73593: LD_VAR 0 7
73597: PPUSH
73598: LD_VAR 0 3
73602: PPUSH
73603: CALL_OW 74
73607: ST_TO_ADDR
// if not ape then
73608: LD_VAR 0 6
73612: NOT
73613: IFFALSE 73617
// break ;
73615: GO 73727
// x := GetX ( ape ) ;
73617: LD_ADDR_VAR 0 4
73621: PUSH
73622: LD_VAR 0 6
73626: PPUSH
73627: CALL_OW 250
73631: ST_TO_ADDR
// y := GetY ( ape ) ;
73632: LD_ADDR_VAR 0 5
73636: PUSH
73637: LD_VAR 0 6
73641: PPUSH
73642: CALL_OW 251
73646: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73647: LD_VAR 0 4
73651: PPUSH
73652: LD_VAR 0 5
73656: PPUSH
73657: CALL_OW 488
73661: NOT
73662: PUSH
73663: LD_VAR 0 11
73667: PPUSH
73668: LD_VAR 0 4
73672: PPUSH
73673: LD_VAR 0 5
73677: PPUSH
73678: LD_INT 20
73680: PPUSH
73681: CALL 20686 0 4
73685: PUSH
73686: LD_INT 4
73688: ARRAY
73689: OR
73690: IFFALSE 73694
// break ;
73692: GO 73727
// if not HasTask ( j ) then
73694: LD_VAR 0 3
73698: PPUSH
73699: CALL_OW 314
73703: NOT
73704: IFFALSE 73725
// ComTameXY ( j , x , y ) ;
73706: LD_VAR 0 3
73710: PPUSH
73711: LD_VAR 0 4
73715: PPUSH
73716: LD_VAR 0 5
73720: PPUSH
73721: CALL_OW 131
// end ; end ;
73725: GO 73390
73727: POP
73728: POP
// end ;
73729: GO 72946
73731: POP
73732: POP
// end ;
73733: LD_VAR 0 1
73737: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73738: LD_INT 0
73740: PPUSH
73741: PPUSH
73742: PPUSH
73743: PPUSH
73744: PPUSH
73745: PPUSH
73746: PPUSH
73747: PPUSH
// if not mc_bases then
73748: LD_EXP 59
73752: NOT
73753: IFFALSE 73757
// exit ;
73755: GO 74383
// for i = 1 to mc_bases do
73757: LD_ADDR_VAR 0 2
73761: PUSH
73762: DOUBLE
73763: LD_INT 1
73765: DEC
73766: ST_TO_ADDR
73767: LD_EXP 59
73771: PUSH
73772: FOR_TO
73773: IFFALSE 74381
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73775: LD_EXP 88
73779: PUSH
73780: LD_VAR 0 2
73784: ARRAY
73785: NOT
73786: PUSH
73787: LD_EXP 88
73791: PUSH
73792: LD_VAR 0 2
73796: ARRAY
73797: PPUSH
73798: LD_INT 25
73800: PUSH
73801: LD_INT 12
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PPUSH
73808: CALL_OW 72
73812: NOT
73813: OR
73814: IFFALSE 73818
// continue ;
73816: GO 73772
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73818: LD_ADDR_VAR 0 5
73822: PUSH
73823: LD_EXP 88
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: PUSH
73834: LD_INT 1
73836: ARRAY
73837: PPUSH
73838: CALL_OW 255
73842: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
73843: LD_VAR 0 5
73847: PPUSH
73848: LD_INT 2
73850: PPUSH
73851: CALL_OW 325
73855: IFFALSE 74108
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
73857: LD_ADDR_VAR 0 4
73861: PUSH
73862: LD_EXP 88
73866: PUSH
73867: LD_VAR 0 2
73871: ARRAY
73872: PPUSH
73873: LD_INT 25
73875: PUSH
73876: LD_INT 16
73878: PUSH
73879: EMPTY
73880: LIST
73881: LIST
73882: PPUSH
73883: CALL_OW 72
73887: ST_TO_ADDR
// if tmp < 6 then
73888: LD_VAR 0 4
73892: PUSH
73893: LD_INT 6
73895: LESS
73896: IFFALSE 74108
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73898: LD_ADDR_VAR 0 6
73902: PUSH
73903: LD_EXP 59
73907: PUSH
73908: LD_VAR 0 2
73912: ARRAY
73913: PPUSH
73914: LD_INT 2
73916: PUSH
73917: LD_INT 30
73919: PUSH
73920: LD_INT 0
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 30
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: LIST
73941: PPUSH
73942: CALL_OW 72
73946: ST_TO_ADDR
// if depot then
73947: LD_VAR 0 6
73951: IFFALSE 74108
// begin selected := 0 ;
73953: LD_ADDR_VAR 0 7
73957: PUSH
73958: LD_INT 0
73960: ST_TO_ADDR
// for j in depot do
73961: LD_ADDR_VAR 0 3
73965: PUSH
73966: LD_VAR 0 6
73970: PUSH
73971: FOR_IN
73972: IFFALSE 74003
// begin if UnitsInside ( j ) < 6 then
73974: LD_VAR 0 3
73978: PPUSH
73979: CALL_OW 313
73983: PUSH
73984: LD_INT 6
73986: LESS
73987: IFFALSE 74001
// begin selected := j ;
73989: LD_ADDR_VAR 0 7
73993: PUSH
73994: LD_VAR 0 3
73998: ST_TO_ADDR
// break ;
73999: GO 74003
// end ; end ;
74001: GO 73971
74003: POP
74004: POP
// if selected then
74005: LD_VAR 0 7
74009: IFFALSE 74108
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74011: LD_ADDR_VAR 0 3
74015: PUSH
74016: LD_EXP 88
74020: PUSH
74021: LD_VAR 0 2
74025: ARRAY
74026: PPUSH
74027: LD_INT 25
74029: PUSH
74030: LD_INT 12
74032: PUSH
74033: EMPTY
74034: LIST
74035: LIST
74036: PPUSH
74037: CALL_OW 72
74041: PUSH
74042: FOR_IN
74043: IFFALSE 74106
// if not HasTask ( j ) then
74045: LD_VAR 0 3
74049: PPUSH
74050: CALL_OW 314
74054: NOT
74055: IFFALSE 74104
// begin if not IsInUnit ( j ) then
74057: LD_VAR 0 3
74061: PPUSH
74062: CALL_OW 310
74066: NOT
74067: IFFALSE 74083
// ComEnterUnit ( j , selected ) ;
74069: LD_VAR 0 3
74073: PPUSH
74074: LD_VAR 0 7
74078: PPUSH
74079: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74083: LD_VAR 0 3
74087: PPUSH
74088: LD_INT 16
74090: PPUSH
74091: CALL_OW 183
// AddComExitBuilding ( j ) ;
74095: LD_VAR 0 3
74099: PPUSH
74100: CALL_OW 182
// end ;
74104: GO 74042
74106: POP
74107: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74108: LD_VAR 0 5
74112: PPUSH
74113: LD_INT 11
74115: PPUSH
74116: CALL_OW 325
74120: IFFALSE 74379
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74122: LD_ADDR_VAR 0 4
74126: PUSH
74127: LD_EXP 88
74131: PUSH
74132: LD_VAR 0 2
74136: ARRAY
74137: PPUSH
74138: LD_INT 25
74140: PUSH
74141: LD_INT 16
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PPUSH
74148: CALL_OW 72
74152: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74153: LD_VAR 0 4
74157: PUSH
74158: LD_INT 6
74160: GREATEREQUAL
74161: PUSH
74162: LD_VAR 0 5
74166: PPUSH
74167: LD_INT 2
74169: PPUSH
74170: CALL_OW 325
74174: NOT
74175: OR
74176: IFFALSE 74379
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74178: LD_ADDR_VAR 0 8
74182: PUSH
74183: LD_EXP 59
74187: PUSH
74188: LD_VAR 0 2
74192: ARRAY
74193: PPUSH
74194: LD_INT 2
74196: PUSH
74197: LD_INT 30
74199: PUSH
74200: LD_INT 4
74202: PUSH
74203: EMPTY
74204: LIST
74205: LIST
74206: PUSH
74207: LD_INT 30
74209: PUSH
74210: LD_INT 5
74212: PUSH
74213: EMPTY
74214: LIST
74215: LIST
74216: PUSH
74217: EMPTY
74218: LIST
74219: LIST
74220: LIST
74221: PPUSH
74222: CALL_OW 72
74226: ST_TO_ADDR
// if barracks then
74227: LD_VAR 0 8
74231: IFFALSE 74379
// begin selected := 0 ;
74233: LD_ADDR_VAR 0 7
74237: PUSH
74238: LD_INT 0
74240: ST_TO_ADDR
// for j in barracks do
74241: LD_ADDR_VAR 0 3
74245: PUSH
74246: LD_VAR 0 8
74250: PUSH
74251: FOR_IN
74252: IFFALSE 74283
// begin if UnitsInside ( j ) < 6 then
74254: LD_VAR 0 3
74258: PPUSH
74259: CALL_OW 313
74263: PUSH
74264: LD_INT 6
74266: LESS
74267: IFFALSE 74281
// begin selected := j ;
74269: LD_ADDR_VAR 0 7
74273: PUSH
74274: LD_VAR 0 3
74278: ST_TO_ADDR
// break ;
74279: GO 74283
// end ; end ;
74281: GO 74251
74283: POP
74284: POP
// if selected then
74285: LD_VAR 0 7
74289: IFFALSE 74379
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74291: LD_ADDR_VAR 0 3
74295: PUSH
74296: LD_EXP 88
74300: PUSH
74301: LD_VAR 0 2
74305: ARRAY
74306: PPUSH
74307: LD_INT 25
74309: PUSH
74310: LD_INT 12
74312: PUSH
74313: EMPTY
74314: LIST
74315: LIST
74316: PPUSH
74317: CALL_OW 72
74321: PUSH
74322: FOR_IN
74323: IFFALSE 74377
// if not IsInUnit ( j ) and not HasTask ( j ) then
74325: LD_VAR 0 3
74329: PPUSH
74330: CALL_OW 310
74334: NOT
74335: PUSH
74336: LD_VAR 0 3
74340: PPUSH
74341: CALL_OW 314
74345: NOT
74346: AND
74347: IFFALSE 74375
// begin ComEnterUnit ( j , selected ) ;
74349: LD_VAR 0 3
74353: PPUSH
74354: LD_VAR 0 7
74358: PPUSH
74359: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74363: LD_VAR 0 3
74367: PPUSH
74368: LD_INT 15
74370: PPUSH
74371: CALL_OW 183
// end ;
74375: GO 74322
74377: POP
74378: POP
// end ; end ; end ; end ; end ;
74379: GO 73772
74381: POP
74382: POP
// end ;
74383: LD_VAR 0 1
74387: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74388: LD_INT 0
74390: PPUSH
74391: PPUSH
74392: PPUSH
74393: PPUSH
// if not mc_bases then
74394: LD_EXP 59
74398: NOT
74399: IFFALSE 74403
// exit ;
74401: GO 74581
// for i = 1 to mc_bases do
74403: LD_ADDR_VAR 0 2
74407: PUSH
74408: DOUBLE
74409: LD_INT 1
74411: DEC
74412: ST_TO_ADDR
74413: LD_EXP 59
74417: PUSH
74418: FOR_TO
74419: IFFALSE 74579
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74421: LD_ADDR_VAR 0 4
74425: PUSH
74426: LD_EXP 59
74430: PUSH
74431: LD_VAR 0 2
74435: ARRAY
74436: PPUSH
74437: LD_INT 25
74439: PUSH
74440: LD_INT 9
74442: PUSH
74443: EMPTY
74444: LIST
74445: LIST
74446: PPUSH
74447: CALL_OW 72
74451: ST_TO_ADDR
// if not tmp then
74452: LD_VAR 0 4
74456: NOT
74457: IFFALSE 74461
// continue ;
74459: GO 74418
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74461: LD_EXP 85
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PPUSH
74472: LD_INT 29
74474: PPUSH
74475: CALL_OW 325
74479: NOT
74480: PUSH
74481: LD_EXP 85
74485: PUSH
74486: LD_VAR 0 2
74490: ARRAY
74491: PPUSH
74492: LD_INT 28
74494: PPUSH
74495: CALL_OW 325
74499: NOT
74500: AND
74501: IFFALSE 74505
// continue ;
74503: GO 74418
// for j in tmp do
74505: LD_ADDR_VAR 0 3
74509: PUSH
74510: LD_VAR 0 4
74514: PUSH
74515: FOR_IN
74516: IFFALSE 74575
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74518: LD_VAR 0 3
74522: PUSH
74523: LD_EXP 62
74527: PUSH
74528: LD_VAR 0 2
74532: ARRAY
74533: PUSH
74534: LD_INT 1
74536: ARRAY
74537: IN
74538: NOT
74539: PUSH
74540: LD_VAR 0 3
74544: PUSH
74545: LD_EXP 62
74549: PUSH
74550: LD_VAR 0 2
74554: ARRAY
74555: PUSH
74556: LD_INT 2
74558: ARRAY
74559: IN
74560: NOT
74561: AND
74562: IFFALSE 74573
// ComSpaceTimeShoot ( j ) ;
74564: LD_VAR 0 3
74568: PPUSH
74569: CALL 15751 0 1
74573: GO 74515
74575: POP
74576: POP
// end ;
74577: GO 74418
74579: POP
74580: POP
// end ;
74581: LD_VAR 0 1
74585: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74586: LD_INT 0
74588: PPUSH
74589: PPUSH
74590: PPUSH
74591: PPUSH
74592: PPUSH
74593: PPUSH
74594: PPUSH
74595: PPUSH
74596: PPUSH
// if not mc_bases then
74597: LD_EXP 59
74601: NOT
74602: IFFALSE 74606
// exit ;
74604: GO 75228
// for i = 1 to mc_bases do
74606: LD_ADDR_VAR 0 2
74610: PUSH
74611: DOUBLE
74612: LD_INT 1
74614: DEC
74615: ST_TO_ADDR
74616: LD_EXP 59
74620: PUSH
74621: FOR_TO
74622: IFFALSE 75226
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74624: LD_EXP 94
74628: PUSH
74629: LD_VAR 0 2
74633: ARRAY
74634: NOT
74635: PUSH
74636: LD_INT 38
74638: PPUSH
74639: LD_EXP 85
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: PPUSH
74650: CALL_OW 321
74654: PUSH
74655: LD_INT 2
74657: NONEQUAL
74658: OR
74659: IFFALSE 74663
// continue ;
74661: GO 74621
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74663: LD_ADDR_VAR 0 8
74667: PUSH
74668: LD_EXP 59
74672: PUSH
74673: LD_VAR 0 2
74677: ARRAY
74678: PPUSH
74679: LD_INT 30
74681: PUSH
74682: LD_INT 34
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PPUSH
74689: CALL_OW 72
74693: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74694: LD_ADDR_VAR 0 9
74698: PUSH
74699: LD_EXP 59
74703: PUSH
74704: LD_VAR 0 2
74708: ARRAY
74709: PPUSH
74710: LD_INT 25
74712: PUSH
74713: LD_INT 4
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PPUSH
74720: CALL_OW 72
74724: PPUSH
74725: LD_INT 0
74727: PPUSH
74728: CALL 49059 0 2
74732: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74733: LD_VAR 0 9
74737: NOT
74738: PUSH
74739: LD_VAR 0 8
74743: NOT
74744: OR
74745: PUSH
74746: LD_EXP 59
74750: PUSH
74751: LD_VAR 0 2
74755: ARRAY
74756: PPUSH
74757: LD_INT 124
74759: PPUSH
74760: CALL 49059 0 2
74764: OR
74765: IFFALSE 74769
// continue ;
74767: GO 74621
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74769: LD_EXP 95
74773: PUSH
74774: LD_VAR 0 2
74778: ARRAY
74779: PUSH
74780: LD_EXP 94
74784: PUSH
74785: LD_VAR 0 2
74789: ARRAY
74790: LESS
74791: PUSH
74792: LD_EXP 95
74796: PUSH
74797: LD_VAR 0 2
74801: ARRAY
74802: PUSH
74803: LD_VAR 0 8
74807: LESS
74808: AND
74809: IFFALSE 75224
// begin tmp := sci [ 1 ] ;
74811: LD_ADDR_VAR 0 7
74815: PUSH
74816: LD_VAR 0 9
74820: PUSH
74821: LD_INT 1
74823: ARRAY
74824: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74825: LD_VAR 0 7
74829: PPUSH
74830: LD_INT 124
74832: PPUSH
74833: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74837: LD_ADDR_VAR 0 3
74841: PUSH
74842: DOUBLE
74843: LD_EXP 94
74847: PUSH
74848: LD_VAR 0 2
74852: ARRAY
74853: INC
74854: ST_TO_ADDR
74855: LD_EXP 94
74859: PUSH
74860: LD_VAR 0 2
74864: ARRAY
74865: PUSH
74866: FOR_DOWNTO
74867: IFFALSE 75210
// begin if IsInUnit ( tmp ) then
74869: LD_VAR 0 7
74873: PPUSH
74874: CALL_OW 310
74878: IFFALSE 74889
// ComExitBuilding ( tmp ) ;
74880: LD_VAR 0 7
74884: PPUSH
74885: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
74889: LD_INT 35
74891: PPUSH
74892: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
74896: LD_VAR 0 7
74900: PPUSH
74901: CALL_OW 310
74905: NOT
74906: PUSH
74907: LD_VAR 0 7
74911: PPUSH
74912: CALL_OW 314
74916: NOT
74917: AND
74918: IFFALSE 74889
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
74920: LD_ADDR_VAR 0 6
74924: PUSH
74925: LD_VAR 0 7
74929: PPUSH
74930: CALL_OW 250
74934: PUSH
74935: LD_VAR 0 7
74939: PPUSH
74940: CALL_OW 251
74944: PUSH
74945: EMPTY
74946: LIST
74947: LIST
74948: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
74949: LD_INT 35
74951: PPUSH
74952: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
74956: LD_ADDR_VAR 0 4
74960: PUSH
74961: LD_EXP 94
74965: PUSH
74966: LD_VAR 0 2
74970: ARRAY
74971: PUSH
74972: LD_VAR 0 3
74976: ARRAY
74977: PUSH
74978: LD_INT 1
74980: ARRAY
74981: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
74982: LD_ADDR_VAR 0 5
74986: PUSH
74987: LD_EXP 94
74991: PUSH
74992: LD_VAR 0 2
74996: ARRAY
74997: PUSH
74998: LD_VAR 0 3
75002: ARRAY
75003: PUSH
75004: LD_INT 2
75006: ARRAY
75007: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75008: LD_VAR 0 7
75012: PPUSH
75013: LD_INT 10
75015: PPUSH
75016: CALL 22389 0 2
75020: PUSH
75021: LD_INT 4
75023: ARRAY
75024: IFFALSE 75062
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75026: LD_VAR 0 7
75030: PPUSH
75031: LD_VAR 0 6
75035: PUSH
75036: LD_INT 1
75038: ARRAY
75039: PPUSH
75040: LD_VAR 0 6
75044: PUSH
75045: LD_INT 2
75047: ARRAY
75048: PPUSH
75049: CALL_OW 111
// wait ( 0 0$10 ) ;
75053: LD_INT 350
75055: PPUSH
75056: CALL_OW 67
// end else
75060: GO 75088
// begin ComMoveXY ( tmp , x , y ) ;
75062: LD_VAR 0 7
75066: PPUSH
75067: LD_VAR 0 4
75071: PPUSH
75072: LD_VAR 0 5
75076: PPUSH
75077: CALL_OW 111
// wait ( 0 0$3 ) ;
75081: LD_INT 105
75083: PPUSH
75084: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75088: LD_VAR 0 7
75092: PPUSH
75093: LD_VAR 0 4
75097: PPUSH
75098: LD_VAR 0 5
75102: PPUSH
75103: CALL_OW 307
75107: IFFALSE 74949
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75109: LD_VAR 0 7
75113: PPUSH
75114: LD_VAR 0 4
75118: PPUSH
75119: LD_VAR 0 5
75123: PPUSH
75124: LD_VAR 0 8
75128: PUSH
75129: LD_VAR 0 3
75133: ARRAY
75134: PPUSH
75135: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75139: LD_INT 35
75141: PPUSH
75142: CALL_OW 67
// until not HasTask ( tmp ) ;
75146: LD_VAR 0 7
75150: PPUSH
75151: CALL_OW 314
75155: NOT
75156: IFFALSE 75139
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75158: LD_ADDR_EXP 95
75162: PUSH
75163: LD_EXP 95
75167: PPUSH
75168: LD_VAR 0 2
75172: PUSH
75173: LD_EXP 95
75177: PUSH
75178: LD_VAR 0 2
75182: ARRAY
75183: PUSH
75184: LD_INT 1
75186: PLUS
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PPUSH
75192: LD_VAR 0 8
75196: PUSH
75197: LD_VAR 0 3
75201: ARRAY
75202: PPUSH
75203: CALL 19790 0 3
75207: ST_TO_ADDR
// end ;
75208: GO 74866
75210: POP
75211: POP
// MC_Reset ( i , 124 ) ;
75212: LD_VAR 0 2
75216: PPUSH
75217: LD_INT 124
75219: PPUSH
75220: CALL 58513 0 2
// end ; end ;
75224: GO 74621
75226: POP
75227: POP
// end ;
75228: LD_VAR 0 1
75232: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75233: LD_INT 0
75235: PPUSH
75236: PPUSH
75237: PPUSH
// if not mc_bases then
75238: LD_EXP 59
75242: NOT
75243: IFFALSE 75247
// exit ;
75245: GO 75853
// for i = 1 to mc_bases do
75247: LD_ADDR_VAR 0 2
75251: PUSH
75252: DOUBLE
75253: LD_INT 1
75255: DEC
75256: ST_TO_ADDR
75257: LD_EXP 59
75261: PUSH
75262: FOR_TO
75263: IFFALSE 75851
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75265: LD_ADDR_VAR 0 3
75269: PUSH
75270: LD_EXP 59
75274: PUSH
75275: LD_VAR 0 2
75279: ARRAY
75280: PPUSH
75281: LD_INT 25
75283: PUSH
75284: LD_INT 4
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PPUSH
75291: CALL_OW 72
75295: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75296: LD_VAR 0 3
75300: NOT
75301: PUSH
75302: LD_EXP 96
75306: PUSH
75307: LD_VAR 0 2
75311: ARRAY
75312: NOT
75313: OR
75314: PUSH
75315: LD_EXP 59
75319: PUSH
75320: LD_VAR 0 2
75324: ARRAY
75325: PPUSH
75326: LD_INT 2
75328: PUSH
75329: LD_INT 30
75331: PUSH
75332: LD_INT 0
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 30
75341: PUSH
75342: LD_INT 1
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: LIST
75353: PPUSH
75354: CALL_OW 72
75358: NOT
75359: OR
75360: IFFALSE 75410
// begin if mc_deposits_finder [ i ] then
75362: LD_EXP 97
75366: PUSH
75367: LD_VAR 0 2
75371: ARRAY
75372: IFFALSE 75408
// begin MC_Reset ( i , 125 ) ;
75374: LD_VAR 0 2
75378: PPUSH
75379: LD_INT 125
75381: PPUSH
75382: CALL 58513 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75386: LD_ADDR_EXP 97
75390: PUSH
75391: LD_EXP 97
75395: PPUSH
75396: LD_VAR 0 2
75400: PPUSH
75401: EMPTY
75402: PPUSH
75403: CALL_OW 1
75407: ST_TO_ADDR
// end ; continue ;
75408: GO 75262
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75410: LD_EXP 96
75414: PUSH
75415: LD_VAR 0 2
75419: ARRAY
75420: PUSH
75421: LD_INT 1
75423: ARRAY
75424: PUSH
75425: LD_INT 3
75427: ARRAY
75428: PUSH
75429: LD_INT 1
75431: EQUAL
75432: PUSH
75433: LD_INT 20
75435: PPUSH
75436: LD_EXP 85
75440: PUSH
75441: LD_VAR 0 2
75445: ARRAY
75446: PPUSH
75447: CALL_OW 321
75451: PUSH
75452: LD_INT 2
75454: NONEQUAL
75455: AND
75456: IFFALSE 75506
// begin if mc_deposits_finder [ i ] then
75458: LD_EXP 97
75462: PUSH
75463: LD_VAR 0 2
75467: ARRAY
75468: IFFALSE 75504
// begin MC_Reset ( i , 125 ) ;
75470: LD_VAR 0 2
75474: PPUSH
75475: LD_INT 125
75477: PPUSH
75478: CALL 58513 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75482: LD_ADDR_EXP 97
75486: PUSH
75487: LD_EXP 97
75491: PPUSH
75492: LD_VAR 0 2
75496: PPUSH
75497: EMPTY
75498: PPUSH
75499: CALL_OW 1
75503: ST_TO_ADDR
// end ; continue ;
75504: GO 75262
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75506: LD_EXP 96
75510: PUSH
75511: LD_VAR 0 2
75515: ARRAY
75516: PUSH
75517: LD_INT 1
75519: ARRAY
75520: PUSH
75521: LD_INT 1
75523: ARRAY
75524: PPUSH
75525: LD_EXP 96
75529: PUSH
75530: LD_VAR 0 2
75534: ARRAY
75535: PUSH
75536: LD_INT 1
75538: ARRAY
75539: PUSH
75540: LD_INT 2
75542: ARRAY
75543: PPUSH
75544: LD_EXP 85
75548: PUSH
75549: LD_VAR 0 2
75553: ARRAY
75554: PPUSH
75555: CALL_OW 440
75559: IFFALSE 75602
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75561: LD_ADDR_EXP 96
75565: PUSH
75566: LD_EXP 96
75570: PPUSH
75571: LD_VAR 0 2
75575: PPUSH
75576: LD_EXP 96
75580: PUSH
75581: LD_VAR 0 2
75585: ARRAY
75586: PPUSH
75587: LD_INT 1
75589: PPUSH
75590: CALL_OW 3
75594: PPUSH
75595: CALL_OW 1
75599: ST_TO_ADDR
75600: GO 75849
// begin if not mc_deposits_finder [ i ] then
75602: LD_EXP 97
75606: PUSH
75607: LD_VAR 0 2
75611: ARRAY
75612: NOT
75613: IFFALSE 75665
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75615: LD_ADDR_EXP 97
75619: PUSH
75620: LD_EXP 97
75624: PPUSH
75625: LD_VAR 0 2
75629: PPUSH
75630: LD_VAR 0 3
75634: PUSH
75635: LD_INT 1
75637: ARRAY
75638: PUSH
75639: EMPTY
75640: LIST
75641: PPUSH
75642: CALL_OW 1
75646: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75647: LD_VAR 0 3
75651: PUSH
75652: LD_INT 1
75654: ARRAY
75655: PPUSH
75656: LD_INT 125
75658: PPUSH
75659: CALL_OW 109
// end else
75663: GO 75849
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75665: LD_EXP 97
75669: PUSH
75670: LD_VAR 0 2
75674: ARRAY
75675: PUSH
75676: LD_INT 1
75678: ARRAY
75679: PPUSH
75680: CALL_OW 310
75684: IFFALSE 75707
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75686: LD_EXP 97
75690: PUSH
75691: LD_VAR 0 2
75695: ARRAY
75696: PUSH
75697: LD_INT 1
75699: ARRAY
75700: PPUSH
75701: CALL_OW 122
75705: GO 75849
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75707: LD_EXP 97
75711: PUSH
75712: LD_VAR 0 2
75716: ARRAY
75717: PUSH
75718: LD_INT 1
75720: ARRAY
75721: PPUSH
75722: CALL_OW 314
75726: NOT
75727: PUSH
75728: LD_EXP 97
75732: PUSH
75733: LD_VAR 0 2
75737: ARRAY
75738: PUSH
75739: LD_INT 1
75741: ARRAY
75742: PPUSH
75743: LD_EXP 96
75747: PUSH
75748: LD_VAR 0 2
75752: ARRAY
75753: PUSH
75754: LD_INT 1
75756: ARRAY
75757: PUSH
75758: LD_INT 1
75760: ARRAY
75761: PPUSH
75762: LD_EXP 96
75766: PUSH
75767: LD_VAR 0 2
75771: ARRAY
75772: PUSH
75773: LD_INT 1
75775: ARRAY
75776: PUSH
75777: LD_INT 2
75779: ARRAY
75780: PPUSH
75781: CALL_OW 297
75785: PUSH
75786: LD_INT 6
75788: GREATER
75789: AND
75790: IFFALSE 75849
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75792: LD_EXP 97
75796: PUSH
75797: LD_VAR 0 2
75801: ARRAY
75802: PUSH
75803: LD_INT 1
75805: ARRAY
75806: PPUSH
75807: LD_EXP 96
75811: PUSH
75812: LD_VAR 0 2
75816: ARRAY
75817: PUSH
75818: LD_INT 1
75820: ARRAY
75821: PUSH
75822: LD_INT 1
75824: ARRAY
75825: PPUSH
75826: LD_EXP 96
75830: PUSH
75831: LD_VAR 0 2
75835: ARRAY
75836: PUSH
75837: LD_INT 1
75839: ARRAY
75840: PUSH
75841: LD_INT 2
75843: ARRAY
75844: PPUSH
75845: CALL_OW 111
// end ; end ; end ;
75849: GO 75262
75851: POP
75852: POP
// end ;
75853: LD_VAR 0 1
75857: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
75858: LD_INT 0
75860: PPUSH
75861: PPUSH
75862: PPUSH
75863: PPUSH
75864: PPUSH
75865: PPUSH
75866: PPUSH
75867: PPUSH
75868: PPUSH
75869: PPUSH
75870: PPUSH
// if not mc_bases then
75871: LD_EXP 59
75875: NOT
75876: IFFALSE 75880
// exit ;
75878: GO 76820
// for i = 1 to mc_bases do
75880: LD_ADDR_VAR 0 2
75884: PUSH
75885: DOUBLE
75886: LD_INT 1
75888: DEC
75889: ST_TO_ADDR
75890: LD_EXP 59
75894: PUSH
75895: FOR_TO
75896: IFFALSE 76818
// begin if not mc_bases [ i ] or mc_scan [ i ] then
75898: LD_EXP 59
75902: PUSH
75903: LD_VAR 0 2
75907: ARRAY
75908: NOT
75909: PUSH
75910: LD_EXP 82
75914: PUSH
75915: LD_VAR 0 2
75919: ARRAY
75920: OR
75921: IFFALSE 75925
// continue ;
75923: GO 75895
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
75925: LD_ADDR_VAR 0 7
75929: PUSH
75930: LD_EXP 59
75934: PUSH
75935: LD_VAR 0 2
75939: ARRAY
75940: PUSH
75941: LD_INT 1
75943: ARRAY
75944: PPUSH
75945: CALL_OW 248
75949: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
75950: LD_VAR 0 7
75954: PUSH
75955: LD_INT 3
75957: EQUAL
75958: PUSH
75959: LD_EXP 78
75963: PUSH
75964: LD_VAR 0 2
75968: ARRAY
75969: PUSH
75970: LD_EXP 81
75974: PUSH
75975: LD_VAR 0 2
75979: ARRAY
75980: UNION
75981: PPUSH
75982: LD_INT 33
75984: PUSH
75985: LD_INT 2
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PPUSH
75992: CALL_OW 72
75996: NOT
75997: OR
75998: IFFALSE 76002
// continue ;
76000: GO 75895
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76002: LD_ADDR_VAR 0 9
76006: PUSH
76007: LD_EXP 59
76011: PUSH
76012: LD_VAR 0 2
76016: ARRAY
76017: PPUSH
76018: LD_INT 30
76020: PUSH
76021: LD_INT 36
76023: PUSH
76024: EMPTY
76025: LIST
76026: LIST
76027: PPUSH
76028: CALL_OW 72
76032: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76033: LD_ADDR_VAR 0 10
76037: PUSH
76038: LD_EXP 78
76042: PUSH
76043: LD_VAR 0 2
76047: ARRAY
76048: PPUSH
76049: LD_INT 34
76051: PUSH
76052: LD_INT 31
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: PPUSH
76059: CALL_OW 72
76063: ST_TO_ADDR
// if not cts and not mcts then
76064: LD_VAR 0 9
76068: NOT
76069: PUSH
76070: LD_VAR 0 10
76074: NOT
76075: AND
76076: IFFALSE 76080
// continue ;
76078: GO 75895
// x := cts ;
76080: LD_ADDR_VAR 0 11
76084: PUSH
76085: LD_VAR 0 9
76089: ST_TO_ADDR
// if not x then
76090: LD_VAR 0 11
76094: NOT
76095: IFFALSE 76107
// x := mcts ;
76097: LD_ADDR_VAR 0 11
76101: PUSH
76102: LD_VAR 0 10
76106: ST_TO_ADDR
// if not x then
76107: LD_VAR 0 11
76111: NOT
76112: IFFALSE 76116
// continue ;
76114: GO 75895
// if mc_remote_driver [ i ] then
76116: LD_EXP 99
76120: PUSH
76121: LD_VAR 0 2
76125: ARRAY
76126: IFFALSE 76513
// for j in mc_remote_driver [ i ] do
76128: LD_ADDR_VAR 0 3
76132: PUSH
76133: LD_EXP 99
76137: PUSH
76138: LD_VAR 0 2
76142: ARRAY
76143: PUSH
76144: FOR_IN
76145: IFFALSE 76511
// begin if GetClass ( j ) <> 3 then
76147: LD_VAR 0 3
76151: PPUSH
76152: CALL_OW 257
76156: PUSH
76157: LD_INT 3
76159: NONEQUAL
76160: IFFALSE 76213
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76162: LD_ADDR_EXP 99
76166: PUSH
76167: LD_EXP 99
76171: PPUSH
76172: LD_VAR 0 2
76176: PPUSH
76177: LD_EXP 99
76181: PUSH
76182: LD_VAR 0 2
76186: ARRAY
76187: PUSH
76188: LD_VAR 0 3
76192: DIFF
76193: PPUSH
76194: CALL_OW 1
76198: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76199: LD_VAR 0 3
76203: PPUSH
76204: LD_INT 0
76206: PPUSH
76207: CALL_OW 109
// continue ;
76211: GO 76144
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76213: LD_EXP 78
76217: PUSH
76218: LD_VAR 0 2
76222: ARRAY
76223: PPUSH
76224: LD_INT 34
76226: PUSH
76227: LD_INT 31
76229: PUSH
76230: EMPTY
76231: LIST
76232: LIST
76233: PUSH
76234: LD_INT 58
76236: PUSH
76237: EMPTY
76238: LIST
76239: PUSH
76240: EMPTY
76241: LIST
76242: LIST
76243: PPUSH
76244: CALL_OW 72
76248: PUSH
76249: LD_VAR 0 3
76253: PPUSH
76254: CALL 49147 0 1
76258: NOT
76259: AND
76260: IFFALSE 76331
// begin if IsInUnit ( j ) then
76262: LD_VAR 0 3
76266: PPUSH
76267: CALL_OW 310
76271: IFFALSE 76282
// ComExitBuilding ( j ) ;
76273: LD_VAR 0 3
76277: PPUSH
76278: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
76282: LD_VAR 0 3
76286: PPUSH
76287: LD_EXP 78
76291: PUSH
76292: LD_VAR 0 2
76296: ARRAY
76297: PPUSH
76298: LD_INT 34
76300: PUSH
76301: LD_INT 31
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 58
76310: PUSH
76311: EMPTY
76312: LIST
76313: PUSH
76314: EMPTY
76315: LIST
76316: LIST
76317: PPUSH
76318: CALL_OW 72
76322: PUSH
76323: LD_INT 1
76325: ARRAY
76326: PPUSH
76327: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76331: LD_VAR 0 3
76335: PPUSH
76336: CALL_OW 310
76340: NOT
76341: PUSH
76342: LD_VAR 0 3
76346: PPUSH
76347: CALL_OW 310
76351: PPUSH
76352: CALL_OW 266
76356: PUSH
76357: LD_INT 36
76359: NONEQUAL
76360: PUSH
76361: LD_VAR 0 3
76365: PPUSH
76366: CALL 49147 0 1
76370: NOT
76371: AND
76372: OR
76373: IFFALSE 76509
// begin if IsInUnit ( j ) then
76375: LD_VAR 0 3
76379: PPUSH
76380: CALL_OW 310
76384: IFFALSE 76395
// ComExitBuilding ( j ) ;
76386: LD_VAR 0 3
76390: PPUSH
76391: CALL_OW 122
// ct := 0 ;
76395: LD_ADDR_VAR 0 8
76399: PUSH
76400: LD_INT 0
76402: ST_TO_ADDR
// for k in x do
76403: LD_ADDR_VAR 0 4
76407: PUSH
76408: LD_VAR 0 11
76412: PUSH
76413: FOR_IN
76414: IFFALSE 76487
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76416: LD_VAR 0 4
76420: PPUSH
76421: CALL_OW 264
76425: PUSH
76426: LD_INT 31
76428: EQUAL
76429: PUSH
76430: LD_VAR 0 4
76434: PPUSH
76435: CALL_OW 311
76439: NOT
76440: AND
76441: PUSH
76442: LD_VAR 0 4
76446: PPUSH
76447: CALL_OW 266
76451: PUSH
76452: LD_INT 36
76454: EQUAL
76455: PUSH
76456: LD_VAR 0 4
76460: PPUSH
76461: CALL_OW 313
76465: PUSH
76466: LD_INT 3
76468: LESS
76469: AND
76470: OR
76471: IFFALSE 76485
// begin ct := k ;
76473: LD_ADDR_VAR 0 8
76477: PUSH
76478: LD_VAR 0 4
76482: ST_TO_ADDR
// break ;
76483: GO 76487
// end ;
76485: GO 76413
76487: POP
76488: POP
// if ct then
76489: LD_VAR 0 8
76493: IFFALSE 76509
// ComEnterUnit ( j , ct ) ;
76495: LD_VAR 0 3
76499: PPUSH
76500: LD_VAR 0 8
76504: PPUSH
76505: CALL_OW 120
// end ; end ;
76509: GO 76144
76511: POP
76512: POP
// places := 0 ;
76513: LD_ADDR_VAR 0 5
76517: PUSH
76518: LD_INT 0
76520: ST_TO_ADDR
// for j = 1 to x do
76521: LD_ADDR_VAR 0 3
76525: PUSH
76526: DOUBLE
76527: LD_INT 1
76529: DEC
76530: ST_TO_ADDR
76531: LD_VAR 0 11
76535: PUSH
76536: FOR_TO
76537: IFFALSE 76613
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76539: LD_VAR 0 11
76543: PUSH
76544: LD_VAR 0 3
76548: ARRAY
76549: PPUSH
76550: CALL_OW 264
76554: PUSH
76555: LD_INT 31
76557: EQUAL
76558: IFFALSE 76576
// places := places + 1 else
76560: LD_ADDR_VAR 0 5
76564: PUSH
76565: LD_VAR 0 5
76569: PUSH
76570: LD_INT 1
76572: PLUS
76573: ST_TO_ADDR
76574: GO 76611
// if GetBType ( x [ j ] ) = b_control_tower then
76576: LD_VAR 0 11
76580: PUSH
76581: LD_VAR 0 3
76585: ARRAY
76586: PPUSH
76587: CALL_OW 266
76591: PUSH
76592: LD_INT 36
76594: EQUAL
76595: IFFALSE 76611
// places := places + 3 ;
76597: LD_ADDR_VAR 0 5
76601: PUSH
76602: LD_VAR 0 5
76606: PUSH
76607: LD_INT 3
76609: PLUS
76610: ST_TO_ADDR
76611: GO 76536
76613: POP
76614: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76615: LD_VAR 0 5
76619: PUSH
76620: LD_INT 0
76622: EQUAL
76623: PUSH
76624: LD_VAR 0 5
76628: PUSH
76629: LD_EXP 99
76633: PUSH
76634: LD_VAR 0 2
76638: ARRAY
76639: LESSEQUAL
76640: OR
76641: IFFALSE 76645
// continue ;
76643: GO 75895
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76645: LD_ADDR_VAR 0 6
76649: PUSH
76650: LD_EXP 59
76654: PUSH
76655: LD_VAR 0 2
76659: ARRAY
76660: PPUSH
76661: LD_INT 25
76663: PUSH
76664: LD_INT 3
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PPUSH
76671: CALL_OW 72
76675: PUSH
76676: LD_EXP 99
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: DIFF
76687: PPUSH
76688: LD_INT 3
76690: PPUSH
76691: CALL 50047 0 2
76695: ST_TO_ADDR
// for j in tmp do
76696: LD_ADDR_VAR 0 3
76700: PUSH
76701: LD_VAR 0 6
76705: PUSH
76706: FOR_IN
76707: IFFALSE 76742
// if GetTag ( j ) > 0 then
76709: LD_VAR 0 3
76713: PPUSH
76714: CALL_OW 110
76718: PUSH
76719: LD_INT 0
76721: GREATER
76722: IFFALSE 76740
// tmp := tmp diff j ;
76724: LD_ADDR_VAR 0 6
76728: PUSH
76729: LD_VAR 0 6
76733: PUSH
76734: LD_VAR 0 3
76738: DIFF
76739: ST_TO_ADDR
76740: GO 76706
76742: POP
76743: POP
// if not tmp then
76744: LD_VAR 0 6
76748: NOT
76749: IFFALSE 76753
// continue ;
76751: GO 75895
// if places then
76753: LD_VAR 0 5
76757: IFFALSE 76816
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76759: LD_ADDR_EXP 99
76763: PUSH
76764: LD_EXP 99
76768: PPUSH
76769: LD_VAR 0 2
76773: PPUSH
76774: LD_EXP 99
76778: PUSH
76779: LD_VAR 0 2
76783: ARRAY
76784: PUSH
76785: LD_VAR 0 6
76789: PUSH
76790: LD_INT 1
76792: ARRAY
76793: UNION
76794: PPUSH
76795: CALL_OW 1
76799: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76800: LD_VAR 0 6
76804: PUSH
76805: LD_INT 1
76807: ARRAY
76808: PPUSH
76809: LD_INT 126
76811: PPUSH
76812: CALL_OW 109
// end ; end ;
76816: GO 75895
76818: POP
76819: POP
// end ;
76820: LD_VAR 0 1
76824: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76825: LD_INT 0
76827: PPUSH
76828: PPUSH
76829: PPUSH
76830: PPUSH
76831: PPUSH
76832: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76833: LD_VAR 0 1
76837: NOT
76838: PUSH
76839: LD_VAR 0 2
76843: NOT
76844: OR
76845: PUSH
76846: LD_VAR 0 3
76850: NOT
76851: OR
76852: PUSH
76853: LD_VAR 0 4
76857: PUSH
76858: LD_INT 1
76860: PUSH
76861: LD_INT 2
76863: PUSH
76864: LD_INT 3
76866: PUSH
76867: LD_INT 4
76869: PUSH
76870: LD_INT 5
76872: PUSH
76873: LD_INT 8
76875: PUSH
76876: LD_INT 9
76878: PUSH
76879: LD_INT 15
76881: PUSH
76882: LD_INT 16
76884: PUSH
76885: EMPTY
76886: LIST
76887: LIST
76888: LIST
76889: LIST
76890: LIST
76891: LIST
76892: LIST
76893: LIST
76894: LIST
76895: IN
76896: NOT
76897: OR
76898: IFFALSE 76902
// exit ;
76900: GO 77802
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
76902: LD_ADDR_VAR 0 2
76906: PUSH
76907: LD_VAR 0 2
76911: PPUSH
76912: LD_INT 21
76914: PUSH
76915: LD_INT 3
76917: PUSH
76918: EMPTY
76919: LIST
76920: LIST
76921: PUSH
76922: LD_INT 24
76924: PUSH
76925: LD_INT 250
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PPUSH
76936: CALL_OW 72
76940: ST_TO_ADDR
// case class of 1 , 15 :
76941: LD_VAR 0 4
76945: PUSH
76946: LD_INT 1
76948: DOUBLE
76949: EQUAL
76950: IFTRUE 76960
76952: LD_INT 15
76954: DOUBLE
76955: EQUAL
76956: IFTRUE 76960
76958: GO 77045
76960: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
76961: LD_ADDR_VAR 0 8
76965: PUSH
76966: LD_VAR 0 2
76970: PPUSH
76971: LD_INT 2
76973: PUSH
76974: LD_INT 30
76976: PUSH
76977: LD_INT 32
76979: PUSH
76980: EMPTY
76981: LIST
76982: LIST
76983: PUSH
76984: LD_INT 30
76986: PUSH
76987: LD_INT 31
76989: PUSH
76990: EMPTY
76991: LIST
76992: LIST
76993: PUSH
76994: EMPTY
76995: LIST
76996: LIST
76997: LIST
76998: PPUSH
76999: CALL_OW 72
77003: PUSH
77004: LD_VAR 0 2
77008: PPUSH
77009: LD_INT 2
77011: PUSH
77012: LD_INT 30
77014: PUSH
77015: LD_INT 4
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 30
77024: PUSH
77025: LD_INT 5
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: LIST
77036: PPUSH
77037: CALL_OW 72
77041: ADD
77042: ST_TO_ADDR
77043: GO 77291
77045: LD_INT 2
77047: DOUBLE
77048: EQUAL
77049: IFTRUE 77059
77051: LD_INT 16
77053: DOUBLE
77054: EQUAL
77055: IFTRUE 77059
77057: GO 77105
77059: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77060: LD_ADDR_VAR 0 8
77064: PUSH
77065: LD_VAR 0 2
77069: PPUSH
77070: LD_INT 2
77072: PUSH
77073: LD_INT 30
77075: PUSH
77076: LD_INT 0
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 30
77085: PUSH
77086: LD_INT 1
77088: PUSH
77089: EMPTY
77090: LIST
77091: LIST
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: LIST
77097: PPUSH
77098: CALL_OW 72
77102: ST_TO_ADDR
77103: GO 77291
77105: LD_INT 3
77107: DOUBLE
77108: EQUAL
77109: IFTRUE 77113
77111: GO 77159
77113: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77114: LD_ADDR_VAR 0 8
77118: PUSH
77119: LD_VAR 0 2
77123: PPUSH
77124: LD_INT 2
77126: PUSH
77127: LD_INT 30
77129: PUSH
77130: LD_INT 2
77132: PUSH
77133: EMPTY
77134: LIST
77135: LIST
77136: PUSH
77137: LD_INT 30
77139: PUSH
77140: LD_INT 3
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: LIST
77151: PPUSH
77152: CALL_OW 72
77156: ST_TO_ADDR
77157: GO 77291
77159: LD_INT 4
77161: DOUBLE
77162: EQUAL
77163: IFTRUE 77167
77165: GO 77224
77167: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77168: LD_ADDR_VAR 0 8
77172: PUSH
77173: LD_VAR 0 2
77177: PPUSH
77178: LD_INT 2
77180: PUSH
77181: LD_INT 30
77183: PUSH
77184: LD_INT 6
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 30
77193: PUSH
77194: LD_INT 7
77196: PUSH
77197: EMPTY
77198: LIST
77199: LIST
77200: PUSH
77201: LD_INT 30
77203: PUSH
77204: LD_INT 8
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: EMPTY
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: PPUSH
77217: CALL_OW 72
77221: ST_TO_ADDR
77222: GO 77291
77224: LD_INT 5
77226: DOUBLE
77227: EQUAL
77228: IFTRUE 77244
77230: LD_INT 8
77232: DOUBLE
77233: EQUAL
77234: IFTRUE 77244
77236: LD_INT 9
77238: DOUBLE
77239: EQUAL
77240: IFTRUE 77244
77242: GO 77290
77244: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77245: LD_ADDR_VAR 0 8
77249: PUSH
77250: LD_VAR 0 2
77254: PPUSH
77255: LD_INT 2
77257: PUSH
77258: LD_INT 30
77260: PUSH
77261: LD_INT 4
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 30
77270: PUSH
77271: LD_INT 5
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: LIST
77282: PPUSH
77283: CALL_OW 72
77287: ST_TO_ADDR
77288: GO 77291
77290: POP
// if not tmp then
77291: LD_VAR 0 8
77295: NOT
77296: IFFALSE 77300
// exit ;
77298: GO 77802
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77300: LD_VAR 0 4
77304: PUSH
77305: LD_INT 1
77307: PUSH
77308: LD_INT 15
77310: PUSH
77311: EMPTY
77312: LIST
77313: LIST
77314: IN
77315: PUSH
77316: LD_EXP 68
77320: PUSH
77321: LD_VAR 0 1
77325: ARRAY
77326: AND
77327: IFFALSE 77483
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77329: LD_ADDR_VAR 0 9
77333: PUSH
77334: LD_EXP 68
77338: PUSH
77339: LD_VAR 0 1
77343: ARRAY
77344: PUSH
77345: LD_INT 1
77347: ARRAY
77348: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77349: LD_VAR 0 9
77353: PUSH
77354: LD_EXP 69
77358: PUSH
77359: LD_VAR 0 1
77363: ARRAY
77364: IN
77365: NOT
77366: IFFALSE 77481
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77368: LD_ADDR_EXP 69
77372: PUSH
77373: LD_EXP 69
77377: PPUSH
77378: LD_VAR 0 1
77382: PUSH
77383: LD_EXP 69
77387: PUSH
77388: LD_VAR 0 1
77392: ARRAY
77393: PUSH
77394: LD_INT 1
77396: PLUS
77397: PUSH
77398: EMPTY
77399: LIST
77400: LIST
77401: PPUSH
77402: LD_VAR 0 9
77406: PPUSH
77407: CALL 19790 0 3
77411: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77412: LD_ADDR_EXP 68
77416: PUSH
77417: LD_EXP 68
77421: PPUSH
77422: LD_VAR 0 1
77426: PPUSH
77427: LD_EXP 68
77431: PUSH
77432: LD_VAR 0 1
77436: ARRAY
77437: PUSH
77438: LD_VAR 0 9
77442: DIFF
77443: PPUSH
77444: CALL_OW 1
77448: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77449: LD_VAR 0 3
77453: PPUSH
77454: LD_EXP 69
77458: PUSH
77459: LD_VAR 0 1
77463: ARRAY
77464: PUSH
77465: LD_EXP 69
77469: PUSH
77470: LD_VAR 0 1
77474: ARRAY
77475: ARRAY
77476: PPUSH
77477: CALL_OW 120
// end ; exit ;
77481: GO 77802
// end ; if tmp > 1 then
77483: LD_VAR 0 8
77487: PUSH
77488: LD_INT 1
77490: GREATER
77491: IFFALSE 77595
// for i = 2 to tmp do
77493: LD_ADDR_VAR 0 6
77497: PUSH
77498: DOUBLE
77499: LD_INT 2
77501: DEC
77502: ST_TO_ADDR
77503: LD_VAR 0 8
77507: PUSH
77508: FOR_TO
77509: IFFALSE 77593
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77511: LD_VAR 0 8
77515: PUSH
77516: LD_VAR 0 6
77520: ARRAY
77521: PPUSH
77522: CALL_OW 461
77526: PUSH
77527: LD_INT 6
77529: EQUAL
77530: IFFALSE 77591
// begin x := tmp [ i ] ;
77532: LD_ADDR_VAR 0 9
77536: PUSH
77537: LD_VAR 0 8
77541: PUSH
77542: LD_VAR 0 6
77546: ARRAY
77547: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77548: LD_ADDR_VAR 0 8
77552: PUSH
77553: LD_VAR 0 8
77557: PPUSH
77558: LD_VAR 0 6
77562: PPUSH
77563: CALL_OW 3
77567: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77568: LD_ADDR_VAR 0 8
77572: PUSH
77573: LD_VAR 0 8
77577: PPUSH
77578: LD_INT 1
77580: PPUSH
77581: LD_VAR 0 9
77585: PPUSH
77586: CALL_OW 2
77590: ST_TO_ADDR
// end ;
77591: GO 77508
77593: POP
77594: POP
// for i in tmp do
77595: LD_ADDR_VAR 0 6
77599: PUSH
77600: LD_VAR 0 8
77604: PUSH
77605: FOR_IN
77606: IFFALSE 77675
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77608: LD_VAR 0 6
77612: PPUSH
77613: CALL_OW 313
77617: PUSH
77618: LD_INT 6
77620: LESS
77621: PUSH
77622: LD_VAR 0 6
77626: PPUSH
77627: CALL_OW 266
77631: PUSH
77632: LD_INT 31
77634: PUSH
77635: LD_INT 32
77637: PUSH
77638: EMPTY
77639: LIST
77640: LIST
77641: IN
77642: NOT
77643: AND
77644: PUSH
77645: LD_VAR 0 6
77649: PPUSH
77650: CALL_OW 313
77654: PUSH
77655: LD_INT 0
77657: EQUAL
77658: OR
77659: IFFALSE 77673
// begin j := i ;
77661: LD_ADDR_VAR 0 7
77665: PUSH
77666: LD_VAR 0 6
77670: ST_TO_ADDR
// break ;
77671: GO 77675
// end ; end ;
77673: GO 77605
77675: POP
77676: POP
// if j then
77677: LD_VAR 0 7
77681: IFFALSE 77699
// ComEnterUnit ( unit , j ) else
77683: LD_VAR 0 3
77687: PPUSH
77688: LD_VAR 0 7
77692: PPUSH
77693: CALL_OW 120
77697: GO 77802
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77699: LD_ADDR_VAR 0 10
77703: PUSH
77704: LD_VAR 0 2
77708: PPUSH
77709: LD_INT 2
77711: PUSH
77712: LD_INT 30
77714: PUSH
77715: LD_INT 0
77717: PUSH
77718: EMPTY
77719: LIST
77720: LIST
77721: PUSH
77722: LD_INT 30
77724: PUSH
77725: LD_INT 1
77727: PUSH
77728: EMPTY
77729: LIST
77730: LIST
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: LIST
77736: PPUSH
77737: CALL_OW 72
77741: ST_TO_ADDR
// if depot then
77742: LD_VAR 0 10
77746: IFFALSE 77802
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77748: LD_ADDR_VAR 0 10
77752: PUSH
77753: LD_VAR 0 10
77757: PPUSH
77758: LD_VAR 0 3
77762: PPUSH
77763: CALL_OW 74
77767: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77768: LD_VAR 0 3
77772: PPUSH
77773: LD_VAR 0 10
77777: PPUSH
77778: CALL_OW 296
77782: PUSH
77783: LD_INT 10
77785: GREATER
77786: IFFALSE 77802
// ComStandNearbyBuilding ( unit , depot ) ;
77788: LD_VAR 0 3
77792: PPUSH
77793: LD_VAR 0 10
77797: PPUSH
77798: CALL 16368 0 2
// end ; end ; end ;
77802: LD_VAR 0 5
77806: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77807: LD_INT 0
77809: PPUSH
77810: PPUSH
77811: PPUSH
77812: PPUSH
// if not mc_bases then
77813: LD_EXP 59
77817: NOT
77818: IFFALSE 77822
// exit ;
77820: GO 78061
// for i = 1 to mc_bases do
77822: LD_ADDR_VAR 0 2
77826: PUSH
77827: DOUBLE
77828: LD_INT 1
77830: DEC
77831: ST_TO_ADDR
77832: LD_EXP 59
77836: PUSH
77837: FOR_TO
77838: IFFALSE 78059
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77840: LD_ADDR_VAR 0 4
77844: PUSH
77845: LD_EXP 59
77849: PUSH
77850: LD_VAR 0 2
77854: ARRAY
77855: PPUSH
77856: LD_INT 21
77858: PUSH
77859: LD_INT 1
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PPUSH
77866: CALL_OW 72
77870: PUSH
77871: LD_EXP 88
77875: PUSH
77876: LD_VAR 0 2
77880: ARRAY
77881: UNION
77882: ST_TO_ADDR
// if not tmp then
77883: LD_VAR 0 4
77887: NOT
77888: IFFALSE 77892
// continue ;
77890: GO 77837
// for j in tmp do
77892: LD_ADDR_VAR 0 3
77896: PUSH
77897: LD_VAR 0 4
77901: PUSH
77902: FOR_IN
77903: IFFALSE 78055
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
77905: LD_VAR 0 3
77909: PPUSH
77910: CALL_OW 110
77914: NOT
77915: PUSH
77916: LD_VAR 0 3
77920: PPUSH
77921: CALL_OW 314
77925: NOT
77926: AND
77927: PUSH
77928: LD_VAR 0 3
77932: PPUSH
77933: CALL_OW 311
77937: NOT
77938: AND
77939: PUSH
77940: LD_VAR 0 3
77944: PPUSH
77945: CALL_OW 310
77949: NOT
77950: AND
77951: PUSH
77952: LD_VAR 0 3
77956: PUSH
77957: LD_EXP 62
77961: PUSH
77962: LD_VAR 0 2
77966: ARRAY
77967: PUSH
77968: LD_INT 1
77970: ARRAY
77971: IN
77972: NOT
77973: AND
77974: PUSH
77975: LD_VAR 0 3
77979: PUSH
77980: LD_EXP 62
77984: PUSH
77985: LD_VAR 0 2
77989: ARRAY
77990: PUSH
77991: LD_INT 2
77993: ARRAY
77994: IN
77995: NOT
77996: AND
77997: PUSH
77998: LD_VAR 0 3
78002: PUSH
78003: LD_EXP 71
78007: PUSH
78008: LD_VAR 0 2
78012: ARRAY
78013: IN
78014: NOT
78015: AND
78016: IFFALSE 78053
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78018: LD_VAR 0 2
78022: PPUSH
78023: LD_EXP 59
78027: PUSH
78028: LD_VAR 0 2
78032: ARRAY
78033: PPUSH
78034: LD_VAR 0 3
78038: PPUSH
78039: LD_VAR 0 3
78043: PPUSH
78044: CALL_OW 257
78048: PPUSH
78049: CALL 76825 0 4
// end ;
78053: GO 77902
78055: POP
78056: POP
// end ;
78057: GO 77837
78059: POP
78060: POP
// end ;
78061: LD_VAR 0 1
78065: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78066: LD_INT 0
78068: PPUSH
78069: PPUSH
78070: PPUSH
78071: PPUSH
78072: PPUSH
78073: PPUSH
// if not mc_bases [ base ] then
78074: LD_EXP 59
78078: PUSH
78079: LD_VAR 0 1
78083: ARRAY
78084: NOT
78085: IFFALSE 78089
// exit ;
78087: GO 78271
// tmp := [ ] ;
78089: LD_ADDR_VAR 0 6
78093: PUSH
78094: EMPTY
78095: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78096: LD_ADDR_VAR 0 7
78100: PUSH
78101: LD_VAR 0 3
78105: PPUSH
78106: LD_INT 0
78108: PPUSH
78109: CALL_OW 517
78113: ST_TO_ADDR
// if not list then
78114: LD_VAR 0 7
78118: NOT
78119: IFFALSE 78123
// exit ;
78121: GO 78271
// for i = 1 to amount do
78123: LD_ADDR_VAR 0 5
78127: PUSH
78128: DOUBLE
78129: LD_INT 1
78131: DEC
78132: ST_TO_ADDR
78133: LD_VAR 0 2
78137: PUSH
78138: FOR_TO
78139: IFFALSE 78219
// begin x := rand ( 1 , list [ 1 ] ) ;
78141: LD_ADDR_VAR 0 8
78145: PUSH
78146: LD_INT 1
78148: PPUSH
78149: LD_VAR 0 7
78153: PUSH
78154: LD_INT 1
78156: ARRAY
78157: PPUSH
78158: CALL_OW 12
78162: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78163: LD_ADDR_VAR 0 6
78167: PUSH
78168: LD_VAR 0 6
78172: PPUSH
78173: LD_VAR 0 5
78177: PPUSH
78178: LD_VAR 0 7
78182: PUSH
78183: LD_INT 1
78185: ARRAY
78186: PUSH
78187: LD_VAR 0 8
78191: ARRAY
78192: PUSH
78193: LD_VAR 0 7
78197: PUSH
78198: LD_INT 2
78200: ARRAY
78201: PUSH
78202: LD_VAR 0 8
78206: ARRAY
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PPUSH
78212: CALL_OW 1
78216: ST_TO_ADDR
// end ;
78217: GO 78138
78219: POP
78220: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78221: LD_ADDR_EXP 72
78225: PUSH
78226: LD_EXP 72
78230: PPUSH
78231: LD_VAR 0 1
78235: PPUSH
78236: LD_VAR 0 6
78240: PPUSH
78241: CALL_OW 1
78245: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78246: LD_ADDR_EXP 74
78250: PUSH
78251: LD_EXP 74
78255: PPUSH
78256: LD_VAR 0 1
78260: PPUSH
78261: LD_VAR 0 3
78265: PPUSH
78266: CALL_OW 1
78270: ST_TO_ADDR
// end ;
78271: LD_VAR 0 4
78275: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78276: LD_INT 0
78278: PPUSH
// if not mc_bases [ base ] then
78279: LD_EXP 59
78283: PUSH
78284: LD_VAR 0 1
78288: ARRAY
78289: NOT
78290: IFFALSE 78294
// exit ;
78292: GO 78319
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78294: LD_ADDR_EXP 64
78298: PUSH
78299: LD_EXP 64
78303: PPUSH
78304: LD_VAR 0 1
78308: PPUSH
78309: LD_VAR 0 2
78313: PPUSH
78314: CALL_OW 1
78318: ST_TO_ADDR
// end ;
78319: LD_VAR 0 3
78323: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78324: LD_INT 0
78326: PPUSH
// if not mc_bases [ base ] then
78327: LD_EXP 59
78331: PUSH
78332: LD_VAR 0 1
78336: ARRAY
78337: NOT
78338: IFFALSE 78342
// exit ;
78340: GO 78379
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78342: LD_ADDR_EXP 64
78346: PUSH
78347: LD_EXP 64
78351: PPUSH
78352: LD_VAR 0 1
78356: PPUSH
78357: LD_EXP 64
78361: PUSH
78362: LD_VAR 0 1
78366: ARRAY
78367: PUSH
78368: LD_VAR 0 2
78372: UNION
78373: PPUSH
78374: CALL_OW 1
78378: ST_TO_ADDR
// end ;
78379: LD_VAR 0 3
78383: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78384: LD_INT 0
78386: PPUSH
// if not mc_bases [ base ] then
78387: LD_EXP 59
78391: PUSH
78392: LD_VAR 0 1
78396: ARRAY
78397: NOT
78398: IFFALSE 78402
// exit ;
78400: GO 78427
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78402: LD_ADDR_EXP 80
78406: PUSH
78407: LD_EXP 80
78411: PPUSH
78412: LD_VAR 0 1
78416: PPUSH
78417: LD_VAR 0 2
78421: PPUSH
78422: CALL_OW 1
78426: ST_TO_ADDR
// end ;
78427: LD_VAR 0 3
78431: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78432: LD_INT 0
78434: PPUSH
// if not mc_bases [ base ] then
78435: LD_EXP 59
78439: PUSH
78440: LD_VAR 0 1
78444: ARRAY
78445: NOT
78446: IFFALSE 78450
// exit ;
78448: GO 78487
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78450: LD_ADDR_EXP 80
78454: PUSH
78455: LD_EXP 80
78459: PPUSH
78460: LD_VAR 0 1
78464: PPUSH
78465: LD_EXP 80
78469: PUSH
78470: LD_VAR 0 1
78474: ARRAY
78475: PUSH
78476: LD_VAR 0 2
78480: ADD
78481: PPUSH
78482: CALL_OW 1
78486: ST_TO_ADDR
// end ;
78487: LD_VAR 0 3
78491: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78492: LD_INT 0
78494: PPUSH
// if not mc_bases [ base ] then
78495: LD_EXP 59
78499: PUSH
78500: LD_VAR 0 1
78504: ARRAY
78505: NOT
78506: IFFALSE 78510
// exit ;
78508: GO 78564
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78510: LD_ADDR_EXP 81
78514: PUSH
78515: LD_EXP 81
78519: PPUSH
78520: LD_VAR 0 1
78524: PPUSH
78525: LD_VAR 0 2
78529: PPUSH
78530: CALL_OW 1
78534: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78535: LD_ADDR_EXP 70
78539: PUSH
78540: LD_EXP 70
78544: PPUSH
78545: LD_VAR 0 1
78549: PPUSH
78550: LD_VAR 0 2
78554: PUSH
78555: LD_INT 0
78557: PLUS
78558: PPUSH
78559: CALL_OW 1
78563: ST_TO_ADDR
// end ;
78564: LD_VAR 0 3
78568: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78569: LD_INT 0
78571: PPUSH
// if not mc_bases [ base ] then
78572: LD_EXP 59
78576: PUSH
78577: LD_VAR 0 1
78581: ARRAY
78582: NOT
78583: IFFALSE 78587
// exit ;
78585: GO 78612
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78587: LD_ADDR_EXP 70
78591: PUSH
78592: LD_EXP 70
78596: PPUSH
78597: LD_VAR 0 1
78601: PPUSH
78602: LD_VAR 0 2
78606: PPUSH
78607: CALL_OW 1
78611: ST_TO_ADDR
// end ;
78612: LD_VAR 0 3
78616: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78617: LD_INT 0
78619: PPUSH
78620: PPUSH
78621: PPUSH
78622: PPUSH
// if not mc_bases [ base ] then
78623: LD_EXP 59
78627: PUSH
78628: LD_VAR 0 1
78632: ARRAY
78633: NOT
78634: IFFALSE 78638
// exit ;
78636: GO 78703
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78638: LD_ADDR_EXP 79
78642: PUSH
78643: LD_EXP 79
78647: PPUSH
78648: LD_VAR 0 1
78652: PUSH
78653: LD_EXP 79
78657: PUSH
78658: LD_VAR 0 1
78662: ARRAY
78663: PUSH
78664: LD_INT 1
78666: PLUS
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PPUSH
78672: LD_VAR 0 1
78676: PUSH
78677: LD_VAR 0 2
78681: PUSH
78682: LD_VAR 0 3
78686: PUSH
78687: LD_VAR 0 4
78691: PUSH
78692: EMPTY
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: PPUSH
78698: CALL 19790 0 3
78702: ST_TO_ADDR
// end ;
78703: LD_VAR 0 5
78707: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78708: LD_INT 0
78710: PPUSH
// if not mc_bases [ base ] then
78711: LD_EXP 59
78715: PUSH
78716: LD_VAR 0 1
78720: ARRAY
78721: NOT
78722: IFFALSE 78726
// exit ;
78724: GO 78751
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78726: LD_ADDR_EXP 96
78730: PUSH
78731: LD_EXP 96
78735: PPUSH
78736: LD_VAR 0 1
78740: PPUSH
78741: LD_VAR 0 2
78745: PPUSH
78746: CALL_OW 1
78750: ST_TO_ADDR
// end ;
78751: LD_VAR 0 3
78755: RET
// export function MC_GetMinesField ( base ) ; begin
78756: LD_INT 0
78758: PPUSH
// result := mc_mines [ base ] ;
78759: LD_ADDR_VAR 0 2
78763: PUSH
78764: LD_EXP 72
78768: PUSH
78769: LD_VAR 0 1
78773: ARRAY
78774: ST_TO_ADDR
// end ;
78775: LD_VAR 0 2
78779: RET
// export function MC_GetProduceList ( base ) ; begin
78780: LD_INT 0
78782: PPUSH
// result := mc_produce [ base ] ;
78783: LD_ADDR_VAR 0 2
78787: PUSH
78788: LD_EXP 80
78792: PUSH
78793: LD_VAR 0 1
78797: ARRAY
78798: ST_TO_ADDR
// end ;
78799: LD_VAR 0 2
78803: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78804: LD_INT 0
78806: PPUSH
78807: PPUSH
// if not mc_bases then
78808: LD_EXP 59
78812: NOT
78813: IFFALSE 78817
// exit ;
78815: GO 78882
// if mc_bases [ base ] then
78817: LD_EXP 59
78821: PUSH
78822: LD_VAR 0 1
78826: ARRAY
78827: IFFALSE 78882
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78829: LD_ADDR_VAR 0 3
78833: PUSH
78834: LD_EXP 59
78838: PUSH
78839: LD_VAR 0 1
78843: ARRAY
78844: PPUSH
78845: LD_INT 30
78847: PUSH
78848: LD_VAR 0 2
78852: PUSH
78853: EMPTY
78854: LIST
78855: LIST
78856: PPUSH
78857: CALL_OW 72
78861: ST_TO_ADDR
// if result then
78862: LD_VAR 0 3
78866: IFFALSE 78882
// result := result [ 1 ] ;
78868: LD_ADDR_VAR 0 3
78872: PUSH
78873: LD_VAR 0 3
78877: PUSH
78878: LD_INT 1
78880: ARRAY
78881: ST_TO_ADDR
// end ; end ;
78882: LD_VAR 0 3
78886: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
78887: LD_INT 0
78889: PPUSH
78890: PPUSH
// if not mc_bases then
78891: LD_EXP 59
78895: NOT
78896: IFFALSE 78900
// exit ;
78898: GO 78945
// if mc_bases [ base ] then
78900: LD_EXP 59
78904: PUSH
78905: LD_VAR 0 1
78909: ARRAY
78910: IFFALSE 78945
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78912: LD_ADDR_VAR 0 3
78916: PUSH
78917: LD_EXP 59
78921: PUSH
78922: LD_VAR 0 1
78926: ARRAY
78927: PPUSH
78928: LD_INT 30
78930: PUSH
78931: LD_VAR 0 2
78935: PUSH
78936: EMPTY
78937: LIST
78938: LIST
78939: PPUSH
78940: CALL_OW 72
78944: ST_TO_ADDR
// end ;
78945: LD_VAR 0 3
78949: RET
// export function MC_SetTame ( base , area ) ; begin
78950: LD_INT 0
78952: PPUSH
// if not mc_bases or not base then
78953: LD_EXP 59
78957: NOT
78958: PUSH
78959: LD_VAR 0 1
78963: NOT
78964: OR
78965: IFFALSE 78969
// exit ;
78967: GO 78994
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
78969: LD_ADDR_EXP 87
78973: PUSH
78974: LD_EXP 87
78978: PPUSH
78979: LD_VAR 0 1
78983: PPUSH
78984: LD_VAR 0 2
78988: PPUSH
78989: CALL_OW 1
78993: ST_TO_ADDR
// end ;
78994: LD_VAR 0 3
78998: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
78999: LD_INT 0
79001: PPUSH
79002: PPUSH
// if not mc_bases or not base then
79003: LD_EXP 59
79007: NOT
79008: PUSH
79009: LD_VAR 0 1
79013: NOT
79014: OR
79015: IFFALSE 79019
// exit ;
79017: GO 79121
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79019: LD_ADDR_VAR 0 4
79023: PUSH
79024: LD_EXP 59
79028: PUSH
79029: LD_VAR 0 1
79033: ARRAY
79034: PPUSH
79035: LD_INT 30
79037: PUSH
79038: LD_VAR 0 2
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PPUSH
79047: CALL_OW 72
79051: ST_TO_ADDR
// if not tmp then
79052: LD_VAR 0 4
79056: NOT
79057: IFFALSE 79061
// exit ;
79059: GO 79121
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79061: LD_ADDR_EXP 91
79065: PUSH
79066: LD_EXP 91
79070: PPUSH
79071: LD_VAR 0 1
79075: PPUSH
79076: LD_EXP 91
79080: PUSH
79081: LD_VAR 0 1
79085: ARRAY
79086: PPUSH
79087: LD_EXP 91
79091: PUSH
79092: LD_VAR 0 1
79096: ARRAY
79097: PUSH
79098: LD_INT 1
79100: PLUS
79101: PPUSH
79102: LD_VAR 0 4
79106: PUSH
79107: LD_INT 1
79109: ARRAY
79110: PPUSH
79111: CALL_OW 2
79115: PPUSH
79116: CALL_OW 1
79120: ST_TO_ADDR
// end ;
79121: LD_VAR 0 3
79125: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79126: LD_INT 0
79128: PPUSH
79129: PPUSH
// if not mc_bases or not base or not kinds then
79130: LD_EXP 59
79134: NOT
79135: PUSH
79136: LD_VAR 0 1
79140: NOT
79141: OR
79142: PUSH
79143: LD_VAR 0 2
79147: NOT
79148: OR
79149: IFFALSE 79153
// exit ;
79151: GO 79214
// for i in kinds do
79153: LD_ADDR_VAR 0 4
79157: PUSH
79158: LD_VAR 0 2
79162: PUSH
79163: FOR_IN
79164: IFFALSE 79212
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79166: LD_ADDR_EXP 93
79170: PUSH
79171: LD_EXP 93
79175: PPUSH
79176: LD_VAR 0 1
79180: PUSH
79181: LD_EXP 93
79185: PUSH
79186: LD_VAR 0 1
79190: ARRAY
79191: PUSH
79192: LD_INT 1
79194: PLUS
79195: PUSH
79196: EMPTY
79197: LIST
79198: LIST
79199: PPUSH
79200: LD_VAR 0 4
79204: PPUSH
79205: CALL 19790 0 3
79209: ST_TO_ADDR
79210: GO 79163
79212: POP
79213: POP
// end ;
79214: LD_VAR 0 3
79218: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79219: LD_INT 0
79221: PPUSH
// if not mc_bases or not base or not areas then
79222: LD_EXP 59
79226: NOT
79227: PUSH
79228: LD_VAR 0 1
79232: NOT
79233: OR
79234: PUSH
79235: LD_VAR 0 2
79239: NOT
79240: OR
79241: IFFALSE 79245
// exit ;
79243: GO 79270
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79245: LD_ADDR_EXP 77
79249: PUSH
79250: LD_EXP 77
79254: PPUSH
79255: LD_VAR 0 1
79259: PPUSH
79260: LD_VAR 0 2
79264: PPUSH
79265: CALL_OW 1
79269: ST_TO_ADDR
// end ;
79270: LD_VAR 0 3
79274: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79275: LD_INT 0
79277: PPUSH
// if not mc_bases or not base or not teleports_exit then
79278: LD_EXP 59
79282: NOT
79283: PUSH
79284: LD_VAR 0 1
79288: NOT
79289: OR
79290: PUSH
79291: LD_VAR 0 2
79295: NOT
79296: OR
79297: IFFALSE 79301
// exit ;
79299: GO 79326
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79301: LD_ADDR_EXP 94
79305: PUSH
79306: LD_EXP 94
79310: PPUSH
79311: LD_VAR 0 1
79315: PPUSH
79316: LD_VAR 0 2
79320: PPUSH
79321: CALL_OW 1
79325: ST_TO_ADDR
// end ;
79326: LD_VAR 0 3
79330: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79331: LD_INT 0
79333: PPUSH
79334: PPUSH
79335: PPUSH
// if not mc_bases or not base or not ext_list then
79336: LD_EXP 59
79340: NOT
79341: PUSH
79342: LD_VAR 0 1
79346: NOT
79347: OR
79348: PUSH
79349: LD_VAR 0 5
79353: NOT
79354: OR
79355: IFFALSE 79359
// exit ;
79357: GO 79532
// tmp := GetFacExtXYD ( x , y , d ) ;
79359: LD_ADDR_VAR 0 8
79363: PUSH
79364: LD_VAR 0 2
79368: PPUSH
79369: LD_VAR 0 3
79373: PPUSH
79374: LD_VAR 0 4
79378: PPUSH
79379: CALL 49177 0 3
79383: ST_TO_ADDR
// if not tmp then
79384: LD_VAR 0 8
79388: NOT
79389: IFFALSE 79393
// exit ;
79391: GO 79532
// for i in tmp do
79393: LD_ADDR_VAR 0 7
79397: PUSH
79398: LD_VAR 0 8
79402: PUSH
79403: FOR_IN
79404: IFFALSE 79530
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79406: LD_ADDR_EXP 64
79410: PUSH
79411: LD_EXP 64
79415: PPUSH
79416: LD_VAR 0 1
79420: PPUSH
79421: LD_EXP 64
79425: PUSH
79426: LD_VAR 0 1
79430: ARRAY
79431: PPUSH
79432: LD_EXP 64
79436: PUSH
79437: LD_VAR 0 1
79441: ARRAY
79442: PUSH
79443: LD_INT 1
79445: PLUS
79446: PPUSH
79447: LD_VAR 0 5
79451: PUSH
79452: LD_INT 1
79454: ARRAY
79455: PUSH
79456: LD_VAR 0 7
79460: PUSH
79461: LD_INT 1
79463: ARRAY
79464: PUSH
79465: LD_VAR 0 7
79469: PUSH
79470: LD_INT 2
79472: ARRAY
79473: PUSH
79474: LD_VAR 0 7
79478: PUSH
79479: LD_INT 3
79481: ARRAY
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: LIST
79487: LIST
79488: PPUSH
79489: CALL_OW 2
79493: PPUSH
79494: CALL_OW 1
79498: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79499: LD_ADDR_VAR 0 5
79503: PUSH
79504: LD_VAR 0 5
79508: PPUSH
79509: LD_INT 1
79511: PPUSH
79512: CALL_OW 3
79516: ST_TO_ADDR
// if not ext_list then
79517: LD_VAR 0 5
79521: NOT
79522: IFFALSE 79528
// exit ;
79524: POP
79525: POP
79526: GO 79532
// end ;
79528: GO 79403
79530: POP
79531: POP
// end ;
79532: LD_VAR 0 6
79536: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79537: LD_INT 0
79539: PPUSH
// if not mc_bases or not base or not weapon_list then
79540: LD_EXP 59
79544: NOT
79545: PUSH
79546: LD_VAR 0 1
79550: NOT
79551: OR
79552: PUSH
79553: LD_VAR 0 2
79557: NOT
79558: OR
79559: IFFALSE 79563
// exit ;
79561: GO 79588
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79563: LD_ADDR_EXP 98
79567: PUSH
79568: LD_EXP 98
79572: PPUSH
79573: LD_VAR 0 1
79577: PPUSH
79578: LD_VAR 0 2
79582: PPUSH
79583: CALL_OW 1
79587: ST_TO_ADDR
// end ;
79588: LD_VAR 0 3
79592: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79593: LD_INT 0
79595: PPUSH
// if not mc_bases or not base or not tech_list then
79596: LD_EXP 59
79600: NOT
79601: PUSH
79602: LD_VAR 0 1
79606: NOT
79607: OR
79608: PUSH
79609: LD_VAR 0 2
79613: NOT
79614: OR
79615: IFFALSE 79619
// exit ;
79617: GO 79644
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79619: LD_ADDR_EXP 86
79623: PUSH
79624: LD_EXP 86
79628: PPUSH
79629: LD_VAR 0 1
79633: PPUSH
79634: LD_VAR 0 2
79638: PPUSH
79639: CALL_OW 1
79643: ST_TO_ADDR
// end ;
79644: LD_VAR 0 3
79648: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79649: LD_INT 0
79651: PPUSH
// if not mc_bases or not parking_area or not base then
79652: LD_EXP 59
79656: NOT
79657: PUSH
79658: LD_VAR 0 2
79662: NOT
79663: OR
79664: PUSH
79665: LD_VAR 0 1
79669: NOT
79670: OR
79671: IFFALSE 79675
// exit ;
79673: GO 79700
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79675: LD_ADDR_EXP 83
79679: PUSH
79680: LD_EXP 83
79684: PPUSH
79685: LD_VAR 0 1
79689: PPUSH
79690: LD_VAR 0 2
79694: PPUSH
79695: CALL_OW 1
79699: ST_TO_ADDR
// end ;
79700: LD_VAR 0 3
79704: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79705: LD_INT 0
79707: PPUSH
// if not mc_bases or not base or not scan_area then
79708: LD_EXP 59
79712: NOT
79713: PUSH
79714: LD_VAR 0 1
79718: NOT
79719: OR
79720: PUSH
79721: LD_VAR 0 2
79725: NOT
79726: OR
79727: IFFALSE 79731
// exit ;
79729: GO 79756
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79731: LD_ADDR_EXP 84
79735: PUSH
79736: LD_EXP 84
79740: PPUSH
79741: LD_VAR 0 1
79745: PPUSH
79746: LD_VAR 0 2
79750: PPUSH
79751: CALL_OW 1
79755: ST_TO_ADDR
// end ;
79756: LD_VAR 0 3
79760: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79761: LD_INT 0
79763: PPUSH
79764: PPUSH
// if not mc_bases or not base then
79765: LD_EXP 59
79769: NOT
79770: PUSH
79771: LD_VAR 0 1
79775: NOT
79776: OR
79777: IFFALSE 79781
// exit ;
79779: GO 79845
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79781: LD_ADDR_VAR 0 3
79785: PUSH
79786: LD_INT 1
79788: PUSH
79789: LD_INT 2
79791: PUSH
79792: LD_INT 3
79794: PUSH
79795: LD_INT 4
79797: PUSH
79798: LD_INT 11
79800: PUSH
79801: EMPTY
79802: LIST
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79808: LD_ADDR_EXP 86
79812: PUSH
79813: LD_EXP 86
79817: PPUSH
79818: LD_VAR 0 1
79822: PPUSH
79823: LD_EXP 86
79827: PUSH
79828: LD_VAR 0 1
79832: ARRAY
79833: PUSH
79834: LD_VAR 0 3
79838: DIFF
79839: PPUSH
79840: CALL_OW 1
79844: ST_TO_ADDR
// end ;
79845: LD_VAR 0 2
79849: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
79850: LD_INT 0
79852: PPUSH
// result := mc_vehicles [ base ] ;
79853: LD_ADDR_VAR 0 3
79857: PUSH
79858: LD_EXP 78
79862: PUSH
79863: LD_VAR 0 1
79867: ARRAY
79868: ST_TO_ADDR
// if onlyCombat then
79869: LD_VAR 0 2
79873: IFFALSE 80051
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
79875: LD_ADDR_VAR 0 3
79879: PUSH
79880: LD_VAR 0 3
79884: PUSH
79885: LD_VAR 0 3
79889: PPUSH
79890: LD_INT 2
79892: PUSH
79893: LD_INT 34
79895: PUSH
79896: LD_INT 12
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 34
79905: PUSH
79906: LD_INT 51
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 34
79915: PUSH
79916: LD_EXP 104
79920: PUSH
79921: EMPTY
79922: LIST
79923: LIST
79924: PUSH
79925: LD_INT 34
79927: PUSH
79928: LD_INT 32
79930: PUSH
79931: EMPTY
79932: LIST
79933: LIST
79934: PUSH
79935: LD_INT 34
79937: PUSH
79938: LD_INT 13
79940: PUSH
79941: EMPTY
79942: LIST
79943: LIST
79944: PUSH
79945: LD_INT 34
79947: PUSH
79948: LD_INT 52
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 34
79957: PUSH
79958: LD_EXP 109
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: PUSH
79967: LD_INT 34
79969: PUSH
79970: LD_INT 14
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 34
79979: PUSH
79980: LD_INT 53
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 34
79989: PUSH
79990: LD_EXP 103
79994: PUSH
79995: EMPTY
79996: LIST
79997: LIST
79998: PUSH
79999: LD_INT 34
80001: PUSH
80002: LD_INT 31
80004: PUSH
80005: EMPTY
80006: LIST
80007: LIST
80008: PUSH
80009: LD_INT 34
80011: PUSH
80012: LD_INT 48
80014: PUSH
80015: EMPTY
80016: LIST
80017: LIST
80018: PUSH
80019: LD_INT 34
80021: PUSH
80022: LD_INT 8
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: LIST
80033: LIST
80034: LIST
80035: LIST
80036: LIST
80037: LIST
80038: LIST
80039: LIST
80040: LIST
80041: LIST
80042: LIST
80043: LIST
80044: PPUSH
80045: CALL_OW 72
80049: DIFF
80050: ST_TO_ADDR
// end ; end_of_file
80051: LD_VAR 0 3
80055: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80056: LD_INT 0
80058: PPUSH
80059: PPUSH
80060: PPUSH
// if not mc_bases or not skirmish then
80061: LD_EXP 59
80065: NOT
80066: PUSH
80067: LD_EXP 57
80071: NOT
80072: OR
80073: IFFALSE 80077
// exit ;
80075: GO 80242
// for i = 1 to mc_bases do
80077: LD_ADDR_VAR 0 4
80081: PUSH
80082: DOUBLE
80083: LD_INT 1
80085: DEC
80086: ST_TO_ADDR
80087: LD_EXP 59
80091: PUSH
80092: FOR_TO
80093: IFFALSE 80240
// begin if sci in mc_bases [ i ] then
80095: LD_VAR 0 2
80099: PUSH
80100: LD_EXP 59
80104: PUSH
80105: LD_VAR 0 4
80109: ARRAY
80110: IN
80111: IFFALSE 80238
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80113: LD_ADDR_EXP 88
80117: PUSH
80118: LD_EXP 88
80122: PPUSH
80123: LD_VAR 0 4
80127: PUSH
80128: LD_EXP 88
80132: PUSH
80133: LD_VAR 0 4
80137: ARRAY
80138: PUSH
80139: LD_INT 1
80141: PLUS
80142: PUSH
80143: EMPTY
80144: LIST
80145: LIST
80146: PPUSH
80147: LD_VAR 0 1
80151: PPUSH
80152: CALL 19790 0 3
80156: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80157: LD_ADDR_VAR 0 5
80161: PUSH
80162: LD_EXP 59
80166: PUSH
80167: LD_VAR 0 4
80171: ARRAY
80172: PPUSH
80173: LD_INT 2
80175: PUSH
80176: LD_INT 30
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: EMPTY
80183: LIST
80184: LIST
80185: PUSH
80186: LD_INT 30
80188: PUSH
80189: LD_INT 1
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: LIST
80200: PPUSH
80201: CALL_OW 72
80205: PPUSH
80206: LD_VAR 0 1
80210: PPUSH
80211: CALL_OW 74
80215: ST_TO_ADDR
// if tmp then
80216: LD_VAR 0 5
80220: IFFALSE 80236
// ComStandNearbyBuilding ( ape , tmp ) ;
80222: LD_VAR 0 1
80226: PPUSH
80227: LD_VAR 0 5
80231: PPUSH
80232: CALL 16368 0 2
// break ;
80236: GO 80240
// end ; end ;
80238: GO 80092
80240: POP
80241: POP
// end ;
80242: LD_VAR 0 3
80246: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80247: LD_INT 0
80249: PPUSH
80250: PPUSH
80251: PPUSH
// if not mc_bases or not skirmish then
80252: LD_EXP 59
80256: NOT
80257: PUSH
80258: LD_EXP 57
80262: NOT
80263: OR
80264: IFFALSE 80268
// exit ;
80266: GO 80357
// for i = 1 to mc_bases do
80268: LD_ADDR_VAR 0 4
80272: PUSH
80273: DOUBLE
80274: LD_INT 1
80276: DEC
80277: ST_TO_ADDR
80278: LD_EXP 59
80282: PUSH
80283: FOR_TO
80284: IFFALSE 80355
// begin if building in mc_busy_turret_list [ i ] then
80286: LD_VAR 0 1
80290: PUSH
80291: LD_EXP 69
80295: PUSH
80296: LD_VAR 0 4
80300: ARRAY
80301: IN
80302: IFFALSE 80353
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80304: LD_ADDR_VAR 0 5
80308: PUSH
80309: LD_EXP 69
80313: PUSH
80314: LD_VAR 0 4
80318: ARRAY
80319: PUSH
80320: LD_VAR 0 1
80324: DIFF
80325: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80326: LD_ADDR_EXP 69
80330: PUSH
80331: LD_EXP 69
80335: PPUSH
80336: LD_VAR 0 4
80340: PPUSH
80341: LD_VAR 0 5
80345: PPUSH
80346: CALL_OW 1
80350: ST_TO_ADDR
// break ;
80351: GO 80355
// end ; end ;
80353: GO 80283
80355: POP
80356: POP
// end ;
80357: LD_VAR 0 3
80361: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80362: LD_INT 0
80364: PPUSH
80365: PPUSH
80366: PPUSH
// if not mc_bases or not skirmish then
80367: LD_EXP 59
80371: NOT
80372: PUSH
80373: LD_EXP 57
80377: NOT
80378: OR
80379: IFFALSE 80383
// exit ;
80381: GO 80582
// for i = 1 to mc_bases do
80383: LD_ADDR_VAR 0 5
80387: PUSH
80388: DOUBLE
80389: LD_INT 1
80391: DEC
80392: ST_TO_ADDR
80393: LD_EXP 59
80397: PUSH
80398: FOR_TO
80399: IFFALSE 80580
// if building in mc_bases [ i ] then
80401: LD_VAR 0 1
80405: PUSH
80406: LD_EXP 59
80410: PUSH
80411: LD_VAR 0 5
80415: ARRAY
80416: IN
80417: IFFALSE 80578
// begin tmp := mc_bases [ i ] diff building ;
80419: LD_ADDR_VAR 0 6
80423: PUSH
80424: LD_EXP 59
80428: PUSH
80429: LD_VAR 0 5
80433: ARRAY
80434: PUSH
80435: LD_VAR 0 1
80439: DIFF
80440: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80441: LD_ADDR_EXP 59
80445: PUSH
80446: LD_EXP 59
80450: PPUSH
80451: LD_VAR 0 5
80455: PPUSH
80456: LD_VAR 0 6
80460: PPUSH
80461: CALL_OW 1
80465: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80466: LD_VAR 0 1
80470: PUSH
80471: LD_EXP 67
80475: PUSH
80476: LD_VAR 0 5
80480: ARRAY
80481: IN
80482: IFFALSE 80521
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80484: LD_ADDR_EXP 67
80488: PUSH
80489: LD_EXP 67
80493: PPUSH
80494: LD_VAR 0 5
80498: PPUSH
80499: LD_EXP 67
80503: PUSH
80504: LD_VAR 0 5
80508: ARRAY
80509: PUSH
80510: LD_VAR 0 1
80514: DIFF
80515: PPUSH
80516: CALL_OW 1
80520: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80521: LD_VAR 0 1
80525: PUSH
80526: LD_EXP 68
80530: PUSH
80531: LD_VAR 0 5
80535: ARRAY
80536: IN
80537: IFFALSE 80576
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80539: LD_ADDR_EXP 68
80543: PUSH
80544: LD_EXP 68
80548: PPUSH
80549: LD_VAR 0 5
80553: PPUSH
80554: LD_EXP 68
80558: PUSH
80559: LD_VAR 0 5
80563: ARRAY
80564: PUSH
80565: LD_VAR 0 1
80569: DIFF
80570: PPUSH
80571: CALL_OW 1
80575: ST_TO_ADDR
// break ;
80576: GO 80580
// end ;
80578: GO 80398
80580: POP
80581: POP
// end ;
80582: LD_VAR 0 4
80586: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80587: LD_INT 0
80589: PPUSH
80590: PPUSH
80591: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80592: LD_EXP 59
80596: NOT
80597: PUSH
80598: LD_EXP 57
80602: NOT
80603: OR
80604: PUSH
80605: LD_VAR 0 3
80609: PUSH
80610: LD_EXP 85
80614: IN
80615: NOT
80616: OR
80617: IFFALSE 80621
// exit ;
80619: GO 80744
// for i = 1 to mc_vehicles do
80621: LD_ADDR_VAR 0 6
80625: PUSH
80626: DOUBLE
80627: LD_INT 1
80629: DEC
80630: ST_TO_ADDR
80631: LD_EXP 78
80635: PUSH
80636: FOR_TO
80637: IFFALSE 80742
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80639: LD_VAR 0 2
80643: PUSH
80644: LD_EXP 78
80648: PUSH
80649: LD_VAR 0 6
80653: ARRAY
80654: IN
80655: PUSH
80656: LD_VAR 0 1
80660: PUSH
80661: LD_EXP 78
80665: PUSH
80666: LD_VAR 0 6
80670: ARRAY
80671: IN
80672: OR
80673: IFFALSE 80740
// begin tmp := mc_vehicles [ i ] diff old ;
80675: LD_ADDR_VAR 0 7
80679: PUSH
80680: LD_EXP 78
80684: PUSH
80685: LD_VAR 0 6
80689: ARRAY
80690: PUSH
80691: LD_VAR 0 2
80695: DIFF
80696: ST_TO_ADDR
// tmp := tmp diff new ;
80697: LD_ADDR_VAR 0 7
80701: PUSH
80702: LD_VAR 0 7
80706: PUSH
80707: LD_VAR 0 1
80711: DIFF
80712: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80713: LD_ADDR_EXP 78
80717: PUSH
80718: LD_EXP 78
80722: PPUSH
80723: LD_VAR 0 6
80727: PPUSH
80728: LD_VAR 0 7
80732: PPUSH
80733: CALL_OW 1
80737: ST_TO_ADDR
// break ;
80738: GO 80742
// end ;
80740: GO 80636
80742: POP
80743: POP
// end ;
80744: LD_VAR 0 5
80748: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80749: LD_INT 0
80751: PPUSH
80752: PPUSH
80753: PPUSH
80754: PPUSH
// if not mc_bases or not skirmish then
80755: LD_EXP 59
80759: NOT
80760: PUSH
80761: LD_EXP 57
80765: NOT
80766: OR
80767: IFFALSE 80771
// exit ;
80769: GO 81163
// side := GetSide ( vehicle ) ;
80771: LD_ADDR_VAR 0 5
80775: PUSH
80776: LD_VAR 0 1
80780: PPUSH
80781: CALL_OW 255
80785: ST_TO_ADDR
// for i = 1 to mc_bases do
80786: LD_ADDR_VAR 0 4
80790: PUSH
80791: DOUBLE
80792: LD_INT 1
80794: DEC
80795: ST_TO_ADDR
80796: LD_EXP 59
80800: PUSH
80801: FOR_TO
80802: IFFALSE 81161
// begin if factory in mc_bases [ i ] then
80804: LD_VAR 0 2
80808: PUSH
80809: LD_EXP 59
80813: PUSH
80814: LD_VAR 0 4
80818: ARRAY
80819: IN
80820: IFFALSE 81159
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80822: LD_EXP 81
80826: PUSH
80827: LD_VAR 0 4
80831: ARRAY
80832: PUSH
80833: LD_EXP 70
80837: PUSH
80838: LD_VAR 0 4
80842: ARRAY
80843: LESS
80844: PUSH
80845: LD_VAR 0 1
80849: PPUSH
80850: CALL_OW 264
80854: PUSH
80855: LD_INT 31
80857: PUSH
80858: LD_INT 32
80860: PUSH
80861: LD_INT 51
80863: PUSH
80864: LD_EXP 104
80868: PUSH
80869: LD_INT 12
80871: PUSH
80872: LD_INT 30
80874: PUSH
80875: LD_EXP 103
80879: PUSH
80880: LD_INT 11
80882: PUSH
80883: LD_INT 53
80885: PUSH
80886: LD_INT 14
80888: PUSH
80889: LD_EXP 107
80893: PUSH
80894: LD_INT 29
80896: PUSH
80897: LD_EXP 105
80901: PUSH
80902: LD_INT 13
80904: PUSH
80905: LD_INT 52
80907: PUSH
80908: LD_EXP 109
80912: PUSH
80913: LD_INT 48
80915: PUSH
80916: LD_INT 8
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: LIST
80923: LIST
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: IN
80939: NOT
80940: AND
80941: IFFALSE 80989
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
80943: LD_ADDR_EXP 81
80947: PUSH
80948: LD_EXP 81
80952: PPUSH
80953: LD_VAR 0 4
80957: PUSH
80958: LD_EXP 81
80962: PUSH
80963: LD_VAR 0 4
80967: ARRAY
80968: PUSH
80969: LD_INT 1
80971: PLUS
80972: PUSH
80973: EMPTY
80974: LIST
80975: LIST
80976: PPUSH
80977: LD_VAR 0 1
80981: PPUSH
80982: CALL 19790 0 3
80986: ST_TO_ADDR
80987: GO 81033
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
80989: LD_ADDR_EXP 78
80993: PUSH
80994: LD_EXP 78
80998: PPUSH
80999: LD_VAR 0 4
81003: PUSH
81004: LD_EXP 78
81008: PUSH
81009: LD_VAR 0 4
81013: ARRAY
81014: PUSH
81015: LD_INT 1
81017: PLUS
81018: PUSH
81019: EMPTY
81020: LIST
81021: LIST
81022: PPUSH
81023: LD_VAR 0 1
81027: PPUSH
81028: CALL 19790 0 3
81032: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81033: LD_VAR 0 1
81037: PPUSH
81038: CALL_OW 263
81042: PUSH
81043: LD_INT 2
81045: EQUAL
81046: IFFALSE 81075
// begin repeat wait ( 0 0$3 ) ;
81048: LD_INT 105
81050: PPUSH
81051: CALL_OW 67
// Connect ( vehicle ) ;
81055: LD_VAR 0 1
81059: PPUSH
81060: CALL 22761 0 1
// until IsControledBy ( vehicle ) ;
81064: LD_VAR 0 1
81068: PPUSH
81069: CALL_OW 312
81073: IFFALSE 81048
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81075: LD_VAR 0 1
81079: PPUSH
81080: LD_EXP 83
81084: PUSH
81085: LD_VAR 0 4
81089: ARRAY
81090: PPUSH
81091: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81095: LD_VAR 0 1
81099: PPUSH
81100: CALL_OW 263
81104: PUSH
81105: LD_INT 1
81107: NONEQUAL
81108: IFFALSE 81112
// break ;
81110: GO 81161
// repeat wait ( 0 0$1 ) ;
81112: LD_INT 35
81114: PPUSH
81115: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81119: LD_VAR 0 1
81123: PPUSH
81124: LD_EXP 83
81128: PUSH
81129: LD_VAR 0 4
81133: ARRAY
81134: PPUSH
81135: CALL_OW 308
81139: IFFALSE 81112
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81141: LD_VAR 0 1
81145: PPUSH
81146: CALL_OW 311
81150: PPUSH
81151: CALL_OW 121
// exit ;
81155: POP
81156: POP
81157: GO 81163
// end ; end ;
81159: GO 80801
81161: POP
81162: POP
// end ;
81163: LD_VAR 0 3
81167: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81168: LD_INT 0
81170: PPUSH
81171: PPUSH
81172: PPUSH
81173: PPUSH
// if not mc_bases or not skirmish then
81174: LD_EXP 59
81178: NOT
81179: PUSH
81180: LD_EXP 57
81184: NOT
81185: OR
81186: IFFALSE 81190
// exit ;
81188: GO 81543
// repeat wait ( 0 0$1 ) ;
81190: LD_INT 35
81192: PPUSH
81193: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81197: LD_VAR 0 2
81201: PPUSH
81202: LD_VAR 0 3
81206: PPUSH
81207: CALL_OW 284
81211: IFFALSE 81190
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81213: LD_VAR 0 2
81217: PPUSH
81218: LD_VAR 0 3
81222: PPUSH
81223: CALL_OW 283
81227: PUSH
81228: LD_INT 4
81230: EQUAL
81231: IFFALSE 81235
// exit ;
81233: GO 81543
// for i = 1 to mc_bases do
81235: LD_ADDR_VAR 0 7
81239: PUSH
81240: DOUBLE
81241: LD_INT 1
81243: DEC
81244: ST_TO_ADDR
81245: LD_EXP 59
81249: PUSH
81250: FOR_TO
81251: IFFALSE 81541
// begin if mc_crates_area [ i ] then
81253: LD_EXP 77
81257: PUSH
81258: LD_VAR 0 7
81262: ARRAY
81263: IFFALSE 81374
// for j in mc_crates_area [ i ] do
81265: LD_ADDR_VAR 0 8
81269: PUSH
81270: LD_EXP 77
81274: PUSH
81275: LD_VAR 0 7
81279: ARRAY
81280: PUSH
81281: FOR_IN
81282: IFFALSE 81372
// if InArea ( x , y , j ) then
81284: LD_VAR 0 2
81288: PPUSH
81289: LD_VAR 0 3
81293: PPUSH
81294: LD_VAR 0 8
81298: PPUSH
81299: CALL_OW 309
81303: IFFALSE 81370
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81305: LD_ADDR_EXP 75
81309: PUSH
81310: LD_EXP 75
81314: PPUSH
81315: LD_VAR 0 7
81319: PUSH
81320: LD_EXP 75
81324: PUSH
81325: LD_VAR 0 7
81329: ARRAY
81330: PUSH
81331: LD_INT 1
81333: PLUS
81334: PUSH
81335: EMPTY
81336: LIST
81337: LIST
81338: PPUSH
81339: LD_VAR 0 4
81343: PUSH
81344: LD_VAR 0 2
81348: PUSH
81349: LD_VAR 0 3
81353: PUSH
81354: EMPTY
81355: LIST
81356: LIST
81357: LIST
81358: PPUSH
81359: CALL 19790 0 3
81363: ST_TO_ADDR
// exit ;
81364: POP
81365: POP
81366: POP
81367: POP
81368: GO 81543
// end ;
81370: GO 81281
81372: POP
81373: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81374: LD_ADDR_VAR 0 9
81378: PUSH
81379: LD_EXP 59
81383: PUSH
81384: LD_VAR 0 7
81388: ARRAY
81389: PPUSH
81390: LD_INT 2
81392: PUSH
81393: LD_INT 30
81395: PUSH
81396: LD_INT 0
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: LD_INT 30
81405: PUSH
81406: LD_INT 1
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: EMPTY
81414: LIST
81415: LIST
81416: LIST
81417: PPUSH
81418: CALL_OW 72
81422: ST_TO_ADDR
// if not depot then
81423: LD_VAR 0 9
81427: NOT
81428: IFFALSE 81432
// continue ;
81430: GO 81250
// for j in depot do
81432: LD_ADDR_VAR 0 8
81436: PUSH
81437: LD_VAR 0 9
81441: PUSH
81442: FOR_IN
81443: IFFALSE 81537
// if GetDistUnitXY ( j , x , y ) < 30 then
81445: LD_VAR 0 8
81449: PPUSH
81450: LD_VAR 0 2
81454: PPUSH
81455: LD_VAR 0 3
81459: PPUSH
81460: CALL_OW 297
81464: PUSH
81465: LD_INT 30
81467: LESS
81468: IFFALSE 81535
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81470: LD_ADDR_EXP 75
81474: PUSH
81475: LD_EXP 75
81479: PPUSH
81480: LD_VAR 0 7
81484: PUSH
81485: LD_EXP 75
81489: PUSH
81490: LD_VAR 0 7
81494: ARRAY
81495: PUSH
81496: LD_INT 1
81498: PLUS
81499: PUSH
81500: EMPTY
81501: LIST
81502: LIST
81503: PPUSH
81504: LD_VAR 0 4
81508: PUSH
81509: LD_VAR 0 2
81513: PUSH
81514: LD_VAR 0 3
81518: PUSH
81519: EMPTY
81520: LIST
81521: LIST
81522: LIST
81523: PPUSH
81524: CALL 19790 0 3
81528: ST_TO_ADDR
// exit ;
81529: POP
81530: POP
81531: POP
81532: POP
81533: GO 81543
// end ;
81535: GO 81442
81537: POP
81538: POP
// end ;
81539: GO 81250
81541: POP
81542: POP
// end ;
81543: LD_VAR 0 6
81547: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81548: LD_INT 0
81550: PPUSH
81551: PPUSH
81552: PPUSH
81553: PPUSH
// if not mc_bases or not skirmish then
81554: LD_EXP 59
81558: NOT
81559: PUSH
81560: LD_EXP 57
81564: NOT
81565: OR
81566: IFFALSE 81570
// exit ;
81568: GO 81847
// side := GetSide ( lab ) ;
81570: LD_ADDR_VAR 0 4
81574: PUSH
81575: LD_VAR 0 2
81579: PPUSH
81580: CALL_OW 255
81584: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81585: LD_VAR 0 4
81589: PUSH
81590: LD_EXP 85
81594: IN
81595: NOT
81596: PUSH
81597: LD_EXP 86
81601: NOT
81602: OR
81603: PUSH
81604: LD_EXP 59
81608: NOT
81609: OR
81610: IFFALSE 81614
// exit ;
81612: GO 81847
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81614: LD_ADDR_EXP 86
81618: PUSH
81619: LD_EXP 86
81623: PPUSH
81624: LD_VAR 0 4
81628: PPUSH
81629: LD_EXP 86
81633: PUSH
81634: LD_VAR 0 4
81638: ARRAY
81639: PUSH
81640: LD_VAR 0 1
81644: DIFF
81645: PPUSH
81646: CALL_OW 1
81650: ST_TO_ADDR
// for i = 1 to mc_bases do
81651: LD_ADDR_VAR 0 5
81655: PUSH
81656: DOUBLE
81657: LD_INT 1
81659: DEC
81660: ST_TO_ADDR
81661: LD_EXP 59
81665: PUSH
81666: FOR_TO
81667: IFFALSE 81845
// begin if lab in mc_bases [ i ] then
81669: LD_VAR 0 2
81673: PUSH
81674: LD_EXP 59
81678: PUSH
81679: LD_VAR 0 5
81683: ARRAY
81684: IN
81685: IFFALSE 81843
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81687: LD_VAR 0 1
81691: PUSH
81692: LD_INT 11
81694: PUSH
81695: LD_INT 4
81697: PUSH
81698: LD_INT 3
81700: PUSH
81701: LD_INT 2
81703: PUSH
81704: EMPTY
81705: LIST
81706: LIST
81707: LIST
81708: LIST
81709: IN
81710: PUSH
81711: LD_EXP 89
81715: PUSH
81716: LD_VAR 0 5
81720: ARRAY
81721: AND
81722: IFFALSE 81843
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81724: LD_ADDR_VAR 0 6
81728: PUSH
81729: LD_EXP 89
81733: PUSH
81734: LD_VAR 0 5
81738: ARRAY
81739: PUSH
81740: LD_INT 1
81742: ARRAY
81743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81744: LD_ADDR_EXP 89
81748: PUSH
81749: LD_EXP 89
81753: PPUSH
81754: LD_VAR 0 5
81758: PPUSH
81759: EMPTY
81760: PPUSH
81761: CALL_OW 1
81765: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81766: LD_VAR 0 6
81770: PPUSH
81771: LD_INT 0
81773: PPUSH
81774: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81778: LD_VAR 0 6
81782: PPUSH
81783: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81787: LD_ADDR_EXP 88
81791: PUSH
81792: LD_EXP 88
81796: PPUSH
81797: LD_VAR 0 5
81801: PPUSH
81802: LD_EXP 88
81806: PUSH
81807: LD_VAR 0 5
81811: ARRAY
81812: PPUSH
81813: LD_INT 1
81815: PPUSH
81816: LD_VAR 0 6
81820: PPUSH
81821: CALL_OW 2
81825: PPUSH
81826: CALL_OW 1
81830: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81831: LD_VAR 0 5
81835: PPUSH
81836: LD_INT 112
81838: PPUSH
81839: CALL 58513 0 2
// end ; end ; end ;
81843: GO 81666
81845: POP
81846: POP
// end ;
81847: LD_VAR 0 3
81851: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
81852: LD_INT 0
81854: PPUSH
81855: PPUSH
81856: PPUSH
81857: PPUSH
81858: PPUSH
81859: PPUSH
81860: PPUSH
81861: PPUSH
// if not mc_bases or not skirmish then
81862: LD_EXP 59
81866: NOT
81867: PUSH
81868: LD_EXP 57
81872: NOT
81873: OR
81874: IFFALSE 81878
// exit ;
81876: GO 83249
// for i = 1 to mc_bases do
81878: LD_ADDR_VAR 0 3
81882: PUSH
81883: DOUBLE
81884: LD_INT 1
81886: DEC
81887: ST_TO_ADDR
81888: LD_EXP 59
81892: PUSH
81893: FOR_TO
81894: IFFALSE 83247
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
81896: LD_VAR 0 1
81900: PUSH
81901: LD_EXP 59
81905: PUSH
81906: LD_VAR 0 3
81910: ARRAY
81911: IN
81912: PUSH
81913: LD_VAR 0 1
81917: PUSH
81918: LD_EXP 66
81922: PUSH
81923: LD_VAR 0 3
81927: ARRAY
81928: IN
81929: OR
81930: PUSH
81931: LD_VAR 0 1
81935: PUSH
81936: LD_EXP 81
81940: PUSH
81941: LD_VAR 0 3
81945: ARRAY
81946: IN
81947: OR
81948: PUSH
81949: LD_VAR 0 1
81953: PUSH
81954: LD_EXP 78
81958: PUSH
81959: LD_VAR 0 3
81963: ARRAY
81964: IN
81965: OR
81966: PUSH
81967: LD_VAR 0 1
81971: PUSH
81972: LD_EXP 88
81976: PUSH
81977: LD_VAR 0 3
81981: ARRAY
81982: IN
81983: OR
81984: PUSH
81985: LD_VAR 0 1
81989: PUSH
81990: LD_EXP 89
81994: PUSH
81995: LD_VAR 0 3
81999: ARRAY
82000: IN
82001: OR
82002: IFFALSE 83245
// begin if un in mc_ape [ i ] then
82004: LD_VAR 0 1
82008: PUSH
82009: LD_EXP 88
82013: PUSH
82014: LD_VAR 0 3
82018: ARRAY
82019: IN
82020: IFFALSE 82059
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82022: LD_ADDR_EXP 88
82026: PUSH
82027: LD_EXP 88
82031: PPUSH
82032: LD_VAR 0 3
82036: PPUSH
82037: LD_EXP 88
82041: PUSH
82042: LD_VAR 0 3
82046: ARRAY
82047: PUSH
82048: LD_VAR 0 1
82052: DIFF
82053: PPUSH
82054: CALL_OW 1
82058: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82059: LD_VAR 0 1
82063: PUSH
82064: LD_EXP 89
82068: PUSH
82069: LD_VAR 0 3
82073: ARRAY
82074: IN
82075: IFFALSE 82099
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82077: LD_ADDR_EXP 89
82081: PUSH
82082: LD_EXP 89
82086: PPUSH
82087: LD_VAR 0 3
82091: PPUSH
82092: EMPTY
82093: PPUSH
82094: CALL_OW 1
82098: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82099: LD_VAR 0 1
82103: PPUSH
82104: CALL_OW 247
82108: PUSH
82109: LD_INT 2
82111: EQUAL
82112: PUSH
82113: LD_VAR 0 1
82117: PPUSH
82118: CALL_OW 110
82122: PUSH
82123: LD_INT 20
82125: EQUAL
82126: PUSH
82127: LD_VAR 0 1
82131: PUSH
82132: LD_EXP 81
82136: PUSH
82137: LD_VAR 0 3
82141: ARRAY
82142: IN
82143: OR
82144: PUSH
82145: LD_VAR 0 1
82149: PPUSH
82150: CALL_OW 264
82154: PUSH
82155: LD_INT 12
82157: PUSH
82158: LD_INT 51
82160: PUSH
82161: LD_EXP 104
82165: PUSH
82166: LD_INT 32
82168: PUSH
82169: LD_INT 13
82171: PUSH
82172: LD_INT 52
82174: PUSH
82175: LD_INT 31
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: IN
82187: OR
82188: AND
82189: IFFALSE 82497
// begin if un in mc_defender [ i ] then
82191: LD_VAR 0 1
82195: PUSH
82196: LD_EXP 81
82200: PUSH
82201: LD_VAR 0 3
82205: ARRAY
82206: IN
82207: IFFALSE 82246
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82209: LD_ADDR_EXP 81
82213: PUSH
82214: LD_EXP 81
82218: PPUSH
82219: LD_VAR 0 3
82223: PPUSH
82224: LD_EXP 81
82228: PUSH
82229: LD_VAR 0 3
82233: ARRAY
82234: PUSH
82235: LD_VAR 0 1
82239: DIFF
82240: PPUSH
82241: CALL_OW 1
82245: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
82246: LD_ADDR_VAR 0 8
82250: PUSH
82251: LD_VAR 0 3
82255: PPUSH
82256: LD_INT 3
82258: PPUSH
82259: CALL 78887 0 2
82263: ST_TO_ADDR
// if fac then
82264: LD_VAR 0 8
82268: IFFALSE 82497
// begin for j in fac do
82270: LD_ADDR_VAR 0 4
82274: PUSH
82275: LD_VAR 0 8
82279: PUSH
82280: FOR_IN
82281: IFFALSE 82495
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82283: LD_ADDR_VAR 0 9
82287: PUSH
82288: LD_VAR 0 8
82292: PPUSH
82293: LD_VAR 0 1
82297: PPUSH
82298: CALL_OW 265
82302: PPUSH
82303: LD_VAR 0 1
82307: PPUSH
82308: CALL_OW 262
82312: PPUSH
82313: LD_VAR 0 1
82317: PPUSH
82318: CALL_OW 263
82322: PPUSH
82323: LD_VAR 0 1
82327: PPUSH
82328: CALL_OW 264
82332: PPUSH
82333: CALL 17286 0 5
82337: ST_TO_ADDR
// if components then
82338: LD_VAR 0 9
82342: IFFALSE 82493
// begin if GetWeapon ( un ) = ar_control_tower then
82344: LD_VAR 0 1
82348: PPUSH
82349: CALL_OW 264
82353: PUSH
82354: LD_INT 31
82356: EQUAL
82357: IFFALSE 82474
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82359: LD_VAR 0 1
82363: PPUSH
82364: CALL_OW 311
82368: PPUSH
82369: LD_INT 0
82371: PPUSH
82372: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82376: LD_ADDR_EXP 99
82380: PUSH
82381: LD_EXP 99
82385: PPUSH
82386: LD_VAR 0 3
82390: PPUSH
82391: LD_EXP 99
82395: PUSH
82396: LD_VAR 0 3
82400: ARRAY
82401: PUSH
82402: LD_VAR 0 1
82406: PPUSH
82407: CALL_OW 311
82411: DIFF
82412: PPUSH
82413: CALL_OW 1
82417: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82418: LD_ADDR_VAR 0 7
82422: PUSH
82423: LD_EXP 80
82427: PUSH
82428: LD_VAR 0 3
82432: ARRAY
82433: PPUSH
82434: LD_INT 1
82436: PPUSH
82437: LD_VAR 0 9
82441: PPUSH
82442: CALL_OW 2
82446: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82447: LD_ADDR_EXP 80
82451: PUSH
82452: LD_EXP 80
82456: PPUSH
82457: LD_VAR 0 3
82461: PPUSH
82462: LD_VAR 0 7
82466: PPUSH
82467: CALL_OW 1
82471: ST_TO_ADDR
// end else
82472: GO 82491
// MC_InsertProduceList ( i , [ components ] ) ;
82474: LD_VAR 0 3
82478: PPUSH
82479: LD_VAR 0 9
82483: PUSH
82484: EMPTY
82485: LIST
82486: PPUSH
82487: CALL 78432 0 2
// break ;
82491: GO 82495
// end ; end ;
82493: GO 82280
82495: POP
82496: POP
// end ; end ; if GetType ( un ) = unit_building then
82497: LD_VAR 0 1
82501: PPUSH
82502: CALL_OW 247
82506: PUSH
82507: LD_INT 3
82509: EQUAL
82510: IFFALSE 82913
// begin btype := GetBType ( un ) ;
82512: LD_ADDR_VAR 0 5
82516: PUSH
82517: LD_VAR 0 1
82521: PPUSH
82522: CALL_OW 266
82526: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82527: LD_VAR 0 5
82531: PUSH
82532: LD_INT 29
82534: PUSH
82535: LD_INT 30
82537: PUSH
82538: EMPTY
82539: LIST
82540: LIST
82541: IN
82542: IFFALSE 82615
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82544: LD_VAR 0 1
82548: PPUSH
82549: CALL_OW 250
82553: PPUSH
82554: LD_VAR 0 1
82558: PPUSH
82559: CALL_OW 251
82563: PPUSH
82564: LD_VAR 0 1
82568: PPUSH
82569: CALL_OW 255
82573: PPUSH
82574: CALL_OW 440
82578: NOT
82579: IFFALSE 82615
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82581: LD_VAR 0 1
82585: PPUSH
82586: CALL_OW 250
82590: PPUSH
82591: LD_VAR 0 1
82595: PPUSH
82596: CALL_OW 251
82600: PPUSH
82601: LD_VAR 0 1
82605: PPUSH
82606: CALL_OW 255
82610: PPUSH
82611: CALL_OW 441
// end ; if btype = b_warehouse then
82615: LD_VAR 0 5
82619: PUSH
82620: LD_INT 1
82622: EQUAL
82623: IFFALSE 82641
// begin btype := b_depot ;
82625: LD_ADDR_VAR 0 5
82629: PUSH
82630: LD_INT 0
82632: ST_TO_ADDR
// pos := 1 ;
82633: LD_ADDR_VAR 0 6
82637: PUSH
82638: LD_INT 1
82640: ST_TO_ADDR
// end ; if btype = b_factory then
82641: LD_VAR 0 5
82645: PUSH
82646: LD_INT 3
82648: EQUAL
82649: IFFALSE 82667
// begin btype := b_workshop ;
82651: LD_ADDR_VAR 0 5
82655: PUSH
82656: LD_INT 2
82658: ST_TO_ADDR
// pos := 1 ;
82659: LD_ADDR_VAR 0 6
82663: PUSH
82664: LD_INT 1
82666: ST_TO_ADDR
// end ; if btype = b_barracks then
82667: LD_VAR 0 5
82671: PUSH
82672: LD_INT 5
82674: EQUAL
82675: IFFALSE 82685
// btype := b_armoury ;
82677: LD_ADDR_VAR 0 5
82681: PUSH
82682: LD_INT 4
82684: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82685: LD_VAR 0 5
82689: PUSH
82690: LD_INT 7
82692: PUSH
82693: LD_INT 8
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: IN
82700: IFFALSE 82710
// btype := b_lab ;
82702: LD_ADDR_VAR 0 5
82706: PUSH
82707: LD_INT 6
82709: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82710: LD_ADDR_EXP 64
82714: PUSH
82715: LD_EXP 64
82719: PPUSH
82720: LD_VAR 0 3
82724: PUSH
82725: LD_EXP 64
82729: PUSH
82730: LD_VAR 0 3
82734: ARRAY
82735: PUSH
82736: LD_INT 1
82738: PLUS
82739: PUSH
82740: EMPTY
82741: LIST
82742: LIST
82743: PPUSH
82744: LD_VAR 0 5
82748: PUSH
82749: LD_VAR 0 1
82753: PPUSH
82754: CALL_OW 250
82758: PUSH
82759: LD_VAR 0 1
82763: PPUSH
82764: CALL_OW 251
82768: PUSH
82769: LD_VAR 0 1
82773: PPUSH
82774: CALL_OW 254
82778: PUSH
82779: EMPTY
82780: LIST
82781: LIST
82782: LIST
82783: LIST
82784: PPUSH
82785: CALL 19790 0 3
82789: ST_TO_ADDR
// if pos = 1 then
82790: LD_VAR 0 6
82794: PUSH
82795: LD_INT 1
82797: EQUAL
82798: IFFALSE 82913
// begin tmp := mc_build_list [ i ] ;
82800: LD_ADDR_VAR 0 7
82804: PUSH
82805: LD_EXP 64
82809: PUSH
82810: LD_VAR 0 3
82814: ARRAY
82815: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82816: LD_VAR 0 7
82820: PPUSH
82821: LD_INT 2
82823: PUSH
82824: LD_INT 30
82826: PUSH
82827: LD_INT 0
82829: PUSH
82830: EMPTY
82831: LIST
82832: LIST
82833: PUSH
82834: LD_INT 30
82836: PUSH
82837: LD_INT 1
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: LIST
82848: PPUSH
82849: CALL_OW 72
82853: IFFALSE 82863
// pos := 2 ;
82855: LD_ADDR_VAR 0 6
82859: PUSH
82860: LD_INT 2
82862: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
82863: LD_ADDR_VAR 0 7
82867: PUSH
82868: LD_VAR 0 7
82872: PPUSH
82873: LD_VAR 0 6
82877: PPUSH
82878: LD_VAR 0 7
82882: PPUSH
82883: CALL 20116 0 3
82887: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
82888: LD_ADDR_EXP 64
82892: PUSH
82893: LD_EXP 64
82897: PPUSH
82898: LD_VAR 0 3
82902: PPUSH
82903: LD_VAR 0 7
82907: PPUSH
82908: CALL_OW 1
82912: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
82913: LD_VAR 0 1
82917: PUSH
82918: LD_EXP 59
82922: PUSH
82923: LD_VAR 0 3
82927: ARRAY
82928: IN
82929: IFFALSE 82968
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
82931: LD_ADDR_EXP 59
82935: PUSH
82936: LD_EXP 59
82940: PPUSH
82941: LD_VAR 0 3
82945: PPUSH
82946: LD_EXP 59
82950: PUSH
82951: LD_VAR 0 3
82955: ARRAY
82956: PUSH
82957: LD_VAR 0 1
82961: DIFF
82962: PPUSH
82963: CALL_OW 1
82967: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
82968: LD_VAR 0 1
82972: PUSH
82973: LD_EXP 66
82977: PUSH
82978: LD_VAR 0 3
82982: ARRAY
82983: IN
82984: IFFALSE 83023
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
82986: LD_ADDR_EXP 66
82990: PUSH
82991: LD_EXP 66
82995: PPUSH
82996: LD_VAR 0 3
83000: PPUSH
83001: LD_EXP 66
83005: PUSH
83006: LD_VAR 0 3
83010: ARRAY
83011: PUSH
83012: LD_VAR 0 1
83016: DIFF
83017: PPUSH
83018: CALL_OW 1
83022: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83023: LD_VAR 0 1
83027: PUSH
83028: LD_EXP 78
83032: PUSH
83033: LD_VAR 0 3
83037: ARRAY
83038: IN
83039: IFFALSE 83078
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83041: LD_ADDR_EXP 78
83045: PUSH
83046: LD_EXP 78
83050: PPUSH
83051: LD_VAR 0 3
83055: PPUSH
83056: LD_EXP 78
83060: PUSH
83061: LD_VAR 0 3
83065: ARRAY
83066: PUSH
83067: LD_VAR 0 1
83071: DIFF
83072: PPUSH
83073: CALL_OW 1
83077: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83078: LD_VAR 0 1
83082: PUSH
83083: LD_EXP 81
83087: PUSH
83088: LD_VAR 0 3
83092: ARRAY
83093: IN
83094: IFFALSE 83133
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83096: LD_ADDR_EXP 81
83100: PUSH
83101: LD_EXP 81
83105: PPUSH
83106: LD_VAR 0 3
83110: PPUSH
83111: LD_EXP 81
83115: PUSH
83116: LD_VAR 0 3
83120: ARRAY
83121: PUSH
83122: LD_VAR 0 1
83126: DIFF
83127: PPUSH
83128: CALL_OW 1
83132: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83133: LD_VAR 0 1
83137: PUSH
83138: LD_EXP 68
83142: PUSH
83143: LD_VAR 0 3
83147: ARRAY
83148: IN
83149: IFFALSE 83188
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83151: LD_ADDR_EXP 68
83155: PUSH
83156: LD_EXP 68
83160: PPUSH
83161: LD_VAR 0 3
83165: PPUSH
83166: LD_EXP 68
83170: PUSH
83171: LD_VAR 0 3
83175: ARRAY
83176: PUSH
83177: LD_VAR 0 1
83181: DIFF
83182: PPUSH
83183: CALL_OW 1
83187: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83188: LD_VAR 0 1
83192: PUSH
83193: LD_EXP 67
83197: PUSH
83198: LD_VAR 0 3
83202: ARRAY
83203: IN
83204: IFFALSE 83243
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83206: LD_ADDR_EXP 67
83210: PUSH
83211: LD_EXP 67
83215: PPUSH
83216: LD_VAR 0 3
83220: PPUSH
83221: LD_EXP 67
83225: PUSH
83226: LD_VAR 0 3
83230: ARRAY
83231: PUSH
83232: LD_VAR 0 1
83236: DIFF
83237: PPUSH
83238: CALL_OW 1
83242: ST_TO_ADDR
// end ; break ;
83243: GO 83247
// end ;
83245: GO 81893
83247: POP
83248: POP
// end ;
83249: LD_VAR 0 2
83253: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83254: LD_INT 0
83256: PPUSH
83257: PPUSH
83258: PPUSH
// if not mc_bases or not skirmish then
83259: LD_EXP 59
83263: NOT
83264: PUSH
83265: LD_EXP 57
83269: NOT
83270: OR
83271: IFFALSE 83275
// exit ;
83273: GO 83490
// for i = 1 to mc_bases do
83275: LD_ADDR_VAR 0 3
83279: PUSH
83280: DOUBLE
83281: LD_INT 1
83283: DEC
83284: ST_TO_ADDR
83285: LD_EXP 59
83289: PUSH
83290: FOR_TO
83291: IFFALSE 83488
// begin if building in mc_construct_list [ i ] then
83293: LD_VAR 0 1
83297: PUSH
83298: LD_EXP 66
83302: PUSH
83303: LD_VAR 0 3
83307: ARRAY
83308: IN
83309: IFFALSE 83486
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83311: LD_ADDR_EXP 66
83315: PUSH
83316: LD_EXP 66
83320: PPUSH
83321: LD_VAR 0 3
83325: PPUSH
83326: LD_EXP 66
83330: PUSH
83331: LD_VAR 0 3
83335: ARRAY
83336: PUSH
83337: LD_VAR 0 1
83341: DIFF
83342: PPUSH
83343: CALL_OW 1
83347: ST_TO_ADDR
// if building in mc_lab [ i ] then
83348: LD_VAR 0 1
83352: PUSH
83353: LD_EXP 92
83357: PUSH
83358: LD_VAR 0 3
83362: ARRAY
83363: IN
83364: IFFALSE 83419
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83366: LD_ADDR_EXP 93
83370: PUSH
83371: LD_EXP 93
83375: PPUSH
83376: LD_VAR 0 3
83380: PPUSH
83381: LD_EXP 93
83385: PUSH
83386: LD_VAR 0 3
83390: ARRAY
83391: PPUSH
83392: LD_INT 1
83394: PPUSH
83395: LD_EXP 93
83399: PUSH
83400: LD_VAR 0 3
83404: ARRAY
83405: PPUSH
83406: LD_INT 0
83408: PPUSH
83409: CALL 19208 0 4
83413: PPUSH
83414: CALL_OW 1
83418: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83419: LD_VAR 0 1
83423: PUSH
83424: LD_EXP 59
83428: PUSH
83429: LD_VAR 0 3
83433: ARRAY
83434: IN
83435: NOT
83436: IFFALSE 83482
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83438: LD_ADDR_EXP 59
83442: PUSH
83443: LD_EXP 59
83447: PPUSH
83448: LD_VAR 0 3
83452: PUSH
83453: LD_EXP 59
83457: PUSH
83458: LD_VAR 0 3
83462: ARRAY
83463: PUSH
83464: LD_INT 1
83466: PLUS
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PPUSH
83472: LD_VAR 0 1
83476: PPUSH
83477: CALL 19790 0 3
83481: ST_TO_ADDR
// exit ;
83482: POP
83483: POP
83484: GO 83490
// end ; end ;
83486: GO 83290
83488: POP
83489: POP
// end ;
83490: LD_VAR 0 2
83494: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83495: LD_INT 0
83497: PPUSH
83498: PPUSH
83499: PPUSH
83500: PPUSH
83501: PPUSH
83502: PPUSH
83503: PPUSH
// if not mc_bases or not skirmish then
83504: LD_EXP 59
83508: NOT
83509: PUSH
83510: LD_EXP 57
83514: NOT
83515: OR
83516: IFFALSE 83520
// exit ;
83518: GO 84181
// for i = 1 to mc_bases do
83520: LD_ADDR_VAR 0 3
83524: PUSH
83525: DOUBLE
83526: LD_INT 1
83528: DEC
83529: ST_TO_ADDR
83530: LD_EXP 59
83534: PUSH
83535: FOR_TO
83536: IFFALSE 84179
// begin if building in mc_construct_list [ i ] then
83538: LD_VAR 0 1
83542: PUSH
83543: LD_EXP 66
83547: PUSH
83548: LD_VAR 0 3
83552: ARRAY
83553: IN
83554: IFFALSE 84177
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83556: LD_ADDR_EXP 66
83560: PUSH
83561: LD_EXP 66
83565: PPUSH
83566: LD_VAR 0 3
83570: PPUSH
83571: LD_EXP 66
83575: PUSH
83576: LD_VAR 0 3
83580: ARRAY
83581: PUSH
83582: LD_VAR 0 1
83586: DIFF
83587: PPUSH
83588: CALL_OW 1
83592: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83593: LD_ADDR_EXP 59
83597: PUSH
83598: LD_EXP 59
83602: PPUSH
83603: LD_VAR 0 3
83607: PUSH
83608: LD_EXP 59
83612: PUSH
83613: LD_VAR 0 3
83617: ARRAY
83618: PUSH
83619: LD_INT 1
83621: PLUS
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PPUSH
83627: LD_VAR 0 1
83631: PPUSH
83632: CALL 19790 0 3
83636: ST_TO_ADDR
// btype := GetBType ( building ) ;
83637: LD_ADDR_VAR 0 5
83641: PUSH
83642: LD_VAR 0 1
83646: PPUSH
83647: CALL_OW 266
83651: ST_TO_ADDR
// side := GetSide ( building ) ;
83652: LD_ADDR_VAR 0 8
83656: PUSH
83657: LD_VAR 0 1
83661: PPUSH
83662: CALL_OW 255
83666: ST_TO_ADDR
// if btype = b_lab then
83667: LD_VAR 0 5
83671: PUSH
83672: LD_INT 6
83674: EQUAL
83675: IFFALSE 83725
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83677: LD_ADDR_EXP 92
83681: PUSH
83682: LD_EXP 92
83686: PPUSH
83687: LD_VAR 0 3
83691: PUSH
83692: LD_EXP 92
83696: PUSH
83697: LD_VAR 0 3
83701: ARRAY
83702: PUSH
83703: LD_INT 1
83705: PLUS
83706: PUSH
83707: EMPTY
83708: LIST
83709: LIST
83710: PPUSH
83711: LD_VAR 0 1
83715: PPUSH
83716: CALL 19790 0 3
83720: ST_TO_ADDR
// exit ;
83721: POP
83722: POP
83723: GO 84181
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83725: LD_VAR 0 5
83729: PUSH
83730: LD_INT 0
83732: PUSH
83733: LD_INT 2
83735: PUSH
83736: LD_INT 4
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: LIST
83743: IN
83744: IFFALSE 83868
// begin if btype = b_armoury then
83746: LD_VAR 0 5
83750: PUSH
83751: LD_INT 4
83753: EQUAL
83754: IFFALSE 83764
// btype := b_barracks ;
83756: LD_ADDR_VAR 0 5
83760: PUSH
83761: LD_INT 5
83763: ST_TO_ADDR
// if btype = b_depot then
83764: LD_VAR 0 5
83768: PUSH
83769: LD_INT 0
83771: EQUAL
83772: IFFALSE 83782
// btype := b_warehouse ;
83774: LD_ADDR_VAR 0 5
83778: PUSH
83779: LD_INT 1
83781: ST_TO_ADDR
// if btype = b_workshop then
83782: LD_VAR 0 5
83786: PUSH
83787: LD_INT 2
83789: EQUAL
83790: IFFALSE 83800
// btype := b_factory ;
83792: LD_ADDR_VAR 0 5
83796: PUSH
83797: LD_INT 3
83799: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83800: LD_VAR 0 5
83804: PPUSH
83805: LD_VAR 0 8
83809: PPUSH
83810: CALL_OW 323
83814: PUSH
83815: LD_INT 1
83817: EQUAL
83818: IFFALSE 83864
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83820: LD_ADDR_EXP 91
83824: PUSH
83825: LD_EXP 91
83829: PPUSH
83830: LD_VAR 0 3
83834: PUSH
83835: LD_EXP 91
83839: PUSH
83840: LD_VAR 0 3
83844: ARRAY
83845: PUSH
83846: LD_INT 1
83848: PLUS
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: PPUSH
83854: LD_VAR 0 1
83858: PPUSH
83859: CALL 19790 0 3
83863: ST_TO_ADDR
// exit ;
83864: POP
83865: POP
83866: GO 84181
// end ; if btype in [ b_bunker , b_turret ] then
83868: LD_VAR 0 5
83872: PUSH
83873: LD_INT 32
83875: PUSH
83876: LD_INT 33
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: IN
83883: IFFALSE 84173
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
83885: LD_ADDR_EXP 67
83889: PUSH
83890: LD_EXP 67
83894: PPUSH
83895: LD_VAR 0 3
83899: PUSH
83900: LD_EXP 67
83904: PUSH
83905: LD_VAR 0 3
83909: ARRAY
83910: PUSH
83911: LD_INT 1
83913: PLUS
83914: PUSH
83915: EMPTY
83916: LIST
83917: LIST
83918: PPUSH
83919: LD_VAR 0 1
83923: PPUSH
83924: CALL 19790 0 3
83928: ST_TO_ADDR
// if btype = b_bunker then
83929: LD_VAR 0 5
83933: PUSH
83934: LD_INT 32
83936: EQUAL
83937: IFFALSE 84173
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
83939: LD_ADDR_EXP 68
83943: PUSH
83944: LD_EXP 68
83948: PPUSH
83949: LD_VAR 0 3
83953: PUSH
83954: LD_EXP 68
83958: PUSH
83959: LD_VAR 0 3
83963: ARRAY
83964: PUSH
83965: LD_INT 1
83967: PLUS
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PPUSH
83973: LD_VAR 0 1
83977: PPUSH
83978: CALL 19790 0 3
83982: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
83983: LD_ADDR_VAR 0 6
83987: PUSH
83988: LD_EXP 59
83992: PUSH
83993: LD_VAR 0 3
83997: ARRAY
83998: PPUSH
83999: LD_INT 25
84001: PUSH
84002: LD_INT 1
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 3
84011: PUSH
84012: LD_INT 54
84014: PUSH
84015: EMPTY
84016: LIST
84017: PUSH
84018: EMPTY
84019: LIST
84020: LIST
84021: PUSH
84022: EMPTY
84023: LIST
84024: LIST
84025: PPUSH
84026: CALL_OW 72
84030: ST_TO_ADDR
// if tmp then
84031: LD_VAR 0 6
84035: IFFALSE 84041
// exit ;
84037: POP
84038: POP
84039: GO 84181
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84041: LD_ADDR_VAR 0 6
84045: PUSH
84046: LD_EXP 59
84050: PUSH
84051: LD_VAR 0 3
84055: ARRAY
84056: PPUSH
84057: LD_INT 2
84059: PUSH
84060: LD_INT 30
84062: PUSH
84063: LD_INT 4
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 30
84072: PUSH
84073: LD_INT 5
84075: PUSH
84076: EMPTY
84077: LIST
84078: LIST
84079: PUSH
84080: EMPTY
84081: LIST
84082: LIST
84083: LIST
84084: PPUSH
84085: CALL_OW 72
84089: ST_TO_ADDR
// if not tmp then
84090: LD_VAR 0 6
84094: NOT
84095: IFFALSE 84101
// exit ;
84097: POP
84098: POP
84099: GO 84181
// for j in tmp do
84101: LD_ADDR_VAR 0 4
84105: PUSH
84106: LD_VAR 0 6
84110: PUSH
84111: FOR_IN
84112: IFFALSE 84171
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84114: LD_ADDR_VAR 0 7
84118: PUSH
84119: LD_VAR 0 4
84123: PPUSH
84124: CALL_OW 313
84128: PPUSH
84129: LD_INT 25
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PPUSH
84139: CALL_OW 72
84143: ST_TO_ADDR
// if units then
84144: LD_VAR 0 7
84148: IFFALSE 84169
// begin ComExitBuilding ( units [ 1 ] ) ;
84150: LD_VAR 0 7
84154: PUSH
84155: LD_INT 1
84157: ARRAY
84158: PPUSH
84159: CALL_OW 122
// exit ;
84163: POP
84164: POP
84165: POP
84166: POP
84167: GO 84181
// end ; end ;
84169: GO 84111
84171: POP
84172: POP
// end ; end ; exit ;
84173: POP
84174: POP
84175: GO 84181
// end ; end ;
84177: GO 83535
84179: POP
84180: POP
// end ;
84181: LD_VAR 0 2
84185: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84186: LD_INT 0
84188: PPUSH
84189: PPUSH
84190: PPUSH
84191: PPUSH
84192: PPUSH
84193: PPUSH
84194: PPUSH
// if not mc_bases or not skirmish then
84195: LD_EXP 59
84199: NOT
84200: PUSH
84201: LD_EXP 57
84205: NOT
84206: OR
84207: IFFALSE 84211
// exit ;
84209: GO 84476
// btype := GetBType ( building ) ;
84211: LD_ADDR_VAR 0 6
84215: PUSH
84216: LD_VAR 0 1
84220: PPUSH
84221: CALL_OW 266
84225: ST_TO_ADDR
// x := GetX ( building ) ;
84226: LD_ADDR_VAR 0 7
84230: PUSH
84231: LD_VAR 0 1
84235: PPUSH
84236: CALL_OW 250
84240: ST_TO_ADDR
// y := GetY ( building ) ;
84241: LD_ADDR_VAR 0 8
84245: PUSH
84246: LD_VAR 0 1
84250: PPUSH
84251: CALL_OW 251
84255: ST_TO_ADDR
// d := GetDir ( building ) ;
84256: LD_ADDR_VAR 0 9
84260: PUSH
84261: LD_VAR 0 1
84265: PPUSH
84266: CALL_OW 254
84270: ST_TO_ADDR
// for i = 1 to mc_bases do
84271: LD_ADDR_VAR 0 4
84275: PUSH
84276: DOUBLE
84277: LD_INT 1
84279: DEC
84280: ST_TO_ADDR
84281: LD_EXP 59
84285: PUSH
84286: FOR_TO
84287: IFFALSE 84474
// begin if not mc_build_list [ i ] then
84289: LD_EXP 64
84293: PUSH
84294: LD_VAR 0 4
84298: ARRAY
84299: NOT
84300: IFFALSE 84304
// continue ;
84302: GO 84286
// for j := 1 to mc_build_list [ i ] do
84304: LD_ADDR_VAR 0 5
84308: PUSH
84309: DOUBLE
84310: LD_INT 1
84312: DEC
84313: ST_TO_ADDR
84314: LD_EXP 64
84318: PUSH
84319: LD_VAR 0 4
84323: ARRAY
84324: PUSH
84325: FOR_TO
84326: IFFALSE 84470
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
84328: LD_VAR 0 6
84332: PUSH
84333: LD_VAR 0 7
84337: PUSH
84338: LD_VAR 0 8
84342: PUSH
84343: LD_VAR 0 9
84347: PUSH
84348: EMPTY
84349: LIST
84350: LIST
84351: LIST
84352: LIST
84353: PPUSH
84354: LD_EXP 64
84358: PUSH
84359: LD_VAR 0 4
84363: ARRAY
84364: PUSH
84365: LD_VAR 0 5
84369: ARRAY
84370: PPUSH
84371: CALL 25972 0 2
84375: IFFALSE 84468
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84377: LD_ADDR_EXP 64
84381: PUSH
84382: LD_EXP 64
84386: PPUSH
84387: LD_VAR 0 4
84391: PPUSH
84392: LD_EXP 64
84396: PUSH
84397: LD_VAR 0 4
84401: ARRAY
84402: PPUSH
84403: LD_VAR 0 5
84407: PPUSH
84408: CALL_OW 3
84412: PPUSH
84413: CALL_OW 1
84417: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84418: LD_ADDR_EXP 66
84422: PUSH
84423: LD_EXP 66
84427: PPUSH
84428: LD_VAR 0 4
84432: PUSH
84433: LD_EXP 66
84437: PUSH
84438: LD_VAR 0 4
84442: ARRAY
84443: PUSH
84444: LD_INT 1
84446: PLUS
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: PPUSH
84452: LD_VAR 0 1
84456: PPUSH
84457: CALL 19790 0 3
84461: ST_TO_ADDR
// exit ;
84462: POP
84463: POP
84464: POP
84465: POP
84466: GO 84476
// end ;
84468: GO 84325
84470: POP
84471: POP
// end ;
84472: GO 84286
84474: POP
84475: POP
// end ;
84476: LD_VAR 0 3
84480: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84481: LD_INT 0
84483: PPUSH
84484: PPUSH
84485: PPUSH
// if not mc_bases or not skirmish then
84486: LD_EXP 59
84490: NOT
84491: PUSH
84492: LD_EXP 57
84496: NOT
84497: OR
84498: IFFALSE 84502
// exit ;
84500: GO 84692
// for i = 1 to mc_bases do
84502: LD_ADDR_VAR 0 4
84506: PUSH
84507: DOUBLE
84508: LD_INT 1
84510: DEC
84511: ST_TO_ADDR
84512: LD_EXP 59
84516: PUSH
84517: FOR_TO
84518: IFFALSE 84605
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84520: LD_VAR 0 1
84524: PUSH
84525: LD_EXP 67
84529: PUSH
84530: LD_VAR 0 4
84534: ARRAY
84535: IN
84536: PUSH
84537: LD_VAR 0 1
84541: PUSH
84542: LD_EXP 68
84546: PUSH
84547: LD_VAR 0 4
84551: ARRAY
84552: IN
84553: NOT
84554: AND
84555: IFFALSE 84603
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84557: LD_ADDR_EXP 68
84561: PUSH
84562: LD_EXP 68
84566: PPUSH
84567: LD_VAR 0 4
84571: PUSH
84572: LD_EXP 68
84576: PUSH
84577: LD_VAR 0 4
84581: ARRAY
84582: PUSH
84583: LD_INT 1
84585: PLUS
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PPUSH
84591: LD_VAR 0 1
84595: PPUSH
84596: CALL 19790 0 3
84600: ST_TO_ADDR
// break ;
84601: GO 84605
// end ; end ;
84603: GO 84517
84605: POP
84606: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84607: LD_VAR 0 1
84611: PPUSH
84612: CALL_OW 257
84616: PUSH
84617: LD_EXP 85
84621: IN
84622: PUSH
84623: LD_VAR 0 1
84627: PPUSH
84628: CALL_OW 266
84632: PUSH
84633: LD_INT 5
84635: EQUAL
84636: AND
84637: PUSH
84638: LD_VAR 0 2
84642: PPUSH
84643: CALL_OW 110
84647: PUSH
84648: LD_INT 18
84650: NONEQUAL
84651: AND
84652: IFFALSE 84692
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84654: LD_VAR 0 2
84658: PPUSH
84659: CALL_OW 257
84663: PUSH
84664: LD_INT 5
84666: PUSH
84667: LD_INT 8
84669: PUSH
84670: LD_INT 9
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: LIST
84677: IN
84678: IFFALSE 84692
// SetClass ( unit , 1 ) ;
84680: LD_VAR 0 2
84684: PPUSH
84685: LD_INT 1
84687: PPUSH
84688: CALL_OW 336
// end ;
84692: LD_VAR 0 3
84696: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84697: LD_INT 0
84699: PPUSH
84700: PPUSH
// if not mc_bases or not skirmish then
84701: LD_EXP 59
84705: NOT
84706: PUSH
84707: LD_EXP 57
84711: NOT
84712: OR
84713: IFFALSE 84717
// exit ;
84715: GO 84833
// if GetLives ( abandoned_vehicle ) > 250 then
84717: LD_VAR 0 2
84721: PPUSH
84722: CALL_OW 256
84726: PUSH
84727: LD_INT 250
84729: GREATER
84730: IFFALSE 84734
// exit ;
84732: GO 84833
// for i = 1 to mc_bases do
84734: LD_ADDR_VAR 0 6
84738: PUSH
84739: DOUBLE
84740: LD_INT 1
84742: DEC
84743: ST_TO_ADDR
84744: LD_EXP 59
84748: PUSH
84749: FOR_TO
84750: IFFALSE 84831
// begin if driver in mc_bases [ i ] then
84752: LD_VAR 0 1
84756: PUSH
84757: LD_EXP 59
84761: PUSH
84762: LD_VAR 0 6
84766: ARRAY
84767: IN
84768: IFFALSE 84829
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84770: LD_VAR 0 1
84774: PPUSH
84775: LD_EXP 59
84779: PUSH
84780: LD_VAR 0 6
84784: ARRAY
84785: PPUSH
84786: LD_INT 2
84788: PUSH
84789: LD_INT 30
84791: PUSH
84792: LD_INT 0
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 30
84801: PUSH
84802: LD_INT 1
84804: PUSH
84805: EMPTY
84806: LIST
84807: LIST
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: LIST
84813: PPUSH
84814: CALL_OW 72
84818: PUSH
84819: LD_INT 1
84821: ARRAY
84822: PPUSH
84823: CALL 52408 0 2
// break ;
84827: GO 84831
// end ; end ;
84829: GO 84749
84831: POP
84832: POP
// end ; end_of_file
84833: LD_VAR 0 5
84837: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
84838: LD_INT 0
84840: PPUSH
// ar_miner := 81 ;
84841: LD_ADDR_EXP 110
84845: PUSH
84846: LD_INT 81
84848: ST_TO_ADDR
// ar_crane := 88 ;
84849: LD_ADDR_EXP 109
84853: PUSH
84854: LD_INT 88
84856: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84857: LD_ADDR_EXP 104
84861: PUSH
84862: LD_INT 89
84864: ST_TO_ADDR
// us_hack := 99 ;
84865: LD_ADDR_EXP 105
84869: PUSH
84870: LD_INT 99
84872: ST_TO_ADDR
// us_artillery := 97 ;
84873: LD_ADDR_EXP 106
84877: PUSH
84878: LD_INT 97
84880: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84881: LD_ADDR_EXP 107
84885: PUSH
84886: LD_INT 91
84888: ST_TO_ADDR
// ar_mortar := 92 ;
84889: LD_ADDR_EXP 108
84893: PUSH
84894: LD_INT 92
84896: ST_TO_ADDR
// ru_radar := 98 ;
84897: LD_ADDR_EXP 103
84901: PUSH
84902: LD_INT 98
84904: ST_TO_ADDR
// tech_Artillery := 80 ;
84905: LD_ADDR_EXP 111
84909: PUSH
84910: LD_INT 80
84912: ST_TO_ADDR
// tech_RadMat := 81 ;
84913: LD_ADDR_EXP 112
84917: PUSH
84918: LD_INT 81
84920: ST_TO_ADDR
// tech_BasicTools := 82 ;
84921: LD_ADDR_EXP 113
84925: PUSH
84926: LD_INT 82
84928: ST_TO_ADDR
// tech_Cargo := 83 ;
84929: LD_ADDR_EXP 114
84933: PUSH
84934: LD_INT 83
84936: ST_TO_ADDR
// tech_Track := 84 ;
84937: LD_ADDR_EXP 115
84941: PUSH
84942: LD_INT 84
84944: ST_TO_ADDR
// tech_Crane := 85 ;
84945: LD_ADDR_EXP 116
84949: PUSH
84950: LD_INT 85
84952: ST_TO_ADDR
// tech_Bulldozer := 86 ;
84953: LD_ADDR_EXP 117
84957: PUSH
84958: LD_INT 86
84960: ST_TO_ADDR
// tech_Hovercraft := 87 ;
84961: LD_ADDR_EXP 118
84965: PUSH
84966: LD_INT 87
84968: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
84969: LD_ADDR_EXP 119
84973: PUSH
84974: LD_INT 88
84976: ST_TO_ADDR
// class_mastodont := 31 ;
84977: LD_ADDR_EXP 120
84981: PUSH
84982: LD_INT 31
84984: ST_TO_ADDR
// class_horse := 21 ;
84985: LD_ADDR_EXP 121
84989: PUSH
84990: LD_INT 21
84992: ST_TO_ADDR
// end ;
84993: LD_VAR 0 1
84997: RET
// every 1 do
84998: GO 85000
85000: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85001: CALL 84838 0 0
85005: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85006: LD_INT 0
85008: PPUSH
// if p2 = 100 then
85009: LD_VAR 0 2
85013: PUSH
85014: LD_INT 100
85016: EQUAL
85017: IFFALSE 85966
// begin if not StreamModeActive then
85019: LD_EXP 122
85023: NOT
85024: IFFALSE 85034
// StreamModeActive := true ;
85026: LD_ADDR_EXP 122
85030: PUSH
85031: LD_INT 1
85033: ST_TO_ADDR
// if p3 = 0 then
85034: LD_VAR 0 3
85038: PUSH
85039: LD_INT 0
85041: EQUAL
85042: IFFALSE 85048
// InitStreamMode ;
85044: CALL 86126 0 0
// if p3 = 1 then
85048: LD_VAR 0 3
85052: PUSH
85053: LD_INT 1
85055: EQUAL
85056: IFFALSE 85066
// sRocket := true ;
85058: LD_ADDR_EXP 127
85062: PUSH
85063: LD_INT 1
85065: ST_TO_ADDR
// if p3 = 2 then
85066: LD_VAR 0 3
85070: PUSH
85071: LD_INT 2
85073: EQUAL
85074: IFFALSE 85084
// sSpeed := true ;
85076: LD_ADDR_EXP 126
85080: PUSH
85081: LD_INT 1
85083: ST_TO_ADDR
// if p3 = 3 then
85084: LD_VAR 0 3
85088: PUSH
85089: LD_INT 3
85091: EQUAL
85092: IFFALSE 85102
// sEngine := true ;
85094: LD_ADDR_EXP 128
85098: PUSH
85099: LD_INT 1
85101: ST_TO_ADDR
// if p3 = 4 then
85102: LD_VAR 0 3
85106: PUSH
85107: LD_INT 4
85109: EQUAL
85110: IFFALSE 85120
// sSpec := true ;
85112: LD_ADDR_EXP 125
85116: PUSH
85117: LD_INT 1
85119: ST_TO_ADDR
// if p3 = 5 then
85120: LD_VAR 0 3
85124: PUSH
85125: LD_INT 5
85127: EQUAL
85128: IFFALSE 85138
// sLevel := true ;
85130: LD_ADDR_EXP 129
85134: PUSH
85135: LD_INT 1
85137: ST_TO_ADDR
// if p3 = 6 then
85138: LD_VAR 0 3
85142: PUSH
85143: LD_INT 6
85145: EQUAL
85146: IFFALSE 85156
// sArmoury := true ;
85148: LD_ADDR_EXP 130
85152: PUSH
85153: LD_INT 1
85155: ST_TO_ADDR
// if p3 = 7 then
85156: LD_VAR 0 3
85160: PUSH
85161: LD_INT 7
85163: EQUAL
85164: IFFALSE 85174
// sRadar := true ;
85166: LD_ADDR_EXP 131
85170: PUSH
85171: LD_INT 1
85173: ST_TO_ADDR
// if p3 = 8 then
85174: LD_VAR 0 3
85178: PUSH
85179: LD_INT 8
85181: EQUAL
85182: IFFALSE 85192
// sBunker := true ;
85184: LD_ADDR_EXP 132
85188: PUSH
85189: LD_INT 1
85191: ST_TO_ADDR
// if p3 = 9 then
85192: LD_VAR 0 3
85196: PUSH
85197: LD_INT 9
85199: EQUAL
85200: IFFALSE 85210
// sHack := true ;
85202: LD_ADDR_EXP 133
85206: PUSH
85207: LD_INT 1
85209: ST_TO_ADDR
// if p3 = 10 then
85210: LD_VAR 0 3
85214: PUSH
85215: LD_INT 10
85217: EQUAL
85218: IFFALSE 85228
// sFire := true ;
85220: LD_ADDR_EXP 134
85224: PUSH
85225: LD_INT 1
85227: ST_TO_ADDR
// if p3 = 11 then
85228: LD_VAR 0 3
85232: PUSH
85233: LD_INT 11
85235: EQUAL
85236: IFFALSE 85246
// sRefresh := true ;
85238: LD_ADDR_EXP 135
85242: PUSH
85243: LD_INT 1
85245: ST_TO_ADDR
// if p3 = 12 then
85246: LD_VAR 0 3
85250: PUSH
85251: LD_INT 12
85253: EQUAL
85254: IFFALSE 85264
// sExp := true ;
85256: LD_ADDR_EXP 136
85260: PUSH
85261: LD_INT 1
85263: ST_TO_ADDR
// if p3 = 13 then
85264: LD_VAR 0 3
85268: PUSH
85269: LD_INT 13
85271: EQUAL
85272: IFFALSE 85282
// sDepot := true ;
85274: LD_ADDR_EXP 137
85278: PUSH
85279: LD_INT 1
85281: ST_TO_ADDR
// if p3 = 14 then
85282: LD_VAR 0 3
85286: PUSH
85287: LD_INT 14
85289: EQUAL
85290: IFFALSE 85300
// sFlag := true ;
85292: LD_ADDR_EXP 138
85296: PUSH
85297: LD_INT 1
85299: ST_TO_ADDR
// if p3 = 15 then
85300: LD_VAR 0 3
85304: PUSH
85305: LD_INT 15
85307: EQUAL
85308: IFFALSE 85318
// sKamikadze := true ;
85310: LD_ADDR_EXP 146
85314: PUSH
85315: LD_INT 1
85317: ST_TO_ADDR
// if p3 = 16 then
85318: LD_VAR 0 3
85322: PUSH
85323: LD_INT 16
85325: EQUAL
85326: IFFALSE 85336
// sTroll := true ;
85328: LD_ADDR_EXP 147
85332: PUSH
85333: LD_INT 1
85335: ST_TO_ADDR
// if p3 = 17 then
85336: LD_VAR 0 3
85340: PUSH
85341: LD_INT 17
85343: EQUAL
85344: IFFALSE 85354
// sSlow := true ;
85346: LD_ADDR_EXP 148
85350: PUSH
85351: LD_INT 1
85353: ST_TO_ADDR
// if p3 = 18 then
85354: LD_VAR 0 3
85358: PUSH
85359: LD_INT 18
85361: EQUAL
85362: IFFALSE 85372
// sLack := true ;
85364: LD_ADDR_EXP 149
85368: PUSH
85369: LD_INT 1
85371: ST_TO_ADDR
// if p3 = 19 then
85372: LD_VAR 0 3
85376: PUSH
85377: LD_INT 19
85379: EQUAL
85380: IFFALSE 85390
// sTank := true ;
85382: LD_ADDR_EXP 151
85386: PUSH
85387: LD_INT 1
85389: ST_TO_ADDR
// if p3 = 20 then
85390: LD_VAR 0 3
85394: PUSH
85395: LD_INT 20
85397: EQUAL
85398: IFFALSE 85408
// sRemote := true ;
85400: LD_ADDR_EXP 152
85404: PUSH
85405: LD_INT 1
85407: ST_TO_ADDR
// if p3 = 21 then
85408: LD_VAR 0 3
85412: PUSH
85413: LD_INT 21
85415: EQUAL
85416: IFFALSE 85426
// sPowell := true ;
85418: LD_ADDR_EXP 153
85422: PUSH
85423: LD_INT 1
85425: ST_TO_ADDR
// if p3 = 22 then
85426: LD_VAR 0 3
85430: PUSH
85431: LD_INT 22
85433: EQUAL
85434: IFFALSE 85444
// sTeleport := true ;
85436: LD_ADDR_EXP 156
85440: PUSH
85441: LD_INT 1
85443: ST_TO_ADDR
// if p3 = 23 then
85444: LD_VAR 0 3
85448: PUSH
85449: LD_INT 23
85451: EQUAL
85452: IFFALSE 85462
// sOilTower := true ;
85454: LD_ADDR_EXP 158
85458: PUSH
85459: LD_INT 1
85461: ST_TO_ADDR
// if p3 = 24 then
85462: LD_VAR 0 3
85466: PUSH
85467: LD_INT 24
85469: EQUAL
85470: IFFALSE 85480
// sShovel := true ;
85472: LD_ADDR_EXP 159
85476: PUSH
85477: LD_INT 1
85479: ST_TO_ADDR
// if p3 = 25 then
85480: LD_VAR 0 3
85484: PUSH
85485: LD_INT 25
85487: EQUAL
85488: IFFALSE 85498
// sSheik := true ;
85490: LD_ADDR_EXP 160
85494: PUSH
85495: LD_INT 1
85497: ST_TO_ADDR
// if p3 = 26 then
85498: LD_VAR 0 3
85502: PUSH
85503: LD_INT 26
85505: EQUAL
85506: IFFALSE 85516
// sEarthquake := true ;
85508: LD_ADDR_EXP 162
85512: PUSH
85513: LD_INT 1
85515: ST_TO_ADDR
// if p3 = 27 then
85516: LD_VAR 0 3
85520: PUSH
85521: LD_INT 27
85523: EQUAL
85524: IFFALSE 85534
// sAI := true ;
85526: LD_ADDR_EXP 163
85530: PUSH
85531: LD_INT 1
85533: ST_TO_ADDR
// if p3 = 28 then
85534: LD_VAR 0 3
85538: PUSH
85539: LD_INT 28
85541: EQUAL
85542: IFFALSE 85552
// sCargo := true ;
85544: LD_ADDR_EXP 166
85548: PUSH
85549: LD_INT 1
85551: ST_TO_ADDR
// if p3 = 29 then
85552: LD_VAR 0 3
85556: PUSH
85557: LD_INT 29
85559: EQUAL
85560: IFFALSE 85570
// sDLaser := true ;
85562: LD_ADDR_EXP 167
85566: PUSH
85567: LD_INT 1
85569: ST_TO_ADDR
// if p3 = 30 then
85570: LD_VAR 0 3
85574: PUSH
85575: LD_INT 30
85577: EQUAL
85578: IFFALSE 85588
// sExchange := true ;
85580: LD_ADDR_EXP 168
85584: PUSH
85585: LD_INT 1
85587: ST_TO_ADDR
// if p3 = 31 then
85588: LD_VAR 0 3
85592: PUSH
85593: LD_INT 31
85595: EQUAL
85596: IFFALSE 85606
// sFac := true ;
85598: LD_ADDR_EXP 169
85602: PUSH
85603: LD_INT 1
85605: ST_TO_ADDR
// if p3 = 32 then
85606: LD_VAR 0 3
85610: PUSH
85611: LD_INT 32
85613: EQUAL
85614: IFFALSE 85624
// sPower := true ;
85616: LD_ADDR_EXP 170
85620: PUSH
85621: LD_INT 1
85623: ST_TO_ADDR
// if p3 = 33 then
85624: LD_VAR 0 3
85628: PUSH
85629: LD_INT 33
85631: EQUAL
85632: IFFALSE 85642
// sRandom := true ;
85634: LD_ADDR_EXP 171
85638: PUSH
85639: LD_INT 1
85641: ST_TO_ADDR
// if p3 = 34 then
85642: LD_VAR 0 3
85646: PUSH
85647: LD_INT 34
85649: EQUAL
85650: IFFALSE 85660
// sShield := true ;
85652: LD_ADDR_EXP 172
85656: PUSH
85657: LD_INT 1
85659: ST_TO_ADDR
// if p3 = 35 then
85660: LD_VAR 0 3
85664: PUSH
85665: LD_INT 35
85667: EQUAL
85668: IFFALSE 85678
// sTime := true ;
85670: LD_ADDR_EXP 173
85674: PUSH
85675: LD_INT 1
85677: ST_TO_ADDR
// if p3 = 36 then
85678: LD_VAR 0 3
85682: PUSH
85683: LD_INT 36
85685: EQUAL
85686: IFFALSE 85696
// sTools := true ;
85688: LD_ADDR_EXP 174
85692: PUSH
85693: LD_INT 1
85695: ST_TO_ADDR
// if p3 = 101 then
85696: LD_VAR 0 3
85700: PUSH
85701: LD_INT 101
85703: EQUAL
85704: IFFALSE 85714
// sSold := true ;
85706: LD_ADDR_EXP 139
85710: PUSH
85711: LD_INT 1
85713: ST_TO_ADDR
// if p3 = 102 then
85714: LD_VAR 0 3
85718: PUSH
85719: LD_INT 102
85721: EQUAL
85722: IFFALSE 85732
// sDiff := true ;
85724: LD_ADDR_EXP 140
85728: PUSH
85729: LD_INT 1
85731: ST_TO_ADDR
// if p3 = 103 then
85732: LD_VAR 0 3
85736: PUSH
85737: LD_INT 103
85739: EQUAL
85740: IFFALSE 85750
// sFog := true ;
85742: LD_ADDR_EXP 143
85746: PUSH
85747: LD_INT 1
85749: ST_TO_ADDR
// if p3 = 104 then
85750: LD_VAR 0 3
85754: PUSH
85755: LD_INT 104
85757: EQUAL
85758: IFFALSE 85768
// sReset := true ;
85760: LD_ADDR_EXP 144
85764: PUSH
85765: LD_INT 1
85767: ST_TO_ADDR
// if p3 = 105 then
85768: LD_VAR 0 3
85772: PUSH
85773: LD_INT 105
85775: EQUAL
85776: IFFALSE 85786
// sSun := true ;
85778: LD_ADDR_EXP 145
85782: PUSH
85783: LD_INT 1
85785: ST_TO_ADDR
// if p3 = 106 then
85786: LD_VAR 0 3
85790: PUSH
85791: LD_INT 106
85793: EQUAL
85794: IFFALSE 85804
// sTiger := true ;
85796: LD_ADDR_EXP 141
85800: PUSH
85801: LD_INT 1
85803: ST_TO_ADDR
// if p3 = 107 then
85804: LD_VAR 0 3
85808: PUSH
85809: LD_INT 107
85811: EQUAL
85812: IFFALSE 85822
// sBomb := true ;
85814: LD_ADDR_EXP 142
85818: PUSH
85819: LD_INT 1
85821: ST_TO_ADDR
// if p3 = 108 then
85822: LD_VAR 0 3
85826: PUSH
85827: LD_INT 108
85829: EQUAL
85830: IFFALSE 85840
// sWound := true ;
85832: LD_ADDR_EXP 150
85836: PUSH
85837: LD_INT 1
85839: ST_TO_ADDR
// if p3 = 109 then
85840: LD_VAR 0 3
85844: PUSH
85845: LD_INT 109
85847: EQUAL
85848: IFFALSE 85858
// sBetray := true ;
85850: LD_ADDR_EXP 154
85854: PUSH
85855: LD_INT 1
85857: ST_TO_ADDR
// if p3 = 110 then
85858: LD_VAR 0 3
85862: PUSH
85863: LD_INT 110
85865: EQUAL
85866: IFFALSE 85876
// sContamin := true ;
85868: LD_ADDR_EXP 155
85872: PUSH
85873: LD_INT 1
85875: ST_TO_ADDR
// if p3 = 111 then
85876: LD_VAR 0 3
85880: PUSH
85881: LD_INT 111
85883: EQUAL
85884: IFFALSE 85894
// sOil := true ;
85886: LD_ADDR_EXP 157
85890: PUSH
85891: LD_INT 1
85893: ST_TO_ADDR
// if p3 = 112 then
85894: LD_VAR 0 3
85898: PUSH
85899: LD_INT 112
85901: EQUAL
85902: IFFALSE 85912
// sStu := true ;
85904: LD_ADDR_EXP 161
85908: PUSH
85909: LD_INT 1
85911: ST_TO_ADDR
// if p3 = 113 then
85912: LD_VAR 0 3
85916: PUSH
85917: LD_INT 113
85919: EQUAL
85920: IFFALSE 85930
// sBazooka := true ;
85922: LD_ADDR_EXP 164
85926: PUSH
85927: LD_INT 1
85929: ST_TO_ADDR
// if p3 = 114 then
85930: LD_VAR 0 3
85934: PUSH
85935: LD_INT 114
85937: EQUAL
85938: IFFALSE 85948
// sMortar := true ;
85940: LD_ADDR_EXP 165
85944: PUSH
85945: LD_INT 1
85947: ST_TO_ADDR
// if p3 = 115 then
85948: LD_VAR 0 3
85952: PUSH
85953: LD_INT 115
85955: EQUAL
85956: IFFALSE 85966
// sRanger := true ;
85958: LD_ADDR_EXP 175
85962: PUSH
85963: LD_INT 1
85965: ST_TO_ADDR
// end ; if p2 = 101 then
85966: LD_VAR 0 2
85970: PUSH
85971: LD_INT 101
85973: EQUAL
85974: IFFALSE 86102
// begin case p3 of 1 :
85976: LD_VAR 0 3
85980: PUSH
85981: LD_INT 1
85983: DOUBLE
85984: EQUAL
85985: IFTRUE 85989
85987: GO 85996
85989: POP
// hHackUnlimitedResources ; 2 :
85990: CALL 97139 0 0
85994: GO 86102
85996: LD_INT 2
85998: DOUBLE
85999: EQUAL
86000: IFTRUE 86004
86002: GO 86011
86004: POP
// hHackSetLevel10 ; 3 :
86005: CALL 97272 0 0
86009: GO 86102
86011: LD_INT 3
86013: DOUBLE
86014: EQUAL
86015: IFTRUE 86019
86017: GO 86026
86019: POP
// hHackSetLevel10YourUnits ; 4 :
86020: CALL 97357 0 0
86024: GO 86102
86026: LD_INT 4
86028: DOUBLE
86029: EQUAL
86030: IFTRUE 86034
86032: GO 86041
86034: POP
// hHackInvincible ; 5 :
86035: CALL 97805 0 0
86039: GO 86102
86041: LD_INT 5
86043: DOUBLE
86044: EQUAL
86045: IFTRUE 86049
86047: GO 86056
86049: POP
// hHackInvisible ; 6 :
86050: CALL 97916 0 0
86054: GO 86102
86056: LD_INT 6
86058: DOUBLE
86059: EQUAL
86060: IFTRUE 86064
86062: GO 86071
86064: POP
// hHackChangeYourSide ; 7 :
86065: CALL 97973 0 0
86069: GO 86102
86071: LD_INT 7
86073: DOUBLE
86074: EQUAL
86075: IFTRUE 86079
86077: GO 86086
86079: POP
// hHackChangeUnitSide ; 8 :
86080: CALL 98015 0 0
86084: GO 86102
86086: LD_INT 8
86088: DOUBLE
86089: EQUAL
86090: IFTRUE 86094
86092: GO 86101
86094: POP
// hHackFog ; end ;
86095: CALL 98116 0 0
86099: GO 86102
86101: POP
// end ; end ;
86102: LD_VAR 0 7
86106: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
86107: GO 86109
86109: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86110: LD_STRING initStreamRollete();
86112: PPUSH
86113: CALL_OW 559
// InitStreamMode ;
86117: CALL 86126 0 0
// DefineStreamItems ( ) ;
86121: CALL 86566 0 0
// end ;
86125: END
// function InitStreamMode ; begin
86126: LD_INT 0
86128: PPUSH
// streamModeActive := false ;
86129: LD_ADDR_EXP 122
86133: PUSH
86134: LD_INT 0
86136: ST_TO_ADDR
// normalCounter := 36 ;
86137: LD_ADDR_EXP 123
86141: PUSH
86142: LD_INT 36
86144: ST_TO_ADDR
// hardcoreCounter := 16 ;
86145: LD_ADDR_EXP 124
86149: PUSH
86150: LD_INT 16
86152: ST_TO_ADDR
// sRocket := false ;
86153: LD_ADDR_EXP 127
86157: PUSH
86158: LD_INT 0
86160: ST_TO_ADDR
// sSpeed := false ;
86161: LD_ADDR_EXP 126
86165: PUSH
86166: LD_INT 0
86168: ST_TO_ADDR
// sEngine := false ;
86169: LD_ADDR_EXP 128
86173: PUSH
86174: LD_INT 0
86176: ST_TO_ADDR
// sSpec := false ;
86177: LD_ADDR_EXP 125
86181: PUSH
86182: LD_INT 0
86184: ST_TO_ADDR
// sLevel := false ;
86185: LD_ADDR_EXP 129
86189: PUSH
86190: LD_INT 0
86192: ST_TO_ADDR
// sArmoury := false ;
86193: LD_ADDR_EXP 130
86197: PUSH
86198: LD_INT 0
86200: ST_TO_ADDR
// sRadar := false ;
86201: LD_ADDR_EXP 131
86205: PUSH
86206: LD_INT 0
86208: ST_TO_ADDR
// sBunker := false ;
86209: LD_ADDR_EXP 132
86213: PUSH
86214: LD_INT 0
86216: ST_TO_ADDR
// sHack := false ;
86217: LD_ADDR_EXP 133
86221: PUSH
86222: LD_INT 0
86224: ST_TO_ADDR
// sFire := false ;
86225: LD_ADDR_EXP 134
86229: PUSH
86230: LD_INT 0
86232: ST_TO_ADDR
// sRefresh := false ;
86233: LD_ADDR_EXP 135
86237: PUSH
86238: LD_INT 0
86240: ST_TO_ADDR
// sExp := false ;
86241: LD_ADDR_EXP 136
86245: PUSH
86246: LD_INT 0
86248: ST_TO_ADDR
// sDepot := false ;
86249: LD_ADDR_EXP 137
86253: PUSH
86254: LD_INT 0
86256: ST_TO_ADDR
// sFlag := false ;
86257: LD_ADDR_EXP 138
86261: PUSH
86262: LD_INT 0
86264: ST_TO_ADDR
// sKamikadze := false ;
86265: LD_ADDR_EXP 146
86269: PUSH
86270: LD_INT 0
86272: ST_TO_ADDR
// sTroll := false ;
86273: LD_ADDR_EXP 147
86277: PUSH
86278: LD_INT 0
86280: ST_TO_ADDR
// sSlow := false ;
86281: LD_ADDR_EXP 148
86285: PUSH
86286: LD_INT 0
86288: ST_TO_ADDR
// sLack := false ;
86289: LD_ADDR_EXP 149
86293: PUSH
86294: LD_INT 0
86296: ST_TO_ADDR
// sTank := false ;
86297: LD_ADDR_EXP 151
86301: PUSH
86302: LD_INT 0
86304: ST_TO_ADDR
// sRemote := false ;
86305: LD_ADDR_EXP 152
86309: PUSH
86310: LD_INT 0
86312: ST_TO_ADDR
// sPowell := false ;
86313: LD_ADDR_EXP 153
86317: PUSH
86318: LD_INT 0
86320: ST_TO_ADDR
// sTeleport := false ;
86321: LD_ADDR_EXP 156
86325: PUSH
86326: LD_INT 0
86328: ST_TO_ADDR
// sOilTower := false ;
86329: LD_ADDR_EXP 158
86333: PUSH
86334: LD_INT 0
86336: ST_TO_ADDR
// sShovel := false ;
86337: LD_ADDR_EXP 159
86341: PUSH
86342: LD_INT 0
86344: ST_TO_ADDR
// sSheik := false ;
86345: LD_ADDR_EXP 160
86349: PUSH
86350: LD_INT 0
86352: ST_TO_ADDR
// sEarthquake := false ;
86353: LD_ADDR_EXP 162
86357: PUSH
86358: LD_INT 0
86360: ST_TO_ADDR
// sAI := false ;
86361: LD_ADDR_EXP 163
86365: PUSH
86366: LD_INT 0
86368: ST_TO_ADDR
// sCargo := false ;
86369: LD_ADDR_EXP 166
86373: PUSH
86374: LD_INT 0
86376: ST_TO_ADDR
// sDLaser := false ;
86377: LD_ADDR_EXP 167
86381: PUSH
86382: LD_INT 0
86384: ST_TO_ADDR
// sExchange := false ;
86385: LD_ADDR_EXP 168
86389: PUSH
86390: LD_INT 0
86392: ST_TO_ADDR
// sFac := false ;
86393: LD_ADDR_EXP 169
86397: PUSH
86398: LD_INT 0
86400: ST_TO_ADDR
// sPower := false ;
86401: LD_ADDR_EXP 170
86405: PUSH
86406: LD_INT 0
86408: ST_TO_ADDR
// sRandom := false ;
86409: LD_ADDR_EXP 171
86413: PUSH
86414: LD_INT 0
86416: ST_TO_ADDR
// sShield := false ;
86417: LD_ADDR_EXP 172
86421: PUSH
86422: LD_INT 0
86424: ST_TO_ADDR
// sTime := false ;
86425: LD_ADDR_EXP 173
86429: PUSH
86430: LD_INT 0
86432: ST_TO_ADDR
// sTools := false ;
86433: LD_ADDR_EXP 174
86437: PUSH
86438: LD_INT 0
86440: ST_TO_ADDR
// sSold := false ;
86441: LD_ADDR_EXP 139
86445: PUSH
86446: LD_INT 0
86448: ST_TO_ADDR
// sDiff := false ;
86449: LD_ADDR_EXP 140
86453: PUSH
86454: LD_INT 0
86456: ST_TO_ADDR
// sFog := false ;
86457: LD_ADDR_EXP 143
86461: PUSH
86462: LD_INT 0
86464: ST_TO_ADDR
// sReset := false ;
86465: LD_ADDR_EXP 144
86469: PUSH
86470: LD_INT 0
86472: ST_TO_ADDR
// sSun := false ;
86473: LD_ADDR_EXP 145
86477: PUSH
86478: LD_INT 0
86480: ST_TO_ADDR
// sTiger := false ;
86481: LD_ADDR_EXP 141
86485: PUSH
86486: LD_INT 0
86488: ST_TO_ADDR
// sBomb := false ;
86489: LD_ADDR_EXP 142
86493: PUSH
86494: LD_INT 0
86496: ST_TO_ADDR
// sWound := false ;
86497: LD_ADDR_EXP 150
86501: PUSH
86502: LD_INT 0
86504: ST_TO_ADDR
// sBetray := false ;
86505: LD_ADDR_EXP 154
86509: PUSH
86510: LD_INT 0
86512: ST_TO_ADDR
// sContamin := false ;
86513: LD_ADDR_EXP 155
86517: PUSH
86518: LD_INT 0
86520: ST_TO_ADDR
// sOil := false ;
86521: LD_ADDR_EXP 157
86525: PUSH
86526: LD_INT 0
86528: ST_TO_ADDR
// sStu := false ;
86529: LD_ADDR_EXP 161
86533: PUSH
86534: LD_INT 0
86536: ST_TO_ADDR
// sBazooka := false ;
86537: LD_ADDR_EXP 164
86541: PUSH
86542: LD_INT 0
86544: ST_TO_ADDR
// sMortar := false ;
86545: LD_ADDR_EXP 165
86549: PUSH
86550: LD_INT 0
86552: ST_TO_ADDR
// sRanger := false ;
86553: LD_ADDR_EXP 175
86557: PUSH
86558: LD_INT 0
86560: ST_TO_ADDR
// end ;
86561: LD_VAR 0 1
86565: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86566: LD_INT 0
86568: PPUSH
86569: PPUSH
86570: PPUSH
86571: PPUSH
86572: PPUSH
// result := [ ] ;
86573: LD_ADDR_VAR 0 1
86577: PUSH
86578: EMPTY
86579: ST_TO_ADDR
// if campaign_id = 1 then
86580: LD_OWVAR 69
86584: PUSH
86585: LD_INT 1
86587: EQUAL
86588: IFFALSE 89526
// begin case mission_number of 1 :
86590: LD_OWVAR 70
86594: PUSH
86595: LD_INT 1
86597: DOUBLE
86598: EQUAL
86599: IFTRUE 86603
86601: GO 86667
86603: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
86604: LD_ADDR_VAR 0 1
86608: PUSH
86609: LD_INT 2
86611: PUSH
86612: LD_INT 4
86614: PUSH
86615: LD_INT 11
86617: PUSH
86618: LD_INT 12
86620: PUSH
86621: LD_INT 15
86623: PUSH
86624: LD_INT 16
86626: PUSH
86627: LD_INT 22
86629: PUSH
86630: LD_INT 23
86632: PUSH
86633: LD_INT 26
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: LIST
86640: LIST
86641: LIST
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: PUSH
86647: LD_INT 101
86649: PUSH
86650: LD_INT 102
86652: PUSH
86653: LD_INT 106
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: LIST
86660: PUSH
86661: EMPTY
86662: LIST
86663: LIST
86664: ST_TO_ADDR
86665: GO 89524
86667: LD_INT 2
86669: DOUBLE
86670: EQUAL
86671: IFTRUE 86675
86673: GO 86747
86675: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
86676: LD_ADDR_VAR 0 1
86680: PUSH
86681: LD_INT 2
86683: PUSH
86684: LD_INT 4
86686: PUSH
86687: LD_INT 11
86689: PUSH
86690: LD_INT 12
86692: PUSH
86693: LD_INT 15
86695: PUSH
86696: LD_INT 16
86698: PUSH
86699: LD_INT 22
86701: PUSH
86702: LD_INT 23
86704: PUSH
86705: LD_INT 26
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 101
86721: PUSH
86722: LD_INT 102
86724: PUSH
86725: LD_INT 105
86727: PUSH
86728: LD_INT 106
86730: PUSH
86731: LD_INT 108
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: LIST
86738: LIST
86739: LIST
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: ST_TO_ADDR
86745: GO 89524
86747: LD_INT 3
86749: DOUBLE
86750: EQUAL
86751: IFTRUE 86755
86753: GO 86831
86755: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86756: LD_ADDR_VAR 0 1
86760: PUSH
86761: LD_INT 2
86763: PUSH
86764: LD_INT 4
86766: PUSH
86767: LD_INT 5
86769: PUSH
86770: LD_INT 11
86772: PUSH
86773: LD_INT 12
86775: PUSH
86776: LD_INT 15
86778: PUSH
86779: LD_INT 16
86781: PUSH
86782: LD_INT 22
86784: PUSH
86785: LD_INT 26
86787: PUSH
86788: LD_INT 36
86790: PUSH
86791: EMPTY
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 101
86805: PUSH
86806: LD_INT 102
86808: PUSH
86809: LD_INT 105
86811: PUSH
86812: LD_INT 106
86814: PUSH
86815: LD_INT 108
86817: PUSH
86818: EMPTY
86819: LIST
86820: LIST
86821: LIST
86822: LIST
86823: LIST
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: ST_TO_ADDR
86829: GO 89524
86831: LD_INT 4
86833: DOUBLE
86834: EQUAL
86835: IFTRUE 86839
86837: GO 86923
86839: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86840: LD_ADDR_VAR 0 1
86844: PUSH
86845: LD_INT 2
86847: PUSH
86848: LD_INT 4
86850: PUSH
86851: LD_INT 5
86853: PUSH
86854: LD_INT 8
86856: PUSH
86857: LD_INT 11
86859: PUSH
86860: LD_INT 12
86862: PUSH
86863: LD_INT 15
86865: PUSH
86866: LD_INT 16
86868: PUSH
86869: LD_INT 22
86871: PUSH
86872: LD_INT 23
86874: PUSH
86875: LD_INT 26
86877: PUSH
86878: LD_INT 36
86880: PUSH
86881: EMPTY
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: LIST
86892: LIST
86893: LIST
86894: PUSH
86895: LD_INT 101
86897: PUSH
86898: LD_INT 102
86900: PUSH
86901: LD_INT 105
86903: PUSH
86904: LD_INT 106
86906: PUSH
86907: LD_INT 108
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: LIST
86914: LIST
86915: LIST
86916: PUSH
86917: EMPTY
86918: LIST
86919: LIST
86920: ST_TO_ADDR
86921: GO 89524
86923: LD_INT 5
86925: DOUBLE
86926: EQUAL
86927: IFTRUE 86931
86929: GO 87031
86931: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
86932: LD_ADDR_VAR 0 1
86936: PUSH
86937: LD_INT 2
86939: PUSH
86940: LD_INT 4
86942: PUSH
86943: LD_INT 5
86945: PUSH
86946: LD_INT 6
86948: PUSH
86949: LD_INT 8
86951: PUSH
86952: LD_INT 11
86954: PUSH
86955: LD_INT 12
86957: PUSH
86958: LD_INT 15
86960: PUSH
86961: LD_INT 16
86963: PUSH
86964: LD_INT 22
86966: PUSH
86967: LD_INT 23
86969: PUSH
86970: LD_INT 25
86972: PUSH
86973: LD_INT 26
86975: PUSH
86976: LD_INT 36
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: LIST
86983: LIST
86984: LIST
86985: LIST
86986: LIST
86987: LIST
86988: LIST
86989: LIST
86990: LIST
86991: LIST
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 101
86997: PUSH
86998: LD_INT 102
87000: PUSH
87001: LD_INT 105
87003: PUSH
87004: LD_INT 106
87006: PUSH
87007: LD_INT 108
87009: PUSH
87010: LD_INT 109
87012: PUSH
87013: LD_INT 112
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: LIST
87020: LIST
87021: LIST
87022: LIST
87023: LIST
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: ST_TO_ADDR
87029: GO 89524
87031: LD_INT 6
87033: DOUBLE
87034: EQUAL
87035: IFTRUE 87039
87037: GO 87159
87039: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87040: LD_ADDR_VAR 0 1
87044: PUSH
87045: LD_INT 2
87047: PUSH
87048: LD_INT 4
87050: PUSH
87051: LD_INT 5
87053: PUSH
87054: LD_INT 6
87056: PUSH
87057: LD_INT 8
87059: PUSH
87060: LD_INT 11
87062: PUSH
87063: LD_INT 12
87065: PUSH
87066: LD_INT 15
87068: PUSH
87069: LD_INT 16
87071: PUSH
87072: LD_INT 20
87074: PUSH
87075: LD_INT 21
87077: PUSH
87078: LD_INT 22
87080: PUSH
87081: LD_INT 23
87083: PUSH
87084: LD_INT 25
87086: PUSH
87087: LD_INT 26
87089: PUSH
87090: LD_INT 30
87092: PUSH
87093: LD_INT 31
87095: PUSH
87096: LD_INT 32
87098: PUSH
87099: LD_INT 36
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: LIST
87114: LIST
87115: LIST
87116: LIST
87117: LIST
87118: LIST
87119: LIST
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 101
87125: PUSH
87126: LD_INT 102
87128: PUSH
87129: LD_INT 105
87131: PUSH
87132: LD_INT 106
87134: PUSH
87135: LD_INT 108
87137: PUSH
87138: LD_INT 109
87140: PUSH
87141: LD_INT 112
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: LIST
87148: LIST
87149: LIST
87150: LIST
87151: LIST
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: ST_TO_ADDR
87157: GO 89524
87159: LD_INT 7
87161: DOUBLE
87162: EQUAL
87163: IFTRUE 87167
87165: GO 87267
87167: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
87168: LD_ADDR_VAR 0 1
87172: PUSH
87173: LD_INT 2
87175: PUSH
87176: LD_INT 4
87178: PUSH
87179: LD_INT 5
87181: PUSH
87182: LD_INT 7
87184: PUSH
87185: LD_INT 11
87187: PUSH
87188: LD_INT 12
87190: PUSH
87191: LD_INT 15
87193: PUSH
87194: LD_INT 16
87196: PUSH
87197: LD_INT 20
87199: PUSH
87200: LD_INT 21
87202: PUSH
87203: LD_INT 22
87205: PUSH
87206: LD_INT 23
87208: PUSH
87209: LD_INT 25
87211: PUSH
87212: LD_INT 26
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: LIST
87226: LIST
87227: LIST
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 101
87233: PUSH
87234: LD_INT 102
87236: PUSH
87237: LD_INT 103
87239: PUSH
87240: LD_INT 105
87242: PUSH
87243: LD_INT 106
87245: PUSH
87246: LD_INT 108
87248: PUSH
87249: LD_INT 112
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: LIST
87256: LIST
87257: LIST
87258: LIST
87259: LIST
87260: PUSH
87261: EMPTY
87262: LIST
87263: LIST
87264: ST_TO_ADDR
87265: GO 89524
87267: LD_INT 8
87269: DOUBLE
87270: EQUAL
87271: IFTRUE 87275
87273: GO 87403
87275: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
87276: LD_ADDR_VAR 0 1
87280: PUSH
87281: LD_INT 2
87283: PUSH
87284: LD_INT 4
87286: PUSH
87287: LD_INT 5
87289: PUSH
87290: LD_INT 6
87292: PUSH
87293: LD_INT 7
87295: PUSH
87296: LD_INT 8
87298: PUSH
87299: LD_INT 11
87301: PUSH
87302: LD_INT 12
87304: PUSH
87305: LD_INT 15
87307: PUSH
87308: LD_INT 16
87310: PUSH
87311: LD_INT 20
87313: PUSH
87314: LD_INT 21
87316: PUSH
87317: LD_INT 22
87319: PUSH
87320: LD_INT 23
87322: PUSH
87323: LD_INT 25
87325: PUSH
87326: LD_INT 26
87328: PUSH
87329: LD_INT 30
87331: PUSH
87332: LD_INT 31
87334: PUSH
87335: LD_INT 32
87337: PUSH
87338: LD_INT 36
87340: PUSH
87341: EMPTY
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: PUSH
87363: LD_INT 101
87365: PUSH
87366: LD_INT 102
87368: PUSH
87369: LD_INT 103
87371: PUSH
87372: LD_INT 105
87374: PUSH
87375: LD_INT 106
87377: PUSH
87378: LD_INT 108
87380: PUSH
87381: LD_INT 109
87383: PUSH
87384: LD_INT 112
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: ST_TO_ADDR
87401: GO 89524
87403: LD_INT 9
87405: DOUBLE
87406: EQUAL
87407: IFTRUE 87411
87409: GO 87547
87411: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
87412: LD_ADDR_VAR 0 1
87416: PUSH
87417: LD_INT 2
87419: PUSH
87420: LD_INT 4
87422: PUSH
87423: LD_INT 5
87425: PUSH
87426: LD_INT 6
87428: PUSH
87429: LD_INT 7
87431: PUSH
87432: LD_INT 8
87434: PUSH
87435: LD_INT 11
87437: PUSH
87438: LD_INT 12
87440: PUSH
87441: LD_INT 15
87443: PUSH
87444: LD_INT 16
87446: PUSH
87447: LD_INT 20
87449: PUSH
87450: LD_INT 21
87452: PUSH
87453: LD_INT 22
87455: PUSH
87456: LD_INT 23
87458: PUSH
87459: LD_INT 25
87461: PUSH
87462: LD_INT 26
87464: PUSH
87465: LD_INT 28
87467: PUSH
87468: LD_INT 30
87470: PUSH
87471: LD_INT 31
87473: PUSH
87474: LD_INT 32
87476: PUSH
87477: LD_INT 36
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: PUSH
87503: LD_INT 101
87505: PUSH
87506: LD_INT 102
87508: PUSH
87509: LD_INT 103
87511: PUSH
87512: LD_INT 105
87514: PUSH
87515: LD_INT 106
87517: PUSH
87518: LD_INT 108
87520: PUSH
87521: LD_INT 109
87523: PUSH
87524: LD_INT 112
87526: PUSH
87527: LD_INT 114
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: LIST
87539: LIST
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: ST_TO_ADDR
87545: GO 89524
87547: LD_INT 10
87549: DOUBLE
87550: EQUAL
87551: IFTRUE 87555
87553: GO 87739
87555: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
87556: LD_ADDR_VAR 0 1
87560: PUSH
87561: LD_INT 2
87563: PUSH
87564: LD_INT 4
87566: PUSH
87567: LD_INT 5
87569: PUSH
87570: LD_INT 6
87572: PUSH
87573: LD_INT 7
87575: PUSH
87576: LD_INT 8
87578: PUSH
87579: LD_INT 9
87581: PUSH
87582: LD_INT 10
87584: PUSH
87585: LD_INT 11
87587: PUSH
87588: LD_INT 12
87590: PUSH
87591: LD_INT 13
87593: PUSH
87594: LD_INT 14
87596: PUSH
87597: LD_INT 15
87599: PUSH
87600: LD_INT 16
87602: PUSH
87603: LD_INT 17
87605: PUSH
87606: LD_INT 18
87608: PUSH
87609: LD_INT 19
87611: PUSH
87612: LD_INT 20
87614: PUSH
87615: LD_INT 21
87617: PUSH
87618: LD_INT 22
87620: PUSH
87621: LD_INT 23
87623: PUSH
87624: LD_INT 24
87626: PUSH
87627: LD_INT 25
87629: PUSH
87630: LD_INT 26
87632: PUSH
87633: LD_INT 28
87635: PUSH
87636: LD_INT 30
87638: PUSH
87639: LD_INT 31
87641: PUSH
87642: LD_INT 32
87644: PUSH
87645: LD_INT 36
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: LIST
87652: LIST
87653: LIST
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: PUSH
87679: LD_INT 101
87681: PUSH
87682: LD_INT 102
87684: PUSH
87685: LD_INT 103
87687: PUSH
87688: LD_INT 104
87690: PUSH
87691: LD_INT 105
87693: PUSH
87694: LD_INT 106
87696: PUSH
87697: LD_INT 107
87699: PUSH
87700: LD_INT 108
87702: PUSH
87703: LD_INT 109
87705: PUSH
87706: LD_INT 110
87708: PUSH
87709: LD_INT 111
87711: PUSH
87712: LD_INT 112
87714: PUSH
87715: LD_INT 114
87717: PUSH
87718: EMPTY
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: PUSH
87733: EMPTY
87734: LIST
87735: LIST
87736: ST_TO_ADDR
87737: GO 89524
87739: LD_INT 11
87741: DOUBLE
87742: EQUAL
87743: IFTRUE 87747
87745: GO 87939
87747: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87748: LD_ADDR_VAR 0 1
87752: PUSH
87753: LD_INT 2
87755: PUSH
87756: LD_INT 3
87758: PUSH
87759: LD_INT 4
87761: PUSH
87762: LD_INT 5
87764: PUSH
87765: LD_INT 6
87767: PUSH
87768: LD_INT 7
87770: PUSH
87771: LD_INT 8
87773: PUSH
87774: LD_INT 9
87776: PUSH
87777: LD_INT 10
87779: PUSH
87780: LD_INT 11
87782: PUSH
87783: LD_INT 12
87785: PUSH
87786: LD_INT 13
87788: PUSH
87789: LD_INT 14
87791: PUSH
87792: LD_INT 15
87794: PUSH
87795: LD_INT 16
87797: PUSH
87798: LD_INT 17
87800: PUSH
87801: LD_INT 18
87803: PUSH
87804: LD_INT 19
87806: PUSH
87807: LD_INT 20
87809: PUSH
87810: LD_INT 21
87812: PUSH
87813: LD_INT 22
87815: PUSH
87816: LD_INT 23
87818: PUSH
87819: LD_INT 24
87821: PUSH
87822: LD_INT 25
87824: PUSH
87825: LD_INT 26
87827: PUSH
87828: LD_INT 28
87830: PUSH
87831: LD_INT 30
87833: PUSH
87834: LD_INT 31
87836: PUSH
87837: LD_INT 32
87839: PUSH
87840: LD_INT 34
87842: PUSH
87843: LD_INT 36
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: LIST
87862: LIST
87863: LIST
87864: LIST
87865: LIST
87866: LIST
87867: LIST
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: PUSH
87879: LD_INT 101
87881: PUSH
87882: LD_INT 102
87884: PUSH
87885: LD_INT 103
87887: PUSH
87888: LD_INT 104
87890: PUSH
87891: LD_INT 105
87893: PUSH
87894: LD_INT 106
87896: PUSH
87897: LD_INT 107
87899: PUSH
87900: LD_INT 108
87902: PUSH
87903: LD_INT 109
87905: PUSH
87906: LD_INT 110
87908: PUSH
87909: LD_INT 111
87911: PUSH
87912: LD_INT 112
87914: PUSH
87915: LD_INT 114
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: ST_TO_ADDR
87937: GO 89524
87939: LD_INT 12
87941: DOUBLE
87942: EQUAL
87943: IFTRUE 87947
87945: GO 88155
87947: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
87948: LD_ADDR_VAR 0 1
87952: PUSH
87953: LD_INT 1
87955: PUSH
87956: LD_INT 2
87958: PUSH
87959: LD_INT 3
87961: PUSH
87962: LD_INT 4
87964: PUSH
87965: LD_INT 5
87967: PUSH
87968: LD_INT 6
87970: PUSH
87971: LD_INT 7
87973: PUSH
87974: LD_INT 8
87976: PUSH
87977: LD_INT 9
87979: PUSH
87980: LD_INT 10
87982: PUSH
87983: LD_INT 11
87985: PUSH
87986: LD_INT 12
87988: PUSH
87989: LD_INT 13
87991: PUSH
87992: LD_INT 14
87994: PUSH
87995: LD_INT 15
87997: PUSH
87998: LD_INT 16
88000: PUSH
88001: LD_INT 17
88003: PUSH
88004: LD_INT 18
88006: PUSH
88007: LD_INT 19
88009: PUSH
88010: LD_INT 20
88012: PUSH
88013: LD_INT 21
88015: PUSH
88016: LD_INT 22
88018: PUSH
88019: LD_INT 23
88021: PUSH
88022: LD_INT 24
88024: PUSH
88025: LD_INT 25
88027: PUSH
88028: LD_INT 26
88030: PUSH
88031: LD_INT 27
88033: PUSH
88034: LD_INT 28
88036: PUSH
88037: LD_INT 30
88039: PUSH
88040: LD_INT 31
88042: PUSH
88043: LD_INT 32
88045: PUSH
88046: LD_INT 33
88048: PUSH
88049: LD_INT 34
88051: PUSH
88052: LD_INT 36
88054: PUSH
88055: EMPTY
88056: LIST
88057: LIST
88058: LIST
88059: LIST
88060: LIST
88061: LIST
88062: LIST
88063: LIST
88064: LIST
88065: LIST
88066: LIST
88067: LIST
88068: LIST
88069: LIST
88070: LIST
88071: LIST
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: PUSH
88091: LD_INT 101
88093: PUSH
88094: LD_INT 102
88096: PUSH
88097: LD_INT 103
88099: PUSH
88100: LD_INT 104
88102: PUSH
88103: LD_INT 105
88105: PUSH
88106: LD_INT 106
88108: PUSH
88109: LD_INT 107
88111: PUSH
88112: LD_INT 108
88114: PUSH
88115: LD_INT 109
88117: PUSH
88118: LD_INT 110
88120: PUSH
88121: LD_INT 111
88123: PUSH
88124: LD_INT 112
88126: PUSH
88127: LD_INT 113
88129: PUSH
88130: LD_INT 114
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: PUSH
88149: EMPTY
88150: LIST
88151: LIST
88152: ST_TO_ADDR
88153: GO 89524
88155: LD_INT 13
88157: DOUBLE
88158: EQUAL
88159: IFTRUE 88163
88161: GO 88359
88163: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
88164: LD_ADDR_VAR 0 1
88168: PUSH
88169: LD_INT 1
88171: PUSH
88172: LD_INT 2
88174: PUSH
88175: LD_INT 3
88177: PUSH
88178: LD_INT 4
88180: PUSH
88181: LD_INT 5
88183: PUSH
88184: LD_INT 8
88186: PUSH
88187: LD_INT 9
88189: PUSH
88190: LD_INT 10
88192: PUSH
88193: LD_INT 11
88195: PUSH
88196: LD_INT 12
88198: PUSH
88199: LD_INT 14
88201: PUSH
88202: LD_INT 15
88204: PUSH
88205: LD_INT 16
88207: PUSH
88208: LD_INT 17
88210: PUSH
88211: LD_INT 18
88213: PUSH
88214: LD_INT 19
88216: PUSH
88217: LD_INT 20
88219: PUSH
88220: LD_INT 21
88222: PUSH
88223: LD_INT 22
88225: PUSH
88226: LD_INT 23
88228: PUSH
88229: LD_INT 24
88231: PUSH
88232: LD_INT 25
88234: PUSH
88235: LD_INT 26
88237: PUSH
88238: LD_INT 27
88240: PUSH
88241: LD_INT 28
88243: PUSH
88244: LD_INT 30
88246: PUSH
88247: LD_INT 31
88249: PUSH
88250: LD_INT 32
88252: PUSH
88253: LD_INT 33
88255: PUSH
88256: LD_INT 34
88258: PUSH
88259: LD_INT 36
88261: PUSH
88262: EMPTY
88263: LIST
88264: LIST
88265: LIST
88266: LIST
88267: LIST
88268: LIST
88269: LIST
88270: LIST
88271: LIST
88272: LIST
88273: LIST
88274: LIST
88275: LIST
88276: LIST
88277: LIST
88278: LIST
88279: LIST
88280: LIST
88281: LIST
88282: LIST
88283: LIST
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: PUSH
88295: LD_INT 101
88297: PUSH
88298: LD_INT 102
88300: PUSH
88301: LD_INT 103
88303: PUSH
88304: LD_INT 104
88306: PUSH
88307: LD_INT 105
88309: PUSH
88310: LD_INT 106
88312: PUSH
88313: LD_INT 107
88315: PUSH
88316: LD_INT 108
88318: PUSH
88319: LD_INT 109
88321: PUSH
88322: LD_INT 110
88324: PUSH
88325: LD_INT 111
88327: PUSH
88328: LD_INT 112
88330: PUSH
88331: LD_INT 113
88333: PUSH
88334: LD_INT 114
88336: PUSH
88337: EMPTY
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: ST_TO_ADDR
88357: GO 89524
88359: LD_INT 14
88361: DOUBLE
88362: EQUAL
88363: IFTRUE 88367
88365: GO 88579
88367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
88368: LD_ADDR_VAR 0 1
88372: PUSH
88373: LD_INT 1
88375: PUSH
88376: LD_INT 2
88378: PUSH
88379: LD_INT 3
88381: PUSH
88382: LD_INT 4
88384: PUSH
88385: LD_INT 5
88387: PUSH
88388: LD_INT 6
88390: PUSH
88391: LD_INT 7
88393: PUSH
88394: LD_INT 8
88396: PUSH
88397: LD_INT 9
88399: PUSH
88400: LD_INT 10
88402: PUSH
88403: LD_INT 11
88405: PUSH
88406: LD_INT 12
88408: PUSH
88409: LD_INT 13
88411: PUSH
88412: LD_INT 14
88414: PUSH
88415: LD_INT 15
88417: PUSH
88418: LD_INT 16
88420: PUSH
88421: LD_INT 17
88423: PUSH
88424: LD_INT 18
88426: PUSH
88427: LD_INT 19
88429: PUSH
88430: LD_INT 20
88432: PUSH
88433: LD_INT 21
88435: PUSH
88436: LD_INT 22
88438: PUSH
88439: LD_INT 23
88441: PUSH
88442: LD_INT 24
88444: PUSH
88445: LD_INT 25
88447: PUSH
88448: LD_INT 26
88450: PUSH
88451: LD_INT 27
88453: PUSH
88454: LD_INT 28
88456: PUSH
88457: LD_INT 29
88459: PUSH
88460: LD_INT 30
88462: PUSH
88463: LD_INT 31
88465: PUSH
88466: LD_INT 32
88468: PUSH
88469: LD_INT 33
88471: PUSH
88472: LD_INT 34
88474: PUSH
88475: LD_INT 36
88477: PUSH
88478: EMPTY
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: LIST
88486: LIST
88487: LIST
88488: LIST
88489: LIST
88490: LIST
88491: LIST
88492: LIST
88493: LIST
88494: LIST
88495: LIST
88496: LIST
88497: LIST
88498: LIST
88499: LIST
88500: LIST
88501: LIST
88502: LIST
88503: LIST
88504: LIST
88505: LIST
88506: LIST
88507: LIST
88508: LIST
88509: LIST
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 101
88517: PUSH
88518: LD_INT 102
88520: PUSH
88521: LD_INT 103
88523: PUSH
88524: LD_INT 104
88526: PUSH
88527: LD_INT 105
88529: PUSH
88530: LD_INT 106
88532: PUSH
88533: LD_INT 107
88535: PUSH
88536: LD_INT 108
88538: PUSH
88539: LD_INT 109
88541: PUSH
88542: LD_INT 110
88544: PUSH
88545: LD_INT 111
88547: PUSH
88548: LD_INT 112
88550: PUSH
88551: LD_INT 113
88553: PUSH
88554: LD_INT 114
88556: PUSH
88557: EMPTY
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: ST_TO_ADDR
88577: GO 89524
88579: LD_INT 15
88581: DOUBLE
88582: EQUAL
88583: IFTRUE 88587
88585: GO 88799
88587: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
88588: LD_ADDR_VAR 0 1
88592: PUSH
88593: LD_INT 1
88595: PUSH
88596: LD_INT 2
88598: PUSH
88599: LD_INT 3
88601: PUSH
88602: LD_INT 4
88604: PUSH
88605: LD_INT 5
88607: PUSH
88608: LD_INT 6
88610: PUSH
88611: LD_INT 7
88613: PUSH
88614: LD_INT 8
88616: PUSH
88617: LD_INT 9
88619: PUSH
88620: LD_INT 10
88622: PUSH
88623: LD_INT 11
88625: PUSH
88626: LD_INT 12
88628: PUSH
88629: LD_INT 13
88631: PUSH
88632: LD_INT 14
88634: PUSH
88635: LD_INT 15
88637: PUSH
88638: LD_INT 16
88640: PUSH
88641: LD_INT 17
88643: PUSH
88644: LD_INT 18
88646: PUSH
88647: LD_INT 19
88649: PUSH
88650: LD_INT 20
88652: PUSH
88653: LD_INT 21
88655: PUSH
88656: LD_INT 22
88658: PUSH
88659: LD_INT 23
88661: PUSH
88662: LD_INT 24
88664: PUSH
88665: LD_INT 25
88667: PUSH
88668: LD_INT 26
88670: PUSH
88671: LD_INT 27
88673: PUSH
88674: LD_INT 28
88676: PUSH
88677: LD_INT 29
88679: PUSH
88680: LD_INT 30
88682: PUSH
88683: LD_INT 31
88685: PUSH
88686: LD_INT 32
88688: PUSH
88689: LD_INT 33
88691: PUSH
88692: LD_INT 34
88694: PUSH
88695: LD_INT 36
88697: PUSH
88698: EMPTY
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: PUSH
88735: LD_INT 101
88737: PUSH
88738: LD_INT 102
88740: PUSH
88741: LD_INT 103
88743: PUSH
88744: LD_INT 104
88746: PUSH
88747: LD_INT 105
88749: PUSH
88750: LD_INT 106
88752: PUSH
88753: LD_INT 107
88755: PUSH
88756: LD_INT 108
88758: PUSH
88759: LD_INT 109
88761: PUSH
88762: LD_INT 110
88764: PUSH
88765: LD_INT 111
88767: PUSH
88768: LD_INT 112
88770: PUSH
88771: LD_INT 113
88773: PUSH
88774: LD_INT 114
88776: PUSH
88777: EMPTY
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: PUSH
88793: EMPTY
88794: LIST
88795: LIST
88796: ST_TO_ADDR
88797: GO 89524
88799: LD_INT 16
88801: DOUBLE
88802: EQUAL
88803: IFTRUE 88807
88805: GO 88931
88807: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88808: LD_ADDR_VAR 0 1
88812: PUSH
88813: LD_INT 2
88815: PUSH
88816: LD_INT 4
88818: PUSH
88819: LD_INT 5
88821: PUSH
88822: LD_INT 7
88824: PUSH
88825: LD_INT 11
88827: PUSH
88828: LD_INT 12
88830: PUSH
88831: LD_INT 15
88833: PUSH
88834: LD_INT 16
88836: PUSH
88837: LD_INT 20
88839: PUSH
88840: LD_INT 21
88842: PUSH
88843: LD_INT 22
88845: PUSH
88846: LD_INT 23
88848: PUSH
88849: LD_INT 25
88851: PUSH
88852: LD_INT 26
88854: PUSH
88855: LD_INT 30
88857: PUSH
88858: LD_INT 31
88860: PUSH
88861: LD_INT 32
88863: PUSH
88864: LD_INT 33
88866: PUSH
88867: LD_INT 34
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 101
88893: PUSH
88894: LD_INT 102
88896: PUSH
88897: LD_INT 103
88899: PUSH
88900: LD_INT 106
88902: PUSH
88903: LD_INT 108
88905: PUSH
88906: LD_INT 112
88908: PUSH
88909: LD_INT 113
88911: PUSH
88912: LD_INT 114
88914: PUSH
88915: EMPTY
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: PUSH
88925: EMPTY
88926: LIST
88927: LIST
88928: ST_TO_ADDR
88929: GO 89524
88931: LD_INT 17
88933: DOUBLE
88934: EQUAL
88935: IFTRUE 88939
88937: GO 89151
88939: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
88940: LD_ADDR_VAR 0 1
88944: PUSH
88945: LD_INT 1
88947: PUSH
88948: LD_INT 2
88950: PUSH
88951: LD_INT 3
88953: PUSH
88954: LD_INT 4
88956: PUSH
88957: LD_INT 5
88959: PUSH
88960: LD_INT 6
88962: PUSH
88963: LD_INT 7
88965: PUSH
88966: LD_INT 8
88968: PUSH
88969: LD_INT 9
88971: PUSH
88972: LD_INT 10
88974: PUSH
88975: LD_INT 11
88977: PUSH
88978: LD_INT 12
88980: PUSH
88981: LD_INT 13
88983: PUSH
88984: LD_INT 14
88986: PUSH
88987: LD_INT 15
88989: PUSH
88990: LD_INT 16
88992: PUSH
88993: LD_INT 17
88995: PUSH
88996: LD_INT 18
88998: PUSH
88999: LD_INT 19
89001: PUSH
89002: LD_INT 20
89004: PUSH
89005: LD_INT 21
89007: PUSH
89008: LD_INT 22
89010: PUSH
89011: LD_INT 23
89013: PUSH
89014: LD_INT 24
89016: PUSH
89017: LD_INT 25
89019: PUSH
89020: LD_INT 26
89022: PUSH
89023: LD_INT 27
89025: PUSH
89026: LD_INT 28
89028: PUSH
89029: LD_INT 29
89031: PUSH
89032: LD_INT 30
89034: PUSH
89035: LD_INT 31
89037: PUSH
89038: LD_INT 32
89040: PUSH
89041: LD_INT 33
89043: PUSH
89044: LD_INT 34
89046: PUSH
89047: LD_INT 36
89049: PUSH
89050: EMPTY
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: LIST
89086: PUSH
89087: LD_INT 101
89089: PUSH
89090: LD_INT 102
89092: PUSH
89093: LD_INT 103
89095: PUSH
89096: LD_INT 104
89098: PUSH
89099: LD_INT 105
89101: PUSH
89102: LD_INT 106
89104: PUSH
89105: LD_INT 107
89107: PUSH
89108: LD_INT 108
89110: PUSH
89111: LD_INT 109
89113: PUSH
89114: LD_INT 110
89116: PUSH
89117: LD_INT 111
89119: PUSH
89120: LD_INT 112
89122: PUSH
89123: LD_INT 113
89125: PUSH
89126: LD_INT 114
89128: PUSH
89129: EMPTY
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: PUSH
89145: EMPTY
89146: LIST
89147: LIST
89148: ST_TO_ADDR
89149: GO 89524
89151: LD_INT 18
89153: DOUBLE
89154: EQUAL
89155: IFTRUE 89159
89157: GO 89295
89159: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
89160: LD_ADDR_VAR 0 1
89164: PUSH
89165: LD_INT 2
89167: PUSH
89168: LD_INT 4
89170: PUSH
89171: LD_INT 5
89173: PUSH
89174: LD_INT 7
89176: PUSH
89177: LD_INT 11
89179: PUSH
89180: LD_INT 12
89182: PUSH
89183: LD_INT 15
89185: PUSH
89186: LD_INT 16
89188: PUSH
89189: LD_INT 20
89191: PUSH
89192: LD_INT 21
89194: PUSH
89195: LD_INT 22
89197: PUSH
89198: LD_INT 23
89200: PUSH
89201: LD_INT 25
89203: PUSH
89204: LD_INT 26
89206: PUSH
89207: LD_INT 30
89209: PUSH
89210: LD_INT 31
89212: PUSH
89213: LD_INT 32
89215: PUSH
89216: LD_INT 33
89218: PUSH
89219: LD_INT 34
89221: PUSH
89222: LD_INT 35
89224: PUSH
89225: LD_INT 36
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: PUSH
89251: LD_INT 101
89253: PUSH
89254: LD_INT 102
89256: PUSH
89257: LD_INT 103
89259: PUSH
89260: LD_INT 106
89262: PUSH
89263: LD_INT 108
89265: PUSH
89266: LD_INT 112
89268: PUSH
89269: LD_INT 113
89271: PUSH
89272: LD_INT 114
89274: PUSH
89275: LD_INT 115
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: LIST
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: ST_TO_ADDR
89293: GO 89524
89295: LD_INT 19
89297: DOUBLE
89298: EQUAL
89299: IFTRUE 89303
89301: GO 89523
89303: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
89304: LD_ADDR_VAR 0 1
89308: PUSH
89309: LD_INT 1
89311: PUSH
89312: LD_INT 2
89314: PUSH
89315: LD_INT 3
89317: PUSH
89318: LD_INT 4
89320: PUSH
89321: LD_INT 5
89323: PUSH
89324: LD_INT 6
89326: PUSH
89327: LD_INT 7
89329: PUSH
89330: LD_INT 8
89332: PUSH
89333: LD_INT 9
89335: PUSH
89336: LD_INT 10
89338: PUSH
89339: LD_INT 11
89341: PUSH
89342: LD_INT 12
89344: PUSH
89345: LD_INT 13
89347: PUSH
89348: LD_INT 14
89350: PUSH
89351: LD_INT 15
89353: PUSH
89354: LD_INT 16
89356: PUSH
89357: LD_INT 17
89359: PUSH
89360: LD_INT 18
89362: PUSH
89363: LD_INT 19
89365: PUSH
89366: LD_INT 20
89368: PUSH
89369: LD_INT 21
89371: PUSH
89372: LD_INT 22
89374: PUSH
89375: LD_INT 23
89377: PUSH
89378: LD_INT 24
89380: PUSH
89381: LD_INT 25
89383: PUSH
89384: LD_INT 26
89386: PUSH
89387: LD_INT 27
89389: PUSH
89390: LD_INT 28
89392: PUSH
89393: LD_INT 29
89395: PUSH
89396: LD_INT 30
89398: PUSH
89399: LD_INT 31
89401: PUSH
89402: LD_INT 32
89404: PUSH
89405: LD_INT 33
89407: PUSH
89408: LD_INT 34
89410: PUSH
89411: LD_INT 35
89413: PUSH
89414: LD_INT 36
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: LIST
89441: LIST
89442: LIST
89443: LIST
89444: LIST
89445: LIST
89446: LIST
89447: LIST
89448: LIST
89449: LIST
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 101
89457: PUSH
89458: LD_INT 102
89460: PUSH
89461: LD_INT 103
89463: PUSH
89464: LD_INT 104
89466: PUSH
89467: LD_INT 105
89469: PUSH
89470: LD_INT 106
89472: PUSH
89473: LD_INT 107
89475: PUSH
89476: LD_INT 108
89478: PUSH
89479: LD_INT 109
89481: PUSH
89482: LD_INT 110
89484: PUSH
89485: LD_INT 111
89487: PUSH
89488: LD_INT 112
89490: PUSH
89491: LD_INT 113
89493: PUSH
89494: LD_INT 114
89496: PUSH
89497: LD_INT 115
89499: PUSH
89500: EMPTY
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: ST_TO_ADDR
89521: GO 89524
89523: POP
// end else
89524: GO 89743
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
89526: LD_ADDR_VAR 0 1
89530: PUSH
89531: LD_INT 1
89533: PUSH
89534: LD_INT 2
89536: PUSH
89537: LD_INT 3
89539: PUSH
89540: LD_INT 4
89542: PUSH
89543: LD_INT 5
89545: PUSH
89546: LD_INT 6
89548: PUSH
89549: LD_INT 7
89551: PUSH
89552: LD_INT 8
89554: PUSH
89555: LD_INT 9
89557: PUSH
89558: LD_INT 10
89560: PUSH
89561: LD_INT 11
89563: PUSH
89564: LD_INT 12
89566: PUSH
89567: LD_INT 13
89569: PUSH
89570: LD_INT 14
89572: PUSH
89573: LD_INT 15
89575: PUSH
89576: LD_INT 16
89578: PUSH
89579: LD_INT 17
89581: PUSH
89582: LD_INT 18
89584: PUSH
89585: LD_INT 19
89587: PUSH
89588: LD_INT 20
89590: PUSH
89591: LD_INT 21
89593: PUSH
89594: LD_INT 22
89596: PUSH
89597: LD_INT 23
89599: PUSH
89600: LD_INT 24
89602: PUSH
89603: LD_INT 25
89605: PUSH
89606: LD_INT 26
89608: PUSH
89609: LD_INT 27
89611: PUSH
89612: LD_INT 28
89614: PUSH
89615: LD_INT 29
89617: PUSH
89618: LD_INT 30
89620: PUSH
89621: LD_INT 31
89623: PUSH
89624: LD_INT 32
89626: PUSH
89627: LD_INT 33
89629: PUSH
89630: LD_INT 34
89632: PUSH
89633: LD_INT 35
89635: PUSH
89636: LD_INT 36
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: LIST
89645: LIST
89646: LIST
89647: LIST
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: PUSH
89677: LD_INT 101
89679: PUSH
89680: LD_INT 102
89682: PUSH
89683: LD_INT 103
89685: PUSH
89686: LD_INT 104
89688: PUSH
89689: LD_INT 105
89691: PUSH
89692: LD_INT 106
89694: PUSH
89695: LD_INT 107
89697: PUSH
89698: LD_INT 108
89700: PUSH
89701: LD_INT 109
89703: PUSH
89704: LD_INT 110
89706: PUSH
89707: LD_INT 111
89709: PUSH
89710: LD_INT 112
89712: PUSH
89713: LD_INT 113
89715: PUSH
89716: LD_INT 114
89718: PUSH
89719: LD_INT 115
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: ST_TO_ADDR
// if result then
89743: LD_VAR 0 1
89747: IFFALSE 90036
// begin normal :=  ;
89749: LD_ADDR_VAR 0 3
89753: PUSH
89754: LD_STRING 
89756: ST_TO_ADDR
// hardcore :=  ;
89757: LD_ADDR_VAR 0 4
89761: PUSH
89762: LD_STRING 
89764: ST_TO_ADDR
// for i = 1 to normalCounter do
89765: LD_ADDR_VAR 0 5
89769: PUSH
89770: DOUBLE
89771: LD_INT 1
89773: DEC
89774: ST_TO_ADDR
89775: LD_EXP 123
89779: PUSH
89780: FOR_TO
89781: IFFALSE 89882
// begin tmp := 0 ;
89783: LD_ADDR_VAR 0 2
89787: PUSH
89788: LD_STRING 0
89790: ST_TO_ADDR
// if result [ 1 ] then
89791: LD_VAR 0 1
89795: PUSH
89796: LD_INT 1
89798: ARRAY
89799: IFFALSE 89864
// if result [ 1 ] [ 1 ] = i then
89801: LD_VAR 0 1
89805: PUSH
89806: LD_INT 1
89808: ARRAY
89809: PUSH
89810: LD_INT 1
89812: ARRAY
89813: PUSH
89814: LD_VAR 0 5
89818: EQUAL
89819: IFFALSE 89864
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89821: LD_ADDR_VAR 0 1
89825: PUSH
89826: LD_VAR 0 1
89830: PPUSH
89831: LD_INT 1
89833: PPUSH
89834: LD_VAR 0 1
89838: PUSH
89839: LD_INT 1
89841: ARRAY
89842: PPUSH
89843: LD_INT 1
89845: PPUSH
89846: CALL_OW 3
89850: PPUSH
89851: CALL_OW 1
89855: ST_TO_ADDR
// tmp := 1 ;
89856: LD_ADDR_VAR 0 2
89860: PUSH
89861: LD_STRING 1
89863: ST_TO_ADDR
// end ; normal := normal & tmp ;
89864: LD_ADDR_VAR 0 3
89868: PUSH
89869: LD_VAR 0 3
89873: PUSH
89874: LD_VAR 0 2
89878: STR
89879: ST_TO_ADDR
// end ;
89880: GO 89780
89882: POP
89883: POP
// for i = 1 to hardcoreCounter do
89884: LD_ADDR_VAR 0 5
89888: PUSH
89889: DOUBLE
89890: LD_INT 1
89892: DEC
89893: ST_TO_ADDR
89894: LD_EXP 124
89898: PUSH
89899: FOR_TO
89900: IFFALSE 90005
// begin tmp := 0 ;
89902: LD_ADDR_VAR 0 2
89906: PUSH
89907: LD_STRING 0
89909: ST_TO_ADDR
// if result [ 2 ] then
89910: LD_VAR 0 1
89914: PUSH
89915: LD_INT 2
89917: ARRAY
89918: IFFALSE 89987
// if result [ 2 ] [ 1 ] = 100 + i then
89920: LD_VAR 0 1
89924: PUSH
89925: LD_INT 2
89927: ARRAY
89928: PUSH
89929: LD_INT 1
89931: ARRAY
89932: PUSH
89933: LD_INT 100
89935: PUSH
89936: LD_VAR 0 5
89940: PLUS
89941: EQUAL
89942: IFFALSE 89987
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
89944: LD_ADDR_VAR 0 1
89948: PUSH
89949: LD_VAR 0 1
89953: PPUSH
89954: LD_INT 2
89956: PPUSH
89957: LD_VAR 0 1
89961: PUSH
89962: LD_INT 2
89964: ARRAY
89965: PPUSH
89966: LD_INT 1
89968: PPUSH
89969: CALL_OW 3
89973: PPUSH
89974: CALL_OW 1
89978: ST_TO_ADDR
// tmp := 1 ;
89979: LD_ADDR_VAR 0 2
89983: PUSH
89984: LD_STRING 1
89986: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
89987: LD_ADDR_VAR 0 4
89991: PUSH
89992: LD_VAR 0 4
89996: PUSH
89997: LD_VAR 0 2
90001: STR
90002: ST_TO_ADDR
// end ;
90003: GO 89899
90005: POP
90006: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90007: LD_STRING getStreamItemsFromMission("
90009: PUSH
90010: LD_VAR 0 3
90014: STR
90015: PUSH
90016: LD_STRING ","
90018: STR
90019: PUSH
90020: LD_VAR 0 4
90024: STR
90025: PUSH
90026: LD_STRING ")
90028: STR
90029: PPUSH
90030: CALL_OW 559
// end else
90034: GO 90043
// ToLua ( getStreamItemsFromMission("","") ) ;
90036: LD_STRING getStreamItemsFromMission("","")
90038: PPUSH
90039: CALL_OW 559
// end ;
90043: LD_VAR 0 1
90047: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90048: LD_EXP 122
90052: PUSH
90053: LD_EXP 127
90057: AND
90058: IFFALSE 90182
90060: GO 90062
90062: DISABLE
90063: LD_INT 0
90065: PPUSH
90066: PPUSH
// begin enable ;
90067: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90068: LD_ADDR_VAR 0 2
90072: PUSH
90073: LD_INT 22
90075: PUSH
90076: LD_OWVAR 2
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 2
90087: PUSH
90088: LD_INT 34
90090: PUSH
90091: LD_INT 7
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 34
90100: PUSH
90101: LD_INT 45
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: LD_INT 34
90110: PUSH
90111: LD_INT 28
90113: PUSH
90114: EMPTY
90115: LIST
90116: LIST
90117: PUSH
90118: LD_INT 34
90120: PUSH
90121: LD_INT 47
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PPUSH
90139: CALL_OW 69
90143: ST_TO_ADDR
// if not tmp then
90144: LD_VAR 0 2
90148: NOT
90149: IFFALSE 90153
// exit ;
90151: GO 90182
// for i in tmp do
90153: LD_ADDR_VAR 0 1
90157: PUSH
90158: LD_VAR 0 2
90162: PUSH
90163: FOR_IN
90164: IFFALSE 90180
// begin SetLives ( i , 0 ) ;
90166: LD_VAR 0 1
90170: PPUSH
90171: LD_INT 0
90173: PPUSH
90174: CALL_OW 234
// end ;
90178: GO 90163
90180: POP
90181: POP
// end ;
90182: PPOPN 2
90184: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90185: LD_EXP 122
90189: PUSH
90190: LD_EXP 128
90194: AND
90195: IFFALSE 90279
90197: GO 90199
90199: DISABLE
90200: LD_INT 0
90202: PPUSH
90203: PPUSH
// begin enable ;
90204: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90205: LD_ADDR_VAR 0 2
90209: PUSH
90210: LD_INT 22
90212: PUSH
90213: LD_OWVAR 2
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 32
90224: PUSH
90225: LD_INT 3
90227: PUSH
90228: EMPTY
90229: LIST
90230: LIST
90231: PUSH
90232: EMPTY
90233: LIST
90234: LIST
90235: PPUSH
90236: CALL_OW 69
90240: ST_TO_ADDR
// if not tmp then
90241: LD_VAR 0 2
90245: NOT
90246: IFFALSE 90250
// exit ;
90248: GO 90279
// for i in tmp do
90250: LD_ADDR_VAR 0 1
90254: PUSH
90255: LD_VAR 0 2
90259: PUSH
90260: FOR_IN
90261: IFFALSE 90277
// begin SetLives ( i , 0 ) ;
90263: LD_VAR 0 1
90267: PPUSH
90268: LD_INT 0
90270: PPUSH
90271: CALL_OW 234
// end ;
90275: GO 90260
90277: POP
90278: POP
// end ;
90279: PPOPN 2
90281: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90282: LD_EXP 122
90286: PUSH
90287: LD_EXP 125
90291: AND
90292: IFFALSE 90385
90294: GO 90296
90296: DISABLE
90297: LD_INT 0
90299: PPUSH
// begin enable ;
90300: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90301: LD_ADDR_VAR 0 1
90305: PUSH
90306: LD_INT 22
90308: PUSH
90309: LD_OWVAR 2
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: PUSH
90318: LD_INT 2
90320: PUSH
90321: LD_INT 25
90323: PUSH
90324: LD_INT 5
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: PUSH
90331: LD_INT 25
90333: PUSH
90334: LD_INT 9
90336: PUSH
90337: EMPTY
90338: LIST
90339: LIST
90340: PUSH
90341: LD_INT 25
90343: PUSH
90344: LD_INT 8
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: EMPTY
90352: LIST
90353: LIST
90354: LIST
90355: LIST
90356: PUSH
90357: EMPTY
90358: LIST
90359: LIST
90360: PPUSH
90361: CALL_OW 69
90365: PUSH
90366: FOR_IN
90367: IFFALSE 90383
// begin SetClass ( i , 1 ) ;
90369: LD_VAR 0 1
90373: PPUSH
90374: LD_INT 1
90376: PPUSH
90377: CALL_OW 336
// end ;
90381: GO 90366
90383: POP
90384: POP
// end ;
90385: PPOPN 1
90387: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90388: LD_EXP 122
90392: PUSH
90393: LD_EXP 126
90397: AND
90398: PUSH
90399: LD_OWVAR 65
90403: PUSH
90404: LD_INT 7
90406: LESS
90407: AND
90408: IFFALSE 90422
90410: GO 90412
90412: DISABLE
// begin enable ;
90413: ENABLE
// game_speed := 7 ;
90414: LD_ADDR_OWVAR 65
90418: PUSH
90419: LD_INT 7
90421: ST_TO_ADDR
// end ;
90422: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90423: LD_EXP 122
90427: PUSH
90428: LD_EXP 129
90432: AND
90433: IFFALSE 90635
90435: GO 90437
90437: DISABLE
90438: LD_INT 0
90440: PPUSH
90441: PPUSH
90442: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90443: LD_ADDR_VAR 0 3
90447: PUSH
90448: LD_INT 81
90450: PUSH
90451: LD_OWVAR 2
90455: PUSH
90456: EMPTY
90457: LIST
90458: LIST
90459: PUSH
90460: LD_INT 21
90462: PUSH
90463: LD_INT 1
90465: PUSH
90466: EMPTY
90467: LIST
90468: LIST
90469: PUSH
90470: EMPTY
90471: LIST
90472: LIST
90473: PPUSH
90474: CALL_OW 69
90478: ST_TO_ADDR
// if not tmp then
90479: LD_VAR 0 3
90483: NOT
90484: IFFALSE 90488
// exit ;
90486: GO 90635
// if tmp > 5 then
90488: LD_VAR 0 3
90492: PUSH
90493: LD_INT 5
90495: GREATER
90496: IFFALSE 90508
// k := 5 else
90498: LD_ADDR_VAR 0 2
90502: PUSH
90503: LD_INT 5
90505: ST_TO_ADDR
90506: GO 90518
// k := tmp ;
90508: LD_ADDR_VAR 0 2
90512: PUSH
90513: LD_VAR 0 3
90517: ST_TO_ADDR
// for i := 1 to k do
90518: LD_ADDR_VAR 0 1
90522: PUSH
90523: DOUBLE
90524: LD_INT 1
90526: DEC
90527: ST_TO_ADDR
90528: LD_VAR 0 2
90532: PUSH
90533: FOR_TO
90534: IFFALSE 90633
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90536: LD_VAR 0 3
90540: PUSH
90541: LD_VAR 0 1
90545: ARRAY
90546: PPUSH
90547: LD_VAR 0 1
90551: PUSH
90552: LD_INT 4
90554: MOD
90555: PUSH
90556: LD_INT 1
90558: PLUS
90559: PPUSH
90560: CALL_OW 259
90564: PUSH
90565: LD_INT 10
90567: LESS
90568: IFFALSE 90631
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90570: LD_VAR 0 3
90574: PUSH
90575: LD_VAR 0 1
90579: ARRAY
90580: PPUSH
90581: LD_VAR 0 1
90585: PUSH
90586: LD_INT 4
90588: MOD
90589: PUSH
90590: LD_INT 1
90592: PLUS
90593: PPUSH
90594: LD_VAR 0 3
90598: PUSH
90599: LD_VAR 0 1
90603: ARRAY
90604: PPUSH
90605: LD_VAR 0 1
90609: PUSH
90610: LD_INT 4
90612: MOD
90613: PUSH
90614: LD_INT 1
90616: PLUS
90617: PPUSH
90618: CALL_OW 259
90622: PUSH
90623: LD_INT 1
90625: PLUS
90626: PPUSH
90627: CALL_OW 237
90631: GO 90533
90633: POP
90634: POP
// end ;
90635: PPOPN 3
90637: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90638: LD_EXP 122
90642: PUSH
90643: LD_EXP 130
90647: AND
90648: IFFALSE 90668
90650: GO 90652
90652: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90653: LD_INT 4
90655: PPUSH
90656: LD_OWVAR 2
90660: PPUSH
90661: LD_INT 0
90663: PPUSH
90664: CALL_OW 324
90668: END
// every 0 0$1 trigger StreamModeActive and sShovel do
90669: LD_EXP 122
90673: PUSH
90674: LD_EXP 159
90678: AND
90679: IFFALSE 90699
90681: GO 90683
90683: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90684: LD_INT 19
90686: PPUSH
90687: LD_OWVAR 2
90691: PPUSH
90692: LD_INT 0
90694: PPUSH
90695: CALL_OW 324
90699: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90700: LD_EXP 122
90704: PUSH
90705: LD_EXP 131
90709: AND
90710: IFFALSE 90812
90712: GO 90714
90714: DISABLE
90715: LD_INT 0
90717: PPUSH
90718: PPUSH
// begin enable ;
90719: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90720: LD_ADDR_VAR 0 2
90724: PUSH
90725: LD_INT 22
90727: PUSH
90728: LD_OWVAR 2
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PUSH
90737: LD_INT 2
90739: PUSH
90740: LD_INT 34
90742: PUSH
90743: LD_INT 11
90745: PUSH
90746: EMPTY
90747: LIST
90748: LIST
90749: PUSH
90750: LD_INT 34
90752: PUSH
90753: LD_INT 30
90755: PUSH
90756: EMPTY
90757: LIST
90758: LIST
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: LIST
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PPUSH
90769: CALL_OW 69
90773: ST_TO_ADDR
// if not tmp then
90774: LD_VAR 0 2
90778: NOT
90779: IFFALSE 90783
// exit ;
90781: GO 90812
// for i in tmp do
90783: LD_ADDR_VAR 0 1
90787: PUSH
90788: LD_VAR 0 2
90792: PUSH
90793: FOR_IN
90794: IFFALSE 90810
// begin SetLives ( i , 0 ) ;
90796: LD_VAR 0 1
90800: PPUSH
90801: LD_INT 0
90803: PPUSH
90804: CALL_OW 234
// end ;
90808: GO 90793
90810: POP
90811: POP
// end ;
90812: PPOPN 2
90814: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90815: LD_EXP 122
90819: PUSH
90820: LD_EXP 132
90824: AND
90825: IFFALSE 90845
90827: GO 90829
90829: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90830: LD_INT 32
90832: PPUSH
90833: LD_OWVAR 2
90837: PPUSH
90838: LD_INT 0
90840: PPUSH
90841: CALL_OW 324
90845: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90846: LD_EXP 122
90850: PUSH
90851: LD_EXP 133
90855: AND
90856: IFFALSE 91037
90858: GO 90860
90860: DISABLE
90861: LD_INT 0
90863: PPUSH
90864: PPUSH
90865: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90866: LD_ADDR_VAR 0 2
90870: PUSH
90871: LD_INT 22
90873: PUSH
90874: LD_OWVAR 2
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: LD_INT 33
90885: PUSH
90886: LD_INT 3
90888: PUSH
90889: EMPTY
90890: LIST
90891: LIST
90892: PUSH
90893: EMPTY
90894: LIST
90895: LIST
90896: PPUSH
90897: CALL_OW 69
90901: ST_TO_ADDR
// if not tmp then
90902: LD_VAR 0 2
90906: NOT
90907: IFFALSE 90911
// exit ;
90909: GO 91037
// side := 0 ;
90911: LD_ADDR_VAR 0 3
90915: PUSH
90916: LD_INT 0
90918: ST_TO_ADDR
// for i := 1 to 8 do
90919: LD_ADDR_VAR 0 1
90923: PUSH
90924: DOUBLE
90925: LD_INT 1
90927: DEC
90928: ST_TO_ADDR
90929: LD_INT 8
90931: PUSH
90932: FOR_TO
90933: IFFALSE 90981
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90935: LD_OWVAR 2
90939: PUSH
90940: LD_VAR 0 1
90944: NONEQUAL
90945: PUSH
90946: LD_OWVAR 2
90950: PPUSH
90951: LD_VAR 0 1
90955: PPUSH
90956: CALL_OW 81
90960: PUSH
90961: LD_INT 2
90963: EQUAL
90964: AND
90965: IFFALSE 90979
// begin side := i ;
90967: LD_ADDR_VAR 0 3
90971: PUSH
90972: LD_VAR 0 1
90976: ST_TO_ADDR
// break ;
90977: GO 90981
// end ;
90979: GO 90932
90981: POP
90982: POP
// if not side then
90983: LD_VAR 0 3
90987: NOT
90988: IFFALSE 90992
// exit ;
90990: GO 91037
// for i := 1 to tmp do
90992: LD_ADDR_VAR 0 1
90996: PUSH
90997: DOUBLE
90998: LD_INT 1
91000: DEC
91001: ST_TO_ADDR
91002: LD_VAR 0 2
91006: PUSH
91007: FOR_TO
91008: IFFALSE 91035
// if Prob ( 60 ) then
91010: LD_INT 60
91012: PPUSH
91013: CALL_OW 13
91017: IFFALSE 91033
// SetSide ( i , side ) ;
91019: LD_VAR 0 1
91023: PPUSH
91024: LD_VAR 0 3
91028: PPUSH
91029: CALL_OW 235
91033: GO 91007
91035: POP
91036: POP
// end ;
91037: PPOPN 3
91039: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91040: LD_EXP 122
91044: PUSH
91045: LD_EXP 135
91049: AND
91050: IFFALSE 91169
91052: GO 91054
91054: DISABLE
91055: LD_INT 0
91057: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91058: LD_ADDR_VAR 0 1
91062: PUSH
91063: LD_INT 22
91065: PUSH
91066: LD_OWVAR 2
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 21
91077: PUSH
91078: LD_INT 1
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: PUSH
91085: LD_INT 3
91087: PUSH
91088: LD_INT 23
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: LIST
91106: PPUSH
91107: CALL_OW 69
91111: PUSH
91112: FOR_IN
91113: IFFALSE 91167
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91115: LD_VAR 0 1
91119: PPUSH
91120: CALL_OW 257
91124: PUSH
91125: LD_INT 1
91127: PUSH
91128: LD_INT 2
91130: PUSH
91131: LD_INT 3
91133: PUSH
91134: LD_INT 4
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: LIST
91141: LIST
91142: IN
91143: IFFALSE 91165
// SetClass ( un , rand ( 1 , 4 ) ) ;
91145: LD_VAR 0 1
91149: PPUSH
91150: LD_INT 1
91152: PPUSH
91153: LD_INT 4
91155: PPUSH
91156: CALL_OW 12
91160: PPUSH
91161: CALL_OW 336
91165: GO 91112
91167: POP
91168: POP
// end ;
91169: PPOPN 1
91171: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91172: LD_EXP 122
91176: PUSH
91177: LD_EXP 134
91181: AND
91182: IFFALSE 91261
91184: GO 91186
91186: DISABLE
91187: LD_INT 0
91189: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91190: LD_ADDR_VAR 0 1
91194: PUSH
91195: LD_INT 22
91197: PUSH
91198: LD_OWVAR 2
91202: PUSH
91203: EMPTY
91204: LIST
91205: LIST
91206: PUSH
91207: LD_INT 21
91209: PUSH
91210: LD_INT 3
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: PPUSH
91221: CALL_OW 69
91225: ST_TO_ADDR
// if not tmp then
91226: LD_VAR 0 1
91230: NOT
91231: IFFALSE 91235
// exit ;
91233: GO 91261
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91235: LD_VAR 0 1
91239: PUSH
91240: LD_INT 1
91242: PPUSH
91243: LD_VAR 0 1
91247: PPUSH
91248: CALL_OW 12
91252: ARRAY
91253: PPUSH
91254: LD_INT 100
91256: PPUSH
91257: CALL_OW 234
// end ;
91261: PPOPN 1
91263: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91264: LD_EXP 122
91268: PUSH
91269: LD_EXP 136
91273: AND
91274: IFFALSE 91372
91276: GO 91278
91278: DISABLE
91279: LD_INT 0
91281: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91282: LD_ADDR_VAR 0 1
91286: PUSH
91287: LD_INT 22
91289: PUSH
91290: LD_OWVAR 2
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 21
91301: PUSH
91302: LD_INT 1
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: EMPTY
91310: LIST
91311: LIST
91312: PPUSH
91313: CALL_OW 69
91317: ST_TO_ADDR
// if not tmp then
91318: LD_VAR 0 1
91322: NOT
91323: IFFALSE 91327
// exit ;
91325: GO 91372
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91327: LD_VAR 0 1
91331: PUSH
91332: LD_INT 1
91334: PPUSH
91335: LD_VAR 0 1
91339: PPUSH
91340: CALL_OW 12
91344: ARRAY
91345: PPUSH
91346: LD_INT 1
91348: PPUSH
91349: LD_INT 4
91351: PPUSH
91352: CALL_OW 12
91356: PPUSH
91357: LD_INT 3000
91359: PPUSH
91360: LD_INT 9000
91362: PPUSH
91363: CALL_OW 12
91367: PPUSH
91368: CALL_OW 492
// end ;
91372: PPOPN 1
91374: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91375: LD_EXP 122
91379: PUSH
91380: LD_EXP 137
91384: AND
91385: IFFALSE 91405
91387: GO 91389
91389: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91390: LD_INT 1
91392: PPUSH
91393: LD_OWVAR 2
91397: PPUSH
91398: LD_INT 0
91400: PPUSH
91401: CALL_OW 324
91405: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91406: LD_EXP 122
91410: PUSH
91411: LD_EXP 138
91415: AND
91416: IFFALSE 91499
91418: GO 91420
91420: DISABLE
91421: LD_INT 0
91423: PPUSH
91424: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91425: LD_ADDR_VAR 0 2
91429: PUSH
91430: LD_INT 22
91432: PUSH
91433: LD_OWVAR 2
91437: PUSH
91438: EMPTY
91439: LIST
91440: LIST
91441: PUSH
91442: LD_INT 21
91444: PUSH
91445: LD_INT 3
91447: PUSH
91448: EMPTY
91449: LIST
91450: LIST
91451: PUSH
91452: EMPTY
91453: LIST
91454: LIST
91455: PPUSH
91456: CALL_OW 69
91460: ST_TO_ADDR
// if not tmp then
91461: LD_VAR 0 2
91465: NOT
91466: IFFALSE 91470
// exit ;
91468: GO 91499
// for i in tmp do
91470: LD_ADDR_VAR 0 1
91474: PUSH
91475: LD_VAR 0 2
91479: PUSH
91480: FOR_IN
91481: IFFALSE 91497
// SetBLevel ( i , 10 ) ;
91483: LD_VAR 0 1
91487: PPUSH
91488: LD_INT 10
91490: PPUSH
91491: CALL_OW 241
91495: GO 91480
91497: POP
91498: POP
// end ;
91499: PPOPN 2
91501: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91502: LD_EXP 122
91506: PUSH
91507: LD_EXP 139
91511: AND
91512: IFFALSE 91623
91514: GO 91516
91516: DISABLE
91517: LD_INT 0
91519: PPUSH
91520: PPUSH
91521: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91522: LD_ADDR_VAR 0 3
91526: PUSH
91527: LD_INT 22
91529: PUSH
91530: LD_OWVAR 2
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 25
91541: PUSH
91542: LD_INT 1
91544: PUSH
91545: EMPTY
91546: LIST
91547: LIST
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PPUSH
91553: CALL_OW 69
91557: ST_TO_ADDR
// if not tmp then
91558: LD_VAR 0 3
91562: NOT
91563: IFFALSE 91567
// exit ;
91565: GO 91623
// un := tmp [ rand ( 1 , tmp ) ] ;
91567: LD_ADDR_VAR 0 2
91571: PUSH
91572: LD_VAR 0 3
91576: PUSH
91577: LD_INT 1
91579: PPUSH
91580: LD_VAR 0 3
91584: PPUSH
91585: CALL_OW 12
91589: ARRAY
91590: ST_TO_ADDR
// if Crawls ( un ) then
91591: LD_VAR 0 2
91595: PPUSH
91596: CALL_OW 318
91600: IFFALSE 91611
// ComWalk ( un ) ;
91602: LD_VAR 0 2
91606: PPUSH
91607: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91611: LD_VAR 0 2
91615: PPUSH
91616: LD_INT 5
91618: PPUSH
91619: CALL_OW 336
// end ;
91623: PPOPN 3
91625: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
91626: LD_EXP 122
91630: PUSH
91631: LD_EXP 140
91635: AND
91636: PUSH
91637: LD_OWVAR 67
91641: PUSH
91642: LD_INT 4
91644: LESS
91645: AND
91646: IFFALSE 91665
91648: GO 91650
91650: DISABLE
// begin Difficulty := Difficulty + 1 ;
91651: LD_ADDR_OWVAR 67
91655: PUSH
91656: LD_OWVAR 67
91660: PUSH
91661: LD_INT 1
91663: PLUS
91664: ST_TO_ADDR
// end ;
91665: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
91666: LD_EXP 122
91670: PUSH
91671: LD_EXP 141
91675: AND
91676: IFFALSE 91779
91678: GO 91680
91680: DISABLE
91681: LD_INT 0
91683: PPUSH
// begin for i := 1 to 5 do
91684: LD_ADDR_VAR 0 1
91688: PUSH
91689: DOUBLE
91690: LD_INT 1
91692: DEC
91693: ST_TO_ADDR
91694: LD_INT 5
91696: PUSH
91697: FOR_TO
91698: IFFALSE 91777
// begin uc_nation := nation_nature ;
91700: LD_ADDR_OWVAR 21
91704: PUSH
91705: LD_INT 0
91707: ST_TO_ADDR
// uc_side := 0 ;
91708: LD_ADDR_OWVAR 20
91712: PUSH
91713: LD_INT 0
91715: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91716: LD_ADDR_OWVAR 29
91720: PUSH
91721: LD_INT 12
91723: PUSH
91724: LD_INT 12
91726: PUSH
91727: EMPTY
91728: LIST
91729: LIST
91730: ST_TO_ADDR
// hc_agressivity := 20 ;
91731: LD_ADDR_OWVAR 35
91735: PUSH
91736: LD_INT 20
91738: ST_TO_ADDR
// hc_class := class_tiger ;
91739: LD_ADDR_OWVAR 28
91743: PUSH
91744: LD_INT 14
91746: ST_TO_ADDR
// hc_gallery :=  ;
91747: LD_ADDR_OWVAR 33
91751: PUSH
91752: LD_STRING 
91754: ST_TO_ADDR
// hc_name :=  ;
91755: LD_ADDR_OWVAR 26
91759: PUSH
91760: LD_STRING 
91762: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91763: CALL_OW 44
91767: PPUSH
91768: LD_INT 0
91770: PPUSH
91771: CALL_OW 51
// end ;
91775: GO 91697
91777: POP
91778: POP
// end ;
91779: PPOPN 1
91781: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91782: LD_EXP 122
91786: PUSH
91787: LD_EXP 142
91791: AND
91792: IFFALSE 91801
91794: GO 91796
91796: DISABLE
// StreamSibBomb ;
91797: CALL 91802 0 0
91801: END
// export function StreamSibBomb ; var i , x , y ; begin
91802: LD_INT 0
91804: PPUSH
91805: PPUSH
91806: PPUSH
91807: PPUSH
// result := false ;
91808: LD_ADDR_VAR 0 1
91812: PUSH
91813: LD_INT 0
91815: ST_TO_ADDR
// for i := 1 to 16 do
91816: LD_ADDR_VAR 0 2
91820: PUSH
91821: DOUBLE
91822: LD_INT 1
91824: DEC
91825: ST_TO_ADDR
91826: LD_INT 16
91828: PUSH
91829: FOR_TO
91830: IFFALSE 92029
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91832: LD_ADDR_VAR 0 3
91836: PUSH
91837: LD_INT 10
91839: PUSH
91840: LD_INT 20
91842: PUSH
91843: LD_INT 30
91845: PUSH
91846: LD_INT 40
91848: PUSH
91849: LD_INT 50
91851: PUSH
91852: LD_INT 60
91854: PUSH
91855: LD_INT 70
91857: PUSH
91858: LD_INT 80
91860: PUSH
91861: LD_INT 90
91863: PUSH
91864: LD_INT 100
91866: PUSH
91867: LD_INT 110
91869: PUSH
91870: LD_INT 120
91872: PUSH
91873: LD_INT 130
91875: PUSH
91876: LD_INT 140
91878: PUSH
91879: LD_INT 150
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 1
91901: PPUSH
91902: LD_INT 15
91904: PPUSH
91905: CALL_OW 12
91909: ARRAY
91910: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91911: LD_ADDR_VAR 0 4
91915: PUSH
91916: LD_INT 10
91918: PUSH
91919: LD_INT 20
91921: PUSH
91922: LD_INT 30
91924: PUSH
91925: LD_INT 40
91927: PUSH
91928: LD_INT 50
91930: PUSH
91931: LD_INT 60
91933: PUSH
91934: LD_INT 70
91936: PUSH
91937: LD_INT 80
91939: PUSH
91940: LD_INT 90
91942: PUSH
91943: LD_INT 100
91945: PUSH
91946: LD_INT 110
91948: PUSH
91949: LD_INT 120
91951: PUSH
91952: LD_INT 130
91954: PUSH
91955: LD_INT 140
91957: PUSH
91958: LD_INT 150
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: PUSH
91978: LD_INT 1
91980: PPUSH
91981: LD_INT 15
91983: PPUSH
91984: CALL_OW 12
91988: ARRAY
91989: ST_TO_ADDR
// if ValidHex ( x , y ) then
91990: LD_VAR 0 3
91994: PPUSH
91995: LD_VAR 0 4
91999: PPUSH
92000: CALL_OW 488
92004: IFFALSE 92027
// begin result := [ x , y ] ;
92006: LD_ADDR_VAR 0 1
92010: PUSH
92011: LD_VAR 0 3
92015: PUSH
92016: LD_VAR 0 4
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: ST_TO_ADDR
// break ;
92025: GO 92029
// end ; end ;
92027: GO 91829
92029: POP
92030: POP
// if result then
92031: LD_VAR 0 1
92035: IFFALSE 92095
// begin ToLua ( playSibBomb() ) ;
92037: LD_STRING playSibBomb()
92039: PPUSH
92040: CALL_OW 559
// wait ( 0 0$14 ) ;
92044: LD_INT 490
92046: PPUSH
92047: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92051: LD_VAR 0 1
92055: PUSH
92056: LD_INT 1
92058: ARRAY
92059: PPUSH
92060: LD_VAR 0 1
92064: PUSH
92065: LD_INT 2
92067: ARRAY
92068: PPUSH
92069: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92073: LD_VAR 0 1
92077: PUSH
92078: LD_INT 1
92080: ARRAY
92081: PPUSH
92082: LD_VAR 0 1
92086: PUSH
92087: LD_INT 2
92089: ARRAY
92090: PPUSH
92091: CALL_OW 429
// end ; end ;
92095: LD_VAR 0 1
92099: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92100: LD_EXP 122
92104: PUSH
92105: LD_EXP 144
92109: AND
92110: IFFALSE 92122
92112: GO 92114
92114: DISABLE
// YouLost (  ) ;
92115: LD_STRING 
92117: PPUSH
92118: CALL_OW 104
92122: END
// every 0 0$1 trigger StreamModeActive and sFog do
92123: LD_EXP 122
92127: PUSH
92128: LD_EXP 143
92132: AND
92133: IFFALSE 92147
92135: GO 92137
92137: DISABLE
// FogOff ( your_side ) ;
92138: LD_OWVAR 2
92142: PPUSH
92143: CALL_OW 344
92147: END
// every 0 0$1 trigger StreamModeActive and sSun do
92148: LD_EXP 122
92152: PUSH
92153: LD_EXP 145
92157: AND
92158: IFFALSE 92186
92160: GO 92162
92162: DISABLE
// begin solar_recharge_percent := 0 ;
92163: LD_ADDR_OWVAR 79
92167: PUSH
92168: LD_INT 0
92170: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92171: LD_INT 10500
92173: PPUSH
92174: CALL_OW 67
// solar_recharge_percent := 100 ;
92178: LD_ADDR_OWVAR 79
92182: PUSH
92183: LD_INT 100
92185: ST_TO_ADDR
// end ;
92186: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92187: LD_EXP 122
92191: PUSH
92192: LD_EXP 146
92196: AND
92197: IFFALSE 92436
92199: GO 92201
92201: DISABLE
92202: LD_INT 0
92204: PPUSH
92205: PPUSH
92206: PPUSH
// begin tmp := [ ] ;
92207: LD_ADDR_VAR 0 3
92211: PUSH
92212: EMPTY
92213: ST_TO_ADDR
// for i := 1 to 6 do
92214: LD_ADDR_VAR 0 1
92218: PUSH
92219: DOUBLE
92220: LD_INT 1
92222: DEC
92223: ST_TO_ADDR
92224: LD_INT 6
92226: PUSH
92227: FOR_TO
92228: IFFALSE 92333
// begin uc_nation := nation_nature ;
92230: LD_ADDR_OWVAR 21
92234: PUSH
92235: LD_INT 0
92237: ST_TO_ADDR
// uc_side := 0 ;
92238: LD_ADDR_OWVAR 20
92242: PUSH
92243: LD_INT 0
92245: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92246: LD_ADDR_OWVAR 29
92250: PUSH
92251: LD_INT 12
92253: PUSH
92254: LD_INT 12
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: ST_TO_ADDR
// hc_agressivity := 20 ;
92261: LD_ADDR_OWVAR 35
92265: PUSH
92266: LD_INT 20
92268: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92269: LD_ADDR_OWVAR 28
92273: PUSH
92274: LD_INT 17
92276: ST_TO_ADDR
// hc_gallery :=  ;
92277: LD_ADDR_OWVAR 33
92281: PUSH
92282: LD_STRING 
92284: ST_TO_ADDR
// hc_name :=  ;
92285: LD_ADDR_OWVAR 26
92289: PUSH
92290: LD_STRING 
92292: ST_TO_ADDR
// un := CreateHuman ;
92293: LD_ADDR_VAR 0 2
92297: PUSH
92298: CALL_OW 44
92302: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92303: LD_VAR 0 2
92307: PPUSH
92308: LD_INT 1
92310: PPUSH
92311: CALL_OW 51
// tmp := tmp ^ un ;
92315: LD_ADDR_VAR 0 3
92319: PUSH
92320: LD_VAR 0 3
92324: PUSH
92325: LD_VAR 0 2
92329: ADD
92330: ST_TO_ADDR
// end ;
92331: GO 92227
92333: POP
92334: POP
// repeat wait ( 0 0$1 ) ;
92335: LD_INT 35
92337: PPUSH
92338: CALL_OW 67
// for un in tmp do
92342: LD_ADDR_VAR 0 2
92346: PUSH
92347: LD_VAR 0 3
92351: PUSH
92352: FOR_IN
92353: IFFALSE 92427
// begin if IsDead ( un ) then
92355: LD_VAR 0 2
92359: PPUSH
92360: CALL_OW 301
92364: IFFALSE 92384
// begin tmp := tmp diff un ;
92366: LD_ADDR_VAR 0 3
92370: PUSH
92371: LD_VAR 0 3
92375: PUSH
92376: LD_VAR 0 2
92380: DIFF
92381: ST_TO_ADDR
// continue ;
92382: GO 92352
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92384: LD_VAR 0 2
92388: PPUSH
92389: LD_INT 3
92391: PUSH
92392: LD_INT 22
92394: PUSH
92395: LD_INT 0
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PPUSH
92406: CALL_OW 69
92410: PPUSH
92411: LD_VAR 0 2
92415: PPUSH
92416: CALL_OW 74
92420: PPUSH
92421: CALL_OW 115
// end ;
92425: GO 92352
92427: POP
92428: POP
// until not tmp ;
92429: LD_VAR 0 3
92433: NOT
92434: IFFALSE 92335
// end ;
92436: PPOPN 3
92438: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92439: LD_EXP 122
92443: PUSH
92444: LD_EXP 147
92448: AND
92449: IFFALSE 92503
92451: GO 92453
92453: DISABLE
// begin ToLua ( displayTroll(); ) ;
92454: LD_STRING displayTroll();
92456: PPUSH
92457: CALL_OW 559
// wait ( 3 3$00 ) ;
92461: LD_INT 6300
92463: PPUSH
92464: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92468: LD_STRING hideTroll();
92470: PPUSH
92471: CALL_OW 559
// wait ( 1 1$00 ) ;
92475: LD_INT 2100
92477: PPUSH
92478: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92482: LD_STRING displayTroll();
92484: PPUSH
92485: CALL_OW 559
// wait ( 1 1$00 ) ;
92489: LD_INT 2100
92491: PPUSH
92492: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92496: LD_STRING hideTroll();
92498: PPUSH
92499: CALL_OW 559
// end ;
92503: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92504: LD_EXP 122
92508: PUSH
92509: LD_EXP 148
92513: AND
92514: IFFALSE 92577
92516: GO 92518
92518: DISABLE
92519: LD_INT 0
92521: PPUSH
// begin p := 0 ;
92522: LD_ADDR_VAR 0 1
92526: PUSH
92527: LD_INT 0
92529: ST_TO_ADDR
// repeat game_speed := 1 ;
92530: LD_ADDR_OWVAR 65
92534: PUSH
92535: LD_INT 1
92537: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92538: LD_INT 35
92540: PPUSH
92541: CALL_OW 67
// p := p + 1 ;
92545: LD_ADDR_VAR 0 1
92549: PUSH
92550: LD_VAR 0 1
92554: PUSH
92555: LD_INT 1
92557: PLUS
92558: ST_TO_ADDR
// until p >= 60 ;
92559: LD_VAR 0 1
92563: PUSH
92564: LD_INT 60
92566: GREATEREQUAL
92567: IFFALSE 92530
// game_speed := 4 ;
92569: LD_ADDR_OWVAR 65
92573: PUSH
92574: LD_INT 4
92576: ST_TO_ADDR
// end ;
92577: PPOPN 1
92579: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92580: LD_EXP 122
92584: PUSH
92585: LD_EXP 149
92589: AND
92590: IFFALSE 92736
92592: GO 92594
92594: DISABLE
92595: LD_INT 0
92597: PPUSH
92598: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92599: LD_ADDR_VAR 0 1
92603: PUSH
92604: LD_INT 22
92606: PUSH
92607: LD_OWVAR 2
92611: PUSH
92612: EMPTY
92613: LIST
92614: LIST
92615: PUSH
92616: LD_INT 2
92618: PUSH
92619: LD_INT 30
92621: PUSH
92622: LD_INT 0
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 30
92631: PUSH
92632: LD_INT 1
92634: PUSH
92635: EMPTY
92636: LIST
92637: LIST
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: LIST
92643: PUSH
92644: EMPTY
92645: LIST
92646: LIST
92647: PPUSH
92648: CALL_OW 69
92652: ST_TO_ADDR
// if not depot then
92653: LD_VAR 0 1
92657: NOT
92658: IFFALSE 92662
// exit ;
92660: GO 92736
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
92662: LD_ADDR_VAR 0 2
92666: PUSH
92667: LD_VAR 0 1
92671: PUSH
92672: LD_INT 1
92674: PPUSH
92675: LD_VAR 0 1
92679: PPUSH
92680: CALL_OW 12
92684: ARRAY
92685: PPUSH
92686: CALL_OW 274
92690: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92691: LD_VAR 0 2
92695: PPUSH
92696: LD_INT 1
92698: PPUSH
92699: LD_INT 0
92701: PPUSH
92702: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92706: LD_VAR 0 2
92710: PPUSH
92711: LD_INT 2
92713: PPUSH
92714: LD_INT 0
92716: PPUSH
92717: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92721: LD_VAR 0 2
92725: PPUSH
92726: LD_INT 3
92728: PPUSH
92729: LD_INT 0
92731: PPUSH
92732: CALL_OW 277
// end ;
92736: PPOPN 2
92738: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92739: LD_EXP 122
92743: PUSH
92744: LD_EXP 150
92748: AND
92749: IFFALSE 92846
92751: GO 92753
92753: DISABLE
92754: LD_INT 0
92756: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92757: LD_ADDR_VAR 0 1
92761: PUSH
92762: LD_INT 22
92764: PUSH
92765: LD_OWVAR 2
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PUSH
92774: LD_INT 21
92776: PUSH
92777: LD_INT 1
92779: PUSH
92780: EMPTY
92781: LIST
92782: LIST
92783: PUSH
92784: LD_INT 3
92786: PUSH
92787: LD_INT 23
92789: PUSH
92790: LD_INT 0
92792: PUSH
92793: EMPTY
92794: LIST
92795: LIST
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: LIST
92805: PPUSH
92806: CALL_OW 69
92810: ST_TO_ADDR
// if not tmp then
92811: LD_VAR 0 1
92815: NOT
92816: IFFALSE 92820
// exit ;
92818: GO 92846
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92820: LD_VAR 0 1
92824: PUSH
92825: LD_INT 1
92827: PPUSH
92828: LD_VAR 0 1
92832: PPUSH
92833: CALL_OW 12
92837: ARRAY
92838: PPUSH
92839: LD_INT 200
92841: PPUSH
92842: CALL_OW 234
// end ;
92846: PPOPN 1
92848: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92849: LD_EXP 122
92853: PUSH
92854: LD_EXP 151
92858: AND
92859: IFFALSE 92938
92861: GO 92863
92863: DISABLE
92864: LD_INT 0
92866: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92867: LD_ADDR_VAR 0 1
92871: PUSH
92872: LD_INT 22
92874: PUSH
92875: LD_OWVAR 2
92879: PUSH
92880: EMPTY
92881: LIST
92882: LIST
92883: PUSH
92884: LD_INT 21
92886: PUSH
92887: LD_INT 2
92889: PUSH
92890: EMPTY
92891: LIST
92892: LIST
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PPUSH
92898: CALL_OW 69
92902: ST_TO_ADDR
// if not tmp then
92903: LD_VAR 0 1
92907: NOT
92908: IFFALSE 92912
// exit ;
92910: GO 92938
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92912: LD_VAR 0 1
92916: PUSH
92917: LD_INT 1
92919: PPUSH
92920: LD_VAR 0 1
92924: PPUSH
92925: CALL_OW 12
92929: ARRAY
92930: PPUSH
92931: LD_INT 60
92933: PPUSH
92934: CALL_OW 234
// end ;
92938: PPOPN 1
92940: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
92941: LD_EXP 122
92945: PUSH
92946: LD_EXP 152
92950: AND
92951: IFFALSE 93050
92953: GO 92955
92955: DISABLE
92956: LD_INT 0
92958: PPUSH
92959: PPUSH
// begin enable ;
92960: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
92961: LD_ADDR_VAR 0 1
92965: PUSH
92966: LD_INT 22
92968: PUSH
92969: LD_OWVAR 2
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: PUSH
92978: LD_INT 61
92980: PUSH
92981: EMPTY
92982: LIST
92983: PUSH
92984: LD_INT 33
92986: PUSH
92987: LD_INT 2
92989: PUSH
92990: EMPTY
92991: LIST
92992: LIST
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: LIST
92998: PPUSH
92999: CALL_OW 69
93003: ST_TO_ADDR
// if not tmp then
93004: LD_VAR 0 1
93008: NOT
93009: IFFALSE 93013
// exit ;
93011: GO 93050
// for i in tmp do
93013: LD_ADDR_VAR 0 2
93017: PUSH
93018: LD_VAR 0 1
93022: PUSH
93023: FOR_IN
93024: IFFALSE 93048
// if IsControledBy ( i ) then
93026: LD_VAR 0 2
93030: PPUSH
93031: CALL_OW 312
93035: IFFALSE 93046
// ComUnlink ( i ) ;
93037: LD_VAR 0 2
93041: PPUSH
93042: CALL_OW 136
93046: GO 93023
93048: POP
93049: POP
// end ;
93050: PPOPN 2
93052: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93053: LD_EXP 122
93057: PUSH
93058: LD_EXP 153
93062: AND
93063: IFFALSE 93203
93065: GO 93067
93067: DISABLE
93068: LD_INT 0
93070: PPUSH
93071: PPUSH
// begin ToLua ( displayPowell(); ) ;
93072: LD_STRING displayPowell();
93074: PPUSH
93075: CALL_OW 559
// uc_side := 0 ;
93079: LD_ADDR_OWVAR 20
93083: PUSH
93084: LD_INT 0
93086: ST_TO_ADDR
// uc_nation := 2 ;
93087: LD_ADDR_OWVAR 21
93091: PUSH
93092: LD_INT 2
93094: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93095: LD_ADDR_OWVAR 37
93099: PUSH
93100: LD_INT 14
93102: ST_TO_ADDR
// vc_engine := engine_siberite ;
93103: LD_ADDR_OWVAR 39
93107: PUSH
93108: LD_INT 3
93110: ST_TO_ADDR
// vc_control := control_apeman ;
93111: LD_ADDR_OWVAR 38
93115: PUSH
93116: LD_INT 5
93118: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93119: LD_ADDR_OWVAR 40
93123: PUSH
93124: LD_INT 29
93126: ST_TO_ADDR
// un := CreateVehicle ;
93127: LD_ADDR_VAR 0 2
93131: PUSH
93132: CALL_OW 45
93136: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93137: LD_VAR 0 2
93141: PPUSH
93142: LD_INT 1
93144: PPUSH
93145: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93149: LD_INT 35
93151: PPUSH
93152: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93156: LD_VAR 0 2
93160: PPUSH
93161: LD_INT 22
93163: PUSH
93164: LD_OWVAR 2
93168: PUSH
93169: EMPTY
93170: LIST
93171: LIST
93172: PPUSH
93173: CALL_OW 69
93177: PPUSH
93178: LD_VAR 0 2
93182: PPUSH
93183: CALL_OW 74
93187: PPUSH
93188: CALL_OW 115
// until IsDead ( un ) ;
93192: LD_VAR 0 2
93196: PPUSH
93197: CALL_OW 301
93201: IFFALSE 93149
// end ;
93203: PPOPN 2
93205: END
// every 0 0$1 trigger StreamModeActive and sStu do
93206: LD_EXP 122
93210: PUSH
93211: LD_EXP 161
93215: AND
93216: IFFALSE 93232
93218: GO 93220
93220: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93221: LD_STRING displayStucuk();
93223: PPUSH
93224: CALL_OW 559
// ResetFog ;
93228: CALL_OW 335
// end ;
93232: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93233: LD_EXP 122
93237: PUSH
93238: LD_EXP 154
93242: AND
93243: IFFALSE 93384
93245: GO 93247
93247: DISABLE
93248: LD_INT 0
93250: PPUSH
93251: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93252: LD_ADDR_VAR 0 2
93256: PUSH
93257: LD_INT 22
93259: PUSH
93260: LD_OWVAR 2
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 21
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: PPUSH
93283: CALL_OW 69
93287: ST_TO_ADDR
// if not tmp then
93288: LD_VAR 0 2
93292: NOT
93293: IFFALSE 93297
// exit ;
93295: GO 93384
// un := tmp [ rand ( 1 , tmp ) ] ;
93297: LD_ADDR_VAR 0 1
93301: PUSH
93302: LD_VAR 0 2
93306: PUSH
93307: LD_INT 1
93309: PPUSH
93310: LD_VAR 0 2
93314: PPUSH
93315: CALL_OW 12
93319: ARRAY
93320: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93321: LD_VAR 0 1
93325: PPUSH
93326: LD_INT 0
93328: PPUSH
93329: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93333: LD_VAR 0 1
93337: PPUSH
93338: LD_OWVAR 3
93342: PUSH
93343: LD_VAR 0 1
93347: DIFF
93348: PPUSH
93349: LD_VAR 0 1
93353: PPUSH
93354: CALL_OW 74
93358: PPUSH
93359: CALL_OW 115
// wait ( 0 0$20 ) ;
93363: LD_INT 700
93365: PPUSH
93366: CALL_OW 67
// SetSide ( un , your_side ) ;
93370: LD_VAR 0 1
93374: PPUSH
93375: LD_OWVAR 2
93379: PPUSH
93380: CALL_OW 235
// end ;
93384: PPOPN 2
93386: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93387: LD_EXP 122
93391: PUSH
93392: LD_EXP 155
93396: AND
93397: IFFALSE 93503
93399: GO 93401
93401: DISABLE
93402: LD_INT 0
93404: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93405: LD_ADDR_VAR 0 1
93409: PUSH
93410: LD_INT 22
93412: PUSH
93413: LD_OWVAR 2
93417: PUSH
93418: EMPTY
93419: LIST
93420: LIST
93421: PUSH
93422: LD_INT 2
93424: PUSH
93425: LD_INT 30
93427: PUSH
93428: LD_INT 0
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 30
93437: PUSH
93438: LD_INT 1
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PPUSH
93454: CALL_OW 69
93458: ST_TO_ADDR
// if not depot then
93459: LD_VAR 0 1
93463: NOT
93464: IFFALSE 93468
// exit ;
93466: GO 93503
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93468: LD_VAR 0 1
93472: PUSH
93473: LD_INT 1
93475: ARRAY
93476: PPUSH
93477: CALL_OW 250
93481: PPUSH
93482: LD_VAR 0 1
93486: PUSH
93487: LD_INT 1
93489: ARRAY
93490: PPUSH
93491: CALL_OW 251
93495: PPUSH
93496: LD_INT 70
93498: PPUSH
93499: CALL_OW 495
// end ;
93503: PPOPN 1
93505: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93506: LD_EXP 122
93510: PUSH
93511: LD_EXP 156
93515: AND
93516: IFFALSE 93727
93518: GO 93520
93520: DISABLE
93521: LD_INT 0
93523: PPUSH
93524: PPUSH
93525: PPUSH
93526: PPUSH
93527: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93528: LD_ADDR_VAR 0 5
93532: PUSH
93533: LD_INT 22
93535: PUSH
93536: LD_OWVAR 2
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: LD_INT 21
93547: PUSH
93548: LD_INT 1
93550: PUSH
93551: EMPTY
93552: LIST
93553: LIST
93554: PUSH
93555: EMPTY
93556: LIST
93557: LIST
93558: PPUSH
93559: CALL_OW 69
93563: ST_TO_ADDR
// if not tmp then
93564: LD_VAR 0 5
93568: NOT
93569: IFFALSE 93573
// exit ;
93571: GO 93727
// for i in tmp do
93573: LD_ADDR_VAR 0 1
93577: PUSH
93578: LD_VAR 0 5
93582: PUSH
93583: FOR_IN
93584: IFFALSE 93725
// begin d := rand ( 0 , 5 ) ;
93586: LD_ADDR_VAR 0 4
93590: PUSH
93591: LD_INT 0
93593: PPUSH
93594: LD_INT 5
93596: PPUSH
93597: CALL_OW 12
93601: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93602: LD_ADDR_VAR 0 2
93606: PUSH
93607: LD_VAR 0 1
93611: PPUSH
93612: CALL_OW 250
93616: PPUSH
93617: LD_VAR 0 4
93621: PPUSH
93622: LD_INT 3
93624: PPUSH
93625: LD_INT 12
93627: PPUSH
93628: CALL_OW 12
93632: PPUSH
93633: CALL_OW 272
93637: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93638: LD_ADDR_VAR 0 3
93642: PUSH
93643: LD_VAR 0 1
93647: PPUSH
93648: CALL_OW 251
93652: PPUSH
93653: LD_VAR 0 4
93657: PPUSH
93658: LD_INT 3
93660: PPUSH
93661: LD_INT 12
93663: PPUSH
93664: CALL_OW 12
93668: PPUSH
93669: CALL_OW 273
93673: ST_TO_ADDR
// if ValidHex ( x , y ) then
93674: LD_VAR 0 2
93678: PPUSH
93679: LD_VAR 0 3
93683: PPUSH
93684: CALL_OW 488
93688: IFFALSE 93723
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93690: LD_VAR 0 1
93694: PPUSH
93695: LD_VAR 0 2
93699: PPUSH
93700: LD_VAR 0 3
93704: PPUSH
93705: LD_INT 3
93707: PPUSH
93708: LD_INT 6
93710: PPUSH
93711: CALL_OW 12
93715: PPUSH
93716: LD_INT 1
93718: PPUSH
93719: CALL_OW 483
// end ;
93723: GO 93583
93725: POP
93726: POP
// end ;
93727: PPOPN 5
93729: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93730: LD_EXP 122
93734: PUSH
93735: LD_EXP 157
93739: AND
93740: IFFALSE 93834
93742: GO 93744
93744: DISABLE
93745: LD_INT 0
93747: PPUSH
93748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93749: LD_ADDR_VAR 0 2
93753: PUSH
93754: LD_INT 22
93756: PUSH
93757: LD_OWVAR 2
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: PUSH
93766: LD_INT 32
93768: PUSH
93769: LD_INT 1
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: PUSH
93776: LD_INT 21
93778: PUSH
93779: LD_INT 2
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: EMPTY
93787: LIST
93788: LIST
93789: LIST
93790: PPUSH
93791: CALL_OW 69
93795: ST_TO_ADDR
// if not tmp then
93796: LD_VAR 0 2
93800: NOT
93801: IFFALSE 93805
// exit ;
93803: GO 93834
// for i in tmp do
93805: LD_ADDR_VAR 0 1
93809: PUSH
93810: LD_VAR 0 2
93814: PUSH
93815: FOR_IN
93816: IFFALSE 93832
// SetFuel ( i , 0 ) ;
93818: LD_VAR 0 1
93822: PPUSH
93823: LD_INT 0
93825: PPUSH
93826: CALL_OW 240
93830: GO 93815
93832: POP
93833: POP
// end ;
93834: PPOPN 2
93836: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93837: LD_EXP 122
93841: PUSH
93842: LD_EXP 158
93846: AND
93847: IFFALSE 93913
93849: GO 93851
93851: DISABLE
93852: LD_INT 0
93854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93855: LD_ADDR_VAR 0 1
93859: PUSH
93860: LD_INT 22
93862: PUSH
93863: LD_OWVAR 2
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 30
93874: PUSH
93875: LD_INT 29
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: PPUSH
93886: CALL_OW 69
93890: ST_TO_ADDR
// if not tmp then
93891: LD_VAR 0 1
93895: NOT
93896: IFFALSE 93900
// exit ;
93898: GO 93913
// DestroyUnit ( tmp [ 1 ] ) ;
93900: LD_VAR 0 1
93904: PUSH
93905: LD_INT 1
93907: ARRAY
93908: PPUSH
93909: CALL_OW 65
// end ;
93913: PPOPN 1
93915: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93916: LD_EXP 122
93920: PUSH
93921: LD_EXP 160
93925: AND
93926: IFFALSE 94055
93928: GO 93930
93930: DISABLE
93931: LD_INT 0
93933: PPUSH
// begin uc_side := 0 ;
93934: LD_ADDR_OWVAR 20
93938: PUSH
93939: LD_INT 0
93941: ST_TO_ADDR
// uc_nation := nation_arabian ;
93942: LD_ADDR_OWVAR 21
93946: PUSH
93947: LD_INT 2
93949: ST_TO_ADDR
// hc_gallery :=  ;
93950: LD_ADDR_OWVAR 33
93954: PUSH
93955: LD_STRING 
93957: ST_TO_ADDR
// hc_name :=  ;
93958: LD_ADDR_OWVAR 26
93962: PUSH
93963: LD_STRING 
93965: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
93966: LD_INT 1
93968: PPUSH
93969: LD_INT 11
93971: PPUSH
93972: LD_INT 10
93974: PPUSH
93975: CALL_OW 380
// un := CreateHuman ;
93979: LD_ADDR_VAR 0 1
93983: PUSH
93984: CALL_OW 44
93988: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93989: LD_VAR 0 1
93993: PPUSH
93994: LD_INT 1
93996: PPUSH
93997: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94001: LD_INT 35
94003: PPUSH
94004: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94008: LD_VAR 0 1
94012: PPUSH
94013: LD_INT 22
94015: PUSH
94016: LD_OWVAR 2
94020: PUSH
94021: EMPTY
94022: LIST
94023: LIST
94024: PPUSH
94025: CALL_OW 69
94029: PPUSH
94030: LD_VAR 0 1
94034: PPUSH
94035: CALL_OW 74
94039: PPUSH
94040: CALL_OW 115
// until IsDead ( un ) ;
94044: LD_VAR 0 1
94048: PPUSH
94049: CALL_OW 301
94053: IFFALSE 94001
// end ;
94055: PPOPN 1
94057: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94058: LD_EXP 122
94062: PUSH
94063: LD_EXP 162
94067: AND
94068: IFFALSE 94080
94070: GO 94072
94072: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94073: LD_STRING earthquake(getX(game), 0, 32)
94075: PPUSH
94076: CALL_OW 559
94080: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94081: LD_EXP 122
94085: PUSH
94086: LD_EXP 163
94090: AND
94091: IFFALSE 94182
94093: GO 94095
94095: DISABLE
94096: LD_INT 0
94098: PPUSH
// begin enable ;
94099: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94100: LD_ADDR_VAR 0 1
94104: PUSH
94105: LD_INT 22
94107: PUSH
94108: LD_OWVAR 2
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: PUSH
94117: LD_INT 21
94119: PUSH
94120: LD_INT 2
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: PUSH
94127: LD_INT 33
94129: PUSH
94130: LD_INT 3
94132: PUSH
94133: EMPTY
94134: LIST
94135: LIST
94136: PUSH
94137: EMPTY
94138: LIST
94139: LIST
94140: LIST
94141: PPUSH
94142: CALL_OW 69
94146: ST_TO_ADDR
// if not tmp then
94147: LD_VAR 0 1
94151: NOT
94152: IFFALSE 94156
// exit ;
94154: GO 94182
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94156: LD_VAR 0 1
94160: PUSH
94161: LD_INT 1
94163: PPUSH
94164: LD_VAR 0 1
94168: PPUSH
94169: CALL_OW 12
94173: ARRAY
94174: PPUSH
94175: LD_INT 1
94177: PPUSH
94178: CALL_OW 234
// end ;
94182: PPOPN 1
94184: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94185: LD_EXP 122
94189: PUSH
94190: LD_EXP 164
94194: AND
94195: IFFALSE 94336
94197: GO 94199
94199: DISABLE
94200: LD_INT 0
94202: PPUSH
94203: PPUSH
94204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94205: LD_ADDR_VAR 0 3
94209: PUSH
94210: LD_INT 22
94212: PUSH
94213: LD_OWVAR 2
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 25
94224: PUSH
94225: LD_INT 1
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PPUSH
94236: CALL_OW 69
94240: ST_TO_ADDR
// if not tmp then
94241: LD_VAR 0 3
94245: NOT
94246: IFFALSE 94250
// exit ;
94248: GO 94336
// un := tmp [ rand ( 1 , tmp ) ] ;
94250: LD_ADDR_VAR 0 2
94254: PUSH
94255: LD_VAR 0 3
94259: PUSH
94260: LD_INT 1
94262: PPUSH
94263: LD_VAR 0 3
94267: PPUSH
94268: CALL_OW 12
94272: ARRAY
94273: ST_TO_ADDR
// if Crawls ( un ) then
94274: LD_VAR 0 2
94278: PPUSH
94279: CALL_OW 318
94283: IFFALSE 94294
// ComWalk ( un ) ;
94285: LD_VAR 0 2
94289: PPUSH
94290: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94294: LD_VAR 0 2
94298: PPUSH
94299: LD_INT 9
94301: PPUSH
94302: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94306: LD_INT 28
94308: PPUSH
94309: LD_OWVAR 2
94313: PPUSH
94314: LD_INT 2
94316: PPUSH
94317: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94321: LD_INT 29
94323: PPUSH
94324: LD_OWVAR 2
94328: PPUSH
94329: LD_INT 2
94331: PPUSH
94332: CALL_OW 322
// end ;
94336: PPOPN 3
94338: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94339: LD_EXP 122
94343: PUSH
94344: LD_EXP 165
94348: AND
94349: IFFALSE 94460
94351: GO 94353
94353: DISABLE
94354: LD_INT 0
94356: PPUSH
94357: PPUSH
94358: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94359: LD_ADDR_VAR 0 3
94363: PUSH
94364: LD_INT 22
94366: PUSH
94367: LD_OWVAR 2
94371: PUSH
94372: EMPTY
94373: LIST
94374: LIST
94375: PUSH
94376: LD_INT 25
94378: PUSH
94379: LD_INT 1
94381: PUSH
94382: EMPTY
94383: LIST
94384: LIST
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PPUSH
94390: CALL_OW 69
94394: ST_TO_ADDR
// if not tmp then
94395: LD_VAR 0 3
94399: NOT
94400: IFFALSE 94404
// exit ;
94402: GO 94460
// un := tmp [ rand ( 1 , tmp ) ] ;
94404: LD_ADDR_VAR 0 2
94408: PUSH
94409: LD_VAR 0 3
94413: PUSH
94414: LD_INT 1
94416: PPUSH
94417: LD_VAR 0 3
94421: PPUSH
94422: CALL_OW 12
94426: ARRAY
94427: ST_TO_ADDR
// if Crawls ( un ) then
94428: LD_VAR 0 2
94432: PPUSH
94433: CALL_OW 318
94437: IFFALSE 94448
// ComWalk ( un ) ;
94439: LD_VAR 0 2
94443: PPUSH
94444: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94448: LD_VAR 0 2
94452: PPUSH
94453: LD_INT 8
94455: PPUSH
94456: CALL_OW 336
// end ;
94460: PPOPN 3
94462: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94463: LD_EXP 122
94467: PUSH
94468: LD_EXP 166
94472: AND
94473: IFFALSE 94617
94475: GO 94477
94477: DISABLE
94478: LD_INT 0
94480: PPUSH
94481: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94482: LD_ADDR_VAR 0 2
94486: PUSH
94487: LD_INT 22
94489: PUSH
94490: LD_OWVAR 2
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 21
94501: PUSH
94502: LD_INT 2
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 2
94511: PUSH
94512: LD_INT 34
94514: PUSH
94515: LD_INT 12
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: LD_INT 34
94524: PUSH
94525: LD_INT 51
94527: PUSH
94528: EMPTY
94529: LIST
94530: LIST
94531: PUSH
94532: LD_INT 34
94534: PUSH
94535: LD_INT 32
94537: PUSH
94538: EMPTY
94539: LIST
94540: LIST
94541: PUSH
94542: EMPTY
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: PUSH
94548: EMPTY
94549: LIST
94550: LIST
94551: LIST
94552: PPUSH
94553: CALL_OW 69
94557: ST_TO_ADDR
// if not tmp then
94558: LD_VAR 0 2
94562: NOT
94563: IFFALSE 94567
// exit ;
94565: GO 94617
// for i in tmp do
94567: LD_ADDR_VAR 0 1
94571: PUSH
94572: LD_VAR 0 2
94576: PUSH
94577: FOR_IN
94578: IFFALSE 94615
// if GetCargo ( i , mat_artifact ) = 0 then
94580: LD_VAR 0 1
94584: PPUSH
94585: LD_INT 4
94587: PPUSH
94588: CALL_OW 289
94592: PUSH
94593: LD_INT 0
94595: EQUAL
94596: IFFALSE 94613
// SetCargo ( i , mat_siberit , 100 ) ;
94598: LD_VAR 0 1
94602: PPUSH
94603: LD_INT 3
94605: PPUSH
94606: LD_INT 100
94608: PPUSH
94609: CALL_OW 290
94613: GO 94577
94615: POP
94616: POP
// end ;
94617: PPOPN 2
94619: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94620: LD_EXP 122
94624: PUSH
94625: LD_EXP 167
94629: AND
94630: IFFALSE 94813
94632: GO 94634
94634: DISABLE
94635: LD_INT 0
94637: PPUSH
94638: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94639: LD_ADDR_VAR 0 2
94643: PUSH
94644: LD_INT 22
94646: PUSH
94647: LD_OWVAR 2
94651: PUSH
94652: EMPTY
94653: LIST
94654: LIST
94655: PPUSH
94656: CALL_OW 69
94660: ST_TO_ADDR
// if not tmp then
94661: LD_VAR 0 2
94665: NOT
94666: IFFALSE 94670
// exit ;
94668: GO 94813
// for i := 1 to 2 do
94670: LD_ADDR_VAR 0 1
94674: PUSH
94675: DOUBLE
94676: LD_INT 1
94678: DEC
94679: ST_TO_ADDR
94680: LD_INT 2
94682: PUSH
94683: FOR_TO
94684: IFFALSE 94811
// begin uc_side := your_side ;
94686: LD_ADDR_OWVAR 20
94690: PUSH
94691: LD_OWVAR 2
94695: ST_TO_ADDR
// uc_nation := nation_american ;
94696: LD_ADDR_OWVAR 21
94700: PUSH
94701: LD_INT 1
94703: ST_TO_ADDR
// vc_chassis := us_morphling ;
94704: LD_ADDR_OWVAR 37
94708: PUSH
94709: LD_INT 5
94711: ST_TO_ADDR
// vc_engine := engine_siberite ;
94712: LD_ADDR_OWVAR 39
94716: PUSH
94717: LD_INT 3
94719: ST_TO_ADDR
// vc_control := control_computer ;
94720: LD_ADDR_OWVAR 38
94724: PUSH
94725: LD_INT 3
94727: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94728: LD_ADDR_OWVAR 40
94732: PUSH
94733: LD_INT 10
94735: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94736: LD_VAR 0 2
94740: PUSH
94741: LD_INT 1
94743: ARRAY
94744: PPUSH
94745: CALL_OW 310
94749: NOT
94750: IFFALSE 94797
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94752: CALL_OW 45
94756: PPUSH
94757: LD_VAR 0 2
94761: PUSH
94762: LD_INT 1
94764: ARRAY
94765: PPUSH
94766: CALL_OW 250
94770: PPUSH
94771: LD_VAR 0 2
94775: PUSH
94776: LD_INT 1
94778: ARRAY
94779: PPUSH
94780: CALL_OW 251
94784: PPUSH
94785: LD_INT 12
94787: PPUSH
94788: LD_INT 1
94790: PPUSH
94791: CALL_OW 50
94795: GO 94809
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94797: CALL_OW 45
94801: PPUSH
94802: LD_INT 1
94804: PPUSH
94805: CALL_OW 51
// end ;
94809: GO 94683
94811: POP
94812: POP
// end ;
94813: PPOPN 2
94815: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94816: LD_EXP 122
94820: PUSH
94821: LD_EXP 168
94825: AND
94826: IFFALSE 95048
94828: GO 94830
94830: DISABLE
94831: LD_INT 0
94833: PPUSH
94834: PPUSH
94835: PPUSH
94836: PPUSH
94837: PPUSH
94838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94839: LD_ADDR_VAR 0 6
94843: PUSH
94844: LD_INT 22
94846: PUSH
94847: LD_OWVAR 2
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 21
94858: PUSH
94859: LD_INT 1
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 3
94868: PUSH
94869: LD_INT 23
94871: PUSH
94872: LD_INT 0
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: EMPTY
94884: LIST
94885: LIST
94886: LIST
94887: PPUSH
94888: CALL_OW 69
94892: ST_TO_ADDR
// if not tmp then
94893: LD_VAR 0 6
94897: NOT
94898: IFFALSE 94902
// exit ;
94900: GO 95048
// s1 := rand ( 1 , 4 ) ;
94902: LD_ADDR_VAR 0 2
94906: PUSH
94907: LD_INT 1
94909: PPUSH
94910: LD_INT 4
94912: PPUSH
94913: CALL_OW 12
94917: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94918: LD_ADDR_VAR 0 4
94922: PUSH
94923: LD_VAR 0 6
94927: PUSH
94928: LD_INT 1
94930: ARRAY
94931: PPUSH
94932: LD_VAR 0 2
94936: PPUSH
94937: CALL_OW 259
94941: ST_TO_ADDR
// if s1 = 1 then
94942: LD_VAR 0 2
94946: PUSH
94947: LD_INT 1
94949: EQUAL
94950: IFFALSE 94970
// s2 := rand ( 2 , 4 ) else
94952: LD_ADDR_VAR 0 3
94956: PUSH
94957: LD_INT 2
94959: PPUSH
94960: LD_INT 4
94962: PPUSH
94963: CALL_OW 12
94967: ST_TO_ADDR
94968: GO 94978
// s2 := 1 ;
94970: LD_ADDR_VAR 0 3
94974: PUSH
94975: LD_INT 1
94977: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
94978: LD_ADDR_VAR 0 5
94982: PUSH
94983: LD_VAR 0 6
94987: PUSH
94988: LD_INT 1
94990: ARRAY
94991: PPUSH
94992: LD_VAR 0 3
94996: PPUSH
94997: CALL_OW 259
95001: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95002: LD_VAR 0 6
95006: PUSH
95007: LD_INT 1
95009: ARRAY
95010: PPUSH
95011: LD_VAR 0 2
95015: PPUSH
95016: LD_VAR 0 5
95020: PPUSH
95021: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95025: LD_VAR 0 6
95029: PUSH
95030: LD_INT 1
95032: ARRAY
95033: PPUSH
95034: LD_VAR 0 3
95038: PPUSH
95039: LD_VAR 0 4
95043: PPUSH
95044: CALL_OW 237
// end ;
95048: PPOPN 6
95050: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95051: LD_EXP 122
95055: PUSH
95056: LD_EXP 169
95060: AND
95061: IFFALSE 95140
95063: GO 95065
95065: DISABLE
95066: LD_INT 0
95068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95069: LD_ADDR_VAR 0 1
95073: PUSH
95074: LD_INT 22
95076: PUSH
95077: LD_OWVAR 2
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 30
95088: PUSH
95089: LD_INT 3
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: EMPTY
95097: LIST
95098: LIST
95099: PPUSH
95100: CALL_OW 69
95104: ST_TO_ADDR
// if not tmp then
95105: LD_VAR 0 1
95109: NOT
95110: IFFALSE 95114
// exit ;
95112: GO 95140
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95114: LD_VAR 0 1
95118: PUSH
95119: LD_INT 1
95121: PPUSH
95122: LD_VAR 0 1
95126: PPUSH
95127: CALL_OW 12
95131: ARRAY
95132: PPUSH
95133: LD_INT 1
95135: PPUSH
95136: CALL_OW 234
// end ;
95140: PPOPN 1
95142: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95143: LD_EXP 122
95147: PUSH
95148: LD_EXP 170
95152: AND
95153: IFFALSE 95265
95155: GO 95157
95157: DISABLE
95158: LD_INT 0
95160: PPUSH
95161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95162: LD_ADDR_VAR 0 2
95166: PUSH
95167: LD_INT 22
95169: PUSH
95170: LD_OWVAR 2
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 2
95181: PUSH
95182: LD_INT 30
95184: PUSH
95185: LD_INT 27
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 30
95194: PUSH
95195: LD_INT 26
95197: PUSH
95198: EMPTY
95199: LIST
95200: LIST
95201: PUSH
95202: LD_INT 30
95204: PUSH
95205: LD_INT 28
95207: PUSH
95208: EMPTY
95209: LIST
95210: LIST
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: PUSH
95218: EMPTY
95219: LIST
95220: LIST
95221: PPUSH
95222: CALL_OW 69
95226: ST_TO_ADDR
// if not tmp then
95227: LD_VAR 0 2
95231: NOT
95232: IFFALSE 95236
// exit ;
95234: GO 95265
// for i in tmp do
95236: LD_ADDR_VAR 0 1
95240: PUSH
95241: LD_VAR 0 2
95245: PUSH
95246: FOR_IN
95247: IFFALSE 95263
// SetLives ( i , 1 ) ;
95249: LD_VAR 0 1
95253: PPUSH
95254: LD_INT 1
95256: PPUSH
95257: CALL_OW 234
95261: GO 95246
95263: POP
95264: POP
// end ;
95265: PPOPN 2
95267: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95268: LD_EXP 122
95272: PUSH
95273: LD_EXP 171
95277: AND
95278: IFFALSE 95552
95280: GO 95282
95282: DISABLE
95283: LD_INT 0
95285: PPUSH
95286: PPUSH
95287: PPUSH
// begin i := rand ( 1 , 7 ) ;
95288: LD_ADDR_VAR 0 1
95292: PUSH
95293: LD_INT 1
95295: PPUSH
95296: LD_INT 7
95298: PPUSH
95299: CALL_OW 12
95303: ST_TO_ADDR
// case i of 1 :
95304: LD_VAR 0 1
95308: PUSH
95309: LD_INT 1
95311: DOUBLE
95312: EQUAL
95313: IFTRUE 95317
95315: GO 95327
95317: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95318: LD_STRING earthquake(getX(game), 0, 32)
95320: PPUSH
95321: CALL_OW 559
95325: GO 95552
95327: LD_INT 2
95329: DOUBLE
95330: EQUAL
95331: IFTRUE 95335
95333: GO 95349
95335: POP
// begin ToLua ( displayStucuk(); ) ;
95336: LD_STRING displayStucuk();
95338: PPUSH
95339: CALL_OW 559
// ResetFog ;
95343: CALL_OW 335
// end ; 3 :
95347: GO 95552
95349: LD_INT 3
95351: DOUBLE
95352: EQUAL
95353: IFTRUE 95357
95355: GO 95461
95357: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95358: LD_ADDR_VAR 0 2
95362: PUSH
95363: LD_INT 22
95365: PUSH
95366: LD_OWVAR 2
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: PUSH
95375: LD_INT 25
95377: PUSH
95378: LD_INT 1
95380: PUSH
95381: EMPTY
95382: LIST
95383: LIST
95384: PUSH
95385: EMPTY
95386: LIST
95387: LIST
95388: PPUSH
95389: CALL_OW 69
95393: ST_TO_ADDR
// if not tmp then
95394: LD_VAR 0 2
95398: NOT
95399: IFFALSE 95403
// exit ;
95401: GO 95552
// un := tmp [ rand ( 1 , tmp ) ] ;
95403: LD_ADDR_VAR 0 3
95407: PUSH
95408: LD_VAR 0 2
95412: PUSH
95413: LD_INT 1
95415: PPUSH
95416: LD_VAR 0 2
95420: PPUSH
95421: CALL_OW 12
95425: ARRAY
95426: ST_TO_ADDR
// if Crawls ( un ) then
95427: LD_VAR 0 3
95431: PPUSH
95432: CALL_OW 318
95436: IFFALSE 95447
// ComWalk ( un ) ;
95438: LD_VAR 0 3
95442: PPUSH
95443: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95447: LD_VAR 0 3
95451: PPUSH
95452: LD_INT 8
95454: PPUSH
95455: CALL_OW 336
// end ; 4 :
95459: GO 95552
95461: LD_INT 4
95463: DOUBLE
95464: EQUAL
95465: IFTRUE 95469
95467: GO 95530
95469: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95470: LD_ADDR_VAR 0 2
95474: PUSH
95475: LD_INT 22
95477: PUSH
95478: LD_OWVAR 2
95482: PUSH
95483: EMPTY
95484: LIST
95485: LIST
95486: PUSH
95487: LD_INT 30
95489: PUSH
95490: LD_INT 29
95492: PUSH
95493: EMPTY
95494: LIST
95495: LIST
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PPUSH
95501: CALL_OW 69
95505: ST_TO_ADDR
// if not tmp then
95506: LD_VAR 0 2
95510: NOT
95511: IFFALSE 95515
// exit ;
95513: GO 95552
// DestroyUnit ( tmp [ 1 ] ) ;
95515: LD_VAR 0 2
95519: PUSH
95520: LD_INT 1
95522: ARRAY
95523: PPUSH
95524: CALL_OW 65
// end ; 5 .. 7 :
95528: GO 95552
95530: LD_INT 5
95532: DOUBLE
95533: GREATEREQUAL
95534: IFFALSE 95542
95536: LD_INT 7
95538: DOUBLE
95539: LESSEQUAL
95540: IFTRUE 95544
95542: GO 95551
95544: POP
// StreamSibBomb ; end ;
95545: CALL 91802 0 0
95549: GO 95552
95551: POP
// end ;
95552: PPOPN 3
95554: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95555: LD_EXP 122
95559: PUSH
95560: LD_EXP 172
95564: AND
95565: IFFALSE 95721
95567: GO 95569
95569: DISABLE
95570: LD_INT 0
95572: PPUSH
95573: PPUSH
95574: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95575: LD_ADDR_VAR 0 2
95579: PUSH
95580: LD_INT 81
95582: PUSH
95583: LD_OWVAR 2
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 2
95594: PUSH
95595: LD_INT 21
95597: PUSH
95598: LD_INT 1
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 21
95607: PUSH
95608: LD_INT 2
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: LIST
95619: PUSH
95620: EMPTY
95621: LIST
95622: LIST
95623: PPUSH
95624: CALL_OW 69
95628: ST_TO_ADDR
// if not tmp then
95629: LD_VAR 0 2
95633: NOT
95634: IFFALSE 95638
// exit ;
95636: GO 95721
// p := 0 ;
95638: LD_ADDR_VAR 0 3
95642: PUSH
95643: LD_INT 0
95645: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95646: LD_INT 35
95648: PPUSH
95649: CALL_OW 67
// p := p + 1 ;
95653: LD_ADDR_VAR 0 3
95657: PUSH
95658: LD_VAR 0 3
95662: PUSH
95663: LD_INT 1
95665: PLUS
95666: ST_TO_ADDR
// for i in tmp do
95667: LD_ADDR_VAR 0 1
95671: PUSH
95672: LD_VAR 0 2
95676: PUSH
95677: FOR_IN
95678: IFFALSE 95709
// if GetLives ( i ) < 1000 then
95680: LD_VAR 0 1
95684: PPUSH
95685: CALL_OW 256
95689: PUSH
95690: LD_INT 1000
95692: LESS
95693: IFFALSE 95707
// SetLives ( i , 1000 ) ;
95695: LD_VAR 0 1
95699: PPUSH
95700: LD_INT 1000
95702: PPUSH
95703: CALL_OW 234
95707: GO 95677
95709: POP
95710: POP
// until p > 20 ;
95711: LD_VAR 0 3
95715: PUSH
95716: LD_INT 20
95718: GREATER
95719: IFFALSE 95646
// end ;
95721: PPOPN 3
95723: END
// every 0 0$1 trigger StreamModeActive and sTime do
95724: LD_EXP 122
95728: PUSH
95729: LD_EXP 173
95733: AND
95734: IFFALSE 95769
95736: GO 95738
95738: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95739: LD_INT 28
95741: PPUSH
95742: LD_OWVAR 2
95746: PPUSH
95747: LD_INT 2
95749: PPUSH
95750: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95754: LD_INT 30
95756: PPUSH
95757: LD_OWVAR 2
95761: PPUSH
95762: LD_INT 2
95764: PPUSH
95765: CALL_OW 322
// end ;
95769: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95770: LD_EXP 122
95774: PUSH
95775: LD_EXP 174
95779: AND
95780: IFFALSE 95901
95782: GO 95784
95784: DISABLE
95785: LD_INT 0
95787: PPUSH
95788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95789: LD_ADDR_VAR 0 2
95793: PUSH
95794: LD_INT 22
95796: PUSH
95797: LD_OWVAR 2
95801: PUSH
95802: EMPTY
95803: LIST
95804: LIST
95805: PUSH
95806: LD_INT 21
95808: PUSH
95809: LD_INT 1
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 3
95818: PUSH
95819: LD_INT 23
95821: PUSH
95822: LD_INT 0
95824: PUSH
95825: EMPTY
95826: LIST
95827: LIST
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: LIST
95837: PPUSH
95838: CALL_OW 69
95842: ST_TO_ADDR
// if not tmp then
95843: LD_VAR 0 2
95847: NOT
95848: IFFALSE 95852
// exit ;
95850: GO 95901
// for i in tmp do
95852: LD_ADDR_VAR 0 1
95856: PUSH
95857: LD_VAR 0 2
95861: PUSH
95862: FOR_IN
95863: IFFALSE 95899
// begin if Crawls ( i ) then
95865: LD_VAR 0 1
95869: PPUSH
95870: CALL_OW 318
95874: IFFALSE 95885
// ComWalk ( i ) ;
95876: LD_VAR 0 1
95880: PPUSH
95881: CALL_OW 138
// SetClass ( i , 2 ) ;
95885: LD_VAR 0 1
95889: PPUSH
95890: LD_INT 2
95892: PPUSH
95893: CALL_OW 336
// end ;
95897: GO 95862
95899: POP
95900: POP
// end ;
95901: PPOPN 2
95903: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95904: LD_EXP 122
95908: PUSH
95909: LD_EXP 175
95913: AND
95914: IFFALSE 96195
95916: GO 95918
95918: DISABLE
95919: LD_INT 0
95921: PPUSH
95922: PPUSH
95923: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95924: LD_OWVAR 2
95928: PPUSH
95929: LD_INT 9
95931: PPUSH
95932: LD_INT 1
95934: PPUSH
95935: LD_INT 1
95937: PPUSH
95938: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
95942: LD_INT 9
95944: PPUSH
95945: LD_OWVAR 2
95949: PPUSH
95950: CALL_OW 343
// uc_side := 9 ;
95954: LD_ADDR_OWVAR 20
95958: PUSH
95959: LD_INT 9
95961: ST_TO_ADDR
// uc_nation := 2 ;
95962: LD_ADDR_OWVAR 21
95966: PUSH
95967: LD_INT 2
95969: ST_TO_ADDR
// hc_name := Dark Warrior ;
95970: LD_ADDR_OWVAR 26
95974: PUSH
95975: LD_STRING Dark Warrior
95977: ST_TO_ADDR
// hc_gallery :=  ;
95978: LD_ADDR_OWVAR 33
95982: PUSH
95983: LD_STRING 
95985: ST_TO_ADDR
// hc_noskilllimit := true ;
95986: LD_ADDR_OWVAR 76
95990: PUSH
95991: LD_INT 1
95993: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
95994: LD_ADDR_OWVAR 31
95998: PUSH
95999: LD_INT 30
96001: PUSH
96002: LD_INT 30
96004: PUSH
96005: LD_INT 30
96007: PUSH
96008: LD_INT 30
96010: PUSH
96011: EMPTY
96012: LIST
96013: LIST
96014: LIST
96015: LIST
96016: ST_TO_ADDR
// un := CreateHuman ;
96017: LD_ADDR_VAR 0 3
96021: PUSH
96022: CALL_OW 44
96026: ST_TO_ADDR
// hc_noskilllimit := false ;
96027: LD_ADDR_OWVAR 76
96031: PUSH
96032: LD_INT 0
96034: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96035: LD_VAR 0 3
96039: PPUSH
96040: LD_INT 1
96042: PPUSH
96043: CALL_OW 51
// p := 0 ;
96047: LD_ADDR_VAR 0 2
96051: PUSH
96052: LD_INT 0
96054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96055: LD_INT 35
96057: PPUSH
96058: CALL_OW 67
// p := p + 1 ;
96062: LD_ADDR_VAR 0 2
96066: PUSH
96067: LD_VAR 0 2
96071: PUSH
96072: LD_INT 1
96074: PLUS
96075: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96076: LD_VAR 0 3
96080: PPUSH
96081: CALL_OW 256
96085: PUSH
96086: LD_INT 1000
96088: LESS
96089: IFFALSE 96103
// SetLives ( un , 1000 ) ;
96091: LD_VAR 0 3
96095: PPUSH
96096: LD_INT 1000
96098: PPUSH
96099: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96103: LD_VAR 0 3
96107: PPUSH
96108: LD_INT 81
96110: PUSH
96111: LD_OWVAR 2
96115: PUSH
96116: EMPTY
96117: LIST
96118: LIST
96119: PUSH
96120: LD_INT 91
96122: PUSH
96123: LD_VAR 0 3
96127: PUSH
96128: LD_INT 30
96130: PUSH
96131: EMPTY
96132: LIST
96133: LIST
96134: LIST
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PPUSH
96140: CALL_OW 69
96144: PPUSH
96145: LD_VAR 0 3
96149: PPUSH
96150: CALL_OW 74
96154: PPUSH
96155: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
96159: LD_VAR 0 2
96163: PUSH
96164: LD_INT 60
96166: GREATER
96167: PUSH
96168: LD_VAR 0 3
96172: PPUSH
96173: CALL_OW 301
96177: OR
96178: IFFALSE 96055
// if un then
96180: LD_VAR 0 3
96184: IFFALSE 96195
// RemoveUnit ( un ) ;
96186: LD_VAR 0 3
96190: PPUSH
96191: CALL_OW 64
// end ;
96195: PPOPN 3
96197: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96198: LD_INT 0
96200: PPUSH
// case cmd of 301 :
96201: LD_VAR 0 1
96205: PUSH
96206: LD_INT 301
96208: DOUBLE
96209: EQUAL
96210: IFTRUE 96214
96212: GO 96246
96214: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96215: LD_VAR 0 6
96219: PPUSH
96220: LD_VAR 0 7
96224: PPUSH
96225: LD_VAR 0 8
96229: PPUSH
96230: LD_VAR 0 4
96234: PPUSH
96235: LD_VAR 0 5
96239: PPUSH
96240: CALL 97447 0 5
96244: GO 96367
96246: LD_INT 302
96248: DOUBLE
96249: EQUAL
96250: IFTRUE 96254
96252: GO 96291
96254: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96255: LD_VAR 0 6
96259: PPUSH
96260: LD_VAR 0 7
96264: PPUSH
96265: LD_VAR 0 8
96269: PPUSH
96270: LD_VAR 0 9
96274: PPUSH
96275: LD_VAR 0 4
96279: PPUSH
96280: LD_VAR 0 5
96284: PPUSH
96285: CALL 97538 0 6
96289: GO 96367
96291: LD_INT 303
96293: DOUBLE
96294: EQUAL
96295: IFTRUE 96299
96297: GO 96336
96299: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96300: LD_VAR 0 6
96304: PPUSH
96305: LD_VAR 0 7
96309: PPUSH
96310: LD_VAR 0 8
96314: PPUSH
96315: LD_VAR 0 9
96319: PPUSH
96320: LD_VAR 0 4
96324: PPUSH
96325: LD_VAR 0 5
96329: PPUSH
96330: CALL 96372 0 6
96334: GO 96367
96336: LD_INT 304
96338: DOUBLE
96339: EQUAL
96340: IFTRUE 96344
96342: GO 96366
96344: POP
// hHackTeleport ( unit , x , y ) ; end ;
96345: LD_VAR 0 2
96349: PPUSH
96350: LD_VAR 0 4
96354: PPUSH
96355: LD_VAR 0 5
96359: PPUSH
96360: CALL 98131 0 3
96364: GO 96367
96366: POP
// end ;
96367: LD_VAR 0 12
96371: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
96372: LD_INT 0
96374: PPUSH
96375: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
96376: LD_VAR 0 1
96380: PUSH
96381: LD_INT 1
96383: LESS
96384: PUSH
96385: LD_VAR 0 1
96389: PUSH
96390: LD_INT 3
96392: GREATER
96393: OR
96394: PUSH
96395: LD_VAR 0 5
96399: PPUSH
96400: LD_VAR 0 6
96404: PPUSH
96405: CALL_OW 428
96409: OR
96410: IFFALSE 96414
// exit ;
96412: GO 97134
// uc_side := your_side ;
96414: LD_ADDR_OWVAR 20
96418: PUSH
96419: LD_OWVAR 2
96423: ST_TO_ADDR
// uc_nation := nation ;
96424: LD_ADDR_OWVAR 21
96428: PUSH
96429: LD_VAR 0 1
96433: ST_TO_ADDR
// bc_level = 1 ;
96434: LD_ADDR_OWVAR 43
96438: PUSH
96439: LD_INT 1
96441: ST_TO_ADDR
// case btype of 1 :
96442: LD_VAR 0 2
96446: PUSH
96447: LD_INT 1
96449: DOUBLE
96450: EQUAL
96451: IFTRUE 96455
96453: GO 96466
96455: POP
// bc_type := b_depot ; 2 :
96456: LD_ADDR_OWVAR 42
96460: PUSH
96461: LD_INT 0
96463: ST_TO_ADDR
96464: GO 97078
96466: LD_INT 2
96468: DOUBLE
96469: EQUAL
96470: IFTRUE 96474
96472: GO 96485
96474: POP
// bc_type := b_warehouse ; 3 :
96475: LD_ADDR_OWVAR 42
96479: PUSH
96480: LD_INT 1
96482: ST_TO_ADDR
96483: GO 97078
96485: LD_INT 3
96487: DOUBLE
96488: EQUAL
96489: IFTRUE 96493
96491: GO 96504
96493: POP
// bc_type := b_lab ; 4 .. 9 :
96494: LD_ADDR_OWVAR 42
96498: PUSH
96499: LD_INT 6
96501: ST_TO_ADDR
96502: GO 97078
96504: LD_INT 4
96506: DOUBLE
96507: GREATEREQUAL
96508: IFFALSE 96516
96510: LD_INT 9
96512: DOUBLE
96513: LESSEQUAL
96514: IFTRUE 96518
96516: GO 96570
96518: POP
// begin bc_type := b_lab_half ;
96519: LD_ADDR_OWVAR 42
96523: PUSH
96524: LD_INT 7
96526: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96527: LD_ADDR_OWVAR 44
96531: PUSH
96532: LD_INT 10
96534: PUSH
96535: LD_INT 11
96537: PUSH
96538: LD_INT 12
96540: PUSH
96541: LD_INT 15
96543: PUSH
96544: LD_INT 14
96546: PUSH
96547: LD_INT 13
96549: PUSH
96550: EMPTY
96551: LIST
96552: LIST
96553: LIST
96554: LIST
96555: LIST
96556: LIST
96557: PUSH
96558: LD_VAR 0 2
96562: PUSH
96563: LD_INT 3
96565: MINUS
96566: ARRAY
96567: ST_TO_ADDR
// end ; 10 .. 13 :
96568: GO 97078
96570: LD_INT 10
96572: DOUBLE
96573: GREATEREQUAL
96574: IFFALSE 96582
96576: LD_INT 13
96578: DOUBLE
96579: LESSEQUAL
96580: IFTRUE 96584
96582: GO 96661
96584: POP
// begin bc_type := b_lab_full ;
96585: LD_ADDR_OWVAR 42
96589: PUSH
96590: LD_INT 8
96592: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96593: LD_ADDR_OWVAR 44
96597: PUSH
96598: LD_INT 10
96600: PUSH
96601: LD_INT 12
96603: PUSH
96604: LD_INT 14
96606: PUSH
96607: LD_INT 13
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: PUSH
96616: LD_VAR 0 2
96620: PUSH
96621: LD_INT 9
96623: MINUS
96624: ARRAY
96625: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96626: LD_ADDR_OWVAR 45
96630: PUSH
96631: LD_INT 11
96633: PUSH
96634: LD_INT 15
96636: PUSH
96637: LD_INT 12
96639: PUSH
96640: LD_INT 15
96642: PUSH
96643: EMPTY
96644: LIST
96645: LIST
96646: LIST
96647: LIST
96648: PUSH
96649: LD_VAR 0 2
96653: PUSH
96654: LD_INT 9
96656: MINUS
96657: ARRAY
96658: ST_TO_ADDR
// end ; 14 :
96659: GO 97078
96661: LD_INT 14
96663: DOUBLE
96664: EQUAL
96665: IFTRUE 96669
96667: GO 96680
96669: POP
// bc_type := b_workshop ; 15 :
96670: LD_ADDR_OWVAR 42
96674: PUSH
96675: LD_INT 2
96677: ST_TO_ADDR
96678: GO 97078
96680: LD_INT 15
96682: DOUBLE
96683: EQUAL
96684: IFTRUE 96688
96686: GO 96699
96688: POP
// bc_type := b_factory ; 16 :
96689: LD_ADDR_OWVAR 42
96693: PUSH
96694: LD_INT 3
96696: ST_TO_ADDR
96697: GO 97078
96699: LD_INT 16
96701: DOUBLE
96702: EQUAL
96703: IFTRUE 96707
96705: GO 96718
96707: POP
// bc_type := b_ext_gun ; 17 :
96708: LD_ADDR_OWVAR 42
96712: PUSH
96713: LD_INT 17
96715: ST_TO_ADDR
96716: GO 97078
96718: LD_INT 17
96720: DOUBLE
96721: EQUAL
96722: IFTRUE 96726
96724: GO 96754
96726: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96727: LD_ADDR_OWVAR 42
96731: PUSH
96732: LD_INT 19
96734: PUSH
96735: LD_INT 23
96737: PUSH
96738: LD_INT 19
96740: PUSH
96741: EMPTY
96742: LIST
96743: LIST
96744: LIST
96745: PUSH
96746: LD_VAR 0 1
96750: ARRAY
96751: ST_TO_ADDR
96752: GO 97078
96754: LD_INT 18
96756: DOUBLE
96757: EQUAL
96758: IFTRUE 96762
96760: GO 96773
96762: POP
// bc_type := b_ext_radar ; 19 :
96763: LD_ADDR_OWVAR 42
96767: PUSH
96768: LD_INT 20
96770: ST_TO_ADDR
96771: GO 97078
96773: LD_INT 19
96775: DOUBLE
96776: EQUAL
96777: IFTRUE 96781
96779: GO 96792
96781: POP
// bc_type := b_ext_radio ; 20 :
96782: LD_ADDR_OWVAR 42
96786: PUSH
96787: LD_INT 22
96789: ST_TO_ADDR
96790: GO 97078
96792: LD_INT 20
96794: DOUBLE
96795: EQUAL
96796: IFTRUE 96800
96798: GO 96811
96800: POP
// bc_type := b_ext_siberium ; 21 :
96801: LD_ADDR_OWVAR 42
96805: PUSH
96806: LD_INT 21
96808: ST_TO_ADDR
96809: GO 97078
96811: LD_INT 21
96813: DOUBLE
96814: EQUAL
96815: IFTRUE 96819
96817: GO 96830
96819: POP
// bc_type := b_ext_computer ; 22 :
96820: LD_ADDR_OWVAR 42
96824: PUSH
96825: LD_INT 24
96827: ST_TO_ADDR
96828: GO 97078
96830: LD_INT 22
96832: DOUBLE
96833: EQUAL
96834: IFTRUE 96838
96836: GO 96849
96838: POP
// bc_type := b_ext_track ; 23 :
96839: LD_ADDR_OWVAR 42
96843: PUSH
96844: LD_INT 16
96846: ST_TO_ADDR
96847: GO 97078
96849: LD_INT 23
96851: DOUBLE
96852: EQUAL
96853: IFTRUE 96857
96855: GO 96868
96857: POP
// bc_type := b_ext_laser ; 24 :
96858: LD_ADDR_OWVAR 42
96862: PUSH
96863: LD_INT 25
96865: ST_TO_ADDR
96866: GO 97078
96868: LD_INT 24
96870: DOUBLE
96871: EQUAL
96872: IFTRUE 96876
96874: GO 96887
96876: POP
// bc_type := b_control_tower ; 25 :
96877: LD_ADDR_OWVAR 42
96881: PUSH
96882: LD_INT 36
96884: ST_TO_ADDR
96885: GO 97078
96887: LD_INT 25
96889: DOUBLE
96890: EQUAL
96891: IFTRUE 96895
96893: GO 96906
96895: POP
// bc_type := b_breastwork ; 26 :
96896: LD_ADDR_OWVAR 42
96900: PUSH
96901: LD_INT 31
96903: ST_TO_ADDR
96904: GO 97078
96906: LD_INT 26
96908: DOUBLE
96909: EQUAL
96910: IFTRUE 96914
96912: GO 96925
96914: POP
// bc_type := b_bunker ; 27 :
96915: LD_ADDR_OWVAR 42
96919: PUSH
96920: LD_INT 32
96922: ST_TO_ADDR
96923: GO 97078
96925: LD_INT 27
96927: DOUBLE
96928: EQUAL
96929: IFTRUE 96933
96931: GO 96944
96933: POP
// bc_type := b_turret ; 28 :
96934: LD_ADDR_OWVAR 42
96938: PUSH
96939: LD_INT 33
96941: ST_TO_ADDR
96942: GO 97078
96944: LD_INT 28
96946: DOUBLE
96947: EQUAL
96948: IFTRUE 96952
96950: GO 96963
96952: POP
// bc_type := b_armoury ; 29 :
96953: LD_ADDR_OWVAR 42
96957: PUSH
96958: LD_INT 4
96960: ST_TO_ADDR
96961: GO 97078
96963: LD_INT 29
96965: DOUBLE
96966: EQUAL
96967: IFTRUE 96971
96969: GO 96982
96971: POP
// bc_type := b_barracks ; 30 :
96972: LD_ADDR_OWVAR 42
96976: PUSH
96977: LD_INT 5
96979: ST_TO_ADDR
96980: GO 97078
96982: LD_INT 30
96984: DOUBLE
96985: EQUAL
96986: IFTRUE 96990
96988: GO 97001
96990: POP
// bc_type := b_solar_power ; 31 :
96991: LD_ADDR_OWVAR 42
96995: PUSH
96996: LD_INT 27
96998: ST_TO_ADDR
96999: GO 97078
97001: LD_INT 31
97003: DOUBLE
97004: EQUAL
97005: IFTRUE 97009
97007: GO 97020
97009: POP
// bc_type := b_oil_power ; 32 :
97010: LD_ADDR_OWVAR 42
97014: PUSH
97015: LD_INT 26
97017: ST_TO_ADDR
97018: GO 97078
97020: LD_INT 32
97022: DOUBLE
97023: EQUAL
97024: IFTRUE 97028
97026: GO 97039
97028: POP
// bc_type := b_siberite_power ; 33 :
97029: LD_ADDR_OWVAR 42
97033: PUSH
97034: LD_INT 28
97036: ST_TO_ADDR
97037: GO 97078
97039: LD_INT 33
97041: DOUBLE
97042: EQUAL
97043: IFTRUE 97047
97045: GO 97058
97047: POP
// bc_type := b_oil_mine ; 34 :
97048: LD_ADDR_OWVAR 42
97052: PUSH
97053: LD_INT 29
97055: ST_TO_ADDR
97056: GO 97078
97058: LD_INT 34
97060: DOUBLE
97061: EQUAL
97062: IFTRUE 97066
97064: GO 97077
97066: POP
// bc_type := b_siberite_mine ; end ;
97067: LD_ADDR_OWVAR 42
97071: PUSH
97072: LD_INT 30
97074: ST_TO_ADDR
97075: GO 97078
97077: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97078: LD_ADDR_VAR 0 8
97082: PUSH
97083: LD_VAR 0 5
97087: PPUSH
97088: LD_VAR 0 6
97092: PPUSH
97093: LD_VAR 0 3
97097: PPUSH
97098: CALL_OW 47
97102: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97103: LD_OWVAR 42
97107: PUSH
97108: LD_INT 32
97110: PUSH
97111: LD_INT 33
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: IN
97118: IFFALSE 97134
// PlaceWeaponTurret ( b , weapon ) ;
97120: LD_VAR 0 8
97124: PPUSH
97125: LD_VAR 0 4
97129: PPUSH
97130: CALL_OW 431
// end ;
97134: LD_VAR 0 7
97138: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97139: LD_INT 0
97141: PPUSH
97142: PPUSH
97143: PPUSH
97144: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97145: LD_ADDR_VAR 0 4
97149: PUSH
97150: LD_INT 22
97152: PUSH
97153: LD_OWVAR 2
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: LD_INT 2
97164: PUSH
97165: LD_INT 30
97167: PUSH
97168: LD_INT 0
97170: PUSH
97171: EMPTY
97172: LIST
97173: LIST
97174: PUSH
97175: LD_INT 30
97177: PUSH
97178: LD_INT 1
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: LIST
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PPUSH
97194: CALL_OW 69
97198: ST_TO_ADDR
// if not tmp then
97199: LD_VAR 0 4
97203: NOT
97204: IFFALSE 97208
// exit ;
97206: GO 97267
// for i in tmp do
97208: LD_ADDR_VAR 0 2
97212: PUSH
97213: LD_VAR 0 4
97217: PUSH
97218: FOR_IN
97219: IFFALSE 97265
// for j = 1 to 3 do
97221: LD_ADDR_VAR 0 3
97225: PUSH
97226: DOUBLE
97227: LD_INT 1
97229: DEC
97230: ST_TO_ADDR
97231: LD_INT 3
97233: PUSH
97234: FOR_TO
97235: IFFALSE 97261
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97237: LD_VAR 0 2
97241: PPUSH
97242: CALL_OW 274
97246: PPUSH
97247: LD_VAR 0 3
97251: PPUSH
97252: LD_INT 99999
97254: PPUSH
97255: CALL_OW 277
97259: GO 97234
97261: POP
97262: POP
97263: GO 97218
97265: POP
97266: POP
// end ;
97267: LD_VAR 0 1
97271: RET
// export function hHackSetLevel10 ; var i , j ; begin
97272: LD_INT 0
97274: PPUSH
97275: PPUSH
97276: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97277: LD_ADDR_VAR 0 2
97281: PUSH
97282: LD_INT 21
97284: PUSH
97285: LD_INT 1
97287: PUSH
97288: EMPTY
97289: LIST
97290: LIST
97291: PPUSH
97292: CALL_OW 69
97296: PUSH
97297: FOR_IN
97298: IFFALSE 97350
// if IsSelected ( i ) then
97300: LD_VAR 0 2
97304: PPUSH
97305: CALL_OW 306
97309: IFFALSE 97348
// begin for j := 1 to 4 do
97311: LD_ADDR_VAR 0 3
97315: PUSH
97316: DOUBLE
97317: LD_INT 1
97319: DEC
97320: ST_TO_ADDR
97321: LD_INT 4
97323: PUSH
97324: FOR_TO
97325: IFFALSE 97346
// SetSkill ( i , j , 10 ) ;
97327: LD_VAR 0 2
97331: PPUSH
97332: LD_VAR 0 3
97336: PPUSH
97337: LD_INT 10
97339: PPUSH
97340: CALL_OW 237
97344: GO 97324
97346: POP
97347: POP
// end ;
97348: GO 97297
97350: POP
97351: POP
// end ;
97352: LD_VAR 0 1
97356: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97357: LD_INT 0
97359: PPUSH
97360: PPUSH
97361: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
97362: LD_ADDR_VAR 0 2
97366: PUSH
97367: LD_INT 22
97369: PUSH
97370: LD_OWVAR 2
97374: PUSH
97375: EMPTY
97376: LIST
97377: LIST
97378: PUSH
97379: LD_INT 21
97381: PUSH
97382: LD_INT 1
97384: PUSH
97385: EMPTY
97386: LIST
97387: LIST
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PPUSH
97393: CALL_OW 69
97397: PUSH
97398: FOR_IN
97399: IFFALSE 97440
// begin for j := 1 to 4 do
97401: LD_ADDR_VAR 0 3
97405: PUSH
97406: DOUBLE
97407: LD_INT 1
97409: DEC
97410: ST_TO_ADDR
97411: LD_INT 4
97413: PUSH
97414: FOR_TO
97415: IFFALSE 97436
// SetSkill ( i , j , 10 ) ;
97417: LD_VAR 0 2
97421: PPUSH
97422: LD_VAR 0 3
97426: PPUSH
97427: LD_INT 10
97429: PPUSH
97430: CALL_OW 237
97434: GO 97414
97436: POP
97437: POP
// end ;
97438: GO 97398
97440: POP
97441: POP
// end ;
97442: LD_VAR 0 1
97446: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97447: LD_INT 0
97449: PPUSH
// uc_side := your_side ;
97450: LD_ADDR_OWVAR 20
97454: PUSH
97455: LD_OWVAR 2
97459: ST_TO_ADDR
// uc_nation := nation ;
97460: LD_ADDR_OWVAR 21
97464: PUSH
97465: LD_VAR 0 1
97469: ST_TO_ADDR
// InitHc ;
97470: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97474: LD_INT 0
97476: PPUSH
97477: LD_VAR 0 2
97481: PPUSH
97482: LD_VAR 0 3
97486: PPUSH
97487: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97491: LD_VAR 0 4
97495: PPUSH
97496: LD_VAR 0 5
97500: PPUSH
97501: CALL_OW 428
97505: PUSH
97506: LD_INT 0
97508: EQUAL
97509: IFFALSE 97533
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97511: CALL_OW 44
97515: PPUSH
97516: LD_VAR 0 4
97520: PPUSH
97521: LD_VAR 0 5
97525: PPUSH
97526: LD_INT 1
97528: PPUSH
97529: CALL_OW 48
// end ;
97533: LD_VAR 0 6
97537: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97538: LD_INT 0
97540: PPUSH
97541: PPUSH
// uc_side := your_side ;
97542: LD_ADDR_OWVAR 20
97546: PUSH
97547: LD_OWVAR 2
97551: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97552: LD_VAR 0 1
97556: PUSH
97557: LD_INT 1
97559: PUSH
97560: LD_INT 2
97562: PUSH
97563: LD_INT 3
97565: PUSH
97566: LD_INT 4
97568: PUSH
97569: LD_INT 5
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: IN
97579: IFFALSE 97591
// uc_nation := nation_american else
97581: LD_ADDR_OWVAR 21
97585: PUSH
97586: LD_INT 1
97588: ST_TO_ADDR
97589: GO 97634
// if chassis in [ 11 , 12 , 13 , 14 ] then
97591: LD_VAR 0 1
97595: PUSH
97596: LD_INT 11
97598: PUSH
97599: LD_INT 12
97601: PUSH
97602: LD_INT 13
97604: PUSH
97605: LD_INT 14
97607: PUSH
97608: EMPTY
97609: LIST
97610: LIST
97611: LIST
97612: LIST
97613: IN
97614: IFFALSE 97626
// uc_nation := nation_arabian else
97616: LD_ADDR_OWVAR 21
97620: PUSH
97621: LD_INT 2
97623: ST_TO_ADDR
97624: GO 97634
// uc_nation := nation_russian ;
97626: LD_ADDR_OWVAR 21
97630: PUSH
97631: LD_INT 3
97633: ST_TO_ADDR
// vc_chassis := chassis ;
97634: LD_ADDR_OWVAR 37
97638: PUSH
97639: LD_VAR 0 1
97643: ST_TO_ADDR
// vc_engine := engine ;
97644: LD_ADDR_OWVAR 39
97648: PUSH
97649: LD_VAR 0 2
97653: ST_TO_ADDR
// vc_control := control ;
97654: LD_ADDR_OWVAR 38
97658: PUSH
97659: LD_VAR 0 3
97663: ST_TO_ADDR
// vc_weapon := weapon ;
97664: LD_ADDR_OWVAR 40
97668: PUSH
97669: LD_VAR 0 4
97673: ST_TO_ADDR
// un := CreateVehicle ;
97674: LD_ADDR_VAR 0 8
97678: PUSH
97679: CALL_OW 45
97683: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97684: LD_VAR 0 8
97688: PPUSH
97689: LD_INT 0
97691: PPUSH
97692: LD_INT 5
97694: PPUSH
97695: CALL_OW 12
97699: PPUSH
97700: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97704: LD_VAR 0 8
97708: PPUSH
97709: LD_VAR 0 5
97713: PPUSH
97714: LD_VAR 0 6
97718: PPUSH
97719: LD_INT 1
97721: PPUSH
97722: CALL_OW 48
// end ;
97726: LD_VAR 0 7
97730: RET
// export hInvincible ; every 1 do
97731: GO 97733
97733: DISABLE
// hInvincible := [ ] ;
97734: LD_ADDR_EXP 176
97738: PUSH
97739: EMPTY
97740: ST_TO_ADDR
97741: END
// every 10 do var i ;
97742: GO 97744
97744: DISABLE
97745: LD_INT 0
97747: PPUSH
// begin enable ;
97748: ENABLE
// if not hInvincible then
97749: LD_EXP 176
97753: NOT
97754: IFFALSE 97758
// exit ;
97756: GO 97802
// for i in hInvincible do
97758: LD_ADDR_VAR 0 1
97762: PUSH
97763: LD_EXP 176
97767: PUSH
97768: FOR_IN
97769: IFFALSE 97800
// if GetLives ( i ) < 1000 then
97771: LD_VAR 0 1
97775: PPUSH
97776: CALL_OW 256
97780: PUSH
97781: LD_INT 1000
97783: LESS
97784: IFFALSE 97798
// SetLives ( i , 1000 ) ;
97786: LD_VAR 0 1
97790: PPUSH
97791: LD_INT 1000
97793: PPUSH
97794: CALL_OW 234
97798: GO 97768
97800: POP
97801: POP
// end ;
97802: PPOPN 1
97804: END
// export function hHackInvincible ; var i ; begin
97805: LD_INT 0
97807: PPUSH
97808: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97809: LD_ADDR_VAR 0 2
97813: PUSH
97814: LD_INT 2
97816: PUSH
97817: LD_INT 21
97819: PUSH
97820: LD_INT 1
97822: PUSH
97823: EMPTY
97824: LIST
97825: LIST
97826: PUSH
97827: LD_INT 21
97829: PUSH
97830: LD_INT 2
97832: PUSH
97833: EMPTY
97834: LIST
97835: LIST
97836: PUSH
97837: EMPTY
97838: LIST
97839: LIST
97840: LIST
97841: PPUSH
97842: CALL_OW 69
97846: PUSH
97847: FOR_IN
97848: IFFALSE 97909
// if IsSelected ( i ) then
97850: LD_VAR 0 2
97854: PPUSH
97855: CALL_OW 306
97859: IFFALSE 97907
// begin if i in hInvincible then
97861: LD_VAR 0 2
97865: PUSH
97866: LD_EXP 176
97870: IN
97871: IFFALSE 97891
// hInvincible := hInvincible diff i else
97873: LD_ADDR_EXP 176
97877: PUSH
97878: LD_EXP 176
97882: PUSH
97883: LD_VAR 0 2
97887: DIFF
97888: ST_TO_ADDR
97889: GO 97907
// hInvincible := hInvincible union i ;
97891: LD_ADDR_EXP 176
97895: PUSH
97896: LD_EXP 176
97900: PUSH
97901: LD_VAR 0 2
97905: UNION
97906: ST_TO_ADDR
// end ;
97907: GO 97847
97909: POP
97910: POP
// end ;
97911: LD_VAR 0 1
97915: RET
// export function hHackInvisible ; var i , j ; begin
97916: LD_INT 0
97918: PPUSH
97919: PPUSH
97920: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97921: LD_ADDR_VAR 0 2
97925: PUSH
97926: LD_INT 21
97928: PUSH
97929: LD_INT 1
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: PPUSH
97936: CALL_OW 69
97940: PUSH
97941: FOR_IN
97942: IFFALSE 97966
// if IsSelected ( i ) then
97944: LD_VAR 0 2
97948: PPUSH
97949: CALL_OW 306
97953: IFFALSE 97964
// ComForceInvisible ( i ) ;
97955: LD_VAR 0 2
97959: PPUSH
97960: CALL_OW 496
97964: GO 97941
97966: POP
97967: POP
// end ;
97968: LD_VAR 0 1
97972: RET
// export function hHackChangeYourSide ; begin
97973: LD_INT 0
97975: PPUSH
// if your_side = 8 then
97976: LD_OWVAR 2
97980: PUSH
97981: LD_INT 8
97983: EQUAL
97984: IFFALSE 97996
// your_side := 0 else
97986: LD_ADDR_OWVAR 2
97990: PUSH
97991: LD_INT 0
97993: ST_TO_ADDR
97994: GO 98010
// your_side := your_side + 1 ;
97996: LD_ADDR_OWVAR 2
98000: PUSH
98001: LD_OWVAR 2
98005: PUSH
98006: LD_INT 1
98008: PLUS
98009: ST_TO_ADDR
// end ;
98010: LD_VAR 0 1
98014: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98015: LD_INT 0
98017: PPUSH
98018: PPUSH
98019: PPUSH
// for i in all_units do
98020: LD_ADDR_VAR 0 2
98024: PUSH
98025: LD_OWVAR 3
98029: PUSH
98030: FOR_IN
98031: IFFALSE 98109
// if IsSelected ( i ) then
98033: LD_VAR 0 2
98037: PPUSH
98038: CALL_OW 306
98042: IFFALSE 98107
// begin j := GetSide ( i ) ;
98044: LD_ADDR_VAR 0 3
98048: PUSH
98049: LD_VAR 0 2
98053: PPUSH
98054: CALL_OW 255
98058: ST_TO_ADDR
// if j = 8 then
98059: LD_VAR 0 3
98063: PUSH
98064: LD_INT 8
98066: EQUAL
98067: IFFALSE 98079
// j := 0 else
98069: LD_ADDR_VAR 0 3
98073: PUSH
98074: LD_INT 0
98076: ST_TO_ADDR
98077: GO 98093
// j := j + 1 ;
98079: LD_ADDR_VAR 0 3
98083: PUSH
98084: LD_VAR 0 3
98088: PUSH
98089: LD_INT 1
98091: PLUS
98092: ST_TO_ADDR
// SetSide ( i , j ) ;
98093: LD_VAR 0 2
98097: PPUSH
98098: LD_VAR 0 3
98102: PPUSH
98103: CALL_OW 235
// end ;
98107: GO 98030
98109: POP
98110: POP
// end ;
98111: LD_VAR 0 1
98115: RET
// export function hHackFog ; begin
98116: LD_INT 0
98118: PPUSH
// FogOff ( true ) ;
98119: LD_INT 1
98121: PPUSH
98122: CALL_OW 344
// end ;
98126: LD_VAR 0 1
98130: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98131: LD_INT 0
98133: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98134: LD_VAR 0 1
98138: PPUSH
98139: LD_VAR 0 2
98143: PPUSH
98144: LD_VAR 0 3
98148: PPUSH
98149: LD_INT 1
98151: PPUSH
98152: LD_INT 1
98154: PPUSH
98155: CALL_OW 483
// CenterOnXY ( x , y ) ;
98159: LD_VAR 0 2
98163: PPUSH
98164: LD_VAR 0 3
98168: PPUSH
98169: CALL_OW 84
// end ; end_of_file
98173: LD_VAR 0 4
98177: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98178: LD_INT 0
98180: PPUSH
98181: PPUSH
98182: PPUSH
98183: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98184: LD_VAR 0 1
98188: PPUSH
98189: CALL_OW 264
98193: PUSH
98194: LD_EXP 107
98198: EQUAL
98199: IFFALSE 98271
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98201: LD_INT 68
98203: PPUSH
98204: LD_VAR 0 1
98208: PPUSH
98209: CALL_OW 255
98213: PPUSH
98214: CALL_OW 321
98218: PUSH
98219: LD_INT 2
98221: EQUAL
98222: IFFALSE 98234
// eff := 70 else
98224: LD_ADDR_VAR 0 4
98228: PUSH
98229: LD_INT 70
98231: ST_TO_ADDR
98232: GO 98242
// eff := 30 ;
98234: LD_ADDR_VAR 0 4
98238: PUSH
98239: LD_INT 30
98241: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98242: LD_VAR 0 1
98246: PPUSH
98247: CALL_OW 250
98251: PPUSH
98252: LD_VAR 0 1
98256: PPUSH
98257: CALL_OW 251
98261: PPUSH
98262: LD_VAR 0 4
98266: PPUSH
98267: CALL_OW 495
// end ; end ;
98271: LD_VAR 0 2
98275: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98276: LD_INT 0
98278: PPUSH
// end ;
98279: LD_VAR 0 4
98283: RET
// export function SOS_Command ( cmd ) ; begin
98284: LD_INT 0
98286: PPUSH
// end ;
98287: LD_VAR 0 2
98291: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
98292: LD_INT 0
98294: PPUSH
// if cmd = 121 then
98295: LD_VAR 0 1
98299: PUSH
98300: LD_INT 121
98302: EQUAL
98303: IFFALSE 98305
// end ;
98305: LD_VAR 0 6
98309: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
98310: LD_INT 0
98312: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
98313: LD_VAR 0 1
98317: PUSH
98318: LD_INT 250
98320: EQUAL
98321: PUSH
98322: LD_VAR 0 2
98326: PPUSH
98327: CALL_OW 264
98331: PUSH
98332: LD_EXP 110
98336: EQUAL
98337: AND
98338: IFFALSE 98359
// MinerPlaceMine ( unit , x , y ) ;
98340: LD_VAR 0 2
98344: PPUSH
98345: LD_VAR 0 4
98349: PPUSH
98350: LD_VAR 0 5
98354: PPUSH
98355: CALL 100708 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
98359: LD_VAR 0 1
98363: PUSH
98364: LD_INT 251
98366: EQUAL
98367: PUSH
98368: LD_VAR 0 2
98372: PPUSH
98373: CALL_OW 264
98377: PUSH
98378: LD_EXP 110
98382: EQUAL
98383: AND
98384: IFFALSE 98405
// MinerDetonateMine ( unit , x , y ) ;
98386: LD_VAR 0 2
98390: PPUSH
98391: LD_VAR 0 4
98395: PPUSH
98396: LD_VAR 0 5
98400: PPUSH
98401: CALL 100985 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
98405: LD_VAR 0 1
98409: PUSH
98410: LD_INT 252
98412: EQUAL
98413: PUSH
98414: LD_VAR 0 2
98418: PPUSH
98419: CALL_OW 264
98423: PUSH
98424: LD_EXP 110
98428: EQUAL
98429: AND
98430: IFFALSE 98451
// MinerCreateMinefield ( unit , x , y ) ;
98432: LD_VAR 0 2
98436: PPUSH
98437: LD_VAR 0 4
98441: PPUSH
98442: LD_VAR 0 5
98446: PPUSH
98447: CALL 101402 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
98451: LD_VAR 0 1
98455: PUSH
98456: LD_INT 253
98458: EQUAL
98459: PUSH
98460: LD_VAR 0 2
98464: PPUSH
98465: CALL_OW 257
98469: PUSH
98470: LD_INT 5
98472: EQUAL
98473: AND
98474: IFFALSE 98495
// ComBinocular ( unit , x , y ) ;
98476: LD_VAR 0 2
98480: PPUSH
98481: LD_VAR 0 4
98485: PPUSH
98486: LD_VAR 0 5
98490: PPUSH
98491: CALL 101773 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98495: LD_VAR 0 1
98499: PUSH
98500: LD_INT 254
98502: EQUAL
98503: PUSH
98504: LD_VAR 0 2
98508: PPUSH
98509: CALL_OW 264
98513: PUSH
98514: LD_EXP 105
98518: EQUAL
98519: AND
98520: PUSH
98521: LD_VAR 0 3
98525: PPUSH
98526: CALL_OW 263
98530: PUSH
98531: LD_INT 3
98533: EQUAL
98534: AND
98535: IFFALSE 98551
// HackDestroyVehicle ( unit , selectedUnit ) ;
98537: LD_VAR 0 2
98541: PPUSH
98542: LD_VAR 0 3
98546: PPUSH
98547: CALL 100068 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98551: LD_VAR 0 1
98555: PUSH
98556: LD_INT 255
98558: EQUAL
98559: PUSH
98560: LD_VAR 0 2
98564: PPUSH
98565: CALL_OW 264
98569: PUSH
98570: LD_INT 14
98572: PUSH
98573: LD_INT 53
98575: PUSH
98576: EMPTY
98577: LIST
98578: LIST
98579: IN
98580: AND
98581: PUSH
98582: LD_VAR 0 4
98586: PPUSH
98587: LD_VAR 0 5
98591: PPUSH
98592: CALL_OW 488
98596: AND
98597: IFFALSE 98621
// CutTreeXYR ( unit , x , y , 12 ) ;
98599: LD_VAR 0 2
98603: PPUSH
98604: LD_VAR 0 4
98608: PPUSH
98609: LD_VAR 0 5
98613: PPUSH
98614: LD_INT 12
98616: PPUSH
98617: CALL 98634 0 4
// end ;
98621: LD_VAR 0 6
98625: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
98626: LD_INT 0
98628: PPUSH
// end ;
98629: LD_VAR 0 4
98633: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98634: LD_INT 0
98636: PPUSH
98637: PPUSH
98638: PPUSH
98639: PPUSH
98640: PPUSH
98641: PPUSH
98642: PPUSH
98643: PPUSH
98644: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98645: LD_VAR 0 1
98649: NOT
98650: PUSH
98651: LD_VAR 0 2
98655: PPUSH
98656: LD_VAR 0 3
98660: PPUSH
98661: CALL_OW 488
98665: NOT
98666: OR
98667: PUSH
98668: LD_VAR 0 4
98672: NOT
98673: OR
98674: IFFALSE 98678
// exit ;
98676: GO 99018
// list := [ ] ;
98678: LD_ADDR_VAR 0 13
98682: PUSH
98683: EMPTY
98684: ST_TO_ADDR
// if x - r < 0 then
98685: LD_VAR 0 2
98689: PUSH
98690: LD_VAR 0 4
98694: MINUS
98695: PUSH
98696: LD_INT 0
98698: LESS
98699: IFFALSE 98711
// min_x := 0 else
98701: LD_ADDR_VAR 0 7
98705: PUSH
98706: LD_INT 0
98708: ST_TO_ADDR
98709: GO 98727
// min_x := x - r ;
98711: LD_ADDR_VAR 0 7
98715: PUSH
98716: LD_VAR 0 2
98720: PUSH
98721: LD_VAR 0 4
98725: MINUS
98726: ST_TO_ADDR
// if y - r < 0 then
98727: LD_VAR 0 3
98731: PUSH
98732: LD_VAR 0 4
98736: MINUS
98737: PUSH
98738: LD_INT 0
98740: LESS
98741: IFFALSE 98753
// min_y := 0 else
98743: LD_ADDR_VAR 0 8
98747: PUSH
98748: LD_INT 0
98750: ST_TO_ADDR
98751: GO 98769
// min_y := y - r ;
98753: LD_ADDR_VAR 0 8
98757: PUSH
98758: LD_VAR 0 3
98762: PUSH
98763: LD_VAR 0 4
98767: MINUS
98768: ST_TO_ADDR
// max_x := x + r ;
98769: LD_ADDR_VAR 0 9
98773: PUSH
98774: LD_VAR 0 2
98778: PUSH
98779: LD_VAR 0 4
98783: PLUS
98784: ST_TO_ADDR
// max_y := y + r ;
98785: LD_ADDR_VAR 0 10
98789: PUSH
98790: LD_VAR 0 3
98794: PUSH
98795: LD_VAR 0 4
98799: PLUS
98800: ST_TO_ADDR
// for _x = min_x to max_x do
98801: LD_ADDR_VAR 0 11
98805: PUSH
98806: DOUBLE
98807: LD_VAR 0 7
98811: DEC
98812: ST_TO_ADDR
98813: LD_VAR 0 9
98817: PUSH
98818: FOR_TO
98819: IFFALSE 98936
// for _y = min_y to max_y do
98821: LD_ADDR_VAR 0 12
98825: PUSH
98826: DOUBLE
98827: LD_VAR 0 8
98831: DEC
98832: ST_TO_ADDR
98833: LD_VAR 0 10
98837: PUSH
98838: FOR_TO
98839: IFFALSE 98932
// begin if not ValidHex ( _x , _y ) then
98841: LD_VAR 0 11
98845: PPUSH
98846: LD_VAR 0 12
98850: PPUSH
98851: CALL_OW 488
98855: NOT
98856: IFFALSE 98860
// continue ;
98858: GO 98838
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98860: LD_VAR 0 11
98864: PPUSH
98865: LD_VAR 0 12
98869: PPUSH
98870: CALL_OW 351
98874: PUSH
98875: LD_VAR 0 11
98879: PPUSH
98880: LD_VAR 0 12
98884: PPUSH
98885: CALL_OW 554
98889: AND
98890: IFFALSE 98930
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98892: LD_ADDR_VAR 0 13
98896: PUSH
98897: LD_VAR 0 13
98901: PPUSH
98902: LD_VAR 0 13
98906: PUSH
98907: LD_INT 1
98909: PLUS
98910: PPUSH
98911: LD_VAR 0 11
98915: PUSH
98916: LD_VAR 0 12
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PPUSH
98925: CALL_OW 2
98929: ST_TO_ADDR
// end ;
98930: GO 98838
98932: POP
98933: POP
98934: GO 98818
98936: POP
98937: POP
// if not list then
98938: LD_VAR 0 13
98942: NOT
98943: IFFALSE 98947
// exit ;
98945: GO 99018
// for i in list do
98947: LD_ADDR_VAR 0 6
98951: PUSH
98952: LD_VAR 0 13
98956: PUSH
98957: FOR_IN
98958: IFFALSE 99016
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98960: LD_VAR 0 1
98964: PPUSH
98965: LD_STRING M
98967: PUSH
98968: LD_VAR 0 6
98972: PUSH
98973: LD_INT 1
98975: ARRAY
98976: PUSH
98977: LD_VAR 0 6
98981: PUSH
98982: LD_INT 2
98984: ARRAY
98985: PUSH
98986: LD_INT 0
98988: PUSH
98989: LD_INT 0
98991: PUSH
98992: LD_INT 0
98994: PUSH
98995: LD_INT 0
98997: PUSH
98998: EMPTY
98999: LIST
99000: LIST
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: PUSH
99007: EMPTY
99008: LIST
99009: PPUSH
99010: CALL_OW 447
99014: GO 98957
99016: POP
99017: POP
// end ;
99018: LD_VAR 0 5
99022: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99023: LD_EXP 179
99027: NOT
99028: IFFALSE 99078
99030: GO 99032
99032: DISABLE
// begin initHack := true ;
99033: LD_ADDR_EXP 179
99037: PUSH
99038: LD_INT 1
99040: ST_TO_ADDR
// hackTanks := [ ] ;
99041: LD_ADDR_EXP 180
99045: PUSH
99046: EMPTY
99047: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99048: LD_ADDR_EXP 181
99052: PUSH
99053: EMPTY
99054: ST_TO_ADDR
// hackLimit := 3 ;
99055: LD_ADDR_EXP 182
99059: PUSH
99060: LD_INT 3
99062: ST_TO_ADDR
// hackDist := 12 ;
99063: LD_ADDR_EXP 183
99067: PUSH
99068: LD_INT 12
99070: ST_TO_ADDR
// hackCounter := [ ] ;
99071: LD_ADDR_EXP 184
99075: PUSH
99076: EMPTY
99077: ST_TO_ADDR
// end ;
99078: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99079: LD_EXP 179
99083: PUSH
99084: LD_INT 34
99086: PUSH
99087: LD_EXP 105
99091: PUSH
99092: EMPTY
99093: LIST
99094: LIST
99095: PPUSH
99096: CALL_OW 69
99100: AND
99101: IFFALSE 99356
99103: GO 99105
99105: DISABLE
99106: LD_INT 0
99108: PPUSH
99109: PPUSH
// begin enable ;
99110: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99111: LD_ADDR_VAR 0 1
99115: PUSH
99116: LD_INT 34
99118: PUSH
99119: LD_EXP 105
99123: PUSH
99124: EMPTY
99125: LIST
99126: LIST
99127: PPUSH
99128: CALL_OW 69
99132: PUSH
99133: FOR_IN
99134: IFFALSE 99354
// begin if not i in hackTanks then
99136: LD_VAR 0 1
99140: PUSH
99141: LD_EXP 180
99145: IN
99146: NOT
99147: IFFALSE 99230
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99149: LD_ADDR_EXP 180
99153: PUSH
99154: LD_EXP 180
99158: PPUSH
99159: LD_EXP 180
99163: PUSH
99164: LD_INT 1
99166: PLUS
99167: PPUSH
99168: LD_VAR 0 1
99172: PPUSH
99173: CALL_OW 1
99177: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99178: LD_ADDR_EXP 181
99182: PUSH
99183: LD_EXP 181
99187: PPUSH
99188: LD_EXP 181
99192: PUSH
99193: LD_INT 1
99195: PLUS
99196: PPUSH
99197: EMPTY
99198: PPUSH
99199: CALL_OW 1
99203: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99204: LD_ADDR_EXP 184
99208: PUSH
99209: LD_EXP 184
99213: PPUSH
99214: LD_EXP 184
99218: PUSH
99219: LD_INT 1
99221: PLUS
99222: PPUSH
99223: EMPTY
99224: PPUSH
99225: CALL_OW 1
99229: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99230: LD_VAR 0 1
99234: PPUSH
99235: CALL_OW 302
99239: NOT
99240: IFFALSE 99253
// begin HackUnlinkAll ( i ) ;
99242: LD_VAR 0 1
99246: PPUSH
99247: CALL 99359 0 1
// continue ;
99251: GO 99133
// end ; HackCheckCapturedStatus ( i ) ;
99253: LD_VAR 0 1
99257: PPUSH
99258: CALL 99802 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
99262: LD_ADDR_VAR 0 2
99266: PUSH
99267: LD_INT 81
99269: PUSH
99270: LD_VAR 0 1
99274: PPUSH
99275: CALL_OW 255
99279: PUSH
99280: EMPTY
99281: LIST
99282: LIST
99283: PUSH
99284: LD_INT 33
99286: PUSH
99287: LD_INT 3
99289: PUSH
99290: EMPTY
99291: LIST
99292: LIST
99293: PUSH
99294: LD_INT 91
99296: PUSH
99297: LD_VAR 0 1
99301: PUSH
99302: LD_EXP 183
99306: PUSH
99307: EMPTY
99308: LIST
99309: LIST
99310: LIST
99311: PUSH
99312: LD_INT 50
99314: PUSH
99315: EMPTY
99316: LIST
99317: PUSH
99318: EMPTY
99319: LIST
99320: LIST
99321: LIST
99322: LIST
99323: PPUSH
99324: CALL_OW 69
99328: ST_TO_ADDR
// if not tmp then
99329: LD_VAR 0 2
99333: NOT
99334: IFFALSE 99338
// continue ;
99336: GO 99133
// HackLink ( i , tmp ) ;
99338: LD_VAR 0 1
99342: PPUSH
99343: LD_VAR 0 2
99347: PPUSH
99348: CALL 99495 0 2
// end ;
99352: GO 99133
99354: POP
99355: POP
// end ;
99356: PPOPN 2
99358: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99359: LD_INT 0
99361: PPUSH
99362: PPUSH
99363: PPUSH
// if not hack in hackTanks then
99364: LD_VAR 0 1
99368: PUSH
99369: LD_EXP 180
99373: IN
99374: NOT
99375: IFFALSE 99379
// exit ;
99377: GO 99490
// index := GetElementIndex ( hackTanks , hack ) ;
99379: LD_ADDR_VAR 0 4
99383: PUSH
99384: LD_EXP 180
99388: PPUSH
99389: LD_VAR 0 1
99393: PPUSH
99394: CALL 19575 0 2
99398: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99399: LD_EXP 181
99403: PUSH
99404: LD_VAR 0 4
99408: ARRAY
99409: IFFALSE 99490
// begin for i in hackTanksCaptured [ index ] do
99411: LD_ADDR_VAR 0 3
99415: PUSH
99416: LD_EXP 181
99420: PUSH
99421: LD_VAR 0 4
99425: ARRAY
99426: PUSH
99427: FOR_IN
99428: IFFALSE 99454
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99430: LD_VAR 0 3
99434: PUSH
99435: LD_INT 1
99437: ARRAY
99438: PPUSH
99439: LD_VAR 0 3
99443: PUSH
99444: LD_INT 2
99446: ARRAY
99447: PPUSH
99448: CALL_OW 235
99452: GO 99427
99454: POP
99455: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99456: LD_ADDR_EXP 181
99460: PUSH
99461: LD_EXP 181
99465: PPUSH
99466: LD_VAR 0 4
99470: PPUSH
99471: EMPTY
99472: PPUSH
99473: CALL_OW 1
99477: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99478: LD_VAR 0 1
99482: PPUSH
99483: LD_INT 0
99485: PPUSH
99486: CALL_OW 505
// end ; end ;
99490: LD_VAR 0 2
99494: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99495: LD_INT 0
99497: PPUSH
99498: PPUSH
99499: PPUSH
// if not hack in hackTanks or not vehicles then
99500: LD_VAR 0 1
99504: PUSH
99505: LD_EXP 180
99509: IN
99510: NOT
99511: PUSH
99512: LD_VAR 0 2
99516: NOT
99517: OR
99518: IFFALSE 99522
// exit ;
99520: GO 99797
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99522: LD_ADDR_VAR 0 2
99526: PUSH
99527: LD_VAR 0 1
99531: PPUSH
99532: LD_VAR 0 2
99536: PPUSH
99537: LD_INT 1
99539: PPUSH
99540: LD_INT 1
99542: PPUSH
99543: CALL 20225 0 4
99547: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99548: LD_ADDR_VAR 0 5
99552: PUSH
99553: LD_EXP 180
99557: PPUSH
99558: LD_VAR 0 1
99562: PPUSH
99563: CALL 19575 0 2
99567: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99568: LD_EXP 181
99572: PUSH
99573: LD_VAR 0 5
99577: ARRAY
99578: PUSH
99579: LD_EXP 182
99583: LESS
99584: IFFALSE 99773
// begin for i := 1 to vehicles do
99586: LD_ADDR_VAR 0 4
99590: PUSH
99591: DOUBLE
99592: LD_INT 1
99594: DEC
99595: ST_TO_ADDR
99596: LD_VAR 0 2
99600: PUSH
99601: FOR_TO
99602: IFFALSE 99771
// begin if hackTanksCaptured [ index ] = hackLimit then
99604: LD_EXP 181
99608: PUSH
99609: LD_VAR 0 5
99613: ARRAY
99614: PUSH
99615: LD_EXP 182
99619: EQUAL
99620: IFFALSE 99624
// break ;
99622: GO 99771
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99624: LD_ADDR_EXP 184
99628: PUSH
99629: LD_EXP 184
99633: PPUSH
99634: LD_VAR 0 5
99638: PPUSH
99639: LD_EXP 184
99643: PUSH
99644: LD_VAR 0 5
99648: ARRAY
99649: PUSH
99650: LD_INT 1
99652: PLUS
99653: PPUSH
99654: CALL_OW 1
99658: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99659: LD_ADDR_EXP 181
99663: PUSH
99664: LD_EXP 181
99668: PPUSH
99669: LD_VAR 0 5
99673: PUSH
99674: LD_EXP 181
99678: PUSH
99679: LD_VAR 0 5
99683: ARRAY
99684: PUSH
99685: LD_INT 1
99687: PLUS
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PPUSH
99693: LD_VAR 0 2
99697: PUSH
99698: LD_VAR 0 4
99702: ARRAY
99703: PUSH
99704: LD_VAR 0 2
99708: PUSH
99709: LD_VAR 0 4
99713: ARRAY
99714: PPUSH
99715: CALL_OW 255
99719: PUSH
99720: EMPTY
99721: LIST
99722: LIST
99723: PPUSH
99724: CALL 19790 0 3
99728: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99729: LD_VAR 0 2
99733: PUSH
99734: LD_VAR 0 4
99738: ARRAY
99739: PPUSH
99740: LD_VAR 0 1
99744: PPUSH
99745: CALL_OW 255
99749: PPUSH
99750: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99754: LD_VAR 0 2
99758: PUSH
99759: LD_VAR 0 4
99763: ARRAY
99764: PPUSH
99765: CALL_OW 141
// end ;
99769: GO 99601
99771: POP
99772: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99773: LD_VAR 0 1
99777: PPUSH
99778: LD_EXP 181
99782: PUSH
99783: LD_VAR 0 5
99787: ARRAY
99788: PUSH
99789: LD_INT 0
99791: PLUS
99792: PPUSH
99793: CALL_OW 505
// end ;
99797: LD_VAR 0 3
99801: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99802: LD_INT 0
99804: PPUSH
99805: PPUSH
99806: PPUSH
99807: PPUSH
// if not hack in hackTanks then
99808: LD_VAR 0 1
99812: PUSH
99813: LD_EXP 180
99817: IN
99818: NOT
99819: IFFALSE 99823
// exit ;
99821: GO 100063
// index := GetElementIndex ( hackTanks , hack ) ;
99823: LD_ADDR_VAR 0 4
99827: PUSH
99828: LD_EXP 180
99832: PPUSH
99833: LD_VAR 0 1
99837: PPUSH
99838: CALL 19575 0 2
99842: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99843: LD_ADDR_VAR 0 3
99847: PUSH
99848: DOUBLE
99849: LD_EXP 181
99853: PUSH
99854: LD_VAR 0 4
99858: ARRAY
99859: INC
99860: ST_TO_ADDR
99861: LD_INT 1
99863: PUSH
99864: FOR_DOWNTO
99865: IFFALSE 100037
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99867: LD_ADDR_VAR 0 5
99871: PUSH
99872: LD_EXP 181
99876: PUSH
99877: LD_VAR 0 4
99881: ARRAY
99882: PUSH
99883: LD_VAR 0 3
99887: ARRAY
99888: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99889: LD_VAR 0 5
99893: PUSH
99894: LD_INT 1
99896: ARRAY
99897: PPUSH
99898: CALL_OW 302
99902: NOT
99903: PUSH
99904: LD_VAR 0 5
99908: PUSH
99909: LD_INT 1
99911: ARRAY
99912: PPUSH
99913: CALL_OW 255
99917: PUSH
99918: LD_VAR 0 1
99922: PPUSH
99923: CALL_OW 255
99927: NONEQUAL
99928: OR
99929: IFFALSE 100035
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99931: LD_VAR 0 5
99935: PUSH
99936: LD_INT 1
99938: ARRAY
99939: PPUSH
99940: CALL_OW 305
99944: PUSH
99945: LD_VAR 0 5
99949: PUSH
99950: LD_INT 1
99952: ARRAY
99953: PPUSH
99954: CALL_OW 255
99958: PUSH
99959: LD_VAR 0 1
99963: PPUSH
99964: CALL_OW 255
99968: EQUAL
99969: AND
99970: IFFALSE 99994
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
99972: LD_VAR 0 5
99976: PUSH
99977: LD_INT 1
99979: ARRAY
99980: PPUSH
99981: LD_VAR 0 5
99985: PUSH
99986: LD_INT 2
99988: ARRAY
99989: PPUSH
99990: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
99994: LD_ADDR_EXP 181
99998: PUSH
99999: LD_EXP 181
100003: PPUSH
100004: LD_VAR 0 4
100008: PPUSH
100009: LD_EXP 181
100013: PUSH
100014: LD_VAR 0 4
100018: ARRAY
100019: PPUSH
100020: LD_VAR 0 3
100024: PPUSH
100025: CALL_OW 3
100029: PPUSH
100030: CALL_OW 1
100034: ST_TO_ADDR
// end ; end ;
100035: GO 99864
100037: POP
100038: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100039: LD_VAR 0 1
100043: PPUSH
100044: LD_EXP 181
100048: PUSH
100049: LD_VAR 0 4
100053: ARRAY
100054: PUSH
100055: LD_INT 0
100057: PLUS
100058: PPUSH
100059: CALL_OW 505
// end ;
100063: LD_VAR 0 2
100067: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100068: LD_INT 0
100070: PPUSH
100071: PPUSH
100072: PPUSH
100073: PPUSH
// if not hack in hackTanks then
100074: LD_VAR 0 1
100078: PUSH
100079: LD_EXP 180
100083: IN
100084: NOT
100085: IFFALSE 100089
// exit ;
100087: GO 100174
// index := GetElementIndex ( hackTanks , hack ) ;
100089: LD_ADDR_VAR 0 5
100093: PUSH
100094: LD_EXP 180
100098: PPUSH
100099: LD_VAR 0 1
100103: PPUSH
100104: CALL 19575 0 2
100108: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100109: LD_ADDR_VAR 0 4
100113: PUSH
100114: DOUBLE
100115: LD_INT 1
100117: DEC
100118: ST_TO_ADDR
100119: LD_EXP 181
100123: PUSH
100124: LD_VAR 0 5
100128: ARRAY
100129: PUSH
100130: FOR_TO
100131: IFFALSE 100172
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100133: LD_EXP 181
100137: PUSH
100138: LD_VAR 0 5
100142: ARRAY
100143: PUSH
100144: LD_VAR 0 4
100148: ARRAY
100149: PUSH
100150: LD_INT 1
100152: ARRAY
100153: PUSH
100154: LD_VAR 0 2
100158: EQUAL
100159: IFFALSE 100170
// KillUnit ( vehicle ) ;
100161: LD_VAR 0 2
100165: PPUSH
100166: CALL_OW 66
100170: GO 100130
100172: POP
100173: POP
// end ;
100174: LD_VAR 0 3
100178: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100179: LD_EXP 185
100183: NOT
100184: IFFALSE 100219
100186: GO 100188
100188: DISABLE
// begin initMiner := true ;
100189: LD_ADDR_EXP 185
100193: PUSH
100194: LD_INT 1
100196: ST_TO_ADDR
// minersList := [ ] ;
100197: LD_ADDR_EXP 186
100201: PUSH
100202: EMPTY
100203: ST_TO_ADDR
// minerMinesList := [ ] ;
100204: LD_ADDR_EXP 187
100208: PUSH
100209: EMPTY
100210: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100211: LD_ADDR_EXP 188
100215: PUSH
100216: LD_INT 5
100218: ST_TO_ADDR
// end ;
100219: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100220: LD_EXP 185
100224: PUSH
100225: LD_INT 34
100227: PUSH
100228: LD_EXP 110
100232: PUSH
100233: EMPTY
100234: LIST
100235: LIST
100236: PPUSH
100237: CALL_OW 69
100241: AND
100242: IFFALSE 100705
100244: GO 100246
100246: DISABLE
100247: LD_INT 0
100249: PPUSH
100250: PPUSH
100251: PPUSH
100252: PPUSH
// begin enable ;
100253: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
100254: LD_ADDR_VAR 0 1
100258: PUSH
100259: LD_INT 34
100261: PUSH
100262: LD_EXP 110
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PPUSH
100271: CALL_OW 69
100275: PUSH
100276: FOR_IN
100277: IFFALSE 100349
// begin if not i in minersList then
100279: LD_VAR 0 1
100283: PUSH
100284: LD_EXP 186
100288: IN
100289: NOT
100290: IFFALSE 100347
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
100292: LD_ADDR_EXP 186
100296: PUSH
100297: LD_EXP 186
100301: PPUSH
100302: LD_EXP 186
100306: PUSH
100307: LD_INT 1
100309: PLUS
100310: PPUSH
100311: LD_VAR 0 1
100315: PPUSH
100316: CALL_OW 1
100320: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
100321: LD_ADDR_EXP 187
100325: PUSH
100326: LD_EXP 187
100330: PPUSH
100331: LD_EXP 187
100335: PUSH
100336: LD_INT 1
100338: PLUS
100339: PPUSH
100340: EMPTY
100341: PPUSH
100342: CALL_OW 1
100346: ST_TO_ADDR
// end end ;
100347: GO 100276
100349: POP
100350: POP
// for i := minerMinesList downto 1 do
100351: LD_ADDR_VAR 0 1
100355: PUSH
100356: DOUBLE
100357: LD_EXP 187
100361: INC
100362: ST_TO_ADDR
100363: LD_INT 1
100365: PUSH
100366: FOR_DOWNTO
100367: IFFALSE 100703
// begin if IsLive ( minersList [ i ] ) then
100369: LD_EXP 186
100373: PUSH
100374: LD_VAR 0 1
100378: ARRAY
100379: PPUSH
100380: CALL_OW 300
100384: IFFALSE 100412
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
100386: LD_EXP 186
100390: PUSH
100391: LD_VAR 0 1
100395: ARRAY
100396: PPUSH
100397: LD_EXP 187
100401: PUSH
100402: LD_VAR 0 1
100406: ARRAY
100407: PPUSH
100408: CALL_OW 505
// if not minerMinesList [ i ] then
100412: LD_EXP 187
100416: PUSH
100417: LD_VAR 0 1
100421: ARRAY
100422: NOT
100423: IFFALSE 100427
// continue ;
100425: GO 100366
// for j := minerMinesList [ i ] downto 1 do
100427: LD_ADDR_VAR 0 2
100431: PUSH
100432: DOUBLE
100433: LD_EXP 187
100437: PUSH
100438: LD_VAR 0 1
100442: ARRAY
100443: INC
100444: ST_TO_ADDR
100445: LD_INT 1
100447: PUSH
100448: FOR_DOWNTO
100449: IFFALSE 100699
// begin side := GetSide ( minersList [ i ] ) ;
100451: LD_ADDR_VAR 0 3
100455: PUSH
100456: LD_EXP 186
100460: PUSH
100461: LD_VAR 0 1
100465: ARRAY
100466: PPUSH
100467: CALL_OW 255
100471: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100472: LD_ADDR_VAR 0 4
100476: PUSH
100477: LD_EXP 187
100481: PUSH
100482: LD_VAR 0 1
100486: ARRAY
100487: PUSH
100488: LD_VAR 0 2
100492: ARRAY
100493: PUSH
100494: LD_INT 1
100496: ARRAY
100497: PPUSH
100498: LD_EXP 187
100502: PUSH
100503: LD_VAR 0 1
100507: ARRAY
100508: PUSH
100509: LD_VAR 0 2
100513: ARRAY
100514: PUSH
100515: LD_INT 2
100517: ARRAY
100518: PPUSH
100519: CALL_OW 428
100523: ST_TO_ADDR
// if not tmp then
100524: LD_VAR 0 4
100528: NOT
100529: IFFALSE 100533
// continue ;
100531: GO 100448
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100533: LD_VAR 0 4
100537: PUSH
100538: LD_INT 81
100540: PUSH
100541: LD_VAR 0 3
100545: PUSH
100546: EMPTY
100547: LIST
100548: LIST
100549: PPUSH
100550: CALL_OW 69
100554: IN
100555: PUSH
100556: LD_EXP 187
100560: PUSH
100561: LD_VAR 0 1
100565: ARRAY
100566: PUSH
100567: LD_VAR 0 2
100571: ARRAY
100572: PUSH
100573: LD_INT 1
100575: ARRAY
100576: PPUSH
100577: LD_EXP 187
100581: PUSH
100582: LD_VAR 0 1
100586: ARRAY
100587: PUSH
100588: LD_VAR 0 2
100592: ARRAY
100593: PUSH
100594: LD_INT 2
100596: ARRAY
100597: PPUSH
100598: CALL_OW 458
100602: AND
100603: IFFALSE 100697
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100605: LD_EXP 187
100609: PUSH
100610: LD_VAR 0 1
100614: ARRAY
100615: PUSH
100616: LD_VAR 0 2
100620: ARRAY
100621: PUSH
100622: LD_INT 1
100624: ARRAY
100625: PPUSH
100626: LD_EXP 187
100630: PUSH
100631: LD_VAR 0 1
100635: ARRAY
100636: PUSH
100637: LD_VAR 0 2
100641: ARRAY
100642: PUSH
100643: LD_INT 2
100645: ARRAY
100646: PPUSH
100647: LD_VAR 0 3
100651: PPUSH
100652: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100656: LD_ADDR_EXP 187
100660: PUSH
100661: LD_EXP 187
100665: PPUSH
100666: LD_VAR 0 1
100670: PPUSH
100671: LD_EXP 187
100675: PUSH
100676: LD_VAR 0 1
100680: ARRAY
100681: PPUSH
100682: LD_VAR 0 2
100686: PPUSH
100687: CALL_OW 3
100691: PPUSH
100692: CALL_OW 1
100696: ST_TO_ADDR
// end ; end ;
100697: GO 100448
100699: POP
100700: POP
// end ;
100701: GO 100366
100703: POP
100704: POP
// end ;
100705: PPOPN 4
100707: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100708: LD_INT 0
100710: PPUSH
100711: PPUSH
// result := false ;
100712: LD_ADDR_VAR 0 4
100716: PUSH
100717: LD_INT 0
100719: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100720: LD_VAR 0 1
100724: PPUSH
100725: CALL_OW 264
100729: PUSH
100730: LD_EXP 110
100734: EQUAL
100735: NOT
100736: IFFALSE 100740
// exit ;
100738: GO 100980
// index := GetElementIndex ( minersList , unit ) ;
100740: LD_ADDR_VAR 0 5
100744: PUSH
100745: LD_EXP 186
100749: PPUSH
100750: LD_VAR 0 1
100754: PPUSH
100755: CALL 19575 0 2
100759: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100760: LD_EXP 187
100764: PUSH
100765: LD_VAR 0 5
100769: ARRAY
100770: PUSH
100771: LD_EXP 188
100775: GREATEREQUAL
100776: IFFALSE 100780
// exit ;
100778: GO 100980
// ComMoveXY ( unit , x , y ) ;
100780: LD_VAR 0 1
100784: PPUSH
100785: LD_VAR 0 2
100789: PPUSH
100790: LD_VAR 0 3
100794: PPUSH
100795: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100799: LD_INT 35
100801: PPUSH
100802: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100806: LD_VAR 0 1
100810: PPUSH
100811: LD_VAR 0 2
100815: PPUSH
100816: LD_VAR 0 3
100820: PPUSH
100821: CALL 50347 0 3
100825: NOT
100826: PUSH
100827: LD_VAR 0 1
100831: PPUSH
100832: CALL_OW 314
100836: AND
100837: IFFALSE 100841
// exit ;
100839: GO 100980
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100841: LD_VAR 0 2
100845: PPUSH
100846: LD_VAR 0 3
100850: PPUSH
100851: CALL_OW 428
100855: PUSH
100856: LD_VAR 0 1
100860: EQUAL
100861: PUSH
100862: LD_VAR 0 1
100866: PPUSH
100867: CALL_OW 314
100871: NOT
100872: AND
100873: IFFALSE 100799
// PlaySoundXY ( x , y , PlantMine ) ;
100875: LD_VAR 0 2
100879: PPUSH
100880: LD_VAR 0 3
100884: PPUSH
100885: LD_STRING PlantMine
100887: PPUSH
100888: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100892: LD_VAR 0 2
100896: PPUSH
100897: LD_VAR 0 3
100901: PPUSH
100902: LD_VAR 0 1
100906: PPUSH
100907: CALL_OW 255
100911: PPUSH
100912: LD_INT 0
100914: PPUSH
100915: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100919: LD_ADDR_EXP 187
100923: PUSH
100924: LD_EXP 187
100928: PPUSH
100929: LD_VAR 0 5
100933: PUSH
100934: LD_EXP 187
100938: PUSH
100939: LD_VAR 0 5
100943: ARRAY
100944: PUSH
100945: LD_INT 1
100947: PLUS
100948: PUSH
100949: EMPTY
100950: LIST
100951: LIST
100952: PPUSH
100953: LD_VAR 0 2
100957: PUSH
100958: LD_VAR 0 3
100962: PUSH
100963: EMPTY
100964: LIST
100965: LIST
100966: PPUSH
100967: CALL 19790 0 3
100971: ST_TO_ADDR
// result := true ;
100972: LD_ADDR_VAR 0 4
100976: PUSH
100977: LD_INT 1
100979: ST_TO_ADDR
// end ;
100980: LD_VAR 0 4
100984: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
100985: LD_INT 0
100987: PPUSH
100988: PPUSH
100989: PPUSH
// if not unit in minersList then
100990: LD_VAR 0 1
100994: PUSH
100995: LD_EXP 186
100999: IN
101000: NOT
101001: IFFALSE 101005
// exit ;
101003: GO 101397
// index := GetElementIndex ( minersList , unit ) ;
101005: LD_ADDR_VAR 0 6
101009: PUSH
101010: LD_EXP 186
101014: PPUSH
101015: LD_VAR 0 1
101019: PPUSH
101020: CALL 19575 0 2
101024: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101025: LD_ADDR_VAR 0 5
101029: PUSH
101030: DOUBLE
101031: LD_EXP 187
101035: PUSH
101036: LD_VAR 0 6
101040: ARRAY
101041: INC
101042: ST_TO_ADDR
101043: LD_INT 1
101045: PUSH
101046: FOR_DOWNTO
101047: IFFALSE 101208
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101049: LD_EXP 187
101053: PUSH
101054: LD_VAR 0 6
101058: ARRAY
101059: PUSH
101060: LD_VAR 0 5
101064: ARRAY
101065: PUSH
101066: LD_INT 1
101068: ARRAY
101069: PUSH
101070: LD_VAR 0 2
101074: EQUAL
101075: PUSH
101076: LD_EXP 187
101080: PUSH
101081: LD_VAR 0 6
101085: ARRAY
101086: PUSH
101087: LD_VAR 0 5
101091: ARRAY
101092: PUSH
101093: LD_INT 2
101095: ARRAY
101096: PUSH
101097: LD_VAR 0 3
101101: EQUAL
101102: AND
101103: IFFALSE 101206
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101105: LD_EXP 187
101109: PUSH
101110: LD_VAR 0 6
101114: ARRAY
101115: PUSH
101116: LD_VAR 0 5
101120: ARRAY
101121: PUSH
101122: LD_INT 1
101124: ARRAY
101125: PPUSH
101126: LD_EXP 187
101130: PUSH
101131: LD_VAR 0 6
101135: ARRAY
101136: PUSH
101137: LD_VAR 0 5
101141: ARRAY
101142: PUSH
101143: LD_INT 2
101145: ARRAY
101146: PPUSH
101147: LD_VAR 0 1
101151: PPUSH
101152: CALL_OW 255
101156: PPUSH
101157: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101161: LD_ADDR_EXP 187
101165: PUSH
101166: LD_EXP 187
101170: PPUSH
101171: LD_VAR 0 6
101175: PPUSH
101176: LD_EXP 187
101180: PUSH
101181: LD_VAR 0 6
101185: ARRAY
101186: PPUSH
101187: LD_VAR 0 5
101191: PPUSH
101192: CALL_OW 3
101196: PPUSH
101197: CALL_OW 1
101201: ST_TO_ADDR
// exit ;
101202: POP
101203: POP
101204: GO 101397
// end ; end ;
101206: GO 101046
101208: POP
101209: POP
// for i := minerMinesList [ index ] downto 1 do
101210: LD_ADDR_VAR 0 5
101214: PUSH
101215: DOUBLE
101216: LD_EXP 187
101220: PUSH
101221: LD_VAR 0 6
101225: ARRAY
101226: INC
101227: ST_TO_ADDR
101228: LD_INT 1
101230: PUSH
101231: FOR_DOWNTO
101232: IFFALSE 101395
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101234: LD_EXP 187
101238: PUSH
101239: LD_VAR 0 6
101243: ARRAY
101244: PUSH
101245: LD_VAR 0 5
101249: ARRAY
101250: PUSH
101251: LD_INT 1
101253: ARRAY
101254: PPUSH
101255: LD_EXP 187
101259: PUSH
101260: LD_VAR 0 6
101264: ARRAY
101265: PUSH
101266: LD_VAR 0 5
101270: ARRAY
101271: PUSH
101272: LD_INT 2
101274: ARRAY
101275: PPUSH
101276: LD_VAR 0 2
101280: PPUSH
101281: LD_VAR 0 3
101285: PPUSH
101286: CALL_OW 298
101290: PUSH
101291: LD_INT 6
101293: LESS
101294: IFFALSE 101393
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101296: LD_EXP 187
101300: PUSH
101301: LD_VAR 0 6
101305: ARRAY
101306: PUSH
101307: LD_VAR 0 5
101311: ARRAY
101312: PUSH
101313: LD_INT 1
101315: ARRAY
101316: PPUSH
101317: LD_EXP 187
101321: PUSH
101322: LD_VAR 0 6
101326: ARRAY
101327: PUSH
101328: LD_VAR 0 5
101332: ARRAY
101333: PUSH
101334: LD_INT 2
101336: ARRAY
101337: PPUSH
101338: LD_VAR 0 1
101342: PPUSH
101343: CALL_OW 255
101347: PPUSH
101348: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101352: LD_ADDR_EXP 187
101356: PUSH
101357: LD_EXP 187
101361: PPUSH
101362: LD_VAR 0 6
101366: PPUSH
101367: LD_EXP 187
101371: PUSH
101372: LD_VAR 0 6
101376: ARRAY
101377: PPUSH
101378: LD_VAR 0 5
101382: PPUSH
101383: CALL_OW 3
101387: PPUSH
101388: CALL_OW 1
101392: ST_TO_ADDR
// end ; end ;
101393: GO 101231
101395: POP
101396: POP
// end ;
101397: LD_VAR 0 4
101401: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
101402: LD_INT 0
101404: PPUSH
101405: PPUSH
101406: PPUSH
101407: PPUSH
101408: PPUSH
101409: PPUSH
101410: PPUSH
101411: PPUSH
101412: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
101413: LD_VAR 0 1
101417: PPUSH
101418: CALL_OW 264
101422: PUSH
101423: LD_EXP 110
101427: EQUAL
101428: NOT
101429: PUSH
101430: LD_VAR 0 1
101434: PUSH
101435: LD_EXP 186
101439: IN
101440: NOT
101441: OR
101442: IFFALSE 101446
// exit ;
101444: GO 101768
// index := GetElementIndex ( minersList , unit ) ;
101446: LD_ADDR_VAR 0 6
101450: PUSH
101451: LD_EXP 186
101455: PPUSH
101456: LD_VAR 0 1
101460: PPUSH
101461: CALL 19575 0 2
101465: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101466: LD_ADDR_VAR 0 8
101470: PUSH
101471: LD_EXP 188
101475: PUSH
101476: LD_EXP 187
101480: PUSH
101481: LD_VAR 0 6
101485: ARRAY
101486: MINUS
101487: ST_TO_ADDR
// if not minesFreeAmount then
101488: LD_VAR 0 8
101492: NOT
101493: IFFALSE 101497
// exit ;
101495: GO 101768
// tmp := [ ] ;
101497: LD_ADDR_VAR 0 7
101501: PUSH
101502: EMPTY
101503: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101504: LD_ADDR_VAR 0 5
101508: PUSH
101509: DOUBLE
101510: LD_INT 1
101512: DEC
101513: ST_TO_ADDR
101514: LD_VAR 0 8
101518: PUSH
101519: FOR_TO
101520: IFFALSE 101715
// begin _d := rand ( 0 , 5 ) ;
101522: LD_ADDR_VAR 0 11
101526: PUSH
101527: LD_INT 0
101529: PPUSH
101530: LD_INT 5
101532: PPUSH
101533: CALL_OW 12
101537: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101538: LD_ADDR_VAR 0 12
101542: PUSH
101543: LD_INT 2
101545: PPUSH
101546: LD_INT 6
101548: PPUSH
101549: CALL_OW 12
101553: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101554: LD_ADDR_VAR 0 9
101558: PUSH
101559: LD_VAR 0 2
101563: PPUSH
101564: LD_VAR 0 11
101568: PPUSH
101569: LD_VAR 0 12
101573: PPUSH
101574: CALL_OW 272
101578: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101579: LD_ADDR_VAR 0 10
101583: PUSH
101584: LD_VAR 0 3
101588: PPUSH
101589: LD_VAR 0 11
101593: PPUSH
101594: LD_VAR 0 12
101598: PPUSH
101599: CALL_OW 273
101603: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101604: LD_VAR 0 9
101608: PPUSH
101609: LD_VAR 0 10
101613: PPUSH
101614: CALL_OW 488
101618: PUSH
101619: LD_VAR 0 9
101623: PUSH
101624: LD_VAR 0 10
101628: PUSH
101629: EMPTY
101630: LIST
101631: LIST
101632: PUSH
101633: LD_VAR 0 7
101637: IN
101638: NOT
101639: AND
101640: PUSH
101641: LD_VAR 0 9
101645: PPUSH
101646: LD_VAR 0 10
101650: PPUSH
101651: CALL_OW 458
101655: NOT
101656: AND
101657: IFFALSE 101699
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101659: LD_ADDR_VAR 0 7
101663: PUSH
101664: LD_VAR 0 7
101668: PPUSH
101669: LD_VAR 0 7
101673: PUSH
101674: LD_INT 1
101676: PLUS
101677: PPUSH
101678: LD_VAR 0 9
101682: PUSH
101683: LD_VAR 0 10
101687: PUSH
101688: EMPTY
101689: LIST
101690: LIST
101691: PPUSH
101692: CALL_OW 1
101696: ST_TO_ADDR
101697: GO 101713
// i := i - 1 ;
101699: LD_ADDR_VAR 0 5
101703: PUSH
101704: LD_VAR 0 5
101708: PUSH
101709: LD_INT 1
101711: MINUS
101712: ST_TO_ADDR
// end ;
101713: GO 101519
101715: POP
101716: POP
// for i in tmp do
101717: LD_ADDR_VAR 0 5
101721: PUSH
101722: LD_VAR 0 7
101726: PUSH
101727: FOR_IN
101728: IFFALSE 101766
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101730: LD_VAR 0 1
101734: PPUSH
101735: LD_VAR 0 5
101739: PUSH
101740: LD_INT 1
101742: ARRAY
101743: PPUSH
101744: LD_VAR 0 5
101748: PUSH
101749: LD_INT 2
101751: ARRAY
101752: PPUSH
101753: CALL 100708 0 3
101757: NOT
101758: IFFALSE 101764
// exit ;
101760: POP
101761: POP
101762: GO 101768
101764: GO 101727
101766: POP
101767: POP
// end ;
101768: LD_VAR 0 4
101772: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101773: LD_INT 0
101775: PPUSH
101776: PPUSH
101777: PPUSH
101778: PPUSH
101779: PPUSH
101780: PPUSH
101781: PPUSH
// if not GetClass ( unit ) = class_sniper then
101782: LD_VAR 0 1
101786: PPUSH
101787: CALL_OW 257
101791: PUSH
101792: LD_INT 5
101794: EQUAL
101795: NOT
101796: IFFALSE 101800
// exit ;
101798: GO 102188
// dist := 8 ;
101800: LD_ADDR_VAR 0 5
101804: PUSH
101805: LD_INT 8
101807: ST_TO_ADDR
// viewRange := 12 ;
101808: LD_ADDR_VAR 0 7
101812: PUSH
101813: LD_INT 12
101815: ST_TO_ADDR
// side := GetSide ( unit ) ;
101816: LD_ADDR_VAR 0 6
101820: PUSH
101821: LD_VAR 0 1
101825: PPUSH
101826: CALL_OW 255
101830: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101831: LD_INT 61
101833: PPUSH
101834: LD_VAR 0 6
101838: PPUSH
101839: CALL_OW 321
101843: PUSH
101844: LD_INT 2
101846: EQUAL
101847: IFFALSE 101857
// viewRange := 16 ;
101849: LD_ADDR_VAR 0 7
101853: PUSH
101854: LD_INT 16
101856: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101857: LD_VAR 0 1
101861: PPUSH
101862: LD_VAR 0 2
101866: PPUSH
101867: LD_VAR 0 3
101871: PPUSH
101872: CALL_OW 297
101876: PUSH
101877: LD_VAR 0 5
101881: GREATER
101882: IFFALSE 101961
// begin ComMoveXY ( unit , x , y ) ;
101884: LD_VAR 0 1
101888: PPUSH
101889: LD_VAR 0 2
101893: PPUSH
101894: LD_VAR 0 3
101898: PPUSH
101899: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101903: LD_INT 35
101905: PPUSH
101906: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101910: LD_VAR 0 1
101914: PPUSH
101915: LD_VAR 0 2
101919: PPUSH
101920: LD_VAR 0 3
101924: PPUSH
101925: CALL 50347 0 3
101929: NOT
101930: IFFALSE 101934
// exit ;
101932: GO 102188
// until GetDistUnitXY ( unit , x , y ) < dist ;
101934: LD_VAR 0 1
101938: PPUSH
101939: LD_VAR 0 2
101943: PPUSH
101944: LD_VAR 0 3
101948: PPUSH
101949: CALL_OW 297
101953: PUSH
101954: LD_VAR 0 5
101958: LESS
101959: IFFALSE 101903
// end ; ComTurnXY ( unit , x , y ) ;
101961: LD_VAR 0 1
101965: PPUSH
101966: LD_VAR 0 2
101970: PPUSH
101971: LD_VAR 0 3
101975: PPUSH
101976: CALL_OW 118
// wait ( 5 ) ;
101980: LD_INT 5
101982: PPUSH
101983: CALL_OW 67
// _d := GetDir ( unit ) ;
101987: LD_ADDR_VAR 0 10
101991: PUSH
101992: LD_VAR 0 1
101996: PPUSH
101997: CALL_OW 254
102001: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102002: LD_ADDR_VAR 0 8
102006: PUSH
102007: LD_VAR 0 1
102011: PPUSH
102012: CALL_OW 250
102016: PPUSH
102017: LD_VAR 0 10
102021: PPUSH
102022: LD_VAR 0 5
102026: PPUSH
102027: CALL_OW 272
102031: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102032: LD_ADDR_VAR 0 9
102036: PUSH
102037: LD_VAR 0 1
102041: PPUSH
102042: CALL_OW 251
102046: PPUSH
102047: LD_VAR 0 10
102051: PPUSH
102052: LD_VAR 0 5
102056: PPUSH
102057: CALL_OW 273
102061: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102062: LD_VAR 0 8
102066: PPUSH
102067: LD_VAR 0 9
102071: PPUSH
102072: CALL_OW 488
102076: NOT
102077: IFFALSE 102081
// exit ;
102079: GO 102188
// ComAnimCustom ( unit , 1 ) ;
102081: LD_VAR 0 1
102085: PPUSH
102086: LD_INT 1
102088: PPUSH
102089: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102093: LD_VAR 0 8
102097: PPUSH
102098: LD_VAR 0 9
102102: PPUSH
102103: LD_VAR 0 6
102107: PPUSH
102108: LD_VAR 0 7
102112: PPUSH
102113: CALL_OW 330
// repeat wait ( 1 ) ;
102117: LD_INT 1
102119: PPUSH
102120: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102124: LD_VAR 0 1
102128: PPUSH
102129: CALL_OW 316
102133: PUSH
102134: LD_VAR 0 1
102138: PPUSH
102139: CALL_OW 314
102143: OR
102144: PUSH
102145: LD_VAR 0 1
102149: PPUSH
102150: CALL_OW 302
102154: NOT
102155: OR
102156: PUSH
102157: LD_VAR 0 1
102161: PPUSH
102162: CALL_OW 301
102166: OR
102167: IFFALSE 102117
// RemoveSeeing ( _x , _y , side ) ;
102169: LD_VAR 0 8
102173: PPUSH
102174: LD_VAR 0 9
102178: PPUSH
102179: LD_VAR 0 6
102183: PPUSH
102184: CALL_OW 331
// end ; end_of_file
102188: LD_VAR 0 4
102192: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102193: LD_INT 0
102195: PPUSH
102196: PPUSH
102197: PPUSH
102198: PPUSH
102199: PPUSH
102200: PPUSH
102201: PPUSH
102202: PPUSH
102203: PPUSH
102204: PPUSH
102205: PPUSH
102206: PPUSH
102207: PPUSH
102208: PPUSH
102209: PPUSH
102210: PPUSH
102211: PPUSH
102212: PPUSH
102213: PPUSH
102214: PPUSH
102215: PPUSH
102216: PPUSH
102217: PPUSH
102218: PPUSH
102219: PPUSH
102220: PPUSH
102221: PPUSH
102222: PPUSH
102223: PPUSH
102224: PPUSH
102225: PPUSH
102226: PPUSH
102227: PPUSH
102228: PPUSH
// if not list then
102229: LD_VAR 0 1
102233: NOT
102234: IFFALSE 102238
// exit ;
102236: GO 106897
// base := list [ 1 ] ;
102238: LD_ADDR_VAR 0 3
102242: PUSH
102243: LD_VAR 0 1
102247: PUSH
102248: LD_INT 1
102250: ARRAY
102251: ST_TO_ADDR
// group := list [ 2 ] ;
102252: LD_ADDR_VAR 0 4
102256: PUSH
102257: LD_VAR 0 1
102261: PUSH
102262: LD_INT 2
102264: ARRAY
102265: ST_TO_ADDR
// path := list [ 3 ] ;
102266: LD_ADDR_VAR 0 5
102270: PUSH
102271: LD_VAR 0 1
102275: PUSH
102276: LD_INT 3
102278: ARRAY
102279: ST_TO_ADDR
// flags := list [ 4 ] ;
102280: LD_ADDR_VAR 0 6
102284: PUSH
102285: LD_VAR 0 1
102289: PUSH
102290: LD_INT 4
102292: ARRAY
102293: ST_TO_ADDR
// mined := [ ] ;
102294: LD_ADDR_VAR 0 27
102298: PUSH
102299: EMPTY
102300: ST_TO_ADDR
// bombed := [ ] ;
102301: LD_ADDR_VAR 0 28
102305: PUSH
102306: EMPTY
102307: ST_TO_ADDR
// healers := [ ] ;
102308: LD_ADDR_VAR 0 31
102312: PUSH
102313: EMPTY
102314: ST_TO_ADDR
// to_heal := [ ] ;
102315: LD_ADDR_VAR 0 30
102319: PUSH
102320: EMPTY
102321: ST_TO_ADDR
// repairs := [ ] ;
102322: LD_ADDR_VAR 0 33
102326: PUSH
102327: EMPTY
102328: ST_TO_ADDR
// to_repair := [ ] ;
102329: LD_ADDR_VAR 0 32
102333: PUSH
102334: EMPTY
102335: ST_TO_ADDR
// if not group or not path then
102336: LD_VAR 0 4
102340: NOT
102341: PUSH
102342: LD_VAR 0 5
102346: NOT
102347: OR
102348: IFFALSE 102352
// exit ;
102350: GO 106897
// side := GetSide ( group [ 1 ] ) ;
102352: LD_ADDR_VAR 0 35
102356: PUSH
102357: LD_VAR 0 4
102361: PUSH
102362: LD_INT 1
102364: ARRAY
102365: PPUSH
102366: CALL_OW 255
102370: ST_TO_ADDR
// if flags then
102371: LD_VAR 0 6
102375: IFFALSE 102519
// begin f_ignore_area := flags [ 1 ] ;
102377: LD_ADDR_VAR 0 17
102381: PUSH
102382: LD_VAR 0 6
102386: PUSH
102387: LD_INT 1
102389: ARRAY
102390: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
102391: LD_ADDR_VAR 0 18
102395: PUSH
102396: LD_VAR 0 6
102400: PUSH
102401: LD_INT 2
102403: ARRAY
102404: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
102405: LD_ADDR_VAR 0 19
102409: PUSH
102410: LD_VAR 0 6
102414: PUSH
102415: LD_INT 3
102417: ARRAY
102418: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
102419: LD_ADDR_VAR 0 20
102423: PUSH
102424: LD_VAR 0 6
102428: PUSH
102429: LD_INT 4
102431: ARRAY
102432: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
102433: LD_ADDR_VAR 0 21
102437: PUSH
102438: LD_VAR 0 6
102442: PUSH
102443: LD_INT 5
102445: ARRAY
102446: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
102447: LD_ADDR_VAR 0 22
102451: PUSH
102452: LD_VAR 0 6
102456: PUSH
102457: LD_INT 6
102459: ARRAY
102460: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102461: LD_ADDR_VAR 0 23
102465: PUSH
102466: LD_VAR 0 6
102470: PUSH
102471: LD_INT 7
102473: ARRAY
102474: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102475: LD_ADDR_VAR 0 24
102479: PUSH
102480: LD_VAR 0 6
102484: PUSH
102485: LD_INT 8
102487: ARRAY
102488: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102489: LD_ADDR_VAR 0 25
102493: PUSH
102494: LD_VAR 0 6
102498: PUSH
102499: LD_INT 9
102501: ARRAY
102502: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102503: LD_ADDR_VAR 0 26
102507: PUSH
102508: LD_VAR 0 6
102512: PUSH
102513: LD_INT 10
102515: ARRAY
102516: ST_TO_ADDR
// end else
102517: GO 102599
// begin f_ignore_area := false ;
102519: LD_ADDR_VAR 0 17
102523: PUSH
102524: LD_INT 0
102526: ST_TO_ADDR
// f_capture := false ;
102527: LD_ADDR_VAR 0 18
102531: PUSH
102532: LD_INT 0
102534: ST_TO_ADDR
// f_ignore_civ := false ;
102535: LD_ADDR_VAR 0 19
102539: PUSH
102540: LD_INT 0
102542: ST_TO_ADDR
// f_murder := false ;
102543: LD_ADDR_VAR 0 20
102547: PUSH
102548: LD_INT 0
102550: ST_TO_ADDR
// f_mines := false ;
102551: LD_ADDR_VAR 0 21
102555: PUSH
102556: LD_INT 0
102558: ST_TO_ADDR
// f_repair := false ;
102559: LD_ADDR_VAR 0 22
102563: PUSH
102564: LD_INT 0
102566: ST_TO_ADDR
// f_heal := false ;
102567: LD_ADDR_VAR 0 23
102571: PUSH
102572: LD_INT 0
102574: ST_TO_ADDR
// f_spacetime := false ;
102575: LD_ADDR_VAR 0 24
102579: PUSH
102580: LD_INT 0
102582: ST_TO_ADDR
// f_attack_depot := false ;
102583: LD_ADDR_VAR 0 25
102587: PUSH
102588: LD_INT 0
102590: ST_TO_ADDR
// f_crawl := false ;
102591: LD_ADDR_VAR 0 26
102595: PUSH
102596: LD_INT 0
102598: ST_TO_ADDR
// end ; if f_heal then
102599: LD_VAR 0 23
102603: IFFALSE 102630
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102605: LD_ADDR_VAR 0 31
102609: PUSH
102610: LD_VAR 0 4
102614: PPUSH
102615: LD_INT 25
102617: PUSH
102618: LD_INT 4
102620: PUSH
102621: EMPTY
102622: LIST
102623: LIST
102624: PPUSH
102625: CALL_OW 72
102629: ST_TO_ADDR
// if f_repair then
102630: LD_VAR 0 22
102634: IFFALSE 102661
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102636: LD_ADDR_VAR 0 33
102640: PUSH
102641: LD_VAR 0 4
102645: PPUSH
102646: LD_INT 25
102648: PUSH
102649: LD_INT 3
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: PPUSH
102656: CALL_OW 72
102660: ST_TO_ADDR
// units_path := [ ] ;
102661: LD_ADDR_VAR 0 16
102665: PUSH
102666: EMPTY
102667: ST_TO_ADDR
// for i = 1 to group do
102668: LD_ADDR_VAR 0 7
102672: PUSH
102673: DOUBLE
102674: LD_INT 1
102676: DEC
102677: ST_TO_ADDR
102678: LD_VAR 0 4
102682: PUSH
102683: FOR_TO
102684: IFFALSE 102713
// units_path := Replace ( units_path , i , path ) ;
102686: LD_ADDR_VAR 0 16
102690: PUSH
102691: LD_VAR 0 16
102695: PPUSH
102696: LD_VAR 0 7
102700: PPUSH
102701: LD_VAR 0 5
102705: PPUSH
102706: CALL_OW 1
102710: ST_TO_ADDR
102711: GO 102683
102713: POP
102714: POP
// repeat for i = group downto 1 do
102715: LD_ADDR_VAR 0 7
102719: PUSH
102720: DOUBLE
102721: LD_VAR 0 4
102725: INC
102726: ST_TO_ADDR
102727: LD_INT 1
102729: PUSH
102730: FOR_DOWNTO
102731: IFFALSE 106853
// begin wait ( 5 ) ;
102733: LD_INT 5
102735: PPUSH
102736: CALL_OW 67
// tmp := [ ] ;
102740: LD_ADDR_VAR 0 14
102744: PUSH
102745: EMPTY
102746: ST_TO_ADDR
// attacking := false ;
102747: LD_ADDR_VAR 0 29
102751: PUSH
102752: LD_INT 0
102754: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102755: LD_VAR 0 4
102759: PUSH
102760: LD_VAR 0 7
102764: ARRAY
102765: PPUSH
102766: CALL_OW 301
102770: PUSH
102771: LD_VAR 0 4
102775: PUSH
102776: LD_VAR 0 7
102780: ARRAY
102781: NOT
102782: OR
102783: IFFALSE 102892
// begin if GetType ( group [ i ] ) = unit_human then
102785: LD_VAR 0 4
102789: PUSH
102790: LD_VAR 0 7
102794: ARRAY
102795: PPUSH
102796: CALL_OW 247
102800: PUSH
102801: LD_INT 1
102803: EQUAL
102804: IFFALSE 102850
// begin to_heal := to_heal diff group [ i ] ;
102806: LD_ADDR_VAR 0 30
102810: PUSH
102811: LD_VAR 0 30
102815: PUSH
102816: LD_VAR 0 4
102820: PUSH
102821: LD_VAR 0 7
102825: ARRAY
102826: DIFF
102827: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102828: LD_ADDR_VAR 0 31
102832: PUSH
102833: LD_VAR 0 31
102837: PUSH
102838: LD_VAR 0 4
102842: PUSH
102843: LD_VAR 0 7
102847: ARRAY
102848: DIFF
102849: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102850: LD_ADDR_VAR 0 4
102854: PUSH
102855: LD_VAR 0 4
102859: PPUSH
102860: LD_VAR 0 7
102864: PPUSH
102865: CALL_OW 3
102869: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102870: LD_ADDR_VAR 0 16
102874: PUSH
102875: LD_VAR 0 16
102879: PPUSH
102880: LD_VAR 0 7
102884: PPUSH
102885: CALL_OW 3
102889: ST_TO_ADDR
// continue ;
102890: GO 102730
// end ; if f_repair then
102892: LD_VAR 0 22
102896: IFFALSE 103385
// begin if GetType ( group [ i ] ) = unit_vehicle then
102898: LD_VAR 0 4
102902: PUSH
102903: LD_VAR 0 7
102907: ARRAY
102908: PPUSH
102909: CALL_OW 247
102913: PUSH
102914: LD_INT 2
102916: EQUAL
102917: IFFALSE 103107
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102919: LD_VAR 0 4
102923: PUSH
102924: LD_VAR 0 7
102928: ARRAY
102929: PPUSH
102930: CALL_OW 256
102934: PUSH
102935: LD_INT 700
102937: LESS
102938: PUSH
102939: LD_VAR 0 4
102943: PUSH
102944: LD_VAR 0 7
102948: ARRAY
102949: PUSH
102950: LD_VAR 0 32
102954: IN
102955: NOT
102956: AND
102957: IFFALSE 102981
// to_repair := to_repair union group [ i ] ;
102959: LD_ADDR_VAR 0 32
102963: PUSH
102964: LD_VAR 0 32
102968: PUSH
102969: LD_VAR 0 4
102973: PUSH
102974: LD_VAR 0 7
102978: ARRAY
102979: UNION
102980: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
102981: LD_VAR 0 4
102985: PUSH
102986: LD_VAR 0 7
102990: ARRAY
102991: PPUSH
102992: CALL_OW 256
102996: PUSH
102997: LD_INT 1000
102999: EQUAL
103000: PUSH
103001: LD_VAR 0 4
103005: PUSH
103006: LD_VAR 0 7
103010: ARRAY
103011: PUSH
103012: LD_VAR 0 32
103016: IN
103017: AND
103018: IFFALSE 103042
// to_repair := to_repair diff group [ i ] ;
103020: LD_ADDR_VAR 0 32
103024: PUSH
103025: LD_VAR 0 32
103029: PUSH
103030: LD_VAR 0 4
103034: PUSH
103035: LD_VAR 0 7
103039: ARRAY
103040: DIFF
103041: ST_TO_ADDR
// if group [ i ] in to_repair then
103042: LD_VAR 0 4
103046: PUSH
103047: LD_VAR 0 7
103051: ARRAY
103052: PUSH
103053: LD_VAR 0 32
103057: IN
103058: IFFALSE 103105
// begin if not IsInArea ( group [ i ] , f_repair ) then
103060: LD_VAR 0 4
103064: PUSH
103065: LD_VAR 0 7
103069: ARRAY
103070: PPUSH
103071: LD_VAR 0 22
103075: PPUSH
103076: CALL_OW 308
103080: NOT
103081: IFFALSE 103103
// ComMoveToArea ( group [ i ] , f_repair ) ;
103083: LD_VAR 0 4
103087: PUSH
103088: LD_VAR 0 7
103092: ARRAY
103093: PPUSH
103094: LD_VAR 0 22
103098: PPUSH
103099: CALL_OW 113
// continue ;
103103: GO 102730
// end ; end else
103105: GO 103385
// if group [ i ] in repairs then
103107: LD_VAR 0 4
103111: PUSH
103112: LD_VAR 0 7
103116: ARRAY
103117: PUSH
103118: LD_VAR 0 33
103122: IN
103123: IFFALSE 103385
// begin if IsInUnit ( group [ i ] ) then
103125: LD_VAR 0 4
103129: PUSH
103130: LD_VAR 0 7
103134: ARRAY
103135: PPUSH
103136: CALL_OW 310
103140: IFFALSE 103208
// begin z := IsInUnit ( group [ i ] ) ;
103142: LD_ADDR_VAR 0 13
103146: PUSH
103147: LD_VAR 0 4
103151: PUSH
103152: LD_VAR 0 7
103156: ARRAY
103157: PPUSH
103158: CALL_OW 310
103162: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103163: LD_VAR 0 13
103167: PUSH
103168: LD_VAR 0 32
103172: IN
103173: PUSH
103174: LD_VAR 0 13
103178: PPUSH
103179: LD_VAR 0 22
103183: PPUSH
103184: CALL_OW 308
103188: AND
103189: IFFALSE 103206
// ComExitVehicle ( group [ i ] ) ;
103191: LD_VAR 0 4
103195: PUSH
103196: LD_VAR 0 7
103200: ARRAY
103201: PPUSH
103202: CALL_OW 121
// end else
103206: GO 103385
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103208: LD_ADDR_VAR 0 13
103212: PUSH
103213: LD_VAR 0 4
103217: PPUSH
103218: LD_INT 95
103220: PUSH
103221: LD_VAR 0 22
103225: PUSH
103226: EMPTY
103227: LIST
103228: LIST
103229: PUSH
103230: LD_INT 58
103232: PUSH
103233: EMPTY
103234: LIST
103235: PUSH
103236: EMPTY
103237: LIST
103238: LIST
103239: PPUSH
103240: CALL_OW 72
103244: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
103245: LD_VAR 0 4
103249: PUSH
103250: LD_VAR 0 7
103254: ARRAY
103255: PPUSH
103256: CALL_OW 314
103260: NOT
103261: IFFALSE 103383
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
103263: LD_ADDR_VAR 0 10
103267: PUSH
103268: LD_VAR 0 13
103272: PPUSH
103273: LD_VAR 0 4
103277: PUSH
103278: LD_VAR 0 7
103282: ARRAY
103283: PPUSH
103284: CALL_OW 74
103288: ST_TO_ADDR
// if not x then
103289: LD_VAR 0 10
103293: NOT
103294: IFFALSE 103298
// continue ;
103296: GO 102730
// if GetLives ( x ) < 1000 then
103298: LD_VAR 0 10
103302: PPUSH
103303: CALL_OW 256
103307: PUSH
103308: LD_INT 1000
103310: LESS
103311: IFFALSE 103335
// ComRepairVehicle ( group [ i ] , x ) else
103313: LD_VAR 0 4
103317: PUSH
103318: LD_VAR 0 7
103322: ARRAY
103323: PPUSH
103324: LD_VAR 0 10
103328: PPUSH
103329: CALL_OW 129
103333: GO 103383
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
103335: LD_VAR 0 23
103339: PUSH
103340: LD_VAR 0 4
103344: PUSH
103345: LD_VAR 0 7
103349: ARRAY
103350: PPUSH
103351: CALL_OW 256
103355: PUSH
103356: LD_INT 1000
103358: LESS
103359: AND
103360: NOT
103361: IFFALSE 103383
// ComEnterUnit ( group [ i ] , x ) ;
103363: LD_VAR 0 4
103367: PUSH
103368: LD_VAR 0 7
103372: ARRAY
103373: PPUSH
103374: LD_VAR 0 10
103378: PPUSH
103379: CALL_OW 120
// end ; continue ;
103383: GO 102730
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
103385: LD_VAR 0 23
103389: PUSH
103390: LD_VAR 0 4
103394: PUSH
103395: LD_VAR 0 7
103399: ARRAY
103400: PPUSH
103401: CALL_OW 247
103405: PUSH
103406: LD_INT 1
103408: EQUAL
103409: AND
103410: IFFALSE 103888
// begin if group [ i ] in healers then
103412: LD_VAR 0 4
103416: PUSH
103417: LD_VAR 0 7
103421: ARRAY
103422: PUSH
103423: LD_VAR 0 31
103427: IN
103428: IFFALSE 103701
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
103430: LD_VAR 0 4
103434: PUSH
103435: LD_VAR 0 7
103439: ARRAY
103440: PPUSH
103441: LD_VAR 0 23
103445: PPUSH
103446: CALL_OW 308
103450: NOT
103451: PUSH
103452: LD_VAR 0 4
103456: PUSH
103457: LD_VAR 0 7
103461: ARRAY
103462: PPUSH
103463: CALL_OW 314
103467: NOT
103468: AND
103469: IFFALSE 103493
// ComMoveToArea ( group [ i ] , f_heal ) else
103471: LD_VAR 0 4
103475: PUSH
103476: LD_VAR 0 7
103480: ARRAY
103481: PPUSH
103482: LD_VAR 0 23
103486: PPUSH
103487: CALL_OW 113
103491: GO 103699
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103493: LD_VAR 0 4
103497: PUSH
103498: LD_VAR 0 7
103502: ARRAY
103503: PPUSH
103504: CALL 48870 0 1
103508: PPUSH
103509: CALL_OW 256
103513: PUSH
103514: LD_INT 1000
103516: EQUAL
103517: IFFALSE 103536
// ComStop ( group [ i ] ) else
103519: LD_VAR 0 4
103523: PUSH
103524: LD_VAR 0 7
103528: ARRAY
103529: PPUSH
103530: CALL_OW 141
103534: GO 103699
// if not HasTask ( group [ i ] ) and to_heal then
103536: LD_VAR 0 4
103540: PUSH
103541: LD_VAR 0 7
103545: ARRAY
103546: PPUSH
103547: CALL_OW 314
103551: NOT
103552: PUSH
103553: LD_VAR 0 30
103557: AND
103558: IFFALSE 103699
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103560: LD_ADDR_VAR 0 13
103564: PUSH
103565: LD_VAR 0 30
103569: PPUSH
103570: LD_INT 3
103572: PUSH
103573: LD_INT 54
103575: PUSH
103576: EMPTY
103577: LIST
103578: PUSH
103579: EMPTY
103580: LIST
103581: LIST
103582: PPUSH
103583: CALL_OW 72
103587: PPUSH
103588: LD_VAR 0 4
103592: PUSH
103593: LD_VAR 0 7
103597: ARRAY
103598: PPUSH
103599: CALL_OW 74
103603: ST_TO_ADDR
// if z then
103604: LD_VAR 0 13
103608: IFFALSE 103699
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103610: LD_INT 91
103612: PUSH
103613: LD_VAR 0 13
103617: PUSH
103618: LD_INT 10
103620: PUSH
103621: EMPTY
103622: LIST
103623: LIST
103624: LIST
103625: PUSH
103626: LD_INT 81
103628: PUSH
103629: LD_VAR 0 13
103633: PPUSH
103634: CALL_OW 255
103638: PUSH
103639: EMPTY
103640: LIST
103641: LIST
103642: PUSH
103643: EMPTY
103644: LIST
103645: LIST
103646: PPUSH
103647: CALL_OW 69
103651: PUSH
103652: LD_INT 0
103654: EQUAL
103655: IFFALSE 103679
// ComHeal ( group [ i ] , z ) else
103657: LD_VAR 0 4
103661: PUSH
103662: LD_VAR 0 7
103666: ARRAY
103667: PPUSH
103668: LD_VAR 0 13
103672: PPUSH
103673: CALL_OW 128
103677: GO 103699
// ComMoveToArea ( group [ i ] , f_heal ) ;
103679: LD_VAR 0 4
103683: PUSH
103684: LD_VAR 0 7
103688: ARRAY
103689: PPUSH
103690: LD_VAR 0 23
103694: PPUSH
103695: CALL_OW 113
// end ; continue ;
103699: GO 102730
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103701: LD_VAR 0 4
103705: PUSH
103706: LD_VAR 0 7
103710: ARRAY
103711: PPUSH
103712: CALL_OW 256
103716: PUSH
103717: LD_INT 700
103719: LESS
103720: PUSH
103721: LD_VAR 0 4
103725: PUSH
103726: LD_VAR 0 7
103730: ARRAY
103731: PUSH
103732: LD_VAR 0 30
103736: IN
103737: NOT
103738: AND
103739: IFFALSE 103763
// to_heal := to_heal union group [ i ] ;
103741: LD_ADDR_VAR 0 30
103745: PUSH
103746: LD_VAR 0 30
103750: PUSH
103751: LD_VAR 0 4
103755: PUSH
103756: LD_VAR 0 7
103760: ARRAY
103761: UNION
103762: ST_TO_ADDR
// if group [ i ] in to_heal then
103763: LD_VAR 0 4
103767: PUSH
103768: LD_VAR 0 7
103772: ARRAY
103773: PUSH
103774: LD_VAR 0 30
103778: IN
103779: IFFALSE 103888
// begin if GetLives ( group [ i ] ) = 1000 then
103781: LD_VAR 0 4
103785: PUSH
103786: LD_VAR 0 7
103790: ARRAY
103791: PPUSH
103792: CALL_OW 256
103796: PUSH
103797: LD_INT 1000
103799: EQUAL
103800: IFFALSE 103826
// to_heal := to_heal diff group [ i ] else
103802: LD_ADDR_VAR 0 30
103806: PUSH
103807: LD_VAR 0 30
103811: PUSH
103812: LD_VAR 0 4
103816: PUSH
103817: LD_VAR 0 7
103821: ARRAY
103822: DIFF
103823: ST_TO_ADDR
103824: GO 103888
// begin if not IsInArea ( group [ i ] , to_heal ) then
103826: LD_VAR 0 4
103830: PUSH
103831: LD_VAR 0 7
103835: ARRAY
103836: PPUSH
103837: LD_VAR 0 30
103841: PPUSH
103842: CALL_OW 308
103846: NOT
103847: IFFALSE 103871
// ComMoveToArea ( group [ i ] , f_heal ) else
103849: LD_VAR 0 4
103853: PUSH
103854: LD_VAR 0 7
103858: ARRAY
103859: PPUSH
103860: LD_VAR 0 23
103864: PPUSH
103865: CALL_OW 113
103869: GO 103886
// ComHold ( group [ i ] ) ;
103871: LD_VAR 0 4
103875: PUSH
103876: LD_VAR 0 7
103880: ARRAY
103881: PPUSH
103882: CALL_OW 140
// continue ;
103886: GO 102730
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103888: LD_VAR 0 4
103892: PUSH
103893: LD_VAR 0 7
103897: ARRAY
103898: PPUSH
103899: LD_INT 10
103901: PPUSH
103902: CALL 47290 0 2
103906: NOT
103907: PUSH
103908: LD_VAR 0 16
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PUSH
103919: EMPTY
103920: EQUAL
103921: NOT
103922: AND
103923: IFFALSE 104189
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103925: LD_VAR 0 4
103929: PUSH
103930: LD_VAR 0 7
103934: ARRAY
103935: PPUSH
103936: CALL_OW 262
103940: PUSH
103941: LD_INT 1
103943: PUSH
103944: LD_INT 2
103946: PUSH
103947: EMPTY
103948: LIST
103949: LIST
103950: IN
103951: IFFALSE 103992
// if GetFuel ( group [ i ] ) < 10 then
103953: LD_VAR 0 4
103957: PUSH
103958: LD_VAR 0 7
103962: ARRAY
103963: PPUSH
103964: CALL_OW 261
103968: PUSH
103969: LD_INT 10
103971: LESS
103972: IFFALSE 103992
// SetFuel ( group [ i ] , 12 ) ;
103974: LD_VAR 0 4
103978: PUSH
103979: LD_VAR 0 7
103983: ARRAY
103984: PPUSH
103985: LD_INT 12
103987: PPUSH
103988: CALL_OW 240
// if units_path [ i ] then
103992: LD_VAR 0 16
103996: PUSH
103997: LD_VAR 0 7
104001: ARRAY
104002: IFFALSE 104187
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104004: LD_VAR 0 4
104008: PUSH
104009: LD_VAR 0 7
104013: ARRAY
104014: PPUSH
104015: LD_VAR 0 16
104019: PUSH
104020: LD_VAR 0 7
104024: ARRAY
104025: PUSH
104026: LD_INT 1
104028: ARRAY
104029: PUSH
104030: LD_INT 1
104032: ARRAY
104033: PPUSH
104034: LD_VAR 0 16
104038: PUSH
104039: LD_VAR 0 7
104043: ARRAY
104044: PUSH
104045: LD_INT 1
104047: ARRAY
104048: PUSH
104049: LD_INT 2
104051: ARRAY
104052: PPUSH
104053: CALL_OW 297
104057: PUSH
104058: LD_INT 6
104060: GREATER
104061: IFFALSE 104136
// begin if not HasTask ( group [ i ] ) then
104063: LD_VAR 0 4
104067: PUSH
104068: LD_VAR 0 7
104072: ARRAY
104073: PPUSH
104074: CALL_OW 314
104078: NOT
104079: IFFALSE 104134
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104081: LD_VAR 0 4
104085: PUSH
104086: LD_VAR 0 7
104090: ARRAY
104091: PPUSH
104092: LD_VAR 0 16
104096: PUSH
104097: LD_VAR 0 7
104101: ARRAY
104102: PUSH
104103: LD_INT 1
104105: ARRAY
104106: PUSH
104107: LD_INT 1
104109: ARRAY
104110: PPUSH
104111: LD_VAR 0 16
104115: PUSH
104116: LD_VAR 0 7
104120: ARRAY
104121: PUSH
104122: LD_INT 1
104124: ARRAY
104125: PUSH
104126: LD_INT 2
104128: ARRAY
104129: PPUSH
104130: CALL_OW 114
// end else
104134: GO 104187
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104136: LD_ADDR_VAR 0 15
104140: PUSH
104141: LD_VAR 0 16
104145: PUSH
104146: LD_VAR 0 7
104150: ARRAY
104151: PPUSH
104152: LD_INT 1
104154: PPUSH
104155: CALL_OW 3
104159: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104160: LD_ADDR_VAR 0 16
104164: PUSH
104165: LD_VAR 0 16
104169: PPUSH
104170: LD_VAR 0 7
104174: PPUSH
104175: LD_VAR 0 15
104179: PPUSH
104180: CALL_OW 1
104184: ST_TO_ADDR
// continue ;
104185: GO 102730
// end ; end ; end else
104187: GO 106851
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104189: LD_ADDR_VAR 0 14
104193: PUSH
104194: LD_INT 81
104196: PUSH
104197: LD_VAR 0 4
104201: PUSH
104202: LD_VAR 0 7
104206: ARRAY
104207: PPUSH
104208: CALL_OW 255
104212: PUSH
104213: EMPTY
104214: LIST
104215: LIST
104216: PPUSH
104217: CALL_OW 69
104221: ST_TO_ADDR
// if not tmp then
104222: LD_VAR 0 14
104226: NOT
104227: IFFALSE 104231
// continue ;
104229: GO 102730
// if f_ignore_area then
104231: LD_VAR 0 17
104235: IFFALSE 104323
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104237: LD_ADDR_VAR 0 15
104241: PUSH
104242: LD_VAR 0 14
104246: PPUSH
104247: LD_INT 3
104249: PUSH
104250: LD_INT 92
104252: PUSH
104253: LD_VAR 0 17
104257: PUSH
104258: LD_INT 1
104260: ARRAY
104261: PUSH
104262: LD_VAR 0 17
104266: PUSH
104267: LD_INT 2
104269: ARRAY
104270: PUSH
104271: LD_VAR 0 17
104275: PUSH
104276: LD_INT 3
104278: ARRAY
104279: PUSH
104280: EMPTY
104281: LIST
104282: LIST
104283: LIST
104284: LIST
104285: PUSH
104286: EMPTY
104287: LIST
104288: LIST
104289: PPUSH
104290: CALL_OW 72
104294: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104295: LD_VAR 0 14
104299: PUSH
104300: LD_VAR 0 15
104304: DIFF
104305: IFFALSE 104323
// tmp := tmp diff tmp2 ;
104307: LD_ADDR_VAR 0 14
104311: PUSH
104312: LD_VAR 0 14
104316: PUSH
104317: LD_VAR 0 15
104321: DIFF
104322: ST_TO_ADDR
// end ; if not f_murder then
104323: LD_VAR 0 20
104327: NOT
104328: IFFALSE 104386
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
104330: LD_ADDR_VAR 0 15
104334: PUSH
104335: LD_VAR 0 14
104339: PPUSH
104340: LD_INT 3
104342: PUSH
104343: LD_INT 50
104345: PUSH
104346: EMPTY
104347: LIST
104348: PUSH
104349: EMPTY
104350: LIST
104351: LIST
104352: PPUSH
104353: CALL_OW 72
104357: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104358: LD_VAR 0 14
104362: PUSH
104363: LD_VAR 0 15
104367: DIFF
104368: IFFALSE 104386
// tmp := tmp diff tmp2 ;
104370: LD_ADDR_VAR 0 14
104374: PUSH
104375: LD_VAR 0 14
104379: PUSH
104380: LD_VAR 0 15
104384: DIFF
104385: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
104386: LD_ADDR_VAR 0 14
104390: PUSH
104391: LD_VAR 0 4
104395: PUSH
104396: LD_VAR 0 7
104400: ARRAY
104401: PPUSH
104402: LD_VAR 0 14
104406: PPUSH
104407: LD_INT 1
104409: PPUSH
104410: LD_INT 1
104412: PPUSH
104413: CALL 20225 0 4
104417: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
104418: LD_VAR 0 4
104422: PUSH
104423: LD_VAR 0 7
104427: ARRAY
104428: PPUSH
104429: CALL_OW 257
104433: PUSH
104434: LD_INT 1
104436: EQUAL
104437: IFFALSE 104885
// begin if WantPlant ( group [ i ] ) then
104439: LD_VAR 0 4
104443: PUSH
104444: LD_VAR 0 7
104448: ARRAY
104449: PPUSH
104450: CALL 19726 0 1
104454: IFFALSE 104458
// continue ;
104456: GO 102730
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104458: LD_VAR 0 18
104462: PUSH
104463: LD_VAR 0 4
104467: PUSH
104468: LD_VAR 0 7
104472: ARRAY
104473: PPUSH
104474: CALL_OW 310
104478: NOT
104479: AND
104480: PUSH
104481: LD_VAR 0 14
104485: PUSH
104486: LD_INT 1
104488: ARRAY
104489: PUSH
104490: LD_VAR 0 14
104494: PPUSH
104495: LD_INT 21
104497: PUSH
104498: LD_INT 2
104500: PUSH
104501: EMPTY
104502: LIST
104503: LIST
104504: PUSH
104505: LD_INT 58
104507: PUSH
104508: EMPTY
104509: LIST
104510: PUSH
104511: EMPTY
104512: LIST
104513: LIST
104514: PPUSH
104515: CALL_OW 72
104519: IN
104520: AND
104521: IFFALSE 104557
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104523: LD_VAR 0 4
104527: PUSH
104528: LD_VAR 0 7
104532: ARRAY
104533: PPUSH
104534: LD_VAR 0 14
104538: PUSH
104539: LD_INT 1
104541: ARRAY
104542: PPUSH
104543: CALL_OW 120
// attacking := true ;
104547: LD_ADDR_VAR 0 29
104551: PUSH
104552: LD_INT 1
104554: ST_TO_ADDR
// continue ;
104555: GO 102730
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104557: LD_VAR 0 26
104561: PUSH
104562: LD_VAR 0 4
104566: PUSH
104567: LD_VAR 0 7
104571: ARRAY
104572: PPUSH
104573: CALL_OW 257
104577: PUSH
104578: LD_INT 1
104580: EQUAL
104581: AND
104582: PUSH
104583: LD_VAR 0 4
104587: PUSH
104588: LD_VAR 0 7
104592: ARRAY
104593: PPUSH
104594: CALL_OW 256
104598: PUSH
104599: LD_INT 800
104601: LESS
104602: AND
104603: PUSH
104604: LD_VAR 0 4
104608: PUSH
104609: LD_VAR 0 7
104613: ARRAY
104614: PPUSH
104615: CALL_OW 318
104619: NOT
104620: AND
104621: IFFALSE 104638
// ComCrawl ( group [ i ] ) ;
104623: LD_VAR 0 4
104627: PUSH
104628: LD_VAR 0 7
104632: ARRAY
104633: PPUSH
104634: CALL_OW 137
// if f_mines then
104638: LD_VAR 0 21
104642: IFFALSE 104885
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104644: LD_VAR 0 14
104648: PUSH
104649: LD_INT 1
104651: ARRAY
104652: PPUSH
104653: CALL_OW 247
104657: PUSH
104658: LD_INT 3
104660: EQUAL
104661: PUSH
104662: LD_VAR 0 14
104666: PUSH
104667: LD_INT 1
104669: ARRAY
104670: PUSH
104671: LD_VAR 0 27
104675: IN
104676: NOT
104677: AND
104678: IFFALSE 104885
// begin x := GetX ( tmp [ 1 ] ) ;
104680: LD_ADDR_VAR 0 10
104684: PUSH
104685: LD_VAR 0 14
104689: PUSH
104690: LD_INT 1
104692: ARRAY
104693: PPUSH
104694: CALL_OW 250
104698: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104699: LD_ADDR_VAR 0 11
104703: PUSH
104704: LD_VAR 0 14
104708: PUSH
104709: LD_INT 1
104711: ARRAY
104712: PPUSH
104713: CALL_OW 251
104717: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104718: LD_ADDR_VAR 0 12
104722: PUSH
104723: LD_VAR 0 4
104727: PUSH
104728: LD_VAR 0 7
104732: ARRAY
104733: PPUSH
104734: CALL 47375 0 1
104738: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104739: LD_VAR 0 4
104743: PUSH
104744: LD_VAR 0 7
104748: ARRAY
104749: PPUSH
104750: LD_VAR 0 10
104754: PPUSH
104755: LD_VAR 0 11
104759: PPUSH
104760: LD_VAR 0 14
104764: PUSH
104765: LD_INT 1
104767: ARRAY
104768: PPUSH
104769: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104773: LD_VAR 0 4
104777: PUSH
104778: LD_VAR 0 7
104782: ARRAY
104783: PPUSH
104784: LD_VAR 0 10
104788: PPUSH
104789: LD_VAR 0 12
104793: PPUSH
104794: LD_INT 7
104796: PPUSH
104797: CALL_OW 272
104801: PPUSH
104802: LD_VAR 0 11
104806: PPUSH
104807: LD_VAR 0 12
104811: PPUSH
104812: LD_INT 7
104814: PPUSH
104815: CALL_OW 273
104819: PPUSH
104820: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104824: LD_VAR 0 4
104828: PUSH
104829: LD_VAR 0 7
104833: ARRAY
104834: PPUSH
104835: LD_INT 71
104837: PPUSH
104838: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104842: LD_ADDR_VAR 0 27
104846: PUSH
104847: LD_VAR 0 27
104851: PPUSH
104852: LD_VAR 0 27
104856: PUSH
104857: LD_INT 1
104859: PLUS
104860: PPUSH
104861: LD_VAR 0 14
104865: PUSH
104866: LD_INT 1
104868: ARRAY
104869: PPUSH
104870: CALL_OW 1
104874: ST_TO_ADDR
// attacking := true ;
104875: LD_ADDR_VAR 0 29
104879: PUSH
104880: LD_INT 1
104882: ST_TO_ADDR
// continue ;
104883: GO 102730
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104885: LD_VAR 0 4
104889: PUSH
104890: LD_VAR 0 7
104894: ARRAY
104895: PPUSH
104896: CALL_OW 257
104900: PUSH
104901: LD_INT 17
104903: EQUAL
104904: PUSH
104905: LD_VAR 0 4
104909: PUSH
104910: LD_VAR 0 7
104914: ARRAY
104915: PPUSH
104916: CALL_OW 110
104920: PUSH
104921: LD_INT 71
104923: EQUAL
104924: NOT
104925: AND
104926: IFFALSE 105072
// begin attacking := false ;
104928: LD_ADDR_VAR 0 29
104932: PUSH
104933: LD_INT 0
104935: ST_TO_ADDR
// k := 5 ;
104936: LD_ADDR_VAR 0 9
104940: PUSH
104941: LD_INT 5
104943: ST_TO_ADDR
// if tmp < k then
104944: LD_VAR 0 14
104948: PUSH
104949: LD_VAR 0 9
104953: LESS
104954: IFFALSE 104966
// k := tmp ;
104956: LD_ADDR_VAR 0 9
104960: PUSH
104961: LD_VAR 0 14
104965: ST_TO_ADDR
// for j = 1 to k do
104966: LD_ADDR_VAR 0 8
104970: PUSH
104971: DOUBLE
104972: LD_INT 1
104974: DEC
104975: ST_TO_ADDR
104976: LD_VAR 0 9
104980: PUSH
104981: FOR_TO
104982: IFFALSE 105070
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
104984: LD_VAR 0 14
104988: PUSH
104989: LD_VAR 0 8
104993: ARRAY
104994: PUSH
104995: LD_VAR 0 14
104999: PPUSH
105000: LD_INT 58
105002: PUSH
105003: EMPTY
105004: LIST
105005: PPUSH
105006: CALL_OW 72
105010: IN
105011: NOT
105012: IFFALSE 105068
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105014: LD_VAR 0 4
105018: PUSH
105019: LD_VAR 0 7
105023: ARRAY
105024: PPUSH
105025: LD_VAR 0 14
105029: PUSH
105030: LD_VAR 0 8
105034: ARRAY
105035: PPUSH
105036: CALL_OW 115
// attacking := true ;
105040: LD_ADDR_VAR 0 29
105044: PUSH
105045: LD_INT 1
105047: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105048: LD_VAR 0 4
105052: PUSH
105053: LD_VAR 0 7
105057: ARRAY
105058: PPUSH
105059: LD_INT 71
105061: PPUSH
105062: CALL_OW 109
// continue ;
105066: GO 104981
// end ; end ;
105068: GO 104981
105070: POP
105071: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105072: LD_VAR 0 4
105076: PUSH
105077: LD_VAR 0 7
105081: ARRAY
105082: PPUSH
105083: CALL_OW 257
105087: PUSH
105088: LD_INT 8
105090: EQUAL
105091: PUSH
105092: LD_VAR 0 4
105096: PUSH
105097: LD_VAR 0 7
105101: ARRAY
105102: PPUSH
105103: CALL_OW 264
105107: PUSH
105108: LD_INT 28
105110: PUSH
105111: LD_INT 45
105113: PUSH
105114: LD_INT 7
105116: PUSH
105117: LD_INT 47
105119: PUSH
105120: EMPTY
105121: LIST
105122: LIST
105123: LIST
105124: LIST
105125: IN
105126: OR
105127: IFFALSE 105383
// begin attacking := false ;
105129: LD_ADDR_VAR 0 29
105133: PUSH
105134: LD_INT 0
105136: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105137: LD_VAR 0 14
105141: PUSH
105142: LD_INT 1
105144: ARRAY
105145: PPUSH
105146: CALL_OW 266
105150: PUSH
105151: LD_INT 32
105153: PUSH
105154: LD_INT 31
105156: PUSH
105157: LD_INT 33
105159: PUSH
105160: LD_INT 4
105162: PUSH
105163: LD_INT 5
105165: PUSH
105166: EMPTY
105167: LIST
105168: LIST
105169: LIST
105170: LIST
105171: LIST
105172: IN
105173: IFFALSE 105359
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105175: LD_ADDR_VAR 0 9
105179: PUSH
105180: LD_VAR 0 14
105184: PUSH
105185: LD_INT 1
105187: ARRAY
105188: PPUSH
105189: CALL_OW 266
105193: PPUSH
105194: LD_VAR 0 14
105198: PUSH
105199: LD_INT 1
105201: ARRAY
105202: PPUSH
105203: CALL_OW 250
105207: PPUSH
105208: LD_VAR 0 14
105212: PUSH
105213: LD_INT 1
105215: ARRAY
105216: PPUSH
105217: CALL_OW 251
105221: PPUSH
105222: LD_VAR 0 14
105226: PUSH
105227: LD_INT 1
105229: ARRAY
105230: PPUSH
105231: CALL_OW 254
105235: PPUSH
105236: LD_VAR 0 14
105240: PUSH
105241: LD_INT 1
105243: ARRAY
105244: PPUSH
105245: CALL_OW 248
105249: PPUSH
105250: LD_INT 0
105252: PPUSH
105253: CALL 28745 0 6
105257: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
105258: LD_ADDR_VAR 0 8
105262: PUSH
105263: LD_VAR 0 4
105267: PUSH
105268: LD_VAR 0 7
105272: ARRAY
105273: PPUSH
105274: LD_VAR 0 9
105278: PPUSH
105279: CALL 47415 0 2
105283: ST_TO_ADDR
// if j then
105284: LD_VAR 0 8
105288: IFFALSE 105357
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
105290: LD_VAR 0 8
105294: PUSH
105295: LD_INT 1
105297: ARRAY
105298: PPUSH
105299: LD_VAR 0 8
105303: PUSH
105304: LD_INT 2
105306: ARRAY
105307: PPUSH
105308: CALL_OW 488
105312: IFFALSE 105357
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
105314: LD_VAR 0 4
105318: PUSH
105319: LD_VAR 0 7
105323: ARRAY
105324: PPUSH
105325: LD_VAR 0 8
105329: PUSH
105330: LD_INT 1
105332: ARRAY
105333: PPUSH
105334: LD_VAR 0 8
105338: PUSH
105339: LD_INT 2
105341: ARRAY
105342: PPUSH
105343: CALL_OW 116
// attacking := true ;
105347: LD_ADDR_VAR 0 29
105351: PUSH
105352: LD_INT 1
105354: ST_TO_ADDR
// continue ;
105355: GO 102730
// end ; end else
105357: GO 105383
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105359: LD_VAR 0 4
105363: PUSH
105364: LD_VAR 0 7
105368: ARRAY
105369: PPUSH
105370: LD_VAR 0 14
105374: PUSH
105375: LD_INT 1
105377: ARRAY
105378: PPUSH
105379: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
105383: LD_VAR 0 4
105387: PUSH
105388: LD_VAR 0 7
105392: ARRAY
105393: PPUSH
105394: CALL_OW 265
105398: PUSH
105399: LD_INT 11
105401: EQUAL
105402: IFFALSE 105680
// begin k := 10 ;
105404: LD_ADDR_VAR 0 9
105408: PUSH
105409: LD_INT 10
105411: ST_TO_ADDR
// x := 0 ;
105412: LD_ADDR_VAR 0 10
105416: PUSH
105417: LD_INT 0
105419: ST_TO_ADDR
// if tmp < k then
105420: LD_VAR 0 14
105424: PUSH
105425: LD_VAR 0 9
105429: LESS
105430: IFFALSE 105442
// k := tmp ;
105432: LD_ADDR_VAR 0 9
105436: PUSH
105437: LD_VAR 0 14
105441: ST_TO_ADDR
// for j = k downto 1 do
105442: LD_ADDR_VAR 0 8
105446: PUSH
105447: DOUBLE
105448: LD_VAR 0 9
105452: INC
105453: ST_TO_ADDR
105454: LD_INT 1
105456: PUSH
105457: FOR_DOWNTO
105458: IFFALSE 105533
// begin if GetType ( tmp [ j ] ) = unit_human then
105460: LD_VAR 0 14
105464: PUSH
105465: LD_VAR 0 8
105469: ARRAY
105470: PPUSH
105471: CALL_OW 247
105475: PUSH
105476: LD_INT 1
105478: EQUAL
105479: IFFALSE 105531
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105481: LD_VAR 0 4
105485: PUSH
105486: LD_VAR 0 7
105490: ARRAY
105491: PPUSH
105492: LD_VAR 0 14
105496: PUSH
105497: LD_VAR 0 8
105501: ARRAY
105502: PPUSH
105503: CALL 47686 0 2
// x := tmp [ j ] ;
105507: LD_ADDR_VAR 0 10
105511: PUSH
105512: LD_VAR 0 14
105516: PUSH
105517: LD_VAR 0 8
105521: ARRAY
105522: ST_TO_ADDR
// attacking := true ;
105523: LD_ADDR_VAR 0 29
105527: PUSH
105528: LD_INT 1
105530: ST_TO_ADDR
// end ; end ;
105531: GO 105457
105533: POP
105534: POP
// if not x then
105535: LD_VAR 0 10
105539: NOT
105540: IFFALSE 105680
// begin attacking := true ;
105542: LD_ADDR_VAR 0 29
105546: PUSH
105547: LD_INT 1
105549: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105550: LD_VAR 0 4
105554: PUSH
105555: LD_VAR 0 7
105559: ARRAY
105560: PPUSH
105561: CALL_OW 250
105565: PPUSH
105566: LD_VAR 0 4
105570: PUSH
105571: LD_VAR 0 7
105575: ARRAY
105576: PPUSH
105577: CALL_OW 251
105581: PPUSH
105582: CALL_OW 546
105586: PUSH
105587: LD_INT 2
105589: ARRAY
105590: PUSH
105591: LD_VAR 0 14
105595: PUSH
105596: LD_INT 1
105598: ARRAY
105599: PPUSH
105600: CALL_OW 250
105604: PPUSH
105605: LD_VAR 0 14
105609: PUSH
105610: LD_INT 1
105612: ARRAY
105613: PPUSH
105614: CALL_OW 251
105618: PPUSH
105619: CALL_OW 546
105623: PUSH
105624: LD_INT 2
105626: ARRAY
105627: EQUAL
105628: IFFALSE 105656
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105630: LD_VAR 0 4
105634: PUSH
105635: LD_VAR 0 7
105639: ARRAY
105640: PPUSH
105641: LD_VAR 0 14
105645: PUSH
105646: LD_INT 1
105648: ARRAY
105649: PPUSH
105650: CALL 47686 0 2
105654: GO 105680
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105656: LD_VAR 0 4
105660: PUSH
105661: LD_VAR 0 7
105665: ARRAY
105666: PPUSH
105667: LD_VAR 0 14
105671: PUSH
105672: LD_INT 1
105674: ARRAY
105675: PPUSH
105676: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105680: LD_VAR 0 4
105684: PUSH
105685: LD_VAR 0 7
105689: ARRAY
105690: PPUSH
105691: CALL_OW 264
105695: PUSH
105696: LD_INT 29
105698: EQUAL
105699: IFFALSE 106065
// begin if WantsToAttack ( group [ i ] ) in bombed then
105701: LD_VAR 0 4
105705: PUSH
105706: LD_VAR 0 7
105710: ARRAY
105711: PPUSH
105712: CALL_OW 319
105716: PUSH
105717: LD_VAR 0 28
105721: IN
105722: IFFALSE 105726
// continue ;
105724: GO 102730
// k := 8 ;
105726: LD_ADDR_VAR 0 9
105730: PUSH
105731: LD_INT 8
105733: ST_TO_ADDR
// x := 0 ;
105734: LD_ADDR_VAR 0 10
105738: PUSH
105739: LD_INT 0
105741: ST_TO_ADDR
// if tmp < k then
105742: LD_VAR 0 14
105746: PUSH
105747: LD_VAR 0 9
105751: LESS
105752: IFFALSE 105764
// k := tmp ;
105754: LD_ADDR_VAR 0 9
105758: PUSH
105759: LD_VAR 0 14
105763: ST_TO_ADDR
// for j = 1 to k do
105764: LD_ADDR_VAR 0 8
105768: PUSH
105769: DOUBLE
105770: LD_INT 1
105772: DEC
105773: ST_TO_ADDR
105774: LD_VAR 0 9
105778: PUSH
105779: FOR_TO
105780: IFFALSE 105912
// begin if GetType ( tmp [ j ] ) = unit_building then
105782: LD_VAR 0 14
105786: PUSH
105787: LD_VAR 0 8
105791: ARRAY
105792: PPUSH
105793: CALL_OW 247
105797: PUSH
105798: LD_INT 3
105800: EQUAL
105801: IFFALSE 105910
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105803: LD_VAR 0 14
105807: PUSH
105808: LD_VAR 0 8
105812: ARRAY
105813: PUSH
105814: LD_VAR 0 28
105818: IN
105819: NOT
105820: PUSH
105821: LD_VAR 0 14
105825: PUSH
105826: LD_VAR 0 8
105830: ARRAY
105831: PPUSH
105832: CALL_OW 313
105836: AND
105837: IFFALSE 105910
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105839: LD_VAR 0 4
105843: PUSH
105844: LD_VAR 0 7
105848: ARRAY
105849: PPUSH
105850: LD_VAR 0 14
105854: PUSH
105855: LD_VAR 0 8
105859: ARRAY
105860: PPUSH
105861: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105865: LD_ADDR_VAR 0 28
105869: PUSH
105870: LD_VAR 0 28
105874: PPUSH
105875: LD_VAR 0 28
105879: PUSH
105880: LD_INT 1
105882: PLUS
105883: PPUSH
105884: LD_VAR 0 14
105888: PUSH
105889: LD_VAR 0 8
105893: ARRAY
105894: PPUSH
105895: CALL_OW 1
105899: ST_TO_ADDR
// attacking := true ;
105900: LD_ADDR_VAR 0 29
105904: PUSH
105905: LD_INT 1
105907: ST_TO_ADDR
// break ;
105908: GO 105912
// end ; end ;
105910: GO 105779
105912: POP
105913: POP
// if not attacking and f_attack_depot then
105914: LD_VAR 0 29
105918: NOT
105919: PUSH
105920: LD_VAR 0 25
105924: AND
105925: IFFALSE 106020
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105927: LD_ADDR_VAR 0 13
105931: PUSH
105932: LD_VAR 0 14
105936: PPUSH
105937: LD_INT 2
105939: PUSH
105940: LD_INT 30
105942: PUSH
105943: LD_INT 0
105945: PUSH
105946: EMPTY
105947: LIST
105948: LIST
105949: PUSH
105950: LD_INT 30
105952: PUSH
105953: LD_INT 1
105955: PUSH
105956: EMPTY
105957: LIST
105958: LIST
105959: PUSH
105960: EMPTY
105961: LIST
105962: LIST
105963: LIST
105964: PPUSH
105965: CALL_OW 72
105969: ST_TO_ADDR
// if z then
105970: LD_VAR 0 13
105974: IFFALSE 106020
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
105976: LD_VAR 0 4
105980: PUSH
105981: LD_VAR 0 7
105985: ARRAY
105986: PPUSH
105987: LD_VAR 0 13
105991: PPUSH
105992: LD_VAR 0 4
105996: PUSH
105997: LD_VAR 0 7
106001: ARRAY
106002: PPUSH
106003: CALL_OW 74
106007: PPUSH
106008: CALL_OW 115
// attacking := true ;
106012: LD_ADDR_VAR 0 29
106016: PUSH
106017: LD_INT 1
106019: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106020: LD_VAR 0 4
106024: PUSH
106025: LD_VAR 0 7
106029: ARRAY
106030: PPUSH
106031: CALL_OW 256
106035: PUSH
106036: LD_INT 500
106038: LESS
106039: IFFALSE 106065
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106041: LD_VAR 0 4
106045: PUSH
106046: LD_VAR 0 7
106050: ARRAY
106051: PPUSH
106052: LD_VAR 0 14
106056: PUSH
106057: LD_INT 1
106059: ARRAY
106060: PPUSH
106061: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106065: LD_VAR 0 4
106069: PUSH
106070: LD_VAR 0 7
106074: ARRAY
106075: PPUSH
106076: CALL_OW 264
106080: PUSH
106081: LD_INT 49
106083: EQUAL
106084: IFFALSE 106205
// begin if not HasTask ( group [ i ] ) then
106086: LD_VAR 0 4
106090: PUSH
106091: LD_VAR 0 7
106095: ARRAY
106096: PPUSH
106097: CALL_OW 314
106101: NOT
106102: IFFALSE 106205
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106104: LD_ADDR_VAR 0 9
106108: PUSH
106109: LD_INT 81
106111: PUSH
106112: LD_VAR 0 4
106116: PUSH
106117: LD_VAR 0 7
106121: ARRAY
106122: PPUSH
106123: CALL_OW 255
106127: PUSH
106128: EMPTY
106129: LIST
106130: LIST
106131: PPUSH
106132: CALL_OW 69
106136: PPUSH
106137: LD_VAR 0 4
106141: PUSH
106142: LD_VAR 0 7
106146: ARRAY
106147: PPUSH
106148: CALL_OW 74
106152: ST_TO_ADDR
// if k then
106153: LD_VAR 0 9
106157: IFFALSE 106205
// if GetDistUnits ( group [ i ] , k ) > 10 then
106159: LD_VAR 0 4
106163: PUSH
106164: LD_VAR 0 7
106168: ARRAY
106169: PPUSH
106170: LD_VAR 0 9
106174: PPUSH
106175: CALL_OW 296
106179: PUSH
106180: LD_INT 10
106182: GREATER
106183: IFFALSE 106205
// ComMoveUnit ( group [ i ] , k ) ;
106185: LD_VAR 0 4
106189: PUSH
106190: LD_VAR 0 7
106194: ARRAY
106195: PPUSH
106196: LD_VAR 0 9
106200: PPUSH
106201: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106205: LD_VAR 0 4
106209: PUSH
106210: LD_VAR 0 7
106214: ARRAY
106215: PPUSH
106216: CALL_OW 256
106220: PUSH
106221: LD_INT 250
106223: LESS
106224: PUSH
106225: LD_VAR 0 4
106229: PUSH
106230: LD_VAR 0 7
106234: ARRAY
106235: PUSH
106236: LD_INT 21
106238: PUSH
106239: LD_INT 2
106241: PUSH
106242: EMPTY
106243: LIST
106244: LIST
106245: PUSH
106246: LD_INT 23
106248: PUSH
106249: LD_INT 2
106251: PUSH
106252: EMPTY
106253: LIST
106254: LIST
106255: PUSH
106256: EMPTY
106257: LIST
106258: LIST
106259: PPUSH
106260: CALL_OW 69
106264: IN
106265: AND
106266: IFFALSE 106391
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
106268: LD_ADDR_VAR 0 9
106272: PUSH
106273: LD_OWVAR 3
106277: PUSH
106278: LD_VAR 0 4
106282: PUSH
106283: LD_VAR 0 7
106287: ARRAY
106288: DIFF
106289: PPUSH
106290: LD_VAR 0 4
106294: PUSH
106295: LD_VAR 0 7
106299: ARRAY
106300: PPUSH
106301: CALL_OW 74
106305: ST_TO_ADDR
// if not k then
106306: LD_VAR 0 9
106310: NOT
106311: IFFALSE 106315
// continue ;
106313: GO 102730
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
106315: LD_VAR 0 9
106319: PUSH
106320: LD_INT 81
106322: PUSH
106323: LD_VAR 0 4
106327: PUSH
106328: LD_VAR 0 7
106332: ARRAY
106333: PPUSH
106334: CALL_OW 255
106338: PUSH
106339: EMPTY
106340: LIST
106341: LIST
106342: PPUSH
106343: CALL_OW 69
106347: IN
106348: PUSH
106349: LD_VAR 0 9
106353: PPUSH
106354: LD_VAR 0 4
106358: PUSH
106359: LD_VAR 0 7
106363: ARRAY
106364: PPUSH
106365: CALL_OW 296
106369: PUSH
106370: LD_INT 5
106372: LESS
106373: AND
106374: IFFALSE 106391
// ComAutodestruct ( group [ i ] ) ;
106376: LD_VAR 0 4
106380: PUSH
106381: LD_VAR 0 7
106385: ARRAY
106386: PPUSH
106387: CALL 47584 0 1
// end ; if f_attack_depot then
106391: LD_VAR 0 25
106395: IFFALSE 106507
// begin k := 6 ;
106397: LD_ADDR_VAR 0 9
106401: PUSH
106402: LD_INT 6
106404: ST_TO_ADDR
// if tmp < k then
106405: LD_VAR 0 14
106409: PUSH
106410: LD_VAR 0 9
106414: LESS
106415: IFFALSE 106427
// k := tmp ;
106417: LD_ADDR_VAR 0 9
106421: PUSH
106422: LD_VAR 0 14
106426: ST_TO_ADDR
// for j = 1 to k do
106427: LD_ADDR_VAR 0 8
106431: PUSH
106432: DOUBLE
106433: LD_INT 1
106435: DEC
106436: ST_TO_ADDR
106437: LD_VAR 0 9
106441: PUSH
106442: FOR_TO
106443: IFFALSE 106505
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
106445: LD_VAR 0 8
106449: PPUSH
106450: CALL_OW 266
106454: PUSH
106455: LD_INT 0
106457: PUSH
106458: LD_INT 1
106460: PUSH
106461: EMPTY
106462: LIST
106463: LIST
106464: IN
106465: IFFALSE 106503
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106467: LD_VAR 0 4
106471: PUSH
106472: LD_VAR 0 7
106476: ARRAY
106477: PPUSH
106478: LD_VAR 0 14
106482: PUSH
106483: LD_VAR 0 8
106487: ARRAY
106488: PPUSH
106489: CALL_OW 115
// attacking := true ;
106493: LD_ADDR_VAR 0 29
106497: PUSH
106498: LD_INT 1
106500: ST_TO_ADDR
// break ;
106501: GO 106505
// end ;
106503: GO 106442
106505: POP
106506: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106507: LD_VAR 0 4
106511: PUSH
106512: LD_VAR 0 7
106516: ARRAY
106517: PPUSH
106518: CALL_OW 302
106522: PUSH
106523: LD_VAR 0 29
106527: NOT
106528: AND
106529: IFFALSE 106851
// begin if GetTag ( group [ i ] ) = 71 then
106531: LD_VAR 0 4
106535: PUSH
106536: LD_VAR 0 7
106540: ARRAY
106541: PPUSH
106542: CALL_OW 110
106546: PUSH
106547: LD_INT 71
106549: EQUAL
106550: IFFALSE 106591
// begin if HasTask ( group [ i ] ) then
106552: LD_VAR 0 4
106556: PUSH
106557: LD_VAR 0 7
106561: ARRAY
106562: PPUSH
106563: CALL_OW 314
106567: IFFALSE 106573
// continue else
106569: GO 102730
106571: GO 106591
// SetTag ( group [ i ] , 0 ) ;
106573: LD_VAR 0 4
106577: PUSH
106578: LD_VAR 0 7
106582: ARRAY
106583: PPUSH
106584: LD_INT 0
106586: PPUSH
106587: CALL_OW 109
// end ; k := 8 ;
106591: LD_ADDR_VAR 0 9
106595: PUSH
106596: LD_INT 8
106598: ST_TO_ADDR
// x := 0 ;
106599: LD_ADDR_VAR 0 10
106603: PUSH
106604: LD_INT 0
106606: ST_TO_ADDR
// if tmp < k then
106607: LD_VAR 0 14
106611: PUSH
106612: LD_VAR 0 9
106616: LESS
106617: IFFALSE 106629
// k := tmp ;
106619: LD_ADDR_VAR 0 9
106623: PUSH
106624: LD_VAR 0 14
106628: ST_TO_ADDR
// for j = 1 to k do
106629: LD_ADDR_VAR 0 8
106633: PUSH
106634: DOUBLE
106635: LD_INT 1
106637: DEC
106638: ST_TO_ADDR
106639: LD_VAR 0 9
106643: PUSH
106644: FOR_TO
106645: IFFALSE 106743
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106647: LD_VAR 0 14
106651: PUSH
106652: LD_VAR 0 8
106656: ARRAY
106657: PPUSH
106658: CALL_OW 247
106662: PUSH
106663: LD_INT 1
106665: EQUAL
106666: PUSH
106667: LD_VAR 0 14
106671: PUSH
106672: LD_VAR 0 8
106676: ARRAY
106677: PPUSH
106678: CALL_OW 256
106682: PUSH
106683: LD_INT 250
106685: LESS
106686: PUSH
106687: LD_VAR 0 20
106691: AND
106692: PUSH
106693: LD_VAR 0 20
106697: NOT
106698: PUSH
106699: LD_VAR 0 14
106703: PUSH
106704: LD_VAR 0 8
106708: ARRAY
106709: PPUSH
106710: CALL_OW 256
106714: PUSH
106715: LD_INT 250
106717: GREATEREQUAL
106718: AND
106719: OR
106720: AND
106721: IFFALSE 106741
// begin x := tmp [ j ] ;
106723: LD_ADDR_VAR 0 10
106727: PUSH
106728: LD_VAR 0 14
106732: PUSH
106733: LD_VAR 0 8
106737: ARRAY
106738: ST_TO_ADDR
// break ;
106739: GO 106743
// end ;
106741: GO 106644
106743: POP
106744: POP
// if x then
106745: LD_VAR 0 10
106749: IFFALSE 106773
// ComAttackUnit ( group [ i ] , x ) else
106751: LD_VAR 0 4
106755: PUSH
106756: LD_VAR 0 7
106760: ARRAY
106761: PPUSH
106762: LD_VAR 0 10
106766: PPUSH
106767: CALL_OW 115
106771: GO 106797
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106773: LD_VAR 0 4
106777: PUSH
106778: LD_VAR 0 7
106782: ARRAY
106783: PPUSH
106784: LD_VAR 0 14
106788: PUSH
106789: LD_INT 1
106791: ARRAY
106792: PPUSH
106793: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106797: LD_VAR 0 4
106801: PUSH
106802: LD_VAR 0 7
106806: ARRAY
106807: PPUSH
106808: CALL_OW 314
106812: NOT
106813: IFFALSE 106851
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106815: LD_VAR 0 4
106819: PUSH
106820: LD_VAR 0 7
106824: ARRAY
106825: PPUSH
106826: LD_VAR 0 14
106830: PPUSH
106831: LD_VAR 0 4
106835: PUSH
106836: LD_VAR 0 7
106840: ARRAY
106841: PPUSH
106842: CALL_OW 74
106846: PPUSH
106847: CALL_OW 115
// end ; end ; end ;
106851: GO 102730
106853: POP
106854: POP
// wait ( 0 0$2 ) ;
106855: LD_INT 70
106857: PPUSH
106858: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106862: LD_VAR 0 4
106866: NOT
106867: PUSH
106868: LD_VAR 0 4
106872: PUSH
106873: EMPTY
106874: EQUAL
106875: OR
106876: PUSH
106877: LD_INT 81
106879: PUSH
106880: LD_VAR 0 35
106884: PUSH
106885: EMPTY
106886: LIST
106887: LIST
106888: PPUSH
106889: CALL_OW 69
106893: NOT
106894: OR
106895: IFFALSE 102715
// end ;
106897: LD_VAR 0 2
106901: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
106902: LD_INT 0
106904: PPUSH
106905: PPUSH
106906: PPUSH
106907: PPUSH
106908: PPUSH
// if not base or not mc_bases [ base ] or not solds then
106909: LD_VAR 0 1
106913: NOT
106914: PUSH
106915: LD_EXP 59
106919: PUSH
106920: LD_VAR 0 1
106924: ARRAY
106925: NOT
106926: OR
106927: PUSH
106928: LD_VAR 0 2
106932: NOT
106933: OR
106934: IFFALSE 106938
// exit ;
106936: GO 107467
// side := mc_sides [ base ] ;
106938: LD_ADDR_VAR 0 5
106942: PUSH
106943: LD_EXP 85
106947: PUSH
106948: LD_VAR 0 1
106952: ARRAY
106953: ST_TO_ADDR
// if not side then
106954: LD_VAR 0 5
106958: NOT
106959: IFFALSE 106963
// exit ;
106961: GO 107467
// for i in solds do
106963: LD_ADDR_VAR 0 6
106967: PUSH
106968: LD_VAR 0 2
106972: PUSH
106973: FOR_IN
106974: IFFALSE 107035
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
106976: LD_VAR 0 6
106980: PPUSH
106981: CALL_OW 310
106985: PPUSH
106986: CALL_OW 266
106990: PUSH
106991: LD_INT 32
106993: PUSH
106994: LD_INT 31
106996: PUSH
106997: EMPTY
106998: LIST
106999: LIST
107000: IN
107001: IFFALSE 107021
// solds := solds diff i else
107003: LD_ADDR_VAR 0 2
107007: PUSH
107008: LD_VAR 0 2
107012: PUSH
107013: LD_VAR 0 6
107017: DIFF
107018: ST_TO_ADDR
107019: GO 107033
// SetTag ( i , 18 ) ;
107021: LD_VAR 0 6
107025: PPUSH
107026: LD_INT 18
107028: PPUSH
107029: CALL_OW 109
107033: GO 106973
107035: POP
107036: POP
// if not solds then
107037: LD_VAR 0 2
107041: NOT
107042: IFFALSE 107046
// exit ;
107044: GO 107467
// repeat wait ( 0 0$2 ) ;
107046: LD_INT 70
107048: PPUSH
107049: CALL_OW 67
// enemy := mc_scan [ base ] ;
107053: LD_ADDR_VAR 0 4
107057: PUSH
107058: LD_EXP 82
107062: PUSH
107063: LD_VAR 0 1
107067: ARRAY
107068: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107069: LD_EXP 59
107073: PUSH
107074: LD_VAR 0 1
107078: ARRAY
107079: NOT
107080: PUSH
107081: LD_EXP 59
107085: PUSH
107086: LD_VAR 0 1
107090: ARRAY
107091: PUSH
107092: EMPTY
107093: EQUAL
107094: OR
107095: IFFALSE 107132
// begin for i in solds do
107097: LD_ADDR_VAR 0 6
107101: PUSH
107102: LD_VAR 0 2
107106: PUSH
107107: FOR_IN
107108: IFFALSE 107121
// ComStop ( i ) ;
107110: LD_VAR 0 6
107114: PPUSH
107115: CALL_OW 141
107119: GO 107107
107121: POP
107122: POP
// solds := [ ] ;
107123: LD_ADDR_VAR 0 2
107127: PUSH
107128: EMPTY
107129: ST_TO_ADDR
// exit ;
107130: GO 107467
// end ; for i in solds do
107132: LD_ADDR_VAR 0 6
107136: PUSH
107137: LD_VAR 0 2
107141: PUSH
107142: FOR_IN
107143: IFFALSE 107439
// begin if IsInUnit ( i ) then
107145: LD_VAR 0 6
107149: PPUSH
107150: CALL_OW 310
107154: IFFALSE 107165
// ComExitBuilding ( i ) ;
107156: LD_VAR 0 6
107160: PPUSH
107161: CALL_OW 122
// if GetLives ( i ) > 333 then
107165: LD_VAR 0 6
107169: PPUSH
107170: CALL_OW 256
107174: PUSH
107175: LD_INT 333
107177: GREATER
107178: IFFALSE 107206
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107180: LD_VAR 0 6
107184: PPUSH
107185: LD_VAR 0 4
107189: PPUSH
107190: LD_VAR 0 6
107194: PPUSH
107195: CALL_OW 74
107199: PPUSH
107200: CALL_OW 115
107204: GO 107437
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
107206: LD_VAR 0 6
107210: PPUSH
107211: LD_EXP 59
107215: PUSH
107216: LD_VAR 0 1
107220: ARRAY
107221: PPUSH
107222: LD_INT 2
107224: PUSH
107225: LD_INT 30
107227: PUSH
107228: LD_INT 0
107230: PUSH
107231: EMPTY
107232: LIST
107233: LIST
107234: PUSH
107235: LD_INT 30
107237: PUSH
107238: LD_INT 1
107240: PUSH
107241: EMPTY
107242: LIST
107243: LIST
107244: PUSH
107245: LD_INT 30
107247: PUSH
107248: LD_INT 6
107250: PUSH
107251: EMPTY
107252: LIST
107253: LIST
107254: PUSH
107255: EMPTY
107256: LIST
107257: LIST
107258: LIST
107259: LIST
107260: PPUSH
107261: CALL_OW 72
107265: PPUSH
107266: LD_VAR 0 6
107270: PPUSH
107271: CALL_OW 74
107275: PPUSH
107276: CALL_OW 296
107280: PUSH
107281: LD_INT 10
107283: GREATER
107284: IFFALSE 107437
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
107286: LD_ADDR_VAR 0 7
107290: PUSH
107291: LD_EXP 59
107295: PUSH
107296: LD_VAR 0 1
107300: ARRAY
107301: PPUSH
107302: LD_INT 2
107304: PUSH
107305: LD_INT 30
107307: PUSH
107308: LD_INT 0
107310: PUSH
107311: EMPTY
107312: LIST
107313: LIST
107314: PUSH
107315: LD_INT 30
107317: PUSH
107318: LD_INT 1
107320: PUSH
107321: EMPTY
107322: LIST
107323: LIST
107324: PUSH
107325: LD_INT 30
107327: PUSH
107328: LD_INT 6
107330: PUSH
107331: EMPTY
107332: LIST
107333: LIST
107334: PUSH
107335: EMPTY
107336: LIST
107337: LIST
107338: LIST
107339: LIST
107340: PPUSH
107341: CALL_OW 72
107345: PPUSH
107346: LD_VAR 0 6
107350: PPUSH
107351: CALL_OW 74
107355: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
107356: LD_VAR 0 6
107360: PPUSH
107361: LD_VAR 0 7
107365: PPUSH
107366: CALL_OW 250
107370: PPUSH
107371: LD_INT 3
107373: PPUSH
107374: LD_INT 5
107376: PPUSH
107377: CALL_OW 272
107381: PPUSH
107382: LD_VAR 0 7
107386: PPUSH
107387: CALL_OW 251
107391: PPUSH
107392: LD_INT 3
107394: PPUSH
107395: LD_INT 5
107397: PPUSH
107398: CALL_OW 273
107402: PPUSH
107403: CALL_OW 111
// SetTag ( i , 0 ) ;
107407: LD_VAR 0 6
107411: PPUSH
107412: LD_INT 0
107414: PPUSH
107415: CALL_OW 109
// solds := solds diff i ;
107419: LD_ADDR_VAR 0 2
107423: PUSH
107424: LD_VAR 0 2
107428: PUSH
107429: LD_VAR 0 6
107433: DIFF
107434: ST_TO_ADDR
// continue ;
107435: GO 107142
// end ; end ;
107437: GO 107142
107439: POP
107440: POP
// until not solds or not enemy ;
107441: LD_VAR 0 2
107445: NOT
107446: PUSH
107447: LD_VAR 0 4
107451: NOT
107452: OR
107453: IFFALSE 107046
// MC_Reset ( base , 18 ) ;
107455: LD_VAR 0 1
107459: PPUSH
107460: LD_INT 18
107462: PPUSH
107463: CALL 58513 0 2
// end ;
107467: LD_VAR 0 3
107471: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
107472: LD_INT 0
107474: PPUSH
107475: PPUSH
107476: PPUSH
107477: PPUSH
107478: PPUSH
107479: PPUSH
107480: PPUSH
107481: PPUSH
107482: PPUSH
107483: PPUSH
107484: PPUSH
107485: PPUSH
107486: PPUSH
107487: PPUSH
107488: PPUSH
107489: PPUSH
107490: PPUSH
107491: PPUSH
107492: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107493: LD_ADDR_VAR 0 12
107497: PUSH
107498: LD_EXP 59
107502: PUSH
107503: LD_VAR 0 1
107507: ARRAY
107508: PPUSH
107509: LD_INT 25
107511: PUSH
107512: LD_INT 3
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: PPUSH
107519: CALL_OW 72
107523: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107524: LD_EXP 99
107528: PUSH
107529: LD_VAR 0 1
107533: ARRAY
107534: IFFALSE 107558
// mechs := mechs diff mc_remote_driver [ base ] ;
107536: LD_ADDR_VAR 0 12
107540: PUSH
107541: LD_VAR 0 12
107545: PUSH
107546: LD_EXP 99
107550: PUSH
107551: LD_VAR 0 1
107555: ARRAY
107556: DIFF
107557: ST_TO_ADDR
// for i in mechs do
107558: LD_ADDR_VAR 0 4
107562: PUSH
107563: LD_VAR 0 12
107567: PUSH
107568: FOR_IN
107569: IFFALSE 107604
// if GetTag ( i ) > 0 then
107571: LD_VAR 0 4
107575: PPUSH
107576: CALL_OW 110
107580: PUSH
107581: LD_INT 0
107583: GREATER
107584: IFFALSE 107602
// mechs := mechs diff i ;
107586: LD_ADDR_VAR 0 12
107590: PUSH
107591: LD_VAR 0 12
107595: PUSH
107596: LD_VAR 0 4
107600: DIFF
107601: ST_TO_ADDR
107602: GO 107568
107604: POP
107605: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107606: LD_ADDR_VAR 0 8
107610: PUSH
107611: LD_EXP 59
107615: PUSH
107616: LD_VAR 0 1
107620: ARRAY
107621: PPUSH
107622: LD_INT 2
107624: PUSH
107625: LD_INT 25
107627: PUSH
107628: LD_INT 1
107630: PUSH
107631: EMPTY
107632: LIST
107633: LIST
107634: PUSH
107635: LD_INT 25
107637: PUSH
107638: LD_INT 5
107640: PUSH
107641: EMPTY
107642: LIST
107643: LIST
107644: PUSH
107645: LD_INT 25
107647: PUSH
107648: LD_INT 8
107650: PUSH
107651: EMPTY
107652: LIST
107653: LIST
107654: PUSH
107655: LD_INT 25
107657: PUSH
107658: LD_INT 9
107660: PUSH
107661: EMPTY
107662: LIST
107663: LIST
107664: PUSH
107665: EMPTY
107666: LIST
107667: LIST
107668: LIST
107669: LIST
107670: LIST
107671: PPUSH
107672: CALL_OW 72
107676: ST_TO_ADDR
// if not defenders and not solds then
107677: LD_VAR 0 2
107681: NOT
107682: PUSH
107683: LD_VAR 0 8
107687: NOT
107688: AND
107689: IFFALSE 107693
// exit ;
107691: GO 109463
// depot_under_attack := false ;
107693: LD_ADDR_VAR 0 16
107697: PUSH
107698: LD_INT 0
107700: ST_TO_ADDR
// sold_defenders := [ ] ;
107701: LD_ADDR_VAR 0 17
107705: PUSH
107706: EMPTY
107707: ST_TO_ADDR
// if mechs then
107708: LD_VAR 0 12
107712: IFFALSE 107865
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
107714: LD_ADDR_VAR 0 4
107718: PUSH
107719: LD_VAR 0 2
107723: PPUSH
107724: LD_INT 21
107726: PUSH
107727: LD_INT 2
107729: PUSH
107730: EMPTY
107731: LIST
107732: LIST
107733: PPUSH
107734: CALL_OW 72
107738: PUSH
107739: FOR_IN
107740: IFFALSE 107863
// begin if GetTag ( i ) <> 20 then
107742: LD_VAR 0 4
107746: PPUSH
107747: CALL_OW 110
107751: PUSH
107752: LD_INT 20
107754: NONEQUAL
107755: IFFALSE 107769
// SetTag ( i , 20 ) ;
107757: LD_VAR 0 4
107761: PPUSH
107762: LD_INT 20
107764: PPUSH
107765: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
107769: LD_VAR 0 4
107773: PPUSH
107774: CALL_OW 263
107778: PUSH
107779: LD_INT 1
107781: EQUAL
107782: PUSH
107783: LD_VAR 0 4
107787: PPUSH
107788: CALL_OW 311
107792: NOT
107793: AND
107794: IFFALSE 107861
// begin un := mechs [ 1 ] ;
107796: LD_ADDR_VAR 0 10
107800: PUSH
107801: LD_VAR 0 12
107805: PUSH
107806: LD_INT 1
107808: ARRAY
107809: ST_TO_ADDR
// ComExit ( un ) ;
107810: LD_VAR 0 10
107814: PPUSH
107815: CALL 51929 0 1
// AddComEnterUnit ( un , i ) ;
107819: LD_VAR 0 10
107823: PPUSH
107824: LD_VAR 0 4
107828: PPUSH
107829: CALL_OW 180
// SetTag ( un , 19 ) ;
107833: LD_VAR 0 10
107837: PPUSH
107838: LD_INT 19
107840: PPUSH
107841: CALL_OW 109
// mechs := mechs diff un ;
107845: LD_ADDR_VAR 0 12
107849: PUSH
107850: LD_VAR 0 12
107854: PUSH
107855: LD_VAR 0 10
107859: DIFF
107860: ST_TO_ADDR
// end ; end ;
107861: GO 107739
107863: POP
107864: POP
// if solds then
107865: LD_VAR 0 8
107869: IFFALSE 107928
// for i in solds do
107871: LD_ADDR_VAR 0 4
107875: PUSH
107876: LD_VAR 0 8
107880: PUSH
107881: FOR_IN
107882: IFFALSE 107926
// if not GetTag ( i ) then
107884: LD_VAR 0 4
107888: PPUSH
107889: CALL_OW 110
107893: NOT
107894: IFFALSE 107924
// begin defenders := defenders union i ;
107896: LD_ADDR_VAR 0 2
107900: PUSH
107901: LD_VAR 0 2
107905: PUSH
107906: LD_VAR 0 4
107910: UNION
107911: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107912: LD_VAR 0 4
107916: PPUSH
107917: LD_INT 18
107919: PPUSH
107920: CALL_OW 109
// end ;
107924: GO 107881
107926: POP
107927: POP
// repeat wait ( 0 0$2 ) ;
107928: LD_INT 70
107930: PPUSH
107931: CALL_OW 67
// enemy := mc_scan [ base ] ;
107935: LD_ADDR_VAR 0 21
107939: PUSH
107940: LD_EXP 82
107944: PUSH
107945: LD_VAR 0 1
107949: ARRAY
107950: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107951: LD_EXP 59
107955: PUSH
107956: LD_VAR 0 1
107960: ARRAY
107961: NOT
107962: PUSH
107963: LD_EXP 59
107967: PUSH
107968: LD_VAR 0 1
107972: ARRAY
107973: PUSH
107974: EMPTY
107975: EQUAL
107976: OR
107977: IFFALSE 108014
// begin for i in defenders do
107979: LD_ADDR_VAR 0 4
107983: PUSH
107984: LD_VAR 0 2
107988: PUSH
107989: FOR_IN
107990: IFFALSE 108003
// ComStop ( i ) ;
107992: LD_VAR 0 4
107996: PPUSH
107997: CALL_OW 141
108001: GO 107989
108003: POP
108004: POP
// defenders := [ ] ;
108005: LD_ADDR_VAR 0 2
108009: PUSH
108010: EMPTY
108011: ST_TO_ADDR
// exit ;
108012: GO 109463
// end ; for i in defenders do
108014: LD_ADDR_VAR 0 4
108018: PUSH
108019: LD_VAR 0 2
108023: PUSH
108024: FOR_IN
108025: IFFALSE 108923
// begin e := NearestUnitToUnit ( enemy , i ) ;
108027: LD_ADDR_VAR 0 13
108031: PUSH
108032: LD_VAR 0 21
108036: PPUSH
108037: LD_VAR 0 4
108041: PPUSH
108042: CALL_OW 74
108046: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108047: LD_ADDR_VAR 0 7
108051: PUSH
108052: LD_EXP 59
108056: PUSH
108057: LD_VAR 0 1
108061: ARRAY
108062: PPUSH
108063: LD_INT 2
108065: PUSH
108066: LD_INT 30
108068: PUSH
108069: LD_INT 0
108071: PUSH
108072: EMPTY
108073: LIST
108074: LIST
108075: PUSH
108076: LD_INT 30
108078: PUSH
108079: LD_INT 1
108081: PUSH
108082: EMPTY
108083: LIST
108084: LIST
108085: PUSH
108086: EMPTY
108087: LIST
108088: LIST
108089: LIST
108090: PPUSH
108091: CALL_OW 72
108095: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108096: LD_ADDR_VAR 0 16
108100: PUSH
108101: LD_VAR 0 7
108105: NOT
108106: PUSH
108107: LD_VAR 0 7
108111: PPUSH
108112: LD_INT 3
108114: PUSH
108115: LD_INT 24
108117: PUSH
108118: LD_INT 600
108120: PUSH
108121: EMPTY
108122: LIST
108123: LIST
108124: PUSH
108125: EMPTY
108126: LIST
108127: LIST
108128: PPUSH
108129: CALL_OW 72
108133: OR
108134: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108135: LD_VAR 0 4
108139: PPUSH
108140: CALL_OW 247
108144: PUSH
108145: LD_INT 2
108147: DOUBLE
108148: EQUAL
108149: IFTRUE 108153
108151: GO 108549
108153: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108154: LD_VAR 0 4
108158: PPUSH
108159: CALL_OW 256
108163: PUSH
108164: LD_INT 1000
108166: EQUAL
108167: PUSH
108168: LD_VAR 0 4
108172: PPUSH
108173: LD_VAR 0 13
108177: PPUSH
108178: CALL_OW 296
108182: PUSH
108183: LD_INT 40
108185: LESS
108186: PUSH
108187: LD_VAR 0 13
108191: PPUSH
108192: LD_EXP 84
108196: PUSH
108197: LD_VAR 0 1
108201: ARRAY
108202: PPUSH
108203: CALL_OW 308
108207: OR
108208: AND
108209: IFFALSE 108331
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108211: LD_VAR 0 4
108215: PPUSH
108216: CALL_OW 262
108220: PUSH
108221: LD_INT 1
108223: EQUAL
108224: PUSH
108225: LD_VAR 0 4
108229: PPUSH
108230: CALL_OW 261
108234: PUSH
108235: LD_INT 30
108237: LESS
108238: AND
108239: PUSH
108240: LD_VAR 0 7
108244: AND
108245: IFFALSE 108315
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
108247: LD_VAR 0 4
108251: PPUSH
108252: LD_VAR 0 7
108256: PPUSH
108257: LD_VAR 0 4
108261: PPUSH
108262: CALL_OW 74
108266: PPUSH
108267: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
108271: LD_VAR 0 4
108275: PPUSH
108276: LD_VAR 0 7
108280: PPUSH
108281: LD_VAR 0 4
108285: PPUSH
108286: CALL_OW 74
108290: PPUSH
108291: CALL_OW 296
108295: PUSH
108296: LD_INT 6
108298: LESS
108299: IFFALSE 108313
// SetFuel ( i , 100 ) ;
108301: LD_VAR 0 4
108305: PPUSH
108306: LD_INT 100
108308: PPUSH
108309: CALL_OW 240
// end else
108313: GO 108329
// ComAttackUnit ( i , e ) ;
108315: LD_VAR 0 4
108319: PPUSH
108320: LD_VAR 0 13
108324: PPUSH
108325: CALL_OW 115
// end else
108329: GO 108432
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
108331: LD_VAR 0 13
108335: PPUSH
108336: LD_EXP 84
108340: PUSH
108341: LD_VAR 0 1
108345: ARRAY
108346: PPUSH
108347: CALL_OW 308
108351: NOT
108352: PUSH
108353: LD_VAR 0 4
108357: PPUSH
108358: LD_VAR 0 13
108362: PPUSH
108363: CALL_OW 296
108367: PUSH
108368: LD_INT 40
108370: GREATEREQUAL
108371: AND
108372: PUSH
108373: LD_VAR 0 4
108377: PPUSH
108378: CALL_OW 256
108382: PUSH
108383: LD_INT 650
108385: LESSEQUAL
108386: OR
108387: PUSH
108388: LD_VAR 0 4
108392: PPUSH
108393: LD_EXP 83
108397: PUSH
108398: LD_VAR 0 1
108402: ARRAY
108403: PPUSH
108404: CALL_OW 308
108408: NOT
108409: AND
108410: IFFALSE 108432
// ComMoveToArea ( i , mc_parking [ base ] ) ;
108412: LD_VAR 0 4
108416: PPUSH
108417: LD_EXP 83
108421: PUSH
108422: LD_VAR 0 1
108426: ARRAY
108427: PPUSH
108428: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108432: LD_VAR 0 4
108436: PPUSH
108437: CALL_OW 256
108441: PUSH
108442: LD_INT 1000
108444: LESS
108445: PUSH
108446: LD_VAR 0 4
108450: PPUSH
108451: CALL_OW 263
108455: PUSH
108456: LD_INT 1
108458: EQUAL
108459: AND
108460: PUSH
108461: LD_VAR 0 4
108465: PPUSH
108466: CALL_OW 311
108470: AND
108471: PUSH
108472: LD_VAR 0 4
108476: PPUSH
108477: LD_EXP 83
108481: PUSH
108482: LD_VAR 0 1
108486: ARRAY
108487: PPUSH
108488: CALL_OW 308
108492: AND
108493: IFFALSE 108547
// begin mech := IsDrivenBy ( i ) ;
108495: LD_ADDR_VAR 0 9
108499: PUSH
108500: LD_VAR 0 4
108504: PPUSH
108505: CALL_OW 311
108509: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108510: LD_VAR 0 9
108514: PPUSH
108515: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108519: LD_VAR 0 9
108523: PPUSH
108524: LD_VAR 0 4
108528: PPUSH
108529: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108533: LD_VAR 0 9
108537: PPUSH
108538: LD_VAR 0 4
108542: PPUSH
108543: CALL_OW 180
// end ; end ; unit_human :
108547: GO 108894
108549: LD_INT 1
108551: DOUBLE
108552: EQUAL
108553: IFTRUE 108557
108555: GO 108893
108557: POP
// begin b := IsInUnit ( i ) ;
108558: LD_ADDR_VAR 0 18
108562: PUSH
108563: LD_VAR 0 4
108567: PPUSH
108568: CALL_OW 310
108572: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108573: LD_ADDR_VAR 0 19
108577: PUSH
108578: LD_VAR 0 18
108582: NOT
108583: PUSH
108584: LD_VAR 0 18
108588: PPUSH
108589: CALL_OW 266
108593: PUSH
108594: LD_INT 32
108596: PUSH
108597: LD_INT 31
108599: PUSH
108600: EMPTY
108601: LIST
108602: LIST
108603: IN
108604: OR
108605: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
108606: LD_VAR 0 18
108610: PPUSH
108611: CALL_OW 266
108615: PUSH
108616: LD_INT 5
108618: EQUAL
108619: PUSH
108620: LD_VAR 0 4
108624: PPUSH
108625: CALL_OW 257
108629: PUSH
108630: LD_INT 1
108632: PUSH
108633: LD_INT 2
108635: PUSH
108636: LD_INT 3
108638: PUSH
108639: LD_INT 4
108641: PUSH
108642: EMPTY
108643: LIST
108644: LIST
108645: LIST
108646: LIST
108647: IN
108648: AND
108649: IFFALSE 108686
// begin class := AllowSpecClass ( i ) ;
108651: LD_ADDR_VAR 0 20
108655: PUSH
108656: LD_VAR 0 4
108660: PPUSH
108661: CALL 16590 0 1
108665: ST_TO_ADDR
// if class then
108666: LD_VAR 0 20
108670: IFFALSE 108686
// ComChangeProfession ( i , class ) ;
108672: LD_VAR 0 4
108676: PPUSH
108677: LD_VAR 0 20
108681: PPUSH
108682: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108686: LD_VAR 0 16
108690: PUSH
108691: LD_VAR 0 2
108695: PPUSH
108696: LD_INT 21
108698: PUSH
108699: LD_INT 2
108701: PUSH
108702: EMPTY
108703: LIST
108704: LIST
108705: PPUSH
108706: CALL_OW 72
108710: PUSH
108711: LD_INT 1
108713: LESSEQUAL
108714: OR
108715: PUSH
108716: LD_VAR 0 19
108720: AND
108721: PUSH
108722: LD_VAR 0 4
108726: PUSH
108727: LD_VAR 0 17
108731: IN
108732: NOT
108733: AND
108734: IFFALSE 108827
// begin if b then
108736: LD_VAR 0 18
108740: IFFALSE 108789
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108742: LD_VAR 0 18
108746: PPUSH
108747: LD_VAR 0 21
108751: PPUSH
108752: LD_VAR 0 18
108756: PPUSH
108757: CALL_OW 74
108761: PPUSH
108762: CALL_OW 296
108766: PUSH
108767: LD_INT 10
108769: LESS
108770: PUSH
108771: LD_VAR 0 18
108775: PPUSH
108776: CALL_OW 461
108780: PUSH
108781: LD_INT 7
108783: NONEQUAL
108784: AND
108785: IFFALSE 108789
// continue ;
108787: GO 108024
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108789: LD_ADDR_VAR 0 17
108793: PUSH
108794: LD_VAR 0 17
108798: PPUSH
108799: LD_VAR 0 17
108803: PUSH
108804: LD_INT 1
108806: PLUS
108807: PPUSH
108808: LD_VAR 0 4
108812: PPUSH
108813: CALL_OW 1
108817: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108818: LD_VAR 0 4
108822: PPUSH
108823: CALL_OW 122
// end ; if sold_defenders then
108827: LD_VAR 0 17
108831: IFFALSE 108891
// if i in sold_defenders then
108833: LD_VAR 0 4
108837: PUSH
108838: LD_VAR 0 17
108842: IN
108843: IFFALSE 108891
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108845: LD_VAR 0 4
108849: PPUSH
108850: CALL_OW 314
108854: NOT
108855: PUSH
108856: LD_VAR 0 4
108860: PPUSH
108861: LD_VAR 0 13
108865: PPUSH
108866: CALL_OW 296
108870: PUSH
108871: LD_INT 30
108873: LESS
108874: AND
108875: IFFALSE 108891
// ComAttackUnit ( i , e ) ;
108877: LD_VAR 0 4
108881: PPUSH
108882: LD_VAR 0 13
108886: PPUSH
108887: CALL_OW 115
// end ; end ; end ;
108891: GO 108894
108893: POP
// if IsDead ( i ) then
108894: LD_VAR 0 4
108898: PPUSH
108899: CALL_OW 301
108903: IFFALSE 108921
// defenders := defenders diff i ;
108905: LD_ADDR_VAR 0 2
108909: PUSH
108910: LD_VAR 0 2
108914: PUSH
108915: LD_VAR 0 4
108919: DIFF
108920: ST_TO_ADDR
// end ;
108921: GO 108024
108923: POP
108924: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108925: LD_VAR 0 21
108929: NOT
108930: PUSH
108931: LD_VAR 0 2
108935: NOT
108936: OR
108937: PUSH
108938: LD_EXP 59
108942: PUSH
108943: LD_VAR 0 1
108947: ARRAY
108948: NOT
108949: OR
108950: IFFALSE 107928
// MC_Reset ( base , 18 ) ;
108952: LD_VAR 0 1
108956: PPUSH
108957: LD_INT 18
108959: PPUSH
108960: CALL 58513 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108964: LD_ADDR_VAR 0 2
108968: PUSH
108969: LD_VAR 0 2
108973: PUSH
108974: LD_VAR 0 2
108978: PPUSH
108979: LD_INT 2
108981: PUSH
108982: LD_INT 25
108984: PUSH
108985: LD_INT 1
108987: PUSH
108988: EMPTY
108989: LIST
108990: LIST
108991: PUSH
108992: LD_INT 25
108994: PUSH
108995: LD_INT 5
108997: PUSH
108998: EMPTY
108999: LIST
109000: LIST
109001: PUSH
109002: LD_INT 25
109004: PUSH
109005: LD_INT 8
109007: PUSH
109008: EMPTY
109009: LIST
109010: LIST
109011: PUSH
109012: LD_INT 25
109014: PUSH
109015: LD_INT 9
109017: PUSH
109018: EMPTY
109019: LIST
109020: LIST
109021: PUSH
109022: EMPTY
109023: LIST
109024: LIST
109025: LIST
109026: LIST
109027: LIST
109028: PPUSH
109029: CALL_OW 72
109033: DIFF
109034: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
109035: LD_VAR 0 21
109039: NOT
109040: PUSH
109041: LD_VAR 0 2
109045: PPUSH
109046: LD_INT 21
109048: PUSH
109049: LD_INT 2
109051: PUSH
109052: EMPTY
109053: LIST
109054: LIST
109055: PPUSH
109056: CALL_OW 72
109060: AND
109061: IFFALSE 109399
// begin tmp := FilterByTag ( defenders , 19 ) ;
109063: LD_ADDR_VAR 0 11
109067: PUSH
109068: LD_VAR 0 2
109072: PPUSH
109073: LD_INT 19
109075: PPUSH
109076: CALL 49059 0 2
109080: ST_TO_ADDR
// if tmp then
109081: LD_VAR 0 11
109085: IFFALSE 109155
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109087: LD_ADDR_VAR 0 11
109091: PUSH
109092: LD_VAR 0 11
109096: PPUSH
109097: LD_INT 25
109099: PUSH
109100: LD_INT 3
109102: PUSH
109103: EMPTY
109104: LIST
109105: LIST
109106: PPUSH
109107: CALL_OW 72
109111: ST_TO_ADDR
// if tmp then
109112: LD_VAR 0 11
109116: IFFALSE 109155
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109118: LD_ADDR_EXP 71
109122: PUSH
109123: LD_EXP 71
109127: PPUSH
109128: LD_VAR 0 1
109132: PPUSH
109133: LD_EXP 71
109137: PUSH
109138: LD_VAR 0 1
109142: ARRAY
109143: PUSH
109144: LD_VAR 0 11
109148: UNION
109149: PPUSH
109150: CALL_OW 1
109154: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109155: LD_VAR 0 1
109159: PPUSH
109160: LD_INT 19
109162: PPUSH
109163: CALL 58513 0 2
// repeat wait ( 0 0$1 ) ;
109167: LD_INT 35
109169: PPUSH
109170: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109174: LD_EXP 59
109178: PUSH
109179: LD_VAR 0 1
109183: ARRAY
109184: NOT
109185: PUSH
109186: LD_EXP 59
109190: PUSH
109191: LD_VAR 0 1
109195: ARRAY
109196: PUSH
109197: EMPTY
109198: EQUAL
109199: OR
109200: IFFALSE 109237
// begin for i in defenders do
109202: LD_ADDR_VAR 0 4
109206: PUSH
109207: LD_VAR 0 2
109211: PUSH
109212: FOR_IN
109213: IFFALSE 109226
// ComStop ( i ) ;
109215: LD_VAR 0 4
109219: PPUSH
109220: CALL_OW 141
109224: GO 109212
109226: POP
109227: POP
// defenders := [ ] ;
109228: LD_ADDR_VAR 0 2
109232: PUSH
109233: EMPTY
109234: ST_TO_ADDR
// exit ;
109235: GO 109463
// end ; for i in defenders do
109237: LD_ADDR_VAR 0 4
109241: PUSH
109242: LD_VAR 0 2
109246: PUSH
109247: FOR_IN
109248: IFFALSE 109337
// begin if not IsInArea ( i , mc_parking [ base ] ) then
109250: LD_VAR 0 4
109254: PPUSH
109255: LD_EXP 83
109259: PUSH
109260: LD_VAR 0 1
109264: ARRAY
109265: PPUSH
109266: CALL_OW 308
109270: NOT
109271: IFFALSE 109295
// ComMoveToArea ( i , mc_parking [ base ] ) else
109273: LD_VAR 0 4
109277: PPUSH
109278: LD_EXP 83
109282: PUSH
109283: LD_VAR 0 1
109287: ARRAY
109288: PPUSH
109289: CALL_OW 113
109293: GO 109335
// if GetControl ( i ) = control_manual then
109295: LD_VAR 0 4
109299: PPUSH
109300: CALL_OW 263
109304: PUSH
109305: LD_INT 1
109307: EQUAL
109308: IFFALSE 109335
// if IsDrivenBy ( i ) then
109310: LD_VAR 0 4
109314: PPUSH
109315: CALL_OW 311
109319: IFFALSE 109335
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
109321: LD_VAR 0 4
109325: PPUSH
109326: CALL_OW 311
109330: PPUSH
109331: CALL_OW 121
// end ;
109335: GO 109247
109337: POP
109338: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
109339: LD_VAR 0 2
109343: PPUSH
109344: LD_INT 95
109346: PUSH
109347: LD_EXP 83
109351: PUSH
109352: LD_VAR 0 1
109356: ARRAY
109357: PUSH
109358: EMPTY
109359: LIST
109360: LIST
109361: PPUSH
109362: CALL_OW 72
109366: PUSH
109367: LD_VAR 0 2
109371: EQUAL
109372: PUSH
109373: LD_EXP 82
109377: PUSH
109378: LD_VAR 0 1
109382: ARRAY
109383: OR
109384: PUSH
109385: LD_EXP 59
109389: PUSH
109390: LD_VAR 0 1
109394: ARRAY
109395: NOT
109396: OR
109397: IFFALSE 109167
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
109399: LD_ADDR_EXP 81
109403: PUSH
109404: LD_EXP 81
109408: PPUSH
109409: LD_VAR 0 1
109413: PPUSH
109414: LD_VAR 0 2
109418: PPUSH
109419: LD_INT 21
109421: PUSH
109422: LD_INT 2
109424: PUSH
109425: EMPTY
109426: LIST
109427: LIST
109428: PPUSH
109429: CALL_OW 72
109433: PPUSH
109434: CALL_OW 1
109438: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
109439: LD_VAR 0 1
109443: PPUSH
109444: LD_INT 19
109446: PPUSH
109447: CALL 58513 0 2
// MC_Reset ( base , 20 ) ;
109451: LD_VAR 0 1
109455: PPUSH
109456: LD_INT 20
109458: PPUSH
109459: CALL 58513 0 2
// end ; end_of_file
109463: LD_VAR 0 3
109467: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109468: LD_VAR 0 1
109472: PUSH
109473: LD_INT 200
109475: DOUBLE
109476: GREATEREQUAL
109477: IFFALSE 109485
109479: LD_INT 299
109481: DOUBLE
109482: LESSEQUAL
109483: IFTRUE 109487
109485: GO 109519
109487: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109488: LD_VAR 0 1
109492: PPUSH
109493: LD_VAR 0 2
109497: PPUSH
109498: LD_VAR 0 3
109502: PPUSH
109503: LD_VAR 0 4
109507: PPUSH
109508: LD_VAR 0 5
109512: PPUSH
109513: CALL 98310 0 5
109517: GO 109596
109519: LD_INT 300
109521: DOUBLE
109522: GREATEREQUAL
109523: IFFALSE 109531
109525: LD_INT 399
109527: DOUBLE
109528: LESSEQUAL
109529: IFTRUE 109533
109531: GO 109595
109533: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109534: LD_VAR 0 1
109538: PPUSH
109539: LD_VAR 0 2
109543: PPUSH
109544: LD_VAR 0 3
109548: PPUSH
109549: LD_VAR 0 4
109553: PPUSH
109554: LD_VAR 0 5
109558: PPUSH
109559: LD_VAR 0 6
109563: PPUSH
109564: LD_VAR 0 7
109568: PPUSH
109569: LD_VAR 0 8
109573: PPUSH
109574: LD_VAR 0 9
109578: PPUSH
109579: LD_VAR 0 10
109583: PPUSH
109584: LD_VAR 0 11
109588: PPUSH
109589: CALL 96198 0 11
109593: GO 109596
109595: POP
// end ;
109596: PPOPN 11
109598: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
109599: LD_VAR 0 1
109603: PPUSH
109604: LD_VAR 0 2
109608: PPUSH
109609: LD_VAR 0 3
109613: PPUSH
109614: LD_VAR 0 4
109618: PPUSH
109619: LD_VAR 0 5
109623: PPUSH
109624: CALL 98292 0 5
// end ; end_of_file
109628: PPOPN 5
109630: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
109631: LD_VAR 0 1
109635: PPUSH
109636: LD_VAR 0 2
109640: PPUSH
109641: LD_VAR 0 3
109645: PPUSH
109646: LD_VAR 0 4
109650: PPUSH
109651: LD_VAR 0 5
109655: PPUSH
109656: LD_VAR 0 6
109660: PPUSH
109661: CALL 85006 0 6
// end ;
109665: PPOPN 6
109667: END
