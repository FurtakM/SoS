// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 684 0 0
// InitMacro ;
  19: CALL 56335 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49064 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49064 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49064 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49064 0 9
// PrepareArabian ;
 168: CALL 4001 0 0
// PrepareRussian ;
 172: CALL 2972 0 0
// PrepareAlliance ;
 176: CALL 894 0 0
// MC_Start ( ) ;
 180: CALL 58507 0 0
// if debug then
 184: LD_EXP 1
 188: IFFALSE 197
// FogOff ( 1 ) ;
 190: LD_INT 1
 192: PPUSH
 193: CALL_OW 344
// Action ;
 197: CALL 7359 0 0
// end ;
 201: END
// export function CustomInitMacro ; var i ; begin
 202: LD_INT 0
 204: PPUSH
 205: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 206: LD_ADDR_EXP 85
 210: PUSH
 211: LD_INT 1
 213: PUSH
 214: LD_INT 2
 216: PUSH
 217: EMPTY
 218: LIST
 219: LIST
 220: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 221: LD_ADDR_EXP 86
 225: PUSH
 226: LD_INT 3
 228: PUSH
 229: LD_INT 4
 231: PUSH
 232: EMPTY
 233: LIST
 234: LIST
 235: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 236: LD_INT 1
 238: PPUSH
 239: LD_INT 12
 241: PUSH
 242: LD_INT 15
 244: PUSH
 245: LD_INT 18
 247: PUSH
 248: LD_INT 20
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: LIST
 255: LIST
 256: PUSH
 257: LD_OWVAR 67
 261: ARRAY
 262: PPUSH
 263: LD_INT 7
 265: PPUSH
 266: CALL 80245 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 270: LD_INT 1
 272: PPUSH
 273: LD_EXP 56
 277: PPUSH
 278: CALL 80671 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 282: LD_INT 1
 284: PPUSH
 285: LD_INT 6
 287: PPUSH
 288: CALL 81129 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 292: LD_INT 1
 294: PPUSH
 295: LD_INT 9
 297: PUSH
 298: EMPTY
 299: LIST
 300: PPUSH
 301: CALL 81398 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 305: LD_INT 1
 307: PPUSH
 308: LD_INT 13
 310: PUSH
 311: LD_INT 1
 313: PUSH
 314: LD_INT 2
 316: PUSH
 317: LD_INT 32
 319: PUSH
 320: EMPTY
 321: LIST
 322: LIST
 323: LIST
 324: LIST
 325: PUSH
 326: LD_INT 13
 328: PUSH
 329: LD_INT 1
 331: PUSH
 332: LD_INT 2
 334: PUSH
 335: LD_INT 88
 337: PUSH
 338: EMPTY
 339: LIST
 340: LIST
 341: LIST
 342: LIST
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: PPUSH
 348: CALL 80611 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 352: LD_INT 2
 354: PPUSH
 355: LD_INT 12
 357: PUSH
 358: LD_INT 14
 360: PUSH
 361: LD_INT 10
 363: PUSH
 364: LD_INT 11
 366: PUSH
 367: EMPTY
 368: LIST
 369: LIST
 370: LIST
 371: LIST
 372: PPUSH
 373: CALL 81305 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 377: LD_INT 2
 379: PPUSH
 380: LD_EXP 53
 384: PPUSH
 385: CALL 80671 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 389: LD_INT 2
 391: PPUSH
 392: LD_INT 8
 394: PPUSH
 395: CALL 81129 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 399: LD_INT 2
 401: PPUSH
 402: LD_INT 10
 404: PUSH
 405: EMPTY
 406: LIST
 407: PPUSH
 408: CALL 81398 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 412: LD_INT 2
 414: PPUSH
 415: LD_INT 6
 417: PUSH
 418: LD_INT 71
 420: PUSH
 421: LD_INT 116
 423: PUSH
 424: LD_INT 4
 426: PUSH
 427: EMPTY
 428: LIST
 429: LIST
 430: LIST
 431: LIST
 432: PUSH
 433: LD_INT 4
 435: PUSH
 436: LD_INT 85
 438: PUSH
 439: LD_INT 116
 441: PUSH
 442: LD_INT 4
 444: PUSH
 445: EMPTY
 446: LIST
 447: LIST
 448: LIST
 449: LIST
 450: PUSH
 451: LD_INT 32
 453: PUSH
 454: LD_INT 83
 456: PUSH
 457: LD_INT 111
 459: PUSH
 460: LD_INT 4
 462: PUSH
 463: EMPTY
 464: LIST
 465: LIST
 466: LIST
 467: LIST
 468: PUSH
 469: LD_INT 32
 471: PUSH
 472: LD_INT 87
 474: PUSH
 475: LD_INT 121
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: EMPTY
 482: LIST
 483: LIST
 484: LIST
 485: LIST
 486: PUSH
 487: LD_INT 33
 489: PUSH
 490: LD_INT 88
 492: PUSH
 493: LD_INT 128
 495: PUSH
 496: LD_INT 4
 498: PUSH
 499: EMPTY
 500: LIST
 501: LIST
 502: LIST
 503: LIST
 504: PUSH
 505: LD_INT 32
 507: PUSH
 508: LD_INT 59
 510: PUSH
 511: LD_INT 89
 513: PUSH
 514: LD_INT 3
 516: PUSH
 517: EMPTY
 518: LIST
 519: LIST
 520: LIST
 521: LIST
 522: PUSH
 523: LD_INT 33
 525: PUSH
 526: LD_INT 69
 528: PUSH
 529: LD_INT 98
 531: PUSH
 532: LD_INT 3
 534: PUSH
 535: EMPTY
 536: LIST
 537: LIST
 538: LIST
 539: LIST
 540: PUSH
 541: LD_INT 33
 543: PUSH
 544: LD_INT 77
 546: PUSH
 547: LD_INT 103
 549: PUSH
 550: LD_INT 3
 552: PUSH
 553: EMPTY
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: PUSH
 559: LD_INT 33
 561: PUSH
 562: LD_INT 83
 564: PUSH
 565: LD_INT 105
 567: PUSH
 568: LD_INT 3
 570: PUSH
 571: EMPTY
 572: LIST
 573: LIST
 574: LIST
 575: LIST
 576: PUSH
 577: LD_INT 33
 579: PUSH
 580: LD_INT 71
 582: PUSH
 583: LD_INT 125
 585: PUSH
 586: LD_INT 5
 588: PUSH
 589: EMPTY
 590: LIST
 591: LIST
 592: LIST
 593: LIST
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: PPUSH
 607: CALL 80455 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 611: LD_INT 2
 613: PPUSH
 614: LD_INT 43
 616: PUSH
 617: LD_INT 47
 619: PUSH
 620: LD_INT 46
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: PPUSH
 628: CALL 81716 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 632: LD_INT 2
 634: PPUSH
 635: LD_INT 21
 637: PUSH
 638: LD_INT 1
 640: PUSH
 641: LD_INT 3
 643: PUSH
 644: LD_INT 51
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: LD_INT 22
 655: PUSH
 656: LD_INT 1
 658: PUSH
 659: LD_INT 3
 661: PUSH
 662: LD_INT 52
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: PPUSH
 675: CALL 80611 0 2
// end ;
 679: LD_VAR 0 1
 683: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 684: LD_INT 0
 686: PPUSH
// debug := false ;
 687: LD_ADDR_EXP 1
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// game := true ;
 695: LD_ADDR_EXP 2
 699: PUSH
 700: LD_INT 1
 702: ST_TO_ADDR
// gossudarov_arrive := false ;
 703: LD_ADDR_EXP 4
 707: PUSH
 708: LD_INT 0
 710: ST_TO_ADDR
// ru_lab_builded := false ;
 711: LD_ADDR_EXP 5
 715: PUSH
 716: LD_INT 0
 718: ST_TO_ADDR
// player_spotted := false ;
 719: LD_ADDR_EXP 6
 723: PUSH
 724: LD_INT 0
 726: ST_TO_ADDR
// first_attack := false ;
 727: LD_ADDR_EXP 7
 731: PUSH
 732: LD_INT 0
 734: ST_TO_ADDR
// ru_attackers := [ ] ;
 735: LD_ADDR_EXP 54
 739: PUSH
 740: EMPTY
 741: ST_TO_ADDR
// ar_base_spotted := false ;
 742: LD_ADDR_EXP 8
 746: PUSH
 747: LD_INT 0
 749: ST_TO_ADDR
// ar_active_attack := false ;
 750: LD_ADDR_EXP 9
 754: PUSH
 755: LD_INT 0
 757: ST_TO_ADDR
// ar_attackers := [ ] ;
 758: LD_ADDR_EXP 11
 762: PUSH
 763: EMPTY
 764: ST_TO_ADDR
// first_powell_attack := false ;
 765: LD_ADDR_EXP 12
 769: PUSH
 770: LD_INT 0
 772: ST_TO_ADDR
// masha_killed := false ;
 773: LD_ADDR_EXP 10
 777: PUSH
 778: LD_INT 0
 780: ST_TO_ADDR
// abdul_escaped := true ;
 781: LD_ADDR_EXP 13
 785: PUSH
 786: LD_INT 1
 788: ST_TO_ADDR
// loss_counter := 0 ;
 789: LD_ADDR_EXP 14
 793: PUSH
 794: LD_INT 0
 796: ST_TO_ADDR
// hack_counter := 0 ;
 797: LD_ADDR_EXP 15
 801: PUSH
 802: LD_INT 0
 804: ST_TO_ADDR
// end ;
 805: LD_VAR 0 1
 809: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 810: LD_EXP 50
 814: PPUSH
 815: CALL_OW 255
 819: PUSH
 820: LD_INT 7
 822: EQUAL
 823: PUSH
 824: LD_EXP 49
 828: PPUSH
 829: CALL_OW 255
 833: PUSH
 834: LD_INT 7
 836: EQUAL
 837: AND
 838: PUSH
 839: LD_EXP 50
 843: PPUSH
 844: CALL_OW 302
 848: AND
 849: PUSH
 850: LD_EXP 49
 854: PPUSH
 855: CALL_OW 302
 859: AND
 860: IFFALSE 872
 862: GO 864
 864: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 865: LD_STRING ACH_COMRADE
 867: PPUSH
 868: CALL_OW 543
 872: END
// every 0 0$1 trigger hack_counter >= 10 do
 873: LD_EXP 15
 877: PUSH
 878: LD_INT 10
 880: GREATEREQUAL
 881: IFFALSE 893
 883: GO 885
 885: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 886: LD_STRING ACH_HACK
 888: PPUSH
 889: CALL_OW 543
 893: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 894: LD_INT 0
 896: PPUSH
 897: PPUSH
 898: PPUSH
 899: PPUSH
// uc_side := 7 ;
 900: LD_ADDR_OWVAR 20
 904: PUSH
 905: LD_INT 7
 907: ST_TO_ADDR
// uc_nation := 1 ;
 908: LD_ADDR_OWVAR 21
 912: PUSH
 913: LD_INT 1
 915: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 16
 920: PUSH
 921: LD_STRING JMM
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 14933 0 3
 937: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 938: LD_EXP 16
 942: PPUSH
 943: LD_INT 71
 945: PPUSH
 946: LD_INT 23
 948: PPUSH
 949: LD_INT 0
 951: PPUSH
 952: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 956: LD_EXP 16
 960: PPUSH
 961: LD_INT 2
 963: PPUSH
 964: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 968: LD_ADDR_EXP 17
 972: PUSH
 973: LD_STRING Roth
 975: PPUSH
 976: LD_EXP 1
 980: NOT
 981: PPUSH
 982: LD_STRING 12a_
 984: PPUSH
 985: CALL 14933 0 3
 989: ST_TO_ADDR
// if Roth then
 990: LD_EXP 17
 994: IFFALSE 1014
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 996: LD_EXP 17
1000: PPUSH
1001: LD_INT 71
1003: PPUSH
1004: LD_INT 21
1006: PPUSH
1007: LD_INT 0
1009: PPUSH
1010: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1014: LD_ADDR_EXP 33
1018: PUSH
1019: LD_STRING Mike
1021: PPUSH
1022: LD_EXP 1
1026: NOT
1027: PPUSH
1028: LD_STRING 12a_
1030: PPUSH
1031: CALL 14933 0 3
1035: ST_TO_ADDR
// if Mike then
1036: LD_EXP 33
1040: IFFALSE 1057
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1042: LD_EXP 33
1046: PPUSH
1047: LD_INT 13
1049: PPUSH
1050: LD_INT 0
1052: PPUSH
1053: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1057: LD_ADDR_EXP 18
1061: PUSH
1062: LD_STRING Lisa
1064: PPUSH
1065: LD_EXP 1
1069: NOT
1070: PPUSH
1071: LD_STRING 12a_
1073: PPUSH
1074: CALL 14933 0 3
1078: ST_TO_ADDR
// if Lisa then
1079: LD_EXP 18
1083: IFFALSE 1100
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1085: LD_EXP 18
1089: PPUSH
1090: LD_INT 13
1092: PPUSH
1093: LD_INT 0
1095: PPUSH
1096: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1100: LD_ADDR_EXP 19
1104: PUSH
1105: LD_STRING Donaldson
1107: PPUSH
1108: LD_EXP 1
1112: NOT
1113: PPUSH
1114: LD_STRING 12a_
1116: PPUSH
1117: CALL 14933 0 3
1121: ST_TO_ADDR
// if Donaldson then
1122: LD_EXP 19
1126: IFFALSE 1143
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1128: LD_EXP 19
1132: PPUSH
1133: LD_INT 13
1135: PPUSH
1136: LD_INT 0
1138: PPUSH
1139: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1143: LD_ADDR_EXP 20
1147: PUSH
1148: LD_STRING Bobby
1150: PPUSH
1151: LD_EXP 1
1155: NOT
1156: PPUSH
1157: LD_STRING 12a_
1159: PPUSH
1160: CALL 14933 0 3
1164: ST_TO_ADDR
// if Bobby then
1165: LD_EXP 20
1169: IFFALSE 1186
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1171: LD_EXP 20
1175: PPUSH
1176: LD_INT 13
1178: PPUSH
1179: LD_INT 0
1181: PPUSH
1182: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1186: LD_ADDR_EXP 21
1190: PUSH
1191: LD_STRING Cyrus
1193: PPUSH
1194: LD_EXP 1
1198: NOT
1199: PPUSH
1200: LD_STRING 12a_
1202: PPUSH
1203: CALL 14933 0 3
1207: ST_TO_ADDR
// if Cyrus then
1208: LD_EXP 21
1212: IFFALSE 1229
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1214: LD_EXP 21
1218: PPUSH
1219: LD_INT 13
1221: PPUSH
1222: LD_INT 0
1224: PPUSH
1225: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1229: LD_ADDR_EXP 22
1233: PUSH
1234: LD_STRING Denis
1236: PPUSH
1237: LD_EXP 1
1241: NOT
1242: PPUSH
1243: LD_STRING 12a_
1245: PPUSH
1246: CALL 14933 0 3
1250: ST_TO_ADDR
// if Denis then
1251: LD_EXP 22
1255: IFFALSE 1272
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1257: LD_EXP 22
1261: PPUSH
1262: LD_INT 13
1264: PPUSH
1265: LD_INT 0
1267: PPUSH
1268: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1272: LD_ADDR_EXP 23
1276: PUSH
1277: LD_STRING Brown
1279: PPUSH
1280: LD_EXP 1
1284: NOT
1285: PPUSH
1286: LD_STRING 12a_
1288: PPUSH
1289: CALL 14933 0 3
1293: ST_TO_ADDR
// if Brown then
1294: LD_EXP 23
1298: IFFALSE 1315
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1300: LD_EXP 23
1304: PPUSH
1305: LD_INT 13
1307: PPUSH
1308: LD_INT 0
1310: PPUSH
1311: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1315: LD_ADDR_EXP 24
1319: PUSH
1320: LD_STRING Gladstone
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_STRING 12a_
1331: PPUSH
1332: CALL 14933 0 3
1336: ST_TO_ADDR
// if Gladstone then
1337: LD_EXP 24
1341: IFFALSE 1358
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1343: LD_EXP 24
1347: PPUSH
1348: LD_INT 13
1350: PPUSH
1351: LD_INT 0
1353: PPUSH
1354: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1358: LD_ADDR_EXP 25
1362: PUSH
1363: LD_STRING Houten
1365: PPUSH
1366: LD_EXP 1
1370: NOT
1371: PPUSH
1372: LD_STRING 12a_
1374: PPUSH
1375: CALL 14933 0 3
1379: ST_TO_ADDR
// if Houten then
1380: LD_EXP 25
1384: IFFALSE 1401
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1386: LD_EXP 25
1390: PPUSH
1391: LD_INT 13
1393: PPUSH
1394: LD_INT 0
1396: PPUSH
1397: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1401: LD_ADDR_EXP 26
1405: PUSH
1406: LD_STRING Cornell
1408: PPUSH
1409: LD_EXP 1
1413: NOT
1414: PPUSH
1415: LD_STRING 12a_
1417: PPUSH
1418: CALL 14933 0 3
1422: ST_TO_ADDR
// if Cornel then
1423: LD_EXP 26
1427: IFFALSE 1444
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1429: LD_EXP 26
1433: PPUSH
1434: LD_INT 13
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1444: LD_ADDR_EXP 27
1448: PUSH
1449: LD_STRING Gary
1451: PPUSH
1452: LD_EXP 1
1456: NOT
1457: PPUSH
1458: LD_STRING 12a_
1460: PPUSH
1461: CALL 14933 0 3
1465: ST_TO_ADDR
// if Gary then
1466: LD_EXP 27
1470: IFFALSE 1487
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1472: LD_EXP 27
1476: PPUSH
1477: LD_INT 13
1479: PPUSH
1480: LD_INT 0
1482: PPUSH
1483: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1487: LD_ADDR_EXP 28
1491: PUSH
1492: LD_STRING Frank
1494: PPUSH
1495: LD_EXP 1
1499: NOT
1500: PPUSH
1501: LD_STRING 12a_
1503: PPUSH
1504: CALL 14933 0 3
1508: ST_TO_ADDR
// if Frank then
1509: LD_EXP 28
1513: IFFALSE 1530
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1515: LD_EXP 28
1519: PPUSH
1520: LD_INT 13
1522: PPUSH
1523: LD_INT 0
1525: PPUSH
1526: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1530: LD_ADDR_EXP 29
1534: PUSH
1535: LD_STRING Kikuchi
1537: PPUSH
1538: LD_EXP 1
1542: NOT
1543: PPUSH
1544: LD_STRING 12a_
1546: PPUSH
1547: CALL 14933 0 3
1551: ST_TO_ADDR
// if Kikuchi then
1552: LD_EXP 29
1556: IFFALSE 1573
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1558: LD_EXP 29
1562: PPUSH
1563: LD_INT 13
1565: PPUSH
1566: LD_INT 0
1568: PPUSH
1569: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1573: LD_ADDR_EXP 30
1577: PUSH
1578: LD_STRING Simms
1580: PPUSH
1581: LD_EXP 1
1585: NOT
1586: PPUSH
1587: LD_STRING 12a_
1589: PPUSH
1590: CALL 14933 0 3
1594: ST_TO_ADDR
// if Simms then
1595: LD_EXP 30
1599: IFFALSE 1616
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1601: LD_EXP 30
1605: PPUSH
1606: LD_INT 13
1608: PPUSH
1609: LD_INT 0
1611: PPUSH
1612: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1616: LD_ADDR_EXP 31
1620: PUSH
1621: LD_STRING Joan
1623: PPUSH
1624: LD_EXP 1
1628: NOT
1629: PPUSH
1630: LD_STRING 12a_
1632: PPUSH
1633: CALL 14933 0 3
1637: ST_TO_ADDR
// if Joan then
1638: LD_EXP 31
1642: IFFALSE 1659
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1644: LD_EXP 31
1648: PPUSH
1649: LD_INT 13
1651: PPUSH
1652: LD_INT 0
1654: PPUSH
1655: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1659: LD_ADDR_EXP 32
1663: PUSH
1664: LD_STRING DeltaDoctor
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 12a_
1675: PPUSH
1676: CALL 14933 0 3
1680: ST_TO_ADDR
// if DeltaDoctor then
1681: LD_EXP 32
1685: IFFALSE 1702
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1687: LD_EXP 32
1691: PPUSH
1692: LD_INT 13
1694: PPUSH
1695: LD_INT 0
1697: PPUSH
1698: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1702: LD_ADDR_VAR 0 4
1706: PUSH
1707: LD_STRING 12a_others
1709: PPUSH
1710: CALL_OW 31
1714: ST_TO_ADDR
// if tmp then
1715: LD_VAR 0 4
1719: IFFALSE 1753
// for i in tmp do
1721: LD_ADDR_VAR 0 3
1725: PUSH
1726: LD_VAR 0 4
1730: PUSH
1731: FOR_IN
1732: IFFALSE 1751
// PlaceUnitArea ( i , alliance_start , false ) ;
1734: LD_VAR 0 3
1738: PPUSH
1739: LD_INT 13
1741: PPUSH
1742: LD_INT 0
1744: PPUSH
1745: CALL_OW 49
1749: GO 1731
1751: POP
1752: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1753: LD_INT 3
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 3
1761: PPUSH
1762: LD_INT 12
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 19948 0 5
// veh := CreateVehicle ;
1772: LD_ADDR_VAR 0 2
1776: PUSH
1777: CALL_OW 45
1781: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 2
1789: PPUSH
1790: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1794: LD_VAR 0 2
1798: PPUSH
1799: LD_INT 60
1801: PPUSH
1802: LD_INT 6
1804: PPUSH
1805: LD_INT 0
1807: PPUSH
1808: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1812: LD_VAR 0 2
1816: PPUSH
1817: LD_INT 4
1819: PPUSH
1820: LD_INT 30
1822: PPUSH
1823: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1827: LD_STRING 11_artifact_captured
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 30
1837: IFFALSE 1913
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1839: LD_INT 3
1841: PPUSH
1842: LD_INT 3
1844: PPUSH
1845: LD_INT 3
1847: PPUSH
1848: LD_INT 12
1850: PPUSH
1851: LD_INT 100
1853: PPUSH
1854: CALL 19948 0 5
// veh := CreateVehicle ;
1858: LD_ADDR_VAR 0 2
1862: PUSH
1863: CALL_OW 45
1867: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1868: LD_VAR 0 2
1872: PPUSH
1873: LD_INT 3
1875: PPUSH
1876: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1880: LD_VAR 0 2
1884: PPUSH
1885: LD_INT 75
1887: PPUSH
1888: LD_INT 6
1890: PPUSH
1891: LD_INT 0
1893: PPUSH
1894: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1898: LD_VAR 0 2
1902: PPUSH
1903: LD_INT 4
1905: PPUSH
1906: LD_INT 50
1908: PPUSH
1909: CALL_OW 290
// end ; end ;
1913: LD_VAR 0 1
1917: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1918: LD_INT 0
1920: PPUSH
1921: PPUSH
1922: PPUSH
1923: PPUSH
// uc_side := 6 ;
1924: LD_ADDR_OWVAR 20
1928: PUSH
1929: LD_INT 6
1931: ST_TO_ADDR
// uc_nation := 3 ;
1932: LD_ADDR_OWVAR 21
1936: PUSH
1937: LD_INT 3
1939: ST_TO_ADDR
// InitHc ;
1940: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1944: LD_ADDR_EXP 34
1948: PUSH
1949: LD_STRING Gossudarov
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1957: LD_ADDR_EXP 35
1961: PUSH
1962: LD_STRING Kirilenkova
1964: PPUSH
1965: CALL_OW 25
1969: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1970: LD_ADDR_EXP 36
1974: PUSH
1975: LD_STRING Titov
1977: PPUSH
1978: CALL_OW 25
1982: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1983: LD_ADDR_EXP 41
1987: PUSH
1988: LD_STRING Oblukov
1990: PPUSH
1991: CALL_OW 25
1995: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1996: LD_ADDR_EXP 38
2000: PUSH
2001: LD_STRING Dolgov
2003: PPUSH
2004: CALL_OW 25
2008: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2009: LD_ADDR_EXP 39
2013: PUSH
2014: LD_STRING Petrosyan
2016: PPUSH
2017: CALL_OW 25
2021: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2022: LD_ADDR_EXP 40
2026: PUSH
2027: LD_STRING Scholtze
2029: PPUSH
2030: CALL_OW 25
2034: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2035: LD_ADDR_EXP 42
2039: PUSH
2040: LD_STRING Kapitsova
2042: PPUSH
2043: CALL_OW 25
2047: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2048: LD_ADDR_VAR 0 2
2052: PUSH
2053: LD_EXP 34
2057: PUSH
2058: LD_EXP 35
2062: PUSH
2063: LD_EXP 36
2067: PUSH
2068: LD_EXP 41
2072: PUSH
2073: LD_EXP 38
2077: PUSH
2078: LD_EXP 39
2082: PUSH
2083: LD_EXP 40
2087: PUSH
2088: LD_EXP 42
2092: PUSH
2093: EMPTY
2094: LIST
2095: LIST
2096: LIST
2097: LIST
2098: LIST
2099: LIST
2100: LIST
2101: LIST
2102: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2103: LD_INT 1
2105: PPUSH
2106: LD_INT 4
2108: PPUSH
2109: LD_INT 8
2111: PPUSH
2112: CALL_OW 380
// un := CreateHuman ;
2116: LD_ADDR_VAR 0 4
2120: PUSH
2121: CALL_OW 44
2125: ST_TO_ADDR
// tmp := tmp ^ un ;
2126: LD_ADDR_VAR 0 2
2130: PUSH
2131: LD_VAR 0 2
2135: PUSH
2136: LD_VAR 0 4
2140: ADD
2141: ST_TO_ADDR
// for i in tmp do
2142: LD_ADDR_VAR 0 3
2146: PUSH
2147: LD_VAR 0 2
2151: PUSH
2152: FOR_IN
2153: IFFALSE 2172
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2155: LD_VAR 0 3
2159: PPUSH
2160: LD_INT 14
2162: PPUSH
2163: LD_INT 0
2165: PPUSH
2166: CALL_OW 49
2170: GO 2152
2172: POP
2173: POP
// if freedom then
2174: LD_EXP 3
2178: IFFALSE 2211
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2180: LD_VAR 0 2
2184: PPUSH
2185: LD_EXP 3
2189: PPUSH
2190: CALL_OW 250
2194: PPUSH
2195: LD_EXP 3
2199: PPUSH
2200: CALL_OW 251
2204: PPUSH
2205: CALL_OW 111
2209: GO 2226
// ComMoveXY ( tmp , 70 , 48 ) ;
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_INT 70
2218: PPUSH
2219: LD_INT 48
2221: PPUSH
2222: CALL_OW 111
// end ;
2226: LD_VAR 0 1
2230: RET
// export function PrepareBelkov ; begin
2231: LD_INT 0
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2254: LD_ADDR_EXP 49
2258: PUSH
2259: LD_STRING Belkov
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2267: LD_EXP 49
2271: PPUSH
2272: LD_INT 14
2274: PPUSH
2275: LD_INT 0
2277: PPUSH
2278: CALL_OW 49
// end ;
2282: LD_VAR 0 1
2286: RET
// export function PrepareGnyevko ; begin
2287: LD_INT 0
2289: PPUSH
// uc_side := 4 ;
2290: LD_ADDR_OWVAR 20
2294: PUSH
2295: LD_INT 4
2297: ST_TO_ADDR
// uc_nation := 3 ;
2298: LD_ADDR_OWVAR 21
2302: PUSH
2303: LD_INT 3
2305: ST_TO_ADDR
// InitHc ;
2306: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2310: LD_ADDR_EXP 50
2314: PUSH
2315: LD_STRING Gnyevko
2317: PPUSH
2318: CALL_OW 25
2322: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2323: LD_EXP 50
2327: PPUSH
2328: LD_INT 14
2330: PPUSH
2331: LD_INT 0
2333: PPUSH
2334: CALL_OW 49
// end ;
2338: LD_VAR 0 1
2342: RET
// export function PrepareBurlak ; var i , tmp ; begin
2343: LD_INT 0
2345: PPUSH
2346: PPUSH
2347: PPUSH
// uc_side := 4 ;
2348: LD_ADDR_OWVAR 20
2352: PUSH
2353: LD_INT 4
2355: ST_TO_ADDR
// uc_nation := 3 ;
2356: LD_ADDR_OWVAR 21
2360: PUSH
2361: LD_INT 3
2363: ST_TO_ADDR
// InitHc ;
2364: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2368: LD_ADDR_EXP 48
2372: PUSH
2373: LD_STRING Burlak
2375: PPUSH
2376: CALL_OW 25
2380: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2381: LD_INT 24
2383: PUSH
2384: LD_INT 23
2386: PUSH
2387: LD_INT 22
2389: PUSH
2390: LD_INT 22
2392: PUSH
2393: EMPTY
2394: LIST
2395: LIST
2396: LIST
2397: LIST
2398: PUSH
2399: LD_OWVAR 67
2403: ARRAY
2404: PPUSH
2405: LD_INT 1
2407: PPUSH
2408: LD_INT 1
2410: PPUSH
2411: LD_INT 45
2413: PUSH
2414: LD_INT 44
2416: PUSH
2417: LD_INT 43
2419: PUSH
2420: LD_INT 42
2422: PUSH
2423: EMPTY
2424: LIST
2425: LIST
2426: LIST
2427: LIST
2428: PUSH
2429: LD_OWVAR 67
2433: ARRAY
2434: PPUSH
2435: LD_INT 0
2437: PPUSH
2438: CALL 19948 0 5
// Masha := CreateVehicle ;
2442: LD_ADDR_EXP 51
2446: PUSH
2447: CALL_OW 45
2451: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2452: LD_EXP 51
2456: PUSH
2457: LD_EXP 48
2461: PUSH
2462: EMPTY
2463: LIST
2464: LIST
2465: PPUSH
2466: LD_INT 499
2468: PPUSH
2469: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2473: LD_EXP 51
2477: PPUSH
2478: LD_INT 3
2480: PPUSH
2481: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2485: LD_EXP 51
2489: PPUSH
2490: LD_INT 1
2492: PPUSH
2493: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2497: LD_INT 1
2499: PPUSH
2500: LD_INT 18
2502: PPUSH
2503: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2507: LD_INT 35
2509: PPUSH
2510: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2514: LD_ADDR_VAR 0 3
2518: PUSH
2519: LD_INT 18
2521: PPUSH
2522: EMPTY
2523: PPUSH
2524: CALL_OW 70
2528: ST_TO_ADDR
// if tmp then
2529: LD_VAR 0 3
2533: IFFALSE 2567
// for i in tmp do
2535: LD_ADDR_VAR 0 2
2539: PUSH
2540: LD_VAR 0 3
2544: PUSH
2545: FOR_IN
2546: IFFALSE 2565
// ComMoveXY ( i , 114 , 9 ) ;
2548: LD_VAR 0 2
2552: PPUSH
2553: LD_INT 114
2555: PPUSH
2556: LD_INT 9
2558: PPUSH
2559: CALL_OW 111
2563: GO 2545
2565: POP
2566: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2567: LD_INT 18
2569: PPUSH
2570: EMPTY
2571: PPUSH
2572: CALL_OW 70
2576: NOT
2577: PUSH
2578: LD_INT 123
2580: PPUSH
2581: LD_INT 3
2583: PPUSH
2584: CALL_OW 428
2588: PUSH
2589: LD_INT 0
2591: EQUAL
2592: AND
2593: IFFALSE 2507
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2595: LD_EXP 51
2599: PPUSH
2600: LD_INT 123
2602: PPUSH
2603: LD_INT 3
2605: PPUSH
2606: LD_INT 0
2608: PPUSH
2609: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2613: LD_EXP 48
2617: PPUSH
2618: LD_INT 125
2620: PPUSH
2621: LD_INT 1
2623: PPUSH
2624: LD_INT 0
2626: PPUSH
2627: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2631: LD_EXP 48
2635: PPUSH
2636: LD_EXP 51
2640: PPUSH
2641: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2645: LD_INT 10
2647: PPUSH
2648: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2652: LD_EXP 51
2656: PPUSH
2657: LD_INT 110
2659: PPUSH
2660: LD_INT 10
2662: PPUSH
2663: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2667: LD_ADDR_EXP 44
2671: PUSH
2672: LD_STRING Petrovova
2674: PPUSH
2675: CALL_OW 25
2679: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2680: LD_ADDR_EXP 46
2684: PUSH
2685: LD_STRING Kuzmov
2687: PPUSH
2688: CALL_OW 25
2692: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2693: LD_ADDR_EXP 45
2697: PUSH
2698: LD_STRING Kovalyuk
2700: PPUSH
2701: CALL_OW 25
2705: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2706: LD_ADDR_EXP 43
2710: PUSH
2711: LD_STRING Lipshchin
2713: PPUSH
2714: CALL_OW 25
2718: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2719: LD_ADDR_EXP 47
2723: PUSH
2724: LD_STRING Karamazov
2726: PPUSH
2727: CALL_OW 25
2731: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2732: LD_ADDR_VAR 0 3
2736: PUSH
2737: LD_EXP 44
2741: PUSH
2742: LD_EXP 46
2746: PUSH
2747: LD_EXP 45
2751: PUSH
2752: LD_EXP 43
2756: PUSH
2757: LD_EXP 47
2761: PUSH
2762: EMPTY
2763: LIST
2764: LIST
2765: LIST
2766: LIST
2767: LIST
2768: ST_TO_ADDR
// for i in tmp do
2769: LD_ADDR_VAR 0 2
2773: PUSH
2774: LD_VAR 0 3
2778: PUSH
2779: FOR_IN
2780: IFFALSE 2819
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2782: LD_VAR 0 2
2786: PPUSH
2787: LD_INT 399
2789: PPUSH
2790: LD_INT 799
2792: PPUSH
2793: CALL_OW 12
2797: PPUSH
2798: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2802: LD_VAR 0 2
2806: PPUSH
2807: LD_INT 19
2809: PPUSH
2810: LD_INT 0
2812: PPUSH
2813: CALL_OW 49
// end ;
2817: GO 2779
2819: POP
2820: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2821: LD_VAR 0 3
2825: PPUSH
2826: LD_INT 112
2828: PPUSH
2829: LD_INT 5
2831: PPUSH
2832: CALL_OW 111
// AddComHold ( tmp ) ;
2836: LD_VAR 0 3
2840: PPUSH
2841: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2845: LD_ADDR_VAR 0 2
2849: PUSH
2850: LD_VAR 0 3
2854: PPUSH
2855: LD_INT 25
2857: PUSH
2858: LD_INT 1
2860: PUSH
2861: EMPTY
2862: LIST
2863: LIST
2864: PPUSH
2865: CALL_OW 72
2869: PUSH
2870: FOR_IN
2871: IFFALSE 2911
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2873: LD_VAR 0 2
2877: PPUSH
2878: LD_INT 20
2880: PPUSH
2881: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2885: LD_VAR 0 2
2889: PPUSH
2890: LD_INT 147
2892: PPUSH
2893: LD_INT 45
2895: PPUSH
2896: CALL_OW 178
// AddComCrawl ( i ) ;
2900: LD_VAR 0 2
2904: PPUSH
2905: CALL_OW 197
// end ;
2909: GO 2870
2911: POP
2912: POP
// repeat wait ( 0 0$1 ) ;
2913: LD_INT 35
2915: PPUSH
2916: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2920: LD_EXP 51
2924: PPUSH
2925: LD_INT 110
2927: PPUSH
2928: LD_INT 10
2930: PPUSH
2931: CALL_OW 307
2935: PUSH
2936: LD_EXP 51
2940: PPUSH
2941: CALL_OW 305
2945: NOT
2946: OR
2947: IFFALSE 2913
// ComStop ( Burlak ) ;
2949: LD_EXP 48
2953: PPUSH
2954: CALL_OW 141
// AddComHold ( Burlak ) ;
2958: LD_EXP 48
2962: PPUSH
2963: CALL_OW 200
// end ; end_of_file
2967: LD_VAR 0 1
2971: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2972: LD_INT 0
2974: PPUSH
2975: PPUSH
2976: PPUSH
2977: PPUSH
2978: PPUSH
// uc_side := 3 ;
2979: LD_ADDR_OWVAR 20
2983: PUSH
2984: LD_INT 3
2986: ST_TO_ADDR
// uc_nation := 3 ;
2987: LD_ADDR_OWVAR 21
2991: PUSH
2992: LD_INT 3
2994: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2995: LD_ADDR_EXP 52
2999: PUSH
3000: LD_INT 47
3002: PPUSH
3003: LD_INT 4
3005: PPUSH
3006: LD_STRING 
3008: PPUSH
3009: LD_INT 7
3011: PUSH
3012: LD_INT 8
3014: PUSH
3015: LD_INT 9
3017: PUSH
3018: LD_INT 10
3020: PUSH
3021: EMPTY
3022: LIST
3023: LIST
3024: LIST
3025: LIST
3026: PUSH
3027: LD_OWVAR 67
3031: ARRAY
3032: PPUSH
3033: LD_INT 10000
3035: PUSH
3036: LD_INT 3000
3038: PUSH
3039: LD_INT 300
3041: PUSH
3042: EMPTY
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: LD_INT 9
3049: PUSH
3050: LD_INT 5
3052: PUSH
3053: LD_INT 6
3055: PUSH
3056: LD_INT 6
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: PPUSH
3065: CALL 23392 0 6
3069: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3070: LD_ADDR_EXP 61
3074: PUSH
3075: LD_EXP 61
3079: PPUSH
3080: LD_INT 2
3082: PPUSH
3083: LD_EXP 52
3087: PPUSH
3088: CALL_OW 1
3092: ST_TO_ADDR
// tmp := [ ] ;
3093: LD_ADDR_VAR 0 4
3097: PUSH
3098: EMPTY
3099: ST_TO_ADDR
// for i = 1 to 4 do
3100: LD_ADDR_VAR 0 2
3104: PUSH
3105: DOUBLE
3106: LD_INT 1
3108: DEC
3109: ST_TO_ADDR
3110: LD_INT 4
3112: PUSH
3113: FOR_TO
3114: IFFALSE 3207
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3116: LD_INT 22
3118: PPUSH
3119: LD_INT 3
3121: PPUSH
3122: LD_INT 3
3124: PPUSH
3125: LD_INT 43
3127: PUSH
3128: LD_INT 45
3130: PUSH
3131: LD_INT 45
3133: PUSH
3134: LD_INT 44
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PUSH
3143: LD_VAR 0 2
3147: PUSH
3148: LD_INT 4
3150: MOD
3151: PUSH
3152: LD_INT 1
3154: PLUS
3155: ARRAY
3156: PPUSH
3157: LD_INT 100
3159: PPUSH
3160: CALL 19948 0 5
// veh := CreateVehicle ;
3164: LD_ADDR_VAR 0 3
3168: PUSH
3169: CALL_OW 45
3173: ST_TO_ADDR
// tmp := tmp ^ veh ;
3174: LD_ADDR_VAR 0 4
3178: PUSH
3179: LD_VAR 0 4
3183: PUSH
3184: LD_VAR 0 3
3188: ADD
3189: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3190: LD_VAR 0 3
3194: PPUSH
3195: LD_INT 2
3197: PPUSH
3198: LD_INT 0
3200: PPUSH
3201: CALL_OW 49
// end ;
3205: GO 3113
3207: POP
3208: POP
// russian_guard := tmp ;
3209: LD_ADDR_EXP 53
3213: PUSH
3214: LD_VAR 0 4
3218: ST_TO_ADDR
// if Difficulty >= 3 then
3219: LD_OWVAR 67
3223: PUSH
3224: LD_INT 3
3226: GREATEREQUAL
3227: IFFALSE 3291
// begin bc_type := b_breastwork ;
3229: LD_ADDR_OWVAR 42
3233: PUSH
3234: LD_INT 31
3236: ST_TO_ADDR
// bc_level := 10 ;
3237: LD_ADDR_OWVAR 43
3241: PUSH
3242: LD_INT 10
3244: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3245: LD_ADDR_VAR 0 5
3249: PUSH
3250: LD_INT 96
3252: PPUSH
3253: LD_INT 105
3255: PPUSH
3256: LD_INT 3
3258: PPUSH
3259: CALL_OW 47
3263: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3264: LD_INT 0
3266: PPUSH
3267: LD_INT 9
3269: PPUSH
3270: LD_INT 10
3272: PPUSH
3273: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3277: CALL_OW 44
3281: PPUSH
3282: LD_VAR 0 5
3286: PPUSH
3287: CALL_OW 52
// end ; end ;
3291: LD_VAR 0 1
3295: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3296: LD_INT 47
3298: PPUSH
3299: CALL_OW 302
3303: PUSH
3304: LD_EXP 6
3308: AND
3309: IFFALSE 3998
3311: GO 3313
3313: DISABLE
3314: LD_INT 0
3316: PPUSH
3317: PPUSH
3318: PPUSH
3319: PPUSH
3320: PPUSH
3321: PPUSH
3322: PPUSH
// begin enable ;
3323: ENABLE
// base := 2 ;
3324: LD_ADDR_VAR 0 2
3328: PUSH
3329: LD_INT 2
3331: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3332: LD_ADDR_VAR 0 4
3336: PUSH
3337: LD_INT 0
3339: PUSH
3340: LD_INT 0
3342: PUSH
3343: LD_INT 0
3345: PUSH
3346: LD_INT 0
3348: PUSH
3349: LD_INT 0
3351: PUSH
3352: LD_INT 0
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 1
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: EMPTY
3368: LIST
3369: LIST
3370: LIST
3371: LIST
3372: LIST
3373: LIST
3374: LIST
3375: LIST
3376: LIST
3377: LIST
3378: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3379: LD_ADDR_VAR 0 3
3383: PUSH
3384: LD_INT 22
3386: PUSH
3387: LD_INT 1
3389: PUSH
3390: LD_INT 3
3392: PUSH
3393: LD_INT 45
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: LIST
3400: LIST
3401: PUSH
3402: LD_INT 21
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 22
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 23
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 46
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: EMPTY
3457: LIST
3458: LIST
3459: LIST
3460: LIST
3461: ST_TO_ADDR
// amount := Difficulty ;
3462: LD_ADDR_VAR 0 7
3466: PUSH
3467: LD_OWVAR 67
3471: ST_TO_ADDR
// if tick > 30 30$00 then
3472: LD_OWVAR 1
3476: PUSH
3477: LD_INT 63000
3479: GREATER
3480: IFFALSE 3517
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3482: LD_ADDR_VAR 0 7
3486: PUSH
3487: LD_VAR 0 7
3491: PUSH
3492: LD_INT 2
3494: PUSH
3495: LD_INT 3
3497: PUSH
3498: LD_INT 4
3500: PUSH
3501: LD_INT 4
3503: PUSH
3504: EMPTY
3505: LIST
3506: LIST
3507: LIST
3508: LIST
3509: PUSH
3510: LD_OWVAR 67
3514: ARRAY
3515: PLUS
3516: ST_TO_ADDR
// for i = 1 to amount do
3517: LD_ADDR_VAR 0 1
3521: PUSH
3522: DOUBLE
3523: LD_INT 1
3525: DEC
3526: ST_TO_ADDR
3527: LD_VAR 0 7
3531: PUSH
3532: FOR_TO
3533: IFFALSE 3621
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3535: LD_ADDR_VAR 0 3
3539: PUSH
3540: LD_VAR 0 3
3544: PPUSH
3545: LD_VAR 0 3
3549: PUSH
3550: LD_INT 1
3552: PLUS
3553: PPUSH
3554: LD_INT 23
3556: PUSH
3557: LD_INT 24
3559: PUSH
3560: EMPTY
3561: LIST
3562: LIST
3563: PUSH
3564: LD_INT 1
3566: PPUSH
3567: LD_INT 2
3569: PPUSH
3570: CALL_OW 12
3574: ARRAY
3575: PUSH
3576: LD_INT 1
3578: PUSH
3579: LD_INT 3
3581: PUSH
3582: LD_INT 46
3584: PUSH
3585: LD_INT 47
3587: PUSH
3588: LD_INT 45
3590: PUSH
3591: EMPTY
3592: LIST
3593: LIST
3594: LIST
3595: PUSH
3596: LD_INT 1
3598: PPUSH
3599: LD_INT 3
3601: PPUSH
3602: CALL_OW 12
3606: ARRAY
3607: PUSH
3608: EMPTY
3609: LIST
3610: LIST
3611: LIST
3612: LIST
3613: PPUSH
3614: CALL_OW 2
3618: ST_TO_ADDR
3619: GO 3532
3621: POP
3622: POP
// MC_InsertProduceList ( base , tmp ) ;
3623: LD_VAR 0 2
3627: PPUSH
3628: LD_VAR 0 3
3632: PPUSH
3633: CALL 80611 0 2
// repeat wait ( 0 0$1 ) ;
3637: LD_INT 35
3639: PPUSH
3640: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3644: LD_VAR 0 2
3648: PPUSH
3649: LD_INT 1
3651: PPUSH
3652: CALL 82029 0 2
3656: PUSH
3657: LD_VAR 0 7
3661: GREATEREQUAL
3662: IFFALSE 3637
// wait ( 0 0$30 ) ;
3664: LD_INT 1050
3666: PPUSH
3667: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3671: LD_ADDR_VAR 0 5
3675: PUSH
3676: LD_INT 71
3678: PUSH
3679: LD_INT 19
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: PUSH
3686: LD_INT 91
3688: PUSH
3689: LD_INT 67
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 52
3698: PUSH
3699: LD_INT 44
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: LD_INT 68
3708: PUSH
3709: LD_INT 48
3711: PUSH
3712: EMPTY
3713: LIST
3714: LIST
3715: PUSH
3716: EMPTY
3717: LIST
3718: LIST
3719: LIST
3720: LIST
3721: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_EXP 80
3731: PUSH
3732: LD_VAR 0 2
3736: ARRAY
3737: PUSH
3738: LD_EXP 80
3742: PUSH
3743: LD_VAR 0 2
3747: ARRAY
3748: PPUSH
3749: LD_INT 2
3751: PUSH
3752: LD_INT 34
3754: PUSH
3755: LD_INT 51
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 34
3764: PUSH
3765: LD_INT 52
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 72
3781: DIFF
3782: ST_TO_ADDR
// if not attackers then
3783: LD_VAR 0 6
3787: NOT
3788: IFFALSE 3792
// exit ;
3790: GO 3998
// ru_attackers := attackers ;
3792: LD_ADDR_EXP 54
3796: PUSH
3797: LD_VAR 0 6
3801: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3802: LD_ADDR_EXP 80
3806: PUSH
3807: LD_EXP 80
3811: PPUSH
3812: LD_VAR 0 2
3816: PPUSH
3817: LD_EXP 80
3821: PUSH
3822: LD_VAR 0 2
3826: ARRAY
3827: PUSH
3828: LD_VAR 0 6
3832: DIFF
3833: PPUSH
3834: CALL_OW 1
3838: ST_TO_ADDR
// for i = 1 to attackers do
3839: LD_ADDR_VAR 0 1
3843: PUSH
3844: DOUBLE
3845: LD_INT 1
3847: DEC
3848: ST_TO_ADDR
3849: LD_VAR 0 6
3853: PUSH
3854: FOR_TO
3855: IFFALSE 3932
// begin case i mod 3 of 0 :
3857: LD_VAR 0 1
3861: PUSH
3862: LD_INT 3
3864: MOD
3865: PUSH
3866: LD_INT 0
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3877
3874: POP
// ; 1 :
3875: GO 3930
3877: LD_INT 1
3879: DOUBLE
3880: EQUAL
3881: IFTRUE 3885
3883: GO 3903
3885: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3886: LD_VAR 0 1
3890: PPUSH
3891: LD_INT 32
3893: PPUSH
3894: LD_INT 49
3896: PPUSH
3897: CALL_OW 114
3901: GO 3930
3903: LD_INT 2
3905: DOUBLE
3906: EQUAL
3907: IFTRUE 3911
3909: GO 3929
3911: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3912: LD_VAR 0 1
3916: PPUSH
3917: LD_INT 117
3919: PPUSH
3920: LD_INT 107
3922: PPUSH
3923: CALL_OW 114
3927: GO 3930
3929: POP
// end ;
3930: GO 3854
3932: POP
3933: POP
// repeat wait ( 0 0$1 ) ;
3934: LD_INT 35
3936: PPUSH
3937: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3941: LD_VAR 0 6
3945: PPUSH
3946: LD_INT 60
3948: PUSH
3949: EMPTY
3950: LIST
3951: PPUSH
3952: CALL_OW 72
3956: NOT
3957: IFFALSE 3934
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3959: LD_VAR 0 2
3963: PPUSH
3964: LD_VAR 0 6
3968: PPUSH
3969: LD_VAR 0 5
3973: PPUSH
3974: LD_VAR 0 4
3978: PPUSH
3979: CALL 80796 0 4
// if not first_attack then
3983: LD_EXP 7
3987: NOT
3988: IFFALSE 3998
// first_attack := true ;
3990: LD_ADDR_EXP 7
3994: PUSH
3995: LD_INT 1
3997: ST_TO_ADDR
// end ; end_of_file
3998: PPOPN 7
4000: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4001: LD_INT 0
4003: PPUSH
4004: PPUSH
4005: PPUSH
4006: PPUSH
4007: PPUSH
4008: PPUSH
4009: PPUSH
// uc_side := 2 ;
4010: LD_ADDR_OWVAR 20
4014: PUSH
4015: LD_INT 2
4017: ST_TO_ADDR
// uc_nation := 2 ;
4018: LD_ADDR_OWVAR 21
4022: PUSH
4023: LD_INT 2
4025: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4026: LD_ADDR_EXP 57
4030: PUSH
4031: LD_STRING Abdul
4033: PPUSH
4034: CALL_OW 25
4038: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4039: LD_EXP 57
4043: PPUSH
4044: LD_INT 11
4046: PPUSH
4047: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4051: LD_EXP 57
4055: PPUSH
4056: LD_INT 1
4058: PPUSH
4059: CALL_OW 52
// vc_chassis := 31 ;
4063: LD_ADDR_OWVAR 37
4067: PUSH
4068: LD_INT 31
4070: ST_TO_ADDR
// vc_control := control_rider ;
4071: LD_ADDR_OWVAR 38
4075: PUSH
4076: LD_INT 4
4078: ST_TO_ADDR
// mastodont := CreateVehicle ;
4079: LD_ADDR_EXP 58
4083: PUSH
4084: CALL_OW 45
4088: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4089: LD_EXP 58
4093: PPUSH
4094: LD_INT 153
4096: PPUSH
4097: LD_INT 71
4099: PPUSH
4100: LD_INT 0
4102: PPUSH
4103: CALL_OW 48
// InitVc ;
4107: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4111: LD_ADDR_EXP 55
4115: PUSH
4116: LD_INT 1
4118: PPUSH
4119: LD_INT 3
4121: PPUSH
4122: LD_STRING 
4124: PPUSH
4125: LD_INT 7
4127: PUSH
4128: LD_INT 8
4130: PUSH
4131: LD_INT 9
4133: PUSH
4134: LD_INT 10
4136: PUSH
4137: EMPTY
4138: LIST
4139: LIST
4140: LIST
4141: LIST
4142: PUSH
4143: LD_OWVAR 67
4147: ARRAY
4148: PPUSH
4149: LD_INT 5000
4151: PUSH
4152: LD_INT 1000
4154: PUSH
4155: LD_INT 300
4157: PUSH
4158: EMPTY
4159: LIST
4160: LIST
4161: LIST
4162: PPUSH
4163: LD_INT 18
4165: PUSH
4166: LD_INT 5
4168: PUSH
4169: LD_INT 6
4171: PUSH
4172: LD_INT 9
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: LIST
4180: PPUSH
4181: CALL 23392 0 6
4185: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4186: LD_ADDR_EXP 61
4190: PUSH
4191: LD_EXP 61
4195: PPUSH
4196: LD_INT 1
4198: PPUSH
4199: LD_EXP 55
4203: PPUSH
4204: CALL_OW 1
4208: ST_TO_ADDR
// tmp := [ ] ;
4209: LD_ADDR_VAR 0 4
4213: PUSH
4214: EMPTY
4215: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4216: LD_ADDR_OWVAR 37
4220: PUSH
4221: LD_INT 14
4223: ST_TO_ADDR
// vc_engine := engine_siberite ;
4224: LD_ADDR_OWVAR 39
4228: PUSH
4229: LD_INT 3
4231: ST_TO_ADDR
// vc_control := control_manual ;
4232: LD_ADDR_OWVAR 38
4236: PUSH
4237: LD_INT 1
4239: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4240: LD_ADDR_OWVAR 40
4244: PUSH
4245: LD_INT 31
4247: ST_TO_ADDR
// for i = 1 to 3 do
4248: LD_ADDR_VAR 0 2
4252: PUSH
4253: DOUBLE
4254: LD_INT 1
4256: DEC
4257: ST_TO_ADDR
4258: LD_INT 3
4260: PUSH
4261: FOR_TO
4262: IFFALSE 4510
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4264: LD_ADDR_VAR 0 5
4268: PUSH
4269: LD_INT 153
4271: PUSH
4272: LD_INT 71
4274: PUSH
4275: EMPTY
4276: LIST
4277: LIST
4278: PUSH
4279: LD_INT 155
4281: PUSH
4282: LD_INT 81
4284: PUSH
4285: EMPTY
4286: LIST
4287: LIST
4288: PUSH
4289: EMPTY
4290: LIST
4291: LIST
4292: PUSH
4293: LD_VAR 0 2
4297: PUSH
4298: LD_INT 2
4300: MOD
4301: PUSH
4302: LD_INT 1
4304: PLUS
4305: ARRAY
4306: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4307: LD_INT 0
4309: PPUSH
4310: LD_INT 3
4312: PPUSH
4313: LD_INT 7
4315: PUSH
4316: LD_INT 8
4318: PUSH
4319: LD_INT 10
4321: PUSH
4322: LD_INT 10
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: LIST
4330: PUSH
4331: LD_OWVAR 67
4335: ARRAY
4336: PPUSH
4337: CALL_OW 380
// un := CreateVehicle ;
4341: LD_ADDR_VAR 0 6
4345: PUSH
4346: CALL_OW 45
4350: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4351: LD_VAR 0 6
4355: PPUSH
4356: LD_INT 0
4358: PPUSH
4359: LD_INT 5
4361: PPUSH
4362: CALL_OW 12
4366: PPUSH
4367: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4371: LD_VAR 0 6
4375: PPUSH
4376: LD_VAR 0 5
4380: PUSH
4381: LD_INT 1
4383: ARRAY
4384: PPUSH
4385: LD_VAR 0 5
4389: PUSH
4390: LD_INT 2
4392: ARRAY
4393: PPUSH
4394: LD_INT 6
4396: PPUSH
4397: LD_INT 0
4399: PPUSH
4400: CALL_OW 50
// un2 := CreateHuman ;
4404: LD_ADDR_VAR 0 7
4408: PUSH
4409: CALL_OW 44
4413: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4414: LD_VAR 0 7
4418: PPUSH
4419: LD_VAR 0 6
4423: PPUSH
4424: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4428: LD_ADDR_EXP 61
4432: PUSH
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 1
4440: PUSH
4441: LD_EXP 61
4445: PUSH
4446: LD_INT 1
4448: ARRAY
4449: PUSH
4450: LD_INT 1
4452: PLUS
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: PPUSH
4458: LD_VAR 0 6
4462: PPUSH
4463: CALL 20070 0 3
4467: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4468: LD_ADDR_EXP 61
4472: PUSH
4473: LD_EXP 61
4477: PPUSH
4478: LD_INT 1
4480: PUSH
4481: LD_EXP 61
4485: PUSH
4486: LD_INT 1
4488: ARRAY
4489: PUSH
4490: LD_INT 1
4492: PLUS
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PPUSH
4498: LD_VAR 0 7
4502: PPUSH
4503: CALL 20070 0 3
4507: ST_TO_ADDR
// end ;
4508: GO 4261
4510: POP
4511: POP
// for i = 1 to 5 do
4512: LD_ADDR_VAR 0 2
4516: PUSH
4517: DOUBLE
4518: LD_INT 1
4520: DEC
4521: ST_TO_ADDR
4522: LD_INT 5
4524: PUSH
4525: FOR_TO
4526: IFFALSE 4619
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4528: LD_INT 14
4530: PPUSH
4531: LD_INT 3
4533: PPUSH
4534: LD_INT 1
4536: PPUSH
4537: LD_INT 25
4539: PUSH
4540: LD_INT 28
4542: PUSH
4543: LD_INT 28
4545: PUSH
4546: LD_INT 26
4548: PUSH
4549: EMPTY
4550: LIST
4551: LIST
4552: LIST
4553: LIST
4554: PUSH
4555: LD_VAR 0 2
4559: PUSH
4560: LD_INT 4
4562: MOD
4563: PUSH
4564: LD_INT 1
4566: PLUS
4567: ARRAY
4568: PPUSH
4569: LD_INT 100
4571: PPUSH
4572: CALL 19948 0 5
// veh := CreateVehicle ;
4576: LD_ADDR_VAR 0 3
4580: PUSH
4581: CALL_OW 45
4585: ST_TO_ADDR
// tmp := tmp ^ veh ;
4586: LD_ADDR_VAR 0 4
4590: PUSH
4591: LD_VAR 0 4
4595: PUSH
4596: LD_VAR 0 3
4600: ADD
4601: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4602: LD_VAR 0 3
4606: PPUSH
4607: LD_INT 1
4609: PPUSH
4610: LD_INT 0
4612: PPUSH
4613: CALL_OW 49
// end ;
4617: GO 4525
4619: POP
4620: POP
// arabian_guard := tmp ;
4621: LD_ADDR_EXP 56
4625: PUSH
4626: LD_VAR 0 4
4630: ST_TO_ADDR
// end ;
4631: LD_VAR 0 1
4635: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4636: LD_INT 22
4638: PUSH
4639: LD_INT 7
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PUSH
4646: LD_INT 91
4648: PUSH
4649: LD_INT 1
4651: PUSH
4652: LD_INT 12
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: PUSH
4660: EMPTY
4661: LIST
4662: LIST
4663: PPUSH
4664: CALL_OW 69
4668: PUSH
4669: LD_EXP 58
4673: PPUSH
4674: CALL_OW 256
4678: PUSH
4679: LD_INT 990
4681: LESS
4682: OR
4683: PUSH
4684: LD_EXP 57
4688: PPUSH
4689: CALL_OW 256
4693: PUSH
4694: LD_INT 990
4696: LESS
4697: OR
4698: IFFALSE 4841
4700: GO 4702
4702: DISABLE
// begin if IsInUnit ( Abdul ) then
4703: LD_EXP 57
4707: PPUSH
4708: CALL_OW 310
4712: IFFALSE 4723
// ComExitBuilding ( Abdul ) ;
4714: LD_EXP 57
4718: PPUSH
4719: CALL_OW 122
// if Mastodont then
4723: LD_EXP 58
4727: IFFALSE 4744
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4729: LD_EXP 58
4733: PPUSH
4734: LD_INT 205
4736: PPUSH
4737: LD_INT 132
4739: PPUSH
4740: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4744: LD_EXP 57
4748: PPUSH
4749: LD_INT 205
4751: PPUSH
4752: LD_INT 132
4754: PPUSH
4755: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4759: LD_INT 35
4761: PPUSH
4762: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4766: LD_EXP 57
4770: PPUSH
4771: LD_INT 21
4773: PPUSH
4774: CALL_OW 308
4778: IFFALSE 4759
// RemoveUnit ( Abdul ) ;
4780: LD_EXP 57
4784: PPUSH
4785: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4789: LD_INT 35
4791: PPUSH
4792: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4796: LD_EXP 58
4800: PPUSH
4801: LD_INT 21
4803: PPUSH
4804: CALL_OW 308
4808: PUSH
4809: LD_EXP 58
4813: PPUSH
4814: CALL_OW 301
4818: OR
4819: IFFALSE 4789
// if IsOk ( Mastodont ) then
4821: LD_EXP 58
4825: PPUSH
4826: CALL_OW 302
4830: IFFALSE 4841
// RemoveUnit ( Mastodont ) ;
4832: LD_EXP 58
4836: PPUSH
4837: CALL_OW 64
// end ;
4841: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4842: LD_EXP 57
4846: PPUSH
4847: CALL_OW 301
4851: PUSH
4852: LD_INT 22
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 2
4864: PUSH
4865: LD_INT 25
4867: PUSH
4868: LD_INT 1
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: LD_INT 25
4877: PUSH
4878: LD_INT 2
4880: PUSH
4881: EMPTY
4882: LIST
4883: LIST
4884: PUSH
4885: LD_INT 25
4887: PUSH
4888: LD_INT 3
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PUSH
4895: LD_INT 25
4897: PUSH
4898: LD_INT 4
4900: PUSH
4901: EMPTY
4902: LIST
4903: LIST
4904: PUSH
4905: LD_INT 25
4907: PUSH
4908: LD_INT 8
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: LIST
4919: LIST
4920: LIST
4921: LIST
4922: PUSH
4923: EMPTY
4924: LIST
4925: LIST
4926: PPUSH
4927: CALL_OW 69
4931: PUSH
4932: LD_INT 16
4934: PUSH
4935: LD_INT 19
4937: PUSH
4938: LD_INT 22
4940: PUSH
4941: LD_INT 22
4943: PUSH
4944: EMPTY
4945: LIST
4946: LIST
4947: LIST
4948: LIST
4949: PUSH
4950: LD_OWVAR 67
4954: ARRAY
4955: LESS
4956: OR
4957: IFFALSE 5630
4959: GO 4961
4961: DISABLE
4962: LD_INT 0
4964: PPUSH
4965: PPUSH
4966: PPUSH
4967: PPUSH
4968: PPUSH
4969: PPUSH
// begin MC_Kill ( 1 ) ;
4970: LD_INT 1
4972: PPUSH
4973: CALL 56584 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4977: LD_ADDR_VAR 0 2
4981: PUSH
4982: LD_INT 22
4984: PUSH
4985: LD_INT 2
4987: PUSH
4988: EMPTY
4989: LIST
4990: LIST
4991: PUSH
4992: LD_INT 2
4994: PUSH
4995: LD_INT 25
4997: PUSH
4998: LD_INT 1
5000: PUSH
5001: EMPTY
5002: LIST
5003: LIST
5004: PUSH
5005: LD_INT 25
5007: PUSH
5008: LD_INT 2
5010: PUSH
5011: EMPTY
5012: LIST
5013: LIST
5014: PUSH
5015: LD_INT 25
5017: PUSH
5018: LD_INT 3
5020: PUSH
5021: EMPTY
5022: LIST
5023: LIST
5024: PUSH
5025: LD_INT 25
5027: PUSH
5028: LD_INT 4
5030: PUSH
5031: EMPTY
5032: LIST
5033: LIST
5034: PUSH
5035: LD_INT 25
5037: PUSH
5038: LD_INT 8
5040: PUSH
5041: EMPTY
5042: LIST
5043: LIST
5044: PUSH
5045: EMPTY
5046: LIST
5047: LIST
5048: LIST
5049: LIST
5050: LIST
5051: LIST
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 69
5061: ST_TO_ADDR
// for i in tmp do
5062: LD_ADDR_VAR 0 5
5066: PUSH
5067: LD_VAR 0 2
5071: PUSH
5072: FOR_IN
5073: IFFALSE 5089
// SetTag ( i , 10 ) ;
5075: LD_VAR 0 5
5079: PPUSH
5080: LD_INT 10
5082: PPUSH
5083: CALL_OW 109
5087: GO 5072
5089: POP
5090: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5091: LD_ADDR_VAR 0 3
5095: PUSH
5096: LD_INT 22
5098: PUSH
5099: LD_INT 2
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 21
5108: PUSH
5109: LD_INT 1
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: PUSH
5125: LD_VAR 0 2
5129: DIFF
5130: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5131: LD_ADDR_VAR 0 1
5135: PUSH
5136: LD_INT 22
5138: PUSH
5139: LD_INT 2
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: PUSH
5146: LD_INT 21
5148: PUSH
5149: LD_INT 2
5151: PUSH
5152: EMPTY
5153: LIST
5154: LIST
5155: PUSH
5156: LD_INT 24
5158: PUSH
5159: LD_INT 300
5161: PUSH
5162: EMPTY
5163: LIST
5164: LIST
5165: PUSH
5166: EMPTY
5167: LIST
5168: LIST
5169: LIST
5170: PPUSH
5171: CALL_OW 69
5175: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5176: LD_ADDR_VAR 0 4
5180: PUSH
5181: LD_VAR 0 1
5185: PPUSH
5186: LD_INT 33
5188: PUSH
5189: LD_INT 1
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 58
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// for i in tmp do
5211: LD_ADDR_VAR 0 5
5215: PUSH
5216: LD_VAR 0 2
5220: PUSH
5221: FOR_IN
5222: IFFALSE 5406
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5224: LD_VAR 0 5
5228: PUSH
5229: LD_INT 55
5231: PUSH
5232: EMPTY
5233: LIST
5234: PPUSH
5235: CALL_OW 69
5239: IN
5240: IFFALSE 5259
// begin AddComMoveXY ( i , 209 , 132 ) ;
5242: LD_VAR 0 5
5246: PPUSH
5247: LD_INT 209
5249: PPUSH
5250: LD_INT 132
5252: PPUSH
5253: CALL_OW 171
// continue ;
5257: GO 5221
// end ; if IsInUnit ( i ) then
5259: LD_VAR 0 5
5263: PPUSH
5264: CALL_OW 310
5268: IFFALSE 5286
// begin ComExitBuilding ( i ) ;
5270: LD_VAR 0 5
5274: PPUSH
5275: CALL_OW 122
// wait ( 3 ) ;
5279: LD_INT 3
5281: PPUSH
5282: CALL_OW 67
// end ; if tmp_empty then
5286: LD_VAR 0 4
5290: IFFALSE 5389
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5292: LD_VAR 0 5
5296: PPUSH
5297: LD_VAR 0 4
5301: PPUSH
5302: LD_VAR 0 5
5306: PPUSH
5307: CALL_OW 74
5311: PPUSH
5312: CALL_OW 296
5316: PUSH
5317: LD_INT 25
5319: LESS
5320: IFFALSE 5389
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5322: LD_ADDR_VAR 0 6
5326: PUSH
5327: LD_VAR 0 4
5331: PPUSH
5332: LD_VAR 0 5
5336: PPUSH
5337: CALL_OW 74
5341: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5342: LD_VAR 0 5
5346: PPUSH
5347: LD_VAR 0 6
5351: PPUSH
5352: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5356: LD_VAR 0 5
5360: PPUSH
5361: LD_INT 209
5363: PPUSH
5364: LD_INT 132
5366: PPUSH
5367: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5371: LD_ADDR_VAR 0 4
5375: PUSH
5376: LD_VAR 0 4
5380: PUSH
5381: LD_VAR 0 6
5385: DIFF
5386: ST_TO_ADDR
// continue ;
5387: GO 5221
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5389: LD_VAR 0 5
5393: PPUSH
5394: LD_INT 201
5396: PPUSH
5397: LD_INT 132
5399: PPUSH
5400: CALL_OW 171
// end ;
5404: GO 5221
5406: POP
5407: POP
// for i in tmp_ape do
5408: LD_ADDR_VAR 0 5
5412: PUSH
5413: LD_VAR 0 3
5417: PUSH
5418: FOR_IN
5419: IFFALSE 5458
// begin if IsInUnit ( i ) then
5421: LD_VAR 0 5
5425: PPUSH
5426: CALL_OW 310
5430: IFFALSE 5441
// ComExitBuilding ( i ) ;
5432: LD_VAR 0 5
5436: PPUSH
5437: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5441: LD_VAR 0 5
5445: PPUSH
5446: LD_INT 201
5448: PPUSH
5449: LD_INT 132
5451: PPUSH
5452: CALL_OW 171
// end ;
5456: GO 5418
5458: POP
5459: POP
// repeat wait ( 0 0$1 ) ;
5460: LD_INT 35
5462: PPUSH
5463: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5467: LD_ADDR_VAR 0 5
5471: PUSH
5472: LD_VAR 0 2
5476: PUSH
5477: LD_VAR 0 3
5481: UNION
5482: PUSH
5483: LD_VAR 0 1
5487: UNION
5488: PUSH
5489: FOR_IN
5490: IFFALSE 5521
// if not HasTask ( i ) then
5492: LD_VAR 0 5
5496: PPUSH
5497: CALL_OW 314
5501: NOT
5502: IFFALSE 5519
// ComMoveXY ( i , 201 , 132 ) ;
5504: LD_VAR 0 5
5508: PPUSH
5509: LD_INT 201
5511: PPUSH
5512: LD_INT 132
5514: PPUSH
5515: CALL_OW 111
5519: GO 5489
5521: POP
5522: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5523: LD_INT 21
5525: PPUSH
5526: LD_INT 22
5528: PUSH
5529: LD_INT 2
5531: PUSH
5532: EMPTY
5533: LIST
5534: LIST
5535: PPUSH
5536: CALL_OW 70
5540: IFFALSE 5581
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5542: LD_ADDR_VAR 0 5
5546: PUSH
5547: LD_INT 21
5549: PPUSH
5550: LD_INT 22
5552: PUSH
5553: LD_INT 2
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PPUSH
5560: CALL_OW 70
5564: PUSH
5565: FOR_IN
5566: IFFALSE 5579
// RemoveUnit ( i ) ;
5568: LD_VAR 0 5
5572: PPUSH
5573: CALL_OW 64
5577: GO 5565
5579: POP
5580: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5581: LD_INT 22
5583: PUSH
5584: LD_INT 2
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 21
5596: PUSH
5597: LD_INT 1
5599: PUSH
5600: EMPTY
5601: LIST
5602: LIST
5603: PUSH
5604: LD_INT 21
5606: PUSH
5607: LD_INT 2
5609: PUSH
5610: EMPTY
5611: LIST
5612: LIST
5613: PUSH
5614: EMPTY
5615: LIST
5616: LIST
5617: LIST
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: PPUSH
5623: CALL_OW 69
5627: NOT
5628: IFFALSE 5460
// end ;
5630: PPOPN 6
5632: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5633: LD_EXP 9
5637: PUSH
5638: LD_INT 92
5640: PPUSH
5641: LD_INT 40
5643: PPUSH
5644: CALL_OW 428
5648: PPUSH
5649: CALL_OW 266
5653: PUSH
5654: LD_INT 30
5656: EQUAL
5657: AND
5658: IFFALSE 5854
5660: GO 5662
5662: DISABLE
5663: LD_INT 0
5665: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5666: LD_ADDR_VAR 0 1
5670: PUSH
5671: LD_EXP 61
5675: PUSH
5676: LD_INT 1
5678: ARRAY
5679: PPUSH
5680: LD_INT 25
5682: PUSH
5683: LD_INT 4
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: PPUSH
5690: CALL_OW 72
5694: ST_TO_ADDR
// if not sci then
5695: LD_VAR 0 1
5699: NOT
5700: IFFALSE 5704
// exit ;
5702: GO 5854
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5704: LD_ADDR_EXP 61
5708: PUSH
5709: LD_EXP 61
5713: PPUSH
5714: LD_INT 1
5716: PPUSH
5717: LD_EXP 61
5721: PUSH
5722: LD_INT 1
5724: ARRAY
5725: PUSH
5726: LD_VAR 0 1
5730: PUSH
5731: LD_INT 1
5733: ARRAY
5734: DIFF
5735: PPUSH
5736: CALL_OW 1
5740: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5741: LD_VAR 0 1
5745: PUSH
5746: LD_INT 1
5748: ARRAY
5749: PPUSH
5750: CALL_OW 310
5754: IFFALSE 5769
// ComExitBuilding ( sci [ 1 ] ) ;
5756: LD_VAR 0 1
5760: PUSH
5761: LD_INT 1
5763: ARRAY
5764: PPUSH
5765: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5769: LD_INT 2
5771: PPUSH
5772: LD_INT 105
5774: PPUSH
5775: LD_INT 14
5777: PPUSH
5778: LD_INT 20
5780: PPUSH
5781: CALL 20966 0 4
5785: PUSH
5786: LD_INT 4
5788: ARRAY
5789: PUSH
5790: LD_INT 10
5792: LESS
5793: IFFALSE 5816
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5795: LD_VAR 0 1
5799: PUSH
5800: LD_INT 1
5802: ARRAY
5803: PPUSH
5804: LD_INT 105
5806: PPUSH
5807: LD_INT 14
5809: PPUSH
5810: CALL_OW 171
5814: GO 5835
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5816: LD_VAR 0 1
5820: PUSH
5821: LD_INT 1
5823: ARRAY
5824: PPUSH
5825: LD_INT 118
5827: PPUSH
5828: LD_INT 77
5830: PPUSH
5831: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5835: LD_VAR 0 1
5839: PUSH
5840: LD_INT 1
5842: ARRAY
5843: PPUSH
5844: LD_INT 92
5846: PPUSH
5847: LD_INT 40
5849: PPUSH
5850: CALL_OW 218
// end ;
5854: PPOPN 1
5856: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5857: LD_INT 1
5859: PPUSH
5860: CALL_OW 302
5864: PUSH
5865: LD_EXP 9
5869: AND
5870: IFFALSE 6347
5872: GO 5874
5874: DISABLE
5875: LD_INT 0
5877: PPUSH
5878: PPUSH
5879: PPUSH
5880: PPUSH
5881: PPUSH
5882: PPUSH
// begin enable ;
5883: ENABLE
// base := 1 ;
5884: LD_ADDR_VAR 0 2
5888: PUSH
5889: LD_INT 1
5891: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5892: LD_ADDR_VAR 0 4
5896: PUSH
5897: LD_INT 0
5899: PUSH
5900: LD_INT 0
5902: PUSH
5903: LD_INT 0
5905: PUSH
5906: LD_INT 0
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: LD_INT 0
5914: PUSH
5915: LD_INT 0
5917: PUSH
5918: LD_INT 0
5920: PUSH
5921: LD_INT 1
5923: PUSH
5924: LD_INT 0
5926: PUSH
5927: EMPTY
5928: LIST
5929: LIST
5930: LIST
5931: LIST
5932: LIST
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5939: LD_ADDR_VAR 0 3
5943: PUSH
5944: LD_INT 14
5946: PUSH
5947: LD_INT 1
5949: PUSH
5950: LD_INT 2
5952: PUSH
5953: LD_INT 26
5955: PUSH
5956: EMPTY
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: PUSH
5962: LD_INT 14
5964: PUSH
5965: LD_INT 1
5967: PUSH
5968: LD_INT 2
5970: PUSH
5971: LD_INT 28
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: PUSH
5980: LD_INT 13
5982: PUSH
5983: LD_INT 1
5985: PUSH
5986: LD_INT 2
5988: PUSH
5989: LD_INT 29
5991: PUSH
5992: EMPTY
5993: LIST
5994: LIST
5995: LIST
5996: LIST
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6003: LD_ADDR_VAR 0 1
6007: PUSH
6008: DOUBLE
6009: LD_INT 1
6011: DEC
6012: ST_TO_ADDR
6013: LD_OWVAR 67
6017: PUSH
6018: LD_OWVAR 1
6022: PUSH
6023: LD_INT 21000
6025: DIV
6026: PLUS
6027: PUSH
6028: FOR_TO
6029: IFFALSE 6121
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6031: LD_ADDR_VAR 0 3
6035: PUSH
6036: LD_VAR 0 3
6040: PPUSH
6041: LD_VAR 0 3
6045: PUSH
6046: LD_INT 1
6048: PLUS
6049: PPUSH
6050: LD_INT 13
6052: PUSH
6053: LD_INT 14
6055: PUSH
6056: EMPTY
6057: LIST
6058: LIST
6059: PUSH
6060: LD_INT 1
6062: PPUSH
6063: LD_INT 2
6065: PPUSH
6066: CALL_OW 12
6070: ARRAY
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: LD_INT 2
6077: PUSH
6078: LD_INT 28
6080: PUSH
6081: LD_INT 29
6083: PUSH
6084: LD_INT 25
6086: PUSH
6087: LD_INT 26
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 1
6098: PPUSH
6099: LD_INT 4
6101: PPUSH
6102: CALL_OW 12
6106: ARRAY
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: PPUSH
6114: CALL_OW 2
6118: ST_TO_ADDR
6119: GO 6028
6121: POP
6122: POP
// MC_InsertProduceList ( base , tmp ) ;
6123: LD_VAR 0 2
6127: PPUSH
6128: LD_VAR 0 3
6132: PPUSH
6133: CALL 80611 0 2
// repeat wait ( 0 0$1 ) ;
6137: LD_INT 35
6139: PPUSH
6140: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6144: LD_EXP 80
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PUSH
6155: LD_INT 6
6157: GREATER
6158: IFFALSE 6137
// wait ( 0 0$20 ) ;
6160: LD_INT 700
6162: PPUSH
6163: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6167: LD_ADDR_VAR 0 5
6171: PUSH
6172: LD_INT 124
6174: PUSH
6175: LD_INT 85
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: PUSH
6182: LD_INT 90
6184: PUSH
6185: LD_INT 61
6187: PUSH
6188: EMPTY
6189: LIST
6190: LIST
6191: PUSH
6192: LD_INT 69
6194: PUSH
6195: LD_INT 48
6197: PUSH
6198: EMPTY
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 68
6204: PUSH
6205: LD_INT 48
6207: PUSH
6208: EMPTY
6209: LIST
6210: LIST
6211: PUSH
6212: EMPTY
6213: LIST
6214: LIST
6215: LIST
6216: LIST
6217: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6218: LD_ADDR_VAR 0 6
6222: PUSH
6223: LD_EXP 80
6227: PUSH
6228: LD_VAR 0 2
6232: ARRAY
6233: PUSH
6234: LD_EXP 80
6238: PUSH
6239: LD_VAR 0 2
6243: ARRAY
6244: PPUSH
6245: LD_INT 2
6247: PUSH
6248: LD_INT 34
6250: PUSH
6251: LD_INT 32
6253: PUSH
6254: EMPTY
6255: LIST
6256: LIST
6257: PUSH
6258: LD_INT 34
6260: PUSH
6261: LD_INT 88
6263: PUSH
6264: EMPTY
6265: LIST
6266: LIST
6267: PUSH
6268: EMPTY
6269: LIST
6270: LIST
6271: LIST
6272: PPUSH
6273: CALL_OW 72
6277: DIFF
6278: ST_TO_ADDR
// if not attackers then
6279: LD_VAR 0 6
6283: NOT
6284: IFFALSE 6288
// exit ;
6286: GO 6347
// ar_attackers := attackers ;
6288: LD_ADDR_EXP 11
6292: PUSH
6293: LD_VAR 0 6
6297: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6298: LD_INT 35
6300: PPUSH
6301: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6305: LD_VAR 0 6
6309: PPUSH
6310: LD_INT 60
6312: PUSH
6313: EMPTY
6314: LIST
6315: PPUSH
6316: CALL_OW 72
6320: NOT
6321: IFFALSE 6298
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6323: LD_VAR 0 2
6327: PPUSH
6328: LD_VAR 0 6
6332: PPUSH
6333: LD_VAR 0 5
6337: PPUSH
6338: LD_VAR 0 4
6342: PPUSH
6343: CALL 80796 0 4
// end ;
6347: PPOPN 6
6349: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6350: LD_INT 1
6352: PPUSH
6353: CALL_OW 302
6357: PUSH
6358: LD_EXP 9
6362: AND
6363: PUSH
6364: LD_EXP 51
6368: PPUSH
6369: LD_INT 22
6371: PPUSH
6372: CALL_OW 308
6376: AND
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: CALL 80959 0 1
6385: PUSH
6386: LD_INT 0
6388: EQUAL
6389: AND
6390: PUSH
6391: LD_EXP 11
6395: NOT
6396: AND
6397: IFFALSE 6883
6399: GO 6401
6401: DISABLE
6402: LD_INT 0
6404: PPUSH
6405: PPUSH
6406: PPUSH
6407: PPUSH
6408: PPUSH
6409: PPUSH
6410: PPUSH
// begin base := 1 ;
6411: LD_ADDR_VAR 0 2
6415: PUSH
6416: LD_INT 1
6418: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6419: LD_ADDR_VAR 0 4
6423: PUSH
6424: LD_INT 0
6426: PUSH
6427: LD_INT 0
6429: PUSH
6430: LD_INT 0
6432: PUSH
6433: LD_INT 0
6435: PUSH
6436: LD_INT 0
6438: PUSH
6439: LD_INT 0
6441: PUSH
6442: LD_INT 0
6444: PUSH
6445: LD_INT 0
6447: PUSH
6448: LD_INT 1
6450: PUSH
6451: LD_INT 0
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: LIST
6458: LIST
6459: LIST
6460: LIST
6461: LIST
6462: LIST
6463: LIST
6464: LIST
6465: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6466: LD_ADDR_VAR 0 3
6470: PUSH
6471: LD_INT 13
6473: PUSH
6474: LD_INT 1
6476: PUSH
6477: LD_INT 2
6479: PUSH
6480: LD_INT 28
6482: PUSH
6483: EMPTY
6484: LIST
6485: LIST
6486: LIST
6487: LIST
6488: PUSH
6489: LD_INT 13
6491: PUSH
6492: LD_INT 1
6494: PUSH
6495: LD_INT 2
6497: PUSH
6498: LD_INT 27
6500: PUSH
6501: EMPTY
6502: LIST
6503: LIST
6504: LIST
6505: LIST
6506: PUSH
6507: LD_INT 13
6509: PUSH
6510: LD_INT 1
6512: PUSH
6513: LD_INT 2
6515: PUSH
6516: LD_INT 25
6518: PUSH
6519: EMPTY
6520: LIST
6521: LIST
6522: LIST
6523: LIST
6524: PUSH
6525: LD_INT 11
6527: PUSH
6528: LD_INT 2
6530: PUSH
6531: LD_INT 2
6533: PUSH
6534: LD_INT 24
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: LIST
6541: LIST
6542: PUSH
6543: LD_INT 11
6545: PUSH
6546: LD_INT 2
6548: PUSH
6549: LD_INT 2
6551: PUSH
6552: LD_INT 24
6554: PUSH
6555: EMPTY
6556: LIST
6557: LIST
6558: LIST
6559: LIST
6560: PUSH
6561: EMPTY
6562: LIST
6563: LIST
6564: LIST
6565: LIST
6566: LIST
6567: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6568: LD_VAR 0 2
6572: PPUSH
6573: LD_VAR 0 3
6577: PPUSH
6578: CALL 80611 0 2
// repeat wait ( 0 0$1 ) ;
6582: LD_INT 35
6584: PPUSH
6585: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6589: LD_EXP 80
6593: PUSH
6594: LD_VAR 0 2
6598: ARRAY
6599: PUSH
6600: LD_INT 6
6602: GREATEREQUAL
6603: IFFALSE 6582
// wait ( 0 0$20 ) ;
6605: LD_INT 700
6607: PPUSH
6608: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6612: LD_ADDR_VAR 0 5
6616: PUSH
6617: LD_INT 119
6619: PUSH
6620: LD_INT 9
6622: PUSH
6623: EMPTY
6624: LIST
6625: LIST
6626: PUSH
6627: EMPTY
6628: LIST
6629: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6630: LD_ADDR_VAR 0 6
6634: PUSH
6635: LD_EXP 80
6639: PUSH
6640: LD_VAR 0 2
6644: ARRAY
6645: PUSH
6646: LD_EXP 80
6650: PUSH
6651: LD_VAR 0 2
6655: ARRAY
6656: PPUSH
6657: LD_INT 2
6659: PUSH
6660: LD_INT 34
6662: PUSH
6663: LD_INT 32
6665: PUSH
6666: EMPTY
6667: LIST
6668: LIST
6669: PUSH
6670: LD_INT 34
6672: PUSH
6673: LD_INT 88
6675: PUSH
6676: EMPTY
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: LIST
6684: PPUSH
6685: CALL_OW 72
6689: DIFF
6690: ST_TO_ADDR
// if not attackers then
6691: LD_VAR 0 6
6695: NOT
6696: IFFALSE 6700
// exit ;
6698: GO 6883
// uc_side := 2 ;
6700: LD_ADDR_OWVAR 20
6704: PUSH
6705: LD_INT 2
6707: ST_TO_ADDR
// uc_nation := 2 ;
6708: LD_ADDR_OWVAR 21
6712: PUSH
6713: LD_INT 2
6715: ST_TO_ADDR
// InitHc ;
6716: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6720: LD_ADDR_VAR 0 1
6724: PUSH
6725: DOUBLE
6726: LD_INT 1
6728: DEC
6729: ST_TO_ADDR
6730: LD_INT 4
6732: PUSH
6733: LD_INT 5
6735: PUSH
6736: LD_INT 6
6738: PUSH
6739: LD_INT 6
6741: PUSH
6742: EMPTY
6743: LIST
6744: LIST
6745: LIST
6746: LIST
6747: PUSH
6748: LD_OWVAR 67
6752: ARRAY
6753: PUSH
6754: FOR_TO
6755: IFFALSE 6832
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6757: LD_INT 0
6759: PPUSH
6760: LD_INT 15
6762: PUSH
6763: LD_INT 17
6765: PUSH
6766: EMPTY
6767: LIST
6768: LIST
6769: PUSH
6770: LD_INT 1
6772: PPUSH
6773: LD_INT 2
6775: PPUSH
6776: CALL_OW 12
6780: ARRAY
6781: PPUSH
6782: LD_INT 8
6784: PPUSH
6785: CALL_OW 380
// un := CreateHuman ;
6789: LD_ADDR_VAR 0 7
6793: PUSH
6794: CALL_OW 44
6798: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6799: LD_VAR 0 7
6803: PPUSH
6804: LD_INT 23
6806: PPUSH
6807: LD_INT 0
6809: PPUSH
6810: CALL_OW 49
// attackers := attackers union un ;
6814: LD_ADDR_VAR 0 6
6818: PUSH
6819: LD_VAR 0 6
6823: PUSH
6824: LD_VAR 0 7
6828: UNION
6829: ST_TO_ADDR
// end ;
6830: GO 6754
6832: POP
6833: POP
// repeat wait ( 0 0$1 ) ;
6834: LD_INT 35
6836: PPUSH
6837: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6841: LD_VAR 0 6
6845: PPUSH
6846: LD_INT 60
6848: PUSH
6849: EMPTY
6850: LIST
6851: PPUSH
6852: CALL_OW 72
6856: NOT
6857: IFFALSE 6834
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6859: LD_VAR 0 2
6863: PPUSH
6864: LD_VAR 0 6
6868: PPUSH
6869: LD_VAR 0 5
6873: PPUSH
6874: LD_VAR 0 4
6878: PPUSH
6879: CALL 80796 0 4
// end ; end_of_file
6883: PPOPN 7
6885: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6886: LD_INT 0
6888: PPUSH
6889: PPUSH
6890: PPUSH
6891: PPUSH
6892: PPUSH
6893: PPUSH
// uc_side := 1 ;
6894: LD_ADDR_OWVAR 20
6898: PUSH
6899: LD_INT 1
6901: ST_TO_ADDR
// uc_nation := 1 ;
6902: LD_ADDR_OWVAR 21
6906: PUSH
6907: LD_INT 1
6909: ST_TO_ADDR
// InitHc ;
6910: CALL_OW 19
// InitVc ;
6914: CALL_OW 20
// tmp := [ ] ;
6918: LD_ADDR_VAR 0 3
6922: PUSH
6923: EMPTY
6924: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6925: LD_ADDR_VAR 0 2
6929: PUSH
6930: DOUBLE
6931: LD_INT 1
6933: DEC
6934: ST_TO_ADDR
6935: LD_INT 6
6937: PUSH
6938: LD_INT 8
6940: PUSH
6941: LD_INT 10
6943: PUSH
6944: LD_INT 10
6946: PUSH
6947: EMPTY
6948: LIST
6949: LIST
6950: LIST
6951: LIST
6952: PUSH
6953: LD_OWVAR 67
6957: ARRAY
6958: PUSH
6959: FOR_TO
6960: IFFALSE 7234
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6962: LD_ADDR_VAR 0 5
6966: PUSH
6967: LD_INT 2
6969: PUSH
6970: LD_INT 4
6972: PUSH
6973: LD_INT 5
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: LIST
6980: PUSH
6981: LD_INT 1
6983: PPUSH
6984: LD_INT 3
6986: PPUSH
6987: CALL_OW 12
6991: ARRAY
6992: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6993: LD_VAR 0 5
6997: PUSH
6998: LD_INT 2
7000: DOUBLE
7001: EQUAL
7002: IFTRUE 7006
7004: GO 7040
7006: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7007: LD_ADDR_VAR 0 6
7011: PUSH
7012: LD_INT 9
7014: PUSH
7015: LD_INT 5
7017: PUSH
7018: LD_INT 7
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 1
7028: PPUSH
7029: LD_INT 3
7031: PPUSH
7032: CALL_OW 12
7036: ARRAY
7037: ST_TO_ADDR
7038: GO 7129
7040: LD_INT 4
7042: DOUBLE
7043: EQUAL
7044: IFTRUE 7048
7046: GO 7086
7048: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7049: LD_ADDR_VAR 0 6
7053: PUSH
7054: LD_INT 9
7056: PUSH
7057: LD_INT 6
7059: PUSH
7060: LD_INT 6
7062: PUSH
7063: LD_INT 7
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: LIST
7070: LIST
7071: PUSH
7072: LD_INT 1
7074: PPUSH
7075: LD_INT 4
7077: PPUSH
7078: CALL_OW 12
7082: ARRAY
7083: ST_TO_ADDR
7084: GO 7129
7086: LD_INT 5
7088: DOUBLE
7089: EQUAL
7090: IFTRUE 7094
7092: GO 7128
7094: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7095: LD_ADDR_VAR 0 6
7099: PUSH
7100: LD_INT 9
7102: PUSH
7103: LD_INT 6
7105: PUSH
7106: LD_INT 7
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 3
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: ST_TO_ADDR
7126: GO 7129
7128: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7129: LD_VAR 0 5
7133: PPUSH
7134: LD_INT 1
7136: PUSH
7137: LD_INT 3
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: LD_INT 1
7146: PPUSH
7147: LD_INT 2
7149: PPUSH
7150: CALL_OW 12
7154: ARRAY
7155: PPUSH
7156: LD_INT 3
7158: PPUSH
7159: LD_VAR 0 6
7163: PPUSH
7164: LD_INT 70
7166: PPUSH
7167: LD_INT 90
7169: PPUSH
7170: CALL_OW 12
7174: PPUSH
7175: CALL 19948 0 5
// veh := CreateVehicle ;
7179: LD_ADDR_VAR 0 4
7183: PUSH
7184: CALL_OW 45
7188: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7189: LD_VAR 0 4
7193: PPUSH
7194: LD_INT 2
7196: PPUSH
7197: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7201: LD_VAR 0 4
7205: PPUSH
7206: LD_INT 17
7208: PPUSH
7209: LD_INT 0
7211: PPUSH
7212: CALL_OW 49
// tmp := tmp ^ veh ;
7216: LD_ADDR_VAR 0 3
7220: PUSH
7221: LD_VAR 0 3
7225: PUSH
7226: LD_VAR 0 4
7230: ADD
7231: ST_TO_ADDR
// end ;
7232: GO 6959
7234: POP
7235: POP
// if not tmp then
7236: LD_VAR 0 3
7240: NOT
7241: IFFALSE 7245
// exit ;
7243: GO 7354
// if not first_powell_attack then
7245: LD_EXP 12
7249: NOT
7250: IFFALSE 7260
// first_powell_attack := true ;
7252: LD_ADDR_EXP 12
7256: PUSH
7257: LD_INT 1
7259: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7260: LD_INT 70
7262: PPUSH
7263: CALL_OW 67
// for i in tmp do
7267: LD_ADDR_VAR 0 2
7271: PUSH
7272: LD_VAR 0 3
7276: PUSH
7277: FOR_IN
7278: IFFALSE 7345
// if IsOk ( i ) then
7280: LD_VAR 0 2
7284: PPUSH
7285: CALL_OW 302
7289: IFFALSE 7327
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7291: LD_VAR 0 2
7295: PPUSH
7296: LD_INT 81
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PPUSH
7306: CALL_OW 69
7310: PPUSH
7311: LD_VAR 0 2
7315: PPUSH
7316: CALL_OW 74
7320: PPUSH
7321: CALL_OW 115
7325: GO 7343
// tmp := tmp diff i ;
7327: LD_ADDR_VAR 0 3
7331: PUSH
7332: LD_VAR 0 3
7336: PUSH
7337: LD_VAR 0 2
7341: DIFF
7342: ST_TO_ADDR
7343: GO 7277
7345: POP
7346: POP
// until not tmp ;
7347: LD_VAR 0 3
7351: NOT
7352: IFFALSE 7260
// end ; end_of_file
7354: LD_VAR 0 1
7358: RET
// export function Action ; var tmp , i , un ; begin
7359: LD_INT 0
7361: PPUSH
7362: PPUSH
7363: PPUSH
7364: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7365: LD_INT 68
7367: PPUSH
7368: LD_INT 39
7370: PPUSH
7371: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7375: LD_ADDR_VAR 0 2
7379: PUSH
7380: LD_INT 22
7382: PUSH
7383: LD_INT 7
7385: PUSH
7386: EMPTY
7387: LIST
7388: LIST
7389: PPUSH
7390: CALL_OW 69
7394: ST_TO_ADDR
// InGameOn ;
7395: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7399: LD_VAR 0 2
7403: PPUSH
7404: LD_INT 71
7406: PPUSH
7407: LD_INT 49
7409: PPUSH
7410: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7414: LD_INT 35
7416: PPUSH
7417: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7421: LD_INT 7
7423: PPUSH
7424: LD_INT 71
7426: PPUSH
7427: LD_INT 51
7429: PPUSH
7430: CALL_OW 293
7434: IFFALSE 7414
// DialogueOn ;
7436: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7440: LD_EXP 16
7444: PPUSH
7445: LD_STRING D1-JMM-1
7447: PPUSH
7448: CALL_OW 88
// if Joan then
7452: LD_EXP 31
7456: IFFALSE 7470
// Say ( Joan , D1-Joan-1 ) ;
7458: LD_EXP 31
7462: PPUSH
7463: LD_STRING D1-Joan-1
7465: PPUSH
7466: CALL_OW 88
// if Lisa then
7470: LD_EXP 18
7474: IFFALSE 7488
// Say ( Lisa , D1-Lisa-1 ) ;
7476: LD_EXP 18
7480: PPUSH
7481: LD_STRING D1-Lisa-1
7483: PPUSH
7484: CALL_OW 88
// if Joan or Lisa then
7488: LD_EXP 31
7492: PUSH
7493: LD_EXP 18
7497: OR
7498: IFFALSE 7512
// Say ( JMM , D1-JMM-2 ) ;
7500: LD_EXP 16
7504: PPUSH
7505: LD_STRING D1-JMM-2
7507: PPUSH
7508: CALL_OW 88
// DialogueOff ;
7512: CALL_OW 7
// InGameOff ;
7516: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7520: LD_INT 71
7522: PPUSH
7523: LD_INT 50
7525: PPUSH
7526: LD_INT 7
7528: PPUSH
7529: LD_INT 30
7531: NEG
7532: PPUSH
7533: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7537: LD_INT 71
7539: PPUSH
7540: LD_INT 50
7542: PPUSH
7543: LD_INT 7
7545: PPUSH
7546: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7550: LD_STRING M1
7552: PPUSH
7553: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7557: LD_INT 35
7559: PPUSH
7560: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7564: LD_EXP 3
7568: PUSH
7569: LD_OWVAR 1
7573: PUSH
7574: LD_INT 2100
7576: GREATER
7577: OR
7578: IFFALSE 7557
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7580: LD_INT 350
7582: PPUSH
7583: LD_INT 700
7585: PPUSH
7586: CALL_OW 12
7590: PPUSH
7591: CALL_OW 67
// PrepareGossudarov ;
7595: CALL 1918 0 0
// repeat wait ( 0 0$1 ) ;
7599: LD_INT 35
7601: PPUSH
7602: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7606: LD_INT 22
7608: PUSH
7609: LD_INT 6
7611: PUSH
7612: EMPTY
7613: LIST
7614: LIST
7615: PUSH
7616: LD_INT 3
7618: PUSH
7619: LD_INT 24
7621: PUSH
7622: LD_INT 1000
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: PPUSH
7637: CALL_OW 69
7641: PUSH
7642: LD_INT 7
7644: PPUSH
7645: LD_EXP 34
7649: PPUSH
7650: CALL_OW 292
7654: OR
7655: IFFALSE 7599
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7657: LD_ADDR_VAR 0 2
7661: PUSH
7662: LD_INT 22
7664: PUSH
7665: LD_INT 6
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: ST_TO_ADDR
// for i in tmp do
7677: LD_ADDR_VAR 0 3
7681: PUSH
7682: LD_VAR 0 2
7686: PUSH
7687: FOR_IN
7688: IFFALSE 7704
// SetSide ( i , 7 ) ;
7690: LD_VAR 0 3
7694: PPUSH
7695: LD_INT 7
7697: PPUSH
7698: CALL_OW 235
7702: GO 7687
7704: POP
7705: POP
// DialogueOn ;
7706: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7710: LD_EXP 16
7714: PUSH
7715: LD_EXP 17
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PPUSH
7724: LD_EXP 34
7728: PPUSH
7729: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7733: LD_EXP 34
7737: PPUSH
7738: CALL_OW 87
// if not Roth then
7742: LD_EXP 17
7746: NOT
7747: IFFALSE 7839
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7749: LD_VAR 0 2
7753: PPUSH
7754: LD_INT 3
7756: PUSH
7757: LD_INT 24
7759: PUSH
7760: LD_INT 1000
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PUSH
7767: EMPTY
7768: LIST
7769: LIST
7770: PPUSH
7771: CALL_OW 72
7775: IFFALSE 7789
// Say ( JMM , D2-JMM-1 ) ;
7777: LD_EXP 16
7781: PPUSH
7782: LD_STRING D2-JMM-1
7784: PPUSH
7785: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7789: LD_EXP 16
7793: PPUSH
7794: LD_STRING D2-JMM-1b
7796: PPUSH
7797: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7801: LD_EXP 34
7805: PPUSH
7806: LD_STRING D2-Gos-1
7808: PPUSH
7809: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7813: LD_EXP 16
7817: PPUSH
7818: LD_STRING D2-JMM-2
7820: PPUSH
7821: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7825: LD_EXP 34
7829: PPUSH
7830: LD_STRING D2-Gos-2
7832: PPUSH
7833: CALL_OW 88
// end else
7837: GO 7991
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7839: LD_VAR 0 2
7843: PPUSH
7844: LD_INT 3
7846: PUSH
7847: LD_INT 24
7849: PUSH
7850: LD_INT 1000
7852: PUSH
7853: EMPTY
7854: LIST
7855: LIST
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 72
7865: IFFALSE 7891
// begin Say ( Roth , D2-Roth-2 ) ;
7867: LD_EXP 17
7871: PPUSH
7872: LD_STRING D2-Roth-2
7874: PPUSH
7875: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7879: LD_EXP 16
7883: PPUSH
7884: LD_STRING D2-JMM-1a
7886: PPUSH
7887: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7891: LD_EXP 17
7895: PPUSH
7896: LD_STRING D2-Roth-2a
7898: PPUSH
7899: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7903: LD_EXP 17
7907: PPUSH
7908: LD_STRING D2-Roth-2b
7910: PPUSH
7911: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7915: LD_EXP 16
7919: PPUSH
7920: LD_STRING D2-JMM-3
7922: PPUSH
7923: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7927: LD_VAR 0 2
7931: PPUSH
7932: LD_INT 3
7934: PUSH
7935: LD_INT 24
7937: PUSH
7938: LD_INT 1000
7940: PUSH
7941: EMPTY
7942: LIST
7943: LIST
7944: PUSH
7945: EMPTY
7946: LIST
7947: LIST
7948: PPUSH
7949: CALL_OW 72
7953: IFFALSE 7991
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7955: LD_EXP 34
7959: PPUSH
7960: LD_STRING D2-Gos-3
7962: PPUSH
7963: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7967: LD_EXP 16
7971: PPUSH
7972: LD_STRING D2-JMM-4
7974: PPUSH
7975: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7979: LD_EXP 34
7983: PPUSH
7984: LD_STRING D2-Gos-4
7986: PPUSH
7987: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7991: LD_EXP 16
7995: PPUSH
7996: LD_STRING D2-JMM-5
7998: PPUSH
7999: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8003: LD_EXP 34
8007: PPUSH
8008: LD_STRING D2-Gos-5
8010: PPUSH
8011: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8015: LD_EXP 16
8019: PPUSH
8020: LD_STRING D2-JMM-6
8022: PPUSH
8023: CALL_OW 88
// DialogueOff ;
8027: CALL_OW 7
// wait ( 0 0$2 ) ;
8031: LD_INT 70
8033: PPUSH
8034: CALL_OW 67
// if Kirilenkova then
8038: LD_EXP 35
8042: IFFALSE 8056
// Say ( Kirilenkova , D3-Kir-1 ) ;
8044: LD_EXP 35
8048: PPUSH
8049: LD_STRING D3-Kir-1
8051: PPUSH
8052: CALL_OW 88
// gossudarov_arrive := true ;
8056: LD_ADDR_EXP 4
8060: PUSH
8061: LD_INT 1
8063: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8064: LD_INT 35
8066: PPUSH
8067: CALL_OW 67
// until ru_lab_builded ;
8071: LD_EXP 5
8075: IFFALSE 8064
// DialogueOn ;
8077: CALL_OW 6
// if Kirilenkova then
8081: LD_EXP 35
8085: IFFALSE 8101
// Say ( Kirilenkova , D3a-Kir-1 ) else
8087: LD_EXP 35
8091: PPUSH
8092: LD_STRING D3a-Kir-1
8094: PPUSH
8095: CALL_OW 88
8099: GO 8123
// begin un := SciRu ;
8101: LD_ADDR_VAR 0 4
8105: PUSH
8106: CALL 13317 0 0
8110: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8111: LD_VAR 0 4
8115: PPUSH
8116: LD_STRING D3a-Sci1-1
8118: PPUSH
8119: CALL_OW 88
// end ; if Kirilenkova or un then
8123: LD_EXP 35
8127: PUSH
8128: LD_VAR 0 4
8132: OR
8133: IFFALSE 8147
// Say ( JMM , D3a-JMM-1 ) ;
8135: LD_EXP 16
8139: PPUSH
8140: LD_STRING D3a-JMM-1
8142: PPUSH
8143: CALL_OW 88
// DialogueOff ;
8147: CALL_OW 7
// end ;
8151: LD_VAR 0 1
8155: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8156: LD_EXP 4
8160: PUSH
8161: LD_INT 22
8163: PUSH
8164: LD_INT 7
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 2
8173: PUSH
8174: LD_INT 25
8176: PUSH
8177: LD_INT 1
8179: PUSH
8180: EMPTY
8181: LIST
8182: LIST
8183: PUSH
8184: LD_INT 25
8186: PUSH
8187: LD_INT 2
8189: PUSH
8190: EMPTY
8191: LIST
8192: LIST
8193: PUSH
8194: LD_INT 25
8196: PUSH
8197: LD_INT 3
8199: PUSH
8200: EMPTY
8201: LIST
8202: LIST
8203: PUSH
8204: LD_INT 25
8206: PUSH
8207: LD_INT 4
8209: PUSH
8210: EMPTY
8211: LIST
8212: LIST
8213: PUSH
8214: LD_INT 25
8216: PUSH
8217: LD_INT 5
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: PUSH
8224: LD_INT 25
8226: PUSH
8227: LD_INT 8
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: LD_INT 25
8236: PUSH
8237: LD_INT 9
8239: PUSH
8240: EMPTY
8241: LIST
8242: LIST
8243: PUSH
8244: EMPTY
8245: LIST
8246: LIST
8247: LIST
8248: LIST
8249: LIST
8250: LIST
8251: LIST
8252: LIST
8253: PUSH
8254: EMPTY
8255: LIST
8256: LIST
8257: PPUSH
8258: CALL_OW 69
8262: PUSH
8263: LD_INT 7
8265: LESS
8266: AND
8267: IFFALSE 8279
8269: GO 8271
8271: DISABLE
// YouLost ( TooMany ) ;
8272: LD_STRING TooMany
8274: PPUSH
8275: CALL_OW 104
8279: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8280: LD_EXP 34
8284: PPUSH
8285: CALL_OW 255
8289: PUSH
8290: LD_INT 7
8292: EQUAL
8293: IFFALSE 8510
8295: GO 8297
8297: DISABLE
8298: LD_INT 0
8300: PPUSH
8301: PPUSH
8302: PPUSH
// begin uc_side := 3 ;
8303: LD_ADDR_OWVAR 20
8307: PUSH
8308: LD_INT 3
8310: ST_TO_ADDR
// uc_nation := 3 ;
8311: LD_ADDR_OWVAR 21
8315: PUSH
8316: LD_INT 3
8318: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8319: LD_INT 21
8321: PPUSH
8322: LD_INT 3
8324: PPUSH
8325: LD_INT 3
8327: PPUSH
8328: LD_INT 42
8330: PPUSH
8331: LD_INT 100
8333: PPUSH
8334: CALL 19948 0 5
// un := CreateVehicle ;
8338: LD_ADDR_VAR 0 3
8342: PUSH
8343: CALL_OW 45
8347: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8348: LD_VAR 0 3
8352: PPUSH
8353: LD_INT 15
8355: PPUSH
8356: LD_INT 0
8358: PPUSH
8359: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8363: LD_VAR 0 3
8367: PPUSH
8368: LD_INT 67
8370: PPUSH
8371: LD_INT 45
8373: PPUSH
8374: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8378: LD_VAR 0 3
8382: PPUSH
8383: LD_INT 70
8385: PPUSH
8386: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8390: LD_VAR 0 3
8394: PPUSH
8395: LD_INT 69
8397: PPUSH
8398: LD_INT 18
8400: PPUSH
8401: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 60
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8420: LD_INT 35
8422: PPUSH
8423: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8427: LD_VAR 0 3
8431: PPUSH
8432: CALL_OW 302
8436: NOT
8437: PUSH
8438: LD_VAR 0 3
8442: PPUSH
8443: LD_INT 17
8445: PPUSH
8446: CALL_OW 308
8450: OR
8451: PUSH
8452: LD_VAR 0 3
8456: PPUSH
8457: LD_INT 60
8459: PPUSH
8460: LD_INT 3
8462: PPUSH
8463: CALL_OW 307
8467: OR
8468: IFFALSE 8420
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8470: LD_VAR 0 3
8474: PPUSH
8475: LD_INT 17
8477: PPUSH
8478: CALL_OW 308
8482: PUSH
8483: LD_VAR 0 3
8487: PPUSH
8488: LD_INT 60
8490: PPUSH
8491: LD_INT 3
8493: PPUSH
8494: CALL_OW 307
8498: OR
8499: IFFALSE 8510
// RemoveUnit ( un ) ;
8501: LD_VAR 0 3
8505: PPUSH
8506: CALL_OW 64
// end ;
8510: PPOPN 3
8512: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8513: LD_EXP 4
8517: IFFALSE 8759
8519: GO 8521
8521: DISABLE
8522: LD_INT 0
8524: PPUSH
8525: PPUSH
8526: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8527: LD_INT 70
8529: PPUSH
8530: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8534: LD_ADDR_VAR 0 3
8538: PUSH
8539: LD_INT 22
8541: PUSH
8542: LD_INT 7
8544: PUSH
8545: EMPTY
8546: LIST
8547: LIST
8548: PUSH
8549: LD_INT 101
8551: PUSH
8552: LD_INT 3
8554: PUSH
8555: EMPTY
8556: LIST
8557: LIST
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: PPUSH
8563: CALL_OW 69
8567: ST_TO_ADDR
// until tmp ;
8568: LD_VAR 0 3
8572: IFFALSE 8527
// un := NearestUnitToUnit ( tmp , JMM ) ;
8574: LD_ADDR_VAR 0 2
8578: PUSH
8579: LD_VAR 0 3
8583: PPUSH
8584: LD_EXP 16
8588: PPUSH
8589: CALL_OW 74
8593: ST_TO_ADDR
// player_spotted := true ;
8594: LD_ADDR_EXP 6
8598: PUSH
8599: LD_INT 1
8601: ST_TO_ADDR
// tmp := SciRu ;
8602: LD_ADDR_VAR 0 3
8606: PUSH
8607: CALL 13317 0 0
8611: ST_TO_ADDR
// if not tmp then
8612: LD_VAR 0 3
8616: NOT
8617: IFFALSE 8629
// tmp := SolRu ;
8619: LD_ADDR_VAR 0 3
8623: PUSH
8624: CALL 13464 0 0
8628: ST_TO_ADDR
// DialogueOn ;
8629: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8633: LD_VAR 0 2
8637: PPUSH
8638: CALL_OW 250
8642: PPUSH
8643: LD_VAR 0 2
8647: PPUSH
8648: CALL_OW 251
8652: PPUSH
8653: LD_INT 7
8655: PPUSH
8656: LD_INT 8
8658: NEG
8659: PPUSH
8660: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8664: LD_VAR 0 2
8668: PPUSH
8669: CALL_OW 87
// if tmp then
8673: LD_VAR 0 3
8677: IFFALSE 8691
// Say ( tmp , D4-RSci1-1 ) ;
8679: LD_VAR 0 3
8683: PPUSH
8684: LD_STRING D4-RSci1-1
8686: PPUSH
8687: CALL_OW 88
// if Gossudarov then
8691: LD_EXP 34
8695: IFFALSE 8721
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8697: LD_EXP 34
8701: PPUSH
8702: LD_STRING D4-Gos-1
8704: PPUSH
8705: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8709: LD_EXP 16
8713: PPUSH
8714: LD_STRING D4-JMM-1
8716: PPUSH
8717: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8721: LD_VAR 0 2
8725: PPUSH
8726: CALL_OW 250
8730: PPUSH
8731: LD_VAR 0 2
8735: PPUSH
8736: CALL_OW 251
8740: PPUSH
8741: LD_INT 7
8743: PPUSH
8744: CALL_OW 331
// DialogueOff ;
8748: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8752: LD_STRING M5
8754: PPUSH
8755: CALL_OW 337
// end ;
8759: PPOPN 3
8761: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8762: LD_EXP 6
8766: IFFALSE 9359
8768: GO 8770
8770: DISABLE
8771: LD_INT 0
8773: PPUSH
8774: PPUSH
8775: PPUSH
// begin PrepareBelkov ;
8776: CALL 2231 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8780: LD_EXP 49
8784: PPUSH
8785: LD_INT 118
8787: PPUSH
8788: LD_INT 106
8790: PPUSH
8791: CALL_OW 111
// AddComHold ( Belkov ) ;
8795: LD_EXP 49
8799: PPUSH
8800: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8811: LD_EXP 49
8815: PPUSH
8816: LD_INT 118
8818: PPUSH
8819: LD_INT 106
8821: PPUSH
8822: CALL_OW 307
8826: IFFALSE 8804
// ChangeSideFog ( 4 , 7 ) ;
8828: LD_INT 4
8830: PPUSH
8831: LD_INT 7
8833: PPUSH
8834: CALL_OW 343
// if IsOk ( Belkov ) then
8838: LD_EXP 49
8842: PPUSH
8843: CALL_OW 302
8847: IFFALSE 8931
// begin InGameOn ;
8849: CALL_OW 8
// DialogueOn ;
8853: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8857: LD_EXP 49
8861: PPUSH
8862: LD_STRING D5-Bel-1
8864: PPUSH
8865: CALL_OW 94
// if Gossudarov then
8869: LD_EXP 34
8873: IFFALSE 8923
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8875: LD_EXP 34
8879: PPUSH
8880: LD_STRING D5-Gos-1
8882: PPUSH
8883: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8887: LD_EXP 16
8891: PPUSH
8892: LD_STRING D5-JMM-1
8894: PPUSH
8895: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8899: LD_EXP 34
8903: PPUSH
8904: LD_STRING D5-Gos-2
8906: PPUSH
8907: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8911: LD_EXP 16
8915: PPUSH
8916: LD_STRING D5-JMM-2
8918: PPUSH
8919: CALL_OW 88
// end ; DialogueOff ;
8923: CALL_OW 7
// InGameOff ;
8927: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8931: LD_STRING QSaveBelkov
8933: PPUSH
8934: CALL_OW 97
8938: PUSH
8939: LD_INT 1
8941: DOUBLE
8942: EQUAL
8943: IFTRUE 8947
8945: GO 8997
8947: POP
// begin DialogueOn ;
8948: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8952: LD_EXP 16
8956: PPUSH
8957: LD_STRING D5a-JMM-1
8959: PPUSH
8960: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8964: LD_EXP 49
8968: PPUSH
8969: LD_STRING D5a-Bel-1
8971: PPUSH
8972: CALL_OW 94
// DialogueOff ;
8976: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8980: LD_EXP 49
8984: PPUSH
8985: LD_INT 83
8987: PPUSH
8988: LD_INT 49
8990: PPUSH
8991: CALL_OW 111
// end ; 2 :
8995: GO 9030
8997: LD_INT 2
8999: DOUBLE
9000: EQUAL
9001: IFTRUE 9005
9003: GO 9029
9005: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9006: LD_EXP 16
9010: PPUSH
9011: LD_STRING D5a-JMM-2
9013: PPUSH
9014: CALL_OW 88
// ComHold ( Belkov ) ;
9018: LD_EXP 49
9022: PPUSH
9023: CALL_OW 140
// end ; end ;
9027: GO 9030
9029: POP
// time := 0 0$00 ;
9030: LD_ADDR_VAR 0 1
9034: PUSH
9035: LD_INT 0
9037: ST_TO_ADDR
// vehSpawned := false ;
9038: LD_ADDR_VAR 0 3
9042: PUSH
9043: LD_INT 0
9045: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9046: LD_INT 35
9048: PPUSH
9049: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9053: LD_VAR 0 1
9057: PUSH
9058: LD_INT 350
9060: PUSH
9061: LD_INT 175
9063: PUSH
9064: LD_INT 105
9066: PUSH
9067: LD_INT 70
9069: PUSH
9070: EMPTY
9071: LIST
9072: LIST
9073: LIST
9074: LIST
9075: PUSH
9076: LD_OWVAR 67
9080: ARRAY
9081: GREATEREQUAL
9082: PUSH
9083: LD_VAR 0 3
9087: NOT
9088: AND
9089: IFFALSE 9179
// begin vehSpawned := true ;
9091: LD_ADDR_VAR 0 3
9095: PUSH
9096: LD_INT 1
9098: ST_TO_ADDR
// uc_side := 3 ;
9099: LD_ADDR_OWVAR 20
9103: PUSH
9104: LD_INT 3
9106: ST_TO_ADDR
// uc_nation := 3 ;
9107: LD_ADDR_OWVAR 21
9111: PUSH
9112: LD_INT 3
9114: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9115: LD_INT 22
9117: PPUSH
9118: LD_INT 3
9120: PPUSH
9121: LD_INT 3
9123: PPUSH
9124: LD_INT 43
9126: PPUSH
9127: LD_INT 100
9129: PPUSH
9130: CALL 19948 0 5
// veh := CreateVehicle ;
9134: LD_ADDR_VAR 0 2
9138: PUSH
9139: CALL_OW 45
9143: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9144: LD_VAR 0 2
9148: PPUSH
9149: LD_INT 130
9151: PPUSH
9152: LD_INT 131
9154: PPUSH
9155: LD_INT 0
9157: PPUSH
9158: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9162: LD_VAR 0 2
9166: PPUSH
9167: LD_INT 100
9169: PPUSH
9170: LD_INT 82
9172: PPUSH
9173: CALL_OW 114
// end else
9177: GO 9193
// time := time + 0 0$1 ;
9179: LD_ADDR_VAR 0 1
9183: PUSH
9184: LD_VAR 0 1
9188: PUSH
9189: LD_INT 35
9191: PLUS
9192: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9193: LD_EXP 49
9197: PPUSH
9198: CALL_OW 301
9202: PUSH
9203: LD_EXP 49
9207: PPUSH
9208: CALL_OW 255
9212: PUSH
9213: LD_INT 4
9215: EQUAL
9216: AND
9217: PUSH
9218: LD_INT 22
9220: PUSH
9221: LD_INT 7
9223: PUSH
9224: EMPTY
9225: LIST
9226: LIST
9227: PPUSH
9228: CALL_OW 69
9232: PPUSH
9233: LD_EXP 49
9237: PPUSH
9238: CALL_OW 74
9242: PPUSH
9243: LD_EXP 49
9247: PPUSH
9248: CALL_OW 296
9252: PUSH
9253: LD_INT 10
9255: LESS
9256: OR
9257: IFFALSE 9046
// if IsDead ( Belkov ) then
9259: LD_EXP 49
9263: PPUSH
9264: CALL_OW 301
9268: IFFALSE 9293
// begin CenterNowOnUnits ( Belkov ) ;
9270: LD_EXP 49
9274: PPUSH
9275: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9279: LD_EXP 16
9283: PPUSH
9284: LD_STRING D5a-JMM-2a
9286: PPUSH
9287: CALL_OW 88
// exit ;
9291: GO 9359
// end ; if See ( 7 , Belkov ) then
9293: LD_INT 7
9295: PPUSH
9296: LD_EXP 49
9300: PPUSH
9301: CALL_OW 292
9305: IFFALSE 9319
// SetSide ( Belkov , 7 ) ;
9307: LD_EXP 49
9311: PPUSH
9312: LD_INT 7
9314: PPUSH
9315: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9319: LD_INT 35
9321: PPUSH
9322: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9326: LD_EXP 49
9330: PPUSH
9331: LD_INT 66
9333: PPUSH
9334: LD_INT 45
9336: PPUSH
9337: CALL_OW 297
9341: PUSH
9342: LD_INT 30
9344: LESS
9345: IFFALSE 9319
// Say ( Belkov , D6-Bel-1 ) ;
9347: LD_EXP 49
9351: PPUSH
9352: LD_STRING D6-Bel-1
9354: PPUSH
9355: CALL_OW 88
// end ;
9359: PPOPN 3
9361: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9362: LD_EXP 49
9366: PPUSH
9367: CALL_OW 302
9371: PUSH
9372: LD_EXP 49
9376: PPUSH
9377: CALL_OW 504
9381: PUSH
9382: LD_INT 2
9384: PUSH
9385: LD_INT 34
9387: PUSH
9388: LD_INT 47
9390: PUSH
9391: EMPTY
9392: LIST
9393: LIST
9394: PUSH
9395: LD_INT 34
9397: PUSH
9398: LD_INT 45
9400: PUSH
9401: EMPTY
9402: LIST
9403: LIST
9404: PUSH
9405: EMPTY
9406: LIST
9407: LIST
9408: LIST
9409: PPUSH
9410: CALL_OW 69
9414: IN
9415: AND
9416: IFFALSE 9433
9418: GO 9420
9420: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9421: LD_EXP 49
9425: PPUSH
9426: LD_STRING D7-Bel-1
9428: PPUSH
9429: CALL_OW 88
9433: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9434: LD_INT 22
9436: PUSH
9437: LD_INT 7
9439: PUSH
9440: EMPTY
9441: LIST
9442: LIST
9443: PUSH
9444: LD_INT 101
9446: PUSH
9447: LD_INT 2
9449: PUSH
9450: EMPTY
9451: LIST
9452: LIST
9453: PUSH
9454: EMPTY
9455: LIST
9456: LIST
9457: PPUSH
9458: CALL_OW 69
9462: PUSH
9463: LD_EXP 8
9467: NOT
9468: AND
9469: PUSH
9470: LD_EXP 48
9474: PPUSH
9475: CALL_OW 305
9479: NOT
9480: AND
9481: IFFALSE 9951
9483: GO 9485
9485: DISABLE
9486: LD_INT 0
9488: PPUSH
// begin ar_base_spotted := true ;
9489: LD_ADDR_EXP 8
9493: PUSH
9494: LD_INT 1
9496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9497: LD_ADDR_VAR 0 1
9501: PUSH
9502: LD_INT 22
9504: PUSH
9505: LD_INT 2
9507: PUSH
9508: EMPTY
9509: LIST
9510: LIST
9511: PUSH
9512: LD_INT 21
9514: PUSH
9515: LD_INT 3
9517: PUSH
9518: EMPTY
9519: LIST
9520: LIST
9521: PUSH
9522: EMPTY
9523: LIST
9524: LIST
9525: PPUSH
9526: CALL_OW 69
9530: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9531: LD_ADDR_VAR 0 1
9535: PUSH
9536: LD_VAR 0 1
9540: PPUSH
9541: LD_EXP 16
9545: PPUSH
9546: CALL_OW 74
9550: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9551: LD_INT 7
9553: PPUSH
9554: LD_INT 3
9556: PPUSH
9557: CALL_OW 332
// DialogueOn ;
9561: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9565: LD_VAR 0 1
9569: PPUSH
9570: CALL_OW 250
9574: PPUSH
9575: LD_VAR 0 1
9579: PPUSH
9580: CALL_OW 251
9584: PPUSH
9585: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9589: LD_ADDR_VAR 0 1
9593: PUSH
9594: LD_INT 22
9596: PUSH
9597: LD_INT 7
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 23
9606: PUSH
9607: LD_INT 1
9609: PUSH
9610: EMPTY
9611: LIST
9612: LIST
9613: PUSH
9614: LD_INT 26
9616: PUSH
9617: LD_INT 1
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: EMPTY
9625: LIST
9626: LIST
9627: LIST
9628: PPUSH
9629: CALL_OW 69
9633: PUSH
9634: LD_EXP 16
9638: PUSH
9639: LD_EXP 20
9643: PUSH
9644: LD_EXP 21
9648: PUSH
9649: LD_EXP 28
9653: PUSH
9654: LD_EXP 17
9658: PUSH
9659: LD_EXP 26
9663: PUSH
9664: LD_EXP 22
9668: PUSH
9669: LD_EXP 24
9673: PUSH
9674: EMPTY
9675: LIST
9676: LIST
9677: LIST
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: LIST
9683: DIFF
9684: ST_TO_ADDR
// if not tmp then
9685: LD_VAR 0 1
9689: NOT
9690: IFFALSE 9764
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9692: LD_ADDR_VAR 0 1
9696: PUSH
9697: LD_INT 22
9699: PUSH
9700: LD_INT 7
9702: PUSH
9703: EMPTY
9704: LIST
9705: LIST
9706: PUSH
9707: LD_INT 23
9709: PUSH
9710: LD_INT 1
9712: PUSH
9713: EMPTY
9714: LIST
9715: LIST
9716: PUSH
9717: LD_INT 26
9719: PUSH
9720: LD_INT 2
9722: PUSH
9723: EMPTY
9724: LIST
9725: LIST
9726: PUSH
9727: EMPTY
9728: LIST
9729: LIST
9730: LIST
9731: PPUSH
9732: CALL_OW 69
9736: PUSH
9737: LD_EXP 31
9741: PUSH
9742: LD_EXP 18
9746: PUSH
9747: LD_EXP 29
9751: PUSH
9752: LD_EXP 30
9756: PUSH
9757: EMPTY
9758: LIST
9759: LIST
9760: LIST
9761: LIST
9762: DIFF
9763: ST_TO_ADDR
// if tmp then
9764: LD_VAR 0 1
9768: IFFALSE 9839
// case GetSex ( tmp [ 1 ] ) of sex_male :
9770: LD_VAR 0 1
9774: PUSH
9775: LD_INT 1
9777: ARRAY
9778: PPUSH
9779: CALL_OW 258
9783: PUSH
9784: LD_INT 1
9786: DOUBLE
9787: EQUAL
9788: IFTRUE 9792
9790: GO 9811
9792: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9793: LD_VAR 0 1
9797: PUSH
9798: LD_INT 1
9800: ARRAY
9801: PPUSH
9802: LD_STRING D9-Sol1-1
9804: PPUSH
9805: CALL_OW 88
9809: GO 9839
9811: LD_INT 2
9813: DOUBLE
9814: EQUAL
9815: IFTRUE 9819
9817: GO 9838
9819: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9820: LD_VAR 0 1
9824: PUSH
9825: LD_INT 1
9827: ARRAY
9828: PPUSH
9829: LD_STRING D9-FSol1-1
9831: PPUSH
9832: CALL_OW 88
9836: GO 9839
9838: POP
// if Frank then
9839: LD_EXP 28
9843: IFFALSE 9947
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9845: LD_EXP 58
9849: PPUSH
9850: CALL_OW 250
9854: PPUSH
9855: LD_EXP 58
9859: PPUSH
9860: CALL_OW 251
9864: PPUSH
9865: LD_INT 7
9867: PPUSH
9868: LD_INT 8
9870: PPUSH
9871: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9875: LD_EXP 58
9879: PPUSH
9880: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9884: LD_EXP 28
9888: PPUSH
9889: LD_STRING D9-Frank-1
9891: PPUSH
9892: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9896: LD_EXP 16
9900: PPUSH
9901: LD_STRING D9-JMM-1
9903: PPUSH
9904: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9908: LD_EXP 28
9912: PPUSH
9913: LD_STRING D9-Frank-2
9915: PPUSH
9916: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9920: LD_EXP 58
9924: PPUSH
9925: CALL_OW 250
9929: PPUSH
9930: LD_EXP 58
9934: PPUSH
9935: CALL_OW 251
9939: PPUSH
9940: LD_INT 7
9942: PPUSH
9943: CALL_OW 331
// end ; DialogueOff ;
9947: CALL_OW 7
// end ;
9951: PPOPN 1
9953: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9954: LD_EXP 7
9958: PUSH
9959: LD_OWVAR 1
9963: PUSH
9964: LD_INT 42000
9966: GREATEREQUAL
9967: OR
9968: IFFALSE 10995
9970: GO 9972
9972: DISABLE
9973: LD_INT 0
9975: PPUSH
9976: PPUSH
// begin selected_option := 1 ;
9977: LD_ADDR_VAR 0 2
9981: PUSH
9982: LD_INT 1
9984: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9985: LD_INT 10500
9987: PPUSH
9988: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9992: LD_INT 35
9994: PPUSH
9995: CALL_OW 67
// until not ru_attackers ;
9999: LD_EXP 54
10003: NOT
10004: IFFALSE 9992
// PrepareBurlak ;
10006: CALL 2343 0 0
// repeat wait ( 0 0$2 ) ;
10010: LD_INT 70
10012: PPUSH
10013: CALL_OW 67
// until not HasTask ( Burlak ) ;
10017: LD_EXP 48
10021: PPUSH
10022: CALL_OW 314
10026: NOT
10027: IFFALSE 10010
// InGameOn ;
10029: CALL_OW 8
// DialogueOn ;
10033: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10037: LD_EXP 51
10041: PPUSH
10042: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bur-1
10053: PPUSH
10054: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10058: LD_EXP 49
10062: PUSH
10063: LD_EXP 49
10067: PPUSH
10068: CALL_OW 255
10072: PUSH
10073: LD_INT 7
10075: EQUAL
10076: AND
10077: IFFALSE 10091
// Say ( Belkov , D10-Bel-1 ) ;
10079: LD_EXP 49
10083: PPUSH
10084: LD_STRING D10-Bel-1
10086: PPUSH
10087: CALL_OW 88
// if Gossudarov then
10091: LD_EXP 34
10095: IFFALSE 10109
// Say ( Gossudarov , D10-Gos-1 ) ;
10097: LD_EXP 34
10101: PPUSH
10102: LD_STRING D10-Gos-1
10104: PPUSH
10105: CALL_OW 88
// if Kirilenkova then
10109: LD_EXP 35
10113: IFFALSE 10127
// Say ( Kirilenkova , D10-Kir-1 ) ;
10115: LD_EXP 35
10119: PPUSH
10120: LD_STRING D10-Kir-1
10122: PPUSH
10123: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10127: CALL 13464 0 0
10131: PPUSH
10132: LD_STRING D10-RSol1-1
10134: PPUSH
10135: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10139: LD_EXP 48
10143: PPUSH
10144: LD_STRING D10-Bur-2
10146: PPUSH
10147: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10151: LD_EXP 16
10155: PPUSH
10156: LD_STRING D10-JMM-2
10158: PPUSH
10159: CALL_OW 88
// if Kirilenkova then
10163: LD_EXP 35
10167: IFFALSE 10183
// Say ( Kirilenkova , D10-Kir-2 ) else
10169: LD_EXP 35
10173: PPUSH
10174: LD_STRING D10-Kir-2
10176: PPUSH
10177: CALL_OW 88
10181: GO 10195
// Say ( SolRu , D10-RSol1-2 ) ;
10183: CALL 13464 0 0
10187: PPUSH
10188: LD_STRING D10-RSol1-2
10190: PPUSH
10191: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10195: LD_EXP 16
10199: PPUSH
10200: LD_STRING D10-JMM-3
10202: PPUSH
10203: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10207: LD_EXP 48
10211: PPUSH
10212: LD_STRING D10-Bur-3
10214: PPUSH
10215: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10219: LD_EXP 16
10223: PPUSH
10224: LD_STRING D10-JMM-4
10226: PPUSH
10227: CALL_OW 88
// DialogueOff ;
10231: CALL_OW 7
// InGameOff ;
10235: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10239: LD_STRING M2
10241: PPUSH
10242: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10246: LD_INT 35
10248: PPUSH
10249: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10253: LD_INT 22
10255: PUSH
10256: LD_INT 7
10258: PUSH
10259: EMPTY
10260: LIST
10261: LIST
10262: PUSH
10263: LD_INT 91
10265: PUSH
10266: LD_EXP 48
10270: PUSH
10271: LD_INT 8
10273: PUSH
10274: EMPTY
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: EMPTY
10280: LIST
10281: LIST
10282: PPUSH
10283: CALL_OW 69
10287: IFFALSE 10246
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10289: LD_ADDR_VAR 0 1
10293: PUSH
10294: LD_INT 22
10296: PUSH
10297: LD_INT 4
10299: PUSH
10300: EMPTY
10301: LIST
10302: LIST
10303: PPUSH
10304: CALL_OW 69
10308: PUSH
10309: FOR_IN
10310: IFFALSE 10326
// SetSide ( i , 7 ) ;
10312: LD_VAR 0 1
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 235
10324: GO 10309
10326: POP
10327: POP
// ChangeMissionObjectives ( M3 ) ;
10328: LD_STRING M3
10330: PPUSH
10331: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10335: LD_INT 35
10337: PPUSH
10338: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10342: LD_EXP 16
10346: PPUSH
10347: LD_EXP 48
10351: PPUSH
10352: CALL_OW 296
10356: PUSH
10357: LD_INT 8
10359: LESS
10360: IFFALSE 10335
// ComTurnUnit ( JMM , Burlak ) ;
10362: LD_EXP 16
10366: PPUSH
10367: LD_EXP 48
10371: PPUSH
10372: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10376: LD_EXP 48
10380: PPUSH
10381: LD_EXP 16
10385: PPUSH
10386: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10390: LD_INT 10
10392: PPUSH
10393: CALL_OW 67
// DialogueOn ;
10397: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10401: LD_EXP 16
10405: PPUSH
10406: LD_STRING D11-JMM-1
10408: PPUSH
10409: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10413: LD_EXP 48
10417: PPUSH
10418: LD_STRING D11-Bur-1
10420: PPUSH
10421: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10425: LD_EXP 16
10429: PPUSH
10430: LD_STRING D11-JMM-2
10432: PPUSH
10433: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10437: LD_EXP 48
10441: PPUSH
10442: LD_STRING D11-Bur-2
10444: PPUSH
10445: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10449: LD_EXP 16
10453: PPUSH
10454: LD_STRING D11-JMM-3
10456: PPUSH
10457: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10461: LD_EXP 48
10465: PPUSH
10466: LD_STRING D11-Bur-3
10468: PPUSH
10469: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10473: LD_EXP 16
10477: PPUSH
10478: LD_STRING D11-JMM-4
10480: PPUSH
10481: CALL_OW 88
// if ar_base_spotted then
10485: LD_EXP 8
10489: IFFALSE 10505
// Say ( Burlak , D12-Bur-1 ) else
10491: LD_EXP 48
10495: PPUSH
10496: LD_STRING D12-Bur-1
10498: PPUSH
10499: CALL_OW 88
10503: GO 10544
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10505: LD_INT 7
10507: PPUSH
10508: LD_INT 3
10510: PPUSH
10511: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10515: LD_INT 127
10517: PPUSH
10518: LD_INT 45
10520: PPUSH
10521: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10525: LD_EXP 48
10529: PPUSH
10530: LD_STRING D12-Bur-1a
10532: PPUSH
10533: CALL_OW 88
// dwait ( 0 0$2 ) ;
10537: LD_INT 70
10539: PPUSH
10540: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10544: LD_EXP 48
10548: PPUSH
10549: LD_STRING D12-Bur-1b
10551: PPUSH
10552: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10556: LD_EXP 16
10560: PPUSH
10561: LD_STRING D12-JMM-1
10563: PPUSH
10564: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10568: LD_EXP 48
10572: PPUSH
10573: LD_STRING D12-Bur-2
10575: PPUSH
10576: CALL_OW 88
// if Roth then
10580: LD_EXP 17
10584: IFFALSE 10600
// Say ( Roth , D12-Roth-2 ) else
10586: LD_EXP 17
10590: PPUSH
10591: LD_STRING D12-Roth-2
10593: PPUSH
10594: CALL_OW 88
10598: GO 10612
// Say ( SciRu , D12-RSci1-2 ) ;
10600: CALL 13317 0 0
10604: PPUSH
10605: LD_STRING D12-RSci1-2
10607: PPUSH
10608: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10612: LD_EXP 16
10616: PPUSH
10617: LD_STRING D12-JMM-2
10619: PPUSH
10620: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10624: LD_EXP 48
10628: PPUSH
10629: LD_STRING D12-Bur-3
10631: PPUSH
10632: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10636: LD_EXP 16
10640: PPUSH
10641: LD_STRING D12-JMM-3
10643: PPUSH
10644: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10648: LD_EXP 48
10652: PPUSH
10653: LD_STRING D12-Bur-4
10655: PPUSH
10656: CALL_OW 88
// case Query ( QBase ) of 1 :
10660: LD_STRING QBase
10662: PPUSH
10663: CALL_OW 97
10667: PUSH
10668: LD_INT 1
10670: DOUBLE
10671: EQUAL
10672: IFTRUE 10676
10674: GO 10794
10676: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10677: LD_EXP 16
10681: PPUSH
10682: LD_STRING D13a-JMM-1
10684: PPUSH
10685: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10689: LD_EXP 48
10693: PPUSH
10694: LD_STRING D13a-Bur-1
10696: PPUSH
10697: CALL_OW 88
// if Roth then
10701: LD_EXP 17
10705: IFFALSE 10721
// Say ( Roth , D13a-Roth-1 ) else
10707: LD_EXP 17
10711: PPUSH
10712: LD_STRING D13a-Roth-1
10714: PPUSH
10715: CALL_OW 88
10719: GO 10733
// Say ( SciRu , D13a-RSci1-1 ) ;
10721: CALL 13317 0 0
10725: PPUSH
10726: LD_STRING D13a-RSci1-1
10728: PPUSH
10729: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10733: LD_EXP 16
10737: PPUSH
10738: LD_STRING D13a-JMM-2
10740: PPUSH
10741: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10745: LD_STRING QBaseAgain
10747: PPUSH
10748: CALL_OW 97
10752: PUSH
10753: LD_INT 1
10755: DOUBLE
10756: EQUAL
10757: IFTRUE 10761
10759: GO 10772
10761: POP
// selected_option := 2 ; 2 :
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_INT 2
10769: ST_TO_ADDR
10770: GO 10792
10772: LD_INT 2
10774: DOUBLE
10775: EQUAL
10776: IFTRUE 10780
10778: GO 10791
10780: POP
// selected_option := 3 ; end ;
10781: LD_ADDR_VAR 0 2
10785: PUSH
10786: LD_INT 3
10788: ST_TO_ADDR
10789: GO 10792
10791: POP
// end ; 2 :
10792: GO 10833
10794: LD_INT 2
10796: DOUBLE
10797: EQUAL
10798: IFTRUE 10802
10800: GO 10813
10802: POP
// selected_option := 2 ; 3 :
10803: LD_ADDR_VAR 0 2
10807: PUSH
10808: LD_INT 2
10810: ST_TO_ADDR
10811: GO 10833
10813: LD_INT 3
10815: DOUBLE
10816: EQUAL
10817: IFTRUE 10821
10819: GO 10832
10821: POP
// selected_option := 3 ; end ;
10822: LD_ADDR_VAR 0 2
10826: PUSH
10827: LD_INT 3
10829: ST_TO_ADDR
10830: GO 10833
10832: POP
// if selected_option = 2 then
10833: LD_VAR 0 2
10837: PUSH
10838: LD_INT 2
10840: EQUAL
10841: IFFALSE 10935
// begin Say ( JMM , D13b-JMM-1 ) ;
10843: LD_EXP 16
10847: PPUSH
10848: LD_STRING D13b-JMM-1
10850: PPUSH
10851: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10855: LD_EXP 48
10859: PPUSH
10860: LD_STRING D13b-Bur-1
10862: PPUSH
10863: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10867: LD_EXP 16
10871: PPUSH
10872: LD_STRING D13b-JMM-2
10874: PPUSH
10875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10879: LD_EXP 57
10883: PPUSH
10884: LD_STRING D13b-Abd-2
10886: PPUSH
10887: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10891: LD_EXP 16
10895: PPUSH
10896: LD_STRING D13b-JMM-3
10898: PPUSH
10899: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10903: LD_EXP 57
10907: PPUSH
10908: LD_STRING D13b-Abd-3
10910: PPUSH
10911: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10915: LD_EXP 16
10919: PPUSH
10920: LD_STRING D13b-JMM-4
10922: PPUSH
10923: CALL_OW 88
// ar_active_attack := true ;
10927: LD_ADDR_EXP 9
10931: PUSH
10932: LD_INT 1
10934: ST_TO_ADDR
// end ; if selected_option = 3 then
10935: LD_VAR 0 2
10939: PUSH
10940: LD_INT 3
10942: EQUAL
10943: IFFALSE 10969
// begin Say ( JMM , D13c-JMM-1 ) ;
10945: LD_EXP 16
10949: PPUSH
10950: LD_STRING D13c-JMM-1
10952: PPUSH
10953: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10957: LD_EXP 48
10961: PPUSH
10962: LD_STRING D13c-Bur-1
10964: PPUSH
10965: CALL_OW 88
// end ; DialogueOff ;
10969: CALL_OW 7
// if not ar_active_attack then
10973: LD_EXP 9
10977: NOT
10978: IFFALSE 10995
// begin wait ( 6 6$00 ) ;
10980: LD_INT 12600
10982: PPUSH
10983: CALL_OW 67
// ar_active_attack := true ;
10987: LD_ADDR_EXP 9
10991: PUSH
10992: LD_INT 1
10994: ST_TO_ADDR
// end ; end ;
10995: PPOPN 2
10997: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10998: LD_EXP 48
11002: PPUSH
11003: CALL_OW 305
11007: PUSH
11008: LD_EXP 48
11012: PPUSH
11013: CALL_OW 255
11017: PUSH
11018: LD_INT 7
11020: EQUAL
11021: AND
11022: IFFALSE 11218
11024: GO 11026
11026: DISABLE
11027: LD_INT 0
11029: PPUSH
// begin wait ( 4 4$40 ) ;
11030: LD_INT 9800
11032: PPUSH
11033: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11037: LD_INT 35
11039: PPUSH
11040: CALL_OW 67
// until not ru_attackers ;
11044: LD_EXP 54
11048: NOT
11049: IFFALSE 11037
// PrepareGnyevko ;
11051: CALL 2287 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11055: LD_EXP 50
11059: PPUSH
11060: LD_INT 124
11062: PPUSH
11063: LD_INT 118
11065: PPUSH
11066: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11070: LD_EXP 50
11074: PPUSH
11075: CALL_OW 200
// time := 0 0$00 ;
11079: LD_ADDR_VAR 0 1
11083: PUSH
11084: LD_INT 0
11086: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11087: LD_INT 35
11089: PPUSH
11090: CALL_OW 67
// time := time + 0 0$1 ;
11094: LD_ADDR_VAR 0 1
11098: PUSH
11099: LD_VAR 0 1
11103: PUSH
11104: LD_INT 35
11106: PLUS
11107: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11108: LD_EXP 50
11112: PPUSH
11113: LD_INT 124
11115: PPUSH
11116: LD_INT 118
11118: PPUSH
11119: CALL_OW 307
11123: PUSH
11124: LD_VAR 0 1
11128: PUSH
11129: LD_INT 1050
11131: GREATEREQUAL
11132: OR
11133: IFFALSE 11087
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11135: LD_EXP 50
11139: PPUSH
11140: LD_STRING DBelkov-Gny-1
11142: PPUSH
11143: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11147: LD_EXP 48
11151: PPUSH
11152: LD_STRING DBelkov-Bur-1a
11154: PPUSH
11155: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11159: LD_INT 35
11161: PPUSH
11162: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11166: LD_EXP 50
11170: PPUSH
11171: LD_INT 22
11173: PUSH
11174: LD_INT 7
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PPUSH
11181: CALL_OW 69
11185: PPUSH
11186: LD_EXP 50
11190: PPUSH
11191: CALL_OW 74
11195: PPUSH
11196: CALL_OW 296
11200: PUSH
11201: LD_INT 8
11203: LESS
11204: IFFALSE 11159
// SetSide ( Gnyevko , 7 ) ;
11206: LD_EXP 50
11210: PPUSH
11211: LD_INT 7
11213: PPUSH
11214: CALL_OW 235
// end ;
11218: PPOPN 1
11220: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11221: LD_EXP 48
11225: PPUSH
11226: CALL_OW 255
11230: PUSH
11231: LD_INT 7
11233: EQUAL
11234: IFFALSE 11244
11236: GO 11238
11238: DISABLE
// begin enable ;
11239: ENABLE
// PrepareAmericanAttack ;
11240: CALL 6886 0 0
// end ;
11244: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11245: LD_INT 22
11247: PUSH
11248: LD_INT 1
11250: PUSH
11251: EMPTY
11252: LIST
11253: LIST
11254: PPUSH
11255: CALL_OW 69
11259: IFFALSE 11443
11261: GO 11263
11263: DISABLE
11264: LD_INT 0
11266: PPUSH
11267: PPUSH
// begin while true do
11268: LD_INT 1
11270: IFFALSE 11327
// begin wait ( 0 0$1 ) ;
11272: LD_INT 35
11274: PPUSH
11275: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11279: LD_ADDR_VAR 0 2
11283: PUSH
11284: LD_INT 22
11286: PUSH
11287: LD_INT 1
11289: PUSH
11290: EMPTY
11291: LIST
11292: LIST
11293: PPUSH
11294: CALL_OW 69
11298: PPUSH
11299: LD_EXP 16
11303: PPUSH
11304: CALL_OW 74
11308: ST_TO_ADDR
// if See ( 7 , tmp ) then
11309: LD_INT 7
11311: PPUSH
11312: LD_VAR 0 2
11316: PPUSH
11317: CALL_OW 292
11321: IFFALSE 11325
// break ;
11323: GO 11327
// end ;
11325: GO 11268
// DialogueOn ;
11327: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11331: LD_VAR 0 2
11335: PPUSH
11336: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11340: LD_VAR 0 2
11344: PPUSH
11345: CALL_OW 250
11349: PPUSH
11350: LD_VAR 0 2
11354: PPUSH
11355: CALL_OW 251
11359: PPUSH
11360: LD_INT 7
11362: PPUSH
11363: LD_INT 8
11365: PPUSH
11366: CALL_OW 330
// if Denis then
11370: LD_EXP 22
11374: IFFALSE 11388
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11376: LD_EXP 22
11380: PPUSH
11381: LD_STRING DAmerAttack-Pet-1
11383: PPUSH
11384: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11388: LD_EXP 16
11392: PPUSH
11393: LD_STRING DAmerAttack-JMM-1
11395: PPUSH
11396: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11400: LD_EXP 48
11404: PPUSH
11405: LD_STRING DStop-Bur-1
11407: PPUSH
11408: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11412: LD_VAR 0 2
11416: PPUSH
11417: CALL_OW 250
11421: PPUSH
11422: LD_VAR 0 2
11426: PPUSH
11427: CALL_OW 251
11431: PPUSH
11432: LD_INT 7
11434: PPUSH
11435: CALL_OW 331
// DialogueOff ;
11439: CALL_OW 7
// end ;
11443: PPOPN 2
11445: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11446: LD_INT 22
11448: PUSH
11449: LD_INT 3
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: LD_INT 21
11458: PUSH
11459: LD_INT 1
11461: PUSH
11462: EMPTY
11463: LIST
11464: LIST
11465: PUSH
11466: EMPTY
11467: LIST
11468: LIST
11469: PPUSH
11470: CALL_OW 69
11474: PUSH
11475: LD_INT 0
11477: EQUAL
11478: IFFALSE 11520
11480: GO 11482
11482: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11483: LD_STRING M5a
11485: PPUSH
11486: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11490: LD_EXP 16
11494: PPUSH
11495: LD_STRING D8-JMM-1
11497: PPUSH
11498: CALL_OW 88
// if Gossudarov then
11502: LD_EXP 34
11506: IFFALSE 11520
// Say ( Gossudarov , D8-Gos-1 ) ;
11508: LD_EXP 34
11512: PPUSH
11513: LD_STRING D8-Gos-1
11515: PPUSH
11516: CALL_OW 88
// end ;
11520: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11521: LD_INT 22
11523: PUSH
11524: LD_INT 2
11526: PUSH
11527: EMPTY
11528: LIST
11529: LIST
11530: PUSH
11531: LD_INT 21
11533: PUSH
11534: LD_INT 1
11536: PUSH
11537: EMPTY
11538: LIST
11539: LIST
11540: PUSH
11541: EMPTY
11542: LIST
11543: LIST
11544: PPUSH
11545: CALL_OW 69
11549: PUSH
11550: LD_INT 0
11552: EQUAL
11553: IFFALSE 11603
11555: GO 11557
11557: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11558: LD_STRING M4c
11560: PPUSH
11561: CALL_OW 337
// if Roth then
11565: LD_EXP 17
11569: IFFALSE 11585
// Say ( Roth , DStop-Roth-1 ) else
11571: LD_EXP 17
11575: PPUSH
11576: LD_STRING DStop-Roth-1
11578: PPUSH
11579: CALL_OW 88
11583: GO 11603
// if Gossudarov then
11585: LD_EXP 34
11589: IFFALSE 11603
// Say ( Gossudarov , D8-Gos-1a ) ;
11591: LD_EXP 34
11595: PPUSH
11596: LD_STRING D8-Gos-1a
11598: PPUSH
11599: CALL_OW 88
// end ;
11603: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11604: LD_INT 7
11606: PPUSH
11607: LD_INT 1
11609: PPUSH
11610: LD_INT 1
11612: PPUSH
11613: CALL 14996 0 3
11617: PUSH
11618: LD_INT 0
11620: EQUAL
11621: PUSH
11622: LD_INT 7
11624: PPUSH
11625: LD_INT 3
11627: PPUSH
11628: LD_INT 1
11630: PPUSH
11631: CALL 14996 0 3
11635: PUSH
11636: LD_INT 0
11638: EQUAL
11639: AND
11640: IFFALSE 11652
11642: GO 11644
11644: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11645: LD_STRING M1a
11647: PPUSH
11648: CALL_OW 337
// end ;
11652: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11653: LD_INT 22
11655: PUSH
11656: LD_INT 2
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: PUSH
11686: LD_INT 22
11688: PUSH
11689: LD_INT 3
11691: PUSH
11692: EMPTY
11693: LIST
11694: LIST
11695: PUSH
11696: LD_INT 21
11698: PUSH
11699: LD_INT 1
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: EMPTY
11707: LIST
11708: LIST
11709: PPUSH
11710: CALL_OW 69
11714: PUSH
11715: LD_INT 0
11717: EQUAL
11718: AND
11719: PUSH
11720: LD_INT 22
11722: PUSH
11723: LD_INT 1
11725: PUSH
11726: EMPTY
11727: LIST
11728: LIST
11729: PPUSH
11730: CALL_OW 69
11734: PUSH
11735: LD_INT 0
11737: EQUAL
11738: AND
11739: PUSH
11740: LD_INT 7
11742: PPUSH
11743: LD_INT 1
11745: PPUSH
11746: LD_INT 1
11748: PPUSH
11749: CALL 14996 0 3
11753: PUSH
11754: LD_INT 0
11756: EQUAL
11757: AND
11758: PUSH
11759: LD_INT 7
11761: PPUSH
11762: LD_INT 3
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL 14996 0 3
11772: PUSH
11773: LD_INT 0
11775: EQUAL
11776: AND
11777: PUSH
11778: LD_EXP 48
11782: PPUSH
11783: CALL_OW 255
11787: PUSH
11788: LD_INT 7
11790: EQUAL
11791: AND
11792: PUSH
11793: LD_EXP 48
11797: PPUSH
11798: CALL_OW 302
11802: AND
11803: IFFALSE 13314
11805: GO 11807
11807: DISABLE
11808: LD_INT 0
11810: PPUSH
11811: PPUSH
11812: PPUSH
11813: PPUSH
11814: PPUSH
11815: PPUSH
// begin m1 := false ;
11816: LD_ADDR_VAR 0 4
11820: PUSH
11821: LD_INT 0
11823: ST_TO_ADDR
// m2 := false ;
11824: LD_ADDR_VAR 0 5
11828: PUSH
11829: LD_INT 0
11831: ST_TO_ADDR
// m3 := false ;
11832: LD_ADDR_VAR 0 6
11836: PUSH
11837: LD_INT 0
11839: ST_TO_ADDR
// if tick < 40 40$00 then
11840: LD_OWVAR 1
11844: PUSH
11845: LD_INT 84000
11847: LESS
11848: IFFALSE 11857
// SetAchievement ( ACH_ASPEED_17 ) ;
11850: LD_STRING ACH_ASPEED_17
11852: PPUSH
11853: CALL_OW 543
// wait ( 0 0$5 ) ;
11857: LD_INT 175
11859: PPUSH
11860: CALL_OW 67
// if not masha_killed then
11864: LD_EXP 10
11868: NOT
11869: IFFALSE 11891
// begin m1 := true ;
11871: LD_ADDR_VAR 0 4
11875: PUSH
11876: LD_INT 1
11878: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11879: LD_STRING Masha
11881: PPUSH
11882: LD_INT 1
11884: PPUSH
11885: CALL_OW 101
// end else
11889: GO 11902
// AddMedal ( Masha , - 1 ) ;
11891: LD_STRING Masha
11893: PPUSH
11894: LD_INT 1
11896: NEG
11897: PPUSH
11898: CALL_OW 101
// if abdul_escaped then
11902: LD_EXP 13
11906: IFFALSE 11921
// AddMedal ( Abdul , - 1 ) else
11908: LD_STRING Abdul
11910: PPUSH
11911: LD_INT 1
11913: NEG
11914: PPUSH
11915: CALL_OW 101
11919: GO 11939
// begin m2 := true ;
11921: LD_ADDR_VAR 0 5
11925: PUSH
11926: LD_INT 1
11928: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11929: LD_STRING Abdul
11931: PPUSH
11932: LD_INT 1
11934: PPUSH
11935: CALL_OW 101
// end ; if loss_counter = 0 then
11939: LD_EXP 14
11943: PUSH
11944: LD_INT 0
11946: EQUAL
11947: IFFALSE 11969
// begin m3 := true ;
11949: LD_ADDR_VAR 0 6
11953: PUSH
11954: LD_INT 1
11956: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11957: LD_STRING People
11959: PPUSH
11960: LD_INT 2
11962: PPUSH
11963: CALL_OW 101
// end else
11967: GO 12031
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11969: LD_EXP 14
11973: PUSH
11974: LD_INT 3
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: LD_INT 2
11982: PUSH
11983: LD_INT 1
11985: PUSH
11986: EMPTY
11987: LIST
11988: LIST
11989: LIST
11990: LIST
11991: PUSH
11992: LD_OWVAR 67
11996: ARRAY
11997: LESSEQUAL
11998: IFFALSE 12020
// begin AddMedal ( People , 1 ) ;
12000: LD_STRING People
12002: PPUSH
12003: LD_INT 1
12005: PPUSH
12006: CALL_OW 101
// m3 := true ;
12010: LD_ADDR_VAR 0 6
12014: PUSH
12015: LD_INT 1
12017: ST_TO_ADDR
// end else
12018: GO 12031
// AddMedal ( People , - 1 ) ;
12020: LD_STRING People
12022: PPUSH
12023: LD_INT 1
12025: NEG
12026: PPUSH
12027: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12031: LD_OWVAR 67
12035: PUSH
12036: LD_INT 3
12038: GREATEREQUAL
12039: PUSH
12040: LD_VAR 0 4
12044: AND
12045: PUSH
12046: LD_VAR 0 5
12050: AND
12051: PUSH
12052: LD_VAR 0 6
12056: AND
12057: IFFALSE 12069
// SetAchievementEX ( ACH_AMER , 17 ) ;
12059: LD_STRING ACH_AMER
12061: PPUSH
12062: LD_INT 17
12064: PPUSH
12065: CALL_OW 564
// GiveMedals ( MAIN ) ;
12069: LD_STRING MAIN
12071: PPUSH
12072: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12076: LD_ADDR_VAR 0 2
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 7
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 50
12093: PUSH
12094: EMPTY
12095: LIST
12096: PUSH
12097: LD_INT 2
12099: PUSH
12100: LD_INT 25
12102: PUSH
12103: LD_INT 1
12105: PUSH
12106: EMPTY
12107: LIST
12108: LIST
12109: PUSH
12110: LD_INT 25
12112: PUSH
12113: LD_INT 2
12115: PUSH
12116: EMPTY
12117: LIST
12118: LIST
12119: PUSH
12120: LD_INT 25
12122: PUSH
12123: LD_INT 3
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: PUSH
12130: LD_INT 25
12132: PUSH
12133: LD_INT 4
12135: PUSH
12136: EMPTY
12137: LIST
12138: LIST
12139: PUSH
12140: LD_INT 25
12142: PUSH
12143: LD_INT 5
12145: PUSH
12146: EMPTY
12147: LIST
12148: LIST
12149: PUSH
12150: LD_INT 25
12152: PUSH
12153: LD_INT 8
12155: PUSH
12156: EMPTY
12157: LIST
12158: LIST
12159: PUSH
12160: LD_INT 25
12162: PUSH
12163: LD_INT 9
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: PUSH
12170: EMPTY
12171: LIST
12172: LIST
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: PPUSH
12185: CALL_OW 69
12189: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12190: LD_VAR 0 2
12194: PPUSH
12195: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12199: LD_ADDR_VAR 0 3
12203: PUSH
12204: LD_EXP 16
12208: PUSH
12209: LD_EXP 17
12213: PUSH
12214: LD_EXP 18
12218: PUSH
12219: LD_EXP 19
12223: PUSH
12224: LD_EXP 20
12228: PUSH
12229: LD_EXP 21
12233: PUSH
12234: LD_EXP 22
12238: PUSH
12239: LD_EXP 23
12243: PUSH
12244: LD_EXP 24
12248: PUSH
12249: LD_EXP 25
12253: PUSH
12254: LD_EXP 26
12258: PUSH
12259: LD_EXP 27
12263: PUSH
12264: LD_EXP 28
12268: PUSH
12269: LD_EXP 29
12273: PUSH
12274: LD_EXP 30
12278: PUSH
12279: LD_EXP 31
12283: PUSH
12284: LD_EXP 32
12288: PUSH
12289: LD_EXP 34
12293: PUSH
12294: LD_EXP 35
12298: PUSH
12299: LD_EXP 36
12303: PUSH
12304: LD_EXP 38
12308: PUSH
12309: LD_EXP 39
12313: PUSH
12314: LD_EXP 40
12318: PUSH
12319: LD_EXP 41
12323: PUSH
12324: LD_EXP 42
12328: PUSH
12329: LD_EXP 43
12333: PUSH
12334: LD_EXP 44
12338: PUSH
12339: LD_EXP 45
12343: PUSH
12344: LD_EXP 46
12348: PUSH
12349: LD_EXP 47
12353: PUSH
12354: LD_EXP 48
12358: PUSH
12359: LD_EXP 49
12363: PUSH
12364: LD_EXP 50
12368: PUSH
12369: LD_EXP 33
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: LIST
12378: LIST
12379: LIST
12380: LIST
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: LIST
12386: LIST
12387: LIST
12388: LIST
12389: LIST
12390: LIST
12391: LIST
12392: LIST
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: LIST
12404: LIST
12405: LIST
12406: LIST
12407: LIST
12408: LIST
12409: ST_TO_ADDR
// if tmp diff tmp2 then
12410: LD_VAR 0 2
12414: PUSH
12415: LD_VAR 0 3
12419: DIFF
12420: IFFALSE 12440
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12422: LD_VAR 0 2
12426: PUSH
12427: LD_VAR 0 3
12431: DIFF
12432: PPUSH
12433: LD_STRING 13a_others
12435: PPUSH
12436: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12440: LD_EXP 16
12444: PPUSH
12445: LD_STRING 13a_JMM
12447: PPUSH
12448: CALL_OW 38
// if IsOk ( Mike ) then
12452: LD_EXP 33
12456: PPUSH
12457: CALL_OW 302
12461: IFFALSE 12475
// SaveCharacters ( Mike , 13a_Mike ) ;
12463: LD_EXP 33
12467: PPUSH
12468: LD_STRING 13a_Mike
12470: PPUSH
12471: CALL_OW 38
// if Titov then
12475: LD_EXP 36
12479: IFFALSE 12493
// SaveCharacters ( Titov , 13a_Titov ) ;
12481: LD_EXP 36
12485: PPUSH
12486: LD_STRING 13a_Titov
12488: PPUSH
12489: CALL_OW 38
// if Dolgov then
12493: LD_EXP 38
12497: IFFALSE 12511
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12499: LD_EXP 38
12503: PPUSH
12504: LD_STRING 13a_Dolgov
12506: PPUSH
12507: CALL_OW 38
// if Petrosyan then
12511: LD_EXP 39
12515: IFFALSE 12529
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12517: LD_EXP 39
12521: PPUSH
12522: LD_STRING 13a_Petrosyan
12524: PPUSH
12525: CALL_OW 38
// if Scholtze then
12529: LD_EXP 40
12533: IFFALSE 12547
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12535: LD_EXP 40
12539: PPUSH
12540: LD_STRING 13a_Scholtze
12542: PPUSH
12543: CALL_OW 38
// if Oblukov then
12547: LD_EXP 41
12551: IFFALSE 12565
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12553: LD_EXP 41
12557: PPUSH
12558: LD_STRING 13a_Oblukov
12560: PPUSH
12561: CALL_OW 38
// if Kapitsova then
12565: LD_EXP 42
12569: IFFALSE 12583
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12571: LD_EXP 42
12575: PPUSH
12576: LD_STRING 13a_Kapitsova
12578: PPUSH
12579: CALL_OW 38
// if Lipshchin then
12583: LD_EXP 43
12587: IFFALSE 12601
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12589: LD_EXP 43
12593: PPUSH
12594: LD_STRING 13a_Lipshchin
12596: PPUSH
12597: CALL_OW 38
// if Petrovova then
12601: LD_EXP 44
12605: IFFALSE 12619
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12607: LD_EXP 44
12611: PPUSH
12612: LD_STRING 13a_Petrovova
12614: PPUSH
12615: CALL_OW 38
// if Kovalyuk then
12619: LD_EXP 45
12623: IFFALSE 12637
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12625: LD_EXP 45
12629: PPUSH
12630: LD_STRING 13a_Kovalyuk
12632: PPUSH
12633: CALL_OW 38
// if Kuzmov then
12637: LD_EXP 46
12641: IFFALSE 12655
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12643: LD_EXP 46
12647: PPUSH
12648: LD_STRING 13a_Kuzmov
12650: PPUSH
12651: CALL_OW 38
// if Karamazov then
12655: LD_EXP 47
12659: IFFALSE 12673
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12661: LD_EXP 47
12665: PPUSH
12666: LD_STRING 13a_Karamazov
12668: PPUSH
12669: CALL_OW 38
// if Burlak then
12673: LD_EXP 48
12677: IFFALSE 12691
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12679: LD_EXP 48
12683: PPUSH
12684: LD_STRING 13a_Burlak
12686: PPUSH
12687: CALL_OW 38
// if Belkov then
12691: LD_EXP 49
12695: IFFALSE 12709
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12697: LD_EXP 49
12701: PPUSH
12702: LD_STRING 13a_Belkov
12704: PPUSH
12705: CALL_OW 38
// if Gnyevko then
12709: LD_EXP 50
12713: IFFALSE 12727
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12715: LD_EXP 50
12719: PPUSH
12720: LD_STRING 13a_Gnyevko
12722: PPUSH
12723: CALL_OW 38
// if Lisa then
12727: LD_EXP 18
12731: IFFALSE 12745
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12733: LD_EXP 18
12737: PPUSH
12738: LD_STRING 13a_Lisa
12740: PPUSH
12741: CALL_OW 38
// if Donaldson then
12745: LD_EXP 19
12749: IFFALSE 12763
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12751: LD_EXP 19
12755: PPUSH
12756: LD_STRING 13a_Donaldson
12758: PPUSH
12759: CALL_OW 38
// if Bobby then
12763: LD_EXP 20
12767: IFFALSE 12781
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12769: LD_EXP 20
12773: PPUSH
12774: LD_STRING 13a_Bobby
12776: PPUSH
12777: CALL_OW 38
// if Cyrus then
12781: LD_EXP 21
12785: IFFALSE 12799
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12787: LD_EXP 21
12791: PPUSH
12792: LD_STRING 13a_Cyrus
12794: PPUSH
12795: CALL_OW 38
// if Denis then
12799: LD_EXP 22
12803: IFFALSE 12817
// SaveCharacters ( Denis , 13a_Denis ) ;
12805: LD_EXP 22
12809: PPUSH
12810: LD_STRING 13a_Denis
12812: PPUSH
12813: CALL_OW 38
// if Brown then
12817: LD_EXP 23
12821: IFFALSE 12835
// SaveCharacters ( Brown , 13a_Brown ) ;
12823: LD_EXP 23
12827: PPUSH
12828: LD_STRING 13a_Brown
12830: PPUSH
12831: CALL_OW 38
// if Gladstone then
12835: LD_EXP 24
12839: IFFALSE 12853
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12841: LD_EXP 24
12845: PPUSH
12846: LD_STRING 13a_Gladstone
12848: PPUSH
12849: CALL_OW 38
// if Houten then
12853: LD_EXP 25
12857: IFFALSE 12871
// SaveCharacters ( Houten , 13a_Houten ) ;
12859: LD_EXP 25
12863: PPUSH
12864: LD_STRING 13a_Houten
12866: PPUSH
12867: CALL_OW 38
// if Cornel then
12871: LD_EXP 26
12875: IFFALSE 12889
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12877: LD_EXP 26
12881: PPUSH
12882: LD_STRING 13a_Cornel
12884: PPUSH
12885: CALL_OW 38
// if Gary then
12889: LD_EXP 27
12893: IFFALSE 12907
// SaveCharacters ( Gary , 13a_Gary ) ;
12895: LD_EXP 27
12899: PPUSH
12900: LD_STRING 13a_Gary
12902: PPUSH
12903: CALL_OW 38
// if Frank then
12907: LD_EXP 28
12911: IFFALSE 12925
// SaveCharacters ( Frank , 13a_Frank ) ;
12913: LD_EXP 28
12917: PPUSH
12918: LD_STRING 13a_Frank
12920: PPUSH
12921: CALL_OW 38
// if Kikuchi then
12925: LD_EXP 29
12929: IFFALSE 12943
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12931: LD_EXP 29
12935: PPUSH
12936: LD_STRING 13a_Kikuchi
12938: PPUSH
12939: CALL_OW 38
// if Simms then
12943: LD_EXP 30
12947: IFFALSE 12961
// SaveCharacters ( Simms , 13a_Simms ) ;
12949: LD_EXP 30
12953: PPUSH
12954: LD_STRING 13a_Simms
12956: PPUSH
12957: CALL_OW 38
// if Joan then
12961: LD_EXP 31
12965: IFFALSE 12979
// SaveCharacters ( Joan , 13a_Joan ) ;
12967: LD_EXP 31
12971: PPUSH
12972: LD_STRING 13a_Joan
12974: PPUSH
12975: CALL_OW 38
// if DeltaDoctor then
12979: LD_EXP 32
12983: IFFALSE 12997
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12985: LD_EXP 32
12989: PPUSH
12990: LD_STRING 13a_DeltaDoctor
12992: PPUSH
12993: CALL_OW 38
// if Gossudarov then
12997: LD_EXP 34
13001: IFFALSE 13015
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13003: LD_EXP 34
13007: PPUSH
13008: LD_STRING 13a_Gossudarov
13010: PPUSH
13011: CALL_OW 38
// if Kirilenkova then
13015: LD_EXP 35
13019: IFFALSE 13033
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13021: LD_EXP 35
13025: PPUSH
13026: LD_STRING 13a_Kirilenkova
13028: PPUSH
13029: CALL_OW 38
// if Roth then
13033: LD_EXP 17
13037: IFFALSE 13051
// SaveCharacters ( Roth , 13a_Roth ) ;
13039: LD_EXP 17
13043: PPUSH
13044: LD_STRING 13a_Roth
13046: PPUSH
13047: CALL_OW 38
// if Masha then
13051: LD_EXP 51
13055: IFFALSE 13110
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13057: LD_EXP 51
13061: PPUSH
13062: CALL_OW 265
13066: PUSH
13067: LD_EXP 51
13071: PPUSH
13072: CALL_OW 262
13076: PUSH
13077: LD_EXP 51
13081: PPUSH
13082: CALL_OW 263
13086: PUSH
13087: LD_EXP 51
13091: PPUSH
13092: CALL_OW 264
13096: PUSH
13097: EMPTY
13098: LIST
13099: LIST
13100: LIST
13101: LIST
13102: PPUSH
13103: LD_STRING 13a_Masha
13105: PPUSH
13106: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13110: LD_ADDR_VAR 0 2
13114: PUSH
13115: LD_INT 21
13117: PUSH
13118: LD_INT 3
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: PPUSH
13125: CALL_OW 69
13129: ST_TO_ADDR
// tmp2 := [ ] ;
13130: LD_ADDR_VAR 0 3
13134: PUSH
13135: EMPTY
13136: ST_TO_ADDR
// if tmp then
13137: LD_VAR 0 2
13141: IFFALSE 13292
// for i in tmp do
13143: LD_ADDR_VAR 0 1
13147: PUSH
13148: LD_VAR 0 2
13152: PUSH
13153: FOR_IN
13154: IFFALSE 13290
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13156: LD_ADDR_VAR 0 3
13160: PUSH
13161: LD_VAR 0 3
13165: PUSH
13166: LD_VAR 0 1
13170: PPUSH
13171: CALL_OW 255
13175: PUSH
13176: LD_VAR 0 1
13180: PPUSH
13181: CALL_OW 248
13185: PUSH
13186: LD_VAR 0 1
13190: PPUSH
13191: CALL_OW 266
13195: PUSH
13196: LD_VAR 0 1
13200: PPUSH
13201: CALL_OW 250
13205: PUSH
13206: LD_VAR 0 1
13210: PPUSH
13211: CALL_OW 251
13215: PUSH
13216: LD_VAR 0 1
13220: PPUSH
13221: CALL_OW 254
13225: PUSH
13226: LD_VAR 0 1
13230: PPUSH
13231: CALL_OW 267
13235: PUSH
13236: LD_VAR 0 1
13240: PPUSH
13241: LD_INT 1
13243: PPUSH
13244: CALL_OW 268
13248: PUSH
13249: LD_VAR 0 1
13253: PPUSH
13254: LD_INT 2
13256: PPUSH
13257: CALL_OW 268
13261: PUSH
13262: LD_VAR 0 1
13266: PPUSH
13267: CALL_OW 269
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: LIST
13282: LIST
13283: PUSH
13284: EMPTY
13285: LIST
13286: ADD
13287: ST_TO_ADDR
13288: GO 13153
13290: POP
13291: POP
// if tmp2 then
13292: LD_VAR 0 3
13296: IFFALSE 13310
// SaveVariable ( tmp2 , 13a_buildings ) ;
13298: LD_VAR 0 3
13302: PPUSH
13303: LD_STRING 13a_buildings
13305: PPUSH
13306: CALL_OW 39
// YouWin ;
13310: CALL_OW 103
// end ;
13314: PPOPN 6
13316: END
// export function SciRu ; var tmp , t ; begin
13317: LD_INT 0
13319: PPUSH
13320: PPUSH
13321: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13322: LD_ADDR_VAR 0 3
13326: PUSH
13327: LD_EXP 34
13331: PUSH
13332: LD_EXP 48
13336: PUSH
13337: LD_EXP 36
13341: PUSH
13342: LD_EXP 49
13346: PUSH
13347: LD_EXP 50
13351: PUSH
13352: LD_EXP 39
13356: PUSH
13357: LD_EXP 40
13361: PUSH
13362: LD_EXP 38
13366: PUSH
13367: EMPTY
13368: LIST
13369: LIST
13370: LIST
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: LIST
13376: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13377: LD_ADDR_VAR 0 2
13381: PUSH
13382: LD_INT 22
13384: PUSH
13385: LD_INT 7
13387: PUSH
13388: EMPTY
13389: LIST
13390: LIST
13391: PUSH
13392: LD_INT 23
13394: PUSH
13395: LD_INT 3
13397: PUSH
13398: EMPTY
13399: LIST
13400: LIST
13401: PUSH
13402: LD_INT 25
13404: PUSH
13405: LD_INT 4
13407: PUSH
13408: EMPTY
13409: LIST
13410: LIST
13411: PUSH
13412: LD_INT 26
13414: PUSH
13415: LD_INT 1
13417: PUSH
13418: EMPTY
13419: LIST
13420: LIST
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: PPUSH
13428: CALL_OW 69
13432: PUSH
13433: LD_VAR 0 3
13437: DIFF
13438: ST_TO_ADDR
// if tmp then
13439: LD_VAR 0 2
13443: IFFALSE 13459
// result := tmp [ 1 ] ;
13445: LD_ADDR_VAR 0 1
13449: PUSH
13450: LD_VAR 0 2
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: ST_TO_ADDR
// end ;
13459: LD_VAR 0 1
13463: RET
// export function SolRu ; var tmp , t ; begin
13464: LD_INT 0
13466: PPUSH
13467: PPUSH
13468: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13469: LD_ADDR_VAR 0 3
13473: PUSH
13474: LD_EXP 34
13478: PUSH
13479: LD_EXP 48
13483: PUSH
13484: LD_EXP 36
13488: PUSH
13489: LD_EXP 49
13493: PUSH
13494: LD_EXP 50
13498: PUSH
13499: LD_EXP 39
13503: PUSH
13504: LD_EXP 40
13508: PUSH
13509: LD_EXP 38
13513: PUSH
13514: EMPTY
13515: LIST
13516: LIST
13517: LIST
13518: LIST
13519: LIST
13520: LIST
13521: LIST
13522: LIST
13523: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13524: LD_ADDR_VAR 0 2
13528: PUSH
13529: LD_INT 22
13531: PUSH
13532: LD_INT 7
13534: PUSH
13535: EMPTY
13536: LIST
13537: LIST
13538: PUSH
13539: LD_INT 23
13541: PUSH
13542: LD_INT 3
13544: PUSH
13545: EMPTY
13546: LIST
13547: LIST
13548: PUSH
13549: LD_INT 25
13551: PUSH
13552: LD_INT 1
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: PUSH
13559: LD_INT 26
13561: PUSH
13562: LD_INT 1
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: EMPTY
13570: LIST
13571: LIST
13572: LIST
13573: LIST
13574: PPUSH
13575: CALL_OW 69
13579: PUSH
13580: LD_VAR 0 3
13584: DIFF
13585: ST_TO_ADDR
// if tmp then
13586: LD_VAR 0 2
13590: IFFALSE 13606
// result := tmp [ 1 ] ;
13592: LD_ADDR_VAR 0 1
13596: PUSH
13597: LD_VAR 0 2
13601: PUSH
13602: LD_INT 1
13604: ARRAY
13605: ST_TO_ADDR
// end ; end_of_file
13606: LD_VAR 0 1
13610: RET
// export function CustomEvent ( event ) ; begin
13611: LD_INT 0
13613: PPUSH
// end ;
13614: LD_VAR 0 2
13618: RET
// on UnitDestroyed ( un ) do var i , side ;
13619: LD_INT 0
13621: PPUSH
13622: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13623: LD_VAR 0 1
13627: PPUSH
13628: CALL 102648 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13632: LD_VAR 0 1
13636: PUSH
13637: LD_INT 22
13639: PUSH
13640: LD_INT 7
13642: PUSH
13643: EMPTY
13644: LIST
13645: LIST
13646: PUSH
13647: LD_INT 2
13649: PUSH
13650: LD_INT 25
13652: PUSH
13653: LD_INT 1
13655: PUSH
13656: EMPTY
13657: LIST
13658: LIST
13659: PUSH
13660: LD_INT 25
13662: PUSH
13663: LD_INT 2
13665: PUSH
13666: EMPTY
13667: LIST
13668: LIST
13669: PUSH
13670: LD_INT 25
13672: PUSH
13673: LD_INT 3
13675: PUSH
13676: EMPTY
13677: LIST
13678: LIST
13679: PUSH
13680: LD_INT 25
13682: PUSH
13683: LD_INT 4
13685: PUSH
13686: EMPTY
13687: LIST
13688: LIST
13689: PUSH
13690: LD_INT 25
13692: PUSH
13693: LD_INT 5
13695: PUSH
13696: EMPTY
13697: LIST
13698: LIST
13699: PUSH
13700: LD_INT 25
13702: PUSH
13703: LD_INT 8
13705: PUSH
13706: EMPTY
13707: LIST
13708: LIST
13709: PUSH
13710: LD_INT 25
13712: PUSH
13713: LD_INT 9
13715: PUSH
13716: EMPTY
13717: LIST
13718: LIST
13719: PUSH
13720: EMPTY
13721: LIST
13722: LIST
13723: LIST
13724: LIST
13725: LIST
13726: LIST
13727: LIST
13728: LIST
13729: PUSH
13730: EMPTY
13731: LIST
13732: LIST
13733: PPUSH
13734: CALL_OW 69
13738: IN
13739: IFFALSE 13755
// loss_counter := loss_counter + 1 ;
13741: LD_ADDR_EXP 14
13745: PUSH
13746: LD_EXP 14
13750: PUSH
13751: LD_INT 1
13753: PLUS
13754: ST_TO_ADDR
// if un = Abdul then
13755: LD_VAR 0 1
13759: PUSH
13760: LD_EXP 57
13764: EQUAL
13765: IFFALSE 13775
// abdul_escaped := false ;
13767: LD_ADDR_EXP 13
13771: PUSH
13772: LD_INT 0
13774: ST_TO_ADDR
// if un in ru_attackers then
13775: LD_VAR 0 1
13779: PUSH
13780: LD_EXP 54
13784: IN
13785: IFFALSE 13803
// ru_attackers := ru_attackers diff un ;
13787: LD_ADDR_EXP 54
13791: PUSH
13792: LD_EXP 54
13796: PUSH
13797: LD_VAR 0 1
13801: DIFF
13802: ST_TO_ADDR
// if un in ar_attackers then
13803: LD_VAR 0 1
13807: PUSH
13808: LD_EXP 11
13812: IN
13813: IFFALSE 13831
// ar_attackers := ar_attackers diff un ;
13815: LD_ADDR_EXP 11
13819: PUSH
13820: LD_EXP 11
13824: PUSH
13825: LD_VAR 0 1
13829: DIFF
13830: ST_TO_ADDR
// if un = JMM then
13831: LD_VAR 0 1
13835: PUSH
13836: LD_EXP 16
13840: EQUAL
13841: IFFALSE 13852
// begin YouLost ( JMM ) ;
13843: LD_STRING JMM
13845: PPUSH
13846: CALL_OW 104
// exit ;
13850: GO 13949
// end ; if un = Burlak then
13852: LD_VAR 0 1
13856: PUSH
13857: LD_EXP 48
13861: EQUAL
13862: IFFALSE 13873
// begin YouLost ( Burlak ) ;
13864: LD_STRING Burlak
13866: PPUSH
13867: CALL_OW 104
// exit ;
13871: GO 13949
// end ; if un = freedom then
13873: LD_VAR 0 1
13877: PUSH
13878: LD_EXP 3
13882: EQUAL
13883: IFFALSE 13894
// begin YouLost ( Destroyed ) ;
13885: LD_STRING Destroyed
13887: PPUSH
13888: CALL_OW 104
// exit ;
13892: GO 13949
// end ; if un = Masha then
13894: LD_VAR 0 1
13898: PUSH
13899: LD_EXP 51
13903: EQUAL
13904: IFFALSE 13921
// begin ChangeMissionObjectives ( M4b ) ;
13906: LD_STRING M4b
13908: PPUSH
13909: CALL_OW 337
// masha_killed := true ;
13913: LD_ADDR_EXP 10
13917: PUSH
13918: LD_INT 1
13920: ST_TO_ADDR
// end ; if un = Mastodont then
13921: LD_VAR 0 1
13925: PUSH
13926: LD_EXP 58
13930: EQUAL
13931: IFFALSE 13940
// ChangeMissionObjectives ( M4a ) ;
13933: LD_STRING M4a
13935: PPUSH
13936: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13940: LD_VAR 0 1
13944: PPUSH
13945: CALL 84015 0 1
// end ;
13949: PPOPN 3
13951: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13952: LD_VAR 0 1
13956: PPUSH
13957: LD_VAR 0 2
13961: PPUSH
13962: CALL 86347 0 2
// end ;
13966: PPOPN 2
13968: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13969: LD_VAR 0 1
13973: PPUSH
13974: CALL 85415 0 1
// end ;
13978: PPOPN 1
13980: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13981: LD_VAR 0 1
13985: PUSH
13986: LD_INT 22
13988: PUSH
13989: LD_INT 7
13991: PUSH
13992: EMPTY
13993: LIST
13994: LIST
13995: PUSH
13996: LD_INT 30
13998: PUSH
13999: LD_INT 0
14001: PUSH
14002: EMPTY
14003: LIST
14004: LIST
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PPUSH
14010: CALL_OW 69
14014: IN
14015: IFFALSE 14054
// begin SetBName ( building , freedom ) ;
14017: LD_VAR 0 1
14021: PPUSH
14022: LD_STRING freedom
14024: PPUSH
14025: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14029: LD_INT 0
14031: PPUSH
14032: LD_INT 7
14034: PPUSH
14035: LD_INT 0
14037: PPUSH
14038: CALL_OW 324
// freedom := building ;
14042: LD_ADDR_EXP 3
14046: PUSH
14047: LD_VAR 0 1
14051: ST_TO_ADDR
// exit ;
14052: GO 14120
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14054: LD_VAR 0 1
14058: PUSH
14059: LD_INT 22
14061: PUSH
14062: LD_INT 7
14064: PUSH
14065: EMPTY
14066: LIST
14067: LIST
14068: PUSH
14069: LD_INT 23
14071: PUSH
14072: LD_INT 3
14074: PUSH
14075: EMPTY
14076: LIST
14077: LIST
14078: PUSH
14079: LD_INT 30
14081: PUSH
14082: LD_INT 6
14084: PUSH
14085: EMPTY
14086: LIST
14087: LIST
14088: PUSH
14089: EMPTY
14090: LIST
14091: LIST
14092: LIST
14093: PPUSH
14094: CALL_OW 69
14098: IN
14099: IFFALSE 14111
// begin ru_lab_builded := true ;
14101: LD_ADDR_EXP 5
14105: PUSH
14106: LD_INT 1
14108: ST_TO_ADDR
// exit ;
14109: GO 14120
// end ; MCE_BuildingComplete ( building ) ;
14111: LD_VAR 0 1
14115: PPUSH
14116: CALL 85656 0 1
// end ;
14120: PPOPN 1
14122: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14123: LD_VAR 0 1
14127: PPUSH
14128: LD_VAR 0 2
14132: PPUSH
14133: CALL 83711 0 2
// end ;
14137: PPOPN 2
14139: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14140: LD_VAR 0 1
14144: PPUSH
14145: LD_VAR 0 2
14149: PPUSH
14150: LD_VAR 0 3
14154: PPUSH
14155: LD_VAR 0 4
14159: PPUSH
14160: LD_VAR 0 5
14164: PPUSH
14165: CALL 83331 0 5
// end ;
14169: PPOPN 5
14171: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14172: LD_VAR 0 1
14176: PPUSH
14177: LD_VAR 0 2
14181: PPUSH
14182: CALL 102768 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14186: LD_VAR 0 1
14190: PPUSH
14191: LD_VAR 0 2
14195: PPUSH
14196: CALL 82922 0 2
// end ;
14200: PPOPN 2
14202: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14203: LD_VAR 0 1
14207: PPUSH
14208: CALL_OW 263
14212: PUSH
14213: LD_INT 3
14215: EQUAL
14216: PUSH
14217: LD_VAR 0 2
14221: PPUSH
14222: CALL_OW 263
14226: PUSH
14227: LD_INT 3
14229: EQUAL
14230: OR
14231: IFFALSE 14247
// hack_counter := hack_counter + 1 ;
14233: LD_ADDR_EXP 15
14237: PUSH
14238: LD_EXP 15
14242: PUSH
14243: LD_INT 1
14245: PLUS
14246: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14247: LD_VAR 0 1
14251: PPUSH
14252: LD_VAR 0 2
14256: PPUSH
14257: LD_VAR 0 3
14261: PPUSH
14262: LD_VAR 0 4
14266: PPUSH
14267: CALL 82760 0 4
// end ;
14271: PPOPN 4
14273: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14274: LD_VAR 0 1
14278: PPUSH
14279: LD_VAR 0 2
14283: PPUSH
14284: LD_VAR 0 3
14288: PPUSH
14289: CALL 82535 0 3
// end ;
14293: PPOPN 3
14295: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14296: LD_VAR 0 1
14300: PPUSH
14301: LD_VAR 0 2
14305: PPUSH
14306: CALL 82420 0 2
// end ;
14310: PPOPN 2
14312: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14313: LD_VAR 0 1
14317: PPUSH
14318: LD_VAR 0 2
14322: PPUSH
14323: CALL 86642 0 2
// end ;
14327: PPOPN 2
14329: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14330: LD_VAR 0 1
14334: PPUSH
14335: LD_VAR 0 2
14339: PPUSH
14340: LD_VAR 0 3
14344: PPUSH
14345: LD_VAR 0 4
14349: PPUSH
14350: CALL 86858 0 4
// end ;
14354: PPOPN 4
14356: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14357: LD_VAR 0 1
14361: PPUSH
14362: LD_VAR 0 2
14366: PPUSH
14367: CALL 82229 0 2
// end ;
14371: PPOPN 2
14373: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14374: LD_VAR 0 1
14378: PPUSH
14379: CALL 102752 0 1
// end ; end_of_file
14383: PPOPN 1
14385: END
// every 0 0$30 do var cr , time ;
14386: GO 14388
14388: DISABLE
14389: LD_INT 0
14391: PPUSH
14392: PPUSH
// begin time := 0 0$20 ;
14393: LD_ADDR_VAR 0 2
14397: PUSH
14398: LD_INT 700
14400: ST_TO_ADDR
// while game do
14401: LD_EXP 2
14405: IFFALSE 14508
// begin wait ( time ) ;
14407: LD_VAR 0 2
14411: PPUSH
14412: CALL_OW 67
// if tick > 2 2$00 then
14416: LD_OWVAR 1
14420: PUSH
14421: LD_INT 4200
14423: GREATER
14424: IFFALSE 14461
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14426: LD_ADDR_VAR 0 2
14430: PUSH
14431: LD_VAR 0 2
14435: PUSH
14436: LD_INT 140
14438: PUSH
14439: LD_INT 140
14441: PUSH
14442: LD_INT 210
14444: PUSH
14445: LD_INT 280
14447: PUSH
14448: EMPTY
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: PUSH
14454: LD_OWVAR 67
14458: ARRAY
14459: PLUS
14460: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14461: LD_INT 1
14463: PPUSH
14464: LD_INT 5
14466: PPUSH
14467: CALL_OW 12
14471: PPUSH
14472: LD_INT 70
14474: PPUSH
14475: LD_INT 49
14477: PPUSH
14478: LD_INT 25
14480: PPUSH
14481: LD_INT 1
14483: PPUSH
14484: CALL_OW 56
// if time > 3 3$00 then
14488: LD_VAR 0 2
14492: PUSH
14493: LD_INT 6300
14495: GREATER
14496: IFFALSE 14506
// time := 0 0$30 ;
14498: LD_ADDR_VAR 0 2
14502: PUSH
14503: LD_INT 1050
14505: ST_TO_ADDR
// end ;
14506: GO 14401
// end ;
14508: PPOPN 2
14510: END
// every 0 0$30 do var cr , time ;
14511: GO 14513
14513: DISABLE
14514: LD_INT 0
14516: PPUSH
14517: PPUSH
// begin time := 0 0$20 ;
14518: LD_ADDR_VAR 0 2
14522: PUSH
14523: LD_INT 700
14525: ST_TO_ADDR
// while game do
14526: LD_EXP 2
14530: IFFALSE 14623
// begin wait ( time ) ;
14532: LD_VAR 0 2
14536: PPUSH
14537: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14541: LD_ADDR_VAR 0 2
14545: PUSH
14546: LD_VAR 0 2
14550: PUSH
14551: LD_INT 140
14553: PUSH
14554: LD_INT 175
14556: PUSH
14557: LD_INT 210
14559: PUSH
14560: LD_INT 280
14562: PUSH
14563: EMPTY
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: PUSH
14569: LD_OWVAR 67
14573: ARRAY
14574: PLUS
14575: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14576: LD_INT 3
14578: PPUSH
14579: LD_INT 5
14581: PPUSH
14582: CALL_OW 12
14586: PPUSH
14587: LD_INT 26
14589: PPUSH
14590: LD_INT 9
14592: PPUSH
14593: LD_INT 30
14595: PPUSH
14596: LD_INT 1
14598: PPUSH
14599: CALL_OW 56
// if time > 3 3$00 then
14603: LD_VAR 0 2
14607: PUSH
14608: LD_INT 6300
14610: GREATER
14611: IFFALSE 14621
// time := 0 0$20 ;
14613: LD_ADDR_VAR 0 2
14617: PUSH
14618: LD_INT 700
14620: ST_TO_ADDR
// end ;
14621: GO 14526
// end ;
14623: PPOPN 2
14625: END
// every 0 0$30 do var cr , time ;
14626: GO 14628
14628: DISABLE
14629: LD_INT 0
14631: PPUSH
14632: PPUSH
// begin time := 0 0$20 ;
14633: LD_ADDR_VAR 0 2
14637: PUSH
14638: LD_INT 700
14640: ST_TO_ADDR
// while game do
14641: LD_EXP 2
14645: IFFALSE 14774
// begin wait ( time ) ;
14647: LD_VAR 0 2
14651: PPUSH
14652: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14656: LD_ADDR_VAR 0 2
14660: PUSH
14661: LD_VAR 0 2
14665: PUSH
14666: LD_INT 175
14668: PUSH
14669: LD_INT 210
14671: PUSH
14672: LD_INT 280
14674: PUSH
14675: LD_INT 350
14677: PUSH
14678: EMPTY
14679: LIST
14680: LIST
14681: LIST
14682: LIST
14683: PUSH
14684: LD_OWVAR 67
14688: ARRAY
14689: PLUS
14690: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14691: LD_INT 1
14693: PPUSH
14694: LD_INT 5
14696: PPUSH
14697: CALL_OW 12
14701: PPUSH
14702: LD_INT 179
14704: PPUSH
14705: LD_INT 101
14707: PPUSH
14708: LD_INT 20
14710: PPUSH
14711: LD_INT 1
14713: PPUSH
14714: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14718: LD_INT 350
14720: PPUSH
14721: LD_INT 525
14723: PPUSH
14724: CALL_OW 12
14728: PPUSH
14729: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14733: LD_INT 1
14735: PPUSH
14736: LD_INT 5
14738: PPUSH
14739: CALL_OW 12
14743: PPUSH
14744: LD_INT 9
14746: PPUSH
14747: LD_INT 1
14749: PPUSH
14750: CALL_OW 55
// if time > 4 4$00 then
14754: LD_VAR 0 2
14758: PUSH
14759: LD_INT 8400
14761: GREATER
14762: IFFALSE 14772
// time := 0 0$30 ;
14764: LD_ADDR_VAR 0 2
14768: PUSH
14769: LD_INT 1050
14771: ST_TO_ADDR
// end ;
14772: GO 14641
// end ;
14774: PPOPN 2
14776: END
// every 0 0$30 do var cr , time ;
14777: GO 14779
14779: DISABLE
14780: LD_INT 0
14782: PPUSH
14783: PPUSH
// begin time := 0 0$10 ;
14784: LD_ADDR_VAR 0 2
14788: PUSH
14789: LD_INT 350
14791: ST_TO_ADDR
// while game do
14792: LD_EXP 2
14796: IFFALSE 14930
// begin wait ( time ) ;
14798: LD_VAR 0 2
14802: PPUSH
14803: CALL_OW 67
// time := time + 0 0$10 ;
14807: LD_ADDR_VAR 0 2
14811: PUSH
14812: LD_VAR 0 2
14816: PUSH
14817: LD_INT 350
14819: PLUS
14820: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14821: LD_INT 1
14823: PPUSH
14824: LD_INT 5
14826: PPUSH
14827: CALL_OW 12
14831: PPUSH
14832: LD_INT 11
14834: PPUSH
14835: LD_INT 1
14837: PPUSH
14838: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14842: LD_ADDR_VAR 0 1
14846: PUSH
14847: LD_INT 1
14849: PPUSH
14850: LD_INT 3
14852: PPUSH
14853: CALL_OW 12
14857: ST_TO_ADDR
// if cr = 1 then
14858: LD_VAR 0 1
14862: PUSH
14863: LD_INT 1
14865: EQUAL
14866: IFFALSE 14910
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14868: LD_INT 700
14870: PPUSH
14871: LD_INT 1575
14873: PPUSH
14874: CALL_OW 12
14878: PPUSH
14879: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14883: LD_INT 1
14885: PPUSH
14886: LD_INT 5
14888: PPUSH
14889: CALL_OW 12
14893: PPUSH
14894: LD_INT 34
14896: PPUSH
14897: LD_INT 50
14899: PPUSH
14900: LD_INT 7
14902: PPUSH
14903: LD_INT 1
14905: PPUSH
14906: CALL_OW 56
// end ; if time > 4 4$00 then
14910: LD_VAR 0 2
14914: PUSH
14915: LD_INT 8400
14917: GREATER
14918: IFFALSE 14928
// time := 0 0$40 ;
14920: LD_ADDR_VAR 0 2
14924: PUSH
14925: LD_INT 1400
14927: ST_TO_ADDR
// end ;
14928: GO 14792
// end ; end_of_file
14930: PPOPN 2
14932: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14933: LD_INT 0
14935: PPUSH
14936: PPUSH
// if exist_mode then
14937: LD_VAR 0 2
14941: IFFALSE 14966
// unit := CreateCharacter ( prefix & ident ) else
14943: LD_ADDR_VAR 0 5
14947: PUSH
14948: LD_VAR 0 3
14952: PUSH
14953: LD_VAR 0 1
14957: STR
14958: PPUSH
14959: CALL_OW 34
14963: ST_TO_ADDR
14964: GO 14981
// unit := NewCharacter ( ident ) ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_VAR 0 1
14975: PPUSH
14976: CALL_OW 25
14980: ST_TO_ADDR
// result := unit ;
14981: LD_ADDR_VAR 0 4
14985: PUSH
14986: LD_VAR 0 5
14990: ST_TO_ADDR
// end ;
14991: LD_VAR 0 4
14995: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14996: LD_INT 0
14998: PPUSH
14999: PPUSH
// if not side or not nation then
15000: LD_VAR 0 1
15004: NOT
15005: PUSH
15006: LD_VAR 0 2
15010: NOT
15011: OR
15012: IFFALSE 15016
// exit ;
15014: GO 15784
// case nation of nation_american :
15016: LD_VAR 0 2
15020: PUSH
15021: LD_INT 1
15023: DOUBLE
15024: EQUAL
15025: IFTRUE 15029
15027: GO 15243
15029: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15030: LD_ADDR_VAR 0 4
15034: PUSH
15035: LD_INT 35
15037: PUSH
15038: LD_INT 45
15040: PUSH
15041: LD_INT 46
15043: PUSH
15044: LD_INT 47
15046: PUSH
15047: LD_INT 82
15049: PUSH
15050: LD_INT 83
15052: PUSH
15053: LD_INT 84
15055: PUSH
15056: LD_INT 85
15058: PUSH
15059: LD_INT 86
15061: PUSH
15062: LD_INT 1
15064: PUSH
15065: LD_INT 2
15067: PUSH
15068: LD_INT 6
15070: PUSH
15071: LD_INT 15
15073: PUSH
15074: LD_INT 16
15076: PUSH
15077: LD_INT 7
15079: PUSH
15080: LD_INT 12
15082: PUSH
15083: LD_INT 13
15085: PUSH
15086: LD_INT 10
15088: PUSH
15089: LD_INT 14
15091: PUSH
15092: LD_INT 20
15094: PUSH
15095: LD_INT 21
15097: PUSH
15098: LD_INT 22
15100: PUSH
15101: LD_INT 25
15103: PUSH
15104: LD_INT 32
15106: PUSH
15107: LD_INT 27
15109: PUSH
15110: LD_INT 36
15112: PUSH
15113: LD_INT 69
15115: PUSH
15116: LD_INT 39
15118: PUSH
15119: LD_INT 34
15121: PUSH
15122: LD_INT 40
15124: PUSH
15125: LD_INT 48
15127: PUSH
15128: LD_INT 49
15130: PUSH
15131: LD_INT 50
15133: PUSH
15134: LD_INT 51
15136: PUSH
15137: LD_INT 52
15139: PUSH
15140: LD_INT 53
15142: PUSH
15143: LD_INT 54
15145: PUSH
15146: LD_INT 55
15148: PUSH
15149: LD_INT 56
15151: PUSH
15152: LD_INT 57
15154: PUSH
15155: LD_INT 58
15157: PUSH
15158: LD_INT 59
15160: PUSH
15161: LD_INT 60
15163: PUSH
15164: LD_INT 61
15166: PUSH
15167: LD_INT 62
15169: PUSH
15170: LD_INT 80
15172: PUSH
15173: LD_INT 82
15175: PUSH
15176: LD_INT 83
15178: PUSH
15179: LD_INT 84
15181: PUSH
15182: LD_INT 85
15184: PUSH
15185: LD_INT 86
15187: PUSH
15188: EMPTY
15189: LIST
15190: LIST
15191: LIST
15192: LIST
15193: LIST
15194: LIST
15195: LIST
15196: LIST
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: LIST
15202: LIST
15203: LIST
15204: LIST
15205: LIST
15206: LIST
15207: LIST
15208: LIST
15209: LIST
15210: LIST
15211: LIST
15212: LIST
15213: LIST
15214: LIST
15215: LIST
15216: LIST
15217: LIST
15218: LIST
15219: LIST
15220: LIST
15221: LIST
15222: LIST
15223: LIST
15224: LIST
15225: LIST
15226: LIST
15227: LIST
15228: LIST
15229: LIST
15230: LIST
15231: LIST
15232: LIST
15233: LIST
15234: LIST
15235: LIST
15236: LIST
15237: LIST
15238: LIST
15239: LIST
15240: ST_TO_ADDR
15241: GO 15708
15243: LD_INT 2
15245: DOUBLE
15246: EQUAL
15247: IFTRUE 15251
15249: GO 15477
15251: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15252: LD_ADDR_VAR 0 4
15256: PUSH
15257: LD_INT 35
15259: PUSH
15260: LD_INT 45
15262: PUSH
15263: LD_INT 46
15265: PUSH
15266: LD_INT 47
15268: PUSH
15269: LD_INT 82
15271: PUSH
15272: LD_INT 83
15274: PUSH
15275: LD_INT 84
15277: PUSH
15278: LD_INT 85
15280: PUSH
15281: LD_INT 87
15283: PUSH
15284: LD_INT 70
15286: PUSH
15287: LD_INT 1
15289: PUSH
15290: LD_INT 11
15292: PUSH
15293: LD_INT 3
15295: PUSH
15296: LD_INT 4
15298: PUSH
15299: LD_INT 5
15301: PUSH
15302: LD_INT 6
15304: PUSH
15305: LD_INT 15
15307: PUSH
15308: LD_INT 18
15310: PUSH
15311: LD_INT 7
15313: PUSH
15314: LD_INT 17
15316: PUSH
15317: LD_INT 8
15319: PUSH
15320: LD_INT 20
15322: PUSH
15323: LD_INT 21
15325: PUSH
15326: LD_INT 22
15328: PUSH
15329: LD_INT 72
15331: PUSH
15332: LD_INT 26
15334: PUSH
15335: LD_INT 69
15337: PUSH
15338: LD_INT 39
15340: PUSH
15341: LD_INT 40
15343: PUSH
15344: LD_INT 41
15346: PUSH
15347: LD_INT 42
15349: PUSH
15350: LD_INT 43
15352: PUSH
15353: LD_INT 48
15355: PUSH
15356: LD_INT 49
15358: PUSH
15359: LD_INT 50
15361: PUSH
15362: LD_INT 51
15364: PUSH
15365: LD_INT 52
15367: PUSH
15368: LD_INT 53
15370: PUSH
15371: LD_INT 54
15373: PUSH
15374: LD_INT 55
15376: PUSH
15377: LD_INT 56
15379: PUSH
15380: LD_INT 60
15382: PUSH
15383: LD_INT 61
15385: PUSH
15386: LD_INT 62
15388: PUSH
15389: LD_INT 66
15391: PUSH
15392: LD_INT 67
15394: PUSH
15395: LD_INT 68
15397: PUSH
15398: LD_INT 81
15400: PUSH
15401: LD_INT 82
15403: PUSH
15404: LD_INT 83
15406: PUSH
15407: LD_INT 84
15409: PUSH
15410: LD_INT 85
15412: PUSH
15413: LD_INT 87
15415: PUSH
15416: LD_INT 88
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: LIST
15423: LIST
15424: LIST
15425: LIST
15426: LIST
15427: LIST
15428: LIST
15429: LIST
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: LIST
15435: LIST
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: LIST
15444: LIST
15445: LIST
15446: LIST
15447: LIST
15448: LIST
15449: LIST
15450: LIST
15451: LIST
15452: LIST
15453: LIST
15454: LIST
15455: LIST
15456: LIST
15457: LIST
15458: LIST
15459: LIST
15460: LIST
15461: LIST
15462: LIST
15463: LIST
15464: LIST
15465: LIST
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: LIST
15471: LIST
15472: LIST
15473: LIST
15474: ST_TO_ADDR
15475: GO 15708
15477: LD_INT 3
15479: DOUBLE
15480: EQUAL
15481: IFTRUE 15485
15483: GO 15707
15485: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15486: LD_ADDR_VAR 0 4
15490: PUSH
15491: LD_INT 46
15493: PUSH
15494: LD_INT 47
15496: PUSH
15497: LD_INT 1
15499: PUSH
15500: LD_INT 2
15502: PUSH
15503: LD_INT 82
15505: PUSH
15506: LD_INT 83
15508: PUSH
15509: LD_INT 84
15511: PUSH
15512: LD_INT 85
15514: PUSH
15515: LD_INT 86
15517: PUSH
15518: LD_INT 11
15520: PUSH
15521: LD_INT 9
15523: PUSH
15524: LD_INT 20
15526: PUSH
15527: LD_INT 19
15529: PUSH
15530: LD_INT 21
15532: PUSH
15533: LD_INT 24
15535: PUSH
15536: LD_INT 22
15538: PUSH
15539: LD_INT 25
15541: PUSH
15542: LD_INT 28
15544: PUSH
15545: LD_INT 29
15547: PUSH
15548: LD_INT 30
15550: PUSH
15551: LD_INT 31
15553: PUSH
15554: LD_INT 37
15556: PUSH
15557: LD_INT 38
15559: PUSH
15560: LD_INT 32
15562: PUSH
15563: LD_INT 27
15565: PUSH
15566: LD_INT 33
15568: PUSH
15569: LD_INT 69
15571: PUSH
15572: LD_INT 39
15574: PUSH
15575: LD_INT 34
15577: PUSH
15578: LD_INT 40
15580: PUSH
15581: LD_INT 71
15583: PUSH
15584: LD_INT 23
15586: PUSH
15587: LD_INT 44
15589: PUSH
15590: LD_INT 48
15592: PUSH
15593: LD_INT 49
15595: PUSH
15596: LD_INT 50
15598: PUSH
15599: LD_INT 51
15601: PUSH
15602: LD_INT 52
15604: PUSH
15605: LD_INT 53
15607: PUSH
15608: LD_INT 54
15610: PUSH
15611: LD_INT 55
15613: PUSH
15614: LD_INT 56
15616: PUSH
15617: LD_INT 57
15619: PUSH
15620: LD_INT 58
15622: PUSH
15623: LD_INT 59
15625: PUSH
15626: LD_INT 63
15628: PUSH
15629: LD_INT 64
15631: PUSH
15632: LD_INT 65
15634: PUSH
15635: LD_INT 82
15637: PUSH
15638: LD_INT 83
15640: PUSH
15641: LD_INT 84
15643: PUSH
15644: LD_INT 85
15646: PUSH
15647: LD_INT 86
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: LIST
15654: LIST
15655: LIST
15656: LIST
15657: LIST
15658: LIST
15659: LIST
15660: LIST
15661: LIST
15662: LIST
15663: LIST
15664: LIST
15665: LIST
15666: LIST
15667: LIST
15668: LIST
15669: LIST
15670: LIST
15671: LIST
15672: LIST
15673: LIST
15674: LIST
15675: LIST
15676: LIST
15677: LIST
15678: LIST
15679: LIST
15680: LIST
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: LIST
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: LIST
15700: LIST
15701: LIST
15702: LIST
15703: LIST
15704: ST_TO_ADDR
15705: GO 15708
15707: POP
// if state > - 1 and state < 3 then
15708: LD_VAR 0 3
15712: PUSH
15713: LD_INT 1
15715: NEG
15716: GREATER
15717: PUSH
15718: LD_VAR 0 3
15722: PUSH
15723: LD_INT 3
15725: LESS
15726: AND
15727: IFFALSE 15784
// for i in result do
15729: LD_ADDR_VAR 0 5
15733: PUSH
15734: LD_VAR 0 4
15738: PUSH
15739: FOR_IN
15740: IFFALSE 15782
// if GetTech ( i , side ) <> state then
15742: LD_VAR 0 5
15746: PPUSH
15747: LD_VAR 0 1
15751: PPUSH
15752: CALL_OW 321
15756: PUSH
15757: LD_VAR 0 3
15761: NONEQUAL
15762: IFFALSE 15780
// result := result diff i ;
15764: LD_ADDR_VAR 0 4
15768: PUSH
15769: LD_VAR 0 4
15773: PUSH
15774: LD_VAR 0 5
15778: DIFF
15779: ST_TO_ADDR
15780: GO 15739
15782: POP
15783: POP
// end ;
15784: LD_VAR 0 4
15788: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15789: LD_INT 0
15791: PPUSH
15792: PPUSH
15793: PPUSH
// result := true ;
15794: LD_ADDR_VAR 0 3
15798: PUSH
15799: LD_INT 1
15801: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15802: LD_ADDR_VAR 0 5
15806: PUSH
15807: LD_VAR 0 2
15811: PPUSH
15812: CALL_OW 480
15816: ST_TO_ADDR
// if not tmp then
15817: LD_VAR 0 5
15821: NOT
15822: IFFALSE 15826
// exit ;
15824: GO 15875
// for i in tmp do
15826: LD_ADDR_VAR 0 4
15830: PUSH
15831: LD_VAR 0 5
15835: PUSH
15836: FOR_IN
15837: IFFALSE 15873
// if GetTech ( i , side ) <> state_researched then
15839: LD_VAR 0 4
15843: PPUSH
15844: LD_VAR 0 1
15848: PPUSH
15849: CALL_OW 321
15853: PUSH
15854: LD_INT 2
15856: NONEQUAL
15857: IFFALSE 15871
// begin result := false ;
15859: LD_ADDR_VAR 0 3
15863: PUSH
15864: LD_INT 0
15866: ST_TO_ADDR
// exit ;
15867: POP
15868: POP
15869: GO 15875
// end ;
15871: GO 15836
15873: POP
15874: POP
// end ;
15875: LD_VAR 0 3
15879: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15880: LD_INT 0
15882: PPUSH
15883: PPUSH
15884: PPUSH
15885: PPUSH
15886: PPUSH
15887: PPUSH
15888: PPUSH
15889: PPUSH
15890: PPUSH
15891: PPUSH
15892: PPUSH
15893: PPUSH
15894: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15895: LD_VAR 0 1
15899: NOT
15900: PUSH
15901: LD_VAR 0 1
15905: PPUSH
15906: CALL_OW 257
15910: PUSH
15911: LD_INT 9
15913: NONEQUAL
15914: OR
15915: IFFALSE 15919
// exit ;
15917: GO 16492
// side := GetSide ( unit ) ;
15919: LD_ADDR_VAR 0 9
15923: PUSH
15924: LD_VAR 0 1
15928: PPUSH
15929: CALL_OW 255
15933: ST_TO_ADDR
// tech_space := tech_spacanom ;
15934: LD_ADDR_VAR 0 12
15938: PUSH
15939: LD_INT 29
15941: ST_TO_ADDR
// tech_time := tech_taurad ;
15942: LD_ADDR_VAR 0 13
15946: PUSH
15947: LD_INT 28
15949: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15950: LD_ADDR_VAR 0 11
15954: PUSH
15955: LD_VAR 0 1
15959: PPUSH
15960: CALL_OW 310
15964: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15965: LD_VAR 0 11
15969: PPUSH
15970: CALL_OW 247
15974: PUSH
15975: LD_INT 2
15977: EQUAL
15978: IFFALSE 15982
// exit ;
15980: GO 16492
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15982: LD_ADDR_VAR 0 8
15986: PUSH
15987: LD_INT 81
15989: PUSH
15990: LD_VAR 0 9
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: PUSH
15999: LD_INT 3
16001: PUSH
16002: LD_INT 21
16004: PUSH
16005: LD_INT 3
16007: PUSH
16008: EMPTY
16009: LIST
16010: LIST
16011: PUSH
16012: EMPTY
16013: LIST
16014: LIST
16015: PUSH
16016: EMPTY
16017: LIST
16018: LIST
16019: PPUSH
16020: CALL_OW 69
16024: ST_TO_ADDR
// if not tmp then
16025: LD_VAR 0 8
16029: NOT
16030: IFFALSE 16034
// exit ;
16032: GO 16492
// if in_unit then
16034: LD_VAR 0 11
16038: IFFALSE 16062
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16040: LD_ADDR_VAR 0 10
16044: PUSH
16045: LD_VAR 0 8
16049: PPUSH
16050: LD_VAR 0 11
16054: PPUSH
16055: CALL_OW 74
16059: ST_TO_ADDR
16060: GO 16082
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16062: LD_ADDR_VAR 0 10
16066: PUSH
16067: LD_VAR 0 8
16071: PPUSH
16072: LD_VAR 0 1
16076: PPUSH
16077: CALL_OW 74
16081: ST_TO_ADDR
// if not enemy then
16082: LD_VAR 0 10
16086: NOT
16087: IFFALSE 16091
// exit ;
16089: GO 16492
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16091: LD_VAR 0 11
16095: PUSH
16096: LD_VAR 0 11
16100: PPUSH
16101: LD_VAR 0 10
16105: PPUSH
16106: CALL_OW 296
16110: PUSH
16111: LD_INT 13
16113: GREATER
16114: AND
16115: PUSH
16116: LD_VAR 0 1
16120: PPUSH
16121: LD_VAR 0 10
16125: PPUSH
16126: CALL_OW 296
16130: PUSH
16131: LD_INT 12
16133: GREATER
16134: OR
16135: IFFALSE 16139
// exit ;
16137: GO 16492
// missile := [ 1 ] ;
16139: LD_ADDR_VAR 0 14
16143: PUSH
16144: LD_INT 1
16146: PUSH
16147: EMPTY
16148: LIST
16149: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16150: LD_VAR 0 9
16154: PPUSH
16155: LD_VAR 0 12
16159: PPUSH
16160: CALL_OW 325
16164: IFFALSE 16193
// missile := Replace ( missile , missile + 1 , 2 ) ;
16166: LD_ADDR_VAR 0 14
16170: PUSH
16171: LD_VAR 0 14
16175: PPUSH
16176: LD_VAR 0 14
16180: PUSH
16181: LD_INT 1
16183: PLUS
16184: PPUSH
16185: LD_INT 2
16187: PPUSH
16188: CALL_OW 1
16192: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16193: LD_VAR 0 9
16197: PPUSH
16198: LD_VAR 0 13
16202: PPUSH
16203: CALL_OW 325
16207: PUSH
16208: LD_VAR 0 10
16212: PPUSH
16213: CALL_OW 255
16217: PPUSH
16218: LD_VAR 0 13
16222: PPUSH
16223: CALL_OW 325
16227: NOT
16228: AND
16229: IFFALSE 16258
// missile := Replace ( missile , missile + 1 , 3 ) ;
16231: LD_ADDR_VAR 0 14
16235: PUSH
16236: LD_VAR 0 14
16240: PPUSH
16241: LD_VAR 0 14
16245: PUSH
16246: LD_INT 1
16248: PLUS
16249: PPUSH
16250: LD_INT 3
16252: PPUSH
16253: CALL_OW 1
16257: ST_TO_ADDR
// if missile < 2 then
16258: LD_VAR 0 14
16262: PUSH
16263: LD_INT 2
16265: LESS
16266: IFFALSE 16270
// exit ;
16268: GO 16492
// x := GetX ( enemy ) ;
16270: LD_ADDR_VAR 0 4
16274: PUSH
16275: LD_VAR 0 10
16279: PPUSH
16280: CALL_OW 250
16284: ST_TO_ADDR
// y := GetY ( enemy ) ;
16285: LD_ADDR_VAR 0 5
16289: PUSH
16290: LD_VAR 0 10
16294: PPUSH
16295: CALL_OW 251
16299: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16300: LD_ADDR_VAR 0 6
16304: PUSH
16305: LD_VAR 0 4
16309: PUSH
16310: LD_INT 1
16312: NEG
16313: PPUSH
16314: LD_INT 1
16316: PPUSH
16317: CALL_OW 12
16321: PLUS
16322: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16323: LD_ADDR_VAR 0 7
16327: PUSH
16328: LD_VAR 0 5
16332: PUSH
16333: LD_INT 1
16335: NEG
16336: PPUSH
16337: LD_INT 1
16339: PPUSH
16340: CALL_OW 12
16344: PLUS
16345: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16346: LD_VAR 0 6
16350: PPUSH
16351: LD_VAR 0 7
16355: PPUSH
16356: CALL_OW 488
16360: NOT
16361: IFFALSE 16383
// begin _x := x ;
16363: LD_ADDR_VAR 0 6
16367: PUSH
16368: LD_VAR 0 4
16372: ST_TO_ADDR
// _y := y ;
16373: LD_ADDR_VAR 0 7
16377: PUSH
16378: LD_VAR 0 5
16382: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16383: LD_ADDR_VAR 0 3
16387: PUSH
16388: LD_INT 1
16390: PPUSH
16391: LD_VAR 0 14
16395: PPUSH
16396: CALL_OW 12
16400: ST_TO_ADDR
// case i of 1 :
16401: LD_VAR 0 3
16405: PUSH
16406: LD_INT 1
16408: DOUBLE
16409: EQUAL
16410: IFTRUE 16414
16412: GO 16431
16414: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16415: LD_VAR 0 1
16419: PPUSH
16420: LD_VAR 0 10
16424: PPUSH
16425: CALL_OW 115
16429: GO 16492
16431: LD_INT 2
16433: DOUBLE
16434: EQUAL
16435: IFTRUE 16439
16437: GO 16461
16439: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16440: LD_VAR 0 1
16444: PPUSH
16445: LD_VAR 0 6
16449: PPUSH
16450: LD_VAR 0 7
16454: PPUSH
16455: CALL_OW 153
16459: GO 16492
16461: LD_INT 3
16463: DOUBLE
16464: EQUAL
16465: IFTRUE 16469
16467: GO 16491
16469: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16470: LD_VAR 0 1
16474: PPUSH
16475: LD_VAR 0 6
16479: PPUSH
16480: LD_VAR 0 7
16484: PPUSH
16485: CALL_OW 154
16489: GO 16492
16491: POP
// end ;
16492: LD_VAR 0 2
16496: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16497: LD_INT 0
16499: PPUSH
16500: PPUSH
16501: PPUSH
16502: PPUSH
16503: PPUSH
16504: PPUSH
// if not unit or not building then
16505: LD_VAR 0 1
16509: NOT
16510: PUSH
16511: LD_VAR 0 2
16515: NOT
16516: OR
16517: IFFALSE 16521
// exit ;
16519: GO 16679
// x := GetX ( building ) ;
16521: LD_ADDR_VAR 0 5
16525: PUSH
16526: LD_VAR 0 2
16530: PPUSH
16531: CALL_OW 250
16535: ST_TO_ADDR
// y := GetY ( building ) ;
16536: LD_ADDR_VAR 0 6
16540: PUSH
16541: LD_VAR 0 2
16545: PPUSH
16546: CALL_OW 251
16550: ST_TO_ADDR
// for i = 0 to 5 do
16551: LD_ADDR_VAR 0 4
16555: PUSH
16556: DOUBLE
16557: LD_INT 0
16559: DEC
16560: ST_TO_ADDR
16561: LD_INT 5
16563: PUSH
16564: FOR_TO
16565: IFFALSE 16677
// begin _x := ShiftX ( x , i , 3 ) ;
16567: LD_ADDR_VAR 0 7
16571: PUSH
16572: LD_VAR 0 5
16576: PPUSH
16577: LD_VAR 0 4
16581: PPUSH
16582: LD_INT 3
16584: PPUSH
16585: CALL_OW 272
16589: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16590: LD_ADDR_VAR 0 8
16594: PUSH
16595: LD_VAR 0 6
16599: PPUSH
16600: LD_VAR 0 4
16604: PPUSH
16605: LD_INT 3
16607: PPUSH
16608: CALL_OW 273
16612: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16613: LD_VAR 0 7
16617: PPUSH
16618: LD_VAR 0 8
16622: PPUSH
16623: CALL_OW 488
16627: NOT
16628: IFFALSE 16632
// continue ;
16630: GO 16564
// if HexInfo ( _x , _y ) = 0 then
16632: LD_VAR 0 7
16636: PPUSH
16637: LD_VAR 0 8
16641: PPUSH
16642: CALL_OW 428
16646: PUSH
16647: LD_INT 0
16649: EQUAL
16650: IFFALSE 16675
// begin ComMoveXY ( unit , _x , _y ) ;
16652: LD_VAR 0 1
16656: PPUSH
16657: LD_VAR 0 7
16661: PPUSH
16662: LD_VAR 0 8
16666: PPUSH
16667: CALL_OW 111
// exit ;
16671: POP
16672: POP
16673: GO 16679
// end ; end ;
16675: GO 16564
16677: POP
16678: POP
// end ;
16679: LD_VAR 0 3
16683: RET
// export function ScanBase ( side , base_area ) ; begin
16684: LD_INT 0
16686: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16687: LD_ADDR_VAR 0 3
16691: PUSH
16692: LD_VAR 0 2
16696: PPUSH
16697: LD_INT 81
16699: PUSH
16700: LD_VAR 0 1
16704: PUSH
16705: EMPTY
16706: LIST
16707: LIST
16708: PPUSH
16709: CALL_OW 70
16713: ST_TO_ADDR
// end ;
16714: LD_VAR 0 3
16718: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16719: LD_INT 0
16721: PPUSH
16722: PPUSH
16723: PPUSH
16724: PPUSH
// result := false ;
16725: LD_ADDR_VAR 0 2
16729: PUSH
16730: LD_INT 0
16732: ST_TO_ADDR
// side := GetSide ( unit ) ;
16733: LD_ADDR_VAR 0 3
16737: PUSH
16738: LD_VAR 0 1
16742: PPUSH
16743: CALL_OW 255
16747: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16748: LD_ADDR_VAR 0 4
16752: PUSH
16753: LD_VAR 0 1
16757: PPUSH
16758: CALL_OW 248
16762: ST_TO_ADDR
// case nat of 1 :
16763: LD_VAR 0 4
16767: PUSH
16768: LD_INT 1
16770: DOUBLE
16771: EQUAL
16772: IFTRUE 16776
16774: GO 16787
16776: POP
// tech := tech_lassight ; 2 :
16777: LD_ADDR_VAR 0 5
16781: PUSH
16782: LD_INT 12
16784: ST_TO_ADDR
16785: GO 16826
16787: LD_INT 2
16789: DOUBLE
16790: EQUAL
16791: IFTRUE 16795
16793: GO 16806
16795: POP
// tech := tech_mortar ; 3 :
16796: LD_ADDR_VAR 0 5
16800: PUSH
16801: LD_INT 41
16803: ST_TO_ADDR
16804: GO 16826
16806: LD_INT 3
16808: DOUBLE
16809: EQUAL
16810: IFTRUE 16814
16812: GO 16825
16814: POP
// tech := tech_bazooka ; end ;
16815: LD_ADDR_VAR 0 5
16819: PUSH
16820: LD_INT 44
16822: ST_TO_ADDR
16823: GO 16826
16825: POP
// if Researched ( side , tech ) then
16826: LD_VAR 0 3
16830: PPUSH
16831: LD_VAR 0 5
16835: PPUSH
16836: CALL_OW 325
16840: IFFALSE 16867
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16842: LD_ADDR_VAR 0 2
16846: PUSH
16847: LD_INT 5
16849: PUSH
16850: LD_INT 8
16852: PUSH
16853: LD_INT 9
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: LIST
16860: PUSH
16861: LD_VAR 0 4
16865: ARRAY
16866: ST_TO_ADDR
// end ;
16867: LD_VAR 0 2
16871: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16872: LD_INT 0
16874: PPUSH
16875: PPUSH
16876: PPUSH
// if not mines then
16877: LD_VAR 0 2
16881: NOT
16882: IFFALSE 16886
// exit ;
16884: GO 17030
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16886: LD_ADDR_VAR 0 5
16890: PUSH
16891: LD_INT 81
16893: PUSH
16894: LD_VAR 0 1
16898: PUSH
16899: EMPTY
16900: LIST
16901: LIST
16902: PUSH
16903: LD_INT 3
16905: PUSH
16906: LD_INT 21
16908: PUSH
16909: LD_INT 3
16911: PUSH
16912: EMPTY
16913: LIST
16914: LIST
16915: PUSH
16916: EMPTY
16917: LIST
16918: LIST
16919: PUSH
16920: EMPTY
16921: LIST
16922: LIST
16923: PPUSH
16924: CALL_OW 69
16928: ST_TO_ADDR
// for i in mines do
16929: LD_ADDR_VAR 0 4
16933: PUSH
16934: LD_VAR 0 2
16938: PUSH
16939: FOR_IN
16940: IFFALSE 17028
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16942: LD_VAR 0 4
16946: PUSH
16947: LD_INT 1
16949: ARRAY
16950: PPUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_INT 2
16958: ARRAY
16959: PPUSH
16960: CALL_OW 458
16964: NOT
16965: IFFALSE 16969
// continue ;
16967: GO 16939
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16969: LD_VAR 0 4
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PUSH
16983: LD_INT 2
16985: ARRAY
16986: PPUSH
16987: CALL_OW 428
16991: PUSH
16992: LD_VAR 0 5
16996: IN
16997: IFFALSE 17026
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16999: LD_VAR 0 4
17003: PUSH
17004: LD_INT 1
17006: ARRAY
17007: PPUSH
17008: LD_VAR 0 4
17012: PUSH
17013: LD_INT 2
17015: ARRAY
17016: PPUSH
17017: LD_VAR 0 1
17021: PPUSH
17022: CALL_OW 456
// end ;
17026: GO 16939
17028: POP
17029: POP
// end ;
17030: LD_VAR 0 3
17034: RET
// export function Count ( array ) ; var i ; begin
17035: LD_INT 0
17037: PPUSH
17038: PPUSH
// result := 0 ;
17039: LD_ADDR_VAR 0 2
17043: PUSH
17044: LD_INT 0
17046: ST_TO_ADDR
// for i in array do
17047: LD_ADDR_VAR 0 3
17051: PUSH
17052: LD_VAR 0 1
17056: PUSH
17057: FOR_IN
17058: IFFALSE 17082
// if i then
17060: LD_VAR 0 3
17064: IFFALSE 17080
// result := result + 1 ;
17066: LD_ADDR_VAR 0 2
17070: PUSH
17071: LD_VAR 0 2
17075: PUSH
17076: LD_INT 1
17078: PLUS
17079: ST_TO_ADDR
17080: GO 17057
17082: POP
17083: POP
// end ;
17084: LD_VAR 0 2
17088: RET
// export function IsEmpty ( building ) ; begin
17089: LD_INT 0
17091: PPUSH
// if not building then
17092: LD_VAR 0 1
17096: NOT
17097: IFFALSE 17101
// exit ;
17099: GO 17144
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17101: LD_ADDR_VAR 0 2
17105: PUSH
17106: LD_VAR 0 1
17110: PUSH
17111: LD_INT 22
17113: PUSH
17114: LD_VAR 0 1
17118: PPUSH
17119: CALL_OW 255
17123: PUSH
17124: EMPTY
17125: LIST
17126: LIST
17127: PUSH
17128: LD_INT 58
17130: PUSH
17131: EMPTY
17132: LIST
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PPUSH
17138: CALL_OW 69
17142: IN
17143: ST_TO_ADDR
// end ;
17144: LD_VAR 0 2
17148: RET
// export function IsNotFull ( building ) ; var places ; begin
17149: LD_INT 0
17151: PPUSH
17152: PPUSH
// if not building then
17153: LD_VAR 0 1
17157: NOT
17158: IFFALSE 17162
// exit ;
17160: GO 17333
// result := false ;
17162: LD_ADDR_VAR 0 2
17166: PUSH
17167: LD_INT 0
17169: ST_TO_ADDR
// places := 0 ;
17170: LD_ADDR_VAR 0 3
17174: PUSH
17175: LD_INT 0
17177: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17178: LD_VAR 0 1
17182: PPUSH
17183: CALL_OW 266
17187: PUSH
17188: LD_INT 0
17190: DOUBLE
17191: EQUAL
17192: IFTRUE 17250
17194: LD_INT 1
17196: DOUBLE
17197: EQUAL
17198: IFTRUE 17250
17200: LD_INT 6
17202: DOUBLE
17203: EQUAL
17204: IFTRUE 17250
17206: LD_INT 7
17208: DOUBLE
17209: EQUAL
17210: IFTRUE 17250
17212: LD_INT 8
17214: DOUBLE
17215: EQUAL
17216: IFTRUE 17250
17218: LD_INT 4
17220: DOUBLE
17221: EQUAL
17222: IFTRUE 17250
17224: LD_INT 5
17226: DOUBLE
17227: EQUAL
17228: IFTRUE 17250
17230: LD_INT 2
17232: DOUBLE
17233: EQUAL
17234: IFTRUE 17250
17236: LD_INT 3
17238: DOUBLE
17239: EQUAL
17240: IFTRUE 17250
17242: LD_INT 35
17244: DOUBLE
17245: EQUAL
17246: IFTRUE 17250
17248: GO 17261
17250: POP
// places := 6 ; b_bunker , b_breastwork :
17251: LD_ADDR_VAR 0 3
17255: PUSH
17256: LD_INT 6
17258: ST_TO_ADDR
17259: GO 17306
17261: LD_INT 32
17263: DOUBLE
17264: EQUAL
17265: IFTRUE 17275
17267: LD_INT 31
17269: DOUBLE
17270: EQUAL
17271: IFTRUE 17275
17273: GO 17286
17275: POP
// places := 1 ; b_control_tower :
17276: LD_ADDR_VAR 0 3
17280: PUSH
17281: LD_INT 1
17283: ST_TO_ADDR
17284: GO 17306
17286: LD_INT 36
17288: DOUBLE
17289: EQUAL
17290: IFTRUE 17294
17292: GO 17305
17294: POP
// places := 3 ; end ;
17295: LD_ADDR_VAR 0 3
17299: PUSH
17300: LD_INT 3
17302: ST_TO_ADDR
17303: GO 17306
17305: POP
// if places then
17306: LD_VAR 0 3
17310: IFFALSE 17333
// result := UnitsInside ( building ) < places ;
17312: LD_ADDR_VAR 0 2
17316: PUSH
17317: LD_VAR 0 1
17321: PPUSH
17322: CALL_OW 313
17326: PUSH
17327: LD_VAR 0 3
17331: LESS
17332: ST_TO_ADDR
// end ;
17333: LD_VAR 0 2
17337: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17338: LD_INT 0
17340: PPUSH
17341: PPUSH
17342: PPUSH
17343: PPUSH
// tmp := [ ] ;
17344: LD_ADDR_VAR 0 3
17348: PUSH
17349: EMPTY
17350: ST_TO_ADDR
// list := [ ] ;
17351: LD_ADDR_VAR 0 5
17355: PUSH
17356: EMPTY
17357: ST_TO_ADDR
// for i = 16 to 25 do
17358: LD_ADDR_VAR 0 4
17362: PUSH
17363: DOUBLE
17364: LD_INT 16
17366: DEC
17367: ST_TO_ADDR
17368: LD_INT 25
17370: PUSH
17371: FOR_TO
17372: IFFALSE 17445
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17374: LD_ADDR_VAR 0 3
17378: PUSH
17379: LD_VAR 0 3
17383: PUSH
17384: LD_INT 22
17386: PUSH
17387: LD_VAR 0 1
17391: PPUSH
17392: CALL_OW 255
17396: PUSH
17397: EMPTY
17398: LIST
17399: LIST
17400: PUSH
17401: LD_INT 91
17403: PUSH
17404: LD_VAR 0 1
17408: PUSH
17409: LD_INT 6
17411: PUSH
17412: EMPTY
17413: LIST
17414: LIST
17415: LIST
17416: PUSH
17417: LD_INT 30
17419: PUSH
17420: LD_VAR 0 4
17424: PUSH
17425: EMPTY
17426: LIST
17427: LIST
17428: PUSH
17429: EMPTY
17430: LIST
17431: LIST
17432: LIST
17433: PUSH
17434: EMPTY
17435: LIST
17436: PPUSH
17437: CALL_OW 69
17441: ADD
17442: ST_TO_ADDR
17443: GO 17371
17445: POP
17446: POP
// for i = 1 to tmp do
17447: LD_ADDR_VAR 0 4
17451: PUSH
17452: DOUBLE
17453: LD_INT 1
17455: DEC
17456: ST_TO_ADDR
17457: LD_VAR 0 3
17461: PUSH
17462: FOR_TO
17463: IFFALSE 17551
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17465: LD_ADDR_VAR 0 5
17469: PUSH
17470: LD_VAR 0 5
17474: PUSH
17475: LD_VAR 0 3
17479: PUSH
17480: LD_VAR 0 4
17484: ARRAY
17485: PPUSH
17486: CALL_OW 266
17490: PUSH
17491: LD_VAR 0 3
17495: PUSH
17496: LD_VAR 0 4
17500: ARRAY
17501: PPUSH
17502: CALL_OW 250
17506: PUSH
17507: LD_VAR 0 3
17511: PUSH
17512: LD_VAR 0 4
17516: ARRAY
17517: PPUSH
17518: CALL_OW 251
17522: PUSH
17523: LD_VAR 0 3
17527: PUSH
17528: LD_VAR 0 4
17532: ARRAY
17533: PPUSH
17534: CALL_OW 254
17538: PUSH
17539: EMPTY
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: PUSH
17545: EMPTY
17546: LIST
17547: ADD
17548: ST_TO_ADDR
17549: GO 17462
17551: POP
17552: POP
// result := list ;
17553: LD_ADDR_VAR 0 2
17557: PUSH
17558: LD_VAR 0 5
17562: ST_TO_ADDR
// end ;
17563: LD_VAR 0 2
17567: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17568: LD_INT 0
17570: PPUSH
17571: PPUSH
17572: PPUSH
17573: PPUSH
17574: PPUSH
17575: PPUSH
17576: PPUSH
// if not factory then
17577: LD_VAR 0 1
17581: NOT
17582: IFFALSE 17586
// exit ;
17584: GO 18179
// if control = control_apeman then
17586: LD_VAR 0 4
17590: PUSH
17591: LD_INT 5
17593: EQUAL
17594: IFFALSE 17703
// begin tmp := UnitsInside ( factory ) ;
17596: LD_ADDR_VAR 0 8
17600: PUSH
17601: LD_VAR 0 1
17605: PPUSH
17606: CALL_OW 313
17610: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17611: LD_VAR 0 8
17615: PPUSH
17616: LD_INT 25
17618: PUSH
17619: LD_INT 12
17621: PUSH
17622: EMPTY
17623: LIST
17624: LIST
17625: PPUSH
17626: CALL_OW 72
17630: NOT
17631: IFFALSE 17641
// control := control_manual ;
17633: LD_ADDR_VAR 0 4
17637: PUSH
17638: LD_INT 1
17640: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17641: LD_ADDR_VAR 0 8
17645: PUSH
17646: LD_VAR 0 1
17650: PPUSH
17651: CALL 17338 0 1
17655: ST_TO_ADDR
// if tmp then
17656: LD_VAR 0 8
17660: IFFALSE 17703
// begin for i in tmp do
17662: LD_ADDR_VAR 0 7
17666: PUSH
17667: LD_VAR 0 8
17671: PUSH
17672: FOR_IN
17673: IFFALSE 17701
// if i [ 1 ] = b_ext_radio then
17675: LD_VAR 0 7
17679: PUSH
17680: LD_INT 1
17682: ARRAY
17683: PUSH
17684: LD_INT 22
17686: EQUAL
17687: IFFALSE 17699
// begin control := control_remote ;
17689: LD_ADDR_VAR 0 4
17693: PUSH
17694: LD_INT 2
17696: ST_TO_ADDR
// break ;
17697: GO 17701
// end ;
17699: GO 17672
17701: POP
17702: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_VAR 0 2
17712: PPUSH
17713: LD_VAR 0 3
17717: PPUSH
17718: LD_VAR 0 4
17722: PPUSH
17723: LD_VAR 0 5
17727: PPUSH
17728: CALL_OW 448
17732: IFFALSE 17767
// begin result := [ chassis , engine , control , weapon ] ;
17734: LD_ADDR_VAR 0 6
17738: PUSH
17739: LD_VAR 0 2
17743: PUSH
17744: LD_VAR 0 3
17748: PUSH
17749: LD_VAR 0 4
17753: PUSH
17754: LD_VAR 0 5
17758: PUSH
17759: EMPTY
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: ST_TO_ADDR
// exit ;
17765: GO 18179
// end ; _chassis := AvailableChassisList ( factory ) ;
17767: LD_ADDR_VAR 0 9
17771: PUSH
17772: LD_VAR 0 1
17776: PPUSH
17777: CALL_OW 475
17781: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17782: LD_ADDR_VAR 0 11
17786: PUSH
17787: LD_VAR 0 1
17791: PPUSH
17792: CALL_OW 476
17796: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17797: LD_ADDR_VAR 0 12
17801: PUSH
17802: LD_VAR 0 1
17806: PPUSH
17807: CALL_OW 477
17811: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17812: LD_ADDR_VAR 0 10
17816: PUSH
17817: LD_VAR 0 1
17821: PPUSH
17822: CALL_OW 478
17826: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17827: LD_VAR 0 9
17831: NOT
17832: PUSH
17833: LD_VAR 0 11
17837: NOT
17838: OR
17839: PUSH
17840: LD_VAR 0 12
17844: NOT
17845: OR
17846: PUSH
17847: LD_VAR 0 10
17851: NOT
17852: OR
17853: IFFALSE 17888
// begin result := [ chassis , engine , control , weapon ] ;
17855: LD_ADDR_VAR 0 6
17859: PUSH
17860: LD_VAR 0 2
17864: PUSH
17865: LD_VAR 0 3
17869: PUSH
17870: LD_VAR 0 4
17874: PUSH
17875: LD_VAR 0 5
17879: PUSH
17880: EMPTY
17881: LIST
17882: LIST
17883: LIST
17884: LIST
17885: ST_TO_ADDR
// exit ;
17886: GO 18179
// end ; if not chassis in _chassis then
17888: LD_VAR 0 2
17892: PUSH
17893: LD_VAR 0 9
17897: IN
17898: NOT
17899: IFFALSE 17925
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17901: LD_ADDR_VAR 0 2
17905: PUSH
17906: LD_VAR 0 9
17910: PUSH
17911: LD_INT 1
17913: PPUSH
17914: LD_VAR 0 9
17918: PPUSH
17919: CALL_OW 12
17923: ARRAY
17924: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17925: LD_VAR 0 2
17929: PPUSH
17930: LD_VAR 0 3
17934: PPUSH
17935: CALL 18184 0 2
17939: NOT
17940: IFFALSE 17999
// repeat engine := _engine [ 1 ] ;
17942: LD_ADDR_VAR 0 3
17946: PUSH
17947: LD_VAR 0 11
17951: PUSH
17952: LD_INT 1
17954: ARRAY
17955: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17956: LD_ADDR_VAR 0 11
17960: PUSH
17961: LD_VAR 0 11
17965: PPUSH
17966: LD_INT 1
17968: PPUSH
17969: CALL_OW 3
17973: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17974: LD_VAR 0 2
17978: PPUSH
17979: LD_VAR 0 3
17983: PPUSH
17984: CALL 18184 0 2
17988: PUSH
17989: LD_VAR 0 11
17993: PUSH
17994: EMPTY
17995: EQUAL
17996: OR
17997: IFFALSE 17942
// if not control in _control then
17999: LD_VAR 0 4
18003: PUSH
18004: LD_VAR 0 12
18008: IN
18009: NOT
18010: IFFALSE 18036
// control := _control [ rand ( 1 , _control ) ] ;
18012: LD_ADDR_VAR 0 4
18016: PUSH
18017: LD_VAR 0 12
18021: PUSH
18022: LD_INT 1
18024: PPUSH
18025: LD_VAR 0 12
18029: PPUSH
18030: CALL_OW 12
18034: ARRAY
18035: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18036: LD_VAR 0 2
18040: PPUSH
18041: LD_VAR 0 5
18045: PPUSH
18046: CALL 18404 0 2
18050: NOT
18051: IFFALSE 18110
// repeat weapon := _weapon [ 1 ] ;
18053: LD_ADDR_VAR 0 5
18057: PUSH
18058: LD_VAR 0 10
18062: PUSH
18063: LD_INT 1
18065: ARRAY
18066: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18067: LD_ADDR_VAR 0 10
18071: PUSH
18072: LD_VAR 0 10
18076: PPUSH
18077: LD_INT 1
18079: PPUSH
18080: CALL_OW 3
18084: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18085: LD_VAR 0 2
18089: PPUSH
18090: LD_VAR 0 5
18094: PPUSH
18095: CALL 18404 0 2
18099: PUSH
18100: LD_VAR 0 10
18104: PUSH
18105: EMPTY
18106: EQUAL
18107: OR
18108: IFFALSE 18053
// result := [ ] ;
18110: LD_ADDR_VAR 0 6
18114: PUSH
18115: EMPTY
18116: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18117: LD_VAR 0 1
18121: PPUSH
18122: LD_VAR 0 2
18126: PPUSH
18127: LD_VAR 0 3
18131: PPUSH
18132: LD_VAR 0 4
18136: PPUSH
18137: LD_VAR 0 5
18141: PPUSH
18142: CALL_OW 448
18146: IFFALSE 18179
// result := [ chassis , engine , control , weapon ] ;
18148: LD_ADDR_VAR 0 6
18152: PUSH
18153: LD_VAR 0 2
18157: PUSH
18158: LD_VAR 0 3
18162: PUSH
18163: LD_VAR 0 4
18167: PUSH
18168: LD_VAR 0 5
18172: PUSH
18173: EMPTY
18174: LIST
18175: LIST
18176: LIST
18177: LIST
18178: ST_TO_ADDR
// end ;
18179: LD_VAR 0 6
18183: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18184: LD_INT 0
18186: PPUSH
// if not chassis or not engine then
18187: LD_VAR 0 1
18191: NOT
18192: PUSH
18193: LD_VAR 0 2
18197: NOT
18198: OR
18199: IFFALSE 18203
// exit ;
18201: GO 18399
// case engine of engine_solar :
18203: LD_VAR 0 2
18207: PUSH
18208: LD_INT 2
18210: DOUBLE
18211: EQUAL
18212: IFTRUE 18216
18214: GO 18254
18216: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18217: LD_ADDR_VAR 0 3
18221: PUSH
18222: LD_INT 11
18224: PUSH
18225: LD_INT 12
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: LD_INT 1
18236: PUSH
18237: LD_INT 2
18239: PUSH
18240: LD_INT 3
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: ST_TO_ADDR
18252: GO 18383
18254: LD_INT 1
18256: DOUBLE
18257: EQUAL
18258: IFTRUE 18262
18260: GO 18324
18262: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18263: LD_ADDR_VAR 0 3
18267: PUSH
18268: LD_INT 11
18270: PUSH
18271: LD_INT 12
18273: PUSH
18274: LD_INT 13
18276: PUSH
18277: LD_INT 14
18279: PUSH
18280: LD_INT 1
18282: PUSH
18283: LD_INT 2
18285: PUSH
18286: LD_INT 3
18288: PUSH
18289: LD_INT 4
18291: PUSH
18292: LD_INT 5
18294: PUSH
18295: LD_INT 21
18297: PUSH
18298: LD_INT 23
18300: PUSH
18301: LD_INT 22
18303: PUSH
18304: LD_INT 24
18306: PUSH
18307: EMPTY
18308: LIST
18309: LIST
18310: LIST
18311: LIST
18312: LIST
18313: LIST
18314: LIST
18315: LIST
18316: LIST
18317: LIST
18318: LIST
18319: LIST
18320: LIST
18321: ST_TO_ADDR
18322: GO 18383
18324: LD_INT 3
18326: DOUBLE
18327: EQUAL
18328: IFTRUE 18332
18330: GO 18382
18332: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18333: LD_ADDR_VAR 0 3
18337: PUSH
18338: LD_INT 13
18340: PUSH
18341: LD_INT 14
18343: PUSH
18344: LD_INT 2
18346: PUSH
18347: LD_INT 3
18349: PUSH
18350: LD_INT 4
18352: PUSH
18353: LD_INT 5
18355: PUSH
18356: LD_INT 21
18358: PUSH
18359: LD_INT 22
18361: PUSH
18362: LD_INT 23
18364: PUSH
18365: LD_INT 24
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: LIST
18375: LIST
18376: LIST
18377: LIST
18378: LIST
18379: ST_TO_ADDR
18380: GO 18383
18382: POP
// result := ( chassis in result ) ;
18383: LD_ADDR_VAR 0 3
18387: PUSH
18388: LD_VAR 0 1
18392: PUSH
18393: LD_VAR 0 3
18397: IN
18398: ST_TO_ADDR
// end ;
18399: LD_VAR 0 3
18403: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18404: LD_INT 0
18406: PPUSH
// if not chassis or not weapon then
18407: LD_VAR 0 1
18411: NOT
18412: PUSH
18413: LD_VAR 0 2
18417: NOT
18418: OR
18419: IFFALSE 18423
// exit ;
18421: GO 19483
// case weapon of us_machine_gun :
18423: LD_VAR 0 2
18427: PUSH
18428: LD_INT 2
18430: DOUBLE
18431: EQUAL
18432: IFTRUE 18436
18434: GO 18466
18436: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18437: LD_ADDR_VAR 0 3
18441: PUSH
18442: LD_INT 1
18444: PUSH
18445: LD_INT 2
18447: PUSH
18448: LD_INT 3
18450: PUSH
18451: LD_INT 4
18453: PUSH
18454: LD_INT 5
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: ST_TO_ADDR
18464: GO 19467
18466: LD_INT 3
18468: DOUBLE
18469: EQUAL
18470: IFTRUE 18474
18472: GO 18504
18474: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18475: LD_ADDR_VAR 0 3
18479: PUSH
18480: LD_INT 1
18482: PUSH
18483: LD_INT 2
18485: PUSH
18486: LD_INT 3
18488: PUSH
18489: LD_INT 4
18491: PUSH
18492: LD_INT 5
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: LIST
18499: LIST
18500: LIST
18501: ST_TO_ADDR
18502: GO 19467
18504: LD_INT 11
18506: DOUBLE
18507: EQUAL
18508: IFTRUE 18512
18510: GO 18542
18512: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18513: LD_ADDR_VAR 0 3
18517: PUSH
18518: LD_INT 1
18520: PUSH
18521: LD_INT 2
18523: PUSH
18524: LD_INT 3
18526: PUSH
18527: LD_INT 4
18529: PUSH
18530: LD_INT 5
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: LIST
18539: ST_TO_ADDR
18540: GO 19467
18542: LD_INT 4
18544: DOUBLE
18545: EQUAL
18546: IFTRUE 18550
18548: GO 18576
18550: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18551: LD_ADDR_VAR 0 3
18555: PUSH
18556: LD_INT 2
18558: PUSH
18559: LD_INT 3
18561: PUSH
18562: LD_INT 4
18564: PUSH
18565: LD_INT 5
18567: PUSH
18568: EMPTY
18569: LIST
18570: LIST
18571: LIST
18572: LIST
18573: ST_TO_ADDR
18574: GO 19467
18576: LD_INT 5
18578: DOUBLE
18579: EQUAL
18580: IFTRUE 18584
18582: GO 18610
18584: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_INT 2
18592: PUSH
18593: LD_INT 3
18595: PUSH
18596: LD_INT 4
18598: PUSH
18599: LD_INT 5
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: LIST
18606: LIST
18607: ST_TO_ADDR
18608: GO 19467
18610: LD_INT 9
18612: DOUBLE
18613: EQUAL
18614: IFTRUE 18618
18616: GO 18644
18618: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18619: LD_ADDR_VAR 0 3
18623: PUSH
18624: LD_INT 2
18626: PUSH
18627: LD_INT 3
18629: PUSH
18630: LD_INT 4
18632: PUSH
18633: LD_INT 5
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: ST_TO_ADDR
18642: GO 19467
18644: LD_INT 7
18646: DOUBLE
18647: EQUAL
18648: IFTRUE 18652
18650: GO 18678
18652: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18653: LD_ADDR_VAR 0 3
18657: PUSH
18658: LD_INT 2
18660: PUSH
18661: LD_INT 3
18663: PUSH
18664: LD_INT 4
18666: PUSH
18667: LD_INT 5
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: LIST
18675: ST_TO_ADDR
18676: GO 19467
18678: LD_INT 12
18680: DOUBLE
18681: EQUAL
18682: IFTRUE 18686
18684: GO 18712
18686: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18687: LD_ADDR_VAR 0 3
18691: PUSH
18692: LD_INT 2
18694: PUSH
18695: LD_INT 3
18697: PUSH
18698: LD_INT 4
18700: PUSH
18701: LD_INT 5
18703: PUSH
18704: EMPTY
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: ST_TO_ADDR
18710: GO 19467
18712: LD_INT 13
18714: DOUBLE
18715: EQUAL
18716: IFTRUE 18720
18718: GO 18746
18720: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18721: LD_ADDR_VAR 0 3
18725: PUSH
18726: LD_INT 2
18728: PUSH
18729: LD_INT 3
18731: PUSH
18732: LD_INT 4
18734: PUSH
18735: LD_INT 5
18737: PUSH
18738: EMPTY
18739: LIST
18740: LIST
18741: LIST
18742: LIST
18743: ST_TO_ADDR
18744: GO 19467
18746: LD_INT 14
18748: DOUBLE
18749: EQUAL
18750: IFTRUE 18754
18752: GO 18772
18754: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18755: LD_ADDR_VAR 0 3
18759: PUSH
18760: LD_INT 4
18762: PUSH
18763: LD_INT 5
18765: PUSH
18766: EMPTY
18767: LIST
18768: LIST
18769: ST_TO_ADDR
18770: GO 19467
18772: LD_INT 6
18774: DOUBLE
18775: EQUAL
18776: IFTRUE 18780
18778: GO 18798
18780: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18781: LD_ADDR_VAR 0 3
18785: PUSH
18786: LD_INT 4
18788: PUSH
18789: LD_INT 5
18791: PUSH
18792: EMPTY
18793: LIST
18794: LIST
18795: ST_TO_ADDR
18796: GO 19467
18798: LD_INT 10
18800: DOUBLE
18801: EQUAL
18802: IFTRUE 18806
18804: GO 18824
18806: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18807: LD_ADDR_VAR 0 3
18811: PUSH
18812: LD_INT 4
18814: PUSH
18815: LD_INT 5
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: ST_TO_ADDR
18822: GO 19467
18824: LD_INT 22
18826: DOUBLE
18827: EQUAL
18828: IFTRUE 18832
18830: GO 18858
18832: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18833: LD_ADDR_VAR 0 3
18837: PUSH
18838: LD_INT 11
18840: PUSH
18841: LD_INT 12
18843: PUSH
18844: LD_INT 13
18846: PUSH
18847: LD_INT 14
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: ST_TO_ADDR
18856: GO 19467
18858: LD_INT 23
18860: DOUBLE
18861: EQUAL
18862: IFTRUE 18866
18864: GO 18892
18866: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18867: LD_ADDR_VAR 0 3
18871: PUSH
18872: LD_INT 11
18874: PUSH
18875: LD_INT 12
18877: PUSH
18878: LD_INT 13
18880: PUSH
18881: LD_INT 14
18883: PUSH
18884: EMPTY
18885: LIST
18886: LIST
18887: LIST
18888: LIST
18889: ST_TO_ADDR
18890: GO 19467
18892: LD_INT 24
18894: DOUBLE
18895: EQUAL
18896: IFTRUE 18900
18898: GO 18926
18900: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18901: LD_ADDR_VAR 0 3
18905: PUSH
18906: LD_INT 11
18908: PUSH
18909: LD_INT 12
18911: PUSH
18912: LD_INT 13
18914: PUSH
18915: LD_INT 14
18917: PUSH
18918: EMPTY
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: ST_TO_ADDR
18924: GO 19467
18926: LD_INT 30
18928: DOUBLE
18929: EQUAL
18930: IFTRUE 18934
18932: GO 18960
18934: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18935: LD_ADDR_VAR 0 3
18939: PUSH
18940: LD_INT 11
18942: PUSH
18943: LD_INT 12
18945: PUSH
18946: LD_INT 13
18948: PUSH
18949: LD_INT 14
18951: PUSH
18952: EMPTY
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: ST_TO_ADDR
18958: GO 19467
18960: LD_INT 25
18962: DOUBLE
18963: EQUAL
18964: IFTRUE 18968
18966: GO 18986
18968: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18969: LD_ADDR_VAR 0 3
18973: PUSH
18974: LD_INT 13
18976: PUSH
18977: LD_INT 14
18979: PUSH
18980: EMPTY
18981: LIST
18982: LIST
18983: ST_TO_ADDR
18984: GO 19467
18986: LD_INT 27
18988: DOUBLE
18989: EQUAL
18990: IFTRUE 18994
18992: GO 19012
18994: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18995: LD_ADDR_VAR 0 3
18999: PUSH
19000: LD_INT 13
19002: PUSH
19003: LD_INT 14
19005: PUSH
19006: EMPTY
19007: LIST
19008: LIST
19009: ST_TO_ADDR
19010: GO 19467
19012: LD_INT 92
19014: DOUBLE
19015: EQUAL
19016: IFTRUE 19020
19018: GO 19046
19020: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19021: LD_ADDR_VAR 0 3
19025: PUSH
19026: LD_INT 11
19028: PUSH
19029: LD_INT 12
19031: PUSH
19032: LD_INT 13
19034: PUSH
19035: LD_INT 14
19037: PUSH
19038: EMPTY
19039: LIST
19040: LIST
19041: LIST
19042: LIST
19043: ST_TO_ADDR
19044: GO 19467
19046: LD_INT 28
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19072
19054: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19055: LD_ADDR_VAR 0 3
19059: PUSH
19060: LD_INT 13
19062: PUSH
19063: LD_INT 14
19065: PUSH
19066: EMPTY
19067: LIST
19068: LIST
19069: ST_TO_ADDR
19070: GO 19467
19072: LD_INT 29
19074: DOUBLE
19075: EQUAL
19076: IFTRUE 19080
19078: GO 19098
19080: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19081: LD_ADDR_VAR 0 3
19085: PUSH
19086: LD_INT 13
19088: PUSH
19089: LD_INT 14
19091: PUSH
19092: EMPTY
19093: LIST
19094: LIST
19095: ST_TO_ADDR
19096: GO 19467
19098: LD_INT 31
19100: DOUBLE
19101: EQUAL
19102: IFTRUE 19106
19104: GO 19124
19106: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19107: LD_ADDR_VAR 0 3
19111: PUSH
19112: LD_INT 13
19114: PUSH
19115: LD_INT 14
19117: PUSH
19118: EMPTY
19119: LIST
19120: LIST
19121: ST_TO_ADDR
19122: GO 19467
19124: LD_INT 26
19126: DOUBLE
19127: EQUAL
19128: IFTRUE 19132
19130: GO 19150
19132: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19133: LD_ADDR_VAR 0 3
19137: PUSH
19138: LD_INT 13
19140: PUSH
19141: LD_INT 14
19143: PUSH
19144: EMPTY
19145: LIST
19146: LIST
19147: ST_TO_ADDR
19148: GO 19467
19150: LD_INT 42
19152: DOUBLE
19153: EQUAL
19154: IFTRUE 19158
19156: GO 19184
19158: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19159: LD_ADDR_VAR 0 3
19163: PUSH
19164: LD_INT 21
19166: PUSH
19167: LD_INT 22
19169: PUSH
19170: LD_INT 23
19172: PUSH
19173: LD_INT 24
19175: PUSH
19176: EMPTY
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: ST_TO_ADDR
19182: GO 19467
19184: LD_INT 43
19186: DOUBLE
19187: EQUAL
19188: IFTRUE 19192
19190: GO 19218
19192: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19193: LD_ADDR_VAR 0 3
19197: PUSH
19198: LD_INT 21
19200: PUSH
19201: LD_INT 22
19203: PUSH
19204: LD_INT 23
19206: PUSH
19207: LD_INT 24
19209: PUSH
19210: EMPTY
19211: LIST
19212: LIST
19213: LIST
19214: LIST
19215: ST_TO_ADDR
19216: GO 19467
19218: LD_INT 44
19220: DOUBLE
19221: EQUAL
19222: IFTRUE 19226
19224: GO 19252
19226: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19227: LD_ADDR_VAR 0 3
19231: PUSH
19232: LD_INT 21
19234: PUSH
19235: LD_INT 22
19237: PUSH
19238: LD_INT 23
19240: PUSH
19241: LD_INT 24
19243: PUSH
19244: EMPTY
19245: LIST
19246: LIST
19247: LIST
19248: LIST
19249: ST_TO_ADDR
19250: GO 19467
19252: LD_INT 45
19254: DOUBLE
19255: EQUAL
19256: IFTRUE 19260
19258: GO 19286
19260: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19261: LD_ADDR_VAR 0 3
19265: PUSH
19266: LD_INT 21
19268: PUSH
19269: LD_INT 22
19271: PUSH
19272: LD_INT 23
19274: PUSH
19275: LD_INT 24
19277: PUSH
19278: EMPTY
19279: LIST
19280: LIST
19281: LIST
19282: LIST
19283: ST_TO_ADDR
19284: GO 19467
19286: LD_INT 49
19288: DOUBLE
19289: EQUAL
19290: IFTRUE 19294
19292: GO 19320
19294: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19295: LD_ADDR_VAR 0 3
19299: PUSH
19300: LD_INT 21
19302: PUSH
19303: LD_INT 22
19305: PUSH
19306: LD_INT 23
19308: PUSH
19309: LD_INT 24
19311: PUSH
19312: EMPTY
19313: LIST
19314: LIST
19315: LIST
19316: LIST
19317: ST_TO_ADDR
19318: GO 19467
19320: LD_INT 51
19322: DOUBLE
19323: EQUAL
19324: IFTRUE 19328
19326: GO 19354
19328: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19329: LD_ADDR_VAR 0 3
19333: PUSH
19334: LD_INT 21
19336: PUSH
19337: LD_INT 22
19339: PUSH
19340: LD_INT 23
19342: PUSH
19343: LD_INT 24
19345: PUSH
19346: EMPTY
19347: LIST
19348: LIST
19349: LIST
19350: LIST
19351: ST_TO_ADDR
19352: GO 19467
19354: LD_INT 52
19356: DOUBLE
19357: EQUAL
19358: IFTRUE 19362
19360: GO 19388
19362: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19363: LD_ADDR_VAR 0 3
19367: PUSH
19368: LD_INT 21
19370: PUSH
19371: LD_INT 22
19373: PUSH
19374: LD_INT 23
19376: PUSH
19377: LD_INT 24
19379: PUSH
19380: EMPTY
19381: LIST
19382: LIST
19383: LIST
19384: LIST
19385: ST_TO_ADDR
19386: GO 19467
19388: LD_INT 53
19390: DOUBLE
19391: EQUAL
19392: IFTRUE 19396
19394: GO 19414
19396: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19397: LD_ADDR_VAR 0 3
19401: PUSH
19402: LD_INT 23
19404: PUSH
19405: LD_INT 24
19407: PUSH
19408: EMPTY
19409: LIST
19410: LIST
19411: ST_TO_ADDR
19412: GO 19467
19414: LD_INT 46
19416: DOUBLE
19417: EQUAL
19418: IFTRUE 19422
19420: GO 19440
19422: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19423: LD_ADDR_VAR 0 3
19427: PUSH
19428: LD_INT 23
19430: PUSH
19431: LD_INT 24
19433: PUSH
19434: EMPTY
19435: LIST
19436: LIST
19437: ST_TO_ADDR
19438: GO 19467
19440: LD_INT 47
19442: DOUBLE
19443: EQUAL
19444: IFTRUE 19448
19446: GO 19466
19448: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19449: LD_ADDR_VAR 0 3
19453: PUSH
19454: LD_INT 23
19456: PUSH
19457: LD_INT 24
19459: PUSH
19460: EMPTY
19461: LIST
19462: LIST
19463: ST_TO_ADDR
19464: GO 19467
19466: POP
// result := ( chassis in result ) ;
19467: LD_ADDR_VAR 0 3
19471: PUSH
19472: LD_VAR 0 1
19476: PUSH
19477: LD_VAR 0 3
19481: IN
19482: ST_TO_ADDR
// end ;
19483: LD_VAR 0 3
19487: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19488: LD_INT 0
19490: PPUSH
19491: PPUSH
19492: PPUSH
19493: PPUSH
19494: PPUSH
19495: PPUSH
19496: PPUSH
// result := array ;
19497: LD_ADDR_VAR 0 5
19501: PUSH
19502: LD_VAR 0 1
19506: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19507: LD_VAR 0 1
19511: NOT
19512: PUSH
19513: LD_VAR 0 2
19517: NOT
19518: OR
19519: PUSH
19520: LD_VAR 0 3
19524: NOT
19525: OR
19526: PUSH
19527: LD_VAR 0 2
19531: PUSH
19532: LD_VAR 0 1
19536: GREATER
19537: OR
19538: PUSH
19539: LD_VAR 0 3
19543: PUSH
19544: LD_VAR 0 1
19548: GREATER
19549: OR
19550: IFFALSE 19554
// exit ;
19552: GO 19850
// if direction then
19554: LD_VAR 0 4
19558: IFFALSE 19622
// begin d := 1 ;
19560: LD_ADDR_VAR 0 9
19564: PUSH
19565: LD_INT 1
19567: ST_TO_ADDR
// if i_from > i_to then
19568: LD_VAR 0 2
19572: PUSH
19573: LD_VAR 0 3
19577: GREATER
19578: IFFALSE 19604
// length := ( array - i_from ) + i_to else
19580: LD_ADDR_VAR 0 11
19584: PUSH
19585: LD_VAR 0 1
19589: PUSH
19590: LD_VAR 0 2
19594: MINUS
19595: PUSH
19596: LD_VAR 0 3
19600: PLUS
19601: ST_TO_ADDR
19602: GO 19620
// length := i_to - i_from ;
19604: LD_ADDR_VAR 0 11
19608: PUSH
19609: LD_VAR 0 3
19613: PUSH
19614: LD_VAR 0 2
19618: MINUS
19619: ST_TO_ADDR
// end else
19620: GO 19683
// begin d := - 1 ;
19622: LD_ADDR_VAR 0 9
19626: PUSH
19627: LD_INT 1
19629: NEG
19630: ST_TO_ADDR
// if i_from > i_to then
19631: LD_VAR 0 2
19635: PUSH
19636: LD_VAR 0 3
19640: GREATER
19641: IFFALSE 19661
// length := i_from - i_to else
19643: LD_ADDR_VAR 0 11
19647: PUSH
19648: LD_VAR 0 2
19652: PUSH
19653: LD_VAR 0 3
19657: MINUS
19658: ST_TO_ADDR
19659: GO 19683
// length := ( array - i_to ) + i_from ;
19661: LD_ADDR_VAR 0 11
19665: PUSH
19666: LD_VAR 0 1
19670: PUSH
19671: LD_VAR 0 3
19675: MINUS
19676: PUSH
19677: LD_VAR 0 2
19681: PLUS
19682: ST_TO_ADDR
// end ; if not length then
19683: LD_VAR 0 11
19687: NOT
19688: IFFALSE 19692
// exit ;
19690: GO 19850
// tmp := array ;
19692: LD_ADDR_VAR 0 10
19696: PUSH
19697: LD_VAR 0 1
19701: ST_TO_ADDR
// for i = 1 to length do
19702: LD_ADDR_VAR 0 6
19706: PUSH
19707: DOUBLE
19708: LD_INT 1
19710: DEC
19711: ST_TO_ADDR
19712: LD_VAR 0 11
19716: PUSH
19717: FOR_TO
19718: IFFALSE 19838
// begin for j = 1 to array do
19720: LD_ADDR_VAR 0 7
19724: PUSH
19725: DOUBLE
19726: LD_INT 1
19728: DEC
19729: ST_TO_ADDR
19730: LD_VAR 0 1
19734: PUSH
19735: FOR_TO
19736: IFFALSE 19824
// begin k := j + d ;
19738: LD_ADDR_VAR 0 8
19742: PUSH
19743: LD_VAR 0 7
19747: PUSH
19748: LD_VAR 0 9
19752: PLUS
19753: ST_TO_ADDR
// if k > array then
19754: LD_VAR 0 8
19758: PUSH
19759: LD_VAR 0 1
19763: GREATER
19764: IFFALSE 19774
// k := 1 ;
19766: LD_ADDR_VAR 0 8
19770: PUSH
19771: LD_INT 1
19773: ST_TO_ADDR
// if not k then
19774: LD_VAR 0 8
19778: NOT
19779: IFFALSE 19791
// k := array ;
19781: LD_ADDR_VAR 0 8
19785: PUSH
19786: LD_VAR 0 1
19790: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19791: LD_ADDR_VAR 0 10
19795: PUSH
19796: LD_VAR 0 10
19800: PPUSH
19801: LD_VAR 0 8
19805: PPUSH
19806: LD_VAR 0 1
19810: PUSH
19811: LD_VAR 0 7
19815: ARRAY
19816: PPUSH
19817: CALL_OW 1
19821: ST_TO_ADDR
// end ;
19822: GO 19735
19824: POP
19825: POP
// array := tmp ;
19826: LD_ADDR_VAR 0 1
19830: PUSH
19831: LD_VAR 0 10
19835: ST_TO_ADDR
// end ;
19836: GO 19717
19838: POP
19839: POP
// result := array ;
19840: LD_ADDR_VAR 0 5
19844: PUSH
19845: LD_VAR 0 1
19849: ST_TO_ADDR
// end ;
19850: LD_VAR 0 5
19854: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19855: LD_INT 0
19857: PPUSH
19858: PPUSH
// result := 0 ;
19859: LD_ADDR_VAR 0 3
19863: PUSH
19864: LD_INT 0
19866: ST_TO_ADDR
// if not array or not value in array then
19867: LD_VAR 0 1
19871: NOT
19872: PUSH
19873: LD_VAR 0 2
19877: PUSH
19878: LD_VAR 0 1
19882: IN
19883: NOT
19884: OR
19885: IFFALSE 19889
// exit ;
19887: GO 19943
// for i = 1 to array do
19889: LD_ADDR_VAR 0 4
19893: PUSH
19894: DOUBLE
19895: LD_INT 1
19897: DEC
19898: ST_TO_ADDR
19899: LD_VAR 0 1
19903: PUSH
19904: FOR_TO
19905: IFFALSE 19941
// if value = array [ i ] then
19907: LD_VAR 0 2
19911: PUSH
19912: LD_VAR 0 1
19916: PUSH
19917: LD_VAR 0 4
19921: ARRAY
19922: EQUAL
19923: IFFALSE 19939
// begin result := i ;
19925: LD_ADDR_VAR 0 3
19929: PUSH
19930: LD_VAR 0 4
19934: ST_TO_ADDR
// exit ;
19935: POP
19936: POP
19937: GO 19943
// end ;
19939: GO 19904
19941: POP
19942: POP
// end ;
19943: LD_VAR 0 3
19947: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19948: LD_INT 0
19950: PPUSH
// vc_chassis := chassis ;
19951: LD_ADDR_OWVAR 37
19955: PUSH
19956: LD_VAR 0 1
19960: ST_TO_ADDR
// vc_engine := engine ;
19961: LD_ADDR_OWVAR 39
19965: PUSH
19966: LD_VAR 0 2
19970: ST_TO_ADDR
// vc_control := control ;
19971: LD_ADDR_OWVAR 38
19975: PUSH
19976: LD_VAR 0 3
19980: ST_TO_ADDR
// vc_weapon := weapon ;
19981: LD_ADDR_OWVAR 40
19985: PUSH
19986: LD_VAR 0 4
19990: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19991: LD_ADDR_OWVAR 41
19995: PUSH
19996: LD_VAR 0 5
20000: ST_TO_ADDR
// end ;
20001: LD_VAR 0 6
20005: RET
// export function WantPlant ( unit ) ; var task ; begin
20006: LD_INT 0
20008: PPUSH
20009: PPUSH
// result := false ;
20010: LD_ADDR_VAR 0 2
20014: PUSH
20015: LD_INT 0
20017: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20018: LD_ADDR_VAR 0 3
20022: PUSH
20023: LD_VAR 0 1
20027: PPUSH
20028: CALL_OW 437
20032: ST_TO_ADDR
// if task then
20033: LD_VAR 0 3
20037: IFFALSE 20065
// if task [ 1 ] [ 1 ] = p then
20039: LD_VAR 0 3
20043: PUSH
20044: LD_INT 1
20046: ARRAY
20047: PUSH
20048: LD_INT 1
20050: ARRAY
20051: PUSH
20052: LD_STRING p
20054: EQUAL
20055: IFFALSE 20065
// result := true ;
20057: LD_ADDR_VAR 0 2
20061: PUSH
20062: LD_INT 1
20064: ST_TO_ADDR
// end ;
20065: LD_VAR 0 2
20069: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20070: LD_INT 0
20072: PPUSH
20073: PPUSH
20074: PPUSH
20075: PPUSH
// if pos < 1 then
20076: LD_VAR 0 2
20080: PUSH
20081: LD_INT 1
20083: LESS
20084: IFFALSE 20088
// exit ;
20086: GO 20391
// if pos = 1 then
20088: LD_VAR 0 2
20092: PUSH
20093: LD_INT 1
20095: EQUAL
20096: IFFALSE 20129
// result := Replace ( arr , pos [ 1 ] , value ) else
20098: LD_ADDR_VAR 0 4
20102: PUSH
20103: LD_VAR 0 1
20107: PPUSH
20108: LD_VAR 0 2
20112: PUSH
20113: LD_INT 1
20115: ARRAY
20116: PPUSH
20117: LD_VAR 0 3
20121: PPUSH
20122: CALL_OW 1
20126: ST_TO_ADDR
20127: GO 20391
// begin tmp := arr ;
20129: LD_ADDR_VAR 0 6
20133: PUSH
20134: LD_VAR 0 1
20138: ST_TO_ADDR
// s_arr := [ tmp ] ;
20139: LD_ADDR_VAR 0 7
20143: PUSH
20144: LD_VAR 0 6
20148: PUSH
20149: EMPTY
20150: LIST
20151: ST_TO_ADDR
// for i = 1 to pos - 1 do
20152: LD_ADDR_VAR 0 5
20156: PUSH
20157: DOUBLE
20158: LD_INT 1
20160: DEC
20161: ST_TO_ADDR
20162: LD_VAR 0 2
20166: PUSH
20167: LD_INT 1
20169: MINUS
20170: PUSH
20171: FOR_TO
20172: IFFALSE 20217
// begin tmp := tmp [ pos [ i ] ] ;
20174: LD_ADDR_VAR 0 6
20178: PUSH
20179: LD_VAR 0 6
20183: PUSH
20184: LD_VAR 0 2
20188: PUSH
20189: LD_VAR 0 5
20193: ARRAY
20194: ARRAY
20195: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: LD_VAR 0 7
20205: PUSH
20206: LD_VAR 0 6
20210: PUSH
20211: EMPTY
20212: LIST
20213: ADD
20214: ST_TO_ADDR
// end ;
20215: GO 20171
20217: POP
20218: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20219: LD_ADDR_VAR 0 6
20223: PUSH
20224: LD_VAR 0 6
20228: PPUSH
20229: LD_VAR 0 2
20233: PUSH
20234: LD_VAR 0 2
20238: ARRAY
20239: PPUSH
20240: LD_VAR 0 3
20244: PPUSH
20245: CALL_OW 1
20249: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20250: LD_ADDR_VAR 0 7
20254: PUSH
20255: LD_VAR 0 7
20259: PPUSH
20260: LD_VAR 0 7
20264: PPUSH
20265: LD_VAR 0 6
20269: PPUSH
20270: CALL_OW 1
20274: ST_TO_ADDR
// for i = s_arr downto 2 do
20275: LD_ADDR_VAR 0 5
20279: PUSH
20280: DOUBLE
20281: LD_VAR 0 7
20285: INC
20286: ST_TO_ADDR
20287: LD_INT 2
20289: PUSH
20290: FOR_DOWNTO
20291: IFFALSE 20375
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20293: LD_ADDR_VAR 0 6
20297: PUSH
20298: LD_VAR 0 7
20302: PUSH
20303: LD_VAR 0 5
20307: PUSH
20308: LD_INT 1
20310: MINUS
20311: ARRAY
20312: PPUSH
20313: LD_VAR 0 2
20317: PUSH
20318: LD_VAR 0 5
20322: PUSH
20323: LD_INT 1
20325: MINUS
20326: ARRAY
20327: PPUSH
20328: LD_VAR 0 7
20332: PUSH
20333: LD_VAR 0 5
20337: ARRAY
20338: PPUSH
20339: CALL_OW 1
20343: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20344: LD_ADDR_VAR 0 7
20348: PUSH
20349: LD_VAR 0 7
20353: PPUSH
20354: LD_VAR 0 5
20358: PUSH
20359: LD_INT 1
20361: MINUS
20362: PPUSH
20363: LD_VAR 0 6
20367: PPUSH
20368: CALL_OW 1
20372: ST_TO_ADDR
// end ;
20373: GO 20290
20375: POP
20376: POP
// result := s_arr [ 1 ] ;
20377: LD_ADDR_VAR 0 4
20381: PUSH
20382: LD_VAR 0 7
20386: PUSH
20387: LD_INT 1
20389: ARRAY
20390: ST_TO_ADDR
// end ; end ;
20391: LD_VAR 0 4
20395: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20396: LD_INT 0
20398: PPUSH
20399: PPUSH
// if not list then
20400: LD_VAR 0 1
20404: NOT
20405: IFFALSE 20409
// exit ;
20407: GO 20500
// i := list [ pos1 ] ;
20409: LD_ADDR_VAR 0 5
20413: PUSH
20414: LD_VAR 0 1
20418: PUSH
20419: LD_VAR 0 2
20423: ARRAY
20424: ST_TO_ADDR
// if not i then
20425: LD_VAR 0 5
20429: NOT
20430: IFFALSE 20434
// exit ;
20432: GO 20500
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20434: LD_ADDR_VAR 0 1
20438: PUSH
20439: LD_VAR 0 1
20443: PPUSH
20444: LD_VAR 0 2
20448: PPUSH
20449: LD_VAR 0 1
20453: PUSH
20454: LD_VAR 0 3
20458: ARRAY
20459: PPUSH
20460: CALL_OW 1
20464: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20465: LD_ADDR_VAR 0 1
20469: PUSH
20470: LD_VAR 0 1
20474: PPUSH
20475: LD_VAR 0 3
20479: PPUSH
20480: LD_VAR 0 5
20484: PPUSH
20485: CALL_OW 1
20489: ST_TO_ADDR
// result := list ;
20490: LD_ADDR_VAR 0 4
20494: PUSH
20495: LD_VAR 0 1
20499: ST_TO_ADDR
// end ;
20500: LD_VAR 0 4
20504: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20505: LD_INT 0
20507: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20508: LD_ADDR_VAR 0 5
20512: PUSH
20513: LD_VAR 0 1
20517: PPUSH
20518: CALL_OW 250
20522: PPUSH
20523: LD_VAR 0 1
20527: PPUSH
20528: CALL_OW 251
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: LD_VAR 0 3
20542: PPUSH
20543: LD_VAR 0 4
20547: PPUSH
20548: CALL 20558 0 5
20552: ST_TO_ADDR
// end ;
20553: LD_VAR 0 5
20557: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20558: LD_INT 0
20560: PPUSH
20561: PPUSH
20562: PPUSH
20563: PPUSH
// if not list then
20564: LD_VAR 0 3
20568: NOT
20569: IFFALSE 20573
// exit ;
20571: GO 20961
// result := [ ] ;
20573: LD_ADDR_VAR 0 6
20577: PUSH
20578: EMPTY
20579: ST_TO_ADDR
// for i in list do
20580: LD_ADDR_VAR 0 7
20584: PUSH
20585: LD_VAR 0 3
20589: PUSH
20590: FOR_IN
20591: IFFALSE 20793
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20593: LD_ADDR_VAR 0 9
20597: PUSH
20598: LD_VAR 0 7
20602: PPUSH
20603: LD_VAR 0 1
20607: PPUSH
20608: LD_VAR 0 2
20612: PPUSH
20613: CALL_OW 297
20617: ST_TO_ADDR
// if not result then
20618: LD_VAR 0 6
20622: NOT
20623: IFFALSE 20649
// result := [ [ i , tmp ] ] else
20625: LD_ADDR_VAR 0 6
20629: PUSH
20630: LD_VAR 0 7
20634: PUSH
20635: LD_VAR 0 9
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: ST_TO_ADDR
20647: GO 20791
// begin if result [ result ] [ 2 ] < tmp then
20649: LD_VAR 0 6
20653: PUSH
20654: LD_VAR 0 6
20658: ARRAY
20659: PUSH
20660: LD_INT 2
20662: ARRAY
20663: PUSH
20664: LD_VAR 0 9
20668: LESS
20669: IFFALSE 20711
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20671: LD_ADDR_VAR 0 6
20675: PUSH
20676: LD_VAR 0 6
20680: PPUSH
20681: LD_VAR 0 6
20685: PUSH
20686: LD_INT 1
20688: PLUS
20689: PPUSH
20690: LD_VAR 0 7
20694: PUSH
20695: LD_VAR 0 9
20699: PUSH
20700: EMPTY
20701: LIST
20702: LIST
20703: PPUSH
20704: CALL_OW 2
20708: ST_TO_ADDR
20709: GO 20791
// for j = 1 to result do
20711: LD_ADDR_VAR 0 8
20715: PUSH
20716: DOUBLE
20717: LD_INT 1
20719: DEC
20720: ST_TO_ADDR
20721: LD_VAR 0 6
20725: PUSH
20726: FOR_TO
20727: IFFALSE 20789
// begin if tmp < result [ j ] [ 2 ] then
20729: LD_VAR 0 9
20733: PUSH
20734: LD_VAR 0 6
20738: PUSH
20739: LD_VAR 0 8
20743: ARRAY
20744: PUSH
20745: LD_INT 2
20747: ARRAY
20748: LESS
20749: IFFALSE 20787
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20751: LD_ADDR_VAR 0 6
20755: PUSH
20756: LD_VAR 0 6
20760: PPUSH
20761: LD_VAR 0 8
20765: PPUSH
20766: LD_VAR 0 7
20770: PUSH
20771: LD_VAR 0 9
20775: PUSH
20776: EMPTY
20777: LIST
20778: LIST
20779: PPUSH
20780: CALL_OW 2
20784: ST_TO_ADDR
// break ;
20785: GO 20789
// end ; end ;
20787: GO 20726
20789: POP
20790: POP
// end ; end ;
20791: GO 20590
20793: POP
20794: POP
// if result and not asc then
20795: LD_VAR 0 6
20799: PUSH
20800: LD_VAR 0 4
20804: NOT
20805: AND
20806: IFFALSE 20881
// begin tmp := result ;
20808: LD_ADDR_VAR 0 9
20812: PUSH
20813: LD_VAR 0 6
20817: ST_TO_ADDR
// for i = tmp downto 1 do
20818: LD_ADDR_VAR 0 7
20822: PUSH
20823: DOUBLE
20824: LD_VAR 0 9
20828: INC
20829: ST_TO_ADDR
20830: LD_INT 1
20832: PUSH
20833: FOR_DOWNTO
20834: IFFALSE 20879
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20836: LD_ADDR_VAR 0 6
20840: PUSH
20841: LD_VAR 0 6
20845: PPUSH
20846: LD_VAR 0 9
20850: PUSH
20851: LD_VAR 0 7
20855: MINUS
20856: PUSH
20857: LD_INT 1
20859: PLUS
20860: PPUSH
20861: LD_VAR 0 9
20865: PUSH
20866: LD_VAR 0 7
20870: ARRAY
20871: PPUSH
20872: CALL_OW 1
20876: ST_TO_ADDR
20877: GO 20833
20879: POP
20880: POP
// end ; tmp := [ ] ;
20881: LD_ADDR_VAR 0 9
20885: PUSH
20886: EMPTY
20887: ST_TO_ADDR
// if mode then
20888: LD_VAR 0 5
20892: IFFALSE 20961
// begin for i = 1 to result do
20894: LD_ADDR_VAR 0 7
20898: PUSH
20899: DOUBLE
20900: LD_INT 1
20902: DEC
20903: ST_TO_ADDR
20904: LD_VAR 0 6
20908: PUSH
20909: FOR_TO
20910: IFFALSE 20949
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20912: LD_ADDR_VAR 0 9
20916: PUSH
20917: LD_VAR 0 9
20921: PPUSH
20922: LD_VAR 0 7
20926: PPUSH
20927: LD_VAR 0 6
20931: PUSH
20932: LD_VAR 0 7
20936: ARRAY
20937: PUSH
20938: LD_INT 1
20940: ARRAY
20941: PPUSH
20942: CALL_OW 1
20946: ST_TO_ADDR
20947: GO 20909
20949: POP
20950: POP
// result := tmp ;
20951: LD_ADDR_VAR 0 6
20955: PUSH
20956: LD_VAR 0 9
20960: ST_TO_ADDR
// end ; end ;
20961: LD_VAR 0 6
20965: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20966: LD_INT 0
20968: PPUSH
20969: PPUSH
20970: PPUSH
20971: PPUSH
20972: PPUSH
20973: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20974: LD_ADDR_VAR 0 5
20978: PUSH
20979: LD_INT 0
20981: PUSH
20982: LD_INT 0
20984: PUSH
20985: LD_INT 0
20987: PUSH
20988: EMPTY
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: ST_TO_ADDR
// if not x or not y then
20996: LD_VAR 0 2
21000: NOT
21001: PUSH
21002: LD_VAR 0 3
21006: NOT
21007: OR
21008: IFFALSE 21012
// exit ;
21010: GO 22662
// if not range then
21012: LD_VAR 0 4
21016: NOT
21017: IFFALSE 21027
// range := 10 ;
21019: LD_ADDR_VAR 0 4
21023: PUSH
21024: LD_INT 10
21026: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21027: LD_ADDR_VAR 0 8
21031: PUSH
21032: LD_INT 81
21034: PUSH
21035: LD_VAR 0 1
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: PUSH
21044: LD_INT 92
21046: PUSH
21047: LD_VAR 0 2
21051: PUSH
21052: LD_VAR 0 3
21056: PUSH
21057: LD_VAR 0 4
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: LIST
21066: LIST
21067: PUSH
21068: LD_INT 3
21070: PUSH
21071: LD_INT 21
21073: PUSH
21074: LD_INT 3
21076: PUSH
21077: EMPTY
21078: LIST
21079: LIST
21080: PUSH
21081: EMPTY
21082: LIST
21083: LIST
21084: PUSH
21085: EMPTY
21086: LIST
21087: LIST
21088: LIST
21089: PPUSH
21090: CALL_OW 69
21094: ST_TO_ADDR
// if not tmp then
21095: LD_VAR 0 8
21099: NOT
21100: IFFALSE 21104
// exit ;
21102: GO 22662
// for i in tmp do
21104: LD_ADDR_VAR 0 6
21108: PUSH
21109: LD_VAR 0 8
21113: PUSH
21114: FOR_IN
21115: IFFALSE 22637
// begin points := [ 0 , 0 , 0 ] ;
21117: LD_ADDR_VAR 0 9
21121: PUSH
21122: LD_INT 0
21124: PUSH
21125: LD_INT 0
21127: PUSH
21128: LD_INT 0
21130: PUSH
21131: EMPTY
21132: LIST
21133: LIST
21134: LIST
21135: ST_TO_ADDR
// bpoints := 1 ;
21136: LD_ADDR_VAR 0 10
21140: PUSH
21141: LD_INT 1
21143: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21144: LD_VAR 0 6
21148: PPUSH
21149: CALL_OW 247
21153: PUSH
21154: LD_INT 1
21156: DOUBLE
21157: EQUAL
21158: IFTRUE 21162
21160: GO 21740
21162: POP
// begin if GetClass ( i ) = 1 then
21163: LD_VAR 0 6
21167: PPUSH
21168: CALL_OW 257
21172: PUSH
21173: LD_INT 1
21175: EQUAL
21176: IFFALSE 21197
// points := [ 10 , 5 , 3 ] ;
21178: LD_ADDR_VAR 0 9
21182: PUSH
21183: LD_INT 10
21185: PUSH
21186: LD_INT 5
21188: PUSH
21189: LD_INT 3
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: LIST
21196: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21197: LD_VAR 0 6
21201: PPUSH
21202: CALL_OW 257
21206: PUSH
21207: LD_INT 2
21209: PUSH
21210: LD_INT 3
21212: PUSH
21213: LD_INT 4
21215: PUSH
21216: EMPTY
21217: LIST
21218: LIST
21219: LIST
21220: IN
21221: IFFALSE 21242
// points := [ 3 , 2 , 1 ] ;
21223: LD_ADDR_VAR 0 9
21227: PUSH
21228: LD_INT 3
21230: PUSH
21231: LD_INT 2
21233: PUSH
21234: LD_INT 1
21236: PUSH
21237: EMPTY
21238: LIST
21239: LIST
21240: LIST
21241: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21242: LD_VAR 0 6
21246: PPUSH
21247: CALL_OW 257
21251: PUSH
21252: LD_INT 5
21254: EQUAL
21255: IFFALSE 21276
// points := [ 130 , 5 , 2 ] ;
21257: LD_ADDR_VAR 0 9
21261: PUSH
21262: LD_INT 130
21264: PUSH
21265: LD_INT 5
21267: PUSH
21268: LD_INT 2
21270: PUSH
21271: EMPTY
21272: LIST
21273: LIST
21274: LIST
21275: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21276: LD_VAR 0 6
21280: PPUSH
21281: CALL_OW 257
21285: PUSH
21286: LD_INT 8
21288: EQUAL
21289: IFFALSE 21310
// points := [ 35 , 35 , 30 ] ;
21291: LD_ADDR_VAR 0 9
21295: PUSH
21296: LD_INT 35
21298: PUSH
21299: LD_INT 35
21301: PUSH
21302: LD_INT 30
21304: PUSH
21305: EMPTY
21306: LIST
21307: LIST
21308: LIST
21309: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21310: LD_VAR 0 6
21314: PPUSH
21315: CALL_OW 257
21319: PUSH
21320: LD_INT 9
21322: EQUAL
21323: IFFALSE 21344
// points := [ 20 , 55 , 40 ] ;
21325: LD_ADDR_VAR 0 9
21329: PUSH
21330: LD_INT 20
21332: PUSH
21333: LD_INT 55
21335: PUSH
21336: LD_INT 40
21338: PUSH
21339: EMPTY
21340: LIST
21341: LIST
21342: LIST
21343: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21344: LD_VAR 0 6
21348: PPUSH
21349: CALL_OW 257
21353: PUSH
21354: LD_INT 12
21356: PUSH
21357: LD_INT 16
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: IN
21364: IFFALSE 21385
// points := [ 5 , 3 , 2 ] ;
21366: LD_ADDR_VAR 0 9
21370: PUSH
21371: LD_INT 5
21373: PUSH
21374: LD_INT 3
21376: PUSH
21377: LD_INT 2
21379: PUSH
21380: EMPTY
21381: LIST
21382: LIST
21383: LIST
21384: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21385: LD_VAR 0 6
21389: PPUSH
21390: CALL_OW 257
21394: PUSH
21395: LD_INT 17
21397: EQUAL
21398: IFFALSE 21419
// points := [ 100 , 50 , 75 ] ;
21400: LD_ADDR_VAR 0 9
21404: PUSH
21405: LD_INT 100
21407: PUSH
21408: LD_INT 50
21410: PUSH
21411: LD_INT 75
21413: PUSH
21414: EMPTY
21415: LIST
21416: LIST
21417: LIST
21418: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21419: LD_VAR 0 6
21423: PPUSH
21424: CALL_OW 257
21428: PUSH
21429: LD_INT 15
21431: EQUAL
21432: IFFALSE 21453
// points := [ 10 , 5 , 3 ] ;
21434: LD_ADDR_VAR 0 9
21438: PUSH
21439: LD_INT 10
21441: PUSH
21442: LD_INT 5
21444: PUSH
21445: LD_INT 3
21447: PUSH
21448: EMPTY
21449: LIST
21450: LIST
21451: LIST
21452: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21453: LD_VAR 0 6
21457: PPUSH
21458: CALL_OW 257
21462: PUSH
21463: LD_INT 14
21465: EQUAL
21466: IFFALSE 21487
// points := [ 10 , 0 , 0 ] ;
21468: LD_ADDR_VAR 0 9
21472: PUSH
21473: LD_INT 10
21475: PUSH
21476: LD_INT 0
21478: PUSH
21479: LD_INT 0
21481: PUSH
21482: EMPTY
21483: LIST
21484: LIST
21485: LIST
21486: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21487: LD_VAR 0 6
21491: PPUSH
21492: CALL_OW 257
21496: PUSH
21497: LD_INT 11
21499: EQUAL
21500: IFFALSE 21521
// points := [ 30 , 10 , 5 ] ;
21502: LD_ADDR_VAR 0 9
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 10
21512: PUSH
21513: LD_INT 5
21515: PUSH
21516: EMPTY
21517: LIST
21518: LIST
21519: LIST
21520: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21521: LD_VAR 0 1
21525: PPUSH
21526: LD_INT 5
21528: PPUSH
21529: CALL_OW 321
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21554
// bpoints := bpoints * 1.8 ;
21539: LD_ADDR_VAR 0 10
21543: PUSH
21544: LD_VAR 0 10
21548: PUSH
21549: LD_REAL  1.80000000000000E+0000
21552: MUL
21553: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21554: LD_VAR 0 6
21558: PPUSH
21559: CALL_OW 257
21563: PUSH
21564: LD_INT 1
21566: PUSH
21567: LD_INT 2
21569: PUSH
21570: LD_INT 3
21572: PUSH
21573: LD_INT 4
21575: PUSH
21576: EMPTY
21577: LIST
21578: LIST
21579: LIST
21580: LIST
21581: IN
21582: PUSH
21583: LD_VAR 0 1
21587: PPUSH
21588: LD_INT 51
21590: PPUSH
21591: CALL_OW 321
21595: PUSH
21596: LD_INT 2
21598: EQUAL
21599: AND
21600: IFFALSE 21617
// bpoints := bpoints * 1.2 ;
21602: LD_ADDR_VAR 0 10
21606: PUSH
21607: LD_VAR 0 10
21611: PUSH
21612: LD_REAL  1.20000000000000E+0000
21615: MUL
21616: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21617: LD_VAR 0 6
21621: PPUSH
21622: CALL_OW 257
21626: PUSH
21627: LD_INT 5
21629: PUSH
21630: LD_INT 7
21632: PUSH
21633: LD_INT 9
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: IN
21641: PUSH
21642: LD_VAR 0 1
21646: PPUSH
21647: LD_INT 52
21649: PPUSH
21650: CALL_OW 321
21654: PUSH
21655: LD_INT 2
21657: EQUAL
21658: AND
21659: IFFALSE 21676
// bpoints := bpoints * 1.5 ;
21661: LD_ADDR_VAR 0 10
21665: PUSH
21666: LD_VAR 0 10
21670: PUSH
21671: LD_REAL  1.50000000000000E+0000
21674: MUL
21675: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21676: LD_VAR 0 1
21680: PPUSH
21681: LD_INT 66
21683: PPUSH
21684: CALL_OW 321
21688: PUSH
21689: LD_INT 2
21691: EQUAL
21692: IFFALSE 21709
// bpoints := bpoints * 1.1 ;
21694: LD_ADDR_VAR 0 10
21698: PUSH
21699: LD_VAR 0 10
21703: PUSH
21704: LD_REAL  1.10000000000000E+0000
21707: MUL
21708: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21709: LD_ADDR_VAR 0 10
21713: PUSH
21714: LD_VAR 0 10
21718: PUSH
21719: LD_VAR 0 6
21723: PPUSH
21724: LD_INT 1
21726: PPUSH
21727: CALL_OW 259
21731: PUSH
21732: LD_REAL  1.15000000000000E+0000
21735: MUL
21736: MUL
21737: ST_TO_ADDR
// end ; unit_vehicle :
21738: GO 22566
21740: LD_INT 2
21742: DOUBLE
21743: EQUAL
21744: IFTRUE 21748
21746: GO 22554
21748: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21749: LD_VAR 0 6
21753: PPUSH
21754: CALL_OW 264
21758: PUSH
21759: LD_INT 2
21761: PUSH
21762: LD_INT 42
21764: PUSH
21765: LD_INT 24
21767: PUSH
21768: EMPTY
21769: LIST
21770: LIST
21771: LIST
21772: IN
21773: IFFALSE 21794
// points := [ 25 , 5 , 3 ] ;
21775: LD_ADDR_VAR 0 9
21779: PUSH
21780: LD_INT 25
21782: PUSH
21783: LD_INT 5
21785: PUSH
21786: LD_INT 3
21788: PUSH
21789: EMPTY
21790: LIST
21791: LIST
21792: LIST
21793: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21794: LD_VAR 0 6
21798: PPUSH
21799: CALL_OW 264
21803: PUSH
21804: LD_INT 4
21806: PUSH
21807: LD_INT 43
21809: PUSH
21810: LD_INT 25
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: LIST
21817: IN
21818: IFFALSE 21839
// points := [ 40 , 15 , 5 ] ;
21820: LD_ADDR_VAR 0 9
21824: PUSH
21825: LD_INT 40
21827: PUSH
21828: LD_INT 15
21830: PUSH
21831: LD_INT 5
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: LIST
21838: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21839: LD_VAR 0 6
21843: PPUSH
21844: CALL_OW 264
21848: PUSH
21849: LD_INT 3
21851: PUSH
21852: LD_INT 23
21854: PUSH
21855: EMPTY
21856: LIST
21857: LIST
21858: IN
21859: IFFALSE 21880
// points := [ 7 , 25 , 8 ] ;
21861: LD_ADDR_VAR 0 9
21865: PUSH
21866: LD_INT 7
21868: PUSH
21869: LD_INT 25
21871: PUSH
21872: LD_INT 8
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21880: LD_VAR 0 6
21884: PPUSH
21885: CALL_OW 264
21889: PUSH
21890: LD_INT 5
21892: PUSH
21893: LD_INT 27
21895: PUSH
21896: LD_INT 44
21898: PUSH
21899: EMPTY
21900: LIST
21901: LIST
21902: LIST
21903: IN
21904: IFFALSE 21925
// points := [ 14 , 50 , 16 ] ;
21906: LD_ADDR_VAR 0 9
21910: PUSH
21911: LD_INT 14
21913: PUSH
21914: LD_INT 50
21916: PUSH
21917: LD_INT 16
21919: PUSH
21920: EMPTY
21921: LIST
21922: LIST
21923: LIST
21924: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21925: LD_VAR 0 6
21929: PPUSH
21930: CALL_OW 264
21934: PUSH
21935: LD_INT 6
21937: PUSH
21938: LD_INT 46
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: IN
21945: IFFALSE 21966
// points := [ 32 , 120 , 70 ] ;
21947: LD_ADDR_VAR 0 9
21951: PUSH
21952: LD_INT 32
21954: PUSH
21955: LD_INT 120
21957: PUSH
21958: LD_INT 70
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: LIST
21965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21966: LD_VAR 0 6
21970: PPUSH
21971: CALL_OW 264
21975: PUSH
21976: LD_INT 7
21978: PUSH
21979: LD_INT 28
21981: PUSH
21982: LD_INT 45
21984: PUSH
21985: LD_INT 92
21987: PUSH
21988: EMPTY
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: IN
21994: IFFALSE 22015
// points := [ 35 , 20 , 45 ] ;
21996: LD_ADDR_VAR 0 9
22000: PUSH
22001: LD_INT 35
22003: PUSH
22004: LD_INT 20
22006: PUSH
22007: LD_INT 45
22009: PUSH
22010: EMPTY
22011: LIST
22012: LIST
22013: LIST
22014: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22015: LD_VAR 0 6
22019: PPUSH
22020: CALL_OW 264
22024: PUSH
22025: LD_INT 47
22027: PUSH
22028: EMPTY
22029: LIST
22030: IN
22031: IFFALSE 22052
// points := [ 67 , 45 , 75 ] ;
22033: LD_ADDR_VAR 0 9
22037: PUSH
22038: LD_INT 67
22040: PUSH
22041: LD_INT 45
22043: PUSH
22044: LD_INT 75
22046: PUSH
22047: EMPTY
22048: LIST
22049: LIST
22050: LIST
22051: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22052: LD_VAR 0 6
22056: PPUSH
22057: CALL_OW 264
22061: PUSH
22062: LD_INT 26
22064: PUSH
22065: EMPTY
22066: LIST
22067: IN
22068: IFFALSE 22089
// points := [ 120 , 30 , 80 ] ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_INT 120
22077: PUSH
22078: LD_INT 30
22080: PUSH
22081: LD_INT 80
22083: PUSH
22084: EMPTY
22085: LIST
22086: LIST
22087: LIST
22088: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22089: LD_VAR 0 6
22093: PPUSH
22094: CALL_OW 264
22098: PUSH
22099: LD_INT 22
22101: PUSH
22102: EMPTY
22103: LIST
22104: IN
22105: IFFALSE 22126
// points := [ 40 , 1 , 1 ] ;
22107: LD_ADDR_VAR 0 9
22111: PUSH
22112: LD_INT 40
22114: PUSH
22115: LD_INT 1
22117: PUSH
22118: LD_INT 1
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: LIST
22125: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22126: LD_VAR 0 6
22130: PPUSH
22131: CALL_OW 264
22135: PUSH
22136: LD_INT 29
22138: PUSH
22139: EMPTY
22140: LIST
22141: IN
22142: IFFALSE 22163
// points := [ 70 , 200 , 400 ] ;
22144: LD_ADDR_VAR 0 9
22148: PUSH
22149: LD_INT 70
22151: PUSH
22152: LD_INT 200
22154: PUSH
22155: LD_INT 400
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: LIST
22162: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22163: LD_VAR 0 6
22167: PPUSH
22168: CALL_OW 264
22172: PUSH
22173: LD_INT 14
22175: PUSH
22176: LD_INT 53
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: IN
22183: IFFALSE 22204
// points := [ 40 , 10 , 20 ] ;
22185: LD_ADDR_VAR 0 9
22189: PUSH
22190: LD_INT 40
22192: PUSH
22193: LD_INT 10
22195: PUSH
22196: LD_INT 20
22198: PUSH
22199: EMPTY
22200: LIST
22201: LIST
22202: LIST
22203: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22204: LD_VAR 0 6
22208: PPUSH
22209: CALL_OW 264
22213: PUSH
22214: LD_INT 9
22216: PUSH
22217: EMPTY
22218: LIST
22219: IN
22220: IFFALSE 22241
// points := [ 5 , 70 , 20 ] ;
22222: LD_ADDR_VAR 0 9
22226: PUSH
22227: LD_INT 5
22229: PUSH
22230: LD_INT 70
22232: PUSH
22233: LD_INT 20
22235: PUSH
22236: EMPTY
22237: LIST
22238: LIST
22239: LIST
22240: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22241: LD_VAR 0 6
22245: PPUSH
22246: CALL_OW 264
22250: PUSH
22251: LD_INT 10
22253: PUSH
22254: EMPTY
22255: LIST
22256: IN
22257: IFFALSE 22278
// points := [ 35 , 110 , 70 ] ;
22259: LD_ADDR_VAR 0 9
22263: PUSH
22264: LD_INT 35
22266: PUSH
22267: LD_INT 110
22269: PUSH
22270: LD_INT 70
22272: PUSH
22273: EMPTY
22274: LIST
22275: LIST
22276: LIST
22277: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22278: LD_VAR 0 6
22282: PPUSH
22283: CALL_OW 265
22287: PUSH
22288: LD_INT 25
22290: EQUAL
22291: IFFALSE 22312
// points := [ 80 , 65 , 100 ] ;
22293: LD_ADDR_VAR 0 9
22297: PUSH
22298: LD_INT 80
22300: PUSH
22301: LD_INT 65
22303: PUSH
22304: LD_INT 100
22306: PUSH
22307: EMPTY
22308: LIST
22309: LIST
22310: LIST
22311: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22312: LD_VAR 0 6
22316: PPUSH
22317: CALL_OW 263
22321: PUSH
22322: LD_INT 1
22324: EQUAL
22325: IFFALSE 22360
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22327: LD_ADDR_VAR 0 10
22331: PUSH
22332: LD_VAR 0 10
22336: PUSH
22337: LD_VAR 0 6
22341: PPUSH
22342: CALL_OW 311
22346: PPUSH
22347: LD_INT 3
22349: PPUSH
22350: CALL_OW 259
22354: PUSH
22355: LD_INT 4
22357: MUL
22358: MUL
22359: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22360: LD_VAR 0 6
22364: PPUSH
22365: CALL_OW 263
22369: PUSH
22370: LD_INT 2
22372: EQUAL
22373: IFFALSE 22424
// begin j := IsControledBy ( i ) ;
22375: LD_ADDR_VAR 0 7
22379: PUSH
22380: LD_VAR 0 6
22384: PPUSH
22385: CALL_OW 312
22389: ST_TO_ADDR
// if j then
22390: LD_VAR 0 7
22394: IFFALSE 22424
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22396: LD_ADDR_VAR 0 10
22400: PUSH
22401: LD_VAR 0 10
22405: PUSH
22406: LD_VAR 0 7
22410: PPUSH
22411: LD_INT 3
22413: PPUSH
22414: CALL_OW 259
22418: PUSH
22419: LD_INT 3
22421: MUL
22422: MUL
22423: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22424: LD_VAR 0 6
22428: PPUSH
22429: CALL_OW 264
22433: PUSH
22434: LD_INT 5
22436: PUSH
22437: LD_INT 6
22439: PUSH
22440: LD_INT 46
22442: PUSH
22443: LD_INT 44
22445: PUSH
22446: LD_INT 47
22448: PUSH
22449: LD_INT 45
22451: PUSH
22452: LD_INT 28
22454: PUSH
22455: LD_INT 7
22457: PUSH
22458: LD_INT 27
22460: PUSH
22461: LD_INT 29
22463: PUSH
22464: EMPTY
22465: LIST
22466: LIST
22467: LIST
22468: LIST
22469: LIST
22470: LIST
22471: LIST
22472: LIST
22473: LIST
22474: LIST
22475: IN
22476: PUSH
22477: LD_VAR 0 1
22481: PPUSH
22482: LD_INT 52
22484: PPUSH
22485: CALL_OW 321
22489: PUSH
22490: LD_INT 2
22492: EQUAL
22493: AND
22494: IFFALSE 22511
// bpoints := bpoints * 1.2 ;
22496: LD_ADDR_VAR 0 10
22500: PUSH
22501: LD_VAR 0 10
22505: PUSH
22506: LD_REAL  1.20000000000000E+0000
22509: MUL
22510: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22511: LD_VAR 0 6
22515: PPUSH
22516: CALL_OW 264
22520: PUSH
22521: LD_INT 6
22523: PUSH
22524: LD_INT 46
22526: PUSH
22527: LD_INT 47
22529: PUSH
22530: EMPTY
22531: LIST
22532: LIST
22533: LIST
22534: IN
22535: IFFALSE 22552
// bpoints := bpoints * 1.2 ;
22537: LD_ADDR_VAR 0 10
22541: PUSH
22542: LD_VAR 0 10
22546: PUSH
22547: LD_REAL  1.20000000000000E+0000
22550: MUL
22551: ST_TO_ADDR
// end ; unit_building :
22552: GO 22566
22554: LD_INT 3
22556: DOUBLE
22557: EQUAL
22558: IFTRUE 22562
22560: GO 22565
22562: POP
// ; end ;
22563: GO 22566
22565: POP
// for j = 1 to 3 do
22566: LD_ADDR_VAR 0 7
22570: PUSH
22571: DOUBLE
22572: LD_INT 1
22574: DEC
22575: ST_TO_ADDR
22576: LD_INT 3
22578: PUSH
22579: FOR_TO
22580: IFFALSE 22633
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22582: LD_ADDR_VAR 0 5
22586: PUSH
22587: LD_VAR 0 5
22591: PPUSH
22592: LD_VAR 0 7
22596: PPUSH
22597: LD_VAR 0 5
22601: PUSH
22602: LD_VAR 0 7
22606: ARRAY
22607: PUSH
22608: LD_VAR 0 9
22612: PUSH
22613: LD_VAR 0 7
22617: ARRAY
22618: PUSH
22619: LD_VAR 0 10
22623: MUL
22624: PLUS
22625: PPUSH
22626: CALL_OW 1
22630: ST_TO_ADDR
22631: GO 22579
22633: POP
22634: POP
// end ;
22635: GO 21114
22637: POP
22638: POP
// result := Replace ( result , 4 , tmp ) ;
22639: LD_ADDR_VAR 0 5
22643: PUSH
22644: LD_VAR 0 5
22648: PPUSH
22649: LD_INT 4
22651: PPUSH
22652: LD_VAR 0 8
22656: PPUSH
22657: CALL_OW 1
22661: ST_TO_ADDR
// end ;
22662: LD_VAR 0 5
22666: RET
// export function DangerAtRange ( unit , range ) ; begin
22667: LD_INT 0
22669: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22670: LD_ADDR_VAR 0 3
22674: PUSH
22675: LD_VAR 0 1
22679: PPUSH
22680: CALL_OW 255
22684: PPUSH
22685: LD_VAR 0 1
22689: PPUSH
22690: CALL_OW 250
22694: PPUSH
22695: LD_VAR 0 1
22699: PPUSH
22700: CALL_OW 251
22704: PPUSH
22705: LD_VAR 0 2
22709: PPUSH
22710: CALL 20966 0 4
22714: ST_TO_ADDR
// end ;
22715: LD_VAR 0 3
22719: RET
// export function DangerInArea ( side , area ) ; begin
22720: LD_INT 0
22722: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22723: LD_ADDR_VAR 0 3
22727: PUSH
22728: LD_VAR 0 2
22732: PPUSH
22733: LD_INT 81
22735: PUSH
22736: LD_VAR 0 1
22740: PUSH
22741: EMPTY
22742: LIST
22743: LIST
22744: PPUSH
22745: CALL_OW 70
22749: ST_TO_ADDR
// end ;
22750: LD_VAR 0 3
22754: RET
// export function IsExtension ( b ) ; begin
22755: LD_INT 0
22757: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22758: LD_ADDR_VAR 0 2
22762: PUSH
22763: LD_VAR 0 1
22767: PUSH
22768: LD_INT 23
22770: PUSH
22771: LD_INT 20
22773: PUSH
22774: LD_INT 22
22776: PUSH
22777: LD_INT 17
22779: PUSH
22780: LD_INT 24
22782: PUSH
22783: LD_INT 21
22785: PUSH
22786: LD_INT 19
22788: PUSH
22789: LD_INT 16
22791: PUSH
22792: LD_INT 25
22794: PUSH
22795: LD_INT 18
22797: PUSH
22798: EMPTY
22799: LIST
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: LIST
22805: LIST
22806: LIST
22807: LIST
22808: LIST
22809: IN
22810: ST_TO_ADDR
// end ;
22811: LD_VAR 0 2
22815: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22816: LD_INT 0
22818: PPUSH
22819: PPUSH
22820: PPUSH
// result := [ ] ;
22821: LD_ADDR_VAR 0 4
22825: PUSH
22826: EMPTY
22827: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22828: LD_ADDR_VAR 0 5
22832: PUSH
22833: LD_VAR 0 2
22837: PPUSH
22838: LD_INT 21
22840: PUSH
22841: LD_INT 3
22843: PUSH
22844: EMPTY
22845: LIST
22846: LIST
22847: PPUSH
22848: CALL_OW 70
22852: ST_TO_ADDR
// if not tmp then
22853: LD_VAR 0 5
22857: NOT
22858: IFFALSE 22862
// exit ;
22860: GO 22926
// if checkLink then
22862: LD_VAR 0 3
22866: IFFALSE 22916
// begin for i in tmp do
22868: LD_ADDR_VAR 0 6
22872: PUSH
22873: LD_VAR 0 5
22877: PUSH
22878: FOR_IN
22879: IFFALSE 22914
// if GetBase ( i ) <> base then
22881: LD_VAR 0 6
22885: PPUSH
22886: CALL_OW 274
22890: PUSH
22891: LD_VAR 0 1
22895: NONEQUAL
22896: IFFALSE 22912
// ComLinkToBase ( base , i ) ;
22898: LD_VAR 0 1
22902: PPUSH
22903: LD_VAR 0 6
22907: PPUSH
22908: CALL_OW 169
22912: GO 22878
22914: POP
22915: POP
// end ; result := tmp ;
22916: LD_ADDR_VAR 0 4
22920: PUSH
22921: LD_VAR 0 5
22925: ST_TO_ADDR
// end ;
22926: LD_VAR 0 4
22930: RET
// export function ComComplete ( units , b ) ; var i ; begin
22931: LD_INT 0
22933: PPUSH
22934: PPUSH
// if not units then
22935: LD_VAR 0 1
22939: NOT
22940: IFFALSE 22944
// exit ;
22942: GO 23034
// for i in units do
22944: LD_ADDR_VAR 0 4
22948: PUSH
22949: LD_VAR 0 1
22953: PUSH
22954: FOR_IN
22955: IFFALSE 23032
// if BuildingStatus ( b ) = bs_build then
22957: LD_VAR 0 2
22961: PPUSH
22962: CALL_OW 461
22966: PUSH
22967: LD_INT 1
22969: EQUAL
22970: IFFALSE 23030
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22972: LD_VAR 0 4
22976: PPUSH
22977: LD_STRING h
22979: PUSH
22980: LD_VAR 0 2
22984: PPUSH
22985: CALL_OW 250
22989: PUSH
22990: LD_VAR 0 2
22994: PPUSH
22995: CALL_OW 251
22999: PUSH
23000: LD_VAR 0 2
23004: PUSH
23005: LD_INT 0
23007: PUSH
23008: LD_INT 0
23010: PUSH
23011: LD_INT 0
23013: PUSH
23014: EMPTY
23015: LIST
23016: LIST
23017: LIST
23018: LIST
23019: LIST
23020: LIST
23021: LIST
23022: PUSH
23023: EMPTY
23024: LIST
23025: PPUSH
23026: CALL_OW 446
23030: GO 22954
23032: POP
23033: POP
// end ;
23034: LD_VAR 0 3
23038: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23039: LD_INT 0
23041: PPUSH
23042: PPUSH
23043: PPUSH
23044: PPUSH
23045: PPUSH
23046: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23047: LD_VAR 0 1
23051: NOT
23052: PUSH
23053: LD_VAR 0 1
23057: PPUSH
23058: CALL_OW 263
23062: PUSH
23063: LD_INT 2
23065: NONEQUAL
23066: OR
23067: IFFALSE 23071
// exit ;
23069: GO 23387
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23071: LD_ADDR_VAR 0 6
23075: PUSH
23076: LD_INT 22
23078: PUSH
23079: LD_VAR 0 1
23083: PPUSH
23084: CALL_OW 255
23088: PUSH
23089: EMPTY
23090: LIST
23091: LIST
23092: PUSH
23093: LD_INT 2
23095: PUSH
23096: LD_INT 30
23098: PUSH
23099: LD_INT 36
23101: PUSH
23102: EMPTY
23103: LIST
23104: LIST
23105: PUSH
23106: LD_INT 34
23108: PUSH
23109: LD_INT 31
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: EMPTY
23117: LIST
23118: LIST
23119: LIST
23120: PUSH
23121: EMPTY
23122: LIST
23123: LIST
23124: PPUSH
23125: CALL_OW 69
23129: ST_TO_ADDR
// if not tmp then
23130: LD_VAR 0 6
23134: NOT
23135: IFFALSE 23139
// exit ;
23137: GO 23387
// result := [ ] ;
23139: LD_ADDR_VAR 0 2
23143: PUSH
23144: EMPTY
23145: ST_TO_ADDR
// for i in tmp do
23146: LD_ADDR_VAR 0 3
23150: PUSH
23151: LD_VAR 0 6
23155: PUSH
23156: FOR_IN
23157: IFFALSE 23228
// begin t := UnitsInside ( i ) ;
23159: LD_ADDR_VAR 0 4
23163: PUSH
23164: LD_VAR 0 3
23168: PPUSH
23169: CALL_OW 313
23173: ST_TO_ADDR
// if t then
23174: LD_VAR 0 4
23178: IFFALSE 23226
// for j in t do
23180: LD_ADDR_VAR 0 7
23184: PUSH
23185: LD_VAR 0 4
23189: PUSH
23190: FOR_IN
23191: IFFALSE 23224
// result := Replace ( result , result + 1 , j ) ;
23193: LD_ADDR_VAR 0 2
23197: PUSH
23198: LD_VAR 0 2
23202: PPUSH
23203: LD_VAR 0 2
23207: PUSH
23208: LD_INT 1
23210: PLUS
23211: PPUSH
23212: LD_VAR 0 7
23216: PPUSH
23217: CALL_OW 1
23221: ST_TO_ADDR
23222: GO 23190
23224: POP
23225: POP
// end ;
23226: GO 23156
23228: POP
23229: POP
// if not result then
23230: LD_VAR 0 2
23234: NOT
23235: IFFALSE 23239
// exit ;
23237: GO 23387
// mech := result [ 1 ] ;
23239: LD_ADDR_VAR 0 5
23243: PUSH
23244: LD_VAR 0 2
23248: PUSH
23249: LD_INT 1
23251: ARRAY
23252: ST_TO_ADDR
// if result > 1 then
23253: LD_VAR 0 2
23257: PUSH
23258: LD_INT 1
23260: GREATER
23261: IFFALSE 23373
// begin for i = 2 to result do
23263: LD_ADDR_VAR 0 3
23267: PUSH
23268: DOUBLE
23269: LD_INT 2
23271: DEC
23272: ST_TO_ADDR
23273: LD_VAR 0 2
23277: PUSH
23278: FOR_TO
23279: IFFALSE 23371
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23281: LD_ADDR_VAR 0 4
23285: PUSH
23286: LD_VAR 0 2
23290: PUSH
23291: LD_VAR 0 3
23295: ARRAY
23296: PPUSH
23297: LD_INT 3
23299: PPUSH
23300: CALL_OW 259
23304: PUSH
23305: LD_VAR 0 2
23309: PUSH
23310: LD_VAR 0 3
23314: ARRAY
23315: PPUSH
23316: CALL_OW 432
23320: MINUS
23321: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23322: LD_VAR 0 4
23326: PUSH
23327: LD_VAR 0 5
23331: PPUSH
23332: LD_INT 3
23334: PPUSH
23335: CALL_OW 259
23339: PUSH
23340: LD_VAR 0 5
23344: PPUSH
23345: CALL_OW 432
23349: MINUS
23350: GREATEREQUAL
23351: IFFALSE 23369
// mech := result [ i ] ;
23353: LD_ADDR_VAR 0 5
23357: PUSH
23358: LD_VAR 0 2
23362: PUSH
23363: LD_VAR 0 3
23367: ARRAY
23368: ST_TO_ADDR
// end ;
23369: GO 23278
23371: POP
23372: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23373: LD_VAR 0 1
23377: PPUSH
23378: LD_VAR 0 5
23382: PPUSH
23383: CALL_OW 135
// end ;
23387: LD_VAR 0 2
23391: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23392: LD_INT 0
23394: PPUSH
23395: PPUSH
23396: PPUSH
23397: PPUSH
23398: PPUSH
23399: PPUSH
23400: PPUSH
23401: PPUSH
23402: PPUSH
23403: PPUSH
23404: PPUSH
23405: PPUSH
23406: PPUSH
// result := [ ] ;
23407: LD_ADDR_VAR 0 7
23411: PUSH
23412: EMPTY
23413: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23414: LD_VAR 0 1
23418: PPUSH
23419: CALL_OW 266
23423: PUSH
23424: LD_INT 0
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: IN
23434: NOT
23435: IFFALSE 23439
// exit ;
23437: GO 25073
// if name then
23439: LD_VAR 0 3
23443: IFFALSE 23459
// SetBName ( base_dep , name ) ;
23445: LD_VAR 0 1
23449: PPUSH
23450: LD_VAR 0 3
23454: PPUSH
23455: CALL_OW 500
// base := GetBase ( base_dep ) ;
23459: LD_ADDR_VAR 0 15
23463: PUSH
23464: LD_VAR 0 1
23468: PPUSH
23469: CALL_OW 274
23473: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23474: LD_ADDR_VAR 0 16
23478: PUSH
23479: LD_VAR 0 1
23483: PPUSH
23484: CALL_OW 255
23488: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23489: LD_ADDR_VAR 0 17
23493: PUSH
23494: LD_VAR 0 1
23498: PPUSH
23499: CALL_OW 248
23503: ST_TO_ADDR
// if sources then
23504: LD_VAR 0 5
23508: IFFALSE 23555
// for i = 1 to 3 do
23510: LD_ADDR_VAR 0 8
23514: PUSH
23515: DOUBLE
23516: LD_INT 1
23518: DEC
23519: ST_TO_ADDR
23520: LD_INT 3
23522: PUSH
23523: FOR_TO
23524: IFFALSE 23553
// AddResourceType ( base , i , sources [ i ] ) ;
23526: LD_VAR 0 15
23530: PPUSH
23531: LD_VAR 0 8
23535: PPUSH
23536: LD_VAR 0 5
23540: PUSH
23541: LD_VAR 0 8
23545: ARRAY
23546: PPUSH
23547: CALL_OW 276
23551: GO 23523
23553: POP
23554: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23555: LD_ADDR_VAR 0 18
23559: PUSH
23560: LD_VAR 0 15
23564: PPUSH
23565: LD_VAR 0 2
23569: PPUSH
23570: LD_INT 1
23572: PPUSH
23573: CALL 22816 0 3
23577: ST_TO_ADDR
// InitHc ;
23578: CALL_OW 19
// InitUc ;
23582: CALL_OW 18
// uc_side := side ;
23586: LD_ADDR_OWVAR 20
23590: PUSH
23591: LD_VAR 0 16
23595: ST_TO_ADDR
// uc_nation := nation ;
23596: LD_ADDR_OWVAR 21
23600: PUSH
23601: LD_VAR 0 17
23605: ST_TO_ADDR
// if buildings then
23606: LD_VAR 0 18
23610: IFFALSE 24932
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23612: LD_ADDR_VAR 0 19
23616: PUSH
23617: LD_VAR 0 18
23621: PPUSH
23622: LD_INT 2
23624: PUSH
23625: LD_INT 30
23627: PUSH
23628: LD_INT 29
23630: PUSH
23631: EMPTY
23632: LIST
23633: LIST
23634: PUSH
23635: LD_INT 30
23637: PUSH
23638: LD_INT 30
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: LIST
23649: PPUSH
23650: CALL_OW 72
23654: ST_TO_ADDR
// if tmp then
23655: LD_VAR 0 19
23659: IFFALSE 23707
// for i in tmp do
23661: LD_ADDR_VAR 0 8
23665: PUSH
23666: LD_VAR 0 19
23670: PUSH
23671: FOR_IN
23672: IFFALSE 23705
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23674: LD_VAR 0 8
23678: PPUSH
23679: CALL_OW 250
23683: PPUSH
23684: LD_VAR 0 8
23688: PPUSH
23689: CALL_OW 251
23693: PPUSH
23694: LD_VAR 0 16
23698: PPUSH
23699: CALL_OW 441
23703: GO 23671
23705: POP
23706: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23707: LD_VAR 0 18
23711: PPUSH
23712: LD_INT 2
23714: PUSH
23715: LD_INT 30
23717: PUSH
23718: LD_INT 32
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PUSH
23725: LD_INT 30
23727: PUSH
23728: LD_INT 33
23730: PUSH
23731: EMPTY
23732: LIST
23733: LIST
23734: PUSH
23735: EMPTY
23736: LIST
23737: LIST
23738: LIST
23739: PPUSH
23740: CALL_OW 72
23744: IFFALSE 23832
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23746: LD_ADDR_VAR 0 8
23750: PUSH
23751: LD_VAR 0 18
23755: PPUSH
23756: LD_INT 2
23758: PUSH
23759: LD_INT 30
23761: PUSH
23762: LD_INT 32
23764: PUSH
23765: EMPTY
23766: LIST
23767: LIST
23768: PUSH
23769: LD_INT 30
23771: PUSH
23772: LD_INT 33
23774: PUSH
23775: EMPTY
23776: LIST
23777: LIST
23778: PUSH
23779: EMPTY
23780: LIST
23781: LIST
23782: LIST
23783: PPUSH
23784: CALL_OW 72
23788: PUSH
23789: FOR_IN
23790: IFFALSE 23830
// begin if not GetBWeapon ( i ) then
23792: LD_VAR 0 8
23796: PPUSH
23797: CALL_OW 269
23801: NOT
23802: IFFALSE 23828
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23804: LD_VAR 0 8
23808: PPUSH
23809: LD_VAR 0 8
23813: PPUSH
23814: LD_VAR 0 2
23818: PPUSH
23819: CALL 25078 0 2
23823: PPUSH
23824: CALL_OW 431
// end ;
23828: GO 23789
23830: POP
23831: POP
// end ; for i = 1 to personel do
23832: LD_ADDR_VAR 0 8
23836: PUSH
23837: DOUBLE
23838: LD_INT 1
23840: DEC
23841: ST_TO_ADDR
23842: LD_VAR 0 6
23846: PUSH
23847: FOR_TO
23848: IFFALSE 24912
// begin if i > 4 then
23850: LD_VAR 0 8
23854: PUSH
23855: LD_INT 4
23857: GREATER
23858: IFFALSE 23862
// break ;
23860: GO 24912
// case i of 1 :
23862: LD_VAR 0 8
23866: PUSH
23867: LD_INT 1
23869: DOUBLE
23870: EQUAL
23871: IFTRUE 23875
23873: GO 23955
23875: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23876: LD_ADDR_VAR 0 12
23880: PUSH
23881: LD_VAR 0 18
23885: PPUSH
23886: LD_INT 22
23888: PUSH
23889: LD_VAR 0 16
23893: PUSH
23894: EMPTY
23895: LIST
23896: LIST
23897: PUSH
23898: LD_INT 58
23900: PUSH
23901: EMPTY
23902: LIST
23903: PUSH
23904: LD_INT 2
23906: PUSH
23907: LD_INT 30
23909: PUSH
23910: LD_INT 32
23912: PUSH
23913: EMPTY
23914: LIST
23915: LIST
23916: PUSH
23917: LD_INT 30
23919: PUSH
23920: LD_INT 4
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 30
23929: PUSH
23930: LD_INT 5
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: LIST
23941: LIST
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: LIST
23947: PPUSH
23948: CALL_OW 72
23952: ST_TO_ADDR
23953: GO 24177
23955: LD_INT 2
23957: DOUBLE
23958: EQUAL
23959: IFTRUE 23963
23961: GO 24025
23963: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23964: LD_ADDR_VAR 0 12
23968: PUSH
23969: LD_VAR 0 18
23973: PPUSH
23974: LD_INT 22
23976: PUSH
23977: LD_VAR 0 16
23981: PUSH
23982: EMPTY
23983: LIST
23984: LIST
23985: PUSH
23986: LD_INT 2
23988: PUSH
23989: LD_INT 30
23991: PUSH
23992: LD_INT 0
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 30
24001: PUSH
24002: LD_INT 1
24004: PUSH
24005: EMPTY
24006: LIST
24007: LIST
24008: PUSH
24009: EMPTY
24010: LIST
24011: LIST
24012: LIST
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: PPUSH
24018: CALL_OW 72
24022: ST_TO_ADDR
24023: GO 24177
24025: LD_INT 3
24027: DOUBLE
24028: EQUAL
24029: IFTRUE 24033
24031: GO 24095
24033: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24034: LD_ADDR_VAR 0 12
24038: PUSH
24039: LD_VAR 0 18
24043: PPUSH
24044: LD_INT 22
24046: PUSH
24047: LD_VAR 0 16
24051: PUSH
24052: EMPTY
24053: LIST
24054: LIST
24055: PUSH
24056: LD_INT 2
24058: PUSH
24059: LD_INT 30
24061: PUSH
24062: LD_INT 2
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: PUSH
24069: LD_INT 30
24071: PUSH
24072: LD_INT 3
24074: PUSH
24075: EMPTY
24076: LIST
24077: LIST
24078: PUSH
24079: EMPTY
24080: LIST
24081: LIST
24082: LIST
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PPUSH
24088: CALL_OW 72
24092: ST_TO_ADDR
24093: GO 24177
24095: LD_INT 4
24097: DOUBLE
24098: EQUAL
24099: IFTRUE 24103
24101: GO 24176
24103: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24104: LD_ADDR_VAR 0 12
24108: PUSH
24109: LD_VAR 0 18
24113: PPUSH
24114: LD_INT 22
24116: PUSH
24117: LD_VAR 0 16
24121: PUSH
24122: EMPTY
24123: LIST
24124: LIST
24125: PUSH
24126: LD_INT 2
24128: PUSH
24129: LD_INT 30
24131: PUSH
24132: LD_INT 6
24134: PUSH
24135: EMPTY
24136: LIST
24137: LIST
24138: PUSH
24139: LD_INT 30
24141: PUSH
24142: LD_INT 7
24144: PUSH
24145: EMPTY
24146: LIST
24147: LIST
24148: PUSH
24149: LD_INT 30
24151: PUSH
24152: LD_INT 8
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: PUSH
24159: EMPTY
24160: LIST
24161: LIST
24162: LIST
24163: LIST
24164: PUSH
24165: EMPTY
24166: LIST
24167: LIST
24168: PPUSH
24169: CALL_OW 72
24173: ST_TO_ADDR
24174: GO 24177
24176: POP
// if i = 1 then
24177: LD_VAR 0 8
24181: PUSH
24182: LD_INT 1
24184: EQUAL
24185: IFFALSE 24296
// begin tmp := [ ] ;
24187: LD_ADDR_VAR 0 19
24191: PUSH
24192: EMPTY
24193: ST_TO_ADDR
// for j in f do
24194: LD_ADDR_VAR 0 9
24198: PUSH
24199: LD_VAR 0 12
24203: PUSH
24204: FOR_IN
24205: IFFALSE 24278
// if GetBType ( j ) = b_bunker then
24207: LD_VAR 0 9
24211: PPUSH
24212: CALL_OW 266
24216: PUSH
24217: LD_INT 32
24219: EQUAL
24220: IFFALSE 24247
// tmp := Insert ( tmp , 1 , j ) else
24222: LD_ADDR_VAR 0 19
24226: PUSH
24227: LD_VAR 0 19
24231: PPUSH
24232: LD_INT 1
24234: PPUSH
24235: LD_VAR 0 9
24239: PPUSH
24240: CALL_OW 2
24244: ST_TO_ADDR
24245: GO 24276
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24247: LD_ADDR_VAR 0 19
24251: PUSH
24252: LD_VAR 0 19
24256: PPUSH
24257: LD_VAR 0 19
24261: PUSH
24262: LD_INT 1
24264: PLUS
24265: PPUSH
24266: LD_VAR 0 9
24270: PPUSH
24271: CALL_OW 2
24275: ST_TO_ADDR
24276: GO 24204
24278: POP
24279: POP
// if tmp then
24280: LD_VAR 0 19
24284: IFFALSE 24296
// f := tmp ;
24286: LD_ADDR_VAR 0 12
24290: PUSH
24291: LD_VAR 0 19
24295: ST_TO_ADDR
// end ; x := personel [ i ] ;
24296: LD_ADDR_VAR 0 13
24300: PUSH
24301: LD_VAR 0 6
24305: PUSH
24306: LD_VAR 0 8
24310: ARRAY
24311: ST_TO_ADDR
// if x = - 1 then
24312: LD_VAR 0 13
24316: PUSH
24317: LD_INT 1
24319: NEG
24320: EQUAL
24321: IFFALSE 24530
// begin for j in f do
24323: LD_ADDR_VAR 0 9
24327: PUSH
24328: LD_VAR 0 12
24332: PUSH
24333: FOR_IN
24334: IFFALSE 24526
// repeat InitHc ;
24336: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24340: LD_VAR 0 9
24344: PPUSH
24345: CALL_OW 266
24349: PUSH
24350: LD_INT 5
24352: EQUAL
24353: IFFALSE 24423
// begin if UnitsInside ( j ) < 3 then
24355: LD_VAR 0 9
24359: PPUSH
24360: CALL_OW 313
24364: PUSH
24365: LD_INT 3
24367: LESS
24368: IFFALSE 24404
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24370: LD_INT 0
24372: PPUSH
24373: LD_INT 5
24375: PUSH
24376: LD_INT 8
24378: PUSH
24379: LD_INT 9
24381: PUSH
24382: EMPTY
24383: LIST
24384: LIST
24385: LIST
24386: PUSH
24387: LD_VAR 0 17
24391: ARRAY
24392: PPUSH
24393: LD_VAR 0 4
24397: PPUSH
24398: CALL_OW 380
24402: GO 24421
// PrepareHuman ( false , i , skill ) ;
24404: LD_INT 0
24406: PPUSH
24407: LD_VAR 0 8
24411: PPUSH
24412: LD_VAR 0 4
24416: PPUSH
24417: CALL_OW 380
// end else
24421: GO 24440
// PrepareHuman ( false , i , skill ) ;
24423: LD_INT 0
24425: PPUSH
24426: LD_VAR 0 8
24430: PPUSH
24431: LD_VAR 0 4
24435: PPUSH
24436: CALL_OW 380
// un := CreateHuman ;
24440: LD_ADDR_VAR 0 14
24444: PUSH
24445: CALL_OW 44
24449: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24450: LD_ADDR_VAR 0 7
24454: PUSH
24455: LD_VAR 0 7
24459: PPUSH
24460: LD_INT 1
24462: PPUSH
24463: LD_VAR 0 14
24467: PPUSH
24468: CALL_OW 2
24472: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24473: LD_VAR 0 14
24477: PPUSH
24478: LD_VAR 0 9
24482: PPUSH
24483: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24487: LD_VAR 0 9
24491: PPUSH
24492: CALL_OW 313
24496: PUSH
24497: LD_INT 6
24499: EQUAL
24500: PUSH
24501: LD_VAR 0 9
24505: PPUSH
24506: CALL_OW 266
24510: PUSH
24511: LD_INT 32
24513: PUSH
24514: LD_INT 31
24516: PUSH
24517: EMPTY
24518: LIST
24519: LIST
24520: IN
24521: OR
24522: IFFALSE 24336
24524: GO 24333
24526: POP
24527: POP
// end else
24528: GO 24910
// for j = 1 to x do
24530: LD_ADDR_VAR 0 9
24534: PUSH
24535: DOUBLE
24536: LD_INT 1
24538: DEC
24539: ST_TO_ADDR
24540: LD_VAR 0 13
24544: PUSH
24545: FOR_TO
24546: IFFALSE 24908
// begin InitHc ;
24548: CALL_OW 19
// if not f then
24552: LD_VAR 0 12
24556: NOT
24557: IFFALSE 24646
// begin PrepareHuman ( false , i , skill ) ;
24559: LD_INT 0
24561: PPUSH
24562: LD_VAR 0 8
24566: PPUSH
24567: LD_VAR 0 4
24571: PPUSH
24572: CALL_OW 380
// un := CreateHuman ;
24576: LD_ADDR_VAR 0 14
24580: PUSH
24581: CALL_OW 44
24585: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24586: LD_ADDR_VAR 0 7
24590: PUSH
24591: LD_VAR 0 7
24595: PPUSH
24596: LD_INT 1
24598: PPUSH
24599: LD_VAR 0 14
24603: PPUSH
24604: CALL_OW 2
24608: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24609: LD_VAR 0 14
24613: PPUSH
24614: LD_VAR 0 1
24618: PPUSH
24619: CALL_OW 250
24623: PPUSH
24624: LD_VAR 0 1
24628: PPUSH
24629: CALL_OW 251
24633: PPUSH
24634: LD_INT 10
24636: PPUSH
24637: LD_INT 0
24639: PPUSH
24640: CALL_OW 50
// continue ;
24644: GO 24545
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24646: LD_VAR 0 12
24650: PUSH
24651: LD_INT 1
24653: ARRAY
24654: PPUSH
24655: CALL_OW 313
24659: PUSH
24660: LD_VAR 0 12
24664: PUSH
24665: LD_INT 1
24667: ARRAY
24668: PPUSH
24669: CALL_OW 266
24673: PUSH
24674: LD_INT 32
24676: PUSH
24677: LD_INT 31
24679: PUSH
24680: EMPTY
24681: LIST
24682: LIST
24683: IN
24684: AND
24685: PUSH
24686: LD_VAR 0 12
24690: PUSH
24691: LD_INT 1
24693: ARRAY
24694: PPUSH
24695: CALL_OW 313
24699: PUSH
24700: LD_INT 6
24702: EQUAL
24703: OR
24704: IFFALSE 24724
// f := Delete ( f , 1 ) ;
24706: LD_ADDR_VAR 0 12
24710: PUSH
24711: LD_VAR 0 12
24715: PPUSH
24716: LD_INT 1
24718: PPUSH
24719: CALL_OW 3
24723: ST_TO_ADDR
// if not f then
24724: LD_VAR 0 12
24728: NOT
24729: IFFALSE 24747
// begin x := x + 2 ;
24731: LD_ADDR_VAR 0 13
24735: PUSH
24736: LD_VAR 0 13
24740: PUSH
24741: LD_INT 2
24743: PLUS
24744: ST_TO_ADDR
// continue ;
24745: GO 24545
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24747: LD_VAR 0 12
24751: PUSH
24752: LD_INT 1
24754: ARRAY
24755: PPUSH
24756: CALL_OW 266
24760: PUSH
24761: LD_INT 5
24763: EQUAL
24764: IFFALSE 24838
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24766: LD_VAR 0 12
24770: PUSH
24771: LD_INT 1
24773: ARRAY
24774: PPUSH
24775: CALL_OW 313
24779: PUSH
24780: LD_INT 3
24782: LESS
24783: IFFALSE 24819
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24785: LD_INT 0
24787: PPUSH
24788: LD_INT 5
24790: PUSH
24791: LD_INT 8
24793: PUSH
24794: LD_INT 9
24796: PUSH
24797: EMPTY
24798: LIST
24799: LIST
24800: LIST
24801: PUSH
24802: LD_VAR 0 17
24806: ARRAY
24807: PPUSH
24808: LD_VAR 0 4
24812: PPUSH
24813: CALL_OW 380
24817: GO 24836
// PrepareHuman ( false , i , skill ) ;
24819: LD_INT 0
24821: PPUSH
24822: LD_VAR 0 8
24826: PPUSH
24827: LD_VAR 0 4
24831: PPUSH
24832: CALL_OW 380
// end else
24836: GO 24855
// PrepareHuman ( false , i , skill ) ;
24838: LD_INT 0
24840: PPUSH
24841: LD_VAR 0 8
24845: PPUSH
24846: LD_VAR 0 4
24850: PPUSH
24851: CALL_OW 380
// un := CreateHuman ;
24855: LD_ADDR_VAR 0 14
24859: PUSH
24860: CALL_OW 44
24864: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24865: LD_ADDR_VAR 0 7
24869: PUSH
24870: LD_VAR 0 7
24874: PPUSH
24875: LD_INT 1
24877: PPUSH
24878: LD_VAR 0 14
24882: PPUSH
24883: CALL_OW 2
24887: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24888: LD_VAR 0 14
24892: PPUSH
24893: LD_VAR 0 12
24897: PUSH
24898: LD_INT 1
24900: ARRAY
24901: PPUSH
24902: CALL_OW 52
// end ;
24906: GO 24545
24908: POP
24909: POP
// end ;
24910: GO 23847
24912: POP
24913: POP
// result := result ^ buildings ;
24914: LD_ADDR_VAR 0 7
24918: PUSH
24919: LD_VAR 0 7
24923: PUSH
24924: LD_VAR 0 18
24928: ADD
24929: ST_TO_ADDR
// end else
24930: GO 25073
// begin for i = 1 to personel do
24932: LD_ADDR_VAR 0 8
24936: PUSH
24937: DOUBLE
24938: LD_INT 1
24940: DEC
24941: ST_TO_ADDR
24942: LD_VAR 0 6
24946: PUSH
24947: FOR_TO
24948: IFFALSE 25071
// begin if i > 4 then
24950: LD_VAR 0 8
24954: PUSH
24955: LD_INT 4
24957: GREATER
24958: IFFALSE 24962
// break ;
24960: GO 25071
// x := personel [ i ] ;
24962: LD_ADDR_VAR 0 13
24966: PUSH
24967: LD_VAR 0 6
24971: PUSH
24972: LD_VAR 0 8
24976: ARRAY
24977: ST_TO_ADDR
// if x = - 1 then
24978: LD_VAR 0 13
24982: PUSH
24983: LD_INT 1
24985: NEG
24986: EQUAL
24987: IFFALSE 24991
// continue ;
24989: GO 24947
// PrepareHuman ( false , i , skill ) ;
24991: LD_INT 0
24993: PPUSH
24994: LD_VAR 0 8
24998: PPUSH
24999: LD_VAR 0 4
25003: PPUSH
25004: CALL_OW 380
// un := CreateHuman ;
25008: LD_ADDR_VAR 0 14
25012: PUSH
25013: CALL_OW 44
25017: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25018: LD_VAR 0 14
25022: PPUSH
25023: LD_VAR 0 1
25027: PPUSH
25028: CALL_OW 250
25032: PPUSH
25033: LD_VAR 0 1
25037: PPUSH
25038: CALL_OW 251
25042: PPUSH
25043: LD_INT 10
25045: PPUSH
25046: LD_INT 0
25048: PPUSH
25049: CALL_OW 50
// result := result ^ un ;
25053: LD_ADDR_VAR 0 7
25057: PUSH
25058: LD_VAR 0 7
25062: PUSH
25063: LD_VAR 0 14
25067: ADD
25068: ST_TO_ADDR
// end ;
25069: GO 24947
25071: POP
25072: POP
// end ; end ;
25073: LD_VAR 0 7
25077: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25078: LD_INT 0
25080: PPUSH
25081: PPUSH
25082: PPUSH
25083: PPUSH
25084: PPUSH
25085: PPUSH
25086: PPUSH
25087: PPUSH
25088: PPUSH
25089: PPUSH
25090: PPUSH
25091: PPUSH
25092: PPUSH
25093: PPUSH
25094: PPUSH
25095: PPUSH
// result := false ;
25096: LD_ADDR_VAR 0 3
25100: PUSH
25101: LD_INT 0
25103: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25104: LD_VAR 0 1
25108: NOT
25109: PUSH
25110: LD_VAR 0 1
25114: PPUSH
25115: CALL_OW 266
25119: PUSH
25120: LD_INT 32
25122: PUSH
25123: LD_INT 33
25125: PUSH
25126: EMPTY
25127: LIST
25128: LIST
25129: IN
25130: NOT
25131: OR
25132: IFFALSE 25136
// exit ;
25134: GO 26245
// nat := GetNation ( tower ) ;
25136: LD_ADDR_VAR 0 12
25140: PUSH
25141: LD_VAR 0 1
25145: PPUSH
25146: CALL_OW 248
25150: ST_TO_ADDR
// side := GetSide ( tower ) ;
25151: LD_ADDR_VAR 0 16
25155: PUSH
25156: LD_VAR 0 1
25160: PPUSH
25161: CALL_OW 255
25165: ST_TO_ADDR
// x := GetX ( tower ) ;
25166: LD_ADDR_VAR 0 10
25170: PUSH
25171: LD_VAR 0 1
25175: PPUSH
25176: CALL_OW 250
25180: ST_TO_ADDR
// y := GetY ( tower ) ;
25181: LD_ADDR_VAR 0 11
25185: PUSH
25186: LD_VAR 0 1
25190: PPUSH
25191: CALL_OW 251
25195: ST_TO_ADDR
// if not x or not y then
25196: LD_VAR 0 10
25200: NOT
25201: PUSH
25202: LD_VAR 0 11
25206: NOT
25207: OR
25208: IFFALSE 25212
// exit ;
25210: GO 26245
// weapon := 0 ;
25212: LD_ADDR_VAR 0 18
25216: PUSH
25217: LD_INT 0
25219: ST_TO_ADDR
// fac_list := [ ] ;
25220: LD_ADDR_VAR 0 17
25224: PUSH
25225: EMPTY
25226: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25227: LD_ADDR_VAR 0 6
25231: PUSH
25232: LD_VAR 0 1
25236: PPUSH
25237: CALL_OW 274
25241: PPUSH
25242: LD_VAR 0 2
25246: PPUSH
25247: LD_INT 0
25249: PPUSH
25250: CALL 22816 0 3
25254: PPUSH
25255: LD_INT 30
25257: PUSH
25258: LD_INT 3
25260: PUSH
25261: EMPTY
25262: LIST
25263: LIST
25264: PPUSH
25265: CALL_OW 72
25269: ST_TO_ADDR
// if not factories then
25270: LD_VAR 0 6
25274: NOT
25275: IFFALSE 25279
// exit ;
25277: GO 26245
// for i in factories do
25279: LD_ADDR_VAR 0 8
25283: PUSH
25284: LD_VAR 0 6
25288: PUSH
25289: FOR_IN
25290: IFFALSE 25315
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25292: LD_ADDR_VAR 0 17
25296: PUSH
25297: LD_VAR 0 17
25301: PUSH
25302: LD_VAR 0 8
25306: PPUSH
25307: CALL_OW 478
25311: UNION
25312: ST_TO_ADDR
25313: GO 25289
25315: POP
25316: POP
// if not fac_list then
25317: LD_VAR 0 17
25321: NOT
25322: IFFALSE 25326
// exit ;
25324: GO 26245
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25326: LD_ADDR_VAR 0 5
25330: PUSH
25331: LD_INT 4
25333: PUSH
25334: LD_INT 5
25336: PUSH
25337: LD_INT 9
25339: PUSH
25340: LD_INT 10
25342: PUSH
25343: LD_INT 6
25345: PUSH
25346: LD_INT 7
25348: PUSH
25349: LD_INT 11
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: LIST
25357: LIST
25358: LIST
25359: LIST
25360: PUSH
25361: LD_INT 27
25363: PUSH
25364: LD_INT 28
25366: PUSH
25367: LD_INT 26
25369: PUSH
25370: LD_INT 30
25372: PUSH
25373: EMPTY
25374: LIST
25375: LIST
25376: LIST
25377: LIST
25378: PUSH
25379: LD_INT 43
25381: PUSH
25382: LD_INT 44
25384: PUSH
25385: LD_INT 46
25387: PUSH
25388: LD_INT 45
25390: PUSH
25391: LD_INT 47
25393: PUSH
25394: LD_INT 49
25396: PUSH
25397: EMPTY
25398: LIST
25399: LIST
25400: LIST
25401: LIST
25402: LIST
25403: LIST
25404: PUSH
25405: EMPTY
25406: LIST
25407: LIST
25408: LIST
25409: PUSH
25410: LD_VAR 0 12
25414: ARRAY
25415: ST_TO_ADDR
// list := list isect fac_list ;
25416: LD_ADDR_VAR 0 5
25420: PUSH
25421: LD_VAR 0 5
25425: PUSH
25426: LD_VAR 0 17
25430: ISECT
25431: ST_TO_ADDR
// if not list then
25432: LD_VAR 0 5
25436: NOT
25437: IFFALSE 25441
// exit ;
25439: GO 26245
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25441: LD_VAR 0 12
25445: PUSH
25446: LD_INT 3
25448: EQUAL
25449: PUSH
25450: LD_INT 49
25452: PUSH
25453: LD_VAR 0 5
25457: IN
25458: AND
25459: PUSH
25460: LD_INT 31
25462: PPUSH
25463: LD_VAR 0 16
25467: PPUSH
25468: CALL_OW 321
25472: PUSH
25473: LD_INT 2
25475: EQUAL
25476: AND
25477: IFFALSE 25537
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25479: LD_INT 22
25481: PUSH
25482: LD_VAR 0 16
25486: PUSH
25487: EMPTY
25488: LIST
25489: LIST
25490: PUSH
25491: LD_INT 35
25493: PUSH
25494: LD_INT 49
25496: PUSH
25497: EMPTY
25498: LIST
25499: LIST
25500: PUSH
25501: LD_INT 91
25503: PUSH
25504: LD_VAR 0 1
25508: PUSH
25509: LD_INT 10
25511: PUSH
25512: EMPTY
25513: LIST
25514: LIST
25515: LIST
25516: PUSH
25517: EMPTY
25518: LIST
25519: LIST
25520: LIST
25521: PPUSH
25522: CALL_OW 69
25526: NOT
25527: IFFALSE 25537
// weapon := ru_time_lapser ;
25529: LD_ADDR_VAR 0 18
25533: PUSH
25534: LD_INT 49
25536: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25537: LD_VAR 0 12
25541: PUSH
25542: LD_INT 1
25544: PUSH
25545: LD_INT 2
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: IN
25552: PUSH
25553: LD_INT 11
25555: PUSH
25556: LD_VAR 0 5
25560: IN
25561: PUSH
25562: LD_INT 30
25564: PUSH
25565: LD_VAR 0 5
25569: IN
25570: OR
25571: AND
25572: PUSH
25573: LD_INT 6
25575: PPUSH
25576: LD_VAR 0 16
25580: PPUSH
25581: CALL_OW 321
25585: PUSH
25586: LD_INT 2
25588: EQUAL
25589: AND
25590: IFFALSE 25755
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25592: LD_INT 22
25594: PUSH
25595: LD_VAR 0 16
25599: PUSH
25600: EMPTY
25601: LIST
25602: LIST
25603: PUSH
25604: LD_INT 2
25606: PUSH
25607: LD_INT 35
25609: PUSH
25610: LD_INT 11
25612: PUSH
25613: EMPTY
25614: LIST
25615: LIST
25616: PUSH
25617: LD_INT 35
25619: PUSH
25620: LD_INT 30
25622: PUSH
25623: EMPTY
25624: LIST
25625: LIST
25626: PUSH
25627: EMPTY
25628: LIST
25629: LIST
25630: LIST
25631: PUSH
25632: LD_INT 91
25634: PUSH
25635: LD_VAR 0 1
25639: PUSH
25640: LD_INT 18
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: LIST
25647: PUSH
25648: EMPTY
25649: LIST
25650: LIST
25651: LIST
25652: PPUSH
25653: CALL_OW 69
25657: NOT
25658: PUSH
25659: LD_INT 22
25661: PUSH
25662: LD_VAR 0 16
25666: PUSH
25667: EMPTY
25668: LIST
25669: LIST
25670: PUSH
25671: LD_INT 2
25673: PUSH
25674: LD_INT 30
25676: PUSH
25677: LD_INT 32
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_INT 30
25686: PUSH
25687: LD_INT 33
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: PUSH
25694: EMPTY
25695: LIST
25696: LIST
25697: LIST
25698: PUSH
25699: LD_INT 91
25701: PUSH
25702: LD_VAR 0 1
25706: PUSH
25707: LD_INT 12
25709: PUSH
25710: EMPTY
25711: LIST
25712: LIST
25713: LIST
25714: PUSH
25715: EMPTY
25716: LIST
25717: LIST
25718: LIST
25719: PUSH
25720: EMPTY
25721: LIST
25722: PPUSH
25723: CALL_OW 69
25727: PUSH
25728: LD_INT 2
25730: GREATER
25731: AND
25732: IFFALSE 25755
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25734: LD_ADDR_VAR 0 18
25738: PUSH
25739: LD_INT 11
25741: PUSH
25742: LD_INT 30
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: PUSH
25749: LD_VAR 0 12
25753: ARRAY
25754: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25755: LD_VAR 0 18
25759: NOT
25760: PUSH
25761: LD_INT 40
25763: PPUSH
25764: LD_VAR 0 16
25768: PPUSH
25769: CALL_OW 321
25773: PUSH
25774: LD_INT 2
25776: EQUAL
25777: AND
25778: PUSH
25779: LD_INT 7
25781: PUSH
25782: LD_VAR 0 5
25786: IN
25787: PUSH
25788: LD_INT 28
25790: PUSH
25791: LD_VAR 0 5
25795: IN
25796: OR
25797: PUSH
25798: LD_INT 45
25800: PUSH
25801: LD_VAR 0 5
25805: IN
25806: OR
25807: AND
25808: IFFALSE 26062
// begin hex := GetHexInfo ( x , y ) ;
25810: LD_ADDR_VAR 0 4
25814: PUSH
25815: LD_VAR 0 10
25819: PPUSH
25820: LD_VAR 0 11
25824: PPUSH
25825: CALL_OW 546
25829: ST_TO_ADDR
// if hex [ 1 ] then
25830: LD_VAR 0 4
25834: PUSH
25835: LD_INT 1
25837: ARRAY
25838: IFFALSE 25842
// exit ;
25840: GO 26245
// height := hex [ 2 ] ;
25842: LD_ADDR_VAR 0 15
25846: PUSH
25847: LD_VAR 0 4
25851: PUSH
25852: LD_INT 2
25854: ARRAY
25855: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25856: LD_ADDR_VAR 0 14
25860: PUSH
25861: LD_INT 0
25863: PUSH
25864: LD_INT 2
25866: PUSH
25867: LD_INT 3
25869: PUSH
25870: LD_INT 5
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: LIST
25877: LIST
25878: ST_TO_ADDR
// for i in tmp do
25879: LD_ADDR_VAR 0 8
25883: PUSH
25884: LD_VAR 0 14
25888: PUSH
25889: FOR_IN
25890: IFFALSE 26060
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25892: LD_ADDR_VAR 0 9
25896: PUSH
25897: LD_VAR 0 10
25901: PPUSH
25902: LD_VAR 0 8
25906: PPUSH
25907: LD_INT 5
25909: PPUSH
25910: CALL_OW 272
25914: PUSH
25915: LD_VAR 0 11
25919: PPUSH
25920: LD_VAR 0 8
25924: PPUSH
25925: LD_INT 5
25927: PPUSH
25928: CALL_OW 273
25932: PUSH
25933: EMPTY
25934: LIST
25935: LIST
25936: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25937: LD_VAR 0 9
25941: PUSH
25942: LD_INT 1
25944: ARRAY
25945: PPUSH
25946: LD_VAR 0 9
25950: PUSH
25951: LD_INT 2
25953: ARRAY
25954: PPUSH
25955: CALL_OW 488
25959: IFFALSE 26058
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25961: LD_ADDR_VAR 0 4
25965: PUSH
25966: LD_VAR 0 9
25970: PUSH
25971: LD_INT 1
25973: ARRAY
25974: PPUSH
25975: LD_VAR 0 9
25979: PUSH
25980: LD_INT 2
25982: ARRAY
25983: PPUSH
25984: CALL_OW 546
25988: ST_TO_ADDR
// if hex [ 1 ] then
25989: LD_VAR 0 4
25993: PUSH
25994: LD_INT 1
25996: ARRAY
25997: IFFALSE 26001
// continue ;
25999: GO 25889
// h := hex [ 2 ] ;
26001: LD_ADDR_VAR 0 13
26005: PUSH
26006: LD_VAR 0 4
26010: PUSH
26011: LD_INT 2
26013: ARRAY
26014: ST_TO_ADDR
// if h + 7 < height then
26015: LD_VAR 0 13
26019: PUSH
26020: LD_INT 7
26022: PLUS
26023: PUSH
26024: LD_VAR 0 15
26028: LESS
26029: IFFALSE 26058
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26031: LD_ADDR_VAR 0 18
26035: PUSH
26036: LD_INT 7
26038: PUSH
26039: LD_INT 28
26041: PUSH
26042: LD_INT 45
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: LIST
26049: PUSH
26050: LD_VAR 0 12
26054: ARRAY
26055: ST_TO_ADDR
// break ;
26056: GO 26060
// end ; end ; end ;
26058: GO 25889
26060: POP
26061: POP
// end ; if not weapon then
26062: LD_VAR 0 18
26066: NOT
26067: IFFALSE 26127
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26069: LD_ADDR_VAR 0 5
26073: PUSH
26074: LD_VAR 0 5
26078: PUSH
26079: LD_INT 11
26081: PUSH
26082: LD_INT 30
26084: PUSH
26085: LD_INT 49
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: LIST
26092: DIFF
26093: ST_TO_ADDR
// if not list then
26094: LD_VAR 0 5
26098: NOT
26099: IFFALSE 26103
// exit ;
26101: GO 26245
// weapon := list [ rand ( 1 , list ) ] ;
26103: LD_ADDR_VAR 0 18
26107: PUSH
26108: LD_VAR 0 5
26112: PUSH
26113: LD_INT 1
26115: PPUSH
26116: LD_VAR 0 5
26120: PPUSH
26121: CALL_OW 12
26125: ARRAY
26126: ST_TO_ADDR
// end ; if weapon then
26127: LD_VAR 0 18
26131: IFFALSE 26245
// begin tmp := CostOfWeapon ( weapon ) ;
26133: LD_ADDR_VAR 0 14
26137: PUSH
26138: LD_VAR 0 18
26142: PPUSH
26143: CALL_OW 451
26147: ST_TO_ADDR
// j := GetBase ( tower ) ;
26148: LD_ADDR_VAR 0 9
26152: PUSH
26153: LD_VAR 0 1
26157: PPUSH
26158: CALL_OW 274
26162: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26163: LD_VAR 0 9
26167: PPUSH
26168: LD_INT 1
26170: PPUSH
26171: CALL_OW 275
26175: PUSH
26176: LD_VAR 0 14
26180: PUSH
26181: LD_INT 1
26183: ARRAY
26184: GREATEREQUAL
26185: PUSH
26186: LD_VAR 0 9
26190: PPUSH
26191: LD_INT 2
26193: PPUSH
26194: CALL_OW 275
26198: PUSH
26199: LD_VAR 0 14
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: GREATEREQUAL
26208: AND
26209: PUSH
26210: LD_VAR 0 9
26214: PPUSH
26215: LD_INT 3
26217: PPUSH
26218: CALL_OW 275
26222: PUSH
26223: LD_VAR 0 14
26227: PUSH
26228: LD_INT 3
26230: ARRAY
26231: GREATEREQUAL
26232: AND
26233: IFFALSE 26245
// result := weapon ;
26235: LD_ADDR_VAR 0 3
26239: PUSH
26240: LD_VAR 0 18
26244: ST_TO_ADDR
// end ; end ;
26245: LD_VAR 0 3
26249: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26250: LD_INT 0
26252: PPUSH
26253: PPUSH
// result := true ;
26254: LD_ADDR_VAR 0 3
26258: PUSH
26259: LD_INT 1
26261: ST_TO_ADDR
// if array1 = array2 then
26262: LD_VAR 0 1
26266: PUSH
26267: LD_VAR 0 2
26271: EQUAL
26272: IFFALSE 26332
// begin for i = 1 to array1 do
26274: LD_ADDR_VAR 0 4
26278: PUSH
26279: DOUBLE
26280: LD_INT 1
26282: DEC
26283: ST_TO_ADDR
26284: LD_VAR 0 1
26288: PUSH
26289: FOR_TO
26290: IFFALSE 26328
// if array1 [ i ] <> array2 [ i ] then
26292: LD_VAR 0 1
26296: PUSH
26297: LD_VAR 0 4
26301: ARRAY
26302: PUSH
26303: LD_VAR 0 2
26307: PUSH
26308: LD_VAR 0 4
26312: ARRAY
26313: NONEQUAL
26314: IFFALSE 26326
// begin result := false ;
26316: LD_ADDR_VAR 0 3
26320: PUSH
26321: LD_INT 0
26323: ST_TO_ADDR
// break ;
26324: GO 26328
// end ;
26326: GO 26289
26328: POP
26329: POP
// end else
26330: GO 26340
// result := false ;
26332: LD_ADDR_VAR 0 3
26336: PUSH
26337: LD_INT 0
26339: ST_TO_ADDR
// end ;
26340: LD_VAR 0 3
26344: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26345: LD_INT 0
26347: PPUSH
26348: PPUSH
// if not array1 or not array2 then
26349: LD_VAR 0 1
26353: NOT
26354: PUSH
26355: LD_VAR 0 2
26359: NOT
26360: OR
26361: IFFALSE 26365
// exit ;
26363: GO 26429
// result := true ;
26365: LD_ADDR_VAR 0 3
26369: PUSH
26370: LD_INT 1
26372: ST_TO_ADDR
// for i = 1 to array1 do
26373: LD_ADDR_VAR 0 4
26377: PUSH
26378: DOUBLE
26379: LD_INT 1
26381: DEC
26382: ST_TO_ADDR
26383: LD_VAR 0 1
26387: PUSH
26388: FOR_TO
26389: IFFALSE 26427
// if array1 [ i ] <> array2 [ i ] then
26391: LD_VAR 0 1
26395: PUSH
26396: LD_VAR 0 4
26400: ARRAY
26401: PUSH
26402: LD_VAR 0 2
26406: PUSH
26407: LD_VAR 0 4
26411: ARRAY
26412: NONEQUAL
26413: IFFALSE 26425
// begin result := false ;
26415: LD_ADDR_VAR 0 3
26419: PUSH
26420: LD_INT 0
26422: ST_TO_ADDR
// break ;
26423: GO 26427
// end ;
26425: GO 26388
26427: POP
26428: POP
// end ;
26429: LD_VAR 0 3
26433: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26434: LD_INT 0
26436: PPUSH
26437: PPUSH
26438: PPUSH
// pom := GetBase ( fac ) ;
26439: LD_ADDR_VAR 0 5
26443: PUSH
26444: LD_VAR 0 1
26448: PPUSH
26449: CALL_OW 274
26453: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26454: LD_ADDR_VAR 0 4
26458: PUSH
26459: LD_VAR 0 2
26463: PUSH
26464: LD_INT 1
26466: ARRAY
26467: PPUSH
26468: LD_VAR 0 2
26472: PUSH
26473: LD_INT 2
26475: ARRAY
26476: PPUSH
26477: LD_VAR 0 2
26481: PUSH
26482: LD_INT 3
26484: ARRAY
26485: PPUSH
26486: LD_VAR 0 2
26490: PUSH
26491: LD_INT 4
26493: ARRAY
26494: PPUSH
26495: CALL_OW 449
26499: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26500: LD_ADDR_VAR 0 3
26504: PUSH
26505: LD_VAR 0 5
26509: PPUSH
26510: LD_INT 1
26512: PPUSH
26513: CALL_OW 275
26517: PUSH
26518: LD_VAR 0 4
26522: PUSH
26523: LD_INT 1
26525: ARRAY
26526: GREATEREQUAL
26527: PUSH
26528: LD_VAR 0 5
26532: PPUSH
26533: LD_INT 2
26535: PPUSH
26536: CALL_OW 275
26540: PUSH
26541: LD_VAR 0 4
26545: PUSH
26546: LD_INT 2
26548: ARRAY
26549: GREATEREQUAL
26550: AND
26551: PUSH
26552: LD_VAR 0 5
26556: PPUSH
26557: LD_INT 3
26559: PPUSH
26560: CALL_OW 275
26564: PUSH
26565: LD_VAR 0 4
26569: PUSH
26570: LD_INT 3
26572: ARRAY
26573: GREATEREQUAL
26574: AND
26575: ST_TO_ADDR
// end ;
26576: LD_VAR 0 3
26580: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26581: LD_INT 0
26583: PPUSH
26584: PPUSH
26585: PPUSH
26586: PPUSH
// pom := GetBase ( building ) ;
26587: LD_ADDR_VAR 0 3
26591: PUSH
26592: LD_VAR 0 1
26596: PPUSH
26597: CALL_OW 274
26601: ST_TO_ADDR
// if not pom then
26602: LD_VAR 0 3
26606: NOT
26607: IFFALSE 26611
// exit ;
26609: GO 26781
// btype := GetBType ( building ) ;
26611: LD_ADDR_VAR 0 5
26615: PUSH
26616: LD_VAR 0 1
26620: PPUSH
26621: CALL_OW 266
26625: ST_TO_ADDR
// if btype = b_armoury then
26626: LD_VAR 0 5
26630: PUSH
26631: LD_INT 4
26633: EQUAL
26634: IFFALSE 26644
// btype := b_barracks ;
26636: LD_ADDR_VAR 0 5
26640: PUSH
26641: LD_INT 5
26643: ST_TO_ADDR
// if btype = b_depot then
26644: LD_VAR 0 5
26648: PUSH
26649: LD_INT 0
26651: EQUAL
26652: IFFALSE 26662
// btype := b_warehouse ;
26654: LD_ADDR_VAR 0 5
26658: PUSH
26659: LD_INT 1
26661: ST_TO_ADDR
// if btype = b_workshop then
26662: LD_VAR 0 5
26666: PUSH
26667: LD_INT 2
26669: EQUAL
26670: IFFALSE 26680
// btype := b_factory ;
26672: LD_ADDR_VAR 0 5
26676: PUSH
26677: LD_INT 3
26679: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26680: LD_ADDR_VAR 0 4
26684: PUSH
26685: LD_VAR 0 5
26689: PPUSH
26690: LD_VAR 0 1
26694: PPUSH
26695: CALL_OW 248
26699: PPUSH
26700: CALL_OW 450
26704: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26705: LD_ADDR_VAR 0 2
26709: PUSH
26710: LD_VAR 0 3
26714: PPUSH
26715: LD_INT 1
26717: PPUSH
26718: CALL_OW 275
26722: PUSH
26723: LD_VAR 0 4
26727: PUSH
26728: LD_INT 1
26730: ARRAY
26731: GREATEREQUAL
26732: PUSH
26733: LD_VAR 0 3
26737: PPUSH
26738: LD_INT 2
26740: PPUSH
26741: CALL_OW 275
26745: PUSH
26746: LD_VAR 0 4
26750: PUSH
26751: LD_INT 2
26753: ARRAY
26754: GREATEREQUAL
26755: AND
26756: PUSH
26757: LD_VAR 0 3
26761: PPUSH
26762: LD_INT 3
26764: PPUSH
26765: CALL_OW 275
26769: PUSH
26770: LD_VAR 0 4
26774: PUSH
26775: LD_INT 3
26777: ARRAY
26778: GREATEREQUAL
26779: AND
26780: ST_TO_ADDR
// end ;
26781: LD_VAR 0 2
26785: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26786: LD_INT 0
26788: PPUSH
26789: PPUSH
26790: PPUSH
// pom := GetBase ( building ) ;
26791: LD_ADDR_VAR 0 4
26795: PUSH
26796: LD_VAR 0 1
26800: PPUSH
26801: CALL_OW 274
26805: ST_TO_ADDR
// if not pom then
26806: LD_VAR 0 4
26810: NOT
26811: IFFALSE 26815
// exit ;
26813: GO 26916
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26815: LD_ADDR_VAR 0 5
26819: PUSH
26820: LD_VAR 0 2
26824: PPUSH
26825: LD_VAR 0 1
26829: PPUSH
26830: CALL_OW 248
26834: PPUSH
26835: CALL_OW 450
26839: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26840: LD_ADDR_VAR 0 3
26844: PUSH
26845: LD_VAR 0 4
26849: PPUSH
26850: LD_INT 1
26852: PPUSH
26853: CALL_OW 275
26857: PUSH
26858: LD_VAR 0 5
26862: PUSH
26863: LD_INT 1
26865: ARRAY
26866: GREATEREQUAL
26867: PUSH
26868: LD_VAR 0 4
26872: PPUSH
26873: LD_INT 2
26875: PPUSH
26876: CALL_OW 275
26880: PUSH
26881: LD_VAR 0 5
26885: PUSH
26886: LD_INT 2
26888: ARRAY
26889: GREATEREQUAL
26890: AND
26891: PUSH
26892: LD_VAR 0 4
26896: PPUSH
26897: LD_INT 3
26899: PPUSH
26900: CALL_OW 275
26904: PUSH
26905: LD_VAR 0 5
26909: PUSH
26910: LD_INT 3
26912: ARRAY
26913: GREATEREQUAL
26914: AND
26915: ST_TO_ADDR
// end ;
26916: LD_VAR 0 3
26920: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26921: LD_INT 0
26923: PPUSH
26924: PPUSH
26925: PPUSH
26926: PPUSH
26927: PPUSH
26928: PPUSH
26929: PPUSH
26930: PPUSH
26931: PPUSH
26932: PPUSH
26933: PPUSH
// result := false ;
26934: LD_ADDR_VAR 0 8
26938: PUSH
26939: LD_INT 0
26941: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26942: LD_VAR 0 5
26946: NOT
26947: PUSH
26948: LD_VAR 0 1
26952: NOT
26953: OR
26954: PUSH
26955: LD_VAR 0 2
26959: NOT
26960: OR
26961: PUSH
26962: LD_VAR 0 3
26966: NOT
26967: OR
26968: IFFALSE 26972
// exit ;
26970: GO 27786
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26972: LD_ADDR_VAR 0 14
26976: PUSH
26977: LD_VAR 0 1
26981: PPUSH
26982: LD_VAR 0 2
26986: PPUSH
26987: LD_VAR 0 3
26991: PPUSH
26992: LD_VAR 0 4
26996: PPUSH
26997: LD_VAR 0 5
27001: PUSH
27002: LD_INT 1
27004: ARRAY
27005: PPUSH
27006: CALL_OW 248
27010: PPUSH
27011: LD_INT 0
27013: PPUSH
27014: CALL 29019 0 6
27018: ST_TO_ADDR
// if not hexes then
27019: LD_VAR 0 14
27023: NOT
27024: IFFALSE 27028
// exit ;
27026: GO 27786
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27028: LD_ADDR_VAR 0 17
27032: PUSH
27033: LD_VAR 0 5
27037: PPUSH
27038: LD_INT 22
27040: PUSH
27041: LD_VAR 0 13
27045: PPUSH
27046: CALL_OW 255
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 2
27057: PUSH
27058: LD_INT 30
27060: PUSH
27061: LD_INT 0
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: PUSH
27068: LD_INT 30
27070: PUSH
27071: LD_INT 1
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: EMPTY
27079: LIST
27080: LIST
27081: LIST
27082: PUSH
27083: EMPTY
27084: LIST
27085: LIST
27086: PPUSH
27087: CALL_OW 72
27091: ST_TO_ADDR
// for i = 1 to hexes do
27092: LD_ADDR_VAR 0 9
27096: PUSH
27097: DOUBLE
27098: LD_INT 1
27100: DEC
27101: ST_TO_ADDR
27102: LD_VAR 0 14
27106: PUSH
27107: FOR_TO
27108: IFFALSE 27784
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27110: LD_ADDR_VAR 0 13
27114: PUSH
27115: LD_VAR 0 14
27119: PUSH
27120: LD_VAR 0 9
27124: ARRAY
27125: PUSH
27126: LD_INT 1
27128: ARRAY
27129: PPUSH
27130: LD_VAR 0 14
27134: PUSH
27135: LD_VAR 0 9
27139: ARRAY
27140: PUSH
27141: LD_INT 2
27143: ARRAY
27144: PPUSH
27145: CALL_OW 428
27149: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27150: LD_VAR 0 14
27154: PUSH
27155: LD_VAR 0 9
27159: ARRAY
27160: PUSH
27161: LD_INT 1
27163: ARRAY
27164: PPUSH
27165: LD_VAR 0 14
27169: PUSH
27170: LD_VAR 0 9
27174: ARRAY
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 351
27184: PUSH
27185: LD_VAR 0 14
27189: PUSH
27190: LD_VAR 0 9
27194: ARRAY
27195: PUSH
27196: LD_INT 1
27198: ARRAY
27199: PPUSH
27200: LD_VAR 0 14
27204: PUSH
27205: LD_VAR 0 9
27209: ARRAY
27210: PUSH
27211: LD_INT 2
27213: ARRAY
27214: PPUSH
27215: CALL_OW 488
27219: NOT
27220: OR
27221: PUSH
27222: LD_VAR 0 13
27226: PPUSH
27227: CALL_OW 247
27231: PUSH
27232: LD_INT 3
27234: EQUAL
27235: OR
27236: IFFALSE 27242
// exit ;
27238: POP
27239: POP
27240: GO 27786
// if not tmp then
27242: LD_VAR 0 13
27246: NOT
27247: IFFALSE 27251
// continue ;
27249: GO 27107
// result := true ;
27251: LD_ADDR_VAR 0 8
27255: PUSH
27256: LD_INT 1
27258: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27259: LD_VAR 0 6
27263: PUSH
27264: LD_VAR 0 13
27268: PPUSH
27269: CALL_OW 247
27273: PUSH
27274: LD_INT 2
27276: EQUAL
27277: AND
27278: PUSH
27279: LD_VAR 0 13
27283: PPUSH
27284: CALL_OW 263
27288: PUSH
27289: LD_INT 1
27291: EQUAL
27292: AND
27293: IFFALSE 27457
// begin if IsDrivenBy ( tmp ) then
27295: LD_VAR 0 13
27299: PPUSH
27300: CALL_OW 311
27304: IFFALSE 27308
// continue ;
27306: GO 27107
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27308: LD_VAR 0 6
27312: PPUSH
27313: LD_INT 3
27315: PUSH
27316: LD_INT 60
27318: PUSH
27319: EMPTY
27320: LIST
27321: PUSH
27322: EMPTY
27323: LIST
27324: LIST
27325: PUSH
27326: LD_INT 3
27328: PUSH
27329: LD_INT 55
27331: PUSH
27332: EMPTY
27333: LIST
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: EMPTY
27340: LIST
27341: LIST
27342: PPUSH
27343: CALL_OW 72
27347: IFFALSE 27455
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27349: LD_ADDR_VAR 0 18
27353: PUSH
27354: LD_VAR 0 6
27358: PPUSH
27359: LD_INT 3
27361: PUSH
27362: LD_INT 60
27364: PUSH
27365: EMPTY
27366: LIST
27367: PUSH
27368: EMPTY
27369: LIST
27370: LIST
27371: PUSH
27372: LD_INT 3
27374: PUSH
27375: LD_INT 55
27377: PUSH
27378: EMPTY
27379: LIST
27380: PUSH
27381: EMPTY
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: PPUSH
27389: CALL_OW 72
27393: PUSH
27394: LD_INT 1
27396: ARRAY
27397: ST_TO_ADDR
// if IsInUnit ( driver ) then
27398: LD_VAR 0 18
27402: PPUSH
27403: CALL_OW 310
27407: IFFALSE 27418
// ComExit ( driver ) ;
27409: LD_VAR 0 18
27413: PPUSH
27414: CALL 52780 0 1
// AddComEnterUnit ( driver , tmp ) ;
27418: LD_VAR 0 18
27422: PPUSH
27423: LD_VAR 0 13
27427: PPUSH
27428: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27432: LD_VAR 0 18
27436: PPUSH
27437: LD_VAR 0 7
27441: PPUSH
27442: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27446: LD_VAR 0 18
27450: PPUSH
27451: CALL_OW 181
// end ; continue ;
27455: GO 27107
// end ; if not cleaners or not tmp in cleaners then
27457: LD_VAR 0 6
27461: NOT
27462: PUSH
27463: LD_VAR 0 13
27467: PUSH
27468: LD_VAR 0 6
27472: IN
27473: NOT
27474: OR
27475: IFFALSE 27782
// begin if dep then
27477: LD_VAR 0 17
27481: IFFALSE 27617
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27483: LD_ADDR_VAR 0 16
27487: PUSH
27488: LD_VAR 0 17
27492: PUSH
27493: LD_INT 1
27495: ARRAY
27496: PPUSH
27497: CALL_OW 250
27501: PPUSH
27502: LD_VAR 0 17
27506: PUSH
27507: LD_INT 1
27509: ARRAY
27510: PPUSH
27511: CALL_OW 254
27515: PPUSH
27516: LD_INT 5
27518: PPUSH
27519: CALL_OW 272
27523: PUSH
27524: LD_VAR 0 17
27528: PUSH
27529: LD_INT 1
27531: ARRAY
27532: PPUSH
27533: CALL_OW 251
27537: PPUSH
27538: LD_VAR 0 17
27542: PUSH
27543: LD_INT 1
27545: ARRAY
27546: PPUSH
27547: CALL_OW 254
27551: PPUSH
27552: LD_INT 5
27554: PPUSH
27555: CALL_OW 273
27559: PUSH
27560: EMPTY
27561: LIST
27562: LIST
27563: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27564: LD_VAR 0 16
27568: PUSH
27569: LD_INT 1
27571: ARRAY
27572: PPUSH
27573: LD_VAR 0 16
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: PPUSH
27582: CALL_OW 488
27586: IFFALSE 27617
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27588: LD_VAR 0 13
27592: PPUSH
27593: LD_VAR 0 16
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 16
27606: PUSH
27607: LD_INT 2
27609: ARRAY
27610: PPUSH
27611: CALL_OW 111
// continue ;
27615: GO 27107
// end ; end ; r := GetDir ( tmp ) ;
27617: LD_ADDR_VAR 0 15
27621: PUSH
27622: LD_VAR 0 13
27626: PPUSH
27627: CALL_OW 254
27631: ST_TO_ADDR
// if r = 5 then
27632: LD_VAR 0 15
27636: PUSH
27637: LD_INT 5
27639: EQUAL
27640: IFFALSE 27650
// r := 0 ;
27642: LD_ADDR_VAR 0 15
27646: PUSH
27647: LD_INT 0
27649: ST_TO_ADDR
// for j = r to 5 do
27650: LD_ADDR_VAR 0 10
27654: PUSH
27655: DOUBLE
27656: LD_VAR 0 15
27660: DEC
27661: ST_TO_ADDR
27662: LD_INT 5
27664: PUSH
27665: FOR_TO
27666: IFFALSE 27780
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27668: LD_ADDR_VAR 0 11
27672: PUSH
27673: LD_VAR 0 13
27677: PPUSH
27678: CALL_OW 250
27682: PPUSH
27683: LD_VAR 0 10
27687: PPUSH
27688: LD_INT 2
27690: PPUSH
27691: CALL_OW 272
27695: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27696: LD_ADDR_VAR 0 12
27700: PUSH
27701: LD_VAR 0 13
27705: PPUSH
27706: CALL_OW 251
27710: PPUSH
27711: LD_VAR 0 10
27715: PPUSH
27716: LD_INT 2
27718: PPUSH
27719: CALL_OW 273
27723: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27724: LD_VAR 0 11
27728: PPUSH
27729: LD_VAR 0 12
27733: PPUSH
27734: CALL_OW 488
27738: PUSH
27739: LD_VAR 0 11
27743: PPUSH
27744: LD_VAR 0 12
27748: PPUSH
27749: CALL_OW 428
27753: NOT
27754: AND
27755: IFFALSE 27778
// begin ComMoveXY ( tmp , _x , _y ) ;
27757: LD_VAR 0 13
27761: PPUSH
27762: LD_VAR 0 11
27766: PPUSH
27767: LD_VAR 0 12
27771: PPUSH
27772: CALL_OW 111
// break ;
27776: GO 27780
// end ; end ;
27778: GO 27665
27780: POP
27781: POP
// end ; end ;
27782: GO 27107
27784: POP
27785: POP
// end ;
27786: LD_VAR 0 8
27790: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27791: LD_INT 0
27793: PPUSH
// result := true ;
27794: LD_ADDR_VAR 0 3
27798: PUSH
27799: LD_INT 1
27801: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27802: LD_VAR 0 2
27806: PUSH
27807: LD_INT 24
27809: DOUBLE
27810: EQUAL
27811: IFTRUE 27821
27813: LD_INT 33
27815: DOUBLE
27816: EQUAL
27817: IFTRUE 27821
27819: GO 27846
27821: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27822: LD_ADDR_VAR 0 3
27826: PUSH
27827: LD_INT 32
27829: PPUSH
27830: LD_VAR 0 1
27834: PPUSH
27835: CALL_OW 321
27839: PUSH
27840: LD_INT 2
27842: EQUAL
27843: ST_TO_ADDR
27844: GO 28162
27846: LD_INT 20
27848: DOUBLE
27849: EQUAL
27850: IFTRUE 27854
27852: GO 27879
27854: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27855: LD_ADDR_VAR 0 3
27859: PUSH
27860: LD_INT 6
27862: PPUSH
27863: LD_VAR 0 1
27867: PPUSH
27868: CALL_OW 321
27872: PUSH
27873: LD_INT 2
27875: EQUAL
27876: ST_TO_ADDR
27877: GO 28162
27879: LD_INT 22
27881: DOUBLE
27882: EQUAL
27883: IFTRUE 27893
27885: LD_INT 36
27887: DOUBLE
27888: EQUAL
27889: IFTRUE 27893
27891: GO 27918
27893: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27894: LD_ADDR_VAR 0 3
27898: PUSH
27899: LD_INT 15
27901: PPUSH
27902: LD_VAR 0 1
27906: PPUSH
27907: CALL_OW 321
27911: PUSH
27912: LD_INT 2
27914: EQUAL
27915: ST_TO_ADDR
27916: GO 28162
27918: LD_INT 30
27920: DOUBLE
27921: EQUAL
27922: IFTRUE 27926
27924: GO 27951
27926: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27927: LD_ADDR_VAR 0 3
27931: PUSH
27932: LD_INT 20
27934: PPUSH
27935: LD_VAR 0 1
27939: PPUSH
27940: CALL_OW 321
27944: PUSH
27945: LD_INT 2
27947: EQUAL
27948: ST_TO_ADDR
27949: GO 28162
27951: LD_INT 28
27953: DOUBLE
27954: EQUAL
27955: IFTRUE 27965
27957: LD_INT 21
27959: DOUBLE
27960: EQUAL
27961: IFTRUE 27965
27963: GO 27990
27965: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27966: LD_ADDR_VAR 0 3
27970: PUSH
27971: LD_INT 21
27973: PPUSH
27974: LD_VAR 0 1
27978: PPUSH
27979: CALL_OW 321
27983: PUSH
27984: LD_INT 2
27986: EQUAL
27987: ST_TO_ADDR
27988: GO 28162
27990: LD_INT 16
27992: DOUBLE
27993: EQUAL
27994: IFTRUE 27998
27996: GO 28023
27998: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27999: LD_ADDR_VAR 0 3
28003: PUSH
28004: LD_INT 84
28006: PPUSH
28007: LD_VAR 0 1
28011: PPUSH
28012: CALL_OW 321
28016: PUSH
28017: LD_INT 2
28019: EQUAL
28020: ST_TO_ADDR
28021: GO 28162
28023: LD_INT 19
28025: DOUBLE
28026: EQUAL
28027: IFTRUE 28037
28029: LD_INT 23
28031: DOUBLE
28032: EQUAL
28033: IFTRUE 28037
28035: GO 28062
28037: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28038: LD_ADDR_VAR 0 3
28042: PUSH
28043: LD_INT 83
28045: PPUSH
28046: LD_VAR 0 1
28050: PPUSH
28051: CALL_OW 321
28055: PUSH
28056: LD_INT 2
28058: EQUAL
28059: ST_TO_ADDR
28060: GO 28162
28062: LD_INT 17
28064: DOUBLE
28065: EQUAL
28066: IFTRUE 28070
28068: GO 28095
28070: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28071: LD_ADDR_VAR 0 3
28075: PUSH
28076: LD_INT 39
28078: PPUSH
28079: LD_VAR 0 1
28083: PPUSH
28084: CALL_OW 321
28088: PUSH
28089: LD_INT 2
28091: EQUAL
28092: ST_TO_ADDR
28093: GO 28162
28095: LD_INT 18
28097: DOUBLE
28098: EQUAL
28099: IFTRUE 28103
28101: GO 28128
28103: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28104: LD_ADDR_VAR 0 3
28108: PUSH
28109: LD_INT 40
28111: PPUSH
28112: LD_VAR 0 1
28116: PPUSH
28117: CALL_OW 321
28121: PUSH
28122: LD_INT 2
28124: EQUAL
28125: ST_TO_ADDR
28126: GO 28162
28128: LD_INT 27
28130: DOUBLE
28131: EQUAL
28132: IFTRUE 28136
28134: GO 28161
28136: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28137: LD_ADDR_VAR 0 3
28141: PUSH
28142: LD_INT 35
28144: PPUSH
28145: LD_VAR 0 1
28149: PPUSH
28150: CALL_OW 321
28154: PUSH
28155: LD_INT 2
28157: EQUAL
28158: ST_TO_ADDR
28159: GO 28162
28161: POP
// end ;
28162: LD_VAR 0 3
28166: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28167: LD_INT 0
28169: PPUSH
28170: PPUSH
28171: PPUSH
28172: PPUSH
28173: PPUSH
28174: PPUSH
28175: PPUSH
28176: PPUSH
28177: PPUSH
28178: PPUSH
28179: PPUSH
// result := false ;
28180: LD_ADDR_VAR 0 6
28184: PUSH
28185: LD_INT 0
28187: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28188: LD_VAR 0 1
28192: NOT
28193: PUSH
28194: LD_VAR 0 1
28198: PPUSH
28199: CALL_OW 266
28203: PUSH
28204: LD_INT 0
28206: PUSH
28207: LD_INT 1
28209: PUSH
28210: EMPTY
28211: LIST
28212: LIST
28213: IN
28214: NOT
28215: OR
28216: PUSH
28217: LD_VAR 0 2
28221: NOT
28222: OR
28223: PUSH
28224: LD_VAR 0 5
28228: PUSH
28229: LD_INT 0
28231: PUSH
28232: LD_INT 1
28234: PUSH
28235: LD_INT 2
28237: PUSH
28238: LD_INT 3
28240: PUSH
28241: LD_INT 4
28243: PUSH
28244: LD_INT 5
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: LIST
28251: LIST
28252: LIST
28253: LIST
28254: IN
28255: NOT
28256: OR
28257: PUSH
28258: LD_VAR 0 3
28262: PPUSH
28263: LD_VAR 0 4
28267: PPUSH
28268: CALL_OW 488
28272: NOT
28273: OR
28274: IFFALSE 28278
// exit ;
28276: GO 29014
// side := GetSide ( depot ) ;
28278: LD_ADDR_VAR 0 9
28282: PUSH
28283: LD_VAR 0 1
28287: PPUSH
28288: CALL_OW 255
28292: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28293: LD_VAR 0 9
28297: PPUSH
28298: LD_VAR 0 2
28302: PPUSH
28303: CALL 27791 0 2
28307: NOT
28308: IFFALSE 28312
// exit ;
28310: GO 29014
// pom := GetBase ( depot ) ;
28312: LD_ADDR_VAR 0 10
28316: PUSH
28317: LD_VAR 0 1
28321: PPUSH
28322: CALL_OW 274
28326: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28327: LD_ADDR_VAR 0 11
28331: PUSH
28332: LD_VAR 0 2
28336: PPUSH
28337: LD_VAR 0 1
28341: PPUSH
28342: CALL_OW 248
28346: PPUSH
28347: CALL_OW 450
28351: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28352: LD_VAR 0 10
28356: PPUSH
28357: LD_INT 1
28359: PPUSH
28360: CALL_OW 275
28364: PUSH
28365: LD_VAR 0 11
28369: PUSH
28370: LD_INT 1
28372: ARRAY
28373: GREATEREQUAL
28374: PUSH
28375: LD_VAR 0 10
28379: PPUSH
28380: LD_INT 2
28382: PPUSH
28383: CALL_OW 275
28387: PUSH
28388: LD_VAR 0 11
28392: PUSH
28393: LD_INT 2
28395: ARRAY
28396: GREATEREQUAL
28397: AND
28398: PUSH
28399: LD_VAR 0 10
28403: PPUSH
28404: LD_INT 3
28406: PPUSH
28407: CALL_OW 275
28411: PUSH
28412: LD_VAR 0 11
28416: PUSH
28417: LD_INT 3
28419: ARRAY
28420: GREATEREQUAL
28421: AND
28422: NOT
28423: IFFALSE 28427
// exit ;
28425: GO 29014
// if GetBType ( depot ) = b_depot then
28427: LD_VAR 0 1
28431: PPUSH
28432: CALL_OW 266
28436: PUSH
28437: LD_INT 0
28439: EQUAL
28440: IFFALSE 28452
// dist := 28 else
28442: LD_ADDR_VAR 0 14
28446: PUSH
28447: LD_INT 28
28449: ST_TO_ADDR
28450: GO 28460
// dist := 36 ;
28452: LD_ADDR_VAR 0 14
28456: PUSH
28457: LD_INT 36
28459: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28460: LD_VAR 0 1
28464: PPUSH
28465: LD_VAR 0 3
28469: PPUSH
28470: LD_VAR 0 4
28474: PPUSH
28475: CALL_OW 297
28479: PUSH
28480: LD_VAR 0 14
28484: GREATER
28485: IFFALSE 28489
// exit ;
28487: GO 29014
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28489: LD_ADDR_VAR 0 12
28493: PUSH
28494: LD_VAR 0 2
28498: PPUSH
28499: LD_VAR 0 3
28503: PPUSH
28504: LD_VAR 0 4
28508: PPUSH
28509: LD_VAR 0 5
28513: PPUSH
28514: LD_VAR 0 1
28518: PPUSH
28519: CALL_OW 248
28523: PPUSH
28524: LD_INT 0
28526: PPUSH
28527: CALL 29019 0 6
28531: ST_TO_ADDR
// if not hexes then
28532: LD_VAR 0 12
28536: NOT
28537: IFFALSE 28541
// exit ;
28539: GO 29014
// hex := GetHexInfo ( x , y ) ;
28541: LD_ADDR_VAR 0 15
28545: PUSH
28546: LD_VAR 0 3
28550: PPUSH
28551: LD_VAR 0 4
28555: PPUSH
28556: CALL_OW 546
28560: ST_TO_ADDR
// if hex [ 1 ] then
28561: LD_VAR 0 15
28565: PUSH
28566: LD_INT 1
28568: ARRAY
28569: IFFALSE 28573
// exit ;
28571: GO 29014
// height := hex [ 2 ] ;
28573: LD_ADDR_VAR 0 13
28577: PUSH
28578: LD_VAR 0 15
28582: PUSH
28583: LD_INT 2
28585: ARRAY
28586: ST_TO_ADDR
// for i = 1 to hexes do
28587: LD_ADDR_VAR 0 7
28591: PUSH
28592: DOUBLE
28593: LD_INT 1
28595: DEC
28596: ST_TO_ADDR
28597: LD_VAR 0 12
28601: PUSH
28602: FOR_TO
28603: IFFALSE 28933
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28605: LD_VAR 0 12
28609: PUSH
28610: LD_VAR 0 7
28614: ARRAY
28615: PUSH
28616: LD_INT 1
28618: ARRAY
28619: PPUSH
28620: LD_VAR 0 12
28624: PUSH
28625: LD_VAR 0 7
28629: ARRAY
28630: PUSH
28631: LD_INT 2
28633: ARRAY
28634: PPUSH
28635: CALL_OW 488
28639: NOT
28640: PUSH
28641: LD_VAR 0 12
28645: PUSH
28646: LD_VAR 0 7
28650: ARRAY
28651: PUSH
28652: LD_INT 1
28654: ARRAY
28655: PPUSH
28656: LD_VAR 0 12
28660: PUSH
28661: LD_VAR 0 7
28665: ARRAY
28666: PUSH
28667: LD_INT 2
28669: ARRAY
28670: PPUSH
28671: CALL_OW 428
28675: PUSH
28676: LD_INT 0
28678: GREATER
28679: OR
28680: PUSH
28681: LD_VAR 0 12
28685: PUSH
28686: LD_VAR 0 7
28690: ARRAY
28691: PUSH
28692: LD_INT 1
28694: ARRAY
28695: PPUSH
28696: LD_VAR 0 12
28700: PUSH
28701: LD_VAR 0 7
28705: ARRAY
28706: PUSH
28707: LD_INT 2
28709: ARRAY
28710: PPUSH
28711: CALL_OW 351
28715: OR
28716: IFFALSE 28722
// exit ;
28718: POP
28719: POP
28720: GO 29014
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28722: LD_ADDR_VAR 0 8
28726: PUSH
28727: LD_VAR 0 12
28731: PUSH
28732: LD_VAR 0 7
28736: ARRAY
28737: PUSH
28738: LD_INT 1
28740: ARRAY
28741: PPUSH
28742: LD_VAR 0 12
28746: PUSH
28747: LD_VAR 0 7
28751: ARRAY
28752: PUSH
28753: LD_INT 2
28755: ARRAY
28756: PPUSH
28757: CALL_OW 546
28761: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28762: LD_VAR 0 8
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_VAR 0 8
28775: PUSH
28776: LD_INT 2
28778: ARRAY
28779: PUSH
28780: LD_VAR 0 13
28784: PUSH
28785: LD_INT 2
28787: PLUS
28788: GREATER
28789: OR
28790: PUSH
28791: LD_VAR 0 8
28795: PUSH
28796: LD_INT 2
28798: ARRAY
28799: PUSH
28800: LD_VAR 0 13
28804: PUSH
28805: LD_INT 2
28807: MINUS
28808: LESS
28809: OR
28810: PUSH
28811: LD_VAR 0 8
28815: PUSH
28816: LD_INT 3
28818: ARRAY
28819: PUSH
28820: LD_INT 0
28822: PUSH
28823: LD_INT 8
28825: PUSH
28826: LD_INT 9
28828: PUSH
28829: LD_INT 10
28831: PUSH
28832: LD_INT 11
28834: PUSH
28835: LD_INT 12
28837: PUSH
28838: LD_INT 13
28840: PUSH
28841: LD_INT 16
28843: PUSH
28844: LD_INT 17
28846: PUSH
28847: LD_INT 18
28849: PUSH
28850: LD_INT 19
28852: PUSH
28853: LD_INT 20
28855: PUSH
28856: LD_INT 21
28858: PUSH
28859: EMPTY
28860: LIST
28861: LIST
28862: LIST
28863: LIST
28864: LIST
28865: LIST
28866: LIST
28867: LIST
28868: LIST
28869: LIST
28870: LIST
28871: LIST
28872: LIST
28873: IN
28874: NOT
28875: OR
28876: PUSH
28877: LD_VAR 0 8
28881: PUSH
28882: LD_INT 5
28884: ARRAY
28885: NOT
28886: OR
28887: PUSH
28888: LD_VAR 0 8
28892: PUSH
28893: LD_INT 6
28895: ARRAY
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: LD_INT 2
28902: PUSH
28903: LD_INT 7
28905: PUSH
28906: LD_INT 9
28908: PUSH
28909: LD_INT 10
28911: PUSH
28912: LD_INT 11
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: IN
28923: NOT
28924: OR
28925: IFFALSE 28931
// exit ;
28927: POP
28928: POP
28929: GO 29014
// end ;
28931: GO 28602
28933: POP
28934: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28935: LD_VAR 0 9
28939: PPUSH
28940: LD_VAR 0 3
28944: PPUSH
28945: LD_VAR 0 4
28949: PPUSH
28950: LD_INT 20
28952: PPUSH
28953: CALL 20966 0 4
28957: PUSH
28958: LD_INT 4
28960: ARRAY
28961: IFFALSE 28965
// exit ;
28963: GO 29014
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28965: LD_VAR 0 2
28969: PUSH
28970: LD_INT 29
28972: PUSH
28973: LD_INT 30
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: IN
28980: PUSH
28981: LD_VAR 0 3
28985: PPUSH
28986: LD_VAR 0 4
28990: PPUSH
28991: LD_VAR 0 9
28995: PPUSH
28996: CALL_OW 440
29000: NOT
29001: AND
29002: IFFALSE 29006
// exit ;
29004: GO 29014
// result := true ;
29006: LD_ADDR_VAR 0 6
29010: PUSH
29011: LD_INT 1
29013: ST_TO_ADDR
// end ;
29014: LD_VAR 0 6
29018: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29019: LD_INT 0
29021: PPUSH
29022: PPUSH
29023: PPUSH
29024: PPUSH
29025: PPUSH
29026: PPUSH
29027: PPUSH
29028: PPUSH
29029: PPUSH
29030: PPUSH
29031: PPUSH
29032: PPUSH
29033: PPUSH
29034: PPUSH
29035: PPUSH
29036: PPUSH
29037: PPUSH
29038: PPUSH
29039: PPUSH
29040: PPUSH
29041: PPUSH
29042: PPUSH
29043: PPUSH
29044: PPUSH
29045: PPUSH
29046: PPUSH
29047: PPUSH
29048: PPUSH
29049: PPUSH
29050: PPUSH
29051: PPUSH
29052: PPUSH
29053: PPUSH
29054: PPUSH
29055: PPUSH
29056: PPUSH
29057: PPUSH
29058: PPUSH
29059: PPUSH
29060: PPUSH
29061: PPUSH
29062: PPUSH
29063: PPUSH
29064: PPUSH
29065: PPUSH
29066: PPUSH
29067: PPUSH
29068: PPUSH
29069: PPUSH
29070: PPUSH
29071: PPUSH
29072: PPUSH
29073: PPUSH
29074: PPUSH
29075: PPUSH
29076: PPUSH
29077: PPUSH
29078: PPUSH
// result = [ ] ;
29079: LD_ADDR_VAR 0 7
29083: PUSH
29084: EMPTY
29085: ST_TO_ADDR
// temp_list = [ ] ;
29086: LD_ADDR_VAR 0 9
29090: PUSH
29091: EMPTY
29092: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29093: LD_VAR 0 4
29097: PUSH
29098: LD_INT 0
29100: PUSH
29101: LD_INT 1
29103: PUSH
29104: LD_INT 2
29106: PUSH
29107: LD_INT 3
29109: PUSH
29110: LD_INT 4
29112: PUSH
29113: LD_INT 5
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: LIST
29120: LIST
29121: LIST
29122: LIST
29123: IN
29124: NOT
29125: PUSH
29126: LD_VAR 0 1
29130: PUSH
29131: LD_INT 0
29133: PUSH
29134: LD_INT 1
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: IN
29141: PUSH
29142: LD_VAR 0 5
29146: PUSH
29147: LD_INT 1
29149: PUSH
29150: LD_INT 2
29152: PUSH
29153: LD_INT 3
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: LIST
29160: IN
29161: NOT
29162: AND
29163: OR
29164: IFFALSE 29168
// exit ;
29166: GO 47559
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29168: LD_VAR 0 1
29172: PUSH
29173: LD_INT 6
29175: PUSH
29176: LD_INT 7
29178: PUSH
29179: LD_INT 8
29181: PUSH
29182: LD_INT 13
29184: PUSH
29185: LD_INT 12
29187: PUSH
29188: LD_INT 15
29190: PUSH
29191: LD_INT 11
29193: PUSH
29194: LD_INT 14
29196: PUSH
29197: LD_INT 10
29199: PUSH
29200: EMPTY
29201: LIST
29202: LIST
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: IN
29211: IFFALSE 29221
// btype = b_lab ;
29213: LD_ADDR_VAR 0 1
29217: PUSH
29218: LD_INT 6
29220: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29221: LD_VAR 0 6
29225: PUSH
29226: LD_INT 0
29228: PUSH
29229: LD_INT 1
29231: PUSH
29232: LD_INT 2
29234: PUSH
29235: EMPTY
29236: LIST
29237: LIST
29238: LIST
29239: IN
29240: NOT
29241: PUSH
29242: LD_VAR 0 1
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: LD_INT 1
29252: PUSH
29253: LD_INT 2
29255: PUSH
29256: LD_INT 3
29258: PUSH
29259: LD_INT 6
29261: PUSH
29262: LD_INT 36
29264: PUSH
29265: LD_INT 4
29267: PUSH
29268: LD_INT 5
29270: PUSH
29271: LD_INT 31
29273: PUSH
29274: LD_INT 32
29276: PUSH
29277: LD_INT 33
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: IN
29293: NOT
29294: PUSH
29295: LD_VAR 0 6
29299: PUSH
29300: LD_INT 1
29302: EQUAL
29303: AND
29304: OR
29305: PUSH
29306: LD_VAR 0 1
29310: PUSH
29311: LD_INT 2
29313: PUSH
29314: LD_INT 3
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: IN
29321: NOT
29322: PUSH
29323: LD_VAR 0 6
29327: PUSH
29328: LD_INT 2
29330: EQUAL
29331: AND
29332: OR
29333: IFFALSE 29343
// mode = 0 ;
29335: LD_ADDR_VAR 0 6
29339: PUSH
29340: LD_INT 0
29342: ST_TO_ADDR
// case mode of 0 :
29343: LD_VAR 0 6
29347: PUSH
29348: LD_INT 0
29350: DOUBLE
29351: EQUAL
29352: IFTRUE 29356
29354: GO 40809
29356: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29357: LD_ADDR_VAR 0 11
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: LD_INT 0
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 0
29374: PUSH
29375: LD_INT 1
29377: NEG
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 0
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 1
29395: PUSH
29396: LD_INT 1
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: LD_INT 1
29408: PUSH
29409: EMPTY
29410: LIST
29411: LIST
29412: PUSH
29413: LD_INT 1
29415: NEG
29416: PUSH
29417: LD_INT 0
29419: PUSH
29420: EMPTY
29421: LIST
29422: LIST
29423: PUSH
29424: LD_INT 1
29426: NEG
29427: PUSH
29428: LD_INT 1
29430: NEG
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: PUSH
29436: LD_INT 1
29438: NEG
29439: PUSH
29440: LD_INT 2
29442: NEG
29443: PUSH
29444: EMPTY
29445: LIST
29446: LIST
29447: PUSH
29448: LD_INT 0
29450: PUSH
29451: LD_INT 2
29453: NEG
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 1
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 1
29472: PUSH
29473: LD_INT 2
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PUSH
29480: LD_INT 0
29482: PUSH
29483: LD_INT 2
29485: PUSH
29486: EMPTY
29487: LIST
29488: LIST
29489: PUSH
29490: LD_INT 1
29492: NEG
29493: PUSH
29494: LD_INT 1
29496: PUSH
29497: EMPTY
29498: LIST
29499: LIST
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: LD_INT 3
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: LD_INT 3
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: PUSH
29521: LD_INT 1
29523: NEG
29524: PUSH
29525: LD_INT 2
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: EMPTY
29533: LIST
29534: LIST
29535: LIST
29536: LIST
29537: LIST
29538: LIST
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: LIST
29546: LIST
29547: LIST
29548: LIST
29549: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29550: LD_ADDR_VAR 0 12
29554: PUSH
29555: LD_INT 0
29557: PUSH
29558: LD_INT 0
29560: PUSH
29561: EMPTY
29562: LIST
29563: LIST
29564: PUSH
29565: LD_INT 0
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 1
29578: PUSH
29579: LD_INT 0
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 1
29588: PUSH
29589: LD_INT 1
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 0
29598: PUSH
29599: LD_INT 1
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 1
29608: NEG
29609: PUSH
29610: LD_INT 0
29612: PUSH
29613: EMPTY
29614: LIST
29615: LIST
29616: PUSH
29617: LD_INT 1
29619: NEG
29620: PUSH
29621: LD_INT 1
29623: NEG
29624: PUSH
29625: EMPTY
29626: LIST
29627: LIST
29628: PUSH
29629: LD_INT 1
29631: PUSH
29632: LD_INT 1
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 2
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: PUSH
29653: LD_INT 1
29655: PUSH
29656: EMPTY
29657: LIST
29658: LIST
29659: PUSH
29660: LD_INT 1
29662: NEG
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 2
29673: NEG
29674: PUSH
29675: LD_INT 0
29677: PUSH
29678: EMPTY
29679: LIST
29680: LIST
29681: PUSH
29682: LD_INT 2
29684: NEG
29685: PUSH
29686: LD_INT 1
29688: NEG
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: LD_INT 2
29696: NEG
29697: PUSH
29698: LD_INT 1
29700: PUSH
29701: EMPTY
29702: LIST
29703: LIST
29704: PUSH
29705: LD_INT 3
29707: NEG
29708: PUSH
29709: LD_INT 0
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 3
29718: NEG
29719: PUSH
29720: LD_INT 1
29722: NEG
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: LIST
29732: LIST
29733: LIST
29734: LIST
29735: LIST
29736: LIST
29737: LIST
29738: LIST
29739: LIST
29740: LIST
29741: LIST
29742: LIST
29743: LIST
29744: LIST
29745: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29746: LD_ADDR_VAR 0 13
29750: PUSH
29751: LD_INT 0
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 0
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 1
29774: PUSH
29775: LD_INT 0
29777: PUSH
29778: EMPTY
29779: LIST
29780: LIST
29781: PUSH
29782: LD_INT 1
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: EMPTY
29789: LIST
29790: LIST
29791: PUSH
29792: LD_INT 0
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: EMPTY
29799: LIST
29800: LIST
29801: PUSH
29802: LD_INT 1
29804: NEG
29805: PUSH
29806: LD_INT 0
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: LD_INT 1
29819: NEG
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 1
29827: NEG
29828: PUSH
29829: LD_INT 2
29831: NEG
29832: PUSH
29833: EMPTY
29834: LIST
29835: LIST
29836: PUSH
29837: LD_INT 2
29839: PUSH
29840: LD_INT 1
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 2
29849: PUSH
29850: LD_INT 2
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 1
29859: PUSH
29860: LD_INT 2
29862: PUSH
29863: EMPTY
29864: LIST
29865: LIST
29866: PUSH
29867: LD_INT 2
29869: NEG
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: EMPTY
29876: LIST
29877: LIST
29878: PUSH
29879: LD_INT 2
29881: NEG
29882: PUSH
29883: LD_INT 2
29885: NEG
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 2
29893: NEG
29894: PUSH
29895: LD_INT 3
29897: NEG
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 3
29905: NEG
29906: PUSH
29907: LD_INT 2
29909: NEG
29910: PUSH
29911: EMPTY
29912: LIST
29913: LIST
29914: PUSH
29915: LD_INT 3
29917: NEG
29918: PUSH
29919: LD_INT 3
29921: NEG
29922: PUSH
29923: EMPTY
29924: LIST
29925: LIST
29926: PUSH
29927: EMPTY
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29945: LD_ADDR_VAR 0 14
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 0
29962: PUSH
29963: LD_INT 1
29965: NEG
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 1
29973: PUSH
29974: LD_INT 0
29976: PUSH
29977: EMPTY
29978: LIST
29979: LIST
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: LD_INT 1
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: PUSH
29991: LD_INT 0
29993: PUSH
29994: LD_INT 1
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 1
30003: NEG
30004: PUSH
30005: LD_INT 0
30007: PUSH
30008: EMPTY
30009: LIST
30010: LIST
30011: PUSH
30012: LD_INT 1
30014: NEG
30015: PUSH
30016: LD_INT 1
30018: NEG
30019: PUSH
30020: EMPTY
30021: LIST
30022: LIST
30023: PUSH
30024: LD_INT 1
30026: NEG
30027: PUSH
30028: LD_INT 2
30030: NEG
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: LD_INT 2
30041: NEG
30042: PUSH
30043: EMPTY
30044: LIST
30045: LIST
30046: PUSH
30047: LD_INT 1
30049: PUSH
30050: LD_INT 1
30052: NEG
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 1
30060: PUSH
30061: LD_INT 2
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 0
30070: PUSH
30071: LD_INT 2
30073: PUSH
30074: EMPTY
30075: LIST
30076: LIST
30077: PUSH
30078: LD_INT 1
30080: NEG
30081: PUSH
30082: LD_INT 1
30084: PUSH
30085: EMPTY
30086: LIST
30087: LIST
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: LD_INT 3
30095: NEG
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 0
30103: PUSH
30104: LD_INT 3
30106: NEG
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: LD_INT 2
30117: NEG
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30141: LD_ADDR_VAR 0 15
30145: PUSH
30146: LD_INT 0
30148: PUSH
30149: LD_INT 0
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 1
30169: PUSH
30170: LD_INT 0
30172: PUSH
30173: EMPTY
30174: LIST
30175: LIST
30176: PUSH
30177: LD_INT 1
30179: PUSH
30180: LD_INT 1
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 0
30189: PUSH
30190: LD_INT 1
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 1
30199: NEG
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 1
30210: NEG
30211: PUSH
30212: LD_INT 1
30214: NEG
30215: PUSH
30216: EMPTY
30217: LIST
30218: LIST
30219: PUSH
30220: LD_INT 1
30222: PUSH
30223: LD_INT 1
30225: NEG
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: EMPTY
30238: LIST
30239: LIST
30240: PUSH
30241: LD_INT 2
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: EMPTY
30248: LIST
30249: LIST
30250: PUSH
30251: LD_INT 1
30253: NEG
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 2
30275: NEG
30276: PUSH
30277: LD_INT 1
30279: NEG
30280: PUSH
30281: EMPTY
30282: LIST
30283: LIST
30284: PUSH
30285: LD_INT 2
30287: PUSH
30288: LD_INT 1
30290: NEG
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 3
30298: PUSH
30299: LD_INT 0
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 3
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: EMPTY
30313: LIST
30314: LIST
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: LIST
30320: LIST
30321: LIST
30322: LIST
30323: LIST
30324: LIST
30325: LIST
30326: LIST
30327: LIST
30328: LIST
30329: LIST
30330: LIST
30331: LIST
30332: LIST
30333: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30334: LD_ADDR_VAR 0 16
30338: PUSH
30339: LD_INT 0
30341: PUSH
30342: LD_INT 0
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 0
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: PUSH
30363: LD_INT 0
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: PUSH
30370: LD_INT 1
30372: PUSH
30373: LD_INT 1
30375: PUSH
30376: EMPTY
30377: LIST
30378: LIST
30379: PUSH
30380: LD_INT 0
30382: PUSH
30383: LD_INT 1
30385: PUSH
30386: EMPTY
30387: LIST
30388: LIST
30389: PUSH
30390: LD_INT 1
30392: NEG
30393: PUSH
30394: LD_INT 0
30396: PUSH
30397: EMPTY
30398: LIST
30399: LIST
30400: PUSH
30401: LD_INT 1
30403: NEG
30404: PUSH
30405: LD_INT 1
30407: NEG
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 1
30415: NEG
30416: PUSH
30417: LD_INT 2
30419: NEG
30420: PUSH
30421: EMPTY
30422: LIST
30423: LIST
30424: PUSH
30425: LD_INT 2
30427: PUSH
30428: LD_INT 1
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 2
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: LD_INT 2
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 2
30457: NEG
30458: PUSH
30459: LD_INT 1
30461: NEG
30462: PUSH
30463: EMPTY
30464: LIST
30465: LIST
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: LD_INT 2
30473: NEG
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 3
30481: PUSH
30482: LD_INT 2
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 3
30491: PUSH
30492: LD_INT 3
30494: PUSH
30495: EMPTY
30496: LIST
30497: LIST
30498: PUSH
30499: LD_INT 2
30501: PUSH
30502: LD_INT 3
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: LIST
30513: LIST
30514: LIST
30515: LIST
30516: LIST
30517: LIST
30518: LIST
30519: LIST
30520: LIST
30521: LIST
30522: LIST
30523: LIST
30524: LIST
30525: LIST
30526: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30527: LD_ADDR_VAR 0 17
30531: PUSH
30532: LD_INT 0
30534: PUSH
30535: LD_INT 0
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 0
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: EMPTY
30550: LIST
30551: LIST
30552: PUSH
30553: LD_INT 1
30555: PUSH
30556: LD_INT 0
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: PUSH
30566: LD_INT 1
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: NEG
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: LD_INT 0
30620: PUSH
30621: LD_INT 2
30623: NEG
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: PUSH
30632: LD_INT 1
30634: NEG
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: LD_INT 0
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: LD_INT 1
30655: PUSH
30656: EMPTY
30657: LIST
30658: LIST
30659: PUSH
30660: LD_INT 2
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: EMPTY
30667: LIST
30668: LIST
30669: PUSH
30670: LD_INT 1
30672: PUSH
30673: LD_INT 2
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 0
30682: PUSH
30683: LD_INT 2
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: LD_INT 1
30696: PUSH
30697: EMPTY
30698: LIST
30699: LIST
30700: PUSH
30701: LD_INT 2
30703: NEG
30704: PUSH
30705: LD_INT 0
30707: PUSH
30708: EMPTY
30709: LIST
30710: LIST
30711: PUSH
30712: LD_INT 2
30714: NEG
30715: PUSH
30716: LD_INT 1
30718: NEG
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 2
30726: NEG
30727: PUSH
30728: LD_INT 2
30730: NEG
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: EMPTY
30737: LIST
30738: LIST
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: LIST
30756: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30757: LD_ADDR_VAR 0 18
30761: PUSH
30762: LD_INT 0
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 0
30774: PUSH
30775: LD_INT 1
30777: NEG
30778: PUSH
30779: EMPTY
30780: LIST
30781: LIST
30782: PUSH
30783: LD_INT 1
30785: PUSH
30786: LD_INT 0
30788: PUSH
30789: EMPTY
30790: LIST
30791: LIST
30792: PUSH
30793: LD_INT 1
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 0
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 1
30815: NEG
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 1
30826: NEG
30827: PUSH
30828: LD_INT 1
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 1
30838: NEG
30839: PUSH
30840: LD_INT 2
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: LD_INT 0
30850: PUSH
30851: LD_INT 2
30853: NEG
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: LD_INT 1
30861: PUSH
30862: LD_INT 1
30864: NEG
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: LD_INT 0
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: LD_INT 1
30885: PUSH
30886: EMPTY
30887: LIST
30888: LIST
30889: PUSH
30890: LD_INT 2
30892: PUSH
30893: LD_INT 2
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 1
30902: PUSH
30903: LD_INT 2
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PUSH
30910: LD_INT 0
30912: PUSH
30913: LD_INT 2
30915: PUSH
30916: EMPTY
30917: LIST
30918: LIST
30919: PUSH
30920: LD_INT 1
30922: NEG
30923: PUSH
30924: LD_INT 1
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: LD_INT 2
30933: NEG
30934: PUSH
30935: LD_INT 0
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: NEG
30945: PUSH
30946: LD_INT 1
30948: NEG
30949: PUSH
30950: EMPTY
30951: LIST
30952: LIST
30953: PUSH
30954: LD_INT 2
30956: NEG
30957: PUSH
30958: LD_INT 2
30960: NEG
30961: PUSH
30962: EMPTY
30963: LIST
30964: LIST
30965: PUSH
30966: EMPTY
30967: LIST
30968: LIST
30969: LIST
30970: LIST
30971: LIST
30972: LIST
30973: LIST
30974: LIST
30975: LIST
30976: LIST
30977: LIST
30978: LIST
30979: LIST
30980: LIST
30981: LIST
30982: LIST
30983: LIST
30984: LIST
30985: LIST
30986: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30987: LD_ADDR_VAR 0 19
30991: PUSH
30992: LD_INT 0
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: EMPTY
31010: LIST
31011: LIST
31012: PUSH
31013: LD_INT 1
31015: PUSH
31016: LD_INT 0
31018: PUSH
31019: EMPTY
31020: LIST
31021: LIST
31022: PUSH
31023: LD_INT 1
31025: PUSH
31026: LD_INT 1
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 0
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 1
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 1
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 2
31083: NEG
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: LD_INT 0
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: LD_INT 1
31115: PUSH
31116: EMPTY
31117: LIST
31118: LIST
31119: PUSH
31120: LD_INT 2
31122: PUSH
31123: LD_INT 2
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 1
31132: PUSH
31133: LD_INT 2
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 0
31142: PUSH
31143: LD_INT 2
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: LD_INT 1
31152: NEG
31153: PUSH
31154: LD_INT 1
31156: PUSH
31157: EMPTY
31158: LIST
31159: LIST
31160: PUSH
31161: LD_INT 2
31163: NEG
31164: PUSH
31165: LD_INT 0
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: NEG
31175: PUSH
31176: LD_INT 1
31178: NEG
31179: PUSH
31180: EMPTY
31181: LIST
31182: LIST
31183: PUSH
31184: LD_INT 2
31186: NEG
31187: PUSH
31188: LD_INT 2
31190: NEG
31191: PUSH
31192: EMPTY
31193: LIST
31194: LIST
31195: PUSH
31196: EMPTY
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: LIST
31203: LIST
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31217: LD_ADDR_VAR 0 20
31221: PUSH
31222: LD_INT 0
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: LD_INT 1
31237: NEG
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 1
31245: PUSH
31246: LD_INT 0
31248: PUSH
31249: EMPTY
31250: LIST
31251: LIST
31252: PUSH
31253: LD_INT 1
31255: PUSH
31256: LD_INT 1
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 1
31275: NEG
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: LD_INT 1
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 1
31298: NEG
31299: PUSH
31300: LD_INT 2
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 0
31310: PUSH
31311: LD_INT 2
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 1
31321: PUSH
31322: LD_INT 1
31324: NEG
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: LD_INT 0
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: LD_INT 1
31345: PUSH
31346: EMPTY
31347: LIST
31348: LIST
31349: PUSH
31350: LD_INT 2
31352: PUSH
31353: LD_INT 2
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 1
31362: PUSH
31363: LD_INT 2
31365: PUSH
31366: EMPTY
31367: LIST
31368: LIST
31369: PUSH
31370: LD_INT 0
31372: PUSH
31373: LD_INT 2
31375: PUSH
31376: EMPTY
31377: LIST
31378: LIST
31379: PUSH
31380: LD_INT 1
31382: NEG
31383: PUSH
31384: LD_INT 1
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 2
31393: NEG
31394: PUSH
31395: LD_INT 0
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: LD_INT 1
31408: NEG
31409: PUSH
31410: EMPTY
31411: LIST
31412: LIST
31413: PUSH
31414: LD_INT 2
31416: NEG
31417: PUSH
31418: LD_INT 2
31420: NEG
31421: PUSH
31422: EMPTY
31423: LIST
31424: LIST
31425: PUSH
31426: EMPTY
31427: LIST
31428: LIST
31429: LIST
31430: LIST
31431: LIST
31432: LIST
31433: LIST
31434: LIST
31435: LIST
31436: LIST
31437: LIST
31438: LIST
31439: LIST
31440: LIST
31441: LIST
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31447: LD_ADDR_VAR 0 21
31451: PUSH
31452: LD_INT 0
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: LD_INT 1
31475: PUSH
31476: LD_INT 0
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: PUSH
31483: LD_INT 1
31485: PUSH
31486: LD_INT 1
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 0
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 1
31505: NEG
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 1
31528: NEG
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: LD_INT 2
31543: NEG
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: LD_INT 1
31554: NEG
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: LD_INT 0
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 2
31572: PUSH
31573: LD_INT 1
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: LD_INT 2
31582: PUSH
31583: LD_INT 2
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 1
31592: PUSH
31593: LD_INT 2
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 0
31602: PUSH
31603: LD_INT 2
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PUSH
31610: LD_INT 1
31612: NEG
31613: PUSH
31614: LD_INT 1
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: PUSH
31621: LD_INT 2
31623: NEG
31624: PUSH
31625: LD_INT 0
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: NEG
31635: PUSH
31636: LD_INT 1
31638: NEG
31639: PUSH
31640: EMPTY
31641: LIST
31642: LIST
31643: PUSH
31644: LD_INT 2
31646: NEG
31647: PUSH
31648: LD_INT 2
31650: NEG
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: LIST
31660: LIST
31661: LIST
31662: LIST
31663: LIST
31664: LIST
31665: LIST
31666: LIST
31667: LIST
31668: LIST
31669: LIST
31670: LIST
31671: LIST
31672: LIST
31673: LIST
31674: LIST
31675: LIST
31676: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31677: LD_ADDR_VAR 0 22
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: LD_INT 0
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: PUSH
31716: LD_INT 1
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 0
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 1
31735: NEG
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 1
31758: NEG
31759: PUSH
31760: LD_INT 2
31762: NEG
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 2
31773: NEG
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 1
31781: PUSH
31782: LD_INT 1
31784: NEG
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: LD_INT 0
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: LD_INT 1
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 2
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: LD_INT 2
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 0
31832: PUSH
31833: LD_INT 2
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: LD_INT 1
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 2
31853: NEG
31854: PUSH
31855: LD_INT 0
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: NEG
31865: PUSH
31866: LD_INT 1
31868: NEG
31869: PUSH
31870: EMPTY
31871: LIST
31872: LIST
31873: PUSH
31874: LD_INT 2
31876: NEG
31877: PUSH
31878: LD_INT 2
31880: NEG
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: EMPTY
31887: LIST
31888: LIST
31889: LIST
31890: LIST
31891: LIST
31892: LIST
31893: LIST
31894: LIST
31895: LIST
31896: LIST
31897: LIST
31898: LIST
31899: LIST
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31907: LD_ADDR_VAR 0 23
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 0
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 1
31935: PUSH
31936: LD_INT 0
31938: PUSH
31939: EMPTY
31940: LIST
31941: LIST
31942: PUSH
31943: LD_INT 1
31945: PUSH
31946: LD_INT 1
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 1
31965: NEG
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 1
31976: NEG
31977: PUSH
31978: LD_INT 1
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 1
31988: NEG
31989: PUSH
31990: LD_INT 2
31992: NEG
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: LD_INT 2
32003: NEG
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: PUSH
32023: LD_INT 0
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 2
32032: PUSH
32033: LD_INT 1
32035: PUSH
32036: EMPTY
32037: LIST
32038: LIST
32039: PUSH
32040: LD_INT 2
32042: PUSH
32043: LD_INT 2
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: LD_INT 2
32055: PUSH
32056: EMPTY
32057: LIST
32058: LIST
32059: PUSH
32060: LD_INT 0
32062: PUSH
32063: LD_INT 2
32065: PUSH
32066: EMPTY
32067: LIST
32068: LIST
32069: PUSH
32070: LD_INT 1
32072: NEG
32073: PUSH
32074: LD_INT 1
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 2
32083: NEG
32084: PUSH
32085: LD_INT 0
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: NEG
32095: PUSH
32096: LD_INT 1
32098: NEG
32099: PUSH
32100: EMPTY
32101: LIST
32102: LIST
32103: PUSH
32104: LD_INT 2
32106: NEG
32107: PUSH
32108: LD_INT 2
32110: NEG
32111: PUSH
32112: EMPTY
32113: LIST
32114: LIST
32115: PUSH
32116: LD_INT 2
32118: NEG
32119: PUSH
32120: LD_INT 3
32122: NEG
32123: PUSH
32124: EMPTY
32125: LIST
32126: LIST
32127: PUSH
32128: LD_INT 1
32130: NEG
32131: PUSH
32132: LD_INT 3
32134: NEG
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: PUSH
32140: LD_INT 1
32142: PUSH
32143: LD_INT 2
32145: NEG
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: PUSH
32151: LD_INT 2
32153: PUSH
32154: LD_INT 1
32156: NEG
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32187: LD_ADDR_VAR 0 24
32191: PUSH
32192: LD_INT 0
32194: PUSH
32195: LD_INT 0
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 0
32204: PUSH
32205: LD_INT 1
32207: NEG
32208: PUSH
32209: EMPTY
32210: LIST
32211: LIST
32212: PUSH
32213: LD_INT 1
32215: PUSH
32216: LD_INT 0
32218: PUSH
32219: EMPTY
32220: LIST
32221: LIST
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: LD_INT 1
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: PUSH
32233: LD_INT 0
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 1
32245: NEG
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 1
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 0
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: PUSH
32303: LD_INT 0
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 2
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 2
32322: PUSH
32323: LD_INT 2
32325: PUSH
32326: EMPTY
32327: LIST
32328: LIST
32329: PUSH
32330: LD_INT 1
32332: PUSH
32333: LD_INT 2
32335: PUSH
32336: EMPTY
32337: LIST
32338: LIST
32339: PUSH
32340: LD_INT 0
32342: PUSH
32343: LD_INT 2
32345: PUSH
32346: EMPTY
32347: LIST
32348: LIST
32349: PUSH
32350: LD_INT 1
32352: NEG
32353: PUSH
32354: LD_INT 1
32356: PUSH
32357: EMPTY
32358: LIST
32359: LIST
32360: PUSH
32361: LD_INT 2
32363: NEG
32364: PUSH
32365: LD_INT 0
32367: PUSH
32368: EMPTY
32369: LIST
32370: LIST
32371: PUSH
32372: LD_INT 2
32374: NEG
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: EMPTY
32381: LIST
32382: LIST
32383: PUSH
32384: LD_INT 2
32386: NEG
32387: PUSH
32388: LD_INT 2
32390: NEG
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: PUSH
32399: LD_INT 2
32401: NEG
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 2
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: LD_INT 3
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 3
32430: PUSH
32431: LD_INT 2
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: LIST
32442: LIST
32443: LIST
32444: LIST
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32463: LD_ADDR_VAR 0 25
32467: PUSH
32468: LD_INT 0
32470: PUSH
32471: LD_INT 0
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 0
32480: PUSH
32481: LD_INT 1
32483: NEG
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: LD_INT 0
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 0
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: NEG
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: NEG
32545: PUSH
32546: LD_INT 2
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 0
32556: PUSH
32557: LD_INT 2
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: PUSH
32568: LD_INT 1
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: PUSH
32579: LD_INT 0
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 2
32588: PUSH
32589: LD_INT 1
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 2
32598: PUSH
32599: LD_INT 2
32601: PUSH
32602: EMPTY
32603: LIST
32604: LIST
32605: PUSH
32606: LD_INT 1
32608: PUSH
32609: LD_INT 2
32611: PUSH
32612: EMPTY
32613: LIST
32614: LIST
32615: PUSH
32616: LD_INT 0
32618: PUSH
32619: LD_INT 2
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 1
32628: NEG
32629: PUSH
32630: LD_INT 1
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: NEG
32640: PUSH
32641: LD_INT 0
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 1
32654: NEG
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 2
32662: NEG
32663: PUSH
32664: LD_INT 2
32666: NEG
32667: PUSH
32668: EMPTY
32669: LIST
32670: LIST
32671: PUSH
32672: LD_INT 3
32674: PUSH
32675: LD_INT 1
32677: PUSH
32678: EMPTY
32679: LIST
32680: LIST
32681: PUSH
32682: LD_INT 3
32684: PUSH
32685: LD_INT 2
32687: PUSH
32688: EMPTY
32689: LIST
32690: LIST
32691: PUSH
32692: LD_INT 2
32694: PUSH
32695: LD_INT 3
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: LD_INT 3
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32737: LD_ADDR_VAR 0 26
32741: PUSH
32742: LD_INT 0
32744: PUSH
32745: LD_INT 0
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 1
32765: PUSH
32766: LD_INT 0
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 1
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 1
32795: NEG
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 1
32806: NEG
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 0
32830: PUSH
32831: LD_INT 2
32833: NEG
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: PUSH
32842: LD_INT 1
32844: NEG
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: PUSH
32853: LD_INT 0
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: LD_INT 1
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 2
32872: PUSH
32873: LD_INT 2
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 1
32882: PUSH
32883: LD_INT 2
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: LD_INT 2
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 2
32913: NEG
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: LD_INT 1
32928: NEG
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 2
32936: NEG
32937: PUSH
32938: LD_INT 2
32940: NEG
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 2
32948: PUSH
32949: LD_INT 3
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 1
32958: PUSH
32959: LD_INT 3
32961: PUSH
32962: EMPTY
32963: LIST
32964: LIST
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: LD_INT 2
32972: PUSH
32973: EMPTY
32974: LIST
32975: LIST
32976: PUSH
32977: LD_INT 2
32979: NEG
32980: PUSH
32981: LD_INT 1
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33013: LD_ADDR_VAR 0 27
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: LD_INT 0
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: LD_INT 0
33044: PUSH
33045: EMPTY
33046: LIST
33047: LIST
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: LD_INT 1
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 1
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 1
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: LD_INT 2
33109: NEG
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: LD_INT 1
33120: NEG
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: PUSH
33129: LD_INT 0
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 2
33138: PUSH
33139: LD_INT 1
33141: PUSH
33142: EMPTY
33143: LIST
33144: LIST
33145: PUSH
33146: LD_INT 2
33148: PUSH
33149: LD_INT 2
33151: PUSH
33152: EMPTY
33153: LIST
33154: LIST
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: LD_INT 2
33161: PUSH
33162: EMPTY
33163: LIST
33164: LIST
33165: PUSH
33166: LD_INT 0
33168: PUSH
33169: LD_INT 2
33171: PUSH
33172: EMPTY
33173: LIST
33174: LIST
33175: PUSH
33176: LD_INT 1
33178: NEG
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: EMPTY
33195: LIST
33196: LIST
33197: PUSH
33198: LD_INT 2
33200: NEG
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 2
33212: NEG
33213: PUSH
33214: LD_INT 2
33216: NEG
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 1
33224: NEG
33225: PUSH
33226: LD_INT 2
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: LD_INT 1
33239: PUSH
33240: EMPTY
33241: LIST
33242: LIST
33243: PUSH
33244: LD_INT 3
33246: NEG
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 3
33258: NEG
33259: PUSH
33260: LD_INT 2
33262: NEG
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33293: LD_ADDR_VAR 0 28
33297: PUSH
33298: LD_INT 0
33300: PUSH
33301: LD_INT 0
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 0
33310: PUSH
33311: LD_INT 1
33313: NEG
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: LD_INT 0
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 1
33331: PUSH
33332: LD_INT 1
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 0
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: LD_INT 1
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 1
33374: NEG
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 0
33386: PUSH
33387: LD_INT 2
33389: NEG
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: PUSH
33398: LD_INT 1
33400: NEG
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 2
33408: PUSH
33409: LD_INT 0
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 2
33418: PUSH
33419: LD_INT 1
33421: PUSH
33422: EMPTY
33423: LIST
33424: LIST
33425: PUSH
33426: LD_INT 2
33428: PUSH
33429: LD_INT 2
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: PUSH
33436: LD_INT 1
33438: PUSH
33439: LD_INT 2
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: PUSH
33446: LD_INT 0
33448: PUSH
33449: LD_INT 2
33451: PUSH
33452: EMPTY
33453: LIST
33454: LIST
33455: PUSH
33456: LD_INT 1
33458: NEG
33459: PUSH
33460: LD_INT 1
33462: PUSH
33463: EMPTY
33464: LIST
33465: LIST
33466: PUSH
33467: LD_INT 2
33469: NEG
33470: PUSH
33471: LD_INT 0
33473: PUSH
33474: EMPTY
33475: LIST
33476: LIST
33477: PUSH
33478: LD_INT 2
33480: NEG
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: EMPTY
33487: LIST
33488: LIST
33489: PUSH
33490: LD_INT 2
33492: NEG
33493: PUSH
33494: LD_INT 2
33496: NEG
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 2
33504: NEG
33505: PUSH
33506: LD_INT 3
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 3
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 3
33528: NEG
33529: PUSH
33530: LD_INT 1
33532: NEG
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33575: LD_ADDR_VAR 0 29
33579: PUSH
33580: LD_INT 0
33582: PUSH
33583: LD_INT 0
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 0
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 1
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: NEG
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: LD_INT 1
33648: NEG
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: LD_INT 2
33660: NEG
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 0
33668: PUSH
33669: LD_INT 2
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 1
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 1
33710: PUSH
33711: LD_INT 2
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 2
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 1
33730: NEG
33731: PUSH
33732: LD_INT 1
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 2
33741: NEG
33742: PUSH
33743: LD_INT 1
33745: NEG
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 2
33753: NEG
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: EMPTY
33760: LIST
33761: LIST
33762: PUSH
33763: LD_INT 2
33765: NEG
33766: PUSH
33767: LD_INT 3
33769: NEG
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 2
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 3
33788: PUSH
33789: LD_INT 1
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: PUSH
33799: LD_INT 3
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: LD_INT 2
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 3
33819: NEG
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33854: LD_ADDR_VAR 0 30
33858: PUSH
33859: LD_INT 0
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 0
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 1
33882: PUSH
33883: LD_INT 0
33885: PUSH
33886: EMPTY
33887: LIST
33888: LIST
33889: PUSH
33890: LD_INT 1
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 0
33902: PUSH
33903: LD_INT 1
33905: PUSH
33906: EMPTY
33907: LIST
33908: LIST
33909: PUSH
33910: LD_INT 1
33912: NEG
33913: PUSH
33914: LD_INT 0
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: LD_INT 2
33939: NEG
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: LD_INT 2
33950: NEG
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 1
33958: PUSH
33959: LD_INT 1
33961: NEG
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 2
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 2
33979: PUSH
33980: LD_INT 1
33982: PUSH
33983: EMPTY
33984: LIST
33985: LIST
33986: PUSH
33987: LD_INT 2
33989: PUSH
33990: LD_INT 2
33992: PUSH
33993: EMPTY
33994: LIST
33995: LIST
33996: PUSH
33997: LD_INT 1
33999: PUSH
34000: LD_INT 2
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 1
34009: NEG
34010: PUSH
34011: LD_INT 1
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 2
34020: NEG
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 2
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: NEG
34044: PUSH
34045: LD_INT 3
34047: NEG
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: LD_INT 2
34058: NEG
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 3
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 2
34076: PUSH
34077: LD_INT 3
34079: PUSH
34080: EMPTY
34081: LIST
34082: LIST
34083: PUSH
34084: LD_INT 2
34086: NEG
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 3
34097: NEG
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34132: LD_ADDR_VAR 0 31
34136: PUSH
34137: LD_INT 0
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 0
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: EMPTY
34155: LIST
34156: LIST
34157: PUSH
34158: LD_INT 1
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: EMPTY
34165: LIST
34166: LIST
34167: PUSH
34168: LD_INT 1
34170: PUSH
34171: LD_INT 1
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: PUSH
34178: LD_INT 0
34180: PUSH
34181: LD_INT 1
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 1
34190: NEG
34191: PUSH
34192: LD_INT 0
34194: PUSH
34195: EMPTY
34196: LIST
34197: LIST
34198: PUSH
34199: LD_INT 1
34201: NEG
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: EMPTY
34208: LIST
34209: LIST
34210: PUSH
34211: LD_INT 1
34213: NEG
34214: PUSH
34215: LD_INT 2
34217: NEG
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 2
34236: PUSH
34237: LD_INT 0
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 2
34246: PUSH
34247: LD_INT 1
34249: PUSH
34250: EMPTY
34251: LIST
34252: LIST
34253: PUSH
34254: LD_INT 2
34256: PUSH
34257: LD_INT 2
34259: PUSH
34260: EMPTY
34261: LIST
34262: LIST
34263: PUSH
34264: LD_INT 1
34266: PUSH
34267: LD_INT 2
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: LD_INT 2
34279: PUSH
34280: EMPTY
34281: LIST
34282: LIST
34283: PUSH
34284: LD_INT 1
34286: NEG
34287: PUSH
34288: LD_INT 1
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 2
34297: NEG
34298: PUSH
34299: LD_INT 1
34301: NEG
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 2
34309: NEG
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 2
34321: NEG
34322: PUSH
34323: LD_INT 3
34325: NEG
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 2
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: EMPTY
34339: LIST
34340: LIST
34341: PUSH
34342: LD_INT 3
34344: PUSH
34345: LD_INT 1
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 3
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 1
34364: NEG
34365: PUSH
34366: LD_INT 2
34368: PUSH
34369: EMPTY
34370: LIST
34371: LIST
34372: PUSH
34373: LD_INT 3
34375: NEG
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34410: LD_ADDR_VAR 0 32
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 0
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 0
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 0
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 2
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 0
34503: PUSH
34504: LD_INT 2
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 1
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 2
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 2
34535: PUSH
34536: LD_INT 2
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: LD_INT 1
34545: PUSH
34546: LD_INT 2
34548: PUSH
34549: EMPTY
34550: LIST
34551: LIST
34552: PUSH
34553: LD_INT 0
34555: PUSH
34556: LD_INT 2
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 1
34565: NEG
34566: PUSH
34567: LD_INT 1
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: NEG
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: NEG
34588: PUSH
34589: LD_INT 1
34591: NEG
34592: PUSH
34593: EMPTY
34594: LIST
34595: LIST
34596: PUSH
34597: LD_INT 1
34599: NEG
34600: PUSH
34601: LD_INT 3
34603: NEG
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: LD_INT 2
34614: NEG
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 3
34622: PUSH
34623: LD_INT 2
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 2
34632: PUSH
34633: LD_INT 3
34635: PUSH
34636: EMPTY
34637: LIST
34638: LIST
34639: PUSH
34640: LD_INT 2
34642: NEG
34643: PUSH
34644: LD_INT 1
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 3
34653: NEG
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34688: LD_ADDR_VAR 0 33
34692: PUSH
34693: LD_INT 0
34695: PUSH
34696: LD_INT 0
34698: PUSH
34699: EMPTY
34700: LIST
34701: LIST
34702: PUSH
34703: LD_INT 0
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: EMPTY
34711: LIST
34712: LIST
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: LD_INT 0
34719: PUSH
34720: EMPTY
34721: LIST
34722: LIST
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: LD_INT 1
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: LD_INT 1
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 1
34746: NEG
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 1
34757: NEG
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: EMPTY
34764: LIST
34765: LIST
34766: PUSH
34767: LD_INT 1
34769: NEG
34770: PUSH
34771: LD_INT 2
34773: NEG
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 1
34781: PUSH
34782: LD_INT 1
34784: NEG
34785: PUSH
34786: EMPTY
34787: LIST
34788: LIST
34789: PUSH
34790: LD_INT 2
34792: PUSH
34793: LD_INT 0
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 2
34802: PUSH
34803: LD_INT 1
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: PUSH
34810: LD_INT 1
34812: PUSH
34813: LD_INT 2
34815: PUSH
34816: EMPTY
34817: LIST
34818: LIST
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: LD_INT 2
34825: PUSH
34826: EMPTY
34827: LIST
34828: LIST
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: LD_INT 1
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: LD_INT 2
34843: NEG
34844: PUSH
34845: LD_INT 0
34847: PUSH
34848: EMPTY
34849: LIST
34850: LIST
34851: PUSH
34852: LD_INT 2
34854: NEG
34855: PUSH
34856: LD_INT 1
34858: NEG
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 2
34866: NEG
34867: PUSH
34868: LD_INT 2
34870: NEG
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 2
34878: NEG
34879: PUSH
34880: LD_INT 3
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 2
34890: PUSH
34891: LD_INT 1
34893: NEG
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 3
34901: PUSH
34902: LD_INT 1
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 1
34911: PUSH
34912: LD_INT 3
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 1
34921: NEG
34922: PUSH
34923: LD_INT 2
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 3
34932: NEG
34933: PUSH
34934: LD_INT 2
34936: NEG
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: EMPTY
34943: LIST
34944: LIST
34945: LIST
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34967: LD_ADDR_VAR 0 34
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 0
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: EMPTY
34990: LIST
34991: LIST
34992: PUSH
34993: LD_INT 1
34995: PUSH
34996: LD_INT 0
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: LD_INT 1
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 1
35025: NEG
35026: PUSH
35027: LD_INT 0
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 1
35036: NEG
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: EMPTY
35043: LIST
35044: LIST
35045: PUSH
35046: LD_INT 1
35048: NEG
35049: PUSH
35050: LD_INT 2
35052: NEG
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 2
35063: NEG
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: PUSH
35069: LD_INT 1
35071: PUSH
35072: LD_INT 1
35074: NEG
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 2
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 1
35102: PUSH
35103: LD_INT 2
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: PUSH
35110: LD_INT 1
35112: NEG
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 2
35123: NEG
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 2
35134: NEG
35135: PUSH
35136: LD_INT 1
35138: NEG
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 2
35146: NEG
35147: PUSH
35148: LD_INT 2
35150: NEG
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: LD_INT 3
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: LD_INT 2
35173: NEG
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 3
35181: PUSH
35182: LD_INT 2
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 2
35191: PUSH
35192: LD_INT 3
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 2
35201: NEG
35202: PUSH
35203: LD_INT 1
35205: PUSH
35206: EMPTY
35207: LIST
35208: LIST
35209: PUSH
35210: LD_INT 3
35212: NEG
35213: PUSH
35214: LD_INT 1
35216: NEG
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: EMPTY
35223: LIST
35224: LIST
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35247: LD_ADDR_VAR 0 35
35251: PUSH
35252: LD_INT 0
35254: PUSH
35255: LD_INT 0
35257: PUSH
35258: EMPTY
35259: LIST
35260: LIST
35261: PUSH
35262: LD_INT 0
35264: PUSH
35265: LD_INT 1
35267: NEG
35268: PUSH
35269: EMPTY
35270: LIST
35271: LIST
35272: PUSH
35273: LD_INT 1
35275: PUSH
35276: LD_INT 0
35278: PUSH
35279: EMPTY
35280: LIST
35281: LIST
35282: PUSH
35283: LD_INT 1
35285: PUSH
35286: LD_INT 1
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: PUSH
35293: LD_INT 0
35295: PUSH
35296: LD_INT 1
35298: PUSH
35299: EMPTY
35300: LIST
35301: LIST
35302: PUSH
35303: LD_INT 1
35305: NEG
35306: PUSH
35307: LD_INT 0
35309: PUSH
35310: EMPTY
35311: LIST
35312: LIST
35313: PUSH
35314: LD_INT 1
35316: NEG
35317: PUSH
35318: LD_INT 1
35320: NEG
35321: PUSH
35322: EMPTY
35323: LIST
35324: LIST
35325: PUSH
35326: LD_INT 2
35328: PUSH
35329: LD_INT 1
35331: PUSH
35332: EMPTY
35333: LIST
35334: LIST
35335: PUSH
35336: LD_INT 2
35338: NEG
35339: PUSH
35340: LD_INT 1
35342: NEG
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35359: LD_ADDR_VAR 0 36
35363: PUSH
35364: LD_INT 0
35366: PUSH
35367: LD_INT 0
35369: PUSH
35370: EMPTY
35371: LIST
35372: LIST
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: EMPTY
35382: LIST
35383: LIST
35384: PUSH
35385: LD_INT 1
35387: PUSH
35388: LD_INT 0
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 1
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 0
35407: PUSH
35408: LD_INT 1
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: NEG
35418: PUSH
35419: LD_INT 0
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 1
35428: NEG
35429: PUSH
35430: LD_INT 1
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: NEG
35441: PUSH
35442: LD_INT 2
35444: NEG
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 1
35452: PUSH
35453: LD_INT 2
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35471: LD_ADDR_VAR 0 37
35475: PUSH
35476: LD_INT 0
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: EMPTY
35483: LIST
35484: LIST
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: LD_INT 0
35502: PUSH
35503: EMPTY
35504: LIST
35505: LIST
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: LD_INT 1
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 0
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: LD_INT 0
35533: PUSH
35534: EMPTY
35535: LIST
35536: LIST
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: LD_INT 1
35544: NEG
35545: PUSH
35546: EMPTY
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 1
35552: PUSH
35553: LD_INT 1
35555: NEG
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 1
35563: NEG
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: EMPTY
35569: LIST
35570: LIST
35571: PUSH
35572: EMPTY
35573: LIST
35574: LIST
35575: LIST
35576: LIST
35577: LIST
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35583: LD_ADDR_VAR 0 38
35587: PUSH
35588: LD_INT 0
35590: PUSH
35591: LD_INT 0
35593: PUSH
35594: EMPTY
35595: LIST
35596: LIST
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 1
35611: PUSH
35612: LD_INT 0
35614: PUSH
35615: EMPTY
35616: LIST
35617: LIST
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: LD_INT 1
35624: PUSH
35625: EMPTY
35626: LIST
35627: LIST
35628: PUSH
35629: LD_INT 0
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: LD_INT 1
35641: NEG
35642: PUSH
35643: LD_INT 0
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PUSH
35650: LD_INT 1
35652: NEG
35653: PUSH
35654: LD_INT 1
35656: NEG
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: PUSH
35665: LD_INT 1
35667: PUSH
35668: EMPTY
35669: LIST
35670: LIST
35671: PUSH
35672: LD_INT 2
35674: NEG
35675: PUSH
35676: LD_INT 1
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: LIST
35688: LIST
35689: LIST
35690: LIST
35691: LIST
35692: LIST
35693: LIST
35694: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35695: LD_ADDR_VAR 0 39
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: LD_INT 0
35705: PUSH
35706: EMPTY
35707: LIST
35708: LIST
35709: PUSH
35710: LD_INT 0
35712: PUSH
35713: LD_INT 1
35715: NEG
35716: PUSH
35717: EMPTY
35718: LIST
35719: LIST
35720: PUSH
35721: LD_INT 1
35723: PUSH
35724: LD_INT 0
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: LD_INT 1
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 0
35743: PUSH
35744: LD_INT 1
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: LD_INT 1
35753: NEG
35754: PUSH
35755: LD_INT 0
35757: PUSH
35758: EMPTY
35759: LIST
35760: LIST
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: LD_INT 1
35768: NEG
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: PUSH
35774: LD_INT 1
35776: NEG
35777: PUSH
35778: LD_INT 2
35780: NEG
35781: PUSH
35782: EMPTY
35783: LIST
35784: LIST
35785: PUSH
35786: LD_INT 1
35788: PUSH
35789: LD_INT 2
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: EMPTY
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35807: LD_ADDR_VAR 0 40
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: EMPTY
35830: LIST
35831: LIST
35832: PUSH
35833: LD_INT 1
35835: PUSH
35836: LD_INT 0
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: PUSH
35846: LD_INT 1
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 0
35855: PUSH
35856: LD_INT 1
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: LD_INT 1
35865: NEG
35866: PUSH
35867: LD_INT 0
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 1
35876: NEG
35877: PUSH
35878: LD_INT 1
35880: NEG
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: LD_INT 1
35891: NEG
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: LD_INT 1
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: EMPTY
35909: LIST
35910: LIST
35911: LIST
35912: LIST
35913: LIST
35914: LIST
35915: LIST
35916: LIST
35917: LIST
35918: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35919: LD_ADDR_VAR 0 41
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: LD_INT 0
35929: PUSH
35930: EMPTY
35931: LIST
35932: LIST
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: EMPTY
35942: LIST
35943: LIST
35944: PUSH
35945: LD_INT 1
35947: PUSH
35948: LD_INT 0
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 1
35957: PUSH
35958: LD_INT 1
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 0
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: LD_INT 1
35977: NEG
35978: PUSH
35979: LD_INT 0
35981: PUSH
35982: EMPTY
35983: LIST
35984: LIST
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: LD_INT 1
35992: NEG
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 2
36004: NEG
36005: PUSH
36006: EMPTY
36007: LIST
36008: LIST
36009: PUSH
36010: LD_INT 1
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 2
36023: PUSH
36024: LD_INT 0
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 2
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 2
36043: PUSH
36044: LD_INT 2
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 1
36053: PUSH
36054: LD_INT 2
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: LD_INT 1
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 2
36074: NEG
36075: PUSH
36076: LD_INT 0
36078: PUSH
36079: EMPTY
36080: LIST
36081: LIST
36082: PUSH
36083: LD_INT 2
36085: NEG
36086: PUSH
36087: LD_INT 1
36089: NEG
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 2
36097: NEG
36098: PUSH
36099: LD_INT 2
36101: NEG
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: LD_INT 3
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: PUSH
36122: LD_INT 1
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: PUSH
36133: LD_INT 0
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: PUSH
36140: LD_INT 3
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 3
36152: PUSH
36153: LD_INT 2
36155: PUSH
36156: EMPTY
36157: LIST
36158: LIST
36159: PUSH
36160: LD_INT 3
36162: PUSH
36163: LD_INT 3
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 2
36172: PUSH
36173: LD_INT 3
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PUSH
36180: LD_INT 2
36182: NEG
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: EMPTY
36188: LIST
36189: LIST
36190: PUSH
36191: LD_INT 3
36193: NEG
36194: PUSH
36195: LD_INT 0
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: PUSH
36202: LD_INT 3
36204: NEG
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 3
36216: NEG
36217: PUSH
36218: LD_INT 2
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 3
36228: NEG
36229: PUSH
36230: LD_INT 3
36232: NEG
36233: PUSH
36234: EMPTY
36235: LIST
36236: LIST
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: LIST
36246: LIST
36247: LIST
36248: LIST
36249: LIST
36250: LIST
36251: LIST
36252: LIST
36253: LIST
36254: LIST
36255: LIST
36256: LIST
36257: LIST
36258: LIST
36259: LIST
36260: LIST
36261: LIST
36262: LIST
36263: LIST
36264: LIST
36265: LIST
36266: LIST
36267: LIST
36268: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36269: LD_ADDR_VAR 0 42
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: EMPTY
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 1
36297: PUSH
36298: LD_INT 0
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 1
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: LD_INT 1
36327: NEG
36328: PUSH
36329: LD_INT 0
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 1
36338: NEG
36339: PUSH
36340: LD_INT 1
36342: NEG
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: NEG
36351: PUSH
36352: LD_INT 2
36354: NEG
36355: PUSH
36356: EMPTY
36357: LIST
36358: LIST
36359: PUSH
36360: LD_INT 0
36362: PUSH
36363: LD_INT 2
36365: NEG
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 1
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 2
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 2
36394: PUSH
36395: LD_INT 2
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 1
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 0
36414: PUSH
36415: LD_INT 2
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 1
36424: NEG
36425: PUSH
36426: LD_INT 1
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: NEG
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: NEG
36448: PUSH
36449: LD_INT 2
36451: NEG
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 2
36459: NEG
36460: PUSH
36461: LD_INT 3
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 3
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 0
36483: PUSH
36484: LD_INT 3
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: PUSH
36495: LD_INT 2
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 3
36505: PUSH
36506: LD_INT 2
36508: PUSH
36509: EMPTY
36510: LIST
36511: LIST
36512: PUSH
36513: LD_INT 3
36515: PUSH
36516: LD_INT 3
36518: PUSH
36519: EMPTY
36520: LIST
36521: LIST
36522: PUSH
36523: LD_INT 2
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PUSH
36533: LD_INT 1
36535: PUSH
36536: LD_INT 3
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 0
36545: PUSH
36546: LD_INT 3
36548: PUSH
36549: EMPTY
36550: LIST
36551: LIST
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: LD_INT 2
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: LD_INT 3
36566: NEG
36567: PUSH
36568: LD_INT 2
36570: NEG
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 3
36578: NEG
36579: PUSH
36580: LD_INT 3
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: LIST
36592: LIST
36593: LIST
36594: LIST
36595: LIST
36596: LIST
36597: LIST
36598: LIST
36599: LIST
36600: LIST
36601: LIST
36602: LIST
36603: LIST
36604: LIST
36605: LIST
36606: LIST
36607: LIST
36608: LIST
36609: LIST
36610: LIST
36611: LIST
36612: LIST
36613: LIST
36614: LIST
36615: LIST
36616: LIST
36617: LIST
36618: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36619: LD_ADDR_VAR 0 43
36623: PUSH
36624: LD_INT 0
36626: PUSH
36627: LD_INT 0
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 0
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 1
36647: PUSH
36648: LD_INT 0
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 1
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 0
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 1
36688: NEG
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: EMPTY
36695: LIST
36696: LIST
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: LD_INT 2
36704: NEG
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 0
36712: PUSH
36713: LD_INT 2
36715: NEG
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 1
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 2
36734: PUSH
36735: LD_INT 0
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 2
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: EMPTY
36749: LIST
36750: LIST
36751: PUSH
36752: LD_INT 1
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 1
36774: NEG
36775: PUSH
36776: LD_INT 1
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 2
36785: NEG
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: NEG
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 1
36808: NEG
36809: PUSH
36810: LD_INT 3
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 0
36820: PUSH
36821: LD_INT 3
36823: NEG
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 1
36831: PUSH
36832: LD_INT 2
36834: NEG
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 2
36842: PUSH
36843: LD_INT 1
36845: NEG
36846: PUSH
36847: EMPTY
36848: LIST
36849: LIST
36850: PUSH
36851: LD_INT 3
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 3
36863: PUSH
36864: LD_INT 1
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: PUSH
36874: LD_INT 3
36876: PUSH
36877: EMPTY
36878: LIST
36879: LIST
36880: PUSH
36881: LD_INT 0
36883: PUSH
36884: LD_INT 3
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 1
36893: NEG
36894: PUSH
36895: LD_INT 2
36897: PUSH
36898: EMPTY
36899: LIST
36900: LIST
36901: PUSH
36902: LD_INT 2
36904: NEG
36905: PUSH
36906: LD_INT 1
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 3
36915: NEG
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 3
36926: NEG
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: EMPTY
36933: LIST
36934: LIST
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: LIST
36948: LIST
36949: LIST
36950: LIST
36951: LIST
36952: LIST
36953: LIST
36954: LIST
36955: LIST
36956: LIST
36957: LIST
36958: LIST
36959: LIST
36960: LIST
36961: LIST
36962: LIST
36963: LIST
36964: LIST
36965: LIST
36966: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36967: LD_ADDR_VAR 0 44
36971: PUSH
36972: LD_INT 0
36974: PUSH
36975: LD_INT 0
36977: PUSH
36978: EMPTY
36979: LIST
36980: LIST
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: LD_INT 1
36987: NEG
36988: PUSH
36989: EMPTY
36990: LIST
36991: LIST
36992: PUSH
36993: LD_INT 1
36995: PUSH
36996: LD_INT 0
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: PUSH
37006: LD_INT 1
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 0
37015: PUSH
37016: LD_INT 1
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: LD_INT 1
37025: NEG
37026: PUSH
37027: LD_INT 0
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: NEG
37037: PUSH
37038: LD_INT 1
37040: NEG
37041: PUSH
37042: EMPTY
37043: LIST
37044: LIST
37045: PUSH
37046: LD_INT 1
37048: NEG
37049: PUSH
37050: LD_INT 2
37052: NEG
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: PUSH
37061: LD_INT 1
37063: NEG
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 2
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: EMPTY
37076: LIST
37077: LIST
37078: PUSH
37079: LD_INT 2
37081: PUSH
37082: LD_INT 1
37084: PUSH
37085: EMPTY
37086: LIST
37087: LIST
37088: PUSH
37089: LD_INT 2
37091: PUSH
37092: LD_INT 2
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PUSH
37099: LD_INT 1
37101: PUSH
37102: LD_INT 2
37104: PUSH
37105: EMPTY
37106: LIST
37107: LIST
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 2
37122: NEG
37123: PUSH
37124: LD_INT 0
37126: PUSH
37127: EMPTY
37128: LIST
37129: LIST
37130: PUSH
37131: LD_INT 2
37133: NEG
37134: PUSH
37135: LD_INT 1
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 2
37145: NEG
37146: PUSH
37147: LD_INT 2
37149: NEG
37150: PUSH
37151: EMPTY
37152: LIST
37153: LIST
37154: PUSH
37155: LD_INT 2
37157: NEG
37158: PUSH
37159: LD_INT 3
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: LD_INT 1
37172: NEG
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 3
37190: PUSH
37191: LD_INT 1
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 3
37200: PUSH
37201: LD_INT 2
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 3
37210: PUSH
37211: LD_INT 3
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 2
37220: PUSH
37221: LD_INT 3
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 2
37230: NEG
37231: PUSH
37232: LD_INT 1
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 3
37241: NEG
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 3
37264: NEG
37265: PUSH
37266: LD_INT 2
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 3
37276: NEG
37277: PUSH
37278: LD_INT 3
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: LIST
37290: LIST
37291: LIST
37292: LIST
37293: LIST
37294: LIST
37295: LIST
37296: LIST
37297: LIST
37298: LIST
37299: LIST
37300: LIST
37301: LIST
37302: LIST
37303: LIST
37304: LIST
37305: LIST
37306: LIST
37307: LIST
37308: LIST
37309: LIST
37310: LIST
37311: LIST
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37317: LD_ADDR_VAR 0 45
37321: PUSH
37322: LD_INT 0
37324: PUSH
37325: LD_INT 0
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 0
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: EMPTY
37340: LIST
37341: LIST
37342: PUSH
37343: LD_INT 1
37345: PUSH
37346: LD_INT 0
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: LD_INT 1
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 0
37365: PUSH
37366: LD_INT 1
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: LD_INT 1
37375: NEG
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 1
37386: NEG
37387: PUSH
37388: LD_INT 1
37390: NEG
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: NEG
37399: PUSH
37400: LD_INT 2
37402: NEG
37403: PUSH
37404: EMPTY
37405: LIST
37406: LIST
37407: PUSH
37408: LD_INT 0
37410: PUSH
37411: LD_INT 2
37413: NEG
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 1
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 2
37432: PUSH
37433: LD_INT 1
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 2
37442: PUSH
37443: LD_INT 2
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 1
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 0
37462: PUSH
37463: LD_INT 2
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: LD_INT 1
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 2
37483: NEG
37484: PUSH
37485: LD_INT 1
37487: NEG
37488: PUSH
37489: EMPTY
37490: LIST
37491: LIST
37492: PUSH
37493: LD_INT 2
37495: NEG
37496: PUSH
37497: LD_INT 2
37499: NEG
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 2
37507: NEG
37508: PUSH
37509: LD_INT 3
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: NEG
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: PUSH
37543: LD_INT 2
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: PUSH
37554: LD_INT 2
37556: PUSH
37557: EMPTY
37558: LIST
37559: LIST
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: LD_INT 3
37566: PUSH
37567: EMPTY
37568: LIST
37569: LIST
37570: PUSH
37571: LD_INT 2
37573: PUSH
37574: LD_INT 3
37576: PUSH
37577: EMPTY
37578: LIST
37579: LIST
37580: PUSH
37581: LD_INT 1
37583: PUSH
37584: LD_INT 3
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 0
37593: PUSH
37594: LD_INT 3
37596: PUSH
37597: EMPTY
37598: LIST
37599: LIST
37600: PUSH
37601: LD_INT 1
37603: NEG
37604: PUSH
37605: LD_INT 2
37607: PUSH
37608: EMPTY
37609: LIST
37610: LIST
37611: PUSH
37612: LD_INT 3
37614: NEG
37615: PUSH
37616: LD_INT 2
37618: NEG
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: PUSH
37624: LD_INT 3
37626: NEG
37627: PUSH
37628: LD_INT 3
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: LIST
37643: LIST
37644: LIST
37645: LIST
37646: LIST
37647: LIST
37648: LIST
37649: LIST
37650: LIST
37651: LIST
37652: LIST
37653: LIST
37654: LIST
37655: LIST
37656: LIST
37657: LIST
37658: LIST
37659: LIST
37660: LIST
37661: LIST
37662: LIST
37663: LIST
37664: LIST
37665: LIST
37666: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37667: LD_ADDR_VAR 0 46
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: LD_INT 0
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 0
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 1
37695: PUSH
37696: LD_INT 0
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 1
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 0
37715: PUSH
37716: LD_INT 1
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 1
37725: NEG
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: NEG
37737: PUSH
37738: LD_INT 1
37740: NEG
37741: PUSH
37742: EMPTY
37743: LIST
37744: LIST
37745: PUSH
37746: LD_INT 1
37748: NEG
37749: PUSH
37750: LD_INT 2
37752: NEG
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 0
37760: PUSH
37761: LD_INT 2
37763: NEG
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 1
37771: PUSH
37772: LD_INT 1
37774: NEG
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: PUSH
37783: LD_INT 0
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 2
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: EMPTY
37797: LIST
37798: LIST
37799: PUSH
37800: LD_INT 1
37802: PUSH
37803: LD_INT 2
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: LD_INT 2
37815: PUSH
37816: EMPTY
37817: LIST
37818: LIST
37819: PUSH
37820: LD_INT 1
37822: NEG
37823: PUSH
37824: LD_INT 1
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 0
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 2
37844: NEG
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: NEG
37857: PUSH
37858: LD_INT 3
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: LD_INT 0
37868: PUSH
37869: LD_INT 3
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 1
37879: PUSH
37880: LD_INT 2
37882: NEG
37883: PUSH
37884: EMPTY
37885: LIST
37886: LIST
37887: PUSH
37888: LD_INT 2
37890: PUSH
37891: LD_INT 1
37893: NEG
37894: PUSH
37895: EMPTY
37896: LIST
37897: LIST
37898: PUSH
37899: LD_INT 3
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 3
37911: PUSH
37912: LD_INT 1
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: PUSH
37922: LD_INT 3
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 0
37931: PUSH
37932: LD_INT 3
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 2
37945: PUSH
37946: EMPTY
37947: LIST
37948: LIST
37949: PUSH
37950: LD_INT 2
37952: NEG
37953: PUSH
37954: LD_INT 1
37956: PUSH
37957: EMPTY
37958: LIST
37959: LIST
37960: PUSH
37961: LD_INT 3
37963: NEG
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: EMPTY
37969: LIST
37970: LIST
37971: PUSH
37972: LD_INT 3
37974: NEG
37975: PUSH
37976: LD_INT 1
37978: NEG
37979: PUSH
37980: EMPTY
37981: LIST
37982: LIST
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: LIST
37997: LIST
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: LIST
38008: LIST
38009: LIST
38010: LIST
38011: LIST
38012: LIST
38013: LIST
38014: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38015: LD_ADDR_VAR 0 47
38019: PUSH
38020: LD_INT 0
38022: PUSH
38023: LD_INT 0
38025: PUSH
38026: EMPTY
38027: LIST
38028: LIST
38029: PUSH
38030: LD_INT 0
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: EMPTY
38038: LIST
38039: LIST
38040: PUSH
38041: LD_INT 1
38043: PUSH
38044: LD_INT 0
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 1
38053: PUSH
38054: LD_INT 1
38056: PUSH
38057: EMPTY
38058: LIST
38059: LIST
38060: PUSH
38061: LD_INT 0
38063: PUSH
38064: LD_INT 1
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: LD_INT 0
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: NEG
38085: PUSH
38086: LD_INT 1
38088: NEG
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 1
38096: NEG
38097: PUSH
38098: LD_INT 2
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 0
38108: PUSH
38109: LD_INT 2
38111: NEG
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: PUSH
38120: LD_INT 1
38122: NEG
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 2
38130: NEG
38131: PUSH
38132: LD_INT 1
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 2
38142: NEG
38143: PUSH
38144: LD_INT 2
38146: NEG
38147: PUSH
38148: EMPTY
38149: LIST
38150: LIST
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: LIST
38158: LIST
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: LIST
38164: LIST
38165: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38166: LD_ADDR_VAR 0 48
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 0
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 0
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 1
38194: PUSH
38195: LD_INT 0
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: LD_INT 1
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: NEG
38225: PUSH
38226: LD_INT 0
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 1
38235: NEG
38236: PUSH
38237: LD_INT 1
38239: NEG
38240: PUSH
38241: EMPTY
38242: LIST
38243: LIST
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: LD_INT 2
38251: NEG
38252: PUSH
38253: EMPTY
38254: LIST
38255: LIST
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: LD_INT 2
38262: NEG
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 1
38270: PUSH
38271: LD_INT 1
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 2
38281: PUSH
38282: LD_INT 0
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 2
38291: PUSH
38292: LD_INT 1
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38313: LD_ADDR_VAR 0 49
38317: PUSH
38318: LD_INT 0
38320: PUSH
38321: LD_INT 0
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: PUSH
38328: LD_INT 0
38330: PUSH
38331: LD_INT 1
38333: NEG
38334: PUSH
38335: EMPTY
38336: LIST
38337: LIST
38338: PUSH
38339: LD_INT 1
38341: PUSH
38342: LD_INT 0
38344: PUSH
38345: EMPTY
38346: LIST
38347: LIST
38348: PUSH
38349: LD_INT 1
38351: PUSH
38352: LD_INT 1
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: LD_INT 1
38364: PUSH
38365: EMPTY
38366: LIST
38367: LIST
38368: PUSH
38369: LD_INT 1
38371: NEG
38372: PUSH
38373: LD_INT 0
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 1
38382: NEG
38383: PUSH
38384: LD_INT 1
38386: NEG
38387: PUSH
38388: EMPTY
38389: LIST
38390: LIST
38391: PUSH
38392: LD_INT 1
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: EMPTY
38400: LIST
38401: LIST
38402: PUSH
38403: LD_INT 2
38405: PUSH
38406: LD_INT 0
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 2
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: LD_INT 2
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 1
38435: PUSH
38436: LD_INT 2
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: LIST
38456: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38457: LD_ADDR_VAR 0 50
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 0
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 2
38538: PUSH
38539: LD_INT 1
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 2
38548: PUSH
38549: LD_INT 2
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 2
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: LD_INT 2
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 1
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: LIST
38595: LIST
38596: LIST
38597: LIST
38598: LIST
38599: LIST
38600: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38601: LD_ADDR_VAR 0 51
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 0
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: LD_INT 0
38618: PUSH
38619: LD_INT 1
38621: NEG
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 1
38629: PUSH
38630: LD_INT 0
38632: PUSH
38633: EMPTY
38634: LIST
38635: LIST
38636: PUSH
38637: LD_INT 1
38639: PUSH
38640: LD_INT 1
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 0
38649: PUSH
38650: LD_INT 1
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: LD_INT 1
38659: NEG
38660: PUSH
38661: LD_INT 0
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: LD_INT 1
38674: NEG
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 1
38682: PUSH
38683: LD_INT 2
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: LD_INT 2
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 1
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 2
38713: NEG
38714: PUSH
38715: LD_INT 0
38717: PUSH
38718: EMPTY
38719: LIST
38720: LIST
38721: PUSH
38722: LD_INT 2
38724: NEG
38725: PUSH
38726: LD_INT 1
38728: NEG
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: LIST
38745: LIST
38746: LIST
38747: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38748: LD_ADDR_VAR 0 52
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: LD_INT 0
38758: PUSH
38759: EMPTY
38760: LIST
38761: LIST
38762: PUSH
38763: LD_INT 0
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: EMPTY
38771: LIST
38772: LIST
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: LD_INT 1
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 0
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: LD_INT 1
38806: NEG
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 1
38817: NEG
38818: PUSH
38819: LD_INT 1
38821: NEG
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 1
38829: NEG
38830: PUSH
38831: LD_INT 2
38833: NEG
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: LD_INT 1
38841: NEG
38842: PUSH
38843: LD_INT 1
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 2
38852: NEG
38853: PUSH
38854: LD_INT 0
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 2
38863: NEG
38864: PUSH
38865: LD_INT 1
38867: NEG
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 2
38875: NEG
38876: PUSH
38877: LD_INT 2
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38899: LD_ADDR_VAR 0 53
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 0
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 0
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: PUSH
38928: LD_INT 0
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 0
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 1
38957: NEG
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 1
38968: NEG
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: LD_INT 2
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: LD_INT 0
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: LD_INT 1
39006: NEG
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: LD_INT 0
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: LD_INT 1
39027: PUSH
39028: EMPTY
39029: LIST
39030: LIST
39031: PUSH
39032: LD_INT 2
39034: PUSH
39035: LD_INT 2
39037: PUSH
39038: EMPTY
39039: LIST
39040: LIST
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: LD_INT 2
39047: PUSH
39048: EMPTY
39049: LIST
39050: LIST
39051: PUSH
39052: LD_INT 0
39054: PUSH
39055: LD_INT 2
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 1
39064: NEG
39065: PUSH
39066: LD_INT 1
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: LD_INT 2
39075: NEG
39076: PUSH
39077: LD_INT 0
39079: PUSH
39080: EMPTY
39081: LIST
39082: LIST
39083: PUSH
39084: LD_INT 2
39086: NEG
39087: PUSH
39088: LD_INT 1
39090: NEG
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: PUSH
39096: LD_INT 2
39098: NEG
39099: PUSH
39100: LD_INT 2
39102: NEG
39103: PUSH
39104: EMPTY
39105: LIST
39106: LIST
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: LIST
39112: LIST
39113: LIST
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: LIST
39122: LIST
39123: LIST
39124: LIST
39125: LIST
39126: LIST
39127: LIST
39128: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39129: LD_ADDR_VAR 0 54
39133: PUSH
39134: LD_INT 0
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 1
39167: PUSH
39168: LD_INT 1
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: LD_INT 1
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: NEG
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 1
39198: NEG
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 1
39210: NEG
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: LD_INT 0
39222: PUSH
39223: LD_INT 2
39225: NEG
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: PUSH
39234: LD_INT 1
39236: NEG
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: LD_INT 1
39257: PUSH
39258: EMPTY
39259: LIST
39260: LIST
39261: PUSH
39262: LD_INT 2
39264: PUSH
39265: LD_INT 2
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 1
39274: PUSH
39275: LD_INT 2
39277: PUSH
39278: EMPTY
39279: LIST
39280: LIST
39281: PUSH
39282: LD_INT 0
39284: PUSH
39285: LD_INT 2
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: PUSH
39292: LD_INT 1
39294: NEG
39295: PUSH
39296: LD_INT 1
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 2
39305: NEG
39306: PUSH
39307: LD_INT 0
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 2
39316: NEG
39317: PUSH
39318: LD_INT 1
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 2
39328: NEG
39329: PUSH
39330: LD_INT 2
39332: NEG
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: EMPTY
39339: LIST
39340: LIST
39341: LIST
39342: LIST
39343: LIST
39344: LIST
39345: LIST
39346: LIST
39347: LIST
39348: LIST
39349: LIST
39350: LIST
39351: LIST
39352: LIST
39353: LIST
39354: LIST
39355: LIST
39356: LIST
39357: LIST
39358: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39359: LD_ADDR_VAR 0 55
39363: PUSH
39364: LD_INT 0
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 0
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: EMPTY
39382: LIST
39383: LIST
39384: PUSH
39385: LD_INT 1
39387: PUSH
39388: LD_INT 0
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PUSH
39395: LD_INT 1
39397: PUSH
39398: LD_INT 1
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 0
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 1
39417: NEG
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 1
39428: NEG
39429: PUSH
39430: LD_INT 1
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 1
39440: NEG
39441: PUSH
39442: LD_INT 2
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: LD_INT 2
39455: NEG
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: LD_INT 0
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 2
39484: PUSH
39485: LD_INT 1
39487: PUSH
39488: EMPTY
39489: LIST
39490: LIST
39491: PUSH
39492: LD_INT 2
39494: PUSH
39495: LD_INT 2
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 1
39504: PUSH
39505: LD_INT 2
39507: PUSH
39508: EMPTY
39509: LIST
39510: LIST
39511: PUSH
39512: LD_INT 0
39514: PUSH
39515: LD_INT 2
39517: PUSH
39518: EMPTY
39519: LIST
39520: LIST
39521: PUSH
39522: LD_INT 1
39524: NEG
39525: PUSH
39526: LD_INT 1
39528: PUSH
39529: EMPTY
39530: LIST
39531: LIST
39532: PUSH
39533: LD_INT 2
39535: NEG
39536: PUSH
39537: LD_INT 0
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 2
39546: NEG
39547: PUSH
39548: LD_INT 1
39550: NEG
39551: PUSH
39552: EMPTY
39553: LIST
39554: LIST
39555: PUSH
39556: LD_INT 2
39558: NEG
39559: PUSH
39560: LD_INT 2
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: EMPTY
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: LIST
39574: LIST
39575: LIST
39576: LIST
39577: LIST
39578: LIST
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: LIST
39587: LIST
39588: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39589: LD_ADDR_VAR 0 56
39593: PUSH
39594: LD_INT 0
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 0
39606: PUSH
39607: LD_INT 1
39609: NEG
39610: PUSH
39611: EMPTY
39612: LIST
39613: LIST
39614: PUSH
39615: LD_INT 1
39617: PUSH
39618: LD_INT 0
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 1
39627: PUSH
39628: LD_INT 1
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 0
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 1
39647: NEG
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 1
39670: NEG
39671: PUSH
39672: LD_INT 2
39674: NEG
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 2
39685: NEG
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: PUSH
39694: LD_INT 1
39696: NEG
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 2
39724: PUSH
39725: LD_INT 2
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 1
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: EMPTY
39739: LIST
39740: LIST
39741: PUSH
39742: LD_INT 0
39744: PUSH
39745: LD_INT 2
39747: PUSH
39748: EMPTY
39749: LIST
39750: LIST
39751: PUSH
39752: LD_INT 1
39754: NEG
39755: PUSH
39756: LD_INT 1
39758: PUSH
39759: EMPTY
39760: LIST
39761: LIST
39762: PUSH
39763: LD_INT 2
39765: NEG
39766: PUSH
39767: LD_INT 0
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 2
39776: NEG
39777: PUSH
39778: LD_INT 1
39780: NEG
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 2
39788: NEG
39789: PUSH
39790: LD_INT 2
39792: NEG
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: EMPTY
39799: LIST
39800: LIST
39801: LIST
39802: LIST
39803: LIST
39804: LIST
39805: LIST
39806: LIST
39807: LIST
39808: LIST
39809: LIST
39810: LIST
39811: LIST
39812: LIST
39813: LIST
39814: LIST
39815: LIST
39816: LIST
39817: LIST
39818: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39819: LD_ADDR_VAR 0 57
39823: PUSH
39824: LD_INT 0
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: EMPTY
39842: LIST
39843: LIST
39844: PUSH
39845: LD_INT 1
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 1
39857: PUSH
39858: LD_INT 1
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 0
39867: PUSH
39868: LD_INT 1
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 1
39877: NEG
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 1
39900: NEG
39901: PUSH
39902: LD_INT 2
39904: NEG
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 0
39912: PUSH
39913: LD_INT 2
39915: NEG
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 1
39923: PUSH
39924: LD_INT 1
39926: NEG
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: LD_INT 0
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 2
39944: PUSH
39945: LD_INT 1
39947: PUSH
39948: EMPTY
39949: LIST
39950: LIST
39951: PUSH
39952: LD_INT 2
39954: PUSH
39955: LD_INT 2
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 1
39964: PUSH
39965: LD_INT 2
39967: PUSH
39968: EMPTY
39969: LIST
39970: LIST
39971: PUSH
39972: LD_INT 0
39974: PUSH
39975: LD_INT 2
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: LD_INT 1
39984: NEG
39985: PUSH
39986: LD_INT 1
39988: PUSH
39989: EMPTY
39990: LIST
39991: LIST
39992: PUSH
39993: LD_INT 2
39995: NEG
39996: PUSH
39997: LD_INT 0
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: NEG
40007: PUSH
40008: LD_INT 1
40010: NEG
40011: PUSH
40012: EMPTY
40013: LIST
40014: LIST
40015: PUSH
40016: LD_INT 2
40018: NEG
40019: PUSH
40020: LD_INT 2
40022: NEG
40023: PUSH
40024: EMPTY
40025: LIST
40026: LIST
40027: PUSH
40028: EMPTY
40029: LIST
40030: LIST
40031: LIST
40032: LIST
40033: LIST
40034: LIST
40035: LIST
40036: LIST
40037: LIST
40038: LIST
40039: LIST
40040: LIST
40041: LIST
40042: LIST
40043: LIST
40044: LIST
40045: LIST
40046: LIST
40047: LIST
40048: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40049: LD_ADDR_VAR 0 58
40053: PUSH
40054: LD_INT 0
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 1
40077: PUSH
40078: LD_INT 0
40080: PUSH
40081: EMPTY
40082: LIST
40083: LIST
40084: PUSH
40085: LD_INT 1
40087: PUSH
40088: LD_INT 1
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: LD_INT 0
40097: PUSH
40098: LD_INT 1
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: NEG
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 1
40130: NEG
40131: PUSH
40132: LD_INT 2
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: LD_INT 2
40145: NEG
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 1
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: PUSH
40165: LD_INT 0
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 2
40174: PUSH
40175: LD_INT 1
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 2
40184: PUSH
40185: LD_INT 2
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 1
40194: PUSH
40195: LD_INT 2
40197: PUSH
40198: EMPTY
40199: LIST
40200: LIST
40201: PUSH
40202: LD_INT 0
40204: PUSH
40205: LD_INT 2
40207: PUSH
40208: EMPTY
40209: LIST
40210: LIST
40211: PUSH
40212: LD_INT 1
40214: NEG
40215: PUSH
40216: LD_INT 1
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 2
40225: NEG
40226: PUSH
40227: LD_INT 0
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 2
40236: NEG
40237: PUSH
40238: LD_INT 1
40240: NEG
40241: PUSH
40242: EMPTY
40243: LIST
40244: LIST
40245: PUSH
40246: LD_INT 2
40248: NEG
40249: PUSH
40250: LD_INT 2
40252: NEG
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: LIST
40272: LIST
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40279: LD_ADDR_VAR 0 59
40283: PUSH
40284: LD_INT 0
40286: PUSH
40287: LD_INT 0
40289: PUSH
40290: EMPTY
40291: LIST
40292: LIST
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: PUSH
40308: LD_INT 0
40310: PUSH
40311: EMPTY
40312: LIST
40313: LIST
40314: PUSH
40315: LD_INT 1
40317: PUSH
40318: LD_INT 1
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: LD_INT 0
40327: PUSH
40328: LD_INT 1
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PUSH
40335: LD_INT 1
40337: NEG
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 1
40348: NEG
40349: PUSH
40350: LD_INT 1
40352: NEG
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40367: LD_ADDR_VAR 0 60
40371: PUSH
40372: LD_INT 0
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 0
40384: PUSH
40385: LD_INT 1
40387: NEG
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 1
40395: PUSH
40396: LD_INT 0
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 1
40405: PUSH
40406: LD_INT 1
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 0
40415: PUSH
40416: LD_INT 1
40418: PUSH
40419: EMPTY
40420: LIST
40421: LIST
40422: PUSH
40423: LD_INT 1
40425: NEG
40426: PUSH
40427: LD_INT 0
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: PUSH
40434: LD_INT 1
40436: NEG
40437: PUSH
40438: LD_INT 1
40440: NEG
40441: PUSH
40442: EMPTY
40443: LIST
40444: LIST
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40455: LD_ADDR_VAR 0 61
40459: PUSH
40460: LD_INT 0
40462: PUSH
40463: LD_INT 0
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 0
40472: PUSH
40473: LD_INT 1
40475: NEG
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 1
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 0
40503: PUSH
40504: LD_INT 1
40506: PUSH
40507: EMPTY
40508: LIST
40509: LIST
40510: PUSH
40511: LD_INT 1
40513: NEG
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: LD_INT 1
40528: NEG
40529: PUSH
40530: EMPTY
40531: LIST
40532: LIST
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40543: LD_ADDR_VAR 0 62
40547: PUSH
40548: LD_INT 0
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 0
40560: PUSH
40561: LD_INT 1
40563: NEG
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: PUSH
40572: LD_INT 0
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 1
40581: PUSH
40582: LD_INT 1
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 0
40591: PUSH
40592: LD_INT 1
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 1
40601: NEG
40602: PUSH
40603: LD_INT 0
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 1
40612: NEG
40613: PUSH
40614: LD_INT 1
40616: NEG
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40631: LD_ADDR_VAR 0 63
40635: PUSH
40636: LD_INT 0
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 0
40648: PUSH
40649: LD_INT 1
40651: NEG
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: PUSH
40660: LD_INT 0
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 1
40669: PUSH
40670: LD_INT 1
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 1
40689: NEG
40690: PUSH
40691: LD_INT 0
40693: PUSH
40694: EMPTY
40695: LIST
40696: LIST
40697: PUSH
40698: LD_INT 1
40700: NEG
40701: PUSH
40702: LD_INT 1
40704: NEG
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: LIST
40714: LIST
40715: LIST
40716: LIST
40717: LIST
40718: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40719: LD_ADDR_VAR 0 64
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 0
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 1
40747: PUSH
40748: LD_INT 0
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 1
40757: PUSH
40758: LD_INT 1
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: LD_INT 1
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 1
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: ST_TO_ADDR
// end ; 1 :
40807: GO 46704
40809: LD_INT 1
40811: DOUBLE
40812: EQUAL
40813: IFTRUE 40817
40815: GO 43440
40817: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40818: LD_ADDR_VAR 0 11
40822: PUSH
40823: LD_INT 1
40825: NEG
40826: PUSH
40827: LD_INT 3
40829: NEG
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: LD_INT 3
40840: NEG
40841: PUSH
40842: EMPTY
40843: LIST
40844: LIST
40845: PUSH
40846: LD_INT 1
40848: PUSH
40849: LD_INT 2
40851: NEG
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: LIST
40861: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40862: LD_ADDR_VAR 0 12
40866: PUSH
40867: LD_INT 2
40869: PUSH
40870: LD_INT 1
40872: NEG
40873: PUSH
40874: EMPTY
40875: LIST
40876: LIST
40877: PUSH
40878: LD_INT 3
40880: PUSH
40881: LD_INT 0
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 3
40890: PUSH
40891: LD_INT 1
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: LIST
40902: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40903: LD_ADDR_VAR 0 13
40907: PUSH
40908: LD_INT 3
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 3
40920: PUSH
40921: LD_INT 3
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: LD_INT 3
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: EMPTY
40939: LIST
40940: LIST
40941: LIST
40942: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40943: LD_ADDR_VAR 0 14
40947: PUSH
40948: LD_INT 1
40950: PUSH
40951: LD_INT 3
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 0
40960: PUSH
40961: LD_INT 3
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 1
40970: NEG
40971: PUSH
40972: LD_INT 2
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: LIST
40983: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40984: LD_ADDR_VAR 0 15
40988: PUSH
40989: LD_INT 2
40991: NEG
40992: PUSH
40993: LD_INT 1
40995: PUSH
40996: EMPTY
40997: LIST
40998: LIST
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: LD_INT 0
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 3
41013: NEG
41014: PUSH
41015: LD_INT 1
41017: NEG
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: LIST
41027: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41028: LD_ADDR_VAR 0 16
41032: PUSH
41033: LD_INT 2
41035: NEG
41036: PUSH
41037: LD_INT 3
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: NEG
41048: PUSH
41049: LD_INT 2
41051: NEG
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 3
41059: NEG
41060: PUSH
41061: LD_INT 3
41063: NEG
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: LIST
41073: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41074: LD_ADDR_VAR 0 17
41078: PUSH
41079: LD_INT 1
41081: NEG
41082: PUSH
41083: LD_INT 3
41085: NEG
41086: PUSH
41087: EMPTY
41088: LIST
41089: LIST
41090: PUSH
41091: LD_INT 0
41093: PUSH
41094: LD_INT 3
41096: NEG
41097: PUSH
41098: EMPTY
41099: LIST
41100: LIST
41101: PUSH
41102: LD_INT 1
41104: PUSH
41105: LD_INT 2
41107: NEG
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: LIST
41117: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41118: LD_ADDR_VAR 0 18
41122: PUSH
41123: LD_INT 2
41125: PUSH
41126: LD_INT 1
41128: NEG
41129: PUSH
41130: EMPTY
41131: LIST
41132: LIST
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 0
41139: PUSH
41140: EMPTY
41141: LIST
41142: LIST
41143: PUSH
41144: LD_INT 3
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: EMPTY
41151: LIST
41152: LIST
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: LIST
41158: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41159: LD_ADDR_VAR 0 19
41163: PUSH
41164: LD_INT 3
41166: PUSH
41167: LD_INT 2
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: LD_INT 3
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: PUSH
41184: LD_INT 2
41186: PUSH
41187: LD_INT 3
41189: PUSH
41190: EMPTY
41191: LIST
41192: LIST
41193: PUSH
41194: EMPTY
41195: LIST
41196: LIST
41197: LIST
41198: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41199: LD_ADDR_VAR 0 20
41203: PUSH
41204: LD_INT 1
41206: PUSH
41207: LD_INT 3
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 0
41216: PUSH
41217: LD_INT 3
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: PUSH
41224: LD_INT 1
41226: NEG
41227: PUSH
41228: LD_INT 2
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41240: LD_ADDR_VAR 0 21
41244: PUSH
41245: LD_INT 2
41247: NEG
41248: PUSH
41249: LD_INT 1
41251: PUSH
41252: EMPTY
41253: LIST
41254: LIST
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: LD_INT 0
41262: PUSH
41263: EMPTY
41264: LIST
41265: LIST
41266: PUSH
41267: LD_INT 3
41269: NEG
41270: PUSH
41271: LD_INT 1
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: LIST
41283: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41284: LD_ADDR_VAR 0 22
41288: PUSH
41289: LD_INT 2
41291: NEG
41292: PUSH
41293: LD_INT 3
41295: NEG
41296: PUSH
41297: EMPTY
41298: LIST
41299: LIST
41300: PUSH
41301: LD_INT 3
41303: NEG
41304: PUSH
41305: LD_INT 2
41307: NEG
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: PUSH
41313: LD_INT 3
41315: NEG
41316: PUSH
41317: LD_INT 3
41319: NEG
41320: PUSH
41321: EMPTY
41322: LIST
41323: LIST
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: LIST
41329: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41330: LD_ADDR_VAR 0 23
41334: PUSH
41335: LD_INT 0
41337: PUSH
41338: LD_INT 3
41340: NEG
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: LD_INT 1
41348: NEG
41349: PUSH
41350: LD_INT 4
41352: NEG
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 1
41360: PUSH
41361: LD_INT 3
41363: NEG
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: LIST
41373: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41374: LD_ADDR_VAR 0 24
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 0
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: LD_INT 3
41391: PUSH
41392: LD_INT 1
41394: NEG
41395: PUSH
41396: EMPTY
41397: LIST
41398: LIST
41399: PUSH
41400: LD_INT 4
41402: PUSH
41403: LD_INT 1
41405: PUSH
41406: EMPTY
41407: LIST
41408: LIST
41409: PUSH
41410: EMPTY
41411: LIST
41412: LIST
41413: LIST
41414: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41415: LD_ADDR_VAR 0 25
41419: PUSH
41420: LD_INT 3
41422: PUSH
41423: LD_INT 3
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 4
41432: PUSH
41433: LD_INT 3
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: PUSH
41440: LD_INT 3
41442: PUSH
41443: LD_INT 4
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PUSH
41450: EMPTY
41451: LIST
41452: LIST
41453: LIST
41454: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41455: LD_ADDR_VAR 0 26
41459: PUSH
41460: LD_INT 0
41462: PUSH
41463: LD_INT 3
41465: PUSH
41466: EMPTY
41467: LIST
41468: LIST
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: LD_INT 4
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: PUSH
41480: LD_INT 1
41482: NEG
41483: PUSH
41484: LD_INT 3
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: LIST
41495: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41496: LD_ADDR_VAR 0 27
41500: PUSH
41501: LD_INT 3
41503: NEG
41504: PUSH
41505: LD_INT 0
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: LD_INT 1
41518: PUSH
41519: EMPTY
41520: LIST
41521: LIST
41522: PUSH
41523: LD_INT 4
41525: NEG
41526: PUSH
41527: LD_INT 1
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: LIST
41539: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41540: LD_ADDR_VAR 0 28
41544: PUSH
41545: LD_INT 3
41547: NEG
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 3
41559: NEG
41560: PUSH
41561: LD_INT 4
41563: NEG
41564: PUSH
41565: EMPTY
41566: LIST
41567: LIST
41568: PUSH
41569: LD_INT 4
41571: NEG
41572: PUSH
41573: LD_INT 3
41575: NEG
41576: PUSH
41577: EMPTY
41578: LIST
41579: LIST
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: LIST
41585: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41586: LD_ADDR_VAR 0 29
41590: PUSH
41591: LD_INT 1
41593: NEG
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: LD_INT 3
41608: NEG
41609: PUSH
41610: EMPTY
41611: LIST
41612: LIST
41613: PUSH
41614: LD_INT 1
41616: PUSH
41617: LD_INT 2
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 1
41627: NEG
41628: PUSH
41629: LD_INT 4
41631: NEG
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: LD_INT 0
41639: PUSH
41640: LD_INT 4
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: LD_INT 1
41650: PUSH
41651: LD_INT 3
41653: NEG
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 1
41661: NEG
41662: PUSH
41663: LD_INT 5
41665: NEG
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 0
41673: PUSH
41674: LD_INT 5
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 1
41684: PUSH
41685: LD_INT 4
41687: NEG
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: LD_INT 6
41699: NEG
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: PUSH
41705: LD_INT 0
41707: PUSH
41708: LD_INT 6
41710: NEG
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: LD_INT 5
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: LIST
41731: LIST
41732: LIST
41733: LIST
41734: LIST
41735: LIST
41736: LIST
41737: LIST
41738: LIST
41739: LIST
41740: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41741: LD_ADDR_VAR 0 30
41745: PUSH
41746: LD_INT 2
41748: PUSH
41749: LD_INT 1
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: LD_INT 3
41759: PUSH
41760: LD_INT 0
41762: PUSH
41763: EMPTY
41764: LIST
41765: LIST
41766: PUSH
41767: LD_INT 3
41769: PUSH
41770: LD_INT 1
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: PUSH
41777: LD_INT 3
41779: PUSH
41780: LD_INT 1
41782: NEG
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 4
41790: PUSH
41791: LD_INT 0
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 4
41800: PUSH
41801: LD_INT 1
41803: PUSH
41804: EMPTY
41805: LIST
41806: LIST
41807: PUSH
41808: LD_INT 4
41810: PUSH
41811: LD_INT 1
41813: NEG
41814: PUSH
41815: EMPTY
41816: LIST
41817: LIST
41818: PUSH
41819: LD_INT 5
41821: PUSH
41822: LD_INT 0
41824: PUSH
41825: EMPTY
41826: LIST
41827: LIST
41828: PUSH
41829: LD_INT 5
41831: PUSH
41832: LD_INT 1
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 5
41841: PUSH
41842: LD_INT 1
41844: NEG
41845: PUSH
41846: EMPTY
41847: LIST
41848: LIST
41849: PUSH
41850: LD_INT 6
41852: PUSH
41853: LD_INT 0
41855: PUSH
41856: EMPTY
41857: LIST
41858: LIST
41859: PUSH
41860: LD_INT 6
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: EMPTY
41867: LIST
41868: LIST
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: LIST
41874: LIST
41875: LIST
41876: LIST
41877: LIST
41878: LIST
41879: LIST
41880: LIST
41881: LIST
41882: LIST
41883: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41884: LD_ADDR_VAR 0 31
41888: PUSH
41889: LD_INT 3
41891: PUSH
41892: LD_INT 2
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: LD_INT 3
41901: PUSH
41902: LD_INT 3
41904: PUSH
41905: EMPTY
41906: LIST
41907: LIST
41908: PUSH
41909: LD_INT 2
41911: PUSH
41912: LD_INT 3
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 4
41921: PUSH
41922: LD_INT 3
41924: PUSH
41925: EMPTY
41926: LIST
41927: LIST
41928: PUSH
41929: LD_INT 4
41931: PUSH
41932: LD_INT 4
41934: PUSH
41935: EMPTY
41936: LIST
41937: LIST
41938: PUSH
41939: LD_INT 3
41941: PUSH
41942: LD_INT 4
41944: PUSH
41945: EMPTY
41946: LIST
41947: LIST
41948: PUSH
41949: LD_INT 5
41951: PUSH
41952: LD_INT 4
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 5
41961: PUSH
41962: LD_INT 5
41964: PUSH
41965: EMPTY
41966: LIST
41967: LIST
41968: PUSH
41969: LD_INT 4
41971: PUSH
41972: LD_INT 5
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 6
41981: PUSH
41982: LD_INT 5
41984: PUSH
41985: EMPTY
41986: LIST
41987: LIST
41988: PUSH
41989: LD_INT 6
41991: PUSH
41992: LD_INT 6
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: LD_INT 5
42001: PUSH
42002: LD_INT 6
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42023: LD_ADDR_VAR 0 32
42027: PUSH
42028: LD_INT 1
42030: PUSH
42031: LD_INT 3
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 0
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 1
42050: NEG
42051: PUSH
42052: LD_INT 2
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 1
42061: PUSH
42062: LD_INT 4
42064: PUSH
42065: EMPTY
42066: LIST
42067: LIST
42068: PUSH
42069: LD_INT 0
42071: PUSH
42072: LD_INT 4
42074: PUSH
42075: EMPTY
42076: LIST
42077: LIST
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: LD_INT 3
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: PUSH
42090: LD_INT 1
42092: PUSH
42093: LD_INT 5
42095: PUSH
42096: EMPTY
42097: LIST
42098: LIST
42099: PUSH
42100: LD_INT 0
42102: PUSH
42103: LD_INT 5
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 1
42112: NEG
42113: PUSH
42114: LD_INT 4
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 1
42123: PUSH
42124: LD_INT 6
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 0
42133: PUSH
42134: LD_INT 6
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 1
42143: NEG
42144: PUSH
42145: LD_INT 5
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42166: LD_ADDR_VAR 0 33
42170: PUSH
42171: LD_INT 2
42173: NEG
42174: PUSH
42175: LD_INT 1
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 3
42184: NEG
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 3
42195: NEG
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 3
42207: NEG
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: EMPTY
42213: LIST
42214: LIST
42215: PUSH
42216: LD_INT 4
42218: NEG
42219: PUSH
42220: LD_INT 0
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 4
42229: NEG
42230: PUSH
42231: LD_INT 1
42233: NEG
42234: PUSH
42235: EMPTY
42236: LIST
42237: LIST
42238: PUSH
42239: LD_INT 4
42241: NEG
42242: PUSH
42243: LD_INT 1
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: PUSH
42250: LD_INT 5
42252: NEG
42253: PUSH
42254: LD_INT 0
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 5
42263: NEG
42264: PUSH
42265: LD_INT 1
42267: NEG
42268: PUSH
42269: EMPTY
42270: LIST
42271: LIST
42272: PUSH
42273: LD_INT 5
42275: NEG
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 6
42286: NEG
42287: PUSH
42288: LD_INT 0
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: PUSH
42295: LD_INT 6
42297: NEG
42298: PUSH
42299: LD_INT 1
42301: NEG
42302: PUSH
42303: EMPTY
42304: LIST
42305: LIST
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: LIST
42314: LIST
42315: LIST
42316: LIST
42317: LIST
42318: LIST
42319: LIST
42320: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42321: LD_ADDR_VAR 0 34
42325: PUSH
42326: LD_INT 2
42328: NEG
42329: PUSH
42330: LD_INT 3
42332: NEG
42333: PUSH
42334: EMPTY
42335: LIST
42336: LIST
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: LD_INT 2
42344: NEG
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: LD_INT 3
42356: NEG
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 3
42364: NEG
42365: PUSH
42366: LD_INT 4
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: LD_INT 4
42376: NEG
42377: PUSH
42378: LD_INT 3
42380: NEG
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: PUSH
42386: LD_INT 4
42388: NEG
42389: PUSH
42390: LD_INT 4
42392: NEG
42393: PUSH
42394: EMPTY
42395: LIST
42396: LIST
42397: PUSH
42398: LD_INT 4
42400: NEG
42401: PUSH
42402: LD_INT 5
42404: NEG
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: PUSH
42410: LD_INT 5
42412: NEG
42413: PUSH
42414: LD_INT 4
42416: NEG
42417: PUSH
42418: EMPTY
42419: LIST
42420: LIST
42421: PUSH
42422: LD_INT 5
42424: NEG
42425: PUSH
42426: LD_INT 5
42428: NEG
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 5
42436: NEG
42437: PUSH
42438: LD_INT 6
42440: NEG
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: LD_INT 6
42448: NEG
42449: PUSH
42450: LD_INT 5
42452: NEG
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: LD_INT 6
42460: NEG
42461: PUSH
42462: LD_INT 6
42464: NEG
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: LIST
42478: LIST
42479: LIST
42480: LIST
42481: LIST
42482: LIST
42483: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42484: LD_ADDR_VAR 0 41
42488: PUSH
42489: LD_INT 0
42491: PUSH
42492: LD_INT 2
42494: NEG
42495: PUSH
42496: EMPTY
42497: LIST
42498: LIST
42499: PUSH
42500: LD_INT 1
42502: NEG
42503: PUSH
42504: LD_INT 3
42506: NEG
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: LD_INT 2
42517: NEG
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: LIST
42527: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42528: LD_ADDR_VAR 0 42
42532: PUSH
42533: LD_INT 2
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 2
42545: PUSH
42546: LD_INT 1
42548: NEG
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: LD_INT 3
42556: PUSH
42557: LD_INT 1
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: LIST
42568: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42569: LD_ADDR_VAR 0 43
42573: PUSH
42574: LD_INT 2
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: PUSH
42587: LD_INT 2
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: PUSH
42594: LD_INT 2
42596: PUSH
42597: LD_INT 3
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: EMPTY
42605: LIST
42606: LIST
42607: LIST
42608: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42609: LD_ADDR_VAR 0 44
42613: PUSH
42614: LD_INT 0
42616: PUSH
42617: LD_INT 2
42619: PUSH
42620: EMPTY
42621: LIST
42622: LIST
42623: PUSH
42624: LD_INT 1
42626: PUSH
42627: LD_INT 3
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 1
42636: NEG
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: LIST
42649: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42650: LD_ADDR_VAR 0 45
42654: PUSH
42655: LD_INT 2
42657: NEG
42658: PUSH
42659: LD_INT 0
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: LD_INT 1
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 3
42679: NEG
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: EMPTY
42690: LIST
42691: LIST
42692: LIST
42693: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42694: LD_ADDR_VAR 0 46
42698: PUSH
42699: LD_INT 2
42701: NEG
42702: PUSH
42703: LD_INT 2
42705: NEG
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 2
42713: NEG
42714: PUSH
42715: LD_INT 3
42717: NEG
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 3
42725: NEG
42726: PUSH
42727: LD_INT 2
42729: NEG
42730: PUSH
42731: EMPTY
42732: LIST
42733: LIST
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: LIST
42739: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42740: LD_ADDR_VAR 0 47
42744: PUSH
42745: LD_INT 2
42747: NEG
42748: PUSH
42749: LD_INT 3
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 1
42759: NEG
42760: PUSH
42761: LD_INT 3
42763: NEG
42764: PUSH
42765: EMPTY
42766: LIST
42767: LIST
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42773: LD_ADDR_VAR 0 48
42777: PUSH
42778: LD_INT 1
42780: PUSH
42781: LD_INT 2
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 2
42791: PUSH
42792: LD_INT 1
42794: NEG
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42804: LD_ADDR_VAR 0 49
42808: PUSH
42809: LD_INT 3
42811: PUSH
42812: LD_INT 1
42814: PUSH
42815: EMPTY
42816: LIST
42817: LIST
42818: PUSH
42819: LD_INT 3
42821: PUSH
42822: LD_INT 2
42824: PUSH
42825: EMPTY
42826: LIST
42827: LIST
42828: PUSH
42829: EMPTY
42830: LIST
42831: LIST
42832: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42833: LD_ADDR_VAR 0 50
42837: PUSH
42838: LD_INT 2
42840: PUSH
42841: LD_INT 3
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: PUSH
42848: LD_INT 1
42850: PUSH
42851: LD_INT 3
42853: PUSH
42854: EMPTY
42855: LIST
42856: LIST
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42862: LD_ADDR_VAR 0 51
42866: PUSH
42867: LD_INT 1
42869: NEG
42870: PUSH
42871: LD_INT 2
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: LD_INT 1
42884: PUSH
42885: EMPTY
42886: LIST
42887: LIST
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42893: LD_ADDR_VAR 0 52
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: LD_INT 1
42904: NEG
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 3
42912: NEG
42913: PUSH
42914: LD_INT 2
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: EMPTY
42923: LIST
42924: LIST
42925: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42926: LD_ADDR_VAR 0 53
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: LD_INT 3
42937: NEG
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: LD_INT 3
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 1
42956: PUSH
42957: LD_INT 2
42959: NEG
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: LIST
42969: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42970: LD_ADDR_VAR 0 54
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: LD_INT 1
42980: NEG
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 3
42988: PUSH
42989: LD_INT 0
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 3
42998: PUSH
42999: LD_INT 1
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43011: LD_ADDR_VAR 0 55
43015: PUSH
43016: LD_INT 3
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 3
43028: PUSH
43029: LD_INT 3
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 2
43038: PUSH
43039: LD_INT 3
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: LIST
43050: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43051: LD_ADDR_VAR 0 56
43055: PUSH
43056: LD_INT 1
43058: PUSH
43059: LD_INT 3
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 0
43068: PUSH
43069: LD_INT 3
43071: PUSH
43072: EMPTY
43073: LIST
43074: LIST
43075: PUSH
43076: LD_INT 1
43078: NEG
43079: PUSH
43080: LD_INT 2
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: LIST
43091: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43092: LD_ADDR_VAR 0 57
43096: PUSH
43097: LD_INT 2
43099: NEG
43100: PUSH
43101: LD_INT 1
43103: PUSH
43104: EMPTY
43105: LIST
43106: LIST
43107: PUSH
43108: LD_INT 3
43110: NEG
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 3
43121: NEG
43122: PUSH
43123: LD_INT 1
43125: NEG
43126: PUSH
43127: EMPTY
43128: LIST
43129: LIST
43130: PUSH
43131: EMPTY
43132: LIST
43133: LIST
43134: LIST
43135: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43136: LD_ADDR_VAR 0 58
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: EMPTY
43150: LIST
43151: LIST
43152: PUSH
43153: LD_INT 3
43155: NEG
43156: PUSH
43157: LD_INT 2
43159: NEG
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 3
43167: NEG
43168: PUSH
43169: LD_INT 3
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: LIST
43181: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43182: LD_ADDR_VAR 0 59
43186: PUSH
43187: LD_INT 1
43189: NEG
43190: PUSH
43191: LD_INT 2
43193: NEG
43194: PUSH
43195: EMPTY
43196: LIST
43197: LIST
43198: PUSH
43199: LD_INT 0
43201: PUSH
43202: LD_INT 2
43204: NEG
43205: PUSH
43206: EMPTY
43207: LIST
43208: LIST
43209: PUSH
43210: LD_INT 1
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: LIST
43225: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43226: LD_ADDR_VAR 0 60
43230: PUSH
43231: LD_INT 1
43233: PUSH
43234: LD_INT 1
43236: NEG
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 2
43244: PUSH
43245: LD_INT 0
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 2
43254: PUSH
43255: LD_INT 1
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: LIST
43266: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43267: LD_ADDR_VAR 0 61
43271: PUSH
43272: LD_INT 2
43274: PUSH
43275: LD_INT 1
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: LD_INT 2
43284: PUSH
43285: LD_INT 2
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: LD_INT 2
43297: PUSH
43298: EMPTY
43299: LIST
43300: LIST
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: LIST
43306: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43307: LD_ADDR_VAR 0 62
43311: PUSH
43312: LD_INT 1
43314: PUSH
43315: LD_INT 2
43317: PUSH
43318: EMPTY
43319: LIST
43320: LIST
43321: PUSH
43322: LD_INT 0
43324: PUSH
43325: LD_INT 2
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 1
43334: NEG
43335: PUSH
43336: LD_INT 1
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: LIST
43347: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43348: LD_ADDR_VAR 0 63
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 1
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 2
43377: NEG
43378: PUSH
43379: LD_INT 1
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: LIST
43391: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43392: LD_ADDR_VAR 0 64
43396: PUSH
43397: LD_INT 1
43399: NEG
43400: PUSH
43401: LD_INT 2
43403: NEG
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: PUSH
43409: LD_INT 2
43411: NEG
43412: PUSH
43413: LD_INT 1
43415: NEG
43416: PUSH
43417: EMPTY
43418: LIST
43419: LIST
43420: PUSH
43421: LD_INT 2
43423: NEG
43424: PUSH
43425: LD_INT 2
43427: NEG
43428: PUSH
43429: EMPTY
43430: LIST
43431: LIST
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: LIST
43437: ST_TO_ADDR
// end ; 2 :
43438: GO 46704
43440: LD_INT 2
43442: DOUBLE
43443: EQUAL
43444: IFTRUE 43448
43446: GO 46703
43448: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43449: LD_ADDR_VAR 0 29
43453: PUSH
43454: LD_INT 4
43456: PUSH
43457: LD_INT 0
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PUSH
43464: LD_INT 4
43466: PUSH
43467: LD_INT 1
43469: NEG
43470: PUSH
43471: EMPTY
43472: LIST
43473: LIST
43474: PUSH
43475: LD_INT 5
43477: PUSH
43478: LD_INT 0
43480: PUSH
43481: EMPTY
43482: LIST
43483: LIST
43484: PUSH
43485: LD_INT 5
43487: PUSH
43488: LD_INT 1
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 4
43497: PUSH
43498: LD_INT 1
43500: PUSH
43501: EMPTY
43502: LIST
43503: LIST
43504: PUSH
43505: LD_INT 3
43507: PUSH
43508: LD_INT 0
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: PUSH
43515: LD_INT 3
43517: PUSH
43518: LD_INT 1
43520: NEG
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: LD_INT 2
43531: NEG
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 5
43539: PUSH
43540: LD_INT 2
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: LD_INT 3
43549: PUSH
43550: LD_INT 3
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: PUSH
43557: LD_INT 3
43559: PUSH
43560: LD_INT 2
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 4
43569: PUSH
43570: LD_INT 3
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 4
43579: PUSH
43580: LD_INT 4
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 3
43589: PUSH
43590: LD_INT 4
43592: PUSH
43593: EMPTY
43594: LIST
43595: LIST
43596: PUSH
43597: LD_INT 2
43599: PUSH
43600: LD_INT 3
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: LD_INT 2
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 4
43619: PUSH
43620: LD_INT 2
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 0
43639: PUSH
43640: LD_INT 4
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 0
43649: PUSH
43650: LD_INT 3
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 1
43659: PUSH
43660: LD_INT 4
43662: PUSH
43663: EMPTY
43664: LIST
43665: LIST
43666: PUSH
43667: LD_INT 1
43669: PUSH
43670: LD_INT 5
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: LD_INT 0
43679: PUSH
43680: LD_INT 5
43682: PUSH
43683: EMPTY
43684: LIST
43685: LIST
43686: PUSH
43687: LD_INT 1
43689: NEG
43690: PUSH
43691: LD_INT 4
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: LD_INT 1
43700: NEG
43701: PUSH
43702: LD_INT 3
43704: PUSH
43705: EMPTY
43706: LIST
43707: LIST
43708: PUSH
43709: LD_INT 2
43711: PUSH
43712: LD_INT 5
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: PUSH
43719: LD_INT 2
43721: NEG
43722: PUSH
43723: LD_INT 3
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 3
43732: NEG
43733: PUSH
43734: LD_INT 0
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 3
43743: NEG
43744: PUSH
43745: LD_INT 1
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 2
43755: NEG
43756: PUSH
43757: LD_INT 0
43759: PUSH
43760: EMPTY
43761: LIST
43762: LIST
43763: PUSH
43764: LD_INT 2
43766: NEG
43767: PUSH
43768: LD_INT 1
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 3
43777: NEG
43778: PUSH
43779: LD_INT 1
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 4
43788: NEG
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 4
43799: NEG
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 4
43811: NEG
43812: PUSH
43813: LD_INT 2
43815: NEG
43816: PUSH
43817: EMPTY
43818: LIST
43819: LIST
43820: PUSH
43821: LD_INT 2
43823: NEG
43824: PUSH
43825: LD_INT 2
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 4
43834: NEG
43835: PUSH
43836: LD_INT 4
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 4
43846: NEG
43847: PUSH
43848: LD_INT 5
43850: NEG
43851: PUSH
43852: EMPTY
43853: LIST
43854: LIST
43855: PUSH
43856: LD_INT 3
43858: NEG
43859: PUSH
43860: LD_INT 4
43862: NEG
43863: PUSH
43864: EMPTY
43865: LIST
43866: LIST
43867: PUSH
43868: LD_INT 3
43870: NEG
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 4
43882: NEG
43883: PUSH
43884: LD_INT 3
43886: NEG
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 5
43894: NEG
43895: PUSH
43896: LD_INT 4
43898: NEG
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: NEG
43907: PUSH
43908: LD_INT 5
43910: NEG
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 3
43918: NEG
43919: PUSH
43920: LD_INT 5
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 5
43930: NEG
43931: PUSH
43932: LD_INT 3
43934: NEG
43935: PUSH
43936: EMPTY
43937: LIST
43938: LIST
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: LIST
43952: LIST
43953: LIST
43954: LIST
43955: LIST
43956: LIST
43957: LIST
43958: LIST
43959: LIST
43960: LIST
43961: LIST
43962: LIST
43963: LIST
43964: LIST
43965: LIST
43966: LIST
43967: LIST
43968: LIST
43969: LIST
43970: LIST
43971: LIST
43972: LIST
43973: LIST
43974: LIST
43975: LIST
43976: LIST
43977: LIST
43978: LIST
43979: LIST
43980: LIST
43981: LIST
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43987: LD_ADDR_VAR 0 30
43991: PUSH
43992: LD_INT 4
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 4
44004: PUSH
44005: LD_INT 3
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 5
44014: PUSH
44015: LD_INT 4
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: LD_INT 5
44024: PUSH
44025: LD_INT 5
44027: PUSH
44028: EMPTY
44029: LIST
44030: LIST
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: LD_INT 5
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 3
44044: PUSH
44045: LD_INT 4
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 3
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 5
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: LD_INT 5
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 0
44084: PUSH
44085: LD_INT 3
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: LD_INT 2
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 1
44114: PUSH
44115: LD_INT 4
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: LD_INT 4
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 1
44134: NEG
44135: PUSH
44136: LD_INT 3
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 1
44145: NEG
44146: PUSH
44147: LD_INT 2
44149: PUSH
44150: EMPTY
44151: LIST
44152: LIST
44153: PUSH
44154: LD_INT 2
44156: PUSH
44157: LD_INT 4
44159: PUSH
44160: EMPTY
44161: LIST
44162: LIST
44163: PUSH
44164: LD_INT 2
44166: NEG
44167: PUSH
44168: LD_INT 2
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 4
44188: NEG
44189: PUSH
44190: LD_INT 1
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: LD_INT 0
44204: PUSH
44205: EMPTY
44206: LIST
44207: LIST
44208: PUSH
44209: LD_INT 3
44211: NEG
44212: PUSH
44213: LD_INT 1
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 4
44222: NEG
44223: PUSH
44224: LD_INT 1
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 5
44233: NEG
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 5
44244: NEG
44245: PUSH
44246: LD_INT 1
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 5
44256: NEG
44257: PUSH
44258: LD_INT 2
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 3
44268: NEG
44269: PUSH
44270: LD_INT 2
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 3
44279: NEG
44280: PUSH
44281: LD_INT 3
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 3
44291: NEG
44292: PUSH
44293: LD_INT 4
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 2
44303: NEG
44304: PUSH
44305: LD_INT 3
44307: NEG
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 2
44315: NEG
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 3
44327: NEG
44328: PUSH
44329: LD_INT 2
44331: NEG
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 4
44339: NEG
44340: PUSH
44341: LD_INT 3
44343: NEG
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 4
44351: NEG
44352: PUSH
44353: LD_INT 4
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 2
44363: NEG
44364: PUSH
44365: LD_INT 4
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 4
44375: NEG
44376: PUSH
44377: LD_INT 2
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 0
44387: PUSH
44388: LD_INT 4
44390: NEG
44391: PUSH
44392: EMPTY
44393: LIST
44394: LIST
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: LD_INT 5
44401: NEG
44402: PUSH
44403: EMPTY
44404: LIST
44405: LIST
44406: PUSH
44407: LD_INT 1
44409: PUSH
44410: LD_INT 4
44412: NEG
44413: PUSH
44414: EMPTY
44415: LIST
44416: LIST
44417: PUSH
44418: LD_INT 1
44420: PUSH
44421: LD_INT 3
44423: NEG
44424: PUSH
44425: EMPTY
44426: LIST
44427: LIST
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: LD_INT 3
44434: NEG
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 1
44442: NEG
44443: PUSH
44444: LD_INT 4
44446: NEG
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 1
44454: NEG
44455: PUSH
44456: LD_INT 5
44458: NEG
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 2
44466: PUSH
44467: LD_INT 3
44469: NEG
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 2
44477: NEG
44478: PUSH
44479: LD_INT 5
44481: NEG
44482: PUSH
44483: EMPTY
44484: LIST
44485: LIST
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: LIST
44498: LIST
44499: LIST
44500: LIST
44501: LIST
44502: LIST
44503: LIST
44504: LIST
44505: LIST
44506: LIST
44507: LIST
44508: LIST
44509: LIST
44510: LIST
44511: LIST
44512: LIST
44513: LIST
44514: LIST
44515: LIST
44516: LIST
44517: LIST
44518: LIST
44519: LIST
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: LIST
44533: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44534: LD_ADDR_VAR 0 31
44538: PUSH
44539: LD_INT 0
44541: PUSH
44542: LD_INT 4
44544: PUSH
44545: EMPTY
44546: LIST
44547: LIST
44548: PUSH
44549: LD_INT 0
44551: PUSH
44552: LD_INT 3
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 1
44561: PUSH
44562: LD_INT 4
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: PUSH
44572: LD_INT 5
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: LD_INT 5
44584: PUSH
44585: EMPTY
44586: LIST
44587: LIST
44588: PUSH
44589: LD_INT 1
44591: NEG
44592: PUSH
44593: LD_INT 4
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 1
44602: NEG
44603: PUSH
44604: LD_INT 3
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 2
44613: PUSH
44614: LD_INT 5
44616: PUSH
44617: EMPTY
44618: LIST
44619: LIST
44620: PUSH
44621: LD_INT 2
44623: NEG
44624: PUSH
44625: LD_INT 3
44627: PUSH
44628: EMPTY
44629: LIST
44630: LIST
44631: PUSH
44632: LD_INT 3
44634: NEG
44635: PUSH
44636: LD_INT 0
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 3
44645: NEG
44646: PUSH
44647: LD_INT 1
44649: NEG
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 2
44657: NEG
44658: PUSH
44659: LD_INT 0
44661: PUSH
44662: EMPTY
44663: LIST
44664: LIST
44665: PUSH
44666: LD_INT 2
44668: NEG
44669: PUSH
44670: LD_INT 1
44672: PUSH
44673: EMPTY
44674: LIST
44675: LIST
44676: PUSH
44677: LD_INT 3
44679: NEG
44680: PUSH
44681: LD_INT 1
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 4
44690: NEG
44691: PUSH
44692: LD_INT 0
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: LD_INT 1
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 4
44713: NEG
44714: PUSH
44715: LD_INT 2
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: LD_INT 2
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 4
44736: NEG
44737: PUSH
44738: LD_INT 4
44740: NEG
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 4
44748: NEG
44749: PUSH
44750: LD_INT 5
44752: NEG
44753: PUSH
44754: EMPTY
44755: LIST
44756: LIST
44757: PUSH
44758: LD_INT 3
44760: NEG
44761: PUSH
44762: LD_INT 4
44764: NEG
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 3
44772: NEG
44773: PUSH
44774: LD_INT 3
44776: NEG
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 4
44784: NEG
44785: PUSH
44786: LD_INT 3
44788: NEG
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 5
44796: NEG
44797: PUSH
44798: LD_INT 4
44800: NEG
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 5
44808: NEG
44809: PUSH
44810: LD_INT 5
44812: NEG
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 3
44820: NEG
44821: PUSH
44822: LD_INT 5
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 5
44832: NEG
44833: PUSH
44834: LD_INT 3
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 0
44844: PUSH
44845: LD_INT 3
44847: NEG
44848: PUSH
44849: EMPTY
44850: LIST
44851: LIST
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: LD_INT 4
44858: NEG
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: LD_INT 3
44869: NEG
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 1
44877: PUSH
44878: LD_INT 2
44880: NEG
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: LD_INT 2
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 1
44899: NEG
44900: PUSH
44901: LD_INT 3
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 1
44911: NEG
44912: PUSH
44913: LD_INT 4
44915: NEG
44916: PUSH
44917: EMPTY
44918: LIST
44919: LIST
44920: PUSH
44921: LD_INT 2
44923: PUSH
44924: LD_INT 2
44926: NEG
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 2
44934: NEG
44935: PUSH
44936: LD_INT 4
44938: NEG
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 4
44946: PUSH
44947: LD_INT 0
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 4
44956: PUSH
44957: LD_INT 1
44959: NEG
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 5
44967: PUSH
44968: LD_INT 0
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 5
44977: PUSH
44978: LD_INT 1
44980: PUSH
44981: EMPTY
44982: LIST
44983: LIST
44984: PUSH
44985: LD_INT 4
44987: PUSH
44988: LD_INT 1
44990: PUSH
44991: EMPTY
44992: LIST
44993: LIST
44994: PUSH
44995: LD_INT 3
44997: PUSH
44998: LD_INT 0
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 3
45007: PUSH
45008: LD_INT 1
45010: NEG
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 3
45018: PUSH
45019: LD_INT 2
45021: NEG
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 5
45029: PUSH
45030: LD_INT 2
45032: PUSH
45033: EMPTY
45034: LIST
45035: LIST
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: LIST
45041: LIST
45042: LIST
45043: LIST
45044: LIST
45045: LIST
45046: LIST
45047: LIST
45048: LIST
45049: LIST
45050: LIST
45051: LIST
45052: LIST
45053: LIST
45054: LIST
45055: LIST
45056: LIST
45057: LIST
45058: LIST
45059: LIST
45060: LIST
45061: LIST
45062: LIST
45063: LIST
45064: LIST
45065: LIST
45066: LIST
45067: LIST
45068: LIST
45069: LIST
45070: LIST
45071: LIST
45072: LIST
45073: LIST
45074: LIST
45075: LIST
45076: LIST
45077: LIST
45078: LIST
45079: LIST
45080: LIST
45081: LIST
45082: LIST
45083: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45084: LD_ADDR_VAR 0 32
45088: PUSH
45089: LD_INT 4
45091: NEG
45092: PUSH
45093: LD_INT 0
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: LD_INT 4
45102: NEG
45103: PUSH
45104: LD_INT 1
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 3
45114: NEG
45115: PUSH
45116: LD_INT 0
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: PUSH
45123: LD_INT 3
45125: NEG
45126: PUSH
45127: LD_INT 1
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 4
45136: NEG
45137: PUSH
45138: LD_INT 1
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 5
45147: NEG
45148: PUSH
45149: LD_INT 0
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 5
45158: NEG
45159: PUSH
45160: LD_INT 1
45162: NEG
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 5
45170: NEG
45171: PUSH
45172: LD_INT 2
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 3
45182: NEG
45183: PUSH
45184: LD_INT 2
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 3
45193: NEG
45194: PUSH
45195: LD_INT 3
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: NEG
45206: PUSH
45207: LD_INT 4
45209: NEG
45210: PUSH
45211: EMPTY
45212: LIST
45213: LIST
45214: PUSH
45215: LD_INT 2
45217: NEG
45218: PUSH
45219: LD_INT 3
45221: NEG
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 2
45229: NEG
45230: PUSH
45231: LD_INT 2
45233: NEG
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 3
45241: NEG
45242: PUSH
45243: LD_INT 2
45245: NEG
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 4
45253: NEG
45254: PUSH
45255: LD_INT 3
45257: NEG
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 4
45265: NEG
45266: PUSH
45267: LD_INT 4
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 2
45277: NEG
45278: PUSH
45279: LD_INT 4
45281: NEG
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 4
45289: NEG
45290: PUSH
45291: LD_INT 2
45293: NEG
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 0
45301: PUSH
45302: LD_INT 4
45304: NEG
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PUSH
45310: LD_INT 0
45312: PUSH
45313: LD_INT 5
45315: NEG
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: LD_INT 1
45323: PUSH
45324: LD_INT 4
45326: NEG
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: PUSH
45332: LD_INT 1
45334: PUSH
45335: LD_INT 3
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: LD_INT 3
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 1
45356: NEG
45357: PUSH
45358: LD_INT 4
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 1
45368: NEG
45369: PUSH
45370: LD_INT 5
45372: NEG
45373: PUSH
45374: EMPTY
45375: LIST
45376: LIST
45377: PUSH
45378: LD_INT 2
45380: PUSH
45381: LD_INT 3
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 2
45391: NEG
45392: PUSH
45393: LD_INT 5
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 3
45403: PUSH
45404: LD_INT 0
45406: PUSH
45407: EMPTY
45408: LIST
45409: LIST
45410: PUSH
45411: LD_INT 3
45413: PUSH
45414: LD_INT 1
45416: NEG
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: PUSH
45422: LD_INT 4
45424: PUSH
45425: LD_INT 0
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 4
45434: PUSH
45435: LD_INT 1
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: LD_INT 3
45444: PUSH
45445: LD_INT 1
45447: PUSH
45448: EMPTY
45449: LIST
45450: LIST
45451: PUSH
45452: LD_INT 2
45454: PUSH
45455: LD_INT 0
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 2
45464: PUSH
45465: LD_INT 1
45467: NEG
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 2
45475: PUSH
45476: LD_INT 2
45478: NEG
45479: PUSH
45480: EMPTY
45481: LIST
45482: LIST
45483: PUSH
45484: LD_INT 4
45486: PUSH
45487: LD_INT 2
45489: PUSH
45490: EMPTY
45491: LIST
45492: LIST
45493: PUSH
45494: LD_INT 4
45496: PUSH
45497: LD_INT 4
45499: PUSH
45500: EMPTY
45501: LIST
45502: LIST
45503: PUSH
45504: LD_INT 4
45506: PUSH
45507: LD_INT 3
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 5
45516: PUSH
45517: LD_INT 4
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: PUSH
45524: LD_INT 5
45526: PUSH
45527: LD_INT 5
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 4
45536: PUSH
45537: LD_INT 5
45539: PUSH
45540: EMPTY
45541: LIST
45542: LIST
45543: PUSH
45544: LD_INT 3
45546: PUSH
45547: LD_INT 4
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: PUSH
45557: LD_INT 3
45559: PUSH
45560: EMPTY
45561: LIST
45562: LIST
45563: PUSH
45564: LD_INT 5
45566: PUSH
45567: LD_INT 3
45569: PUSH
45570: EMPTY
45571: LIST
45572: LIST
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: LD_INT 5
45579: PUSH
45580: EMPTY
45581: LIST
45582: LIST
45583: PUSH
45584: EMPTY
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: LIST
45592: LIST
45593: LIST
45594: LIST
45595: LIST
45596: LIST
45597: LIST
45598: LIST
45599: LIST
45600: LIST
45601: LIST
45602: LIST
45603: LIST
45604: LIST
45605: LIST
45606: LIST
45607: LIST
45608: LIST
45609: LIST
45610: LIST
45611: LIST
45612: LIST
45613: LIST
45614: LIST
45615: LIST
45616: LIST
45617: LIST
45618: LIST
45619: LIST
45620: LIST
45621: LIST
45622: LIST
45623: LIST
45624: LIST
45625: LIST
45626: LIST
45627: LIST
45628: LIST
45629: LIST
45630: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45631: LD_ADDR_VAR 0 33
45635: PUSH
45636: LD_INT 4
45638: NEG
45639: PUSH
45640: LD_INT 4
45642: NEG
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 4
45650: NEG
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: LD_INT 3
45662: NEG
45663: PUSH
45664: LD_INT 4
45666: NEG
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 3
45674: NEG
45675: PUSH
45676: LD_INT 3
45678: NEG
45679: PUSH
45680: EMPTY
45681: LIST
45682: LIST
45683: PUSH
45684: LD_INT 4
45686: NEG
45687: PUSH
45688: LD_INT 3
45690: NEG
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 5
45698: NEG
45699: PUSH
45700: LD_INT 4
45702: NEG
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PUSH
45708: LD_INT 5
45710: NEG
45711: PUSH
45712: LD_INT 5
45714: NEG
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 3
45722: NEG
45723: PUSH
45724: LD_INT 5
45726: NEG
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 5
45734: NEG
45735: PUSH
45736: LD_INT 3
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 0
45746: PUSH
45747: LD_INT 3
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 0
45757: PUSH
45758: LD_INT 4
45760: NEG
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 1
45768: PUSH
45769: LD_INT 3
45771: NEG
45772: PUSH
45773: EMPTY
45774: LIST
45775: LIST
45776: PUSH
45777: LD_INT 1
45779: PUSH
45780: LD_INT 2
45782: NEG
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: LD_INT 2
45793: NEG
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 1
45801: NEG
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 1
45813: NEG
45814: PUSH
45815: LD_INT 4
45817: NEG
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: PUSH
45823: LD_INT 2
45825: PUSH
45826: LD_INT 2
45828: NEG
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 2
45836: NEG
45837: PUSH
45838: LD_INT 4
45840: NEG
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 4
45848: PUSH
45849: LD_INT 0
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 4
45858: PUSH
45859: LD_INT 1
45861: NEG
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PUSH
45867: LD_INT 5
45869: PUSH
45870: LD_INT 0
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: LD_INT 5
45879: PUSH
45880: LD_INT 1
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 4
45889: PUSH
45890: LD_INT 1
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: LD_INT 3
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: EMPTY
45904: LIST
45905: LIST
45906: PUSH
45907: LD_INT 3
45909: PUSH
45910: LD_INT 1
45912: NEG
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 3
45920: PUSH
45921: LD_INT 2
45923: NEG
45924: PUSH
45925: EMPTY
45926: LIST
45927: LIST
45928: PUSH
45929: LD_INT 5
45931: PUSH
45932: LD_INT 2
45934: PUSH
45935: EMPTY
45936: LIST
45937: LIST
45938: PUSH
45939: LD_INT 3
45941: PUSH
45942: LD_INT 3
45944: PUSH
45945: EMPTY
45946: LIST
45947: LIST
45948: PUSH
45949: LD_INT 3
45951: PUSH
45952: LD_INT 2
45954: PUSH
45955: EMPTY
45956: LIST
45957: LIST
45958: PUSH
45959: LD_INT 4
45961: PUSH
45962: LD_INT 3
45964: PUSH
45965: EMPTY
45966: LIST
45967: LIST
45968: PUSH
45969: LD_INT 4
45971: PUSH
45972: LD_INT 4
45974: PUSH
45975: EMPTY
45976: LIST
45977: LIST
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: LD_INT 4
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 2
45991: PUSH
45992: LD_INT 3
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: LD_INT 2
46001: PUSH
46002: LD_INT 2
46004: PUSH
46005: EMPTY
46006: LIST
46007: LIST
46008: PUSH
46009: LD_INT 4
46011: PUSH
46012: LD_INT 2
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 2
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 0
46031: PUSH
46032: LD_INT 4
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 0
46041: PUSH
46042: LD_INT 3
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 1
46051: PUSH
46052: LD_INT 4
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 1
46061: PUSH
46062: LD_INT 5
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: LD_INT 0
46071: PUSH
46072: LD_INT 5
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 1
46081: NEG
46082: PUSH
46083: LD_INT 4
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: PUSH
46090: LD_INT 1
46092: NEG
46093: PUSH
46094: LD_INT 3
46096: PUSH
46097: EMPTY
46098: LIST
46099: LIST
46100: PUSH
46101: LD_INT 2
46103: PUSH
46104: LD_INT 5
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 2
46113: NEG
46114: PUSH
46115: LD_INT 3
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: LIST
46136: LIST
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: LIST
46144: LIST
46145: LIST
46146: LIST
46147: LIST
46148: LIST
46149: LIST
46150: LIST
46151: LIST
46152: LIST
46153: LIST
46154: LIST
46155: LIST
46156: LIST
46157: LIST
46158: LIST
46159: LIST
46160: LIST
46161: LIST
46162: LIST
46163: LIST
46164: LIST
46165: LIST
46166: LIST
46167: LIST
46168: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46169: LD_ADDR_VAR 0 34
46173: PUSH
46174: LD_INT 0
46176: PUSH
46177: LD_INT 4
46179: NEG
46180: PUSH
46181: EMPTY
46182: LIST
46183: LIST
46184: PUSH
46185: LD_INT 0
46187: PUSH
46188: LD_INT 5
46190: NEG
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 1
46198: PUSH
46199: LD_INT 4
46201: NEG
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 1
46209: PUSH
46210: LD_INT 3
46212: NEG
46213: PUSH
46214: EMPTY
46215: LIST
46216: LIST
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: LD_INT 3
46223: NEG
46224: PUSH
46225: EMPTY
46226: LIST
46227: LIST
46228: PUSH
46229: LD_INT 1
46231: NEG
46232: PUSH
46233: LD_INT 4
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 1
46243: NEG
46244: PUSH
46245: LD_INT 5
46247: NEG
46248: PUSH
46249: EMPTY
46250: LIST
46251: LIST
46252: PUSH
46253: LD_INT 2
46255: PUSH
46256: LD_INT 3
46258: NEG
46259: PUSH
46260: EMPTY
46261: LIST
46262: LIST
46263: PUSH
46264: LD_INT 2
46266: NEG
46267: PUSH
46268: LD_INT 5
46270: NEG
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 3
46278: PUSH
46279: LD_INT 0
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 3
46288: PUSH
46289: LD_INT 1
46291: NEG
46292: PUSH
46293: EMPTY
46294: LIST
46295: LIST
46296: PUSH
46297: LD_INT 4
46299: PUSH
46300: LD_INT 0
46302: PUSH
46303: EMPTY
46304: LIST
46305: LIST
46306: PUSH
46307: LD_INT 4
46309: PUSH
46310: LD_INT 1
46312: PUSH
46313: EMPTY
46314: LIST
46315: LIST
46316: PUSH
46317: LD_INT 3
46319: PUSH
46320: LD_INT 1
46322: PUSH
46323: EMPTY
46324: LIST
46325: LIST
46326: PUSH
46327: LD_INT 2
46329: PUSH
46330: LD_INT 0
46332: PUSH
46333: EMPTY
46334: LIST
46335: LIST
46336: PUSH
46337: LD_INT 2
46339: PUSH
46340: LD_INT 1
46342: NEG
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 2
46350: PUSH
46351: LD_INT 2
46353: NEG
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: LD_INT 4
46361: PUSH
46362: LD_INT 2
46364: PUSH
46365: EMPTY
46366: LIST
46367: LIST
46368: PUSH
46369: LD_INT 4
46371: PUSH
46372: LD_INT 4
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 4
46381: PUSH
46382: LD_INT 3
46384: PUSH
46385: EMPTY
46386: LIST
46387: LIST
46388: PUSH
46389: LD_INT 5
46391: PUSH
46392: LD_INT 4
46394: PUSH
46395: EMPTY
46396: LIST
46397: LIST
46398: PUSH
46399: LD_INT 5
46401: PUSH
46402: LD_INT 5
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: LD_INT 5
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 3
46421: PUSH
46422: LD_INT 4
46424: PUSH
46425: EMPTY
46426: LIST
46427: LIST
46428: PUSH
46429: LD_INT 3
46431: PUSH
46432: LD_INT 3
46434: PUSH
46435: EMPTY
46436: LIST
46437: LIST
46438: PUSH
46439: LD_INT 5
46441: PUSH
46442: LD_INT 3
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: PUSH
46449: LD_INT 3
46451: PUSH
46452: LD_INT 5
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: PUSH
46459: LD_INT 0
46461: PUSH
46462: LD_INT 3
46464: PUSH
46465: EMPTY
46466: LIST
46467: LIST
46468: PUSH
46469: LD_INT 0
46471: PUSH
46472: LD_INT 2
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: LD_INT 1
46481: PUSH
46482: LD_INT 3
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 1
46491: PUSH
46492: LD_INT 4
46494: PUSH
46495: EMPTY
46496: LIST
46497: LIST
46498: PUSH
46499: LD_INT 0
46501: PUSH
46502: LD_INT 4
46504: PUSH
46505: EMPTY
46506: LIST
46507: LIST
46508: PUSH
46509: LD_INT 1
46511: NEG
46512: PUSH
46513: LD_INT 3
46515: PUSH
46516: EMPTY
46517: LIST
46518: LIST
46519: PUSH
46520: LD_INT 1
46522: NEG
46523: PUSH
46524: LD_INT 2
46526: PUSH
46527: EMPTY
46528: LIST
46529: LIST
46530: PUSH
46531: LD_INT 2
46533: PUSH
46534: LD_INT 4
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 2
46543: NEG
46544: PUSH
46545: LD_INT 2
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 4
46554: NEG
46555: PUSH
46556: LD_INT 0
46558: PUSH
46559: EMPTY
46560: LIST
46561: LIST
46562: PUSH
46563: LD_INT 4
46565: NEG
46566: PUSH
46567: LD_INT 1
46569: NEG
46570: PUSH
46571: EMPTY
46572: LIST
46573: LIST
46574: PUSH
46575: LD_INT 3
46577: NEG
46578: PUSH
46579: LD_INT 0
46581: PUSH
46582: EMPTY
46583: LIST
46584: LIST
46585: PUSH
46586: LD_INT 3
46588: NEG
46589: PUSH
46590: LD_INT 1
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: PUSH
46597: LD_INT 4
46599: NEG
46600: PUSH
46601: LD_INT 1
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 5
46610: NEG
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: LD_INT 5
46621: NEG
46622: PUSH
46623: LD_INT 1
46625: NEG
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 5
46633: NEG
46634: PUSH
46635: LD_INT 2
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 3
46645: NEG
46646: PUSH
46647: LD_INT 2
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: LIST
46674: LIST
46675: LIST
46676: LIST
46677: LIST
46678: LIST
46679: LIST
46680: LIST
46681: LIST
46682: LIST
46683: LIST
46684: LIST
46685: LIST
46686: LIST
46687: LIST
46688: LIST
46689: LIST
46690: LIST
46691: LIST
46692: LIST
46693: LIST
46694: LIST
46695: LIST
46696: LIST
46697: LIST
46698: LIST
46699: LIST
46700: ST_TO_ADDR
// end ; end ;
46701: GO 46704
46703: POP
// case btype of b_depot , b_warehouse :
46704: LD_VAR 0 1
46708: PUSH
46709: LD_INT 0
46711: DOUBLE
46712: EQUAL
46713: IFTRUE 46723
46715: LD_INT 1
46717: DOUBLE
46718: EQUAL
46719: IFTRUE 46723
46721: GO 46924
46723: POP
// case nation of nation_american :
46724: LD_VAR 0 5
46728: PUSH
46729: LD_INT 1
46731: DOUBLE
46732: EQUAL
46733: IFTRUE 46737
46735: GO 46793
46737: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46738: LD_ADDR_VAR 0 9
46742: PUSH
46743: LD_VAR 0 11
46747: PUSH
46748: LD_VAR 0 12
46752: PUSH
46753: LD_VAR 0 13
46757: PUSH
46758: LD_VAR 0 14
46762: PUSH
46763: LD_VAR 0 15
46767: PUSH
46768: LD_VAR 0 16
46772: PUSH
46773: EMPTY
46774: LIST
46775: LIST
46776: LIST
46777: LIST
46778: LIST
46779: LIST
46780: PUSH
46781: LD_VAR 0 4
46785: PUSH
46786: LD_INT 1
46788: PLUS
46789: ARRAY
46790: ST_TO_ADDR
46791: GO 46922
46793: LD_INT 2
46795: DOUBLE
46796: EQUAL
46797: IFTRUE 46801
46799: GO 46857
46801: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46802: LD_ADDR_VAR 0 9
46806: PUSH
46807: LD_VAR 0 17
46811: PUSH
46812: LD_VAR 0 18
46816: PUSH
46817: LD_VAR 0 19
46821: PUSH
46822: LD_VAR 0 20
46826: PUSH
46827: LD_VAR 0 21
46831: PUSH
46832: LD_VAR 0 22
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: LIST
46841: LIST
46842: LIST
46843: LIST
46844: PUSH
46845: LD_VAR 0 4
46849: PUSH
46850: LD_INT 1
46852: PLUS
46853: ARRAY
46854: ST_TO_ADDR
46855: GO 46922
46857: LD_INT 3
46859: DOUBLE
46860: EQUAL
46861: IFTRUE 46865
46863: GO 46921
46865: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46866: LD_ADDR_VAR 0 9
46870: PUSH
46871: LD_VAR 0 23
46875: PUSH
46876: LD_VAR 0 24
46880: PUSH
46881: LD_VAR 0 25
46885: PUSH
46886: LD_VAR 0 26
46890: PUSH
46891: LD_VAR 0 27
46895: PUSH
46896: LD_VAR 0 28
46900: PUSH
46901: EMPTY
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: PUSH
46909: LD_VAR 0 4
46913: PUSH
46914: LD_INT 1
46916: PLUS
46917: ARRAY
46918: ST_TO_ADDR
46919: GO 46922
46921: POP
46922: GO 47477
46924: LD_INT 2
46926: DOUBLE
46927: EQUAL
46928: IFTRUE 46938
46930: LD_INT 3
46932: DOUBLE
46933: EQUAL
46934: IFTRUE 46938
46936: GO 46994
46938: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46939: LD_ADDR_VAR 0 9
46943: PUSH
46944: LD_VAR 0 29
46948: PUSH
46949: LD_VAR 0 30
46953: PUSH
46954: LD_VAR 0 31
46958: PUSH
46959: LD_VAR 0 32
46963: PUSH
46964: LD_VAR 0 33
46968: PUSH
46969: LD_VAR 0 34
46973: PUSH
46974: EMPTY
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: PUSH
46982: LD_VAR 0 4
46986: PUSH
46987: LD_INT 1
46989: PLUS
46990: ARRAY
46991: ST_TO_ADDR
46992: GO 47477
46994: LD_INT 16
46996: DOUBLE
46997: EQUAL
46998: IFTRUE 47056
47000: LD_INT 17
47002: DOUBLE
47003: EQUAL
47004: IFTRUE 47056
47006: LD_INT 18
47008: DOUBLE
47009: EQUAL
47010: IFTRUE 47056
47012: LD_INT 19
47014: DOUBLE
47015: EQUAL
47016: IFTRUE 47056
47018: LD_INT 22
47020: DOUBLE
47021: EQUAL
47022: IFTRUE 47056
47024: LD_INT 20
47026: DOUBLE
47027: EQUAL
47028: IFTRUE 47056
47030: LD_INT 21
47032: DOUBLE
47033: EQUAL
47034: IFTRUE 47056
47036: LD_INT 23
47038: DOUBLE
47039: EQUAL
47040: IFTRUE 47056
47042: LD_INT 24
47044: DOUBLE
47045: EQUAL
47046: IFTRUE 47056
47048: LD_INT 25
47050: DOUBLE
47051: EQUAL
47052: IFTRUE 47056
47054: GO 47112
47056: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47057: LD_ADDR_VAR 0 9
47061: PUSH
47062: LD_VAR 0 35
47066: PUSH
47067: LD_VAR 0 36
47071: PUSH
47072: LD_VAR 0 37
47076: PUSH
47077: LD_VAR 0 38
47081: PUSH
47082: LD_VAR 0 39
47086: PUSH
47087: LD_VAR 0 40
47091: PUSH
47092: EMPTY
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: PUSH
47100: LD_VAR 0 4
47104: PUSH
47105: LD_INT 1
47107: PLUS
47108: ARRAY
47109: ST_TO_ADDR
47110: GO 47477
47112: LD_INT 6
47114: DOUBLE
47115: EQUAL
47116: IFTRUE 47168
47118: LD_INT 7
47120: DOUBLE
47121: EQUAL
47122: IFTRUE 47168
47124: LD_INT 8
47126: DOUBLE
47127: EQUAL
47128: IFTRUE 47168
47130: LD_INT 13
47132: DOUBLE
47133: EQUAL
47134: IFTRUE 47168
47136: LD_INT 12
47138: DOUBLE
47139: EQUAL
47140: IFTRUE 47168
47142: LD_INT 15
47144: DOUBLE
47145: EQUAL
47146: IFTRUE 47168
47148: LD_INT 11
47150: DOUBLE
47151: EQUAL
47152: IFTRUE 47168
47154: LD_INT 14
47156: DOUBLE
47157: EQUAL
47158: IFTRUE 47168
47160: LD_INT 10
47162: DOUBLE
47163: EQUAL
47164: IFTRUE 47168
47166: GO 47224
47168: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47169: LD_ADDR_VAR 0 9
47173: PUSH
47174: LD_VAR 0 41
47178: PUSH
47179: LD_VAR 0 42
47183: PUSH
47184: LD_VAR 0 43
47188: PUSH
47189: LD_VAR 0 44
47193: PUSH
47194: LD_VAR 0 45
47198: PUSH
47199: LD_VAR 0 46
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: LIST
47208: LIST
47209: LIST
47210: LIST
47211: PUSH
47212: LD_VAR 0 4
47216: PUSH
47217: LD_INT 1
47219: PLUS
47220: ARRAY
47221: ST_TO_ADDR
47222: GO 47477
47224: LD_INT 36
47226: DOUBLE
47227: EQUAL
47228: IFTRUE 47232
47230: GO 47288
47232: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47233: LD_ADDR_VAR 0 9
47237: PUSH
47238: LD_VAR 0 47
47242: PUSH
47243: LD_VAR 0 48
47247: PUSH
47248: LD_VAR 0 49
47252: PUSH
47253: LD_VAR 0 50
47257: PUSH
47258: LD_VAR 0 51
47262: PUSH
47263: LD_VAR 0 52
47267: PUSH
47268: EMPTY
47269: LIST
47270: LIST
47271: LIST
47272: LIST
47273: LIST
47274: LIST
47275: PUSH
47276: LD_VAR 0 4
47280: PUSH
47281: LD_INT 1
47283: PLUS
47284: ARRAY
47285: ST_TO_ADDR
47286: GO 47477
47288: LD_INT 4
47290: DOUBLE
47291: EQUAL
47292: IFTRUE 47314
47294: LD_INT 5
47296: DOUBLE
47297: EQUAL
47298: IFTRUE 47314
47300: LD_INT 34
47302: DOUBLE
47303: EQUAL
47304: IFTRUE 47314
47306: LD_INT 37
47308: DOUBLE
47309: EQUAL
47310: IFTRUE 47314
47312: GO 47370
47314: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47315: LD_ADDR_VAR 0 9
47319: PUSH
47320: LD_VAR 0 53
47324: PUSH
47325: LD_VAR 0 54
47329: PUSH
47330: LD_VAR 0 55
47334: PUSH
47335: LD_VAR 0 56
47339: PUSH
47340: LD_VAR 0 57
47344: PUSH
47345: LD_VAR 0 58
47349: PUSH
47350: EMPTY
47351: LIST
47352: LIST
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: PUSH
47358: LD_VAR 0 4
47362: PUSH
47363: LD_INT 1
47365: PLUS
47366: ARRAY
47367: ST_TO_ADDR
47368: GO 47477
47370: LD_INT 31
47372: DOUBLE
47373: EQUAL
47374: IFTRUE 47420
47376: LD_INT 32
47378: DOUBLE
47379: EQUAL
47380: IFTRUE 47420
47382: LD_INT 33
47384: DOUBLE
47385: EQUAL
47386: IFTRUE 47420
47388: LD_INT 27
47390: DOUBLE
47391: EQUAL
47392: IFTRUE 47420
47394: LD_INT 26
47396: DOUBLE
47397: EQUAL
47398: IFTRUE 47420
47400: LD_INT 28
47402: DOUBLE
47403: EQUAL
47404: IFTRUE 47420
47406: LD_INT 29
47408: DOUBLE
47409: EQUAL
47410: IFTRUE 47420
47412: LD_INT 30
47414: DOUBLE
47415: EQUAL
47416: IFTRUE 47420
47418: GO 47476
47420: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47421: LD_ADDR_VAR 0 9
47425: PUSH
47426: LD_VAR 0 59
47430: PUSH
47431: LD_VAR 0 60
47435: PUSH
47436: LD_VAR 0 61
47440: PUSH
47441: LD_VAR 0 62
47445: PUSH
47446: LD_VAR 0 63
47450: PUSH
47451: LD_VAR 0 64
47455: PUSH
47456: EMPTY
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: PUSH
47464: LD_VAR 0 4
47468: PUSH
47469: LD_INT 1
47471: PLUS
47472: ARRAY
47473: ST_TO_ADDR
47474: GO 47477
47476: POP
// temp_list2 = [ ] ;
47477: LD_ADDR_VAR 0 10
47481: PUSH
47482: EMPTY
47483: ST_TO_ADDR
// for i in temp_list do
47484: LD_ADDR_VAR 0 8
47488: PUSH
47489: LD_VAR 0 9
47493: PUSH
47494: FOR_IN
47495: IFFALSE 47547
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47497: LD_ADDR_VAR 0 10
47501: PUSH
47502: LD_VAR 0 10
47506: PUSH
47507: LD_VAR 0 8
47511: PUSH
47512: LD_INT 1
47514: ARRAY
47515: PUSH
47516: LD_VAR 0 2
47520: PLUS
47521: PUSH
47522: LD_VAR 0 8
47526: PUSH
47527: LD_INT 2
47529: ARRAY
47530: PUSH
47531: LD_VAR 0 3
47535: PLUS
47536: PUSH
47537: EMPTY
47538: LIST
47539: LIST
47540: PUSH
47541: EMPTY
47542: LIST
47543: ADD
47544: ST_TO_ADDR
47545: GO 47494
47547: POP
47548: POP
// result = temp_list2 ;
47549: LD_ADDR_VAR 0 7
47553: PUSH
47554: LD_VAR 0 10
47558: ST_TO_ADDR
// end ;
47559: LD_VAR 0 7
47563: RET
// export function EnemyInRange ( unit , dist ) ; begin
47564: LD_INT 0
47566: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47567: LD_ADDR_VAR 0 3
47571: PUSH
47572: LD_VAR 0 1
47576: PPUSH
47577: CALL_OW 255
47581: PPUSH
47582: LD_VAR 0 1
47586: PPUSH
47587: CALL_OW 250
47591: PPUSH
47592: LD_VAR 0 1
47596: PPUSH
47597: CALL_OW 251
47601: PPUSH
47602: LD_VAR 0 2
47606: PPUSH
47607: CALL 20966 0 4
47611: PUSH
47612: LD_INT 4
47614: ARRAY
47615: ST_TO_ADDR
// end ;
47616: LD_VAR 0 3
47620: RET
// export function PlayerSeeMe ( unit ) ; begin
47621: LD_INT 0
47623: PPUSH
// result := See ( your_side , unit ) ;
47624: LD_ADDR_VAR 0 2
47628: PUSH
47629: LD_OWVAR 2
47633: PPUSH
47634: LD_VAR 0 1
47638: PPUSH
47639: CALL_OW 292
47643: ST_TO_ADDR
// end ;
47644: LD_VAR 0 2
47648: RET
// export function ReverseDir ( unit ) ; begin
47649: LD_INT 0
47651: PPUSH
// if not unit then
47652: LD_VAR 0 1
47656: NOT
47657: IFFALSE 47661
// exit ;
47659: GO 47684
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47661: LD_ADDR_VAR 0 2
47665: PUSH
47666: LD_VAR 0 1
47670: PPUSH
47671: CALL_OW 254
47675: PUSH
47676: LD_INT 3
47678: PLUS
47679: PUSH
47680: LD_INT 6
47682: MOD
47683: ST_TO_ADDR
// end ;
47684: LD_VAR 0 2
47688: RET
// export function ReverseArray ( array ) ; var i ; begin
47689: LD_INT 0
47691: PPUSH
47692: PPUSH
// if not array then
47693: LD_VAR 0 1
47697: NOT
47698: IFFALSE 47702
// exit ;
47700: GO 47757
// result := [ ] ;
47702: LD_ADDR_VAR 0 2
47706: PUSH
47707: EMPTY
47708: ST_TO_ADDR
// for i := array downto 1 do
47709: LD_ADDR_VAR 0 3
47713: PUSH
47714: DOUBLE
47715: LD_VAR 0 1
47719: INC
47720: ST_TO_ADDR
47721: LD_INT 1
47723: PUSH
47724: FOR_DOWNTO
47725: IFFALSE 47755
// result := Join ( result , array [ i ] ) ;
47727: LD_ADDR_VAR 0 2
47731: PUSH
47732: LD_VAR 0 2
47736: PPUSH
47737: LD_VAR 0 1
47741: PUSH
47742: LD_VAR 0 3
47746: ARRAY
47747: PPUSH
47748: CALL 52382 0 2
47752: ST_TO_ADDR
47753: GO 47724
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
// if not unit or not hexes then
47770: LD_VAR 0 1
47774: NOT
47775: PUSH
47776: LD_VAR 0 2
47780: NOT
47781: OR
47782: IFFALSE 47786
// exit ;
47784: GO 47909
// dist := 9999 ;
47786: LD_ADDR_VAR 0 5
47790: PUSH
47791: LD_INT 9999
47793: ST_TO_ADDR
// for i = 1 to hexes do
47794: LD_ADDR_VAR 0 4
47798: PUSH
47799: DOUBLE
47800: LD_INT 1
47802: DEC
47803: ST_TO_ADDR
47804: LD_VAR 0 2
47808: PUSH
47809: FOR_TO
47810: IFFALSE 47897
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47812: LD_ADDR_VAR 0 6
47816: PUSH
47817: LD_VAR 0 1
47821: PPUSH
47822: LD_VAR 0 2
47826: PUSH
47827: LD_VAR 0 4
47831: ARRAY
47832: PUSH
47833: LD_INT 1
47835: ARRAY
47836: PPUSH
47837: LD_VAR 0 2
47841: PUSH
47842: LD_VAR 0 4
47846: ARRAY
47847: PUSH
47848: LD_INT 2
47850: ARRAY
47851: PPUSH
47852: CALL_OW 297
47856: ST_TO_ADDR
// if tdist < dist then
47857: LD_VAR 0 6
47861: PUSH
47862: LD_VAR 0 5
47866: LESS
47867: IFFALSE 47895
// begin hex := hexes [ i ] ;
47869: LD_ADDR_VAR 0 8
47873: PUSH
47874: LD_VAR 0 2
47878: PUSH
47879: LD_VAR 0 4
47883: ARRAY
47884: ST_TO_ADDR
// dist := tdist ;
47885: LD_ADDR_VAR 0 5
47889: PUSH
47890: LD_VAR 0 6
47894: ST_TO_ADDR
// end ; end ;
47895: GO 47809
47897: POP
47898: POP
// result := hex ;
47899: LD_ADDR_VAR 0 3
47903: PUSH
47904: LD_VAR 0 8
47908: ST_TO_ADDR
// end ;
47909: LD_VAR 0 3
47913: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47914: LD_INT 0
47916: PPUSH
47917: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47918: LD_VAR 0 1
47922: NOT
47923: PUSH
47924: LD_VAR 0 1
47928: PUSH
47929: LD_INT 21
47931: PUSH
47932: LD_INT 2
47934: PUSH
47935: EMPTY
47936: LIST
47937: LIST
47938: PUSH
47939: LD_INT 23
47941: PUSH
47942: LD_INT 2
47944: PUSH
47945: EMPTY
47946: LIST
47947: LIST
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PPUSH
47953: CALL_OW 69
47957: IN
47958: NOT
47959: OR
47960: IFFALSE 47964
// exit ;
47962: GO 48011
// for i = 1 to 3 do
47964: LD_ADDR_VAR 0 3
47968: PUSH
47969: DOUBLE
47970: LD_INT 1
47972: DEC
47973: ST_TO_ADDR
47974: LD_INT 3
47976: PUSH
47977: FOR_TO
47978: IFFALSE 48009
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47980: LD_VAR 0 1
47984: PPUSH
47985: CALL_OW 250
47989: PPUSH
47990: LD_VAR 0 1
47994: PPUSH
47995: CALL_OW 251
47999: PPUSH
48000: LD_INT 1
48002: PPUSH
48003: CALL_OW 453
48007: GO 47977
48009: POP
48010: POP
// end ;
48011: LD_VAR 0 2
48015: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48016: LD_INT 0
48018: PPUSH
48019: PPUSH
48020: PPUSH
48021: PPUSH
48022: PPUSH
48023: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48024: LD_VAR 0 1
48028: NOT
48029: PUSH
48030: LD_VAR 0 2
48034: NOT
48035: OR
48036: PUSH
48037: LD_VAR 0 1
48041: PPUSH
48042: CALL_OW 314
48046: OR
48047: IFFALSE 48051
// exit ;
48049: GO 48492
// x := GetX ( enemy_unit ) ;
48051: LD_ADDR_VAR 0 7
48055: PUSH
48056: LD_VAR 0 2
48060: PPUSH
48061: CALL_OW 250
48065: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48066: LD_ADDR_VAR 0 8
48070: PUSH
48071: LD_VAR 0 2
48075: PPUSH
48076: CALL_OW 251
48080: ST_TO_ADDR
// if not x or not y then
48081: LD_VAR 0 7
48085: NOT
48086: PUSH
48087: LD_VAR 0 8
48091: NOT
48092: OR
48093: IFFALSE 48097
// exit ;
48095: GO 48492
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48097: LD_ADDR_VAR 0 6
48101: PUSH
48102: LD_VAR 0 7
48106: PPUSH
48107: LD_INT 0
48109: PPUSH
48110: LD_INT 4
48112: PPUSH
48113: CALL_OW 272
48117: PUSH
48118: LD_VAR 0 8
48122: PPUSH
48123: LD_INT 0
48125: PPUSH
48126: LD_INT 4
48128: PPUSH
48129: CALL_OW 273
48133: PUSH
48134: EMPTY
48135: LIST
48136: LIST
48137: PUSH
48138: LD_VAR 0 7
48142: PPUSH
48143: LD_INT 1
48145: PPUSH
48146: LD_INT 4
48148: PPUSH
48149: CALL_OW 272
48153: PUSH
48154: LD_VAR 0 8
48158: PPUSH
48159: LD_INT 1
48161: PPUSH
48162: LD_INT 4
48164: PPUSH
48165: CALL_OW 273
48169: PUSH
48170: EMPTY
48171: LIST
48172: LIST
48173: PUSH
48174: LD_VAR 0 7
48178: PPUSH
48179: LD_INT 2
48181: PPUSH
48182: LD_INT 4
48184: PPUSH
48185: CALL_OW 272
48189: PUSH
48190: LD_VAR 0 8
48194: PPUSH
48195: LD_INT 2
48197: PPUSH
48198: LD_INT 4
48200: PPUSH
48201: CALL_OW 273
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: PUSH
48210: LD_VAR 0 7
48214: PPUSH
48215: LD_INT 3
48217: PPUSH
48218: LD_INT 4
48220: PPUSH
48221: CALL_OW 272
48225: PUSH
48226: LD_VAR 0 8
48230: PPUSH
48231: LD_INT 3
48233: PPUSH
48234: LD_INT 4
48236: PPUSH
48237: CALL_OW 273
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: LD_VAR 0 7
48250: PPUSH
48251: LD_INT 4
48253: PPUSH
48254: LD_INT 4
48256: PPUSH
48257: CALL_OW 272
48261: PUSH
48262: LD_VAR 0 8
48266: PPUSH
48267: LD_INT 4
48269: PPUSH
48270: LD_INT 4
48272: PPUSH
48273: CALL_OW 273
48277: PUSH
48278: EMPTY
48279: LIST
48280: LIST
48281: PUSH
48282: LD_VAR 0 7
48286: PPUSH
48287: LD_INT 5
48289: PPUSH
48290: LD_INT 4
48292: PPUSH
48293: CALL_OW 272
48297: PUSH
48298: LD_VAR 0 8
48302: PPUSH
48303: LD_INT 5
48305: PPUSH
48306: LD_INT 4
48308: PPUSH
48309: CALL_OW 273
48313: PUSH
48314: EMPTY
48315: LIST
48316: LIST
48317: PUSH
48318: EMPTY
48319: LIST
48320: LIST
48321: LIST
48322: LIST
48323: LIST
48324: LIST
48325: ST_TO_ADDR
// for i = tmp downto 1 do
48326: LD_ADDR_VAR 0 4
48330: PUSH
48331: DOUBLE
48332: LD_VAR 0 6
48336: INC
48337: ST_TO_ADDR
48338: LD_INT 1
48340: PUSH
48341: FOR_DOWNTO
48342: IFFALSE 48443
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48344: LD_VAR 0 6
48348: PUSH
48349: LD_VAR 0 4
48353: ARRAY
48354: PUSH
48355: LD_INT 1
48357: ARRAY
48358: PPUSH
48359: LD_VAR 0 6
48363: PUSH
48364: LD_VAR 0 4
48368: ARRAY
48369: PUSH
48370: LD_INT 2
48372: ARRAY
48373: PPUSH
48374: CALL_OW 488
48378: NOT
48379: PUSH
48380: LD_VAR 0 6
48384: PUSH
48385: LD_VAR 0 4
48389: ARRAY
48390: PUSH
48391: LD_INT 1
48393: ARRAY
48394: PPUSH
48395: LD_VAR 0 6
48399: PUSH
48400: LD_VAR 0 4
48404: ARRAY
48405: PUSH
48406: LD_INT 2
48408: ARRAY
48409: PPUSH
48410: CALL_OW 428
48414: PUSH
48415: LD_INT 0
48417: NONEQUAL
48418: OR
48419: IFFALSE 48441
// tmp := Delete ( tmp , i ) ;
48421: LD_ADDR_VAR 0 6
48425: PUSH
48426: LD_VAR 0 6
48430: PPUSH
48431: LD_VAR 0 4
48435: PPUSH
48436: CALL_OW 3
48440: ST_TO_ADDR
48441: GO 48341
48443: POP
48444: POP
// j := GetClosestHex ( unit , tmp ) ;
48445: LD_ADDR_VAR 0 5
48449: PUSH
48450: LD_VAR 0 1
48454: PPUSH
48455: LD_VAR 0 6
48459: PPUSH
48460: CALL 47762 0 2
48464: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48465: LD_VAR 0 1
48469: PPUSH
48470: LD_VAR 0 5
48474: PUSH
48475: LD_INT 1
48477: ARRAY
48478: PPUSH
48479: LD_VAR 0 5
48483: PUSH
48484: LD_INT 2
48486: ARRAY
48487: PPUSH
48488: CALL_OW 111
// end ;
48492: LD_VAR 0 3
48496: RET
// export function PrepareApemanSoldier ( ) ; begin
48497: LD_INT 0
48499: PPUSH
// uc_nation := 0 ;
48500: LD_ADDR_OWVAR 21
48504: PUSH
48505: LD_INT 0
48507: ST_TO_ADDR
// hc_sex := sex_male ;
48508: LD_ADDR_OWVAR 27
48512: PUSH
48513: LD_INT 1
48515: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48516: LD_ADDR_OWVAR 28
48520: PUSH
48521: LD_INT 15
48523: ST_TO_ADDR
// hc_gallery :=  ;
48524: LD_ADDR_OWVAR 33
48528: PUSH
48529: LD_STRING 
48531: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48532: LD_ADDR_OWVAR 31
48536: PUSH
48537: LD_INT 0
48539: PPUSH
48540: LD_INT 3
48542: PPUSH
48543: CALL_OW 12
48547: PUSH
48548: LD_INT 0
48550: PPUSH
48551: LD_INT 3
48553: PPUSH
48554: CALL_OW 12
48558: PUSH
48559: LD_INT 0
48561: PUSH
48562: LD_INT 0
48564: PUSH
48565: EMPTY
48566: LIST
48567: LIST
48568: LIST
48569: LIST
48570: ST_TO_ADDR
// end ;
48571: LD_VAR 0 1
48575: RET
// export function PrepareApemanEngineer ( ) ; begin
48576: LD_INT 0
48578: PPUSH
// uc_nation := 0 ;
48579: LD_ADDR_OWVAR 21
48583: PUSH
48584: LD_INT 0
48586: ST_TO_ADDR
// hc_sex := sex_male ;
48587: LD_ADDR_OWVAR 27
48591: PUSH
48592: LD_INT 1
48594: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48595: LD_ADDR_OWVAR 28
48599: PUSH
48600: LD_INT 16
48602: ST_TO_ADDR
// hc_gallery :=  ;
48603: LD_ADDR_OWVAR 33
48607: PUSH
48608: LD_STRING 
48610: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48611: LD_ADDR_OWVAR 31
48615: PUSH
48616: LD_INT 0
48618: PPUSH
48619: LD_INT 3
48621: PPUSH
48622: CALL_OW 12
48626: PUSH
48627: LD_INT 0
48629: PPUSH
48630: LD_INT 3
48632: PPUSH
48633: CALL_OW 12
48637: PUSH
48638: LD_INT 0
48640: PUSH
48641: LD_INT 0
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: LIST
48648: LIST
48649: ST_TO_ADDR
// end ;
48650: LD_VAR 0 1
48654: RET
// export function PrepareApeman ( agressivity ) ; begin
48655: LD_INT 0
48657: PPUSH
// uc_side := 0 ;
48658: LD_ADDR_OWVAR 20
48662: PUSH
48663: LD_INT 0
48665: ST_TO_ADDR
// uc_nation := 0 ;
48666: LD_ADDR_OWVAR 21
48670: PUSH
48671: LD_INT 0
48673: ST_TO_ADDR
// hc_sex := sex_male ;
48674: LD_ADDR_OWVAR 27
48678: PUSH
48679: LD_INT 1
48681: ST_TO_ADDR
// hc_class := class_apeman ;
48682: LD_ADDR_OWVAR 28
48686: PUSH
48687: LD_INT 12
48689: ST_TO_ADDR
// hc_gallery :=  ;
48690: LD_ADDR_OWVAR 33
48694: PUSH
48695: LD_STRING 
48697: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48698: LD_ADDR_OWVAR 35
48702: PUSH
48703: LD_VAR 0 1
48707: NEG
48708: PPUSH
48709: LD_VAR 0 1
48713: PPUSH
48714: CALL_OW 12
48718: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48719: LD_ADDR_OWVAR 31
48723: PUSH
48724: LD_INT 0
48726: PPUSH
48727: LD_INT 3
48729: PPUSH
48730: CALL_OW 12
48734: PUSH
48735: LD_INT 0
48737: PPUSH
48738: LD_INT 3
48740: PPUSH
48741: CALL_OW 12
48745: PUSH
48746: LD_INT 0
48748: PUSH
48749: LD_INT 0
48751: PUSH
48752: EMPTY
48753: LIST
48754: LIST
48755: LIST
48756: LIST
48757: ST_TO_ADDR
// end ;
48758: LD_VAR 0 2
48762: RET
// export function PrepareTiger ( agressivity ) ; begin
48763: LD_INT 0
48765: PPUSH
// uc_side := 0 ;
48766: LD_ADDR_OWVAR 20
48770: PUSH
48771: LD_INT 0
48773: ST_TO_ADDR
// uc_nation := 0 ;
48774: LD_ADDR_OWVAR 21
48778: PUSH
48779: LD_INT 0
48781: ST_TO_ADDR
// hc_class := class_tiger ;
48782: LD_ADDR_OWVAR 28
48786: PUSH
48787: LD_INT 14
48789: ST_TO_ADDR
// hc_gallery :=  ;
48790: LD_ADDR_OWVAR 33
48794: PUSH
48795: LD_STRING 
48797: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48798: LD_ADDR_OWVAR 35
48802: PUSH
48803: LD_VAR 0 1
48807: NEG
48808: PPUSH
48809: LD_VAR 0 1
48813: PPUSH
48814: CALL_OW 12
48818: ST_TO_ADDR
// end ;
48819: LD_VAR 0 2
48823: RET
// export function PrepareEnchidna ( ) ; begin
48824: LD_INT 0
48826: PPUSH
// uc_side := 0 ;
48827: LD_ADDR_OWVAR 20
48831: PUSH
48832: LD_INT 0
48834: ST_TO_ADDR
// uc_nation := 0 ;
48835: LD_ADDR_OWVAR 21
48839: PUSH
48840: LD_INT 0
48842: ST_TO_ADDR
// hc_class := class_baggie ;
48843: LD_ADDR_OWVAR 28
48847: PUSH
48848: LD_INT 13
48850: ST_TO_ADDR
// hc_gallery :=  ;
48851: LD_ADDR_OWVAR 33
48855: PUSH
48856: LD_STRING 
48858: ST_TO_ADDR
// end ;
48859: LD_VAR 0 1
48863: RET
// export function PrepareFrog ( ) ; begin
48864: LD_INT 0
48866: PPUSH
// uc_side := 0 ;
48867: LD_ADDR_OWVAR 20
48871: PUSH
48872: LD_INT 0
48874: ST_TO_ADDR
// uc_nation := 0 ;
48875: LD_ADDR_OWVAR 21
48879: PUSH
48880: LD_INT 0
48882: ST_TO_ADDR
// hc_class := class_frog ;
48883: LD_ADDR_OWVAR 28
48887: PUSH
48888: LD_INT 19
48890: ST_TO_ADDR
// hc_gallery :=  ;
48891: LD_ADDR_OWVAR 33
48895: PUSH
48896: LD_STRING 
48898: ST_TO_ADDR
// end ;
48899: LD_VAR 0 1
48903: RET
// export function PrepareFish ( ) ; begin
48904: LD_INT 0
48906: PPUSH
// uc_side := 0 ;
48907: LD_ADDR_OWVAR 20
48911: PUSH
48912: LD_INT 0
48914: ST_TO_ADDR
// uc_nation := 0 ;
48915: LD_ADDR_OWVAR 21
48919: PUSH
48920: LD_INT 0
48922: ST_TO_ADDR
// hc_class := class_fish ;
48923: LD_ADDR_OWVAR 28
48927: PUSH
48928: LD_INT 20
48930: ST_TO_ADDR
// hc_gallery :=  ;
48931: LD_ADDR_OWVAR 33
48935: PUSH
48936: LD_STRING 
48938: ST_TO_ADDR
// end ;
48939: LD_VAR 0 1
48943: RET
// export function PrepareBird ( ) ; begin
48944: LD_INT 0
48946: PPUSH
// uc_side := 0 ;
48947: LD_ADDR_OWVAR 20
48951: PUSH
48952: LD_INT 0
48954: ST_TO_ADDR
// uc_nation := 0 ;
48955: LD_ADDR_OWVAR 21
48959: PUSH
48960: LD_INT 0
48962: ST_TO_ADDR
// hc_class := class_phororhacos ;
48963: LD_ADDR_OWVAR 28
48967: PUSH
48968: LD_INT 18
48970: ST_TO_ADDR
// hc_gallery :=  ;
48971: LD_ADDR_OWVAR 33
48975: PUSH
48976: LD_STRING 
48978: ST_TO_ADDR
// end ;
48979: LD_VAR 0 1
48983: RET
// export function PrepareHorse ( ) ; begin
48984: LD_INT 0
48986: PPUSH
// uc_side := 0 ;
48987: LD_ADDR_OWVAR 20
48991: PUSH
48992: LD_INT 0
48994: ST_TO_ADDR
// uc_nation := 0 ;
48995: LD_ADDR_OWVAR 21
48999: PUSH
49000: LD_INT 0
49002: ST_TO_ADDR
// hc_class := class_horse ;
49003: LD_ADDR_OWVAR 28
49007: PUSH
49008: LD_INT 21
49010: ST_TO_ADDR
// hc_gallery :=  ;
49011: LD_ADDR_OWVAR 33
49015: PUSH
49016: LD_STRING 
49018: ST_TO_ADDR
// end ;
49019: LD_VAR 0 1
49023: RET
// export function PrepareMastodont ( ) ; begin
49024: LD_INT 0
49026: PPUSH
// uc_side := 0 ;
49027: LD_ADDR_OWVAR 20
49031: PUSH
49032: LD_INT 0
49034: ST_TO_ADDR
// uc_nation := 0 ;
49035: LD_ADDR_OWVAR 21
49039: PUSH
49040: LD_INT 0
49042: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49043: LD_ADDR_OWVAR 37
49047: PUSH
49048: LD_INT 31
49050: ST_TO_ADDR
// vc_control := control_rider ;
49051: LD_ADDR_OWVAR 38
49055: PUSH
49056: LD_INT 4
49058: ST_TO_ADDR
// end ;
49059: LD_VAR 0 1
49063: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49064: LD_INT 0
49066: PPUSH
49067: PPUSH
49068: PPUSH
// uc_side = 0 ;
49069: LD_ADDR_OWVAR 20
49073: PUSH
49074: LD_INT 0
49076: ST_TO_ADDR
// uc_nation = 0 ;
49077: LD_ADDR_OWVAR 21
49081: PUSH
49082: LD_INT 0
49084: ST_TO_ADDR
// InitHc_All ( ) ;
49085: CALL_OW 584
// InitVc ;
49089: CALL_OW 20
// if mastodonts then
49093: LD_VAR 0 6
49097: IFFALSE 49164
// for i = 1 to mastodonts do
49099: LD_ADDR_VAR 0 11
49103: PUSH
49104: DOUBLE
49105: LD_INT 1
49107: DEC
49108: ST_TO_ADDR
49109: LD_VAR 0 6
49113: PUSH
49114: FOR_TO
49115: IFFALSE 49162
// begin vc_chassis := 31 ;
49117: LD_ADDR_OWVAR 37
49121: PUSH
49122: LD_INT 31
49124: ST_TO_ADDR
// vc_control := control_rider ;
49125: LD_ADDR_OWVAR 38
49129: PUSH
49130: LD_INT 4
49132: ST_TO_ADDR
// animal := CreateVehicle ;
49133: LD_ADDR_VAR 0 12
49137: PUSH
49138: CALL_OW 45
49142: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49143: LD_VAR 0 12
49147: PPUSH
49148: LD_VAR 0 8
49152: PPUSH
49153: LD_INT 0
49155: PPUSH
49156: CALL 51299 0 3
// end ;
49160: GO 49114
49162: POP
49163: POP
// if horses then
49164: LD_VAR 0 5
49168: IFFALSE 49235
// for i = 1 to horses do
49170: LD_ADDR_VAR 0 11
49174: PUSH
49175: DOUBLE
49176: LD_INT 1
49178: DEC
49179: ST_TO_ADDR
49180: LD_VAR 0 5
49184: PUSH
49185: FOR_TO
49186: IFFALSE 49233
// begin hc_class := 21 ;
49188: LD_ADDR_OWVAR 28
49192: PUSH
49193: LD_INT 21
49195: ST_TO_ADDR
// hc_gallery :=  ;
49196: LD_ADDR_OWVAR 33
49200: PUSH
49201: LD_STRING 
49203: ST_TO_ADDR
// animal := CreateHuman ;
49204: LD_ADDR_VAR 0 12
49208: PUSH
49209: CALL_OW 44
49213: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49214: LD_VAR 0 12
49218: PPUSH
49219: LD_VAR 0 8
49223: PPUSH
49224: LD_INT 0
49226: PPUSH
49227: CALL 51299 0 3
// end ;
49231: GO 49185
49233: POP
49234: POP
// if birds then
49235: LD_VAR 0 1
49239: IFFALSE 49306
// for i = 1 to birds do
49241: LD_ADDR_VAR 0 11
49245: PUSH
49246: DOUBLE
49247: LD_INT 1
49249: DEC
49250: ST_TO_ADDR
49251: LD_VAR 0 1
49255: PUSH
49256: FOR_TO
49257: IFFALSE 49304
// begin hc_class = 18 ;
49259: LD_ADDR_OWVAR 28
49263: PUSH
49264: LD_INT 18
49266: ST_TO_ADDR
// hc_gallery =  ;
49267: LD_ADDR_OWVAR 33
49271: PUSH
49272: LD_STRING 
49274: ST_TO_ADDR
// animal := CreateHuman ;
49275: LD_ADDR_VAR 0 12
49279: PUSH
49280: CALL_OW 44
49284: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49285: LD_VAR 0 12
49289: PPUSH
49290: LD_VAR 0 8
49294: PPUSH
49295: LD_INT 0
49297: PPUSH
49298: CALL 51299 0 3
// end ;
49302: GO 49256
49304: POP
49305: POP
// if tigers then
49306: LD_VAR 0 2
49310: IFFALSE 49394
// for i = 1 to tigers do
49312: LD_ADDR_VAR 0 11
49316: PUSH
49317: DOUBLE
49318: LD_INT 1
49320: DEC
49321: ST_TO_ADDR
49322: LD_VAR 0 2
49326: PUSH
49327: FOR_TO
49328: IFFALSE 49392
// begin hc_class = class_tiger ;
49330: LD_ADDR_OWVAR 28
49334: PUSH
49335: LD_INT 14
49337: ST_TO_ADDR
// hc_gallery =  ;
49338: LD_ADDR_OWVAR 33
49342: PUSH
49343: LD_STRING 
49345: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49346: LD_ADDR_OWVAR 35
49350: PUSH
49351: LD_INT 7
49353: NEG
49354: PPUSH
49355: LD_INT 7
49357: PPUSH
49358: CALL_OW 12
49362: ST_TO_ADDR
// animal := CreateHuman ;
49363: LD_ADDR_VAR 0 12
49367: PUSH
49368: CALL_OW 44
49372: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49373: LD_VAR 0 12
49377: PPUSH
49378: LD_VAR 0 8
49382: PPUSH
49383: LD_INT 0
49385: PPUSH
49386: CALL 51299 0 3
// end ;
49390: GO 49327
49392: POP
49393: POP
// if apemans then
49394: LD_VAR 0 3
49398: IFFALSE 49521
// for i = 1 to apemans do
49400: LD_ADDR_VAR 0 11
49404: PUSH
49405: DOUBLE
49406: LD_INT 1
49408: DEC
49409: ST_TO_ADDR
49410: LD_VAR 0 3
49414: PUSH
49415: FOR_TO
49416: IFFALSE 49519
// begin hc_class = class_apeman ;
49418: LD_ADDR_OWVAR 28
49422: PUSH
49423: LD_INT 12
49425: ST_TO_ADDR
// hc_gallery =  ;
49426: LD_ADDR_OWVAR 33
49430: PUSH
49431: LD_STRING 
49433: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49434: LD_ADDR_OWVAR 35
49438: PUSH
49439: LD_INT 2
49441: NEG
49442: PPUSH
49443: LD_INT 2
49445: PPUSH
49446: CALL_OW 12
49450: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49451: LD_ADDR_OWVAR 31
49455: PUSH
49456: LD_INT 1
49458: PPUSH
49459: LD_INT 3
49461: PPUSH
49462: CALL_OW 12
49466: PUSH
49467: LD_INT 1
49469: PPUSH
49470: LD_INT 3
49472: PPUSH
49473: CALL_OW 12
49477: PUSH
49478: LD_INT 0
49480: PUSH
49481: LD_INT 0
49483: PUSH
49484: EMPTY
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: ST_TO_ADDR
// animal := CreateHuman ;
49490: LD_ADDR_VAR 0 12
49494: PUSH
49495: CALL_OW 44
49499: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49500: LD_VAR 0 12
49504: PPUSH
49505: LD_VAR 0 8
49509: PPUSH
49510: LD_INT 0
49512: PPUSH
49513: CALL 51299 0 3
// end ;
49517: GO 49415
49519: POP
49520: POP
// if enchidnas then
49521: LD_VAR 0 4
49525: IFFALSE 49592
// for i = 1 to enchidnas do
49527: LD_ADDR_VAR 0 11
49531: PUSH
49532: DOUBLE
49533: LD_INT 1
49535: DEC
49536: ST_TO_ADDR
49537: LD_VAR 0 4
49541: PUSH
49542: FOR_TO
49543: IFFALSE 49590
// begin hc_class = 13 ;
49545: LD_ADDR_OWVAR 28
49549: PUSH
49550: LD_INT 13
49552: ST_TO_ADDR
// hc_gallery =  ;
49553: LD_ADDR_OWVAR 33
49557: PUSH
49558: LD_STRING 
49560: ST_TO_ADDR
// animal := CreateHuman ;
49561: LD_ADDR_VAR 0 12
49565: PUSH
49566: CALL_OW 44
49570: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49571: LD_VAR 0 12
49575: PPUSH
49576: LD_VAR 0 8
49580: PPUSH
49581: LD_INT 0
49583: PPUSH
49584: CALL 51299 0 3
// end ;
49588: GO 49542
49590: POP
49591: POP
// if fishes then
49592: LD_VAR 0 7
49596: IFFALSE 49663
// for i = 1 to fishes do
49598: LD_ADDR_VAR 0 11
49602: PUSH
49603: DOUBLE
49604: LD_INT 1
49606: DEC
49607: ST_TO_ADDR
49608: LD_VAR 0 7
49612: PUSH
49613: FOR_TO
49614: IFFALSE 49661
// begin hc_class = 20 ;
49616: LD_ADDR_OWVAR 28
49620: PUSH
49621: LD_INT 20
49623: ST_TO_ADDR
// hc_gallery =  ;
49624: LD_ADDR_OWVAR 33
49628: PUSH
49629: LD_STRING 
49631: ST_TO_ADDR
// animal := CreateHuman ;
49632: LD_ADDR_VAR 0 12
49636: PUSH
49637: CALL_OW 44
49641: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49642: LD_VAR 0 12
49646: PPUSH
49647: LD_VAR 0 9
49651: PPUSH
49652: LD_INT 0
49654: PPUSH
49655: CALL 51299 0 3
// end ;
49659: GO 49613
49661: POP
49662: POP
// end ;
49663: LD_VAR 0 10
49667: RET
// export function WantHeal ( sci , unit ) ; begin
49668: LD_INT 0
49670: PPUSH
// if GetTaskList ( sci ) > 0 then
49671: LD_VAR 0 1
49675: PPUSH
49676: CALL_OW 437
49680: PUSH
49681: LD_INT 0
49683: GREATER
49684: IFFALSE 49754
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49686: LD_VAR 0 1
49690: PPUSH
49691: CALL_OW 437
49695: PUSH
49696: LD_INT 1
49698: ARRAY
49699: PUSH
49700: LD_INT 1
49702: ARRAY
49703: PUSH
49704: LD_STRING l
49706: EQUAL
49707: PUSH
49708: LD_VAR 0 1
49712: PPUSH
49713: CALL_OW 437
49717: PUSH
49718: LD_INT 1
49720: ARRAY
49721: PUSH
49722: LD_INT 4
49724: ARRAY
49725: PUSH
49726: LD_VAR 0 2
49730: EQUAL
49731: AND
49732: IFFALSE 49744
// result := true else
49734: LD_ADDR_VAR 0 3
49738: PUSH
49739: LD_INT 1
49741: ST_TO_ADDR
49742: GO 49752
// result := false ;
49744: LD_ADDR_VAR 0 3
49748: PUSH
49749: LD_INT 0
49751: ST_TO_ADDR
// end else
49752: GO 49762
// result := false ;
49754: LD_ADDR_VAR 0 3
49758: PUSH
49759: LD_INT 0
49761: ST_TO_ADDR
// end ;
49762: LD_VAR 0 3
49766: RET
// export function HealTarget ( sci ) ; begin
49767: LD_INT 0
49769: PPUSH
// if not sci then
49770: LD_VAR 0 1
49774: NOT
49775: IFFALSE 49779
// exit ;
49777: GO 49844
// result := 0 ;
49779: LD_ADDR_VAR 0 2
49783: PUSH
49784: LD_INT 0
49786: ST_TO_ADDR
// if GetTaskList ( sci ) then
49787: LD_VAR 0 1
49791: PPUSH
49792: CALL_OW 437
49796: IFFALSE 49844
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49798: LD_VAR 0 1
49802: PPUSH
49803: CALL_OW 437
49807: PUSH
49808: LD_INT 1
49810: ARRAY
49811: PUSH
49812: LD_INT 1
49814: ARRAY
49815: PUSH
49816: LD_STRING l
49818: EQUAL
49819: IFFALSE 49844
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49821: LD_ADDR_VAR 0 2
49825: PUSH
49826: LD_VAR 0 1
49830: PPUSH
49831: CALL_OW 437
49835: PUSH
49836: LD_INT 1
49838: ARRAY
49839: PUSH
49840: LD_INT 4
49842: ARRAY
49843: ST_TO_ADDR
// end ;
49844: LD_VAR 0 2
49848: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49849: LD_INT 0
49851: PPUSH
49852: PPUSH
49853: PPUSH
49854: PPUSH
// if not base_units then
49855: LD_VAR 0 1
49859: NOT
49860: IFFALSE 49864
// exit ;
49862: GO 49951
// result := false ;
49864: LD_ADDR_VAR 0 2
49868: PUSH
49869: LD_INT 0
49871: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49872: LD_ADDR_VAR 0 5
49876: PUSH
49877: LD_VAR 0 1
49881: PPUSH
49882: LD_INT 21
49884: PUSH
49885: LD_INT 3
49887: PUSH
49888: EMPTY
49889: LIST
49890: LIST
49891: PPUSH
49892: CALL_OW 72
49896: ST_TO_ADDR
// if not tmp then
49897: LD_VAR 0 5
49901: NOT
49902: IFFALSE 49906
// exit ;
49904: GO 49951
// for i in tmp do
49906: LD_ADDR_VAR 0 3
49910: PUSH
49911: LD_VAR 0 5
49915: PUSH
49916: FOR_IN
49917: IFFALSE 49949
// begin result := EnemyInRange ( i , 22 ) ;
49919: LD_ADDR_VAR 0 2
49923: PUSH
49924: LD_VAR 0 3
49928: PPUSH
49929: LD_INT 22
49931: PPUSH
49932: CALL 47564 0 2
49936: ST_TO_ADDR
// if result then
49937: LD_VAR 0 2
49941: IFFALSE 49947
// exit ;
49943: POP
49944: POP
49945: GO 49951
// end ;
49947: GO 49916
49949: POP
49950: POP
// end ;
49951: LD_VAR 0 2
49955: RET
// export function FilterByTag ( units , tag ) ; begin
49956: LD_INT 0
49958: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49959: LD_ADDR_VAR 0 3
49963: PUSH
49964: LD_VAR 0 1
49968: PPUSH
49969: LD_INT 120
49971: PUSH
49972: LD_VAR 0 2
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: PPUSH
49981: CALL_OW 72
49985: ST_TO_ADDR
// end ;
49986: LD_VAR 0 3
49990: RET
// export function IsDriver ( un ) ; begin
49991: LD_INT 0
49993: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49994: LD_ADDR_VAR 0 2
49998: PUSH
49999: LD_VAR 0 1
50003: PUSH
50004: LD_INT 55
50006: PUSH
50007: EMPTY
50008: LIST
50009: PPUSH
50010: CALL_OW 69
50014: IN
50015: ST_TO_ADDR
// end ;
50016: LD_VAR 0 2
50020: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50021: LD_INT 0
50023: PPUSH
50024: PPUSH
// list := [ ] ;
50025: LD_ADDR_VAR 0 5
50029: PUSH
50030: EMPTY
50031: ST_TO_ADDR
// case d of 0 :
50032: LD_VAR 0 3
50036: PUSH
50037: LD_INT 0
50039: DOUBLE
50040: EQUAL
50041: IFTRUE 50045
50043: GO 50178
50045: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50046: LD_ADDR_VAR 0 5
50050: PUSH
50051: LD_VAR 0 1
50055: PUSH
50056: LD_INT 4
50058: MINUS
50059: PUSH
50060: LD_VAR 0 2
50064: PUSH
50065: LD_INT 4
50067: MINUS
50068: PUSH
50069: LD_INT 2
50071: PUSH
50072: EMPTY
50073: LIST
50074: LIST
50075: LIST
50076: PUSH
50077: LD_VAR 0 1
50081: PUSH
50082: LD_INT 3
50084: MINUS
50085: PUSH
50086: LD_VAR 0 2
50090: PUSH
50091: LD_INT 1
50093: PUSH
50094: EMPTY
50095: LIST
50096: LIST
50097: LIST
50098: PUSH
50099: LD_VAR 0 1
50103: PUSH
50104: LD_INT 4
50106: PLUS
50107: PUSH
50108: LD_VAR 0 2
50112: PUSH
50113: LD_INT 4
50115: PUSH
50116: EMPTY
50117: LIST
50118: LIST
50119: LIST
50120: PUSH
50121: LD_VAR 0 1
50125: PUSH
50126: LD_INT 3
50128: PLUS
50129: PUSH
50130: LD_VAR 0 2
50134: PUSH
50135: LD_INT 3
50137: PLUS
50138: PUSH
50139: LD_INT 5
50141: PUSH
50142: EMPTY
50143: LIST
50144: LIST
50145: LIST
50146: PUSH
50147: LD_VAR 0 1
50151: PUSH
50152: LD_VAR 0 2
50156: PUSH
50157: LD_INT 4
50159: PLUS
50160: PUSH
50161: LD_INT 0
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: LIST
50168: PUSH
50169: EMPTY
50170: LIST
50171: LIST
50172: LIST
50173: LIST
50174: LIST
50175: ST_TO_ADDR
// end ; 1 :
50176: GO 50876
50178: LD_INT 1
50180: DOUBLE
50181: EQUAL
50182: IFTRUE 50186
50184: GO 50319
50186: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50187: LD_ADDR_VAR 0 5
50191: PUSH
50192: LD_VAR 0 1
50196: PUSH
50197: LD_VAR 0 2
50201: PUSH
50202: LD_INT 4
50204: MINUS
50205: PUSH
50206: LD_INT 3
50208: PUSH
50209: EMPTY
50210: LIST
50211: LIST
50212: LIST
50213: PUSH
50214: LD_VAR 0 1
50218: PUSH
50219: LD_INT 3
50221: MINUS
50222: PUSH
50223: LD_VAR 0 2
50227: PUSH
50228: LD_INT 3
50230: MINUS
50231: PUSH
50232: LD_INT 2
50234: PUSH
50235: EMPTY
50236: LIST
50237: LIST
50238: LIST
50239: PUSH
50240: LD_VAR 0 1
50244: PUSH
50245: LD_INT 4
50247: MINUS
50248: PUSH
50249: LD_VAR 0 2
50253: PUSH
50254: LD_INT 1
50256: PUSH
50257: EMPTY
50258: LIST
50259: LIST
50260: LIST
50261: PUSH
50262: LD_VAR 0 1
50266: PUSH
50267: LD_VAR 0 2
50271: PUSH
50272: LD_INT 3
50274: PLUS
50275: PUSH
50276: LD_INT 0
50278: PUSH
50279: EMPTY
50280: LIST
50281: LIST
50282: LIST
50283: PUSH
50284: LD_VAR 0 1
50288: PUSH
50289: LD_INT 4
50291: PLUS
50292: PUSH
50293: LD_VAR 0 2
50297: PUSH
50298: LD_INT 4
50300: PLUS
50301: PUSH
50302: LD_INT 5
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: LIST
50309: PUSH
50310: EMPTY
50311: LIST
50312: LIST
50313: LIST
50314: LIST
50315: LIST
50316: ST_TO_ADDR
// end ; 2 :
50317: GO 50876
50319: LD_INT 2
50321: DOUBLE
50322: EQUAL
50323: IFTRUE 50327
50325: GO 50456
50327: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50328: LD_ADDR_VAR 0 5
50332: PUSH
50333: LD_VAR 0 1
50337: PUSH
50338: LD_VAR 0 2
50342: PUSH
50343: LD_INT 3
50345: MINUS
50346: PUSH
50347: LD_INT 3
50349: PUSH
50350: EMPTY
50351: LIST
50352: LIST
50353: LIST
50354: PUSH
50355: LD_VAR 0 1
50359: PUSH
50360: LD_INT 4
50362: PLUS
50363: PUSH
50364: LD_VAR 0 2
50368: PUSH
50369: LD_INT 4
50371: PUSH
50372: EMPTY
50373: LIST
50374: LIST
50375: LIST
50376: PUSH
50377: LD_VAR 0 1
50381: PUSH
50382: LD_VAR 0 2
50386: PUSH
50387: LD_INT 4
50389: PLUS
50390: PUSH
50391: LD_INT 0
50393: PUSH
50394: EMPTY
50395: LIST
50396: LIST
50397: LIST
50398: PUSH
50399: LD_VAR 0 1
50403: PUSH
50404: LD_INT 3
50406: MINUS
50407: PUSH
50408: LD_VAR 0 2
50412: PUSH
50413: LD_INT 1
50415: PUSH
50416: EMPTY
50417: LIST
50418: LIST
50419: LIST
50420: PUSH
50421: LD_VAR 0 1
50425: PUSH
50426: LD_INT 4
50428: MINUS
50429: PUSH
50430: LD_VAR 0 2
50434: PUSH
50435: LD_INT 4
50437: MINUS
50438: PUSH
50439: LD_INT 2
50441: PUSH
50442: EMPTY
50443: LIST
50444: LIST
50445: LIST
50446: PUSH
50447: EMPTY
50448: LIST
50449: LIST
50450: LIST
50451: LIST
50452: LIST
50453: ST_TO_ADDR
// end ; 3 :
50454: GO 50876
50456: LD_INT 3
50458: DOUBLE
50459: EQUAL
50460: IFTRUE 50464
50462: GO 50597
50464: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50465: LD_ADDR_VAR 0 5
50469: PUSH
50470: LD_VAR 0 1
50474: PUSH
50475: LD_INT 3
50477: PLUS
50478: PUSH
50479: LD_VAR 0 2
50483: PUSH
50484: LD_INT 4
50486: PUSH
50487: EMPTY
50488: LIST
50489: LIST
50490: LIST
50491: PUSH
50492: LD_VAR 0 1
50496: PUSH
50497: LD_INT 4
50499: PLUS
50500: PUSH
50501: LD_VAR 0 2
50505: PUSH
50506: LD_INT 4
50508: PLUS
50509: PUSH
50510: LD_INT 5
50512: PUSH
50513: EMPTY
50514: LIST
50515: LIST
50516: LIST
50517: PUSH
50518: LD_VAR 0 1
50522: PUSH
50523: LD_INT 4
50525: MINUS
50526: PUSH
50527: LD_VAR 0 2
50531: PUSH
50532: LD_INT 1
50534: PUSH
50535: EMPTY
50536: LIST
50537: LIST
50538: LIST
50539: PUSH
50540: LD_VAR 0 1
50544: PUSH
50545: LD_VAR 0 2
50549: PUSH
50550: LD_INT 4
50552: MINUS
50553: PUSH
50554: LD_INT 3
50556: PUSH
50557: EMPTY
50558: LIST
50559: LIST
50560: LIST
50561: PUSH
50562: LD_VAR 0 1
50566: PUSH
50567: LD_INT 3
50569: MINUS
50570: PUSH
50571: LD_VAR 0 2
50575: PUSH
50576: LD_INT 3
50578: MINUS
50579: PUSH
50580: LD_INT 2
50582: PUSH
50583: EMPTY
50584: LIST
50585: LIST
50586: LIST
50587: PUSH
50588: EMPTY
50589: LIST
50590: LIST
50591: LIST
50592: LIST
50593: LIST
50594: ST_TO_ADDR
// end ; 4 :
50595: GO 50876
50597: LD_INT 4
50599: DOUBLE
50600: EQUAL
50601: IFTRUE 50605
50603: GO 50738
50605: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50606: LD_ADDR_VAR 0 5
50610: PUSH
50611: LD_VAR 0 1
50615: PUSH
50616: LD_VAR 0 2
50620: PUSH
50621: LD_INT 4
50623: PLUS
50624: PUSH
50625: LD_INT 0
50627: PUSH
50628: EMPTY
50629: LIST
50630: LIST
50631: LIST
50632: PUSH
50633: LD_VAR 0 1
50637: PUSH
50638: LD_INT 3
50640: PLUS
50641: PUSH
50642: LD_VAR 0 2
50646: PUSH
50647: LD_INT 3
50649: PLUS
50650: PUSH
50651: LD_INT 5
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: LIST
50658: PUSH
50659: LD_VAR 0 1
50663: PUSH
50664: LD_INT 4
50666: PLUS
50667: PUSH
50668: LD_VAR 0 2
50672: PUSH
50673: LD_INT 4
50675: PUSH
50676: EMPTY
50677: LIST
50678: LIST
50679: LIST
50680: PUSH
50681: LD_VAR 0 1
50685: PUSH
50686: LD_VAR 0 2
50690: PUSH
50691: LD_INT 3
50693: MINUS
50694: PUSH
50695: LD_INT 3
50697: PUSH
50698: EMPTY
50699: LIST
50700: LIST
50701: LIST
50702: PUSH
50703: LD_VAR 0 1
50707: PUSH
50708: LD_INT 4
50710: MINUS
50711: PUSH
50712: LD_VAR 0 2
50716: PUSH
50717: LD_INT 4
50719: MINUS
50720: PUSH
50721: LD_INT 2
50723: PUSH
50724: EMPTY
50725: LIST
50726: LIST
50727: LIST
50728: PUSH
50729: EMPTY
50730: LIST
50731: LIST
50732: LIST
50733: LIST
50734: LIST
50735: ST_TO_ADDR
// end ; 5 :
50736: GO 50876
50738: LD_INT 5
50740: DOUBLE
50741: EQUAL
50742: IFTRUE 50746
50744: GO 50875
50746: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50747: LD_ADDR_VAR 0 5
50751: PUSH
50752: LD_VAR 0 1
50756: PUSH
50757: LD_INT 4
50759: MINUS
50760: PUSH
50761: LD_VAR 0 2
50765: PUSH
50766: LD_INT 1
50768: PUSH
50769: EMPTY
50770: LIST
50771: LIST
50772: LIST
50773: PUSH
50774: LD_VAR 0 1
50778: PUSH
50779: LD_VAR 0 2
50783: PUSH
50784: LD_INT 4
50786: MINUS
50787: PUSH
50788: LD_INT 3
50790: PUSH
50791: EMPTY
50792: LIST
50793: LIST
50794: LIST
50795: PUSH
50796: LD_VAR 0 1
50800: PUSH
50801: LD_INT 4
50803: PLUS
50804: PUSH
50805: LD_VAR 0 2
50809: PUSH
50810: LD_INT 4
50812: PLUS
50813: PUSH
50814: LD_INT 5
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: LIST
50821: PUSH
50822: LD_VAR 0 1
50826: PUSH
50827: LD_INT 3
50829: PLUS
50830: PUSH
50831: LD_VAR 0 2
50835: PUSH
50836: LD_INT 4
50838: PUSH
50839: EMPTY
50840: LIST
50841: LIST
50842: LIST
50843: PUSH
50844: LD_VAR 0 1
50848: PUSH
50849: LD_VAR 0 2
50853: PUSH
50854: LD_INT 3
50856: PLUS
50857: PUSH
50858: LD_INT 0
50860: PUSH
50861: EMPTY
50862: LIST
50863: LIST
50864: LIST
50865: PUSH
50866: EMPTY
50867: LIST
50868: LIST
50869: LIST
50870: LIST
50871: LIST
50872: ST_TO_ADDR
// end ; end ;
50873: GO 50876
50875: POP
// result := list ;
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: LD_VAR 0 5
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 4
50890: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50896: LD_VAR 0 1
50900: NOT
50901: PUSH
50902: LD_VAR 0 2
50906: PUSH
50907: LD_INT 1
50909: PUSH
50910: LD_INT 2
50912: PUSH
50913: LD_INT 3
50915: PUSH
50916: LD_INT 4
50918: PUSH
50919: EMPTY
50920: LIST
50921: LIST
50922: LIST
50923: LIST
50924: IN
50925: NOT
50926: OR
50927: IFFALSE 50931
// exit ;
50929: GO 51023
// tmp := [ ] ;
50931: LD_ADDR_VAR 0 5
50935: PUSH
50936: EMPTY
50937: ST_TO_ADDR
// for i in units do
50938: LD_ADDR_VAR 0 4
50942: PUSH
50943: LD_VAR 0 1
50947: PUSH
50948: FOR_IN
50949: IFFALSE 50992
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50951: LD_ADDR_VAR 0 5
50955: PUSH
50956: LD_VAR 0 5
50960: PPUSH
50961: LD_VAR 0 5
50965: PUSH
50966: LD_INT 1
50968: PLUS
50969: PPUSH
50970: LD_VAR 0 4
50974: PPUSH
50975: LD_VAR 0 2
50979: PPUSH
50980: CALL_OW 259
50984: PPUSH
50985: CALL_OW 2
50989: ST_TO_ADDR
50990: GO 50948
50992: POP
50993: POP
// if not tmp then
50994: LD_VAR 0 5
50998: NOT
50999: IFFALSE 51003
// exit ;
51001: GO 51023
// result := SortListByListDesc ( units , tmp ) ;
51003: LD_ADDR_VAR 0 3
51007: PUSH
51008: LD_VAR 0 1
51012: PPUSH
51013: LD_VAR 0 5
51017: PPUSH
51018: CALL_OW 77
51022: ST_TO_ADDR
// end ;
51023: LD_VAR 0 3
51027: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51028: LD_INT 0
51030: PPUSH
51031: PPUSH
51032: PPUSH
// result := false ;
51033: LD_ADDR_VAR 0 3
51037: PUSH
51038: LD_INT 0
51040: ST_TO_ADDR
// x := GetX ( building ) ;
51041: LD_ADDR_VAR 0 4
51045: PUSH
51046: LD_VAR 0 2
51050: PPUSH
51051: CALL_OW 250
51055: ST_TO_ADDR
// y := GetY ( building ) ;
51056: LD_ADDR_VAR 0 5
51060: PUSH
51061: LD_VAR 0 2
51065: PPUSH
51066: CALL_OW 251
51070: ST_TO_ADDR
// if not building or not x or not y then
51071: LD_VAR 0 2
51075: NOT
51076: PUSH
51077: LD_VAR 0 4
51081: NOT
51082: OR
51083: PUSH
51084: LD_VAR 0 5
51088: NOT
51089: OR
51090: IFFALSE 51094
// exit ;
51092: GO 51186
// if GetTaskList ( unit ) then
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 437
51103: IFFALSE 51186
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51105: LD_STRING e
51107: PUSH
51108: LD_VAR 0 1
51112: PPUSH
51113: CALL_OW 437
51117: PUSH
51118: LD_INT 1
51120: ARRAY
51121: PUSH
51122: LD_INT 1
51124: ARRAY
51125: EQUAL
51126: PUSH
51127: LD_VAR 0 4
51131: PUSH
51132: LD_VAR 0 1
51136: PPUSH
51137: CALL_OW 437
51141: PUSH
51142: LD_INT 1
51144: ARRAY
51145: PUSH
51146: LD_INT 2
51148: ARRAY
51149: EQUAL
51150: AND
51151: PUSH
51152: LD_VAR 0 5
51156: PUSH
51157: LD_VAR 0 1
51161: PPUSH
51162: CALL_OW 437
51166: PUSH
51167: LD_INT 1
51169: ARRAY
51170: PUSH
51171: LD_INT 3
51173: ARRAY
51174: EQUAL
51175: AND
51176: IFFALSE 51186
// result := true end ;
51178: LD_ADDR_VAR 0 3
51182: PUSH
51183: LD_INT 1
51185: ST_TO_ADDR
// end ;
51186: LD_VAR 0 3
51190: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51191: LD_INT 0
51193: PPUSH
// result := false ;
51194: LD_ADDR_VAR 0 4
51198: PUSH
51199: LD_INT 0
51201: ST_TO_ADDR
// if GetTaskList ( unit ) then
51202: LD_VAR 0 1
51206: PPUSH
51207: CALL_OW 437
51211: IFFALSE 51294
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51213: LD_STRING M
51215: PUSH
51216: LD_VAR 0 1
51220: PPUSH
51221: CALL_OW 437
51225: PUSH
51226: LD_INT 1
51228: ARRAY
51229: PUSH
51230: LD_INT 1
51232: ARRAY
51233: EQUAL
51234: PUSH
51235: LD_VAR 0 2
51239: PUSH
51240: LD_VAR 0 1
51244: PPUSH
51245: CALL_OW 437
51249: PUSH
51250: LD_INT 1
51252: ARRAY
51253: PUSH
51254: LD_INT 2
51256: ARRAY
51257: EQUAL
51258: AND
51259: PUSH
51260: LD_VAR 0 3
51264: PUSH
51265: LD_VAR 0 1
51269: PPUSH
51270: CALL_OW 437
51274: PUSH
51275: LD_INT 1
51277: ARRAY
51278: PUSH
51279: LD_INT 3
51281: ARRAY
51282: EQUAL
51283: AND
51284: IFFALSE 51294
// result := true ;
51286: LD_ADDR_VAR 0 4
51290: PUSH
51291: LD_INT 1
51293: ST_TO_ADDR
// end ; end ;
51294: LD_VAR 0 4
51298: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51299: LD_INT 0
51301: PPUSH
51302: PPUSH
51303: PPUSH
51304: PPUSH
// if not unit or not area then
51305: LD_VAR 0 1
51309: NOT
51310: PUSH
51311: LD_VAR 0 2
51315: NOT
51316: OR
51317: IFFALSE 51321
// exit ;
51319: GO 51485
// tmp := AreaToList ( area , i ) ;
51321: LD_ADDR_VAR 0 6
51325: PUSH
51326: LD_VAR 0 2
51330: PPUSH
51331: LD_VAR 0 5
51335: PPUSH
51336: CALL_OW 517
51340: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51341: LD_ADDR_VAR 0 5
51345: PUSH
51346: DOUBLE
51347: LD_INT 1
51349: DEC
51350: ST_TO_ADDR
51351: LD_VAR 0 6
51355: PUSH
51356: LD_INT 1
51358: ARRAY
51359: PUSH
51360: FOR_TO
51361: IFFALSE 51483
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51363: LD_ADDR_VAR 0 7
51367: PUSH
51368: LD_VAR 0 6
51372: PUSH
51373: LD_INT 1
51375: ARRAY
51376: PUSH
51377: LD_VAR 0 5
51381: ARRAY
51382: PUSH
51383: LD_VAR 0 6
51387: PUSH
51388: LD_INT 2
51390: ARRAY
51391: PUSH
51392: LD_VAR 0 5
51396: ARRAY
51397: PUSH
51398: EMPTY
51399: LIST
51400: LIST
51401: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
51402: LD_VAR 0 7
51406: PUSH
51407: LD_INT 1
51409: ARRAY
51410: PPUSH
51411: LD_VAR 0 7
51415: PUSH
51416: LD_INT 2
51418: ARRAY
51419: PPUSH
51420: CALL_OW 428
51424: PUSH
51425: LD_INT 0
51427: EQUAL
51428: IFFALSE 51481
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
51430: LD_VAR 0 1
51434: PPUSH
51435: LD_VAR 0 7
51439: PUSH
51440: LD_INT 1
51442: ARRAY
51443: PPUSH
51444: LD_VAR 0 7
51448: PUSH
51449: LD_INT 2
51451: ARRAY
51452: PPUSH
51453: LD_VAR 0 3
51457: PPUSH
51458: CALL_OW 48
// result := IsPlaced ( unit ) ;
51462: LD_ADDR_VAR 0 4
51466: PUSH
51467: LD_VAR 0 1
51471: PPUSH
51472: CALL_OW 305
51476: ST_TO_ADDR
// exit ;
51477: POP
51478: POP
51479: GO 51485
// end ; end ;
51481: GO 51360
51483: POP
51484: POP
// end ;
51485: LD_VAR 0 4
51489: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51490: LD_INT 0
51492: PPUSH
51493: PPUSH
51494: PPUSH
// if not side or side > 8 then
51495: LD_VAR 0 1
51499: NOT
51500: PUSH
51501: LD_VAR 0 1
51505: PUSH
51506: LD_INT 8
51508: GREATER
51509: OR
51510: IFFALSE 51514
// exit ;
51512: GO 51701
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51514: LD_ADDR_VAR 0 4
51518: PUSH
51519: LD_INT 22
51521: PUSH
51522: LD_VAR 0 1
51526: PUSH
51527: EMPTY
51528: LIST
51529: LIST
51530: PUSH
51531: LD_INT 21
51533: PUSH
51534: LD_INT 3
51536: PUSH
51537: EMPTY
51538: LIST
51539: LIST
51540: PUSH
51541: EMPTY
51542: LIST
51543: LIST
51544: PPUSH
51545: CALL_OW 69
51549: ST_TO_ADDR
// if not tmp then
51550: LD_VAR 0 4
51554: NOT
51555: IFFALSE 51559
// exit ;
51557: GO 51701
// enable_addtolog := true ;
51559: LD_ADDR_OWVAR 81
51563: PUSH
51564: LD_INT 1
51566: ST_TO_ADDR
// AddToLog ( [ ) ;
51567: LD_STRING [
51569: PPUSH
51570: CALL_OW 561
// for i in tmp do
51574: LD_ADDR_VAR 0 3
51578: PUSH
51579: LD_VAR 0 4
51583: PUSH
51584: FOR_IN
51585: IFFALSE 51692
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51587: LD_STRING [
51589: PUSH
51590: LD_VAR 0 3
51594: PPUSH
51595: CALL_OW 266
51599: STR
51600: PUSH
51601: LD_STRING , 
51603: STR
51604: PUSH
51605: LD_VAR 0 3
51609: PPUSH
51610: CALL_OW 250
51614: STR
51615: PUSH
51616: LD_STRING , 
51618: STR
51619: PUSH
51620: LD_VAR 0 3
51624: PPUSH
51625: CALL_OW 251
51629: STR
51630: PUSH
51631: LD_STRING , 
51633: STR
51634: PUSH
51635: LD_VAR 0 3
51639: PPUSH
51640: CALL_OW 254
51644: STR
51645: PUSH
51646: LD_STRING , 
51648: STR
51649: PUSH
51650: LD_VAR 0 3
51654: PPUSH
51655: LD_INT 1
51657: PPUSH
51658: CALL_OW 268
51662: STR
51663: PUSH
51664: LD_STRING , 
51666: STR
51667: PUSH
51668: LD_VAR 0 3
51672: PPUSH
51673: LD_INT 2
51675: PPUSH
51676: CALL_OW 268
51680: STR
51681: PUSH
51682: LD_STRING ],
51684: STR
51685: PPUSH
51686: CALL_OW 561
// end ;
51690: GO 51584
51692: POP
51693: POP
// AddToLog ( ]; ) ;
51694: LD_STRING ];
51696: PPUSH
51697: CALL_OW 561
// end ;
51701: LD_VAR 0 2
51705: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51706: LD_INT 0
51708: PPUSH
51709: PPUSH
51710: PPUSH
51711: PPUSH
51712: PPUSH
// if not area or not rate or not max then
51713: LD_VAR 0 1
51717: NOT
51718: PUSH
51719: LD_VAR 0 2
51723: NOT
51724: OR
51725: PUSH
51726: LD_VAR 0 4
51730: NOT
51731: OR
51732: IFFALSE 51736
// exit ;
51734: GO 51925
// while 1 do
51736: LD_INT 1
51738: IFFALSE 51925
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51740: LD_ADDR_VAR 0 9
51744: PUSH
51745: LD_VAR 0 1
51749: PPUSH
51750: LD_INT 1
51752: PPUSH
51753: CALL_OW 287
51757: PUSH
51758: LD_INT 10
51760: MUL
51761: ST_TO_ADDR
// r := rate / 10 ;
51762: LD_ADDR_VAR 0 7
51766: PUSH
51767: LD_VAR 0 2
51771: PUSH
51772: LD_INT 10
51774: DIVREAL
51775: ST_TO_ADDR
// time := 1 1$00 ;
51776: LD_ADDR_VAR 0 8
51780: PUSH
51781: LD_INT 2100
51783: ST_TO_ADDR
// if amount < min then
51784: LD_VAR 0 9
51788: PUSH
51789: LD_VAR 0 3
51793: LESS
51794: IFFALSE 51812
// r := r * 2 else
51796: LD_ADDR_VAR 0 7
51800: PUSH
51801: LD_VAR 0 7
51805: PUSH
51806: LD_INT 2
51808: MUL
51809: ST_TO_ADDR
51810: GO 51838
// if amount > max then
51812: LD_VAR 0 9
51816: PUSH
51817: LD_VAR 0 4
51821: GREATER
51822: IFFALSE 51838
// r := r / 2 ;
51824: LD_ADDR_VAR 0 7
51828: PUSH
51829: LD_VAR 0 7
51833: PUSH
51834: LD_INT 2
51836: DIVREAL
51837: ST_TO_ADDR
// time := time / r ;
51838: LD_ADDR_VAR 0 8
51842: PUSH
51843: LD_VAR 0 8
51847: PUSH
51848: LD_VAR 0 7
51852: DIVREAL
51853: ST_TO_ADDR
// if time < 0 then
51854: LD_VAR 0 8
51858: PUSH
51859: LD_INT 0
51861: LESS
51862: IFFALSE 51879
// time := time * - 1 ;
51864: LD_ADDR_VAR 0 8
51868: PUSH
51869: LD_VAR 0 8
51873: PUSH
51874: LD_INT 1
51876: NEG
51877: MUL
51878: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51879: LD_VAR 0 8
51883: PUSH
51884: LD_INT 35
51886: PPUSH
51887: LD_INT 875
51889: PPUSH
51890: CALL_OW 12
51894: PLUS
51895: PPUSH
51896: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51900: LD_INT 1
51902: PPUSH
51903: LD_INT 5
51905: PPUSH
51906: CALL_OW 12
51910: PPUSH
51911: LD_VAR 0 1
51915: PPUSH
51916: LD_INT 1
51918: PPUSH
51919: CALL_OW 55
// end ;
51923: GO 51736
// end ;
51925: LD_VAR 0 5
51929: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51930: LD_INT 0
51932: PPUSH
51933: PPUSH
51934: PPUSH
51935: PPUSH
51936: PPUSH
51937: PPUSH
51938: PPUSH
51939: PPUSH
// if not turrets or not factories then
51940: LD_VAR 0 1
51944: NOT
51945: PUSH
51946: LD_VAR 0 2
51950: NOT
51951: OR
51952: IFFALSE 51956
// exit ;
51954: GO 52263
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51956: LD_ADDR_VAR 0 10
51960: PUSH
51961: LD_INT 5
51963: PUSH
51964: LD_INT 6
51966: PUSH
51967: EMPTY
51968: LIST
51969: LIST
51970: PUSH
51971: LD_INT 2
51973: PUSH
51974: LD_INT 4
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: PUSH
51981: LD_INT 3
51983: PUSH
51984: LD_INT 5
51986: PUSH
51987: EMPTY
51988: LIST
51989: LIST
51990: PUSH
51991: EMPTY
51992: LIST
51993: LIST
51994: LIST
51995: PUSH
51996: LD_INT 24
51998: PUSH
51999: LD_INT 25
52001: PUSH
52002: EMPTY
52003: LIST
52004: LIST
52005: PUSH
52006: LD_INT 23
52008: PUSH
52009: LD_INT 27
52011: PUSH
52012: EMPTY
52013: LIST
52014: LIST
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: PUSH
52020: LD_INT 42
52022: PUSH
52023: LD_INT 43
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: PUSH
52030: LD_INT 44
52032: PUSH
52033: LD_INT 46
52035: PUSH
52036: EMPTY
52037: LIST
52038: LIST
52039: PUSH
52040: LD_INT 45
52042: PUSH
52043: LD_INT 47
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: LIST
52054: PUSH
52055: EMPTY
52056: LIST
52057: LIST
52058: LIST
52059: ST_TO_ADDR
// result := [ ] ;
52060: LD_ADDR_VAR 0 3
52064: PUSH
52065: EMPTY
52066: ST_TO_ADDR
// for i in turrets do
52067: LD_ADDR_VAR 0 4
52071: PUSH
52072: LD_VAR 0 1
52076: PUSH
52077: FOR_IN
52078: IFFALSE 52261
// begin nat := GetNation ( i ) ;
52080: LD_ADDR_VAR 0 7
52084: PUSH
52085: LD_VAR 0 4
52089: PPUSH
52090: CALL_OW 248
52094: ST_TO_ADDR
// weapon := 0 ;
52095: LD_ADDR_VAR 0 8
52099: PUSH
52100: LD_INT 0
52102: ST_TO_ADDR
// if not nat then
52103: LD_VAR 0 7
52107: NOT
52108: IFFALSE 52112
// continue ;
52110: GO 52077
// for j in list [ nat ] do
52112: LD_ADDR_VAR 0 5
52116: PUSH
52117: LD_VAR 0 10
52121: PUSH
52122: LD_VAR 0 7
52126: ARRAY
52127: PUSH
52128: FOR_IN
52129: IFFALSE 52170
// if GetBWeapon ( i ) = j [ 1 ] then
52131: LD_VAR 0 4
52135: PPUSH
52136: CALL_OW 269
52140: PUSH
52141: LD_VAR 0 5
52145: PUSH
52146: LD_INT 1
52148: ARRAY
52149: EQUAL
52150: IFFALSE 52168
// begin weapon := j [ 2 ] ;
52152: LD_ADDR_VAR 0 8
52156: PUSH
52157: LD_VAR 0 5
52161: PUSH
52162: LD_INT 2
52164: ARRAY
52165: ST_TO_ADDR
// break ;
52166: GO 52170
// end ;
52168: GO 52128
52170: POP
52171: POP
// if not weapon then
52172: LD_VAR 0 8
52176: NOT
52177: IFFALSE 52181
// continue ;
52179: GO 52077
// for k in factories do
52181: LD_ADDR_VAR 0 6
52185: PUSH
52186: LD_VAR 0 2
52190: PUSH
52191: FOR_IN
52192: IFFALSE 52257
// begin weapons := AvailableWeaponList ( k ) ;
52194: LD_ADDR_VAR 0 9
52198: PUSH
52199: LD_VAR 0 6
52203: PPUSH
52204: CALL_OW 478
52208: ST_TO_ADDR
// if not weapons then
52209: LD_VAR 0 9
52213: NOT
52214: IFFALSE 52218
// continue ;
52216: GO 52191
// if weapon in weapons then
52218: LD_VAR 0 8
52222: PUSH
52223: LD_VAR 0 9
52227: IN
52228: IFFALSE 52255
// begin result := [ i , weapon ] ;
52230: LD_ADDR_VAR 0 3
52234: PUSH
52235: LD_VAR 0 4
52239: PUSH
52240: LD_VAR 0 8
52244: PUSH
52245: EMPTY
52246: LIST
52247: LIST
52248: ST_TO_ADDR
// exit ;
52249: POP
52250: POP
52251: POP
52252: POP
52253: GO 52263
// end ; end ;
52255: GO 52191
52257: POP
52258: POP
// end ;
52259: GO 52077
52261: POP
52262: POP
// end ;
52263: LD_VAR 0 3
52267: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52268: LD_INT 0
52270: PPUSH
// if not side or side > 8 then
52271: LD_VAR 0 3
52275: NOT
52276: PUSH
52277: LD_VAR 0 3
52281: PUSH
52282: LD_INT 8
52284: GREATER
52285: OR
52286: IFFALSE 52290
// exit ;
52288: GO 52349
// if not range then
52290: LD_VAR 0 4
52294: NOT
52295: IFFALSE 52306
// range := - 12 ;
52297: LD_ADDR_VAR 0 4
52301: PUSH
52302: LD_INT 12
52304: NEG
52305: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52306: LD_VAR 0 1
52310: PPUSH
52311: LD_VAR 0 2
52315: PPUSH
52316: LD_VAR 0 3
52320: PPUSH
52321: LD_VAR 0 4
52325: PPUSH
52326: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52330: LD_VAR 0 1
52334: PPUSH
52335: LD_VAR 0 2
52339: PPUSH
52340: LD_VAR 0 3
52344: PPUSH
52345: CALL_OW 331
// end ;
52349: LD_VAR 0 5
52353: RET
// export function Video ( mode ) ; begin
52354: LD_INT 0
52356: PPUSH
// ingame_video = mode ;
52357: LD_ADDR_OWVAR 52
52361: PUSH
52362: LD_VAR 0 1
52366: ST_TO_ADDR
// interface_hidden = mode ;
52367: LD_ADDR_OWVAR 54
52371: PUSH
52372: LD_VAR 0 1
52376: ST_TO_ADDR
// end ;
52377: LD_VAR 0 2
52381: RET
// export function Join ( array , element ) ; begin
52382: LD_INT 0
52384: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52385: LD_ADDR_VAR 0 3
52389: PUSH
52390: LD_VAR 0 1
52394: PPUSH
52395: LD_VAR 0 1
52399: PUSH
52400: LD_INT 1
52402: PLUS
52403: PPUSH
52404: LD_VAR 0 2
52408: PPUSH
52409: CALL_OW 1
52413: ST_TO_ADDR
// end ;
52414: LD_VAR 0 3
52418: RET
// export function JoinUnion ( array , element ) ; begin
52419: LD_INT 0
52421: PPUSH
// result := array union element ;
52422: LD_ADDR_VAR 0 3
52426: PUSH
52427: LD_VAR 0 1
52431: PUSH
52432: LD_VAR 0 2
52436: UNION
52437: ST_TO_ADDR
// end ;
52438: LD_VAR 0 3
52442: RET
// export function GetBehemoths ( side ) ; begin
52443: LD_INT 0
52445: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52446: LD_ADDR_VAR 0 2
52450: PUSH
52451: LD_INT 22
52453: PUSH
52454: LD_VAR 0 1
52458: PUSH
52459: EMPTY
52460: LIST
52461: LIST
52462: PUSH
52463: LD_INT 31
52465: PUSH
52466: LD_INT 25
52468: PUSH
52469: EMPTY
52470: LIST
52471: LIST
52472: PUSH
52473: EMPTY
52474: LIST
52475: LIST
52476: PPUSH
52477: CALL_OW 69
52481: ST_TO_ADDR
// end ;
52482: LD_VAR 0 2
52486: RET
// export function Shuffle ( array ) ; var i , index ; begin
52487: LD_INT 0
52489: PPUSH
52490: PPUSH
52491: PPUSH
// result := [ ] ;
52492: LD_ADDR_VAR 0 2
52496: PUSH
52497: EMPTY
52498: ST_TO_ADDR
// if not array then
52499: LD_VAR 0 1
52503: NOT
52504: IFFALSE 52508
// exit ;
52506: GO 52607
// Randomize ;
52508: CALL_OW 10
// for i = array downto 1 do
52512: LD_ADDR_VAR 0 3
52516: PUSH
52517: DOUBLE
52518: LD_VAR 0 1
52522: INC
52523: ST_TO_ADDR
52524: LD_INT 1
52526: PUSH
52527: FOR_DOWNTO
52528: IFFALSE 52605
// begin index := rand ( 1 , array ) ;
52530: LD_ADDR_VAR 0 4
52534: PUSH
52535: LD_INT 1
52537: PPUSH
52538: LD_VAR 0 1
52542: PPUSH
52543: CALL_OW 12
52547: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52548: LD_ADDR_VAR 0 2
52552: PUSH
52553: LD_VAR 0 2
52557: PPUSH
52558: LD_VAR 0 2
52562: PUSH
52563: LD_INT 1
52565: PLUS
52566: PPUSH
52567: LD_VAR 0 1
52571: PUSH
52572: LD_VAR 0 4
52576: ARRAY
52577: PPUSH
52578: CALL_OW 2
52582: ST_TO_ADDR
// array := Delete ( array , index ) ;
52583: LD_ADDR_VAR 0 1
52587: PUSH
52588: LD_VAR 0 1
52592: PPUSH
52593: LD_VAR 0 4
52597: PPUSH
52598: CALL_OW 3
52602: ST_TO_ADDR
// end ;
52603: GO 52527
52605: POP
52606: POP
// end ;
52607: LD_VAR 0 2
52611: RET
// export function GetBaseMaterials ( base ) ; begin
52612: LD_INT 0
52614: PPUSH
// result := [ 0 , 0 , 0 ] ;
52615: LD_ADDR_VAR 0 2
52619: PUSH
52620: LD_INT 0
52622: PUSH
52623: LD_INT 0
52625: PUSH
52626: LD_INT 0
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: LIST
52633: ST_TO_ADDR
// if not base then
52634: LD_VAR 0 1
52638: NOT
52639: IFFALSE 52643
// exit ;
52641: GO 52692
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52643: LD_ADDR_VAR 0 2
52647: PUSH
52648: LD_VAR 0 1
52652: PPUSH
52653: LD_INT 1
52655: PPUSH
52656: CALL_OW 275
52660: PUSH
52661: LD_VAR 0 1
52665: PPUSH
52666: LD_INT 2
52668: PPUSH
52669: CALL_OW 275
52673: PUSH
52674: LD_VAR 0 1
52678: PPUSH
52679: LD_INT 3
52681: PPUSH
52682: CALL_OW 275
52686: PUSH
52687: EMPTY
52688: LIST
52689: LIST
52690: LIST
52691: ST_TO_ADDR
// end ;
52692: LD_VAR 0 2
52696: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52697: LD_INT 0
52699: PPUSH
52700: PPUSH
// result := array ;
52701: LD_ADDR_VAR 0 3
52705: PUSH
52706: LD_VAR 0 1
52710: ST_TO_ADDR
// if size >= result then
52711: LD_VAR 0 2
52715: PUSH
52716: LD_VAR 0 3
52720: GREATEREQUAL
52721: IFFALSE 52725
// exit ;
52723: GO 52775
// if size then
52725: LD_VAR 0 2
52729: IFFALSE 52775
// for i := array downto size do
52731: LD_ADDR_VAR 0 4
52735: PUSH
52736: DOUBLE
52737: LD_VAR 0 1
52741: INC
52742: ST_TO_ADDR
52743: LD_VAR 0 2
52747: PUSH
52748: FOR_DOWNTO
52749: IFFALSE 52773
// result := Delete ( result , result ) ;
52751: LD_ADDR_VAR 0 3
52755: PUSH
52756: LD_VAR 0 3
52760: PPUSH
52761: LD_VAR 0 3
52765: PPUSH
52766: CALL_OW 3
52770: ST_TO_ADDR
52771: GO 52748
52773: POP
52774: POP
// end ;
52775: LD_VAR 0 3
52779: RET
// export function ComExit ( unit ) ; var tmp ; begin
52780: LD_INT 0
52782: PPUSH
52783: PPUSH
// if not IsInUnit ( unit ) then
52784: LD_VAR 0 1
52788: PPUSH
52789: CALL_OW 310
52793: NOT
52794: IFFALSE 52798
// exit ;
52796: GO 52858
// tmp := IsInUnit ( unit ) ;
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: LD_VAR 0 1
52807: PPUSH
52808: CALL_OW 310
52812: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52813: LD_VAR 0 3
52817: PPUSH
52818: CALL_OW 247
52822: PUSH
52823: LD_INT 2
52825: EQUAL
52826: IFFALSE 52839
// ComExitVehicle ( unit ) else
52828: LD_VAR 0 1
52832: PPUSH
52833: CALL_OW 121
52837: GO 52848
// ComExitBuilding ( unit ) ;
52839: LD_VAR 0 1
52843: PPUSH
52844: CALL_OW 122
// result := tmp ;
52848: LD_ADDR_VAR 0 2
52852: PUSH
52853: LD_VAR 0 3
52857: ST_TO_ADDR
// end ;
52858: LD_VAR 0 2
52862: RET
// export function ComExitAll ( units ) ; var i ; begin
52863: LD_INT 0
52865: PPUSH
52866: PPUSH
// if not units then
52867: LD_VAR 0 1
52871: NOT
52872: IFFALSE 52876
// exit ;
52874: GO 52902
// for i in units do
52876: LD_ADDR_VAR 0 3
52880: PUSH
52881: LD_VAR 0 1
52885: PUSH
52886: FOR_IN
52887: IFFALSE 52900
// ComExit ( i ) ;
52889: LD_VAR 0 3
52893: PPUSH
52894: CALL 52780 0 1
52898: GO 52886
52900: POP
52901: POP
// end ;
52902: LD_VAR 0 2
52906: RET
// export function ResetHc ; begin
52907: LD_INT 0
52909: PPUSH
// InitHc ;
52910: CALL_OW 19
// hc_importance := 0 ;
52914: LD_ADDR_OWVAR 32
52918: PUSH
52919: LD_INT 0
52921: ST_TO_ADDR
// end ;
52922: LD_VAR 0 1
52926: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52927: LD_INT 0
52929: PPUSH
52930: PPUSH
52931: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52932: LD_ADDR_VAR 0 6
52936: PUSH
52937: LD_VAR 0 1
52941: PUSH
52942: LD_VAR 0 3
52946: PLUS
52947: PUSH
52948: LD_INT 2
52950: DIV
52951: ST_TO_ADDR
// if _x < 0 then
52952: LD_VAR 0 6
52956: PUSH
52957: LD_INT 0
52959: LESS
52960: IFFALSE 52977
// _x := _x * - 1 ;
52962: LD_ADDR_VAR 0 6
52966: PUSH
52967: LD_VAR 0 6
52971: PUSH
52972: LD_INT 1
52974: NEG
52975: MUL
52976: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52977: LD_ADDR_VAR 0 7
52981: PUSH
52982: LD_VAR 0 2
52986: PUSH
52987: LD_VAR 0 4
52991: PLUS
52992: PUSH
52993: LD_INT 2
52995: DIV
52996: ST_TO_ADDR
// if _y < 0 then
52997: LD_VAR 0 7
53001: PUSH
53002: LD_INT 0
53004: LESS
53005: IFFALSE 53022
// _y := _y * - 1 ;
53007: LD_ADDR_VAR 0 7
53011: PUSH
53012: LD_VAR 0 7
53016: PUSH
53017: LD_INT 1
53019: NEG
53020: MUL
53021: ST_TO_ADDR
// result := [ _x , _y ] ;
53022: LD_ADDR_VAR 0 5
53026: PUSH
53027: LD_VAR 0 6
53031: PUSH
53032: LD_VAR 0 7
53036: PUSH
53037: EMPTY
53038: LIST
53039: LIST
53040: ST_TO_ADDR
// end ;
53041: LD_VAR 0 5
53045: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53046: LD_INT 0
53048: PPUSH
53049: PPUSH
53050: PPUSH
53051: PPUSH
// task := GetTaskList ( unit ) ;
53052: LD_ADDR_VAR 0 7
53056: PUSH
53057: LD_VAR 0 1
53061: PPUSH
53062: CALL_OW 437
53066: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53067: LD_VAR 0 7
53071: NOT
53072: PUSH
53073: LD_VAR 0 1
53077: PPUSH
53078: LD_VAR 0 2
53082: PPUSH
53083: CALL_OW 308
53087: NOT
53088: AND
53089: IFFALSE 53093
// exit ;
53091: GO 53211
// if IsInArea ( unit , area ) then
53093: LD_VAR 0 1
53097: PPUSH
53098: LD_VAR 0 2
53102: PPUSH
53103: CALL_OW 308
53107: IFFALSE 53125
// begin ComMoveToArea ( unit , goAway ) ;
53109: LD_VAR 0 1
53113: PPUSH
53114: LD_VAR 0 3
53118: PPUSH
53119: CALL_OW 113
// exit ;
53123: GO 53211
// end ; if task [ 1 ] [ 1 ] <> M then
53125: LD_VAR 0 7
53129: PUSH
53130: LD_INT 1
53132: ARRAY
53133: PUSH
53134: LD_INT 1
53136: ARRAY
53137: PUSH
53138: LD_STRING M
53140: NONEQUAL
53141: IFFALSE 53145
// exit ;
53143: GO 53211
// x := task [ 1 ] [ 2 ] ;
53145: LD_ADDR_VAR 0 5
53149: PUSH
53150: LD_VAR 0 7
53154: PUSH
53155: LD_INT 1
53157: ARRAY
53158: PUSH
53159: LD_INT 2
53161: ARRAY
53162: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53163: LD_ADDR_VAR 0 6
53167: PUSH
53168: LD_VAR 0 7
53172: PUSH
53173: LD_INT 1
53175: ARRAY
53176: PUSH
53177: LD_INT 3
53179: ARRAY
53180: ST_TO_ADDR
// if InArea ( x , y , area ) then
53181: LD_VAR 0 5
53185: PPUSH
53186: LD_VAR 0 6
53190: PPUSH
53191: LD_VAR 0 2
53195: PPUSH
53196: CALL_OW 309
53200: IFFALSE 53211
// ComStop ( unit ) ;
53202: LD_VAR 0 1
53206: PPUSH
53207: CALL_OW 141
// end ;
53211: LD_VAR 0 4
53215: RET
// export function Abs ( value ) ; begin
53216: LD_INT 0
53218: PPUSH
// result := value ;
53219: LD_ADDR_VAR 0 2
53223: PUSH
53224: LD_VAR 0 1
53228: ST_TO_ADDR
// if value < 0 then
53229: LD_VAR 0 1
53233: PUSH
53234: LD_INT 0
53236: LESS
53237: IFFALSE 53254
// result := value * - 1 ;
53239: LD_ADDR_VAR 0 2
53243: PUSH
53244: LD_VAR 0 1
53248: PUSH
53249: LD_INT 1
53251: NEG
53252: MUL
53253: ST_TO_ADDR
// end ;
53254: LD_VAR 0 2
53258: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53259: LD_INT 0
53261: PPUSH
53262: PPUSH
53263: PPUSH
53264: PPUSH
53265: PPUSH
53266: PPUSH
53267: PPUSH
53268: PPUSH
// if not unit or not building then
53269: LD_VAR 0 1
53273: NOT
53274: PUSH
53275: LD_VAR 0 2
53279: NOT
53280: OR
53281: IFFALSE 53285
// exit ;
53283: GO 53511
// x := GetX ( building ) ;
53285: LD_ADDR_VAR 0 4
53289: PUSH
53290: LD_VAR 0 2
53294: PPUSH
53295: CALL_OW 250
53299: ST_TO_ADDR
// y := GetY ( building ) ;
53300: LD_ADDR_VAR 0 6
53304: PUSH
53305: LD_VAR 0 2
53309: PPUSH
53310: CALL_OW 251
53314: ST_TO_ADDR
// d := GetDir ( building ) ;
53315: LD_ADDR_VAR 0 8
53319: PUSH
53320: LD_VAR 0 2
53324: PPUSH
53325: CALL_OW 254
53329: ST_TO_ADDR
// r := 4 ;
53330: LD_ADDR_VAR 0 9
53334: PUSH
53335: LD_INT 4
53337: ST_TO_ADDR
// for i := 1 to 5 do
53338: LD_ADDR_VAR 0 10
53342: PUSH
53343: DOUBLE
53344: LD_INT 1
53346: DEC
53347: ST_TO_ADDR
53348: LD_INT 5
53350: PUSH
53351: FOR_TO
53352: IFFALSE 53509
// begin _x := ShiftX ( x , d , r + i ) ;
53354: LD_ADDR_VAR 0 5
53358: PUSH
53359: LD_VAR 0 4
53363: PPUSH
53364: LD_VAR 0 8
53368: PPUSH
53369: LD_VAR 0 9
53373: PUSH
53374: LD_VAR 0 10
53378: PLUS
53379: PPUSH
53380: CALL_OW 272
53384: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53385: LD_ADDR_VAR 0 7
53389: PUSH
53390: LD_VAR 0 6
53394: PPUSH
53395: LD_VAR 0 8
53399: PPUSH
53400: LD_VAR 0 9
53404: PUSH
53405: LD_VAR 0 10
53409: PLUS
53410: PPUSH
53411: CALL_OW 273
53415: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53416: LD_VAR 0 5
53420: PPUSH
53421: LD_VAR 0 7
53425: PPUSH
53426: CALL_OW 488
53430: PUSH
53431: LD_VAR 0 5
53435: PPUSH
53436: LD_VAR 0 7
53440: PPUSH
53441: CALL_OW 428
53445: PPUSH
53446: CALL_OW 247
53450: PUSH
53451: LD_INT 3
53453: PUSH
53454: LD_INT 2
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: IN
53461: NOT
53462: AND
53463: IFFALSE 53507
// begin ComMoveXY ( unit , _x , _y ) ;
53465: LD_VAR 0 1
53469: PPUSH
53470: LD_VAR 0 5
53474: PPUSH
53475: LD_VAR 0 7
53479: PPUSH
53480: CALL_OW 111
// result := [ _x , _y ] ;
53484: LD_ADDR_VAR 0 3
53488: PUSH
53489: LD_VAR 0 5
53493: PUSH
53494: LD_VAR 0 7
53498: PUSH
53499: EMPTY
53500: LIST
53501: LIST
53502: ST_TO_ADDR
// exit ;
53503: POP
53504: POP
53505: GO 53511
// end ; end ;
53507: GO 53351
53509: POP
53510: POP
// end ;
53511: LD_VAR 0 3
53515: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53516: LD_INT 0
53518: PPUSH
53519: PPUSH
53520: PPUSH
// result := 0 ;
53521: LD_ADDR_VAR 0 3
53525: PUSH
53526: LD_INT 0
53528: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53529: LD_VAR 0 1
53533: PUSH
53534: LD_INT 0
53536: LESS
53537: PUSH
53538: LD_VAR 0 1
53542: PUSH
53543: LD_INT 8
53545: GREATER
53546: OR
53547: PUSH
53548: LD_VAR 0 2
53552: PUSH
53553: LD_INT 0
53555: LESS
53556: OR
53557: PUSH
53558: LD_VAR 0 2
53562: PUSH
53563: LD_INT 8
53565: GREATER
53566: OR
53567: IFFALSE 53571
// exit ;
53569: GO 53646
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53571: LD_ADDR_VAR 0 4
53575: PUSH
53576: LD_INT 22
53578: PUSH
53579: LD_VAR 0 2
53583: PUSH
53584: EMPTY
53585: LIST
53586: LIST
53587: PPUSH
53588: CALL_OW 69
53592: PUSH
53593: FOR_IN
53594: IFFALSE 53644
// begin un := UnitShoot ( i ) ;
53596: LD_ADDR_VAR 0 5
53600: PUSH
53601: LD_VAR 0 4
53605: PPUSH
53606: CALL_OW 504
53610: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53611: LD_VAR 0 5
53615: PPUSH
53616: CALL_OW 255
53620: PUSH
53621: LD_VAR 0 1
53625: EQUAL
53626: IFFALSE 53642
// begin result := un ;
53628: LD_ADDR_VAR 0 3
53632: PUSH
53633: LD_VAR 0 5
53637: ST_TO_ADDR
// exit ;
53638: POP
53639: POP
53640: GO 53646
// end ; end ;
53642: GO 53593
53644: POP
53645: POP
// end ;
53646: LD_VAR 0 3
53650: RET
// export function GetCargoBay ( units ) ; begin
53651: LD_INT 0
53653: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53654: LD_ADDR_VAR 0 2
53658: PUSH
53659: LD_VAR 0 1
53663: PPUSH
53664: LD_INT 2
53666: PUSH
53667: LD_INT 34
53669: PUSH
53670: LD_INT 12
53672: PUSH
53673: EMPTY
53674: LIST
53675: LIST
53676: PUSH
53677: LD_INT 34
53679: PUSH
53680: LD_INT 51
53682: PUSH
53683: EMPTY
53684: LIST
53685: LIST
53686: PUSH
53687: LD_INT 34
53689: PUSH
53690: LD_INT 32
53692: PUSH
53693: EMPTY
53694: LIST
53695: LIST
53696: PUSH
53697: LD_INT 34
53699: PUSH
53700: LD_INT 89
53702: PUSH
53703: EMPTY
53704: LIST
53705: LIST
53706: PUSH
53707: EMPTY
53708: LIST
53709: LIST
53710: LIST
53711: LIST
53712: LIST
53713: PPUSH
53714: CALL_OW 72
53718: ST_TO_ADDR
// end ;
53719: LD_VAR 0 2
53723: RET
// export function Negate ( value ) ; begin
53724: LD_INT 0
53726: PPUSH
// result := not value ;
53727: LD_ADDR_VAR 0 2
53731: PUSH
53732: LD_VAR 0 1
53736: NOT
53737: ST_TO_ADDR
// end ;
53738: LD_VAR 0 2
53742: RET
// export function Inc ( value ) ; begin
53743: LD_INT 0
53745: PPUSH
// result := value + 1 ;
53746: LD_ADDR_VAR 0 2
53750: PUSH
53751: LD_VAR 0 1
53755: PUSH
53756: LD_INT 1
53758: PLUS
53759: ST_TO_ADDR
// end ;
53760: LD_VAR 0 2
53764: RET
// export function Dec ( value ) ; begin
53765: LD_INT 0
53767: PPUSH
// result := value - 1 ;
53768: LD_ADDR_VAR 0 2
53772: PUSH
53773: LD_VAR 0 1
53777: PUSH
53778: LD_INT 1
53780: MINUS
53781: ST_TO_ADDR
// end ;
53782: LD_VAR 0 2
53786: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53787: LD_INT 0
53789: PPUSH
53790: PPUSH
53791: PPUSH
53792: PPUSH
53793: PPUSH
53794: PPUSH
53795: PPUSH
53796: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53797: LD_VAR 0 1
53801: PPUSH
53802: LD_VAR 0 2
53806: PPUSH
53807: CALL_OW 488
53811: NOT
53812: PUSH
53813: LD_VAR 0 3
53817: PPUSH
53818: LD_VAR 0 4
53822: PPUSH
53823: CALL_OW 488
53827: NOT
53828: OR
53829: IFFALSE 53842
// begin result := - 1 ;
53831: LD_ADDR_VAR 0 5
53835: PUSH
53836: LD_INT 1
53838: NEG
53839: ST_TO_ADDR
// exit ;
53840: GO 54077
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53842: LD_ADDR_VAR 0 12
53846: PUSH
53847: LD_VAR 0 1
53851: PPUSH
53852: LD_VAR 0 2
53856: PPUSH
53857: LD_VAR 0 3
53861: PPUSH
53862: LD_VAR 0 4
53866: PPUSH
53867: CALL 52927 0 4
53871: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53872: LD_ADDR_VAR 0 11
53876: PUSH
53877: LD_VAR 0 1
53881: PPUSH
53882: LD_VAR 0 2
53886: PPUSH
53887: LD_VAR 0 12
53891: PUSH
53892: LD_INT 1
53894: ARRAY
53895: PPUSH
53896: LD_VAR 0 12
53900: PUSH
53901: LD_INT 2
53903: ARRAY
53904: PPUSH
53905: CALL_OW 298
53909: ST_TO_ADDR
// distance := 9999 ;
53910: LD_ADDR_VAR 0 10
53914: PUSH
53915: LD_INT 9999
53917: ST_TO_ADDR
// for i := 0 to 5 do
53918: LD_ADDR_VAR 0 6
53922: PUSH
53923: DOUBLE
53924: LD_INT 0
53926: DEC
53927: ST_TO_ADDR
53928: LD_INT 5
53930: PUSH
53931: FOR_TO
53932: IFFALSE 54075
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53934: LD_ADDR_VAR 0 7
53938: PUSH
53939: LD_VAR 0 1
53943: PPUSH
53944: LD_VAR 0 6
53948: PPUSH
53949: LD_VAR 0 11
53953: PPUSH
53954: CALL_OW 272
53958: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53959: LD_ADDR_VAR 0 8
53963: PUSH
53964: LD_VAR 0 2
53968: PPUSH
53969: LD_VAR 0 6
53973: PPUSH
53974: LD_VAR 0 11
53978: PPUSH
53979: CALL_OW 273
53983: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53984: LD_VAR 0 7
53988: PPUSH
53989: LD_VAR 0 8
53993: PPUSH
53994: CALL_OW 488
53998: NOT
53999: IFFALSE 54003
// continue ;
54001: GO 53931
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54003: LD_ADDR_VAR 0 9
54007: PUSH
54008: LD_VAR 0 12
54012: PUSH
54013: LD_INT 1
54015: ARRAY
54016: PPUSH
54017: LD_VAR 0 12
54021: PUSH
54022: LD_INT 2
54024: ARRAY
54025: PPUSH
54026: LD_VAR 0 7
54030: PPUSH
54031: LD_VAR 0 8
54035: PPUSH
54036: CALL_OW 298
54040: ST_TO_ADDR
// if tmp < distance then
54041: LD_VAR 0 9
54045: PUSH
54046: LD_VAR 0 10
54050: LESS
54051: IFFALSE 54073
// begin result := i ;
54053: LD_ADDR_VAR 0 5
54057: PUSH
54058: LD_VAR 0 6
54062: ST_TO_ADDR
// distance := tmp ;
54063: LD_ADDR_VAR 0 10
54067: PUSH
54068: LD_VAR 0 9
54072: ST_TO_ADDR
// end ; end ;
54073: GO 53931
54075: POP
54076: POP
// end ;
54077: LD_VAR 0 5
54081: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54082: LD_INT 0
54084: PPUSH
54085: PPUSH
// if not driver or not IsInUnit ( driver ) then
54086: LD_VAR 0 1
54090: NOT
54091: PUSH
54092: LD_VAR 0 1
54096: PPUSH
54097: CALL_OW 310
54101: NOT
54102: OR
54103: IFFALSE 54107
// exit ;
54105: GO 54197
// vehicle := IsInUnit ( driver ) ;
54107: LD_ADDR_VAR 0 3
54111: PUSH
54112: LD_VAR 0 1
54116: PPUSH
54117: CALL_OW 310
54121: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54122: LD_VAR 0 1
54126: PPUSH
54127: LD_STRING \
54129: PUSH
54130: LD_INT 0
54132: PUSH
54133: LD_INT 0
54135: PUSH
54136: LD_INT 0
54138: PUSH
54139: LD_INT 0
54141: PUSH
54142: LD_INT 0
54144: PUSH
54145: LD_INT 0
54147: PUSH
54148: EMPTY
54149: LIST
54150: LIST
54151: LIST
54152: LIST
54153: LIST
54154: LIST
54155: LIST
54156: PUSH
54157: LD_STRING E
54159: PUSH
54160: LD_INT 0
54162: PUSH
54163: LD_INT 0
54165: PUSH
54166: LD_VAR 0 3
54170: PUSH
54171: LD_INT 0
54173: PUSH
54174: LD_INT 0
54176: PUSH
54177: LD_INT 0
54179: PUSH
54180: EMPTY
54181: LIST
54182: LIST
54183: LIST
54184: LIST
54185: LIST
54186: LIST
54187: LIST
54188: PUSH
54189: EMPTY
54190: LIST
54191: LIST
54192: PPUSH
54193: CALL_OW 446
// end ;
54197: LD_VAR 0 2
54201: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54202: LD_INT 0
54204: PPUSH
54205: PPUSH
// if not driver or not IsInUnit ( driver ) then
54206: LD_VAR 0 1
54210: NOT
54211: PUSH
54212: LD_VAR 0 1
54216: PPUSH
54217: CALL_OW 310
54221: NOT
54222: OR
54223: IFFALSE 54227
// exit ;
54225: GO 54317
// vehicle := IsInUnit ( driver ) ;
54227: LD_ADDR_VAR 0 3
54231: PUSH
54232: LD_VAR 0 1
54236: PPUSH
54237: CALL_OW 310
54241: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54242: LD_VAR 0 1
54246: PPUSH
54247: LD_STRING \
54249: PUSH
54250: LD_INT 0
54252: PUSH
54253: LD_INT 0
54255: PUSH
54256: LD_INT 0
54258: PUSH
54259: LD_INT 0
54261: PUSH
54262: LD_INT 0
54264: PUSH
54265: LD_INT 0
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: LIST
54272: LIST
54273: LIST
54274: LIST
54275: LIST
54276: PUSH
54277: LD_STRING E
54279: PUSH
54280: LD_INT 0
54282: PUSH
54283: LD_INT 0
54285: PUSH
54286: LD_VAR 0 3
54290: PUSH
54291: LD_INT 0
54293: PUSH
54294: LD_INT 0
54296: PUSH
54297: LD_INT 0
54299: PUSH
54300: EMPTY
54301: LIST
54302: LIST
54303: LIST
54304: LIST
54305: LIST
54306: LIST
54307: LIST
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: PPUSH
54313: CALL_OW 447
// end ;
54317: LD_VAR 0 2
54321: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54322: LD_INT 0
54324: PPUSH
54325: PPUSH
54326: PPUSH
// tmp := [ ] ;
54327: LD_ADDR_VAR 0 5
54331: PUSH
54332: EMPTY
54333: ST_TO_ADDR
// for i in units do
54334: LD_ADDR_VAR 0 4
54338: PUSH
54339: LD_VAR 0 1
54343: PUSH
54344: FOR_IN
54345: IFFALSE 54383
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54347: LD_ADDR_VAR 0 5
54351: PUSH
54352: LD_VAR 0 5
54356: PPUSH
54357: LD_VAR 0 5
54361: PUSH
54362: LD_INT 1
54364: PLUS
54365: PPUSH
54366: LD_VAR 0 4
54370: PPUSH
54371: CALL_OW 256
54375: PPUSH
54376: CALL_OW 2
54380: ST_TO_ADDR
54381: GO 54344
54383: POP
54384: POP
// if not tmp then
54385: LD_VAR 0 5
54389: NOT
54390: IFFALSE 54394
// exit ;
54392: GO 54442
// if asc then
54394: LD_VAR 0 2
54398: IFFALSE 54422
// result := SortListByListAsc ( units , tmp ) else
54400: LD_ADDR_VAR 0 3
54404: PUSH
54405: LD_VAR 0 1
54409: PPUSH
54410: LD_VAR 0 5
54414: PPUSH
54415: CALL_OW 76
54419: ST_TO_ADDR
54420: GO 54442
// result := SortListByListDesc ( units , tmp ) ;
54422: LD_ADDR_VAR 0 3
54426: PUSH
54427: LD_VAR 0 1
54431: PPUSH
54432: LD_VAR 0 5
54436: PPUSH
54437: CALL_OW 77
54441: ST_TO_ADDR
// end ;
54442: LD_VAR 0 3
54446: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54447: LD_INT 0
54449: PPUSH
54450: PPUSH
// task := GetTaskList ( mech ) ;
54451: LD_ADDR_VAR 0 4
54455: PUSH
54456: LD_VAR 0 1
54460: PPUSH
54461: CALL_OW 437
54465: ST_TO_ADDR
// if not task then
54466: LD_VAR 0 4
54470: NOT
54471: IFFALSE 54475
// exit ;
54473: GO 54517
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54475: LD_ADDR_VAR 0 3
54479: PUSH
54480: LD_VAR 0 4
54484: PUSH
54485: LD_INT 1
54487: ARRAY
54488: PUSH
54489: LD_INT 1
54491: ARRAY
54492: PUSH
54493: LD_STRING r
54495: EQUAL
54496: PUSH
54497: LD_VAR 0 4
54501: PUSH
54502: LD_INT 1
54504: ARRAY
54505: PUSH
54506: LD_INT 4
54508: ARRAY
54509: PUSH
54510: LD_VAR 0 2
54514: EQUAL
54515: AND
54516: ST_TO_ADDR
// end ;
54517: LD_VAR 0 3
54521: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54522: LD_INT 0
54524: PPUSH
// SetDir ( unit , d ) ;
54525: LD_VAR 0 1
54529: PPUSH
54530: LD_VAR 0 4
54534: PPUSH
54535: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54539: LD_VAR 0 1
54543: PPUSH
54544: LD_VAR 0 2
54548: PPUSH
54549: LD_VAR 0 3
54553: PPUSH
54554: LD_VAR 0 5
54558: PPUSH
54559: CALL_OW 48
// end ;
54563: LD_VAR 0 6
54567: RET
// export function ToNaturalNumber ( number ) ; begin
54568: LD_INT 0
54570: PPUSH
// result := number div 1 ;
54571: LD_ADDR_VAR 0 2
54575: PUSH
54576: LD_VAR 0 1
54580: PUSH
54581: LD_INT 1
54583: DIV
54584: ST_TO_ADDR
// if number < 0 then
54585: LD_VAR 0 1
54589: PUSH
54590: LD_INT 0
54592: LESS
54593: IFFALSE 54603
// result := 0 ;
54595: LD_ADDR_VAR 0 2
54599: PUSH
54600: LD_INT 0
54602: ST_TO_ADDR
// end ;
54603: LD_VAR 0 2
54607: RET
// export function SortByClass ( units , class ) ; var un ; begin
54608: LD_INT 0
54610: PPUSH
54611: PPUSH
// if not units or not class then
54612: LD_VAR 0 1
54616: NOT
54617: PUSH
54618: LD_VAR 0 2
54622: NOT
54623: OR
54624: IFFALSE 54628
// exit ;
54626: GO 54723
// result := [ ] ;
54628: LD_ADDR_VAR 0 3
54632: PUSH
54633: EMPTY
54634: ST_TO_ADDR
// for un in units do
54635: LD_ADDR_VAR 0 4
54639: PUSH
54640: LD_VAR 0 1
54644: PUSH
54645: FOR_IN
54646: IFFALSE 54721
// if GetClass ( un ) = class then
54648: LD_VAR 0 4
54652: PPUSH
54653: CALL_OW 257
54657: PUSH
54658: LD_VAR 0 2
54662: EQUAL
54663: IFFALSE 54690
// result := Insert ( result , 1 , un ) else
54665: LD_ADDR_VAR 0 3
54669: PUSH
54670: LD_VAR 0 3
54674: PPUSH
54675: LD_INT 1
54677: PPUSH
54678: LD_VAR 0 4
54682: PPUSH
54683: CALL_OW 2
54687: ST_TO_ADDR
54688: GO 54719
// result := Replace ( result , result + 1 , un ) ;
54690: LD_ADDR_VAR 0 3
54694: PUSH
54695: LD_VAR 0 3
54699: PPUSH
54700: LD_VAR 0 3
54704: PUSH
54705: LD_INT 1
54707: PLUS
54708: PPUSH
54709: LD_VAR 0 4
54713: PPUSH
54714: CALL_OW 1
54718: ST_TO_ADDR
54719: GO 54645
54721: POP
54722: POP
// end ;
54723: LD_VAR 0 3
54727: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54728: LD_INT 0
54730: PPUSH
54731: PPUSH
54732: PPUSH
54733: PPUSH
54734: PPUSH
54735: PPUSH
54736: PPUSH
// result := [ ] ;
54737: LD_ADDR_VAR 0 4
54741: PUSH
54742: EMPTY
54743: ST_TO_ADDR
// if x - r < 0 then
54744: LD_VAR 0 1
54748: PUSH
54749: LD_VAR 0 3
54753: MINUS
54754: PUSH
54755: LD_INT 0
54757: LESS
54758: IFFALSE 54770
// min_x := 0 else
54760: LD_ADDR_VAR 0 8
54764: PUSH
54765: LD_INT 0
54767: ST_TO_ADDR
54768: GO 54786
// min_x := x - r ;
54770: LD_ADDR_VAR 0 8
54774: PUSH
54775: LD_VAR 0 1
54779: PUSH
54780: LD_VAR 0 3
54784: MINUS
54785: ST_TO_ADDR
// if y - r < 0 then
54786: LD_VAR 0 2
54790: PUSH
54791: LD_VAR 0 3
54795: MINUS
54796: PUSH
54797: LD_INT 0
54799: LESS
54800: IFFALSE 54812
// min_y := 0 else
54802: LD_ADDR_VAR 0 7
54806: PUSH
54807: LD_INT 0
54809: ST_TO_ADDR
54810: GO 54828
// min_y := y - r ;
54812: LD_ADDR_VAR 0 7
54816: PUSH
54817: LD_VAR 0 2
54821: PUSH
54822: LD_VAR 0 3
54826: MINUS
54827: ST_TO_ADDR
// max_x := x + r ;
54828: LD_ADDR_VAR 0 9
54832: PUSH
54833: LD_VAR 0 1
54837: PUSH
54838: LD_VAR 0 3
54842: PLUS
54843: ST_TO_ADDR
// max_y := y + r ;
54844: LD_ADDR_VAR 0 10
54848: PUSH
54849: LD_VAR 0 2
54853: PUSH
54854: LD_VAR 0 3
54858: PLUS
54859: ST_TO_ADDR
// for _x = min_x to max_x do
54860: LD_ADDR_VAR 0 5
54864: PUSH
54865: DOUBLE
54866: LD_VAR 0 8
54870: DEC
54871: ST_TO_ADDR
54872: LD_VAR 0 9
54876: PUSH
54877: FOR_TO
54878: IFFALSE 54979
// for _y = min_y to max_y do
54880: LD_ADDR_VAR 0 6
54884: PUSH
54885: DOUBLE
54886: LD_VAR 0 7
54890: DEC
54891: ST_TO_ADDR
54892: LD_VAR 0 10
54896: PUSH
54897: FOR_TO
54898: IFFALSE 54975
// begin if not ValidHex ( _x , _y ) then
54900: LD_VAR 0 5
54904: PPUSH
54905: LD_VAR 0 6
54909: PPUSH
54910: CALL_OW 488
54914: NOT
54915: IFFALSE 54919
// continue ;
54917: GO 54897
// if GetResourceTypeXY ( _x , _y ) then
54919: LD_VAR 0 5
54923: PPUSH
54924: LD_VAR 0 6
54928: PPUSH
54929: CALL_OW 283
54933: IFFALSE 54973
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54935: LD_ADDR_VAR 0 4
54939: PUSH
54940: LD_VAR 0 4
54944: PPUSH
54945: LD_VAR 0 4
54949: PUSH
54950: LD_INT 1
54952: PLUS
54953: PPUSH
54954: LD_VAR 0 5
54958: PUSH
54959: LD_VAR 0 6
54963: PUSH
54964: EMPTY
54965: LIST
54966: LIST
54967: PPUSH
54968: CALL_OW 1
54972: ST_TO_ADDR
// end ;
54973: GO 54897
54975: POP
54976: POP
54977: GO 54877
54979: POP
54980: POP
// end ;
54981: LD_VAR 0 4
54985: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54986: LD_INT 0
54988: PPUSH
54989: PPUSH
54990: PPUSH
54991: PPUSH
54992: PPUSH
54993: PPUSH
54994: PPUSH
54995: PPUSH
// if not units then
54996: LD_VAR 0 1
55000: NOT
55001: IFFALSE 55005
// exit ;
55003: GO 55529
// result := UnitFilter ( units , [ f_ok ] ) ;
55005: LD_ADDR_VAR 0 3
55009: PUSH
55010: LD_VAR 0 1
55014: PPUSH
55015: LD_INT 50
55017: PUSH
55018: EMPTY
55019: LIST
55020: PPUSH
55021: CALL_OW 72
55025: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55026: LD_ADDR_VAR 0 8
55030: PUSH
55031: LD_VAR 0 1
55035: PUSH
55036: LD_INT 1
55038: ARRAY
55039: PPUSH
55040: CALL_OW 255
55044: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55045: LD_ADDR_VAR 0 10
55049: PUSH
55050: LD_INT 29
55052: PUSH
55053: LD_INT 91
55055: PUSH
55056: LD_INT 49
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: LIST
55063: ST_TO_ADDR
// if not result then
55064: LD_VAR 0 3
55068: NOT
55069: IFFALSE 55073
// exit ;
55071: GO 55529
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55073: LD_ADDR_VAR 0 5
55077: PUSH
55078: LD_INT 81
55080: PUSH
55081: LD_VAR 0 8
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: PPUSH
55090: CALL_OW 69
55094: ST_TO_ADDR
// for i in result do
55095: LD_ADDR_VAR 0 4
55099: PUSH
55100: LD_VAR 0 3
55104: PUSH
55105: FOR_IN
55106: IFFALSE 55527
// begin tag := GetTag ( i ) + 1 ;
55108: LD_ADDR_VAR 0 9
55112: PUSH
55113: LD_VAR 0 4
55117: PPUSH
55118: CALL_OW 110
55122: PUSH
55123: LD_INT 1
55125: PLUS
55126: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55127: LD_ADDR_VAR 0 7
55131: PUSH
55132: LD_VAR 0 4
55136: PPUSH
55137: CALL_OW 250
55141: PPUSH
55142: LD_VAR 0 4
55146: PPUSH
55147: CALL_OW 251
55151: PPUSH
55152: LD_INT 6
55154: PPUSH
55155: CALL 54728 0 3
55159: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55160: LD_VAR 0 4
55164: PPUSH
55165: CALL_OW 247
55169: PUSH
55170: LD_INT 2
55172: EQUAL
55173: PUSH
55174: LD_VAR 0 7
55178: AND
55179: PUSH
55180: LD_VAR 0 4
55184: PPUSH
55185: CALL_OW 264
55189: PUSH
55190: LD_VAR 0 10
55194: IN
55195: NOT
55196: AND
55197: IFFALSE 55236
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55199: LD_VAR 0 4
55203: PPUSH
55204: LD_VAR 0 7
55208: PUSH
55209: LD_INT 1
55211: ARRAY
55212: PUSH
55213: LD_INT 1
55215: ARRAY
55216: PPUSH
55217: LD_VAR 0 7
55221: PUSH
55222: LD_INT 1
55224: ARRAY
55225: PUSH
55226: LD_INT 2
55228: ARRAY
55229: PPUSH
55230: CALL_OW 116
55234: GO 55525
// if path > tag then
55236: LD_VAR 0 2
55240: PUSH
55241: LD_VAR 0 9
55245: GREATER
55246: IFFALSE 55454
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55248: LD_ADDR_VAR 0 6
55252: PUSH
55253: LD_VAR 0 5
55257: PPUSH
55258: LD_INT 91
55260: PUSH
55261: LD_VAR 0 4
55265: PUSH
55266: LD_INT 8
55268: PUSH
55269: EMPTY
55270: LIST
55271: LIST
55272: LIST
55273: PPUSH
55274: CALL_OW 72
55278: ST_TO_ADDR
// if nearEnemy then
55279: LD_VAR 0 6
55283: IFFALSE 55352
// begin if GetWeapon ( i ) = ru_time_lapser then
55285: LD_VAR 0 4
55289: PPUSH
55290: CALL_OW 264
55294: PUSH
55295: LD_INT 49
55297: EQUAL
55298: IFFALSE 55326
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55300: LD_VAR 0 4
55304: PPUSH
55305: LD_VAR 0 6
55309: PPUSH
55310: LD_VAR 0 4
55314: PPUSH
55315: CALL_OW 74
55319: PPUSH
55320: CALL_OW 112
55324: GO 55350
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55326: LD_VAR 0 4
55330: PPUSH
55331: LD_VAR 0 6
55335: PPUSH
55336: LD_VAR 0 4
55340: PPUSH
55341: CALL_OW 74
55345: PPUSH
55346: CALL_OW 115
// end else
55350: GO 55452
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55352: LD_VAR 0 4
55356: PPUSH
55357: LD_VAR 0 2
55361: PUSH
55362: LD_VAR 0 9
55366: ARRAY
55367: PUSH
55368: LD_INT 1
55370: ARRAY
55371: PPUSH
55372: LD_VAR 0 2
55376: PUSH
55377: LD_VAR 0 9
55381: ARRAY
55382: PUSH
55383: LD_INT 2
55385: ARRAY
55386: PPUSH
55387: CALL_OW 297
55391: PUSH
55392: LD_INT 6
55394: GREATER
55395: IFFALSE 55438
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55397: LD_VAR 0 4
55401: PPUSH
55402: LD_VAR 0 2
55406: PUSH
55407: LD_VAR 0 9
55411: ARRAY
55412: PUSH
55413: LD_INT 1
55415: ARRAY
55416: PPUSH
55417: LD_VAR 0 2
55421: PUSH
55422: LD_VAR 0 9
55426: ARRAY
55427: PUSH
55428: LD_INT 2
55430: ARRAY
55431: PPUSH
55432: CALL_OW 114
55436: GO 55452
// SetTag ( i , tag ) ;
55438: LD_VAR 0 4
55442: PPUSH
55443: LD_VAR 0 9
55447: PPUSH
55448: CALL_OW 109
// end else
55452: GO 55525
// if enemy then
55454: LD_VAR 0 5
55458: IFFALSE 55525
// begin if GetWeapon ( i ) = ru_time_lapser then
55460: LD_VAR 0 4
55464: PPUSH
55465: CALL_OW 264
55469: PUSH
55470: LD_INT 49
55472: EQUAL
55473: IFFALSE 55501
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55475: LD_VAR 0 4
55479: PPUSH
55480: LD_VAR 0 5
55484: PPUSH
55485: LD_VAR 0 4
55489: PPUSH
55490: CALL_OW 74
55494: PPUSH
55495: CALL_OW 112
55499: GO 55525
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55501: LD_VAR 0 4
55505: PPUSH
55506: LD_VAR 0 5
55510: PPUSH
55511: LD_VAR 0 4
55515: PPUSH
55516: CALL_OW 74
55520: PPUSH
55521: CALL_OW 115
// end ; end ;
55525: GO 55105
55527: POP
55528: POP
// end ;
55529: LD_VAR 0 3
55533: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55534: LD_INT 0
55536: PPUSH
55537: PPUSH
55538: PPUSH
// if not unit or IsInUnit ( unit ) then
55539: LD_VAR 0 1
55543: NOT
55544: PUSH
55545: LD_VAR 0 1
55549: PPUSH
55550: CALL_OW 310
55554: OR
55555: IFFALSE 55559
// exit ;
55557: GO 55650
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55559: LD_ADDR_VAR 0 4
55563: PUSH
55564: LD_VAR 0 1
55568: PPUSH
55569: CALL_OW 250
55573: PPUSH
55574: LD_VAR 0 2
55578: PPUSH
55579: LD_INT 1
55581: PPUSH
55582: CALL_OW 272
55586: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55587: LD_ADDR_VAR 0 5
55591: PUSH
55592: LD_VAR 0 1
55596: PPUSH
55597: CALL_OW 251
55601: PPUSH
55602: LD_VAR 0 2
55606: PPUSH
55607: LD_INT 1
55609: PPUSH
55610: CALL_OW 273
55614: ST_TO_ADDR
// if ValidHex ( x , y ) then
55615: LD_VAR 0 4
55619: PPUSH
55620: LD_VAR 0 5
55624: PPUSH
55625: CALL_OW 488
55629: IFFALSE 55650
// ComTurnXY ( unit , x , y ) ;
55631: LD_VAR 0 1
55635: PPUSH
55636: LD_VAR 0 4
55640: PPUSH
55641: LD_VAR 0 5
55645: PPUSH
55646: CALL_OW 118
// end ;
55650: LD_VAR 0 3
55654: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55655: LD_INT 0
55657: PPUSH
55658: PPUSH
// result := false ;
55659: LD_ADDR_VAR 0 3
55663: PUSH
55664: LD_INT 0
55666: ST_TO_ADDR
// if not units then
55667: LD_VAR 0 2
55671: NOT
55672: IFFALSE 55676
// exit ;
55674: GO 55721
// for i in units do
55676: LD_ADDR_VAR 0 4
55680: PUSH
55681: LD_VAR 0 2
55685: PUSH
55686: FOR_IN
55687: IFFALSE 55719
// if See ( side , i ) then
55689: LD_VAR 0 1
55693: PPUSH
55694: LD_VAR 0 4
55698: PPUSH
55699: CALL_OW 292
55703: IFFALSE 55717
// begin result := true ;
55705: LD_ADDR_VAR 0 3
55709: PUSH
55710: LD_INT 1
55712: ST_TO_ADDR
// exit ;
55713: POP
55714: POP
55715: GO 55721
// end ;
55717: GO 55686
55719: POP
55720: POP
// end ;
55721: LD_VAR 0 3
55725: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55726: LD_INT 0
55728: PPUSH
55729: PPUSH
55730: PPUSH
55731: PPUSH
// if not unit or not points then
55732: LD_VAR 0 1
55736: NOT
55737: PUSH
55738: LD_VAR 0 2
55742: NOT
55743: OR
55744: IFFALSE 55748
// exit ;
55746: GO 55838
// dist := 99999 ;
55748: LD_ADDR_VAR 0 5
55752: PUSH
55753: LD_INT 99999
55755: ST_TO_ADDR
// for i in points do
55756: LD_ADDR_VAR 0 4
55760: PUSH
55761: LD_VAR 0 2
55765: PUSH
55766: FOR_IN
55767: IFFALSE 55836
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55769: LD_ADDR_VAR 0 6
55773: PUSH
55774: LD_VAR 0 1
55778: PPUSH
55779: LD_VAR 0 4
55783: PUSH
55784: LD_INT 1
55786: ARRAY
55787: PPUSH
55788: LD_VAR 0 4
55792: PUSH
55793: LD_INT 2
55795: ARRAY
55796: PPUSH
55797: CALL_OW 297
55801: ST_TO_ADDR
// if tmpDist < dist then
55802: LD_VAR 0 6
55806: PUSH
55807: LD_VAR 0 5
55811: LESS
55812: IFFALSE 55834
// begin result := i ;
55814: LD_ADDR_VAR 0 3
55818: PUSH
55819: LD_VAR 0 4
55823: ST_TO_ADDR
// dist := tmpDist ;
55824: LD_ADDR_VAR 0 5
55828: PUSH
55829: LD_VAR 0 6
55833: ST_TO_ADDR
// end ; end ;
55834: GO 55766
55836: POP
55837: POP
// end ;
55838: LD_VAR 0 3
55842: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55843: LD_INT 0
55845: PPUSH
// uc_side := side ;
55846: LD_ADDR_OWVAR 20
55850: PUSH
55851: LD_VAR 0 1
55855: ST_TO_ADDR
// uc_nation := 3 ;
55856: LD_ADDR_OWVAR 21
55860: PUSH
55861: LD_INT 3
55863: ST_TO_ADDR
// vc_chassis := 25 ;
55864: LD_ADDR_OWVAR 37
55868: PUSH
55869: LD_INT 25
55871: ST_TO_ADDR
// vc_engine := engine_siberite ;
55872: LD_ADDR_OWVAR 39
55876: PUSH
55877: LD_INT 3
55879: ST_TO_ADDR
// vc_control := control_computer ;
55880: LD_ADDR_OWVAR 38
55884: PUSH
55885: LD_INT 3
55887: ST_TO_ADDR
// vc_weapon := 59 ;
55888: LD_ADDR_OWVAR 40
55892: PUSH
55893: LD_INT 59
55895: ST_TO_ADDR
// result := CreateVehicle ;
55896: LD_ADDR_VAR 0 5
55900: PUSH
55901: CALL_OW 45
55905: ST_TO_ADDR
// SetDir ( result , d ) ;
55906: LD_VAR 0 5
55910: PPUSH
55911: LD_VAR 0 4
55915: PPUSH
55916: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55920: LD_VAR 0 5
55924: PPUSH
55925: LD_VAR 0 2
55929: PPUSH
55930: LD_VAR 0 3
55934: PPUSH
55935: LD_INT 0
55937: PPUSH
55938: CALL_OW 48
// end ;
55942: LD_VAR 0 5
55946: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55947: LD_INT 0
55949: PPUSH
55950: PPUSH
55951: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55952: LD_ADDR_VAR 0 2
55956: PUSH
55957: LD_INT 0
55959: PUSH
55960: LD_INT 0
55962: PUSH
55963: LD_INT 0
55965: PUSH
55966: LD_INT 0
55968: PUSH
55969: EMPTY
55970: LIST
55971: LIST
55972: LIST
55973: LIST
55974: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55975: LD_VAR 0 1
55979: NOT
55980: PUSH
55981: LD_VAR 0 1
55985: PPUSH
55986: CALL_OW 264
55990: PUSH
55991: LD_INT 12
55993: PUSH
55994: LD_INT 51
55996: PUSH
55997: LD_INT 32
55999: PUSH
56000: LD_INT 89
56002: PUSH
56003: EMPTY
56004: LIST
56005: LIST
56006: LIST
56007: LIST
56008: IN
56009: NOT
56010: OR
56011: IFFALSE 56015
// exit ;
56013: GO 56113
// for i := 1 to 3 do
56015: LD_ADDR_VAR 0 3
56019: PUSH
56020: DOUBLE
56021: LD_INT 1
56023: DEC
56024: ST_TO_ADDR
56025: LD_INT 3
56027: PUSH
56028: FOR_TO
56029: IFFALSE 56111
// begin tmp := GetCargo ( cargo , i ) ;
56031: LD_ADDR_VAR 0 4
56035: PUSH
56036: LD_VAR 0 1
56040: PPUSH
56041: LD_VAR 0 3
56045: PPUSH
56046: CALL_OW 289
56050: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56051: LD_ADDR_VAR 0 2
56055: PUSH
56056: LD_VAR 0 2
56060: PPUSH
56061: LD_VAR 0 3
56065: PPUSH
56066: LD_VAR 0 4
56070: PPUSH
56071: CALL_OW 1
56075: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56076: LD_ADDR_VAR 0 2
56080: PUSH
56081: LD_VAR 0 2
56085: PPUSH
56086: LD_INT 4
56088: PPUSH
56089: LD_VAR 0 2
56093: PUSH
56094: LD_INT 4
56096: ARRAY
56097: PUSH
56098: LD_VAR 0 4
56102: PLUS
56103: PPUSH
56104: CALL_OW 1
56108: ST_TO_ADDR
// end ;
56109: GO 56028
56111: POP
56112: POP
// end ;
56113: LD_VAR 0 2
56117: RET
// export function Length ( array ) ; begin
56118: LD_INT 0
56120: PPUSH
// result := array + 0 ;
56121: LD_ADDR_VAR 0 2
56125: PUSH
56126: LD_VAR 0 1
56130: PUSH
56131: LD_INT 0
56133: PLUS
56134: ST_TO_ADDR
// end ;
56135: LD_VAR 0 2
56139: RET
// export function PrepareArray ( array ) ; begin
56140: LD_INT 0
56142: PPUSH
// result := array diff 0 ;
56143: LD_ADDR_VAR 0 2
56147: PUSH
56148: LD_VAR 0 1
56152: PUSH
56153: LD_INT 0
56155: DIFF
56156: ST_TO_ADDR
// if not result [ 1 ] then
56157: LD_VAR 0 2
56161: PUSH
56162: LD_INT 1
56164: ARRAY
56165: NOT
56166: IFFALSE 56186
// result := Delete ( result , 1 ) ;
56168: LD_ADDR_VAR 0 2
56172: PUSH
56173: LD_VAR 0 2
56177: PPUSH
56178: LD_INT 1
56180: PPUSH
56181: CALL_OW 3
56185: ST_TO_ADDR
// end ;
56186: LD_VAR 0 2
56190: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56191: LD_INT 0
56193: PPUSH
56194: PPUSH
56195: PPUSH
56196: PPUSH
// sibRocketRange := 25 ;
56197: LD_ADDR_VAR 0 6
56201: PUSH
56202: LD_INT 25
56204: ST_TO_ADDR
// result := false ;
56205: LD_ADDR_VAR 0 4
56209: PUSH
56210: LD_INT 0
56212: ST_TO_ADDR
// for i := 0 to 5 do
56213: LD_ADDR_VAR 0 5
56217: PUSH
56218: DOUBLE
56219: LD_INT 0
56221: DEC
56222: ST_TO_ADDR
56223: LD_INT 5
56225: PUSH
56226: FOR_TO
56227: IFFALSE 56294
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56229: LD_VAR 0 1
56233: PPUSH
56234: LD_VAR 0 5
56238: PPUSH
56239: LD_VAR 0 6
56243: PPUSH
56244: CALL_OW 272
56248: PPUSH
56249: LD_VAR 0 2
56253: PPUSH
56254: LD_VAR 0 5
56258: PPUSH
56259: LD_VAR 0 6
56263: PPUSH
56264: CALL_OW 273
56268: PPUSH
56269: LD_VAR 0 3
56273: PPUSH
56274: CALL_OW 309
56278: IFFALSE 56292
// begin result := true ;
56280: LD_ADDR_VAR 0 4
56284: PUSH
56285: LD_INT 1
56287: ST_TO_ADDR
// exit ;
56288: POP
56289: POP
56290: GO 56296
// end ;
56292: GO 56226
56294: POP
56295: POP
// end ;
56296: LD_VAR 0 4
56300: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56301: LD_INT 0
56303: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56304: LD_VAR 0 1
56308: PPUSH
56309: LD_VAR 0 2
56313: PPUSH
56314: LD_INT 0
56316: PPUSH
56317: LD_INT 0
56319: PPUSH
56320: LD_INT 1
56322: PPUSH
56323: LD_INT 0
56325: PPUSH
56326: CALL_OW 587
// end ; end_of_file
56330: LD_VAR 0 3
56334: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
56335: LD_INT 0
56337: PPUSH
56338: PPUSH
// skirmish := false ;
56339: LD_ADDR_EXP 59
56343: PUSH
56344: LD_INT 0
56346: ST_TO_ADDR
// debug_mc := false ;
56347: LD_ADDR_EXP 60
56351: PUSH
56352: LD_INT 0
56354: ST_TO_ADDR
// mc_bases := [ ] ;
56355: LD_ADDR_EXP 61
56359: PUSH
56360: EMPTY
56361: ST_TO_ADDR
// mc_sides := [ ] ;
56362: LD_ADDR_EXP 87
56366: PUSH
56367: EMPTY
56368: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56369: LD_ADDR_EXP 62
56373: PUSH
56374: EMPTY
56375: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56376: LD_ADDR_EXP 63
56380: PUSH
56381: EMPTY
56382: ST_TO_ADDR
// mc_need_heal := [ ] ;
56383: LD_ADDR_EXP 64
56387: PUSH
56388: EMPTY
56389: ST_TO_ADDR
// mc_healers := [ ] ;
56390: LD_ADDR_EXP 65
56394: PUSH
56395: EMPTY
56396: ST_TO_ADDR
// mc_build_list := [ ] ;
56397: LD_ADDR_EXP 66
56401: PUSH
56402: EMPTY
56403: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56404: LD_ADDR_EXP 93
56408: PUSH
56409: EMPTY
56410: ST_TO_ADDR
// mc_builders := [ ] ;
56411: LD_ADDR_EXP 67
56415: PUSH
56416: EMPTY
56417: ST_TO_ADDR
// mc_construct_list := [ ] ;
56418: LD_ADDR_EXP 68
56422: PUSH
56423: EMPTY
56424: ST_TO_ADDR
// mc_turret_list := [ ] ;
56425: LD_ADDR_EXP 69
56429: PUSH
56430: EMPTY
56431: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56432: LD_ADDR_EXP 70
56436: PUSH
56437: EMPTY
56438: ST_TO_ADDR
// mc_miners := [ ] ;
56439: LD_ADDR_EXP 75
56443: PUSH
56444: EMPTY
56445: ST_TO_ADDR
// mc_mines := [ ] ;
56446: LD_ADDR_EXP 74
56450: PUSH
56451: EMPTY
56452: ST_TO_ADDR
// mc_minefields := [ ] ;
56453: LD_ADDR_EXP 76
56457: PUSH
56458: EMPTY
56459: ST_TO_ADDR
// mc_crates := [ ] ;
56460: LD_ADDR_EXP 77
56464: PUSH
56465: EMPTY
56466: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56467: LD_ADDR_EXP 78
56471: PUSH
56472: EMPTY
56473: ST_TO_ADDR
// mc_crates_area := [ ] ;
56474: LD_ADDR_EXP 79
56478: PUSH
56479: EMPTY
56480: ST_TO_ADDR
// mc_vehicles := [ ] ;
56481: LD_ADDR_EXP 80
56485: PUSH
56486: EMPTY
56487: ST_TO_ADDR
// mc_attack := [ ] ;
56488: LD_ADDR_EXP 81
56492: PUSH
56493: EMPTY
56494: ST_TO_ADDR
// mc_produce := [ ] ;
56495: LD_ADDR_EXP 82
56499: PUSH
56500: EMPTY
56501: ST_TO_ADDR
// mc_defender := [ ] ;
56502: LD_ADDR_EXP 83
56506: PUSH
56507: EMPTY
56508: ST_TO_ADDR
// mc_parking := [ ] ;
56509: LD_ADDR_EXP 85
56513: PUSH
56514: EMPTY
56515: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56516: LD_ADDR_EXP 71
56520: PUSH
56521: EMPTY
56522: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56523: LD_ADDR_EXP 73
56527: PUSH
56528: EMPTY
56529: ST_TO_ADDR
// mc_scan := [ ] ;
56530: LD_ADDR_EXP 84
56534: PUSH
56535: EMPTY
56536: ST_TO_ADDR
// mc_scan_area := [ ] ;
56537: LD_ADDR_EXP 86
56541: PUSH
56542: EMPTY
56543: ST_TO_ADDR
// mc_tech := [ ] ;
56544: LD_ADDR_EXP 88
56548: PUSH
56549: EMPTY
56550: ST_TO_ADDR
// mc_class := [ ] ;
56551: LD_ADDR_EXP 102
56555: PUSH
56556: EMPTY
56557: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56558: LD_ADDR_EXP 103
56562: PUSH
56563: EMPTY
56564: ST_TO_ADDR
// mc_is_defending := [ ] ;
56565: LD_ADDR_EXP 104
56569: PUSH
56570: EMPTY
56571: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
56572: LD_ADDR_EXP 95
56576: PUSH
56577: EMPTY
56578: ST_TO_ADDR
// end ;
56579: LD_VAR 0 1
56583: RET
// export function MC_Kill ( base ) ; begin
56584: LD_INT 0
56586: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56587: LD_ADDR_EXP 61
56591: PUSH
56592: LD_EXP 61
56596: PPUSH
56597: LD_VAR 0 1
56601: PPUSH
56602: EMPTY
56603: PPUSH
56604: CALL_OW 1
56608: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56609: LD_ADDR_EXP 62
56613: PUSH
56614: LD_EXP 62
56618: PPUSH
56619: LD_VAR 0 1
56623: PPUSH
56624: EMPTY
56625: PPUSH
56626: CALL_OW 1
56630: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56631: LD_ADDR_EXP 63
56635: PUSH
56636: LD_EXP 63
56640: PPUSH
56641: LD_VAR 0 1
56645: PPUSH
56646: EMPTY
56647: PPUSH
56648: CALL_OW 1
56652: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56653: LD_ADDR_EXP 64
56657: PUSH
56658: LD_EXP 64
56662: PPUSH
56663: LD_VAR 0 1
56667: PPUSH
56668: EMPTY
56669: PPUSH
56670: CALL_OW 1
56674: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56675: LD_ADDR_EXP 65
56679: PUSH
56680: LD_EXP 65
56684: PPUSH
56685: LD_VAR 0 1
56689: PPUSH
56690: EMPTY
56691: PPUSH
56692: CALL_OW 1
56696: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56697: LD_ADDR_EXP 66
56701: PUSH
56702: LD_EXP 66
56706: PPUSH
56707: LD_VAR 0 1
56711: PPUSH
56712: EMPTY
56713: PPUSH
56714: CALL_OW 1
56718: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56719: LD_ADDR_EXP 67
56723: PUSH
56724: LD_EXP 67
56728: PPUSH
56729: LD_VAR 0 1
56733: PPUSH
56734: EMPTY
56735: PPUSH
56736: CALL_OW 1
56740: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56741: LD_ADDR_EXP 68
56745: PUSH
56746: LD_EXP 68
56750: PPUSH
56751: LD_VAR 0 1
56755: PPUSH
56756: EMPTY
56757: PPUSH
56758: CALL_OW 1
56762: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56763: LD_ADDR_EXP 69
56767: PUSH
56768: LD_EXP 69
56772: PPUSH
56773: LD_VAR 0 1
56777: PPUSH
56778: EMPTY
56779: PPUSH
56780: CALL_OW 1
56784: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56785: LD_ADDR_EXP 70
56789: PUSH
56790: LD_EXP 70
56794: PPUSH
56795: LD_VAR 0 1
56799: PPUSH
56800: EMPTY
56801: PPUSH
56802: CALL_OW 1
56806: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56807: LD_ADDR_EXP 71
56811: PUSH
56812: LD_EXP 71
56816: PPUSH
56817: LD_VAR 0 1
56821: PPUSH
56822: EMPTY
56823: PPUSH
56824: CALL_OW 1
56828: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56829: LD_ADDR_EXP 72
56833: PUSH
56834: LD_EXP 72
56838: PPUSH
56839: LD_VAR 0 1
56843: PPUSH
56844: LD_INT 0
56846: PPUSH
56847: CALL_OW 1
56851: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56852: LD_ADDR_EXP 73
56856: PUSH
56857: LD_EXP 73
56861: PPUSH
56862: LD_VAR 0 1
56866: PPUSH
56867: EMPTY
56868: PPUSH
56869: CALL_OW 1
56873: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56874: LD_ADDR_EXP 74
56878: PUSH
56879: LD_EXP 74
56883: PPUSH
56884: LD_VAR 0 1
56888: PPUSH
56889: EMPTY
56890: PPUSH
56891: CALL_OW 1
56895: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56896: LD_ADDR_EXP 75
56900: PUSH
56901: LD_EXP 75
56905: PPUSH
56906: LD_VAR 0 1
56910: PPUSH
56911: EMPTY
56912: PPUSH
56913: CALL_OW 1
56917: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56918: LD_ADDR_EXP 76
56922: PUSH
56923: LD_EXP 76
56927: PPUSH
56928: LD_VAR 0 1
56932: PPUSH
56933: EMPTY
56934: PPUSH
56935: CALL_OW 1
56939: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56940: LD_ADDR_EXP 77
56944: PUSH
56945: LD_EXP 77
56949: PPUSH
56950: LD_VAR 0 1
56954: PPUSH
56955: EMPTY
56956: PPUSH
56957: CALL_OW 1
56961: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56962: LD_ADDR_EXP 78
56966: PUSH
56967: LD_EXP 78
56971: PPUSH
56972: LD_VAR 0 1
56976: PPUSH
56977: EMPTY
56978: PPUSH
56979: CALL_OW 1
56983: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56984: LD_ADDR_EXP 79
56988: PUSH
56989: LD_EXP 79
56993: PPUSH
56994: LD_VAR 0 1
56998: PPUSH
56999: EMPTY
57000: PPUSH
57001: CALL_OW 1
57005: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57006: LD_ADDR_EXP 80
57010: PUSH
57011: LD_EXP 80
57015: PPUSH
57016: LD_VAR 0 1
57020: PPUSH
57021: EMPTY
57022: PPUSH
57023: CALL_OW 1
57027: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57028: LD_ADDR_EXP 81
57032: PUSH
57033: LD_EXP 81
57037: PPUSH
57038: LD_VAR 0 1
57042: PPUSH
57043: EMPTY
57044: PPUSH
57045: CALL_OW 1
57049: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57050: LD_ADDR_EXP 82
57054: PUSH
57055: LD_EXP 82
57059: PPUSH
57060: LD_VAR 0 1
57064: PPUSH
57065: EMPTY
57066: PPUSH
57067: CALL_OW 1
57071: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57072: LD_ADDR_EXP 83
57076: PUSH
57077: LD_EXP 83
57081: PPUSH
57082: LD_VAR 0 1
57086: PPUSH
57087: EMPTY
57088: PPUSH
57089: CALL_OW 1
57093: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57094: LD_ADDR_EXP 84
57098: PUSH
57099: LD_EXP 84
57103: PPUSH
57104: LD_VAR 0 1
57108: PPUSH
57109: EMPTY
57110: PPUSH
57111: CALL_OW 1
57115: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57116: LD_ADDR_EXP 85
57120: PUSH
57121: LD_EXP 85
57125: PPUSH
57126: LD_VAR 0 1
57130: PPUSH
57131: EMPTY
57132: PPUSH
57133: CALL_OW 1
57137: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57138: LD_ADDR_EXP 86
57142: PUSH
57143: LD_EXP 86
57147: PPUSH
57148: LD_VAR 0 1
57152: PPUSH
57153: EMPTY
57154: PPUSH
57155: CALL_OW 1
57159: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57160: LD_ADDR_EXP 88
57164: PUSH
57165: LD_EXP 88
57169: PPUSH
57170: LD_VAR 0 1
57174: PPUSH
57175: EMPTY
57176: PPUSH
57177: CALL_OW 1
57181: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57182: LD_ADDR_EXP 90
57186: PUSH
57187: LD_EXP 90
57191: PPUSH
57192: LD_VAR 0 1
57196: PPUSH
57197: EMPTY
57198: PPUSH
57199: CALL_OW 1
57203: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57204: LD_ADDR_EXP 91
57208: PUSH
57209: LD_EXP 91
57213: PPUSH
57214: LD_VAR 0 1
57218: PPUSH
57219: EMPTY
57220: PPUSH
57221: CALL_OW 1
57225: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57226: LD_ADDR_EXP 92
57230: PUSH
57231: LD_EXP 92
57235: PPUSH
57236: LD_VAR 0 1
57240: PPUSH
57241: EMPTY
57242: PPUSH
57243: CALL_OW 1
57247: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57248: LD_ADDR_EXP 93
57252: PUSH
57253: LD_EXP 93
57257: PPUSH
57258: LD_VAR 0 1
57262: PPUSH
57263: EMPTY
57264: PPUSH
57265: CALL_OW 1
57269: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57270: LD_ADDR_EXP 94
57274: PUSH
57275: LD_EXP 94
57279: PPUSH
57280: LD_VAR 0 1
57284: PPUSH
57285: EMPTY
57286: PPUSH
57287: CALL_OW 1
57291: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57292: LD_ADDR_EXP 95
57296: PUSH
57297: LD_EXP 95
57301: PPUSH
57302: LD_VAR 0 1
57306: PPUSH
57307: EMPTY
57308: PPUSH
57309: CALL_OW 1
57313: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57314: LD_ADDR_EXP 96
57318: PUSH
57319: LD_EXP 96
57323: PPUSH
57324: LD_VAR 0 1
57328: PPUSH
57329: EMPTY
57330: PPUSH
57331: CALL_OW 1
57335: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57336: LD_ADDR_EXP 97
57340: PUSH
57341: LD_EXP 97
57345: PPUSH
57346: LD_VAR 0 1
57350: PPUSH
57351: EMPTY
57352: PPUSH
57353: CALL_OW 1
57357: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57358: LD_ADDR_EXP 98
57362: PUSH
57363: LD_EXP 98
57367: PPUSH
57368: LD_VAR 0 1
57372: PPUSH
57373: EMPTY
57374: PPUSH
57375: CALL_OW 1
57379: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57380: LD_ADDR_EXP 99
57384: PUSH
57385: LD_EXP 99
57389: PPUSH
57390: LD_VAR 0 1
57394: PPUSH
57395: EMPTY
57396: PPUSH
57397: CALL_OW 1
57401: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57402: LD_ADDR_EXP 100
57406: PUSH
57407: LD_EXP 100
57411: PPUSH
57412: LD_VAR 0 1
57416: PPUSH
57417: EMPTY
57418: PPUSH
57419: CALL_OW 1
57423: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57424: LD_ADDR_EXP 101
57428: PUSH
57429: LD_EXP 101
57433: PPUSH
57434: LD_VAR 0 1
57438: PPUSH
57439: EMPTY
57440: PPUSH
57441: CALL_OW 1
57445: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57446: LD_ADDR_EXP 102
57450: PUSH
57451: LD_EXP 102
57455: PPUSH
57456: LD_VAR 0 1
57460: PPUSH
57461: EMPTY
57462: PPUSH
57463: CALL_OW 1
57467: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57468: LD_ADDR_EXP 103
57472: PUSH
57473: LD_EXP 103
57477: PPUSH
57478: LD_VAR 0 1
57482: PPUSH
57483: LD_INT 0
57485: PPUSH
57486: CALL_OW 1
57490: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57491: LD_ADDR_EXP 104
57495: PUSH
57496: LD_EXP 104
57500: PPUSH
57501: LD_VAR 0 1
57505: PPUSH
57506: LD_INT 0
57508: PPUSH
57509: CALL_OW 1
57513: ST_TO_ADDR
// end ;
57514: LD_VAR 0 2
57518: RET
// export function MC_Add ( side , units ) ; var base ; begin
57519: LD_INT 0
57521: PPUSH
57522: PPUSH
// base := mc_bases + 1 ;
57523: LD_ADDR_VAR 0 4
57527: PUSH
57528: LD_EXP 61
57532: PUSH
57533: LD_INT 1
57535: PLUS
57536: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57537: LD_ADDR_EXP 87
57541: PUSH
57542: LD_EXP 87
57546: PPUSH
57547: LD_VAR 0 4
57551: PPUSH
57552: LD_VAR 0 1
57556: PPUSH
57557: CALL_OW 1
57561: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57562: LD_ADDR_EXP 61
57566: PUSH
57567: LD_EXP 61
57571: PPUSH
57572: LD_VAR 0 4
57576: PPUSH
57577: LD_VAR 0 2
57581: PPUSH
57582: CALL_OW 1
57586: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57587: LD_ADDR_EXP 62
57591: PUSH
57592: LD_EXP 62
57596: PPUSH
57597: LD_VAR 0 4
57601: PPUSH
57602: EMPTY
57603: PPUSH
57604: CALL_OW 1
57608: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57609: LD_ADDR_EXP 63
57613: PUSH
57614: LD_EXP 63
57618: PPUSH
57619: LD_VAR 0 4
57623: PPUSH
57624: EMPTY
57625: PPUSH
57626: CALL_OW 1
57630: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57631: LD_ADDR_EXP 64
57635: PUSH
57636: LD_EXP 64
57640: PPUSH
57641: LD_VAR 0 4
57645: PPUSH
57646: EMPTY
57647: PPUSH
57648: CALL_OW 1
57652: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57653: LD_ADDR_EXP 65
57657: PUSH
57658: LD_EXP 65
57662: PPUSH
57663: LD_VAR 0 4
57667: PPUSH
57668: EMPTY
57669: PPUSH
57670: CALL_OW 1
57674: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57675: LD_ADDR_EXP 66
57679: PUSH
57680: LD_EXP 66
57684: PPUSH
57685: LD_VAR 0 4
57689: PPUSH
57690: EMPTY
57691: PPUSH
57692: CALL_OW 1
57696: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57697: LD_ADDR_EXP 67
57701: PUSH
57702: LD_EXP 67
57706: PPUSH
57707: LD_VAR 0 4
57711: PPUSH
57712: EMPTY
57713: PPUSH
57714: CALL_OW 1
57718: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57719: LD_ADDR_EXP 68
57723: PUSH
57724: LD_EXP 68
57728: PPUSH
57729: LD_VAR 0 4
57733: PPUSH
57734: EMPTY
57735: PPUSH
57736: CALL_OW 1
57740: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57741: LD_ADDR_EXP 69
57745: PUSH
57746: LD_EXP 69
57750: PPUSH
57751: LD_VAR 0 4
57755: PPUSH
57756: EMPTY
57757: PPUSH
57758: CALL_OW 1
57762: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57763: LD_ADDR_EXP 70
57767: PUSH
57768: LD_EXP 70
57772: PPUSH
57773: LD_VAR 0 4
57777: PPUSH
57778: EMPTY
57779: PPUSH
57780: CALL_OW 1
57784: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57785: LD_ADDR_EXP 71
57789: PUSH
57790: LD_EXP 71
57794: PPUSH
57795: LD_VAR 0 4
57799: PPUSH
57800: EMPTY
57801: PPUSH
57802: CALL_OW 1
57806: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57807: LD_ADDR_EXP 72
57811: PUSH
57812: LD_EXP 72
57816: PPUSH
57817: LD_VAR 0 4
57821: PPUSH
57822: LD_INT 0
57824: PPUSH
57825: CALL_OW 1
57829: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57830: LD_ADDR_EXP 73
57834: PUSH
57835: LD_EXP 73
57839: PPUSH
57840: LD_VAR 0 4
57844: PPUSH
57845: EMPTY
57846: PPUSH
57847: CALL_OW 1
57851: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57852: LD_ADDR_EXP 74
57856: PUSH
57857: LD_EXP 74
57861: PPUSH
57862: LD_VAR 0 4
57866: PPUSH
57867: EMPTY
57868: PPUSH
57869: CALL_OW 1
57873: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57874: LD_ADDR_EXP 75
57878: PUSH
57879: LD_EXP 75
57883: PPUSH
57884: LD_VAR 0 4
57888: PPUSH
57889: EMPTY
57890: PPUSH
57891: CALL_OW 1
57895: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57896: LD_ADDR_EXP 76
57900: PUSH
57901: LD_EXP 76
57905: PPUSH
57906: LD_VAR 0 4
57910: PPUSH
57911: EMPTY
57912: PPUSH
57913: CALL_OW 1
57917: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57918: LD_ADDR_EXP 77
57922: PUSH
57923: LD_EXP 77
57927: PPUSH
57928: LD_VAR 0 4
57932: PPUSH
57933: EMPTY
57934: PPUSH
57935: CALL_OW 1
57939: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57940: LD_ADDR_EXP 78
57944: PUSH
57945: LD_EXP 78
57949: PPUSH
57950: LD_VAR 0 4
57954: PPUSH
57955: EMPTY
57956: PPUSH
57957: CALL_OW 1
57961: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57962: LD_ADDR_EXP 79
57966: PUSH
57967: LD_EXP 79
57971: PPUSH
57972: LD_VAR 0 4
57976: PPUSH
57977: EMPTY
57978: PPUSH
57979: CALL_OW 1
57983: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57984: LD_ADDR_EXP 80
57988: PUSH
57989: LD_EXP 80
57993: PPUSH
57994: LD_VAR 0 4
57998: PPUSH
57999: EMPTY
58000: PPUSH
58001: CALL_OW 1
58005: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58006: LD_ADDR_EXP 81
58010: PUSH
58011: LD_EXP 81
58015: PPUSH
58016: LD_VAR 0 4
58020: PPUSH
58021: EMPTY
58022: PPUSH
58023: CALL_OW 1
58027: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58028: LD_ADDR_EXP 82
58032: PUSH
58033: LD_EXP 82
58037: PPUSH
58038: LD_VAR 0 4
58042: PPUSH
58043: EMPTY
58044: PPUSH
58045: CALL_OW 1
58049: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58050: LD_ADDR_EXP 83
58054: PUSH
58055: LD_EXP 83
58059: PPUSH
58060: LD_VAR 0 4
58064: PPUSH
58065: EMPTY
58066: PPUSH
58067: CALL_OW 1
58071: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58072: LD_ADDR_EXP 84
58076: PUSH
58077: LD_EXP 84
58081: PPUSH
58082: LD_VAR 0 4
58086: PPUSH
58087: EMPTY
58088: PPUSH
58089: CALL_OW 1
58093: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58094: LD_ADDR_EXP 85
58098: PUSH
58099: LD_EXP 85
58103: PPUSH
58104: LD_VAR 0 4
58108: PPUSH
58109: EMPTY
58110: PPUSH
58111: CALL_OW 1
58115: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58116: LD_ADDR_EXP 86
58120: PUSH
58121: LD_EXP 86
58125: PPUSH
58126: LD_VAR 0 4
58130: PPUSH
58131: EMPTY
58132: PPUSH
58133: CALL_OW 1
58137: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58138: LD_ADDR_EXP 88
58142: PUSH
58143: LD_EXP 88
58147: PPUSH
58148: LD_VAR 0 4
58152: PPUSH
58153: EMPTY
58154: PPUSH
58155: CALL_OW 1
58159: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58160: LD_ADDR_EXP 90
58164: PUSH
58165: LD_EXP 90
58169: PPUSH
58170: LD_VAR 0 4
58174: PPUSH
58175: EMPTY
58176: PPUSH
58177: CALL_OW 1
58181: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58182: LD_ADDR_EXP 91
58186: PUSH
58187: LD_EXP 91
58191: PPUSH
58192: LD_VAR 0 4
58196: PPUSH
58197: EMPTY
58198: PPUSH
58199: CALL_OW 1
58203: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58204: LD_ADDR_EXP 92
58208: PUSH
58209: LD_EXP 92
58213: PPUSH
58214: LD_VAR 0 4
58218: PPUSH
58219: EMPTY
58220: PPUSH
58221: CALL_OW 1
58225: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58226: LD_ADDR_EXP 93
58230: PUSH
58231: LD_EXP 93
58235: PPUSH
58236: LD_VAR 0 4
58240: PPUSH
58241: EMPTY
58242: PPUSH
58243: CALL_OW 1
58247: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58248: LD_ADDR_EXP 94
58252: PUSH
58253: LD_EXP 94
58257: PPUSH
58258: LD_VAR 0 4
58262: PPUSH
58263: EMPTY
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58270: LD_ADDR_EXP 95
58274: PUSH
58275: LD_EXP 95
58279: PPUSH
58280: LD_VAR 0 4
58284: PPUSH
58285: EMPTY
58286: PPUSH
58287: CALL_OW 1
58291: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58292: LD_ADDR_EXP 96
58296: PUSH
58297: LD_EXP 96
58301: PPUSH
58302: LD_VAR 0 4
58306: PPUSH
58307: EMPTY
58308: PPUSH
58309: CALL_OW 1
58313: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58314: LD_ADDR_EXP 97
58318: PUSH
58319: LD_EXP 97
58323: PPUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: EMPTY
58330: PPUSH
58331: CALL_OW 1
58335: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58336: LD_ADDR_EXP 98
58340: PUSH
58341: LD_EXP 98
58345: PPUSH
58346: LD_VAR 0 4
58350: PPUSH
58351: EMPTY
58352: PPUSH
58353: CALL_OW 1
58357: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58358: LD_ADDR_EXP 99
58362: PUSH
58363: LD_EXP 99
58367: PPUSH
58368: LD_VAR 0 4
58372: PPUSH
58373: EMPTY
58374: PPUSH
58375: CALL_OW 1
58379: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58380: LD_ADDR_EXP 100
58384: PUSH
58385: LD_EXP 100
58389: PPUSH
58390: LD_VAR 0 4
58394: PPUSH
58395: EMPTY
58396: PPUSH
58397: CALL_OW 1
58401: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58402: LD_ADDR_EXP 101
58406: PUSH
58407: LD_EXP 101
58411: PPUSH
58412: LD_VAR 0 4
58416: PPUSH
58417: EMPTY
58418: PPUSH
58419: CALL_OW 1
58423: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58424: LD_ADDR_EXP 102
58428: PUSH
58429: LD_EXP 102
58433: PPUSH
58434: LD_VAR 0 4
58438: PPUSH
58439: EMPTY
58440: PPUSH
58441: CALL_OW 1
58445: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58446: LD_ADDR_EXP 103
58450: PUSH
58451: LD_EXP 103
58455: PPUSH
58456: LD_VAR 0 4
58460: PPUSH
58461: LD_INT 0
58463: PPUSH
58464: CALL_OW 1
58468: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58469: LD_ADDR_EXP 104
58473: PUSH
58474: LD_EXP 104
58478: PPUSH
58479: LD_VAR 0 4
58483: PPUSH
58484: LD_INT 0
58486: PPUSH
58487: CALL_OW 1
58491: ST_TO_ADDR
// result := base ;
58492: LD_ADDR_VAR 0 3
58496: PUSH
58497: LD_VAR 0 4
58501: ST_TO_ADDR
// end ;
58502: LD_VAR 0 3
58506: RET
// export function MC_Start ( ) ; var i ; begin
58507: LD_INT 0
58509: PPUSH
58510: PPUSH
// for i = 1 to mc_bases do
58511: LD_ADDR_VAR 0 2
58515: PUSH
58516: DOUBLE
58517: LD_INT 1
58519: DEC
58520: ST_TO_ADDR
58521: LD_EXP 61
58525: PUSH
58526: FOR_TO
58527: IFFALSE 59627
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58529: LD_ADDR_EXP 61
58533: PUSH
58534: LD_EXP 61
58538: PPUSH
58539: LD_VAR 0 2
58543: PPUSH
58544: LD_EXP 61
58548: PUSH
58549: LD_VAR 0 2
58553: ARRAY
58554: PUSH
58555: LD_INT 0
58557: DIFF
58558: PPUSH
58559: CALL_OW 1
58563: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58564: LD_ADDR_EXP 62
58568: PUSH
58569: LD_EXP 62
58573: PPUSH
58574: LD_VAR 0 2
58578: PPUSH
58579: EMPTY
58580: PPUSH
58581: CALL_OW 1
58585: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58586: LD_ADDR_EXP 63
58590: PUSH
58591: LD_EXP 63
58595: PPUSH
58596: LD_VAR 0 2
58600: PPUSH
58601: EMPTY
58602: PPUSH
58603: CALL_OW 1
58607: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58608: LD_ADDR_EXP 64
58612: PUSH
58613: LD_EXP 64
58617: PPUSH
58618: LD_VAR 0 2
58622: PPUSH
58623: EMPTY
58624: PPUSH
58625: CALL_OW 1
58629: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58630: LD_ADDR_EXP 65
58634: PUSH
58635: LD_EXP 65
58639: PPUSH
58640: LD_VAR 0 2
58644: PPUSH
58645: EMPTY
58646: PUSH
58647: EMPTY
58648: PUSH
58649: EMPTY
58650: LIST
58651: LIST
58652: PPUSH
58653: CALL_OW 1
58657: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58658: LD_ADDR_EXP 66
58662: PUSH
58663: LD_EXP 66
58667: PPUSH
58668: LD_VAR 0 2
58672: PPUSH
58673: EMPTY
58674: PPUSH
58675: CALL_OW 1
58679: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58680: LD_ADDR_EXP 93
58684: PUSH
58685: LD_EXP 93
58689: PPUSH
58690: LD_VAR 0 2
58694: PPUSH
58695: EMPTY
58696: PPUSH
58697: CALL_OW 1
58701: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58702: LD_ADDR_EXP 67
58706: PUSH
58707: LD_EXP 67
58711: PPUSH
58712: LD_VAR 0 2
58716: PPUSH
58717: EMPTY
58718: PPUSH
58719: CALL_OW 1
58723: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58724: LD_ADDR_EXP 68
58728: PUSH
58729: LD_EXP 68
58733: PPUSH
58734: LD_VAR 0 2
58738: PPUSH
58739: EMPTY
58740: PPUSH
58741: CALL_OW 1
58745: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58746: LD_ADDR_EXP 69
58750: PUSH
58751: LD_EXP 69
58755: PPUSH
58756: LD_VAR 0 2
58760: PPUSH
58761: LD_EXP 61
58765: PUSH
58766: LD_VAR 0 2
58770: ARRAY
58771: PPUSH
58772: LD_INT 2
58774: PUSH
58775: LD_INT 30
58777: PUSH
58778: LD_INT 32
58780: PUSH
58781: EMPTY
58782: LIST
58783: LIST
58784: PUSH
58785: LD_INT 30
58787: PUSH
58788: LD_INT 33
58790: PUSH
58791: EMPTY
58792: LIST
58793: LIST
58794: PUSH
58795: EMPTY
58796: LIST
58797: LIST
58798: LIST
58799: PPUSH
58800: CALL_OW 72
58804: PPUSH
58805: CALL_OW 1
58809: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58810: LD_ADDR_EXP 70
58814: PUSH
58815: LD_EXP 70
58819: PPUSH
58820: LD_VAR 0 2
58824: PPUSH
58825: LD_EXP 61
58829: PUSH
58830: LD_VAR 0 2
58834: ARRAY
58835: PPUSH
58836: LD_INT 2
58838: PUSH
58839: LD_INT 30
58841: PUSH
58842: LD_INT 32
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: PUSH
58849: LD_INT 30
58851: PUSH
58852: LD_INT 31
58854: PUSH
58855: EMPTY
58856: LIST
58857: LIST
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: LIST
58863: PUSH
58864: LD_INT 58
58866: PUSH
58867: EMPTY
58868: LIST
58869: PUSH
58870: EMPTY
58871: LIST
58872: LIST
58873: PPUSH
58874: CALL_OW 72
58878: PPUSH
58879: CALL_OW 1
58883: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58884: LD_ADDR_EXP 71
58888: PUSH
58889: LD_EXP 71
58893: PPUSH
58894: LD_VAR 0 2
58898: PPUSH
58899: EMPTY
58900: PPUSH
58901: CALL_OW 1
58905: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58906: LD_ADDR_EXP 75
58910: PUSH
58911: LD_EXP 75
58915: PPUSH
58916: LD_VAR 0 2
58920: PPUSH
58921: EMPTY
58922: PPUSH
58923: CALL_OW 1
58927: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58928: LD_ADDR_EXP 74
58932: PUSH
58933: LD_EXP 74
58937: PPUSH
58938: LD_VAR 0 2
58942: PPUSH
58943: EMPTY
58944: PPUSH
58945: CALL_OW 1
58949: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58950: LD_ADDR_EXP 76
58954: PUSH
58955: LD_EXP 76
58959: PPUSH
58960: LD_VAR 0 2
58964: PPUSH
58965: EMPTY
58966: PPUSH
58967: CALL_OW 1
58971: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58972: LD_ADDR_EXP 77
58976: PUSH
58977: LD_EXP 77
58981: PPUSH
58982: LD_VAR 0 2
58986: PPUSH
58987: EMPTY
58988: PPUSH
58989: CALL_OW 1
58993: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58994: LD_ADDR_EXP 78
58998: PUSH
58999: LD_EXP 78
59003: PPUSH
59004: LD_VAR 0 2
59008: PPUSH
59009: EMPTY
59010: PPUSH
59011: CALL_OW 1
59015: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59016: LD_ADDR_EXP 79
59020: PUSH
59021: LD_EXP 79
59025: PPUSH
59026: LD_VAR 0 2
59030: PPUSH
59031: EMPTY
59032: PPUSH
59033: CALL_OW 1
59037: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59038: LD_ADDR_EXP 80
59042: PUSH
59043: LD_EXP 80
59047: PPUSH
59048: LD_VAR 0 2
59052: PPUSH
59053: EMPTY
59054: PPUSH
59055: CALL_OW 1
59059: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59060: LD_ADDR_EXP 81
59064: PUSH
59065: LD_EXP 81
59069: PPUSH
59070: LD_VAR 0 2
59074: PPUSH
59075: EMPTY
59076: PPUSH
59077: CALL_OW 1
59081: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59082: LD_ADDR_EXP 82
59086: PUSH
59087: LD_EXP 82
59091: PPUSH
59092: LD_VAR 0 2
59096: PPUSH
59097: EMPTY
59098: PPUSH
59099: CALL_OW 1
59103: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59104: LD_ADDR_EXP 83
59108: PUSH
59109: LD_EXP 83
59113: PPUSH
59114: LD_VAR 0 2
59118: PPUSH
59119: EMPTY
59120: PPUSH
59121: CALL_OW 1
59125: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59126: LD_ADDR_EXP 72
59130: PUSH
59131: LD_EXP 72
59135: PPUSH
59136: LD_VAR 0 2
59140: PPUSH
59141: LD_INT 0
59143: PPUSH
59144: CALL_OW 1
59148: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59149: LD_ADDR_EXP 85
59153: PUSH
59154: LD_EXP 85
59158: PPUSH
59159: LD_VAR 0 2
59163: PPUSH
59164: LD_INT 0
59166: PPUSH
59167: CALL_OW 1
59171: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59172: LD_ADDR_EXP 73
59176: PUSH
59177: LD_EXP 73
59181: PPUSH
59182: LD_VAR 0 2
59186: PPUSH
59187: EMPTY
59188: PPUSH
59189: CALL_OW 1
59193: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59194: LD_ADDR_EXP 84
59198: PUSH
59199: LD_EXP 84
59203: PPUSH
59204: LD_VAR 0 2
59208: PPUSH
59209: LD_INT 0
59211: PPUSH
59212: CALL_OW 1
59216: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59217: LD_ADDR_EXP 86
59221: PUSH
59222: LD_EXP 86
59226: PPUSH
59227: LD_VAR 0 2
59231: PPUSH
59232: EMPTY
59233: PPUSH
59234: CALL_OW 1
59238: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59239: LD_ADDR_EXP 89
59243: PUSH
59244: LD_EXP 89
59248: PPUSH
59249: LD_VAR 0 2
59253: PPUSH
59254: LD_INT 0
59256: PPUSH
59257: CALL_OW 1
59261: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59262: LD_ADDR_EXP 90
59266: PUSH
59267: LD_EXP 90
59271: PPUSH
59272: LD_VAR 0 2
59276: PPUSH
59277: EMPTY
59278: PPUSH
59279: CALL_OW 1
59283: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59284: LD_ADDR_EXP 91
59288: PUSH
59289: LD_EXP 91
59293: PPUSH
59294: LD_VAR 0 2
59298: PPUSH
59299: EMPTY
59300: PPUSH
59301: CALL_OW 1
59305: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59306: LD_ADDR_EXP 92
59310: PUSH
59311: LD_EXP 92
59315: PPUSH
59316: LD_VAR 0 2
59320: PPUSH
59321: EMPTY
59322: PPUSH
59323: CALL_OW 1
59327: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59328: LD_ADDR_EXP 94
59332: PUSH
59333: LD_EXP 94
59337: PPUSH
59338: LD_VAR 0 2
59342: PPUSH
59343: LD_EXP 61
59347: PUSH
59348: LD_VAR 0 2
59352: ARRAY
59353: PPUSH
59354: LD_INT 2
59356: PUSH
59357: LD_INT 30
59359: PUSH
59360: LD_INT 6
59362: PUSH
59363: EMPTY
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 30
59369: PUSH
59370: LD_INT 7
59372: PUSH
59373: EMPTY
59374: LIST
59375: LIST
59376: PUSH
59377: LD_INT 30
59379: PUSH
59380: LD_INT 8
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: PUSH
59387: EMPTY
59388: LIST
59389: LIST
59390: LIST
59391: LIST
59392: PPUSH
59393: CALL_OW 72
59397: PPUSH
59398: CALL_OW 1
59402: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59403: LD_ADDR_EXP 95
59407: PUSH
59408: LD_EXP 95
59412: PPUSH
59413: LD_VAR 0 2
59417: PPUSH
59418: EMPTY
59419: PPUSH
59420: CALL_OW 1
59424: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59425: LD_ADDR_EXP 96
59429: PUSH
59430: LD_EXP 96
59434: PPUSH
59435: LD_VAR 0 2
59439: PPUSH
59440: EMPTY
59441: PPUSH
59442: CALL_OW 1
59446: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59447: LD_ADDR_EXP 97
59451: PUSH
59452: LD_EXP 97
59456: PPUSH
59457: LD_VAR 0 2
59461: PPUSH
59462: EMPTY
59463: PPUSH
59464: CALL_OW 1
59468: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59469: LD_ADDR_EXP 98
59473: PUSH
59474: LD_EXP 98
59478: PPUSH
59479: LD_VAR 0 2
59483: PPUSH
59484: EMPTY
59485: PPUSH
59486: CALL_OW 1
59490: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59491: LD_ADDR_EXP 99
59495: PUSH
59496: LD_EXP 99
59500: PPUSH
59501: LD_VAR 0 2
59505: PPUSH
59506: EMPTY
59507: PPUSH
59508: CALL_OW 1
59512: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59513: LD_ADDR_EXP 100
59517: PUSH
59518: LD_EXP 100
59522: PPUSH
59523: LD_VAR 0 2
59527: PPUSH
59528: EMPTY
59529: PPUSH
59530: CALL_OW 1
59534: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59535: LD_ADDR_EXP 101
59539: PUSH
59540: LD_EXP 101
59544: PPUSH
59545: LD_VAR 0 2
59549: PPUSH
59550: EMPTY
59551: PPUSH
59552: CALL_OW 1
59556: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59557: LD_ADDR_EXP 102
59561: PUSH
59562: LD_EXP 102
59566: PPUSH
59567: LD_VAR 0 2
59571: PPUSH
59572: EMPTY
59573: PPUSH
59574: CALL_OW 1
59578: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59579: LD_ADDR_EXP 103
59583: PUSH
59584: LD_EXP 103
59588: PPUSH
59589: LD_VAR 0 2
59593: PPUSH
59594: LD_INT 0
59596: PPUSH
59597: CALL_OW 1
59601: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59602: LD_ADDR_EXP 104
59606: PUSH
59607: LD_EXP 104
59611: PPUSH
59612: LD_VAR 0 2
59616: PPUSH
59617: LD_INT 0
59619: PPUSH
59620: CALL_OW 1
59624: ST_TO_ADDR
// end ;
59625: GO 58526
59627: POP
59628: POP
// MC_InitSides ( ) ;
59629: CALL 59915 0 0
// MC_InitResearch ( ) ;
59633: CALL 59654 0 0
// CustomInitMacro ( ) ;
59637: CALL 202 0 0
// skirmish := true ;
59641: LD_ADDR_EXP 59
59645: PUSH
59646: LD_INT 1
59648: ST_TO_ADDR
// end ;
59649: LD_VAR 0 1
59653: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59654: LD_INT 0
59656: PPUSH
59657: PPUSH
59658: PPUSH
59659: PPUSH
59660: PPUSH
59661: PPUSH
// if not mc_bases then
59662: LD_EXP 61
59666: NOT
59667: IFFALSE 59671
// exit ;
59669: GO 59910
// for i = 1 to 8 do
59671: LD_ADDR_VAR 0 2
59675: PUSH
59676: DOUBLE
59677: LD_INT 1
59679: DEC
59680: ST_TO_ADDR
59681: LD_INT 8
59683: PUSH
59684: FOR_TO
59685: IFFALSE 59711
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59687: LD_ADDR_EXP 88
59691: PUSH
59692: LD_EXP 88
59696: PPUSH
59697: LD_VAR 0 2
59701: PPUSH
59702: EMPTY
59703: PPUSH
59704: CALL_OW 1
59708: ST_TO_ADDR
59709: GO 59684
59711: POP
59712: POP
// tmp := [ ] ;
59713: LD_ADDR_VAR 0 5
59717: PUSH
59718: EMPTY
59719: ST_TO_ADDR
// for i = 1 to mc_sides do
59720: LD_ADDR_VAR 0 2
59724: PUSH
59725: DOUBLE
59726: LD_INT 1
59728: DEC
59729: ST_TO_ADDR
59730: LD_EXP 87
59734: PUSH
59735: FOR_TO
59736: IFFALSE 59794
// if not mc_sides [ i ] in tmp then
59738: LD_EXP 87
59742: PUSH
59743: LD_VAR 0 2
59747: ARRAY
59748: PUSH
59749: LD_VAR 0 5
59753: IN
59754: NOT
59755: IFFALSE 59792
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59757: LD_ADDR_VAR 0 5
59761: PUSH
59762: LD_VAR 0 5
59766: PPUSH
59767: LD_VAR 0 5
59771: PUSH
59772: LD_INT 1
59774: PLUS
59775: PPUSH
59776: LD_EXP 87
59780: PUSH
59781: LD_VAR 0 2
59785: ARRAY
59786: PPUSH
59787: CALL_OW 2
59791: ST_TO_ADDR
59792: GO 59735
59794: POP
59795: POP
// if not tmp then
59796: LD_VAR 0 5
59800: NOT
59801: IFFALSE 59805
// exit ;
59803: GO 59910
// for j in tmp do
59805: LD_ADDR_VAR 0 3
59809: PUSH
59810: LD_VAR 0 5
59814: PUSH
59815: FOR_IN
59816: IFFALSE 59908
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59818: LD_ADDR_VAR 0 6
59822: PUSH
59823: LD_INT 22
59825: PUSH
59826: LD_VAR 0 3
59830: PUSH
59831: EMPTY
59832: LIST
59833: LIST
59834: PPUSH
59835: CALL_OW 69
59839: ST_TO_ADDR
// if not un then
59840: LD_VAR 0 6
59844: NOT
59845: IFFALSE 59849
// continue ;
59847: GO 59815
// nation := GetNation ( un [ 1 ] ) ;
59849: LD_ADDR_VAR 0 4
59853: PUSH
59854: LD_VAR 0 6
59858: PUSH
59859: LD_INT 1
59861: ARRAY
59862: PPUSH
59863: CALL_OW 248
59867: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59868: LD_ADDR_EXP 88
59872: PUSH
59873: LD_EXP 88
59877: PPUSH
59878: LD_VAR 0 3
59882: PPUSH
59883: LD_VAR 0 3
59887: PPUSH
59888: LD_VAR 0 4
59892: PPUSH
59893: LD_INT 1
59895: PPUSH
59896: CALL 14996 0 3
59900: PPUSH
59901: CALL_OW 1
59905: ST_TO_ADDR
// end ;
59906: GO 59815
59908: POP
59909: POP
// end ;
59910: LD_VAR 0 1
59914: RET
// export function MC_InitSides ( ) ; var i ; begin
59915: LD_INT 0
59917: PPUSH
59918: PPUSH
// if not mc_bases then
59919: LD_EXP 61
59923: NOT
59924: IFFALSE 59928
// exit ;
59926: GO 60002
// for i = 1 to mc_bases do
59928: LD_ADDR_VAR 0 2
59932: PUSH
59933: DOUBLE
59934: LD_INT 1
59936: DEC
59937: ST_TO_ADDR
59938: LD_EXP 61
59942: PUSH
59943: FOR_TO
59944: IFFALSE 60000
// if mc_bases [ i ] then
59946: LD_EXP 61
59950: PUSH
59951: LD_VAR 0 2
59955: ARRAY
59956: IFFALSE 59998
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59958: LD_ADDR_EXP 87
59962: PUSH
59963: LD_EXP 87
59967: PPUSH
59968: LD_VAR 0 2
59972: PPUSH
59973: LD_EXP 61
59977: PUSH
59978: LD_VAR 0 2
59982: ARRAY
59983: PUSH
59984: LD_INT 1
59986: ARRAY
59987: PPUSH
59988: CALL_OW 255
59992: PPUSH
59993: CALL_OW 1
59997: ST_TO_ADDR
59998: GO 59943
60000: POP
60001: POP
// end ;
60002: LD_VAR 0 1
60006: RET
// every 0 0$03 trigger skirmish do
60007: LD_EXP 59
60011: IFFALSE 60165
60013: GO 60015
60015: DISABLE
// begin enable ;
60016: ENABLE
// MC_CheckBuildings ( ) ;
60017: CALL 64663 0 0
// MC_CheckPeopleLife ( ) ;
60021: CALL 64824 0 0
// RaiseSailEvent ( 100 ) ;
60025: LD_INT 100
60027: PPUSH
60028: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60032: LD_INT 103
60034: PPUSH
60035: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60039: LD_INT 104
60041: PPUSH
60042: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60046: LD_INT 105
60048: PPUSH
60049: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60053: LD_INT 106
60055: PPUSH
60056: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60060: LD_INT 107
60062: PPUSH
60063: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60067: LD_INT 108
60069: PPUSH
60070: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60074: LD_INT 109
60076: PPUSH
60077: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60081: LD_INT 110
60083: PPUSH
60084: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60088: LD_INT 111
60090: PPUSH
60091: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60095: LD_INT 112
60097: PPUSH
60098: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60102: LD_INT 113
60104: PPUSH
60105: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60109: LD_INT 120
60111: PPUSH
60112: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60116: LD_INT 121
60118: PPUSH
60119: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60123: LD_INT 122
60125: PPUSH
60126: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60130: LD_INT 123
60132: PPUSH
60133: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60137: LD_INT 124
60139: PPUSH
60140: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60144: LD_INT 125
60146: PPUSH
60147: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60151: LD_INT 126
60153: PPUSH
60154: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60158: LD_INT 200
60160: PPUSH
60161: CALL_OW 427
// end ;
60165: END
// on SailEvent ( event ) do begin if event < 100 then
60166: LD_VAR 0 1
60170: PUSH
60171: LD_INT 100
60173: LESS
60174: IFFALSE 60185
// CustomEvent ( event ) ;
60176: LD_VAR 0 1
60180: PPUSH
60181: CALL 13611 0 1
// if event = 100 then
60185: LD_VAR 0 1
60189: PUSH
60190: LD_INT 100
60192: EQUAL
60193: IFFALSE 60199
// MC_ClassManager ( ) ;
60195: CALL 60591 0 0
// if event = 101 then
60199: LD_VAR 0 1
60203: PUSH
60204: LD_INT 101
60206: EQUAL
60207: IFFALSE 60213
// MC_RepairBuildings ( ) ;
60209: CALL 65409 0 0
// if event = 102 then
60213: LD_VAR 0 1
60217: PUSH
60218: LD_INT 102
60220: EQUAL
60221: IFFALSE 60227
// MC_Heal ( ) ;
60223: CALL 66344 0 0
// if event = 103 then
60227: LD_VAR 0 1
60231: PUSH
60232: LD_INT 103
60234: EQUAL
60235: IFFALSE 60241
// MC_Build ( ) ;
60237: CALL 66766 0 0
// if event = 104 then
60241: LD_VAR 0 1
60245: PUSH
60246: LD_INT 104
60248: EQUAL
60249: IFFALSE 60255
// MC_TurretWeapon ( ) ;
60251: CALL 68400 0 0
// if event = 105 then
60255: LD_VAR 0 1
60259: PUSH
60260: LD_INT 105
60262: EQUAL
60263: IFFALSE 60269
// MC_BuildUpgrade ( ) ;
60265: CALL 67951 0 0
// if event = 106 then
60269: LD_VAR 0 1
60273: PUSH
60274: LD_INT 106
60276: EQUAL
60277: IFFALSE 60283
// MC_PlantMines ( ) ;
60279: CALL 68830 0 0
// if event = 107 then
60283: LD_VAR 0 1
60287: PUSH
60288: LD_INT 107
60290: EQUAL
60291: IFFALSE 60297
// MC_CollectCrates ( ) ;
60293: CALL 69621 0 0
// if event = 108 then
60297: LD_VAR 0 1
60301: PUSH
60302: LD_INT 108
60304: EQUAL
60305: IFFALSE 60311
// MC_LinkRemoteControl ( ) ;
60307: CALL 71471 0 0
// if event = 109 then
60311: LD_VAR 0 1
60315: PUSH
60316: LD_INT 109
60318: EQUAL
60319: IFFALSE 60325
// MC_ProduceVehicle ( ) ;
60321: CALL 71652 0 0
// if event = 110 then
60325: LD_VAR 0 1
60329: PUSH
60330: LD_INT 110
60332: EQUAL
60333: IFFALSE 60339
// MC_SendAttack ( ) ;
60335: CALL 72118 0 0
// if event = 111 then
60339: LD_VAR 0 1
60343: PUSH
60344: LD_INT 111
60346: EQUAL
60347: IFFALSE 60353
// MC_Defend ( ) ;
60349: CALL 72226 0 0
// if event = 112 then
60353: LD_VAR 0 1
60357: PUSH
60358: LD_INT 112
60360: EQUAL
60361: IFFALSE 60367
// MC_Research ( ) ;
60363: CALL 73106 0 0
// if event = 113 then
60367: LD_VAR 0 1
60371: PUSH
60372: LD_INT 113
60374: EQUAL
60375: IFFALSE 60381
// MC_MinesTrigger ( ) ;
60377: CALL 74220 0 0
// if event = 120 then
60381: LD_VAR 0 1
60385: PUSH
60386: LD_INT 120
60388: EQUAL
60389: IFFALSE 60395
// MC_RepairVehicle ( ) ;
60391: CALL 74319 0 0
// if event = 121 then
60395: LD_VAR 0 1
60399: PUSH
60400: LD_INT 121
60402: EQUAL
60403: IFFALSE 60409
// MC_TameApe ( ) ;
60405: CALL 75088 0 0
// if event = 122 then
60409: LD_VAR 0 1
60413: PUSH
60414: LD_INT 122
60416: EQUAL
60417: IFFALSE 60423
// MC_ChangeApeClass ( ) ;
60419: CALL 75917 0 0
// if event = 123 then
60423: LD_VAR 0 1
60427: PUSH
60428: LD_INT 123
60430: EQUAL
60431: IFFALSE 60437
// MC_Bazooka ( ) ;
60433: CALL 76567 0 0
// if event = 124 then
60437: LD_VAR 0 1
60441: PUSH
60442: LD_INT 124
60444: EQUAL
60445: IFFALSE 60451
// MC_TeleportExit ( ) ;
60447: CALL 76765 0 0
// if event = 125 then
60451: LD_VAR 0 1
60455: PUSH
60456: LD_INT 125
60458: EQUAL
60459: IFFALSE 60465
// MC_Deposits ( ) ;
60461: CALL 77412 0 0
// if event = 126 then
60465: LD_VAR 0 1
60469: PUSH
60470: LD_INT 126
60472: EQUAL
60473: IFFALSE 60479
// MC_RemoteDriver ( ) ;
60475: CALL 78037 0 0
// if event = 200 then
60479: LD_VAR 0 1
60483: PUSH
60484: LD_INT 200
60486: EQUAL
60487: IFFALSE 60493
// MC_Idle ( ) ;
60489: CALL 79986 0 0
// end ;
60493: PPOPN 1
60495: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60496: LD_INT 0
60498: PPUSH
60499: PPUSH
// if not mc_bases [ base ] or not tag then
60500: LD_EXP 61
60504: PUSH
60505: LD_VAR 0 1
60509: ARRAY
60510: NOT
60511: PUSH
60512: LD_VAR 0 2
60516: NOT
60517: OR
60518: IFFALSE 60522
// exit ;
60520: GO 60586
// for i in mc_bases [ base ] union mc_ape [ base ] do
60522: LD_ADDR_VAR 0 4
60526: PUSH
60527: LD_EXP 61
60531: PUSH
60532: LD_VAR 0 1
60536: ARRAY
60537: PUSH
60538: LD_EXP 90
60542: PUSH
60543: LD_VAR 0 1
60547: ARRAY
60548: UNION
60549: PUSH
60550: FOR_IN
60551: IFFALSE 60584
// if GetTag ( i ) = tag then
60553: LD_VAR 0 4
60557: PPUSH
60558: CALL_OW 110
60562: PUSH
60563: LD_VAR 0 2
60567: EQUAL
60568: IFFALSE 60582
// SetTag ( i , 0 ) ;
60570: LD_VAR 0 4
60574: PPUSH
60575: LD_INT 0
60577: PPUSH
60578: CALL_OW 109
60582: GO 60550
60584: POP
60585: POP
// end ;
60586: LD_VAR 0 3
60590: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60591: LD_INT 0
60593: PPUSH
60594: PPUSH
60595: PPUSH
60596: PPUSH
60597: PPUSH
60598: PPUSH
60599: PPUSH
60600: PPUSH
// if not mc_bases then
60601: LD_EXP 61
60605: NOT
60606: IFFALSE 60610
// exit ;
60608: GO 61068
// for i = 1 to mc_bases do
60610: LD_ADDR_VAR 0 2
60614: PUSH
60615: DOUBLE
60616: LD_INT 1
60618: DEC
60619: ST_TO_ADDR
60620: LD_EXP 61
60624: PUSH
60625: FOR_TO
60626: IFFALSE 61066
// begin tmp := MC_ClassCheckReq ( i ) ;
60628: LD_ADDR_VAR 0 4
60632: PUSH
60633: LD_VAR 0 2
60637: PPUSH
60638: CALL 61073 0 1
60642: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60643: LD_ADDR_EXP 102
60647: PUSH
60648: LD_EXP 102
60652: PPUSH
60653: LD_VAR 0 2
60657: PPUSH
60658: LD_VAR 0 4
60662: PPUSH
60663: CALL_OW 1
60667: ST_TO_ADDR
// if not tmp then
60668: LD_VAR 0 4
60672: NOT
60673: IFFALSE 60677
// continue ;
60675: GO 60625
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60677: LD_ADDR_VAR 0 6
60681: PUSH
60682: LD_EXP 61
60686: PUSH
60687: LD_VAR 0 2
60691: ARRAY
60692: PPUSH
60693: LD_INT 2
60695: PUSH
60696: LD_INT 30
60698: PUSH
60699: LD_INT 4
60701: PUSH
60702: EMPTY
60703: LIST
60704: LIST
60705: PUSH
60706: LD_INT 30
60708: PUSH
60709: LD_INT 5
60711: PUSH
60712: EMPTY
60713: LIST
60714: LIST
60715: PUSH
60716: EMPTY
60717: LIST
60718: LIST
60719: LIST
60720: PPUSH
60721: CALL_OW 72
60725: PUSH
60726: LD_EXP 61
60730: PUSH
60731: LD_VAR 0 2
60735: ARRAY
60736: PPUSH
60737: LD_INT 2
60739: PUSH
60740: LD_INT 30
60742: PUSH
60743: LD_INT 0
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PUSH
60750: LD_INT 30
60752: PUSH
60753: LD_INT 1
60755: PUSH
60756: EMPTY
60757: LIST
60758: LIST
60759: PUSH
60760: EMPTY
60761: LIST
60762: LIST
60763: LIST
60764: PPUSH
60765: CALL_OW 72
60769: PUSH
60770: LD_EXP 61
60774: PUSH
60775: LD_VAR 0 2
60779: ARRAY
60780: PPUSH
60781: LD_INT 30
60783: PUSH
60784: LD_INT 3
60786: PUSH
60787: EMPTY
60788: LIST
60789: LIST
60790: PPUSH
60791: CALL_OW 72
60795: PUSH
60796: LD_EXP 61
60800: PUSH
60801: LD_VAR 0 2
60805: ARRAY
60806: PPUSH
60807: LD_INT 2
60809: PUSH
60810: LD_INT 30
60812: PUSH
60813: LD_INT 6
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PUSH
60820: LD_INT 30
60822: PUSH
60823: LD_INT 7
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PUSH
60830: LD_INT 30
60832: PUSH
60833: LD_INT 8
60835: PUSH
60836: EMPTY
60837: LIST
60838: LIST
60839: PUSH
60840: EMPTY
60841: LIST
60842: LIST
60843: LIST
60844: LIST
60845: PPUSH
60846: CALL_OW 72
60850: PUSH
60851: EMPTY
60852: LIST
60853: LIST
60854: LIST
60855: LIST
60856: ST_TO_ADDR
// for j = 1 to 4 do
60857: LD_ADDR_VAR 0 3
60861: PUSH
60862: DOUBLE
60863: LD_INT 1
60865: DEC
60866: ST_TO_ADDR
60867: LD_INT 4
60869: PUSH
60870: FOR_TO
60871: IFFALSE 61062
// begin if not tmp [ j ] then
60873: LD_VAR 0 4
60877: PUSH
60878: LD_VAR 0 3
60882: ARRAY
60883: NOT
60884: IFFALSE 60888
// continue ;
60886: GO 60870
// for p in tmp [ j ] do
60888: LD_ADDR_VAR 0 5
60892: PUSH
60893: LD_VAR 0 4
60897: PUSH
60898: LD_VAR 0 3
60902: ARRAY
60903: PUSH
60904: FOR_IN
60905: IFFALSE 61058
// begin if not b [ j ] then
60907: LD_VAR 0 6
60911: PUSH
60912: LD_VAR 0 3
60916: ARRAY
60917: NOT
60918: IFFALSE 60922
// break ;
60920: GO 61058
// e := 0 ;
60922: LD_ADDR_VAR 0 7
60926: PUSH
60927: LD_INT 0
60929: ST_TO_ADDR
// for k in b [ j ] do
60930: LD_ADDR_VAR 0 8
60934: PUSH
60935: LD_VAR 0 6
60939: PUSH
60940: LD_VAR 0 3
60944: ARRAY
60945: PUSH
60946: FOR_IN
60947: IFFALSE 60974
// if IsNotFull ( k ) then
60949: LD_VAR 0 8
60953: PPUSH
60954: CALL 17149 0 1
60958: IFFALSE 60972
// begin e := k ;
60960: LD_ADDR_VAR 0 7
60964: PUSH
60965: LD_VAR 0 8
60969: ST_TO_ADDR
// break ;
60970: GO 60974
// end ;
60972: GO 60946
60974: POP
60975: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60976: LD_VAR 0 7
60980: PUSH
60981: LD_VAR 0 5
60985: PPUSH
60986: LD_VAR 0 7
60990: PPUSH
60991: CALL 51028 0 2
60995: NOT
60996: AND
60997: IFFALSE 61056
// begin if IsInUnit ( p ) then
60999: LD_VAR 0 5
61003: PPUSH
61004: CALL_OW 310
61008: IFFALSE 61019
// ComExitBuilding ( p ) ;
61010: LD_VAR 0 5
61014: PPUSH
61015: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61019: LD_VAR 0 5
61023: PPUSH
61024: LD_VAR 0 7
61028: PPUSH
61029: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61033: LD_VAR 0 5
61037: PPUSH
61038: LD_VAR 0 3
61042: PPUSH
61043: CALL_OW 183
// AddComExitBuilding ( p ) ;
61047: LD_VAR 0 5
61051: PPUSH
61052: CALL_OW 182
// end ; end ;
61056: GO 60904
61058: POP
61059: POP
// end ;
61060: GO 60870
61062: POP
61063: POP
// end ;
61064: GO 60625
61066: POP
61067: POP
// end ;
61068: LD_VAR 0 1
61072: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61073: LD_INT 0
61075: PPUSH
61076: PPUSH
61077: PPUSH
61078: PPUSH
61079: PPUSH
61080: PPUSH
61081: PPUSH
61082: PPUSH
61083: PPUSH
61084: PPUSH
61085: PPUSH
61086: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61087: LD_VAR 0 1
61091: NOT
61092: PUSH
61093: LD_EXP 61
61097: PUSH
61098: LD_VAR 0 1
61102: ARRAY
61103: NOT
61104: OR
61105: PUSH
61106: LD_EXP 61
61110: PUSH
61111: LD_VAR 0 1
61115: ARRAY
61116: PPUSH
61117: LD_INT 2
61119: PUSH
61120: LD_INT 30
61122: PUSH
61123: LD_INT 0
61125: PUSH
61126: EMPTY
61127: LIST
61128: LIST
61129: PUSH
61130: LD_INT 30
61132: PUSH
61133: LD_INT 1
61135: PUSH
61136: EMPTY
61137: LIST
61138: LIST
61139: PUSH
61140: EMPTY
61141: LIST
61142: LIST
61143: LIST
61144: PPUSH
61145: CALL_OW 72
61149: NOT
61150: OR
61151: IFFALSE 61155
// exit ;
61153: GO 64658
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61155: LD_ADDR_VAR 0 4
61159: PUSH
61160: LD_EXP 61
61164: PUSH
61165: LD_VAR 0 1
61169: ARRAY
61170: PPUSH
61171: LD_INT 2
61173: PUSH
61174: LD_INT 25
61176: PUSH
61177: LD_INT 1
61179: PUSH
61180: EMPTY
61181: LIST
61182: LIST
61183: PUSH
61184: LD_INT 25
61186: PUSH
61187: LD_INT 2
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PUSH
61194: LD_INT 25
61196: PUSH
61197: LD_INT 3
61199: PUSH
61200: EMPTY
61201: LIST
61202: LIST
61203: PUSH
61204: LD_INT 25
61206: PUSH
61207: LD_INT 4
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: PUSH
61214: LD_INT 25
61216: PUSH
61217: LD_INT 5
61219: PUSH
61220: EMPTY
61221: LIST
61222: LIST
61223: PUSH
61224: LD_INT 25
61226: PUSH
61227: LD_INT 8
61229: PUSH
61230: EMPTY
61231: LIST
61232: LIST
61233: PUSH
61234: LD_INT 25
61236: PUSH
61237: LD_INT 9
61239: PUSH
61240: EMPTY
61241: LIST
61242: LIST
61243: PUSH
61244: EMPTY
61245: LIST
61246: LIST
61247: LIST
61248: LIST
61249: LIST
61250: LIST
61251: LIST
61252: LIST
61253: PPUSH
61254: CALL_OW 72
61258: ST_TO_ADDR
// if not tmp then
61259: LD_VAR 0 4
61263: NOT
61264: IFFALSE 61268
// exit ;
61266: GO 64658
// for i in tmp do
61268: LD_ADDR_VAR 0 3
61272: PUSH
61273: LD_VAR 0 4
61277: PUSH
61278: FOR_IN
61279: IFFALSE 61310
// if GetTag ( i ) then
61281: LD_VAR 0 3
61285: PPUSH
61286: CALL_OW 110
61290: IFFALSE 61308
// tmp := tmp diff i ;
61292: LD_ADDR_VAR 0 4
61296: PUSH
61297: LD_VAR 0 4
61301: PUSH
61302: LD_VAR 0 3
61306: DIFF
61307: ST_TO_ADDR
61308: GO 61278
61310: POP
61311: POP
// if not tmp then
61312: LD_VAR 0 4
61316: NOT
61317: IFFALSE 61321
// exit ;
61319: GO 64658
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61321: LD_ADDR_VAR 0 5
61325: PUSH
61326: LD_EXP 61
61330: PUSH
61331: LD_VAR 0 1
61335: ARRAY
61336: PPUSH
61337: LD_INT 2
61339: PUSH
61340: LD_INT 25
61342: PUSH
61343: LD_INT 1
61345: PUSH
61346: EMPTY
61347: LIST
61348: LIST
61349: PUSH
61350: LD_INT 25
61352: PUSH
61353: LD_INT 5
61355: PUSH
61356: EMPTY
61357: LIST
61358: LIST
61359: PUSH
61360: LD_INT 25
61362: PUSH
61363: LD_INT 8
61365: PUSH
61366: EMPTY
61367: LIST
61368: LIST
61369: PUSH
61370: LD_INT 25
61372: PUSH
61373: LD_INT 9
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: PUSH
61380: EMPTY
61381: LIST
61382: LIST
61383: LIST
61384: LIST
61385: LIST
61386: PPUSH
61387: CALL_OW 72
61391: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61392: LD_ADDR_VAR 0 6
61396: PUSH
61397: LD_EXP 61
61401: PUSH
61402: LD_VAR 0 1
61406: ARRAY
61407: PPUSH
61408: LD_INT 25
61410: PUSH
61411: LD_INT 2
61413: PUSH
61414: EMPTY
61415: LIST
61416: LIST
61417: PPUSH
61418: CALL_OW 72
61422: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61423: LD_ADDR_VAR 0 7
61427: PUSH
61428: LD_EXP 61
61432: PUSH
61433: LD_VAR 0 1
61437: ARRAY
61438: PPUSH
61439: LD_INT 25
61441: PUSH
61442: LD_INT 3
61444: PUSH
61445: EMPTY
61446: LIST
61447: LIST
61448: PPUSH
61449: CALL_OW 72
61453: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61454: LD_ADDR_VAR 0 8
61458: PUSH
61459: LD_EXP 61
61463: PUSH
61464: LD_VAR 0 1
61468: ARRAY
61469: PPUSH
61470: LD_INT 25
61472: PUSH
61473: LD_INT 4
61475: PUSH
61476: EMPTY
61477: LIST
61478: LIST
61479: PUSH
61480: LD_INT 24
61482: PUSH
61483: LD_INT 251
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PUSH
61490: EMPTY
61491: LIST
61492: LIST
61493: PPUSH
61494: CALL_OW 72
61498: ST_TO_ADDR
// if mc_is_defending [ base ] then
61499: LD_EXP 104
61503: PUSH
61504: LD_VAR 0 1
61508: ARRAY
61509: IFFALSE 61970
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61511: LD_ADDR_EXP 103
61515: PUSH
61516: LD_EXP 103
61520: PPUSH
61521: LD_VAR 0 1
61525: PPUSH
61526: LD_INT 4
61528: PPUSH
61529: CALL_OW 1
61533: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61534: LD_ADDR_VAR 0 12
61538: PUSH
61539: LD_EXP 61
61543: PUSH
61544: LD_VAR 0 1
61548: ARRAY
61549: PPUSH
61550: LD_INT 2
61552: PUSH
61553: LD_INT 30
61555: PUSH
61556: LD_INT 4
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: LD_INT 30
61565: PUSH
61566: LD_INT 5
61568: PUSH
61569: EMPTY
61570: LIST
61571: LIST
61572: PUSH
61573: EMPTY
61574: LIST
61575: LIST
61576: LIST
61577: PPUSH
61578: CALL_OW 72
61582: ST_TO_ADDR
// if not b then
61583: LD_VAR 0 12
61587: NOT
61588: IFFALSE 61592
// exit ;
61590: GO 64658
// p := [ ] ;
61592: LD_ADDR_VAR 0 11
61596: PUSH
61597: EMPTY
61598: ST_TO_ADDR
// if sci >= 2 then
61599: LD_VAR 0 8
61603: PUSH
61604: LD_INT 2
61606: GREATEREQUAL
61607: IFFALSE 61638
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61609: LD_ADDR_VAR 0 8
61613: PUSH
61614: LD_VAR 0 8
61618: PUSH
61619: LD_INT 1
61621: ARRAY
61622: PUSH
61623: LD_VAR 0 8
61627: PUSH
61628: LD_INT 2
61630: ARRAY
61631: PUSH
61632: EMPTY
61633: LIST
61634: LIST
61635: ST_TO_ADDR
61636: GO 61699
// if sci = 1 then
61638: LD_VAR 0 8
61642: PUSH
61643: LD_INT 1
61645: EQUAL
61646: IFFALSE 61667
// sci := [ sci [ 1 ] ] else
61648: LD_ADDR_VAR 0 8
61652: PUSH
61653: LD_VAR 0 8
61657: PUSH
61658: LD_INT 1
61660: ARRAY
61661: PUSH
61662: EMPTY
61663: LIST
61664: ST_TO_ADDR
61665: GO 61699
// if sci = 0 then
61667: LD_VAR 0 8
61671: PUSH
61672: LD_INT 0
61674: EQUAL
61675: IFFALSE 61699
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61677: LD_ADDR_VAR 0 11
61681: PUSH
61682: LD_VAR 0 4
61686: PPUSH
61687: LD_INT 4
61689: PPUSH
61690: CALL 50891 0 2
61694: PUSH
61695: LD_INT 1
61697: ARRAY
61698: ST_TO_ADDR
// if eng > 4 then
61699: LD_VAR 0 6
61703: PUSH
61704: LD_INT 4
61706: GREATER
61707: IFFALSE 61753
// for i = eng downto 4 do
61709: LD_ADDR_VAR 0 3
61713: PUSH
61714: DOUBLE
61715: LD_VAR 0 6
61719: INC
61720: ST_TO_ADDR
61721: LD_INT 4
61723: PUSH
61724: FOR_DOWNTO
61725: IFFALSE 61751
// eng := eng diff eng [ i ] ;
61727: LD_ADDR_VAR 0 6
61731: PUSH
61732: LD_VAR 0 6
61736: PUSH
61737: LD_VAR 0 6
61741: PUSH
61742: LD_VAR 0 3
61746: ARRAY
61747: DIFF
61748: ST_TO_ADDR
61749: GO 61724
61751: POP
61752: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61753: LD_ADDR_VAR 0 4
61757: PUSH
61758: LD_VAR 0 4
61762: PUSH
61763: LD_VAR 0 5
61767: PUSH
61768: LD_VAR 0 6
61772: UNION
61773: PUSH
61774: LD_VAR 0 7
61778: UNION
61779: PUSH
61780: LD_VAR 0 8
61784: UNION
61785: DIFF
61786: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61787: LD_ADDR_VAR 0 13
61791: PUSH
61792: LD_EXP 61
61796: PUSH
61797: LD_VAR 0 1
61801: ARRAY
61802: PPUSH
61803: LD_INT 2
61805: PUSH
61806: LD_INT 30
61808: PUSH
61809: LD_INT 32
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: PUSH
61816: LD_INT 30
61818: PUSH
61819: LD_INT 31
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: EMPTY
61827: LIST
61828: LIST
61829: LIST
61830: PPUSH
61831: CALL_OW 72
61835: PUSH
61836: LD_EXP 61
61840: PUSH
61841: LD_VAR 0 1
61845: ARRAY
61846: PPUSH
61847: LD_INT 2
61849: PUSH
61850: LD_INT 30
61852: PUSH
61853: LD_INT 4
61855: PUSH
61856: EMPTY
61857: LIST
61858: LIST
61859: PUSH
61860: LD_INT 30
61862: PUSH
61863: LD_INT 5
61865: PUSH
61866: EMPTY
61867: LIST
61868: LIST
61869: PUSH
61870: EMPTY
61871: LIST
61872: LIST
61873: LIST
61874: PPUSH
61875: CALL_OW 72
61879: PUSH
61880: LD_INT 6
61882: MUL
61883: PLUS
61884: ST_TO_ADDR
// if bcount < tmp then
61885: LD_VAR 0 13
61889: PUSH
61890: LD_VAR 0 4
61894: LESS
61895: IFFALSE 61941
// for i = tmp downto bcount do
61897: LD_ADDR_VAR 0 3
61901: PUSH
61902: DOUBLE
61903: LD_VAR 0 4
61907: INC
61908: ST_TO_ADDR
61909: LD_VAR 0 13
61913: PUSH
61914: FOR_DOWNTO
61915: IFFALSE 61939
// tmp := Delete ( tmp , tmp ) ;
61917: LD_ADDR_VAR 0 4
61921: PUSH
61922: LD_VAR 0 4
61926: PPUSH
61927: LD_VAR 0 4
61931: PPUSH
61932: CALL_OW 3
61936: ST_TO_ADDR
61937: GO 61914
61939: POP
61940: POP
// result := [ tmp , 0 , 0 , p ] ;
61941: LD_ADDR_VAR 0 2
61945: PUSH
61946: LD_VAR 0 4
61950: PUSH
61951: LD_INT 0
61953: PUSH
61954: LD_INT 0
61956: PUSH
61957: LD_VAR 0 11
61961: PUSH
61962: EMPTY
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: ST_TO_ADDR
// exit ;
61968: GO 64658
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61970: LD_EXP 61
61974: PUSH
61975: LD_VAR 0 1
61979: ARRAY
61980: PPUSH
61981: LD_INT 2
61983: PUSH
61984: LD_INT 30
61986: PUSH
61987: LD_INT 6
61989: PUSH
61990: EMPTY
61991: LIST
61992: LIST
61993: PUSH
61994: LD_INT 30
61996: PUSH
61997: LD_INT 7
61999: PUSH
62000: EMPTY
62001: LIST
62002: LIST
62003: PUSH
62004: LD_INT 30
62006: PUSH
62007: LD_INT 8
62009: PUSH
62010: EMPTY
62011: LIST
62012: LIST
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: LIST
62018: LIST
62019: PPUSH
62020: CALL_OW 72
62024: NOT
62025: PUSH
62026: LD_EXP 61
62030: PUSH
62031: LD_VAR 0 1
62035: ARRAY
62036: PPUSH
62037: LD_INT 30
62039: PUSH
62040: LD_INT 3
62042: PUSH
62043: EMPTY
62044: LIST
62045: LIST
62046: PPUSH
62047: CALL_OW 72
62051: NOT
62052: AND
62053: IFFALSE 62125
// begin if eng = tmp then
62055: LD_VAR 0 6
62059: PUSH
62060: LD_VAR 0 4
62064: EQUAL
62065: IFFALSE 62069
// exit ;
62067: GO 64658
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62069: LD_ADDR_EXP 103
62073: PUSH
62074: LD_EXP 103
62078: PPUSH
62079: LD_VAR 0 1
62083: PPUSH
62084: LD_INT 1
62086: PPUSH
62087: CALL_OW 1
62091: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62092: LD_ADDR_VAR 0 2
62096: PUSH
62097: LD_INT 0
62099: PUSH
62100: LD_VAR 0 4
62104: PUSH
62105: LD_VAR 0 6
62109: DIFF
62110: PUSH
62111: LD_INT 0
62113: PUSH
62114: LD_INT 0
62116: PUSH
62117: EMPTY
62118: LIST
62119: LIST
62120: LIST
62121: LIST
62122: ST_TO_ADDR
// exit ;
62123: GO 64658
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62125: LD_EXP 88
62129: PUSH
62130: LD_EXP 87
62134: PUSH
62135: LD_VAR 0 1
62139: ARRAY
62140: ARRAY
62141: PUSH
62142: LD_EXP 61
62146: PUSH
62147: LD_VAR 0 1
62151: ARRAY
62152: PPUSH
62153: LD_INT 2
62155: PUSH
62156: LD_INT 30
62158: PUSH
62159: LD_INT 6
62161: PUSH
62162: EMPTY
62163: LIST
62164: LIST
62165: PUSH
62166: LD_INT 30
62168: PUSH
62169: LD_INT 7
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: PUSH
62176: LD_INT 30
62178: PUSH
62179: LD_INT 8
62181: PUSH
62182: EMPTY
62183: LIST
62184: LIST
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: LIST
62190: LIST
62191: PPUSH
62192: CALL_OW 72
62196: AND
62197: PUSH
62198: LD_EXP 61
62202: PUSH
62203: LD_VAR 0 1
62207: ARRAY
62208: PPUSH
62209: LD_INT 30
62211: PUSH
62212: LD_INT 3
62214: PUSH
62215: EMPTY
62216: LIST
62217: LIST
62218: PPUSH
62219: CALL_OW 72
62223: NOT
62224: AND
62225: IFFALSE 62439
// begin if sci >= 6 then
62227: LD_VAR 0 8
62231: PUSH
62232: LD_INT 6
62234: GREATEREQUAL
62235: IFFALSE 62239
// exit ;
62237: GO 64658
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62239: LD_ADDR_EXP 103
62243: PUSH
62244: LD_EXP 103
62248: PPUSH
62249: LD_VAR 0 1
62253: PPUSH
62254: LD_INT 2
62256: PPUSH
62257: CALL_OW 1
62261: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62262: LD_ADDR_VAR 0 9
62266: PUSH
62267: LD_VAR 0 4
62271: PUSH
62272: LD_VAR 0 8
62276: DIFF
62277: PPUSH
62278: LD_INT 4
62280: PPUSH
62281: CALL 50891 0 2
62285: ST_TO_ADDR
// p := [ ] ;
62286: LD_ADDR_VAR 0 11
62290: PUSH
62291: EMPTY
62292: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62293: LD_VAR 0 8
62297: PUSH
62298: LD_INT 6
62300: LESS
62301: PUSH
62302: LD_VAR 0 9
62306: PUSH
62307: LD_INT 6
62309: GREATER
62310: AND
62311: IFFALSE 62392
// begin for i = 1 to 6 - sci do
62313: LD_ADDR_VAR 0 3
62317: PUSH
62318: DOUBLE
62319: LD_INT 1
62321: DEC
62322: ST_TO_ADDR
62323: LD_INT 6
62325: PUSH
62326: LD_VAR 0 8
62330: MINUS
62331: PUSH
62332: FOR_TO
62333: IFFALSE 62388
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62335: LD_ADDR_VAR 0 11
62339: PUSH
62340: LD_VAR 0 11
62344: PPUSH
62345: LD_VAR 0 11
62349: PUSH
62350: LD_INT 1
62352: PLUS
62353: PPUSH
62354: LD_VAR 0 9
62358: PUSH
62359: LD_INT 1
62361: ARRAY
62362: PPUSH
62363: CALL_OW 2
62367: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62368: LD_ADDR_VAR 0 9
62372: PUSH
62373: LD_VAR 0 9
62377: PPUSH
62378: LD_INT 1
62380: PPUSH
62381: CALL_OW 3
62385: ST_TO_ADDR
// end ;
62386: GO 62332
62388: POP
62389: POP
// end else
62390: GO 62412
// if sort then
62392: LD_VAR 0 9
62396: IFFALSE 62412
// p := sort [ 1 ] ;
62398: LD_ADDR_VAR 0 11
62402: PUSH
62403: LD_VAR 0 9
62407: PUSH
62408: LD_INT 1
62410: ARRAY
62411: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62412: LD_ADDR_VAR 0 2
62416: PUSH
62417: LD_INT 0
62419: PUSH
62420: LD_INT 0
62422: PUSH
62423: LD_INT 0
62425: PUSH
62426: LD_VAR 0 11
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: LIST
62435: LIST
62436: ST_TO_ADDR
// exit ;
62437: GO 64658
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62439: LD_EXP 88
62443: PUSH
62444: LD_EXP 87
62448: PUSH
62449: LD_VAR 0 1
62453: ARRAY
62454: ARRAY
62455: PUSH
62456: LD_EXP 61
62460: PUSH
62461: LD_VAR 0 1
62465: ARRAY
62466: PPUSH
62467: LD_INT 2
62469: PUSH
62470: LD_INT 30
62472: PUSH
62473: LD_INT 6
62475: PUSH
62476: EMPTY
62477: LIST
62478: LIST
62479: PUSH
62480: LD_INT 30
62482: PUSH
62483: LD_INT 7
62485: PUSH
62486: EMPTY
62487: LIST
62488: LIST
62489: PUSH
62490: LD_INT 30
62492: PUSH
62493: LD_INT 8
62495: PUSH
62496: EMPTY
62497: LIST
62498: LIST
62499: PUSH
62500: EMPTY
62501: LIST
62502: LIST
62503: LIST
62504: LIST
62505: PPUSH
62506: CALL_OW 72
62510: AND
62511: PUSH
62512: LD_EXP 61
62516: PUSH
62517: LD_VAR 0 1
62521: ARRAY
62522: PPUSH
62523: LD_INT 30
62525: PUSH
62526: LD_INT 3
62528: PUSH
62529: EMPTY
62530: LIST
62531: LIST
62532: PPUSH
62533: CALL_OW 72
62537: AND
62538: IFFALSE 63272
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62540: LD_ADDR_EXP 103
62544: PUSH
62545: LD_EXP 103
62549: PPUSH
62550: LD_VAR 0 1
62554: PPUSH
62555: LD_INT 3
62557: PPUSH
62558: CALL_OW 1
62562: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62563: LD_ADDR_VAR 0 2
62567: PUSH
62568: LD_INT 0
62570: PUSH
62571: LD_INT 0
62573: PUSH
62574: LD_INT 0
62576: PUSH
62577: LD_INT 0
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: ST_TO_ADDR
// if not eng then
62586: LD_VAR 0 6
62590: NOT
62591: IFFALSE 62654
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62593: LD_ADDR_VAR 0 11
62597: PUSH
62598: LD_VAR 0 4
62602: PPUSH
62603: LD_INT 2
62605: PPUSH
62606: CALL 50891 0 2
62610: PUSH
62611: LD_INT 1
62613: ARRAY
62614: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62615: LD_ADDR_VAR 0 2
62619: PUSH
62620: LD_VAR 0 2
62624: PPUSH
62625: LD_INT 2
62627: PPUSH
62628: LD_VAR 0 11
62632: PPUSH
62633: CALL_OW 1
62637: ST_TO_ADDR
// tmp := tmp diff p ;
62638: LD_ADDR_VAR 0 4
62642: PUSH
62643: LD_VAR 0 4
62647: PUSH
62648: LD_VAR 0 11
62652: DIFF
62653: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62654: LD_VAR 0 4
62658: PUSH
62659: LD_VAR 0 8
62663: PUSH
62664: LD_INT 6
62666: LESS
62667: AND
62668: IFFALSE 62856
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62670: LD_ADDR_VAR 0 9
62674: PUSH
62675: LD_VAR 0 4
62679: PUSH
62680: LD_VAR 0 8
62684: PUSH
62685: LD_VAR 0 7
62689: UNION
62690: DIFF
62691: PPUSH
62692: LD_INT 4
62694: PPUSH
62695: CALL 50891 0 2
62699: ST_TO_ADDR
// p := [ ] ;
62700: LD_ADDR_VAR 0 11
62704: PUSH
62705: EMPTY
62706: ST_TO_ADDR
// if sort then
62707: LD_VAR 0 9
62711: IFFALSE 62827
// for i = 1 to 6 - sci do
62713: LD_ADDR_VAR 0 3
62717: PUSH
62718: DOUBLE
62719: LD_INT 1
62721: DEC
62722: ST_TO_ADDR
62723: LD_INT 6
62725: PUSH
62726: LD_VAR 0 8
62730: MINUS
62731: PUSH
62732: FOR_TO
62733: IFFALSE 62825
// begin if i = sort then
62735: LD_VAR 0 3
62739: PUSH
62740: LD_VAR 0 9
62744: EQUAL
62745: IFFALSE 62749
// break ;
62747: GO 62825
// if GetClass ( i ) = 4 then
62749: LD_VAR 0 3
62753: PPUSH
62754: CALL_OW 257
62758: PUSH
62759: LD_INT 4
62761: EQUAL
62762: IFFALSE 62766
// continue ;
62764: GO 62732
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62766: LD_ADDR_VAR 0 11
62770: PUSH
62771: LD_VAR 0 11
62775: PPUSH
62776: LD_VAR 0 11
62780: PUSH
62781: LD_INT 1
62783: PLUS
62784: PPUSH
62785: LD_VAR 0 9
62789: PUSH
62790: LD_VAR 0 3
62794: ARRAY
62795: PPUSH
62796: CALL_OW 2
62800: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62801: LD_ADDR_VAR 0 4
62805: PUSH
62806: LD_VAR 0 4
62810: PUSH
62811: LD_VAR 0 9
62815: PUSH
62816: LD_VAR 0 3
62820: ARRAY
62821: DIFF
62822: ST_TO_ADDR
// end ;
62823: GO 62732
62825: POP
62826: POP
// if p then
62827: LD_VAR 0 11
62831: IFFALSE 62856
// result := Replace ( result , 4 , p ) ;
62833: LD_ADDR_VAR 0 2
62837: PUSH
62838: LD_VAR 0 2
62842: PPUSH
62843: LD_INT 4
62845: PPUSH
62846: LD_VAR 0 11
62850: PPUSH
62851: CALL_OW 1
62855: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62856: LD_VAR 0 4
62860: PUSH
62861: LD_VAR 0 7
62865: PUSH
62866: LD_INT 6
62868: LESS
62869: AND
62870: IFFALSE 63058
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62872: LD_ADDR_VAR 0 9
62876: PUSH
62877: LD_VAR 0 4
62881: PUSH
62882: LD_VAR 0 8
62886: PUSH
62887: LD_VAR 0 7
62891: UNION
62892: DIFF
62893: PPUSH
62894: LD_INT 3
62896: PPUSH
62897: CALL 50891 0 2
62901: ST_TO_ADDR
// p := [ ] ;
62902: LD_ADDR_VAR 0 11
62906: PUSH
62907: EMPTY
62908: ST_TO_ADDR
// if sort then
62909: LD_VAR 0 9
62913: IFFALSE 63029
// for i = 1 to 6 - mech do
62915: LD_ADDR_VAR 0 3
62919: PUSH
62920: DOUBLE
62921: LD_INT 1
62923: DEC
62924: ST_TO_ADDR
62925: LD_INT 6
62927: PUSH
62928: LD_VAR 0 7
62932: MINUS
62933: PUSH
62934: FOR_TO
62935: IFFALSE 63027
// begin if i = sort then
62937: LD_VAR 0 3
62941: PUSH
62942: LD_VAR 0 9
62946: EQUAL
62947: IFFALSE 62951
// break ;
62949: GO 63027
// if GetClass ( i ) = 3 then
62951: LD_VAR 0 3
62955: PPUSH
62956: CALL_OW 257
62960: PUSH
62961: LD_INT 3
62963: EQUAL
62964: IFFALSE 62968
// continue ;
62966: GO 62934
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62968: LD_ADDR_VAR 0 11
62972: PUSH
62973: LD_VAR 0 11
62977: PPUSH
62978: LD_VAR 0 11
62982: PUSH
62983: LD_INT 1
62985: PLUS
62986: PPUSH
62987: LD_VAR 0 9
62991: PUSH
62992: LD_VAR 0 3
62996: ARRAY
62997: PPUSH
62998: CALL_OW 2
63002: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63003: LD_ADDR_VAR 0 4
63007: PUSH
63008: LD_VAR 0 4
63012: PUSH
63013: LD_VAR 0 9
63017: PUSH
63018: LD_VAR 0 3
63022: ARRAY
63023: DIFF
63024: ST_TO_ADDR
// end ;
63025: GO 62934
63027: POP
63028: POP
// if p then
63029: LD_VAR 0 11
63033: IFFALSE 63058
// result := Replace ( result , 3 , p ) ;
63035: LD_ADDR_VAR 0 2
63039: PUSH
63040: LD_VAR 0 2
63044: PPUSH
63045: LD_INT 3
63047: PPUSH
63048: LD_VAR 0 11
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63058: LD_VAR 0 4
63062: PUSH
63063: LD_INT 6
63065: GREATER
63066: PUSH
63067: LD_VAR 0 6
63071: PUSH
63072: LD_INT 6
63074: LESS
63075: AND
63076: IFFALSE 63270
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63078: LD_ADDR_VAR 0 9
63082: PUSH
63083: LD_VAR 0 4
63087: PUSH
63088: LD_VAR 0 8
63092: PUSH
63093: LD_VAR 0 7
63097: UNION
63098: PUSH
63099: LD_VAR 0 6
63103: UNION
63104: DIFF
63105: PPUSH
63106: LD_INT 2
63108: PPUSH
63109: CALL 50891 0 2
63113: ST_TO_ADDR
// p := [ ] ;
63114: LD_ADDR_VAR 0 11
63118: PUSH
63119: EMPTY
63120: ST_TO_ADDR
// if sort then
63121: LD_VAR 0 9
63125: IFFALSE 63241
// for i = 1 to 6 - eng do
63127: LD_ADDR_VAR 0 3
63131: PUSH
63132: DOUBLE
63133: LD_INT 1
63135: DEC
63136: ST_TO_ADDR
63137: LD_INT 6
63139: PUSH
63140: LD_VAR 0 6
63144: MINUS
63145: PUSH
63146: FOR_TO
63147: IFFALSE 63239
// begin if i = sort then
63149: LD_VAR 0 3
63153: PUSH
63154: LD_VAR 0 9
63158: EQUAL
63159: IFFALSE 63163
// break ;
63161: GO 63239
// if GetClass ( i ) = 2 then
63163: LD_VAR 0 3
63167: PPUSH
63168: CALL_OW 257
63172: PUSH
63173: LD_INT 2
63175: EQUAL
63176: IFFALSE 63180
// continue ;
63178: GO 63146
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63180: LD_ADDR_VAR 0 11
63184: PUSH
63185: LD_VAR 0 11
63189: PPUSH
63190: LD_VAR 0 11
63194: PUSH
63195: LD_INT 1
63197: PLUS
63198: PPUSH
63199: LD_VAR 0 9
63203: PUSH
63204: LD_VAR 0 3
63208: ARRAY
63209: PPUSH
63210: CALL_OW 2
63214: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63215: LD_ADDR_VAR 0 4
63219: PUSH
63220: LD_VAR 0 4
63224: PUSH
63225: LD_VAR 0 9
63229: PUSH
63230: LD_VAR 0 3
63234: ARRAY
63235: DIFF
63236: ST_TO_ADDR
// end ;
63237: GO 63146
63239: POP
63240: POP
// if p then
63241: LD_VAR 0 11
63245: IFFALSE 63270
// result := Replace ( result , 2 , p ) ;
63247: LD_ADDR_VAR 0 2
63251: PUSH
63252: LD_VAR 0 2
63256: PPUSH
63257: LD_INT 2
63259: PPUSH
63260: LD_VAR 0 11
63264: PPUSH
63265: CALL_OW 1
63269: ST_TO_ADDR
// end ; exit ;
63270: GO 64658
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63272: LD_EXP 88
63276: PUSH
63277: LD_EXP 87
63281: PUSH
63282: LD_VAR 0 1
63286: ARRAY
63287: ARRAY
63288: NOT
63289: PUSH
63290: LD_EXP 61
63294: PUSH
63295: LD_VAR 0 1
63299: ARRAY
63300: PPUSH
63301: LD_INT 30
63303: PUSH
63304: LD_INT 3
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: PPUSH
63311: CALL_OW 72
63315: AND
63316: PUSH
63317: LD_EXP 66
63321: PUSH
63322: LD_VAR 0 1
63326: ARRAY
63327: AND
63328: IFFALSE 63936
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63330: LD_ADDR_EXP 103
63334: PUSH
63335: LD_EXP 103
63339: PPUSH
63340: LD_VAR 0 1
63344: PPUSH
63345: LD_INT 5
63347: PPUSH
63348: CALL_OW 1
63352: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63353: LD_ADDR_VAR 0 2
63357: PUSH
63358: LD_INT 0
63360: PUSH
63361: LD_INT 0
63363: PUSH
63364: LD_INT 0
63366: PUSH
63367: LD_INT 0
63369: PUSH
63370: EMPTY
63371: LIST
63372: LIST
63373: LIST
63374: LIST
63375: ST_TO_ADDR
// if sci > 1 then
63376: LD_VAR 0 8
63380: PUSH
63381: LD_INT 1
63383: GREATER
63384: IFFALSE 63412
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63386: LD_ADDR_VAR 0 4
63390: PUSH
63391: LD_VAR 0 4
63395: PUSH
63396: LD_VAR 0 8
63400: PUSH
63401: LD_VAR 0 8
63405: PUSH
63406: LD_INT 1
63408: ARRAY
63409: DIFF
63410: DIFF
63411: ST_TO_ADDR
// if tmp and not sci then
63412: LD_VAR 0 4
63416: PUSH
63417: LD_VAR 0 8
63421: NOT
63422: AND
63423: IFFALSE 63492
// begin sort := SortBySkill ( tmp , 4 ) ;
63425: LD_ADDR_VAR 0 9
63429: PUSH
63430: LD_VAR 0 4
63434: PPUSH
63435: LD_INT 4
63437: PPUSH
63438: CALL 50891 0 2
63442: ST_TO_ADDR
// if sort then
63443: LD_VAR 0 9
63447: IFFALSE 63463
// p := sort [ 1 ] ;
63449: LD_ADDR_VAR 0 11
63453: PUSH
63454: LD_VAR 0 9
63458: PUSH
63459: LD_INT 1
63461: ARRAY
63462: ST_TO_ADDR
// if p then
63463: LD_VAR 0 11
63467: IFFALSE 63492
// result := Replace ( result , 4 , p ) ;
63469: LD_ADDR_VAR 0 2
63473: PUSH
63474: LD_VAR 0 2
63478: PPUSH
63479: LD_INT 4
63481: PPUSH
63482: LD_VAR 0 11
63486: PPUSH
63487: CALL_OW 1
63491: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63492: LD_ADDR_VAR 0 4
63496: PUSH
63497: LD_VAR 0 4
63501: PUSH
63502: LD_VAR 0 7
63506: DIFF
63507: ST_TO_ADDR
// if tmp and mech < 6 then
63508: LD_VAR 0 4
63512: PUSH
63513: LD_VAR 0 7
63517: PUSH
63518: LD_INT 6
63520: LESS
63521: AND
63522: IFFALSE 63710
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63524: LD_ADDR_VAR 0 9
63528: PUSH
63529: LD_VAR 0 4
63533: PUSH
63534: LD_VAR 0 8
63538: PUSH
63539: LD_VAR 0 7
63543: UNION
63544: DIFF
63545: PPUSH
63546: LD_INT 3
63548: PPUSH
63549: CALL 50891 0 2
63553: ST_TO_ADDR
// p := [ ] ;
63554: LD_ADDR_VAR 0 11
63558: PUSH
63559: EMPTY
63560: ST_TO_ADDR
// if sort then
63561: LD_VAR 0 9
63565: IFFALSE 63681
// for i = 1 to 6 - mech do
63567: LD_ADDR_VAR 0 3
63571: PUSH
63572: DOUBLE
63573: LD_INT 1
63575: DEC
63576: ST_TO_ADDR
63577: LD_INT 6
63579: PUSH
63580: LD_VAR 0 7
63584: MINUS
63585: PUSH
63586: FOR_TO
63587: IFFALSE 63679
// begin if i = sort then
63589: LD_VAR 0 3
63593: PUSH
63594: LD_VAR 0 9
63598: EQUAL
63599: IFFALSE 63603
// break ;
63601: GO 63679
// if GetClass ( i ) = 3 then
63603: LD_VAR 0 3
63607: PPUSH
63608: CALL_OW 257
63612: PUSH
63613: LD_INT 3
63615: EQUAL
63616: IFFALSE 63620
// continue ;
63618: GO 63586
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63620: LD_ADDR_VAR 0 11
63624: PUSH
63625: LD_VAR 0 11
63629: PPUSH
63630: LD_VAR 0 11
63634: PUSH
63635: LD_INT 1
63637: PLUS
63638: PPUSH
63639: LD_VAR 0 9
63643: PUSH
63644: LD_VAR 0 3
63648: ARRAY
63649: PPUSH
63650: CALL_OW 2
63654: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63655: LD_ADDR_VAR 0 4
63659: PUSH
63660: LD_VAR 0 4
63664: PUSH
63665: LD_VAR 0 9
63669: PUSH
63670: LD_VAR 0 3
63674: ARRAY
63675: DIFF
63676: ST_TO_ADDR
// end ;
63677: GO 63586
63679: POP
63680: POP
// if p then
63681: LD_VAR 0 11
63685: IFFALSE 63710
// result := Replace ( result , 3 , p ) ;
63687: LD_ADDR_VAR 0 2
63691: PUSH
63692: LD_VAR 0 2
63696: PPUSH
63697: LD_INT 3
63699: PPUSH
63700: LD_VAR 0 11
63704: PPUSH
63705: CALL_OW 1
63709: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63710: LD_ADDR_VAR 0 4
63714: PUSH
63715: LD_VAR 0 4
63719: PUSH
63720: LD_VAR 0 6
63724: DIFF
63725: ST_TO_ADDR
// if tmp and eng < 6 then
63726: LD_VAR 0 4
63730: PUSH
63731: LD_VAR 0 6
63735: PUSH
63736: LD_INT 6
63738: LESS
63739: AND
63740: IFFALSE 63934
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63742: LD_ADDR_VAR 0 9
63746: PUSH
63747: LD_VAR 0 4
63751: PUSH
63752: LD_VAR 0 8
63756: PUSH
63757: LD_VAR 0 7
63761: UNION
63762: PUSH
63763: LD_VAR 0 6
63767: UNION
63768: DIFF
63769: PPUSH
63770: LD_INT 2
63772: PPUSH
63773: CALL 50891 0 2
63777: ST_TO_ADDR
// p := [ ] ;
63778: LD_ADDR_VAR 0 11
63782: PUSH
63783: EMPTY
63784: ST_TO_ADDR
// if sort then
63785: LD_VAR 0 9
63789: IFFALSE 63905
// for i = 1 to 6 - eng do
63791: LD_ADDR_VAR 0 3
63795: PUSH
63796: DOUBLE
63797: LD_INT 1
63799: DEC
63800: ST_TO_ADDR
63801: LD_INT 6
63803: PUSH
63804: LD_VAR 0 6
63808: MINUS
63809: PUSH
63810: FOR_TO
63811: IFFALSE 63903
// begin if i = sort then
63813: LD_VAR 0 3
63817: PUSH
63818: LD_VAR 0 9
63822: EQUAL
63823: IFFALSE 63827
// break ;
63825: GO 63903
// if GetClass ( i ) = 2 then
63827: LD_VAR 0 3
63831: PPUSH
63832: CALL_OW 257
63836: PUSH
63837: LD_INT 2
63839: EQUAL
63840: IFFALSE 63844
// continue ;
63842: GO 63810
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63844: LD_ADDR_VAR 0 11
63848: PUSH
63849: LD_VAR 0 11
63853: PPUSH
63854: LD_VAR 0 11
63858: PUSH
63859: LD_INT 1
63861: PLUS
63862: PPUSH
63863: LD_VAR 0 9
63867: PUSH
63868: LD_VAR 0 3
63872: ARRAY
63873: PPUSH
63874: CALL_OW 2
63878: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63879: LD_ADDR_VAR 0 4
63883: PUSH
63884: LD_VAR 0 4
63888: PUSH
63889: LD_VAR 0 9
63893: PUSH
63894: LD_VAR 0 3
63898: ARRAY
63899: DIFF
63900: ST_TO_ADDR
// end ;
63901: GO 63810
63903: POP
63904: POP
// if p then
63905: LD_VAR 0 11
63909: IFFALSE 63934
// result := Replace ( result , 2 , p ) ;
63911: LD_ADDR_VAR 0 2
63915: PUSH
63916: LD_VAR 0 2
63920: PPUSH
63921: LD_INT 2
63923: PPUSH
63924: LD_VAR 0 11
63928: PPUSH
63929: CALL_OW 1
63933: ST_TO_ADDR
// end ; exit ;
63934: GO 64658
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63936: LD_EXP 88
63940: PUSH
63941: LD_EXP 87
63945: PUSH
63946: LD_VAR 0 1
63950: ARRAY
63951: ARRAY
63952: NOT
63953: PUSH
63954: LD_EXP 61
63958: PUSH
63959: LD_VAR 0 1
63963: ARRAY
63964: PPUSH
63965: LD_INT 30
63967: PUSH
63968: LD_INT 3
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PPUSH
63975: CALL_OW 72
63979: AND
63980: PUSH
63981: LD_EXP 66
63985: PUSH
63986: LD_VAR 0 1
63990: ARRAY
63991: NOT
63992: AND
63993: IFFALSE 64658
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63995: LD_ADDR_EXP 103
63999: PUSH
64000: LD_EXP 103
64004: PPUSH
64005: LD_VAR 0 1
64009: PPUSH
64010: LD_INT 6
64012: PPUSH
64013: CALL_OW 1
64017: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64018: LD_ADDR_VAR 0 2
64022: PUSH
64023: LD_INT 0
64025: PUSH
64026: LD_INT 0
64028: PUSH
64029: LD_INT 0
64031: PUSH
64032: LD_INT 0
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: ST_TO_ADDR
// if sci >= 1 then
64041: LD_VAR 0 8
64045: PUSH
64046: LD_INT 1
64048: GREATEREQUAL
64049: IFFALSE 64071
// tmp := tmp diff sci [ 1 ] ;
64051: LD_ADDR_VAR 0 4
64055: PUSH
64056: LD_VAR 0 4
64060: PUSH
64061: LD_VAR 0 8
64065: PUSH
64066: LD_INT 1
64068: ARRAY
64069: DIFF
64070: ST_TO_ADDR
// if tmp and not sci then
64071: LD_VAR 0 4
64075: PUSH
64076: LD_VAR 0 8
64080: NOT
64081: AND
64082: IFFALSE 64151
// begin sort := SortBySkill ( tmp , 4 ) ;
64084: LD_ADDR_VAR 0 9
64088: PUSH
64089: LD_VAR 0 4
64093: PPUSH
64094: LD_INT 4
64096: PPUSH
64097: CALL 50891 0 2
64101: ST_TO_ADDR
// if sort then
64102: LD_VAR 0 9
64106: IFFALSE 64122
// p := sort [ 1 ] ;
64108: LD_ADDR_VAR 0 11
64112: PUSH
64113: LD_VAR 0 9
64117: PUSH
64118: LD_INT 1
64120: ARRAY
64121: ST_TO_ADDR
// if p then
64122: LD_VAR 0 11
64126: IFFALSE 64151
// result := Replace ( result , 4 , p ) ;
64128: LD_ADDR_VAR 0 2
64132: PUSH
64133: LD_VAR 0 2
64137: PPUSH
64138: LD_INT 4
64140: PPUSH
64141: LD_VAR 0 11
64145: PPUSH
64146: CALL_OW 1
64150: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64151: LD_ADDR_VAR 0 4
64155: PUSH
64156: LD_VAR 0 4
64160: PUSH
64161: LD_VAR 0 7
64165: DIFF
64166: ST_TO_ADDR
// if tmp and mech < 6 then
64167: LD_VAR 0 4
64171: PUSH
64172: LD_VAR 0 7
64176: PUSH
64177: LD_INT 6
64179: LESS
64180: AND
64181: IFFALSE 64363
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64183: LD_ADDR_VAR 0 9
64187: PUSH
64188: LD_VAR 0 4
64192: PUSH
64193: LD_VAR 0 7
64197: DIFF
64198: PPUSH
64199: LD_INT 3
64201: PPUSH
64202: CALL 50891 0 2
64206: ST_TO_ADDR
// p := [ ] ;
64207: LD_ADDR_VAR 0 11
64211: PUSH
64212: EMPTY
64213: ST_TO_ADDR
// if sort then
64214: LD_VAR 0 9
64218: IFFALSE 64334
// for i = 1 to 6 - mech do
64220: LD_ADDR_VAR 0 3
64224: PUSH
64225: DOUBLE
64226: LD_INT 1
64228: DEC
64229: ST_TO_ADDR
64230: LD_INT 6
64232: PUSH
64233: LD_VAR 0 7
64237: MINUS
64238: PUSH
64239: FOR_TO
64240: IFFALSE 64332
// begin if i = sort then
64242: LD_VAR 0 3
64246: PUSH
64247: LD_VAR 0 9
64251: EQUAL
64252: IFFALSE 64256
// break ;
64254: GO 64332
// if GetClass ( i ) = 3 then
64256: LD_VAR 0 3
64260: PPUSH
64261: CALL_OW 257
64265: PUSH
64266: LD_INT 3
64268: EQUAL
64269: IFFALSE 64273
// continue ;
64271: GO 64239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64273: LD_ADDR_VAR 0 11
64277: PUSH
64278: LD_VAR 0 11
64282: PPUSH
64283: LD_VAR 0 11
64287: PUSH
64288: LD_INT 1
64290: PLUS
64291: PPUSH
64292: LD_VAR 0 9
64296: PUSH
64297: LD_VAR 0 3
64301: ARRAY
64302: PPUSH
64303: CALL_OW 2
64307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64308: LD_ADDR_VAR 0 4
64312: PUSH
64313: LD_VAR 0 4
64317: PUSH
64318: LD_VAR 0 9
64322: PUSH
64323: LD_VAR 0 3
64327: ARRAY
64328: DIFF
64329: ST_TO_ADDR
// end ;
64330: GO 64239
64332: POP
64333: POP
// if p then
64334: LD_VAR 0 11
64338: IFFALSE 64363
// result := Replace ( result , 3 , p ) ;
64340: LD_ADDR_VAR 0 2
64344: PUSH
64345: LD_VAR 0 2
64349: PPUSH
64350: LD_INT 3
64352: PPUSH
64353: LD_VAR 0 11
64357: PPUSH
64358: CALL_OW 1
64362: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64363: LD_ADDR_VAR 0 4
64367: PUSH
64368: LD_VAR 0 4
64372: PUSH
64373: LD_VAR 0 6
64377: DIFF
64378: ST_TO_ADDR
// if tmp and eng < 4 then
64379: LD_VAR 0 4
64383: PUSH
64384: LD_VAR 0 6
64388: PUSH
64389: LD_INT 4
64391: LESS
64392: AND
64393: IFFALSE 64583
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64395: LD_ADDR_VAR 0 9
64399: PUSH
64400: LD_VAR 0 4
64404: PUSH
64405: LD_VAR 0 7
64409: PUSH
64410: LD_VAR 0 6
64414: UNION
64415: DIFF
64416: PPUSH
64417: LD_INT 2
64419: PPUSH
64420: CALL 50891 0 2
64424: ST_TO_ADDR
// p := [ ] ;
64425: LD_ADDR_VAR 0 11
64429: PUSH
64430: EMPTY
64431: ST_TO_ADDR
// if sort then
64432: LD_VAR 0 9
64436: IFFALSE 64552
// for i = 1 to 4 - eng do
64438: LD_ADDR_VAR 0 3
64442: PUSH
64443: DOUBLE
64444: LD_INT 1
64446: DEC
64447: ST_TO_ADDR
64448: LD_INT 4
64450: PUSH
64451: LD_VAR 0 6
64455: MINUS
64456: PUSH
64457: FOR_TO
64458: IFFALSE 64550
// begin if i = sort then
64460: LD_VAR 0 3
64464: PUSH
64465: LD_VAR 0 9
64469: EQUAL
64470: IFFALSE 64474
// break ;
64472: GO 64550
// if GetClass ( i ) = 2 then
64474: LD_VAR 0 3
64478: PPUSH
64479: CALL_OW 257
64483: PUSH
64484: LD_INT 2
64486: EQUAL
64487: IFFALSE 64491
// continue ;
64489: GO 64457
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64491: LD_ADDR_VAR 0 11
64495: PUSH
64496: LD_VAR 0 11
64500: PPUSH
64501: LD_VAR 0 11
64505: PUSH
64506: LD_INT 1
64508: PLUS
64509: PPUSH
64510: LD_VAR 0 9
64514: PUSH
64515: LD_VAR 0 3
64519: ARRAY
64520: PPUSH
64521: CALL_OW 2
64525: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64526: LD_ADDR_VAR 0 4
64530: PUSH
64531: LD_VAR 0 4
64535: PUSH
64536: LD_VAR 0 9
64540: PUSH
64541: LD_VAR 0 3
64545: ARRAY
64546: DIFF
64547: ST_TO_ADDR
// end ;
64548: GO 64457
64550: POP
64551: POP
// if p then
64552: LD_VAR 0 11
64556: IFFALSE 64581
// result := Replace ( result , 2 , p ) ;
64558: LD_ADDR_VAR 0 2
64562: PUSH
64563: LD_VAR 0 2
64567: PPUSH
64568: LD_INT 2
64570: PPUSH
64571: LD_VAR 0 11
64575: PPUSH
64576: CALL_OW 1
64580: ST_TO_ADDR
// end else
64581: GO 64627
// for i = eng downto 5 do
64583: LD_ADDR_VAR 0 3
64587: PUSH
64588: DOUBLE
64589: LD_VAR 0 6
64593: INC
64594: ST_TO_ADDR
64595: LD_INT 5
64597: PUSH
64598: FOR_DOWNTO
64599: IFFALSE 64625
// tmp := tmp union eng [ i ] ;
64601: LD_ADDR_VAR 0 4
64605: PUSH
64606: LD_VAR 0 4
64610: PUSH
64611: LD_VAR 0 6
64615: PUSH
64616: LD_VAR 0 3
64620: ARRAY
64621: UNION
64622: ST_TO_ADDR
64623: GO 64598
64625: POP
64626: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64627: LD_ADDR_VAR 0 2
64631: PUSH
64632: LD_VAR 0 2
64636: PPUSH
64637: LD_INT 1
64639: PPUSH
64640: LD_VAR 0 4
64644: PUSH
64645: LD_VAR 0 5
64649: DIFF
64650: PPUSH
64651: CALL_OW 1
64655: ST_TO_ADDR
// exit ;
64656: GO 64658
// end ; end ;
64658: LD_VAR 0 2
64662: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64663: LD_INT 0
64665: PPUSH
64666: PPUSH
64667: PPUSH
// if not mc_bases then
64668: LD_EXP 61
64672: NOT
64673: IFFALSE 64677
// exit ;
64675: GO 64819
// for i = 1 to mc_bases do
64677: LD_ADDR_VAR 0 2
64681: PUSH
64682: DOUBLE
64683: LD_INT 1
64685: DEC
64686: ST_TO_ADDR
64687: LD_EXP 61
64691: PUSH
64692: FOR_TO
64693: IFFALSE 64810
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64695: LD_ADDR_VAR 0 3
64699: PUSH
64700: LD_EXP 61
64704: PUSH
64705: LD_VAR 0 2
64709: ARRAY
64710: PPUSH
64711: LD_INT 21
64713: PUSH
64714: LD_INT 3
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 3
64723: PUSH
64724: LD_INT 2
64726: PUSH
64727: LD_INT 30
64729: PUSH
64730: LD_INT 29
64732: PUSH
64733: EMPTY
64734: LIST
64735: LIST
64736: PUSH
64737: LD_INT 30
64739: PUSH
64740: LD_INT 30
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: LIST
64751: PUSH
64752: EMPTY
64753: LIST
64754: LIST
64755: PUSH
64756: LD_INT 3
64758: PUSH
64759: LD_INT 24
64761: PUSH
64762: LD_INT 1000
64764: PUSH
64765: EMPTY
64766: LIST
64767: LIST
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: EMPTY
64774: LIST
64775: LIST
64776: LIST
64777: PPUSH
64778: CALL_OW 72
64782: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64783: LD_ADDR_EXP 62
64787: PUSH
64788: LD_EXP 62
64792: PPUSH
64793: LD_VAR 0 2
64797: PPUSH
64798: LD_VAR 0 3
64802: PPUSH
64803: CALL_OW 1
64807: ST_TO_ADDR
// end ;
64808: GO 64692
64810: POP
64811: POP
// RaiseSailEvent ( 101 ) ;
64812: LD_INT 101
64814: PPUSH
64815: CALL_OW 427
// end ;
64819: LD_VAR 0 1
64823: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64824: LD_INT 0
64826: PPUSH
64827: PPUSH
64828: PPUSH
64829: PPUSH
64830: PPUSH
64831: PPUSH
64832: PPUSH
// if not mc_bases then
64833: LD_EXP 61
64837: NOT
64838: IFFALSE 64842
// exit ;
64840: GO 65404
// for i = 1 to mc_bases do
64842: LD_ADDR_VAR 0 2
64846: PUSH
64847: DOUBLE
64848: LD_INT 1
64850: DEC
64851: ST_TO_ADDR
64852: LD_EXP 61
64856: PUSH
64857: FOR_TO
64858: IFFALSE 65395
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64860: LD_ADDR_VAR 0 5
64864: PUSH
64865: LD_EXP 61
64869: PUSH
64870: LD_VAR 0 2
64874: ARRAY
64875: PUSH
64876: LD_EXP 90
64880: PUSH
64881: LD_VAR 0 2
64885: ARRAY
64886: UNION
64887: PPUSH
64888: LD_INT 21
64890: PUSH
64891: LD_INT 1
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 1
64900: PUSH
64901: LD_INT 3
64903: PUSH
64904: LD_INT 54
64906: PUSH
64907: EMPTY
64908: LIST
64909: PUSH
64910: EMPTY
64911: LIST
64912: LIST
64913: PUSH
64914: LD_INT 3
64916: PUSH
64917: LD_INT 24
64919: PUSH
64920: LD_INT 1000
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: PUSH
64931: EMPTY
64932: LIST
64933: LIST
64934: LIST
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PPUSH
64940: CALL_OW 72
64944: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64945: LD_ADDR_VAR 0 6
64949: PUSH
64950: LD_EXP 61
64954: PUSH
64955: LD_VAR 0 2
64959: ARRAY
64960: PPUSH
64961: LD_INT 21
64963: PUSH
64964: LD_INT 1
64966: PUSH
64967: EMPTY
64968: LIST
64969: LIST
64970: PUSH
64971: LD_INT 1
64973: PUSH
64974: LD_INT 3
64976: PUSH
64977: LD_INT 54
64979: PUSH
64980: EMPTY
64981: LIST
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 3
64989: PUSH
64990: LD_INT 24
64992: PUSH
64993: LD_INT 250
64995: PUSH
64996: EMPTY
64997: LIST
64998: LIST
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: LIST
65008: PUSH
65009: EMPTY
65010: LIST
65011: LIST
65012: PPUSH
65013: CALL_OW 72
65017: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65018: LD_ADDR_VAR 0 7
65022: PUSH
65023: LD_VAR 0 5
65027: PUSH
65028: LD_VAR 0 6
65032: DIFF
65033: ST_TO_ADDR
// if not need_heal_1 then
65034: LD_VAR 0 6
65038: NOT
65039: IFFALSE 65072
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65041: LD_ADDR_EXP 64
65045: PUSH
65046: LD_EXP 64
65050: PPUSH
65051: LD_VAR 0 2
65055: PUSH
65056: LD_INT 1
65058: PUSH
65059: EMPTY
65060: LIST
65061: LIST
65062: PPUSH
65063: EMPTY
65064: PPUSH
65065: CALL 20070 0 3
65069: ST_TO_ADDR
65070: GO 65142
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65072: LD_ADDR_EXP 64
65076: PUSH
65077: LD_EXP 64
65081: PPUSH
65082: LD_VAR 0 2
65086: PUSH
65087: LD_INT 1
65089: PUSH
65090: EMPTY
65091: LIST
65092: LIST
65093: PPUSH
65094: LD_EXP 64
65098: PUSH
65099: LD_VAR 0 2
65103: ARRAY
65104: PUSH
65105: LD_INT 1
65107: ARRAY
65108: PPUSH
65109: LD_INT 3
65111: PUSH
65112: LD_INT 24
65114: PUSH
65115: LD_INT 1000
65117: PUSH
65118: EMPTY
65119: LIST
65120: LIST
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PPUSH
65126: CALL_OW 72
65130: PUSH
65131: LD_VAR 0 6
65135: UNION
65136: PPUSH
65137: CALL 20070 0 3
65141: ST_TO_ADDR
// if not need_heal_2 then
65142: LD_VAR 0 7
65146: NOT
65147: IFFALSE 65180
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65149: LD_ADDR_EXP 64
65153: PUSH
65154: LD_EXP 64
65158: PPUSH
65159: LD_VAR 0 2
65163: PUSH
65164: LD_INT 2
65166: PUSH
65167: EMPTY
65168: LIST
65169: LIST
65170: PPUSH
65171: EMPTY
65172: PPUSH
65173: CALL 20070 0 3
65177: ST_TO_ADDR
65178: GO 65212
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65180: LD_ADDR_EXP 64
65184: PUSH
65185: LD_EXP 64
65189: PPUSH
65190: LD_VAR 0 2
65194: PUSH
65195: LD_INT 2
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PPUSH
65202: LD_VAR 0 7
65206: PPUSH
65207: CALL 20070 0 3
65211: ST_TO_ADDR
// if need_heal_2 then
65212: LD_VAR 0 7
65216: IFFALSE 65377
// for j in need_heal_2 do
65218: LD_ADDR_VAR 0 3
65222: PUSH
65223: LD_VAR 0 7
65227: PUSH
65228: FOR_IN
65229: IFFALSE 65375
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65231: LD_ADDR_VAR 0 5
65235: PUSH
65236: LD_EXP 61
65240: PUSH
65241: LD_VAR 0 2
65245: ARRAY
65246: PPUSH
65247: LD_INT 2
65249: PUSH
65250: LD_INT 30
65252: PUSH
65253: LD_INT 6
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: LD_INT 30
65262: PUSH
65263: LD_INT 7
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PUSH
65270: LD_INT 30
65272: PUSH
65273: LD_INT 8
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 30
65282: PUSH
65283: LD_INT 0
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: LD_INT 30
65292: PUSH
65293: LD_INT 1
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: EMPTY
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: LIST
65306: LIST
65307: PPUSH
65308: CALL_OW 72
65312: ST_TO_ADDR
// if tmp then
65313: LD_VAR 0 5
65317: IFFALSE 65373
// begin k := NearestUnitToUnit ( tmp , j ) ;
65319: LD_ADDR_VAR 0 4
65323: PUSH
65324: LD_VAR 0 5
65328: PPUSH
65329: LD_VAR 0 3
65333: PPUSH
65334: CALL_OW 74
65338: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65339: LD_VAR 0 3
65343: PPUSH
65344: LD_VAR 0 4
65348: PPUSH
65349: CALL_OW 296
65353: PUSH
65354: LD_INT 5
65356: GREATER
65357: IFFALSE 65373
// ComMoveToNearbyEntrance ( j , k ) ;
65359: LD_VAR 0 3
65363: PPUSH
65364: LD_VAR 0 4
65368: PPUSH
65369: CALL 53259 0 2
// end ; end ;
65373: GO 65228
65375: POP
65376: POP
// if not need_heal_1 and not need_heal_2 then
65377: LD_VAR 0 6
65381: NOT
65382: PUSH
65383: LD_VAR 0 7
65387: NOT
65388: AND
65389: IFFALSE 65393
// continue ;
65391: GO 64857
// end ;
65393: GO 64857
65395: POP
65396: POP
// RaiseSailEvent ( 102 ) ;
65397: LD_INT 102
65399: PPUSH
65400: CALL_OW 427
// end ;
65404: LD_VAR 0 1
65408: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65409: LD_INT 0
65411: PPUSH
65412: PPUSH
65413: PPUSH
65414: PPUSH
65415: PPUSH
65416: PPUSH
65417: PPUSH
65418: PPUSH
// if not mc_bases then
65419: LD_EXP 61
65423: NOT
65424: IFFALSE 65428
// exit ;
65426: GO 66339
// for i = 1 to mc_bases do
65428: LD_ADDR_VAR 0 2
65432: PUSH
65433: DOUBLE
65434: LD_INT 1
65436: DEC
65437: ST_TO_ADDR
65438: LD_EXP 61
65442: PUSH
65443: FOR_TO
65444: IFFALSE 66337
// begin if not mc_building_need_repair [ i ] then
65446: LD_EXP 62
65450: PUSH
65451: LD_VAR 0 2
65455: ARRAY
65456: NOT
65457: IFFALSE 65642
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65459: LD_ADDR_VAR 0 6
65463: PUSH
65464: LD_EXP 80
65468: PUSH
65469: LD_VAR 0 2
65473: ARRAY
65474: PPUSH
65475: LD_INT 3
65477: PUSH
65478: LD_INT 24
65480: PUSH
65481: LD_INT 1000
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PUSH
65488: EMPTY
65489: LIST
65490: LIST
65491: PUSH
65492: LD_INT 2
65494: PUSH
65495: LD_INT 34
65497: PUSH
65498: LD_INT 13
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 34
65507: PUSH
65508: LD_INT 52
65510: PUSH
65511: EMPTY
65512: LIST
65513: LIST
65514: PUSH
65515: LD_INT 34
65517: PUSH
65518: LD_INT 88
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: LIST
65529: LIST
65530: PUSH
65531: EMPTY
65532: LIST
65533: LIST
65534: PPUSH
65535: CALL_OW 72
65539: ST_TO_ADDR
// if cranes then
65540: LD_VAR 0 6
65544: IFFALSE 65606
// for j in cranes do
65546: LD_ADDR_VAR 0 3
65550: PUSH
65551: LD_VAR 0 6
65555: PUSH
65556: FOR_IN
65557: IFFALSE 65604
// if not IsInArea ( j , mc_parking [ i ] ) then
65559: LD_VAR 0 3
65563: PPUSH
65564: LD_EXP 85
65568: PUSH
65569: LD_VAR 0 2
65573: ARRAY
65574: PPUSH
65575: CALL_OW 308
65579: NOT
65580: IFFALSE 65602
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65582: LD_VAR 0 3
65586: PPUSH
65587: LD_EXP 85
65591: PUSH
65592: LD_VAR 0 2
65596: ARRAY
65597: PPUSH
65598: CALL_OW 113
65602: GO 65556
65604: POP
65605: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65606: LD_ADDR_EXP 63
65610: PUSH
65611: LD_EXP 63
65615: PPUSH
65616: LD_VAR 0 2
65620: PPUSH
65621: EMPTY
65622: PPUSH
65623: CALL_OW 1
65627: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65628: LD_VAR 0 2
65632: PPUSH
65633: LD_INT 101
65635: PPUSH
65636: CALL 60496 0 2
// continue ;
65640: GO 65443
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65642: LD_ADDR_EXP 67
65646: PUSH
65647: LD_EXP 67
65651: PPUSH
65652: LD_VAR 0 2
65656: PPUSH
65657: EMPTY
65658: PPUSH
65659: CALL_OW 1
65663: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65664: LD_VAR 0 2
65668: PPUSH
65669: LD_INT 103
65671: PPUSH
65672: CALL 60496 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65676: LD_ADDR_VAR 0 5
65680: PUSH
65681: LD_EXP 61
65685: PUSH
65686: LD_VAR 0 2
65690: ARRAY
65691: PUSH
65692: LD_EXP 90
65696: PUSH
65697: LD_VAR 0 2
65701: ARRAY
65702: UNION
65703: PPUSH
65704: LD_INT 2
65706: PUSH
65707: LD_INT 25
65709: PUSH
65710: LD_INT 2
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 25
65719: PUSH
65720: LD_INT 16
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: LIST
65731: PUSH
65732: EMPTY
65733: LIST
65734: PPUSH
65735: CALL_OW 72
65739: ST_TO_ADDR
// if mc_need_heal [ i ] then
65740: LD_EXP 64
65744: PUSH
65745: LD_VAR 0 2
65749: ARRAY
65750: IFFALSE 65794
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65752: LD_ADDR_VAR 0 5
65756: PUSH
65757: LD_VAR 0 5
65761: PUSH
65762: LD_EXP 64
65766: PUSH
65767: LD_VAR 0 2
65771: ARRAY
65772: PUSH
65773: LD_INT 1
65775: ARRAY
65776: PUSH
65777: LD_EXP 64
65781: PUSH
65782: LD_VAR 0 2
65786: ARRAY
65787: PUSH
65788: LD_INT 2
65790: ARRAY
65791: UNION
65792: DIFF
65793: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65794: LD_ADDR_VAR 0 6
65798: PUSH
65799: LD_EXP 80
65803: PUSH
65804: LD_VAR 0 2
65808: ARRAY
65809: PPUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 34
65815: PUSH
65816: LD_INT 13
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 34
65825: PUSH
65826: LD_INT 52
65828: PUSH
65829: EMPTY
65830: LIST
65831: LIST
65832: PUSH
65833: LD_INT 34
65835: PUSH
65836: LD_INT 88
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: LIST
65847: LIST
65848: PPUSH
65849: CALL_OW 72
65853: ST_TO_ADDR
// if cranes then
65854: LD_VAR 0 6
65858: IFFALSE 66026
// begin for j in cranes do
65860: LD_ADDR_VAR 0 3
65864: PUSH
65865: LD_VAR 0 6
65869: PUSH
65870: FOR_IN
65871: IFFALSE 66024
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65873: LD_VAR 0 3
65877: PPUSH
65878: CALL_OW 256
65882: PUSH
65883: LD_INT 1000
65885: EQUAL
65886: PUSH
65887: LD_VAR 0 3
65891: PPUSH
65892: CALL_OW 314
65896: NOT
65897: AND
65898: IFFALSE 65964
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
65900: LD_ADDR_VAR 0 8
65904: PUSH
65905: LD_EXP 62
65909: PUSH
65910: LD_VAR 0 2
65914: ARRAY
65915: PPUSH
65916: LD_VAR 0 3
65920: PPUSH
65921: CALL_OW 74
65925: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
65926: LD_VAR 0 8
65930: PPUSH
65931: LD_INT 16
65933: PPUSH
65934: CALL 22667 0 2
65938: PUSH
65939: LD_INT 4
65941: ARRAY
65942: PUSH
65943: LD_INT 10
65945: LESS
65946: IFFALSE 65962
// ComRepairBuilding ( j , to_repair ) ;
65948: LD_VAR 0 3
65952: PPUSH
65953: LD_VAR 0 8
65957: PPUSH
65958: CALL_OW 130
// end else
65962: GO 66022
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65964: LD_VAR 0 3
65968: PPUSH
65969: CALL_OW 256
65973: PUSH
65974: LD_INT 500
65976: LESS
65977: PUSH
65978: LD_VAR 0 3
65982: PPUSH
65983: LD_EXP 85
65987: PUSH
65988: LD_VAR 0 2
65992: ARRAY
65993: PPUSH
65994: CALL_OW 308
65998: NOT
65999: AND
66000: IFFALSE 66022
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66002: LD_VAR 0 3
66006: PPUSH
66007: LD_EXP 85
66011: PUSH
66012: LD_VAR 0 2
66016: ARRAY
66017: PPUSH
66018: CALL_OW 113
// end ;
66022: GO 65870
66024: POP
66025: POP
// end ; if tmp > 3 then
66026: LD_VAR 0 5
66030: PUSH
66031: LD_INT 3
66033: GREATER
66034: IFFALSE 66054
// tmp := ShrinkArray ( tmp , 4 ) ;
66036: LD_ADDR_VAR 0 5
66040: PUSH
66041: LD_VAR 0 5
66045: PPUSH
66046: LD_INT 4
66048: PPUSH
66049: CALL 52697 0 2
66053: ST_TO_ADDR
// if not tmp then
66054: LD_VAR 0 5
66058: NOT
66059: IFFALSE 66063
// continue ;
66061: GO 65443
// for j in tmp do
66063: LD_ADDR_VAR 0 3
66067: PUSH
66068: LD_VAR 0 5
66072: PUSH
66073: FOR_IN
66074: IFFALSE 66333
// begin if IsInUnit ( j ) then
66076: LD_VAR 0 3
66080: PPUSH
66081: CALL_OW 310
66085: IFFALSE 66096
// ComExitBuilding ( j ) ;
66087: LD_VAR 0 3
66091: PPUSH
66092: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66096: LD_VAR 0 3
66100: PUSH
66101: LD_EXP 63
66105: PUSH
66106: LD_VAR 0 2
66110: ARRAY
66111: IN
66112: NOT
66113: IFFALSE 66171
// begin SetTag ( j , 101 ) ;
66115: LD_VAR 0 3
66119: PPUSH
66120: LD_INT 101
66122: PPUSH
66123: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66127: LD_ADDR_EXP 63
66131: PUSH
66132: LD_EXP 63
66136: PPUSH
66137: LD_VAR 0 2
66141: PUSH
66142: LD_EXP 63
66146: PUSH
66147: LD_VAR 0 2
66151: ARRAY
66152: PUSH
66153: LD_INT 1
66155: PLUS
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PPUSH
66161: LD_VAR 0 3
66165: PPUSH
66166: CALL 20070 0 3
66170: ST_TO_ADDR
// end ; wait ( 1 ) ;
66171: LD_INT 1
66173: PPUSH
66174: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66178: LD_ADDR_VAR 0 7
66182: PUSH
66183: LD_EXP 62
66187: PUSH
66188: LD_VAR 0 2
66192: ARRAY
66193: ST_TO_ADDR
// if mc_scan [ i ] then
66194: LD_EXP 84
66198: PUSH
66199: LD_VAR 0 2
66203: ARRAY
66204: IFFALSE 66266
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66206: LD_ADDR_VAR 0 7
66210: PUSH
66211: LD_EXP 62
66215: PUSH
66216: LD_VAR 0 2
66220: ARRAY
66221: PPUSH
66222: LD_INT 3
66224: PUSH
66225: LD_INT 30
66227: PUSH
66228: LD_INT 32
66230: PUSH
66231: EMPTY
66232: LIST
66233: LIST
66234: PUSH
66235: LD_INT 30
66237: PUSH
66238: LD_INT 33
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: LD_INT 30
66247: PUSH
66248: LD_INT 31
66250: PUSH
66251: EMPTY
66252: LIST
66253: LIST
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: PPUSH
66261: CALL_OW 72
66265: ST_TO_ADDR
// if not to_repair_tmp then
66266: LD_VAR 0 7
66270: NOT
66271: IFFALSE 66275
// continue ;
66273: GO 66073
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66275: LD_ADDR_VAR 0 8
66279: PUSH
66280: LD_VAR 0 7
66284: PPUSH
66285: LD_VAR 0 3
66289: PPUSH
66290: CALL_OW 74
66294: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66295: LD_VAR 0 8
66299: PPUSH
66300: LD_INT 16
66302: PPUSH
66303: CALL 22667 0 2
66307: PUSH
66308: LD_INT 4
66310: ARRAY
66311: PUSH
66312: LD_INT 14
66314: LESS
66315: IFFALSE 66331
// ComRepairBuilding ( j , to_repair ) ;
66317: LD_VAR 0 3
66321: PPUSH
66322: LD_VAR 0 8
66326: PPUSH
66327: CALL_OW 130
// end ;
66331: GO 66073
66333: POP
66334: POP
// end ;
66335: GO 65443
66337: POP
66338: POP
// end ;
66339: LD_VAR 0 1
66343: RET
// export function MC_Heal ; var i , j , tmp ; begin
66344: LD_INT 0
66346: PPUSH
66347: PPUSH
66348: PPUSH
66349: PPUSH
// if not mc_bases then
66350: LD_EXP 61
66354: NOT
66355: IFFALSE 66359
// exit ;
66357: GO 66761
// for i = 1 to mc_bases do
66359: LD_ADDR_VAR 0 2
66363: PUSH
66364: DOUBLE
66365: LD_INT 1
66367: DEC
66368: ST_TO_ADDR
66369: LD_EXP 61
66373: PUSH
66374: FOR_TO
66375: IFFALSE 66759
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66377: LD_EXP 64
66381: PUSH
66382: LD_VAR 0 2
66386: ARRAY
66387: PUSH
66388: LD_INT 1
66390: ARRAY
66391: NOT
66392: PUSH
66393: LD_EXP 64
66397: PUSH
66398: LD_VAR 0 2
66402: ARRAY
66403: PUSH
66404: LD_INT 2
66406: ARRAY
66407: NOT
66408: AND
66409: IFFALSE 66447
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66411: LD_ADDR_EXP 65
66415: PUSH
66416: LD_EXP 65
66420: PPUSH
66421: LD_VAR 0 2
66425: PPUSH
66426: EMPTY
66427: PPUSH
66428: CALL_OW 1
66432: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66433: LD_VAR 0 2
66437: PPUSH
66438: LD_INT 102
66440: PPUSH
66441: CALL 60496 0 2
// continue ;
66445: GO 66374
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66447: LD_ADDR_VAR 0 4
66451: PUSH
66452: LD_EXP 61
66456: PUSH
66457: LD_VAR 0 2
66461: ARRAY
66462: PPUSH
66463: LD_INT 25
66465: PUSH
66466: LD_INT 4
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PPUSH
66473: CALL_OW 72
66477: ST_TO_ADDR
// if not tmp then
66478: LD_VAR 0 4
66482: NOT
66483: IFFALSE 66487
// continue ;
66485: GO 66374
// if mc_taming [ i ] then
66487: LD_EXP 92
66491: PUSH
66492: LD_VAR 0 2
66496: ARRAY
66497: IFFALSE 66521
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66499: LD_ADDR_EXP 92
66503: PUSH
66504: LD_EXP 92
66508: PPUSH
66509: LD_VAR 0 2
66513: PPUSH
66514: EMPTY
66515: PPUSH
66516: CALL_OW 1
66520: ST_TO_ADDR
// for j in tmp do
66521: LD_ADDR_VAR 0 3
66525: PUSH
66526: LD_VAR 0 4
66530: PUSH
66531: FOR_IN
66532: IFFALSE 66755
// begin if IsInUnit ( j ) then
66534: LD_VAR 0 3
66538: PPUSH
66539: CALL_OW 310
66543: IFFALSE 66554
// ComExitBuilding ( j ) ;
66545: LD_VAR 0 3
66549: PPUSH
66550: CALL_OW 122
// if not j in mc_healers [ i ] then
66554: LD_VAR 0 3
66558: PUSH
66559: LD_EXP 65
66563: PUSH
66564: LD_VAR 0 2
66568: ARRAY
66569: IN
66570: NOT
66571: IFFALSE 66617
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66573: LD_ADDR_EXP 65
66577: PUSH
66578: LD_EXP 65
66582: PPUSH
66583: LD_VAR 0 2
66587: PUSH
66588: LD_EXP 65
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_INT 1
66601: PLUS
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PPUSH
66607: LD_VAR 0 3
66611: PPUSH
66612: CALL 20070 0 3
66616: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66617: LD_VAR 0 3
66621: PPUSH
66622: CALL_OW 110
66626: PUSH
66627: LD_INT 102
66629: NONEQUAL
66630: IFFALSE 66644
// SetTag ( j , 102 ) ;
66632: LD_VAR 0 3
66636: PPUSH
66637: LD_INT 102
66639: PPUSH
66640: CALL_OW 109
// Wait ( 3 ) ;
66644: LD_INT 3
66646: PPUSH
66647: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66651: LD_EXP 64
66655: PUSH
66656: LD_VAR 0 2
66660: ARRAY
66661: PUSH
66662: LD_INT 1
66664: ARRAY
66665: IFFALSE 66697
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66667: LD_VAR 0 3
66671: PPUSH
66672: LD_EXP 64
66676: PUSH
66677: LD_VAR 0 2
66681: ARRAY
66682: PUSH
66683: LD_INT 1
66685: ARRAY
66686: PUSH
66687: LD_INT 1
66689: ARRAY
66690: PPUSH
66691: CALL_OW 128
66695: GO 66753
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66697: LD_VAR 0 3
66701: PPUSH
66702: CALL_OW 314
66706: NOT
66707: PUSH
66708: LD_EXP 64
66712: PUSH
66713: LD_VAR 0 2
66717: ARRAY
66718: PUSH
66719: LD_INT 2
66721: ARRAY
66722: AND
66723: IFFALSE 66753
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66725: LD_VAR 0 3
66729: PPUSH
66730: LD_EXP 64
66734: PUSH
66735: LD_VAR 0 2
66739: ARRAY
66740: PUSH
66741: LD_INT 2
66743: ARRAY
66744: PUSH
66745: LD_INT 1
66747: ARRAY
66748: PPUSH
66749: CALL_OW 128
// end ;
66753: GO 66531
66755: POP
66756: POP
// end ;
66757: GO 66374
66759: POP
66760: POP
// end ;
66761: LD_VAR 0 1
66765: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
66766: LD_INT 0
66768: PPUSH
66769: PPUSH
66770: PPUSH
66771: PPUSH
66772: PPUSH
66773: PPUSH
// if not mc_bases then
66774: LD_EXP 61
66778: NOT
66779: IFFALSE 66783
// exit ;
66781: GO 67946
// for i = 1 to mc_bases do
66783: LD_ADDR_VAR 0 2
66787: PUSH
66788: DOUBLE
66789: LD_INT 1
66791: DEC
66792: ST_TO_ADDR
66793: LD_EXP 61
66797: PUSH
66798: FOR_TO
66799: IFFALSE 67944
// begin if mc_scan [ i ] then
66801: LD_EXP 84
66805: PUSH
66806: LD_VAR 0 2
66810: ARRAY
66811: IFFALSE 66815
// continue ;
66813: GO 66798
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66815: LD_EXP 66
66819: PUSH
66820: LD_VAR 0 2
66824: ARRAY
66825: NOT
66826: PUSH
66827: LD_EXP 68
66831: PUSH
66832: LD_VAR 0 2
66836: ARRAY
66837: NOT
66838: AND
66839: PUSH
66840: LD_EXP 67
66844: PUSH
66845: LD_VAR 0 2
66849: ARRAY
66850: AND
66851: IFFALSE 66889
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66853: LD_ADDR_EXP 67
66857: PUSH
66858: LD_EXP 67
66862: PPUSH
66863: LD_VAR 0 2
66867: PPUSH
66868: EMPTY
66869: PPUSH
66870: CALL_OW 1
66874: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66875: LD_VAR 0 2
66879: PPUSH
66880: LD_INT 103
66882: PPUSH
66883: CALL 60496 0 2
// continue ;
66887: GO 66798
// end ; if mc_construct_list [ i ] then
66889: LD_EXP 68
66893: PUSH
66894: LD_VAR 0 2
66898: ARRAY
66899: IFFALSE 67119
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66901: LD_ADDR_VAR 0 5
66905: PUSH
66906: LD_EXP 61
66910: PUSH
66911: LD_VAR 0 2
66915: ARRAY
66916: PPUSH
66917: LD_INT 25
66919: PUSH
66920: LD_INT 2
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PPUSH
66927: CALL_OW 72
66931: PUSH
66932: LD_EXP 63
66936: PUSH
66937: LD_VAR 0 2
66941: ARRAY
66942: DIFF
66943: ST_TO_ADDR
// if not tmp then
66944: LD_VAR 0 5
66948: NOT
66949: IFFALSE 66953
// continue ;
66951: GO 66798
// for j in tmp do
66953: LD_ADDR_VAR 0 3
66957: PUSH
66958: LD_VAR 0 5
66962: PUSH
66963: FOR_IN
66964: IFFALSE 67115
// begin if not mc_builders [ i ] then
66966: LD_EXP 67
66970: PUSH
66971: LD_VAR 0 2
66975: ARRAY
66976: NOT
66977: IFFALSE 67035
// begin SetTag ( j , 103 ) ;
66979: LD_VAR 0 3
66983: PPUSH
66984: LD_INT 103
66986: PPUSH
66987: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66991: LD_ADDR_EXP 67
66995: PUSH
66996: LD_EXP 67
67000: PPUSH
67001: LD_VAR 0 2
67005: PUSH
67006: LD_EXP 67
67010: PUSH
67011: LD_VAR 0 2
67015: ARRAY
67016: PUSH
67017: LD_INT 1
67019: PLUS
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PPUSH
67025: LD_VAR 0 3
67029: PPUSH
67030: CALL 20070 0 3
67034: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67035: LD_VAR 0 3
67039: PPUSH
67040: CALL_OW 310
67044: IFFALSE 67055
// ComExitBuilding ( j ) ;
67046: LD_VAR 0 3
67050: PPUSH
67051: CALL_OW 122
// wait ( 3 ) ;
67055: LD_INT 3
67057: PPUSH
67058: CALL_OW 67
// if not mc_construct_list [ i ] then
67062: LD_EXP 68
67066: PUSH
67067: LD_VAR 0 2
67071: ARRAY
67072: NOT
67073: IFFALSE 67077
// break ;
67075: GO 67115
// if not HasTask ( j ) then
67077: LD_VAR 0 3
67081: PPUSH
67082: CALL_OW 314
67086: NOT
67087: IFFALSE 67113
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67089: LD_VAR 0 3
67093: PPUSH
67094: LD_EXP 68
67098: PUSH
67099: LD_VAR 0 2
67103: ARRAY
67104: PUSH
67105: LD_INT 1
67107: ARRAY
67108: PPUSH
67109: CALL 22931 0 2
// end ;
67113: GO 66963
67115: POP
67116: POP
// end else
67117: GO 67942
// if mc_build_list [ i ] then
67119: LD_EXP 66
67123: PUSH
67124: LD_VAR 0 2
67128: ARRAY
67129: IFFALSE 67942
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67131: LD_EXP 66
67135: PUSH
67136: LD_VAR 0 2
67140: ARRAY
67141: PUSH
67142: LD_INT 1
67144: ARRAY
67145: PUSH
67146: LD_INT 1
67148: ARRAY
67149: PPUSH
67150: CALL 22755 0 1
67154: PUSH
67155: LD_EXP 61
67159: PUSH
67160: LD_VAR 0 2
67164: ARRAY
67165: PPUSH
67166: LD_INT 2
67168: PUSH
67169: LD_INT 30
67171: PUSH
67172: LD_INT 2
67174: PUSH
67175: EMPTY
67176: LIST
67177: LIST
67178: PUSH
67179: LD_INT 30
67181: PUSH
67182: LD_INT 3
67184: PUSH
67185: EMPTY
67186: LIST
67187: LIST
67188: PUSH
67189: EMPTY
67190: LIST
67191: LIST
67192: LIST
67193: PPUSH
67194: CALL_OW 72
67198: NOT
67199: AND
67200: IFFALSE 67305
// begin for j = 1 to mc_build_list [ i ] do
67202: LD_ADDR_VAR 0 3
67206: PUSH
67207: DOUBLE
67208: LD_INT 1
67210: DEC
67211: ST_TO_ADDR
67212: LD_EXP 66
67216: PUSH
67217: LD_VAR 0 2
67221: ARRAY
67222: PUSH
67223: FOR_TO
67224: IFFALSE 67303
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67226: LD_EXP 66
67230: PUSH
67231: LD_VAR 0 2
67235: ARRAY
67236: PUSH
67237: LD_VAR 0 3
67241: ARRAY
67242: PUSH
67243: LD_INT 1
67245: ARRAY
67246: PUSH
67247: LD_INT 2
67249: EQUAL
67250: IFFALSE 67301
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67252: LD_ADDR_EXP 66
67256: PUSH
67257: LD_EXP 66
67261: PPUSH
67262: LD_VAR 0 2
67266: PPUSH
67267: LD_EXP 66
67271: PUSH
67272: LD_VAR 0 2
67276: ARRAY
67277: PPUSH
67278: LD_VAR 0 3
67282: PPUSH
67283: LD_INT 1
67285: PPUSH
67286: LD_INT 0
67288: PPUSH
67289: CALL 19488 0 4
67293: PPUSH
67294: CALL_OW 1
67298: ST_TO_ADDR
// break ;
67299: GO 67303
// end ;
67301: GO 67223
67303: POP
67304: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67305: LD_ADDR_VAR 0 6
67309: PUSH
67310: LD_EXP 61
67314: PUSH
67315: LD_VAR 0 2
67319: ARRAY
67320: PPUSH
67321: LD_INT 2
67323: PUSH
67324: LD_INT 30
67326: PUSH
67327: LD_INT 0
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 30
67336: PUSH
67337: LD_INT 1
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: LIST
67348: PPUSH
67349: CALL_OW 72
67353: ST_TO_ADDR
// for k := 1 to depot do
67354: LD_ADDR_VAR 0 4
67358: PUSH
67359: DOUBLE
67360: LD_INT 1
67362: DEC
67363: ST_TO_ADDR
67364: LD_VAR 0 6
67368: PUSH
67369: FOR_TO
67370: IFFALSE 67940
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67372: LD_EXP 66
67376: PUSH
67377: LD_VAR 0 2
67381: ARRAY
67382: PUSH
67383: LD_INT 1
67385: ARRAY
67386: PUSH
67387: LD_INT 1
67389: ARRAY
67390: PUSH
67391: LD_INT 0
67393: EQUAL
67394: PUSH
67395: LD_VAR 0 6
67399: PUSH
67400: LD_VAR 0 4
67404: ARRAY
67405: PPUSH
67406: LD_EXP 66
67410: PUSH
67411: LD_VAR 0 2
67415: ARRAY
67416: PUSH
67417: LD_INT 1
67419: ARRAY
67420: PUSH
67421: LD_INT 1
67423: ARRAY
67424: PPUSH
67425: LD_EXP 66
67429: PUSH
67430: LD_VAR 0 2
67434: ARRAY
67435: PUSH
67436: LD_INT 1
67438: ARRAY
67439: PUSH
67440: LD_INT 2
67442: ARRAY
67443: PPUSH
67444: LD_EXP 66
67448: PUSH
67449: LD_VAR 0 2
67453: ARRAY
67454: PUSH
67455: LD_INT 1
67457: ARRAY
67458: PUSH
67459: LD_INT 3
67461: ARRAY
67462: PPUSH
67463: LD_EXP 66
67467: PUSH
67468: LD_VAR 0 2
67472: ARRAY
67473: PUSH
67474: LD_INT 1
67476: ARRAY
67477: PUSH
67478: LD_INT 4
67480: ARRAY
67481: PPUSH
67482: CALL 28167 0 5
67486: OR
67487: IFFALSE 67768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67489: LD_ADDR_VAR 0 5
67493: PUSH
67494: LD_EXP 61
67498: PUSH
67499: LD_VAR 0 2
67503: ARRAY
67504: PPUSH
67505: LD_INT 25
67507: PUSH
67508: LD_INT 2
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PPUSH
67515: CALL_OW 72
67519: PUSH
67520: LD_EXP 63
67524: PUSH
67525: LD_VAR 0 2
67529: ARRAY
67530: DIFF
67531: ST_TO_ADDR
// if not tmp then
67532: LD_VAR 0 5
67536: NOT
67537: IFFALSE 67541
// continue ;
67539: GO 67369
// for j in tmp do
67541: LD_ADDR_VAR 0 3
67545: PUSH
67546: LD_VAR 0 5
67550: PUSH
67551: FOR_IN
67552: IFFALSE 67764
// begin if not mc_builders [ i ] then
67554: LD_EXP 67
67558: PUSH
67559: LD_VAR 0 2
67563: ARRAY
67564: NOT
67565: IFFALSE 67623
// begin SetTag ( j , 103 ) ;
67567: LD_VAR 0 3
67571: PPUSH
67572: LD_INT 103
67574: PPUSH
67575: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67579: LD_ADDR_EXP 67
67583: PUSH
67584: LD_EXP 67
67588: PPUSH
67589: LD_VAR 0 2
67593: PUSH
67594: LD_EXP 67
67598: PUSH
67599: LD_VAR 0 2
67603: ARRAY
67604: PUSH
67605: LD_INT 1
67607: PLUS
67608: PUSH
67609: EMPTY
67610: LIST
67611: LIST
67612: PPUSH
67613: LD_VAR 0 3
67617: PPUSH
67618: CALL 20070 0 3
67622: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67623: LD_VAR 0 3
67627: PPUSH
67628: CALL_OW 310
67632: IFFALSE 67643
// ComExitBuilding ( j ) ;
67634: LD_VAR 0 3
67638: PPUSH
67639: CALL_OW 122
// wait ( 3 ) ;
67643: LD_INT 3
67645: PPUSH
67646: CALL_OW 67
// if not mc_build_list [ i ] then
67650: LD_EXP 66
67654: PUSH
67655: LD_VAR 0 2
67659: ARRAY
67660: NOT
67661: IFFALSE 67665
// break ;
67663: GO 67764
// if not HasTask ( j ) then
67665: LD_VAR 0 3
67669: PPUSH
67670: CALL_OW 314
67674: NOT
67675: IFFALSE 67762
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67677: LD_VAR 0 3
67681: PPUSH
67682: LD_EXP 66
67686: PUSH
67687: LD_VAR 0 2
67691: ARRAY
67692: PUSH
67693: LD_INT 1
67695: ARRAY
67696: PUSH
67697: LD_INT 1
67699: ARRAY
67700: PPUSH
67701: LD_EXP 66
67705: PUSH
67706: LD_VAR 0 2
67710: ARRAY
67711: PUSH
67712: LD_INT 1
67714: ARRAY
67715: PUSH
67716: LD_INT 2
67718: ARRAY
67719: PPUSH
67720: LD_EXP 66
67724: PUSH
67725: LD_VAR 0 2
67729: ARRAY
67730: PUSH
67731: LD_INT 1
67733: ARRAY
67734: PUSH
67735: LD_INT 3
67737: ARRAY
67738: PPUSH
67739: LD_EXP 66
67743: PUSH
67744: LD_VAR 0 2
67748: ARRAY
67749: PUSH
67750: LD_INT 1
67752: ARRAY
67753: PUSH
67754: LD_INT 4
67756: ARRAY
67757: PPUSH
67758: CALL_OW 145
// end ;
67762: GO 67551
67764: POP
67765: POP
// end else
67766: GO 67938
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67768: LD_EXP 61
67772: PUSH
67773: LD_VAR 0 2
67777: ARRAY
67778: PPUSH
67779: LD_EXP 66
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: PUSH
67790: LD_INT 1
67792: ARRAY
67793: PUSH
67794: LD_INT 1
67796: ARRAY
67797: PPUSH
67798: LD_EXP 66
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: PUSH
67813: LD_INT 2
67815: ARRAY
67816: PPUSH
67817: LD_EXP 66
67821: PUSH
67822: LD_VAR 0 2
67826: ARRAY
67827: PUSH
67828: LD_INT 1
67830: ARRAY
67831: PUSH
67832: LD_INT 3
67834: ARRAY
67835: PPUSH
67836: LD_EXP 66
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PUSH
67847: LD_INT 1
67849: ARRAY
67850: PUSH
67851: LD_INT 4
67853: ARRAY
67854: PPUSH
67855: LD_EXP 61
67859: PUSH
67860: LD_VAR 0 2
67864: ARRAY
67865: PPUSH
67866: LD_INT 21
67868: PUSH
67869: LD_INT 3
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: CALL_OW 72
67880: PPUSH
67881: EMPTY
67882: PPUSH
67883: CALL 26921 0 7
67887: NOT
67888: IFFALSE 67938
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67890: LD_ADDR_EXP 66
67894: PUSH
67895: LD_EXP 66
67899: PPUSH
67900: LD_VAR 0 2
67904: PPUSH
67905: LD_EXP 66
67909: PUSH
67910: LD_VAR 0 2
67914: ARRAY
67915: PPUSH
67916: LD_INT 1
67918: PPUSH
67919: LD_INT 1
67921: NEG
67922: PPUSH
67923: LD_INT 0
67925: PPUSH
67926: CALL 19488 0 4
67930: PPUSH
67931: CALL_OW 1
67935: ST_TO_ADDR
// continue ;
67936: GO 67369
// end ; end ;
67938: GO 67369
67940: POP
67941: POP
// end ; end ;
67942: GO 66798
67944: POP
67945: POP
// end ;
67946: LD_VAR 0 1
67950: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67951: LD_INT 0
67953: PPUSH
67954: PPUSH
67955: PPUSH
67956: PPUSH
67957: PPUSH
67958: PPUSH
// if not mc_bases then
67959: LD_EXP 61
67963: NOT
67964: IFFALSE 67968
// exit ;
67966: GO 68395
// for i = 1 to mc_bases do
67968: LD_ADDR_VAR 0 2
67972: PUSH
67973: DOUBLE
67974: LD_INT 1
67976: DEC
67977: ST_TO_ADDR
67978: LD_EXP 61
67982: PUSH
67983: FOR_TO
67984: IFFALSE 68393
// begin tmp := mc_build_upgrade [ i ] ;
67986: LD_ADDR_VAR 0 4
67990: PUSH
67991: LD_EXP 93
67995: PUSH
67996: LD_VAR 0 2
68000: ARRAY
68001: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68002: LD_ADDR_VAR 0 6
68006: PUSH
68007: LD_EXP 94
68011: PUSH
68012: LD_VAR 0 2
68016: ARRAY
68017: PPUSH
68018: LD_INT 2
68020: PUSH
68021: LD_INT 30
68023: PUSH
68024: LD_INT 6
68026: PUSH
68027: EMPTY
68028: LIST
68029: LIST
68030: PUSH
68031: LD_INT 30
68033: PUSH
68034: LD_INT 7
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: LIST
68045: PPUSH
68046: CALL_OW 72
68050: ST_TO_ADDR
// if not tmp and not lab then
68051: LD_VAR 0 4
68055: NOT
68056: PUSH
68057: LD_VAR 0 6
68061: NOT
68062: AND
68063: IFFALSE 68067
// continue ;
68065: GO 67983
// if tmp then
68067: LD_VAR 0 4
68071: IFFALSE 68191
// for j in tmp do
68073: LD_ADDR_VAR 0 3
68077: PUSH
68078: LD_VAR 0 4
68082: PUSH
68083: FOR_IN
68084: IFFALSE 68189
// begin if UpgradeCost ( j ) then
68086: LD_VAR 0 3
68090: PPUSH
68091: CALL 26581 0 1
68095: IFFALSE 68187
// begin ComUpgrade ( j ) ;
68097: LD_VAR 0 3
68101: PPUSH
68102: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68106: LD_ADDR_EXP 93
68110: PUSH
68111: LD_EXP 93
68115: PPUSH
68116: LD_VAR 0 2
68120: PPUSH
68121: LD_EXP 93
68125: PUSH
68126: LD_VAR 0 2
68130: ARRAY
68131: PUSH
68132: LD_VAR 0 3
68136: DIFF
68137: PPUSH
68138: CALL_OW 1
68142: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68143: LD_ADDR_EXP 68
68147: PUSH
68148: LD_EXP 68
68152: PPUSH
68153: LD_VAR 0 2
68157: PUSH
68158: LD_EXP 68
68162: PUSH
68163: LD_VAR 0 2
68167: ARRAY
68168: PUSH
68169: LD_INT 1
68171: PLUS
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: PPUSH
68177: LD_VAR 0 3
68181: PPUSH
68182: CALL 20070 0 3
68186: ST_TO_ADDR
// end ; end ;
68187: GO 68083
68189: POP
68190: POP
// if not lab or not mc_lab_upgrade [ i ] then
68191: LD_VAR 0 6
68195: NOT
68196: PUSH
68197: LD_EXP 95
68201: PUSH
68202: LD_VAR 0 2
68206: ARRAY
68207: NOT
68208: OR
68209: IFFALSE 68213
// continue ;
68211: GO 67983
// for j in lab do
68213: LD_ADDR_VAR 0 3
68217: PUSH
68218: LD_VAR 0 6
68222: PUSH
68223: FOR_IN
68224: IFFALSE 68389
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68226: LD_VAR 0 3
68230: PPUSH
68231: CALL_OW 266
68235: PUSH
68236: LD_INT 6
68238: PUSH
68239: LD_INT 7
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: IN
68246: PUSH
68247: LD_VAR 0 3
68251: PPUSH
68252: CALL_OW 461
68256: PUSH
68257: LD_INT 1
68259: NONEQUAL
68260: AND
68261: IFFALSE 68387
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68263: LD_VAR 0 3
68267: PPUSH
68268: LD_EXP 95
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: PUSH
68279: LD_INT 1
68281: ARRAY
68282: PPUSH
68283: CALL 26786 0 2
68287: IFFALSE 68387
// begin ComCancel ( j ) ;
68289: LD_VAR 0 3
68293: PPUSH
68294: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68298: LD_VAR 0 3
68302: PPUSH
68303: LD_EXP 95
68307: PUSH
68308: LD_VAR 0 2
68312: ARRAY
68313: PUSH
68314: LD_INT 1
68316: ARRAY
68317: PPUSH
68318: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68322: LD_VAR 0 3
68326: PUSH
68327: LD_EXP 68
68331: PUSH
68332: LD_VAR 0 2
68336: ARRAY
68337: IN
68338: NOT
68339: IFFALSE 68385
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68341: LD_ADDR_EXP 68
68345: PUSH
68346: LD_EXP 68
68350: PPUSH
68351: LD_VAR 0 2
68355: PUSH
68356: LD_EXP 68
68360: PUSH
68361: LD_VAR 0 2
68365: ARRAY
68366: PUSH
68367: LD_INT 1
68369: PLUS
68370: PUSH
68371: EMPTY
68372: LIST
68373: LIST
68374: PPUSH
68375: LD_VAR 0 3
68379: PPUSH
68380: CALL 20070 0 3
68384: ST_TO_ADDR
// break ;
68385: GO 68389
// end ; end ; end ;
68387: GO 68223
68389: POP
68390: POP
// end ;
68391: GO 67983
68393: POP
68394: POP
// end ;
68395: LD_VAR 0 1
68399: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68400: LD_INT 0
68402: PPUSH
68403: PPUSH
68404: PPUSH
68405: PPUSH
68406: PPUSH
68407: PPUSH
68408: PPUSH
68409: PPUSH
68410: PPUSH
// if not mc_bases then
68411: LD_EXP 61
68415: NOT
68416: IFFALSE 68420
// exit ;
68418: GO 68825
// for i = 1 to mc_bases do
68420: LD_ADDR_VAR 0 2
68424: PUSH
68425: DOUBLE
68426: LD_INT 1
68428: DEC
68429: ST_TO_ADDR
68430: LD_EXP 61
68434: PUSH
68435: FOR_TO
68436: IFFALSE 68823
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68438: LD_EXP 69
68442: PUSH
68443: LD_VAR 0 2
68447: ARRAY
68448: NOT
68449: PUSH
68450: LD_EXP 61
68454: PUSH
68455: LD_VAR 0 2
68459: ARRAY
68460: PPUSH
68461: LD_INT 30
68463: PUSH
68464: LD_INT 3
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PPUSH
68471: CALL_OW 72
68475: NOT
68476: OR
68477: IFFALSE 68481
// continue ;
68479: GO 68435
// busy := false ;
68481: LD_ADDR_VAR 0 8
68485: PUSH
68486: LD_INT 0
68488: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68489: LD_ADDR_VAR 0 4
68493: PUSH
68494: LD_EXP 61
68498: PUSH
68499: LD_VAR 0 2
68503: ARRAY
68504: PPUSH
68505: LD_INT 30
68507: PUSH
68508: LD_INT 3
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PPUSH
68515: CALL_OW 72
68519: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68520: LD_ADDR_VAR 0 6
68524: PUSH
68525: LD_EXP 69
68529: PUSH
68530: LD_VAR 0 2
68534: ARRAY
68535: PPUSH
68536: LD_INT 2
68538: PUSH
68539: LD_INT 30
68541: PUSH
68542: LD_INT 32
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 30
68551: PUSH
68552: LD_INT 33
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: EMPTY
68560: LIST
68561: LIST
68562: LIST
68563: PPUSH
68564: CALL_OW 72
68568: ST_TO_ADDR
// if not t then
68569: LD_VAR 0 6
68573: NOT
68574: IFFALSE 68578
// continue ;
68576: GO 68435
// for j in tmp do
68578: LD_ADDR_VAR 0 3
68582: PUSH
68583: LD_VAR 0 4
68587: PUSH
68588: FOR_IN
68589: IFFALSE 68619
// if not BuildingStatus ( j ) = bs_idle then
68591: LD_VAR 0 3
68595: PPUSH
68596: CALL_OW 461
68600: PUSH
68601: LD_INT 2
68603: EQUAL
68604: NOT
68605: IFFALSE 68617
// begin busy := true ;
68607: LD_ADDR_VAR 0 8
68611: PUSH
68612: LD_INT 1
68614: ST_TO_ADDR
// break ;
68615: GO 68619
// end ;
68617: GO 68588
68619: POP
68620: POP
// if busy then
68621: LD_VAR 0 8
68625: IFFALSE 68629
// continue ;
68627: GO 68435
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68629: LD_ADDR_VAR 0 7
68633: PUSH
68634: LD_VAR 0 6
68638: PPUSH
68639: LD_INT 35
68641: PUSH
68642: LD_INT 0
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PPUSH
68649: CALL_OW 72
68653: ST_TO_ADDR
// if tw then
68654: LD_VAR 0 7
68658: IFFALSE 68735
// begin tw := tw [ 1 ] ;
68660: LD_ADDR_VAR 0 7
68664: PUSH
68665: LD_VAR 0 7
68669: PUSH
68670: LD_INT 1
68672: ARRAY
68673: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68674: LD_ADDR_VAR 0 9
68678: PUSH
68679: LD_VAR 0 7
68683: PPUSH
68684: LD_EXP 86
68688: PUSH
68689: LD_VAR 0 2
68693: ARRAY
68694: PPUSH
68695: CALL 25078 0 2
68699: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68700: LD_EXP 100
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: IFFALSE 68733
// if not weapon in mc_allowed_tower_weapons [ i ] then
68712: LD_VAR 0 9
68716: PUSH
68717: LD_EXP 100
68721: PUSH
68722: LD_VAR 0 2
68726: ARRAY
68727: IN
68728: NOT
68729: IFFALSE 68733
// continue ;
68731: GO 68435
// end else
68733: GO 68798
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68735: LD_ADDR_VAR 0 5
68739: PUSH
68740: LD_EXP 69
68744: PUSH
68745: LD_VAR 0 2
68749: ARRAY
68750: PPUSH
68751: LD_VAR 0 4
68755: PPUSH
68756: CALL 51930 0 2
68760: ST_TO_ADDR
// if not tmp2 then
68761: LD_VAR 0 5
68765: NOT
68766: IFFALSE 68770
// continue ;
68768: GO 68435
// tw := tmp2 [ 1 ] ;
68770: LD_ADDR_VAR 0 7
68774: PUSH
68775: LD_VAR 0 5
68779: PUSH
68780: LD_INT 1
68782: ARRAY
68783: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68784: LD_ADDR_VAR 0 9
68788: PUSH
68789: LD_VAR 0 5
68793: PUSH
68794: LD_INT 2
68796: ARRAY
68797: ST_TO_ADDR
// end ; if not weapon then
68798: LD_VAR 0 9
68802: NOT
68803: IFFALSE 68807
// continue ;
68805: GO 68435
// ComPlaceWeapon ( tw , weapon ) ;
68807: LD_VAR 0 7
68811: PPUSH
68812: LD_VAR 0 9
68816: PPUSH
68817: CALL_OW 148
// end ;
68821: GO 68435
68823: POP
68824: POP
// end ;
68825: LD_VAR 0 1
68829: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68830: LD_INT 0
68832: PPUSH
68833: PPUSH
68834: PPUSH
68835: PPUSH
68836: PPUSH
68837: PPUSH
68838: PPUSH
// if not mc_bases then
68839: LD_EXP 61
68843: NOT
68844: IFFALSE 68848
// exit ;
68846: GO 69616
// for i = 1 to mc_bases do
68848: LD_ADDR_VAR 0 2
68852: PUSH
68853: DOUBLE
68854: LD_INT 1
68856: DEC
68857: ST_TO_ADDR
68858: LD_EXP 61
68862: PUSH
68863: FOR_TO
68864: IFFALSE 69614
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68866: LD_EXP 74
68870: PUSH
68871: LD_VAR 0 2
68875: ARRAY
68876: NOT
68877: PUSH
68878: LD_EXP 74
68882: PUSH
68883: LD_VAR 0 2
68887: ARRAY
68888: PUSH
68889: LD_EXP 75
68893: PUSH
68894: LD_VAR 0 2
68898: ARRAY
68899: EQUAL
68900: OR
68901: PUSH
68902: LD_EXP 84
68906: PUSH
68907: LD_VAR 0 2
68911: ARRAY
68912: OR
68913: IFFALSE 68917
// continue ;
68915: GO 68863
// if mc_miners [ i ] then
68917: LD_EXP 75
68921: PUSH
68922: LD_VAR 0 2
68926: ARRAY
68927: IFFALSE 69301
// begin for j = mc_miners [ i ] downto 1 do
68929: LD_ADDR_VAR 0 3
68933: PUSH
68934: DOUBLE
68935: LD_EXP 75
68939: PUSH
68940: LD_VAR 0 2
68944: ARRAY
68945: INC
68946: ST_TO_ADDR
68947: LD_INT 1
68949: PUSH
68950: FOR_DOWNTO
68951: IFFALSE 69299
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68953: LD_EXP 75
68957: PUSH
68958: LD_VAR 0 2
68962: ARRAY
68963: PUSH
68964: LD_VAR 0 3
68968: ARRAY
68969: PPUSH
68970: CALL_OW 301
68974: PUSH
68975: LD_EXP 75
68979: PUSH
68980: LD_VAR 0 2
68984: ARRAY
68985: PUSH
68986: LD_VAR 0 3
68990: ARRAY
68991: PPUSH
68992: CALL_OW 257
68996: PUSH
68997: LD_INT 1
68999: NONEQUAL
69000: OR
69001: IFFALSE 69064
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69003: LD_ADDR_VAR 0 5
69007: PUSH
69008: LD_EXP 75
69012: PUSH
69013: LD_VAR 0 2
69017: ARRAY
69018: PUSH
69019: LD_EXP 75
69023: PUSH
69024: LD_VAR 0 2
69028: ARRAY
69029: PUSH
69030: LD_VAR 0 3
69034: ARRAY
69035: DIFF
69036: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69037: LD_ADDR_EXP 75
69041: PUSH
69042: LD_EXP 75
69046: PPUSH
69047: LD_VAR 0 2
69051: PPUSH
69052: LD_VAR 0 5
69056: PPUSH
69057: CALL_OW 1
69061: ST_TO_ADDR
// continue ;
69062: GO 68950
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69064: LD_EXP 75
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: PUSH
69075: LD_VAR 0 3
69079: ARRAY
69080: PPUSH
69081: CALL_OW 257
69085: PUSH
69086: LD_INT 1
69088: EQUAL
69089: PUSH
69090: LD_EXP 75
69094: PUSH
69095: LD_VAR 0 2
69099: ARRAY
69100: PUSH
69101: LD_VAR 0 3
69105: ARRAY
69106: PPUSH
69107: CALL_OW 459
69111: NOT
69112: AND
69113: PUSH
69114: LD_EXP 75
69118: PUSH
69119: LD_VAR 0 2
69123: ARRAY
69124: PUSH
69125: LD_VAR 0 3
69129: ARRAY
69130: PPUSH
69131: CALL_OW 314
69135: NOT
69136: AND
69137: IFFALSE 69297
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69139: LD_EXP 75
69143: PUSH
69144: LD_VAR 0 2
69148: ARRAY
69149: PUSH
69150: LD_VAR 0 3
69154: ARRAY
69155: PPUSH
69156: CALL_OW 310
69160: IFFALSE 69183
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69162: LD_EXP 75
69166: PUSH
69167: LD_VAR 0 2
69171: ARRAY
69172: PUSH
69173: LD_VAR 0 3
69177: ARRAY
69178: PPUSH
69179: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69183: LD_EXP 75
69187: PUSH
69188: LD_VAR 0 2
69192: ARRAY
69193: PUSH
69194: LD_VAR 0 3
69198: ARRAY
69199: PPUSH
69200: CALL_OW 314
69204: NOT
69205: IFFALSE 69297
// begin r := rand ( 1 , mc_mines [ i ] ) ;
69207: LD_ADDR_VAR 0 7
69211: PUSH
69212: LD_INT 1
69214: PPUSH
69215: LD_EXP 74
69219: PUSH
69220: LD_VAR 0 2
69224: ARRAY
69225: PPUSH
69226: CALL_OW 12
69230: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69231: LD_EXP 75
69235: PUSH
69236: LD_VAR 0 2
69240: ARRAY
69241: PUSH
69242: LD_VAR 0 3
69246: ARRAY
69247: PPUSH
69248: LD_EXP 74
69252: PUSH
69253: LD_VAR 0 2
69257: ARRAY
69258: PUSH
69259: LD_VAR 0 7
69263: ARRAY
69264: PUSH
69265: LD_INT 1
69267: ARRAY
69268: PPUSH
69269: LD_EXP 74
69273: PUSH
69274: LD_VAR 0 2
69278: ARRAY
69279: PUSH
69280: LD_VAR 0 7
69284: ARRAY
69285: PUSH
69286: LD_INT 2
69288: ARRAY
69289: PPUSH
69290: LD_INT 0
69292: PPUSH
69293: CALL_OW 193
// end ; end ; end ;
69297: GO 68950
69299: POP
69300: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69301: LD_ADDR_VAR 0 5
69305: PUSH
69306: LD_EXP 61
69310: PUSH
69311: LD_VAR 0 2
69315: ARRAY
69316: PPUSH
69317: LD_INT 2
69319: PUSH
69320: LD_INT 30
69322: PUSH
69323: LD_INT 4
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: PUSH
69330: LD_INT 30
69332: PUSH
69333: LD_INT 5
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 30
69342: PUSH
69343: LD_INT 32
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: EMPTY
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: PPUSH
69356: CALL_OW 72
69360: ST_TO_ADDR
// if not tmp then
69361: LD_VAR 0 5
69365: NOT
69366: IFFALSE 69370
// continue ;
69368: GO 68863
// list := [ ] ;
69370: LD_ADDR_VAR 0 6
69374: PUSH
69375: EMPTY
69376: ST_TO_ADDR
// for j in tmp do
69377: LD_ADDR_VAR 0 3
69381: PUSH
69382: LD_VAR 0 5
69386: PUSH
69387: FOR_IN
69388: IFFALSE 69457
// begin for k in UnitsInside ( j ) do
69390: LD_ADDR_VAR 0 4
69394: PUSH
69395: LD_VAR 0 3
69399: PPUSH
69400: CALL_OW 313
69404: PUSH
69405: FOR_IN
69406: IFFALSE 69453
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69408: LD_VAR 0 4
69412: PPUSH
69413: CALL_OW 257
69417: PUSH
69418: LD_INT 1
69420: EQUAL
69421: PUSH
69422: LD_VAR 0 4
69426: PPUSH
69427: CALL_OW 459
69431: NOT
69432: AND
69433: IFFALSE 69451
// list := list ^ k ;
69435: LD_ADDR_VAR 0 6
69439: PUSH
69440: LD_VAR 0 6
69444: PUSH
69445: LD_VAR 0 4
69449: ADD
69450: ST_TO_ADDR
69451: GO 69405
69453: POP
69454: POP
// end ;
69455: GO 69387
69457: POP
69458: POP
// list := list diff mc_miners [ i ] ;
69459: LD_ADDR_VAR 0 6
69463: PUSH
69464: LD_VAR 0 6
69468: PUSH
69469: LD_EXP 75
69473: PUSH
69474: LD_VAR 0 2
69478: ARRAY
69479: DIFF
69480: ST_TO_ADDR
// if not list then
69481: LD_VAR 0 6
69485: NOT
69486: IFFALSE 69490
// continue ;
69488: GO 68863
// k := mc_mines [ i ] - mc_miners [ i ] ;
69490: LD_ADDR_VAR 0 4
69494: PUSH
69495: LD_EXP 74
69499: PUSH
69500: LD_VAR 0 2
69504: ARRAY
69505: PUSH
69506: LD_EXP 75
69510: PUSH
69511: LD_VAR 0 2
69515: ARRAY
69516: MINUS
69517: ST_TO_ADDR
// if k > list then
69518: LD_VAR 0 4
69522: PUSH
69523: LD_VAR 0 6
69527: GREATER
69528: IFFALSE 69540
// k := list ;
69530: LD_ADDR_VAR 0 4
69534: PUSH
69535: LD_VAR 0 6
69539: ST_TO_ADDR
// for j = 1 to k do
69540: LD_ADDR_VAR 0 3
69544: PUSH
69545: DOUBLE
69546: LD_INT 1
69548: DEC
69549: ST_TO_ADDR
69550: LD_VAR 0 4
69554: PUSH
69555: FOR_TO
69556: IFFALSE 69610
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69558: LD_ADDR_EXP 75
69562: PUSH
69563: LD_EXP 75
69567: PPUSH
69568: LD_VAR 0 2
69572: PUSH
69573: LD_EXP 75
69577: PUSH
69578: LD_VAR 0 2
69582: ARRAY
69583: PUSH
69584: LD_INT 1
69586: PLUS
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PPUSH
69592: LD_VAR 0 6
69596: PUSH
69597: LD_VAR 0 3
69601: ARRAY
69602: PPUSH
69603: CALL 20070 0 3
69607: ST_TO_ADDR
69608: GO 69555
69610: POP
69611: POP
// end ;
69612: GO 68863
69614: POP
69615: POP
// end ;
69616: LD_VAR 0 1
69620: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69621: LD_INT 0
69623: PPUSH
69624: PPUSH
69625: PPUSH
69626: PPUSH
69627: PPUSH
69628: PPUSH
69629: PPUSH
69630: PPUSH
69631: PPUSH
69632: PPUSH
69633: PPUSH
// if not mc_bases then
69634: LD_EXP 61
69638: NOT
69639: IFFALSE 69643
// exit ;
69641: GO 71466
// for i = 1 to mc_bases do
69643: LD_ADDR_VAR 0 2
69647: PUSH
69648: DOUBLE
69649: LD_INT 1
69651: DEC
69652: ST_TO_ADDR
69653: LD_EXP 61
69657: PUSH
69658: FOR_TO
69659: IFFALSE 71464
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69661: LD_EXP 61
69665: PUSH
69666: LD_VAR 0 2
69670: ARRAY
69671: NOT
69672: PUSH
69673: LD_EXP 68
69677: PUSH
69678: LD_VAR 0 2
69682: ARRAY
69683: OR
69684: IFFALSE 69688
// continue ;
69686: GO 69658
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69688: LD_EXP 77
69692: PUSH
69693: LD_VAR 0 2
69697: ARRAY
69698: NOT
69699: PUSH
69700: LD_EXP 78
69704: PUSH
69705: LD_VAR 0 2
69709: ARRAY
69710: AND
69711: IFFALSE 69749
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69713: LD_ADDR_EXP 78
69717: PUSH
69718: LD_EXP 78
69722: PPUSH
69723: LD_VAR 0 2
69727: PPUSH
69728: EMPTY
69729: PPUSH
69730: CALL_OW 1
69734: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69735: LD_VAR 0 2
69739: PPUSH
69740: LD_INT 107
69742: PPUSH
69743: CALL 60496 0 2
// continue ;
69747: GO 69658
// end ; target := [ ] ;
69749: LD_ADDR_VAR 0 7
69753: PUSH
69754: EMPTY
69755: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69756: LD_ADDR_VAR 0 6
69760: PUSH
69761: LD_EXP 61
69765: PUSH
69766: LD_VAR 0 2
69770: ARRAY
69771: PUSH
69772: LD_INT 1
69774: ARRAY
69775: PPUSH
69776: CALL_OW 255
69780: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69781: LD_ADDR_VAR 0 9
69785: PUSH
69786: LD_EXP 61
69790: PUSH
69791: LD_VAR 0 2
69795: ARRAY
69796: PPUSH
69797: LD_INT 2
69799: PUSH
69800: LD_INT 30
69802: PUSH
69803: LD_INT 0
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 30
69812: PUSH
69813: LD_INT 1
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: LIST
69824: PPUSH
69825: CALL_OW 72
69829: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69830: LD_ADDR_VAR 0 3
69834: PUSH
69835: DOUBLE
69836: LD_EXP 77
69840: PUSH
69841: LD_VAR 0 2
69845: ARRAY
69846: INC
69847: ST_TO_ADDR
69848: LD_INT 1
69850: PUSH
69851: FOR_DOWNTO
69852: IFFALSE 70097
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69854: LD_EXP 77
69858: PUSH
69859: LD_VAR 0 2
69863: ARRAY
69864: PUSH
69865: LD_VAR 0 3
69869: ARRAY
69870: PUSH
69871: LD_INT 2
69873: ARRAY
69874: PPUSH
69875: LD_EXP 77
69879: PUSH
69880: LD_VAR 0 2
69884: ARRAY
69885: PUSH
69886: LD_VAR 0 3
69890: ARRAY
69891: PUSH
69892: LD_INT 3
69894: ARRAY
69895: PPUSH
69896: CALL_OW 488
69900: PUSH
69901: LD_EXP 77
69905: PUSH
69906: LD_VAR 0 2
69910: ARRAY
69911: PUSH
69912: LD_VAR 0 3
69916: ARRAY
69917: PUSH
69918: LD_INT 2
69920: ARRAY
69921: PPUSH
69922: LD_EXP 77
69926: PUSH
69927: LD_VAR 0 2
69931: ARRAY
69932: PUSH
69933: LD_VAR 0 3
69937: ARRAY
69938: PUSH
69939: LD_INT 3
69941: ARRAY
69942: PPUSH
69943: CALL_OW 284
69947: PUSH
69948: LD_INT 0
69950: EQUAL
69951: AND
69952: IFFALSE 70007
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69954: LD_ADDR_VAR 0 5
69958: PUSH
69959: LD_EXP 77
69963: PUSH
69964: LD_VAR 0 2
69968: ARRAY
69969: PPUSH
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 3
69979: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69980: LD_ADDR_EXP 77
69984: PUSH
69985: LD_EXP 77
69989: PPUSH
69990: LD_VAR 0 2
69994: PPUSH
69995: LD_VAR 0 5
69999: PPUSH
70000: CALL_OW 1
70004: ST_TO_ADDR
// continue ;
70005: GO 69851
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70007: LD_VAR 0 6
70011: PPUSH
70012: LD_EXP 77
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: PUSH
70023: LD_VAR 0 3
70027: ARRAY
70028: PUSH
70029: LD_INT 2
70031: ARRAY
70032: PPUSH
70033: LD_EXP 77
70037: PUSH
70038: LD_VAR 0 2
70042: ARRAY
70043: PUSH
70044: LD_VAR 0 3
70048: ARRAY
70049: PUSH
70050: LD_INT 3
70052: ARRAY
70053: PPUSH
70054: LD_INT 30
70056: PPUSH
70057: CALL 20966 0 4
70061: PUSH
70062: LD_INT 4
70064: ARRAY
70065: PUSH
70066: LD_INT 0
70068: EQUAL
70069: IFFALSE 70095
// begin target := mc_crates [ i ] [ j ] ;
70071: LD_ADDR_VAR 0 7
70075: PUSH
70076: LD_EXP 77
70080: PUSH
70081: LD_VAR 0 2
70085: ARRAY
70086: PUSH
70087: LD_VAR 0 3
70091: ARRAY
70092: ST_TO_ADDR
// break ;
70093: GO 70097
// end ; end ;
70095: GO 69851
70097: POP
70098: POP
// if not target then
70099: LD_VAR 0 7
70103: NOT
70104: IFFALSE 70108
// continue ;
70106: GO 69658
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70108: LD_ADDR_VAR 0 8
70112: PUSH
70113: LD_EXP 80
70117: PUSH
70118: LD_VAR 0 2
70122: ARRAY
70123: PPUSH
70124: LD_INT 2
70126: PUSH
70127: LD_INT 3
70129: PUSH
70130: LD_INT 58
70132: PUSH
70133: EMPTY
70134: LIST
70135: PUSH
70136: EMPTY
70137: LIST
70138: LIST
70139: PUSH
70140: LD_INT 61
70142: PUSH
70143: EMPTY
70144: LIST
70145: PUSH
70146: LD_INT 33
70148: PUSH
70149: LD_INT 5
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 33
70158: PUSH
70159: LD_INT 3
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: EMPTY
70167: LIST
70168: LIST
70169: LIST
70170: LIST
70171: LIST
70172: PUSH
70173: LD_INT 2
70175: PUSH
70176: LD_INT 34
70178: PUSH
70179: LD_INT 32
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 34
70188: PUSH
70189: LD_INT 51
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 34
70198: PUSH
70199: LD_INT 12
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: EMPTY
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: PUSH
70212: EMPTY
70213: LIST
70214: LIST
70215: PPUSH
70216: CALL_OW 72
70220: ST_TO_ADDR
// if not cargo then
70221: LD_VAR 0 8
70225: NOT
70226: IFFALSE 70932
// begin if mc_crates_collector [ i ] < 5 then
70228: LD_EXP 78
70232: PUSH
70233: LD_VAR 0 2
70237: ARRAY
70238: PUSH
70239: LD_INT 5
70241: LESS
70242: IFFALSE 70608
// begin if mc_ape [ i ] then
70244: LD_EXP 90
70248: PUSH
70249: LD_VAR 0 2
70253: ARRAY
70254: IFFALSE 70301
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70256: LD_ADDR_VAR 0 5
70260: PUSH
70261: LD_EXP 90
70265: PUSH
70266: LD_VAR 0 2
70270: ARRAY
70271: PPUSH
70272: LD_INT 25
70274: PUSH
70275: LD_INT 16
70277: PUSH
70278: EMPTY
70279: LIST
70280: LIST
70281: PUSH
70282: LD_INT 24
70284: PUSH
70285: LD_INT 750
70287: PUSH
70288: EMPTY
70289: LIST
70290: LIST
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PPUSH
70296: CALL_OW 72
70300: ST_TO_ADDR
// if not tmp then
70301: LD_VAR 0 5
70305: NOT
70306: IFFALSE 70353
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70308: LD_ADDR_VAR 0 5
70312: PUSH
70313: LD_EXP 61
70317: PUSH
70318: LD_VAR 0 2
70322: ARRAY
70323: PPUSH
70324: LD_INT 25
70326: PUSH
70327: LD_INT 2
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: PUSH
70334: LD_INT 24
70336: PUSH
70337: LD_INT 750
70339: PUSH
70340: EMPTY
70341: LIST
70342: LIST
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PPUSH
70348: CALL_OW 72
70352: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70353: LD_EXP 90
70357: PUSH
70358: LD_VAR 0 2
70362: ARRAY
70363: PUSH
70364: LD_EXP 61
70368: PUSH
70369: LD_VAR 0 2
70373: ARRAY
70374: PPUSH
70375: LD_INT 25
70377: PUSH
70378: LD_INT 2
70380: PUSH
70381: EMPTY
70382: LIST
70383: LIST
70384: PUSH
70385: LD_INT 24
70387: PUSH
70388: LD_INT 750
70390: PUSH
70391: EMPTY
70392: LIST
70393: LIST
70394: PUSH
70395: EMPTY
70396: LIST
70397: LIST
70398: PPUSH
70399: CALL_OW 72
70403: AND
70404: PUSH
70405: LD_VAR 0 5
70409: PUSH
70410: LD_INT 5
70412: LESS
70413: AND
70414: IFFALSE 70496
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70416: LD_ADDR_VAR 0 3
70420: PUSH
70421: LD_EXP 61
70425: PUSH
70426: LD_VAR 0 2
70430: ARRAY
70431: PPUSH
70432: LD_INT 25
70434: PUSH
70435: LD_INT 2
70437: PUSH
70438: EMPTY
70439: LIST
70440: LIST
70441: PUSH
70442: LD_INT 24
70444: PUSH
70445: LD_INT 750
70447: PUSH
70448: EMPTY
70449: LIST
70450: LIST
70451: PUSH
70452: EMPTY
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: PUSH
70461: FOR_IN
70462: IFFALSE 70494
// begin tmp := tmp union j ;
70464: LD_ADDR_VAR 0 5
70468: PUSH
70469: LD_VAR 0 5
70473: PUSH
70474: LD_VAR 0 3
70478: UNION
70479: ST_TO_ADDR
// if tmp >= 5 then
70480: LD_VAR 0 5
70484: PUSH
70485: LD_INT 5
70487: GREATEREQUAL
70488: IFFALSE 70492
// break ;
70490: GO 70494
// end ;
70492: GO 70461
70494: POP
70495: POP
// end ; if not tmp then
70496: LD_VAR 0 5
70500: NOT
70501: IFFALSE 70505
// continue ;
70503: GO 69658
// for j in tmp do
70505: LD_ADDR_VAR 0 3
70509: PUSH
70510: LD_VAR 0 5
70514: PUSH
70515: FOR_IN
70516: IFFALSE 70606
// if not GetTag ( j ) then
70518: LD_VAR 0 3
70522: PPUSH
70523: CALL_OW 110
70527: NOT
70528: IFFALSE 70604
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70530: LD_ADDR_EXP 78
70534: PUSH
70535: LD_EXP 78
70539: PPUSH
70540: LD_VAR 0 2
70544: PUSH
70545: LD_EXP 78
70549: PUSH
70550: LD_VAR 0 2
70554: ARRAY
70555: PUSH
70556: LD_INT 1
70558: PLUS
70559: PUSH
70560: EMPTY
70561: LIST
70562: LIST
70563: PPUSH
70564: LD_VAR 0 3
70568: PPUSH
70569: CALL 20070 0 3
70573: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70574: LD_VAR 0 3
70578: PPUSH
70579: LD_INT 107
70581: PPUSH
70582: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70586: LD_EXP 78
70590: PUSH
70591: LD_VAR 0 2
70595: ARRAY
70596: PUSH
70597: LD_INT 5
70599: GREATEREQUAL
70600: IFFALSE 70604
// break ;
70602: GO 70606
// end ;
70604: GO 70515
70606: POP
70607: POP
// end ; if mc_crates_collector [ i ] and target then
70608: LD_EXP 78
70612: PUSH
70613: LD_VAR 0 2
70617: ARRAY
70618: PUSH
70619: LD_VAR 0 7
70623: AND
70624: IFFALSE 70930
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70626: LD_EXP 78
70630: PUSH
70631: LD_VAR 0 2
70635: ARRAY
70636: PUSH
70637: LD_VAR 0 7
70641: PUSH
70642: LD_INT 1
70644: ARRAY
70645: LESS
70646: IFFALSE 70666
// tmp := mc_crates_collector [ i ] else
70648: LD_ADDR_VAR 0 5
70652: PUSH
70653: LD_EXP 78
70657: PUSH
70658: LD_VAR 0 2
70662: ARRAY
70663: ST_TO_ADDR
70664: GO 70680
// tmp := target [ 1 ] ;
70666: LD_ADDR_VAR 0 5
70670: PUSH
70671: LD_VAR 0 7
70675: PUSH
70676: LD_INT 1
70678: ARRAY
70679: ST_TO_ADDR
// k := 0 ;
70680: LD_ADDR_VAR 0 4
70684: PUSH
70685: LD_INT 0
70687: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70688: LD_ADDR_VAR 0 3
70692: PUSH
70693: LD_EXP 78
70697: PUSH
70698: LD_VAR 0 2
70702: ARRAY
70703: PUSH
70704: FOR_IN
70705: IFFALSE 70928
// begin k := k + 1 ;
70707: LD_ADDR_VAR 0 4
70711: PUSH
70712: LD_VAR 0 4
70716: PUSH
70717: LD_INT 1
70719: PLUS
70720: ST_TO_ADDR
// if k > tmp then
70721: LD_VAR 0 4
70725: PUSH
70726: LD_VAR 0 5
70730: GREATER
70731: IFFALSE 70735
// break ;
70733: GO 70928
// if not GetClass ( j ) in [ 2 , 16 ] then
70735: LD_VAR 0 3
70739: PPUSH
70740: CALL_OW 257
70744: PUSH
70745: LD_INT 2
70747: PUSH
70748: LD_INT 16
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: IN
70755: NOT
70756: IFFALSE 70809
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70758: LD_ADDR_EXP 78
70762: PUSH
70763: LD_EXP 78
70767: PPUSH
70768: LD_VAR 0 2
70772: PPUSH
70773: LD_EXP 78
70777: PUSH
70778: LD_VAR 0 2
70782: ARRAY
70783: PUSH
70784: LD_VAR 0 3
70788: DIFF
70789: PPUSH
70790: CALL_OW 1
70794: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70795: LD_VAR 0 3
70799: PPUSH
70800: LD_INT 0
70802: PPUSH
70803: CALL_OW 109
// continue ;
70807: GO 70704
// end ; if IsInUnit ( j ) then
70809: LD_VAR 0 3
70813: PPUSH
70814: CALL_OW 310
70818: IFFALSE 70829
// ComExitBuilding ( j ) ;
70820: LD_VAR 0 3
70824: PPUSH
70825: CALL_OW 122
// wait ( 3 ) ;
70829: LD_INT 3
70831: PPUSH
70832: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70836: LD_VAR 0 3
70840: PPUSH
70841: CALL_OW 314
70845: PUSH
70846: LD_VAR 0 6
70850: PPUSH
70851: LD_VAR 0 7
70855: PUSH
70856: LD_INT 2
70858: ARRAY
70859: PPUSH
70860: LD_VAR 0 7
70864: PUSH
70865: LD_INT 3
70867: ARRAY
70868: PPUSH
70869: LD_INT 30
70871: PPUSH
70872: CALL 20966 0 4
70876: PUSH
70877: LD_INT 4
70879: ARRAY
70880: AND
70881: IFFALSE 70899
// ComStandNearbyBuilding ( j , depot ) else
70883: LD_VAR 0 3
70887: PPUSH
70888: LD_VAR 0 9
70892: PPUSH
70893: CALL 16497 0 2
70897: GO 70926
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70899: LD_VAR 0 3
70903: PPUSH
70904: LD_VAR 0 7
70908: PUSH
70909: LD_INT 2
70911: ARRAY
70912: PPUSH
70913: LD_VAR 0 7
70917: PUSH
70918: LD_INT 3
70920: ARRAY
70921: PPUSH
70922: CALL_OW 117
// end ;
70926: GO 70704
70928: POP
70929: POP
// end ; end else
70930: GO 71462
// begin for j in cargo do
70932: LD_ADDR_VAR 0 3
70936: PUSH
70937: LD_VAR 0 8
70941: PUSH
70942: FOR_IN
70943: IFFALSE 71460
// begin if GetTag ( j ) <> 0 then
70945: LD_VAR 0 3
70949: PPUSH
70950: CALL_OW 110
70954: PUSH
70955: LD_INT 0
70957: NONEQUAL
70958: IFFALSE 70962
// continue ;
70960: GO 70942
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70962: LD_VAR 0 3
70966: PPUSH
70967: CALL_OW 256
70971: PUSH
70972: LD_INT 1000
70974: LESS
70975: PUSH
70976: LD_VAR 0 3
70980: PPUSH
70981: LD_EXP 85
70985: PUSH
70986: LD_VAR 0 2
70990: ARRAY
70991: PPUSH
70992: CALL_OW 308
70996: NOT
70997: AND
70998: IFFALSE 71020
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71000: LD_VAR 0 3
71004: PPUSH
71005: LD_EXP 85
71009: PUSH
71010: LD_VAR 0 2
71014: ARRAY
71015: PPUSH
71016: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71020: LD_VAR 0 3
71024: PPUSH
71025: CALL_OW 256
71029: PUSH
71030: LD_INT 1000
71032: LESS
71033: PUSH
71034: LD_VAR 0 3
71038: PPUSH
71039: LD_EXP 85
71043: PUSH
71044: LD_VAR 0 2
71048: ARRAY
71049: PPUSH
71050: CALL_OW 308
71054: AND
71055: IFFALSE 71059
// continue ;
71057: GO 70942
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL_OW 262
71068: PUSH
71069: LD_INT 2
71071: EQUAL
71072: PUSH
71073: LD_VAR 0 3
71077: PPUSH
71078: CALL_OW 261
71082: PUSH
71083: LD_INT 15
71085: LESS
71086: AND
71087: IFFALSE 71091
// continue ;
71089: GO 70942
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71091: LD_VAR 0 3
71095: PPUSH
71096: CALL_OW 262
71100: PUSH
71101: LD_INT 1
71103: EQUAL
71104: PUSH
71105: LD_VAR 0 3
71109: PPUSH
71110: CALL_OW 261
71114: PUSH
71115: LD_INT 10
71117: LESS
71118: AND
71119: IFFALSE 71399
// begin if not depot then
71121: LD_VAR 0 9
71125: NOT
71126: IFFALSE 71130
// continue ;
71128: GO 70942
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71130: LD_VAR 0 3
71134: PPUSH
71135: LD_VAR 0 9
71139: PPUSH
71140: LD_VAR 0 3
71144: PPUSH
71145: CALL_OW 74
71149: PPUSH
71150: CALL_OW 296
71154: PUSH
71155: LD_INT 6
71157: LESS
71158: IFFALSE 71174
// SetFuel ( j , 100 ) else
71160: LD_VAR 0 3
71164: PPUSH
71165: LD_INT 100
71167: PPUSH
71168: CALL_OW 240
71172: GO 71399
// if GetFuel ( j ) = 0 then
71174: LD_VAR 0 3
71178: PPUSH
71179: CALL_OW 261
71183: PUSH
71184: LD_INT 0
71186: EQUAL
71187: IFFALSE 71399
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71189: LD_ADDR_EXP 80
71193: PUSH
71194: LD_EXP 80
71198: PPUSH
71199: LD_VAR 0 2
71203: PPUSH
71204: LD_EXP 80
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_VAR 0 3
71219: DIFF
71220: PPUSH
71221: CALL_OW 1
71225: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71226: LD_VAR 0 3
71230: PPUSH
71231: CALL_OW 263
71235: PUSH
71236: LD_INT 1
71238: EQUAL
71239: IFFALSE 71255
// ComExitVehicle ( IsInUnit ( j ) ) ;
71241: LD_VAR 0 3
71245: PPUSH
71246: CALL_OW 310
71250: PPUSH
71251: CALL_OW 121
// if GetControl ( j ) = control_remote then
71255: LD_VAR 0 3
71259: PPUSH
71260: CALL_OW 263
71264: PUSH
71265: LD_INT 2
71267: EQUAL
71268: IFFALSE 71279
// ComUnlink ( j ) ;
71270: LD_VAR 0 3
71274: PPUSH
71275: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71279: LD_ADDR_VAR 0 10
71283: PUSH
71284: LD_VAR 0 2
71288: PPUSH
71289: LD_INT 3
71291: PPUSH
71292: CALL 81066 0 2
71296: ST_TO_ADDR
// if fac then
71297: LD_VAR 0 10
71301: IFFALSE 71397
// begin for k in fac do
71303: LD_ADDR_VAR 0 4
71307: PUSH
71308: LD_VAR 0 10
71312: PUSH
71313: FOR_IN
71314: IFFALSE 71395
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71316: LD_ADDR_VAR 0 11
71320: PUSH
71321: LD_VAR 0 10
71325: PPUSH
71326: LD_VAR 0 3
71330: PPUSH
71331: CALL_OW 265
71335: PPUSH
71336: LD_VAR 0 3
71340: PPUSH
71341: CALL_OW 262
71345: PPUSH
71346: LD_VAR 0 3
71350: PPUSH
71351: CALL_OW 263
71355: PPUSH
71356: LD_VAR 0 3
71360: PPUSH
71361: CALL_OW 264
71365: PPUSH
71366: CALL 17568 0 5
71370: ST_TO_ADDR
// if components then
71371: LD_VAR 0 11
71375: IFFALSE 71393
// begin MC_InsertProduceList ( i , components ) ;
71377: LD_VAR 0 2
71381: PPUSH
71382: LD_VAR 0 11
71386: PPUSH
71387: CALL 80611 0 2
// break ;
71391: GO 71395
// end ; end ;
71393: GO 71313
71395: POP
71396: POP
// end ; continue ;
71397: GO 70942
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71399: LD_VAR 0 3
71403: PPUSH
71404: LD_INT 1
71406: PPUSH
71407: CALL_OW 289
71411: PUSH
71412: LD_INT 100
71414: LESS
71415: PUSH
71416: LD_VAR 0 3
71420: PPUSH
71421: CALL_OW 314
71425: NOT
71426: AND
71427: IFFALSE 71456
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71429: LD_VAR 0 3
71433: PPUSH
71434: LD_VAR 0 7
71438: PUSH
71439: LD_INT 2
71441: ARRAY
71442: PPUSH
71443: LD_VAR 0 7
71447: PUSH
71448: LD_INT 3
71450: ARRAY
71451: PPUSH
71452: CALL_OW 117
// break ;
71456: GO 71460
// end ;
71458: GO 70942
71460: POP
71461: POP
// end ; end ;
71462: GO 69658
71464: POP
71465: POP
// end ;
71466: LD_VAR 0 1
71470: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71471: LD_INT 0
71473: PPUSH
71474: PPUSH
71475: PPUSH
71476: PPUSH
// if not mc_bases then
71477: LD_EXP 61
71481: NOT
71482: IFFALSE 71486
// exit ;
71484: GO 71647
// for i = 1 to mc_bases do
71486: LD_ADDR_VAR 0 2
71490: PUSH
71491: DOUBLE
71492: LD_INT 1
71494: DEC
71495: ST_TO_ADDR
71496: LD_EXP 61
71500: PUSH
71501: FOR_TO
71502: IFFALSE 71645
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71504: LD_ADDR_VAR 0 4
71508: PUSH
71509: LD_EXP 80
71513: PUSH
71514: LD_VAR 0 2
71518: ARRAY
71519: PUSH
71520: LD_EXP 83
71524: PUSH
71525: LD_VAR 0 2
71529: ARRAY
71530: UNION
71531: PPUSH
71532: LD_INT 33
71534: PUSH
71535: LD_INT 2
71537: PUSH
71538: EMPTY
71539: LIST
71540: LIST
71541: PPUSH
71542: CALL_OW 72
71546: ST_TO_ADDR
// if tmp then
71547: LD_VAR 0 4
71551: IFFALSE 71643
// for j in tmp do
71553: LD_ADDR_VAR 0 3
71557: PUSH
71558: LD_VAR 0 4
71562: PUSH
71563: FOR_IN
71564: IFFALSE 71641
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71566: LD_VAR 0 3
71570: PPUSH
71571: CALL_OW 312
71575: NOT
71576: PUSH
71577: LD_VAR 0 3
71581: PPUSH
71582: CALL_OW 256
71586: PUSH
71587: LD_INT 250
71589: GREATEREQUAL
71590: AND
71591: IFFALSE 71604
// Connect ( j ) else
71593: LD_VAR 0 3
71597: PPUSH
71598: CALL 23039 0 1
71602: GO 71639
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71604: LD_VAR 0 3
71608: PPUSH
71609: CALL_OW 256
71613: PUSH
71614: LD_INT 250
71616: LESS
71617: PUSH
71618: LD_VAR 0 3
71622: PPUSH
71623: CALL_OW 312
71627: AND
71628: IFFALSE 71639
// ComUnlink ( j ) ;
71630: LD_VAR 0 3
71634: PPUSH
71635: CALL_OW 136
71639: GO 71563
71641: POP
71642: POP
// end ;
71643: GO 71501
71645: POP
71646: POP
// end ;
71647: LD_VAR 0 1
71651: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71652: LD_INT 0
71654: PPUSH
71655: PPUSH
71656: PPUSH
71657: PPUSH
71658: PPUSH
// if not mc_bases then
71659: LD_EXP 61
71663: NOT
71664: IFFALSE 71668
// exit ;
71666: GO 72113
// for i = 1 to mc_bases do
71668: LD_ADDR_VAR 0 2
71672: PUSH
71673: DOUBLE
71674: LD_INT 1
71676: DEC
71677: ST_TO_ADDR
71678: LD_EXP 61
71682: PUSH
71683: FOR_TO
71684: IFFALSE 72111
// begin if not mc_produce [ i ] then
71686: LD_EXP 82
71690: PUSH
71691: LD_VAR 0 2
71695: ARRAY
71696: NOT
71697: IFFALSE 71701
// continue ;
71699: GO 71683
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71701: LD_ADDR_VAR 0 5
71705: PUSH
71706: LD_EXP 61
71710: PUSH
71711: LD_VAR 0 2
71715: ARRAY
71716: PPUSH
71717: LD_INT 30
71719: PUSH
71720: LD_INT 3
71722: PUSH
71723: EMPTY
71724: LIST
71725: LIST
71726: PPUSH
71727: CALL_OW 72
71731: ST_TO_ADDR
// if not fac then
71732: LD_VAR 0 5
71736: NOT
71737: IFFALSE 71741
// continue ;
71739: GO 71683
// for j in fac do
71741: LD_ADDR_VAR 0 3
71745: PUSH
71746: LD_VAR 0 5
71750: PUSH
71751: FOR_IN
71752: IFFALSE 72107
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71754: LD_VAR 0 3
71758: PPUSH
71759: CALL_OW 461
71763: PUSH
71764: LD_INT 2
71766: NONEQUAL
71767: PUSH
71768: LD_VAR 0 3
71772: PPUSH
71773: LD_INT 15
71775: PPUSH
71776: CALL 22667 0 2
71780: PUSH
71781: LD_INT 4
71783: ARRAY
71784: OR
71785: IFFALSE 71789
// continue ;
71787: GO 71751
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71789: LD_VAR 0 3
71793: PPUSH
71794: LD_EXP 82
71798: PUSH
71799: LD_VAR 0 2
71803: ARRAY
71804: PUSH
71805: LD_INT 1
71807: ARRAY
71808: PUSH
71809: LD_INT 1
71811: ARRAY
71812: PPUSH
71813: LD_EXP 82
71817: PUSH
71818: LD_VAR 0 2
71822: ARRAY
71823: PUSH
71824: LD_INT 1
71826: ARRAY
71827: PUSH
71828: LD_INT 2
71830: ARRAY
71831: PPUSH
71832: LD_EXP 82
71836: PUSH
71837: LD_VAR 0 2
71841: ARRAY
71842: PUSH
71843: LD_INT 1
71845: ARRAY
71846: PUSH
71847: LD_INT 3
71849: ARRAY
71850: PPUSH
71851: LD_EXP 82
71855: PUSH
71856: LD_VAR 0 2
71860: ARRAY
71861: PUSH
71862: LD_INT 1
71864: ARRAY
71865: PUSH
71866: LD_INT 4
71868: ARRAY
71869: PPUSH
71870: CALL_OW 448
71874: PUSH
71875: LD_VAR 0 3
71879: PPUSH
71880: LD_EXP 82
71884: PUSH
71885: LD_VAR 0 2
71889: ARRAY
71890: PUSH
71891: LD_INT 1
71893: ARRAY
71894: PUSH
71895: LD_INT 1
71897: ARRAY
71898: PUSH
71899: LD_EXP 82
71903: PUSH
71904: LD_VAR 0 2
71908: ARRAY
71909: PUSH
71910: LD_INT 1
71912: ARRAY
71913: PUSH
71914: LD_INT 2
71916: ARRAY
71917: PUSH
71918: LD_EXP 82
71922: PUSH
71923: LD_VAR 0 2
71927: ARRAY
71928: PUSH
71929: LD_INT 1
71931: ARRAY
71932: PUSH
71933: LD_INT 3
71935: ARRAY
71936: PUSH
71937: LD_EXP 82
71941: PUSH
71942: LD_VAR 0 2
71946: ARRAY
71947: PUSH
71948: LD_INT 1
71950: ARRAY
71951: PUSH
71952: LD_INT 4
71954: ARRAY
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: LIST
71960: LIST
71961: PPUSH
71962: CALL 26434 0 2
71966: AND
71967: IFFALSE 72105
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71969: LD_VAR 0 3
71973: PPUSH
71974: LD_EXP 82
71978: PUSH
71979: LD_VAR 0 2
71983: ARRAY
71984: PUSH
71985: LD_INT 1
71987: ARRAY
71988: PUSH
71989: LD_INT 1
71991: ARRAY
71992: PPUSH
71993: LD_EXP 82
71997: PUSH
71998: LD_VAR 0 2
72002: ARRAY
72003: PUSH
72004: LD_INT 1
72006: ARRAY
72007: PUSH
72008: LD_INT 2
72010: ARRAY
72011: PPUSH
72012: LD_EXP 82
72016: PUSH
72017: LD_VAR 0 2
72021: ARRAY
72022: PUSH
72023: LD_INT 1
72025: ARRAY
72026: PUSH
72027: LD_INT 3
72029: ARRAY
72030: PPUSH
72031: LD_EXP 82
72035: PUSH
72036: LD_VAR 0 2
72040: ARRAY
72041: PUSH
72042: LD_INT 1
72044: ARRAY
72045: PUSH
72046: LD_INT 4
72048: ARRAY
72049: PPUSH
72050: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72054: LD_ADDR_VAR 0 4
72058: PUSH
72059: LD_EXP 82
72063: PUSH
72064: LD_VAR 0 2
72068: ARRAY
72069: PPUSH
72070: LD_INT 1
72072: PPUSH
72073: CALL_OW 3
72077: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72078: LD_ADDR_EXP 82
72082: PUSH
72083: LD_EXP 82
72087: PPUSH
72088: LD_VAR 0 2
72092: PPUSH
72093: LD_VAR 0 4
72097: PPUSH
72098: CALL_OW 1
72102: ST_TO_ADDR
// break ;
72103: GO 72107
// end ; end ;
72105: GO 71751
72107: POP
72108: POP
// end ;
72109: GO 71683
72111: POP
72112: POP
// end ;
72113: LD_VAR 0 1
72117: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72118: LD_INT 0
72120: PPUSH
72121: PPUSH
72122: PPUSH
// if not mc_bases then
72123: LD_EXP 61
72127: NOT
72128: IFFALSE 72132
// exit ;
72130: GO 72221
// for i = 1 to mc_bases do
72132: LD_ADDR_VAR 0 2
72136: PUSH
72137: DOUBLE
72138: LD_INT 1
72140: DEC
72141: ST_TO_ADDR
72142: LD_EXP 61
72146: PUSH
72147: FOR_TO
72148: IFFALSE 72219
// begin if mc_attack [ i ] then
72150: LD_EXP 81
72154: PUSH
72155: LD_VAR 0 2
72159: ARRAY
72160: IFFALSE 72217
// begin tmp := mc_attack [ i ] [ 1 ] ;
72162: LD_ADDR_VAR 0 3
72166: PUSH
72167: LD_EXP 81
72171: PUSH
72172: LD_VAR 0 2
72176: ARRAY
72177: PUSH
72178: LD_INT 1
72180: ARRAY
72181: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72182: LD_ADDR_EXP 81
72186: PUSH
72187: LD_EXP 81
72191: PPUSH
72192: LD_VAR 0 2
72196: PPUSH
72197: EMPTY
72198: PPUSH
72199: CALL_OW 1
72203: ST_TO_ADDR
// Attack ( tmp ) ;
72204: LD_VAR 0 3
72208: PPUSH
72209: CALL 106937 0 1
// exit ;
72213: POP
72214: POP
72215: GO 72221
// end ; end ;
72217: GO 72147
72219: POP
72220: POP
// end ;
72221: LD_VAR 0 1
72225: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72226: LD_INT 0
72228: PPUSH
72229: PPUSH
72230: PPUSH
72231: PPUSH
72232: PPUSH
72233: PPUSH
72234: PPUSH
// if not mc_bases then
72235: LD_EXP 61
72239: NOT
72240: IFFALSE 72244
// exit ;
72242: GO 73101
// for i = 1 to mc_bases do
72244: LD_ADDR_VAR 0 2
72248: PUSH
72249: DOUBLE
72250: LD_INT 1
72252: DEC
72253: ST_TO_ADDR
72254: LD_EXP 61
72258: PUSH
72259: FOR_TO
72260: IFFALSE 73099
// begin if not mc_bases [ i ] then
72262: LD_EXP 61
72266: PUSH
72267: LD_VAR 0 2
72271: ARRAY
72272: NOT
72273: IFFALSE 72277
// continue ;
72275: GO 72259
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72277: LD_ADDR_VAR 0 7
72281: PUSH
72282: LD_EXP 61
72286: PUSH
72287: LD_VAR 0 2
72291: ARRAY
72292: PUSH
72293: LD_INT 1
72295: ARRAY
72296: PPUSH
72297: CALL 16719 0 1
72301: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72302: LD_ADDR_EXP 84
72306: PUSH
72307: LD_EXP 84
72311: PPUSH
72312: LD_VAR 0 2
72316: PPUSH
72317: LD_EXP 61
72321: PUSH
72322: LD_VAR 0 2
72326: ARRAY
72327: PUSH
72328: LD_INT 1
72330: ARRAY
72331: PPUSH
72332: CALL_OW 255
72336: PPUSH
72337: LD_EXP 86
72341: PUSH
72342: LD_VAR 0 2
72346: ARRAY
72347: PPUSH
72348: CALL 16684 0 2
72352: PPUSH
72353: CALL_OW 1
72357: ST_TO_ADDR
// if not mc_scan [ i ] then
72358: LD_EXP 84
72362: PUSH
72363: LD_VAR 0 2
72367: ARRAY
72368: NOT
72369: IFFALSE 72547
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72371: LD_ADDR_EXP 104
72375: PUSH
72376: LD_EXP 104
72380: PPUSH
72381: LD_VAR 0 2
72385: PPUSH
72386: LD_INT 0
72388: PPUSH
72389: CALL_OW 1
72393: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72394: LD_ADDR_VAR 0 4
72398: PUSH
72399: LD_EXP 61
72403: PUSH
72404: LD_VAR 0 2
72408: ARRAY
72409: PPUSH
72410: LD_INT 2
72412: PUSH
72413: LD_INT 25
72415: PUSH
72416: LD_INT 5
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PUSH
72423: LD_INT 25
72425: PUSH
72426: LD_INT 8
72428: PUSH
72429: EMPTY
72430: LIST
72431: LIST
72432: PUSH
72433: LD_INT 25
72435: PUSH
72436: LD_INT 9
72438: PUSH
72439: EMPTY
72440: LIST
72441: LIST
72442: PUSH
72443: EMPTY
72444: LIST
72445: LIST
72446: LIST
72447: LIST
72448: PPUSH
72449: CALL_OW 72
72453: ST_TO_ADDR
// if not tmp then
72454: LD_VAR 0 4
72458: NOT
72459: IFFALSE 72463
// continue ;
72461: GO 72259
// for j in tmp do
72463: LD_ADDR_VAR 0 3
72467: PUSH
72468: LD_VAR 0 4
72472: PUSH
72473: FOR_IN
72474: IFFALSE 72545
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72476: LD_VAR 0 3
72480: PPUSH
72481: CALL_OW 310
72485: PPUSH
72486: CALL_OW 266
72490: PUSH
72491: LD_INT 5
72493: EQUAL
72494: PUSH
72495: LD_VAR 0 3
72499: PPUSH
72500: CALL_OW 257
72504: PUSH
72505: LD_INT 1
72507: EQUAL
72508: AND
72509: PUSH
72510: LD_VAR 0 3
72514: PPUSH
72515: CALL_OW 459
72519: NOT
72520: AND
72521: PUSH
72522: LD_VAR 0 7
72526: AND
72527: IFFALSE 72543
// ComChangeProfession ( j , class ) ;
72529: LD_VAR 0 3
72533: PPUSH
72534: LD_VAR 0 7
72538: PPUSH
72539: CALL_OW 123
72543: GO 72473
72545: POP
72546: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72547: LD_EXP 84
72551: PUSH
72552: LD_VAR 0 2
72556: ARRAY
72557: PUSH
72558: LD_EXP 104
72562: PUSH
72563: LD_VAR 0 2
72567: ARRAY
72568: NOT
72569: AND
72570: PUSH
72571: LD_EXP 83
72575: PUSH
72576: LD_VAR 0 2
72580: ARRAY
72581: NOT
72582: AND
72583: PUSH
72584: LD_EXP 61
72588: PUSH
72589: LD_VAR 0 2
72593: ARRAY
72594: PPUSH
72595: LD_INT 50
72597: PUSH
72598: EMPTY
72599: LIST
72600: PUSH
72601: LD_INT 2
72603: PUSH
72604: LD_INT 30
72606: PUSH
72607: LD_INT 32
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 30
72616: PUSH
72617: LD_INT 33
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 30
72626: PUSH
72627: LD_INT 4
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: PUSH
72634: LD_INT 30
72636: PUSH
72637: LD_INT 5
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: EMPTY
72645: LIST
72646: LIST
72647: LIST
72648: LIST
72649: LIST
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PPUSH
72655: CALL_OW 72
72659: PUSH
72660: LD_INT 4
72662: LESS
72663: PUSH
72664: LD_EXP 61
72668: PUSH
72669: LD_VAR 0 2
72673: ARRAY
72674: PPUSH
72675: LD_INT 3
72677: PUSH
72678: LD_INT 24
72680: PUSH
72681: LD_INT 1000
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 2
72694: PUSH
72695: LD_INT 30
72697: PUSH
72698: LD_INT 0
72700: PUSH
72701: EMPTY
72702: LIST
72703: LIST
72704: PUSH
72705: LD_INT 30
72707: PUSH
72708: LD_INT 1
72710: PUSH
72711: EMPTY
72712: LIST
72713: LIST
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: LIST
72719: PUSH
72720: EMPTY
72721: LIST
72722: LIST
72723: PPUSH
72724: CALL_OW 72
72728: OR
72729: AND
72730: IFFALSE 72981
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72732: LD_ADDR_EXP 104
72736: PUSH
72737: LD_EXP 104
72741: PPUSH
72742: LD_VAR 0 2
72746: PPUSH
72747: LD_INT 1
72749: PPUSH
72750: CALL_OW 1
72754: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72755: LD_ADDR_VAR 0 4
72759: PUSH
72760: LD_EXP 61
72764: PUSH
72765: LD_VAR 0 2
72769: ARRAY
72770: PPUSH
72771: LD_INT 2
72773: PUSH
72774: LD_INT 25
72776: PUSH
72777: LD_INT 1
72779: PUSH
72780: EMPTY
72781: LIST
72782: LIST
72783: PUSH
72784: LD_INT 25
72786: PUSH
72787: LD_INT 5
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: LD_INT 25
72796: PUSH
72797: LD_INT 8
72799: PUSH
72800: EMPTY
72801: LIST
72802: LIST
72803: PUSH
72804: LD_INT 25
72806: PUSH
72807: LD_INT 9
72809: PUSH
72810: EMPTY
72811: LIST
72812: LIST
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: LIST
72818: LIST
72819: LIST
72820: PPUSH
72821: CALL_OW 72
72825: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72826: LD_ADDR_VAR 0 4
72830: PUSH
72831: LD_VAR 0 4
72835: PUSH
72836: LD_VAR 0 4
72840: PPUSH
72841: LD_INT 18
72843: PPUSH
72844: CALL 49956 0 2
72848: DIFF
72849: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72850: LD_VAR 0 4
72854: NOT
72855: PUSH
72856: LD_EXP 61
72860: PUSH
72861: LD_VAR 0 2
72865: ARRAY
72866: PPUSH
72867: LD_INT 2
72869: PUSH
72870: LD_INT 30
72872: PUSH
72873: LD_INT 4
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: PUSH
72880: LD_INT 30
72882: PUSH
72883: LD_INT 5
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: LIST
72894: PPUSH
72895: CALL_OW 72
72899: NOT
72900: AND
72901: IFFALSE 72963
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72903: LD_ADDR_VAR 0 4
72907: PUSH
72908: LD_EXP 61
72912: PUSH
72913: LD_VAR 0 2
72917: ARRAY
72918: PPUSH
72919: LD_INT 2
72921: PUSH
72922: LD_INT 25
72924: PUSH
72925: LD_INT 2
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: LD_INT 25
72934: PUSH
72935: LD_INT 3
72937: PUSH
72938: EMPTY
72939: LIST
72940: LIST
72941: PUSH
72942: LD_INT 25
72944: PUSH
72945: LD_INT 4
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: LIST
72956: LIST
72957: PPUSH
72958: CALL_OW 72
72962: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72963: LD_VAR 0 2
72967: PPUSH
72968: LD_VAR 0 4
72972: PPUSH
72973: CALL 111646 0 2
// exit ;
72977: POP
72978: POP
72979: GO 73101
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
72981: LD_EXP 84
72985: PUSH
72986: LD_VAR 0 2
72990: ARRAY
72991: PUSH
72992: LD_EXP 104
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: NOT
73003: AND
73004: PUSH
73005: LD_EXP 83
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: AND
73016: IFFALSE 73097
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73018: LD_ADDR_EXP 104
73022: PUSH
73023: LD_EXP 104
73027: PPUSH
73028: LD_VAR 0 2
73032: PPUSH
73033: LD_INT 1
73035: PPUSH
73036: CALL_OW 1
73040: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73041: LD_ADDR_VAR 0 4
73045: PUSH
73046: LD_EXP 83
73050: PUSH
73051: LD_VAR 0 2
73055: ARRAY
73056: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73057: LD_ADDR_EXP 83
73061: PUSH
73062: LD_EXP 83
73066: PPUSH
73067: LD_VAR 0 2
73071: PPUSH
73072: EMPTY
73073: PPUSH
73074: CALL_OW 1
73078: ST_TO_ADDR
// Defend ( i , tmp ) ;
73079: LD_VAR 0 2
73083: PPUSH
73084: LD_VAR 0 4
73088: PPUSH
73089: CALL 112242 0 2
// exit ;
73093: POP
73094: POP
73095: GO 73101
// end ; end ;
73097: GO 72259
73099: POP
73100: POP
// end ;
73101: LD_VAR 0 1
73105: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73106: LD_INT 0
73108: PPUSH
73109: PPUSH
73110: PPUSH
73111: PPUSH
73112: PPUSH
73113: PPUSH
73114: PPUSH
73115: PPUSH
73116: PPUSH
73117: PPUSH
73118: PPUSH
// if not mc_bases then
73119: LD_EXP 61
73123: NOT
73124: IFFALSE 73128
// exit ;
73126: GO 74215
// for i = 1 to mc_bases do
73128: LD_ADDR_VAR 0 2
73132: PUSH
73133: DOUBLE
73134: LD_INT 1
73136: DEC
73137: ST_TO_ADDR
73138: LD_EXP 61
73142: PUSH
73143: FOR_TO
73144: IFFALSE 74213
// begin tmp := mc_lab [ i ] ;
73146: LD_ADDR_VAR 0 6
73150: PUSH
73151: LD_EXP 94
73155: PUSH
73156: LD_VAR 0 2
73160: ARRAY
73161: ST_TO_ADDR
// if not tmp then
73162: LD_VAR 0 6
73166: NOT
73167: IFFALSE 73171
// continue ;
73169: GO 73143
// idle_lab := 0 ;
73171: LD_ADDR_VAR 0 11
73175: PUSH
73176: LD_INT 0
73178: ST_TO_ADDR
// for j in tmp do
73179: LD_ADDR_VAR 0 3
73183: PUSH
73184: LD_VAR 0 6
73188: PUSH
73189: FOR_IN
73190: IFFALSE 74209
// begin researching := false ;
73192: LD_ADDR_VAR 0 10
73196: PUSH
73197: LD_INT 0
73199: ST_TO_ADDR
// side := GetSide ( j ) ;
73200: LD_ADDR_VAR 0 4
73204: PUSH
73205: LD_VAR 0 3
73209: PPUSH
73210: CALL_OW 255
73214: ST_TO_ADDR
// if not mc_tech [ side ] then
73215: LD_EXP 88
73219: PUSH
73220: LD_VAR 0 4
73224: ARRAY
73225: NOT
73226: IFFALSE 73230
// continue ;
73228: GO 73189
// if BuildingStatus ( j ) = bs_idle then
73230: LD_VAR 0 3
73234: PPUSH
73235: CALL_OW 461
73239: PUSH
73240: LD_INT 2
73242: EQUAL
73243: IFFALSE 73431
// begin if idle_lab and UnitsInside ( j ) < 6 then
73245: LD_VAR 0 11
73249: PUSH
73250: LD_VAR 0 3
73254: PPUSH
73255: CALL_OW 313
73259: PUSH
73260: LD_INT 6
73262: LESS
73263: AND
73264: IFFALSE 73335
// begin tmp2 := UnitsInside ( idle_lab ) ;
73266: LD_ADDR_VAR 0 9
73270: PUSH
73271: LD_VAR 0 11
73275: PPUSH
73276: CALL_OW 313
73280: ST_TO_ADDR
// if tmp2 then
73281: LD_VAR 0 9
73285: IFFALSE 73327
// for x in tmp2 do
73287: LD_ADDR_VAR 0 7
73291: PUSH
73292: LD_VAR 0 9
73296: PUSH
73297: FOR_IN
73298: IFFALSE 73325
// begin ComExitBuilding ( x ) ;
73300: LD_VAR 0 7
73304: PPUSH
73305: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73309: LD_VAR 0 7
73313: PPUSH
73314: LD_VAR 0 3
73318: PPUSH
73319: CALL_OW 180
// end ;
73323: GO 73297
73325: POP
73326: POP
// idle_lab := 0 ;
73327: LD_ADDR_VAR 0 11
73331: PUSH
73332: LD_INT 0
73334: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73335: LD_ADDR_VAR 0 5
73339: PUSH
73340: LD_EXP 88
73344: PUSH
73345: LD_VAR 0 4
73349: ARRAY
73350: PUSH
73351: FOR_IN
73352: IFFALSE 73412
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73354: LD_VAR 0 3
73358: PPUSH
73359: LD_VAR 0 5
73363: PPUSH
73364: CALL_OW 430
73368: PUSH
73369: LD_VAR 0 4
73373: PPUSH
73374: LD_VAR 0 5
73378: PPUSH
73379: CALL 15789 0 2
73383: AND
73384: IFFALSE 73410
// begin researching := true ;
73386: LD_ADDR_VAR 0 10
73390: PUSH
73391: LD_INT 1
73393: ST_TO_ADDR
// ComResearch ( j , t ) ;
73394: LD_VAR 0 3
73398: PPUSH
73399: LD_VAR 0 5
73403: PPUSH
73404: CALL_OW 124
// break ;
73408: GO 73412
// end ;
73410: GO 73351
73412: POP
73413: POP
// if not researching then
73414: LD_VAR 0 10
73418: NOT
73419: IFFALSE 73431
// idle_lab := j ;
73421: LD_ADDR_VAR 0 11
73425: PUSH
73426: LD_VAR 0 3
73430: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73431: LD_VAR 0 3
73435: PPUSH
73436: CALL_OW 461
73440: PUSH
73441: LD_INT 10
73443: EQUAL
73444: IFFALSE 74032
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73446: LD_EXP 90
73450: PUSH
73451: LD_VAR 0 2
73455: ARRAY
73456: NOT
73457: PUSH
73458: LD_EXP 91
73462: PUSH
73463: LD_VAR 0 2
73467: ARRAY
73468: NOT
73469: AND
73470: PUSH
73471: LD_EXP 88
73475: PUSH
73476: LD_VAR 0 4
73480: ARRAY
73481: PUSH
73482: LD_INT 1
73484: GREATER
73485: AND
73486: IFFALSE 73617
// begin ComCancel ( j ) ;
73488: LD_VAR 0 3
73492: PPUSH
73493: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73497: LD_ADDR_EXP 88
73501: PUSH
73502: LD_EXP 88
73506: PPUSH
73507: LD_VAR 0 4
73511: PPUSH
73512: LD_EXP 88
73516: PUSH
73517: LD_VAR 0 4
73521: ARRAY
73522: PPUSH
73523: LD_EXP 88
73527: PUSH
73528: LD_VAR 0 4
73532: ARRAY
73533: PUSH
73534: LD_INT 1
73536: MINUS
73537: PPUSH
73538: LD_EXP 88
73542: PUSH
73543: LD_VAR 0 4
73547: ARRAY
73548: PPUSH
73549: LD_INT 0
73551: PPUSH
73552: CALL 19488 0 4
73556: PPUSH
73557: CALL_OW 1
73561: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73562: LD_ADDR_EXP 88
73566: PUSH
73567: LD_EXP 88
73571: PPUSH
73572: LD_VAR 0 4
73576: PPUSH
73577: LD_EXP 88
73581: PUSH
73582: LD_VAR 0 4
73586: ARRAY
73587: PPUSH
73588: LD_EXP 88
73592: PUSH
73593: LD_VAR 0 4
73597: ARRAY
73598: PPUSH
73599: LD_INT 1
73601: PPUSH
73602: LD_INT 0
73604: PPUSH
73605: CALL 19488 0 4
73609: PPUSH
73610: CALL_OW 1
73614: ST_TO_ADDR
// continue ;
73615: GO 73189
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73617: LD_EXP 90
73621: PUSH
73622: LD_VAR 0 2
73626: ARRAY
73627: PUSH
73628: LD_EXP 91
73632: PUSH
73633: LD_VAR 0 2
73637: ARRAY
73638: NOT
73639: AND
73640: IFFALSE 73767
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73642: LD_ADDR_EXP 91
73646: PUSH
73647: LD_EXP 91
73651: PPUSH
73652: LD_VAR 0 2
73656: PUSH
73657: LD_EXP 91
73661: PUSH
73662: LD_VAR 0 2
73666: ARRAY
73667: PUSH
73668: LD_INT 1
73670: PLUS
73671: PUSH
73672: EMPTY
73673: LIST
73674: LIST
73675: PPUSH
73676: LD_EXP 90
73680: PUSH
73681: LD_VAR 0 2
73685: ARRAY
73686: PUSH
73687: LD_INT 1
73689: ARRAY
73690: PPUSH
73691: CALL 20070 0 3
73695: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73696: LD_EXP 90
73700: PUSH
73701: LD_VAR 0 2
73705: ARRAY
73706: PUSH
73707: LD_INT 1
73709: ARRAY
73710: PPUSH
73711: LD_INT 112
73713: PPUSH
73714: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73718: LD_ADDR_VAR 0 9
73722: PUSH
73723: LD_EXP 90
73727: PUSH
73728: LD_VAR 0 2
73732: ARRAY
73733: PPUSH
73734: LD_INT 1
73736: PPUSH
73737: CALL_OW 3
73741: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73742: LD_ADDR_EXP 90
73746: PUSH
73747: LD_EXP 90
73751: PPUSH
73752: LD_VAR 0 2
73756: PPUSH
73757: LD_VAR 0 9
73761: PPUSH
73762: CALL_OW 1
73766: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73767: LD_EXP 90
73771: PUSH
73772: LD_VAR 0 2
73776: ARRAY
73777: PUSH
73778: LD_EXP 91
73782: PUSH
73783: LD_VAR 0 2
73787: ARRAY
73788: AND
73789: PUSH
73790: LD_EXP 91
73794: PUSH
73795: LD_VAR 0 2
73799: ARRAY
73800: PUSH
73801: LD_INT 1
73803: ARRAY
73804: PPUSH
73805: CALL_OW 310
73809: NOT
73810: AND
73811: PUSH
73812: LD_VAR 0 3
73816: PPUSH
73817: CALL_OW 313
73821: PUSH
73822: LD_INT 6
73824: EQUAL
73825: AND
73826: IFFALSE 73882
// begin tmp2 := UnitsInside ( j ) ;
73828: LD_ADDR_VAR 0 9
73832: PUSH
73833: LD_VAR 0 3
73837: PPUSH
73838: CALL_OW 313
73842: ST_TO_ADDR
// if tmp2 = 6 then
73843: LD_VAR 0 9
73847: PUSH
73848: LD_INT 6
73850: EQUAL
73851: IFFALSE 73882
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73853: LD_VAR 0 9
73857: PUSH
73858: LD_INT 1
73860: ARRAY
73861: PPUSH
73862: LD_INT 112
73864: PPUSH
73865: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73869: LD_VAR 0 9
73873: PUSH
73874: LD_INT 1
73876: ARRAY
73877: PPUSH
73878: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73882: LD_EXP 91
73886: PUSH
73887: LD_VAR 0 2
73891: ARRAY
73892: PUSH
73893: LD_EXP 91
73897: PUSH
73898: LD_VAR 0 2
73902: ARRAY
73903: PUSH
73904: LD_INT 1
73906: ARRAY
73907: PPUSH
73908: CALL_OW 314
73912: NOT
73913: AND
73914: PUSH
73915: LD_EXP 91
73919: PUSH
73920: LD_VAR 0 2
73924: ARRAY
73925: PUSH
73926: LD_INT 1
73928: ARRAY
73929: PPUSH
73930: CALL_OW 310
73934: NOT
73935: AND
73936: IFFALSE 73962
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73938: LD_EXP 91
73942: PUSH
73943: LD_VAR 0 2
73947: ARRAY
73948: PUSH
73949: LD_INT 1
73951: ARRAY
73952: PPUSH
73953: LD_VAR 0 3
73957: PPUSH
73958: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73962: LD_EXP 91
73966: PUSH
73967: LD_VAR 0 2
73971: ARRAY
73972: PUSH
73973: LD_INT 1
73975: ARRAY
73976: PPUSH
73977: CALL_OW 310
73981: PUSH
73982: LD_EXP 91
73986: PUSH
73987: LD_VAR 0 2
73991: ARRAY
73992: PUSH
73993: LD_INT 1
73995: ARRAY
73996: PPUSH
73997: CALL_OW 310
74001: PPUSH
74002: CALL_OW 461
74006: PUSH
74007: LD_INT 3
74009: NONEQUAL
74010: AND
74011: IFFALSE 74032
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74013: LD_EXP 91
74017: PUSH
74018: LD_VAR 0 2
74022: ARRAY
74023: PUSH
74024: LD_INT 1
74026: ARRAY
74027: PPUSH
74028: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74032: LD_VAR 0 3
74036: PPUSH
74037: CALL_OW 461
74041: PUSH
74042: LD_INT 6
74044: EQUAL
74045: PUSH
74046: LD_VAR 0 6
74050: PUSH
74051: LD_INT 1
74053: GREATER
74054: AND
74055: IFFALSE 74207
// begin sci := [ ] ;
74057: LD_ADDR_VAR 0 8
74061: PUSH
74062: EMPTY
74063: ST_TO_ADDR
// for x in ( tmp diff j ) do
74064: LD_ADDR_VAR 0 7
74068: PUSH
74069: LD_VAR 0 6
74073: PUSH
74074: LD_VAR 0 3
74078: DIFF
74079: PUSH
74080: FOR_IN
74081: IFFALSE 74133
// begin if sci = 6 then
74083: LD_VAR 0 8
74087: PUSH
74088: LD_INT 6
74090: EQUAL
74091: IFFALSE 74095
// break ;
74093: GO 74133
// if BuildingStatus ( x ) = bs_idle then
74095: LD_VAR 0 7
74099: PPUSH
74100: CALL_OW 461
74104: PUSH
74105: LD_INT 2
74107: EQUAL
74108: IFFALSE 74131
// sci := sci ^ UnitsInside ( x ) ;
74110: LD_ADDR_VAR 0 8
74114: PUSH
74115: LD_VAR 0 8
74119: PUSH
74120: LD_VAR 0 7
74124: PPUSH
74125: CALL_OW 313
74129: ADD
74130: ST_TO_ADDR
// end ;
74131: GO 74080
74133: POP
74134: POP
// if not sci then
74135: LD_VAR 0 8
74139: NOT
74140: IFFALSE 74144
// continue ;
74142: GO 73189
// for x in sci do
74144: LD_ADDR_VAR 0 7
74148: PUSH
74149: LD_VAR 0 8
74153: PUSH
74154: FOR_IN
74155: IFFALSE 74205
// if IsInUnit ( x ) and not HasTask ( x ) then
74157: LD_VAR 0 7
74161: PPUSH
74162: CALL_OW 310
74166: PUSH
74167: LD_VAR 0 7
74171: PPUSH
74172: CALL_OW 314
74176: NOT
74177: AND
74178: IFFALSE 74203
// begin ComExitBuilding ( x ) ;
74180: LD_VAR 0 7
74184: PPUSH
74185: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74189: LD_VAR 0 7
74193: PPUSH
74194: LD_VAR 0 3
74198: PPUSH
74199: CALL_OW 180
// end ;
74203: GO 74154
74205: POP
74206: POP
// end ; end ;
74207: GO 73189
74209: POP
74210: POP
// end ;
74211: GO 73143
74213: POP
74214: POP
// end ;
74215: LD_VAR 0 1
74219: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74220: LD_INT 0
74222: PPUSH
74223: PPUSH
// if not mc_bases then
74224: LD_EXP 61
74228: NOT
74229: IFFALSE 74233
// exit ;
74231: GO 74314
// for i = 1 to mc_bases do
74233: LD_ADDR_VAR 0 2
74237: PUSH
74238: DOUBLE
74239: LD_INT 1
74241: DEC
74242: ST_TO_ADDR
74243: LD_EXP 61
74247: PUSH
74248: FOR_TO
74249: IFFALSE 74312
// if mc_mines [ i ] and mc_miners [ i ] then
74251: LD_EXP 74
74255: PUSH
74256: LD_VAR 0 2
74260: ARRAY
74261: PUSH
74262: LD_EXP 75
74266: PUSH
74267: LD_VAR 0 2
74271: ARRAY
74272: AND
74273: IFFALSE 74310
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74275: LD_EXP 75
74279: PUSH
74280: LD_VAR 0 2
74284: ARRAY
74285: PUSH
74286: LD_INT 1
74288: ARRAY
74289: PPUSH
74290: CALL_OW 255
74294: PPUSH
74295: LD_EXP 74
74299: PUSH
74300: LD_VAR 0 2
74304: ARRAY
74305: PPUSH
74306: CALL 16872 0 2
74310: GO 74248
74312: POP
74313: POP
// end ;
74314: LD_VAR 0 1
74318: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74319: LD_INT 0
74321: PPUSH
74322: PPUSH
74323: PPUSH
74324: PPUSH
74325: PPUSH
74326: PPUSH
74327: PPUSH
74328: PPUSH
// if not mc_bases or not mc_parking then
74329: LD_EXP 61
74333: NOT
74334: PUSH
74335: LD_EXP 85
74339: NOT
74340: OR
74341: IFFALSE 74345
// exit ;
74343: GO 75083
// for i = 1 to mc_bases do
74345: LD_ADDR_VAR 0 2
74349: PUSH
74350: DOUBLE
74351: LD_INT 1
74353: DEC
74354: ST_TO_ADDR
74355: LD_EXP 61
74359: PUSH
74360: FOR_TO
74361: IFFALSE 75081
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74363: LD_EXP 61
74367: PUSH
74368: LD_VAR 0 2
74372: ARRAY
74373: NOT
74374: PUSH
74375: LD_EXP 85
74379: PUSH
74380: LD_VAR 0 2
74384: ARRAY
74385: NOT
74386: OR
74387: IFFALSE 74391
// continue ;
74389: GO 74360
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74391: LD_ADDR_VAR 0 5
74395: PUSH
74396: LD_EXP 61
74400: PUSH
74401: LD_VAR 0 2
74405: ARRAY
74406: PUSH
74407: LD_INT 1
74409: ARRAY
74410: PPUSH
74411: CALL_OW 255
74415: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74416: LD_ADDR_VAR 0 6
74420: PUSH
74421: LD_EXP 61
74425: PUSH
74426: LD_VAR 0 2
74430: ARRAY
74431: PPUSH
74432: LD_INT 30
74434: PUSH
74435: LD_INT 3
74437: PUSH
74438: EMPTY
74439: LIST
74440: LIST
74441: PPUSH
74442: CALL_OW 72
74446: ST_TO_ADDR
// if not fac then
74447: LD_VAR 0 6
74451: NOT
74452: IFFALSE 74503
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74454: LD_ADDR_VAR 0 6
74458: PUSH
74459: LD_EXP 61
74463: PUSH
74464: LD_VAR 0 2
74468: ARRAY
74469: PPUSH
74470: LD_INT 2
74472: PUSH
74473: LD_INT 30
74475: PUSH
74476: LD_INT 0
74478: PUSH
74479: EMPTY
74480: LIST
74481: LIST
74482: PUSH
74483: LD_INT 30
74485: PUSH
74486: LD_INT 1
74488: PUSH
74489: EMPTY
74490: LIST
74491: LIST
74492: PUSH
74493: EMPTY
74494: LIST
74495: LIST
74496: LIST
74497: PPUSH
74498: CALL_OW 72
74502: ST_TO_ADDR
// if not fac then
74503: LD_VAR 0 6
74507: NOT
74508: IFFALSE 74512
// continue ;
74510: GO 74360
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74512: LD_ADDR_VAR 0 7
74516: PUSH
74517: LD_EXP 85
74521: PUSH
74522: LD_VAR 0 2
74526: ARRAY
74527: PPUSH
74528: LD_INT 22
74530: PUSH
74531: LD_VAR 0 5
74535: PUSH
74536: EMPTY
74537: LIST
74538: LIST
74539: PUSH
74540: LD_INT 21
74542: PUSH
74543: LD_INT 2
74545: PUSH
74546: EMPTY
74547: LIST
74548: LIST
74549: PUSH
74550: LD_INT 3
74552: PUSH
74553: LD_INT 60
74555: PUSH
74556: EMPTY
74557: LIST
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 3
74565: PUSH
74566: LD_INT 24
74568: PUSH
74569: LD_INT 1000
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: LIST
74584: LIST
74585: PPUSH
74586: CALL_OW 70
74590: ST_TO_ADDR
// for j in fac do
74591: LD_ADDR_VAR 0 3
74595: PUSH
74596: LD_VAR 0 6
74600: PUSH
74601: FOR_IN
74602: IFFALSE 74697
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74604: LD_ADDR_VAR 0 7
74608: PUSH
74609: LD_VAR 0 7
74613: PUSH
74614: LD_INT 22
74616: PUSH
74617: LD_VAR 0 5
74621: PUSH
74622: EMPTY
74623: LIST
74624: LIST
74625: PUSH
74626: LD_INT 91
74628: PUSH
74629: LD_VAR 0 3
74633: PUSH
74634: LD_INT 15
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: LIST
74641: PUSH
74642: LD_INT 21
74644: PUSH
74645: LD_INT 2
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: PUSH
74652: LD_INT 3
74654: PUSH
74655: LD_INT 60
74657: PUSH
74658: EMPTY
74659: LIST
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 3
74667: PUSH
74668: LD_INT 24
74670: PUSH
74671: LD_INT 1000
74673: PUSH
74674: EMPTY
74675: LIST
74676: LIST
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: LIST
74686: LIST
74687: LIST
74688: PPUSH
74689: CALL_OW 69
74693: UNION
74694: ST_TO_ADDR
74695: GO 74601
74697: POP
74698: POP
// if not vehs then
74699: LD_VAR 0 7
74703: NOT
74704: IFFALSE 74730
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74706: LD_ADDR_EXP 73
74710: PUSH
74711: LD_EXP 73
74715: PPUSH
74716: LD_VAR 0 2
74720: PPUSH
74721: EMPTY
74722: PPUSH
74723: CALL_OW 1
74727: ST_TO_ADDR
// continue ;
74728: GO 74360
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74730: LD_ADDR_VAR 0 8
74734: PUSH
74735: LD_EXP 61
74739: PUSH
74740: LD_VAR 0 2
74744: ARRAY
74745: PPUSH
74746: LD_INT 30
74748: PUSH
74749: LD_INT 3
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PPUSH
74756: CALL_OW 72
74760: ST_TO_ADDR
// if tmp then
74761: LD_VAR 0 8
74765: IFFALSE 74868
// begin for j in tmp do
74767: LD_ADDR_VAR 0 3
74771: PUSH
74772: LD_VAR 0 8
74776: PUSH
74777: FOR_IN
74778: IFFALSE 74866
// for k in UnitsInside ( j ) do
74780: LD_ADDR_VAR 0 4
74784: PUSH
74785: LD_VAR 0 3
74789: PPUSH
74790: CALL_OW 313
74794: PUSH
74795: FOR_IN
74796: IFFALSE 74862
// if k then
74798: LD_VAR 0 4
74802: IFFALSE 74860
// if not k in mc_repair_vehicle [ i ] then
74804: LD_VAR 0 4
74808: PUSH
74809: LD_EXP 73
74813: PUSH
74814: LD_VAR 0 2
74818: ARRAY
74819: IN
74820: NOT
74821: IFFALSE 74860
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74823: LD_ADDR_EXP 73
74827: PUSH
74828: LD_EXP 73
74832: PPUSH
74833: LD_VAR 0 2
74837: PPUSH
74838: LD_EXP 73
74842: PUSH
74843: LD_VAR 0 2
74847: ARRAY
74848: PUSH
74849: LD_VAR 0 4
74853: UNION
74854: PPUSH
74855: CALL_OW 1
74859: ST_TO_ADDR
74860: GO 74795
74862: POP
74863: POP
74864: GO 74777
74866: POP
74867: POP
// end ; if not mc_repair_vehicle [ i ] then
74868: LD_EXP 73
74872: PUSH
74873: LD_VAR 0 2
74877: ARRAY
74878: NOT
74879: IFFALSE 74883
// continue ;
74881: GO 74360
// for j in mc_repair_vehicle [ i ] do
74883: LD_ADDR_VAR 0 3
74887: PUSH
74888: LD_EXP 73
74892: PUSH
74893: LD_VAR 0 2
74897: ARRAY
74898: PUSH
74899: FOR_IN
74900: IFFALSE 75077
// begin if GetClass ( j ) <> 3 then
74902: LD_VAR 0 3
74906: PPUSH
74907: CALL_OW 257
74911: PUSH
74912: LD_INT 3
74914: NONEQUAL
74915: IFFALSE 74956
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74917: LD_ADDR_EXP 73
74921: PUSH
74922: LD_EXP 73
74926: PPUSH
74927: LD_VAR 0 2
74931: PPUSH
74932: LD_EXP 73
74936: PUSH
74937: LD_VAR 0 2
74941: ARRAY
74942: PUSH
74943: LD_VAR 0 3
74947: DIFF
74948: PPUSH
74949: CALL_OW 1
74953: ST_TO_ADDR
// continue ;
74954: GO 74899
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74956: LD_VAR 0 3
74960: PPUSH
74961: CALL_OW 311
74965: NOT
74966: PUSH
74967: LD_VAR 0 3
74971: PUSH
74972: LD_EXP 64
74976: PUSH
74977: LD_VAR 0 2
74981: ARRAY
74982: PUSH
74983: LD_INT 1
74985: ARRAY
74986: IN
74987: NOT
74988: AND
74989: PUSH
74990: LD_VAR 0 3
74994: PUSH
74995: LD_EXP 64
74999: PUSH
75000: LD_VAR 0 2
75004: ARRAY
75005: PUSH
75006: LD_INT 2
75008: ARRAY
75009: IN
75010: NOT
75011: AND
75012: IFFALSE 75075
// begin if IsInUnit ( j ) then
75014: LD_VAR 0 3
75018: PPUSH
75019: CALL_OW 310
75023: IFFALSE 75036
// ComExitBuilding ( j ) else
75025: LD_VAR 0 3
75029: PPUSH
75030: CALL_OW 122
75034: GO 75075
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75036: LD_VAR 0 3
75040: PPUSH
75041: LD_VAR 0 7
75045: PUSH
75046: LD_INT 1
75048: ARRAY
75049: PPUSH
75050: CALL 54447 0 2
75054: NOT
75055: IFFALSE 75075
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75057: LD_VAR 0 3
75061: PPUSH
75062: LD_VAR 0 7
75066: PUSH
75067: LD_INT 1
75069: ARRAY
75070: PPUSH
75071: CALL_OW 129
// end ; end ;
75075: GO 74899
75077: POP
75078: POP
// end ;
75079: GO 74360
75081: POP
75082: POP
// end ;
75083: LD_VAR 0 1
75087: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75088: LD_INT 0
75090: PPUSH
75091: PPUSH
75092: PPUSH
75093: PPUSH
75094: PPUSH
75095: PPUSH
75096: PPUSH
75097: PPUSH
75098: PPUSH
75099: PPUSH
75100: PPUSH
// if not mc_bases then
75101: LD_EXP 61
75105: NOT
75106: IFFALSE 75110
// exit ;
75108: GO 75912
// for i = 1 to mc_bases do
75110: LD_ADDR_VAR 0 2
75114: PUSH
75115: DOUBLE
75116: LD_INT 1
75118: DEC
75119: ST_TO_ADDR
75120: LD_EXP 61
75124: PUSH
75125: FOR_TO
75126: IFFALSE 75910
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75128: LD_EXP 89
75132: PUSH
75133: LD_VAR 0 2
75137: ARRAY
75138: NOT
75139: PUSH
75140: LD_EXP 64
75144: PUSH
75145: LD_VAR 0 2
75149: ARRAY
75150: PUSH
75151: LD_INT 1
75153: ARRAY
75154: OR
75155: PUSH
75156: LD_EXP 64
75160: PUSH
75161: LD_VAR 0 2
75165: ARRAY
75166: PUSH
75167: LD_INT 2
75169: ARRAY
75170: OR
75171: PUSH
75172: LD_EXP 87
75176: PUSH
75177: LD_VAR 0 2
75181: ARRAY
75182: PPUSH
75183: LD_INT 1
75185: PPUSH
75186: CALL_OW 325
75190: NOT
75191: OR
75192: PUSH
75193: LD_EXP 84
75197: PUSH
75198: LD_VAR 0 2
75202: ARRAY
75203: OR
75204: IFFALSE 75208
// continue ;
75206: GO 75125
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75208: LD_ADDR_VAR 0 8
75212: PUSH
75213: LD_EXP 61
75217: PUSH
75218: LD_VAR 0 2
75222: ARRAY
75223: PPUSH
75224: LD_INT 25
75226: PUSH
75227: LD_INT 4
75229: PUSH
75230: EMPTY
75231: LIST
75232: LIST
75233: PUSH
75234: LD_INT 50
75236: PUSH
75237: EMPTY
75238: LIST
75239: PUSH
75240: LD_INT 3
75242: PUSH
75243: LD_INT 60
75245: PUSH
75246: EMPTY
75247: LIST
75248: PUSH
75249: EMPTY
75250: LIST
75251: LIST
75252: PUSH
75253: EMPTY
75254: LIST
75255: LIST
75256: LIST
75257: PPUSH
75258: CALL_OW 72
75262: PUSH
75263: LD_EXP 65
75267: PUSH
75268: LD_VAR 0 2
75272: ARRAY
75273: DIFF
75274: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75275: LD_ADDR_VAR 0 9
75279: PUSH
75280: LD_EXP 61
75284: PUSH
75285: LD_VAR 0 2
75289: ARRAY
75290: PPUSH
75291: LD_INT 2
75293: PUSH
75294: LD_INT 30
75296: PUSH
75297: LD_INT 0
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 30
75306: PUSH
75307: LD_INT 1
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: LIST
75318: PPUSH
75319: CALL_OW 72
75323: ST_TO_ADDR
// if not tmp or not dep then
75324: LD_VAR 0 8
75328: NOT
75329: PUSH
75330: LD_VAR 0 9
75334: NOT
75335: OR
75336: IFFALSE 75340
// continue ;
75338: GO 75125
// side := GetSide ( tmp [ 1 ] ) ;
75340: LD_ADDR_VAR 0 11
75344: PUSH
75345: LD_VAR 0 8
75349: PUSH
75350: LD_INT 1
75352: ARRAY
75353: PPUSH
75354: CALL_OW 255
75358: ST_TO_ADDR
// dep := dep [ 1 ] ;
75359: LD_ADDR_VAR 0 9
75363: PUSH
75364: LD_VAR 0 9
75368: PUSH
75369: LD_INT 1
75371: ARRAY
75372: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75373: LD_ADDR_VAR 0 7
75377: PUSH
75378: LD_EXP 89
75382: PUSH
75383: LD_VAR 0 2
75387: ARRAY
75388: PPUSH
75389: LD_INT 22
75391: PUSH
75392: LD_INT 0
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: PUSH
75399: LD_INT 25
75401: PUSH
75402: LD_INT 12
75404: PUSH
75405: EMPTY
75406: LIST
75407: LIST
75408: PUSH
75409: EMPTY
75410: LIST
75411: LIST
75412: PPUSH
75413: CALL_OW 70
75417: PUSH
75418: LD_INT 22
75420: PUSH
75421: LD_INT 0
75423: PUSH
75424: EMPTY
75425: LIST
75426: LIST
75427: PUSH
75428: LD_INT 25
75430: PUSH
75431: LD_INT 12
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 91
75440: PUSH
75441: LD_VAR 0 9
75445: PUSH
75446: LD_INT 20
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: LIST
75453: PUSH
75454: EMPTY
75455: LIST
75456: LIST
75457: LIST
75458: PPUSH
75459: CALL_OW 69
75463: UNION
75464: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75465: LD_ADDR_VAR 0 10
75469: PUSH
75470: LD_EXP 89
75474: PUSH
75475: LD_VAR 0 2
75479: ARRAY
75480: PPUSH
75481: LD_INT 81
75483: PUSH
75484: LD_VAR 0 11
75488: PUSH
75489: EMPTY
75490: LIST
75491: LIST
75492: PPUSH
75493: CALL_OW 70
75497: ST_TO_ADDR
// if not apes or danger_at_area then
75498: LD_VAR 0 7
75502: NOT
75503: PUSH
75504: LD_VAR 0 10
75508: OR
75509: IFFALSE 75559
// begin if mc_taming [ i ] then
75511: LD_EXP 92
75515: PUSH
75516: LD_VAR 0 2
75520: ARRAY
75521: IFFALSE 75557
// begin MC_Reset ( i , 121 ) ;
75523: LD_VAR 0 2
75527: PPUSH
75528: LD_INT 121
75530: PPUSH
75531: CALL 60496 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75535: LD_ADDR_EXP 92
75539: PUSH
75540: LD_EXP 92
75544: PPUSH
75545: LD_VAR 0 2
75549: PPUSH
75550: EMPTY
75551: PPUSH
75552: CALL_OW 1
75556: ST_TO_ADDR
// end ; continue ;
75557: GO 75125
// end ; for j in tmp do
75559: LD_ADDR_VAR 0 3
75563: PUSH
75564: LD_VAR 0 8
75568: PUSH
75569: FOR_IN
75570: IFFALSE 75906
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75572: LD_VAR 0 3
75576: PUSH
75577: LD_EXP 92
75581: PUSH
75582: LD_VAR 0 2
75586: ARRAY
75587: IN
75588: NOT
75589: PUSH
75590: LD_EXP 92
75594: PUSH
75595: LD_VAR 0 2
75599: ARRAY
75600: PUSH
75601: LD_INT 3
75603: LESS
75604: AND
75605: IFFALSE 75663
// begin SetTag ( j , 121 ) ;
75607: LD_VAR 0 3
75611: PPUSH
75612: LD_INT 121
75614: PPUSH
75615: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75619: LD_ADDR_EXP 92
75623: PUSH
75624: LD_EXP 92
75628: PPUSH
75629: LD_VAR 0 2
75633: PUSH
75634: LD_EXP 92
75638: PUSH
75639: LD_VAR 0 2
75643: ARRAY
75644: PUSH
75645: LD_INT 1
75647: PLUS
75648: PUSH
75649: EMPTY
75650: LIST
75651: LIST
75652: PPUSH
75653: LD_VAR 0 3
75657: PPUSH
75658: CALL 20070 0 3
75662: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75663: LD_VAR 0 3
75667: PUSH
75668: LD_EXP 92
75672: PUSH
75673: LD_VAR 0 2
75677: ARRAY
75678: IN
75679: IFFALSE 75904
// begin if GetClass ( j ) <> 4 then
75681: LD_VAR 0 3
75685: PPUSH
75686: CALL_OW 257
75690: PUSH
75691: LD_INT 4
75693: NONEQUAL
75694: IFFALSE 75747
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75696: LD_ADDR_EXP 92
75700: PUSH
75701: LD_EXP 92
75705: PPUSH
75706: LD_VAR 0 2
75710: PPUSH
75711: LD_EXP 92
75715: PUSH
75716: LD_VAR 0 2
75720: ARRAY
75721: PUSH
75722: LD_VAR 0 3
75726: DIFF
75727: PPUSH
75728: CALL_OW 1
75732: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75733: LD_VAR 0 3
75737: PPUSH
75738: LD_INT 0
75740: PPUSH
75741: CALL_OW 109
// continue ;
75745: GO 75569
// end ; if IsInUnit ( j ) then
75747: LD_VAR 0 3
75751: PPUSH
75752: CALL_OW 310
75756: IFFALSE 75767
// ComExitBuilding ( j ) ;
75758: LD_VAR 0 3
75762: PPUSH
75763: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75767: LD_ADDR_VAR 0 6
75771: PUSH
75772: LD_VAR 0 7
75776: PPUSH
75777: LD_VAR 0 3
75781: PPUSH
75782: CALL_OW 74
75786: ST_TO_ADDR
// if not ape then
75787: LD_VAR 0 6
75791: NOT
75792: IFFALSE 75796
// break ;
75794: GO 75906
// x := GetX ( ape ) ;
75796: LD_ADDR_VAR 0 4
75800: PUSH
75801: LD_VAR 0 6
75805: PPUSH
75806: CALL_OW 250
75810: ST_TO_ADDR
// y := GetY ( ape ) ;
75811: LD_ADDR_VAR 0 5
75815: PUSH
75816: LD_VAR 0 6
75820: PPUSH
75821: CALL_OW 251
75825: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75826: LD_VAR 0 4
75830: PPUSH
75831: LD_VAR 0 5
75835: PPUSH
75836: CALL_OW 488
75840: NOT
75841: PUSH
75842: LD_VAR 0 11
75846: PPUSH
75847: LD_VAR 0 4
75851: PPUSH
75852: LD_VAR 0 5
75856: PPUSH
75857: LD_INT 20
75859: PPUSH
75860: CALL 20966 0 4
75864: PUSH
75865: LD_INT 4
75867: ARRAY
75868: OR
75869: IFFALSE 75873
// break ;
75871: GO 75906
// if not HasTask ( j ) then
75873: LD_VAR 0 3
75877: PPUSH
75878: CALL_OW 314
75882: NOT
75883: IFFALSE 75904
// ComTameXY ( j , x , y ) ;
75885: LD_VAR 0 3
75889: PPUSH
75890: LD_VAR 0 4
75894: PPUSH
75895: LD_VAR 0 5
75899: PPUSH
75900: CALL_OW 131
// end ; end ;
75904: GO 75569
75906: POP
75907: POP
// end ;
75908: GO 75125
75910: POP
75911: POP
// end ;
75912: LD_VAR 0 1
75916: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75917: LD_INT 0
75919: PPUSH
75920: PPUSH
75921: PPUSH
75922: PPUSH
75923: PPUSH
75924: PPUSH
75925: PPUSH
75926: PPUSH
// if not mc_bases then
75927: LD_EXP 61
75931: NOT
75932: IFFALSE 75936
// exit ;
75934: GO 76562
// for i = 1 to mc_bases do
75936: LD_ADDR_VAR 0 2
75940: PUSH
75941: DOUBLE
75942: LD_INT 1
75944: DEC
75945: ST_TO_ADDR
75946: LD_EXP 61
75950: PUSH
75951: FOR_TO
75952: IFFALSE 76560
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75954: LD_EXP 90
75958: PUSH
75959: LD_VAR 0 2
75963: ARRAY
75964: NOT
75965: PUSH
75966: LD_EXP 90
75970: PUSH
75971: LD_VAR 0 2
75975: ARRAY
75976: PPUSH
75977: LD_INT 25
75979: PUSH
75980: LD_INT 12
75982: PUSH
75983: EMPTY
75984: LIST
75985: LIST
75986: PPUSH
75987: CALL_OW 72
75991: NOT
75992: OR
75993: IFFALSE 75997
// continue ;
75995: GO 75951
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75997: LD_ADDR_VAR 0 5
76001: PUSH
76002: LD_EXP 90
76006: PUSH
76007: LD_VAR 0 2
76011: ARRAY
76012: PUSH
76013: LD_INT 1
76015: ARRAY
76016: PPUSH
76017: CALL_OW 255
76021: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76022: LD_VAR 0 5
76026: PPUSH
76027: LD_INT 2
76029: PPUSH
76030: CALL_OW 325
76034: IFFALSE 76287
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76036: LD_ADDR_VAR 0 4
76040: PUSH
76041: LD_EXP 90
76045: PUSH
76046: LD_VAR 0 2
76050: ARRAY
76051: PPUSH
76052: LD_INT 25
76054: PUSH
76055: LD_INT 16
76057: PUSH
76058: EMPTY
76059: LIST
76060: LIST
76061: PPUSH
76062: CALL_OW 72
76066: ST_TO_ADDR
// if tmp < 6 then
76067: LD_VAR 0 4
76071: PUSH
76072: LD_INT 6
76074: LESS
76075: IFFALSE 76287
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76077: LD_ADDR_VAR 0 6
76081: PUSH
76082: LD_EXP 61
76086: PUSH
76087: LD_VAR 0 2
76091: ARRAY
76092: PPUSH
76093: LD_INT 2
76095: PUSH
76096: LD_INT 30
76098: PUSH
76099: LD_INT 0
76101: PUSH
76102: EMPTY
76103: LIST
76104: LIST
76105: PUSH
76106: LD_INT 30
76108: PUSH
76109: LD_INT 1
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: LIST
76120: PPUSH
76121: CALL_OW 72
76125: ST_TO_ADDR
// if depot then
76126: LD_VAR 0 6
76130: IFFALSE 76287
// begin selected := 0 ;
76132: LD_ADDR_VAR 0 7
76136: PUSH
76137: LD_INT 0
76139: ST_TO_ADDR
// for j in depot do
76140: LD_ADDR_VAR 0 3
76144: PUSH
76145: LD_VAR 0 6
76149: PUSH
76150: FOR_IN
76151: IFFALSE 76182
// begin if UnitsInside ( j ) < 6 then
76153: LD_VAR 0 3
76157: PPUSH
76158: CALL_OW 313
76162: PUSH
76163: LD_INT 6
76165: LESS
76166: IFFALSE 76180
// begin selected := j ;
76168: LD_ADDR_VAR 0 7
76172: PUSH
76173: LD_VAR 0 3
76177: ST_TO_ADDR
// break ;
76178: GO 76182
// end ; end ;
76180: GO 76150
76182: POP
76183: POP
// if selected then
76184: LD_VAR 0 7
76188: IFFALSE 76287
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76190: LD_ADDR_VAR 0 3
76194: PUSH
76195: LD_EXP 90
76199: PUSH
76200: LD_VAR 0 2
76204: ARRAY
76205: PPUSH
76206: LD_INT 25
76208: PUSH
76209: LD_INT 12
76211: PUSH
76212: EMPTY
76213: LIST
76214: LIST
76215: PPUSH
76216: CALL_OW 72
76220: PUSH
76221: FOR_IN
76222: IFFALSE 76285
// if not HasTask ( j ) then
76224: LD_VAR 0 3
76228: PPUSH
76229: CALL_OW 314
76233: NOT
76234: IFFALSE 76283
// begin if not IsInUnit ( j ) then
76236: LD_VAR 0 3
76240: PPUSH
76241: CALL_OW 310
76245: NOT
76246: IFFALSE 76262
// ComEnterUnit ( j , selected ) ;
76248: LD_VAR 0 3
76252: PPUSH
76253: LD_VAR 0 7
76257: PPUSH
76258: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76262: LD_VAR 0 3
76266: PPUSH
76267: LD_INT 16
76269: PPUSH
76270: CALL_OW 183
// AddComExitBuilding ( j ) ;
76274: LD_VAR 0 3
76278: PPUSH
76279: CALL_OW 182
// end ;
76283: GO 76221
76285: POP
76286: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76287: LD_VAR 0 5
76291: PPUSH
76292: LD_INT 11
76294: PPUSH
76295: CALL_OW 325
76299: IFFALSE 76558
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76301: LD_ADDR_VAR 0 4
76305: PUSH
76306: LD_EXP 90
76310: PUSH
76311: LD_VAR 0 2
76315: ARRAY
76316: PPUSH
76317: LD_INT 25
76319: PUSH
76320: LD_INT 16
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: PPUSH
76327: CALL_OW 72
76331: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76332: LD_VAR 0 4
76336: PUSH
76337: LD_INT 6
76339: GREATEREQUAL
76340: PUSH
76341: LD_VAR 0 5
76345: PPUSH
76346: LD_INT 2
76348: PPUSH
76349: CALL_OW 325
76353: NOT
76354: OR
76355: IFFALSE 76558
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76357: LD_ADDR_VAR 0 8
76361: PUSH
76362: LD_EXP 61
76366: PUSH
76367: LD_VAR 0 2
76371: ARRAY
76372: PPUSH
76373: LD_INT 2
76375: PUSH
76376: LD_INT 30
76378: PUSH
76379: LD_INT 4
76381: PUSH
76382: EMPTY
76383: LIST
76384: LIST
76385: PUSH
76386: LD_INT 30
76388: PUSH
76389: LD_INT 5
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: LIST
76400: PPUSH
76401: CALL_OW 72
76405: ST_TO_ADDR
// if barracks then
76406: LD_VAR 0 8
76410: IFFALSE 76558
// begin selected := 0 ;
76412: LD_ADDR_VAR 0 7
76416: PUSH
76417: LD_INT 0
76419: ST_TO_ADDR
// for j in barracks do
76420: LD_ADDR_VAR 0 3
76424: PUSH
76425: LD_VAR 0 8
76429: PUSH
76430: FOR_IN
76431: IFFALSE 76462
// begin if UnitsInside ( j ) < 6 then
76433: LD_VAR 0 3
76437: PPUSH
76438: CALL_OW 313
76442: PUSH
76443: LD_INT 6
76445: LESS
76446: IFFALSE 76460
// begin selected := j ;
76448: LD_ADDR_VAR 0 7
76452: PUSH
76453: LD_VAR 0 3
76457: ST_TO_ADDR
// break ;
76458: GO 76462
// end ; end ;
76460: GO 76430
76462: POP
76463: POP
// if selected then
76464: LD_VAR 0 7
76468: IFFALSE 76558
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76470: LD_ADDR_VAR 0 3
76474: PUSH
76475: LD_EXP 90
76479: PUSH
76480: LD_VAR 0 2
76484: ARRAY
76485: PPUSH
76486: LD_INT 25
76488: PUSH
76489: LD_INT 12
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PPUSH
76496: CALL_OW 72
76500: PUSH
76501: FOR_IN
76502: IFFALSE 76556
// if not IsInUnit ( j ) and not HasTask ( j ) then
76504: LD_VAR 0 3
76508: PPUSH
76509: CALL_OW 310
76513: NOT
76514: PUSH
76515: LD_VAR 0 3
76519: PPUSH
76520: CALL_OW 314
76524: NOT
76525: AND
76526: IFFALSE 76554
// begin ComEnterUnit ( j , selected ) ;
76528: LD_VAR 0 3
76532: PPUSH
76533: LD_VAR 0 7
76537: PPUSH
76538: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76542: LD_VAR 0 3
76546: PPUSH
76547: LD_INT 15
76549: PPUSH
76550: CALL_OW 183
// end ;
76554: GO 76501
76556: POP
76557: POP
// end ; end ; end ; end ; end ;
76558: GO 75951
76560: POP
76561: POP
// end ;
76562: LD_VAR 0 1
76566: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76567: LD_INT 0
76569: PPUSH
76570: PPUSH
76571: PPUSH
76572: PPUSH
// if not mc_bases then
76573: LD_EXP 61
76577: NOT
76578: IFFALSE 76582
// exit ;
76580: GO 76760
// for i = 1 to mc_bases do
76582: LD_ADDR_VAR 0 2
76586: PUSH
76587: DOUBLE
76588: LD_INT 1
76590: DEC
76591: ST_TO_ADDR
76592: LD_EXP 61
76596: PUSH
76597: FOR_TO
76598: IFFALSE 76758
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76600: LD_ADDR_VAR 0 4
76604: PUSH
76605: LD_EXP 61
76609: PUSH
76610: LD_VAR 0 2
76614: ARRAY
76615: PPUSH
76616: LD_INT 25
76618: PUSH
76619: LD_INT 9
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PPUSH
76626: CALL_OW 72
76630: ST_TO_ADDR
// if not tmp then
76631: LD_VAR 0 4
76635: NOT
76636: IFFALSE 76640
// continue ;
76638: GO 76597
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76640: LD_EXP 87
76644: PUSH
76645: LD_VAR 0 2
76649: ARRAY
76650: PPUSH
76651: LD_INT 29
76653: PPUSH
76654: CALL_OW 325
76658: NOT
76659: PUSH
76660: LD_EXP 87
76664: PUSH
76665: LD_VAR 0 2
76669: ARRAY
76670: PPUSH
76671: LD_INT 28
76673: PPUSH
76674: CALL_OW 325
76678: NOT
76679: AND
76680: IFFALSE 76684
// continue ;
76682: GO 76597
// for j in tmp do
76684: LD_ADDR_VAR 0 3
76688: PUSH
76689: LD_VAR 0 4
76693: PUSH
76694: FOR_IN
76695: IFFALSE 76754
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76697: LD_VAR 0 3
76701: PUSH
76702: LD_EXP 64
76706: PUSH
76707: LD_VAR 0 2
76711: ARRAY
76712: PUSH
76713: LD_INT 1
76715: ARRAY
76716: IN
76717: NOT
76718: PUSH
76719: LD_VAR 0 3
76723: PUSH
76724: LD_EXP 64
76728: PUSH
76729: LD_VAR 0 2
76733: ARRAY
76734: PUSH
76735: LD_INT 2
76737: ARRAY
76738: IN
76739: NOT
76740: AND
76741: IFFALSE 76752
// ComSpaceTimeShoot ( j ) ;
76743: LD_VAR 0 3
76747: PPUSH
76748: CALL 15880 0 1
76752: GO 76694
76754: POP
76755: POP
// end ;
76756: GO 76597
76758: POP
76759: POP
// end ;
76760: LD_VAR 0 1
76764: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76765: LD_INT 0
76767: PPUSH
76768: PPUSH
76769: PPUSH
76770: PPUSH
76771: PPUSH
76772: PPUSH
76773: PPUSH
76774: PPUSH
76775: PPUSH
// if not mc_bases then
76776: LD_EXP 61
76780: NOT
76781: IFFALSE 76785
// exit ;
76783: GO 77407
// for i = 1 to mc_bases do
76785: LD_ADDR_VAR 0 2
76789: PUSH
76790: DOUBLE
76791: LD_INT 1
76793: DEC
76794: ST_TO_ADDR
76795: LD_EXP 61
76799: PUSH
76800: FOR_TO
76801: IFFALSE 77405
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76803: LD_EXP 96
76807: PUSH
76808: LD_VAR 0 2
76812: ARRAY
76813: NOT
76814: PUSH
76815: LD_INT 38
76817: PPUSH
76818: LD_EXP 87
76822: PUSH
76823: LD_VAR 0 2
76827: ARRAY
76828: PPUSH
76829: CALL_OW 321
76833: PUSH
76834: LD_INT 2
76836: NONEQUAL
76837: OR
76838: IFFALSE 76842
// continue ;
76840: GO 76800
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76842: LD_ADDR_VAR 0 8
76846: PUSH
76847: LD_EXP 61
76851: PUSH
76852: LD_VAR 0 2
76856: ARRAY
76857: PPUSH
76858: LD_INT 30
76860: PUSH
76861: LD_INT 34
76863: PUSH
76864: EMPTY
76865: LIST
76866: LIST
76867: PPUSH
76868: CALL_OW 72
76872: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76873: LD_ADDR_VAR 0 9
76877: PUSH
76878: LD_EXP 61
76882: PUSH
76883: LD_VAR 0 2
76887: ARRAY
76888: PPUSH
76889: LD_INT 25
76891: PUSH
76892: LD_INT 4
76894: PUSH
76895: EMPTY
76896: LIST
76897: LIST
76898: PPUSH
76899: CALL_OW 72
76903: PPUSH
76904: LD_INT 0
76906: PPUSH
76907: CALL 49956 0 2
76911: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76912: LD_VAR 0 9
76916: NOT
76917: PUSH
76918: LD_VAR 0 8
76922: NOT
76923: OR
76924: PUSH
76925: LD_EXP 61
76929: PUSH
76930: LD_VAR 0 2
76934: ARRAY
76935: PPUSH
76936: LD_INT 124
76938: PPUSH
76939: CALL 49956 0 2
76943: OR
76944: IFFALSE 76948
// continue ;
76946: GO 76800
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76948: LD_EXP 97
76952: PUSH
76953: LD_VAR 0 2
76957: ARRAY
76958: PUSH
76959: LD_EXP 96
76963: PUSH
76964: LD_VAR 0 2
76968: ARRAY
76969: LESS
76970: PUSH
76971: LD_EXP 97
76975: PUSH
76976: LD_VAR 0 2
76980: ARRAY
76981: PUSH
76982: LD_VAR 0 8
76986: LESS
76987: AND
76988: IFFALSE 77403
// begin tmp := sci [ 1 ] ;
76990: LD_ADDR_VAR 0 7
76994: PUSH
76995: LD_VAR 0 9
76999: PUSH
77000: LD_INT 1
77002: ARRAY
77003: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77004: LD_VAR 0 7
77008: PPUSH
77009: LD_INT 124
77011: PPUSH
77012: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77016: LD_ADDR_VAR 0 3
77020: PUSH
77021: DOUBLE
77022: LD_EXP 96
77026: PUSH
77027: LD_VAR 0 2
77031: ARRAY
77032: INC
77033: ST_TO_ADDR
77034: LD_EXP 96
77038: PUSH
77039: LD_VAR 0 2
77043: ARRAY
77044: PUSH
77045: FOR_DOWNTO
77046: IFFALSE 77389
// begin if IsInUnit ( tmp ) then
77048: LD_VAR 0 7
77052: PPUSH
77053: CALL_OW 310
77057: IFFALSE 77068
// ComExitBuilding ( tmp ) ;
77059: LD_VAR 0 7
77063: PPUSH
77064: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77068: LD_INT 35
77070: PPUSH
77071: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77075: LD_VAR 0 7
77079: PPUSH
77080: CALL_OW 310
77084: NOT
77085: PUSH
77086: LD_VAR 0 7
77090: PPUSH
77091: CALL_OW 314
77095: NOT
77096: AND
77097: IFFALSE 77068
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77099: LD_ADDR_VAR 0 6
77103: PUSH
77104: LD_VAR 0 7
77108: PPUSH
77109: CALL_OW 250
77113: PUSH
77114: LD_VAR 0 7
77118: PPUSH
77119: CALL_OW 251
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77128: LD_INT 35
77130: PPUSH
77131: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77135: LD_ADDR_VAR 0 4
77139: PUSH
77140: LD_EXP 96
77144: PUSH
77145: LD_VAR 0 2
77149: ARRAY
77150: PUSH
77151: LD_VAR 0 3
77155: ARRAY
77156: PUSH
77157: LD_INT 1
77159: ARRAY
77160: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77161: LD_ADDR_VAR 0 5
77165: PUSH
77166: LD_EXP 96
77170: PUSH
77171: LD_VAR 0 2
77175: ARRAY
77176: PUSH
77177: LD_VAR 0 3
77181: ARRAY
77182: PUSH
77183: LD_INT 2
77185: ARRAY
77186: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77187: LD_VAR 0 7
77191: PPUSH
77192: LD_INT 10
77194: PPUSH
77195: CALL 22667 0 2
77199: PUSH
77200: LD_INT 4
77202: ARRAY
77203: IFFALSE 77241
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77205: LD_VAR 0 7
77209: PPUSH
77210: LD_VAR 0 6
77214: PUSH
77215: LD_INT 1
77217: ARRAY
77218: PPUSH
77219: LD_VAR 0 6
77223: PUSH
77224: LD_INT 2
77226: ARRAY
77227: PPUSH
77228: CALL_OW 111
// wait ( 0 0$10 ) ;
77232: LD_INT 350
77234: PPUSH
77235: CALL_OW 67
// end else
77239: GO 77267
// begin ComMoveXY ( tmp , x , y ) ;
77241: LD_VAR 0 7
77245: PPUSH
77246: LD_VAR 0 4
77250: PPUSH
77251: LD_VAR 0 5
77255: PPUSH
77256: CALL_OW 111
// wait ( 0 0$3 ) ;
77260: LD_INT 105
77262: PPUSH
77263: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77267: LD_VAR 0 7
77271: PPUSH
77272: LD_VAR 0 4
77276: PPUSH
77277: LD_VAR 0 5
77281: PPUSH
77282: CALL_OW 307
77286: IFFALSE 77128
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77288: LD_VAR 0 7
77292: PPUSH
77293: LD_VAR 0 4
77297: PPUSH
77298: LD_VAR 0 5
77302: PPUSH
77303: LD_VAR 0 8
77307: PUSH
77308: LD_VAR 0 3
77312: ARRAY
77313: PPUSH
77314: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77318: LD_INT 35
77320: PPUSH
77321: CALL_OW 67
// until not HasTask ( tmp ) ;
77325: LD_VAR 0 7
77329: PPUSH
77330: CALL_OW 314
77334: NOT
77335: IFFALSE 77318
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77337: LD_ADDR_EXP 97
77341: PUSH
77342: LD_EXP 97
77346: PPUSH
77347: LD_VAR 0 2
77351: PUSH
77352: LD_EXP 97
77356: PUSH
77357: LD_VAR 0 2
77361: ARRAY
77362: PUSH
77363: LD_INT 1
77365: PLUS
77366: PUSH
77367: EMPTY
77368: LIST
77369: LIST
77370: PPUSH
77371: LD_VAR 0 8
77375: PUSH
77376: LD_VAR 0 3
77380: ARRAY
77381: PPUSH
77382: CALL 20070 0 3
77386: ST_TO_ADDR
// end ;
77387: GO 77045
77389: POP
77390: POP
// MC_Reset ( i , 124 ) ;
77391: LD_VAR 0 2
77395: PPUSH
77396: LD_INT 124
77398: PPUSH
77399: CALL 60496 0 2
// end ; end ;
77403: GO 76800
77405: POP
77406: POP
// end ;
77407: LD_VAR 0 1
77411: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77412: LD_INT 0
77414: PPUSH
77415: PPUSH
77416: PPUSH
// if not mc_bases then
77417: LD_EXP 61
77421: NOT
77422: IFFALSE 77426
// exit ;
77424: GO 78032
// for i = 1 to mc_bases do
77426: LD_ADDR_VAR 0 2
77430: PUSH
77431: DOUBLE
77432: LD_INT 1
77434: DEC
77435: ST_TO_ADDR
77436: LD_EXP 61
77440: PUSH
77441: FOR_TO
77442: IFFALSE 78030
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77444: LD_ADDR_VAR 0 3
77448: PUSH
77449: LD_EXP 61
77453: PUSH
77454: LD_VAR 0 2
77458: ARRAY
77459: PPUSH
77460: LD_INT 25
77462: PUSH
77463: LD_INT 4
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PPUSH
77470: CALL_OW 72
77474: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77475: LD_VAR 0 3
77479: NOT
77480: PUSH
77481: LD_EXP 98
77485: PUSH
77486: LD_VAR 0 2
77490: ARRAY
77491: NOT
77492: OR
77493: PUSH
77494: LD_EXP 61
77498: PUSH
77499: LD_VAR 0 2
77503: ARRAY
77504: PPUSH
77505: LD_INT 2
77507: PUSH
77508: LD_INT 30
77510: PUSH
77511: LD_INT 0
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: PUSH
77518: LD_INT 30
77520: PUSH
77521: LD_INT 1
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: EMPTY
77529: LIST
77530: LIST
77531: LIST
77532: PPUSH
77533: CALL_OW 72
77537: NOT
77538: OR
77539: IFFALSE 77589
// begin if mc_deposits_finder [ i ] then
77541: LD_EXP 99
77545: PUSH
77546: LD_VAR 0 2
77550: ARRAY
77551: IFFALSE 77587
// begin MC_Reset ( i , 125 ) ;
77553: LD_VAR 0 2
77557: PPUSH
77558: LD_INT 125
77560: PPUSH
77561: CALL 60496 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77565: LD_ADDR_EXP 99
77569: PUSH
77570: LD_EXP 99
77574: PPUSH
77575: LD_VAR 0 2
77579: PPUSH
77580: EMPTY
77581: PPUSH
77582: CALL_OW 1
77586: ST_TO_ADDR
// end ; continue ;
77587: GO 77441
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77589: LD_EXP 98
77593: PUSH
77594: LD_VAR 0 2
77598: ARRAY
77599: PUSH
77600: LD_INT 1
77602: ARRAY
77603: PUSH
77604: LD_INT 3
77606: ARRAY
77607: PUSH
77608: LD_INT 1
77610: EQUAL
77611: PUSH
77612: LD_INT 20
77614: PPUSH
77615: LD_EXP 87
77619: PUSH
77620: LD_VAR 0 2
77624: ARRAY
77625: PPUSH
77626: CALL_OW 321
77630: PUSH
77631: LD_INT 2
77633: NONEQUAL
77634: AND
77635: IFFALSE 77685
// begin if mc_deposits_finder [ i ] then
77637: LD_EXP 99
77641: PUSH
77642: LD_VAR 0 2
77646: ARRAY
77647: IFFALSE 77683
// begin MC_Reset ( i , 125 ) ;
77649: LD_VAR 0 2
77653: PPUSH
77654: LD_INT 125
77656: PPUSH
77657: CALL 60496 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77661: LD_ADDR_EXP 99
77665: PUSH
77666: LD_EXP 99
77670: PPUSH
77671: LD_VAR 0 2
77675: PPUSH
77676: EMPTY
77677: PPUSH
77678: CALL_OW 1
77682: ST_TO_ADDR
// end ; continue ;
77683: GO 77441
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77685: LD_EXP 98
77689: PUSH
77690: LD_VAR 0 2
77694: ARRAY
77695: PUSH
77696: LD_INT 1
77698: ARRAY
77699: PUSH
77700: LD_INT 1
77702: ARRAY
77703: PPUSH
77704: LD_EXP 98
77708: PUSH
77709: LD_VAR 0 2
77713: ARRAY
77714: PUSH
77715: LD_INT 1
77717: ARRAY
77718: PUSH
77719: LD_INT 2
77721: ARRAY
77722: PPUSH
77723: LD_EXP 87
77727: PUSH
77728: LD_VAR 0 2
77732: ARRAY
77733: PPUSH
77734: CALL_OW 440
77738: IFFALSE 77781
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77740: LD_ADDR_EXP 98
77744: PUSH
77745: LD_EXP 98
77749: PPUSH
77750: LD_VAR 0 2
77754: PPUSH
77755: LD_EXP 98
77759: PUSH
77760: LD_VAR 0 2
77764: ARRAY
77765: PPUSH
77766: LD_INT 1
77768: PPUSH
77769: CALL_OW 3
77773: PPUSH
77774: CALL_OW 1
77778: ST_TO_ADDR
77779: GO 78028
// begin if not mc_deposits_finder [ i ] then
77781: LD_EXP 99
77785: PUSH
77786: LD_VAR 0 2
77790: ARRAY
77791: NOT
77792: IFFALSE 77844
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77794: LD_ADDR_EXP 99
77798: PUSH
77799: LD_EXP 99
77803: PPUSH
77804: LD_VAR 0 2
77808: PPUSH
77809: LD_VAR 0 3
77813: PUSH
77814: LD_INT 1
77816: ARRAY
77817: PUSH
77818: EMPTY
77819: LIST
77820: PPUSH
77821: CALL_OW 1
77825: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77826: LD_VAR 0 3
77830: PUSH
77831: LD_INT 1
77833: ARRAY
77834: PPUSH
77835: LD_INT 125
77837: PPUSH
77838: CALL_OW 109
// end else
77842: GO 78028
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77844: LD_EXP 99
77848: PUSH
77849: LD_VAR 0 2
77853: ARRAY
77854: PUSH
77855: LD_INT 1
77857: ARRAY
77858: PPUSH
77859: CALL_OW 310
77863: IFFALSE 77886
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77865: LD_EXP 99
77869: PUSH
77870: LD_VAR 0 2
77874: ARRAY
77875: PUSH
77876: LD_INT 1
77878: ARRAY
77879: PPUSH
77880: CALL_OW 122
77884: GO 78028
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77886: LD_EXP 99
77890: PUSH
77891: LD_VAR 0 2
77895: ARRAY
77896: PUSH
77897: LD_INT 1
77899: ARRAY
77900: PPUSH
77901: CALL_OW 314
77905: NOT
77906: PUSH
77907: LD_EXP 99
77911: PUSH
77912: LD_VAR 0 2
77916: ARRAY
77917: PUSH
77918: LD_INT 1
77920: ARRAY
77921: PPUSH
77922: LD_EXP 98
77926: PUSH
77927: LD_VAR 0 2
77931: ARRAY
77932: PUSH
77933: LD_INT 1
77935: ARRAY
77936: PUSH
77937: LD_INT 1
77939: ARRAY
77940: PPUSH
77941: LD_EXP 98
77945: PUSH
77946: LD_VAR 0 2
77950: ARRAY
77951: PUSH
77952: LD_INT 1
77954: ARRAY
77955: PUSH
77956: LD_INT 2
77958: ARRAY
77959: PPUSH
77960: CALL_OW 297
77964: PUSH
77965: LD_INT 6
77967: GREATER
77968: AND
77969: IFFALSE 78028
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77971: LD_EXP 99
77975: PUSH
77976: LD_VAR 0 2
77980: ARRAY
77981: PUSH
77982: LD_INT 1
77984: ARRAY
77985: PPUSH
77986: LD_EXP 98
77990: PUSH
77991: LD_VAR 0 2
77995: ARRAY
77996: PUSH
77997: LD_INT 1
77999: ARRAY
78000: PUSH
78001: LD_INT 1
78003: ARRAY
78004: PPUSH
78005: LD_EXP 98
78009: PUSH
78010: LD_VAR 0 2
78014: ARRAY
78015: PUSH
78016: LD_INT 1
78018: ARRAY
78019: PUSH
78020: LD_INT 2
78022: ARRAY
78023: PPUSH
78024: CALL_OW 111
// end ; end ; end ;
78028: GO 77441
78030: POP
78031: POP
// end ;
78032: LD_VAR 0 1
78036: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78037: LD_INT 0
78039: PPUSH
78040: PPUSH
78041: PPUSH
78042: PPUSH
78043: PPUSH
78044: PPUSH
78045: PPUSH
78046: PPUSH
78047: PPUSH
78048: PPUSH
78049: PPUSH
// if not mc_bases then
78050: LD_EXP 61
78054: NOT
78055: IFFALSE 78059
// exit ;
78057: GO 78999
// for i = 1 to mc_bases do
78059: LD_ADDR_VAR 0 2
78063: PUSH
78064: DOUBLE
78065: LD_INT 1
78067: DEC
78068: ST_TO_ADDR
78069: LD_EXP 61
78073: PUSH
78074: FOR_TO
78075: IFFALSE 78997
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78077: LD_EXP 61
78081: PUSH
78082: LD_VAR 0 2
78086: ARRAY
78087: NOT
78088: PUSH
78089: LD_EXP 84
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: OR
78100: IFFALSE 78104
// continue ;
78102: GO 78074
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78104: LD_ADDR_VAR 0 7
78108: PUSH
78109: LD_EXP 61
78113: PUSH
78114: LD_VAR 0 2
78118: ARRAY
78119: PUSH
78120: LD_INT 1
78122: ARRAY
78123: PPUSH
78124: CALL_OW 248
78128: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78129: LD_VAR 0 7
78133: PUSH
78134: LD_INT 3
78136: EQUAL
78137: PUSH
78138: LD_EXP 80
78142: PUSH
78143: LD_VAR 0 2
78147: ARRAY
78148: PUSH
78149: LD_EXP 83
78153: PUSH
78154: LD_VAR 0 2
78158: ARRAY
78159: UNION
78160: PPUSH
78161: LD_INT 33
78163: PUSH
78164: LD_INT 2
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PPUSH
78171: CALL_OW 72
78175: NOT
78176: OR
78177: IFFALSE 78181
// continue ;
78179: GO 78074
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78181: LD_ADDR_VAR 0 9
78185: PUSH
78186: LD_EXP 61
78190: PUSH
78191: LD_VAR 0 2
78195: ARRAY
78196: PPUSH
78197: LD_INT 30
78199: PUSH
78200: LD_INT 36
78202: PUSH
78203: EMPTY
78204: LIST
78205: LIST
78206: PPUSH
78207: CALL_OW 72
78211: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78212: LD_ADDR_VAR 0 10
78216: PUSH
78217: LD_EXP 80
78221: PUSH
78222: LD_VAR 0 2
78226: ARRAY
78227: PPUSH
78228: LD_INT 34
78230: PUSH
78231: LD_INT 31
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PPUSH
78238: CALL_OW 72
78242: ST_TO_ADDR
// if not cts and not mcts then
78243: LD_VAR 0 9
78247: NOT
78248: PUSH
78249: LD_VAR 0 10
78253: NOT
78254: AND
78255: IFFALSE 78259
// continue ;
78257: GO 78074
// x := cts ;
78259: LD_ADDR_VAR 0 11
78263: PUSH
78264: LD_VAR 0 9
78268: ST_TO_ADDR
// if not x then
78269: LD_VAR 0 11
78273: NOT
78274: IFFALSE 78286
// x := mcts ;
78276: LD_ADDR_VAR 0 11
78280: PUSH
78281: LD_VAR 0 10
78285: ST_TO_ADDR
// if not x then
78286: LD_VAR 0 11
78290: NOT
78291: IFFALSE 78295
// continue ;
78293: GO 78074
// if mc_remote_driver [ i ] then
78295: LD_EXP 101
78299: PUSH
78300: LD_VAR 0 2
78304: ARRAY
78305: IFFALSE 78692
// for j in mc_remote_driver [ i ] do
78307: LD_ADDR_VAR 0 3
78311: PUSH
78312: LD_EXP 101
78316: PUSH
78317: LD_VAR 0 2
78321: ARRAY
78322: PUSH
78323: FOR_IN
78324: IFFALSE 78690
// begin if GetClass ( j ) <> 3 then
78326: LD_VAR 0 3
78330: PPUSH
78331: CALL_OW 257
78335: PUSH
78336: LD_INT 3
78338: NONEQUAL
78339: IFFALSE 78392
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78341: LD_ADDR_EXP 101
78345: PUSH
78346: LD_EXP 101
78350: PPUSH
78351: LD_VAR 0 2
78355: PPUSH
78356: LD_EXP 101
78360: PUSH
78361: LD_VAR 0 2
78365: ARRAY
78366: PUSH
78367: LD_VAR 0 3
78371: DIFF
78372: PPUSH
78373: CALL_OW 1
78377: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78378: LD_VAR 0 3
78382: PPUSH
78383: LD_INT 0
78385: PPUSH
78386: CALL_OW 109
// continue ;
78390: GO 78323
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78392: LD_EXP 80
78396: PUSH
78397: LD_VAR 0 2
78401: ARRAY
78402: PPUSH
78403: LD_INT 34
78405: PUSH
78406: LD_INT 31
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: PUSH
78413: LD_INT 58
78415: PUSH
78416: EMPTY
78417: LIST
78418: PUSH
78419: EMPTY
78420: LIST
78421: LIST
78422: PPUSH
78423: CALL_OW 72
78427: PUSH
78428: LD_VAR 0 3
78432: PPUSH
78433: CALL 49991 0 1
78437: NOT
78438: AND
78439: IFFALSE 78510
// begin if IsInUnit ( j ) then
78441: LD_VAR 0 3
78445: PPUSH
78446: CALL_OW 310
78450: IFFALSE 78461
// ComExitBuilding ( j ) ;
78452: LD_VAR 0 3
78456: PPUSH
78457: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78461: LD_VAR 0 3
78465: PPUSH
78466: LD_EXP 80
78470: PUSH
78471: LD_VAR 0 2
78475: ARRAY
78476: PPUSH
78477: LD_INT 34
78479: PUSH
78480: LD_INT 31
78482: PUSH
78483: EMPTY
78484: LIST
78485: LIST
78486: PUSH
78487: LD_INT 58
78489: PUSH
78490: EMPTY
78491: LIST
78492: PUSH
78493: EMPTY
78494: LIST
78495: LIST
78496: PPUSH
78497: CALL_OW 72
78501: PUSH
78502: LD_INT 1
78504: ARRAY
78505: PPUSH
78506: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78510: LD_VAR 0 3
78514: PPUSH
78515: CALL_OW 310
78519: NOT
78520: PUSH
78521: LD_VAR 0 3
78525: PPUSH
78526: CALL_OW 310
78530: PPUSH
78531: CALL_OW 266
78535: PUSH
78536: LD_INT 36
78538: NONEQUAL
78539: PUSH
78540: LD_VAR 0 3
78544: PPUSH
78545: CALL 49991 0 1
78549: NOT
78550: AND
78551: OR
78552: IFFALSE 78688
// begin if IsInUnit ( j ) then
78554: LD_VAR 0 3
78558: PPUSH
78559: CALL_OW 310
78563: IFFALSE 78574
// ComExitBuilding ( j ) ;
78565: LD_VAR 0 3
78569: PPUSH
78570: CALL_OW 122
// ct := 0 ;
78574: LD_ADDR_VAR 0 8
78578: PUSH
78579: LD_INT 0
78581: ST_TO_ADDR
// for k in x do
78582: LD_ADDR_VAR 0 4
78586: PUSH
78587: LD_VAR 0 11
78591: PUSH
78592: FOR_IN
78593: IFFALSE 78666
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78595: LD_VAR 0 4
78599: PPUSH
78600: CALL_OW 264
78604: PUSH
78605: LD_INT 31
78607: EQUAL
78608: PUSH
78609: LD_VAR 0 4
78613: PPUSH
78614: CALL_OW 311
78618: NOT
78619: AND
78620: PUSH
78621: LD_VAR 0 4
78625: PPUSH
78626: CALL_OW 266
78630: PUSH
78631: LD_INT 36
78633: EQUAL
78634: PUSH
78635: LD_VAR 0 4
78639: PPUSH
78640: CALL_OW 313
78644: PUSH
78645: LD_INT 3
78647: LESS
78648: AND
78649: OR
78650: IFFALSE 78664
// begin ct := k ;
78652: LD_ADDR_VAR 0 8
78656: PUSH
78657: LD_VAR 0 4
78661: ST_TO_ADDR
// break ;
78662: GO 78666
// end ;
78664: GO 78592
78666: POP
78667: POP
// if ct then
78668: LD_VAR 0 8
78672: IFFALSE 78688
// ComEnterUnit ( j , ct ) ;
78674: LD_VAR 0 3
78678: PPUSH
78679: LD_VAR 0 8
78683: PPUSH
78684: CALL_OW 120
// end ; end ;
78688: GO 78323
78690: POP
78691: POP
// places := 0 ;
78692: LD_ADDR_VAR 0 5
78696: PUSH
78697: LD_INT 0
78699: ST_TO_ADDR
// for j = 1 to x do
78700: LD_ADDR_VAR 0 3
78704: PUSH
78705: DOUBLE
78706: LD_INT 1
78708: DEC
78709: ST_TO_ADDR
78710: LD_VAR 0 11
78714: PUSH
78715: FOR_TO
78716: IFFALSE 78792
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78718: LD_VAR 0 11
78722: PUSH
78723: LD_VAR 0 3
78727: ARRAY
78728: PPUSH
78729: CALL_OW 264
78733: PUSH
78734: LD_INT 31
78736: EQUAL
78737: IFFALSE 78755
// places := places + 1 else
78739: LD_ADDR_VAR 0 5
78743: PUSH
78744: LD_VAR 0 5
78748: PUSH
78749: LD_INT 1
78751: PLUS
78752: ST_TO_ADDR
78753: GO 78790
// if GetBType ( x [ j ] ) = b_control_tower then
78755: LD_VAR 0 11
78759: PUSH
78760: LD_VAR 0 3
78764: ARRAY
78765: PPUSH
78766: CALL_OW 266
78770: PUSH
78771: LD_INT 36
78773: EQUAL
78774: IFFALSE 78790
// places := places + 3 ;
78776: LD_ADDR_VAR 0 5
78780: PUSH
78781: LD_VAR 0 5
78785: PUSH
78786: LD_INT 3
78788: PLUS
78789: ST_TO_ADDR
78790: GO 78715
78792: POP
78793: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78794: LD_VAR 0 5
78798: PUSH
78799: LD_INT 0
78801: EQUAL
78802: PUSH
78803: LD_VAR 0 5
78807: PUSH
78808: LD_EXP 101
78812: PUSH
78813: LD_VAR 0 2
78817: ARRAY
78818: LESSEQUAL
78819: OR
78820: IFFALSE 78824
// continue ;
78822: GO 78074
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78824: LD_ADDR_VAR 0 6
78828: PUSH
78829: LD_EXP 61
78833: PUSH
78834: LD_VAR 0 2
78838: ARRAY
78839: PPUSH
78840: LD_INT 25
78842: PUSH
78843: LD_INT 3
78845: PUSH
78846: EMPTY
78847: LIST
78848: LIST
78849: PPUSH
78850: CALL_OW 72
78854: PUSH
78855: LD_EXP 101
78859: PUSH
78860: LD_VAR 0 2
78864: ARRAY
78865: DIFF
78866: PPUSH
78867: LD_INT 3
78869: PPUSH
78870: CALL 50891 0 2
78874: ST_TO_ADDR
// for j in tmp do
78875: LD_ADDR_VAR 0 3
78879: PUSH
78880: LD_VAR 0 6
78884: PUSH
78885: FOR_IN
78886: IFFALSE 78921
// if GetTag ( j ) > 0 then
78888: LD_VAR 0 3
78892: PPUSH
78893: CALL_OW 110
78897: PUSH
78898: LD_INT 0
78900: GREATER
78901: IFFALSE 78919
// tmp := tmp diff j ;
78903: LD_ADDR_VAR 0 6
78907: PUSH
78908: LD_VAR 0 6
78912: PUSH
78913: LD_VAR 0 3
78917: DIFF
78918: ST_TO_ADDR
78919: GO 78885
78921: POP
78922: POP
// if not tmp then
78923: LD_VAR 0 6
78927: NOT
78928: IFFALSE 78932
// continue ;
78930: GO 78074
// if places then
78932: LD_VAR 0 5
78936: IFFALSE 78995
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78938: LD_ADDR_EXP 101
78942: PUSH
78943: LD_EXP 101
78947: PPUSH
78948: LD_VAR 0 2
78952: PPUSH
78953: LD_EXP 101
78957: PUSH
78958: LD_VAR 0 2
78962: ARRAY
78963: PUSH
78964: LD_VAR 0 6
78968: PUSH
78969: LD_INT 1
78971: ARRAY
78972: UNION
78973: PPUSH
78974: CALL_OW 1
78978: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78979: LD_VAR 0 6
78983: PUSH
78984: LD_INT 1
78986: ARRAY
78987: PPUSH
78988: LD_INT 126
78990: PPUSH
78991: CALL_OW 109
// end ; end ;
78995: GO 78074
78997: POP
78998: POP
// end ;
78999: LD_VAR 0 1
79003: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79004: LD_INT 0
79006: PPUSH
79007: PPUSH
79008: PPUSH
79009: PPUSH
79010: PPUSH
79011: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79012: LD_VAR 0 1
79016: NOT
79017: PUSH
79018: LD_VAR 0 2
79022: NOT
79023: OR
79024: PUSH
79025: LD_VAR 0 3
79029: NOT
79030: OR
79031: PUSH
79032: LD_VAR 0 4
79036: PUSH
79037: LD_INT 1
79039: PUSH
79040: LD_INT 2
79042: PUSH
79043: LD_INT 3
79045: PUSH
79046: LD_INT 4
79048: PUSH
79049: LD_INT 5
79051: PUSH
79052: LD_INT 8
79054: PUSH
79055: LD_INT 9
79057: PUSH
79058: LD_INT 15
79060: PUSH
79061: LD_INT 16
79063: PUSH
79064: EMPTY
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: IN
79075: NOT
79076: OR
79077: IFFALSE 79081
// exit ;
79079: GO 79981
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79081: LD_ADDR_VAR 0 2
79085: PUSH
79086: LD_VAR 0 2
79090: PPUSH
79091: LD_INT 21
79093: PUSH
79094: LD_INT 3
79096: PUSH
79097: EMPTY
79098: LIST
79099: LIST
79100: PUSH
79101: LD_INT 24
79103: PUSH
79104: LD_INT 250
79106: PUSH
79107: EMPTY
79108: LIST
79109: LIST
79110: PUSH
79111: EMPTY
79112: LIST
79113: LIST
79114: PPUSH
79115: CALL_OW 72
79119: ST_TO_ADDR
// case class of 1 , 15 :
79120: LD_VAR 0 4
79124: PUSH
79125: LD_INT 1
79127: DOUBLE
79128: EQUAL
79129: IFTRUE 79139
79131: LD_INT 15
79133: DOUBLE
79134: EQUAL
79135: IFTRUE 79139
79137: GO 79224
79139: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79140: LD_ADDR_VAR 0 8
79144: PUSH
79145: LD_VAR 0 2
79149: PPUSH
79150: LD_INT 2
79152: PUSH
79153: LD_INT 30
79155: PUSH
79156: LD_INT 32
79158: PUSH
79159: EMPTY
79160: LIST
79161: LIST
79162: PUSH
79163: LD_INT 30
79165: PUSH
79166: LD_INT 31
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: LIST
79177: PPUSH
79178: CALL_OW 72
79182: PUSH
79183: LD_VAR 0 2
79187: PPUSH
79188: LD_INT 2
79190: PUSH
79191: LD_INT 30
79193: PUSH
79194: LD_INT 4
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PUSH
79201: LD_INT 30
79203: PUSH
79204: LD_INT 5
79206: PUSH
79207: EMPTY
79208: LIST
79209: LIST
79210: PUSH
79211: EMPTY
79212: LIST
79213: LIST
79214: LIST
79215: PPUSH
79216: CALL_OW 72
79220: ADD
79221: ST_TO_ADDR
79222: GO 79470
79224: LD_INT 2
79226: DOUBLE
79227: EQUAL
79228: IFTRUE 79238
79230: LD_INT 16
79232: DOUBLE
79233: EQUAL
79234: IFTRUE 79238
79236: GO 79284
79238: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79239: LD_ADDR_VAR 0 8
79243: PUSH
79244: LD_VAR 0 2
79248: PPUSH
79249: LD_INT 2
79251: PUSH
79252: LD_INT 30
79254: PUSH
79255: LD_INT 0
79257: PUSH
79258: EMPTY
79259: LIST
79260: LIST
79261: PUSH
79262: LD_INT 30
79264: PUSH
79265: LD_INT 1
79267: PUSH
79268: EMPTY
79269: LIST
79270: LIST
79271: PUSH
79272: EMPTY
79273: LIST
79274: LIST
79275: LIST
79276: PPUSH
79277: CALL_OW 72
79281: ST_TO_ADDR
79282: GO 79470
79284: LD_INT 3
79286: DOUBLE
79287: EQUAL
79288: IFTRUE 79292
79290: GO 79338
79292: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79293: LD_ADDR_VAR 0 8
79297: PUSH
79298: LD_VAR 0 2
79302: PPUSH
79303: LD_INT 2
79305: PUSH
79306: LD_INT 30
79308: PUSH
79309: LD_INT 2
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 30
79318: PUSH
79319: LD_INT 3
79321: PUSH
79322: EMPTY
79323: LIST
79324: LIST
79325: PUSH
79326: EMPTY
79327: LIST
79328: LIST
79329: LIST
79330: PPUSH
79331: CALL_OW 72
79335: ST_TO_ADDR
79336: GO 79470
79338: LD_INT 4
79340: DOUBLE
79341: EQUAL
79342: IFTRUE 79346
79344: GO 79403
79346: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79347: LD_ADDR_VAR 0 8
79351: PUSH
79352: LD_VAR 0 2
79356: PPUSH
79357: LD_INT 2
79359: PUSH
79360: LD_INT 30
79362: PUSH
79363: LD_INT 6
79365: PUSH
79366: EMPTY
79367: LIST
79368: LIST
79369: PUSH
79370: LD_INT 30
79372: PUSH
79373: LD_INT 7
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 30
79382: PUSH
79383: LD_INT 8
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: PPUSH
79396: CALL_OW 72
79400: ST_TO_ADDR
79401: GO 79470
79403: LD_INT 5
79405: DOUBLE
79406: EQUAL
79407: IFTRUE 79423
79409: LD_INT 8
79411: DOUBLE
79412: EQUAL
79413: IFTRUE 79423
79415: LD_INT 9
79417: DOUBLE
79418: EQUAL
79419: IFTRUE 79423
79421: GO 79469
79423: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79424: LD_ADDR_VAR 0 8
79428: PUSH
79429: LD_VAR 0 2
79433: PPUSH
79434: LD_INT 2
79436: PUSH
79437: LD_INT 30
79439: PUSH
79440: LD_INT 4
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 30
79449: PUSH
79450: LD_INT 5
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: LIST
79461: PPUSH
79462: CALL_OW 72
79466: ST_TO_ADDR
79467: GO 79470
79469: POP
// if not tmp then
79470: LD_VAR 0 8
79474: NOT
79475: IFFALSE 79479
// exit ;
79477: GO 79981
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79479: LD_VAR 0 4
79483: PUSH
79484: LD_INT 1
79486: PUSH
79487: LD_INT 15
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: IN
79494: PUSH
79495: LD_EXP 70
79499: PUSH
79500: LD_VAR 0 1
79504: ARRAY
79505: AND
79506: IFFALSE 79662
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79508: LD_ADDR_VAR 0 9
79512: PUSH
79513: LD_EXP 70
79517: PUSH
79518: LD_VAR 0 1
79522: ARRAY
79523: PUSH
79524: LD_INT 1
79526: ARRAY
79527: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79528: LD_VAR 0 9
79532: PUSH
79533: LD_EXP 71
79537: PUSH
79538: LD_VAR 0 1
79542: ARRAY
79543: IN
79544: NOT
79545: IFFALSE 79660
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79547: LD_ADDR_EXP 71
79551: PUSH
79552: LD_EXP 71
79556: PPUSH
79557: LD_VAR 0 1
79561: PUSH
79562: LD_EXP 71
79566: PUSH
79567: LD_VAR 0 1
79571: ARRAY
79572: PUSH
79573: LD_INT 1
79575: PLUS
79576: PUSH
79577: EMPTY
79578: LIST
79579: LIST
79580: PPUSH
79581: LD_VAR 0 9
79585: PPUSH
79586: CALL 20070 0 3
79590: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79591: LD_ADDR_EXP 70
79595: PUSH
79596: LD_EXP 70
79600: PPUSH
79601: LD_VAR 0 1
79605: PPUSH
79606: LD_EXP 70
79610: PUSH
79611: LD_VAR 0 1
79615: ARRAY
79616: PUSH
79617: LD_VAR 0 9
79621: DIFF
79622: PPUSH
79623: CALL_OW 1
79627: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79628: LD_VAR 0 3
79632: PPUSH
79633: LD_EXP 71
79637: PUSH
79638: LD_VAR 0 1
79642: ARRAY
79643: PUSH
79644: LD_EXP 71
79648: PUSH
79649: LD_VAR 0 1
79653: ARRAY
79654: ARRAY
79655: PPUSH
79656: CALL_OW 120
// end ; exit ;
79660: GO 79981
// end ; if tmp > 1 then
79662: LD_VAR 0 8
79666: PUSH
79667: LD_INT 1
79669: GREATER
79670: IFFALSE 79774
// for i = 2 to tmp do
79672: LD_ADDR_VAR 0 6
79676: PUSH
79677: DOUBLE
79678: LD_INT 2
79680: DEC
79681: ST_TO_ADDR
79682: LD_VAR 0 8
79686: PUSH
79687: FOR_TO
79688: IFFALSE 79772
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79690: LD_VAR 0 8
79694: PUSH
79695: LD_VAR 0 6
79699: ARRAY
79700: PPUSH
79701: CALL_OW 461
79705: PUSH
79706: LD_INT 6
79708: EQUAL
79709: IFFALSE 79770
// begin x := tmp [ i ] ;
79711: LD_ADDR_VAR 0 9
79715: PUSH
79716: LD_VAR 0 8
79720: PUSH
79721: LD_VAR 0 6
79725: ARRAY
79726: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79727: LD_ADDR_VAR 0 8
79731: PUSH
79732: LD_VAR 0 8
79736: PPUSH
79737: LD_VAR 0 6
79741: PPUSH
79742: CALL_OW 3
79746: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79747: LD_ADDR_VAR 0 8
79751: PUSH
79752: LD_VAR 0 8
79756: PPUSH
79757: LD_INT 1
79759: PPUSH
79760: LD_VAR 0 9
79764: PPUSH
79765: CALL_OW 2
79769: ST_TO_ADDR
// end ;
79770: GO 79687
79772: POP
79773: POP
// for i in tmp do
79774: LD_ADDR_VAR 0 6
79778: PUSH
79779: LD_VAR 0 8
79783: PUSH
79784: FOR_IN
79785: IFFALSE 79854
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79787: LD_VAR 0 6
79791: PPUSH
79792: CALL_OW 313
79796: PUSH
79797: LD_INT 6
79799: LESS
79800: PUSH
79801: LD_VAR 0 6
79805: PPUSH
79806: CALL_OW 266
79810: PUSH
79811: LD_INT 31
79813: PUSH
79814: LD_INT 32
79816: PUSH
79817: EMPTY
79818: LIST
79819: LIST
79820: IN
79821: NOT
79822: AND
79823: PUSH
79824: LD_VAR 0 6
79828: PPUSH
79829: CALL_OW 313
79833: PUSH
79834: LD_INT 0
79836: EQUAL
79837: OR
79838: IFFALSE 79852
// begin j := i ;
79840: LD_ADDR_VAR 0 7
79844: PUSH
79845: LD_VAR 0 6
79849: ST_TO_ADDR
// break ;
79850: GO 79854
// end ; end ;
79852: GO 79784
79854: POP
79855: POP
// if j then
79856: LD_VAR 0 7
79860: IFFALSE 79878
// ComEnterUnit ( unit , j ) else
79862: LD_VAR 0 3
79866: PPUSH
79867: LD_VAR 0 7
79871: PPUSH
79872: CALL_OW 120
79876: GO 79981
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79878: LD_ADDR_VAR 0 10
79882: PUSH
79883: LD_VAR 0 2
79887: PPUSH
79888: LD_INT 2
79890: PUSH
79891: LD_INT 30
79893: PUSH
79894: LD_INT 0
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 30
79903: PUSH
79904: LD_INT 1
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: LIST
79915: PPUSH
79916: CALL_OW 72
79920: ST_TO_ADDR
// if depot then
79921: LD_VAR 0 10
79925: IFFALSE 79981
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79927: LD_ADDR_VAR 0 10
79931: PUSH
79932: LD_VAR 0 10
79936: PPUSH
79937: LD_VAR 0 3
79941: PPUSH
79942: CALL_OW 74
79946: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79947: LD_VAR 0 3
79951: PPUSH
79952: LD_VAR 0 10
79956: PPUSH
79957: CALL_OW 296
79961: PUSH
79962: LD_INT 10
79964: GREATER
79965: IFFALSE 79981
// ComStandNearbyBuilding ( unit , depot ) ;
79967: LD_VAR 0 3
79971: PPUSH
79972: LD_VAR 0 10
79976: PPUSH
79977: CALL 16497 0 2
// end ; end ; end ;
79981: LD_VAR 0 5
79985: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79986: LD_INT 0
79988: PPUSH
79989: PPUSH
79990: PPUSH
79991: PPUSH
// if not mc_bases then
79992: LD_EXP 61
79996: NOT
79997: IFFALSE 80001
// exit ;
79999: GO 80240
// for i = 1 to mc_bases do
80001: LD_ADDR_VAR 0 2
80005: PUSH
80006: DOUBLE
80007: LD_INT 1
80009: DEC
80010: ST_TO_ADDR
80011: LD_EXP 61
80015: PUSH
80016: FOR_TO
80017: IFFALSE 80238
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80019: LD_ADDR_VAR 0 4
80023: PUSH
80024: LD_EXP 61
80028: PUSH
80029: LD_VAR 0 2
80033: ARRAY
80034: PPUSH
80035: LD_INT 21
80037: PUSH
80038: LD_INT 1
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PPUSH
80045: CALL_OW 72
80049: PUSH
80050: LD_EXP 90
80054: PUSH
80055: LD_VAR 0 2
80059: ARRAY
80060: UNION
80061: ST_TO_ADDR
// if not tmp then
80062: LD_VAR 0 4
80066: NOT
80067: IFFALSE 80071
// continue ;
80069: GO 80016
// for j in tmp do
80071: LD_ADDR_VAR 0 3
80075: PUSH
80076: LD_VAR 0 4
80080: PUSH
80081: FOR_IN
80082: IFFALSE 80234
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80084: LD_VAR 0 3
80088: PPUSH
80089: CALL_OW 110
80093: NOT
80094: PUSH
80095: LD_VAR 0 3
80099: PPUSH
80100: CALL_OW 314
80104: NOT
80105: AND
80106: PUSH
80107: LD_VAR 0 3
80111: PPUSH
80112: CALL_OW 311
80116: NOT
80117: AND
80118: PUSH
80119: LD_VAR 0 3
80123: PPUSH
80124: CALL_OW 310
80128: NOT
80129: AND
80130: PUSH
80131: LD_VAR 0 3
80135: PUSH
80136: LD_EXP 64
80140: PUSH
80141: LD_VAR 0 2
80145: ARRAY
80146: PUSH
80147: LD_INT 1
80149: ARRAY
80150: IN
80151: NOT
80152: AND
80153: PUSH
80154: LD_VAR 0 3
80158: PUSH
80159: LD_EXP 64
80163: PUSH
80164: LD_VAR 0 2
80168: ARRAY
80169: PUSH
80170: LD_INT 2
80172: ARRAY
80173: IN
80174: NOT
80175: AND
80176: PUSH
80177: LD_VAR 0 3
80181: PUSH
80182: LD_EXP 73
80186: PUSH
80187: LD_VAR 0 2
80191: ARRAY
80192: IN
80193: NOT
80194: AND
80195: IFFALSE 80232
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80197: LD_VAR 0 2
80201: PPUSH
80202: LD_EXP 61
80206: PUSH
80207: LD_VAR 0 2
80211: ARRAY
80212: PPUSH
80213: LD_VAR 0 3
80217: PPUSH
80218: LD_VAR 0 3
80222: PPUSH
80223: CALL_OW 257
80227: PPUSH
80228: CALL 79004 0 4
// end ;
80232: GO 80081
80234: POP
80235: POP
// end ;
80236: GO 80016
80238: POP
80239: POP
// end ;
80240: LD_VAR 0 1
80244: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80245: LD_INT 0
80247: PPUSH
80248: PPUSH
80249: PPUSH
80250: PPUSH
80251: PPUSH
80252: PPUSH
// if not mc_bases [ base ] then
80253: LD_EXP 61
80257: PUSH
80258: LD_VAR 0 1
80262: ARRAY
80263: NOT
80264: IFFALSE 80268
// exit ;
80266: GO 80450
// tmp := [ ] ;
80268: LD_ADDR_VAR 0 6
80272: PUSH
80273: EMPTY
80274: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80275: LD_ADDR_VAR 0 7
80279: PUSH
80280: LD_VAR 0 3
80284: PPUSH
80285: LD_INT 0
80287: PPUSH
80288: CALL_OW 517
80292: ST_TO_ADDR
// if not list then
80293: LD_VAR 0 7
80297: NOT
80298: IFFALSE 80302
// exit ;
80300: GO 80450
// for i = 1 to amount do
80302: LD_ADDR_VAR 0 5
80306: PUSH
80307: DOUBLE
80308: LD_INT 1
80310: DEC
80311: ST_TO_ADDR
80312: LD_VAR 0 2
80316: PUSH
80317: FOR_TO
80318: IFFALSE 80398
// begin x := rand ( 1 , list [ 1 ] ) ;
80320: LD_ADDR_VAR 0 8
80324: PUSH
80325: LD_INT 1
80327: PPUSH
80328: LD_VAR 0 7
80332: PUSH
80333: LD_INT 1
80335: ARRAY
80336: PPUSH
80337: CALL_OW 12
80341: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80342: LD_ADDR_VAR 0 6
80346: PUSH
80347: LD_VAR 0 6
80351: PPUSH
80352: LD_VAR 0 5
80356: PPUSH
80357: LD_VAR 0 7
80361: PUSH
80362: LD_INT 1
80364: ARRAY
80365: PUSH
80366: LD_VAR 0 8
80370: ARRAY
80371: PUSH
80372: LD_VAR 0 7
80376: PUSH
80377: LD_INT 2
80379: ARRAY
80380: PUSH
80381: LD_VAR 0 8
80385: ARRAY
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PPUSH
80391: CALL_OW 1
80395: ST_TO_ADDR
// end ;
80396: GO 80317
80398: POP
80399: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80400: LD_ADDR_EXP 74
80404: PUSH
80405: LD_EXP 74
80409: PPUSH
80410: LD_VAR 0 1
80414: PPUSH
80415: LD_VAR 0 6
80419: PPUSH
80420: CALL_OW 1
80424: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80425: LD_ADDR_EXP 76
80429: PUSH
80430: LD_EXP 76
80434: PPUSH
80435: LD_VAR 0 1
80439: PPUSH
80440: LD_VAR 0 3
80444: PPUSH
80445: CALL_OW 1
80449: ST_TO_ADDR
// end ;
80450: LD_VAR 0 4
80454: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80455: LD_INT 0
80457: PPUSH
// if not mc_bases [ base ] then
80458: LD_EXP 61
80462: PUSH
80463: LD_VAR 0 1
80467: ARRAY
80468: NOT
80469: IFFALSE 80473
// exit ;
80471: GO 80498
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80473: LD_ADDR_EXP 66
80477: PUSH
80478: LD_EXP 66
80482: PPUSH
80483: LD_VAR 0 1
80487: PPUSH
80488: LD_VAR 0 2
80492: PPUSH
80493: CALL_OW 1
80497: ST_TO_ADDR
// end ;
80498: LD_VAR 0 3
80502: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80503: LD_INT 0
80505: PPUSH
// if not mc_bases [ base ] then
80506: LD_EXP 61
80510: PUSH
80511: LD_VAR 0 1
80515: ARRAY
80516: NOT
80517: IFFALSE 80521
// exit ;
80519: GO 80558
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80521: LD_ADDR_EXP 66
80525: PUSH
80526: LD_EXP 66
80530: PPUSH
80531: LD_VAR 0 1
80535: PPUSH
80536: LD_EXP 66
80540: PUSH
80541: LD_VAR 0 1
80545: ARRAY
80546: PUSH
80547: LD_VAR 0 2
80551: UNION
80552: PPUSH
80553: CALL_OW 1
80557: ST_TO_ADDR
// end ;
80558: LD_VAR 0 3
80562: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80563: LD_INT 0
80565: PPUSH
// if not mc_bases [ base ] then
80566: LD_EXP 61
80570: PUSH
80571: LD_VAR 0 1
80575: ARRAY
80576: NOT
80577: IFFALSE 80581
// exit ;
80579: GO 80606
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80581: LD_ADDR_EXP 82
80585: PUSH
80586: LD_EXP 82
80590: PPUSH
80591: LD_VAR 0 1
80595: PPUSH
80596: LD_VAR 0 2
80600: PPUSH
80601: CALL_OW 1
80605: ST_TO_ADDR
// end ;
80606: LD_VAR 0 3
80610: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80611: LD_INT 0
80613: PPUSH
// if not mc_bases [ base ] then
80614: LD_EXP 61
80618: PUSH
80619: LD_VAR 0 1
80623: ARRAY
80624: NOT
80625: IFFALSE 80629
// exit ;
80627: GO 80666
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80629: LD_ADDR_EXP 82
80633: PUSH
80634: LD_EXP 82
80638: PPUSH
80639: LD_VAR 0 1
80643: PPUSH
80644: LD_EXP 82
80648: PUSH
80649: LD_VAR 0 1
80653: ARRAY
80654: PUSH
80655: LD_VAR 0 2
80659: ADD
80660: PPUSH
80661: CALL_OW 1
80665: ST_TO_ADDR
// end ;
80666: LD_VAR 0 3
80670: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80671: LD_INT 0
80673: PPUSH
// if not mc_bases [ base ] then
80674: LD_EXP 61
80678: PUSH
80679: LD_VAR 0 1
80683: ARRAY
80684: NOT
80685: IFFALSE 80689
// exit ;
80687: GO 80743
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80689: LD_ADDR_EXP 83
80693: PUSH
80694: LD_EXP 83
80698: PPUSH
80699: LD_VAR 0 1
80703: PPUSH
80704: LD_VAR 0 2
80708: PPUSH
80709: CALL_OW 1
80713: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80714: LD_ADDR_EXP 72
80718: PUSH
80719: LD_EXP 72
80723: PPUSH
80724: LD_VAR 0 1
80728: PPUSH
80729: LD_VAR 0 2
80733: PUSH
80734: LD_INT 0
80736: PLUS
80737: PPUSH
80738: CALL_OW 1
80742: ST_TO_ADDR
// end ;
80743: LD_VAR 0 3
80747: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80748: LD_INT 0
80750: PPUSH
// if not mc_bases [ base ] then
80751: LD_EXP 61
80755: PUSH
80756: LD_VAR 0 1
80760: ARRAY
80761: NOT
80762: IFFALSE 80766
// exit ;
80764: GO 80791
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80766: LD_ADDR_EXP 72
80770: PUSH
80771: LD_EXP 72
80775: PPUSH
80776: LD_VAR 0 1
80780: PPUSH
80781: LD_VAR 0 2
80785: PPUSH
80786: CALL_OW 1
80790: ST_TO_ADDR
// end ;
80791: LD_VAR 0 3
80795: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80796: LD_INT 0
80798: PPUSH
80799: PPUSH
80800: PPUSH
80801: PPUSH
// if not mc_bases [ base ] then
80802: LD_EXP 61
80806: PUSH
80807: LD_VAR 0 1
80811: ARRAY
80812: NOT
80813: IFFALSE 80817
// exit ;
80815: GO 80882
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80817: LD_ADDR_EXP 81
80821: PUSH
80822: LD_EXP 81
80826: PPUSH
80827: LD_VAR 0 1
80831: PUSH
80832: LD_EXP 81
80836: PUSH
80837: LD_VAR 0 1
80841: ARRAY
80842: PUSH
80843: LD_INT 1
80845: PLUS
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PPUSH
80851: LD_VAR 0 1
80855: PUSH
80856: LD_VAR 0 2
80860: PUSH
80861: LD_VAR 0 3
80865: PUSH
80866: LD_VAR 0 4
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: LIST
80875: LIST
80876: PPUSH
80877: CALL 20070 0 3
80881: ST_TO_ADDR
// end ;
80882: LD_VAR 0 5
80886: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80887: LD_INT 0
80889: PPUSH
// if not mc_bases [ base ] then
80890: LD_EXP 61
80894: PUSH
80895: LD_VAR 0 1
80899: ARRAY
80900: NOT
80901: IFFALSE 80905
// exit ;
80903: GO 80930
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80905: LD_ADDR_EXP 98
80909: PUSH
80910: LD_EXP 98
80914: PPUSH
80915: LD_VAR 0 1
80919: PPUSH
80920: LD_VAR 0 2
80924: PPUSH
80925: CALL_OW 1
80929: ST_TO_ADDR
// end ;
80930: LD_VAR 0 3
80934: RET
// export function MC_GetMinesField ( base ) ; begin
80935: LD_INT 0
80937: PPUSH
// result := mc_mines [ base ] ;
80938: LD_ADDR_VAR 0 2
80942: PUSH
80943: LD_EXP 74
80947: PUSH
80948: LD_VAR 0 1
80952: ARRAY
80953: ST_TO_ADDR
// end ;
80954: LD_VAR 0 2
80958: RET
// export function MC_GetProduceList ( base ) ; begin
80959: LD_INT 0
80961: PPUSH
// result := mc_produce [ base ] ;
80962: LD_ADDR_VAR 0 2
80966: PUSH
80967: LD_EXP 82
80971: PUSH
80972: LD_VAR 0 1
80976: ARRAY
80977: ST_TO_ADDR
// end ;
80978: LD_VAR 0 2
80982: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80983: LD_INT 0
80985: PPUSH
80986: PPUSH
// if not mc_bases then
80987: LD_EXP 61
80991: NOT
80992: IFFALSE 80996
// exit ;
80994: GO 81061
// if mc_bases [ base ] then
80996: LD_EXP 61
81000: PUSH
81001: LD_VAR 0 1
81005: ARRAY
81006: IFFALSE 81061
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81008: LD_ADDR_VAR 0 3
81012: PUSH
81013: LD_EXP 61
81017: PUSH
81018: LD_VAR 0 1
81022: ARRAY
81023: PPUSH
81024: LD_INT 30
81026: PUSH
81027: LD_VAR 0 2
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PPUSH
81036: CALL_OW 72
81040: ST_TO_ADDR
// if result then
81041: LD_VAR 0 3
81045: IFFALSE 81061
// result := result [ 1 ] ;
81047: LD_ADDR_VAR 0 3
81051: PUSH
81052: LD_VAR 0 3
81056: PUSH
81057: LD_INT 1
81059: ARRAY
81060: ST_TO_ADDR
// end ; end ;
81061: LD_VAR 0 3
81065: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81066: LD_INT 0
81068: PPUSH
81069: PPUSH
// if not mc_bases then
81070: LD_EXP 61
81074: NOT
81075: IFFALSE 81079
// exit ;
81077: GO 81124
// if mc_bases [ base ] then
81079: LD_EXP 61
81083: PUSH
81084: LD_VAR 0 1
81088: ARRAY
81089: IFFALSE 81124
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81091: LD_ADDR_VAR 0 3
81095: PUSH
81096: LD_EXP 61
81100: PUSH
81101: LD_VAR 0 1
81105: ARRAY
81106: PPUSH
81107: LD_INT 30
81109: PUSH
81110: LD_VAR 0 2
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PPUSH
81119: CALL_OW 72
81123: ST_TO_ADDR
// end ;
81124: LD_VAR 0 3
81128: RET
// export function MC_SetTame ( base , area ) ; begin
81129: LD_INT 0
81131: PPUSH
// if not mc_bases or not base then
81132: LD_EXP 61
81136: NOT
81137: PUSH
81138: LD_VAR 0 1
81142: NOT
81143: OR
81144: IFFALSE 81148
// exit ;
81146: GO 81173
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81148: LD_ADDR_EXP 89
81152: PUSH
81153: LD_EXP 89
81157: PPUSH
81158: LD_VAR 0 1
81162: PPUSH
81163: LD_VAR 0 2
81167: PPUSH
81168: CALL_OW 1
81172: ST_TO_ADDR
// end ;
81173: LD_VAR 0 3
81177: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81178: LD_INT 0
81180: PPUSH
81181: PPUSH
// if not mc_bases or not base then
81182: LD_EXP 61
81186: NOT
81187: PUSH
81188: LD_VAR 0 1
81192: NOT
81193: OR
81194: IFFALSE 81198
// exit ;
81196: GO 81300
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81198: LD_ADDR_VAR 0 4
81202: PUSH
81203: LD_EXP 61
81207: PUSH
81208: LD_VAR 0 1
81212: ARRAY
81213: PPUSH
81214: LD_INT 30
81216: PUSH
81217: LD_VAR 0 2
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PPUSH
81226: CALL_OW 72
81230: ST_TO_ADDR
// if not tmp then
81231: LD_VAR 0 4
81235: NOT
81236: IFFALSE 81240
// exit ;
81238: GO 81300
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81240: LD_ADDR_EXP 93
81244: PUSH
81245: LD_EXP 93
81249: PPUSH
81250: LD_VAR 0 1
81254: PPUSH
81255: LD_EXP 93
81259: PUSH
81260: LD_VAR 0 1
81264: ARRAY
81265: PPUSH
81266: LD_EXP 93
81270: PUSH
81271: LD_VAR 0 1
81275: ARRAY
81276: PUSH
81277: LD_INT 1
81279: PLUS
81280: PPUSH
81281: LD_VAR 0 4
81285: PUSH
81286: LD_INT 1
81288: ARRAY
81289: PPUSH
81290: CALL_OW 2
81294: PPUSH
81295: CALL_OW 1
81299: ST_TO_ADDR
// end ;
81300: LD_VAR 0 3
81304: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81305: LD_INT 0
81307: PPUSH
81308: PPUSH
// if not mc_bases or not base or not kinds then
81309: LD_EXP 61
81313: NOT
81314: PUSH
81315: LD_VAR 0 1
81319: NOT
81320: OR
81321: PUSH
81322: LD_VAR 0 2
81326: NOT
81327: OR
81328: IFFALSE 81332
// exit ;
81330: GO 81393
// for i in kinds do
81332: LD_ADDR_VAR 0 4
81336: PUSH
81337: LD_VAR 0 2
81341: PUSH
81342: FOR_IN
81343: IFFALSE 81391
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81345: LD_ADDR_EXP 95
81349: PUSH
81350: LD_EXP 95
81354: PPUSH
81355: LD_VAR 0 1
81359: PUSH
81360: LD_EXP 95
81364: PUSH
81365: LD_VAR 0 1
81369: ARRAY
81370: PUSH
81371: LD_INT 1
81373: PLUS
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PPUSH
81379: LD_VAR 0 4
81383: PPUSH
81384: CALL 20070 0 3
81388: ST_TO_ADDR
81389: GO 81342
81391: POP
81392: POP
// end ;
81393: LD_VAR 0 3
81397: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81398: LD_INT 0
81400: PPUSH
// if not mc_bases or not base or not areas then
81401: LD_EXP 61
81405: NOT
81406: PUSH
81407: LD_VAR 0 1
81411: NOT
81412: OR
81413: PUSH
81414: LD_VAR 0 2
81418: NOT
81419: OR
81420: IFFALSE 81424
// exit ;
81422: GO 81449
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81424: LD_ADDR_EXP 79
81428: PUSH
81429: LD_EXP 79
81433: PPUSH
81434: LD_VAR 0 1
81438: PPUSH
81439: LD_VAR 0 2
81443: PPUSH
81444: CALL_OW 1
81448: ST_TO_ADDR
// end ;
81449: LD_VAR 0 3
81453: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81454: LD_INT 0
81456: PPUSH
// if not mc_bases or not base or not teleports_exit then
81457: LD_EXP 61
81461: NOT
81462: PUSH
81463: LD_VAR 0 1
81467: NOT
81468: OR
81469: PUSH
81470: LD_VAR 0 2
81474: NOT
81475: OR
81476: IFFALSE 81480
// exit ;
81478: GO 81505
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81480: LD_ADDR_EXP 96
81484: PUSH
81485: LD_EXP 96
81489: PPUSH
81490: LD_VAR 0 1
81494: PPUSH
81495: LD_VAR 0 2
81499: PPUSH
81500: CALL_OW 1
81504: ST_TO_ADDR
// end ;
81505: LD_VAR 0 3
81509: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81510: LD_INT 0
81512: PPUSH
81513: PPUSH
81514: PPUSH
// if not mc_bases or not base or not ext_list then
81515: LD_EXP 61
81519: NOT
81520: PUSH
81521: LD_VAR 0 1
81525: NOT
81526: OR
81527: PUSH
81528: LD_VAR 0 5
81532: NOT
81533: OR
81534: IFFALSE 81538
// exit ;
81536: GO 81711
// tmp := GetFacExtXYD ( x , y , d ) ;
81538: LD_ADDR_VAR 0 8
81542: PUSH
81543: LD_VAR 0 2
81547: PPUSH
81548: LD_VAR 0 3
81552: PPUSH
81553: LD_VAR 0 4
81557: PPUSH
81558: CALL 50021 0 3
81562: ST_TO_ADDR
// if not tmp then
81563: LD_VAR 0 8
81567: NOT
81568: IFFALSE 81572
// exit ;
81570: GO 81711
// for i in tmp do
81572: LD_ADDR_VAR 0 7
81576: PUSH
81577: LD_VAR 0 8
81581: PUSH
81582: FOR_IN
81583: IFFALSE 81709
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81585: LD_ADDR_EXP 66
81589: PUSH
81590: LD_EXP 66
81594: PPUSH
81595: LD_VAR 0 1
81599: PPUSH
81600: LD_EXP 66
81604: PUSH
81605: LD_VAR 0 1
81609: ARRAY
81610: PPUSH
81611: LD_EXP 66
81615: PUSH
81616: LD_VAR 0 1
81620: ARRAY
81621: PUSH
81622: LD_INT 1
81624: PLUS
81625: PPUSH
81626: LD_VAR 0 5
81630: PUSH
81631: LD_INT 1
81633: ARRAY
81634: PUSH
81635: LD_VAR 0 7
81639: PUSH
81640: LD_INT 1
81642: ARRAY
81643: PUSH
81644: LD_VAR 0 7
81648: PUSH
81649: LD_INT 2
81651: ARRAY
81652: PUSH
81653: LD_VAR 0 7
81657: PUSH
81658: LD_INT 3
81660: ARRAY
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: LIST
81666: LIST
81667: PPUSH
81668: CALL_OW 2
81672: PPUSH
81673: CALL_OW 1
81677: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81678: LD_ADDR_VAR 0 5
81682: PUSH
81683: LD_VAR 0 5
81687: PPUSH
81688: LD_INT 1
81690: PPUSH
81691: CALL_OW 3
81695: ST_TO_ADDR
// if not ext_list then
81696: LD_VAR 0 5
81700: NOT
81701: IFFALSE 81707
// exit ;
81703: POP
81704: POP
81705: GO 81711
// end ;
81707: GO 81582
81709: POP
81710: POP
// end ;
81711: LD_VAR 0 6
81715: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81716: LD_INT 0
81718: PPUSH
// if not mc_bases or not base or not weapon_list then
81719: LD_EXP 61
81723: NOT
81724: PUSH
81725: LD_VAR 0 1
81729: NOT
81730: OR
81731: PUSH
81732: LD_VAR 0 2
81736: NOT
81737: OR
81738: IFFALSE 81742
// exit ;
81740: GO 81767
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81742: LD_ADDR_EXP 100
81746: PUSH
81747: LD_EXP 100
81751: PPUSH
81752: LD_VAR 0 1
81756: PPUSH
81757: LD_VAR 0 2
81761: PPUSH
81762: CALL_OW 1
81766: ST_TO_ADDR
// end ;
81767: LD_VAR 0 3
81771: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81772: LD_INT 0
81774: PPUSH
// if not mc_bases or not base or not tech_list then
81775: LD_EXP 61
81779: NOT
81780: PUSH
81781: LD_VAR 0 1
81785: NOT
81786: OR
81787: PUSH
81788: LD_VAR 0 2
81792: NOT
81793: OR
81794: IFFALSE 81798
// exit ;
81796: GO 81823
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81798: LD_ADDR_EXP 88
81802: PUSH
81803: LD_EXP 88
81807: PPUSH
81808: LD_VAR 0 1
81812: PPUSH
81813: LD_VAR 0 2
81817: PPUSH
81818: CALL_OW 1
81822: ST_TO_ADDR
// end ;
81823: LD_VAR 0 3
81827: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81828: LD_INT 0
81830: PPUSH
// if not mc_bases or not parking_area or not base then
81831: LD_EXP 61
81835: NOT
81836: PUSH
81837: LD_VAR 0 2
81841: NOT
81842: OR
81843: PUSH
81844: LD_VAR 0 1
81848: NOT
81849: OR
81850: IFFALSE 81854
// exit ;
81852: GO 81879
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81854: LD_ADDR_EXP 85
81858: PUSH
81859: LD_EXP 85
81863: PPUSH
81864: LD_VAR 0 1
81868: PPUSH
81869: LD_VAR 0 2
81873: PPUSH
81874: CALL_OW 1
81878: ST_TO_ADDR
// end ;
81879: LD_VAR 0 3
81883: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81884: LD_INT 0
81886: PPUSH
// if not mc_bases or not base or not scan_area then
81887: LD_EXP 61
81891: NOT
81892: PUSH
81893: LD_VAR 0 1
81897: NOT
81898: OR
81899: PUSH
81900: LD_VAR 0 2
81904: NOT
81905: OR
81906: IFFALSE 81910
// exit ;
81908: GO 81935
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81910: LD_ADDR_EXP 86
81914: PUSH
81915: LD_EXP 86
81919: PPUSH
81920: LD_VAR 0 1
81924: PPUSH
81925: LD_VAR 0 2
81929: PPUSH
81930: CALL_OW 1
81934: ST_TO_ADDR
// end ;
81935: LD_VAR 0 3
81939: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81940: LD_INT 0
81942: PPUSH
81943: PPUSH
// if not mc_bases or not base then
81944: LD_EXP 61
81948: NOT
81949: PUSH
81950: LD_VAR 0 1
81954: NOT
81955: OR
81956: IFFALSE 81960
// exit ;
81958: GO 82024
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81960: LD_ADDR_VAR 0 3
81964: PUSH
81965: LD_INT 1
81967: PUSH
81968: LD_INT 2
81970: PUSH
81971: LD_INT 3
81973: PUSH
81974: LD_INT 4
81976: PUSH
81977: LD_INT 11
81979: PUSH
81980: EMPTY
81981: LIST
81982: LIST
81983: LIST
81984: LIST
81985: LIST
81986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81987: LD_ADDR_EXP 88
81991: PUSH
81992: LD_EXP 88
81996: PPUSH
81997: LD_VAR 0 1
82001: PPUSH
82002: LD_EXP 88
82006: PUSH
82007: LD_VAR 0 1
82011: ARRAY
82012: PUSH
82013: LD_VAR 0 3
82017: DIFF
82018: PPUSH
82019: CALL_OW 1
82023: ST_TO_ADDR
// end ;
82024: LD_VAR 0 2
82028: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82029: LD_INT 0
82031: PPUSH
// result := mc_vehicles [ base ] ;
82032: LD_ADDR_VAR 0 3
82036: PUSH
82037: LD_EXP 80
82041: PUSH
82042: LD_VAR 0 1
82046: ARRAY
82047: ST_TO_ADDR
// if onlyCombat then
82048: LD_VAR 0 2
82052: IFFALSE 82224
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82054: LD_ADDR_VAR 0 3
82058: PUSH
82059: LD_VAR 0 3
82063: PUSH
82064: LD_VAR 0 3
82068: PPUSH
82069: LD_INT 2
82071: PUSH
82072: LD_INT 34
82074: PUSH
82075: LD_INT 12
82077: PUSH
82078: EMPTY
82079: LIST
82080: LIST
82081: PUSH
82082: LD_INT 34
82084: PUSH
82085: LD_INT 51
82087: PUSH
82088: EMPTY
82089: LIST
82090: LIST
82091: PUSH
82092: LD_INT 34
82094: PUSH
82095: LD_INT 89
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: PUSH
82102: LD_INT 34
82104: PUSH
82105: LD_INT 32
82107: PUSH
82108: EMPTY
82109: LIST
82110: LIST
82111: PUSH
82112: LD_INT 34
82114: PUSH
82115: LD_INT 13
82117: PUSH
82118: EMPTY
82119: LIST
82120: LIST
82121: PUSH
82122: LD_INT 34
82124: PUSH
82125: LD_INT 52
82127: PUSH
82128: EMPTY
82129: LIST
82130: LIST
82131: PUSH
82132: LD_INT 34
82134: PUSH
82135: LD_INT 88
82137: PUSH
82138: EMPTY
82139: LIST
82140: LIST
82141: PUSH
82142: LD_INT 34
82144: PUSH
82145: LD_INT 14
82147: PUSH
82148: EMPTY
82149: LIST
82150: LIST
82151: PUSH
82152: LD_INT 34
82154: PUSH
82155: LD_INT 53
82157: PUSH
82158: EMPTY
82159: LIST
82160: LIST
82161: PUSH
82162: LD_INT 34
82164: PUSH
82165: LD_INT 98
82167: PUSH
82168: EMPTY
82169: LIST
82170: LIST
82171: PUSH
82172: LD_INT 34
82174: PUSH
82175: LD_INT 31
82177: PUSH
82178: EMPTY
82179: LIST
82180: LIST
82181: PUSH
82182: LD_INT 34
82184: PUSH
82185: LD_INT 48
82187: PUSH
82188: EMPTY
82189: LIST
82190: LIST
82191: PUSH
82192: LD_INT 34
82194: PUSH
82195: LD_INT 8
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: LIST
82206: LIST
82207: LIST
82208: LIST
82209: LIST
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: PPUSH
82218: CALL_OW 72
82222: DIFF
82223: ST_TO_ADDR
// end ; end_of_file
82224: LD_VAR 0 3
82228: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82229: LD_INT 0
82231: PPUSH
82232: PPUSH
82233: PPUSH
// if not mc_bases or not skirmish then
82234: LD_EXP 61
82238: NOT
82239: PUSH
82240: LD_EXP 59
82244: NOT
82245: OR
82246: IFFALSE 82250
// exit ;
82248: GO 82415
// for i = 1 to mc_bases do
82250: LD_ADDR_VAR 0 4
82254: PUSH
82255: DOUBLE
82256: LD_INT 1
82258: DEC
82259: ST_TO_ADDR
82260: LD_EXP 61
82264: PUSH
82265: FOR_TO
82266: IFFALSE 82413
// begin if sci in mc_bases [ i ] then
82268: LD_VAR 0 2
82272: PUSH
82273: LD_EXP 61
82277: PUSH
82278: LD_VAR 0 4
82282: ARRAY
82283: IN
82284: IFFALSE 82411
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82286: LD_ADDR_EXP 90
82290: PUSH
82291: LD_EXP 90
82295: PPUSH
82296: LD_VAR 0 4
82300: PUSH
82301: LD_EXP 90
82305: PUSH
82306: LD_VAR 0 4
82310: ARRAY
82311: PUSH
82312: LD_INT 1
82314: PLUS
82315: PUSH
82316: EMPTY
82317: LIST
82318: LIST
82319: PPUSH
82320: LD_VAR 0 1
82324: PPUSH
82325: CALL 20070 0 3
82329: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82330: LD_ADDR_VAR 0 5
82334: PUSH
82335: LD_EXP 61
82339: PUSH
82340: LD_VAR 0 4
82344: ARRAY
82345: PPUSH
82346: LD_INT 2
82348: PUSH
82349: LD_INT 30
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 30
82361: PUSH
82362: LD_INT 1
82364: PUSH
82365: EMPTY
82366: LIST
82367: LIST
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: LIST
82373: PPUSH
82374: CALL_OW 72
82378: PPUSH
82379: LD_VAR 0 1
82383: PPUSH
82384: CALL_OW 74
82388: ST_TO_ADDR
// if tmp then
82389: LD_VAR 0 5
82393: IFFALSE 82409
// ComStandNearbyBuilding ( ape , tmp ) ;
82395: LD_VAR 0 1
82399: PPUSH
82400: LD_VAR 0 5
82404: PPUSH
82405: CALL 16497 0 2
// break ;
82409: GO 82413
// end ; end ;
82411: GO 82265
82413: POP
82414: POP
// end ;
82415: LD_VAR 0 3
82419: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82420: LD_INT 0
82422: PPUSH
82423: PPUSH
82424: PPUSH
// if not mc_bases or not skirmish then
82425: LD_EXP 61
82429: NOT
82430: PUSH
82431: LD_EXP 59
82435: NOT
82436: OR
82437: IFFALSE 82441
// exit ;
82439: GO 82530
// for i = 1 to mc_bases do
82441: LD_ADDR_VAR 0 4
82445: PUSH
82446: DOUBLE
82447: LD_INT 1
82449: DEC
82450: ST_TO_ADDR
82451: LD_EXP 61
82455: PUSH
82456: FOR_TO
82457: IFFALSE 82528
// begin if building in mc_busy_turret_list [ i ] then
82459: LD_VAR 0 1
82463: PUSH
82464: LD_EXP 71
82468: PUSH
82469: LD_VAR 0 4
82473: ARRAY
82474: IN
82475: IFFALSE 82526
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82477: LD_ADDR_VAR 0 5
82481: PUSH
82482: LD_EXP 71
82486: PUSH
82487: LD_VAR 0 4
82491: ARRAY
82492: PUSH
82493: LD_VAR 0 1
82497: DIFF
82498: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82499: LD_ADDR_EXP 71
82503: PUSH
82504: LD_EXP 71
82508: PPUSH
82509: LD_VAR 0 4
82513: PPUSH
82514: LD_VAR 0 5
82518: PPUSH
82519: CALL_OW 1
82523: ST_TO_ADDR
// break ;
82524: GO 82528
// end ; end ;
82526: GO 82456
82528: POP
82529: POP
// end ;
82530: LD_VAR 0 3
82534: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82535: LD_INT 0
82537: PPUSH
82538: PPUSH
82539: PPUSH
// if not mc_bases or not skirmish then
82540: LD_EXP 61
82544: NOT
82545: PUSH
82546: LD_EXP 59
82550: NOT
82551: OR
82552: IFFALSE 82556
// exit ;
82554: GO 82755
// for i = 1 to mc_bases do
82556: LD_ADDR_VAR 0 5
82560: PUSH
82561: DOUBLE
82562: LD_INT 1
82564: DEC
82565: ST_TO_ADDR
82566: LD_EXP 61
82570: PUSH
82571: FOR_TO
82572: IFFALSE 82753
// if building in mc_bases [ i ] then
82574: LD_VAR 0 1
82578: PUSH
82579: LD_EXP 61
82583: PUSH
82584: LD_VAR 0 5
82588: ARRAY
82589: IN
82590: IFFALSE 82751
// begin tmp := mc_bases [ i ] diff building ;
82592: LD_ADDR_VAR 0 6
82596: PUSH
82597: LD_EXP 61
82601: PUSH
82602: LD_VAR 0 5
82606: ARRAY
82607: PUSH
82608: LD_VAR 0 1
82612: DIFF
82613: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82614: LD_ADDR_EXP 61
82618: PUSH
82619: LD_EXP 61
82623: PPUSH
82624: LD_VAR 0 5
82628: PPUSH
82629: LD_VAR 0 6
82633: PPUSH
82634: CALL_OW 1
82638: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82639: LD_VAR 0 1
82643: PUSH
82644: LD_EXP 69
82648: PUSH
82649: LD_VAR 0 5
82653: ARRAY
82654: IN
82655: IFFALSE 82694
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82657: LD_ADDR_EXP 69
82661: PUSH
82662: LD_EXP 69
82666: PPUSH
82667: LD_VAR 0 5
82671: PPUSH
82672: LD_EXP 69
82676: PUSH
82677: LD_VAR 0 5
82681: ARRAY
82682: PUSH
82683: LD_VAR 0 1
82687: DIFF
82688: PPUSH
82689: CALL_OW 1
82693: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82694: LD_VAR 0 1
82698: PUSH
82699: LD_EXP 70
82703: PUSH
82704: LD_VAR 0 5
82708: ARRAY
82709: IN
82710: IFFALSE 82749
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82712: LD_ADDR_EXP 70
82716: PUSH
82717: LD_EXP 70
82721: PPUSH
82722: LD_VAR 0 5
82726: PPUSH
82727: LD_EXP 70
82731: PUSH
82732: LD_VAR 0 5
82736: ARRAY
82737: PUSH
82738: LD_VAR 0 1
82742: DIFF
82743: PPUSH
82744: CALL_OW 1
82748: ST_TO_ADDR
// break ;
82749: GO 82753
// end ;
82751: GO 82571
82753: POP
82754: POP
// end ;
82755: LD_VAR 0 4
82759: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82760: LD_INT 0
82762: PPUSH
82763: PPUSH
82764: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82765: LD_EXP 61
82769: NOT
82770: PUSH
82771: LD_EXP 59
82775: NOT
82776: OR
82777: PUSH
82778: LD_VAR 0 3
82782: PUSH
82783: LD_EXP 87
82787: IN
82788: NOT
82789: OR
82790: IFFALSE 82794
// exit ;
82792: GO 82917
// for i = 1 to mc_vehicles do
82794: LD_ADDR_VAR 0 6
82798: PUSH
82799: DOUBLE
82800: LD_INT 1
82802: DEC
82803: ST_TO_ADDR
82804: LD_EXP 80
82808: PUSH
82809: FOR_TO
82810: IFFALSE 82915
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82812: LD_VAR 0 2
82816: PUSH
82817: LD_EXP 80
82821: PUSH
82822: LD_VAR 0 6
82826: ARRAY
82827: IN
82828: PUSH
82829: LD_VAR 0 1
82833: PUSH
82834: LD_EXP 80
82838: PUSH
82839: LD_VAR 0 6
82843: ARRAY
82844: IN
82845: OR
82846: IFFALSE 82913
// begin tmp := mc_vehicles [ i ] diff old ;
82848: LD_ADDR_VAR 0 7
82852: PUSH
82853: LD_EXP 80
82857: PUSH
82858: LD_VAR 0 6
82862: ARRAY
82863: PUSH
82864: LD_VAR 0 2
82868: DIFF
82869: ST_TO_ADDR
// tmp := tmp diff new ;
82870: LD_ADDR_VAR 0 7
82874: PUSH
82875: LD_VAR 0 7
82879: PUSH
82880: LD_VAR 0 1
82884: DIFF
82885: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82886: LD_ADDR_EXP 80
82890: PUSH
82891: LD_EXP 80
82895: PPUSH
82896: LD_VAR 0 6
82900: PPUSH
82901: LD_VAR 0 7
82905: PPUSH
82906: CALL_OW 1
82910: ST_TO_ADDR
// break ;
82911: GO 82915
// end ;
82913: GO 82809
82915: POP
82916: POP
// end ;
82917: LD_VAR 0 5
82921: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82922: LD_INT 0
82924: PPUSH
82925: PPUSH
82926: PPUSH
82927: PPUSH
// if not mc_bases or not skirmish then
82928: LD_EXP 61
82932: NOT
82933: PUSH
82934: LD_EXP 59
82938: NOT
82939: OR
82940: IFFALSE 82944
// exit ;
82942: GO 83326
// side := GetSide ( vehicle ) ;
82944: LD_ADDR_VAR 0 5
82948: PUSH
82949: LD_VAR 0 1
82953: PPUSH
82954: CALL_OW 255
82958: ST_TO_ADDR
// for i = 1 to mc_bases do
82959: LD_ADDR_VAR 0 4
82963: PUSH
82964: DOUBLE
82965: LD_INT 1
82967: DEC
82968: ST_TO_ADDR
82969: LD_EXP 61
82973: PUSH
82974: FOR_TO
82975: IFFALSE 83324
// begin if factory in mc_bases [ i ] then
82977: LD_VAR 0 2
82981: PUSH
82982: LD_EXP 61
82986: PUSH
82987: LD_VAR 0 4
82991: ARRAY
82992: IN
82993: IFFALSE 83322
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
82995: LD_EXP 83
82999: PUSH
83000: LD_VAR 0 4
83004: ARRAY
83005: PUSH
83006: LD_EXP 72
83010: PUSH
83011: LD_VAR 0 4
83015: ARRAY
83016: LESS
83017: PUSH
83018: LD_VAR 0 1
83022: PPUSH
83023: CALL_OW 264
83027: PUSH
83028: LD_INT 31
83030: PUSH
83031: LD_INT 32
83033: PUSH
83034: LD_INT 51
83036: PUSH
83037: LD_INT 89
83039: PUSH
83040: LD_INT 12
83042: PUSH
83043: LD_INT 30
83045: PUSH
83046: LD_INT 98
83048: PUSH
83049: LD_INT 11
83051: PUSH
83052: LD_INT 53
83054: PUSH
83055: LD_INT 14
83057: PUSH
83058: LD_INT 91
83060: PUSH
83061: LD_INT 29
83063: PUSH
83064: LD_INT 99
83066: PUSH
83067: LD_INT 13
83069: PUSH
83070: LD_INT 52
83072: PUSH
83073: LD_INT 88
83075: PUSH
83076: LD_INT 48
83078: PUSH
83079: LD_INT 8
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: IN
83102: NOT
83103: AND
83104: IFFALSE 83152
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83106: LD_ADDR_EXP 83
83110: PUSH
83111: LD_EXP 83
83115: PPUSH
83116: LD_VAR 0 4
83120: PUSH
83121: LD_EXP 83
83125: PUSH
83126: LD_VAR 0 4
83130: ARRAY
83131: PUSH
83132: LD_INT 1
83134: PLUS
83135: PUSH
83136: EMPTY
83137: LIST
83138: LIST
83139: PPUSH
83140: LD_VAR 0 1
83144: PPUSH
83145: CALL 20070 0 3
83149: ST_TO_ADDR
83150: GO 83196
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83152: LD_ADDR_EXP 80
83156: PUSH
83157: LD_EXP 80
83161: PPUSH
83162: LD_VAR 0 4
83166: PUSH
83167: LD_EXP 80
83171: PUSH
83172: LD_VAR 0 4
83176: ARRAY
83177: PUSH
83178: LD_INT 1
83180: PLUS
83181: PUSH
83182: EMPTY
83183: LIST
83184: LIST
83185: PPUSH
83186: LD_VAR 0 1
83190: PPUSH
83191: CALL 20070 0 3
83195: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83196: LD_VAR 0 1
83200: PPUSH
83201: CALL_OW 263
83205: PUSH
83206: LD_INT 2
83208: EQUAL
83209: IFFALSE 83238
// begin repeat wait ( 0 0$3 ) ;
83211: LD_INT 105
83213: PPUSH
83214: CALL_OW 67
// Connect ( vehicle ) ;
83218: LD_VAR 0 1
83222: PPUSH
83223: CALL 23039 0 1
// until IsControledBy ( vehicle ) ;
83227: LD_VAR 0 1
83231: PPUSH
83232: CALL_OW 312
83236: IFFALSE 83211
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83238: LD_VAR 0 1
83242: PPUSH
83243: LD_EXP 85
83247: PUSH
83248: LD_VAR 0 4
83252: ARRAY
83253: PPUSH
83254: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83258: LD_VAR 0 1
83262: PPUSH
83263: CALL_OW 263
83267: PUSH
83268: LD_INT 1
83270: NONEQUAL
83271: IFFALSE 83275
// break ;
83273: GO 83324
// repeat wait ( 0 0$1 ) ;
83275: LD_INT 35
83277: PPUSH
83278: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83282: LD_VAR 0 1
83286: PPUSH
83287: LD_EXP 85
83291: PUSH
83292: LD_VAR 0 4
83296: ARRAY
83297: PPUSH
83298: CALL_OW 308
83302: IFFALSE 83275
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83304: LD_VAR 0 1
83308: PPUSH
83309: CALL_OW 311
83313: PPUSH
83314: CALL_OW 121
// exit ;
83318: POP
83319: POP
83320: GO 83326
// end ; end ;
83322: GO 82974
83324: POP
83325: POP
// end ;
83326: LD_VAR 0 3
83330: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83331: LD_INT 0
83333: PPUSH
83334: PPUSH
83335: PPUSH
83336: PPUSH
// if not mc_bases or not skirmish then
83337: LD_EXP 61
83341: NOT
83342: PUSH
83343: LD_EXP 59
83347: NOT
83348: OR
83349: IFFALSE 83353
// exit ;
83351: GO 83706
// repeat wait ( 0 0$1 ) ;
83353: LD_INT 35
83355: PPUSH
83356: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83360: LD_VAR 0 2
83364: PPUSH
83365: LD_VAR 0 3
83369: PPUSH
83370: CALL_OW 284
83374: IFFALSE 83353
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83376: LD_VAR 0 2
83380: PPUSH
83381: LD_VAR 0 3
83385: PPUSH
83386: CALL_OW 283
83390: PUSH
83391: LD_INT 4
83393: EQUAL
83394: IFFALSE 83398
// exit ;
83396: GO 83706
// for i = 1 to mc_bases do
83398: LD_ADDR_VAR 0 7
83402: PUSH
83403: DOUBLE
83404: LD_INT 1
83406: DEC
83407: ST_TO_ADDR
83408: LD_EXP 61
83412: PUSH
83413: FOR_TO
83414: IFFALSE 83704
// begin if mc_crates_area [ i ] then
83416: LD_EXP 79
83420: PUSH
83421: LD_VAR 0 7
83425: ARRAY
83426: IFFALSE 83537
// for j in mc_crates_area [ i ] do
83428: LD_ADDR_VAR 0 8
83432: PUSH
83433: LD_EXP 79
83437: PUSH
83438: LD_VAR 0 7
83442: ARRAY
83443: PUSH
83444: FOR_IN
83445: IFFALSE 83535
// if InArea ( x , y , j ) then
83447: LD_VAR 0 2
83451: PPUSH
83452: LD_VAR 0 3
83456: PPUSH
83457: LD_VAR 0 8
83461: PPUSH
83462: CALL_OW 309
83466: IFFALSE 83533
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83468: LD_ADDR_EXP 77
83472: PUSH
83473: LD_EXP 77
83477: PPUSH
83478: LD_VAR 0 7
83482: PUSH
83483: LD_EXP 77
83487: PUSH
83488: LD_VAR 0 7
83492: ARRAY
83493: PUSH
83494: LD_INT 1
83496: PLUS
83497: PUSH
83498: EMPTY
83499: LIST
83500: LIST
83501: PPUSH
83502: LD_VAR 0 4
83506: PUSH
83507: LD_VAR 0 2
83511: PUSH
83512: LD_VAR 0 3
83516: PUSH
83517: EMPTY
83518: LIST
83519: LIST
83520: LIST
83521: PPUSH
83522: CALL 20070 0 3
83526: ST_TO_ADDR
// exit ;
83527: POP
83528: POP
83529: POP
83530: POP
83531: GO 83706
// end ;
83533: GO 83444
83535: POP
83536: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83537: LD_ADDR_VAR 0 9
83541: PUSH
83542: LD_EXP 61
83546: PUSH
83547: LD_VAR 0 7
83551: ARRAY
83552: PPUSH
83553: LD_INT 2
83555: PUSH
83556: LD_INT 30
83558: PUSH
83559: LD_INT 0
83561: PUSH
83562: EMPTY
83563: LIST
83564: LIST
83565: PUSH
83566: LD_INT 30
83568: PUSH
83569: LD_INT 1
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: LIST
83580: PPUSH
83581: CALL_OW 72
83585: ST_TO_ADDR
// if not depot then
83586: LD_VAR 0 9
83590: NOT
83591: IFFALSE 83595
// continue ;
83593: GO 83413
// for j in depot do
83595: LD_ADDR_VAR 0 8
83599: PUSH
83600: LD_VAR 0 9
83604: PUSH
83605: FOR_IN
83606: IFFALSE 83700
// if GetDistUnitXY ( j , x , y ) < 30 then
83608: LD_VAR 0 8
83612: PPUSH
83613: LD_VAR 0 2
83617: PPUSH
83618: LD_VAR 0 3
83622: PPUSH
83623: CALL_OW 297
83627: PUSH
83628: LD_INT 30
83630: LESS
83631: IFFALSE 83698
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83633: LD_ADDR_EXP 77
83637: PUSH
83638: LD_EXP 77
83642: PPUSH
83643: LD_VAR 0 7
83647: PUSH
83648: LD_EXP 77
83652: PUSH
83653: LD_VAR 0 7
83657: ARRAY
83658: PUSH
83659: LD_INT 1
83661: PLUS
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PPUSH
83667: LD_VAR 0 4
83671: PUSH
83672: LD_VAR 0 2
83676: PUSH
83677: LD_VAR 0 3
83681: PUSH
83682: EMPTY
83683: LIST
83684: LIST
83685: LIST
83686: PPUSH
83687: CALL 20070 0 3
83691: ST_TO_ADDR
// exit ;
83692: POP
83693: POP
83694: POP
83695: POP
83696: GO 83706
// end ;
83698: GO 83605
83700: POP
83701: POP
// end ;
83702: GO 83413
83704: POP
83705: POP
// end ;
83706: LD_VAR 0 6
83710: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83711: LD_INT 0
83713: PPUSH
83714: PPUSH
83715: PPUSH
83716: PPUSH
// if not mc_bases or not skirmish then
83717: LD_EXP 61
83721: NOT
83722: PUSH
83723: LD_EXP 59
83727: NOT
83728: OR
83729: IFFALSE 83733
// exit ;
83731: GO 84010
// side := GetSide ( lab ) ;
83733: LD_ADDR_VAR 0 4
83737: PUSH
83738: LD_VAR 0 2
83742: PPUSH
83743: CALL_OW 255
83747: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83748: LD_VAR 0 4
83752: PUSH
83753: LD_EXP 87
83757: IN
83758: NOT
83759: PUSH
83760: LD_EXP 88
83764: NOT
83765: OR
83766: PUSH
83767: LD_EXP 61
83771: NOT
83772: OR
83773: IFFALSE 83777
// exit ;
83775: GO 84010
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83777: LD_ADDR_EXP 88
83781: PUSH
83782: LD_EXP 88
83786: PPUSH
83787: LD_VAR 0 4
83791: PPUSH
83792: LD_EXP 88
83796: PUSH
83797: LD_VAR 0 4
83801: ARRAY
83802: PUSH
83803: LD_VAR 0 1
83807: DIFF
83808: PPUSH
83809: CALL_OW 1
83813: ST_TO_ADDR
// for i = 1 to mc_bases do
83814: LD_ADDR_VAR 0 5
83818: PUSH
83819: DOUBLE
83820: LD_INT 1
83822: DEC
83823: ST_TO_ADDR
83824: LD_EXP 61
83828: PUSH
83829: FOR_TO
83830: IFFALSE 84008
// begin if lab in mc_bases [ i ] then
83832: LD_VAR 0 2
83836: PUSH
83837: LD_EXP 61
83841: PUSH
83842: LD_VAR 0 5
83846: ARRAY
83847: IN
83848: IFFALSE 84006
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83850: LD_VAR 0 1
83854: PUSH
83855: LD_INT 11
83857: PUSH
83858: LD_INT 4
83860: PUSH
83861: LD_INT 3
83863: PUSH
83864: LD_INT 2
83866: PUSH
83867: EMPTY
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: IN
83873: PUSH
83874: LD_EXP 91
83878: PUSH
83879: LD_VAR 0 5
83883: ARRAY
83884: AND
83885: IFFALSE 84006
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83887: LD_ADDR_VAR 0 6
83891: PUSH
83892: LD_EXP 91
83896: PUSH
83897: LD_VAR 0 5
83901: ARRAY
83902: PUSH
83903: LD_INT 1
83905: ARRAY
83906: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83907: LD_ADDR_EXP 91
83911: PUSH
83912: LD_EXP 91
83916: PPUSH
83917: LD_VAR 0 5
83921: PPUSH
83922: EMPTY
83923: PPUSH
83924: CALL_OW 1
83928: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83929: LD_VAR 0 6
83933: PPUSH
83934: LD_INT 0
83936: PPUSH
83937: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83941: LD_VAR 0 6
83945: PPUSH
83946: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83950: LD_ADDR_EXP 90
83954: PUSH
83955: LD_EXP 90
83959: PPUSH
83960: LD_VAR 0 5
83964: PPUSH
83965: LD_EXP 90
83969: PUSH
83970: LD_VAR 0 5
83974: ARRAY
83975: PPUSH
83976: LD_INT 1
83978: PPUSH
83979: LD_VAR 0 6
83983: PPUSH
83984: CALL_OW 2
83988: PPUSH
83989: CALL_OW 1
83993: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83994: LD_VAR 0 5
83998: PPUSH
83999: LD_INT 112
84001: PPUSH
84002: CALL 60496 0 2
// end ; end ; end ;
84006: GO 83829
84008: POP
84009: POP
// end ;
84010: LD_VAR 0 3
84014: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84015: LD_INT 0
84017: PPUSH
84018: PPUSH
84019: PPUSH
84020: PPUSH
84021: PPUSH
84022: PPUSH
84023: PPUSH
84024: PPUSH
// if not mc_bases or not skirmish then
84025: LD_EXP 61
84029: NOT
84030: PUSH
84031: LD_EXP 59
84035: NOT
84036: OR
84037: IFFALSE 84041
// exit ;
84039: GO 85410
// for i = 1 to mc_bases do
84041: LD_ADDR_VAR 0 3
84045: PUSH
84046: DOUBLE
84047: LD_INT 1
84049: DEC
84050: ST_TO_ADDR
84051: LD_EXP 61
84055: PUSH
84056: FOR_TO
84057: IFFALSE 85408
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84059: LD_VAR 0 1
84063: PUSH
84064: LD_EXP 61
84068: PUSH
84069: LD_VAR 0 3
84073: ARRAY
84074: IN
84075: PUSH
84076: LD_VAR 0 1
84080: PUSH
84081: LD_EXP 68
84085: PUSH
84086: LD_VAR 0 3
84090: ARRAY
84091: IN
84092: OR
84093: PUSH
84094: LD_VAR 0 1
84098: PUSH
84099: LD_EXP 83
84103: PUSH
84104: LD_VAR 0 3
84108: ARRAY
84109: IN
84110: OR
84111: PUSH
84112: LD_VAR 0 1
84116: PUSH
84117: LD_EXP 80
84121: PUSH
84122: LD_VAR 0 3
84126: ARRAY
84127: IN
84128: OR
84129: PUSH
84130: LD_VAR 0 1
84134: PUSH
84135: LD_EXP 90
84139: PUSH
84140: LD_VAR 0 3
84144: ARRAY
84145: IN
84146: OR
84147: PUSH
84148: LD_VAR 0 1
84152: PUSH
84153: LD_EXP 91
84157: PUSH
84158: LD_VAR 0 3
84162: ARRAY
84163: IN
84164: OR
84165: IFFALSE 85406
// begin if un in mc_ape [ i ] then
84167: LD_VAR 0 1
84171: PUSH
84172: LD_EXP 90
84176: PUSH
84177: LD_VAR 0 3
84181: ARRAY
84182: IN
84183: IFFALSE 84222
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84185: LD_ADDR_EXP 90
84189: PUSH
84190: LD_EXP 90
84194: PPUSH
84195: LD_VAR 0 3
84199: PPUSH
84200: LD_EXP 90
84204: PUSH
84205: LD_VAR 0 3
84209: ARRAY
84210: PUSH
84211: LD_VAR 0 1
84215: DIFF
84216: PPUSH
84217: CALL_OW 1
84221: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84222: LD_VAR 0 1
84226: PUSH
84227: LD_EXP 91
84231: PUSH
84232: LD_VAR 0 3
84236: ARRAY
84237: IN
84238: IFFALSE 84262
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84240: LD_ADDR_EXP 91
84244: PUSH
84245: LD_EXP 91
84249: PPUSH
84250: LD_VAR 0 3
84254: PPUSH
84255: EMPTY
84256: PPUSH
84257: CALL_OW 1
84261: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84262: LD_VAR 0 1
84266: PPUSH
84267: CALL_OW 247
84271: PUSH
84272: LD_INT 2
84274: EQUAL
84275: PUSH
84276: LD_VAR 0 1
84280: PPUSH
84281: CALL_OW 110
84285: PUSH
84286: LD_INT 20
84288: EQUAL
84289: PUSH
84290: LD_VAR 0 1
84294: PUSH
84295: LD_EXP 83
84299: PUSH
84300: LD_VAR 0 3
84304: ARRAY
84305: IN
84306: OR
84307: PUSH
84308: LD_VAR 0 1
84312: PPUSH
84313: CALL_OW 264
84317: PUSH
84318: LD_INT 12
84320: PUSH
84321: LD_INT 51
84323: PUSH
84324: LD_INT 89
84326: PUSH
84327: LD_INT 32
84329: PUSH
84330: LD_INT 13
84332: PUSH
84333: LD_INT 52
84335: PUSH
84336: LD_INT 31
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: IN
84348: OR
84349: AND
84350: IFFALSE 84658
// begin if un in mc_defender [ i ] then
84352: LD_VAR 0 1
84356: PUSH
84357: LD_EXP 83
84361: PUSH
84362: LD_VAR 0 3
84366: ARRAY
84367: IN
84368: IFFALSE 84407
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84370: LD_ADDR_EXP 83
84374: PUSH
84375: LD_EXP 83
84379: PPUSH
84380: LD_VAR 0 3
84384: PPUSH
84385: LD_EXP 83
84389: PUSH
84390: LD_VAR 0 3
84394: ARRAY
84395: PUSH
84396: LD_VAR 0 1
84400: DIFF
84401: PPUSH
84402: CALL_OW 1
84406: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84407: LD_ADDR_VAR 0 8
84411: PUSH
84412: LD_VAR 0 3
84416: PPUSH
84417: LD_INT 3
84419: PPUSH
84420: CALL 81066 0 2
84424: ST_TO_ADDR
// if fac then
84425: LD_VAR 0 8
84429: IFFALSE 84658
// begin for j in fac do
84431: LD_ADDR_VAR 0 4
84435: PUSH
84436: LD_VAR 0 8
84440: PUSH
84441: FOR_IN
84442: IFFALSE 84656
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84444: LD_ADDR_VAR 0 9
84448: PUSH
84449: LD_VAR 0 8
84453: PPUSH
84454: LD_VAR 0 1
84458: PPUSH
84459: CALL_OW 265
84463: PPUSH
84464: LD_VAR 0 1
84468: PPUSH
84469: CALL_OW 262
84473: PPUSH
84474: LD_VAR 0 1
84478: PPUSH
84479: CALL_OW 263
84483: PPUSH
84484: LD_VAR 0 1
84488: PPUSH
84489: CALL_OW 264
84493: PPUSH
84494: CALL 17568 0 5
84498: ST_TO_ADDR
// if components then
84499: LD_VAR 0 9
84503: IFFALSE 84654
// begin if GetWeapon ( un ) = ar_control_tower then
84505: LD_VAR 0 1
84509: PPUSH
84510: CALL_OW 264
84514: PUSH
84515: LD_INT 31
84517: EQUAL
84518: IFFALSE 84635
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84520: LD_VAR 0 1
84524: PPUSH
84525: CALL_OW 311
84529: PPUSH
84530: LD_INT 0
84532: PPUSH
84533: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84537: LD_ADDR_EXP 101
84541: PUSH
84542: LD_EXP 101
84546: PPUSH
84547: LD_VAR 0 3
84551: PPUSH
84552: LD_EXP 101
84556: PUSH
84557: LD_VAR 0 3
84561: ARRAY
84562: PUSH
84563: LD_VAR 0 1
84567: PPUSH
84568: CALL_OW 311
84572: DIFF
84573: PPUSH
84574: CALL_OW 1
84578: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84579: LD_ADDR_VAR 0 7
84583: PUSH
84584: LD_EXP 82
84588: PUSH
84589: LD_VAR 0 3
84593: ARRAY
84594: PPUSH
84595: LD_INT 1
84597: PPUSH
84598: LD_VAR 0 9
84602: PPUSH
84603: CALL_OW 2
84607: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84608: LD_ADDR_EXP 82
84612: PUSH
84613: LD_EXP 82
84617: PPUSH
84618: LD_VAR 0 3
84622: PPUSH
84623: LD_VAR 0 7
84627: PPUSH
84628: CALL_OW 1
84632: ST_TO_ADDR
// end else
84633: GO 84652
// MC_InsertProduceList ( i , [ components ] ) ;
84635: LD_VAR 0 3
84639: PPUSH
84640: LD_VAR 0 9
84644: PUSH
84645: EMPTY
84646: LIST
84647: PPUSH
84648: CALL 80611 0 2
// break ;
84652: GO 84656
// end ; end ;
84654: GO 84441
84656: POP
84657: POP
// end ; end ; if GetType ( un ) = unit_building then
84658: LD_VAR 0 1
84662: PPUSH
84663: CALL_OW 247
84667: PUSH
84668: LD_INT 3
84670: EQUAL
84671: IFFALSE 85074
// begin btype := GetBType ( un ) ;
84673: LD_ADDR_VAR 0 5
84677: PUSH
84678: LD_VAR 0 1
84682: PPUSH
84683: CALL_OW 266
84687: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84688: LD_VAR 0 5
84692: PUSH
84693: LD_INT 29
84695: PUSH
84696: LD_INT 30
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: IN
84703: IFFALSE 84776
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84705: LD_VAR 0 1
84709: PPUSH
84710: CALL_OW 250
84714: PPUSH
84715: LD_VAR 0 1
84719: PPUSH
84720: CALL_OW 251
84724: PPUSH
84725: LD_VAR 0 1
84729: PPUSH
84730: CALL_OW 255
84734: PPUSH
84735: CALL_OW 440
84739: NOT
84740: IFFALSE 84776
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84742: LD_VAR 0 1
84746: PPUSH
84747: CALL_OW 250
84751: PPUSH
84752: LD_VAR 0 1
84756: PPUSH
84757: CALL_OW 251
84761: PPUSH
84762: LD_VAR 0 1
84766: PPUSH
84767: CALL_OW 255
84771: PPUSH
84772: CALL_OW 441
// end ; if btype = b_warehouse then
84776: LD_VAR 0 5
84780: PUSH
84781: LD_INT 1
84783: EQUAL
84784: IFFALSE 84802
// begin btype := b_depot ;
84786: LD_ADDR_VAR 0 5
84790: PUSH
84791: LD_INT 0
84793: ST_TO_ADDR
// pos := 1 ;
84794: LD_ADDR_VAR 0 6
84798: PUSH
84799: LD_INT 1
84801: ST_TO_ADDR
// end ; if btype = b_factory then
84802: LD_VAR 0 5
84806: PUSH
84807: LD_INT 3
84809: EQUAL
84810: IFFALSE 84828
// begin btype := b_workshop ;
84812: LD_ADDR_VAR 0 5
84816: PUSH
84817: LD_INT 2
84819: ST_TO_ADDR
// pos := 1 ;
84820: LD_ADDR_VAR 0 6
84824: PUSH
84825: LD_INT 1
84827: ST_TO_ADDR
// end ; if btype = b_barracks then
84828: LD_VAR 0 5
84832: PUSH
84833: LD_INT 5
84835: EQUAL
84836: IFFALSE 84846
// btype := b_armoury ;
84838: LD_ADDR_VAR 0 5
84842: PUSH
84843: LD_INT 4
84845: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84846: LD_VAR 0 5
84850: PUSH
84851: LD_INT 7
84853: PUSH
84854: LD_INT 8
84856: PUSH
84857: EMPTY
84858: LIST
84859: LIST
84860: IN
84861: IFFALSE 84871
// btype := b_lab ;
84863: LD_ADDR_VAR 0 5
84867: PUSH
84868: LD_INT 6
84870: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84871: LD_ADDR_EXP 66
84875: PUSH
84876: LD_EXP 66
84880: PPUSH
84881: LD_VAR 0 3
84885: PUSH
84886: LD_EXP 66
84890: PUSH
84891: LD_VAR 0 3
84895: ARRAY
84896: PUSH
84897: LD_INT 1
84899: PLUS
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PPUSH
84905: LD_VAR 0 5
84909: PUSH
84910: LD_VAR 0 1
84914: PPUSH
84915: CALL_OW 250
84919: PUSH
84920: LD_VAR 0 1
84924: PPUSH
84925: CALL_OW 251
84929: PUSH
84930: LD_VAR 0 1
84934: PPUSH
84935: CALL_OW 254
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: PPUSH
84946: CALL 20070 0 3
84950: ST_TO_ADDR
// if pos = 1 then
84951: LD_VAR 0 6
84955: PUSH
84956: LD_INT 1
84958: EQUAL
84959: IFFALSE 85074
// begin tmp := mc_build_list [ i ] ;
84961: LD_ADDR_VAR 0 7
84965: PUSH
84966: LD_EXP 66
84970: PUSH
84971: LD_VAR 0 3
84975: ARRAY
84976: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84977: LD_VAR 0 7
84981: PPUSH
84982: LD_INT 2
84984: PUSH
84985: LD_INT 30
84987: PUSH
84988: LD_INT 0
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 30
84997: PUSH
84998: LD_INT 1
85000: PUSH
85001: EMPTY
85002: LIST
85003: LIST
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: LIST
85009: PPUSH
85010: CALL_OW 72
85014: IFFALSE 85024
// pos := 2 ;
85016: LD_ADDR_VAR 0 6
85020: PUSH
85021: LD_INT 2
85023: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85024: LD_ADDR_VAR 0 7
85028: PUSH
85029: LD_VAR 0 7
85033: PPUSH
85034: LD_VAR 0 6
85038: PPUSH
85039: LD_VAR 0 7
85043: PPUSH
85044: CALL 20396 0 3
85048: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85049: LD_ADDR_EXP 66
85053: PUSH
85054: LD_EXP 66
85058: PPUSH
85059: LD_VAR 0 3
85063: PPUSH
85064: LD_VAR 0 7
85068: PPUSH
85069: CALL_OW 1
85073: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85074: LD_VAR 0 1
85078: PUSH
85079: LD_EXP 61
85083: PUSH
85084: LD_VAR 0 3
85088: ARRAY
85089: IN
85090: IFFALSE 85129
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85092: LD_ADDR_EXP 61
85096: PUSH
85097: LD_EXP 61
85101: PPUSH
85102: LD_VAR 0 3
85106: PPUSH
85107: LD_EXP 61
85111: PUSH
85112: LD_VAR 0 3
85116: ARRAY
85117: PUSH
85118: LD_VAR 0 1
85122: DIFF
85123: PPUSH
85124: CALL_OW 1
85128: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85129: LD_VAR 0 1
85133: PUSH
85134: LD_EXP 68
85138: PUSH
85139: LD_VAR 0 3
85143: ARRAY
85144: IN
85145: IFFALSE 85184
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85147: LD_ADDR_EXP 68
85151: PUSH
85152: LD_EXP 68
85156: PPUSH
85157: LD_VAR 0 3
85161: PPUSH
85162: LD_EXP 68
85166: PUSH
85167: LD_VAR 0 3
85171: ARRAY
85172: PUSH
85173: LD_VAR 0 1
85177: DIFF
85178: PPUSH
85179: CALL_OW 1
85183: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85184: LD_VAR 0 1
85188: PUSH
85189: LD_EXP 80
85193: PUSH
85194: LD_VAR 0 3
85198: ARRAY
85199: IN
85200: IFFALSE 85239
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85202: LD_ADDR_EXP 80
85206: PUSH
85207: LD_EXP 80
85211: PPUSH
85212: LD_VAR 0 3
85216: PPUSH
85217: LD_EXP 80
85221: PUSH
85222: LD_VAR 0 3
85226: ARRAY
85227: PUSH
85228: LD_VAR 0 1
85232: DIFF
85233: PPUSH
85234: CALL_OW 1
85238: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85239: LD_VAR 0 1
85243: PUSH
85244: LD_EXP 83
85248: PUSH
85249: LD_VAR 0 3
85253: ARRAY
85254: IN
85255: IFFALSE 85294
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85257: LD_ADDR_EXP 83
85261: PUSH
85262: LD_EXP 83
85266: PPUSH
85267: LD_VAR 0 3
85271: PPUSH
85272: LD_EXP 83
85276: PUSH
85277: LD_VAR 0 3
85281: ARRAY
85282: PUSH
85283: LD_VAR 0 1
85287: DIFF
85288: PPUSH
85289: CALL_OW 1
85293: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85294: LD_VAR 0 1
85298: PUSH
85299: LD_EXP 70
85303: PUSH
85304: LD_VAR 0 3
85308: ARRAY
85309: IN
85310: IFFALSE 85349
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85312: LD_ADDR_EXP 70
85316: PUSH
85317: LD_EXP 70
85321: PPUSH
85322: LD_VAR 0 3
85326: PPUSH
85327: LD_EXP 70
85331: PUSH
85332: LD_VAR 0 3
85336: ARRAY
85337: PUSH
85338: LD_VAR 0 1
85342: DIFF
85343: PPUSH
85344: CALL_OW 1
85348: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85349: LD_VAR 0 1
85353: PUSH
85354: LD_EXP 69
85358: PUSH
85359: LD_VAR 0 3
85363: ARRAY
85364: IN
85365: IFFALSE 85404
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85367: LD_ADDR_EXP 69
85371: PUSH
85372: LD_EXP 69
85376: PPUSH
85377: LD_VAR 0 3
85381: PPUSH
85382: LD_EXP 69
85386: PUSH
85387: LD_VAR 0 3
85391: ARRAY
85392: PUSH
85393: LD_VAR 0 1
85397: DIFF
85398: PPUSH
85399: CALL_OW 1
85403: ST_TO_ADDR
// end ; break ;
85404: GO 85408
// end ;
85406: GO 84056
85408: POP
85409: POP
// end ;
85410: LD_VAR 0 2
85414: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85415: LD_INT 0
85417: PPUSH
85418: PPUSH
85419: PPUSH
// if not mc_bases or not skirmish then
85420: LD_EXP 61
85424: NOT
85425: PUSH
85426: LD_EXP 59
85430: NOT
85431: OR
85432: IFFALSE 85436
// exit ;
85434: GO 85651
// for i = 1 to mc_bases do
85436: LD_ADDR_VAR 0 3
85440: PUSH
85441: DOUBLE
85442: LD_INT 1
85444: DEC
85445: ST_TO_ADDR
85446: LD_EXP 61
85450: PUSH
85451: FOR_TO
85452: IFFALSE 85649
// begin if building in mc_construct_list [ i ] then
85454: LD_VAR 0 1
85458: PUSH
85459: LD_EXP 68
85463: PUSH
85464: LD_VAR 0 3
85468: ARRAY
85469: IN
85470: IFFALSE 85647
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85472: LD_ADDR_EXP 68
85476: PUSH
85477: LD_EXP 68
85481: PPUSH
85482: LD_VAR 0 3
85486: PPUSH
85487: LD_EXP 68
85491: PUSH
85492: LD_VAR 0 3
85496: ARRAY
85497: PUSH
85498: LD_VAR 0 1
85502: DIFF
85503: PPUSH
85504: CALL_OW 1
85508: ST_TO_ADDR
// if building in mc_lab [ i ] then
85509: LD_VAR 0 1
85513: PUSH
85514: LD_EXP 94
85518: PUSH
85519: LD_VAR 0 3
85523: ARRAY
85524: IN
85525: IFFALSE 85580
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85527: LD_ADDR_EXP 95
85531: PUSH
85532: LD_EXP 95
85536: PPUSH
85537: LD_VAR 0 3
85541: PPUSH
85542: LD_EXP 95
85546: PUSH
85547: LD_VAR 0 3
85551: ARRAY
85552: PPUSH
85553: LD_INT 1
85555: PPUSH
85556: LD_EXP 95
85560: PUSH
85561: LD_VAR 0 3
85565: ARRAY
85566: PPUSH
85567: LD_INT 0
85569: PPUSH
85570: CALL 19488 0 4
85574: PPUSH
85575: CALL_OW 1
85579: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85580: LD_VAR 0 1
85584: PUSH
85585: LD_EXP 61
85589: PUSH
85590: LD_VAR 0 3
85594: ARRAY
85595: IN
85596: NOT
85597: IFFALSE 85643
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85599: LD_ADDR_EXP 61
85603: PUSH
85604: LD_EXP 61
85608: PPUSH
85609: LD_VAR 0 3
85613: PUSH
85614: LD_EXP 61
85618: PUSH
85619: LD_VAR 0 3
85623: ARRAY
85624: PUSH
85625: LD_INT 1
85627: PLUS
85628: PUSH
85629: EMPTY
85630: LIST
85631: LIST
85632: PPUSH
85633: LD_VAR 0 1
85637: PPUSH
85638: CALL 20070 0 3
85642: ST_TO_ADDR
// exit ;
85643: POP
85644: POP
85645: GO 85651
// end ; end ;
85647: GO 85451
85649: POP
85650: POP
// end ;
85651: LD_VAR 0 2
85655: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85656: LD_INT 0
85658: PPUSH
85659: PPUSH
85660: PPUSH
85661: PPUSH
85662: PPUSH
85663: PPUSH
85664: PPUSH
// if not mc_bases or not skirmish then
85665: LD_EXP 61
85669: NOT
85670: PUSH
85671: LD_EXP 59
85675: NOT
85676: OR
85677: IFFALSE 85681
// exit ;
85679: GO 86342
// for i = 1 to mc_bases do
85681: LD_ADDR_VAR 0 3
85685: PUSH
85686: DOUBLE
85687: LD_INT 1
85689: DEC
85690: ST_TO_ADDR
85691: LD_EXP 61
85695: PUSH
85696: FOR_TO
85697: IFFALSE 86340
// begin if building in mc_construct_list [ i ] then
85699: LD_VAR 0 1
85703: PUSH
85704: LD_EXP 68
85708: PUSH
85709: LD_VAR 0 3
85713: ARRAY
85714: IN
85715: IFFALSE 86338
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85717: LD_ADDR_EXP 68
85721: PUSH
85722: LD_EXP 68
85726: PPUSH
85727: LD_VAR 0 3
85731: PPUSH
85732: LD_EXP 68
85736: PUSH
85737: LD_VAR 0 3
85741: ARRAY
85742: PUSH
85743: LD_VAR 0 1
85747: DIFF
85748: PPUSH
85749: CALL_OW 1
85753: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85754: LD_ADDR_EXP 61
85758: PUSH
85759: LD_EXP 61
85763: PPUSH
85764: LD_VAR 0 3
85768: PUSH
85769: LD_EXP 61
85773: PUSH
85774: LD_VAR 0 3
85778: ARRAY
85779: PUSH
85780: LD_INT 1
85782: PLUS
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PPUSH
85788: LD_VAR 0 1
85792: PPUSH
85793: CALL 20070 0 3
85797: ST_TO_ADDR
// btype := GetBType ( building ) ;
85798: LD_ADDR_VAR 0 5
85802: PUSH
85803: LD_VAR 0 1
85807: PPUSH
85808: CALL_OW 266
85812: ST_TO_ADDR
// side := GetSide ( building ) ;
85813: LD_ADDR_VAR 0 8
85817: PUSH
85818: LD_VAR 0 1
85822: PPUSH
85823: CALL_OW 255
85827: ST_TO_ADDR
// if btype = b_lab then
85828: LD_VAR 0 5
85832: PUSH
85833: LD_INT 6
85835: EQUAL
85836: IFFALSE 85886
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85838: LD_ADDR_EXP 94
85842: PUSH
85843: LD_EXP 94
85847: PPUSH
85848: LD_VAR 0 3
85852: PUSH
85853: LD_EXP 94
85857: PUSH
85858: LD_VAR 0 3
85862: ARRAY
85863: PUSH
85864: LD_INT 1
85866: PLUS
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PPUSH
85872: LD_VAR 0 1
85876: PPUSH
85877: CALL 20070 0 3
85881: ST_TO_ADDR
// exit ;
85882: POP
85883: POP
85884: GO 86342
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85886: LD_VAR 0 5
85890: PUSH
85891: LD_INT 0
85893: PUSH
85894: LD_INT 2
85896: PUSH
85897: LD_INT 4
85899: PUSH
85900: EMPTY
85901: LIST
85902: LIST
85903: LIST
85904: IN
85905: IFFALSE 86029
// begin if btype = b_armoury then
85907: LD_VAR 0 5
85911: PUSH
85912: LD_INT 4
85914: EQUAL
85915: IFFALSE 85925
// btype := b_barracks ;
85917: LD_ADDR_VAR 0 5
85921: PUSH
85922: LD_INT 5
85924: ST_TO_ADDR
// if btype = b_depot then
85925: LD_VAR 0 5
85929: PUSH
85930: LD_INT 0
85932: EQUAL
85933: IFFALSE 85943
// btype := b_warehouse ;
85935: LD_ADDR_VAR 0 5
85939: PUSH
85940: LD_INT 1
85942: ST_TO_ADDR
// if btype = b_workshop then
85943: LD_VAR 0 5
85947: PUSH
85948: LD_INT 2
85950: EQUAL
85951: IFFALSE 85961
// btype := b_factory ;
85953: LD_ADDR_VAR 0 5
85957: PUSH
85958: LD_INT 3
85960: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85961: LD_VAR 0 5
85965: PPUSH
85966: LD_VAR 0 8
85970: PPUSH
85971: CALL_OW 323
85975: PUSH
85976: LD_INT 1
85978: EQUAL
85979: IFFALSE 86025
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85981: LD_ADDR_EXP 93
85985: PUSH
85986: LD_EXP 93
85990: PPUSH
85991: LD_VAR 0 3
85995: PUSH
85996: LD_EXP 93
86000: PUSH
86001: LD_VAR 0 3
86005: ARRAY
86006: PUSH
86007: LD_INT 1
86009: PLUS
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PPUSH
86015: LD_VAR 0 1
86019: PPUSH
86020: CALL 20070 0 3
86024: ST_TO_ADDR
// exit ;
86025: POP
86026: POP
86027: GO 86342
// end ; if btype in [ b_bunker , b_turret ] then
86029: LD_VAR 0 5
86033: PUSH
86034: LD_INT 32
86036: PUSH
86037: LD_INT 33
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: IN
86044: IFFALSE 86334
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86046: LD_ADDR_EXP 69
86050: PUSH
86051: LD_EXP 69
86055: PPUSH
86056: LD_VAR 0 3
86060: PUSH
86061: LD_EXP 69
86065: PUSH
86066: LD_VAR 0 3
86070: ARRAY
86071: PUSH
86072: LD_INT 1
86074: PLUS
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PPUSH
86080: LD_VAR 0 1
86084: PPUSH
86085: CALL 20070 0 3
86089: ST_TO_ADDR
// if btype = b_bunker then
86090: LD_VAR 0 5
86094: PUSH
86095: LD_INT 32
86097: EQUAL
86098: IFFALSE 86334
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86100: LD_ADDR_EXP 70
86104: PUSH
86105: LD_EXP 70
86109: PPUSH
86110: LD_VAR 0 3
86114: PUSH
86115: LD_EXP 70
86119: PUSH
86120: LD_VAR 0 3
86124: ARRAY
86125: PUSH
86126: LD_INT 1
86128: PLUS
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: PPUSH
86134: LD_VAR 0 1
86138: PPUSH
86139: CALL 20070 0 3
86143: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86144: LD_ADDR_VAR 0 6
86148: PUSH
86149: LD_EXP 61
86153: PUSH
86154: LD_VAR 0 3
86158: ARRAY
86159: PPUSH
86160: LD_INT 25
86162: PUSH
86163: LD_INT 1
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 3
86172: PUSH
86173: LD_INT 54
86175: PUSH
86176: EMPTY
86177: LIST
86178: PUSH
86179: EMPTY
86180: LIST
86181: LIST
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PPUSH
86187: CALL_OW 72
86191: ST_TO_ADDR
// if tmp then
86192: LD_VAR 0 6
86196: IFFALSE 86202
// exit ;
86198: POP
86199: POP
86200: GO 86342
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86202: LD_ADDR_VAR 0 6
86206: PUSH
86207: LD_EXP 61
86211: PUSH
86212: LD_VAR 0 3
86216: ARRAY
86217: PPUSH
86218: LD_INT 2
86220: PUSH
86221: LD_INT 30
86223: PUSH
86224: LD_INT 4
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 30
86233: PUSH
86234: LD_INT 5
86236: PUSH
86237: EMPTY
86238: LIST
86239: LIST
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: LIST
86245: PPUSH
86246: CALL_OW 72
86250: ST_TO_ADDR
// if not tmp then
86251: LD_VAR 0 6
86255: NOT
86256: IFFALSE 86262
// exit ;
86258: POP
86259: POP
86260: GO 86342
// for j in tmp do
86262: LD_ADDR_VAR 0 4
86266: PUSH
86267: LD_VAR 0 6
86271: PUSH
86272: FOR_IN
86273: IFFALSE 86332
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86275: LD_ADDR_VAR 0 7
86279: PUSH
86280: LD_VAR 0 4
86284: PPUSH
86285: CALL_OW 313
86289: PPUSH
86290: LD_INT 25
86292: PUSH
86293: LD_INT 1
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PPUSH
86300: CALL_OW 72
86304: ST_TO_ADDR
// if units then
86305: LD_VAR 0 7
86309: IFFALSE 86330
// begin ComExitBuilding ( units [ 1 ] ) ;
86311: LD_VAR 0 7
86315: PUSH
86316: LD_INT 1
86318: ARRAY
86319: PPUSH
86320: CALL_OW 122
// exit ;
86324: POP
86325: POP
86326: POP
86327: POP
86328: GO 86342
// end ; end ;
86330: GO 86272
86332: POP
86333: POP
// end ; end ; exit ;
86334: POP
86335: POP
86336: GO 86342
// end ; end ;
86338: GO 85696
86340: POP
86341: POP
// end ;
86342: LD_VAR 0 2
86346: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86347: LD_INT 0
86349: PPUSH
86350: PPUSH
86351: PPUSH
86352: PPUSH
86353: PPUSH
86354: PPUSH
86355: PPUSH
// if not mc_bases or not skirmish then
86356: LD_EXP 61
86360: NOT
86361: PUSH
86362: LD_EXP 59
86366: NOT
86367: OR
86368: IFFALSE 86372
// exit ;
86370: GO 86637
// btype := GetBType ( building ) ;
86372: LD_ADDR_VAR 0 6
86376: PUSH
86377: LD_VAR 0 1
86381: PPUSH
86382: CALL_OW 266
86386: ST_TO_ADDR
// x := GetX ( building ) ;
86387: LD_ADDR_VAR 0 7
86391: PUSH
86392: LD_VAR 0 1
86396: PPUSH
86397: CALL_OW 250
86401: ST_TO_ADDR
// y := GetY ( building ) ;
86402: LD_ADDR_VAR 0 8
86406: PUSH
86407: LD_VAR 0 1
86411: PPUSH
86412: CALL_OW 251
86416: ST_TO_ADDR
// d := GetDir ( building ) ;
86417: LD_ADDR_VAR 0 9
86421: PUSH
86422: LD_VAR 0 1
86426: PPUSH
86427: CALL_OW 254
86431: ST_TO_ADDR
// for i = 1 to mc_bases do
86432: LD_ADDR_VAR 0 4
86436: PUSH
86437: DOUBLE
86438: LD_INT 1
86440: DEC
86441: ST_TO_ADDR
86442: LD_EXP 61
86446: PUSH
86447: FOR_TO
86448: IFFALSE 86635
// begin if not mc_build_list [ i ] then
86450: LD_EXP 66
86454: PUSH
86455: LD_VAR 0 4
86459: ARRAY
86460: NOT
86461: IFFALSE 86465
// continue ;
86463: GO 86447
// for j := 1 to mc_build_list [ i ] do
86465: LD_ADDR_VAR 0 5
86469: PUSH
86470: DOUBLE
86471: LD_INT 1
86473: DEC
86474: ST_TO_ADDR
86475: LD_EXP 66
86479: PUSH
86480: LD_VAR 0 4
86484: ARRAY
86485: PUSH
86486: FOR_TO
86487: IFFALSE 86631
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86489: LD_VAR 0 6
86493: PUSH
86494: LD_VAR 0 7
86498: PUSH
86499: LD_VAR 0 8
86503: PUSH
86504: LD_VAR 0 9
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: PPUSH
86515: LD_EXP 66
86519: PUSH
86520: LD_VAR 0 4
86524: ARRAY
86525: PUSH
86526: LD_VAR 0 5
86530: ARRAY
86531: PPUSH
86532: CALL 26250 0 2
86536: IFFALSE 86629
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86538: LD_ADDR_EXP 66
86542: PUSH
86543: LD_EXP 66
86547: PPUSH
86548: LD_VAR 0 4
86552: PPUSH
86553: LD_EXP 66
86557: PUSH
86558: LD_VAR 0 4
86562: ARRAY
86563: PPUSH
86564: LD_VAR 0 5
86568: PPUSH
86569: CALL_OW 3
86573: PPUSH
86574: CALL_OW 1
86578: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86579: LD_ADDR_EXP 68
86583: PUSH
86584: LD_EXP 68
86588: PPUSH
86589: LD_VAR 0 4
86593: PUSH
86594: LD_EXP 68
86598: PUSH
86599: LD_VAR 0 4
86603: ARRAY
86604: PUSH
86605: LD_INT 1
86607: PLUS
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PPUSH
86613: LD_VAR 0 1
86617: PPUSH
86618: CALL 20070 0 3
86622: ST_TO_ADDR
// exit ;
86623: POP
86624: POP
86625: POP
86626: POP
86627: GO 86637
// end ;
86629: GO 86486
86631: POP
86632: POP
// end ;
86633: GO 86447
86635: POP
86636: POP
// end ;
86637: LD_VAR 0 3
86641: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86642: LD_INT 0
86644: PPUSH
86645: PPUSH
86646: PPUSH
// if not mc_bases or not skirmish then
86647: LD_EXP 61
86651: NOT
86652: PUSH
86653: LD_EXP 59
86657: NOT
86658: OR
86659: IFFALSE 86663
// exit ;
86661: GO 86853
// for i = 1 to mc_bases do
86663: LD_ADDR_VAR 0 4
86667: PUSH
86668: DOUBLE
86669: LD_INT 1
86671: DEC
86672: ST_TO_ADDR
86673: LD_EXP 61
86677: PUSH
86678: FOR_TO
86679: IFFALSE 86766
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86681: LD_VAR 0 1
86685: PUSH
86686: LD_EXP 69
86690: PUSH
86691: LD_VAR 0 4
86695: ARRAY
86696: IN
86697: PUSH
86698: LD_VAR 0 1
86702: PUSH
86703: LD_EXP 70
86707: PUSH
86708: LD_VAR 0 4
86712: ARRAY
86713: IN
86714: NOT
86715: AND
86716: IFFALSE 86764
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86718: LD_ADDR_EXP 70
86722: PUSH
86723: LD_EXP 70
86727: PPUSH
86728: LD_VAR 0 4
86732: PUSH
86733: LD_EXP 70
86737: PUSH
86738: LD_VAR 0 4
86742: ARRAY
86743: PUSH
86744: LD_INT 1
86746: PLUS
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PPUSH
86752: LD_VAR 0 1
86756: PPUSH
86757: CALL 20070 0 3
86761: ST_TO_ADDR
// break ;
86762: GO 86766
// end ; end ;
86764: GO 86678
86766: POP
86767: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86768: LD_VAR 0 1
86772: PPUSH
86773: CALL_OW 257
86777: PUSH
86778: LD_EXP 87
86782: IN
86783: PUSH
86784: LD_VAR 0 1
86788: PPUSH
86789: CALL_OW 266
86793: PUSH
86794: LD_INT 5
86796: EQUAL
86797: AND
86798: PUSH
86799: LD_VAR 0 2
86803: PPUSH
86804: CALL_OW 110
86808: PUSH
86809: LD_INT 18
86811: NONEQUAL
86812: AND
86813: IFFALSE 86853
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86815: LD_VAR 0 2
86819: PPUSH
86820: CALL_OW 257
86824: PUSH
86825: LD_INT 5
86827: PUSH
86828: LD_INT 8
86830: PUSH
86831: LD_INT 9
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: LIST
86838: IN
86839: IFFALSE 86853
// SetClass ( unit , 1 ) ;
86841: LD_VAR 0 2
86845: PPUSH
86846: LD_INT 1
86848: PPUSH
86849: CALL_OW 336
// end ;
86853: LD_VAR 0 3
86857: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86858: LD_INT 0
86860: PPUSH
86861: PPUSH
// if not mc_bases or not skirmish then
86862: LD_EXP 61
86866: NOT
86867: PUSH
86868: LD_EXP 59
86872: NOT
86873: OR
86874: IFFALSE 86878
// exit ;
86876: GO 86994
// if GetLives ( abandoned_vehicle ) > 250 then
86878: LD_VAR 0 2
86882: PPUSH
86883: CALL_OW 256
86887: PUSH
86888: LD_INT 250
86890: GREATER
86891: IFFALSE 86895
// exit ;
86893: GO 86994
// for i = 1 to mc_bases do
86895: LD_ADDR_VAR 0 6
86899: PUSH
86900: DOUBLE
86901: LD_INT 1
86903: DEC
86904: ST_TO_ADDR
86905: LD_EXP 61
86909: PUSH
86910: FOR_TO
86911: IFFALSE 86992
// begin if driver in mc_bases [ i ] then
86913: LD_VAR 0 1
86917: PUSH
86918: LD_EXP 61
86922: PUSH
86923: LD_VAR 0 6
86927: ARRAY
86928: IN
86929: IFFALSE 86990
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86931: LD_VAR 0 1
86935: PPUSH
86936: LD_EXP 61
86940: PUSH
86941: LD_VAR 0 6
86945: ARRAY
86946: PPUSH
86947: LD_INT 2
86949: PUSH
86950: LD_INT 30
86952: PUSH
86953: LD_INT 0
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 30
86962: PUSH
86963: LD_INT 1
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: LIST
86974: PPUSH
86975: CALL_OW 72
86979: PUSH
86980: LD_INT 1
86982: ARRAY
86983: PPUSH
86984: CALL 53259 0 2
// break ;
86988: GO 86992
// end ; end ;
86990: GO 86910
86992: POP
86993: POP
// end ; end_of_file end_of_file
86994: LD_VAR 0 5
86998: RET
// every 0 0$1 do
86999: GO 87001
87001: DISABLE
// begin enable ;
87002: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87003: LD_STRING updateTimer(
87005: PUSH
87006: LD_OWVAR 1
87010: STR
87011: PUSH
87012: LD_STRING );
87014: STR
87015: PPUSH
87016: CALL_OW 559
// end ;
87020: END
// export function SOS_MapStart ( ) ; begin
87021: LD_INT 0
87023: PPUSH
// if streamModeActive then
87024: LD_EXP 105
87028: IFFALSE 87037
// DefineStreamItems ( true ) ;
87030: LD_INT 1
87032: PPUSH
87033: CALL 88691 0 1
// UpdateFactoryWaypoints ( ) ;
87037: CALL 101552 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87041: CALL 101809 0 0
// end ;
87045: LD_VAR 0 1
87049: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87050: LD_INT 0
87052: PPUSH
// if p2 = hack_mode then
87053: LD_VAR 0 2
87057: PUSH
87058: LD_INT 100
87060: EQUAL
87061: IFFALSE 88064
// begin if not StreamModeActive then
87063: LD_EXP 105
87067: NOT
87068: IFFALSE 87078
// StreamModeActive := true ;
87070: LD_ADDR_EXP 105
87074: PUSH
87075: LD_INT 1
87077: ST_TO_ADDR
// if p3 = 0 then
87078: LD_VAR 0 3
87082: PUSH
87083: LD_INT 0
87085: EQUAL
87086: IFFALSE 87092
// InitStreamMode ;
87088: CALL 88227 0 0
// if p3 = 1 then
87092: LD_VAR 0 3
87096: PUSH
87097: LD_INT 1
87099: EQUAL
87100: IFFALSE 87110
// sRocket := true ;
87102: LD_ADDR_EXP 110
87106: PUSH
87107: LD_INT 1
87109: ST_TO_ADDR
// if p3 = 2 then
87110: LD_VAR 0 3
87114: PUSH
87115: LD_INT 2
87117: EQUAL
87118: IFFALSE 87128
// sSpeed := true ;
87120: LD_ADDR_EXP 109
87124: PUSH
87125: LD_INT 1
87127: ST_TO_ADDR
// if p3 = 3 then
87128: LD_VAR 0 3
87132: PUSH
87133: LD_INT 3
87135: EQUAL
87136: IFFALSE 87146
// sEngine := true ;
87138: LD_ADDR_EXP 111
87142: PUSH
87143: LD_INT 1
87145: ST_TO_ADDR
// if p3 = 4 then
87146: LD_VAR 0 3
87150: PUSH
87151: LD_INT 4
87153: EQUAL
87154: IFFALSE 87164
// sSpec := true ;
87156: LD_ADDR_EXP 108
87160: PUSH
87161: LD_INT 1
87163: ST_TO_ADDR
// if p3 = 5 then
87164: LD_VAR 0 3
87168: PUSH
87169: LD_INT 5
87171: EQUAL
87172: IFFALSE 87182
// sLevel := true ;
87174: LD_ADDR_EXP 112
87178: PUSH
87179: LD_INT 1
87181: ST_TO_ADDR
// if p3 = 6 then
87182: LD_VAR 0 3
87186: PUSH
87187: LD_INT 6
87189: EQUAL
87190: IFFALSE 87200
// sArmoury := true ;
87192: LD_ADDR_EXP 113
87196: PUSH
87197: LD_INT 1
87199: ST_TO_ADDR
// if p3 = 7 then
87200: LD_VAR 0 3
87204: PUSH
87205: LD_INT 7
87207: EQUAL
87208: IFFALSE 87218
// sRadar := true ;
87210: LD_ADDR_EXP 114
87214: PUSH
87215: LD_INT 1
87217: ST_TO_ADDR
// if p3 = 8 then
87218: LD_VAR 0 3
87222: PUSH
87223: LD_INT 8
87225: EQUAL
87226: IFFALSE 87236
// sBunker := true ;
87228: LD_ADDR_EXP 115
87232: PUSH
87233: LD_INT 1
87235: ST_TO_ADDR
// if p3 = 9 then
87236: LD_VAR 0 3
87240: PUSH
87241: LD_INT 9
87243: EQUAL
87244: IFFALSE 87254
// sHack := true ;
87246: LD_ADDR_EXP 116
87250: PUSH
87251: LD_INT 1
87253: ST_TO_ADDR
// if p3 = 10 then
87254: LD_VAR 0 3
87258: PUSH
87259: LD_INT 10
87261: EQUAL
87262: IFFALSE 87272
// sFire := true ;
87264: LD_ADDR_EXP 117
87268: PUSH
87269: LD_INT 1
87271: ST_TO_ADDR
// if p3 = 11 then
87272: LD_VAR 0 3
87276: PUSH
87277: LD_INT 11
87279: EQUAL
87280: IFFALSE 87290
// sRefresh := true ;
87282: LD_ADDR_EXP 118
87286: PUSH
87287: LD_INT 1
87289: ST_TO_ADDR
// if p3 = 12 then
87290: LD_VAR 0 3
87294: PUSH
87295: LD_INT 12
87297: EQUAL
87298: IFFALSE 87308
// sExp := true ;
87300: LD_ADDR_EXP 119
87304: PUSH
87305: LD_INT 1
87307: ST_TO_ADDR
// if p3 = 13 then
87308: LD_VAR 0 3
87312: PUSH
87313: LD_INT 13
87315: EQUAL
87316: IFFALSE 87326
// sDepot := true ;
87318: LD_ADDR_EXP 120
87322: PUSH
87323: LD_INT 1
87325: ST_TO_ADDR
// if p3 = 14 then
87326: LD_VAR 0 3
87330: PUSH
87331: LD_INT 14
87333: EQUAL
87334: IFFALSE 87344
// sFlag := true ;
87336: LD_ADDR_EXP 121
87340: PUSH
87341: LD_INT 1
87343: ST_TO_ADDR
// if p3 = 15 then
87344: LD_VAR 0 3
87348: PUSH
87349: LD_INT 15
87351: EQUAL
87352: IFFALSE 87362
// sKamikadze := true ;
87354: LD_ADDR_EXP 129
87358: PUSH
87359: LD_INT 1
87361: ST_TO_ADDR
// if p3 = 16 then
87362: LD_VAR 0 3
87366: PUSH
87367: LD_INT 16
87369: EQUAL
87370: IFFALSE 87380
// sTroll := true ;
87372: LD_ADDR_EXP 130
87376: PUSH
87377: LD_INT 1
87379: ST_TO_ADDR
// if p3 = 17 then
87380: LD_VAR 0 3
87384: PUSH
87385: LD_INT 17
87387: EQUAL
87388: IFFALSE 87398
// sSlow := true ;
87390: LD_ADDR_EXP 131
87394: PUSH
87395: LD_INT 1
87397: ST_TO_ADDR
// if p3 = 18 then
87398: LD_VAR 0 3
87402: PUSH
87403: LD_INT 18
87405: EQUAL
87406: IFFALSE 87416
// sLack := true ;
87408: LD_ADDR_EXP 132
87412: PUSH
87413: LD_INT 1
87415: ST_TO_ADDR
// if p3 = 19 then
87416: LD_VAR 0 3
87420: PUSH
87421: LD_INT 19
87423: EQUAL
87424: IFFALSE 87434
// sTank := true ;
87426: LD_ADDR_EXP 134
87430: PUSH
87431: LD_INT 1
87433: ST_TO_ADDR
// if p3 = 20 then
87434: LD_VAR 0 3
87438: PUSH
87439: LD_INT 20
87441: EQUAL
87442: IFFALSE 87452
// sRemote := true ;
87444: LD_ADDR_EXP 135
87448: PUSH
87449: LD_INT 1
87451: ST_TO_ADDR
// if p3 = 21 then
87452: LD_VAR 0 3
87456: PUSH
87457: LD_INT 21
87459: EQUAL
87460: IFFALSE 87470
// sPowell := true ;
87462: LD_ADDR_EXP 136
87466: PUSH
87467: LD_INT 1
87469: ST_TO_ADDR
// if p3 = 22 then
87470: LD_VAR 0 3
87474: PUSH
87475: LD_INT 22
87477: EQUAL
87478: IFFALSE 87488
// sTeleport := true ;
87480: LD_ADDR_EXP 139
87484: PUSH
87485: LD_INT 1
87487: ST_TO_ADDR
// if p3 = 23 then
87488: LD_VAR 0 3
87492: PUSH
87493: LD_INT 23
87495: EQUAL
87496: IFFALSE 87506
// sOilTower := true ;
87498: LD_ADDR_EXP 141
87502: PUSH
87503: LD_INT 1
87505: ST_TO_ADDR
// if p3 = 24 then
87506: LD_VAR 0 3
87510: PUSH
87511: LD_INT 24
87513: EQUAL
87514: IFFALSE 87524
// sShovel := true ;
87516: LD_ADDR_EXP 142
87520: PUSH
87521: LD_INT 1
87523: ST_TO_ADDR
// if p3 = 25 then
87524: LD_VAR 0 3
87528: PUSH
87529: LD_INT 25
87531: EQUAL
87532: IFFALSE 87542
// sSheik := true ;
87534: LD_ADDR_EXP 143
87538: PUSH
87539: LD_INT 1
87541: ST_TO_ADDR
// if p3 = 26 then
87542: LD_VAR 0 3
87546: PUSH
87547: LD_INT 26
87549: EQUAL
87550: IFFALSE 87560
// sEarthquake := true ;
87552: LD_ADDR_EXP 145
87556: PUSH
87557: LD_INT 1
87559: ST_TO_ADDR
// if p3 = 27 then
87560: LD_VAR 0 3
87564: PUSH
87565: LD_INT 27
87567: EQUAL
87568: IFFALSE 87578
// sAI := true ;
87570: LD_ADDR_EXP 146
87574: PUSH
87575: LD_INT 1
87577: ST_TO_ADDR
// if p3 = 28 then
87578: LD_VAR 0 3
87582: PUSH
87583: LD_INT 28
87585: EQUAL
87586: IFFALSE 87596
// sCargo := true ;
87588: LD_ADDR_EXP 149
87592: PUSH
87593: LD_INT 1
87595: ST_TO_ADDR
// if p3 = 29 then
87596: LD_VAR 0 3
87600: PUSH
87601: LD_INT 29
87603: EQUAL
87604: IFFALSE 87614
// sDLaser := true ;
87606: LD_ADDR_EXP 150
87610: PUSH
87611: LD_INT 1
87613: ST_TO_ADDR
// if p3 = 30 then
87614: LD_VAR 0 3
87618: PUSH
87619: LD_INT 30
87621: EQUAL
87622: IFFALSE 87632
// sExchange := true ;
87624: LD_ADDR_EXP 151
87628: PUSH
87629: LD_INT 1
87631: ST_TO_ADDR
// if p3 = 31 then
87632: LD_VAR 0 3
87636: PUSH
87637: LD_INT 31
87639: EQUAL
87640: IFFALSE 87650
// sFac := true ;
87642: LD_ADDR_EXP 152
87646: PUSH
87647: LD_INT 1
87649: ST_TO_ADDR
// if p3 = 32 then
87650: LD_VAR 0 3
87654: PUSH
87655: LD_INT 32
87657: EQUAL
87658: IFFALSE 87668
// sPower := true ;
87660: LD_ADDR_EXP 153
87664: PUSH
87665: LD_INT 1
87667: ST_TO_ADDR
// if p3 = 33 then
87668: LD_VAR 0 3
87672: PUSH
87673: LD_INT 33
87675: EQUAL
87676: IFFALSE 87686
// sRandom := true ;
87678: LD_ADDR_EXP 154
87682: PUSH
87683: LD_INT 1
87685: ST_TO_ADDR
// if p3 = 34 then
87686: LD_VAR 0 3
87690: PUSH
87691: LD_INT 34
87693: EQUAL
87694: IFFALSE 87704
// sShield := true ;
87696: LD_ADDR_EXP 155
87700: PUSH
87701: LD_INT 1
87703: ST_TO_ADDR
// if p3 = 35 then
87704: LD_VAR 0 3
87708: PUSH
87709: LD_INT 35
87711: EQUAL
87712: IFFALSE 87722
// sTime := true ;
87714: LD_ADDR_EXP 156
87718: PUSH
87719: LD_INT 1
87721: ST_TO_ADDR
// if p3 = 36 then
87722: LD_VAR 0 3
87726: PUSH
87727: LD_INT 36
87729: EQUAL
87730: IFFALSE 87740
// sTools := true ;
87732: LD_ADDR_EXP 157
87736: PUSH
87737: LD_INT 1
87739: ST_TO_ADDR
// if p3 = 101 then
87740: LD_VAR 0 3
87744: PUSH
87745: LD_INT 101
87747: EQUAL
87748: IFFALSE 87758
// sSold := true ;
87750: LD_ADDR_EXP 122
87754: PUSH
87755: LD_INT 1
87757: ST_TO_ADDR
// if p3 = 102 then
87758: LD_VAR 0 3
87762: PUSH
87763: LD_INT 102
87765: EQUAL
87766: IFFALSE 87776
// sDiff := true ;
87768: LD_ADDR_EXP 123
87772: PUSH
87773: LD_INT 1
87775: ST_TO_ADDR
// if p3 = 103 then
87776: LD_VAR 0 3
87780: PUSH
87781: LD_INT 103
87783: EQUAL
87784: IFFALSE 87794
// sFog := true ;
87786: LD_ADDR_EXP 126
87790: PUSH
87791: LD_INT 1
87793: ST_TO_ADDR
// if p3 = 104 then
87794: LD_VAR 0 3
87798: PUSH
87799: LD_INT 104
87801: EQUAL
87802: IFFALSE 87812
// sReset := true ;
87804: LD_ADDR_EXP 127
87808: PUSH
87809: LD_INT 1
87811: ST_TO_ADDR
// if p3 = 105 then
87812: LD_VAR 0 3
87816: PUSH
87817: LD_INT 105
87819: EQUAL
87820: IFFALSE 87830
// sSun := true ;
87822: LD_ADDR_EXP 128
87826: PUSH
87827: LD_INT 1
87829: ST_TO_ADDR
// if p3 = 106 then
87830: LD_VAR 0 3
87834: PUSH
87835: LD_INT 106
87837: EQUAL
87838: IFFALSE 87848
// sTiger := true ;
87840: LD_ADDR_EXP 124
87844: PUSH
87845: LD_INT 1
87847: ST_TO_ADDR
// if p3 = 107 then
87848: LD_VAR 0 3
87852: PUSH
87853: LD_INT 107
87855: EQUAL
87856: IFFALSE 87866
// sBomb := true ;
87858: LD_ADDR_EXP 125
87862: PUSH
87863: LD_INT 1
87865: ST_TO_ADDR
// if p3 = 108 then
87866: LD_VAR 0 3
87870: PUSH
87871: LD_INT 108
87873: EQUAL
87874: IFFALSE 87884
// sWound := true ;
87876: LD_ADDR_EXP 133
87880: PUSH
87881: LD_INT 1
87883: ST_TO_ADDR
// if p3 = 109 then
87884: LD_VAR 0 3
87888: PUSH
87889: LD_INT 109
87891: EQUAL
87892: IFFALSE 87902
// sBetray := true ;
87894: LD_ADDR_EXP 137
87898: PUSH
87899: LD_INT 1
87901: ST_TO_ADDR
// if p3 = 110 then
87902: LD_VAR 0 3
87906: PUSH
87907: LD_INT 110
87909: EQUAL
87910: IFFALSE 87920
// sContamin := true ;
87912: LD_ADDR_EXP 138
87916: PUSH
87917: LD_INT 1
87919: ST_TO_ADDR
// if p3 = 111 then
87920: LD_VAR 0 3
87924: PUSH
87925: LD_INT 111
87927: EQUAL
87928: IFFALSE 87938
// sOil := true ;
87930: LD_ADDR_EXP 140
87934: PUSH
87935: LD_INT 1
87937: ST_TO_ADDR
// if p3 = 112 then
87938: LD_VAR 0 3
87942: PUSH
87943: LD_INT 112
87945: EQUAL
87946: IFFALSE 87956
// sStu := true ;
87948: LD_ADDR_EXP 144
87952: PUSH
87953: LD_INT 1
87955: ST_TO_ADDR
// if p3 = 113 then
87956: LD_VAR 0 3
87960: PUSH
87961: LD_INT 113
87963: EQUAL
87964: IFFALSE 87974
// sBazooka := true ;
87966: LD_ADDR_EXP 147
87970: PUSH
87971: LD_INT 1
87973: ST_TO_ADDR
// if p3 = 114 then
87974: LD_VAR 0 3
87978: PUSH
87979: LD_INT 114
87981: EQUAL
87982: IFFALSE 87992
// sMortar := true ;
87984: LD_ADDR_EXP 148
87988: PUSH
87989: LD_INT 1
87991: ST_TO_ADDR
// if p3 = 115 then
87992: LD_VAR 0 3
87996: PUSH
87997: LD_INT 115
87999: EQUAL
88000: IFFALSE 88010
// sRanger := true ;
88002: LD_ADDR_EXP 158
88006: PUSH
88007: LD_INT 1
88009: ST_TO_ADDR
// if p3 = 116 then
88010: LD_VAR 0 3
88014: PUSH
88015: LD_INT 116
88017: EQUAL
88018: IFFALSE 88028
// sComputer := true ;
88020: LD_ADDR_EXP 159
88024: PUSH
88025: LD_INT 1
88027: ST_TO_ADDR
// if p3 = 117 then
88028: LD_VAR 0 3
88032: PUSH
88033: LD_INT 117
88035: EQUAL
88036: IFFALSE 88046
// s30 := true ;
88038: LD_ADDR_EXP 160
88042: PUSH
88043: LD_INT 1
88045: ST_TO_ADDR
// if p3 = 118 then
88046: LD_VAR 0 3
88050: PUSH
88051: LD_INT 118
88053: EQUAL
88054: IFFALSE 88064
// s60 := true ;
88056: LD_ADDR_EXP 161
88060: PUSH
88061: LD_INT 1
88063: ST_TO_ADDR
// end ; if p2 = stream_mode then
88064: LD_VAR 0 2
88068: PUSH
88069: LD_INT 101
88071: EQUAL
88072: IFFALSE 88200
// begin case p3 of 1 :
88074: LD_VAR 0 3
88078: PUSH
88079: LD_INT 1
88081: DOUBLE
88082: EQUAL
88083: IFTRUE 88087
88085: GO 88094
88087: POP
// hHackUnlimitedResources ; 2 :
88088: CALL 100298 0 0
88092: GO 88200
88094: LD_INT 2
88096: DOUBLE
88097: EQUAL
88098: IFTRUE 88102
88100: GO 88109
88102: POP
// hHackSetLevel10 ; 3 :
88103: CALL 100431 0 0
88107: GO 88200
88109: LD_INT 3
88111: DOUBLE
88112: EQUAL
88113: IFTRUE 88117
88115: GO 88124
88117: POP
// hHackSetLevel10YourUnits ; 4 :
88118: CALL 100516 0 0
88122: GO 88200
88124: LD_INT 4
88126: DOUBLE
88127: EQUAL
88128: IFTRUE 88132
88130: GO 88139
88132: POP
// hHackInvincible ; 5 :
88133: CALL 100964 0 0
88137: GO 88200
88139: LD_INT 5
88141: DOUBLE
88142: EQUAL
88143: IFTRUE 88147
88145: GO 88154
88147: POP
// hHackInvisible ; 6 :
88148: CALL 101075 0 0
88152: GO 88200
88154: LD_INT 6
88156: DOUBLE
88157: EQUAL
88158: IFTRUE 88162
88160: GO 88169
88162: POP
// hHackChangeYourSide ; 7 :
88163: CALL 101132 0 0
88167: GO 88200
88169: LD_INT 7
88171: DOUBLE
88172: EQUAL
88173: IFTRUE 88177
88175: GO 88184
88177: POP
// hHackChangeUnitSide ; 8 :
88178: CALL 101174 0 0
88182: GO 88200
88184: LD_INT 8
88186: DOUBLE
88187: EQUAL
88188: IFTRUE 88192
88190: GO 88199
88192: POP
// hHackFog ; end ;
88193: CALL 101275 0 0
88197: GO 88200
88199: POP
// end ; end ;
88200: LD_VAR 0 7
88204: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
88205: GO 88207
88207: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88208: LD_STRING initStreamRollete();
88210: PPUSH
88211: CALL_OW 559
// InitStreamMode ;
88215: CALL 88227 0 0
// DefineStreamItems ( false ) ;
88219: LD_INT 0
88221: PPUSH
88222: CALL 88691 0 1
// end ;
88226: END
// function InitStreamMode ; begin
88227: LD_INT 0
88229: PPUSH
// streamModeActive := false ;
88230: LD_ADDR_EXP 105
88234: PUSH
88235: LD_INT 0
88237: ST_TO_ADDR
// normalCounter := 36 ;
88238: LD_ADDR_EXP 106
88242: PUSH
88243: LD_INT 36
88245: ST_TO_ADDR
// hardcoreCounter := 18 ;
88246: LD_ADDR_EXP 107
88250: PUSH
88251: LD_INT 18
88253: ST_TO_ADDR
// sRocket := false ;
88254: LD_ADDR_EXP 110
88258: PUSH
88259: LD_INT 0
88261: ST_TO_ADDR
// sSpeed := false ;
88262: LD_ADDR_EXP 109
88266: PUSH
88267: LD_INT 0
88269: ST_TO_ADDR
// sEngine := false ;
88270: LD_ADDR_EXP 111
88274: PUSH
88275: LD_INT 0
88277: ST_TO_ADDR
// sSpec := false ;
88278: LD_ADDR_EXP 108
88282: PUSH
88283: LD_INT 0
88285: ST_TO_ADDR
// sLevel := false ;
88286: LD_ADDR_EXP 112
88290: PUSH
88291: LD_INT 0
88293: ST_TO_ADDR
// sArmoury := false ;
88294: LD_ADDR_EXP 113
88298: PUSH
88299: LD_INT 0
88301: ST_TO_ADDR
// sRadar := false ;
88302: LD_ADDR_EXP 114
88306: PUSH
88307: LD_INT 0
88309: ST_TO_ADDR
// sBunker := false ;
88310: LD_ADDR_EXP 115
88314: PUSH
88315: LD_INT 0
88317: ST_TO_ADDR
// sHack := false ;
88318: LD_ADDR_EXP 116
88322: PUSH
88323: LD_INT 0
88325: ST_TO_ADDR
// sFire := false ;
88326: LD_ADDR_EXP 117
88330: PUSH
88331: LD_INT 0
88333: ST_TO_ADDR
// sRefresh := false ;
88334: LD_ADDR_EXP 118
88338: PUSH
88339: LD_INT 0
88341: ST_TO_ADDR
// sExp := false ;
88342: LD_ADDR_EXP 119
88346: PUSH
88347: LD_INT 0
88349: ST_TO_ADDR
// sDepot := false ;
88350: LD_ADDR_EXP 120
88354: PUSH
88355: LD_INT 0
88357: ST_TO_ADDR
// sFlag := false ;
88358: LD_ADDR_EXP 121
88362: PUSH
88363: LD_INT 0
88365: ST_TO_ADDR
// sKamikadze := false ;
88366: LD_ADDR_EXP 129
88370: PUSH
88371: LD_INT 0
88373: ST_TO_ADDR
// sTroll := false ;
88374: LD_ADDR_EXP 130
88378: PUSH
88379: LD_INT 0
88381: ST_TO_ADDR
// sSlow := false ;
88382: LD_ADDR_EXP 131
88386: PUSH
88387: LD_INT 0
88389: ST_TO_ADDR
// sLack := false ;
88390: LD_ADDR_EXP 132
88394: PUSH
88395: LD_INT 0
88397: ST_TO_ADDR
// sTank := false ;
88398: LD_ADDR_EXP 134
88402: PUSH
88403: LD_INT 0
88405: ST_TO_ADDR
// sRemote := false ;
88406: LD_ADDR_EXP 135
88410: PUSH
88411: LD_INT 0
88413: ST_TO_ADDR
// sPowell := false ;
88414: LD_ADDR_EXP 136
88418: PUSH
88419: LD_INT 0
88421: ST_TO_ADDR
// sTeleport := false ;
88422: LD_ADDR_EXP 139
88426: PUSH
88427: LD_INT 0
88429: ST_TO_ADDR
// sOilTower := false ;
88430: LD_ADDR_EXP 141
88434: PUSH
88435: LD_INT 0
88437: ST_TO_ADDR
// sShovel := false ;
88438: LD_ADDR_EXP 142
88442: PUSH
88443: LD_INT 0
88445: ST_TO_ADDR
// sSheik := false ;
88446: LD_ADDR_EXP 143
88450: PUSH
88451: LD_INT 0
88453: ST_TO_ADDR
// sEarthquake := false ;
88454: LD_ADDR_EXP 145
88458: PUSH
88459: LD_INT 0
88461: ST_TO_ADDR
// sAI := false ;
88462: LD_ADDR_EXP 146
88466: PUSH
88467: LD_INT 0
88469: ST_TO_ADDR
// sCargo := false ;
88470: LD_ADDR_EXP 149
88474: PUSH
88475: LD_INT 0
88477: ST_TO_ADDR
// sDLaser := false ;
88478: LD_ADDR_EXP 150
88482: PUSH
88483: LD_INT 0
88485: ST_TO_ADDR
// sExchange := false ;
88486: LD_ADDR_EXP 151
88490: PUSH
88491: LD_INT 0
88493: ST_TO_ADDR
// sFac := false ;
88494: LD_ADDR_EXP 152
88498: PUSH
88499: LD_INT 0
88501: ST_TO_ADDR
// sPower := false ;
88502: LD_ADDR_EXP 153
88506: PUSH
88507: LD_INT 0
88509: ST_TO_ADDR
// sRandom := false ;
88510: LD_ADDR_EXP 154
88514: PUSH
88515: LD_INT 0
88517: ST_TO_ADDR
// sShield := false ;
88518: LD_ADDR_EXP 155
88522: PUSH
88523: LD_INT 0
88525: ST_TO_ADDR
// sTime := false ;
88526: LD_ADDR_EXP 156
88530: PUSH
88531: LD_INT 0
88533: ST_TO_ADDR
// sTools := false ;
88534: LD_ADDR_EXP 157
88538: PUSH
88539: LD_INT 0
88541: ST_TO_ADDR
// sSold := false ;
88542: LD_ADDR_EXP 122
88546: PUSH
88547: LD_INT 0
88549: ST_TO_ADDR
// sDiff := false ;
88550: LD_ADDR_EXP 123
88554: PUSH
88555: LD_INT 0
88557: ST_TO_ADDR
// sFog := false ;
88558: LD_ADDR_EXP 126
88562: PUSH
88563: LD_INT 0
88565: ST_TO_ADDR
// sReset := false ;
88566: LD_ADDR_EXP 127
88570: PUSH
88571: LD_INT 0
88573: ST_TO_ADDR
// sSun := false ;
88574: LD_ADDR_EXP 128
88578: PUSH
88579: LD_INT 0
88581: ST_TO_ADDR
// sTiger := false ;
88582: LD_ADDR_EXP 124
88586: PUSH
88587: LD_INT 0
88589: ST_TO_ADDR
// sBomb := false ;
88590: LD_ADDR_EXP 125
88594: PUSH
88595: LD_INT 0
88597: ST_TO_ADDR
// sWound := false ;
88598: LD_ADDR_EXP 133
88602: PUSH
88603: LD_INT 0
88605: ST_TO_ADDR
// sBetray := false ;
88606: LD_ADDR_EXP 137
88610: PUSH
88611: LD_INT 0
88613: ST_TO_ADDR
// sContamin := false ;
88614: LD_ADDR_EXP 138
88618: PUSH
88619: LD_INT 0
88621: ST_TO_ADDR
// sOil := false ;
88622: LD_ADDR_EXP 140
88626: PUSH
88627: LD_INT 0
88629: ST_TO_ADDR
// sStu := false ;
88630: LD_ADDR_EXP 144
88634: PUSH
88635: LD_INT 0
88637: ST_TO_ADDR
// sBazooka := false ;
88638: LD_ADDR_EXP 147
88642: PUSH
88643: LD_INT 0
88645: ST_TO_ADDR
// sMortar := false ;
88646: LD_ADDR_EXP 148
88650: PUSH
88651: LD_INT 0
88653: ST_TO_ADDR
// sRanger := false ;
88654: LD_ADDR_EXP 158
88658: PUSH
88659: LD_INT 0
88661: ST_TO_ADDR
// sComputer := false ;
88662: LD_ADDR_EXP 159
88666: PUSH
88667: LD_INT 0
88669: ST_TO_ADDR
// s30 := false ;
88670: LD_ADDR_EXP 160
88674: PUSH
88675: LD_INT 0
88677: ST_TO_ADDR
// s60 := false ;
88678: LD_ADDR_EXP 161
88682: PUSH
88683: LD_INT 0
88685: ST_TO_ADDR
// end ;
88686: LD_VAR 0 1
88690: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88691: LD_INT 0
88693: PPUSH
88694: PPUSH
88695: PPUSH
88696: PPUSH
88697: PPUSH
88698: PPUSH
88699: PPUSH
// result := [ ] ;
88700: LD_ADDR_VAR 0 2
88704: PUSH
88705: EMPTY
88706: ST_TO_ADDR
// if campaign_id = 1 then
88707: LD_OWVAR 69
88711: PUSH
88712: LD_INT 1
88714: EQUAL
88715: IFFALSE 91881
// begin case mission_number of 1 :
88717: LD_OWVAR 70
88721: PUSH
88722: LD_INT 1
88724: DOUBLE
88725: EQUAL
88726: IFTRUE 88730
88728: GO 88806
88730: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88731: LD_ADDR_VAR 0 2
88735: PUSH
88736: LD_INT 2
88738: PUSH
88739: LD_INT 4
88741: PUSH
88742: LD_INT 11
88744: PUSH
88745: LD_INT 12
88747: PUSH
88748: LD_INT 15
88750: PUSH
88751: LD_INT 16
88753: PUSH
88754: LD_INT 22
88756: PUSH
88757: LD_INT 23
88759: PUSH
88760: LD_INT 26
88762: PUSH
88763: EMPTY
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: PUSH
88774: LD_INT 101
88776: PUSH
88777: LD_INT 102
88779: PUSH
88780: LD_INT 106
88782: PUSH
88783: LD_INT 116
88785: PUSH
88786: LD_INT 117
88788: PUSH
88789: LD_INT 118
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: ST_TO_ADDR
88804: GO 91879
88806: LD_INT 2
88808: DOUBLE
88809: EQUAL
88810: IFTRUE 88814
88812: GO 88898
88814: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88815: LD_ADDR_VAR 0 2
88819: PUSH
88820: LD_INT 2
88822: PUSH
88823: LD_INT 4
88825: PUSH
88826: LD_INT 11
88828: PUSH
88829: LD_INT 12
88831: PUSH
88832: LD_INT 15
88834: PUSH
88835: LD_INT 16
88837: PUSH
88838: LD_INT 22
88840: PUSH
88841: LD_INT 23
88843: PUSH
88844: LD_INT 26
88846: PUSH
88847: EMPTY
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: LIST
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 101
88860: PUSH
88861: LD_INT 102
88863: PUSH
88864: LD_INT 105
88866: PUSH
88867: LD_INT 106
88869: PUSH
88870: LD_INT 108
88872: PUSH
88873: LD_INT 116
88875: PUSH
88876: LD_INT 117
88878: PUSH
88879: LD_INT 118
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: PUSH
88892: EMPTY
88893: LIST
88894: LIST
88895: ST_TO_ADDR
88896: GO 91879
88898: LD_INT 3
88900: DOUBLE
88901: EQUAL
88902: IFTRUE 88906
88904: GO 88994
88906: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
88907: LD_ADDR_VAR 0 2
88911: PUSH
88912: LD_INT 2
88914: PUSH
88915: LD_INT 4
88917: PUSH
88918: LD_INT 5
88920: PUSH
88921: LD_INT 11
88923: PUSH
88924: LD_INT 12
88926: PUSH
88927: LD_INT 15
88929: PUSH
88930: LD_INT 16
88932: PUSH
88933: LD_INT 22
88935: PUSH
88936: LD_INT 26
88938: PUSH
88939: LD_INT 36
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: PUSH
88954: LD_INT 101
88956: PUSH
88957: LD_INT 102
88959: PUSH
88960: LD_INT 105
88962: PUSH
88963: LD_INT 106
88965: PUSH
88966: LD_INT 108
88968: PUSH
88969: LD_INT 116
88971: PUSH
88972: LD_INT 117
88974: PUSH
88975: LD_INT 118
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: ST_TO_ADDR
88992: GO 91879
88994: LD_INT 4
88996: DOUBLE
88997: EQUAL
88998: IFTRUE 89002
89000: GO 89098
89002: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89003: LD_ADDR_VAR 0 2
89007: PUSH
89008: LD_INT 2
89010: PUSH
89011: LD_INT 4
89013: PUSH
89014: LD_INT 5
89016: PUSH
89017: LD_INT 8
89019: PUSH
89020: LD_INT 11
89022: PUSH
89023: LD_INT 12
89025: PUSH
89026: LD_INT 15
89028: PUSH
89029: LD_INT 16
89031: PUSH
89032: LD_INT 22
89034: PUSH
89035: LD_INT 23
89037: PUSH
89038: LD_INT 26
89040: PUSH
89041: LD_INT 36
89043: PUSH
89044: EMPTY
89045: LIST
89046: LIST
89047: LIST
89048: LIST
89049: LIST
89050: LIST
89051: LIST
89052: LIST
89053: LIST
89054: LIST
89055: LIST
89056: LIST
89057: PUSH
89058: LD_INT 101
89060: PUSH
89061: LD_INT 102
89063: PUSH
89064: LD_INT 105
89066: PUSH
89067: LD_INT 106
89069: PUSH
89070: LD_INT 108
89072: PUSH
89073: LD_INT 116
89075: PUSH
89076: LD_INT 117
89078: PUSH
89079: LD_INT 118
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: LIST
89086: LIST
89087: LIST
89088: LIST
89089: LIST
89090: LIST
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: ST_TO_ADDR
89096: GO 91879
89098: LD_INT 5
89100: DOUBLE
89101: EQUAL
89102: IFTRUE 89106
89104: GO 89218
89106: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89107: LD_ADDR_VAR 0 2
89111: PUSH
89112: LD_INT 2
89114: PUSH
89115: LD_INT 4
89117: PUSH
89118: LD_INT 5
89120: PUSH
89121: LD_INT 6
89123: PUSH
89124: LD_INT 8
89126: PUSH
89127: LD_INT 11
89129: PUSH
89130: LD_INT 12
89132: PUSH
89133: LD_INT 15
89135: PUSH
89136: LD_INT 16
89138: PUSH
89139: LD_INT 22
89141: PUSH
89142: LD_INT 23
89144: PUSH
89145: LD_INT 25
89147: PUSH
89148: LD_INT 26
89150: PUSH
89151: LD_INT 36
89153: PUSH
89154: EMPTY
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: PUSH
89170: LD_INT 101
89172: PUSH
89173: LD_INT 102
89175: PUSH
89176: LD_INT 105
89178: PUSH
89179: LD_INT 106
89181: PUSH
89182: LD_INT 108
89184: PUSH
89185: LD_INT 109
89187: PUSH
89188: LD_INT 112
89190: PUSH
89191: LD_INT 116
89193: PUSH
89194: LD_INT 117
89196: PUSH
89197: LD_INT 118
89199: PUSH
89200: EMPTY
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: LIST
89209: LIST
89210: LIST
89211: PUSH
89212: EMPTY
89213: LIST
89214: LIST
89215: ST_TO_ADDR
89216: GO 91879
89218: LD_INT 6
89220: DOUBLE
89221: EQUAL
89222: IFTRUE 89226
89224: GO 89358
89226: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89227: LD_ADDR_VAR 0 2
89231: PUSH
89232: LD_INT 2
89234: PUSH
89235: LD_INT 4
89237: PUSH
89238: LD_INT 5
89240: PUSH
89241: LD_INT 6
89243: PUSH
89244: LD_INT 8
89246: PUSH
89247: LD_INT 11
89249: PUSH
89250: LD_INT 12
89252: PUSH
89253: LD_INT 15
89255: PUSH
89256: LD_INT 16
89258: PUSH
89259: LD_INT 20
89261: PUSH
89262: LD_INT 21
89264: PUSH
89265: LD_INT 22
89267: PUSH
89268: LD_INT 23
89270: PUSH
89271: LD_INT 25
89273: PUSH
89274: LD_INT 26
89276: PUSH
89277: LD_INT 30
89279: PUSH
89280: LD_INT 31
89282: PUSH
89283: LD_INT 32
89285: PUSH
89286: LD_INT 36
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 101
89312: PUSH
89313: LD_INT 102
89315: PUSH
89316: LD_INT 105
89318: PUSH
89319: LD_INT 106
89321: PUSH
89322: LD_INT 108
89324: PUSH
89325: LD_INT 109
89327: PUSH
89328: LD_INT 112
89330: PUSH
89331: LD_INT 116
89333: PUSH
89334: LD_INT 117
89336: PUSH
89337: LD_INT 118
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: PUSH
89352: EMPTY
89353: LIST
89354: LIST
89355: ST_TO_ADDR
89356: GO 91879
89358: LD_INT 7
89360: DOUBLE
89361: EQUAL
89362: IFTRUE 89366
89364: GO 89478
89366: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89367: LD_ADDR_VAR 0 2
89371: PUSH
89372: LD_INT 2
89374: PUSH
89375: LD_INT 4
89377: PUSH
89378: LD_INT 5
89380: PUSH
89381: LD_INT 7
89383: PUSH
89384: LD_INT 11
89386: PUSH
89387: LD_INT 12
89389: PUSH
89390: LD_INT 15
89392: PUSH
89393: LD_INT 16
89395: PUSH
89396: LD_INT 20
89398: PUSH
89399: LD_INT 21
89401: PUSH
89402: LD_INT 22
89404: PUSH
89405: LD_INT 23
89407: PUSH
89408: LD_INT 25
89410: PUSH
89411: LD_INT 26
89413: PUSH
89414: EMPTY
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 101
89432: PUSH
89433: LD_INT 102
89435: PUSH
89436: LD_INT 103
89438: PUSH
89439: LD_INT 105
89441: PUSH
89442: LD_INT 106
89444: PUSH
89445: LD_INT 108
89447: PUSH
89448: LD_INT 112
89450: PUSH
89451: LD_INT 116
89453: PUSH
89454: LD_INT 117
89456: PUSH
89457: LD_INT 118
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: ST_TO_ADDR
89476: GO 91879
89478: LD_INT 8
89480: DOUBLE
89481: EQUAL
89482: IFTRUE 89486
89484: GO 89626
89486: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89487: LD_ADDR_VAR 0 2
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: LD_INT 4
89497: PUSH
89498: LD_INT 5
89500: PUSH
89501: LD_INT 6
89503: PUSH
89504: LD_INT 7
89506: PUSH
89507: LD_INT 8
89509: PUSH
89510: LD_INT 11
89512: PUSH
89513: LD_INT 12
89515: PUSH
89516: LD_INT 15
89518: PUSH
89519: LD_INT 16
89521: PUSH
89522: LD_INT 20
89524: PUSH
89525: LD_INT 21
89527: PUSH
89528: LD_INT 22
89530: PUSH
89531: LD_INT 23
89533: PUSH
89534: LD_INT 25
89536: PUSH
89537: LD_INT 26
89539: PUSH
89540: LD_INT 30
89542: PUSH
89543: LD_INT 31
89545: PUSH
89546: LD_INT 32
89548: PUSH
89549: LD_INT 36
89551: PUSH
89552: EMPTY
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: PUSH
89574: LD_INT 101
89576: PUSH
89577: LD_INT 102
89579: PUSH
89580: LD_INT 103
89582: PUSH
89583: LD_INT 105
89585: PUSH
89586: LD_INT 106
89588: PUSH
89589: LD_INT 108
89591: PUSH
89592: LD_INT 109
89594: PUSH
89595: LD_INT 112
89597: PUSH
89598: LD_INT 116
89600: PUSH
89601: LD_INT 117
89603: PUSH
89604: LD_INT 118
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: LIST
89611: LIST
89612: LIST
89613: LIST
89614: LIST
89615: LIST
89616: LIST
89617: LIST
89618: LIST
89619: PUSH
89620: EMPTY
89621: LIST
89622: LIST
89623: ST_TO_ADDR
89624: GO 91879
89626: LD_INT 9
89628: DOUBLE
89629: EQUAL
89630: IFTRUE 89634
89632: GO 89782
89634: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89635: LD_ADDR_VAR 0 2
89639: PUSH
89640: LD_INT 2
89642: PUSH
89643: LD_INT 4
89645: PUSH
89646: LD_INT 5
89648: PUSH
89649: LD_INT 6
89651: PUSH
89652: LD_INT 7
89654: PUSH
89655: LD_INT 8
89657: PUSH
89658: LD_INT 11
89660: PUSH
89661: LD_INT 12
89663: PUSH
89664: LD_INT 15
89666: PUSH
89667: LD_INT 16
89669: PUSH
89670: LD_INT 20
89672: PUSH
89673: LD_INT 21
89675: PUSH
89676: LD_INT 22
89678: PUSH
89679: LD_INT 23
89681: PUSH
89682: LD_INT 25
89684: PUSH
89685: LD_INT 26
89687: PUSH
89688: LD_INT 28
89690: PUSH
89691: LD_INT 30
89693: PUSH
89694: LD_INT 31
89696: PUSH
89697: LD_INT 32
89699: PUSH
89700: LD_INT 36
89702: PUSH
89703: EMPTY
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: PUSH
89726: LD_INT 101
89728: PUSH
89729: LD_INT 102
89731: PUSH
89732: LD_INT 103
89734: PUSH
89735: LD_INT 105
89737: PUSH
89738: LD_INT 106
89740: PUSH
89741: LD_INT 108
89743: PUSH
89744: LD_INT 109
89746: PUSH
89747: LD_INT 112
89749: PUSH
89750: LD_INT 114
89752: PUSH
89753: LD_INT 116
89755: PUSH
89756: LD_INT 117
89758: PUSH
89759: LD_INT 118
89761: PUSH
89762: EMPTY
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: ST_TO_ADDR
89780: GO 91879
89782: LD_INT 10
89784: DOUBLE
89785: EQUAL
89786: IFTRUE 89790
89788: GO 89986
89790: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89791: LD_ADDR_VAR 0 2
89795: PUSH
89796: LD_INT 2
89798: PUSH
89799: LD_INT 4
89801: PUSH
89802: LD_INT 5
89804: PUSH
89805: LD_INT 6
89807: PUSH
89808: LD_INT 7
89810: PUSH
89811: LD_INT 8
89813: PUSH
89814: LD_INT 9
89816: PUSH
89817: LD_INT 10
89819: PUSH
89820: LD_INT 11
89822: PUSH
89823: LD_INT 12
89825: PUSH
89826: LD_INT 13
89828: PUSH
89829: LD_INT 14
89831: PUSH
89832: LD_INT 15
89834: PUSH
89835: LD_INT 16
89837: PUSH
89838: LD_INT 17
89840: PUSH
89841: LD_INT 18
89843: PUSH
89844: LD_INT 19
89846: PUSH
89847: LD_INT 20
89849: PUSH
89850: LD_INT 21
89852: PUSH
89853: LD_INT 22
89855: PUSH
89856: LD_INT 23
89858: PUSH
89859: LD_INT 24
89861: PUSH
89862: LD_INT 25
89864: PUSH
89865: LD_INT 26
89867: PUSH
89868: LD_INT 28
89870: PUSH
89871: LD_INT 30
89873: PUSH
89874: LD_INT 31
89876: PUSH
89877: LD_INT 32
89879: PUSH
89880: LD_INT 36
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: LIST
89907: LIST
89908: LIST
89909: LIST
89910: LIST
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 101
89916: PUSH
89917: LD_INT 102
89919: PUSH
89920: LD_INT 103
89922: PUSH
89923: LD_INT 104
89925: PUSH
89926: LD_INT 105
89928: PUSH
89929: LD_INT 106
89931: PUSH
89932: LD_INT 107
89934: PUSH
89935: LD_INT 108
89937: PUSH
89938: LD_INT 109
89940: PUSH
89941: LD_INT 110
89943: PUSH
89944: LD_INT 111
89946: PUSH
89947: LD_INT 112
89949: PUSH
89950: LD_INT 114
89952: PUSH
89953: LD_INT 116
89955: PUSH
89956: LD_INT 117
89958: PUSH
89959: LD_INT 118
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: ST_TO_ADDR
89984: GO 91879
89986: LD_INT 11
89988: DOUBLE
89989: EQUAL
89990: IFTRUE 89994
89992: GO 90198
89994: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
89995: LD_ADDR_VAR 0 2
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 3
90005: PUSH
90006: LD_INT 4
90008: PUSH
90009: LD_INT 5
90011: PUSH
90012: LD_INT 6
90014: PUSH
90015: LD_INT 7
90017: PUSH
90018: LD_INT 8
90020: PUSH
90021: LD_INT 9
90023: PUSH
90024: LD_INT 10
90026: PUSH
90027: LD_INT 11
90029: PUSH
90030: LD_INT 12
90032: PUSH
90033: LD_INT 13
90035: PUSH
90036: LD_INT 14
90038: PUSH
90039: LD_INT 15
90041: PUSH
90042: LD_INT 16
90044: PUSH
90045: LD_INT 17
90047: PUSH
90048: LD_INT 18
90050: PUSH
90051: LD_INT 19
90053: PUSH
90054: LD_INT 20
90056: PUSH
90057: LD_INT 21
90059: PUSH
90060: LD_INT 22
90062: PUSH
90063: LD_INT 23
90065: PUSH
90066: LD_INT 24
90068: PUSH
90069: LD_INT 25
90071: PUSH
90072: LD_INT 26
90074: PUSH
90075: LD_INT 28
90077: PUSH
90078: LD_INT 30
90080: PUSH
90081: LD_INT 31
90083: PUSH
90084: LD_INT 32
90086: PUSH
90087: LD_INT 34
90089: PUSH
90090: LD_INT 36
90092: PUSH
90093: EMPTY
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 101
90128: PUSH
90129: LD_INT 102
90131: PUSH
90132: LD_INT 103
90134: PUSH
90135: LD_INT 104
90137: PUSH
90138: LD_INT 105
90140: PUSH
90141: LD_INT 106
90143: PUSH
90144: LD_INT 107
90146: PUSH
90147: LD_INT 108
90149: PUSH
90150: LD_INT 109
90152: PUSH
90153: LD_INT 110
90155: PUSH
90156: LD_INT 111
90158: PUSH
90159: LD_INT 112
90161: PUSH
90162: LD_INT 114
90164: PUSH
90165: LD_INT 116
90167: PUSH
90168: LD_INT 117
90170: PUSH
90171: LD_INT 118
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: LIST
90181: LIST
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: ST_TO_ADDR
90196: GO 91879
90198: LD_INT 12
90200: DOUBLE
90201: EQUAL
90202: IFTRUE 90206
90204: GO 90426
90206: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90207: LD_ADDR_VAR 0 2
90211: PUSH
90212: LD_INT 1
90214: PUSH
90215: LD_INT 2
90217: PUSH
90218: LD_INT 3
90220: PUSH
90221: LD_INT 4
90223: PUSH
90224: LD_INT 5
90226: PUSH
90227: LD_INT 6
90229: PUSH
90230: LD_INT 7
90232: PUSH
90233: LD_INT 8
90235: PUSH
90236: LD_INT 9
90238: PUSH
90239: LD_INT 10
90241: PUSH
90242: LD_INT 11
90244: PUSH
90245: LD_INT 12
90247: PUSH
90248: LD_INT 13
90250: PUSH
90251: LD_INT 14
90253: PUSH
90254: LD_INT 15
90256: PUSH
90257: LD_INT 16
90259: PUSH
90260: LD_INT 17
90262: PUSH
90263: LD_INT 18
90265: PUSH
90266: LD_INT 19
90268: PUSH
90269: LD_INT 20
90271: PUSH
90272: LD_INT 21
90274: PUSH
90275: LD_INT 22
90277: PUSH
90278: LD_INT 23
90280: PUSH
90281: LD_INT 24
90283: PUSH
90284: LD_INT 25
90286: PUSH
90287: LD_INT 26
90289: PUSH
90290: LD_INT 27
90292: PUSH
90293: LD_INT 28
90295: PUSH
90296: LD_INT 30
90298: PUSH
90299: LD_INT 31
90301: PUSH
90302: LD_INT 32
90304: PUSH
90305: LD_INT 33
90307: PUSH
90308: LD_INT 34
90310: PUSH
90311: LD_INT 36
90313: PUSH
90314: EMPTY
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: LIST
90328: LIST
90329: LIST
90330: LIST
90331: LIST
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: LIST
90343: LIST
90344: LIST
90345: LIST
90346: LIST
90347: LIST
90348: LIST
90349: PUSH
90350: LD_INT 101
90352: PUSH
90353: LD_INT 102
90355: PUSH
90356: LD_INT 103
90358: PUSH
90359: LD_INT 104
90361: PUSH
90362: LD_INT 105
90364: PUSH
90365: LD_INT 106
90367: PUSH
90368: LD_INT 107
90370: PUSH
90371: LD_INT 108
90373: PUSH
90374: LD_INT 109
90376: PUSH
90377: LD_INT 110
90379: PUSH
90380: LD_INT 111
90382: PUSH
90383: LD_INT 112
90385: PUSH
90386: LD_INT 113
90388: PUSH
90389: LD_INT 114
90391: PUSH
90392: LD_INT 116
90394: PUSH
90395: LD_INT 117
90397: PUSH
90398: LD_INT 118
90400: PUSH
90401: EMPTY
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: ST_TO_ADDR
90424: GO 91879
90426: LD_INT 13
90428: DOUBLE
90429: EQUAL
90430: IFTRUE 90434
90432: GO 90642
90434: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90435: LD_ADDR_VAR 0 2
90439: PUSH
90440: LD_INT 1
90442: PUSH
90443: LD_INT 2
90445: PUSH
90446: LD_INT 3
90448: PUSH
90449: LD_INT 4
90451: PUSH
90452: LD_INT 5
90454: PUSH
90455: LD_INT 8
90457: PUSH
90458: LD_INT 9
90460: PUSH
90461: LD_INT 10
90463: PUSH
90464: LD_INT 11
90466: PUSH
90467: LD_INT 12
90469: PUSH
90470: LD_INT 14
90472: PUSH
90473: LD_INT 15
90475: PUSH
90476: LD_INT 16
90478: PUSH
90479: LD_INT 17
90481: PUSH
90482: LD_INT 18
90484: PUSH
90485: LD_INT 19
90487: PUSH
90488: LD_INT 20
90490: PUSH
90491: LD_INT 21
90493: PUSH
90494: LD_INT 22
90496: PUSH
90497: LD_INT 23
90499: PUSH
90500: LD_INT 24
90502: PUSH
90503: LD_INT 25
90505: PUSH
90506: LD_INT 26
90508: PUSH
90509: LD_INT 27
90511: PUSH
90512: LD_INT 28
90514: PUSH
90515: LD_INT 30
90517: PUSH
90518: LD_INT 31
90520: PUSH
90521: LD_INT 32
90523: PUSH
90524: LD_INT 33
90526: PUSH
90527: LD_INT 34
90529: PUSH
90530: LD_INT 36
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: LIST
90564: LIST
90565: PUSH
90566: LD_INT 101
90568: PUSH
90569: LD_INT 102
90571: PUSH
90572: LD_INT 103
90574: PUSH
90575: LD_INT 104
90577: PUSH
90578: LD_INT 105
90580: PUSH
90581: LD_INT 106
90583: PUSH
90584: LD_INT 107
90586: PUSH
90587: LD_INT 108
90589: PUSH
90590: LD_INT 109
90592: PUSH
90593: LD_INT 110
90595: PUSH
90596: LD_INT 111
90598: PUSH
90599: LD_INT 112
90601: PUSH
90602: LD_INT 113
90604: PUSH
90605: LD_INT 114
90607: PUSH
90608: LD_INT 116
90610: PUSH
90611: LD_INT 117
90613: PUSH
90614: LD_INT 118
90616: PUSH
90617: EMPTY
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: LIST
90626: LIST
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: PUSH
90636: EMPTY
90637: LIST
90638: LIST
90639: ST_TO_ADDR
90640: GO 91879
90642: LD_INT 14
90644: DOUBLE
90645: EQUAL
90646: IFTRUE 90650
90648: GO 90874
90650: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90651: LD_ADDR_VAR 0 2
90655: PUSH
90656: LD_INT 1
90658: PUSH
90659: LD_INT 2
90661: PUSH
90662: LD_INT 3
90664: PUSH
90665: LD_INT 4
90667: PUSH
90668: LD_INT 5
90670: PUSH
90671: LD_INT 6
90673: PUSH
90674: LD_INT 7
90676: PUSH
90677: LD_INT 8
90679: PUSH
90680: LD_INT 9
90682: PUSH
90683: LD_INT 10
90685: PUSH
90686: LD_INT 11
90688: PUSH
90689: LD_INT 12
90691: PUSH
90692: LD_INT 13
90694: PUSH
90695: LD_INT 14
90697: PUSH
90698: LD_INT 15
90700: PUSH
90701: LD_INT 16
90703: PUSH
90704: LD_INT 17
90706: PUSH
90707: LD_INT 18
90709: PUSH
90710: LD_INT 19
90712: PUSH
90713: LD_INT 20
90715: PUSH
90716: LD_INT 21
90718: PUSH
90719: LD_INT 22
90721: PUSH
90722: LD_INT 23
90724: PUSH
90725: LD_INT 24
90727: PUSH
90728: LD_INT 25
90730: PUSH
90731: LD_INT 26
90733: PUSH
90734: LD_INT 27
90736: PUSH
90737: LD_INT 28
90739: PUSH
90740: LD_INT 29
90742: PUSH
90743: LD_INT 30
90745: PUSH
90746: LD_INT 31
90748: PUSH
90749: LD_INT 32
90751: PUSH
90752: LD_INT 33
90754: PUSH
90755: LD_INT 34
90757: PUSH
90758: LD_INT 36
90760: PUSH
90761: EMPTY
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: PUSH
90798: LD_INT 101
90800: PUSH
90801: LD_INT 102
90803: PUSH
90804: LD_INT 103
90806: PUSH
90807: LD_INT 104
90809: PUSH
90810: LD_INT 105
90812: PUSH
90813: LD_INT 106
90815: PUSH
90816: LD_INT 107
90818: PUSH
90819: LD_INT 108
90821: PUSH
90822: LD_INT 109
90824: PUSH
90825: LD_INT 110
90827: PUSH
90828: LD_INT 111
90830: PUSH
90831: LD_INT 112
90833: PUSH
90834: LD_INT 113
90836: PUSH
90837: LD_INT 114
90839: PUSH
90840: LD_INT 116
90842: PUSH
90843: LD_INT 117
90845: PUSH
90846: LD_INT 118
90848: PUSH
90849: EMPTY
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: ST_TO_ADDR
90872: GO 91879
90874: LD_INT 15
90876: DOUBLE
90877: EQUAL
90878: IFTRUE 90882
90880: GO 91106
90882: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
90883: LD_ADDR_VAR 0 2
90887: PUSH
90888: LD_INT 1
90890: PUSH
90891: LD_INT 2
90893: PUSH
90894: LD_INT 3
90896: PUSH
90897: LD_INT 4
90899: PUSH
90900: LD_INT 5
90902: PUSH
90903: LD_INT 6
90905: PUSH
90906: LD_INT 7
90908: PUSH
90909: LD_INT 8
90911: PUSH
90912: LD_INT 9
90914: PUSH
90915: LD_INT 10
90917: PUSH
90918: LD_INT 11
90920: PUSH
90921: LD_INT 12
90923: PUSH
90924: LD_INT 13
90926: PUSH
90927: LD_INT 14
90929: PUSH
90930: LD_INT 15
90932: PUSH
90933: LD_INT 16
90935: PUSH
90936: LD_INT 17
90938: PUSH
90939: LD_INT 18
90941: PUSH
90942: LD_INT 19
90944: PUSH
90945: LD_INT 20
90947: PUSH
90948: LD_INT 21
90950: PUSH
90951: LD_INT 22
90953: PUSH
90954: LD_INT 23
90956: PUSH
90957: LD_INT 24
90959: PUSH
90960: LD_INT 25
90962: PUSH
90963: LD_INT 26
90965: PUSH
90966: LD_INT 27
90968: PUSH
90969: LD_INT 28
90971: PUSH
90972: LD_INT 29
90974: PUSH
90975: LD_INT 30
90977: PUSH
90978: LD_INT 31
90980: PUSH
90981: LD_INT 32
90983: PUSH
90984: LD_INT 33
90986: PUSH
90987: LD_INT 34
90989: PUSH
90990: LD_INT 36
90992: PUSH
90993: EMPTY
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: LIST
91024: LIST
91025: LIST
91026: LIST
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 101
91032: PUSH
91033: LD_INT 102
91035: PUSH
91036: LD_INT 103
91038: PUSH
91039: LD_INT 104
91041: PUSH
91042: LD_INT 105
91044: PUSH
91045: LD_INT 106
91047: PUSH
91048: LD_INT 107
91050: PUSH
91051: LD_INT 108
91053: PUSH
91054: LD_INT 109
91056: PUSH
91057: LD_INT 110
91059: PUSH
91060: LD_INT 111
91062: PUSH
91063: LD_INT 112
91065: PUSH
91066: LD_INT 113
91068: PUSH
91069: LD_INT 114
91071: PUSH
91072: LD_INT 116
91074: PUSH
91075: LD_INT 117
91077: PUSH
91078: LD_INT 118
91080: PUSH
91081: EMPTY
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: ST_TO_ADDR
91104: GO 91879
91106: LD_INT 16
91108: DOUBLE
91109: EQUAL
91110: IFTRUE 91114
91112: GO 91250
91114: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91115: LD_ADDR_VAR 0 2
91119: PUSH
91120: LD_INT 2
91122: PUSH
91123: LD_INT 4
91125: PUSH
91126: LD_INT 5
91128: PUSH
91129: LD_INT 7
91131: PUSH
91132: LD_INT 11
91134: PUSH
91135: LD_INT 12
91137: PUSH
91138: LD_INT 15
91140: PUSH
91141: LD_INT 16
91143: PUSH
91144: LD_INT 20
91146: PUSH
91147: LD_INT 21
91149: PUSH
91150: LD_INT 22
91152: PUSH
91153: LD_INT 23
91155: PUSH
91156: LD_INT 25
91158: PUSH
91159: LD_INT 26
91161: PUSH
91162: LD_INT 30
91164: PUSH
91165: LD_INT 31
91167: PUSH
91168: LD_INT 32
91170: PUSH
91171: LD_INT 33
91173: PUSH
91174: LD_INT 34
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: LIST
91181: LIST
91182: LIST
91183: LIST
91184: LIST
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: PUSH
91198: LD_INT 101
91200: PUSH
91201: LD_INT 102
91203: PUSH
91204: LD_INT 103
91206: PUSH
91207: LD_INT 106
91209: PUSH
91210: LD_INT 108
91212: PUSH
91213: LD_INT 112
91215: PUSH
91216: LD_INT 113
91218: PUSH
91219: LD_INT 114
91221: PUSH
91222: LD_INT 116
91224: PUSH
91225: LD_INT 117
91227: PUSH
91228: LD_INT 118
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: PUSH
91244: EMPTY
91245: LIST
91246: LIST
91247: ST_TO_ADDR
91248: GO 91879
91250: LD_INT 17
91252: DOUBLE
91253: EQUAL
91254: IFTRUE 91258
91256: GO 91482
91258: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91259: LD_ADDR_VAR 0 2
91263: PUSH
91264: LD_INT 1
91266: PUSH
91267: LD_INT 2
91269: PUSH
91270: LD_INT 3
91272: PUSH
91273: LD_INT 4
91275: PUSH
91276: LD_INT 5
91278: PUSH
91279: LD_INT 6
91281: PUSH
91282: LD_INT 7
91284: PUSH
91285: LD_INT 8
91287: PUSH
91288: LD_INT 9
91290: PUSH
91291: LD_INT 10
91293: PUSH
91294: LD_INT 11
91296: PUSH
91297: LD_INT 12
91299: PUSH
91300: LD_INT 13
91302: PUSH
91303: LD_INT 14
91305: PUSH
91306: LD_INT 15
91308: PUSH
91309: LD_INT 16
91311: PUSH
91312: LD_INT 17
91314: PUSH
91315: LD_INT 18
91317: PUSH
91318: LD_INT 19
91320: PUSH
91321: LD_INT 20
91323: PUSH
91324: LD_INT 21
91326: PUSH
91327: LD_INT 22
91329: PUSH
91330: LD_INT 23
91332: PUSH
91333: LD_INT 24
91335: PUSH
91336: LD_INT 25
91338: PUSH
91339: LD_INT 26
91341: PUSH
91342: LD_INT 27
91344: PUSH
91345: LD_INT 28
91347: PUSH
91348: LD_INT 29
91350: PUSH
91351: LD_INT 30
91353: PUSH
91354: LD_INT 31
91356: PUSH
91357: LD_INT 32
91359: PUSH
91360: LD_INT 33
91362: PUSH
91363: LD_INT 34
91365: PUSH
91366: LD_INT 36
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 101
91408: PUSH
91409: LD_INT 102
91411: PUSH
91412: LD_INT 103
91414: PUSH
91415: LD_INT 104
91417: PUSH
91418: LD_INT 105
91420: PUSH
91421: LD_INT 106
91423: PUSH
91424: LD_INT 107
91426: PUSH
91427: LD_INT 108
91429: PUSH
91430: LD_INT 109
91432: PUSH
91433: LD_INT 110
91435: PUSH
91436: LD_INT 111
91438: PUSH
91439: LD_INT 112
91441: PUSH
91442: LD_INT 113
91444: PUSH
91445: LD_INT 114
91447: PUSH
91448: LD_INT 116
91450: PUSH
91451: LD_INT 117
91453: PUSH
91454: LD_INT 118
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: PUSH
91476: EMPTY
91477: LIST
91478: LIST
91479: ST_TO_ADDR
91480: GO 91879
91482: LD_INT 18
91484: DOUBLE
91485: EQUAL
91486: IFTRUE 91490
91488: GO 91638
91490: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91491: LD_ADDR_VAR 0 2
91495: PUSH
91496: LD_INT 2
91498: PUSH
91499: LD_INT 4
91501: PUSH
91502: LD_INT 5
91504: PUSH
91505: LD_INT 7
91507: PUSH
91508: LD_INT 11
91510: PUSH
91511: LD_INT 12
91513: PUSH
91514: LD_INT 15
91516: PUSH
91517: LD_INT 16
91519: PUSH
91520: LD_INT 20
91522: PUSH
91523: LD_INT 21
91525: PUSH
91526: LD_INT 22
91528: PUSH
91529: LD_INT 23
91531: PUSH
91532: LD_INT 25
91534: PUSH
91535: LD_INT 26
91537: PUSH
91538: LD_INT 30
91540: PUSH
91541: LD_INT 31
91543: PUSH
91544: LD_INT 32
91546: PUSH
91547: LD_INT 33
91549: PUSH
91550: LD_INT 34
91552: PUSH
91553: LD_INT 35
91555: PUSH
91556: LD_INT 36
91558: PUSH
91559: EMPTY
91560: LIST
91561: LIST
91562: LIST
91563: LIST
91564: LIST
91565: LIST
91566: LIST
91567: LIST
91568: LIST
91569: LIST
91570: LIST
91571: LIST
91572: LIST
91573: LIST
91574: LIST
91575: LIST
91576: LIST
91577: LIST
91578: LIST
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 101
91584: PUSH
91585: LD_INT 102
91587: PUSH
91588: LD_INT 103
91590: PUSH
91591: LD_INT 106
91593: PUSH
91594: LD_INT 108
91596: PUSH
91597: LD_INT 112
91599: PUSH
91600: LD_INT 113
91602: PUSH
91603: LD_INT 114
91605: PUSH
91606: LD_INT 115
91608: PUSH
91609: LD_INT 116
91611: PUSH
91612: LD_INT 117
91614: PUSH
91615: LD_INT 118
91617: PUSH
91618: EMPTY
91619: LIST
91620: LIST
91621: LIST
91622: LIST
91623: LIST
91624: LIST
91625: LIST
91626: LIST
91627: LIST
91628: LIST
91629: LIST
91630: LIST
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: ST_TO_ADDR
91636: GO 91879
91638: LD_INT 19
91640: DOUBLE
91641: EQUAL
91642: IFTRUE 91646
91644: GO 91878
91646: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91647: LD_ADDR_VAR 0 2
91651: PUSH
91652: LD_INT 1
91654: PUSH
91655: LD_INT 2
91657: PUSH
91658: LD_INT 3
91660: PUSH
91661: LD_INT 4
91663: PUSH
91664: LD_INT 5
91666: PUSH
91667: LD_INT 6
91669: PUSH
91670: LD_INT 7
91672: PUSH
91673: LD_INT 8
91675: PUSH
91676: LD_INT 9
91678: PUSH
91679: LD_INT 10
91681: PUSH
91682: LD_INT 11
91684: PUSH
91685: LD_INT 12
91687: PUSH
91688: LD_INT 13
91690: PUSH
91691: LD_INT 14
91693: PUSH
91694: LD_INT 15
91696: PUSH
91697: LD_INT 16
91699: PUSH
91700: LD_INT 17
91702: PUSH
91703: LD_INT 18
91705: PUSH
91706: LD_INT 19
91708: PUSH
91709: LD_INT 20
91711: PUSH
91712: LD_INT 21
91714: PUSH
91715: LD_INT 22
91717: PUSH
91718: LD_INT 23
91720: PUSH
91721: LD_INT 24
91723: PUSH
91724: LD_INT 25
91726: PUSH
91727: LD_INT 26
91729: PUSH
91730: LD_INT 27
91732: PUSH
91733: LD_INT 28
91735: PUSH
91736: LD_INT 29
91738: PUSH
91739: LD_INT 30
91741: PUSH
91742: LD_INT 31
91744: PUSH
91745: LD_INT 32
91747: PUSH
91748: LD_INT 33
91750: PUSH
91751: LD_INT 34
91753: PUSH
91754: LD_INT 35
91756: PUSH
91757: LD_INT 36
91759: PUSH
91760: EMPTY
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: PUSH
91798: LD_INT 101
91800: PUSH
91801: LD_INT 102
91803: PUSH
91804: LD_INT 103
91806: PUSH
91807: LD_INT 104
91809: PUSH
91810: LD_INT 105
91812: PUSH
91813: LD_INT 106
91815: PUSH
91816: LD_INT 107
91818: PUSH
91819: LD_INT 108
91821: PUSH
91822: LD_INT 109
91824: PUSH
91825: LD_INT 110
91827: PUSH
91828: LD_INT 111
91830: PUSH
91831: LD_INT 112
91833: PUSH
91834: LD_INT 113
91836: PUSH
91837: LD_INT 114
91839: PUSH
91840: LD_INT 115
91842: PUSH
91843: LD_INT 116
91845: PUSH
91846: LD_INT 117
91848: PUSH
91849: LD_INT 118
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: LIST
91856: LIST
91857: LIST
91858: LIST
91859: LIST
91860: LIST
91861: LIST
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: ST_TO_ADDR
91876: GO 91879
91878: POP
// end else
91879: GO 92110
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
91881: LD_ADDR_VAR 0 2
91885: PUSH
91886: LD_INT 1
91888: PUSH
91889: LD_INT 2
91891: PUSH
91892: LD_INT 3
91894: PUSH
91895: LD_INT 4
91897: PUSH
91898: LD_INT 5
91900: PUSH
91901: LD_INT 6
91903: PUSH
91904: LD_INT 7
91906: PUSH
91907: LD_INT 8
91909: PUSH
91910: LD_INT 9
91912: PUSH
91913: LD_INT 10
91915: PUSH
91916: LD_INT 11
91918: PUSH
91919: LD_INT 12
91921: PUSH
91922: LD_INT 13
91924: PUSH
91925: LD_INT 14
91927: PUSH
91928: LD_INT 15
91930: PUSH
91931: LD_INT 16
91933: PUSH
91934: LD_INT 17
91936: PUSH
91937: LD_INT 18
91939: PUSH
91940: LD_INT 19
91942: PUSH
91943: LD_INT 20
91945: PUSH
91946: LD_INT 21
91948: PUSH
91949: LD_INT 22
91951: PUSH
91952: LD_INT 23
91954: PUSH
91955: LD_INT 24
91957: PUSH
91958: LD_INT 25
91960: PUSH
91961: LD_INT 26
91963: PUSH
91964: LD_INT 27
91966: PUSH
91967: LD_INT 28
91969: PUSH
91970: LD_INT 29
91972: PUSH
91973: LD_INT 30
91975: PUSH
91976: LD_INT 31
91978: PUSH
91979: LD_INT 32
91981: PUSH
91982: LD_INT 33
91984: PUSH
91985: LD_INT 34
91987: PUSH
91988: LD_INT 35
91990: PUSH
91991: LD_INT 36
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: PUSH
92032: LD_INT 101
92034: PUSH
92035: LD_INT 102
92037: PUSH
92038: LD_INT 103
92040: PUSH
92041: LD_INT 104
92043: PUSH
92044: LD_INT 105
92046: PUSH
92047: LD_INT 106
92049: PUSH
92050: LD_INT 107
92052: PUSH
92053: LD_INT 108
92055: PUSH
92056: LD_INT 109
92058: PUSH
92059: LD_INT 110
92061: PUSH
92062: LD_INT 111
92064: PUSH
92065: LD_INT 112
92067: PUSH
92068: LD_INT 113
92070: PUSH
92071: LD_INT 114
92073: PUSH
92074: LD_INT 115
92076: PUSH
92077: LD_INT 116
92079: PUSH
92080: LD_INT 117
92082: PUSH
92083: LD_INT 118
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: LIST
92103: LIST
92104: LIST
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: ST_TO_ADDR
// if result then
92110: LD_VAR 0 2
92114: IFFALSE 92900
// begin normal :=  ;
92116: LD_ADDR_VAR 0 5
92120: PUSH
92121: LD_STRING 
92123: ST_TO_ADDR
// hardcore :=  ;
92124: LD_ADDR_VAR 0 6
92128: PUSH
92129: LD_STRING 
92131: ST_TO_ADDR
// active :=  ;
92132: LD_ADDR_VAR 0 7
92136: PUSH
92137: LD_STRING 
92139: ST_TO_ADDR
// for i = 1 to normalCounter do
92140: LD_ADDR_VAR 0 8
92144: PUSH
92145: DOUBLE
92146: LD_INT 1
92148: DEC
92149: ST_TO_ADDR
92150: LD_EXP 106
92154: PUSH
92155: FOR_TO
92156: IFFALSE 92257
// begin tmp := 0 ;
92158: LD_ADDR_VAR 0 3
92162: PUSH
92163: LD_STRING 0
92165: ST_TO_ADDR
// if result [ 1 ] then
92166: LD_VAR 0 2
92170: PUSH
92171: LD_INT 1
92173: ARRAY
92174: IFFALSE 92239
// if result [ 1 ] [ 1 ] = i then
92176: LD_VAR 0 2
92180: PUSH
92181: LD_INT 1
92183: ARRAY
92184: PUSH
92185: LD_INT 1
92187: ARRAY
92188: PUSH
92189: LD_VAR 0 8
92193: EQUAL
92194: IFFALSE 92239
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92196: LD_ADDR_VAR 0 2
92200: PUSH
92201: LD_VAR 0 2
92205: PPUSH
92206: LD_INT 1
92208: PPUSH
92209: LD_VAR 0 2
92213: PUSH
92214: LD_INT 1
92216: ARRAY
92217: PPUSH
92218: LD_INT 1
92220: PPUSH
92221: CALL_OW 3
92225: PPUSH
92226: CALL_OW 1
92230: ST_TO_ADDR
// tmp := 1 ;
92231: LD_ADDR_VAR 0 3
92235: PUSH
92236: LD_STRING 1
92238: ST_TO_ADDR
// end ; normal := normal & tmp ;
92239: LD_ADDR_VAR 0 5
92243: PUSH
92244: LD_VAR 0 5
92248: PUSH
92249: LD_VAR 0 3
92253: STR
92254: ST_TO_ADDR
// end ;
92255: GO 92155
92257: POP
92258: POP
// for i = 1 to hardcoreCounter do
92259: LD_ADDR_VAR 0 8
92263: PUSH
92264: DOUBLE
92265: LD_INT 1
92267: DEC
92268: ST_TO_ADDR
92269: LD_EXP 107
92273: PUSH
92274: FOR_TO
92275: IFFALSE 92380
// begin tmp := 0 ;
92277: LD_ADDR_VAR 0 3
92281: PUSH
92282: LD_STRING 0
92284: ST_TO_ADDR
// if result [ 2 ] then
92285: LD_VAR 0 2
92289: PUSH
92290: LD_INT 2
92292: ARRAY
92293: IFFALSE 92362
// if result [ 2 ] [ 1 ] = 100 + i then
92295: LD_VAR 0 2
92299: PUSH
92300: LD_INT 2
92302: ARRAY
92303: PUSH
92304: LD_INT 1
92306: ARRAY
92307: PUSH
92308: LD_INT 100
92310: PUSH
92311: LD_VAR 0 8
92315: PLUS
92316: EQUAL
92317: IFFALSE 92362
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92319: LD_ADDR_VAR 0 2
92323: PUSH
92324: LD_VAR 0 2
92328: PPUSH
92329: LD_INT 2
92331: PPUSH
92332: LD_VAR 0 2
92336: PUSH
92337: LD_INT 2
92339: ARRAY
92340: PPUSH
92341: LD_INT 1
92343: PPUSH
92344: CALL_OW 3
92348: PPUSH
92349: CALL_OW 1
92353: ST_TO_ADDR
// tmp := 1 ;
92354: LD_ADDR_VAR 0 3
92358: PUSH
92359: LD_STRING 1
92361: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92362: LD_ADDR_VAR 0 6
92366: PUSH
92367: LD_VAR 0 6
92371: PUSH
92372: LD_VAR 0 3
92376: STR
92377: ST_TO_ADDR
// end ;
92378: GO 92274
92380: POP
92381: POP
// if isGameLoad then
92382: LD_VAR 0 1
92386: IFFALSE 92861
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92388: LD_ADDR_VAR 0 4
92392: PUSH
92393: LD_EXP 110
92397: PUSH
92398: LD_EXP 109
92402: PUSH
92403: LD_EXP 111
92407: PUSH
92408: LD_EXP 108
92412: PUSH
92413: LD_EXP 112
92417: PUSH
92418: LD_EXP 113
92422: PUSH
92423: LD_EXP 114
92427: PUSH
92428: LD_EXP 115
92432: PUSH
92433: LD_EXP 116
92437: PUSH
92438: LD_EXP 117
92442: PUSH
92443: LD_EXP 118
92447: PUSH
92448: LD_EXP 119
92452: PUSH
92453: LD_EXP 120
92457: PUSH
92458: LD_EXP 121
92462: PUSH
92463: LD_EXP 129
92467: PUSH
92468: LD_EXP 130
92472: PUSH
92473: LD_EXP 131
92477: PUSH
92478: LD_EXP 132
92482: PUSH
92483: LD_EXP 134
92487: PUSH
92488: LD_EXP 135
92492: PUSH
92493: LD_EXP 136
92497: PUSH
92498: LD_EXP 139
92502: PUSH
92503: LD_EXP 141
92507: PUSH
92508: LD_EXP 142
92512: PUSH
92513: LD_EXP 143
92517: PUSH
92518: LD_EXP 145
92522: PUSH
92523: LD_EXP 146
92527: PUSH
92528: LD_EXP 149
92532: PUSH
92533: LD_EXP 150
92537: PUSH
92538: LD_EXP 151
92542: PUSH
92543: LD_EXP 152
92547: PUSH
92548: LD_EXP 153
92552: PUSH
92553: LD_EXP 154
92557: PUSH
92558: LD_EXP 155
92562: PUSH
92563: LD_EXP 156
92567: PUSH
92568: LD_EXP 157
92572: PUSH
92573: LD_EXP 122
92577: PUSH
92578: LD_EXP 123
92582: PUSH
92583: LD_EXP 126
92587: PUSH
92588: LD_EXP 127
92592: PUSH
92593: LD_EXP 128
92597: PUSH
92598: LD_EXP 124
92602: PUSH
92603: LD_EXP 125
92607: PUSH
92608: LD_EXP 133
92612: PUSH
92613: LD_EXP 137
92617: PUSH
92618: LD_EXP 138
92622: PUSH
92623: LD_EXP 140
92627: PUSH
92628: LD_EXP 144
92632: PUSH
92633: LD_EXP 147
92637: PUSH
92638: LD_EXP 148
92642: PUSH
92643: LD_EXP 158
92647: PUSH
92648: LD_EXP 159
92652: PUSH
92653: LD_EXP 160
92657: PUSH
92658: LD_EXP 161
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: LIST
92699: LIST
92700: LIST
92701: LIST
92702: LIST
92703: LIST
92704: LIST
92705: LIST
92706: LIST
92707: LIST
92708: LIST
92709: LIST
92710: LIST
92711: LIST
92712: LIST
92713: LIST
92714: LIST
92715: LIST
92716: LIST
92717: LIST
92718: ST_TO_ADDR
// tmp :=  ;
92719: LD_ADDR_VAR 0 3
92723: PUSH
92724: LD_STRING 
92726: ST_TO_ADDR
// for i = 1 to normalCounter do
92727: LD_ADDR_VAR 0 8
92731: PUSH
92732: DOUBLE
92733: LD_INT 1
92735: DEC
92736: ST_TO_ADDR
92737: LD_EXP 106
92741: PUSH
92742: FOR_TO
92743: IFFALSE 92779
// begin if flags [ i ] then
92745: LD_VAR 0 4
92749: PUSH
92750: LD_VAR 0 8
92754: ARRAY
92755: IFFALSE 92777
// tmp := tmp & i & ; ;
92757: LD_ADDR_VAR 0 3
92761: PUSH
92762: LD_VAR 0 3
92766: PUSH
92767: LD_VAR 0 8
92771: STR
92772: PUSH
92773: LD_STRING ;
92775: STR
92776: ST_TO_ADDR
// end ;
92777: GO 92742
92779: POP
92780: POP
// for i = 1 to hardcoreCounter do
92781: LD_ADDR_VAR 0 8
92785: PUSH
92786: DOUBLE
92787: LD_INT 1
92789: DEC
92790: ST_TO_ADDR
92791: LD_EXP 107
92795: PUSH
92796: FOR_TO
92797: IFFALSE 92843
// begin if flags [ normalCounter + i ] then
92799: LD_VAR 0 4
92803: PUSH
92804: LD_EXP 106
92808: PUSH
92809: LD_VAR 0 8
92813: PLUS
92814: ARRAY
92815: IFFALSE 92841
// tmp := tmp & ( 100 + i ) & ; ;
92817: LD_ADDR_VAR 0 3
92821: PUSH
92822: LD_VAR 0 3
92826: PUSH
92827: LD_INT 100
92829: PUSH
92830: LD_VAR 0 8
92834: PLUS
92835: STR
92836: PUSH
92837: LD_STRING ;
92839: STR
92840: ST_TO_ADDR
// end ;
92841: GO 92796
92843: POP
92844: POP
// if tmp then
92845: LD_VAR 0 3
92849: IFFALSE 92861
// active := tmp ;
92851: LD_ADDR_VAR 0 7
92855: PUSH
92856: LD_VAR 0 3
92860: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
92861: LD_STRING getStreamItemsFromMission("
92863: PUSH
92864: LD_VAR 0 5
92868: STR
92869: PUSH
92870: LD_STRING ","
92872: STR
92873: PUSH
92874: LD_VAR 0 6
92878: STR
92879: PUSH
92880: LD_STRING ","
92882: STR
92883: PUSH
92884: LD_VAR 0 7
92888: STR
92889: PUSH
92890: LD_STRING ")
92892: STR
92893: PPUSH
92894: CALL_OW 559
// end else
92898: GO 92907
// ToLua ( getStreamItemsFromMission("","","") ) ;
92900: LD_STRING getStreamItemsFromMission("","","")
92902: PPUSH
92903: CALL_OW 559
// end ;
92907: LD_VAR 0 2
92911: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92912: LD_EXP 105
92916: PUSH
92917: LD_EXP 110
92921: AND
92922: IFFALSE 93046
92924: GO 92926
92926: DISABLE
92927: LD_INT 0
92929: PPUSH
92930: PPUSH
// begin enable ;
92931: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92932: LD_ADDR_VAR 0 2
92936: PUSH
92937: LD_INT 22
92939: PUSH
92940: LD_OWVAR 2
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 2
92951: PUSH
92952: LD_INT 34
92954: PUSH
92955: LD_INT 7
92957: PUSH
92958: EMPTY
92959: LIST
92960: LIST
92961: PUSH
92962: LD_INT 34
92964: PUSH
92965: LD_INT 45
92967: PUSH
92968: EMPTY
92969: LIST
92970: LIST
92971: PUSH
92972: LD_INT 34
92974: PUSH
92975: LD_INT 28
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: LD_INT 34
92984: PUSH
92985: LD_INT 47
92987: PUSH
92988: EMPTY
92989: LIST
92990: LIST
92991: PUSH
92992: EMPTY
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PPUSH
93003: CALL_OW 69
93007: ST_TO_ADDR
// if not tmp then
93008: LD_VAR 0 2
93012: NOT
93013: IFFALSE 93017
// exit ;
93015: GO 93046
// for i in tmp do
93017: LD_ADDR_VAR 0 1
93021: PUSH
93022: LD_VAR 0 2
93026: PUSH
93027: FOR_IN
93028: IFFALSE 93044
// begin SetLives ( i , 0 ) ;
93030: LD_VAR 0 1
93034: PPUSH
93035: LD_INT 0
93037: PPUSH
93038: CALL_OW 234
// end ;
93042: GO 93027
93044: POP
93045: POP
// end ;
93046: PPOPN 2
93048: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93049: LD_EXP 105
93053: PUSH
93054: LD_EXP 111
93058: AND
93059: IFFALSE 93143
93061: GO 93063
93063: DISABLE
93064: LD_INT 0
93066: PPUSH
93067: PPUSH
// begin enable ;
93068: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93069: LD_ADDR_VAR 0 2
93073: PUSH
93074: LD_INT 22
93076: PUSH
93077: LD_OWVAR 2
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 32
93088: PUSH
93089: LD_INT 3
93091: PUSH
93092: EMPTY
93093: LIST
93094: LIST
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PPUSH
93100: CALL_OW 69
93104: ST_TO_ADDR
// if not tmp then
93105: LD_VAR 0 2
93109: NOT
93110: IFFALSE 93114
// exit ;
93112: GO 93143
// for i in tmp do
93114: LD_ADDR_VAR 0 1
93118: PUSH
93119: LD_VAR 0 2
93123: PUSH
93124: FOR_IN
93125: IFFALSE 93141
// begin SetLives ( i , 0 ) ;
93127: LD_VAR 0 1
93131: PPUSH
93132: LD_INT 0
93134: PPUSH
93135: CALL_OW 234
// end ;
93139: GO 93124
93141: POP
93142: POP
// end ;
93143: PPOPN 2
93145: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93146: LD_EXP 105
93150: PUSH
93151: LD_EXP 108
93155: AND
93156: IFFALSE 93249
93158: GO 93160
93160: DISABLE
93161: LD_INT 0
93163: PPUSH
// begin enable ;
93164: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93165: LD_ADDR_VAR 0 1
93169: PUSH
93170: LD_INT 22
93172: PUSH
93173: LD_OWVAR 2
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 2
93184: PUSH
93185: LD_INT 25
93187: PUSH
93188: LD_INT 5
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 25
93197: PUSH
93198: LD_INT 9
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 25
93207: PUSH
93208: LD_INT 8
93210: PUSH
93211: EMPTY
93212: LIST
93213: LIST
93214: PUSH
93215: EMPTY
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: PUSH
93221: EMPTY
93222: LIST
93223: LIST
93224: PPUSH
93225: CALL_OW 69
93229: PUSH
93230: FOR_IN
93231: IFFALSE 93247
// begin SetClass ( i , 1 ) ;
93233: LD_VAR 0 1
93237: PPUSH
93238: LD_INT 1
93240: PPUSH
93241: CALL_OW 336
// end ;
93245: GO 93230
93247: POP
93248: POP
// end ;
93249: PPOPN 1
93251: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93252: LD_EXP 105
93256: PUSH
93257: LD_EXP 109
93261: AND
93262: PUSH
93263: LD_OWVAR 65
93267: PUSH
93268: LD_INT 7
93270: LESS
93271: AND
93272: IFFALSE 93286
93274: GO 93276
93276: DISABLE
// begin enable ;
93277: ENABLE
// game_speed := 7 ;
93278: LD_ADDR_OWVAR 65
93282: PUSH
93283: LD_INT 7
93285: ST_TO_ADDR
// end ;
93286: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93287: LD_EXP 105
93291: PUSH
93292: LD_EXP 112
93296: AND
93297: IFFALSE 93499
93299: GO 93301
93301: DISABLE
93302: LD_INT 0
93304: PPUSH
93305: PPUSH
93306: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93307: LD_ADDR_VAR 0 3
93311: PUSH
93312: LD_INT 81
93314: PUSH
93315: LD_OWVAR 2
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 21
93326: PUSH
93327: LD_INT 1
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PPUSH
93338: CALL_OW 69
93342: ST_TO_ADDR
// if not tmp then
93343: LD_VAR 0 3
93347: NOT
93348: IFFALSE 93352
// exit ;
93350: GO 93499
// if tmp > 5 then
93352: LD_VAR 0 3
93356: PUSH
93357: LD_INT 5
93359: GREATER
93360: IFFALSE 93372
// k := 5 else
93362: LD_ADDR_VAR 0 2
93366: PUSH
93367: LD_INT 5
93369: ST_TO_ADDR
93370: GO 93382
// k := tmp ;
93372: LD_ADDR_VAR 0 2
93376: PUSH
93377: LD_VAR 0 3
93381: ST_TO_ADDR
// for i := 1 to k do
93382: LD_ADDR_VAR 0 1
93386: PUSH
93387: DOUBLE
93388: LD_INT 1
93390: DEC
93391: ST_TO_ADDR
93392: LD_VAR 0 2
93396: PUSH
93397: FOR_TO
93398: IFFALSE 93497
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93400: LD_VAR 0 3
93404: PUSH
93405: LD_VAR 0 1
93409: ARRAY
93410: PPUSH
93411: LD_VAR 0 1
93415: PUSH
93416: LD_INT 4
93418: MOD
93419: PUSH
93420: LD_INT 1
93422: PLUS
93423: PPUSH
93424: CALL_OW 259
93428: PUSH
93429: LD_INT 10
93431: LESS
93432: IFFALSE 93495
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93434: LD_VAR 0 3
93438: PUSH
93439: LD_VAR 0 1
93443: ARRAY
93444: PPUSH
93445: LD_VAR 0 1
93449: PUSH
93450: LD_INT 4
93452: MOD
93453: PUSH
93454: LD_INT 1
93456: PLUS
93457: PPUSH
93458: LD_VAR 0 3
93462: PUSH
93463: LD_VAR 0 1
93467: ARRAY
93468: PPUSH
93469: LD_VAR 0 1
93473: PUSH
93474: LD_INT 4
93476: MOD
93477: PUSH
93478: LD_INT 1
93480: PLUS
93481: PPUSH
93482: CALL_OW 259
93486: PUSH
93487: LD_INT 1
93489: PLUS
93490: PPUSH
93491: CALL_OW 237
93495: GO 93397
93497: POP
93498: POP
// end ;
93499: PPOPN 3
93501: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93502: LD_EXP 105
93506: PUSH
93507: LD_EXP 113
93511: AND
93512: IFFALSE 93532
93514: GO 93516
93516: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93517: LD_INT 4
93519: PPUSH
93520: LD_OWVAR 2
93524: PPUSH
93525: LD_INT 0
93527: PPUSH
93528: CALL_OW 324
93532: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93533: LD_EXP 105
93537: PUSH
93538: LD_EXP 142
93542: AND
93543: IFFALSE 93563
93545: GO 93547
93547: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93548: LD_INT 19
93550: PPUSH
93551: LD_OWVAR 2
93555: PPUSH
93556: LD_INT 0
93558: PPUSH
93559: CALL_OW 324
93563: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93564: LD_EXP 105
93568: PUSH
93569: LD_EXP 114
93573: AND
93574: IFFALSE 93676
93576: GO 93578
93578: DISABLE
93579: LD_INT 0
93581: PPUSH
93582: PPUSH
// begin enable ;
93583: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93584: LD_ADDR_VAR 0 2
93588: PUSH
93589: LD_INT 22
93591: PUSH
93592: LD_OWVAR 2
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 2
93603: PUSH
93604: LD_INT 34
93606: PUSH
93607: LD_INT 11
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 34
93616: PUSH
93617: LD_INT 30
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: LIST
93628: PUSH
93629: EMPTY
93630: LIST
93631: LIST
93632: PPUSH
93633: CALL_OW 69
93637: ST_TO_ADDR
// if not tmp then
93638: LD_VAR 0 2
93642: NOT
93643: IFFALSE 93647
// exit ;
93645: GO 93676
// for i in tmp do
93647: LD_ADDR_VAR 0 1
93651: PUSH
93652: LD_VAR 0 2
93656: PUSH
93657: FOR_IN
93658: IFFALSE 93674
// begin SetLives ( i , 0 ) ;
93660: LD_VAR 0 1
93664: PPUSH
93665: LD_INT 0
93667: PPUSH
93668: CALL_OW 234
// end ;
93672: GO 93657
93674: POP
93675: POP
// end ;
93676: PPOPN 2
93678: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93679: LD_EXP 105
93683: PUSH
93684: LD_EXP 115
93688: AND
93689: IFFALSE 93709
93691: GO 93693
93693: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93694: LD_INT 32
93696: PPUSH
93697: LD_OWVAR 2
93701: PPUSH
93702: LD_INT 0
93704: PPUSH
93705: CALL_OW 324
93709: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93710: LD_EXP 105
93714: PUSH
93715: LD_EXP 116
93719: AND
93720: IFFALSE 93901
93722: GO 93724
93724: DISABLE
93725: LD_INT 0
93727: PPUSH
93728: PPUSH
93729: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93730: LD_ADDR_VAR 0 2
93734: PUSH
93735: LD_INT 22
93737: PUSH
93738: LD_OWVAR 2
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 33
93749: PUSH
93750: LD_INT 3
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PPUSH
93761: CALL_OW 69
93765: ST_TO_ADDR
// if not tmp then
93766: LD_VAR 0 2
93770: NOT
93771: IFFALSE 93775
// exit ;
93773: GO 93901
// side := 0 ;
93775: LD_ADDR_VAR 0 3
93779: PUSH
93780: LD_INT 0
93782: ST_TO_ADDR
// for i := 1 to 8 do
93783: LD_ADDR_VAR 0 1
93787: PUSH
93788: DOUBLE
93789: LD_INT 1
93791: DEC
93792: ST_TO_ADDR
93793: LD_INT 8
93795: PUSH
93796: FOR_TO
93797: IFFALSE 93845
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93799: LD_OWVAR 2
93803: PUSH
93804: LD_VAR 0 1
93808: NONEQUAL
93809: PUSH
93810: LD_OWVAR 2
93814: PPUSH
93815: LD_VAR 0 1
93819: PPUSH
93820: CALL_OW 81
93824: PUSH
93825: LD_INT 2
93827: EQUAL
93828: AND
93829: IFFALSE 93843
// begin side := i ;
93831: LD_ADDR_VAR 0 3
93835: PUSH
93836: LD_VAR 0 1
93840: ST_TO_ADDR
// break ;
93841: GO 93845
// end ;
93843: GO 93796
93845: POP
93846: POP
// if not side then
93847: LD_VAR 0 3
93851: NOT
93852: IFFALSE 93856
// exit ;
93854: GO 93901
// for i := 1 to tmp do
93856: LD_ADDR_VAR 0 1
93860: PUSH
93861: DOUBLE
93862: LD_INT 1
93864: DEC
93865: ST_TO_ADDR
93866: LD_VAR 0 2
93870: PUSH
93871: FOR_TO
93872: IFFALSE 93899
// if Prob ( 60 ) then
93874: LD_INT 60
93876: PPUSH
93877: CALL_OW 13
93881: IFFALSE 93897
// SetSide ( i , side ) ;
93883: LD_VAR 0 1
93887: PPUSH
93888: LD_VAR 0 3
93892: PPUSH
93893: CALL_OW 235
93897: GO 93871
93899: POP
93900: POP
// end ;
93901: PPOPN 3
93903: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93904: LD_EXP 105
93908: PUSH
93909: LD_EXP 118
93913: AND
93914: IFFALSE 94033
93916: GO 93918
93918: DISABLE
93919: LD_INT 0
93921: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93922: LD_ADDR_VAR 0 1
93926: PUSH
93927: LD_INT 22
93929: PUSH
93930: LD_OWVAR 2
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: PUSH
93939: LD_INT 21
93941: PUSH
93942: LD_INT 1
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 3
93951: PUSH
93952: LD_INT 23
93954: PUSH
93955: LD_INT 0
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: LIST
93970: PPUSH
93971: CALL_OW 69
93975: PUSH
93976: FOR_IN
93977: IFFALSE 94031
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93979: LD_VAR 0 1
93983: PPUSH
93984: CALL_OW 257
93988: PUSH
93989: LD_INT 1
93991: PUSH
93992: LD_INT 2
93994: PUSH
93995: LD_INT 3
93997: PUSH
93998: LD_INT 4
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: IN
94007: IFFALSE 94029
// SetClass ( un , rand ( 1 , 4 ) ) ;
94009: LD_VAR 0 1
94013: PPUSH
94014: LD_INT 1
94016: PPUSH
94017: LD_INT 4
94019: PPUSH
94020: CALL_OW 12
94024: PPUSH
94025: CALL_OW 336
94029: GO 93976
94031: POP
94032: POP
// end ;
94033: PPOPN 1
94035: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94036: LD_EXP 105
94040: PUSH
94041: LD_EXP 117
94045: AND
94046: IFFALSE 94125
94048: GO 94050
94050: DISABLE
94051: LD_INT 0
94053: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94054: LD_ADDR_VAR 0 1
94058: PUSH
94059: LD_INT 22
94061: PUSH
94062: LD_OWVAR 2
94066: PUSH
94067: EMPTY
94068: LIST
94069: LIST
94070: PUSH
94071: LD_INT 21
94073: PUSH
94074: LD_INT 3
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PPUSH
94085: CALL_OW 69
94089: ST_TO_ADDR
// if not tmp then
94090: LD_VAR 0 1
94094: NOT
94095: IFFALSE 94099
// exit ;
94097: GO 94125
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94099: LD_VAR 0 1
94103: PUSH
94104: LD_INT 1
94106: PPUSH
94107: LD_VAR 0 1
94111: PPUSH
94112: CALL_OW 12
94116: ARRAY
94117: PPUSH
94118: LD_INT 100
94120: PPUSH
94121: CALL_OW 234
// end ;
94125: PPOPN 1
94127: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94128: LD_EXP 105
94132: PUSH
94133: LD_EXP 119
94137: AND
94138: IFFALSE 94236
94140: GO 94142
94142: DISABLE
94143: LD_INT 0
94145: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94146: LD_ADDR_VAR 0 1
94150: PUSH
94151: LD_INT 22
94153: PUSH
94154: LD_OWVAR 2
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: PUSH
94163: LD_INT 21
94165: PUSH
94166: LD_INT 1
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: EMPTY
94174: LIST
94175: LIST
94176: PPUSH
94177: CALL_OW 69
94181: ST_TO_ADDR
// if not tmp then
94182: LD_VAR 0 1
94186: NOT
94187: IFFALSE 94191
// exit ;
94189: GO 94236
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94191: LD_VAR 0 1
94195: PUSH
94196: LD_INT 1
94198: PPUSH
94199: LD_VAR 0 1
94203: PPUSH
94204: CALL_OW 12
94208: ARRAY
94209: PPUSH
94210: LD_INT 1
94212: PPUSH
94213: LD_INT 4
94215: PPUSH
94216: CALL_OW 12
94220: PPUSH
94221: LD_INT 3000
94223: PPUSH
94224: LD_INT 9000
94226: PPUSH
94227: CALL_OW 12
94231: PPUSH
94232: CALL_OW 492
// end ;
94236: PPOPN 1
94238: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94239: LD_EXP 105
94243: PUSH
94244: LD_EXP 120
94248: AND
94249: IFFALSE 94269
94251: GO 94253
94253: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94254: LD_INT 1
94256: PPUSH
94257: LD_OWVAR 2
94261: PPUSH
94262: LD_INT 0
94264: PPUSH
94265: CALL_OW 324
94269: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94270: LD_EXP 105
94274: PUSH
94275: LD_EXP 121
94279: AND
94280: IFFALSE 94363
94282: GO 94284
94284: DISABLE
94285: LD_INT 0
94287: PPUSH
94288: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94289: LD_ADDR_VAR 0 2
94293: PUSH
94294: LD_INT 22
94296: PUSH
94297: LD_OWVAR 2
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 21
94308: PUSH
94309: LD_INT 3
94311: PUSH
94312: EMPTY
94313: LIST
94314: LIST
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: PPUSH
94320: CALL_OW 69
94324: ST_TO_ADDR
// if not tmp then
94325: LD_VAR 0 2
94329: NOT
94330: IFFALSE 94334
// exit ;
94332: GO 94363
// for i in tmp do
94334: LD_ADDR_VAR 0 1
94338: PUSH
94339: LD_VAR 0 2
94343: PUSH
94344: FOR_IN
94345: IFFALSE 94361
// SetBLevel ( i , 10 ) ;
94347: LD_VAR 0 1
94351: PPUSH
94352: LD_INT 10
94354: PPUSH
94355: CALL_OW 241
94359: GO 94344
94361: POP
94362: POP
// end ;
94363: PPOPN 2
94365: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94366: LD_EXP 105
94370: PUSH
94371: LD_EXP 122
94375: AND
94376: IFFALSE 94487
94378: GO 94380
94380: DISABLE
94381: LD_INT 0
94383: PPUSH
94384: PPUSH
94385: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94386: LD_ADDR_VAR 0 3
94390: PUSH
94391: LD_INT 22
94393: PUSH
94394: LD_OWVAR 2
94398: PUSH
94399: EMPTY
94400: LIST
94401: LIST
94402: PUSH
94403: LD_INT 25
94405: PUSH
94406: LD_INT 1
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PPUSH
94417: CALL_OW 69
94421: ST_TO_ADDR
// if not tmp then
94422: LD_VAR 0 3
94426: NOT
94427: IFFALSE 94431
// exit ;
94429: GO 94487
// un := tmp [ rand ( 1 , tmp ) ] ;
94431: LD_ADDR_VAR 0 2
94435: PUSH
94436: LD_VAR 0 3
94440: PUSH
94441: LD_INT 1
94443: PPUSH
94444: LD_VAR 0 3
94448: PPUSH
94449: CALL_OW 12
94453: ARRAY
94454: ST_TO_ADDR
// if Crawls ( un ) then
94455: LD_VAR 0 2
94459: PPUSH
94460: CALL_OW 318
94464: IFFALSE 94475
// ComWalk ( un ) ;
94466: LD_VAR 0 2
94470: PPUSH
94471: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94475: LD_VAR 0 2
94479: PPUSH
94480: LD_INT 5
94482: PPUSH
94483: CALL_OW 336
// end ;
94487: PPOPN 3
94489: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94490: LD_EXP 105
94494: PUSH
94495: LD_EXP 123
94499: AND
94500: PUSH
94501: LD_OWVAR 67
94505: PUSH
94506: LD_INT 4
94508: LESS
94509: AND
94510: IFFALSE 94529
94512: GO 94514
94514: DISABLE
// begin Difficulty := Difficulty + 1 ;
94515: LD_ADDR_OWVAR 67
94519: PUSH
94520: LD_OWVAR 67
94524: PUSH
94525: LD_INT 1
94527: PLUS
94528: ST_TO_ADDR
// end ;
94529: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94530: LD_EXP 105
94534: PUSH
94535: LD_EXP 124
94539: AND
94540: IFFALSE 94643
94542: GO 94544
94544: DISABLE
94545: LD_INT 0
94547: PPUSH
// begin for i := 1 to 5 do
94548: LD_ADDR_VAR 0 1
94552: PUSH
94553: DOUBLE
94554: LD_INT 1
94556: DEC
94557: ST_TO_ADDR
94558: LD_INT 5
94560: PUSH
94561: FOR_TO
94562: IFFALSE 94641
// begin uc_nation := nation_nature ;
94564: LD_ADDR_OWVAR 21
94568: PUSH
94569: LD_INT 0
94571: ST_TO_ADDR
// uc_side := 0 ;
94572: LD_ADDR_OWVAR 20
94576: PUSH
94577: LD_INT 0
94579: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94580: LD_ADDR_OWVAR 29
94584: PUSH
94585: LD_INT 12
94587: PUSH
94588: LD_INT 12
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: ST_TO_ADDR
// hc_agressivity := 20 ;
94595: LD_ADDR_OWVAR 35
94599: PUSH
94600: LD_INT 20
94602: ST_TO_ADDR
// hc_class := class_tiger ;
94603: LD_ADDR_OWVAR 28
94607: PUSH
94608: LD_INT 14
94610: ST_TO_ADDR
// hc_gallery :=  ;
94611: LD_ADDR_OWVAR 33
94615: PUSH
94616: LD_STRING 
94618: ST_TO_ADDR
// hc_name :=  ;
94619: LD_ADDR_OWVAR 26
94623: PUSH
94624: LD_STRING 
94626: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94627: CALL_OW 44
94631: PPUSH
94632: LD_INT 0
94634: PPUSH
94635: CALL_OW 51
// end ;
94639: GO 94561
94641: POP
94642: POP
// end ;
94643: PPOPN 1
94645: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94646: LD_EXP 105
94650: PUSH
94651: LD_EXP 125
94655: AND
94656: IFFALSE 94665
94658: GO 94660
94660: DISABLE
// StreamSibBomb ;
94661: CALL 94666 0 0
94665: END
// export function StreamSibBomb ; var i , x , y ; begin
94666: LD_INT 0
94668: PPUSH
94669: PPUSH
94670: PPUSH
94671: PPUSH
// result := false ;
94672: LD_ADDR_VAR 0 1
94676: PUSH
94677: LD_INT 0
94679: ST_TO_ADDR
// for i := 1 to 16 do
94680: LD_ADDR_VAR 0 2
94684: PUSH
94685: DOUBLE
94686: LD_INT 1
94688: DEC
94689: ST_TO_ADDR
94690: LD_INT 16
94692: PUSH
94693: FOR_TO
94694: IFFALSE 94893
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94696: LD_ADDR_VAR 0 3
94700: PUSH
94701: LD_INT 10
94703: PUSH
94704: LD_INT 20
94706: PUSH
94707: LD_INT 30
94709: PUSH
94710: LD_INT 40
94712: PUSH
94713: LD_INT 50
94715: PUSH
94716: LD_INT 60
94718: PUSH
94719: LD_INT 70
94721: PUSH
94722: LD_INT 80
94724: PUSH
94725: LD_INT 90
94727: PUSH
94728: LD_INT 100
94730: PUSH
94731: LD_INT 110
94733: PUSH
94734: LD_INT 120
94736: PUSH
94737: LD_INT 130
94739: PUSH
94740: LD_INT 140
94742: PUSH
94743: LD_INT 150
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 1
94765: PPUSH
94766: LD_INT 15
94768: PPUSH
94769: CALL_OW 12
94773: ARRAY
94774: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94775: LD_ADDR_VAR 0 4
94779: PUSH
94780: LD_INT 10
94782: PUSH
94783: LD_INT 20
94785: PUSH
94786: LD_INT 30
94788: PUSH
94789: LD_INT 40
94791: PUSH
94792: LD_INT 50
94794: PUSH
94795: LD_INT 60
94797: PUSH
94798: LD_INT 70
94800: PUSH
94801: LD_INT 80
94803: PUSH
94804: LD_INT 90
94806: PUSH
94807: LD_INT 100
94809: PUSH
94810: LD_INT 110
94812: PUSH
94813: LD_INT 120
94815: PUSH
94816: LD_INT 130
94818: PUSH
94819: LD_INT 140
94821: PUSH
94822: LD_INT 150
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: PUSH
94842: LD_INT 1
94844: PPUSH
94845: LD_INT 15
94847: PPUSH
94848: CALL_OW 12
94852: ARRAY
94853: ST_TO_ADDR
// if ValidHex ( x , y ) then
94854: LD_VAR 0 3
94858: PPUSH
94859: LD_VAR 0 4
94863: PPUSH
94864: CALL_OW 488
94868: IFFALSE 94891
// begin result := [ x , y ] ;
94870: LD_ADDR_VAR 0 1
94874: PUSH
94875: LD_VAR 0 3
94879: PUSH
94880: LD_VAR 0 4
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: ST_TO_ADDR
// break ;
94889: GO 94893
// end ; end ;
94891: GO 94693
94893: POP
94894: POP
// if result then
94895: LD_VAR 0 1
94899: IFFALSE 94959
// begin ToLua ( playSibBomb() ) ;
94901: LD_STRING playSibBomb()
94903: PPUSH
94904: CALL_OW 559
// wait ( 0 0$14 ) ;
94908: LD_INT 490
94910: PPUSH
94911: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94915: LD_VAR 0 1
94919: PUSH
94920: LD_INT 1
94922: ARRAY
94923: PPUSH
94924: LD_VAR 0 1
94928: PUSH
94929: LD_INT 2
94931: ARRAY
94932: PPUSH
94933: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94937: LD_VAR 0 1
94941: PUSH
94942: LD_INT 1
94944: ARRAY
94945: PPUSH
94946: LD_VAR 0 1
94950: PUSH
94951: LD_INT 2
94953: ARRAY
94954: PPUSH
94955: CALL_OW 429
// end ; end ;
94959: LD_VAR 0 1
94963: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94964: LD_EXP 105
94968: PUSH
94969: LD_EXP 127
94973: AND
94974: IFFALSE 94986
94976: GO 94978
94978: DISABLE
// YouLost (  ) ;
94979: LD_STRING 
94981: PPUSH
94982: CALL_OW 104
94986: END
// every 0 0$1 trigger StreamModeActive and sFog do
94987: LD_EXP 105
94991: PUSH
94992: LD_EXP 126
94996: AND
94997: IFFALSE 95011
94999: GO 95001
95001: DISABLE
// FogOff ( your_side ) ;
95002: LD_OWVAR 2
95006: PPUSH
95007: CALL_OW 344
95011: END
// every 0 0$1 trigger StreamModeActive and sSun do
95012: LD_EXP 105
95016: PUSH
95017: LD_EXP 128
95021: AND
95022: IFFALSE 95050
95024: GO 95026
95026: DISABLE
// begin solar_recharge_percent := 0 ;
95027: LD_ADDR_OWVAR 79
95031: PUSH
95032: LD_INT 0
95034: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95035: LD_INT 10500
95037: PPUSH
95038: CALL_OW 67
// solar_recharge_percent := 100 ;
95042: LD_ADDR_OWVAR 79
95046: PUSH
95047: LD_INT 100
95049: ST_TO_ADDR
// end ;
95050: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95051: LD_EXP 105
95055: PUSH
95056: LD_EXP 129
95060: AND
95061: IFFALSE 95300
95063: GO 95065
95065: DISABLE
95066: LD_INT 0
95068: PPUSH
95069: PPUSH
95070: PPUSH
// begin tmp := [ ] ;
95071: LD_ADDR_VAR 0 3
95075: PUSH
95076: EMPTY
95077: ST_TO_ADDR
// for i := 1 to 6 do
95078: LD_ADDR_VAR 0 1
95082: PUSH
95083: DOUBLE
95084: LD_INT 1
95086: DEC
95087: ST_TO_ADDR
95088: LD_INT 6
95090: PUSH
95091: FOR_TO
95092: IFFALSE 95197
// begin uc_nation := nation_nature ;
95094: LD_ADDR_OWVAR 21
95098: PUSH
95099: LD_INT 0
95101: ST_TO_ADDR
// uc_side := 0 ;
95102: LD_ADDR_OWVAR 20
95106: PUSH
95107: LD_INT 0
95109: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95110: LD_ADDR_OWVAR 29
95114: PUSH
95115: LD_INT 12
95117: PUSH
95118: LD_INT 12
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: ST_TO_ADDR
// hc_agressivity := 20 ;
95125: LD_ADDR_OWVAR 35
95129: PUSH
95130: LD_INT 20
95132: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95133: LD_ADDR_OWVAR 28
95137: PUSH
95138: LD_INT 17
95140: ST_TO_ADDR
// hc_gallery :=  ;
95141: LD_ADDR_OWVAR 33
95145: PUSH
95146: LD_STRING 
95148: ST_TO_ADDR
// hc_name :=  ;
95149: LD_ADDR_OWVAR 26
95153: PUSH
95154: LD_STRING 
95156: ST_TO_ADDR
// un := CreateHuman ;
95157: LD_ADDR_VAR 0 2
95161: PUSH
95162: CALL_OW 44
95166: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95167: LD_VAR 0 2
95171: PPUSH
95172: LD_INT 1
95174: PPUSH
95175: CALL_OW 51
// tmp := tmp ^ un ;
95179: LD_ADDR_VAR 0 3
95183: PUSH
95184: LD_VAR 0 3
95188: PUSH
95189: LD_VAR 0 2
95193: ADD
95194: ST_TO_ADDR
// end ;
95195: GO 95091
95197: POP
95198: POP
// repeat wait ( 0 0$1 ) ;
95199: LD_INT 35
95201: PPUSH
95202: CALL_OW 67
// for un in tmp do
95206: LD_ADDR_VAR 0 2
95210: PUSH
95211: LD_VAR 0 3
95215: PUSH
95216: FOR_IN
95217: IFFALSE 95291
// begin if IsDead ( un ) then
95219: LD_VAR 0 2
95223: PPUSH
95224: CALL_OW 301
95228: IFFALSE 95248
// begin tmp := tmp diff un ;
95230: LD_ADDR_VAR 0 3
95234: PUSH
95235: LD_VAR 0 3
95239: PUSH
95240: LD_VAR 0 2
95244: DIFF
95245: ST_TO_ADDR
// continue ;
95246: GO 95216
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95248: LD_VAR 0 2
95252: PPUSH
95253: LD_INT 3
95255: PUSH
95256: LD_INT 22
95258: PUSH
95259: LD_INT 0
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PPUSH
95270: CALL_OW 69
95274: PPUSH
95275: LD_VAR 0 2
95279: PPUSH
95280: CALL_OW 74
95284: PPUSH
95285: CALL_OW 115
// end ;
95289: GO 95216
95291: POP
95292: POP
// until not tmp ;
95293: LD_VAR 0 3
95297: NOT
95298: IFFALSE 95199
// end ;
95300: PPOPN 3
95302: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95303: LD_EXP 105
95307: PUSH
95308: LD_EXP 130
95312: AND
95313: IFFALSE 95367
95315: GO 95317
95317: DISABLE
// begin ToLua ( displayTroll(); ) ;
95318: LD_STRING displayTroll();
95320: PPUSH
95321: CALL_OW 559
// wait ( 3 3$00 ) ;
95325: LD_INT 6300
95327: PPUSH
95328: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95332: LD_STRING hideTroll();
95334: PPUSH
95335: CALL_OW 559
// wait ( 1 1$00 ) ;
95339: LD_INT 2100
95341: PPUSH
95342: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95346: LD_STRING displayTroll();
95348: PPUSH
95349: CALL_OW 559
// wait ( 1 1$00 ) ;
95353: LD_INT 2100
95355: PPUSH
95356: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95360: LD_STRING hideTroll();
95362: PPUSH
95363: CALL_OW 559
// end ;
95367: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95368: LD_EXP 105
95372: PUSH
95373: LD_EXP 131
95377: AND
95378: IFFALSE 95441
95380: GO 95382
95382: DISABLE
95383: LD_INT 0
95385: PPUSH
// begin p := 0 ;
95386: LD_ADDR_VAR 0 1
95390: PUSH
95391: LD_INT 0
95393: ST_TO_ADDR
// repeat game_speed := 1 ;
95394: LD_ADDR_OWVAR 65
95398: PUSH
95399: LD_INT 1
95401: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95402: LD_INT 35
95404: PPUSH
95405: CALL_OW 67
// p := p + 1 ;
95409: LD_ADDR_VAR 0 1
95413: PUSH
95414: LD_VAR 0 1
95418: PUSH
95419: LD_INT 1
95421: PLUS
95422: ST_TO_ADDR
// until p >= 60 ;
95423: LD_VAR 0 1
95427: PUSH
95428: LD_INT 60
95430: GREATEREQUAL
95431: IFFALSE 95394
// game_speed := 4 ;
95433: LD_ADDR_OWVAR 65
95437: PUSH
95438: LD_INT 4
95440: ST_TO_ADDR
// end ;
95441: PPOPN 1
95443: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95444: LD_EXP 105
95448: PUSH
95449: LD_EXP 132
95453: AND
95454: IFFALSE 95600
95456: GO 95458
95458: DISABLE
95459: LD_INT 0
95461: PPUSH
95462: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95463: LD_ADDR_VAR 0 1
95467: PUSH
95468: LD_INT 22
95470: PUSH
95471: LD_OWVAR 2
95475: PUSH
95476: EMPTY
95477: LIST
95478: LIST
95479: PUSH
95480: LD_INT 2
95482: PUSH
95483: LD_INT 30
95485: PUSH
95486: LD_INT 0
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: PUSH
95493: LD_INT 30
95495: PUSH
95496: LD_INT 1
95498: PUSH
95499: EMPTY
95500: LIST
95501: LIST
95502: PUSH
95503: EMPTY
95504: LIST
95505: LIST
95506: LIST
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: PPUSH
95512: CALL_OW 69
95516: ST_TO_ADDR
// if not depot then
95517: LD_VAR 0 1
95521: NOT
95522: IFFALSE 95526
// exit ;
95524: GO 95600
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95526: LD_ADDR_VAR 0 2
95530: PUSH
95531: LD_VAR 0 1
95535: PUSH
95536: LD_INT 1
95538: PPUSH
95539: LD_VAR 0 1
95543: PPUSH
95544: CALL_OW 12
95548: ARRAY
95549: PPUSH
95550: CALL_OW 274
95554: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95555: LD_VAR 0 2
95559: PPUSH
95560: LD_INT 1
95562: PPUSH
95563: LD_INT 0
95565: PPUSH
95566: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95570: LD_VAR 0 2
95574: PPUSH
95575: LD_INT 2
95577: PPUSH
95578: LD_INT 0
95580: PPUSH
95581: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95585: LD_VAR 0 2
95589: PPUSH
95590: LD_INT 3
95592: PPUSH
95593: LD_INT 0
95595: PPUSH
95596: CALL_OW 277
// end ;
95600: PPOPN 2
95602: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95603: LD_EXP 105
95607: PUSH
95608: LD_EXP 133
95612: AND
95613: IFFALSE 95710
95615: GO 95617
95617: DISABLE
95618: LD_INT 0
95620: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95621: LD_ADDR_VAR 0 1
95625: PUSH
95626: LD_INT 22
95628: PUSH
95629: LD_OWVAR 2
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: LD_INT 21
95640: PUSH
95641: LD_INT 1
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: PUSH
95648: LD_INT 3
95650: PUSH
95651: LD_INT 23
95653: PUSH
95654: LD_INT 0
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: EMPTY
95666: LIST
95667: LIST
95668: LIST
95669: PPUSH
95670: CALL_OW 69
95674: ST_TO_ADDR
// if not tmp then
95675: LD_VAR 0 1
95679: NOT
95680: IFFALSE 95684
// exit ;
95682: GO 95710
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95684: LD_VAR 0 1
95688: PUSH
95689: LD_INT 1
95691: PPUSH
95692: LD_VAR 0 1
95696: PPUSH
95697: CALL_OW 12
95701: ARRAY
95702: PPUSH
95703: LD_INT 200
95705: PPUSH
95706: CALL_OW 234
// end ;
95710: PPOPN 1
95712: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95713: LD_EXP 105
95717: PUSH
95718: LD_EXP 134
95722: AND
95723: IFFALSE 95802
95725: GO 95727
95727: DISABLE
95728: LD_INT 0
95730: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95731: LD_ADDR_VAR 0 1
95735: PUSH
95736: LD_INT 22
95738: PUSH
95739: LD_OWVAR 2
95743: PUSH
95744: EMPTY
95745: LIST
95746: LIST
95747: PUSH
95748: LD_INT 21
95750: PUSH
95751: LD_INT 2
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: EMPTY
95759: LIST
95760: LIST
95761: PPUSH
95762: CALL_OW 69
95766: ST_TO_ADDR
// if not tmp then
95767: LD_VAR 0 1
95771: NOT
95772: IFFALSE 95776
// exit ;
95774: GO 95802
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95776: LD_VAR 0 1
95780: PUSH
95781: LD_INT 1
95783: PPUSH
95784: LD_VAR 0 1
95788: PPUSH
95789: CALL_OW 12
95793: ARRAY
95794: PPUSH
95795: LD_INT 60
95797: PPUSH
95798: CALL_OW 234
// end ;
95802: PPOPN 1
95804: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95805: LD_EXP 105
95809: PUSH
95810: LD_EXP 135
95814: AND
95815: IFFALSE 95914
95817: GO 95819
95819: DISABLE
95820: LD_INT 0
95822: PPUSH
95823: PPUSH
// begin enable ;
95824: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95825: LD_ADDR_VAR 0 1
95829: PUSH
95830: LD_INT 22
95832: PUSH
95833: LD_OWVAR 2
95837: PUSH
95838: EMPTY
95839: LIST
95840: LIST
95841: PUSH
95842: LD_INT 61
95844: PUSH
95845: EMPTY
95846: LIST
95847: PUSH
95848: LD_INT 33
95850: PUSH
95851: LD_INT 2
95853: PUSH
95854: EMPTY
95855: LIST
95856: LIST
95857: PUSH
95858: EMPTY
95859: LIST
95860: LIST
95861: LIST
95862: PPUSH
95863: CALL_OW 69
95867: ST_TO_ADDR
// if not tmp then
95868: LD_VAR 0 1
95872: NOT
95873: IFFALSE 95877
// exit ;
95875: GO 95914
// for i in tmp do
95877: LD_ADDR_VAR 0 2
95881: PUSH
95882: LD_VAR 0 1
95886: PUSH
95887: FOR_IN
95888: IFFALSE 95912
// if IsControledBy ( i ) then
95890: LD_VAR 0 2
95894: PPUSH
95895: CALL_OW 312
95899: IFFALSE 95910
// ComUnlink ( i ) ;
95901: LD_VAR 0 2
95905: PPUSH
95906: CALL_OW 136
95910: GO 95887
95912: POP
95913: POP
// end ;
95914: PPOPN 2
95916: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95917: LD_EXP 105
95921: PUSH
95922: LD_EXP 136
95926: AND
95927: IFFALSE 96067
95929: GO 95931
95931: DISABLE
95932: LD_INT 0
95934: PPUSH
95935: PPUSH
// begin ToLua ( displayPowell(); ) ;
95936: LD_STRING displayPowell();
95938: PPUSH
95939: CALL_OW 559
// uc_side := 0 ;
95943: LD_ADDR_OWVAR 20
95947: PUSH
95948: LD_INT 0
95950: ST_TO_ADDR
// uc_nation := 2 ;
95951: LD_ADDR_OWVAR 21
95955: PUSH
95956: LD_INT 2
95958: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95959: LD_ADDR_OWVAR 37
95963: PUSH
95964: LD_INT 14
95966: ST_TO_ADDR
// vc_engine := engine_siberite ;
95967: LD_ADDR_OWVAR 39
95971: PUSH
95972: LD_INT 3
95974: ST_TO_ADDR
// vc_control := control_apeman ;
95975: LD_ADDR_OWVAR 38
95979: PUSH
95980: LD_INT 5
95982: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95983: LD_ADDR_OWVAR 40
95987: PUSH
95988: LD_INT 29
95990: ST_TO_ADDR
// un := CreateVehicle ;
95991: LD_ADDR_VAR 0 2
95995: PUSH
95996: CALL_OW 45
96000: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96001: LD_VAR 0 2
96005: PPUSH
96006: LD_INT 1
96008: PPUSH
96009: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96013: LD_INT 35
96015: PPUSH
96016: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96020: LD_VAR 0 2
96024: PPUSH
96025: LD_INT 22
96027: PUSH
96028: LD_OWVAR 2
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PPUSH
96037: CALL_OW 69
96041: PPUSH
96042: LD_VAR 0 2
96046: PPUSH
96047: CALL_OW 74
96051: PPUSH
96052: CALL_OW 115
// until IsDead ( un ) ;
96056: LD_VAR 0 2
96060: PPUSH
96061: CALL_OW 301
96065: IFFALSE 96013
// end ;
96067: PPOPN 2
96069: END
// every 0 0$1 trigger StreamModeActive and sStu do
96070: LD_EXP 105
96074: PUSH
96075: LD_EXP 144
96079: AND
96080: IFFALSE 96096
96082: GO 96084
96084: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96085: LD_STRING displayStucuk();
96087: PPUSH
96088: CALL_OW 559
// ResetFog ;
96092: CALL_OW 335
// end ;
96096: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96097: LD_EXP 105
96101: PUSH
96102: LD_EXP 137
96106: AND
96107: IFFALSE 96248
96109: GO 96111
96111: DISABLE
96112: LD_INT 0
96114: PPUSH
96115: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96116: LD_ADDR_VAR 0 2
96120: PUSH
96121: LD_INT 22
96123: PUSH
96124: LD_OWVAR 2
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 21
96135: PUSH
96136: LD_INT 1
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: PUSH
96143: EMPTY
96144: LIST
96145: LIST
96146: PPUSH
96147: CALL_OW 69
96151: ST_TO_ADDR
// if not tmp then
96152: LD_VAR 0 2
96156: NOT
96157: IFFALSE 96161
// exit ;
96159: GO 96248
// un := tmp [ rand ( 1 , tmp ) ] ;
96161: LD_ADDR_VAR 0 1
96165: PUSH
96166: LD_VAR 0 2
96170: PUSH
96171: LD_INT 1
96173: PPUSH
96174: LD_VAR 0 2
96178: PPUSH
96179: CALL_OW 12
96183: ARRAY
96184: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96185: LD_VAR 0 1
96189: PPUSH
96190: LD_INT 0
96192: PPUSH
96193: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96197: LD_VAR 0 1
96201: PPUSH
96202: LD_OWVAR 3
96206: PUSH
96207: LD_VAR 0 1
96211: DIFF
96212: PPUSH
96213: LD_VAR 0 1
96217: PPUSH
96218: CALL_OW 74
96222: PPUSH
96223: CALL_OW 115
// wait ( 0 0$20 ) ;
96227: LD_INT 700
96229: PPUSH
96230: CALL_OW 67
// SetSide ( un , your_side ) ;
96234: LD_VAR 0 1
96238: PPUSH
96239: LD_OWVAR 2
96243: PPUSH
96244: CALL_OW 235
// end ;
96248: PPOPN 2
96250: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96251: LD_EXP 105
96255: PUSH
96256: LD_EXP 138
96260: AND
96261: IFFALSE 96367
96263: GO 96265
96265: DISABLE
96266: LD_INT 0
96268: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96269: LD_ADDR_VAR 0 1
96273: PUSH
96274: LD_INT 22
96276: PUSH
96277: LD_OWVAR 2
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: LD_INT 2
96288: PUSH
96289: LD_INT 30
96291: PUSH
96292: LD_INT 0
96294: PUSH
96295: EMPTY
96296: LIST
96297: LIST
96298: PUSH
96299: LD_INT 30
96301: PUSH
96302: LD_INT 1
96304: PUSH
96305: EMPTY
96306: LIST
96307: LIST
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: LIST
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PPUSH
96318: CALL_OW 69
96322: ST_TO_ADDR
// if not depot then
96323: LD_VAR 0 1
96327: NOT
96328: IFFALSE 96332
// exit ;
96330: GO 96367
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96332: LD_VAR 0 1
96336: PUSH
96337: LD_INT 1
96339: ARRAY
96340: PPUSH
96341: CALL_OW 250
96345: PPUSH
96346: LD_VAR 0 1
96350: PUSH
96351: LD_INT 1
96353: ARRAY
96354: PPUSH
96355: CALL_OW 251
96359: PPUSH
96360: LD_INT 70
96362: PPUSH
96363: CALL_OW 495
// end ;
96367: PPOPN 1
96369: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96370: LD_EXP 105
96374: PUSH
96375: LD_EXP 139
96379: AND
96380: IFFALSE 96591
96382: GO 96384
96384: DISABLE
96385: LD_INT 0
96387: PPUSH
96388: PPUSH
96389: PPUSH
96390: PPUSH
96391: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96392: LD_ADDR_VAR 0 5
96396: PUSH
96397: LD_INT 22
96399: PUSH
96400: LD_OWVAR 2
96404: PUSH
96405: EMPTY
96406: LIST
96407: LIST
96408: PUSH
96409: LD_INT 21
96411: PUSH
96412: LD_INT 1
96414: PUSH
96415: EMPTY
96416: LIST
96417: LIST
96418: PUSH
96419: EMPTY
96420: LIST
96421: LIST
96422: PPUSH
96423: CALL_OW 69
96427: ST_TO_ADDR
// if not tmp then
96428: LD_VAR 0 5
96432: NOT
96433: IFFALSE 96437
// exit ;
96435: GO 96591
// for i in tmp do
96437: LD_ADDR_VAR 0 1
96441: PUSH
96442: LD_VAR 0 5
96446: PUSH
96447: FOR_IN
96448: IFFALSE 96589
// begin d := rand ( 0 , 5 ) ;
96450: LD_ADDR_VAR 0 4
96454: PUSH
96455: LD_INT 0
96457: PPUSH
96458: LD_INT 5
96460: PPUSH
96461: CALL_OW 12
96465: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96466: LD_ADDR_VAR 0 2
96470: PUSH
96471: LD_VAR 0 1
96475: PPUSH
96476: CALL_OW 250
96480: PPUSH
96481: LD_VAR 0 4
96485: PPUSH
96486: LD_INT 3
96488: PPUSH
96489: LD_INT 12
96491: PPUSH
96492: CALL_OW 12
96496: PPUSH
96497: CALL_OW 272
96501: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96502: LD_ADDR_VAR 0 3
96506: PUSH
96507: LD_VAR 0 1
96511: PPUSH
96512: CALL_OW 251
96516: PPUSH
96517: LD_VAR 0 4
96521: PPUSH
96522: LD_INT 3
96524: PPUSH
96525: LD_INT 12
96527: PPUSH
96528: CALL_OW 12
96532: PPUSH
96533: CALL_OW 273
96537: ST_TO_ADDR
// if ValidHex ( x , y ) then
96538: LD_VAR 0 2
96542: PPUSH
96543: LD_VAR 0 3
96547: PPUSH
96548: CALL_OW 488
96552: IFFALSE 96587
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96554: LD_VAR 0 1
96558: PPUSH
96559: LD_VAR 0 2
96563: PPUSH
96564: LD_VAR 0 3
96568: PPUSH
96569: LD_INT 3
96571: PPUSH
96572: LD_INT 6
96574: PPUSH
96575: CALL_OW 12
96579: PPUSH
96580: LD_INT 1
96582: PPUSH
96583: CALL_OW 483
// end ;
96587: GO 96447
96589: POP
96590: POP
// end ;
96591: PPOPN 5
96593: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96594: LD_EXP 105
96598: PUSH
96599: LD_EXP 140
96603: AND
96604: IFFALSE 96698
96606: GO 96608
96608: DISABLE
96609: LD_INT 0
96611: PPUSH
96612: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96613: LD_ADDR_VAR 0 2
96617: PUSH
96618: LD_INT 22
96620: PUSH
96621: LD_OWVAR 2
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 32
96632: PUSH
96633: LD_INT 1
96635: PUSH
96636: EMPTY
96637: LIST
96638: LIST
96639: PUSH
96640: LD_INT 21
96642: PUSH
96643: LD_INT 2
96645: PUSH
96646: EMPTY
96647: LIST
96648: LIST
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: LIST
96654: PPUSH
96655: CALL_OW 69
96659: ST_TO_ADDR
// if not tmp then
96660: LD_VAR 0 2
96664: NOT
96665: IFFALSE 96669
// exit ;
96667: GO 96698
// for i in tmp do
96669: LD_ADDR_VAR 0 1
96673: PUSH
96674: LD_VAR 0 2
96678: PUSH
96679: FOR_IN
96680: IFFALSE 96696
// SetFuel ( i , 0 ) ;
96682: LD_VAR 0 1
96686: PPUSH
96687: LD_INT 0
96689: PPUSH
96690: CALL_OW 240
96694: GO 96679
96696: POP
96697: POP
// end ;
96698: PPOPN 2
96700: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96701: LD_EXP 105
96705: PUSH
96706: LD_EXP 141
96710: AND
96711: IFFALSE 96777
96713: GO 96715
96715: DISABLE
96716: LD_INT 0
96718: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96719: LD_ADDR_VAR 0 1
96723: PUSH
96724: LD_INT 22
96726: PUSH
96727: LD_OWVAR 2
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 30
96738: PUSH
96739: LD_INT 29
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PPUSH
96750: CALL_OW 69
96754: ST_TO_ADDR
// if not tmp then
96755: LD_VAR 0 1
96759: NOT
96760: IFFALSE 96764
// exit ;
96762: GO 96777
// DestroyUnit ( tmp [ 1 ] ) ;
96764: LD_VAR 0 1
96768: PUSH
96769: LD_INT 1
96771: ARRAY
96772: PPUSH
96773: CALL_OW 65
// end ;
96777: PPOPN 1
96779: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96780: LD_EXP 105
96784: PUSH
96785: LD_EXP 143
96789: AND
96790: IFFALSE 96919
96792: GO 96794
96794: DISABLE
96795: LD_INT 0
96797: PPUSH
// begin uc_side := 0 ;
96798: LD_ADDR_OWVAR 20
96802: PUSH
96803: LD_INT 0
96805: ST_TO_ADDR
// uc_nation := nation_arabian ;
96806: LD_ADDR_OWVAR 21
96810: PUSH
96811: LD_INT 2
96813: ST_TO_ADDR
// hc_gallery :=  ;
96814: LD_ADDR_OWVAR 33
96818: PUSH
96819: LD_STRING 
96821: ST_TO_ADDR
// hc_name :=  ;
96822: LD_ADDR_OWVAR 26
96826: PUSH
96827: LD_STRING 
96829: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96830: LD_INT 1
96832: PPUSH
96833: LD_INT 11
96835: PPUSH
96836: LD_INT 10
96838: PPUSH
96839: CALL_OW 380
// un := CreateHuman ;
96843: LD_ADDR_VAR 0 1
96847: PUSH
96848: CALL_OW 44
96852: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96853: LD_VAR 0 1
96857: PPUSH
96858: LD_INT 1
96860: PPUSH
96861: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96865: LD_INT 35
96867: PPUSH
96868: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96872: LD_VAR 0 1
96876: PPUSH
96877: LD_INT 22
96879: PUSH
96880: LD_OWVAR 2
96884: PUSH
96885: EMPTY
96886: LIST
96887: LIST
96888: PPUSH
96889: CALL_OW 69
96893: PPUSH
96894: LD_VAR 0 1
96898: PPUSH
96899: CALL_OW 74
96903: PPUSH
96904: CALL_OW 115
// until IsDead ( un ) ;
96908: LD_VAR 0 1
96912: PPUSH
96913: CALL_OW 301
96917: IFFALSE 96865
// end ;
96919: PPOPN 1
96921: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96922: LD_EXP 105
96926: PUSH
96927: LD_EXP 145
96931: AND
96932: IFFALSE 96944
96934: GO 96936
96936: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96937: LD_STRING earthquake(getX(game), 0, 32)
96939: PPUSH
96940: CALL_OW 559
96944: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96945: LD_EXP 105
96949: PUSH
96950: LD_EXP 146
96954: AND
96955: IFFALSE 97046
96957: GO 96959
96959: DISABLE
96960: LD_INT 0
96962: PPUSH
// begin enable ;
96963: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96964: LD_ADDR_VAR 0 1
96968: PUSH
96969: LD_INT 22
96971: PUSH
96972: LD_OWVAR 2
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 21
96983: PUSH
96984: LD_INT 2
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: PUSH
96991: LD_INT 33
96993: PUSH
96994: LD_INT 3
96996: PUSH
96997: EMPTY
96998: LIST
96999: LIST
97000: PUSH
97001: EMPTY
97002: LIST
97003: LIST
97004: LIST
97005: PPUSH
97006: CALL_OW 69
97010: ST_TO_ADDR
// if not tmp then
97011: LD_VAR 0 1
97015: NOT
97016: IFFALSE 97020
// exit ;
97018: GO 97046
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97020: LD_VAR 0 1
97024: PUSH
97025: LD_INT 1
97027: PPUSH
97028: LD_VAR 0 1
97032: PPUSH
97033: CALL_OW 12
97037: ARRAY
97038: PPUSH
97039: LD_INT 1
97041: PPUSH
97042: CALL_OW 234
// end ;
97046: PPOPN 1
97048: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97049: LD_EXP 105
97053: PUSH
97054: LD_EXP 147
97058: AND
97059: IFFALSE 97200
97061: GO 97063
97063: DISABLE
97064: LD_INT 0
97066: PPUSH
97067: PPUSH
97068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97069: LD_ADDR_VAR 0 3
97073: PUSH
97074: LD_INT 22
97076: PUSH
97077: LD_OWVAR 2
97081: PUSH
97082: EMPTY
97083: LIST
97084: LIST
97085: PUSH
97086: LD_INT 25
97088: PUSH
97089: LD_INT 1
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: PUSH
97096: EMPTY
97097: LIST
97098: LIST
97099: PPUSH
97100: CALL_OW 69
97104: ST_TO_ADDR
// if not tmp then
97105: LD_VAR 0 3
97109: NOT
97110: IFFALSE 97114
// exit ;
97112: GO 97200
// un := tmp [ rand ( 1 , tmp ) ] ;
97114: LD_ADDR_VAR 0 2
97118: PUSH
97119: LD_VAR 0 3
97123: PUSH
97124: LD_INT 1
97126: PPUSH
97127: LD_VAR 0 3
97131: PPUSH
97132: CALL_OW 12
97136: ARRAY
97137: ST_TO_ADDR
// if Crawls ( un ) then
97138: LD_VAR 0 2
97142: PPUSH
97143: CALL_OW 318
97147: IFFALSE 97158
// ComWalk ( un ) ;
97149: LD_VAR 0 2
97153: PPUSH
97154: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97158: LD_VAR 0 2
97162: PPUSH
97163: LD_INT 9
97165: PPUSH
97166: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97170: LD_INT 28
97172: PPUSH
97173: LD_OWVAR 2
97177: PPUSH
97178: LD_INT 2
97180: PPUSH
97181: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97185: LD_INT 29
97187: PPUSH
97188: LD_OWVAR 2
97192: PPUSH
97193: LD_INT 2
97195: PPUSH
97196: CALL_OW 322
// end ;
97200: PPOPN 3
97202: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97203: LD_EXP 105
97207: PUSH
97208: LD_EXP 148
97212: AND
97213: IFFALSE 97324
97215: GO 97217
97217: DISABLE
97218: LD_INT 0
97220: PPUSH
97221: PPUSH
97222: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97223: LD_ADDR_VAR 0 3
97227: PUSH
97228: LD_INT 22
97230: PUSH
97231: LD_OWVAR 2
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 25
97242: PUSH
97243: LD_INT 1
97245: PUSH
97246: EMPTY
97247: LIST
97248: LIST
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PPUSH
97254: CALL_OW 69
97258: ST_TO_ADDR
// if not tmp then
97259: LD_VAR 0 3
97263: NOT
97264: IFFALSE 97268
// exit ;
97266: GO 97324
// un := tmp [ rand ( 1 , tmp ) ] ;
97268: LD_ADDR_VAR 0 2
97272: PUSH
97273: LD_VAR 0 3
97277: PUSH
97278: LD_INT 1
97280: PPUSH
97281: LD_VAR 0 3
97285: PPUSH
97286: CALL_OW 12
97290: ARRAY
97291: ST_TO_ADDR
// if Crawls ( un ) then
97292: LD_VAR 0 2
97296: PPUSH
97297: CALL_OW 318
97301: IFFALSE 97312
// ComWalk ( un ) ;
97303: LD_VAR 0 2
97307: PPUSH
97308: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97312: LD_VAR 0 2
97316: PPUSH
97317: LD_INT 8
97319: PPUSH
97320: CALL_OW 336
// end ;
97324: PPOPN 3
97326: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97327: LD_EXP 105
97331: PUSH
97332: LD_EXP 149
97336: AND
97337: IFFALSE 97481
97339: GO 97341
97341: DISABLE
97342: LD_INT 0
97344: PPUSH
97345: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97346: LD_ADDR_VAR 0 2
97350: PUSH
97351: LD_INT 22
97353: PUSH
97354: LD_OWVAR 2
97358: PUSH
97359: EMPTY
97360: LIST
97361: LIST
97362: PUSH
97363: LD_INT 21
97365: PUSH
97366: LD_INT 2
97368: PUSH
97369: EMPTY
97370: LIST
97371: LIST
97372: PUSH
97373: LD_INT 2
97375: PUSH
97376: LD_INT 34
97378: PUSH
97379: LD_INT 12
97381: PUSH
97382: EMPTY
97383: LIST
97384: LIST
97385: PUSH
97386: LD_INT 34
97388: PUSH
97389: LD_INT 51
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 34
97398: PUSH
97399: LD_INT 32
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: LIST
97416: PPUSH
97417: CALL_OW 69
97421: ST_TO_ADDR
// if not tmp then
97422: LD_VAR 0 2
97426: NOT
97427: IFFALSE 97431
// exit ;
97429: GO 97481
// for i in tmp do
97431: LD_ADDR_VAR 0 1
97435: PUSH
97436: LD_VAR 0 2
97440: PUSH
97441: FOR_IN
97442: IFFALSE 97479
// if GetCargo ( i , mat_artifact ) = 0 then
97444: LD_VAR 0 1
97448: PPUSH
97449: LD_INT 4
97451: PPUSH
97452: CALL_OW 289
97456: PUSH
97457: LD_INT 0
97459: EQUAL
97460: IFFALSE 97477
// SetCargo ( i , mat_siberit , 100 ) ;
97462: LD_VAR 0 1
97466: PPUSH
97467: LD_INT 3
97469: PPUSH
97470: LD_INT 100
97472: PPUSH
97473: CALL_OW 290
97477: GO 97441
97479: POP
97480: POP
// end ;
97481: PPOPN 2
97483: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97484: LD_EXP 105
97488: PUSH
97489: LD_EXP 150
97493: AND
97494: IFFALSE 97677
97496: GO 97498
97498: DISABLE
97499: LD_INT 0
97501: PPUSH
97502: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97503: LD_ADDR_VAR 0 2
97507: PUSH
97508: LD_INT 22
97510: PUSH
97511: LD_OWVAR 2
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PPUSH
97520: CALL_OW 69
97524: ST_TO_ADDR
// if not tmp then
97525: LD_VAR 0 2
97529: NOT
97530: IFFALSE 97534
// exit ;
97532: GO 97677
// for i := 1 to 2 do
97534: LD_ADDR_VAR 0 1
97538: PUSH
97539: DOUBLE
97540: LD_INT 1
97542: DEC
97543: ST_TO_ADDR
97544: LD_INT 2
97546: PUSH
97547: FOR_TO
97548: IFFALSE 97675
// begin uc_side := your_side ;
97550: LD_ADDR_OWVAR 20
97554: PUSH
97555: LD_OWVAR 2
97559: ST_TO_ADDR
// uc_nation := nation_american ;
97560: LD_ADDR_OWVAR 21
97564: PUSH
97565: LD_INT 1
97567: ST_TO_ADDR
// vc_chassis := us_morphling ;
97568: LD_ADDR_OWVAR 37
97572: PUSH
97573: LD_INT 5
97575: ST_TO_ADDR
// vc_engine := engine_siberite ;
97576: LD_ADDR_OWVAR 39
97580: PUSH
97581: LD_INT 3
97583: ST_TO_ADDR
// vc_control := control_computer ;
97584: LD_ADDR_OWVAR 38
97588: PUSH
97589: LD_INT 3
97591: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97592: LD_ADDR_OWVAR 40
97596: PUSH
97597: LD_INT 10
97599: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97600: LD_VAR 0 2
97604: PUSH
97605: LD_INT 1
97607: ARRAY
97608: PPUSH
97609: CALL_OW 310
97613: NOT
97614: IFFALSE 97661
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97616: CALL_OW 45
97620: PPUSH
97621: LD_VAR 0 2
97625: PUSH
97626: LD_INT 1
97628: ARRAY
97629: PPUSH
97630: CALL_OW 250
97634: PPUSH
97635: LD_VAR 0 2
97639: PUSH
97640: LD_INT 1
97642: ARRAY
97643: PPUSH
97644: CALL_OW 251
97648: PPUSH
97649: LD_INT 12
97651: PPUSH
97652: LD_INT 1
97654: PPUSH
97655: CALL_OW 50
97659: GO 97673
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97661: CALL_OW 45
97665: PPUSH
97666: LD_INT 1
97668: PPUSH
97669: CALL_OW 51
// end ;
97673: GO 97547
97675: POP
97676: POP
// end ;
97677: PPOPN 2
97679: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97680: LD_EXP 105
97684: PUSH
97685: LD_EXP 151
97689: AND
97690: IFFALSE 97912
97692: GO 97694
97694: DISABLE
97695: LD_INT 0
97697: PPUSH
97698: PPUSH
97699: PPUSH
97700: PPUSH
97701: PPUSH
97702: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97703: LD_ADDR_VAR 0 6
97707: PUSH
97708: LD_INT 22
97710: PUSH
97711: LD_OWVAR 2
97715: PUSH
97716: EMPTY
97717: LIST
97718: LIST
97719: PUSH
97720: LD_INT 21
97722: PUSH
97723: LD_INT 1
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: LD_INT 3
97732: PUSH
97733: LD_INT 23
97735: PUSH
97736: LD_INT 0
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: EMPTY
97744: LIST
97745: LIST
97746: PUSH
97747: EMPTY
97748: LIST
97749: LIST
97750: LIST
97751: PPUSH
97752: CALL_OW 69
97756: ST_TO_ADDR
// if not tmp then
97757: LD_VAR 0 6
97761: NOT
97762: IFFALSE 97766
// exit ;
97764: GO 97912
// s1 := rand ( 1 , 4 ) ;
97766: LD_ADDR_VAR 0 2
97770: PUSH
97771: LD_INT 1
97773: PPUSH
97774: LD_INT 4
97776: PPUSH
97777: CALL_OW 12
97781: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97782: LD_ADDR_VAR 0 4
97786: PUSH
97787: LD_VAR 0 6
97791: PUSH
97792: LD_INT 1
97794: ARRAY
97795: PPUSH
97796: LD_VAR 0 2
97800: PPUSH
97801: CALL_OW 259
97805: ST_TO_ADDR
// if s1 = 1 then
97806: LD_VAR 0 2
97810: PUSH
97811: LD_INT 1
97813: EQUAL
97814: IFFALSE 97834
// s2 := rand ( 2 , 4 ) else
97816: LD_ADDR_VAR 0 3
97820: PUSH
97821: LD_INT 2
97823: PPUSH
97824: LD_INT 4
97826: PPUSH
97827: CALL_OW 12
97831: ST_TO_ADDR
97832: GO 97842
// s2 := 1 ;
97834: LD_ADDR_VAR 0 3
97838: PUSH
97839: LD_INT 1
97841: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97842: LD_ADDR_VAR 0 5
97846: PUSH
97847: LD_VAR 0 6
97851: PUSH
97852: LD_INT 1
97854: ARRAY
97855: PPUSH
97856: LD_VAR 0 3
97860: PPUSH
97861: CALL_OW 259
97865: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97866: LD_VAR 0 6
97870: PUSH
97871: LD_INT 1
97873: ARRAY
97874: PPUSH
97875: LD_VAR 0 2
97879: PPUSH
97880: LD_VAR 0 5
97884: PPUSH
97885: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97889: LD_VAR 0 6
97893: PUSH
97894: LD_INT 1
97896: ARRAY
97897: PPUSH
97898: LD_VAR 0 3
97902: PPUSH
97903: LD_VAR 0 4
97907: PPUSH
97908: CALL_OW 237
// end ;
97912: PPOPN 6
97914: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97915: LD_EXP 105
97919: PUSH
97920: LD_EXP 152
97924: AND
97925: IFFALSE 98004
97927: GO 97929
97929: DISABLE
97930: LD_INT 0
97932: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97933: LD_ADDR_VAR 0 1
97937: PUSH
97938: LD_INT 22
97940: PUSH
97941: LD_OWVAR 2
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 30
97952: PUSH
97953: LD_INT 3
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: PUSH
97960: EMPTY
97961: LIST
97962: LIST
97963: PPUSH
97964: CALL_OW 69
97968: ST_TO_ADDR
// if not tmp then
97969: LD_VAR 0 1
97973: NOT
97974: IFFALSE 97978
// exit ;
97976: GO 98004
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97978: LD_VAR 0 1
97982: PUSH
97983: LD_INT 1
97985: PPUSH
97986: LD_VAR 0 1
97990: PPUSH
97991: CALL_OW 12
97995: ARRAY
97996: PPUSH
97997: LD_INT 1
97999: PPUSH
98000: CALL_OW 234
// end ;
98004: PPOPN 1
98006: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98007: LD_EXP 105
98011: PUSH
98012: LD_EXP 153
98016: AND
98017: IFFALSE 98129
98019: GO 98021
98021: DISABLE
98022: LD_INT 0
98024: PPUSH
98025: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98026: LD_ADDR_VAR 0 2
98030: PUSH
98031: LD_INT 22
98033: PUSH
98034: LD_OWVAR 2
98038: PUSH
98039: EMPTY
98040: LIST
98041: LIST
98042: PUSH
98043: LD_INT 2
98045: PUSH
98046: LD_INT 30
98048: PUSH
98049: LD_INT 27
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 30
98058: PUSH
98059: LD_INT 26
98061: PUSH
98062: EMPTY
98063: LIST
98064: LIST
98065: PUSH
98066: LD_INT 30
98068: PUSH
98069: LD_INT 28
98071: PUSH
98072: EMPTY
98073: LIST
98074: LIST
98075: PUSH
98076: EMPTY
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PPUSH
98086: CALL_OW 69
98090: ST_TO_ADDR
// if not tmp then
98091: LD_VAR 0 2
98095: NOT
98096: IFFALSE 98100
// exit ;
98098: GO 98129
// for i in tmp do
98100: LD_ADDR_VAR 0 1
98104: PUSH
98105: LD_VAR 0 2
98109: PUSH
98110: FOR_IN
98111: IFFALSE 98127
// SetLives ( i , 1 ) ;
98113: LD_VAR 0 1
98117: PPUSH
98118: LD_INT 1
98120: PPUSH
98121: CALL_OW 234
98125: GO 98110
98127: POP
98128: POP
// end ;
98129: PPOPN 2
98131: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
98132: LD_EXP 105
98136: PUSH
98137: LD_EXP 154
98141: AND
98142: IFFALSE 98429
98144: GO 98146
98146: DISABLE
98147: LD_INT 0
98149: PPUSH
98150: PPUSH
98151: PPUSH
// begin i := rand ( 1 , 7 ) ;
98152: LD_ADDR_VAR 0 1
98156: PUSH
98157: LD_INT 1
98159: PPUSH
98160: LD_INT 7
98162: PPUSH
98163: CALL_OW 12
98167: ST_TO_ADDR
// case i of 1 :
98168: LD_VAR 0 1
98172: PUSH
98173: LD_INT 1
98175: DOUBLE
98176: EQUAL
98177: IFTRUE 98181
98179: GO 98191
98181: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98182: LD_STRING earthquake(getX(game), 0, 32)
98184: PPUSH
98185: CALL_OW 559
98189: GO 98429
98191: LD_INT 2
98193: DOUBLE
98194: EQUAL
98195: IFTRUE 98199
98197: GO 98213
98199: POP
// begin ToLua ( displayStucuk(); ) ;
98200: LD_STRING displayStucuk();
98202: PPUSH
98203: CALL_OW 559
// ResetFog ;
98207: CALL_OW 335
// end ; 3 :
98211: GO 98429
98213: LD_INT 3
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98221
98219: GO 98325
98221: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98222: LD_ADDR_VAR 0 2
98226: PUSH
98227: LD_INT 22
98229: PUSH
98230: LD_OWVAR 2
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PUSH
98239: LD_INT 25
98241: PUSH
98242: LD_INT 1
98244: PUSH
98245: EMPTY
98246: LIST
98247: LIST
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: PPUSH
98253: CALL_OW 69
98257: ST_TO_ADDR
// if not tmp then
98258: LD_VAR 0 2
98262: NOT
98263: IFFALSE 98267
// exit ;
98265: GO 98429
// un := tmp [ rand ( 1 , tmp ) ] ;
98267: LD_ADDR_VAR 0 3
98271: PUSH
98272: LD_VAR 0 2
98276: PUSH
98277: LD_INT 1
98279: PPUSH
98280: LD_VAR 0 2
98284: PPUSH
98285: CALL_OW 12
98289: ARRAY
98290: ST_TO_ADDR
// if Crawls ( un ) then
98291: LD_VAR 0 3
98295: PPUSH
98296: CALL_OW 318
98300: IFFALSE 98311
// ComWalk ( un ) ;
98302: LD_VAR 0 3
98306: PPUSH
98307: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98311: LD_VAR 0 3
98315: PPUSH
98316: LD_INT 8
98318: PPUSH
98319: CALL_OW 336
// end ; 4 :
98323: GO 98429
98325: LD_INT 4
98327: DOUBLE
98328: EQUAL
98329: IFTRUE 98333
98331: GO 98407
98333: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98334: LD_ADDR_VAR 0 2
98338: PUSH
98339: LD_INT 22
98341: PUSH
98342: LD_OWVAR 2
98346: PUSH
98347: EMPTY
98348: LIST
98349: LIST
98350: PUSH
98351: LD_INT 30
98353: PUSH
98354: LD_INT 29
98356: PUSH
98357: EMPTY
98358: LIST
98359: LIST
98360: PUSH
98361: EMPTY
98362: LIST
98363: LIST
98364: PPUSH
98365: CALL_OW 69
98369: ST_TO_ADDR
// if not tmp then
98370: LD_VAR 0 2
98374: NOT
98375: IFFALSE 98379
// exit ;
98377: GO 98429
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98379: LD_VAR 0 2
98383: PUSH
98384: LD_INT 1
98386: ARRAY
98387: PPUSH
98388: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98392: LD_VAR 0 2
98396: PUSH
98397: LD_INT 1
98399: ARRAY
98400: PPUSH
98401: CALL_OW 65
// end ; 5 .. 7 :
98405: GO 98429
98407: LD_INT 5
98409: DOUBLE
98410: GREATEREQUAL
98411: IFFALSE 98419
98413: LD_INT 7
98415: DOUBLE
98416: LESSEQUAL
98417: IFTRUE 98421
98419: GO 98428
98421: POP
// StreamSibBomb ; end ;
98422: CALL 94666 0 0
98426: GO 98429
98428: POP
// end ;
98429: PPOPN 3
98431: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98432: LD_EXP 105
98436: PUSH
98437: LD_EXP 155
98441: AND
98442: IFFALSE 98598
98444: GO 98446
98446: DISABLE
98447: LD_INT 0
98449: PPUSH
98450: PPUSH
98451: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98452: LD_ADDR_VAR 0 2
98456: PUSH
98457: LD_INT 81
98459: PUSH
98460: LD_OWVAR 2
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 2
98471: PUSH
98472: LD_INT 21
98474: PUSH
98475: LD_INT 1
98477: PUSH
98478: EMPTY
98479: LIST
98480: LIST
98481: PUSH
98482: LD_INT 21
98484: PUSH
98485: LD_INT 2
98487: PUSH
98488: EMPTY
98489: LIST
98490: LIST
98491: PUSH
98492: EMPTY
98493: LIST
98494: LIST
98495: LIST
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PPUSH
98501: CALL_OW 69
98505: ST_TO_ADDR
// if not tmp then
98506: LD_VAR 0 2
98510: NOT
98511: IFFALSE 98515
// exit ;
98513: GO 98598
// p := 0 ;
98515: LD_ADDR_VAR 0 3
98519: PUSH
98520: LD_INT 0
98522: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98523: LD_INT 35
98525: PPUSH
98526: CALL_OW 67
// p := p + 1 ;
98530: LD_ADDR_VAR 0 3
98534: PUSH
98535: LD_VAR 0 3
98539: PUSH
98540: LD_INT 1
98542: PLUS
98543: ST_TO_ADDR
// for i in tmp do
98544: LD_ADDR_VAR 0 1
98548: PUSH
98549: LD_VAR 0 2
98553: PUSH
98554: FOR_IN
98555: IFFALSE 98586
// if GetLives ( i ) < 1000 then
98557: LD_VAR 0 1
98561: PPUSH
98562: CALL_OW 256
98566: PUSH
98567: LD_INT 1000
98569: LESS
98570: IFFALSE 98584
// SetLives ( i , 1000 ) ;
98572: LD_VAR 0 1
98576: PPUSH
98577: LD_INT 1000
98579: PPUSH
98580: CALL_OW 234
98584: GO 98554
98586: POP
98587: POP
// until p > 20 ;
98588: LD_VAR 0 3
98592: PUSH
98593: LD_INT 20
98595: GREATER
98596: IFFALSE 98523
// end ;
98598: PPOPN 3
98600: END
// every 0 0$1 trigger StreamModeActive and sTime do
98601: LD_EXP 105
98605: PUSH
98606: LD_EXP 156
98610: AND
98611: IFFALSE 98646
98613: GO 98615
98615: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98616: LD_INT 28
98618: PPUSH
98619: LD_OWVAR 2
98623: PPUSH
98624: LD_INT 2
98626: PPUSH
98627: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98631: LD_INT 30
98633: PPUSH
98634: LD_OWVAR 2
98638: PPUSH
98639: LD_INT 2
98641: PPUSH
98642: CALL_OW 322
// end ;
98646: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98647: LD_EXP 105
98651: PUSH
98652: LD_EXP 157
98656: AND
98657: IFFALSE 98778
98659: GO 98661
98661: DISABLE
98662: LD_INT 0
98664: PPUSH
98665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98666: LD_ADDR_VAR 0 2
98670: PUSH
98671: LD_INT 22
98673: PUSH
98674: LD_OWVAR 2
98678: PUSH
98679: EMPTY
98680: LIST
98681: LIST
98682: PUSH
98683: LD_INT 21
98685: PUSH
98686: LD_INT 1
98688: PUSH
98689: EMPTY
98690: LIST
98691: LIST
98692: PUSH
98693: LD_INT 3
98695: PUSH
98696: LD_INT 23
98698: PUSH
98699: LD_INT 0
98701: PUSH
98702: EMPTY
98703: LIST
98704: LIST
98705: PUSH
98706: EMPTY
98707: LIST
98708: LIST
98709: PUSH
98710: EMPTY
98711: LIST
98712: LIST
98713: LIST
98714: PPUSH
98715: CALL_OW 69
98719: ST_TO_ADDR
// if not tmp then
98720: LD_VAR 0 2
98724: NOT
98725: IFFALSE 98729
// exit ;
98727: GO 98778
// for i in tmp do
98729: LD_ADDR_VAR 0 1
98733: PUSH
98734: LD_VAR 0 2
98738: PUSH
98739: FOR_IN
98740: IFFALSE 98776
// begin if Crawls ( i ) then
98742: LD_VAR 0 1
98746: PPUSH
98747: CALL_OW 318
98751: IFFALSE 98762
// ComWalk ( i ) ;
98753: LD_VAR 0 1
98757: PPUSH
98758: CALL_OW 138
// SetClass ( i , 2 ) ;
98762: LD_VAR 0 1
98766: PPUSH
98767: LD_INT 2
98769: PPUSH
98770: CALL_OW 336
// end ;
98774: GO 98739
98776: POP
98777: POP
// end ;
98778: PPOPN 2
98780: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98781: LD_EXP 105
98785: PUSH
98786: LD_EXP 158
98790: AND
98791: IFFALSE 99079
98793: GO 98795
98795: DISABLE
98796: LD_INT 0
98798: PPUSH
98799: PPUSH
98800: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98801: LD_OWVAR 2
98805: PPUSH
98806: LD_INT 9
98808: PPUSH
98809: LD_INT 1
98811: PPUSH
98812: LD_INT 1
98814: PPUSH
98815: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98819: LD_INT 9
98821: PPUSH
98822: LD_OWVAR 2
98826: PPUSH
98827: CALL_OW 343
// uc_side := 9 ;
98831: LD_ADDR_OWVAR 20
98835: PUSH
98836: LD_INT 9
98838: ST_TO_ADDR
// uc_nation := 2 ;
98839: LD_ADDR_OWVAR 21
98843: PUSH
98844: LD_INT 2
98846: ST_TO_ADDR
// hc_name := Dark Warrior ;
98847: LD_ADDR_OWVAR 26
98851: PUSH
98852: LD_STRING Dark Warrior
98854: ST_TO_ADDR
// hc_gallery :=  ;
98855: LD_ADDR_OWVAR 33
98859: PUSH
98860: LD_STRING 
98862: ST_TO_ADDR
// hc_noskilllimit := true ;
98863: LD_ADDR_OWVAR 76
98867: PUSH
98868: LD_INT 1
98870: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98871: LD_ADDR_OWVAR 31
98875: PUSH
98876: LD_INT 30
98878: PUSH
98879: LD_INT 30
98881: PUSH
98882: LD_INT 30
98884: PUSH
98885: LD_INT 30
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: LIST
98892: LIST
98893: ST_TO_ADDR
// un := CreateHuman ;
98894: LD_ADDR_VAR 0 3
98898: PUSH
98899: CALL_OW 44
98903: ST_TO_ADDR
// hc_noskilllimit := false ;
98904: LD_ADDR_OWVAR 76
98908: PUSH
98909: LD_INT 0
98911: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98912: LD_VAR 0 3
98916: PPUSH
98917: LD_INT 1
98919: PPUSH
98920: CALL_OW 51
// ToLua ( playRanger() ) ;
98924: LD_STRING playRanger()
98926: PPUSH
98927: CALL_OW 559
// p := 0 ;
98931: LD_ADDR_VAR 0 2
98935: PUSH
98936: LD_INT 0
98938: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98939: LD_INT 35
98941: PPUSH
98942: CALL_OW 67
// p := p + 1 ;
98946: LD_ADDR_VAR 0 2
98950: PUSH
98951: LD_VAR 0 2
98955: PUSH
98956: LD_INT 1
98958: PLUS
98959: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98960: LD_VAR 0 3
98964: PPUSH
98965: CALL_OW 256
98969: PUSH
98970: LD_INT 1000
98972: LESS
98973: IFFALSE 98987
// SetLives ( un , 1000 ) ;
98975: LD_VAR 0 3
98979: PPUSH
98980: LD_INT 1000
98982: PPUSH
98983: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98987: LD_VAR 0 3
98991: PPUSH
98992: LD_INT 81
98994: PUSH
98995: LD_OWVAR 2
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: PUSH
99004: LD_INT 91
99006: PUSH
99007: LD_VAR 0 3
99011: PUSH
99012: LD_INT 30
99014: PUSH
99015: EMPTY
99016: LIST
99017: LIST
99018: LIST
99019: PUSH
99020: EMPTY
99021: LIST
99022: LIST
99023: PPUSH
99024: CALL_OW 69
99028: PPUSH
99029: LD_VAR 0 3
99033: PPUSH
99034: CALL_OW 74
99038: PPUSH
99039: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99043: LD_VAR 0 2
99047: PUSH
99048: LD_INT 80
99050: GREATER
99051: PUSH
99052: LD_VAR 0 3
99056: PPUSH
99057: CALL_OW 301
99061: OR
99062: IFFALSE 98939
// if un then
99064: LD_VAR 0 3
99068: IFFALSE 99079
// RemoveUnit ( un ) ;
99070: LD_VAR 0 3
99074: PPUSH
99075: CALL_OW 64
// end ;
99079: PPOPN 3
99081: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99082: LD_EXP 159
99086: IFFALSE 99202
99088: GO 99090
99090: DISABLE
99091: LD_INT 0
99093: PPUSH
99094: PPUSH
99095: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99096: LD_ADDR_VAR 0 2
99100: PUSH
99101: LD_INT 81
99103: PUSH
99104: LD_OWVAR 2
99108: PUSH
99109: EMPTY
99110: LIST
99111: LIST
99112: PUSH
99113: LD_INT 21
99115: PUSH
99116: LD_INT 1
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PPUSH
99127: CALL_OW 69
99131: ST_TO_ADDR
// ToLua ( playComputer() ) ;
99132: LD_STRING playComputer()
99134: PPUSH
99135: CALL_OW 559
// if not tmp then
99139: LD_VAR 0 2
99143: NOT
99144: IFFALSE 99148
// exit ;
99146: GO 99202
// for i in tmp do
99148: LD_ADDR_VAR 0 1
99152: PUSH
99153: LD_VAR 0 2
99157: PUSH
99158: FOR_IN
99159: IFFALSE 99200
// for j := 1 to 4 do
99161: LD_ADDR_VAR 0 3
99165: PUSH
99166: DOUBLE
99167: LD_INT 1
99169: DEC
99170: ST_TO_ADDR
99171: LD_INT 4
99173: PUSH
99174: FOR_TO
99175: IFFALSE 99196
// SetSkill ( i , j , 10 ) ;
99177: LD_VAR 0 1
99181: PPUSH
99182: LD_VAR 0 3
99186: PPUSH
99187: LD_INT 10
99189: PPUSH
99190: CALL_OW 237
99194: GO 99174
99196: POP
99197: POP
99198: GO 99158
99200: POP
99201: POP
// end ;
99202: PPOPN 3
99204: END
// every 0 0$1 trigger s30 do var i , tmp ;
99205: LD_EXP 160
99209: IFFALSE 99278
99211: GO 99213
99213: DISABLE
99214: LD_INT 0
99216: PPUSH
99217: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99218: LD_ADDR_VAR 0 2
99222: PUSH
99223: LD_INT 22
99225: PUSH
99226: LD_OWVAR 2
99230: PUSH
99231: EMPTY
99232: LIST
99233: LIST
99234: PPUSH
99235: CALL_OW 69
99239: ST_TO_ADDR
// if not tmp then
99240: LD_VAR 0 2
99244: NOT
99245: IFFALSE 99249
// exit ;
99247: GO 99278
// for i in tmp do
99249: LD_ADDR_VAR 0 1
99253: PUSH
99254: LD_VAR 0 2
99258: PUSH
99259: FOR_IN
99260: IFFALSE 99276
// SetLives ( i , 300 ) ;
99262: LD_VAR 0 1
99266: PPUSH
99267: LD_INT 300
99269: PPUSH
99270: CALL_OW 234
99274: GO 99259
99276: POP
99277: POP
// end ;
99278: PPOPN 2
99280: END
// every 0 0$1 trigger s60 do var i , tmp ;
99281: LD_EXP 161
99285: IFFALSE 99354
99287: GO 99289
99289: DISABLE
99290: LD_INT 0
99292: PPUSH
99293: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99294: LD_ADDR_VAR 0 2
99298: PUSH
99299: LD_INT 22
99301: PUSH
99302: LD_OWVAR 2
99306: PUSH
99307: EMPTY
99308: LIST
99309: LIST
99310: PPUSH
99311: CALL_OW 69
99315: ST_TO_ADDR
// if not tmp then
99316: LD_VAR 0 2
99320: NOT
99321: IFFALSE 99325
// exit ;
99323: GO 99354
// for i in tmp do
99325: LD_ADDR_VAR 0 1
99329: PUSH
99330: LD_VAR 0 2
99334: PUSH
99335: FOR_IN
99336: IFFALSE 99352
// SetLives ( i , 600 ) ;
99338: LD_VAR 0 1
99342: PPUSH
99343: LD_INT 600
99345: PPUSH
99346: CALL_OW 234
99350: GO 99335
99352: POP
99353: POP
// end ;
99354: PPOPN 2
99356: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99357: LD_INT 0
99359: PPUSH
// case cmd of 301 :
99360: LD_VAR 0 1
99364: PUSH
99365: LD_INT 301
99367: DOUBLE
99368: EQUAL
99369: IFTRUE 99373
99371: GO 99405
99373: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99374: LD_VAR 0 6
99378: PPUSH
99379: LD_VAR 0 7
99383: PPUSH
99384: LD_VAR 0 8
99388: PPUSH
99389: LD_VAR 0 4
99393: PPUSH
99394: LD_VAR 0 5
99398: PPUSH
99399: CALL 100606 0 5
99403: GO 99526
99405: LD_INT 302
99407: DOUBLE
99408: EQUAL
99409: IFTRUE 99413
99411: GO 99450
99413: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99414: LD_VAR 0 6
99418: PPUSH
99419: LD_VAR 0 7
99423: PPUSH
99424: LD_VAR 0 8
99428: PPUSH
99429: LD_VAR 0 9
99433: PPUSH
99434: LD_VAR 0 4
99438: PPUSH
99439: LD_VAR 0 5
99443: PPUSH
99444: CALL 100697 0 6
99448: GO 99526
99450: LD_INT 303
99452: DOUBLE
99453: EQUAL
99454: IFTRUE 99458
99456: GO 99495
99458: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99459: LD_VAR 0 6
99463: PPUSH
99464: LD_VAR 0 7
99468: PPUSH
99469: LD_VAR 0 8
99473: PPUSH
99474: LD_VAR 0 9
99478: PPUSH
99479: LD_VAR 0 4
99483: PPUSH
99484: LD_VAR 0 5
99488: PPUSH
99489: CALL 99531 0 6
99493: GO 99526
99495: LD_INT 304
99497: DOUBLE
99498: EQUAL
99499: IFTRUE 99503
99501: GO 99525
99503: POP
// hHackTeleport ( unit , x , y ) ; end ;
99504: LD_VAR 0 2
99508: PPUSH
99509: LD_VAR 0 4
99513: PPUSH
99514: LD_VAR 0 5
99518: PPUSH
99519: CALL 101290 0 3
99523: GO 99526
99525: POP
// end ;
99526: LD_VAR 0 12
99530: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99531: LD_INT 0
99533: PPUSH
99534: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99535: LD_VAR 0 1
99539: PUSH
99540: LD_INT 1
99542: LESS
99543: PUSH
99544: LD_VAR 0 1
99548: PUSH
99549: LD_INT 3
99551: GREATER
99552: OR
99553: PUSH
99554: LD_VAR 0 5
99558: PPUSH
99559: LD_VAR 0 6
99563: PPUSH
99564: CALL_OW 428
99568: OR
99569: IFFALSE 99573
// exit ;
99571: GO 100293
// uc_side := your_side ;
99573: LD_ADDR_OWVAR 20
99577: PUSH
99578: LD_OWVAR 2
99582: ST_TO_ADDR
// uc_nation := nation ;
99583: LD_ADDR_OWVAR 21
99587: PUSH
99588: LD_VAR 0 1
99592: ST_TO_ADDR
// bc_level = 1 ;
99593: LD_ADDR_OWVAR 43
99597: PUSH
99598: LD_INT 1
99600: ST_TO_ADDR
// case btype of 1 :
99601: LD_VAR 0 2
99605: PUSH
99606: LD_INT 1
99608: DOUBLE
99609: EQUAL
99610: IFTRUE 99614
99612: GO 99625
99614: POP
// bc_type := b_depot ; 2 :
99615: LD_ADDR_OWVAR 42
99619: PUSH
99620: LD_INT 0
99622: ST_TO_ADDR
99623: GO 100237
99625: LD_INT 2
99627: DOUBLE
99628: EQUAL
99629: IFTRUE 99633
99631: GO 99644
99633: POP
// bc_type := b_warehouse ; 3 :
99634: LD_ADDR_OWVAR 42
99638: PUSH
99639: LD_INT 1
99641: ST_TO_ADDR
99642: GO 100237
99644: LD_INT 3
99646: DOUBLE
99647: EQUAL
99648: IFTRUE 99652
99650: GO 99663
99652: POP
// bc_type := b_lab ; 4 .. 9 :
99653: LD_ADDR_OWVAR 42
99657: PUSH
99658: LD_INT 6
99660: ST_TO_ADDR
99661: GO 100237
99663: LD_INT 4
99665: DOUBLE
99666: GREATEREQUAL
99667: IFFALSE 99675
99669: LD_INT 9
99671: DOUBLE
99672: LESSEQUAL
99673: IFTRUE 99677
99675: GO 99729
99677: POP
// begin bc_type := b_lab_half ;
99678: LD_ADDR_OWVAR 42
99682: PUSH
99683: LD_INT 7
99685: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99686: LD_ADDR_OWVAR 44
99690: PUSH
99691: LD_INT 10
99693: PUSH
99694: LD_INT 11
99696: PUSH
99697: LD_INT 12
99699: PUSH
99700: LD_INT 15
99702: PUSH
99703: LD_INT 14
99705: PUSH
99706: LD_INT 13
99708: PUSH
99709: EMPTY
99710: LIST
99711: LIST
99712: LIST
99713: LIST
99714: LIST
99715: LIST
99716: PUSH
99717: LD_VAR 0 2
99721: PUSH
99722: LD_INT 3
99724: MINUS
99725: ARRAY
99726: ST_TO_ADDR
// end ; 10 .. 13 :
99727: GO 100237
99729: LD_INT 10
99731: DOUBLE
99732: GREATEREQUAL
99733: IFFALSE 99741
99735: LD_INT 13
99737: DOUBLE
99738: LESSEQUAL
99739: IFTRUE 99743
99741: GO 99820
99743: POP
// begin bc_type := b_lab_full ;
99744: LD_ADDR_OWVAR 42
99748: PUSH
99749: LD_INT 8
99751: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99752: LD_ADDR_OWVAR 44
99756: PUSH
99757: LD_INT 10
99759: PUSH
99760: LD_INT 12
99762: PUSH
99763: LD_INT 14
99765: PUSH
99766: LD_INT 13
99768: PUSH
99769: EMPTY
99770: LIST
99771: LIST
99772: LIST
99773: LIST
99774: PUSH
99775: LD_VAR 0 2
99779: PUSH
99780: LD_INT 9
99782: MINUS
99783: ARRAY
99784: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99785: LD_ADDR_OWVAR 45
99789: PUSH
99790: LD_INT 11
99792: PUSH
99793: LD_INT 15
99795: PUSH
99796: LD_INT 12
99798: PUSH
99799: LD_INT 15
99801: PUSH
99802: EMPTY
99803: LIST
99804: LIST
99805: LIST
99806: LIST
99807: PUSH
99808: LD_VAR 0 2
99812: PUSH
99813: LD_INT 9
99815: MINUS
99816: ARRAY
99817: ST_TO_ADDR
// end ; 14 :
99818: GO 100237
99820: LD_INT 14
99822: DOUBLE
99823: EQUAL
99824: IFTRUE 99828
99826: GO 99839
99828: POP
// bc_type := b_workshop ; 15 :
99829: LD_ADDR_OWVAR 42
99833: PUSH
99834: LD_INT 2
99836: ST_TO_ADDR
99837: GO 100237
99839: LD_INT 15
99841: DOUBLE
99842: EQUAL
99843: IFTRUE 99847
99845: GO 99858
99847: POP
// bc_type := b_factory ; 16 :
99848: LD_ADDR_OWVAR 42
99852: PUSH
99853: LD_INT 3
99855: ST_TO_ADDR
99856: GO 100237
99858: LD_INT 16
99860: DOUBLE
99861: EQUAL
99862: IFTRUE 99866
99864: GO 99877
99866: POP
// bc_type := b_ext_gun ; 17 :
99867: LD_ADDR_OWVAR 42
99871: PUSH
99872: LD_INT 17
99874: ST_TO_ADDR
99875: GO 100237
99877: LD_INT 17
99879: DOUBLE
99880: EQUAL
99881: IFTRUE 99885
99883: GO 99913
99885: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99886: LD_ADDR_OWVAR 42
99890: PUSH
99891: LD_INT 19
99893: PUSH
99894: LD_INT 23
99896: PUSH
99897: LD_INT 19
99899: PUSH
99900: EMPTY
99901: LIST
99902: LIST
99903: LIST
99904: PUSH
99905: LD_VAR 0 1
99909: ARRAY
99910: ST_TO_ADDR
99911: GO 100237
99913: LD_INT 18
99915: DOUBLE
99916: EQUAL
99917: IFTRUE 99921
99919: GO 99932
99921: POP
// bc_type := b_ext_radar ; 19 :
99922: LD_ADDR_OWVAR 42
99926: PUSH
99927: LD_INT 20
99929: ST_TO_ADDR
99930: GO 100237
99932: LD_INT 19
99934: DOUBLE
99935: EQUAL
99936: IFTRUE 99940
99938: GO 99951
99940: POP
// bc_type := b_ext_radio ; 20 :
99941: LD_ADDR_OWVAR 42
99945: PUSH
99946: LD_INT 22
99948: ST_TO_ADDR
99949: GO 100237
99951: LD_INT 20
99953: DOUBLE
99954: EQUAL
99955: IFTRUE 99959
99957: GO 99970
99959: POP
// bc_type := b_ext_siberium ; 21 :
99960: LD_ADDR_OWVAR 42
99964: PUSH
99965: LD_INT 21
99967: ST_TO_ADDR
99968: GO 100237
99970: LD_INT 21
99972: DOUBLE
99973: EQUAL
99974: IFTRUE 99978
99976: GO 99989
99978: POP
// bc_type := b_ext_computer ; 22 :
99979: LD_ADDR_OWVAR 42
99983: PUSH
99984: LD_INT 24
99986: ST_TO_ADDR
99987: GO 100237
99989: LD_INT 22
99991: DOUBLE
99992: EQUAL
99993: IFTRUE 99997
99995: GO 100008
99997: POP
// bc_type := b_ext_track ; 23 :
99998: LD_ADDR_OWVAR 42
100002: PUSH
100003: LD_INT 16
100005: ST_TO_ADDR
100006: GO 100237
100008: LD_INT 23
100010: DOUBLE
100011: EQUAL
100012: IFTRUE 100016
100014: GO 100027
100016: POP
// bc_type := b_ext_laser ; 24 :
100017: LD_ADDR_OWVAR 42
100021: PUSH
100022: LD_INT 25
100024: ST_TO_ADDR
100025: GO 100237
100027: LD_INT 24
100029: DOUBLE
100030: EQUAL
100031: IFTRUE 100035
100033: GO 100046
100035: POP
// bc_type := b_control_tower ; 25 :
100036: LD_ADDR_OWVAR 42
100040: PUSH
100041: LD_INT 36
100043: ST_TO_ADDR
100044: GO 100237
100046: LD_INT 25
100048: DOUBLE
100049: EQUAL
100050: IFTRUE 100054
100052: GO 100065
100054: POP
// bc_type := b_breastwork ; 26 :
100055: LD_ADDR_OWVAR 42
100059: PUSH
100060: LD_INT 31
100062: ST_TO_ADDR
100063: GO 100237
100065: LD_INT 26
100067: DOUBLE
100068: EQUAL
100069: IFTRUE 100073
100071: GO 100084
100073: POP
// bc_type := b_bunker ; 27 :
100074: LD_ADDR_OWVAR 42
100078: PUSH
100079: LD_INT 32
100081: ST_TO_ADDR
100082: GO 100237
100084: LD_INT 27
100086: DOUBLE
100087: EQUAL
100088: IFTRUE 100092
100090: GO 100103
100092: POP
// bc_type := b_turret ; 28 :
100093: LD_ADDR_OWVAR 42
100097: PUSH
100098: LD_INT 33
100100: ST_TO_ADDR
100101: GO 100237
100103: LD_INT 28
100105: DOUBLE
100106: EQUAL
100107: IFTRUE 100111
100109: GO 100122
100111: POP
// bc_type := b_armoury ; 29 :
100112: LD_ADDR_OWVAR 42
100116: PUSH
100117: LD_INT 4
100119: ST_TO_ADDR
100120: GO 100237
100122: LD_INT 29
100124: DOUBLE
100125: EQUAL
100126: IFTRUE 100130
100128: GO 100141
100130: POP
// bc_type := b_barracks ; 30 :
100131: LD_ADDR_OWVAR 42
100135: PUSH
100136: LD_INT 5
100138: ST_TO_ADDR
100139: GO 100237
100141: LD_INT 30
100143: DOUBLE
100144: EQUAL
100145: IFTRUE 100149
100147: GO 100160
100149: POP
// bc_type := b_solar_power ; 31 :
100150: LD_ADDR_OWVAR 42
100154: PUSH
100155: LD_INT 27
100157: ST_TO_ADDR
100158: GO 100237
100160: LD_INT 31
100162: DOUBLE
100163: EQUAL
100164: IFTRUE 100168
100166: GO 100179
100168: POP
// bc_type := b_oil_power ; 32 :
100169: LD_ADDR_OWVAR 42
100173: PUSH
100174: LD_INT 26
100176: ST_TO_ADDR
100177: GO 100237
100179: LD_INT 32
100181: DOUBLE
100182: EQUAL
100183: IFTRUE 100187
100185: GO 100198
100187: POP
// bc_type := b_siberite_power ; 33 :
100188: LD_ADDR_OWVAR 42
100192: PUSH
100193: LD_INT 28
100195: ST_TO_ADDR
100196: GO 100237
100198: LD_INT 33
100200: DOUBLE
100201: EQUAL
100202: IFTRUE 100206
100204: GO 100217
100206: POP
// bc_type := b_oil_mine ; 34 :
100207: LD_ADDR_OWVAR 42
100211: PUSH
100212: LD_INT 29
100214: ST_TO_ADDR
100215: GO 100237
100217: LD_INT 34
100219: DOUBLE
100220: EQUAL
100221: IFTRUE 100225
100223: GO 100236
100225: POP
// bc_type := b_siberite_mine ; end ;
100226: LD_ADDR_OWVAR 42
100230: PUSH
100231: LD_INT 30
100233: ST_TO_ADDR
100234: GO 100237
100236: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100237: LD_ADDR_VAR 0 8
100241: PUSH
100242: LD_VAR 0 5
100246: PPUSH
100247: LD_VAR 0 6
100251: PPUSH
100252: LD_VAR 0 3
100256: PPUSH
100257: CALL_OW 47
100261: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100262: LD_OWVAR 42
100266: PUSH
100267: LD_INT 32
100269: PUSH
100270: LD_INT 33
100272: PUSH
100273: EMPTY
100274: LIST
100275: LIST
100276: IN
100277: IFFALSE 100293
// PlaceWeaponTurret ( b , weapon ) ;
100279: LD_VAR 0 8
100283: PPUSH
100284: LD_VAR 0 4
100288: PPUSH
100289: CALL_OW 431
// end ;
100293: LD_VAR 0 7
100297: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100298: LD_INT 0
100300: PPUSH
100301: PPUSH
100302: PPUSH
100303: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100304: LD_ADDR_VAR 0 4
100308: PUSH
100309: LD_INT 22
100311: PUSH
100312: LD_OWVAR 2
100316: PUSH
100317: EMPTY
100318: LIST
100319: LIST
100320: PUSH
100321: LD_INT 2
100323: PUSH
100324: LD_INT 30
100326: PUSH
100327: LD_INT 0
100329: PUSH
100330: EMPTY
100331: LIST
100332: LIST
100333: PUSH
100334: LD_INT 30
100336: PUSH
100337: LD_INT 1
100339: PUSH
100340: EMPTY
100341: LIST
100342: LIST
100343: PUSH
100344: EMPTY
100345: LIST
100346: LIST
100347: LIST
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PPUSH
100353: CALL_OW 69
100357: ST_TO_ADDR
// if not tmp then
100358: LD_VAR 0 4
100362: NOT
100363: IFFALSE 100367
// exit ;
100365: GO 100426
// for i in tmp do
100367: LD_ADDR_VAR 0 2
100371: PUSH
100372: LD_VAR 0 4
100376: PUSH
100377: FOR_IN
100378: IFFALSE 100424
// for j = 1 to 3 do
100380: LD_ADDR_VAR 0 3
100384: PUSH
100385: DOUBLE
100386: LD_INT 1
100388: DEC
100389: ST_TO_ADDR
100390: LD_INT 3
100392: PUSH
100393: FOR_TO
100394: IFFALSE 100420
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100396: LD_VAR 0 2
100400: PPUSH
100401: CALL_OW 274
100405: PPUSH
100406: LD_VAR 0 3
100410: PPUSH
100411: LD_INT 99999
100413: PPUSH
100414: CALL_OW 277
100418: GO 100393
100420: POP
100421: POP
100422: GO 100377
100424: POP
100425: POP
// end ;
100426: LD_VAR 0 1
100430: RET
// export function hHackSetLevel10 ; var i , j ; begin
100431: LD_INT 0
100433: PPUSH
100434: PPUSH
100435: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100436: LD_ADDR_VAR 0 2
100440: PUSH
100441: LD_INT 21
100443: PUSH
100444: LD_INT 1
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PPUSH
100451: CALL_OW 69
100455: PUSH
100456: FOR_IN
100457: IFFALSE 100509
// if IsSelected ( i ) then
100459: LD_VAR 0 2
100463: PPUSH
100464: CALL_OW 306
100468: IFFALSE 100507
// begin for j := 1 to 4 do
100470: LD_ADDR_VAR 0 3
100474: PUSH
100475: DOUBLE
100476: LD_INT 1
100478: DEC
100479: ST_TO_ADDR
100480: LD_INT 4
100482: PUSH
100483: FOR_TO
100484: IFFALSE 100505
// SetSkill ( i , j , 10 ) ;
100486: LD_VAR 0 2
100490: PPUSH
100491: LD_VAR 0 3
100495: PPUSH
100496: LD_INT 10
100498: PPUSH
100499: CALL_OW 237
100503: GO 100483
100505: POP
100506: POP
// end ;
100507: GO 100456
100509: POP
100510: POP
// end ;
100511: LD_VAR 0 1
100515: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100516: LD_INT 0
100518: PPUSH
100519: PPUSH
100520: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100521: LD_ADDR_VAR 0 2
100525: PUSH
100526: LD_INT 22
100528: PUSH
100529: LD_OWVAR 2
100533: PUSH
100534: EMPTY
100535: LIST
100536: LIST
100537: PUSH
100538: LD_INT 21
100540: PUSH
100541: LD_INT 1
100543: PUSH
100544: EMPTY
100545: LIST
100546: LIST
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PPUSH
100552: CALL_OW 69
100556: PUSH
100557: FOR_IN
100558: IFFALSE 100599
// begin for j := 1 to 4 do
100560: LD_ADDR_VAR 0 3
100564: PUSH
100565: DOUBLE
100566: LD_INT 1
100568: DEC
100569: ST_TO_ADDR
100570: LD_INT 4
100572: PUSH
100573: FOR_TO
100574: IFFALSE 100595
// SetSkill ( i , j , 10 ) ;
100576: LD_VAR 0 2
100580: PPUSH
100581: LD_VAR 0 3
100585: PPUSH
100586: LD_INT 10
100588: PPUSH
100589: CALL_OW 237
100593: GO 100573
100595: POP
100596: POP
// end ;
100597: GO 100557
100599: POP
100600: POP
// end ;
100601: LD_VAR 0 1
100605: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100606: LD_INT 0
100608: PPUSH
// uc_side := your_side ;
100609: LD_ADDR_OWVAR 20
100613: PUSH
100614: LD_OWVAR 2
100618: ST_TO_ADDR
// uc_nation := nation ;
100619: LD_ADDR_OWVAR 21
100623: PUSH
100624: LD_VAR 0 1
100628: ST_TO_ADDR
// InitHc ;
100629: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100633: LD_INT 0
100635: PPUSH
100636: LD_VAR 0 2
100640: PPUSH
100641: LD_VAR 0 3
100645: PPUSH
100646: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100650: LD_VAR 0 4
100654: PPUSH
100655: LD_VAR 0 5
100659: PPUSH
100660: CALL_OW 428
100664: PUSH
100665: LD_INT 0
100667: EQUAL
100668: IFFALSE 100692
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100670: CALL_OW 44
100674: PPUSH
100675: LD_VAR 0 4
100679: PPUSH
100680: LD_VAR 0 5
100684: PPUSH
100685: LD_INT 1
100687: PPUSH
100688: CALL_OW 48
// end ;
100692: LD_VAR 0 6
100696: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100697: LD_INT 0
100699: PPUSH
100700: PPUSH
// uc_side := your_side ;
100701: LD_ADDR_OWVAR 20
100705: PUSH
100706: LD_OWVAR 2
100710: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100711: LD_VAR 0 1
100715: PUSH
100716: LD_INT 1
100718: PUSH
100719: LD_INT 2
100721: PUSH
100722: LD_INT 3
100724: PUSH
100725: LD_INT 4
100727: PUSH
100728: LD_INT 5
100730: PUSH
100731: EMPTY
100732: LIST
100733: LIST
100734: LIST
100735: LIST
100736: LIST
100737: IN
100738: IFFALSE 100750
// uc_nation := nation_american else
100740: LD_ADDR_OWVAR 21
100744: PUSH
100745: LD_INT 1
100747: ST_TO_ADDR
100748: GO 100793
// if chassis in [ 11 , 12 , 13 , 14 ] then
100750: LD_VAR 0 1
100754: PUSH
100755: LD_INT 11
100757: PUSH
100758: LD_INT 12
100760: PUSH
100761: LD_INT 13
100763: PUSH
100764: LD_INT 14
100766: PUSH
100767: EMPTY
100768: LIST
100769: LIST
100770: LIST
100771: LIST
100772: IN
100773: IFFALSE 100785
// uc_nation := nation_arabian else
100775: LD_ADDR_OWVAR 21
100779: PUSH
100780: LD_INT 2
100782: ST_TO_ADDR
100783: GO 100793
// uc_nation := nation_russian ;
100785: LD_ADDR_OWVAR 21
100789: PUSH
100790: LD_INT 3
100792: ST_TO_ADDR
// vc_chassis := chassis ;
100793: LD_ADDR_OWVAR 37
100797: PUSH
100798: LD_VAR 0 1
100802: ST_TO_ADDR
// vc_engine := engine ;
100803: LD_ADDR_OWVAR 39
100807: PUSH
100808: LD_VAR 0 2
100812: ST_TO_ADDR
// vc_control := control ;
100813: LD_ADDR_OWVAR 38
100817: PUSH
100818: LD_VAR 0 3
100822: ST_TO_ADDR
// vc_weapon := weapon ;
100823: LD_ADDR_OWVAR 40
100827: PUSH
100828: LD_VAR 0 4
100832: ST_TO_ADDR
// un := CreateVehicle ;
100833: LD_ADDR_VAR 0 8
100837: PUSH
100838: CALL_OW 45
100842: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100843: LD_VAR 0 8
100847: PPUSH
100848: LD_INT 0
100850: PPUSH
100851: LD_INT 5
100853: PPUSH
100854: CALL_OW 12
100858: PPUSH
100859: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100863: LD_VAR 0 8
100867: PPUSH
100868: LD_VAR 0 5
100872: PPUSH
100873: LD_VAR 0 6
100877: PPUSH
100878: LD_INT 1
100880: PPUSH
100881: CALL_OW 48
// end ;
100885: LD_VAR 0 7
100889: RET
// export hInvincible ; every 1 do
100890: GO 100892
100892: DISABLE
// hInvincible := [ ] ;
100893: LD_ADDR_EXP 162
100897: PUSH
100898: EMPTY
100899: ST_TO_ADDR
100900: END
// every 10 do var i ;
100901: GO 100903
100903: DISABLE
100904: LD_INT 0
100906: PPUSH
// begin enable ;
100907: ENABLE
// if not hInvincible then
100908: LD_EXP 162
100912: NOT
100913: IFFALSE 100917
// exit ;
100915: GO 100961
// for i in hInvincible do
100917: LD_ADDR_VAR 0 1
100921: PUSH
100922: LD_EXP 162
100926: PUSH
100927: FOR_IN
100928: IFFALSE 100959
// if GetLives ( i ) < 1000 then
100930: LD_VAR 0 1
100934: PPUSH
100935: CALL_OW 256
100939: PUSH
100940: LD_INT 1000
100942: LESS
100943: IFFALSE 100957
// SetLives ( i , 1000 ) ;
100945: LD_VAR 0 1
100949: PPUSH
100950: LD_INT 1000
100952: PPUSH
100953: CALL_OW 234
100957: GO 100927
100959: POP
100960: POP
// end ;
100961: PPOPN 1
100963: END
// export function hHackInvincible ; var i ; begin
100964: LD_INT 0
100966: PPUSH
100967: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100968: LD_ADDR_VAR 0 2
100972: PUSH
100973: LD_INT 2
100975: PUSH
100976: LD_INT 21
100978: PUSH
100979: LD_INT 1
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PUSH
100986: LD_INT 21
100988: PUSH
100989: LD_INT 2
100991: PUSH
100992: EMPTY
100993: LIST
100994: LIST
100995: PUSH
100996: EMPTY
100997: LIST
100998: LIST
100999: LIST
101000: PPUSH
101001: CALL_OW 69
101005: PUSH
101006: FOR_IN
101007: IFFALSE 101068
// if IsSelected ( i ) then
101009: LD_VAR 0 2
101013: PPUSH
101014: CALL_OW 306
101018: IFFALSE 101066
// begin if i in hInvincible then
101020: LD_VAR 0 2
101024: PUSH
101025: LD_EXP 162
101029: IN
101030: IFFALSE 101050
// hInvincible := hInvincible diff i else
101032: LD_ADDR_EXP 162
101036: PUSH
101037: LD_EXP 162
101041: PUSH
101042: LD_VAR 0 2
101046: DIFF
101047: ST_TO_ADDR
101048: GO 101066
// hInvincible := hInvincible union i ;
101050: LD_ADDR_EXP 162
101054: PUSH
101055: LD_EXP 162
101059: PUSH
101060: LD_VAR 0 2
101064: UNION
101065: ST_TO_ADDR
// end ;
101066: GO 101006
101068: POP
101069: POP
// end ;
101070: LD_VAR 0 1
101074: RET
// export function hHackInvisible ; var i , j ; begin
101075: LD_INT 0
101077: PPUSH
101078: PPUSH
101079: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101080: LD_ADDR_VAR 0 2
101084: PUSH
101085: LD_INT 21
101087: PUSH
101088: LD_INT 1
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PPUSH
101095: CALL_OW 69
101099: PUSH
101100: FOR_IN
101101: IFFALSE 101125
// if IsSelected ( i ) then
101103: LD_VAR 0 2
101107: PPUSH
101108: CALL_OW 306
101112: IFFALSE 101123
// ComForceInvisible ( i ) ;
101114: LD_VAR 0 2
101118: PPUSH
101119: CALL_OW 496
101123: GO 101100
101125: POP
101126: POP
// end ;
101127: LD_VAR 0 1
101131: RET
// export function hHackChangeYourSide ; begin
101132: LD_INT 0
101134: PPUSH
// if your_side = 8 then
101135: LD_OWVAR 2
101139: PUSH
101140: LD_INT 8
101142: EQUAL
101143: IFFALSE 101155
// your_side := 0 else
101145: LD_ADDR_OWVAR 2
101149: PUSH
101150: LD_INT 0
101152: ST_TO_ADDR
101153: GO 101169
// your_side := your_side + 1 ;
101155: LD_ADDR_OWVAR 2
101159: PUSH
101160: LD_OWVAR 2
101164: PUSH
101165: LD_INT 1
101167: PLUS
101168: ST_TO_ADDR
// end ;
101169: LD_VAR 0 1
101173: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101174: LD_INT 0
101176: PPUSH
101177: PPUSH
101178: PPUSH
// for i in all_units do
101179: LD_ADDR_VAR 0 2
101183: PUSH
101184: LD_OWVAR 3
101188: PUSH
101189: FOR_IN
101190: IFFALSE 101268
// if IsSelected ( i ) then
101192: LD_VAR 0 2
101196: PPUSH
101197: CALL_OW 306
101201: IFFALSE 101266
// begin j := GetSide ( i ) ;
101203: LD_ADDR_VAR 0 3
101207: PUSH
101208: LD_VAR 0 2
101212: PPUSH
101213: CALL_OW 255
101217: ST_TO_ADDR
// if j = 8 then
101218: LD_VAR 0 3
101222: PUSH
101223: LD_INT 8
101225: EQUAL
101226: IFFALSE 101238
// j := 0 else
101228: LD_ADDR_VAR 0 3
101232: PUSH
101233: LD_INT 0
101235: ST_TO_ADDR
101236: GO 101252
// j := j + 1 ;
101238: LD_ADDR_VAR 0 3
101242: PUSH
101243: LD_VAR 0 3
101247: PUSH
101248: LD_INT 1
101250: PLUS
101251: ST_TO_ADDR
// SetSide ( i , j ) ;
101252: LD_VAR 0 2
101256: PPUSH
101257: LD_VAR 0 3
101261: PPUSH
101262: CALL_OW 235
// end ;
101266: GO 101189
101268: POP
101269: POP
// end ;
101270: LD_VAR 0 1
101274: RET
// export function hHackFog ; begin
101275: LD_INT 0
101277: PPUSH
// FogOff ( true ) ;
101278: LD_INT 1
101280: PPUSH
101281: CALL_OW 344
// end ;
101285: LD_VAR 0 1
101289: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101290: LD_INT 0
101292: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101293: LD_VAR 0 1
101297: PPUSH
101298: LD_VAR 0 2
101302: PPUSH
101303: LD_VAR 0 3
101307: PPUSH
101308: LD_INT 1
101310: PPUSH
101311: LD_INT 1
101313: PPUSH
101314: CALL_OW 483
// CenterOnXY ( x , y ) ;
101318: LD_VAR 0 2
101322: PPUSH
101323: LD_VAR 0 3
101327: PPUSH
101328: CALL_OW 84
// end ;
101332: LD_VAR 0 4
101336: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101337: LD_INT 0
101339: PPUSH
101340: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101341: LD_VAR 0 1
101345: NOT
101346: PUSH
101347: LD_VAR 0 2
101351: PPUSH
101352: LD_VAR 0 3
101356: PPUSH
101357: CALL_OW 488
101361: NOT
101362: OR
101363: PUSH
101364: LD_VAR 0 1
101368: PPUSH
101369: CALL_OW 266
101373: PUSH
101374: LD_INT 3
101376: NONEQUAL
101377: PUSH
101378: LD_VAR 0 1
101382: PPUSH
101383: CALL_OW 247
101387: PUSH
101388: LD_INT 1
101390: EQUAL
101391: NOT
101392: AND
101393: OR
101394: IFFALSE 101398
// exit ;
101396: GO 101547
// if GetType ( factory ) = unit_human then
101398: LD_VAR 0 1
101402: PPUSH
101403: CALL_OW 247
101407: PUSH
101408: LD_INT 1
101410: EQUAL
101411: IFFALSE 101428
// factory := IsInUnit ( factory ) ;
101413: LD_ADDR_VAR 0 1
101417: PUSH
101418: LD_VAR 0 1
101422: PPUSH
101423: CALL_OW 310
101427: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101428: LD_VAR 0 1
101432: PPUSH
101433: CALL_OW 266
101437: PUSH
101438: LD_INT 3
101440: NONEQUAL
101441: IFFALSE 101445
// exit ;
101443: GO 101547
// if HexInfo ( x , y ) = factory then
101445: LD_VAR 0 2
101449: PPUSH
101450: LD_VAR 0 3
101454: PPUSH
101455: CALL_OW 428
101459: PUSH
101460: LD_VAR 0 1
101464: EQUAL
101465: IFFALSE 101492
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101467: LD_ADDR_EXP 163
101471: PUSH
101472: LD_EXP 163
101476: PPUSH
101477: LD_VAR 0 1
101481: PPUSH
101482: LD_INT 0
101484: PPUSH
101485: CALL_OW 1
101489: ST_TO_ADDR
101490: GO 101543
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101492: LD_ADDR_EXP 163
101496: PUSH
101497: LD_EXP 163
101501: PPUSH
101502: LD_VAR 0 1
101506: PPUSH
101507: LD_VAR 0 1
101511: PPUSH
101512: CALL_OW 255
101516: PUSH
101517: LD_VAR 0 1
101521: PUSH
101522: LD_VAR 0 2
101526: PUSH
101527: LD_VAR 0 3
101531: PUSH
101532: EMPTY
101533: LIST
101534: LIST
101535: LIST
101536: LIST
101537: PPUSH
101538: CALL_OW 1
101542: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101543: CALL 101552 0 0
// end ;
101547: LD_VAR 0 4
101551: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101552: LD_INT 0
101554: PPUSH
101555: PPUSH
101556: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101557: LD_STRING resetFactoryWaypoint();
101559: PPUSH
101560: CALL_OW 559
// if factoryWaypoints then
101564: LD_EXP 163
101568: IFFALSE 101694
// begin list := PrepareArray ( factoryWaypoints ) ;
101570: LD_ADDR_VAR 0 3
101574: PUSH
101575: LD_EXP 163
101579: PPUSH
101580: CALL 56140 0 1
101584: ST_TO_ADDR
// for i := 1 to list do
101585: LD_ADDR_VAR 0 2
101589: PUSH
101590: DOUBLE
101591: LD_INT 1
101593: DEC
101594: ST_TO_ADDR
101595: LD_VAR 0 3
101599: PUSH
101600: FOR_TO
101601: IFFALSE 101692
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101603: LD_STRING setFactoryWaypointXY(
101605: PUSH
101606: LD_VAR 0 3
101610: PUSH
101611: LD_VAR 0 2
101615: ARRAY
101616: PUSH
101617: LD_INT 1
101619: ARRAY
101620: STR
101621: PUSH
101622: LD_STRING ,
101624: STR
101625: PUSH
101626: LD_VAR 0 3
101630: PUSH
101631: LD_VAR 0 2
101635: ARRAY
101636: PUSH
101637: LD_INT 2
101639: ARRAY
101640: STR
101641: PUSH
101642: LD_STRING ,
101644: STR
101645: PUSH
101646: LD_VAR 0 3
101650: PUSH
101651: LD_VAR 0 2
101655: ARRAY
101656: PUSH
101657: LD_INT 3
101659: ARRAY
101660: STR
101661: PUSH
101662: LD_STRING ,
101664: STR
101665: PUSH
101666: LD_VAR 0 3
101670: PUSH
101671: LD_VAR 0 2
101675: ARRAY
101676: PUSH
101677: LD_INT 4
101679: ARRAY
101680: STR
101681: PUSH
101682: LD_STRING )
101684: STR
101685: PPUSH
101686: CALL_OW 559
101690: GO 101600
101692: POP
101693: POP
// end ; end ;
101694: LD_VAR 0 1
101698: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101699: LD_INT 0
101701: PPUSH
// if HexInfo ( x , y ) = warehouse then
101702: LD_VAR 0 2
101706: PPUSH
101707: LD_VAR 0 3
101711: PPUSH
101712: CALL_OW 428
101716: PUSH
101717: LD_VAR 0 1
101721: EQUAL
101722: IFFALSE 101749
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101724: LD_ADDR_EXP 164
101728: PUSH
101729: LD_EXP 164
101733: PPUSH
101734: LD_VAR 0 1
101738: PPUSH
101739: LD_INT 0
101741: PPUSH
101742: CALL_OW 1
101746: ST_TO_ADDR
101747: GO 101800
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101749: LD_ADDR_EXP 164
101753: PUSH
101754: LD_EXP 164
101758: PPUSH
101759: LD_VAR 0 1
101763: PPUSH
101764: LD_VAR 0 1
101768: PPUSH
101769: CALL_OW 255
101773: PUSH
101774: LD_VAR 0 1
101778: PUSH
101779: LD_VAR 0 2
101783: PUSH
101784: LD_VAR 0 3
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: LIST
101793: LIST
101794: PPUSH
101795: CALL_OW 1
101799: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
101800: CALL 101809 0 0
// end ;
101804: LD_VAR 0 4
101808: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
101809: LD_INT 0
101811: PPUSH
101812: PPUSH
101813: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
101814: LD_STRING resetWarehouseGatheringPoints();
101816: PPUSH
101817: CALL_OW 559
// if warehouseGatheringPoints then
101821: LD_EXP 164
101825: IFFALSE 101951
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
101827: LD_ADDR_VAR 0 3
101831: PUSH
101832: LD_EXP 164
101836: PPUSH
101837: CALL 56140 0 1
101841: ST_TO_ADDR
// for i := 1 to list do
101842: LD_ADDR_VAR 0 2
101846: PUSH
101847: DOUBLE
101848: LD_INT 1
101850: DEC
101851: ST_TO_ADDR
101852: LD_VAR 0 3
101856: PUSH
101857: FOR_TO
101858: IFFALSE 101949
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101860: LD_STRING setWarehouseGatheringPointXY(
101862: PUSH
101863: LD_VAR 0 3
101867: PUSH
101868: LD_VAR 0 2
101872: ARRAY
101873: PUSH
101874: LD_INT 1
101876: ARRAY
101877: STR
101878: PUSH
101879: LD_STRING ,
101881: STR
101882: PUSH
101883: LD_VAR 0 3
101887: PUSH
101888: LD_VAR 0 2
101892: ARRAY
101893: PUSH
101894: LD_INT 2
101896: ARRAY
101897: STR
101898: PUSH
101899: LD_STRING ,
101901: STR
101902: PUSH
101903: LD_VAR 0 3
101907: PUSH
101908: LD_VAR 0 2
101912: ARRAY
101913: PUSH
101914: LD_INT 3
101916: ARRAY
101917: STR
101918: PUSH
101919: LD_STRING ,
101921: STR
101922: PUSH
101923: LD_VAR 0 3
101927: PUSH
101928: LD_VAR 0 2
101932: ARRAY
101933: PUSH
101934: LD_INT 4
101936: ARRAY
101937: STR
101938: PUSH
101939: LD_STRING )
101941: STR
101942: PPUSH
101943: CALL_OW 559
101947: GO 101857
101949: POP
101950: POP
// end ; end ;
101951: LD_VAR 0 1
101955: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
101956: LD_EXP 164
101960: IFFALSE 102645
101962: GO 101964
101964: DISABLE
101965: LD_INT 0
101967: PPUSH
101968: PPUSH
101969: PPUSH
101970: PPUSH
101971: PPUSH
101972: PPUSH
101973: PPUSH
101974: PPUSH
101975: PPUSH
// begin enable ;
101976: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
101977: LD_ADDR_VAR 0 3
101981: PUSH
101982: LD_EXP 164
101986: PPUSH
101987: CALL 56140 0 1
101991: ST_TO_ADDR
// if not list then
101992: LD_VAR 0 3
101996: NOT
101997: IFFALSE 102001
// exit ;
101999: GO 102645
// for i := 1 to list do
102001: LD_ADDR_VAR 0 1
102005: PUSH
102006: DOUBLE
102007: LD_INT 1
102009: DEC
102010: ST_TO_ADDR
102011: LD_VAR 0 3
102015: PUSH
102016: FOR_TO
102017: IFFALSE 102643
// begin depot := list [ i ] [ 2 ] ;
102019: LD_ADDR_VAR 0 8
102023: PUSH
102024: LD_VAR 0 3
102028: PUSH
102029: LD_VAR 0 1
102033: ARRAY
102034: PUSH
102035: LD_INT 2
102037: ARRAY
102038: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102039: LD_ADDR_VAR 0 5
102043: PUSH
102044: LD_VAR 0 3
102048: PUSH
102049: LD_VAR 0 1
102053: ARRAY
102054: PUSH
102055: LD_INT 1
102057: ARRAY
102058: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102059: LD_VAR 0 8
102063: PPUSH
102064: CALL_OW 301
102068: PUSH
102069: LD_VAR 0 5
102073: PUSH
102074: LD_VAR 0 8
102078: PPUSH
102079: CALL_OW 255
102083: NONEQUAL
102084: OR
102085: IFFALSE 102114
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102087: LD_ADDR_EXP 164
102091: PUSH
102092: LD_EXP 164
102096: PPUSH
102097: LD_VAR 0 8
102101: PPUSH
102102: LD_INT 0
102104: PPUSH
102105: CALL_OW 1
102109: ST_TO_ADDR
// exit ;
102110: POP
102111: POP
102112: GO 102645
// end ; x := list [ i ] [ 3 ] ;
102114: LD_ADDR_VAR 0 6
102118: PUSH
102119: LD_VAR 0 3
102123: PUSH
102124: LD_VAR 0 1
102128: ARRAY
102129: PUSH
102130: LD_INT 3
102132: ARRAY
102133: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102134: LD_ADDR_VAR 0 7
102138: PUSH
102139: LD_VAR 0 3
102143: PUSH
102144: LD_VAR 0 1
102148: ARRAY
102149: PUSH
102150: LD_INT 4
102152: ARRAY
102153: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102154: LD_ADDR_VAR 0 9
102158: PUSH
102159: LD_VAR 0 6
102163: PPUSH
102164: LD_VAR 0 7
102168: PPUSH
102169: LD_INT 16
102171: PPUSH
102172: CALL 54728 0 3
102176: ST_TO_ADDR
// if not cratesNearbyPoint then
102177: LD_VAR 0 9
102181: NOT
102182: IFFALSE 102188
// exit ;
102184: POP
102185: POP
102186: GO 102645
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102188: LD_ADDR_VAR 0 4
102192: PUSH
102193: LD_INT 22
102195: PUSH
102196: LD_VAR 0 5
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: PUSH
102205: LD_INT 3
102207: PUSH
102208: LD_INT 60
102210: PUSH
102211: EMPTY
102212: LIST
102213: PUSH
102214: EMPTY
102215: LIST
102216: LIST
102217: PUSH
102218: LD_INT 91
102220: PUSH
102221: LD_VAR 0 8
102225: PUSH
102226: LD_INT 6
102228: PUSH
102229: EMPTY
102230: LIST
102231: LIST
102232: LIST
102233: PUSH
102234: LD_INT 2
102236: PUSH
102237: LD_INT 25
102239: PUSH
102240: LD_INT 2
102242: PUSH
102243: EMPTY
102244: LIST
102245: LIST
102246: PUSH
102247: LD_INT 25
102249: PUSH
102250: LD_INT 16
102252: PUSH
102253: EMPTY
102254: LIST
102255: LIST
102256: PUSH
102257: EMPTY
102258: LIST
102259: LIST
102260: LIST
102261: PUSH
102262: EMPTY
102263: LIST
102264: LIST
102265: LIST
102266: LIST
102267: PPUSH
102268: CALL_OW 69
102272: PUSH
102273: LD_VAR 0 8
102277: PPUSH
102278: CALL_OW 313
102282: PPUSH
102283: LD_INT 3
102285: PUSH
102286: LD_INT 60
102288: PUSH
102289: EMPTY
102290: LIST
102291: PUSH
102292: EMPTY
102293: LIST
102294: LIST
102295: PUSH
102296: LD_INT 2
102298: PUSH
102299: LD_INT 25
102301: PUSH
102302: LD_INT 2
102304: PUSH
102305: EMPTY
102306: LIST
102307: LIST
102308: PUSH
102309: LD_INT 25
102311: PUSH
102312: LD_INT 16
102314: PUSH
102315: EMPTY
102316: LIST
102317: LIST
102318: PUSH
102319: EMPTY
102320: LIST
102321: LIST
102322: LIST
102323: PUSH
102324: EMPTY
102325: LIST
102326: LIST
102327: PPUSH
102328: CALL_OW 72
102332: UNION
102333: ST_TO_ADDR
// if tmp then
102334: LD_VAR 0 4
102338: IFFALSE 102418
// begin tmp := ShrinkArray ( tmp , 3 ) ;
102340: LD_ADDR_VAR 0 4
102344: PUSH
102345: LD_VAR 0 4
102349: PPUSH
102350: LD_INT 3
102352: PPUSH
102353: CALL 52697 0 2
102357: ST_TO_ADDR
// for j in tmp do
102358: LD_ADDR_VAR 0 2
102362: PUSH
102363: LD_VAR 0 4
102367: PUSH
102368: FOR_IN
102369: IFFALSE 102412
// begin if IsInUnit ( j ) then
102371: LD_VAR 0 2
102375: PPUSH
102376: CALL_OW 310
102380: IFFALSE 102391
// ComExit ( j ) ;
102382: LD_VAR 0 2
102386: PPUSH
102387: CALL 52780 0 1
// AddComCollect ( j , x , y ) ;
102391: LD_VAR 0 2
102395: PPUSH
102396: LD_VAR 0 6
102400: PPUSH
102401: LD_VAR 0 7
102405: PPUSH
102406: CALL_OW 177
// end ;
102410: GO 102368
102412: POP
102413: POP
// exit ;
102414: POP
102415: POP
102416: GO 102645
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102418: LD_ADDR_VAR 0 4
102422: PUSH
102423: LD_INT 22
102425: PUSH
102426: LD_VAR 0 5
102430: PUSH
102431: EMPTY
102432: LIST
102433: LIST
102434: PUSH
102435: LD_INT 91
102437: PUSH
102438: LD_VAR 0 8
102442: PUSH
102443: LD_INT 8
102445: PUSH
102446: EMPTY
102447: LIST
102448: LIST
102449: LIST
102450: PUSH
102451: LD_INT 2
102453: PUSH
102454: LD_INT 34
102456: PUSH
102457: LD_INT 12
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: PUSH
102464: LD_INT 34
102466: PUSH
102467: LD_INT 51
102469: PUSH
102470: EMPTY
102471: LIST
102472: LIST
102473: PUSH
102474: LD_INT 34
102476: PUSH
102477: LD_INT 32
102479: PUSH
102480: EMPTY
102481: LIST
102482: LIST
102483: PUSH
102484: LD_INT 34
102486: PUSH
102487: LD_INT 89
102489: PUSH
102490: EMPTY
102491: LIST
102492: LIST
102493: PUSH
102494: EMPTY
102495: LIST
102496: LIST
102497: LIST
102498: LIST
102499: LIST
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: LIST
102505: PPUSH
102506: CALL_OW 69
102510: ST_TO_ADDR
// if tmp then
102511: LD_VAR 0 4
102515: IFFALSE 102641
// begin for j in tmp do
102517: LD_ADDR_VAR 0 2
102521: PUSH
102522: LD_VAR 0 4
102526: PUSH
102527: FOR_IN
102528: IFFALSE 102639
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102530: LD_VAR 0 2
102534: PPUSH
102535: CALL_OW 262
102539: PUSH
102540: LD_INT 3
102542: EQUAL
102543: PUSH
102544: LD_VAR 0 2
102548: PPUSH
102549: CALL_OW 261
102553: PUSH
102554: LD_INT 20
102556: GREATER
102557: OR
102558: PUSH
102559: LD_VAR 0 2
102563: PPUSH
102564: CALL_OW 314
102568: NOT
102569: AND
102570: PUSH
102571: LD_VAR 0 2
102575: PPUSH
102576: CALL_OW 263
102580: PUSH
102581: LD_INT 1
102583: NONEQUAL
102584: PUSH
102585: LD_VAR 0 2
102589: PPUSH
102590: CALL_OW 311
102594: OR
102595: AND
102596: IFFALSE 102637
// begin ComCollect ( j , x , y ) ;
102598: LD_VAR 0 2
102602: PPUSH
102603: LD_VAR 0 6
102607: PPUSH
102608: LD_VAR 0 7
102612: PPUSH
102613: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102617: LD_VAR 0 2
102621: PPUSH
102622: LD_VAR 0 8
102626: PPUSH
102627: CALL_OW 172
// exit ;
102631: POP
102632: POP
102633: POP
102634: POP
102635: GO 102645
// end ;
102637: GO 102527
102639: POP
102640: POP
// end ; end ;
102641: GO 102016
102643: POP
102644: POP
// end ; end_of_file
102645: PPOPN 9
102647: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102648: LD_INT 0
102650: PPUSH
102651: PPUSH
102652: PPUSH
102653: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102654: LD_VAR 0 1
102658: PPUSH
102659: CALL_OW 264
102663: PUSH
102664: LD_INT 91
102666: EQUAL
102667: IFFALSE 102739
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102669: LD_INT 68
102671: PPUSH
102672: LD_VAR 0 1
102676: PPUSH
102677: CALL_OW 255
102681: PPUSH
102682: CALL_OW 321
102686: PUSH
102687: LD_INT 2
102689: EQUAL
102690: IFFALSE 102702
// eff := 70 else
102692: LD_ADDR_VAR 0 4
102696: PUSH
102697: LD_INT 70
102699: ST_TO_ADDR
102700: GO 102710
// eff := 30 ;
102702: LD_ADDR_VAR 0 4
102706: PUSH
102707: LD_INT 30
102709: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102710: LD_VAR 0 1
102714: PPUSH
102715: CALL_OW 250
102719: PPUSH
102720: LD_VAR 0 1
102724: PPUSH
102725: CALL_OW 251
102729: PPUSH
102730: LD_VAR 0 4
102734: PPUSH
102735: CALL_OW 495
// end ; end ;
102739: LD_VAR 0 2
102743: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102744: LD_INT 0
102746: PPUSH
// end ;
102747: LD_VAR 0 4
102751: RET
// export function SOS_Command ( cmd ) ; begin
102752: LD_INT 0
102754: PPUSH
// end ;
102755: LD_VAR 0 2
102759: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102760: LD_INT 0
102762: PPUSH
// end ;
102763: LD_VAR 0 6
102767: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102768: LD_INT 0
102770: PPUSH
102771: PPUSH
// if not vehicle or not factory then
102772: LD_VAR 0 1
102776: NOT
102777: PUSH
102778: LD_VAR 0 2
102782: NOT
102783: OR
102784: IFFALSE 102788
// exit ;
102786: GO 103019
// if factoryWaypoints >= factory then
102788: LD_EXP 163
102792: PUSH
102793: LD_VAR 0 2
102797: GREATEREQUAL
102798: IFFALSE 103019
// if factoryWaypoints [ factory ] then
102800: LD_EXP 163
102804: PUSH
102805: LD_VAR 0 2
102809: ARRAY
102810: IFFALSE 103019
// begin if GetControl ( vehicle ) = control_manual then
102812: LD_VAR 0 1
102816: PPUSH
102817: CALL_OW 263
102821: PUSH
102822: LD_INT 1
102824: EQUAL
102825: IFFALSE 102906
// begin driver := IsDrivenBy ( vehicle ) ;
102827: LD_ADDR_VAR 0 4
102831: PUSH
102832: LD_VAR 0 1
102836: PPUSH
102837: CALL_OW 311
102841: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102842: LD_VAR 0 4
102846: PPUSH
102847: LD_EXP 163
102851: PUSH
102852: LD_VAR 0 2
102856: ARRAY
102857: PUSH
102858: LD_INT 3
102860: ARRAY
102861: PPUSH
102862: LD_EXP 163
102866: PUSH
102867: LD_VAR 0 2
102871: ARRAY
102872: PUSH
102873: LD_INT 4
102875: ARRAY
102876: PPUSH
102877: CALL_OW 171
// AddComExitVehicle ( driver ) ;
102881: LD_VAR 0 4
102885: PPUSH
102886: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
102890: LD_VAR 0 4
102894: PPUSH
102895: LD_VAR 0 2
102899: PPUSH
102900: CALL_OW 180
// end else
102904: GO 103019
// if GetControl ( vehicle ) = control_remote then
102906: LD_VAR 0 1
102910: PPUSH
102911: CALL_OW 263
102915: PUSH
102916: LD_INT 2
102918: EQUAL
102919: IFFALSE 102980
// begin wait ( 0 0$2 ) ;
102921: LD_INT 70
102923: PPUSH
102924: CALL_OW 67
// if Connect ( vehicle ) then
102928: LD_VAR 0 1
102932: PPUSH
102933: CALL 23039 0 1
102937: IFFALSE 102978
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102939: LD_VAR 0 1
102943: PPUSH
102944: LD_EXP 163
102948: PUSH
102949: LD_VAR 0 2
102953: ARRAY
102954: PUSH
102955: LD_INT 3
102957: ARRAY
102958: PPUSH
102959: LD_EXP 163
102963: PUSH
102964: LD_VAR 0 2
102968: ARRAY
102969: PUSH
102970: LD_INT 4
102972: ARRAY
102973: PPUSH
102974: CALL_OW 171
// end else
102978: GO 103019
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102980: LD_VAR 0 1
102984: PPUSH
102985: LD_EXP 163
102989: PUSH
102990: LD_VAR 0 2
102994: ARRAY
102995: PUSH
102996: LD_INT 3
102998: ARRAY
102999: PPUSH
103000: LD_EXP 163
103004: PUSH
103005: LD_VAR 0 2
103009: ARRAY
103010: PUSH
103011: LD_INT 4
103013: ARRAY
103014: PPUSH
103015: CALL_OW 171
// end ; end ;
103019: LD_VAR 0 3
103023: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103024: LD_INT 0
103026: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103027: LD_VAR 0 1
103031: PUSH
103032: LD_INT 250
103034: EQUAL
103035: PUSH
103036: LD_VAR 0 2
103040: PPUSH
103041: CALL_OW 264
103045: PUSH
103046: LD_INT 81
103048: EQUAL
103049: AND
103050: IFFALSE 103071
// MinerPlaceMine ( unit , x , y ) ;
103052: LD_VAR 0 2
103056: PPUSH
103057: LD_VAR 0 4
103061: PPUSH
103062: LD_VAR 0 5
103066: PPUSH
103067: CALL 105456 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103071: LD_VAR 0 1
103075: PUSH
103076: LD_INT 251
103078: EQUAL
103079: PUSH
103080: LD_VAR 0 2
103084: PPUSH
103085: CALL_OW 264
103089: PUSH
103090: LD_INT 81
103092: EQUAL
103093: AND
103094: IFFALSE 103115
// MinerDetonateMine ( unit , x , y ) ;
103096: LD_VAR 0 2
103100: PPUSH
103101: LD_VAR 0 4
103105: PPUSH
103106: LD_VAR 0 5
103110: PPUSH
103111: CALL 105731 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103115: LD_VAR 0 1
103119: PUSH
103120: LD_INT 252
103122: EQUAL
103123: PUSH
103124: LD_VAR 0 2
103128: PPUSH
103129: CALL_OW 264
103133: PUSH
103134: LD_INT 81
103136: EQUAL
103137: AND
103138: IFFALSE 103159
// MinerCreateMinefield ( unit , x , y ) ;
103140: LD_VAR 0 2
103144: PPUSH
103145: LD_VAR 0 4
103149: PPUSH
103150: LD_VAR 0 5
103154: PPUSH
103155: CALL 106148 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103159: LD_VAR 0 1
103163: PUSH
103164: LD_INT 253
103166: EQUAL
103167: PUSH
103168: LD_VAR 0 2
103172: PPUSH
103173: CALL_OW 257
103177: PUSH
103178: LD_INT 5
103180: EQUAL
103181: AND
103182: IFFALSE 103203
// ComBinocular ( unit , x , y ) ;
103184: LD_VAR 0 2
103188: PPUSH
103189: LD_VAR 0 4
103193: PPUSH
103194: LD_VAR 0 5
103198: PPUSH
103199: CALL 106517 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103203: LD_VAR 0 1
103207: PUSH
103208: LD_INT 254
103210: EQUAL
103211: PUSH
103212: LD_VAR 0 2
103216: PPUSH
103217: CALL_OW 264
103221: PUSH
103222: LD_INT 99
103224: EQUAL
103225: AND
103226: PUSH
103227: LD_VAR 0 3
103231: PPUSH
103232: CALL_OW 263
103236: PUSH
103237: LD_INT 3
103239: EQUAL
103240: AND
103241: IFFALSE 103257
// HackDestroyVehicle ( unit , selectedUnit ) ;
103243: LD_VAR 0 2
103247: PPUSH
103248: LD_VAR 0 3
103252: PPUSH
103253: CALL 104820 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103257: LD_VAR 0 1
103261: PUSH
103262: LD_INT 255
103264: EQUAL
103265: PUSH
103266: LD_VAR 0 2
103270: PPUSH
103271: CALL_OW 264
103275: PUSH
103276: LD_INT 14
103278: PUSH
103279: LD_INT 53
103281: PUSH
103282: EMPTY
103283: LIST
103284: LIST
103285: IN
103286: AND
103287: PUSH
103288: LD_VAR 0 4
103292: PPUSH
103293: LD_VAR 0 5
103297: PPUSH
103298: CALL_OW 488
103302: AND
103303: IFFALSE 103327
// CutTreeXYR ( unit , x , y , 12 ) ;
103305: LD_VAR 0 2
103309: PPUSH
103310: LD_VAR 0 4
103314: PPUSH
103315: LD_VAR 0 5
103319: PPUSH
103320: LD_INT 12
103322: PPUSH
103323: CALL 103390 0 4
// if cmd = 256 then
103327: LD_VAR 0 1
103331: PUSH
103332: LD_INT 256
103334: EQUAL
103335: IFFALSE 103356
// SetFactoryWaypoint ( unit , x , y ) ;
103337: LD_VAR 0 2
103341: PPUSH
103342: LD_VAR 0 4
103346: PPUSH
103347: LD_VAR 0 5
103351: PPUSH
103352: CALL 101337 0 3
// if cmd = 257 then
103356: LD_VAR 0 1
103360: PUSH
103361: LD_INT 257
103363: EQUAL
103364: IFFALSE 103385
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103366: LD_VAR 0 2
103370: PPUSH
103371: LD_VAR 0 4
103375: PPUSH
103376: LD_VAR 0 5
103380: PPUSH
103381: CALL 101699 0 3
// end ;
103385: LD_VAR 0 6
103389: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103390: LD_INT 0
103392: PPUSH
103393: PPUSH
103394: PPUSH
103395: PPUSH
103396: PPUSH
103397: PPUSH
103398: PPUSH
103399: PPUSH
103400: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103401: LD_VAR 0 1
103405: NOT
103406: PUSH
103407: LD_VAR 0 2
103411: PPUSH
103412: LD_VAR 0 3
103416: PPUSH
103417: CALL_OW 488
103421: NOT
103422: OR
103423: PUSH
103424: LD_VAR 0 4
103428: NOT
103429: OR
103430: IFFALSE 103434
// exit ;
103432: GO 103774
// list := [ ] ;
103434: LD_ADDR_VAR 0 13
103438: PUSH
103439: EMPTY
103440: ST_TO_ADDR
// if x - r < 0 then
103441: LD_VAR 0 2
103445: PUSH
103446: LD_VAR 0 4
103450: MINUS
103451: PUSH
103452: LD_INT 0
103454: LESS
103455: IFFALSE 103467
// min_x := 0 else
103457: LD_ADDR_VAR 0 7
103461: PUSH
103462: LD_INT 0
103464: ST_TO_ADDR
103465: GO 103483
// min_x := x - r ;
103467: LD_ADDR_VAR 0 7
103471: PUSH
103472: LD_VAR 0 2
103476: PUSH
103477: LD_VAR 0 4
103481: MINUS
103482: ST_TO_ADDR
// if y - r < 0 then
103483: LD_VAR 0 3
103487: PUSH
103488: LD_VAR 0 4
103492: MINUS
103493: PUSH
103494: LD_INT 0
103496: LESS
103497: IFFALSE 103509
// min_y := 0 else
103499: LD_ADDR_VAR 0 8
103503: PUSH
103504: LD_INT 0
103506: ST_TO_ADDR
103507: GO 103525
// min_y := y - r ;
103509: LD_ADDR_VAR 0 8
103513: PUSH
103514: LD_VAR 0 3
103518: PUSH
103519: LD_VAR 0 4
103523: MINUS
103524: ST_TO_ADDR
// max_x := x + r ;
103525: LD_ADDR_VAR 0 9
103529: PUSH
103530: LD_VAR 0 2
103534: PUSH
103535: LD_VAR 0 4
103539: PLUS
103540: ST_TO_ADDR
// max_y := y + r ;
103541: LD_ADDR_VAR 0 10
103545: PUSH
103546: LD_VAR 0 3
103550: PUSH
103551: LD_VAR 0 4
103555: PLUS
103556: ST_TO_ADDR
// for _x = min_x to max_x do
103557: LD_ADDR_VAR 0 11
103561: PUSH
103562: DOUBLE
103563: LD_VAR 0 7
103567: DEC
103568: ST_TO_ADDR
103569: LD_VAR 0 9
103573: PUSH
103574: FOR_TO
103575: IFFALSE 103692
// for _y = min_y to max_y do
103577: LD_ADDR_VAR 0 12
103581: PUSH
103582: DOUBLE
103583: LD_VAR 0 8
103587: DEC
103588: ST_TO_ADDR
103589: LD_VAR 0 10
103593: PUSH
103594: FOR_TO
103595: IFFALSE 103688
// begin if not ValidHex ( _x , _y ) then
103597: LD_VAR 0 11
103601: PPUSH
103602: LD_VAR 0 12
103606: PPUSH
103607: CALL_OW 488
103611: NOT
103612: IFFALSE 103616
// continue ;
103614: GO 103594
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103616: LD_VAR 0 11
103620: PPUSH
103621: LD_VAR 0 12
103625: PPUSH
103626: CALL_OW 351
103630: PUSH
103631: LD_VAR 0 11
103635: PPUSH
103636: LD_VAR 0 12
103640: PPUSH
103641: CALL_OW 554
103645: AND
103646: IFFALSE 103686
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103648: LD_ADDR_VAR 0 13
103652: PUSH
103653: LD_VAR 0 13
103657: PPUSH
103658: LD_VAR 0 13
103662: PUSH
103663: LD_INT 1
103665: PLUS
103666: PPUSH
103667: LD_VAR 0 11
103671: PUSH
103672: LD_VAR 0 12
103676: PUSH
103677: EMPTY
103678: LIST
103679: LIST
103680: PPUSH
103681: CALL_OW 2
103685: ST_TO_ADDR
// end ;
103686: GO 103594
103688: POP
103689: POP
103690: GO 103574
103692: POP
103693: POP
// if not list then
103694: LD_VAR 0 13
103698: NOT
103699: IFFALSE 103703
// exit ;
103701: GO 103774
// for i in list do
103703: LD_ADDR_VAR 0 6
103707: PUSH
103708: LD_VAR 0 13
103712: PUSH
103713: FOR_IN
103714: IFFALSE 103772
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103716: LD_VAR 0 1
103720: PPUSH
103721: LD_STRING M
103723: PUSH
103724: LD_VAR 0 6
103728: PUSH
103729: LD_INT 1
103731: ARRAY
103732: PUSH
103733: LD_VAR 0 6
103737: PUSH
103738: LD_INT 2
103740: ARRAY
103741: PUSH
103742: LD_INT 0
103744: PUSH
103745: LD_INT 0
103747: PUSH
103748: LD_INT 0
103750: PUSH
103751: LD_INT 0
103753: PUSH
103754: EMPTY
103755: LIST
103756: LIST
103757: LIST
103758: LIST
103759: LIST
103760: LIST
103761: LIST
103762: PUSH
103763: EMPTY
103764: LIST
103765: PPUSH
103766: CALL_OW 447
103770: GO 103713
103772: POP
103773: POP
// end ;
103774: LD_VAR 0 5
103778: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103779: LD_EXP 166
103783: NOT
103784: IFFALSE 103834
103786: GO 103788
103788: DISABLE
// begin initHack := true ;
103789: LD_ADDR_EXP 166
103793: PUSH
103794: LD_INT 1
103796: ST_TO_ADDR
// hackTanks := [ ] ;
103797: LD_ADDR_EXP 167
103801: PUSH
103802: EMPTY
103803: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103804: LD_ADDR_EXP 168
103808: PUSH
103809: EMPTY
103810: ST_TO_ADDR
// hackLimit := 3 ;
103811: LD_ADDR_EXP 169
103815: PUSH
103816: LD_INT 3
103818: ST_TO_ADDR
// hackDist := 12 ;
103819: LD_ADDR_EXP 170
103823: PUSH
103824: LD_INT 12
103826: ST_TO_ADDR
// hackCounter := [ ] ;
103827: LD_ADDR_EXP 171
103831: PUSH
103832: EMPTY
103833: ST_TO_ADDR
// end ;
103834: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103835: LD_EXP 166
103839: PUSH
103840: LD_INT 34
103842: PUSH
103843: LD_INT 99
103845: PUSH
103846: EMPTY
103847: LIST
103848: LIST
103849: PPUSH
103850: CALL_OW 69
103854: AND
103855: IFFALSE 104108
103857: GO 103859
103859: DISABLE
103860: LD_INT 0
103862: PPUSH
103863: PPUSH
// begin enable ;
103864: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
103865: LD_ADDR_VAR 0 1
103869: PUSH
103870: LD_INT 34
103872: PUSH
103873: LD_INT 99
103875: PUSH
103876: EMPTY
103877: LIST
103878: LIST
103879: PPUSH
103880: CALL_OW 69
103884: PUSH
103885: FOR_IN
103886: IFFALSE 104106
// begin if not i in hackTanks then
103888: LD_VAR 0 1
103892: PUSH
103893: LD_EXP 167
103897: IN
103898: NOT
103899: IFFALSE 103982
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103901: LD_ADDR_EXP 167
103905: PUSH
103906: LD_EXP 167
103910: PPUSH
103911: LD_EXP 167
103915: PUSH
103916: LD_INT 1
103918: PLUS
103919: PPUSH
103920: LD_VAR 0 1
103924: PPUSH
103925: CALL_OW 1
103929: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103930: LD_ADDR_EXP 168
103934: PUSH
103935: LD_EXP 168
103939: PPUSH
103940: LD_EXP 168
103944: PUSH
103945: LD_INT 1
103947: PLUS
103948: PPUSH
103949: EMPTY
103950: PPUSH
103951: CALL_OW 1
103955: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
103956: LD_ADDR_EXP 171
103960: PUSH
103961: LD_EXP 171
103965: PPUSH
103966: LD_EXP 171
103970: PUSH
103971: LD_INT 1
103973: PLUS
103974: PPUSH
103975: EMPTY
103976: PPUSH
103977: CALL_OW 1
103981: ST_TO_ADDR
// end ; if not IsOk ( i ) then
103982: LD_VAR 0 1
103986: PPUSH
103987: CALL_OW 302
103991: NOT
103992: IFFALSE 104005
// begin HackUnlinkAll ( i ) ;
103994: LD_VAR 0 1
103998: PPUSH
103999: CALL 104111 0 1
// continue ;
104003: GO 103885
// end ; HackCheckCapturedStatus ( i ) ;
104005: LD_VAR 0 1
104009: PPUSH
104010: CALL 104554 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104014: LD_ADDR_VAR 0 2
104018: PUSH
104019: LD_INT 81
104021: PUSH
104022: LD_VAR 0 1
104026: PPUSH
104027: CALL_OW 255
104031: PUSH
104032: EMPTY
104033: LIST
104034: LIST
104035: PUSH
104036: LD_INT 33
104038: PUSH
104039: LD_INT 3
104041: PUSH
104042: EMPTY
104043: LIST
104044: LIST
104045: PUSH
104046: LD_INT 91
104048: PUSH
104049: LD_VAR 0 1
104053: PUSH
104054: LD_EXP 170
104058: PUSH
104059: EMPTY
104060: LIST
104061: LIST
104062: LIST
104063: PUSH
104064: LD_INT 50
104066: PUSH
104067: EMPTY
104068: LIST
104069: PUSH
104070: EMPTY
104071: LIST
104072: LIST
104073: LIST
104074: LIST
104075: PPUSH
104076: CALL_OW 69
104080: ST_TO_ADDR
// if not tmp then
104081: LD_VAR 0 2
104085: NOT
104086: IFFALSE 104090
// continue ;
104088: GO 103885
// HackLink ( i , tmp ) ;
104090: LD_VAR 0 1
104094: PPUSH
104095: LD_VAR 0 2
104099: PPUSH
104100: CALL 104247 0 2
// end ;
104104: GO 103885
104106: POP
104107: POP
// end ;
104108: PPOPN 2
104110: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104111: LD_INT 0
104113: PPUSH
104114: PPUSH
104115: PPUSH
// if not hack in hackTanks then
104116: LD_VAR 0 1
104120: PUSH
104121: LD_EXP 167
104125: IN
104126: NOT
104127: IFFALSE 104131
// exit ;
104129: GO 104242
// index := GetElementIndex ( hackTanks , hack ) ;
104131: LD_ADDR_VAR 0 4
104135: PUSH
104136: LD_EXP 167
104140: PPUSH
104141: LD_VAR 0 1
104145: PPUSH
104146: CALL 19855 0 2
104150: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104151: LD_EXP 168
104155: PUSH
104156: LD_VAR 0 4
104160: ARRAY
104161: IFFALSE 104242
// begin for i in hackTanksCaptured [ index ] do
104163: LD_ADDR_VAR 0 3
104167: PUSH
104168: LD_EXP 168
104172: PUSH
104173: LD_VAR 0 4
104177: ARRAY
104178: PUSH
104179: FOR_IN
104180: IFFALSE 104206
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104182: LD_VAR 0 3
104186: PUSH
104187: LD_INT 1
104189: ARRAY
104190: PPUSH
104191: LD_VAR 0 3
104195: PUSH
104196: LD_INT 2
104198: ARRAY
104199: PPUSH
104200: CALL_OW 235
104204: GO 104179
104206: POP
104207: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104208: LD_ADDR_EXP 168
104212: PUSH
104213: LD_EXP 168
104217: PPUSH
104218: LD_VAR 0 4
104222: PPUSH
104223: EMPTY
104224: PPUSH
104225: CALL_OW 1
104229: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104230: LD_VAR 0 1
104234: PPUSH
104235: LD_INT 0
104237: PPUSH
104238: CALL_OW 505
// end ; end ;
104242: LD_VAR 0 2
104246: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104247: LD_INT 0
104249: PPUSH
104250: PPUSH
104251: PPUSH
// if not hack in hackTanks or not vehicles then
104252: LD_VAR 0 1
104256: PUSH
104257: LD_EXP 167
104261: IN
104262: NOT
104263: PUSH
104264: LD_VAR 0 2
104268: NOT
104269: OR
104270: IFFALSE 104274
// exit ;
104272: GO 104549
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104274: LD_ADDR_VAR 0 2
104278: PUSH
104279: LD_VAR 0 1
104283: PPUSH
104284: LD_VAR 0 2
104288: PPUSH
104289: LD_INT 1
104291: PPUSH
104292: LD_INT 1
104294: PPUSH
104295: CALL 20505 0 4
104299: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104300: LD_ADDR_VAR 0 5
104304: PUSH
104305: LD_EXP 167
104309: PPUSH
104310: LD_VAR 0 1
104314: PPUSH
104315: CALL 19855 0 2
104319: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104320: LD_EXP 168
104324: PUSH
104325: LD_VAR 0 5
104329: ARRAY
104330: PUSH
104331: LD_EXP 169
104335: LESS
104336: IFFALSE 104525
// begin for i := 1 to vehicles do
104338: LD_ADDR_VAR 0 4
104342: PUSH
104343: DOUBLE
104344: LD_INT 1
104346: DEC
104347: ST_TO_ADDR
104348: LD_VAR 0 2
104352: PUSH
104353: FOR_TO
104354: IFFALSE 104523
// begin if hackTanksCaptured [ index ] = hackLimit then
104356: LD_EXP 168
104360: PUSH
104361: LD_VAR 0 5
104365: ARRAY
104366: PUSH
104367: LD_EXP 169
104371: EQUAL
104372: IFFALSE 104376
// break ;
104374: GO 104523
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104376: LD_ADDR_EXP 171
104380: PUSH
104381: LD_EXP 171
104385: PPUSH
104386: LD_VAR 0 5
104390: PPUSH
104391: LD_EXP 171
104395: PUSH
104396: LD_VAR 0 5
104400: ARRAY
104401: PUSH
104402: LD_INT 1
104404: PLUS
104405: PPUSH
104406: CALL_OW 1
104410: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104411: LD_ADDR_EXP 168
104415: PUSH
104416: LD_EXP 168
104420: PPUSH
104421: LD_VAR 0 5
104425: PUSH
104426: LD_EXP 168
104430: PUSH
104431: LD_VAR 0 5
104435: ARRAY
104436: PUSH
104437: LD_INT 1
104439: PLUS
104440: PUSH
104441: EMPTY
104442: LIST
104443: LIST
104444: PPUSH
104445: LD_VAR 0 2
104449: PUSH
104450: LD_VAR 0 4
104454: ARRAY
104455: PUSH
104456: LD_VAR 0 2
104460: PUSH
104461: LD_VAR 0 4
104465: ARRAY
104466: PPUSH
104467: CALL_OW 255
104471: PUSH
104472: EMPTY
104473: LIST
104474: LIST
104475: PPUSH
104476: CALL 20070 0 3
104480: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104481: LD_VAR 0 2
104485: PUSH
104486: LD_VAR 0 4
104490: ARRAY
104491: PPUSH
104492: LD_VAR 0 1
104496: PPUSH
104497: CALL_OW 255
104501: PPUSH
104502: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104506: LD_VAR 0 2
104510: PUSH
104511: LD_VAR 0 4
104515: ARRAY
104516: PPUSH
104517: CALL_OW 141
// end ;
104521: GO 104353
104523: POP
104524: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104525: LD_VAR 0 1
104529: PPUSH
104530: LD_EXP 168
104534: PUSH
104535: LD_VAR 0 5
104539: ARRAY
104540: PUSH
104541: LD_INT 0
104543: PLUS
104544: PPUSH
104545: CALL_OW 505
// end ;
104549: LD_VAR 0 3
104553: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104554: LD_INT 0
104556: PPUSH
104557: PPUSH
104558: PPUSH
104559: PPUSH
// if not hack in hackTanks then
104560: LD_VAR 0 1
104564: PUSH
104565: LD_EXP 167
104569: IN
104570: NOT
104571: IFFALSE 104575
// exit ;
104573: GO 104815
// index := GetElementIndex ( hackTanks , hack ) ;
104575: LD_ADDR_VAR 0 4
104579: PUSH
104580: LD_EXP 167
104584: PPUSH
104585: LD_VAR 0 1
104589: PPUSH
104590: CALL 19855 0 2
104594: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104595: LD_ADDR_VAR 0 3
104599: PUSH
104600: DOUBLE
104601: LD_EXP 168
104605: PUSH
104606: LD_VAR 0 4
104610: ARRAY
104611: INC
104612: ST_TO_ADDR
104613: LD_INT 1
104615: PUSH
104616: FOR_DOWNTO
104617: IFFALSE 104789
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104619: LD_ADDR_VAR 0 5
104623: PUSH
104624: LD_EXP 168
104628: PUSH
104629: LD_VAR 0 4
104633: ARRAY
104634: PUSH
104635: LD_VAR 0 3
104639: ARRAY
104640: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104641: LD_VAR 0 5
104645: PUSH
104646: LD_INT 1
104648: ARRAY
104649: PPUSH
104650: CALL_OW 302
104654: NOT
104655: PUSH
104656: LD_VAR 0 5
104660: PUSH
104661: LD_INT 1
104663: ARRAY
104664: PPUSH
104665: CALL_OW 255
104669: PUSH
104670: LD_VAR 0 1
104674: PPUSH
104675: CALL_OW 255
104679: NONEQUAL
104680: OR
104681: IFFALSE 104787
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104683: LD_VAR 0 5
104687: PUSH
104688: LD_INT 1
104690: ARRAY
104691: PPUSH
104692: CALL_OW 305
104696: PUSH
104697: LD_VAR 0 5
104701: PUSH
104702: LD_INT 1
104704: ARRAY
104705: PPUSH
104706: CALL_OW 255
104710: PUSH
104711: LD_VAR 0 1
104715: PPUSH
104716: CALL_OW 255
104720: EQUAL
104721: AND
104722: IFFALSE 104746
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104724: LD_VAR 0 5
104728: PUSH
104729: LD_INT 1
104731: ARRAY
104732: PPUSH
104733: LD_VAR 0 5
104737: PUSH
104738: LD_INT 2
104740: ARRAY
104741: PPUSH
104742: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104746: LD_ADDR_EXP 168
104750: PUSH
104751: LD_EXP 168
104755: PPUSH
104756: LD_VAR 0 4
104760: PPUSH
104761: LD_EXP 168
104765: PUSH
104766: LD_VAR 0 4
104770: ARRAY
104771: PPUSH
104772: LD_VAR 0 3
104776: PPUSH
104777: CALL_OW 3
104781: PPUSH
104782: CALL_OW 1
104786: ST_TO_ADDR
// end ; end ;
104787: GO 104616
104789: POP
104790: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104791: LD_VAR 0 1
104795: PPUSH
104796: LD_EXP 168
104800: PUSH
104801: LD_VAR 0 4
104805: ARRAY
104806: PUSH
104807: LD_INT 0
104809: PLUS
104810: PPUSH
104811: CALL_OW 505
// end ;
104815: LD_VAR 0 2
104819: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104820: LD_INT 0
104822: PPUSH
104823: PPUSH
104824: PPUSH
104825: PPUSH
// if not hack in hackTanks then
104826: LD_VAR 0 1
104830: PUSH
104831: LD_EXP 167
104835: IN
104836: NOT
104837: IFFALSE 104841
// exit ;
104839: GO 104926
// index := GetElementIndex ( hackTanks , hack ) ;
104841: LD_ADDR_VAR 0 5
104845: PUSH
104846: LD_EXP 167
104850: PPUSH
104851: LD_VAR 0 1
104855: PPUSH
104856: CALL 19855 0 2
104860: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
104861: LD_ADDR_VAR 0 4
104865: PUSH
104866: DOUBLE
104867: LD_INT 1
104869: DEC
104870: ST_TO_ADDR
104871: LD_EXP 168
104875: PUSH
104876: LD_VAR 0 5
104880: ARRAY
104881: PUSH
104882: FOR_TO
104883: IFFALSE 104924
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104885: LD_EXP 168
104889: PUSH
104890: LD_VAR 0 5
104894: ARRAY
104895: PUSH
104896: LD_VAR 0 4
104900: ARRAY
104901: PUSH
104902: LD_INT 1
104904: ARRAY
104905: PUSH
104906: LD_VAR 0 2
104910: EQUAL
104911: IFFALSE 104922
// KillUnit ( vehicle ) ;
104913: LD_VAR 0 2
104917: PPUSH
104918: CALL_OW 66
104922: GO 104882
104924: POP
104925: POP
// end ;
104926: LD_VAR 0 3
104930: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104931: LD_EXP 172
104935: NOT
104936: IFFALSE 104971
104938: GO 104940
104940: DISABLE
// begin initMiner := true ;
104941: LD_ADDR_EXP 172
104945: PUSH
104946: LD_INT 1
104948: ST_TO_ADDR
// minersList := [ ] ;
104949: LD_ADDR_EXP 173
104953: PUSH
104954: EMPTY
104955: ST_TO_ADDR
// minerMinesList := [ ] ;
104956: LD_ADDR_EXP 174
104960: PUSH
104961: EMPTY
104962: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
104963: LD_ADDR_EXP 175
104967: PUSH
104968: LD_INT 5
104970: ST_TO_ADDR
// end ;
104971: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
104972: LD_EXP 172
104976: PUSH
104977: LD_INT 34
104979: PUSH
104980: LD_INT 81
104982: PUSH
104983: EMPTY
104984: LIST
104985: LIST
104986: PPUSH
104987: CALL_OW 69
104991: AND
104992: IFFALSE 105453
104994: GO 104996
104996: DISABLE
104997: LD_INT 0
104999: PPUSH
105000: PPUSH
105001: PPUSH
105002: PPUSH
// begin enable ;
105003: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105004: LD_ADDR_VAR 0 1
105008: PUSH
105009: LD_INT 34
105011: PUSH
105012: LD_INT 81
105014: PUSH
105015: EMPTY
105016: LIST
105017: LIST
105018: PPUSH
105019: CALL_OW 69
105023: PUSH
105024: FOR_IN
105025: IFFALSE 105097
// begin if not i in minersList then
105027: LD_VAR 0 1
105031: PUSH
105032: LD_EXP 173
105036: IN
105037: NOT
105038: IFFALSE 105095
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105040: LD_ADDR_EXP 173
105044: PUSH
105045: LD_EXP 173
105049: PPUSH
105050: LD_EXP 173
105054: PUSH
105055: LD_INT 1
105057: PLUS
105058: PPUSH
105059: LD_VAR 0 1
105063: PPUSH
105064: CALL_OW 1
105068: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105069: LD_ADDR_EXP 174
105073: PUSH
105074: LD_EXP 174
105078: PPUSH
105079: LD_EXP 174
105083: PUSH
105084: LD_INT 1
105086: PLUS
105087: PPUSH
105088: EMPTY
105089: PPUSH
105090: CALL_OW 1
105094: ST_TO_ADDR
// end end ;
105095: GO 105024
105097: POP
105098: POP
// for i := minerMinesList downto 1 do
105099: LD_ADDR_VAR 0 1
105103: PUSH
105104: DOUBLE
105105: LD_EXP 174
105109: INC
105110: ST_TO_ADDR
105111: LD_INT 1
105113: PUSH
105114: FOR_DOWNTO
105115: IFFALSE 105451
// begin if IsLive ( minersList [ i ] ) then
105117: LD_EXP 173
105121: PUSH
105122: LD_VAR 0 1
105126: ARRAY
105127: PPUSH
105128: CALL_OW 300
105132: IFFALSE 105160
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105134: LD_EXP 173
105138: PUSH
105139: LD_VAR 0 1
105143: ARRAY
105144: PPUSH
105145: LD_EXP 174
105149: PUSH
105150: LD_VAR 0 1
105154: ARRAY
105155: PPUSH
105156: CALL_OW 505
// if not minerMinesList [ i ] then
105160: LD_EXP 174
105164: PUSH
105165: LD_VAR 0 1
105169: ARRAY
105170: NOT
105171: IFFALSE 105175
// continue ;
105173: GO 105114
// for j := minerMinesList [ i ] downto 1 do
105175: LD_ADDR_VAR 0 2
105179: PUSH
105180: DOUBLE
105181: LD_EXP 174
105185: PUSH
105186: LD_VAR 0 1
105190: ARRAY
105191: INC
105192: ST_TO_ADDR
105193: LD_INT 1
105195: PUSH
105196: FOR_DOWNTO
105197: IFFALSE 105447
// begin side := GetSide ( minersList [ i ] ) ;
105199: LD_ADDR_VAR 0 3
105203: PUSH
105204: LD_EXP 173
105208: PUSH
105209: LD_VAR 0 1
105213: ARRAY
105214: PPUSH
105215: CALL_OW 255
105219: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105220: LD_ADDR_VAR 0 4
105224: PUSH
105225: LD_EXP 174
105229: PUSH
105230: LD_VAR 0 1
105234: ARRAY
105235: PUSH
105236: LD_VAR 0 2
105240: ARRAY
105241: PUSH
105242: LD_INT 1
105244: ARRAY
105245: PPUSH
105246: LD_EXP 174
105250: PUSH
105251: LD_VAR 0 1
105255: ARRAY
105256: PUSH
105257: LD_VAR 0 2
105261: ARRAY
105262: PUSH
105263: LD_INT 2
105265: ARRAY
105266: PPUSH
105267: CALL_OW 428
105271: ST_TO_ADDR
// if not tmp then
105272: LD_VAR 0 4
105276: NOT
105277: IFFALSE 105281
// continue ;
105279: GO 105196
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105281: LD_VAR 0 4
105285: PUSH
105286: LD_INT 81
105288: PUSH
105289: LD_VAR 0 3
105293: PUSH
105294: EMPTY
105295: LIST
105296: LIST
105297: PPUSH
105298: CALL_OW 69
105302: IN
105303: PUSH
105304: LD_EXP 174
105308: PUSH
105309: LD_VAR 0 1
105313: ARRAY
105314: PUSH
105315: LD_VAR 0 2
105319: ARRAY
105320: PUSH
105321: LD_INT 1
105323: ARRAY
105324: PPUSH
105325: LD_EXP 174
105329: PUSH
105330: LD_VAR 0 1
105334: ARRAY
105335: PUSH
105336: LD_VAR 0 2
105340: ARRAY
105341: PUSH
105342: LD_INT 2
105344: ARRAY
105345: PPUSH
105346: CALL_OW 458
105350: AND
105351: IFFALSE 105445
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105353: LD_EXP 174
105357: PUSH
105358: LD_VAR 0 1
105362: ARRAY
105363: PUSH
105364: LD_VAR 0 2
105368: ARRAY
105369: PUSH
105370: LD_INT 1
105372: ARRAY
105373: PPUSH
105374: LD_EXP 174
105378: PUSH
105379: LD_VAR 0 1
105383: ARRAY
105384: PUSH
105385: LD_VAR 0 2
105389: ARRAY
105390: PUSH
105391: LD_INT 2
105393: ARRAY
105394: PPUSH
105395: LD_VAR 0 3
105399: PPUSH
105400: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105404: LD_ADDR_EXP 174
105408: PUSH
105409: LD_EXP 174
105413: PPUSH
105414: LD_VAR 0 1
105418: PPUSH
105419: LD_EXP 174
105423: PUSH
105424: LD_VAR 0 1
105428: ARRAY
105429: PPUSH
105430: LD_VAR 0 2
105434: PPUSH
105435: CALL_OW 3
105439: PPUSH
105440: CALL_OW 1
105444: ST_TO_ADDR
// end ; end ;
105445: GO 105196
105447: POP
105448: POP
// end ;
105449: GO 105114
105451: POP
105452: POP
// end ;
105453: PPOPN 4
105455: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105456: LD_INT 0
105458: PPUSH
105459: PPUSH
// result := false ;
105460: LD_ADDR_VAR 0 4
105464: PUSH
105465: LD_INT 0
105467: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105468: LD_VAR 0 1
105472: PPUSH
105473: CALL_OW 264
105477: PUSH
105478: LD_INT 81
105480: EQUAL
105481: NOT
105482: IFFALSE 105486
// exit ;
105484: GO 105726
// index := GetElementIndex ( minersList , unit ) ;
105486: LD_ADDR_VAR 0 5
105490: PUSH
105491: LD_EXP 173
105495: PPUSH
105496: LD_VAR 0 1
105500: PPUSH
105501: CALL 19855 0 2
105505: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105506: LD_EXP 174
105510: PUSH
105511: LD_VAR 0 5
105515: ARRAY
105516: PUSH
105517: LD_EXP 175
105521: GREATEREQUAL
105522: IFFALSE 105526
// exit ;
105524: GO 105726
// ComMoveXY ( unit , x , y ) ;
105526: LD_VAR 0 1
105530: PPUSH
105531: LD_VAR 0 2
105535: PPUSH
105536: LD_VAR 0 3
105540: PPUSH
105541: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105545: LD_INT 35
105547: PPUSH
105548: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105552: LD_VAR 0 1
105556: PPUSH
105557: LD_VAR 0 2
105561: PPUSH
105562: LD_VAR 0 3
105566: PPUSH
105567: CALL 51191 0 3
105571: NOT
105572: PUSH
105573: LD_VAR 0 1
105577: PPUSH
105578: CALL_OW 314
105582: AND
105583: IFFALSE 105587
// exit ;
105585: GO 105726
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105587: LD_VAR 0 2
105591: PPUSH
105592: LD_VAR 0 3
105596: PPUSH
105597: CALL_OW 428
105601: PUSH
105602: LD_VAR 0 1
105606: EQUAL
105607: PUSH
105608: LD_VAR 0 1
105612: PPUSH
105613: CALL_OW 314
105617: NOT
105618: AND
105619: IFFALSE 105545
// PlaySoundXY ( x , y , PlantMine ) ;
105621: LD_VAR 0 2
105625: PPUSH
105626: LD_VAR 0 3
105630: PPUSH
105631: LD_STRING PlantMine
105633: PPUSH
105634: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105638: LD_VAR 0 2
105642: PPUSH
105643: LD_VAR 0 3
105647: PPUSH
105648: LD_VAR 0 1
105652: PPUSH
105653: CALL_OW 255
105657: PPUSH
105658: LD_INT 0
105660: PPUSH
105661: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105665: LD_ADDR_EXP 174
105669: PUSH
105670: LD_EXP 174
105674: PPUSH
105675: LD_VAR 0 5
105679: PUSH
105680: LD_EXP 174
105684: PUSH
105685: LD_VAR 0 5
105689: ARRAY
105690: PUSH
105691: LD_INT 1
105693: PLUS
105694: PUSH
105695: EMPTY
105696: LIST
105697: LIST
105698: PPUSH
105699: LD_VAR 0 2
105703: PUSH
105704: LD_VAR 0 3
105708: PUSH
105709: EMPTY
105710: LIST
105711: LIST
105712: PPUSH
105713: CALL 20070 0 3
105717: ST_TO_ADDR
// result := true ;
105718: LD_ADDR_VAR 0 4
105722: PUSH
105723: LD_INT 1
105725: ST_TO_ADDR
// end ;
105726: LD_VAR 0 4
105730: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105731: LD_INT 0
105733: PPUSH
105734: PPUSH
105735: PPUSH
// if not unit in minersList then
105736: LD_VAR 0 1
105740: PUSH
105741: LD_EXP 173
105745: IN
105746: NOT
105747: IFFALSE 105751
// exit ;
105749: GO 106143
// index := GetElementIndex ( minersList , unit ) ;
105751: LD_ADDR_VAR 0 6
105755: PUSH
105756: LD_EXP 173
105760: PPUSH
105761: LD_VAR 0 1
105765: PPUSH
105766: CALL 19855 0 2
105770: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105771: LD_ADDR_VAR 0 5
105775: PUSH
105776: DOUBLE
105777: LD_EXP 174
105781: PUSH
105782: LD_VAR 0 6
105786: ARRAY
105787: INC
105788: ST_TO_ADDR
105789: LD_INT 1
105791: PUSH
105792: FOR_DOWNTO
105793: IFFALSE 105954
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105795: LD_EXP 174
105799: PUSH
105800: LD_VAR 0 6
105804: ARRAY
105805: PUSH
105806: LD_VAR 0 5
105810: ARRAY
105811: PUSH
105812: LD_INT 1
105814: ARRAY
105815: PUSH
105816: LD_VAR 0 2
105820: EQUAL
105821: PUSH
105822: LD_EXP 174
105826: PUSH
105827: LD_VAR 0 6
105831: ARRAY
105832: PUSH
105833: LD_VAR 0 5
105837: ARRAY
105838: PUSH
105839: LD_INT 2
105841: ARRAY
105842: PUSH
105843: LD_VAR 0 3
105847: EQUAL
105848: AND
105849: IFFALSE 105952
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105851: LD_EXP 174
105855: PUSH
105856: LD_VAR 0 6
105860: ARRAY
105861: PUSH
105862: LD_VAR 0 5
105866: ARRAY
105867: PUSH
105868: LD_INT 1
105870: ARRAY
105871: PPUSH
105872: LD_EXP 174
105876: PUSH
105877: LD_VAR 0 6
105881: ARRAY
105882: PUSH
105883: LD_VAR 0 5
105887: ARRAY
105888: PUSH
105889: LD_INT 2
105891: ARRAY
105892: PPUSH
105893: LD_VAR 0 1
105897: PPUSH
105898: CALL_OW 255
105902: PPUSH
105903: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105907: LD_ADDR_EXP 174
105911: PUSH
105912: LD_EXP 174
105916: PPUSH
105917: LD_VAR 0 6
105921: PPUSH
105922: LD_EXP 174
105926: PUSH
105927: LD_VAR 0 6
105931: ARRAY
105932: PPUSH
105933: LD_VAR 0 5
105937: PPUSH
105938: CALL_OW 3
105942: PPUSH
105943: CALL_OW 1
105947: ST_TO_ADDR
// exit ;
105948: POP
105949: POP
105950: GO 106143
// end ; end ;
105952: GO 105792
105954: POP
105955: POP
// for i := minerMinesList [ index ] downto 1 do
105956: LD_ADDR_VAR 0 5
105960: PUSH
105961: DOUBLE
105962: LD_EXP 174
105966: PUSH
105967: LD_VAR 0 6
105971: ARRAY
105972: INC
105973: ST_TO_ADDR
105974: LD_INT 1
105976: PUSH
105977: FOR_DOWNTO
105978: IFFALSE 106141
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
105980: LD_EXP 174
105984: PUSH
105985: LD_VAR 0 6
105989: ARRAY
105990: PUSH
105991: LD_VAR 0 5
105995: ARRAY
105996: PUSH
105997: LD_INT 1
105999: ARRAY
106000: PPUSH
106001: LD_EXP 174
106005: PUSH
106006: LD_VAR 0 6
106010: ARRAY
106011: PUSH
106012: LD_VAR 0 5
106016: ARRAY
106017: PUSH
106018: LD_INT 2
106020: ARRAY
106021: PPUSH
106022: LD_VAR 0 2
106026: PPUSH
106027: LD_VAR 0 3
106031: PPUSH
106032: CALL_OW 298
106036: PUSH
106037: LD_INT 6
106039: LESS
106040: IFFALSE 106139
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106042: LD_EXP 174
106046: PUSH
106047: LD_VAR 0 6
106051: ARRAY
106052: PUSH
106053: LD_VAR 0 5
106057: ARRAY
106058: PUSH
106059: LD_INT 1
106061: ARRAY
106062: PPUSH
106063: LD_EXP 174
106067: PUSH
106068: LD_VAR 0 6
106072: ARRAY
106073: PUSH
106074: LD_VAR 0 5
106078: ARRAY
106079: PUSH
106080: LD_INT 2
106082: ARRAY
106083: PPUSH
106084: LD_VAR 0 1
106088: PPUSH
106089: CALL_OW 255
106093: PPUSH
106094: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106098: LD_ADDR_EXP 174
106102: PUSH
106103: LD_EXP 174
106107: PPUSH
106108: LD_VAR 0 6
106112: PPUSH
106113: LD_EXP 174
106117: PUSH
106118: LD_VAR 0 6
106122: ARRAY
106123: PPUSH
106124: LD_VAR 0 5
106128: PPUSH
106129: CALL_OW 3
106133: PPUSH
106134: CALL_OW 1
106138: ST_TO_ADDR
// end ; end ;
106139: GO 105977
106141: POP
106142: POP
// end ;
106143: LD_VAR 0 4
106147: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106148: LD_INT 0
106150: PPUSH
106151: PPUSH
106152: PPUSH
106153: PPUSH
106154: PPUSH
106155: PPUSH
106156: PPUSH
106157: PPUSH
106158: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106159: LD_VAR 0 1
106163: PPUSH
106164: CALL_OW 264
106168: PUSH
106169: LD_INT 81
106171: EQUAL
106172: NOT
106173: PUSH
106174: LD_VAR 0 1
106178: PUSH
106179: LD_EXP 173
106183: IN
106184: NOT
106185: OR
106186: IFFALSE 106190
// exit ;
106188: GO 106512
// index := GetElementIndex ( minersList , unit ) ;
106190: LD_ADDR_VAR 0 6
106194: PUSH
106195: LD_EXP 173
106199: PPUSH
106200: LD_VAR 0 1
106204: PPUSH
106205: CALL 19855 0 2
106209: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106210: LD_ADDR_VAR 0 8
106214: PUSH
106215: LD_EXP 175
106219: PUSH
106220: LD_EXP 174
106224: PUSH
106225: LD_VAR 0 6
106229: ARRAY
106230: MINUS
106231: ST_TO_ADDR
// if not minesFreeAmount then
106232: LD_VAR 0 8
106236: NOT
106237: IFFALSE 106241
// exit ;
106239: GO 106512
// tmp := [ ] ;
106241: LD_ADDR_VAR 0 7
106245: PUSH
106246: EMPTY
106247: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106248: LD_ADDR_VAR 0 5
106252: PUSH
106253: DOUBLE
106254: LD_INT 1
106256: DEC
106257: ST_TO_ADDR
106258: LD_VAR 0 8
106262: PUSH
106263: FOR_TO
106264: IFFALSE 106459
// begin _d := rand ( 0 , 5 ) ;
106266: LD_ADDR_VAR 0 11
106270: PUSH
106271: LD_INT 0
106273: PPUSH
106274: LD_INT 5
106276: PPUSH
106277: CALL_OW 12
106281: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106282: LD_ADDR_VAR 0 12
106286: PUSH
106287: LD_INT 2
106289: PPUSH
106290: LD_INT 6
106292: PPUSH
106293: CALL_OW 12
106297: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106298: LD_ADDR_VAR 0 9
106302: PUSH
106303: LD_VAR 0 2
106307: PPUSH
106308: LD_VAR 0 11
106312: PPUSH
106313: LD_VAR 0 12
106317: PPUSH
106318: CALL_OW 272
106322: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106323: LD_ADDR_VAR 0 10
106327: PUSH
106328: LD_VAR 0 3
106332: PPUSH
106333: LD_VAR 0 11
106337: PPUSH
106338: LD_VAR 0 12
106342: PPUSH
106343: CALL_OW 273
106347: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106348: LD_VAR 0 9
106352: PPUSH
106353: LD_VAR 0 10
106357: PPUSH
106358: CALL_OW 488
106362: PUSH
106363: LD_VAR 0 9
106367: PUSH
106368: LD_VAR 0 10
106372: PUSH
106373: EMPTY
106374: LIST
106375: LIST
106376: PUSH
106377: LD_VAR 0 7
106381: IN
106382: NOT
106383: AND
106384: PUSH
106385: LD_VAR 0 9
106389: PPUSH
106390: LD_VAR 0 10
106394: PPUSH
106395: CALL_OW 458
106399: NOT
106400: AND
106401: IFFALSE 106443
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106403: LD_ADDR_VAR 0 7
106407: PUSH
106408: LD_VAR 0 7
106412: PPUSH
106413: LD_VAR 0 7
106417: PUSH
106418: LD_INT 1
106420: PLUS
106421: PPUSH
106422: LD_VAR 0 9
106426: PUSH
106427: LD_VAR 0 10
106431: PUSH
106432: EMPTY
106433: LIST
106434: LIST
106435: PPUSH
106436: CALL_OW 1
106440: ST_TO_ADDR
106441: GO 106457
// i := i - 1 ;
106443: LD_ADDR_VAR 0 5
106447: PUSH
106448: LD_VAR 0 5
106452: PUSH
106453: LD_INT 1
106455: MINUS
106456: ST_TO_ADDR
// end ;
106457: GO 106263
106459: POP
106460: POP
// for i in tmp do
106461: LD_ADDR_VAR 0 5
106465: PUSH
106466: LD_VAR 0 7
106470: PUSH
106471: FOR_IN
106472: IFFALSE 106510
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106474: LD_VAR 0 1
106478: PPUSH
106479: LD_VAR 0 5
106483: PUSH
106484: LD_INT 1
106486: ARRAY
106487: PPUSH
106488: LD_VAR 0 5
106492: PUSH
106493: LD_INT 2
106495: ARRAY
106496: PPUSH
106497: CALL 105456 0 3
106501: NOT
106502: IFFALSE 106508
// exit ;
106504: POP
106505: POP
106506: GO 106512
106508: GO 106471
106510: POP
106511: POP
// end ;
106512: LD_VAR 0 4
106516: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106517: LD_INT 0
106519: PPUSH
106520: PPUSH
106521: PPUSH
106522: PPUSH
106523: PPUSH
106524: PPUSH
106525: PPUSH
// if not GetClass ( unit ) = class_sniper then
106526: LD_VAR 0 1
106530: PPUSH
106531: CALL_OW 257
106535: PUSH
106536: LD_INT 5
106538: EQUAL
106539: NOT
106540: IFFALSE 106544
// exit ;
106542: GO 106932
// dist := 8 ;
106544: LD_ADDR_VAR 0 5
106548: PUSH
106549: LD_INT 8
106551: ST_TO_ADDR
// viewRange := 12 ;
106552: LD_ADDR_VAR 0 7
106556: PUSH
106557: LD_INT 12
106559: ST_TO_ADDR
// side := GetSide ( unit ) ;
106560: LD_ADDR_VAR 0 6
106564: PUSH
106565: LD_VAR 0 1
106569: PPUSH
106570: CALL_OW 255
106574: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106575: LD_INT 61
106577: PPUSH
106578: LD_VAR 0 6
106582: PPUSH
106583: CALL_OW 321
106587: PUSH
106588: LD_INT 2
106590: EQUAL
106591: IFFALSE 106601
// viewRange := 16 ;
106593: LD_ADDR_VAR 0 7
106597: PUSH
106598: LD_INT 16
106600: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106601: LD_VAR 0 1
106605: PPUSH
106606: LD_VAR 0 2
106610: PPUSH
106611: LD_VAR 0 3
106615: PPUSH
106616: CALL_OW 297
106620: PUSH
106621: LD_VAR 0 5
106625: GREATER
106626: IFFALSE 106705
// begin ComMoveXY ( unit , x , y ) ;
106628: LD_VAR 0 1
106632: PPUSH
106633: LD_VAR 0 2
106637: PPUSH
106638: LD_VAR 0 3
106642: PPUSH
106643: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106647: LD_INT 35
106649: PPUSH
106650: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106654: LD_VAR 0 1
106658: PPUSH
106659: LD_VAR 0 2
106663: PPUSH
106664: LD_VAR 0 3
106668: PPUSH
106669: CALL 51191 0 3
106673: NOT
106674: IFFALSE 106678
// exit ;
106676: GO 106932
// until GetDistUnitXY ( unit , x , y ) < dist ;
106678: LD_VAR 0 1
106682: PPUSH
106683: LD_VAR 0 2
106687: PPUSH
106688: LD_VAR 0 3
106692: PPUSH
106693: CALL_OW 297
106697: PUSH
106698: LD_VAR 0 5
106702: LESS
106703: IFFALSE 106647
// end ; ComTurnXY ( unit , x , y ) ;
106705: LD_VAR 0 1
106709: PPUSH
106710: LD_VAR 0 2
106714: PPUSH
106715: LD_VAR 0 3
106719: PPUSH
106720: CALL_OW 118
// wait ( 5 ) ;
106724: LD_INT 5
106726: PPUSH
106727: CALL_OW 67
// _d := GetDir ( unit ) ;
106731: LD_ADDR_VAR 0 10
106735: PUSH
106736: LD_VAR 0 1
106740: PPUSH
106741: CALL_OW 254
106745: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106746: LD_ADDR_VAR 0 8
106750: PUSH
106751: LD_VAR 0 1
106755: PPUSH
106756: CALL_OW 250
106760: PPUSH
106761: LD_VAR 0 10
106765: PPUSH
106766: LD_VAR 0 5
106770: PPUSH
106771: CALL_OW 272
106775: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106776: LD_ADDR_VAR 0 9
106780: PUSH
106781: LD_VAR 0 1
106785: PPUSH
106786: CALL_OW 251
106790: PPUSH
106791: LD_VAR 0 10
106795: PPUSH
106796: LD_VAR 0 5
106800: PPUSH
106801: CALL_OW 273
106805: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106806: LD_VAR 0 8
106810: PPUSH
106811: LD_VAR 0 9
106815: PPUSH
106816: CALL_OW 488
106820: NOT
106821: IFFALSE 106825
// exit ;
106823: GO 106932
// ComAnimCustom ( unit , 1 ) ;
106825: LD_VAR 0 1
106829: PPUSH
106830: LD_INT 1
106832: PPUSH
106833: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106837: LD_VAR 0 8
106841: PPUSH
106842: LD_VAR 0 9
106846: PPUSH
106847: LD_VAR 0 6
106851: PPUSH
106852: LD_VAR 0 7
106856: PPUSH
106857: CALL_OW 330
// repeat wait ( 1 ) ;
106861: LD_INT 1
106863: PPUSH
106864: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
106868: LD_VAR 0 1
106872: PPUSH
106873: CALL_OW 316
106877: PUSH
106878: LD_VAR 0 1
106882: PPUSH
106883: CALL_OW 314
106887: OR
106888: PUSH
106889: LD_VAR 0 1
106893: PPUSH
106894: CALL_OW 302
106898: NOT
106899: OR
106900: PUSH
106901: LD_VAR 0 1
106905: PPUSH
106906: CALL_OW 301
106910: OR
106911: IFFALSE 106861
// RemoveSeeing ( _x , _y , side ) ;
106913: LD_VAR 0 8
106917: PPUSH
106918: LD_VAR 0 9
106922: PPUSH
106923: LD_VAR 0 6
106927: PPUSH
106928: CALL_OW 331
// end ; end_of_file
106932: LD_VAR 0 4
106936: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106937: LD_INT 0
106939: PPUSH
106940: PPUSH
106941: PPUSH
106942: PPUSH
106943: PPUSH
106944: PPUSH
106945: PPUSH
106946: PPUSH
106947: PPUSH
106948: PPUSH
106949: PPUSH
106950: PPUSH
106951: PPUSH
106952: PPUSH
106953: PPUSH
106954: PPUSH
106955: PPUSH
106956: PPUSH
106957: PPUSH
106958: PPUSH
106959: PPUSH
106960: PPUSH
106961: PPUSH
106962: PPUSH
106963: PPUSH
106964: PPUSH
106965: PPUSH
106966: PPUSH
106967: PPUSH
106968: PPUSH
106969: PPUSH
106970: PPUSH
106971: PPUSH
106972: PPUSH
// if not list then
106973: LD_VAR 0 1
106977: NOT
106978: IFFALSE 106982
// exit ;
106980: GO 111641
// base := list [ 1 ] ;
106982: LD_ADDR_VAR 0 3
106986: PUSH
106987: LD_VAR 0 1
106991: PUSH
106992: LD_INT 1
106994: ARRAY
106995: ST_TO_ADDR
// group := list [ 2 ] ;
106996: LD_ADDR_VAR 0 4
107000: PUSH
107001: LD_VAR 0 1
107005: PUSH
107006: LD_INT 2
107008: ARRAY
107009: ST_TO_ADDR
// path := list [ 3 ] ;
107010: LD_ADDR_VAR 0 5
107014: PUSH
107015: LD_VAR 0 1
107019: PUSH
107020: LD_INT 3
107022: ARRAY
107023: ST_TO_ADDR
// flags := list [ 4 ] ;
107024: LD_ADDR_VAR 0 6
107028: PUSH
107029: LD_VAR 0 1
107033: PUSH
107034: LD_INT 4
107036: ARRAY
107037: ST_TO_ADDR
// mined := [ ] ;
107038: LD_ADDR_VAR 0 27
107042: PUSH
107043: EMPTY
107044: ST_TO_ADDR
// bombed := [ ] ;
107045: LD_ADDR_VAR 0 28
107049: PUSH
107050: EMPTY
107051: ST_TO_ADDR
// healers := [ ] ;
107052: LD_ADDR_VAR 0 31
107056: PUSH
107057: EMPTY
107058: ST_TO_ADDR
// to_heal := [ ] ;
107059: LD_ADDR_VAR 0 30
107063: PUSH
107064: EMPTY
107065: ST_TO_ADDR
// repairs := [ ] ;
107066: LD_ADDR_VAR 0 33
107070: PUSH
107071: EMPTY
107072: ST_TO_ADDR
// to_repair := [ ] ;
107073: LD_ADDR_VAR 0 32
107077: PUSH
107078: EMPTY
107079: ST_TO_ADDR
// if not group or not path then
107080: LD_VAR 0 4
107084: NOT
107085: PUSH
107086: LD_VAR 0 5
107090: NOT
107091: OR
107092: IFFALSE 107096
// exit ;
107094: GO 111641
// side := GetSide ( group [ 1 ] ) ;
107096: LD_ADDR_VAR 0 35
107100: PUSH
107101: LD_VAR 0 4
107105: PUSH
107106: LD_INT 1
107108: ARRAY
107109: PPUSH
107110: CALL_OW 255
107114: ST_TO_ADDR
// if flags then
107115: LD_VAR 0 6
107119: IFFALSE 107263
// begin f_ignore_area := flags [ 1 ] ;
107121: LD_ADDR_VAR 0 17
107125: PUSH
107126: LD_VAR 0 6
107130: PUSH
107131: LD_INT 1
107133: ARRAY
107134: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107135: LD_ADDR_VAR 0 18
107139: PUSH
107140: LD_VAR 0 6
107144: PUSH
107145: LD_INT 2
107147: ARRAY
107148: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107149: LD_ADDR_VAR 0 19
107153: PUSH
107154: LD_VAR 0 6
107158: PUSH
107159: LD_INT 3
107161: ARRAY
107162: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107163: LD_ADDR_VAR 0 20
107167: PUSH
107168: LD_VAR 0 6
107172: PUSH
107173: LD_INT 4
107175: ARRAY
107176: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107177: LD_ADDR_VAR 0 21
107181: PUSH
107182: LD_VAR 0 6
107186: PUSH
107187: LD_INT 5
107189: ARRAY
107190: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107191: LD_ADDR_VAR 0 22
107195: PUSH
107196: LD_VAR 0 6
107200: PUSH
107201: LD_INT 6
107203: ARRAY
107204: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107205: LD_ADDR_VAR 0 23
107209: PUSH
107210: LD_VAR 0 6
107214: PUSH
107215: LD_INT 7
107217: ARRAY
107218: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107219: LD_ADDR_VAR 0 24
107223: PUSH
107224: LD_VAR 0 6
107228: PUSH
107229: LD_INT 8
107231: ARRAY
107232: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107233: LD_ADDR_VAR 0 25
107237: PUSH
107238: LD_VAR 0 6
107242: PUSH
107243: LD_INT 9
107245: ARRAY
107246: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107247: LD_ADDR_VAR 0 26
107251: PUSH
107252: LD_VAR 0 6
107256: PUSH
107257: LD_INT 10
107259: ARRAY
107260: ST_TO_ADDR
// end else
107261: GO 107343
// begin f_ignore_area := false ;
107263: LD_ADDR_VAR 0 17
107267: PUSH
107268: LD_INT 0
107270: ST_TO_ADDR
// f_capture := false ;
107271: LD_ADDR_VAR 0 18
107275: PUSH
107276: LD_INT 0
107278: ST_TO_ADDR
// f_ignore_civ := false ;
107279: LD_ADDR_VAR 0 19
107283: PUSH
107284: LD_INT 0
107286: ST_TO_ADDR
// f_murder := false ;
107287: LD_ADDR_VAR 0 20
107291: PUSH
107292: LD_INT 0
107294: ST_TO_ADDR
// f_mines := false ;
107295: LD_ADDR_VAR 0 21
107299: PUSH
107300: LD_INT 0
107302: ST_TO_ADDR
// f_repair := false ;
107303: LD_ADDR_VAR 0 22
107307: PUSH
107308: LD_INT 0
107310: ST_TO_ADDR
// f_heal := false ;
107311: LD_ADDR_VAR 0 23
107315: PUSH
107316: LD_INT 0
107318: ST_TO_ADDR
// f_spacetime := false ;
107319: LD_ADDR_VAR 0 24
107323: PUSH
107324: LD_INT 0
107326: ST_TO_ADDR
// f_attack_depot := false ;
107327: LD_ADDR_VAR 0 25
107331: PUSH
107332: LD_INT 0
107334: ST_TO_ADDR
// f_crawl := false ;
107335: LD_ADDR_VAR 0 26
107339: PUSH
107340: LD_INT 0
107342: ST_TO_ADDR
// end ; if f_heal then
107343: LD_VAR 0 23
107347: IFFALSE 107374
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107349: LD_ADDR_VAR 0 31
107353: PUSH
107354: LD_VAR 0 4
107358: PPUSH
107359: LD_INT 25
107361: PUSH
107362: LD_INT 4
107364: PUSH
107365: EMPTY
107366: LIST
107367: LIST
107368: PPUSH
107369: CALL_OW 72
107373: ST_TO_ADDR
// if f_repair then
107374: LD_VAR 0 22
107378: IFFALSE 107405
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107380: LD_ADDR_VAR 0 33
107384: PUSH
107385: LD_VAR 0 4
107389: PPUSH
107390: LD_INT 25
107392: PUSH
107393: LD_INT 3
107395: PUSH
107396: EMPTY
107397: LIST
107398: LIST
107399: PPUSH
107400: CALL_OW 72
107404: ST_TO_ADDR
// units_path := [ ] ;
107405: LD_ADDR_VAR 0 16
107409: PUSH
107410: EMPTY
107411: ST_TO_ADDR
// for i = 1 to group do
107412: LD_ADDR_VAR 0 7
107416: PUSH
107417: DOUBLE
107418: LD_INT 1
107420: DEC
107421: ST_TO_ADDR
107422: LD_VAR 0 4
107426: PUSH
107427: FOR_TO
107428: IFFALSE 107457
// units_path := Replace ( units_path , i , path ) ;
107430: LD_ADDR_VAR 0 16
107434: PUSH
107435: LD_VAR 0 16
107439: PPUSH
107440: LD_VAR 0 7
107444: PPUSH
107445: LD_VAR 0 5
107449: PPUSH
107450: CALL_OW 1
107454: ST_TO_ADDR
107455: GO 107427
107457: POP
107458: POP
// repeat for i = group downto 1 do
107459: LD_ADDR_VAR 0 7
107463: PUSH
107464: DOUBLE
107465: LD_VAR 0 4
107469: INC
107470: ST_TO_ADDR
107471: LD_INT 1
107473: PUSH
107474: FOR_DOWNTO
107475: IFFALSE 111597
// begin wait ( 5 ) ;
107477: LD_INT 5
107479: PPUSH
107480: CALL_OW 67
// tmp := [ ] ;
107484: LD_ADDR_VAR 0 14
107488: PUSH
107489: EMPTY
107490: ST_TO_ADDR
// attacking := false ;
107491: LD_ADDR_VAR 0 29
107495: PUSH
107496: LD_INT 0
107498: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107499: LD_VAR 0 4
107503: PUSH
107504: LD_VAR 0 7
107508: ARRAY
107509: PPUSH
107510: CALL_OW 301
107514: PUSH
107515: LD_VAR 0 4
107519: PUSH
107520: LD_VAR 0 7
107524: ARRAY
107525: NOT
107526: OR
107527: IFFALSE 107636
// begin if GetType ( group [ i ] ) = unit_human then
107529: LD_VAR 0 4
107533: PUSH
107534: LD_VAR 0 7
107538: ARRAY
107539: PPUSH
107540: CALL_OW 247
107544: PUSH
107545: LD_INT 1
107547: EQUAL
107548: IFFALSE 107594
// begin to_heal := to_heal diff group [ i ] ;
107550: LD_ADDR_VAR 0 30
107554: PUSH
107555: LD_VAR 0 30
107559: PUSH
107560: LD_VAR 0 4
107564: PUSH
107565: LD_VAR 0 7
107569: ARRAY
107570: DIFF
107571: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107572: LD_ADDR_VAR 0 31
107576: PUSH
107577: LD_VAR 0 31
107581: PUSH
107582: LD_VAR 0 4
107586: PUSH
107587: LD_VAR 0 7
107591: ARRAY
107592: DIFF
107593: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107594: LD_ADDR_VAR 0 4
107598: PUSH
107599: LD_VAR 0 4
107603: PPUSH
107604: LD_VAR 0 7
107608: PPUSH
107609: CALL_OW 3
107613: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107614: LD_ADDR_VAR 0 16
107618: PUSH
107619: LD_VAR 0 16
107623: PPUSH
107624: LD_VAR 0 7
107628: PPUSH
107629: CALL_OW 3
107633: ST_TO_ADDR
// continue ;
107634: GO 107474
// end ; if f_repair then
107636: LD_VAR 0 22
107640: IFFALSE 108129
// begin if GetType ( group [ i ] ) = unit_vehicle then
107642: LD_VAR 0 4
107646: PUSH
107647: LD_VAR 0 7
107651: ARRAY
107652: PPUSH
107653: CALL_OW 247
107657: PUSH
107658: LD_INT 2
107660: EQUAL
107661: IFFALSE 107851
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107663: LD_VAR 0 4
107667: PUSH
107668: LD_VAR 0 7
107672: ARRAY
107673: PPUSH
107674: CALL_OW 256
107678: PUSH
107679: LD_INT 700
107681: LESS
107682: PUSH
107683: LD_VAR 0 4
107687: PUSH
107688: LD_VAR 0 7
107692: ARRAY
107693: PUSH
107694: LD_VAR 0 32
107698: IN
107699: NOT
107700: AND
107701: IFFALSE 107725
// to_repair := to_repair union group [ i ] ;
107703: LD_ADDR_VAR 0 32
107707: PUSH
107708: LD_VAR 0 32
107712: PUSH
107713: LD_VAR 0 4
107717: PUSH
107718: LD_VAR 0 7
107722: ARRAY
107723: UNION
107724: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107725: LD_VAR 0 4
107729: PUSH
107730: LD_VAR 0 7
107734: ARRAY
107735: PPUSH
107736: CALL_OW 256
107740: PUSH
107741: LD_INT 1000
107743: EQUAL
107744: PUSH
107745: LD_VAR 0 4
107749: PUSH
107750: LD_VAR 0 7
107754: ARRAY
107755: PUSH
107756: LD_VAR 0 32
107760: IN
107761: AND
107762: IFFALSE 107786
// to_repair := to_repair diff group [ i ] ;
107764: LD_ADDR_VAR 0 32
107768: PUSH
107769: LD_VAR 0 32
107773: PUSH
107774: LD_VAR 0 4
107778: PUSH
107779: LD_VAR 0 7
107783: ARRAY
107784: DIFF
107785: ST_TO_ADDR
// if group [ i ] in to_repair then
107786: LD_VAR 0 4
107790: PUSH
107791: LD_VAR 0 7
107795: ARRAY
107796: PUSH
107797: LD_VAR 0 32
107801: IN
107802: IFFALSE 107849
// begin if not IsInArea ( group [ i ] , f_repair ) then
107804: LD_VAR 0 4
107808: PUSH
107809: LD_VAR 0 7
107813: ARRAY
107814: PPUSH
107815: LD_VAR 0 22
107819: PPUSH
107820: CALL_OW 308
107824: NOT
107825: IFFALSE 107847
// ComMoveToArea ( group [ i ] , f_repair ) ;
107827: LD_VAR 0 4
107831: PUSH
107832: LD_VAR 0 7
107836: ARRAY
107837: PPUSH
107838: LD_VAR 0 22
107842: PPUSH
107843: CALL_OW 113
// continue ;
107847: GO 107474
// end ; end else
107849: GO 108129
// if group [ i ] in repairs then
107851: LD_VAR 0 4
107855: PUSH
107856: LD_VAR 0 7
107860: ARRAY
107861: PUSH
107862: LD_VAR 0 33
107866: IN
107867: IFFALSE 108129
// begin if IsInUnit ( group [ i ] ) then
107869: LD_VAR 0 4
107873: PUSH
107874: LD_VAR 0 7
107878: ARRAY
107879: PPUSH
107880: CALL_OW 310
107884: IFFALSE 107952
// begin z := IsInUnit ( group [ i ] ) ;
107886: LD_ADDR_VAR 0 13
107890: PUSH
107891: LD_VAR 0 4
107895: PUSH
107896: LD_VAR 0 7
107900: ARRAY
107901: PPUSH
107902: CALL_OW 310
107906: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107907: LD_VAR 0 13
107911: PUSH
107912: LD_VAR 0 32
107916: IN
107917: PUSH
107918: LD_VAR 0 13
107922: PPUSH
107923: LD_VAR 0 22
107927: PPUSH
107928: CALL_OW 308
107932: AND
107933: IFFALSE 107950
// ComExitVehicle ( group [ i ] ) ;
107935: LD_VAR 0 4
107939: PUSH
107940: LD_VAR 0 7
107944: ARRAY
107945: PPUSH
107946: CALL_OW 121
// end else
107950: GO 108129
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
107952: LD_ADDR_VAR 0 13
107956: PUSH
107957: LD_VAR 0 4
107961: PPUSH
107962: LD_INT 95
107964: PUSH
107965: LD_VAR 0 22
107969: PUSH
107970: EMPTY
107971: LIST
107972: LIST
107973: PUSH
107974: LD_INT 58
107976: PUSH
107977: EMPTY
107978: LIST
107979: PUSH
107980: EMPTY
107981: LIST
107982: LIST
107983: PPUSH
107984: CALL_OW 72
107988: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107989: LD_VAR 0 4
107993: PUSH
107994: LD_VAR 0 7
107998: ARRAY
107999: PPUSH
108000: CALL_OW 314
108004: NOT
108005: IFFALSE 108127
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108007: LD_ADDR_VAR 0 10
108011: PUSH
108012: LD_VAR 0 13
108016: PPUSH
108017: LD_VAR 0 4
108021: PUSH
108022: LD_VAR 0 7
108026: ARRAY
108027: PPUSH
108028: CALL_OW 74
108032: ST_TO_ADDR
// if not x then
108033: LD_VAR 0 10
108037: NOT
108038: IFFALSE 108042
// continue ;
108040: GO 107474
// if GetLives ( x ) < 1000 then
108042: LD_VAR 0 10
108046: PPUSH
108047: CALL_OW 256
108051: PUSH
108052: LD_INT 1000
108054: LESS
108055: IFFALSE 108079
// ComRepairVehicle ( group [ i ] , x ) else
108057: LD_VAR 0 4
108061: PUSH
108062: LD_VAR 0 7
108066: ARRAY
108067: PPUSH
108068: LD_VAR 0 10
108072: PPUSH
108073: CALL_OW 129
108077: GO 108127
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108079: LD_VAR 0 23
108083: PUSH
108084: LD_VAR 0 4
108088: PUSH
108089: LD_VAR 0 7
108093: ARRAY
108094: PPUSH
108095: CALL_OW 256
108099: PUSH
108100: LD_INT 1000
108102: LESS
108103: AND
108104: NOT
108105: IFFALSE 108127
// ComEnterUnit ( group [ i ] , x ) ;
108107: LD_VAR 0 4
108111: PUSH
108112: LD_VAR 0 7
108116: ARRAY
108117: PPUSH
108118: LD_VAR 0 10
108122: PPUSH
108123: CALL_OW 120
// end ; continue ;
108127: GO 107474
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108129: LD_VAR 0 23
108133: PUSH
108134: LD_VAR 0 4
108138: PUSH
108139: LD_VAR 0 7
108143: ARRAY
108144: PPUSH
108145: CALL_OW 247
108149: PUSH
108150: LD_INT 1
108152: EQUAL
108153: AND
108154: IFFALSE 108632
// begin if group [ i ] in healers then
108156: LD_VAR 0 4
108160: PUSH
108161: LD_VAR 0 7
108165: ARRAY
108166: PUSH
108167: LD_VAR 0 31
108171: IN
108172: IFFALSE 108445
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108174: LD_VAR 0 4
108178: PUSH
108179: LD_VAR 0 7
108183: ARRAY
108184: PPUSH
108185: LD_VAR 0 23
108189: PPUSH
108190: CALL_OW 308
108194: NOT
108195: PUSH
108196: LD_VAR 0 4
108200: PUSH
108201: LD_VAR 0 7
108205: ARRAY
108206: PPUSH
108207: CALL_OW 314
108211: NOT
108212: AND
108213: IFFALSE 108237
// ComMoveToArea ( group [ i ] , f_heal ) else
108215: LD_VAR 0 4
108219: PUSH
108220: LD_VAR 0 7
108224: ARRAY
108225: PPUSH
108226: LD_VAR 0 23
108230: PPUSH
108231: CALL_OW 113
108235: GO 108443
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108237: LD_VAR 0 4
108241: PUSH
108242: LD_VAR 0 7
108246: ARRAY
108247: PPUSH
108248: CALL 49767 0 1
108252: PPUSH
108253: CALL_OW 256
108257: PUSH
108258: LD_INT 1000
108260: EQUAL
108261: IFFALSE 108280
// ComStop ( group [ i ] ) else
108263: LD_VAR 0 4
108267: PUSH
108268: LD_VAR 0 7
108272: ARRAY
108273: PPUSH
108274: CALL_OW 141
108278: GO 108443
// if not HasTask ( group [ i ] ) and to_heal then
108280: LD_VAR 0 4
108284: PUSH
108285: LD_VAR 0 7
108289: ARRAY
108290: PPUSH
108291: CALL_OW 314
108295: NOT
108296: PUSH
108297: LD_VAR 0 30
108301: AND
108302: IFFALSE 108443
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108304: LD_ADDR_VAR 0 13
108308: PUSH
108309: LD_VAR 0 30
108313: PPUSH
108314: LD_INT 3
108316: PUSH
108317: LD_INT 54
108319: PUSH
108320: EMPTY
108321: LIST
108322: PUSH
108323: EMPTY
108324: LIST
108325: LIST
108326: PPUSH
108327: CALL_OW 72
108331: PPUSH
108332: LD_VAR 0 4
108336: PUSH
108337: LD_VAR 0 7
108341: ARRAY
108342: PPUSH
108343: CALL_OW 74
108347: ST_TO_ADDR
// if z then
108348: LD_VAR 0 13
108352: IFFALSE 108443
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108354: LD_INT 91
108356: PUSH
108357: LD_VAR 0 13
108361: PUSH
108362: LD_INT 10
108364: PUSH
108365: EMPTY
108366: LIST
108367: LIST
108368: LIST
108369: PUSH
108370: LD_INT 81
108372: PUSH
108373: LD_VAR 0 13
108377: PPUSH
108378: CALL_OW 255
108382: PUSH
108383: EMPTY
108384: LIST
108385: LIST
108386: PUSH
108387: EMPTY
108388: LIST
108389: LIST
108390: PPUSH
108391: CALL_OW 69
108395: PUSH
108396: LD_INT 0
108398: EQUAL
108399: IFFALSE 108423
// ComHeal ( group [ i ] , z ) else
108401: LD_VAR 0 4
108405: PUSH
108406: LD_VAR 0 7
108410: ARRAY
108411: PPUSH
108412: LD_VAR 0 13
108416: PPUSH
108417: CALL_OW 128
108421: GO 108443
// ComMoveToArea ( group [ i ] , f_heal ) ;
108423: LD_VAR 0 4
108427: PUSH
108428: LD_VAR 0 7
108432: ARRAY
108433: PPUSH
108434: LD_VAR 0 23
108438: PPUSH
108439: CALL_OW 113
// end ; continue ;
108443: GO 107474
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108445: LD_VAR 0 4
108449: PUSH
108450: LD_VAR 0 7
108454: ARRAY
108455: PPUSH
108456: CALL_OW 256
108460: PUSH
108461: LD_INT 700
108463: LESS
108464: PUSH
108465: LD_VAR 0 4
108469: PUSH
108470: LD_VAR 0 7
108474: ARRAY
108475: PUSH
108476: LD_VAR 0 30
108480: IN
108481: NOT
108482: AND
108483: IFFALSE 108507
// to_heal := to_heal union group [ i ] ;
108485: LD_ADDR_VAR 0 30
108489: PUSH
108490: LD_VAR 0 30
108494: PUSH
108495: LD_VAR 0 4
108499: PUSH
108500: LD_VAR 0 7
108504: ARRAY
108505: UNION
108506: ST_TO_ADDR
// if group [ i ] in to_heal then
108507: LD_VAR 0 4
108511: PUSH
108512: LD_VAR 0 7
108516: ARRAY
108517: PUSH
108518: LD_VAR 0 30
108522: IN
108523: IFFALSE 108632
// begin if GetLives ( group [ i ] ) = 1000 then
108525: LD_VAR 0 4
108529: PUSH
108530: LD_VAR 0 7
108534: ARRAY
108535: PPUSH
108536: CALL_OW 256
108540: PUSH
108541: LD_INT 1000
108543: EQUAL
108544: IFFALSE 108570
// to_heal := to_heal diff group [ i ] else
108546: LD_ADDR_VAR 0 30
108550: PUSH
108551: LD_VAR 0 30
108555: PUSH
108556: LD_VAR 0 4
108560: PUSH
108561: LD_VAR 0 7
108565: ARRAY
108566: DIFF
108567: ST_TO_ADDR
108568: GO 108632
// begin if not IsInArea ( group [ i ] , to_heal ) then
108570: LD_VAR 0 4
108574: PUSH
108575: LD_VAR 0 7
108579: ARRAY
108580: PPUSH
108581: LD_VAR 0 30
108585: PPUSH
108586: CALL_OW 308
108590: NOT
108591: IFFALSE 108615
// ComMoveToArea ( group [ i ] , f_heal ) else
108593: LD_VAR 0 4
108597: PUSH
108598: LD_VAR 0 7
108602: ARRAY
108603: PPUSH
108604: LD_VAR 0 23
108608: PPUSH
108609: CALL_OW 113
108613: GO 108630
// ComHold ( group [ i ] ) ;
108615: LD_VAR 0 4
108619: PUSH
108620: LD_VAR 0 7
108624: ARRAY
108625: PPUSH
108626: CALL_OW 140
// continue ;
108630: GO 107474
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108632: LD_VAR 0 4
108636: PUSH
108637: LD_VAR 0 7
108641: ARRAY
108642: PPUSH
108643: LD_INT 10
108645: PPUSH
108646: CALL 47564 0 2
108650: NOT
108651: PUSH
108652: LD_VAR 0 16
108656: PUSH
108657: LD_VAR 0 7
108661: ARRAY
108662: PUSH
108663: EMPTY
108664: EQUAL
108665: NOT
108666: AND
108667: IFFALSE 108933
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108669: LD_VAR 0 4
108673: PUSH
108674: LD_VAR 0 7
108678: ARRAY
108679: PPUSH
108680: CALL_OW 262
108684: PUSH
108685: LD_INT 1
108687: PUSH
108688: LD_INT 2
108690: PUSH
108691: EMPTY
108692: LIST
108693: LIST
108694: IN
108695: IFFALSE 108736
// if GetFuel ( group [ i ] ) < 10 then
108697: LD_VAR 0 4
108701: PUSH
108702: LD_VAR 0 7
108706: ARRAY
108707: PPUSH
108708: CALL_OW 261
108712: PUSH
108713: LD_INT 10
108715: LESS
108716: IFFALSE 108736
// SetFuel ( group [ i ] , 12 ) ;
108718: LD_VAR 0 4
108722: PUSH
108723: LD_VAR 0 7
108727: ARRAY
108728: PPUSH
108729: LD_INT 12
108731: PPUSH
108732: CALL_OW 240
// if units_path [ i ] then
108736: LD_VAR 0 16
108740: PUSH
108741: LD_VAR 0 7
108745: ARRAY
108746: IFFALSE 108931
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108748: LD_VAR 0 4
108752: PUSH
108753: LD_VAR 0 7
108757: ARRAY
108758: PPUSH
108759: LD_VAR 0 16
108763: PUSH
108764: LD_VAR 0 7
108768: ARRAY
108769: PUSH
108770: LD_INT 1
108772: ARRAY
108773: PUSH
108774: LD_INT 1
108776: ARRAY
108777: PPUSH
108778: LD_VAR 0 16
108782: PUSH
108783: LD_VAR 0 7
108787: ARRAY
108788: PUSH
108789: LD_INT 1
108791: ARRAY
108792: PUSH
108793: LD_INT 2
108795: ARRAY
108796: PPUSH
108797: CALL_OW 297
108801: PUSH
108802: LD_INT 6
108804: GREATER
108805: IFFALSE 108880
// begin if not HasTask ( group [ i ] ) then
108807: LD_VAR 0 4
108811: PUSH
108812: LD_VAR 0 7
108816: ARRAY
108817: PPUSH
108818: CALL_OW 314
108822: NOT
108823: IFFALSE 108878
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108825: LD_VAR 0 4
108829: PUSH
108830: LD_VAR 0 7
108834: ARRAY
108835: PPUSH
108836: LD_VAR 0 16
108840: PUSH
108841: LD_VAR 0 7
108845: ARRAY
108846: PUSH
108847: LD_INT 1
108849: ARRAY
108850: PUSH
108851: LD_INT 1
108853: ARRAY
108854: PPUSH
108855: LD_VAR 0 16
108859: PUSH
108860: LD_VAR 0 7
108864: ARRAY
108865: PUSH
108866: LD_INT 1
108868: ARRAY
108869: PUSH
108870: LD_INT 2
108872: ARRAY
108873: PPUSH
108874: CALL_OW 114
// end else
108878: GO 108931
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108880: LD_ADDR_VAR 0 15
108884: PUSH
108885: LD_VAR 0 16
108889: PUSH
108890: LD_VAR 0 7
108894: ARRAY
108895: PPUSH
108896: LD_INT 1
108898: PPUSH
108899: CALL_OW 3
108903: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108904: LD_ADDR_VAR 0 16
108908: PUSH
108909: LD_VAR 0 16
108913: PPUSH
108914: LD_VAR 0 7
108918: PPUSH
108919: LD_VAR 0 15
108923: PPUSH
108924: CALL_OW 1
108928: ST_TO_ADDR
// continue ;
108929: GO 107474
// end ; end ; end else
108931: GO 111595
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108933: LD_ADDR_VAR 0 14
108937: PUSH
108938: LD_INT 81
108940: PUSH
108941: LD_VAR 0 4
108945: PUSH
108946: LD_VAR 0 7
108950: ARRAY
108951: PPUSH
108952: CALL_OW 255
108956: PUSH
108957: EMPTY
108958: LIST
108959: LIST
108960: PPUSH
108961: CALL_OW 69
108965: ST_TO_ADDR
// if not tmp then
108966: LD_VAR 0 14
108970: NOT
108971: IFFALSE 108975
// continue ;
108973: GO 107474
// if f_ignore_area then
108975: LD_VAR 0 17
108979: IFFALSE 109067
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
108981: LD_ADDR_VAR 0 15
108985: PUSH
108986: LD_VAR 0 14
108990: PPUSH
108991: LD_INT 3
108993: PUSH
108994: LD_INT 92
108996: PUSH
108997: LD_VAR 0 17
109001: PUSH
109002: LD_INT 1
109004: ARRAY
109005: PUSH
109006: LD_VAR 0 17
109010: PUSH
109011: LD_INT 2
109013: ARRAY
109014: PUSH
109015: LD_VAR 0 17
109019: PUSH
109020: LD_INT 3
109022: ARRAY
109023: PUSH
109024: EMPTY
109025: LIST
109026: LIST
109027: LIST
109028: LIST
109029: PUSH
109030: EMPTY
109031: LIST
109032: LIST
109033: PPUSH
109034: CALL_OW 72
109038: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109039: LD_VAR 0 14
109043: PUSH
109044: LD_VAR 0 15
109048: DIFF
109049: IFFALSE 109067
// tmp := tmp diff tmp2 ;
109051: LD_ADDR_VAR 0 14
109055: PUSH
109056: LD_VAR 0 14
109060: PUSH
109061: LD_VAR 0 15
109065: DIFF
109066: ST_TO_ADDR
// end ; if not f_murder then
109067: LD_VAR 0 20
109071: NOT
109072: IFFALSE 109130
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109074: LD_ADDR_VAR 0 15
109078: PUSH
109079: LD_VAR 0 14
109083: PPUSH
109084: LD_INT 3
109086: PUSH
109087: LD_INT 50
109089: PUSH
109090: EMPTY
109091: LIST
109092: PUSH
109093: EMPTY
109094: LIST
109095: LIST
109096: PPUSH
109097: CALL_OW 72
109101: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109102: LD_VAR 0 14
109106: PUSH
109107: LD_VAR 0 15
109111: DIFF
109112: IFFALSE 109130
// tmp := tmp diff tmp2 ;
109114: LD_ADDR_VAR 0 14
109118: PUSH
109119: LD_VAR 0 14
109123: PUSH
109124: LD_VAR 0 15
109128: DIFF
109129: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109130: LD_ADDR_VAR 0 14
109134: PUSH
109135: LD_VAR 0 4
109139: PUSH
109140: LD_VAR 0 7
109144: ARRAY
109145: PPUSH
109146: LD_VAR 0 14
109150: PPUSH
109151: LD_INT 1
109153: PPUSH
109154: LD_INT 1
109156: PPUSH
109157: CALL 20505 0 4
109161: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109162: LD_VAR 0 4
109166: PUSH
109167: LD_VAR 0 7
109171: ARRAY
109172: PPUSH
109173: CALL_OW 257
109177: PUSH
109178: LD_INT 1
109180: EQUAL
109181: IFFALSE 109629
// begin if WantPlant ( group [ i ] ) then
109183: LD_VAR 0 4
109187: PUSH
109188: LD_VAR 0 7
109192: ARRAY
109193: PPUSH
109194: CALL 20006 0 1
109198: IFFALSE 109202
// continue ;
109200: GO 107474
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109202: LD_VAR 0 18
109206: PUSH
109207: LD_VAR 0 4
109211: PUSH
109212: LD_VAR 0 7
109216: ARRAY
109217: PPUSH
109218: CALL_OW 310
109222: NOT
109223: AND
109224: PUSH
109225: LD_VAR 0 14
109229: PUSH
109230: LD_INT 1
109232: ARRAY
109233: PUSH
109234: LD_VAR 0 14
109238: PPUSH
109239: LD_INT 21
109241: PUSH
109242: LD_INT 2
109244: PUSH
109245: EMPTY
109246: LIST
109247: LIST
109248: PUSH
109249: LD_INT 58
109251: PUSH
109252: EMPTY
109253: LIST
109254: PUSH
109255: EMPTY
109256: LIST
109257: LIST
109258: PPUSH
109259: CALL_OW 72
109263: IN
109264: AND
109265: IFFALSE 109301
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109267: LD_VAR 0 4
109271: PUSH
109272: LD_VAR 0 7
109276: ARRAY
109277: PPUSH
109278: LD_VAR 0 14
109282: PUSH
109283: LD_INT 1
109285: ARRAY
109286: PPUSH
109287: CALL_OW 120
// attacking := true ;
109291: LD_ADDR_VAR 0 29
109295: PUSH
109296: LD_INT 1
109298: ST_TO_ADDR
// continue ;
109299: GO 107474
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109301: LD_VAR 0 26
109305: PUSH
109306: LD_VAR 0 4
109310: PUSH
109311: LD_VAR 0 7
109315: ARRAY
109316: PPUSH
109317: CALL_OW 257
109321: PUSH
109322: LD_INT 1
109324: EQUAL
109325: AND
109326: PUSH
109327: LD_VAR 0 4
109331: PUSH
109332: LD_VAR 0 7
109336: ARRAY
109337: PPUSH
109338: CALL_OW 256
109342: PUSH
109343: LD_INT 800
109345: LESS
109346: AND
109347: PUSH
109348: LD_VAR 0 4
109352: PUSH
109353: LD_VAR 0 7
109357: ARRAY
109358: PPUSH
109359: CALL_OW 318
109363: NOT
109364: AND
109365: IFFALSE 109382
// ComCrawl ( group [ i ] ) ;
109367: LD_VAR 0 4
109371: PUSH
109372: LD_VAR 0 7
109376: ARRAY
109377: PPUSH
109378: CALL_OW 137
// if f_mines then
109382: LD_VAR 0 21
109386: IFFALSE 109629
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109388: LD_VAR 0 14
109392: PUSH
109393: LD_INT 1
109395: ARRAY
109396: PPUSH
109397: CALL_OW 247
109401: PUSH
109402: LD_INT 3
109404: EQUAL
109405: PUSH
109406: LD_VAR 0 14
109410: PUSH
109411: LD_INT 1
109413: ARRAY
109414: PUSH
109415: LD_VAR 0 27
109419: IN
109420: NOT
109421: AND
109422: IFFALSE 109629
// begin x := GetX ( tmp [ 1 ] ) ;
109424: LD_ADDR_VAR 0 10
109428: PUSH
109429: LD_VAR 0 14
109433: PUSH
109434: LD_INT 1
109436: ARRAY
109437: PPUSH
109438: CALL_OW 250
109442: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109443: LD_ADDR_VAR 0 11
109447: PUSH
109448: LD_VAR 0 14
109452: PUSH
109453: LD_INT 1
109455: ARRAY
109456: PPUSH
109457: CALL_OW 251
109461: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109462: LD_ADDR_VAR 0 12
109466: PUSH
109467: LD_VAR 0 4
109471: PUSH
109472: LD_VAR 0 7
109476: ARRAY
109477: PPUSH
109478: CALL 47649 0 1
109482: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109483: LD_VAR 0 4
109487: PUSH
109488: LD_VAR 0 7
109492: ARRAY
109493: PPUSH
109494: LD_VAR 0 10
109498: PPUSH
109499: LD_VAR 0 11
109503: PPUSH
109504: LD_VAR 0 14
109508: PUSH
109509: LD_INT 1
109511: ARRAY
109512: PPUSH
109513: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109517: LD_VAR 0 4
109521: PUSH
109522: LD_VAR 0 7
109526: ARRAY
109527: PPUSH
109528: LD_VAR 0 10
109532: PPUSH
109533: LD_VAR 0 12
109537: PPUSH
109538: LD_INT 7
109540: PPUSH
109541: CALL_OW 272
109545: PPUSH
109546: LD_VAR 0 11
109550: PPUSH
109551: LD_VAR 0 12
109555: PPUSH
109556: LD_INT 7
109558: PPUSH
109559: CALL_OW 273
109563: PPUSH
109564: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109568: LD_VAR 0 4
109572: PUSH
109573: LD_VAR 0 7
109577: ARRAY
109578: PPUSH
109579: LD_INT 71
109581: PPUSH
109582: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109586: LD_ADDR_VAR 0 27
109590: PUSH
109591: LD_VAR 0 27
109595: PPUSH
109596: LD_VAR 0 27
109600: PUSH
109601: LD_INT 1
109603: PLUS
109604: PPUSH
109605: LD_VAR 0 14
109609: PUSH
109610: LD_INT 1
109612: ARRAY
109613: PPUSH
109614: CALL_OW 1
109618: ST_TO_ADDR
// attacking := true ;
109619: LD_ADDR_VAR 0 29
109623: PUSH
109624: LD_INT 1
109626: ST_TO_ADDR
// continue ;
109627: GO 107474
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109629: LD_VAR 0 4
109633: PUSH
109634: LD_VAR 0 7
109638: ARRAY
109639: PPUSH
109640: CALL_OW 257
109644: PUSH
109645: LD_INT 17
109647: EQUAL
109648: PUSH
109649: LD_VAR 0 4
109653: PUSH
109654: LD_VAR 0 7
109658: ARRAY
109659: PPUSH
109660: CALL_OW 110
109664: PUSH
109665: LD_INT 71
109667: EQUAL
109668: NOT
109669: AND
109670: IFFALSE 109816
// begin attacking := false ;
109672: LD_ADDR_VAR 0 29
109676: PUSH
109677: LD_INT 0
109679: ST_TO_ADDR
// k := 5 ;
109680: LD_ADDR_VAR 0 9
109684: PUSH
109685: LD_INT 5
109687: ST_TO_ADDR
// if tmp < k then
109688: LD_VAR 0 14
109692: PUSH
109693: LD_VAR 0 9
109697: LESS
109698: IFFALSE 109710
// k := tmp ;
109700: LD_ADDR_VAR 0 9
109704: PUSH
109705: LD_VAR 0 14
109709: ST_TO_ADDR
// for j = 1 to k do
109710: LD_ADDR_VAR 0 8
109714: PUSH
109715: DOUBLE
109716: LD_INT 1
109718: DEC
109719: ST_TO_ADDR
109720: LD_VAR 0 9
109724: PUSH
109725: FOR_TO
109726: IFFALSE 109814
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109728: LD_VAR 0 14
109732: PUSH
109733: LD_VAR 0 8
109737: ARRAY
109738: PUSH
109739: LD_VAR 0 14
109743: PPUSH
109744: LD_INT 58
109746: PUSH
109747: EMPTY
109748: LIST
109749: PPUSH
109750: CALL_OW 72
109754: IN
109755: NOT
109756: IFFALSE 109812
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109758: LD_VAR 0 4
109762: PUSH
109763: LD_VAR 0 7
109767: ARRAY
109768: PPUSH
109769: LD_VAR 0 14
109773: PUSH
109774: LD_VAR 0 8
109778: ARRAY
109779: PPUSH
109780: CALL_OW 115
// attacking := true ;
109784: LD_ADDR_VAR 0 29
109788: PUSH
109789: LD_INT 1
109791: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109792: LD_VAR 0 4
109796: PUSH
109797: LD_VAR 0 7
109801: ARRAY
109802: PPUSH
109803: LD_INT 71
109805: PPUSH
109806: CALL_OW 109
// continue ;
109810: GO 109725
// end ; end ;
109812: GO 109725
109814: POP
109815: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109816: LD_VAR 0 4
109820: PUSH
109821: LD_VAR 0 7
109825: ARRAY
109826: PPUSH
109827: CALL_OW 257
109831: PUSH
109832: LD_INT 8
109834: EQUAL
109835: PUSH
109836: LD_VAR 0 4
109840: PUSH
109841: LD_VAR 0 7
109845: ARRAY
109846: PPUSH
109847: CALL_OW 264
109851: PUSH
109852: LD_INT 28
109854: PUSH
109855: LD_INT 45
109857: PUSH
109858: LD_INT 7
109860: PUSH
109861: LD_INT 47
109863: PUSH
109864: EMPTY
109865: LIST
109866: LIST
109867: LIST
109868: LIST
109869: IN
109870: OR
109871: IFFALSE 110127
// begin attacking := false ;
109873: LD_ADDR_VAR 0 29
109877: PUSH
109878: LD_INT 0
109880: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109881: LD_VAR 0 14
109885: PUSH
109886: LD_INT 1
109888: ARRAY
109889: PPUSH
109890: CALL_OW 266
109894: PUSH
109895: LD_INT 32
109897: PUSH
109898: LD_INT 31
109900: PUSH
109901: LD_INT 33
109903: PUSH
109904: LD_INT 4
109906: PUSH
109907: LD_INT 5
109909: PUSH
109910: EMPTY
109911: LIST
109912: LIST
109913: LIST
109914: LIST
109915: LIST
109916: IN
109917: IFFALSE 110103
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109919: LD_ADDR_VAR 0 9
109923: PUSH
109924: LD_VAR 0 14
109928: PUSH
109929: LD_INT 1
109931: ARRAY
109932: PPUSH
109933: CALL_OW 266
109937: PPUSH
109938: LD_VAR 0 14
109942: PUSH
109943: LD_INT 1
109945: ARRAY
109946: PPUSH
109947: CALL_OW 250
109951: PPUSH
109952: LD_VAR 0 14
109956: PUSH
109957: LD_INT 1
109959: ARRAY
109960: PPUSH
109961: CALL_OW 251
109965: PPUSH
109966: LD_VAR 0 14
109970: PUSH
109971: LD_INT 1
109973: ARRAY
109974: PPUSH
109975: CALL_OW 254
109979: PPUSH
109980: LD_VAR 0 14
109984: PUSH
109985: LD_INT 1
109987: ARRAY
109988: PPUSH
109989: CALL_OW 248
109993: PPUSH
109994: LD_INT 0
109996: PPUSH
109997: CALL 29019 0 6
110001: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110002: LD_ADDR_VAR 0 8
110006: PUSH
110007: LD_VAR 0 4
110011: PUSH
110012: LD_VAR 0 7
110016: ARRAY
110017: PPUSH
110018: LD_VAR 0 9
110022: PPUSH
110023: CALL 47762 0 2
110027: ST_TO_ADDR
// if j then
110028: LD_VAR 0 8
110032: IFFALSE 110101
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110034: LD_VAR 0 8
110038: PUSH
110039: LD_INT 1
110041: ARRAY
110042: PPUSH
110043: LD_VAR 0 8
110047: PUSH
110048: LD_INT 2
110050: ARRAY
110051: PPUSH
110052: CALL_OW 488
110056: IFFALSE 110101
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110058: LD_VAR 0 4
110062: PUSH
110063: LD_VAR 0 7
110067: ARRAY
110068: PPUSH
110069: LD_VAR 0 8
110073: PUSH
110074: LD_INT 1
110076: ARRAY
110077: PPUSH
110078: LD_VAR 0 8
110082: PUSH
110083: LD_INT 2
110085: ARRAY
110086: PPUSH
110087: CALL_OW 116
// attacking := true ;
110091: LD_ADDR_VAR 0 29
110095: PUSH
110096: LD_INT 1
110098: ST_TO_ADDR
// continue ;
110099: GO 107474
// end ; end else
110101: GO 110127
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110103: LD_VAR 0 4
110107: PUSH
110108: LD_VAR 0 7
110112: ARRAY
110113: PPUSH
110114: LD_VAR 0 14
110118: PUSH
110119: LD_INT 1
110121: ARRAY
110122: PPUSH
110123: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110127: LD_VAR 0 4
110131: PUSH
110132: LD_VAR 0 7
110136: ARRAY
110137: PPUSH
110138: CALL_OW 265
110142: PUSH
110143: LD_INT 11
110145: EQUAL
110146: IFFALSE 110424
// begin k := 10 ;
110148: LD_ADDR_VAR 0 9
110152: PUSH
110153: LD_INT 10
110155: ST_TO_ADDR
// x := 0 ;
110156: LD_ADDR_VAR 0 10
110160: PUSH
110161: LD_INT 0
110163: ST_TO_ADDR
// if tmp < k then
110164: LD_VAR 0 14
110168: PUSH
110169: LD_VAR 0 9
110173: LESS
110174: IFFALSE 110186
// k := tmp ;
110176: LD_ADDR_VAR 0 9
110180: PUSH
110181: LD_VAR 0 14
110185: ST_TO_ADDR
// for j = k downto 1 do
110186: LD_ADDR_VAR 0 8
110190: PUSH
110191: DOUBLE
110192: LD_VAR 0 9
110196: INC
110197: ST_TO_ADDR
110198: LD_INT 1
110200: PUSH
110201: FOR_DOWNTO
110202: IFFALSE 110277
// begin if GetType ( tmp [ j ] ) = unit_human then
110204: LD_VAR 0 14
110208: PUSH
110209: LD_VAR 0 8
110213: ARRAY
110214: PPUSH
110215: CALL_OW 247
110219: PUSH
110220: LD_INT 1
110222: EQUAL
110223: IFFALSE 110275
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110225: LD_VAR 0 4
110229: PUSH
110230: LD_VAR 0 7
110234: ARRAY
110235: PPUSH
110236: LD_VAR 0 14
110240: PUSH
110241: LD_VAR 0 8
110245: ARRAY
110246: PPUSH
110247: CALL 48016 0 2
// x := tmp [ j ] ;
110251: LD_ADDR_VAR 0 10
110255: PUSH
110256: LD_VAR 0 14
110260: PUSH
110261: LD_VAR 0 8
110265: ARRAY
110266: ST_TO_ADDR
// attacking := true ;
110267: LD_ADDR_VAR 0 29
110271: PUSH
110272: LD_INT 1
110274: ST_TO_ADDR
// end ; end ;
110275: GO 110201
110277: POP
110278: POP
// if not x then
110279: LD_VAR 0 10
110283: NOT
110284: IFFALSE 110424
// begin attacking := true ;
110286: LD_ADDR_VAR 0 29
110290: PUSH
110291: LD_INT 1
110293: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110294: LD_VAR 0 4
110298: PUSH
110299: LD_VAR 0 7
110303: ARRAY
110304: PPUSH
110305: CALL_OW 250
110309: PPUSH
110310: LD_VAR 0 4
110314: PUSH
110315: LD_VAR 0 7
110319: ARRAY
110320: PPUSH
110321: CALL_OW 251
110325: PPUSH
110326: CALL_OW 546
110330: PUSH
110331: LD_INT 2
110333: ARRAY
110334: PUSH
110335: LD_VAR 0 14
110339: PUSH
110340: LD_INT 1
110342: ARRAY
110343: PPUSH
110344: CALL_OW 250
110348: PPUSH
110349: LD_VAR 0 14
110353: PUSH
110354: LD_INT 1
110356: ARRAY
110357: PPUSH
110358: CALL_OW 251
110362: PPUSH
110363: CALL_OW 546
110367: PUSH
110368: LD_INT 2
110370: ARRAY
110371: EQUAL
110372: IFFALSE 110400
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110374: LD_VAR 0 4
110378: PUSH
110379: LD_VAR 0 7
110383: ARRAY
110384: PPUSH
110385: LD_VAR 0 14
110389: PUSH
110390: LD_INT 1
110392: ARRAY
110393: PPUSH
110394: CALL 48016 0 2
110398: GO 110424
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110400: LD_VAR 0 4
110404: PUSH
110405: LD_VAR 0 7
110409: ARRAY
110410: PPUSH
110411: LD_VAR 0 14
110415: PUSH
110416: LD_INT 1
110418: ARRAY
110419: PPUSH
110420: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110424: LD_VAR 0 4
110428: PUSH
110429: LD_VAR 0 7
110433: ARRAY
110434: PPUSH
110435: CALL_OW 264
110439: PUSH
110440: LD_INT 29
110442: EQUAL
110443: IFFALSE 110809
// begin if WantsToAttack ( group [ i ] ) in bombed then
110445: LD_VAR 0 4
110449: PUSH
110450: LD_VAR 0 7
110454: ARRAY
110455: PPUSH
110456: CALL_OW 319
110460: PUSH
110461: LD_VAR 0 28
110465: IN
110466: IFFALSE 110470
// continue ;
110468: GO 107474
// k := 8 ;
110470: LD_ADDR_VAR 0 9
110474: PUSH
110475: LD_INT 8
110477: ST_TO_ADDR
// x := 0 ;
110478: LD_ADDR_VAR 0 10
110482: PUSH
110483: LD_INT 0
110485: ST_TO_ADDR
// if tmp < k then
110486: LD_VAR 0 14
110490: PUSH
110491: LD_VAR 0 9
110495: LESS
110496: IFFALSE 110508
// k := tmp ;
110498: LD_ADDR_VAR 0 9
110502: PUSH
110503: LD_VAR 0 14
110507: ST_TO_ADDR
// for j = 1 to k do
110508: LD_ADDR_VAR 0 8
110512: PUSH
110513: DOUBLE
110514: LD_INT 1
110516: DEC
110517: ST_TO_ADDR
110518: LD_VAR 0 9
110522: PUSH
110523: FOR_TO
110524: IFFALSE 110656
// begin if GetType ( tmp [ j ] ) = unit_building then
110526: LD_VAR 0 14
110530: PUSH
110531: LD_VAR 0 8
110535: ARRAY
110536: PPUSH
110537: CALL_OW 247
110541: PUSH
110542: LD_INT 3
110544: EQUAL
110545: IFFALSE 110654
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110547: LD_VAR 0 14
110551: PUSH
110552: LD_VAR 0 8
110556: ARRAY
110557: PUSH
110558: LD_VAR 0 28
110562: IN
110563: NOT
110564: PUSH
110565: LD_VAR 0 14
110569: PUSH
110570: LD_VAR 0 8
110574: ARRAY
110575: PPUSH
110576: CALL_OW 313
110580: AND
110581: IFFALSE 110654
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110583: LD_VAR 0 4
110587: PUSH
110588: LD_VAR 0 7
110592: ARRAY
110593: PPUSH
110594: LD_VAR 0 14
110598: PUSH
110599: LD_VAR 0 8
110603: ARRAY
110604: PPUSH
110605: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110609: LD_ADDR_VAR 0 28
110613: PUSH
110614: LD_VAR 0 28
110618: PPUSH
110619: LD_VAR 0 28
110623: PUSH
110624: LD_INT 1
110626: PLUS
110627: PPUSH
110628: LD_VAR 0 14
110632: PUSH
110633: LD_VAR 0 8
110637: ARRAY
110638: PPUSH
110639: CALL_OW 1
110643: ST_TO_ADDR
// attacking := true ;
110644: LD_ADDR_VAR 0 29
110648: PUSH
110649: LD_INT 1
110651: ST_TO_ADDR
// break ;
110652: GO 110656
// end ; end ;
110654: GO 110523
110656: POP
110657: POP
// if not attacking and f_attack_depot then
110658: LD_VAR 0 29
110662: NOT
110663: PUSH
110664: LD_VAR 0 25
110668: AND
110669: IFFALSE 110764
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110671: LD_ADDR_VAR 0 13
110675: PUSH
110676: LD_VAR 0 14
110680: PPUSH
110681: LD_INT 2
110683: PUSH
110684: LD_INT 30
110686: PUSH
110687: LD_INT 0
110689: PUSH
110690: EMPTY
110691: LIST
110692: LIST
110693: PUSH
110694: LD_INT 30
110696: PUSH
110697: LD_INT 1
110699: PUSH
110700: EMPTY
110701: LIST
110702: LIST
110703: PUSH
110704: EMPTY
110705: LIST
110706: LIST
110707: LIST
110708: PPUSH
110709: CALL_OW 72
110713: ST_TO_ADDR
// if z then
110714: LD_VAR 0 13
110718: IFFALSE 110764
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110720: LD_VAR 0 4
110724: PUSH
110725: LD_VAR 0 7
110729: ARRAY
110730: PPUSH
110731: LD_VAR 0 13
110735: PPUSH
110736: LD_VAR 0 4
110740: PUSH
110741: LD_VAR 0 7
110745: ARRAY
110746: PPUSH
110747: CALL_OW 74
110751: PPUSH
110752: CALL_OW 115
// attacking := true ;
110756: LD_ADDR_VAR 0 29
110760: PUSH
110761: LD_INT 1
110763: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110764: LD_VAR 0 4
110768: PUSH
110769: LD_VAR 0 7
110773: ARRAY
110774: PPUSH
110775: CALL_OW 256
110779: PUSH
110780: LD_INT 500
110782: LESS
110783: IFFALSE 110809
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110785: LD_VAR 0 4
110789: PUSH
110790: LD_VAR 0 7
110794: ARRAY
110795: PPUSH
110796: LD_VAR 0 14
110800: PUSH
110801: LD_INT 1
110803: ARRAY
110804: PPUSH
110805: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110809: LD_VAR 0 4
110813: PUSH
110814: LD_VAR 0 7
110818: ARRAY
110819: PPUSH
110820: CALL_OW 264
110824: PUSH
110825: LD_INT 49
110827: EQUAL
110828: IFFALSE 110949
// begin if not HasTask ( group [ i ] ) then
110830: LD_VAR 0 4
110834: PUSH
110835: LD_VAR 0 7
110839: ARRAY
110840: PPUSH
110841: CALL_OW 314
110845: NOT
110846: IFFALSE 110949
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
110848: LD_ADDR_VAR 0 9
110852: PUSH
110853: LD_INT 81
110855: PUSH
110856: LD_VAR 0 4
110860: PUSH
110861: LD_VAR 0 7
110865: ARRAY
110866: PPUSH
110867: CALL_OW 255
110871: PUSH
110872: EMPTY
110873: LIST
110874: LIST
110875: PPUSH
110876: CALL_OW 69
110880: PPUSH
110881: LD_VAR 0 4
110885: PUSH
110886: LD_VAR 0 7
110890: ARRAY
110891: PPUSH
110892: CALL_OW 74
110896: ST_TO_ADDR
// if k then
110897: LD_VAR 0 9
110901: IFFALSE 110949
// if GetDistUnits ( group [ i ] , k ) > 10 then
110903: LD_VAR 0 4
110907: PUSH
110908: LD_VAR 0 7
110912: ARRAY
110913: PPUSH
110914: LD_VAR 0 9
110918: PPUSH
110919: CALL_OW 296
110923: PUSH
110924: LD_INT 10
110926: GREATER
110927: IFFALSE 110949
// ComMoveUnit ( group [ i ] , k ) ;
110929: LD_VAR 0 4
110933: PUSH
110934: LD_VAR 0 7
110938: ARRAY
110939: PPUSH
110940: LD_VAR 0 9
110944: PPUSH
110945: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
110949: LD_VAR 0 4
110953: PUSH
110954: LD_VAR 0 7
110958: ARRAY
110959: PPUSH
110960: CALL_OW 256
110964: PUSH
110965: LD_INT 250
110967: LESS
110968: PUSH
110969: LD_VAR 0 4
110973: PUSH
110974: LD_VAR 0 7
110978: ARRAY
110979: PUSH
110980: LD_INT 21
110982: PUSH
110983: LD_INT 2
110985: PUSH
110986: EMPTY
110987: LIST
110988: LIST
110989: PUSH
110990: LD_INT 23
110992: PUSH
110993: LD_INT 2
110995: PUSH
110996: EMPTY
110997: LIST
110998: LIST
110999: PUSH
111000: EMPTY
111001: LIST
111002: LIST
111003: PPUSH
111004: CALL_OW 69
111008: IN
111009: AND
111010: IFFALSE 111135
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111012: LD_ADDR_VAR 0 9
111016: PUSH
111017: LD_OWVAR 3
111021: PUSH
111022: LD_VAR 0 4
111026: PUSH
111027: LD_VAR 0 7
111031: ARRAY
111032: DIFF
111033: PPUSH
111034: LD_VAR 0 4
111038: PUSH
111039: LD_VAR 0 7
111043: ARRAY
111044: PPUSH
111045: CALL_OW 74
111049: ST_TO_ADDR
// if not k then
111050: LD_VAR 0 9
111054: NOT
111055: IFFALSE 111059
// continue ;
111057: GO 107474
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111059: LD_VAR 0 9
111063: PUSH
111064: LD_INT 81
111066: PUSH
111067: LD_VAR 0 4
111071: PUSH
111072: LD_VAR 0 7
111076: ARRAY
111077: PPUSH
111078: CALL_OW 255
111082: PUSH
111083: EMPTY
111084: LIST
111085: LIST
111086: PPUSH
111087: CALL_OW 69
111091: IN
111092: PUSH
111093: LD_VAR 0 9
111097: PPUSH
111098: LD_VAR 0 4
111102: PUSH
111103: LD_VAR 0 7
111107: ARRAY
111108: PPUSH
111109: CALL_OW 296
111113: PUSH
111114: LD_INT 5
111116: LESS
111117: AND
111118: IFFALSE 111135
// ComAutodestruct ( group [ i ] ) ;
111120: LD_VAR 0 4
111124: PUSH
111125: LD_VAR 0 7
111129: ARRAY
111130: PPUSH
111131: CALL 47914 0 1
// end ; if f_attack_depot then
111135: LD_VAR 0 25
111139: IFFALSE 111251
// begin k := 6 ;
111141: LD_ADDR_VAR 0 9
111145: PUSH
111146: LD_INT 6
111148: ST_TO_ADDR
// if tmp < k then
111149: LD_VAR 0 14
111153: PUSH
111154: LD_VAR 0 9
111158: LESS
111159: IFFALSE 111171
// k := tmp ;
111161: LD_ADDR_VAR 0 9
111165: PUSH
111166: LD_VAR 0 14
111170: ST_TO_ADDR
// for j = 1 to k do
111171: LD_ADDR_VAR 0 8
111175: PUSH
111176: DOUBLE
111177: LD_INT 1
111179: DEC
111180: ST_TO_ADDR
111181: LD_VAR 0 9
111185: PUSH
111186: FOR_TO
111187: IFFALSE 111249
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111189: LD_VAR 0 8
111193: PPUSH
111194: CALL_OW 266
111198: PUSH
111199: LD_INT 0
111201: PUSH
111202: LD_INT 1
111204: PUSH
111205: EMPTY
111206: LIST
111207: LIST
111208: IN
111209: IFFALSE 111247
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111211: LD_VAR 0 4
111215: PUSH
111216: LD_VAR 0 7
111220: ARRAY
111221: PPUSH
111222: LD_VAR 0 14
111226: PUSH
111227: LD_VAR 0 8
111231: ARRAY
111232: PPUSH
111233: CALL_OW 115
// attacking := true ;
111237: LD_ADDR_VAR 0 29
111241: PUSH
111242: LD_INT 1
111244: ST_TO_ADDR
// break ;
111245: GO 111249
// end ;
111247: GO 111186
111249: POP
111250: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111251: LD_VAR 0 4
111255: PUSH
111256: LD_VAR 0 7
111260: ARRAY
111261: PPUSH
111262: CALL_OW 302
111266: PUSH
111267: LD_VAR 0 29
111271: NOT
111272: AND
111273: IFFALSE 111595
// begin if GetTag ( group [ i ] ) = 71 then
111275: LD_VAR 0 4
111279: PUSH
111280: LD_VAR 0 7
111284: ARRAY
111285: PPUSH
111286: CALL_OW 110
111290: PUSH
111291: LD_INT 71
111293: EQUAL
111294: IFFALSE 111335
// begin if HasTask ( group [ i ] ) then
111296: LD_VAR 0 4
111300: PUSH
111301: LD_VAR 0 7
111305: ARRAY
111306: PPUSH
111307: CALL_OW 314
111311: IFFALSE 111317
// continue else
111313: GO 107474
111315: GO 111335
// SetTag ( group [ i ] , 0 ) ;
111317: LD_VAR 0 4
111321: PUSH
111322: LD_VAR 0 7
111326: ARRAY
111327: PPUSH
111328: LD_INT 0
111330: PPUSH
111331: CALL_OW 109
// end ; k := 8 ;
111335: LD_ADDR_VAR 0 9
111339: PUSH
111340: LD_INT 8
111342: ST_TO_ADDR
// x := 0 ;
111343: LD_ADDR_VAR 0 10
111347: PUSH
111348: LD_INT 0
111350: ST_TO_ADDR
// if tmp < k then
111351: LD_VAR 0 14
111355: PUSH
111356: LD_VAR 0 9
111360: LESS
111361: IFFALSE 111373
// k := tmp ;
111363: LD_ADDR_VAR 0 9
111367: PUSH
111368: LD_VAR 0 14
111372: ST_TO_ADDR
// for j = 1 to k do
111373: LD_ADDR_VAR 0 8
111377: PUSH
111378: DOUBLE
111379: LD_INT 1
111381: DEC
111382: ST_TO_ADDR
111383: LD_VAR 0 9
111387: PUSH
111388: FOR_TO
111389: IFFALSE 111487
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111391: LD_VAR 0 14
111395: PUSH
111396: LD_VAR 0 8
111400: ARRAY
111401: PPUSH
111402: CALL_OW 247
111406: PUSH
111407: LD_INT 1
111409: EQUAL
111410: PUSH
111411: LD_VAR 0 14
111415: PUSH
111416: LD_VAR 0 8
111420: ARRAY
111421: PPUSH
111422: CALL_OW 256
111426: PUSH
111427: LD_INT 250
111429: LESS
111430: PUSH
111431: LD_VAR 0 20
111435: AND
111436: PUSH
111437: LD_VAR 0 20
111441: NOT
111442: PUSH
111443: LD_VAR 0 14
111447: PUSH
111448: LD_VAR 0 8
111452: ARRAY
111453: PPUSH
111454: CALL_OW 256
111458: PUSH
111459: LD_INT 250
111461: GREATEREQUAL
111462: AND
111463: OR
111464: AND
111465: IFFALSE 111485
// begin x := tmp [ j ] ;
111467: LD_ADDR_VAR 0 10
111471: PUSH
111472: LD_VAR 0 14
111476: PUSH
111477: LD_VAR 0 8
111481: ARRAY
111482: ST_TO_ADDR
// break ;
111483: GO 111487
// end ;
111485: GO 111388
111487: POP
111488: POP
// if x then
111489: LD_VAR 0 10
111493: IFFALSE 111517
// ComAttackUnit ( group [ i ] , x ) else
111495: LD_VAR 0 4
111499: PUSH
111500: LD_VAR 0 7
111504: ARRAY
111505: PPUSH
111506: LD_VAR 0 10
111510: PPUSH
111511: CALL_OW 115
111515: GO 111541
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111517: LD_VAR 0 4
111521: PUSH
111522: LD_VAR 0 7
111526: ARRAY
111527: PPUSH
111528: LD_VAR 0 14
111532: PUSH
111533: LD_INT 1
111535: ARRAY
111536: PPUSH
111537: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111541: LD_VAR 0 4
111545: PUSH
111546: LD_VAR 0 7
111550: ARRAY
111551: PPUSH
111552: CALL_OW 314
111556: NOT
111557: IFFALSE 111595
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111559: LD_VAR 0 4
111563: PUSH
111564: LD_VAR 0 7
111568: ARRAY
111569: PPUSH
111570: LD_VAR 0 14
111574: PPUSH
111575: LD_VAR 0 4
111579: PUSH
111580: LD_VAR 0 7
111584: ARRAY
111585: PPUSH
111586: CALL_OW 74
111590: PPUSH
111591: CALL_OW 115
// end ; end ; end ;
111595: GO 107474
111597: POP
111598: POP
// wait ( 0 0$2 ) ;
111599: LD_INT 70
111601: PPUSH
111602: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111606: LD_VAR 0 4
111610: NOT
111611: PUSH
111612: LD_VAR 0 4
111616: PUSH
111617: EMPTY
111618: EQUAL
111619: OR
111620: PUSH
111621: LD_INT 81
111623: PUSH
111624: LD_VAR 0 35
111628: PUSH
111629: EMPTY
111630: LIST
111631: LIST
111632: PPUSH
111633: CALL_OW 69
111637: NOT
111638: OR
111639: IFFALSE 107459
// end ;
111641: LD_VAR 0 2
111645: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111646: LD_INT 0
111648: PPUSH
111649: PPUSH
111650: PPUSH
111651: PPUSH
111652: PPUSH
111653: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111654: LD_VAR 0 1
111658: NOT
111659: PUSH
111660: LD_EXP 61
111664: PUSH
111665: LD_VAR 0 1
111669: ARRAY
111670: NOT
111671: OR
111672: PUSH
111673: LD_VAR 0 2
111677: NOT
111678: OR
111679: IFFALSE 111683
// exit ;
111681: GO 112237
// side := mc_sides [ base ] ;
111683: LD_ADDR_VAR 0 6
111687: PUSH
111688: LD_EXP 87
111692: PUSH
111693: LD_VAR 0 1
111697: ARRAY
111698: ST_TO_ADDR
// if not side then
111699: LD_VAR 0 6
111703: NOT
111704: IFFALSE 111708
// exit ;
111706: GO 112237
// for i in solds do
111708: LD_ADDR_VAR 0 7
111712: PUSH
111713: LD_VAR 0 2
111717: PUSH
111718: FOR_IN
111719: IFFALSE 111780
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111721: LD_VAR 0 7
111725: PPUSH
111726: CALL_OW 310
111730: PPUSH
111731: CALL_OW 266
111735: PUSH
111736: LD_INT 32
111738: PUSH
111739: LD_INT 31
111741: PUSH
111742: EMPTY
111743: LIST
111744: LIST
111745: IN
111746: IFFALSE 111766
// solds := solds diff i else
111748: LD_ADDR_VAR 0 2
111752: PUSH
111753: LD_VAR 0 2
111757: PUSH
111758: LD_VAR 0 7
111762: DIFF
111763: ST_TO_ADDR
111764: GO 111778
// SetTag ( i , 18 ) ;
111766: LD_VAR 0 7
111770: PPUSH
111771: LD_INT 18
111773: PPUSH
111774: CALL_OW 109
111778: GO 111718
111780: POP
111781: POP
// if not solds then
111782: LD_VAR 0 2
111786: NOT
111787: IFFALSE 111791
// exit ;
111789: GO 112237
// repeat wait ( 0 0$2 ) ;
111791: LD_INT 70
111793: PPUSH
111794: CALL_OW 67
// enemy := mc_scan [ base ] ;
111798: LD_ADDR_VAR 0 4
111802: PUSH
111803: LD_EXP 84
111807: PUSH
111808: LD_VAR 0 1
111812: ARRAY
111813: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111814: LD_EXP 61
111818: PUSH
111819: LD_VAR 0 1
111823: ARRAY
111824: NOT
111825: PUSH
111826: LD_EXP 61
111830: PUSH
111831: LD_VAR 0 1
111835: ARRAY
111836: PUSH
111837: EMPTY
111838: EQUAL
111839: OR
111840: IFFALSE 111877
// begin for i in solds do
111842: LD_ADDR_VAR 0 7
111846: PUSH
111847: LD_VAR 0 2
111851: PUSH
111852: FOR_IN
111853: IFFALSE 111866
// ComStop ( i ) ;
111855: LD_VAR 0 7
111859: PPUSH
111860: CALL_OW 141
111864: GO 111852
111866: POP
111867: POP
// solds := [ ] ;
111868: LD_ADDR_VAR 0 2
111872: PUSH
111873: EMPTY
111874: ST_TO_ADDR
// exit ;
111875: GO 112237
// end ; for i in solds do
111877: LD_ADDR_VAR 0 7
111881: PUSH
111882: LD_VAR 0 2
111886: PUSH
111887: FOR_IN
111888: IFFALSE 112209
// begin if IsInUnit ( i ) then
111890: LD_VAR 0 7
111894: PPUSH
111895: CALL_OW 310
111899: IFFALSE 111910
// ComExitBuilding ( i ) ;
111901: LD_VAR 0 7
111905: PPUSH
111906: CALL_OW 122
// if GetLives ( i ) > 500 then
111910: LD_VAR 0 7
111914: PPUSH
111915: CALL_OW 256
111919: PUSH
111920: LD_INT 500
111922: GREATER
111923: IFFALSE 111976
// begin e := NearestUnitToUnit ( enemy , i ) ;
111925: LD_ADDR_VAR 0 5
111929: PUSH
111930: LD_VAR 0 4
111934: PPUSH
111935: LD_VAR 0 7
111939: PPUSH
111940: CALL_OW 74
111944: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
111945: LD_VAR 0 7
111949: PPUSH
111950: LD_VAR 0 5
111954: PPUSH
111955: CALL_OW 250
111959: PPUSH
111960: LD_VAR 0 5
111964: PPUSH
111965: CALL_OW 251
111969: PPUSH
111970: CALL_OW 114
// end else
111974: GO 112207
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
111976: LD_VAR 0 7
111980: PPUSH
111981: LD_EXP 61
111985: PUSH
111986: LD_VAR 0 1
111990: ARRAY
111991: PPUSH
111992: LD_INT 2
111994: PUSH
111995: LD_INT 30
111997: PUSH
111998: LD_INT 0
112000: PUSH
112001: EMPTY
112002: LIST
112003: LIST
112004: PUSH
112005: LD_INT 30
112007: PUSH
112008: LD_INT 1
112010: PUSH
112011: EMPTY
112012: LIST
112013: LIST
112014: PUSH
112015: LD_INT 30
112017: PUSH
112018: LD_INT 6
112020: PUSH
112021: EMPTY
112022: LIST
112023: LIST
112024: PUSH
112025: EMPTY
112026: LIST
112027: LIST
112028: LIST
112029: LIST
112030: PPUSH
112031: CALL_OW 72
112035: PPUSH
112036: LD_VAR 0 7
112040: PPUSH
112041: CALL_OW 74
112045: PPUSH
112046: CALL_OW 296
112050: PUSH
112051: LD_INT 10
112053: GREATER
112054: IFFALSE 112207
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112056: LD_ADDR_VAR 0 8
112060: PUSH
112061: LD_EXP 61
112065: PUSH
112066: LD_VAR 0 1
112070: ARRAY
112071: PPUSH
112072: LD_INT 2
112074: PUSH
112075: LD_INT 30
112077: PUSH
112078: LD_INT 0
112080: PUSH
112081: EMPTY
112082: LIST
112083: LIST
112084: PUSH
112085: LD_INT 30
112087: PUSH
112088: LD_INT 1
112090: PUSH
112091: EMPTY
112092: LIST
112093: LIST
112094: PUSH
112095: LD_INT 30
112097: PUSH
112098: LD_INT 6
112100: PUSH
112101: EMPTY
112102: LIST
112103: LIST
112104: PUSH
112105: EMPTY
112106: LIST
112107: LIST
112108: LIST
112109: LIST
112110: PPUSH
112111: CALL_OW 72
112115: PPUSH
112116: LD_VAR 0 7
112120: PPUSH
112121: CALL_OW 74
112125: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112126: LD_VAR 0 7
112130: PPUSH
112131: LD_VAR 0 8
112135: PPUSH
112136: CALL_OW 250
112140: PPUSH
112141: LD_INT 3
112143: PPUSH
112144: LD_INT 5
112146: PPUSH
112147: CALL_OW 272
112151: PPUSH
112152: LD_VAR 0 8
112156: PPUSH
112157: CALL_OW 251
112161: PPUSH
112162: LD_INT 3
112164: PPUSH
112165: LD_INT 5
112167: PPUSH
112168: CALL_OW 273
112172: PPUSH
112173: CALL_OW 111
// SetTag ( i , 0 ) ;
112177: LD_VAR 0 7
112181: PPUSH
112182: LD_INT 0
112184: PPUSH
112185: CALL_OW 109
// solds := solds diff i ;
112189: LD_ADDR_VAR 0 2
112193: PUSH
112194: LD_VAR 0 2
112198: PUSH
112199: LD_VAR 0 7
112203: DIFF
112204: ST_TO_ADDR
// continue ;
112205: GO 111887
// end ; end ;
112207: GO 111887
112209: POP
112210: POP
// until not solds or not enemy ;
112211: LD_VAR 0 2
112215: NOT
112216: PUSH
112217: LD_VAR 0 4
112221: NOT
112222: OR
112223: IFFALSE 111791
// MC_Reset ( base , 18 ) ;
112225: LD_VAR 0 1
112229: PPUSH
112230: LD_INT 18
112232: PPUSH
112233: CALL 60496 0 2
// end ;
112237: LD_VAR 0 3
112241: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112242: LD_INT 0
112244: PPUSH
112245: PPUSH
112246: PPUSH
112247: PPUSH
112248: PPUSH
112249: PPUSH
112250: PPUSH
112251: PPUSH
112252: PPUSH
112253: PPUSH
112254: PPUSH
112255: PPUSH
112256: PPUSH
112257: PPUSH
112258: PPUSH
112259: PPUSH
112260: PPUSH
112261: PPUSH
112262: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112263: LD_ADDR_VAR 0 12
112267: PUSH
112268: LD_EXP 61
112272: PUSH
112273: LD_VAR 0 1
112277: ARRAY
112278: PPUSH
112279: LD_INT 25
112281: PUSH
112282: LD_INT 3
112284: PUSH
112285: EMPTY
112286: LIST
112287: LIST
112288: PPUSH
112289: CALL_OW 72
112293: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112294: LD_EXP 101
112298: PUSH
112299: LD_VAR 0 1
112303: ARRAY
112304: IFFALSE 112328
// mechs := mechs diff mc_remote_driver [ base ] ;
112306: LD_ADDR_VAR 0 12
112310: PUSH
112311: LD_VAR 0 12
112315: PUSH
112316: LD_EXP 101
112320: PUSH
112321: LD_VAR 0 1
112325: ARRAY
112326: DIFF
112327: ST_TO_ADDR
// for i in mechs do
112328: LD_ADDR_VAR 0 4
112332: PUSH
112333: LD_VAR 0 12
112337: PUSH
112338: FOR_IN
112339: IFFALSE 112374
// if GetTag ( i ) > 0 then
112341: LD_VAR 0 4
112345: PPUSH
112346: CALL_OW 110
112350: PUSH
112351: LD_INT 0
112353: GREATER
112354: IFFALSE 112372
// mechs := mechs diff i ;
112356: LD_ADDR_VAR 0 12
112360: PUSH
112361: LD_VAR 0 12
112365: PUSH
112366: LD_VAR 0 4
112370: DIFF
112371: ST_TO_ADDR
112372: GO 112338
112374: POP
112375: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112376: LD_ADDR_VAR 0 8
112380: PUSH
112381: LD_EXP 61
112385: PUSH
112386: LD_VAR 0 1
112390: ARRAY
112391: PPUSH
112392: LD_INT 2
112394: PUSH
112395: LD_INT 25
112397: PUSH
112398: LD_INT 1
112400: PUSH
112401: EMPTY
112402: LIST
112403: LIST
112404: PUSH
112405: LD_INT 25
112407: PUSH
112408: LD_INT 5
112410: PUSH
112411: EMPTY
112412: LIST
112413: LIST
112414: PUSH
112415: LD_INT 25
112417: PUSH
112418: LD_INT 8
112420: PUSH
112421: EMPTY
112422: LIST
112423: LIST
112424: PUSH
112425: LD_INT 25
112427: PUSH
112428: LD_INT 9
112430: PUSH
112431: EMPTY
112432: LIST
112433: LIST
112434: PUSH
112435: EMPTY
112436: LIST
112437: LIST
112438: LIST
112439: LIST
112440: LIST
112441: PPUSH
112442: CALL_OW 72
112446: ST_TO_ADDR
// if not defenders and not solds then
112447: LD_VAR 0 2
112451: NOT
112452: PUSH
112453: LD_VAR 0 8
112457: NOT
112458: AND
112459: IFFALSE 112463
// exit ;
112461: GO 114233
// depot_under_attack := false ;
112463: LD_ADDR_VAR 0 16
112467: PUSH
112468: LD_INT 0
112470: ST_TO_ADDR
// sold_defenders := [ ] ;
112471: LD_ADDR_VAR 0 17
112475: PUSH
112476: EMPTY
112477: ST_TO_ADDR
// if mechs then
112478: LD_VAR 0 12
112482: IFFALSE 112635
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112484: LD_ADDR_VAR 0 4
112488: PUSH
112489: LD_VAR 0 2
112493: PPUSH
112494: LD_INT 21
112496: PUSH
112497: LD_INT 2
112499: PUSH
112500: EMPTY
112501: LIST
112502: LIST
112503: PPUSH
112504: CALL_OW 72
112508: PUSH
112509: FOR_IN
112510: IFFALSE 112633
// begin if GetTag ( i ) <> 20 then
112512: LD_VAR 0 4
112516: PPUSH
112517: CALL_OW 110
112521: PUSH
112522: LD_INT 20
112524: NONEQUAL
112525: IFFALSE 112539
// SetTag ( i , 20 ) ;
112527: LD_VAR 0 4
112531: PPUSH
112532: LD_INT 20
112534: PPUSH
112535: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112539: LD_VAR 0 4
112543: PPUSH
112544: CALL_OW 263
112548: PUSH
112549: LD_INT 1
112551: EQUAL
112552: PUSH
112553: LD_VAR 0 4
112557: PPUSH
112558: CALL_OW 311
112562: NOT
112563: AND
112564: IFFALSE 112631
// begin un := mechs [ 1 ] ;
112566: LD_ADDR_VAR 0 10
112570: PUSH
112571: LD_VAR 0 12
112575: PUSH
112576: LD_INT 1
112578: ARRAY
112579: ST_TO_ADDR
// ComExit ( un ) ;
112580: LD_VAR 0 10
112584: PPUSH
112585: CALL 52780 0 1
// AddComEnterUnit ( un , i ) ;
112589: LD_VAR 0 10
112593: PPUSH
112594: LD_VAR 0 4
112598: PPUSH
112599: CALL_OW 180
// SetTag ( un , 19 ) ;
112603: LD_VAR 0 10
112607: PPUSH
112608: LD_INT 19
112610: PPUSH
112611: CALL_OW 109
// mechs := mechs diff un ;
112615: LD_ADDR_VAR 0 12
112619: PUSH
112620: LD_VAR 0 12
112624: PUSH
112625: LD_VAR 0 10
112629: DIFF
112630: ST_TO_ADDR
// end ; end ;
112631: GO 112509
112633: POP
112634: POP
// if solds then
112635: LD_VAR 0 8
112639: IFFALSE 112698
// for i in solds do
112641: LD_ADDR_VAR 0 4
112645: PUSH
112646: LD_VAR 0 8
112650: PUSH
112651: FOR_IN
112652: IFFALSE 112696
// if not GetTag ( i ) then
112654: LD_VAR 0 4
112658: PPUSH
112659: CALL_OW 110
112663: NOT
112664: IFFALSE 112694
// begin defenders := defenders union i ;
112666: LD_ADDR_VAR 0 2
112670: PUSH
112671: LD_VAR 0 2
112675: PUSH
112676: LD_VAR 0 4
112680: UNION
112681: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112682: LD_VAR 0 4
112686: PPUSH
112687: LD_INT 18
112689: PPUSH
112690: CALL_OW 109
// end ;
112694: GO 112651
112696: POP
112697: POP
// repeat wait ( 0 0$2 ) ;
112698: LD_INT 70
112700: PPUSH
112701: CALL_OW 67
// enemy := mc_scan [ base ] ;
112705: LD_ADDR_VAR 0 21
112709: PUSH
112710: LD_EXP 84
112714: PUSH
112715: LD_VAR 0 1
112719: ARRAY
112720: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112721: LD_EXP 61
112725: PUSH
112726: LD_VAR 0 1
112730: ARRAY
112731: NOT
112732: PUSH
112733: LD_EXP 61
112737: PUSH
112738: LD_VAR 0 1
112742: ARRAY
112743: PUSH
112744: EMPTY
112745: EQUAL
112746: OR
112747: IFFALSE 112784
// begin for i in defenders do
112749: LD_ADDR_VAR 0 4
112753: PUSH
112754: LD_VAR 0 2
112758: PUSH
112759: FOR_IN
112760: IFFALSE 112773
// ComStop ( i ) ;
112762: LD_VAR 0 4
112766: PPUSH
112767: CALL_OW 141
112771: GO 112759
112773: POP
112774: POP
// defenders := [ ] ;
112775: LD_ADDR_VAR 0 2
112779: PUSH
112780: EMPTY
112781: ST_TO_ADDR
// exit ;
112782: GO 114233
// end ; for i in defenders do
112784: LD_ADDR_VAR 0 4
112788: PUSH
112789: LD_VAR 0 2
112793: PUSH
112794: FOR_IN
112795: IFFALSE 113693
// begin e := NearestUnitToUnit ( enemy , i ) ;
112797: LD_ADDR_VAR 0 13
112801: PUSH
112802: LD_VAR 0 21
112806: PPUSH
112807: LD_VAR 0 4
112811: PPUSH
112812: CALL_OW 74
112816: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112817: LD_ADDR_VAR 0 7
112821: PUSH
112822: LD_EXP 61
112826: PUSH
112827: LD_VAR 0 1
112831: ARRAY
112832: PPUSH
112833: LD_INT 2
112835: PUSH
112836: LD_INT 30
112838: PUSH
112839: LD_INT 0
112841: PUSH
112842: EMPTY
112843: LIST
112844: LIST
112845: PUSH
112846: LD_INT 30
112848: PUSH
112849: LD_INT 1
112851: PUSH
112852: EMPTY
112853: LIST
112854: LIST
112855: PUSH
112856: EMPTY
112857: LIST
112858: LIST
112859: LIST
112860: PPUSH
112861: CALL_OW 72
112865: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
112866: LD_ADDR_VAR 0 16
112870: PUSH
112871: LD_VAR 0 7
112875: NOT
112876: PUSH
112877: LD_VAR 0 7
112881: PPUSH
112882: LD_INT 3
112884: PUSH
112885: LD_INT 24
112887: PUSH
112888: LD_INT 600
112890: PUSH
112891: EMPTY
112892: LIST
112893: LIST
112894: PUSH
112895: EMPTY
112896: LIST
112897: LIST
112898: PPUSH
112899: CALL_OW 72
112903: OR
112904: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112905: LD_VAR 0 4
112909: PPUSH
112910: CALL_OW 247
112914: PUSH
112915: LD_INT 2
112917: DOUBLE
112918: EQUAL
112919: IFTRUE 112923
112921: GO 113319
112923: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112924: LD_VAR 0 4
112928: PPUSH
112929: CALL_OW 256
112933: PUSH
112934: LD_INT 1000
112936: EQUAL
112937: PUSH
112938: LD_VAR 0 4
112942: PPUSH
112943: LD_VAR 0 13
112947: PPUSH
112948: CALL_OW 296
112952: PUSH
112953: LD_INT 40
112955: LESS
112956: PUSH
112957: LD_VAR 0 13
112961: PPUSH
112962: LD_EXP 86
112966: PUSH
112967: LD_VAR 0 1
112971: ARRAY
112972: PPUSH
112973: CALL_OW 308
112977: OR
112978: AND
112979: IFFALSE 113101
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
112981: LD_VAR 0 4
112985: PPUSH
112986: CALL_OW 262
112990: PUSH
112991: LD_INT 1
112993: EQUAL
112994: PUSH
112995: LD_VAR 0 4
112999: PPUSH
113000: CALL_OW 261
113004: PUSH
113005: LD_INT 30
113007: LESS
113008: AND
113009: PUSH
113010: LD_VAR 0 7
113014: AND
113015: IFFALSE 113085
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113017: LD_VAR 0 4
113021: PPUSH
113022: LD_VAR 0 7
113026: PPUSH
113027: LD_VAR 0 4
113031: PPUSH
113032: CALL_OW 74
113036: PPUSH
113037: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113041: LD_VAR 0 4
113045: PPUSH
113046: LD_VAR 0 7
113050: PPUSH
113051: LD_VAR 0 4
113055: PPUSH
113056: CALL_OW 74
113060: PPUSH
113061: CALL_OW 296
113065: PUSH
113066: LD_INT 6
113068: LESS
113069: IFFALSE 113083
// SetFuel ( i , 100 ) ;
113071: LD_VAR 0 4
113075: PPUSH
113076: LD_INT 100
113078: PPUSH
113079: CALL_OW 240
// end else
113083: GO 113099
// ComAttackUnit ( i , e ) ;
113085: LD_VAR 0 4
113089: PPUSH
113090: LD_VAR 0 13
113094: PPUSH
113095: CALL_OW 115
// end else
113099: GO 113202
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113101: LD_VAR 0 13
113105: PPUSH
113106: LD_EXP 86
113110: PUSH
113111: LD_VAR 0 1
113115: ARRAY
113116: PPUSH
113117: CALL_OW 308
113121: NOT
113122: PUSH
113123: LD_VAR 0 4
113127: PPUSH
113128: LD_VAR 0 13
113132: PPUSH
113133: CALL_OW 296
113137: PUSH
113138: LD_INT 40
113140: GREATEREQUAL
113141: AND
113142: PUSH
113143: LD_VAR 0 4
113147: PPUSH
113148: CALL_OW 256
113152: PUSH
113153: LD_INT 650
113155: LESSEQUAL
113156: OR
113157: PUSH
113158: LD_VAR 0 4
113162: PPUSH
113163: LD_EXP 85
113167: PUSH
113168: LD_VAR 0 1
113172: ARRAY
113173: PPUSH
113174: CALL_OW 308
113178: NOT
113179: AND
113180: IFFALSE 113202
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113182: LD_VAR 0 4
113186: PPUSH
113187: LD_EXP 85
113191: PUSH
113192: LD_VAR 0 1
113196: ARRAY
113197: PPUSH
113198: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113202: LD_VAR 0 4
113206: PPUSH
113207: CALL_OW 256
113211: PUSH
113212: LD_INT 1000
113214: LESS
113215: PUSH
113216: LD_VAR 0 4
113220: PPUSH
113221: CALL_OW 263
113225: PUSH
113226: LD_INT 1
113228: EQUAL
113229: AND
113230: PUSH
113231: LD_VAR 0 4
113235: PPUSH
113236: CALL_OW 311
113240: AND
113241: PUSH
113242: LD_VAR 0 4
113246: PPUSH
113247: LD_EXP 85
113251: PUSH
113252: LD_VAR 0 1
113256: ARRAY
113257: PPUSH
113258: CALL_OW 308
113262: AND
113263: IFFALSE 113317
// begin mech := IsDrivenBy ( i ) ;
113265: LD_ADDR_VAR 0 9
113269: PUSH
113270: LD_VAR 0 4
113274: PPUSH
113275: CALL_OW 311
113279: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113280: LD_VAR 0 9
113284: PPUSH
113285: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113289: LD_VAR 0 9
113293: PPUSH
113294: LD_VAR 0 4
113298: PPUSH
113299: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113303: LD_VAR 0 9
113307: PPUSH
113308: LD_VAR 0 4
113312: PPUSH
113313: CALL_OW 180
// end ; end ; unit_human :
113317: GO 113664
113319: LD_INT 1
113321: DOUBLE
113322: EQUAL
113323: IFTRUE 113327
113325: GO 113663
113327: POP
// begin b := IsInUnit ( i ) ;
113328: LD_ADDR_VAR 0 18
113332: PUSH
113333: LD_VAR 0 4
113337: PPUSH
113338: CALL_OW 310
113342: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113343: LD_ADDR_VAR 0 19
113347: PUSH
113348: LD_VAR 0 18
113352: NOT
113353: PUSH
113354: LD_VAR 0 18
113358: PPUSH
113359: CALL_OW 266
113363: PUSH
113364: LD_INT 32
113366: PUSH
113367: LD_INT 31
113369: PUSH
113370: EMPTY
113371: LIST
113372: LIST
113373: IN
113374: OR
113375: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113376: LD_VAR 0 18
113380: PPUSH
113381: CALL_OW 266
113385: PUSH
113386: LD_INT 5
113388: EQUAL
113389: PUSH
113390: LD_VAR 0 4
113394: PPUSH
113395: CALL_OW 257
113399: PUSH
113400: LD_INT 1
113402: PUSH
113403: LD_INT 2
113405: PUSH
113406: LD_INT 3
113408: PUSH
113409: LD_INT 4
113411: PUSH
113412: EMPTY
113413: LIST
113414: LIST
113415: LIST
113416: LIST
113417: IN
113418: AND
113419: IFFALSE 113456
// begin class := AllowSpecClass ( i ) ;
113421: LD_ADDR_VAR 0 20
113425: PUSH
113426: LD_VAR 0 4
113430: PPUSH
113431: CALL 16719 0 1
113435: ST_TO_ADDR
// if class then
113436: LD_VAR 0 20
113440: IFFALSE 113456
// ComChangeProfession ( i , class ) ;
113442: LD_VAR 0 4
113446: PPUSH
113447: LD_VAR 0 20
113451: PPUSH
113452: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113456: LD_VAR 0 16
113460: PUSH
113461: LD_VAR 0 2
113465: PPUSH
113466: LD_INT 21
113468: PUSH
113469: LD_INT 2
113471: PUSH
113472: EMPTY
113473: LIST
113474: LIST
113475: PPUSH
113476: CALL_OW 72
113480: PUSH
113481: LD_INT 1
113483: LESSEQUAL
113484: OR
113485: PUSH
113486: LD_VAR 0 19
113490: AND
113491: PUSH
113492: LD_VAR 0 4
113496: PUSH
113497: LD_VAR 0 17
113501: IN
113502: NOT
113503: AND
113504: IFFALSE 113597
// begin if b then
113506: LD_VAR 0 18
113510: IFFALSE 113559
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113512: LD_VAR 0 18
113516: PPUSH
113517: LD_VAR 0 21
113521: PPUSH
113522: LD_VAR 0 18
113526: PPUSH
113527: CALL_OW 74
113531: PPUSH
113532: CALL_OW 296
113536: PUSH
113537: LD_INT 10
113539: LESS
113540: PUSH
113541: LD_VAR 0 18
113545: PPUSH
113546: CALL_OW 461
113550: PUSH
113551: LD_INT 7
113553: NONEQUAL
113554: AND
113555: IFFALSE 113559
// continue ;
113557: GO 112794
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113559: LD_ADDR_VAR 0 17
113563: PUSH
113564: LD_VAR 0 17
113568: PPUSH
113569: LD_VAR 0 17
113573: PUSH
113574: LD_INT 1
113576: PLUS
113577: PPUSH
113578: LD_VAR 0 4
113582: PPUSH
113583: CALL_OW 1
113587: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113588: LD_VAR 0 4
113592: PPUSH
113593: CALL_OW 122
// end ; if sold_defenders then
113597: LD_VAR 0 17
113601: IFFALSE 113661
// if i in sold_defenders then
113603: LD_VAR 0 4
113607: PUSH
113608: LD_VAR 0 17
113612: IN
113613: IFFALSE 113661
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113615: LD_VAR 0 4
113619: PPUSH
113620: CALL_OW 314
113624: NOT
113625: PUSH
113626: LD_VAR 0 4
113630: PPUSH
113631: LD_VAR 0 13
113635: PPUSH
113636: CALL_OW 296
113640: PUSH
113641: LD_INT 30
113643: LESS
113644: AND
113645: IFFALSE 113661
// ComAttackUnit ( i , e ) ;
113647: LD_VAR 0 4
113651: PPUSH
113652: LD_VAR 0 13
113656: PPUSH
113657: CALL_OW 115
// end ; end ; end ;
113661: GO 113664
113663: POP
// if IsDead ( i ) then
113664: LD_VAR 0 4
113668: PPUSH
113669: CALL_OW 301
113673: IFFALSE 113691
// defenders := defenders diff i ;
113675: LD_ADDR_VAR 0 2
113679: PUSH
113680: LD_VAR 0 2
113684: PUSH
113685: LD_VAR 0 4
113689: DIFF
113690: ST_TO_ADDR
// end ;
113691: GO 112794
113693: POP
113694: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113695: LD_VAR 0 21
113699: NOT
113700: PUSH
113701: LD_VAR 0 2
113705: NOT
113706: OR
113707: PUSH
113708: LD_EXP 61
113712: PUSH
113713: LD_VAR 0 1
113717: ARRAY
113718: NOT
113719: OR
113720: IFFALSE 112698
// MC_Reset ( base , 18 ) ;
113722: LD_VAR 0 1
113726: PPUSH
113727: LD_INT 18
113729: PPUSH
113730: CALL 60496 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113734: LD_ADDR_VAR 0 2
113738: PUSH
113739: LD_VAR 0 2
113743: PUSH
113744: LD_VAR 0 2
113748: PPUSH
113749: LD_INT 2
113751: PUSH
113752: LD_INT 25
113754: PUSH
113755: LD_INT 1
113757: PUSH
113758: EMPTY
113759: LIST
113760: LIST
113761: PUSH
113762: LD_INT 25
113764: PUSH
113765: LD_INT 5
113767: PUSH
113768: EMPTY
113769: LIST
113770: LIST
113771: PUSH
113772: LD_INT 25
113774: PUSH
113775: LD_INT 8
113777: PUSH
113778: EMPTY
113779: LIST
113780: LIST
113781: PUSH
113782: LD_INT 25
113784: PUSH
113785: LD_INT 9
113787: PUSH
113788: EMPTY
113789: LIST
113790: LIST
113791: PUSH
113792: EMPTY
113793: LIST
113794: LIST
113795: LIST
113796: LIST
113797: LIST
113798: PPUSH
113799: CALL_OW 72
113803: DIFF
113804: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113805: LD_VAR 0 21
113809: NOT
113810: PUSH
113811: LD_VAR 0 2
113815: PPUSH
113816: LD_INT 21
113818: PUSH
113819: LD_INT 2
113821: PUSH
113822: EMPTY
113823: LIST
113824: LIST
113825: PPUSH
113826: CALL_OW 72
113830: AND
113831: IFFALSE 114169
// begin tmp := FilterByTag ( defenders , 19 ) ;
113833: LD_ADDR_VAR 0 11
113837: PUSH
113838: LD_VAR 0 2
113842: PPUSH
113843: LD_INT 19
113845: PPUSH
113846: CALL 49956 0 2
113850: ST_TO_ADDR
// if tmp then
113851: LD_VAR 0 11
113855: IFFALSE 113925
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
113857: LD_ADDR_VAR 0 11
113861: PUSH
113862: LD_VAR 0 11
113866: PPUSH
113867: LD_INT 25
113869: PUSH
113870: LD_INT 3
113872: PUSH
113873: EMPTY
113874: LIST
113875: LIST
113876: PPUSH
113877: CALL_OW 72
113881: ST_TO_ADDR
// if tmp then
113882: LD_VAR 0 11
113886: IFFALSE 113925
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113888: LD_ADDR_EXP 73
113892: PUSH
113893: LD_EXP 73
113897: PPUSH
113898: LD_VAR 0 1
113902: PPUSH
113903: LD_EXP 73
113907: PUSH
113908: LD_VAR 0 1
113912: ARRAY
113913: PUSH
113914: LD_VAR 0 11
113918: UNION
113919: PPUSH
113920: CALL_OW 1
113924: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113925: LD_VAR 0 1
113929: PPUSH
113930: LD_INT 19
113932: PPUSH
113933: CALL 60496 0 2
// repeat wait ( 0 0$1 ) ;
113937: LD_INT 35
113939: PPUSH
113940: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113944: LD_EXP 61
113948: PUSH
113949: LD_VAR 0 1
113953: ARRAY
113954: NOT
113955: PUSH
113956: LD_EXP 61
113960: PUSH
113961: LD_VAR 0 1
113965: ARRAY
113966: PUSH
113967: EMPTY
113968: EQUAL
113969: OR
113970: IFFALSE 114007
// begin for i in defenders do
113972: LD_ADDR_VAR 0 4
113976: PUSH
113977: LD_VAR 0 2
113981: PUSH
113982: FOR_IN
113983: IFFALSE 113996
// ComStop ( i ) ;
113985: LD_VAR 0 4
113989: PPUSH
113990: CALL_OW 141
113994: GO 113982
113996: POP
113997: POP
// defenders := [ ] ;
113998: LD_ADDR_VAR 0 2
114002: PUSH
114003: EMPTY
114004: ST_TO_ADDR
// exit ;
114005: GO 114233
// end ; for i in defenders do
114007: LD_ADDR_VAR 0 4
114011: PUSH
114012: LD_VAR 0 2
114016: PUSH
114017: FOR_IN
114018: IFFALSE 114107
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114020: LD_VAR 0 4
114024: PPUSH
114025: LD_EXP 85
114029: PUSH
114030: LD_VAR 0 1
114034: ARRAY
114035: PPUSH
114036: CALL_OW 308
114040: NOT
114041: IFFALSE 114065
// ComMoveToArea ( i , mc_parking [ base ] ) else
114043: LD_VAR 0 4
114047: PPUSH
114048: LD_EXP 85
114052: PUSH
114053: LD_VAR 0 1
114057: ARRAY
114058: PPUSH
114059: CALL_OW 113
114063: GO 114105
// if GetControl ( i ) = control_manual then
114065: LD_VAR 0 4
114069: PPUSH
114070: CALL_OW 263
114074: PUSH
114075: LD_INT 1
114077: EQUAL
114078: IFFALSE 114105
// if IsDrivenBy ( i ) then
114080: LD_VAR 0 4
114084: PPUSH
114085: CALL_OW 311
114089: IFFALSE 114105
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114091: LD_VAR 0 4
114095: PPUSH
114096: CALL_OW 311
114100: PPUSH
114101: CALL_OW 121
// end ;
114105: GO 114017
114107: POP
114108: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114109: LD_VAR 0 2
114113: PPUSH
114114: LD_INT 95
114116: PUSH
114117: LD_EXP 85
114121: PUSH
114122: LD_VAR 0 1
114126: ARRAY
114127: PUSH
114128: EMPTY
114129: LIST
114130: LIST
114131: PPUSH
114132: CALL_OW 72
114136: PUSH
114137: LD_VAR 0 2
114141: EQUAL
114142: PUSH
114143: LD_EXP 84
114147: PUSH
114148: LD_VAR 0 1
114152: ARRAY
114153: OR
114154: PUSH
114155: LD_EXP 61
114159: PUSH
114160: LD_VAR 0 1
114164: ARRAY
114165: NOT
114166: OR
114167: IFFALSE 113937
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114169: LD_ADDR_EXP 83
114173: PUSH
114174: LD_EXP 83
114178: PPUSH
114179: LD_VAR 0 1
114183: PPUSH
114184: LD_VAR 0 2
114188: PPUSH
114189: LD_INT 21
114191: PUSH
114192: LD_INT 2
114194: PUSH
114195: EMPTY
114196: LIST
114197: LIST
114198: PPUSH
114199: CALL_OW 72
114203: PPUSH
114204: CALL_OW 1
114208: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114209: LD_VAR 0 1
114213: PPUSH
114214: LD_INT 19
114216: PPUSH
114217: CALL 60496 0 2
// MC_Reset ( base , 20 ) ;
114221: LD_VAR 0 1
114225: PPUSH
114226: LD_INT 20
114228: PPUSH
114229: CALL 60496 0 2
// end ; end_of_file
114233: LD_VAR 0 3
114237: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114238: LD_VAR 0 1
114242: PUSH
114243: LD_INT 200
114245: DOUBLE
114246: GREATEREQUAL
114247: IFFALSE 114255
114249: LD_INT 299
114251: DOUBLE
114252: LESSEQUAL
114253: IFTRUE 114257
114255: GO 114289
114257: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114258: LD_VAR 0 1
114262: PPUSH
114263: LD_VAR 0 2
114267: PPUSH
114268: LD_VAR 0 3
114272: PPUSH
114273: LD_VAR 0 4
114277: PPUSH
114278: LD_VAR 0 5
114282: PPUSH
114283: CALL 103024 0 5
114287: GO 114366
114289: LD_INT 300
114291: DOUBLE
114292: GREATEREQUAL
114293: IFFALSE 114301
114295: LD_INT 399
114297: DOUBLE
114298: LESSEQUAL
114299: IFTRUE 114303
114301: GO 114365
114303: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114304: LD_VAR 0 1
114308: PPUSH
114309: LD_VAR 0 2
114313: PPUSH
114314: LD_VAR 0 3
114318: PPUSH
114319: LD_VAR 0 4
114323: PPUSH
114324: LD_VAR 0 5
114328: PPUSH
114329: LD_VAR 0 6
114333: PPUSH
114334: LD_VAR 0 7
114338: PPUSH
114339: LD_VAR 0 8
114343: PPUSH
114344: LD_VAR 0 9
114348: PPUSH
114349: LD_VAR 0 10
114353: PPUSH
114354: LD_VAR 0 11
114358: PPUSH
114359: CALL 99357 0 11
114363: GO 114366
114365: POP
// end ;
114366: PPOPN 11
114368: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114369: LD_VAR 0 1
114373: PPUSH
114374: LD_VAR 0 2
114378: PPUSH
114379: LD_VAR 0 3
114383: PPUSH
114384: LD_VAR 0 4
114388: PPUSH
114389: LD_VAR 0 5
114393: PPUSH
114394: CALL 102760 0 5
// end ; end_of_file
114398: PPOPN 5
114400: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114401: LD_VAR 0 1
114405: PPUSH
114406: LD_VAR 0 2
114410: PPUSH
114411: LD_VAR 0 3
114415: PPUSH
114416: LD_VAR 0 4
114420: PPUSH
114421: LD_VAR 0 5
114425: PPUSH
114426: LD_VAR 0 6
114430: PPUSH
114431: CALL 87050 0 6
// end ;
114435: PPOPN 6
114437: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114438: LD_INT 0
114440: PPUSH
// begin if not units then
114441: LD_VAR 0 1
114445: NOT
114446: IFFALSE 114450
// exit ;
114448: GO 114450
// end ;
114450: PPOPN 7
114452: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114453: CALL 87021 0 0
// end ;
114457: PPOPN 1
114459: END
