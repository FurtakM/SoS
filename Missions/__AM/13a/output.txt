// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60908 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 52205 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 52205 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 52205 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 52205 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4594 0 0
// PrepareRussian ;
 189: CALL 3007 0 0
// PrepareAlliance ;
 193: CALL 925 0 0
// MC_Start ( ) ;
 197: CALL 63088 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9382 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 85061 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 85506 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 85964 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 86241 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 85446 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 86144 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 85506 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 85964 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 86241 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 85290 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 86571 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 85446 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: IFFALSE 865
 850: PUSH
 851: LD_EXP 50
 855: PPUSH
 856: CALL_OW 255
 860: PUSH
 861: LD_INT 7
 863: EQUAL
 864: AND
 865: IFFALSE 878
 867: PUSH
 868: LD_EXP 51
 872: PPUSH
 873: CALL_OW 302
 877: AND
 878: IFFALSE 891
 880: PUSH
 881: LD_EXP 50
 885: PPUSH
 886: CALL_OW 302
 890: AND
 891: IFFALSE 903
 893: GO 895
 895: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 896: LD_STRING ACH_COMRADE
 898: PPUSH
 899: CALL_OW 543
 903: END
// every 0 0$1 trigger hack_counter >= 10 do
 904: LD_EXP 16
 908: PUSH
 909: LD_INT 10
 911: GREATEREQUAL
 912: IFFALSE 924
 914: GO 916
 916: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 917: LD_STRING ACH_HACK
 919: PPUSH
 920: CALL_OW 543
 924: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 925: LD_INT 0
 927: PPUSH
 928: PPUSH
 929: PPUSH
 930: PPUSH
// uc_side := 7 ;
 931: LD_ADDR_OWVAR 20
 935: PUSH
 936: LD_INT 7
 938: ST_TO_ADDR
// uc_nation := 1 ;
 939: LD_ADDR_OWVAR 21
 943: PUSH
 944: LD_INT 1
 946: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 947: LD_ADDR_EXP 17
 951: PUSH
 952: LD_STRING JMM
 954: PPUSH
 955: LD_EXP 1
 959: NOT
 960: PPUSH
 961: LD_STRING 12a_
 963: PPUSH
 964: CALL 17398 0 3
 968: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 71
 976: PPUSH
 977: LD_INT 23
 979: PPUSH
 980: LD_INT 0
 982: PPUSH
 983: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 987: LD_EXP 17
 991: PPUSH
 992: LD_INT 2
 994: PPUSH
 995: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 999: LD_ADDR_EXP 18
1003: PUSH
1004: LD_STRING Roth
1006: PPUSH
1007: LD_EXP 1
1011: NOT
1012: PPUSH
1013: LD_STRING 12a_
1015: PPUSH
1016: CALL 17398 0 3
1020: ST_TO_ADDR
// if Roth then
1021: LD_EXP 18
1025: IFFALSE 1045
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1027: LD_EXP 18
1031: PPUSH
1032: LD_INT 71
1034: PPUSH
1035: LD_INT 21
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 34
1049: PUSH
1050: LD_STRING Mike
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 17398 0 3
1066: ST_TO_ADDR
// if Mike then
1067: LD_EXP 34
1071: IFFALSE 1088
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1073: LD_EXP 34
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 19
1092: PUSH
1093: LD_STRING Lisa
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 17398 0 3
1109: ST_TO_ADDR
// if Lisa then
1110: LD_EXP 19
1114: IFFALSE 1131
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1116: LD_EXP 19
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 20
1135: PUSH
1136: LD_STRING Donaldson
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 17398 0 3
1152: ST_TO_ADDR
// if Donaldson then
1153: LD_EXP 20
1157: IFFALSE 1174
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1159: LD_EXP 20
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 21
1178: PUSH
1179: LD_STRING Bobby
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 17398 0 3
1195: ST_TO_ADDR
// if Bobby then
1196: LD_EXP 21
1200: IFFALSE 1217
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1202: LD_EXP 21
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 22
1221: PUSH
1222: LD_STRING Cyrus
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 17398 0 3
1238: ST_TO_ADDR
// if Cyrus then
1239: LD_EXP 22
1243: IFFALSE 1260
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1245: LD_EXP 22
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 23
1264: PUSH
1265: LD_STRING Denis
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 17398 0 3
1281: ST_TO_ADDR
// if Denis then
1282: LD_EXP 23
1286: IFFALSE 1303
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1288: LD_EXP 23
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 24
1307: PUSH
1308: LD_STRING Brown
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 17398 0 3
1324: ST_TO_ADDR
// if Brown then
1325: LD_EXP 24
1329: IFFALSE 1346
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1331: LD_EXP 24
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 25
1350: PUSH
1351: LD_STRING Gladstone
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 17398 0 3
1367: ST_TO_ADDR
// if Gladstone then
1368: LD_EXP 25
1372: IFFALSE 1389
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1374: LD_EXP 25
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 26
1393: PUSH
1394: LD_STRING Houten
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 17398 0 3
1410: ST_TO_ADDR
// if Houten then
1411: LD_EXP 26
1415: IFFALSE 1432
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1417: LD_EXP 26
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 27
1436: PUSH
1437: LD_STRING Cornell
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 17398 0 3
1453: ST_TO_ADDR
// if Cornel then
1454: LD_EXP 27
1458: IFFALSE 1475
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1460: LD_EXP 27
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1475: LD_ADDR_EXP 28
1479: PUSH
1480: LD_STRING Gary
1482: PPUSH
1483: LD_EXP 1
1487: NOT
1488: PPUSH
1489: LD_STRING 12a_
1491: PPUSH
1492: CALL 17398 0 3
1496: ST_TO_ADDR
// if Gary then
1497: LD_EXP 28
1501: IFFALSE 1518
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1503: LD_EXP 28
1507: PPUSH
1508: LD_INT 13
1510: PPUSH
1511: LD_INT 0
1513: PPUSH
1514: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1518: LD_ADDR_EXP 29
1522: PUSH
1523: LD_STRING Frank
1525: PPUSH
1526: LD_EXP 1
1530: NOT
1531: PPUSH
1532: LD_STRING 12a_
1534: PPUSH
1535: CALL 17398 0 3
1539: ST_TO_ADDR
// if Frank then
1540: LD_EXP 29
1544: IFFALSE 1561
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1546: LD_EXP 29
1550: PPUSH
1551: LD_INT 13
1553: PPUSH
1554: LD_INT 0
1556: PPUSH
1557: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1561: LD_ADDR_EXP 30
1565: PUSH
1566: LD_STRING Kikuchi
1568: PPUSH
1569: LD_EXP 1
1573: NOT
1574: PPUSH
1575: LD_STRING 12a_
1577: PPUSH
1578: CALL 17398 0 3
1582: ST_TO_ADDR
// if Kikuchi then
1583: LD_EXP 30
1587: IFFALSE 1604
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1589: LD_EXP 30
1593: PPUSH
1594: LD_INT 13
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1604: LD_ADDR_EXP 31
1608: PUSH
1609: LD_STRING Simms
1611: PPUSH
1612: LD_EXP 1
1616: NOT
1617: PPUSH
1618: LD_STRING 12a_
1620: PPUSH
1621: CALL 17398 0 3
1625: ST_TO_ADDR
// if Simms then
1626: LD_EXP 31
1630: IFFALSE 1647
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1632: LD_EXP 31
1636: PPUSH
1637: LD_INT 13
1639: PPUSH
1640: LD_INT 0
1642: PPUSH
1643: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1647: LD_ADDR_EXP 32
1651: PUSH
1652: LD_STRING Joan
1654: PPUSH
1655: LD_EXP 1
1659: NOT
1660: PPUSH
1661: LD_STRING 12a_
1663: PPUSH
1664: CALL 17398 0 3
1668: ST_TO_ADDR
// if Joan then
1669: LD_EXP 32
1673: IFFALSE 1690
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1675: LD_EXP 32
1679: PPUSH
1680: LD_INT 13
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1690: LD_ADDR_EXP 33
1694: PUSH
1695: LD_STRING DeltaDoctor
1697: PPUSH
1698: LD_EXP 1
1702: NOT
1703: PPUSH
1704: LD_STRING 12a_
1706: PPUSH
1707: CALL 17398 0 3
1711: ST_TO_ADDR
// if DeltaDoctor then
1712: LD_EXP 33
1716: IFFALSE 1733
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1718: LD_EXP 33
1722: PPUSH
1723: LD_INT 13
1725: PPUSH
1726: LD_INT 0
1728: PPUSH
1729: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1733: LD_ADDR_VAR 0 4
1737: PUSH
1738: LD_STRING 12a_others
1740: PPUSH
1741: CALL_OW 31
1745: ST_TO_ADDR
// if tmp then
1746: LD_VAR 0 4
1750: IFFALSE 1784
// for i in tmp do
1752: LD_ADDR_VAR 0 3
1756: PUSH
1757: LD_VAR 0 4
1761: PUSH
1762: FOR_IN
1763: IFFALSE 1782
// PlaceUnitArea ( i , alliance_start , false ) ;
1765: LD_VAR 0 3
1769: PPUSH
1770: LD_INT 13
1772: PPUSH
1773: LD_INT 0
1775: PPUSH
1776: CALL_OW 49
1780: GO 1762
1782: POP
1783: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 3
1789: PPUSH
1790: LD_INT 3
1792: PPUSH
1793: LD_INT 12
1795: PPUSH
1796: LD_INT 100
1798: PPUSH
1799: CALL 22384 0 5
// veh := CreateVehicle ;
1803: LD_ADDR_VAR 0 2
1807: PUSH
1808: CALL_OW 45
1812: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1813: LD_VAR 0 2
1817: PPUSH
1818: LD_INT 2
1820: PPUSH
1821: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1825: LD_VAR 0 2
1829: PPUSH
1830: LD_INT 60
1832: PPUSH
1833: LD_INT 6
1835: PPUSH
1836: LD_INT 0
1838: PPUSH
1839: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 4
1850: PPUSH
1851: LD_INT 30
1853: PPUSH
1854: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1858: LD_STRING 11_artifact_captured
1860: PPUSH
1861: LD_INT 0
1863: PPUSH
1864: CALL_OW 30
1868: IFFALSE 1944
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 3
1875: PPUSH
1876: LD_INT 3
1878: PPUSH
1879: LD_INT 12
1881: PPUSH
1882: LD_INT 100
1884: PPUSH
1885: CALL 22384 0 5
// veh := CreateVehicle ;
1889: LD_ADDR_VAR 0 2
1893: PUSH
1894: CALL_OW 45
1898: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1899: LD_VAR 0 2
1903: PPUSH
1904: LD_INT 3
1906: PPUSH
1907: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1911: LD_VAR 0 2
1915: PPUSH
1916: LD_INT 75
1918: PPUSH
1919: LD_INT 6
1921: PPUSH
1922: LD_INT 0
1924: PPUSH
1925: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1929: LD_VAR 0 2
1933: PPUSH
1934: LD_INT 4
1936: PPUSH
1937: LD_INT 50
1939: PPUSH
1940: CALL_OW 290
// end ; end ;
1944: LD_VAR 0 1
1948: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1949: LD_INT 0
1951: PPUSH
1952: PPUSH
1953: PPUSH
1954: PPUSH
// uc_side := 6 ;
1955: LD_ADDR_OWVAR 20
1959: PUSH
1960: LD_INT 6
1962: ST_TO_ADDR
// uc_nation := 3 ;
1963: LD_ADDR_OWVAR 21
1967: PUSH
1968: LD_INT 3
1970: ST_TO_ADDR
// InitHc ;
1971: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1975: LD_ADDR_EXP 35
1979: PUSH
1980: LD_STRING Gossudarov
1982: PPUSH
1983: CALL_OW 25
1987: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1988: LD_ADDR_EXP 36
1992: PUSH
1993: LD_STRING Kirilenkova
1995: PPUSH
1996: CALL_OW 25
2000: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
2001: LD_ADDR_EXP 37
2005: PUSH
2006: LD_STRING Titov
2008: PPUSH
2009: CALL_OW 25
2013: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2014: LD_ADDR_EXP 42
2018: PUSH
2019: LD_STRING Oblukov
2021: PPUSH
2022: CALL_OW 25
2026: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2027: LD_ADDR_EXP 39
2031: PUSH
2032: LD_STRING Dolgov
2034: PPUSH
2035: CALL_OW 25
2039: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2040: LD_ADDR_EXP 40
2044: PUSH
2045: LD_STRING Petrosyan
2047: PPUSH
2048: CALL_OW 25
2052: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2053: LD_ADDR_EXP 41
2057: PUSH
2058: LD_STRING Scholtze
2060: PPUSH
2061: CALL_OW 25
2065: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2066: LD_ADDR_EXP 43
2070: PUSH
2071: LD_STRING Kapitsova
2073: PPUSH
2074: CALL_OW 25
2078: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2079: LD_ADDR_VAR 0 2
2083: PUSH
2084: LD_EXP 35
2088: PUSH
2089: LD_EXP 36
2093: PUSH
2094: LD_EXP 37
2098: PUSH
2099: LD_EXP 42
2103: PUSH
2104: LD_EXP 39
2108: PUSH
2109: LD_EXP 40
2113: PUSH
2114: LD_EXP 41
2118: PUSH
2119: LD_EXP 43
2123: PUSH
2124: EMPTY
2125: LIST
2126: LIST
2127: LIST
2128: LIST
2129: LIST
2130: LIST
2131: LIST
2132: LIST
2133: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2134: LD_INT 1
2136: PPUSH
2137: LD_INT 4
2139: PPUSH
2140: LD_INT 8
2142: PPUSH
2143: CALL_OW 380
// un := CreateHuman ;
2147: LD_ADDR_VAR 0 4
2151: PUSH
2152: CALL_OW 44
2156: ST_TO_ADDR
// tmp := tmp ^ un ;
2157: LD_ADDR_VAR 0 2
2161: PUSH
2162: LD_VAR 0 2
2166: PUSH
2167: LD_VAR 0 4
2171: ADD
2172: ST_TO_ADDR
// for i in tmp do
2173: LD_ADDR_VAR 0 3
2177: PUSH
2178: LD_VAR 0 2
2182: PUSH
2183: FOR_IN
2184: IFFALSE 2203
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2186: LD_VAR 0 3
2190: PPUSH
2191: LD_INT 14
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
2201: GO 2183
2203: POP
2204: POP
// if freedom then
2205: LD_EXP 3
2209: IFFALSE 2242
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2211: LD_VAR 0 2
2215: PPUSH
2216: LD_EXP 3
2220: PPUSH
2221: CALL_OW 250
2225: PPUSH
2226: LD_EXP 3
2230: PPUSH
2231: CALL_OW 251
2235: PPUSH
2236: CALL_OW 111
2240: GO 2257
// ComMoveXY ( tmp , 70 , 48 ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 70
2249: PPUSH
2250: LD_INT 48
2252: PPUSH
2253: CALL_OW 111
// end ;
2257: LD_VAR 0 1
2261: RET
// export function PrepareBelkov ; begin
2262: LD_INT 0
2264: PPUSH
// uc_side := 4 ;
2265: LD_ADDR_OWVAR 20
2269: PUSH
2270: LD_INT 4
2272: ST_TO_ADDR
// uc_nation := 3 ;
2273: LD_ADDR_OWVAR 21
2277: PUSH
2278: LD_INT 3
2280: ST_TO_ADDR
// InitHc ;
2281: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2285: LD_ADDR_EXP 50
2289: PUSH
2290: LD_STRING Belkov
2292: PPUSH
2293: CALL_OW 25
2297: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2298: LD_EXP 50
2302: PPUSH
2303: LD_INT 14
2305: PPUSH
2306: LD_INT 0
2308: PPUSH
2309: CALL_OW 49
// end ;
2313: LD_VAR 0 1
2317: RET
// export function PrepareGnyevko ; begin
2318: LD_INT 0
2320: PPUSH
// uc_side := 4 ;
2321: LD_ADDR_OWVAR 20
2325: PUSH
2326: LD_INT 4
2328: ST_TO_ADDR
// uc_nation := 3 ;
2329: LD_ADDR_OWVAR 21
2333: PUSH
2334: LD_INT 3
2336: ST_TO_ADDR
// InitHc ;
2337: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2341: LD_ADDR_EXP 51
2345: PUSH
2346: LD_STRING Gnyevko
2348: PPUSH
2349: CALL_OW 25
2353: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2354: LD_EXP 51
2358: PPUSH
2359: LD_INT 14
2361: PPUSH
2362: LD_INT 0
2364: PPUSH
2365: CALL_OW 49
// end ;
2369: LD_VAR 0 1
2373: RET
// export function PrepareBurlak ; var i , tmp ; begin
2374: LD_INT 0
2376: PPUSH
2377: PPUSH
2378: PPUSH
// uc_side := 4 ;
2379: LD_ADDR_OWVAR 20
2383: PUSH
2384: LD_INT 4
2386: ST_TO_ADDR
// uc_nation := 3 ;
2387: LD_ADDR_OWVAR 21
2391: PUSH
2392: LD_INT 3
2394: ST_TO_ADDR
// InitHc ;
2395: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2399: LD_ADDR_EXP 49
2403: PUSH
2404: LD_STRING Burlak
2406: PPUSH
2407: CALL_OW 25
2411: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2412: LD_INT 24
2414: PUSH
2415: LD_INT 23
2417: PUSH
2418: LD_INT 22
2420: PUSH
2421: LD_INT 22
2423: PUSH
2424: EMPTY
2425: LIST
2426: LIST
2427: LIST
2428: LIST
2429: PUSH
2430: LD_OWVAR 67
2434: ARRAY
2435: PPUSH
2436: LD_INT 1
2438: PPUSH
2439: LD_INT 1
2441: PPUSH
2442: LD_INT 45
2444: PUSH
2445: LD_INT 44
2447: PUSH
2448: LD_INT 43
2450: PUSH
2451: LD_INT 42
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: PUSH
2460: LD_OWVAR 67
2464: ARRAY
2465: PPUSH
2466: LD_INT 0
2468: PPUSH
2469: CALL 22384 0 5
// Masha := CreateVehicle ;
2473: LD_ADDR_EXP 52
2477: PUSH
2478: CALL_OW 45
2482: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2483: LD_EXP 52
2487: PUSH
2488: LD_EXP 49
2492: PUSH
2493: EMPTY
2494: LIST
2495: LIST
2496: PPUSH
2497: LD_INT 499
2499: PPUSH
2500: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2504: LD_EXP 52
2508: PPUSH
2509: LD_INT 3
2511: PPUSH
2512: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2516: LD_EXP 52
2520: PPUSH
2521: LD_INT 1
2523: PPUSH
2524: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2528: LD_INT 1
2530: PPUSH
2531: LD_INT 18
2533: PPUSH
2534: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2538: LD_INT 35
2540: PPUSH
2541: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2545: LD_ADDR_VAR 0 3
2549: PUSH
2550: LD_INT 18
2552: PPUSH
2553: EMPTY
2554: PPUSH
2555: CALL_OW 70
2559: ST_TO_ADDR
// if tmp then
2560: LD_VAR 0 3
2564: IFFALSE 2598
// for i in tmp do
2566: LD_ADDR_VAR 0 2
2570: PUSH
2571: LD_VAR 0 3
2575: PUSH
2576: FOR_IN
2577: IFFALSE 2596
// ComMoveXY ( i , 114 , 9 ) ;
2579: LD_VAR 0 2
2583: PPUSH
2584: LD_INT 114
2586: PPUSH
2587: LD_INT 9
2589: PPUSH
2590: CALL_OW 111
2594: GO 2576
2596: POP
2597: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2598: LD_INT 18
2600: PPUSH
2601: EMPTY
2602: PPUSH
2603: CALL_OW 70
2607: NOT
2608: IFFALSE 2626
2610: PUSH
2611: LD_INT 123
2613: PPUSH
2614: LD_INT 3
2616: PPUSH
2617: CALL_OW 428
2621: PUSH
2622: LD_INT 0
2624: EQUAL
2625: AND
2626: IFFALSE 2538
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2628: LD_EXP 52
2632: PPUSH
2633: LD_INT 123
2635: PPUSH
2636: LD_INT 3
2638: PPUSH
2639: LD_INT 0
2641: PPUSH
2642: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2646: LD_EXP 49
2650: PPUSH
2651: LD_INT 125
2653: PPUSH
2654: LD_INT 1
2656: PPUSH
2657: LD_INT 0
2659: PPUSH
2660: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2664: LD_EXP 49
2668: PPUSH
2669: LD_EXP 52
2673: PPUSH
2674: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2678: LD_INT 10
2680: PPUSH
2681: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2685: LD_EXP 52
2689: PPUSH
2690: LD_INT 110
2692: PPUSH
2693: LD_INT 10
2695: PPUSH
2696: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2700: LD_ADDR_EXP 45
2704: PUSH
2705: LD_STRING Petrovova
2707: PPUSH
2708: CALL_OW 25
2712: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2713: LD_ADDR_EXP 47
2717: PUSH
2718: LD_STRING Kuzmov
2720: PPUSH
2721: CALL_OW 25
2725: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2726: LD_ADDR_EXP 46
2730: PUSH
2731: LD_STRING Kovalyuk
2733: PPUSH
2734: CALL_OW 25
2738: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2739: LD_ADDR_EXP 44
2743: PUSH
2744: LD_STRING Lipshchin
2746: PPUSH
2747: CALL_OW 25
2751: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2752: LD_ADDR_EXP 48
2756: PUSH
2757: LD_STRING Karamazov
2759: PPUSH
2760: CALL_OW 25
2764: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2765: LD_ADDR_VAR 0 3
2769: PUSH
2770: LD_EXP 45
2774: PUSH
2775: LD_EXP 47
2779: PUSH
2780: LD_EXP 46
2784: PUSH
2785: LD_EXP 44
2789: PUSH
2790: LD_EXP 48
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: LIST
2801: ST_TO_ADDR
// for i in tmp do
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 3
2811: PUSH
2812: FOR_IN
2813: IFFALSE 2852
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2815: LD_VAR 0 2
2819: PPUSH
2820: LD_INT 399
2822: PPUSH
2823: LD_INT 799
2825: PPUSH
2826: CALL_OW 12
2830: PPUSH
2831: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2835: LD_VAR 0 2
2839: PPUSH
2840: LD_INT 19
2842: PPUSH
2843: LD_INT 0
2845: PPUSH
2846: CALL_OW 49
// end ;
2850: GO 2812
2852: POP
2853: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2854: LD_VAR 0 3
2858: PPUSH
2859: LD_INT 112
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: CALL_OW 111
// AddComHold ( tmp ) ;
2869: LD_VAR 0 3
2873: PPUSH
2874: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2878: LD_ADDR_VAR 0 2
2882: PUSH
2883: LD_VAR 0 3
2887: PPUSH
2888: LD_INT 25
2890: PUSH
2891: LD_INT 1
2893: PUSH
2894: EMPTY
2895: LIST
2896: LIST
2897: PPUSH
2898: CALL_OW 72
2902: PUSH
2903: FOR_IN
2904: IFFALSE 2944
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2906: LD_VAR 0 2
2910: PPUSH
2911: LD_INT 20
2913: PPUSH
2914: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2918: LD_VAR 0 2
2922: PPUSH
2923: LD_INT 147
2925: PPUSH
2926: LD_INT 45
2928: PPUSH
2929: CALL_OW 178
// AddComCrawl ( i ) ;
2933: LD_VAR 0 2
2937: PPUSH
2938: CALL_OW 197
// end ;
2942: GO 2903
2944: POP
2945: POP
// repeat wait ( 0 0$1 ) ;
2946: LD_INT 35
2948: PPUSH
2949: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2953: LD_EXP 52
2957: PPUSH
2958: LD_INT 110
2960: PPUSH
2961: LD_INT 10
2963: PPUSH
2964: CALL_OW 307
2968: IFTRUE 2982
2970: PUSH
2971: LD_EXP 52
2975: PPUSH
2976: CALL_OW 305
2980: NOT
2981: OR
2982: IFFALSE 2946
// ComStop ( Burlak ) ;
2984: LD_EXP 49
2988: PPUSH
2989: CALL_OW 141
// AddComHold ( Burlak ) ;
2993: LD_EXP 49
2997: PPUSH
2998: CALL_OW 200
// end ; end_of_file
3002: LD_VAR 0 1
3006: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
3007: LD_INT 0
3009: PPUSH
3010: PPUSH
3011: PPUSH
3012: PPUSH
3013: PPUSH
// uc_side := 3 ;
3014: LD_ADDR_OWVAR 20
3018: PUSH
3019: LD_INT 3
3021: ST_TO_ADDR
// uc_nation := 3 ;
3022: LD_ADDR_OWVAR 21
3026: PUSH
3027: LD_INT 3
3029: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3030: LD_ADDR_EXP 53
3034: PUSH
3035: LD_INT 47
3037: PPUSH
3038: LD_INT 4
3040: PPUSH
3041: LD_STRING 
3043: PPUSH
3044: LD_INT 7
3046: PUSH
3047: LD_INT 8
3049: PUSH
3050: LD_INT 9
3052: PUSH
3053: LD_INT 10
3055: PUSH
3056: EMPTY
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: PUSH
3062: LD_OWVAR 67
3066: ARRAY
3067: PPUSH
3068: LD_INT 10000
3070: PUSH
3071: LD_INT 3000
3073: PUSH
3074: LD_INT 300
3076: PUSH
3077: EMPTY
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: LD_INT 9
3084: PUSH
3085: LD_INT 5
3087: PUSH
3088: LD_INT 6
3090: PUSH
3091: LD_INT 6
3093: PUSH
3094: EMPTY
3095: LIST
3096: LIST
3097: LIST
3098: LIST
3099: PPUSH
3100: CALL 26221 0 6
3104: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3105: LD_ADDR_EXP 63
3109: PUSH
3110: LD_EXP 63
3114: PPUSH
3115: LD_INT 2
3117: PPUSH
3118: LD_EXP 53
3122: PPUSH
3123: CALL_OW 1
3127: ST_TO_ADDR
// tmp := [ ] ;
3128: LD_ADDR_VAR 0 4
3132: PUSH
3133: EMPTY
3134: ST_TO_ADDR
// for i = 1 to 4 do
3135: LD_ADDR_VAR 0 2
3139: PUSH
3140: DOUBLE
3141: LD_INT 1
3143: DEC
3144: ST_TO_ADDR
3145: LD_INT 4
3147: PUSH
3148: FOR_TO
3149: IFFALSE 3242
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3151: LD_INT 22
3153: PPUSH
3154: LD_INT 3
3156: PPUSH
3157: LD_INT 3
3159: PPUSH
3160: LD_INT 43
3162: PUSH
3163: LD_INT 45
3165: PUSH
3166: LD_INT 45
3168: PUSH
3169: LD_INT 44
3171: PUSH
3172: EMPTY
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: PUSH
3178: LD_VAR 0 2
3182: PUSH
3183: LD_INT 4
3185: MOD
3186: PUSH
3187: LD_INT 1
3189: PLUS
3190: ARRAY
3191: PPUSH
3192: LD_INT 100
3194: PPUSH
3195: CALL 22384 0 5
// veh := CreateVehicle ;
3199: LD_ADDR_VAR 0 3
3203: PUSH
3204: CALL_OW 45
3208: ST_TO_ADDR
// tmp := tmp ^ veh ;
3209: LD_ADDR_VAR 0 4
3213: PUSH
3214: LD_VAR 0 4
3218: PUSH
3219: LD_VAR 0 3
3223: ADD
3224: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3225: LD_VAR 0 3
3229: PPUSH
3230: LD_INT 2
3232: PPUSH
3233: LD_INT 0
3235: PPUSH
3236: CALL_OW 49
// end ;
3240: GO 3148
3242: POP
3243: POP
// russian_guard := tmp ;
3244: LD_ADDR_EXP 54
3248: PUSH
3249: LD_VAR 0 4
3253: ST_TO_ADDR
// if Difficulty >= 3 then
3254: LD_OWVAR 67
3258: PUSH
3259: LD_INT 3
3261: GREATEREQUAL
3262: IFFALSE 3326
// begin bc_type := b_breastwork ;
3264: LD_ADDR_OWVAR 42
3268: PUSH
3269: LD_INT 31
3271: ST_TO_ADDR
// bc_level := 10 ;
3272: LD_ADDR_OWVAR 43
3276: PUSH
3277: LD_INT 10
3279: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3280: LD_ADDR_VAR 0 5
3284: PUSH
3285: LD_INT 96
3287: PPUSH
3288: LD_INT 105
3290: PPUSH
3291: LD_INT 3
3293: PPUSH
3294: CALL_OW 47
3298: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3299: LD_INT 0
3301: PPUSH
3302: LD_INT 9
3304: PPUSH
3305: LD_INT 10
3307: PPUSH
3308: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3312: CALL_OW 44
3316: PPUSH
3317: LD_VAR 0 5
3321: PPUSH
3322: CALL_OW 52
// end ; end ;
3326: LD_VAR 0 1
3330: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3331: LD_INT 47
3333: PPUSH
3334: CALL_OW 302
3338: IFFALSE 3346
3340: PUSH
3341: LD_EXP 7
3345: AND
3346: IFFALSE 4104
3348: GO 3350
3350: DISABLE
3351: LD_INT 0
3353: PPUSH
3354: PPUSH
3355: PPUSH
3356: PPUSH
3357: PPUSH
3358: PPUSH
3359: PPUSH
// begin enable ;
3360: ENABLE
// base := 2 ;
3361: LD_ADDR_VAR 0 3
3365: PUSH
3366: LD_INT 2
3368: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3369: LD_ADDR_VAR 0 4
3373: PUSH
3374: LD_INT 22
3376: PUSH
3377: LD_INT 1
3379: PUSH
3380: LD_INT 3
3382: PUSH
3383: LD_INT 45
3385: PUSH
3386: EMPTY
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: PUSH
3392: LD_INT 21
3394: PUSH
3395: LD_INT 1
3397: PUSH
3398: LD_INT 3
3400: PUSH
3401: LD_INT 45
3403: PUSH
3404: EMPTY
3405: LIST
3406: LIST
3407: LIST
3408: LIST
3409: PUSH
3410: LD_INT 22
3412: PUSH
3413: LD_INT 1
3415: PUSH
3416: LD_INT 3
3418: PUSH
3419: LD_INT 45
3421: PUSH
3422: EMPTY
3423: LIST
3424: LIST
3425: LIST
3426: LIST
3427: PUSH
3428: LD_INT 23
3430: PUSH
3431: LD_INT 1
3433: PUSH
3434: LD_INT 3
3436: PUSH
3437: LD_INT 46
3439: PUSH
3440: EMPTY
3441: LIST
3442: LIST
3443: LIST
3444: LIST
3445: PUSH
3446: EMPTY
3447: LIST
3448: LIST
3449: LIST
3450: LIST
3451: ST_TO_ADDR
// amount := Difficulty ;
3452: LD_ADDR_VAR 0 7
3456: PUSH
3457: LD_OWVAR 67
3461: ST_TO_ADDR
// if tick > 30 30$00 then
3462: LD_OWVAR 1
3466: PUSH
3467: LD_INT 63000
3469: GREATER
3470: IFFALSE 3507
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3472: LD_ADDR_VAR 0 7
3476: PUSH
3477: LD_VAR 0 7
3481: PUSH
3482: LD_INT 2
3484: PUSH
3485: LD_INT 3
3487: PUSH
3488: LD_INT 4
3490: PUSH
3491: LD_INT 4
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: LIST
3498: LIST
3499: PUSH
3500: LD_OWVAR 67
3504: ARRAY
3505: PLUS
3506: ST_TO_ADDR
// for i = 1 to amount do
3507: LD_ADDR_VAR 0 1
3511: PUSH
3512: DOUBLE
3513: LD_INT 1
3515: DEC
3516: ST_TO_ADDR
3517: LD_VAR 0 7
3521: PUSH
3522: FOR_TO
3523: IFFALSE 3611
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3525: LD_ADDR_VAR 0 4
3529: PUSH
3530: LD_VAR 0 4
3534: PPUSH
3535: LD_VAR 0 4
3539: PUSH
3540: LD_INT 1
3542: PLUS
3543: PPUSH
3544: LD_INT 23
3546: PUSH
3547: LD_INT 24
3549: PUSH
3550: EMPTY
3551: LIST
3552: LIST
3553: PUSH
3554: LD_INT 1
3556: PPUSH
3557: LD_INT 2
3559: PPUSH
3560: CALL_OW 12
3564: ARRAY
3565: PUSH
3566: LD_INT 1
3568: PUSH
3569: LD_INT 3
3571: PUSH
3572: LD_INT 46
3574: PUSH
3575: LD_INT 47
3577: PUSH
3578: LD_INT 45
3580: PUSH
3581: EMPTY
3582: LIST
3583: LIST
3584: LIST
3585: PUSH
3586: LD_INT 1
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: CALL_OW 12
3596: ARRAY
3597: PUSH
3598: EMPTY
3599: LIST
3600: LIST
3601: LIST
3602: LIST
3603: PPUSH
3604: CALL_OW 2
3608: ST_TO_ADDR
3609: GO 3522
3611: POP
3612: POP
// p := 1 ;
3613: LD_ADDR_VAR 0 2
3617: PUSH
3618: LD_INT 1
3620: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3621: LD_VAR 0 3
3625: PPUSH
3626: LD_VAR 0 4
3630: PPUSH
3631: CALL 85446 0 2
// repeat wait ( 0 0$1 ) ;
3635: LD_INT 35
3637: PPUSH
3638: CALL_OW 67
// p := Inc ( p ) ;
3642: LD_ADDR_VAR 0 2
3646: PUSH
3647: LD_VAR 0 2
3651: PPUSH
3652: CALL 56927 0 1
3656: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3657: LD_VAR 0 3
3661: PPUSH
3662: LD_INT 1
3664: PPUSH
3665: CALL 86902 0 2
3669: PUSH
3670: LD_VAR 0 7
3674: GREATEREQUAL
3675: IFTRUE 3687
3677: PUSH
3678: LD_VAR 0 2
3682: PUSH
3683: LD_INT 60
3685: GREATEREQUAL
3686: OR
3687: IFFALSE 3635
// wait ( 0 0$30 ) ;
3689: LD_INT 1050
3691: PPUSH
3692: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3696: LD_ADDR_VAR 0 5
3700: PUSH
3701: LD_INT 71
3703: PUSH
3704: LD_INT 19
3706: PUSH
3707: EMPTY
3708: LIST
3709: LIST
3710: PUSH
3711: LD_INT 91
3713: PUSH
3714: LD_INT 67
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 52
3723: PUSH
3724: LD_INT 44
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: LD_INT 68
3733: PUSH
3734: LD_INT 48
3736: PUSH
3737: EMPTY
3738: LIST
3739: LIST
3740: PUSH
3741: EMPTY
3742: LIST
3743: LIST
3744: LIST
3745: LIST
3746: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3747: LD_ADDR_VAR 0 6
3751: PUSH
3752: LD_INT 22
3754: PUSH
3755: LD_INT 3
3757: PUSH
3758: EMPTY
3759: LIST
3760: LIST
3761: PUSH
3762: LD_INT 21
3764: PUSH
3765: LD_INT 2
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 3
3774: PUSH
3775: LD_INT 2
3777: PUSH
3778: LD_INT 34
3780: PUSH
3781: LD_INT 52
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: PUSH
3788: LD_INT 34
3790: PUSH
3791: LD_INT 51
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: EMPTY
3799: LIST
3800: LIST
3801: LIST
3802: PUSH
3803: EMPTY
3804: LIST
3805: LIST
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: LIST
3811: PPUSH
3812: CALL_OW 69
3816: PUSH
3817: LD_EXP 85
3821: PUSH
3822: LD_VAR 0 3
3826: ARRAY
3827: DIFF
3828: ST_TO_ADDR
// if not attackers then
3829: LD_VAR 0 6
3833: NOT
3834: IFFALSE 3838
// exit ;
3836: GO 4104
// ru_attackers := attackers ;
3838: LD_ADDR_EXP 55
3842: PUSH
3843: LD_VAR 0 6
3847: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3848: LD_ADDR_EXP 82
3852: PUSH
3853: LD_EXP 82
3857: PPUSH
3858: LD_VAR 0 3
3862: PPUSH
3863: LD_EXP 82
3867: PUSH
3868: LD_VAR 0 3
3872: ARRAY
3873: PUSH
3874: LD_VAR 0 6
3878: DIFF
3879: PPUSH
3880: CALL_OW 1
3884: ST_TO_ADDR
// for i = 1 to attackers do
3885: LD_ADDR_VAR 0 1
3889: PUSH
3890: DOUBLE
3891: LD_INT 1
3893: DEC
3894: ST_TO_ADDR
3895: LD_VAR 0 6
3899: PUSH
3900: FOR_TO
3901: IFFALSE 3978
// begin case i mod 3 of 0 :
3903: LD_VAR 0 1
3907: PUSH
3908: LD_INT 3
3910: MOD
3911: PUSH
3912: LD_INT 0
3914: DOUBLE
3915: EQUAL
3916: IFTRUE 3920
3918: GO 3923
3920: POP
// ; 1 :
3921: GO 3976
3923: LD_INT 1
3925: DOUBLE
3926: EQUAL
3927: IFTRUE 3931
3929: GO 3949
3931: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3932: LD_VAR 0 1
3936: PPUSH
3937: LD_INT 32
3939: PPUSH
3940: LD_INT 49
3942: PPUSH
3943: CALL_OW 114
3947: GO 3976
3949: LD_INT 2
3951: DOUBLE
3952: EQUAL
3953: IFTRUE 3957
3955: GO 3975
3957: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3958: LD_VAR 0 1
3962: PPUSH
3963: LD_INT 117
3965: PPUSH
3966: LD_INT 107
3968: PPUSH
3969: CALL_OW 114
3973: GO 3976
3975: POP
// end ;
3976: GO 3900
3978: POP
3979: POP
// p := 0 ;
3980: LD_ADDR_VAR 0 2
3984: PUSH
3985: LD_INT 0
3987: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3988: LD_INT 35
3990: PPUSH
3991: CALL_OW 67
// p := Inc ( p ) ;
3995: LD_ADDR_VAR 0 2
3999: PUSH
4000: LD_VAR 0 2
4004: PPUSH
4005: CALL 56927 0 1
4009: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4010: LD_VAR 0 6
4014: PPUSH
4015: LD_INT 60
4017: PUSH
4018: EMPTY
4019: LIST
4020: PPUSH
4021: CALL_OW 72
4025: NOT
4026: IFTRUE 4038
4028: PUSH
4029: LD_VAR 0 2
4033: PUSH
4034: LD_INT 30
4036: GREATER
4037: OR
4038: IFFALSE 3988
// if not first_attack then
4040: LD_EXP 8
4044: NOT
4045: IFFALSE 4055
// first_attack := true ;
4047: LD_ADDR_EXP 8
4051: PUSH
4052: LD_INT 1
4054: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4055: LD_INT 35
4057: PPUSH
4058: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4062: LD_ADDR_VAR 0 6
4066: PUSH
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_INT 50
4074: PUSH
4075: EMPTY
4076: LIST
4077: PPUSH
4078: CALL_OW 72
4082: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4083: LD_VAR 0 6
4087: PPUSH
4088: LD_VAR 0 5
4092: PPUSH
4093: CALL 58320 0 2
// until not attackers ;
4097: LD_VAR 0 6
4101: NOT
4102: IFFALSE 4055
// end ;
4104: PPOPN 7
4106: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4107: LD_INT 0
4109: PPUSH
4110: PPUSH
4111: PPUSH
4112: PPUSH
4113: PPUSH
4114: PPUSH
// uc_side := 6 ;
4115: LD_ADDR_OWVAR 20
4119: PUSH
4120: LD_INT 6
4122: ST_TO_ADDR
// uc_nation := 3 ;
4123: LD_ADDR_OWVAR 21
4127: PUSH
4128: LD_INT 3
4130: ST_TO_ADDR
// InitHc ;
4131: CALL_OW 19
// InitVc ;
4135: CALL_OW 20
// tmp := [ ] ;
4139: LD_ADDR_VAR 0 3
4143: PUSH
4144: EMPTY
4145: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4146: LD_ADDR_VAR 0 2
4150: PUSH
4151: DOUBLE
4152: LD_INT 1
4154: DEC
4155: ST_TO_ADDR
4156: LD_INT 4
4158: PUSH
4159: LD_INT 5
4161: PUSH
4162: LD_INT 6
4164: PUSH
4165: LD_INT 7
4167: PUSH
4168: EMPTY
4169: LIST
4170: LIST
4171: LIST
4172: LIST
4173: PUSH
4174: LD_OWVAR 67
4178: ARRAY
4179: PUSH
4180: FOR_TO
4181: IFFALSE 4435
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4183: LD_ADDR_VAR 0 5
4187: PUSH
4188: LD_INT 21
4190: PUSH
4191: LD_INT 22
4193: PUSH
4194: LD_INT 24
4196: PUSH
4197: EMPTY
4198: LIST
4199: LIST
4200: LIST
4201: PUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 3
4207: PPUSH
4208: CALL_OW 12
4212: ARRAY
4213: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4214: LD_VAR 0 5
4218: PUSH
4219: LD_INT 21
4221: DOUBLE
4222: EQUAL
4223: IFTRUE 4233
4225: LD_INT 22
4227: DOUBLE
4228: EQUAL
4229: IFTRUE 4233
4231: GO 4267
4233: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4234: LD_ADDR_VAR 0 6
4238: PUSH
4239: LD_INT 45
4241: PUSH
4242: LD_INT 44
4244: PUSH
4245: LD_INT 43
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 3
4258: PPUSH
4259: CALL_OW 12
4263: ARRAY
4264: ST_TO_ADDR
4265: GO 4314
4267: LD_INT 24
4269: DOUBLE
4270: EQUAL
4271: IFTRUE 4275
4273: GO 4313
4275: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4276: LD_ADDR_VAR 0 6
4280: PUSH
4281: LD_INT 46
4283: PUSH
4284: LD_INT 47
4286: PUSH
4287: LD_INT 45
4289: PUSH
4290: LD_INT 46
4292: PUSH
4293: EMPTY
4294: LIST
4295: LIST
4296: LIST
4297: LIST
4298: PUSH
4299: LD_INT 1
4301: PPUSH
4302: LD_INT 4
4304: PPUSH
4305: CALL_OW 12
4309: ARRAY
4310: ST_TO_ADDR
4311: GO 4314
4313: POP
// uc_side := 6 ;
4314: LD_ADDR_OWVAR 20
4318: PUSH
4319: LD_INT 6
4321: ST_TO_ADDR
// uc_nation := 3 ;
4322: LD_ADDR_OWVAR 21
4326: PUSH
4327: LD_INT 3
4329: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4330: LD_VAR 0 5
4334: PPUSH
4335: LD_INT 1
4337: PUSH
4338: LD_INT 3
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: LD_INT 2
4350: PPUSH
4351: CALL_OW 12
4355: ARRAY
4356: PPUSH
4357: LD_INT 3
4359: PPUSH
4360: LD_VAR 0 6
4364: PPUSH
4365: LD_INT 70
4367: PPUSH
4368: LD_INT 90
4370: PPUSH
4371: CALL_OW 12
4375: PPUSH
4376: CALL 22384 0 5
// veh := CreateVehicle ;
4380: LD_ADDR_VAR 0 4
4384: PUSH
4385: CALL_OW 45
4389: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4390: LD_VAR 0 4
4394: PPUSH
4395: LD_INT 5
4397: PPUSH
4398: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4402: LD_VAR 0 4
4406: PPUSH
4407: LD_INT 16
4409: PPUSH
4410: LD_INT 0
4412: PPUSH
4413: CALL_OW 49
// tmp := tmp ^ veh ;
4417: LD_ADDR_VAR 0 3
4421: PUSH
4422: LD_VAR 0 3
4426: PUSH
4427: LD_VAR 0 4
4431: ADD
4432: ST_TO_ADDR
// end ;
4433: GO 4180
4435: POP
4436: POP
// if not tmp then
4437: LD_VAR 0 3
4441: NOT
4442: IFFALSE 4446
// exit ;
4444: GO 4540
// repeat wait ( 0 0$2 ) ;
4446: LD_INT 70
4448: PPUSH
4449: CALL_OW 67
// for i in tmp do
4453: LD_ADDR_VAR 0 2
4457: PUSH
4458: LD_VAR 0 3
4462: PUSH
4463: FOR_IN
4464: IFFALSE 4531
// if IsOk ( i ) then
4466: LD_VAR 0 2
4470: PPUSH
4471: CALL_OW 302
4475: IFFALSE 4513
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4477: LD_VAR 0 2
4481: PPUSH
4482: LD_INT 22
4484: PUSH
4485: LD_INT 7
4487: PUSH
4488: EMPTY
4489: LIST
4490: LIST
4491: PPUSH
4492: CALL_OW 69
4496: PPUSH
4497: LD_VAR 0 2
4501: PPUSH
4502: CALL_OW 74
4506: PPUSH
4507: CALL_OW 115
4511: GO 4529
// tmp := tmp diff i ;
4513: LD_ADDR_VAR 0 3
4517: PUSH
4518: LD_VAR 0 3
4522: PUSH
4523: LD_VAR 0 2
4527: DIFF
4528: ST_TO_ADDR
4529: GO 4463
4531: POP
4532: POP
// until not tmp ;
4533: LD_VAR 0 3
4537: NOT
4538: IFFALSE 4446
// end ;
4540: LD_VAR 0 1
4544: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4545: LD_EXP 8
4549: IFFALSE 4560
4551: PUSH
4552: LD_INT 47
4554: PPUSH
4555: CALL_OW 302
4559: AND
4560: IFFALSE 4575
4562: PUSH
4563: LD_INT 47
4565: PPUSH
4566: CALL_OW 255
4570: PUSH
4571: LD_INT 3
4573: EQUAL
4574: AND
4575: IFFALSE 4583
4577: PUSH
4578: LD_EXP 6
4582: AND
4583: IFFALSE 4593
4585: GO 4587
4587: DISABLE
// begin enable ;
4588: ENABLE
// PrepareRussianAttack ;
4589: CALL 4107 0 0
// end ; end_of_file
4593: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4594: LD_INT 0
4596: PPUSH
4597: PPUSH
4598: PPUSH
4599: PPUSH
4600: PPUSH
4601: PPUSH
4602: PPUSH
4603: PPUSH
4604: PPUSH
// uc_side := 2 ;
4605: LD_ADDR_OWVAR 20
4609: PUSH
4610: LD_INT 2
4612: ST_TO_ADDR
// uc_nation := 2 ;
4613: LD_ADDR_OWVAR 21
4617: PUSH
4618: LD_INT 2
4620: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4621: LD_INT 2
4623: PPUSH
4624: LD_INT 28
4626: PPUSH
4627: CALL 60675 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4631: LD_INT 25
4633: PPUSH
4634: LD_INT 0
4636: PUSH
4637: LD_INT 0
4639: PUSH
4640: LD_INT 6
4642: PUSH
4643: LD_INT 8
4645: PUSH
4646: EMPTY
4647: LIST
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: PPUSH
4658: CALL 8161 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4662: LD_INT 26
4664: PPUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 4
4670: PUSH
4671: LD_INT 8
4673: PUSH
4674: LD_INT 12
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: LIST
4681: LIST
4682: PUSH
4683: LD_OWVAR 67
4687: ARRAY
4688: PPUSH
4689: CALL 8161 0 2
// if Difficulty > 2 then
4693: LD_OWVAR 67
4697: PUSH
4698: LD_INT 2
4700: GREATER
4701: IFFALSE 4871
// begin bc_type := b_breastwork ;
4703: LD_ADDR_OWVAR 42
4707: PUSH
4708: LD_INT 31
4710: ST_TO_ADDR
// bc_level := 8 ;
4711: LD_ADDR_OWVAR 43
4715: PUSH
4716: LD_INT 8
4718: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4719: LD_ADDR_VAR 0 5
4723: PUSH
4724: LD_INT 27
4726: PUSH
4727: LD_INT 29
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: FOR_IN
4735: IFFALSE 4869
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4737: LD_ADDR_VAR 0 6
4741: PUSH
4742: LD_VAR 0 5
4746: PPUSH
4747: LD_INT 1
4749: PPUSH
4750: CALL 60273 0 2
4754: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4755: LD_ADDR_VAR 0 3
4759: PUSH
4760: LD_VAR 0 6
4764: PUSH
4765: LD_INT 1
4767: ARRAY
4768: PPUSH
4769: LD_VAR 0 6
4773: PUSH
4774: LD_INT 2
4776: ARRAY
4777: PPUSH
4778: LD_VAR 0 6
4782: PUSH
4783: LD_INT 3
4785: ARRAY
4786: PPUSH
4787: CALL_OW 47
4791: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4792: LD_INT 0
4794: PPUSH
4795: LD_INT 5
4797: PUSH
4798: LD_OWVAR 67
4802: PLUS
4803: PPUSH
4804: CALL_OW 381
// un := CreateHuman ;
4808: LD_ADDR_VAR 0 8
4812: PUSH
4813: CALL_OW 44
4817: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4818: LD_VAR 0 8
4822: PPUSH
4823: LD_VAR 0 3
4827: PPUSH
4828: CALL_OW 254
4832: PUSH
4833: LD_INT 3
4835: MINUS
4836: PPUSH
4837: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4841: LD_VAR 0 8
4845: PPUSH
4846: LD_INT 5
4848: PPUSH
4849: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4853: LD_VAR 0 8
4857: PPUSH
4858: LD_VAR 0 3
4862: PPUSH
4863: CALL_OW 52
// end ;
4867: GO 4734
4869: POP
4870: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4871: LD_ADDR_EXP 58
4875: PUSH
4876: LD_STRING Abdul
4878: PPUSH
4879: CALL_OW 25
4883: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4884: LD_EXP 58
4888: PPUSH
4889: LD_INT 11
4891: PPUSH
4892: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4896: LD_EXP 58
4900: PPUSH
4901: LD_INT 1
4903: PPUSH
4904: CALL_OW 52
// vc_chassis := 31 ;
4908: LD_ADDR_OWVAR 37
4912: PUSH
4913: LD_INT 31
4915: ST_TO_ADDR
// vc_control := control_rider ;
4916: LD_ADDR_OWVAR 38
4920: PUSH
4921: LD_INT 4
4923: ST_TO_ADDR
// mastodont := CreateVehicle ;
4924: LD_ADDR_EXP 59
4928: PUSH
4929: CALL_OW 45
4933: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4934: LD_EXP 59
4938: PPUSH
4939: LD_INT 153
4941: PPUSH
4942: LD_INT 71
4944: PPUSH
4945: LD_INT 0
4947: PPUSH
4948: CALL_OW 48
// InitVc ;
4952: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4956: LD_ADDR_EXP 56
4960: PUSH
4961: LD_INT 1
4963: PPUSH
4964: LD_INT 3
4966: PPUSH
4967: LD_STRING kaba
4969: PPUSH
4970: LD_INT 7
4972: PUSH
4973: LD_INT 8
4975: PUSH
4976: LD_INT 9
4978: PUSH
4979: LD_INT 10
4981: PUSH
4982: EMPTY
4983: LIST
4984: LIST
4985: LIST
4986: LIST
4987: PUSH
4988: LD_OWVAR 67
4992: ARRAY
4993: PPUSH
4994: LD_INT 5000
4996: PUSH
4997: LD_INT 1000
4999: PUSH
5000: LD_INT 300
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: LIST
5007: PPUSH
5008: LD_INT 11
5010: PUSH
5011: LD_INT 5
5013: PUSH
5014: LD_INT 6
5016: PUSH
5017: LD_INT 7
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: LIST
5024: LIST
5025: PPUSH
5026: CALL 26221 0 6
5030: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5031: LD_ADDR_EXP 63
5035: PUSH
5036: LD_EXP 63
5040: PPUSH
5041: LD_INT 1
5043: PPUSH
5044: LD_EXP 56
5048: PPUSH
5049: CALL_OW 1
5053: ST_TO_ADDR
// tmp := [ ] ;
5054: LD_ADDR_VAR 0 6
5058: PUSH
5059: EMPTY
5060: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5061: LD_ADDR_OWVAR 37
5065: PUSH
5066: LD_INT 13
5068: ST_TO_ADDR
// vc_engine := engine_siberite ;
5069: LD_ADDR_OWVAR 39
5073: PUSH
5074: LD_INT 3
5076: ST_TO_ADDR
// vc_control := control_manual ;
5077: LD_ADDR_OWVAR 38
5081: PUSH
5082: LD_INT 1
5084: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5085: LD_ADDR_OWVAR 40
5089: PUSH
5090: LD_INT 31
5092: ST_TO_ADDR
// for i = 1 to 3 do
5093: LD_ADDR_VAR 0 2
5097: PUSH
5098: DOUBLE
5099: LD_INT 1
5101: DEC
5102: ST_TO_ADDR
5103: LD_INT 3
5105: PUSH
5106: FOR_TO
5107: IFFALSE 5355
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5109: LD_ADDR_VAR 0 7
5113: PUSH
5114: LD_INT 153
5116: PUSH
5117: LD_INT 71
5119: PUSH
5120: EMPTY
5121: LIST
5122: LIST
5123: PUSH
5124: LD_INT 155
5126: PUSH
5127: LD_INT 81
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: PUSH
5134: EMPTY
5135: LIST
5136: LIST
5137: PUSH
5138: LD_VAR 0 2
5142: PUSH
5143: LD_INT 2
5145: MOD
5146: PUSH
5147: LD_INT 1
5149: PLUS
5150: ARRAY
5151: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5152: LD_INT 0
5154: PPUSH
5155: LD_INT 3
5157: PPUSH
5158: LD_INT 7
5160: PUSH
5161: LD_INT 8
5163: PUSH
5164: LD_INT 10
5166: PUSH
5167: LD_INT 10
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_OWVAR 67
5180: ARRAY
5181: PPUSH
5182: CALL_OW 380
// un := CreateVehicle ;
5186: LD_ADDR_VAR 0 8
5190: PUSH
5191: CALL_OW 45
5195: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5196: LD_VAR 0 8
5200: PPUSH
5201: LD_INT 0
5203: PPUSH
5204: LD_INT 5
5206: PPUSH
5207: CALL_OW 12
5211: PPUSH
5212: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5216: LD_VAR 0 8
5220: PPUSH
5221: LD_VAR 0 7
5225: PUSH
5226: LD_INT 1
5228: ARRAY
5229: PPUSH
5230: LD_VAR 0 7
5234: PUSH
5235: LD_INT 2
5237: ARRAY
5238: PPUSH
5239: LD_INT 6
5241: PPUSH
5242: LD_INT 0
5244: PPUSH
5245: CALL_OW 50
// un2 := CreateHuman ;
5249: LD_ADDR_VAR 0 9
5253: PUSH
5254: CALL_OW 44
5258: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5259: LD_VAR 0 9
5263: PPUSH
5264: LD_VAR 0 8
5268: PPUSH
5269: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5273: LD_ADDR_EXP 63
5277: PUSH
5278: LD_EXP 63
5282: PPUSH
5283: LD_INT 1
5285: PUSH
5286: LD_EXP 63
5290: PUSH
5291: LD_INT 1
5293: ARRAY
5294: PUSH
5295: LD_INT 1
5297: PLUS
5298: PUSH
5299: EMPTY
5300: LIST
5301: LIST
5302: PPUSH
5303: LD_VAR 0 8
5307: PPUSH
5308: CALL 22506 0 3
5312: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5313: LD_ADDR_EXP 63
5317: PUSH
5318: LD_EXP 63
5322: PPUSH
5323: LD_INT 1
5325: PUSH
5326: LD_EXP 63
5330: PUSH
5331: LD_INT 1
5333: ARRAY
5334: PUSH
5335: LD_INT 1
5337: PLUS
5338: PUSH
5339: EMPTY
5340: LIST
5341: LIST
5342: PPUSH
5343: LD_VAR 0 9
5347: PPUSH
5348: CALL 22506 0 3
5352: ST_TO_ADDR
// end ;
5353: GO 5106
5355: POP
5356: POP
// for i = 1 to 5 do
5357: LD_ADDR_VAR 0 2
5361: PUSH
5362: DOUBLE
5363: LD_INT 1
5365: DEC
5366: ST_TO_ADDR
5367: LD_INT 5
5369: PUSH
5370: FOR_TO
5371: IFFALSE 5464
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5373: LD_INT 13
5375: PPUSH
5376: LD_INT 3
5378: PPUSH
5379: LD_INT 1
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 28
5387: PUSH
5388: LD_INT 28
5390: PUSH
5391: LD_INT 26
5393: PUSH
5394: EMPTY
5395: LIST
5396: LIST
5397: LIST
5398: LIST
5399: PUSH
5400: LD_VAR 0 2
5404: PUSH
5405: LD_INT 4
5407: MOD
5408: PUSH
5409: LD_INT 1
5411: PLUS
5412: ARRAY
5413: PPUSH
5414: LD_INT 100
5416: PPUSH
5417: CALL 22384 0 5
// veh := CreateVehicle ;
5421: LD_ADDR_VAR 0 4
5425: PUSH
5426: CALL_OW 45
5430: ST_TO_ADDR
// tmp := tmp ^ veh ;
5431: LD_ADDR_VAR 0 6
5435: PUSH
5436: LD_VAR 0 6
5440: PUSH
5441: LD_VAR 0 4
5445: ADD
5446: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5447: LD_VAR 0 4
5451: PPUSH
5452: LD_INT 1
5454: PPUSH
5455: LD_INT 0
5457: PPUSH
5458: CALL_OW 49
// end ;
5462: GO 5370
5464: POP
5465: POP
// arabian_guard := tmp ;
5466: LD_ADDR_EXP 57
5470: PUSH
5471: LD_VAR 0 6
5475: ST_TO_ADDR
// end ;
5476: LD_VAR 0 1
5480: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5481: LD_INT 22
5483: PUSH
5484: LD_INT 7
5486: PUSH
5487: EMPTY
5488: LIST
5489: LIST
5490: PUSH
5491: LD_INT 91
5493: PUSH
5494: LD_INT 1
5496: PUSH
5497: LD_INT 12
5499: PUSH
5500: EMPTY
5501: LIST
5502: LIST
5503: LIST
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PPUSH
5509: CALL_OW 69
5513: IFTRUE 5530
5515: PUSH
5516: LD_EXP 59
5520: PPUSH
5521: CALL_OW 256
5525: PUSH
5526: LD_INT 990
5528: LESS
5529: OR
5530: IFTRUE 5547
5532: PUSH
5533: LD_EXP 58
5537: PPUSH
5538: CALL_OW 256
5542: PUSH
5543: LD_INT 990
5545: LESS
5546: OR
5547: IFFALSE 5692
5549: GO 5551
5551: DISABLE
// begin if IsInUnit ( Abdul ) then
5552: LD_EXP 58
5556: PPUSH
5557: CALL_OW 310
5561: IFFALSE 5572
// ComExitBuilding ( Abdul ) ;
5563: LD_EXP 58
5567: PPUSH
5568: CALL_OW 122
// if Mastodont then
5572: LD_EXP 59
5576: IFFALSE 5593
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5578: LD_EXP 59
5582: PPUSH
5583: LD_INT 205
5585: PPUSH
5586: LD_INT 132
5588: PPUSH
5589: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5593: LD_EXP 58
5597: PPUSH
5598: LD_INT 205
5600: PPUSH
5601: LD_INT 132
5603: PPUSH
5604: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5608: LD_INT 35
5610: PPUSH
5611: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5615: LD_EXP 58
5619: PPUSH
5620: LD_INT 21
5622: PPUSH
5623: CALL_OW 308
5627: IFFALSE 5608
// RemoveUnit ( Abdul ) ;
5629: LD_EXP 58
5633: PPUSH
5634: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5638: LD_INT 35
5640: PPUSH
5641: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5645: LD_EXP 59
5649: PPUSH
5650: LD_INT 21
5652: PPUSH
5653: CALL_OW 308
5657: IFTRUE 5670
5659: PUSH
5660: LD_EXP 59
5664: PPUSH
5665: CALL_OW 301
5669: OR
5670: IFFALSE 5638
// if IsOk ( Mastodont ) then
5672: LD_EXP 59
5676: PPUSH
5677: CALL_OW 302
5681: IFFALSE 5692
// RemoveUnit ( Mastodont ) ;
5683: LD_EXP 59
5687: PPUSH
5688: CALL_OW 64
// end ;
5692: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5693: LD_EXP 58
5697: PPUSH
5698: CALL_OW 301
5702: IFTRUE 5810
5704: PUSH
5705: LD_INT 22
5707: PUSH
5708: LD_INT 2
5710: PUSH
5711: EMPTY
5712: LIST
5713: LIST
5714: PUSH
5715: LD_INT 2
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 1
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 2
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: LD_INT 25
5740: PUSH
5741: LD_INT 3
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 25
5750: PUSH
5751: LD_INT 4
5753: PUSH
5754: EMPTY
5755: LIST
5756: LIST
5757: PUSH
5758: LD_INT 25
5760: PUSH
5761: LD_INT 8
5763: PUSH
5764: EMPTY
5765: LIST
5766: LIST
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: LIST
5773: LIST
5774: LIST
5775: PUSH
5776: EMPTY
5777: LIST
5778: LIST
5779: PPUSH
5780: CALL_OW 69
5784: PUSH
5785: LD_INT 16
5787: PUSH
5788: LD_INT 19
5790: PUSH
5791: LD_INT 22
5793: PUSH
5794: LD_INT 22
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: LESS
5809: OR
5810: IFFALSE 6483
5812: GO 5814
5814: DISABLE
5815: LD_INT 0
5817: PPUSH
5818: PPUSH
5819: PPUSH
5820: PPUSH
5821: PPUSH
5822: PPUSH
// begin MC_Kill ( 1 ) ;
5823: LD_INT 1
5825: PPUSH
5826: CALL 61165 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: LD_INT 22
5837: PUSH
5838: LD_INT 2
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: LD_INT 2
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 1
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 2
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 25
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: EMPTY
5875: LIST
5876: LIST
5877: PUSH
5878: LD_INT 25
5880: PUSH
5881: LD_INT 4
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 25
5890: PUSH
5891: LD_INT 8
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: PPUSH
5910: CALL_OW 69
5914: ST_TO_ADDR
// for i in tmp do
5915: LD_ADDR_VAR 0 5
5919: PUSH
5920: LD_VAR 0 2
5924: PUSH
5925: FOR_IN
5926: IFFALSE 5942
// SetTag ( i , 10 ) ;
5928: LD_VAR 0 5
5932: PPUSH
5933: LD_INT 10
5935: PPUSH
5936: CALL_OW 109
5940: GO 5925
5942: POP
5943: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5944: LD_ADDR_VAR 0 3
5948: PUSH
5949: LD_INT 22
5951: PUSH
5952: LD_INT 2
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: PUSH
5959: LD_INT 21
5961: PUSH
5962: LD_INT 1
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: EMPTY
5970: LIST
5971: LIST
5972: PPUSH
5973: CALL_OW 69
5977: PUSH
5978: LD_VAR 0 2
5982: DIFF
5983: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5984: LD_ADDR_VAR 0 1
5988: PUSH
5989: LD_INT 22
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 21
6001: PUSH
6002: LD_INT 2
6004: PUSH
6005: EMPTY
6006: LIST
6007: LIST
6008: PUSH
6009: LD_INT 24
6011: PUSH
6012: LD_INT 300
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 69
6028: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
6029: LD_ADDR_VAR 0 4
6033: PUSH
6034: LD_VAR 0 1
6038: PPUSH
6039: LD_INT 33
6041: PUSH
6042: LD_INT 1
6044: PUSH
6045: EMPTY
6046: LIST
6047: LIST
6048: PUSH
6049: LD_INT 58
6051: PUSH
6052: EMPTY
6053: LIST
6054: PUSH
6055: EMPTY
6056: LIST
6057: LIST
6058: PPUSH
6059: CALL_OW 72
6063: ST_TO_ADDR
// for i in tmp do
6064: LD_ADDR_VAR 0 5
6068: PUSH
6069: LD_VAR 0 2
6073: PUSH
6074: FOR_IN
6075: IFFALSE 6259
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6077: LD_VAR 0 5
6081: PUSH
6082: LD_INT 55
6084: PUSH
6085: EMPTY
6086: LIST
6087: PPUSH
6088: CALL_OW 69
6092: IN
6093: IFFALSE 6112
// begin AddComMoveXY ( i , 209 , 132 ) ;
6095: LD_VAR 0 5
6099: PPUSH
6100: LD_INT 209
6102: PPUSH
6103: LD_INT 132
6105: PPUSH
6106: CALL_OW 171
// continue ;
6110: GO 6074
// end ; if IsInUnit ( i ) then
6112: LD_VAR 0 5
6116: PPUSH
6117: CALL_OW 310
6121: IFFALSE 6139
// begin ComExitBuilding ( i ) ;
6123: LD_VAR 0 5
6127: PPUSH
6128: CALL_OW 122
// wait ( 3 ) ;
6132: LD_INT 3
6134: PPUSH
6135: CALL_OW 67
// end ; if tmp_empty then
6139: LD_VAR 0 4
6143: IFFALSE 6242
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6145: LD_VAR 0 5
6149: PPUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: PPUSH
6165: CALL_OW 296
6169: PUSH
6170: LD_INT 25
6172: LESS
6173: IFFALSE 6242
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6175: LD_ADDR_VAR 0 6
6179: PUSH
6180: LD_VAR 0 4
6184: PPUSH
6185: LD_VAR 0 5
6189: PPUSH
6190: CALL_OW 74
6194: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6195: LD_VAR 0 5
6199: PPUSH
6200: LD_VAR 0 6
6204: PPUSH
6205: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6209: LD_VAR 0 5
6213: PPUSH
6214: LD_INT 209
6216: PPUSH
6217: LD_INT 132
6219: PPUSH
6220: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6224: LD_ADDR_VAR 0 4
6228: PUSH
6229: LD_VAR 0 4
6233: PUSH
6234: LD_VAR 0 6
6238: DIFF
6239: ST_TO_ADDR
// continue ;
6240: GO 6074
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6242: LD_VAR 0 5
6246: PPUSH
6247: LD_INT 201
6249: PPUSH
6250: LD_INT 132
6252: PPUSH
6253: CALL_OW 171
// end ;
6257: GO 6074
6259: POP
6260: POP
// for i in tmp_ape do
6261: LD_ADDR_VAR 0 5
6265: PUSH
6266: LD_VAR 0 3
6270: PUSH
6271: FOR_IN
6272: IFFALSE 6311
// begin if IsInUnit ( i ) then
6274: LD_VAR 0 5
6278: PPUSH
6279: CALL_OW 310
6283: IFFALSE 6294
// ComExitBuilding ( i ) ;
6285: LD_VAR 0 5
6289: PPUSH
6290: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6294: LD_VAR 0 5
6298: PPUSH
6299: LD_INT 201
6301: PPUSH
6302: LD_INT 132
6304: PPUSH
6305: CALL_OW 171
// end ;
6309: GO 6271
6311: POP
6312: POP
// repeat wait ( 0 0$1 ) ;
6313: LD_INT 35
6315: PPUSH
6316: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6320: LD_ADDR_VAR 0 5
6324: PUSH
6325: LD_VAR 0 2
6329: PUSH
6330: LD_VAR 0 3
6334: UNION
6335: PUSH
6336: LD_VAR 0 1
6340: UNION
6341: PUSH
6342: FOR_IN
6343: IFFALSE 6374
// if not HasTask ( i ) then
6345: LD_VAR 0 5
6349: PPUSH
6350: CALL_OW 314
6354: NOT
6355: IFFALSE 6372
// ComMoveXY ( i , 201 , 132 ) ;
6357: LD_VAR 0 5
6361: PPUSH
6362: LD_INT 201
6364: PPUSH
6365: LD_INT 132
6367: PPUSH
6368: CALL_OW 111
6372: GO 6342
6374: POP
6375: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6376: LD_INT 21
6378: PPUSH
6379: LD_INT 22
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: EMPTY
6386: LIST
6387: LIST
6388: PPUSH
6389: CALL_OW 70
6393: IFFALSE 6434
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6395: LD_ADDR_VAR 0 5
6399: PUSH
6400: LD_INT 21
6402: PPUSH
6403: LD_INT 22
6405: PUSH
6406: LD_INT 2
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 70
6417: PUSH
6418: FOR_IN
6419: IFFALSE 6432
// RemoveUnit ( i ) ;
6421: LD_VAR 0 5
6425: PPUSH
6426: CALL_OW 64
6430: GO 6418
6432: POP
6433: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6434: LD_INT 22
6436: PUSH
6437: LD_INT 2
6439: PUSH
6440: EMPTY
6441: LIST
6442: LIST
6443: PUSH
6444: LD_INT 2
6446: PUSH
6447: LD_INT 21
6449: PUSH
6450: LD_INT 1
6452: PUSH
6453: EMPTY
6454: LIST
6455: LIST
6456: PUSH
6457: LD_INT 21
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: EMPTY
6464: LIST
6465: LIST
6466: PUSH
6467: EMPTY
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PPUSH
6476: CALL_OW 69
6480: NOT
6481: IFFALSE 6313
// end ;
6483: PPOPN 6
6485: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6486: LD_EXP 10
6490: IFFALSE 6513
6492: PUSH
6493: LD_INT 92
6495: PPUSH
6496: LD_INT 40
6498: PPUSH
6499: CALL_OW 428
6503: PPUSH
6504: CALL_OW 266
6508: PUSH
6509: LD_INT 30
6511: EQUAL
6512: AND
6513: IFFALSE 6709
6515: GO 6517
6517: DISABLE
6518: LD_INT 0
6520: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6521: LD_ADDR_VAR 0 1
6525: PUSH
6526: LD_EXP 63
6530: PUSH
6531: LD_INT 1
6533: ARRAY
6534: PPUSH
6535: LD_INT 25
6537: PUSH
6538: LD_INT 4
6540: PUSH
6541: EMPTY
6542: LIST
6543: LIST
6544: PPUSH
6545: CALL_OW 72
6549: ST_TO_ADDR
// if not sci then
6550: LD_VAR 0 1
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6709
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6559: LD_ADDR_EXP 63
6563: PUSH
6564: LD_EXP 63
6568: PPUSH
6569: LD_INT 1
6571: PPUSH
6572: LD_EXP 63
6576: PUSH
6577: LD_INT 1
6579: ARRAY
6580: PUSH
6581: LD_VAR 0 1
6585: PUSH
6586: LD_INT 1
6588: ARRAY
6589: DIFF
6590: PPUSH
6591: CALL_OW 1
6595: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6596: LD_VAR 0 1
6600: PUSH
6601: LD_INT 1
6603: ARRAY
6604: PPUSH
6605: CALL_OW 310
6609: IFFALSE 6624
// ComExitBuilding ( sci [ 1 ] ) ;
6611: LD_VAR 0 1
6615: PUSH
6616: LD_INT 1
6618: ARRAY
6619: PPUSH
6620: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6624: LD_INT 2
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: LD_INT 20
6635: PPUSH
6636: CALL 23776 0 4
6640: PUSH
6641: LD_INT 4
6643: ARRAY
6644: PUSH
6645: LD_INT 10
6647: LESS
6648: IFFALSE 6671
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6650: LD_VAR 0 1
6654: PUSH
6655: LD_INT 1
6657: ARRAY
6658: PPUSH
6659: LD_INT 105
6661: PPUSH
6662: LD_INT 14
6664: PPUSH
6665: CALL_OW 171
6669: GO 6690
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6671: LD_VAR 0 1
6675: PUSH
6676: LD_INT 1
6678: ARRAY
6679: PPUSH
6680: LD_INT 118
6682: PPUSH
6683: LD_INT 77
6685: PPUSH
6686: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6690: LD_VAR 0 1
6694: PUSH
6695: LD_INT 1
6697: ARRAY
6698: PPUSH
6699: LD_INT 92
6701: PPUSH
6702: LD_INT 40
6704: PPUSH
6705: CALL_OW 218
// end ;
6709: PPOPN 1
6711: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6712: LD_INT 1
6714: PPUSH
6715: CALL_OW 302
6719: IFFALSE 6727
6721: PUSH
6722: LD_EXP 10
6726: AND
6727: IFFALSE 7618
6729: GO 6731
6731: DISABLE
6732: LD_INT 0
6734: PPUSH
6735: PPUSH
6736: PPUSH
6737: PPUSH
6738: PPUSH
6739: PPUSH
6740: PPUSH
6741: PPUSH
// begin enable ;
6742: ENABLE
// base := 1 ;
6743: LD_ADDR_VAR 0 3
6747: PUSH
6748: LD_INT 1
6750: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6751: LD_ADDR_VAR 0 5
6755: PUSH
6756: LD_INT 0
6758: PUSH
6759: LD_INT 0
6761: PUSH
6762: LD_INT 0
6764: PUSH
6765: LD_INT 0
6767: PUSH
6768: LD_INT 0
6770: PUSH
6771: LD_INT 0
6773: PUSH
6774: LD_INT 0
6776: PUSH
6777: LD_INT 0
6779: PUSH
6780: LD_INT 1
6782: PUSH
6783: LD_INT 0
6785: PUSH
6786: EMPTY
6787: LIST
6788: LIST
6789: LIST
6790: LIST
6791: LIST
6792: LIST
6793: LIST
6794: LIST
6795: LIST
6796: LIST
6797: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6798: LD_ADDR_VAR 0 4
6802: PUSH
6803: LD_INT 13
6805: PUSH
6806: LD_INT 1
6808: PUSH
6809: LD_INT 2
6811: PUSH
6812: LD_INT 26
6814: PUSH
6815: EMPTY
6816: LIST
6817: LIST
6818: LIST
6819: LIST
6820: PUSH
6821: LD_INT 13
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 2
6829: PUSH
6830: LD_INT 28
6832: PUSH
6833: EMPTY
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 13
6841: PUSH
6842: LD_INT 1
6844: PUSH
6845: LD_INT 2
6847: PUSH
6848: LD_INT 29
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: LIST
6855: LIST
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: LIST
6861: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6862: LD_ADDR_VAR 0 1
6866: PUSH
6867: DOUBLE
6868: LD_INT 1
6870: DEC
6871: ST_TO_ADDR
6872: LD_OWVAR 67
6876: PUSH
6877: LD_OWVAR 1
6881: PUSH
6882: LD_INT 21000
6884: DIV
6885: PLUS
6886: PUSH
6887: FOR_TO
6888: IFFALSE 6961
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6890: LD_ADDR_VAR 0 4
6894: PUSH
6895: LD_VAR 0 4
6899: PPUSH
6900: LD_VAR 0 4
6904: PUSH
6905: LD_INT 1
6907: PLUS
6908: PPUSH
6909: LD_INT 13
6911: PUSH
6912: LD_INT 1
6914: PUSH
6915: LD_INT 2
6917: PUSH
6918: LD_INT 28
6920: PUSH
6921: LD_INT 29
6923: PUSH
6924: LD_INT 25
6926: PUSH
6927: LD_INT 26
6929: PUSH
6930: EMPTY
6931: LIST
6932: LIST
6933: LIST
6934: LIST
6935: PUSH
6936: LD_INT 1
6938: PPUSH
6939: LD_INT 4
6941: PPUSH
6942: CALL_OW 12
6946: ARRAY
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: LIST
6952: LIST
6953: PPUSH
6954: CALL_OW 2
6958: ST_TO_ADDR
6959: GO 6887
6961: POP
6962: POP
// MC_InsertProduceList ( base , tmp ) ;
6963: LD_VAR 0 3
6967: PPUSH
6968: LD_VAR 0 4
6972: PPUSH
6973: CALL 85446 0 2
// wait ( 3 3$20 ) ;
6977: LD_INT 7000
6979: PPUSH
6980: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6984: LD_ADDR_VAR 0 6
6988: PUSH
6989: LD_INT 124
6991: PUSH
6992: LD_INT 85
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: PUSH
6999: LD_INT 90
7001: PUSH
7002: LD_INT 61
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PUSH
7009: LD_INT 69
7011: PUSH
7012: LD_INT 48
7014: PUSH
7015: EMPTY
7016: LIST
7017: LIST
7018: PUSH
7019: LD_INT 68
7021: PUSH
7022: LD_INT 48
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: LIST
7033: LIST
7034: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 22
7042: PUSH
7043: LD_INT 2
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 23
7052: PUSH
7053: LD_INT 2
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: LD_INT 21
7062: PUSH
7063: LD_INT 2
7065: PUSH
7066: EMPTY
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 3
7072: PUSH
7073: LD_INT 2
7075: PUSH
7076: LD_INT 34
7078: PUSH
7079: LD_INT 31
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: PUSH
7086: LD_INT 34
7088: PUSH
7089: LD_INT 88
7091: PUSH
7092: EMPTY
7093: LIST
7094: LIST
7095: PUSH
7096: LD_INT 34
7098: PUSH
7099: LD_INT 32
7101: PUSH
7102: EMPTY
7103: LIST
7104: LIST
7105: PUSH
7106: EMPTY
7107: LIST
7108: LIST
7109: LIST
7110: LIST
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: LIST
7120: LIST
7121: PPUSH
7122: CALL_OW 69
7126: PUSH
7127: LD_EXP 82
7131: PUSH
7132: LD_VAR 0 3
7136: ARRAY
7137: PPUSH
7138: LD_INT 2
7140: PUSH
7141: LD_INT 34
7143: PUSH
7144: LD_INT 32
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: PUSH
7151: LD_INT 34
7153: PUSH
7154: LD_INT 88
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: LIST
7165: PPUSH
7166: CALL_OW 72
7170: DIFF
7171: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7172: LD_INT 0
7174: PPUSH
7175: LD_INT 1
7177: PPUSH
7178: CALL_OW 12
7182: IFFALSE 7332
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7184: LD_ADDR_VAR 0 1
7188: PUSH
7189: DOUBLE
7190: LD_INT 1
7192: DEC
7193: ST_TO_ADDR
7194: LD_INT 3
7196: PUSH
7197: LD_INT 4
7199: PUSH
7200: LD_INT 5
7202: PUSH
7203: LD_INT 6
7205: PUSH
7206: EMPTY
7207: LIST
7208: LIST
7209: LIST
7210: LIST
7211: PUSH
7212: LD_OWVAR 67
7216: ARRAY
7217: PUSH
7218: FOR_TO
7219: IFFALSE 7328
// begin uc_side := 2 ;
7221: LD_ADDR_OWVAR 20
7225: PUSH
7226: LD_INT 2
7228: ST_TO_ADDR
// uc_nation := 2 ;
7229: LD_ADDR_OWVAR 21
7233: PUSH
7234: LD_INT 2
7236: ST_TO_ADDR
// InitHc ;
7237: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7241: LD_INT 0
7243: PPUSH
7244: LD_INT 15
7246: PUSH
7247: LD_INT 17
7249: PUSH
7250: EMPTY
7251: LIST
7252: LIST
7253: PUSH
7254: LD_INT 1
7256: PPUSH
7257: LD_INT 2
7259: PPUSH
7260: CALL_OW 12
7264: ARRAY
7265: PPUSH
7266: LD_INT 8
7268: PPUSH
7269: CALL_OW 380
// un := CreateHuman ;
7273: LD_ADDR_VAR 0 2
7277: PUSH
7278: CALL_OW 44
7282: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 4
7290: PPUSH
7291: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7295: LD_VAR 0 2
7299: PPUSH
7300: LD_INT 23
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 49
// attackers := attackers union un ;
7310: LD_ADDR_VAR 0 7
7314: PUSH
7315: LD_VAR 0 7
7319: PUSH
7320: LD_VAR 0 2
7324: UNION
7325: ST_TO_ADDR
// end ;
7326: GO 7218
7328: POP
7329: POP
// end else
7330: GO 7490
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7332: LD_ADDR_VAR 0 1
7336: PUSH
7337: DOUBLE
7338: LD_INT 1
7340: DEC
7341: ST_TO_ADDR
7342: LD_INT 2
7344: PUSH
7345: LD_INT 3
7347: PUSH
7348: LD_INT 4
7350: PUSH
7351: LD_INT 5
7353: PUSH
7354: EMPTY
7355: LIST
7356: LIST
7357: LIST
7358: LIST
7359: PUSH
7360: LD_OWVAR 67
7364: ARRAY
7365: PUSH
7366: FOR_TO
7367: IFFALSE 7488
// begin uc_side := 2 ;
7369: LD_ADDR_OWVAR 20
7373: PUSH
7374: LD_INT 2
7376: ST_TO_ADDR
// uc_nation := 2 ;
7377: LD_ADDR_OWVAR 21
7381: PUSH
7382: LD_INT 2
7384: ST_TO_ADDR
// InitHc ;
7385: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7389: LD_INT 14
7391: PPUSH
7392: LD_INT 3
7394: PPUSH
7395: LD_INT 5
7397: PPUSH
7398: LD_INT 29
7400: PUSH
7401: LD_INT 29
7403: PUSH
7404: LD_INT 26
7406: PUSH
7407: EMPTY
7408: LIST
7409: LIST
7410: LIST
7411: PUSH
7412: LD_VAR 0 1
7416: PUSH
7417: LD_INT 3
7419: MOD
7420: PUSH
7421: LD_INT 1
7423: PLUS
7424: ARRAY
7425: PPUSH
7426: LD_INT 100
7428: PPUSH
7429: CALL 22384 0 5
// un := CreateVehicle ;
7433: LD_ADDR_VAR 0 2
7437: PUSH
7438: CALL_OW 45
7442: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7443: LD_VAR 0 2
7447: PPUSH
7448: LD_INT 4
7450: PPUSH
7451: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7455: LD_VAR 0 2
7459: PPUSH
7460: LD_INT 23
7462: PPUSH
7463: LD_INT 0
7465: PPUSH
7466: CALL_OW 49
// attackers := attackers union un ;
7470: LD_ADDR_VAR 0 7
7474: PUSH
7475: LD_VAR 0 7
7479: PUSH
7480: LD_VAR 0 2
7484: UNION
7485: ST_TO_ADDR
// end ;
7486: GO 7366
7488: POP
7489: POP
// end ; if not attackers then
7490: LD_VAR 0 7
7494: NOT
7495: IFFALSE 7499
// exit ;
7497: GO 7618
// ar_attackers := attackers ;
7499: LD_ADDR_EXP 12
7503: PUSH
7504: LD_VAR 0 7
7508: ST_TO_ADDR
// p := 0 ;
7509: LD_ADDR_VAR 0 8
7513: PUSH
7514: LD_INT 0
7516: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7517: LD_INT 35
7519: PPUSH
7520: CALL_OW 67
// p := Inc ( p ) ;
7524: LD_ADDR_VAR 0 8
7528: PUSH
7529: LD_VAR 0 8
7533: PPUSH
7534: CALL 56927 0 1
7538: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7539: LD_VAR 0 7
7543: PPUSH
7544: LD_INT 60
7546: PUSH
7547: EMPTY
7548: LIST
7549: PPUSH
7550: CALL_OW 72
7554: NOT
7555: IFTRUE 7567
7557: PUSH
7558: LD_VAR 0 8
7562: PUSH
7563: LD_INT 30
7565: GREATER
7566: OR
7567: IFFALSE 7517
// repeat wait ( 0 0$1 ) ;
7569: LD_INT 35
7571: PPUSH
7572: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7576: LD_ADDR_VAR 0 7
7580: PUSH
7581: LD_VAR 0 7
7585: PPUSH
7586: LD_INT 50
7588: PUSH
7589: EMPTY
7590: LIST
7591: PPUSH
7592: CALL_OW 72
7596: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7597: LD_VAR 0 7
7601: PPUSH
7602: LD_VAR 0 6
7606: PPUSH
7607: CALL 58320 0 2
// until not attackers ;
7611: LD_VAR 0 7
7615: NOT
7616: IFFALSE 7569
// end ;
7618: PPOPN 8
7620: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7621: LD_INT 1
7623: PPUSH
7624: CALL_OW 302
7628: IFFALSE 7636
7630: PUSH
7631: LD_EXP 10
7635: AND
7636: IFFALSE 7652
7638: PUSH
7639: LD_EXP 52
7643: PPUSH
7644: LD_INT 22
7646: PPUSH
7647: CALL_OW 308
7651: AND
7652: IFFALSE 8158
7654: GO 7656
7656: DISABLE
7657: LD_INT 0
7659: PPUSH
7660: PPUSH
7661: PPUSH
7662: PPUSH
7663: PPUSH
7664: PPUSH
7665: PPUSH
7666: PPUSH
// begin base := 1 ;
7667: LD_ADDR_VAR 0 2
7671: PUSH
7672: LD_INT 1
7674: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7675: LD_ADDR_VAR 0 4
7679: PUSH
7680: LD_INT 0
7682: PUSH
7683: LD_INT 0
7685: PUSH
7686: LD_INT 0
7688: PUSH
7689: LD_INT 0
7691: PUSH
7692: LD_INT 0
7694: PUSH
7695: LD_INT 0
7697: PUSH
7698: LD_INT 0
7700: PUSH
7701: LD_INT 0
7703: PUSH
7704: LD_INT 1
7706: PUSH
7707: LD_INT 0
7709: PUSH
7710: EMPTY
7711: LIST
7712: LIST
7713: LIST
7714: LIST
7715: LIST
7716: LIST
7717: LIST
7718: LIST
7719: LIST
7720: LIST
7721: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7722: LD_ADDR_VAR 0 3
7726: PUSH
7727: LD_INT 13
7729: PUSH
7730: LD_INT 1
7732: PUSH
7733: LD_INT 2
7735: PUSH
7736: LD_INT 28
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: LIST
7743: LIST
7744: PUSH
7745: LD_INT 13
7747: PUSH
7748: LD_INT 1
7750: PUSH
7751: LD_INT 2
7753: PUSH
7754: LD_INT 27
7756: PUSH
7757: EMPTY
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 13
7765: PUSH
7766: LD_INT 1
7768: PUSH
7769: LD_INT 2
7771: PUSH
7772: LD_INT 25
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: LIST
7779: LIST
7780: PUSH
7781: LD_INT 11
7783: PUSH
7784: LD_INT 2
7786: PUSH
7787: LD_INT 2
7789: PUSH
7790: LD_INT 24
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: PUSH
7799: LD_INT 11
7801: PUSH
7802: LD_INT 2
7804: PUSH
7805: LD_INT 2
7807: PUSH
7808: LD_INT 24
7810: PUSH
7811: EMPTY
7812: LIST
7813: LIST
7814: LIST
7815: LIST
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: LIST
7821: LIST
7822: LIST
7823: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7824: LD_VAR 0 2
7828: PPUSH
7829: LD_VAR 0 3
7833: PPUSH
7834: CALL 85446 0 2
// wait ( 4 4$20 ) ;
7838: LD_INT 9100
7840: PPUSH
7841: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7845: LD_ADDR_VAR 0 5
7849: PUSH
7850: LD_INT 119
7852: PUSH
7853: LD_INT 9
7855: PUSH
7856: EMPTY
7857: LIST
7858: LIST
7859: PUSH
7860: EMPTY
7861: LIST
7862: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7863: LD_ADDR_VAR 0 6
7867: PUSH
7868: LD_EXP 82
7872: PUSH
7873: LD_VAR 0 2
7877: ARRAY
7878: PUSH
7879: LD_EXP 82
7883: PUSH
7884: LD_VAR 0 2
7888: ARRAY
7889: PPUSH
7890: LD_INT 2
7892: PUSH
7893: LD_INT 34
7895: PUSH
7896: LD_INT 32
7898: PUSH
7899: EMPTY
7900: LIST
7901: LIST
7902: PUSH
7903: LD_INT 34
7905: PUSH
7906: LD_INT 88
7908: PUSH
7909: EMPTY
7910: LIST
7911: LIST
7912: PUSH
7913: EMPTY
7914: LIST
7915: LIST
7916: LIST
7917: PPUSH
7918: CALL_OW 72
7922: DIFF
7923: ST_TO_ADDR
// uc_side := 2 ;
7924: LD_ADDR_OWVAR 20
7928: PUSH
7929: LD_INT 2
7931: ST_TO_ADDR
// uc_nation := 2 ;
7932: LD_ADDR_OWVAR 21
7936: PUSH
7937: LD_INT 2
7939: ST_TO_ADDR
// InitHc ;
7940: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7944: LD_ADDR_VAR 0 1
7948: PUSH
7949: DOUBLE
7950: LD_INT 1
7952: DEC
7953: ST_TO_ADDR
7954: LD_INT 4
7956: PUSH
7957: LD_INT 5
7959: PUSH
7960: LD_INT 6
7962: PUSH
7963: LD_INT 6
7965: PUSH
7966: EMPTY
7967: LIST
7968: LIST
7969: LIST
7970: LIST
7971: PUSH
7972: LD_OWVAR 67
7976: ARRAY
7977: PUSH
7978: FOR_TO
7979: IFFALSE 8056
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7981: LD_INT 0
7983: PPUSH
7984: LD_INT 15
7986: PUSH
7987: LD_INT 17
7989: PUSH
7990: EMPTY
7991: LIST
7992: LIST
7993: PUSH
7994: LD_INT 1
7996: PPUSH
7997: LD_INT 2
7999: PPUSH
8000: CALL_OW 12
8004: ARRAY
8005: PPUSH
8006: LD_INT 8
8008: PPUSH
8009: CALL_OW 380
// un := CreateHuman ;
8013: LD_ADDR_VAR 0 7
8017: PUSH
8018: CALL_OW 44
8022: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
8023: LD_VAR 0 7
8027: PPUSH
8028: LD_INT 23
8030: PPUSH
8031: LD_INT 0
8033: PPUSH
8034: CALL_OW 49
// attackers := attackers union un ;
8038: LD_ADDR_VAR 0 6
8042: PUSH
8043: LD_VAR 0 6
8047: PUSH
8048: LD_VAR 0 7
8052: UNION
8053: ST_TO_ADDR
// end ;
8054: GO 7978
8056: POP
8057: POP
// p := 0 ;
8058: LD_ADDR_VAR 0 8
8062: PUSH
8063: LD_INT 0
8065: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8066: LD_INT 35
8068: PPUSH
8069: CALL_OW 67
// p := Inc ( p ) ;
8073: LD_ADDR_VAR 0 8
8077: PUSH
8078: LD_VAR 0 8
8082: PPUSH
8083: CALL 56927 0 1
8087: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8088: LD_VAR 0 6
8092: PPUSH
8093: LD_INT 60
8095: PUSH
8096: EMPTY
8097: LIST
8098: PPUSH
8099: CALL_OW 72
8103: NOT
8104: IFTRUE 8116
8106: PUSH
8107: LD_VAR 0 8
8111: PUSH
8112: LD_INT 30
8114: GREATER
8115: OR
8116: IFFALSE 8066
// SetAttitude ( 4 , 2 , att_enemy , true ) ;
8118: LD_INT 4
8120: PPUSH
8121: LD_INT 2
8123: PPUSH
8124: LD_INT 2
8126: PPUSH
8127: LD_INT 1
8129: PPUSH
8130: CALL_OW 80
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8134: LD_VAR 0 2
8138: PPUSH
8139: LD_VAR 0 6
8143: PPUSH
8144: LD_VAR 0 5
8148: PPUSH
8149: LD_VAR 0 4
8153: PPUSH
8154: CALL 85631 0 4
// end ;
8158: PPOPN 8
8160: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8161: LD_INT 0
8163: PPUSH
8164: PPUSH
8165: PPUSH
8166: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8167: LD_ADDR_VAR 0 5
8171: PUSH
8172: LD_VAR 0 1
8176: PPUSH
8177: LD_INT 0
8179: PPUSH
8180: CALL_OW 517
8184: ST_TO_ADDR
// if not tmp then
8185: LD_VAR 0 5
8189: NOT
8190: IFFALSE 8194
// exit ;
8192: GO 8444
// arMinesList := arMinesList diff 0 ;
8194: LD_ADDR_EXP 60
8198: PUSH
8199: LD_EXP 60
8203: PUSH
8204: LD_INT 0
8206: DIFF
8207: ST_TO_ADDR
// for i := 1 to n do
8208: LD_ADDR_VAR 0 4
8212: PUSH
8213: DOUBLE
8214: LD_INT 1
8216: DEC
8217: ST_TO_ADDR
8218: LD_VAR 0 2
8222: PUSH
8223: FOR_TO
8224: IFFALSE 8442
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8226: LD_ADDR_VAR 0 6
8230: PUSH
8231: LD_INT 1
8233: PPUSH
8234: LD_VAR 0 5
8238: PUSH
8239: LD_INT 1
8241: ARRAY
8242: PPUSH
8243: CALL_OW 12
8247: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8248: LD_VAR 0 5
8252: PUSH
8253: LD_INT 1
8255: ARRAY
8256: PUSH
8257: LD_VAR 0 6
8261: ARRAY
8262: PPUSH
8263: LD_VAR 0 5
8267: PUSH
8268: LD_INT 2
8270: ARRAY
8271: PUSH
8272: LD_VAR 0 6
8276: ARRAY
8277: PPUSH
8278: LD_INT 2
8280: PPUSH
8281: LD_INT 0
8283: PPUSH
8284: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8288: LD_ADDR_EXP 60
8292: PUSH
8293: LD_EXP 60
8297: PPUSH
8298: LD_EXP 60
8302: PUSH
8303: LD_INT 1
8305: PLUS
8306: PPUSH
8307: LD_VAR 0 5
8311: PUSH
8312: LD_INT 1
8314: ARRAY
8315: PUSH
8316: LD_VAR 0 6
8320: ARRAY
8321: PPUSH
8322: CALL_OW 2
8326: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8327: LD_ADDR_EXP 60
8331: PUSH
8332: LD_EXP 60
8336: PPUSH
8337: LD_EXP 60
8341: PUSH
8342: LD_INT 1
8344: PLUS
8345: PPUSH
8346: LD_VAR 0 5
8350: PUSH
8351: LD_INT 2
8353: ARRAY
8354: PUSH
8355: LD_VAR 0 6
8359: ARRAY
8360: PPUSH
8361: CALL_OW 2
8365: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8366: LD_ADDR_VAR 0 5
8370: PUSH
8371: LD_VAR 0 5
8375: PPUSH
8376: LD_INT 1
8378: PPUSH
8379: LD_VAR 0 5
8383: PUSH
8384: LD_INT 1
8386: ARRAY
8387: PPUSH
8388: LD_VAR 0 6
8392: PPUSH
8393: CALL_OW 3
8397: PPUSH
8398: CALL_OW 1
8402: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8403: LD_ADDR_VAR 0 5
8407: PUSH
8408: LD_VAR 0 5
8412: PPUSH
8413: LD_INT 2
8415: PPUSH
8416: LD_VAR 0 5
8420: PUSH
8421: LD_INT 2
8423: ARRAY
8424: PPUSH
8425: LD_VAR 0 6
8429: PPUSH
8430: CALL_OW 3
8434: PPUSH
8435: CALL_OW 1
8439: ST_TO_ADDR
// end ;
8440: GO 8223
8442: POP
8443: POP
// end ;
8444: LD_VAR 0 3
8448: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8449: LD_EXP 60
8453: IFFALSE 8684
8455: GO 8457
8457: DISABLE
8458: LD_INT 0
8460: PPUSH
8461: PPUSH
8462: PPUSH
8463: PPUSH
// begin enable ;
8464: ENABLE
// p := 1 ;
8465: LD_ADDR_VAR 0 2
8469: PUSH
8470: LD_INT 1
8472: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8473: LD_ADDR_VAR 0 1
8477: PUSH
8478: DOUBLE
8479: LD_INT 1
8481: DEC
8482: ST_TO_ADDR
8483: LD_EXP 60
8487: PPUSH
8488: CALL 19622 0 1
8492: PUSH
8493: LD_INT 2
8495: DIV
8496: PUSH
8497: FOR_TO
8498: IFFALSE 8682
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8500: LD_ADDR_VAR 0 3
8504: PUSH
8505: LD_EXP 60
8509: PUSH
8510: LD_VAR 0 2
8514: ARRAY
8515: PPUSH
8516: LD_EXP 60
8520: PUSH
8521: LD_VAR 0 2
8525: PUSH
8526: LD_INT 1
8528: PLUS
8529: ARRAY
8530: PPUSH
8531: CALL_OW 428
8535: ST_TO_ADDR
// if tmp then
8536: LD_VAR 0 3
8540: IFFALSE 8666
// begin side := GetSide ( tmp ) ;
8542: LD_ADDR_VAR 0 4
8546: PUSH
8547: LD_VAR 0 3
8551: PPUSH
8552: CALL_OW 255
8556: ST_TO_ADDR
// if side <> 2 and side > 0 then
8557: LD_VAR 0 4
8561: PUSH
8562: LD_INT 2
8564: NONEQUAL
8565: IFFALSE 8577
8567: PUSH
8568: LD_VAR 0 4
8572: PUSH
8573: LD_INT 0
8575: GREATER
8576: AND
8577: IFFALSE 8666
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8579: LD_EXP 60
8583: PUSH
8584: LD_VAR 0 2
8588: ARRAY
8589: PPUSH
8590: LD_EXP 60
8594: PUSH
8595: LD_VAR 0 2
8599: PUSH
8600: LD_INT 1
8602: PLUS
8603: ARRAY
8604: PPUSH
8605: LD_INT 2
8607: PPUSH
8608: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8612: LD_ADDR_EXP 60
8616: PUSH
8617: LD_EXP 60
8621: PPUSH
8622: LD_VAR 0 2
8626: PPUSH
8627: CALL_OW 3
8631: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8632: LD_ADDR_EXP 60
8636: PUSH
8637: LD_EXP 60
8641: PPUSH
8642: LD_VAR 0 2
8646: PPUSH
8647: CALL_OW 3
8651: ST_TO_ADDR
// p := p - 2 ;
8652: LD_ADDR_VAR 0 2
8656: PUSH
8657: LD_VAR 0 2
8661: PUSH
8662: LD_INT 2
8664: MINUS
8665: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: LD_VAR 0 2
8675: PUSH
8676: LD_INT 2
8678: PLUS
8679: ST_TO_ADDR
// end ;
8680: GO 8497
8682: POP
8683: POP
// end ; end_of_file
8684: PPOPN 4
8686: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8687: LD_INT 0
8689: PPUSH
8690: PPUSH
8691: PPUSH
8692: PPUSH
8693: PPUSH
8694: PPUSH
// uc_side := 1 ;
8695: LD_ADDR_OWVAR 20
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// uc_nation := 1 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 1
8710: ST_TO_ADDR
// InitHc ;
8711: CALL_OW 19
// InitVc ;
8715: CALL_OW 20
// tmp := [ ] ;
8719: LD_ADDR_VAR 0 3
8723: PUSH
8724: EMPTY
8725: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8726: LD_ADDR_VAR 0 2
8730: PUSH
8731: DOUBLE
8732: LD_INT 1
8734: DEC
8735: ST_TO_ADDR
8736: LD_INT 6
8738: PUSH
8739: LD_INT 8
8741: PUSH
8742: LD_INT 10
8744: PUSH
8745: LD_INT 10
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: LIST
8752: LIST
8753: PUSH
8754: LD_OWVAR 67
8758: ARRAY
8759: PUSH
8760: FOR_TO
8761: IFFALSE 9051
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8763: LD_ADDR_VAR 0 5
8767: PUSH
8768: LD_INT 2
8770: PUSH
8771: LD_INT 4
8773: PUSH
8774: LD_INT 5
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: LIST
8781: PUSH
8782: LD_INT 1
8784: PPUSH
8785: LD_INT 3
8787: PPUSH
8788: CALL_OW 12
8792: ARRAY
8793: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8794: LD_VAR 0 5
8798: PUSH
8799: LD_INT 2
8801: DOUBLE
8802: EQUAL
8803: IFTRUE 8807
8805: GO 8841
8807: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8808: LD_ADDR_VAR 0 6
8812: PUSH
8813: LD_INT 9
8815: PUSH
8816: LD_INT 5
8818: PUSH
8819: LD_INT 7
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_INT 1
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 12
8837: ARRAY
8838: ST_TO_ADDR
8839: GO 8930
8841: LD_INT 4
8843: DOUBLE
8844: EQUAL
8845: IFTRUE 8849
8847: GO 8887
8849: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8850: LD_ADDR_VAR 0 6
8854: PUSH
8855: LD_INT 9
8857: PUSH
8858: LD_INT 6
8860: PUSH
8861: LD_INT 6
8863: PUSH
8864: LD_INT 7
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 1
8875: PPUSH
8876: LD_INT 4
8878: PPUSH
8879: CALL_OW 12
8883: ARRAY
8884: ST_TO_ADDR
8885: GO 8930
8887: LD_INT 5
8889: DOUBLE
8890: EQUAL
8891: IFTRUE 8895
8893: GO 8929
8895: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8896: LD_ADDR_VAR 0 6
8900: PUSH
8901: LD_INT 9
8903: PUSH
8904: LD_INT 6
8906: PUSH
8907: LD_INT 7
8909: PUSH
8910: EMPTY
8911: LIST
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 3
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: ST_TO_ADDR
8927: GO 8930
8929: POP
// uc_side := 1 ;
8930: LD_ADDR_OWVAR 20
8934: PUSH
8935: LD_INT 1
8937: ST_TO_ADDR
// uc_nation := 1 ;
8938: LD_ADDR_OWVAR 21
8942: PUSH
8943: LD_INT 1
8945: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8946: LD_VAR 0 5
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_VAR 0 6
8980: PPUSH
8981: LD_INT 70
8983: PPUSH
8984: LD_INT 90
8986: PPUSH
8987: CALL_OW 12
8991: PPUSH
8992: CALL 22384 0 5
// veh := CreateVehicle ;
8996: LD_ADDR_VAR 0 4
9000: PUSH
9001: CALL_OW 45
9005: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9006: LD_VAR 0 4
9010: PPUSH
9011: LD_INT 2
9013: PPUSH
9014: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9018: LD_VAR 0 4
9022: PPUSH
9023: LD_INT 17
9025: PPUSH
9026: LD_INT 0
9028: PPUSH
9029: CALL_OW 49
// tmp := tmp ^ veh ;
9033: LD_ADDR_VAR 0 3
9037: PUSH
9038: LD_VAR 0 3
9042: PUSH
9043: LD_VAR 0 4
9047: ADD
9048: ST_TO_ADDR
// end ;
9049: GO 8760
9051: POP
9052: POP
// if not tmp then
9053: LD_VAR 0 3
9057: NOT
9058: IFFALSE 9062
// exit ;
9060: GO 9171
// if not first_powell_attack then
9062: LD_EXP 13
9066: NOT
9067: IFFALSE 9077
// first_powell_attack := true ;
9069: LD_ADDR_EXP 13
9073: PUSH
9074: LD_INT 1
9076: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9077: LD_INT 70
9079: PPUSH
9080: CALL_OW 67
// for i in tmp do
9084: LD_ADDR_VAR 0 2
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: FOR_IN
9095: IFFALSE 9162
// if IsOk ( i ) then
9097: LD_VAR 0 2
9101: PPUSH
9102: CALL_OW 302
9106: IFFALSE 9144
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9108: LD_VAR 0 2
9112: PPUSH
9113: LD_INT 81
9115: PUSH
9116: LD_INT 1
9118: PUSH
9119: EMPTY
9120: LIST
9121: LIST
9122: PPUSH
9123: CALL_OW 69
9127: PPUSH
9128: LD_VAR 0 2
9132: PPUSH
9133: CALL_OW 74
9137: PPUSH
9138: CALL_OW 115
9142: GO 9160
// tmp := tmp diff i ;
9144: LD_ADDR_VAR 0 3
9148: PUSH
9149: LD_VAR 0 3
9153: PUSH
9154: LD_VAR 0 2
9158: DIFF
9159: ST_TO_ADDR
9160: GO 9094
9162: POP
9163: POP
// until not tmp ;
9164: LD_VAR 0 3
9168: NOT
9169: IFFALSE 9077
// end ;
9171: LD_VAR 0 1
9175: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9176: LD_INT 0
9178: PPUSH
9179: PPUSH
// uc_side := 1 ;
9180: LD_ADDR_OWVAR 20
9184: PUSH
9185: LD_INT 1
9187: ST_TO_ADDR
// uc_nation := 1 ;
9188: LD_ADDR_OWVAR 21
9192: PUSH
9193: LD_INT 1
9195: ST_TO_ADDR
// InitHc ;
9196: CALL_OW 19
// InitVc ;
9200: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9204: LD_INT 5
9206: PPUSH
9207: LD_INT 3
9209: PPUSH
9210: LD_INT 3
9212: PPUSH
9213: LD_INT 12
9215: PPUSH
9216: LD_INT 100
9218: PPUSH
9219: CALL 22384 0 5
// veh := CreateVehicle ;
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: CALL_OW 45
9232: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9233: LD_VAR 0 3
9237: PPUSH
9238: LD_INT 2
9240: PPUSH
9241: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9245: LD_VAR 0 3
9249: PPUSH
9250: LD_INT 17
9252: PPUSH
9253: LD_INT 0
9255: PPUSH
9256: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9260: LD_VAR 0 3
9264: PPUSH
9265: LD_VAR 0 1
9269: PUSH
9270: LD_INT 1
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 1
9278: PUSH
9279: LD_INT 2
9281: ARRAY
9282: PPUSH
9283: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9287: LD_VAR 0 3
9291: PPUSH
9292: LD_INT 59
9294: PPUSH
9295: LD_INT 2
9297: PPUSH
9298: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9302: LD_INT 35
9304: PPUSH
9305: CALL_OW 67
// if not IsOk ( veh ) then
9309: LD_VAR 0 3
9313: PPUSH
9314: CALL_OW 302
9318: NOT
9319: IFFALSE 9323
// exit ;
9321: GO 9377
// until IsAt ( veh , 59 , 2 ) ;
9323: LD_VAR 0 3
9327: PPUSH
9328: LD_INT 59
9330: PPUSH
9331: LD_INT 2
9333: PPUSH
9334: CALL_OW 307
9338: IFFALSE 9302
// RemoveUnit ( veh ) ;
9340: LD_VAR 0 3
9344: PPUSH
9345: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9349: LD_VAR 0 3
9353: PPUSH
9354: LD_INT 4
9356: PPUSH
9357: CALL_OW 289
9361: IFFALSE 9377
// begin wait ( 0 0$2 ) ;
9363: LD_INT 70
9365: PPUSH
9366: CALL_OW 67
// YouLost ( Artifact ) ;
9370: LD_STRING Artifact
9372: PPUSH
9373: CALL_OW 104
// end ; end ; end_of_file
9377: LD_VAR 0 2
9381: RET
// export function Action ; var tmp , i , un ; begin
9382: LD_INT 0
9384: PPUSH
9385: PPUSH
9386: PPUSH
9387: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9388: LD_INT 68
9390: PPUSH
9391: LD_INT 39
9393: PPUSH
9394: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9398: LD_ADDR_VAR 0 2
9402: PUSH
9403: LD_INT 22
9405: PUSH
9406: LD_INT 7
9408: PUSH
9409: EMPTY
9410: LIST
9411: LIST
9412: PPUSH
9413: CALL_OW 69
9417: ST_TO_ADDR
// InGameOn ;
9418: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9422: LD_VAR 0 2
9426: PPUSH
9427: LD_INT 71
9429: PPUSH
9430: LD_INT 49
9432: PPUSH
9433: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9437: LD_INT 35
9439: PPUSH
9440: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9444: LD_INT 7
9446: PPUSH
9447: LD_INT 71
9449: PPUSH
9450: LD_INT 51
9452: PPUSH
9453: CALL_OW 293
9457: IFFALSE 9437
// DialogueOn ;
9459: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-1
9470: PPUSH
9471: CALL_OW 88
// if Joan then
9475: LD_EXP 32
9479: IFFALSE 9493
// Say ( Joan , D1-Joan-1 ) ;
9481: LD_EXP 32
9485: PPUSH
9486: LD_STRING D1-Joan-1
9488: PPUSH
9489: CALL_OW 88
// if Lisa then
9493: LD_EXP 19
9497: IFFALSE 9511
// Say ( Lisa , D1-Lisa-1 ) ;
9499: LD_EXP 19
9503: PPUSH
9504: LD_STRING D1-Lisa-1
9506: PPUSH
9507: CALL_OW 88
// if Joan or Lisa then
9511: LD_EXP 32
9515: IFTRUE 9523
9517: PUSH
9518: LD_EXP 19
9522: OR
9523: IFFALSE 9537
// Say ( JMM , D1-JMM-2 ) ;
9525: LD_EXP 17
9529: PPUSH
9530: LD_STRING D1-JMM-2
9532: PPUSH
9533: CALL_OW 88
// DialogueOff ;
9537: CALL_OW 7
// InGameOff ;
9541: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9545: LD_INT 71
9547: PPUSH
9548: LD_INT 50
9550: PPUSH
9551: LD_INT 7
9553: PPUSH
9554: LD_INT 30
9556: NEG
9557: PPUSH
9558: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9562: LD_INT 71
9564: PPUSH
9565: LD_INT 50
9567: PPUSH
9568: LD_INT 7
9570: PPUSH
9571: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9575: LD_STRING M1
9577: PPUSH
9578: CALL_OW 337
// SaveForQuickRestart ;
9582: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9586: LD_INT 35
9588: PPUSH
9589: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9593: LD_EXP 3
9597: IFTRUE 9609
9599: PUSH
9600: LD_OWVAR 1
9604: PUSH
9605: LD_INT 2100
9607: GREATER
9608: OR
9609: IFFALSE 9586
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9611: LD_INT 350
9613: PPUSH
9614: LD_INT 700
9616: PPUSH
9617: CALL_OW 12
9621: PPUSH
9622: CALL_OW 67
// PrepareGossudarov ;
9626: CALL 1949 0 0
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9637: LD_INT 22
9639: PUSH
9640: LD_INT 6
9642: PUSH
9643: EMPTY
9644: LIST
9645: LIST
9646: PUSH
9647: LD_INT 3
9649: PUSH
9650: LD_INT 24
9652: PUSH
9653: LD_INT 1000
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: IFTRUE 9688
9674: PUSH
9675: LD_INT 7
9677: PPUSH
9678: LD_EXP 35
9682: PPUSH
9683: CALL_OW 292
9687: OR
9688: IFFALSE 9630
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9690: LD_ADDR_VAR 0 2
9694: PUSH
9695: LD_INT 22
9697: PUSH
9698: LD_INT 6
9700: PUSH
9701: EMPTY
9702: LIST
9703: LIST
9704: PPUSH
9705: CALL_OW 69
9709: ST_TO_ADDR
// for i in tmp do
9710: LD_ADDR_VAR 0 3
9714: PUSH
9715: LD_VAR 0 2
9719: PUSH
9720: FOR_IN
9721: IFFALSE 9737
// SetSide ( i , 7 ) ;
9723: LD_VAR 0 3
9727: PPUSH
9728: LD_INT 7
9730: PPUSH
9731: CALL_OW 235
9735: GO 9720
9737: POP
9738: POP
// DialogueOn ;
9739: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9743: LD_EXP 17
9747: PUSH
9748: LD_EXP 18
9752: PUSH
9753: EMPTY
9754: LIST
9755: LIST
9756: PPUSH
9757: LD_EXP 35
9761: PPUSH
9762: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9766: LD_EXP 35
9770: PPUSH
9771: CALL_OW 87
// if not Roth then
9775: LD_EXP 18
9779: NOT
9780: IFFALSE 9872
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9782: LD_VAR 0 2
9786: PPUSH
9787: LD_INT 3
9789: PUSH
9790: LD_INT 24
9792: PUSH
9793: LD_INT 1000
9795: PUSH
9796: EMPTY
9797: LIST
9798: LIST
9799: PUSH
9800: EMPTY
9801: LIST
9802: LIST
9803: PPUSH
9804: CALL_OW 72
9808: IFFALSE 9822
// Say ( JMM , D2-JMM-1 ) ;
9810: LD_EXP 17
9814: PPUSH
9815: LD_STRING D2-JMM-1
9817: PPUSH
9818: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9822: LD_EXP 17
9826: PPUSH
9827: LD_STRING D2-JMM-1b
9829: PPUSH
9830: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9834: LD_EXP 35
9838: PPUSH
9839: LD_STRING D2-Gos-1
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-2
9853: PPUSH
9854: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9858: LD_EXP 35
9862: PPUSH
9863: LD_STRING D2-Gos-2
9865: PPUSH
9866: CALL_OW 88
// end else
9870: GO 10024
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9872: LD_VAR 0 2
9876: PPUSH
9877: LD_INT 3
9879: PUSH
9880: LD_INT 24
9882: PUSH
9883: LD_INT 1000
9885: PUSH
9886: EMPTY
9887: LIST
9888: LIST
9889: PUSH
9890: EMPTY
9891: LIST
9892: LIST
9893: PPUSH
9894: CALL_OW 72
9898: IFFALSE 9924
// begin Say ( Roth , D2-Roth-2 ) ;
9900: LD_EXP 18
9904: PPUSH
9905: LD_STRING D2-Roth-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9912: LD_EXP 17
9916: PPUSH
9917: LD_STRING D2-JMM-1a
9919: PPUSH
9920: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9924: LD_EXP 18
9928: PPUSH
9929: LD_STRING D2-Roth-2a
9931: PPUSH
9932: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9936: LD_EXP 18
9940: PPUSH
9941: LD_STRING D2-Roth-2b
9943: PPUSH
9944: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9948: LD_EXP 17
9952: PPUSH
9953: LD_STRING D2-JMM-3
9955: PPUSH
9956: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9960: LD_VAR 0 2
9964: PPUSH
9965: LD_INT 3
9967: PUSH
9968: LD_INT 24
9970: PUSH
9971: LD_INT 1000
9973: PUSH
9974: EMPTY
9975: LIST
9976: LIST
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PPUSH
9982: CALL_OW 72
9986: IFFALSE 10024
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9988: LD_EXP 35
9992: PPUSH
9993: LD_STRING D2-Gos-3
9995: PPUSH
9996: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
10000: LD_EXP 17
10004: PPUSH
10005: LD_STRING D2-JMM-4
10007: PPUSH
10008: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
10012: LD_EXP 35
10016: PPUSH
10017: LD_STRING D2-Gos-4
10019: PPUSH
10020: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
10024: LD_EXP 17
10028: PPUSH
10029: LD_STRING D2-JMM-5
10031: PPUSH
10032: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
10036: LD_EXP 35
10040: PPUSH
10041: LD_STRING D2-Gos-5
10043: PPUSH
10044: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
10048: LD_EXP 17
10052: PPUSH
10053: LD_STRING D2-JMM-6
10055: PPUSH
10056: CALL_OW 88
// DialogueOff ;
10060: CALL_OW 7
// wait ( 0 0$2 ) ;
10064: LD_INT 70
10066: PPUSH
10067: CALL_OW 67
// if Kirilenkova then
10071: LD_EXP 36
10075: IFFALSE 10089
// Say ( Kirilenkova , D3-Kir-1 ) ;
10077: LD_EXP 36
10081: PPUSH
10082: LD_STRING D3-Kir-1
10084: PPUSH
10085: CALL_OW 88
// gossudarov_arrive := true ;
10089: LD_ADDR_EXP 4
10093: PUSH
10094: LD_INT 1
10096: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10097: LD_INT 35
10099: PPUSH
10100: CALL_OW 67
// until ru_lab_builded ;
10104: LD_EXP 5
10108: IFFALSE 10097
// DialogueOn ;
10110: CALL_OW 6
// if Kirilenkova then
10114: LD_EXP 36
10118: IFFALSE 10134
// Say ( Kirilenkova , D3a-Kir-1 ) else
10120: LD_EXP 36
10124: PPUSH
10125: LD_STRING D3a-Kir-1
10127: PPUSH
10128: CALL_OW 88
10132: GO 10156
// begin un := SciRu ;
10134: LD_ADDR_VAR 0 4
10138: PUSH
10139: CALL 15750 0 0
10143: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10144: LD_VAR 0 4
10148: PPUSH
10149: LD_STRING D3a-Sci1-1
10151: PPUSH
10152: CALL_OW 88
// end ; if Kirilenkova or un then
10156: LD_EXP 36
10160: IFTRUE 10168
10162: PUSH
10163: LD_VAR 0 4
10167: OR
10168: IFFALSE 10182
// Say ( JMM , D3a-JMM-1 ) ;
10170: LD_EXP 17
10174: PPUSH
10175: LD_STRING D3a-JMM-1
10177: PPUSH
10178: CALL_OW 88
// DialogueOff ;
10182: CALL_OW 7
// end ;
10186: LD_VAR 0 1
10190: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10191: LD_EXP 4
10195: IFFALSE 10304
10197: PUSH
10198: LD_INT 22
10200: PUSH
10201: LD_INT 7
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: PUSH
10208: LD_INT 2
10210: PUSH
10211: LD_INT 25
10213: PUSH
10214: LD_INT 1
10216: PUSH
10217: EMPTY
10218: LIST
10219: LIST
10220: PUSH
10221: LD_INT 25
10223: PUSH
10224: LD_INT 2
10226: PUSH
10227: EMPTY
10228: LIST
10229: LIST
10230: PUSH
10231: LD_INT 25
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: PUSH
10241: LD_INT 25
10243: PUSH
10244: LD_INT 4
10246: PUSH
10247: EMPTY
10248: LIST
10249: LIST
10250: PUSH
10251: LD_INT 25
10253: PUSH
10254: LD_INT 5
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 25
10263: PUSH
10264: LD_INT 8
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PUSH
10271: LD_INT 25
10273: PUSH
10274: LD_INT 9
10276: PUSH
10277: EMPTY
10278: LIST
10279: LIST
10280: PUSH
10281: EMPTY
10282: LIST
10283: LIST
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: LIST
10289: LIST
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: PPUSH
10295: CALL_OW 69
10299: PUSH
10300: LD_INT 7
10302: LESS
10303: AND
10304: IFFALSE 10316
10306: GO 10308
10308: DISABLE
// YouLost ( TooMany ) ;
10309: LD_STRING TooMany
10311: PPUSH
10312: CALL_OW 104
10316: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10317: LD_EXP 35
10321: PPUSH
10322: CALL_OW 255
10326: PUSH
10327: LD_INT 7
10329: EQUAL
10330: IFFALSE 10553
10332: GO 10334
10334: DISABLE
10335: LD_INT 0
10337: PPUSH
10338: PPUSH
10339: PPUSH
// begin uc_side := 3 ;
10340: LD_ADDR_OWVAR 20
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// uc_nation := 3 ;
10348: LD_ADDR_OWVAR 21
10352: PUSH
10353: LD_INT 3
10355: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10356: LD_INT 21
10358: PPUSH
10359: LD_INT 3
10361: PPUSH
10362: LD_INT 3
10364: PPUSH
10365: LD_INT 42
10367: PPUSH
10368: LD_INT 100
10370: PPUSH
10371: CALL 22384 0 5
// un := CreateVehicle ;
10375: LD_ADDR_VAR 0 3
10379: PUSH
10380: CALL_OW 45
10384: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10385: LD_VAR 0 3
10389: PPUSH
10390: LD_INT 15
10392: PPUSH
10393: LD_INT 0
10395: PPUSH
10396: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10400: LD_VAR 0 3
10404: PPUSH
10405: LD_INT 67
10407: PPUSH
10408: LD_INT 45
10410: PPUSH
10411: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10415: LD_VAR 0 3
10419: PPUSH
10420: LD_INT 70
10422: PPUSH
10423: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10427: LD_VAR 0 3
10431: PPUSH
10432: LD_INT 69
10434: PPUSH
10435: LD_INT 18
10437: PPUSH
10438: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10442: LD_VAR 0 3
10446: PPUSH
10447: LD_INT 60
10449: PPUSH
10450: LD_INT 3
10452: PPUSH
10453: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10457: LD_INT 35
10459: PPUSH
10460: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10464: LD_VAR 0 3
10468: PPUSH
10469: CALL_OW 302
10473: NOT
10474: IFTRUE 10490
10476: PUSH
10477: LD_VAR 0 3
10481: PPUSH
10482: LD_INT 17
10484: PPUSH
10485: CALL_OW 308
10489: OR
10490: IFTRUE 10509
10492: PUSH
10493: LD_VAR 0 3
10497: PPUSH
10498: LD_INT 60
10500: PPUSH
10501: LD_INT 3
10503: PPUSH
10504: CALL_OW 307
10508: OR
10509: IFFALSE 10457
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10511: LD_VAR 0 3
10515: PPUSH
10516: LD_INT 17
10518: PPUSH
10519: CALL_OW 308
10523: IFTRUE 10542
10525: PUSH
10526: LD_VAR 0 3
10530: PPUSH
10531: LD_INT 60
10533: PPUSH
10534: LD_INT 3
10536: PPUSH
10537: CALL_OW 307
10541: OR
10542: IFFALSE 10553
// RemoveUnit ( un ) ;
10544: LD_VAR 0 3
10548: PPUSH
10549: CALL_OW 64
// end ;
10553: PPOPN 3
10555: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10556: LD_EXP 4
10560: IFFALSE 10802
10562: GO 10564
10564: DISABLE
10565: LD_INT 0
10567: PPUSH
10568: PPUSH
10569: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10570: LD_INT 70
10572: PPUSH
10573: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10577: LD_ADDR_VAR 0 3
10581: PUSH
10582: LD_INT 22
10584: PUSH
10585: LD_INT 7
10587: PUSH
10588: EMPTY
10589: LIST
10590: LIST
10591: PUSH
10592: LD_INT 101
10594: PUSH
10595: LD_INT 3
10597: PUSH
10598: EMPTY
10599: LIST
10600: LIST
10601: PUSH
10602: EMPTY
10603: LIST
10604: LIST
10605: PPUSH
10606: CALL_OW 69
10610: ST_TO_ADDR
// until tmp ;
10611: LD_VAR 0 3
10615: IFFALSE 10570
// un := NearestUnitToUnit ( tmp , JMM ) ;
10617: LD_ADDR_VAR 0 2
10621: PUSH
10622: LD_VAR 0 3
10626: PPUSH
10627: LD_EXP 17
10631: PPUSH
10632: CALL_OW 74
10636: ST_TO_ADDR
// player_spotted := true ;
10637: LD_ADDR_EXP 7
10641: PUSH
10642: LD_INT 1
10644: ST_TO_ADDR
// tmp := SciRu ;
10645: LD_ADDR_VAR 0 3
10649: PUSH
10650: CALL 15750 0 0
10654: ST_TO_ADDR
// if not tmp then
10655: LD_VAR 0 3
10659: NOT
10660: IFFALSE 10672
// tmp := SolRu ;
10662: LD_ADDR_VAR 0 3
10666: PUSH
10667: CALL 15897 0 0
10671: ST_TO_ADDR
// DialogueOn ;
10672: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10676: LD_VAR 0 2
10680: PPUSH
10681: CALL_OW 250
10685: PPUSH
10686: LD_VAR 0 2
10690: PPUSH
10691: CALL_OW 251
10695: PPUSH
10696: LD_INT 7
10698: PPUSH
10699: LD_INT 8
10701: NEG
10702: PPUSH
10703: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 87
// if tmp then
10716: LD_VAR 0 3
10720: IFFALSE 10734
// Say ( tmp , D4-RSci1-1 ) ;
10722: LD_VAR 0 3
10726: PPUSH
10727: LD_STRING D4-RSci1-1
10729: PPUSH
10730: CALL_OW 88
// if Gossudarov then
10734: LD_EXP 35
10738: IFFALSE 10764
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10740: LD_EXP 35
10744: PPUSH
10745: LD_STRING D4-Gos-1
10747: PPUSH
10748: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10752: LD_EXP 17
10756: PPUSH
10757: LD_STRING D4-JMM-1
10759: PPUSH
10760: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10764: LD_VAR 0 2
10768: PPUSH
10769: CALL_OW 250
10773: PPUSH
10774: LD_VAR 0 2
10778: PPUSH
10779: CALL_OW 251
10783: PPUSH
10784: LD_INT 7
10786: PPUSH
10787: CALL_OW 331
// DialogueOff ;
10791: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10795: LD_STRING M5
10797: PPUSH
10798: CALL_OW 337
// end ;
10802: PPOPN 3
10804: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10805: LD_EXP 7
10809: IFFALSE 11408
10811: GO 10813
10813: DISABLE
10814: LD_INT 0
10816: PPUSH
10817: PPUSH
10818: PPUSH
// begin PrepareBelkov ;
10819: CALL 2262 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10823: LD_EXP 50
10827: PPUSH
10828: LD_INT 118
10830: PPUSH
10831: LD_INT 106
10833: PPUSH
10834: CALL_OW 111
// AddComHold ( Belkov ) ;
10838: LD_EXP 50
10842: PPUSH
10843: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10847: LD_INT 35
10849: PPUSH
10850: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10854: LD_EXP 50
10858: PPUSH
10859: LD_INT 118
10861: PPUSH
10862: LD_INT 106
10864: PPUSH
10865: CALL_OW 307
10869: IFFALSE 10847
// ChangeSideFog ( 4 , 7 ) ;
10871: LD_INT 4
10873: PPUSH
10874: LD_INT 7
10876: PPUSH
10877: CALL_OW 343
// if IsOk ( Belkov ) then
10881: LD_EXP 50
10885: PPUSH
10886: CALL_OW 302
10890: IFFALSE 10974
// begin InGameOn ;
10892: CALL_OW 8
// DialogueOn ;
10896: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10900: LD_EXP 50
10904: PPUSH
10905: LD_STRING D5-Bel-1
10907: PPUSH
10908: CALL_OW 94
// if Gossudarov then
10912: LD_EXP 35
10916: IFFALSE 10966
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10918: LD_EXP 35
10922: PPUSH
10923: LD_STRING D5-Gos-1
10925: PPUSH
10926: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10930: LD_EXP 17
10934: PPUSH
10935: LD_STRING D5-JMM-1
10937: PPUSH
10938: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10942: LD_EXP 35
10946: PPUSH
10947: LD_STRING D5-Gos-2
10949: PPUSH
10950: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10954: LD_EXP 17
10958: PPUSH
10959: LD_STRING D5-JMM-2
10961: PPUSH
10962: CALL_OW 88
// end ; DialogueOff ;
10966: CALL_OW 7
// InGameOff ;
10970: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10974: LD_STRING QSaveBelkov
10976: PPUSH
10977: CALL_OW 97
10981: PUSH
10982: LD_INT 1
10984: DOUBLE
10985: EQUAL
10986: IFTRUE 10990
10988: GO 11040
10990: POP
// begin DialogueOn ;
10991: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10995: LD_EXP 17
10999: PPUSH
11000: LD_STRING D5a-JMM-1
11002: PPUSH
11003: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
11007: LD_EXP 50
11011: PPUSH
11012: LD_STRING D5a-Bel-1
11014: PPUSH
11015: CALL_OW 94
// DialogueOff ;
11019: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
11023: LD_EXP 50
11027: PPUSH
11028: LD_INT 83
11030: PPUSH
11031: LD_INT 49
11033: PPUSH
11034: CALL_OW 111
// end ; 2 :
11038: GO 11073
11040: LD_INT 2
11042: DOUBLE
11043: EQUAL
11044: IFTRUE 11048
11046: GO 11072
11048: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
11049: LD_EXP 17
11053: PPUSH
11054: LD_STRING D5a-JMM-2
11056: PPUSH
11057: CALL_OW 88
// ComHold ( Belkov ) ;
11061: LD_EXP 50
11065: PPUSH
11066: CALL_OW 140
// end ; end ;
11070: GO 11073
11072: POP
// time := 0 0$00 ;
11073: LD_ADDR_VAR 0 1
11077: PUSH
11078: LD_INT 0
11080: ST_TO_ADDR
// vehSpawned := false ;
11081: LD_ADDR_VAR 0 3
11085: PUSH
11086: LD_INT 0
11088: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11089: LD_INT 35
11091: PPUSH
11092: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11096: LD_VAR 0 1
11100: PUSH
11101: LD_INT 350
11103: PUSH
11104: LD_INT 175
11106: PUSH
11107: LD_INT 105
11109: PUSH
11110: LD_INT 70
11112: PUSH
11113: EMPTY
11114: LIST
11115: LIST
11116: LIST
11117: LIST
11118: PUSH
11119: LD_OWVAR 67
11123: ARRAY
11124: GREATEREQUAL
11125: IFFALSE 11134
11127: PUSH
11128: LD_VAR 0 3
11132: NOT
11133: AND
11134: IFFALSE 11224
// begin vehSpawned := true ;
11136: LD_ADDR_VAR 0 3
11140: PUSH
11141: LD_INT 1
11143: ST_TO_ADDR
// uc_side := 3 ;
11144: LD_ADDR_OWVAR 20
11148: PUSH
11149: LD_INT 3
11151: ST_TO_ADDR
// uc_nation := 3 ;
11152: LD_ADDR_OWVAR 21
11156: PUSH
11157: LD_INT 3
11159: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11160: LD_INT 22
11162: PPUSH
11163: LD_INT 3
11165: PPUSH
11166: LD_INT 3
11168: PPUSH
11169: LD_INT 43
11171: PPUSH
11172: LD_INT 100
11174: PPUSH
11175: CALL 22384 0 5
// veh := CreateVehicle ;
11179: LD_ADDR_VAR 0 2
11183: PUSH
11184: CALL_OW 45
11188: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11189: LD_VAR 0 2
11193: PPUSH
11194: LD_INT 130
11196: PPUSH
11197: LD_INT 131
11199: PPUSH
11200: LD_INT 0
11202: PPUSH
11203: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11207: LD_VAR 0 2
11211: PPUSH
11212: LD_INT 100
11214: PPUSH
11215: LD_INT 82
11217: PPUSH
11218: CALL_OW 114
// end else
11222: GO 11238
// time := time + 0 0$1 ;
11224: LD_ADDR_VAR 0 1
11228: PUSH
11229: LD_VAR 0 1
11233: PUSH
11234: LD_INT 35
11236: PLUS
11237: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11238: LD_EXP 50
11242: PPUSH
11243: CALL_OW 301
11247: IFFALSE 11264
11249: PUSH
11250: LD_EXP 50
11254: PPUSH
11255: CALL_OW 255
11259: PUSH
11260: LD_INT 4
11262: EQUAL
11263: AND
11264: IFTRUE 11306
11266: PUSH
11267: LD_INT 22
11269: PUSH
11270: LD_INT 7
11272: PUSH
11273: EMPTY
11274: LIST
11275: LIST
11276: PPUSH
11277: CALL_OW 69
11281: PPUSH
11282: LD_EXP 50
11286: PPUSH
11287: CALL_OW 74
11291: PPUSH
11292: LD_EXP 50
11296: PPUSH
11297: CALL_OW 296
11301: PUSH
11302: LD_INT 10
11304: LESS
11305: OR
11306: IFFALSE 11089
// if IsDead ( Belkov ) then
11308: LD_EXP 50
11312: PPUSH
11313: CALL_OW 301
11317: IFFALSE 11342
// begin CenterNowOnUnits ( Belkov ) ;
11319: LD_EXP 50
11323: PPUSH
11324: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11328: LD_EXP 17
11332: PPUSH
11333: LD_STRING D5a-JMM-2a
11335: PPUSH
11336: CALL_OW 88
// exit ;
11340: GO 11408
// end ; if See ( 7 , Belkov ) then
11342: LD_INT 7
11344: PPUSH
11345: LD_EXP 50
11349: PPUSH
11350: CALL_OW 292
11354: IFFALSE 11368
// SetSide ( Belkov , 7 ) ;
11356: LD_EXP 50
11360: PPUSH
11361: LD_INT 7
11363: PPUSH
11364: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11368: LD_INT 35
11370: PPUSH
11371: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11375: LD_EXP 50
11379: PPUSH
11380: LD_INT 66
11382: PPUSH
11383: LD_INT 45
11385: PPUSH
11386: CALL_OW 297
11390: PUSH
11391: LD_INT 30
11393: LESS
11394: IFFALSE 11368
// Say ( Belkov , D6-Bel-1 ) ;
11396: LD_EXP 50
11400: PPUSH
11401: LD_STRING D6-Bel-1
11403: PPUSH
11404: CALL_OW 88
// end ;
11408: PPOPN 3
11410: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11411: LD_EXP 50
11415: PPUSH
11416: CALL_OW 302
11420: IFFALSE 11467
11422: PUSH
11423: LD_EXP 50
11427: PPUSH
11428: CALL_OW 504
11432: PUSH
11433: LD_INT 2
11435: PUSH
11436: LD_INT 34
11438: PUSH
11439: LD_INT 47
11441: PUSH
11442: EMPTY
11443: LIST
11444: LIST
11445: PUSH
11446: LD_INT 34
11448: PUSH
11449: LD_INT 45
11451: PUSH
11452: EMPTY
11453: LIST
11454: LIST
11455: PUSH
11456: EMPTY
11457: LIST
11458: LIST
11459: LIST
11460: PPUSH
11461: CALL_OW 69
11465: IN
11466: AND
11467: IFFALSE 11484
11469: GO 11471
11471: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11472: LD_EXP 50
11476: PPUSH
11477: LD_STRING D7-Bel-1
11479: PPUSH
11480: CALL_OW 88
11484: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11485: LD_INT 22
11487: PUSH
11488: LD_INT 7
11490: PUSH
11491: EMPTY
11492: LIST
11493: LIST
11494: PUSH
11495: LD_INT 101
11497: PUSH
11498: LD_INT 2
11500: PUSH
11501: EMPTY
11502: LIST
11503: LIST
11504: PUSH
11505: EMPTY
11506: LIST
11507: LIST
11508: PPUSH
11509: CALL_OW 69
11513: IFFALSE 11522
11515: PUSH
11516: LD_EXP 9
11520: NOT
11521: AND
11522: IFFALSE 11536
11524: PUSH
11525: LD_EXP 49
11529: PPUSH
11530: CALL_OW 305
11534: NOT
11535: AND
11536: IFFALSE 12021
11538: GO 11540
11540: DISABLE
11541: LD_INT 0
11543: PPUSH
// begin ar_base_spotted := true ;
11544: LD_ADDR_EXP 9
11548: PUSH
11549: LD_INT 1
11551: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11552: LD_ADDR_VAR 0 1
11556: PUSH
11557: LD_INT 22
11559: PUSH
11560: LD_INT 2
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 21
11569: PUSH
11570: LD_INT 3
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PPUSH
11581: CALL_OW 69
11585: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11586: LD_ADDR_VAR 0 1
11590: PUSH
11591: LD_VAR 0 1
11595: PPUSH
11596: LD_EXP 17
11600: PPUSH
11601: CALL_OW 74
11605: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11606: LD_INT 7
11608: PPUSH
11609: LD_INT 3
11611: PPUSH
11612: CALL_OW 332
// DialogueOn ;
11616: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11620: LD_VAR 0 1
11624: PPUSH
11625: CALL_OW 250
11629: PPUSH
11630: LD_VAR 0 1
11634: PPUSH
11635: CALL_OW 251
11639: PPUSH
11640: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11644: LD_ADDR_VAR 0 1
11648: PUSH
11649: LD_INT 22
11651: PUSH
11652: LD_INT 7
11654: PUSH
11655: EMPTY
11656: LIST
11657: LIST
11658: PUSH
11659: LD_INT 23
11661: PUSH
11662: LD_INT 1
11664: PUSH
11665: EMPTY
11666: LIST
11667: LIST
11668: PUSH
11669: LD_INT 26
11671: PUSH
11672: LD_INT 1
11674: PUSH
11675: EMPTY
11676: LIST
11677: LIST
11678: PUSH
11679: EMPTY
11680: LIST
11681: LIST
11682: LIST
11683: PPUSH
11684: CALL_OW 69
11688: PUSH
11689: LD_EXP 17
11693: PUSH
11694: LD_EXP 21
11698: PUSH
11699: LD_EXP 22
11703: PUSH
11704: LD_EXP 29
11708: PUSH
11709: LD_EXP 18
11713: PUSH
11714: LD_EXP 27
11718: PUSH
11719: LD_EXP 23
11723: PUSH
11724: LD_EXP 25
11728: PUSH
11729: EMPTY
11730: LIST
11731: LIST
11732: LIST
11733: LIST
11734: LIST
11735: LIST
11736: LIST
11737: LIST
11738: DIFF
11739: ST_TO_ADDR
// if not tmp then
11740: LD_VAR 0 1
11744: NOT
11745: IFFALSE 11819
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11747: LD_ADDR_VAR 0 1
11751: PUSH
11752: LD_INT 22
11754: PUSH
11755: LD_INT 7
11757: PUSH
11758: EMPTY
11759: LIST
11760: LIST
11761: PUSH
11762: LD_INT 23
11764: PUSH
11765: LD_INT 1
11767: PUSH
11768: EMPTY
11769: LIST
11770: LIST
11771: PUSH
11772: LD_INT 26
11774: PUSH
11775: LD_INT 2
11777: PUSH
11778: EMPTY
11779: LIST
11780: LIST
11781: PUSH
11782: EMPTY
11783: LIST
11784: LIST
11785: LIST
11786: PPUSH
11787: CALL_OW 69
11791: PUSH
11792: LD_EXP 32
11796: PUSH
11797: LD_EXP 19
11801: PUSH
11802: LD_EXP 30
11806: PUSH
11807: LD_EXP 31
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: DIFF
11818: ST_TO_ADDR
// if tmp then
11819: LD_VAR 0 1
11823: IFFALSE 11894
// case GetSex ( tmp [ 1 ] ) of sex_male :
11825: LD_VAR 0 1
11829: PUSH
11830: LD_INT 1
11832: ARRAY
11833: PPUSH
11834: CALL_OW 258
11838: PUSH
11839: LD_INT 1
11841: DOUBLE
11842: EQUAL
11843: IFTRUE 11847
11845: GO 11866
11847: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11848: LD_VAR 0 1
11852: PUSH
11853: LD_INT 1
11855: ARRAY
11856: PPUSH
11857: LD_STRING D9-Sol1-1
11859: PPUSH
11860: CALL_OW 88
11864: GO 11894
11866: LD_INT 2
11868: DOUBLE
11869: EQUAL
11870: IFTRUE 11874
11872: GO 11893
11874: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11875: LD_VAR 0 1
11879: PUSH
11880: LD_INT 1
11882: ARRAY
11883: PPUSH
11884: LD_STRING D9-FSol1-1
11886: PPUSH
11887: CALL_OW 88
11891: GO 11894
11893: POP
// if Frank then
11894: LD_EXP 29
11898: IFFALSE 12002
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11900: LD_EXP 59
11904: PPUSH
11905: CALL_OW 250
11909: PPUSH
11910: LD_EXP 59
11914: PPUSH
11915: CALL_OW 251
11919: PPUSH
11920: LD_INT 7
11922: PPUSH
11923: LD_INT 8
11925: PPUSH
11926: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11930: LD_EXP 59
11934: PPUSH
11935: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11939: LD_EXP 29
11943: PPUSH
11944: LD_STRING D9-Frank-1
11946: PPUSH
11947: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11951: LD_EXP 17
11955: PPUSH
11956: LD_STRING D9-JMM-1
11958: PPUSH
11959: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11963: LD_EXP 29
11967: PPUSH
11968: LD_STRING D9-Frank-2
11970: PPUSH
11971: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11975: LD_EXP 59
11979: PPUSH
11980: CALL_OW 250
11984: PPUSH
11985: LD_EXP 59
11989: PPUSH
11990: CALL_OW 251
11994: PPUSH
11995: LD_INT 7
11997: PPUSH
11998: CALL_OW 331
// end ; DialogueOff ;
12002: CALL_OW 7
// wait ( 1 1$00 ) ;
12006: LD_INT 2100
12008: PPUSH
12009: CALL_OW 67
// ar_active_attack := true ;
12013: LD_ADDR_EXP 10
12017: PUSH
12018: LD_INT 1
12020: ST_TO_ADDR
// end ;
12021: PPOPN 1
12023: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
12024: LD_EXP 8
12028: IFTRUE 12040
12030: PUSH
12031: LD_OWVAR 1
12035: PUSH
12036: LD_INT 42000
12038: GREATEREQUAL
12039: OR
12040: IFFALSE 13104
12042: GO 12044
12044: DISABLE
12045: LD_INT 0
12047: PPUSH
12048: PPUSH
// begin selected_option := 1 ;
12049: LD_ADDR_VAR 0 2
12053: PUSH
12054: LD_INT 1
12056: ST_TO_ADDR
// wait ( 5 5$00 ) ;
12057: LD_INT 10500
12059: PPUSH
12060: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
12064: LD_INT 35
12066: PPUSH
12067: CALL_OW 67
// until not ru_attackers ;
12071: LD_EXP 55
12075: NOT
12076: IFFALSE 12064
// PrepareBurlak ;
12078: CALL 2374 0 0
// repeat wait ( 0 0$2 ) ;
12082: LD_INT 70
12084: PPUSH
12085: CALL_OW 67
// until not HasTask ( Burlak ) ;
12089: LD_EXP 49
12093: PPUSH
12094: CALL_OW 314
12098: NOT
12099: IFFALSE 12082
// InGameOn ;
12101: CALL_OW 8
// DialogueOn ;
12105: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12109: LD_EXP 52
12113: PPUSH
12114: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12118: LD_EXP 49
12122: PPUSH
12123: LD_STRING D10-Bur-1
12125: PPUSH
12126: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12130: LD_EXP 50
12134: IFFALSE 12151
12136: PUSH
12137: LD_EXP 50
12141: PPUSH
12142: CALL_OW 255
12146: PUSH
12147: LD_INT 7
12149: EQUAL
12150: AND
12151: IFFALSE 12165
// Say ( Belkov , D10-Bel-1 ) ;
12153: LD_EXP 50
12157: PPUSH
12158: LD_STRING D10-Bel-1
12160: PPUSH
12161: CALL_OW 88
// if Gossudarov then
12165: LD_EXP 35
12169: IFFALSE 12183
// Say ( Gossudarov , D10-Gos-1 ) ;
12171: LD_EXP 35
12175: PPUSH
12176: LD_STRING D10-Gos-1
12178: PPUSH
12179: CALL_OW 88
// if Kirilenkova then
12183: LD_EXP 36
12187: IFFALSE 12201
// Say ( Kirilenkova , D10-Kir-1 ) ;
12189: LD_EXP 36
12193: PPUSH
12194: LD_STRING D10-Kir-1
12196: PPUSH
12197: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12201: CALL 15897 0 0
12205: PPUSH
12206: LD_STRING D10-RSol1-1
12208: PPUSH
12209: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12213: LD_EXP 49
12217: PPUSH
12218: LD_STRING D10-Bur-2
12220: PPUSH
12221: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12225: LD_EXP 17
12229: PPUSH
12230: LD_STRING D10-JMM-2
12232: PPUSH
12233: CALL_OW 88
// if Kirilenkova then
12237: LD_EXP 36
12241: IFFALSE 12257
// Say ( Kirilenkova , D10-Kir-2 ) else
12243: LD_EXP 36
12247: PPUSH
12248: LD_STRING D10-Kir-2
12250: PPUSH
12251: CALL_OW 88
12255: GO 12269
// Say ( SolRu , D10-RSol1-2 ) ;
12257: CALL 15897 0 0
12261: PPUSH
12262: LD_STRING D10-RSol1-2
12264: PPUSH
12265: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12269: LD_EXP 17
12273: PPUSH
12274: LD_STRING D10-JMM-3
12276: PPUSH
12277: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12281: LD_EXP 49
12285: PPUSH
12286: LD_STRING D10-Bur-3
12288: PPUSH
12289: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12293: LD_EXP 17
12297: PPUSH
12298: LD_STRING D10-JMM-4
12300: PPUSH
12301: CALL_OW 88
// DialogueOff ;
12305: CALL_OW 7
// InGameOff ;
12309: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12313: LD_STRING M2
12315: PPUSH
12316: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12320: LD_INT 35
12322: PPUSH
12323: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12327: LD_INT 22
12329: PUSH
12330: LD_INT 7
12332: PUSH
12333: EMPTY
12334: LIST
12335: LIST
12336: PUSH
12337: LD_INT 91
12339: PUSH
12340: LD_EXP 49
12344: PUSH
12345: LD_INT 8
12347: PUSH
12348: EMPTY
12349: LIST
12350: LIST
12351: LIST
12352: PUSH
12353: EMPTY
12354: LIST
12355: LIST
12356: PPUSH
12357: CALL_OW 69
12361: IFFALSE 12320
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12363: LD_ADDR_VAR 0 1
12367: PUSH
12368: LD_INT 22
12370: PUSH
12371: LD_INT 4
12373: PUSH
12374: EMPTY
12375: LIST
12376: LIST
12377: PPUSH
12378: CALL_OW 69
12382: PUSH
12383: FOR_IN
12384: IFFALSE 12400
// SetSide ( i , 7 ) ;
12386: LD_VAR 0 1
12390: PPUSH
12391: LD_INT 7
12393: PPUSH
12394: CALL_OW 235
12398: GO 12383
12400: POP
12401: POP
// ChangeMissionObjectives ( M3 ) ;
12402: LD_STRING M3
12404: PPUSH
12405: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12409: LD_INT 35
12411: PPUSH
12412: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12416: LD_EXP 17
12420: PPUSH
12421: LD_EXP 49
12425: PPUSH
12426: CALL_OW 296
12430: PUSH
12431: LD_INT 8
12433: LESS
12434: IFFALSE 12409
// ComTurnUnit ( JMM , Burlak ) ;
12436: LD_EXP 17
12440: PPUSH
12441: LD_EXP 49
12445: PPUSH
12446: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12450: LD_EXP 49
12454: PPUSH
12455: LD_EXP 17
12459: PPUSH
12460: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12464: LD_INT 10
12466: PPUSH
12467: CALL_OW 67
// DialogueOn ;
12471: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12475: LD_EXP 17
12479: PPUSH
12480: LD_STRING D11-JMM-1
12482: PPUSH
12483: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12487: LD_EXP 49
12491: PPUSH
12492: LD_STRING D11-Bur-1
12494: PPUSH
12495: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12499: LD_EXP 17
12503: PPUSH
12504: LD_STRING D11-JMM-2
12506: PPUSH
12507: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12511: LD_EXP 49
12515: PPUSH
12516: LD_STRING D11-Bur-2
12518: PPUSH
12519: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12523: LD_EXP 17
12527: PPUSH
12528: LD_STRING D11-JMM-3
12530: PPUSH
12531: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12535: LD_EXP 49
12539: PPUSH
12540: LD_STRING D11-Bur-3
12542: PPUSH
12543: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12547: LD_EXP 17
12551: PPUSH
12552: LD_STRING D11-JMM-4
12554: PPUSH
12555: CALL_OW 88
// if ar_base_spotted then
12559: LD_EXP 9
12563: IFFALSE 12579
// Say ( Burlak , D12-Bur-1 ) else
12565: LD_EXP 49
12569: PPUSH
12570: LD_STRING D12-Bur-1
12572: PPUSH
12573: CALL_OW 88
12577: GO 12618
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12579: LD_INT 7
12581: PPUSH
12582: LD_INT 3
12584: PPUSH
12585: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12589: LD_INT 127
12591: PPUSH
12592: LD_INT 45
12594: PPUSH
12595: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12599: LD_EXP 49
12603: PPUSH
12604: LD_STRING D12-Bur-1a
12606: PPUSH
12607: CALL_OW 88
// dwait ( 0 0$2 ) ;
12611: LD_INT 70
12613: PPUSH
12614: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12618: LD_EXP 58
12622: PPUSH
12623: CALL_OW 302
12627: NOT
12628: IFFALSE 12636
// begin DialogueOff ;
12630: CALL_OW 7
// exit ;
12634: GO 13104
// end ; Say ( Burlak , D12-Bur-1b ) ;
12636: LD_EXP 49
12640: PPUSH
12641: LD_STRING D12-Bur-1b
12643: PPUSH
12644: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12648: LD_EXP 17
12652: PPUSH
12653: LD_STRING D12-JMM-1
12655: PPUSH
12656: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12660: LD_EXP 49
12664: PPUSH
12665: LD_STRING D12-Bur-2
12667: PPUSH
12668: CALL_OW 88
// if Roth then
12672: LD_EXP 18
12676: IFFALSE 12692
// Say ( Roth , D12-Roth-2 ) else
12678: LD_EXP 18
12682: PPUSH
12683: LD_STRING D12-Roth-2
12685: PPUSH
12686: CALL_OW 88
12690: GO 12704
// Say ( SciRu , D12-RSci1-2 ) ;
12692: CALL 15750 0 0
12696: PPUSH
12697: LD_STRING D12-RSci1-2
12699: PPUSH
12700: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12704: LD_EXP 17
12708: PPUSH
12709: LD_STRING D12-JMM-2
12711: PPUSH
12712: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12716: LD_EXP 49
12720: PPUSH
12721: LD_STRING D12-Bur-3
12723: PPUSH
12724: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12728: LD_EXP 17
12732: PPUSH
12733: LD_STRING D12-JMM-3
12735: PPUSH
12736: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12740: LD_EXP 49
12744: PPUSH
12745: LD_STRING D12-Bur-4
12747: PPUSH
12748: CALL_OW 88
// case Query ( QBase ) of 1 :
12752: LD_STRING QBase
12754: PPUSH
12755: CALL_OW 97
12759: PUSH
12760: LD_INT 1
12762: DOUBLE
12763: EQUAL
12764: IFTRUE 12768
12766: GO 12886
12768: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12769: LD_EXP 17
12773: PPUSH
12774: LD_STRING D13a-JMM-1
12776: PPUSH
12777: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12781: LD_EXP 49
12785: PPUSH
12786: LD_STRING D13a-Bur-1
12788: PPUSH
12789: CALL_OW 88
// if Roth then
12793: LD_EXP 18
12797: IFFALSE 12813
// Say ( Roth , D13a-Roth-1 ) else
12799: LD_EXP 18
12803: PPUSH
12804: LD_STRING D13a-Roth-1
12806: PPUSH
12807: CALL_OW 88
12811: GO 12825
// Say ( SciRu , D13a-RSci1-1 ) ;
12813: CALL 15750 0 0
12817: PPUSH
12818: LD_STRING D13a-RSci1-1
12820: PPUSH
12821: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12825: LD_EXP 17
12829: PPUSH
12830: LD_STRING D13a-JMM-2
12832: PPUSH
12833: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12837: LD_STRING QBaseAgain
12839: PPUSH
12840: CALL_OW 97
12844: PUSH
12845: LD_INT 1
12847: DOUBLE
12848: EQUAL
12849: IFTRUE 12853
12851: GO 12864
12853: POP
// selected_option := 2 ; 2 :
12854: LD_ADDR_VAR 0 2
12858: PUSH
12859: LD_INT 2
12861: ST_TO_ADDR
12862: GO 12884
12864: LD_INT 2
12866: DOUBLE
12867: EQUAL
12868: IFTRUE 12872
12870: GO 12883
12872: POP
// selected_option := 3 ; end ;
12873: LD_ADDR_VAR 0 2
12877: PUSH
12878: LD_INT 3
12880: ST_TO_ADDR
12881: GO 12884
12883: POP
// end ; 2 :
12884: GO 12925
12886: LD_INT 2
12888: DOUBLE
12889: EQUAL
12890: IFTRUE 12894
12892: GO 12905
12894: POP
// selected_option := 2 ; 3 :
12895: LD_ADDR_VAR 0 2
12899: PUSH
12900: LD_INT 2
12902: ST_TO_ADDR
12903: GO 12925
12905: LD_INT 3
12907: DOUBLE
12908: EQUAL
12909: IFTRUE 12913
12911: GO 12924
12913: POP
// selected_option := 3 ; end ;
12914: LD_ADDR_VAR 0 2
12918: PUSH
12919: LD_INT 3
12921: ST_TO_ADDR
12922: GO 12925
12924: POP
// if selected_option = 2 then
12925: LD_VAR 0 2
12929: PUSH
12930: LD_INT 2
12932: EQUAL
12933: IFFALSE 13037
// begin Say ( JMM , D13b-JMM-1 ) ;
12935: LD_EXP 17
12939: PPUSH
12940: LD_STRING D13b-JMM-1
12942: PPUSH
12943: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12947: LD_EXP 49
12951: PPUSH
12952: LD_STRING D13b-Bur-1
12954: PPUSH
12955: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12959: LD_EXP 17
12963: PPUSH
12964: LD_STRING D13b-JMM-2
12966: PPUSH
12967: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12971: LD_EXP 58
12975: PPUSH
12976: LD_STRING D13b-Abd-2
12978: PPUSH
12979: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12983: LD_EXP 17
12987: PPUSH
12988: LD_STRING D13b-JMM-3
12990: PPUSH
12991: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12995: LD_EXP 58
12999: PPUSH
13000: LD_STRING D13b-Abd-3
13002: PPUSH
13003: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
13007: LD_EXP 17
13011: PPUSH
13012: LD_STRING D13b-JMM-4
13014: PPUSH
13015: CALL_OW 88
// ar_active_attack := true ;
13019: LD_ADDR_EXP 10
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
13027: LD_INT 1
13029: PPUSH
13030: LD_STRING 13a_negotiationWithArabs
13032: PPUSH
13033: CALL_OW 39
// end ; if selected_option = 3 then
13037: LD_VAR 0 2
13041: PUSH
13042: LD_INT 3
13044: EQUAL
13045: IFFALSE 13071
// begin Say ( JMM , D13c-JMM-1 ) ;
13047: LD_EXP 17
13051: PPUSH
13052: LD_STRING D13c-JMM-1
13054: PPUSH
13055: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
13059: LD_EXP 49
13063: PPUSH
13064: LD_STRING D13c-Bur-1
13066: PPUSH
13067: CALL_OW 88
// end ; DialogueOff ;
13071: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
13075: LD_STRING M4
13077: PPUSH
13078: CALL_OW 337
// if not ar_active_attack then
13082: LD_EXP 10
13086: NOT
13087: IFFALSE 13104
// begin wait ( 6 6$00 ) ;
13089: LD_INT 12600
13091: PPUSH
13092: CALL_OW 67
// ar_active_attack := true ;
13096: LD_ADDR_EXP 10
13100: PUSH
13101: LD_INT 1
13103: ST_TO_ADDR
// end ; end ;
13104: PPOPN 2
13106: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13107: LD_EXP 49
13111: PPUSH
13112: CALL_OW 305
13116: IFFALSE 13133
13118: PUSH
13119: LD_EXP 49
13123: PPUSH
13124: CALL_OW 255
13128: PUSH
13129: LD_INT 7
13131: EQUAL
13132: AND
13133: IFFALSE 13360
13135: GO 13137
13137: DISABLE
13138: LD_INT 0
13140: PPUSH
// begin wait ( 4 4$40 ) ;
13141: LD_INT 9800
13143: PPUSH
13144: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13148: LD_INT 35
13150: PPUSH
13151: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13155: LD_EXP 55
13159: NOT
13160: IFFALSE 13189
13162: PUSH
13163: LD_INT 22
13165: PUSH
13166: LD_INT 6
13168: PUSH
13169: EMPTY
13170: LIST
13171: LIST
13172: PUSH
13173: LD_INT 50
13175: PUSH
13176: EMPTY
13177: LIST
13178: PUSH
13179: EMPTY
13180: LIST
13181: LIST
13182: PPUSH
13183: CALL_OW 69
13187: NOT
13188: AND
13189: IFFALSE 13148
// PrepareGnyevko ;
13191: CALL 2318 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13195: LD_EXP 51
13199: PPUSH
13200: LD_INT 124
13202: PPUSH
13203: LD_INT 118
13205: PPUSH
13206: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13210: LD_EXP 51
13214: PPUSH
13215: CALL_OW 200
// time := 0 0$00 ;
13219: LD_ADDR_VAR 0 1
13223: PUSH
13224: LD_INT 0
13226: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13227: LD_INT 35
13229: PPUSH
13230: CALL_OW 67
// time := time + 0 0$1 ;
13234: LD_ADDR_VAR 0 1
13238: PUSH
13239: LD_VAR 0 1
13243: PUSH
13244: LD_INT 35
13246: PLUS
13247: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13248: LD_EXP 51
13252: PPUSH
13253: LD_INT 124
13255: PPUSH
13256: LD_INT 118
13258: PPUSH
13259: CALL_OW 307
13263: IFTRUE 13275
13265: PUSH
13266: LD_VAR 0 1
13270: PUSH
13271: LD_INT 1050
13273: GREATEREQUAL
13274: OR
13275: IFFALSE 13227
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13277: LD_EXP 51
13281: PPUSH
13282: LD_STRING DBelkov-Gny-1
13284: PPUSH
13285: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13289: LD_EXP 49
13293: PPUSH
13294: LD_STRING DBelkov-Bur-1a
13296: PPUSH
13297: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13301: LD_INT 35
13303: PPUSH
13304: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13308: LD_EXP 51
13312: PPUSH
13313: LD_INT 22
13315: PUSH
13316: LD_INT 7
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PPUSH
13323: CALL_OW 69
13327: PPUSH
13328: LD_EXP 51
13332: PPUSH
13333: CALL_OW 74
13337: PPUSH
13338: CALL_OW 296
13342: PUSH
13343: LD_INT 8
13345: LESS
13346: IFFALSE 13301
// SetSide ( Gnyevko , 7 ) ;
13348: LD_EXP 51
13352: PPUSH
13353: LD_INT 7
13355: PPUSH
13356: CALL_OW 235
// end ;
13360: PPOPN 1
13362: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13363: LD_EXP 49
13367: PPUSH
13368: CALL_OW 255
13372: PUSH
13373: LD_INT 7
13375: EQUAL
13376: IFFALSE 13386
13378: GO 13380
13380: DISABLE
// begin enable ;
13381: ENABLE
// PrepareAmericanAttack ;
13382: CALL 8687 0 0
// end ;
13386: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13387: LD_INT 22
13389: PUSH
13390: LD_INT 1
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PPUSH
13397: CALL_OW 69
13401: IFFALSE 13585
13403: GO 13405
13405: DISABLE
13406: LD_INT 0
13408: PPUSH
13409: PPUSH
// begin while true do
13410: LD_INT 1
13412: IFFALSE 13469
// begin wait ( 0 0$1 ) ;
13414: LD_INT 35
13416: PPUSH
13417: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13421: LD_ADDR_VAR 0 2
13425: PUSH
13426: LD_INT 22
13428: PUSH
13429: LD_INT 1
13431: PUSH
13432: EMPTY
13433: LIST
13434: LIST
13435: PPUSH
13436: CALL_OW 69
13440: PPUSH
13441: LD_EXP 17
13445: PPUSH
13446: CALL_OW 74
13450: ST_TO_ADDR
// if See ( 7 , tmp ) then
13451: LD_INT 7
13453: PPUSH
13454: LD_VAR 0 2
13458: PPUSH
13459: CALL_OW 292
13463: IFFALSE 13467
// break ;
13465: GO 13469
// end ;
13467: GO 13410
// DialogueOn ;
13469: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13473: LD_VAR 0 2
13477: PPUSH
13478: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13482: LD_VAR 0 2
13486: PPUSH
13487: CALL_OW 250
13491: PPUSH
13492: LD_VAR 0 2
13496: PPUSH
13497: CALL_OW 251
13501: PPUSH
13502: LD_INT 7
13504: PPUSH
13505: LD_INT 8
13507: PPUSH
13508: CALL_OW 330
// if Denis then
13512: LD_EXP 23
13516: IFFALSE 13530
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13518: LD_EXP 23
13522: PPUSH
13523: LD_STRING DAmerAttack-Pet-1
13525: PPUSH
13526: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13530: LD_EXP 17
13534: PPUSH
13535: LD_STRING DAmerAttack-JMM-1
13537: PPUSH
13538: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13542: LD_EXP 49
13546: PPUSH
13547: LD_STRING DStop-Bur-1
13549: PPUSH
13550: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13554: LD_VAR 0 2
13558: PPUSH
13559: CALL_OW 250
13563: PPUSH
13564: LD_VAR 0 2
13568: PPUSH
13569: CALL_OW 251
13573: PPUSH
13574: LD_INT 7
13576: PPUSH
13577: CALL_OW 331
// DialogueOff ;
13581: CALL_OW 7
// end ;
13585: PPOPN 2
13587: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13588: LD_INT 22
13590: PUSH
13591: LD_INT 3
13593: PUSH
13594: EMPTY
13595: LIST
13596: LIST
13597: PUSH
13598: LD_INT 21
13600: PUSH
13601: LD_INT 1
13603: PUSH
13604: EMPTY
13605: LIST
13606: LIST
13607: PUSH
13608: EMPTY
13609: LIST
13610: LIST
13611: PPUSH
13612: CALL_OW 69
13616: PUSH
13617: LD_INT 0
13619: EQUAL
13620: IFFALSE 13670
13622: GO 13624
13624: DISABLE
// begin ru_active_attack := false ;
13625: LD_ADDR_EXP 6
13629: PUSH
13630: LD_INT 0
13632: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13633: LD_STRING M5a
13635: PPUSH
13636: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13640: LD_EXP 17
13644: PPUSH
13645: LD_STRING D8-JMM-1
13647: PPUSH
13648: CALL_OW 88
// if Gossudarov then
13652: LD_EXP 35
13656: IFFALSE 13670
// Say ( Gossudarov , D8-Gos-1 ) ;
13658: LD_EXP 35
13662: PPUSH
13663: LD_STRING D8-Gos-1
13665: PPUSH
13666: CALL_OW 88
// end ;
13670: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13671: LD_INT 22
13673: PUSH
13674: LD_INT 2
13676: PUSH
13677: EMPTY
13678: LIST
13679: LIST
13680: PUSH
13681: LD_INT 21
13683: PUSH
13684: LD_INT 1
13686: PUSH
13687: EMPTY
13688: LIST
13689: LIST
13690: PUSH
13691: EMPTY
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 69
13699: PUSH
13700: LD_INT 0
13702: EQUAL
13703: IFFALSE 13761
13705: GO 13707
13707: DISABLE
// begin ar_active_attack := false ;
13708: LD_ADDR_EXP 10
13712: PUSH
13713: LD_INT 0
13715: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13716: LD_STRING M4c
13718: PPUSH
13719: CALL_OW 337
// if Roth then
13723: LD_EXP 18
13727: IFFALSE 13743
// Say ( Roth , DStop-Roth-1 ) else
13729: LD_EXP 18
13733: PPUSH
13734: LD_STRING DStop-Roth-1
13736: PPUSH
13737: CALL_OW 88
13741: GO 13761
// if Gossudarov then
13743: LD_EXP 35
13747: IFFALSE 13761
// Say ( Gossudarov , D8-Gos-1a ) ;
13749: LD_EXP 35
13753: PPUSH
13754: LD_STRING D8-Gos-1a
13756: PPUSH
13757: CALL_OW 88
// end ;
13761: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13762: LD_INT 3
13764: PPUSH
13765: CALL_OW 469
13769: IFFALSE 13777
13771: PUSH
13772: LD_EXP 13
13776: AND
13777: IFFALSE 13832
13779: GO 13781
13781: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13782: LD_INT 3
13784: PPUSH
13785: CALL_OW 469
13789: PPUSH
13790: CALL 9176 0 1
// if Difficulty > 2 then
13794: LD_OWVAR 67
13798: PUSH
13799: LD_INT 2
13801: GREATER
13802: IFFALSE 13832
// begin wait ( 5 5$00 ) ;
13804: LD_INT 10500
13806: PPUSH
13807: CALL_OW 67
// if FindArtifact ( 3 ) then
13811: LD_INT 3
13813: PPUSH
13814: CALL_OW 469
13818: IFFALSE 13832
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13820: LD_INT 3
13822: PPUSH
13823: CALL_OW 469
13827: PPUSH
13828: CALL 9176 0 1
// end ; end ;
13832: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13833: LD_INT 7
13835: PPUSH
13836: LD_INT 1
13838: PPUSH
13839: LD_INT 1
13841: PPUSH
13842: CALL 17545 0 3
13846: PUSH
13847: LD_INT 0
13849: EQUAL
13850: IFFALSE 13871
13852: PUSH
13853: LD_INT 7
13855: PPUSH
13856: LD_INT 3
13858: PPUSH
13859: LD_INT 1
13861: PPUSH
13862: CALL 17545 0 3
13866: PUSH
13867: LD_INT 0
13869: EQUAL
13870: AND
13871: IFFALSE 13883
13873: GO 13875
13875: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13876: LD_STRING M1a
13878: PPUSH
13879: CALL_OW 337
// end ;
13883: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13884: LD_INT 22
13886: PUSH
13887: LD_INT 2
13889: PUSH
13890: EMPTY
13891: LIST
13892: LIST
13893: PUSH
13894: LD_INT 23
13896: PUSH
13897: LD_INT 2
13899: PUSH
13900: EMPTY
13901: LIST
13902: LIST
13903: PUSH
13904: LD_INT 21
13906: PUSH
13907: LD_INT 1
13909: PUSH
13910: EMPTY
13911: LIST
13912: LIST
13913: PUSH
13914: EMPTY
13915: LIST
13916: LIST
13917: LIST
13918: PPUSH
13919: CALL_OW 69
13923: PUSH
13924: LD_INT 0
13926: EQUAL
13927: IFFALSE 13974
13929: PUSH
13930: LD_INT 22
13932: PUSH
13933: LD_INT 3
13935: PUSH
13936: EMPTY
13937: LIST
13938: LIST
13939: PUSH
13940: LD_INT 23
13942: PUSH
13943: LD_INT 3
13945: PUSH
13946: EMPTY
13947: LIST
13948: LIST
13949: PUSH
13950: LD_INT 21
13952: PUSH
13953: LD_INT 1
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: EMPTY
13961: LIST
13962: LIST
13963: LIST
13964: PPUSH
13965: CALL_OW 69
13969: PUSH
13970: LD_INT 0
13972: EQUAL
13973: AND
13974: IFFALSE 13996
13976: PUSH
13977: LD_INT 22
13979: PUSH
13980: LD_INT 1
13982: PUSH
13983: EMPTY
13984: LIST
13985: LIST
13986: PPUSH
13987: CALL_OW 69
13991: PUSH
13992: LD_INT 0
13994: EQUAL
13995: AND
13996: IFFALSE 14017
13998: PUSH
13999: LD_INT 7
14001: PPUSH
14002: LD_INT 1
14004: PPUSH
14005: LD_INT 1
14007: PPUSH
14008: CALL 17545 0 3
14012: PUSH
14013: LD_INT 0
14015: EQUAL
14016: AND
14017: IFFALSE 14038
14019: PUSH
14020: LD_INT 7
14022: PPUSH
14023: LD_INT 3
14025: PPUSH
14026: LD_INT 1
14028: PPUSH
14029: CALL 17545 0 3
14033: PUSH
14034: LD_INT 0
14036: EQUAL
14037: AND
14038: IFFALSE 14055
14040: PUSH
14041: LD_EXP 49
14045: PPUSH
14046: CALL_OW 255
14050: PUSH
14051: LD_INT 7
14053: EQUAL
14054: AND
14055: IFFALSE 14068
14057: PUSH
14058: LD_EXP 49
14062: PPUSH
14063: CALL_OW 302
14067: AND
14068: IFFALSE 15747
14070: GO 14072
14072: DISABLE
14073: LD_INT 0
14075: PPUSH
14076: PPUSH
14077: PPUSH
14078: PPUSH
14079: PPUSH
14080: PPUSH
// begin m1 := false ;
14081: LD_ADDR_VAR 0 4
14085: PUSH
14086: LD_INT 0
14088: ST_TO_ADDR
// m2 := false ;
14089: LD_ADDR_VAR 0 5
14093: PUSH
14094: LD_INT 0
14096: ST_TO_ADDR
// m3 := false ;
14097: LD_ADDR_VAR 0 6
14101: PUSH
14102: LD_INT 0
14104: ST_TO_ADDR
// if tick < 40 40$00 then
14105: LD_OWVAR 1
14109: PUSH
14110: LD_INT 84000
14112: LESS
14113: IFFALSE 14122
// SetAchievement ( ACH_ASPEED_17 ) ;
14115: LD_STRING ACH_ASPEED_17
14117: PPUSH
14118: CALL_OW 543
// wait ( 0 0$5 ) ;
14122: LD_INT 175
14124: PPUSH
14125: CALL_OW 67
// if not masha_killed then
14129: LD_EXP 11
14133: NOT
14134: IFFALSE 14156
// begin m1 := true ;
14136: LD_ADDR_VAR 0 4
14140: PUSH
14141: LD_INT 1
14143: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14144: LD_STRING Masha
14146: PPUSH
14147: LD_INT 1
14149: PPUSH
14150: CALL_OW 101
// end else
14154: GO 14167
// AddMedal ( Masha , - 1 ) ;
14156: LD_STRING Masha
14158: PPUSH
14159: LD_INT 1
14161: NEG
14162: PPUSH
14163: CALL_OW 101
// if abdul_escaped then
14167: LD_EXP 14
14171: IFFALSE 14186
// AddMedal ( Abdul , - 1 ) else
14173: LD_STRING Abdul
14175: PPUSH
14176: LD_INT 1
14178: NEG
14179: PPUSH
14180: CALL_OW 101
14184: GO 14204
// begin m2 := true ;
14186: LD_ADDR_VAR 0 5
14190: PUSH
14191: LD_INT 1
14193: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14194: LD_STRING Abdul
14196: PPUSH
14197: LD_INT 1
14199: PPUSH
14200: CALL_OW 101
// end ; if loss_counter = 0 then
14204: LD_EXP 15
14208: PUSH
14209: LD_INT 0
14211: EQUAL
14212: IFFALSE 14234
// begin m3 := true ;
14214: LD_ADDR_VAR 0 6
14218: PUSH
14219: LD_INT 1
14221: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14222: LD_STRING People
14224: PPUSH
14225: LD_INT 2
14227: PPUSH
14228: CALL_OW 101
// end else
14232: GO 14296
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14234: LD_EXP 15
14238: PUSH
14239: LD_INT 3
14241: PUSH
14242: LD_INT 2
14244: PUSH
14245: LD_INT 2
14247: PUSH
14248: LD_INT 1
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: LIST
14255: LIST
14256: PUSH
14257: LD_OWVAR 67
14261: ARRAY
14262: LESSEQUAL
14263: IFFALSE 14285
// begin AddMedal ( People , 1 ) ;
14265: LD_STRING People
14267: PPUSH
14268: LD_INT 1
14270: PPUSH
14271: CALL_OW 101
// m3 := true ;
14275: LD_ADDR_VAR 0 6
14279: PUSH
14280: LD_INT 1
14282: ST_TO_ADDR
// end else
14283: GO 14296
// AddMedal ( People , - 1 ) ;
14285: LD_STRING People
14287: PPUSH
14288: LD_INT 1
14290: NEG
14291: PPUSH
14292: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14296: LD_OWVAR 67
14300: PUSH
14301: LD_INT 3
14303: GREATEREQUAL
14304: IFFALSE 14312
14306: PUSH
14307: LD_VAR 0 4
14311: AND
14312: IFFALSE 14320
14314: PUSH
14315: LD_VAR 0 5
14319: AND
14320: IFFALSE 14328
14322: PUSH
14323: LD_VAR 0 6
14327: AND
14328: IFFALSE 14340
// SetAchievementEX ( ACH_AMER , 17 ) ;
14330: LD_STRING ACH_AMER
14332: PPUSH
14333: LD_INT 17
14335: PPUSH
14336: CALL_OW 564
// GiveMedals ( MAIN ) ;
14340: LD_STRING MAIN
14342: PPUSH
14343: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: LD_INT 22
14354: PUSH
14355: LD_INT 7
14357: PUSH
14358: EMPTY
14359: LIST
14360: LIST
14361: PUSH
14362: LD_INT 50
14364: PUSH
14365: EMPTY
14366: LIST
14367: PUSH
14368: LD_INT 2
14370: PUSH
14371: LD_INT 25
14373: PUSH
14374: LD_INT 1
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: LD_INT 25
14383: PUSH
14384: LD_INT 2
14386: PUSH
14387: EMPTY
14388: LIST
14389: LIST
14390: PUSH
14391: LD_INT 25
14393: PUSH
14394: LD_INT 3
14396: PUSH
14397: EMPTY
14398: LIST
14399: LIST
14400: PUSH
14401: LD_INT 25
14403: PUSH
14404: LD_INT 4
14406: PUSH
14407: EMPTY
14408: LIST
14409: LIST
14410: PUSH
14411: LD_INT 25
14413: PUSH
14414: LD_INT 5
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 25
14423: PUSH
14424: LD_INT 8
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: LD_INT 25
14433: PUSH
14434: LD_INT 9
14436: PUSH
14437: EMPTY
14438: LIST
14439: LIST
14440: PUSH
14441: EMPTY
14442: LIST
14443: LIST
14444: LIST
14445: LIST
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: PUSH
14451: EMPTY
14452: LIST
14453: LIST
14454: LIST
14455: PPUSH
14456: CALL_OW 69
14460: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14461: LD_VAR 0 2
14465: PPUSH
14466: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14470: LD_ADDR_VAR 0 3
14474: PUSH
14475: LD_EXP 17
14479: PUSH
14480: LD_EXP 18
14484: PUSH
14485: LD_EXP 19
14489: PUSH
14490: LD_EXP 20
14494: PUSH
14495: LD_EXP 21
14499: PUSH
14500: LD_EXP 22
14504: PUSH
14505: LD_EXP 23
14509: PUSH
14510: LD_EXP 24
14514: PUSH
14515: LD_EXP 25
14519: PUSH
14520: LD_EXP 26
14524: PUSH
14525: LD_EXP 27
14529: PUSH
14530: LD_EXP 28
14534: PUSH
14535: LD_EXP 29
14539: PUSH
14540: LD_EXP 30
14544: PUSH
14545: LD_EXP 31
14549: PUSH
14550: LD_EXP 32
14554: PUSH
14555: LD_EXP 33
14559: PUSH
14560: LD_EXP 35
14564: PUSH
14565: LD_EXP 36
14569: PUSH
14570: LD_EXP 37
14574: PUSH
14575: LD_EXP 39
14579: PUSH
14580: LD_EXP 40
14584: PUSH
14585: LD_EXP 41
14589: PUSH
14590: LD_EXP 42
14594: PUSH
14595: LD_EXP 43
14599: PUSH
14600: LD_EXP 44
14604: PUSH
14605: LD_EXP 45
14609: PUSH
14610: LD_EXP 46
14614: PUSH
14615: LD_EXP 47
14619: PUSH
14620: LD_EXP 48
14624: PUSH
14625: LD_EXP 49
14629: PUSH
14630: LD_EXP 50
14634: PUSH
14635: LD_EXP 51
14639: PUSH
14640: LD_EXP 34
14644: PUSH
14645: EMPTY
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: LIST
14669: LIST
14670: LIST
14671: LIST
14672: LIST
14673: LIST
14674: LIST
14675: LIST
14676: LIST
14677: LIST
14678: LIST
14679: LIST
14680: ST_TO_ADDR
// if tmp diff tmp2 then
14681: LD_VAR 0 2
14685: PUSH
14686: LD_VAR 0 3
14690: DIFF
14691: IFFALSE 14711
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14693: LD_VAR 0 2
14697: PUSH
14698: LD_VAR 0 3
14702: DIFF
14703: PPUSH
14704: LD_STRING 13a_others
14706: PPUSH
14707: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14711: LD_EXP 17
14715: PPUSH
14716: LD_STRING 13a_JMM
14718: PPUSH
14719: CALL_OW 38
// if IsOk ( Mike ) then
14723: LD_EXP 34
14727: PPUSH
14728: CALL_OW 302
14732: IFFALSE 14746
// SaveCharacters ( Mike , 13a_Mike ) ;
14734: LD_EXP 34
14738: PPUSH
14739: LD_STRING 13a_Mike
14741: PPUSH
14742: CALL_OW 38
// if IsOk ( Titov ) then
14746: LD_EXP 37
14750: PPUSH
14751: CALL_OW 302
14755: IFFALSE 14769
// SaveCharacters ( Titov , 13a_Titov ) ;
14757: LD_EXP 37
14761: PPUSH
14762: LD_STRING 13a_Titov
14764: PPUSH
14765: CALL_OW 38
// if IsOk ( Dolgov ) then
14769: LD_EXP 39
14773: PPUSH
14774: CALL_OW 302
14778: IFFALSE 14792
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14780: LD_EXP 39
14784: PPUSH
14785: LD_STRING 13a_Dolgov
14787: PPUSH
14788: CALL_OW 38
// if IsOk ( Petrosyan ) then
14792: LD_EXP 40
14796: PPUSH
14797: CALL_OW 302
14801: IFFALSE 14815
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14803: LD_EXP 40
14807: PPUSH
14808: LD_STRING 13a_Petrosyan
14810: PPUSH
14811: CALL_OW 38
// if IsOk ( Scholtze ) then
14815: LD_EXP 41
14819: PPUSH
14820: CALL_OW 302
14824: IFFALSE 14838
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14826: LD_EXP 41
14830: PPUSH
14831: LD_STRING 13a_Scholtze
14833: PPUSH
14834: CALL_OW 38
// if IsOk ( Oblukov ) then
14838: LD_EXP 42
14842: PPUSH
14843: CALL_OW 302
14847: IFFALSE 14861
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14849: LD_EXP 42
14853: PPUSH
14854: LD_STRING 13a_Oblukov
14856: PPUSH
14857: CALL_OW 38
// if IsOk ( Kapitsova ) then
14861: LD_EXP 43
14865: PPUSH
14866: CALL_OW 302
14870: IFFALSE 14884
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14872: LD_EXP 43
14876: PPUSH
14877: LD_STRING 13a_Kapitsova
14879: PPUSH
14880: CALL_OW 38
// if IsOk ( Lipshchin ) then
14884: LD_EXP 44
14888: PPUSH
14889: CALL_OW 302
14893: IFFALSE 14907
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14895: LD_EXP 44
14899: PPUSH
14900: LD_STRING 13a_Lipshchin
14902: PPUSH
14903: CALL_OW 38
// if IsOk ( Petrovova ) then
14907: LD_EXP 45
14911: PPUSH
14912: CALL_OW 302
14916: IFFALSE 14930
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14918: LD_EXP 45
14922: PPUSH
14923: LD_STRING 13a_Petrovova
14925: PPUSH
14926: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14930: LD_EXP 46
14934: PPUSH
14935: CALL_OW 302
14939: IFFALSE 14953
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14941: LD_EXP 46
14945: PPUSH
14946: LD_STRING 13a_Kovalyuk
14948: PPUSH
14949: CALL_OW 38
// if IsOk ( Kuzmov ) then
14953: LD_EXP 47
14957: PPUSH
14958: CALL_OW 302
14962: IFFALSE 14976
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14964: LD_EXP 47
14968: PPUSH
14969: LD_STRING 13a_Kuzmov
14971: PPUSH
14972: CALL_OW 38
// if IsOk ( Karamazov ) then
14976: LD_EXP 48
14980: PPUSH
14981: CALL_OW 302
14985: IFFALSE 14999
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14987: LD_EXP 48
14991: PPUSH
14992: LD_STRING 13a_Karamazov
14994: PPUSH
14995: CALL_OW 38
// if Burlak then
14999: LD_EXP 49
15003: IFFALSE 15024
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
15005: LD_STRING enableBioCharacter(BIO_GORKI)
15007: PPUSH
15008: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
15012: LD_EXP 49
15016: PPUSH
15017: LD_STRING 13a_Burlak
15019: PPUSH
15020: CALL_OW 38
// end ; if IsOk ( Belkov ) then
15024: LD_EXP 50
15028: PPUSH
15029: CALL_OW 302
15033: IFFALSE 15047
// SaveCharacters ( Belkov , 13a_Belkov ) ;
15035: LD_EXP 50
15039: PPUSH
15040: LD_STRING 13a_Belkov
15042: PPUSH
15043: CALL_OW 38
// if IsOk ( Gnyevko ) then
15047: LD_EXP 51
15051: PPUSH
15052: CALL_OW 302
15056: IFFALSE 15070
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
15058: LD_EXP 51
15062: PPUSH
15063: LD_STRING 13a_Gnyevko
15065: PPUSH
15066: CALL_OW 38
// if IsOk ( Lisa ) then
15070: LD_EXP 19
15074: PPUSH
15075: CALL_OW 302
15079: IFFALSE 15093
// SaveCharacters ( Lisa , 13a_Lisa ) ;
15081: LD_EXP 19
15085: PPUSH
15086: LD_STRING 13a_Lisa
15088: PPUSH
15089: CALL_OW 38
// if IsOk ( Donaldson ) then
15093: LD_EXP 20
15097: PPUSH
15098: CALL_OW 302
15102: IFFALSE 15116
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
15104: LD_EXP 20
15108: PPUSH
15109: LD_STRING 13a_Donaldson
15111: PPUSH
15112: CALL_OW 38
// if IsOk ( Bobby ) then
15116: LD_EXP 21
15120: PPUSH
15121: CALL_OW 302
15125: IFFALSE 15139
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15127: LD_EXP 21
15131: PPUSH
15132: LD_STRING 13a_Bobby
15134: PPUSH
15135: CALL_OW 38
// if IsOk ( Cyrus ) then
15139: LD_EXP 22
15143: PPUSH
15144: CALL_OW 302
15148: IFFALSE 15162
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15150: LD_EXP 22
15154: PPUSH
15155: LD_STRING 13a_Cyrus
15157: PPUSH
15158: CALL_OW 38
// if IsOk ( Denis ) then
15162: LD_EXP 23
15166: PPUSH
15167: CALL_OW 302
15171: IFFALSE 15185
// SaveCharacters ( Denis , 13a_Denis ) ;
15173: LD_EXP 23
15177: PPUSH
15178: LD_STRING 13a_Denis
15180: PPUSH
15181: CALL_OW 38
// if IsOk ( Brown ) then
15185: LD_EXP 24
15189: PPUSH
15190: CALL_OW 302
15194: IFFALSE 15208
// SaveCharacters ( Brown , 13a_Brown ) ;
15196: LD_EXP 24
15200: PPUSH
15201: LD_STRING 13a_Brown
15203: PPUSH
15204: CALL_OW 38
// if IsOk ( Gladstone ) then
15208: LD_EXP 25
15212: PPUSH
15213: CALL_OW 302
15217: IFFALSE 15231
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15219: LD_EXP 25
15223: PPUSH
15224: LD_STRING 13a_Gladstone
15226: PPUSH
15227: CALL_OW 38
// if IsOk ( Houten ) then
15231: LD_EXP 26
15235: PPUSH
15236: CALL_OW 302
15240: IFFALSE 15254
// SaveCharacters ( Houten , 13a_Houten ) ;
15242: LD_EXP 26
15246: PPUSH
15247: LD_STRING 13a_Houten
15249: PPUSH
15250: CALL_OW 38
// if IsOk ( Cornel ) then
15254: LD_EXP 27
15258: PPUSH
15259: CALL_OW 302
15263: IFFALSE 15277
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15265: LD_EXP 27
15269: PPUSH
15270: LD_STRING 13a_Cornel
15272: PPUSH
15273: CALL_OW 38
// if IsOk ( Gary ) then
15277: LD_EXP 28
15281: PPUSH
15282: CALL_OW 302
15286: IFFALSE 15300
// SaveCharacters ( Gary , 13a_Gary ) ;
15288: LD_EXP 28
15292: PPUSH
15293: LD_STRING 13a_Gary
15295: PPUSH
15296: CALL_OW 38
// if IsOk ( Frank ) then
15300: LD_EXP 29
15304: PPUSH
15305: CALL_OW 302
15309: IFFALSE 15323
// SaveCharacters ( Frank , 13a_Frank ) ;
15311: LD_EXP 29
15315: PPUSH
15316: LD_STRING 13a_Frank
15318: PPUSH
15319: CALL_OW 38
// if IsOk ( Kikuchi ) then
15323: LD_EXP 30
15327: PPUSH
15328: CALL_OW 302
15332: IFFALSE 15346
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15334: LD_EXP 30
15338: PPUSH
15339: LD_STRING 13a_Kikuchi
15341: PPUSH
15342: CALL_OW 38
// if IsOk ( Simms ) then
15346: LD_EXP 31
15350: PPUSH
15351: CALL_OW 302
15355: IFFALSE 15369
// SaveCharacters ( Simms , 13a_Simms ) ;
15357: LD_EXP 31
15361: PPUSH
15362: LD_STRING 13a_Simms
15364: PPUSH
15365: CALL_OW 38
// if IsOk ( Joan ) then
15369: LD_EXP 32
15373: PPUSH
15374: CALL_OW 302
15378: IFFALSE 15392
// SaveCharacters ( Joan , 13a_Joan ) ;
15380: LD_EXP 32
15384: PPUSH
15385: LD_STRING 13a_Joan
15387: PPUSH
15388: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15392: LD_EXP 33
15396: PPUSH
15397: CALL_OW 302
15401: IFFALSE 15415
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15403: LD_EXP 33
15407: PPUSH
15408: LD_STRING 13a_DeltaDoctor
15410: PPUSH
15411: CALL_OW 38
// if IsOk ( Gossudarov ) then
15415: LD_EXP 35
15419: PPUSH
15420: CALL_OW 302
15424: IFFALSE 15438
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15426: LD_EXP 35
15430: PPUSH
15431: LD_STRING 13a_Gossudarov
15433: PPUSH
15434: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15438: LD_EXP 36
15442: PPUSH
15443: CALL_OW 302
15447: IFFALSE 15461
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15449: LD_EXP 36
15453: PPUSH
15454: LD_STRING 13a_Kirilenkova
15456: PPUSH
15457: CALL_OW 38
// if IsOk ( Roth ) then
15461: LD_EXP 18
15465: PPUSH
15466: CALL_OW 302
15470: IFFALSE 15484
// SaveCharacters ( Roth , 13a_Roth ) ;
15472: LD_EXP 18
15476: PPUSH
15477: LD_STRING 13a_Roth
15479: PPUSH
15480: CALL_OW 38
// if Masha then
15484: LD_EXP 52
15488: IFFALSE 15543
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15490: LD_EXP 52
15494: PPUSH
15495: CALL_OW 265
15499: PUSH
15500: LD_EXP 52
15504: PPUSH
15505: CALL_OW 262
15509: PUSH
15510: LD_EXP 52
15514: PPUSH
15515: CALL_OW 263
15519: PUSH
15520: LD_EXP 52
15524: PPUSH
15525: CALL_OW 264
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: PPUSH
15536: LD_STRING 13a_Masha
15538: PPUSH
15539: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15543: LD_ADDR_VAR 0 2
15547: PUSH
15548: LD_INT 21
15550: PUSH
15551: LD_INT 3
15553: PUSH
15554: EMPTY
15555: LIST
15556: LIST
15557: PPUSH
15558: CALL_OW 69
15562: ST_TO_ADDR
// tmp2 := [ ] ;
15563: LD_ADDR_VAR 0 3
15567: PUSH
15568: EMPTY
15569: ST_TO_ADDR
// if tmp then
15570: LD_VAR 0 2
15574: IFFALSE 15725
// for i in tmp do
15576: LD_ADDR_VAR 0 1
15580: PUSH
15581: LD_VAR 0 2
15585: PUSH
15586: FOR_IN
15587: IFFALSE 15723
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15589: LD_ADDR_VAR 0 3
15593: PUSH
15594: LD_VAR 0 3
15598: PUSH
15599: LD_VAR 0 1
15603: PPUSH
15604: CALL_OW 255
15608: PUSH
15609: LD_VAR 0 1
15613: PPUSH
15614: CALL_OW 248
15618: PUSH
15619: LD_VAR 0 1
15623: PPUSH
15624: CALL_OW 266
15628: PUSH
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 250
15638: PUSH
15639: LD_VAR 0 1
15643: PPUSH
15644: CALL_OW 251
15648: PUSH
15649: LD_VAR 0 1
15653: PPUSH
15654: CALL_OW 254
15658: PUSH
15659: LD_VAR 0 1
15663: PPUSH
15664: CALL_OW 267
15668: PUSH
15669: LD_VAR 0 1
15673: PPUSH
15674: LD_INT 1
15676: PPUSH
15677: CALL_OW 268
15681: PUSH
15682: LD_VAR 0 1
15686: PPUSH
15687: LD_INT 2
15689: PPUSH
15690: CALL_OW 268
15694: PUSH
15695: LD_VAR 0 1
15699: PPUSH
15700: CALL_OW 269
15704: PUSH
15705: EMPTY
15706: LIST
15707: LIST
15708: LIST
15709: LIST
15710: LIST
15711: LIST
15712: LIST
15713: LIST
15714: LIST
15715: LIST
15716: PUSH
15717: EMPTY
15718: LIST
15719: ADD
15720: ST_TO_ADDR
15721: GO 15586
15723: POP
15724: POP
// if tmp2 then
15725: LD_VAR 0 3
15729: IFFALSE 15743
// SaveVariable ( tmp2 , 13a_buildings ) ;
15731: LD_VAR 0 3
15735: PPUSH
15736: LD_STRING 13a_buildings
15738: PPUSH
15739: CALL_OW 39
// YouWin ;
15743: CALL_OW 103
// end ;
15747: PPOPN 6
15749: END
// export function SciRu ; var tmp , t ; begin
15750: LD_INT 0
15752: PPUSH
15753: PPUSH
15754: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15755: LD_ADDR_VAR 0 3
15759: PUSH
15760: LD_EXP 35
15764: PUSH
15765: LD_EXP 49
15769: PUSH
15770: LD_EXP 37
15774: PUSH
15775: LD_EXP 50
15779: PUSH
15780: LD_EXP 51
15784: PUSH
15785: LD_EXP 40
15789: PUSH
15790: LD_EXP 41
15794: PUSH
15795: LD_EXP 39
15799: PUSH
15800: EMPTY
15801: LIST
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: LIST
15809: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15810: LD_ADDR_VAR 0 2
15814: PUSH
15815: LD_INT 22
15817: PUSH
15818: LD_INT 7
15820: PUSH
15821: EMPTY
15822: LIST
15823: LIST
15824: PUSH
15825: LD_INT 23
15827: PUSH
15828: LD_INT 3
15830: PUSH
15831: EMPTY
15832: LIST
15833: LIST
15834: PUSH
15835: LD_INT 25
15837: PUSH
15838: LD_INT 4
15840: PUSH
15841: EMPTY
15842: LIST
15843: LIST
15844: PUSH
15845: LD_INT 26
15847: PUSH
15848: LD_INT 1
15850: PUSH
15851: EMPTY
15852: LIST
15853: LIST
15854: PUSH
15855: EMPTY
15856: LIST
15857: LIST
15858: LIST
15859: LIST
15860: PPUSH
15861: CALL_OW 69
15865: PUSH
15866: LD_VAR 0 3
15870: DIFF
15871: ST_TO_ADDR
// if tmp then
15872: LD_VAR 0 2
15876: IFFALSE 15892
// result := tmp [ 1 ] ;
15878: LD_ADDR_VAR 0 1
15882: PUSH
15883: LD_VAR 0 2
15887: PUSH
15888: LD_INT 1
15890: ARRAY
15891: ST_TO_ADDR
// end ;
15892: LD_VAR 0 1
15896: RET
// export function SolRu ; var tmp , t ; begin
15897: LD_INT 0
15899: PPUSH
15900: PPUSH
15901: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15902: LD_ADDR_VAR 0 3
15906: PUSH
15907: LD_EXP 35
15911: PUSH
15912: LD_EXP 49
15916: PUSH
15917: LD_EXP 37
15921: PUSH
15922: LD_EXP 50
15926: PUSH
15927: LD_EXP 51
15931: PUSH
15932: LD_EXP 40
15936: PUSH
15937: LD_EXP 41
15941: PUSH
15942: LD_EXP 39
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: LIST
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: LIST
15956: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15957: LD_ADDR_VAR 0 2
15961: PUSH
15962: LD_INT 22
15964: PUSH
15965: LD_INT 7
15967: PUSH
15968: EMPTY
15969: LIST
15970: LIST
15971: PUSH
15972: LD_INT 23
15974: PUSH
15975: LD_INT 3
15977: PUSH
15978: EMPTY
15979: LIST
15980: LIST
15981: PUSH
15982: LD_INT 25
15984: PUSH
15985: LD_INT 1
15987: PUSH
15988: EMPTY
15989: LIST
15990: LIST
15991: PUSH
15992: LD_INT 26
15994: PUSH
15995: LD_INT 1
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: PUSH
16002: EMPTY
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: PPUSH
16008: CALL_OW 69
16012: PUSH
16013: LD_VAR 0 3
16017: DIFF
16018: ST_TO_ADDR
// if tmp then
16019: LD_VAR 0 2
16023: IFFALSE 16039
// result := tmp [ 1 ] ;
16025: LD_ADDR_VAR 0 1
16029: PUSH
16030: LD_VAR 0 2
16034: PUSH
16035: LD_INT 1
16037: ARRAY
16038: ST_TO_ADDR
// end ; end_of_file
16039: LD_VAR 0 1
16043: RET
// export function CustomEvent ( event ) ; begin
16044: LD_INT 0
16046: PPUSH
// end ;
16047: LD_VAR 0 2
16051: RET
// on UnitDestroyed ( un ) do var i , side ;
16052: LD_INT 0
16054: PPUSH
16055: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
16056: LD_VAR 0 1
16060: PPUSH
16061: CALL 108049 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
16065: LD_VAR 0 1
16069: PUSH
16070: LD_INT 22
16072: PUSH
16073: LD_INT 7
16075: PUSH
16076: EMPTY
16077: LIST
16078: LIST
16079: PUSH
16080: LD_INT 2
16082: PUSH
16083: LD_INT 25
16085: PUSH
16086: LD_INT 1
16088: PUSH
16089: EMPTY
16090: LIST
16091: LIST
16092: PUSH
16093: LD_INT 25
16095: PUSH
16096: LD_INT 2
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 25
16105: PUSH
16106: LD_INT 3
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: LD_INT 25
16115: PUSH
16116: LD_INT 4
16118: PUSH
16119: EMPTY
16120: LIST
16121: LIST
16122: PUSH
16123: LD_INT 25
16125: PUSH
16126: LD_INT 5
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PUSH
16133: LD_INT 25
16135: PUSH
16136: LD_INT 8
16138: PUSH
16139: EMPTY
16140: LIST
16141: LIST
16142: PUSH
16143: LD_INT 25
16145: PUSH
16146: LD_INT 9
16148: PUSH
16149: EMPTY
16150: LIST
16151: LIST
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: LIST
16157: LIST
16158: LIST
16159: LIST
16160: LIST
16161: LIST
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PPUSH
16167: CALL_OW 69
16171: IN
16172: IFFALSE 16188
// loss_counter := loss_counter + 1 ;
16174: LD_ADDR_EXP 15
16178: PUSH
16179: LD_EXP 15
16183: PUSH
16184: LD_INT 1
16186: PLUS
16187: ST_TO_ADDR
// if un = Abdul then
16188: LD_VAR 0 1
16192: PUSH
16193: LD_EXP 58
16197: EQUAL
16198: IFFALSE 16208
// abdul_escaped := false ;
16200: LD_ADDR_EXP 14
16204: PUSH
16205: LD_INT 0
16207: ST_TO_ADDR
// if un in ru_attackers then
16208: LD_VAR 0 1
16212: PUSH
16213: LD_EXP 55
16217: IN
16218: IFFALSE 16236
// ru_attackers := ru_attackers diff un ;
16220: LD_ADDR_EXP 55
16224: PUSH
16225: LD_EXP 55
16229: PUSH
16230: LD_VAR 0 1
16234: DIFF
16235: ST_TO_ADDR
// if un in ar_attackers then
16236: LD_VAR 0 1
16240: PUSH
16241: LD_EXP 12
16245: IN
16246: IFFALSE 16264
// ar_attackers := ar_attackers diff un ;
16248: LD_ADDR_EXP 12
16252: PUSH
16253: LD_EXP 12
16257: PUSH
16258: LD_VAR 0 1
16262: DIFF
16263: ST_TO_ADDR
// if un = JMM then
16264: LD_VAR 0 1
16268: PUSH
16269: LD_EXP 17
16273: EQUAL
16274: IFFALSE 16285
// begin YouLost ( JMM ) ;
16276: LD_STRING JMM
16278: PPUSH
16279: CALL_OW 104
// exit ;
16283: GO 16382
// end ; if un = Burlak then
16285: LD_VAR 0 1
16289: PUSH
16290: LD_EXP 49
16294: EQUAL
16295: IFFALSE 16306
// begin YouLost ( Burlak ) ;
16297: LD_STRING Burlak
16299: PPUSH
16300: CALL_OW 104
// exit ;
16304: GO 16382
// end ; if un = freedom then
16306: LD_VAR 0 1
16310: PUSH
16311: LD_EXP 3
16315: EQUAL
16316: IFFALSE 16327
// begin YouLost ( Destroyed ) ;
16318: LD_STRING Destroyed
16320: PPUSH
16321: CALL_OW 104
// exit ;
16325: GO 16382
// end ; if un = Masha then
16327: LD_VAR 0 1
16331: PUSH
16332: LD_EXP 52
16336: EQUAL
16337: IFFALSE 16354
// begin ChangeMissionObjectives ( M4b ) ;
16339: LD_STRING M4b
16341: PPUSH
16342: CALL_OW 337
// masha_killed := true ;
16346: LD_ADDR_EXP 11
16350: PUSH
16351: LD_INT 1
16353: ST_TO_ADDR
// end ; if un = Mastodont then
16354: LD_VAR 0 1
16358: PUSH
16359: LD_EXP 59
16363: EQUAL
16364: IFFALSE 16373
// ChangeMissionObjectives ( M4a ) ;
16366: LD_STRING M4a
16368: PPUSH
16369: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16373: LD_VAR 0 1
16377: PPUSH
16378: CALL 88952 0 1
// end ;
16382: PPOPN 3
16384: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16385: LD_VAR 0 1
16389: PPUSH
16390: LD_VAR 0 2
16394: PPUSH
16395: CALL 91306 0 2
// end ;
16399: PPOPN 2
16401: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16402: LD_VAR 0 1
16406: PPUSH
16407: CALL 90370 0 1
// end ;
16411: PPOPN 1
16413: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16414: LD_VAR 0 1
16418: PUSH
16419: LD_INT 22
16421: PUSH
16422: LD_INT 7
16424: PUSH
16425: EMPTY
16426: LIST
16427: LIST
16428: PUSH
16429: LD_INT 30
16431: PUSH
16432: LD_INT 0
16434: PUSH
16435: EMPTY
16436: LIST
16437: LIST
16438: PUSH
16439: EMPTY
16440: LIST
16441: LIST
16442: PPUSH
16443: CALL_OW 69
16447: IN
16448: IFFALSE 16487
// begin SetBName ( building , freedom ) ;
16450: LD_VAR 0 1
16454: PPUSH
16455: LD_STRING freedom
16457: PPUSH
16458: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16462: LD_INT 0
16464: PPUSH
16465: LD_INT 7
16467: PPUSH
16468: LD_INT 0
16470: PPUSH
16471: CALL_OW 324
// freedom := building ;
16475: LD_ADDR_EXP 3
16479: PUSH
16480: LD_VAR 0 1
16484: ST_TO_ADDR
// exit ;
16485: GO 16553
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16487: LD_VAR 0 1
16491: PUSH
16492: LD_INT 22
16494: PUSH
16495: LD_INT 7
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: LD_INT 23
16504: PUSH
16505: LD_INT 3
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 30
16514: PUSH
16515: LD_INT 6
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: EMPTY
16523: LIST
16524: LIST
16525: LIST
16526: PPUSH
16527: CALL_OW 69
16531: IN
16532: IFFALSE 16544
// begin ru_lab_builded := true ;
16534: LD_ADDR_EXP 5
16538: PUSH
16539: LD_INT 1
16541: ST_TO_ADDR
// exit ;
16542: GO 16553
// end ; MCE_BuildingComplete ( building ) ;
16544: LD_VAR 0 1
16548: PPUSH
16549: CALL 90613 0 1
// end ;
16553: PPOPN 1
16555: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16556: LD_VAR 0 1
16560: PPUSH
16561: LD_VAR 0 2
16565: PPUSH
16566: CALL 88640 0 2
// end ;
16570: PPOPN 2
16572: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16573: LD_VAR 0 1
16577: PPUSH
16578: LD_VAR 0 2
16582: PPUSH
16583: LD_VAR 0 3
16587: PPUSH
16588: LD_VAR 0 4
16592: PPUSH
16593: LD_VAR 0 5
16597: PPUSH
16598: CALL 88258 0 5
// end ;
16602: PPOPN 5
16604: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16605: LD_VAR 0 1
16609: PPUSH
16610: LD_VAR 0 2
16614: PPUSH
16615: CALL 108107 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16619: LD_VAR 0 1
16623: PPUSH
16624: LD_VAR 0 2
16628: PPUSH
16629: CALL 87807 0 2
// end ;
16633: PPOPN 2
16635: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16636: LD_VAR 0 1
16640: PPUSH
16641: CALL_OW 263
16645: PUSH
16646: LD_INT 3
16648: EQUAL
16649: IFTRUE 16666
16651: PUSH
16652: LD_VAR 0 2
16656: PPUSH
16657: CALL_OW 263
16661: PUSH
16662: LD_INT 3
16664: EQUAL
16665: OR
16666: IFFALSE 16682
// hack_counter := hack_counter + 1 ;
16668: LD_ADDR_EXP 16
16672: PUSH
16673: LD_EXP 16
16677: PUSH
16678: LD_INT 1
16680: PLUS
16681: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16682: LD_VAR 0 1
16686: PPUSH
16687: LD_VAR 0 2
16691: PPUSH
16692: LD_VAR 0 3
16696: PPUSH
16697: LD_VAR 0 4
16701: PPUSH
16702: CALL 87639 0 4
// end ;
16706: PPOPN 4
16708: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16709: LD_VAR 0 1
16713: PUSH
16714: LD_INT 47
16716: EQUAL
16717: IFFALSE 16739
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16719: LD_VAR 0 1
16723: PPUSH
16724: CALL_OW 274
16728: PPUSH
16729: LD_INT 1
16731: PPUSH
16732: LD_INT 600
16734: PPUSH
16735: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16739: LD_VAR 0 1
16743: PPUSH
16744: LD_VAR 0 2
16748: PPUSH
16749: LD_VAR 0 3
16753: PPUSH
16754: CALL 87412 0 3
// end ;
16758: PPOPN 3
16760: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16761: LD_VAR 0 1
16765: PPUSH
16766: LD_VAR 0 2
16770: PPUSH
16771: CALL 87295 0 2
// end ;
16775: PPOPN 2
16777: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16778: LD_VAR 0 1
16782: PPUSH
16783: LD_VAR 0 2
16787: PPUSH
16788: CALL 91603 0 2
// end ;
16792: PPOPN 2
16794: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16795: LD_VAR 0 1
16799: PPUSH
16800: LD_VAR 0 2
16804: PPUSH
16805: LD_VAR 0 3
16809: PPUSH
16810: LD_VAR 0 4
16814: PPUSH
16815: CALL 91827 0 4
// end ;
16819: PPOPN 4
16821: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16822: LD_VAR 0 1
16826: PPUSH
16827: LD_VAR 0 2
16831: PPUSH
16832: CALL 87102 0 2
// end ;
16836: PPOPN 2
16838: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16839: LD_VAR 0 1
16843: PPUSH
16844: CALL 108091 0 1
// end ; end_of_file
16848: PPOPN 1
16850: END
// every 0 0$30 do var cr , time ;
16851: GO 16853
16853: DISABLE
16854: LD_INT 0
16856: PPUSH
16857: PPUSH
// begin time := 0 0$20 ;
16858: LD_ADDR_VAR 0 2
16862: PUSH
16863: LD_INT 700
16865: ST_TO_ADDR
// while game do
16866: LD_EXP 2
16870: IFFALSE 16973
// begin wait ( time ) ;
16872: LD_VAR 0 2
16876: PPUSH
16877: CALL_OW 67
// if tick > 2 2$00 then
16881: LD_OWVAR 1
16885: PUSH
16886: LD_INT 4200
16888: GREATER
16889: IFFALSE 16926
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16891: LD_ADDR_VAR 0 2
16895: PUSH
16896: LD_VAR 0 2
16900: PUSH
16901: LD_INT 140
16903: PUSH
16904: LD_INT 140
16906: PUSH
16907: LD_INT 210
16909: PUSH
16910: LD_INT 280
16912: PUSH
16913: EMPTY
16914: LIST
16915: LIST
16916: LIST
16917: LIST
16918: PUSH
16919: LD_OWVAR 67
16923: ARRAY
16924: PLUS
16925: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16926: LD_INT 1
16928: PPUSH
16929: LD_INT 5
16931: PPUSH
16932: CALL_OW 12
16936: PPUSH
16937: LD_INT 70
16939: PPUSH
16940: LD_INT 49
16942: PPUSH
16943: LD_INT 25
16945: PPUSH
16946: LD_INT 1
16948: PPUSH
16949: CALL_OW 56
// if time > 3 3$00 then
16953: LD_VAR 0 2
16957: PUSH
16958: LD_INT 6300
16960: GREATER
16961: IFFALSE 16971
// time := 0 0$30 ;
16963: LD_ADDR_VAR 0 2
16967: PUSH
16968: LD_INT 1050
16970: ST_TO_ADDR
// end ;
16971: GO 16866
// end ;
16973: PPOPN 2
16975: END
// every 0 0$30 do var cr , time ;
16976: GO 16978
16978: DISABLE
16979: LD_INT 0
16981: PPUSH
16982: PPUSH
// begin time := 0 0$20 ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_INT 700
16990: ST_TO_ADDR
// while game do
16991: LD_EXP 2
16995: IFFALSE 17088
// begin wait ( time ) ;
16997: LD_VAR 0 2
17001: PPUSH
17002: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
17006: LD_ADDR_VAR 0 2
17010: PUSH
17011: LD_VAR 0 2
17015: PUSH
17016: LD_INT 140
17018: PUSH
17019: LD_INT 175
17021: PUSH
17022: LD_INT 210
17024: PUSH
17025: LD_INT 280
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: LIST
17032: LIST
17033: PUSH
17034: LD_OWVAR 67
17038: ARRAY
17039: PLUS
17040: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
17041: LD_INT 3
17043: PPUSH
17044: LD_INT 5
17046: PPUSH
17047: CALL_OW 12
17051: PPUSH
17052: LD_INT 26
17054: PPUSH
17055: LD_INT 9
17057: PPUSH
17058: LD_INT 30
17060: PPUSH
17061: LD_INT 1
17063: PPUSH
17064: CALL_OW 56
// if time > 3 3$00 then
17068: LD_VAR 0 2
17072: PUSH
17073: LD_INT 6300
17075: GREATER
17076: IFFALSE 17086
// time := 0 0$20 ;
17078: LD_ADDR_VAR 0 2
17082: PUSH
17083: LD_INT 700
17085: ST_TO_ADDR
// end ;
17086: GO 16991
// end ;
17088: PPOPN 2
17090: END
// every 0 0$30 do var cr , time ;
17091: GO 17093
17093: DISABLE
17094: LD_INT 0
17096: PPUSH
17097: PPUSH
// begin time := 0 0$20 ;
17098: LD_ADDR_VAR 0 2
17102: PUSH
17103: LD_INT 700
17105: ST_TO_ADDR
// while game do
17106: LD_EXP 2
17110: IFFALSE 17239
// begin wait ( time ) ;
17112: LD_VAR 0 2
17116: PPUSH
17117: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
17121: LD_ADDR_VAR 0 2
17125: PUSH
17126: LD_VAR 0 2
17130: PUSH
17131: LD_INT 175
17133: PUSH
17134: LD_INT 210
17136: PUSH
17137: LD_INT 280
17139: PUSH
17140: LD_INT 350
17142: PUSH
17143: EMPTY
17144: LIST
17145: LIST
17146: LIST
17147: LIST
17148: PUSH
17149: LD_OWVAR 67
17153: ARRAY
17154: PLUS
17155: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17156: LD_INT 1
17158: PPUSH
17159: LD_INT 5
17161: PPUSH
17162: CALL_OW 12
17166: PPUSH
17167: LD_INT 179
17169: PPUSH
17170: LD_INT 101
17172: PPUSH
17173: LD_INT 20
17175: PPUSH
17176: LD_INT 1
17178: PPUSH
17179: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17183: LD_INT 350
17185: PPUSH
17186: LD_INT 525
17188: PPUSH
17189: CALL_OW 12
17193: PPUSH
17194: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17198: LD_INT 1
17200: PPUSH
17201: LD_INT 5
17203: PPUSH
17204: CALL_OW 12
17208: PPUSH
17209: LD_INT 9
17211: PPUSH
17212: LD_INT 1
17214: PPUSH
17215: CALL_OW 55
// if time > 4 4$00 then
17219: LD_VAR 0 2
17223: PUSH
17224: LD_INT 8400
17226: GREATER
17227: IFFALSE 17237
// time := 0 0$30 ;
17229: LD_ADDR_VAR 0 2
17233: PUSH
17234: LD_INT 1050
17236: ST_TO_ADDR
// end ;
17237: GO 17106
// end ;
17239: PPOPN 2
17241: END
// every 0 0$30 do var cr , time ;
17242: GO 17244
17244: DISABLE
17245: LD_INT 0
17247: PPUSH
17248: PPUSH
// begin time := 0 0$10 ;
17249: LD_ADDR_VAR 0 2
17253: PUSH
17254: LD_INT 350
17256: ST_TO_ADDR
// while game do
17257: LD_EXP 2
17261: IFFALSE 17395
// begin wait ( time ) ;
17263: LD_VAR 0 2
17267: PPUSH
17268: CALL_OW 67
// time := time + 0 0$10 ;
17272: LD_ADDR_VAR 0 2
17276: PUSH
17277: LD_VAR 0 2
17281: PUSH
17282: LD_INT 350
17284: PLUS
17285: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17286: LD_INT 1
17288: PPUSH
17289: LD_INT 5
17291: PPUSH
17292: CALL_OW 12
17296: PPUSH
17297: LD_INT 11
17299: PPUSH
17300: LD_INT 1
17302: PPUSH
17303: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17307: LD_ADDR_VAR 0 1
17311: PUSH
17312: LD_INT 1
17314: PPUSH
17315: LD_INT 3
17317: PPUSH
17318: CALL_OW 12
17322: ST_TO_ADDR
// if cr = 1 then
17323: LD_VAR 0 1
17327: PUSH
17328: LD_INT 1
17330: EQUAL
17331: IFFALSE 17375
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17333: LD_INT 700
17335: PPUSH
17336: LD_INT 1575
17338: PPUSH
17339: CALL_OW 12
17343: PPUSH
17344: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17348: LD_INT 1
17350: PPUSH
17351: LD_INT 5
17353: PPUSH
17354: CALL_OW 12
17358: PPUSH
17359: LD_INT 34
17361: PPUSH
17362: LD_INT 50
17364: PPUSH
17365: LD_INT 7
17367: PPUSH
17368: LD_INT 1
17370: PPUSH
17371: CALL_OW 56
// end ; if time > 4 4$00 then
17375: LD_VAR 0 2
17379: PUSH
17380: LD_INT 8400
17382: GREATER
17383: IFFALSE 17393
// time := 0 0$40 ;
17385: LD_ADDR_VAR 0 2
17389: PUSH
17390: LD_INT 1400
17392: ST_TO_ADDR
// end ;
17393: GO 17257
// end ; end_of_file
17395: PPOPN 2
17397: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17398: LD_INT 0
17400: PPUSH
17401: PPUSH
// if exist_mode then
17402: LD_VAR 0 2
17406: IFFALSE 17452
// begin unit := CreateCharacter ( prefix & ident ) ;
17408: LD_ADDR_VAR 0 5
17412: PUSH
17413: LD_VAR 0 3
17417: PUSH
17418: LD_VAR 0 1
17422: STR
17423: PPUSH
17424: CALL_OW 34
17428: ST_TO_ADDR
// if unit then
17429: LD_VAR 0 5
17433: IFFALSE 17450
// DeleteCharacters ( prefix & ident ) ;
17435: LD_VAR 0 3
17439: PUSH
17440: LD_VAR 0 1
17444: STR
17445: PPUSH
17446: CALL_OW 40
// end else
17450: GO 17467
// unit := NewCharacter ( ident ) ;
17452: LD_ADDR_VAR 0 5
17456: PUSH
17457: LD_VAR 0 1
17461: PPUSH
17462: CALL_OW 25
17466: ST_TO_ADDR
// result := unit ;
17467: LD_ADDR_VAR 0 4
17471: PUSH
17472: LD_VAR 0 5
17476: ST_TO_ADDR
// end ;
17477: LD_VAR 0 4
17481: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
17482: LD_INT 0
17484: PPUSH
17485: PPUSH
// if exist_mode then
17486: LD_VAR 0 2
17490: IFFALSE 17515
// unit := CreateCharacter ( prefix & ident ) else
17492: LD_ADDR_VAR 0 5
17496: PUSH
17497: LD_VAR 0 3
17501: PUSH
17502: LD_VAR 0 1
17506: STR
17507: PPUSH
17508: CALL_OW 34
17512: ST_TO_ADDR
17513: GO 17530
// unit := NewCharacter ( ident ) ;
17515: LD_ADDR_VAR 0 5
17519: PUSH
17520: LD_VAR 0 1
17524: PPUSH
17525: CALL_OW 25
17529: ST_TO_ADDR
// result := unit ;
17530: LD_ADDR_VAR 0 4
17534: PUSH
17535: LD_VAR 0 5
17539: ST_TO_ADDR
// end ;
17540: LD_VAR 0 4
17544: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17545: LD_INT 0
17547: PPUSH
17548: PPUSH
// if not side or not nation then
17549: LD_VAR 0 1
17553: NOT
17554: IFTRUE 17563
17556: PUSH
17557: LD_VAR 0 2
17561: NOT
17562: OR
17563: IFFALSE 17567
// exit ;
17565: GO 18361
// case nation of nation_american :
17567: LD_VAR 0 2
17571: PUSH
17572: LD_INT 1
17574: DOUBLE
17575: EQUAL
17576: IFTRUE 17580
17578: GO 17802
17580: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
17581: LD_ADDR_VAR 0 4
17585: PUSH
17586: LD_INT 35
17588: PUSH
17589: LD_INT 45
17591: PUSH
17592: LD_INT 46
17594: PUSH
17595: LD_INT 47
17597: PUSH
17598: LD_INT 82
17600: PUSH
17601: LD_INT 83
17603: PUSH
17604: LD_INT 84
17606: PUSH
17607: LD_INT 85
17609: PUSH
17610: LD_INT 86
17612: PUSH
17613: LD_INT 1
17615: PUSH
17616: LD_INT 2
17618: PUSH
17619: LD_INT 6
17621: PUSH
17622: LD_INT 15
17624: PUSH
17625: LD_INT 16
17627: PUSH
17628: LD_INT 7
17630: PUSH
17631: LD_INT 12
17633: PUSH
17634: LD_INT 13
17636: PUSH
17637: LD_INT 10
17639: PUSH
17640: LD_INT 14
17642: PUSH
17643: LD_INT 20
17645: PUSH
17646: LD_INT 21
17648: PUSH
17649: LD_INT 22
17651: PUSH
17652: LD_INT 25
17654: PUSH
17655: LD_INT 32
17657: PUSH
17658: LD_INT 27
17660: PUSH
17661: LD_INT 36
17663: PUSH
17664: LD_INT 69
17666: PUSH
17667: LD_INT 39
17669: PUSH
17670: LD_INT 34
17672: PUSH
17673: LD_INT 40
17675: PUSH
17676: LD_INT 48
17678: PUSH
17679: LD_INT 49
17681: PUSH
17682: LD_INT 50
17684: PUSH
17685: LD_INT 51
17687: PUSH
17688: LD_INT 52
17690: PUSH
17691: LD_INT 53
17693: PUSH
17694: LD_INT 54
17696: PUSH
17697: LD_INT 55
17699: PUSH
17700: LD_INT 56
17702: PUSH
17703: LD_INT 57
17705: PUSH
17706: LD_INT 58
17708: PUSH
17709: LD_INT 59
17711: PUSH
17712: LD_INT 60
17714: PUSH
17715: LD_INT 61
17717: PUSH
17718: LD_INT 62
17720: PUSH
17721: LD_INT 80
17723: PUSH
17724: LD_INT 82
17726: PUSH
17727: LD_INT 83
17729: PUSH
17730: LD_INT 84
17732: PUSH
17733: LD_INT 85
17735: PUSH
17736: LD_INT 86
17738: PUSH
17739: LD_INT 90
17741: PUSH
17742: LD_INT 93
17744: PUSH
17745: EMPTY
17746: LIST
17747: LIST
17748: LIST
17749: LIST
17750: LIST
17751: LIST
17752: LIST
17753: LIST
17754: LIST
17755: LIST
17756: LIST
17757: LIST
17758: LIST
17759: LIST
17760: LIST
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: LIST
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: LIST
17776: LIST
17777: LIST
17778: LIST
17779: LIST
17780: LIST
17781: LIST
17782: LIST
17783: LIST
17784: LIST
17785: LIST
17786: LIST
17787: LIST
17788: LIST
17789: LIST
17790: LIST
17791: LIST
17792: LIST
17793: LIST
17794: LIST
17795: LIST
17796: LIST
17797: LIST
17798: LIST
17799: ST_TO_ADDR
17800: GO 18283
17802: LD_INT 2
17804: DOUBLE
17805: EQUAL
17806: IFTRUE 17810
17808: GO 18044
17810: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
17811: LD_ADDR_VAR 0 4
17815: PUSH
17816: LD_INT 35
17818: PUSH
17819: LD_INT 45
17821: PUSH
17822: LD_INT 46
17824: PUSH
17825: LD_INT 47
17827: PUSH
17828: LD_INT 82
17830: PUSH
17831: LD_INT 83
17833: PUSH
17834: LD_INT 84
17836: PUSH
17837: LD_INT 85
17839: PUSH
17840: LD_INT 87
17842: PUSH
17843: LD_INT 70
17845: PUSH
17846: LD_INT 1
17848: PUSH
17849: LD_INT 11
17851: PUSH
17852: LD_INT 3
17854: PUSH
17855: LD_INT 4
17857: PUSH
17858: LD_INT 5
17860: PUSH
17861: LD_INT 6
17863: PUSH
17864: LD_INT 15
17866: PUSH
17867: LD_INT 18
17869: PUSH
17870: LD_INT 7
17872: PUSH
17873: LD_INT 17
17875: PUSH
17876: LD_INT 8
17878: PUSH
17879: LD_INT 20
17881: PUSH
17882: LD_INT 21
17884: PUSH
17885: LD_INT 22
17887: PUSH
17888: LD_INT 72
17890: PUSH
17891: LD_INT 26
17893: PUSH
17894: LD_INT 69
17896: PUSH
17897: LD_INT 39
17899: PUSH
17900: LD_INT 40
17902: PUSH
17903: LD_INT 41
17905: PUSH
17906: LD_INT 42
17908: PUSH
17909: LD_INT 43
17911: PUSH
17912: LD_INT 48
17914: PUSH
17915: LD_INT 49
17917: PUSH
17918: LD_INT 50
17920: PUSH
17921: LD_INT 51
17923: PUSH
17924: LD_INT 52
17926: PUSH
17927: LD_INT 53
17929: PUSH
17930: LD_INT 54
17932: PUSH
17933: LD_INT 55
17935: PUSH
17936: LD_INT 56
17938: PUSH
17939: LD_INT 60
17941: PUSH
17942: LD_INT 61
17944: PUSH
17945: LD_INT 62
17947: PUSH
17948: LD_INT 66
17950: PUSH
17951: LD_INT 67
17953: PUSH
17954: LD_INT 68
17956: PUSH
17957: LD_INT 81
17959: PUSH
17960: LD_INT 82
17962: PUSH
17963: LD_INT 83
17965: PUSH
17966: LD_INT 84
17968: PUSH
17969: LD_INT 85
17971: PUSH
17972: LD_INT 87
17974: PUSH
17975: LD_INT 88
17977: PUSH
17978: LD_INT 92
17980: PUSH
17981: LD_INT 94
17983: PUSH
17984: EMPTY
17985: LIST
17986: LIST
17987: LIST
17988: LIST
17989: LIST
17990: LIST
17991: LIST
17992: LIST
17993: LIST
17994: LIST
17995: LIST
17996: LIST
17997: LIST
17998: LIST
17999: LIST
18000: LIST
18001: LIST
18002: LIST
18003: LIST
18004: LIST
18005: LIST
18006: LIST
18007: LIST
18008: LIST
18009: LIST
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: LIST
18015: LIST
18016: LIST
18017: LIST
18018: LIST
18019: LIST
18020: LIST
18021: LIST
18022: LIST
18023: LIST
18024: LIST
18025: LIST
18026: LIST
18027: LIST
18028: LIST
18029: LIST
18030: LIST
18031: LIST
18032: LIST
18033: LIST
18034: LIST
18035: LIST
18036: LIST
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: ST_TO_ADDR
18042: GO 18283
18044: LD_INT 3
18046: DOUBLE
18047: EQUAL
18048: IFTRUE 18052
18050: GO 18282
18052: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
18053: LD_ADDR_VAR 0 4
18057: PUSH
18058: LD_INT 46
18060: PUSH
18061: LD_INT 47
18063: PUSH
18064: LD_INT 1
18066: PUSH
18067: LD_INT 2
18069: PUSH
18070: LD_INT 82
18072: PUSH
18073: LD_INT 83
18075: PUSH
18076: LD_INT 84
18078: PUSH
18079: LD_INT 85
18081: PUSH
18082: LD_INT 86
18084: PUSH
18085: LD_INT 11
18087: PUSH
18088: LD_INT 9
18090: PUSH
18091: LD_INT 20
18093: PUSH
18094: LD_INT 19
18096: PUSH
18097: LD_INT 21
18099: PUSH
18100: LD_INT 24
18102: PUSH
18103: LD_INT 22
18105: PUSH
18106: LD_INT 25
18108: PUSH
18109: LD_INT 28
18111: PUSH
18112: LD_INT 29
18114: PUSH
18115: LD_INT 30
18117: PUSH
18118: LD_INT 31
18120: PUSH
18121: LD_INT 37
18123: PUSH
18124: LD_INT 38
18126: PUSH
18127: LD_INT 32
18129: PUSH
18130: LD_INT 27
18132: PUSH
18133: LD_INT 33
18135: PUSH
18136: LD_INT 69
18138: PUSH
18139: LD_INT 39
18141: PUSH
18142: LD_INT 34
18144: PUSH
18145: LD_INT 40
18147: PUSH
18148: LD_INT 71
18150: PUSH
18151: LD_INT 23
18153: PUSH
18154: LD_INT 44
18156: PUSH
18157: LD_INT 48
18159: PUSH
18160: LD_INT 49
18162: PUSH
18163: LD_INT 50
18165: PUSH
18166: LD_INT 51
18168: PUSH
18169: LD_INT 52
18171: PUSH
18172: LD_INT 53
18174: PUSH
18175: LD_INT 54
18177: PUSH
18178: LD_INT 55
18180: PUSH
18181: LD_INT 56
18183: PUSH
18184: LD_INT 57
18186: PUSH
18187: LD_INT 58
18189: PUSH
18190: LD_INT 59
18192: PUSH
18193: LD_INT 63
18195: PUSH
18196: LD_INT 64
18198: PUSH
18199: LD_INT 65
18201: PUSH
18202: LD_INT 82
18204: PUSH
18205: LD_INT 83
18207: PUSH
18208: LD_INT 84
18210: PUSH
18211: LD_INT 85
18213: PUSH
18214: LD_INT 86
18216: PUSH
18217: LD_INT 89
18219: PUSH
18220: LD_INT 91
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: LIST
18231: LIST
18232: LIST
18233: LIST
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: LIST
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: LIST
18253: LIST
18254: LIST
18255: LIST
18256: LIST
18257: LIST
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: LIST
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: LIST
18269: LIST
18270: LIST
18271: LIST
18272: LIST
18273: LIST
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: LIST
18279: ST_TO_ADDR
18280: GO 18283
18282: POP
// if state > - 1 and state < 3 then
18283: LD_VAR 0 3
18287: PUSH
18288: LD_INT 1
18290: NEG
18291: GREATER
18292: IFFALSE 18304
18294: PUSH
18295: LD_VAR 0 3
18299: PUSH
18300: LD_INT 3
18302: LESS
18303: AND
18304: IFFALSE 18361
// for i in result do
18306: LD_ADDR_VAR 0 5
18310: PUSH
18311: LD_VAR 0 4
18315: PUSH
18316: FOR_IN
18317: IFFALSE 18359
// if GetTech ( i , side ) <> state then
18319: LD_VAR 0 5
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: CALL_OW 321
18333: PUSH
18334: LD_VAR 0 3
18338: NONEQUAL
18339: IFFALSE 18357
// result := result diff i ;
18341: LD_ADDR_VAR 0 4
18345: PUSH
18346: LD_VAR 0 4
18350: PUSH
18351: LD_VAR 0 5
18355: DIFF
18356: ST_TO_ADDR
18357: GO 18316
18359: POP
18360: POP
// end ;
18361: LD_VAR 0 4
18365: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18366: LD_INT 0
18368: PPUSH
18369: PPUSH
18370: PPUSH
// result := true ;
18371: LD_ADDR_VAR 0 3
18375: PUSH
18376: LD_INT 1
18378: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18379: LD_ADDR_VAR 0 5
18383: PUSH
18384: LD_VAR 0 2
18388: PPUSH
18389: CALL_OW 480
18393: ST_TO_ADDR
// if not tmp then
18394: LD_VAR 0 5
18398: NOT
18399: IFFALSE 18403
// exit ;
18401: GO 18452
// for i in tmp do
18403: LD_ADDR_VAR 0 4
18407: PUSH
18408: LD_VAR 0 5
18412: PUSH
18413: FOR_IN
18414: IFFALSE 18450
// if GetTech ( i , side ) <> state_researched then
18416: LD_VAR 0 4
18420: PPUSH
18421: LD_VAR 0 1
18425: PPUSH
18426: CALL_OW 321
18430: PUSH
18431: LD_INT 2
18433: NONEQUAL
18434: IFFALSE 18448
// begin result := false ;
18436: LD_ADDR_VAR 0 3
18440: PUSH
18441: LD_INT 0
18443: ST_TO_ADDR
// exit ;
18444: POP
18445: POP
18446: GO 18452
// end ;
18448: GO 18413
18450: POP
18451: POP
// end ;
18452: LD_VAR 0 3
18456: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18457: LD_INT 0
18459: PPUSH
18460: PPUSH
18461: PPUSH
18462: PPUSH
18463: PPUSH
18464: PPUSH
18465: PPUSH
18466: PPUSH
18467: PPUSH
18468: PPUSH
18469: PPUSH
18470: PPUSH
18471: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18472: LD_VAR 0 1
18476: NOT
18477: IFTRUE 18494
18479: PUSH
18480: LD_VAR 0 1
18484: PPUSH
18485: CALL_OW 257
18489: PUSH
18490: LD_INT 9
18492: NONEQUAL
18493: OR
18494: IFFALSE 18498
// exit ;
18496: GO 19077
// side := GetSide ( unit ) ;
18498: LD_ADDR_VAR 0 9
18502: PUSH
18503: LD_VAR 0 1
18507: PPUSH
18508: CALL_OW 255
18512: ST_TO_ADDR
// tech_space := tech_spacanom ;
18513: LD_ADDR_VAR 0 12
18517: PUSH
18518: LD_INT 29
18520: ST_TO_ADDR
// tech_time := tech_taurad ;
18521: LD_ADDR_VAR 0 13
18525: PUSH
18526: LD_INT 28
18528: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18529: LD_ADDR_VAR 0 11
18533: PUSH
18534: LD_VAR 0 1
18538: PPUSH
18539: CALL_OW 310
18543: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18544: LD_VAR 0 11
18548: PPUSH
18549: CALL_OW 247
18553: PUSH
18554: LD_INT 2
18556: EQUAL
18557: IFFALSE 18561
// exit ;
18559: GO 19077
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18561: LD_ADDR_VAR 0 8
18565: PUSH
18566: LD_INT 81
18568: PUSH
18569: LD_VAR 0 9
18573: PUSH
18574: EMPTY
18575: LIST
18576: LIST
18577: PUSH
18578: LD_INT 3
18580: PUSH
18581: LD_INT 21
18583: PUSH
18584: LD_INT 3
18586: PUSH
18587: EMPTY
18588: LIST
18589: LIST
18590: PUSH
18591: EMPTY
18592: LIST
18593: LIST
18594: PUSH
18595: EMPTY
18596: LIST
18597: LIST
18598: PPUSH
18599: CALL_OW 69
18603: ST_TO_ADDR
// if not tmp then
18604: LD_VAR 0 8
18608: NOT
18609: IFFALSE 18613
// exit ;
18611: GO 19077
// if in_unit then
18613: LD_VAR 0 11
18617: IFFALSE 18641
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18619: LD_ADDR_VAR 0 10
18623: PUSH
18624: LD_VAR 0 8
18628: PPUSH
18629: LD_VAR 0 11
18633: PPUSH
18634: CALL_OW 74
18638: ST_TO_ADDR
18639: GO 18661
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18641: LD_ADDR_VAR 0 10
18645: PUSH
18646: LD_VAR 0 8
18650: PPUSH
18651: LD_VAR 0 1
18655: PPUSH
18656: CALL_OW 74
18660: ST_TO_ADDR
// if not enemy then
18661: LD_VAR 0 10
18665: NOT
18666: IFFALSE 18670
// exit ;
18668: GO 19077
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18670: LD_VAR 0 11
18674: IFFALSE 18696
18676: PUSH
18677: LD_VAR 0 11
18681: PPUSH
18682: LD_VAR 0 10
18686: PPUSH
18687: CALL_OW 296
18691: PUSH
18692: LD_INT 13
18694: GREATER
18695: AND
18696: IFTRUE 18718
18698: PUSH
18699: LD_VAR 0 1
18703: PPUSH
18704: LD_VAR 0 10
18708: PPUSH
18709: CALL_OW 296
18713: PUSH
18714: LD_INT 12
18716: GREATER
18717: OR
18718: IFFALSE 18722
// exit ;
18720: GO 19077
// missile := [ 1 ] ;
18722: LD_ADDR_VAR 0 14
18726: PUSH
18727: LD_INT 1
18729: PUSH
18730: EMPTY
18731: LIST
18732: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18733: LD_VAR 0 9
18737: PPUSH
18738: LD_VAR 0 12
18742: PPUSH
18743: CALL_OW 325
18747: IFFALSE 18776
// missile := Replace ( missile , missile + 1 , 2 ) ;
18749: LD_ADDR_VAR 0 14
18753: PUSH
18754: LD_VAR 0 14
18758: PPUSH
18759: LD_VAR 0 14
18763: PUSH
18764: LD_INT 1
18766: PLUS
18767: PPUSH
18768: LD_INT 2
18770: PPUSH
18771: CALL_OW 1
18775: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18776: LD_VAR 0 9
18780: PPUSH
18781: LD_VAR 0 13
18785: PPUSH
18786: CALL_OW 325
18790: IFFALSE 18814
18792: PUSH
18793: LD_VAR 0 10
18797: PPUSH
18798: CALL_OW 255
18802: PPUSH
18803: LD_VAR 0 13
18807: PPUSH
18808: CALL_OW 325
18812: NOT
18813: AND
18814: IFFALSE 18843
// missile := Replace ( missile , missile + 1 , 3 ) ;
18816: LD_ADDR_VAR 0 14
18820: PUSH
18821: LD_VAR 0 14
18825: PPUSH
18826: LD_VAR 0 14
18830: PUSH
18831: LD_INT 1
18833: PLUS
18834: PPUSH
18835: LD_INT 3
18837: PPUSH
18838: CALL_OW 1
18842: ST_TO_ADDR
// if missile < 2 then
18843: LD_VAR 0 14
18847: PUSH
18848: LD_INT 2
18850: LESS
18851: IFFALSE 18855
// exit ;
18853: GO 19077
// x := GetX ( enemy ) ;
18855: LD_ADDR_VAR 0 4
18859: PUSH
18860: LD_VAR 0 10
18864: PPUSH
18865: CALL_OW 250
18869: ST_TO_ADDR
// y := GetY ( enemy ) ;
18870: LD_ADDR_VAR 0 5
18874: PUSH
18875: LD_VAR 0 10
18879: PPUSH
18880: CALL_OW 251
18884: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18885: LD_ADDR_VAR 0 6
18889: PUSH
18890: LD_VAR 0 4
18894: PUSH
18895: LD_INT 1
18897: NEG
18898: PPUSH
18899: LD_INT 1
18901: PPUSH
18902: CALL_OW 12
18906: PLUS
18907: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18908: LD_ADDR_VAR 0 7
18912: PUSH
18913: LD_VAR 0 5
18917: PUSH
18918: LD_INT 1
18920: NEG
18921: PPUSH
18922: LD_INT 1
18924: PPUSH
18925: CALL_OW 12
18929: PLUS
18930: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18931: LD_VAR 0 6
18935: PPUSH
18936: LD_VAR 0 7
18940: PPUSH
18941: CALL_OW 488
18945: NOT
18946: IFFALSE 18968
// begin _x := x ;
18948: LD_ADDR_VAR 0 6
18952: PUSH
18953: LD_VAR 0 4
18957: ST_TO_ADDR
// _y := y ;
18958: LD_ADDR_VAR 0 7
18962: PUSH
18963: LD_VAR 0 5
18967: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18968: LD_ADDR_VAR 0 3
18972: PUSH
18973: LD_INT 1
18975: PPUSH
18976: LD_VAR 0 14
18980: PPUSH
18981: CALL_OW 12
18985: ST_TO_ADDR
// case i of 1 :
18986: LD_VAR 0 3
18990: PUSH
18991: LD_INT 1
18993: DOUBLE
18994: EQUAL
18995: IFTRUE 18999
18997: GO 19016
18999: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
19000: LD_VAR 0 1
19004: PPUSH
19005: LD_VAR 0 10
19009: PPUSH
19010: CALL_OW 115
19014: GO 19077
19016: LD_INT 2
19018: DOUBLE
19019: EQUAL
19020: IFTRUE 19024
19022: GO 19046
19024: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
19025: LD_VAR 0 1
19029: PPUSH
19030: LD_VAR 0 6
19034: PPUSH
19035: LD_VAR 0 7
19039: PPUSH
19040: CALL_OW 153
19044: GO 19077
19046: LD_INT 3
19048: DOUBLE
19049: EQUAL
19050: IFTRUE 19054
19052: GO 19076
19054: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
19055: LD_VAR 0 1
19059: PPUSH
19060: LD_VAR 0 6
19064: PPUSH
19065: LD_VAR 0 7
19069: PPUSH
19070: CALL_OW 154
19074: GO 19077
19076: POP
// end ;
19077: LD_VAR 0 2
19081: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
19082: LD_INT 0
19084: PPUSH
19085: PPUSH
19086: PPUSH
19087: PPUSH
19088: PPUSH
19089: PPUSH
// if not unit or not building then
19090: LD_VAR 0 1
19094: NOT
19095: IFTRUE 19104
19097: PUSH
19098: LD_VAR 0 2
19102: NOT
19103: OR
19104: IFFALSE 19108
// exit ;
19106: GO 19266
// x := GetX ( building ) ;
19108: LD_ADDR_VAR 0 5
19112: PUSH
19113: LD_VAR 0 2
19117: PPUSH
19118: CALL_OW 250
19122: ST_TO_ADDR
// y := GetY ( building ) ;
19123: LD_ADDR_VAR 0 6
19127: PUSH
19128: LD_VAR 0 2
19132: PPUSH
19133: CALL_OW 251
19137: ST_TO_ADDR
// for i := 0 to 5 do
19138: LD_ADDR_VAR 0 4
19142: PUSH
19143: DOUBLE
19144: LD_INT 0
19146: DEC
19147: ST_TO_ADDR
19148: LD_INT 5
19150: PUSH
19151: FOR_TO
19152: IFFALSE 19264
// begin _x := ShiftX ( x , i , 3 ) ;
19154: LD_ADDR_VAR 0 7
19158: PUSH
19159: LD_VAR 0 5
19163: PPUSH
19164: LD_VAR 0 4
19168: PPUSH
19169: LD_INT 3
19171: PPUSH
19172: CALL_OW 272
19176: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19177: LD_ADDR_VAR 0 8
19181: PUSH
19182: LD_VAR 0 6
19186: PPUSH
19187: LD_VAR 0 4
19191: PPUSH
19192: LD_INT 3
19194: PPUSH
19195: CALL_OW 273
19199: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19200: LD_VAR 0 7
19204: PPUSH
19205: LD_VAR 0 8
19209: PPUSH
19210: CALL_OW 488
19214: NOT
19215: IFFALSE 19219
// continue ;
19217: GO 19151
// if HexInfo ( _x , _y ) = 0 then
19219: LD_VAR 0 7
19223: PPUSH
19224: LD_VAR 0 8
19228: PPUSH
19229: CALL_OW 428
19233: PUSH
19234: LD_INT 0
19236: EQUAL
19237: IFFALSE 19262
// begin ComMoveXY ( unit , _x , _y ) ;
19239: LD_VAR 0 1
19243: PPUSH
19244: LD_VAR 0 7
19248: PPUSH
19249: LD_VAR 0 8
19253: PPUSH
19254: CALL_OW 111
// exit ;
19258: POP
19259: POP
19260: GO 19266
// end ; end ;
19262: GO 19151
19264: POP
19265: POP
// end ;
19266: LD_VAR 0 3
19270: RET
// export function ScanBase ( side , base_area ) ; begin
19271: LD_INT 0
19273: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19274: LD_ADDR_VAR 0 3
19278: PUSH
19279: LD_VAR 0 2
19283: PPUSH
19284: LD_INT 81
19286: PUSH
19287: LD_VAR 0 1
19291: PUSH
19292: EMPTY
19293: LIST
19294: LIST
19295: PPUSH
19296: CALL_OW 70
19300: ST_TO_ADDR
// end ;
19301: LD_VAR 0 3
19305: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19306: LD_INT 0
19308: PPUSH
19309: PPUSH
19310: PPUSH
19311: PPUSH
// result := false ;
19312: LD_ADDR_VAR 0 2
19316: PUSH
19317: LD_INT 0
19319: ST_TO_ADDR
// side := GetSide ( unit ) ;
19320: LD_ADDR_VAR 0 3
19324: PUSH
19325: LD_VAR 0 1
19329: PPUSH
19330: CALL_OW 255
19334: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19335: LD_ADDR_VAR 0 4
19339: PUSH
19340: LD_VAR 0 1
19344: PPUSH
19345: CALL_OW 248
19349: ST_TO_ADDR
// case nat of 1 :
19350: LD_VAR 0 4
19354: PUSH
19355: LD_INT 1
19357: DOUBLE
19358: EQUAL
19359: IFTRUE 19363
19361: GO 19374
19363: POP
// tech := tech_lassight ; 2 :
19364: LD_ADDR_VAR 0 5
19368: PUSH
19369: LD_INT 12
19371: ST_TO_ADDR
19372: GO 19413
19374: LD_INT 2
19376: DOUBLE
19377: EQUAL
19378: IFTRUE 19382
19380: GO 19393
19382: POP
// tech := tech_mortar ; 3 :
19383: LD_ADDR_VAR 0 5
19387: PUSH
19388: LD_INT 41
19390: ST_TO_ADDR
19391: GO 19413
19393: LD_INT 3
19395: DOUBLE
19396: EQUAL
19397: IFTRUE 19401
19399: GO 19412
19401: POP
// tech := tech_bazooka ; end ;
19402: LD_ADDR_VAR 0 5
19406: PUSH
19407: LD_INT 44
19409: ST_TO_ADDR
19410: GO 19413
19412: POP
// if Researched ( side , tech ) then
19413: LD_VAR 0 3
19417: PPUSH
19418: LD_VAR 0 5
19422: PPUSH
19423: CALL_OW 325
19427: IFFALSE 19454
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19429: LD_ADDR_VAR 0 2
19433: PUSH
19434: LD_INT 5
19436: PUSH
19437: LD_INT 8
19439: PUSH
19440: LD_INT 9
19442: PUSH
19443: EMPTY
19444: LIST
19445: LIST
19446: LIST
19447: PUSH
19448: LD_VAR 0 4
19452: ARRAY
19453: ST_TO_ADDR
// end ;
19454: LD_VAR 0 2
19458: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19459: LD_INT 0
19461: PPUSH
19462: PPUSH
19463: PPUSH
// if not mines then
19464: LD_VAR 0 2
19468: NOT
19469: IFFALSE 19473
// exit ;
19471: GO 19617
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19473: LD_ADDR_VAR 0 5
19477: PUSH
19478: LD_INT 81
19480: PUSH
19481: LD_VAR 0 1
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: PUSH
19490: LD_INT 3
19492: PUSH
19493: LD_INT 21
19495: PUSH
19496: LD_INT 3
19498: PUSH
19499: EMPTY
19500: LIST
19501: LIST
19502: PUSH
19503: EMPTY
19504: LIST
19505: LIST
19506: PUSH
19507: EMPTY
19508: LIST
19509: LIST
19510: PPUSH
19511: CALL_OW 69
19515: ST_TO_ADDR
// for i in mines do
19516: LD_ADDR_VAR 0 4
19520: PUSH
19521: LD_VAR 0 2
19525: PUSH
19526: FOR_IN
19527: IFFALSE 19615
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19529: LD_VAR 0 4
19533: PUSH
19534: LD_INT 1
19536: ARRAY
19537: PPUSH
19538: LD_VAR 0 4
19542: PUSH
19543: LD_INT 2
19545: ARRAY
19546: PPUSH
19547: CALL_OW 458
19551: NOT
19552: IFFALSE 19556
// continue ;
19554: GO 19526
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19556: LD_VAR 0 4
19560: PUSH
19561: LD_INT 1
19563: ARRAY
19564: PPUSH
19565: LD_VAR 0 4
19569: PUSH
19570: LD_INT 2
19572: ARRAY
19573: PPUSH
19574: CALL_OW 428
19578: PUSH
19579: LD_VAR 0 5
19583: IN
19584: IFFALSE 19613
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19586: LD_VAR 0 4
19590: PUSH
19591: LD_INT 1
19593: ARRAY
19594: PPUSH
19595: LD_VAR 0 4
19599: PUSH
19600: LD_INT 2
19602: ARRAY
19603: PPUSH
19604: LD_VAR 0 1
19608: PPUSH
19609: CALL_OW 456
// end ;
19613: GO 19526
19615: POP
19616: POP
// end ;
19617: LD_VAR 0 3
19621: RET
// export function Count ( array ) ; begin
19622: LD_INT 0
19624: PPUSH
// result := array + 0 ;
19625: LD_ADDR_VAR 0 2
19629: PUSH
19630: LD_VAR 0 1
19634: PUSH
19635: LD_INT 0
19637: PLUS
19638: ST_TO_ADDR
// end ;
19639: LD_VAR 0 2
19643: RET
// export function IsEmpty ( building ) ; begin
19644: LD_INT 0
19646: PPUSH
// if not building then
19647: LD_VAR 0 1
19651: NOT
19652: IFFALSE 19656
// exit ;
19654: GO 19699
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19656: LD_ADDR_VAR 0 2
19660: PUSH
19661: LD_VAR 0 1
19665: PUSH
19666: LD_INT 22
19668: PUSH
19669: LD_VAR 0 1
19673: PPUSH
19674: CALL_OW 255
19678: PUSH
19679: EMPTY
19680: LIST
19681: LIST
19682: PUSH
19683: LD_INT 58
19685: PUSH
19686: EMPTY
19687: LIST
19688: PUSH
19689: EMPTY
19690: LIST
19691: LIST
19692: PPUSH
19693: CALL_OW 69
19697: IN
19698: ST_TO_ADDR
// end ;
19699: LD_VAR 0 2
19703: RET
// export function IsNotFull ( building ) ; var places ; begin
19704: LD_INT 0
19706: PPUSH
19707: PPUSH
// if not building then
19708: LD_VAR 0 1
19712: NOT
19713: IFFALSE 19717
// exit ;
19715: GO 19745
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19717: LD_ADDR_VAR 0 2
19721: PUSH
19722: LD_VAR 0 1
19726: PPUSH
19727: LD_INT 3
19729: PUSH
19730: LD_INT 62
19732: PUSH
19733: EMPTY
19734: LIST
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: PPUSH
19740: CALL_OW 72
19744: ST_TO_ADDR
// end ;
19745: LD_VAR 0 2
19749: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19750: LD_INT 0
19752: PPUSH
19753: PPUSH
19754: PPUSH
19755: PPUSH
// tmp := [ ] ;
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: EMPTY
19762: ST_TO_ADDR
// list := [ ] ;
19763: LD_ADDR_VAR 0 5
19767: PUSH
19768: EMPTY
19769: ST_TO_ADDR
// for i = 16 to 25 do
19770: LD_ADDR_VAR 0 4
19774: PUSH
19775: DOUBLE
19776: LD_INT 16
19778: DEC
19779: ST_TO_ADDR
19780: LD_INT 25
19782: PUSH
19783: FOR_TO
19784: IFFALSE 19857
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19786: LD_ADDR_VAR 0 3
19790: PUSH
19791: LD_VAR 0 3
19795: PUSH
19796: LD_INT 22
19798: PUSH
19799: LD_VAR 0 1
19803: PPUSH
19804: CALL_OW 255
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: PUSH
19813: LD_INT 91
19815: PUSH
19816: LD_VAR 0 1
19820: PUSH
19821: LD_INT 6
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: LIST
19828: PUSH
19829: LD_INT 30
19831: PUSH
19832: LD_VAR 0 4
19836: PUSH
19837: EMPTY
19838: LIST
19839: LIST
19840: PUSH
19841: EMPTY
19842: LIST
19843: LIST
19844: LIST
19845: PUSH
19846: EMPTY
19847: LIST
19848: PPUSH
19849: CALL_OW 69
19853: ADD
19854: ST_TO_ADDR
19855: GO 19783
19857: POP
19858: POP
// for i = 1 to tmp do
19859: LD_ADDR_VAR 0 4
19863: PUSH
19864: DOUBLE
19865: LD_INT 1
19867: DEC
19868: ST_TO_ADDR
19869: LD_VAR 0 3
19873: PUSH
19874: FOR_TO
19875: IFFALSE 19963
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19877: LD_ADDR_VAR 0 5
19881: PUSH
19882: LD_VAR 0 5
19886: PUSH
19887: LD_VAR 0 3
19891: PUSH
19892: LD_VAR 0 4
19896: ARRAY
19897: PPUSH
19898: CALL_OW 266
19902: PUSH
19903: LD_VAR 0 3
19907: PUSH
19908: LD_VAR 0 4
19912: ARRAY
19913: PPUSH
19914: CALL_OW 250
19918: PUSH
19919: LD_VAR 0 3
19923: PUSH
19924: LD_VAR 0 4
19928: ARRAY
19929: PPUSH
19930: CALL_OW 251
19934: PUSH
19935: LD_VAR 0 3
19939: PUSH
19940: LD_VAR 0 4
19944: ARRAY
19945: PPUSH
19946: CALL_OW 254
19950: PUSH
19951: EMPTY
19952: LIST
19953: LIST
19954: LIST
19955: LIST
19956: PUSH
19957: EMPTY
19958: LIST
19959: ADD
19960: ST_TO_ADDR
19961: GO 19874
19963: POP
19964: POP
// result := list ;
19965: LD_ADDR_VAR 0 2
19969: PUSH
19970: LD_VAR 0 5
19974: ST_TO_ADDR
// end ;
19975: LD_VAR 0 2
19979: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19980: LD_INT 0
19982: PPUSH
19983: PPUSH
19984: PPUSH
19985: PPUSH
19986: PPUSH
19987: PPUSH
19988: PPUSH
// if not factory then
19989: LD_VAR 0 1
19993: NOT
19994: IFFALSE 19998
// exit ;
19996: GO 20601
// if control = control_apeman then
19998: LD_VAR 0 4
20002: PUSH
20003: LD_INT 5
20005: EQUAL
20006: IFFALSE 20115
// begin tmp := UnitsInside ( factory ) ;
20008: LD_ADDR_VAR 0 8
20012: PUSH
20013: LD_VAR 0 1
20017: PPUSH
20018: CALL_OW 313
20022: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
20023: LD_VAR 0 8
20027: PPUSH
20028: LD_INT 25
20030: PUSH
20031: LD_INT 12
20033: PUSH
20034: EMPTY
20035: LIST
20036: LIST
20037: PPUSH
20038: CALL_OW 72
20042: NOT
20043: IFFALSE 20053
// control := control_manual ;
20045: LD_ADDR_VAR 0 4
20049: PUSH
20050: LD_INT 1
20052: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
20053: LD_ADDR_VAR 0 8
20057: PUSH
20058: LD_VAR 0 1
20062: PPUSH
20063: CALL 19750 0 1
20067: ST_TO_ADDR
// if tmp then
20068: LD_VAR 0 8
20072: IFFALSE 20115
// begin for i in tmp do
20074: LD_ADDR_VAR 0 7
20078: PUSH
20079: LD_VAR 0 8
20083: PUSH
20084: FOR_IN
20085: IFFALSE 20113
// if i [ 1 ] = b_ext_radio then
20087: LD_VAR 0 7
20091: PUSH
20092: LD_INT 1
20094: ARRAY
20095: PUSH
20096: LD_INT 22
20098: EQUAL
20099: IFFALSE 20111
// begin control := control_remote ;
20101: LD_ADDR_VAR 0 4
20105: PUSH
20106: LD_INT 2
20108: ST_TO_ADDR
// break ;
20109: GO 20113
// end ;
20111: GO 20084
20113: POP
20114: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20115: LD_VAR 0 1
20119: PPUSH
20120: LD_VAR 0 2
20124: PPUSH
20125: LD_VAR 0 3
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: LD_VAR 0 5
20139: PPUSH
20140: CALL_OW 448
20144: IFFALSE 20179
// begin result := [ chassis , engine , control , weapon ] ;
20146: LD_ADDR_VAR 0 6
20150: PUSH
20151: LD_VAR 0 2
20155: PUSH
20156: LD_VAR 0 3
20160: PUSH
20161: LD_VAR 0 4
20165: PUSH
20166: LD_VAR 0 5
20170: PUSH
20171: EMPTY
20172: LIST
20173: LIST
20174: LIST
20175: LIST
20176: ST_TO_ADDR
// exit ;
20177: GO 20601
// end ; _chassis := AvailableChassisList ( factory ) ;
20179: LD_ADDR_VAR 0 9
20183: PUSH
20184: LD_VAR 0 1
20188: PPUSH
20189: CALL_OW 475
20193: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20194: LD_ADDR_VAR 0 11
20198: PUSH
20199: LD_VAR 0 1
20203: PPUSH
20204: CALL_OW 476
20208: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20209: LD_ADDR_VAR 0 12
20213: PUSH
20214: LD_VAR 0 1
20218: PPUSH
20219: CALL_OW 477
20223: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20224: LD_ADDR_VAR 0 10
20228: PUSH
20229: LD_VAR 0 1
20233: PPUSH
20234: CALL_OW 478
20238: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20239: LD_VAR 0 9
20243: NOT
20244: IFTRUE 20253
20246: PUSH
20247: LD_VAR 0 11
20251: NOT
20252: OR
20253: IFTRUE 20262
20255: PUSH
20256: LD_VAR 0 12
20260: NOT
20261: OR
20262: IFTRUE 20271
20264: PUSH
20265: LD_VAR 0 10
20269: NOT
20270: OR
20271: IFFALSE 20306
// begin result := [ chassis , engine , control , weapon ] ;
20273: LD_ADDR_VAR 0 6
20277: PUSH
20278: LD_VAR 0 2
20282: PUSH
20283: LD_VAR 0 3
20287: PUSH
20288: LD_VAR 0 4
20292: PUSH
20293: LD_VAR 0 5
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: LIST
20302: LIST
20303: ST_TO_ADDR
// exit ;
20304: GO 20601
// end ; if not chassis in _chassis then
20306: LD_VAR 0 2
20310: PUSH
20311: LD_VAR 0 9
20315: IN
20316: NOT
20317: IFFALSE 20343
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20319: LD_ADDR_VAR 0 2
20323: PUSH
20324: LD_VAR 0 9
20328: PUSH
20329: LD_INT 1
20331: PPUSH
20332: LD_VAR 0 9
20336: PPUSH
20337: CALL_OW 12
20341: ARRAY
20342: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20343: LD_VAR 0 2
20347: PPUSH
20348: LD_VAR 0 3
20352: PPUSH
20353: CALL 20606 0 2
20357: NOT
20358: IFFALSE 20419
// repeat engine := _engine [ 1 ] ;
20360: LD_ADDR_VAR 0 3
20364: PUSH
20365: LD_VAR 0 11
20369: PUSH
20370: LD_INT 1
20372: ARRAY
20373: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20374: LD_ADDR_VAR 0 11
20378: PUSH
20379: LD_VAR 0 11
20383: PPUSH
20384: LD_INT 1
20386: PPUSH
20387: CALL_OW 3
20391: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20392: LD_VAR 0 2
20396: PPUSH
20397: LD_VAR 0 3
20401: PPUSH
20402: CALL 20606 0 2
20406: IFTRUE 20417
20408: PUSH
20409: LD_VAR 0 11
20413: PUSH
20414: EMPTY
20415: EQUAL
20416: OR
20417: IFFALSE 20360
// if not control in _control then
20419: LD_VAR 0 4
20423: PUSH
20424: LD_VAR 0 12
20428: IN
20429: NOT
20430: IFFALSE 20456
// control := _control [ rand ( 1 , _control ) ] ;
20432: LD_ADDR_VAR 0 4
20436: PUSH
20437: LD_VAR 0 12
20441: PUSH
20442: LD_INT 1
20444: PPUSH
20445: LD_VAR 0 12
20449: PPUSH
20450: CALL_OW 12
20454: ARRAY
20455: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20456: LD_VAR 0 2
20460: PPUSH
20461: LD_VAR 0 5
20465: PPUSH
20466: CALL 20828 0 2
20470: NOT
20471: IFFALSE 20532
// repeat weapon := _weapon [ 1 ] ;
20473: LD_ADDR_VAR 0 5
20477: PUSH
20478: LD_VAR 0 10
20482: PUSH
20483: LD_INT 1
20485: ARRAY
20486: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20487: LD_ADDR_VAR 0 10
20491: PUSH
20492: LD_VAR 0 10
20496: PPUSH
20497: LD_INT 1
20499: PPUSH
20500: CALL_OW 3
20504: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20505: LD_VAR 0 2
20509: PPUSH
20510: LD_VAR 0 5
20514: PPUSH
20515: CALL 20828 0 2
20519: IFTRUE 20530
20521: PUSH
20522: LD_VAR 0 10
20526: PUSH
20527: EMPTY
20528: EQUAL
20529: OR
20530: IFFALSE 20473
// result := [ ] ;
20532: LD_ADDR_VAR 0 6
20536: PUSH
20537: EMPTY
20538: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20539: LD_VAR 0 1
20543: PPUSH
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_VAR 0 3
20553: PPUSH
20554: LD_VAR 0 4
20558: PPUSH
20559: LD_VAR 0 5
20563: PPUSH
20564: CALL_OW 448
20568: IFFALSE 20601
// result := [ chassis , engine , control , weapon ] ;
20570: LD_ADDR_VAR 0 6
20574: PUSH
20575: LD_VAR 0 2
20579: PUSH
20580: LD_VAR 0 3
20584: PUSH
20585: LD_VAR 0 4
20589: PUSH
20590: LD_VAR 0 5
20594: PUSH
20595: EMPTY
20596: LIST
20597: LIST
20598: LIST
20599: LIST
20600: ST_TO_ADDR
// end ;
20601: LD_VAR 0 6
20605: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20606: LD_INT 0
20608: PPUSH
// if not chassis or not engine then
20609: LD_VAR 0 1
20613: NOT
20614: IFTRUE 20623
20616: PUSH
20617: LD_VAR 0 2
20621: NOT
20622: OR
20623: IFFALSE 20627
// exit ;
20625: GO 20823
// case engine of engine_solar :
20627: LD_VAR 0 2
20631: PUSH
20632: LD_INT 2
20634: DOUBLE
20635: EQUAL
20636: IFTRUE 20640
20638: GO 20678
20640: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20641: LD_ADDR_VAR 0 3
20645: PUSH
20646: LD_INT 11
20648: PUSH
20649: LD_INT 12
20651: PUSH
20652: LD_INT 13
20654: PUSH
20655: LD_INT 14
20657: PUSH
20658: LD_INT 1
20660: PUSH
20661: LD_INT 2
20663: PUSH
20664: LD_INT 3
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: LIST
20671: LIST
20672: LIST
20673: LIST
20674: LIST
20675: ST_TO_ADDR
20676: GO 20807
20678: LD_INT 1
20680: DOUBLE
20681: EQUAL
20682: IFTRUE 20686
20684: GO 20748
20686: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20687: LD_ADDR_VAR 0 3
20691: PUSH
20692: LD_INT 11
20694: PUSH
20695: LD_INT 12
20697: PUSH
20698: LD_INT 13
20700: PUSH
20701: LD_INT 14
20703: PUSH
20704: LD_INT 1
20706: PUSH
20707: LD_INT 2
20709: PUSH
20710: LD_INT 3
20712: PUSH
20713: LD_INT 4
20715: PUSH
20716: LD_INT 5
20718: PUSH
20719: LD_INT 21
20721: PUSH
20722: LD_INT 23
20724: PUSH
20725: LD_INT 22
20727: PUSH
20728: LD_INT 24
20730: PUSH
20731: EMPTY
20732: LIST
20733: LIST
20734: LIST
20735: LIST
20736: LIST
20737: LIST
20738: LIST
20739: LIST
20740: LIST
20741: LIST
20742: LIST
20743: LIST
20744: LIST
20745: ST_TO_ADDR
20746: GO 20807
20748: LD_INT 3
20750: DOUBLE
20751: EQUAL
20752: IFTRUE 20756
20754: GO 20806
20756: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20757: LD_ADDR_VAR 0 3
20761: PUSH
20762: LD_INT 13
20764: PUSH
20765: LD_INT 14
20767: PUSH
20768: LD_INT 2
20770: PUSH
20771: LD_INT 3
20773: PUSH
20774: LD_INT 4
20776: PUSH
20777: LD_INT 5
20779: PUSH
20780: LD_INT 21
20782: PUSH
20783: LD_INT 22
20785: PUSH
20786: LD_INT 23
20788: PUSH
20789: LD_INT 24
20791: PUSH
20792: EMPTY
20793: LIST
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: LIST
20799: LIST
20800: LIST
20801: LIST
20802: LIST
20803: ST_TO_ADDR
20804: GO 20807
20806: POP
// result := ( chassis in result ) ;
20807: LD_ADDR_VAR 0 3
20811: PUSH
20812: LD_VAR 0 1
20816: PUSH
20817: LD_VAR 0 3
20821: IN
20822: ST_TO_ADDR
// end ;
20823: LD_VAR 0 3
20827: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20828: LD_INT 0
20830: PPUSH
// if not chassis or not weapon then
20831: LD_VAR 0 1
20835: NOT
20836: IFTRUE 20845
20838: PUSH
20839: LD_VAR 0 2
20843: NOT
20844: OR
20845: IFFALSE 20849
// exit ;
20847: GO 21909
// case weapon of us_machine_gun :
20849: LD_VAR 0 2
20853: PUSH
20854: LD_INT 2
20856: DOUBLE
20857: EQUAL
20858: IFTRUE 20862
20860: GO 20892
20862: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20863: LD_ADDR_VAR 0 3
20867: PUSH
20868: LD_INT 1
20870: PUSH
20871: LD_INT 2
20873: PUSH
20874: LD_INT 3
20876: PUSH
20877: LD_INT 4
20879: PUSH
20880: LD_INT 5
20882: PUSH
20883: EMPTY
20884: LIST
20885: LIST
20886: LIST
20887: LIST
20888: LIST
20889: ST_TO_ADDR
20890: GO 21893
20892: LD_INT 3
20894: DOUBLE
20895: EQUAL
20896: IFTRUE 20900
20898: GO 20930
20900: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20901: LD_ADDR_VAR 0 3
20905: PUSH
20906: LD_INT 1
20908: PUSH
20909: LD_INT 2
20911: PUSH
20912: LD_INT 3
20914: PUSH
20915: LD_INT 4
20917: PUSH
20918: LD_INT 5
20920: PUSH
20921: EMPTY
20922: LIST
20923: LIST
20924: LIST
20925: LIST
20926: LIST
20927: ST_TO_ADDR
20928: GO 21893
20930: LD_INT 11
20932: DOUBLE
20933: EQUAL
20934: IFTRUE 20938
20936: GO 20968
20938: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20939: LD_ADDR_VAR 0 3
20943: PUSH
20944: LD_INT 1
20946: PUSH
20947: LD_INT 2
20949: PUSH
20950: LD_INT 3
20952: PUSH
20953: LD_INT 4
20955: PUSH
20956: LD_INT 5
20958: PUSH
20959: EMPTY
20960: LIST
20961: LIST
20962: LIST
20963: LIST
20964: LIST
20965: ST_TO_ADDR
20966: GO 21893
20968: LD_INT 4
20970: DOUBLE
20971: EQUAL
20972: IFTRUE 20976
20974: GO 21002
20976: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20977: LD_ADDR_VAR 0 3
20981: PUSH
20982: LD_INT 2
20984: PUSH
20985: LD_INT 3
20987: PUSH
20988: LD_INT 4
20990: PUSH
20991: LD_INT 5
20993: PUSH
20994: EMPTY
20995: LIST
20996: LIST
20997: LIST
20998: LIST
20999: ST_TO_ADDR
21000: GO 21893
21002: LD_INT 5
21004: DOUBLE
21005: EQUAL
21006: IFTRUE 21010
21008: GO 21036
21010: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
21011: LD_ADDR_VAR 0 3
21015: PUSH
21016: LD_INT 2
21018: PUSH
21019: LD_INT 3
21021: PUSH
21022: LD_INT 4
21024: PUSH
21025: LD_INT 5
21027: PUSH
21028: EMPTY
21029: LIST
21030: LIST
21031: LIST
21032: LIST
21033: ST_TO_ADDR
21034: GO 21893
21036: LD_INT 9
21038: DOUBLE
21039: EQUAL
21040: IFTRUE 21044
21042: GO 21070
21044: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
21045: LD_ADDR_VAR 0 3
21049: PUSH
21050: LD_INT 2
21052: PUSH
21053: LD_INT 3
21055: PUSH
21056: LD_INT 4
21058: PUSH
21059: LD_INT 5
21061: PUSH
21062: EMPTY
21063: LIST
21064: LIST
21065: LIST
21066: LIST
21067: ST_TO_ADDR
21068: GO 21893
21070: LD_INT 7
21072: DOUBLE
21073: EQUAL
21074: IFTRUE 21078
21076: GO 21104
21078: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
21079: LD_ADDR_VAR 0 3
21083: PUSH
21084: LD_INT 2
21086: PUSH
21087: LD_INT 3
21089: PUSH
21090: LD_INT 4
21092: PUSH
21093: LD_INT 5
21095: PUSH
21096: EMPTY
21097: LIST
21098: LIST
21099: LIST
21100: LIST
21101: ST_TO_ADDR
21102: GO 21893
21104: LD_INT 12
21106: DOUBLE
21107: EQUAL
21108: IFTRUE 21112
21110: GO 21138
21112: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
21113: LD_ADDR_VAR 0 3
21117: PUSH
21118: LD_INT 2
21120: PUSH
21121: LD_INT 3
21123: PUSH
21124: LD_INT 4
21126: PUSH
21127: LD_INT 5
21129: PUSH
21130: EMPTY
21131: LIST
21132: LIST
21133: LIST
21134: LIST
21135: ST_TO_ADDR
21136: GO 21893
21138: LD_INT 13
21140: DOUBLE
21141: EQUAL
21142: IFTRUE 21146
21144: GO 21172
21146: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
21147: LD_ADDR_VAR 0 3
21151: PUSH
21152: LD_INT 2
21154: PUSH
21155: LD_INT 3
21157: PUSH
21158: LD_INT 4
21160: PUSH
21161: LD_INT 5
21163: PUSH
21164: EMPTY
21165: LIST
21166: LIST
21167: LIST
21168: LIST
21169: ST_TO_ADDR
21170: GO 21893
21172: LD_INT 14
21174: DOUBLE
21175: EQUAL
21176: IFTRUE 21180
21178: GO 21198
21180: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21181: LD_ADDR_VAR 0 3
21185: PUSH
21186: LD_INT 4
21188: PUSH
21189: LD_INT 5
21191: PUSH
21192: EMPTY
21193: LIST
21194: LIST
21195: ST_TO_ADDR
21196: GO 21893
21198: LD_INT 6
21200: DOUBLE
21201: EQUAL
21202: IFTRUE 21206
21204: GO 21224
21206: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21207: LD_ADDR_VAR 0 3
21211: PUSH
21212: LD_INT 4
21214: PUSH
21215: LD_INT 5
21217: PUSH
21218: EMPTY
21219: LIST
21220: LIST
21221: ST_TO_ADDR
21222: GO 21893
21224: LD_INT 10
21226: DOUBLE
21227: EQUAL
21228: IFTRUE 21232
21230: GO 21250
21232: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21233: LD_ADDR_VAR 0 3
21237: PUSH
21238: LD_INT 4
21240: PUSH
21241: LD_INT 5
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: ST_TO_ADDR
21248: GO 21893
21250: LD_INT 22
21252: DOUBLE
21253: EQUAL
21254: IFTRUE 21258
21256: GO 21284
21258: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21259: LD_ADDR_VAR 0 3
21263: PUSH
21264: LD_INT 11
21266: PUSH
21267: LD_INT 12
21269: PUSH
21270: LD_INT 13
21272: PUSH
21273: LD_INT 14
21275: PUSH
21276: EMPTY
21277: LIST
21278: LIST
21279: LIST
21280: LIST
21281: ST_TO_ADDR
21282: GO 21893
21284: LD_INT 23
21286: DOUBLE
21287: EQUAL
21288: IFTRUE 21292
21290: GO 21318
21292: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21293: LD_ADDR_VAR 0 3
21297: PUSH
21298: LD_INT 11
21300: PUSH
21301: LD_INT 12
21303: PUSH
21304: LD_INT 13
21306: PUSH
21307: LD_INT 14
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: LIST
21314: LIST
21315: ST_TO_ADDR
21316: GO 21893
21318: LD_INT 24
21320: DOUBLE
21321: EQUAL
21322: IFTRUE 21326
21324: GO 21352
21326: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21327: LD_ADDR_VAR 0 3
21331: PUSH
21332: LD_INT 11
21334: PUSH
21335: LD_INT 12
21337: PUSH
21338: LD_INT 13
21340: PUSH
21341: LD_INT 14
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: LIST
21348: LIST
21349: ST_TO_ADDR
21350: GO 21893
21352: LD_INT 30
21354: DOUBLE
21355: EQUAL
21356: IFTRUE 21360
21358: GO 21386
21360: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21361: LD_ADDR_VAR 0 3
21365: PUSH
21366: LD_INT 11
21368: PUSH
21369: LD_INT 12
21371: PUSH
21372: LD_INT 13
21374: PUSH
21375: LD_INT 14
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: LIST
21382: LIST
21383: ST_TO_ADDR
21384: GO 21893
21386: LD_INT 25
21388: DOUBLE
21389: EQUAL
21390: IFTRUE 21394
21392: GO 21412
21394: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21395: LD_ADDR_VAR 0 3
21399: PUSH
21400: LD_INT 13
21402: PUSH
21403: LD_INT 14
21405: PUSH
21406: EMPTY
21407: LIST
21408: LIST
21409: ST_TO_ADDR
21410: GO 21893
21412: LD_INT 27
21414: DOUBLE
21415: EQUAL
21416: IFTRUE 21420
21418: GO 21438
21420: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21421: LD_ADDR_VAR 0 3
21425: PUSH
21426: LD_INT 13
21428: PUSH
21429: LD_INT 14
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: ST_TO_ADDR
21436: GO 21893
21438: LD_INT 92
21440: DOUBLE
21441: EQUAL
21442: IFTRUE 21446
21444: GO 21472
21446: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21447: LD_ADDR_VAR 0 3
21451: PUSH
21452: LD_INT 11
21454: PUSH
21455: LD_INT 12
21457: PUSH
21458: LD_INT 13
21460: PUSH
21461: LD_INT 14
21463: PUSH
21464: EMPTY
21465: LIST
21466: LIST
21467: LIST
21468: LIST
21469: ST_TO_ADDR
21470: GO 21893
21472: LD_INT 28
21474: DOUBLE
21475: EQUAL
21476: IFTRUE 21480
21478: GO 21498
21480: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21481: LD_ADDR_VAR 0 3
21485: PUSH
21486: LD_INT 13
21488: PUSH
21489: LD_INT 14
21491: PUSH
21492: EMPTY
21493: LIST
21494: LIST
21495: ST_TO_ADDR
21496: GO 21893
21498: LD_INT 29
21500: DOUBLE
21501: EQUAL
21502: IFTRUE 21506
21504: GO 21524
21506: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21507: LD_ADDR_VAR 0 3
21511: PUSH
21512: LD_INT 13
21514: PUSH
21515: LD_INT 14
21517: PUSH
21518: EMPTY
21519: LIST
21520: LIST
21521: ST_TO_ADDR
21522: GO 21893
21524: LD_INT 31
21526: DOUBLE
21527: EQUAL
21528: IFTRUE 21532
21530: GO 21550
21532: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21533: LD_ADDR_VAR 0 3
21537: PUSH
21538: LD_INT 13
21540: PUSH
21541: LD_INT 14
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: ST_TO_ADDR
21548: GO 21893
21550: LD_INT 26
21552: DOUBLE
21553: EQUAL
21554: IFTRUE 21558
21556: GO 21576
21558: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21559: LD_ADDR_VAR 0 3
21563: PUSH
21564: LD_INT 13
21566: PUSH
21567: LD_INT 14
21569: PUSH
21570: EMPTY
21571: LIST
21572: LIST
21573: ST_TO_ADDR
21574: GO 21893
21576: LD_INT 42
21578: DOUBLE
21579: EQUAL
21580: IFTRUE 21584
21582: GO 21610
21584: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21585: LD_ADDR_VAR 0 3
21589: PUSH
21590: LD_INT 21
21592: PUSH
21593: LD_INT 22
21595: PUSH
21596: LD_INT 23
21598: PUSH
21599: LD_INT 24
21601: PUSH
21602: EMPTY
21603: LIST
21604: LIST
21605: LIST
21606: LIST
21607: ST_TO_ADDR
21608: GO 21893
21610: LD_INT 43
21612: DOUBLE
21613: EQUAL
21614: IFTRUE 21618
21616: GO 21644
21618: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21619: LD_ADDR_VAR 0 3
21623: PUSH
21624: LD_INT 21
21626: PUSH
21627: LD_INT 22
21629: PUSH
21630: LD_INT 23
21632: PUSH
21633: LD_INT 24
21635: PUSH
21636: EMPTY
21637: LIST
21638: LIST
21639: LIST
21640: LIST
21641: ST_TO_ADDR
21642: GO 21893
21644: LD_INT 44
21646: DOUBLE
21647: EQUAL
21648: IFTRUE 21652
21650: GO 21678
21652: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21653: LD_ADDR_VAR 0 3
21657: PUSH
21658: LD_INT 21
21660: PUSH
21661: LD_INT 22
21663: PUSH
21664: LD_INT 23
21666: PUSH
21667: LD_INT 24
21669: PUSH
21670: EMPTY
21671: LIST
21672: LIST
21673: LIST
21674: LIST
21675: ST_TO_ADDR
21676: GO 21893
21678: LD_INT 45
21680: DOUBLE
21681: EQUAL
21682: IFTRUE 21686
21684: GO 21712
21686: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21687: LD_ADDR_VAR 0 3
21691: PUSH
21692: LD_INT 21
21694: PUSH
21695: LD_INT 22
21697: PUSH
21698: LD_INT 23
21700: PUSH
21701: LD_INT 24
21703: PUSH
21704: EMPTY
21705: LIST
21706: LIST
21707: LIST
21708: LIST
21709: ST_TO_ADDR
21710: GO 21893
21712: LD_INT 49
21714: DOUBLE
21715: EQUAL
21716: IFTRUE 21720
21718: GO 21746
21720: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21721: LD_ADDR_VAR 0 3
21725: PUSH
21726: LD_INT 21
21728: PUSH
21729: LD_INT 22
21731: PUSH
21732: LD_INT 23
21734: PUSH
21735: LD_INT 24
21737: PUSH
21738: EMPTY
21739: LIST
21740: LIST
21741: LIST
21742: LIST
21743: ST_TO_ADDR
21744: GO 21893
21746: LD_INT 51
21748: DOUBLE
21749: EQUAL
21750: IFTRUE 21754
21752: GO 21780
21754: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21755: LD_ADDR_VAR 0 3
21759: PUSH
21760: LD_INT 21
21762: PUSH
21763: LD_INT 22
21765: PUSH
21766: LD_INT 23
21768: PUSH
21769: LD_INT 24
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: LIST
21776: LIST
21777: ST_TO_ADDR
21778: GO 21893
21780: LD_INT 52
21782: DOUBLE
21783: EQUAL
21784: IFTRUE 21788
21786: GO 21814
21788: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21789: LD_ADDR_VAR 0 3
21793: PUSH
21794: LD_INT 21
21796: PUSH
21797: LD_INT 22
21799: PUSH
21800: LD_INT 23
21802: PUSH
21803: LD_INT 24
21805: PUSH
21806: EMPTY
21807: LIST
21808: LIST
21809: LIST
21810: LIST
21811: ST_TO_ADDR
21812: GO 21893
21814: LD_INT 53
21816: DOUBLE
21817: EQUAL
21818: IFTRUE 21822
21820: GO 21840
21822: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21823: LD_ADDR_VAR 0 3
21827: PUSH
21828: LD_INT 23
21830: PUSH
21831: LD_INT 24
21833: PUSH
21834: EMPTY
21835: LIST
21836: LIST
21837: ST_TO_ADDR
21838: GO 21893
21840: LD_INT 46
21842: DOUBLE
21843: EQUAL
21844: IFTRUE 21848
21846: GO 21866
21848: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21849: LD_ADDR_VAR 0 3
21853: PUSH
21854: LD_INT 23
21856: PUSH
21857: LD_INT 24
21859: PUSH
21860: EMPTY
21861: LIST
21862: LIST
21863: ST_TO_ADDR
21864: GO 21893
21866: LD_INT 47
21868: DOUBLE
21869: EQUAL
21870: IFTRUE 21874
21872: GO 21892
21874: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21875: LD_ADDR_VAR 0 3
21879: PUSH
21880: LD_INT 23
21882: PUSH
21883: LD_INT 24
21885: PUSH
21886: EMPTY
21887: LIST
21888: LIST
21889: ST_TO_ADDR
21890: GO 21893
21892: POP
// result := ( chassis in result ) ;
21893: LD_ADDR_VAR 0 3
21897: PUSH
21898: LD_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: IN
21908: ST_TO_ADDR
// end ;
21909: LD_VAR 0 3
21913: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21914: LD_INT 0
21916: PPUSH
21917: PPUSH
21918: PPUSH
21919: PPUSH
21920: PPUSH
21921: PPUSH
21922: PPUSH
// result := array ;
21923: LD_ADDR_VAR 0 5
21927: PUSH
21928: LD_VAR 0 1
21932: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21933: LD_VAR 0 1
21937: NOT
21938: IFTRUE 21947
21940: PUSH
21941: LD_VAR 0 2
21945: NOT
21946: OR
21947: IFTRUE 21956
21949: PUSH
21950: LD_VAR 0 3
21954: NOT
21955: OR
21956: IFTRUE 21970
21958: PUSH
21959: LD_VAR 0 2
21963: PUSH
21964: LD_VAR 0 1
21968: GREATER
21969: OR
21970: IFTRUE 21984
21972: PUSH
21973: LD_VAR 0 3
21977: PUSH
21978: LD_VAR 0 1
21982: GREATER
21983: OR
21984: IFFALSE 21988
// exit ;
21986: GO 22284
// if direction then
21988: LD_VAR 0 4
21992: IFFALSE 22056
// begin d := 1 ;
21994: LD_ADDR_VAR 0 9
21998: PUSH
21999: LD_INT 1
22001: ST_TO_ADDR
// if i_from > i_to then
22002: LD_VAR 0 2
22006: PUSH
22007: LD_VAR 0 3
22011: GREATER
22012: IFFALSE 22038
// length := ( array - i_from ) + i_to else
22014: LD_ADDR_VAR 0 11
22018: PUSH
22019: LD_VAR 0 1
22023: PUSH
22024: LD_VAR 0 2
22028: MINUS
22029: PUSH
22030: LD_VAR 0 3
22034: PLUS
22035: ST_TO_ADDR
22036: GO 22054
// length := i_to - i_from ;
22038: LD_ADDR_VAR 0 11
22042: PUSH
22043: LD_VAR 0 3
22047: PUSH
22048: LD_VAR 0 2
22052: MINUS
22053: ST_TO_ADDR
// end else
22054: GO 22117
// begin d := - 1 ;
22056: LD_ADDR_VAR 0 9
22060: PUSH
22061: LD_INT 1
22063: NEG
22064: ST_TO_ADDR
// if i_from > i_to then
22065: LD_VAR 0 2
22069: PUSH
22070: LD_VAR 0 3
22074: GREATER
22075: IFFALSE 22095
// length := i_from - i_to else
22077: LD_ADDR_VAR 0 11
22081: PUSH
22082: LD_VAR 0 2
22086: PUSH
22087: LD_VAR 0 3
22091: MINUS
22092: ST_TO_ADDR
22093: GO 22117
// length := ( array - i_to ) + i_from ;
22095: LD_ADDR_VAR 0 11
22099: PUSH
22100: LD_VAR 0 1
22104: PUSH
22105: LD_VAR 0 3
22109: MINUS
22110: PUSH
22111: LD_VAR 0 2
22115: PLUS
22116: ST_TO_ADDR
// end ; if not length then
22117: LD_VAR 0 11
22121: NOT
22122: IFFALSE 22126
// exit ;
22124: GO 22284
// tmp := array ;
22126: LD_ADDR_VAR 0 10
22130: PUSH
22131: LD_VAR 0 1
22135: ST_TO_ADDR
// for i = 1 to length do
22136: LD_ADDR_VAR 0 6
22140: PUSH
22141: DOUBLE
22142: LD_INT 1
22144: DEC
22145: ST_TO_ADDR
22146: LD_VAR 0 11
22150: PUSH
22151: FOR_TO
22152: IFFALSE 22272
// begin for j = 1 to array do
22154: LD_ADDR_VAR 0 7
22158: PUSH
22159: DOUBLE
22160: LD_INT 1
22162: DEC
22163: ST_TO_ADDR
22164: LD_VAR 0 1
22168: PUSH
22169: FOR_TO
22170: IFFALSE 22258
// begin k := j + d ;
22172: LD_ADDR_VAR 0 8
22176: PUSH
22177: LD_VAR 0 7
22181: PUSH
22182: LD_VAR 0 9
22186: PLUS
22187: ST_TO_ADDR
// if k > array then
22188: LD_VAR 0 8
22192: PUSH
22193: LD_VAR 0 1
22197: GREATER
22198: IFFALSE 22208
// k := 1 ;
22200: LD_ADDR_VAR 0 8
22204: PUSH
22205: LD_INT 1
22207: ST_TO_ADDR
// if not k then
22208: LD_VAR 0 8
22212: NOT
22213: IFFALSE 22225
// k := array ;
22215: LD_ADDR_VAR 0 8
22219: PUSH
22220: LD_VAR 0 1
22224: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22225: LD_ADDR_VAR 0 10
22229: PUSH
22230: LD_VAR 0 10
22234: PPUSH
22235: LD_VAR 0 8
22239: PPUSH
22240: LD_VAR 0 1
22244: PUSH
22245: LD_VAR 0 7
22249: ARRAY
22250: PPUSH
22251: CALL_OW 1
22255: ST_TO_ADDR
// end ;
22256: GO 22169
22258: POP
22259: POP
// array := tmp ;
22260: LD_ADDR_VAR 0 1
22264: PUSH
22265: LD_VAR 0 10
22269: ST_TO_ADDR
// end ;
22270: GO 22151
22272: POP
22273: POP
// result := array ;
22274: LD_ADDR_VAR 0 5
22278: PUSH
22279: LD_VAR 0 1
22283: ST_TO_ADDR
// end ;
22284: LD_VAR 0 5
22288: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22289: LD_INT 0
22291: PPUSH
22292: PPUSH
// result := 0 ;
22293: LD_ADDR_VAR 0 3
22297: PUSH
22298: LD_INT 0
22300: ST_TO_ADDR
// if not array or not value in array then
22301: LD_VAR 0 1
22305: NOT
22306: IFTRUE 22321
22308: PUSH
22309: LD_VAR 0 2
22313: PUSH
22314: LD_VAR 0 1
22318: IN
22319: NOT
22320: OR
22321: IFFALSE 22325
// exit ;
22323: GO 22379
// for i = 1 to array do
22325: LD_ADDR_VAR 0 4
22329: PUSH
22330: DOUBLE
22331: LD_INT 1
22333: DEC
22334: ST_TO_ADDR
22335: LD_VAR 0 1
22339: PUSH
22340: FOR_TO
22341: IFFALSE 22377
// if value = array [ i ] then
22343: LD_VAR 0 2
22347: PUSH
22348: LD_VAR 0 1
22352: PUSH
22353: LD_VAR 0 4
22357: ARRAY
22358: EQUAL
22359: IFFALSE 22375
// begin result := i ;
22361: LD_ADDR_VAR 0 3
22365: PUSH
22366: LD_VAR 0 4
22370: ST_TO_ADDR
// exit ;
22371: POP
22372: POP
22373: GO 22379
// end ;
22375: GO 22340
22377: POP
22378: POP
// end ;
22379: LD_VAR 0 3
22383: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22384: LD_INT 0
22386: PPUSH
// vc_chassis := chassis ;
22387: LD_ADDR_OWVAR 37
22391: PUSH
22392: LD_VAR 0 1
22396: ST_TO_ADDR
// vc_engine := engine ;
22397: LD_ADDR_OWVAR 39
22401: PUSH
22402: LD_VAR 0 2
22406: ST_TO_ADDR
// vc_control := control ;
22407: LD_ADDR_OWVAR 38
22411: PUSH
22412: LD_VAR 0 3
22416: ST_TO_ADDR
// vc_weapon := weapon ;
22417: LD_ADDR_OWVAR 40
22421: PUSH
22422: LD_VAR 0 4
22426: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22427: LD_ADDR_OWVAR 41
22431: PUSH
22432: LD_VAR 0 5
22436: ST_TO_ADDR
// end ;
22437: LD_VAR 0 6
22441: RET
// export function WantPlant ( unit ) ; var task ; begin
22442: LD_INT 0
22444: PPUSH
22445: PPUSH
// result := false ;
22446: LD_ADDR_VAR 0 2
22450: PUSH
22451: LD_INT 0
22453: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22454: LD_ADDR_VAR 0 3
22458: PUSH
22459: LD_VAR 0 1
22463: PPUSH
22464: CALL_OW 437
22468: ST_TO_ADDR
// if task then
22469: LD_VAR 0 3
22473: IFFALSE 22501
// if task [ 1 ] [ 1 ] = p then
22475: LD_VAR 0 3
22479: PUSH
22480: LD_INT 1
22482: ARRAY
22483: PUSH
22484: LD_INT 1
22486: ARRAY
22487: PUSH
22488: LD_STRING p
22490: EQUAL
22491: IFFALSE 22501
// result := true ;
22493: LD_ADDR_VAR 0 2
22497: PUSH
22498: LD_INT 1
22500: ST_TO_ADDR
// end ;
22501: LD_VAR 0 2
22505: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22506: LD_INT 0
22508: PPUSH
22509: PPUSH
22510: PPUSH
22511: PPUSH
// if pos < 1 then
22512: LD_VAR 0 2
22516: PUSH
22517: LD_INT 1
22519: LESS
22520: IFFALSE 22524
// exit ;
22522: GO 22827
// if pos = 1 then
22524: LD_VAR 0 2
22528: PUSH
22529: LD_INT 1
22531: EQUAL
22532: IFFALSE 22565
// result := Replace ( arr , pos [ 1 ] , value ) else
22534: LD_ADDR_VAR 0 4
22538: PUSH
22539: LD_VAR 0 1
22543: PPUSH
22544: LD_VAR 0 2
22548: PUSH
22549: LD_INT 1
22551: ARRAY
22552: PPUSH
22553: LD_VAR 0 3
22557: PPUSH
22558: CALL_OW 1
22562: ST_TO_ADDR
22563: GO 22827
// begin tmp := arr ;
22565: LD_ADDR_VAR 0 6
22569: PUSH
22570: LD_VAR 0 1
22574: ST_TO_ADDR
// s_arr := [ tmp ] ;
22575: LD_ADDR_VAR 0 7
22579: PUSH
22580: LD_VAR 0 6
22584: PUSH
22585: EMPTY
22586: LIST
22587: ST_TO_ADDR
// for i = 1 to pos - 1 do
22588: LD_ADDR_VAR 0 5
22592: PUSH
22593: DOUBLE
22594: LD_INT 1
22596: DEC
22597: ST_TO_ADDR
22598: LD_VAR 0 2
22602: PUSH
22603: LD_INT 1
22605: MINUS
22606: PUSH
22607: FOR_TO
22608: IFFALSE 22653
// begin tmp := tmp [ pos [ i ] ] ;
22610: LD_ADDR_VAR 0 6
22614: PUSH
22615: LD_VAR 0 6
22619: PUSH
22620: LD_VAR 0 2
22624: PUSH
22625: LD_VAR 0 5
22629: ARRAY
22630: ARRAY
22631: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22632: LD_ADDR_VAR 0 7
22636: PUSH
22637: LD_VAR 0 7
22641: PUSH
22642: LD_VAR 0 6
22646: PUSH
22647: EMPTY
22648: LIST
22649: ADD
22650: ST_TO_ADDR
// end ;
22651: GO 22607
22653: POP
22654: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22655: LD_ADDR_VAR 0 6
22659: PUSH
22660: LD_VAR 0 6
22664: PPUSH
22665: LD_VAR 0 2
22669: PUSH
22670: LD_VAR 0 2
22674: ARRAY
22675: PPUSH
22676: LD_VAR 0 3
22680: PPUSH
22681: CALL_OW 1
22685: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22686: LD_ADDR_VAR 0 7
22690: PUSH
22691: LD_VAR 0 7
22695: PPUSH
22696: LD_VAR 0 7
22700: PPUSH
22701: LD_VAR 0 6
22705: PPUSH
22706: CALL_OW 1
22710: ST_TO_ADDR
// for i = s_arr downto 2 do
22711: LD_ADDR_VAR 0 5
22715: PUSH
22716: DOUBLE
22717: LD_VAR 0 7
22721: INC
22722: ST_TO_ADDR
22723: LD_INT 2
22725: PUSH
22726: FOR_DOWNTO
22727: IFFALSE 22811
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22729: LD_ADDR_VAR 0 6
22733: PUSH
22734: LD_VAR 0 7
22738: PUSH
22739: LD_VAR 0 5
22743: PUSH
22744: LD_INT 1
22746: MINUS
22747: ARRAY
22748: PPUSH
22749: LD_VAR 0 2
22753: PUSH
22754: LD_VAR 0 5
22758: PUSH
22759: LD_INT 1
22761: MINUS
22762: ARRAY
22763: PPUSH
22764: LD_VAR 0 7
22768: PUSH
22769: LD_VAR 0 5
22773: ARRAY
22774: PPUSH
22775: CALL_OW 1
22779: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22780: LD_ADDR_VAR 0 7
22784: PUSH
22785: LD_VAR 0 7
22789: PPUSH
22790: LD_VAR 0 5
22794: PUSH
22795: LD_INT 1
22797: MINUS
22798: PPUSH
22799: LD_VAR 0 6
22803: PPUSH
22804: CALL_OW 1
22808: ST_TO_ADDR
// end ;
22809: GO 22726
22811: POP
22812: POP
// result := s_arr [ 1 ] ;
22813: LD_ADDR_VAR 0 4
22817: PUSH
22818: LD_VAR 0 7
22822: PUSH
22823: LD_INT 1
22825: ARRAY
22826: ST_TO_ADDR
// end ; end ;
22827: LD_VAR 0 4
22831: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22832: LD_INT 0
22834: PPUSH
22835: PPUSH
// if not list then
22836: LD_VAR 0 1
22840: NOT
22841: IFFALSE 22845
// exit ;
22843: GO 22936
// i := list [ pos1 ] ;
22845: LD_ADDR_VAR 0 5
22849: PUSH
22850: LD_VAR 0 1
22854: PUSH
22855: LD_VAR 0 2
22859: ARRAY
22860: ST_TO_ADDR
// if not i then
22861: LD_VAR 0 5
22865: NOT
22866: IFFALSE 22870
// exit ;
22868: GO 22936
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22870: LD_ADDR_VAR 0 1
22874: PUSH
22875: LD_VAR 0 1
22879: PPUSH
22880: LD_VAR 0 2
22884: PPUSH
22885: LD_VAR 0 1
22889: PUSH
22890: LD_VAR 0 3
22894: ARRAY
22895: PPUSH
22896: CALL_OW 1
22900: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22901: LD_ADDR_VAR 0 1
22905: PUSH
22906: LD_VAR 0 1
22910: PPUSH
22911: LD_VAR 0 3
22915: PPUSH
22916: LD_VAR 0 5
22920: PPUSH
22921: CALL_OW 1
22925: ST_TO_ADDR
// result := list ;
22926: LD_ADDR_VAR 0 4
22930: PUSH
22931: LD_VAR 0 1
22935: ST_TO_ADDR
// end ;
22936: LD_VAR 0 4
22940: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22941: LD_INT 0
22943: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22944: LD_ADDR_VAR 0 5
22948: PUSH
22949: LD_VAR 0 1
22953: PPUSH
22954: CALL_OW 250
22958: PPUSH
22959: LD_VAR 0 1
22963: PPUSH
22964: CALL_OW 251
22968: PPUSH
22969: LD_VAR 0 2
22973: PPUSH
22974: LD_VAR 0 3
22978: PPUSH
22979: LD_VAR 0 4
22983: PPUSH
22984: CALL 23366 0 5
22988: ST_TO_ADDR
// end ;
22989: LD_VAR 0 5
22993: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
22994: LD_INT 0
22996: PPUSH
22997: PPUSH
22998: PPUSH
22999: PPUSH
// if not list or not unit then
23000: LD_VAR 0 2
23004: NOT
23005: IFTRUE 23014
23007: PUSH
23008: LD_VAR 0 1
23012: NOT
23013: OR
23014: IFFALSE 23018
// exit ;
23016: GO 23361
// result := [ ] ;
23018: LD_ADDR_VAR 0 5
23022: PUSH
23023: EMPTY
23024: ST_TO_ADDR
// for i in list do
23025: LD_ADDR_VAR 0 6
23029: PUSH
23030: LD_VAR 0 2
23034: PUSH
23035: FOR_IN
23036: IFFALSE 23254
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
23038: LD_ADDR_VAR 0 8
23042: PUSH
23043: LD_VAR 0 1
23047: PPUSH
23048: LD_VAR 0 6
23052: PUSH
23053: LD_INT 1
23055: ARRAY
23056: PPUSH
23057: LD_VAR 0 6
23061: PUSH
23062: LD_INT 2
23064: ARRAY
23065: PPUSH
23066: CALL_OW 297
23070: ST_TO_ADDR
// if not Count ( result ) then
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL 19622 0 1
23080: NOT
23081: IFFALSE 23114
// begin result := Join ( result , [ i , tmp ] ) ;
23083: LD_ADDR_VAR 0 5
23087: PUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: LD_VAR 0 6
23097: PUSH
23098: LD_VAR 0 8
23102: PUSH
23103: EMPTY
23104: LIST
23105: LIST
23106: PPUSH
23107: CALL 55554 0 2
23111: ST_TO_ADDR
// continue ;
23112: GO 23035
// end ; if result [ result ] [ 2 ] <= tmp then
23114: LD_VAR 0 5
23118: PUSH
23119: LD_VAR 0 5
23123: ARRAY
23124: PUSH
23125: LD_INT 2
23127: ARRAY
23128: PUSH
23129: LD_VAR 0 8
23133: LESSEQUAL
23134: IFFALSE 23167
// result := Join ( result , [ i , tmp ] ) else
23136: LD_ADDR_VAR 0 5
23140: PUSH
23141: LD_VAR 0 5
23145: PPUSH
23146: LD_VAR 0 6
23150: PUSH
23151: LD_VAR 0 8
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PPUSH
23160: CALL 55554 0 2
23164: ST_TO_ADDR
23165: GO 23252
// begin for j := 1 to Count ( result ) do
23167: LD_ADDR_VAR 0 7
23171: PUSH
23172: DOUBLE
23173: LD_INT 1
23175: DEC
23176: ST_TO_ADDR
23177: LD_VAR 0 5
23181: PPUSH
23182: CALL 19622 0 1
23186: PUSH
23187: FOR_TO
23188: IFFALSE 23250
// begin if tmp < result [ j ] [ 2 ] then
23190: LD_VAR 0 8
23194: PUSH
23195: LD_VAR 0 5
23199: PUSH
23200: LD_VAR 0 7
23204: ARRAY
23205: PUSH
23206: LD_INT 2
23208: ARRAY
23209: LESS
23210: IFFALSE 23248
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23212: LD_ADDR_VAR 0 5
23216: PUSH
23217: LD_VAR 0 5
23221: PPUSH
23222: LD_VAR 0 7
23226: PPUSH
23227: LD_VAR 0 6
23231: PUSH
23232: LD_VAR 0 8
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PPUSH
23241: CALL_OW 2
23245: ST_TO_ADDR
// break ;
23246: GO 23250
// end ; end ;
23248: GO 23187
23250: POP
23251: POP
// end ; end ;
23252: GO 23035
23254: POP
23255: POP
// if result and not asc then
23256: LD_VAR 0 5
23260: IFFALSE 23269
23262: PUSH
23263: LD_VAR 0 3
23267: NOT
23268: AND
23269: IFFALSE 23286
// result := ReverseArray ( result ) ;
23271: LD_ADDR_VAR 0 5
23275: PUSH
23276: LD_VAR 0 5
23280: PPUSH
23281: CALL 50644 0 1
23285: ST_TO_ADDR
// tmp := [ ] ;
23286: LD_ADDR_VAR 0 8
23290: PUSH
23291: EMPTY
23292: ST_TO_ADDR
// if mode then
23293: LD_VAR 0 4
23297: IFFALSE 23361
// begin for i := 1 to result do
23299: LD_ADDR_VAR 0 6
23303: PUSH
23304: DOUBLE
23305: LD_INT 1
23307: DEC
23308: ST_TO_ADDR
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_TO
23315: IFFALSE 23349
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23317: LD_ADDR_VAR 0 8
23321: PUSH
23322: LD_VAR 0 8
23326: PPUSH
23327: LD_VAR 0 5
23331: PUSH
23332: LD_VAR 0 6
23336: ARRAY
23337: PUSH
23338: LD_INT 1
23340: ARRAY
23341: PPUSH
23342: CALL 55554 0 2
23346: ST_TO_ADDR
23347: GO 23314
23349: POP
23350: POP
// result := tmp ;
23351: LD_ADDR_VAR 0 5
23355: PUSH
23356: LD_VAR 0 8
23360: ST_TO_ADDR
// end ; end ;
23361: LD_VAR 0 5
23365: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23366: LD_INT 0
23368: PPUSH
23369: PPUSH
23370: PPUSH
23371: PPUSH
// if not list then
23372: LD_VAR 0 3
23376: NOT
23377: IFFALSE 23381
// exit ;
23379: GO 23771
// result := [ ] ;
23381: LD_ADDR_VAR 0 6
23385: PUSH
23386: EMPTY
23387: ST_TO_ADDR
// for i in list do
23388: LD_ADDR_VAR 0 7
23392: PUSH
23393: LD_VAR 0 3
23397: PUSH
23398: FOR_IN
23399: IFFALSE 23601
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23401: LD_ADDR_VAR 0 9
23405: PUSH
23406: LD_VAR 0 7
23410: PPUSH
23411: LD_VAR 0 1
23415: PPUSH
23416: LD_VAR 0 2
23420: PPUSH
23421: CALL_OW 297
23425: ST_TO_ADDR
// if not result then
23426: LD_VAR 0 6
23430: NOT
23431: IFFALSE 23457
// result := [ [ i , tmp ] ] else
23433: LD_ADDR_VAR 0 6
23437: PUSH
23438: LD_VAR 0 7
23442: PUSH
23443: LD_VAR 0 9
23447: PUSH
23448: EMPTY
23449: LIST
23450: LIST
23451: PUSH
23452: EMPTY
23453: LIST
23454: ST_TO_ADDR
23455: GO 23599
// begin if result [ result ] [ 2 ] <= tmp then
23457: LD_VAR 0 6
23461: PUSH
23462: LD_VAR 0 6
23466: ARRAY
23467: PUSH
23468: LD_INT 2
23470: ARRAY
23471: PUSH
23472: LD_VAR 0 9
23476: LESSEQUAL
23477: IFFALSE 23519
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23479: LD_ADDR_VAR 0 6
23483: PUSH
23484: LD_VAR 0 6
23488: PPUSH
23489: LD_VAR 0 6
23493: PUSH
23494: LD_INT 1
23496: PLUS
23497: PPUSH
23498: LD_VAR 0 7
23502: PUSH
23503: LD_VAR 0 9
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PPUSH
23512: CALL_OW 2
23516: ST_TO_ADDR
23517: GO 23599
// for j := 1 to result do
23519: LD_ADDR_VAR 0 8
23523: PUSH
23524: DOUBLE
23525: LD_INT 1
23527: DEC
23528: ST_TO_ADDR
23529: LD_VAR 0 6
23533: PUSH
23534: FOR_TO
23535: IFFALSE 23597
// begin if tmp < result [ j ] [ 2 ] then
23537: LD_VAR 0 9
23541: PUSH
23542: LD_VAR 0 6
23546: PUSH
23547: LD_VAR 0 8
23551: ARRAY
23552: PUSH
23553: LD_INT 2
23555: ARRAY
23556: LESS
23557: IFFALSE 23595
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23559: LD_ADDR_VAR 0 6
23563: PUSH
23564: LD_VAR 0 6
23568: PPUSH
23569: LD_VAR 0 8
23573: PPUSH
23574: LD_VAR 0 7
23578: PUSH
23579: LD_VAR 0 9
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PPUSH
23588: CALL_OW 2
23592: ST_TO_ADDR
// break ;
23593: GO 23597
// end ; end ;
23595: GO 23534
23597: POP
23598: POP
// end ; end ;
23599: GO 23398
23601: POP
23602: POP
// if result and not asc then
23603: LD_VAR 0 6
23607: IFFALSE 23616
23609: PUSH
23610: LD_VAR 0 4
23614: NOT
23615: AND
23616: IFFALSE 23691
// begin tmp := result ;
23618: LD_ADDR_VAR 0 9
23622: PUSH
23623: LD_VAR 0 6
23627: ST_TO_ADDR
// for i = tmp downto 1 do
23628: LD_ADDR_VAR 0 7
23632: PUSH
23633: DOUBLE
23634: LD_VAR 0 9
23638: INC
23639: ST_TO_ADDR
23640: LD_INT 1
23642: PUSH
23643: FOR_DOWNTO
23644: IFFALSE 23689
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23646: LD_ADDR_VAR 0 6
23650: PUSH
23651: LD_VAR 0 6
23655: PPUSH
23656: LD_VAR 0 9
23660: PUSH
23661: LD_VAR 0 7
23665: MINUS
23666: PUSH
23667: LD_INT 1
23669: PLUS
23670: PPUSH
23671: LD_VAR 0 9
23675: PUSH
23676: LD_VAR 0 7
23680: ARRAY
23681: PPUSH
23682: CALL_OW 1
23686: ST_TO_ADDR
23687: GO 23643
23689: POP
23690: POP
// end ; tmp := [ ] ;
23691: LD_ADDR_VAR 0 9
23695: PUSH
23696: EMPTY
23697: ST_TO_ADDR
// if mode then
23698: LD_VAR 0 5
23702: IFFALSE 23771
// begin for i = 1 to result do
23704: LD_ADDR_VAR 0 7
23708: PUSH
23709: DOUBLE
23710: LD_INT 1
23712: DEC
23713: ST_TO_ADDR
23714: LD_VAR 0 6
23718: PUSH
23719: FOR_TO
23720: IFFALSE 23759
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23722: LD_ADDR_VAR 0 9
23726: PUSH
23727: LD_VAR 0 9
23731: PPUSH
23732: LD_VAR 0 7
23736: PPUSH
23737: LD_VAR 0 6
23741: PUSH
23742: LD_VAR 0 7
23746: ARRAY
23747: PUSH
23748: LD_INT 1
23750: ARRAY
23751: PPUSH
23752: CALL_OW 1
23756: ST_TO_ADDR
23757: GO 23719
23759: POP
23760: POP
// result := tmp ;
23761: LD_ADDR_VAR 0 6
23765: PUSH
23766: LD_VAR 0 9
23770: ST_TO_ADDR
// end ; end ;
23771: LD_VAR 0 6
23775: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23776: LD_INT 0
23778: PPUSH
23779: PPUSH
23780: PPUSH
23781: PPUSH
23782: PPUSH
23783: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23784: LD_ADDR_VAR 0 5
23788: PUSH
23789: LD_INT 0
23791: PUSH
23792: LD_INT 0
23794: PUSH
23795: LD_INT 0
23797: PUSH
23798: EMPTY
23799: PUSH
23800: EMPTY
23801: LIST
23802: LIST
23803: LIST
23804: LIST
23805: ST_TO_ADDR
// if not x or not y then
23806: LD_VAR 0 2
23810: NOT
23811: IFTRUE 23820
23813: PUSH
23814: LD_VAR 0 3
23818: NOT
23819: OR
23820: IFFALSE 23824
// exit ;
23822: GO 25480
// if not range then
23824: LD_VAR 0 4
23828: NOT
23829: IFFALSE 23839
// range := 10 ;
23831: LD_ADDR_VAR 0 4
23835: PUSH
23836: LD_INT 10
23838: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23839: LD_ADDR_VAR 0 8
23843: PUSH
23844: LD_INT 81
23846: PUSH
23847: LD_VAR 0 1
23851: PUSH
23852: EMPTY
23853: LIST
23854: LIST
23855: PUSH
23856: LD_INT 92
23858: PUSH
23859: LD_VAR 0 2
23863: PUSH
23864: LD_VAR 0 3
23868: PUSH
23869: LD_VAR 0 4
23873: PUSH
23874: EMPTY
23875: LIST
23876: LIST
23877: LIST
23878: LIST
23879: PUSH
23880: LD_INT 3
23882: PUSH
23883: LD_INT 21
23885: PUSH
23886: LD_INT 3
23888: PUSH
23889: EMPTY
23890: LIST
23891: LIST
23892: PUSH
23893: EMPTY
23894: LIST
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 69
23906: ST_TO_ADDR
// if not tmp then
23907: LD_VAR 0 8
23911: NOT
23912: IFFALSE 23916
// exit ;
23914: GO 25480
// for i in tmp do
23916: LD_ADDR_VAR 0 6
23920: PUSH
23921: LD_VAR 0 8
23925: PUSH
23926: FOR_IN
23927: IFFALSE 25455
// begin points := [ 0 , 0 , 0 ] ;
23929: LD_ADDR_VAR 0 9
23933: PUSH
23934: LD_INT 0
23936: PUSH
23937: LD_INT 0
23939: PUSH
23940: LD_INT 0
23942: PUSH
23943: EMPTY
23944: LIST
23945: LIST
23946: LIST
23947: ST_TO_ADDR
// bpoints := 1 ;
23948: LD_ADDR_VAR 0 10
23952: PUSH
23953: LD_INT 1
23955: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23956: LD_VAR 0 6
23960: PPUSH
23961: CALL_OW 247
23965: PUSH
23966: LD_INT 1
23968: DOUBLE
23969: EQUAL
23970: IFTRUE 23974
23972: GO 24556
23974: POP
// begin if GetClass ( i ) = 1 then
23975: LD_VAR 0 6
23979: PPUSH
23980: CALL_OW 257
23984: PUSH
23985: LD_INT 1
23987: EQUAL
23988: IFFALSE 24009
// points := [ 10 , 5 , 3 ] ;
23990: LD_ADDR_VAR 0 9
23994: PUSH
23995: LD_INT 10
23997: PUSH
23998: LD_INT 5
24000: PUSH
24001: LD_INT 3
24003: PUSH
24004: EMPTY
24005: LIST
24006: LIST
24007: LIST
24008: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
24009: LD_VAR 0 6
24013: PPUSH
24014: CALL_OW 257
24018: PUSH
24019: LD_INT 2
24021: PUSH
24022: LD_INT 3
24024: PUSH
24025: LD_INT 4
24027: PUSH
24028: EMPTY
24029: LIST
24030: LIST
24031: LIST
24032: IN
24033: IFFALSE 24054
// points := [ 3 , 2 , 1 ] ;
24035: LD_ADDR_VAR 0 9
24039: PUSH
24040: LD_INT 3
24042: PUSH
24043: LD_INT 2
24045: PUSH
24046: LD_INT 1
24048: PUSH
24049: EMPTY
24050: LIST
24051: LIST
24052: LIST
24053: ST_TO_ADDR
// if GetClass ( i ) = 5 then
24054: LD_VAR 0 6
24058: PPUSH
24059: CALL_OW 257
24063: PUSH
24064: LD_INT 5
24066: EQUAL
24067: IFFALSE 24088
// points := [ 130 , 5 , 2 ] ;
24069: LD_ADDR_VAR 0 9
24073: PUSH
24074: LD_INT 130
24076: PUSH
24077: LD_INT 5
24079: PUSH
24080: LD_INT 2
24082: PUSH
24083: EMPTY
24084: LIST
24085: LIST
24086: LIST
24087: ST_TO_ADDR
// if GetClass ( i ) = 8 then
24088: LD_VAR 0 6
24092: PPUSH
24093: CALL_OW 257
24097: PUSH
24098: LD_INT 8
24100: EQUAL
24101: IFFALSE 24122
// points := [ 35 , 35 , 30 ] ;
24103: LD_ADDR_VAR 0 9
24107: PUSH
24108: LD_INT 35
24110: PUSH
24111: LD_INT 35
24113: PUSH
24114: LD_INT 30
24116: PUSH
24117: EMPTY
24118: LIST
24119: LIST
24120: LIST
24121: ST_TO_ADDR
// if GetClass ( i ) = 9 then
24122: LD_VAR 0 6
24126: PPUSH
24127: CALL_OW 257
24131: PUSH
24132: LD_INT 9
24134: EQUAL
24135: IFFALSE 24156
// points := [ 20 , 55 , 40 ] ;
24137: LD_ADDR_VAR 0 9
24141: PUSH
24142: LD_INT 20
24144: PUSH
24145: LD_INT 55
24147: PUSH
24148: LD_INT 40
24150: PUSH
24151: EMPTY
24152: LIST
24153: LIST
24154: LIST
24155: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
24156: LD_VAR 0 6
24160: PPUSH
24161: CALL_OW 257
24165: PUSH
24166: LD_INT 12
24168: PUSH
24169: LD_INT 16
24171: PUSH
24172: EMPTY
24173: LIST
24174: LIST
24175: IN
24176: IFFALSE 24197
// points := [ 5 , 3 , 2 ] ;
24178: LD_ADDR_VAR 0 9
24182: PUSH
24183: LD_INT 5
24185: PUSH
24186: LD_INT 3
24188: PUSH
24189: LD_INT 2
24191: PUSH
24192: EMPTY
24193: LIST
24194: LIST
24195: LIST
24196: ST_TO_ADDR
// if GetClass ( i ) = 17 then
24197: LD_VAR 0 6
24201: PPUSH
24202: CALL_OW 257
24206: PUSH
24207: LD_INT 17
24209: EQUAL
24210: IFFALSE 24231
// points := [ 100 , 50 , 75 ] ;
24212: LD_ADDR_VAR 0 9
24216: PUSH
24217: LD_INT 100
24219: PUSH
24220: LD_INT 50
24222: PUSH
24223: LD_INT 75
24225: PUSH
24226: EMPTY
24227: LIST
24228: LIST
24229: LIST
24230: ST_TO_ADDR
// if GetClass ( i ) = 15 then
24231: LD_VAR 0 6
24235: PPUSH
24236: CALL_OW 257
24240: PUSH
24241: LD_INT 15
24243: EQUAL
24244: IFFALSE 24265
// points := [ 10 , 5 , 3 ] ;
24246: LD_ADDR_VAR 0 9
24250: PUSH
24251: LD_INT 10
24253: PUSH
24254: LD_INT 5
24256: PUSH
24257: LD_INT 3
24259: PUSH
24260: EMPTY
24261: LIST
24262: LIST
24263: LIST
24264: ST_TO_ADDR
// if GetClass ( i ) = 14 then
24265: LD_VAR 0 6
24269: PPUSH
24270: CALL_OW 257
24274: PUSH
24275: LD_INT 14
24277: EQUAL
24278: IFFALSE 24299
// points := [ 10 , 0 , 0 ] ;
24280: LD_ADDR_VAR 0 9
24284: PUSH
24285: LD_INT 10
24287: PUSH
24288: LD_INT 0
24290: PUSH
24291: LD_INT 0
24293: PUSH
24294: EMPTY
24295: LIST
24296: LIST
24297: LIST
24298: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24299: LD_VAR 0 6
24303: PPUSH
24304: CALL_OW 257
24308: PUSH
24309: LD_INT 11
24311: EQUAL
24312: IFFALSE 24333
// points := [ 30 , 10 , 5 ] ;
24314: LD_ADDR_VAR 0 9
24318: PUSH
24319: LD_INT 30
24321: PUSH
24322: LD_INT 10
24324: PUSH
24325: LD_INT 5
24327: PUSH
24328: EMPTY
24329: LIST
24330: LIST
24331: LIST
24332: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_INT 5
24340: PPUSH
24341: CALL_OW 321
24345: PUSH
24346: LD_INT 2
24348: EQUAL
24349: IFFALSE 24366
// bpoints := bpoints * 1.8 ;
24351: LD_ADDR_VAR 0 10
24355: PUSH
24356: LD_VAR 0 10
24360: PUSH
24361: LD_REAL  1.80000000000000E+0000
24364: MUL
24365: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24366: LD_VAR 0 6
24370: PPUSH
24371: CALL_OW 257
24375: PUSH
24376: LD_INT 1
24378: PUSH
24379: LD_INT 2
24381: PUSH
24382: LD_INT 3
24384: PUSH
24385: LD_INT 4
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: LIST
24392: LIST
24393: IN
24394: IFFALSE 24414
24396: PUSH
24397: LD_VAR 0 1
24401: PPUSH
24402: LD_INT 51
24404: PPUSH
24405: CALL_OW 321
24409: PUSH
24410: LD_INT 2
24412: EQUAL
24413: AND
24414: IFFALSE 24431
// bpoints := bpoints * 1.2 ;
24416: LD_ADDR_VAR 0 10
24420: PUSH
24421: LD_VAR 0 10
24425: PUSH
24426: LD_REAL  1.20000000000000E+0000
24429: MUL
24430: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24431: LD_VAR 0 6
24435: PPUSH
24436: CALL_OW 257
24440: PUSH
24441: LD_INT 5
24443: PUSH
24444: LD_INT 7
24446: PUSH
24447: LD_INT 9
24449: PUSH
24450: EMPTY
24451: LIST
24452: LIST
24453: LIST
24454: IN
24455: IFFALSE 24475
24457: PUSH
24458: LD_VAR 0 1
24462: PPUSH
24463: LD_INT 52
24465: PPUSH
24466: CALL_OW 321
24470: PUSH
24471: LD_INT 2
24473: EQUAL
24474: AND
24475: IFFALSE 24492
// bpoints := bpoints * 1.5 ;
24477: LD_ADDR_VAR 0 10
24481: PUSH
24482: LD_VAR 0 10
24486: PUSH
24487: LD_REAL  1.50000000000000E+0000
24490: MUL
24491: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24492: LD_VAR 0 1
24496: PPUSH
24497: LD_INT 66
24499: PPUSH
24500: CALL_OW 321
24504: PUSH
24505: LD_INT 2
24507: EQUAL
24508: IFFALSE 24525
// bpoints := bpoints * 1.1 ;
24510: LD_ADDR_VAR 0 10
24514: PUSH
24515: LD_VAR 0 10
24519: PUSH
24520: LD_REAL  1.10000000000000E+0000
24523: MUL
24524: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24525: LD_ADDR_VAR 0 10
24529: PUSH
24530: LD_VAR 0 10
24534: PUSH
24535: LD_VAR 0 6
24539: PPUSH
24540: LD_INT 1
24542: PPUSH
24543: CALL_OW 259
24547: PUSH
24548: LD_REAL  1.15000000000000E+0000
24551: MUL
24552: MUL
24553: ST_TO_ADDR
// end ; unit_vehicle :
24554: GO 25384
24556: LD_INT 2
24558: DOUBLE
24559: EQUAL
24560: IFTRUE 24564
24562: GO 25372
24564: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24565: LD_VAR 0 6
24569: PPUSH
24570: CALL_OW 264
24574: PUSH
24575: LD_INT 2
24577: PUSH
24578: LD_INT 42
24580: PUSH
24581: LD_INT 24
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: LIST
24588: IN
24589: IFFALSE 24610
// points := [ 25 , 5 , 3 ] ;
24591: LD_ADDR_VAR 0 9
24595: PUSH
24596: LD_INT 25
24598: PUSH
24599: LD_INT 5
24601: PUSH
24602: LD_INT 3
24604: PUSH
24605: EMPTY
24606: LIST
24607: LIST
24608: LIST
24609: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24610: LD_VAR 0 6
24614: PPUSH
24615: CALL_OW 264
24619: PUSH
24620: LD_INT 4
24622: PUSH
24623: LD_INT 43
24625: PUSH
24626: LD_INT 25
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: LIST
24633: IN
24634: IFFALSE 24655
// points := [ 40 , 15 , 5 ] ;
24636: LD_ADDR_VAR 0 9
24640: PUSH
24641: LD_INT 40
24643: PUSH
24644: LD_INT 15
24646: PUSH
24647: LD_INT 5
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: LIST
24654: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24655: LD_VAR 0 6
24659: PPUSH
24660: CALL_OW 264
24664: PUSH
24665: LD_INT 3
24667: PUSH
24668: LD_INT 23
24670: PUSH
24671: EMPTY
24672: LIST
24673: LIST
24674: IN
24675: IFFALSE 24696
// points := [ 7 , 25 , 8 ] ;
24677: LD_ADDR_VAR 0 9
24681: PUSH
24682: LD_INT 7
24684: PUSH
24685: LD_INT 25
24687: PUSH
24688: LD_INT 8
24690: PUSH
24691: EMPTY
24692: LIST
24693: LIST
24694: LIST
24695: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24696: LD_VAR 0 6
24700: PPUSH
24701: CALL_OW 264
24705: PUSH
24706: LD_INT 5
24708: PUSH
24709: LD_INT 27
24711: PUSH
24712: LD_INT 44
24714: PUSH
24715: EMPTY
24716: LIST
24717: LIST
24718: LIST
24719: IN
24720: IFFALSE 24741
// points := [ 14 , 50 , 16 ] ;
24722: LD_ADDR_VAR 0 9
24726: PUSH
24727: LD_INT 14
24729: PUSH
24730: LD_INT 50
24732: PUSH
24733: LD_INT 16
24735: PUSH
24736: EMPTY
24737: LIST
24738: LIST
24739: LIST
24740: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24741: LD_VAR 0 6
24745: PPUSH
24746: CALL_OW 264
24750: PUSH
24751: LD_INT 6
24753: PUSH
24754: LD_INT 46
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: IN
24761: IFFALSE 24782
// points := [ 32 , 120 , 70 ] ;
24763: LD_ADDR_VAR 0 9
24767: PUSH
24768: LD_INT 32
24770: PUSH
24771: LD_INT 120
24773: PUSH
24774: LD_INT 70
24776: PUSH
24777: EMPTY
24778: LIST
24779: LIST
24780: LIST
24781: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24782: LD_VAR 0 6
24786: PPUSH
24787: CALL_OW 264
24791: PUSH
24792: LD_INT 7
24794: PUSH
24795: LD_INT 28
24797: PUSH
24798: LD_INT 45
24800: PUSH
24801: LD_INT 92
24803: PUSH
24804: EMPTY
24805: LIST
24806: LIST
24807: LIST
24808: LIST
24809: IN
24810: IFFALSE 24831
// points := [ 35 , 20 , 45 ] ;
24812: LD_ADDR_VAR 0 9
24816: PUSH
24817: LD_INT 35
24819: PUSH
24820: LD_INT 20
24822: PUSH
24823: LD_INT 45
24825: PUSH
24826: EMPTY
24827: LIST
24828: LIST
24829: LIST
24830: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24831: LD_VAR 0 6
24835: PPUSH
24836: CALL_OW 264
24840: PUSH
24841: LD_INT 47
24843: PUSH
24844: EMPTY
24845: LIST
24846: IN
24847: IFFALSE 24868
// points := [ 67 , 45 , 75 ] ;
24849: LD_ADDR_VAR 0 9
24853: PUSH
24854: LD_INT 67
24856: PUSH
24857: LD_INT 45
24859: PUSH
24860: LD_INT 75
24862: PUSH
24863: EMPTY
24864: LIST
24865: LIST
24866: LIST
24867: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24868: LD_VAR 0 6
24872: PPUSH
24873: CALL_OW 264
24877: PUSH
24878: LD_INT 26
24880: PUSH
24881: EMPTY
24882: LIST
24883: IN
24884: IFFALSE 24905
// points := [ 120 , 30 , 80 ] ;
24886: LD_ADDR_VAR 0 9
24890: PUSH
24891: LD_INT 120
24893: PUSH
24894: LD_INT 30
24896: PUSH
24897: LD_INT 80
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24905: LD_VAR 0 6
24909: PPUSH
24910: CALL_OW 264
24914: PUSH
24915: LD_INT 22
24917: PUSH
24918: EMPTY
24919: LIST
24920: IN
24921: IFFALSE 24942
// points := [ 40 , 1 , 1 ] ;
24923: LD_ADDR_VAR 0 9
24927: PUSH
24928: LD_INT 40
24930: PUSH
24931: LD_INT 1
24933: PUSH
24934: LD_INT 1
24936: PUSH
24937: EMPTY
24938: LIST
24939: LIST
24940: LIST
24941: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24942: LD_VAR 0 6
24946: PPUSH
24947: CALL_OW 264
24951: PUSH
24952: LD_INT 29
24954: PUSH
24955: EMPTY
24956: LIST
24957: IN
24958: IFFALSE 24979
// points := [ 70 , 200 , 400 ] ;
24960: LD_ADDR_VAR 0 9
24964: PUSH
24965: LD_INT 70
24967: PUSH
24968: LD_INT 200
24970: PUSH
24971: LD_INT 400
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: LIST
24978: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24979: LD_VAR 0 6
24983: PPUSH
24984: CALL_OW 264
24988: PUSH
24989: LD_INT 14
24991: PUSH
24992: LD_INT 53
24994: PUSH
24995: EMPTY
24996: LIST
24997: LIST
24998: IN
24999: IFFALSE 25020
// points := [ 40 , 10 , 20 ] ;
25001: LD_ADDR_VAR 0 9
25005: PUSH
25006: LD_INT 40
25008: PUSH
25009: LD_INT 10
25011: PUSH
25012: LD_INT 20
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: LIST
25019: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
25020: LD_VAR 0 6
25024: PPUSH
25025: CALL_OW 264
25029: PUSH
25030: LD_INT 9
25032: PUSH
25033: EMPTY
25034: LIST
25035: IN
25036: IFFALSE 25057
// points := [ 5 , 70 , 20 ] ;
25038: LD_ADDR_VAR 0 9
25042: PUSH
25043: LD_INT 5
25045: PUSH
25046: LD_INT 70
25048: PUSH
25049: LD_INT 20
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: LIST
25056: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
25057: LD_VAR 0 6
25061: PPUSH
25062: CALL_OW 264
25066: PUSH
25067: LD_INT 10
25069: PUSH
25070: EMPTY
25071: LIST
25072: IN
25073: IFFALSE 25094
// points := [ 35 , 110 , 70 ] ;
25075: LD_ADDR_VAR 0 9
25079: PUSH
25080: LD_INT 35
25082: PUSH
25083: LD_INT 110
25085: PUSH
25086: LD_INT 70
25088: PUSH
25089: EMPTY
25090: LIST
25091: LIST
25092: LIST
25093: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
25094: LD_VAR 0 6
25098: PPUSH
25099: CALL_OW 265
25103: PUSH
25104: LD_INT 25
25106: EQUAL
25107: IFFALSE 25128
// points := [ 80 , 65 , 100 ] ;
25109: LD_ADDR_VAR 0 9
25113: PUSH
25114: LD_INT 80
25116: PUSH
25117: LD_INT 65
25119: PUSH
25120: LD_INT 100
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: LIST
25127: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
25128: LD_VAR 0 6
25132: PPUSH
25133: CALL_OW 263
25137: PUSH
25138: LD_INT 1
25140: EQUAL
25141: IFFALSE 25176
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
25143: LD_ADDR_VAR 0 10
25147: PUSH
25148: LD_VAR 0 10
25152: PUSH
25153: LD_VAR 0 6
25157: PPUSH
25158: CALL_OW 311
25162: PPUSH
25163: LD_INT 3
25165: PPUSH
25166: CALL_OW 259
25170: PUSH
25171: LD_INT 4
25173: MUL
25174: MUL
25175: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
25176: LD_VAR 0 6
25180: PPUSH
25181: CALL_OW 263
25185: PUSH
25186: LD_INT 2
25188: EQUAL
25189: IFFALSE 25240
// begin j := IsControledBy ( i ) ;
25191: LD_ADDR_VAR 0 7
25195: PUSH
25196: LD_VAR 0 6
25200: PPUSH
25201: CALL_OW 312
25205: ST_TO_ADDR
// if j then
25206: LD_VAR 0 7
25210: IFFALSE 25240
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
25212: LD_ADDR_VAR 0 10
25216: PUSH
25217: LD_VAR 0 10
25221: PUSH
25222: LD_VAR 0 7
25226: PPUSH
25227: LD_INT 3
25229: PPUSH
25230: CALL_OW 259
25234: PUSH
25235: LD_INT 3
25237: MUL
25238: MUL
25239: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
25240: LD_VAR 0 6
25244: PPUSH
25245: CALL_OW 264
25249: PUSH
25250: LD_INT 5
25252: PUSH
25253: LD_INT 6
25255: PUSH
25256: LD_INT 46
25258: PUSH
25259: LD_INT 44
25261: PUSH
25262: LD_INT 47
25264: PUSH
25265: LD_INT 45
25267: PUSH
25268: LD_INT 28
25270: PUSH
25271: LD_INT 7
25273: PUSH
25274: LD_INT 27
25276: PUSH
25277: LD_INT 29
25279: PUSH
25280: EMPTY
25281: LIST
25282: LIST
25283: LIST
25284: LIST
25285: LIST
25286: LIST
25287: LIST
25288: LIST
25289: LIST
25290: LIST
25291: IN
25292: IFFALSE 25312
25294: PUSH
25295: LD_VAR 0 1
25299: PPUSH
25300: LD_INT 52
25302: PPUSH
25303: CALL_OW 321
25307: PUSH
25308: LD_INT 2
25310: EQUAL
25311: AND
25312: IFFALSE 25329
// bpoints := bpoints * 1.2 ;
25314: LD_ADDR_VAR 0 10
25318: PUSH
25319: LD_VAR 0 10
25323: PUSH
25324: LD_REAL  1.20000000000000E+0000
25327: MUL
25328: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25329: LD_VAR 0 6
25333: PPUSH
25334: CALL_OW 264
25338: PUSH
25339: LD_INT 6
25341: PUSH
25342: LD_INT 46
25344: PUSH
25345: LD_INT 47
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: LIST
25352: IN
25353: IFFALSE 25370
// bpoints := bpoints * 1.2 ;
25355: LD_ADDR_VAR 0 10
25359: PUSH
25360: LD_VAR 0 10
25364: PUSH
25365: LD_REAL  1.20000000000000E+0000
25368: MUL
25369: ST_TO_ADDR
// end ; unit_building :
25370: GO 25384
25372: LD_INT 3
25374: DOUBLE
25375: EQUAL
25376: IFTRUE 25380
25378: GO 25383
25380: POP
// ; end ;
25381: GO 25384
25383: POP
// for j = 1 to 3 do
25384: LD_ADDR_VAR 0 7
25388: PUSH
25389: DOUBLE
25390: LD_INT 1
25392: DEC
25393: ST_TO_ADDR
25394: LD_INT 3
25396: PUSH
25397: FOR_TO
25398: IFFALSE 25451
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25400: LD_ADDR_VAR 0 5
25404: PUSH
25405: LD_VAR 0 5
25409: PPUSH
25410: LD_VAR 0 7
25414: PPUSH
25415: LD_VAR 0 5
25419: PUSH
25420: LD_VAR 0 7
25424: ARRAY
25425: PUSH
25426: LD_VAR 0 9
25430: PUSH
25431: LD_VAR 0 7
25435: ARRAY
25436: PUSH
25437: LD_VAR 0 10
25441: MUL
25442: PLUS
25443: PPUSH
25444: CALL_OW 1
25448: ST_TO_ADDR
25449: GO 25397
25451: POP
25452: POP
// end ;
25453: GO 23926
25455: POP
25456: POP
// result := Replace ( result , 4 , tmp ) ;
25457: LD_ADDR_VAR 0 5
25461: PUSH
25462: LD_VAR 0 5
25466: PPUSH
25467: LD_INT 4
25469: PPUSH
25470: LD_VAR 0 8
25474: PPUSH
25475: CALL_OW 1
25479: ST_TO_ADDR
// end ;
25480: LD_VAR 0 5
25484: RET
// export function DangerAtRange ( unit , range ) ; begin
25485: LD_INT 0
25487: PPUSH
// if not unit then
25488: LD_VAR 0 1
25492: NOT
25493: IFFALSE 25497
// exit ;
25495: GO 25542
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25497: LD_ADDR_VAR 0 3
25501: PUSH
25502: LD_VAR 0 1
25506: PPUSH
25507: CALL_OW 255
25511: PPUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 250
25521: PPUSH
25522: LD_VAR 0 1
25526: PPUSH
25527: CALL_OW 251
25531: PPUSH
25532: LD_VAR 0 2
25536: PPUSH
25537: CALL 23776 0 4
25541: ST_TO_ADDR
// end ;
25542: LD_VAR 0 3
25546: RET
// export function DangerInArea ( side , area ) ; begin
25547: LD_INT 0
25549: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25550: LD_ADDR_VAR 0 3
25554: PUSH
25555: LD_VAR 0 2
25559: PPUSH
25560: LD_INT 81
25562: PUSH
25563: LD_VAR 0 1
25567: PUSH
25568: EMPTY
25569: LIST
25570: LIST
25571: PPUSH
25572: CALL_OW 70
25576: ST_TO_ADDR
// end ;
25577: LD_VAR 0 3
25581: RET
// export function IsExtension ( b ) ; begin
25582: LD_INT 0
25584: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25585: LD_ADDR_VAR 0 2
25589: PUSH
25590: LD_VAR 0 1
25594: PUSH
25595: LD_INT 23
25597: PUSH
25598: LD_INT 20
25600: PUSH
25601: LD_INT 22
25603: PUSH
25604: LD_INT 17
25606: PUSH
25607: LD_INT 24
25609: PUSH
25610: LD_INT 21
25612: PUSH
25613: LD_INT 19
25615: PUSH
25616: LD_INT 16
25618: PUSH
25619: LD_INT 25
25621: PUSH
25622: LD_INT 18
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: LIST
25629: LIST
25630: LIST
25631: LIST
25632: LIST
25633: LIST
25634: LIST
25635: LIST
25636: IN
25637: ST_TO_ADDR
// end ;
25638: LD_VAR 0 2
25642: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25643: LD_INT 0
25645: PPUSH
25646: PPUSH
25647: PPUSH
// result := [ ] ;
25648: LD_ADDR_VAR 0 4
25652: PUSH
25653: EMPTY
25654: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25655: LD_ADDR_VAR 0 5
25659: PUSH
25660: LD_VAR 0 2
25664: PPUSH
25665: LD_INT 21
25667: PUSH
25668: LD_INT 3
25670: PUSH
25671: EMPTY
25672: LIST
25673: LIST
25674: PPUSH
25675: CALL_OW 70
25679: ST_TO_ADDR
// if not tmp then
25680: LD_VAR 0 5
25684: NOT
25685: IFFALSE 25689
// exit ;
25687: GO 25753
// if checkLink then
25689: LD_VAR 0 3
25693: IFFALSE 25743
// begin for i in tmp do
25695: LD_ADDR_VAR 0 6
25699: PUSH
25700: LD_VAR 0 5
25704: PUSH
25705: FOR_IN
25706: IFFALSE 25741
// if GetBase ( i ) <> base then
25708: LD_VAR 0 6
25712: PPUSH
25713: CALL_OW 274
25717: PUSH
25718: LD_VAR 0 1
25722: NONEQUAL
25723: IFFALSE 25739
// ComLinkToBase ( base , i ) ;
25725: LD_VAR 0 1
25729: PPUSH
25730: LD_VAR 0 6
25734: PPUSH
25735: CALL_OW 169
25739: GO 25705
25741: POP
25742: POP
// end ; result := tmp ;
25743: LD_ADDR_VAR 0 4
25747: PUSH
25748: LD_VAR 0 5
25752: ST_TO_ADDR
// end ;
25753: LD_VAR 0 4
25757: RET
// export function ComComplete ( units , b ) ; var i ; begin
25758: LD_INT 0
25760: PPUSH
25761: PPUSH
// if not units then
25762: LD_VAR 0 1
25766: NOT
25767: IFFALSE 25771
// exit ;
25769: GO 25861
// for i in units do
25771: LD_ADDR_VAR 0 4
25775: PUSH
25776: LD_VAR 0 1
25780: PUSH
25781: FOR_IN
25782: IFFALSE 25859
// if BuildingStatus ( b ) = bs_build then
25784: LD_VAR 0 2
25788: PPUSH
25789: CALL_OW 461
25793: PUSH
25794: LD_INT 1
25796: EQUAL
25797: IFFALSE 25857
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25799: LD_VAR 0 4
25803: PPUSH
25804: LD_STRING h
25806: PUSH
25807: LD_VAR 0 2
25811: PPUSH
25812: CALL_OW 250
25816: PUSH
25817: LD_VAR 0 2
25821: PPUSH
25822: CALL_OW 251
25826: PUSH
25827: LD_VAR 0 2
25831: PUSH
25832: LD_INT 0
25834: PUSH
25835: LD_INT 0
25837: PUSH
25838: LD_INT 0
25840: PUSH
25841: EMPTY
25842: LIST
25843: LIST
25844: LIST
25845: LIST
25846: LIST
25847: LIST
25848: LIST
25849: PUSH
25850: EMPTY
25851: LIST
25852: PPUSH
25853: CALL_OW 446
25857: GO 25781
25859: POP
25860: POP
// end ;
25861: LD_VAR 0 3
25865: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25866: LD_INT 0
25868: PPUSH
25869: PPUSH
25870: PPUSH
25871: PPUSH
25872: PPUSH
25873: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25874: LD_VAR 0 1
25878: NOT
25879: IFTRUE 25896
25881: PUSH
25882: LD_VAR 0 1
25886: PPUSH
25887: CALL_OW 263
25891: PUSH
25892: LD_INT 2
25894: NONEQUAL
25895: OR
25896: IFFALSE 25900
// exit ;
25898: GO 26216
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25900: LD_ADDR_VAR 0 6
25904: PUSH
25905: LD_INT 22
25907: PUSH
25908: LD_VAR 0 1
25912: PPUSH
25913: CALL_OW 255
25917: PUSH
25918: EMPTY
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 2
25924: PUSH
25925: LD_INT 30
25927: PUSH
25928: LD_INT 36
25930: PUSH
25931: EMPTY
25932: LIST
25933: LIST
25934: PUSH
25935: LD_INT 34
25937: PUSH
25938: LD_INT 31
25940: PUSH
25941: EMPTY
25942: LIST
25943: LIST
25944: PUSH
25945: EMPTY
25946: LIST
25947: LIST
25948: LIST
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: PPUSH
25954: CALL_OW 69
25958: ST_TO_ADDR
// if not tmp then
25959: LD_VAR 0 6
25963: NOT
25964: IFFALSE 25968
// exit ;
25966: GO 26216
// result := [ ] ;
25968: LD_ADDR_VAR 0 2
25972: PUSH
25973: EMPTY
25974: ST_TO_ADDR
// for i in tmp do
25975: LD_ADDR_VAR 0 3
25979: PUSH
25980: LD_VAR 0 6
25984: PUSH
25985: FOR_IN
25986: IFFALSE 26057
// begin t := UnitsInside ( i ) ;
25988: LD_ADDR_VAR 0 4
25992: PUSH
25993: LD_VAR 0 3
25997: PPUSH
25998: CALL_OW 313
26002: ST_TO_ADDR
// if t then
26003: LD_VAR 0 4
26007: IFFALSE 26055
// for j in t do
26009: LD_ADDR_VAR 0 7
26013: PUSH
26014: LD_VAR 0 4
26018: PUSH
26019: FOR_IN
26020: IFFALSE 26053
// result := Replace ( result , result + 1 , j ) ;
26022: LD_ADDR_VAR 0 2
26026: PUSH
26027: LD_VAR 0 2
26031: PPUSH
26032: LD_VAR 0 2
26036: PUSH
26037: LD_INT 1
26039: PLUS
26040: PPUSH
26041: LD_VAR 0 7
26045: PPUSH
26046: CALL_OW 1
26050: ST_TO_ADDR
26051: GO 26019
26053: POP
26054: POP
// end ;
26055: GO 25985
26057: POP
26058: POP
// if not result then
26059: LD_VAR 0 2
26063: NOT
26064: IFFALSE 26068
// exit ;
26066: GO 26216
// mech := result [ 1 ] ;
26068: LD_ADDR_VAR 0 5
26072: PUSH
26073: LD_VAR 0 2
26077: PUSH
26078: LD_INT 1
26080: ARRAY
26081: ST_TO_ADDR
// if result > 1 then
26082: LD_VAR 0 2
26086: PUSH
26087: LD_INT 1
26089: GREATER
26090: IFFALSE 26202
// begin for i = 2 to result do
26092: LD_ADDR_VAR 0 3
26096: PUSH
26097: DOUBLE
26098: LD_INT 2
26100: DEC
26101: ST_TO_ADDR
26102: LD_VAR 0 2
26106: PUSH
26107: FOR_TO
26108: IFFALSE 26200
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
26110: LD_ADDR_VAR 0 4
26114: PUSH
26115: LD_VAR 0 2
26119: PUSH
26120: LD_VAR 0 3
26124: ARRAY
26125: PPUSH
26126: LD_INT 3
26128: PPUSH
26129: CALL_OW 259
26133: PUSH
26134: LD_VAR 0 2
26138: PUSH
26139: LD_VAR 0 3
26143: ARRAY
26144: PPUSH
26145: CALL_OW 432
26149: MINUS
26150: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
26151: LD_VAR 0 4
26155: PUSH
26156: LD_VAR 0 5
26160: PPUSH
26161: LD_INT 3
26163: PPUSH
26164: CALL_OW 259
26168: PUSH
26169: LD_VAR 0 5
26173: PPUSH
26174: CALL_OW 432
26178: MINUS
26179: GREATEREQUAL
26180: IFFALSE 26198
// mech := result [ i ] ;
26182: LD_ADDR_VAR 0 5
26186: PUSH
26187: LD_VAR 0 2
26191: PUSH
26192: LD_VAR 0 3
26196: ARRAY
26197: ST_TO_ADDR
// end ;
26198: GO 26107
26200: POP
26201: POP
// end ; ComLinkTo ( vehicle , mech ) ;
26202: LD_VAR 0 1
26206: PPUSH
26207: LD_VAR 0 5
26211: PPUSH
26212: CALL_OW 135
// end ;
26216: LD_VAR 0 2
26220: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
26221: LD_INT 0
26223: PPUSH
26224: PPUSH
26225: PPUSH
26226: PPUSH
26227: PPUSH
26228: PPUSH
26229: PPUSH
26230: PPUSH
26231: PPUSH
26232: PPUSH
26233: PPUSH
26234: PPUSH
26235: PPUSH
// result := [ ] ;
26236: LD_ADDR_VAR 0 7
26240: PUSH
26241: EMPTY
26242: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
26243: LD_VAR 0 1
26247: PPUSH
26248: CALL_OW 266
26252: PUSH
26253: LD_INT 0
26255: PUSH
26256: LD_INT 1
26258: PUSH
26259: EMPTY
26260: LIST
26261: LIST
26262: IN
26263: NOT
26264: IFFALSE 26268
// exit ;
26266: GO 27908
// if name then
26268: LD_VAR 0 3
26272: IFFALSE 26288
// SetBName ( base_dep , name ) ;
26274: LD_VAR 0 1
26278: PPUSH
26279: LD_VAR 0 3
26283: PPUSH
26284: CALL_OW 500
// base := GetBase ( base_dep ) ;
26288: LD_ADDR_VAR 0 15
26292: PUSH
26293: LD_VAR 0 1
26297: PPUSH
26298: CALL_OW 274
26302: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26303: LD_ADDR_VAR 0 16
26307: PUSH
26308: LD_VAR 0 1
26312: PPUSH
26313: CALL_OW 255
26317: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26318: LD_ADDR_VAR 0 17
26322: PUSH
26323: LD_VAR 0 1
26327: PPUSH
26328: CALL_OW 248
26332: ST_TO_ADDR
// if sources then
26333: LD_VAR 0 5
26337: IFFALSE 26384
// for i = 1 to 3 do
26339: LD_ADDR_VAR 0 8
26343: PUSH
26344: DOUBLE
26345: LD_INT 1
26347: DEC
26348: ST_TO_ADDR
26349: LD_INT 3
26351: PUSH
26352: FOR_TO
26353: IFFALSE 26382
// AddResourceType ( base , i , sources [ i ] ) ;
26355: LD_VAR 0 15
26359: PPUSH
26360: LD_VAR 0 8
26364: PPUSH
26365: LD_VAR 0 5
26369: PUSH
26370: LD_VAR 0 8
26374: ARRAY
26375: PPUSH
26376: CALL_OW 276
26380: GO 26352
26382: POP
26383: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26384: LD_ADDR_VAR 0 18
26388: PUSH
26389: LD_VAR 0 15
26393: PPUSH
26394: LD_VAR 0 2
26398: PPUSH
26399: LD_INT 1
26401: PPUSH
26402: CALL 25643 0 3
26406: ST_TO_ADDR
// InitHc ;
26407: CALL_OW 19
// InitUc ;
26411: CALL_OW 18
// uc_side := side ;
26415: LD_ADDR_OWVAR 20
26419: PUSH
26420: LD_VAR 0 16
26424: ST_TO_ADDR
// uc_nation := nation ;
26425: LD_ADDR_OWVAR 21
26429: PUSH
26430: LD_VAR 0 17
26434: ST_TO_ADDR
// if buildings then
26435: LD_VAR 0 18
26439: IFFALSE 27767
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26441: LD_ADDR_VAR 0 19
26445: PUSH
26446: LD_VAR 0 18
26450: PPUSH
26451: LD_INT 2
26453: PUSH
26454: LD_INT 30
26456: PUSH
26457: LD_INT 29
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 30
26466: PUSH
26467: LD_INT 30
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: LIST
26478: PPUSH
26479: CALL_OW 72
26483: ST_TO_ADDR
// if tmp then
26484: LD_VAR 0 19
26488: IFFALSE 26536
// for i in tmp do
26490: LD_ADDR_VAR 0 8
26494: PUSH
26495: LD_VAR 0 19
26499: PUSH
26500: FOR_IN
26501: IFFALSE 26534
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26503: LD_VAR 0 8
26507: PPUSH
26508: CALL_OW 250
26512: PPUSH
26513: LD_VAR 0 8
26517: PPUSH
26518: CALL_OW 251
26522: PPUSH
26523: LD_VAR 0 16
26527: PPUSH
26528: CALL_OW 441
26532: GO 26500
26534: POP
26535: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26536: LD_VAR 0 18
26540: PPUSH
26541: LD_INT 2
26543: PUSH
26544: LD_INT 30
26546: PUSH
26547: LD_INT 32
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: PUSH
26554: LD_INT 30
26556: PUSH
26557: LD_INT 33
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: PUSH
26564: EMPTY
26565: LIST
26566: LIST
26567: LIST
26568: PPUSH
26569: CALL_OW 72
26573: IFFALSE 26661
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26575: LD_ADDR_VAR 0 8
26579: PUSH
26580: LD_VAR 0 18
26584: PPUSH
26585: LD_INT 2
26587: PUSH
26588: LD_INT 30
26590: PUSH
26591: LD_INT 32
26593: PUSH
26594: EMPTY
26595: LIST
26596: LIST
26597: PUSH
26598: LD_INT 30
26600: PUSH
26601: LD_INT 33
26603: PUSH
26604: EMPTY
26605: LIST
26606: LIST
26607: PUSH
26608: EMPTY
26609: LIST
26610: LIST
26611: LIST
26612: PPUSH
26613: CALL_OW 72
26617: PUSH
26618: FOR_IN
26619: IFFALSE 26659
// begin if not GetBWeapon ( i ) then
26621: LD_VAR 0 8
26625: PPUSH
26626: CALL_OW 269
26630: NOT
26631: IFFALSE 26657
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26633: LD_VAR 0 8
26637: PPUSH
26638: LD_VAR 0 8
26642: PPUSH
26643: LD_VAR 0 2
26647: PPUSH
26648: CALL 27913 0 2
26652: PPUSH
26653: CALL_OW 431
// end ;
26657: GO 26618
26659: POP
26660: POP
// end ; for i = 1 to personel do
26661: LD_ADDR_VAR 0 8
26665: PUSH
26666: DOUBLE
26667: LD_INT 1
26669: DEC
26670: ST_TO_ADDR
26671: LD_VAR 0 6
26675: PUSH
26676: FOR_TO
26677: IFFALSE 27747
// begin if i > 4 then
26679: LD_VAR 0 8
26683: PUSH
26684: LD_INT 4
26686: GREATER
26687: IFFALSE 26691
// break ;
26689: GO 27747
// case i of 1 :
26691: LD_VAR 0 8
26695: PUSH
26696: LD_INT 1
26698: DOUBLE
26699: EQUAL
26700: IFTRUE 26704
26702: GO 26784
26704: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26705: LD_ADDR_VAR 0 12
26709: PUSH
26710: LD_VAR 0 18
26714: PPUSH
26715: LD_INT 22
26717: PUSH
26718: LD_VAR 0 16
26722: PUSH
26723: EMPTY
26724: LIST
26725: LIST
26726: PUSH
26727: LD_INT 58
26729: PUSH
26730: EMPTY
26731: LIST
26732: PUSH
26733: LD_INT 2
26735: PUSH
26736: LD_INT 30
26738: PUSH
26739: LD_INT 32
26741: PUSH
26742: EMPTY
26743: LIST
26744: LIST
26745: PUSH
26746: LD_INT 30
26748: PUSH
26749: LD_INT 4
26751: PUSH
26752: EMPTY
26753: LIST
26754: LIST
26755: PUSH
26756: LD_INT 30
26758: PUSH
26759: LD_INT 5
26761: PUSH
26762: EMPTY
26763: LIST
26764: LIST
26765: PUSH
26766: EMPTY
26767: LIST
26768: LIST
26769: LIST
26770: LIST
26771: PUSH
26772: EMPTY
26773: LIST
26774: LIST
26775: LIST
26776: PPUSH
26777: CALL_OW 72
26781: ST_TO_ADDR
26782: GO 27006
26784: LD_INT 2
26786: DOUBLE
26787: EQUAL
26788: IFTRUE 26792
26790: GO 26854
26792: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26793: LD_ADDR_VAR 0 12
26797: PUSH
26798: LD_VAR 0 18
26802: PPUSH
26803: LD_INT 22
26805: PUSH
26806: LD_VAR 0 16
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: PUSH
26815: LD_INT 2
26817: PUSH
26818: LD_INT 30
26820: PUSH
26821: LD_INT 0
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: PUSH
26828: LD_INT 30
26830: PUSH
26831: LD_INT 1
26833: PUSH
26834: EMPTY
26835: LIST
26836: LIST
26837: PUSH
26838: EMPTY
26839: LIST
26840: LIST
26841: LIST
26842: PUSH
26843: EMPTY
26844: LIST
26845: LIST
26846: PPUSH
26847: CALL_OW 72
26851: ST_TO_ADDR
26852: GO 27006
26854: LD_INT 3
26856: DOUBLE
26857: EQUAL
26858: IFTRUE 26862
26860: GO 26924
26862: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26863: LD_ADDR_VAR 0 12
26867: PUSH
26868: LD_VAR 0 18
26872: PPUSH
26873: LD_INT 22
26875: PUSH
26876: LD_VAR 0 16
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 2
26887: PUSH
26888: LD_INT 30
26890: PUSH
26891: LD_INT 2
26893: PUSH
26894: EMPTY
26895: LIST
26896: LIST
26897: PUSH
26898: LD_INT 30
26900: PUSH
26901: LD_INT 3
26903: PUSH
26904: EMPTY
26905: LIST
26906: LIST
26907: PUSH
26908: EMPTY
26909: LIST
26910: LIST
26911: LIST
26912: PUSH
26913: EMPTY
26914: LIST
26915: LIST
26916: PPUSH
26917: CALL_OW 72
26921: ST_TO_ADDR
26922: GO 27006
26924: LD_INT 4
26926: DOUBLE
26927: EQUAL
26928: IFTRUE 26932
26930: GO 27005
26932: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26933: LD_ADDR_VAR 0 12
26937: PUSH
26938: LD_VAR 0 18
26942: PPUSH
26943: LD_INT 22
26945: PUSH
26946: LD_VAR 0 16
26950: PUSH
26951: EMPTY
26952: LIST
26953: LIST
26954: PUSH
26955: LD_INT 2
26957: PUSH
26958: LD_INT 30
26960: PUSH
26961: LD_INT 6
26963: PUSH
26964: EMPTY
26965: LIST
26966: LIST
26967: PUSH
26968: LD_INT 30
26970: PUSH
26971: LD_INT 7
26973: PUSH
26974: EMPTY
26975: LIST
26976: LIST
26977: PUSH
26978: LD_INT 30
26980: PUSH
26981: LD_INT 8
26983: PUSH
26984: EMPTY
26985: LIST
26986: LIST
26987: PUSH
26988: EMPTY
26989: LIST
26990: LIST
26991: LIST
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PPUSH
26998: CALL_OW 72
27002: ST_TO_ADDR
27003: GO 27006
27005: POP
// if i = 1 then
27006: LD_VAR 0 8
27010: PUSH
27011: LD_INT 1
27013: EQUAL
27014: IFFALSE 27125
// begin tmp := [ ] ;
27016: LD_ADDR_VAR 0 19
27020: PUSH
27021: EMPTY
27022: ST_TO_ADDR
// for j in f do
27023: LD_ADDR_VAR 0 9
27027: PUSH
27028: LD_VAR 0 12
27032: PUSH
27033: FOR_IN
27034: IFFALSE 27107
// if GetBType ( j ) = b_bunker then
27036: LD_VAR 0 9
27040: PPUSH
27041: CALL_OW 266
27045: PUSH
27046: LD_INT 32
27048: EQUAL
27049: IFFALSE 27076
// tmp := Insert ( tmp , 1 , j ) else
27051: LD_ADDR_VAR 0 19
27055: PUSH
27056: LD_VAR 0 19
27060: PPUSH
27061: LD_INT 1
27063: PPUSH
27064: LD_VAR 0 9
27068: PPUSH
27069: CALL_OW 2
27073: ST_TO_ADDR
27074: GO 27105
// tmp := Insert ( tmp , tmp + 1 , j ) ;
27076: LD_ADDR_VAR 0 19
27080: PUSH
27081: LD_VAR 0 19
27085: PPUSH
27086: LD_VAR 0 19
27090: PUSH
27091: LD_INT 1
27093: PLUS
27094: PPUSH
27095: LD_VAR 0 9
27099: PPUSH
27100: CALL_OW 2
27104: ST_TO_ADDR
27105: GO 27033
27107: POP
27108: POP
// if tmp then
27109: LD_VAR 0 19
27113: IFFALSE 27125
// f := tmp ;
27115: LD_ADDR_VAR 0 12
27119: PUSH
27120: LD_VAR 0 19
27124: ST_TO_ADDR
// end ; x := personel [ i ] ;
27125: LD_ADDR_VAR 0 13
27129: PUSH
27130: LD_VAR 0 6
27134: PUSH
27135: LD_VAR 0 8
27139: ARRAY
27140: ST_TO_ADDR
// if x = - 1 then
27141: LD_VAR 0 13
27145: PUSH
27146: LD_INT 1
27148: NEG
27149: EQUAL
27150: IFFALSE 27361
// begin for j in f do
27152: LD_ADDR_VAR 0 9
27156: PUSH
27157: LD_VAR 0 12
27161: PUSH
27162: FOR_IN
27163: IFFALSE 27357
// repeat InitHc ;
27165: CALL_OW 19
// if GetBType ( j ) = b_barracks then
27169: LD_VAR 0 9
27173: PPUSH
27174: CALL_OW 266
27178: PUSH
27179: LD_INT 5
27181: EQUAL
27182: IFFALSE 27252
// begin if UnitsInside ( j ) < 3 then
27184: LD_VAR 0 9
27188: PPUSH
27189: CALL_OW 313
27193: PUSH
27194: LD_INT 3
27196: LESS
27197: IFFALSE 27233
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27199: LD_INT 0
27201: PPUSH
27202: LD_INT 5
27204: PUSH
27205: LD_INT 8
27207: PUSH
27208: LD_INT 9
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: LIST
27215: PUSH
27216: LD_VAR 0 17
27220: ARRAY
27221: PPUSH
27222: LD_VAR 0 4
27226: PPUSH
27227: CALL_OW 380
27231: GO 27250
// PrepareHuman ( false , i , skill ) ;
27233: LD_INT 0
27235: PPUSH
27236: LD_VAR 0 8
27240: PPUSH
27241: LD_VAR 0 4
27245: PPUSH
27246: CALL_OW 380
// end else
27250: GO 27269
// PrepareHuman ( false , i , skill ) ;
27252: LD_INT 0
27254: PPUSH
27255: LD_VAR 0 8
27259: PPUSH
27260: LD_VAR 0 4
27264: PPUSH
27265: CALL_OW 380
// un := CreateHuman ;
27269: LD_ADDR_VAR 0 14
27273: PUSH
27274: CALL_OW 44
27278: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27279: LD_ADDR_VAR 0 7
27283: PUSH
27284: LD_VAR 0 7
27288: PPUSH
27289: LD_INT 1
27291: PPUSH
27292: LD_VAR 0 14
27296: PPUSH
27297: CALL_OW 2
27301: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27302: LD_VAR 0 14
27306: PPUSH
27307: LD_VAR 0 9
27311: PPUSH
27312: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27316: LD_VAR 0 9
27320: PPUSH
27321: CALL_OW 313
27325: PUSH
27326: LD_INT 6
27328: EQUAL
27329: IFTRUE 27353
27331: PUSH
27332: LD_VAR 0 9
27336: PPUSH
27337: CALL_OW 266
27341: PUSH
27342: LD_INT 32
27344: PUSH
27345: LD_INT 31
27347: PUSH
27348: EMPTY
27349: LIST
27350: LIST
27351: IN
27352: OR
27353: IFFALSE 27165
27355: GO 27162
27357: POP
27358: POP
// end else
27359: GO 27745
// for j = 1 to x do
27361: LD_ADDR_VAR 0 9
27365: PUSH
27366: DOUBLE
27367: LD_INT 1
27369: DEC
27370: ST_TO_ADDR
27371: LD_VAR 0 13
27375: PUSH
27376: FOR_TO
27377: IFFALSE 27743
// begin InitHc ;
27379: CALL_OW 19
// if not f then
27383: LD_VAR 0 12
27387: NOT
27388: IFFALSE 27477
// begin PrepareHuman ( false , i , skill ) ;
27390: LD_INT 0
27392: PPUSH
27393: LD_VAR 0 8
27397: PPUSH
27398: LD_VAR 0 4
27402: PPUSH
27403: CALL_OW 380
// un := CreateHuman ;
27407: LD_ADDR_VAR 0 14
27411: PUSH
27412: CALL_OW 44
27416: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27417: LD_ADDR_VAR 0 7
27421: PUSH
27422: LD_VAR 0 7
27426: PPUSH
27427: LD_INT 1
27429: PPUSH
27430: LD_VAR 0 14
27434: PPUSH
27435: CALL_OW 2
27439: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27440: LD_VAR 0 14
27444: PPUSH
27445: LD_VAR 0 1
27449: PPUSH
27450: CALL_OW 250
27454: PPUSH
27455: LD_VAR 0 1
27459: PPUSH
27460: CALL_OW 251
27464: PPUSH
27465: LD_INT 10
27467: PPUSH
27468: LD_INT 0
27470: PPUSH
27471: CALL_OW 50
// continue ;
27475: GO 27376
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27477: LD_VAR 0 12
27481: PUSH
27482: LD_INT 1
27484: ARRAY
27485: PPUSH
27486: CALL_OW 313
27490: IFFALSE 27518
27492: PUSH
27493: LD_VAR 0 12
27497: PUSH
27498: LD_INT 1
27500: ARRAY
27501: PPUSH
27502: CALL_OW 266
27506: PUSH
27507: LD_INT 32
27509: PUSH
27510: LD_INT 31
27512: PUSH
27513: EMPTY
27514: LIST
27515: LIST
27516: IN
27517: AND
27518: IFTRUE 27539
27520: PUSH
27521: LD_VAR 0 12
27525: PUSH
27526: LD_INT 1
27528: ARRAY
27529: PPUSH
27530: CALL_OW 313
27534: PUSH
27535: LD_INT 6
27537: EQUAL
27538: OR
27539: IFFALSE 27559
// f := Delete ( f , 1 ) ;
27541: LD_ADDR_VAR 0 12
27545: PUSH
27546: LD_VAR 0 12
27550: PPUSH
27551: LD_INT 1
27553: PPUSH
27554: CALL_OW 3
27558: ST_TO_ADDR
// if not f then
27559: LD_VAR 0 12
27563: NOT
27564: IFFALSE 27582
// begin x := x + 2 ;
27566: LD_ADDR_VAR 0 13
27570: PUSH
27571: LD_VAR 0 13
27575: PUSH
27576: LD_INT 2
27578: PLUS
27579: ST_TO_ADDR
// continue ;
27580: GO 27376
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27582: LD_VAR 0 12
27586: PUSH
27587: LD_INT 1
27589: ARRAY
27590: PPUSH
27591: CALL_OW 266
27595: PUSH
27596: LD_INT 5
27598: EQUAL
27599: IFFALSE 27673
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27601: LD_VAR 0 12
27605: PUSH
27606: LD_INT 1
27608: ARRAY
27609: PPUSH
27610: CALL_OW 313
27614: PUSH
27615: LD_INT 3
27617: LESS
27618: IFFALSE 27654
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27620: LD_INT 0
27622: PPUSH
27623: LD_INT 5
27625: PUSH
27626: LD_INT 8
27628: PUSH
27629: LD_INT 9
27631: PUSH
27632: EMPTY
27633: LIST
27634: LIST
27635: LIST
27636: PUSH
27637: LD_VAR 0 17
27641: ARRAY
27642: PPUSH
27643: LD_VAR 0 4
27647: PPUSH
27648: CALL_OW 380
27652: GO 27671
// PrepareHuman ( false , i , skill ) ;
27654: LD_INT 0
27656: PPUSH
27657: LD_VAR 0 8
27661: PPUSH
27662: LD_VAR 0 4
27666: PPUSH
27667: CALL_OW 380
// end else
27671: GO 27690
// PrepareHuman ( false , i , skill ) ;
27673: LD_INT 0
27675: PPUSH
27676: LD_VAR 0 8
27680: PPUSH
27681: LD_VAR 0 4
27685: PPUSH
27686: CALL_OW 380
// un := CreateHuman ;
27690: LD_ADDR_VAR 0 14
27694: PUSH
27695: CALL_OW 44
27699: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27700: LD_ADDR_VAR 0 7
27704: PUSH
27705: LD_VAR 0 7
27709: PPUSH
27710: LD_INT 1
27712: PPUSH
27713: LD_VAR 0 14
27717: PPUSH
27718: CALL_OW 2
27722: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27723: LD_VAR 0 14
27727: PPUSH
27728: LD_VAR 0 12
27732: PUSH
27733: LD_INT 1
27735: ARRAY
27736: PPUSH
27737: CALL_OW 52
// end ;
27741: GO 27376
27743: POP
27744: POP
// end ;
27745: GO 26676
27747: POP
27748: POP
// result := result ^ buildings ;
27749: LD_ADDR_VAR 0 7
27753: PUSH
27754: LD_VAR 0 7
27758: PUSH
27759: LD_VAR 0 18
27763: ADD
27764: ST_TO_ADDR
// end else
27765: GO 27908
// begin for i = 1 to personel do
27767: LD_ADDR_VAR 0 8
27771: PUSH
27772: DOUBLE
27773: LD_INT 1
27775: DEC
27776: ST_TO_ADDR
27777: LD_VAR 0 6
27781: PUSH
27782: FOR_TO
27783: IFFALSE 27906
// begin if i > 4 then
27785: LD_VAR 0 8
27789: PUSH
27790: LD_INT 4
27792: GREATER
27793: IFFALSE 27797
// break ;
27795: GO 27906
// x := personel [ i ] ;
27797: LD_ADDR_VAR 0 13
27801: PUSH
27802: LD_VAR 0 6
27806: PUSH
27807: LD_VAR 0 8
27811: ARRAY
27812: ST_TO_ADDR
// if x = - 1 then
27813: LD_VAR 0 13
27817: PUSH
27818: LD_INT 1
27820: NEG
27821: EQUAL
27822: IFFALSE 27826
// continue ;
27824: GO 27782
// PrepareHuman ( false , i , skill ) ;
27826: LD_INT 0
27828: PPUSH
27829: LD_VAR 0 8
27833: PPUSH
27834: LD_VAR 0 4
27838: PPUSH
27839: CALL_OW 380
// un := CreateHuman ;
27843: LD_ADDR_VAR 0 14
27847: PUSH
27848: CALL_OW 44
27852: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27853: LD_VAR 0 14
27857: PPUSH
27858: LD_VAR 0 1
27862: PPUSH
27863: CALL_OW 250
27867: PPUSH
27868: LD_VAR 0 1
27872: PPUSH
27873: CALL_OW 251
27877: PPUSH
27878: LD_INT 10
27880: PPUSH
27881: LD_INT 0
27883: PPUSH
27884: CALL_OW 50
// result := result ^ un ;
27888: LD_ADDR_VAR 0 7
27892: PUSH
27893: LD_VAR 0 7
27897: PUSH
27898: LD_VAR 0 14
27902: ADD
27903: ST_TO_ADDR
// end ;
27904: GO 27782
27906: POP
27907: POP
// end ; end ;
27908: LD_VAR 0 7
27912: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27913: LD_INT 0
27915: PPUSH
27916: PPUSH
27917: PPUSH
27918: PPUSH
27919: PPUSH
27920: PPUSH
27921: PPUSH
27922: PPUSH
27923: PPUSH
27924: PPUSH
27925: PPUSH
27926: PPUSH
27927: PPUSH
27928: PPUSH
27929: PPUSH
27930: PPUSH
// result := false ;
27931: LD_ADDR_VAR 0 3
27935: PUSH
27936: LD_INT 0
27938: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27939: LD_VAR 0 1
27943: NOT
27944: IFTRUE 27969
27946: PUSH
27947: LD_VAR 0 1
27951: PPUSH
27952: CALL_OW 266
27956: PUSH
27957: LD_INT 32
27959: PUSH
27960: LD_INT 33
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: IN
27967: NOT
27968: OR
27969: IFFALSE 27973
// exit ;
27971: GO 29108
// nat := GetNation ( tower ) ;
27973: LD_ADDR_VAR 0 12
27977: PUSH
27978: LD_VAR 0 1
27982: PPUSH
27983: CALL_OW 248
27987: ST_TO_ADDR
// side := GetSide ( tower ) ;
27988: LD_ADDR_VAR 0 16
27992: PUSH
27993: LD_VAR 0 1
27997: PPUSH
27998: CALL_OW 255
28002: ST_TO_ADDR
// x := GetX ( tower ) ;
28003: LD_ADDR_VAR 0 10
28007: PUSH
28008: LD_VAR 0 1
28012: PPUSH
28013: CALL_OW 250
28017: ST_TO_ADDR
// y := GetY ( tower ) ;
28018: LD_ADDR_VAR 0 11
28022: PUSH
28023: LD_VAR 0 1
28027: PPUSH
28028: CALL_OW 251
28032: ST_TO_ADDR
// if not x or not y then
28033: LD_VAR 0 10
28037: NOT
28038: IFTRUE 28047
28040: PUSH
28041: LD_VAR 0 11
28045: NOT
28046: OR
28047: IFFALSE 28051
// exit ;
28049: GO 29108
// weapon := 0 ;
28051: LD_ADDR_VAR 0 18
28055: PUSH
28056: LD_INT 0
28058: ST_TO_ADDR
// fac_list := [ ] ;
28059: LD_ADDR_VAR 0 17
28063: PUSH
28064: EMPTY
28065: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
28066: LD_ADDR_VAR 0 6
28070: PUSH
28071: LD_VAR 0 1
28075: PPUSH
28076: CALL_OW 274
28080: PPUSH
28081: LD_VAR 0 2
28085: PPUSH
28086: LD_INT 0
28088: PPUSH
28089: CALL 25643 0 3
28093: PPUSH
28094: LD_INT 30
28096: PUSH
28097: LD_INT 3
28099: PUSH
28100: EMPTY
28101: LIST
28102: LIST
28103: PPUSH
28104: CALL_OW 72
28108: ST_TO_ADDR
// if not factories then
28109: LD_VAR 0 6
28113: NOT
28114: IFFALSE 28118
// exit ;
28116: GO 29108
// for i in factories do
28118: LD_ADDR_VAR 0 8
28122: PUSH
28123: LD_VAR 0 6
28127: PUSH
28128: FOR_IN
28129: IFFALSE 28154
// fac_list := fac_list union AvailableWeaponList ( i ) ;
28131: LD_ADDR_VAR 0 17
28135: PUSH
28136: LD_VAR 0 17
28140: PUSH
28141: LD_VAR 0 8
28145: PPUSH
28146: CALL_OW 478
28150: UNION
28151: ST_TO_ADDR
28152: GO 28128
28154: POP
28155: POP
// if not fac_list then
28156: LD_VAR 0 17
28160: NOT
28161: IFFALSE 28165
// exit ;
28163: GO 29108
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
28165: LD_ADDR_VAR 0 5
28169: PUSH
28170: LD_INT 4
28172: PUSH
28173: LD_INT 5
28175: PUSH
28176: LD_INT 9
28178: PUSH
28179: LD_INT 10
28181: PUSH
28182: LD_INT 6
28184: PUSH
28185: LD_INT 7
28187: PUSH
28188: LD_INT 11
28190: PUSH
28191: EMPTY
28192: LIST
28193: LIST
28194: LIST
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: PUSH
28200: LD_INT 27
28202: PUSH
28203: LD_INT 28
28205: PUSH
28206: LD_INT 26
28208: PUSH
28209: LD_INT 30
28211: PUSH
28212: EMPTY
28213: LIST
28214: LIST
28215: LIST
28216: LIST
28217: PUSH
28218: LD_INT 43
28220: PUSH
28221: LD_INT 44
28223: PUSH
28224: LD_INT 46
28226: PUSH
28227: LD_INT 45
28229: PUSH
28230: LD_INT 47
28232: PUSH
28233: LD_INT 49
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: LIST
28240: LIST
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: LIST
28248: PUSH
28249: LD_VAR 0 12
28253: ARRAY
28254: ST_TO_ADDR
// list := list isect fac_list ;
28255: LD_ADDR_VAR 0 5
28259: PUSH
28260: LD_VAR 0 5
28264: PUSH
28265: LD_VAR 0 17
28269: ISECT
28270: ST_TO_ADDR
// if not list then
28271: LD_VAR 0 5
28275: NOT
28276: IFFALSE 28280
// exit ;
28278: GO 29108
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
28280: LD_VAR 0 12
28284: PUSH
28285: LD_INT 3
28287: EQUAL
28288: IFFALSE 28300
28290: PUSH
28291: LD_INT 49
28293: PUSH
28294: LD_VAR 0 5
28298: IN
28299: AND
28300: IFFALSE 28320
28302: PUSH
28303: LD_INT 31
28305: PPUSH
28306: LD_VAR 0 16
28310: PPUSH
28311: CALL_OW 321
28315: PUSH
28316: LD_INT 2
28318: EQUAL
28319: AND
28320: IFFALSE 28380
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28322: LD_INT 22
28324: PUSH
28325: LD_VAR 0 16
28329: PUSH
28330: EMPTY
28331: LIST
28332: LIST
28333: PUSH
28334: LD_INT 35
28336: PUSH
28337: LD_INT 49
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PUSH
28344: LD_INT 91
28346: PUSH
28347: LD_VAR 0 1
28351: PUSH
28352: LD_INT 10
28354: PUSH
28355: EMPTY
28356: LIST
28357: LIST
28358: LIST
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: LIST
28364: PPUSH
28365: CALL_OW 69
28369: NOT
28370: IFFALSE 28380
// weapon := ru_time_lapser ;
28372: LD_ADDR_VAR 0 18
28376: PUSH
28377: LD_INT 49
28379: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28380: LD_VAR 0 12
28384: PUSH
28385: LD_INT 1
28387: PUSH
28388: LD_INT 2
28390: PUSH
28391: EMPTY
28392: LIST
28393: LIST
28394: IN
28395: IFFALSE 28419
28397: PUSH
28398: LD_INT 11
28400: PUSH
28401: LD_VAR 0 5
28405: IN
28406: IFTRUE 28418
28408: PUSH
28409: LD_INT 30
28411: PUSH
28412: LD_VAR 0 5
28416: IN
28417: OR
28418: AND
28419: IFFALSE 28439
28421: PUSH
28422: LD_INT 6
28424: PPUSH
28425: LD_VAR 0 16
28429: PPUSH
28430: CALL_OW 321
28434: PUSH
28435: LD_INT 2
28437: EQUAL
28438: AND
28439: IFFALSE 28606
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28441: LD_INT 22
28443: PUSH
28444: LD_VAR 0 16
28448: PUSH
28449: EMPTY
28450: LIST
28451: LIST
28452: PUSH
28453: LD_INT 2
28455: PUSH
28456: LD_INT 35
28458: PUSH
28459: LD_INT 11
28461: PUSH
28462: EMPTY
28463: LIST
28464: LIST
28465: PUSH
28466: LD_INT 35
28468: PUSH
28469: LD_INT 30
28471: PUSH
28472: EMPTY
28473: LIST
28474: LIST
28475: PUSH
28476: EMPTY
28477: LIST
28478: LIST
28479: LIST
28480: PUSH
28481: LD_INT 91
28483: PUSH
28484: LD_VAR 0 1
28488: PUSH
28489: LD_INT 18
28491: PUSH
28492: EMPTY
28493: LIST
28494: LIST
28495: LIST
28496: PUSH
28497: EMPTY
28498: LIST
28499: LIST
28500: LIST
28501: PPUSH
28502: CALL_OW 69
28506: NOT
28507: IFFALSE 28583
28509: PUSH
28510: LD_INT 22
28512: PUSH
28513: LD_VAR 0 16
28517: PUSH
28518: EMPTY
28519: LIST
28520: LIST
28521: PUSH
28522: LD_INT 2
28524: PUSH
28525: LD_INT 30
28527: PUSH
28528: LD_INT 32
28530: PUSH
28531: EMPTY
28532: LIST
28533: LIST
28534: PUSH
28535: LD_INT 30
28537: PUSH
28538: LD_INT 33
28540: PUSH
28541: EMPTY
28542: LIST
28543: LIST
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 91
28552: PUSH
28553: LD_VAR 0 1
28557: PUSH
28558: LD_INT 12
28560: PUSH
28561: EMPTY
28562: LIST
28563: LIST
28564: LIST
28565: PUSH
28566: EMPTY
28567: LIST
28568: LIST
28569: LIST
28570: PUSH
28571: EMPTY
28572: LIST
28573: PPUSH
28574: CALL_OW 69
28578: PUSH
28579: LD_INT 2
28581: GREATER
28582: AND
28583: IFFALSE 28606
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28585: LD_ADDR_VAR 0 18
28589: PUSH
28590: LD_INT 11
28592: PUSH
28593: LD_INT 30
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: PUSH
28600: LD_VAR 0 12
28604: ARRAY
28605: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28606: LD_VAR 0 18
28610: NOT
28611: IFFALSE 28631
28613: PUSH
28614: LD_INT 40
28616: PPUSH
28617: LD_VAR 0 16
28621: PPUSH
28622: CALL_OW 321
28626: PUSH
28627: LD_INT 2
28629: EQUAL
28630: AND
28631: IFFALSE 28667
28633: PUSH
28634: LD_INT 7
28636: PUSH
28637: LD_VAR 0 5
28641: IN
28642: IFTRUE 28654
28644: PUSH
28645: LD_INT 28
28647: PUSH
28648: LD_VAR 0 5
28652: IN
28653: OR
28654: IFTRUE 28666
28656: PUSH
28657: LD_INT 45
28659: PUSH
28660: LD_VAR 0 5
28664: IN
28665: OR
28666: AND
28667: IFFALSE 28921
// begin hex := GetHexInfo ( x , y ) ;
28669: LD_ADDR_VAR 0 4
28673: PUSH
28674: LD_VAR 0 10
28678: PPUSH
28679: LD_VAR 0 11
28683: PPUSH
28684: CALL_OW 546
28688: ST_TO_ADDR
// if hex [ 1 ] then
28689: LD_VAR 0 4
28693: PUSH
28694: LD_INT 1
28696: ARRAY
28697: IFFALSE 28701
// exit ;
28699: GO 29108
// height := hex [ 2 ] ;
28701: LD_ADDR_VAR 0 15
28705: PUSH
28706: LD_VAR 0 4
28710: PUSH
28711: LD_INT 2
28713: ARRAY
28714: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28715: LD_ADDR_VAR 0 14
28719: PUSH
28720: LD_INT 0
28722: PUSH
28723: LD_INT 2
28725: PUSH
28726: LD_INT 3
28728: PUSH
28729: LD_INT 5
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: LIST
28736: LIST
28737: ST_TO_ADDR
// for i in tmp do
28738: LD_ADDR_VAR 0 8
28742: PUSH
28743: LD_VAR 0 14
28747: PUSH
28748: FOR_IN
28749: IFFALSE 28919
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28751: LD_ADDR_VAR 0 9
28755: PUSH
28756: LD_VAR 0 10
28760: PPUSH
28761: LD_VAR 0 8
28765: PPUSH
28766: LD_INT 5
28768: PPUSH
28769: CALL_OW 272
28773: PUSH
28774: LD_VAR 0 11
28778: PPUSH
28779: LD_VAR 0 8
28783: PPUSH
28784: LD_INT 5
28786: PPUSH
28787: CALL_OW 273
28791: PUSH
28792: EMPTY
28793: LIST
28794: LIST
28795: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28796: LD_VAR 0 9
28800: PUSH
28801: LD_INT 1
28803: ARRAY
28804: PPUSH
28805: LD_VAR 0 9
28809: PUSH
28810: LD_INT 2
28812: ARRAY
28813: PPUSH
28814: CALL_OW 488
28818: IFFALSE 28917
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28820: LD_ADDR_VAR 0 4
28824: PUSH
28825: LD_VAR 0 9
28829: PUSH
28830: LD_INT 1
28832: ARRAY
28833: PPUSH
28834: LD_VAR 0 9
28838: PUSH
28839: LD_INT 2
28841: ARRAY
28842: PPUSH
28843: CALL_OW 546
28847: ST_TO_ADDR
// if hex [ 1 ] then
28848: LD_VAR 0 4
28852: PUSH
28853: LD_INT 1
28855: ARRAY
28856: IFFALSE 28860
// continue ;
28858: GO 28748
// h := hex [ 2 ] ;
28860: LD_ADDR_VAR 0 13
28864: PUSH
28865: LD_VAR 0 4
28869: PUSH
28870: LD_INT 2
28872: ARRAY
28873: ST_TO_ADDR
// if h + 7 < height then
28874: LD_VAR 0 13
28878: PUSH
28879: LD_INT 7
28881: PLUS
28882: PUSH
28883: LD_VAR 0 15
28887: LESS
28888: IFFALSE 28917
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28890: LD_ADDR_VAR 0 18
28894: PUSH
28895: LD_INT 7
28897: PUSH
28898: LD_INT 28
28900: PUSH
28901: LD_INT 45
28903: PUSH
28904: EMPTY
28905: LIST
28906: LIST
28907: LIST
28908: PUSH
28909: LD_VAR 0 12
28913: ARRAY
28914: ST_TO_ADDR
// break ;
28915: GO 28919
// end ; end ; end ;
28917: GO 28748
28919: POP
28920: POP
// end ; if not weapon then
28921: LD_VAR 0 18
28925: NOT
28926: IFFALSE 28986
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28928: LD_ADDR_VAR 0 5
28932: PUSH
28933: LD_VAR 0 5
28937: PUSH
28938: LD_INT 11
28940: PUSH
28941: LD_INT 30
28943: PUSH
28944: LD_INT 49
28946: PUSH
28947: EMPTY
28948: LIST
28949: LIST
28950: LIST
28951: DIFF
28952: ST_TO_ADDR
// if not list then
28953: LD_VAR 0 5
28957: NOT
28958: IFFALSE 28962
// exit ;
28960: GO 29108
// weapon := list [ rand ( 1 , list ) ] ;
28962: LD_ADDR_VAR 0 18
28966: PUSH
28967: LD_VAR 0 5
28971: PUSH
28972: LD_INT 1
28974: PPUSH
28975: LD_VAR 0 5
28979: PPUSH
28980: CALL_OW 12
28984: ARRAY
28985: ST_TO_ADDR
// end ; if weapon then
28986: LD_VAR 0 18
28990: IFFALSE 29108
// begin tmp := CostOfWeapon ( weapon ) ;
28992: LD_ADDR_VAR 0 14
28996: PUSH
28997: LD_VAR 0 18
29001: PPUSH
29002: CALL_OW 451
29006: ST_TO_ADDR
// j := GetBase ( tower ) ;
29007: LD_ADDR_VAR 0 9
29011: PUSH
29012: LD_VAR 0 1
29016: PPUSH
29017: CALL_OW 274
29021: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
29022: LD_VAR 0 9
29026: PPUSH
29027: LD_INT 1
29029: PPUSH
29030: CALL_OW 275
29034: PUSH
29035: LD_VAR 0 14
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: GREATEREQUAL
29044: IFFALSE 29070
29046: PUSH
29047: LD_VAR 0 9
29051: PPUSH
29052: LD_INT 2
29054: PPUSH
29055: CALL_OW 275
29059: PUSH
29060: LD_VAR 0 14
29064: PUSH
29065: LD_INT 2
29067: ARRAY
29068: GREATEREQUAL
29069: AND
29070: IFFALSE 29096
29072: PUSH
29073: LD_VAR 0 9
29077: PPUSH
29078: LD_INT 3
29080: PPUSH
29081: CALL_OW 275
29085: PUSH
29086: LD_VAR 0 14
29090: PUSH
29091: LD_INT 3
29093: ARRAY
29094: GREATEREQUAL
29095: AND
29096: IFFALSE 29108
// result := weapon ;
29098: LD_ADDR_VAR 0 3
29102: PUSH
29103: LD_VAR 0 18
29107: ST_TO_ADDR
// end ; end ;
29108: LD_VAR 0 3
29112: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
29113: LD_INT 0
29115: PPUSH
29116: PPUSH
// result := true ;
29117: LD_ADDR_VAR 0 3
29121: PUSH
29122: LD_INT 1
29124: ST_TO_ADDR
// if array1 = array2 then
29125: LD_VAR 0 1
29129: PUSH
29130: LD_VAR 0 2
29134: EQUAL
29135: IFFALSE 29195
// begin for i = 1 to array1 do
29137: LD_ADDR_VAR 0 4
29141: PUSH
29142: DOUBLE
29143: LD_INT 1
29145: DEC
29146: ST_TO_ADDR
29147: LD_VAR 0 1
29151: PUSH
29152: FOR_TO
29153: IFFALSE 29191
// if array1 [ i ] <> array2 [ i ] then
29155: LD_VAR 0 1
29159: PUSH
29160: LD_VAR 0 4
29164: ARRAY
29165: PUSH
29166: LD_VAR 0 2
29170: PUSH
29171: LD_VAR 0 4
29175: ARRAY
29176: NONEQUAL
29177: IFFALSE 29189
// begin result := false ;
29179: LD_ADDR_VAR 0 3
29183: PUSH
29184: LD_INT 0
29186: ST_TO_ADDR
// break ;
29187: GO 29191
// end ;
29189: GO 29152
29191: POP
29192: POP
// end else
29193: GO 29203
// result := false ;
29195: LD_ADDR_VAR 0 3
29199: PUSH
29200: LD_INT 0
29202: ST_TO_ADDR
// end ;
29203: LD_VAR 0 3
29207: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
29208: LD_INT 0
29210: PPUSH
29211: PPUSH
// if not array1 or not array2 then
29212: LD_VAR 0 1
29216: NOT
29217: IFTRUE 29226
29219: PUSH
29220: LD_VAR 0 2
29224: NOT
29225: OR
29226: IFFALSE 29230
// exit ;
29228: GO 29294
// result := true ;
29230: LD_ADDR_VAR 0 3
29234: PUSH
29235: LD_INT 1
29237: ST_TO_ADDR
// for i = 1 to array1 do
29238: LD_ADDR_VAR 0 4
29242: PUSH
29243: DOUBLE
29244: LD_INT 1
29246: DEC
29247: ST_TO_ADDR
29248: LD_VAR 0 1
29252: PUSH
29253: FOR_TO
29254: IFFALSE 29292
// if array1 [ i ] <> array2 [ i ] then
29256: LD_VAR 0 1
29260: PUSH
29261: LD_VAR 0 4
29265: ARRAY
29266: PUSH
29267: LD_VAR 0 2
29271: PUSH
29272: LD_VAR 0 4
29276: ARRAY
29277: NONEQUAL
29278: IFFALSE 29290
// begin result := false ;
29280: LD_ADDR_VAR 0 3
29284: PUSH
29285: LD_INT 0
29287: ST_TO_ADDR
// break ;
29288: GO 29292
// end ;
29290: GO 29253
29292: POP
29293: POP
// end ;
29294: LD_VAR 0 3
29298: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
29299: LD_INT 0
29301: PPUSH
29302: PPUSH
29303: PPUSH
// pom := GetBase ( fac ) ;
29304: LD_ADDR_VAR 0 5
29308: PUSH
29309: LD_VAR 0 1
29313: PPUSH
29314: CALL_OW 274
29318: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
29319: LD_ADDR_VAR 0 4
29323: PUSH
29324: LD_VAR 0 2
29328: PUSH
29329: LD_INT 1
29331: ARRAY
29332: PPUSH
29333: LD_VAR 0 2
29337: PUSH
29338: LD_INT 2
29340: ARRAY
29341: PPUSH
29342: LD_VAR 0 2
29346: PUSH
29347: LD_INT 3
29349: ARRAY
29350: PPUSH
29351: LD_VAR 0 2
29355: PUSH
29356: LD_INT 4
29358: ARRAY
29359: PPUSH
29360: CALL_OW 449
29364: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29365: LD_ADDR_VAR 0 3
29369: PUSH
29370: LD_VAR 0 5
29374: PPUSH
29375: LD_INT 1
29377: PPUSH
29378: CALL_OW 275
29382: PUSH
29383: LD_VAR 0 4
29387: PUSH
29388: LD_INT 1
29390: ARRAY
29391: GREATEREQUAL
29392: IFFALSE 29418
29394: PUSH
29395: LD_VAR 0 5
29399: PPUSH
29400: LD_INT 2
29402: PPUSH
29403: CALL_OW 275
29407: PUSH
29408: LD_VAR 0 4
29412: PUSH
29413: LD_INT 2
29415: ARRAY
29416: GREATEREQUAL
29417: AND
29418: IFFALSE 29444
29420: PUSH
29421: LD_VAR 0 5
29425: PPUSH
29426: LD_INT 3
29428: PPUSH
29429: CALL_OW 275
29433: PUSH
29434: LD_VAR 0 4
29438: PUSH
29439: LD_INT 3
29441: ARRAY
29442: GREATEREQUAL
29443: AND
29444: ST_TO_ADDR
// end ;
29445: LD_VAR 0 3
29449: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29450: LD_INT 0
29452: PPUSH
29453: PPUSH
29454: PPUSH
29455: PPUSH
// pom := GetBase ( building ) ;
29456: LD_ADDR_VAR 0 3
29460: PUSH
29461: LD_VAR 0 1
29465: PPUSH
29466: CALL_OW 274
29470: ST_TO_ADDR
// if not pom then
29471: LD_VAR 0 3
29475: NOT
29476: IFFALSE 29480
// exit ;
29478: GO 29654
// btype := GetBType ( building ) ;
29480: LD_ADDR_VAR 0 5
29484: PUSH
29485: LD_VAR 0 1
29489: PPUSH
29490: CALL_OW 266
29494: ST_TO_ADDR
// if btype = b_armoury then
29495: LD_VAR 0 5
29499: PUSH
29500: LD_INT 4
29502: EQUAL
29503: IFFALSE 29513
// btype := b_barracks ;
29505: LD_ADDR_VAR 0 5
29509: PUSH
29510: LD_INT 5
29512: ST_TO_ADDR
// if btype = b_depot then
29513: LD_VAR 0 5
29517: PUSH
29518: LD_INT 0
29520: EQUAL
29521: IFFALSE 29531
// btype := b_warehouse ;
29523: LD_ADDR_VAR 0 5
29527: PUSH
29528: LD_INT 1
29530: ST_TO_ADDR
// if btype = b_workshop then
29531: LD_VAR 0 5
29535: PUSH
29536: LD_INT 2
29538: EQUAL
29539: IFFALSE 29549
// btype := b_factory ;
29541: LD_ADDR_VAR 0 5
29545: PUSH
29546: LD_INT 3
29548: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29549: LD_ADDR_VAR 0 4
29553: PUSH
29554: LD_VAR 0 5
29558: PPUSH
29559: LD_VAR 0 1
29563: PPUSH
29564: CALL_OW 248
29568: PPUSH
29569: CALL_OW 450
29573: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29574: LD_ADDR_VAR 0 2
29578: PUSH
29579: LD_VAR 0 3
29583: PPUSH
29584: LD_INT 1
29586: PPUSH
29587: CALL_OW 275
29591: PUSH
29592: LD_VAR 0 4
29596: PUSH
29597: LD_INT 1
29599: ARRAY
29600: GREATEREQUAL
29601: IFFALSE 29627
29603: PUSH
29604: LD_VAR 0 3
29608: PPUSH
29609: LD_INT 2
29611: PPUSH
29612: CALL_OW 275
29616: PUSH
29617: LD_VAR 0 4
29621: PUSH
29622: LD_INT 2
29624: ARRAY
29625: GREATEREQUAL
29626: AND
29627: IFFALSE 29653
29629: PUSH
29630: LD_VAR 0 3
29634: PPUSH
29635: LD_INT 3
29637: PPUSH
29638: CALL_OW 275
29642: PUSH
29643: LD_VAR 0 4
29647: PUSH
29648: LD_INT 3
29650: ARRAY
29651: GREATEREQUAL
29652: AND
29653: ST_TO_ADDR
// end ;
29654: LD_VAR 0 2
29658: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29659: LD_INT 0
29661: PPUSH
29662: PPUSH
29663: PPUSH
// pom := GetBase ( building ) ;
29664: LD_ADDR_VAR 0 4
29668: PUSH
29669: LD_VAR 0 1
29673: PPUSH
29674: CALL_OW 274
29678: ST_TO_ADDR
// if not pom then
29679: LD_VAR 0 4
29683: NOT
29684: IFFALSE 29688
// exit ;
29686: GO 29793
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29688: LD_ADDR_VAR 0 5
29692: PUSH
29693: LD_VAR 0 2
29697: PPUSH
29698: LD_VAR 0 1
29702: PPUSH
29703: CALL_OW 248
29707: PPUSH
29708: CALL_OW 450
29712: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29713: LD_ADDR_VAR 0 3
29717: PUSH
29718: LD_VAR 0 4
29722: PPUSH
29723: LD_INT 1
29725: PPUSH
29726: CALL_OW 275
29730: PUSH
29731: LD_VAR 0 5
29735: PUSH
29736: LD_INT 1
29738: ARRAY
29739: GREATEREQUAL
29740: IFFALSE 29766
29742: PUSH
29743: LD_VAR 0 4
29747: PPUSH
29748: LD_INT 2
29750: PPUSH
29751: CALL_OW 275
29755: PUSH
29756: LD_VAR 0 5
29760: PUSH
29761: LD_INT 2
29763: ARRAY
29764: GREATEREQUAL
29765: AND
29766: IFFALSE 29792
29768: PUSH
29769: LD_VAR 0 4
29773: PPUSH
29774: LD_INT 3
29776: PPUSH
29777: CALL_OW 275
29781: PUSH
29782: LD_VAR 0 5
29786: PUSH
29787: LD_INT 3
29789: ARRAY
29790: GREATEREQUAL
29791: AND
29792: ST_TO_ADDR
// end ;
29793: LD_VAR 0 3
29797: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29798: LD_INT 0
29800: PPUSH
29801: PPUSH
29802: PPUSH
29803: PPUSH
29804: PPUSH
29805: PPUSH
29806: PPUSH
29807: PPUSH
29808: PPUSH
29809: PPUSH
29810: PPUSH
// result := false ;
29811: LD_ADDR_VAR 0 8
29815: PUSH
29816: LD_INT 0
29818: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29819: LD_VAR 0 5
29823: NOT
29824: IFTRUE 29833
29826: PUSH
29827: LD_VAR 0 1
29831: NOT
29832: OR
29833: IFTRUE 29842
29835: PUSH
29836: LD_VAR 0 2
29840: NOT
29841: OR
29842: IFTRUE 29851
29844: PUSH
29845: LD_VAR 0 3
29849: NOT
29850: OR
29851: IFFALSE 29855
// exit ;
29853: GO 30681
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29855: LD_ADDR_VAR 0 14
29859: PUSH
29860: LD_VAR 0 1
29864: PPUSH
29865: LD_VAR 0 2
29869: PPUSH
29870: LD_VAR 0 3
29874: PPUSH
29875: LD_VAR 0 4
29879: PPUSH
29880: LD_VAR 0 5
29884: PUSH
29885: LD_INT 1
29887: ARRAY
29888: PPUSH
29889: CALL_OW 248
29893: PPUSH
29894: LD_INT 0
29896: PPUSH
29897: CALL 31962 0 6
29901: ST_TO_ADDR
// if not hexes then
29902: LD_VAR 0 14
29906: NOT
29907: IFFALSE 29911
// exit ;
29909: GO 30681
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29911: LD_ADDR_VAR 0 17
29915: PUSH
29916: LD_VAR 0 5
29920: PPUSH
29921: LD_INT 22
29923: PUSH
29924: LD_VAR 0 13
29928: PPUSH
29929: CALL_OW 255
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: PUSH
29938: LD_INT 2
29940: PUSH
29941: LD_INT 30
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 30
29953: PUSH
29954: LD_INT 1
29956: PUSH
29957: EMPTY
29958: LIST
29959: LIST
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: LIST
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PPUSH
29970: CALL_OW 72
29974: ST_TO_ADDR
// for i = 1 to hexes do
29975: LD_ADDR_VAR 0 9
29979: PUSH
29980: DOUBLE
29981: LD_INT 1
29983: DEC
29984: ST_TO_ADDR
29985: LD_VAR 0 14
29989: PUSH
29990: FOR_TO
29991: IFFALSE 30679
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29993: LD_ADDR_VAR 0 13
29997: PUSH
29998: LD_VAR 0 14
30002: PUSH
30003: LD_VAR 0 9
30007: ARRAY
30008: PUSH
30009: LD_INT 1
30011: ARRAY
30012: PPUSH
30013: LD_VAR 0 14
30017: PUSH
30018: LD_VAR 0 9
30022: ARRAY
30023: PUSH
30024: LD_INT 2
30026: ARRAY
30027: PPUSH
30028: CALL_OW 428
30032: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
30033: LD_VAR 0 14
30037: PUSH
30038: LD_VAR 0 9
30042: ARRAY
30043: PUSH
30044: LD_INT 1
30046: ARRAY
30047: PPUSH
30048: LD_VAR 0 14
30052: PUSH
30053: LD_VAR 0 9
30057: ARRAY
30058: PUSH
30059: LD_INT 2
30061: ARRAY
30062: PPUSH
30063: CALL_OW 351
30067: IFTRUE 30106
30069: PUSH
30070: LD_VAR 0 14
30074: PUSH
30075: LD_VAR 0 9
30079: ARRAY
30080: PUSH
30081: LD_INT 1
30083: ARRAY
30084: PPUSH
30085: LD_VAR 0 14
30089: PUSH
30090: LD_VAR 0 9
30094: ARRAY
30095: PUSH
30096: LD_INT 2
30098: ARRAY
30099: PPUSH
30100: CALL_OW 488
30104: NOT
30105: OR
30106: IFTRUE 30123
30108: PUSH
30109: LD_VAR 0 13
30113: PPUSH
30114: CALL_OW 247
30118: PUSH
30119: LD_INT 3
30121: EQUAL
30122: OR
30123: IFFALSE 30129
// exit ;
30125: POP
30126: POP
30127: GO 30681
// if not tmp then
30129: LD_VAR 0 13
30133: NOT
30134: IFFALSE 30138
// continue ;
30136: GO 29990
// result := true ;
30138: LD_ADDR_VAR 0 8
30142: PUSH
30143: LD_INT 1
30145: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
30146: LD_VAR 0 6
30150: IFFALSE 30167
30152: PUSH
30153: LD_VAR 0 13
30157: PPUSH
30158: CALL_OW 247
30162: PUSH
30163: LD_INT 2
30165: EQUAL
30166: AND
30167: IFFALSE 30184
30169: PUSH
30170: LD_VAR 0 13
30174: PPUSH
30175: CALL_OW 263
30179: PUSH
30180: LD_INT 1
30182: EQUAL
30183: AND
30184: IFFALSE 30348
// begin if IsDrivenBy ( tmp ) then
30186: LD_VAR 0 13
30190: PPUSH
30191: CALL_OW 311
30195: IFFALSE 30199
// continue ;
30197: GO 29990
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
30199: LD_VAR 0 6
30203: PPUSH
30204: LD_INT 3
30206: PUSH
30207: LD_INT 60
30209: PUSH
30210: EMPTY
30211: LIST
30212: PUSH
30213: EMPTY
30214: LIST
30215: LIST
30216: PUSH
30217: LD_INT 3
30219: PUSH
30220: LD_INT 55
30222: PUSH
30223: EMPTY
30224: LIST
30225: PUSH
30226: EMPTY
30227: LIST
30228: LIST
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PPUSH
30234: CALL_OW 72
30238: IFFALSE 30346
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
30240: LD_ADDR_VAR 0 18
30244: PUSH
30245: LD_VAR 0 6
30249: PPUSH
30250: LD_INT 3
30252: PUSH
30253: LD_INT 60
30255: PUSH
30256: EMPTY
30257: LIST
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 3
30265: PUSH
30266: LD_INT 55
30268: PUSH
30269: EMPTY
30270: LIST
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: EMPTY
30277: LIST
30278: LIST
30279: PPUSH
30280: CALL_OW 72
30284: PUSH
30285: LD_INT 1
30287: ARRAY
30288: ST_TO_ADDR
// if IsInUnit ( driver ) then
30289: LD_VAR 0 18
30293: PPUSH
30294: CALL_OW 310
30298: IFFALSE 30309
// ComExit ( driver ) ;
30300: LD_VAR 0 18
30304: PPUSH
30305: CALL 55952 0 1
// AddComEnterUnit ( driver , tmp ) ;
30309: LD_VAR 0 18
30313: PPUSH
30314: LD_VAR 0 13
30318: PPUSH
30319: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
30323: LD_VAR 0 18
30327: PPUSH
30328: LD_VAR 0 7
30332: PPUSH
30333: CALL_OW 173
// AddComExitVehicle ( driver ) ;
30337: LD_VAR 0 18
30341: PPUSH
30342: CALL_OW 181
// end ; continue ;
30346: GO 29990
// end ; if not cleaners or not tmp in cleaners then
30348: LD_VAR 0 6
30352: NOT
30353: IFTRUE 30368
30355: PUSH
30356: LD_VAR 0 13
30360: PUSH
30361: LD_VAR 0 6
30365: IN
30366: NOT
30367: OR
30368: IFFALSE 30677
// begin if dep then
30370: LD_VAR 0 17
30374: IFFALSE 30510
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30376: LD_ADDR_VAR 0 16
30380: PUSH
30381: LD_VAR 0 17
30385: PUSH
30386: LD_INT 1
30388: ARRAY
30389: PPUSH
30390: CALL_OW 250
30394: PPUSH
30395: LD_VAR 0 17
30399: PUSH
30400: LD_INT 1
30402: ARRAY
30403: PPUSH
30404: CALL_OW 254
30408: PPUSH
30409: LD_INT 5
30411: PPUSH
30412: CALL_OW 272
30416: PUSH
30417: LD_VAR 0 17
30421: PUSH
30422: LD_INT 1
30424: ARRAY
30425: PPUSH
30426: CALL_OW 251
30430: PPUSH
30431: LD_VAR 0 17
30435: PUSH
30436: LD_INT 1
30438: ARRAY
30439: PPUSH
30440: CALL_OW 254
30444: PPUSH
30445: LD_INT 5
30447: PPUSH
30448: CALL_OW 273
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30457: LD_VAR 0 16
30461: PUSH
30462: LD_INT 1
30464: ARRAY
30465: PPUSH
30466: LD_VAR 0 16
30470: PUSH
30471: LD_INT 2
30473: ARRAY
30474: PPUSH
30475: CALL_OW 488
30479: IFFALSE 30510
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30481: LD_VAR 0 13
30485: PPUSH
30486: LD_VAR 0 16
30490: PUSH
30491: LD_INT 1
30493: ARRAY
30494: PPUSH
30495: LD_VAR 0 16
30499: PUSH
30500: LD_INT 2
30502: ARRAY
30503: PPUSH
30504: CALL_OW 111
// continue ;
30508: GO 29990
// end ; end ; r := GetDir ( tmp ) ;
30510: LD_ADDR_VAR 0 15
30514: PUSH
30515: LD_VAR 0 13
30519: PPUSH
30520: CALL_OW 254
30524: ST_TO_ADDR
// if r = 5 then
30525: LD_VAR 0 15
30529: PUSH
30530: LD_INT 5
30532: EQUAL
30533: IFFALSE 30543
// r := 0 ;
30535: LD_ADDR_VAR 0 15
30539: PUSH
30540: LD_INT 0
30542: ST_TO_ADDR
// for j = r to 5 do
30543: LD_ADDR_VAR 0 10
30547: PUSH
30548: DOUBLE
30549: LD_VAR 0 15
30553: DEC
30554: ST_TO_ADDR
30555: LD_INT 5
30557: PUSH
30558: FOR_TO
30559: IFFALSE 30675
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30561: LD_ADDR_VAR 0 11
30565: PUSH
30566: LD_VAR 0 13
30570: PPUSH
30571: CALL_OW 250
30575: PPUSH
30576: LD_VAR 0 10
30580: PPUSH
30581: LD_INT 2
30583: PPUSH
30584: CALL_OW 272
30588: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30589: LD_ADDR_VAR 0 12
30593: PUSH
30594: LD_VAR 0 13
30598: PPUSH
30599: CALL_OW 251
30603: PPUSH
30604: LD_VAR 0 10
30608: PPUSH
30609: LD_INT 2
30611: PPUSH
30612: CALL_OW 273
30616: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30617: LD_VAR 0 11
30621: PPUSH
30622: LD_VAR 0 12
30626: PPUSH
30627: CALL_OW 488
30631: IFFALSE 30650
30633: PUSH
30634: LD_VAR 0 11
30638: PPUSH
30639: LD_VAR 0 12
30643: PPUSH
30644: CALL_OW 428
30648: NOT
30649: AND
30650: IFFALSE 30673
// begin ComMoveXY ( tmp , _x , _y ) ;
30652: LD_VAR 0 13
30656: PPUSH
30657: LD_VAR 0 11
30661: PPUSH
30662: LD_VAR 0 12
30666: PPUSH
30667: CALL_OW 111
// break ;
30671: GO 30675
// end ; end ;
30673: GO 30558
30675: POP
30676: POP
// end ; end ;
30677: GO 29990
30679: POP
30680: POP
// end ;
30681: LD_VAR 0 8
30685: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30686: LD_INT 0
30688: PPUSH
// result := true ;
30689: LD_ADDR_VAR 0 3
30693: PUSH
30694: LD_INT 1
30696: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30697: LD_VAR 0 2
30701: PUSH
30702: LD_INT 24
30704: DOUBLE
30705: EQUAL
30706: IFTRUE 30716
30708: LD_INT 33
30710: DOUBLE
30711: EQUAL
30712: IFTRUE 30716
30714: GO 30741
30716: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30717: LD_ADDR_VAR 0 3
30721: PUSH
30722: LD_INT 32
30724: PPUSH
30725: LD_VAR 0 1
30729: PPUSH
30730: CALL_OW 321
30734: PUSH
30735: LD_INT 2
30737: EQUAL
30738: ST_TO_ADDR
30739: GO 31057
30741: LD_INT 20
30743: DOUBLE
30744: EQUAL
30745: IFTRUE 30749
30747: GO 30774
30749: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30750: LD_ADDR_VAR 0 3
30754: PUSH
30755: LD_INT 6
30757: PPUSH
30758: LD_VAR 0 1
30762: PPUSH
30763: CALL_OW 321
30767: PUSH
30768: LD_INT 2
30770: EQUAL
30771: ST_TO_ADDR
30772: GO 31057
30774: LD_INT 22
30776: DOUBLE
30777: EQUAL
30778: IFTRUE 30788
30780: LD_INT 36
30782: DOUBLE
30783: EQUAL
30784: IFTRUE 30788
30786: GO 30813
30788: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30789: LD_ADDR_VAR 0 3
30793: PUSH
30794: LD_INT 15
30796: PPUSH
30797: LD_VAR 0 1
30801: PPUSH
30802: CALL_OW 321
30806: PUSH
30807: LD_INT 2
30809: EQUAL
30810: ST_TO_ADDR
30811: GO 31057
30813: LD_INT 30
30815: DOUBLE
30816: EQUAL
30817: IFTRUE 30821
30819: GO 30846
30821: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30822: LD_ADDR_VAR 0 3
30826: PUSH
30827: LD_INT 20
30829: PPUSH
30830: LD_VAR 0 1
30834: PPUSH
30835: CALL_OW 321
30839: PUSH
30840: LD_INT 2
30842: EQUAL
30843: ST_TO_ADDR
30844: GO 31057
30846: LD_INT 28
30848: DOUBLE
30849: EQUAL
30850: IFTRUE 30860
30852: LD_INT 21
30854: DOUBLE
30855: EQUAL
30856: IFTRUE 30860
30858: GO 30885
30860: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30861: LD_ADDR_VAR 0 3
30865: PUSH
30866: LD_INT 21
30868: PPUSH
30869: LD_VAR 0 1
30873: PPUSH
30874: CALL_OW 321
30878: PUSH
30879: LD_INT 2
30881: EQUAL
30882: ST_TO_ADDR
30883: GO 31057
30885: LD_INT 16
30887: DOUBLE
30888: EQUAL
30889: IFTRUE 30893
30891: GO 30918
30893: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30894: LD_ADDR_VAR 0 3
30898: PUSH
30899: LD_INT 84
30901: PPUSH
30902: LD_VAR 0 1
30906: PPUSH
30907: CALL_OW 321
30911: PUSH
30912: LD_INT 2
30914: EQUAL
30915: ST_TO_ADDR
30916: GO 31057
30918: LD_INT 19
30920: DOUBLE
30921: EQUAL
30922: IFTRUE 30932
30924: LD_INT 23
30926: DOUBLE
30927: EQUAL
30928: IFTRUE 30932
30930: GO 30957
30932: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30933: LD_ADDR_VAR 0 3
30937: PUSH
30938: LD_INT 83
30940: PPUSH
30941: LD_VAR 0 1
30945: PPUSH
30946: CALL_OW 321
30950: PUSH
30951: LD_INT 2
30953: EQUAL
30954: ST_TO_ADDR
30955: GO 31057
30957: LD_INT 17
30959: DOUBLE
30960: EQUAL
30961: IFTRUE 30965
30963: GO 30990
30965: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
30966: LD_ADDR_VAR 0 3
30970: PUSH
30971: LD_INT 39
30973: PPUSH
30974: LD_VAR 0 1
30978: PPUSH
30979: CALL_OW 321
30983: PUSH
30984: LD_INT 2
30986: EQUAL
30987: ST_TO_ADDR
30988: GO 31057
30990: LD_INT 18
30992: DOUBLE
30993: EQUAL
30994: IFTRUE 30998
30996: GO 31023
30998: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
30999: LD_ADDR_VAR 0 3
31003: PUSH
31004: LD_INT 40
31006: PPUSH
31007: LD_VAR 0 1
31011: PPUSH
31012: CALL_OW 321
31016: PUSH
31017: LD_INT 2
31019: EQUAL
31020: ST_TO_ADDR
31021: GO 31057
31023: LD_INT 27
31025: DOUBLE
31026: EQUAL
31027: IFTRUE 31031
31029: GO 31056
31031: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
31032: LD_ADDR_VAR 0 3
31036: PUSH
31037: LD_INT 35
31039: PPUSH
31040: LD_VAR 0 1
31044: PPUSH
31045: CALL_OW 321
31049: PUSH
31050: LD_INT 2
31052: EQUAL
31053: ST_TO_ADDR
31054: GO 31057
31056: POP
// end ;
31057: LD_VAR 0 3
31061: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
31062: LD_INT 0
31064: PPUSH
31065: PPUSH
31066: PPUSH
31067: PPUSH
31068: PPUSH
31069: PPUSH
31070: PPUSH
31071: PPUSH
31072: PPUSH
31073: PPUSH
31074: PPUSH
// result := false ;
31075: LD_ADDR_VAR 0 6
31079: PUSH
31080: LD_INT 0
31082: ST_TO_ADDR
// if btype = b_depot then
31083: LD_VAR 0 2
31087: PUSH
31088: LD_INT 0
31090: EQUAL
31091: IFFALSE 31103
// begin result := true ;
31093: LD_ADDR_VAR 0 6
31097: PUSH
31098: LD_INT 1
31100: ST_TO_ADDR
// exit ;
31101: GO 31957
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
31103: LD_VAR 0 1
31107: NOT
31108: IFTRUE 31133
31110: PUSH
31111: LD_VAR 0 1
31115: PPUSH
31116: CALL_OW 266
31120: PUSH
31121: LD_INT 0
31123: PUSH
31124: LD_INT 1
31126: PUSH
31127: EMPTY
31128: LIST
31129: LIST
31130: IN
31131: NOT
31132: OR
31133: IFTRUE 31142
31135: PUSH
31136: LD_VAR 0 2
31140: NOT
31141: OR
31142: IFTRUE 31178
31144: PUSH
31145: LD_VAR 0 5
31149: PUSH
31150: LD_INT 0
31152: PUSH
31153: LD_INT 1
31155: PUSH
31156: LD_INT 2
31158: PUSH
31159: LD_INT 3
31161: PUSH
31162: LD_INT 4
31164: PUSH
31165: LD_INT 5
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: IN
31176: NOT
31177: OR
31178: IFTRUE 31197
31180: PUSH
31181: LD_VAR 0 3
31185: PPUSH
31186: LD_VAR 0 4
31190: PPUSH
31191: CALL_OW 488
31195: NOT
31196: OR
31197: IFFALSE 31201
// exit ;
31199: GO 31957
// side := GetSide ( depot ) ;
31201: LD_ADDR_VAR 0 9
31205: PUSH
31206: LD_VAR 0 1
31210: PPUSH
31211: CALL_OW 255
31215: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
31216: LD_VAR 0 9
31220: PPUSH
31221: LD_VAR 0 2
31225: PPUSH
31226: CALL 30686 0 2
31230: NOT
31231: IFFALSE 31235
// exit ;
31233: GO 31957
// pom := GetBase ( depot ) ;
31235: LD_ADDR_VAR 0 10
31239: PUSH
31240: LD_VAR 0 1
31244: PPUSH
31245: CALL_OW 274
31249: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
31250: LD_ADDR_VAR 0 11
31254: PUSH
31255: LD_VAR 0 2
31259: PPUSH
31260: LD_VAR 0 1
31264: PPUSH
31265: CALL_OW 248
31269: PPUSH
31270: CALL_OW 450
31274: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31275: LD_VAR 0 10
31279: PPUSH
31280: LD_INT 1
31282: PPUSH
31283: CALL_OW 275
31287: PUSH
31288: LD_VAR 0 11
31292: PUSH
31293: LD_INT 1
31295: ARRAY
31296: GREATEREQUAL
31297: IFFALSE 31323
31299: PUSH
31300: LD_VAR 0 10
31304: PPUSH
31305: LD_INT 2
31307: PPUSH
31308: CALL_OW 275
31312: PUSH
31313: LD_VAR 0 11
31317: PUSH
31318: LD_INT 2
31320: ARRAY
31321: GREATEREQUAL
31322: AND
31323: IFFALSE 31349
31325: PUSH
31326: LD_VAR 0 10
31330: PPUSH
31331: LD_INT 3
31333: PPUSH
31334: CALL_OW 275
31338: PUSH
31339: LD_VAR 0 11
31343: PUSH
31344: LD_INT 3
31346: ARRAY
31347: GREATEREQUAL
31348: AND
31349: NOT
31350: IFFALSE 31354
// exit ;
31352: GO 31957
// if GetBType ( depot ) = b_depot then
31354: LD_VAR 0 1
31358: PPUSH
31359: CALL_OW 266
31363: PUSH
31364: LD_INT 0
31366: EQUAL
31367: IFFALSE 31379
// dist := 28 else
31369: LD_ADDR_VAR 0 14
31373: PUSH
31374: LD_INT 28
31376: ST_TO_ADDR
31377: GO 31387
// dist := 36 ;
31379: LD_ADDR_VAR 0 14
31383: PUSH
31384: LD_INT 36
31386: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31387: LD_VAR 0 1
31391: PPUSH
31392: LD_VAR 0 3
31396: PPUSH
31397: LD_VAR 0 4
31401: PPUSH
31402: CALL_OW 297
31406: PUSH
31407: LD_VAR 0 14
31411: GREATER
31412: IFFALSE 31416
// exit ;
31414: GO 31957
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31416: LD_ADDR_VAR 0 12
31420: PUSH
31421: LD_VAR 0 2
31425: PPUSH
31426: LD_VAR 0 3
31430: PPUSH
31431: LD_VAR 0 4
31435: PPUSH
31436: LD_VAR 0 5
31440: PPUSH
31441: LD_VAR 0 1
31445: PPUSH
31446: CALL_OW 248
31450: PPUSH
31451: LD_INT 0
31453: PPUSH
31454: CALL 31962 0 6
31458: ST_TO_ADDR
// if not hexes then
31459: LD_VAR 0 12
31463: NOT
31464: IFFALSE 31468
// exit ;
31466: GO 31957
// hex := GetHexInfo ( x , y ) ;
31468: LD_ADDR_VAR 0 15
31472: PUSH
31473: LD_VAR 0 3
31477: PPUSH
31478: LD_VAR 0 4
31482: PPUSH
31483: CALL_OW 546
31487: ST_TO_ADDR
// if hex [ 1 ] then
31488: LD_VAR 0 15
31492: PUSH
31493: LD_INT 1
31495: ARRAY
31496: IFFALSE 31500
// exit ;
31498: GO 31957
// height := hex [ 2 ] ;
31500: LD_ADDR_VAR 0 13
31504: PUSH
31505: LD_VAR 0 15
31509: PUSH
31510: LD_INT 2
31512: ARRAY
31513: ST_TO_ADDR
// for i = 1 to hexes do
31514: LD_ADDR_VAR 0 7
31518: PUSH
31519: DOUBLE
31520: LD_INT 1
31522: DEC
31523: ST_TO_ADDR
31524: LD_VAR 0 12
31528: PUSH
31529: FOR_TO
31530: IFFALSE 31874
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31532: LD_VAR 0 12
31536: PUSH
31537: LD_VAR 0 7
31541: ARRAY
31542: PUSH
31543: LD_INT 1
31545: ARRAY
31546: PPUSH
31547: LD_VAR 0 12
31551: PUSH
31552: LD_VAR 0 7
31556: ARRAY
31557: PUSH
31558: LD_INT 2
31560: ARRAY
31561: PPUSH
31562: CALL_OW 488
31566: NOT
31567: IFTRUE 31609
31569: PUSH
31570: LD_VAR 0 12
31574: PUSH
31575: LD_VAR 0 7
31579: ARRAY
31580: PUSH
31581: LD_INT 1
31583: ARRAY
31584: PPUSH
31585: LD_VAR 0 12
31589: PUSH
31590: LD_VAR 0 7
31594: ARRAY
31595: PUSH
31596: LD_INT 2
31598: ARRAY
31599: PPUSH
31600: CALL_OW 428
31604: PUSH
31605: LD_INT 0
31607: GREATER
31608: OR
31609: IFTRUE 31647
31611: PUSH
31612: LD_VAR 0 12
31616: PUSH
31617: LD_VAR 0 7
31621: ARRAY
31622: PUSH
31623: LD_INT 1
31625: ARRAY
31626: PPUSH
31627: LD_VAR 0 12
31631: PUSH
31632: LD_VAR 0 7
31636: ARRAY
31637: PUSH
31638: LD_INT 2
31640: ARRAY
31641: PPUSH
31642: CALL_OW 351
31646: OR
31647: IFFALSE 31653
// exit ;
31649: POP
31650: POP
31651: GO 31957
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31653: LD_ADDR_VAR 0 8
31657: PUSH
31658: LD_VAR 0 12
31662: PUSH
31663: LD_VAR 0 7
31667: ARRAY
31668: PUSH
31669: LD_INT 1
31671: ARRAY
31672: PPUSH
31673: LD_VAR 0 12
31677: PUSH
31678: LD_VAR 0 7
31682: ARRAY
31683: PUSH
31684: LD_INT 2
31686: ARRAY
31687: PPUSH
31688: CALL_OW 546
31692: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31693: LD_VAR 0 8
31697: PUSH
31698: LD_INT 1
31700: ARRAY
31701: IFTRUE 31723
31703: PUSH
31704: LD_VAR 0 8
31708: PUSH
31709: LD_INT 2
31711: ARRAY
31712: PUSH
31713: LD_VAR 0 13
31717: PUSH
31718: LD_INT 2
31720: PLUS
31721: GREATER
31722: OR
31723: IFTRUE 31745
31725: PUSH
31726: LD_VAR 0 8
31730: PUSH
31731: LD_INT 2
31733: ARRAY
31734: PUSH
31735: LD_VAR 0 13
31739: PUSH
31740: LD_INT 2
31742: MINUS
31743: LESS
31744: OR
31745: IFTRUE 31813
31747: PUSH
31748: LD_VAR 0 8
31752: PUSH
31753: LD_INT 3
31755: ARRAY
31756: PUSH
31757: LD_INT 0
31759: PUSH
31760: LD_INT 8
31762: PUSH
31763: LD_INT 9
31765: PUSH
31766: LD_INT 10
31768: PUSH
31769: LD_INT 11
31771: PUSH
31772: LD_INT 12
31774: PUSH
31775: LD_INT 13
31777: PUSH
31778: LD_INT 16
31780: PUSH
31781: LD_INT 17
31783: PUSH
31784: LD_INT 18
31786: PUSH
31787: LD_INT 19
31789: PUSH
31790: LD_INT 20
31792: PUSH
31793: LD_INT 21
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: LIST
31800: LIST
31801: LIST
31802: LIST
31803: LIST
31804: LIST
31805: LIST
31806: LIST
31807: LIST
31808: LIST
31809: LIST
31810: IN
31811: NOT
31812: OR
31813: IFTRUE 31826
31815: PUSH
31816: LD_VAR 0 8
31820: PUSH
31821: LD_INT 5
31823: ARRAY
31824: NOT
31825: OR
31826: IFTRUE 31866
31828: PUSH
31829: LD_VAR 0 8
31833: PUSH
31834: LD_INT 6
31836: ARRAY
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: LD_INT 2
31843: PUSH
31844: LD_INT 7
31846: PUSH
31847: LD_INT 9
31849: PUSH
31850: LD_INT 10
31852: PUSH
31853: LD_INT 11
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: IN
31864: NOT
31865: OR
31866: IFFALSE 31872
// exit ;
31868: POP
31869: POP
31870: GO 31957
// end ;
31872: GO 31529
31874: POP
31875: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31876: LD_VAR 0 9
31880: PPUSH
31881: LD_VAR 0 3
31885: PPUSH
31886: LD_VAR 0 4
31890: PPUSH
31891: LD_INT 20
31893: PPUSH
31894: CALL 23776 0 4
31898: PUSH
31899: LD_INT 4
31901: ARRAY
31902: IFFALSE 31906
// exit ;
31904: GO 31957
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31906: LD_VAR 0 2
31910: PUSH
31911: LD_INT 29
31913: PUSH
31914: LD_INT 30
31916: PUSH
31917: EMPTY
31918: LIST
31919: LIST
31920: IN
31921: IFFALSE 31945
31923: PUSH
31924: LD_VAR 0 3
31928: PPUSH
31929: LD_VAR 0 4
31933: PPUSH
31934: LD_VAR 0 9
31938: PPUSH
31939: CALL_OW 440
31943: NOT
31944: AND
31945: IFFALSE 31949
// exit ;
31947: GO 31957
// result := true ;
31949: LD_ADDR_VAR 0 6
31953: PUSH
31954: LD_INT 1
31956: ST_TO_ADDR
// end ;
31957: LD_VAR 0 6
31961: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31962: LD_INT 0
31964: PPUSH
31965: PPUSH
31966: PPUSH
31967: PPUSH
31968: PPUSH
31969: PPUSH
31970: PPUSH
31971: PPUSH
31972: PPUSH
31973: PPUSH
31974: PPUSH
31975: PPUSH
31976: PPUSH
31977: PPUSH
31978: PPUSH
31979: PPUSH
31980: PPUSH
31981: PPUSH
31982: PPUSH
31983: PPUSH
31984: PPUSH
31985: PPUSH
31986: PPUSH
31987: PPUSH
31988: PPUSH
31989: PPUSH
31990: PPUSH
31991: PPUSH
31992: PPUSH
31993: PPUSH
31994: PPUSH
31995: PPUSH
31996: PPUSH
31997: PPUSH
31998: PPUSH
31999: PPUSH
32000: PPUSH
32001: PPUSH
32002: PPUSH
32003: PPUSH
32004: PPUSH
32005: PPUSH
32006: PPUSH
32007: PPUSH
32008: PPUSH
32009: PPUSH
32010: PPUSH
32011: PPUSH
32012: PPUSH
32013: PPUSH
32014: PPUSH
32015: PPUSH
32016: PPUSH
32017: PPUSH
32018: PPUSH
32019: PPUSH
32020: PPUSH
32021: PPUSH
// result = [ ] ;
32022: LD_ADDR_VAR 0 7
32026: PUSH
32027: EMPTY
32028: ST_TO_ADDR
// temp_list = [ ] ;
32029: LD_ADDR_VAR 0 9
32033: PUSH
32034: EMPTY
32035: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
32036: LD_VAR 0 4
32040: PUSH
32041: LD_INT 0
32043: PUSH
32044: LD_INT 1
32046: PUSH
32047: LD_INT 2
32049: PUSH
32050: LD_INT 3
32052: PUSH
32053: LD_INT 4
32055: PUSH
32056: LD_INT 5
32058: PUSH
32059: EMPTY
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: IN
32067: NOT
32068: IFTRUE 32111
32070: PUSH
32071: LD_VAR 0 1
32075: PUSH
32076: LD_INT 0
32078: PUSH
32079: LD_INT 1
32081: PUSH
32082: EMPTY
32083: LIST
32084: LIST
32085: IN
32086: IFFALSE 32110
32088: PUSH
32089: LD_VAR 0 5
32093: PUSH
32094: LD_INT 1
32096: PUSH
32097: LD_INT 2
32099: PUSH
32100: LD_INT 3
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: LIST
32107: IN
32108: NOT
32109: AND
32110: OR
32111: IFFALSE 32115
// exit ;
32113: GO 50514
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
32115: LD_VAR 0 1
32119: PUSH
32120: LD_INT 6
32122: PUSH
32123: LD_INT 7
32125: PUSH
32126: LD_INT 8
32128: PUSH
32129: LD_INT 13
32131: PUSH
32132: LD_INT 12
32134: PUSH
32135: LD_INT 15
32137: PUSH
32138: LD_INT 11
32140: PUSH
32141: LD_INT 14
32143: PUSH
32144: LD_INT 10
32146: PUSH
32147: EMPTY
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: IN
32158: IFFALSE 32168
// btype = b_lab ;
32160: LD_ADDR_VAR 0 1
32164: PUSH
32165: LD_INT 6
32167: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
32168: LD_VAR 0 6
32172: PUSH
32173: LD_INT 0
32175: PUSH
32176: LD_INT 1
32178: PUSH
32179: LD_INT 2
32181: PUSH
32182: EMPTY
32183: LIST
32184: LIST
32185: LIST
32186: IN
32187: NOT
32188: IFTRUE 32256
32190: PUSH
32191: LD_VAR 0 1
32195: PUSH
32196: LD_INT 0
32198: PUSH
32199: LD_INT 1
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: LD_INT 3
32207: PUSH
32208: LD_INT 6
32210: PUSH
32211: LD_INT 36
32213: PUSH
32214: LD_INT 4
32216: PUSH
32217: LD_INT 5
32219: PUSH
32220: LD_INT 31
32222: PUSH
32223: LD_INT 32
32225: PUSH
32226: LD_INT 33
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: IN
32242: NOT
32243: IFFALSE 32255
32245: PUSH
32246: LD_VAR 0 6
32250: PUSH
32251: LD_INT 1
32253: EQUAL
32254: AND
32255: OR
32256: IFTRUE 32288
32258: PUSH
32259: LD_VAR 0 1
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 3
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: IN
32274: NOT
32275: IFFALSE 32287
32277: PUSH
32278: LD_VAR 0 6
32282: PUSH
32283: LD_INT 2
32285: EQUAL
32286: AND
32287: OR
32288: IFFALSE 32298
// mode = 0 ;
32290: LD_ADDR_VAR 0 6
32294: PUSH
32295: LD_INT 0
32297: ST_TO_ADDR
// case mode of 0 :
32298: LD_VAR 0 6
32302: PUSH
32303: LD_INT 0
32305: DOUBLE
32306: EQUAL
32307: IFTRUE 32311
32309: GO 43764
32311: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32312: LD_ADDR_VAR 0 11
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: LD_INT 0
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 0
32329: PUSH
32330: LD_INT 1
32332: NEG
32333: PUSH
32334: EMPTY
32335: LIST
32336: LIST
32337: PUSH
32338: LD_INT 1
32340: PUSH
32341: LD_INT 0
32343: PUSH
32344: EMPTY
32345: LIST
32346: LIST
32347: PUSH
32348: LD_INT 1
32350: PUSH
32351: LD_INT 1
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 0
32360: PUSH
32361: LD_INT 1
32363: PUSH
32364: EMPTY
32365: LIST
32366: LIST
32367: PUSH
32368: LD_INT 1
32370: NEG
32371: PUSH
32372: LD_INT 0
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 1
32381: NEG
32382: PUSH
32383: LD_INT 1
32385: NEG
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: LD_INT 2
32397: NEG
32398: PUSH
32399: EMPTY
32400: LIST
32401: LIST
32402: PUSH
32403: LD_INT 0
32405: PUSH
32406: LD_INT 2
32408: NEG
32409: PUSH
32410: EMPTY
32411: LIST
32412: LIST
32413: PUSH
32414: LD_INT 1
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 1
32427: PUSH
32428: LD_INT 2
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: LD_INT 0
32437: PUSH
32438: LD_INT 2
32440: PUSH
32441: EMPTY
32442: LIST
32443: LIST
32444: PUSH
32445: LD_INT 1
32447: NEG
32448: PUSH
32449: LD_INT 1
32451: PUSH
32452: EMPTY
32453: LIST
32454: LIST
32455: PUSH
32456: LD_INT 1
32458: PUSH
32459: LD_INT 3
32461: PUSH
32462: EMPTY
32463: LIST
32464: LIST
32465: PUSH
32466: LD_INT 0
32468: PUSH
32469: LD_INT 3
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 1
32478: NEG
32479: PUSH
32480: LD_INT 2
32482: PUSH
32483: EMPTY
32484: LIST
32485: LIST
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: LIST
32491: LIST
32492: LIST
32493: LIST
32494: LIST
32495: LIST
32496: LIST
32497: LIST
32498: LIST
32499: LIST
32500: LIST
32501: LIST
32502: LIST
32503: LIST
32504: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32505: LD_ADDR_VAR 0 12
32509: PUSH
32510: LD_INT 0
32512: PUSH
32513: LD_INT 0
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 1
32525: NEG
32526: PUSH
32527: EMPTY
32528: LIST
32529: LIST
32530: PUSH
32531: LD_INT 1
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 1
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: EMPTY
32548: LIST
32549: LIST
32550: PUSH
32551: LD_INT 0
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 1
32563: NEG
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: EMPTY
32569: LIST
32570: LIST
32571: PUSH
32572: LD_INT 1
32574: NEG
32575: PUSH
32576: LD_INT 1
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: LD_INT 1
32589: NEG
32590: PUSH
32591: EMPTY
32592: LIST
32593: LIST
32594: PUSH
32595: LD_INT 2
32597: PUSH
32598: LD_INT 0
32600: PUSH
32601: EMPTY
32602: LIST
32603: LIST
32604: PUSH
32605: LD_INT 2
32607: PUSH
32608: LD_INT 1
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: NEG
32618: PUSH
32619: LD_INT 1
32621: PUSH
32622: EMPTY
32623: LIST
32624: LIST
32625: PUSH
32626: LD_INT 2
32628: NEG
32629: PUSH
32630: LD_INT 0
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 2
32639: NEG
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 2
32651: NEG
32652: PUSH
32653: LD_INT 1
32655: PUSH
32656: EMPTY
32657: LIST
32658: LIST
32659: PUSH
32660: LD_INT 3
32662: NEG
32663: PUSH
32664: LD_INT 0
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 3
32673: NEG
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: EMPTY
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: LIST
32692: LIST
32693: LIST
32694: LIST
32695: LIST
32696: LIST
32697: LIST
32698: LIST
32699: LIST
32700: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32701: LD_ADDR_VAR 0 13
32705: PUSH
32706: LD_INT 0
32708: PUSH
32709: LD_INT 0
32711: PUSH
32712: EMPTY
32713: LIST
32714: LIST
32715: PUSH
32716: LD_INT 0
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: PUSH
32730: LD_INT 0
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 1
32739: PUSH
32740: LD_INT 1
32742: PUSH
32743: EMPTY
32744: LIST
32745: LIST
32746: PUSH
32747: LD_INT 0
32749: PUSH
32750: LD_INT 1
32752: PUSH
32753: EMPTY
32754: LIST
32755: LIST
32756: PUSH
32757: LD_INT 1
32759: NEG
32760: PUSH
32761: LD_INT 0
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: PUSH
32780: LD_INT 1
32782: NEG
32783: PUSH
32784: LD_INT 2
32786: NEG
32787: PUSH
32788: EMPTY
32789: LIST
32790: LIST
32791: PUSH
32792: LD_INT 2
32794: PUSH
32795: LD_INT 1
32797: PUSH
32798: EMPTY
32799: LIST
32800: LIST
32801: PUSH
32802: LD_INT 2
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: PUSH
32815: LD_INT 2
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: NEG
32825: PUSH
32826: LD_INT 1
32828: NEG
32829: PUSH
32830: EMPTY
32831: LIST
32832: LIST
32833: PUSH
32834: LD_INT 2
32836: NEG
32837: PUSH
32838: LD_INT 2
32840: NEG
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 2
32848: NEG
32849: PUSH
32850: LD_INT 3
32852: NEG
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 3
32860: NEG
32861: PUSH
32862: LD_INT 2
32864: NEG
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: LD_INT 3
32872: NEG
32873: PUSH
32874: LD_INT 3
32876: NEG
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32900: LD_ADDR_VAR 0 14
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: LD_INT 0
32910: PUSH
32911: EMPTY
32912: LIST
32913: LIST
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: LD_INT 1
32920: NEG
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: PUSH
32926: LD_INT 1
32928: PUSH
32929: LD_INT 0
32931: PUSH
32932: EMPTY
32933: LIST
32934: LIST
32935: PUSH
32936: LD_INT 1
32938: PUSH
32939: LD_INT 1
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 0
32948: PUSH
32949: LD_INT 1
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 1
32958: NEG
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: LD_INT 1
32973: NEG
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: PUSH
32979: LD_INT 1
32981: NEG
32982: PUSH
32983: LD_INT 2
32985: NEG
32986: PUSH
32987: EMPTY
32988: LIST
32989: LIST
32990: PUSH
32991: LD_INT 0
32993: PUSH
32994: LD_INT 2
32996: NEG
32997: PUSH
32998: EMPTY
32999: LIST
33000: LIST
33001: PUSH
33002: LD_INT 1
33004: PUSH
33005: LD_INT 1
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 1
33015: PUSH
33016: LD_INT 2
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 0
33025: PUSH
33026: LD_INT 2
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: NEG
33036: PUSH
33037: LD_INT 1
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 1
33046: NEG
33047: PUSH
33048: LD_INT 3
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 0
33058: PUSH
33059: LD_INT 3
33061: NEG
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: PUSH
33070: LD_INT 2
33072: NEG
33073: PUSH
33074: EMPTY
33075: LIST
33076: LIST
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: LIST
33082: LIST
33083: LIST
33084: LIST
33085: LIST
33086: LIST
33087: LIST
33088: LIST
33089: LIST
33090: LIST
33091: LIST
33092: LIST
33093: LIST
33094: LIST
33095: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
33096: LD_ADDR_VAR 0 15
33100: PUSH
33101: LD_INT 0
33103: PUSH
33104: LD_INT 0
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 0
33113: PUSH
33114: LD_INT 1
33116: NEG
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 1
33124: PUSH
33125: LD_INT 0
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 0
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: NEG
33155: PUSH
33156: LD_INT 0
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 1
33165: NEG
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: LD_INT 1
33180: NEG
33181: PUSH
33182: EMPTY
33183: LIST
33184: LIST
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: LD_INT 0
33191: PUSH
33192: EMPTY
33193: LIST
33194: LIST
33195: PUSH
33196: LD_INT 2
33198: PUSH
33199: LD_INT 1
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: LD_INT 1
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: LD_INT 2
33219: NEG
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 2
33230: NEG
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: EMPTY
33237: LIST
33238: LIST
33239: PUSH
33240: LD_INT 2
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 3
33253: PUSH
33254: LD_INT 0
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 3
33263: PUSH
33264: LD_INT 1
33266: PUSH
33267: EMPTY
33268: LIST
33269: LIST
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
33289: LD_ADDR_VAR 0 16
33293: PUSH
33294: LD_INT 0
33296: PUSH
33297: LD_INT 0
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 0
33306: PUSH
33307: LD_INT 1
33309: NEG
33310: PUSH
33311: EMPTY
33312: LIST
33313: LIST
33314: PUSH
33315: LD_INT 1
33317: PUSH
33318: LD_INT 0
33320: PUSH
33321: EMPTY
33322: LIST
33323: LIST
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: LD_INT 1
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: LD_INT 0
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: NEG
33348: PUSH
33349: LD_INT 0
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 1
33358: NEG
33359: PUSH
33360: LD_INT 1
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 2
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 2
33392: PUSH
33393: LD_INT 2
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 2
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 2
33412: NEG
33413: PUSH
33414: LD_INT 1
33416: NEG
33417: PUSH
33418: EMPTY
33419: LIST
33420: LIST
33421: PUSH
33422: LD_INT 2
33424: NEG
33425: PUSH
33426: LD_INT 2
33428: NEG
33429: PUSH
33430: EMPTY
33431: LIST
33432: LIST
33433: PUSH
33434: LD_INT 3
33436: PUSH
33437: LD_INT 2
33439: PUSH
33440: EMPTY
33441: LIST
33442: LIST
33443: PUSH
33444: LD_INT 3
33446: PUSH
33447: LD_INT 3
33449: PUSH
33450: EMPTY
33451: LIST
33452: LIST
33453: PUSH
33454: LD_INT 2
33456: PUSH
33457: LD_INT 3
33459: PUSH
33460: EMPTY
33461: LIST
33462: LIST
33463: PUSH
33464: EMPTY
33465: LIST
33466: LIST
33467: LIST
33468: LIST
33469: LIST
33470: LIST
33471: LIST
33472: LIST
33473: LIST
33474: LIST
33475: LIST
33476: LIST
33477: LIST
33478: LIST
33479: LIST
33480: LIST
33481: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33482: LD_ADDR_VAR 0 17
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: LD_INT 0
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 1
33510: PUSH
33511: LD_INT 0
33513: PUSH
33514: EMPTY
33515: LIST
33516: LIST
33517: PUSH
33518: LD_INT 1
33520: PUSH
33521: LD_INT 1
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 0
33530: PUSH
33531: LD_INT 1
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: LD_INT 0
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 1
33551: NEG
33552: PUSH
33553: LD_INT 1
33555: NEG
33556: PUSH
33557: EMPTY
33558: LIST
33559: LIST
33560: PUSH
33561: LD_INT 1
33563: NEG
33564: PUSH
33565: LD_INT 2
33567: NEG
33568: PUSH
33569: EMPTY
33570: LIST
33571: LIST
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: LD_INT 2
33578: NEG
33579: PUSH
33580: EMPTY
33581: LIST
33582: LIST
33583: PUSH
33584: LD_INT 1
33586: PUSH
33587: LD_INT 1
33589: NEG
33590: PUSH
33591: EMPTY
33592: LIST
33593: LIST
33594: PUSH
33595: LD_INT 2
33597: PUSH
33598: LD_INT 0
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 2
33607: PUSH
33608: LD_INT 1
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: LD_INT 2
33617: PUSH
33618: LD_INT 2
33620: PUSH
33621: EMPTY
33622: LIST
33623: LIST
33624: PUSH
33625: LD_INT 1
33627: PUSH
33628: LD_INT 2
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: LD_INT 2
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 1
33647: NEG
33648: PUSH
33649: LD_INT 1
33651: PUSH
33652: EMPTY
33653: LIST
33654: LIST
33655: PUSH
33656: LD_INT 2
33658: NEG
33659: PUSH
33660: LD_INT 0
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 2
33669: NEG
33670: PUSH
33671: LD_INT 1
33673: NEG
33674: PUSH
33675: EMPTY
33676: LIST
33677: LIST
33678: PUSH
33679: LD_INT 2
33681: NEG
33682: PUSH
33683: LD_INT 2
33685: NEG
33686: PUSH
33687: EMPTY
33688: LIST
33689: LIST
33690: PUSH
33691: EMPTY
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33712: LD_ADDR_VAR 0 18
33716: PUSH
33717: LD_INT 0
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 0
33729: PUSH
33730: LD_INT 1
33732: NEG
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: EMPTY
33745: LIST
33746: LIST
33747: PUSH
33748: LD_INT 1
33750: PUSH
33751: LD_INT 1
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: LD_INT 1
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: LD_INT 1
33770: NEG
33771: PUSH
33772: LD_INT 0
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 1
33781: NEG
33782: PUSH
33783: LD_INT 1
33785: NEG
33786: PUSH
33787: EMPTY
33788: LIST
33789: LIST
33790: PUSH
33791: LD_INT 1
33793: NEG
33794: PUSH
33795: LD_INT 2
33797: NEG
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 0
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: LD_INT 1
33816: PUSH
33817: LD_INT 1
33819: NEG
33820: PUSH
33821: EMPTY
33822: LIST
33823: LIST
33824: PUSH
33825: LD_INT 2
33827: PUSH
33828: LD_INT 0
33830: PUSH
33831: EMPTY
33832: LIST
33833: LIST
33834: PUSH
33835: LD_INT 2
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: LD_INT 2
33847: PUSH
33848: LD_INT 2
33850: PUSH
33851: EMPTY
33852: LIST
33853: LIST
33854: PUSH
33855: LD_INT 1
33857: PUSH
33858: LD_INT 2
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: LD_INT 2
33870: PUSH
33871: EMPTY
33872: LIST
33873: LIST
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: LD_INT 1
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 2
33888: NEG
33889: PUSH
33890: LD_INT 0
33892: PUSH
33893: EMPTY
33894: LIST
33895: LIST
33896: PUSH
33897: LD_INT 2
33899: NEG
33900: PUSH
33901: LD_INT 1
33903: NEG
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 2
33911: NEG
33912: PUSH
33913: LD_INT 2
33915: NEG
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: LIST
33925: LIST
33926: LIST
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: LIST
33937: LIST
33938: LIST
33939: LIST
33940: LIST
33941: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33942: LD_ADDR_VAR 0 19
33946: PUSH
33947: LD_INT 0
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 0
33959: PUSH
33960: LD_INT 1
33962: NEG
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: LD_INT 0
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 1
33980: PUSH
33981: LD_INT 1
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 0
33990: PUSH
33991: LD_INT 1
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 1
34000: NEG
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 1
34011: NEG
34012: PUSH
34013: LD_INT 1
34015: NEG
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 2
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 0
34035: PUSH
34036: LD_INT 2
34038: NEG
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 1
34046: PUSH
34047: LD_INT 1
34049: NEG
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: LD_INT 2
34057: PUSH
34058: LD_INT 0
34060: PUSH
34061: EMPTY
34062: LIST
34063: LIST
34064: PUSH
34065: LD_INT 2
34067: PUSH
34068: LD_INT 1
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 2
34077: PUSH
34078: LD_INT 2
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 2
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 2
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 1
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 2
34118: NEG
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 2
34129: NEG
34130: PUSH
34131: LD_INT 1
34133: NEG
34134: PUSH
34135: EMPTY
34136: LIST
34137: LIST
34138: PUSH
34139: LD_INT 2
34141: NEG
34142: PUSH
34143: LD_INT 2
34145: NEG
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: EMPTY
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: LIST
34161: LIST
34162: LIST
34163: LIST
34164: LIST
34165: LIST
34166: LIST
34167: LIST
34168: LIST
34169: LIST
34170: LIST
34171: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34172: LD_ADDR_VAR 0 20
34176: PUSH
34177: LD_INT 0
34179: PUSH
34180: LD_INT 0
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 0
34189: PUSH
34190: LD_INT 1
34192: NEG
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 0
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 1
34210: PUSH
34211: LD_INT 1
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 0
34220: PUSH
34221: LD_INT 1
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 1
34241: NEG
34242: PUSH
34243: LD_INT 1
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: LD_INT 1
34253: NEG
34254: PUSH
34255: LD_INT 2
34257: NEG
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 0
34265: PUSH
34266: LD_INT 2
34268: NEG
34269: PUSH
34270: EMPTY
34271: LIST
34272: LIST
34273: PUSH
34274: LD_INT 1
34276: PUSH
34277: LD_INT 1
34279: NEG
34280: PUSH
34281: EMPTY
34282: LIST
34283: LIST
34284: PUSH
34285: LD_INT 2
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: PUSH
34295: LD_INT 2
34297: PUSH
34298: LD_INT 1
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: LD_INT 2
34307: PUSH
34308: LD_INT 2
34310: PUSH
34311: EMPTY
34312: LIST
34313: LIST
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: LD_INT 2
34320: PUSH
34321: EMPTY
34322: LIST
34323: LIST
34324: PUSH
34325: LD_INT 0
34327: PUSH
34328: LD_INT 2
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: LD_INT 1
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 2
34348: NEG
34349: PUSH
34350: LD_INT 0
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 2
34359: NEG
34360: PUSH
34361: LD_INT 1
34363: NEG
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 2
34371: NEG
34372: PUSH
34373: LD_INT 2
34375: NEG
34376: PUSH
34377: EMPTY
34378: LIST
34379: LIST
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: LIST
34385: LIST
34386: LIST
34387: LIST
34388: LIST
34389: LIST
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34402: LD_ADDR_VAR 0 21
34406: PUSH
34407: LD_INT 0
34409: PUSH
34410: LD_INT 0
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 0
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: PUSH
34441: LD_INT 1
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 0
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: LD_INT 1
34460: NEG
34461: PUSH
34462: LD_INT 0
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: NEG
34472: PUSH
34473: LD_INT 1
34475: NEG
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 2
34487: NEG
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 0
34495: PUSH
34496: LD_INT 2
34498: NEG
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: EMPTY
34512: LIST
34513: LIST
34514: PUSH
34515: LD_INT 2
34517: PUSH
34518: LD_INT 0
34520: PUSH
34521: EMPTY
34522: LIST
34523: LIST
34524: PUSH
34525: LD_INT 2
34527: PUSH
34528: LD_INT 1
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: LD_INT 2
34537: PUSH
34538: LD_INT 2
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: LD_INT 1
34547: PUSH
34548: LD_INT 2
34550: PUSH
34551: EMPTY
34552: LIST
34553: LIST
34554: PUSH
34555: LD_INT 0
34557: PUSH
34558: LD_INT 2
34560: PUSH
34561: EMPTY
34562: LIST
34563: LIST
34564: PUSH
34565: LD_INT 1
34567: NEG
34568: PUSH
34569: LD_INT 1
34571: PUSH
34572: EMPTY
34573: LIST
34574: LIST
34575: PUSH
34576: LD_INT 2
34578: NEG
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: EMPTY
34584: LIST
34585: LIST
34586: PUSH
34587: LD_INT 2
34589: NEG
34590: PUSH
34591: LD_INT 1
34593: NEG
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 2
34601: NEG
34602: PUSH
34603: LD_INT 2
34605: NEG
34606: PUSH
34607: EMPTY
34608: LIST
34609: LIST
34610: PUSH
34611: EMPTY
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34632: LD_ADDR_VAR 0 22
34636: PUSH
34637: LD_INT 0
34639: PUSH
34640: LD_INT 0
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 0
34649: PUSH
34650: LD_INT 1
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 1
34670: PUSH
34671: LD_INT 1
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: PUSH
34678: LD_INT 0
34680: PUSH
34681: LD_INT 1
34683: PUSH
34684: EMPTY
34685: LIST
34686: LIST
34687: PUSH
34688: LD_INT 1
34690: NEG
34691: PUSH
34692: LD_INT 0
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: NEG
34702: PUSH
34703: LD_INT 1
34705: NEG
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 1
34713: NEG
34714: PUSH
34715: LD_INT 2
34717: NEG
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 0
34725: PUSH
34726: LD_INT 2
34728: NEG
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 1
34736: PUSH
34737: LD_INT 1
34739: NEG
34740: PUSH
34741: EMPTY
34742: LIST
34743: LIST
34744: PUSH
34745: LD_INT 2
34747: PUSH
34748: LD_INT 0
34750: PUSH
34751: EMPTY
34752: LIST
34753: LIST
34754: PUSH
34755: LD_INT 2
34757: PUSH
34758: LD_INT 1
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 2
34767: PUSH
34768: LD_INT 2
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 1
34777: PUSH
34778: LD_INT 2
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 0
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 2
34808: NEG
34809: PUSH
34810: LD_INT 0
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: NEG
34820: PUSH
34821: LD_INT 1
34823: NEG
34824: PUSH
34825: EMPTY
34826: LIST
34827: LIST
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: LD_INT 2
34835: NEG
34836: PUSH
34837: EMPTY
34838: LIST
34839: LIST
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: LIST
34848: LIST
34849: LIST
34850: LIST
34851: LIST
34852: LIST
34853: LIST
34854: LIST
34855: LIST
34856: LIST
34857: LIST
34858: LIST
34859: LIST
34860: LIST
34861: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34862: LD_ADDR_VAR 0 23
34866: PUSH
34867: LD_INT 0
34869: PUSH
34870: LD_INT 0
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 0
34879: PUSH
34880: LD_INT 1
34882: NEG
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: LD_INT 0
34893: PUSH
34894: EMPTY
34895: LIST
34896: LIST
34897: PUSH
34898: LD_INT 1
34900: PUSH
34901: LD_INT 1
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 0
34910: PUSH
34911: LD_INT 1
34913: PUSH
34914: EMPTY
34915: LIST
34916: LIST
34917: PUSH
34918: LD_INT 1
34920: NEG
34921: PUSH
34922: LD_INT 0
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: NEG
34932: PUSH
34933: LD_INT 1
34935: NEG
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: LD_INT 2
34947: NEG
34948: PUSH
34949: EMPTY
34950: LIST
34951: LIST
34952: PUSH
34953: LD_INT 0
34955: PUSH
34956: LD_INT 2
34958: NEG
34959: PUSH
34960: EMPTY
34961: LIST
34962: LIST
34963: PUSH
34964: LD_INT 1
34966: PUSH
34967: LD_INT 1
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 2
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 2
34987: PUSH
34988: LD_INT 1
34990: PUSH
34991: EMPTY
34992: LIST
34993: LIST
34994: PUSH
34995: LD_INT 2
34997: PUSH
34998: LD_INT 2
35000: PUSH
35001: EMPTY
35002: LIST
35003: LIST
35004: PUSH
35005: LD_INT 1
35007: PUSH
35008: LD_INT 2
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PUSH
35015: LD_INT 0
35017: PUSH
35018: LD_INT 2
35020: PUSH
35021: EMPTY
35022: LIST
35023: LIST
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: LD_INT 1
35031: PUSH
35032: EMPTY
35033: LIST
35034: LIST
35035: PUSH
35036: LD_INT 2
35038: NEG
35039: PUSH
35040: LD_INT 0
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: PUSH
35047: LD_INT 2
35049: NEG
35050: PUSH
35051: LD_INT 1
35053: NEG
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: LD_INT 2
35065: NEG
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: NEG
35074: PUSH
35075: LD_INT 3
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 1
35085: NEG
35086: PUSH
35087: LD_INT 3
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: PUSH
35098: LD_INT 2
35100: NEG
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: LD_INT 2
35108: PUSH
35109: LD_INT 1
35111: NEG
35112: PUSH
35113: EMPTY
35114: LIST
35115: LIST
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: LIST
35137: LIST
35138: LIST
35139: LIST
35140: LIST
35141: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
35142: LD_ADDR_VAR 0 24
35146: PUSH
35147: LD_INT 0
35149: PUSH
35150: LD_INT 0
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 0
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: LD_INT 0
35173: PUSH
35174: EMPTY
35175: LIST
35176: LIST
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 0
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 1
35200: NEG
35201: PUSH
35202: LD_INT 0
35204: PUSH
35205: EMPTY
35206: LIST
35207: LIST
35208: PUSH
35209: LD_INT 1
35211: NEG
35212: PUSH
35213: LD_INT 1
35215: NEG
35216: PUSH
35217: EMPTY
35218: LIST
35219: LIST
35220: PUSH
35221: LD_INT 1
35223: NEG
35224: PUSH
35225: LD_INT 2
35227: NEG
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 0
35235: PUSH
35236: LD_INT 2
35238: NEG
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: LD_INT 1
35249: NEG
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 2
35257: PUSH
35258: LD_INT 0
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: PUSH
35278: LD_INT 2
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: LD_INT 2
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 2
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: LD_INT 1
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 2
35318: NEG
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 2
35329: NEG
35330: PUSH
35331: LD_INT 1
35333: NEG
35334: PUSH
35335: EMPTY
35336: LIST
35337: LIST
35338: PUSH
35339: LD_INT 2
35341: NEG
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: LD_INT 2
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: EMPTY
35370: LIST
35371: LIST
35372: PUSH
35373: LD_INT 3
35375: PUSH
35376: LD_INT 1
35378: PUSH
35379: EMPTY
35380: LIST
35381: LIST
35382: PUSH
35383: LD_INT 3
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: EMPTY
35394: LIST
35395: LIST
35396: LIST
35397: LIST
35398: LIST
35399: LIST
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35418: LD_ADDR_VAR 0 25
35422: PUSH
35423: LD_INT 0
35425: PUSH
35426: LD_INT 0
35428: PUSH
35429: EMPTY
35430: LIST
35431: LIST
35432: PUSH
35433: LD_INT 0
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 1
35446: PUSH
35447: LD_INT 0
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: LD_INT 1
35456: PUSH
35457: LD_INT 1
35459: PUSH
35460: EMPTY
35461: LIST
35462: LIST
35463: PUSH
35464: LD_INT 0
35466: PUSH
35467: LD_INT 1
35469: PUSH
35470: EMPTY
35471: LIST
35472: LIST
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: LD_INT 1
35487: NEG
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: EMPTY
35494: LIST
35495: LIST
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: LD_INT 2
35503: NEG
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 0
35511: PUSH
35512: LD_INT 2
35514: NEG
35515: PUSH
35516: EMPTY
35517: LIST
35518: LIST
35519: PUSH
35520: LD_INT 1
35522: PUSH
35523: LD_INT 1
35525: NEG
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: PUSH
35531: LD_INT 2
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: EMPTY
35538: LIST
35539: LIST
35540: PUSH
35541: LD_INT 2
35543: PUSH
35544: LD_INT 1
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 2
35553: PUSH
35554: LD_INT 2
35556: PUSH
35557: EMPTY
35558: LIST
35559: LIST
35560: PUSH
35561: LD_INT 1
35563: PUSH
35564: LD_INT 2
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 0
35573: PUSH
35574: LD_INT 2
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 1
35583: NEG
35584: PUSH
35585: LD_INT 1
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 2
35594: NEG
35595: PUSH
35596: LD_INT 0
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 2
35605: NEG
35606: PUSH
35607: LD_INT 1
35609: NEG
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 2
35617: NEG
35618: PUSH
35619: LD_INT 2
35621: NEG
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: PUSH
35627: LD_INT 3
35629: PUSH
35630: LD_INT 1
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 3
35639: PUSH
35640: LD_INT 2
35642: PUSH
35643: EMPTY
35644: LIST
35645: LIST
35646: PUSH
35647: LD_INT 2
35649: PUSH
35650: LD_INT 3
35652: PUSH
35653: EMPTY
35654: LIST
35655: LIST
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: LD_INT 3
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: LIST
35671: LIST
35672: LIST
35673: LIST
35674: LIST
35675: LIST
35676: LIST
35677: LIST
35678: LIST
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: LIST
35689: LIST
35690: LIST
35691: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35692: LD_ADDR_VAR 0 26
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: LD_INT 0
35702: PUSH
35703: EMPTY
35704: LIST
35705: LIST
35706: PUSH
35707: LD_INT 0
35709: PUSH
35710: LD_INT 1
35712: NEG
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: LD_INT 0
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 0
35740: PUSH
35741: LD_INT 1
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 1
35750: NEG
35751: PUSH
35752: LD_INT 0
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 1
35761: NEG
35762: PUSH
35763: LD_INT 1
35765: NEG
35766: PUSH
35767: EMPTY
35768: LIST
35769: LIST
35770: PUSH
35771: LD_INT 1
35773: NEG
35774: PUSH
35775: LD_INT 2
35777: NEG
35778: PUSH
35779: EMPTY
35780: LIST
35781: LIST
35782: PUSH
35783: LD_INT 0
35785: PUSH
35786: LD_INT 2
35788: NEG
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: PUSH
35794: LD_INT 1
35796: PUSH
35797: LD_INT 1
35799: NEG
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 2
35807: PUSH
35808: LD_INT 0
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 2
35817: PUSH
35818: LD_INT 1
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 2
35827: PUSH
35828: LD_INT 2
35830: PUSH
35831: EMPTY
35832: LIST
35833: LIST
35834: PUSH
35835: LD_INT 1
35837: PUSH
35838: LD_INT 2
35840: PUSH
35841: EMPTY
35842: LIST
35843: LIST
35844: PUSH
35845: LD_INT 0
35847: PUSH
35848: LD_INT 2
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: PUSH
35855: LD_INT 1
35857: NEG
35858: PUSH
35859: LD_INT 1
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: PUSH
35866: LD_INT 2
35868: NEG
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: LD_INT 1
35883: NEG
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 2
35891: NEG
35892: PUSH
35893: LD_INT 2
35895: NEG
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 2
35903: PUSH
35904: LD_INT 3
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 1
35913: PUSH
35914: LD_INT 3
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: NEG
35924: PUSH
35925: LD_INT 2
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 2
35934: NEG
35935: PUSH
35936: LD_INT 1
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: LIST
35947: LIST
35948: LIST
35949: LIST
35950: LIST
35951: LIST
35952: LIST
35953: LIST
35954: LIST
35955: LIST
35956: LIST
35957: LIST
35958: LIST
35959: LIST
35960: LIST
35961: LIST
35962: LIST
35963: LIST
35964: LIST
35965: LIST
35966: LIST
35967: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35968: LD_ADDR_VAR 0 27
35972: PUSH
35973: LD_INT 0
35975: PUSH
35976: LD_INT 0
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 0
35985: PUSH
35986: LD_INT 1
35988: NEG
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: LD_INT 1
35996: PUSH
35997: LD_INT 0
35999: PUSH
36000: EMPTY
36001: LIST
36002: LIST
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: LD_INT 1
36009: PUSH
36010: EMPTY
36011: LIST
36012: LIST
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: LD_INT 1
36019: PUSH
36020: EMPTY
36021: LIST
36022: LIST
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: LD_INT 0
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 1
36037: NEG
36038: PUSH
36039: LD_INT 1
36041: NEG
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: LD_INT 2
36053: NEG
36054: PUSH
36055: EMPTY
36056: LIST
36057: LIST
36058: PUSH
36059: LD_INT 0
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: EMPTY
36067: LIST
36068: LIST
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: PUSH
36081: LD_INT 2
36083: PUSH
36084: LD_INT 0
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 2
36093: PUSH
36094: LD_INT 1
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: LD_INT 2
36103: PUSH
36104: LD_INT 2
36106: PUSH
36107: EMPTY
36108: LIST
36109: LIST
36110: PUSH
36111: LD_INT 1
36113: PUSH
36114: LD_INT 2
36116: PUSH
36117: EMPTY
36118: LIST
36119: LIST
36120: PUSH
36121: LD_INT 0
36123: PUSH
36124: LD_INT 2
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: LD_INT 1
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 2
36144: NEG
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 2
36155: NEG
36156: PUSH
36157: LD_INT 1
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 2
36167: NEG
36168: PUSH
36169: LD_INT 2
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 1
36179: NEG
36180: PUSH
36181: LD_INT 2
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PUSH
36188: LD_INT 2
36190: NEG
36191: PUSH
36192: LD_INT 1
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: LD_INT 3
36201: NEG
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 3
36213: NEG
36214: PUSH
36215: LD_INT 2
36217: NEG
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: LIST
36229: LIST
36230: LIST
36231: LIST
36232: LIST
36233: LIST
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: LIST
36239: LIST
36240: LIST
36241: LIST
36242: LIST
36243: LIST
36244: LIST
36245: LIST
36246: LIST
36247: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
36248: LD_ADDR_VAR 0 28
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: LD_INT 0
36258: PUSH
36259: EMPTY
36260: LIST
36261: LIST
36262: PUSH
36263: LD_INT 0
36265: PUSH
36266: LD_INT 1
36268: NEG
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 1
36276: PUSH
36277: LD_INT 0
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: LD_INT 1
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: LD_INT 0
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 1
36317: NEG
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 1
36329: NEG
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 0
36341: PUSH
36342: LD_INT 2
36344: NEG
36345: PUSH
36346: EMPTY
36347: LIST
36348: LIST
36349: PUSH
36350: LD_INT 1
36352: PUSH
36353: LD_INT 1
36355: NEG
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 2
36363: PUSH
36364: LD_INT 0
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 2
36373: PUSH
36374: LD_INT 1
36376: PUSH
36377: EMPTY
36378: LIST
36379: LIST
36380: PUSH
36381: LD_INT 2
36383: PUSH
36384: LD_INT 2
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: LD_INT 2
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: LD_INT 2
36406: PUSH
36407: EMPTY
36408: LIST
36409: LIST
36410: PUSH
36411: LD_INT 1
36413: NEG
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 2
36424: NEG
36425: PUSH
36426: LD_INT 0
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: NEG
36436: PUSH
36437: LD_INT 1
36439: NEG
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 2
36447: NEG
36448: PUSH
36449: LD_INT 2
36451: NEG
36452: PUSH
36453: EMPTY
36454: LIST
36455: LIST
36456: PUSH
36457: LD_INT 2
36459: NEG
36460: PUSH
36461: LD_INT 3
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 3
36475: NEG
36476: PUSH
36477: EMPTY
36478: LIST
36479: LIST
36480: PUSH
36481: LD_INT 3
36483: NEG
36484: PUSH
36485: LD_INT 1
36487: NEG
36488: PUSH
36489: EMPTY
36490: LIST
36491: LIST
36492: PUSH
36493: LD_INT 3
36495: NEG
36496: PUSH
36497: LD_INT 2
36499: NEG
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36530: LD_ADDR_VAR 0 29
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: LD_INT 0
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 0
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 1
36558: PUSH
36559: LD_INT 0
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 1
36571: PUSH
36572: EMPTY
36573: LIST
36574: LIST
36575: PUSH
36576: LD_INT 0
36578: PUSH
36579: LD_INT 1
36581: PUSH
36582: EMPTY
36583: LIST
36584: LIST
36585: PUSH
36586: LD_INT 1
36588: NEG
36589: PUSH
36590: LD_INT 0
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 1
36599: NEG
36600: PUSH
36601: LD_INT 1
36603: NEG
36604: PUSH
36605: EMPTY
36606: LIST
36607: LIST
36608: PUSH
36609: LD_INT 1
36611: NEG
36612: PUSH
36613: LD_INT 2
36615: NEG
36616: PUSH
36617: EMPTY
36618: LIST
36619: LIST
36620: PUSH
36621: LD_INT 0
36623: PUSH
36624: LD_INT 2
36626: NEG
36627: PUSH
36628: EMPTY
36629: LIST
36630: LIST
36631: PUSH
36632: LD_INT 1
36634: PUSH
36635: LD_INT 1
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 2
36645: PUSH
36646: LD_INT 0
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 2
36655: PUSH
36656: LD_INT 1
36658: PUSH
36659: EMPTY
36660: LIST
36661: LIST
36662: PUSH
36663: LD_INT 1
36665: PUSH
36666: LD_INT 2
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 0
36675: PUSH
36676: LD_INT 2
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 1
36685: NEG
36686: PUSH
36687: LD_INT 1
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 2
36696: NEG
36697: PUSH
36698: LD_INT 1
36700: NEG
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 2
36708: NEG
36709: PUSH
36710: LD_INT 2
36712: NEG
36713: PUSH
36714: EMPTY
36715: LIST
36716: LIST
36717: PUSH
36718: LD_INT 2
36720: NEG
36721: PUSH
36722: LD_INT 3
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 2
36732: PUSH
36733: LD_INT 1
36735: NEG
36736: PUSH
36737: EMPTY
36738: LIST
36739: LIST
36740: PUSH
36741: LD_INT 3
36743: PUSH
36744: LD_INT 1
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: PUSH
36754: LD_INT 3
36756: PUSH
36757: EMPTY
36758: LIST
36759: LIST
36760: PUSH
36761: LD_INT 1
36763: NEG
36764: PUSH
36765: LD_INT 2
36767: PUSH
36768: EMPTY
36769: LIST
36770: LIST
36771: PUSH
36772: LD_INT 3
36774: NEG
36775: PUSH
36776: LD_INT 2
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: LIST
36788: LIST
36789: LIST
36790: LIST
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: LIST
36804: LIST
36805: LIST
36806: LIST
36807: LIST
36808: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36809: LD_ADDR_VAR 0 30
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: LD_INT 0
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 0
36826: PUSH
36827: LD_INT 1
36829: NEG
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: PUSH
36838: LD_INT 0
36840: PUSH
36841: EMPTY
36842: LIST
36843: LIST
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 0
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 1
36867: NEG
36868: PUSH
36869: LD_INT 0
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: NEG
36879: PUSH
36880: LD_INT 1
36882: NEG
36883: PUSH
36884: EMPTY
36885: LIST
36886: LIST
36887: PUSH
36888: LD_INT 1
36890: NEG
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 0
36902: PUSH
36903: LD_INT 2
36905: NEG
36906: PUSH
36907: EMPTY
36908: LIST
36909: LIST
36910: PUSH
36911: LD_INT 1
36913: PUSH
36914: LD_INT 1
36916: NEG
36917: PUSH
36918: EMPTY
36919: LIST
36920: LIST
36921: PUSH
36922: LD_INT 2
36924: PUSH
36925: LD_INT 0
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 2
36934: PUSH
36935: LD_INT 1
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 2
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 1
36954: PUSH
36955: LD_INT 2
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 1
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 2
36975: NEG
36976: PUSH
36977: LD_INT 0
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 2
36986: NEG
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 1
36998: NEG
36999: PUSH
37000: LD_INT 3
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 1
37010: PUSH
37011: LD_INT 2
37013: NEG
37014: PUSH
37015: EMPTY
37016: LIST
37017: LIST
37018: PUSH
37019: LD_INT 3
37021: PUSH
37022: LD_INT 2
37024: PUSH
37025: EMPTY
37026: LIST
37027: LIST
37028: PUSH
37029: LD_INT 2
37031: PUSH
37032: LD_INT 3
37034: PUSH
37035: EMPTY
37036: LIST
37037: LIST
37038: PUSH
37039: LD_INT 2
37041: NEG
37042: PUSH
37043: LD_INT 1
37045: PUSH
37046: EMPTY
37047: LIST
37048: LIST
37049: PUSH
37050: LD_INT 3
37052: NEG
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: LIST
37066: LIST
37067: LIST
37068: LIST
37069: LIST
37070: LIST
37071: LIST
37072: LIST
37073: LIST
37074: LIST
37075: LIST
37076: LIST
37077: LIST
37078: LIST
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37087: LD_ADDR_VAR 0 31
37091: PUSH
37092: LD_INT 0
37094: PUSH
37095: LD_INT 0
37097: PUSH
37098: EMPTY
37099: LIST
37100: LIST
37101: PUSH
37102: LD_INT 0
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: PUSH
37116: LD_INT 0
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: PUSH
37126: LD_INT 1
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 0
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 1
37145: NEG
37146: PUSH
37147: LD_INT 0
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: LD_INT 1
37156: NEG
37157: PUSH
37158: LD_INT 1
37160: NEG
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: LD_INT 2
37172: NEG
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 1
37180: PUSH
37181: LD_INT 1
37183: NEG
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 2
37191: PUSH
37192: LD_INT 0
37194: PUSH
37195: EMPTY
37196: LIST
37197: LIST
37198: PUSH
37199: LD_INT 2
37201: PUSH
37202: LD_INT 1
37204: PUSH
37205: EMPTY
37206: LIST
37207: LIST
37208: PUSH
37209: LD_INT 2
37211: PUSH
37212: LD_INT 2
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PUSH
37219: LD_INT 1
37221: PUSH
37222: LD_INT 2
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 2
37234: PUSH
37235: EMPTY
37236: LIST
37237: LIST
37238: PUSH
37239: LD_INT 1
37241: NEG
37242: PUSH
37243: LD_INT 1
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 2
37252: NEG
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 2
37264: NEG
37265: PUSH
37266: LD_INT 2
37268: NEG
37269: PUSH
37270: EMPTY
37271: LIST
37272: LIST
37273: PUSH
37274: LD_INT 2
37276: NEG
37277: PUSH
37278: LD_INT 3
37280: NEG
37281: PUSH
37282: EMPTY
37283: LIST
37284: LIST
37285: PUSH
37286: LD_INT 2
37288: PUSH
37289: LD_INT 1
37291: NEG
37292: PUSH
37293: EMPTY
37294: LIST
37295: LIST
37296: PUSH
37297: LD_INT 3
37299: PUSH
37300: LD_INT 1
37302: PUSH
37303: EMPTY
37304: LIST
37305: LIST
37306: PUSH
37307: LD_INT 1
37309: PUSH
37310: LD_INT 3
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 1
37319: NEG
37320: PUSH
37321: LD_INT 2
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 3
37330: NEG
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37365: LD_ADDR_VAR 0 32
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 1
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 2
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 0
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 1
37520: NEG
37521: PUSH
37522: LD_INT 1
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 2
37531: NEG
37532: PUSH
37533: LD_INT 0
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 2
37542: NEG
37543: PUSH
37544: LD_INT 1
37546: NEG
37547: PUSH
37548: EMPTY
37549: LIST
37550: LIST
37551: PUSH
37552: LD_INT 1
37554: NEG
37555: PUSH
37556: LD_INT 3
37558: NEG
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 1
37566: PUSH
37567: LD_INT 2
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 3
37577: PUSH
37578: LD_INT 2
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 2
37587: PUSH
37588: LD_INT 3
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 2
37597: NEG
37598: PUSH
37599: LD_INT 1
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: PUSH
37606: LD_INT 3
37608: NEG
37609: PUSH
37610: LD_INT 1
37612: NEG
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: EMPTY
37619: LIST
37620: LIST
37621: LIST
37622: LIST
37623: LIST
37624: LIST
37625: LIST
37626: LIST
37627: LIST
37628: LIST
37629: LIST
37630: LIST
37631: LIST
37632: LIST
37633: LIST
37634: LIST
37635: LIST
37636: LIST
37637: LIST
37638: LIST
37639: LIST
37640: LIST
37641: LIST
37642: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37643: LD_ADDR_VAR 0 33
37647: PUSH
37648: LD_INT 0
37650: PUSH
37651: LD_INT 0
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 1
37663: NEG
37664: PUSH
37665: EMPTY
37666: LIST
37667: LIST
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: LD_INT 0
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 1
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: EMPTY
37686: LIST
37687: LIST
37688: PUSH
37689: LD_INT 0
37691: PUSH
37692: LD_INT 1
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 0
37705: PUSH
37706: EMPTY
37707: LIST
37708: LIST
37709: PUSH
37710: LD_INT 1
37712: NEG
37713: PUSH
37714: LD_INT 1
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: NEG
37725: PUSH
37726: LD_INT 2
37728: NEG
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 1
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 2
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 2
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: LD_INT 2
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: LD_INT 2
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: LD_INT 1
37791: PUSH
37792: EMPTY
37793: LIST
37794: LIST
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: LD_INT 0
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PUSH
37807: LD_INT 2
37809: NEG
37810: PUSH
37811: LD_INT 1
37813: NEG
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: LD_INT 2
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 2
37833: NEG
37834: PUSH
37835: LD_INT 3
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 2
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: PUSH
37857: LD_INT 1
37859: PUSH
37860: EMPTY
37861: LIST
37862: LIST
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: LD_INT 3
37869: PUSH
37870: EMPTY
37871: LIST
37872: LIST
37873: PUSH
37874: LD_INT 1
37876: NEG
37877: PUSH
37878: LD_INT 2
37880: PUSH
37881: EMPTY
37882: LIST
37883: LIST
37884: PUSH
37885: LD_INT 3
37887: NEG
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: EMPTY
37894: LIST
37895: LIST
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: LIST
37903: LIST
37904: LIST
37905: LIST
37906: LIST
37907: LIST
37908: LIST
37909: LIST
37910: LIST
37911: LIST
37912: LIST
37913: LIST
37914: LIST
37915: LIST
37916: LIST
37917: LIST
37918: LIST
37919: LIST
37920: LIST
37921: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37922: LD_ADDR_VAR 0 34
37926: PUSH
37927: LD_INT 0
37929: PUSH
37930: LD_INT 0
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PUSH
37937: LD_INT 0
37939: PUSH
37940: LD_INT 1
37942: NEG
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 1
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 1
37960: PUSH
37961: LD_INT 1
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 0
37970: PUSH
37971: LD_INT 1
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 1
37980: NEG
37981: PUSH
37982: LD_INT 0
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 1
37991: NEG
37992: PUSH
37993: LD_INT 1
37995: NEG
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: PUSH
38001: LD_INT 1
38003: NEG
38004: PUSH
38005: LD_INT 2
38007: NEG
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 0
38015: PUSH
38016: LD_INT 2
38018: NEG
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 1
38026: PUSH
38027: LD_INT 1
38029: NEG
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 2
38037: PUSH
38038: LD_INT 1
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 2
38047: PUSH
38048: LD_INT 2
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: PUSH
38055: LD_INT 1
38057: PUSH
38058: LD_INT 2
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 1
38067: NEG
38068: PUSH
38069: LD_INT 1
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 2
38078: NEG
38079: PUSH
38080: LD_INT 0
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 2
38089: NEG
38090: PUSH
38091: LD_INT 1
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 2
38101: NEG
38102: PUSH
38103: LD_INT 2
38105: NEG
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 3
38117: NEG
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: LD_INT 2
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 3
38136: PUSH
38137: LD_INT 2
38139: PUSH
38140: EMPTY
38141: LIST
38142: LIST
38143: PUSH
38144: LD_INT 2
38146: PUSH
38147: LD_INT 3
38149: PUSH
38150: EMPTY
38151: LIST
38152: LIST
38153: PUSH
38154: LD_INT 2
38156: NEG
38157: PUSH
38158: LD_INT 1
38160: PUSH
38161: EMPTY
38162: LIST
38163: LIST
38164: PUSH
38165: LD_INT 3
38167: NEG
38168: PUSH
38169: LD_INT 1
38171: NEG
38172: PUSH
38173: EMPTY
38174: LIST
38175: LIST
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: LIST
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: LIST
38195: LIST
38196: LIST
38197: LIST
38198: LIST
38199: LIST
38200: LIST
38201: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38202: LD_ADDR_VAR 0 35
38206: PUSH
38207: LD_INT 0
38209: PUSH
38210: LD_INT 0
38212: PUSH
38213: EMPTY
38214: LIST
38215: LIST
38216: PUSH
38217: LD_INT 0
38219: PUSH
38220: LD_INT 1
38222: NEG
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 1
38230: PUSH
38231: LD_INT 0
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: LD_INT 1
38240: PUSH
38241: LD_INT 1
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: LD_INT 1
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: LD_INT 0
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 1
38271: NEG
38272: PUSH
38273: LD_INT 1
38275: NEG
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PUSH
38281: LD_INT 2
38283: PUSH
38284: LD_INT 1
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PUSH
38291: LD_INT 2
38293: NEG
38294: PUSH
38295: LD_INT 1
38297: NEG
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: LIST
38310: LIST
38311: LIST
38312: LIST
38313: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38314: LD_ADDR_VAR 0 36
38318: PUSH
38319: LD_INT 0
38321: PUSH
38322: LD_INT 0
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 0
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 1
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 1
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 0
38362: PUSH
38363: LD_INT 1
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 1
38372: NEG
38373: PUSH
38374: LD_INT 0
38376: PUSH
38377: EMPTY
38378: LIST
38379: LIST
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: LD_INT 1
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 1
38395: NEG
38396: PUSH
38397: LD_INT 2
38399: NEG
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: PUSH
38415: EMPTY
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38426: LD_ADDR_VAR 0 37
38430: PUSH
38431: LD_INT 0
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: EMPTY
38438: LIST
38439: LIST
38440: PUSH
38441: LD_INT 0
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: LD_INT 0
38457: PUSH
38458: EMPTY
38459: LIST
38460: LIST
38461: PUSH
38462: LD_INT 1
38464: PUSH
38465: LD_INT 1
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: LD_INT 1
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 1
38484: NEG
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: NEG
38496: PUSH
38497: LD_INT 1
38499: NEG
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 1
38518: NEG
38519: PUSH
38520: LD_INT 1
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38538: LD_ADDR_VAR 0 38
38542: PUSH
38543: LD_INT 0
38545: PUSH
38546: LD_INT 0
38548: PUSH
38549: EMPTY
38550: LIST
38551: LIST
38552: PUSH
38553: LD_INT 0
38555: PUSH
38556: LD_INT 1
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: LD_INT 0
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: LD_INT 1
38579: PUSH
38580: EMPTY
38581: LIST
38582: LIST
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: LD_INT 1
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: LD_INT 0
38600: PUSH
38601: EMPTY
38602: LIST
38603: LIST
38604: PUSH
38605: LD_INT 1
38607: NEG
38608: PUSH
38609: LD_INT 1
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 2
38619: PUSH
38620: LD_INT 1
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PUSH
38627: LD_INT 2
38629: NEG
38630: PUSH
38631: LD_INT 1
38633: NEG
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: LIST
38643: LIST
38644: LIST
38645: LIST
38646: LIST
38647: LIST
38648: LIST
38649: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38650: LD_ADDR_VAR 0 39
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: LD_INT 0
38660: PUSH
38661: EMPTY
38662: LIST
38663: LIST
38664: PUSH
38665: LD_INT 0
38667: PUSH
38668: LD_INT 1
38670: NEG
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 1
38678: PUSH
38679: LD_INT 0
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 1
38688: PUSH
38689: LD_INT 1
38691: PUSH
38692: EMPTY
38693: LIST
38694: LIST
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: LD_INT 1
38701: PUSH
38702: EMPTY
38703: LIST
38704: LIST
38705: PUSH
38706: LD_INT 1
38708: NEG
38709: PUSH
38710: LD_INT 0
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 1
38719: NEG
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: LD_INT 2
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: LD_INT 1
38743: PUSH
38744: LD_INT 2
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38762: LD_ADDR_VAR 0 40
38766: PUSH
38767: LD_INT 0
38769: PUSH
38770: LD_INT 0
38772: PUSH
38773: EMPTY
38774: LIST
38775: LIST
38776: PUSH
38777: LD_INT 0
38779: PUSH
38780: LD_INT 1
38782: NEG
38783: PUSH
38784: EMPTY
38785: LIST
38786: LIST
38787: PUSH
38788: LD_INT 1
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: EMPTY
38795: LIST
38796: LIST
38797: PUSH
38798: LD_INT 1
38800: PUSH
38801: LD_INT 1
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: LD_INT 1
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 1
38820: NEG
38821: PUSH
38822: LD_INT 0
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 1
38831: NEG
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 1
38846: NEG
38847: PUSH
38848: EMPTY
38849: LIST
38850: LIST
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: LD_INT 1
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: EMPTY
38864: LIST
38865: LIST
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38874: LD_ADDR_VAR 0 41
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 0
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 0
38891: PUSH
38892: LD_INT 1
38894: NEG
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: PUSH
38903: LD_INT 0
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: PUSH
38910: LD_INT 1
38912: PUSH
38913: LD_INT 1
38915: PUSH
38916: EMPTY
38917: LIST
38918: LIST
38919: PUSH
38920: LD_INT 0
38922: PUSH
38923: LD_INT 1
38925: PUSH
38926: EMPTY
38927: LIST
38928: LIST
38929: PUSH
38930: LD_INT 1
38932: NEG
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: PUSH
38941: LD_INT 1
38943: NEG
38944: PUSH
38945: LD_INT 1
38947: NEG
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 1
38955: NEG
38956: PUSH
38957: LD_INT 2
38959: NEG
38960: PUSH
38961: EMPTY
38962: LIST
38963: LIST
38964: PUSH
38965: LD_INT 1
38967: PUSH
38968: LD_INT 1
38970: NEG
38971: PUSH
38972: EMPTY
38973: LIST
38974: LIST
38975: PUSH
38976: LD_INT 2
38978: PUSH
38979: LD_INT 0
38981: PUSH
38982: EMPTY
38983: LIST
38984: LIST
38985: PUSH
38986: LD_INT 2
38988: PUSH
38989: LD_INT 1
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 2
38998: PUSH
38999: LD_INT 2
39001: PUSH
39002: EMPTY
39003: LIST
39004: LIST
39005: PUSH
39006: LD_INT 1
39008: PUSH
39009: LD_INT 2
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: LD_INT 1
39018: NEG
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: EMPTY
39024: LIST
39025: LIST
39026: PUSH
39027: LD_INT 2
39029: NEG
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 2
39040: NEG
39041: PUSH
39042: LD_INT 1
39044: NEG
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 2
39052: NEG
39053: PUSH
39054: LD_INT 2
39056: NEG
39057: PUSH
39058: EMPTY
39059: LIST
39060: LIST
39061: PUSH
39062: LD_INT 2
39064: NEG
39065: PUSH
39066: LD_INT 3
39068: NEG
39069: PUSH
39070: EMPTY
39071: LIST
39072: LIST
39073: PUSH
39074: LD_INT 2
39076: PUSH
39077: LD_INT 1
39079: NEG
39080: PUSH
39081: EMPTY
39082: LIST
39083: LIST
39084: PUSH
39085: LD_INT 3
39087: PUSH
39088: LD_INT 0
39090: PUSH
39091: EMPTY
39092: LIST
39093: LIST
39094: PUSH
39095: LD_INT 3
39097: PUSH
39098: LD_INT 1
39100: PUSH
39101: EMPTY
39102: LIST
39103: LIST
39104: PUSH
39105: LD_INT 3
39107: PUSH
39108: LD_INT 2
39110: PUSH
39111: EMPTY
39112: LIST
39113: LIST
39114: PUSH
39115: LD_INT 3
39117: PUSH
39118: LD_INT 3
39120: PUSH
39121: EMPTY
39122: LIST
39123: LIST
39124: PUSH
39125: LD_INT 2
39127: PUSH
39128: LD_INT 3
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 2
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: PUSH
39142: EMPTY
39143: LIST
39144: LIST
39145: PUSH
39146: LD_INT 3
39148: NEG
39149: PUSH
39150: LD_INT 0
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: PUSH
39157: LD_INT 3
39159: NEG
39160: PUSH
39161: LD_INT 1
39163: NEG
39164: PUSH
39165: EMPTY
39166: LIST
39167: LIST
39168: PUSH
39169: LD_INT 3
39171: NEG
39172: PUSH
39173: LD_INT 2
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 3
39183: NEG
39184: PUSH
39185: LD_INT 3
39187: NEG
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: LIST
39197: LIST
39198: LIST
39199: LIST
39200: LIST
39201: LIST
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: LIST
39210: LIST
39211: LIST
39212: LIST
39213: LIST
39214: LIST
39215: LIST
39216: LIST
39217: LIST
39218: LIST
39219: LIST
39220: LIST
39221: LIST
39222: LIST
39223: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39224: LD_ADDR_VAR 0 42
39228: PUSH
39229: LD_INT 0
39231: PUSH
39232: LD_INT 0
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: LD_INT 1
39244: NEG
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 1
39252: PUSH
39253: LD_INT 0
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: LD_INT 1
39275: PUSH
39276: EMPTY
39277: LIST
39278: LIST
39279: PUSH
39280: LD_INT 1
39282: NEG
39283: PUSH
39284: LD_INT 0
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 1
39293: NEG
39294: PUSH
39295: LD_INT 1
39297: NEG
39298: PUSH
39299: EMPTY
39300: LIST
39301: LIST
39302: PUSH
39303: LD_INT 1
39305: NEG
39306: PUSH
39307: LD_INT 2
39309: NEG
39310: PUSH
39311: EMPTY
39312: LIST
39313: LIST
39314: PUSH
39315: LD_INT 0
39317: PUSH
39318: LD_INT 2
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 1
39328: PUSH
39329: LD_INT 1
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 2
39339: PUSH
39340: LD_INT 1
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 2
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: LD_INT 2
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 2
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: LD_INT 1
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 2
39390: NEG
39391: PUSH
39392: LD_INT 1
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 2
39402: NEG
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 2
39414: NEG
39415: PUSH
39416: LD_INT 3
39418: NEG
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 1
39426: NEG
39427: PUSH
39428: LD_INT 3
39430: NEG
39431: PUSH
39432: EMPTY
39433: LIST
39434: LIST
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: LD_INT 3
39441: NEG
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: LD_INT 2
39452: NEG
39453: PUSH
39454: EMPTY
39455: LIST
39456: LIST
39457: PUSH
39458: LD_INT 3
39460: PUSH
39461: LD_INT 2
39463: PUSH
39464: EMPTY
39465: LIST
39466: LIST
39467: PUSH
39468: LD_INT 3
39470: PUSH
39471: LD_INT 3
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 2
39480: PUSH
39481: LD_INT 3
39483: PUSH
39484: EMPTY
39485: LIST
39486: LIST
39487: PUSH
39488: LD_INT 1
39490: PUSH
39491: LD_INT 3
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 0
39500: PUSH
39501: LD_INT 3
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: PUSH
39508: LD_INT 1
39510: NEG
39511: PUSH
39512: LD_INT 2
39514: PUSH
39515: EMPTY
39516: LIST
39517: LIST
39518: PUSH
39519: LD_INT 3
39521: NEG
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: EMPTY
39528: LIST
39529: LIST
39530: PUSH
39531: LD_INT 3
39533: NEG
39534: PUSH
39535: LD_INT 3
39537: NEG
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: LIST
39556: LIST
39557: LIST
39558: LIST
39559: LIST
39560: LIST
39561: LIST
39562: LIST
39563: LIST
39564: LIST
39565: LIST
39566: LIST
39567: LIST
39568: LIST
39569: LIST
39570: LIST
39571: LIST
39572: LIST
39573: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39574: LD_ADDR_VAR 0 43
39578: PUSH
39579: LD_INT 0
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 1
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: LD_INT 0
39622: PUSH
39623: LD_INT 1
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: NEG
39633: PUSH
39634: LD_INT 0
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 1
39643: NEG
39644: PUSH
39645: LD_INT 1
39647: NEG
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: NEG
39656: PUSH
39657: LD_INT 2
39659: NEG
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 0
39667: PUSH
39668: LD_INT 2
39670: NEG
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 1
39678: PUSH
39679: LD_INT 1
39681: NEG
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 2
39689: PUSH
39690: LD_INT 0
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 2
39699: PUSH
39700: LD_INT 1
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: LD_INT 2
39712: PUSH
39713: EMPTY
39714: LIST
39715: LIST
39716: PUSH
39717: LD_INT 0
39719: PUSH
39720: LD_INT 2
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: LD_INT 1
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 2
39740: NEG
39741: PUSH
39742: LD_INT 0
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: PUSH
39749: LD_INT 2
39751: NEG
39752: PUSH
39753: LD_INT 1
39755: NEG
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: LD_INT 3
39767: NEG
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: LD_INT 3
39778: NEG
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: PUSH
39787: LD_INT 2
39789: NEG
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: PUSH
39795: LD_INT 2
39797: PUSH
39798: LD_INT 1
39800: NEG
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: LD_INT 3
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 3
39818: PUSH
39819: LD_INT 1
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 1
39828: PUSH
39829: LD_INT 3
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 0
39838: PUSH
39839: LD_INT 3
39841: PUSH
39842: EMPTY
39843: LIST
39844: LIST
39845: PUSH
39846: LD_INT 1
39848: NEG
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 3
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 3
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: LIST
39895: LIST
39896: LIST
39897: LIST
39898: LIST
39899: LIST
39900: LIST
39901: LIST
39902: LIST
39903: LIST
39904: LIST
39905: LIST
39906: LIST
39907: LIST
39908: LIST
39909: LIST
39910: LIST
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39922: LD_ADDR_VAR 0 44
39926: PUSH
39927: LD_INT 0
39929: PUSH
39930: LD_INT 0
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: LD_INT 0
39939: PUSH
39940: LD_INT 1
39942: NEG
39943: PUSH
39944: EMPTY
39945: LIST
39946: LIST
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 1
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: EMPTY
39965: LIST
39966: LIST
39967: PUSH
39968: LD_INT 0
39970: PUSH
39971: LD_INT 1
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 1
39980: NEG
39981: PUSH
39982: LD_INT 0
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 1
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: LD_INT 1
40003: NEG
40004: PUSH
40005: LD_INT 2
40007: NEG
40008: PUSH
40009: EMPTY
40010: LIST
40011: LIST
40012: PUSH
40013: LD_INT 1
40015: PUSH
40016: LD_INT 1
40018: NEG
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 2
40026: PUSH
40027: LD_INT 0
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 2
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: LD_INT 2
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 1
40056: PUSH
40057: LD_INT 2
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 1
40066: NEG
40067: PUSH
40068: LD_INT 1
40070: PUSH
40071: EMPTY
40072: LIST
40073: LIST
40074: PUSH
40075: LD_INT 2
40077: NEG
40078: PUSH
40079: LD_INT 0
40081: PUSH
40082: EMPTY
40083: LIST
40084: LIST
40085: PUSH
40086: LD_INT 2
40088: NEG
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: PUSH
40098: LD_INT 2
40100: NEG
40101: PUSH
40102: LD_INT 2
40104: NEG
40105: PUSH
40106: EMPTY
40107: LIST
40108: LIST
40109: PUSH
40110: LD_INT 2
40112: NEG
40113: PUSH
40114: LD_INT 3
40116: NEG
40117: PUSH
40118: EMPTY
40119: LIST
40120: LIST
40121: PUSH
40122: LD_INT 2
40124: PUSH
40125: LD_INT 1
40127: NEG
40128: PUSH
40129: EMPTY
40130: LIST
40131: LIST
40132: PUSH
40133: LD_INT 3
40135: PUSH
40136: LD_INT 0
40138: PUSH
40139: EMPTY
40140: LIST
40141: LIST
40142: PUSH
40143: LD_INT 3
40145: PUSH
40146: LD_INT 1
40148: PUSH
40149: EMPTY
40150: LIST
40151: LIST
40152: PUSH
40153: LD_INT 3
40155: PUSH
40156: LD_INT 2
40158: PUSH
40159: EMPTY
40160: LIST
40161: LIST
40162: PUSH
40163: LD_INT 3
40165: PUSH
40166: LD_INT 3
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 2
40175: PUSH
40176: LD_INT 3
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 2
40185: NEG
40186: PUSH
40187: LD_INT 1
40189: PUSH
40190: EMPTY
40191: LIST
40192: LIST
40193: PUSH
40194: LD_INT 3
40196: NEG
40197: PUSH
40198: LD_INT 0
40200: PUSH
40201: EMPTY
40202: LIST
40203: LIST
40204: PUSH
40205: LD_INT 3
40207: NEG
40208: PUSH
40209: LD_INT 1
40211: NEG
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 3
40219: NEG
40220: PUSH
40221: LD_INT 2
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 3
40231: NEG
40232: PUSH
40233: LD_INT 3
40235: NEG
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: PUSH
40241: EMPTY
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: LIST
40249: LIST
40250: LIST
40251: LIST
40252: LIST
40253: LIST
40254: LIST
40255: LIST
40256: LIST
40257: LIST
40258: LIST
40259: LIST
40260: LIST
40261: LIST
40262: LIST
40263: LIST
40264: LIST
40265: LIST
40266: LIST
40267: LIST
40268: LIST
40269: LIST
40270: LIST
40271: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40272: LD_ADDR_VAR 0 45
40276: PUSH
40277: LD_INT 0
40279: PUSH
40280: LD_INT 0
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 0
40289: PUSH
40290: LD_INT 1
40292: NEG
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 1
40310: PUSH
40311: LD_INT 1
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: LD_INT 0
40320: PUSH
40321: LD_INT 1
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: LD_INT 1
40330: NEG
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 1
40341: NEG
40342: PUSH
40343: LD_INT 1
40345: NEG
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 1
40353: NEG
40354: PUSH
40355: LD_INT 2
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 0
40365: PUSH
40366: LD_INT 2
40368: NEG
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 1
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 2
40387: PUSH
40388: LD_INT 1
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 2
40397: PUSH
40398: LD_INT 2
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 1
40407: PUSH
40408: LD_INT 2
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 0
40417: PUSH
40418: LD_INT 2
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 1
40427: NEG
40428: PUSH
40429: LD_INT 1
40431: PUSH
40432: EMPTY
40433: LIST
40434: LIST
40435: PUSH
40436: LD_INT 2
40438: NEG
40439: PUSH
40440: LD_INT 1
40442: NEG
40443: PUSH
40444: EMPTY
40445: LIST
40446: LIST
40447: PUSH
40448: LD_INT 2
40450: NEG
40451: PUSH
40452: LD_INT 2
40454: NEG
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 2
40462: NEG
40463: PUSH
40464: LD_INT 3
40466: NEG
40467: PUSH
40468: EMPTY
40469: LIST
40470: LIST
40471: PUSH
40472: LD_INT 1
40474: NEG
40475: PUSH
40476: LD_INT 3
40478: NEG
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 3
40489: NEG
40490: PUSH
40491: EMPTY
40492: LIST
40493: LIST
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: EMPTY
40503: LIST
40504: LIST
40505: PUSH
40506: LD_INT 3
40508: PUSH
40509: LD_INT 2
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 3
40518: PUSH
40519: LD_INT 3
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 2
40528: PUSH
40529: LD_INT 3
40531: PUSH
40532: EMPTY
40533: LIST
40534: LIST
40535: PUSH
40536: LD_INT 1
40538: PUSH
40539: LD_INT 3
40541: PUSH
40542: EMPTY
40543: LIST
40544: LIST
40545: PUSH
40546: LD_INT 0
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: NEG
40559: PUSH
40560: LD_INT 2
40562: PUSH
40563: EMPTY
40564: LIST
40565: LIST
40566: PUSH
40567: LD_INT 3
40569: NEG
40570: PUSH
40571: LD_INT 2
40573: NEG
40574: PUSH
40575: EMPTY
40576: LIST
40577: LIST
40578: PUSH
40579: LD_INT 3
40581: NEG
40582: PUSH
40583: LD_INT 3
40585: NEG
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: LIST
40610: LIST
40611: LIST
40612: LIST
40613: LIST
40614: LIST
40615: LIST
40616: LIST
40617: LIST
40618: LIST
40619: LIST
40620: LIST
40621: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40622: LD_ADDR_VAR 0 46
40626: PUSH
40627: LD_INT 0
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 0
40639: PUSH
40640: LD_INT 1
40642: NEG
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 1
40650: PUSH
40651: LD_INT 0
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 1
40660: PUSH
40661: LD_INT 1
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 0
40670: PUSH
40671: LD_INT 1
40673: PUSH
40674: EMPTY
40675: LIST
40676: LIST
40677: PUSH
40678: LD_INT 1
40680: NEG
40681: PUSH
40682: LD_INT 0
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: LD_INT 1
40691: NEG
40692: PUSH
40693: LD_INT 1
40695: NEG
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: LD_INT 1
40703: NEG
40704: PUSH
40705: LD_INT 2
40707: NEG
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 0
40715: PUSH
40716: LD_INT 2
40718: NEG
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 1
40726: PUSH
40727: LD_INT 1
40729: NEG
40730: PUSH
40731: EMPTY
40732: LIST
40733: LIST
40734: PUSH
40735: LD_INT 2
40737: PUSH
40738: LD_INT 0
40740: PUSH
40741: EMPTY
40742: LIST
40743: LIST
40744: PUSH
40745: LD_INT 2
40747: PUSH
40748: LD_INT 1
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 1
40757: PUSH
40758: LD_INT 2
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 0
40767: PUSH
40768: LD_INT 2
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 1
40777: NEG
40778: PUSH
40779: LD_INT 1
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 2
40788: NEG
40789: PUSH
40790: LD_INT 0
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 2
40799: NEG
40800: PUSH
40801: LD_INT 1
40803: NEG
40804: PUSH
40805: EMPTY
40806: LIST
40807: LIST
40808: PUSH
40809: LD_INT 1
40811: NEG
40812: PUSH
40813: LD_INT 3
40815: NEG
40816: PUSH
40817: EMPTY
40818: LIST
40819: LIST
40820: PUSH
40821: LD_INT 0
40823: PUSH
40824: LD_INT 3
40826: NEG
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 1
40834: PUSH
40835: LD_INT 2
40837: NEG
40838: PUSH
40839: EMPTY
40840: LIST
40841: LIST
40842: PUSH
40843: LD_INT 2
40845: PUSH
40846: LD_INT 1
40848: NEG
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 3
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 3
40866: PUSH
40867: LD_INT 1
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: PUSH
40874: LD_INT 1
40876: PUSH
40877: LD_INT 3
40879: PUSH
40880: EMPTY
40881: LIST
40882: LIST
40883: PUSH
40884: LD_INT 0
40886: PUSH
40887: LD_INT 3
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 1
40896: NEG
40897: PUSH
40898: LD_INT 2
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: LD_INT 2
40907: NEG
40908: PUSH
40909: LD_INT 1
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 3
40918: NEG
40919: PUSH
40920: LD_INT 0
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: LD_INT 1
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: EMPTY
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: LIST
40950: LIST
40951: LIST
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: LIST
40960: LIST
40961: LIST
40962: LIST
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40970: LD_ADDR_VAR 0 47
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 0
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 0
40987: PUSH
40988: LD_INT 1
40990: NEG
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 0
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 1
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 0
41018: PUSH
41019: LD_INT 1
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 1
41028: NEG
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: LD_INT 1
41043: NEG
41044: PUSH
41045: EMPTY
41046: LIST
41047: LIST
41048: PUSH
41049: LD_INT 1
41051: NEG
41052: PUSH
41053: LD_INT 2
41055: NEG
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: LD_INT 2
41066: NEG
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 1
41074: PUSH
41075: LD_INT 1
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 2
41085: NEG
41086: PUSH
41087: LD_INT 1
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 2
41097: NEG
41098: PUSH
41099: LD_INT 2
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: LIST
41111: LIST
41112: LIST
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41121: LD_ADDR_VAR 0 48
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 1
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 1
41179: NEG
41180: PUSH
41181: LD_INT 0
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 1
41202: NEG
41203: PUSH
41204: LD_INT 2
41206: NEG
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 0
41214: PUSH
41215: LD_INT 2
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: PUSH
41226: LD_INT 1
41228: NEG
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PUSH
41234: LD_INT 2
41236: PUSH
41237: LD_INT 0
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 2
41246: PUSH
41247: LD_INT 1
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: EMPTY
41255: LIST
41256: LIST
41257: LIST
41258: LIST
41259: LIST
41260: LIST
41261: LIST
41262: LIST
41263: LIST
41264: LIST
41265: LIST
41266: LIST
41267: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41268: LD_ADDR_VAR 0 49
41272: PUSH
41273: LD_INT 0
41275: PUSH
41276: LD_INT 0
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: PUSH
41283: LD_INT 0
41285: PUSH
41286: LD_INT 1
41288: NEG
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 1
41296: PUSH
41297: LD_INT 0
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: PUSH
41304: LD_INT 1
41306: PUSH
41307: LD_INT 1
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 0
41316: PUSH
41317: LD_INT 1
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: LD_INT 1
41326: NEG
41327: PUSH
41328: LD_INT 0
41330: PUSH
41331: EMPTY
41332: LIST
41333: LIST
41334: PUSH
41335: LD_INT 1
41337: NEG
41338: PUSH
41339: LD_INT 1
41341: NEG
41342: PUSH
41343: EMPTY
41344: LIST
41345: LIST
41346: PUSH
41347: LD_INT 1
41349: PUSH
41350: LD_INT 1
41352: NEG
41353: PUSH
41354: EMPTY
41355: LIST
41356: LIST
41357: PUSH
41358: LD_INT 2
41360: PUSH
41361: LD_INT 0
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 2
41370: PUSH
41371: LD_INT 1
41373: PUSH
41374: EMPTY
41375: LIST
41376: LIST
41377: PUSH
41378: LD_INT 2
41380: PUSH
41381: LD_INT 2
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: LD_INT 1
41390: PUSH
41391: LD_INT 2
41393: PUSH
41394: EMPTY
41395: LIST
41396: LIST
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: LIST
41402: LIST
41403: LIST
41404: LIST
41405: LIST
41406: LIST
41407: LIST
41408: LIST
41409: LIST
41410: LIST
41411: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41412: LD_ADDR_VAR 0 50
41416: PUSH
41417: LD_INT 0
41419: PUSH
41420: LD_INT 0
41422: PUSH
41423: EMPTY
41424: LIST
41425: LIST
41426: PUSH
41427: LD_INT 0
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: EMPTY
41435: LIST
41436: LIST
41437: PUSH
41438: LD_INT 1
41440: PUSH
41441: LD_INT 0
41443: PUSH
41444: EMPTY
41445: LIST
41446: LIST
41447: PUSH
41448: LD_INT 1
41450: PUSH
41451: LD_INT 1
41453: PUSH
41454: EMPTY
41455: LIST
41456: LIST
41457: PUSH
41458: LD_INT 0
41460: PUSH
41461: LD_INT 1
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: PUSH
41468: LD_INT 1
41470: NEG
41471: PUSH
41472: LD_INT 0
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 1
41481: NEG
41482: PUSH
41483: LD_INT 1
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: LD_INT 2
41493: PUSH
41494: LD_INT 1
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: PUSH
41501: LD_INT 2
41503: PUSH
41504: LD_INT 2
41506: PUSH
41507: EMPTY
41508: LIST
41509: LIST
41510: PUSH
41511: LD_INT 1
41513: PUSH
41514: LD_INT 2
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: PUSH
41521: LD_INT 0
41523: PUSH
41524: LD_INT 2
41526: PUSH
41527: EMPTY
41528: LIST
41529: LIST
41530: PUSH
41531: LD_INT 1
41533: NEG
41534: PUSH
41535: LD_INT 1
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: LIST
41548: LIST
41549: LIST
41550: LIST
41551: LIST
41552: LIST
41553: LIST
41554: LIST
41555: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41556: LD_ADDR_VAR 0 51
41560: PUSH
41561: LD_INT 0
41563: PUSH
41564: LD_INT 0
41566: PUSH
41567: EMPTY
41568: LIST
41569: LIST
41570: PUSH
41571: LD_INT 0
41573: PUSH
41574: LD_INT 1
41576: NEG
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: PUSH
41582: LD_INT 1
41584: PUSH
41585: LD_INT 0
41587: PUSH
41588: EMPTY
41589: LIST
41590: LIST
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: LD_INT 1
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: LD_INT 0
41604: PUSH
41605: LD_INT 1
41607: PUSH
41608: EMPTY
41609: LIST
41610: LIST
41611: PUSH
41612: LD_INT 1
41614: NEG
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: EMPTY
41620: LIST
41621: LIST
41622: PUSH
41623: LD_INT 1
41625: NEG
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: EMPTY
41632: LIST
41633: LIST
41634: PUSH
41635: LD_INT 1
41637: PUSH
41638: LD_INT 2
41640: PUSH
41641: EMPTY
41642: LIST
41643: LIST
41644: PUSH
41645: LD_INT 0
41647: PUSH
41648: LD_INT 2
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 1
41657: NEG
41658: PUSH
41659: LD_INT 1
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 2
41668: NEG
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: EMPTY
41674: LIST
41675: LIST
41676: PUSH
41677: LD_INT 2
41679: NEG
41680: PUSH
41681: LD_INT 1
41683: NEG
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: EMPTY
41690: LIST
41691: LIST
41692: LIST
41693: LIST
41694: LIST
41695: LIST
41696: LIST
41697: LIST
41698: LIST
41699: LIST
41700: LIST
41701: LIST
41702: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41703: LD_ADDR_VAR 0 52
41707: PUSH
41708: LD_INT 0
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 0
41720: PUSH
41721: LD_INT 1
41723: NEG
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 1
41731: PUSH
41732: LD_INT 0
41734: PUSH
41735: EMPTY
41736: LIST
41737: LIST
41738: PUSH
41739: LD_INT 1
41741: PUSH
41742: LD_INT 1
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 0
41751: PUSH
41752: LD_INT 1
41754: PUSH
41755: EMPTY
41756: LIST
41757: LIST
41758: PUSH
41759: LD_INT 1
41761: NEG
41762: PUSH
41763: LD_INT 0
41765: PUSH
41766: EMPTY
41767: LIST
41768: LIST
41769: PUSH
41770: LD_INT 1
41772: NEG
41773: PUSH
41774: LD_INT 1
41776: NEG
41777: PUSH
41778: EMPTY
41779: LIST
41780: LIST
41781: PUSH
41782: LD_INT 1
41784: NEG
41785: PUSH
41786: LD_INT 2
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: LD_INT 1
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 2
41807: NEG
41808: PUSH
41809: LD_INT 0
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 2
41818: NEG
41819: PUSH
41820: LD_INT 1
41822: NEG
41823: PUSH
41824: EMPTY
41825: LIST
41826: LIST
41827: PUSH
41828: LD_INT 2
41830: NEG
41831: PUSH
41832: LD_INT 2
41834: NEG
41835: PUSH
41836: EMPTY
41837: LIST
41838: LIST
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: LIST
41844: LIST
41845: LIST
41846: LIST
41847: LIST
41848: LIST
41849: LIST
41850: LIST
41851: LIST
41852: LIST
41853: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41854: LD_ADDR_VAR 0 53
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: LD_INT 0
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 0
41871: PUSH
41872: LD_INT 1
41874: NEG
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 0
41885: PUSH
41886: EMPTY
41887: LIST
41888: LIST
41889: PUSH
41890: LD_INT 1
41892: PUSH
41893: LD_INT 1
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 0
41902: PUSH
41903: LD_INT 1
41905: PUSH
41906: EMPTY
41907: LIST
41908: LIST
41909: PUSH
41910: LD_INT 1
41912: NEG
41913: PUSH
41914: LD_INT 0
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: PUSH
41921: LD_INT 1
41923: NEG
41924: PUSH
41925: LD_INT 1
41927: NEG
41928: PUSH
41929: EMPTY
41930: LIST
41931: LIST
41932: PUSH
41933: LD_INT 1
41935: NEG
41936: PUSH
41937: LD_INT 2
41939: NEG
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 0
41947: PUSH
41948: LD_INT 2
41950: NEG
41951: PUSH
41952: EMPTY
41953: LIST
41954: LIST
41955: PUSH
41956: LD_INT 1
41958: PUSH
41959: LD_INT 1
41961: NEG
41962: PUSH
41963: EMPTY
41964: LIST
41965: LIST
41966: PUSH
41967: LD_INT 2
41969: PUSH
41970: LD_INT 0
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 2
41979: PUSH
41980: LD_INT 1
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 2
41989: PUSH
41990: LD_INT 2
41992: PUSH
41993: EMPTY
41994: LIST
41995: LIST
41996: PUSH
41997: LD_INT 1
41999: PUSH
42000: LD_INT 2
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: PUSH
42007: LD_INT 0
42009: PUSH
42010: LD_INT 2
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 1
42019: NEG
42020: PUSH
42021: LD_INT 1
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 2
42030: NEG
42031: PUSH
42032: LD_INT 0
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 2
42041: NEG
42042: PUSH
42043: LD_INT 1
42045: NEG
42046: PUSH
42047: EMPTY
42048: LIST
42049: LIST
42050: PUSH
42051: LD_INT 2
42053: NEG
42054: PUSH
42055: LD_INT 2
42057: NEG
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: LIST
42067: LIST
42068: LIST
42069: LIST
42070: LIST
42071: LIST
42072: LIST
42073: LIST
42074: LIST
42075: LIST
42076: LIST
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42084: LD_ADDR_VAR 0 54
42088: PUSH
42089: LD_INT 0
42091: PUSH
42092: LD_INT 0
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: LD_INT 1
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 1
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 1
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 0
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: EMPTY
42137: LIST
42138: LIST
42139: PUSH
42140: LD_INT 1
42142: NEG
42143: PUSH
42144: LD_INT 0
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 1
42153: NEG
42154: PUSH
42155: LD_INT 1
42157: NEG
42158: PUSH
42159: EMPTY
42160: LIST
42161: LIST
42162: PUSH
42163: LD_INT 1
42165: NEG
42166: PUSH
42167: LD_INT 2
42169: NEG
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 0
42177: PUSH
42178: LD_INT 2
42180: NEG
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: PUSH
42186: LD_INT 1
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: EMPTY
42194: LIST
42195: LIST
42196: PUSH
42197: LD_INT 2
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 2
42209: PUSH
42210: LD_INT 1
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: LD_INT 2
42219: PUSH
42220: LD_INT 2
42222: PUSH
42223: EMPTY
42224: LIST
42225: LIST
42226: PUSH
42227: LD_INT 1
42229: PUSH
42230: LD_INT 2
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 0
42239: PUSH
42240: LD_INT 2
42242: PUSH
42243: EMPTY
42244: LIST
42245: LIST
42246: PUSH
42247: LD_INT 1
42249: NEG
42250: PUSH
42251: LD_INT 1
42253: PUSH
42254: EMPTY
42255: LIST
42256: LIST
42257: PUSH
42258: LD_INT 2
42260: NEG
42261: PUSH
42262: LD_INT 0
42264: PUSH
42265: EMPTY
42266: LIST
42267: LIST
42268: PUSH
42269: LD_INT 2
42271: NEG
42272: PUSH
42273: LD_INT 1
42275: NEG
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 2
42283: NEG
42284: PUSH
42285: LD_INT 2
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: EMPTY
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: LIST
42306: LIST
42307: LIST
42308: LIST
42309: LIST
42310: LIST
42311: LIST
42312: LIST
42313: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42314: LD_ADDR_VAR 0 55
42318: PUSH
42319: LD_INT 0
42321: PUSH
42322: LD_INT 0
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 0
42331: PUSH
42332: LD_INT 1
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 1
42342: PUSH
42343: LD_INT 0
42345: PUSH
42346: EMPTY
42347: LIST
42348: LIST
42349: PUSH
42350: LD_INT 1
42352: PUSH
42353: LD_INT 1
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: LD_INT 0
42362: PUSH
42363: LD_INT 1
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 1
42372: NEG
42373: PUSH
42374: LD_INT 0
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: NEG
42384: PUSH
42385: LD_INT 1
42387: NEG
42388: PUSH
42389: EMPTY
42390: LIST
42391: LIST
42392: PUSH
42393: LD_INT 1
42395: NEG
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 0
42407: PUSH
42408: LD_INT 2
42410: NEG
42411: PUSH
42412: EMPTY
42413: LIST
42414: LIST
42415: PUSH
42416: LD_INT 1
42418: PUSH
42419: LD_INT 1
42421: NEG
42422: PUSH
42423: EMPTY
42424: LIST
42425: LIST
42426: PUSH
42427: LD_INT 2
42429: PUSH
42430: LD_INT 0
42432: PUSH
42433: EMPTY
42434: LIST
42435: LIST
42436: PUSH
42437: LD_INT 2
42439: PUSH
42440: LD_INT 1
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PUSH
42447: LD_INT 2
42449: PUSH
42450: LD_INT 2
42452: PUSH
42453: EMPTY
42454: LIST
42455: LIST
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: LD_INT 2
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PUSH
42467: LD_INT 0
42469: PUSH
42470: LD_INT 2
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 1
42479: NEG
42480: PUSH
42481: LD_INT 1
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 2
42490: NEG
42491: PUSH
42492: LD_INT 0
42494: PUSH
42495: EMPTY
42496: LIST
42497: LIST
42498: PUSH
42499: LD_INT 2
42501: NEG
42502: PUSH
42503: LD_INT 1
42505: NEG
42506: PUSH
42507: EMPTY
42508: LIST
42509: LIST
42510: PUSH
42511: LD_INT 2
42513: NEG
42514: PUSH
42515: LD_INT 2
42517: NEG
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: LIST
42530: LIST
42531: LIST
42532: LIST
42533: LIST
42534: LIST
42535: LIST
42536: LIST
42537: LIST
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42544: LD_ADDR_VAR 0 56
42548: PUSH
42549: LD_INT 0
42551: PUSH
42552: LD_INT 0
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 1
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PUSH
42580: LD_INT 1
42582: PUSH
42583: LD_INT 1
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: LD_INT 0
42592: PUSH
42593: LD_INT 1
42595: PUSH
42596: EMPTY
42597: LIST
42598: LIST
42599: PUSH
42600: LD_INT 1
42602: NEG
42603: PUSH
42604: LD_INT 0
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: NEG
42614: PUSH
42615: LD_INT 1
42617: NEG
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 1
42625: NEG
42626: PUSH
42627: LD_INT 2
42629: NEG
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PUSH
42635: LD_INT 0
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 1
42648: PUSH
42649: LD_INT 1
42651: NEG
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: LD_INT 2
42659: PUSH
42660: LD_INT 0
42662: PUSH
42663: EMPTY
42664: LIST
42665: LIST
42666: PUSH
42667: LD_INT 2
42669: PUSH
42670: LD_INT 1
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 2
42679: PUSH
42680: LD_INT 2
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 1
42689: PUSH
42690: LD_INT 2
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 0
42699: PUSH
42700: LD_INT 2
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 1
42709: NEG
42710: PUSH
42711: LD_INT 1
42713: PUSH
42714: EMPTY
42715: LIST
42716: LIST
42717: PUSH
42718: LD_INT 2
42720: NEG
42721: PUSH
42722: LD_INT 0
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: LD_INT 2
42731: NEG
42732: PUSH
42733: LD_INT 1
42735: NEG
42736: PUSH
42737: EMPTY
42738: LIST
42739: LIST
42740: PUSH
42741: LD_INT 2
42743: NEG
42744: PUSH
42745: LD_INT 2
42747: NEG
42748: PUSH
42749: EMPTY
42750: LIST
42751: LIST
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: LIST
42773: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42774: LD_ADDR_VAR 0 57
42778: PUSH
42779: LD_INT 0
42781: PUSH
42782: LD_INT 0
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 0
42791: PUSH
42792: LD_INT 1
42794: NEG
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 1
42802: PUSH
42803: LD_INT 0
42805: PUSH
42806: EMPTY
42807: LIST
42808: LIST
42809: PUSH
42810: LD_INT 1
42812: PUSH
42813: LD_INT 1
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 0
42822: PUSH
42823: LD_INT 1
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: PUSH
42830: LD_INT 1
42832: NEG
42833: PUSH
42834: LD_INT 0
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: PUSH
42841: LD_INT 1
42843: NEG
42844: PUSH
42845: LD_INT 1
42847: NEG
42848: PUSH
42849: EMPTY
42850: LIST
42851: LIST
42852: PUSH
42853: LD_INT 1
42855: NEG
42856: PUSH
42857: LD_INT 2
42859: NEG
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: PUSH
42865: LD_INT 0
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 1
42878: PUSH
42879: LD_INT 1
42881: NEG
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 2
42889: PUSH
42890: LD_INT 0
42892: PUSH
42893: EMPTY
42894: LIST
42895: LIST
42896: PUSH
42897: LD_INT 2
42899: PUSH
42900: LD_INT 1
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: LD_INT 2
42909: PUSH
42910: LD_INT 2
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 1
42919: PUSH
42920: LD_INT 2
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 0
42929: PUSH
42930: LD_INT 2
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: LD_INT 1
42939: NEG
42940: PUSH
42941: LD_INT 1
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 2
42950: NEG
42951: PUSH
42952: LD_INT 0
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 2
42961: NEG
42962: PUSH
42963: LD_INT 1
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: LD_INT 2
42973: NEG
42974: PUSH
42975: LD_INT 2
42977: NEG
42978: PUSH
42979: EMPTY
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: LIST
43000: LIST
43001: LIST
43002: LIST
43003: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43004: LD_ADDR_VAR 0 58
43008: PUSH
43009: LD_INT 0
43011: PUSH
43012: LD_INT 0
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 0
43021: PUSH
43022: LD_INT 1
43024: NEG
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: PUSH
43030: LD_INT 1
43032: PUSH
43033: LD_INT 0
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 1
43042: PUSH
43043: LD_INT 1
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 0
43052: PUSH
43053: LD_INT 1
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 1
43062: NEG
43063: PUSH
43064: LD_INT 0
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 1
43073: NEG
43074: PUSH
43075: LD_INT 1
43077: NEG
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: LD_INT 0
43097: PUSH
43098: LD_INT 2
43100: NEG
43101: PUSH
43102: EMPTY
43103: LIST
43104: LIST
43105: PUSH
43106: LD_INT 1
43108: PUSH
43109: LD_INT 1
43111: NEG
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: PUSH
43117: LD_INT 2
43119: PUSH
43120: LD_INT 0
43122: PUSH
43123: EMPTY
43124: LIST
43125: LIST
43126: PUSH
43127: LD_INT 2
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: LD_INT 2
43139: PUSH
43140: LD_INT 2
43142: PUSH
43143: EMPTY
43144: LIST
43145: LIST
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: LD_INT 2
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 0
43159: PUSH
43160: LD_INT 2
43162: PUSH
43163: EMPTY
43164: LIST
43165: LIST
43166: PUSH
43167: LD_INT 1
43169: NEG
43170: PUSH
43171: LD_INT 1
43173: PUSH
43174: EMPTY
43175: LIST
43176: LIST
43177: PUSH
43178: LD_INT 2
43180: NEG
43181: PUSH
43182: LD_INT 0
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: NEG
43192: PUSH
43193: LD_INT 1
43195: NEG
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 2
43203: NEG
43204: PUSH
43205: LD_INT 2
43207: NEG
43208: PUSH
43209: EMPTY
43210: LIST
43211: LIST
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: LIST
43217: LIST
43218: LIST
43219: LIST
43220: LIST
43221: LIST
43222: LIST
43223: LIST
43224: LIST
43225: LIST
43226: LIST
43227: LIST
43228: LIST
43229: LIST
43230: LIST
43231: LIST
43232: LIST
43233: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43234: LD_ADDR_VAR 0 59
43238: PUSH
43239: LD_INT 0
43241: PUSH
43242: LD_INT 0
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 0
43251: PUSH
43252: LD_INT 1
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 1
43262: PUSH
43263: LD_INT 0
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 1
43272: PUSH
43273: LD_INT 1
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 0
43282: PUSH
43283: LD_INT 1
43285: PUSH
43286: EMPTY
43287: LIST
43288: LIST
43289: PUSH
43290: LD_INT 1
43292: NEG
43293: PUSH
43294: LD_INT 0
43296: PUSH
43297: EMPTY
43298: LIST
43299: LIST
43300: PUSH
43301: LD_INT 1
43303: NEG
43304: PUSH
43305: LD_INT 1
43307: NEG
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: EMPTY
43314: LIST
43315: LIST
43316: LIST
43317: LIST
43318: LIST
43319: LIST
43320: LIST
43321: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43322: LD_ADDR_VAR 0 60
43326: PUSH
43327: LD_INT 0
43329: PUSH
43330: LD_INT 0
43332: PUSH
43333: EMPTY
43334: LIST
43335: LIST
43336: PUSH
43337: LD_INT 0
43339: PUSH
43340: LD_INT 1
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 1
43350: PUSH
43351: LD_INT 0
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: LD_INT 1
43360: PUSH
43361: LD_INT 1
43363: PUSH
43364: EMPTY
43365: LIST
43366: LIST
43367: PUSH
43368: LD_INT 0
43370: PUSH
43371: LD_INT 1
43373: PUSH
43374: EMPTY
43375: LIST
43376: LIST
43377: PUSH
43378: LD_INT 1
43380: NEG
43381: PUSH
43382: LD_INT 0
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 1
43391: NEG
43392: PUSH
43393: LD_INT 1
43395: NEG
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: LIST
43405: LIST
43406: LIST
43407: LIST
43408: LIST
43409: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43410: LD_ADDR_VAR 0 61
43414: PUSH
43415: LD_INT 0
43417: PUSH
43418: LD_INT 0
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: LD_INT 0
43427: PUSH
43428: LD_INT 1
43430: NEG
43431: PUSH
43432: EMPTY
43433: LIST
43434: LIST
43435: PUSH
43436: LD_INT 1
43438: PUSH
43439: LD_INT 0
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 1
43448: PUSH
43449: LD_INT 1
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 0
43458: PUSH
43459: LD_INT 1
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 1
43468: NEG
43469: PUSH
43470: LD_INT 0
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 1
43479: NEG
43480: PUSH
43481: LD_INT 1
43483: NEG
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: LIST
43493: LIST
43494: LIST
43495: LIST
43496: LIST
43497: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43498: LD_ADDR_VAR 0 62
43502: PUSH
43503: LD_INT 0
43505: PUSH
43506: LD_INT 0
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: PUSH
43513: LD_INT 0
43515: PUSH
43516: LD_INT 1
43518: NEG
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 1
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 1
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: LD_INT 0
43546: PUSH
43547: LD_INT 1
43549: PUSH
43550: EMPTY
43551: LIST
43552: LIST
43553: PUSH
43554: LD_INT 1
43556: NEG
43557: PUSH
43558: LD_INT 0
43560: PUSH
43561: EMPTY
43562: LIST
43563: LIST
43564: PUSH
43565: LD_INT 1
43567: NEG
43568: PUSH
43569: LD_INT 1
43571: NEG
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: LIST
43581: LIST
43582: LIST
43583: LIST
43584: LIST
43585: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43586: LD_ADDR_VAR 0 63
43590: PUSH
43591: LD_INT 0
43593: PUSH
43594: LD_INT 0
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 0
43603: PUSH
43604: LD_INT 1
43606: NEG
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 1
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 1
43624: PUSH
43625: LD_INT 1
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 0
43634: PUSH
43635: LD_INT 1
43637: PUSH
43638: EMPTY
43639: LIST
43640: LIST
43641: PUSH
43642: LD_INT 1
43644: NEG
43645: PUSH
43646: LD_INT 0
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 1
43655: NEG
43656: PUSH
43657: LD_INT 1
43659: NEG
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: LIST
43669: LIST
43670: LIST
43671: LIST
43672: LIST
43673: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43674: LD_ADDR_VAR 0 64
43678: PUSH
43679: LD_INT 0
43681: PUSH
43682: LD_INT 0
43684: PUSH
43685: EMPTY
43686: LIST
43687: LIST
43688: PUSH
43689: LD_INT 0
43691: PUSH
43692: LD_INT 1
43694: NEG
43695: PUSH
43696: EMPTY
43697: LIST
43698: LIST
43699: PUSH
43700: LD_INT 1
43702: PUSH
43703: LD_INT 0
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: LD_INT 1
43712: PUSH
43713: LD_INT 1
43715: PUSH
43716: EMPTY
43717: LIST
43718: LIST
43719: PUSH
43720: LD_INT 0
43722: PUSH
43723: LD_INT 1
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 1
43732: NEG
43733: PUSH
43734: LD_INT 0
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 1
43743: NEG
43744: PUSH
43745: LD_INT 1
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: LIST
43757: LIST
43758: LIST
43759: LIST
43760: LIST
43761: ST_TO_ADDR
// end ; 1 :
43762: GO 49659
43764: LD_INT 1
43766: DOUBLE
43767: EQUAL
43768: IFTRUE 43772
43770: GO 46395
43772: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43773: LD_ADDR_VAR 0 11
43777: PUSH
43778: LD_INT 1
43780: NEG
43781: PUSH
43782: LD_INT 3
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: LD_INT 3
43795: NEG
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 1
43803: PUSH
43804: LD_INT 2
43806: NEG
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: EMPTY
43813: LIST
43814: LIST
43815: LIST
43816: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43817: LD_ADDR_VAR 0 12
43821: PUSH
43822: LD_INT 2
43824: PUSH
43825: LD_INT 1
43827: NEG
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 3
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 3
43845: PUSH
43846: LD_INT 1
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: LIST
43857: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43858: LD_ADDR_VAR 0 13
43862: PUSH
43863: LD_INT 3
43865: PUSH
43866: LD_INT 2
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 3
43875: PUSH
43876: LD_INT 3
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: PUSH
43883: LD_INT 2
43885: PUSH
43886: LD_INT 3
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: LIST
43897: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43898: LD_ADDR_VAR 0 14
43902: PUSH
43903: LD_INT 1
43905: PUSH
43906: LD_INT 3
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 0
43915: PUSH
43916: LD_INT 3
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 1
43925: NEG
43926: PUSH
43927: LD_INT 2
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: LIST
43938: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43939: LD_ADDR_VAR 0 15
43943: PUSH
43944: LD_INT 2
43946: NEG
43947: PUSH
43948: LD_INT 1
43950: PUSH
43951: EMPTY
43952: LIST
43953: LIST
43954: PUSH
43955: LD_INT 3
43957: NEG
43958: PUSH
43959: LD_INT 0
43961: PUSH
43962: EMPTY
43963: LIST
43964: LIST
43965: PUSH
43966: LD_INT 3
43968: NEG
43969: PUSH
43970: LD_INT 1
43972: NEG
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: PUSH
43978: EMPTY
43979: LIST
43980: LIST
43981: LIST
43982: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43983: LD_ADDR_VAR 0 16
43987: PUSH
43988: LD_INT 2
43990: NEG
43991: PUSH
43992: LD_INT 3
43994: NEG
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 3
44002: NEG
44003: PUSH
44004: LD_INT 2
44006: NEG
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 3
44014: NEG
44015: PUSH
44016: LD_INT 3
44018: NEG
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: EMPTY
44025: LIST
44026: LIST
44027: LIST
44028: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
44029: LD_ADDR_VAR 0 17
44033: PUSH
44034: LD_INT 1
44036: NEG
44037: PUSH
44038: LD_INT 3
44040: NEG
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 0
44048: PUSH
44049: LD_INT 3
44051: NEG
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 1
44059: PUSH
44060: LD_INT 2
44062: NEG
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: LIST
44072: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
44073: LD_ADDR_VAR 0 18
44077: PUSH
44078: LD_INT 2
44080: PUSH
44081: LD_INT 1
44083: NEG
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: LD_INT 0
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 3
44101: PUSH
44102: LD_INT 1
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: LIST
44113: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
44114: LD_ADDR_VAR 0 19
44118: PUSH
44119: LD_INT 3
44121: PUSH
44122: LD_INT 2
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 3
44131: PUSH
44132: LD_INT 3
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 2
44141: PUSH
44142: LD_INT 3
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: EMPTY
44150: LIST
44151: LIST
44152: LIST
44153: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
44154: LD_ADDR_VAR 0 20
44158: PUSH
44159: LD_INT 1
44161: PUSH
44162: LD_INT 3
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 0
44171: PUSH
44172: LD_INT 3
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 1
44181: NEG
44182: PUSH
44183: LD_INT 2
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: EMPTY
44191: LIST
44192: LIST
44193: LIST
44194: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
44195: LD_ADDR_VAR 0 21
44199: PUSH
44200: LD_INT 2
44202: NEG
44203: PUSH
44204: LD_INT 1
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 3
44213: NEG
44214: PUSH
44215: LD_INT 0
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 3
44224: NEG
44225: PUSH
44226: LD_INT 1
44228: NEG
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: EMPTY
44235: LIST
44236: LIST
44237: LIST
44238: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
44239: LD_ADDR_VAR 0 22
44243: PUSH
44244: LD_INT 2
44246: NEG
44247: PUSH
44248: LD_INT 3
44250: NEG
44251: PUSH
44252: EMPTY
44253: LIST
44254: LIST
44255: PUSH
44256: LD_INT 3
44258: NEG
44259: PUSH
44260: LD_INT 2
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 3
44270: NEG
44271: PUSH
44272: LD_INT 3
44274: NEG
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: LIST
44284: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
44285: LD_ADDR_VAR 0 23
44289: PUSH
44290: LD_INT 0
44292: PUSH
44293: LD_INT 3
44295: NEG
44296: PUSH
44297: EMPTY
44298: LIST
44299: LIST
44300: PUSH
44301: LD_INT 1
44303: NEG
44304: PUSH
44305: LD_INT 4
44307: NEG
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PUSH
44313: LD_INT 1
44315: PUSH
44316: LD_INT 3
44318: NEG
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: EMPTY
44325: LIST
44326: LIST
44327: LIST
44328: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
44329: LD_ADDR_VAR 0 24
44333: PUSH
44334: LD_INT 3
44336: PUSH
44337: LD_INT 0
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 3
44346: PUSH
44347: LD_INT 1
44349: NEG
44350: PUSH
44351: EMPTY
44352: LIST
44353: LIST
44354: PUSH
44355: LD_INT 4
44357: PUSH
44358: LD_INT 1
44360: PUSH
44361: EMPTY
44362: LIST
44363: LIST
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: LIST
44369: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44370: LD_ADDR_VAR 0 25
44374: PUSH
44375: LD_INT 3
44377: PUSH
44378: LD_INT 3
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 4
44387: PUSH
44388: LD_INT 3
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 3
44397: PUSH
44398: LD_INT 4
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: LIST
44409: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44410: LD_ADDR_VAR 0 26
44414: PUSH
44415: LD_INT 0
44417: PUSH
44418: LD_INT 3
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 1
44427: PUSH
44428: LD_INT 4
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 1
44437: NEG
44438: PUSH
44439: LD_INT 3
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: LIST
44450: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44451: LD_ADDR_VAR 0 27
44455: PUSH
44456: LD_INT 3
44458: NEG
44459: PUSH
44460: LD_INT 0
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PUSH
44467: LD_INT 3
44469: NEG
44470: PUSH
44471: LD_INT 1
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 4
44480: NEG
44481: PUSH
44482: LD_INT 1
44484: NEG
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: LIST
44494: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44495: LD_ADDR_VAR 0 28
44499: PUSH
44500: LD_INT 3
44502: NEG
44503: PUSH
44504: LD_INT 3
44506: NEG
44507: PUSH
44508: EMPTY
44509: LIST
44510: LIST
44511: PUSH
44512: LD_INT 3
44514: NEG
44515: PUSH
44516: LD_INT 4
44518: NEG
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 4
44526: NEG
44527: PUSH
44528: LD_INT 3
44530: NEG
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: LIST
44540: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44541: LD_ADDR_VAR 0 29
44545: PUSH
44546: LD_INT 1
44548: NEG
44549: PUSH
44550: LD_INT 3
44552: NEG
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 0
44560: PUSH
44561: LD_INT 3
44563: NEG
44564: PUSH
44565: EMPTY
44566: LIST
44567: LIST
44568: PUSH
44569: LD_INT 1
44571: PUSH
44572: LD_INT 2
44574: NEG
44575: PUSH
44576: EMPTY
44577: LIST
44578: LIST
44579: PUSH
44580: LD_INT 1
44582: NEG
44583: PUSH
44584: LD_INT 4
44586: NEG
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 0
44594: PUSH
44595: LD_INT 4
44597: NEG
44598: PUSH
44599: EMPTY
44600: LIST
44601: LIST
44602: PUSH
44603: LD_INT 1
44605: PUSH
44606: LD_INT 3
44608: NEG
44609: PUSH
44610: EMPTY
44611: LIST
44612: LIST
44613: PUSH
44614: LD_INT 1
44616: NEG
44617: PUSH
44618: LD_INT 5
44620: NEG
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 0
44628: PUSH
44629: LD_INT 5
44631: NEG
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: PUSH
44640: LD_INT 4
44642: NEG
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 1
44650: NEG
44651: PUSH
44652: LD_INT 6
44654: NEG
44655: PUSH
44656: EMPTY
44657: LIST
44658: LIST
44659: PUSH
44660: LD_INT 0
44662: PUSH
44663: LD_INT 6
44665: NEG
44666: PUSH
44667: EMPTY
44668: LIST
44669: LIST
44670: PUSH
44671: LD_INT 1
44673: PUSH
44674: LD_INT 5
44676: NEG
44677: PUSH
44678: EMPTY
44679: LIST
44680: LIST
44681: PUSH
44682: EMPTY
44683: LIST
44684: LIST
44685: LIST
44686: LIST
44687: LIST
44688: LIST
44689: LIST
44690: LIST
44691: LIST
44692: LIST
44693: LIST
44694: LIST
44695: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44696: LD_ADDR_VAR 0 30
44700: PUSH
44701: LD_INT 2
44703: PUSH
44704: LD_INT 1
44706: NEG
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 3
44714: PUSH
44715: LD_INT 0
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 3
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 3
44734: PUSH
44735: LD_INT 1
44737: NEG
44738: PUSH
44739: EMPTY
44740: LIST
44741: LIST
44742: PUSH
44743: LD_INT 4
44745: PUSH
44746: LD_INT 0
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 4
44755: PUSH
44756: LD_INT 1
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: LD_INT 1
44768: NEG
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: LD_INT 5
44776: PUSH
44777: LD_INT 0
44779: PUSH
44780: EMPTY
44781: LIST
44782: LIST
44783: PUSH
44784: LD_INT 5
44786: PUSH
44787: LD_INT 1
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 5
44796: PUSH
44797: LD_INT 1
44799: NEG
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: PUSH
44805: LD_INT 6
44807: PUSH
44808: LD_INT 0
44810: PUSH
44811: EMPTY
44812: LIST
44813: LIST
44814: PUSH
44815: LD_INT 6
44817: PUSH
44818: LD_INT 1
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: LIST
44829: LIST
44830: LIST
44831: LIST
44832: LIST
44833: LIST
44834: LIST
44835: LIST
44836: LIST
44837: LIST
44838: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44839: LD_ADDR_VAR 0 31
44843: PUSH
44844: LD_INT 3
44846: PUSH
44847: LD_INT 2
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 3
44856: PUSH
44857: LD_INT 3
44859: PUSH
44860: EMPTY
44861: LIST
44862: LIST
44863: PUSH
44864: LD_INT 2
44866: PUSH
44867: LD_INT 3
44869: PUSH
44870: EMPTY
44871: LIST
44872: LIST
44873: PUSH
44874: LD_INT 4
44876: PUSH
44877: LD_INT 3
44879: PUSH
44880: EMPTY
44881: LIST
44882: LIST
44883: PUSH
44884: LD_INT 4
44886: PUSH
44887: LD_INT 4
44889: PUSH
44890: EMPTY
44891: LIST
44892: LIST
44893: PUSH
44894: LD_INT 3
44896: PUSH
44897: LD_INT 4
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 5
44906: PUSH
44907: LD_INT 4
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 5
44916: PUSH
44917: LD_INT 5
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 4
44926: PUSH
44927: LD_INT 5
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 6
44936: PUSH
44937: LD_INT 5
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 6
44946: PUSH
44947: LD_INT 6
44949: PUSH
44950: EMPTY
44951: LIST
44952: LIST
44953: PUSH
44954: LD_INT 5
44956: PUSH
44957: LD_INT 6
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: EMPTY
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: LIST
44970: LIST
44971: LIST
44972: LIST
44973: LIST
44974: LIST
44975: LIST
44976: LIST
44977: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44978: LD_ADDR_VAR 0 32
44982: PUSH
44983: LD_INT 1
44985: PUSH
44986: LD_INT 3
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 0
44995: PUSH
44996: LD_INT 3
44998: PUSH
44999: EMPTY
45000: LIST
45001: LIST
45002: PUSH
45003: LD_INT 1
45005: NEG
45006: PUSH
45007: LD_INT 2
45009: PUSH
45010: EMPTY
45011: LIST
45012: LIST
45013: PUSH
45014: LD_INT 1
45016: PUSH
45017: LD_INT 4
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 0
45026: PUSH
45027: LD_INT 4
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 1
45036: NEG
45037: PUSH
45038: LD_INT 3
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 1
45047: PUSH
45048: LD_INT 5
45050: PUSH
45051: EMPTY
45052: LIST
45053: LIST
45054: PUSH
45055: LD_INT 0
45057: PUSH
45058: LD_INT 5
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 1
45067: NEG
45068: PUSH
45069: LD_INT 4
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 1
45078: PUSH
45079: LD_INT 6
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 0
45088: PUSH
45089: LD_INT 6
45091: PUSH
45092: EMPTY
45093: LIST
45094: LIST
45095: PUSH
45096: LD_INT 1
45098: NEG
45099: PUSH
45100: LD_INT 5
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: EMPTY
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
45121: LD_ADDR_VAR 0 33
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: LD_INT 1
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 3
45150: NEG
45151: PUSH
45152: LD_INT 1
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 3
45162: NEG
45163: PUSH
45164: LD_INT 1
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 4
45173: NEG
45174: PUSH
45175: LD_INT 0
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: LD_INT 4
45184: NEG
45185: PUSH
45186: LD_INT 1
45188: NEG
45189: PUSH
45190: EMPTY
45191: LIST
45192: LIST
45193: PUSH
45194: LD_INT 4
45196: NEG
45197: PUSH
45198: LD_INT 1
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 5
45207: NEG
45208: PUSH
45209: LD_INT 0
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 5
45218: NEG
45219: PUSH
45220: LD_INT 1
45222: NEG
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 5
45230: NEG
45231: PUSH
45232: LD_INT 1
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 6
45241: NEG
45242: PUSH
45243: LD_INT 0
45245: PUSH
45246: EMPTY
45247: LIST
45248: LIST
45249: PUSH
45250: LD_INT 6
45252: NEG
45253: PUSH
45254: LD_INT 1
45256: NEG
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: LIST
45272: LIST
45273: LIST
45274: LIST
45275: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
45276: LD_ADDR_VAR 0 34
45280: PUSH
45281: LD_INT 2
45283: NEG
45284: PUSH
45285: LD_INT 3
45287: NEG
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: NEG
45296: PUSH
45297: LD_INT 2
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 3
45307: NEG
45308: PUSH
45309: LD_INT 3
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: NEG
45320: PUSH
45321: LD_INT 4
45323: NEG
45324: PUSH
45325: EMPTY
45326: LIST
45327: LIST
45328: PUSH
45329: LD_INT 4
45331: NEG
45332: PUSH
45333: LD_INT 3
45335: NEG
45336: PUSH
45337: EMPTY
45338: LIST
45339: LIST
45340: PUSH
45341: LD_INT 4
45343: NEG
45344: PUSH
45345: LD_INT 4
45347: NEG
45348: PUSH
45349: EMPTY
45350: LIST
45351: LIST
45352: PUSH
45353: LD_INT 4
45355: NEG
45356: PUSH
45357: LD_INT 5
45359: NEG
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PUSH
45365: LD_INT 5
45367: NEG
45368: PUSH
45369: LD_INT 4
45371: NEG
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 5
45379: NEG
45380: PUSH
45381: LD_INT 5
45383: NEG
45384: PUSH
45385: EMPTY
45386: LIST
45387: LIST
45388: PUSH
45389: LD_INT 5
45391: NEG
45392: PUSH
45393: LD_INT 6
45395: NEG
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 6
45403: NEG
45404: PUSH
45405: LD_INT 5
45407: NEG
45408: PUSH
45409: EMPTY
45410: LIST
45411: LIST
45412: PUSH
45413: LD_INT 6
45415: NEG
45416: PUSH
45417: LD_INT 6
45419: NEG
45420: PUSH
45421: EMPTY
45422: LIST
45423: LIST
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: LIST
45429: LIST
45430: LIST
45431: LIST
45432: LIST
45433: LIST
45434: LIST
45435: LIST
45436: LIST
45437: LIST
45438: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45439: LD_ADDR_VAR 0 41
45443: PUSH
45444: LD_INT 0
45446: PUSH
45447: LD_INT 2
45449: NEG
45450: PUSH
45451: EMPTY
45452: LIST
45453: LIST
45454: PUSH
45455: LD_INT 1
45457: NEG
45458: PUSH
45459: LD_INT 3
45461: NEG
45462: PUSH
45463: EMPTY
45464: LIST
45465: LIST
45466: PUSH
45467: LD_INT 1
45469: PUSH
45470: LD_INT 2
45472: NEG
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: LIST
45482: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45483: LD_ADDR_VAR 0 42
45487: PUSH
45488: LD_INT 2
45490: PUSH
45491: LD_INT 0
45493: PUSH
45494: EMPTY
45495: LIST
45496: LIST
45497: PUSH
45498: LD_INT 2
45500: PUSH
45501: LD_INT 1
45503: NEG
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 3
45511: PUSH
45512: LD_INT 1
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: LIST
45523: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45524: LD_ADDR_VAR 0 43
45528: PUSH
45529: LD_INT 2
45531: PUSH
45532: LD_INT 2
45534: PUSH
45535: EMPTY
45536: LIST
45537: LIST
45538: PUSH
45539: LD_INT 3
45541: PUSH
45542: LD_INT 2
45544: PUSH
45545: EMPTY
45546: LIST
45547: LIST
45548: PUSH
45549: LD_INT 2
45551: PUSH
45552: LD_INT 3
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: EMPTY
45560: LIST
45561: LIST
45562: LIST
45563: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45564: LD_ADDR_VAR 0 44
45568: PUSH
45569: LD_INT 0
45571: PUSH
45572: LD_INT 2
45574: PUSH
45575: EMPTY
45576: LIST
45577: LIST
45578: PUSH
45579: LD_INT 1
45581: PUSH
45582: LD_INT 3
45584: PUSH
45585: EMPTY
45586: LIST
45587: LIST
45588: PUSH
45589: LD_INT 1
45591: NEG
45592: PUSH
45593: LD_INT 2
45595: PUSH
45596: EMPTY
45597: LIST
45598: LIST
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: LIST
45604: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45605: LD_ADDR_VAR 0 45
45609: PUSH
45610: LD_INT 2
45612: NEG
45613: PUSH
45614: LD_INT 0
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 2
45623: NEG
45624: PUSH
45625: LD_INT 1
45627: PUSH
45628: EMPTY
45629: LIST
45630: LIST
45631: PUSH
45632: LD_INT 3
45634: NEG
45635: PUSH
45636: LD_INT 1
45638: NEG
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: LIST
45648: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45649: LD_ADDR_VAR 0 46
45653: PUSH
45654: LD_INT 2
45656: NEG
45657: PUSH
45658: LD_INT 2
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 2
45668: NEG
45669: PUSH
45670: LD_INT 3
45672: NEG
45673: PUSH
45674: EMPTY
45675: LIST
45676: LIST
45677: PUSH
45678: LD_INT 3
45680: NEG
45681: PUSH
45682: LD_INT 2
45684: NEG
45685: PUSH
45686: EMPTY
45687: LIST
45688: LIST
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: LIST
45694: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45695: LD_ADDR_VAR 0 47
45699: PUSH
45700: LD_INT 2
45702: NEG
45703: PUSH
45704: LD_INT 3
45706: NEG
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PUSH
45712: LD_INT 1
45714: NEG
45715: PUSH
45716: LD_INT 3
45718: NEG
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45728: LD_ADDR_VAR 0 48
45732: PUSH
45733: LD_INT 1
45735: PUSH
45736: LD_INT 2
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: PUSH
45747: LD_INT 1
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45759: LD_ADDR_VAR 0 49
45763: PUSH
45764: LD_INT 3
45766: PUSH
45767: LD_INT 1
45769: PUSH
45770: EMPTY
45771: LIST
45772: LIST
45773: PUSH
45774: LD_INT 3
45776: PUSH
45777: LD_INT 2
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45788: LD_ADDR_VAR 0 50
45792: PUSH
45793: LD_INT 2
45795: PUSH
45796: LD_INT 3
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 1
45805: PUSH
45806: LD_INT 3
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: PUSH
45813: EMPTY
45814: LIST
45815: LIST
45816: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45817: LD_ADDR_VAR 0 51
45821: PUSH
45822: LD_INT 1
45824: NEG
45825: PUSH
45826: LD_INT 2
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 2
45835: NEG
45836: PUSH
45837: LD_INT 1
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45848: LD_ADDR_VAR 0 52
45852: PUSH
45853: LD_INT 3
45855: NEG
45856: PUSH
45857: LD_INT 1
45859: NEG
45860: PUSH
45861: EMPTY
45862: LIST
45863: LIST
45864: PUSH
45865: LD_INT 3
45867: NEG
45868: PUSH
45869: LD_INT 2
45871: NEG
45872: PUSH
45873: EMPTY
45874: LIST
45875: LIST
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45881: LD_ADDR_VAR 0 53
45885: PUSH
45886: LD_INT 1
45888: NEG
45889: PUSH
45890: LD_INT 3
45892: NEG
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: PUSH
45898: LD_INT 0
45900: PUSH
45901: LD_INT 3
45903: NEG
45904: PUSH
45905: EMPTY
45906: LIST
45907: LIST
45908: PUSH
45909: LD_INT 1
45911: PUSH
45912: LD_INT 2
45914: NEG
45915: PUSH
45916: EMPTY
45917: LIST
45918: LIST
45919: PUSH
45920: EMPTY
45921: LIST
45922: LIST
45923: LIST
45924: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45925: LD_ADDR_VAR 0 54
45929: PUSH
45930: LD_INT 2
45932: PUSH
45933: LD_INT 1
45935: NEG
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: PUSH
45941: LD_INT 3
45943: PUSH
45944: LD_INT 0
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 3
45953: PUSH
45954: LD_INT 1
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: LIST
45965: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45966: LD_ADDR_VAR 0 55
45970: PUSH
45971: LD_INT 3
45973: PUSH
45974: LD_INT 2
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 3
45983: PUSH
45984: LD_INT 3
45986: PUSH
45987: EMPTY
45988: LIST
45989: LIST
45990: PUSH
45991: LD_INT 2
45993: PUSH
45994: LD_INT 3
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: EMPTY
46002: LIST
46003: LIST
46004: LIST
46005: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
46006: LD_ADDR_VAR 0 56
46010: PUSH
46011: LD_INT 1
46013: PUSH
46014: LD_INT 3
46016: PUSH
46017: EMPTY
46018: LIST
46019: LIST
46020: PUSH
46021: LD_INT 0
46023: PUSH
46024: LD_INT 3
46026: PUSH
46027: EMPTY
46028: LIST
46029: LIST
46030: PUSH
46031: LD_INT 1
46033: NEG
46034: PUSH
46035: LD_INT 2
46037: PUSH
46038: EMPTY
46039: LIST
46040: LIST
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: LIST
46046: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
46047: LD_ADDR_VAR 0 57
46051: PUSH
46052: LD_INT 2
46054: NEG
46055: PUSH
46056: LD_INT 1
46058: PUSH
46059: EMPTY
46060: LIST
46061: LIST
46062: PUSH
46063: LD_INT 3
46065: NEG
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 3
46076: NEG
46077: PUSH
46078: LD_INT 1
46080: NEG
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: EMPTY
46087: LIST
46088: LIST
46089: LIST
46090: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
46091: LD_ADDR_VAR 0 58
46095: PUSH
46096: LD_INT 2
46098: NEG
46099: PUSH
46100: LD_INT 3
46102: NEG
46103: PUSH
46104: EMPTY
46105: LIST
46106: LIST
46107: PUSH
46108: LD_INT 3
46110: NEG
46111: PUSH
46112: LD_INT 2
46114: NEG
46115: PUSH
46116: EMPTY
46117: LIST
46118: LIST
46119: PUSH
46120: LD_INT 3
46122: NEG
46123: PUSH
46124: LD_INT 3
46126: NEG
46127: PUSH
46128: EMPTY
46129: LIST
46130: LIST
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: LIST
46136: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
46137: LD_ADDR_VAR 0 59
46141: PUSH
46142: LD_INT 1
46144: NEG
46145: PUSH
46146: LD_INT 2
46148: NEG
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: LD_INT 0
46156: PUSH
46157: LD_INT 2
46159: NEG
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 1
46167: PUSH
46168: LD_INT 1
46170: NEG
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: LIST
46180: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
46181: LD_ADDR_VAR 0 60
46185: PUSH
46186: LD_INT 1
46188: PUSH
46189: LD_INT 1
46191: NEG
46192: PUSH
46193: EMPTY
46194: LIST
46195: LIST
46196: PUSH
46197: LD_INT 2
46199: PUSH
46200: LD_INT 0
46202: PUSH
46203: EMPTY
46204: LIST
46205: LIST
46206: PUSH
46207: LD_INT 2
46209: PUSH
46210: LD_INT 1
46212: PUSH
46213: EMPTY
46214: LIST
46215: LIST
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: LIST
46221: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
46222: LD_ADDR_VAR 0 61
46226: PUSH
46227: LD_INT 2
46229: PUSH
46230: LD_INT 1
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: PUSH
46237: LD_INT 2
46239: PUSH
46240: LD_INT 2
46242: PUSH
46243: EMPTY
46244: LIST
46245: LIST
46246: PUSH
46247: LD_INT 1
46249: PUSH
46250: LD_INT 2
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: LIST
46261: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
46262: LD_ADDR_VAR 0 62
46266: PUSH
46267: LD_INT 1
46269: PUSH
46270: LD_INT 2
46272: PUSH
46273: EMPTY
46274: LIST
46275: LIST
46276: PUSH
46277: LD_INT 0
46279: PUSH
46280: LD_INT 2
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 1
46289: NEG
46290: PUSH
46291: LD_INT 1
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: EMPTY
46299: LIST
46300: LIST
46301: LIST
46302: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
46303: LD_ADDR_VAR 0 63
46307: PUSH
46308: LD_INT 1
46310: NEG
46311: PUSH
46312: LD_INT 1
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 2
46321: NEG
46322: PUSH
46323: LD_INT 0
46325: PUSH
46326: EMPTY
46327: LIST
46328: LIST
46329: PUSH
46330: LD_INT 2
46332: NEG
46333: PUSH
46334: LD_INT 1
46336: NEG
46337: PUSH
46338: EMPTY
46339: LIST
46340: LIST
46341: PUSH
46342: EMPTY
46343: LIST
46344: LIST
46345: LIST
46346: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46347: LD_ADDR_VAR 0 64
46351: PUSH
46352: LD_INT 1
46354: NEG
46355: PUSH
46356: LD_INT 2
46358: NEG
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 2
46366: NEG
46367: PUSH
46368: LD_INT 1
46370: NEG
46371: PUSH
46372: EMPTY
46373: LIST
46374: LIST
46375: PUSH
46376: LD_INT 2
46378: NEG
46379: PUSH
46380: LD_INT 2
46382: NEG
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: LIST
46392: ST_TO_ADDR
// end ; 2 :
46393: GO 49659
46395: LD_INT 2
46397: DOUBLE
46398: EQUAL
46399: IFTRUE 46403
46401: GO 49658
46403: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46404: LD_ADDR_VAR 0 29
46408: PUSH
46409: LD_INT 4
46411: PUSH
46412: LD_INT 0
46414: PUSH
46415: EMPTY
46416: LIST
46417: LIST
46418: PUSH
46419: LD_INT 4
46421: PUSH
46422: LD_INT 1
46424: NEG
46425: PUSH
46426: EMPTY
46427: LIST
46428: LIST
46429: PUSH
46430: LD_INT 5
46432: PUSH
46433: LD_INT 0
46435: PUSH
46436: EMPTY
46437: LIST
46438: LIST
46439: PUSH
46440: LD_INT 5
46442: PUSH
46443: LD_INT 1
46445: PUSH
46446: EMPTY
46447: LIST
46448: LIST
46449: PUSH
46450: LD_INT 4
46452: PUSH
46453: LD_INT 1
46455: PUSH
46456: EMPTY
46457: LIST
46458: LIST
46459: PUSH
46460: LD_INT 3
46462: PUSH
46463: LD_INT 0
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 3
46472: PUSH
46473: LD_INT 1
46475: NEG
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 3
46483: PUSH
46484: LD_INT 2
46486: NEG
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 5
46494: PUSH
46495: LD_INT 2
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 3
46504: PUSH
46505: LD_INT 3
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 3
46514: PUSH
46515: LD_INT 2
46517: PUSH
46518: EMPTY
46519: LIST
46520: LIST
46521: PUSH
46522: LD_INT 4
46524: PUSH
46525: LD_INT 3
46527: PUSH
46528: EMPTY
46529: LIST
46530: LIST
46531: PUSH
46532: LD_INT 4
46534: PUSH
46535: LD_INT 4
46537: PUSH
46538: EMPTY
46539: LIST
46540: LIST
46541: PUSH
46542: LD_INT 3
46544: PUSH
46545: LD_INT 4
46547: PUSH
46548: EMPTY
46549: LIST
46550: LIST
46551: PUSH
46552: LD_INT 2
46554: PUSH
46555: LD_INT 3
46557: PUSH
46558: EMPTY
46559: LIST
46560: LIST
46561: PUSH
46562: LD_INT 2
46564: PUSH
46565: LD_INT 2
46567: PUSH
46568: EMPTY
46569: LIST
46570: LIST
46571: PUSH
46572: LD_INT 4
46574: PUSH
46575: LD_INT 2
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 2
46584: PUSH
46585: LD_INT 4
46587: PUSH
46588: EMPTY
46589: LIST
46590: LIST
46591: PUSH
46592: LD_INT 0
46594: PUSH
46595: LD_INT 4
46597: PUSH
46598: EMPTY
46599: LIST
46600: LIST
46601: PUSH
46602: LD_INT 0
46604: PUSH
46605: LD_INT 3
46607: PUSH
46608: EMPTY
46609: LIST
46610: LIST
46611: PUSH
46612: LD_INT 1
46614: PUSH
46615: LD_INT 4
46617: PUSH
46618: EMPTY
46619: LIST
46620: LIST
46621: PUSH
46622: LD_INT 1
46624: PUSH
46625: LD_INT 5
46627: PUSH
46628: EMPTY
46629: LIST
46630: LIST
46631: PUSH
46632: LD_INT 0
46634: PUSH
46635: LD_INT 5
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_INT 1
46644: NEG
46645: PUSH
46646: LD_INT 4
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 1
46655: NEG
46656: PUSH
46657: LD_INT 3
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: LD_INT 2
46666: PUSH
46667: LD_INT 5
46669: PUSH
46670: EMPTY
46671: LIST
46672: LIST
46673: PUSH
46674: LD_INT 2
46676: NEG
46677: PUSH
46678: LD_INT 3
46680: PUSH
46681: EMPTY
46682: LIST
46683: LIST
46684: PUSH
46685: LD_INT 3
46687: NEG
46688: PUSH
46689: LD_INT 0
46691: PUSH
46692: EMPTY
46693: LIST
46694: LIST
46695: PUSH
46696: LD_INT 3
46698: NEG
46699: PUSH
46700: LD_INT 1
46702: NEG
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 2
46710: NEG
46711: PUSH
46712: LD_INT 0
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 2
46721: NEG
46722: PUSH
46723: LD_INT 1
46725: PUSH
46726: EMPTY
46727: LIST
46728: LIST
46729: PUSH
46730: LD_INT 3
46732: NEG
46733: PUSH
46734: LD_INT 1
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PUSH
46741: LD_INT 4
46743: NEG
46744: PUSH
46745: LD_INT 0
46747: PUSH
46748: EMPTY
46749: LIST
46750: LIST
46751: PUSH
46752: LD_INT 4
46754: NEG
46755: PUSH
46756: LD_INT 1
46758: NEG
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: PUSH
46764: LD_INT 4
46766: NEG
46767: PUSH
46768: LD_INT 2
46770: NEG
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PUSH
46776: LD_INT 2
46778: NEG
46779: PUSH
46780: LD_INT 2
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: PUSH
46787: LD_INT 4
46789: NEG
46790: PUSH
46791: LD_INT 4
46793: NEG
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PUSH
46799: LD_INT 4
46801: NEG
46802: PUSH
46803: LD_INT 5
46805: NEG
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 3
46813: NEG
46814: PUSH
46815: LD_INT 4
46817: NEG
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 3
46825: NEG
46826: PUSH
46827: LD_INT 3
46829: NEG
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 4
46837: NEG
46838: PUSH
46839: LD_INT 3
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 5
46849: NEG
46850: PUSH
46851: LD_INT 4
46853: NEG
46854: PUSH
46855: EMPTY
46856: LIST
46857: LIST
46858: PUSH
46859: LD_INT 5
46861: NEG
46862: PUSH
46863: LD_INT 5
46865: NEG
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 3
46873: NEG
46874: PUSH
46875: LD_INT 5
46877: NEG
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: PUSH
46883: LD_INT 5
46885: NEG
46886: PUSH
46887: LD_INT 3
46889: NEG
46890: PUSH
46891: EMPTY
46892: LIST
46893: LIST
46894: PUSH
46895: EMPTY
46896: LIST
46897: LIST
46898: LIST
46899: LIST
46900: LIST
46901: LIST
46902: LIST
46903: LIST
46904: LIST
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: LIST
46912: LIST
46913: LIST
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: LIST
46921: LIST
46922: LIST
46923: LIST
46924: LIST
46925: LIST
46926: LIST
46927: LIST
46928: LIST
46929: LIST
46930: LIST
46931: LIST
46932: LIST
46933: LIST
46934: LIST
46935: LIST
46936: LIST
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46942: LD_ADDR_VAR 0 30
46946: PUSH
46947: LD_INT 4
46949: PUSH
46950: LD_INT 4
46952: PUSH
46953: EMPTY
46954: LIST
46955: LIST
46956: PUSH
46957: LD_INT 4
46959: PUSH
46960: LD_INT 3
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: PUSH
46967: LD_INT 5
46969: PUSH
46970: LD_INT 4
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PUSH
46977: LD_INT 5
46979: PUSH
46980: LD_INT 5
46982: PUSH
46983: EMPTY
46984: LIST
46985: LIST
46986: PUSH
46987: LD_INT 4
46989: PUSH
46990: LD_INT 5
46992: PUSH
46993: EMPTY
46994: LIST
46995: LIST
46996: PUSH
46997: LD_INT 3
46999: PUSH
47000: LD_INT 4
47002: PUSH
47003: EMPTY
47004: LIST
47005: LIST
47006: PUSH
47007: LD_INT 3
47009: PUSH
47010: LD_INT 3
47012: PUSH
47013: EMPTY
47014: LIST
47015: LIST
47016: PUSH
47017: LD_INT 5
47019: PUSH
47020: LD_INT 3
47022: PUSH
47023: EMPTY
47024: LIST
47025: LIST
47026: PUSH
47027: LD_INT 3
47029: PUSH
47030: LD_INT 5
47032: PUSH
47033: EMPTY
47034: LIST
47035: LIST
47036: PUSH
47037: LD_INT 0
47039: PUSH
47040: LD_INT 3
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: PUSH
47047: LD_INT 0
47049: PUSH
47050: LD_INT 2
47052: PUSH
47053: EMPTY
47054: LIST
47055: LIST
47056: PUSH
47057: LD_INT 1
47059: PUSH
47060: LD_INT 3
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 1
47069: PUSH
47070: LD_INT 4
47072: PUSH
47073: EMPTY
47074: LIST
47075: LIST
47076: PUSH
47077: LD_INT 0
47079: PUSH
47080: LD_INT 4
47082: PUSH
47083: EMPTY
47084: LIST
47085: LIST
47086: PUSH
47087: LD_INT 1
47089: NEG
47090: PUSH
47091: LD_INT 3
47093: PUSH
47094: EMPTY
47095: LIST
47096: LIST
47097: PUSH
47098: LD_INT 1
47100: NEG
47101: PUSH
47102: LD_INT 2
47104: PUSH
47105: EMPTY
47106: LIST
47107: LIST
47108: PUSH
47109: LD_INT 2
47111: PUSH
47112: LD_INT 4
47114: PUSH
47115: EMPTY
47116: LIST
47117: LIST
47118: PUSH
47119: LD_INT 2
47121: NEG
47122: PUSH
47123: LD_INT 2
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: PUSH
47130: LD_INT 4
47132: NEG
47133: PUSH
47134: LD_INT 0
47136: PUSH
47137: EMPTY
47138: LIST
47139: LIST
47140: PUSH
47141: LD_INT 4
47143: NEG
47144: PUSH
47145: LD_INT 1
47147: NEG
47148: PUSH
47149: EMPTY
47150: LIST
47151: LIST
47152: PUSH
47153: LD_INT 3
47155: NEG
47156: PUSH
47157: LD_INT 0
47159: PUSH
47160: EMPTY
47161: LIST
47162: LIST
47163: PUSH
47164: LD_INT 3
47166: NEG
47167: PUSH
47168: LD_INT 1
47170: PUSH
47171: EMPTY
47172: LIST
47173: LIST
47174: PUSH
47175: LD_INT 4
47177: NEG
47178: PUSH
47179: LD_INT 1
47181: PUSH
47182: EMPTY
47183: LIST
47184: LIST
47185: PUSH
47186: LD_INT 5
47188: NEG
47189: PUSH
47190: LD_INT 0
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: PUSH
47197: LD_INT 5
47199: NEG
47200: PUSH
47201: LD_INT 1
47203: NEG
47204: PUSH
47205: EMPTY
47206: LIST
47207: LIST
47208: PUSH
47209: LD_INT 5
47211: NEG
47212: PUSH
47213: LD_INT 2
47215: NEG
47216: PUSH
47217: EMPTY
47218: LIST
47219: LIST
47220: PUSH
47221: LD_INT 3
47223: NEG
47224: PUSH
47225: LD_INT 2
47227: PUSH
47228: EMPTY
47229: LIST
47230: LIST
47231: PUSH
47232: LD_INT 3
47234: NEG
47235: PUSH
47236: LD_INT 3
47238: NEG
47239: PUSH
47240: EMPTY
47241: LIST
47242: LIST
47243: PUSH
47244: LD_INT 3
47246: NEG
47247: PUSH
47248: LD_INT 4
47250: NEG
47251: PUSH
47252: EMPTY
47253: LIST
47254: LIST
47255: PUSH
47256: LD_INT 2
47258: NEG
47259: PUSH
47260: LD_INT 3
47262: NEG
47263: PUSH
47264: EMPTY
47265: LIST
47266: LIST
47267: PUSH
47268: LD_INT 2
47270: NEG
47271: PUSH
47272: LD_INT 2
47274: NEG
47275: PUSH
47276: EMPTY
47277: LIST
47278: LIST
47279: PUSH
47280: LD_INT 3
47282: NEG
47283: PUSH
47284: LD_INT 2
47286: NEG
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PUSH
47292: LD_INT 4
47294: NEG
47295: PUSH
47296: LD_INT 3
47298: NEG
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 4
47306: NEG
47307: PUSH
47308: LD_INT 4
47310: NEG
47311: PUSH
47312: EMPTY
47313: LIST
47314: LIST
47315: PUSH
47316: LD_INT 2
47318: NEG
47319: PUSH
47320: LD_INT 4
47322: NEG
47323: PUSH
47324: EMPTY
47325: LIST
47326: LIST
47327: PUSH
47328: LD_INT 4
47330: NEG
47331: PUSH
47332: LD_INT 2
47334: NEG
47335: PUSH
47336: EMPTY
47337: LIST
47338: LIST
47339: PUSH
47340: LD_INT 0
47342: PUSH
47343: LD_INT 4
47345: NEG
47346: PUSH
47347: EMPTY
47348: LIST
47349: LIST
47350: PUSH
47351: LD_INT 0
47353: PUSH
47354: LD_INT 5
47356: NEG
47357: PUSH
47358: EMPTY
47359: LIST
47360: LIST
47361: PUSH
47362: LD_INT 1
47364: PUSH
47365: LD_INT 4
47367: NEG
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: PUSH
47373: LD_INT 1
47375: PUSH
47376: LD_INT 3
47378: NEG
47379: PUSH
47380: EMPTY
47381: LIST
47382: LIST
47383: PUSH
47384: LD_INT 0
47386: PUSH
47387: LD_INT 3
47389: NEG
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 1
47397: NEG
47398: PUSH
47399: LD_INT 4
47401: NEG
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 1
47409: NEG
47410: PUSH
47411: LD_INT 5
47413: NEG
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: PUSH
47419: LD_INT 2
47421: PUSH
47422: LD_INT 3
47424: NEG
47425: PUSH
47426: EMPTY
47427: LIST
47428: LIST
47429: PUSH
47430: LD_INT 2
47432: NEG
47433: PUSH
47434: LD_INT 5
47436: NEG
47437: PUSH
47438: EMPTY
47439: LIST
47440: LIST
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: LIST
47446: LIST
47447: LIST
47448: LIST
47449: LIST
47450: LIST
47451: LIST
47452: LIST
47453: LIST
47454: LIST
47455: LIST
47456: LIST
47457: LIST
47458: LIST
47459: LIST
47460: LIST
47461: LIST
47462: LIST
47463: LIST
47464: LIST
47465: LIST
47466: LIST
47467: LIST
47468: LIST
47469: LIST
47470: LIST
47471: LIST
47472: LIST
47473: LIST
47474: LIST
47475: LIST
47476: LIST
47477: LIST
47478: LIST
47479: LIST
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: LIST
47487: LIST
47488: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47489: LD_ADDR_VAR 0 31
47493: PUSH
47494: LD_INT 0
47496: PUSH
47497: LD_INT 4
47499: PUSH
47500: EMPTY
47501: LIST
47502: LIST
47503: PUSH
47504: LD_INT 0
47506: PUSH
47507: LD_INT 3
47509: PUSH
47510: EMPTY
47511: LIST
47512: LIST
47513: PUSH
47514: LD_INT 1
47516: PUSH
47517: LD_INT 4
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: PUSH
47524: LD_INT 1
47526: PUSH
47527: LD_INT 5
47529: PUSH
47530: EMPTY
47531: LIST
47532: LIST
47533: PUSH
47534: LD_INT 0
47536: PUSH
47537: LD_INT 5
47539: PUSH
47540: EMPTY
47541: LIST
47542: LIST
47543: PUSH
47544: LD_INT 1
47546: NEG
47547: PUSH
47548: LD_INT 4
47550: PUSH
47551: EMPTY
47552: LIST
47553: LIST
47554: PUSH
47555: LD_INT 1
47557: NEG
47558: PUSH
47559: LD_INT 3
47561: PUSH
47562: EMPTY
47563: LIST
47564: LIST
47565: PUSH
47566: LD_INT 2
47568: PUSH
47569: LD_INT 5
47571: PUSH
47572: EMPTY
47573: LIST
47574: LIST
47575: PUSH
47576: LD_INT 2
47578: NEG
47579: PUSH
47580: LD_INT 3
47582: PUSH
47583: EMPTY
47584: LIST
47585: LIST
47586: PUSH
47587: LD_INT 3
47589: NEG
47590: PUSH
47591: LD_INT 0
47593: PUSH
47594: EMPTY
47595: LIST
47596: LIST
47597: PUSH
47598: LD_INT 3
47600: NEG
47601: PUSH
47602: LD_INT 1
47604: NEG
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 2
47612: NEG
47613: PUSH
47614: LD_INT 0
47616: PUSH
47617: EMPTY
47618: LIST
47619: LIST
47620: PUSH
47621: LD_INT 2
47623: NEG
47624: PUSH
47625: LD_INT 1
47627: PUSH
47628: EMPTY
47629: LIST
47630: LIST
47631: PUSH
47632: LD_INT 3
47634: NEG
47635: PUSH
47636: LD_INT 1
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: PUSH
47643: LD_INT 4
47645: NEG
47646: PUSH
47647: LD_INT 0
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 4
47656: NEG
47657: PUSH
47658: LD_INT 1
47660: NEG
47661: PUSH
47662: EMPTY
47663: LIST
47664: LIST
47665: PUSH
47666: LD_INT 4
47668: NEG
47669: PUSH
47670: LD_INT 2
47672: NEG
47673: PUSH
47674: EMPTY
47675: LIST
47676: LIST
47677: PUSH
47678: LD_INT 2
47680: NEG
47681: PUSH
47682: LD_INT 2
47684: PUSH
47685: EMPTY
47686: LIST
47687: LIST
47688: PUSH
47689: LD_INT 4
47691: NEG
47692: PUSH
47693: LD_INT 4
47695: NEG
47696: PUSH
47697: EMPTY
47698: LIST
47699: LIST
47700: PUSH
47701: LD_INT 4
47703: NEG
47704: PUSH
47705: LD_INT 5
47707: NEG
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: PUSH
47713: LD_INT 3
47715: NEG
47716: PUSH
47717: LD_INT 4
47719: NEG
47720: PUSH
47721: EMPTY
47722: LIST
47723: LIST
47724: PUSH
47725: LD_INT 3
47727: NEG
47728: PUSH
47729: LD_INT 3
47731: NEG
47732: PUSH
47733: EMPTY
47734: LIST
47735: LIST
47736: PUSH
47737: LD_INT 4
47739: NEG
47740: PUSH
47741: LD_INT 3
47743: NEG
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 5
47751: NEG
47752: PUSH
47753: LD_INT 4
47755: NEG
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: PUSH
47761: LD_INT 5
47763: NEG
47764: PUSH
47765: LD_INT 5
47767: NEG
47768: PUSH
47769: EMPTY
47770: LIST
47771: LIST
47772: PUSH
47773: LD_INT 3
47775: NEG
47776: PUSH
47777: LD_INT 5
47779: NEG
47780: PUSH
47781: EMPTY
47782: LIST
47783: LIST
47784: PUSH
47785: LD_INT 5
47787: NEG
47788: PUSH
47789: LD_INT 3
47791: NEG
47792: PUSH
47793: EMPTY
47794: LIST
47795: LIST
47796: PUSH
47797: LD_INT 0
47799: PUSH
47800: LD_INT 3
47802: NEG
47803: PUSH
47804: EMPTY
47805: LIST
47806: LIST
47807: PUSH
47808: LD_INT 0
47810: PUSH
47811: LD_INT 4
47813: NEG
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_INT 1
47821: PUSH
47822: LD_INT 3
47824: NEG
47825: PUSH
47826: EMPTY
47827: LIST
47828: LIST
47829: PUSH
47830: LD_INT 1
47832: PUSH
47833: LD_INT 2
47835: NEG
47836: PUSH
47837: EMPTY
47838: LIST
47839: LIST
47840: PUSH
47841: LD_INT 0
47843: PUSH
47844: LD_INT 2
47846: NEG
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_INT 1
47854: NEG
47855: PUSH
47856: LD_INT 3
47858: NEG
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PUSH
47864: LD_INT 1
47866: NEG
47867: PUSH
47868: LD_INT 4
47870: NEG
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 2
47878: PUSH
47879: LD_INT 2
47881: NEG
47882: PUSH
47883: EMPTY
47884: LIST
47885: LIST
47886: PUSH
47887: LD_INT 2
47889: NEG
47890: PUSH
47891: LD_INT 4
47893: NEG
47894: PUSH
47895: EMPTY
47896: LIST
47897: LIST
47898: PUSH
47899: LD_INT 4
47901: PUSH
47902: LD_INT 0
47904: PUSH
47905: EMPTY
47906: LIST
47907: LIST
47908: PUSH
47909: LD_INT 4
47911: PUSH
47912: LD_INT 1
47914: NEG
47915: PUSH
47916: EMPTY
47917: LIST
47918: LIST
47919: PUSH
47920: LD_INT 5
47922: PUSH
47923: LD_INT 0
47925: PUSH
47926: EMPTY
47927: LIST
47928: LIST
47929: PUSH
47930: LD_INT 5
47932: PUSH
47933: LD_INT 1
47935: PUSH
47936: EMPTY
47937: LIST
47938: LIST
47939: PUSH
47940: LD_INT 4
47942: PUSH
47943: LD_INT 1
47945: PUSH
47946: EMPTY
47947: LIST
47948: LIST
47949: PUSH
47950: LD_INT 3
47952: PUSH
47953: LD_INT 0
47955: PUSH
47956: EMPTY
47957: LIST
47958: LIST
47959: PUSH
47960: LD_INT 3
47962: PUSH
47963: LD_INT 1
47965: NEG
47966: PUSH
47967: EMPTY
47968: LIST
47969: LIST
47970: PUSH
47971: LD_INT 3
47973: PUSH
47974: LD_INT 2
47976: NEG
47977: PUSH
47978: EMPTY
47979: LIST
47980: LIST
47981: PUSH
47982: LD_INT 5
47984: PUSH
47985: LD_INT 2
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: EMPTY
47993: LIST
47994: LIST
47995: LIST
47996: LIST
47997: LIST
47998: LIST
47999: LIST
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: LIST
48007: LIST
48008: LIST
48009: LIST
48010: LIST
48011: LIST
48012: LIST
48013: LIST
48014: LIST
48015: LIST
48016: LIST
48017: LIST
48018: LIST
48019: LIST
48020: LIST
48021: LIST
48022: LIST
48023: LIST
48024: LIST
48025: LIST
48026: LIST
48027: LIST
48028: LIST
48029: LIST
48030: LIST
48031: LIST
48032: LIST
48033: LIST
48034: LIST
48035: LIST
48036: LIST
48037: LIST
48038: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
48039: LD_ADDR_VAR 0 32
48043: PUSH
48044: LD_INT 4
48046: NEG
48047: PUSH
48048: LD_INT 0
48050: PUSH
48051: EMPTY
48052: LIST
48053: LIST
48054: PUSH
48055: LD_INT 4
48057: NEG
48058: PUSH
48059: LD_INT 1
48061: NEG
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: PUSH
48067: LD_INT 3
48069: NEG
48070: PUSH
48071: LD_INT 0
48073: PUSH
48074: EMPTY
48075: LIST
48076: LIST
48077: PUSH
48078: LD_INT 3
48080: NEG
48081: PUSH
48082: LD_INT 1
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: LD_INT 4
48091: NEG
48092: PUSH
48093: LD_INT 1
48095: PUSH
48096: EMPTY
48097: LIST
48098: LIST
48099: PUSH
48100: LD_INT 5
48102: NEG
48103: PUSH
48104: LD_INT 0
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PUSH
48111: LD_INT 5
48113: NEG
48114: PUSH
48115: LD_INT 1
48117: NEG
48118: PUSH
48119: EMPTY
48120: LIST
48121: LIST
48122: PUSH
48123: LD_INT 5
48125: NEG
48126: PUSH
48127: LD_INT 2
48129: NEG
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: PUSH
48135: LD_INT 3
48137: NEG
48138: PUSH
48139: LD_INT 2
48141: PUSH
48142: EMPTY
48143: LIST
48144: LIST
48145: PUSH
48146: LD_INT 3
48148: NEG
48149: PUSH
48150: LD_INT 3
48152: NEG
48153: PUSH
48154: EMPTY
48155: LIST
48156: LIST
48157: PUSH
48158: LD_INT 3
48160: NEG
48161: PUSH
48162: LD_INT 4
48164: NEG
48165: PUSH
48166: EMPTY
48167: LIST
48168: LIST
48169: PUSH
48170: LD_INT 2
48172: NEG
48173: PUSH
48174: LD_INT 3
48176: NEG
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: PUSH
48182: LD_INT 2
48184: NEG
48185: PUSH
48186: LD_INT 2
48188: NEG
48189: PUSH
48190: EMPTY
48191: LIST
48192: LIST
48193: PUSH
48194: LD_INT 3
48196: NEG
48197: PUSH
48198: LD_INT 2
48200: NEG
48201: PUSH
48202: EMPTY
48203: LIST
48204: LIST
48205: PUSH
48206: LD_INT 4
48208: NEG
48209: PUSH
48210: LD_INT 3
48212: NEG
48213: PUSH
48214: EMPTY
48215: LIST
48216: LIST
48217: PUSH
48218: LD_INT 4
48220: NEG
48221: PUSH
48222: LD_INT 4
48224: NEG
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: PUSH
48230: LD_INT 2
48232: NEG
48233: PUSH
48234: LD_INT 4
48236: NEG
48237: PUSH
48238: EMPTY
48239: LIST
48240: LIST
48241: PUSH
48242: LD_INT 4
48244: NEG
48245: PUSH
48246: LD_INT 2
48248: NEG
48249: PUSH
48250: EMPTY
48251: LIST
48252: LIST
48253: PUSH
48254: LD_INT 0
48256: PUSH
48257: LD_INT 4
48259: NEG
48260: PUSH
48261: EMPTY
48262: LIST
48263: LIST
48264: PUSH
48265: LD_INT 0
48267: PUSH
48268: LD_INT 5
48270: NEG
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 1
48278: PUSH
48279: LD_INT 4
48281: NEG
48282: PUSH
48283: EMPTY
48284: LIST
48285: LIST
48286: PUSH
48287: LD_INT 1
48289: PUSH
48290: LD_INT 3
48292: NEG
48293: PUSH
48294: EMPTY
48295: LIST
48296: LIST
48297: PUSH
48298: LD_INT 0
48300: PUSH
48301: LD_INT 3
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 1
48311: NEG
48312: PUSH
48313: LD_INT 4
48315: NEG
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 1
48323: NEG
48324: PUSH
48325: LD_INT 5
48327: NEG
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 2
48335: PUSH
48336: LD_INT 3
48338: NEG
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: PUSH
48344: LD_INT 2
48346: NEG
48347: PUSH
48348: LD_INT 5
48350: NEG
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: PUSH
48356: LD_INT 3
48358: PUSH
48359: LD_INT 0
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 3
48368: PUSH
48369: LD_INT 1
48371: NEG
48372: PUSH
48373: EMPTY
48374: LIST
48375: LIST
48376: PUSH
48377: LD_INT 4
48379: PUSH
48380: LD_INT 0
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: PUSH
48387: LD_INT 4
48389: PUSH
48390: LD_INT 1
48392: PUSH
48393: EMPTY
48394: LIST
48395: LIST
48396: PUSH
48397: LD_INT 3
48399: PUSH
48400: LD_INT 1
48402: PUSH
48403: EMPTY
48404: LIST
48405: LIST
48406: PUSH
48407: LD_INT 2
48409: PUSH
48410: LD_INT 0
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: PUSH
48417: LD_INT 2
48419: PUSH
48420: LD_INT 1
48422: NEG
48423: PUSH
48424: EMPTY
48425: LIST
48426: LIST
48427: PUSH
48428: LD_INT 2
48430: PUSH
48431: LD_INT 2
48433: NEG
48434: PUSH
48435: EMPTY
48436: LIST
48437: LIST
48438: PUSH
48439: LD_INT 4
48441: PUSH
48442: LD_INT 2
48444: PUSH
48445: EMPTY
48446: LIST
48447: LIST
48448: PUSH
48449: LD_INT 4
48451: PUSH
48452: LD_INT 4
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_INT 4
48461: PUSH
48462: LD_INT 3
48464: PUSH
48465: EMPTY
48466: LIST
48467: LIST
48468: PUSH
48469: LD_INT 5
48471: PUSH
48472: LD_INT 4
48474: PUSH
48475: EMPTY
48476: LIST
48477: LIST
48478: PUSH
48479: LD_INT 5
48481: PUSH
48482: LD_INT 5
48484: PUSH
48485: EMPTY
48486: LIST
48487: LIST
48488: PUSH
48489: LD_INT 4
48491: PUSH
48492: LD_INT 5
48494: PUSH
48495: EMPTY
48496: LIST
48497: LIST
48498: PUSH
48499: LD_INT 3
48501: PUSH
48502: LD_INT 4
48504: PUSH
48505: EMPTY
48506: LIST
48507: LIST
48508: PUSH
48509: LD_INT 3
48511: PUSH
48512: LD_INT 3
48514: PUSH
48515: EMPTY
48516: LIST
48517: LIST
48518: PUSH
48519: LD_INT 5
48521: PUSH
48522: LD_INT 3
48524: PUSH
48525: EMPTY
48526: LIST
48527: LIST
48528: PUSH
48529: LD_INT 3
48531: PUSH
48532: LD_INT 5
48534: PUSH
48535: EMPTY
48536: LIST
48537: LIST
48538: PUSH
48539: EMPTY
48540: LIST
48541: LIST
48542: LIST
48543: LIST
48544: LIST
48545: LIST
48546: LIST
48547: LIST
48548: LIST
48549: LIST
48550: LIST
48551: LIST
48552: LIST
48553: LIST
48554: LIST
48555: LIST
48556: LIST
48557: LIST
48558: LIST
48559: LIST
48560: LIST
48561: LIST
48562: LIST
48563: LIST
48564: LIST
48565: LIST
48566: LIST
48567: LIST
48568: LIST
48569: LIST
48570: LIST
48571: LIST
48572: LIST
48573: LIST
48574: LIST
48575: LIST
48576: LIST
48577: LIST
48578: LIST
48579: LIST
48580: LIST
48581: LIST
48582: LIST
48583: LIST
48584: LIST
48585: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48586: LD_ADDR_VAR 0 33
48590: PUSH
48591: LD_INT 4
48593: NEG
48594: PUSH
48595: LD_INT 4
48597: NEG
48598: PUSH
48599: EMPTY
48600: LIST
48601: LIST
48602: PUSH
48603: LD_INT 4
48605: NEG
48606: PUSH
48607: LD_INT 5
48609: NEG
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PUSH
48615: LD_INT 3
48617: NEG
48618: PUSH
48619: LD_INT 4
48621: NEG
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: PUSH
48627: LD_INT 3
48629: NEG
48630: PUSH
48631: LD_INT 3
48633: NEG
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: PUSH
48639: LD_INT 4
48641: NEG
48642: PUSH
48643: LD_INT 3
48645: NEG
48646: PUSH
48647: EMPTY
48648: LIST
48649: LIST
48650: PUSH
48651: LD_INT 5
48653: NEG
48654: PUSH
48655: LD_INT 4
48657: NEG
48658: PUSH
48659: EMPTY
48660: LIST
48661: LIST
48662: PUSH
48663: LD_INT 5
48665: NEG
48666: PUSH
48667: LD_INT 5
48669: NEG
48670: PUSH
48671: EMPTY
48672: LIST
48673: LIST
48674: PUSH
48675: LD_INT 3
48677: NEG
48678: PUSH
48679: LD_INT 5
48681: NEG
48682: PUSH
48683: EMPTY
48684: LIST
48685: LIST
48686: PUSH
48687: LD_INT 5
48689: NEG
48690: PUSH
48691: LD_INT 3
48693: NEG
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: PUSH
48699: LD_INT 0
48701: PUSH
48702: LD_INT 3
48704: NEG
48705: PUSH
48706: EMPTY
48707: LIST
48708: LIST
48709: PUSH
48710: LD_INT 0
48712: PUSH
48713: LD_INT 4
48715: NEG
48716: PUSH
48717: EMPTY
48718: LIST
48719: LIST
48720: PUSH
48721: LD_INT 1
48723: PUSH
48724: LD_INT 3
48726: NEG
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: LD_INT 1
48734: PUSH
48735: LD_INT 2
48737: NEG
48738: PUSH
48739: EMPTY
48740: LIST
48741: LIST
48742: PUSH
48743: LD_INT 0
48745: PUSH
48746: LD_INT 2
48748: NEG
48749: PUSH
48750: EMPTY
48751: LIST
48752: LIST
48753: PUSH
48754: LD_INT 1
48756: NEG
48757: PUSH
48758: LD_INT 3
48760: NEG
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: LD_INT 1
48768: NEG
48769: PUSH
48770: LD_INT 4
48772: NEG
48773: PUSH
48774: EMPTY
48775: LIST
48776: LIST
48777: PUSH
48778: LD_INT 2
48780: PUSH
48781: LD_INT 2
48783: NEG
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: PUSH
48789: LD_INT 2
48791: NEG
48792: PUSH
48793: LD_INT 4
48795: NEG
48796: PUSH
48797: EMPTY
48798: LIST
48799: LIST
48800: PUSH
48801: LD_INT 4
48803: PUSH
48804: LD_INT 0
48806: PUSH
48807: EMPTY
48808: LIST
48809: LIST
48810: PUSH
48811: LD_INT 4
48813: PUSH
48814: LD_INT 1
48816: NEG
48817: PUSH
48818: EMPTY
48819: LIST
48820: LIST
48821: PUSH
48822: LD_INT 5
48824: PUSH
48825: LD_INT 0
48827: PUSH
48828: EMPTY
48829: LIST
48830: LIST
48831: PUSH
48832: LD_INT 5
48834: PUSH
48835: LD_INT 1
48837: PUSH
48838: EMPTY
48839: LIST
48840: LIST
48841: PUSH
48842: LD_INT 4
48844: PUSH
48845: LD_INT 1
48847: PUSH
48848: EMPTY
48849: LIST
48850: LIST
48851: PUSH
48852: LD_INT 3
48854: PUSH
48855: LD_INT 0
48857: PUSH
48858: EMPTY
48859: LIST
48860: LIST
48861: PUSH
48862: LD_INT 3
48864: PUSH
48865: LD_INT 1
48867: NEG
48868: PUSH
48869: EMPTY
48870: LIST
48871: LIST
48872: PUSH
48873: LD_INT 3
48875: PUSH
48876: LD_INT 2
48878: NEG
48879: PUSH
48880: EMPTY
48881: LIST
48882: LIST
48883: PUSH
48884: LD_INT 5
48886: PUSH
48887: LD_INT 2
48889: PUSH
48890: EMPTY
48891: LIST
48892: LIST
48893: PUSH
48894: LD_INT 3
48896: PUSH
48897: LD_INT 3
48899: PUSH
48900: EMPTY
48901: LIST
48902: LIST
48903: PUSH
48904: LD_INT 3
48906: PUSH
48907: LD_INT 2
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: PUSH
48914: LD_INT 4
48916: PUSH
48917: LD_INT 3
48919: PUSH
48920: EMPTY
48921: LIST
48922: LIST
48923: PUSH
48924: LD_INT 4
48926: PUSH
48927: LD_INT 4
48929: PUSH
48930: EMPTY
48931: LIST
48932: LIST
48933: PUSH
48934: LD_INT 3
48936: PUSH
48937: LD_INT 4
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: PUSH
48944: LD_INT 2
48946: PUSH
48947: LD_INT 3
48949: PUSH
48950: EMPTY
48951: LIST
48952: LIST
48953: PUSH
48954: LD_INT 2
48956: PUSH
48957: LD_INT 2
48959: PUSH
48960: EMPTY
48961: LIST
48962: LIST
48963: PUSH
48964: LD_INT 4
48966: PUSH
48967: LD_INT 2
48969: PUSH
48970: EMPTY
48971: LIST
48972: LIST
48973: PUSH
48974: LD_INT 2
48976: PUSH
48977: LD_INT 4
48979: PUSH
48980: EMPTY
48981: LIST
48982: LIST
48983: PUSH
48984: LD_INT 0
48986: PUSH
48987: LD_INT 4
48989: PUSH
48990: EMPTY
48991: LIST
48992: LIST
48993: PUSH
48994: LD_INT 0
48996: PUSH
48997: LD_INT 3
48999: PUSH
49000: EMPTY
49001: LIST
49002: LIST
49003: PUSH
49004: LD_INT 1
49006: PUSH
49007: LD_INT 4
49009: PUSH
49010: EMPTY
49011: LIST
49012: LIST
49013: PUSH
49014: LD_INT 1
49016: PUSH
49017: LD_INT 5
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: PUSH
49024: LD_INT 0
49026: PUSH
49027: LD_INT 5
49029: PUSH
49030: EMPTY
49031: LIST
49032: LIST
49033: PUSH
49034: LD_INT 1
49036: NEG
49037: PUSH
49038: LD_INT 4
49040: PUSH
49041: EMPTY
49042: LIST
49043: LIST
49044: PUSH
49045: LD_INT 1
49047: NEG
49048: PUSH
49049: LD_INT 3
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 2
49058: PUSH
49059: LD_INT 5
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 2
49068: NEG
49069: PUSH
49070: LD_INT 3
49072: PUSH
49073: EMPTY
49074: LIST
49075: LIST
49076: PUSH
49077: EMPTY
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: LIST
49100: LIST
49101: LIST
49102: LIST
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: LIST
49108: LIST
49109: LIST
49110: LIST
49111: LIST
49112: LIST
49113: LIST
49114: LIST
49115: LIST
49116: LIST
49117: LIST
49118: LIST
49119: LIST
49120: LIST
49121: LIST
49122: LIST
49123: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
49124: LD_ADDR_VAR 0 34
49128: PUSH
49129: LD_INT 0
49131: PUSH
49132: LD_INT 4
49134: NEG
49135: PUSH
49136: EMPTY
49137: LIST
49138: LIST
49139: PUSH
49140: LD_INT 0
49142: PUSH
49143: LD_INT 5
49145: NEG
49146: PUSH
49147: EMPTY
49148: LIST
49149: LIST
49150: PUSH
49151: LD_INT 1
49153: PUSH
49154: LD_INT 4
49156: NEG
49157: PUSH
49158: EMPTY
49159: LIST
49160: LIST
49161: PUSH
49162: LD_INT 1
49164: PUSH
49165: LD_INT 3
49167: NEG
49168: PUSH
49169: EMPTY
49170: LIST
49171: LIST
49172: PUSH
49173: LD_INT 0
49175: PUSH
49176: LD_INT 3
49178: NEG
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: PUSH
49184: LD_INT 1
49186: NEG
49187: PUSH
49188: LD_INT 4
49190: NEG
49191: PUSH
49192: EMPTY
49193: LIST
49194: LIST
49195: PUSH
49196: LD_INT 1
49198: NEG
49199: PUSH
49200: LD_INT 5
49202: NEG
49203: PUSH
49204: EMPTY
49205: LIST
49206: LIST
49207: PUSH
49208: LD_INT 2
49210: PUSH
49211: LD_INT 3
49213: NEG
49214: PUSH
49215: EMPTY
49216: LIST
49217: LIST
49218: PUSH
49219: LD_INT 2
49221: NEG
49222: PUSH
49223: LD_INT 5
49225: NEG
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 3
49233: PUSH
49234: LD_INT 0
49236: PUSH
49237: EMPTY
49238: LIST
49239: LIST
49240: PUSH
49241: LD_INT 3
49243: PUSH
49244: LD_INT 1
49246: NEG
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PUSH
49252: LD_INT 4
49254: PUSH
49255: LD_INT 0
49257: PUSH
49258: EMPTY
49259: LIST
49260: LIST
49261: PUSH
49262: LD_INT 4
49264: PUSH
49265: LD_INT 1
49267: PUSH
49268: EMPTY
49269: LIST
49270: LIST
49271: PUSH
49272: LD_INT 3
49274: PUSH
49275: LD_INT 1
49277: PUSH
49278: EMPTY
49279: LIST
49280: LIST
49281: PUSH
49282: LD_INT 2
49284: PUSH
49285: LD_INT 0
49287: PUSH
49288: EMPTY
49289: LIST
49290: LIST
49291: PUSH
49292: LD_INT 2
49294: PUSH
49295: LD_INT 1
49297: NEG
49298: PUSH
49299: EMPTY
49300: LIST
49301: LIST
49302: PUSH
49303: LD_INT 2
49305: PUSH
49306: LD_INT 2
49308: NEG
49309: PUSH
49310: EMPTY
49311: LIST
49312: LIST
49313: PUSH
49314: LD_INT 4
49316: PUSH
49317: LD_INT 2
49319: PUSH
49320: EMPTY
49321: LIST
49322: LIST
49323: PUSH
49324: LD_INT 4
49326: PUSH
49327: LD_INT 4
49329: PUSH
49330: EMPTY
49331: LIST
49332: LIST
49333: PUSH
49334: LD_INT 4
49336: PUSH
49337: LD_INT 3
49339: PUSH
49340: EMPTY
49341: LIST
49342: LIST
49343: PUSH
49344: LD_INT 5
49346: PUSH
49347: LD_INT 4
49349: PUSH
49350: EMPTY
49351: LIST
49352: LIST
49353: PUSH
49354: LD_INT 5
49356: PUSH
49357: LD_INT 5
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: LD_INT 4
49366: PUSH
49367: LD_INT 5
49369: PUSH
49370: EMPTY
49371: LIST
49372: LIST
49373: PUSH
49374: LD_INT 3
49376: PUSH
49377: LD_INT 4
49379: PUSH
49380: EMPTY
49381: LIST
49382: LIST
49383: PUSH
49384: LD_INT 3
49386: PUSH
49387: LD_INT 3
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 5
49396: PUSH
49397: LD_INT 3
49399: PUSH
49400: EMPTY
49401: LIST
49402: LIST
49403: PUSH
49404: LD_INT 3
49406: PUSH
49407: LD_INT 5
49409: PUSH
49410: EMPTY
49411: LIST
49412: LIST
49413: PUSH
49414: LD_INT 0
49416: PUSH
49417: LD_INT 3
49419: PUSH
49420: EMPTY
49421: LIST
49422: LIST
49423: PUSH
49424: LD_INT 0
49426: PUSH
49427: LD_INT 2
49429: PUSH
49430: EMPTY
49431: LIST
49432: LIST
49433: PUSH
49434: LD_INT 1
49436: PUSH
49437: LD_INT 3
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: PUSH
49444: LD_INT 1
49446: PUSH
49447: LD_INT 4
49449: PUSH
49450: EMPTY
49451: LIST
49452: LIST
49453: PUSH
49454: LD_INT 0
49456: PUSH
49457: LD_INT 4
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: PUSH
49464: LD_INT 1
49466: NEG
49467: PUSH
49468: LD_INT 3
49470: PUSH
49471: EMPTY
49472: LIST
49473: LIST
49474: PUSH
49475: LD_INT 1
49477: NEG
49478: PUSH
49479: LD_INT 2
49481: PUSH
49482: EMPTY
49483: LIST
49484: LIST
49485: PUSH
49486: LD_INT 2
49488: PUSH
49489: LD_INT 4
49491: PUSH
49492: EMPTY
49493: LIST
49494: LIST
49495: PUSH
49496: LD_INT 2
49498: NEG
49499: PUSH
49500: LD_INT 2
49502: PUSH
49503: EMPTY
49504: LIST
49505: LIST
49506: PUSH
49507: LD_INT 4
49509: NEG
49510: PUSH
49511: LD_INT 0
49513: PUSH
49514: EMPTY
49515: LIST
49516: LIST
49517: PUSH
49518: LD_INT 4
49520: NEG
49521: PUSH
49522: LD_INT 1
49524: NEG
49525: PUSH
49526: EMPTY
49527: LIST
49528: LIST
49529: PUSH
49530: LD_INT 3
49532: NEG
49533: PUSH
49534: LD_INT 0
49536: PUSH
49537: EMPTY
49538: LIST
49539: LIST
49540: PUSH
49541: LD_INT 3
49543: NEG
49544: PUSH
49545: LD_INT 1
49547: PUSH
49548: EMPTY
49549: LIST
49550: LIST
49551: PUSH
49552: LD_INT 4
49554: NEG
49555: PUSH
49556: LD_INT 1
49558: PUSH
49559: EMPTY
49560: LIST
49561: LIST
49562: PUSH
49563: LD_INT 5
49565: NEG
49566: PUSH
49567: LD_INT 0
49569: PUSH
49570: EMPTY
49571: LIST
49572: LIST
49573: PUSH
49574: LD_INT 5
49576: NEG
49577: PUSH
49578: LD_INT 1
49580: NEG
49581: PUSH
49582: EMPTY
49583: LIST
49584: LIST
49585: PUSH
49586: LD_INT 5
49588: NEG
49589: PUSH
49590: LD_INT 2
49592: NEG
49593: PUSH
49594: EMPTY
49595: LIST
49596: LIST
49597: PUSH
49598: LD_INT 3
49600: NEG
49601: PUSH
49602: LD_INT 2
49604: PUSH
49605: EMPTY
49606: LIST
49607: LIST
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: LIST
49647: LIST
49648: LIST
49649: LIST
49650: LIST
49651: LIST
49652: LIST
49653: LIST
49654: LIST
49655: ST_TO_ADDR
// end ; end ;
49656: GO 49659
49658: POP
// case btype of b_depot , b_warehouse :
49659: LD_VAR 0 1
49663: PUSH
49664: LD_INT 0
49666: DOUBLE
49667: EQUAL
49668: IFTRUE 49678
49670: LD_INT 1
49672: DOUBLE
49673: EQUAL
49674: IFTRUE 49678
49676: GO 49879
49678: POP
// case nation of nation_american :
49679: LD_VAR 0 5
49683: PUSH
49684: LD_INT 1
49686: DOUBLE
49687: EQUAL
49688: IFTRUE 49692
49690: GO 49748
49692: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49693: LD_ADDR_VAR 0 9
49697: PUSH
49698: LD_VAR 0 11
49702: PUSH
49703: LD_VAR 0 12
49707: PUSH
49708: LD_VAR 0 13
49712: PUSH
49713: LD_VAR 0 14
49717: PUSH
49718: LD_VAR 0 15
49722: PUSH
49723: LD_VAR 0 16
49727: PUSH
49728: EMPTY
49729: LIST
49730: LIST
49731: LIST
49732: LIST
49733: LIST
49734: LIST
49735: PUSH
49736: LD_VAR 0 4
49740: PUSH
49741: LD_INT 1
49743: PLUS
49744: ARRAY
49745: ST_TO_ADDR
49746: GO 49877
49748: LD_INT 2
49750: DOUBLE
49751: EQUAL
49752: IFTRUE 49756
49754: GO 49812
49756: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49757: LD_ADDR_VAR 0 9
49761: PUSH
49762: LD_VAR 0 17
49766: PUSH
49767: LD_VAR 0 18
49771: PUSH
49772: LD_VAR 0 19
49776: PUSH
49777: LD_VAR 0 20
49781: PUSH
49782: LD_VAR 0 21
49786: PUSH
49787: LD_VAR 0 22
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: LIST
49796: LIST
49797: LIST
49798: LIST
49799: PUSH
49800: LD_VAR 0 4
49804: PUSH
49805: LD_INT 1
49807: PLUS
49808: ARRAY
49809: ST_TO_ADDR
49810: GO 49877
49812: LD_INT 3
49814: DOUBLE
49815: EQUAL
49816: IFTRUE 49820
49818: GO 49876
49820: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49821: LD_ADDR_VAR 0 9
49825: PUSH
49826: LD_VAR 0 23
49830: PUSH
49831: LD_VAR 0 24
49835: PUSH
49836: LD_VAR 0 25
49840: PUSH
49841: LD_VAR 0 26
49845: PUSH
49846: LD_VAR 0 27
49850: PUSH
49851: LD_VAR 0 28
49855: PUSH
49856: EMPTY
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: PUSH
49864: LD_VAR 0 4
49868: PUSH
49869: LD_INT 1
49871: PLUS
49872: ARRAY
49873: ST_TO_ADDR
49874: GO 49877
49876: POP
49877: GO 50432
49879: LD_INT 2
49881: DOUBLE
49882: EQUAL
49883: IFTRUE 49893
49885: LD_INT 3
49887: DOUBLE
49888: EQUAL
49889: IFTRUE 49893
49891: GO 49949
49893: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49894: LD_ADDR_VAR 0 9
49898: PUSH
49899: LD_VAR 0 29
49903: PUSH
49904: LD_VAR 0 30
49908: PUSH
49909: LD_VAR 0 31
49913: PUSH
49914: LD_VAR 0 32
49918: PUSH
49919: LD_VAR 0 33
49923: PUSH
49924: LD_VAR 0 34
49928: PUSH
49929: EMPTY
49930: LIST
49931: LIST
49932: LIST
49933: LIST
49934: LIST
49935: LIST
49936: PUSH
49937: LD_VAR 0 4
49941: PUSH
49942: LD_INT 1
49944: PLUS
49945: ARRAY
49946: ST_TO_ADDR
49947: GO 50432
49949: LD_INT 16
49951: DOUBLE
49952: EQUAL
49953: IFTRUE 50011
49955: LD_INT 17
49957: DOUBLE
49958: EQUAL
49959: IFTRUE 50011
49961: LD_INT 18
49963: DOUBLE
49964: EQUAL
49965: IFTRUE 50011
49967: LD_INT 19
49969: DOUBLE
49970: EQUAL
49971: IFTRUE 50011
49973: LD_INT 22
49975: DOUBLE
49976: EQUAL
49977: IFTRUE 50011
49979: LD_INT 20
49981: DOUBLE
49982: EQUAL
49983: IFTRUE 50011
49985: LD_INT 21
49987: DOUBLE
49988: EQUAL
49989: IFTRUE 50011
49991: LD_INT 23
49993: DOUBLE
49994: EQUAL
49995: IFTRUE 50011
49997: LD_INT 24
49999: DOUBLE
50000: EQUAL
50001: IFTRUE 50011
50003: LD_INT 25
50005: DOUBLE
50006: EQUAL
50007: IFTRUE 50011
50009: GO 50067
50011: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
50012: LD_ADDR_VAR 0 9
50016: PUSH
50017: LD_VAR 0 35
50021: PUSH
50022: LD_VAR 0 36
50026: PUSH
50027: LD_VAR 0 37
50031: PUSH
50032: LD_VAR 0 38
50036: PUSH
50037: LD_VAR 0 39
50041: PUSH
50042: LD_VAR 0 40
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: LIST
50051: LIST
50052: LIST
50053: LIST
50054: PUSH
50055: LD_VAR 0 4
50059: PUSH
50060: LD_INT 1
50062: PLUS
50063: ARRAY
50064: ST_TO_ADDR
50065: GO 50432
50067: LD_INT 6
50069: DOUBLE
50070: EQUAL
50071: IFTRUE 50123
50073: LD_INT 7
50075: DOUBLE
50076: EQUAL
50077: IFTRUE 50123
50079: LD_INT 8
50081: DOUBLE
50082: EQUAL
50083: IFTRUE 50123
50085: LD_INT 13
50087: DOUBLE
50088: EQUAL
50089: IFTRUE 50123
50091: LD_INT 12
50093: DOUBLE
50094: EQUAL
50095: IFTRUE 50123
50097: LD_INT 15
50099: DOUBLE
50100: EQUAL
50101: IFTRUE 50123
50103: LD_INT 11
50105: DOUBLE
50106: EQUAL
50107: IFTRUE 50123
50109: LD_INT 14
50111: DOUBLE
50112: EQUAL
50113: IFTRUE 50123
50115: LD_INT 10
50117: DOUBLE
50118: EQUAL
50119: IFTRUE 50123
50121: GO 50179
50123: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
50124: LD_ADDR_VAR 0 9
50128: PUSH
50129: LD_VAR 0 41
50133: PUSH
50134: LD_VAR 0 42
50138: PUSH
50139: LD_VAR 0 43
50143: PUSH
50144: LD_VAR 0 44
50148: PUSH
50149: LD_VAR 0 45
50153: PUSH
50154: LD_VAR 0 46
50158: PUSH
50159: EMPTY
50160: LIST
50161: LIST
50162: LIST
50163: LIST
50164: LIST
50165: LIST
50166: PUSH
50167: LD_VAR 0 4
50171: PUSH
50172: LD_INT 1
50174: PLUS
50175: ARRAY
50176: ST_TO_ADDR
50177: GO 50432
50179: LD_INT 36
50181: DOUBLE
50182: EQUAL
50183: IFTRUE 50187
50185: GO 50243
50187: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
50188: LD_ADDR_VAR 0 9
50192: PUSH
50193: LD_VAR 0 47
50197: PUSH
50198: LD_VAR 0 48
50202: PUSH
50203: LD_VAR 0 49
50207: PUSH
50208: LD_VAR 0 50
50212: PUSH
50213: LD_VAR 0 51
50217: PUSH
50218: LD_VAR 0 52
50222: PUSH
50223: EMPTY
50224: LIST
50225: LIST
50226: LIST
50227: LIST
50228: LIST
50229: LIST
50230: PUSH
50231: LD_VAR 0 4
50235: PUSH
50236: LD_INT 1
50238: PLUS
50239: ARRAY
50240: ST_TO_ADDR
50241: GO 50432
50243: LD_INT 4
50245: DOUBLE
50246: EQUAL
50247: IFTRUE 50269
50249: LD_INT 5
50251: DOUBLE
50252: EQUAL
50253: IFTRUE 50269
50255: LD_INT 34
50257: DOUBLE
50258: EQUAL
50259: IFTRUE 50269
50261: LD_INT 37
50263: DOUBLE
50264: EQUAL
50265: IFTRUE 50269
50267: GO 50325
50269: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
50270: LD_ADDR_VAR 0 9
50274: PUSH
50275: LD_VAR 0 53
50279: PUSH
50280: LD_VAR 0 54
50284: PUSH
50285: LD_VAR 0 55
50289: PUSH
50290: LD_VAR 0 56
50294: PUSH
50295: LD_VAR 0 57
50299: PUSH
50300: LD_VAR 0 58
50304: PUSH
50305: EMPTY
50306: LIST
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: LIST
50312: PUSH
50313: LD_VAR 0 4
50317: PUSH
50318: LD_INT 1
50320: PLUS
50321: ARRAY
50322: ST_TO_ADDR
50323: GO 50432
50325: LD_INT 31
50327: DOUBLE
50328: EQUAL
50329: IFTRUE 50375
50331: LD_INT 32
50333: DOUBLE
50334: EQUAL
50335: IFTRUE 50375
50337: LD_INT 33
50339: DOUBLE
50340: EQUAL
50341: IFTRUE 50375
50343: LD_INT 27
50345: DOUBLE
50346: EQUAL
50347: IFTRUE 50375
50349: LD_INT 26
50351: DOUBLE
50352: EQUAL
50353: IFTRUE 50375
50355: LD_INT 28
50357: DOUBLE
50358: EQUAL
50359: IFTRUE 50375
50361: LD_INT 29
50363: DOUBLE
50364: EQUAL
50365: IFTRUE 50375
50367: LD_INT 30
50369: DOUBLE
50370: EQUAL
50371: IFTRUE 50375
50373: GO 50431
50375: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50376: LD_ADDR_VAR 0 9
50380: PUSH
50381: LD_VAR 0 59
50385: PUSH
50386: LD_VAR 0 60
50390: PUSH
50391: LD_VAR 0 61
50395: PUSH
50396: LD_VAR 0 62
50400: PUSH
50401: LD_VAR 0 63
50405: PUSH
50406: LD_VAR 0 64
50410: PUSH
50411: EMPTY
50412: LIST
50413: LIST
50414: LIST
50415: LIST
50416: LIST
50417: LIST
50418: PUSH
50419: LD_VAR 0 4
50423: PUSH
50424: LD_INT 1
50426: PLUS
50427: ARRAY
50428: ST_TO_ADDR
50429: GO 50432
50431: POP
// temp_list2 = [ ] ;
50432: LD_ADDR_VAR 0 10
50436: PUSH
50437: EMPTY
50438: ST_TO_ADDR
// for i in temp_list do
50439: LD_ADDR_VAR 0 8
50443: PUSH
50444: LD_VAR 0 9
50448: PUSH
50449: FOR_IN
50450: IFFALSE 50502
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50452: LD_ADDR_VAR 0 10
50456: PUSH
50457: LD_VAR 0 10
50461: PUSH
50462: LD_VAR 0 8
50466: PUSH
50467: LD_INT 1
50469: ARRAY
50470: PUSH
50471: LD_VAR 0 2
50475: PLUS
50476: PUSH
50477: LD_VAR 0 8
50481: PUSH
50482: LD_INT 2
50484: ARRAY
50485: PUSH
50486: LD_VAR 0 3
50490: PLUS
50491: PUSH
50492: EMPTY
50493: LIST
50494: LIST
50495: PUSH
50496: EMPTY
50497: LIST
50498: ADD
50499: ST_TO_ADDR
50500: GO 50449
50502: POP
50503: POP
// result = temp_list2 ;
50504: LD_ADDR_VAR 0 7
50508: PUSH
50509: LD_VAR 0 10
50513: ST_TO_ADDR
// end ;
50514: LD_VAR 0 7
50518: RET
// export function EnemyInRange ( unit , dist ) ; begin
50519: LD_INT 0
50521: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50522: LD_ADDR_VAR 0 3
50526: PUSH
50527: LD_VAR 0 1
50531: PPUSH
50532: CALL_OW 255
50536: PPUSH
50537: LD_VAR 0 1
50541: PPUSH
50542: CALL_OW 250
50546: PPUSH
50547: LD_VAR 0 1
50551: PPUSH
50552: CALL_OW 251
50556: PPUSH
50557: LD_VAR 0 2
50561: PPUSH
50562: CALL 23776 0 4
50566: PUSH
50567: LD_INT 4
50569: ARRAY
50570: ST_TO_ADDR
// end ;
50571: LD_VAR 0 3
50575: RET
// export function PlayerSeeMe ( unit ) ; begin
50576: LD_INT 0
50578: PPUSH
// result := See ( your_side , unit ) ;
50579: LD_ADDR_VAR 0 2
50583: PUSH
50584: LD_OWVAR 2
50588: PPUSH
50589: LD_VAR 0 1
50593: PPUSH
50594: CALL_OW 292
50598: ST_TO_ADDR
// end ;
50599: LD_VAR 0 2
50603: RET
// export function ReverseDir ( unit ) ; begin
50604: LD_INT 0
50606: PPUSH
// if not unit then
50607: LD_VAR 0 1
50611: NOT
50612: IFFALSE 50616
// exit ;
50614: GO 50639
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50616: LD_ADDR_VAR 0 2
50620: PUSH
50621: LD_VAR 0 1
50625: PPUSH
50626: CALL_OW 254
50630: PUSH
50631: LD_INT 3
50633: PLUS
50634: PUSH
50635: LD_INT 6
50637: MOD
50638: ST_TO_ADDR
// end ;
50639: LD_VAR 0 2
50643: RET
// export function ReverseArray ( array ) ; var i ; begin
50644: LD_INT 0
50646: PPUSH
50647: PPUSH
// if not array then
50648: LD_VAR 0 1
50652: NOT
50653: IFFALSE 50657
// exit ;
50655: GO 50712
// result := [ ] ;
50657: LD_ADDR_VAR 0 2
50661: PUSH
50662: EMPTY
50663: ST_TO_ADDR
// for i := array downto 1 do
50664: LD_ADDR_VAR 0 3
50668: PUSH
50669: DOUBLE
50670: LD_VAR 0 1
50674: INC
50675: ST_TO_ADDR
50676: LD_INT 1
50678: PUSH
50679: FOR_DOWNTO
50680: IFFALSE 50710
// result := Join ( result , array [ i ] ) ;
50682: LD_ADDR_VAR 0 2
50686: PUSH
50687: LD_VAR 0 2
50691: PPUSH
50692: LD_VAR 0 1
50696: PUSH
50697: LD_VAR 0 3
50701: ARRAY
50702: PPUSH
50703: CALL 55554 0 2
50707: ST_TO_ADDR
50708: GO 50679
50710: POP
50711: POP
// end ;
50712: LD_VAR 0 2
50716: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50717: LD_INT 0
50719: PPUSH
50720: PPUSH
50721: PPUSH
50722: PPUSH
50723: PPUSH
50724: PPUSH
// if not unit or not hexes then
50725: LD_VAR 0 1
50729: NOT
50730: IFTRUE 50739
50732: PUSH
50733: LD_VAR 0 2
50737: NOT
50738: OR
50739: IFFALSE 50743
// exit ;
50741: GO 50866
// dist := 9999 ;
50743: LD_ADDR_VAR 0 5
50747: PUSH
50748: LD_INT 9999
50750: ST_TO_ADDR
// for i = 1 to hexes do
50751: LD_ADDR_VAR 0 4
50755: PUSH
50756: DOUBLE
50757: LD_INT 1
50759: DEC
50760: ST_TO_ADDR
50761: LD_VAR 0 2
50765: PUSH
50766: FOR_TO
50767: IFFALSE 50854
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50769: LD_ADDR_VAR 0 6
50773: PUSH
50774: LD_VAR 0 1
50778: PPUSH
50779: LD_VAR 0 2
50783: PUSH
50784: LD_VAR 0 4
50788: ARRAY
50789: PUSH
50790: LD_INT 1
50792: ARRAY
50793: PPUSH
50794: LD_VAR 0 2
50798: PUSH
50799: LD_VAR 0 4
50803: ARRAY
50804: PUSH
50805: LD_INT 2
50807: ARRAY
50808: PPUSH
50809: CALL_OW 297
50813: ST_TO_ADDR
// if tdist < dist then
50814: LD_VAR 0 6
50818: PUSH
50819: LD_VAR 0 5
50823: LESS
50824: IFFALSE 50852
// begin hex := hexes [ i ] ;
50826: LD_ADDR_VAR 0 8
50830: PUSH
50831: LD_VAR 0 2
50835: PUSH
50836: LD_VAR 0 4
50840: ARRAY
50841: ST_TO_ADDR
// dist := tdist ;
50842: LD_ADDR_VAR 0 5
50846: PUSH
50847: LD_VAR 0 6
50851: ST_TO_ADDR
// end ; end ;
50852: GO 50766
50854: POP
50855: POP
// result := hex ;
50856: LD_ADDR_VAR 0 3
50860: PUSH
50861: LD_VAR 0 8
50865: ST_TO_ADDR
// end ;
50866: LD_VAR 0 3
50870: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50871: LD_INT 0
50873: PPUSH
50874: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50875: LD_VAR 0 1
50879: NOT
50880: IFTRUE 50919
50882: PUSH
50883: LD_VAR 0 1
50887: PUSH
50888: LD_INT 21
50890: PUSH
50891: LD_INT 2
50893: PUSH
50894: EMPTY
50895: LIST
50896: LIST
50897: PUSH
50898: LD_INT 23
50900: PUSH
50901: LD_INT 2
50903: PUSH
50904: EMPTY
50905: LIST
50906: LIST
50907: PUSH
50908: EMPTY
50909: LIST
50910: LIST
50911: PPUSH
50912: CALL_OW 69
50916: IN
50917: NOT
50918: OR
50919: IFFALSE 50923
// exit ;
50921: GO 50970
// for i = 1 to 3 do
50923: LD_ADDR_VAR 0 3
50927: PUSH
50928: DOUBLE
50929: LD_INT 1
50931: DEC
50932: ST_TO_ADDR
50933: LD_INT 3
50935: PUSH
50936: FOR_TO
50937: IFFALSE 50968
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50939: LD_VAR 0 1
50943: PPUSH
50944: CALL_OW 250
50948: PPUSH
50949: LD_VAR 0 1
50953: PPUSH
50954: CALL_OW 251
50958: PPUSH
50959: LD_INT 1
50961: PPUSH
50962: CALL_OW 453
50966: GO 50936
50968: POP
50969: POP
// end ;
50970: LD_VAR 0 2
50974: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
50975: LD_INT 0
50977: PPUSH
50978: PPUSH
50979: PPUSH
50980: PPUSH
50981: PPUSH
50982: PPUSH
// if not unit or not enemy_unit then
50983: LD_VAR 0 1
50987: NOT
50988: IFTRUE 50997
50990: PUSH
50991: LD_VAR 0 2
50995: NOT
50996: OR
50997: IFFALSE 51001
// exit ;
50999: GO 51472
// if GetLives ( i ) < 250 then
51001: LD_VAR 0 4
51005: PPUSH
51006: CALL_OW 256
51010: PUSH
51011: LD_INT 250
51013: LESS
51014: IFFALSE 51027
// begin ComAutodestruct ( i ) ;
51016: LD_VAR 0 4
51020: PPUSH
51021: CALL 50871 0 1
// exit ;
51025: GO 51472
// end ; x := GetX ( enemy_unit ) ;
51027: LD_ADDR_VAR 0 7
51031: PUSH
51032: LD_VAR 0 2
51036: PPUSH
51037: CALL_OW 250
51041: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
51042: LD_ADDR_VAR 0 8
51046: PUSH
51047: LD_VAR 0 2
51051: PPUSH
51052: CALL_OW 251
51056: ST_TO_ADDR
// if not x or not y then
51057: LD_VAR 0 7
51061: NOT
51062: IFTRUE 51071
51064: PUSH
51065: LD_VAR 0 8
51069: NOT
51070: OR
51071: IFFALSE 51075
// exit ;
51073: GO 51472
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
51075: LD_ADDR_VAR 0 6
51079: PUSH
51080: LD_VAR 0 7
51084: PPUSH
51085: LD_INT 0
51087: PPUSH
51088: LD_INT 4
51090: PPUSH
51091: CALL_OW 272
51095: PUSH
51096: LD_VAR 0 8
51100: PPUSH
51101: LD_INT 0
51103: PPUSH
51104: LD_INT 4
51106: PPUSH
51107: CALL_OW 273
51111: PUSH
51112: EMPTY
51113: LIST
51114: LIST
51115: PUSH
51116: LD_VAR 0 7
51120: PPUSH
51121: LD_INT 1
51123: PPUSH
51124: LD_INT 4
51126: PPUSH
51127: CALL_OW 272
51131: PUSH
51132: LD_VAR 0 8
51136: PPUSH
51137: LD_INT 1
51139: PPUSH
51140: LD_INT 4
51142: PPUSH
51143: CALL_OW 273
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: PUSH
51152: LD_VAR 0 7
51156: PPUSH
51157: LD_INT 2
51159: PPUSH
51160: LD_INT 4
51162: PPUSH
51163: CALL_OW 272
51167: PUSH
51168: LD_VAR 0 8
51172: PPUSH
51173: LD_INT 2
51175: PPUSH
51176: LD_INT 4
51178: PPUSH
51179: CALL_OW 273
51183: PUSH
51184: EMPTY
51185: LIST
51186: LIST
51187: PUSH
51188: LD_VAR 0 7
51192: PPUSH
51193: LD_INT 3
51195: PPUSH
51196: LD_INT 4
51198: PPUSH
51199: CALL_OW 272
51203: PUSH
51204: LD_VAR 0 8
51208: PPUSH
51209: LD_INT 3
51211: PPUSH
51212: LD_INT 4
51214: PPUSH
51215: CALL_OW 273
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: LD_VAR 0 7
51228: PPUSH
51229: LD_INT 4
51231: PPUSH
51232: LD_INT 4
51234: PPUSH
51235: CALL_OW 272
51239: PUSH
51240: LD_VAR 0 8
51244: PPUSH
51245: LD_INT 4
51247: PPUSH
51248: LD_INT 4
51250: PPUSH
51251: CALL_OW 273
51255: PUSH
51256: EMPTY
51257: LIST
51258: LIST
51259: PUSH
51260: LD_VAR 0 7
51264: PPUSH
51265: LD_INT 5
51267: PPUSH
51268: LD_INT 4
51270: PPUSH
51271: CALL_OW 272
51275: PUSH
51276: LD_VAR 0 8
51280: PPUSH
51281: LD_INT 5
51283: PPUSH
51284: LD_INT 4
51286: PPUSH
51287: CALL_OW 273
51291: PUSH
51292: EMPTY
51293: LIST
51294: LIST
51295: PUSH
51296: EMPTY
51297: LIST
51298: LIST
51299: LIST
51300: LIST
51301: LIST
51302: LIST
51303: ST_TO_ADDR
// for i = tmp downto 1 do
51304: LD_ADDR_VAR 0 4
51308: PUSH
51309: DOUBLE
51310: LD_VAR 0 6
51314: INC
51315: ST_TO_ADDR
51316: LD_INT 1
51318: PUSH
51319: FOR_DOWNTO
51320: IFFALSE 51423
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51322: LD_VAR 0 6
51326: PUSH
51327: LD_VAR 0 4
51331: ARRAY
51332: PUSH
51333: LD_INT 1
51335: ARRAY
51336: PPUSH
51337: LD_VAR 0 6
51341: PUSH
51342: LD_VAR 0 4
51346: ARRAY
51347: PUSH
51348: LD_INT 2
51350: ARRAY
51351: PPUSH
51352: CALL_OW 488
51356: NOT
51357: IFTRUE 51399
51359: PUSH
51360: LD_VAR 0 6
51364: PUSH
51365: LD_VAR 0 4
51369: ARRAY
51370: PUSH
51371: LD_INT 1
51373: ARRAY
51374: PPUSH
51375: LD_VAR 0 6
51379: PUSH
51380: LD_VAR 0 4
51384: ARRAY
51385: PUSH
51386: LD_INT 2
51388: ARRAY
51389: PPUSH
51390: CALL_OW 428
51394: PUSH
51395: LD_INT 0
51397: NONEQUAL
51398: OR
51399: IFFALSE 51421
// tmp := Delete ( tmp , i ) ;
51401: LD_ADDR_VAR 0 6
51405: PUSH
51406: LD_VAR 0 6
51410: PPUSH
51411: LD_VAR 0 4
51415: PPUSH
51416: CALL_OW 3
51420: ST_TO_ADDR
51421: GO 51319
51423: POP
51424: POP
// j := GetClosestHex ( unit , tmp ) ;
51425: LD_ADDR_VAR 0 5
51429: PUSH
51430: LD_VAR 0 1
51434: PPUSH
51435: LD_VAR 0 6
51439: PPUSH
51440: CALL 50717 0 2
51444: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51445: LD_VAR 0 1
51449: PPUSH
51450: LD_VAR 0 5
51454: PUSH
51455: LD_INT 1
51457: ARRAY
51458: PPUSH
51459: LD_VAR 0 5
51463: PUSH
51464: LD_INT 2
51466: ARRAY
51467: PPUSH
51468: CALL_OW 111
// end ;
51472: LD_VAR 0 3
51476: RET
// export function PrepareApemanSoldier ( ) ; begin
51477: LD_INT 0
51479: PPUSH
// uc_nation := 0 ;
51480: LD_ADDR_OWVAR 21
51484: PUSH
51485: LD_INT 0
51487: ST_TO_ADDR
// hc_sex := sex_male ;
51488: LD_ADDR_OWVAR 27
51492: PUSH
51493: LD_INT 1
51495: ST_TO_ADDR
// hc_name :=  ;
51496: LD_ADDR_OWVAR 26
51500: PUSH
51501: LD_STRING 
51503: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51504: LD_ADDR_OWVAR 28
51508: PUSH
51509: LD_INT 15
51511: ST_TO_ADDR
// hc_gallery :=  ;
51512: LD_ADDR_OWVAR 33
51516: PUSH
51517: LD_STRING 
51519: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51520: LD_ADDR_OWVAR 31
51524: PUSH
51525: LD_INT 0
51527: PPUSH
51528: LD_INT 3
51530: PPUSH
51531: CALL_OW 12
51535: PUSH
51536: LD_INT 0
51538: PPUSH
51539: LD_INT 3
51541: PPUSH
51542: CALL_OW 12
51546: PUSH
51547: LD_INT 0
51549: PUSH
51550: LD_INT 0
51552: PUSH
51553: EMPTY
51554: LIST
51555: LIST
51556: LIST
51557: LIST
51558: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51559: LD_ADDR_OWVAR 29
51563: PUSH
51564: LD_INT 12
51566: PUSH
51567: LD_INT 12
51569: PUSH
51570: EMPTY
51571: LIST
51572: LIST
51573: ST_TO_ADDR
// end ;
51574: LD_VAR 0 1
51578: RET
// export function PrepareApemanEngineer ( ) ; begin
51579: LD_INT 0
51581: PPUSH
// uc_nation := 0 ;
51582: LD_ADDR_OWVAR 21
51586: PUSH
51587: LD_INT 0
51589: ST_TO_ADDR
// hc_sex := sex_male ;
51590: LD_ADDR_OWVAR 27
51594: PUSH
51595: LD_INT 1
51597: ST_TO_ADDR
// hc_name :=  ;
51598: LD_ADDR_OWVAR 26
51602: PUSH
51603: LD_STRING 
51605: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51606: LD_ADDR_OWVAR 28
51610: PUSH
51611: LD_INT 16
51613: ST_TO_ADDR
// hc_gallery :=  ;
51614: LD_ADDR_OWVAR 33
51618: PUSH
51619: LD_STRING 
51621: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51622: LD_ADDR_OWVAR 31
51626: PUSH
51627: LD_INT 0
51629: PPUSH
51630: LD_INT 3
51632: PPUSH
51633: CALL_OW 12
51637: PUSH
51638: LD_INT 0
51640: PPUSH
51641: LD_INT 3
51643: PPUSH
51644: CALL_OW 12
51648: PUSH
51649: LD_INT 0
51651: PUSH
51652: LD_INT 0
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: LIST
51659: LIST
51660: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51661: LD_ADDR_OWVAR 29
51665: PUSH
51666: LD_INT 12
51668: PUSH
51669: LD_INT 12
51671: PUSH
51672: EMPTY
51673: LIST
51674: LIST
51675: ST_TO_ADDR
// end ;
51676: LD_VAR 0 1
51680: RET
// export function PrepareApeman ( agressivity ) ; begin
51681: LD_INT 0
51683: PPUSH
// uc_side := 0 ;
51684: LD_ADDR_OWVAR 20
51688: PUSH
51689: LD_INT 0
51691: ST_TO_ADDR
// uc_nation := 0 ;
51692: LD_ADDR_OWVAR 21
51696: PUSH
51697: LD_INT 0
51699: ST_TO_ADDR
// hc_sex := sex_male ;
51700: LD_ADDR_OWVAR 27
51704: PUSH
51705: LD_INT 1
51707: ST_TO_ADDR
// hc_class := class_apeman ;
51708: LD_ADDR_OWVAR 28
51712: PUSH
51713: LD_INT 12
51715: ST_TO_ADDR
// hc_gallery :=  ;
51716: LD_ADDR_OWVAR 33
51720: PUSH
51721: LD_STRING 
51723: ST_TO_ADDR
// hc_name :=  ;
51724: LD_ADDR_OWVAR 26
51728: PUSH
51729: LD_STRING 
51731: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
51732: LD_ADDR_OWVAR 29
51736: PUSH
51737: LD_INT 12
51739: PUSH
51740: LD_INT 12
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: ST_TO_ADDR
// if agressivity = 0 then
51747: LD_VAR 0 1
51751: PUSH
51752: LD_INT 0
51754: EQUAL
51755: IFFALSE 51767
// hc_agressivity := 0 else
51757: LD_ADDR_OWVAR 35
51761: PUSH
51762: LD_INT 0
51764: ST_TO_ADDR
51765: GO 51788
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51767: LD_ADDR_OWVAR 35
51771: PUSH
51772: LD_VAR 0 1
51776: NEG
51777: PPUSH
51778: LD_VAR 0 1
51782: PPUSH
51783: CALL_OW 12
51787: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51788: LD_ADDR_OWVAR 31
51792: PUSH
51793: LD_INT 0
51795: PPUSH
51796: LD_INT 3
51798: PPUSH
51799: CALL_OW 12
51803: PUSH
51804: LD_INT 0
51806: PPUSH
51807: LD_INT 3
51809: PPUSH
51810: CALL_OW 12
51814: PUSH
51815: LD_INT 0
51817: PUSH
51818: LD_INT 0
51820: PUSH
51821: EMPTY
51822: LIST
51823: LIST
51824: LIST
51825: LIST
51826: ST_TO_ADDR
// end ;
51827: LD_VAR 0 2
51831: RET
// export function PrepareTiger ( agressivity ) ; begin
51832: LD_INT 0
51834: PPUSH
// uc_side := 0 ;
51835: LD_ADDR_OWVAR 20
51839: PUSH
51840: LD_INT 0
51842: ST_TO_ADDR
// uc_nation := 0 ;
51843: LD_ADDR_OWVAR 21
51847: PUSH
51848: LD_INT 0
51850: ST_TO_ADDR
// InitHc ;
51851: CALL_OW 19
// hc_class := class_tiger ;
51855: LD_ADDR_OWVAR 28
51859: PUSH
51860: LD_INT 14
51862: ST_TO_ADDR
// hc_gallery :=  ;
51863: LD_ADDR_OWVAR 33
51867: PUSH
51868: LD_STRING 
51870: ST_TO_ADDR
// hc_name :=  ;
51871: LD_ADDR_OWVAR 26
51875: PUSH
51876: LD_STRING 
51878: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51879: LD_ADDR_OWVAR 35
51883: PUSH
51884: LD_VAR 0 1
51888: NEG
51889: PPUSH
51890: LD_VAR 0 1
51894: PPUSH
51895: CALL_OW 12
51899: ST_TO_ADDR
// end ;
51900: LD_VAR 0 2
51904: RET
// export function PrepareEnchidna ( ) ; begin
51905: LD_INT 0
51907: PPUSH
// uc_side := 0 ;
51908: LD_ADDR_OWVAR 20
51912: PUSH
51913: LD_INT 0
51915: ST_TO_ADDR
// uc_nation := 0 ;
51916: LD_ADDR_OWVAR 21
51920: PUSH
51921: LD_INT 0
51923: ST_TO_ADDR
// InitHc ;
51924: CALL_OW 19
// hc_class := class_baggie ;
51928: LD_ADDR_OWVAR 28
51932: PUSH
51933: LD_INT 13
51935: ST_TO_ADDR
// hc_gallery :=  ;
51936: LD_ADDR_OWVAR 33
51940: PUSH
51941: LD_STRING 
51943: ST_TO_ADDR
// hc_name :=  ;
51944: LD_ADDR_OWVAR 26
51948: PUSH
51949: LD_STRING 
51951: ST_TO_ADDR
// end ;
51952: LD_VAR 0 1
51956: RET
// export function PrepareFrog ( ) ; begin
51957: LD_INT 0
51959: PPUSH
// uc_side := 0 ;
51960: LD_ADDR_OWVAR 20
51964: PUSH
51965: LD_INT 0
51967: ST_TO_ADDR
// uc_nation := 0 ;
51968: LD_ADDR_OWVAR 21
51972: PUSH
51973: LD_INT 0
51975: ST_TO_ADDR
// InitHc ;
51976: CALL_OW 19
// hc_class := class_frog ;
51980: LD_ADDR_OWVAR 28
51984: PUSH
51985: LD_INT 19
51987: ST_TO_ADDR
// hc_gallery :=  ;
51988: LD_ADDR_OWVAR 33
51992: PUSH
51993: LD_STRING 
51995: ST_TO_ADDR
// hc_name :=  ;
51996: LD_ADDR_OWVAR 26
52000: PUSH
52001: LD_STRING 
52003: ST_TO_ADDR
// end ;
52004: LD_VAR 0 1
52008: RET
// export function PrepareFish ( ) ; begin
52009: LD_INT 0
52011: PPUSH
// uc_side := 0 ;
52012: LD_ADDR_OWVAR 20
52016: PUSH
52017: LD_INT 0
52019: ST_TO_ADDR
// uc_nation := 0 ;
52020: LD_ADDR_OWVAR 21
52024: PUSH
52025: LD_INT 0
52027: ST_TO_ADDR
// InitHc ;
52028: CALL_OW 19
// hc_class := class_fish ;
52032: LD_ADDR_OWVAR 28
52036: PUSH
52037: LD_INT 20
52039: ST_TO_ADDR
// hc_gallery :=  ;
52040: LD_ADDR_OWVAR 33
52044: PUSH
52045: LD_STRING 
52047: ST_TO_ADDR
// hc_name :=  ;
52048: LD_ADDR_OWVAR 26
52052: PUSH
52053: LD_STRING 
52055: ST_TO_ADDR
// end ;
52056: LD_VAR 0 1
52060: RET
// export function PrepareBird ( ) ; begin
52061: LD_INT 0
52063: PPUSH
// uc_side := 0 ;
52064: LD_ADDR_OWVAR 20
52068: PUSH
52069: LD_INT 0
52071: ST_TO_ADDR
// uc_nation := 0 ;
52072: LD_ADDR_OWVAR 21
52076: PUSH
52077: LD_INT 0
52079: ST_TO_ADDR
// InitHc ;
52080: CALL_OW 19
// hc_class := class_phororhacos ;
52084: LD_ADDR_OWVAR 28
52088: PUSH
52089: LD_INT 18
52091: ST_TO_ADDR
// hc_gallery :=  ;
52092: LD_ADDR_OWVAR 33
52096: PUSH
52097: LD_STRING 
52099: ST_TO_ADDR
// hc_name :=  ;
52100: LD_ADDR_OWVAR 26
52104: PUSH
52105: LD_STRING 
52107: ST_TO_ADDR
// end ;
52108: LD_VAR 0 1
52112: RET
// export function PrepareHorse ( ) ; begin
52113: LD_INT 0
52115: PPUSH
// uc_side := 0 ;
52116: LD_ADDR_OWVAR 20
52120: PUSH
52121: LD_INT 0
52123: ST_TO_ADDR
// uc_nation := 0 ;
52124: LD_ADDR_OWVAR 21
52128: PUSH
52129: LD_INT 0
52131: ST_TO_ADDR
// InitHc ;
52132: CALL_OW 19
// hc_class := class_horse ;
52136: LD_ADDR_OWVAR 28
52140: PUSH
52141: LD_INT 21
52143: ST_TO_ADDR
// hc_gallery :=  ;
52144: LD_ADDR_OWVAR 33
52148: PUSH
52149: LD_STRING 
52151: ST_TO_ADDR
// hc_name :=  ;
52152: LD_ADDR_OWVAR 26
52156: PUSH
52157: LD_STRING 
52159: ST_TO_ADDR
// end ;
52160: LD_VAR 0 1
52164: RET
// export function PrepareMastodont ( ) ; begin
52165: LD_INT 0
52167: PPUSH
// uc_side := 0 ;
52168: LD_ADDR_OWVAR 20
52172: PUSH
52173: LD_INT 0
52175: ST_TO_ADDR
// uc_nation := 0 ;
52176: LD_ADDR_OWVAR 21
52180: PUSH
52181: LD_INT 0
52183: ST_TO_ADDR
// vc_chassis := class_mastodont ;
52184: LD_ADDR_OWVAR 37
52188: PUSH
52189: LD_INT 31
52191: ST_TO_ADDR
// vc_control := control_rider ;
52192: LD_ADDR_OWVAR 38
52196: PUSH
52197: LD_INT 4
52199: ST_TO_ADDR
// end ;
52200: LD_VAR 0 1
52204: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
52205: LD_INT 0
52207: PPUSH
52208: PPUSH
52209: PPUSH
// uc_side = 0 ;
52210: LD_ADDR_OWVAR 20
52214: PUSH
52215: LD_INT 0
52217: ST_TO_ADDR
// uc_nation = 0 ;
52218: LD_ADDR_OWVAR 21
52222: PUSH
52223: LD_INT 0
52225: ST_TO_ADDR
// InitHc_All ( ) ;
52226: CALL_OW 584
// InitVc ;
52230: CALL_OW 20
// if mastodonts then
52234: LD_VAR 0 6
52238: IFFALSE 52305
// for i = 1 to mastodonts do
52240: LD_ADDR_VAR 0 11
52244: PUSH
52245: DOUBLE
52246: LD_INT 1
52248: DEC
52249: ST_TO_ADDR
52250: LD_VAR 0 6
52254: PUSH
52255: FOR_TO
52256: IFFALSE 52303
// begin vc_chassis := 31 ;
52258: LD_ADDR_OWVAR 37
52262: PUSH
52263: LD_INT 31
52265: ST_TO_ADDR
// vc_control := control_rider ;
52266: LD_ADDR_OWVAR 38
52270: PUSH
52271: LD_INT 4
52273: ST_TO_ADDR
// animal := CreateVehicle ;
52274: LD_ADDR_VAR 0 12
52278: PUSH
52279: CALL_OW 45
52283: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52284: LD_VAR 0 12
52288: PPUSH
52289: LD_VAR 0 8
52293: PPUSH
52294: LD_INT 0
52296: PPUSH
52297: CALL 54447 0 3
// end ;
52301: GO 52255
52303: POP
52304: POP
// if horses then
52305: LD_VAR 0 5
52309: IFFALSE 52376
// for i = 1 to horses do
52311: LD_ADDR_VAR 0 11
52315: PUSH
52316: DOUBLE
52317: LD_INT 1
52319: DEC
52320: ST_TO_ADDR
52321: LD_VAR 0 5
52325: PUSH
52326: FOR_TO
52327: IFFALSE 52374
// begin hc_class := 21 ;
52329: LD_ADDR_OWVAR 28
52333: PUSH
52334: LD_INT 21
52336: ST_TO_ADDR
// hc_gallery :=  ;
52337: LD_ADDR_OWVAR 33
52341: PUSH
52342: LD_STRING 
52344: ST_TO_ADDR
// animal := CreateHuman ;
52345: LD_ADDR_VAR 0 12
52349: PUSH
52350: CALL_OW 44
52354: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52355: LD_VAR 0 12
52359: PPUSH
52360: LD_VAR 0 8
52364: PPUSH
52365: LD_INT 0
52367: PPUSH
52368: CALL 54447 0 3
// end ;
52372: GO 52326
52374: POP
52375: POP
// if birds then
52376: LD_VAR 0 1
52380: IFFALSE 52447
// for i = 1 to birds do
52382: LD_ADDR_VAR 0 11
52386: PUSH
52387: DOUBLE
52388: LD_INT 1
52390: DEC
52391: ST_TO_ADDR
52392: LD_VAR 0 1
52396: PUSH
52397: FOR_TO
52398: IFFALSE 52445
// begin hc_class := 18 ;
52400: LD_ADDR_OWVAR 28
52404: PUSH
52405: LD_INT 18
52407: ST_TO_ADDR
// hc_gallery =  ;
52408: LD_ADDR_OWVAR 33
52412: PUSH
52413: LD_STRING 
52415: ST_TO_ADDR
// animal := CreateHuman ;
52416: LD_ADDR_VAR 0 12
52420: PUSH
52421: CALL_OW 44
52425: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52426: LD_VAR 0 12
52430: PPUSH
52431: LD_VAR 0 8
52435: PPUSH
52436: LD_INT 0
52438: PPUSH
52439: CALL 54447 0 3
// end ;
52443: GO 52397
52445: POP
52446: POP
// if tigers then
52447: LD_VAR 0 2
52451: IFFALSE 52535
// for i = 1 to tigers do
52453: LD_ADDR_VAR 0 11
52457: PUSH
52458: DOUBLE
52459: LD_INT 1
52461: DEC
52462: ST_TO_ADDR
52463: LD_VAR 0 2
52467: PUSH
52468: FOR_TO
52469: IFFALSE 52533
// begin hc_class = class_tiger ;
52471: LD_ADDR_OWVAR 28
52475: PUSH
52476: LD_INT 14
52478: ST_TO_ADDR
// hc_gallery =  ;
52479: LD_ADDR_OWVAR 33
52483: PUSH
52484: LD_STRING 
52486: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52487: LD_ADDR_OWVAR 35
52491: PUSH
52492: LD_INT 7
52494: NEG
52495: PPUSH
52496: LD_INT 7
52498: PPUSH
52499: CALL_OW 12
52503: ST_TO_ADDR
// animal := CreateHuman ;
52504: LD_ADDR_VAR 0 12
52508: PUSH
52509: CALL_OW 44
52513: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52514: LD_VAR 0 12
52518: PPUSH
52519: LD_VAR 0 8
52523: PPUSH
52524: LD_INT 0
52526: PPUSH
52527: CALL 54447 0 3
// end ;
52531: GO 52468
52533: POP
52534: POP
// if apemans then
52535: LD_VAR 0 3
52539: IFFALSE 52662
// for i = 1 to apemans do
52541: LD_ADDR_VAR 0 11
52545: PUSH
52546: DOUBLE
52547: LD_INT 1
52549: DEC
52550: ST_TO_ADDR
52551: LD_VAR 0 3
52555: PUSH
52556: FOR_TO
52557: IFFALSE 52660
// begin hc_class = class_apeman ;
52559: LD_ADDR_OWVAR 28
52563: PUSH
52564: LD_INT 12
52566: ST_TO_ADDR
// hc_gallery =  ;
52567: LD_ADDR_OWVAR 33
52571: PUSH
52572: LD_STRING 
52574: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52575: LD_ADDR_OWVAR 35
52579: PUSH
52580: LD_INT 2
52582: NEG
52583: PPUSH
52584: LD_INT 2
52586: PPUSH
52587: CALL_OW 12
52591: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52592: LD_ADDR_OWVAR 31
52596: PUSH
52597: LD_INT 1
52599: PPUSH
52600: LD_INT 3
52602: PPUSH
52603: CALL_OW 12
52607: PUSH
52608: LD_INT 1
52610: PPUSH
52611: LD_INT 3
52613: PPUSH
52614: CALL_OW 12
52618: PUSH
52619: LD_INT 0
52621: PUSH
52622: LD_INT 0
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: LIST
52629: LIST
52630: ST_TO_ADDR
// animal := CreateHuman ;
52631: LD_ADDR_VAR 0 12
52635: PUSH
52636: CALL_OW 44
52640: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52641: LD_VAR 0 12
52645: PPUSH
52646: LD_VAR 0 8
52650: PPUSH
52651: LD_INT 0
52653: PPUSH
52654: CALL 54447 0 3
// end ;
52658: GO 52556
52660: POP
52661: POP
// if enchidnas then
52662: LD_VAR 0 4
52666: IFFALSE 52733
// for i = 1 to enchidnas do
52668: LD_ADDR_VAR 0 11
52672: PUSH
52673: DOUBLE
52674: LD_INT 1
52676: DEC
52677: ST_TO_ADDR
52678: LD_VAR 0 4
52682: PUSH
52683: FOR_TO
52684: IFFALSE 52731
// begin hc_class = 13 ;
52686: LD_ADDR_OWVAR 28
52690: PUSH
52691: LD_INT 13
52693: ST_TO_ADDR
// hc_gallery =  ;
52694: LD_ADDR_OWVAR 33
52698: PUSH
52699: LD_STRING 
52701: ST_TO_ADDR
// animal := CreateHuman ;
52702: LD_ADDR_VAR 0 12
52706: PUSH
52707: CALL_OW 44
52711: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52712: LD_VAR 0 12
52716: PPUSH
52717: LD_VAR 0 8
52721: PPUSH
52722: LD_INT 0
52724: PPUSH
52725: CALL 54447 0 3
// end ;
52729: GO 52683
52731: POP
52732: POP
// if fishes then
52733: LD_VAR 0 7
52737: IFFALSE 52804
// for i = 1 to fishes do
52739: LD_ADDR_VAR 0 11
52743: PUSH
52744: DOUBLE
52745: LD_INT 1
52747: DEC
52748: ST_TO_ADDR
52749: LD_VAR 0 7
52753: PUSH
52754: FOR_TO
52755: IFFALSE 52802
// begin hc_class = 20 ;
52757: LD_ADDR_OWVAR 28
52761: PUSH
52762: LD_INT 20
52764: ST_TO_ADDR
// hc_gallery =  ;
52765: LD_ADDR_OWVAR 33
52769: PUSH
52770: LD_STRING 
52772: ST_TO_ADDR
// animal := CreateHuman ;
52773: LD_ADDR_VAR 0 12
52777: PUSH
52778: CALL_OW 44
52782: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52783: LD_VAR 0 12
52787: PPUSH
52788: LD_VAR 0 9
52792: PPUSH
52793: LD_INT 0
52795: PPUSH
52796: CALL 54447 0 3
// end ;
52800: GO 52754
52802: POP
52803: POP
// end ;
52804: LD_VAR 0 10
52808: RET
// export function WantHeal ( sci , unit ) ; begin
52809: LD_INT 0
52811: PPUSH
// if GetTaskList ( sci ) > 0 then
52812: LD_VAR 0 1
52816: PPUSH
52817: CALL_OW 437
52821: PUSH
52822: LD_INT 0
52824: GREATER
52825: IFFALSE 52897
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52827: LD_VAR 0 1
52831: PPUSH
52832: CALL_OW 437
52836: PUSH
52837: LD_INT 1
52839: ARRAY
52840: PUSH
52841: LD_INT 1
52843: ARRAY
52844: PUSH
52845: LD_STRING l
52847: EQUAL
52848: IFFALSE 52875
52850: PUSH
52851: LD_VAR 0 1
52855: PPUSH
52856: CALL_OW 437
52860: PUSH
52861: LD_INT 1
52863: ARRAY
52864: PUSH
52865: LD_INT 4
52867: ARRAY
52868: PUSH
52869: LD_VAR 0 2
52873: EQUAL
52874: AND
52875: IFFALSE 52887
// result := true else
52877: LD_ADDR_VAR 0 3
52881: PUSH
52882: LD_INT 1
52884: ST_TO_ADDR
52885: GO 52895
// result := false ;
52887: LD_ADDR_VAR 0 3
52891: PUSH
52892: LD_INT 0
52894: ST_TO_ADDR
// end else
52895: GO 52905
// result := false ;
52897: LD_ADDR_VAR 0 3
52901: PUSH
52902: LD_INT 0
52904: ST_TO_ADDR
// end ;
52905: LD_VAR 0 3
52909: RET
// export function HealTarget ( sci ) ; begin
52910: LD_INT 0
52912: PPUSH
// if not sci then
52913: LD_VAR 0 1
52917: NOT
52918: IFFALSE 52922
// exit ;
52920: GO 52987
// result := 0 ;
52922: LD_ADDR_VAR 0 2
52926: PUSH
52927: LD_INT 0
52929: ST_TO_ADDR
// if GetTaskList ( sci ) then
52930: LD_VAR 0 1
52934: PPUSH
52935: CALL_OW 437
52939: IFFALSE 52987
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52941: LD_VAR 0 1
52945: PPUSH
52946: CALL_OW 437
52950: PUSH
52951: LD_INT 1
52953: ARRAY
52954: PUSH
52955: LD_INT 1
52957: ARRAY
52958: PUSH
52959: LD_STRING l
52961: EQUAL
52962: IFFALSE 52987
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52964: LD_ADDR_VAR 0 2
52968: PUSH
52969: LD_VAR 0 1
52973: PPUSH
52974: CALL_OW 437
52978: PUSH
52979: LD_INT 1
52981: ARRAY
52982: PUSH
52983: LD_INT 4
52985: ARRAY
52986: ST_TO_ADDR
// end ;
52987: LD_VAR 0 2
52991: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52992: LD_INT 0
52994: PPUSH
52995: PPUSH
52996: PPUSH
52997: PPUSH
// if not base_units then
52998: LD_VAR 0 1
53002: NOT
53003: IFFALSE 53007
// exit ;
53005: GO 53094
// result := false ;
53007: LD_ADDR_VAR 0 2
53011: PUSH
53012: LD_INT 0
53014: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53015: LD_ADDR_VAR 0 5
53019: PUSH
53020: LD_VAR 0 1
53024: PPUSH
53025: LD_INT 21
53027: PUSH
53028: LD_INT 3
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: PPUSH
53035: CALL_OW 72
53039: ST_TO_ADDR
// if not tmp then
53040: LD_VAR 0 5
53044: NOT
53045: IFFALSE 53049
// exit ;
53047: GO 53094
// for i in tmp do
53049: LD_ADDR_VAR 0 3
53053: PUSH
53054: LD_VAR 0 5
53058: PUSH
53059: FOR_IN
53060: IFFALSE 53092
// begin result := EnemyInRange ( i , 22 ) ;
53062: LD_ADDR_VAR 0 2
53066: PUSH
53067: LD_VAR 0 3
53071: PPUSH
53072: LD_INT 22
53074: PPUSH
53075: CALL 50519 0 2
53079: ST_TO_ADDR
// if result then
53080: LD_VAR 0 2
53084: IFFALSE 53090
// exit ;
53086: POP
53087: POP
53088: GO 53094
// end ;
53090: GO 53059
53092: POP
53093: POP
// end ;
53094: LD_VAR 0 2
53098: RET
// export function FilterByTag ( units , tag ) ; begin
53099: LD_INT 0
53101: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
53102: LD_ADDR_VAR 0 3
53106: PUSH
53107: LD_VAR 0 1
53111: PPUSH
53112: LD_INT 120
53114: PUSH
53115: LD_VAR 0 2
53119: PUSH
53120: EMPTY
53121: LIST
53122: LIST
53123: PPUSH
53124: CALL_OW 72
53128: ST_TO_ADDR
// end ;
53129: LD_VAR 0 3
53133: RET
// export function IsDriver ( un ) ; begin
53134: LD_INT 0
53136: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53137: LD_ADDR_VAR 0 2
53141: PUSH
53142: LD_VAR 0 1
53146: PUSH
53147: LD_INT 55
53149: PUSH
53150: EMPTY
53151: LIST
53152: PPUSH
53153: CALL_OW 69
53157: IN
53158: ST_TO_ADDR
// end ;
53159: LD_VAR 0 2
53163: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
53164: LD_INT 0
53166: PPUSH
53167: PPUSH
// list := [ ] ;
53168: LD_ADDR_VAR 0 5
53172: PUSH
53173: EMPTY
53174: ST_TO_ADDR
// case d of 0 :
53175: LD_VAR 0 3
53179: PUSH
53180: LD_INT 0
53182: DOUBLE
53183: EQUAL
53184: IFTRUE 53188
53186: GO 53321
53188: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
53189: LD_ADDR_VAR 0 5
53193: PUSH
53194: LD_VAR 0 1
53198: PUSH
53199: LD_INT 4
53201: MINUS
53202: PUSH
53203: LD_VAR 0 2
53207: PUSH
53208: LD_INT 4
53210: MINUS
53211: PUSH
53212: LD_INT 2
53214: PUSH
53215: EMPTY
53216: LIST
53217: LIST
53218: LIST
53219: PUSH
53220: LD_VAR 0 1
53224: PUSH
53225: LD_INT 3
53227: MINUS
53228: PUSH
53229: LD_VAR 0 2
53233: PUSH
53234: LD_INT 1
53236: PUSH
53237: EMPTY
53238: LIST
53239: LIST
53240: LIST
53241: PUSH
53242: LD_VAR 0 1
53246: PUSH
53247: LD_INT 4
53249: PLUS
53250: PUSH
53251: LD_VAR 0 2
53255: PUSH
53256: LD_INT 4
53258: PUSH
53259: EMPTY
53260: LIST
53261: LIST
53262: LIST
53263: PUSH
53264: LD_VAR 0 1
53268: PUSH
53269: LD_INT 3
53271: PLUS
53272: PUSH
53273: LD_VAR 0 2
53277: PUSH
53278: LD_INT 3
53280: PLUS
53281: PUSH
53282: LD_INT 5
53284: PUSH
53285: EMPTY
53286: LIST
53287: LIST
53288: LIST
53289: PUSH
53290: LD_VAR 0 1
53294: PUSH
53295: LD_VAR 0 2
53299: PUSH
53300: LD_INT 4
53302: PLUS
53303: PUSH
53304: LD_INT 0
53306: PUSH
53307: EMPTY
53308: LIST
53309: LIST
53310: LIST
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: ST_TO_ADDR
// end ; 1 :
53319: GO 54019
53321: LD_INT 1
53323: DOUBLE
53324: EQUAL
53325: IFTRUE 53329
53327: GO 53462
53329: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
53330: LD_ADDR_VAR 0 5
53334: PUSH
53335: LD_VAR 0 1
53339: PUSH
53340: LD_VAR 0 2
53344: PUSH
53345: LD_INT 4
53347: MINUS
53348: PUSH
53349: LD_INT 3
53351: PUSH
53352: EMPTY
53353: LIST
53354: LIST
53355: LIST
53356: PUSH
53357: LD_VAR 0 1
53361: PUSH
53362: LD_INT 3
53364: MINUS
53365: PUSH
53366: LD_VAR 0 2
53370: PUSH
53371: LD_INT 3
53373: MINUS
53374: PUSH
53375: LD_INT 2
53377: PUSH
53378: EMPTY
53379: LIST
53380: LIST
53381: LIST
53382: PUSH
53383: LD_VAR 0 1
53387: PUSH
53388: LD_INT 4
53390: MINUS
53391: PUSH
53392: LD_VAR 0 2
53396: PUSH
53397: LD_INT 1
53399: PUSH
53400: EMPTY
53401: LIST
53402: LIST
53403: LIST
53404: PUSH
53405: LD_VAR 0 1
53409: PUSH
53410: LD_VAR 0 2
53414: PUSH
53415: LD_INT 3
53417: PLUS
53418: PUSH
53419: LD_INT 0
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: LIST
53426: PUSH
53427: LD_VAR 0 1
53431: PUSH
53432: LD_INT 4
53434: PLUS
53435: PUSH
53436: LD_VAR 0 2
53440: PUSH
53441: LD_INT 4
53443: PLUS
53444: PUSH
53445: LD_INT 5
53447: PUSH
53448: EMPTY
53449: LIST
53450: LIST
53451: LIST
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: LIST
53458: LIST
53459: ST_TO_ADDR
// end ; 2 :
53460: GO 54019
53462: LD_INT 2
53464: DOUBLE
53465: EQUAL
53466: IFTRUE 53470
53468: GO 53599
53470: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53471: LD_ADDR_VAR 0 5
53475: PUSH
53476: LD_VAR 0 1
53480: PUSH
53481: LD_VAR 0 2
53485: PUSH
53486: LD_INT 3
53488: MINUS
53489: PUSH
53490: LD_INT 3
53492: PUSH
53493: EMPTY
53494: LIST
53495: LIST
53496: LIST
53497: PUSH
53498: LD_VAR 0 1
53502: PUSH
53503: LD_INT 4
53505: PLUS
53506: PUSH
53507: LD_VAR 0 2
53511: PUSH
53512: LD_INT 4
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: LIST
53519: PUSH
53520: LD_VAR 0 1
53524: PUSH
53525: LD_VAR 0 2
53529: PUSH
53530: LD_INT 4
53532: PLUS
53533: PUSH
53534: LD_INT 0
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: LIST
53541: PUSH
53542: LD_VAR 0 1
53546: PUSH
53547: LD_INT 3
53549: MINUS
53550: PUSH
53551: LD_VAR 0 2
53555: PUSH
53556: LD_INT 1
53558: PUSH
53559: EMPTY
53560: LIST
53561: LIST
53562: LIST
53563: PUSH
53564: LD_VAR 0 1
53568: PUSH
53569: LD_INT 4
53571: MINUS
53572: PUSH
53573: LD_VAR 0 2
53577: PUSH
53578: LD_INT 4
53580: MINUS
53581: PUSH
53582: LD_INT 2
53584: PUSH
53585: EMPTY
53586: LIST
53587: LIST
53588: LIST
53589: PUSH
53590: EMPTY
53591: LIST
53592: LIST
53593: LIST
53594: LIST
53595: LIST
53596: ST_TO_ADDR
// end ; 3 :
53597: GO 54019
53599: LD_INT 3
53601: DOUBLE
53602: EQUAL
53603: IFTRUE 53607
53605: GO 53740
53607: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53608: LD_ADDR_VAR 0 5
53612: PUSH
53613: LD_VAR 0 1
53617: PUSH
53618: LD_INT 3
53620: PLUS
53621: PUSH
53622: LD_VAR 0 2
53626: PUSH
53627: LD_INT 4
53629: PUSH
53630: EMPTY
53631: LIST
53632: LIST
53633: LIST
53634: PUSH
53635: LD_VAR 0 1
53639: PUSH
53640: LD_INT 4
53642: PLUS
53643: PUSH
53644: LD_VAR 0 2
53648: PUSH
53649: LD_INT 4
53651: PLUS
53652: PUSH
53653: LD_INT 5
53655: PUSH
53656: EMPTY
53657: LIST
53658: LIST
53659: LIST
53660: PUSH
53661: LD_VAR 0 1
53665: PUSH
53666: LD_INT 4
53668: MINUS
53669: PUSH
53670: LD_VAR 0 2
53674: PUSH
53675: LD_INT 1
53677: PUSH
53678: EMPTY
53679: LIST
53680: LIST
53681: LIST
53682: PUSH
53683: LD_VAR 0 1
53687: PUSH
53688: LD_VAR 0 2
53692: PUSH
53693: LD_INT 4
53695: MINUS
53696: PUSH
53697: LD_INT 3
53699: PUSH
53700: EMPTY
53701: LIST
53702: LIST
53703: LIST
53704: PUSH
53705: LD_VAR 0 1
53709: PUSH
53710: LD_INT 3
53712: MINUS
53713: PUSH
53714: LD_VAR 0 2
53718: PUSH
53719: LD_INT 3
53721: MINUS
53722: PUSH
53723: LD_INT 2
53725: PUSH
53726: EMPTY
53727: LIST
53728: LIST
53729: LIST
53730: PUSH
53731: EMPTY
53732: LIST
53733: LIST
53734: LIST
53735: LIST
53736: LIST
53737: ST_TO_ADDR
// end ; 4 :
53738: GO 54019
53740: LD_INT 4
53742: DOUBLE
53743: EQUAL
53744: IFTRUE 53748
53746: GO 53881
53748: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53749: LD_ADDR_VAR 0 5
53753: PUSH
53754: LD_VAR 0 1
53758: PUSH
53759: LD_VAR 0 2
53763: PUSH
53764: LD_INT 4
53766: PLUS
53767: PUSH
53768: LD_INT 0
53770: PUSH
53771: EMPTY
53772: LIST
53773: LIST
53774: LIST
53775: PUSH
53776: LD_VAR 0 1
53780: PUSH
53781: LD_INT 3
53783: PLUS
53784: PUSH
53785: LD_VAR 0 2
53789: PUSH
53790: LD_INT 3
53792: PLUS
53793: PUSH
53794: LD_INT 5
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: LIST
53801: PUSH
53802: LD_VAR 0 1
53806: PUSH
53807: LD_INT 4
53809: PLUS
53810: PUSH
53811: LD_VAR 0 2
53815: PUSH
53816: LD_INT 4
53818: PUSH
53819: EMPTY
53820: LIST
53821: LIST
53822: LIST
53823: PUSH
53824: LD_VAR 0 1
53828: PUSH
53829: LD_VAR 0 2
53833: PUSH
53834: LD_INT 3
53836: MINUS
53837: PUSH
53838: LD_INT 3
53840: PUSH
53841: EMPTY
53842: LIST
53843: LIST
53844: LIST
53845: PUSH
53846: LD_VAR 0 1
53850: PUSH
53851: LD_INT 4
53853: MINUS
53854: PUSH
53855: LD_VAR 0 2
53859: PUSH
53860: LD_INT 4
53862: MINUS
53863: PUSH
53864: LD_INT 2
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: LIST
53871: PUSH
53872: EMPTY
53873: LIST
53874: LIST
53875: LIST
53876: LIST
53877: LIST
53878: ST_TO_ADDR
// end ; 5 :
53879: GO 54019
53881: LD_INT 5
53883: DOUBLE
53884: EQUAL
53885: IFTRUE 53889
53887: GO 54018
53889: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53890: LD_ADDR_VAR 0 5
53894: PUSH
53895: LD_VAR 0 1
53899: PUSH
53900: LD_INT 4
53902: MINUS
53903: PUSH
53904: LD_VAR 0 2
53908: PUSH
53909: LD_INT 1
53911: PUSH
53912: EMPTY
53913: LIST
53914: LIST
53915: LIST
53916: PUSH
53917: LD_VAR 0 1
53921: PUSH
53922: LD_VAR 0 2
53926: PUSH
53927: LD_INT 4
53929: MINUS
53930: PUSH
53931: LD_INT 3
53933: PUSH
53934: EMPTY
53935: LIST
53936: LIST
53937: LIST
53938: PUSH
53939: LD_VAR 0 1
53943: PUSH
53944: LD_INT 4
53946: PLUS
53947: PUSH
53948: LD_VAR 0 2
53952: PUSH
53953: LD_INT 4
53955: PLUS
53956: PUSH
53957: LD_INT 5
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: LIST
53964: PUSH
53965: LD_VAR 0 1
53969: PUSH
53970: LD_INT 3
53972: PLUS
53973: PUSH
53974: LD_VAR 0 2
53978: PUSH
53979: LD_INT 4
53981: PUSH
53982: EMPTY
53983: LIST
53984: LIST
53985: LIST
53986: PUSH
53987: LD_VAR 0 1
53991: PUSH
53992: LD_VAR 0 2
53996: PUSH
53997: LD_INT 3
53999: PLUS
54000: PUSH
54001: LD_INT 0
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: LIST
54008: PUSH
54009: EMPTY
54010: LIST
54011: LIST
54012: LIST
54013: LIST
54014: LIST
54015: ST_TO_ADDR
// end ; end ;
54016: GO 54019
54018: POP
// result := list ;
54019: LD_ADDR_VAR 0 4
54023: PUSH
54024: LD_VAR 0 5
54028: ST_TO_ADDR
// end ;
54029: LD_VAR 0 4
54033: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54034: LD_INT 0
54036: PPUSH
54037: PPUSH
54038: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54039: LD_VAR 0 1
54043: NOT
54044: IFTRUE 54072
54046: PUSH
54047: LD_VAR 0 2
54051: PUSH
54052: LD_INT 1
54054: PUSH
54055: LD_INT 2
54057: PUSH
54058: LD_INT 3
54060: PUSH
54061: LD_INT 4
54063: PUSH
54064: EMPTY
54065: LIST
54066: LIST
54067: LIST
54068: LIST
54069: IN
54070: NOT
54071: OR
54072: IFFALSE 54076
// exit ;
54074: GO 54159
// tmp := [ ] ;
54076: LD_ADDR_VAR 0 5
54080: PUSH
54081: EMPTY
54082: ST_TO_ADDR
// for i in units do
54083: LD_ADDR_VAR 0 4
54087: PUSH
54088: LD_VAR 0 1
54092: PUSH
54093: FOR_IN
54094: IFFALSE 54128
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
54096: LD_ADDR_VAR 0 5
54100: PUSH
54101: LD_VAR 0 5
54105: PPUSH
54106: LD_VAR 0 4
54110: PPUSH
54111: LD_VAR 0 2
54115: PPUSH
54116: CALL_OW 259
54120: PPUSH
54121: CALL 55554 0 2
54125: ST_TO_ADDR
54126: GO 54093
54128: POP
54129: POP
// if not tmp then
54130: LD_VAR 0 5
54134: NOT
54135: IFFALSE 54139
// exit ;
54137: GO 54159
// result := SortListByListDesc ( units , tmp ) ;
54139: LD_ADDR_VAR 0 3
54143: PUSH
54144: LD_VAR 0 1
54148: PPUSH
54149: LD_VAR 0 5
54153: PPUSH
54154: CALL_OW 77
54158: ST_TO_ADDR
// end ;
54159: LD_VAR 0 3
54163: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
54164: LD_INT 0
54166: PPUSH
54167: PPUSH
54168: PPUSH
// result := false ;
54169: LD_ADDR_VAR 0 3
54173: PUSH
54174: LD_INT 0
54176: ST_TO_ADDR
// if not building then
54177: LD_VAR 0 2
54181: NOT
54182: IFFALSE 54186
// exit ;
54184: GO 54330
// x := GetX ( building ) ;
54186: LD_ADDR_VAR 0 4
54190: PUSH
54191: LD_VAR 0 2
54195: PPUSH
54196: CALL_OW 250
54200: ST_TO_ADDR
// y := GetY ( building ) ;
54201: LD_ADDR_VAR 0 5
54205: PUSH
54206: LD_VAR 0 2
54210: PPUSH
54211: CALL_OW 251
54215: ST_TO_ADDR
// if not x or not y then
54216: LD_VAR 0 4
54220: NOT
54221: IFTRUE 54230
54223: PUSH
54224: LD_VAR 0 5
54228: NOT
54229: OR
54230: IFFALSE 54234
// exit ;
54232: GO 54330
// if GetTaskList ( unit ) then
54234: LD_VAR 0 1
54238: PPUSH
54239: CALL_OW 437
54243: IFFALSE 54330
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54245: LD_STRING e
54247: PUSH
54248: LD_VAR 0 1
54252: PPUSH
54253: CALL_OW 437
54257: PUSH
54258: LD_INT 1
54260: ARRAY
54261: PUSH
54262: LD_INT 1
54264: ARRAY
54265: EQUAL
54266: IFFALSE 54293
54268: PUSH
54269: LD_VAR 0 4
54273: PUSH
54274: LD_VAR 0 1
54278: PPUSH
54279: CALL_OW 437
54283: PUSH
54284: LD_INT 1
54286: ARRAY
54287: PUSH
54288: LD_INT 2
54290: ARRAY
54291: EQUAL
54292: AND
54293: IFFALSE 54320
54295: PUSH
54296: LD_VAR 0 5
54300: PUSH
54301: LD_VAR 0 1
54305: PPUSH
54306: CALL_OW 437
54310: PUSH
54311: LD_INT 1
54313: ARRAY
54314: PUSH
54315: LD_INT 3
54317: ARRAY
54318: EQUAL
54319: AND
54320: IFFALSE 54330
// result := true end ;
54322: LD_ADDR_VAR 0 3
54326: PUSH
54327: LD_INT 1
54329: ST_TO_ADDR
// end ;
54330: LD_VAR 0 3
54334: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
54335: LD_INT 0
54337: PPUSH
// result := false ;
54338: LD_ADDR_VAR 0 4
54342: PUSH
54343: LD_INT 0
54345: ST_TO_ADDR
// if GetTaskList ( unit ) then
54346: LD_VAR 0 1
54350: PPUSH
54351: CALL_OW 437
54355: IFFALSE 54442
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
54357: LD_STRING M
54359: PUSH
54360: LD_VAR 0 1
54364: PPUSH
54365: CALL_OW 437
54369: PUSH
54370: LD_INT 1
54372: ARRAY
54373: PUSH
54374: LD_INT 1
54376: ARRAY
54377: EQUAL
54378: IFFALSE 54405
54380: PUSH
54381: LD_VAR 0 2
54385: PUSH
54386: LD_VAR 0 1
54390: PPUSH
54391: CALL_OW 437
54395: PUSH
54396: LD_INT 1
54398: ARRAY
54399: PUSH
54400: LD_INT 2
54402: ARRAY
54403: EQUAL
54404: AND
54405: IFFALSE 54432
54407: PUSH
54408: LD_VAR 0 3
54412: PUSH
54413: LD_VAR 0 1
54417: PPUSH
54418: CALL_OW 437
54422: PUSH
54423: LD_INT 1
54425: ARRAY
54426: PUSH
54427: LD_INT 3
54429: ARRAY
54430: EQUAL
54431: AND
54432: IFFALSE 54442
// result := true ;
54434: LD_ADDR_VAR 0 4
54438: PUSH
54439: LD_INT 1
54441: ST_TO_ADDR
// end ; end ;
54442: LD_VAR 0 4
54446: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
54447: LD_INT 0
54449: PPUSH
54450: PPUSH
54451: PPUSH
54452: PPUSH
// if not unit or not area then
54453: LD_VAR 0 1
54457: NOT
54458: IFTRUE 54467
54460: PUSH
54461: LD_VAR 0 2
54465: NOT
54466: OR
54467: IFFALSE 54471
// exit ;
54469: GO 54647
// tmp := AreaToList ( area , i ) ;
54471: LD_ADDR_VAR 0 6
54475: PUSH
54476: LD_VAR 0 2
54480: PPUSH
54481: LD_VAR 0 5
54485: PPUSH
54486: CALL_OW 517
54490: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54491: LD_ADDR_VAR 0 5
54495: PUSH
54496: DOUBLE
54497: LD_INT 1
54499: DEC
54500: ST_TO_ADDR
54501: LD_VAR 0 6
54505: PUSH
54506: LD_INT 1
54508: ARRAY
54509: PUSH
54510: FOR_TO
54511: IFFALSE 54645
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54513: LD_ADDR_VAR 0 7
54517: PUSH
54518: LD_VAR 0 6
54522: PUSH
54523: LD_INT 1
54525: ARRAY
54526: PUSH
54527: LD_VAR 0 5
54531: ARRAY
54532: PUSH
54533: LD_VAR 0 6
54537: PUSH
54538: LD_INT 2
54540: ARRAY
54541: PUSH
54542: LD_VAR 0 5
54546: ARRAY
54547: PUSH
54548: EMPTY
54549: LIST
54550: LIST
54551: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
54552: LD_INT 92
54554: PUSH
54555: LD_VAR 0 7
54559: PUSH
54560: LD_INT 1
54562: ARRAY
54563: PUSH
54564: LD_VAR 0 7
54568: PUSH
54569: LD_INT 2
54571: ARRAY
54572: PUSH
54573: LD_INT 2
54575: PUSH
54576: EMPTY
54577: LIST
54578: LIST
54579: LIST
54580: LIST
54581: PPUSH
54582: CALL_OW 69
54586: PUSH
54587: LD_INT 0
54589: EQUAL
54590: IFFALSE 54643
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54592: LD_VAR 0 1
54596: PPUSH
54597: LD_VAR 0 7
54601: PUSH
54602: LD_INT 1
54604: ARRAY
54605: PPUSH
54606: LD_VAR 0 7
54610: PUSH
54611: LD_INT 2
54613: ARRAY
54614: PPUSH
54615: LD_VAR 0 3
54619: PPUSH
54620: CALL_OW 48
// result := IsPlaced ( unit ) ;
54624: LD_ADDR_VAR 0 4
54628: PUSH
54629: LD_VAR 0 1
54633: PPUSH
54634: CALL_OW 305
54638: ST_TO_ADDR
// exit ;
54639: POP
54640: POP
54641: GO 54647
// end ; end ;
54643: GO 54510
54645: POP
54646: POP
// end ;
54647: LD_VAR 0 4
54651: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54652: LD_INT 0
54654: PPUSH
54655: PPUSH
54656: PPUSH
// if not side or side > 8 then
54657: LD_VAR 0 1
54661: NOT
54662: IFTRUE 54674
54664: PUSH
54665: LD_VAR 0 1
54669: PUSH
54670: LD_INT 8
54672: GREATER
54673: OR
54674: IFFALSE 54678
// exit ;
54676: GO 54865
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54678: LD_ADDR_VAR 0 4
54682: PUSH
54683: LD_INT 22
54685: PUSH
54686: LD_VAR 0 1
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: PUSH
54695: LD_INT 21
54697: PUSH
54698: LD_INT 3
54700: PUSH
54701: EMPTY
54702: LIST
54703: LIST
54704: PUSH
54705: EMPTY
54706: LIST
54707: LIST
54708: PPUSH
54709: CALL_OW 69
54713: ST_TO_ADDR
// if not tmp then
54714: LD_VAR 0 4
54718: NOT
54719: IFFALSE 54723
// exit ;
54721: GO 54865
// enable_addtolog := true ;
54723: LD_ADDR_OWVAR 81
54727: PUSH
54728: LD_INT 1
54730: ST_TO_ADDR
// AddToLog ( [ ) ;
54731: LD_STRING [
54733: PPUSH
54734: CALL_OW 561
// for i in tmp do
54738: LD_ADDR_VAR 0 3
54742: PUSH
54743: LD_VAR 0 4
54747: PUSH
54748: FOR_IN
54749: IFFALSE 54856
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54751: LD_STRING [
54753: PUSH
54754: LD_VAR 0 3
54758: PPUSH
54759: CALL_OW 266
54763: STR
54764: PUSH
54765: LD_STRING , 
54767: STR
54768: PUSH
54769: LD_VAR 0 3
54773: PPUSH
54774: CALL_OW 250
54778: STR
54779: PUSH
54780: LD_STRING , 
54782: STR
54783: PUSH
54784: LD_VAR 0 3
54788: PPUSH
54789: CALL_OW 251
54793: STR
54794: PUSH
54795: LD_STRING , 
54797: STR
54798: PUSH
54799: LD_VAR 0 3
54803: PPUSH
54804: CALL_OW 254
54808: STR
54809: PUSH
54810: LD_STRING , 
54812: STR
54813: PUSH
54814: LD_VAR 0 3
54818: PPUSH
54819: LD_INT 1
54821: PPUSH
54822: CALL_OW 268
54826: STR
54827: PUSH
54828: LD_STRING , 
54830: STR
54831: PUSH
54832: LD_VAR 0 3
54836: PPUSH
54837: LD_INT 2
54839: PPUSH
54840: CALL_OW 268
54844: STR
54845: PUSH
54846: LD_STRING ],
54848: STR
54849: PPUSH
54850: CALL_OW 561
// end ;
54854: GO 54748
54856: POP
54857: POP
// AddToLog ( ]; ) ;
54858: LD_STRING ];
54860: PPUSH
54861: CALL_OW 561
// end ;
54865: LD_VAR 0 2
54869: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54870: LD_INT 0
54872: PPUSH
54873: PPUSH
54874: PPUSH
54875: PPUSH
54876: PPUSH
// if not area or not rate or not max then
54877: LD_VAR 0 1
54881: NOT
54882: IFTRUE 54891
54884: PUSH
54885: LD_VAR 0 2
54889: NOT
54890: OR
54891: IFTRUE 54900
54893: PUSH
54894: LD_VAR 0 4
54898: NOT
54899: OR
54900: IFFALSE 54904
// exit ;
54902: GO 55093
// while 1 do
54904: LD_INT 1
54906: IFFALSE 55093
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54908: LD_ADDR_VAR 0 9
54912: PUSH
54913: LD_VAR 0 1
54917: PPUSH
54918: LD_INT 1
54920: PPUSH
54921: CALL_OW 287
54925: PUSH
54926: LD_INT 10
54928: MUL
54929: ST_TO_ADDR
// r := rate / 10 ;
54930: LD_ADDR_VAR 0 7
54934: PUSH
54935: LD_VAR 0 2
54939: PUSH
54940: LD_INT 10
54942: DIVREAL
54943: ST_TO_ADDR
// time := 1 1$00 ;
54944: LD_ADDR_VAR 0 8
54948: PUSH
54949: LD_INT 2100
54951: ST_TO_ADDR
// if amount < min then
54952: LD_VAR 0 9
54956: PUSH
54957: LD_VAR 0 3
54961: LESS
54962: IFFALSE 54980
// r := r * 2 else
54964: LD_ADDR_VAR 0 7
54968: PUSH
54969: LD_VAR 0 7
54973: PUSH
54974: LD_INT 2
54976: MUL
54977: ST_TO_ADDR
54978: GO 55006
// if amount > max then
54980: LD_VAR 0 9
54984: PUSH
54985: LD_VAR 0 4
54989: GREATER
54990: IFFALSE 55006
// r := r / 2 ;
54992: LD_ADDR_VAR 0 7
54996: PUSH
54997: LD_VAR 0 7
55001: PUSH
55002: LD_INT 2
55004: DIVREAL
55005: ST_TO_ADDR
// time := time / r ;
55006: LD_ADDR_VAR 0 8
55010: PUSH
55011: LD_VAR 0 8
55015: PUSH
55016: LD_VAR 0 7
55020: DIVREAL
55021: ST_TO_ADDR
// if time < 0 then
55022: LD_VAR 0 8
55026: PUSH
55027: LD_INT 0
55029: LESS
55030: IFFALSE 55047
// time := time * - 1 ;
55032: LD_ADDR_VAR 0 8
55036: PUSH
55037: LD_VAR 0 8
55041: PUSH
55042: LD_INT 1
55044: NEG
55045: MUL
55046: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
55047: LD_VAR 0 8
55051: PUSH
55052: LD_INT 35
55054: PPUSH
55055: LD_INT 875
55057: PPUSH
55058: CALL_OW 12
55062: PLUS
55063: PPUSH
55064: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55068: LD_INT 1
55070: PPUSH
55071: LD_INT 5
55073: PPUSH
55074: CALL_OW 12
55078: PPUSH
55079: LD_VAR 0 1
55083: PPUSH
55084: LD_INT 1
55086: PPUSH
55087: CALL_OW 55
// end ;
55091: GO 54904
// end ;
55093: LD_VAR 0 5
55097: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55098: LD_INT 0
55100: PPUSH
55101: PPUSH
55102: PPUSH
55103: PPUSH
55104: PPUSH
55105: PPUSH
55106: PPUSH
55107: PPUSH
// if not turrets or not factories then
55108: LD_VAR 0 1
55112: NOT
55113: IFTRUE 55122
55115: PUSH
55116: LD_VAR 0 2
55120: NOT
55121: OR
55122: IFFALSE 55126
// exit ;
55124: GO 55433
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55126: LD_ADDR_VAR 0 10
55130: PUSH
55131: LD_INT 5
55133: PUSH
55134: LD_INT 6
55136: PUSH
55137: EMPTY
55138: LIST
55139: LIST
55140: PUSH
55141: LD_INT 2
55143: PUSH
55144: LD_INT 4
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: PUSH
55151: LD_INT 3
55153: PUSH
55154: LD_INT 5
55156: PUSH
55157: EMPTY
55158: LIST
55159: LIST
55160: PUSH
55161: EMPTY
55162: LIST
55163: LIST
55164: LIST
55165: PUSH
55166: LD_INT 24
55168: PUSH
55169: LD_INT 25
55171: PUSH
55172: EMPTY
55173: LIST
55174: LIST
55175: PUSH
55176: LD_INT 23
55178: PUSH
55179: LD_INT 27
55181: PUSH
55182: EMPTY
55183: LIST
55184: LIST
55185: PUSH
55186: EMPTY
55187: LIST
55188: LIST
55189: PUSH
55190: LD_INT 42
55192: PUSH
55193: LD_INT 43
55195: PUSH
55196: EMPTY
55197: LIST
55198: LIST
55199: PUSH
55200: LD_INT 44
55202: PUSH
55203: LD_INT 46
55205: PUSH
55206: EMPTY
55207: LIST
55208: LIST
55209: PUSH
55210: LD_INT 45
55212: PUSH
55213: LD_INT 47
55215: PUSH
55216: EMPTY
55217: LIST
55218: LIST
55219: PUSH
55220: EMPTY
55221: LIST
55222: LIST
55223: LIST
55224: PUSH
55225: EMPTY
55226: LIST
55227: LIST
55228: LIST
55229: ST_TO_ADDR
// result := [ ] ;
55230: LD_ADDR_VAR 0 3
55234: PUSH
55235: EMPTY
55236: ST_TO_ADDR
// for i in turrets do
55237: LD_ADDR_VAR 0 4
55241: PUSH
55242: LD_VAR 0 1
55246: PUSH
55247: FOR_IN
55248: IFFALSE 55431
// begin nat := GetNation ( i ) ;
55250: LD_ADDR_VAR 0 7
55254: PUSH
55255: LD_VAR 0 4
55259: PPUSH
55260: CALL_OW 248
55264: ST_TO_ADDR
// weapon := 0 ;
55265: LD_ADDR_VAR 0 8
55269: PUSH
55270: LD_INT 0
55272: ST_TO_ADDR
// if not nat then
55273: LD_VAR 0 7
55277: NOT
55278: IFFALSE 55282
// continue ;
55280: GO 55247
// for j in list [ nat ] do
55282: LD_ADDR_VAR 0 5
55286: PUSH
55287: LD_VAR 0 10
55291: PUSH
55292: LD_VAR 0 7
55296: ARRAY
55297: PUSH
55298: FOR_IN
55299: IFFALSE 55340
// if GetBWeapon ( i ) = j [ 1 ] then
55301: LD_VAR 0 4
55305: PPUSH
55306: CALL_OW 269
55310: PUSH
55311: LD_VAR 0 5
55315: PUSH
55316: LD_INT 1
55318: ARRAY
55319: EQUAL
55320: IFFALSE 55338
// begin weapon := j [ 2 ] ;
55322: LD_ADDR_VAR 0 8
55326: PUSH
55327: LD_VAR 0 5
55331: PUSH
55332: LD_INT 2
55334: ARRAY
55335: ST_TO_ADDR
// break ;
55336: GO 55340
// end ;
55338: GO 55298
55340: POP
55341: POP
// if not weapon then
55342: LD_VAR 0 8
55346: NOT
55347: IFFALSE 55351
// continue ;
55349: GO 55247
// for k in factories do
55351: LD_ADDR_VAR 0 6
55355: PUSH
55356: LD_VAR 0 2
55360: PUSH
55361: FOR_IN
55362: IFFALSE 55427
// begin weapons := AvailableWeaponList ( k ) ;
55364: LD_ADDR_VAR 0 9
55368: PUSH
55369: LD_VAR 0 6
55373: PPUSH
55374: CALL_OW 478
55378: ST_TO_ADDR
// if not weapons then
55379: LD_VAR 0 9
55383: NOT
55384: IFFALSE 55388
// continue ;
55386: GO 55361
// if weapon in weapons then
55388: LD_VAR 0 8
55392: PUSH
55393: LD_VAR 0 9
55397: IN
55398: IFFALSE 55425
// begin result := [ i , weapon ] ;
55400: LD_ADDR_VAR 0 3
55404: PUSH
55405: LD_VAR 0 4
55409: PUSH
55410: LD_VAR 0 8
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: ST_TO_ADDR
// exit ;
55419: POP
55420: POP
55421: POP
55422: POP
55423: GO 55433
// end ; end ;
55425: GO 55361
55427: POP
55428: POP
// end ;
55429: GO 55247
55431: POP
55432: POP
// end ;
55433: LD_VAR 0 3
55437: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
55438: LD_INT 0
55440: PPUSH
// if not side or side > 8 then
55441: LD_VAR 0 3
55445: NOT
55446: IFTRUE 55458
55448: PUSH
55449: LD_VAR 0 3
55453: PUSH
55454: LD_INT 8
55456: GREATER
55457: OR
55458: IFFALSE 55462
// exit ;
55460: GO 55521
// if not range then
55462: LD_VAR 0 4
55466: NOT
55467: IFFALSE 55478
// range := - 12 ;
55469: LD_ADDR_VAR 0 4
55473: PUSH
55474: LD_INT 12
55476: NEG
55477: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
55478: LD_VAR 0 1
55482: PPUSH
55483: LD_VAR 0 2
55487: PPUSH
55488: LD_VAR 0 3
55492: PPUSH
55493: LD_VAR 0 4
55497: PPUSH
55498: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55502: LD_VAR 0 1
55506: PPUSH
55507: LD_VAR 0 2
55511: PPUSH
55512: LD_VAR 0 3
55516: PPUSH
55517: CALL_OW 331
// end ;
55521: LD_VAR 0 5
55525: RET
// export function Video ( mode ) ; begin
55526: LD_INT 0
55528: PPUSH
// ingame_video = mode ;
55529: LD_ADDR_OWVAR 52
55533: PUSH
55534: LD_VAR 0 1
55538: ST_TO_ADDR
// interface_hidden = mode ;
55539: LD_ADDR_OWVAR 54
55543: PUSH
55544: LD_VAR 0 1
55548: ST_TO_ADDR
// end ;
55549: LD_VAR 0 2
55553: RET
// export function Join ( array , element ) ; begin
55554: LD_INT 0
55556: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55557: LD_ADDR_VAR 0 3
55561: PUSH
55562: LD_VAR 0 1
55566: PPUSH
55567: LD_VAR 0 1
55571: PUSH
55572: LD_INT 1
55574: PLUS
55575: PPUSH
55576: LD_VAR 0 2
55580: PPUSH
55581: CALL_OW 1
55585: ST_TO_ADDR
// end ;
55586: LD_VAR 0 3
55590: RET
// export function JoinUnion ( array , element ) ; begin
55591: LD_INT 0
55593: PPUSH
// result := array union element ;
55594: LD_ADDR_VAR 0 3
55598: PUSH
55599: LD_VAR 0 1
55603: PUSH
55604: LD_VAR 0 2
55608: UNION
55609: ST_TO_ADDR
// end ;
55610: LD_VAR 0 3
55614: RET
// export function GetBehemoths ( side ) ; begin
55615: LD_INT 0
55617: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55618: LD_ADDR_VAR 0 2
55622: PUSH
55623: LD_INT 22
55625: PUSH
55626: LD_VAR 0 1
55630: PUSH
55631: EMPTY
55632: LIST
55633: LIST
55634: PUSH
55635: LD_INT 31
55637: PUSH
55638: LD_INT 25
55640: PUSH
55641: EMPTY
55642: LIST
55643: LIST
55644: PUSH
55645: EMPTY
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL_OW 69
55653: ST_TO_ADDR
// end ;
55654: LD_VAR 0 2
55658: RET
// export function Shuffle ( array ) ; var i , index ; begin
55659: LD_INT 0
55661: PPUSH
55662: PPUSH
55663: PPUSH
// result := [ ] ;
55664: LD_ADDR_VAR 0 2
55668: PUSH
55669: EMPTY
55670: ST_TO_ADDR
// if not array then
55671: LD_VAR 0 1
55675: NOT
55676: IFFALSE 55680
// exit ;
55678: GO 55779
// Randomize ;
55680: CALL_OW 10
// for i = array downto 1 do
55684: LD_ADDR_VAR 0 3
55688: PUSH
55689: DOUBLE
55690: LD_VAR 0 1
55694: INC
55695: ST_TO_ADDR
55696: LD_INT 1
55698: PUSH
55699: FOR_DOWNTO
55700: IFFALSE 55777
// begin index := rand ( 1 , array ) ;
55702: LD_ADDR_VAR 0 4
55706: PUSH
55707: LD_INT 1
55709: PPUSH
55710: LD_VAR 0 1
55714: PPUSH
55715: CALL_OW 12
55719: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55720: LD_ADDR_VAR 0 2
55724: PUSH
55725: LD_VAR 0 2
55729: PPUSH
55730: LD_VAR 0 2
55734: PUSH
55735: LD_INT 1
55737: PLUS
55738: PPUSH
55739: LD_VAR 0 1
55743: PUSH
55744: LD_VAR 0 4
55748: ARRAY
55749: PPUSH
55750: CALL_OW 2
55754: ST_TO_ADDR
// array := Delete ( array , index ) ;
55755: LD_ADDR_VAR 0 1
55759: PUSH
55760: LD_VAR 0 1
55764: PPUSH
55765: LD_VAR 0 4
55769: PPUSH
55770: CALL_OW 3
55774: ST_TO_ADDR
// end ;
55775: GO 55699
55777: POP
55778: POP
// end ;
55779: LD_VAR 0 2
55783: RET
// export function GetBaseMaterials ( base ) ; begin
55784: LD_INT 0
55786: PPUSH
// result := [ 0 , 0 , 0 ] ;
55787: LD_ADDR_VAR 0 2
55791: PUSH
55792: LD_INT 0
55794: PUSH
55795: LD_INT 0
55797: PUSH
55798: LD_INT 0
55800: PUSH
55801: EMPTY
55802: LIST
55803: LIST
55804: LIST
55805: ST_TO_ADDR
// if not base then
55806: LD_VAR 0 1
55810: NOT
55811: IFFALSE 55815
// exit ;
55813: GO 55864
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55815: LD_ADDR_VAR 0 2
55819: PUSH
55820: LD_VAR 0 1
55824: PPUSH
55825: LD_INT 1
55827: PPUSH
55828: CALL_OW 275
55832: PUSH
55833: LD_VAR 0 1
55837: PPUSH
55838: LD_INT 2
55840: PPUSH
55841: CALL_OW 275
55845: PUSH
55846: LD_VAR 0 1
55850: PPUSH
55851: LD_INT 3
55853: PPUSH
55854: CALL_OW 275
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
// end ;
55864: LD_VAR 0 2
55868: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55869: LD_INT 0
55871: PPUSH
55872: PPUSH
// result := array ;
55873: LD_ADDR_VAR 0 3
55877: PUSH
55878: LD_VAR 0 1
55882: ST_TO_ADDR
// if size >= result then
55883: LD_VAR 0 2
55887: PUSH
55888: LD_VAR 0 3
55892: GREATEREQUAL
55893: IFFALSE 55897
// exit ;
55895: GO 55947
// if size then
55897: LD_VAR 0 2
55901: IFFALSE 55947
// for i := array downto size do
55903: LD_ADDR_VAR 0 4
55907: PUSH
55908: DOUBLE
55909: LD_VAR 0 1
55913: INC
55914: ST_TO_ADDR
55915: LD_VAR 0 2
55919: PUSH
55920: FOR_DOWNTO
55921: IFFALSE 55945
// result := Delete ( result , result ) ;
55923: LD_ADDR_VAR 0 3
55927: PUSH
55928: LD_VAR 0 3
55932: PPUSH
55933: LD_VAR 0 3
55937: PPUSH
55938: CALL_OW 3
55942: ST_TO_ADDR
55943: GO 55920
55945: POP
55946: POP
// end ;
55947: LD_VAR 0 3
55951: RET
// export function ComExit ( unit ) ; var tmp ; begin
55952: LD_INT 0
55954: PPUSH
55955: PPUSH
// if not IsInUnit ( unit ) then
55956: LD_VAR 0 1
55960: PPUSH
55961: CALL_OW 310
55965: NOT
55966: IFFALSE 55970
// exit ;
55968: GO 56030
// tmp := IsInUnit ( unit ) ;
55970: LD_ADDR_VAR 0 3
55974: PUSH
55975: LD_VAR 0 1
55979: PPUSH
55980: CALL_OW 310
55984: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55985: LD_VAR 0 3
55989: PPUSH
55990: CALL_OW 247
55994: PUSH
55995: LD_INT 2
55997: EQUAL
55998: IFFALSE 56011
// ComExitVehicle ( unit ) else
56000: LD_VAR 0 1
56004: PPUSH
56005: CALL_OW 121
56009: GO 56020
// ComExitBuilding ( unit ) ;
56011: LD_VAR 0 1
56015: PPUSH
56016: CALL_OW 122
// result := tmp ;
56020: LD_ADDR_VAR 0 2
56024: PUSH
56025: LD_VAR 0 3
56029: ST_TO_ADDR
// end ;
56030: LD_VAR 0 2
56034: RET
// export function ComExitAll ( units ) ; var i ; begin
56035: LD_INT 0
56037: PPUSH
56038: PPUSH
// if not units then
56039: LD_VAR 0 1
56043: NOT
56044: IFFALSE 56048
// exit ;
56046: GO 56074
// for i in units do
56048: LD_ADDR_VAR 0 3
56052: PUSH
56053: LD_VAR 0 1
56057: PUSH
56058: FOR_IN
56059: IFFALSE 56072
// ComExit ( i ) ;
56061: LD_VAR 0 3
56065: PPUSH
56066: CALL 55952 0 1
56070: GO 56058
56072: POP
56073: POP
// end ;
56074: LD_VAR 0 2
56078: RET
// export function ResetHc ; begin
56079: LD_INT 0
56081: PPUSH
// InitHc ;
56082: CALL_OW 19
// hc_importance := 0 ;
56086: LD_ADDR_OWVAR 32
56090: PUSH
56091: LD_INT 0
56093: ST_TO_ADDR
// end ;
56094: LD_VAR 0 1
56098: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
56099: LD_INT 0
56101: PPUSH
56102: PPUSH
56103: PPUSH
// _x := ( x1 + x2 ) div 2 ;
56104: LD_ADDR_VAR 0 6
56108: PUSH
56109: LD_VAR 0 1
56113: PUSH
56114: LD_VAR 0 3
56118: PLUS
56119: PUSH
56120: LD_INT 2
56122: DIV
56123: ST_TO_ADDR
// if _x < 0 then
56124: LD_VAR 0 6
56128: PUSH
56129: LD_INT 0
56131: LESS
56132: IFFALSE 56149
// _x := _x * - 1 ;
56134: LD_ADDR_VAR 0 6
56138: PUSH
56139: LD_VAR 0 6
56143: PUSH
56144: LD_INT 1
56146: NEG
56147: MUL
56148: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
56149: LD_ADDR_VAR 0 7
56153: PUSH
56154: LD_VAR 0 2
56158: PUSH
56159: LD_VAR 0 4
56163: PLUS
56164: PUSH
56165: LD_INT 2
56167: DIV
56168: ST_TO_ADDR
// if _y < 0 then
56169: LD_VAR 0 7
56173: PUSH
56174: LD_INT 0
56176: LESS
56177: IFFALSE 56194
// _y := _y * - 1 ;
56179: LD_ADDR_VAR 0 7
56183: PUSH
56184: LD_VAR 0 7
56188: PUSH
56189: LD_INT 1
56191: NEG
56192: MUL
56193: ST_TO_ADDR
// result := [ _x , _y ] ;
56194: LD_ADDR_VAR 0 5
56198: PUSH
56199: LD_VAR 0 6
56203: PUSH
56204: LD_VAR 0 7
56208: PUSH
56209: EMPTY
56210: LIST
56211: LIST
56212: ST_TO_ADDR
// end ;
56213: LD_VAR 0 5
56217: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
56218: LD_INT 0
56220: PPUSH
56221: PPUSH
56222: PPUSH
56223: PPUSH
// task := GetTaskList ( unit ) ;
56224: LD_ADDR_VAR 0 7
56228: PUSH
56229: LD_VAR 0 1
56233: PPUSH
56234: CALL_OW 437
56238: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
56239: LD_VAR 0 7
56243: NOT
56244: IFFALSE 56263
56246: PUSH
56247: LD_VAR 0 1
56251: PPUSH
56252: LD_VAR 0 2
56256: PPUSH
56257: CALL_OW 308
56261: NOT
56262: AND
56263: IFFALSE 56267
// exit ;
56265: GO 56385
// if IsInArea ( unit , area ) then
56267: LD_VAR 0 1
56271: PPUSH
56272: LD_VAR 0 2
56276: PPUSH
56277: CALL_OW 308
56281: IFFALSE 56299
// begin ComMoveToArea ( unit , goAway ) ;
56283: LD_VAR 0 1
56287: PPUSH
56288: LD_VAR 0 3
56292: PPUSH
56293: CALL_OW 113
// exit ;
56297: GO 56385
// end ; if task [ 1 ] [ 1 ] <> M then
56299: LD_VAR 0 7
56303: PUSH
56304: LD_INT 1
56306: ARRAY
56307: PUSH
56308: LD_INT 1
56310: ARRAY
56311: PUSH
56312: LD_STRING M
56314: NONEQUAL
56315: IFFALSE 56319
// exit ;
56317: GO 56385
// x := task [ 1 ] [ 2 ] ;
56319: LD_ADDR_VAR 0 5
56323: PUSH
56324: LD_VAR 0 7
56328: PUSH
56329: LD_INT 1
56331: ARRAY
56332: PUSH
56333: LD_INT 2
56335: ARRAY
56336: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
56337: LD_ADDR_VAR 0 6
56341: PUSH
56342: LD_VAR 0 7
56346: PUSH
56347: LD_INT 1
56349: ARRAY
56350: PUSH
56351: LD_INT 3
56353: ARRAY
56354: ST_TO_ADDR
// if InArea ( x , y , area ) then
56355: LD_VAR 0 5
56359: PPUSH
56360: LD_VAR 0 6
56364: PPUSH
56365: LD_VAR 0 2
56369: PPUSH
56370: CALL_OW 309
56374: IFFALSE 56385
// ComStop ( unit ) ;
56376: LD_VAR 0 1
56380: PPUSH
56381: CALL_OW 141
// end ;
56385: LD_VAR 0 4
56389: RET
// export function Abs ( value ) ; begin
56390: LD_INT 0
56392: PPUSH
// result := value ;
56393: LD_ADDR_VAR 0 2
56397: PUSH
56398: LD_VAR 0 1
56402: ST_TO_ADDR
// if value < 0 then
56403: LD_VAR 0 1
56407: PUSH
56408: LD_INT 0
56410: LESS
56411: IFFALSE 56428
// result := value * - 1 ;
56413: LD_ADDR_VAR 0 2
56417: PUSH
56418: LD_VAR 0 1
56422: PUSH
56423: LD_INT 1
56425: NEG
56426: MUL
56427: ST_TO_ADDR
// end ;
56428: LD_VAR 0 2
56432: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
56433: LD_INT 0
56435: PPUSH
56436: PPUSH
56437: PPUSH
56438: PPUSH
56439: PPUSH
56440: PPUSH
56441: PPUSH
56442: PPUSH
// if not unit or not building then
56443: LD_VAR 0 1
56447: NOT
56448: IFTRUE 56457
56450: PUSH
56451: LD_VAR 0 2
56455: NOT
56456: OR
56457: IFFALSE 56461
// exit ;
56459: GO 56689
// x := GetX ( building ) ;
56461: LD_ADDR_VAR 0 4
56465: PUSH
56466: LD_VAR 0 2
56470: PPUSH
56471: CALL_OW 250
56475: ST_TO_ADDR
// y := GetY ( building ) ;
56476: LD_ADDR_VAR 0 6
56480: PUSH
56481: LD_VAR 0 2
56485: PPUSH
56486: CALL_OW 251
56490: ST_TO_ADDR
// d := GetDir ( building ) ;
56491: LD_ADDR_VAR 0 8
56495: PUSH
56496: LD_VAR 0 2
56500: PPUSH
56501: CALL_OW 254
56505: ST_TO_ADDR
// r := 4 ;
56506: LD_ADDR_VAR 0 9
56510: PUSH
56511: LD_INT 4
56513: ST_TO_ADDR
// for i := 1 to 5 do
56514: LD_ADDR_VAR 0 10
56518: PUSH
56519: DOUBLE
56520: LD_INT 1
56522: DEC
56523: ST_TO_ADDR
56524: LD_INT 5
56526: PUSH
56527: FOR_TO
56528: IFFALSE 56687
// begin _x := ShiftX ( x , d , r + i ) ;
56530: LD_ADDR_VAR 0 5
56534: PUSH
56535: LD_VAR 0 4
56539: PPUSH
56540: LD_VAR 0 8
56544: PPUSH
56545: LD_VAR 0 9
56549: PUSH
56550: LD_VAR 0 10
56554: PLUS
56555: PPUSH
56556: CALL_OW 272
56560: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56561: LD_ADDR_VAR 0 7
56565: PUSH
56566: LD_VAR 0 6
56570: PPUSH
56571: LD_VAR 0 8
56575: PPUSH
56576: LD_VAR 0 9
56580: PUSH
56581: LD_VAR 0 10
56585: PLUS
56586: PPUSH
56587: CALL_OW 273
56591: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56592: LD_VAR 0 5
56596: PPUSH
56597: LD_VAR 0 7
56601: PPUSH
56602: CALL_OW 488
56606: IFFALSE 56641
56608: PUSH
56609: LD_VAR 0 5
56613: PPUSH
56614: LD_VAR 0 7
56618: PPUSH
56619: CALL_OW 428
56623: PPUSH
56624: CALL_OW 247
56628: PUSH
56629: LD_INT 3
56631: PUSH
56632: LD_INT 2
56634: PUSH
56635: EMPTY
56636: LIST
56637: LIST
56638: IN
56639: NOT
56640: AND
56641: IFFALSE 56685
// begin ComMoveXY ( unit , _x , _y ) ;
56643: LD_VAR 0 1
56647: PPUSH
56648: LD_VAR 0 5
56652: PPUSH
56653: LD_VAR 0 7
56657: PPUSH
56658: CALL_OW 111
// result := [ _x , _y ] ;
56662: LD_ADDR_VAR 0 3
56666: PUSH
56667: LD_VAR 0 5
56671: PUSH
56672: LD_VAR 0 7
56676: PUSH
56677: EMPTY
56678: LIST
56679: LIST
56680: ST_TO_ADDR
// exit ;
56681: POP
56682: POP
56683: GO 56689
// end ; end ;
56685: GO 56527
56687: POP
56688: POP
// end ;
56689: LD_VAR 0 3
56693: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56694: LD_INT 0
56696: PPUSH
56697: PPUSH
56698: PPUSH
// result := 0 ;
56699: LD_ADDR_VAR 0 3
56703: PUSH
56704: LD_INT 0
56706: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56707: LD_VAR 0 1
56711: PUSH
56712: LD_INT 0
56714: LESS
56715: IFTRUE 56727
56717: PUSH
56718: LD_VAR 0 1
56722: PUSH
56723: LD_INT 8
56725: GREATER
56726: OR
56727: IFTRUE 56739
56729: PUSH
56730: LD_VAR 0 2
56734: PUSH
56735: LD_INT 0
56737: LESS
56738: OR
56739: IFTRUE 56751
56741: PUSH
56742: LD_VAR 0 2
56746: PUSH
56747: LD_INT 8
56749: GREATER
56750: OR
56751: IFFALSE 56755
// exit ;
56753: GO 56830
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56755: LD_ADDR_VAR 0 4
56759: PUSH
56760: LD_INT 22
56762: PUSH
56763: LD_VAR 0 2
56767: PUSH
56768: EMPTY
56769: LIST
56770: LIST
56771: PPUSH
56772: CALL_OW 69
56776: PUSH
56777: FOR_IN
56778: IFFALSE 56828
// begin un := UnitShoot ( i ) ;
56780: LD_ADDR_VAR 0 5
56784: PUSH
56785: LD_VAR 0 4
56789: PPUSH
56790: CALL_OW 504
56794: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56795: LD_VAR 0 5
56799: PPUSH
56800: CALL_OW 255
56804: PUSH
56805: LD_VAR 0 1
56809: EQUAL
56810: IFFALSE 56826
// begin result := un ;
56812: LD_ADDR_VAR 0 3
56816: PUSH
56817: LD_VAR 0 5
56821: ST_TO_ADDR
// exit ;
56822: POP
56823: POP
56824: GO 56830
// end ; end ;
56826: GO 56777
56828: POP
56829: POP
// end ;
56830: LD_VAR 0 3
56834: RET
// export function GetCargoBay ( units ) ; begin
56835: LD_INT 0
56837: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56838: LD_ADDR_VAR 0 2
56842: PUSH
56843: LD_VAR 0 1
56847: PPUSH
56848: LD_INT 2
56850: PUSH
56851: LD_INT 34
56853: PUSH
56854: LD_INT 12
56856: PUSH
56857: EMPTY
56858: LIST
56859: LIST
56860: PUSH
56861: LD_INT 34
56863: PUSH
56864: LD_INT 51
56866: PUSH
56867: EMPTY
56868: LIST
56869: LIST
56870: PUSH
56871: LD_INT 34
56873: PUSH
56874: LD_INT 32
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: PUSH
56881: LD_INT 34
56883: PUSH
56884: LD_INT 89
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: LIST
56895: LIST
56896: LIST
56897: PPUSH
56898: CALL_OW 72
56902: ST_TO_ADDR
// end ;
56903: LD_VAR 0 2
56907: RET
// export function Negate ( value ) ; begin
56908: LD_INT 0
56910: PPUSH
// result := not value ;
56911: LD_ADDR_VAR 0 2
56915: PUSH
56916: LD_VAR 0 1
56920: NOT
56921: ST_TO_ADDR
// end ;
56922: LD_VAR 0 2
56926: RET
// export function Inc ( value ) ; begin
56927: LD_INT 0
56929: PPUSH
// result := value + 1 ;
56930: LD_ADDR_VAR 0 2
56934: PUSH
56935: LD_VAR 0 1
56939: PUSH
56940: LD_INT 1
56942: PLUS
56943: ST_TO_ADDR
// end ;
56944: LD_VAR 0 2
56948: RET
// export function Dec ( value ) ; begin
56949: LD_INT 0
56951: PPUSH
// result := value - 1 ;
56952: LD_ADDR_VAR 0 2
56956: PUSH
56957: LD_VAR 0 1
56961: PUSH
56962: LD_INT 1
56964: MINUS
56965: ST_TO_ADDR
// end ;
56966: LD_VAR 0 2
56970: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
56971: LD_INT 0
56973: PPUSH
56974: PPUSH
56975: PPUSH
56976: PPUSH
56977: PPUSH
56978: PPUSH
56979: PPUSH
56980: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
56981: LD_VAR 0 1
56985: PPUSH
56986: LD_VAR 0 2
56990: PPUSH
56991: CALL_OW 488
56995: NOT
56996: IFTRUE 57015
56998: PUSH
56999: LD_VAR 0 3
57003: PPUSH
57004: LD_VAR 0 4
57008: PPUSH
57009: CALL_OW 488
57013: NOT
57014: OR
57015: IFFALSE 57028
// begin result := - 1 ;
57017: LD_ADDR_VAR 0 5
57021: PUSH
57022: LD_INT 1
57024: NEG
57025: ST_TO_ADDR
// exit ;
57026: GO 57263
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
57028: LD_ADDR_VAR 0 12
57032: PUSH
57033: LD_VAR 0 1
57037: PPUSH
57038: LD_VAR 0 2
57042: PPUSH
57043: LD_VAR 0 3
57047: PPUSH
57048: LD_VAR 0 4
57052: PPUSH
57053: CALL 56099 0 4
57057: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
57058: LD_ADDR_VAR 0 11
57062: PUSH
57063: LD_VAR 0 1
57067: PPUSH
57068: LD_VAR 0 2
57072: PPUSH
57073: LD_VAR 0 12
57077: PUSH
57078: LD_INT 1
57080: ARRAY
57081: PPUSH
57082: LD_VAR 0 12
57086: PUSH
57087: LD_INT 2
57089: ARRAY
57090: PPUSH
57091: CALL_OW 298
57095: ST_TO_ADDR
// distance := 9999 ;
57096: LD_ADDR_VAR 0 10
57100: PUSH
57101: LD_INT 9999
57103: ST_TO_ADDR
// for i := 0 to 5 do
57104: LD_ADDR_VAR 0 6
57108: PUSH
57109: DOUBLE
57110: LD_INT 0
57112: DEC
57113: ST_TO_ADDR
57114: LD_INT 5
57116: PUSH
57117: FOR_TO
57118: IFFALSE 57261
// begin _x := ShiftX ( x1 , i , centerDist ) ;
57120: LD_ADDR_VAR 0 7
57124: PUSH
57125: LD_VAR 0 1
57129: PPUSH
57130: LD_VAR 0 6
57134: PPUSH
57135: LD_VAR 0 11
57139: PPUSH
57140: CALL_OW 272
57144: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
57145: LD_ADDR_VAR 0 8
57149: PUSH
57150: LD_VAR 0 2
57154: PPUSH
57155: LD_VAR 0 6
57159: PPUSH
57160: LD_VAR 0 11
57164: PPUSH
57165: CALL_OW 273
57169: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
57170: LD_VAR 0 7
57174: PPUSH
57175: LD_VAR 0 8
57179: PPUSH
57180: CALL_OW 488
57184: NOT
57185: IFFALSE 57189
// continue ;
57187: GO 57117
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
57189: LD_ADDR_VAR 0 9
57193: PUSH
57194: LD_VAR 0 12
57198: PUSH
57199: LD_INT 1
57201: ARRAY
57202: PPUSH
57203: LD_VAR 0 12
57207: PUSH
57208: LD_INT 2
57210: ARRAY
57211: PPUSH
57212: LD_VAR 0 7
57216: PPUSH
57217: LD_VAR 0 8
57221: PPUSH
57222: CALL_OW 298
57226: ST_TO_ADDR
// if tmp < distance then
57227: LD_VAR 0 9
57231: PUSH
57232: LD_VAR 0 10
57236: LESS
57237: IFFALSE 57259
// begin result := i ;
57239: LD_ADDR_VAR 0 5
57243: PUSH
57244: LD_VAR 0 6
57248: ST_TO_ADDR
// distance := tmp ;
57249: LD_ADDR_VAR 0 10
57253: PUSH
57254: LD_VAR 0 9
57258: ST_TO_ADDR
// end ; end ;
57259: GO 57117
57261: POP
57262: POP
// end ;
57263: LD_VAR 0 5
57267: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57268: LD_INT 0
57270: PPUSH
57271: PPUSH
// if not driver or not IsInUnit ( driver ) then
57272: LD_VAR 0 1
57276: NOT
57277: IFTRUE 57291
57279: PUSH
57280: LD_VAR 0 1
57284: PPUSH
57285: CALL_OW 310
57289: NOT
57290: OR
57291: IFFALSE 57295
// exit ;
57293: GO 57385
// vehicle := IsInUnit ( driver ) ;
57295: LD_ADDR_VAR 0 3
57299: PUSH
57300: LD_VAR 0 1
57304: PPUSH
57305: CALL_OW 310
57309: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57310: LD_VAR 0 1
57314: PPUSH
57315: LD_STRING \
57317: PUSH
57318: LD_INT 0
57320: PUSH
57321: LD_INT 0
57323: PUSH
57324: LD_INT 0
57326: PUSH
57327: LD_INT 0
57329: PUSH
57330: LD_INT 0
57332: PUSH
57333: LD_INT 0
57335: PUSH
57336: EMPTY
57337: LIST
57338: LIST
57339: LIST
57340: LIST
57341: LIST
57342: LIST
57343: LIST
57344: PUSH
57345: LD_STRING E
57347: PUSH
57348: LD_INT 0
57350: PUSH
57351: LD_INT 0
57353: PUSH
57354: LD_VAR 0 3
57358: PUSH
57359: LD_INT 0
57361: PUSH
57362: LD_INT 0
57364: PUSH
57365: LD_INT 0
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: LIST
57372: LIST
57373: LIST
57374: LIST
57375: LIST
57376: PUSH
57377: EMPTY
57378: LIST
57379: LIST
57380: PPUSH
57381: CALL_OW 446
// end ;
57385: LD_VAR 0 2
57389: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
57390: LD_INT 0
57392: PPUSH
57393: PPUSH
// if not driver or not IsInUnit ( driver ) then
57394: LD_VAR 0 1
57398: NOT
57399: IFTRUE 57413
57401: PUSH
57402: LD_VAR 0 1
57406: PPUSH
57407: CALL_OW 310
57411: NOT
57412: OR
57413: IFFALSE 57417
// exit ;
57415: GO 57507
// vehicle := IsInUnit ( driver ) ;
57417: LD_ADDR_VAR 0 3
57421: PUSH
57422: LD_VAR 0 1
57426: PPUSH
57427: CALL_OW 310
57431: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
57432: LD_VAR 0 1
57436: PPUSH
57437: LD_STRING \
57439: PUSH
57440: LD_INT 0
57442: PUSH
57443: LD_INT 0
57445: PUSH
57446: LD_INT 0
57448: PUSH
57449: LD_INT 0
57451: PUSH
57452: LD_INT 0
57454: PUSH
57455: LD_INT 0
57457: PUSH
57458: EMPTY
57459: LIST
57460: LIST
57461: LIST
57462: LIST
57463: LIST
57464: LIST
57465: LIST
57466: PUSH
57467: LD_STRING E
57469: PUSH
57470: LD_INT 0
57472: PUSH
57473: LD_INT 0
57475: PUSH
57476: LD_VAR 0 3
57480: PUSH
57481: LD_INT 0
57483: PUSH
57484: LD_INT 0
57486: PUSH
57487: LD_INT 0
57489: PUSH
57490: EMPTY
57491: LIST
57492: LIST
57493: LIST
57494: LIST
57495: LIST
57496: LIST
57497: LIST
57498: PUSH
57499: EMPTY
57500: LIST
57501: LIST
57502: PPUSH
57503: CALL_OW 447
// end ;
57507: LD_VAR 0 2
57511: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57512: LD_INT 0
57514: PPUSH
57515: PPUSH
57516: PPUSH
// tmp := [ ] ;
57517: LD_ADDR_VAR 0 5
57521: PUSH
57522: EMPTY
57523: ST_TO_ADDR
// for i in units do
57524: LD_ADDR_VAR 0 4
57528: PUSH
57529: LD_VAR 0 1
57533: PUSH
57534: FOR_IN
57535: IFFALSE 57573
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57537: LD_ADDR_VAR 0 5
57541: PUSH
57542: LD_VAR 0 5
57546: PPUSH
57547: LD_VAR 0 5
57551: PUSH
57552: LD_INT 1
57554: PLUS
57555: PPUSH
57556: LD_VAR 0 4
57560: PPUSH
57561: CALL_OW 256
57565: PPUSH
57566: CALL_OW 2
57570: ST_TO_ADDR
57571: GO 57534
57573: POP
57574: POP
// if not tmp then
57575: LD_VAR 0 5
57579: NOT
57580: IFFALSE 57584
// exit ;
57582: GO 57632
// if asc then
57584: LD_VAR 0 2
57588: IFFALSE 57612
// result := SortListByListAsc ( units , tmp ) else
57590: LD_ADDR_VAR 0 3
57594: PUSH
57595: LD_VAR 0 1
57599: PPUSH
57600: LD_VAR 0 5
57604: PPUSH
57605: CALL_OW 76
57609: ST_TO_ADDR
57610: GO 57632
// result := SortListByListDesc ( units , tmp ) ;
57612: LD_ADDR_VAR 0 3
57616: PUSH
57617: LD_VAR 0 1
57621: PPUSH
57622: LD_VAR 0 5
57626: PPUSH
57627: CALL_OW 77
57631: ST_TO_ADDR
// end ;
57632: LD_VAR 0 3
57636: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57637: LD_INT 0
57639: PPUSH
57640: PPUSH
// task := GetTaskList ( mech ) ;
57641: LD_ADDR_VAR 0 4
57645: PUSH
57646: LD_VAR 0 1
57650: PPUSH
57651: CALL_OW 437
57655: ST_TO_ADDR
// if not task then
57656: LD_VAR 0 4
57660: NOT
57661: IFFALSE 57665
// exit ;
57663: GO 57709
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57665: LD_ADDR_VAR 0 3
57669: PUSH
57670: LD_VAR 0 4
57674: PUSH
57675: LD_INT 1
57677: ARRAY
57678: PUSH
57679: LD_INT 1
57681: ARRAY
57682: PUSH
57683: LD_STRING r
57685: EQUAL
57686: IFFALSE 57708
57688: PUSH
57689: LD_VAR 0 4
57693: PUSH
57694: LD_INT 1
57696: ARRAY
57697: PUSH
57698: LD_INT 4
57700: ARRAY
57701: PUSH
57702: LD_VAR 0 2
57706: EQUAL
57707: AND
57708: ST_TO_ADDR
// end ;
57709: LD_VAR 0 3
57713: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57714: LD_INT 0
57716: PPUSH
// SetDir ( unit , d ) ;
57717: LD_VAR 0 1
57721: PPUSH
57722: LD_VAR 0 4
57726: PPUSH
57727: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
57731: LD_ADDR_VAR 0 6
57735: PUSH
57736: LD_VAR 0 1
57740: PPUSH
57741: LD_VAR 0 2
57745: PPUSH
57746: LD_VAR 0 3
57750: PPUSH
57751: LD_VAR 0 5
57755: PPUSH
57756: CALL_OW 48
57760: ST_TO_ADDR
// end ;
57761: LD_VAR 0 6
57765: RET
// export function ToNaturalNumber ( number ) ; begin
57766: LD_INT 0
57768: PPUSH
// result := number div 1 ;
57769: LD_ADDR_VAR 0 2
57773: PUSH
57774: LD_VAR 0 1
57778: PUSH
57779: LD_INT 1
57781: DIV
57782: ST_TO_ADDR
// if number < 0 then
57783: LD_VAR 0 1
57787: PUSH
57788: LD_INT 0
57790: LESS
57791: IFFALSE 57801
// result := 0 ;
57793: LD_ADDR_VAR 0 2
57797: PUSH
57798: LD_INT 0
57800: ST_TO_ADDR
// end ;
57801: LD_VAR 0 2
57805: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
57806: LD_INT 0
57808: PPUSH
57809: PPUSH
57810: PPUSH
// if not buildings then
57811: LD_VAR 0 1
57815: NOT
57816: IFFALSE 57820
// exit ;
57818: GO 57935
// tmp := [ ] ;
57820: LD_ADDR_VAR 0 5
57824: PUSH
57825: EMPTY
57826: ST_TO_ADDR
// for b in buildings do
57827: LD_ADDR_VAR 0 4
57831: PUSH
57832: LD_VAR 0 1
57836: PUSH
57837: FOR_IN
57838: IFFALSE 57876
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
57840: LD_ADDR_VAR 0 5
57844: PUSH
57845: LD_VAR 0 5
57849: PPUSH
57850: LD_VAR 0 5
57854: PUSH
57855: LD_INT 1
57857: PLUS
57858: PPUSH
57859: LD_VAR 0 4
57863: PPUSH
57864: CALL_OW 266
57868: PPUSH
57869: CALL_OW 1
57873: ST_TO_ADDR
57874: GO 57837
57876: POP
57877: POP
// if not tmp then
57878: LD_VAR 0 5
57882: NOT
57883: IFFALSE 57887
// exit ;
57885: GO 57935
// if asc then
57887: LD_VAR 0 2
57891: IFFALSE 57915
// result := SortListByListAsc ( buildings , tmp ) else
57893: LD_ADDR_VAR 0 3
57897: PUSH
57898: LD_VAR 0 1
57902: PPUSH
57903: LD_VAR 0 5
57907: PPUSH
57908: CALL_OW 76
57912: ST_TO_ADDR
57913: GO 57935
// result := SortListByListDesc ( buildings , tmp ) ;
57915: LD_ADDR_VAR 0 3
57919: PUSH
57920: LD_VAR 0 1
57924: PPUSH
57925: LD_VAR 0 5
57929: PPUSH
57930: CALL_OW 77
57934: ST_TO_ADDR
// end ;
57935: LD_VAR 0 3
57939: RET
// export function SortByClass ( units , class ) ; var un ; begin
57940: LD_INT 0
57942: PPUSH
57943: PPUSH
// if not units or not class then
57944: LD_VAR 0 1
57948: NOT
57949: IFTRUE 57958
57951: PUSH
57952: LD_VAR 0 2
57956: NOT
57957: OR
57958: IFFALSE 57962
// exit ;
57960: GO 58057
// result := [ ] ;
57962: LD_ADDR_VAR 0 3
57966: PUSH
57967: EMPTY
57968: ST_TO_ADDR
// for un in units do
57969: LD_ADDR_VAR 0 4
57973: PUSH
57974: LD_VAR 0 1
57978: PUSH
57979: FOR_IN
57980: IFFALSE 58055
// if GetClass ( un ) = class then
57982: LD_VAR 0 4
57986: PPUSH
57987: CALL_OW 257
57991: PUSH
57992: LD_VAR 0 2
57996: EQUAL
57997: IFFALSE 58024
// result := Insert ( result , 1 , un ) else
57999: LD_ADDR_VAR 0 3
58003: PUSH
58004: LD_VAR 0 3
58008: PPUSH
58009: LD_INT 1
58011: PPUSH
58012: LD_VAR 0 4
58016: PPUSH
58017: CALL_OW 2
58021: ST_TO_ADDR
58022: GO 58053
// result := Replace ( result , result + 1 , un ) ;
58024: LD_ADDR_VAR 0 3
58028: PUSH
58029: LD_VAR 0 3
58033: PPUSH
58034: LD_VAR 0 3
58038: PUSH
58039: LD_INT 1
58041: PLUS
58042: PPUSH
58043: LD_VAR 0 4
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
58053: GO 57979
58055: POP
58056: POP
// end ;
58057: LD_VAR 0 3
58061: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
58062: LD_INT 0
58064: PPUSH
58065: PPUSH
58066: PPUSH
58067: PPUSH
58068: PPUSH
58069: PPUSH
58070: PPUSH
// result := [ ] ;
58071: LD_ADDR_VAR 0 4
58075: PUSH
58076: EMPTY
58077: ST_TO_ADDR
// if x - r < 0 then
58078: LD_VAR 0 1
58082: PUSH
58083: LD_VAR 0 3
58087: MINUS
58088: PUSH
58089: LD_INT 0
58091: LESS
58092: IFFALSE 58104
// min_x := 0 else
58094: LD_ADDR_VAR 0 8
58098: PUSH
58099: LD_INT 0
58101: ST_TO_ADDR
58102: GO 58120
// min_x := x - r ;
58104: LD_ADDR_VAR 0 8
58108: PUSH
58109: LD_VAR 0 1
58113: PUSH
58114: LD_VAR 0 3
58118: MINUS
58119: ST_TO_ADDR
// if y - r < 0 then
58120: LD_VAR 0 2
58124: PUSH
58125: LD_VAR 0 3
58129: MINUS
58130: PUSH
58131: LD_INT 0
58133: LESS
58134: IFFALSE 58146
// min_y := 0 else
58136: LD_ADDR_VAR 0 7
58140: PUSH
58141: LD_INT 0
58143: ST_TO_ADDR
58144: GO 58162
// min_y := y - r ;
58146: LD_ADDR_VAR 0 7
58150: PUSH
58151: LD_VAR 0 2
58155: PUSH
58156: LD_VAR 0 3
58160: MINUS
58161: ST_TO_ADDR
// max_x := x + r ;
58162: LD_ADDR_VAR 0 9
58166: PUSH
58167: LD_VAR 0 1
58171: PUSH
58172: LD_VAR 0 3
58176: PLUS
58177: ST_TO_ADDR
// max_y := y + r ;
58178: LD_ADDR_VAR 0 10
58182: PUSH
58183: LD_VAR 0 2
58187: PUSH
58188: LD_VAR 0 3
58192: PLUS
58193: ST_TO_ADDR
// for _x = min_x to max_x do
58194: LD_ADDR_VAR 0 5
58198: PUSH
58199: DOUBLE
58200: LD_VAR 0 8
58204: DEC
58205: ST_TO_ADDR
58206: LD_VAR 0 9
58210: PUSH
58211: FOR_TO
58212: IFFALSE 58313
// for _y = min_y to max_y do
58214: LD_ADDR_VAR 0 6
58218: PUSH
58219: DOUBLE
58220: LD_VAR 0 7
58224: DEC
58225: ST_TO_ADDR
58226: LD_VAR 0 10
58230: PUSH
58231: FOR_TO
58232: IFFALSE 58309
// begin if not ValidHex ( _x , _y ) then
58234: LD_VAR 0 5
58238: PPUSH
58239: LD_VAR 0 6
58243: PPUSH
58244: CALL_OW 488
58248: NOT
58249: IFFALSE 58253
// continue ;
58251: GO 58231
// if GetResourceTypeXY ( _x , _y ) then
58253: LD_VAR 0 5
58257: PPUSH
58258: LD_VAR 0 6
58262: PPUSH
58263: CALL_OW 283
58267: IFFALSE 58307
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
58269: LD_ADDR_VAR 0 4
58273: PUSH
58274: LD_VAR 0 4
58278: PPUSH
58279: LD_VAR 0 4
58283: PUSH
58284: LD_INT 1
58286: PLUS
58287: PPUSH
58288: LD_VAR 0 5
58292: PUSH
58293: LD_VAR 0 6
58297: PUSH
58298: EMPTY
58299: LIST
58300: LIST
58301: PPUSH
58302: CALL_OW 1
58306: ST_TO_ADDR
// end ;
58307: GO 58231
58309: POP
58310: POP
58311: GO 58211
58313: POP
58314: POP
// end ;
58315: LD_VAR 0 4
58319: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
58320: LD_INT 0
58322: PPUSH
58323: PPUSH
58324: PPUSH
58325: PPUSH
58326: PPUSH
58327: PPUSH
58328: PPUSH
58329: PPUSH
// if not units then
58330: LD_VAR 0 1
58334: NOT
58335: IFFALSE 58339
// exit ;
58337: GO 58871
// result := UnitFilter ( units , [ f_ok ] ) ;
58339: LD_ADDR_VAR 0 3
58343: PUSH
58344: LD_VAR 0 1
58348: PPUSH
58349: LD_INT 50
58351: PUSH
58352: EMPTY
58353: LIST
58354: PPUSH
58355: CALL_OW 72
58359: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
58360: LD_ADDR_VAR 0 8
58364: PUSH
58365: LD_VAR 0 1
58369: PUSH
58370: LD_INT 1
58372: ARRAY
58373: PPUSH
58374: CALL_OW 255
58378: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
58379: LD_ADDR_VAR 0 10
58383: PUSH
58384: LD_INT 29
58386: PUSH
58387: LD_INT 91
58389: PUSH
58390: LD_INT 49
58392: PUSH
58393: EMPTY
58394: LIST
58395: LIST
58396: LIST
58397: ST_TO_ADDR
// if not result then
58398: LD_VAR 0 3
58402: NOT
58403: IFFALSE 58407
// exit ;
58405: GO 58871
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
58407: LD_ADDR_VAR 0 5
58411: PUSH
58412: LD_INT 81
58414: PUSH
58415: LD_VAR 0 8
58419: PUSH
58420: EMPTY
58421: LIST
58422: LIST
58423: PPUSH
58424: CALL_OW 69
58428: ST_TO_ADDR
// for i in result do
58429: LD_ADDR_VAR 0 4
58433: PUSH
58434: LD_VAR 0 3
58438: PUSH
58439: FOR_IN
58440: IFFALSE 58869
// begin tag := GetTag ( i ) + 1 ;
58442: LD_ADDR_VAR 0 9
58446: PUSH
58447: LD_VAR 0 4
58451: PPUSH
58452: CALL_OW 110
58456: PUSH
58457: LD_INT 1
58459: PLUS
58460: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
58461: LD_ADDR_VAR 0 7
58465: PUSH
58466: LD_VAR 0 4
58470: PPUSH
58471: CALL_OW 250
58475: PPUSH
58476: LD_VAR 0 4
58480: PPUSH
58481: CALL_OW 251
58485: PPUSH
58486: LD_INT 4
58488: PPUSH
58489: CALL 58062 0 3
58493: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
58494: LD_VAR 0 4
58498: PPUSH
58499: CALL_OW 247
58503: PUSH
58504: LD_INT 2
58506: EQUAL
58507: IFFALSE 58519
58509: PUSH
58510: LD_VAR 0 7
58514: PUSH
58515: LD_INT 2
58517: GREATER
58518: AND
58519: IFFALSE 58539
58521: PUSH
58522: LD_VAR 0 4
58526: PPUSH
58527: CALL_OW 264
58531: PUSH
58532: LD_VAR 0 10
58536: IN
58537: NOT
58538: AND
58539: IFFALSE 58578
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
58541: LD_VAR 0 4
58545: PPUSH
58546: LD_VAR 0 7
58550: PUSH
58551: LD_INT 1
58553: ARRAY
58554: PUSH
58555: LD_INT 1
58557: ARRAY
58558: PPUSH
58559: LD_VAR 0 7
58563: PUSH
58564: LD_INT 1
58566: ARRAY
58567: PUSH
58568: LD_INT 2
58570: ARRAY
58571: PPUSH
58572: CALL_OW 116
58576: GO 58867
// if path > tag then
58578: LD_VAR 0 2
58582: PUSH
58583: LD_VAR 0 9
58587: GREATER
58588: IFFALSE 58796
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
58590: LD_ADDR_VAR 0 6
58594: PUSH
58595: LD_VAR 0 5
58599: PPUSH
58600: LD_INT 91
58602: PUSH
58603: LD_VAR 0 4
58607: PUSH
58608: LD_INT 8
58610: PUSH
58611: EMPTY
58612: LIST
58613: LIST
58614: LIST
58615: PPUSH
58616: CALL_OW 72
58620: ST_TO_ADDR
// if nearEnemy then
58621: LD_VAR 0 6
58625: IFFALSE 58694
// begin if GetWeapon ( i ) = ru_time_lapser then
58627: LD_VAR 0 4
58631: PPUSH
58632: CALL_OW 264
58636: PUSH
58637: LD_INT 49
58639: EQUAL
58640: IFFALSE 58668
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
58642: LD_VAR 0 4
58646: PPUSH
58647: LD_VAR 0 6
58651: PPUSH
58652: LD_VAR 0 4
58656: PPUSH
58657: CALL_OW 74
58661: PPUSH
58662: CALL_OW 112
58666: GO 58692
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
58668: LD_VAR 0 4
58672: PPUSH
58673: LD_VAR 0 6
58677: PPUSH
58678: LD_VAR 0 4
58682: PPUSH
58683: CALL_OW 74
58687: PPUSH
58688: CALL 59952 0 2
// end else
58692: GO 58794
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58694: LD_VAR 0 4
58698: PPUSH
58699: LD_VAR 0 2
58703: PUSH
58704: LD_VAR 0 9
58708: ARRAY
58709: PUSH
58710: LD_INT 1
58712: ARRAY
58713: PPUSH
58714: LD_VAR 0 2
58718: PUSH
58719: LD_VAR 0 9
58723: ARRAY
58724: PUSH
58725: LD_INT 2
58727: ARRAY
58728: PPUSH
58729: CALL_OW 297
58733: PUSH
58734: LD_INT 6
58736: GREATER
58737: IFFALSE 58780
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58739: LD_VAR 0 4
58743: PPUSH
58744: LD_VAR 0 2
58748: PUSH
58749: LD_VAR 0 9
58753: ARRAY
58754: PUSH
58755: LD_INT 1
58757: ARRAY
58758: PPUSH
58759: LD_VAR 0 2
58763: PUSH
58764: LD_VAR 0 9
58768: ARRAY
58769: PUSH
58770: LD_INT 2
58772: ARRAY
58773: PPUSH
58774: CALL_OW 114
58778: GO 58794
// SetTag ( i , tag ) ;
58780: LD_VAR 0 4
58784: PPUSH
58785: LD_VAR 0 9
58789: PPUSH
58790: CALL_OW 109
// end else
58794: GO 58867
// if enemy then
58796: LD_VAR 0 5
58800: IFFALSE 58867
// begin if GetWeapon ( i ) = ru_time_lapser then
58802: LD_VAR 0 4
58806: PPUSH
58807: CALL_OW 264
58811: PUSH
58812: LD_INT 49
58814: EQUAL
58815: IFFALSE 58843
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58817: LD_VAR 0 4
58821: PPUSH
58822: LD_VAR 0 5
58826: PPUSH
58827: LD_VAR 0 4
58831: PPUSH
58832: CALL_OW 74
58836: PPUSH
58837: CALL_OW 112
58841: GO 58867
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58843: LD_VAR 0 4
58847: PPUSH
58848: LD_VAR 0 5
58852: PPUSH
58853: LD_VAR 0 4
58857: PPUSH
58858: CALL_OW 74
58862: PPUSH
58863: CALL 59952 0 2
// end ; end ;
58867: GO 58439
58869: POP
58870: POP
// end ;
58871: LD_VAR 0 3
58875: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58876: LD_INT 0
58878: PPUSH
58879: PPUSH
58880: PPUSH
// if not unit or IsInUnit ( unit ) then
58881: LD_VAR 0 1
58885: NOT
58886: IFTRUE 58899
58888: PUSH
58889: LD_VAR 0 1
58893: PPUSH
58894: CALL_OW 310
58898: OR
58899: IFFALSE 58903
// exit ;
58901: GO 58994
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58903: LD_ADDR_VAR 0 4
58907: PUSH
58908: LD_VAR 0 1
58912: PPUSH
58913: CALL_OW 250
58917: PPUSH
58918: LD_VAR 0 2
58922: PPUSH
58923: LD_INT 1
58925: PPUSH
58926: CALL_OW 272
58930: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58931: LD_ADDR_VAR 0 5
58935: PUSH
58936: LD_VAR 0 1
58940: PPUSH
58941: CALL_OW 251
58945: PPUSH
58946: LD_VAR 0 2
58950: PPUSH
58951: LD_INT 1
58953: PPUSH
58954: CALL_OW 273
58958: ST_TO_ADDR
// if ValidHex ( x , y ) then
58959: LD_VAR 0 4
58963: PPUSH
58964: LD_VAR 0 5
58968: PPUSH
58969: CALL_OW 488
58973: IFFALSE 58994
// ComTurnXY ( unit , x , y ) ;
58975: LD_VAR 0 1
58979: PPUSH
58980: LD_VAR 0 4
58984: PPUSH
58985: LD_VAR 0 5
58989: PPUSH
58990: CALL_OW 118
// end ;
58994: LD_VAR 0 3
58998: RET
// export function SeeUnits ( side , units ) ; var i ; begin
58999: LD_INT 0
59001: PPUSH
59002: PPUSH
// result := false ;
59003: LD_ADDR_VAR 0 3
59007: PUSH
59008: LD_INT 0
59010: ST_TO_ADDR
// if not units then
59011: LD_VAR 0 2
59015: NOT
59016: IFFALSE 59020
// exit ;
59018: GO 59065
// for i in units do
59020: LD_ADDR_VAR 0 4
59024: PUSH
59025: LD_VAR 0 2
59029: PUSH
59030: FOR_IN
59031: IFFALSE 59063
// if See ( side , i ) then
59033: LD_VAR 0 1
59037: PPUSH
59038: LD_VAR 0 4
59042: PPUSH
59043: CALL_OW 292
59047: IFFALSE 59061
// begin result := true ;
59049: LD_ADDR_VAR 0 3
59053: PUSH
59054: LD_INT 1
59056: ST_TO_ADDR
// exit ;
59057: POP
59058: POP
59059: GO 59065
// end ;
59061: GO 59030
59063: POP
59064: POP
// end ;
59065: LD_VAR 0 3
59069: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
59070: LD_INT 0
59072: PPUSH
59073: PPUSH
59074: PPUSH
59075: PPUSH
// if not unit or not points then
59076: LD_VAR 0 1
59080: NOT
59081: IFTRUE 59090
59083: PUSH
59084: LD_VAR 0 2
59088: NOT
59089: OR
59090: IFFALSE 59094
// exit ;
59092: GO 59184
// dist := 99999 ;
59094: LD_ADDR_VAR 0 5
59098: PUSH
59099: LD_INT 99999
59101: ST_TO_ADDR
// for i in points do
59102: LD_ADDR_VAR 0 4
59106: PUSH
59107: LD_VAR 0 2
59111: PUSH
59112: FOR_IN
59113: IFFALSE 59182
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
59115: LD_ADDR_VAR 0 6
59119: PUSH
59120: LD_VAR 0 1
59124: PPUSH
59125: LD_VAR 0 4
59129: PUSH
59130: LD_INT 1
59132: ARRAY
59133: PPUSH
59134: LD_VAR 0 4
59138: PUSH
59139: LD_INT 2
59141: ARRAY
59142: PPUSH
59143: CALL_OW 297
59147: ST_TO_ADDR
// if tmpDist < dist then
59148: LD_VAR 0 6
59152: PUSH
59153: LD_VAR 0 5
59157: LESS
59158: IFFALSE 59180
// begin result := i ;
59160: LD_ADDR_VAR 0 3
59164: PUSH
59165: LD_VAR 0 4
59169: ST_TO_ADDR
// dist := tmpDist ;
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: LD_VAR 0 6
59179: ST_TO_ADDR
// end ; end ;
59180: GO 59112
59182: POP
59183: POP
// end ;
59184: LD_VAR 0 3
59188: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
59189: LD_INT 0
59191: PPUSH
// uc_side := side ;
59192: LD_ADDR_OWVAR 20
59196: PUSH
59197: LD_VAR 0 1
59201: ST_TO_ADDR
// uc_nation := 3 ;
59202: LD_ADDR_OWVAR 21
59206: PUSH
59207: LD_INT 3
59209: ST_TO_ADDR
// vc_chassis := 25 ;
59210: LD_ADDR_OWVAR 37
59214: PUSH
59215: LD_INT 25
59217: ST_TO_ADDR
// vc_engine := engine_siberite ;
59218: LD_ADDR_OWVAR 39
59222: PUSH
59223: LD_INT 3
59225: ST_TO_ADDR
// vc_control := control_computer ;
59226: LD_ADDR_OWVAR 38
59230: PUSH
59231: LD_INT 3
59233: ST_TO_ADDR
// vc_weapon := 59 ;
59234: LD_ADDR_OWVAR 40
59238: PUSH
59239: LD_INT 59
59241: ST_TO_ADDR
// result := CreateVehicle ;
59242: LD_ADDR_VAR 0 5
59246: PUSH
59247: CALL_OW 45
59251: ST_TO_ADDR
// SetDir ( result , d ) ;
59252: LD_VAR 0 5
59256: PPUSH
59257: LD_VAR 0 4
59261: PPUSH
59262: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
59266: LD_VAR 0 5
59270: PPUSH
59271: LD_VAR 0 2
59275: PPUSH
59276: LD_VAR 0 3
59280: PPUSH
59281: LD_INT 0
59283: PPUSH
59284: CALL_OW 48
// end ;
59288: LD_VAR 0 5
59292: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
59293: LD_INT 0
59295: PPUSH
59296: PPUSH
59297: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
59298: LD_ADDR_VAR 0 2
59302: PUSH
59303: LD_INT 0
59305: PUSH
59306: LD_INT 0
59308: PUSH
59309: LD_INT 0
59311: PUSH
59312: LD_INT 0
59314: PUSH
59315: EMPTY
59316: LIST
59317: LIST
59318: LIST
59319: LIST
59320: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
59321: LD_VAR 0 1
59325: NOT
59326: IFTRUE 59359
59328: PUSH
59329: LD_VAR 0 1
59333: PPUSH
59334: CALL_OW 264
59338: PUSH
59339: LD_INT 12
59341: PUSH
59342: LD_INT 51
59344: PUSH
59345: LD_INT 32
59347: PUSH
59348: LD_INT 89
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: LIST
59355: LIST
59356: IN
59357: NOT
59358: OR
59359: IFFALSE 59363
// exit ;
59361: GO 59461
// for i := 1 to 3 do
59363: LD_ADDR_VAR 0 3
59367: PUSH
59368: DOUBLE
59369: LD_INT 1
59371: DEC
59372: ST_TO_ADDR
59373: LD_INT 3
59375: PUSH
59376: FOR_TO
59377: IFFALSE 59459
// begin tmp := GetCargo ( cargo , i ) ;
59379: LD_ADDR_VAR 0 4
59383: PUSH
59384: LD_VAR 0 1
59388: PPUSH
59389: LD_VAR 0 3
59393: PPUSH
59394: CALL_OW 289
59398: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
59399: LD_ADDR_VAR 0 2
59403: PUSH
59404: LD_VAR 0 2
59408: PPUSH
59409: LD_VAR 0 3
59413: PPUSH
59414: LD_VAR 0 4
59418: PPUSH
59419: CALL_OW 1
59423: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
59424: LD_ADDR_VAR 0 2
59428: PUSH
59429: LD_VAR 0 2
59433: PPUSH
59434: LD_INT 4
59436: PPUSH
59437: LD_VAR 0 2
59441: PUSH
59442: LD_INT 4
59444: ARRAY
59445: PUSH
59446: LD_VAR 0 4
59450: PLUS
59451: PPUSH
59452: CALL_OW 1
59456: ST_TO_ADDR
// end ;
59457: GO 59376
59459: POP
59460: POP
// end ;
59461: LD_VAR 0 2
59465: RET
// export function Length ( array ) ; begin
59466: LD_INT 0
59468: PPUSH
// result := array + 0 ;
59469: LD_ADDR_VAR 0 2
59473: PUSH
59474: LD_VAR 0 1
59478: PUSH
59479: LD_INT 0
59481: PLUS
59482: ST_TO_ADDR
// end ;
59483: LD_VAR 0 2
59487: RET
// export function PrepareArray ( array ) ; begin
59488: LD_INT 0
59490: PPUSH
// result := array diff 0 ;
59491: LD_ADDR_VAR 0 2
59495: PUSH
59496: LD_VAR 0 1
59500: PUSH
59501: LD_INT 0
59503: DIFF
59504: ST_TO_ADDR
// if not result [ 1 ] then
59505: LD_VAR 0 2
59509: PUSH
59510: LD_INT 1
59512: ARRAY
59513: NOT
59514: IFFALSE 59534
// result := Delete ( result , 1 ) ;
59516: LD_ADDR_VAR 0 2
59520: PUSH
59521: LD_VAR 0 2
59525: PPUSH
59526: LD_INT 1
59528: PPUSH
59529: CALL_OW 3
59533: ST_TO_ADDR
// end ;
59534: LD_VAR 0 2
59538: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
59539: LD_INT 0
59541: PPUSH
59542: PPUSH
59543: PPUSH
59544: PPUSH
// sibRocketRange := 25 ;
59545: LD_ADDR_VAR 0 6
59549: PUSH
59550: LD_INT 25
59552: ST_TO_ADDR
// result := false ;
59553: LD_ADDR_VAR 0 4
59557: PUSH
59558: LD_INT 0
59560: ST_TO_ADDR
// for i := 0 to 5 do
59561: LD_ADDR_VAR 0 5
59565: PUSH
59566: DOUBLE
59567: LD_INT 0
59569: DEC
59570: ST_TO_ADDR
59571: LD_INT 5
59573: PUSH
59574: FOR_TO
59575: IFFALSE 59642
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
59577: LD_VAR 0 1
59581: PPUSH
59582: LD_VAR 0 5
59586: PPUSH
59587: LD_VAR 0 6
59591: PPUSH
59592: CALL_OW 272
59596: PPUSH
59597: LD_VAR 0 2
59601: PPUSH
59602: LD_VAR 0 5
59606: PPUSH
59607: LD_VAR 0 6
59611: PPUSH
59612: CALL_OW 273
59616: PPUSH
59617: LD_VAR 0 3
59621: PPUSH
59622: CALL_OW 309
59626: IFFALSE 59640
// begin result := true ;
59628: LD_ADDR_VAR 0 4
59632: PUSH
59633: LD_INT 1
59635: ST_TO_ADDR
// exit ;
59636: POP
59637: POP
59638: GO 59644
// end ;
59640: GO 59574
59642: POP
59643: POP
// end ;
59644: LD_VAR 0 4
59648: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
59649: LD_INT 0
59651: PPUSH
59652: PPUSH
59653: PPUSH
// if btype = b_depot then
59654: LD_VAR 0 2
59658: PUSH
59659: LD_INT 0
59661: EQUAL
59662: IFFALSE 59674
// begin result := true ;
59664: LD_ADDR_VAR 0 3
59668: PUSH
59669: LD_INT 1
59671: ST_TO_ADDR
// exit ;
59672: GO 59794
// end ; pom := GetBase ( depot ) ;
59674: LD_ADDR_VAR 0 4
59678: PUSH
59679: LD_VAR 0 1
59683: PPUSH
59684: CALL_OW 274
59688: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59689: LD_ADDR_VAR 0 5
59693: PUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: LD_VAR 0 1
59703: PPUSH
59704: CALL_OW 248
59708: PPUSH
59709: CALL_OW 450
59713: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
59714: LD_ADDR_VAR 0 3
59718: PUSH
59719: LD_VAR 0 4
59723: PPUSH
59724: LD_INT 1
59726: PPUSH
59727: CALL_OW 275
59731: PUSH
59732: LD_VAR 0 5
59736: PUSH
59737: LD_INT 1
59739: ARRAY
59740: GREATEREQUAL
59741: IFFALSE 59767
59743: PUSH
59744: LD_VAR 0 4
59748: PPUSH
59749: LD_INT 2
59751: PPUSH
59752: CALL_OW 275
59756: PUSH
59757: LD_VAR 0 5
59761: PUSH
59762: LD_INT 2
59764: ARRAY
59765: GREATEREQUAL
59766: AND
59767: IFFALSE 59793
59769: PUSH
59770: LD_VAR 0 4
59774: PPUSH
59775: LD_INT 3
59777: PPUSH
59778: CALL_OW 275
59782: PUSH
59783: LD_VAR 0 5
59787: PUSH
59788: LD_INT 3
59790: ARRAY
59791: GREATEREQUAL
59792: AND
59793: ST_TO_ADDR
// end ;
59794: LD_VAR 0 3
59798: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59799: LD_INT 0
59801: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59802: LD_VAR 0 1
59806: PPUSH
59807: LD_VAR 0 2
59811: PPUSH
59812: LD_INT 0
59814: PPUSH
59815: LD_INT 0
59817: PPUSH
59818: LD_INT 1
59820: PPUSH
59821: LD_INT 0
59823: PPUSH
59824: CALL_OW 587
// end ;
59828: LD_VAR 0 3
59832: RET
// export function CenterOnNow ( unit ) ; begin
59833: LD_INT 0
59835: PPUSH
// result := IsInUnit ( unit ) ;
59836: LD_ADDR_VAR 0 2
59840: PUSH
59841: LD_VAR 0 1
59845: PPUSH
59846: CALL_OW 310
59850: ST_TO_ADDR
// if not result then
59851: LD_VAR 0 2
59855: NOT
59856: IFFALSE 59868
// result := unit ;
59858: LD_ADDR_VAR 0 2
59862: PUSH
59863: LD_VAR 0 1
59867: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59868: LD_VAR 0 1
59872: PPUSH
59873: CALL_OW 87
// end ;
59877: LD_VAR 0 2
59881: RET
// export function ComMoveHex ( unit , hex ) ; begin
59882: LD_INT 0
59884: PPUSH
// if not hex then
59885: LD_VAR 0 2
59889: NOT
59890: IFFALSE 59894
// exit ;
59892: GO 59947
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59894: LD_VAR 0 2
59898: PUSH
59899: LD_INT 1
59901: ARRAY
59902: PPUSH
59903: LD_VAR 0 2
59907: PUSH
59908: LD_INT 2
59910: ARRAY
59911: PPUSH
59912: CALL_OW 428
59916: IFFALSE 59920
// exit ;
59918: GO 59947
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59920: LD_VAR 0 1
59924: PPUSH
59925: LD_VAR 0 2
59929: PUSH
59930: LD_INT 1
59932: ARRAY
59933: PPUSH
59934: LD_VAR 0 2
59938: PUSH
59939: LD_INT 2
59941: ARRAY
59942: PPUSH
59943: CALL_OW 111
// end ;
59947: LD_VAR 0 3
59951: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
59952: LD_INT 0
59954: PPUSH
59955: PPUSH
59956: PPUSH
// if not unit or not enemy then
59957: LD_VAR 0 1
59961: NOT
59962: IFTRUE 59971
59964: PUSH
59965: LD_VAR 0 2
59969: NOT
59970: OR
59971: IFFALSE 59975
// exit ;
59973: GO 60101
// x := GetX ( enemy ) ;
59975: LD_ADDR_VAR 0 4
59979: PUSH
59980: LD_VAR 0 2
59984: PPUSH
59985: CALL_OW 250
59989: ST_TO_ADDR
// y := GetY ( enemy ) ;
59990: LD_ADDR_VAR 0 5
59994: PUSH
59995: LD_VAR 0 2
59999: PPUSH
60000: CALL_OW 251
60004: ST_TO_ADDR
// if ValidHex ( x , y ) then
60005: LD_VAR 0 4
60009: PPUSH
60010: LD_VAR 0 5
60014: PPUSH
60015: CALL_OW 488
60019: IFFALSE 60101
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
60021: LD_VAR 0 2
60025: PPUSH
60026: CALL_OW 247
60030: PUSH
60031: LD_INT 3
60033: PUSH
60034: LD_INT 2
60036: PUSH
60037: EMPTY
60038: LIST
60039: LIST
60040: IN
60041: IFTRUE 60064
60043: PUSH
60044: LD_VAR 0 1
60048: PPUSH
60049: CALL_OW 255
60053: PPUSH
60054: LD_VAR 0 2
60058: PPUSH
60059: CALL_OW 292
60063: OR
60064: IFFALSE 60082
// ComAttackUnit ( unit , enemy ) else
60066: LD_VAR 0 1
60070: PPUSH
60071: LD_VAR 0 2
60075: PPUSH
60076: CALL_OW 115
60080: GO 60101
// ComAgressiveMove ( unit , x , y ) ;
60082: LD_VAR 0 1
60086: PPUSH
60087: LD_VAR 0 4
60091: PPUSH
60092: LD_VAR 0 5
60096: PPUSH
60097: CALL_OW 114
// end ;
60101: LD_VAR 0 3
60105: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
60106: LD_INT 0
60108: PPUSH
60109: PPUSH
60110: PPUSH
// list := AreaToList ( area , 0 ) ;
60111: LD_ADDR_VAR 0 5
60115: PUSH
60116: LD_VAR 0 1
60120: PPUSH
60121: LD_INT 0
60123: PPUSH
60124: CALL_OW 517
60128: ST_TO_ADDR
// if not list then
60129: LD_VAR 0 5
60133: NOT
60134: IFFALSE 60138
// exit ;
60136: GO 60268
// if all then
60138: LD_VAR 0 2
60142: IFFALSE 60230
// begin for i := 1 to list [ 1 ] do
60144: LD_ADDR_VAR 0 4
60148: PUSH
60149: DOUBLE
60150: LD_INT 1
60152: DEC
60153: ST_TO_ADDR
60154: LD_VAR 0 5
60158: PUSH
60159: LD_INT 1
60161: ARRAY
60162: PUSH
60163: FOR_TO
60164: IFFALSE 60226
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
60166: LD_ADDR_VAR 0 3
60170: PUSH
60171: LD_VAR 0 3
60175: PPUSH
60176: LD_VAR 0 3
60180: PUSH
60181: LD_INT 1
60183: PLUS
60184: PPUSH
60185: LD_VAR 0 5
60189: PUSH
60190: LD_INT 1
60192: ARRAY
60193: PUSH
60194: LD_VAR 0 4
60198: ARRAY
60199: PUSH
60200: LD_VAR 0 5
60204: PUSH
60205: LD_INT 2
60207: ARRAY
60208: PUSH
60209: LD_VAR 0 4
60213: ARRAY
60214: PUSH
60215: EMPTY
60216: LIST
60217: LIST
60218: PPUSH
60219: CALL_OW 1
60223: ST_TO_ADDR
60224: GO 60163
60226: POP
60227: POP
// exit ;
60228: GO 60268
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
60230: LD_ADDR_VAR 0 3
60234: PUSH
60235: LD_VAR 0 5
60239: PUSH
60240: LD_INT 1
60242: ARRAY
60243: PUSH
60244: LD_INT 1
60246: ARRAY
60247: PUSH
60248: LD_VAR 0 5
60252: PUSH
60253: LD_INT 2
60255: ARRAY
60256: PUSH
60257: LD_INT 1
60259: ARRAY
60260: PUSH
60261: EMPTY
60262: LIST
60263: LIST
60264: PUSH
60265: EMPTY
60266: LIST
60267: ST_TO_ADDR
// end ;
60268: LD_VAR 0 3
60272: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
60273: LD_INT 0
60275: PPUSH
60276: PPUSH
// list := AreaToList ( area , 0 ) ;
60277: LD_ADDR_VAR 0 4
60281: PUSH
60282: LD_VAR 0 1
60286: PPUSH
60287: LD_INT 0
60289: PPUSH
60290: CALL_OW 517
60294: ST_TO_ADDR
// if not list then
60295: LD_VAR 0 4
60299: NOT
60300: IFFALSE 60304
// exit ;
60302: GO 60345
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
60304: LD_ADDR_VAR 0 3
60308: PUSH
60309: LD_VAR 0 4
60313: PUSH
60314: LD_INT 1
60316: ARRAY
60317: PUSH
60318: LD_INT 1
60320: ARRAY
60321: PUSH
60322: LD_VAR 0 4
60326: PUSH
60327: LD_INT 2
60329: ARRAY
60330: PUSH
60331: LD_INT 1
60333: ARRAY
60334: PUSH
60335: LD_VAR 0 2
60339: PUSH
60340: EMPTY
60341: LIST
60342: LIST
60343: LIST
60344: ST_TO_ADDR
// end ;
60345: LD_VAR 0 3
60349: RET
// export function First ( array ) ; begin
60350: LD_INT 0
60352: PPUSH
// if not array then
60353: LD_VAR 0 1
60357: NOT
60358: IFFALSE 60362
// exit ;
60360: GO 60376
// result := array [ 1 ] ;
60362: LD_ADDR_VAR 0 2
60366: PUSH
60367: LD_VAR 0 1
60371: PUSH
60372: LD_INT 1
60374: ARRAY
60375: ST_TO_ADDR
// end ;
60376: LD_VAR 0 2
60380: RET
// export function Last ( array ) ; begin
60381: LD_INT 0
60383: PPUSH
// if not array then
60384: LD_VAR 0 1
60388: NOT
60389: IFFALSE 60393
// exit ;
60391: GO 60409
// result := array [ array ] ;
60393: LD_ADDR_VAR 0 2
60397: PUSH
60398: LD_VAR 0 1
60402: PUSH
60403: LD_VAR 0 1
60407: ARRAY
60408: ST_TO_ADDR
// end ;
60409: LD_VAR 0 2
60413: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
60414: LD_INT 0
60416: PPUSH
60417: PPUSH
// result := [ ] ;
60418: LD_ADDR_VAR 0 5
60422: PUSH
60423: EMPTY
60424: ST_TO_ADDR
// if not array then
60425: LD_VAR 0 1
60429: NOT
60430: IFFALSE 60434
// exit ;
60432: GO 60546
// for i := 1 to array do
60434: LD_ADDR_VAR 0 6
60438: PUSH
60439: DOUBLE
60440: LD_INT 1
60442: DEC
60443: ST_TO_ADDR
60444: LD_VAR 0 1
60448: PUSH
60449: FOR_TO
60450: IFFALSE 60544
// if array [ i ] [ index ] = value then
60452: LD_VAR 0 1
60456: PUSH
60457: LD_VAR 0 6
60461: ARRAY
60462: PUSH
60463: LD_VAR 0 2
60467: ARRAY
60468: PUSH
60469: LD_VAR 0 3
60473: EQUAL
60474: IFFALSE 60542
// begin if indexColumn then
60476: LD_VAR 0 4
60480: IFFALSE 60516
// result := Join ( result , array [ i ] [ indexColumn ] ) else
60482: LD_ADDR_VAR 0 5
60486: PUSH
60487: LD_VAR 0 5
60491: PPUSH
60492: LD_VAR 0 1
60496: PUSH
60497: LD_VAR 0 6
60501: ARRAY
60502: PUSH
60503: LD_VAR 0 4
60507: ARRAY
60508: PPUSH
60509: CALL 55554 0 2
60513: ST_TO_ADDR
60514: GO 60542
// result := Join ( result , array [ i ] ) ;
60516: LD_ADDR_VAR 0 5
60520: PUSH
60521: LD_VAR 0 5
60525: PPUSH
60526: LD_VAR 0 1
60530: PUSH
60531: LD_VAR 0 6
60535: ARRAY
60536: PPUSH
60537: CALL 55554 0 2
60541: ST_TO_ADDR
// end ;
60542: GO 60449
60544: POP
60545: POP
// end ;
60546: LD_VAR 0 5
60550: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
60551: LD_INT 0
60553: PPUSH
// if not vehicles or not parkingPoint then
60554: LD_VAR 0 1
60558: NOT
60559: IFTRUE 60568
60561: PUSH
60562: LD_VAR 0 2
60566: NOT
60567: OR
60568: IFFALSE 60572
// exit ;
60570: GO 60670
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
60572: LD_ADDR_VAR 0 1
60576: PUSH
60577: LD_VAR 0 1
60581: PPUSH
60582: LD_INT 50
60584: PUSH
60585: EMPTY
60586: LIST
60587: PUSH
60588: LD_INT 3
60590: PUSH
60591: LD_INT 92
60593: PUSH
60594: LD_VAR 0 2
60598: PUSH
60599: LD_INT 1
60601: ARRAY
60602: PUSH
60603: LD_VAR 0 2
60607: PUSH
60608: LD_INT 2
60610: ARRAY
60611: PUSH
60612: LD_INT 8
60614: PUSH
60615: EMPTY
60616: LIST
60617: LIST
60618: LIST
60619: LIST
60620: PUSH
60621: EMPTY
60622: LIST
60623: LIST
60624: PUSH
60625: EMPTY
60626: LIST
60627: LIST
60628: PPUSH
60629: CALL_OW 72
60633: ST_TO_ADDR
// if not vehicles then
60634: LD_VAR 0 1
60638: NOT
60639: IFFALSE 60643
// exit ;
60641: GO 60670
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
60643: LD_VAR 0 1
60647: PPUSH
60648: LD_VAR 0 2
60652: PUSH
60653: LD_INT 1
60655: ARRAY
60656: PPUSH
60657: LD_VAR 0 2
60661: PUSH
60662: LD_INT 2
60664: ARRAY
60665: PPUSH
60666: CALL_OW 111
// end ;
60670: LD_VAR 0 3
60674: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
60675: LD_INT 0
60677: PPUSH
60678: PPUSH
60679: PPUSH
// if not side or not area then
60680: LD_VAR 0 1
60684: NOT
60685: IFTRUE 60694
60687: PUSH
60688: LD_VAR 0 2
60692: NOT
60693: OR
60694: IFFALSE 60698
// exit ;
60696: GO 60817
// tmp := AreaToList ( area , 0 ) ;
60698: LD_ADDR_VAR 0 5
60702: PUSH
60703: LD_VAR 0 2
60707: PPUSH
60708: LD_INT 0
60710: PPUSH
60711: CALL_OW 517
60715: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
60716: LD_ADDR_VAR 0 4
60720: PUSH
60721: DOUBLE
60722: LD_INT 1
60724: DEC
60725: ST_TO_ADDR
60726: LD_VAR 0 5
60730: PUSH
60731: LD_INT 1
60733: ARRAY
60734: PUSH
60735: FOR_TO
60736: IFFALSE 60815
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
60738: LD_VAR 0 5
60742: PUSH
60743: LD_INT 1
60745: ARRAY
60746: PUSH
60747: LD_VAR 0 4
60751: ARRAY
60752: PPUSH
60753: LD_VAR 0 5
60757: PUSH
60758: LD_INT 2
60760: ARRAY
60761: PUSH
60762: LD_VAR 0 4
60766: ARRAY
60767: PPUSH
60768: CALL_OW 351
60772: IFFALSE 60813
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60774: LD_VAR 0 5
60778: PUSH
60779: LD_INT 1
60781: ARRAY
60782: PUSH
60783: LD_VAR 0 4
60787: ARRAY
60788: PPUSH
60789: LD_VAR 0 5
60793: PUSH
60794: LD_INT 2
60796: ARRAY
60797: PUSH
60798: LD_VAR 0 4
60802: ARRAY
60803: PPUSH
60804: LD_VAR 0 1
60808: PPUSH
60809: CALL_OW 244
// end ;
60813: GO 60735
60815: POP
60816: POP
// end ;
60817: LD_VAR 0 3
60821: RET
// export function UniqueArray ( array ) ; var i ; begin
60822: LD_INT 0
60824: PPUSH
60825: PPUSH
// result := [ ] ;
60826: LD_ADDR_VAR 0 2
60830: PUSH
60831: EMPTY
60832: ST_TO_ADDR
// if not array then
60833: LD_VAR 0 1
60837: NOT
60838: IFFALSE 60842
// exit ;
60840: GO 60903
// for i := 1 to array do
60842: LD_ADDR_VAR 0 3
60846: PUSH
60847: DOUBLE
60848: LD_INT 1
60850: DEC
60851: ST_TO_ADDR
60852: LD_VAR 0 1
60856: PUSH
60857: FOR_TO
60858: IFFALSE 60901
// if not array [ i ] in result then
60860: LD_VAR 0 1
60864: PUSH
60865: LD_VAR 0 3
60869: ARRAY
60870: PUSH
60871: LD_VAR 0 2
60875: IN
60876: NOT
60877: IFFALSE 60899
// result := Join ( result , i ) ;
60879: LD_ADDR_VAR 0 2
60883: PUSH
60884: LD_VAR 0 2
60888: PPUSH
60889: LD_VAR 0 3
60893: PPUSH
60894: CALL 55554 0 2
60898: ST_TO_ADDR
60899: GO 60857
60901: POP
60902: POP
// end ; end_of_file
60903: LD_VAR 0 2
60907: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60908: LD_INT 0
60910: PPUSH
60911: PPUSH
// skirmish := false ;
60912: LD_ADDR_EXP 61
60916: PUSH
60917: LD_INT 0
60919: ST_TO_ADDR
// debug_mc := false ;
60920: LD_ADDR_EXP 62
60924: PUSH
60925: LD_INT 0
60927: ST_TO_ADDR
// mc_bases := [ ] ;
60928: LD_ADDR_EXP 63
60932: PUSH
60933: EMPTY
60934: ST_TO_ADDR
// mc_sides := [ ] ;
60935: LD_ADDR_EXP 89
60939: PUSH
60940: EMPTY
60941: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60942: LD_ADDR_EXP 64
60946: PUSH
60947: EMPTY
60948: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60949: LD_ADDR_EXP 65
60953: PUSH
60954: EMPTY
60955: ST_TO_ADDR
// mc_need_heal := [ ] ;
60956: LD_ADDR_EXP 66
60960: PUSH
60961: EMPTY
60962: ST_TO_ADDR
// mc_healers := [ ] ;
60963: LD_ADDR_EXP 67
60967: PUSH
60968: EMPTY
60969: ST_TO_ADDR
// mc_build_list := [ ] ;
60970: LD_ADDR_EXP 68
60974: PUSH
60975: EMPTY
60976: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60977: LD_ADDR_EXP 95
60981: PUSH
60982: EMPTY
60983: ST_TO_ADDR
// mc_builders := [ ] ;
60984: LD_ADDR_EXP 69
60988: PUSH
60989: EMPTY
60990: ST_TO_ADDR
// mc_construct_list := [ ] ;
60991: LD_ADDR_EXP 70
60995: PUSH
60996: EMPTY
60997: ST_TO_ADDR
// mc_turret_list := [ ] ;
60998: LD_ADDR_EXP 71
61002: PUSH
61003: EMPTY
61004: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
61005: LD_ADDR_EXP 72
61009: PUSH
61010: EMPTY
61011: ST_TO_ADDR
// mc_miners := [ ] ;
61012: LD_ADDR_EXP 77
61016: PUSH
61017: EMPTY
61018: ST_TO_ADDR
// mc_mines := [ ] ;
61019: LD_ADDR_EXP 76
61023: PUSH
61024: EMPTY
61025: ST_TO_ADDR
// mc_minefields := [ ] ;
61026: LD_ADDR_EXP 78
61030: PUSH
61031: EMPTY
61032: ST_TO_ADDR
// mc_crates := [ ] ;
61033: LD_ADDR_EXP 79
61037: PUSH
61038: EMPTY
61039: ST_TO_ADDR
// mc_crates_collector := [ ] ;
61040: LD_ADDR_EXP 80
61044: PUSH
61045: EMPTY
61046: ST_TO_ADDR
// mc_crates_area := [ ] ;
61047: LD_ADDR_EXP 81
61051: PUSH
61052: EMPTY
61053: ST_TO_ADDR
// mc_vehicles := [ ] ;
61054: LD_ADDR_EXP 82
61058: PUSH
61059: EMPTY
61060: ST_TO_ADDR
// mc_attack := [ ] ;
61061: LD_ADDR_EXP 83
61065: PUSH
61066: EMPTY
61067: ST_TO_ADDR
// mc_produce := [ ] ;
61068: LD_ADDR_EXP 84
61072: PUSH
61073: EMPTY
61074: ST_TO_ADDR
// mc_defender := [ ] ;
61075: LD_ADDR_EXP 85
61079: PUSH
61080: EMPTY
61081: ST_TO_ADDR
// mc_parking := [ ] ;
61082: LD_ADDR_EXP 87
61086: PUSH
61087: EMPTY
61088: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
61089: LD_ADDR_EXP 73
61093: PUSH
61094: EMPTY
61095: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
61096: LD_ADDR_EXP 75
61100: PUSH
61101: EMPTY
61102: ST_TO_ADDR
// mc_scan := [ ] ;
61103: LD_ADDR_EXP 86
61107: PUSH
61108: EMPTY
61109: ST_TO_ADDR
// mc_scan_area := [ ] ;
61110: LD_ADDR_EXP 88
61114: PUSH
61115: EMPTY
61116: ST_TO_ADDR
// mc_tech := [ ] ;
61117: LD_ADDR_EXP 90
61121: PUSH
61122: EMPTY
61123: ST_TO_ADDR
// mc_class := [ ] ;
61124: LD_ADDR_EXP 104
61128: PUSH
61129: EMPTY
61130: ST_TO_ADDR
// mc_class_case_use := [ ] ;
61131: LD_ADDR_EXP 105
61135: PUSH
61136: EMPTY
61137: ST_TO_ADDR
// mc_is_defending := [ ] ;
61138: LD_ADDR_EXP 106
61142: PUSH
61143: EMPTY
61144: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
61145: LD_ADDR_EXP 97
61149: PUSH
61150: EMPTY
61151: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
61152: LD_ADDR_EXP 107
61156: PUSH
61157: LD_INT 0
61159: ST_TO_ADDR
// end ;
61160: LD_VAR 0 1
61164: RET
// export function MC_Kill ( base ) ; begin
61165: LD_INT 0
61167: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
61168: LD_ADDR_EXP 63
61172: PUSH
61173: LD_EXP 63
61177: PPUSH
61178: LD_VAR 0 1
61182: PPUSH
61183: EMPTY
61184: PPUSH
61185: CALL_OW 1
61189: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61190: LD_ADDR_EXP 64
61194: PUSH
61195: LD_EXP 64
61199: PPUSH
61200: LD_VAR 0 1
61204: PPUSH
61205: EMPTY
61206: PPUSH
61207: CALL_OW 1
61211: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61212: LD_ADDR_EXP 65
61216: PUSH
61217: LD_EXP 65
61221: PPUSH
61222: LD_VAR 0 1
61226: PPUSH
61227: EMPTY
61228: PPUSH
61229: CALL_OW 1
61233: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61234: LD_ADDR_EXP 66
61238: PUSH
61239: LD_EXP 66
61243: PPUSH
61244: LD_VAR 0 1
61248: PPUSH
61249: EMPTY
61250: PPUSH
61251: CALL_OW 1
61255: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61256: LD_ADDR_EXP 67
61260: PUSH
61261: LD_EXP 67
61265: PPUSH
61266: LD_VAR 0 1
61270: PPUSH
61271: EMPTY
61272: PPUSH
61273: CALL_OW 1
61277: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61278: LD_ADDR_EXP 68
61282: PUSH
61283: LD_EXP 68
61287: PPUSH
61288: LD_VAR 0 1
61292: PPUSH
61293: EMPTY
61294: PPUSH
61295: CALL_OW 1
61299: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61300: LD_ADDR_EXP 69
61304: PUSH
61305: LD_EXP 69
61309: PPUSH
61310: LD_VAR 0 1
61314: PPUSH
61315: EMPTY
61316: PPUSH
61317: CALL_OW 1
61321: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61322: LD_ADDR_EXP 70
61326: PUSH
61327: LD_EXP 70
61331: PPUSH
61332: LD_VAR 0 1
61336: PPUSH
61337: EMPTY
61338: PPUSH
61339: CALL_OW 1
61343: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61344: LD_ADDR_EXP 71
61348: PUSH
61349: LD_EXP 71
61353: PPUSH
61354: LD_VAR 0 1
61358: PPUSH
61359: EMPTY
61360: PPUSH
61361: CALL_OW 1
61365: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61366: LD_ADDR_EXP 72
61370: PUSH
61371: LD_EXP 72
61375: PPUSH
61376: LD_VAR 0 1
61380: PPUSH
61381: EMPTY
61382: PPUSH
61383: CALL_OW 1
61387: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61388: LD_ADDR_EXP 73
61392: PUSH
61393: LD_EXP 73
61397: PPUSH
61398: LD_VAR 0 1
61402: PPUSH
61403: EMPTY
61404: PPUSH
61405: CALL_OW 1
61409: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61410: LD_ADDR_EXP 74
61414: PUSH
61415: LD_EXP 74
61419: PPUSH
61420: LD_VAR 0 1
61424: PPUSH
61425: LD_INT 0
61427: PPUSH
61428: CALL_OW 1
61432: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61433: LD_ADDR_EXP 75
61437: PUSH
61438: LD_EXP 75
61442: PPUSH
61443: LD_VAR 0 1
61447: PPUSH
61448: EMPTY
61449: PPUSH
61450: CALL_OW 1
61454: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61455: LD_ADDR_EXP 76
61459: PUSH
61460: LD_EXP 76
61464: PPUSH
61465: LD_VAR 0 1
61469: PPUSH
61470: EMPTY
61471: PPUSH
61472: CALL_OW 1
61476: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61477: LD_ADDR_EXP 77
61481: PUSH
61482: LD_EXP 77
61486: PPUSH
61487: LD_VAR 0 1
61491: PPUSH
61492: EMPTY
61493: PPUSH
61494: CALL_OW 1
61498: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61499: LD_ADDR_EXP 78
61503: PUSH
61504: LD_EXP 78
61508: PPUSH
61509: LD_VAR 0 1
61513: PPUSH
61514: EMPTY
61515: PPUSH
61516: CALL_OW 1
61520: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61521: LD_ADDR_EXP 79
61525: PUSH
61526: LD_EXP 79
61530: PPUSH
61531: LD_VAR 0 1
61535: PPUSH
61536: EMPTY
61537: PPUSH
61538: CALL_OW 1
61542: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61543: LD_ADDR_EXP 80
61547: PUSH
61548: LD_EXP 80
61552: PPUSH
61553: LD_VAR 0 1
61557: PPUSH
61558: EMPTY
61559: PPUSH
61560: CALL_OW 1
61564: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61565: LD_ADDR_EXP 81
61569: PUSH
61570: LD_EXP 81
61574: PPUSH
61575: LD_VAR 0 1
61579: PPUSH
61580: EMPTY
61581: PPUSH
61582: CALL_OW 1
61586: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61587: LD_ADDR_EXP 82
61591: PUSH
61592: LD_EXP 82
61596: PPUSH
61597: LD_VAR 0 1
61601: PPUSH
61602: EMPTY
61603: PPUSH
61604: CALL_OW 1
61608: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61609: LD_ADDR_EXP 83
61613: PUSH
61614: LD_EXP 83
61618: PPUSH
61619: LD_VAR 0 1
61623: PPUSH
61624: EMPTY
61625: PPUSH
61626: CALL_OW 1
61630: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61631: LD_ADDR_EXP 84
61635: PUSH
61636: LD_EXP 84
61640: PPUSH
61641: LD_VAR 0 1
61645: PPUSH
61646: EMPTY
61647: PPUSH
61648: CALL_OW 1
61652: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61653: LD_ADDR_EXP 85
61657: PUSH
61658: LD_EXP 85
61662: PPUSH
61663: LD_VAR 0 1
61667: PPUSH
61668: EMPTY
61669: PPUSH
61670: CALL_OW 1
61674: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61675: LD_ADDR_EXP 86
61679: PUSH
61680: LD_EXP 86
61684: PPUSH
61685: LD_VAR 0 1
61689: PPUSH
61690: EMPTY
61691: PPUSH
61692: CALL_OW 1
61696: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61697: LD_ADDR_EXP 87
61701: PUSH
61702: LD_EXP 87
61706: PPUSH
61707: LD_VAR 0 1
61711: PPUSH
61712: EMPTY
61713: PPUSH
61714: CALL_OW 1
61718: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61719: LD_ADDR_EXP 88
61723: PUSH
61724: LD_EXP 88
61728: PPUSH
61729: LD_VAR 0 1
61733: PPUSH
61734: EMPTY
61735: PPUSH
61736: CALL_OW 1
61740: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61741: LD_ADDR_EXP 90
61745: PUSH
61746: LD_EXP 90
61750: PPUSH
61751: LD_VAR 0 1
61755: PPUSH
61756: EMPTY
61757: PPUSH
61758: CALL_OW 1
61762: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61763: LD_ADDR_EXP 92
61767: PUSH
61768: LD_EXP 92
61772: PPUSH
61773: LD_VAR 0 1
61777: PPUSH
61778: EMPTY
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61785: LD_ADDR_EXP 93
61789: PUSH
61790: LD_EXP 93
61794: PPUSH
61795: LD_VAR 0 1
61799: PPUSH
61800: EMPTY
61801: PPUSH
61802: CALL_OW 1
61806: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61807: LD_ADDR_EXP 94
61811: PUSH
61812: LD_EXP 94
61816: PPUSH
61817: LD_VAR 0 1
61821: PPUSH
61822: EMPTY
61823: PPUSH
61824: CALL_OW 1
61828: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61829: LD_ADDR_EXP 95
61833: PUSH
61834: LD_EXP 95
61838: PPUSH
61839: LD_VAR 0 1
61843: PPUSH
61844: EMPTY
61845: PPUSH
61846: CALL_OW 1
61850: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61851: LD_ADDR_EXP 96
61855: PUSH
61856: LD_EXP 96
61860: PPUSH
61861: LD_VAR 0 1
61865: PPUSH
61866: EMPTY
61867: PPUSH
61868: CALL_OW 1
61872: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61873: LD_ADDR_EXP 97
61877: PUSH
61878: LD_EXP 97
61882: PPUSH
61883: LD_VAR 0 1
61887: PPUSH
61888: EMPTY
61889: PPUSH
61890: CALL_OW 1
61894: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61895: LD_ADDR_EXP 98
61899: PUSH
61900: LD_EXP 98
61904: PPUSH
61905: LD_VAR 0 1
61909: PPUSH
61910: EMPTY
61911: PPUSH
61912: CALL_OW 1
61916: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61917: LD_ADDR_EXP 99
61921: PUSH
61922: LD_EXP 99
61926: PPUSH
61927: LD_VAR 0 1
61931: PPUSH
61932: EMPTY
61933: PPUSH
61934: CALL_OW 1
61938: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61939: LD_ADDR_EXP 100
61943: PUSH
61944: LD_EXP 100
61948: PPUSH
61949: LD_VAR 0 1
61953: PPUSH
61954: EMPTY
61955: PPUSH
61956: CALL_OW 1
61960: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61961: LD_ADDR_EXP 101
61965: PUSH
61966: LD_EXP 101
61970: PPUSH
61971: LD_VAR 0 1
61975: PPUSH
61976: EMPTY
61977: PPUSH
61978: CALL_OW 1
61982: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61983: LD_ADDR_EXP 102
61987: PUSH
61988: LD_EXP 102
61992: PPUSH
61993: LD_VAR 0 1
61997: PPUSH
61998: EMPTY
61999: PPUSH
62000: CALL_OW 1
62004: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62005: LD_ADDR_EXP 103
62009: PUSH
62010: LD_EXP 103
62014: PPUSH
62015: LD_VAR 0 1
62019: PPUSH
62020: EMPTY
62021: PPUSH
62022: CALL_OW 1
62026: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62027: LD_ADDR_EXP 104
62031: PUSH
62032: LD_EXP 104
62036: PPUSH
62037: LD_VAR 0 1
62041: PPUSH
62042: EMPTY
62043: PPUSH
62044: CALL_OW 1
62048: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62049: LD_ADDR_EXP 105
62053: PUSH
62054: LD_EXP 105
62058: PPUSH
62059: LD_VAR 0 1
62063: PPUSH
62064: LD_INT 0
62066: PPUSH
62067: CALL_OW 1
62071: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62072: LD_ADDR_EXP 106
62076: PUSH
62077: LD_EXP 106
62081: PPUSH
62082: LD_VAR 0 1
62086: PPUSH
62087: LD_INT 0
62089: PPUSH
62090: CALL_OW 1
62094: ST_TO_ADDR
// end ;
62095: LD_VAR 0 2
62099: RET
// export function MC_Add ( side , units ) ; var base ; begin
62100: LD_INT 0
62102: PPUSH
62103: PPUSH
// base := mc_bases + 1 ;
62104: LD_ADDR_VAR 0 4
62108: PUSH
62109: LD_EXP 63
62113: PUSH
62114: LD_INT 1
62116: PLUS
62117: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
62118: LD_ADDR_EXP 89
62122: PUSH
62123: LD_EXP 89
62127: PPUSH
62128: LD_VAR 0 4
62132: PPUSH
62133: LD_VAR 0 1
62137: PPUSH
62138: CALL_OW 1
62142: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
62143: LD_ADDR_EXP 63
62147: PUSH
62148: LD_EXP 63
62152: PPUSH
62153: LD_VAR 0 4
62157: PPUSH
62158: LD_VAR 0 2
62162: PPUSH
62163: CALL_OW 1
62167: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
62168: LD_ADDR_EXP 64
62172: PUSH
62173: LD_EXP 64
62177: PPUSH
62178: LD_VAR 0 4
62182: PPUSH
62183: EMPTY
62184: PPUSH
62185: CALL_OW 1
62189: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
62190: LD_ADDR_EXP 65
62194: PUSH
62195: LD_EXP 65
62199: PPUSH
62200: LD_VAR 0 4
62204: PPUSH
62205: EMPTY
62206: PPUSH
62207: CALL_OW 1
62211: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
62212: LD_ADDR_EXP 66
62216: PUSH
62217: LD_EXP 66
62221: PPUSH
62222: LD_VAR 0 4
62226: PPUSH
62227: EMPTY
62228: PPUSH
62229: CALL_OW 1
62233: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
62234: LD_ADDR_EXP 67
62238: PUSH
62239: LD_EXP 67
62243: PPUSH
62244: LD_VAR 0 4
62248: PPUSH
62249: EMPTY
62250: PPUSH
62251: CALL_OW 1
62255: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
62256: LD_ADDR_EXP 68
62260: PUSH
62261: LD_EXP 68
62265: PPUSH
62266: LD_VAR 0 4
62270: PPUSH
62271: EMPTY
62272: PPUSH
62273: CALL_OW 1
62277: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
62278: LD_ADDR_EXP 69
62282: PUSH
62283: LD_EXP 69
62287: PPUSH
62288: LD_VAR 0 4
62292: PPUSH
62293: EMPTY
62294: PPUSH
62295: CALL_OW 1
62299: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
62300: LD_ADDR_EXP 70
62304: PUSH
62305: LD_EXP 70
62309: PPUSH
62310: LD_VAR 0 4
62314: PPUSH
62315: EMPTY
62316: PPUSH
62317: CALL_OW 1
62321: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
62322: LD_ADDR_EXP 71
62326: PUSH
62327: LD_EXP 71
62331: PPUSH
62332: LD_VAR 0 4
62336: PPUSH
62337: EMPTY
62338: PPUSH
62339: CALL_OW 1
62343: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
62344: LD_ADDR_EXP 72
62348: PUSH
62349: LD_EXP 72
62353: PPUSH
62354: LD_VAR 0 4
62358: PPUSH
62359: EMPTY
62360: PPUSH
62361: CALL_OW 1
62365: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
62366: LD_ADDR_EXP 73
62370: PUSH
62371: LD_EXP 73
62375: PPUSH
62376: LD_VAR 0 4
62380: PPUSH
62381: EMPTY
62382: PPUSH
62383: CALL_OW 1
62387: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
62388: LD_ADDR_EXP 74
62392: PUSH
62393: LD_EXP 74
62397: PPUSH
62398: LD_VAR 0 4
62402: PPUSH
62403: LD_INT 0
62405: PPUSH
62406: CALL_OW 1
62410: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
62411: LD_ADDR_EXP 75
62415: PUSH
62416: LD_EXP 75
62420: PPUSH
62421: LD_VAR 0 4
62425: PPUSH
62426: EMPTY
62427: PPUSH
62428: CALL_OW 1
62432: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
62433: LD_ADDR_EXP 76
62437: PUSH
62438: LD_EXP 76
62442: PPUSH
62443: LD_VAR 0 4
62447: PPUSH
62448: EMPTY
62449: PPUSH
62450: CALL_OW 1
62454: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
62455: LD_ADDR_EXP 77
62459: PUSH
62460: LD_EXP 77
62464: PPUSH
62465: LD_VAR 0 4
62469: PPUSH
62470: EMPTY
62471: PPUSH
62472: CALL_OW 1
62476: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
62477: LD_ADDR_EXP 78
62481: PUSH
62482: LD_EXP 78
62486: PPUSH
62487: LD_VAR 0 4
62491: PPUSH
62492: EMPTY
62493: PPUSH
62494: CALL_OW 1
62498: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
62499: LD_ADDR_EXP 79
62503: PUSH
62504: LD_EXP 79
62508: PPUSH
62509: LD_VAR 0 4
62513: PPUSH
62514: EMPTY
62515: PPUSH
62516: CALL_OW 1
62520: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
62521: LD_ADDR_EXP 80
62525: PUSH
62526: LD_EXP 80
62530: PPUSH
62531: LD_VAR 0 4
62535: PPUSH
62536: EMPTY
62537: PPUSH
62538: CALL_OW 1
62542: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
62543: LD_ADDR_EXP 81
62547: PUSH
62548: LD_EXP 81
62552: PPUSH
62553: LD_VAR 0 4
62557: PPUSH
62558: EMPTY
62559: PPUSH
62560: CALL_OW 1
62564: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
62565: LD_ADDR_EXP 82
62569: PUSH
62570: LD_EXP 82
62574: PPUSH
62575: LD_VAR 0 4
62579: PPUSH
62580: EMPTY
62581: PPUSH
62582: CALL_OW 1
62586: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
62587: LD_ADDR_EXP 83
62591: PUSH
62592: LD_EXP 83
62596: PPUSH
62597: LD_VAR 0 4
62601: PPUSH
62602: EMPTY
62603: PPUSH
62604: CALL_OW 1
62608: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
62609: LD_ADDR_EXP 84
62613: PUSH
62614: LD_EXP 84
62618: PPUSH
62619: LD_VAR 0 4
62623: PPUSH
62624: EMPTY
62625: PPUSH
62626: CALL_OW 1
62630: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
62631: LD_ADDR_EXP 85
62635: PUSH
62636: LD_EXP 85
62640: PPUSH
62641: LD_VAR 0 4
62645: PPUSH
62646: EMPTY
62647: PPUSH
62648: CALL_OW 1
62652: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
62653: LD_ADDR_EXP 86
62657: PUSH
62658: LD_EXP 86
62662: PPUSH
62663: LD_VAR 0 4
62667: PPUSH
62668: EMPTY
62669: PPUSH
62670: CALL_OW 1
62674: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
62675: LD_ADDR_EXP 87
62679: PUSH
62680: LD_EXP 87
62684: PPUSH
62685: LD_VAR 0 4
62689: PPUSH
62690: EMPTY
62691: PPUSH
62692: CALL_OW 1
62696: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
62697: LD_ADDR_EXP 88
62701: PUSH
62702: LD_EXP 88
62706: PPUSH
62707: LD_VAR 0 4
62711: PPUSH
62712: EMPTY
62713: PPUSH
62714: CALL_OW 1
62718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
62719: LD_ADDR_EXP 90
62723: PUSH
62724: LD_EXP 90
62728: PPUSH
62729: LD_VAR 0 4
62733: PPUSH
62734: EMPTY
62735: PPUSH
62736: CALL_OW 1
62740: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
62741: LD_ADDR_EXP 92
62745: PUSH
62746: LD_EXP 92
62750: PPUSH
62751: LD_VAR 0 4
62755: PPUSH
62756: EMPTY
62757: PPUSH
62758: CALL_OW 1
62762: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62763: LD_ADDR_EXP 93
62767: PUSH
62768: LD_EXP 93
62772: PPUSH
62773: LD_VAR 0 4
62777: PPUSH
62778: EMPTY
62779: PPUSH
62780: CALL_OW 1
62784: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62785: LD_ADDR_EXP 94
62789: PUSH
62790: LD_EXP 94
62794: PPUSH
62795: LD_VAR 0 4
62799: PPUSH
62800: EMPTY
62801: PPUSH
62802: CALL_OW 1
62806: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62807: LD_ADDR_EXP 95
62811: PUSH
62812: LD_EXP 95
62816: PPUSH
62817: LD_VAR 0 4
62821: PPUSH
62822: EMPTY
62823: PPUSH
62824: CALL_OW 1
62828: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62829: LD_ADDR_EXP 96
62833: PUSH
62834: LD_EXP 96
62838: PPUSH
62839: LD_VAR 0 4
62843: PPUSH
62844: EMPTY
62845: PPUSH
62846: CALL_OW 1
62850: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62851: LD_ADDR_EXP 97
62855: PUSH
62856: LD_EXP 97
62860: PPUSH
62861: LD_VAR 0 4
62865: PPUSH
62866: EMPTY
62867: PPUSH
62868: CALL_OW 1
62872: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62873: LD_ADDR_EXP 98
62877: PUSH
62878: LD_EXP 98
62882: PPUSH
62883: LD_VAR 0 4
62887: PPUSH
62888: EMPTY
62889: PPUSH
62890: CALL_OW 1
62894: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62895: LD_ADDR_EXP 99
62899: PUSH
62900: LD_EXP 99
62904: PPUSH
62905: LD_VAR 0 4
62909: PPUSH
62910: EMPTY
62911: PPUSH
62912: CALL_OW 1
62916: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62917: LD_ADDR_EXP 100
62921: PUSH
62922: LD_EXP 100
62926: PPUSH
62927: LD_VAR 0 4
62931: PPUSH
62932: EMPTY
62933: PPUSH
62934: CALL_OW 1
62938: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62939: LD_ADDR_EXP 101
62943: PUSH
62944: LD_EXP 101
62948: PPUSH
62949: LD_VAR 0 4
62953: PPUSH
62954: EMPTY
62955: PPUSH
62956: CALL_OW 1
62960: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62961: LD_ADDR_EXP 102
62965: PUSH
62966: LD_EXP 102
62970: PPUSH
62971: LD_VAR 0 4
62975: PPUSH
62976: EMPTY
62977: PPUSH
62978: CALL_OW 1
62982: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62983: LD_ADDR_EXP 103
62987: PUSH
62988: LD_EXP 103
62992: PPUSH
62993: LD_VAR 0 4
62997: PPUSH
62998: EMPTY
62999: PPUSH
63000: CALL_OW 1
63004: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
63005: LD_ADDR_EXP 104
63009: PUSH
63010: LD_EXP 104
63014: PPUSH
63015: LD_VAR 0 4
63019: PPUSH
63020: EMPTY
63021: PPUSH
63022: CALL_OW 1
63026: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
63027: LD_ADDR_EXP 105
63031: PUSH
63032: LD_EXP 105
63036: PPUSH
63037: LD_VAR 0 4
63041: PPUSH
63042: LD_INT 0
63044: PPUSH
63045: CALL_OW 1
63049: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
63050: LD_ADDR_EXP 106
63054: PUSH
63055: LD_EXP 106
63059: PPUSH
63060: LD_VAR 0 4
63064: PPUSH
63065: LD_INT 0
63067: PPUSH
63068: CALL_OW 1
63072: ST_TO_ADDR
// result := base ;
63073: LD_ADDR_VAR 0 3
63077: PUSH
63078: LD_VAR 0 4
63082: ST_TO_ADDR
// end ;
63083: LD_VAR 0 3
63087: RET
// export function MC_Start ( ) ; var i ; begin
63088: LD_INT 0
63090: PPUSH
63091: PPUSH
// for i = 1 to mc_bases do
63092: LD_ADDR_VAR 0 2
63096: PUSH
63097: DOUBLE
63098: LD_INT 1
63100: DEC
63101: ST_TO_ADDR
63102: LD_EXP 63
63106: PUSH
63107: FOR_TO
63108: IFFALSE 64208
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
63110: LD_ADDR_EXP 63
63114: PUSH
63115: LD_EXP 63
63119: PPUSH
63120: LD_VAR 0 2
63124: PPUSH
63125: LD_EXP 63
63129: PUSH
63130: LD_VAR 0 2
63134: ARRAY
63135: PUSH
63136: LD_INT 0
63138: DIFF
63139: PPUSH
63140: CALL_OW 1
63144: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
63145: LD_ADDR_EXP 64
63149: PUSH
63150: LD_EXP 64
63154: PPUSH
63155: LD_VAR 0 2
63159: PPUSH
63160: EMPTY
63161: PPUSH
63162: CALL_OW 1
63166: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63167: LD_ADDR_EXP 65
63171: PUSH
63172: LD_EXP 65
63176: PPUSH
63177: LD_VAR 0 2
63181: PPUSH
63182: EMPTY
63183: PPUSH
63184: CALL_OW 1
63188: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
63189: LD_ADDR_EXP 66
63193: PUSH
63194: LD_EXP 66
63198: PPUSH
63199: LD_VAR 0 2
63203: PPUSH
63204: EMPTY
63205: PPUSH
63206: CALL_OW 1
63210: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
63211: LD_ADDR_EXP 67
63215: PUSH
63216: LD_EXP 67
63220: PPUSH
63221: LD_VAR 0 2
63225: PPUSH
63226: EMPTY
63227: PUSH
63228: EMPTY
63229: PUSH
63230: EMPTY
63231: LIST
63232: LIST
63233: PPUSH
63234: CALL_OW 1
63238: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
63239: LD_ADDR_EXP 68
63243: PUSH
63244: LD_EXP 68
63248: PPUSH
63249: LD_VAR 0 2
63253: PPUSH
63254: EMPTY
63255: PPUSH
63256: CALL_OW 1
63260: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
63261: LD_ADDR_EXP 95
63265: PUSH
63266: LD_EXP 95
63270: PPUSH
63271: LD_VAR 0 2
63275: PPUSH
63276: EMPTY
63277: PPUSH
63278: CALL_OW 1
63282: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
63283: LD_ADDR_EXP 69
63287: PUSH
63288: LD_EXP 69
63292: PPUSH
63293: LD_VAR 0 2
63297: PPUSH
63298: EMPTY
63299: PPUSH
63300: CALL_OW 1
63304: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
63305: LD_ADDR_EXP 70
63309: PUSH
63310: LD_EXP 70
63314: PPUSH
63315: LD_VAR 0 2
63319: PPUSH
63320: EMPTY
63321: PPUSH
63322: CALL_OW 1
63326: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
63327: LD_ADDR_EXP 71
63331: PUSH
63332: LD_EXP 71
63336: PPUSH
63337: LD_VAR 0 2
63341: PPUSH
63342: LD_EXP 63
63346: PUSH
63347: LD_VAR 0 2
63351: ARRAY
63352: PPUSH
63353: LD_INT 2
63355: PUSH
63356: LD_INT 30
63358: PUSH
63359: LD_INT 32
63361: PUSH
63362: EMPTY
63363: LIST
63364: LIST
63365: PUSH
63366: LD_INT 30
63368: PUSH
63369: LD_INT 33
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PUSH
63376: EMPTY
63377: LIST
63378: LIST
63379: LIST
63380: PPUSH
63381: CALL_OW 72
63385: PPUSH
63386: CALL_OW 1
63390: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
63391: LD_ADDR_EXP 72
63395: PUSH
63396: LD_EXP 72
63400: PPUSH
63401: LD_VAR 0 2
63405: PPUSH
63406: LD_EXP 63
63410: PUSH
63411: LD_VAR 0 2
63415: ARRAY
63416: PPUSH
63417: LD_INT 2
63419: PUSH
63420: LD_INT 30
63422: PUSH
63423: LD_INT 32
63425: PUSH
63426: EMPTY
63427: LIST
63428: LIST
63429: PUSH
63430: LD_INT 30
63432: PUSH
63433: LD_INT 31
63435: PUSH
63436: EMPTY
63437: LIST
63438: LIST
63439: PUSH
63440: EMPTY
63441: LIST
63442: LIST
63443: LIST
63444: PUSH
63445: LD_INT 58
63447: PUSH
63448: EMPTY
63449: LIST
63450: PUSH
63451: EMPTY
63452: LIST
63453: LIST
63454: PPUSH
63455: CALL_OW 72
63459: PPUSH
63460: CALL_OW 1
63464: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
63465: LD_ADDR_EXP 73
63469: PUSH
63470: LD_EXP 73
63474: PPUSH
63475: LD_VAR 0 2
63479: PPUSH
63480: EMPTY
63481: PPUSH
63482: CALL_OW 1
63486: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
63487: LD_ADDR_EXP 77
63491: PUSH
63492: LD_EXP 77
63496: PPUSH
63497: LD_VAR 0 2
63501: PPUSH
63502: EMPTY
63503: PPUSH
63504: CALL_OW 1
63508: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
63509: LD_ADDR_EXP 76
63513: PUSH
63514: LD_EXP 76
63518: PPUSH
63519: LD_VAR 0 2
63523: PPUSH
63524: EMPTY
63525: PPUSH
63526: CALL_OW 1
63530: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
63531: LD_ADDR_EXP 78
63535: PUSH
63536: LD_EXP 78
63540: PPUSH
63541: LD_VAR 0 2
63545: PPUSH
63546: EMPTY
63547: PPUSH
63548: CALL_OW 1
63552: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
63553: LD_ADDR_EXP 79
63557: PUSH
63558: LD_EXP 79
63562: PPUSH
63563: LD_VAR 0 2
63567: PPUSH
63568: EMPTY
63569: PPUSH
63570: CALL_OW 1
63574: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63575: LD_ADDR_EXP 80
63579: PUSH
63580: LD_EXP 80
63584: PPUSH
63585: LD_VAR 0 2
63589: PPUSH
63590: EMPTY
63591: PPUSH
63592: CALL_OW 1
63596: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
63597: LD_ADDR_EXP 81
63601: PUSH
63602: LD_EXP 81
63606: PPUSH
63607: LD_VAR 0 2
63611: PPUSH
63612: EMPTY
63613: PPUSH
63614: CALL_OW 1
63618: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
63619: LD_ADDR_EXP 82
63623: PUSH
63624: LD_EXP 82
63628: PPUSH
63629: LD_VAR 0 2
63633: PPUSH
63634: EMPTY
63635: PPUSH
63636: CALL_OW 1
63640: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
63641: LD_ADDR_EXP 83
63645: PUSH
63646: LD_EXP 83
63650: PPUSH
63651: LD_VAR 0 2
63655: PPUSH
63656: EMPTY
63657: PPUSH
63658: CALL_OW 1
63662: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
63663: LD_ADDR_EXP 84
63667: PUSH
63668: LD_EXP 84
63672: PPUSH
63673: LD_VAR 0 2
63677: PPUSH
63678: EMPTY
63679: PPUSH
63680: CALL_OW 1
63684: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
63685: LD_ADDR_EXP 85
63689: PUSH
63690: LD_EXP 85
63694: PPUSH
63695: LD_VAR 0 2
63699: PPUSH
63700: EMPTY
63701: PPUSH
63702: CALL_OW 1
63706: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
63707: LD_ADDR_EXP 74
63711: PUSH
63712: LD_EXP 74
63716: PPUSH
63717: LD_VAR 0 2
63721: PPUSH
63722: LD_INT 0
63724: PPUSH
63725: CALL_OW 1
63729: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
63730: LD_ADDR_EXP 87
63734: PUSH
63735: LD_EXP 87
63739: PPUSH
63740: LD_VAR 0 2
63744: PPUSH
63745: LD_INT 0
63747: PPUSH
63748: CALL_OW 1
63752: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
63753: LD_ADDR_EXP 75
63757: PUSH
63758: LD_EXP 75
63762: PPUSH
63763: LD_VAR 0 2
63767: PPUSH
63768: EMPTY
63769: PPUSH
63770: CALL_OW 1
63774: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
63775: LD_ADDR_EXP 86
63779: PUSH
63780: LD_EXP 86
63784: PPUSH
63785: LD_VAR 0 2
63789: PPUSH
63790: LD_INT 0
63792: PPUSH
63793: CALL_OW 1
63797: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63798: LD_ADDR_EXP 88
63802: PUSH
63803: LD_EXP 88
63807: PPUSH
63808: LD_VAR 0 2
63812: PPUSH
63813: EMPTY
63814: PPUSH
63815: CALL_OW 1
63819: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63820: LD_ADDR_EXP 91
63824: PUSH
63825: LD_EXP 91
63829: PPUSH
63830: LD_VAR 0 2
63834: PPUSH
63835: LD_INT 0
63837: PPUSH
63838: CALL_OW 1
63842: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63843: LD_ADDR_EXP 92
63847: PUSH
63848: LD_EXP 92
63852: PPUSH
63853: LD_VAR 0 2
63857: PPUSH
63858: EMPTY
63859: PPUSH
63860: CALL_OW 1
63864: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63865: LD_ADDR_EXP 93
63869: PUSH
63870: LD_EXP 93
63874: PPUSH
63875: LD_VAR 0 2
63879: PPUSH
63880: EMPTY
63881: PPUSH
63882: CALL_OW 1
63886: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63887: LD_ADDR_EXP 94
63891: PUSH
63892: LD_EXP 94
63896: PPUSH
63897: LD_VAR 0 2
63901: PPUSH
63902: EMPTY
63903: PPUSH
63904: CALL_OW 1
63908: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63909: LD_ADDR_EXP 96
63913: PUSH
63914: LD_EXP 96
63918: PPUSH
63919: LD_VAR 0 2
63923: PPUSH
63924: LD_EXP 63
63928: PUSH
63929: LD_VAR 0 2
63933: ARRAY
63934: PPUSH
63935: LD_INT 2
63937: PUSH
63938: LD_INT 30
63940: PUSH
63941: LD_INT 6
63943: PUSH
63944: EMPTY
63945: LIST
63946: LIST
63947: PUSH
63948: LD_INT 30
63950: PUSH
63951: LD_INT 7
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PUSH
63958: LD_INT 30
63960: PUSH
63961: LD_INT 8
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PUSH
63968: EMPTY
63969: LIST
63970: LIST
63971: LIST
63972: LIST
63973: PPUSH
63974: CALL_OW 72
63978: PPUSH
63979: CALL_OW 1
63983: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63984: LD_ADDR_EXP 97
63988: PUSH
63989: LD_EXP 97
63993: PPUSH
63994: LD_VAR 0 2
63998: PPUSH
63999: EMPTY
64000: PPUSH
64001: CALL_OW 1
64005: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
64006: LD_ADDR_EXP 98
64010: PUSH
64011: LD_EXP 98
64015: PPUSH
64016: LD_VAR 0 2
64020: PPUSH
64021: EMPTY
64022: PPUSH
64023: CALL_OW 1
64027: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
64028: LD_ADDR_EXP 99
64032: PUSH
64033: LD_EXP 99
64037: PPUSH
64038: LD_VAR 0 2
64042: PPUSH
64043: EMPTY
64044: PPUSH
64045: CALL_OW 1
64049: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
64050: LD_ADDR_EXP 100
64054: PUSH
64055: LD_EXP 100
64059: PPUSH
64060: LD_VAR 0 2
64064: PPUSH
64065: EMPTY
64066: PPUSH
64067: CALL_OW 1
64071: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
64072: LD_ADDR_EXP 101
64076: PUSH
64077: LD_EXP 101
64081: PPUSH
64082: LD_VAR 0 2
64086: PPUSH
64087: EMPTY
64088: PPUSH
64089: CALL_OW 1
64093: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
64094: LD_ADDR_EXP 102
64098: PUSH
64099: LD_EXP 102
64103: PPUSH
64104: LD_VAR 0 2
64108: PPUSH
64109: EMPTY
64110: PPUSH
64111: CALL_OW 1
64115: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
64116: LD_ADDR_EXP 103
64120: PUSH
64121: LD_EXP 103
64125: PPUSH
64126: LD_VAR 0 2
64130: PPUSH
64131: EMPTY
64132: PPUSH
64133: CALL_OW 1
64137: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
64138: LD_ADDR_EXP 104
64142: PUSH
64143: LD_EXP 104
64147: PPUSH
64148: LD_VAR 0 2
64152: PPUSH
64153: EMPTY
64154: PPUSH
64155: CALL_OW 1
64159: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
64160: LD_ADDR_EXP 105
64164: PUSH
64165: LD_EXP 105
64169: PPUSH
64170: LD_VAR 0 2
64174: PPUSH
64175: LD_INT 0
64177: PPUSH
64178: CALL_OW 1
64182: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
64183: LD_ADDR_EXP 106
64187: PUSH
64188: LD_EXP 106
64192: PPUSH
64193: LD_VAR 0 2
64197: PPUSH
64198: LD_INT 0
64200: PPUSH
64201: CALL_OW 1
64205: ST_TO_ADDR
// end ;
64206: GO 63107
64208: POP
64209: POP
// MC_InitSides ( ) ;
64210: CALL 64496 0 0
// MC_InitResearch ( ) ;
64214: CALL 64235 0 0
// CustomInitMacro ( ) ;
64218: CALL 219 0 0
// skirmish := true ;
64222: LD_ADDR_EXP 61
64226: PUSH
64227: LD_INT 1
64229: ST_TO_ADDR
// end ;
64230: LD_VAR 0 1
64234: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
64235: LD_INT 0
64237: PPUSH
64238: PPUSH
64239: PPUSH
64240: PPUSH
64241: PPUSH
64242: PPUSH
// if not mc_bases then
64243: LD_EXP 63
64247: NOT
64248: IFFALSE 64252
// exit ;
64250: GO 64491
// for i = 1 to 8 do
64252: LD_ADDR_VAR 0 2
64256: PUSH
64257: DOUBLE
64258: LD_INT 1
64260: DEC
64261: ST_TO_ADDR
64262: LD_INT 8
64264: PUSH
64265: FOR_TO
64266: IFFALSE 64292
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
64268: LD_ADDR_EXP 90
64272: PUSH
64273: LD_EXP 90
64277: PPUSH
64278: LD_VAR 0 2
64282: PPUSH
64283: EMPTY
64284: PPUSH
64285: CALL_OW 1
64289: ST_TO_ADDR
64290: GO 64265
64292: POP
64293: POP
// tmp := [ ] ;
64294: LD_ADDR_VAR 0 5
64298: PUSH
64299: EMPTY
64300: ST_TO_ADDR
// for i = 1 to mc_sides do
64301: LD_ADDR_VAR 0 2
64305: PUSH
64306: DOUBLE
64307: LD_INT 1
64309: DEC
64310: ST_TO_ADDR
64311: LD_EXP 89
64315: PUSH
64316: FOR_TO
64317: IFFALSE 64375
// if not mc_sides [ i ] in tmp then
64319: LD_EXP 89
64323: PUSH
64324: LD_VAR 0 2
64328: ARRAY
64329: PUSH
64330: LD_VAR 0 5
64334: IN
64335: NOT
64336: IFFALSE 64373
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
64338: LD_ADDR_VAR 0 5
64342: PUSH
64343: LD_VAR 0 5
64347: PPUSH
64348: LD_VAR 0 5
64352: PUSH
64353: LD_INT 1
64355: PLUS
64356: PPUSH
64357: LD_EXP 89
64361: PUSH
64362: LD_VAR 0 2
64366: ARRAY
64367: PPUSH
64368: CALL_OW 2
64372: ST_TO_ADDR
64373: GO 64316
64375: POP
64376: POP
// if not tmp then
64377: LD_VAR 0 5
64381: NOT
64382: IFFALSE 64386
// exit ;
64384: GO 64491
// for j in tmp do
64386: LD_ADDR_VAR 0 3
64390: PUSH
64391: LD_VAR 0 5
64395: PUSH
64396: FOR_IN
64397: IFFALSE 64489
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
64399: LD_ADDR_VAR 0 6
64403: PUSH
64404: LD_INT 22
64406: PUSH
64407: LD_VAR 0 3
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PPUSH
64416: CALL_OW 69
64420: ST_TO_ADDR
// if not un then
64421: LD_VAR 0 6
64425: NOT
64426: IFFALSE 64430
// continue ;
64428: GO 64396
// nation := GetNation ( un [ 1 ] ) ;
64430: LD_ADDR_VAR 0 4
64434: PUSH
64435: LD_VAR 0 6
64439: PUSH
64440: LD_INT 1
64442: ARRAY
64443: PPUSH
64444: CALL_OW 248
64448: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
64449: LD_ADDR_EXP 90
64453: PUSH
64454: LD_EXP 90
64458: PPUSH
64459: LD_VAR 0 3
64463: PPUSH
64464: LD_VAR 0 3
64468: PPUSH
64469: LD_VAR 0 4
64473: PPUSH
64474: LD_INT 1
64476: PPUSH
64477: CALL 17545 0 3
64481: PPUSH
64482: CALL_OW 1
64486: ST_TO_ADDR
// end ;
64487: GO 64396
64489: POP
64490: POP
// end ;
64491: LD_VAR 0 1
64495: RET
// export function MC_InitSides ( ) ; var i ; begin
64496: LD_INT 0
64498: PPUSH
64499: PPUSH
// if not mc_bases then
64500: LD_EXP 63
64504: NOT
64505: IFFALSE 64509
// exit ;
64507: GO 64583
// for i = 1 to mc_bases do
64509: LD_ADDR_VAR 0 2
64513: PUSH
64514: DOUBLE
64515: LD_INT 1
64517: DEC
64518: ST_TO_ADDR
64519: LD_EXP 63
64523: PUSH
64524: FOR_TO
64525: IFFALSE 64581
// if mc_bases [ i ] then
64527: LD_EXP 63
64531: PUSH
64532: LD_VAR 0 2
64536: ARRAY
64537: IFFALSE 64579
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
64539: LD_ADDR_EXP 89
64543: PUSH
64544: LD_EXP 89
64548: PPUSH
64549: LD_VAR 0 2
64553: PPUSH
64554: LD_EXP 63
64558: PUSH
64559: LD_VAR 0 2
64563: ARRAY
64564: PUSH
64565: LD_INT 1
64567: ARRAY
64568: PPUSH
64569: CALL_OW 255
64573: PPUSH
64574: CALL_OW 1
64578: ST_TO_ADDR
64579: GO 64524
64581: POP
64582: POP
// end ;
64583: LD_VAR 0 1
64587: RET
// every 0 0$03 trigger skirmish do
64588: LD_EXP 61
64592: IFFALSE 64746
64594: GO 64596
64596: DISABLE
// begin enable ;
64597: ENABLE
// MC_CheckBuildings ( ) ;
64598: CALL 69304 0 0
// MC_CheckPeopleLife ( ) ;
64602: CALL 69465 0 0
// RaiseSailEvent ( 100 ) ;
64606: LD_INT 100
64608: PPUSH
64609: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
64613: LD_INT 103
64615: PPUSH
64616: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
64620: LD_INT 104
64622: PPUSH
64623: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
64627: LD_INT 105
64629: PPUSH
64630: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
64634: LD_INT 106
64636: PPUSH
64637: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
64641: LD_INT 107
64643: PPUSH
64644: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
64648: LD_INT 108
64650: PPUSH
64651: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
64655: LD_INT 109
64657: PPUSH
64658: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
64662: LD_INT 110
64664: PPUSH
64665: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
64669: LD_INT 111
64671: PPUSH
64672: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
64676: LD_INT 112
64678: PPUSH
64679: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
64683: LD_INT 113
64685: PPUSH
64686: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
64690: LD_INT 120
64692: PPUSH
64693: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
64697: LD_INT 121
64699: PPUSH
64700: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
64704: LD_INT 122
64706: PPUSH
64707: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
64711: LD_INT 123
64713: PPUSH
64714: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
64718: LD_INT 124
64720: PPUSH
64721: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
64725: LD_INT 125
64727: PPUSH
64728: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
64732: LD_INT 126
64734: PPUSH
64735: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
64739: LD_INT 200
64741: PPUSH
64742: CALL_OW 427
// end ;
64746: END
// on SailEvent ( event ) do begin if event < 100 then
64747: LD_VAR 0 1
64751: PUSH
64752: LD_INT 100
64754: LESS
64755: IFFALSE 64766
// CustomEvent ( event ) ;
64757: LD_VAR 0 1
64761: PPUSH
64762: CALL 16044 0 1
// if event = 100 then
64766: LD_VAR 0 1
64770: PUSH
64771: LD_INT 100
64773: EQUAL
64774: IFFALSE 64780
// MC_ClassManager ( ) ;
64776: CALL 65174 0 0
// if event = 101 then
64780: LD_VAR 0 1
64784: PUSH
64785: LD_INT 101
64787: EQUAL
64788: IFFALSE 64794
// MC_RepairBuildings ( ) ;
64790: CALL 70052 0 0
// if event = 102 then
64794: LD_VAR 0 1
64798: PUSH
64799: LD_INT 102
64801: EQUAL
64802: IFFALSE 64808
// MC_Heal ( ) ;
64804: CALL 70991 0 0
// if event = 103 then
64808: LD_VAR 0 1
64812: PUSH
64813: LD_INT 103
64815: EQUAL
64816: IFFALSE 64822
// MC_Build ( ) ;
64818: CALL 71417 0 0
// if event = 104 then
64822: LD_VAR 0 1
64826: PUSH
64827: LD_INT 104
64829: EQUAL
64830: IFFALSE 64836
// MC_TurretWeapon ( ) ;
64832: CALL 73065 0 0
// if event = 105 then
64836: LD_VAR 0 1
64840: PUSH
64841: LD_INT 105
64843: EQUAL
64844: IFFALSE 64850
// MC_BuildUpgrade ( ) ;
64846: CALL 72610 0 0
// if event = 106 then
64850: LD_VAR 0 1
64854: PUSH
64855: LD_INT 106
64857: EQUAL
64858: IFFALSE 64864
// MC_PlantMines ( ) ;
64860: CALL 73497 0 0
// if event = 107 then
64864: LD_VAR 0 1
64868: PUSH
64869: LD_INT 107
64871: EQUAL
64872: IFFALSE 64878
// MC_CollectCrates ( ) ;
64874: CALL 74307 0 0
// if event = 108 then
64878: LD_VAR 0 1
64882: PUSH
64883: LD_INT 108
64885: EQUAL
64886: IFFALSE 64892
// MC_LinkRemoteControl ( ) ;
64888: CALL 76181 0 0
// if event = 109 then
64892: LD_VAR 0 1
64896: PUSH
64897: LD_INT 109
64899: EQUAL
64900: IFFALSE 64906
// MC_ProduceVehicle ( ) ;
64902: CALL 76366 0 0
// if event = 110 then
64906: LD_VAR 0 1
64910: PUSH
64911: LD_INT 110
64913: EQUAL
64914: IFFALSE 64920
// MC_SendAttack ( ) ;
64916: CALL 76836 0 0
// if event = 111 then
64920: LD_VAR 0 1
64924: PUSH
64925: LD_INT 111
64927: EQUAL
64928: IFFALSE 64934
// MC_Defend ( ) ;
64930: CALL 76944 0 0
// if event = 112 then
64934: LD_VAR 0 1
64938: PUSH
64939: LD_INT 112
64941: EQUAL
64942: IFFALSE 64948
// MC_Research ( ) ;
64944: CALL 77844 0 0
// if event = 113 then
64948: LD_VAR 0 1
64952: PUSH
64953: LD_INT 113
64955: EQUAL
64956: IFFALSE 64962
// MC_MinesTrigger ( ) ;
64958: CALL 78984 0 0
// if event = 120 then
64962: LD_VAR 0 1
64966: PUSH
64967: LD_INT 120
64969: EQUAL
64970: IFFALSE 64976
// MC_RepairVehicle ( ) ;
64972: CALL 79085 0 0
// if event = 121 then
64976: LD_VAR 0 1
64980: PUSH
64981: LD_INT 121
64983: EQUAL
64984: IFFALSE 64990
// MC_TameApe ( ) ;
64986: CALL 79862 0 0
// if event = 122 then
64990: LD_VAR 0 1
64994: PUSH
64995: LD_INT 122
64997: EQUAL
64998: IFFALSE 65004
// MC_ChangeApeClass ( ) ;
65000: CALL 80707 0 0
// if event = 123 then
65004: LD_VAR 0 1
65008: PUSH
65009: LD_INT 123
65011: EQUAL
65012: IFFALSE 65018
// MC_Bazooka ( ) ;
65014: CALL 81363 0 0
// if event = 124 then
65018: LD_VAR 0 1
65022: PUSH
65023: LD_INT 124
65025: EQUAL
65026: IFFALSE 65032
// MC_TeleportExit ( ) ;
65028: CALL 81565 0 0
// if event = 125 then
65032: LD_VAR 0 1
65036: PUSH
65037: LD_INT 125
65039: EQUAL
65040: IFFALSE 65046
// MC_Deposits ( ) ;
65042: CALL 82222 0 0
// if event = 126 then
65046: LD_VAR 0 1
65050: PUSH
65051: LD_INT 126
65053: EQUAL
65054: IFFALSE 65060
// MC_RemoteDriver ( ) ;
65056: CALL 82855 0 0
// if event = 200 then
65060: LD_VAR 0 1
65064: PUSH
65065: LD_INT 200
65067: EQUAL
65068: IFFALSE 65074
// MC_Idle ( ) ;
65070: CALL 84790 0 0
// end ;
65074: PPOPN 1
65076: END
// export function MC_Reset ( base , tag ) ; var i ; begin
65077: LD_INT 0
65079: PPUSH
65080: PPUSH
// if not mc_bases [ base ] or not tag then
65081: LD_EXP 63
65085: PUSH
65086: LD_VAR 0 1
65090: ARRAY
65091: NOT
65092: IFTRUE 65101
65094: PUSH
65095: LD_VAR 0 2
65099: NOT
65100: OR
65101: IFFALSE 65105
// exit ;
65103: GO 65169
// for i in mc_bases [ base ] union mc_ape [ base ] do
65105: LD_ADDR_VAR 0 4
65109: PUSH
65110: LD_EXP 63
65114: PUSH
65115: LD_VAR 0 1
65119: ARRAY
65120: PUSH
65121: LD_EXP 92
65125: PUSH
65126: LD_VAR 0 1
65130: ARRAY
65131: UNION
65132: PUSH
65133: FOR_IN
65134: IFFALSE 65167
// if GetTag ( i ) = tag then
65136: LD_VAR 0 4
65140: PPUSH
65141: CALL_OW 110
65145: PUSH
65146: LD_VAR 0 2
65150: EQUAL
65151: IFFALSE 65165
// SetTag ( i , 0 ) ;
65153: LD_VAR 0 4
65157: PPUSH
65158: LD_INT 0
65160: PPUSH
65161: CALL_OW 109
65165: GO 65133
65167: POP
65168: POP
// end ;
65169: LD_VAR 0 3
65173: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
65174: LD_INT 0
65176: PPUSH
65177: PPUSH
65178: PPUSH
65179: PPUSH
65180: PPUSH
65181: PPUSH
65182: PPUSH
65183: PPUSH
// if not mc_bases then
65184: LD_EXP 63
65188: NOT
65189: IFFALSE 65193
// exit ;
65191: GO 65644
// for i = 1 to mc_bases do
65193: LD_ADDR_VAR 0 2
65197: PUSH
65198: DOUBLE
65199: LD_INT 1
65201: DEC
65202: ST_TO_ADDR
65203: LD_EXP 63
65207: PUSH
65208: FOR_TO
65209: IFFALSE 65642
// begin tmp := MC_ClassCheckReq ( i ) ;
65211: LD_ADDR_VAR 0 4
65215: PUSH
65216: LD_VAR 0 2
65220: PPUSH
65221: CALL 65649 0 1
65225: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
65226: LD_ADDR_EXP 104
65230: PUSH
65231: LD_EXP 104
65235: PPUSH
65236: LD_VAR 0 2
65240: PPUSH
65241: LD_VAR 0 4
65245: PPUSH
65246: CALL_OW 1
65250: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
65251: LD_ADDR_VAR 0 6
65255: PUSH
65256: LD_EXP 63
65260: PUSH
65261: LD_VAR 0 2
65265: ARRAY
65266: PPUSH
65267: LD_INT 2
65269: PUSH
65270: LD_INT 30
65272: PUSH
65273: LD_INT 4
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 30
65282: PUSH
65283: LD_INT 5
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: EMPTY
65291: LIST
65292: LIST
65293: LIST
65294: PPUSH
65295: CALL_OW 72
65299: PUSH
65300: LD_EXP 63
65304: PUSH
65305: LD_VAR 0 2
65309: ARRAY
65310: PPUSH
65311: LD_INT 2
65313: PUSH
65314: LD_INT 30
65316: PUSH
65317: LD_INT 0
65319: PUSH
65320: EMPTY
65321: LIST
65322: LIST
65323: PUSH
65324: LD_INT 30
65326: PUSH
65327: LD_INT 1
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: LIST
65338: PPUSH
65339: CALL_OW 72
65343: PUSH
65344: LD_EXP 63
65348: PUSH
65349: LD_VAR 0 2
65353: ARRAY
65354: PPUSH
65355: LD_INT 30
65357: PUSH
65358: LD_INT 3
65360: PUSH
65361: EMPTY
65362: LIST
65363: LIST
65364: PPUSH
65365: CALL_OW 72
65369: PUSH
65370: LD_EXP 63
65374: PUSH
65375: LD_VAR 0 2
65379: ARRAY
65380: PPUSH
65381: LD_INT 2
65383: PUSH
65384: LD_INT 30
65386: PUSH
65387: LD_INT 6
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: LD_INT 30
65396: PUSH
65397: LD_INT 7
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PUSH
65404: LD_INT 30
65406: PUSH
65407: LD_INT 8
65409: PUSH
65410: EMPTY
65411: LIST
65412: LIST
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: PPUSH
65420: CALL_OW 72
65424: PUSH
65425: EMPTY
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: ST_TO_ADDR
// for j := 1 to 4 do
65431: LD_ADDR_VAR 0 3
65435: PUSH
65436: DOUBLE
65437: LD_INT 1
65439: DEC
65440: ST_TO_ADDR
65441: LD_INT 4
65443: PUSH
65444: FOR_TO
65445: IFFALSE 65638
// begin if not tmp [ j ] then
65447: LD_VAR 0 4
65451: PUSH
65452: LD_VAR 0 3
65456: ARRAY
65457: NOT
65458: IFFALSE 65462
// continue ;
65460: GO 65444
// for p in tmp [ j ] do
65462: LD_ADDR_VAR 0 5
65466: PUSH
65467: LD_VAR 0 4
65471: PUSH
65472: LD_VAR 0 3
65476: ARRAY
65477: PUSH
65478: FOR_IN
65479: IFFALSE 65634
// begin if not b [ j ] then
65481: LD_VAR 0 6
65485: PUSH
65486: LD_VAR 0 3
65490: ARRAY
65491: NOT
65492: IFFALSE 65496
// break ;
65494: GO 65634
// e := 0 ;
65496: LD_ADDR_VAR 0 7
65500: PUSH
65501: LD_INT 0
65503: ST_TO_ADDR
// for k in b [ j ] do
65504: LD_ADDR_VAR 0 8
65508: PUSH
65509: LD_VAR 0 6
65513: PUSH
65514: LD_VAR 0 3
65518: ARRAY
65519: PUSH
65520: FOR_IN
65521: IFFALSE 65548
// if IsNotFull ( k ) then
65523: LD_VAR 0 8
65527: PPUSH
65528: CALL 19704 0 1
65532: IFFALSE 65546
// begin e := k ;
65534: LD_ADDR_VAR 0 7
65538: PUSH
65539: LD_VAR 0 8
65543: ST_TO_ADDR
// break ;
65544: GO 65548
// end ;
65546: GO 65520
65548: POP
65549: POP
// if e and not UnitGoingToBuilding ( p , e ) then
65550: LD_VAR 0 7
65554: IFFALSE 65573
65556: PUSH
65557: LD_VAR 0 5
65561: PPUSH
65562: LD_VAR 0 7
65566: PPUSH
65567: CALL 54164 0 2
65571: NOT
65572: AND
65573: IFFALSE 65632
// begin if IsInUnit ( p ) then
65575: LD_VAR 0 5
65579: PPUSH
65580: CALL_OW 310
65584: IFFALSE 65595
// ComExitBuilding ( p ) ;
65586: LD_VAR 0 5
65590: PPUSH
65591: CALL_OW 122
// ComEnterUnit ( p , e ) ;
65595: LD_VAR 0 5
65599: PPUSH
65600: LD_VAR 0 7
65604: PPUSH
65605: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
65609: LD_VAR 0 5
65613: PPUSH
65614: LD_VAR 0 3
65618: PPUSH
65619: CALL_OW 183
// AddComExitBuilding ( p ) ;
65623: LD_VAR 0 5
65627: PPUSH
65628: CALL_OW 182
// end ; end ;
65632: GO 65478
65634: POP
65635: POP
// end ;
65636: GO 65444
65638: POP
65639: POP
// end ;
65640: GO 65208
65642: POP
65643: POP
// end ;
65644: LD_VAR 0 1
65648: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
65649: LD_INT 0
65651: PPUSH
65652: PPUSH
65653: PPUSH
65654: PPUSH
65655: PPUSH
65656: PPUSH
65657: PPUSH
65658: PPUSH
65659: PPUSH
65660: PPUSH
65661: PPUSH
65662: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
65663: LD_ADDR_VAR 0 2
65667: PUSH
65668: LD_INT 0
65670: PUSH
65671: LD_INT 0
65673: PUSH
65674: LD_INT 0
65676: PUSH
65677: LD_INT 0
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
65686: LD_VAR 0 1
65690: NOT
65691: IFTRUE 65706
65693: PUSH
65694: LD_EXP 63
65698: PUSH
65699: LD_VAR 0 1
65703: ARRAY
65704: NOT
65705: OR
65706: IFTRUE 65754
65708: PUSH
65709: LD_EXP 63
65713: PUSH
65714: LD_VAR 0 1
65718: ARRAY
65719: PPUSH
65720: LD_INT 2
65722: PUSH
65723: LD_INT 30
65725: PUSH
65726: LD_INT 0
65728: PUSH
65729: EMPTY
65730: LIST
65731: LIST
65732: PUSH
65733: LD_INT 30
65735: PUSH
65736: LD_INT 1
65738: PUSH
65739: EMPTY
65740: LIST
65741: LIST
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: LIST
65747: PPUSH
65748: CALL_OW 72
65752: NOT
65753: OR
65754: IFFALSE 65758
// exit ;
65756: GO 69299
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65758: LD_ADDR_VAR 0 4
65762: PUSH
65763: LD_EXP 63
65767: PUSH
65768: LD_VAR 0 1
65772: ARRAY
65773: PPUSH
65774: LD_INT 2
65776: PUSH
65777: LD_INT 25
65779: PUSH
65780: LD_INT 1
65782: PUSH
65783: EMPTY
65784: LIST
65785: LIST
65786: PUSH
65787: LD_INT 25
65789: PUSH
65790: LD_INT 2
65792: PUSH
65793: EMPTY
65794: LIST
65795: LIST
65796: PUSH
65797: LD_INT 25
65799: PUSH
65800: LD_INT 3
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: LD_INT 25
65809: PUSH
65810: LD_INT 4
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 25
65819: PUSH
65820: LD_INT 5
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 25
65829: PUSH
65830: LD_INT 8
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 25
65839: PUSH
65840: LD_INT 9
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: LIST
65851: LIST
65852: LIST
65853: LIST
65854: LIST
65855: LIST
65856: PPUSH
65857: CALL_OW 72
65861: ST_TO_ADDR
// if not tmp then
65862: LD_VAR 0 4
65866: NOT
65867: IFFALSE 65871
// exit ;
65869: GO 69299
// for i in tmp do
65871: LD_ADDR_VAR 0 3
65875: PUSH
65876: LD_VAR 0 4
65880: PUSH
65881: FOR_IN
65882: IFFALSE 65913
// if GetTag ( i ) then
65884: LD_VAR 0 3
65888: PPUSH
65889: CALL_OW 110
65893: IFFALSE 65911
// tmp := tmp diff i ;
65895: LD_ADDR_VAR 0 4
65899: PUSH
65900: LD_VAR 0 4
65904: PUSH
65905: LD_VAR 0 3
65909: DIFF
65910: ST_TO_ADDR
65911: GO 65881
65913: POP
65914: POP
// if not tmp then
65915: LD_VAR 0 4
65919: NOT
65920: IFFALSE 65924
// exit ;
65922: GO 69299
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65924: LD_ADDR_VAR 0 5
65928: PUSH
65929: LD_EXP 63
65933: PUSH
65934: LD_VAR 0 1
65938: ARRAY
65939: PPUSH
65940: LD_INT 2
65942: PUSH
65943: LD_INT 25
65945: PUSH
65946: LD_INT 1
65948: PUSH
65949: EMPTY
65950: LIST
65951: LIST
65952: PUSH
65953: LD_INT 25
65955: PUSH
65956: LD_INT 5
65958: PUSH
65959: EMPTY
65960: LIST
65961: LIST
65962: PUSH
65963: LD_INT 25
65965: PUSH
65966: LD_INT 8
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 25
65975: PUSH
65976: LD_INT 9
65978: PUSH
65979: EMPTY
65980: LIST
65981: LIST
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: LIST
65987: LIST
65988: LIST
65989: PPUSH
65990: CALL_OW 72
65994: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65995: LD_ADDR_VAR 0 6
65999: PUSH
66000: LD_EXP 63
66004: PUSH
66005: LD_VAR 0 1
66009: ARRAY
66010: PPUSH
66011: LD_INT 25
66013: PUSH
66014: LD_INT 2
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PPUSH
66021: CALL_OW 72
66025: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66026: LD_ADDR_VAR 0 7
66030: PUSH
66031: LD_EXP 63
66035: PUSH
66036: LD_VAR 0 1
66040: ARRAY
66041: PPUSH
66042: LD_INT 25
66044: PUSH
66045: LD_INT 3
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: PPUSH
66052: CALL_OW 72
66056: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
66057: LD_ADDR_VAR 0 8
66061: PUSH
66062: LD_EXP 63
66066: PUSH
66067: LD_VAR 0 1
66071: ARRAY
66072: PPUSH
66073: LD_INT 25
66075: PUSH
66076: LD_INT 4
66078: PUSH
66079: EMPTY
66080: LIST
66081: LIST
66082: PUSH
66083: LD_INT 24
66085: PUSH
66086: LD_INT 251
66088: PUSH
66089: EMPTY
66090: LIST
66091: LIST
66092: PUSH
66093: EMPTY
66094: LIST
66095: LIST
66096: PPUSH
66097: CALL_OW 72
66101: ST_TO_ADDR
// if mc_is_defending [ base ] then
66102: LD_EXP 106
66106: PUSH
66107: LD_VAR 0 1
66111: ARRAY
66112: IFFALSE 66573
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
66114: LD_ADDR_EXP 105
66118: PUSH
66119: LD_EXP 105
66123: PPUSH
66124: LD_VAR 0 1
66128: PPUSH
66129: LD_INT 4
66131: PPUSH
66132: CALL_OW 1
66136: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
66137: LD_ADDR_VAR 0 12
66141: PUSH
66142: LD_EXP 63
66146: PUSH
66147: LD_VAR 0 1
66151: ARRAY
66152: PPUSH
66153: LD_INT 2
66155: PUSH
66156: LD_INT 30
66158: PUSH
66159: LD_INT 4
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 30
66168: PUSH
66169: LD_INT 5
66171: PUSH
66172: EMPTY
66173: LIST
66174: LIST
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: LIST
66180: PPUSH
66181: CALL_OW 72
66185: ST_TO_ADDR
// if not b then
66186: LD_VAR 0 12
66190: NOT
66191: IFFALSE 66195
// exit ;
66193: GO 69299
// p := [ ] ;
66195: LD_ADDR_VAR 0 11
66199: PUSH
66200: EMPTY
66201: ST_TO_ADDR
// if sci >= 2 then
66202: LD_VAR 0 8
66206: PUSH
66207: LD_INT 2
66209: GREATEREQUAL
66210: IFFALSE 66241
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
66212: LD_ADDR_VAR 0 8
66216: PUSH
66217: LD_VAR 0 8
66221: PUSH
66222: LD_INT 1
66224: ARRAY
66225: PUSH
66226: LD_VAR 0 8
66230: PUSH
66231: LD_INT 2
66233: ARRAY
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: ST_TO_ADDR
66239: GO 66302
// if sci = 1 then
66241: LD_VAR 0 8
66245: PUSH
66246: LD_INT 1
66248: EQUAL
66249: IFFALSE 66270
// sci := [ sci [ 1 ] ] else
66251: LD_ADDR_VAR 0 8
66255: PUSH
66256: LD_VAR 0 8
66260: PUSH
66261: LD_INT 1
66263: ARRAY
66264: PUSH
66265: EMPTY
66266: LIST
66267: ST_TO_ADDR
66268: GO 66302
// if sci = 0 then
66270: LD_VAR 0 8
66274: PUSH
66275: LD_INT 0
66277: EQUAL
66278: IFFALSE 66302
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
66280: LD_ADDR_VAR 0 11
66284: PUSH
66285: LD_VAR 0 4
66289: PPUSH
66290: LD_INT 4
66292: PPUSH
66293: CALL 54034 0 2
66297: PUSH
66298: LD_INT 1
66300: ARRAY
66301: ST_TO_ADDR
// if eng > 4 then
66302: LD_VAR 0 6
66306: PUSH
66307: LD_INT 4
66309: GREATER
66310: IFFALSE 66356
// for i = eng downto 4 do
66312: LD_ADDR_VAR 0 3
66316: PUSH
66317: DOUBLE
66318: LD_VAR 0 6
66322: INC
66323: ST_TO_ADDR
66324: LD_INT 4
66326: PUSH
66327: FOR_DOWNTO
66328: IFFALSE 66354
// eng := eng diff eng [ i ] ;
66330: LD_ADDR_VAR 0 6
66334: PUSH
66335: LD_VAR 0 6
66339: PUSH
66340: LD_VAR 0 6
66344: PUSH
66345: LD_VAR 0 3
66349: ARRAY
66350: DIFF
66351: ST_TO_ADDR
66352: GO 66327
66354: POP
66355: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
66356: LD_ADDR_VAR 0 4
66360: PUSH
66361: LD_VAR 0 4
66365: PUSH
66366: LD_VAR 0 5
66370: PUSH
66371: LD_VAR 0 6
66375: UNION
66376: PUSH
66377: LD_VAR 0 7
66381: UNION
66382: PUSH
66383: LD_VAR 0 8
66387: UNION
66388: DIFF
66389: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
66390: LD_ADDR_VAR 0 13
66394: PUSH
66395: LD_EXP 63
66399: PUSH
66400: LD_VAR 0 1
66404: ARRAY
66405: PPUSH
66406: LD_INT 2
66408: PUSH
66409: LD_INT 30
66411: PUSH
66412: LD_INT 32
66414: PUSH
66415: EMPTY
66416: LIST
66417: LIST
66418: PUSH
66419: LD_INT 30
66421: PUSH
66422: LD_INT 31
66424: PUSH
66425: EMPTY
66426: LIST
66427: LIST
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: LIST
66433: PPUSH
66434: CALL_OW 72
66438: PUSH
66439: LD_EXP 63
66443: PUSH
66444: LD_VAR 0 1
66448: ARRAY
66449: PPUSH
66450: LD_INT 2
66452: PUSH
66453: LD_INT 30
66455: PUSH
66456: LD_INT 4
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 30
66465: PUSH
66466: LD_INT 5
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: LIST
66477: PPUSH
66478: CALL_OW 72
66482: PUSH
66483: LD_INT 6
66485: MUL
66486: PLUS
66487: ST_TO_ADDR
// if bcount < tmp then
66488: LD_VAR 0 13
66492: PUSH
66493: LD_VAR 0 4
66497: LESS
66498: IFFALSE 66544
// for i = tmp downto bcount do
66500: LD_ADDR_VAR 0 3
66504: PUSH
66505: DOUBLE
66506: LD_VAR 0 4
66510: INC
66511: ST_TO_ADDR
66512: LD_VAR 0 13
66516: PUSH
66517: FOR_DOWNTO
66518: IFFALSE 66542
// tmp := Delete ( tmp , tmp ) ;
66520: LD_ADDR_VAR 0 4
66524: PUSH
66525: LD_VAR 0 4
66529: PPUSH
66530: LD_VAR 0 4
66534: PPUSH
66535: CALL_OW 3
66539: ST_TO_ADDR
66540: GO 66517
66542: POP
66543: POP
// result := [ tmp , 0 , 0 , p ] ;
66544: LD_ADDR_VAR 0 2
66548: PUSH
66549: LD_VAR 0 4
66553: PUSH
66554: LD_INT 0
66556: PUSH
66557: LD_INT 0
66559: PUSH
66560: LD_VAR 0 11
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: LIST
66569: LIST
66570: ST_TO_ADDR
// exit ;
66571: GO 69299
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66573: LD_EXP 63
66577: PUSH
66578: LD_VAR 0 1
66582: ARRAY
66583: PPUSH
66584: LD_INT 2
66586: PUSH
66587: LD_INT 30
66589: PUSH
66590: LD_INT 6
66592: PUSH
66593: EMPTY
66594: LIST
66595: LIST
66596: PUSH
66597: LD_INT 30
66599: PUSH
66600: LD_INT 7
66602: PUSH
66603: EMPTY
66604: LIST
66605: LIST
66606: PUSH
66607: LD_INT 30
66609: PUSH
66610: LD_INT 8
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PUSH
66617: EMPTY
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: PPUSH
66623: CALL_OW 72
66627: NOT
66628: IFFALSE 66658
66630: PUSH
66631: LD_EXP 63
66635: PUSH
66636: LD_VAR 0 1
66640: ARRAY
66641: PPUSH
66642: LD_INT 30
66644: PUSH
66645: LD_INT 3
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PPUSH
66652: CALL_OW 72
66656: NOT
66657: AND
66658: IFFALSE 66730
// begin if eng = tmp then
66660: LD_VAR 0 6
66664: PUSH
66665: LD_VAR 0 4
66669: EQUAL
66670: IFFALSE 66674
// exit ;
66672: GO 69299
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
66674: LD_ADDR_EXP 105
66678: PUSH
66679: LD_EXP 105
66683: PPUSH
66684: LD_VAR 0 1
66688: PPUSH
66689: LD_INT 1
66691: PPUSH
66692: CALL_OW 1
66696: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
66697: LD_ADDR_VAR 0 2
66701: PUSH
66702: LD_INT 0
66704: PUSH
66705: LD_VAR 0 4
66709: PUSH
66710: LD_VAR 0 6
66714: DIFF
66715: PUSH
66716: LD_INT 0
66718: PUSH
66719: LD_INT 0
66721: PUSH
66722: EMPTY
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: ST_TO_ADDR
// exit ;
66728: GO 69299
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66730: LD_EXP 90
66734: PUSH
66735: LD_EXP 89
66739: PUSH
66740: LD_VAR 0 1
66744: ARRAY
66745: ARRAY
66746: IFFALSE 66804
66748: PUSH
66749: LD_EXP 63
66753: PUSH
66754: LD_VAR 0 1
66758: ARRAY
66759: PPUSH
66760: LD_INT 2
66762: PUSH
66763: LD_INT 30
66765: PUSH
66766: LD_INT 6
66768: PUSH
66769: EMPTY
66770: LIST
66771: LIST
66772: PUSH
66773: LD_INT 30
66775: PUSH
66776: LD_INT 7
66778: PUSH
66779: EMPTY
66780: LIST
66781: LIST
66782: PUSH
66783: LD_INT 30
66785: PUSH
66786: LD_INT 8
66788: PUSH
66789: EMPTY
66790: LIST
66791: LIST
66792: PUSH
66793: EMPTY
66794: LIST
66795: LIST
66796: LIST
66797: LIST
66798: PPUSH
66799: CALL_OW 72
66803: AND
66804: IFFALSE 66834
66806: PUSH
66807: LD_EXP 63
66811: PUSH
66812: LD_VAR 0 1
66816: ARRAY
66817: PPUSH
66818: LD_INT 30
66820: PUSH
66821: LD_INT 3
66823: PUSH
66824: EMPTY
66825: LIST
66826: LIST
66827: PPUSH
66828: CALL_OW 72
66832: NOT
66833: AND
66834: IFFALSE 67050
// begin if sci >= 6 then
66836: LD_VAR 0 8
66840: PUSH
66841: LD_INT 6
66843: GREATEREQUAL
66844: IFFALSE 66848
// exit ;
66846: GO 69299
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66848: LD_ADDR_EXP 105
66852: PUSH
66853: LD_EXP 105
66857: PPUSH
66858: LD_VAR 0 1
66862: PPUSH
66863: LD_INT 2
66865: PPUSH
66866: CALL_OW 1
66870: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66871: LD_ADDR_VAR 0 9
66875: PUSH
66876: LD_VAR 0 4
66880: PUSH
66881: LD_VAR 0 8
66885: DIFF
66886: PPUSH
66887: LD_INT 4
66889: PPUSH
66890: CALL 54034 0 2
66894: ST_TO_ADDR
// p := [ ] ;
66895: LD_ADDR_VAR 0 11
66899: PUSH
66900: EMPTY
66901: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66902: LD_VAR 0 8
66906: PUSH
66907: LD_INT 6
66909: LESS
66910: IFFALSE 66922
66912: PUSH
66913: LD_VAR 0 9
66917: PUSH
66918: LD_INT 6
66920: GREATER
66921: AND
66922: IFFALSE 67003
// begin for i = 1 to 6 - sci do
66924: LD_ADDR_VAR 0 3
66928: PUSH
66929: DOUBLE
66930: LD_INT 1
66932: DEC
66933: ST_TO_ADDR
66934: LD_INT 6
66936: PUSH
66937: LD_VAR 0 8
66941: MINUS
66942: PUSH
66943: FOR_TO
66944: IFFALSE 66999
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66946: LD_ADDR_VAR 0 11
66950: PUSH
66951: LD_VAR 0 11
66955: PPUSH
66956: LD_VAR 0 11
66960: PUSH
66961: LD_INT 1
66963: PLUS
66964: PPUSH
66965: LD_VAR 0 9
66969: PUSH
66970: LD_INT 1
66972: ARRAY
66973: PPUSH
66974: CALL_OW 2
66978: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66979: LD_ADDR_VAR 0 9
66983: PUSH
66984: LD_VAR 0 9
66988: PPUSH
66989: LD_INT 1
66991: PPUSH
66992: CALL_OW 3
66996: ST_TO_ADDR
// end ;
66997: GO 66943
66999: POP
67000: POP
// end else
67001: GO 67023
// if sort then
67003: LD_VAR 0 9
67007: IFFALSE 67023
// p := sort [ 1 ] ;
67009: LD_ADDR_VAR 0 11
67013: PUSH
67014: LD_VAR 0 9
67018: PUSH
67019: LD_INT 1
67021: ARRAY
67022: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
67023: LD_ADDR_VAR 0 2
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 0
67033: PUSH
67034: LD_INT 0
67036: PUSH
67037: LD_VAR 0 11
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: LIST
67046: LIST
67047: ST_TO_ADDR
// exit ;
67048: GO 69299
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
67050: LD_EXP 90
67054: PUSH
67055: LD_EXP 89
67059: PUSH
67060: LD_VAR 0 1
67064: ARRAY
67065: ARRAY
67066: IFFALSE 67124
67068: PUSH
67069: LD_EXP 63
67073: PUSH
67074: LD_VAR 0 1
67078: ARRAY
67079: PPUSH
67080: LD_INT 2
67082: PUSH
67083: LD_INT 30
67085: PUSH
67086: LD_INT 6
67088: PUSH
67089: EMPTY
67090: LIST
67091: LIST
67092: PUSH
67093: LD_INT 30
67095: PUSH
67096: LD_INT 7
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 30
67105: PUSH
67106: LD_INT 8
67108: PUSH
67109: EMPTY
67110: LIST
67111: LIST
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: LIST
67117: LIST
67118: PPUSH
67119: CALL_OW 72
67123: AND
67124: IFFALSE 67153
67126: PUSH
67127: LD_EXP 63
67131: PUSH
67132: LD_VAR 0 1
67136: ARRAY
67137: PPUSH
67138: LD_INT 30
67140: PUSH
67141: LD_INT 3
67143: PUSH
67144: EMPTY
67145: LIST
67146: LIST
67147: PPUSH
67148: CALL_OW 72
67152: AND
67153: IFFALSE 67893
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
67155: LD_ADDR_EXP 105
67159: PUSH
67160: LD_EXP 105
67164: PPUSH
67165: LD_VAR 0 1
67169: PPUSH
67170: LD_INT 3
67172: PPUSH
67173: CALL_OW 1
67177: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67178: LD_ADDR_VAR 0 2
67182: PUSH
67183: LD_INT 0
67185: PUSH
67186: LD_INT 0
67188: PUSH
67189: LD_INT 0
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: ST_TO_ADDR
// if not eng then
67201: LD_VAR 0 6
67205: NOT
67206: IFFALSE 67269
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
67208: LD_ADDR_VAR 0 11
67212: PUSH
67213: LD_VAR 0 4
67217: PPUSH
67218: LD_INT 2
67220: PPUSH
67221: CALL 54034 0 2
67225: PUSH
67226: LD_INT 1
67228: ARRAY
67229: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
67230: LD_ADDR_VAR 0 2
67234: PUSH
67235: LD_VAR 0 2
67239: PPUSH
67240: LD_INT 2
67242: PPUSH
67243: LD_VAR 0 11
67247: PPUSH
67248: CALL_OW 1
67252: ST_TO_ADDR
// tmp := tmp diff p ;
67253: LD_ADDR_VAR 0 4
67257: PUSH
67258: LD_VAR 0 4
67262: PUSH
67263: LD_VAR 0 11
67267: DIFF
67268: ST_TO_ADDR
// end ; if tmp and sci < 6 then
67269: LD_VAR 0 4
67273: IFFALSE 67285
67275: PUSH
67276: LD_VAR 0 8
67280: PUSH
67281: LD_INT 6
67283: LESS
67284: AND
67285: IFFALSE 67473
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
67287: LD_ADDR_VAR 0 9
67291: PUSH
67292: LD_VAR 0 4
67296: PUSH
67297: LD_VAR 0 8
67301: PUSH
67302: LD_VAR 0 7
67306: UNION
67307: DIFF
67308: PPUSH
67309: LD_INT 4
67311: PPUSH
67312: CALL 54034 0 2
67316: ST_TO_ADDR
// p := [ ] ;
67317: LD_ADDR_VAR 0 11
67321: PUSH
67322: EMPTY
67323: ST_TO_ADDR
// if sort then
67324: LD_VAR 0 9
67328: IFFALSE 67444
// for i = 1 to 6 - sci do
67330: LD_ADDR_VAR 0 3
67334: PUSH
67335: DOUBLE
67336: LD_INT 1
67338: DEC
67339: ST_TO_ADDR
67340: LD_INT 6
67342: PUSH
67343: LD_VAR 0 8
67347: MINUS
67348: PUSH
67349: FOR_TO
67350: IFFALSE 67442
// begin if i = sort then
67352: LD_VAR 0 3
67356: PUSH
67357: LD_VAR 0 9
67361: EQUAL
67362: IFFALSE 67366
// break ;
67364: GO 67442
// if GetClass ( i ) = 4 then
67366: LD_VAR 0 3
67370: PPUSH
67371: CALL_OW 257
67375: PUSH
67376: LD_INT 4
67378: EQUAL
67379: IFFALSE 67383
// continue ;
67381: GO 67349
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67383: LD_ADDR_VAR 0 11
67387: PUSH
67388: LD_VAR 0 11
67392: PPUSH
67393: LD_VAR 0 11
67397: PUSH
67398: LD_INT 1
67400: PLUS
67401: PPUSH
67402: LD_VAR 0 9
67406: PUSH
67407: LD_VAR 0 3
67411: ARRAY
67412: PPUSH
67413: CALL_OW 2
67417: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67418: LD_ADDR_VAR 0 4
67422: PUSH
67423: LD_VAR 0 4
67427: PUSH
67428: LD_VAR 0 9
67432: PUSH
67433: LD_VAR 0 3
67437: ARRAY
67438: DIFF
67439: ST_TO_ADDR
// end ;
67440: GO 67349
67442: POP
67443: POP
// if p then
67444: LD_VAR 0 11
67448: IFFALSE 67473
// result := Replace ( result , 4 , p ) ;
67450: LD_ADDR_VAR 0 2
67454: PUSH
67455: LD_VAR 0 2
67459: PPUSH
67460: LD_INT 4
67462: PPUSH
67463: LD_VAR 0 11
67467: PPUSH
67468: CALL_OW 1
67472: ST_TO_ADDR
// end ; if tmp and mech < 6 then
67473: LD_VAR 0 4
67477: IFFALSE 67489
67479: PUSH
67480: LD_VAR 0 7
67484: PUSH
67485: LD_INT 6
67487: LESS
67488: AND
67489: IFFALSE 67677
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67491: LD_ADDR_VAR 0 9
67495: PUSH
67496: LD_VAR 0 4
67500: PUSH
67501: LD_VAR 0 8
67505: PUSH
67506: LD_VAR 0 7
67510: UNION
67511: DIFF
67512: PPUSH
67513: LD_INT 3
67515: PPUSH
67516: CALL 54034 0 2
67520: ST_TO_ADDR
// p := [ ] ;
67521: LD_ADDR_VAR 0 11
67525: PUSH
67526: EMPTY
67527: ST_TO_ADDR
// if sort then
67528: LD_VAR 0 9
67532: IFFALSE 67648
// for i = 1 to 6 - mech do
67534: LD_ADDR_VAR 0 3
67538: PUSH
67539: DOUBLE
67540: LD_INT 1
67542: DEC
67543: ST_TO_ADDR
67544: LD_INT 6
67546: PUSH
67547: LD_VAR 0 7
67551: MINUS
67552: PUSH
67553: FOR_TO
67554: IFFALSE 67646
// begin if i = sort then
67556: LD_VAR 0 3
67560: PUSH
67561: LD_VAR 0 9
67565: EQUAL
67566: IFFALSE 67570
// break ;
67568: GO 67646
// if GetClass ( i ) = 3 then
67570: LD_VAR 0 3
67574: PPUSH
67575: CALL_OW 257
67579: PUSH
67580: LD_INT 3
67582: EQUAL
67583: IFFALSE 67587
// continue ;
67585: GO 67553
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67587: LD_ADDR_VAR 0 11
67591: PUSH
67592: LD_VAR 0 11
67596: PPUSH
67597: LD_VAR 0 11
67601: PUSH
67602: LD_INT 1
67604: PLUS
67605: PPUSH
67606: LD_VAR 0 9
67610: PUSH
67611: LD_VAR 0 3
67615: ARRAY
67616: PPUSH
67617: CALL_OW 2
67621: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67622: LD_ADDR_VAR 0 4
67626: PUSH
67627: LD_VAR 0 4
67631: PUSH
67632: LD_VAR 0 9
67636: PUSH
67637: LD_VAR 0 3
67641: ARRAY
67642: DIFF
67643: ST_TO_ADDR
// end ;
67644: GO 67553
67646: POP
67647: POP
// if p then
67648: LD_VAR 0 11
67652: IFFALSE 67677
// result := Replace ( result , 3 , p ) ;
67654: LD_ADDR_VAR 0 2
67658: PUSH
67659: LD_VAR 0 2
67663: PPUSH
67664: LD_INT 3
67666: PPUSH
67667: LD_VAR 0 11
67671: PPUSH
67672: CALL_OW 1
67676: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
67677: LD_VAR 0 4
67681: PUSH
67682: LD_INT 6
67684: GREATER
67685: IFFALSE 67697
67687: PUSH
67688: LD_VAR 0 6
67692: PUSH
67693: LD_INT 6
67695: LESS
67696: AND
67697: IFFALSE 67891
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67699: LD_ADDR_VAR 0 9
67703: PUSH
67704: LD_VAR 0 4
67708: PUSH
67709: LD_VAR 0 8
67713: PUSH
67714: LD_VAR 0 7
67718: UNION
67719: PUSH
67720: LD_VAR 0 6
67724: UNION
67725: DIFF
67726: PPUSH
67727: LD_INT 2
67729: PPUSH
67730: CALL 54034 0 2
67734: ST_TO_ADDR
// p := [ ] ;
67735: LD_ADDR_VAR 0 11
67739: PUSH
67740: EMPTY
67741: ST_TO_ADDR
// if sort then
67742: LD_VAR 0 9
67746: IFFALSE 67862
// for i = 1 to 6 - eng do
67748: LD_ADDR_VAR 0 3
67752: PUSH
67753: DOUBLE
67754: LD_INT 1
67756: DEC
67757: ST_TO_ADDR
67758: LD_INT 6
67760: PUSH
67761: LD_VAR 0 6
67765: MINUS
67766: PUSH
67767: FOR_TO
67768: IFFALSE 67860
// begin if i = sort then
67770: LD_VAR 0 3
67774: PUSH
67775: LD_VAR 0 9
67779: EQUAL
67780: IFFALSE 67784
// break ;
67782: GO 67860
// if GetClass ( i ) = 2 then
67784: LD_VAR 0 3
67788: PPUSH
67789: CALL_OW 257
67793: PUSH
67794: LD_INT 2
67796: EQUAL
67797: IFFALSE 67801
// continue ;
67799: GO 67767
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67801: LD_ADDR_VAR 0 11
67805: PUSH
67806: LD_VAR 0 11
67810: PPUSH
67811: LD_VAR 0 11
67815: PUSH
67816: LD_INT 1
67818: PLUS
67819: PPUSH
67820: LD_VAR 0 9
67824: PUSH
67825: LD_VAR 0 3
67829: ARRAY
67830: PPUSH
67831: CALL_OW 2
67835: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67836: LD_ADDR_VAR 0 4
67840: PUSH
67841: LD_VAR 0 4
67845: PUSH
67846: LD_VAR 0 9
67850: PUSH
67851: LD_VAR 0 3
67855: ARRAY
67856: DIFF
67857: ST_TO_ADDR
// end ;
67858: GO 67767
67860: POP
67861: POP
// if p then
67862: LD_VAR 0 11
67866: IFFALSE 67891
// result := Replace ( result , 2 , p ) ;
67868: LD_ADDR_VAR 0 2
67872: PUSH
67873: LD_VAR 0 2
67877: PPUSH
67878: LD_INT 2
67880: PPUSH
67881: LD_VAR 0 11
67885: PPUSH
67886: CALL_OW 1
67890: ST_TO_ADDR
// end ; exit ;
67891: GO 69299
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67893: LD_EXP 90
67897: PUSH
67898: LD_EXP 89
67902: PUSH
67903: LD_VAR 0 1
67907: ARRAY
67908: ARRAY
67909: NOT
67910: IFFALSE 67939
67912: PUSH
67913: LD_EXP 63
67917: PUSH
67918: LD_VAR 0 1
67922: ARRAY
67923: PPUSH
67924: LD_INT 30
67926: PUSH
67927: LD_INT 3
67929: PUSH
67930: EMPTY
67931: LIST
67932: LIST
67933: PPUSH
67934: CALL_OW 72
67938: AND
67939: IFFALSE 67953
67941: PUSH
67942: LD_EXP 68
67946: PUSH
67947: LD_VAR 0 1
67951: ARRAY
67952: AND
67953: IFFALSE 68567
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67955: LD_ADDR_EXP 105
67959: PUSH
67960: LD_EXP 105
67964: PPUSH
67965: LD_VAR 0 1
67969: PPUSH
67970: LD_INT 5
67972: PPUSH
67973: CALL_OW 1
67977: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67978: LD_ADDR_VAR 0 2
67982: PUSH
67983: LD_INT 0
67985: PUSH
67986: LD_INT 0
67988: PUSH
67989: LD_INT 0
67991: PUSH
67992: LD_INT 0
67994: PUSH
67995: EMPTY
67996: LIST
67997: LIST
67998: LIST
67999: LIST
68000: ST_TO_ADDR
// if sci > 1 then
68001: LD_VAR 0 8
68005: PUSH
68006: LD_INT 1
68008: GREATER
68009: IFFALSE 68037
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
68011: LD_ADDR_VAR 0 4
68015: PUSH
68016: LD_VAR 0 4
68020: PUSH
68021: LD_VAR 0 8
68025: PUSH
68026: LD_VAR 0 8
68030: PUSH
68031: LD_INT 1
68033: ARRAY
68034: DIFF
68035: DIFF
68036: ST_TO_ADDR
// if tmp and not sci then
68037: LD_VAR 0 4
68041: IFFALSE 68050
68043: PUSH
68044: LD_VAR 0 8
68048: NOT
68049: AND
68050: IFFALSE 68119
// begin sort := SortBySkill ( tmp , 4 ) ;
68052: LD_ADDR_VAR 0 9
68056: PUSH
68057: LD_VAR 0 4
68061: PPUSH
68062: LD_INT 4
68064: PPUSH
68065: CALL 54034 0 2
68069: ST_TO_ADDR
// if sort then
68070: LD_VAR 0 9
68074: IFFALSE 68090
// p := sort [ 1 ] ;
68076: LD_ADDR_VAR 0 11
68080: PUSH
68081: LD_VAR 0 9
68085: PUSH
68086: LD_INT 1
68088: ARRAY
68089: ST_TO_ADDR
// if p then
68090: LD_VAR 0 11
68094: IFFALSE 68119
// result := Replace ( result , 4 , p ) ;
68096: LD_ADDR_VAR 0 2
68100: PUSH
68101: LD_VAR 0 2
68105: PPUSH
68106: LD_INT 4
68108: PPUSH
68109: LD_VAR 0 11
68113: PPUSH
68114: CALL_OW 1
68118: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68119: LD_ADDR_VAR 0 4
68123: PUSH
68124: LD_VAR 0 4
68128: PUSH
68129: LD_VAR 0 7
68133: DIFF
68134: ST_TO_ADDR
// if tmp and mech < 6 then
68135: LD_VAR 0 4
68139: IFFALSE 68151
68141: PUSH
68142: LD_VAR 0 7
68146: PUSH
68147: LD_INT 6
68149: LESS
68150: AND
68151: IFFALSE 68339
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
68153: LD_ADDR_VAR 0 9
68157: PUSH
68158: LD_VAR 0 4
68162: PUSH
68163: LD_VAR 0 8
68167: PUSH
68168: LD_VAR 0 7
68172: UNION
68173: DIFF
68174: PPUSH
68175: LD_INT 3
68177: PPUSH
68178: CALL 54034 0 2
68182: ST_TO_ADDR
// p := [ ] ;
68183: LD_ADDR_VAR 0 11
68187: PUSH
68188: EMPTY
68189: ST_TO_ADDR
// if sort then
68190: LD_VAR 0 9
68194: IFFALSE 68310
// for i = 1 to 6 - mech do
68196: LD_ADDR_VAR 0 3
68200: PUSH
68201: DOUBLE
68202: LD_INT 1
68204: DEC
68205: ST_TO_ADDR
68206: LD_INT 6
68208: PUSH
68209: LD_VAR 0 7
68213: MINUS
68214: PUSH
68215: FOR_TO
68216: IFFALSE 68308
// begin if i = sort then
68218: LD_VAR 0 3
68222: PUSH
68223: LD_VAR 0 9
68227: EQUAL
68228: IFFALSE 68232
// break ;
68230: GO 68308
// if GetClass ( i ) = 3 then
68232: LD_VAR 0 3
68236: PPUSH
68237: CALL_OW 257
68241: PUSH
68242: LD_INT 3
68244: EQUAL
68245: IFFALSE 68249
// continue ;
68247: GO 68215
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68249: LD_ADDR_VAR 0 11
68253: PUSH
68254: LD_VAR 0 11
68258: PPUSH
68259: LD_VAR 0 11
68263: PUSH
68264: LD_INT 1
68266: PLUS
68267: PPUSH
68268: LD_VAR 0 9
68272: PUSH
68273: LD_VAR 0 3
68277: ARRAY
68278: PPUSH
68279: CALL_OW 2
68283: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68284: LD_ADDR_VAR 0 4
68288: PUSH
68289: LD_VAR 0 4
68293: PUSH
68294: LD_VAR 0 9
68298: PUSH
68299: LD_VAR 0 3
68303: ARRAY
68304: DIFF
68305: ST_TO_ADDR
// end ;
68306: GO 68215
68308: POP
68309: POP
// if p then
68310: LD_VAR 0 11
68314: IFFALSE 68339
// result := Replace ( result , 3 , p ) ;
68316: LD_ADDR_VAR 0 2
68320: PUSH
68321: LD_VAR 0 2
68325: PPUSH
68326: LD_INT 3
68328: PPUSH
68329: LD_VAR 0 11
68333: PPUSH
68334: CALL_OW 1
68338: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68339: LD_ADDR_VAR 0 4
68343: PUSH
68344: LD_VAR 0 4
68348: PUSH
68349: LD_VAR 0 6
68353: DIFF
68354: ST_TO_ADDR
// if tmp and eng < 6 then
68355: LD_VAR 0 4
68359: IFFALSE 68371
68361: PUSH
68362: LD_VAR 0 6
68366: PUSH
68367: LD_INT 6
68369: LESS
68370: AND
68371: IFFALSE 68565
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
68373: LD_ADDR_VAR 0 9
68377: PUSH
68378: LD_VAR 0 4
68382: PUSH
68383: LD_VAR 0 8
68387: PUSH
68388: LD_VAR 0 7
68392: UNION
68393: PUSH
68394: LD_VAR 0 6
68398: UNION
68399: DIFF
68400: PPUSH
68401: LD_INT 2
68403: PPUSH
68404: CALL 54034 0 2
68408: ST_TO_ADDR
// p := [ ] ;
68409: LD_ADDR_VAR 0 11
68413: PUSH
68414: EMPTY
68415: ST_TO_ADDR
// if sort then
68416: LD_VAR 0 9
68420: IFFALSE 68536
// for i = 1 to 6 - eng do
68422: LD_ADDR_VAR 0 3
68426: PUSH
68427: DOUBLE
68428: LD_INT 1
68430: DEC
68431: ST_TO_ADDR
68432: LD_INT 6
68434: PUSH
68435: LD_VAR 0 6
68439: MINUS
68440: PUSH
68441: FOR_TO
68442: IFFALSE 68534
// begin if i = sort then
68444: LD_VAR 0 3
68448: PUSH
68449: LD_VAR 0 9
68453: EQUAL
68454: IFFALSE 68458
// break ;
68456: GO 68534
// if GetClass ( i ) = 2 then
68458: LD_VAR 0 3
68462: PPUSH
68463: CALL_OW 257
68467: PUSH
68468: LD_INT 2
68470: EQUAL
68471: IFFALSE 68475
// continue ;
68473: GO 68441
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68475: LD_ADDR_VAR 0 11
68479: PUSH
68480: LD_VAR 0 11
68484: PPUSH
68485: LD_VAR 0 11
68489: PUSH
68490: LD_INT 1
68492: PLUS
68493: PPUSH
68494: LD_VAR 0 9
68498: PUSH
68499: LD_VAR 0 3
68503: ARRAY
68504: PPUSH
68505: CALL_OW 2
68509: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68510: LD_ADDR_VAR 0 4
68514: PUSH
68515: LD_VAR 0 4
68519: PUSH
68520: LD_VAR 0 9
68524: PUSH
68525: LD_VAR 0 3
68529: ARRAY
68530: DIFF
68531: ST_TO_ADDR
// end ;
68532: GO 68441
68534: POP
68535: POP
// if p then
68536: LD_VAR 0 11
68540: IFFALSE 68565
// result := Replace ( result , 2 , p ) ;
68542: LD_ADDR_VAR 0 2
68546: PUSH
68547: LD_VAR 0 2
68551: PPUSH
68552: LD_INT 2
68554: PPUSH
68555: LD_VAR 0 11
68559: PPUSH
68560: CALL_OW 1
68564: ST_TO_ADDR
// end ; exit ;
68565: GO 69299
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
68567: LD_EXP 90
68571: PUSH
68572: LD_EXP 89
68576: PUSH
68577: LD_VAR 0 1
68581: ARRAY
68582: ARRAY
68583: NOT
68584: IFFALSE 68613
68586: PUSH
68587: LD_EXP 63
68591: PUSH
68592: LD_VAR 0 1
68596: ARRAY
68597: PPUSH
68598: LD_INT 30
68600: PUSH
68601: LD_INT 3
68603: PUSH
68604: EMPTY
68605: LIST
68606: LIST
68607: PPUSH
68608: CALL_OW 72
68612: AND
68613: IFFALSE 68628
68615: PUSH
68616: LD_EXP 68
68620: PUSH
68621: LD_VAR 0 1
68625: ARRAY
68626: NOT
68627: AND
68628: IFFALSE 69299
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
68630: LD_ADDR_EXP 105
68634: PUSH
68635: LD_EXP 105
68639: PPUSH
68640: LD_VAR 0 1
68644: PPUSH
68645: LD_INT 6
68647: PPUSH
68648: CALL_OW 1
68652: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
68653: LD_ADDR_VAR 0 2
68657: PUSH
68658: LD_INT 0
68660: PUSH
68661: LD_INT 0
68663: PUSH
68664: LD_INT 0
68666: PUSH
68667: LD_INT 0
68669: PUSH
68670: EMPTY
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: ST_TO_ADDR
// if sci >= 1 then
68676: LD_VAR 0 8
68680: PUSH
68681: LD_INT 1
68683: GREATEREQUAL
68684: IFFALSE 68706
// tmp := tmp diff sci [ 1 ] ;
68686: LD_ADDR_VAR 0 4
68690: PUSH
68691: LD_VAR 0 4
68695: PUSH
68696: LD_VAR 0 8
68700: PUSH
68701: LD_INT 1
68703: ARRAY
68704: DIFF
68705: ST_TO_ADDR
// if tmp and not sci then
68706: LD_VAR 0 4
68710: IFFALSE 68719
68712: PUSH
68713: LD_VAR 0 8
68717: NOT
68718: AND
68719: IFFALSE 68788
// begin sort := SortBySkill ( tmp , 4 ) ;
68721: LD_ADDR_VAR 0 9
68725: PUSH
68726: LD_VAR 0 4
68730: PPUSH
68731: LD_INT 4
68733: PPUSH
68734: CALL 54034 0 2
68738: ST_TO_ADDR
// if sort then
68739: LD_VAR 0 9
68743: IFFALSE 68759
// p := sort [ 1 ] ;
68745: LD_ADDR_VAR 0 11
68749: PUSH
68750: LD_VAR 0 9
68754: PUSH
68755: LD_INT 1
68757: ARRAY
68758: ST_TO_ADDR
// if p then
68759: LD_VAR 0 11
68763: IFFALSE 68788
// result := Replace ( result , 4 , p ) ;
68765: LD_ADDR_VAR 0 2
68769: PUSH
68770: LD_VAR 0 2
68774: PPUSH
68775: LD_INT 4
68777: PPUSH
68778: LD_VAR 0 11
68782: PPUSH
68783: CALL_OW 1
68787: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
68788: LD_ADDR_VAR 0 4
68792: PUSH
68793: LD_VAR 0 4
68797: PUSH
68798: LD_VAR 0 7
68802: DIFF
68803: ST_TO_ADDR
// if tmp and mech < 6 then
68804: LD_VAR 0 4
68808: IFFALSE 68820
68810: PUSH
68811: LD_VAR 0 7
68815: PUSH
68816: LD_INT 6
68818: LESS
68819: AND
68820: IFFALSE 69002
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
68822: LD_ADDR_VAR 0 9
68826: PUSH
68827: LD_VAR 0 4
68831: PUSH
68832: LD_VAR 0 7
68836: DIFF
68837: PPUSH
68838: LD_INT 3
68840: PPUSH
68841: CALL 54034 0 2
68845: ST_TO_ADDR
// p := [ ] ;
68846: LD_ADDR_VAR 0 11
68850: PUSH
68851: EMPTY
68852: ST_TO_ADDR
// if sort then
68853: LD_VAR 0 9
68857: IFFALSE 68973
// for i = 1 to 6 - mech do
68859: LD_ADDR_VAR 0 3
68863: PUSH
68864: DOUBLE
68865: LD_INT 1
68867: DEC
68868: ST_TO_ADDR
68869: LD_INT 6
68871: PUSH
68872: LD_VAR 0 7
68876: MINUS
68877: PUSH
68878: FOR_TO
68879: IFFALSE 68971
// begin if i = sort then
68881: LD_VAR 0 3
68885: PUSH
68886: LD_VAR 0 9
68890: EQUAL
68891: IFFALSE 68895
// break ;
68893: GO 68971
// if GetClass ( i ) = 3 then
68895: LD_VAR 0 3
68899: PPUSH
68900: CALL_OW 257
68904: PUSH
68905: LD_INT 3
68907: EQUAL
68908: IFFALSE 68912
// continue ;
68910: GO 68878
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68912: LD_ADDR_VAR 0 11
68916: PUSH
68917: LD_VAR 0 11
68921: PPUSH
68922: LD_VAR 0 11
68926: PUSH
68927: LD_INT 1
68929: PLUS
68930: PPUSH
68931: LD_VAR 0 9
68935: PUSH
68936: LD_VAR 0 3
68940: ARRAY
68941: PPUSH
68942: CALL_OW 2
68946: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68947: LD_ADDR_VAR 0 4
68951: PUSH
68952: LD_VAR 0 4
68956: PUSH
68957: LD_VAR 0 9
68961: PUSH
68962: LD_VAR 0 3
68966: ARRAY
68967: DIFF
68968: ST_TO_ADDR
// end ;
68969: GO 68878
68971: POP
68972: POP
// if p then
68973: LD_VAR 0 11
68977: IFFALSE 69002
// result := Replace ( result , 3 , p ) ;
68979: LD_ADDR_VAR 0 2
68983: PUSH
68984: LD_VAR 0 2
68988: PPUSH
68989: LD_INT 3
68991: PPUSH
68992: LD_VAR 0 11
68996: PPUSH
68997: CALL_OW 1
69001: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
69002: LD_ADDR_VAR 0 4
69006: PUSH
69007: LD_VAR 0 4
69011: PUSH
69012: LD_VAR 0 6
69016: DIFF
69017: ST_TO_ADDR
// if tmp and eng < 4 then
69018: LD_VAR 0 4
69022: IFFALSE 69034
69024: PUSH
69025: LD_VAR 0 6
69029: PUSH
69030: LD_INT 4
69032: LESS
69033: AND
69034: IFFALSE 69224
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
69036: LD_ADDR_VAR 0 9
69040: PUSH
69041: LD_VAR 0 4
69045: PUSH
69046: LD_VAR 0 7
69050: PUSH
69051: LD_VAR 0 6
69055: UNION
69056: DIFF
69057: PPUSH
69058: LD_INT 2
69060: PPUSH
69061: CALL 54034 0 2
69065: ST_TO_ADDR
// p := [ ] ;
69066: LD_ADDR_VAR 0 11
69070: PUSH
69071: EMPTY
69072: ST_TO_ADDR
// if sort then
69073: LD_VAR 0 9
69077: IFFALSE 69193
// for i = 1 to 4 - eng do
69079: LD_ADDR_VAR 0 3
69083: PUSH
69084: DOUBLE
69085: LD_INT 1
69087: DEC
69088: ST_TO_ADDR
69089: LD_INT 4
69091: PUSH
69092: LD_VAR 0 6
69096: MINUS
69097: PUSH
69098: FOR_TO
69099: IFFALSE 69191
// begin if i = sort then
69101: LD_VAR 0 3
69105: PUSH
69106: LD_VAR 0 9
69110: EQUAL
69111: IFFALSE 69115
// break ;
69113: GO 69191
// if GetClass ( i ) = 2 then
69115: LD_VAR 0 3
69119: PPUSH
69120: CALL_OW 257
69124: PUSH
69125: LD_INT 2
69127: EQUAL
69128: IFFALSE 69132
// continue ;
69130: GO 69098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
69132: LD_ADDR_VAR 0 11
69136: PUSH
69137: LD_VAR 0 11
69141: PPUSH
69142: LD_VAR 0 11
69146: PUSH
69147: LD_INT 1
69149: PLUS
69150: PPUSH
69151: LD_VAR 0 9
69155: PUSH
69156: LD_VAR 0 3
69160: ARRAY
69161: PPUSH
69162: CALL_OW 2
69166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
69167: LD_ADDR_VAR 0 4
69171: PUSH
69172: LD_VAR 0 4
69176: PUSH
69177: LD_VAR 0 9
69181: PUSH
69182: LD_VAR 0 3
69186: ARRAY
69187: DIFF
69188: ST_TO_ADDR
// end ;
69189: GO 69098
69191: POP
69192: POP
// if p then
69193: LD_VAR 0 11
69197: IFFALSE 69222
// result := Replace ( result , 2 , p ) ;
69199: LD_ADDR_VAR 0 2
69203: PUSH
69204: LD_VAR 0 2
69208: PPUSH
69209: LD_INT 2
69211: PPUSH
69212: LD_VAR 0 11
69216: PPUSH
69217: CALL_OW 1
69221: ST_TO_ADDR
// end else
69222: GO 69268
// for i = eng downto 5 do
69224: LD_ADDR_VAR 0 3
69228: PUSH
69229: DOUBLE
69230: LD_VAR 0 6
69234: INC
69235: ST_TO_ADDR
69236: LD_INT 5
69238: PUSH
69239: FOR_DOWNTO
69240: IFFALSE 69266
// tmp := tmp union eng [ i ] ;
69242: LD_ADDR_VAR 0 4
69246: PUSH
69247: LD_VAR 0 4
69251: PUSH
69252: LD_VAR 0 6
69256: PUSH
69257: LD_VAR 0 3
69261: ARRAY
69262: UNION
69263: ST_TO_ADDR
69264: GO 69239
69266: POP
69267: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
69268: LD_ADDR_VAR 0 2
69272: PUSH
69273: LD_VAR 0 2
69277: PPUSH
69278: LD_INT 1
69280: PPUSH
69281: LD_VAR 0 4
69285: PUSH
69286: LD_VAR 0 5
69290: DIFF
69291: PPUSH
69292: CALL_OW 1
69296: ST_TO_ADDR
// exit ;
69297: GO 69299
// end ; end ;
69299: LD_VAR 0 2
69303: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
69304: LD_INT 0
69306: PPUSH
69307: PPUSH
69308: PPUSH
// if not mc_bases then
69309: LD_EXP 63
69313: NOT
69314: IFFALSE 69318
// exit ;
69316: GO 69460
// for i = 1 to mc_bases do
69318: LD_ADDR_VAR 0 2
69322: PUSH
69323: DOUBLE
69324: LD_INT 1
69326: DEC
69327: ST_TO_ADDR
69328: LD_EXP 63
69332: PUSH
69333: FOR_TO
69334: IFFALSE 69451
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69336: LD_ADDR_VAR 0 3
69340: PUSH
69341: LD_EXP 63
69345: PUSH
69346: LD_VAR 0 2
69350: ARRAY
69351: PPUSH
69352: LD_INT 21
69354: PUSH
69355: LD_INT 3
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 3
69364: PUSH
69365: LD_INT 2
69367: PUSH
69368: LD_INT 30
69370: PUSH
69371: LD_INT 29
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: PUSH
69378: LD_INT 30
69380: PUSH
69381: LD_INT 30
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: PUSH
69388: EMPTY
69389: LIST
69390: LIST
69391: LIST
69392: PUSH
69393: EMPTY
69394: LIST
69395: LIST
69396: PUSH
69397: LD_INT 3
69399: PUSH
69400: LD_INT 24
69402: PUSH
69403: LD_INT 1000
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: PUSH
69410: EMPTY
69411: LIST
69412: LIST
69413: PUSH
69414: EMPTY
69415: LIST
69416: LIST
69417: LIST
69418: PPUSH
69419: CALL_OW 72
69423: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
69424: LD_ADDR_EXP 64
69428: PUSH
69429: LD_EXP 64
69433: PPUSH
69434: LD_VAR 0 2
69438: PPUSH
69439: LD_VAR 0 3
69443: PPUSH
69444: CALL_OW 1
69448: ST_TO_ADDR
// end ;
69449: GO 69333
69451: POP
69452: POP
// RaiseSailEvent ( 101 ) ;
69453: LD_INT 101
69455: PPUSH
69456: CALL_OW 427
// end ;
69460: LD_VAR 0 1
69464: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
69465: LD_INT 0
69467: PPUSH
69468: PPUSH
69469: PPUSH
69470: PPUSH
69471: PPUSH
69472: PPUSH
69473: PPUSH
// if not mc_bases then
69474: LD_EXP 63
69478: NOT
69479: IFFALSE 69483
// exit ;
69481: GO 70047
// for i = 1 to mc_bases do
69483: LD_ADDR_VAR 0 2
69487: PUSH
69488: DOUBLE
69489: LD_INT 1
69491: DEC
69492: ST_TO_ADDR
69493: LD_EXP 63
69497: PUSH
69498: FOR_TO
69499: IFFALSE 70038
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
69501: LD_ADDR_VAR 0 5
69505: PUSH
69506: LD_EXP 63
69510: PUSH
69511: LD_VAR 0 2
69515: ARRAY
69516: PUSH
69517: LD_EXP 92
69521: PUSH
69522: LD_VAR 0 2
69526: ARRAY
69527: UNION
69528: PPUSH
69529: LD_INT 21
69531: PUSH
69532: LD_INT 1
69534: PUSH
69535: EMPTY
69536: LIST
69537: LIST
69538: PUSH
69539: LD_INT 1
69541: PUSH
69542: LD_INT 3
69544: PUSH
69545: LD_INT 54
69547: PUSH
69548: EMPTY
69549: LIST
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 3
69557: PUSH
69558: LD_INT 24
69560: PUSH
69561: LD_INT 1000
69563: PUSH
69564: EMPTY
69565: LIST
69566: LIST
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: LIST
69576: PUSH
69577: EMPTY
69578: LIST
69579: LIST
69580: PPUSH
69581: CALL_OW 72
69585: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
69586: LD_ADDR_VAR 0 6
69590: PUSH
69591: LD_EXP 63
69595: PUSH
69596: LD_VAR 0 2
69600: ARRAY
69601: PPUSH
69602: LD_INT 21
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: LD_INT 3
69617: PUSH
69618: LD_INT 54
69620: PUSH
69621: EMPTY
69622: LIST
69623: PUSH
69624: EMPTY
69625: LIST
69626: LIST
69627: PUSH
69628: LD_INT 3
69630: PUSH
69631: LD_INT 24
69633: PUSH
69634: LD_INT 250
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: EMPTY
69646: LIST
69647: LIST
69648: LIST
69649: PUSH
69650: EMPTY
69651: LIST
69652: LIST
69653: PPUSH
69654: CALL_OW 72
69658: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
69659: LD_ADDR_VAR 0 7
69663: PUSH
69664: LD_VAR 0 5
69668: PUSH
69669: LD_VAR 0 6
69673: DIFF
69674: ST_TO_ADDR
// if not need_heal_1 then
69675: LD_VAR 0 6
69679: NOT
69680: IFFALSE 69713
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
69682: LD_ADDR_EXP 66
69686: PUSH
69687: LD_EXP 66
69691: PPUSH
69692: LD_VAR 0 2
69696: PUSH
69697: LD_INT 1
69699: PUSH
69700: EMPTY
69701: LIST
69702: LIST
69703: PPUSH
69704: EMPTY
69705: PPUSH
69706: CALL 22506 0 3
69710: ST_TO_ADDR
69711: GO 69783
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
69713: LD_ADDR_EXP 66
69717: PUSH
69718: LD_EXP 66
69722: PPUSH
69723: LD_VAR 0 2
69727: PUSH
69728: LD_INT 1
69730: PUSH
69731: EMPTY
69732: LIST
69733: LIST
69734: PPUSH
69735: LD_EXP 66
69739: PUSH
69740: LD_VAR 0 2
69744: ARRAY
69745: PUSH
69746: LD_INT 1
69748: ARRAY
69749: PPUSH
69750: LD_INT 3
69752: PUSH
69753: LD_INT 24
69755: PUSH
69756: LD_INT 1000
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PPUSH
69767: CALL_OW 72
69771: PUSH
69772: LD_VAR 0 6
69776: UNION
69777: PPUSH
69778: CALL 22506 0 3
69782: ST_TO_ADDR
// if not need_heal_2 then
69783: LD_VAR 0 7
69787: NOT
69788: IFFALSE 69821
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
69790: LD_ADDR_EXP 66
69794: PUSH
69795: LD_EXP 66
69799: PPUSH
69800: LD_VAR 0 2
69804: PUSH
69805: LD_INT 2
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PPUSH
69812: EMPTY
69813: PPUSH
69814: CALL 22506 0 3
69818: ST_TO_ADDR
69819: GO 69853
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
69821: LD_ADDR_EXP 66
69825: PUSH
69826: LD_EXP 66
69830: PPUSH
69831: LD_VAR 0 2
69835: PUSH
69836: LD_INT 2
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: PPUSH
69843: LD_VAR 0 7
69847: PPUSH
69848: CALL 22506 0 3
69852: ST_TO_ADDR
// if need_heal_2 then
69853: LD_VAR 0 7
69857: IFFALSE 70018
// for j in need_heal_2 do
69859: LD_ADDR_VAR 0 3
69863: PUSH
69864: LD_VAR 0 7
69868: PUSH
69869: FOR_IN
69870: IFFALSE 70016
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69872: LD_ADDR_VAR 0 5
69876: PUSH
69877: LD_EXP 63
69881: PUSH
69882: LD_VAR 0 2
69886: ARRAY
69887: PPUSH
69888: LD_INT 2
69890: PUSH
69891: LD_INT 30
69893: PUSH
69894: LD_INT 6
69896: PUSH
69897: EMPTY
69898: LIST
69899: LIST
69900: PUSH
69901: LD_INT 30
69903: PUSH
69904: LD_INT 7
69906: PUSH
69907: EMPTY
69908: LIST
69909: LIST
69910: PUSH
69911: LD_INT 30
69913: PUSH
69914: LD_INT 8
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 30
69923: PUSH
69924: LD_INT 0
69926: PUSH
69927: EMPTY
69928: LIST
69929: LIST
69930: PUSH
69931: LD_INT 30
69933: PUSH
69934: LD_INT 1
69936: PUSH
69937: EMPTY
69938: LIST
69939: LIST
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: LIST
69945: LIST
69946: LIST
69947: LIST
69948: PPUSH
69949: CALL_OW 72
69953: ST_TO_ADDR
// if tmp then
69954: LD_VAR 0 5
69958: IFFALSE 70014
// begin k := NearestUnitToUnit ( tmp , j ) ;
69960: LD_ADDR_VAR 0 4
69964: PUSH
69965: LD_VAR 0 5
69969: PPUSH
69970: LD_VAR 0 3
69974: PPUSH
69975: CALL_OW 74
69979: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69980: LD_VAR 0 3
69984: PPUSH
69985: LD_VAR 0 4
69989: PPUSH
69990: CALL_OW 296
69994: PUSH
69995: LD_INT 5
69997: GREATER
69998: IFFALSE 70014
// ComMoveToNearbyEntrance ( j , k ) ;
70000: LD_VAR 0 3
70004: PPUSH
70005: LD_VAR 0 4
70009: PPUSH
70010: CALL 56433 0 2
// end ; end ;
70014: GO 69869
70016: POP
70017: POP
// if not need_heal_1 and not need_heal_2 then
70018: LD_VAR 0 6
70022: NOT
70023: IFFALSE 70032
70025: PUSH
70026: LD_VAR 0 7
70030: NOT
70031: AND
70032: IFFALSE 70036
// continue ;
70034: GO 69498
// end ;
70036: GO 69498
70038: POP
70039: POP
// RaiseSailEvent ( 102 ) ;
70040: LD_INT 102
70042: PPUSH
70043: CALL_OW 427
// end ;
70047: LD_VAR 0 1
70051: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
70052: LD_INT 0
70054: PPUSH
70055: PPUSH
70056: PPUSH
70057: PPUSH
70058: PPUSH
70059: PPUSH
70060: PPUSH
70061: PPUSH
// if not mc_bases then
70062: LD_EXP 63
70066: NOT
70067: IFFALSE 70071
// exit ;
70069: GO 70986
// for i = 1 to mc_bases do
70071: LD_ADDR_VAR 0 2
70075: PUSH
70076: DOUBLE
70077: LD_INT 1
70079: DEC
70080: ST_TO_ADDR
70081: LD_EXP 63
70085: PUSH
70086: FOR_TO
70087: IFFALSE 70984
// begin if not mc_building_need_repair [ i ] then
70089: LD_EXP 64
70093: PUSH
70094: LD_VAR 0 2
70098: ARRAY
70099: NOT
70100: IFFALSE 70285
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
70102: LD_ADDR_VAR 0 6
70106: PUSH
70107: LD_EXP 82
70111: PUSH
70112: LD_VAR 0 2
70116: ARRAY
70117: PPUSH
70118: LD_INT 3
70120: PUSH
70121: LD_INT 24
70123: PUSH
70124: LD_INT 1000
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: EMPTY
70132: LIST
70133: LIST
70134: PUSH
70135: LD_INT 2
70137: PUSH
70138: LD_INT 34
70140: PUSH
70141: LD_INT 13
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 34
70150: PUSH
70151: LD_INT 52
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: LD_INT 34
70160: PUSH
70161: LD_INT 88
70163: PUSH
70164: EMPTY
70165: LIST
70166: LIST
70167: PUSH
70168: EMPTY
70169: LIST
70170: LIST
70171: LIST
70172: LIST
70173: PUSH
70174: EMPTY
70175: LIST
70176: LIST
70177: PPUSH
70178: CALL_OW 72
70182: ST_TO_ADDR
// if cranes then
70183: LD_VAR 0 6
70187: IFFALSE 70249
// for j in cranes do
70189: LD_ADDR_VAR 0 3
70193: PUSH
70194: LD_VAR 0 6
70198: PUSH
70199: FOR_IN
70200: IFFALSE 70247
// if not IsInArea ( j , mc_parking [ i ] ) then
70202: LD_VAR 0 3
70206: PPUSH
70207: LD_EXP 87
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: PPUSH
70218: CALL_OW 308
70222: NOT
70223: IFFALSE 70245
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70225: LD_VAR 0 3
70229: PPUSH
70230: LD_EXP 87
70234: PUSH
70235: LD_VAR 0 2
70239: ARRAY
70240: PPUSH
70241: CALL_OW 113
70245: GO 70199
70247: POP
70248: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
70249: LD_ADDR_EXP 65
70253: PUSH
70254: LD_EXP 65
70258: PPUSH
70259: LD_VAR 0 2
70263: PPUSH
70264: EMPTY
70265: PPUSH
70266: CALL_OW 1
70270: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
70271: LD_VAR 0 2
70275: PPUSH
70276: LD_INT 101
70278: PPUSH
70279: CALL 65077 0 2
// continue ;
70283: GO 70086
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
70285: LD_ADDR_EXP 69
70289: PUSH
70290: LD_EXP 69
70294: PPUSH
70295: LD_VAR 0 2
70299: PPUSH
70300: EMPTY
70301: PPUSH
70302: CALL_OW 1
70306: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70307: LD_VAR 0 2
70311: PPUSH
70312: LD_INT 103
70314: PPUSH
70315: CALL 65077 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
70319: LD_ADDR_VAR 0 5
70323: PUSH
70324: LD_EXP 63
70328: PUSH
70329: LD_VAR 0 2
70333: ARRAY
70334: PUSH
70335: LD_EXP 92
70339: PUSH
70340: LD_VAR 0 2
70344: ARRAY
70345: UNION
70346: PPUSH
70347: LD_INT 2
70349: PUSH
70350: LD_INT 25
70352: PUSH
70353: LD_INT 2
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 25
70362: PUSH
70363: LD_INT 16
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: LIST
70374: PUSH
70375: EMPTY
70376: LIST
70377: PPUSH
70378: CALL_OW 72
70382: ST_TO_ADDR
// if mc_need_heal [ i ] then
70383: LD_EXP 66
70387: PUSH
70388: LD_VAR 0 2
70392: ARRAY
70393: IFFALSE 70437
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
70395: LD_ADDR_VAR 0 5
70399: PUSH
70400: LD_VAR 0 5
70404: PUSH
70405: LD_EXP 66
70409: PUSH
70410: LD_VAR 0 2
70414: ARRAY
70415: PUSH
70416: LD_INT 1
70418: ARRAY
70419: PUSH
70420: LD_EXP 66
70424: PUSH
70425: LD_VAR 0 2
70429: ARRAY
70430: PUSH
70431: LD_INT 2
70433: ARRAY
70434: UNION
70435: DIFF
70436: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
70437: LD_ADDR_VAR 0 6
70441: PUSH
70442: LD_EXP 82
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: PPUSH
70453: LD_INT 2
70455: PUSH
70456: LD_INT 34
70458: PUSH
70459: LD_INT 13
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 34
70468: PUSH
70469: LD_INT 52
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 34
70478: PUSH
70479: LD_INT 88
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: LIST
70490: LIST
70491: PPUSH
70492: CALL_OW 72
70496: ST_TO_ADDR
// if cranes then
70497: LD_VAR 0 6
70501: IFFALSE 70673
// begin for j in cranes do
70503: LD_ADDR_VAR 0 3
70507: PUSH
70508: LD_VAR 0 6
70512: PUSH
70513: FOR_IN
70514: IFFALSE 70671
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
70516: LD_VAR 0 3
70520: PPUSH
70521: CALL_OW 256
70525: PUSH
70526: LD_INT 1000
70528: EQUAL
70529: IFFALSE 70543
70531: PUSH
70532: LD_VAR 0 3
70536: PPUSH
70537: CALL_OW 314
70541: NOT
70542: AND
70543: IFFALSE 70609
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
70545: LD_ADDR_VAR 0 8
70549: PUSH
70550: LD_EXP 64
70554: PUSH
70555: LD_VAR 0 2
70559: ARRAY
70560: PPUSH
70561: LD_VAR 0 3
70565: PPUSH
70566: CALL_OW 74
70570: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
70571: LD_VAR 0 8
70575: PPUSH
70576: LD_INT 16
70578: PPUSH
70579: CALL 25485 0 2
70583: PUSH
70584: LD_INT 4
70586: ARRAY
70587: PUSH
70588: LD_INT 10
70590: LESS
70591: IFFALSE 70607
// ComRepairBuilding ( j , to_repair ) ;
70593: LD_VAR 0 3
70597: PPUSH
70598: LD_VAR 0 8
70602: PPUSH
70603: CALL_OW 130
// end else
70607: GO 70669
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
70609: LD_VAR 0 3
70613: PPUSH
70614: CALL_OW 256
70618: PUSH
70619: LD_INT 500
70621: LESS
70622: IFFALSE 70647
70624: PUSH
70625: LD_VAR 0 3
70629: PPUSH
70630: LD_EXP 87
70634: PUSH
70635: LD_VAR 0 2
70639: ARRAY
70640: PPUSH
70641: CALL_OW 308
70645: NOT
70646: AND
70647: IFFALSE 70669
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70649: LD_VAR 0 3
70653: PPUSH
70654: LD_EXP 87
70658: PUSH
70659: LD_VAR 0 2
70663: ARRAY
70664: PPUSH
70665: CALL_OW 113
// end ;
70669: GO 70513
70671: POP
70672: POP
// end ; if tmp > 3 then
70673: LD_VAR 0 5
70677: PUSH
70678: LD_INT 3
70680: GREATER
70681: IFFALSE 70701
// tmp := ShrinkArray ( tmp , 4 ) ;
70683: LD_ADDR_VAR 0 5
70687: PUSH
70688: LD_VAR 0 5
70692: PPUSH
70693: LD_INT 4
70695: PPUSH
70696: CALL 55869 0 2
70700: ST_TO_ADDR
// if not tmp then
70701: LD_VAR 0 5
70705: NOT
70706: IFFALSE 70710
// continue ;
70708: GO 70086
// for j in tmp do
70710: LD_ADDR_VAR 0 3
70714: PUSH
70715: LD_VAR 0 5
70719: PUSH
70720: FOR_IN
70721: IFFALSE 70980
// begin if IsInUnit ( j ) then
70723: LD_VAR 0 3
70727: PPUSH
70728: CALL_OW 310
70732: IFFALSE 70743
// ComExitBuilding ( j ) ;
70734: LD_VAR 0 3
70738: PPUSH
70739: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
70743: LD_VAR 0 3
70747: PUSH
70748: LD_EXP 65
70752: PUSH
70753: LD_VAR 0 2
70757: ARRAY
70758: IN
70759: NOT
70760: IFFALSE 70818
// begin SetTag ( j , 101 ) ;
70762: LD_VAR 0 3
70766: PPUSH
70767: LD_INT 101
70769: PPUSH
70770: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
70774: LD_ADDR_EXP 65
70778: PUSH
70779: LD_EXP 65
70783: PPUSH
70784: LD_VAR 0 2
70788: PUSH
70789: LD_EXP 65
70793: PUSH
70794: LD_VAR 0 2
70798: ARRAY
70799: PUSH
70800: LD_INT 1
70802: PLUS
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PPUSH
70808: LD_VAR 0 3
70812: PPUSH
70813: CALL 22506 0 3
70817: ST_TO_ADDR
// end ; wait ( 1 ) ;
70818: LD_INT 1
70820: PPUSH
70821: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
70825: LD_ADDR_VAR 0 7
70829: PUSH
70830: LD_EXP 64
70834: PUSH
70835: LD_VAR 0 2
70839: ARRAY
70840: ST_TO_ADDR
// if mc_scan [ i ] then
70841: LD_EXP 86
70845: PUSH
70846: LD_VAR 0 2
70850: ARRAY
70851: IFFALSE 70913
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
70853: LD_ADDR_VAR 0 7
70857: PUSH
70858: LD_EXP 64
70862: PUSH
70863: LD_VAR 0 2
70867: ARRAY
70868: PPUSH
70869: LD_INT 3
70871: PUSH
70872: LD_INT 30
70874: PUSH
70875: LD_INT 32
70877: PUSH
70878: EMPTY
70879: LIST
70880: LIST
70881: PUSH
70882: LD_INT 30
70884: PUSH
70885: LD_INT 33
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 30
70894: PUSH
70895: LD_INT 31
70897: PUSH
70898: EMPTY
70899: LIST
70900: LIST
70901: PUSH
70902: EMPTY
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: PPUSH
70908: CALL_OW 72
70912: ST_TO_ADDR
// if not to_repair_tmp then
70913: LD_VAR 0 7
70917: NOT
70918: IFFALSE 70922
// continue ;
70920: GO 70720
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70922: LD_ADDR_VAR 0 8
70926: PUSH
70927: LD_VAR 0 7
70931: PPUSH
70932: LD_VAR 0 3
70936: PPUSH
70937: CALL_OW 74
70941: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
70942: LD_VAR 0 8
70946: PPUSH
70947: LD_INT 16
70949: PPUSH
70950: CALL 25485 0 2
70954: PUSH
70955: LD_INT 4
70957: ARRAY
70958: PUSH
70959: LD_INT 14
70961: LESS
70962: IFFALSE 70978
// ComRepairBuilding ( j , to_repair ) ;
70964: LD_VAR 0 3
70968: PPUSH
70969: LD_VAR 0 8
70973: PPUSH
70974: CALL_OW 130
// end ;
70978: GO 70720
70980: POP
70981: POP
// end ;
70982: GO 70086
70984: POP
70985: POP
// end ;
70986: LD_VAR 0 1
70990: RET
// export function MC_Heal ; var i , j , tmp ; begin
70991: LD_INT 0
70993: PPUSH
70994: PPUSH
70995: PPUSH
70996: PPUSH
// if not mc_bases then
70997: LD_EXP 63
71001: NOT
71002: IFFALSE 71006
// exit ;
71004: GO 71412
// for i = 1 to mc_bases do
71006: LD_ADDR_VAR 0 2
71010: PUSH
71011: DOUBLE
71012: LD_INT 1
71014: DEC
71015: ST_TO_ADDR
71016: LD_EXP 63
71020: PUSH
71021: FOR_TO
71022: IFFALSE 71410
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
71024: LD_EXP 66
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: PUSH
71035: LD_INT 1
71037: ARRAY
71038: NOT
71039: IFFALSE 71058
71041: PUSH
71042: LD_EXP 66
71046: PUSH
71047: LD_VAR 0 2
71051: ARRAY
71052: PUSH
71053: LD_INT 2
71055: ARRAY
71056: NOT
71057: AND
71058: IFFALSE 71096
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
71060: LD_ADDR_EXP 67
71064: PUSH
71065: LD_EXP 67
71069: PPUSH
71070: LD_VAR 0 2
71074: PPUSH
71075: EMPTY
71076: PPUSH
71077: CALL_OW 1
71081: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
71082: LD_VAR 0 2
71086: PPUSH
71087: LD_INT 102
71089: PPUSH
71090: CALL 65077 0 2
// continue ;
71094: GO 71021
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71096: LD_ADDR_VAR 0 4
71100: PUSH
71101: LD_EXP 63
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: PPUSH
71112: LD_INT 25
71114: PUSH
71115: LD_INT 4
71117: PUSH
71118: EMPTY
71119: LIST
71120: LIST
71121: PPUSH
71122: CALL_OW 72
71126: ST_TO_ADDR
// if not tmp then
71127: LD_VAR 0 4
71131: NOT
71132: IFFALSE 71136
// continue ;
71134: GO 71021
// if mc_taming [ i ] then
71136: LD_EXP 94
71140: PUSH
71141: LD_VAR 0 2
71145: ARRAY
71146: IFFALSE 71170
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
71148: LD_ADDR_EXP 94
71152: PUSH
71153: LD_EXP 94
71157: PPUSH
71158: LD_VAR 0 2
71162: PPUSH
71163: EMPTY
71164: PPUSH
71165: CALL_OW 1
71169: ST_TO_ADDR
// for j in tmp do
71170: LD_ADDR_VAR 0 3
71174: PUSH
71175: LD_VAR 0 4
71179: PUSH
71180: FOR_IN
71181: IFFALSE 71406
// begin if IsInUnit ( j ) then
71183: LD_VAR 0 3
71187: PPUSH
71188: CALL_OW 310
71192: IFFALSE 71203
// ComExitBuilding ( j ) ;
71194: LD_VAR 0 3
71198: PPUSH
71199: CALL_OW 122
// if not j in mc_healers [ i ] then
71203: LD_VAR 0 3
71207: PUSH
71208: LD_EXP 67
71212: PUSH
71213: LD_VAR 0 2
71217: ARRAY
71218: IN
71219: NOT
71220: IFFALSE 71266
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
71222: LD_ADDR_EXP 67
71226: PUSH
71227: LD_EXP 67
71231: PPUSH
71232: LD_VAR 0 2
71236: PUSH
71237: LD_EXP 67
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: PUSH
71248: LD_INT 1
71250: PLUS
71251: PUSH
71252: EMPTY
71253: LIST
71254: LIST
71255: PPUSH
71256: LD_VAR 0 3
71260: PPUSH
71261: CALL 22506 0 3
71265: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
71266: LD_VAR 0 3
71270: PPUSH
71271: CALL_OW 110
71275: PUSH
71276: LD_INT 102
71278: NONEQUAL
71279: IFFALSE 71293
// SetTag ( j , 102 ) ;
71281: LD_VAR 0 3
71285: PPUSH
71286: LD_INT 102
71288: PPUSH
71289: CALL_OW 109
// Wait ( 3 ) ;
71293: LD_INT 3
71295: PPUSH
71296: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
71300: LD_EXP 66
71304: PUSH
71305: LD_VAR 0 2
71309: ARRAY
71310: PUSH
71311: LD_INT 1
71313: ARRAY
71314: IFFALSE 71346
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
71316: LD_VAR 0 3
71320: PPUSH
71321: LD_EXP 66
71325: PUSH
71326: LD_VAR 0 2
71330: ARRAY
71331: PUSH
71332: LD_INT 1
71334: ARRAY
71335: PUSH
71336: LD_INT 1
71338: ARRAY
71339: PPUSH
71340: CALL_OW 128
71344: GO 71404
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
71346: LD_VAR 0 3
71350: PPUSH
71351: CALL_OW 314
71355: NOT
71356: IFFALSE 71374
71358: PUSH
71359: LD_EXP 66
71363: PUSH
71364: LD_VAR 0 2
71368: ARRAY
71369: PUSH
71370: LD_INT 2
71372: ARRAY
71373: AND
71374: IFFALSE 71404
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
71376: LD_VAR 0 3
71380: PPUSH
71381: LD_EXP 66
71385: PUSH
71386: LD_VAR 0 2
71390: ARRAY
71391: PUSH
71392: LD_INT 2
71394: ARRAY
71395: PUSH
71396: LD_INT 1
71398: ARRAY
71399: PPUSH
71400: CALL_OW 128
// end ;
71404: GO 71180
71406: POP
71407: POP
// end ;
71408: GO 71021
71410: POP
71411: POP
// end ;
71412: LD_VAR 0 1
71416: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
71417: LD_INT 0
71419: PPUSH
71420: PPUSH
71421: PPUSH
71422: PPUSH
71423: PPUSH
71424: PPUSH
// if not mc_bases then
71425: LD_EXP 63
71429: NOT
71430: IFFALSE 71434
// exit ;
71432: GO 72605
// for i = 1 to mc_bases do
71434: LD_ADDR_VAR 0 2
71438: PUSH
71439: DOUBLE
71440: LD_INT 1
71442: DEC
71443: ST_TO_ADDR
71444: LD_EXP 63
71448: PUSH
71449: FOR_TO
71450: IFFALSE 72603
// begin if mc_scan [ i ] then
71452: LD_EXP 86
71456: PUSH
71457: LD_VAR 0 2
71461: ARRAY
71462: IFFALSE 71466
// continue ;
71464: GO 71449
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
71466: LD_EXP 68
71470: PUSH
71471: LD_VAR 0 2
71475: ARRAY
71476: NOT
71477: IFFALSE 71492
71479: PUSH
71480: LD_EXP 70
71484: PUSH
71485: LD_VAR 0 2
71489: ARRAY
71490: NOT
71491: AND
71492: IFFALSE 71506
71494: PUSH
71495: LD_EXP 69
71499: PUSH
71500: LD_VAR 0 2
71504: ARRAY
71505: AND
71506: IFFALSE 71544
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
71508: LD_ADDR_EXP 69
71512: PUSH
71513: LD_EXP 69
71517: PPUSH
71518: LD_VAR 0 2
71522: PPUSH
71523: EMPTY
71524: PPUSH
71525: CALL_OW 1
71529: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
71530: LD_VAR 0 2
71534: PPUSH
71535: LD_INT 103
71537: PPUSH
71538: CALL 65077 0 2
// continue ;
71542: GO 71449
// end ; if mc_construct_list [ i ] then
71544: LD_EXP 70
71548: PUSH
71549: LD_VAR 0 2
71553: ARRAY
71554: IFFALSE 71774
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71556: LD_ADDR_VAR 0 5
71560: PUSH
71561: LD_EXP 63
71565: PUSH
71566: LD_VAR 0 2
71570: ARRAY
71571: PPUSH
71572: LD_INT 25
71574: PUSH
71575: LD_INT 2
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PPUSH
71582: CALL_OW 72
71586: PUSH
71587: LD_EXP 65
71591: PUSH
71592: LD_VAR 0 2
71596: ARRAY
71597: DIFF
71598: ST_TO_ADDR
// if not tmp then
71599: LD_VAR 0 5
71603: NOT
71604: IFFALSE 71608
// continue ;
71606: GO 71449
// for j in tmp do
71608: LD_ADDR_VAR 0 3
71612: PUSH
71613: LD_VAR 0 5
71617: PUSH
71618: FOR_IN
71619: IFFALSE 71770
// begin if not mc_builders [ i ] then
71621: LD_EXP 69
71625: PUSH
71626: LD_VAR 0 2
71630: ARRAY
71631: NOT
71632: IFFALSE 71690
// begin SetTag ( j , 103 ) ;
71634: LD_VAR 0 3
71638: PPUSH
71639: LD_INT 103
71641: PPUSH
71642: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71646: LD_ADDR_EXP 69
71650: PUSH
71651: LD_EXP 69
71655: PPUSH
71656: LD_VAR 0 2
71660: PUSH
71661: LD_EXP 69
71665: PUSH
71666: LD_VAR 0 2
71670: ARRAY
71671: PUSH
71672: LD_INT 1
71674: PLUS
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PPUSH
71680: LD_VAR 0 3
71684: PPUSH
71685: CALL 22506 0 3
71689: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71690: LD_VAR 0 3
71694: PPUSH
71695: CALL_OW 310
71699: IFFALSE 71710
// ComExitBuilding ( j ) ;
71701: LD_VAR 0 3
71705: PPUSH
71706: CALL_OW 122
// wait ( 3 ) ;
71710: LD_INT 3
71712: PPUSH
71713: CALL_OW 67
// if not mc_construct_list [ i ] then
71717: LD_EXP 70
71721: PUSH
71722: LD_VAR 0 2
71726: ARRAY
71727: NOT
71728: IFFALSE 71732
// break ;
71730: GO 71770
// if not HasTask ( j ) then
71732: LD_VAR 0 3
71736: PPUSH
71737: CALL_OW 314
71741: NOT
71742: IFFALSE 71768
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
71744: LD_VAR 0 3
71748: PPUSH
71749: LD_EXP 70
71753: PUSH
71754: LD_VAR 0 2
71758: ARRAY
71759: PUSH
71760: LD_INT 1
71762: ARRAY
71763: PPUSH
71764: CALL 25758 0 2
// end ;
71768: GO 71618
71770: POP
71771: POP
// end else
71772: GO 72601
// if mc_build_list [ i ] then
71774: LD_EXP 68
71778: PUSH
71779: LD_VAR 0 2
71783: ARRAY
71784: IFFALSE 72601
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
71786: LD_EXP 68
71790: PUSH
71791: LD_VAR 0 2
71795: ARRAY
71796: PUSH
71797: LD_INT 1
71799: ARRAY
71800: PUSH
71801: LD_INT 1
71803: ARRAY
71804: PPUSH
71805: CALL 25582 0 1
71809: IFFALSE 71857
71811: PUSH
71812: LD_EXP 63
71816: PUSH
71817: LD_VAR 0 2
71821: ARRAY
71822: PPUSH
71823: LD_INT 2
71825: PUSH
71826: LD_INT 30
71828: PUSH
71829: LD_INT 2
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 30
71838: PUSH
71839: LD_INT 3
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: EMPTY
71847: LIST
71848: LIST
71849: LIST
71850: PPUSH
71851: CALL_OW 72
71855: NOT
71856: AND
71857: IFFALSE 71962
// begin for j = 1 to mc_build_list [ i ] do
71859: LD_ADDR_VAR 0 3
71863: PUSH
71864: DOUBLE
71865: LD_INT 1
71867: DEC
71868: ST_TO_ADDR
71869: LD_EXP 68
71873: PUSH
71874: LD_VAR 0 2
71878: ARRAY
71879: PUSH
71880: FOR_TO
71881: IFFALSE 71960
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71883: LD_EXP 68
71887: PUSH
71888: LD_VAR 0 2
71892: ARRAY
71893: PUSH
71894: LD_VAR 0 3
71898: ARRAY
71899: PUSH
71900: LD_INT 1
71902: ARRAY
71903: PUSH
71904: LD_INT 2
71906: EQUAL
71907: IFFALSE 71958
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71909: LD_ADDR_EXP 68
71913: PUSH
71914: LD_EXP 68
71918: PPUSH
71919: LD_VAR 0 2
71923: PPUSH
71924: LD_EXP 68
71928: PUSH
71929: LD_VAR 0 2
71933: ARRAY
71934: PPUSH
71935: LD_VAR 0 3
71939: PPUSH
71940: LD_INT 1
71942: PPUSH
71943: LD_INT 0
71945: PPUSH
71946: CALL 21914 0 4
71950: PPUSH
71951: CALL_OW 1
71955: ST_TO_ADDR
// break ;
71956: GO 71960
// end ;
71958: GO 71880
71960: POP
71961: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71962: LD_ADDR_VAR 0 6
71966: PUSH
71967: LD_EXP 63
71971: PUSH
71972: LD_VAR 0 2
71976: ARRAY
71977: PPUSH
71978: LD_INT 2
71980: PUSH
71981: LD_INT 30
71983: PUSH
71984: LD_INT 0
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 30
71993: PUSH
71994: LD_INT 1
71996: PUSH
71997: EMPTY
71998: LIST
71999: LIST
72000: PUSH
72001: EMPTY
72002: LIST
72003: LIST
72004: LIST
72005: PPUSH
72006: CALL_OW 72
72010: ST_TO_ADDR
// for k := 1 to depot do
72011: LD_ADDR_VAR 0 4
72015: PUSH
72016: DOUBLE
72017: LD_INT 1
72019: DEC
72020: ST_TO_ADDR
72021: LD_VAR 0 6
72025: PUSH
72026: FOR_TO
72027: IFFALSE 72599
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
72029: LD_EXP 68
72033: PUSH
72034: LD_VAR 0 2
72038: ARRAY
72039: PUSH
72040: LD_INT 1
72042: ARRAY
72043: PUSH
72044: LD_INT 1
72046: ARRAY
72047: PUSH
72048: LD_INT 0
72050: EQUAL
72051: IFTRUE 72146
72053: PUSH
72054: LD_VAR 0 6
72058: PUSH
72059: LD_VAR 0 4
72063: ARRAY
72064: PPUSH
72065: LD_EXP 68
72069: PUSH
72070: LD_VAR 0 2
72074: ARRAY
72075: PUSH
72076: LD_INT 1
72078: ARRAY
72079: PUSH
72080: LD_INT 1
72082: ARRAY
72083: PPUSH
72084: LD_EXP 68
72088: PUSH
72089: LD_VAR 0 2
72093: ARRAY
72094: PUSH
72095: LD_INT 1
72097: ARRAY
72098: PUSH
72099: LD_INT 2
72101: ARRAY
72102: PPUSH
72103: LD_EXP 68
72107: PUSH
72108: LD_VAR 0 2
72112: ARRAY
72113: PUSH
72114: LD_INT 1
72116: ARRAY
72117: PUSH
72118: LD_INT 3
72120: ARRAY
72121: PPUSH
72122: LD_EXP 68
72126: PUSH
72127: LD_VAR 0 2
72131: ARRAY
72132: PUSH
72133: LD_INT 1
72135: ARRAY
72136: PUSH
72137: LD_INT 4
72139: ARRAY
72140: PPUSH
72141: CALL 31062 0 5
72145: OR
72146: IFFALSE 72427
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
72148: LD_ADDR_VAR 0 5
72152: PUSH
72153: LD_EXP 63
72157: PUSH
72158: LD_VAR 0 2
72162: ARRAY
72163: PPUSH
72164: LD_INT 25
72166: PUSH
72167: LD_INT 2
72169: PUSH
72170: EMPTY
72171: LIST
72172: LIST
72173: PPUSH
72174: CALL_OW 72
72178: PUSH
72179: LD_EXP 65
72183: PUSH
72184: LD_VAR 0 2
72188: ARRAY
72189: DIFF
72190: ST_TO_ADDR
// if not tmp then
72191: LD_VAR 0 5
72195: NOT
72196: IFFALSE 72200
// continue ;
72198: GO 72026
// for j in tmp do
72200: LD_ADDR_VAR 0 3
72204: PUSH
72205: LD_VAR 0 5
72209: PUSH
72210: FOR_IN
72211: IFFALSE 72423
// begin if not mc_builders [ i ] then
72213: LD_EXP 69
72217: PUSH
72218: LD_VAR 0 2
72222: ARRAY
72223: NOT
72224: IFFALSE 72282
// begin SetTag ( j , 103 ) ;
72226: LD_VAR 0 3
72230: PPUSH
72231: LD_INT 103
72233: PPUSH
72234: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
72238: LD_ADDR_EXP 69
72242: PUSH
72243: LD_EXP 69
72247: PPUSH
72248: LD_VAR 0 2
72252: PUSH
72253: LD_EXP 69
72257: PUSH
72258: LD_VAR 0 2
72262: ARRAY
72263: PUSH
72264: LD_INT 1
72266: PLUS
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PPUSH
72272: LD_VAR 0 3
72276: PPUSH
72277: CALL 22506 0 3
72281: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
72282: LD_VAR 0 3
72286: PPUSH
72287: CALL_OW 310
72291: IFFALSE 72302
// ComExitBuilding ( j ) ;
72293: LD_VAR 0 3
72297: PPUSH
72298: CALL_OW 122
// wait ( 3 ) ;
72302: LD_INT 3
72304: PPUSH
72305: CALL_OW 67
// if not mc_build_list [ i ] then
72309: LD_EXP 68
72313: PUSH
72314: LD_VAR 0 2
72318: ARRAY
72319: NOT
72320: IFFALSE 72324
// break ;
72322: GO 72423
// if not HasTask ( j ) then
72324: LD_VAR 0 3
72328: PPUSH
72329: CALL_OW 314
72333: NOT
72334: IFFALSE 72421
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
72336: LD_VAR 0 3
72340: PPUSH
72341: LD_EXP 68
72345: PUSH
72346: LD_VAR 0 2
72350: ARRAY
72351: PUSH
72352: LD_INT 1
72354: ARRAY
72355: PUSH
72356: LD_INT 1
72358: ARRAY
72359: PPUSH
72360: LD_EXP 68
72364: PUSH
72365: LD_VAR 0 2
72369: ARRAY
72370: PUSH
72371: LD_INT 1
72373: ARRAY
72374: PUSH
72375: LD_INT 2
72377: ARRAY
72378: PPUSH
72379: LD_EXP 68
72383: PUSH
72384: LD_VAR 0 2
72388: ARRAY
72389: PUSH
72390: LD_INT 1
72392: ARRAY
72393: PUSH
72394: LD_INT 3
72396: ARRAY
72397: PPUSH
72398: LD_EXP 68
72402: PUSH
72403: LD_VAR 0 2
72407: ARRAY
72408: PUSH
72409: LD_INT 1
72411: ARRAY
72412: PUSH
72413: LD_INT 4
72415: ARRAY
72416: PPUSH
72417: CALL_OW 145
// end ;
72421: GO 72210
72423: POP
72424: POP
// end else
72425: GO 72597
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
72427: LD_EXP 63
72431: PUSH
72432: LD_VAR 0 2
72436: ARRAY
72437: PPUSH
72438: LD_EXP 68
72442: PUSH
72443: LD_VAR 0 2
72447: ARRAY
72448: PUSH
72449: LD_INT 1
72451: ARRAY
72452: PUSH
72453: LD_INT 1
72455: ARRAY
72456: PPUSH
72457: LD_EXP 68
72461: PUSH
72462: LD_VAR 0 2
72466: ARRAY
72467: PUSH
72468: LD_INT 1
72470: ARRAY
72471: PUSH
72472: LD_INT 2
72474: ARRAY
72475: PPUSH
72476: LD_EXP 68
72480: PUSH
72481: LD_VAR 0 2
72485: ARRAY
72486: PUSH
72487: LD_INT 1
72489: ARRAY
72490: PUSH
72491: LD_INT 3
72493: ARRAY
72494: PPUSH
72495: LD_EXP 68
72499: PUSH
72500: LD_VAR 0 2
72504: ARRAY
72505: PUSH
72506: LD_INT 1
72508: ARRAY
72509: PUSH
72510: LD_INT 4
72512: ARRAY
72513: PPUSH
72514: LD_EXP 63
72518: PUSH
72519: LD_VAR 0 2
72523: ARRAY
72524: PPUSH
72525: LD_INT 21
72527: PUSH
72528: LD_INT 3
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PPUSH
72535: CALL_OW 72
72539: PPUSH
72540: EMPTY
72541: PPUSH
72542: CALL 29798 0 7
72546: NOT
72547: IFFALSE 72597
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
72549: LD_ADDR_EXP 68
72553: PUSH
72554: LD_EXP 68
72558: PPUSH
72559: LD_VAR 0 2
72563: PPUSH
72564: LD_EXP 68
72568: PUSH
72569: LD_VAR 0 2
72573: ARRAY
72574: PPUSH
72575: LD_INT 1
72577: PPUSH
72578: LD_INT 1
72580: NEG
72581: PPUSH
72582: LD_INT 0
72584: PPUSH
72585: CALL 21914 0 4
72589: PPUSH
72590: CALL_OW 1
72594: ST_TO_ADDR
// continue ;
72595: GO 72026
// end ; end ;
72597: GO 72026
72599: POP
72600: POP
// end ; end ;
72601: GO 71449
72603: POP
72604: POP
// end ;
72605: LD_VAR 0 1
72609: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
72610: LD_INT 0
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
72616: PPUSH
72617: PPUSH
// if not mc_bases then
72618: LD_EXP 63
72622: NOT
72623: IFFALSE 72627
// exit ;
72625: GO 73060
// for i = 1 to mc_bases do
72627: LD_ADDR_VAR 0 2
72631: PUSH
72632: DOUBLE
72633: LD_INT 1
72635: DEC
72636: ST_TO_ADDR
72637: LD_EXP 63
72641: PUSH
72642: FOR_TO
72643: IFFALSE 73058
// begin tmp := mc_build_upgrade [ i ] ;
72645: LD_ADDR_VAR 0 4
72649: PUSH
72650: LD_EXP 95
72654: PUSH
72655: LD_VAR 0 2
72659: ARRAY
72660: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
72661: LD_ADDR_VAR 0 6
72665: PUSH
72666: LD_EXP 96
72670: PUSH
72671: LD_VAR 0 2
72675: ARRAY
72676: PPUSH
72677: LD_INT 2
72679: PUSH
72680: LD_INT 30
72682: PUSH
72683: LD_INT 6
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: PUSH
72690: LD_INT 30
72692: PUSH
72693: LD_INT 7
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: LIST
72704: PPUSH
72705: CALL_OW 72
72709: ST_TO_ADDR
// if not tmp and not lab then
72710: LD_VAR 0 4
72714: NOT
72715: IFFALSE 72724
72717: PUSH
72718: LD_VAR 0 6
72722: NOT
72723: AND
72724: IFFALSE 72728
// continue ;
72726: GO 72642
// if tmp then
72728: LD_VAR 0 4
72732: IFFALSE 72852
// for j in tmp do
72734: LD_ADDR_VAR 0 3
72738: PUSH
72739: LD_VAR 0 4
72743: PUSH
72744: FOR_IN
72745: IFFALSE 72850
// begin if UpgradeCost ( j ) then
72747: LD_VAR 0 3
72751: PPUSH
72752: CALL 29450 0 1
72756: IFFALSE 72848
// begin ComUpgrade ( j ) ;
72758: LD_VAR 0 3
72762: PPUSH
72763: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
72767: LD_ADDR_EXP 95
72771: PUSH
72772: LD_EXP 95
72776: PPUSH
72777: LD_VAR 0 2
72781: PPUSH
72782: LD_EXP 95
72786: PUSH
72787: LD_VAR 0 2
72791: ARRAY
72792: PUSH
72793: LD_VAR 0 3
72797: DIFF
72798: PPUSH
72799: CALL_OW 1
72803: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72804: LD_ADDR_EXP 70
72808: PUSH
72809: LD_EXP 70
72813: PPUSH
72814: LD_VAR 0 2
72818: PUSH
72819: LD_EXP 70
72823: PUSH
72824: LD_VAR 0 2
72828: ARRAY
72829: PUSH
72830: LD_INT 1
72832: PLUS
72833: PUSH
72834: EMPTY
72835: LIST
72836: LIST
72837: PPUSH
72838: LD_VAR 0 3
72842: PPUSH
72843: CALL 22506 0 3
72847: ST_TO_ADDR
// end ; end ;
72848: GO 72744
72850: POP
72851: POP
// if not lab or not mc_lab_upgrade [ i ] then
72852: LD_VAR 0 6
72856: NOT
72857: IFTRUE 72872
72859: PUSH
72860: LD_EXP 97
72864: PUSH
72865: LD_VAR 0 2
72869: ARRAY
72870: NOT
72871: OR
72872: IFFALSE 72876
// continue ;
72874: GO 72642
// for j in lab do
72876: LD_ADDR_VAR 0 3
72880: PUSH
72881: LD_VAR 0 6
72885: PUSH
72886: FOR_IN
72887: IFFALSE 73054
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72889: LD_VAR 0 3
72893: PPUSH
72894: CALL_OW 266
72898: PUSH
72899: LD_INT 6
72901: PUSH
72902: LD_INT 7
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: IN
72909: IFFALSE 72926
72911: PUSH
72912: LD_VAR 0 3
72916: PPUSH
72917: CALL_OW 461
72921: PUSH
72922: LD_INT 1
72924: NONEQUAL
72925: AND
72926: IFFALSE 73052
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72928: LD_VAR 0 3
72932: PPUSH
72933: LD_EXP 97
72937: PUSH
72938: LD_VAR 0 2
72942: ARRAY
72943: PUSH
72944: LD_INT 1
72946: ARRAY
72947: PPUSH
72948: CALL 29659 0 2
72952: IFFALSE 73052
// begin ComCancel ( j ) ;
72954: LD_VAR 0 3
72958: PPUSH
72959: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72963: LD_VAR 0 3
72967: PPUSH
72968: LD_EXP 97
72972: PUSH
72973: LD_VAR 0 2
72977: ARRAY
72978: PUSH
72979: LD_INT 1
72981: ARRAY
72982: PPUSH
72983: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72987: LD_VAR 0 3
72991: PUSH
72992: LD_EXP 70
72996: PUSH
72997: LD_VAR 0 2
73001: ARRAY
73002: IN
73003: NOT
73004: IFFALSE 73050
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
73006: LD_ADDR_EXP 70
73010: PUSH
73011: LD_EXP 70
73015: PPUSH
73016: LD_VAR 0 2
73020: PUSH
73021: LD_EXP 70
73025: PUSH
73026: LD_VAR 0 2
73030: ARRAY
73031: PUSH
73032: LD_INT 1
73034: PLUS
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PPUSH
73040: LD_VAR 0 3
73044: PPUSH
73045: CALL 22506 0 3
73049: ST_TO_ADDR
// break ;
73050: GO 73054
// end ; end ; end ;
73052: GO 72886
73054: POP
73055: POP
// end ;
73056: GO 72642
73058: POP
73059: POP
// end ;
73060: LD_VAR 0 1
73064: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
73065: LD_INT 0
73067: PPUSH
73068: PPUSH
73069: PPUSH
73070: PPUSH
73071: PPUSH
73072: PPUSH
73073: PPUSH
73074: PPUSH
73075: PPUSH
// if not mc_bases then
73076: LD_EXP 63
73080: NOT
73081: IFFALSE 73085
// exit ;
73083: GO 73492
// for i = 1 to mc_bases do
73085: LD_ADDR_VAR 0 2
73089: PUSH
73090: DOUBLE
73091: LD_INT 1
73093: DEC
73094: ST_TO_ADDR
73095: LD_EXP 63
73099: PUSH
73100: FOR_TO
73101: IFFALSE 73490
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
73103: LD_EXP 71
73107: PUSH
73108: LD_VAR 0 2
73112: ARRAY
73113: NOT
73114: IFTRUE 73144
73116: PUSH
73117: LD_EXP 63
73121: PUSH
73122: LD_VAR 0 2
73126: ARRAY
73127: PPUSH
73128: LD_INT 30
73130: PUSH
73131: LD_INT 3
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: PPUSH
73138: CALL_OW 72
73142: NOT
73143: OR
73144: IFFALSE 73148
// continue ;
73146: GO 73100
// busy := false ;
73148: LD_ADDR_VAR 0 8
73152: PUSH
73153: LD_INT 0
73155: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73156: LD_ADDR_VAR 0 4
73160: PUSH
73161: LD_EXP 63
73165: PUSH
73166: LD_VAR 0 2
73170: ARRAY
73171: PPUSH
73172: LD_INT 30
73174: PUSH
73175: LD_INT 3
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PPUSH
73182: CALL_OW 72
73186: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
73187: LD_ADDR_VAR 0 6
73191: PUSH
73192: LD_EXP 71
73196: PUSH
73197: LD_VAR 0 2
73201: ARRAY
73202: PPUSH
73203: LD_INT 2
73205: PUSH
73206: LD_INT 30
73208: PUSH
73209: LD_INT 32
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 30
73218: PUSH
73219: LD_INT 33
73221: PUSH
73222: EMPTY
73223: LIST
73224: LIST
73225: PUSH
73226: EMPTY
73227: LIST
73228: LIST
73229: LIST
73230: PPUSH
73231: CALL_OW 72
73235: ST_TO_ADDR
// if not t then
73236: LD_VAR 0 6
73240: NOT
73241: IFFALSE 73245
// continue ;
73243: GO 73100
// for j in tmp do
73245: LD_ADDR_VAR 0 3
73249: PUSH
73250: LD_VAR 0 4
73254: PUSH
73255: FOR_IN
73256: IFFALSE 73286
// if not BuildingStatus ( j ) = bs_idle then
73258: LD_VAR 0 3
73262: PPUSH
73263: CALL_OW 461
73267: PUSH
73268: LD_INT 2
73270: EQUAL
73271: NOT
73272: IFFALSE 73284
// begin busy := true ;
73274: LD_ADDR_VAR 0 8
73278: PUSH
73279: LD_INT 1
73281: ST_TO_ADDR
// break ;
73282: GO 73286
// end ;
73284: GO 73255
73286: POP
73287: POP
// if busy then
73288: LD_VAR 0 8
73292: IFFALSE 73296
// continue ;
73294: GO 73100
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
73296: LD_ADDR_VAR 0 7
73300: PUSH
73301: LD_VAR 0 6
73305: PPUSH
73306: LD_INT 35
73308: PUSH
73309: LD_INT 0
73311: PUSH
73312: EMPTY
73313: LIST
73314: LIST
73315: PPUSH
73316: CALL_OW 72
73320: ST_TO_ADDR
// if tw then
73321: LD_VAR 0 7
73325: IFFALSE 73402
// begin tw := tw [ 1 ] ;
73327: LD_ADDR_VAR 0 7
73331: PUSH
73332: LD_VAR 0 7
73336: PUSH
73337: LD_INT 1
73339: ARRAY
73340: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
73341: LD_ADDR_VAR 0 9
73345: PUSH
73346: LD_VAR 0 7
73350: PPUSH
73351: LD_EXP 88
73355: PUSH
73356: LD_VAR 0 2
73360: ARRAY
73361: PPUSH
73362: CALL 27913 0 2
73366: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
73367: LD_EXP 102
73371: PUSH
73372: LD_VAR 0 2
73376: ARRAY
73377: IFFALSE 73400
// if not weapon in mc_allowed_tower_weapons [ i ] then
73379: LD_VAR 0 9
73383: PUSH
73384: LD_EXP 102
73388: PUSH
73389: LD_VAR 0 2
73393: ARRAY
73394: IN
73395: NOT
73396: IFFALSE 73400
// continue ;
73398: GO 73100
// end else
73400: GO 73465
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
73402: LD_ADDR_VAR 0 5
73406: PUSH
73407: LD_EXP 71
73411: PUSH
73412: LD_VAR 0 2
73416: ARRAY
73417: PPUSH
73418: LD_VAR 0 4
73422: PPUSH
73423: CALL 55098 0 2
73427: ST_TO_ADDR
// if not tmp2 then
73428: LD_VAR 0 5
73432: NOT
73433: IFFALSE 73437
// continue ;
73435: GO 73100
// tw := tmp2 [ 1 ] ;
73437: LD_ADDR_VAR 0 7
73441: PUSH
73442: LD_VAR 0 5
73446: PUSH
73447: LD_INT 1
73449: ARRAY
73450: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
73451: LD_ADDR_VAR 0 9
73455: PUSH
73456: LD_VAR 0 5
73460: PUSH
73461: LD_INT 2
73463: ARRAY
73464: ST_TO_ADDR
// end ; if not weapon then
73465: LD_VAR 0 9
73469: NOT
73470: IFFALSE 73474
// continue ;
73472: GO 73100
// ComPlaceWeapon ( tw , weapon ) ;
73474: LD_VAR 0 7
73478: PPUSH
73479: LD_VAR 0 9
73483: PPUSH
73484: CALL_OW 148
// end ;
73488: GO 73100
73490: POP
73491: POP
// end ;
73492: LD_VAR 0 1
73496: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
73497: LD_INT 0
73499: PPUSH
73500: PPUSH
73501: PPUSH
73502: PPUSH
73503: PPUSH
73504: PPUSH
73505: PPUSH
// if not mc_bases then
73506: LD_EXP 63
73510: NOT
73511: IFFALSE 73515
// exit ;
73513: GO 74302
// for i = 1 to mc_bases do
73515: LD_ADDR_VAR 0 2
73519: PUSH
73520: DOUBLE
73521: LD_INT 1
73523: DEC
73524: ST_TO_ADDR
73525: LD_EXP 63
73529: PUSH
73530: FOR_TO
73531: IFFALSE 74300
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
73533: LD_EXP 76
73537: PUSH
73538: LD_VAR 0 2
73542: ARRAY
73543: NOT
73544: IFTRUE 73570
73546: PUSH
73547: LD_EXP 76
73551: PUSH
73552: LD_VAR 0 2
73556: ARRAY
73557: PUSH
73558: LD_EXP 77
73562: PUSH
73563: LD_VAR 0 2
73567: ARRAY
73568: EQUAL
73569: OR
73570: IFTRUE 73584
73572: PUSH
73573: LD_EXP 86
73577: PUSH
73578: LD_VAR 0 2
73582: ARRAY
73583: OR
73584: IFFALSE 73588
// continue ;
73586: GO 73530
// if mc_miners [ i ] then
73588: LD_EXP 77
73592: PUSH
73593: LD_VAR 0 2
73597: ARRAY
73598: IFFALSE 73985
// begin for j = mc_miners [ i ] downto 1 do
73600: LD_ADDR_VAR 0 3
73604: PUSH
73605: DOUBLE
73606: LD_EXP 77
73610: PUSH
73611: LD_VAR 0 2
73615: ARRAY
73616: INC
73617: ST_TO_ADDR
73618: LD_INT 1
73620: PUSH
73621: FOR_DOWNTO
73622: IFFALSE 73983
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
73624: LD_EXP 77
73628: PUSH
73629: LD_VAR 0 2
73633: ARRAY
73634: PUSH
73635: LD_VAR 0 3
73639: ARRAY
73640: PPUSH
73641: CALL_OW 301
73645: IFTRUE 73674
73647: PUSH
73648: LD_EXP 77
73652: PUSH
73653: LD_VAR 0 2
73657: ARRAY
73658: PUSH
73659: LD_VAR 0 3
73663: ARRAY
73664: PPUSH
73665: CALL_OW 257
73669: PUSH
73670: LD_INT 1
73672: NONEQUAL
73673: OR
73674: IFFALSE 73737
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
73676: LD_ADDR_VAR 0 5
73680: PUSH
73681: LD_EXP 77
73685: PUSH
73686: LD_VAR 0 2
73690: ARRAY
73691: PUSH
73692: LD_EXP 77
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: PUSH
73703: LD_VAR 0 3
73707: ARRAY
73708: DIFF
73709: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
73710: LD_ADDR_EXP 77
73714: PUSH
73715: LD_EXP 77
73719: PPUSH
73720: LD_VAR 0 2
73724: PPUSH
73725: LD_VAR 0 5
73729: PPUSH
73730: CALL_OW 1
73734: ST_TO_ADDR
// continue ;
73735: GO 73621
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
73737: LD_EXP 77
73741: PUSH
73742: LD_VAR 0 2
73746: ARRAY
73747: PUSH
73748: LD_VAR 0 3
73752: ARRAY
73753: PPUSH
73754: CALL_OW 257
73758: PUSH
73759: LD_INT 1
73761: EQUAL
73762: IFFALSE 73788
73764: PUSH
73765: LD_EXP 77
73769: PUSH
73770: LD_VAR 0 2
73774: ARRAY
73775: PUSH
73776: LD_VAR 0 3
73780: ARRAY
73781: PPUSH
73782: CALL_OW 459
73786: NOT
73787: AND
73788: IFFALSE 73814
73790: PUSH
73791: LD_EXP 77
73795: PUSH
73796: LD_VAR 0 2
73800: ARRAY
73801: PUSH
73802: LD_VAR 0 3
73806: ARRAY
73807: PPUSH
73808: CALL_OW 314
73812: NOT
73813: AND
73814: IFFALSE 73981
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
73816: LD_EXP 77
73820: PUSH
73821: LD_VAR 0 2
73825: ARRAY
73826: PUSH
73827: LD_VAR 0 3
73831: ARRAY
73832: PPUSH
73833: CALL_OW 310
73837: IFFALSE 73860
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
73839: LD_EXP 77
73843: PUSH
73844: LD_VAR 0 2
73848: ARRAY
73849: PUSH
73850: LD_VAR 0 3
73854: ARRAY
73855: PPUSH
73856: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
73860: LD_EXP 77
73864: PUSH
73865: LD_VAR 0 2
73869: ARRAY
73870: PUSH
73871: LD_VAR 0 3
73875: ARRAY
73876: PPUSH
73877: CALL_OW 314
73881: NOT
73882: IFFALSE 73981
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
73884: LD_ADDR_VAR 0 7
73888: PUSH
73889: LD_VAR 0 3
73893: PUSH
73894: LD_EXP 76
73898: PUSH
73899: LD_VAR 0 2
73903: ARRAY
73904: PPUSH
73905: CALL 19622 0 1
73909: MOD
73910: PUSH
73911: LD_INT 1
73913: PLUS
73914: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73915: LD_EXP 77
73919: PUSH
73920: LD_VAR 0 2
73924: ARRAY
73925: PUSH
73926: LD_VAR 0 3
73930: ARRAY
73931: PPUSH
73932: LD_EXP 76
73936: PUSH
73937: LD_VAR 0 2
73941: ARRAY
73942: PUSH
73943: LD_VAR 0 7
73947: ARRAY
73948: PUSH
73949: LD_INT 1
73951: ARRAY
73952: PPUSH
73953: LD_EXP 76
73957: PUSH
73958: LD_VAR 0 2
73962: ARRAY
73963: PUSH
73964: LD_VAR 0 7
73968: ARRAY
73969: PUSH
73970: LD_INT 2
73972: ARRAY
73973: PPUSH
73974: LD_INT 0
73976: PPUSH
73977: CALL_OW 193
// end ; end ; end ;
73981: GO 73621
73983: POP
73984: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73985: LD_ADDR_VAR 0 5
73989: PUSH
73990: LD_EXP 63
73994: PUSH
73995: LD_VAR 0 2
73999: ARRAY
74000: PPUSH
74001: LD_INT 2
74003: PUSH
74004: LD_INT 30
74006: PUSH
74007: LD_INT 4
74009: PUSH
74010: EMPTY
74011: LIST
74012: LIST
74013: PUSH
74014: LD_INT 30
74016: PUSH
74017: LD_INT 5
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 30
74026: PUSH
74027: LD_INT 32
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: EMPTY
74035: LIST
74036: LIST
74037: LIST
74038: LIST
74039: PPUSH
74040: CALL_OW 72
74044: ST_TO_ADDR
// if not tmp then
74045: LD_VAR 0 5
74049: NOT
74050: IFFALSE 74054
// continue ;
74052: GO 73530
// list := [ ] ;
74054: LD_ADDR_VAR 0 6
74058: PUSH
74059: EMPTY
74060: ST_TO_ADDR
// for j in tmp do
74061: LD_ADDR_VAR 0 3
74065: PUSH
74066: LD_VAR 0 5
74070: PUSH
74071: FOR_IN
74072: IFFALSE 74143
// begin for k in UnitsInside ( j ) do
74074: LD_ADDR_VAR 0 4
74078: PUSH
74079: LD_VAR 0 3
74083: PPUSH
74084: CALL_OW 313
74088: PUSH
74089: FOR_IN
74090: IFFALSE 74139
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
74092: LD_VAR 0 4
74096: PPUSH
74097: CALL_OW 257
74101: PUSH
74102: LD_INT 1
74104: EQUAL
74105: IFFALSE 74119
74107: PUSH
74108: LD_VAR 0 4
74112: PPUSH
74113: CALL_OW 459
74117: NOT
74118: AND
74119: IFFALSE 74137
// list := list ^ k ;
74121: LD_ADDR_VAR 0 6
74125: PUSH
74126: LD_VAR 0 6
74130: PUSH
74131: LD_VAR 0 4
74135: ADD
74136: ST_TO_ADDR
74137: GO 74089
74139: POP
74140: POP
// end ;
74141: GO 74071
74143: POP
74144: POP
// list := list diff mc_miners [ i ] ;
74145: LD_ADDR_VAR 0 6
74149: PUSH
74150: LD_VAR 0 6
74154: PUSH
74155: LD_EXP 77
74159: PUSH
74160: LD_VAR 0 2
74164: ARRAY
74165: DIFF
74166: ST_TO_ADDR
// if not list then
74167: LD_VAR 0 6
74171: NOT
74172: IFFALSE 74176
// continue ;
74174: GO 73530
// k := mc_mines [ i ] - mc_miners [ i ] ;
74176: LD_ADDR_VAR 0 4
74180: PUSH
74181: LD_EXP 76
74185: PUSH
74186: LD_VAR 0 2
74190: ARRAY
74191: PUSH
74192: LD_EXP 77
74196: PUSH
74197: LD_VAR 0 2
74201: ARRAY
74202: MINUS
74203: ST_TO_ADDR
// if k > list then
74204: LD_VAR 0 4
74208: PUSH
74209: LD_VAR 0 6
74213: GREATER
74214: IFFALSE 74226
// k := list ;
74216: LD_ADDR_VAR 0 4
74220: PUSH
74221: LD_VAR 0 6
74225: ST_TO_ADDR
// for j = 1 to k do
74226: LD_ADDR_VAR 0 3
74230: PUSH
74231: DOUBLE
74232: LD_INT 1
74234: DEC
74235: ST_TO_ADDR
74236: LD_VAR 0 4
74240: PUSH
74241: FOR_TO
74242: IFFALSE 74296
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
74244: LD_ADDR_EXP 77
74248: PUSH
74249: LD_EXP 77
74253: PPUSH
74254: LD_VAR 0 2
74258: PUSH
74259: LD_EXP 77
74263: PUSH
74264: LD_VAR 0 2
74268: ARRAY
74269: PUSH
74270: LD_INT 1
74272: PLUS
74273: PUSH
74274: EMPTY
74275: LIST
74276: LIST
74277: PPUSH
74278: LD_VAR 0 6
74282: PUSH
74283: LD_VAR 0 3
74287: ARRAY
74288: PPUSH
74289: CALL 22506 0 3
74293: ST_TO_ADDR
74294: GO 74241
74296: POP
74297: POP
// end ;
74298: GO 73530
74300: POP
74301: POP
// end ;
74302: LD_VAR 0 1
74306: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
74307: LD_INT 0
74309: PPUSH
74310: PPUSH
74311: PPUSH
74312: PPUSH
74313: PPUSH
74314: PPUSH
74315: PPUSH
74316: PPUSH
74317: PPUSH
74318: PPUSH
74319: PPUSH
// if not mc_bases then
74320: LD_EXP 63
74324: NOT
74325: IFFALSE 74329
// exit ;
74327: GO 76176
// for i = 1 to mc_bases do
74329: LD_ADDR_VAR 0 2
74333: PUSH
74334: DOUBLE
74335: LD_INT 1
74337: DEC
74338: ST_TO_ADDR
74339: LD_EXP 63
74343: PUSH
74344: FOR_TO
74345: IFFALSE 76174
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
74347: LD_EXP 63
74351: PUSH
74352: LD_VAR 0 2
74356: ARRAY
74357: NOT
74358: IFTRUE 74372
74360: PUSH
74361: LD_EXP 70
74365: PUSH
74366: LD_VAR 0 2
74370: ARRAY
74371: OR
74372: IFFALSE 74376
// continue ;
74374: GO 74344
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
74376: LD_EXP 79
74380: PUSH
74381: LD_VAR 0 2
74385: ARRAY
74386: NOT
74387: IFFALSE 74401
74389: PUSH
74390: LD_EXP 80
74394: PUSH
74395: LD_VAR 0 2
74399: ARRAY
74400: AND
74401: IFFALSE 74439
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
74403: LD_ADDR_EXP 80
74407: PUSH
74408: LD_EXP 80
74412: PPUSH
74413: LD_VAR 0 2
74417: PPUSH
74418: EMPTY
74419: PPUSH
74420: CALL_OW 1
74424: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
74425: LD_VAR 0 2
74429: PPUSH
74430: LD_INT 107
74432: PPUSH
74433: CALL 65077 0 2
// continue ;
74437: GO 74344
// end ; target := [ ] ;
74439: LD_ADDR_VAR 0 7
74443: PUSH
74444: EMPTY
74445: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74446: LD_ADDR_VAR 0 6
74450: PUSH
74451: LD_EXP 63
74455: PUSH
74456: LD_VAR 0 2
74460: ARRAY
74461: PUSH
74462: LD_INT 1
74464: ARRAY
74465: PPUSH
74466: CALL_OW 255
74470: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74471: LD_ADDR_VAR 0 9
74475: PUSH
74476: LD_EXP 63
74480: PUSH
74481: LD_VAR 0 2
74485: ARRAY
74486: PPUSH
74487: LD_INT 2
74489: PUSH
74490: LD_INT 30
74492: PUSH
74493: LD_INT 0
74495: PUSH
74496: EMPTY
74497: LIST
74498: LIST
74499: PUSH
74500: LD_INT 30
74502: PUSH
74503: LD_INT 1
74505: PUSH
74506: EMPTY
74507: LIST
74508: LIST
74509: PUSH
74510: EMPTY
74511: LIST
74512: LIST
74513: LIST
74514: PPUSH
74515: CALL_OW 72
74519: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
74520: LD_ADDR_VAR 0 3
74524: PUSH
74525: DOUBLE
74526: LD_EXP 79
74530: PUSH
74531: LD_VAR 0 2
74535: ARRAY
74536: INC
74537: ST_TO_ADDR
74538: LD_INT 1
74540: PUSH
74541: FOR_DOWNTO
74542: IFFALSE 74789
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
74544: LD_EXP 79
74548: PUSH
74549: LD_VAR 0 2
74553: ARRAY
74554: PUSH
74555: LD_VAR 0 3
74559: ARRAY
74560: PUSH
74561: LD_INT 2
74563: ARRAY
74564: PPUSH
74565: LD_EXP 79
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: PUSH
74576: LD_VAR 0 3
74580: ARRAY
74581: PUSH
74582: LD_INT 3
74584: ARRAY
74585: PPUSH
74586: CALL_OW 488
74590: IFFALSE 74644
74592: PUSH
74593: LD_EXP 79
74597: PUSH
74598: LD_VAR 0 2
74602: ARRAY
74603: PUSH
74604: LD_VAR 0 3
74608: ARRAY
74609: PUSH
74610: LD_INT 2
74612: ARRAY
74613: PPUSH
74614: LD_EXP 79
74618: PUSH
74619: LD_VAR 0 2
74623: ARRAY
74624: PUSH
74625: LD_VAR 0 3
74629: ARRAY
74630: PUSH
74631: LD_INT 3
74633: ARRAY
74634: PPUSH
74635: CALL_OW 284
74639: PUSH
74640: LD_INT 0
74642: EQUAL
74643: AND
74644: IFFALSE 74699
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
74646: LD_ADDR_VAR 0 5
74650: PUSH
74651: LD_EXP 79
74655: PUSH
74656: LD_VAR 0 2
74660: ARRAY
74661: PPUSH
74662: LD_VAR 0 3
74666: PPUSH
74667: CALL_OW 3
74671: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
74672: LD_ADDR_EXP 79
74676: PUSH
74677: LD_EXP 79
74681: PPUSH
74682: LD_VAR 0 2
74686: PPUSH
74687: LD_VAR 0 5
74691: PPUSH
74692: CALL_OW 1
74696: ST_TO_ADDR
// continue ;
74697: GO 74541
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
74699: LD_VAR 0 6
74703: PPUSH
74704: LD_EXP 79
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PUSH
74715: LD_VAR 0 3
74719: ARRAY
74720: PUSH
74721: LD_INT 2
74723: ARRAY
74724: PPUSH
74725: LD_EXP 79
74729: PUSH
74730: LD_VAR 0 2
74734: ARRAY
74735: PUSH
74736: LD_VAR 0 3
74740: ARRAY
74741: PUSH
74742: LD_INT 3
74744: ARRAY
74745: PPUSH
74746: LD_INT 30
74748: PPUSH
74749: CALL 23776 0 4
74753: PUSH
74754: LD_INT 4
74756: ARRAY
74757: PUSH
74758: LD_INT 0
74760: EQUAL
74761: IFFALSE 74787
// begin target := mc_crates [ i ] [ j ] ;
74763: LD_ADDR_VAR 0 7
74767: PUSH
74768: LD_EXP 79
74772: PUSH
74773: LD_VAR 0 2
74777: ARRAY
74778: PUSH
74779: LD_VAR 0 3
74783: ARRAY
74784: ST_TO_ADDR
// break ;
74785: GO 74789
// end ; end ;
74787: GO 74541
74789: POP
74790: POP
// if not target then
74791: LD_VAR 0 7
74795: NOT
74796: IFFALSE 74800
// continue ;
74798: GO 74344
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
74800: LD_ADDR_VAR 0 8
74804: PUSH
74805: LD_EXP 82
74809: PUSH
74810: LD_VAR 0 2
74814: ARRAY
74815: PPUSH
74816: LD_INT 2
74818: PUSH
74819: LD_INT 3
74821: PUSH
74822: LD_INT 58
74824: PUSH
74825: EMPTY
74826: LIST
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: LD_INT 61
74834: PUSH
74835: EMPTY
74836: LIST
74837: PUSH
74838: LD_INT 33
74840: PUSH
74841: LD_INT 5
74843: PUSH
74844: EMPTY
74845: LIST
74846: LIST
74847: PUSH
74848: LD_INT 33
74850: PUSH
74851: LD_INT 3
74853: PUSH
74854: EMPTY
74855: LIST
74856: LIST
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: LIST
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 2
74867: PUSH
74868: LD_INT 34
74870: PUSH
74871: LD_INT 32
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PUSH
74878: LD_INT 34
74880: PUSH
74881: LD_INT 51
74883: PUSH
74884: EMPTY
74885: LIST
74886: LIST
74887: PUSH
74888: LD_INT 34
74890: PUSH
74891: LD_INT 12
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: EMPTY
74899: LIST
74900: LIST
74901: LIST
74902: LIST
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PPUSH
74908: CALL_OW 72
74912: ST_TO_ADDR
// if not cargo then
74913: LD_VAR 0 8
74917: NOT
74918: IFFALSE 75632
// begin if mc_crates_collector [ i ] < 5 then
74920: LD_EXP 80
74924: PUSH
74925: LD_VAR 0 2
74929: ARRAY
74930: PUSH
74931: LD_INT 5
74933: LESS
74934: IFFALSE 75304
// begin if mc_ape [ i ] then
74936: LD_EXP 92
74940: PUSH
74941: LD_VAR 0 2
74945: ARRAY
74946: IFFALSE 74993
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74948: LD_ADDR_VAR 0 5
74952: PUSH
74953: LD_EXP 92
74957: PUSH
74958: LD_VAR 0 2
74962: ARRAY
74963: PPUSH
74964: LD_INT 25
74966: PUSH
74967: LD_INT 16
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 24
74976: PUSH
74977: LD_INT 750
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: EMPTY
74985: LIST
74986: LIST
74987: PPUSH
74988: CALL_OW 72
74992: ST_TO_ADDR
// if not tmp then
74993: LD_VAR 0 5
74997: NOT
74998: IFFALSE 75045
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
75000: LD_ADDR_VAR 0 5
75004: PUSH
75005: LD_EXP 63
75009: PUSH
75010: LD_VAR 0 2
75014: ARRAY
75015: PPUSH
75016: LD_INT 25
75018: PUSH
75019: LD_INT 2
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 24
75028: PUSH
75029: LD_INT 750
75031: PUSH
75032: EMPTY
75033: LIST
75034: LIST
75035: PUSH
75036: EMPTY
75037: LIST
75038: LIST
75039: PPUSH
75040: CALL_OW 72
75044: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
75045: LD_EXP 92
75049: PUSH
75050: LD_VAR 0 2
75054: ARRAY
75055: IFFALSE 75098
75057: PUSH
75058: LD_EXP 63
75062: PUSH
75063: LD_VAR 0 2
75067: ARRAY
75068: PPUSH
75069: LD_INT 25
75071: PUSH
75072: LD_INT 2
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 24
75081: PUSH
75082: LD_INT 750
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: EMPTY
75090: LIST
75091: LIST
75092: PPUSH
75093: CALL_OW 72
75097: AND
75098: IFFALSE 75110
75100: PUSH
75101: LD_VAR 0 5
75105: PUSH
75106: LD_INT 5
75108: LESS
75109: AND
75110: IFFALSE 75192
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
75112: LD_ADDR_VAR 0 3
75116: PUSH
75117: LD_EXP 63
75121: PUSH
75122: LD_VAR 0 2
75126: ARRAY
75127: PPUSH
75128: LD_INT 25
75130: PUSH
75131: LD_INT 2
75133: PUSH
75134: EMPTY
75135: LIST
75136: LIST
75137: PUSH
75138: LD_INT 24
75140: PUSH
75141: LD_INT 750
75143: PUSH
75144: EMPTY
75145: LIST
75146: LIST
75147: PUSH
75148: EMPTY
75149: LIST
75150: LIST
75151: PPUSH
75152: CALL_OW 72
75156: PUSH
75157: FOR_IN
75158: IFFALSE 75190
// begin tmp := tmp union j ;
75160: LD_ADDR_VAR 0 5
75164: PUSH
75165: LD_VAR 0 5
75169: PUSH
75170: LD_VAR 0 3
75174: UNION
75175: ST_TO_ADDR
// if tmp >= 5 then
75176: LD_VAR 0 5
75180: PUSH
75181: LD_INT 5
75183: GREATEREQUAL
75184: IFFALSE 75188
// break ;
75186: GO 75190
// end ;
75188: GO 75157
75190: POP
75191: POP
// end ; if not tmp then
75192: LD_VAR 0 5
75196: NOT
75197: IFFALSE 75201
// continue ;
75199: GO 74344
// for j in tmp do
75201: LD_ADDR_VAR 0 3
75205: PUSH
75206: LD_VAR 0 5
75210: PUSH
75211: FOR_IN
75212: IFFALSE 75302
// if not GetTag ( j ) then
75214: LD_VAR 0 3
75218: PPUSH
75219: CALL_OW 110
75223: NOT
75224: IFFALSE 75300
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
75226: LD_ADDR_EXP 80
75230: PUSH
75231: LD_EXP 80
75235: PPUSH
75236: LD_VAR 0 2
75240: PUSH
75241: LD_EXP 80
75245: PUSH
75246: LD_VAR 0 2
75250: ARRAY
75251: PUSH
75252: LD_INT 1
75254: PLUS
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PPUSH
75260: LD_VAR 0 3
75264: PPUSH
75265: CALL 22506 0 3
75269: ST_TO_ADDR
// SetTag ( j , 107 ) ;
75270: LD_VAR 0 3
75274: PPUSH
75275: LD_INT 107
75277: PPUSH
75278: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
75282: LD_EXP 80
75286: PUSH
75287: LD_VAR 0 2
75291: ARRAY
75292: PUSH
75293: LD_INT 5
75295: GREATEREQUAL
75296: IFFALSE 75300
// break ;
75298: GO 75302
// end ;
75300: GO 75211
75302: POP
75303: POP
// end ; if mc_crates_collector [ i ] and target then
75304: LD_EXP 80
75308: PUSH
75309: LD_VAR 0 2
75313: ARRAY
75314: IFFALSE 75322
75316: PUSH
75317: LD_VAR 0 7
75321: AND
75322: IFFALSE 75630
// begin if mc_crates_collector [ i ] < target [ 1 ] then
75324: LD_EXP 80
75328: PUSH
75329: LD_VAR 0 2
75333: ARRAY
75334: PUSH
75335: LD_VAR 0 7
75339: PUSH
75340: LD_INT 1
75342: ARRAY
75343: LESS
75344: IFFALSE 75364
// tmp := mc_crates_collector [ i ] else
75346: LD_ADDR_VAR 0 5
75350: PUSH
75351: LD_EXP 80
75355: PUSH
75356: LD_VAR 0 2
75360: ARRAY
75361: ST_TO_ADDR
75362: GO 75378
// tmp := target [ 1 ] ;
75364: LD_ADDR_VAR 0 5
75368: PUSH
75369: LD_VAR 0 7
75373: PUSH
75374: LD_INT 1
75376: ARRAY
75377: ST_TO_ADDR
// k := 0 ;
75378: LD_ADDR_VAR 0 4
75382: PUSH
75383: LD_INT 0
75385: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
75386: LD_ADDR_VAR 0 3
75390: PUSH
75391: LD_EXP 80
75395: PUSH
75396: LD_VAR 0 2
75400: ARRAY
75401: PUSH
75402: FOR_IN
75403: IFFALSE 75628
// begin k := k + 1 ;
75405: LD_ADDR_VAR 0 4
75409: PUSH
75410: LD_VAR 0 4
75414: PUSH
75415: LD_INT 1
75417: PLUS
75418: ST_TO_ADDR
// if k > tmp then
75419: LD_VAR 0 4
75423: PUSH
75424: LD_VAR 0 5
75428: GREATER
75429: IFFALSE 75433
// break ;
75431: GO 75628
// if not GetClass ( j ) in [ 2 , 16 ] then
75433: LD_VAR 0 3
75437: PPUSH
75438: CALL_OW 257
75442: PUSH
75443: LD_INT 2
75445: PUSH
75446: LD_INT 16
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: IN
75453: NOT
75454: IFFALSE 75507
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
75456: LD_ADDR_EXP 80
75460: PUSH
75461: LD_EXP 80
75465: PPUSH
75466: LD_VAR 0 2
75470: PPUSH
75471: LD_EXP 80
75475: PUSH
75476: LD_VAR 0 2
75480: ARRAY
75481: PUSH
75482: LD_VAR 0 3
75486: DIFF
75487: PPUSH
75488: CALL_OW 1
75492: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75493: LD_VAR 0 3
75497: PPUSH
75498: LD_INT 0
75500: PPUSH
75501: CALL_OW 109
// continue ;
75505: GO 75402
// end ; if IsInUnit ( j ) then
75507: LD_VAR 0 3
75511: PPUSH
75512: CALL_OW 310
75516: IFFALSE 75527
// ComExitBuilding ( j ) ;
75518: LD_VAR 0 3
75522: PPUSH
75523: CALL_OW 122
// wait ( 3 ) ;
75527: LD_INT 3
75529: PPUSH
75530: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
75534: LD_VAR 0 3
75538: PPUSH
75539: CALL_OW 314
75543: IFFALSE 75581
75545: PUSH
75546: LD_VAR 0 6
75550: PPUSH
75551: LD_VAR 0 7
75555: PUSH
75556: LD_INT 2
75558: ARRAY
75559: PPUSH
75560: LD_VAR 0 7
75564: PUSH
75565: LD_INT 3
75567: ARRAY
75568: PPUSH
75569: LD_INT 30
75571: PPUSH
75572: CALL 23776 0 4
75576: PUSH
75577: LD_INT 4
75579: ARRAY
75580: AND
75581: IFFALSE 75599
// ComStandNearbyBuilding ( j , depot ) else
75583: LD_VAR 0 3
75587: PPUSH
75588: LD_VAR 0 9
75592: PPUSH
75593: CALL 19082 0 2
75597: GO 75626
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75599: LD_VAR 0 3
75603: PPUSH
75604: LD_VAR 0 7
75608: PUSH
75609: LD_INT 2
75611: ARRAY
75612: PPUSH
75613: LD_VAR 0 7
75617: PUSH
75618: LD_INT 3
75620: ARRAY
75621: PPUSH
75622: CALL_OW 117
// end ;
75626: GO 75402
75628: POP
75629: POP
// end ; end else
75630: GO 76172
// begin for j in cargo do
75632: LD_ADDR_VAR 0 3
75636: PUSH
75637: LD_VAR 0 8
75641: PUSH
75642: FOR_IN
75643: IFFALSE 76170
// begin if GetTag ( j ) <> 0 then
75645: LD_VAR 0 3
75649: PPUSH
75650: CALL_OW 110
75654: PUSH
75655: LD_INT 0
75657: NONEQUAL
75658: IFFALSE 75662
// continue ;
75660: GO 75642
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
75662: LD_VAR 0 3
75666: PPUSH
75667: CALL_OW 256
75671: PUSH
75672: LD_INT 1000
75674: LESS
75675: IFFALSE 75700
75677: PUSH
75678: LD_VAR 0 3
75682: PPUSH
75683: LD_EXP 87
75687: PUSH
75688: LD_VAR 0 2
75692: ARRAY
75693: PPUSH
75694: CALL_OW 308
75698: NOT
75699: AND
75700: IFFALSE 75722
// ComMoveToArea ( j , mc_parking [ i ] ) ;
75702: LD_VAR 0 3
75706: PPUSH
75707: LD_EXP 87
75711: PUSH
75712: LD_VAR 0 2
75716: ARRAY
75717: PPUSH
75718: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
75722: LD_VAR 0 3
75726: PPUSH
75727: CALL_OW 256
75731: PUSH
75732: LD_INT 1000
75734: LESS
75735: IFFALSE 75759
75737: PUSH
75738: LD_VAR 0 3
75742: PPUSH
75743: LD_EXP 87
75747: PUSH
75748: LD_VAR 0 2
75752: ARRAY
75753: PPUSH
75754: CALL_OW 308
75758: AND
75759: IFFALSE 75763
// continue ;
75761: GO 75642
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
75763: LD_VAR 0 3
75767: PPUSH
75768: CALL_OW 262
75772: PUSH
75773: LD_INT 2
75775: EQUAL
75776: IFFALSE 75793
75778: PUSH
75779: LD_VAR 0 3
75783: PPUSH
75784: CALL_OW 261
75788: PUSH
75789: LD_INT 15
75791: LESS
75792: AND
75793: IFFALSE 75797
// continue ;
75795: GO 75642
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
75797: LD_VAR 0 3
75801: PPUSH
75802: CALL_OW 262
75806: PUSH
75807: LD_INT 1
75809: EQUAL
75810: IFFALSE 75827
75812: PUSH
75813: LD_VAR 0 3
75817: PPUSH
75818: CALL_OW 261
75822: PUSH
75823: LD_INT 10
75825: LESS
75826: AND
75827: IFFALSE 76107
// begin if not depot then
75829: LD_VAR 0 9
75833: NOT
75834: IFFALSE 75838
// continue ;
75836: GO 75642
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
75838: LD_VAR 0 3
75842: PPUSH
75843: LD_VAR 0 9
75847: PPUSH
75848: LD_VAR 0 3
75852: PPUSH
75853: CALL_OW 74
75857: PPUSH
75858: CALL_OW 296
75862: PUSH
75863: LD_INT 6
75865: LESS
75866: IFFALSE 75882
// SetFuel ( j , 100 ) else
75868: LD_VAR 0 3
75872: PPUSH
75873: LD_INT 100
75875: PPUSH
75876: CALL_OW 240
75880: GO 76107
// if GetFuel ( j ) = 0 then
75882: LD_VAR 0 3
75886: PPUSH
75887: CALL_OW 261
75891: PUSH
75892: LD_INT 0
75894: EQUAL
75895: IFFALSE 76107
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
75897: LD_ADDR_EXP 82
75901: PUSH
75902: LD_EXP 82
75906: PPUSH
75907: LD_VAR 0 2
75911: PPUSH
75912: LD_EXP 82
75916: PUSH
75917: LD_VAR 0 2
75921: ARRAY
75922: PUSH
75923: LD_VAR 0 3
75927: DIFF
75928: PPUSH
75929: CALL_OW 1
75933: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75934: LD_VAR 0 3
75938: PPUSH
75939: CALL_OW 263
75943: PUSH
75944: LD_INT 1
75946: EQUAL
75947: IFFALSE 75963
// ComExitVehicle ( IsInUnit ( j ) ) ;
75949: LD_VAR 0 3
75953: PPUSH
75954: CALL_OW 310
75958: PPUSH
75959: CALL_OW 121
// if GetControl ( j ) = control_remote then
75963: LD_VAR 0 3
75967: PPUSH
75968: CALL_OW 263
75972: PUSH
75973: LD_INT 2
75975: EQUAL
75976: IFFALSE 75987
// ComUnlink ( j ) ;
75978: LD_VAR 0 3
75982: PPUSH
75983: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75987: LD_ADDR_VAR 0 10
75991: PUSH
75992: LD_VAR 0 2
75996: PPUSH
75997: LD_INT 3
75999: PPUSH
76000: CALL 85901 0 2
76004: ST_TO_ADDR
// if fac then
76005: LD_VAR 0 10
76009: IFFALSE 76105
// begin for k in fac do
76011: LD_ADDR_VAR 0 4
76015: PUSH
76016: LD_VAR 0 10
76020: PUSH
76021: FOR_IN
76022: IFFALSE 76103
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
76024: LD_ADDR_VAR 0 11
76028: PUSH
76029: LD_VAR 0 10
76033: PPUSH
76034: LD_VAR 0 3
76038: PPUSH
76039: CALL_OW 265
76043: PPUSH
76044: LD_VAR 0 3
76048: PPUSH
76049: CALL_OW 262
76053: PPUSH
76054: LD_VAR 0 3
76058: PPUSH
76059: CALL_OW 263
76063: PPUSH
76064: LD_VAR 0 3
76068: PPUSH
76069: CALL_OW 264
76073: PPUSH
76074: CALL 19980 0 5
76078: ST_TO_ADDR
// if components then
76079: LD_VAR 0 11
76083: IFFALSE 76101
// begin MC_InsertProduceList ( i , components ) ;
76085: LD_VAR 0 2
76089: PPUSH
76090: LD_VAR 0 11
76094: PPUSH
76095: CALL 85446 0 2
// break ;
76099: GO 76103
// end ; end ;
76101: GO 76021
76103: POP
76104: POP
// end ; continue ;
76105: GO 75642
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
76107: LD_VAR 0 3
76111: PPUSH
76112: LD_INT 1
76114: PPUSH
76115: CALL_OW 289
76119: PUSH
76120: LD_INT 100
76122: LESS
76123: IFFALSE 76137
76125: PUSH
76126: LD_VAR 0 3
76130: PPUSH
76131: CALL_OW 314
76135: NOT
76136: AND
76137: IFFALSE 76166
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
76139: LD_VAR 0 3
76143: PPUSH
76144: LD_VAR 0 7
76148: PUSH
76149: LD_INT 2
76151: ARRAY
76152: PPUSH
76153: LD_VAR 0 7
76157: PUSH
76158: LD_INT 3
76160: ARRAY
76161: PPUSH
76162: CALL_OW 117
// break ;
76166: GO 76170
// end ;
76168: GO 75642
76170: POP
76171: POP
// end ; end ;
76172: GO 74344
76174: POP
76175: POP
// end ;
76176: LD_VAR 0 1
76180: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
76181: LD_INT 0
76183: PPUSH
76184: PPUSH
76185: PPUSH
76186: PPUSH
// if not mc_bases then
76187: LD_EXP 63
76191: NOT
76192: IFFALSE 76196
// exit ;
76194: GO 76361
// for i = 1 to mc_bases do
76196: LD_ADDR_VAR 0 2
76200: PUSH
76201: DOUBLE
76202: LD_INT 1
76204: DEC
76205: ST_TO_ADDR
76206: LD_EXP 63
76210: PUSH
76211: FOR_TO
76212: IFFALSE 76359
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
76214: LD_ADDR_VAR 0 4
76218: PUSH
76219: LD_EXP 82
76223: PUSH
76224: LD_VAR 0 2
76228: ARRAY
76229: PUSH
76230: LD_EXP 85
76234: PUSH
76235: LD_VAR 0 2
76239: ARRAY
76240: UNION
76241: PPUSH
76242: LD_INT 33
76244: PUSH
76245: LD_INT 2
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PPUSH
76252: CALL_OW 72
76256: ST_TO_ADDR
// if tmp then
76257: LD_VAR 0 4
76261: IFFALSE 76357
// for j in tmp do
76263: LD_ADDR_VAR 0 3
76267: PUSH
76268: LD_VAR 0 4
76272: PUSH
76273: FOR_IN
76274: IFFALSE 76355
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
76276: LD_VAR 0 3
76280: PPUSH
76281: CALL_OW 312
76285: NOT
76286: IFFALSE 76303
76288: PUSH
76289: LD_VAR 0 3
76293: PPUSH
76294: CALL_OW 256
76298: PUSH
76299: LD_INT 250
76301: GREATEREQUAL
76302: AND
76303: IFFALSE 76316
// Connect ( j ) else
76305: LD_VAR 0 3
76309: PPUSH
76310: CALL 25866 0 1
76314: GO 76353
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
76316: LD_VAR 0 3
76320: PPUSH
76321: CALL_OW 256
76325: PUSH
76326: LD_INT 250
76328: LESS
76329: IFFALSE 76342
76331: PUSH
76332: LD_VAR 0 3
76336: PPUSH
76337: CALL_OW 312
76341: AND
76342: IFFALSE 76353
// ComUnlink ( j ) ;
76344: LD_VAR 0 3
76348: PPUSH
76349: CALL_OW 136
76353: GO 76273
76355: POP
76356: POP
// end ;
76357: GO 76211
76359: POP
76360: POP
// end ;
76361: LD_VAR 0 1
76365: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
76366: LD_INT 0
76368: PPUSH
76369: PPUSH
76370: PPUSH
76371: PPUSH
76372: PPUSH
// if not mc_bases then
76373: LD_EXP 63
76377: NOT
76378: IFFALSE 76382
// exit ;
76380: GO 76831
// for i = 1 to mc_bases do
76382: LD_ADDR_VAR 0 2
76386: PUSH
76387: DOUBLE
76388: LD_INT 1
76390: DEC
76391: ST_TO_ADDR
76392: LD_EXP 63
76396: PUSH
76397: FOR_TO
76398: IFFALSE 76829
// begin if not mc_produce [ i ] then
76400: LD_EXP 84
76404: PUSH
76405: LD_VAR 0 2
76409: ARRAY
76410: NOT
76411: IFFALSE 76415
// continue ;
76413: GO 76397
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
76415: LD_ADDR_VAR 0 5
76419: PUSH
76420: LD_EXP 63
76424: PUSH
76425: LD_VAR 0 2
76429: ARRAY
76430: PPUSH
76431: LD_INT 30
76433: PUSH
76434: LD_INT 3
76436: PUSH
76437: EMPTY
76438: LIST
76439: LIST
76440: PPUSH
76441: CALL_OW 72
76445: ST_TO_ADDR
// if not fac then
76446: LD_VAR 0 5
76450: NOT
76451: IFFALSE 76455
// continue ;
76453: GO 76397
// for j in fac do
76455: LD_ADDR_VAR 0 3
76459: PUSH
76460: LD_VAR 0 5
76464: PUSH
76465: FOR_IN
76466: IFFALSE 76825
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
76468: LD_VAR 0 3
76472: PPUSH
76473: CALL_OW 461
76477: PUSH
76478: LD_INT 2
76480: NONEQUAL
76481: IFTRUE 76501
76483: PUSH
76484: LD_VAR 0 3
76488: PPUSH
76489: LD_INT 15
76491: PPUSH
76492: CALL 25485 0 2
76496: PUSH
76497: LD_INT 4
76499: ARRAY
76500: OR
76501: IFFALSE 76505
// continue ;
76503: GO 76465
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
76505: LD_VAR 0 3
76509: PPUSH
76510: LD_EXP 84
76514: PUSH
76515: LD_VAR 0 2
76519: ARRAY
76520: PUSH
76521: LD_INT 1
76523: ARRAY
76524: PUSH
76525: LD_INT 1
76527: ARRAY
76528: PPUSH
76529: LD_EXP 84
76533: PUSH
76534: LD_VAR 0 2
76538: ARRAY
76539: PUSH
76540: LD_INT 1
76542: ARRAY
76543: PUSH
76544: LD_INT 2
76546: ARRAY
76547: PPUSH
76548: LD_EXP 84
76552: PUSH
76553: LD_VAR 0 2
76557: ARRAY
76558: PUSH
76559: LD_INT 1
76561: ARRAY
76562: PUSH
76563: LD_INT 3
76565: ARRAY
76566: PPUSH
76567: LD_EXP 84
76571: PUSH
76572: LD_VAR 0 2
76576: ARRAY
76577: PUSH
76578: LD_INT 1
76580: ARRAY
76581: PUSH
76582: LD_INT 4
76584: ARRAY
76585: PPUSH
76586: CALL_OW 448
76590: IFFALSE 76685
76592: PUSH
76593: LD_VAR 0 3
76597: PPUSH
76598: LD_EXP 84
76602: PUSH
76603: LD_VAR 0 2
76607: ARRAY
76608: PUSH
76609: LD_INT 1
76611: ARRAY
76612: PUSH
76613: LD_INT 1
76615: ARRAY
76616: PUSH
76617: LD_EXP 84
76621: PUSH
76622: LD_VAR 0 2
76626: ARRAY
76627: PUSH
76628: LD_INT 1
76630: ARRAY
76631: PUSH
76632: LD_INT 2
76634: ARRAY
76635: PUSH
76636: LD_EXP 84
76640: PUSH
76641: LD_VAR 0 2
76645: ARRAY
76646: PUSH
76647: LD_INT 1
76649: ARRAY
76650: PUSH
76651: LD_INT 3
76653: ARRAY
76654: PUSH
76655: LD_EXP 84
76659: PUSH
76660: LD_VAR 0 2
76664: ARRAY
76665: PUSH
76666: LD_INT 1
76668: ARRAY
76669: PUSH
76670: LD_INT 4
76672: ARRAY
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: LIST
76678: LIST
76679: PPUSH
76680: CALL 29299 0 2
76684: AND
76685: IFFALSE 76823
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
76687: LD_VAR 0 3
76691: PPUSH
76692: LD_EXP 84
76696: PUSH
76697: LD_VAR 0 2
76701: ARRAY
76702: PUSH
76703: LD_INT 1
76705: ARRAY
76706: PUSH
76707: LD_INT 1
76709: ARRAY
76710: PPUSH
76711: LD_EXP 84
76715: PUSH
76716: LD_VAR 0 2
76720: ARRAY
76721: PUSH
76722: LD_INT 1
76724: ARRAY
76725: PUSH
76726: LD_INT 2
76728: ARRAY
76729: PPUSH
76730: LD_EXP 84
76734: PUSH
76735: LD_VAR 0 2
76739: ARRAY
76740: PUSH
76741: LD_INT 1
76743: ARRAY
76744: PUSH
76745: LD_INT 3
76747: ARRAY
76748: PPUSH
76749: LD_EXP 84
76753: PUSH
76754: LD_VAR 0 2
76758: ARRAY
76759: PUSH
76760: LD_INT 1
76762: ARRAY
76763: PUSH
76764: LD_INT 4
76766: ARRAY
76767: PPUSH
76768: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
76772: LD_ADDR_VAR 0 4
76776: PUSH
76777: LD_EXP 84
76781: PUSH
76782: LD_VAR 0 2
76786: ARRAY
76787: PPUSH
76788: LD_INT 1
76790: PPUSH
76791: CALL_OW 3
76795: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
76796: LD_ADDR_EXP 84
76800: PUSH
76801: LD_EXP 84
76805: PPUSH
76806: LD_VAR 0 2
76810: PPUSH
76811: LD_VAR 0 4
76815: PPUSH
76816: CALL_OW 1
76820: ST_TO_ADDR
// break ;
76821: GO 76825
// end ; end ;
76823: GO 76465
76825: POP
76826: POP
// end ;
76827: GO 76397
76829: POP
76830: POP
// end ;
76831: LD_VAR 0 1
76835: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
76836: LD_INT 0
76838: PPUSH
76839: PPUSH
76840: PPUSH
// if not mc_bases then
76841: LD_EXP 63
76845: NOT
76846: IFFALSE 76850
// exit ;
76848: GO 76939
// for i = 1 to mc_bases do
76850: LD_ADDR_VAR 0 2
76854: PUSH
76855: DOUBLE
76856: LD_INT 1
76858: DEC
76859: ST_TO_ADDR
76860: LD_EXP 63
76864: PUSH
76865: FOR_TO
76866: IFFALSE 76937
// begin if mc_attack [ i ] then
76868: LD_EXP 83
76872: PUSH
76873: LD_VAR 0 2
76877: ARRAY
76878: IFFALSE 76935
// begin tmp := mc_attack [ i ] [ 1 ] ;
76880: LD_ADDR_VAR 0 3
76884: PUSH
76885: LD_EXP 83
76889: PUSH
76890: LD_VAR 0 2
76894: ARRAY
76895: PUSH
76896: LD_INT 1
76898: ARRAY
76899: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
76900: LD_ADDR_EXP 83
76904: PUSH
76905: LD_EXP 83
76909: PPUSH
76910: LD_VAR 0 2
76914: PPUSH
76915: EMPTY
76916: PPUSH
76917: CALL_OW 1
76921: ST_TO_ADDR
// Attack ( tmp ) ;
76922: LD_VAR 0 3
76926: PPUSH
76927: CALL 114252 0 1
// exit ;
76931: POP
76932: POP
76933: GO 76939
// end ; end ;
76935: GO 76865
76937: POP
76938: POP
// end ;
76939: LD_VAR 0 1
76943: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
76944: LD_INT 0
76946: PPUSH
76947: PPUSH
76948: PPUSH
76949: PPUSH
76950: PPUSH
76951: PPUSH
76952: PPUSH
// if not mc_bases then
76953: LD_EXP 63
76957: NOT
76958: IFFALSE 76962
// exit ;
76960: GO 77839
// for i = 1 to mc_bases do
76962: LD_ADDR_VAR 0 2
76966: PUSH
76967: DOUBLE
76968: LD_INT 1
76970: DEC
76971: ST_TO_ADDR
76972: LD_EXP 63
76976: PUSH
76977: FOR_TO
76978: IFFALSE 77837
// begin if not mc_bases [ i ] then
76980: LD_EXP 63
76984: PUSH
76985: LD_VAR 0 2
76989: ARRAY
76990: NOT
76991: IFFALSE 76995
// continue ;
76993: GO 76977
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76995: LD_ADDR_VAR 0 7
76999: PUSH
77000: LD_EXP 63
77004: PUSH
77005: LD_VAR 0 2
77009: ARRAY
77010: PUSH
77011: LD_INT 1
77013: ARRAY
77014: PPUSH
77015: CALL 19306 0 1
77019: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
77020: LD_ADDR_EXP 86
77024: PUSH
77025: LD_EXP 86
77029: PPUSH
77030: LD_VAR 0 2
77034: PPUSH
77035: LD_EXP 63
77039: PUSH
77040: LD_VAR 0 2
77044: ARRAY
77045: PUSH
77046: LD_INT 1
77048: ARRAY
77049: PPUSH
77050: CALL_OW 255
77054: PPUSH
77055: LD_EXP 88
77059: PUSH
77060: LD_VAR 0 2
77064: ARRAY
77065: PPUSH
77066: CALL 19271 0 2
77070: PPUSH
77071: CALL_OW 1
77075: ST_TO_ADDR
// if not mc_scan [ i ] then
77076: LD_EXP 86
77080: PUSH
77081: LD_VAR 0 2
77085: ARRAY
77086: NOT
77087: IFFALSE 77271
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
77089: LD_ADDR_EXP 106
77093: PUSH
77094: LD_EXP 106
77098: PPUSH
77099: LD_VAR 0 2
77103: PPUSH
77104: LD_INT 0
77106: PPUSH
77107: CALL_OW 1
77111: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77112: LD_ADDR_VAR 0 4
77116: PUSH
77117: LD_EXP 63
77121: PUSH
77122: LD_VAR 0 2
77126: ARRAY
77127: PPUSH
77128: LD_INT 2
77130: PUSH
77131: LD_INT 25
77133: PUSH
77134: LD_INT 5
77136: PUSH
77137: EMPTY
77138: LIST
77139: LIST
77140: PUSH
77141: LD_INT 25
77143: PUSH
77144: LD_INT 8
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 25
77153: PUSH
77154: LD_INT 9
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: LIST
77165: LIST
77166: PPUSH
77167: CALL_OW 72
77171: ST_TO_ADDR
// if not tmp then
77172: LD_VAR 0 4
77176: NOT
77177: IFFALSE 77181
// continue ;
77179: GO 76977
// for j in tmp do
77181: LD_ADDR_VAR 0 3
77185: PUSH
77186: LD_VAR 0 4
77190: PUSH
77191: FOR_IN
77192: IFFALSE 77269
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
77194: LD_VAR 0 3
77198: PPUSH
77199: CALL_OW 310
77203: PPUSH
77204: CALL_OW 266
77208: PUSH
77209: LD_INT 5
77211: EQUAL
77212: IFFALSE 77229
77214: PUSH
77215: LD_VAR 0 3
77219: PPUSH
77220: CALL_OW 257
77224: PUSH
77225: LD_INT 1
77227: EQUAL
77228: AND
77229: IFFALSE 77243
77231: PUSH
77232: LD_VAR 0 3
77236: PPUSH
77237: CALL_OW 459
77241: NOT
77242: AND
77243: IFFALSE 77251
77245: PUSH
77246: LD_VAR 0 7
77250: AND
77251: IFFALSE 77267
// ComChangeProfession ( j , class ) ;
77253: LD_VAR 0 3
77257: PPUSH
77258: LD_VAR 0 7
77262: PPUSH
77263: CALL_OW 123
77267: GO 77191
77269: POP
77270: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
77271: LD_EXP 86
77275: PUSH
77276: LD_VAR 0 2
77280: ARRAY
77281: IFFALSE 77296
77283: PUSH
77284: LD_EXP 106
77288: PUSH
77289: LD_VAR 0 2
77293: ARRAY
77294: NOT
77295: AND
77296: IFFALSE 77311
77298: PUSH
77299: LD_EXP 85
77303: PUSH
77304: LD_VAR 0 2
77308: ARRAY
77309: NOT
77310: AND
77311: IFFALSE 77462
77313: PUSH
77314: LD_EXP 63
77318: PUSH
77319: LD_VAR 0 2
77323: ARRAY
77324: PPUSH
77325: LD_INT 50
77327: PUSH
77328: EMPTY
77329: LIST
77330: PUSH
77331: LD_INT 2
77333: PUSH
77334: LD_INT 30
77336: PUSH
77337: LD_INT 32
77339: PUSH
77340: EMPTY
77341: LIST
77342: LIST
77343: PUSH
77344: LD_INT 30
77346: PUSH
77347: LD_INT 33
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 30
77356: PUSH
77357: LD_INT 4
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PUSH
77364: LD_INT 30
77366: PUSH
77367: LD_INT 5
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: EMPTY
77375: LIST
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PPUSH
77385: CALL_OW 72
77389: PUSH
77390: LD_INT 4
77392: LESS
77393: IFTRUE 77461
77395: PUSH
77396: LD_EXP 63
77400: PUSH
77401: LD_VAR 0 2
77405: ARRAY
77406: PPUSH
77407: LD_INT 3
77409: PUSH
77410: LD_INT 24
77412: PUSH
77413: LD_INT 1000
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: EMPTY
77421: LIST
77422: LIST
77423: PUSH
77424: LD_INT 2
77426: PUSH
77427: LD_INT 30
77429: PUSH
77430: LD_INT 0
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 30
77439: PUSH
77440: LD_INT 1
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: EMPTY
77448: LIST
77449: LIST
77450: LIST
77451: PUSH
77452: EMPTY
77453: LIST
77454: LIST
77455: PPUSH
77456: CALL_OW 72
77460: OR
77461: AND
77462: IFFALSE 77715
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77464: LD_ADDR_EXP 106
77468: PUSH
77469: LD_EXP 106
77473: PPUSH
77474: LD_VAR 0 2
77478: PPUSH
77479: LD_INT 1
77481: PPUSH
77482: CALL_OW 1
77486: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
77487: LD_ADDR_VAR 0 4
77491: PUSH
77492: LD_EXP 63
77496: PUSH
77497: LD_VAR 0 2
77501: ARRAY
77502: PPUSH
77503: LD_INT 2
77505: PUSH
77506: LD_INT 25
77508: PUSH
77509: LD_INT 1
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 25
77518: PUSH
77519: LD_INT 5
77521: PUSH
77522: EMPTY
77523: LIST
77524: LIST
77525: PUSH
77526: LD_INT 25
77528: PUSH
77529: LD_INT 8
77531: PUSH
77532: EMPTY
77533: LIST
77534: LIST
77535: PUSH
77536: LD_INT 25
77538: PUSH
77539: LD_INT 9
77541: PUSH
77542: EMPTY
77543: LIST
77544: LIST
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: LIST
77550: LIST
77551: LIST
77552: PPUSH
77553: CALL_OW 72
77557: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
77558: LD_ADDR_VAR 0 4
77562: PUSH
77563: LD_VAR 0 4
77567: PUSH
77568: LD_VAR 0 4
77572: PPUSH
77573: LD_INT 18
77575: PPUSH
77576: CALL 53099 0 2
77580: DIFF
77581: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
77582: LD_VAR 0 4
77586: NOT
77587: IFFALSE 77635
77589: PUSH
77590: LD_EXP 63
77594: PUSH
77595: LD_VAR 0 2
77599: ARRAY
77600: PPUSH
77601: LD_INT 2
77603: PUSH
77604: LD_INT 30
77606: PUSH
77607: LD_INT 4
77609: PUSH
77610: EMPTY
77611: LIST
77612: LIST
77613: PUSH
77614: LD_INT 30
77616: PUSH
77617: LD_INT 5
77619: PUSH
77620: EMPTY
77621: LIST
77622: LIST
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: LIST
77628: PPUSH
77629: CALL_OW 72
77633: NOT
77634: AND
77635: IFFALSE 77697
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
77637: LD_ADDR_VAR 0 4
77641: PUSH
77642: LD_EXP 63
77646: PUSH
77647: LD_VAR 0 2
77651: ARRAY
77652: PPUSH
77653: LD_INT 2
77655: PUSH
77656: LD_INT 25
77658: PUSH
77659: LD_INT 2
77661: PUSH
77662: EMPTY
77663: LIST
77664: LIST
77665: PUSH
77666: LD_INT 25
77668: PUSH
77669: LD_INT 3
77671: PUSH
77672: EMPTY
77673: LIST
77674: LIST
77675: PUSH
77676: LD_INT 25
77678: PUSH
77679: LD_INT 4
77681: PUSH
77682: EMPTY
77683: LIST
77684: LIST
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: PPUSH
77692: CALL_OW 72
77696: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
77697: LD_VAR 0 2
77701: PPUSH
77702: LD_VAR 0 4
77706: PPUSH
77707: CALL 119021 0 2
// exit ;
77711: POP
77712: POP
77713: GO 77839
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
77715: LD_EXP 86
77719: PUSH
77720: LD_VAR 0 2
77724: ARRAY
77725: IFFALSE 77740
77727: PUSH
77728: LD_EXP 106
77732: PUSH
77733: LD_VAR 0 2
77737: ARRAY
77738: NOT
77739: AND
77740: IFFALSE 77754
77742: PUSH
77743: LD_EXP 85
77747: PUSH
77748: LD_VAR 0 2
77752: ARRAY
77753: AND
77754: IFFALSE 77835
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
77756: LD_ADDR_EXP 106
77760: PUSH
77761: LD_EXP 106
77765: PPUSH
77766: LD_VAR 0 2
77770: PPUSH
77771: LD_INT 1
77773: PPUSH
77774: CALL_OW 1
77778: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
77779: LD_ADDR_VAR 0 4
77783: PUSH
77784: LD_EXP 85
77788: PUSH
77789: LD_VAR 0 2
77793: ARRAY
77794: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
77795: LD_ADDR_EXP 85
77799: PUSH
77800: LD_EXP 85
77804: PPUSH
77805: LD_VAR 0 2
77809: PPUSH
77810: EMPTY
77811: PPUSH
77812: CALL_OW 1
77816: ST_TO_ADDR
// Defend ( i , tmp ) ;
77817: LD_VAR 0 2
77821: PPUSH
77822: LD_VAR 0 4
77826: PPUSH
77827: CALL 119625 0 2
// exit ;
77831: POP
77832: POP
77833: GO 77839
// end ; end ;
77835: GO 76977
77837: POP
77838: POP
// end ;
77839: LD_VAR 0 1
77843: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
77844: LD_INT 0
77846: PPUSH
77847: PPUSH
77848: PPUSH
77849: PPUSH
77850: PPUSH
77851: PPUSH
77852: PPUSH
77853: PPUSH
77854: PPUSH
77855: PPUSH
77856: PPUSH
// if not mc_bases then
77857: LD_EXP 63
77861: NOT
77862: IFFALSE 77866
// exit ;
77864: GO 78979
// for i = 1 to mc_bases do
77866: LD_ADDR_VAR 0 2
77870: PUSH
77871: DOUBLE
77872: LD_INT 1
77874: DEC
77875: ST_TO_ADDR
77876: LD_EXP 63
77880: PUSH
77881: FOR_TO
77882: IFFALSE 78977
// begin tmp := mc_lab [ i ] ;
77884: LD_ADDR_VAR 0 6
77888: PUSH
77889: LD_EXP 96
77893: PUSH
77894: LD_VAR 0 2
77898: ARRAY
77899: ST_TO_ADDR
// if not tmp then
77900: LD_VAR 0 6
77904: NOT
77905: IFFALSE 77909
// continue ;
77907: GO 77881
// idle_lab := 0 ;
77909: LD_ADDR_VAR 0 11
77913: PUSH
77914: LD_INT 0
77916: ST_TO_ADDR
// for j in tmp do
77917: LD_ADDR_VAR 0 3
77921: PUSH
77922: LD_VAR 0 6
77926: PUSH
77927: FOR_IN
77928: IFFALSE 78973
// begin researching := false ;
77930: LD_ADDR_VAR 0 10
77934: PUSH
77935: LD_INT 0
77937: ST_TO_ADDR
// side := GetSide ( j ) ;
77938: LD_ADDR_VAR 0 4
77942: PUSH
77943: LD_VAR 0 3
77947: PPUSH
77948: CALL_OW 255
77952: ST_TO_ADDR
// if not mc_tech [ side ] then
77953: LD_EXP 90
77957: PUSH
77958: LD_VAR 0 4
77962: ARRAY
77963: NOT
77964: IFFALSE 77968
// continue ;
77966: GO 77927
// if BuildingStatus ( j ) = bs_idle then
77968: LD_VAR 0 3
77972: PPUSH
77973: CALL_OW 461
77977: PUSH
77978: LD_INT 2
77980: EQUAL
77981: IFFALSE 78173
// begin if idle_lab and UnitsInside ( j ) < 6 then
77983: LD_VAR 0 11
77987: IFFALSE 78004
77989: PUSH
77990: LD_VAR 0 3
77994: PPUSH
77995: CALL_OW 313
77999: PUSH
78000: LD_INT 6
78002: LESS
78003: AND
78004: IFFALSE 78075
// begin tmp2 := UnitsInside ( idle_lab ) ;
78006: LD_ADDR_VAR 0 9
78010: PUSH
78011: LD_VAR 0 11
78015: PPUSH
78016: CALL_OW 313
78020: ST_TO_ADDR
// if tmp2 then
78021: LD_VAR 0 9
78025: IFFALSE 78067
// for x in tmp2 do
78027: LD_ADDR_VAR 0 7
78031: PUSH
78032: LD_VAR 0 9
78036: PUSH
78037: FOR_IN
78038: IFFALSE 78065
// begin ComExitBuilding ( x ) ;
78040: LD_VAR 0 7
78044: PPUSH
78045: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78049: LD_VAR 0 7
78053: PPUSH
78054: LD_VAR 0 3
78058: PPUSH
78059: CALL_OW 180
// end ;
78063: GO 78037
78065: POP
78066: POP
// idle_lab := 0 ;
78067: LD_ADDR_VAR 0 11
78071: PUSH
78072: LD_INT 0
78074: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
78075: LD_ADDR_VAR 0 5
78079: PUSH
78080: LD_EXP 90
78084: PUSH
78085: LD_VAR 0 4
78089: ARRAY
78090: PUSH
78091: FOR_IN
78092: IFFALSE 78154
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
78094: LD_VAR 0 3
78098: PPUSH
78099: LD_VAR 0 5
78103: PPUSH
78104: CALL_OW 430
78108: IFFALSE 78126
78110: PUSH
78111: LD_VAR 0 4
78115: PPUSH
78116: LD_VAR 0 5
78120: PPUSH
78121: CALL 18366 0 2
78125: AND
78126: IFFALSE 78152
// begin researching := true ;
78128: LD_ADDR_VAR 0 10
78132: PUSH
78133: LD_INT 1
78135: ST_TO_ADDR
// ComResearch ( j , t ) ;
78136: LD_VAR 0 3
78140: PPUSH
78141: LD_VAR 0 5
78145: PPUSH
78146: CALL_OW 124
// break ;
78150: GO 78154
// end ;
78152: GO 78091
78154: POP
78155: POP
// if not researching then
78156: LD_VAR 0 10
78160: NOT
78161: IFFALSE 78173
// idle_lab := j ;
78163: LD_ADDR_VAR 0 11
78167: PUSH
78168: LD_VAR 0 3
78172: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
78173: LD_VAR 0 3
78177: PPUSH
78178: CALL_OW 461
78182: PUSH
78183: LD_INT 10
78185: EQUAL
78186: IFFALSE 78792
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
78188: LD_EXP 92
78192: PUSH
78193: LD_VAR 0 2
78197: ARRAY
78198: NOT
78199: IFFALSE 78214
78201: PUSH
78202: LD_EXP 93
78206: PUSH
78207: LD_VAR 0 2
78211: ARRAY
78212: NOT
78213: AND
78214: IFFALSE 78232
78216: PUSH
78217: LD_EXP 90
78221: PUSH
78222: LD_VAR 0 4
78226: ARRAY
78227: PUSH
78228: LD_INT 1
78230: GREATER
78231: AND
78232: IFFALSE 78363
// begin ComCancel ( j ) ;
78234: LD_VAR 0 3
78238: PPUSH
78239: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
78243: LD_ADDR_EXP 90
78247: PUSH
78248: LD_EXP 90
78252: PPUSH
78253: LD_VAR 0 4
78257: PPUSH
78258: LD_EXP 90
78262: PUSH
78263: LD_VAR 0 4
78267: ARRAY
78268: PPUSH
78269: LD_EXP 90
78273: PUSH
78274: LD_VAR 0 4
78278: ARRAY
78279: PUSH
78280: LD_INT 1
78282: MINUS
78283: PPUSH
78284: LD_EXP 90
78288: PUSH
78289: LD_VAR 0 4
78293: ARRAY
78294: PPUSH
78295: LD_INT 0
78297: PPUSH
78298: CALL 21914 0 4
78302: PPUSH
78303: CALL_OW 1
78307: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
78308: LD_ADDR_EXP 90
78312: PUSH
78313: LD_EXP 90
78317: PPUSH
78318: LD_VAR 0 4
78322: PPUSH
78323: LD_EXP 90
78327: PUSH
78328: LD_VAR 0 4
78332: ARRAY
78333: PPUSH
78334: LD_EXP 90
78338: PUSH
78339: LD_VAR 0 4
78343: ARRAY
78344: PPUSH
78345: LD_INT 1
78347: PPUSH
78348: LD_INT 0
78350: PPUSH
78351: CALL 21914 0 4
78355: PPUSH
78356: CALL_OW 1
78360: ST_TO_ADDR
// continue ;
78361: GO 77927
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
78363: LD_EXP 92
78367: PUSH
78368: LD_VAR 0 2
78372: ARRAY
78373: IFFALSE 78388
78375: PUSH
78376: LD_EXP 93
78380: PUSH
78381: LD_VAR 0 2
78385: ARRAY
78386: NOT
78387: AND
78388: IFFALSE 78515
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
78390: LD_ADDR_EXP 93
78394: PUSH
78395: LD_EXP 93
78399: PPUSH
78400: LD_VAR 0 2
78404: PUSH
78405: LD_EXP 93
78409: PUSH
78410: LD_VAR 0 2
78414: ARRAY
78415: PUSH
78416: LD_INT 1
78418: PLUS
78419: PUSH
78420: EMPTY
78421: LIST
78422: LIST
78423: PPUSH
78424: LD_EXP 92
78428: PUSH
78429: LD_VAR 0 2
78433: ARRAY
78434: PUSH
78435: LD_INT 1
78437: ARRAY
78438: PPUSH
78439: CALL 22506 0 3
78443: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
78444: LD_EXP 92
78448: PUSH
78449: LD_VAR 0 2
78453: ARRAY
78454: PUSH
78455: LD_INT 1
78457: ARRAY
78458: PPUSH
78459: LD_INT 112
78461: PPUSH
78462: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
78466: LD_ADDR_VAR 0 9
78470: PUSH
78471: LD_EXP 92
78475: PUSH
78476: LD_VAR 0 2
78480: ARRAY
78481: PPUSH
78482: LD_INT 1
78484: PPUSH
78485: CALL_OW 3
78489: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
78490: LD_ADDR_EXP 92
78494: PUSH
78495: LD_EXP 92
78499: PPUSH
78500: LD_VAR 0 2
78504: PPUSH
78505: LD_VAR 0 9
78509: PPUSH
78510: CALL_OW 1
78514: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
78515: LD_EXP 92
78519: PUSH
78520: LD_VAR 0 2
78524: ARRAY
78525: IFFALSE 78539
78527: PUSH
78528: LD_EXP 93
78532: PUSH
78533: LD_VAR 0 2
78537: ARRAY
78538: AND
78539: IFFALSE 78563
78541: PUSH
78542: LD_EXP 93
78546: PUSH
78547: LD_VAR 0 2
78551: ARRAY
78552: PUSH
78553: LD_INT 1
78555: ARRAY
78556: PPUSH
78557: CALL_OW 310
78561: NOT
78562: AND
78563: IFFALSE 78580
78565: PUSH
78566: LD_VAR 0 3
78570: PPUSH
78571: CALL_OW 313
78575: PUSH
78576: LD_INT 6
78578: EQUAL
78579: AND
78580: IFFALSE 78636
// begin tmp2 := UnitsInside ( j ) ;
78582: LD_ADDR_VAR 0 9
78586: PUSH
78587: LD_VAR 0 3
78591: PPUSH
78592: CALL_OW 313
78596: ST_TO_ADDR
// if tmp2 = 6 then
78597: LD_VAR 0 9
78601: PUSH
78602: LD_INT 6
78604: EQUAL
78605: IFFALSE 78636
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
78607: LD_VAR 0 9
78611: PUSH
78612: LD_INT 1
78614: ARRAY
78615: PPUSH
78616: LD_INT 112
78618: PPUSH
78619: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
78623: LD_VAR 0 9
78627: PUSH
78628: LD_INT 1
78630: ARRAY
78631: PPUSH
78632: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
78636: LD_EXP 93
78640: PUSH
78641: LD_VAR 0 2
78645: ARRAY
78646: IFFALSE 78670
78648: PUSH
78649: LD_EXP 93
78653: PUSH
78654: LD_VAR 0 2
78658: ARRAY
78659: PUSH
78660: LD_INT 1
78662: ARRAY
78663: PPUSH
78664: CALL_OW 314
78668: NOT
78669: AND
78670: IFFALSE 78694
78672: PUSH
78673: LD_EXP 93
78677: PUSH
78678: LD_VAR 0 2
78682: ARRAY
78683: PUSH
78684: LD_INT 1
78686: ARRAY
78687: PPUSH
78688: CALL_OW 310
78692: NOT
78693: AND
78694: IFFALSE 78720
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
78696: LD_EXP 93
78700: PUSH
78701: LD_VAR 0 2
78705: ARRAY
78706: PUSH
78707: LD_INT 1
78709: ARRAY
78710: PPUSH
78711: LD_VAR 0 3
78715: PPUSH
78716: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
78720: LD_EXP 93
78724: PUSH
78725: LD_VAR 0 2
78729: ARRAY
78730: PUSH
78731: LD_INT 1
78733: ARRAY
78734: PPUSH
78735: CALL_OW 310
78739: IFFALSE 78771
78741: PUSH
78742: LD_EXP 93
78746: PUSH
78747: LD_VAR 0 2
78751: ARRAY
78752: PUSH
78753: LD_INT 1
78755: ARRAY
78756: PPUSH
78757: CALL_OW 310
78761: PPUSH
78762: CALL_OW 461
78766: PUSH
78767: LD_INT 3
78769: NONEQUAL
78770: AND
78771: IFFALSE 78792
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
78773: LD_EXP 93
78777: PUSH
78778: LD_VAR 0 2
78782: ARRAY
78783: PUSH
78784: LD_INT 1
78786: ARRAY
78787: PPUSH
78788: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
78792: LD_VAR 0 3
78796: PPUSH
78797: CALL_OW 461
78801: PUSH
78802: LD_INT 6
78804: EQUAL
78805: IFFALSE 78817
78807: PUSH
78808: LD_VAR 0 6
78812: PUSH
78813: LD_INT 1
78815: GREATER
78816: AND
78817: IFFALSE 78971
// begin sci := [ ] ;
78819: LD_ADDR_VAR 0 8
78823: PUSH
78824: EMPTY
78825: ST_TO_ADDR
// for x in ( tmp diff j ) do
78826: LD_ADDR_VAR 0 7
78830: PUSH
78831: LD_VAR 0 6
78835: PUSH
78836: LD_VAR 0 3
78840: DIFF
78841: PUSH
78842: FOR_IN
78843: IFFALSE 78895
// begin if sci = 6 then
78845: LD_VAR 0 8
78849: PUSH
78850: LD_INT 6
78852: EQUAL
78853: IFFALSE 78857
// break ;
78855: GO 78895
// if BuildingStatus ( x ) = bs_idle then
78857: LD_VAR 0 7
78861: PPUSH
78862: CALL_OW 461
78866: PUSH
78867: LD_INT 2
78869: EQUAL
78870: IFFALSE 78893
// sci := sci ^ UnitsInside ( x ) ;
78872: LD_ADDR_VAR 0 8
78876: PUSH
78877: LD_VAR 0 8
78881: PUSH
78882: LD_VAR 0 7
78886: PPUSH
78887: CALL_OW 313
78891: ADD
78892: ST_TO_ADDR
// end ;
78893: GO 78842
78895: POP
78896: POP
// if not sci then
78897: LD_VAR 0 8
78901: NOT
78902: IFFALSE 78906
// continue ;
78904: GO 77927
// for x in sci do
78906: LD_ADDR_VAR 0 7
78910: PUSH
78911: LD_VAR 0 8
78915: PUSH
78916: FOR_IN
78917: IFFALSE 78969
// if IsInUnit ( x ) and not HasTask ( x ) then
78919: LD_VAR 0 7
78923: PPUSH
78924: CALL_OW 310
78928: IFFALSE 78942
78930: PUSH
78931: LD_VAR 0 7
78935: PPUSH
78936: CALL_OW 314
78940: NOT
78941: AND
78942: IFFALSE 78967
// begin ComExitBuilding ( x ) ;
78944: LD_VAR 0 7
78948: PPUSH
78949: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78953: LD_VAR 0 7
78957: PPUSH
78958: LD_VAR 0 3
78962: PPUSH
78963: CALL_OW 180
// end ;
78967: GO 78916
78969: POP
78970: POP
// end ; end ;
78971: GO 77927
78973: POP
78974: POP
// end ;
78975: GO 77881
78977: POP
78978: POP
// end ;
78979: LD_VAR 0 1
78983: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
78984: LD_INT 0
78986: PPUSH
78987: PPUSH
// if not mc_bases then
78988: LD_EXP 63
78992: NOT
78993: IFFALSE 78997
// exit ;
78995: GO 79080
// for i = 1 to mc_bases do
78997: LD_ADDR_VAR 0 2
79001: PUSH
79002: DOUBLE
79003: LD_INT 1
79005: DEC
79006: ST_TO_ADDR
79007: LD_EXP 63
79011: PUSH
79012: FOR_TO
79013: IFFALSE 79078
// if mc_mines [ i ] and mc_miners [ i ] then
79015: LD_EXP 76
79019: PUSH
79020: LD_VAR 0 2
79024: ARRAY
79025: IFFALSE 79039
79027: PUSH
79028: LD_EXP 77
79032: PUSH
79033: LD_VAR 0 2
79037: ARRAY
79038: AND
79039: IFFALSE 79076
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
79041: LD_EXP 77
79045: PUSH
79046: LD_VAR 0 2
79050: ARRAY
79051: PUSH
79052: LD_INT 1
79054: ARRAY
79055: PPUSH
79056: CALL_OW 255
79060: PPUSH
79061: LD_EXP 76
79065: PUSH
79066: LD_VAR 0 2
79070: ARRAY
79071: PPUSH
79072: CALL 19459 0 2
79076: GO 79012
79078: POP
79079: POP
// end ;
79080: LD_VAR 0 1
79084: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
79085: LD_INT 0
79087: PPUSH
79088: PPUSH
79089: PPUSH
79090: PPUSH
79091: PPUSH
79092: PPUSH
79093: PPUSH
79094: PPUSH
// if not mc_bases or not mc_parking then
79095: LD_EXP 63
79099: NOT
79100: IFTRUE 79109
79102: PUSH
79103: LD_EXP 87
79107: NOT
79108: OR
79109: IFFALSE 79113
// exit ;
79111: GO 79857
// for i = 1 to mc_bases do
79113: LD_ADDR_VAR 0 2
79117: PUSH
79118: DOUBLE
79119: LD_INT 1
79121: DEC
79122: ST_TO_ADDR
79123: LD_EXP 63
79127: PUSH
79128: FOR_TO
79129: IFFALSE 79855
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
79131: LD_EXP 63
79135: PUSH
79136: LD_VAR 0 2
79140: ARRAY
79141: NOT
79142: IFTRUE 79157
79144: PUSH
79145: LD_EXP 87
79149: PUSH
79150: LD_VAR 0 2
79154: ARRAY
79155: NOT
79156: OR
79157: IFFALSE 79161
// continue ;
79159: GO 79128
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
79161: LD_ADDR_VAR 0 5
79165: PUSH
79166: LD_EXP 63
79170: PUSH
79171: LD_VAR 0 2
79175: ARRAY
79176: PUSH
79177: LD_INT 1
79179: ARRAY
79180: PPUSH
79181: CALL_OW 255
79185: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79186: LD_ADDR_VAR 0 6
79190: PUSH
79191: LD_EXP 63
79195: PUSH
79196: LD_VAR 0 2
79200: ARRAY
79201: PPUSH
79202: LD_INT 30
79204: PUSH
79205: LD_INT 3
79207: PUSH
79208: EMPTY
79209: LIST
79210: LIST
79211: PPUSH
79212: CALL_OW 72
79216: ST_TO_ADDR
// if not fac then
79217: LD_VAR 0 6
79221: NOT
79222: IFFALSE 79273
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79224: LD_ADDR_VAR 0 6
79228: PUSH
79229: LD_EXP 63
79233: PUSH
79234: LD_VAR 0 2
79238: ARRAY
79239: PPUSH
79240: LD_INT 2
79242: PUSH
79243: LD_INT 30
79245: PUSH
79246: LD_INT 0
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 30
79255: PUSH
79256: LD_INT 1
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: LIST
79267: PPUSH
79268: CALL_OW 72
79272: ST_TO_ADDR
// if not fac then
79273: LD_VAR 0 6
79277: NOT
79278: IFFALSE 79282
// continue ;
79280: GO 79128
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79282: LD_ADDR_VAR 0 7
79286: PUSH
79287: LD_EXP 87
79291: PUSH
79292: LD_VAR 0 2
79296: ARRAY
79297: PPUSH
79298: LD_INT 22
79300: PUSH
79301: LD_VAR 0 5
79305: PUSH
79306: EMPTY
79307: LIST
79308: LIST
79309: PUSH
79310: LD_INT 21
79312: PUSH
79313: LD_INT 2
79315: PUSH
79316: EMPTY
79317: LIST
79318: LIST
79319: PUSH
79320: LD_INT 3
79322: PUSH
79323: LD_INT 60
79325: PUSH
79326: EMPTY
79327: LIST
79328: PUSH
79329: EMPTY
79330: LIST
79331: LIST
79332: PUSH
79333: LD_INT 3
79335: PUSH
79336: LD_INT 24
79338: PUSH
79339: LD_INT 1000
79341: PUSH
79342: EMPTY
79343: LIST
79344: LIST
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: PUSH
79350: EMPTY
79351: LIST
79352: LIST
79353: LIST
79354: LIST
79355: PPUSH
79356: CALL_OW 70
79360: ST_TO_ADDR
// for j in fac do
79361: LD_ADDR_VAR 0 3
79365: PUSH
79366: LD_VAR 0 6
79370: PUSH
79371: FOR_IN
79372: IFFALSE 79467
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
79374: LD_ADDR_VAR 0 7
79378: PUSH
79379: LD_VAR 0 7
79383: PUSH
79384: LD_INT 22
79386: PUSH
79387: LD_VAR 0 5
79391: PUSH
79392: EMPTY
79393: LIST
79394: LIST
79395: PUSH
79396: LD_INT 91
79398: PUSH
79399: LD_VAR 0 3
79403: PUSH
79404: LD_INT 15
79406: PUSH
79407: EMPTY
79408: LIST
79409: LIST
79410: LIST
79411: PUSH
79412: LD_INT 21
79414: PUSH
79415: LD_INT 2
79417: PUSH
79418: EMPTY
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 3
79424: PUSH
79425: LD_INT 60
79427: PUSH
79428: EMPTY
79429: LIST
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 3
79437: PUSH
79438: LD_INT 24
79440: PUSH
79441: LD_INT 1000
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: EMPTY
79449: LIST
79450: LIST
79451: PUSH
79452: EMPTY
79453: LIST
79454: LIST
79455: LIST
79456: LIST
79457: LIST
79458: PPUSH
79459: CALL_OW 69
79463: UNION
79464: ST_TO_ADDR
79465: GO 79371
79467: POP
79468: POP
// if not vehs then
79469: LD_VAR 0 7
79473: NOT
79474: IFFALSE 79500
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
79476: LD_ADDR_EXP 75
79480: PUSH
79481: LD_EXP 75
79485: PPUSH
79486: LD_VAR 0 2
79490: PPUSH
79491: EMPTY
79492: PPUSH
79493: CALL_OW 1
79497: ST_TO_ADDR
// continue ;
79498: GO 79128
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
79500: LD_ADDR_VAR 0 8
79504: PUSH
79505: LD_EXP 63
79509: PUSH
79510: LD_VAR 0 2
79514: ARRAY
79515: PPUSH
79516: LD_INT 30
79518: PUSH
79519: LD_INT 3
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PPUSH
79526: CALL_OW 72
79530: ST_TO_ADDR
// if tmp then
79531: LD_VAR 0 8
79535: IFFALSE 79638
// begin for j in tmp do
79537: LD_ADDR_VAR 0 3
79541: PUSH
79542: LD_VAR 0 8
79546: PUSH
79547: FOR_IN
79548: IFFALSE 79636
// for k in UnitsInside ( j ) do
79550: LD_ADDR_VAR 0 4
79554: PUSH
79555: LD_VAR 0 3
79559: PPUSH
79560: CALL_OW 313
79564: PUSH
79565: FOR_IN
79566: IFFALSE 79632
// if k then
79568: LD_VAR 0 4
79572: IFFALSE 79630
// if not k in mc_repair_vehicle [ i ] then
79574: LD_VAR 0 4
79578: PUSH
79579: LD_EXP 75
79583: PUSH
79584: LD_VAR 0 2
79588: ARRAY
79589: IN
79590: NOT
79591: IFFALSE 79630
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
79593: LD_ADDR_EXP 75
79597: PUSH
79598: LD_EXP 75
79602: PPUSH
79603: LD_VAR 0 2
79607: PPUSH
79608: LD_EXP 75
79612: PUSH
79613: LD_VAR 0 2
79617: ARRAY
79618: PUSH
79619: LD_VAR 0 4
79623: UNION
79624: PPUSH
79625: CALL_OW 1
79629: ST_TO_ADDR
79630: GO 79565
79632: POP
79633: POP
79634: GO 79547
79636: POP
79637: POP
// end ; if not mc_repair_vehicle [ i ] then
79638: LD_EXP 75
79642: PUSH
79643: LD_VAR 0 2
79647: ARRAY
79648: NOT
79649: IFFALSE 79653
// continue ;
79651: GO 79128
// for j in mc_repair_vehicle [ i ] do
79653: LD_ADDR_VAR 0 3
79657: PUSH
79658: LD_EXP 75
79662: PUSH
79663: LD_VAR 0 2
79667: ARRAY
79668: PUSH
79669: FOR_IN
79670: IFFALSE 79851
// begin if GetClass ( j ) <> 3 then
79672: LD_VAR 0 3
79676: PPUSH
79677: CALL_OW 257
79681: PUSH
79682: LD_INT 3
79684: NONEQUAL
79685: IFFALSE 79726
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
79687: LD_ADDR_EXP 75
79691: PUSH
79692: LD_EXP 75
79696: PPUSH
79697: LD_VAR 0 2
79701: PPUSH
79702: LD_EXP 75
79706: PUSH
79707: LD_VAR 0 2
79711: ARRAY
79712: PUSH
79713: LD_VAR 0 3
79717: DIFF
79718: PPUSH
79719: CALL_OW 1
79723: ST_TO_ADDR
// continue ;
79724: GO 79669
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
79726: LD_VAR 0 3
79730: PPUSH
79731: CALL_OW 311
79735: NOT
79736: IFFALSE 79761
79738: PUSH
79739: LD_VAR 0 3
79743: PUSH
79744: LD_EXP 66
79748: PUSH
79749: LD_VAR 0 2
79753: ARRAY
79754: PUSH
79755: LD_INT 1
79757: ARRAY
79758: IN
79759: NOT
79760: AND
79761: IFFALSE 79786
79763: PUSH
79764: LD_VAR 0 3
79768: PUSH
79769: LD_EXP 66
79773: PUSH
79774: LD_VAR 0 2
79778: ARRAY
79779: PUSH
79780: LD_INT 2
79782: ARRAY
79783: IN
79784: NOT
79785: AND
79786: IFFALSE 79849
// begin if IsInUnit ( j ) then
79788: LD_VAR 0 3
79792: PPUSH
79793: CALL_OW 310
79797: IFFALSE 79810
// ComExitBuilding ( j ) else
79799: LD_VAR 0 3
79803: PPUSH
79804: CALL_OW 122
79808: GO 79849
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
79810: LD_VAR 0 3
79814: PPUSH
79815: LD_VAR 0 7
79819: PUSH
79820: LD_INT 1
79822: ARRAY
79823: PPUSH
79824: CALL 57637 0 2
79828: NOT
79829: IFFALSE 79849
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
79831: LD_VAR 0 3
79835: PPUSH
79836: LD_VAR 0 7
79840: PUSH
79841: LD_INT 1
79843: ARRAY
79844: PPUSH
79845: CALL_OW 129
// end ; end ;
79849: GO 79669
79851: POP
79852: POP
// end ;
79853: GO 79128
79855: POP
79856: POP
// end ;
79857: LD_VAR 0 1
79861: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
79862: LD_INT 0
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
// if not mc_bases then
79875: LD_EXP 63
79879: NOT
79880: IFFALSE 79884
// exit ;
79882: GO 80702
// for i = 1 to mc_bases do
79884: LD_ADDR_VAR 0 2
79888: PUSH
79889: DOUBLE
79890: LD_INT 1
79892: DEC
79893: ST_TO_ADDR
79894: LD_EXP 63
79898: PUSH
79899: FOR_TO
79900: IFFALSE 80700
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
79902: LD_EXP 91
79906: PUSH
79907: LD_VAR 0 2
79911: ARRAY
79912: NOT
79913: IFTRUE 79931
79915: PUSH
79916: LD_EXP 66
79920: PUSH
79921: LD_VAR 0 2
79925: ARRAY
79926: PUSH
79927: LD_INT 1
79929: ARRAY
79930: OR
79931: IFTRUE 79949
79933: PUSH
79934: LD_EXP 66
79938: PUSH
79939: LD_VAR 0 2
79943: ARRAY
79944: PUSH
79945: LD_INT 2
79947: ARRAY
79948: OR
79949: IFTRUE 79972
79951: PUSH
79952: LD_EXP 89
79956: PUSH
79957: LD_VAR 0 2
79961: ARRAY
79962: PPUSH
79963: LD_INT 1
79965: PPUSH
79966: CALL_OW 325
79970: NOT
79971: OR
79972: IFTRUE 79986
79974: PUSH
79975: LD_EXP 86
79979: PUSH
79980: LD_VAR 0 2
79984: ARRAY
79985: OR
79986: IFFALSE 79990
// continue ;
79988: GO 79899
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
79990: LD_ADDR_VAR 0 8
79994: PUSH
79995: LD_EXP 63
79999: PUSH
80000: LD_VAR 0 2
80004: ARRAY
80005: PPUSH
80006: LD_INT 25
80008: PUSH
80009: LD_INT 4
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 50
80018: PUSH
80019: EMPTY
80020: LIST
80021: PUSH
80022: LD_INT 3
80024: PUSH
80025: LD_INT 60
80027: PUSH
80028: EMPTY
80029: LIST
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: LIST
80039: PPUSH
80040: CALL_OW 72
80044: PUSH
80045: LD_EXP 67
80049: PUSH
80050: LD_VAR 0 2
80054: ARRAY
80055: DIFF
80056: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80057: LD_ADDR_VAR 0 9
80061: PUSH
80062: LD_EXP 63
80066: PUSH
80067: LD_VAR 0 2
80071: ARRAY
80072: PPUSH
80073: LD_INT 2
80075: PUSH
80076: LD_INT 30
80078: PUSH
80079: LD_INT 0
80081: PUSH
80082: EMPTY
80083: LIST
80084: LIST
80085: PUSH
80086: LD_INT 30
80088: PUSH
80089: LD_INT 1
80091: PUSH
80092: EMPTY
80093: LIST
80094: LIST
80095: PUSH
80096: EMPTY
80097: LIST
80098: LIST
80099: LIST
80100: PPUSH
80101: CALL_OW 72
80105: ST_TO_ADDR
// if not tmp or not dep then
80106: LD_VAR 0 8
80110: NOT
80111: IFTRUE 80120
80113: PUSH
80114: LD_VAR 0 9
80118: NOT
80119: OR
80120: IFFALSE 80124
// continue ;
80122: GO 79899
// side := GetSide ( tmp [ 1 ] ) ;
80124: LD_ADDR_VAR 0 11
80128: PUSH
80129: LD_VAR 0 8
80133: PUSH
80134: LD_INT 1
80136: ARRAY
80137: PPUSH
80138: CALL_OW 255
80142: ST_TO_ADDR
// dep := dep [ 1 ] ;
80143: LD_ADDR_VAR 0 9
80147: PUSH
80148: LD_VAR 0 9
80152: PUSH
80153: LD_INT 1
80155: ARRAY
80156: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
80157: LD_ADDR_VAR 0 7
80161: PUSH
80162: LD_EXP 91
80166: PUSH
80167: LD_VAR 0 2
80171: ARRAY
80172: PPUSH
80173: LD_INT 22
80175: PUSH
80176: LD_INT 0
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: LD_INT 25
80185: PUSH
80186: LD_INT 12
80188: PUSH
80189: EMPTY
80190: LIST
80191: LIST
80192: PUSH
80193: EMPTY
80194: LIST
80195: LIST
80196: PPUSH
80197: CALL_OW 70
80201: PUSH
80202: LD_INT 22
80204: PUSH
80205: LD_INT 0
80207: PUSH
80208: EMPTY
80209: LIST
80210: LIST
80211: PUSH
80212: LD_INT 25
80214: PUSH
80215: LD_INT 12
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 91
80224: PUSH
80225: LD_VAR 0 9
80229: PUSH
80230: LD_INT 20
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: LIST
80237: PUSH
80238: EMPTY
80239: LIST
80240: LIST
80241: LIST
80242: PPUSH
80243: CALL_OW 69
80247: UNION
80248: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
80249: LD_ADDR_VAR 0 10
80253: PUSH
80254: LD_EXP 91
80258: PUSH
80259: LD_VAR 0 2
80263: ARRAY
80264: PPUSH
80265: LD_INT 81
80267: PUSH
80268: LD_VAR 0 11
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PPUSH
80277: CALL_OW 70
80281: ST_TO_ADDR
// if not apes or danger_at_area then
80282: LD_VAR 0 7
80286: NOT
80287: IFTRUE 80295
80289: PUSH
80290: LD_VAR 0 10
80294: OR
80295: IFFALSE 80345
// begin if mc_taming [ i ] then
80297: LD_EXP 94
80301: PUSH
80302: LD_VAR 0 2
80306: ARRAY
80307: IFFALSE 80343
// begin MC_Reset ( i , 121 ) ;
80309: LD_VAR 0 2
80313: PPUSH
80314: LD_INT 121
80316: PPUSH
80317: CALL 65077 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
80321: LD_ADDR_EXP 94
80325: PUSH
80326: LD_EXP 94
80330: PPUSH
80331: LD_VAR 0 2
80335: PPUSH
80336: EMPTY
80337: PPUSH
80338: CALL_OW 1
80342: ST_TO_ADDR
// end ; continue ;
80343: GO 79899
// end ; for j in tmp do
80345: LD_ADDR_VAR 0 3
80349: PUSH
80350: LD_VAR 0 8
80354: PUSH
80355: FOR_IN
80356: IFFALSE 80696
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
80358: LD_VAR 0 3
80362: PUSH
80363: LD_EXP 94
80367: PUSH
80368: LD_VAR 0 2
80372: ARRAY
80373: IN
80374: NOT
80375: IFFALSE 80393
80377: PUSH
80378: LD_EXP 94
80382: PUSH
80383: LD_VAR 0 2
80387: ARRAY
80388: PUSH
80389: LD_INT 3
80391: LESS
80392: AND
80393: IFFALSE 80451
// begin SetTag ( j , 121 ) ;
80395: LD_VAR 0 3
80399: PPUSH
80400: LD_INT 121
80402: PPUSH
80403: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
80407: LD_ADDR_EXP 94
80411: PUSH
80412: LD_EXP 94
80416: PPUSH
80417: LD_VAR 0 2
80421: PUSH
80422: LD_EXP 94
80426: PUSH
80427: LD_VAR 0 2
80431: ARRAY
80432: PUSH
80433: LD_INT 1
80435: PLUS
80436: PUSH
80437: EMPTY
80438: LIST
80439: LIST
80440: PPUSH
80441: LD_VAR 0 3
80445: PPUSH
80446: CALL 22506 0 3
80450: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
80451: LD_VAR 0 3
80455: PUSH
80456: LD_EXP 94
80460: PUSH
80461: LD_VAR 0 2
80465: ARRAY
80466: IN
80467: IFFALSE 80694
// begin if GetClass ( j ) <> 4 then
80469: LD_VAR 0 3
80473: PPUSH
80474: CALL_OW 257
80478: PUSH
80479: LD_INT 4
80481: NONEQUAL
80482: IFFALSE 80535
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
80484: LD_ADDR_EXP 94
80488: PUSH
80489: LD_EXP 94
80493: PPUSH
80494: LD_VAR 0 2
80498: PPUSH
80499: LD_EXP 94
80503: PUSH
80504: LD_VAR 0 2
80508: ARRAY
80509: PUSH
80510: LD_VAR 0 3
80514: DIFF
80515: PPUSH
80516: CALL_OW 1
80520: ST_TO_ADDR
// SetTag ( j , 0 ) ;
80521: LD_VAR 0 3
80525: PPUSH
80526: LD_INT 0
80528: PPUSH
80529: CALL_OW 109
// continue ;
80533: GO 80355
// end ; if IsInUnit ( j ) then
80535: LD_VAR 0 3
80539: PPUSH
80540: CALL_OW 310
80544: IFFALSE 80555
// ComExitBuilding ( j ) ;
80546: LD_VAR 0 3
80550: PPUSH
80551: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
80555: LD_ADDR_VAR 0 6
80559: PUSH
80560: LD_VAR 0 7
80564: PPUSH
80565: LD_VAR 0 3
80569: PPUSH
80570: CALL_OW 74
80574: ST_TO_ADDR
// if not ape then
80575: LD_VAR 0 6
80579: NOT
80580: IFFALSE 80584
// break ;
80582: GO 80696
// x := GetX ( ape ) ;
80584: LD_ADDR_VAR 0 4
80588: PUSH
80589: LD_VAR 0 6
80593: PPUSH
80594: CALL_OW 250
80598: ST_TO_ADDR
// y := GetY ( ape ) ;
80599: LD_ADDR_VAR 0 5
80603: PUSH
80604: LD_VAR 0 6
80608: PPUSH
80609: CALL_OW 251
80613: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80614: LD_VAR 0 4
80618: PPUSH
80619: LD_VAR 0 5
80623: PPUSH
80624: CALL_OW 488
80628: NOT
80629: IFTRUE 80659
80631: PUSH
80632: LD_VAR 0 11
80636: PPUSH
80637: LD_VAR 0 4
80641: PPUSH
80642: LD_VAR 0 5
80646: PPUSH
80647: LD_INT 20
80649: PPUSH
80650: CALL 23776 0 4
80654: PUSH
80655: LD_INT 4
80657: ARRAY
80658: OR
80659: IFFALSE 80663
// break ;
80661: GO 80696
// if not HasTask ( j ) then
80663: LD_VAR 0 3
80667: PPUSH
80668: CALL_OW 314
80672: NOT
80673: IFFALSE 80694
// ComTameXY ( j , x , y ) ;
80675: LD_VAR 0 3
80679: PPUSH
80680: LD_VAR 0 4
80684: PPUSH
80685: LD_VAR 0 5
80689: PPUSH
80690: CALL_OW 131
// end ; end ;
80694: GO 80355
80696: POP
80697: POP
// end ;
80698: GO 79899
80700: POP
80701: POP
// end ;
80702: LD_VAR 0 1
80706: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
80707: LD_INT 0
80709: PPUSH
80710: PPUSH
80711: PPUSH
80712: PPUSH
80713: PPUSH
80714: PPUSH
80715: PPUSH
80716: PPUSH
// if not mc_bases then
80717: LD_EXP 63
80721: NOT
80722: IFFALSE 80726
// exit ;
80724: GO 81358
// for i = 1 to mc_bases do
80726: LD_ADDR_VAR 0 2
80730: PUSH
80731: DOUBLE
80732: LD_INT 1
80734: DEC
80735: ST_TO_ADDR
80736: LD_EXP 63
80740: PUSH
80741: FOR_TO
80742: IFFALSE 81356
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
80744: LD_EXP 92
80748: PUSH
80749: LD_VAR 0 2
80753: ARRAY
80754: NOT
80755: IFTRUE 80785
80757: PUSH
80758: LD_EXP 92
80762: PUSH
80763: LD_VAR 0 2
80767: ARRAY
80768: PPUSH
80769: LD_INT 25
80771: PUSH
80772: LD_INT 12
80774: PUSH
80775: EMPTY
80776: LIST
80777: LIST
80778: PPUSH
80779: CALL_OW 72
80783: NOT
80784: OR
80785: IFFALSE 80789
// continue ;
80787: GO 80741
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
80789: LD_ADDR_VAR 0 5
80793: PUSH
80794: LD_EXP 92
80798: PUSH
80799: LD_VAR 0 2
80803: ARRAY
80804: PUSH
80805: LD_INT 1
80807: ARRAY
80808: PPUSH
80809: CALL_OW 255
80813: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
80814: LD_VAR 0 5
80818: PPUSH
80819: LD_INT 2
80821: PPUSH
80822: CALL_OW 325
80826: IFFALSE 81079
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80828: LD_ADDR_VAR 0 4
80832: PUSH
80833: LD_EXP 92
80837: PUSH
80838: LD_VAR 0 2
80842: ARRAY
80843: PPUSH
80844: LD_INT 25
80846: PUSH
80847: LD_INT 16
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PPUSH
80854: CALL_OW 72
80858: ST_TO_ADDR
// if tmp < 6 then
80859: LD_VAR 0 4
80863: PUSH
80864: LD_INT 6
80866: LESS
80867: IFFALSE 81079
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80869: LD_ADDR_VAR 0 6
80873: PUSH
80874: LD_EXP 63
80878: PUSH
80879: LD_VAR 0 2
80883: ARRAY
80884: PPUSH
80885: LD_INT 2
80887: PUSH
80888: LD_INT 30
80890: PUSH
80891: LD_INT 0
80893: PUSH
80894: EMPTY
80895: LIST
80896: LIST
80897: PUSH
80898: LD_INT 30
80900: PUSH
80901: LD_INT 1
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: EMPTY
80909: LIST
80910: LIST
80911: LIST
80912: PPUSH
80913: CALL_OW 72
80917: ST_TO_ADDR
// if depot then
80918: LD_VAR 0 6
80922: IFFALSE 81079
// begin selected := 0 ;
80924: LD_ADDR_VAR 0 7
80928: PUSH
80929: LD_INT 0
80931: ST_TO_ADDR
// for j in depot do
80932: LD_ADDR_VAR 0 3
80936: PUSH
80937: LD_VAR 0 6
80941: PUSH
80942: FOR_IN
80943: IFFALSE 80974
// begin if UnitsInside ( j ) < 6 then
80945: LD_VAR 0 3
80949: PPUSH
80950: CALL_OW 313
80954: PUSH
80955: LD_INT 6
80957: LESS
80958: IFFALSE 80972
// begin selected := j ;
80960: LD_ADDR_VAR 0 7
80964: PUSH
80965: LD_VAR 0 3
80969: ST_TO_ADDR
// break ;
80970: GO 80974
// end ; end ;
80972: GO 80942
80974: POP
80975: POP
// if selected then
80976: LD_VAR 0 7
80980: IFFALSE 81079
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80982: LD_ADDR_VAR 0 3
80986: PUSH
80987: LD_EXP 92
80991: PUSH
80992: LD_VAR 0 2
80996: ARRAY
80997: PPUSH
80998: LD_INT 25
81000: PUSH
81001: LD_INT 12
81003: PUSH
81004: EMPTY
81005: LIST
81006: LIST
81007: PPUSH
81008: CALL_OW 72
81012: PUSH
81013: FOR_IN
81014: IFFALSE 81077
// if not HasTask ( j ) then
81016: LD_VAR 0 3
81020: PPUSH
81021: CALL_OW 314
81025: NOT
81026: IFFALSE 81075
// begin if not IsInUnit ( j ) then
81028: LD_VAR 0 3
81032: PPUSH
81033: CALL_OW 310
81037: NOT
81038: IFFALSE 81054
// ComEnterUnit ( j , selected ) ;
81040: LD_VAR 0 3
81044: PPUSH
81045: LD_VAR 0 7
81049: PPUSH
81050: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
81054: LD_VAR 0 3
81058: PPUSH
81059: LD_INT 16
81061: PPUSH
81062: CALL_OW 183
// AddComExitBuilding ( j ) ;
81066: LD_VAR 0 3
81070: PPUSH
81071: CALL_OW 182
// end ;
81075: GO 81013
81077: POP
81078: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
81079: LD_VAR 0 5
81083: PPUSH
81084: LD_INT 11
81086: PPUSH
81087: CALL_OW 325
81091: IFFALSE 81354
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
81093: LD_ADDR_VAR 0 4
81097: PUSH
81098: LD_EXP 92
81102: PUSH
81103: LD_VAR 0 2
81107: ARRAY
81108: PPUSH
81109: LD_INT 25
81111: PUSH
81112: LD_INT 16
81114: PUSH
81115: EMPTY
81116: LIST
81117: LIST
81118: PPUSH
81119: CALL_OW 72
81123: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
81124: LD_VAR 0 4
81128: PUSH
81129: LD_INT 6
81131: GREATEREQUAL
81132: IFTRUE 81149
81134: PUSH
81135: LD_VAR 0 5
81139: PPUSH
81140: LD_INT 2
81142: PPUSH
81143: CALL_OW 325
81147: NOT
81148: OR
81149: IFFALSE 81354
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81151: LD_ADDR_VAR 0 8
81155: PUSH
81156: LD_EXP 63
81160: PUSH
81161: LD_VAR 0 2
81165: ARRAY
81166: PPUSH
81167: LD_INT 2
81169: PUSH
81170: LD_INT 30
81172: PUSH
81173: LD_INT 4
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 30
81182: PUSH
81183: LD_INT 5
81185: PUSH
81186: EMPTY
81187: LIST
81188: LIST
81189: PUSH
81190: EMPTY
81191: LIST
81192: LIST
81193: LIST
81194: PPUSH
81195: CALL_OW 72
81199: ST_TO_ADDR
// if barracks then
81200: LD_VAR 0 8
81204: IFFALSE 81354
// begin selected := 0 ;
81206: LD_ADDR_VAR 0 7
81210: PUSH
81211: LD_INT 0
81213: ST_TO_ADDR
// for j in barracks do
81214: LD_ADDR_VAR 0 3
81218: PUSH
81219: LD_VAR 0 8
81223: PUSH
81224: FOR_IN
81225: IFFALSE 81256
// begin if UnitsInside ( j ) < 6 then
81227: LD_VAR 0 3
81231: PPUSH
81232: CALL_OW 313
81236: PUSH
81237: LD_INT 6
81239: LESS
81240: IFFALSE 81254
// begin selected := j ;
81242: LD_ADDR_VAR 0 7
81246: PUSH
81247: LD_VAR 0 3
81251: ST_TO_ADDR
// break ;
81252: GO 81256
// end ; end ;
81254: GO 81224
81256: POP
81257: POP
// if selected then
81258: LD_VAR 0 7
81262: IFFALSE 81354
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
81264: LD_ADDR_VAR 0 3
81268: PUSH
81269: LD_EXP 92
81273: PUSH
81274: LD_VAR 0 2
81278: ARRAY
81279: PPUSH
81280: LD_INT 25
81282: PUSH
81283: LD_INT 12
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PPUSH
81290: CALL_OW 72
81294: PUSH
81295: FOR_IN
81296: IFFALSE 81352
// if not IsInUnit ( j ) and not HasTask ( j ) then
81298: LD_VAR 0 3
81302: PPUSH
81303: CALL_OW 310
81307: NOT
81308: IFFALSE 81322
81310: PUSH
81311: LD_VAR 0 3
81315: PPUSH
81316: CALL_OW 314
81320: NOT
81321: AND
81322: IFFALSE 81350
// begin ComEnterUnit ( j , selected ) ;
81324: LD_VAR 0 3
81328: PPUSH
81329: LD_VAR 0 7
81333: PPUSH
81334: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
81338: LD_VAR 0 3
81342: PPUSH
81343: LD_INT 15
81345: PPUSH
81346: CALL_OW 183
// end ;
81350: GO 81295
81352: POP
81353: POP
// end ; end ; end ; end ; end ;
81354: GO 80741
81356: POP
81357: POP
// end ;
81358: LD_VAR 0 1
81362: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
81363: LD_INT 0
81365: PPUSH
81366: PPUSH
81367: PPUSH
81368: PPUSH
// if not mc_bases then
81369: LD_EXP 63
81373: NOT
81374: IFFALSE 81378
// exit ;
81376: GO 81560
// for i = 1 to mc_bases do
81378: LD_ADDR_VAR 0 2
81382: PUSH
81383: DOUBLE
81384: LD_INT 1
81386: DEC
81387: ST_TO_ADDR
81388: LD_EXP 63
81392: PUSH
81393: FOR_TO
81394: IFFALSE 81558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
81396: LD_ADDR_VAR 0 4
81400: PUSH
81401: LD_EXP 63
81405: PUSH
81406: LD_VAR 0 2
81410: ARRAY
81411: PPUSH
81412: LD_INT 25
81414: PUSH
81415: LD_INT 9
81417: PUSH
81418: EMPTY
81419: LIST
81420: LIST
81421: PPUSH
81422: CALL_OW 72
81426: ST_TO_ADDR
// if not tmp then
81427: LD_VAR 0 4
81431: NOT
81432: IFFALSE 81436
// continue ;
81434: GO 81393
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
81436: LD_EXP 89
81440: PUSH
81441: LD_VAR 0 2
81445: ARRAY
81446: PPUSH
81447: LD_INT 29
81449: PPUSH
81450: CALL_OW 325
81454: NOT
81455: IFFALSE 81478
81457: PUSH
81458: LD_EXP 89
81462: PUSH
81463: LD_VAR 0 2
81467: ARRAY
81468: PPUSH
81469: LD_INT 28
81471: PPUSH
81472: CALL_OW 325
81476: NOT
81477: AND
81478: IFFALSE 81482
// continue ;
81480: GO 81393
// for j in tmp do
81482: LD_ADDR_VAR 0 3
81486: PUSH
81487: LD_VAR 0 4
81491: PUSH
81492: FOR_IN
81493: IFFALSE 81554
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
81495: LD_VAR 0 3
81499: PUSH
81500: LD_EXP 66
81504: PUSH
81505: LD_VAR 0 2
81509: ARRAY
81510: PUSH
81511: LD_INT 1
81513: ARRAY
81514: IN
81515: NOT
81516: IFFALSE 81541
81518: PUSH
81519: LD_VAR 0 3
81523: PUSH
81524: LD_EXP 66
81528: PUSH
81529: LD_VAR 0 2
81533: ARRAY
81534: PUSH
81535: LD_INT 2
81537: ARRAY
81538: IN
81539: NOT
81540: AND
81541: IFFALSE 81552
// ComSpaceTimeShoot ( j ) ;
81543: LD_VAR 0 3
81547: PPUSH
81548: CALL 18457 0 1
81552: GO 81492
81554: POP
81555: POP
// end ;
81556: GO 81393
81558: POP
81559: POP
// end ;
81560: LD_VAR 0 1
81564: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
81565: LD_INT 0
81567: PPUSH
81568: PPUSH
81569: PPUSH
81570: PPUSH
81571: PPUSH
81572: PPUSH
81573: PPUSH
81574: PPUSH
81575: PPUSH
// if not mc_bases then
81576: LD_EXP 63
81580: NOT
81581: IFFALSE 81585
// exit ;
81583: GO 82217
// for i = 1 to mc_bases do
81585: LD_ADDR_VAR 0 2
81589: PUSH
81590: DOUBLE
81591: LD_INT 1
81593: DEC
81594: ST_TO_ADDR
81595: LD_EXP 63
81599: PUSH
81600: FOR_TO
81601: IFFALSE 82215
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
81603: LD_EXP 98
81607: PUSH
81608: LD_VAR 0 2
81612: ARRAY
81613: NOT
81614: IFTRUE 81640
81616: PUSH
81617: LD_INT 38
81619: PPUSH
81620: LD_EXP 89
81624: PUSH
81625: LD_VAR 0 2
81629: ARRAY
81630: PPUSH
81631: CALL_OW 321
81635: PUSH
81636: LD_INT 2
81638: NONEQUAL
81639: OR
81640: IFFALSE 81644
// continue ;
81642: GO 81600
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
81644: LD_ADDR_VAR 0 8
81648: PUSH
81649: LD_EXP 63
81653: PUSH
81654: LD_VAR 0 2
81658: ARRAY
81659: PPUSH
81660: LD_INT 30
81662: PUSH
81663: LD_INT 34
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PPUSH
81670: CALL_OW 72
81674: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
81675: LD_ADDR_VAR 0 9
81679: PUSH
81680: LD_EXP 63
81684: PUSH
81685: LD_VAR 0 2
81689: ARRAY
81690: PPUSH
81691: LD_INT 25
81693: PUSH
81694: LD_INT 4
81696: PUSH
81697: EMPTY
81698: LIST
81699: LIST
81700: PPUSH
81701: CALL_OW 72
81705: PPUSH
81706: LD_INT 0
81708: PPUSH
81709: CALL 53099 0 2
81713: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
81714: LD_VAR 0 9
81718: NOT
81719: IFTRUE 81728
81721: PUSH
81722: LD_VAR 0 8
81726: NOT
81727: OR
81728: IFTRUE 81750
81730: PUSH
81731: LD_EXP 63
81735: PUSH
81736: LD_VAR 0 2
81740: ARRAY
81741: PPUSH
81742: LD_INT 124
81744: PPUSH
81745: CALL 53099 0 2
81749: OR
81750: IFFALSE 81754
// continue ;
81752: GO 81600
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
81754: LD_EXP 99
81758: PUSH
81759: LD_VAR 0 2
81763: ARRAY
81764: PUSH
81765: LD_EXP 98
81769: PUSH
81770: LD_VAR 0 2
81774: ARRAY
81775: LESS
81776: IFFALSE 81796
81778: PUSH
81779: LD_EXP 99
81783: PUSH
81784: LD_VAR 0 2
81788: ARRAY
81789: PUSH
81790: LD_VAR 0 8
81794: LESS
81795: AND
81796: IFFALSE 82213
// begin tmp := sci [ 1 ] ;
81798: LD_ADDR_VAR 0 7
81802: PUSH
81803: LD_VAR 0 9
81807: PUSH
81808: LD_INT 1
81810: ARRAY
81811: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
81812: LD_VAR 0 7
81816: PPUSH
81817: LD_INT 124
81819: PPUSH
81820: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
81824: LD_ADDR_VAR 0 3
81828: PUSH
81829: DOUBLE
81830: LD_EXP 98
81834: PUSH
81835: LD_VAR 0 2
81839: ARRAY
81840: INC
81841: ST_TO_ADDR
81842: LD_EXP 98
81846: PUSH
81847: LD_VAR 0 2
81851: ARRAY
81852: PUSH
81853: FOR_DOWNTO
81854: IFFALSE 82199
// begin if IsInUnit ( tmp ) then
81856: LD_VAR 0 7
81860: PPUSH
81861: CALL_OW 310
81865: IFFALSE 81876
// ComExitBuilding ( tmp ) ;
81867: LD_VAR 0 7
81871: PPUSH
81872: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
81876: LD_INT 35
81878: PPUSH
81879: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
81883: LD_VAR 0 7
81887: PPUSH
81888: CALL_OW 310
81892: NOT
81893: IFFALSE 81907
81895: PUSH
81896: LD_VAR 0 7
81900: PPUSH
81901: CALL_OW 314
81905: NOT
81906: AND
81907: IFFALSE 81876
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
81909: LD_ADDR_VAR 0 6
81913: PUSH
81914: LD_VAR 0 7
81918: PPUSH
81919: CALL_OW 250
81923: PUSH
81924: LD_VAR 0 7
81928: PPUSH
81929: CALL_OW 251
81933: PUSH
81934: EMPTY
81935: LIST
81936: LIST
81937: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
81938: LD_INT 35
81940: PPUSH
81941: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
81945: LD_ADDR_VAR 0 4
81949: PUSH
81950: LD_EXP 98
81954: PUSH
81955: LD_VAR 0 2
81959: ARRAY
81960: PUSH
81961: LD_VAR 0 3
81965: ARRAY
81966: PUSH
81967: LD_INT 1
81969: ARRAY
81970: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
81971: LD_ADDR_VAR 0 5
81975: PUSH
81976: LD_EXP 98
81980: PUSH
81981: LD_VAR 0 2
81985: ARRAY
81986: PUSH
81987: LD_VAR 0 3
81991: ARRAY
81992: PUSH
81993: LD_INT 2
81995: ARRAY
81996: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
81997: LD_VAR 0 7
82001: PPUSH
82002: LD_INT 10
82004: PPUSH
82005: CALL 25485 0 2
82009: PUSH
82010: LD_INT 4
82012: ARRAY
82013: IFFALSE 82051
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
82015: LD_VAR 0 7
82019: PPUSH
82020: LD_VAR 0 6
82024: PUSH
82025: LD_INT 1
82027: ARRAY
82028: PPUSH
82029: LD_VAR 0 6
82033: PUSH
82034: LD_INT 2
82036: ARRAY
82037: PPUSH
82038: CALL_OW 111
// wait ( 0 0$10 ) ;
82042: LD_INT 350
82044: PPUSH
82045: CALL_OW 67
// end else
82049: GO 82077
// begin ComMoveXY ( tmp , x , y ) ;
82051: LD_VAR 0 7
82055: PPUSH
82056: LD_VAR 0 4
82060: PPUSH
82061: LD_VAR 0 5
82065: PPUSH
82066: CALL_OW 111
// wait ( 0 0$3 ) ;
82070: LD_INT 105
82072: PPUSH
82073: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
82077: LD_VAR 0 7
82081: PPUSH
82082: LD_VAR 0 4
82086: PPUSH
82087: LD_VAR 0 5
82091: PPUSH
82092: CALL_OW 307
82096: IFFALSE 81938
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
82098: LD_VAR 0 7
82102: PPUSH
82103: LD_VAR 0 4
82107: PPUSH
82108: LD_VAR 0 5
82112: PPUSH
82113: LD_VAR 0 8
82117: PUSH
82118: LD_VAR 0 3
82122: ARRAY
82123: PPUSH
82124: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
82128: LD_INT 35
82130: PPUSH
82131: CALL_OW 67
// until not HasTask ( tmp ) ;
82135: LD_VAR 0 7
82139: PPUSH
82140: CALL_OW 314
82144: NOT
82145: IFFALSE 82128
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
82147: LD_ADDR_EXP 99
82151: PUSH
82152: LD_EXP 99
82156: PPUSH
82157: LD_VAR 0 2
82161: PUSH
82162: LD_EXP 99
82166: PUSH
82167: LD_VAR 0 2
82171: ARRAY
82172: PUSH
82173: LD_INT 1
82175: PLUS
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: PPUSH
82181: LD_VAR 0 8
82185: PUSH
82186: LD_VAR 0 3
82190: ARRAY
82191: PPUSH
82192: CALL 22506 0 3
82196: ST_TO_ADDR
// end ;
82197: GO 81853
82199: POP
82200: POP
// MC_Reset ( i , 124 ) ;
82201: LD_VAR 0 2
82205: PPUSH
82206: LD_INT 124
82208: PPUSH
82209: CALL 65077 0 2
// end ; end ;
82213: GO 81600
82215: POP
82216: POP
// end ;
82217: LD_VAR 0 1
82221: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
82222: LD_INT 0
82224: PPUSH
82225: PPUSH
82226: PPUSH
// if not mc_bases then
82227: LD_EXP 63
82231: NOT
82232: IFFALSE 82236
// exit ;
82234: GO 82850
// for i = 1 to mc_bases do
82236: LD_ADDR_VAR 0 2
82240: PUSH
82241: DOUBLE
82242: LD_INT 1
82244: DEC
82245: ST_TO_ADDR
82246: LD_EXP 63
82250: PUSH
82251: FOR_TO
82252: IFFALSE 82848
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
82254: LD_ADDR_VAR 0 3
82258: PUSH
82259: LD_EXP 63
82263: PUSH
82264: LD_VAR 0 2
82268: ARRAY
82269: PPUSH
82270: LD_INT 25
82272: PUSH
82273: LD_INT 4
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PPUSH
82280: CALL_OW 72
82284: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82285: LD_VAR 0 3
82289: NOT
82290: IFTRUE 82305
82292: PUSH
82293: LD_EXP 100
82297: PUSH
82298: LD_VAR 0 2
82302: ARRAY
82303: NOT
82304: OR
82305: IFTRUE 82353
82307: PUSH
82308: LD_EXP 63
82312: PUSH
82313: LD_VAR 0 2
82317: ARRAY
82318: PPUSH
82319: LD_INT 2
82321: PUSH
82322: LD_INT 30
82324: PUSH
82325: LD_INT 0
82327: PUSH
82328: EMPTY
82329: LIST
82330: LIST
82331: PUSH
82332: LD_INT 30
82334: PUSH
82335: LD_INT 1
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: EMPTY
82343: LIST
82344: LIST
82345: LIST
82346: PPUSH
82347: CALL_OW 72
82351: NOT
82352: OR
82353: IFFALSE 82403
// begin if mc_deposits_finder [ i ] then
82355: LD_EXP 101
82359: PUSH
82360: LD_VAR 0 2
82364: ARRAY
82365: IFFALSE 82401
// begin MC_Reset ( i , 125 ) ;
82367: LD_VAR 0 2
82371: PPUSH
82372: LD_INT 125
82374: PPUSH
82375: CALL 65077 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82379: LD_ADDR_EXP 101
82383: PUSH
82384: LD_EXP 101
82388: PPUSH
82389: LD_VAR 0 2
82393: PPUSH
82394: EMPTY
82395: PPUSH
82396: CALL_OW 1
82400: ST_TO_ADDR
// end ; continue ;
82401: GO 82251
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
82403: LD_EXP 100
82407: PUSH
82408: LD_VAR 0 2
82412: ARRAY
82413: PUSH
82414: LD_INT 1
82416: ARRAY
82417: PUSH
82418: LD_INT 3
82420: ARRAY
82421: PUSH
82422: LD_INT 1
82424: EQUAL
82425: IFFALSE 82451
82427: PUSH
82428: LD_INT 20
82430: PPUSH
82431: LD_EXP 89
82435: PUSH
82436: LD_VAR 0 2
82440: ARRAY
82441: PPUSH
82442: CALL_OW 321
82446: PUSH
82447: LD_INT 2
82449: NONEQUAL
82450: AND
82451: IFFALSE 82501
// begin if mc_deposits_finder [ i ] then
82453: LD_EXP 101
82457: PUSH
82458: LD_VAR 0 2
82462: ARRAY
82463: IFFALSE 82499
// begin MC_Reset ( i , 125 ) ;
82465: LD_VAR 0 2
82469: PPUSH
82470: LD_INT 125
82472: PPUSH
82473: CALL 65077 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
82477: LD_ADDR_EXP 101
82481: PUSH
82482: LD_EXP 101
82486: PPUSH
82487: LD_VAR 0 2
82491: PPUSH
82492: EMPTY
82493: PPUSH
82494: CALL_OW 1
82498: ST_TO_ADDR
// end ; continue ;
82499: GO 82251
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
82501: LD_EXP 100
82505: PUSH
82506: LD_VAR 0 2
82510: ARRAY
82511: PUSH
82512: LD_INT 1
82514: ARRAY
82515: PUSH
82516: LD_INT 1
82518: ARRAY
82519: PPUSH
82520: LD_EXP 100
82524: PUSH
82525: LD_VAR 0 2
82529: ARRAY
82530: PUSH
82531: LD_INT 1
82533: ARRAY
82534: PUSH
82535: LD_INT 2
82537: ARRAY
82538: PPUSH
82539: LD_EXP 89
82543: PUSH
82544: LD_VAR 0 2
82548: ARRAY
82549: PPUSH
82550: CALL_OW 440
82554: IFFALSE 82597
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
82556: LD_ADDR_EXP 100
82560: PUSH
82561: LD_EXP 100
82565: PPUSH
82566: LD_VAR 0 2
82570: PPUSH
82571: LD_EXP 100
82575: PUSH
82576: LD_VAR 0 2
82580: ARRAY
82581: PPUSH
82582: LD_INT 1
82584: PPUSH
82585: CALL_OW 3
82589: PPUSH
82590: CALL_OW 1
82594: ST_TO_ADDR
82595: GO 82846
// begin if not mc_deposits_finder [ i ] then
82597: LD_EXP 101
82601: PUSH
82602: LD_VAR 0 2
82606: ARRAY
82607: NOT
82608: IFFALSE 82660
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
82610: LD_ADDR_EXP 101
82614: PUSH
82615: LD_EXP 101
82619: PPUSH
82620: LD_VAR 0 2
82624: PPUSH
82625: LD_VAR 0 3
82629: PUSH
82630: LD_INT 1
82632: ARRAY
82633: PUSH
82634: EMPTY
82635: LIST
82636: PPUSH
82637: CALL_OW 1
82641: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
82642: LD_VAR 0 3
82646: PUSH
82647: LD_INT 1
82649: ARRAY
82650: PPUSH
82651: LD_INT 125
82653: PPUSH
82654: CALL_OW 109
// end else
82658: GO 82846
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
82660: LD_EXP 101
82664: PUSH
82665: LD_VAR 0 2
82669: ARRAY
82670: PUSH
82671: LD_INT 1
82673: ARRAY
82674: PPUSH
82675: CALL_OW 310
82679: IFFALSE 82702
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
82681: LD_EXP 101
82685: PUSH
82686: LD_VAR 0 2
82690: ARRAY
82691: PUSH
82692: LD_INT 1
82694: ARRAY
82695: PPUSH
82696: CALL_OW 122
82700: GO 82846
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
82702: LD_EXP 101
82706: PUSH
82707: LD_VAR 0 2
82711: ARRAY
82712: PUSH
82713: LD_INT 1
82715: ARRAY
82716: PPUSH
82717: CALL_OW 314
82721: NOT
82722: IFFALSE 82787
82724: PUSH
82725: LD_EXP 101
82729: PUSH
82730: LD_VAR 0 2
82734: ARRAY
82735: PUSH
82736: LD_INT 1
82738: ARRAY
82739: PPUSH
82740: LD_EXP 100
82744: PUSH
82745: LD_VAR 0 2
82749: ARRAY
82750: PUSH
82751: LD_INT 1
82753: ARRAY
82754: PUSH
82755: LD_INT 1
82757: ARRAY
82758: PPUSH
82759: LD_EXP 100
82763: PUSH
82764: LD_VAR 0 2
82768: ARRAY
82769: PUSH
82770: LD_INT 1
82772: ARRAY
82773: PUSH
82774: LD_INT 2
82776: ARRAY
82777: PPUSH
82778: CALL_OW 297
82782: PUSH
82783: LD_INT 6
82785: GREATER
82786: AND
82787: IFFALSE 82846
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
82789: LD_EXP 101
82793: PUSH
82794: LD_VAR 0 2
82798: ARRAY
82799: PUSH
82800: LD_INT 1
82802: ARRAY
82803: PPUSH
82804: LD_EXP 100
82808: PUSH
82809: LD_VAR 0 2
82813: ARRAY
82814: PUSH
82815: LD_INT 1
82817: ARRAY
82818: PUSH
82819: LD_INT 1
82821: ARRAY
82822: PPUSH
82823: LD_EXP 100
82827: PUSH
82828: LD_VAR 0 2
82832: ARRAY
82833: PUSH
82834: LD_INT 1
82836: ARRAY
82837: PUSH
82838: LD_INT 2
82840: ARRAY
82841: PPUSH
82842: CALL_OW 111
// end ; end ; end ;
82846: GO 82251
82848: POP
82849: POP
// end ;
82850: LD_VAR 0 1
82854: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
82855: LD_INT 0
82857: PPUSH
82858: PPUSH
82859: PPUSH
82860: PPUSH
82861: PPUSH
82862: PPUSH
82863: PPUSH
82864: PPUSH
82865: PPUSH
82866: PPUSH
82867: PPUSH
// if not mc_bases then
82868: LD_EXP 63
82872: NOT
82873: IFFALSE 82877
// exit ;
82875: GO 83837
// for i = 1 to mc_bases do
82877: LD_ADDR_VAR 0 2
82881: PUSH
82882: DOUBLE
82883: LD_INT 1
82885: DEC
82886: ST_TO_ADDR
82887: LD_EXP 63
82891: PUSH
82892: FOR_TO
82893: IFFALSE 83835
// begin if not mc_bases [ i ] or mc_scan [ i ] then
82895: LD_EXP 63
82899: PUSH
82900: LD_VAR 0 2
82904: ARRAY
82905: NOT
82906: IFTRUE 82920
82908: PUSH
82909: LD_EXP 86
82913: PUSH
82914: LD_VAR 0 2
82918: ARRAY
82919: OR
82920: IFFALSE 82924
// continue ;
82922: GO 82892
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
82924: LD_ADDR_VAR 0 7
82928: PUSH
82929: LD_EXP 63
82933: PUSH
82934: LD_VAR 0 2
82938: ARRAY
82939: PUSH
82940: LD_INT 1
82942: ARRAY
82943: PPUSH
82944: CALL_OW 248
82948: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
82949: LD_VAR 0 7
82953: PUSH
82954: LD_INT 3
82956: EQUAL
82957: IFTRUE 82999
82959: PUSH
82960: LD_EXP 82
82964: PUSH
82965: LD_VAR 0 2
82969: ARRAY
82970: PUSH
82971: LD_EXP 85
82975: PUSH
82976: LD_VAR 0 2
82980: ARRAY
82981: UNION
82982: PPUSH
82983: LD_INT 33
82985: PUSH
82986: LD_INT 2
82988: PUSH
82989: EMPTY
82990: LIST
82991: LIST
82992: PPUSH
82993: CALL_OW 72
82997: NOT
82998: OR
82999: IFFALSE 83003
// continue ;
83001: GO 82892
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
83003: LD_ADDR_VAR 0 9
83007: PUSH
83008: LD_EXP 63
83012: PUSH
83013: LD_VAR 0 2
83017: ARRAY
83018: PPUSH
83019: LD_INT 30
83021: PUSH
83022: LD_INT 36
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PPUSH
83029: CALL_OW 72
83033: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
83034: LD_ADDR_VAR 0 10
83038: PUSH
83039: LD_EXP 82
83043: PUSH
83044: LD_VAR 0 2
83048: ARRAY
83049: PPUSH
83050: LD_INT 34
83052: PUSH
83053: LD_INT 31
83055: PUSH
83056: EMPTY
83057: LIST
83058: LIST
83059: PPUSH
83060: CALL_OW 72
83064: ST_TO_ADDR
// if not cts and not mcts then
83065: LD_VAR 0 9
83069: NOT
83070: IFFALSE 83079
83072: PUSH
83073: LD_VAR 0 10
83077: NOT
83078: AND
83079: IFFALSE 83083
// continue ;
83081: GO 82892
// x := cts ;
83083: LD_ADDR_VAR 0 11
83087: PUSH
83088: LD_VAR 0 9
83092: ST_TO_ADDR
// if not x then
83093: LD_VAR 0 11
83097: NOT
83098: IFFALSE 83110
// x := mcts ;
83100: LD_ADDR_VAR 0 11
83104: PUSH
83105: LD_VAR 0 10
83109: ST_TO_ADDR
// if not x then
83110: LD_VAR 0 11
83114: NOT
83115: IFFALSE 83119
// continue ;
83117: GO 82892
// if mc_remote_driver [ i ] then
83119: LD_EXP 103
83123: PUSH
83124: LD_VAR 0 2
83128: ARRAY
83129: IFFALSE 83528
// for j in mc_remote_driver [ i ] do
83131: LD_ADDR_VAR 0 3
83135: PUSH
83136: LD_EXP 103
83140: PUSH
83141: LD_VAR 0 2
83145: ARRAY
83146: PUSH
83147: FOR_IN
83148: IFFALSE 83526
// begin if GetClass ( j ) <> 3 then
83150: LD_VAR 0 3
83154: PPUSH
83155: CALL_OW 257
83159: PUSH
83160: LD_INT 3
83162: NONEQUAL
83163: IFFALSE 83216
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
83165: LD_ADDR_EXP 103
83169: PUSH
83170: LD_EXP 103
83174: PPUSH
83175: LD_VAR 0 2
83179: PPUSH
83180: LD_EXP 103
83184: PUSH
83185: LD_VAR 0 2
83189: ARRAY
83190: PUSH
83191: LD_VAR 0 3
83195: DIFF
83196: PPUSH
83197: CALL_OW 1
83201: ST_TO_ADDR
// SetTag ( j , 0 ) ;
83202: LD_VAR 0 3
83206: PPUSH
83207: LD_INT 0
83209: PPUSH
83210: CALL_OW 109
// continue ;
83214: GO 83147
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
83216: LD_EXP 82
83220: PUSH
83221: LD_VAR 0 2
83225: ARRAY
83226: PPUSH
83227: LD_INT 34
83229: PUSH
83230: LD_INT 31
83232: PUSH
83233: EMPTY
83234: LIST
83235: LIST
83236: PUSH
83237: LD_INT 58
83239: PUSH
83240: EMPTY
83241: LIST
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: PPUSH
83247: CALL_OW 72
83251: IFFALSE 83265
83253: PUSH
83254: LD_VAR 0 3
83258: PPUSH
83259: CALL 53134 0 1
83263: NOT
83264: AND
83265: IFFALSE 83336
// begin if IsInUnit ( j ) then
83267: LD_VAR 0 3
83271: PPUSH
83272: CALL_OW 310
83276: IFFALSE 83287
// ComExitBuilding ( j ) ;
83278: LD_VAR 0 3
83282: PPUSH
83283: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
83287: LD_VAR 0 3
83291: PPUSH
83292: LD_EXP 82
83296: PUSH
83297: LD_VAR 0 2
83301: ARRAY
83302: PPUSH
83303: LD_INT 34
83305: PUSH
83306: LD_INT 31
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 58
83315: PUSH
83316: EMPTY
83317: LIST
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PPUSH
83323: CALL_OW 72
83327: PUSH
83328: LD_INT 1
83330: ARRAY
83331: PPUSH
83332: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
83336: LD_VAR 0 3
83340: PPUSH
83341: CALL_OW 310
83345: NOT
83346: IFTRUE 83382
83348: PUSH
83349: LD_VAR 0 3
83353: PPUSH
83354: CALL_OW 310
83358: PPUSH
83359: CALL_OW 266
83363: PUSH
83364: LD_INT 36
83366: NONEQUAL
83367: IFFALSE 83381
83369: PUSH
83370: LD_VAR 0 3
83374: PPUSH
83375: CALL 53134 0 1
83379: NOT
83380: AND
83381: OR
83382: IFFALSE 83524
// begin if IsInUnit ( j ) then
83384: LD_VAR 0 3
83388: PPUSH
83389: CALL_OW 310
83393: IFFALSE 83404
// ComExitBuilding ( j ) ;
83395: LD_VAR 0 3
83399: PPUSH
83400: CALL_OW 122
// ct := 0 ;
83404: LD_ADDR_VAR 0 8
83408: PUSH
83409: LD_INT 0
83411: ST_TO_ADDR
// for k in x do
83412: LD_ADDR_VAR 0 4
83416: PUSH
83417: LD_VAR 0 11
83421: PUSH
83422: FOR_IN
83423: IFFALSE 83502
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
83425: LD_VAR 0 4
83429: PPUSH
83430: CALL_OW 264
83434: PUSH
83435: LD_INT 31
83437: EQUAL
83438: IFFALSE 83452
83440: PUSH
83441: LD_VAR 0 4
83445: PPUSH
83446: CALL_OW 311
83450: NOT
83451: AND
83452: IFTRUE 83486
83454: PUSH
83455: LD_VAR 0 4
83459: PPUSH
83460: CALL_OW 266
83464: PUSH
83465: LD_INT 36
83467: EQUAL
83468: IFFALSE 83485
83470: PUSH
83471: LD_VAR 0 4
83475: PPUSH
83476: CALL_OW 313
83480: PUSH
83481: LD_INT 3
83483: LESS
83484: AND
83485: OR
83486: IFFALSE 83500
// begin ct := k ;
83488: LD_ADDR_VAR 0 8
83492: PUSH
83493: LD_VAR 0 4
83497: ST_TO_ADDR
// break ;
83498: GO 83502
// end ;
83500: GO 83422
83502: POP
83503: POP
// if ct then
83504: LD_VAR 0 8
83508: IFFALSE 83524
// ComEnterUnit ( j , ct ) ;
83510: LD_VAR 0 3
83514: PPUSH
83515: LD_VAR 0 8
83519: PPUSH
83520: CALL_OW 120
// end ; end ;
83524: GO 83147
83526: POP
83527: POP
// places := 0 ;
83528: LD_ADDR_VAR 0 5
83532: PUSH
83533: LD_INT 0
83535: ST_TO_ADDR
// for j = 1 to x do
83536: LD_ADDR_VAR 0 3
83540: PUSH
83541: DOUBLE
83542: LD_INT 1
83544: DEC
83545: ST_TO_ADDR
83546: LD_VAR 0 11
83550: PUSH
83551: FOR_TO
83552: IFFALSE 83628
// if GetWeapon ( x [ j ] ) = ar_control_tower then
83554: LD_VAR 0 11
83558: PUSH
83559: LD_VAR 0 3
83563: ARRAY
83564: PPUSH
83565: CALL_OW 264
83569: PUSH
83570: LD_INT 31
83572: EQUAL
83573: IFFALSE 83591
// places := places + 1 else
83575: LD_ADDR_VAR 0 5
83579: PUSH
83580: LD_VAR 0 5
83584: PUSH
83585: LD_INT 1
83587: PLUS
83588: ST_TO_ADDR
83589: GO 83626
// if GetBType ( x [ j ] ) = b_control_tower then
83591: LD_VAR 0 11
83595: PUSH
83596: LD_VAR 0 3
83600: ARRAY
83601: PPUSH
83602: CALL_OW 266
83606: PUSH
83607: LD_INT 36
83609: EQUAL
83610: IFFALSE 83626
// places := places + 3 ;
83612: LD_ADDR_VAR 0 5
83616: PUSH
83617: LD_VAR 0 5
83621: PUSH
83622: LD_INT 3
83624: PLUS
83625: ST_TO_ADDR
83626: GO 83551
83628: POP
83629: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
83630: LD_VAR 0 5
83634: PUSH
83635: LD_INT 0
83637: EQUAL
83638: IFTRUE 83658
83640: PUSH
83641: LD_VAR 0 5
83645: PUSH
83646: LD_EXP 103
83650: PUSH
83651: LD_VAR 0 2
83655: ARRAY
83656: LESSEQUAL
83657: OR
83658: IFFALSE 83662
// continue ;
83660: GO 82892
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
83662: LD_ADDR_VAR 0 6
83666: PUSH
83667: LD_EXP 63
83671: PUSH
83672: LD_VAR 0 2
83676: ARRAY
83677: PPUSH
83678: LD_INT 25
83680: PUSH
83681: LD_INT 3
83683: PUSH
83684: EMPTY
83685: LIST
83686: LIST
83687: PPUSH
83688: CALL_OW 72
83692: PUSH
83693: LD_EXP 103
83697: PUSH
83698: LD_VAR 0 2
83702: ARRAY
83703: DIFF
83704: PPUSH
83705: LD_INT 3
83707: PPUSH
83708: CALL 54034 0 2
83712: ST_TO_ADDR
// for j in tmp do
83713: LD_ADDR_VAR 0 3
83717: PUSH
83718: LD_VAR 0 6
83722: PUSH
83723: FOR_IN
83724: IFFALSE 83759
// if GetTag ( j ) > 0 then
83726: LD_VAR 0 3
83730: PPUSH
83731: CALL_OW 110
83735: PUSH
83736: LD_INT 0
83738: GREATER
83739: IFFALSE 83757
// tmp := tmp diff j ;
83741: LD_ADDR_VAR 0 6
83745: PUSH
83746: LD_VAR 0 6
83750: PUSH
83751: LD_VAR 0 3
83755: DIFF
83756: ST_TO_ADDR
83757: GO 83723
83759: POP
83760: POP
// if not tmp then
83761: LD_VAR 0 6
83765: NOT
83766: IFFALSE 83770
// continue ;
83768: GO 82892
// if places then
83770: LD_VAR 0 5
83774: IFFALSE 83833
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
83776: LD_ADDR_EXP 103
83780: PUSH
83781: LD_EXP 103
83785: PPUSH
83786: LD_VAR 0 2
83790: PPUSH
83791: LD_EXP 103
83795: PUSH
83796: LD_VAR 0 2
83800: ARRAY
83801: PUSH
83802: LD_VAR 0 6
83806: PUSH
83807: LD_INT 1
83809: ARRAY
83810: UNION
83811: PPUSH
83812: CALL_OW 1
83816: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
83817: LD_VAR 0 6
83821: PUSH
83822: LD_INT 1
83824: ARRAY
83825: PPUSH
83826: LD_INT 126
83828: PPUSH
83829: CALL_OW 109
// end ; end ;
83833: GO 82892
83835: POP
83836: POP
// end ;
83837: LD_VAR 0 1
83841: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
83842: LD_INT 0
83844: PPUSH
83845: PPUSH
83846: PPUSH
83847: PPUSH
83848: PPUSH
83849: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
83850: LD_VAR 0 1
83854: NOT
83855: IFTRUE 83864
83857: PUSH
83858: LD_VAR 0 2
83862: NOT
83863: OR
83864: IFTRUE 83873
83866: PUSH
83867: LD_VAR 0 3
83871: NOT
83872: OR
83873: IFTRUE 83921
83875: PUSH
83876: LD_VAR 0 4
83880: PUSH
83881: LD_INT 1
83883: PUSH
83884: LD_INT 2
83886: PUSH
83887: LD_INT 3
83889: PUSH
83890: LD_INT 4
83892: PUSH
83893: LD_INT 5
83895: PUSH
83896: LD_INT 8
83898: PUSH
83899: LD_INT 9
83901: PUSH
83902: LD_INT 15
83904: PUSH
83905: LD_INT 16
83907: PUSH
83908: EMPTY
83909: LIST
83910: LIST
83911: LIST
83912: LIST
83913: LIST
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: IN
83919: NOT
83920: OR
83921: IFFALSE 83925
// exit ;
83923: GO 84785
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
83925: LD_ADDR_VAR 0 2
83929: PUSH
83930: LD_VAR 0 2
83934: PPUSH
83935: LD_INT 21
83937: PUSH
83938: LD_INT 3
83940: PUSH
83941: EMPTY
83942: LIST
83943: LIST
83944: PUSH
83945: LD_INT 24
83947: PUSH
83948: LD_INT 250
83950: PUSH
83951: EMPTY
83952: LIST
83953: LIST
83954: PUSH
83955: EMPTY
83956: LIST
83957: LIST
83958: PPUSH
83959: CALL_OW 72
83963: ST_TO_ADDR
// case class of 1 , 15 :
83964: LD_VAR 0 4
83968: PUSH
83969: LD_INT 1
83971: DOUBLE
83972: EQUAL
83973: IFTRUE 83983
83975: LD_INT 15
83977: DOUBLE
83978: EQUAL
83979: IFTRUE 83983
83981: GO 84068
83983: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
83984: LD_ADDR_VAR 0 8
83988: PUSH
83989: LD_VAR 0 2
83993: PPUSH
83994: LD_INT 2
83996: PUSH
83997: LD_INT 30
83999: PUSH
84000: LD_INT 32
84002: PUSH
84003: EMPTY
84004: LIST
84005: LIST
84006: PUSH
84007: LD_INT 30
84009: PUSH
84010: LD_INT 31
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: LIST
84021: PPUSH
84022: CALL_OW 72
84026: PUSH
84027: LD_VAR 0 2
84031: PPUSH
84032: LD_INT 2
84034: PUSH
84035: LD_INT 30
84037: PUSH
84038: LD_INT 4
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 30
84047: PUSH
84048: LD_INT 5
84050: PUSH
84051: EMPTY
84052: LIST
84053: LIST
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: LIST
84059: PPUSH
84060: CALL_OW 72
84064: ADD
84065: ST_TO_ADDR
84066: GO 84314
84068: LD_INT 2
84070: DOUBLE
84071: EQUAL
84072: IFTRUE 84082
84074: LD_INT 16
84076: DOUBLE
84077: EQUAL
84078: IFTRUE 84082
84080: GO 84128
84082: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
84083: LD_ADDR_VAR 0 8
84087: PUSH
84088: LD_VAR 0 2
84092: PPUSH
84093: LD_INT 2
84095: PUSH
84096: LD_INT 30
84098: PUSH
84099: LD_INT 0
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: LD_INT 30
84108: PUSH
84109: LD_INT 1
84111: PUSH
84112: EMPTY
84113: LIST
84114: LIST
84115: PUSH
84116: EMPTY
84117: LIST
84118: LIST
84119: LIST
84120: PPUSH
84121: CALL_OW 72
84125: ST_TO_ADDR
84126: GO 84314
84128: LD_INT 3
84130: DOUBLE
84131: EQUAL
84132: IFTRUE 84136
84134: GO 84182
84136: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
84137: LD_ADDR_VAR 0 8
84141: PUSH
84142: LD_VAR 0 2
84146: PPUSH
84147: LD_INT 2
84149: PUSH
84150: LD_INT 30
84152: PUSH
84153: LD_INT 2
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 30
84162: PUSH
84163: LD_INT 3
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: EMPTY
84171: LIST
84172: LIST
84173: LIST
84174: PPUSH
84175: CALL_OW 72
84179: ST_TO_ADDR
84180: GO 84314
84182: LD_INT 4
84184: DOUBLE
84185: EQUAL
84186: IFTRUE 84190
84188: GO 84247
84190: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
84191: LD_ADDR_VAR 0 8
84195: PUSH
84196: LD_VAR 0 2
84200: PPUSH
84201: LD_INT 2
84203: PUSH
84204: LD_INT 30
84206: PUSH
84207: LD_INT 6
84209: PUSH
84210: EMPTY
84211: LIST
84212: LIST
84213: PUSH
84214: LD_INT 30
84216: PUSH
84217: LD_INT 7
84219: PUSH
84220: EMPTY
84221: LIST
84222: LIST
84223: PUSH
84224: LD_INT 30
84226: PUSH
84227: LD_INT 8
84229: PUSH
84230: EMPTY
84231: LIST
84232: LIST
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: LIST
84238: LIST
84239: PPUSH
84240: CALL_OW 72
84244: ST_TO_ADDR
84245: GO 84314
84247: LD_INT 5
84249: DOUBLE
84250: EQUAL
84251: IFTRUE 84267
84253: LD_INT 8
84255: DOUBLE
84256: EQUAL
84257: IFTRUE 84267
84259: LD_INT 9
84261: DOUBLE
84262: EQUAL
84263: IFTRUE 84267
84265: GO 84313
84267: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
84268: LD_ADDR_VAR 0 8
84272: PUSH
84273: LD_VAR 0 2
84277: PPUSH
84278: LD_INT 2
84280: PUSH
84281: LD_INT 30
84283: PUSH
84284: LD_INT 4
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 30
84293: PUSH
84294: LD_INT 5
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: EMPTY
84302: LIST
84303: LIST
84304: LIST
84305: PPUSH
84306: CALL_OW 72
84310: ST_TO_ADDR
84311: GO 84314
84313: POP
// if not tmp then
84314: LD_VAR 0 8
84318: NOT
84319: IFFALSE 84323
// exit ;
84321: GO 84785
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
84323: LD_VAR 0 4
84327: PUSH
84328: LD_INT 1
84330: PUSH
84331: LD_INT 15
84333: PUSH
84334: EMPTY
84335: LIST
84336: LIST
84337: IN
84338: IFFALSE 84352
84340: PUSH
84341: LD_EXP 72
84345: PUSH
84346: LD_VAR 0 1
84350: ARRAY
84351: AND
84352: IFFALSE 84508
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
84354: LD_ADDR_VAR 0 9
84358: PUSH
84359: LD_EXP 72
84363: PUSH
84364: LD_VAR 0 1
84368: ARRAY
84369: PUSH
84370: LD_INT 1
84372: ARRAY
84373: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
84374: LD_VAR 0 9
84378: PUSH
84379: LD_EXP 73
84383: PUSH
84384: LD_VAR 0 1
84388: ARRAY
84389: IN
84390: NOT
84391: IFFALSE 84506
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
84393: LD_ADDR_EXP 73
84397: PUSH
84398: LD_EXP 73
84402: PPUSH
84403: LD_VAR 0 1
84407: PUSH
84408: LD_EXP 73
84412: PUSH
84413: LD_VAR 0 1
84417: ARRAY
84418: PUSH
84419: LD_INT 1
84421: PLUS
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PPUSH
84427: LD_VAR 0 9
84431: PPUSH
84432: CALL 22506 0 3
84436: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
84437: LD_ADDR_EXP 72
84441: PUSH
84442: LD_EXP 72
84446: PPUSH
84447: LD_VAR 0 1
84451: PPUSH
84452: LD_EXP 72
84456: PUSH
84457: LD_VAR 0 1
84461: ARRAY
84462: PUSH
84463: LD_VAR 0 9
84467: DIFF
84468: PPUSH
84469: CALL_OW 1
84473: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
84474: LD_VAR 0 3
84478: PPUSH
84479: LD_EXP 73
84483: PUSH
84484: LD_VAR 0 1
84488: ARRAY
84489: PUSH
84490: LD_EXP 73
84494: PUSH
84495: LD_VAR 0 1
84499: ARRAY
84500: ARRAY
84501: PPUSH
84502: CALL_OW 120
// end ; exit ;
84506: GO 84785
// end ; if tmp > 1 then
84508: LD_VAR 0 8
84512: PUSH
84513: LD_INT 1
84515: GREATER
84516: IFFALSE 84620
// for i = 2 to tmp do
84518: LD_ADDR_VAR 0 6
84522: PUSH
84523: DOUBLE
84524: LD_INT 2
84526: DEC
84527: ST_TO_ADDR
84528: LD_VAR 0 8
84532: PUSH
84533: FOR_TO
84534: IFFALSE 84618
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
84536: LD_VAR 0 8
84540: PUSH
84541: LD_VAR 0 6
84545: ARRAY
84546: PPUSH
84547: CALL_OW 461
84551: PUSH
84552: LD_INT 6
84554: EQUAL
84555: IFFALSE 84616
// begin x := tmp [ i ] ;
84557: LD_ADDR_VAR 0 9
84561: PUSH
84562: LD_VAR 0 8
84566: PUSH
84567: LD_VAR 0 6
84571: ARRAY
84572: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
84573: LD_ADDR_VAR 0 8
84577: PUSH
84578: LD_VAR 0 8
84582: PPUSH
84583: LD_VAR 0 6
84587: PPUSH
84588: CALL_OW 3
84592: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
84593: LD_ADDR_VAR 0 8
84597: PUSH
84598: LD_VAR 0 8
84602: PPUSH
84603: LD_INT 1
84605: PPUSH
84606: LD_VAR 0 9
84610: PPUSH
84611: CALL_OW 2
84615: ST_TO_ADDR
// end ;
84616: GO 84533
84618: POP
84619: POP
// for i in tmp do
84620: LD_ADDR_VAR 0 6
84624: PUSH
84625: LD_VAR 0 8
84629: PUSH
84630: FOR_IN
84631: IFFALSE 84658
// begin if IsNotFull ( i ) then
84633: LD_VAR 0 6
84637: PPUSH
84638: CALL 19704 0 1
84642: IFFALSE 84656
// begin j := i ;
84644: LD_ADDR_VAR 0 7
84648: PUSH
84649: LD_VAR 0 6
84653: ST_TO_ADDR
// break ;
84654: GO 84658
// end ; end ;
84656: GO 84630
84658: POP
84659: POP
// if j then
84660: LD_VAR 0 7
84664: IFFALSE 84682
// ComEnterUnit ( unit , j ) else
84666: LD_VAR 0 3
84670: PPUSH
84671: LD_VAR 0 7
84675: PPUSH
84676: CALL_OW 120
84680: GO 84785
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84682: LD_ADDR_VAR 0 10
84686: PUSH
84687: LD_VAR 0 2
84691: PPUSH
84692: LD_INT 2
84694: PUSH
84695: LD_INT 30
84697: PUSH
84698: LD_INT 0
84700: PUSH
84701: EMPTY
84702: LIST
84703: LIST
84704: PUSH
84705: LD_INT 30
84707: PUSH
84708: LD_INT 1
84710: PUSH
84711: EMPTY
84712: LIST
84713: LIST
84714: PUSH
84715: EMPTY
84716: LIST
84717: LIST
84718: LIST
84719: PPUSH
84720: CALL_OW 72
84724: ST_TO_ADDR
// if depot then
84725: LD_VAR 0 10
84729: IFFALSE 84785
// begin depot := NearestUnitToUnit ( depot , unit ) ;
84731: LD_ADDR_VAR 0 10
84735: PUSH
84736: LD_VAR 0 10
84740: PPUSH
84741: LD_VAR 0 3
84745: PPUSH
84746: CALL_OW 74
84750: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
84751: LD_VAR 0 3
84755: PPUSH
84756: LD_VAR 0 10
84760: PPUSH
84761: CALL_OW 296
84765: PUSH
84766: LD_INT 10
84768: GREATER
84769: IFFALSE 84785
// ComStandNearbyBuilding ( unit , depot ) ;
84771: LD_VAR 0 3
84775: PPUSH
84776: LD_VAR 0 10
84780: PPUSH
84781: CALL 19082 0 2
// end ; end ; end ;
84785: LD_VAR 0 5
84789: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
84790: LD_INT 0
84792: PPUSH
84793: PPUSH
84794: PPUSH
84795: PPUSH
// if not mc_bases then
84796: LD_EXP 63
84800: NOT
84801: IFFALSE 84805
// exit ;
84803: GO 85056
// for i = 1 to mc_bases do
84805: LD_ADDR_VAR 0 2
84809: PUSH
84810: DOUBLE
84811: LD_INT 1
84813: DEC
84814: ST_TO_ADDR
84815: LD_EXP 63
84819: PUSH
84820: FOR_TO
84821: IFFALSE 85054
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
84823: LD_ADDR_VAR 0 4
84827: PUSH
84828: LD_EXP 63
84832: PUSH
84833: LD_VAR 0 2
84837: ARRAY
84838: PPUSH
84839: LD_INT 21
84841: PUSH
84842: LD_INT 1
84844: PUSH
84845: EMPTY
84846: LIST
84847: LIST
84848: PPUSH
84849: CALL_OW 72
84853: PUSH
84854: LD_EXP 92
84858: PUSH
84859: LD_VAR 0 2
84863: ARRAY
84864: UNION
84865: ST_TO_ADDR
// if not tmp then
84866: LD_VAR 0 4
84870: NOT
84871: IFFALSE 84875
// continue ;
84873: GO 84820
// for j in tmp do
84875: LD_ADDR_VAR 0 3
84879: PUSH
84880: LD_VAR 0 4
84884: PUSH
84885: FOR_IN
84886: IFFALSE 85050
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
84888: LD_VAR 0 3
84892: PPUSH
84893: CALL_OW 110
84897: NOT
84898: IFFALSE 84912
84900: PUSH
84901: LD_VAR 0 3
84905: PPUSH
84906: CALL_OW 314
84910: NOT
84911: AND
84912: IFFALSE 84926
84914: PUSH
84915: LD_VAR 0 3
84919: PPUSH
84920: CALL_OW 311
84924: NOT
84925: AND
84926: IFFALSE 84940
84928: PUSH
84929: LD_VAR 0 3
84933: PPUSH
84934: CALL_OW 310
84938: NOT
84939: AND
84940: IFFALSE 84965
84942: PUSH
84943: LD_VAR 0 3
84947: PUSH
84948: LD_EXP 66
84952: PUSH
84953: LD_VAR 0 2
84957: ARRAY
84958: PUSH
84959: LD_INT 1
84961: ARRAY
84962: IN
84963: NOT
84964: AND
84965: IFFALSE 84990
84967: PUSH
84968: LD_VAR 0 3
84972: PUSH
84973: LD_EXP 66
84977: PUSH
84978: LD_VAR 0 2
84982: ARRAY
84983: PUSH
84984: LD_INT 2
84986: ARRAY
84987: IN
84988: NOT
84989: AND
84990: IFFALSE 85011
84992: PUSH
84993: LD_VAR 0 3
84997: PUSH
84998: LD_EXP 75
85002: PUSH
85003: LD_VAR 0 2
85007: ARRAY
85008: IN
85009: NOT
85010: AND
85011: IFFALSE 85048
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
85013: LD_VAR 0 2
85017: PPUSH
85018: LD_EXP 63
85022: PUSH
85023: LD_VAR 0 2
85027: ARRAY
85028: PPUSH
85029: LD_VAR 0 3
85033: PPUSH
85034: LD_VAR 0 3
85038: PPUSH
85039: CALL_OW 257
85043: PPUSH
85044: CALL 83842 0 4
// end ;
85048: GO 84885
85050: POP
85051: POP
// end ;
85052: GO 84820
85054: POP
85055: POP
// end ;
85056: LD_VAR 0 1
85060: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
85061: LD_INT 0
85063: PPUSH
85064: PPUSH
85065: PPUSH
85066: PPUSH
85067: PPUSH
85068: PPUSH
// if not mc_bases [ base ] then
85069: LD_EXP 63
85073: PUSH
85074: LD_VAR 0 1
85078: ARRAY
85079: NOT
85080: IFFALSE 85084
// exit ;
85082: GO 85285
// tmp := [ ] ;
85084: LD_ADDR_VAR 0 6
85088: PUSH
85089: EMPTY
85090: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
85091: LD_ADDR_VAR 0 7
85095: PUSH
85096: LD_VAR 0 3
85100: PPUSH
85101: LD_INT 0
85103: PPUSH
85104: CALL_OW 517
85108: ST_TO_ADDR
// if not list then
85109: LD_VAR 0 7
85113: NOT
85114: IFFALSE 85118
// exit ;
85116: GO 85285
// c := Count ( list [ 1 ] ) ;
85118: LD_ADDR_VAR 0 9
85122: PUSH
85123: LD_VAR 0 7
85127: PUSH
85128: LD_INT 1
85130: ARRAY
85131: PPUSH
85132: CALL 19622 0 1
85136: ST_TO_ADDR
// if amount > c then
85137: LD_VAR 0 2
85141: PUSH
85142: LD_VAR 0 9
85146: GREATER
85147: IFFALSE 85159
// amount := c ;
85149: LD_ADDR_VAR 0 2
85153: PUSH
85154: LD_VAR 0 9
85158: ST_TO_ADDR
// for i := 1 to amount do
85159: LD_ADDR_VAR 0 5
85163: PUSH
85164: DOUBLE
85165: LD_INT 1
85167: DEC
85168: ST_TO_ADDR
85169: LD_VAR 0 2
85173: PUSH
85174: FOR_TO
85175: IFFALSE 85233
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
85177: LD_ADDR_VAR 0 6
85181: PUSH
85182: LD_VAR 0 6
85186: PPUSH
85187: LD_VAR 0 5
85191: PPUSH
85192: LD_VAR 0 7
85196: PUSH
85197: LD_INT 1
85199: ARRAY
85200: PUSH
85201: LD_VAR 0 5
85205: ARRAY
85206: PUSH
85207: LD_VAR 0 7
85211: PUSH
85212: LD_INT 2
85214: ARRAY
85215: PUSH
85216: LD_VAR 0 5
85220: ARRAY
85221: PUSH
85222: EMPTY
85223: LIST
85224: LIST
85225: PPUSH
85226: CALL_OW 1
85230: ST_TO_ADDR
85231: GO 85174
85233: POP
85234: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
85235: LD_ADDR_EXP 76
85239: PUSH
85240: LD_EXP 76
85244: PPUSH
85245: LD_VAR 0 1
85249: PPUSH
85250: LD_VAR 0 6
85254: PPUSH
85255: CALL_OW 1
85259: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
85260: LD_ADDR_EXP 78
85264: PUSH
85265: LD_EXP 78
85269: PPUSH
85270: LD_VAR 0 1
85274: PPUSH
85275: LD_VAR 0 3
85279: PPUSH
85280: CALL_OW 1
85284: ST_TO_ADDR
// end ;
85285: LD_VAR 0 4
85289: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
85290: LD_INT 0
85292: PPUSH
// if not mc_bases [ base ] then
85293: LD_EXP 63
85297: PUSH
85298: LD_VAR 0 1
85302: ARRAY
85303: NOT
85304: IFFALSE 85308
// exit ;
85306: GO 85333
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
85308: LD_ADDR_EXP 68
85312: PUSH
85313: LD_EXP 68
85317: PPUSH
85318: LD_VAR 0 1
85322: PPUSH
85323: LD_VAR 0 2
85327: PPUSH
85328: CALL_OW 1
85332: ST_TO_ADDR
// end ;
85333: LD_VAR 0 3
85337: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
85338: LD_INT 0
85340: PPUSH
// if not mc_bases [ base ] then
85341: LD_EXP 63
85345: PUSH
85346: LD_VAR 0 1
85350: ARRAY
85351: NOT
85352: IFFALSE 85356
// exit ;
85354: GO 85393
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
85356: LD_ADDR_EXP 68
85360: PUSH
85361: LD_EXP 68
85365: PPUSH
85366: LD_VAR 0 1
85370: PPUSH
85371: LD_EXP 68
85375: PUSH
85376: LD_VAR 0 1
85380: ARRAY
85381: PUSH
85382: LD_VAR 0 2
85386: UNION
85387: PPUSH
85388: CALL_OW 1
85392: ST_TO_ADDR
// end ;
85393: LD_VAR 0 3
85397: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
85398: LD_INT 0
85400: PPUSH
// if not mc_bases [ base ] then
85401: LD_EXP 63
85405: PUSH
85406: LD_VAR 0 1
85410: ARRAY
85411: NOT
85412: IFFALSE 85416
// exit ;
85414: GO 85441
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
85416: LD_ADDR_EXP 84
85420: PUSH
85421: LD_EXP 84
85425: PPUSH
85426: LD_VAR 0 1
85430: PPUSH
85431: LD_VAR 0 2
85435: PPUSH
85436: CALL_OW 1
85440: ST_TO_ADDR
// end ;
85441: LD_VAR 0 3
85445: RET
// export function MC_InsertProduceList ( base , components ) ; begin
85446: LD_INT 0
85448: PPUSH
// if not mc_bases [ base ] then
85449: LD_EXP 63
85453: PUSH
85454: LD_VAR 0 1
85458: ARRAY
85459: NOT
85460: IFFALSE 85464
// exit ;
85462: GO 85501
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
85464: LD_ADDR_EXP 84
85468: PUSH
85469: LD_EXP 84
85473: PPUSH
85474: LD_VAR 0 1
85478: PPUSH
85479: LD_EXP 84
85483: PUSH
85484: LD_VAR 0 1
85488: ARRAY
85489: PUSH
85490: LD_VAR 0 2
85494: ADD
85495: PPUSH
85496: CALL_OW 1
85500: ST_TO_ADDR
// end ;
85501: LD_VAR 0 3
85505: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
85506: LD_INT 0
85508: PPUSH
// if not mc_bases [ base ] then
85509: LD_EXP 63
85513: PUSH
85514: LD_VAR 0 1
85518: ARRAY
85519: NOT
85520: IFFALSE 85524
// exit ;
85522: GO 85578
// mc_defender := Replace ( mc_defender , base , deflist ) ;
85524: LD_ADDR_EXP 85
85528: PUSH
85529: LD_EXP 85
85533: PPUSH
85534: LD_VAR 0 1
85538: PPUSH
85539: LD_VAR 0 2
85543: PPUSH
85544: CALL_OW 1
85548: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
85549: LD_ADDR_EXP 74
85553: PUSH
85554: LD_EXP 74
85558: PPUSH
85559: LD_VAR 0 1
85563: PPUSH
85564: LD_VAR 0 2
85568: PUSH
85569: LD_INT 0
85571: PLUS
85572: PPUSH
85573: CALL_OW 1
85577: ST_TO_ADDR
// end ;
85578: LD_VAR 0 3
85582: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
85583: LD_INT 0
85585: PPUSH
// if not mc_bases [ base ] then
85586: LD_EXP 63
85590: PUSH
85591: LD_VAR 0 1
85595: ARRAY
85596: NOT
85597: IFFALSE 85601
// exit ;
85599: GO 85626
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
85601: LD_ADDR_EXP 74
85605: PUSH
85606: LD_EXP 74
85610: PPUSH
85611: LD_VAR 0 1
85615: PPUSH
85616: LD_VAR 0 2
85620: PPUSH
85621: CALL_OW 1
85625: ST_TO_ADDR
// end ;
85626: LD_VAR 0 3
85630: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
85631: LD_INT 0
85633: PPUSH
85634: PPUSH
85635: PPUSH
85636: PPUSH
// if not mc_bases [ base ] then
85637: LD_EXP 63
85641: PUSH
85642: LD_VAR 0 1
85646: ARRAY
85647: NOT
85648: IFFALSE 85652
// exit ;
85650: GO 85717
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
85652: LD_ADDR_EXP 83
85656: PUSH
85657: LD_EXP 83
85661: PPUSH
85662: LD_VAR 0 1
85666: PUSH
85667: LD_EXP 83
85671: PUSH
85672: LD_VAR 0 1
85676: ARRAY
85677: PUSH
85678: LD_INT 1
85680: PLUS
85681: PUSH
85682: EMPTY
85683: LIST
85684: LIST
85685: PPUSH
85686: LD_VAR 0 1
85690: PUSH
85691: LD_VAR 0 2
85695: PUSH
85696: LD_VAR 0 3
85700: PUSH
85701: LD_VAR 0 4
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: PPUSH
85712: CALL 22506 0 3
85716: ST_TO_ADDR
// end ;
85717: LD_VAR 0 5
85721: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
85722: LD_INT 0
85724: PPUSH
// if not mc_bases [ base ] then
85725: LD_EXP 63
85729: PUSH
85730: LD_VAR 0 1
85734: ARRAY
85735: NOT
85736: IFFALSE 85740
// exit ;
85738: GO 85765
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
85740: LD_ADDR_EXP 100
85744: PUSH
85745: LD_EXP 100
85749: PPUSH
85750: LD_VAR 0 1
85754: PPUSH
85755: LD_VAR 0 2
85759: PPUSH
85760: CALL_OW 1
85764: ST_TO_ADDR
// end ;
85765: LD_VAR 0 3
85769: RET
// export function MC_GetMinesField ( base ) ; begin
85770: LD_INT 0
85772: PPUSH
// result := mc_mines [ base ] ;
85773: LD_ADDR_VAR 0 2
85777: PUSH
85778: LD_EXP 76
85782: PUSH
85783: LD_VAR 0 1
85787: ARRAY
85788: ST_TO_ADDR
// end ;
85789: LD_VAR 0 2
85793: RET
// export function MC_GetProduceList ( base ) ; begin
85794: LD_INT 0
85796: PPUSH
// result := mc_produce [ base ] ;
85797: LD_ADDR_VAR 0 2
85801: PUSH
85802: LD_EXP 84
85806: PUSH
85807: LD_VAR 0 1
85811: ARRAY
85812: ST_TO_ADDR
// end ;
85813: LD_VAR 0 2
85817: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
85818: LD_INT 0
85820: PPUSH
85821: PPUSH
// if not mc_bases then
85822: LD_EXP 63
85826: NOT
85827: IFFALSE 85831
// exit ;
85829: GO 85896
// if mc_bases [ base ] then
85831: LD_EXP 63
85835: PUSH
85836: LD_VAR 0 1
85840: ARRAY
85841: IFFALSE 85896
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85843: LD_ADDR_VAR 0 3
85847: PUSH
85848: LD_EXP 63
85852: PUSH
85853: LD_VAR 0 1
85857: ARRAY
85858: PPUSH
85859: LD_INT 30
85861: PUSH
85862: LD_VAR 0 2
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PPUSH
85871: CALL_OW 72
85875: ST_TO_ADDR
// if result then
85876: LD_VAR 0 3
85880: IFFALSE 85896
// result := result [ 1 ] ;
85882: LD_ADDR_VAR 0 3
85886: PUSH
85887: LD_VAR 0 3
85891: PUSH
85892: LD_INT 1
85894: ARRAY
85895: ST_TO_ADDR
// end ; end ;
85896: LD_VAR 0 3
85900: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
85901: LD_INT 0
85903: PPUSH
85904: PPUSH
// if not mc_bases then
85905: LD_EXP 63
85909: NOT
85910: IFFALSE 85914
// exit ;
85912: GO 85959
// if mc_bases [ base ] then
85914: LD_EXP 63
85918: PUSH
85919: LD_VAR 0 1
85923: ARRAY
85924: IFFALSE 85959
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85926: LD_ADDR_VAR 0 3
85930: PUSH
85931: LD_EXP 63
85935: PUSH
85936: LD_VAR 0 1
85940: ARRAY
85941: PPUSH
85942: LD_INT 30
85944: PUSH
85945: LD_VAR 0 2
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PPUSH
85954: CALL_OW 72
85958: ST_TO_ADDR
// end ;
85959: LD_VAR 0 3
85963: RET
// export function MC_SetTame ( base , area ) ; begin
85964: LD_INT 0
85966: PPUSH
// if not mc_bases or not base then
85967: LD_EXP 63
85971: NOT
85972: IFTRUE 85981
85974: PUSH
85975: LD_VAR 0 1
85979: NOT
85980: OR
85981: IFFALSE 85985
// exit ;
85983: GO 86010
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
85985: LD_ADDR_EXP 91
85989: PUSH
85990: LD_EXP 91
85994: PPUSH
85995: LD_VAR 0 1
85999: PPUSH
86000: LD_VAR 0 2
86004: PPUSH
86005: CALL_OW 1
86009: ST_TO_ADDR
// end ;
86010: LD_VAR 0 3
86014: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
86015: LD_INT 0
86017: PPUSH
86018: PPUSH
// if not mc_bases or not base then
86019: LD_EXP 63
86023: NOT
86024: IFTRUE 86033
86026: PUSH
86027: LD_VAR 0 1
86031: NOT
86032: OR
86033: IFFALSE 86037
// exit ;
86035: GO 86139
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
86037: LD_ADDR_VAR 0 4
86041: PUSH
86042: LD_EXP 63
86046: PUSH
86047: LD_VAR 0 1
86051: ARRAY
86052: PPUSH
86053: LD_INT 30
86055: PUSH
86056: LD_VAR 0 2
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PPUSH
86065: CALL_OW 72
86069: ST_TO_ADDR
// if not tmp then
86070: LD_VAR 0 4
86074: NOT
86075: IFFALSE 86079
// exit ;
86077: GO 86139
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
86079: LD_ADDR_EXP 95
86083: PUSH
86084: LD_EXP 95
86088: PPUSH
86089: LD_VAR 0 1
86093: PPUSH
86094: LD_EXP 95
86098: PUSH
86099: LD_VAR 0 1
86103: ARRAY
86104: PPUSH
86105: LD_EXP 95
86109: PUSH
86110: LD_VAR 0 1
86114: ARRAY
86115: PUSH
86116: LD_INT 1
86118: PLUS
86119: PPUSH
86120: LD_VAR 0 4
86124: PUSH
86125: LD_INT 1
86127: ARRAY
86128: PPUSH
86129: CALL_OW 2
86133: PPUSH
86134: CALL_OW 1
86138: ST_TO_ADDR
// end ;
86139: LD_VAR 0 3
86143: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
86144: LD_INT 0
86146: PPUSH
86147: PPUSH
// if not mc_bases or not base or not kinds then
86148: LD_EXP 63
86152: NOT
86153: IFTRUE 86162
86155: PUSH
86156: LD_VAR 0 1
86160: NOT
86161: OR
86162: IFTRUE 86171
86164: PUSH
86165: LD_VAR 0 2
86169: NOT
86170: OR
86171: IFFALSE 86175
// exit ;
86173: GO 86236
// for i in kinds do
86175: LD_ADDR_VAR 0 4
86179: PUSH
86180: LD_VAR 0 2
86184: PUSH
86185: FOR_IN
86186: IFFALSE 86234
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
86188: LD_ADDR_EXP 97
86192: PUSH
86193: LD_EXP 97
86197: PPUSH
86198: LD_VAR 0 1
86202: PUSH
86203: LD_EXP 97
86207: PUSH
86208: LD_VAR 0 1
86212: ARRAY
86213: PUSH
86214: LD_INT 1
86216: PLUS
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PPUSH
86222: LD_VAR 0 4
86226: PPUSH
86227: CALL 22506 0 3
86231: ST_TO_ADDR
86232: GO 86185
86234: POP
86235: POP
// end ;
86236: LD_VAR 0 3
86240: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
86241: LD_INT 0
86243: PPUSH
// if not mc_bases or not base or not areas then
86244: LD_EXP 63
86248: NOT
86249: IFTRUE 86258
86251: PUSH
86252: LD_VAR 0 1
86256: NOT
86257: OR
86258: IFTRUE 86267
86260: PUSH
86261: LD_VAR 0 2
86265: NOT
86266: OR
86267: IFFALSE 86271
// exit ;
86269: GO 86296
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
86271: LD_ADDR_EXP 81
86275: PUSH
86276: LD_EXP 81
86280: PPUSH
86281: LD_VAR 0 1
86285: PPUSH
86286: LD_VAR 0 2
86290: PPUSH
86291: CALL_OW 1
86295: ST_TO_ADDR
// end ;
86296: LD_VAR 0 3
86300: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
86301: LD_INT 0
86303: PPUSH
// if not mc_bases or not base or not teleports_exit then
86304: LD_EXP 63
86308: NOT
86309: IFTRUE 86318
86311: PUSH
86312: LD_VAR 0 1
86316: NOT
86317: OR
86318: IFTRUE 86327
86320: PUSH
86321: LD_VAR 0 2
86325: NOT
86326: OR
86327: IFFALSE 86331
// exit ;
86329: GO 86356
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
86331: LD_ADDR_EXP 98
86335: PUSH
86336: LD_EXP 98
86340: PPUSH
86341: LD_VAR 0 1
86345: PPUSH
86346: LD_VAR 0 2
86350: PPUSH
86351: CALL_OW 1
86355: ST_TO_ADDR
// end ;
86356: LD_VAR 0 3
86360: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
86361: LD_INT 0
86363: PPUSH
86364: PPUSH
86365: PPUSH
// if not mc_bases or not base or not ext_list then
86366: LD_EXP 63
86370: NOT
86371: IFTRUE 86380
86373: PUSH
86374: LD_VAR 0 1
86378: NOT
86379: OR
86380: IFTRUE 86389
86382: PUSH
86383: LD_VAR 0 5
86387: NOT
86388: OR
86389: IFFALSE 86393
// exit ;
86391: GO 86566
// tmp := GetFacExtXYD ( x , y , d ) ;
86393: LD_ADDR_VAR 0 8
86397: PUSH
86398: LD_VAR 0 2
86402: PPUSH
86403: LD_VAR 0 3
86407: PPUSH
86408: LD_VAR 0 4
86412: PPUSH
86413: CALL 53164 0 3
86417: ST_TO_ADDR
// if not tmp then
86418: LD_VAR 0 8
86422: NOT
86423: IFFALSE 86427
// exit ;
86425: GO 86566
// for i in tmp do
86427: LD_ADDR_VAR 0 7
86431: PUSH
86432: LD_VAR 0 8
86436: PUSH
86437: FOR_IN
86438: IFFALSE 86564
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
86440: LD_ADDR_EXP 68
86444: PUSH
86445: LD_EXP 68
86449: PPUSH
86450: LD_VAR 0 1
86454: PPUSH
86455: LD_EXP 68
86459: PUSH
86460: LD_VAR 0 1
86464: ARRAY
86465: PPUSH
86466: LD_EXP 68
86470: PUSH
86471: LD_VAR 0 1
86475: ARRAY
86476: PUSH
86477: LD_INT 1
86479: PLUS
86480: PPUSH
86481: LD_VAR 0 5
86485: PUSH
86486: LD_INT 1
86488: ARRAY
86489: PUSH
86490: LD_VAR 0 7
86494: PUSH
86495: LD_INT 1
86497: ARRAY
86498: PUSH
86499: LD_VAR 0 7
86503: PUSH
86504: LD_INT 2
86506: ARRAY
86507: PUSH
86508: LD_VAR 0 7
86512: PUSH
86513: LD_INT 3
86515: ARRAY
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: PPUSH
86523: CALL_OW 2
86527: PPUSH
86528: CALL_OW 1
86532: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
86533: LD_ADDR_VAR 0 5
86537: PUSH
86538: LD_VAR 0 5
86542: PPUSH
86543: LD_INT 1
86545: PPUSH
86546: CALL_OW 3
86550: ST_TO_ADDR
// if not ext_list then
86551: LD_VAR 0 5
86555: NOT
86556: IFFALSE 86562
// exit ;
86558: POP
86559: POP
86560: GO 86566
// end ;
86562: GO 86437
86564: POP
86565: POP
// end ;
86566: LD_VAR 0 6
86570: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
86571: LD_INT 0
86573: PPUSH
// if not mc_bases or not base or not weapon_list then
86574: LD_EXP 63
86578: NOT
86579: IFTRUE 86588
86581: PUSH
86582: LD_VAR 0 1
86586: NOT
86587: OR
86588: IFTRUE 86597
86590: PUSH
86591: LD_VAR 0 2
86595: NOT
86596: OR
86597: IFFALSE 86601
// exit ;
86599: GO 86626
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
86601: LD_ADDR_EXP 102
86605: PUSH
86606: LD_EXP 102
86610: PPUSH
86611: LD_VAR 0 1
86615: PPUSH
86616: LD_VAR 0 2
86620: PPUSH
86621: CALL_OW 1
86625: ST_TO_ADDR
// end ;
86626: LD_VAR 0 3
86630: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
86631: LD_INT 0
86633: PPUSH
// if not mc_bases or not base or not tech_list then
86634: LD_EXP 63
86638: NOT
86639: IFTRUE 86648
86641: PUSH
86642: LD_VAR 0 1
86646: NOT
86647: OR
86648: IFTRUE 86657
86650: PUSH
86651: LD_VAR 0 2
86655: NOT
86656: OR
86657: IFFALSE 86661
// exit ;
86659: GO 86686
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
86661: LD_ADDR_EXP 90
86665: PUSH
86666: LD_EXP 90
86670: PPUSH
86671: LD_VAR 0 1
86675: PPUSH
86676: LD_VAR 0 2
86680: PPUSH
86681: CALL_OW 1
86685: ST_TO_ADDR
// end ;
86686: LD_VAR 0 3
86690: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
86691: LD_INT 0
86693: PPUSH
// if not mc_bases or not parking_area or not base then
86694: LD_EXP 63
86698: NOT
86699: IFTRUE 86708
86701: PUSH
86702: LD_VAR 0 2
86706: NOT
86707: OR
86708: IFTRUE 86717
86710: PUSH
86711: LD_VAR 0 1
86715: NOT
86716: OR
86717: IFFALSE 86721
// exit ;
86719: GO 86746
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
86721: LD_ADDR_EXP 87
86725: PUSH
86726: LD_EXP 87
86730: PPUSH
86731: LD_VAR 0 1
86735: PPUSH
86736: LD_VAR 0 2
86740: PPUSH
86741: CALL_OW 1
86745: ST_TO_ADDR
// end ;
86746: LD_VAR 0 3
86750: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
86751: LD_INT 0
86753: PPUSH
// if not mc_bases or not base or not scan_area then
86754: LD_EXP 63
86758: NOT
86759: IFTRUE 86768
86761: PUSH
86762: LD_VAR 0 1
86766: NOT
86767: OR
86768: IFTRUE 86777
86770: PUSH
86771: LD_VAR 0 2
86775: NOT
86776: OR
86777: IFFALSE 86781
// exit ;
86779: GO 86806
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
86781: LD_ADDR_EXP 88
86785: PUSH
86786: LD_EXP 88
86790: PPUSH
86791: LD_VAR 0 1
86795: PPUSH
86796: LD_VAR 0 2
86800: PPUSH
86801: CALL_OW 1
86805: ST_TO_ADDR
// end ;
86806: LD_VAR 0 3
86810: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
86811: LD_INT 0
86813: PPUSH
86814: PPUSH
// if not mc_bases or not base then
86815: LD_EXP 63
86819: NOT
86820: IFTRUE 86829
86822: PUSH
86823: LD_VAR 0 1
86827: NOT
86828: OR
86829: IFFALSE 86833
// exit ;
86831: GO 86897
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
86833: LD_ADDR_VAR 0 3
86837: PUSH
86838: LD_INT 1
86840: PUSH
86841: LD_INT 2
86843: PUSH
86844: LD_INT 3
86846: PUSH
86847: LD_INT 4
86849: PUSH
86850: LD_INT 11
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
86860: LD_ADDR_EXP 90
86864: PUSH
86865: LD_EXP 90
86869: PPUSH
86870: LD_VAR 0 1
86874: PPUSH
86875: LD_EXP 90
86879: PUSH
86880: LD_VAR 0 1
86884: ARRAY
86885: PUSH
86886: LD_VAR 0 3
86890: DIFF
86891: PPUSH
86892: CALL_OW 1
86896: ST_TO_ADDR
// end ;
86897: LD_VAR 0 2
86901: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
86902: LD_INT 0
86904: PPUSH
// result := mc_vehicles [ base ] ;
86905: LD_ADDR_VAR 0 3
86909: PUSH
86910: LD_EXP 82
86914: PUSH
86915: LD_VAR 0 1
86919: ARRAY
86920: ST_TO_ADDR
// if onlyCombat then
86921: LD_VAR 0 2
86925: IFFALSE 87097
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
86927: LD_ADDR_VAR 0 3
86931: PUSH
86932: LD_VAR 0 3
86936: PUSH
86937: LD_VAR 0 3
86941: PPUSH
86942: LD_INT 2
86944: PUSH
86945: LD_INT 34
86947: PUSH
86948: LD_INT 12
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 34
86957: PUSH
86958: LD_INT 51
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 34
86967: PUSH
86968: LD_INT 89
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 34
86977: PUSH
86978: LD_INT 32
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 34
86987: PUSH
86988: LD_INT 13
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: PUSH
86995: LD_INT 34
86997: PUSH
86998: LD_INT 52
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 34
87007: PUSH
87008: LD_INT 88
87010: PUSH
87011: EMPTY
87012: LIST
87013: LIST
87014: PUSH
87015: LD_INT 34
87017: PUSH
87018: LD_INT 14
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: LD_INT 34
87027: PUSH
87028: LD_INT 53
87030: PUSH
87031: EMPTY
87032: LIST
87033: LIST
87034: PUSH
87035: LD_INT 34
87037: PUSH
87038: LD_INT 98
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: LD_INT 34
87047: PUSH
87048: LD_INT 31
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: PUSH
87055: LD_INT 34
87057: PUSH
87058: LD_INT 48
87060: PUSH
87061: EMPTY
87062: LIST
87063: LIST
87064: PUSH
87065: LD_INT 34
87067: PUSH
87068: LD_INT 8
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: PPUSH
87091: CALL_OW 72
87095: DIFF
87096: ST_TO_ADDR
// end ; end_of_file
87097: LD_VAR 0 3
87101: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
87102: LD_INT 0
87104: PPUSH
87105: PPUSH
87106: PPUSH
// if not mc_bases or not skirmish then
87107: LD_EXP 63
87111: NOT
87112: IFTRUE 87121
87114: PUSH
87115: LD_EXP 61
87119: NOT
87120: OR
87121: IFFALSE 87125
// exit ;
87123: GO 87290
// for i = 1 to mc_bases do
87125: LD_ADDR_VAR 0 4
87129: PUSH
87130: DOUBLE
87131: LD_INT 1
87133: DEC
87134: ST_TO_ADDR
87135: LD_EXP 63
87139: PUSH
87140: FOR_TO
87141: IFFALSE 87288
// begin if sci in mc_bases [ i ] then
87143: LD_VAR 0 2
87147: PUSH
87148: LD_EXP 63
87152: PUSH
87153: LD_VAR 0 4
87157: ARRAY
87158: IN
87159: IFFALSE 87286
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
87161: LD_ADDR_EXP 92
87165: PUSH
87166: LD_EXP 92
87170: PPUSH
87171: LD_VAR 0 4
87175: PUSH
87176: LD_EXP 92
87180: PUSH
87181: LD_VAR 0 4
87185: ARRAY
87186: PUSH
87187: LD_INT 1
87189: PLUS
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PPUSH
87195: LD_VAR 0 1
87199: PPUSH
87200: CALL 22506 0 3
87204: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
87205: LD_ADDR_VAR 0 5
87209: PUSH
87210: LD_EXP 63
87214: PUSH
87215: LD_VAR 0 4
87219: ARRAY
87220: PPUSH
87221: LD_INT 2
87223: PUSH
87224: LD_INT 30
87226: PUSH
87227: LD_INT 0
87229: PUSH
87230: EMPTY
87231: LIST
87232: LIST
87233: PUSH
87234: LD_INT 30
87236: PUSH
87237: LD_INT 1
87239: PUSH
87240: EMPTY
87241: LIST
87242: LIST
87243: PUSH
87244: EMPTY
87245: LIST
87246: LIST
87247: LIST
87248: PPUSH
87249: CALL_OW 72
87253: PPUSH
87254: LD_VAR 0 1
87258: PPUSH
87259: CALL_OW 74
87263: ST_TO_ADDR
// if tmp then
87264: LD_VAR 0 5
87268: IFFALSE 87284
// ComStandNearbyBuilding ( ape , tmp ) ;
87270: LD_VAR 0 1
87274: PPUSH
87275: LD_VAR 0 5
87279: PPUSH
87280: CALL 19082 0 2
// break ;
87284: GO 87288
// end ; end ;
87286: GO 87140
87288: POP
87289: POP
// end ;
87290: LD_VAR 0 3
87294: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
87295: LD_INT 0
87297: PPUSH
87298: PPUSH
87299: PPUSH
// if not mc_bases or not skirmish then
87300: LD_EXP 63
87304: NOT
87305: IFTRUE 87314
87307: PUSH
87308: LD_EXP 61
87312: NOT
87313: OR
87314: IFFALSE 87318
// exit ;
87316: GO 87407
// for i = 1 to mc_bases do
87318: LD_ADDR_VAR 0 4
87322: PUSH
87323: DOUBLE
87324: LD_INT 1
87326: DEC
87327: ST_TO_ADDR
87328: LD_EXP 63
87332: PUSH
87333: FOR_TO
87334: IFFALSE 87405
// begin if building in mc_busy_turret_list [ i ] then
87336: LD_VAR 0 1
87340: PUSH
87341: LD_EXP 73
87345: PUSH
87346: LD_VAR 0 4
87350: ARRAY
87351: IN
87352: IFFALSE 87403
// begin tmp := mc_busy_turret_list [ i ] diff building ;
87354: LD_ADDR_VAR 0 5
87358: PUSH
87359: LD_EXP 73
87363: PUSH
87364: LD_VAR 0 4
87368: ARRAY
87369: PUSH
87370: LD_VAR 0 1
87374: DIFF
87375: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
87376: LD_ADDR_EXP 73
87380: PUSH
87381: LD_EXP 73
87385: PPUSH
87386: LD_VAR 0 4
87390: PPUSH
87391: LD_VAR 0 5
87395: PPUSH
87396: CALL_OW 1
87400: ST_TO_ADDR
// break ;
87401: GO 87405
// end ; end ;
87403: GO 87333
87405: POP
87406: POP
// end ;
87407: LD_VAR 0 3
87411: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
87412: LD_INT 0
87414: PPUSH
87415: PPUSH
87416: PPUSH
// if not mc_bases or not skirmish then
87417: LD_EXP 63
87421: NOT
87422: IFTRUE 87431
87424: PUSH
87425: LD_EXP 61
87429: NOT
87430: OR
87431: IFFALSE 87435
// exit ;
87433: GO 87634
// for i = 1 to mc_bases do
87435: LD_ADDR_VAR 0 5
87439: PUSH
87440: DOUBLE
87441: LD_INT 1
87443: DEC
87444: ST_TO_ADDR
87445: LD_EXP 63
87449: PUSH
87450: FOR_TO
87451: IFFALSE 87632
// if building in mc_bases [ i ] then
87453: LD_VAR 0 1
87457: PUSH
87458: LD_EXP 63
87462: PUSH
87463: LD_VAR 0 5
87467: ARRAY
87468: IN
87469: IFFALSE 87630
// begin tmp := mc_bases [ i ] diff building ;
87471: LD_ADDR_VAR 0 6
87475: PUSH
87476: LD_EXP 63
87480: PUSH
87481: LD_VAR 0 5
87485: ARRAY
87486: PUSH
87487: LD_VAR 0 1
87491: DIFF
87492: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
87493: LD_ADDR_EXP 63
87497: PUSH
87498: LD_EXP 63
87502: PPUSH
87503: LD_VAR 0 5
87507: PPUSH
87508: LD_VAR 0 6
87512: PPUSH
87513: CALL_OW 1
87517: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
87518: LD_VAR 0 1
87522: PUSH
87523: LD_EXP 71
87527: PUSH
87528: LD_VAR 0 5
87532: ARRAY
87533: IN
87534: IFFALSE 87573
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
87536: LD_ADDR_EXP 71
87540: PUSH
87541: LD_EXP 71
87545: PPUSH
87546: LD_VAR 0 5
87550: PPUSH
87551: LD_EXP 71
87555: PUSH
87556: LD_VAR 0 5
87560: ARRAY
87561: PUSH
87562: LD_VAR 0 1
87566: DIFF
87567: PPUSH
87568: CALL_OW 1
87572: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
87573: LD_VAR 0 1
87577: PUSH
87578: LD_EXP 72
87582: PUSH
87583: LD_VAR 0 5
87587: ARRAY
87588: IN
87589: IFFALSE 87628
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
87591: LD_ADDR_EXP 72
87595: PUSH
87596: LD_EXP 72
87600: PPUSH
87601: LD_VAR 0 5
87605: PPUSH
87606: LD_EXP 72
87610: PUSH
87611: LD_VAR 0 5
87615: ARRAY
87616: PUSH
87617: LD_VAR 0 1
87621: DIFF
87622: PPUSH
87623: CALL_OW 1
87627: ST_TO_ADDR
// break ;
87628: GO 87632
// end ;
87630: GO 87450
87632: POP
87633: POP
// end ;
87634: LD_VAR 0 4
87638: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
87639: LD_INT 0
87641: PPUSH
87642: PPUSH
87643: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
87644: LD_EXP 63
87648: NOT
87649: IFTRUE 87658
87651: PUSH
87652: LD_EXP 61
87656: NOT
87657: OR
87658: IFTRUE 87673
87660: PUSH
87661: LD_VAR 0 3
87665: PUSH
87666: LD_EXP 89
87670: IN
87671: NOT
87672: OR
87673: IFFALSE 87677
// exit ;
87675: GO 87802
// for i = 1 to mc_vehicles do
87677: LD_ADDR_VAR 0 6
87681: PUSH
87682: DOUBLE
87683: LD_INT 1
87685: DEC
87686: ST_TO_ADDR
87687: LD_EXP 82
87691: PUSH
87692: FOR_TO
87693: IFFALSE 87800
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
87695: LD_VAR 0 2
87699: PUSH
87700: LD_EXP 82
87704: PUSH
87705: LD_VAR 0 6
87709: ARRAY
87710: IN
87711: IFTRUE 87731
87713: PUSH
87714: LD_VAR 0 1
87718: PUSH
87719: LD_EXP 82
87723: PUSH
87724: LD_VAR 0 6
87728: ARRAY
87729: IN
87730: OR
87731: IFFALSE 87798
// begin tmp := mc_vehicles [ i ] diff old ;
87733: LD_ADDR_VAR 0 7
87737: PUSH
87738: LD_EXP 82
87742: PUSH
87743: LD_VAR 0 6
87747: ARRAY
87748: PUSH
87749: LD_VAR 0 2
87753: DIFF
87754: ST_TO_ADDR
// tmp := tmp diff new ;
87755: LD_ADDR_VAR 0 7
87759: PUSH
87760: LD_VAR 0 7
87764: PUSH
87765: LD_VAR 0 1
87769: DIFF
87770: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
87771: LD_ADDR_EXP 82
87775: PUSH
87776: LD_EXP 82
87780: PPUSH
87781: LD_VAR 0 6
87785: PPUSH
87786: LD_VAR 0 7
87790: PPUSH
87791: CALL_OW 1
87795: ST_TO_ADDR
// break ;
87796: GO 87800
// end ;
87798: GO 87692
87800: POP
87801: POP
// end ;
87802: LD_VAR 0 5
87806: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
87807: LD_INT 0
87809: PPUSH
87810: PPUSH
87811: PPUSH
87812: PPUSH
// if not mc_bases or not skirmish then
87813: LD_EXP 63
87817: NOT
87818: IFTRUE 87827
87820: PUSH
87821: LD_EXP 61
87825: NOT
87826: OR
87827: IFFALSE 87831
// exit ;
87829: GO 88253
// repeat wait ( 0 0$1 ) ;
87831: LD_INT 35
87833: PPUSH
87834: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
87838: LD_EXP 107
87842: NOT
87843: IFFALSE 87831
// mc_block_vehicle_constructed_thread := true ;
87845: LD_ADDR_EXP 107
87849: PUSH
87850: LD_INT 1
87852: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
87853: LD_ADDR_VAR 0 5
87857: PUSH
87858: LD_VAR 0 1
87862: PPUSH
87863: CALL_OW 255
87867: ST_TO_ADDR
// for i = 1 to mc_bases do
87868: LD_ADDR_VAR 0 4
87872: PUSH
87873: DOUBLE
87874: LD_INT 1
87876: DEC
87877: ST_TO_ADDR
87878: LD_EXP 63
87882: PUSH
87883: FOR_TO
87884: IFFALSE 88243
// begin if factory in mc_bases [ i ] then
87886: LD_VAR 0 2
87890: PUSH
87891: LD_EXP 63
87895: PUSH
87896: LD_VAR 0 4
87900: ARRAY
87901: IN
87902: IFFALSE 88241
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
87904: LD_EXP 85
87908: PUSH
87909: LD_VAR 0 4
87913: ARRAY
87914: PUSH
87915: LD_EXP 74
87919: PUSH
87920: LD_VAR 0 4
87924: ARRAY
87925: LESS
87926: IFFALSE 88015
87928: PUSH
87929: LD_VAR 0 1
87933: PPUSH
87934: CALL_OW 264
87938: PUSH
87939: LD_INT 31
87941: PUSH
87942: LD_INT 32
87944: PUSH
87945: LD_INT 51
87947: PUSH
87948: LD_INT 89
87950: PUSH
87951: LD_INT 12
87953: PUSH
87954: LD_INT 30
87956: PUSH
87957: LD_INT 98
87959: PUSH
87960: LD_INT 11
87962: PUSH
87963: LD_INT 53
87965: PUSH
87966: LD_INT 14
87968: PUSH
87969: LD_INT 91
87971: PUSH
87972: LD_INT 29
87974: PUSH
87975: LD_INT 99
87977: PUSH
87978: LD_INT 13
87980: PUSH
87981: LD_INT 52
87983: PUSH
87984: LD_INT 88
87986: PUSH
87987: LD_INT 48
87989: PUSH
87990: LD_INT 8
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: IN
88013: NOT
88014: AND
88015: IFFALSE 88063
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
88017: LD_ADDR_EXP 85
88021: PUSH
88022: LD_EXP 85
88026: PPUSH
88027: LD_VAR 0 4
88031: PUSH
88032: LD_EXP 85
88036: PUSH
88037: LD_VAR 0 4
88041: ARRAY
88042: PUSH
88043: LD_INT 1
88045: PLUS
88046: PUSH
88047: EMPTY
88048: LIST
88049: LIST
88050: PPUSH
88051: LD_VAR 0 1
88055: PPUSH
88056: CALL 22506 0 3
88060: ST_TO_ADDR
88061: GO 88107
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
88063: LD_ADDR_EXP 82
88067: PUSH
88068: LD_EXP 82
88072: PPUSH
88073: LD_VAR 0 4
88077: PUSH
88078: LD_EXP 82
88082: PUSH
88083: LD_VAR 0 4
88087: ARRAY
88088: PUSH
88089: LD_INT 1
88091: PLUS
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PPUSH
88097: LD_VAR 0 1
88101: PPUSH
88102: CALL 22506 0 3
88106: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
88107: LD_ADDR_EXP 107
88111: PUSH
88112: LD_INT 0
88114: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
88115: LD_VAR 0 1
88119: PPUSH
88120: CALL_OW 263
88124: PUSH
88125: LD_INT 2
88127: EQUAL
88128: IFFALSE 88157
// begin repeat wait ( 0 0$3 ) ;
88130: LD_INT 105
88132: PPUSH
88133: CALL_OW 67
// Connect ( vehicle ) ;
88137: LD_VAR 0 1
88141: PPUSH
88142: CALL 25866 0 1
// until IsControledBy ( vehicle ) ;
88146: LD_VAR 0 1
88150: PPUSH
88151: CALL_OW 312
88155: IFFALSE 88130
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
88157: LD_VAR 0 1
88161: PPUSH
88162: LD_EXP 87
88166: PUSH
88167: LD_VAR 0 4
88171: ARRAY
88172: PPUSH
88173: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
88177: LD_VAR 0 1
88181: PPUSH
88182: CALL_OW 263
88186: PUSH
88187: LD_INT 1
88189: NONEQUAL
88190: IFFALSE 88194
// break ;
88192: GO 88243
// repeat wait ( 0 0$1 ) ;
88194: LD_INT 35
88196: PPUSH
88197: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
88201: LD_VAR 0 1
88205: PPUSH
88206: LD_EXP 87
88210: PUSH
88211: LD_VAR 0 4
88215: ARRAY
88216: PPUSH
88217: CALL_OW 308
88221: IFFALSE 88194
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
88223: LD_VAR 0 1
88227: PPUSH
88228: CALL_OW 311
88232: PPUSH
88233: CALL_OW 121
// exit ;
88237: POP
88238: POP
88239: GO 88253
// end ; end ;
88241: GO 87883
88243: POP
88244: POP
// mc_block_vehicle_constructed_thread := false ;
88245: LD_ADDR_EXP 107
88249: PUSH
88250: LD_INT 0
88252: ST_TO_ADDR
// end ;
88253: LD_VAR 0 3
88257: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
88258: LD_INT 0
88260: PPUSH
88261: PPUSH
88262: PPUSH
88263: PPUSH
// if not mc_bases or not skirmish then
88264: LD_EXP 63
88268: NOT
88269: IFTRUE 88278
88271: PUSH
88272: LD_EXP 61
88276: NOT
88277: OR
88278: IFFALSE 88282
// exit ;
88280: GO 88635
// repeat wait ( 0 0$1 ) ;
88282: LD_INT 35
88284: PPUSH
88285: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
88289: LD_VAR 0 2
88293: PPUSH
88294: LD_VAR 0 3
88298: PPUSH
88299: CALL_OW 284
88303: IFFALSE 88282
// if GetResourceTypeXY ( x , y ) = mat_artefact then
88305: LD_VAR 0 2
88309: PPUSH
88310: LD_VAR 0 3
88314: PPUSH
88315: CALL_OW 283
88319: PUSH
88320: LD_INT 4
88322: EQUAL
88323: IFFALSE 88327
// exit ;
88325: GO 88635
// for i = 1 to mc_bases do
88327: LD_ADDR_VAR 0 7
88331: PUSH
88332: DOUBLE
88333: LD_INT 1
88335: DEC
88336: ST_TO_ADDR
88337: LD_EXP 63
88341: PUSH
88342: FOR_TO
88343: IFFALSE 88633
// begin if mc_crates_area [ i ] then
88345: LD_EXP 81
88349: PUSH
88350: LD_VAR 0 7
88354: ARRAY
88355: IFFALSE 88466
// for j in mc_crates_area [ i ] do
88357: LD_ADDR_VAR 0 8
88361: PUSH
88362: LD_EXP 81
88366: PUSH
88367: LD_VAR 0 7
88371: ARRAY
88372: PUSH
88373: FOR_IN
88374: IFFALSE 88464
// if InArea ( x , y , j ) then
88376: LD_VAR 0 2
88380: PPUSH
88381: LD_VAR 0 3
88385: PPUSH
88386: LD_VAR 0 8
88390: PPUSH
88391: CALL_OW 309
88395: IFFALSE 88462
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88397: LD_ADDR_EXP 79
88401: PUSH
88402: LD_EXP 79
88406: PPUSH
88407: LD_VAR 0 7
88411: PUSH
88412: LD_EXP 79
88416: PUSH
88417: LD_VAR 0 7
88421: ARRAY
88422: PUSH
88423: LD_INT 1
88425: PLUS
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PPUSH
88431: LD_VAR 0 4
88435: PUSH
88436: LD_VAR 0 2
88440: PUSH
88441: LD_VAR 0 3
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: LIST
88450: PPUSH
88451: CALL 22506 0 3
88455: ST_TO_ADDR
// exit ;
88456: POP
88457: POP
88458: POP
88459: POP
88460: GO 88635
// end ;
88462: GO 88373
88464: POP
88465: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
88466: LD_ADDR_VAR 0 9
88470: PUSH
88471: LD_EXP 63
88475: PUSH
88476: LD_VAR 0 7
88480: ARRAY
88481: PPUSH
88482: LD_INT 2
88484: PUSH
88485: LD_INT 30
88487: PUSH
88488: LD_INT 0
88490: PUSH
88491: EMPTY
88492: LIST
88493: LIST
88494: PUSH
88495: LD_INT 30
88497: PUSH
88498: LD_INT 1
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: EMPTY
88506: LIST
88507: LIST
88508: LIST
88509: PPUSH
88510: CALL_OW 72
88514: ST_TO_ADDR
// if not depot then
88515: LD_VAR 0 9
88519: NOT
88520: IFFALSE 88524
// continue ;
88522: GO 88342
// for j in depot do
88524: LD_ADDR_VAR 0 8
88528: PUSH
88529: LD_VAR 0 9
88533: PUSH
88534: FOR_IN
88535: IFFALSE 88629
// if GetDistUnitXY ( j , x , y ) < 30 then
88537: LD_VAR 0 8
88541: PPUSH
88542: LD_VAR 0 2
88546: PPUSH
88547: LD_VAR 0 3
88551: PPUSH
88552: CALL_OW 297
88556: PUSH
88557: LD_INT 30
88559: LESS
88560: IFFALSE 88627
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
88562: LD_ADDR_EXP 79
88566: PUSH
88567: LD_EXP 79
88571: PPUSH
88572: LD_VAR 0 7
88576: PUSH
88577: LD_EXP 79
88581: PUSH
88582: LD_VAR 0 7
88586: ARRAY
88587: PUSH
88588: LD_INT 1
88590: PLUS
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: PPUSH
88596: LD_VAR 0 4
88600: PUSH
88601: LD_VAR 0 2
88605: PUSH
88606: LD_VAR 0 3
88610: PUSH
88611: EMPTY
88612: LIST
88613: LIST
88614: LIST
88615: PPUSH
88616: CALL 22506 0 3
88620: ST_TO_ADDR
// exit ;
88621: POP
88622: POP
88623: POP
88624: POP
88625: GO 88635
// end ;
88627: GO 88534
88629: POP
88630: POP
// end ;
88631: GO 88342
88633: POP
88634: POP
// end ;
88635: LD_VAR 0 6
88639: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
88640: LD_INT 0
88642: PPUSH
88643: PPUSH
88644: PPUSH
88645: PPUSH
// if not mc_bases or not skirmish then
88646: LD_EXP 63
88650: NOT
88651: IFTRUE 88660
88653: PUSH
88654: LD_EXP 61
88658: NOT
88659: OR
88660: IFFALSE 88664
// exit ;
88662: GO 88947
// side := GetSide ( lab ) ;
88664: LD_ADDR_VAR 0 4
88668: PUSH
88669: LD_VAR 0 2
88673: PPUSH
88674: CALL_OW 255
88678: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
88679: LD_VAR 0 4
88683: PUSH
88684: LD_EXP 89
88688: IN
88689: NOT
88690: IFTRUE 88699
88692: PUSH
88693: LD_EXP 90
88697: NOT
88698: OR
88699: IFTRUE 88708
88701: PUSH
88702: LD_EXP 63
88706: NOT
88707: OR
88708: IFFALSE 88712
// exit ;
88710: GO 88947
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
88712: LD_ADDR_EXP 90
88716: PUSH
88717: LD_EXP 90
88721: PPUSH
88722: LD_VAR 0 4
88726: PPUSH
88727: LD_EXP 90
88731: PUSH
88732: LD_VAR 0 4
88736: ARRAY
88737: PUSH
88738: LD_VAR 0 1
88742: DIFF
88743: PPUSH
88744: CALL_OW 1
88748: ST_TO_ADDR
// for i = 1 to mc_bases do
88749: LD_ADDR_VAR 0 5
88753: PUSH
88754: DOUBLE
88755: LD_INT 1
88757: DEC
88758: ST_TO_ADDR
88759: LD_EXP 63
88763: PUSH
88764: FOR_TO
88765: IFFALSE 88945
// begin if lab in mc_bases [ i ] then
88767: LD_VAR 0 2
88771: PUSH
88772: LD_EXP 63
88776: PUSH
88777: LD_VAR 0 5
88781: ARRAY
88782: IN
88783: IFFALSE 88943
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
88785: LD_VAR 0 1
88789: PUSH
88790: LD_INT 11
88792: PUSH
88793: LD_INT 4
88795: PUSH
88796: LD_INT 3
88798: PUSH
88799: LD_INT 2
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: IN
88808: IFFALSE 88822
88810: PUSH
88811: LD_EXP 93
88815: PUSH
88816: LD_VAR 0 5
88820: ARRAY
88821: AND
88822: IFFALSE 88943
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
88824: LD_ADDR_VAR 0 6
88828: PUSH
88829: LD_EXP 93
88833: PUSH
88834: LD_VAR 0 5
88838: ARRAY
88839: PUSH
88840: LD_INT 1
88842: ARRAY
88843: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88844: LD_ADDR_EXP 93
88848: PUSH
88849: LD_EXP 93
88853: PPUSH
88854: LD_VAR 0 5
88858: PPUSH
88859: EMPTY
88860: PPUSH
88861: CALL_OW 1
88865: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
88866: LD_VAR 0 6
88870: PPUSH
88871: LD_INT 0
88873: PPUSH
88874: CALL_OW 109
// ComExitBuilding ( tmp ) ;
88878: LD_VAR 0 6
88882: PPUSH
88883: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
88887: LD_ADDR_EXP 92
88891: PUSH
88892: LD_EXP 92
88896: PPUSH
88897: LD_VAR 0 5
88901: PPUSH
88902: LD_EXP 92
88906: PUSH
88907: LD_VAR 0 5
88911: ARRAY
88912: PPUSH
88913: LD_INT 1
88915: PPUSH
88916: LD_VAR 0 6
88920: PPUSH
88921: CALL_OW 2
88925: PPUSH
88926: CALL_OW 1
88930: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
88931: LD_VAR 0 5
88935: PPUSH
88936: LD_INT 112
88938: PPUSH
88939: CALL 65077 0 2
// end ; end ; end ;
88943: GO 88764
88945: POP
88946: POP
// end ;
88947: LD_VAR 0 3
88951: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
88952: LD_INT 0
88954: PPUSH
88955: PPUSH
88956: PPUSH
88957: PPUSH
88958: PPUSH
88959: PPUSH
88960: PPUSH
88961: PPUSH
// if not mc_bases or not skirmish then
88962: LD_EXP 63
88966: NOT
88967: IFTRUE 88976
88969: PUSH
88970: LD_EXP 61
88974: NOT
88975: OR
88976: IFFALSE 88980
// exit ;
88978: GO 90365
// for i = 1 to mc_bases do
88980: LD_ADDR_VAR 0 3
88984: PUSH
88985: DOUBLE
88986: LD_INT 1
88988: DEC
88989: ST_TO_ADDR
88990: LD_EXP 63
88994: PUSH
88995: FOR_TO
88996: IFFALSE 90363
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
88998: LD_VAR 0 1
89002: PUSH
89003: LD_EXP 63
89007: PUSH
89008: LD_VAR 0 3
89012: ARRAY
89013: IN
89014: IFTRUE 89034
89016: PUSH
89017: LD_VAR 0 1
89021: PUSH
89022: LD_EXP 70
89026: PUSH
89027: LD_VAR 0 3
89031: ARRAY
89032: IN
89033: OR
89034: IFTRUE 89054
89036: PUSH
89037: LD_VAR 0 1
89041: PUSH
89042: LD_EXP 85
89046: PUSH
89047: LD_VAR 0 3
89051: ARRAY
89052: IN
89053: OR
89054: IFTRUE 89074
89056: PUSH
89057: LD_VAR 0 1
89061: PUSH
89062: LD_EXP 82
89066: PUSH
89067: LD_VAR 0 3
89071: ARRAY
89072: IN
89073: OR
89074: IFTRUE 89094
89076: PUSH
89077: LD_VAR 0 1
89081: PUSH
89082: LD_EXP 92
89086: PUSH
89087: LD_VAR 0 3
89091: ARRAY
89092: IN
89093: OR
89094: IFTRUE 89114
89096: PUSH
89097: LD_VAR 0 1
89101: PUSH
89102: LD_EXP 93
89106: PUSH
89107: LD_VAR 0 3
89111: ARRAY
89112: IN
89113: OR
89114: IFFALSE 90361
// begin if un in mc_ape [ i ] then
89116: LD_VAR 0 1
89120: PUSH
89121: LD_EXP 92
89125: PUSH
89126: LD_VAR 0 3
89130: ARRAY
89131: IN
89132: IFFALSE 89171
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
89134: LD_ADDR_EXP 92
89138: PUSH
89139: LD_EXP 92
89143: PPUSH
89144: LD_VAR 0 3
89148: PPUSH
89149: LD_EXP 92
89153: PUSH
89154: LD_VAR 0 3
89158: ARRAY
89159: PUSH
89160: LD_VAR 0 1
89164: DIFF
89165: PPUSH
89166: CALL_OW 1
89170: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
89171: LD_VAR 0 1
89175: PUSH
89176: LD_EXP 93
89180: PUSH
89181: LD_VAR 0 3
89185: ARRAY
89186: IN
89187: IFFALSE 89211
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
89189: LD_ADDR_EXP 93
89193: PUSH
89194: LD_EXP 93
89198: PPUSH
89199: LD_VAR 0 3
89203: PPUSH
89204: EMPTY
89205: PPUSH
89206: CALL_OW 1
89210: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
89211: LD_VAR 0 1
89215: PPUSH
89216: CALL_OW 247
89220: PUSH
89221: LD_INT 2
89223: EQUAL
89224: IFFALSE 89305
89226: PUSH
89227: LD_VAR 0 1
89231: PPUSH
89232: CALL_OW 110
89236: PUSH
89237: LD_INT 20
89239: EQUAL
89240: IFTRUE 89260
89242: PUSH
89243: LD_VAR 0 1
89247: PUSH
89248: LD_EXP 85
89252: PUSH
89253: LD_VAR 0 3
89257: ARRAY
89258: IN
89259: OR
89260: IFTRUE 89304
89262: PUSH
89263: LD_VAR 0 1
89267: PPUSH
89268: CALL_OW 264
89272: PUSH
89273: LD_INT 12
89275: PUSH
89276: LD_INT 51
89278: PUSH
89279: LD_INT 89
89281: PUSH
89282: LD_INT 32
89284: PUSH
89285: LD_INT 13
89287: PUSH
89288: LD_INT 52
89290: PUSH
89291: LD_INT 31
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: IN
89303: OR
89304: AND
89305: IFFALSE 89613
// begin if un in mc_defender [ i ] then
89307: LD_VAR 0 1
89311: PUSH
89312: LD_EXP 85
89316: PUSH
89317: LD_VAR 0 3
89321: ARRAY
89322: IN
89323: IFFALSE 89362
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89325: LD_ADDR_EXP 85
89329: PUSH
89330: LD_EXP 85
89334: PPUSH
89335: LD_VAR 0 3
89339: PPUSH
89340: LD_EXP 85
89344: PUSH
89345: LD_VAR 0 3
89349: ARRAY
89350: PUSH
89351: LD_VAR 0 1
89355: DIFF
89356: PPUSH
89357: CALL_OW 1
89361: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
89362: LD_ADDR_VAR 0 8
89366: PUSH
89367: LD_VAR 0 3
89371: PPUSH
89372: LD_INT 3
89374: PPUSH
89375: CALL 85901 0 2
89379: ST_TO_ADDR
// if fac then
89380: LD_VAR 0 8
89384: IFFALSE 89613
// begin for j in fac do
89386: LD_ADDR_VAR 0 4
89390: PUSH
89391: LD_VAR 0 8
89395: PUSH
89396: FOR_IN
89397: IFFALSE 89611
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
89399: LD_ADDR_VAR 0 9
89403: PUSH
89404: LD_VAR 0 8
89408: PPUSH
89409: LD_VAR 0 1
89413: PPUSH
89414: CALL_OW 265
89418: PPUSH
89419: LD_VAR 0 1
89423: PPUSH
89424: CALL_OW 262
89428: PPUSH
89429: LD_VAR 0 1
89433: PPUSH
89434: CALL_OW 263
89438: PPUSH
89439: LD_VAR 0 1
89443: PPUSH
89444: CALL_OW 264
89448: PPUSH
89449: CALL 19980 0 5
89453: ST_TO_ADDR
// if components then
89454: LD_VAR 0 9
89458: IFFALSE 89609
// begin if GetWeapon ( un ) = ar_control_tower then
89460: LD_VAR 0 1
89464: PPUSH
89465: CALL_OW 264
89469: PUSH
89470: LD_INT 31
89472: EQUAL
89473: IFFALSE 89590
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
89475: LD_VAR 0 1
89479: PPUSH
89480: CALL_OW 311
89484: PPUSH
89485: LD_INT 0
89487: PPUSH
89488: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
89492: LD_ADDR_EXP 103
89496: PUSH
89497: LD_EXP 103
89501: PPUSH
89502: LD_VAR 0 3
89506: PPUSH
89507: LD_EXP 103
89511: PUSH
89512: LD_VAR 0 3
89516: ARRAY
89517: PUSH
89518: LD_VAR 0 1
89522: PPUSH
89523: CALL_OW 311
89527: DIFF
89528: PPUSH
89529: CALL_OW 1
89533: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
89534: LD_ADDR_VAR 0 7
89538: PUSH
89539: LD_EXP 84
89543: PUSH
89544: LD_VAR 0 3
89548: ARRAY
89549: PPUSH
89550: LD_INT 1
89552: PPUSH
89553: LD_VAR 0 9
89557: PPUSH
89558: CALL_OW 2
89562: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
89563: LD_ADDR_EXP 84
89567: PUSH
89568: LD_EXP 84
89572: PPUSH
89573: LD_VAR 0 3
89577: PPUSH
89578: LD_VAR 0 7
89582: PPUSH
89583: CALL_OW 1
89587: ST_TO_ADDR
// end else
89588: GO 89607
// MC_InsertProduceList ( i , [ components ] ) ;
89590: LD_VAR 0 3
89594: PPUSH
89595: LD_VAR 0 9
89599: PUSH
89600: EMPTY
89601: LIST
89602: PPUSH
89603: CALL 85446 0 2
// break ;
89607: GO 89611
// end ; end ;
89609: GO 89396
89611: POP
89612: POP
// end ; end ; if GetType ( un ) = unit_building then
89613: LD_VAR 0 1
89617: PPUSH
89618: CALL_OW 247
89622: PUSH
89623: LD_INT 3
89625: EQUAL
89626: IFFALSE 90029
// begin btype := GetBType ( un ) ;
89628: LD_ADDR_VAR 0 5
89632: PUSH
89633: LD_VAR 0 1
89637: PPUSH
89638: CALL_OW 266
89642: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
89643: LD_VAR 0 5
89647: PUSH
89648: LD_INT 29
89650: PUSH
89651: LD_INT 30
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: IN
89658: IFFALSE 89731
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
89660: LD_VAR 0 1
89664: PPUSH
89665: CALL_OW 250
89669: PPUSH
89670: LD_VAR 0 1
89674: PPUSH
89675: CALL_OW 251
89679: PPUSH
89680: LD_VAR 0 1
89684: PPUSH
89685: CALL_OW 255
89689: PPUSH
89690: CALL_OW 440
89694: NOT
89695: IFFALSE 89731
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
89697: LD_VAR 0 1
89701: PPUSH
89702: CALL_OW 250
89706: PPUSH
89707: LD_VAR 0 1
89711: PPUSH
89712: CALL_OW 251
89716: PPUSH
89717: LD_VAR 0 1
89721: PPUSH
89722: CALL_OW 255
89726: PPUSH
89727: CALL_OW 441
// end ; if btype = b_warehouse then
89731: LD_VAR 0 5
89735: PUSH
89736: LD_INT 1
89738: EQUAL
89739: IFFALSE 89757
// begin btype := b_depot ;
89741: LD_ADDR_VAR 0 5
89745: PUSH
89746: LD_INT 0
89748: ST_TO_ADDR
// pos := 1 ;
89749: LD_ADDR_VAR 0 6
89753: PUSH
89754: LD_INT 1
89756: ST_TO_ADDR
// end ; if btype = b_factory then
89757: LD_VAR 0 5
89761: PUSH
89762: LD_INT 3
89764: EQUAL
89765: IFFALSE 89783
// begin btype := b_workshop ;
89767: LD_ADDR_VAR 0 5
89771: PUSH
89772: LD_INT 2
89774: ST_TO_ADDR
// pos := 1 ;
89775: LD_ADDR_VAR 0 6
89779: PUSH
89780: LD_INT 1
89782: ST_TO_ADDR
// end ; if btype = b_barracks then
89783: LD_VAR 0 5
89787: PUSH
89788: LD_INT 5
89790: EQUAL
89791: IFFALSE 89801
// btype := b_armoury ;
89793: LD_ADDR_VAR 0 5
89797: PUSH
89798: LD_INT 4
89800: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
89801: LD_VAR 0 5
89805: PUSH
89806: LD_INT 7
89808: PUSH
89809: LD_INT 8
89811: PUSH
89812: EMPTY
89813: LIST
89814: LIST
89815: IN
89816: IFFALSE 89826
// btype := b_lab ;
89818: LD_ADDR_VAR 0 5
89822: PUSH
89823: LD_INT 6
89825: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
89826: LD_ADDR_EXP 68
89830: PUSH
89831: LD_EXP 68
89835: PPUSH
89836: LD_VAR 0 3
89840: PUSH
89841: LD_EXP 68
89845: PUSH
89846: LD_VAR 0 3
89850: ARRAY
89851: PUSH
89852: LD_INT 1
89854: PLUS
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: PPUSH
89860: LD_VAR 0 5
89864: PUSH
89865: LD_VAR 0 1
89869: PPUSH
89870: CALL_OW 250
89874: PUSH
89875: LD_VAR 0 1
89879: PPUSH
89880: CALL_OW 251
89884: PUSH
89885: LD_VAR 0 1
89889: PPUSH
89890: CALL_OW 254
89894: PUSH
89895: EMPTY
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: PPUSH
89901: CALL 22506 0 3
89905: ST_TO_ADDR
// if pos = 1 then
89906: LD_VAR 0 6
89910: PUSH
89911: LD_INT 1
89913: EQUAL
89914: IFFALSE 90029
// begin tmp := mc_build_list [ i ] ;
89916: LD_ADDR_VAR 0 7
89920: PUSH
89921: LD_EXP 68
89925: PUSH
89926: LD_VAR 0 3
89930: ARRAY
89931: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
89932: LD_VAR 0 7
89936: PPUSH
89937: LD_INT 2
89939: PUSH
89940: LD_INT 30
89942: PUSH
89943: LD_INT 0
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 30
89952: PUSH
89953: LD_INT 1
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: LIST
89964: PPUSH
89965: CALL_OW 72
89969: IFFALSE 89979
// pos := 2 ;
89971: LD_ADDR_VAR 0 6
89975: PUSH
89976: LD_INT 2
89978: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
89979: LD_ADDR_VAR 0 7
89983: PUSH
89984: LD_VAR 0 7
89988: PPUSH
89989: LD_VAR 0 6
89993: PPUSH
89994: LD_VAR 0 7
89998: PPUSH
89999: CALL 22832 0 3
90003: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
90004: LD_ADDR_EXP 68
90008: PUSH
90009: LD_EXP 68
90013: PPUSH
90014: LD_VAR 0 3
90018: PPUSH
90019: LD_VAR 0 7
90023: PPUSH
90024: CALL_OW 1
90028: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
90029: LD_VAR 0 1
90033: PUSH
90034: LD_EXP 63
90038: PUSH
90039: LD_VAR 0 3
90043: ARRAY
90044: IN
90045: IFFALSE 90084
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
90047: LD_ADDR_EXP 63
90051: PUSH
90052: LD_EXP 63
90056: PPUSH
90057: LD_VAR 0 3
90061: PPUSH
90062: LD_EXP 63
90066: PUSH
90067: LD_VAR 0 3
90071: ARRAY
90072: PUSH
90073: LD_VAR 0 1
90077: DIFF
90078: PPUSH
90079: CALL_OW 1
90083: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
90084: LD_VAR 0 1
90088: PUSH
90089: LD_EXP 70
90093: PUSH
90094: LD_VAR 0 3
90098: ARRAY
90099: IN
90100: IFFALSE 90139
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
90102: LD_ADDR_EXP 70
90106: PUSH
90107: LD_EXP 70
90111: PPUSH
90112: LD_VAR 0 3
90116: PPUSH
90117: LD_EXP 70
90121: PUSH
90122: LD_VAR 0 3
90126: ARRAY
90127: PUSH
90128: LD_VAR 0 1
90132: DIFF
90133: PPUSH
90134: CALL_OW 1
90138: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
90139: LD_VAR 0 1
90143: PUSH
90144: LD_EXP 82
90148: PUSH
90149: LD_VAR 0 3
90153: ARRAY
90154: IN
90155: IFFALSE 90194
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
90157: LD_ADDR_EXP 82
90161: PUSH
90162: LD_EXP 82
90166: PPUSH
90167: LD_VAR 0 3
90171: PPUSH
90172: LD_EXP 82
90176: PUSH
90177: LD_VAR 0 3
90181: ARRAY
90182: PUSH
90183: LD_VAR 0 1
90187: DIFF
90188: PPUSH
90189: CALL_OW 1
90193: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
90194: LD_VAR 0 1
90198: PUSH
90199: LD_EXP 85
90203: PUSH
90204: LD_VAR 0 3
90208: ARRAY
90209: IN
90210: IFFALSE 90249
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
90212: LD_ADDR_EXP 85
90216: PUSH
90217: LD_EXP 85
90221: PPUSH
90222: LD_VAR 0 3
90226: PPUSH
90227: LD_EXP 85
90231: PUSH
90232: LD_VAR 0 3
90236: ARRAY
90237: PUSH
90238: LD_VAR 0 1
90242: DIFF
90243: PPUSH
90244: CALL_OW 1
90248: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
90249: LD_VAR 0 1
90253: PUSH
90254: LD_EXP 72
90258: PUSH
90259: LD_VAR 0 3
90263: ARRAY
90264: IN
90265: IFFALSE 90304
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
90267: LD_ADDR_EXP 72
90271: PUSH
90272: LD_EXP 72
90276: PPUSH
90277: LD_VAR 0 3
90281: PPUSH
90282: LD_EXP 72
90286: PUSH
90287: LD_VAR 0 3
90291: ARRAY
90292: PUSH
90293: LD_VAR 0 1
90297: DIFF
90298: PPUSH
90299: CALL_OW 1
90303: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
90304: LD_VAR 0 1
90308: PUSH
90309: LD_EXP 71
90313: PUSH
90314: LD_VAR 0 3
90318: ARRAY
90319: IN
90320: IFFALSE 90359
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
90322: LD_ADDR_EXP 71
90326: PUSH
90327: LD_EXP 71
90331: PPUSH
90332: LD_VAR 0 3
90336: PPUSH
90337: LD_EXP 71
90341: PUSH
90342: LD_VAR 0 3
90346: ARRAY
90347: PUSH
90348: LD_VAR 0 1
90352: DIFF
90353: PPUSH
90354: CALL_OW 1
90358: ST_TO_ADDR
// end ; break ;
90359: GO 90363
// end ;
90361: GO 88995
90363: POP
90364: POP
// end ;
90365: LD_VAR 0 2
90369: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
90370: LD_INT 0
90372: PPUSH
90373: PPUSH
90374: PPUSH
// if not mc_bases or not skirmish then
90375: LD_EXP 63
90379: NOT
90380: IFTRUE 90389
90382: PUSH
90383: LD_EXP 61
90387: NOT
90388: OR
90389: IFFALSE 90393
// exit ;
90391: GO 90608
// for i = 1 to mc_bases do
90393: LD_ADDR_VAR 0 3
90397: PUSH
90398: DOUBLE
90399: LD_INT 1
90401: DEC
90402: ST_TO_ADDR
90403: LD_EXP 63
90407: PUSH
90408: FOR_TO
90409: IFFALSE 90606
// begin if building in mc_construct_list [ i ] then
90411: LD_VAR 0 1
90415: PUSH
90416: LD_EXP 70
90420: PUSH
90421: LD_VAR 0 3
90425: ARRAY
90426: IN
90427: IFFALSE 90604
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90429: LD_ADDR_EXP 70
90433: PUSH
90434: LD_EXP 70
90438: PPUSH
90439: LD_VAR 0 3
90443: PPUSH
90444: LD_EXP 70
90448: PUSH
90449: LD_VAR 0 3
90453: ARRAY
90454: PUSH
90455: LD_VAR 0 1
90459: DIFF
90460: PPUSH
90461: CALL_OW 1
90465: ST_TO_ADDR
// if building in mc_lab [ i ] then
90466: LD_VAR 0 1
90470: PUSH
90471: LD_EXP 96
90475: PUSH
90476: LD_VAR 0 3
90480: ARRAY
90481: IN
90482: IFFALSE 90537
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
90484: LD_ADDR_EXP 97
90488: PUSH
90489: LD_EXP 97
90493: PPUSH
90494: LD_VAR 0 3
90498: PPUSH
90499: LD_EXP 97
90503: PUSH
90504: LD_VAR 0 3
90508: ARRAY
90509: PPUSH
90510: LD_INT 1
90512: PPUSH
90513: LD_EXP 97
90517: PUSH
90518: LD_VAR 0 3
90522: ARRAY
90523: PPUSH
90524: LD_INT 0
90526: PPUSH
90527: CALL 21914 0 4
90531: PPUSH
90532: CALL_OW 1
90536: ST_TO_ADDR
// if not building in mc_bases [ i ] then
90537: LD_VAR 0 1
90541: PUSH
90542: LD_EXP 63
90546: PUSH
90547: LD_VAR 0 3
90551: ARRAY
90552: IN
90553: NOT
90554: IFFALSE 90600
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90556: LD_ADDR_EXP 63
90560: PUSH
90561: LD_EXP 63
90565: PPUSH
90566: LD_VAR 0 3
90570: PUSH
90571: LD_EXP 63
90575: PUSH
90576: LD_VAR 0 3
90580: ARRAY
90581: PUSH
90582: LD_INT 1
90584: PLUS
90585: PUSH
90586: EMPTY
90587: LIST
90588: LIST
90589: PPUSH
90590: LD_VAR 0 1
90594: PPUSH
90595: CALL 22506 0 3
90599: ST_TO_ADDR
// exit ;
90600: POP
90601: POP
90602: GO 90608
// end ; end ;
90604: GO 90408
90606: POP
90607: POP
// end ;
90608: LD_VAR 0 2
90612: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
90613: LD_INT 0
90615: PPUSH
90616: PPUSH
90617: PPUSH
90618: PPUSH
90619: PPUSH
90620: PPUSH
90621: PPUSH
// if not mc_bases or not skirmish then
90622: LD_EXP 63
90626: NOT
90627: IFTRUE 90636
90629: PUSH
90630: LD_EXP 61
90634: NOT
90635: OR
90636: IFFALSE 90640
// exit ;
90638: GO 91301
// for i = 1 to mc_bases do
90640: LD_ADDR_VAR 0 3
90644: PUSH
90645: DOUBLE
90646: LD_INT 1
90648: DEC
90649: ST_TO_ADDR
90650: LD_EXP 63
90654: PUSH
90655: FOR_TO
90656: IFFALSE 91299
// begin if building in mc_construct_list [ i ] then
90658: LD_VAR 0 1
90662: PUSH
90663: LD_EXP 70
90667: PUSH
90668: LD_VAR 0 3
90672: ARRAY
90673: IN
90674: IFFALSE 91297
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
90676: LD_ADDR_EXP 70
90680: PUSH
90681: LD_EXP 70
90685: PPUSH
90686: LD_VAR 0 3
90690: PPUSH
90691: LD_EXP 70
90695: PUSH
90696: LD_VAR 0 3
90700: ARRAY
90701: PUSH
90702: LD_VAR 0 1
90706: DIFF
90707: PPUSH
90708: CALL_OW 1
90712: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
90713: LD_ADDR_EXP 63
90717: PUSH
90718: LD_EXP 63
90722: PPUSH
90723: LD_VAR 0 3
90727: PUSH
90728: LD_EXP 63
90732: PUSH
90733: LD_VAR 0 3
90737: ARRAY
90738: PUSH
90739: LD_INT 1
90741: PLUS
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PPUSH
90747: LD_VAR 0 1
90751: PPUSH
90752: CALL 22506 0 3
90756: ST_TO_ADDR
// btype := GetBType ( building ) ;
90757: LD_ADDR_VAR 0 5
90761: PUSH
90762: LD_VAR 0 1
90766: PPUSH
90767: CALL_OW 266
90771: ST_TO_ADDR
// side := GetSide ( building ) ;
90772: LD_ADDR_VAR 0 8
90776: PUSH
90777: LD_VAR 0 1
90781: PPUSH
90782: CALL_OW 255
90786: ST_TO_ADDR
// if btype = b_lab then
90787: LD_VAR 0 5
90791: PUSH
90792: LD_INT 6
90794: EQUAL
90795: IFFALSE 90845
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
90797: LD_ADDR_EXP 96
90801: PUSH
90802: LD_EXP 96
90806: PPUSH
90807: LD_VAR 0 3
90811: PUSH
90812: LD_EXP 96
90816: PUSH
90817: LD_VAR 0 3
90821: ARRAY
90822: PUSH
90823: LD_INT 1
90825: PLUS
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: PPUSH
90831: LD_VAR 0 1
90835: PPUSH
90836: CALL 22506 0 3
90840: ST_TO_ADDR
// exit ;
90841: POP
90842: POP
90843: GO 91301
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
90845: LD_VAR 0 5
90849: PUSH
90850: LD_INT 0
90852: PUSH
90853: LD_INT 2
90855: PUSH
90856: LD_INT 4
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: LIST
90863: IN
90864: IFFALSE 90988
// begin if btype = b_armoury then
90866: LD_VAR 0 5
90870: PUSH
90871: LD_INT 4
90873: EQUAL
90874: IFFALSE 90884
// btype := b_barracks ;
90876: LD_ADDR_VAR 0 5
90880: PUSH
90881: LD_INT 5
90883: ST_TO_ADDR
// if btype = b_depot then
90884: LD_VAR 0 5
90888: PUSH
90889: LD_INT 0
90891: EQUAL
90892: IFFALSE 90902
// btype := b_warehouse ;
90894: LD_ADDR_VAR 0 5
90898: PUSH
90899: LD_INT 1
90901: ST_TO_ADDR
// if btype = b_workshop then
90902: LD_VAR 0 5
90906: PUSH
90907: LD_INT 2
90909: EQUAL
90910: IFFALSE 90920
// btype := b_factory ;
90912: LD_ADDR_VAR 0 5
90916: PUSH
90917: LD_INT 3
90919: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
90920: LD_VAR 0 5
90924: PPUSH
90925: LD_VAR 0 8
90929: PPUSH
90930: CALL_OW 323
90934: PUSH
90935: LD_INT 1
90937: EQUAL
90938: IFFALSE 90984
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
90940: LD_ADDR_EXP 95
90944: PUSH
90945: LD_EXP 95
90949: PPUSH
90950: LD_VAR 0 3
90954: PUSH
90955: LD_EXP 95
90959: PUSH
90960: LD_VAR 0 3
90964: ARRAY
90965: PUSH
90966: LD_INT 1
90968: PLUS
90969: PUSH
90970: EMPTY
90971: LIST
90972: LIST
90973: PPUSH
90974: LD_VAR 0 1
90978: PPUSH
90979: CALL 22506 0 3
90983: ST_TO_ADDR
// exit ;
90984: POP
90985: POP
90986: GO 91301
// end ; if btype in [ b_bunker , b_turret ] then
90988: LD_VAR 0 5
90992: PUSH
90993: LD_INT 32
90995: PUSH
90996: LD_INT 33
90998: PUSH
90999: EMPTY
91000: LIST
91001: LIST
91002: IN
91003: IFFALSE 91293
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
91005: LD_ADDR_EXP 71
91009: PUSH
91010: LD_EXP 71
91014: PPUSH
91015: LD_VAR 0 3
91019: PUSH
91020: LD_EXP 71
91024: PUSH
91025: LD_VAR 0 3
91029: ARRAY
91030: PUSH
91031: LD_INT 1
91033: PLUS
91034: PUSH
91035: EMPTY
91036: LIST
91037: LIST
91038: PPUSH
91039: LD_VAR 0 1
91043: PPUSH
91044: CALL 22506 0 3
91048: ST_TO_ADDR
// if btype = b_bunker then
91049: LD_VAR 0 5
91053: PUSH
91054: LD_INT 32
91056: EQUAL
91057: IFFALSE 91293
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91059: LD_ADDR_EXP 72
91063: PUSH
91064: LD_EXP 72
91068: PPUSH
91069: LD_VAR 0 3
91073: PUSH
91074: LD_EXP 72
91078: PUSH
91079: LD_VAR 0 3
91083: ARRAY
91084: PUSH
91085: LD_INT 1
91087: PLUS
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PPUSH
91093: LD_VAR 0 1
91097: PPUSH
91098: CALL 22506 0 3
91102: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
91103: LD_ADDR_VAR 0 6
91107: PUSH
91108: LD_EXP 63
91112: PUSH
91113: LD_VAR 0 3
91117: ARRAY
91118: PPUSH
91119: LD_INT 25
91121: PUSH
91122: LD_INT 1
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: LD_INT 3
91131: PUSH
91132: LD_INT 54
91134: PUSH
91135: EMPTY
91136: LIST
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: EMPTY
91143: LIST
91144: LIST
91145: PPUSH
91146: CALL_OW 72
91150: ST_TO_ADDR
// if tmp then
91151: LD_VAR 0 6
91155: IFFALSE 91161
// exit ;
91157: POP
91158: POP
91159: GO 91301
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
91161: LD_ADDR_VAR 0 6
91165: PUSH
91166: LD_EXP 63
91170: PUSH
91171: LD_VAR 0 3
91175: ARRAY
91176: PPUSH
91177: LD_INT 2
91179: PUSH
91180: LD_INT 30
91182: PUSH
91183: LD_INT 4
91185: PUSH
91186: EMPTY
91187: LIST
91188: LIST
91189: PUSH
91190: LD_INT 30
91192: PUSH
91193: LD_INT 5
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: EMPTY
91201: LIST
91202: LIST
91203: LIST
91204: PPUSH
91205: CALL_OW 72
91209: ST_TO_ADDR
// if not tmp then
91210: LD_VAR 0 6
91214: NOT
91215: IFFALSE 91221
// exit ;
91217: POP
91218: POP
91219: GO 91301
// for j in tmp do
91221: LD_ADDR_VAR 0 4
91225: PUSH
91226: LD_VAR 0 6
91230: PUSH
91231: FOR_IN
91232: IFFALSE 91291
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
91234: LD_ADDR_VAR 0 7
91238: PUSH
91239: LD_VAR 0 4
91243: PPUSH
91244: CALL_OW 313
91248: PPUSH
91249: LD_INT 25
91251: PUSH
91252: LD_INT 1
91254: PUSH
91255: EMPTY
91256: LIST
91257: LIST
91258: PPUSH
91259: CALL_OW 72
91263: ST_TO_ADDR
// if units then
91264: LD_VAR 0 7
91268: IFFALSE 91289
// begin ComExitBuilding ( units [ 1 ] ) ;
91270: LD_VAR 0 7
91274: PUSH
91275: LD_INT 1
91277: ARRAY
91278: PPUSH
91279: CALL_OW 122
// exit ;
91283: POP
91284: POP
91285: POP
91286: POP
91287: GO 91301
// end ; end ;
91289: GO 91231
91291: POP
91292: POP
// end ; end ; exit ;
91293: POP
91294: POP
91295: GO 91301
// end ; end ;
91297: GO 90655
91299: POP
91300: POP
// end ;
91301: LD_VAR 0 2
91305: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
91306: LD_INT 0
91308: PPUSH
91309: PPUSH
91310: PPUSH
91311: PPUSH
91312: PPUSH
91313: PPUSH
91314: PPUSH
// if not mc_bases or not skirmish then
91315: LD_EXP 63
91319: NOT
91320: IFTRUE 91329
91322: PUSH
91323: LD_EXP 61
91327: NOT
91328: OR
91329: IFFALSE 91333
// exit ;
91331: GO 91598
// btype := GetBType ( building ) ;
91333: LD_ADDR_VAR 0 6
91337: PUSH
91338: LD_VAR 0 1
91342: PPUSH
91343: CALL_OW 266
91347: ST_TO_ADDR
// x := GetX ( building ) ;
91348: LD_ADDR_VAR 0 7
91352: PUSH
91353: LD_VAR 0 1
91357: PPUSH
91358: CALL_OW 250
91362: ST_TO_ADDR
// y := GetY ( building ) ;
91363: LD_ADDR_VAR 0 8
91367: PUSH
91368: LD_VAR 0 1
91372: PPUSH
91373: CALL_OW 251
91377: ST_TO_ADDR
// d := GetDir ( building ) ;
91378: LD_ADDR_VAR 0 9
91382: PUSH
91383: LD_VAR 0 1
91387: PPUSH
91388: CALL_OW 254
91392: ST_TO_ADDR
// for i = 1 to mc_bases do
91393: LD_ADDR_VAR 0 4
91397: PUSH
91398: DOUBLE
91399: LD_INT 1
91401: DEC
91402: ST_TO_ADDR
91403: LD_EXP 63
91407: PUSH
91408: FOR_TO
91409: IFFALSE 91596
// begin if not mc_build_list [ i ] then
91411: LD_EXP 68
91415: PUSH
91416: LD_VAR 0 4
91420: ARRAY
91421: NOT
91422: IFFALSE 91426
// continue ;
91424: GO 91408
// for j := 1 to mc_build_list [ i ] do
91426: LD_ADDR_VAR 0 5
91430: PUSH
91431: DOUBLE
91432: LD_INT 1
91434: DEC
91435: ST_TO_ADDR
91436: LD_EXP 68
91440: PUSH
91441: LD_VAR 0 4
91445: ARRAY
91446: PUSH
91447: FOR_TO
91448: IFFALSE 91592
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
91450: LD_VAR 0 6
91454: PUSH
91455: LD_VAR 0 7
91459: PUSH
91460: LD_VAR 0 8
91464: PUSH
91465: LD_VAR 0 9
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: PPUSH
91476: LD_EXP 68
91480: PUSH
91481: LD_VAR 0 4
91485: ARRAY
91486: PUSH
91487: LD_VAR 0 5
91491: ARRAY
91492: PPUSH
91493: CALL 29113 0 2
91497: IFFALSE 91590
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
91499: LD_ADDR_EXP 68
91503: PUSH
91504: LD_EXP 68
91508: PPUSH
91509: LD_VAR 0 4
91513: PPUSH
91514: LD_EXP 68
91518: PUSH
91519: LD_VAR 0 4
91523: ARRAY
91524: PPUSH
91525: LD_VAR 0 5
91529: PPUSH
91530: CALL_OW 3
91534: PPUSH
91535: CALL_OW 1
91539: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
91540: LD_ADDR_EXP 70
91544: PUSH
91545: LD_EXP 70
91549: PPUSH
91550: LD_VAR 0 4
91554: PUSH
91555: LD_EXP 70
91559: PUSH
91560: LD_VAR 0 4
91564: ARRAY
91565: PUSH
91566: LD_INT 1
91568: PLUS
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PPUSH
91574: LD_VAR 0 1
91578: PPUSH
91579: CALL 22506 0 3
91583: ST_TO_ADDR
// exit ;
91584: POP
91585: POP
91586: POP
91587: POP
91588: GO 91598
// end ;
91590: GO 91447
91592: POP
91593: POP
// end ;
91594: GO 91408
91596: POP
91597: POP
// end ;
91598: LD_VAR 0 3
91602: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
91603: LD_INT 0
91605: PPUSH
91606: PPUSH
91607: PPUSH
// if not mc_bases or not skirmish then
91608: LD_EXP 63
91612: NOT
91613: IFTRUE 91622
91615: PUSH
91616: LD_EXP 61
91620: NOT
91621: OR
91622: IFFALSE 91626
// exit ;
91624: GO 91822
// for i = 1 to mc_bases do
91626: LD_ADDR_VAR 0 4
91630: PUSH
91631: DOUBLE
91632: LD_INT 1
91634: DEC
91635: ST_TO_ADDR
91636: LD_EXP 63
91640: PUSH
91641: FOR_TO
91642: IFFALSE 91731
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
91644: LD_VAR 0 1
91648: PUSH
91649: LD_EXP 71
91653: PUSH
91654: LD_VAR 0 4
91658: ARRAY
91659: IN
91660: IFFALSE 91681
91662: PUSH
91663: LD_VAR 0 1
91667: PUSH
91668: LD_EXP 72
91672: PUSH
91673: LD_VAR 0 4
91677: ARRAY
91678: IN
91679: NOT
91680: AND
91681: IFFALSE 91729
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
91683: LD_ADDR_EXP 72
91687: PUSH
91688: LD_EXP 72
91692: PPUSH
91693: LD_VAR 0 4
91697: PUSH
91698: LD_EXP 72
91702: PUSH
91703: LD_VAR 0 4
91707: ARRAY
91708: PUSH
91709: LD_INT 1
91711: PLUS
91712: PUSH
91713: EMPTY
91714: LIST
91715: LIST
91716: PPUSH
91717: LD_VAR 0 1
91721: PPUSH
91722: CALL 22506 0 3
91726: ST_TO_ADDR
// break ;
91727: GO 91731
// end ; end ;
91729: GO 91641
91731: POP
91732: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
91733: LD_VAR 0 1
91737: PPUSH
91738: CALL_OW 257
91742: PUSH
91743: LD_EXP 89
91747: IN
91748: IFFALSE 91765
91750: PUSH
91751: LD_VAR 0 1
91755: PPUSH
91756: CALL_OW 266
91760: PUSH
91761: LD_INT 5
91763: EQUAL
91764: AND
91765: IFFALSE 91782
91767: PUSH
91768: LD_VAR 0 2
91772: PPUSH
91773: CALL_OW 110
91777: PUSH
91778: LD_INT 18
91780: NONEQUAL
91781: AND
91782: IFFALSE 91822
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
91784: LD_VAR 0 2
91788: PPUSH
91789: CALL_OW 257
91793: PUSH
91794: LD_INT 5
91796: PUSH
91797: LD_INT 8
91799: PUSH
91800: LD_INT 9
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: LIST
91807: IN
91808: IFFALSE 91822
// SetClass ( unit , 1 ) ;
91810: LD_VAR 0 2
91814: PPUSH
91815: LD_INT 1
91817: PPUSH
91818: CALL_OW 336
// end ;
91822: LD_VAR 0 3
91826: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
91827: LD_INT 0
91829: PPUSH
91830: PPUSH
// if not mc_bases or not skirmish then
91831: LD_EXP 63
91835: NOT
91836: IFTRUE 91845
91838: PUSH
91839: LD_EXP 61
91843: NOT
91844: OR
91845: IFFALSE 91849
// exit ;
91847: GO 91965
// if GetLives ( abandoned_vehicle ) > 250 then
91849: LD_VAR 0 2
91853: PPUSH
91854: CALL_OW 256
91858: PUSH
91859: LD_INT 250
91861: GREATER
91862: IFFALSE 91866
// exit ;
91864: GO 91965
// for i = 1 to mc_bases do
91866: LD_ADDR_VAR 0 6
91870: PUSH
91871: DOUBLE
91872: LD_INT 1
91874: DEC
91875: ST_TO_ADDR
91876: LD_EXP 63
91880: PUSH
91881: FOR_TO
91882: IFFALSE 91963
// begin if driver in mc_bases [ i ] then
91884: LD_VAR 0 1
91888: PUSH
91889: LD_EXP 63
91893: PUSH
91894: LD_VAR 0 6
91898: ARRAY
91899: IN
91900: IFFALSE 91961
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
91902: LD_VAR 0 1
91906: PPUSH
91907: LD_EXP 63
91911: PUSH
91912: LD_VAR 0 6
91916: ARRAY
91917: PPUSH
91918: LD_INT 2
91920: PUSH
91921: LD_INT 30
91923: PUSH
91924: LD_INT 0
91926: PUSH
91927: EMPTY
91928: LIST
91929: LIST
91930: PUSH
91931: LD_INT 30
91933: PUSH
91934: LD_INT 1
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: PPUSH
91946: CALL_OW 72
91950: PUSH
91951: LD_INT 1
91953: ARRAY
91954: PPUSH
91955: CALL 56433 0 2
// break ;
91959: GO 91963
// end ; end ;
91961: GO 91881
91963: POP
91964: POP
// end ; end_of_file end_of_file
91965: LD_VAR 0 5
91969: RET
// export globalGameSaveCounter ; every 0 0$1 do
91970: GO 91972
91972: DISABLE
// begin enable ;
91973: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91974: LD_STRING updateTimer(
91976: PUSH
91977: LD_OWVAR 1
91981: STR
91982: PUSH
91983: LD_STRING );
91985: STR
91986: PPUSH
91987: CALL_OW 559
// end ;
91991: END
// every 0 0$1 do
91992: GO 91994
91994: DISABLE
// begin globalGameSaveCounter := 0 ;
91995: LD_ADDR_EXP 108
91999: PUSH
92000: LD_INT 0
92002: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
92003: LD_STRING setGameSaveCounter(0)
92005: PPUSH
92006: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
92010: LD_STRING initStreamRollete();
92012: PPUSH
92013: CALL_OW 559
// InitStreamMode ;
92017: CALL 93362 0 0
// DefineStreamItems ( false ) ;
92021: LD_INT 0
92023: PPUSH
92024: CALL 93826 0 1
// end ;
92028: END
// export function SOS_MapStart ( ) ; begin
92029: LD_INT 0
92031: PPUSH
// if streamModeActive then
92032: LD_EXP 109
92036: IFFALSE 92045
// DefineStreamItems ( true ) ;
92038: LD_INT 1
92040: PPUSH
92041: CALL 93826 0 1
// UpdateLuaVariables ( ) ;
92045: CALL 92062 0 0
// UpdateFactoryWaypoints ( ) ;
92049: CALL 106948 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92053: CALL 107200 0 0
// end ;
92057: LD_VAR 0 1
92061: RET
// function UpdateLuaVariables ( ) ; begin
92062: LD_INT 0
92064: PPUSH
// if globalGameSaveCounter then
92065: LD_EXP 108
92069: IFFALSE 92103
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92071: LD_ADDR_EXP 108
92075: PUSH
92076: LD_EXP 108
92080: PPUSH
92081: CALL 56927 0 1
92085: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92086: LD_STRING setGameSaveCounter(
92088: PUSH
92089: LD_EXP 108
92093: STR
92094: PUSH
92095: LD_STRING )
92097: STR
92098: PPUSH
92099: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92103: LD_STRING setGameDifficulty(
92105: PUSH
92106: LD_OWVAR 67
92110: STR
92111: PUSH
92112: LD_STRING )
92114: STR
92115: PPUSH
92116: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92120: LD_STRING displayDifficulty(
92122: PUSH
92123: LD_OWVAR 67
92127: STR
92128: PUSH
92129: LD_STRING )
92131: STR
92132: PPUSH
92133: CALL_OW 559
// end ;
92137: LD_VAR 0 1
92141: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92142: LD_INT 0
92144: PPUSH
// if p2 = stream_mode then
92145: LD_VAR 0 2
92149: PUSH
92150: LD_INT 100
92152: EQUAL
92153: IFFALSE 93156
// begin if not StreamModeActive then
92155: LD_EXP 109
92159: NOT
92160: IFFALSE 92170
// StreamModeActive := true ;
92162: LD_ADDR_EXP 109
92166: PUSH
92167: LD_INT 1
92169: ST_TO_ADDR
// if p3 = 0 then
92170: LD_VAR 0 3
92174: PUSH
92175: LD_INT 0
92177: EQUAL
92178: IFFALSE 92184
// InitStreamMode ;
92180: CALL 93362 0 0
// if p3 = 1 then
92184: LD_VAR 0 3
92188: PUSH
92189: LD_INT 1
92191: EQUAL
92192: IFFALSE 92202
// sRocket := true ;
92194: LD_ADDR_EXP 114
92198: PUSH
92199: LD_INT 1
92201: ST_TO_ADDR
// if p3 = 2 then
92202: LD_VAR 0 3
92206: PUSH
92207: LD_INT 2
92209: EQUAL
92210: IFFALSE 92220
// sSpeed := true ;
92212: LD_ADDR_EXP 113
92216: PUSH
92217: LD_INT 1
92219: ST_TO_ADDR
// if p3 = 3 then
92220: LD_VAR 0 3
92224: PUSH
92225: LD_INT 3
92227: EQUAL
92228: IFFALSE 92238
// sEngine := true ;
92230: LD_ADDR_EXP 115
92234: PUSH
92235: LD_INT 1
92237: ST_TO_ADDR
// if p3 = 4 then
92238: LD_VAR 0 3
92242: PUSH
92243: LD_INT 4
92245: EQUAL
92246: IFFALSE 92256
// sSpec := true ;
92248: LD_ADDR_EXP 112
92252: PUSH
92253: LD_INT 1
92255: ST_TO_ADDR
// if p3 = 5 then
92256: LD_VAR 0 3
92260: PUSH
92261: LD_INT 5
92263: EQUAL
92264: IFFALSE 92274
// sLevel := true ;
92266: LD_ADDR_EXP 116
92270: PUSH
92271: LD_INT 1
92273: ST_TO_ADDR
// if p3 = 6 then
92274: LD_VAR 0 3
92278: PUSH
92279: LD_INT 6
92281: EQUAL
92282: IFFALSE 92292
// sArmoury := true ;
92284: LD_ADDR_EXP 117
92288: PUSH
92289: LD_INT 1
92291: ST_TO_ADDR
// if p3 = 7 then
92292: LD_VAR 0 3
92296: PUSH
92297: LD_INT 7
92299: EQUAL
92300: IFFALSE 92310
// sRadar := true ;
92302: LD_ADDR_EXP 118
92306: PUSH
92307: LD_INT 1
92309: ST_TO_ADDR
// if p3 = 8 then
92310: LD_VAR 0 3
92314: PUSH
92315: LD_INT 8
92317: EQUAL
92318: IFFALSE 92328
// sBunker := true ;
92320: LD_ADDR_EXP 119
92324: PUSH
92325: LD_INT 1
92327: ST_TO_ADDR
// if p3 = 9 then
92328: LD_VAR 0 3
92332: PUSH
92333: LD_INT 9
92335: EQUAL
92336: IFFALSE 92346
// sHack := true ;
92338: LD_ADDR_EXP 120
92342: PUSH
92343: LD_INT 1
92345: ST_TO_ADDR
// if p3 = 10 then
92346: LD_VAR 0 3
92350: PUSH
92351: LD_INT 10
92353: EQUAL
92354: IFFALSE 92364
// sFire := true ;
92356: LD_ADDR_EXP 121
92360: PUSH
92361: LD_INT 1
92363: ST_TO_ADDR
// if p3 = 11 then
92364: LD_VAR 0 3
92368: PUSH
92369: LD_INT 11
92371: EQUAL
92372: IFFALSE 92382
// sRefresh := true ;
92374: LD_ADDR_EXP 122
92378: PUSH
92379: LD_INT 1
92381: ST_TO_ADDR
// if p3 = 12 then
92382: LD_VAR 0 3
92386: PUSH
92387: LD_INT 12
92389: EQUAL
92390: IFFALSE 92400
// sExp := true ;
92392: LD_ADDR_EXP 123
92396: PUSH
92397: LD_INT 1
92399: ST_TO_ADDR
// if p3 = 13 then
92400: LD_VAR 0 3
92404: PUSH
92405: LD_INT 13
92407: EQUAL
92408: IFFALSE 92418
// sDepot := true ;
92410: LD_ADDR_EXP 124
92414: PUSH
92415: LD_INT 1
92417: ST_TO_ADDR
// if p3 = 14 then
92418: LD_VAR 0 3
92422: PUSH
92423: LD_INT 14
92425: EQUAL
92426: IFFALSE 92436
// sFlag := true ;
92428: LD_ADDR_EXP 125
92432: PUSH
92433: LD_INT 1
92435: ST_TO_ADDR
// if p3 = 15 then
92436: LD_VAR 0 3
92440: PUSH
92441: LD_INT 15
92443: EQUAL
92444: IFFALSE 92454
// sKamikadze := true ;
92446: LD_ADDR_EXP 133
92450: PUSH
92451: LD_INT 1
92453: ST_TO_ADDR
// if p3 = 16 then
92454: LD_VAR 0 3
92458: PUSH
92459: LD_INT 16
92461: EQUAL
92462: IFFALSE 92472
// sTroll := true ;
92464: LD_ADDR_EXP 134
92468: PUSH
92469: LD_INT 1
92471: ST_TO_ADDR
// if p3 = 17 then
92472: LD_VAR 0 3
92476: PUSH
92477: LD_INT 17
92479: EQUAL
92480: IFFALSE 92490
// sSlow := true ;
92482: LD_ADDR_EXP 135
92486: PUSH
92487: LD_INT 1
92489: ST_TO_ADDR
// if p3 = 18 then
92490: LD_VAR 0 3
92494: PUSH
92495: LD_INT 18
92497: EQUAL
92498: IFFALSE 92508
// sLack := true ;
92500: LD_ADDR_EXP 136
92504: PUSH
92505: LD_INT 1
92507: ST_TO_ADDR
// if p3 = 19 then
92508: LD_VAR 0 3
92512: PUSH
92513: LD_INT 19
92515: EQUAL
92516: IFFALSE 92526
// sTank := true ;
92518: LD_ADDR_EXP 138
92522: PUSH
92523: LD_INT 1
92525: ST_TO_ADDR
// if p3 = 20 then
92526: LD_VAR 0 3
92530: PUSH
92531: LD_INT 20
92533: EQUAL
92534: IFFALSE 92544
// sRemote := true ;
92536: LD_ADDR_EXP 139
92540: PUSH
92541: LD_INT 1
92543: ST_TO_ADDR
// if p3 = 21 then
92544: LD_VAR 0 3
92548: PUSH
92549: LD_INT 21
92551: EQUAL
92552: IFFALSE 92562
// sPowell := true ;
92554: LD_ADDR_EXP 140
92558: PUSH
92559: LD_INT 1
92561: ST_TO_ADDR
// if p3 = 22 then
92562: LD_VAR 0 3
92566: PUSH
92567: LD_INT 22
92569: EQUAL
92570: IFFALSE 92580
// sTeleport := true ;
92572: LD_ADDR_EXP 143
92576: PUSH
92577: LD_INT 1
92579: ST_TO_ADDR
// if p3 = 23 then
92580: LD_VAR 0 3
92584: PUSH
92585: LD_INT 23
92587: EQUAL
92588: IFFALSE 92598
// sOilTower := true ;
92590: LD_ADDR_EXP 145
92594: PUSH
92595: LD_INT 1
92597: ST_TO_ADDR
// if p3 = 24 then
92598: LD_VAR 0 3
92602: PUSH
92603: LD_INT 24
92605: EQUAL
92606: IFFALSE 92616
// sShovel := true ;
92608: LD_ADDR_EXP 146
92612: PUSH
92613: LD_INT 1
92615: ST_TO_ADDR
// if p3 = 25 then
92616: LD_VAR 0 3
92620: PUSH
92621: LD_INT 25
92623: EQUAL
92624: IFFALSE 92634
// sSheik := true ;
92626: LD_ADDR_EXP 147
92630: PUSH
92631: LD_INT 1
92633: ST_TO_ADDR
// if p3 = 26 then
92634: LD_VAR 0 3
92638: PUSH
92639: LD_INT 26
92641: EQUAL
92642: IFFALSE 92652
// sEarthquake := true ;
92644: LD_ADDR_EXP 149
92648: PUSH
92649: LD_INT 1
92651: ST_TO_ADDR
// if p3 = 27 then
92652: LD_VAR 0 3
92656: PUSH
92657: LD_INT 27
92659: EQUAL
92660: IFFALSE 92670
// sAI := true ;
92662: LD_ADDR_EXP 150
92666: PUSH
92667: LD_INT 1
92669: ST_TO_ADDR
// if p3 = 28 then
92670: LD_VAR 0 3
92674: PUSH
92675: LD_INT 28
92677: EQUAL
92678: IFFALSE 92688
// sCargo := true ;
92680: LD_ADDR_EXP 153
92684: PUSH
92685: LD_INT 1
92687: ST_TO_ADDR
// if p3 = 29 then
92688: LD_VAR 0 3
92692: PUSH
92693: LD_INT 29
92695: EQUAL
92696: IFFALSE 92706
// sDLaser := true ;
92698: LD_ADDR_EXP 154
92702: PUSH
92703: LD_INT 1
92705: ST_TO_ADDR
// if p3 = 30 then
92706: LD_VAR 0 3
92710: PUSH
92711: LD_INT 30
92713: EQUAL
92714: IFFALSE 92724
// sExchange := true ;
92716: LD_ADDR_EXP 155
92720: PUSH
92721: LD_INT 1
92723: ST_TO_ADDR
// if p3 = 31 then
92724: LD_VAR 0 3
92728: PUSH
92729: LD_INT 31
92731: EQUAL
92732: IFFALSE 92742
// sFac := true ;
92734: LD_ADDR_EXP 156
92738: PUSH
92739: LD_INT 1
92741: ST_TO_ADDR
// if p3 = 32 then
92742: LD_VAR 0 3
92746: PUSH
92747: LD_INT 32
92749: EQUAL
92750: IFFALSE 92760
// sPower := true ;
92752: LD_ADDR_EXP 157
92756: PUSH
92757: LD_INT 1
92759: ST_TO_ADDR
// if p3 = 33 then
92760: LD_VAR 0 3
92764: PUSH
92765: LD_INT 33
92767: EQUAL
92768: IFFALSE 92778
// sRandom := true ;
92770: LD_ADDR_EXP 158
92774: PUSH
92775: LD_INT 1
92777: ST_TO_ADDR
// if p3 = 34 then
92778: LD_VAR 0 3
92782: PUSH
92783: LD_INT 34
92785: EQUAL
92786: IFFALSE 92796
// sShield := true ;
92788: LD_ADDR_EXP 159
92792: PUSH
92793: LD_INT 1
92795: ST_TO_ADDR
// if p3 = 35 then
92796: LD_VAR 0 3
92800: PUSH
92801: LD_INT 35
92803: EQUAL
92804: IFFALSE 92814
// sTime := true ;
92806: LD_ADDR_EXP 160
92810: PUSH
92811: LD_INT 1
92813: ST_TO_ADDR
// if p3 = 36 then
92814: LD_VAR 0 3
92818: PUSH
92819: LD_INT 36
92821: EQUAL
92822: IFFALSE 92832
// sTools := true ;
92824: LD_ADDR_EXP 161
92828: PUSH
92829: LD_INT 1
92831: ST_TO_ADDR
// if p3 = 101 then
92832: LD_VAR 0 3
92836: PUSH
92837: LD_INT 101
92839: EQUAL
92840: IFFALSE 92850
// sSold := true ;
92842: LD_ADDR_EXP 126
92846: PUSH
92847: LD_INT 1
92849: ST_TO_ADDR
// if p3 = 102 then
92850: LD_VAR 0 3
92854: PUSH
92855: LD_INT 102
92857: EQUAL
92858: IFFALSE 92868
// sDiff := true ;
92860: LD_ADDR_EXP 127
92864: PUSH
92865: LD_INT 1
92867: ST_TO_ADDR
// if p3 = 103 then
92868: LD_VAR 0 3
92872: PUSH
92873: LD_INT 103
92875: EQUAL
92876: IFFALSE 92886
// sFog := true ;
92878: LD_ADDR_EXP 130
92882: PUSH
92883: LD_INT 1
92885: ST_TO_ADDR
// if p3 = 104 then
92886: LD_VAR 0 3
92890: PUSH
92891: LD_INT 104
92893: EQUAL
92894: IFFALSE 92904
// sReset := true ;
92896: LD_ADDR_EXP 131
92900: PUSH
92901: LD_INT 1
92903: ST_TO_ADDR
// if p3 = 105 then
92904: LD_VAR 0 3
92908: PUSH
92909: LD_INT 105
92911: EQUAL
92912: IFFALSE 92922
// sSun := true ;
92914: LD_ADDR_EXP 132
92918: PUSH
92919: LD_INT 1
92921: ST_TO_ADDR
// if p3 = 106 then
92922: LD_VAR 0 3
92926: PUSH
92927: LD_INT 106
92929: EQUAL
92930: IFFALSE 92940
// sTiger := true ;
92932: LD_ADDR_EXP 128
92936: PUSH
92937: LD_INT 1
92939: ST_TO_ADDR
// if p3 = 107 then
92940: LD_VAR 0 3
92944: PUSH
92945: LD_INT 107
92947: EQUAL
92948: IFFALSE 92958
// sBomb := true ;
92950: LD_ADDR_EXP 129
92954: PUSH
92955: LD_INT 1
92957: ST_TO_ADDR
// if p3 = 108 then
92958: LD_VAR 0 3
92962: PUSH
92963: LD_INT 108
92965: EQUAL
92966: IFFALSE 92976
// sWound := true ;
92968: LD_ADDR_EXP 137
92972: PUSH
92973: LD_INT 1
92975: ST_TO_ADDR
// if p3 = 109 then
92976: LD_VAR 0 3
92980: PUSH
92981: LD_INT 109
92983: EQUAL
92984: IFFALSE 92994
// sBetray := true ;
92986: LD_ADDR_EXP 141
92990: PUSH
92991: LD_INT 1
92993: ST_TO_ADDR
// if p3 = 110 then
92994: LD_VAR 0 3
92998: PUSH
92999: LD_INT 110
93001: EQUAL
93002: IFFALSE 93012
// sContamin := true ;
93004: LD_ADDR_EXP 142
93008: PUSH
93009: LD_INT 1
93011: ST_TO_ADDR
// if p3 = 111 then
93012: LD_VAR 0 3
93016: PUSH
93017: LD_INT 111
93019: EQUAL
93020: IFFALSE 93030
// sOil := true ;
93022: LD_ADDR_EXP 144
93026: PUSH
93027: LD_INT 1
93029: ST_TO_ADDR
// if p3 = 112 then
93030: LD_VAR 0 3
93034: PUSH
93035: LD_INT 112
93037: EQUAL
93038: IFFALSE 93048
// sStu := true ;
93040: LD_ADDR_EXP 148
93044: PUSH
93045: LD_INT 1
93047: ST_TO_ADDR
// if p3 = 113 then
93048: LD_VAR 0 3
93052: PUSH
93053: LD_INT 113
93055: EQUAL
93056: IFFALSE 93066
// sBazooka := true ;
93058: LD_ADDR_EXP 151
93062: PUSH
93063: LD_INT 1
93065: ST_TO_ADDR
// if p3 = 114 then
93066: LD_VAR 0 3
93070: PUSH
93071: LD_INT 114
93073: EQUAL
93074: IFFALSE 93084
// sMortar := true ;
93076: LD_ADDR_EXP 152
93080: PUSH
93081: LD_INT 1
93083: ST_TO_ADDR
// if p3 = 115 then
93084: LD_VAR 0 3
93088: PUSH
93089: LD_INT 115
93091: EQUAL
93092: IFFALSE 93102
// sRanger := true ;
93094: LD_ADDR_EXP 162
93098: PUSH
93099: LD_INT 1
93101: ST_TO_ADDR
// if p3 = 116 then
93102: LD_VAR 0 3
93106: PUSH
93107: LD_INT 116
93109: EQUAL
93110: IFFALSE 93120
// sComputer := true ;
93112: LD_ADDR_EXP 163
93116: PUSH
93117: LD_INT 1
93119: ST_TO_ADDR
// if p3 = 117 then
93120: LD_VAR 0 3
93124: PUSH
93125: LD_INT 117
93127: EQUAL
93128: IFFALSE 93138
// s30 := true ;
93130: LD_ADDR_EXP 164
93134: PUSH
93135: LD_INT 1
93137: ST_TO_ADDR
// if p3 = 118 then
93138: LD_VAR 0 3
93142: PUSH
93143: LD_INT 118
93145: EQUAL
93146: IFFALSE 93156
// s60 := true ;
93148: LD_ADDR_EXP 165
93152: PUSH
93153: LD_INT 1
93155: ST_TO_ADDR
// end ; if p2 = hack_mode then
93156: LD_VAR 0 2
93160: PUSH
93161: LD_INT 101
93163: EQUAL
93164: IFFALSE 93292
// begin case p3 of 1 :
93166: LD_VAR 0 3
93170: PUSH
93171: LD_INT 1
93173: DOUBLE
93174: EQUAL
93175: IFTRUE 93179
93177: GO 93186
93179: POP
// hHackUnlimitedResources ; 2 :
93180: CALL 105555 0 0
93184: GO 93292
93186: LD_INT 2
93188: DOUBLE
93189: EQUAL
93190: IFTRUE 93194
93192: GO 93201
93194: POP
// hHackSetLevel10 ; 3 :
93195: CALL 105688 0 0
93199: GO 93292
93201: LD_INT 3
93203: DOUBLE
93204: EQUAL
93205: IFTRUE 93209
93207: GO 93216
93209: POP
// hHackSetLevel10YourUnits ; 4 :
93210: CALL 105773 0 0
93214: GO 93292
93216: LD_INT 4
93218: DOUBLE
93219: EQUAL
93220: IFTRUE 93224
93222: GO 93231
93224: POP
// hHackInvincible ; 5 :
93225: CALL 106221 0 0
93229: GO 93292
93231: LD_INT 5
93233: DOUBLE
93234: EQUAL
93235: IFTRUE 93239
93237: GO 93246
93239: POP
// hHackInvisible ; 6 :
93240: CALL 106332 0 0
93244: GO 93292
93246: LD_INT 6
93248: DOUBLE
93249: EQUAL
93250: IFTRUE 93254
93252: GO 93261
93254: POP
// hHackChangeYourSide ; 7 :
93255: CALL 106389 0 0
93259: GO 93292
93261: LD_INT 7
93263: DOUBLE
93264: EQUAL
93265: IFTRUE 93269
93267: GO 93276
93269: POP
// hHackChangeUnitSide ; 8 :
93270: CALL 106431 0 0
93274: GO 93292
93276: LD_INT 8
93278: DOUBLE
93279: EQUAL
93280: IFTRUE 93284
93282: GO 93291
93284: POP
// hHackFog ; end ;
93285: CALL 106532 0 0
93289: GO 93292
93291: POP
// end ; if p2 = game_save_mode then
93292: LD_VAR 0 2
93296: PUSH
93297: LD_INT 102
93299: EQUAL
93300: IFFALSE 93357
// begin if p3 = 1 then
93302: LD_VAR 0 3
93306: PUSH
93307: LD_INT 1
93309: EQUAL
93310: IFFALSE 93322
// globalGameSaveCounter := p4 ;
93312: LD_ADDR_EXP 108
93316: PUSH
93317: LD_VAR 0 4
93321: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93322: LD_VAR 0 3
93326: PUSH
93327: LD_INT 2
93329: EQUAL
93330: IFFALSE 93338
93332: PUSH
93333: LD_EXP 108
93337: AND
93338: IFFALSE 93357
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93340: LD_STRING setGameSaveCounter(
93342: PUSH
93343: LD_EXP 108
93347: STR
93348: PUSH
93349: LD_STRING )
93351: STR
93352: PPUSH
93353: CALL_OW 559
// end ; end ;
93357: LD_VAR 0 7
93361: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93362: LD_INT 0
93364: PPUSH
// streamModeActive := false ;
93365: LD_ADDR_EXP 109
93369: PUSH
93370: LD_INT 0
93372: ST_TO_ADDR
// normalCounter := 36 ;
93373: LD_ADDR_EXP 110
93377: PUSH
93378: LD_INT 36
93380: ST_TO_ADDR
// hardcoreCounter := 18 ;
93381: LD_ADDR_EXP 111
93385: PUSH
93386: LD_INT 18
93388: ST_TO_ADDR
// sRocket := false ;
93389: LD_ADDR_EXP 114
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// sSpeed := false ;
93397: LD_ADDR_EXP 113
93401: PUSH
93402: LD_INT 0
93404: ST_TO_ADDR
// sEngine := false ;
93405: LD_ADDR_EXP 115
93409: PUSH
93410: LD_INT 0
93412: ST_TO_ADDR
// sSpec := false ;
93413: LD_ADDR_EXP 112
93417: PUSH
93418: LD_INT 0
93420: ST_TO_ADDR
// sLevel := false ;
93421: LD_ADDR_EXP 116
93425: PUSH
93426: LD_INT 0
93428: ST_TO_ADDR
// sArmoury := false ;
93429: LD_ADDR_EXP 117
93433: PUSH
93434: LD_INT 0
93436: ST_TO_ADDR
// sRadar := false ;
93437: LD_ADDR_EXP 118
93441: PUSH
93442: LD_INT 0
93444: ST_TO_ADDR
// sBunker := false ;
93445: LD_ADDR_EXP 119
93449: PUSH
93450: LD_INT 0
93452: ST_TO_ADDR
// sHack := false ;
93453: LD_ADDR_EXP 120
93457: PUSH
93458: LD_INT 0
93460: ST_TO_ADDR
// sFire := false ;
93461: LD_ADDR_EXP 121
93465: PUSH
93466: LD_INT 0
93468: ST_TO_ADDR
// sRefresh := false ;
93469: LD_ADDR_EXP 122
93473: PUSH
93474: LD_INT 0
93476: ST_TO_ADDR
// sExp := false ;
93477: LD_ADDR_EXP 123
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// sDepot := false ;
93485: LD_ADDR_EXP 124
93489: PUSH
93490: LD_INT 0
93492: ST_TO_ADDR
// sFlag := false ;
93493: LD_ADDR_EXP 125
93497: PUSH
93498: LD_INT 0
93500: ST_TO_ADDR
// sKamikadze := false ;
93501: LD_ADDR_EXP 133
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// sTroll := false ;
93509: LD_ADDR_EXP 134
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// sSlow := false ;
93517: LD_ADDR_EXP 135
93521: PUSH
93522: LD_INT 0
93524: ST_TO_ADDR
// sLack := false ;
93525: LD_ADDR_EXP 136
93529: PUSH
93530: LD_INT 0
93532: ST_TO_ADDR
// sTank := false ;
93533: LD_ADDR_EXP 138
93537: PUSH
93538: LD_INT 0
93540: ST_TO_ADDR
// sRemote := false ;
93541: LD_ADDR_EXP 139
93545: PUSH
93546: LD_INT 0
93548: ST_TO_ADDR
// sPowell := false ;
93549: LD_ADDR_EXP 140
93553: PUSH
93554: LD_INT 0
93556: ST_TO_ADDR
// sTeleport := false ;
93557: LD_ADDR_EXP 143
93561: PUSH
93562: LD_INT 0
93564: ST_TO_ADDR
// sOilTower := false ;
93565: LD_ADDR_EXP 145
93569: PUSH
93570: LD_INT 0
93572: ST_TO_ADDR
// sShovel := false ;
93573: LD_ADDR_EXP 146
93577: PUSH
93578: LD_INT 0
93580: ST_TO_ADDR
// sSheik := false ;
93581: LD_ADDR_EXP 147
93585: PUSH
93586: LD_INT 0
93588: ST_TO_ADDR
// sEarthquake := false ;
93589: LD_ADDR_EXP 149
93593: PUSH
93594: LD_INT 0
93596: ST_TO_ADDR
// sAI := false ;
93597: LD_ADDR_EXP 150
93601: PUSH
93602: LD_INT 0
93604: ST_TO_ADDR
// sCargo := false ;
93605: LD_ADDR_EXP 153
93609: PUSH
93610: LD_INT 0
93612: ST_TO_ADDR
// sDLaser := false ;
93613: LD_ADDR_EXP 154
93617: PUSH
93618: LD_INT 0
93620: ST_TO_ADDR
// sExchange := false ;
93621: LD_ADDR_EXP 155
93625: PUSH
93626: LD_INT 0
93628: ST_TO_ADDR
// sFac := false ;
93629: LD_ADDR_EXP 156
93633: PUSH
93634: LD_INT 0
93636: ST_TO_ADDR
// sPower := false ;
93637: LD_ADDR_EXP 157
93641: PUSH
93642: LD_INT 0
93644: ST_TO_ADDR
// sRandom := false ;
93645: LD_ADDR_EXP 158
93649: PUSH
93650: LD_INT 0
93652: ST_TO_ADDR
// sShield := false ;
93653: LD_ADDR_EXP 159
93657: PUSH
93658: LD_INT 0
93660: ST_TO_ADDR
// sTime := false ;
93661: LD_ADDR_EXP 160
93665: PUSH
93666: LD_INT 0
93668: ST_TO_ADDR
// sTools := false ;
93669: LD_ADDR_EXP 161
93673: PUSH
93674: LD_INT 0
93676: ST_TO_ADDR
// sSold := false ;
93677: LD_ADDR_EXP 126
93681: PUSH
93682: LD_INT 0
93684: ST_TO_ADDR
// sDiff := false ;
93685: LD_ADDR_EXP 127
93689: PUSH
93690: LD_INT 0
93692: ST_TO_ADDR
// sFog := false ;
93693: LD_ADDR_EXP 130
93697: PUSH
93698: LD_INT 0
93700: ST_TO_ADDR
// sReset := false ;
93701: LD_ADDR_EXP 131
93705: PUSH
93706: LD_INT 0
93708: ST_TO_ADDR
// sSun := false ;
93709: LD_ADDR_EXP 132
93713: PUSH
93714: LD_INT 0
93716: ST_TO_ADDR
// sTiger := false ;
93717: LD_ADDR_EXP 128
93721: PUSH
93722: LD_INT 0
93724: ST_TO_ADDR
// sBomb := false ;
93725: LD_ADDR_EXP 129
93729: PUSH
93730: LD_INT 0
93732: ST_TO_ADDR
// sWound := false ;
93733: LD_ADDR_EXP 137
93737: PUSH
93738: LD_INT 0
93740: ST_TO_ADDR
// sBetray := false ;
93741: LD_ADDR_EXP 141
93745: PUSH
93746: LD_INT 0
93748: ST_TO_ADDR
// sContamin := false ;
93749: LD_ADDR_EXP 142
93753: PUSH
93754: LD_INT 0
93756: ST_TO_ADDR
// sOil := false ;
93757: LD_ADDR_EXP 144
93761: PUSH
93762: LD_INT 0
93764: ST_TO_ADDR
// sStu := false ;
93765: LD_ADDR_EXP 148
93769: PUSH
93770: LD_INT 0
93772: ST_TO_ADDR
// sBazooka := false ;
93773: LD_ADDR_EXP 151
93777: PUSH
93778: LD_INT 0
93780: ST_TO_ADDR
// sMortar := false ;
93781: LD_ADDR_EXP 152
93785: PUSH
93786: LD_INT 0
93788: ST_TO_ADDR
// sRanger := false ;
93789: LD_ADDR_EXP 162
93793: PUSH
93794: LD_INT 0
93796: ST_TO_ADDR
// sComputer := false ;
93797: LD_ADDR_EXP 163
93801: PUSH
93802: LD_INT 0
93804: ST_TO_ADDR
// s30 := false ;
93805: LD_ADDR_EXP 164
93809: PUSH
93810: LD_INT 0
93812: ST_TO_ADDR
// s60 := false ;
93813: LD_ADDR_EXP 165
93817: PUSH
93818: LD_INT 0
93820: ST_TO_ADDR
// end ;
93821: LD_VAR 0 1
93825: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93826: LD_INT 0
93828: PPUSH
93829: PPUSH
93830: PPUSH
93831: PPUSH
93832: PPUSH
93833: PPUSH
93834: PPUSH
// result := [ ] ;
93835: LD_ADDR_VAR 0 2
93839: PUSH
93840: EMPTY
93841: ST_TO_ADDR
// if campaign_id = 1 then
93842: LD_OWVAR 69
93846: PUSH
93847: LD_INT 1
93849: EQUAL
93850: IFFALSE 97016
// begin case mission_number of 1 :
93852: LD_OWVAR 70
93856: PUSH
93857: LD_INT 1
93859: DOUBLE
93860: EQUAL
93861: IFTRUE 93865
93863: GO 93941
93865: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93866: LD_ADDR_VAR 0 2
93870: PUSH
93871: LD_INT 2
93873: PUSH
93874: LD_INT 4
93876: PUSH
93877: LD_INT 11
93879: PUSH
93880: LD_INT 12
93882: PUSH
93883: LD_INT 15
93885: PUSH
93886: LD_INT 16
93888: PUSH
93889: LD_INT 22
93891: PUSH
93892: LD_INT 23
93894: PUSH
93895: LD_INT 26
93897: PUSH
93898: EMPTY
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 101
93911: PUSH
93912: LD_INT 102
93914: PUSH
93915: LD_INT 106
93917: PUSH
93918: LD_INT 116
93920: PUSH
93921: LD_INT 117
93923: PUSH
93924: LD_INT 118
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: PUSH
93935: EMPTY
93936: LIST
93937: LIST
93938: ST_TO_ADDR
93939: GO 97014
93941: LD_INT 2
93943: DOUBLE
93944: EQUAL
93945: IFTRUE 93949
93947: GO 94033
93949: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93950: LD_ADDR_VAR 0 2
93954: PUSH
93955: LD_INT 2
93957: PUSH
93958: LD_INT 4
93960: PUSH
93961: LD_INT 11
93963: PUSH
93964: LD_INT 12
93966: PUSH
93967: LD_INT 15
93969: PUSH
93970: LD_INT 16
93972: PUSH
93973: LD_INT 22
93975: PUSH
93976: LD_INT 23
93978: PUSH
93979: LD_INT 26
93981: PUSH
93982: EMPTY
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: PUSH
93993: LD_INT 101
93995: PUSH
93996: LD_INT 102
93998: PUSH
93999: LD_INT 105
94001: PUSH
94002: LD_INT 106
94004: PUSH
94005: LD_INT 108
94007: PUSH
94008: LD_INT 116
94010: PUSH
94011: LD_INT 117
94013: PUSH
94014: LD_INT 118
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: ST_TO_ADDR
94031: GO 97014
94033: LD_INT 3
94035: DOUBLE
94036: EQUAL
94037: IFTRUE 94041
94039: GO 94129
94041: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94042: LD_ADDR_VAR 0 2
94046: PUSH
94047: LD_INT 2
94049: PUSH
94050: LD_INT 4
94052: PUSH
94053: LD_INT 5
94055: PUSH
94056: LD_INT 11
94058: PUSH
94059: LD_INT 12
94061: PUSH
94062: LD_INT 15
94064: PUSH
94065: LD_INT 16
94067: PUSH
94068: LD_INT 22
94070: PUSH
94071: LD_INT 26
94073: PUSH
94074: LD_INT 36
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: LIST
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 101
94091: PUSH
94092: LD_INT 102
94094: PUSH
94095: LD_INT 105
94097: PUSH
94098: LD_INT 106
94100: PUSH
94101: LD_INT 108
94103: PUSH
94104: LD_INT 116
94106: PUSH
94107: LD_INT 117
94109: PUSH
94110: LD_INT 118
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: PUSH
94123: EMPTY
94124: LIST
94125: LIST
94126: ST_TO_ADDR
94127: GO 97014
94129: LD_INT 4
94131: DOUBLE
94132: EQUAL
94133: IFTRUE 94137
94135: GO 94233
94137: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94138: LD_ADDR_VAR 0 2
94142: PUSH
94143: LD_INT 2
94145: PUSH
94146: LD_INT 4
94148: PUSH
94149: LD_INT 5
94151: PUSH
94152: LD_INT 8
94154: PUSH
94155: LD_INT 11
94157: PUSH
94158: LD_INT 12
94160: PUSH
94161: LD_INT 15
94163: PUSH
94164: LD_INT 16
94166: PUSH
94167: LD_INT 22
94169: PUSH
94170: LD_INT 23
94172: PUSH
94173: LD_INT 26
94175: PUSH
94176: LD_INT 36
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 101
94195: PUSH
94196: LD_INT 102
94198: PUSH
94199: LD_INT 105
94201: PUSH
94202: LD_INT 106
94204: PUSH
94205: LD_INT 108
94207: PUSH
94208: LD_INT 116
94210: PUSH
94211: LD_INT 117
94213: PUSH
94214: LD_INT 118
94216: PUSH
94217: EMPTY
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: LIST
94224: LIST
94225: LIST
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: ST_TO_ADDR
94231: GO 97014
94233: LD_INT 5
94235: DOUBLE
94236: EQUAL
94237: IFTRUE 94241
94239: GO 94353
94241: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94242: LD_ADDR_VAR 0 2
94246: PUSH
94247: LD_INT 2
94249: PUSH
94250: LD_INT 4
94252: PUSH
94253: LD_INT 5
94255: PUSH
94256: LD_INT 6
94258: PUSH
94259: LD_INT 8
94261: PUSH
94262: LD_INT 11
94264: PUSH
94265: LD_INT 12
94267: PUSH
94268: LD_INT 15
94270: PUSH
94271: LD_INT 16
94273: PUSH
94274: LD_INT 22
94276: PUSH
94277: LD_INT 23
94279: PUSH
94280: LD_INT 25
94282: PUSH
94283: LD_INT 26
94285: PUSH
94286: LD_INT 36
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: LIST
94293: LIST
94294: LIST
94295: LIST
94296: LIST
94297: LIST
94298: LIST
94299: LIST
94300: LIST
94301: LIST
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 101
94307: PUSH
94308: LD_INT 102
94310: PUSH
94311: LD_INT 105
94313: PUSH
94314: LD_INT 106
94316: PUSH
94317: LD_INT 108
94319: PUSH
94320: LD_INT 109
94322: PUSH
94323: LD_INT 112
94325: PUSH
94326: LD_INT 116
94328: PUSH
94329: LD_INT 117
94331: PUSH
94332: LD_INT 118
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: PUSH
94347: EMPTY
94348: LIST
94349: LIST
94350: ST_TO_ADDR
94351: GO 97014
94353: LD_INT 6
94355: DOUBLE
94356: EQUAL
94357: IFTRUE 94361
94359: GO 94493
94361: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94362: LD_ADDR_VAR 0 2
94366: PUSH
94367: LD_INT 2
94369: PUSH
94370: LD_INT 4
94372: PUSH
94373: LD_INT 5
94375: PUSH
94376: LD_INT 6
94378: PUSH
94379: LD_INT 8
94381: PUSH
94382: LD_INT 11
94384: PUSH
94385: LD_INT 12
94387: PUSH
94388: LD_INT 15
94390: PUSH
94391: LD_INT 16
94393: PUSH
94394: LD_INT 20
94396: PUSH
94397: LD_INT 21
94399: PUSH
94400: LD_INT 22
94402: PUSH
94403: LD_INT 23
94405: PUSH
94406: LD_INT 25
94408: PUSH
94409: LD_INT 26
94411: PUSH
94412: LD_INT 30
94414: PUSH
94415: LD_INT 31
94417: PUSH
94418: LD_INT 32
94420: PUSH
94421: LD_INT 36
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: LIST
94430: LIST
94431: LIST
94432: LIST
94433: LIST
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 101
94447: PUSH
94448: LD_INT 102
94450: PUSH
94451: LD_INT 105
94453: PUSH
94454: LD_INT 106
94456: PUSH
94457: LD_INT 108
94459: PUSH
94460: LD_INT 109
94462: PUSH
94463: LD_INT 112
94465: PUSH
94466: LD_INT 116
94468: PUSH
94469: LD_INT 117
94471: PUSH
94472: LD_INT 118
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: ST_TO_ADDR
94491: GO 97014
94493: LD_INT 7
94495: DOUBLE
94496: EQUAL
94497: IFTRUE 94501
94499: GO 94613
94501: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94502: LD_ADDR_VAR 0 2
94506: PUSH
94507: LD_INT 2
94509: PUSH
94510: LD_INT 4
94512: PUSH
94513: LD_INT 5
94515: PUSH
94516: LD_INT 7
94518: PUSH
94519: LD_INT 11
94521: PUSH
94522: LD_INT 12
94524: PUSH
94525: LD_INT 15
94527: PUSH
94528: LD_INT 16
94530: PUSH
94531: LD_INT 20
94533: PUSH
94534: LD_INT 21
94536: PUSH
94537: LD_INT 22
94539: PUSH
94540: LD_INT 23
94542: PUSH
94543: LD_INT 25
94545: PUSH
94546: LD_INT 26
94548: PUSH
94549: EMPTY
94550: LIST
94551: LIST
94552: LIST
94553: LIST
94554: LIST
94555: LIST
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 101
94567: PUSH
94568: LD_INT 102
94570: PUSH
94571: LD_INT 103
94573: PUSH
94574: LD_INT 105
94576: PUSH
94577: LD_INT 106
94579: PUSH
94580: LD_INT 108
94582: PUSH
94583: LD_INT 112
94585: PUSH
94586: LD_INT 116
94588: PUSH
94589: LD_INT 117
94591: PUSH
94592: LD_INT 118
94594: PUSH
94595: EMPTY
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: ST_TO_ADDR
94611: GO 97014
94613: LD_INT 8
94615: DOUBLE
94616: EQUAL
94617: IFTRUE 94621
94619: GO 94761
94621: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94622: LD_ADDR_VAR 0 2
94626: PUSH
94627: LD_INT 2
94629: PUSH
94630: LD_INT 4
94632: PUSH
94633: LD_INT 5
94635: PUSH
94636: LD_INT 6
94638: PUSH
94639: LD_INT 7
94641: PUSH
94642: LD_INT 8
94644: PUSH
94645: LD_INT 11
94647: PUSH
94648: LD_INT 12
94650: PUSH
94651: LD_INT 15
94653: PUSH
94654: LD_INT 16
94656: PUSH
94657: LD_INT 20
94659: PUSH
94660: LD_INT 21
94662: PUSH
94663: LD_INT 22
94665: PUSH
94666: LD_INT 23
94668: PUSH
94669: LD_INT 25
94671: PUSH
94672: LD_INT 26
94674: PUSH
94675: LD_INT 30
94677: PUSH
94678: LD_INT 31
94680: PUSH
94681: LD_INT 32
94683: PUSH
94684: LD_INT 36
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: PUSH
94709: LD_INT 101
94711: PUSH
94712: LD_INT 102
94714: PUSH
94715: LD_INT 103
94717: PUSH
94718: LD_INT 105
94720: PUSH
94721: LD_INT 106
94723: PUSH
94724: LD_INT 108
94726: PUSH
94727: LD_INT 109
94729: PUSH
94730: LD_INT 112
94732: PUSH
94733: LD_INT 116
94735: PUSH
94736: LD_INT 117
94738: PUSH
94739: LD_INT 118
94741: PUSH
94742: EMPTY
94743: LIST
94744: LIST
94745: LIST
94746: LIST
94747: LIST
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: PUSH
94755: EMPTY
94756: LIST
94757: LIST
94758: ST_TO_ADDR
94759: GO 97014
94761: LD_INT 9
94763: DOUBLE
94764: EQUAL
94765: IFTRUE 94769
94767: GO 94917
94769: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94770: LD_ADDR_VAR 0 2
94774: PUSH
94775: LD_INT 2
94777: PUSH
94778: LD_INT 4
94780: PUSH
94781: LD_INT 5
94783: PUSH
94784: LD_INT 6
94786: PUSH
94787: LD_INT 7
94789: PUSH
94790: LD_INT 8
94792: PUSH
94793: LD_INT 11
94795: PUSH
94796: LD_INT 12
94798: PUSH
94799: LD_INT 15
94801: PUSH
94802: LD_INT 16
94804: PUSH
94805: LD_INT 20
94807: PUSH
94808: LD_INT 21
94810: PUSH
94811: LD_INT 22
94813: PUSH
94814: LD_INT 23
94816: PUSH
94817: LD_INT 25
94819: PUSH
94820: LD_INT 26
94822: PUSH
94823: LD_INT 28
94825: PUSH
94826: LD_INT 30
94828: PUSH
94829: LD_INT 31
94831: PUSH
94832: LD_INT 32
94834: PUSH
94835: LD_INT 36
94837: PUSH
94838: EMPTY
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: LIST
94845: LIST
94846: LIST
94847: LIST
94848: LIST
94849: LIST
94850: LIST
94851: LIST
94852: LIST
94853: LIST
94854: LIST
94855: LIST
94856: LIST
94857: LIST
94858: LIST
94859: LIST
94860: PUSH
94861: LD_INT 101
94863: PUSH
94864: LD_INT 102
94866: PUSH
94867: LD_INT 103
94869: PUSH
94870: LD_INT 105
94872: PUSH
94873: LD_INT 106
94875: PUSH
94876: LD_INT 108
94878: PUSH
94879: LD_INT 109
94881: PUSH
94882: LD_INT 112
94884: PUSH
94885: LD_INT 114
94887: PUSH
94888: LD_INT 116
94890: PUSH
94891: LD_INT 117
94893: PUSH
94894: LD_INT 118
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: LIST
94905: LIST
94906: LIST
94907: LIST
94908: LIST
94909: LIST
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: ST_TO_ADDR
94915: GO 97014
94917: LD_INT 10
94919: DOUBLE
94920: EQUAL
94921: IFTRUE 94925
94923: GO 95121
94925: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94926: LD_ADDR_VAR 0 2
94930: PUSH
94931: LD_INT 2
94933: PUSH
94934: LD_INT 4
94936: PUSH
94937: LD_INT 5
94939: PUSH
94940: LD_INT 6
94942: PUSH
94943: LD_INT 7
94945: PUSH
94946: LD_INT 8
94948: PUSH
94949: LD_INT 9
94951: PUSH
94952: LD_INT 10
94954: PUSH
94955: LD_INT 11
94957: PUSH
94958: LD_INT 12
94960: PUSH
94961: LD_INT 13
94963: PUSH
94964: LD_INT 14
94966: PUSH
94967: LD_INT 15
94969: PUSH
94970: LD_INT 16
94972: PUSH
94973: LD_INT 17
94975: PUSH
94976: LD_INT 18
94978: PUSH
94979: LD_INT 19
94981: PUSH
94982: LD_INT 20
94984: PUSH
94985: LD_INT 21
94987: PUSH
94988: LD_INT 22
94990: PUSH
94991: LD_INT 23
94993: PUSH
94994: LD_INT 24
94996: PUSH
94997: LD_INT 25
94999: PUSH
95000: LD_INT 26
95002: PUSH
95003: LD_INT 28
95005: PUSH
95006: LD_INT 30
95008: PUSH
95009: LD_INT 31
95011: PUSH
95012: LD_INT 32
95014: PUSH
95015: LD_INT 36
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 101
95051: PUSH
95052: LD_INT 102
95054: PUSH
95055: LD_INT 103
95057: PUSH
95058: LD_INT 104
95060: PUSH
95061: LD_INT 105
95063: PUSH
95064: LD_INT 106
95066: PUSH
95067: LD_INT 107
95069: PUSH
95070: LD_INT 108
95072: PUSH
95073: LD_INT 109
95075: PUSH
95076: LD_INT 110
95078: PUSH
95079: LD_INT 111
95081: PUSH
95082: LD_INT 112
95084: PUSH
95085: LD_INT 114
95087: PUSH
95088: LD_INT 116
95090: PUSH
95091: LD_INT 117
95093: PUSH
95094: LD_INT 118
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: LIST
95101: LIST
95102: LIST
95103: LIST
95104: LIST
95105: LIST
95106: LIST
95107: LIST
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: ST_TO_ADDR
95119: GO 97014
95121: LD_INT 11
95123: DOUBLE
95124: EQUAL
95125: IFTRUE 95129
95127: GO 95333
95129: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95130: LD_ADDR_VAR 0 2
95134: PUSH
95135: LD_INT 2
95137: PUSH
95138: LD_INT 3
95140: PUSH
95141: LD_INT 4
95143: PUSH
95144: LD_INT 5
95146: PUSH
95147: LD_INT 6
95149: PUSH
95150: LD_INT 7
95152: PUSH
95153: LD_INT 8
95155: PUSH
95156: LD_INT 9
95158: PUSH
95159: LD_INT 10
95161: PUSH
95162: LD_INT 11
95164: PUSH
95165: LD_INT 12
95167: PUSH
95168: LD_INT 13
95170: PUSH
95171: LD_INT 14
95173: PUSH
95174: LD_INT 15
95176: PUSH
95177: LD_INT 16
95179: PUSH
95180: LD_INT 17
95182: PUSH
95183: LD_INT 18
95185: PUSH
95186: LD_INT 19
95188: PUSH
95189: LD_INT 20
95191: PUSH
95192: LD_INT 21
95194: PUSH
95195: LD_INT 22
95197: PUSH
95198: LD_INT 23
95200: PUSH
95201: LD_INT 24
95203: PUSH
95204: LD_INT 25
95206: PUSH
95207: LD_INT 26
95209: PUSH
95210: LD_INT 28
95212: PUSH
95213: LD_INT 30
95215: PUSH
95216: LD_INT 31
95218: PUSH
95219: LD_INT 32
95221: PUSH
95222: LD_INT 34
95224: PUSH
95225: LD_INT 36
95227: PUSH
95228: EMPTY
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: LIST
95245: LIST
95246: LIST
95247: LIST
95248: LIST
95249: LIST
95250: LIST
95251: LIST
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: PUSH
95261: LD_INT 101
95263: PUSH
95264: LD_INT 102
95266: PUSH
95267: LD_INT 103
95269: PUSH
95270: LD_INT 104
95272: PUSH
95273: LD_INT 105
95275: PUSH
95276: LD_INT 106
95278: PUSH
95279: LD_INT 107
95281: PUSH
95282: LD_INT 108
95284: PUSH
95285: LD_INT 109
95287: PUSH
95288: LD_INT 110
95290: PUSH
95291: LD_INT 111
95293: PUSH
95294: LD_INT 112
95296: PUSH
95297: LD_INT 114
95299: PUSH
95300: LD_INT 116
95302: PUSH
95303: LD_INT 117
95305: PUSH
95306: LD_INT 118
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: PUSH
95327: EMPTY
95328: LIST
95329: LIST
95330: ST_TO_ADDR
95331: GO 97014
95333: LD_INT 12
95335: DOUBLE
95336: EQUAL
95337: IFTRUE 95341
95339: GO 95561
95341: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95342: LD_ADDR_VAR 0 2
95346: PUSH
95347: LD_INT 1
95349: PUSH
95350: LD_INT 2
95352: PUSH
95353: LD_INT 3
95355: PUSH
95356: LD_INT 4
95358: PUSH
95359: LD_INT 5
95361: PUSH
95362: LD_INT 6
95364: PUSH
95365: LD_INT 7
95367: PUSH
95368: LD_INT 8
95370: PUSH
95371: LD_INT 9
95373: PUSH
95374: LD_INT 10
95376: PUSH
95377: LD_INT 11
95379: PUSH
95380: LD_INT 12
95382: PUSH
95383: LD_INT 13
95385: PUSH
95386: LD_INT 14
95388: PUSH
95389: LD_INT 15
95391: PUSH
95392: LD_INT 16
95394: PUSH
95395: LD_INT 17
95397: PUSH
95398: LD_INT 18
95400: PUSH
95401: LD_INT 19
95403: PUSH
95404: LD_INT 20
95406: PUSH
95407: LD_INT 21
95409: PUSH
95410: LD_INT 22
95412: PUSH
95413: LD_INT 23
95415: PUSH
95416: LD_INT 24
95418: PUSH
95419: LD_INT 25
95421: PUSH
95422: LD_INT 26
95424: PUSH
95425: LD_INT 27
95427: PUSH
95428: LD_INT 28
95430: PUSH
95431: LD_INT 30
95433: PUSH
95434: LD_INT 31
95436: PUSH
95437: LD_INT 32
95439: PUSH
95440: LD_INT 33
95442: PUSH
95443: LD_INT 34
95445: PUSH
95446: LD_INT 36
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: LIST
95469: LIST
95470: LIST
95471: LIST
95472: LIST
95473: LIST
95474: LIST
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 101
95487: PUSH
95488: LD_INT 102
95490: PUSH
95491: LD_INT 103
95493: PUSH
95494: LD_INT 104
95496: PUSH
95497: LD_INT 105
95499: PUSH
95500: LD_INT 106
95502: PUSH
95503: LD_INT 107
95505: PUSH
95506: LD_INT 108
95508: PUSH
95509: LD_INT 109
95511: PUSH
95512: LD_INT 110
95514: PUSH
95515: LD_INT 111
95517: PUSH
95518: LD_INT 112
95520: PUSH
95521: LD_INT 113
95523: PUSH
95524: LD_INT 114
95526: PUSH
95527: LD_INT 116
95529: PUSH
95530: LD_INT 117
95532: PUSH
95533: LD_INT 118
95535: PUSH
95536: EMPTY
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: PUSH
95555: EMPTY
95556: LIST
95557: LIST
95558: ST_TO_ADDR
95559: GO 97014
95561: LD_INT 13
95563: DOUBLE
95564: EQUAL
95565: IFTRUE 95569
95567: GO 95777
95569: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95570: LD_ADDR_VAR 0 2
95574: PUSH
95575: LD_INT 1
95577: PUSH
95578: LD_INT 2
95580: PUSH
95581: LD_INT 3
95583: PUSH
95584: LD_INT 4
95586: PUSH
95587: LD_INT 5
95589: PUSH
95590: LD_INT 8
95592: PUSH
95593: LD_INT 9
95595: PUSH
95596: LD_INT 10
95598: PUSH
95599: LD_INT 11
95601: PUSH
95602: LD_INT 12
95604: PUSH
95605: LD_INT 14
95607: PUSH
95608: LD_INT 15
95610: PUSH
95611: LD_INT 16
95613: PUSH
95614: LD_INT 17
95616: PUSH
95617: LD_INT 18
95619: PUSH
95620: LD_INT 19
95622: PUSH
95623: LD_INT 20
95625: PUSH
95626: LD_INT 21
95628: PUSH
95629: LD_INT 22
95631: PUSH
95632: LD_INT 23
95634: PUSH
95635: LD_INT 24
95637: PUSH
95638: LD_INT 25
95640: PUSH
95641: LD_INT 26
95643: PUSH
95644: LD_INT 27
95646: PUSH
95647: LD_INT 28
95649: PUSH
95650: LD_INT 30
95652: PUSH
95653: LD_INT 31
95655: PUSH
95656: LD_INT 32
95658: PUSH
95659: LD_INT 33
95661: PUSH
95662: LD_INT 34
95664: PUSH
95665: LD_INT 36
95667: PUSH
95668: EMPTY
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: LIST
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 101
95703: PUSH
95704: LD_INT 102
95706: PUSH
95707: LD_INT 103
95709: PUSH
95710: LD_INT 104
95712: PUSH
95713: LD_INT 105
95715: PUSH
95716: LD_INT 106
95718: PUSH
95719: LD_INT 107
95721: PUSH
95722: LD_INT 108
95724: PUSH
95725: LD_INT 109
95727: PUSH
95728: LD_INT 110
95730: PUSH
95731: LD_INT 111
95733: PUSH
95734: LD_INT 112
95736: PUSH
95737: LD_INT 113
95739: PUSH
95740: LD_INT 114
95742: PUSH
95743: LD_INT 116
95745: PUSH
95746: LD_INT 117
95748: PUSH
95749: LD_INT 118
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: LIST
95756: LIST
95757: LIST
95758: LIST
95759: LIST
95760: LIST
95761: LIST
95762: LIST
95763: LIST
95764: LIST
95765: LIST
95766: LIST
95767: LIST
95768: LIST
95769: LIST
95770: PUSH
95771: EMPTY
95772: LIST
95773: LIST
95774: ST_TO_ADDR
95775: GO 97014
95777: LD_INT 14
95779: DOUBLE
95780: EQUAL
95781: IFTRUE 95785
95783: GO 96009
95785: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95786: LD_ADDR_VAR 0 2
95790: PUSH
95791: LD_INT 1
95793: PUSH
95794: LD_INT 2
95796: PUSH
95797: LD_INT 3
95799: PUSH
95800: LD_INT 4
95802: PUSH
95803: LD_INT 5
95805: PUSH
95806: LD_INT 6
95808: PUSH
95809: LD_INT 7
95811: PUSH
95812: LD_INT 8
95814: PUSH
95815: LD_INT 9
95817: PUSH
95818: LD_INT 10
95820: PUSH
95821: LD_INT 11
95823: PUSH
95824: LD_INT 12
95826: PUSH
95827: LD_INT 13
95829: PUSH
95830: LD_INT 14
95832: PUSH
95833: LD_INT 15
95835: PUSH
95836: LD_INT 16
95838: PUSH
95839: LD_INT 17
95841: PUSH
95842: LD_INT 18
95844: PUSH
95845: LD_INT 19
95847: PUSH
95848: LD_INT 20
95850: PUSH
95851: LD_INT 21
95853: PUSH
95854: LD_INT 22
95856: PUSH
95857: LD_INT 23
95859: PUSH
95860: LD_INT 24
95862: PUSH
95863: LD_INT 25
95865: PUSH
95866: LD_INT 26
95868: PUSH
95869: LD_INT 27
95871: PUSH
95872: LD_INT 28
95874: PUSH
95875: LD_INT 29
95877: PUSH
95878: LD_INT 30
95880: PUSH
95881: LD_INT 31
95883: PUSH
95884: LD_INT 32
95886: PUSH
95887: LD_INT 33
95889: PUSH
95890: LD_INT 34
95892: PUSH
95893: LD_INT 36
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: PUSH
95933: LD_INT 101
95935: PUSH
95936: LD_INT 102
95938: PUSH
95939: LD_INT 103
95941: PUSH
95942: LD_INT 104
95944: PUSH
95945: LD_INT 105
95947: PUSH
95948: LD_INT 106
95950: PUSH
95951: LD_INT 107
95953: PUSH
95954: LD_INT 108
95956: PUSH
95957: LD_INT 109
95959: PUSH
95960: LD_INT 110
95962: PUSH
95963: LD_INT 111
95965: PUSH
95966: LD_INT 112
95968: PUSH
95969: LD_INT 113
95971: PUSH
95972: LD_INT 114
95974: PUSH
95975: LD_INT 116
95977: PUSH
95978: LD_INT 117
95980: PUSH
95981: LD_INT 118
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: LIST
95988: LIST
95989: LIST
95990: LIST
95991: LIST
95992: LIST
95993: LIST
95994: LIST
95995: LIST
95996: LIST
95997: LIST
95998: LIST
95999: LIST
96000: LIST
96001: LIST
96002: PUSH
96003: EMPTY
96004: LIST
96005: LIST
96006: ST_TO_ADDR
96007: GO 97014
96009: LD_INT 15
96011: DOUBLE
96012: EQUAL
96013: IFTRUE 96017
96015: GO 96241
96017: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96018: LD_ADDR_VAR 0 2
96022: PUSH
96023: LD_INT 1
96025: PUSH
96026: LD_INT 2
96028: PUSH
96029: LD_INT 3
96031: PUSH
96032: LD_INT 4
96034: PUSH
96035: LD_INT 5
96037: PUSH
96038: LD_INT 6
96040: PUSH
96041: LD_INT 7
96043: PUSH
96044: LD_INT 8
96046: PUSH
96047: LD_INT 9
96049: PUSH
96050: LD_INT 10
96052: PUSH
96053: LD_INT 11
96055: PUSH
96056: LD_INT 12
96058: PUSH
96059: LD_INT 13
96061: PUSH
96062: LD_INT 14
96064: PUSH
96065: LD_INT 15
96067: PUSH
96068: LD_INT 16
96070: PUSH
96071: LD_INT 17
96073: PUSH
96074: LD_INT 18
96076: PUSH
96077: LD_INT 19
96079: PUSH
96080: LD_INT 20
96082: PUSH
96083: LD_INT 21
96085: PUSH
96086: LD_INT 22
96088: PUSH
96089: LD_INT 23
96091: PUSH
96092: LD_INT 24
96094: PUSH
96095: LD_INT 25
96097: PUSH
96098: LD_INT 26
96100: PUSH
96101: LD_INT 27
96103: PUSH
96104: LD_INT 28
96106: PUSH
96107: LD_INT 29
96109: PUSH
96110: LD_INT 30
96112: PUSH
96113: LD_INT 31
96115: PUSH
96116: LD_INT 32
96118: PUSH
96119: LD_INT 33
96121: PUSH
96122: LD_INT 34
96124: PUSH
96125: LD_INT 36
96127: PUSH
96128: EMPTY
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 101
96167: PUSH
96168: LD_INT 102
96170: PUSH
96171: LD_INT 103
96173: PUSH
96174: LD_INT 104
96176: PUSH
96177: LD_INT 105
96179: PUSH
96180: LD_INT 106
96182: PUSH
96183: LD_INT 107
96185: PUSH
96186: LD_INT 108
96188: PUSH
96189: LD_INT 109
96191: PUSH
96192: LD_INT 110
96194: PUSH
96195: LD_INT 111
96197: PUSH
96198: LD_INT 112
96200: PUSH
96201: LD_INT 113
96203: PUSH
96204: LD_INT 114
96206: PUSH
96207: LD_INT 116
96209: PUSH
96210: LD_INT 117
96212: PUSH
96213: LD_INT 118
96215: PUSH
96216: EMPTY
96217: LIST
96218: LIST
96219: LIST
96220: LIST
96221: LIST
96222: LIST
96223: LIST
96224: LIST
96225: LIST
96226: LIST
96227: LIST
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: ST_TO_ADDR
96239: GO 97014
96241: LD_INT 16
96243: DOUBLE
96244: EQUAL
96245: IFTRUE 96249
96247: GO 96385
96249: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96250: LD_ADDR_VAR 0 2
96254: PUSH
96255: LD_INT 2
96257: PUSH
96258: LD_INT 4
96260: PUSH
96261: LD_INT 5
96263: PUSH
96264: LD_INT 7
96266: PUSH
96267: LD_INT 11
96269: PUSH
96270: LD_INT 12
96272: PUSH
96273: LD_INT 15
96275: PUSH
96276: LD_INT 16
96278: PUSH
96279: LD_INT 20
96281: PUSH
96282: LD_INT 21
96284: PUSH
96285: LD_INT 22
96287: PUSH
96288: LD_INT 23
96290: PUSH
96291: LD_INT 25
96293: PUSH
96294: LD_INT 26
96296: PUSH
96297: LD_INT 30
96299: PUSH
96300: LD_INT 31
96302: PUSH
96303: LD_INT 32
96305: PUSH
96306: LD_INT 33
96308: PUSH
96309: LD_INT 34
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: LIST
96316: LIST
96317: LIST
96318: LIST
96319: LIST
96320: LIST
96321: LIST
96322: LIST
96323: LIST
96324: LIST
96325: LIST
96326: LIST
96327: LIST
96328: LIST
96329: LIST
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 101
96335: PUSH
96336: LD_INT 102
96338: PUSH
96339: LD_INT 103
96341: PUSH
96342: LD_INT 106
96344: PUSH
96345: LD_INT 108
96347: PUSH
96348: LD_INT 112
96350: PUSH
96351: LD_INT 113
96353: PUSH
96354: LD_INT 114
96356: PUSH
96357: LD_INT 116
96359: PUSH
96360: LD_INT 117
96362: PUSH
96363: LD_INT 118
96365: PUSH
96366: EMPTY
96367: LIST
96368: LIST
96369: LIST
96370: LIST
96371: LIST
96372: LIST
96373: LIST
96374: LIST
96375: LIST
96376: LIST
96377: LIST
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: ST_TO_ADDR
96383: GO 97014
96385: LD_INT 17
96387: DOUBLE
96388: EQUAL
96389: IFTRUE 96393
96391: GO 96617
96393: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96394: LD_ADDR_VAR 0 2
96398: PUSH
96399: LD_INT 1
96401: PUSH
96402: LD_INT 2
96404: PUSH
96405: LD_INT 3
96407: PUSH
96408: LD_INT 4
96410: PUSH
96411: LD_INT 5
96413: PUSH
96414: LD_INT 6
96416: PUSH
96417: LD_INT 7
96419: PUSH
96420: LD_INT 8
96422: PUSH
96423: LD_INT 9
96425: PUSH
96426: LD_INT 10
96428: PUSH
96429: LD_INT 11
96431: PUSH
96432: LD_INT 12
96434: PUSH
96435: LD_INT 13
96437: PUSH
96438: LD_INT 14
96440: PUSH
96441: LD_INT 15
96443: PUSH
96444: LD_INT 16
96446: PUSH
96447: LD_INT 17
96449: PUSH
96450: LD_INT 18
96452: PUSH
96453: LD_INT 19
96455: PUSH
96456: LD_INT 20
96458: PUSH
96459: LD_INT 21
96461: PUSH
96462: LD_INT 22
96464: PUSH
96465: LD_INT 23
96467: PUSH
96468: LD_INT 24
96470: PUSH
96471: LD_INT 25
96473: PUSH
96474: LD_INT 26
96476: PUSH
96477: LD_INT 27
96479: PUSH
96480: LD_INT 28
96482: PUSH
96483: LD_INT 29
96485: PUSH
96486: LD_INT 30
96488: PUSH
96489: LD_INT 31
96491: PUSH
96492: LD_INT 32
96494: PUSH
96495: LD_INT 33
96497: PUSH
96498: LD_INT 34
96500: PUSH
96501: LD_INT 36
96503: PUSH
96504: EMPTY
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: LIST
96525: LIST
96526: LIST
96527: LIST
96528: LIST
96529: LIST
96530: LIST
96531: LIST
96532: LIST
96533: LIST
96534: LIST
96535: LIST
96536: LIST
96537: LIST
96538: LIST
96539: LIST
96540: PUSH
96541: LD_INT 101
96543: PUSH
96544: LD_INT 102
96546: PUSH
96547: LD_INT 103
96549: PUSH
96550: LD_INT 104
96552: PUSH
96553: LD_INT 105
96555: PUSH
96556: LD_INT 106
96558: PUSH
96559: LD_INT 107
96561: PUSH
96562: LD_INT 108
96564: PUSH
96565: LD_INT 109
96567: PUSH
96568: LD_INT 110
96570: PUSH
96571: LD_INT 111
96573: PUSH
96574: LD_INT 112
96576: PUSH
96577: LD_INT 113
96579: PUSH
96580: LD_INT 114
96582: PUSH
96583: LD_INT 116
96585: PUSH
96586: LD_INT 117
96588: PUSH
96589: LD_INT 118
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: LIST
96606: LIST
96607: LIST
96608: LIST
96609: LIST
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: ST_TO_ADDR
96615: GO 97014
96617: LD_INT 18
96619: DOUBLE
96620: EQUAL
96621: IFTRUE 96625
96623: GO 96773
96625: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96626: LD_ADDR_VAR 0 2
96630: PUSH
96631: LD_INT 2
96633: PUSH
96634: LD_INT 4
96636: PUSH
96637: LD_INT 5
96639: PUSH
96640: LD_INT 7
96642: PUSH
96643: LD_INT 11
96645: PUSH
96646: LD_INT 12
96648: PUSH
96649: LD_INT 15
96651: PUSH
96652: LD_INT 16
96654: PUSH
96655: LD_INT 20
96657: PUSH
96658: LD_INT 21
96660: PUSH
96661: LD_INT 22
96663: PUSH
96664: LD_INT 23
96666: PUSH
96667: LD_INT 25
96669: PUSH
96670: LD_INT 26
96672: PUSH
96673: LD_INT 30
96675: PUSH
96676: LD_INT 31
96678: PUSH
96679: LD_INT 32
96681: PUSH
96682: LD_INT 33
96684: PUSH
96685: LD_INT 34
96687: PUSH
96688: LD_INT 35
96690: PUSH
96691: LD_INT 36
96693: PUSH
96694: EMPTY
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: PUSH
96717: LD_INT 101
96719: PUSH
96720: LD_INT 102
96722: PUSH
96723: LD_INT 103
96725: PUSH
96726: LD_INT 106
96728: PUSH
96729: LD_INT 108
96731: PUSH
96732: LD_INT 112
96734: PUSH
96735: LD_INT 113
96737: PUSH
96738: LD_INT 114
96740: PUSH
96741: LD_INT 115
96743: PUSH
96744: LD_INT 116
96746: PUSH
96747: LD_INT 117
96749: PUSH
96750: LD_INT 118
96752: PUSH
96753: EMPTY
96754: LIST
96755: LIST
96756: LIST
96757: LIST
96758: LIST
96759: LIST
96760: LIST
96761: LIST
96762: LIST
96763: LIST
96764: LIST
96765: LIST
96766: PUSH
96767: EMPTY
96768: LIST
96769: LIST
96770: ST_TO_ADDR
96771: GO 97014
96773: LD_INT 19
96775: DOUBLE
96776: EQUAL
96777: IFTRUE 96781
96779: GO 97013
96781: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96782: LD_ADDR_VAR 0 2
96786: PUSH
96787: LD_INT 1
96789: PUSH
96790: LD_INT 2
96792: PUSH
96793: LD_INT 3
96795: PUSH
96796: LD_INT 4
96798: PUSH
96799: LD_INT 5
96801: PUSH
96802: LD_INT 6
96804: PUSH
96805: LD_INT 7
96807: PUSH
96808: LD_INT 8
96810: PUSH
96811: LD_INT 9
96813: PUSH
96814: LD_INT 10
96816: PUSH
96817: LD_INT 11
96819: PUSH
96820: LD_INT 12
96822: PUSH
96823: LD_INT 13
96825: PUSH
96826: LD_INT 14
96828: PUSH
96829: LD_INT 15
96831: PUSH
96832: LD_INT 16
96834: PUSH
96835: LD_INT 17
96837: PUSH
96838: LD_INT 18
96840: PUSH
96841: LD_INT 19
96843: PUSH
96844: LD_INT 20
96846: PUSH
96847: LD_INT 21
96849: PUSH
96850: LD_INT 22
96852: PUSH
96853: LD_INT 23
96855: PUSH
96856: LD_INT 24
96858: PUSH
96859: LD_INT 25
96861: PUSH
96862: LD_INT 26
96864: PUSH
96865: LD_INT 27
96867: PUSH
96868: LD_INT 28
96870: PUSH
96871: LD_INT 29
96873: PUSH
96874: LD_INT 30
96876: PUSH
96877: LD_INT 31
96879: PUSH
96880: LD_INT 32
96882: PUSH
96883: LD_INT 33
96885: PUSH
96886: LD_INT 34
96888: PUSH
96889: LD_INT 35
96891: PUSH
96892: LD_INT 36
96894: PUSH
96895: EMPTY
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: LIST
96917: LIST
96918: LIST
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: LIST
96926: LIST
96927: LIST
96928: LIST
96929: LIST
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 101
96935: PUSH
96936: LD_INT 102
96938: PUSH
96939: LD_INT 103
96941: PUSH
96942: LD_INT 104
96944: PUSH
96945: LD_INT 105
96947: PUSH
96948: LD_INT 106
96950: PUSH
96951: LD_INT 107
96953: PUSH
96954: LD_INT 108
96956: PUSH
96957: LD_INT 109
96959: PUSH
96960: LD_INT 110
96962: PUSH
96963: LD_INT 111
96965: PUSH
96966: LD_INT 112
96968: PUSH
96969: LD_INT 113
96971: PUSH
96972: LD_INT 114
96974: PUSH
96975: LD_INT 115
96977: PUSH
96978: LD_INT 116
96980: PUSH
96981: LD_INT 117
96983: PUSH
96984: LD_INT 118
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: LIST
96991: LIST
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: LIST
96999: LIST
97000: LIST
97001: LIST
97002: LIST
97003: LIST
97004: LIST
97005: LIST
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: ST_TO_ADDR
97011: GO 97014
97013: POP
// end else
97014: GO 97245
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97016: LD_ADDR_VAR 0 2
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 2
97026: PUSH
97027: LD_INT 3
97029: PUSH
97030: LD_INT 4
97032: PUSH
97033: LD_INT 5
97035: PUSH
97036: LD_INT 6
97038: PUSH
97039: LD_INT 7
97041: PUSH
97042: LD_INT 8
97044: PUSH
97045: LD_INT 9
97047: PUSH
97048: LD_INT 10
97050: PUSH
97051: LD_INT 11
97053: PUSH
97054: LD_INT 12
97056: PUSH
97057: LD_INT 13
97059: PUSH
97060: LD_INT 14
97062: PUSH
97063: LD_INT 15
97065: PUSH
97066: LD_INT 16
97068: PUSH
97069: LD_INT 17
97071: PUSH
97072: LD_INT 18
97074: PUSH
97075: LD_INT 19
97077: PUSH
97078: LD_INT 20
97080: PUSH
97081: LD_INT 21
97083: PUSH
97084: LD_INT 22
97086: PUSH
97087: LD_INT 23
97089: PUSH
97090: LD_INT 24
97092: PUSH
97093: LD_INT 25
97095: PUSH
97096: LD_INT 26
97098: PUSH
97099: LD_INT 27
97101: PUSH
97102: LD_INT 28
97104: PUSH
97105: LD_INT 29
97107: PUSH
97108: LD_INT 30
97110: PUSH
97111: LD_INT 31
97113: PUSH
97114: LD_INT 32
97116: PUSH
97117: LD_INT 33
97119: PUSH
97120: LD_INT 34
97122: PUSH
97123: LD_INT 35
97125: PUSH
97126: LD_INT 36
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: LIST
97151: LIST
97152: LIST
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: LIST
97161: LIST
97162: LIST
97163: LIST
97164: LIST
97165: LIST
97166: PUSH
97167: LD_INT 101
97169: PUSH
97170: LD_INT 102
97172: PUSH
97173: LD_INT 103
97175: PUSH
97176: LD_INT 104
97178: PUSH
97179: LD_INT 105
97181: PUSH
97182: LD_INT 106
97184: PUSH
97185: LD_INT 107
97187: PUSH
97188: LD_INT 108
97190: PUSH
97191: LD_INT 109
97193: PUSH
97194: LD_INT 110
97196: PUSH
97197: LD_INT 111
97199: PUSH
97200: LD_INT 112
97202: PUSH
97203: LD_INT 113
97205: PUSH
97206: LD_INT 114
97208: PUSH
97209: LD_INT 115
97211: PUSH
97212: LD_INT 116
97214: PUSH
97215: LD_INT 117
97217: PUSH
97218: LD_INT 118
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: LIST
97229: LIST
97230: LIST
97231: LIST
97232: LIST
97233: LIST
97234: LIST
97235: LIST
97236: LIST
97237: LIST
97238: LIST
97239: LIST
97240: PUSH
97241: EMPTY
97242: LIST
97243: LIST
97244: ST_TO_ADDR
// if result then
97245: LD_VAR 0 2
97249: IFFALSE 98035
// begin normal :=  ;
97251: LD_ADDR_VAR 0 5
97255: PUSH
97256: LD_STRING 
97258: ST_TO_ADDR
// hardcore :=  ;
97259: LD_ADDR_VAR 0 6
97263: PUSH
97264: LD_STRING 
97266: ST_TO_ADDR
// active :=  ;
97267: LD_ADDR_VAR 0 7
97271: PUSH
97272: LD_STRING 
97274: ST_TO_ADDR
// for i = 1 to normalCounter do
97275: LD_ADDR_VAR 0 8
97279: PUSH
97280: DOUBLE
97281: LD_INT 1
97283: DEC
97284: ST_TO_ADDR
97285: LD_EXP 110
97289: PUSH
97290: FOR_TO
97291: IFFALSE 97392
// begin tmp := 0 ;
97293: LD_ADDR_VAR 0 3
97297: PUSH
97298: LD_STRING 0
97300: ST_TO_ADDR
// if result [ 1 ] then
97301: LD_VAR 0 2
97305: PUSH
97306: LD_INT 1
97308: ARRAY
97309: IFFALSE 97374
// if result [ 1 ] [ 1 ] = i then
97311: LD_VAR 0 2
97315: PUSH
97316: LD_INT 1
97318: ARRAY
97319: PUSH
97320: LD_INT 1
97322: ARRAY
97323: PUSH
97324: LD_VAR 0 8
97328: EQUAL
97329: IFFALSE 97374
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97331: LD_ADDR_VAR 0 2
97335: PUSH
97336: LD_VAR 0 2
97340: PPUSH
97341: LD_INT 1
97343: PPUSH
97344: LD_VAR 0 2
97348: PUSH
97349: LD_INT 1
97351: ARRAY
97352: PPUSH
97353: LD_INT 1
97355: PPUSH
97356: CALL_OW 3
97360: PPUSH
97361: CALL_OW 1
97365: ST_TO_ADDR
// tmp := 1 ;
97366: LD_ADDR_VAR 0 3
97370: PUSH
97371: LD_STRING 1
97373: ST_TO_ADDR
// end ; normal := normal & tmp ;
97374: LD_ADDR_VAR 0 5
97378: PUSH
97379: LD_VAR 0 5
97383: PUSH
97384: LD_VAR 0 3
97388: STR
97389: ST_TO_ADDR
// end ;
97390: GO 97290
97392: POP
97393: POP
// for i = 1 to hardcoreCounter do
97394: LD_ADDR_VAR 0 8
97398: PUSH
97399: DOUBLE
97400: LD_INT 1
97402: DEC
97403: ST_TO_ADDR
97404: LD_EXP 111
97408: PUSH
97409: FOR_TO
97410: IFFALSE 97515
// begin tmp := 0 ;
97412: LD_ADDR_VAR 0 3
97416: PUSH
97417: LD_STRING 0
97419: ST_TO_ADDR
// if result [ 2 ] then
97420: LD_VAR 0 2
97424: PUSH
97425: LD_INT 2
97427: ARRAY
97428: IFFALSE 97497
// if result [ 2 ] [ 1 ] = 100 + i then
97430: LD_VAR 0 2
97434: PUSH
97435: LD_INT 2
97437: ARRAY
97438: PUSH
97439: LD_INT 1
97441: ARRAY
97442: PUSH
97443: LD_INT 100
97445: PUSH
97446: LD_VAR 0 8
97450: PLUS
97451: EQUAL
97452: IFFALSE 97497
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97454: LD_ADDR_VAR 0 2
97458: PUSH
97459: LD_VAR 0 2
97463: PPUSH
97464: LD_INT 2
97466: PPUSH
97467: LD_VAR 0 2
97471: PUSH
97472: LD_INT 2
97474: ARRAY
97475: PPUSH
97476: LD_INT 1
97478: PPUSH
97479: CALL_OW 3
97483: PPUSH
97484: CALL_OW 1
97488: ST_TO_ADDR
// tmp := 1 ;
97489: LD_ADDR_VAR 0 3
97493: PUSH
97494: LD_STRING 1
97496: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97497: LD_ADDR_VAR 0 6
97501: PUSH
97502: LD_VAR 0 6
97506: PUSH
97507: LD_VAR 0 3
97511: STR
97512: ST_TO_ADDR
// end ;
97513: GO 97409
97515: POP
97516: POP
// if isGameLoad then
97517: LD_VAR 0 1
97521: IFFALSE 97996
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97523: LD_ADDR_VAR 0 4
97527: PUSH
97528: LD_EXP 114
97532: PUSH
97533: LD_EXP 113
97537: PUSH
97538: LD_EXP 115
97542: PUSH
97543: LD_EXP 112
97547: PUSH
97548: LD_EXP 116
97552: PUSH
97553: LD_EXP 117
97557: PUSH
97558: LD_EXP 118
97562: PUSH
97563: LD_EXP 119
97567: PUSH
97568: LD_EXP 120
97572: PUSH
97573: LD_EXP 121
97577: PUSH
97578: LD_EXP 122
97582: PUSH
97583: LD_EXP 123
97587: PUSH
97588: LD_EXP 124
97592: PUSH
97593: LD_EXP 125
97597: PUSH
97598: LD_EXP 133
97602: PUSH
97603: LD_EXP 134
97607: PUSH
97608: LD_EXP 135
97612: PUSH
97613: LD_EXP 136
97617: PUSH
97618: LD_EXP 138
97622: PUSH
97623: LD_EXP 139
97627: PUSH
97628: LD_EXP 140
97632: PUSH
97633: LD_EXP 143
97637: PUSH
97638: LD_EXP 145
97642: PUSH
97643: LD_EXP 146
97647: PUSH
97648: LD_EXP 147
97652: PUSH
97653: LD_EXP 149
97657: PUSH
97658: LD_EXP 150
97662: PUSH
97663: LD_EXP 153
97667: PUSH
97668: LD_EXP 154
97672: PUSH
97673: LD_EXP 155
97677: PUSH
97678: LD_EXP 156
97682: PUSH
97683: LD_EXP 157
97687: PUSH
97688: LD_EXP 158
97692: PUSH
97693: LD_EXP 159
97697: PUSH
97698: LD_EXP 160
97702: PUSH
97703: LD_EXP 161
97707: PUSH
97708: LD_EXP 126
97712: PUSH
97713: LD_EXP 127
97717: PUSH
97718: LD_EXP 130
97722: PUSH
97723: LD_EXP 131
97727: PUSH
97728: LD_EXP 132
97732: PUSH
97733: LD_EXP 128
97737: PUSH
97738: LD_EXP 129
97742: PUSH
97743: LD_EXP 137
97747: PUSH
97748: LD_EXP 141
97752: PUSH
97753: LD_EXP 142
97757: PUSH
97758: LD_EXP 144
97762: PUSH
97763: LD_EXP 148
97767: PUSH
97768: LD_EXP 151
97772: PUSH
97773: LD_EXP 152
97777: PUSH
97778: LD_EXP 162
97782: PUSH
97783: LD_EXP 163
97787: PUSH
97788: LD_EXP 164
97792: PUSH
97793: LD_EXP 165
97797: PUSH
97798: EMPTY
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: LIST
97838: LIST
97839: LIST
97840: LIST
97841: LIST
97842: LIST
97843: LIST
97844: LIST
97845: LIST
97846: LIST
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: ST_TO_ADDR
// tmp :=  ;
97854: LD_ADDR_VAR 0 3
97858: PUSH
97859: LD_STRING 
97861: ST_TO_ADDR
// for i = 1 to normalCounter do
97862: LD_ADDR_VAR 0 8
97866: PUSH
97867: DOUBLE
97868: LD_INT 1
97870: DEC
97871: ST_TO_ADDR
97872: LD_EXP 110
97876: PUSH
97877: FOR_TO
97878: IFFALSE 97914
// begin if flags [ i ] then
97880: LD_VAR 0 4
97884: PUSH
97885: LD_VAR 0 8
97889: ARRAY
97890: IFFALSE 97912
// tmp := tmp & i & ; ;
97892: LD_ADDR_VAR 0 3
97896: PUSH
97897: LD_VAR 0 3
97901: PUSH
97902: LD_VAR 0 8
97906: STR
97907: PUSH
97908: LD_STRING ;
97910: STR
97911: ST_TO_ADDR
// end ;
97912: GO 97877
97914: POP
97915: POP
// for i = 1 to hardcoreCounter do
97916: LD_ADDR_VAR 0 8
97920: PUSH
97921: DOUBLE
97922: LD_INT 1
97924: DEC
97925: ST_TO_ADDR
97926: LD_EXP 111
97930: PUSH
97931: FOR_TO
97932: IFFALSE 97978
// begin if flags [ normalCounter + i ] then
97934: LD_VAR 0 4
97938: PUSH
97939: LD_EXP 110
97943: PUSH
97944: LD_VAR 0 8
97948: PLUS
97949: ARRAY
97950: IFFALSE 97976
// tmp := tmp & ( 100 + i ) & ; ;
97952: LD_ADDR_VAR 0 3
97956: PUSH
97957: LD_VAR 0 3
97961: PUSH
97962: LD_INT 100
97964: PUSH
97965: LD_VAR 0 8
97969: PLUS
97970: STR
97971: PUSH
97972: LD_STRING ;
97974: STR
97975: ST_TO_ADDR
// end ;
97976: GO 97931
97978: POP
97979: POP
// if tmp then
97980: LD_VAR 0 3
97984: IFFALSE 97996
// active := tmp ;
97986: LD_ADDR_VAR 0 7
97990: PUSH
97991: LD_VAR 0 3
97995: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97996: LD_STRING getStreamItemsFromMission("
97998: PUSH
97999: LD_VAR 0 5
98003: STR
98004: PUSH
98005: LD_STRING ","
98007: STR
98008: PUSH
98009: LD_VAR 0 6
98013: STR
98014: PUSH
98015: LD_STRING ","
98017: STR
98018: PUSH
98019: LD_VAR 0 7
98023: STR
98024: PUSH
98025: LD_STRING ")
98027: STR
98028: PPUSH
98029: CALL_OW 559
// end else
98033: GO 98042
// ToLua ( getStreamItemsFromMission("","","") ) ;
98035: LD_STRING getStreamItemsFromMission("","","")
98037: PPUSH
98038: CALL_OW 559
// end ;
98042: LD_VAR 0 2
98046: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98047: LD_EXP 109
98051: IFFALSE 98059
98053: PUSH
98054: LD_EXP 114
98058: AND
98059: IFFALSE 98183
98061: GO 98063
98063: DISABLE
98064: LD_INT 0
98066: PPUSH
98067: PPUSH
// begin enable ;
98068: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98069: LD_ADDR_VAR 0 2
98073: PUSH
98074: LD_INT 22
98076: PUSH
98077: LD_OWVAR 2
98081: PUSH
98082: EMPTY
98083: LIST
98084: LIST
98085: PUSH
98086: LD_INT 2
98088: PUSH
98089: LD_INT 34
98091: PUSH
98092: LD_INT 7
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 34
98101: PUSH
98102: LD_INT 45
98104: PUSH
98105: EMPTY
98106: LIST
98107: LIST
98108: PUSH
98109: LD_INT 34
98111: PUSH
98112: LD_INT 28
98114: PUSH
98115: EMPTY
98116: LIST
98117: LIST
98118: PUSH
98119: LD_INT 34
98121: PUSH
98122: LD_INT 47
98124: PUSH
98125: EMPTY
98126: LIST
98127: LIST
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: LIST
98133: LIST
98134: LIST
98135: PUSH
98136: EMPTY
98137: LIST
98138: LIST
98139: PPUSH
98140: CALL_OW 69
98144: ST_TO_ADDR
// if not tmp then
98145: LD_VAR 0 2
98149: NOT
98150: IFFALSE 98154
// exit ;
98152: GO 98183
// for i in tmp do
98154: LD_ADDR_VAR 0 1
98158: PUSH
98159: LD_VAR 0 2
98163: PUSH
98164: FOR_IN
98165: IFFALSE 98181
// begin SetLives ( i , 0 ) ;
98167: LD_VAR 0 1
98171: PPUSH
98172: LD_INT 0
98174: PPUSH
98175: CALL_OW 234
// end ;
98179: GO 98164
98181: POP
98182: POP
// end ;
98183: PPOPN 2
98185: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98186: LD_EXP 109
98190: IFFALSE 98198
98192: PUSH
98193: LD_EXP 115
98197: AND
98198: IFFALSE 98282
98200: GO 98202
98202: DISABLE
98203: LD_INT 0
98205: PPUSH
98206: PPUSH
// begin enable ;
98207: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98208: LD_ADDR_VAR 0 2
98212: PUSH
98213: LD_INT 22
98215: PUSH
98216: LD_OWVAR 2
98220: PUSH
98221: EMPTY
98222: LIST
98223: LIST
98224: PUSH
98225: LD_INT 32
98227: PUSH
98228: LD_INT 3
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: EMPTY
98236: LIST
98237: LIST
98238: PPUSH
98239: CALL_OW 69
98243: ST_TO_ADDR
// if not tmp then
98244: LD_VAR 0 2
98248: NOT
98249: IFFALSE 98253
// exit ;
98251: GO 98282
// for i in tmp do
98253: LD_ADDR_VAR 0 1
98257: PUSH
98258: LD_VAR 0 2
98262: PUSH
98263: FOR_IN
98264: IFFALSE 98280
// begin SetLives ( i , 0 ) ;
98266: LD_VAR 0 1
98270: PPUSH
98271: LD_INT 0
98273: PPUSH
98274: CALL_OW 234
// end ;
98278: GO 98263
98280: POP
98281: POP
// end ;
98282: PPOPN 2
98284: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98285: LD_EXP 109
98289: IFFALSE 98297
98291: PUSH
98292: LD_EXP 112
98296: AND
98297: IFFALSE 98390
98299: GO 98301
98301: DISABLE
98302: LD_INT 0
98304: PPUSH
// begin enable ;
98305: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98306: LD_ADDR_VAR 0 1
98310: PUSH
98311: LD_INT 22
98313: PUSH
98314: LD_OWVAR 2
98318: PUSH
98319: EMPTY
98320: LIST
98321: LIST
98322: PUSH
98323: LD_INT 2
98325: PUSH
98326: LD_INT 25
98328: PUSH
98329: LD_INT 5
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: PUSH
98336: LD_INT 25
98338: PUSH
98339: LD_INT 9
98341: PUSH
98342: EMPTY
98343: LIST
98344: LIST
98345: PUSH
98346: LD_INT 25
98348: PUSH
98349: LD_INT 8
98351: PUSH
98352: EMPTY
98353: LIST
98354: LIST
98355: PUSH
98356: EMPTY
98357: LIST
98358: LIST
98359: LIST
98360: LIST
98361: PUSH
98362: EMPTY
98363: LIST
98364: LIST
98365: PPUSH
98366: CALL_OW 69
98370: PUSH
98371: FOR_IN
98372: IFFALSE 98388
// begin SetClass ( i , 1 ) ;
98374: LD_VAR 0 1
98378: PPUSH
98379: LD_INT 1
98381: PPUSH
98382: CALL_OW 336
// end ;
98386: GO 98371
98388: POP
98389: POP
// end ;
98390: PPOPN 1
98392: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98393: LD_EXP 109
98397: IFFALSE 98405
98399: PUSH
98400: LD_EXP 113
98404: AND
98405: IFFALSE 98417
98407: PUSH
98408: LD_OWVAR 65
98412: PUSH
98413: LD_INT 7
98415: LESS
98416: AND
98417: IFFALSE 98431
98419: GO 98421
98421: DISABLE
// begin enable ;
98422: ENABLE
// game_speed := 7 ;
98423: LD_ADDR_OWVAR 65
98427: PUSH
98428: LD_INT 7
98430: ST_TO_ADDR
// end ;
98431: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98432: LD_EXP 109
98436: IFFALSE 98444
98438: PUSH
98439: LD_EXP 116
98443: AND
98444: IFFALSE 98646
98446: GO 98448
98448: DISABLE
98449: LD_INT 0
98451: PPUSH
98452: PPUSH
98453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98454: LD_ADDR_VAR 0 3
98458: PUSH
98459: LD_INT 81
98461: PUSH
98462: LD_OWVAR 2
98466: PUSH
98467: EMPTY
98468: LIST
98469: LIST
98470: PUSH
98471: LD_INT 21
98473: PUSH
98474: LD_INT 1
98476: PUSH
98477: EMPTY
98478: LIST
98479: LIST
98480: PUSH
98481: EMPTY
98482: LIST
98483: LIST
98484: PPUSH
98485: CALL_OW 69
98489: ST_TO_ADDR
// if not tmp then
98490: LD_VAR 0 3
98494: NOT
98495: IFFALSE 98499
// exit ;
98497: GO 98646
// if tmp > 5 then
98499: LD_VAR 0 3
98503: PUSH
98504: LD_INT 5
98506: GREATER
98507: IFFALSE 98519
// k := 5 else
98509: LD_ADDR_VAR 0 2
98513: PUSH
98514: LD_INT 5
98516: ST_TO_ADDR
98517: GO 98529
// k := tmp ;
98519: LD_ADDR_VAR 0 2
98523: PUSH
98524: LD_VAR 0 3
98528: ST_TO_ADDR
// for i := 1 to k do
98529: LD_ADDR_VAR 0 1
98533: PUSH
98534: DOUBLE
98535: LD_INT 1
98537: DEC
98538: ST_TO_ADDR
98539: LD_VAR 0 2
98543: PUSH
98544: FOR_TO
98545: IFFALSE 98644
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98547: LD_VAR 0 3
98551: PUSH
98552: LD_VAR 0 1
98556: ARRAY
98557: PPUSH
98558: LD_VAR 0 1
98562: PUSH
98563: LD_INT 4
98565: MOD
98566: PUSH
98567: LD_INT 1
98569: PLUS
98570: PPUSH
98571: CALL_OW 259
98575: PUSH
98576: LD_INT 10
98578: LESS
98579: IFFALSE 98642
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98581: LD_VAR 0 3
98585: PUSH
98586: LD_VAR 0 1
98590: ARRAY
98591: PPUSH
98592: LD_VAR 0 1
98596: PUSH
98597: LD_INT 4
98599: MOD
98600: PUSH
98601: LD_INT 1
98603: PLUS
98604: PPUSH
98605: LD_VAR 0 3
98609: PUSH
98610: LD_VAR 0 1
98614: ARRAY
98615: PPUSH
98616: LD_VAR 0 1
98620: PUSH
98621: LD_INT 4
98623: MOD
98624: PUSH
98625: LD_INT 1
98627: PLUS
98628: PPUSH
98629: CALL_OW 259
98633: PUSH
98634: LD_INT 1
98636: PLUS
98637: PPUSH
98638: CALL_OW 237
98642: GO 98544
98644: POP
98645: POP
// end ;
98646: PPOPN 3
98648: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98649: LD_EXP 109
98653: IFFALSE 98661
98655: PUSH
98656: LD_EXP 117
98660: AND
98661: IFFALSE 98681
98663: GO 98665
98665: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98666: LD_INT 4
98668: PPUSH
98669: LD_OWVAR 2
98673: PPUSH
98674: LD_INT 0
98676: PPUSH
98677: CALL_OW 324
98681: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98682: LD_EXP 109
98686: IFFALSE 98694
98688: PUSH
98689: LD_EXP 146
98693: AND
98694: IFFALSE 98714
98696: GO 98698
98698: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98699: LD_INT 19
98701: PPUSH
98702: LD_OWVAR 2
98706: PPUSH
98707: LD_INT 0
98709: PPUSH
98710: CALL_OW 324
98714: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98715: LD_EXP 109
98719: IFFALSE 98727
98721: PUSH
98722: LD_EXP 118
98726: AND
98727: IFFALSE 98829
98729: GO 98731
98731: DISABLE
98732: LD_INT 0
98734: PPUSH
98735: PPUSH
// begin enable ;
98736: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98737: LD_ADDR_VAR 0 2
98741: PUSH
98742: LD_INT 22
98744: PUSH
98745: LD_OWVAR 2
98749: PUSH
98750: EMPTY
98751: LIST
98752: LIST
98753: PUSH
98754: LD_INT 2
98756: PUSH
98757: LD_INT 34
98759: PUSH
98760: LD_INT 11
98762: PUSH
98763: EMPTY
98764: LIST
98765: LIST
98766: PUSH
98767: LD_INT 34
98769: PUSH
98770: LD_INT 30
98772: PUSH
98773: EMPTY
98774: LIST
98775: LIST
98776: PUSH
98777: EMPTY
98778: LIST
98779: LIST
98780: LIST
98781: PUSH
98782: EMPTY
98783: LIST
98784: LIST
98785: PPUSH
98786: CALL_OW 69
98790: ST_TO_ADDR
// if not tmp then
98791: LD_VAR 0 2
98795: NOT
98796: IFFALSE 98800
// exit ;
98798: GO 98829
// for i in tmp do
98800: LD_ADDR_VAR 0 1
98804: PUSH
98805: LD_VAR 0 2
98809: PUSH
98810: FOR_IN
98811: IFFALSE 98827
// begin SetLives ( i , 0 ) ;
98813: LD_VAR 0 1
98817: PPUSH
98818: LD_INT 0
98820: PPUSH
98821: CALL_OW 234
// end ;
98825: GO 98810
98827: POP
98828: POP
// end ;
98829: PPOPN 2
98831: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98832: LD_EXP 109
98836: IFFALSE 98844
98838: PUSH
98839: LD_EXP 119
98843: AND
98844: IFFALSE 98864
98846: GO 98848
98848: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98849: LD_INT 32
98851: PPUSH
98852: LD_OWVAR 2
98856: PPUSH
98857: LD_INT 0
98859: PPUSH
98860: CALL_OW 324
98864: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98865: LD_EXP 109
98869: IFFALSE 98877
98871: PUSH
98872: LD_EXP 120
98876: AND
98877: IFFALSE 99060
98879: GO 98881
98881: DISABLE
98882: LD_INT 0
98884: PPUSH
98885: PPUSH
98886: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98887: LD_ADDR_VAR 0 2
98891: PUSH
98892: LD_INT 22
98894: PUSH
98895: LD_OWVAR 2
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 33
98906: PUSH
98907: LD_INT 3
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: PPUSH
98918: CALL_OW 69
98922: ST_TO_ADDR
// if not tmp then
98923: LD_VAR 0 2
98927: NOT
98928: IFFALSE 98932
// exit ;
98930: GO 99060
// side := 0 ;
98932: LD_ADDR_VAR 0 3
98936: PUSH
98937: LD_INT 0
98939: ST_TO_ADDR
// for i := 1 to 8 do
98940: LD_ADDR_VAR 0 1
98944: PUSH
98945: DOUBLE
98946: LD_INT 1
98948: DEC
98949: ST_TO_ADDR
98950: LD_INT 8
98952: PUSH
98953: FOR_TO
98954: IFFALSE 99004
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98956: LD_OWVAR 2
98960: PUSH
98961: LD_VAR 0 1
98965: NONEQUAL
98966: IFFALSE 98988
98968: PUSH
98969: LD_OWVAR 2
98973: PPUSH
98974: LD_VAR 0 1
98978: PPUSH
98979: CALL_OW 81
98983: PUSH
98984: LD_INT 2
98986: EQUAL
98987: AND
98988: IFFALSE 99002
// begin side := i ;
98990: LD_ADDR_VAR 0 3
98994: PUSH
98995: LD_VAR 0 1
98999: ST_TO_ADDR
// break ;
99000: GO 99004
// end ;
99002: GO 98953
99004: POP
99005: POP
// if not side then
99006: LD_VAR 0 3
99010: NOT
99011: IFFALSE 99015
// exit ;
99013: GO 99060
// for i := 1 to tmp do
99015: LD_ADDR_VAR 0 1
99019: PUSH
99020: DOUBLE
99021: LD_INT 1
99023: DEC
99024: ST_TO_ADDR
99025: LD_VAR 0 2
99029: PUSH
99030: FOR_TO
99031: IFFALSE 99058
// if Prob ( 60 ) then
99033: LD_INT 60
99035: PPUSH
99036: CALL_OW 13
99040: IFFALSE 99056
// SetSide ( i , side ) ;
99042: LD_VAR 0 1
99046: PPUSH
99047: LD_VAR 0 3
99051: PPUSH
99052: CALL_OW 235
99056: GO 99030
99058: POP
99059: POP
// end ;
99060: PPOPN 3
99062: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99063: LD_EXP 109
99067: IFFALSE 99075
99069: PUSH
99070: LD_EXP 122
99074: AND
99075: IFFALSE 99194
99077: GO 99079
99079: DISABLE
99080: LD_INT 0
99082: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99083: LD_ADDR_VAR 0 1
99087: PUSH
99088: LD_INT 22
99090: PUSH
99091: LD_OWVAR 2
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: LD_INT 21
99102: PUSH
99103: LD_INT 1
99105: PUSH
99106: EMPTY
99107: LIST
99108: LIST
99109: PUSH
99110: LD_INT 3
99112: PUSH
99113: LD_INT 23
99115: PUSH
99116: LD_INT 0
99118: PUSH
99119: EMPTY
99120: LIST
99121: LIST
99122: PUSH
99123: EMPTY
99124: LIST
99125: LIST
99126: PUSH
99127: EMPTY
99128: LIST
99129: LIST
99130: LIST
99131: PPUSH
99132: CALL_OW 69
99136: PUSH
99137: FOR_IN
99138: IFFALSE 99192
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99140: LD_VAR 0 1
99144: PPUSH
99145: CALL_OW 257
99149: PUSH
99150: LD_INT 1
99152: PUSH
99153: LD_INT 2
99155: PUSH
99156: LD_INT 3
99158: PUSH
99159: LD_INT 4
99161: PUSH
99162: EMPTY
99163: LIST
99164: LIST
99165: LIST
99166: LIST
99167: IN
99168: IFFALSE 99190
// SetClass ( un , rand ( 1 , 4 ) ) ;
99170: LD_VAR 0 1
99174: PPUSH
99175: LD_INT 1
99177: PPUSH
99178: LD_INT 4
99180: PPUSH
99181: CALL_OW 12
99185: PPUSH
99186: CALL_OW 336
99190: GO 99137
99192: POP
99193: POP
// end ;
99194: PPOPN 1
99196: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99197: LD_EXP 109
99201: IFFALSE 99209
99203: PUSH
99204: LD_EXP 121
99208: AND
99209: IFFALSE 99288
99211: GO 99213
99213: DISABLE
99214: LD_INT 0
99216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99217: LD_ADDR_VAR 0 1
99221: PUSH
99222: LD_INT 22
99224: PUSH
99225: LD_OWVAR 2
99229: PUSH
99230: EMPTY
99231: LIST
99232: LIST
99233: PUSH
99234: LD_INT 21
99236: PUSH
99237: LD_INT 3
99239: PUSH
99240: EMPTY
99241: LIST
99242: LIST
99243: PUSH
99244: EMPTY
99245: LIST
99246: LIST
99247: PPUSH
99248: CALL_OW 69
99252: ST_TO_ADDR
// if not tmp then
99253: LD_VAR 0 1
99257: NOT
99258: IFFALSE 99262
// exit ;
99260: GO 99288
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99262: LD_VAR 0 1
99266: PUSH
99267: LD_INT 1
99269: PPUSH
99270: LD_VAR 0 1
99274: PPUSH
99275: CALL_OW 12
99279: ARRAY
99280: PPUSH
99281: LD_INT 100
99283: PPUSH
99284: CALL_OW 234
// end ;
99288: PPOPN 1
99290: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99291: LD_EXP 109
99295: IFFALSE 99303
99297: PUSH
99298: LD_EXP 123
99302: AND
99303: IFFALSE 99401
99305: GO 99307
99307: DISABLE
99308: LD_INT 0
99310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99311: LD_ADDR_VAR 0 1
99315: PUSH
99316: LD_INT 22
99318: PUSH
99319: LD_OWVAR 2
99323: PUSH
99324: EMPTY
99325: LIST
99326: LIST
99327: PUSH
99328: LD_INT 21
99330: PUSH
99331: LD_INT 1
99333: PUSH
99334: EMPTY
99335: LIST
99336: LIST
99337: PUSH
99338: EMPTY
99339: LIST
99340: LIST
99341: PPUSH
99342: CALL_OW 69
99346: ST_TO_ADDR
// if not tmp then
99347: LD_VAR 0 1
99351: NOT
99352: IFFALSE 99356
// exit ;
99354: GO 99401
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99356: LD_VAR 0 1
99360: PUSH
99361: LD_INT 1
99363: PPUSH
99364: LD_VAR 0 1
99368: PPUSH
99369: CALL_OW 12
99373: ARRAY
99374: PPUSH
99375: LD_INT 1
99377: PPUSH
99378: LD_INT 4
99380: PPUSH
99381: CALL_OW 12
99385: PPUSH
99386: LD_INT 3000
99388: PPUSH
99389: LD_INT 9000
99391: PPUSH
99392: CALL_OW 12
99396: PPUSH
99397: CALL_OW 492
// end ;
99401: PPOPN 1
99403: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99404: LD_EXP 109
99408: IFFALSE 99416
99410: PUSH
99411: LD_EXP 124
99415: AND
99416: IFFALSE 99436
99418: GO 99420
99420: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99421: LD_INT 1
99423: PPUSH
99424: LD_OWVAR 2
99428: PPUSH
99429: LD_INT 0
99431: PPUSH
99432: CALL_OW 324
99436: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99437: LD_EXP 109
99441: IFFALSE 99449
99443: PUSH
99444: LD_EXP 125
99448: AND
99449: IFFALSE 99532
99451: GO 99453
99453: DISABLE
99454: LD_INT 0
99456: PPUSH
99457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99458: LD_ADDR_VAR 0 2
99462: PUSH
99463: LD_INT 22
99465: PUSH
99466: LD_OWVAR 2
99470: PUSH
99471: EMPTY
99472: LIST
99473: LIST
99474: PUSH
99475: LD_INT 21
99477: PUSH
99478: LD_INT 3
99480: PUSH
99481: EMPTY
99482: LIST
99483: LIST
99484: PUSH
99485: EMPTY
99486: LIST
99487: LIST
99488: PPUSH
99489: CALL_OW 69
99493: ST_TO_ADDR
// if not tmp then
99494: LD_VAR 0 2
99498: NOT
99499: IFFALSE 99503
// exit ;
99501: GO 99532
// for i in tmp do
99503: LD_ADDR_VAR 0 1
99507: PUSH
99508: LD_VAR 0 2
99512: PUSH
99513: FOR_IN
99514: IFFALSE 99530
// SetBLevel ( i , 10 ) ;
99516: LD_VAR 0 1
99520: PPUSH
99521: LD_INT 10
99523: PPUSH
99524: CALL_OW 241
99528: GO 99513
99530: POP
99531: POP
// end ;
99532: PPOPN 2
99534: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99535: LD_EXP 109
99539: IFFALSE 99547
99541: PUSH
99542: LD_EXP 126
99546: AND
99547: IFFALSE 99658
99549: GO 99551
99551: DISABLE
99552: LD_INT 0
99554: PPUSH
99555: PPUSH
99556: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99557: LD_ADDR_VAR 0 3
99561: PUSH
99562: LD_INT 22
99564: PUSH
99565: LD_OWVAR 2
99569: PUSH
99570: EMPTY
99571: LIST
99572: LIST
99573: PUSH
99574: LD_INT 25
99576: PUSH
99577: LD_INT 1
99579: PUSH
99580: EMPTY
99581: LIST
99582: LIST
99583: PUSH
99584: EMPTY
99585: LIST
99586: LIST
99587: PPUSH
99588: CALL_OW 69
99592: ST_TO_ADDR
// if not tmp then
99593: LD_VAR 0 3
99597: NOT
99598: IFFALSE 99602
// exit ;
99600: GO 99658
// un := tmp [ rand ( 1 , tmp ) ] ;
99602: LD_ADDR_VAR 0 2
99606: PUSH
99607: LD_VAR 0 3
99611: PUSH
99612: LD_INT 1
99614: PPUSH
99615: LD_VAR 0 3
99619: PPUSH
99620: CALL_OW 12
99624: ARRAY
99625: ST_TO_ADDR
// if Crawls ( un ) then
99626: LD_VAR 0 2
99630: PPUSH
99631: CALL_OW 318
99635: IFFALSE 99646
// ComWalk ( un ) ;
99637: LD_VAR 0 2
99641: PPUSH
99642: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99646: LD_VAR 0 2
99650: PPUSH
99651: LD_INT 5
99653: PPUSH
99654: CALL_OW 336
// end ;
99658: PPOPN 3
99660: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99661: LD_EXP 109
99665: IFFALSE 99673
99667: PUSH
99668: LD_EXP 127
99672: AND
99673: IFFALSE 99685
99675: PUSH
99676: LD_OWVAR 67
99680: PUSH
99681: LD_INT 4
99683: LESS
99684: AND
99685: IFFALSE 99704
99687: GO 99689
99689: DISABLE
// begin Difficulty := Difficulty + 1 ;
99690: LD_ADDR_OWVAR 67
99694: PUSH
99695: LD_OWVAR 67
99699: PUSH
99700: LD_INT 1
99702: PLUS
99703: ST_TO_ADDR
// end ;
99704: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99705: LD_EXP 109
99709: IFFALSE 99717
99711: PUSH
99712: LD_EXP 128
99716: AND
99717: IFFALSE 99820
99719: GO 99721
99721: DISABLE
99722: LD_INT 0
99724: PPUSH
// begin for i := 1 to 5 do
99725: LD_ADDR_VAR 0 1
99729: PUSH
99730: DOUBLE
99731: LD_INT 1
99733: DEC
99734: ST_TO_ADDR
99735: LD_INT 5
99737: PUSH
99738: FOR_TO
99739: IFFALSE 99818
// begin uc_nation := nation_nature ;
99741: LD_ADDR_OWVAR 21
99745: PUSH
99746: LD_INT 0
99748: ST_TO_ADDR
// uc_side := 0 ;
99749: LD_ADDR_OWVAR 20
99753: PUSH
99754: LD_INT 0
99756: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99757: LD_ADDR_OWVAR 29
99761: PUSH
99762: LD_INT 12
99764: PUSH
99765: LD_INT 12
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: ST_TO_ADDR
// hc_agressivity := 20 ;
99772: LD_ADDR_OWVAR 35
99776: PUSH
99777: LD_INT 20
99779: ST_TO_ADDR
// hc_class := class_tiger ;
99780: LD_ADDR_OWVAR 28
99784: PUSH
99785: LD_INT 14
99787: ST_TO_ADDR
// hc_gallery :=  ;
99788: LD_ADDR_OWVAR 33
99792: PUSH
99793: LD_STRING 
99795: ST_TO_ADDR
// hc_name :=  ;
99796: LD_ADDR_OWVAR 26
99800: PUSH
99801: LD_STRING 
99803: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99804: CALL_OW 44
99808: PPUSH
99809: LD_INT 0
99811: PPUSH
99812: CALL_OW 51
// end ;
99816: GO 99738
99818: POP
99819: POP
// end ;
99820: PPOPN 1
99822: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99823: LD_EXP 109
99827: IFFALSE 99835
99829: PUSH
99830: LD_EXP 129
99834: AND
99835: IFFALSE 99844
99837: GO 99839
99839: DISABLE
// StreamSibBomb ;
99840: CALL 99845 0 0
99844: END
// export function StreamSibBomb ; var i , x , y ; begin
99845: LD_INT 0
99847: PPUSH
99848: PPUSH
99849: PPUSH
99850: PPUSH
// result := false ;
99851: LD_ADDR_VAR 0 1
99855: PUSH
99856: LD_INT 0
99858: ST_TO_ADDR
// for i := 1 to 16 do
99859: LD_ADDR_VAR 0 2
99863: PUSH
99864: DOUBLE
99865: LD_INT 1
99867: DEC
99868: ST_TO_ADDR
99869: LD_INT 16
99871: PUSH
99872: FOR_TO
99873: IFFALSE 100072
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99875: LD_ADDR_VAR 0 3
99879: PUSH
99880: LD_INT 10
99882: PUSH
99883: LD_INT 20
99885: PUSH
99886: LD_INT 30
99888: PUSH
99889: LD_INT 40
99891: PUSH
99892: LD_INT 50
99894: PUSH
99895: LD_INT 60
99897: PUSH
99898: LD_INT 70
99900: PUSH
99901: LD_INT 80
99903: PUSH
99904: LD_INT 90
99906: PUSH
99907: LD_INT 100
99909: PUSH
99910: LD_INT 110
99912: PUSH
99913: LD_INT 120
99915: PUSH
99916: LD_INT 130
99918: PUSH
99919: LD_INT 140
99921: PUSH
99922: LD_INT 150
99924: PUSH
99925: EMPTY
99926: LIST
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: PUSH
99942: LD_INT 1
99944: PPUSH
99945: LD_INT 15
99947: PPUSH
99948: CALL_OW 12
99952: ARRAY
99953: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99954: LD_ADDR_VAR 0 4
99958: PUSH
99959: LD_INT 10
99961: PUSH
99962: LD_INT 20
99964: PUSH
99965: LD_INT 30
99967: PUSH
99968: LD_INT 40
99970: PUSH
99971: LD_INT 50
99973: PUSH
99974: LD_INT 60
99976: PUSH
99977: LD_INT 70
99979: PUSH
99980: LD_INT 80
99982: PUSH
99983: LD_INT 90
99985: PUSH
99986: LD_INT 100
99988: PUSH
99989: LD_INT 110
99991: PUSH
99992: LD_INT 120
99994: PUSH
99995: LD_INT 130
99997: PUSH
99998: LD_INT 140
100000: PUSH
100001: LD_INT 150
100003: PUSH
100004: EMPTY
100005: LIST
100006: LIST
100007: LIST
100008: LIST
100009: LIST
100010: LIST
100011: LIST
100012: LIST
100013: LIST
100014: LIST
100015: LIST
100016: LIST
100017: LIST
100018: LIST
100019: LIST
100020: PUSH
100021: LD_INT 1
100023: PPUSH
100024: LD_INT 15
100026: PPUSH
100027: CALL_OW 12
100031: ARRAY
100032: ST_TO_ADDR
// if ValidHex ( x , y ) then
100033: LD_VAR 0 3
100037: PPUSH
100038: LD_VAR 0 4
100042: PPUSH
100043: CALL_OW 488
100047: IFFALSE 100070
// begin result := [ x , y ] ;
100049: LD_ADDR_VAR 0 1
100053: PUSH
100054: LD_VAR 0 3
100058: PUSH
100059: LD_VAR 0 4
100063: PUSH
100064: EMPTY
100065: LIST
100066: LIST
100067: ST_TO_ADDR
// break ;
100068: GO 100072
// end ; end ;
100070: GO 99872
100072: POP
100073: POP
// if result then
100074: LD_VAR 0 1
100078: IFFALSE 100138
// begin ToLua ( playSibBomb() ) ;
100080: LD_STRING playSibBomb()
100082: PPUSH
100083: CALL_OW 559
// wait ( 0 0$14 ) ;
100087: LD_INT 490
100089: PPUSH
100090: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100094: LD_VAR 0 1
100098: PUSH
100099: LD_INT 1
100101: ARRAY
100102: PPUSH
100103: LD_VAR 0 1
100107: PUSH
100108: LD_INT 2
100110: ARRAY
100111: PPUSH
100112: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100116: LD_VAR 0 1
100120: PUSH
100121: LD_INT 1
100123: ARRAY
100124: PPUSH
100125: LD_VAR 0 1
100129: PUSH
100130: LD_INT 2
100132: ARRAY
100133: PPUSH
100134: CALL_OW 429
// end ; end ;
100138: LD_VAR 0 1
100142: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100143: LD_EXP 109
100147: IFFALSE 100155
100149: PUSH
100150: LD_EXP 131
100154: AND
100155: IFFALSE 100167
100157: GO 100159
100159: DISABLE
// YouLost (  ) ;
100160: LD_STRING 
100162: PPUSH
100163: CALL_OW 104
100167: END
// every 0 0$1 trigger StreamModeActive and sFog do
100168: LD_EXP 109
100172: IFFALSE 100180
100174: PUSH
100175: LD_EXP 130
100179: AND
100180: IFFALSE 100194
100182: GO 100184
100184: DISABLE
// FogOff ( your_side ) ;
100185: LD_OWVAR 2
100189: PPUSH
100190: CALL_OW 344
100194: END
// every 0 0$1 trigger StreamModeActive and sSun do
100195: LD_EXP 109
100199: IFFALSE 100207
100201: PUSH
100202: LD_EXP 132
100206: AND
100207: IFFALSE 100235
100209: GO 100211
100211: DISABLE
// begin solar_recharge_percent := 0 ;
100212: LD_ADDR_OWVAR 79
100216: PUSH
100217: LD_INT 0
100219: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100220: LD_INT 10500
100222: PPUSH
100223: CALL_OW 67
// solar_recharge_percent := 100 ;
100227: LD_ADDR_OWVAR 79
100231: PUSH
100232: LD_INT 100
100234: ST_TO_ADDR
// end ;
100235: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100236: LD_EXP 109
100240: IFFALSE 100248
100242: PUSH
100243: LD_EXP 133
100247: AND
100248: IFFALSE 100487
100250: GO 100252
100252: DISABLE
100253: LD_INT 0
100255: PPUSH
100256: PPUSH
100257: PPUSH
// begin tmp := [ ] ;
100258: LD_ADDR_VAR 0 3
100262: PUSH
100263: EMPTY
100264: ST_TO_ADDR
// for i := 1 to 6 do
100265: LD_ADDR_VAR 0 1
100269: PUSH
100270: DOUBLE
100271: LD_INT 1
100273: DEC
100274: ST_TO_ADDR
100275: LD_INT 6
100277: PUSH
100278: FOR_TO
100279: IFFALSE 100384
// begin uc_nation := nation_nature ;
100281: LD_ADDR_OWVAR 21
100285: PUSH
100286: LD_INT 0
100288: ST_TO_ADDR
// uc_side := 0 ;
100289: LD_ADDR_OWVAR 20
100293: PUSH
100294: LD_INT 0
100296: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100297: LD_ADDR_OWVAR 29
100301: PUSH
100302: LD_INT 12
100304: PUSH
100305: LD_INT 12
100307: PUSH
100308: EMPTY
100309: LIST
100310: LIST
100311: ST_TO_ADDR
// hc_agressivity := 20 ;
100312: LD_ADDR_OWVAR 35
100316: PUSH
100317: LD_INT 20
100319: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100320: LD_ADDR_OWVAR 28
100324: PUSH
100325: LD_INT 17
100327: ST_TO_ADDR
// hc_gallery :=  ;
100328: LD_ADDR_OWVAR 33
100332: PUSH
100333: LD_STRING 
100335: ST_TO_ADDR
// hc_name :=  ;
100336: LD_ADDR_OWVAR 26
100340: PUSH
100341: LD_STRING 
100343: ST_TO_ADDR
// un := CreateHuman ;
100344: LD_ADDR_VAR 0 2
100348: PUSH
100349: CALL_OW 44
100353: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100354: LD_VAR 0 2
100358: PPUSH
100359: LD_INT 1
100361: PPUSH
100362: CALL_OW 51
// tmp := tmp ^ un ;
100366: LD_ADDR_VAR 0 3
100370: PUSH
100371: LD_VAR 0 3
100375: PUSH
100376: LD_VAR 0 2
100380: ADD
100381: ST_TO_ADDR
// end ;
100382: GO 100278
100384: POP
100385: POP
// repeat wait ( 0 0$1 ) ;
100386: LD_INT 35
100388: PPUSH
100389: CALL_OW 67
// for un in tmp do
100393: LD_ADDR_VAR 0 2
100397: PUSH
100398: LD_VAR 0 3
100402: PUSH
100403: FOR_IN
100404: IFFALSE 100478
// begin if IsDead ( un ) then
100406: LD_VAR 0 2
100410: PPUSH
100411: CALL_OW 301
100415: IFFALSE 100435
// begin tmp := tmp diff un ;
100417: LD_ADDR_VAR 0 3
100421: PUSH
100422: LD_VAR 0 3
100426: PUSH
100427: LD_VAR 0 2
100431: DIFF
100432: ST_TO_ADDR
// continue ;
100433: GO 100403
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100435: LD_VAR 0 2
100439: PPUSH
100440: LD_INT 3
100442: PUSH
100443: LD_INT 22
100445: PUSH
100446: LD_INT 0
100448: PUSH
100449: EMPTY
100450: LIST
100451: LIST
100452: PUSH
100453: EMPTY
100454: LIST
100455: LIST
100456: PPUSH
100457: CALL_OW 69
100461: PPUSH
100462: LD_VAR 0 2
100466: PPUSH
100467: CALL_OW 74
100471: PPUSH
100472: CALL_OW 115
// end ;
100476: GO 100403
100478: POP
100479: POP
// until not tmp ;
100480: LD_VAR 0 3
100484: NOT
100485: IFFALSE 100386
// end ;
100487: PPOPN 3
100489: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100490: LD_EXP 109
100494: IFFALSE 100502
100496: PUSH
100497: LD_EXP 134
100501: AND
100502: IFFALSE 100556
100504: GO 100506
100506: DISABLE
// begin ToLua ( displayTroll(); ) ;
100507: LD_STRING displayTroll();
100509: PPUSH
100510: CALL_OW 559
// wait ( 3 3$00 ) ;
100514: LD_INT 6300
100516: PPUSH
100517: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100521: LD_STRING hideTroll();
100523: PPUSH
100524: CALL_OW 559
// wait ( 1 1$00 ) ;
100528: LD_INT 2100
100530: PPUSH
100531: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100535: LD_STRING displayTroll();
100537: PPUSH
100538: CALL_OW 559
// wait ( 1 1$00 ) ;
100542: LD_INT 2100
100544: PPUSH
100545: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100549: LD_STRING hideTroll();
100551: PPUSH
100552: CALL_OW 559
// end ;
100556: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100557: LD_EXP 109
100561: IFFALSE 100569
100563: PUSH
100564: LD_EXP 135
100568: AND
100569: IFFALSE 100632
100571: GO 100573
100573: DISABLE
100574: LD_INT 0
100576: PPUSH
// begin p := 0 ;
100577: LD_ADDR_VAR 0 1
100581: PUSH
100582: LD_INT 0
100584: ST_TO_ADDR
// repeat game_speed := 1 ;
100585: LD_ADDR_OWVAR 65
100589: PUSH
100590: LD_INT 1
100592: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100593: LD_INT 35
100595: PPUSH
100596: CALL_OW 67
// p := p + 1 ;
100600: LD_ADDR_VAR 0 1
100604: PUSH
100605: LD_VAR 0 1
100609: PUSH
100610: LD_INT 1
100612: PLUS
100613: ST_TO_ADDR
// until p >= 60 ;
100614: LD_VAR 0 1
100618: PUSH
100619: LD_INT 60
100621: GREATEREQUAL
100622: IFFALSE 100585
// game_speed := 4 ;
100624: LD_ADDR_OWVAR 65
100628: PUSH
100629: LD_INT 4
100631: ST_TO_ADDR
// end ;
100632: PPOPN 1
100634: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100635: LD_EXP 109
100639: IFFALSE 100647
100641: PUSH
100642: LD_EXP 136
100646: AND
100647: IFFALSE 100793
100649: GO 100651
100651: DISABLE
100652: LD_INT 0
100654: PPUSH
100655: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100656: LD_ADDR_VAR 0 1
100660: PUSH
100661: LD_INT 22
100663: PUSH
100664: LD_OWVAR 2
100668: PUSH
100669: EMPTY
100670: LIST
100671: LIST
100672: PUSH
100673: LD_INT 2
100675: PUSH
100676: LD_INT 30
100678: PUSH
100679: LD_INT 0
100681: PUSH
100682: EMPTY
100683: LIST
100684: LIST
100685: PUSH
100686: LD_INT 30
100688: PUSH
100689: LD_INT 1
100691: PUSH
100692: EMPTY
100693: LIST
100694: LIST
100695: PUSH
100696: EMPTY
100697: LIST
100698: LIST
100699: LIST
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: PPUSH
100705: CALL_OW 69
100709: ST_TO_ADDR
// if not depot then
100710: LD_VAR 0 1
100714: NOT
100715: IFFALSE 100719
// exit ;
100717: GO 100793
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100719: LD_ADDR_VAR 0 2
100723: PUSH
100724: LD_VAR 0 1
100728: PUSH
100729: LD_INT 1
100731: PPUSH
100732: LD_VAR 0 1
100736: PPUSH
100737: CALL_OW 12
100741: ARRAY
100742: PPUSH
100743: CALL_OW 274
100747: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100748: LD_VAR 0 2
100752: PPUSH
100753: LD_INT 1
100755: PPUSH
100756: LD_INT 0
100758: PPUSH
100759: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100763: LD_VAR 0 2
100767: PPUSH
100768: LD_INT 2
100770: PPUSH
100771: LD_INT 0
100773: PPUSH
100774: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100778: LD_VAR 0 2
100782: PPUSH
100783: LD_INT 3
100785: PPUSH
100786: LD_INT 0
100788: PPUSH
100789: CALL_OW 277
// end ;
100793: PPOPN 2
100795: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100796: LD_EXP 109
100800: IFFALSE 100808
100802: PUSH
100803: LD_EXP 137
100807: AND
100808: IFFALSE 100905
100810: GO 100812
100812: DISABLE
100813: LD_INT 0
100815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100816: LD_ADDR_VAR 0 1
100820: PUSH
100821: LD_INT 22
100823: PUSH
100824: LD_OWVAR 2
100828: PUSH
100829: EMPTY
100830: LIST
100831: LIST
100832: PUSH
100833: LD_INT 21
100835: PUSH
100836: LD_INT 1
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: LD_INT 3
100845: PUSH
100846: LD_INT 23
100848: PUSH
100849: LD_INT 0
100851: PUSH
100852: EMPTY
100853: LIST
100854: LIST
100855: PUSH
100856: EMPTY
100857: LIST
100858: LIST
100859: PUSH
100860: EMPTY
100861: LIST
100862: LIST
100863: LIST
100864: PPUSH
100865: CALL_OW 69
100869: ST_TO_ADDR
// if not tmp then
100870: LD_VAR 0 1
100874: NOT
100875: IFFALSE 100879
// exit ;
100877: GO 100905
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100879: LD_VAR 0 1
100883: PUSH
100884: LD_INT 1
100886: PPUSH
100887: LD_VAR 0 1
100891: PPUSH
100892: CALL_OW 12
100896: ARRAY
100897: PPUSH
100898: LD_INT 200
100900: PPUSH
100901: CALL_OW 234
// end ;
100905: PPOPN 1
100907: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100908: LD_EXP 109
100912: IFFALSE 100920
100914: PUSH
100915: LD_EXP 138
100919: AND
100920: IFFALSE 100999
100922: GO 100924
100924: DISABLE
100925: LD_INT 0
100927: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100928: LD_ADDR_VAR 0 1
100932: PUSH
100933: LD_INT 22
100935: PUSH
100936: LD_OWVAR 2
100940: PUSH
100941: EMPTY
100942: LIST
100943: LIST
100944: PUSH
100945: LD_INT 21
100947: PUSH
100948: LD_INT 2
100950: PUSH
100951: EMPTY
100952: LIST
100953: LIST
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PPUSH
100959: CALL_OW 69
100963: ST_TO_ADDR
// if not tmp then
100964: LD_VAR 0 1
100968: NOT
100969: IFFALSE 100973
// exit ;
100971: GO 100999
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100973: LD_VAR 0 1
100977: PUSH
100978: LD_INT 1
100980: PPUSH
100981: LD_VAR 0 1
100985: PPUSH
100986: CALL_OW 12
100990: ARRAY
100991: PPUSH
100992: LD_INT 60
100994: PPUSH
100995: CALL_OW 234
// end ;
100999: PPOPN 1
101001: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
101002: LD_EXP 109
101006: IFFALSE 101014
101008: PUSH
101009: LD_EXP 139
101013: AND
101014: IFFALSE 101113
101016: GO 101018
101018: DISABLE
101019: LD_INT 0
101021: PPUSH
101022: PPUSH
// begin enable ;
101023: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
101024: LD_ADDR_VAR 0 1
101028: PUSH
101029: LD_INT 22
101031: PUSH
101032: LD_OWVAR 2
101036: PUSH
101037: EMPTY
101038: LIST
101039: LIST
101040: PUSH
101041: LD_INT 61
101043: PUSH
101044: EMPTY
101045: LIST
101046: PUSH
101047: LD_INT 33
101049: PUSH
101050: LD_INT 2
101052: PUSH
101053: EMPTY
101054: LIST
101055: LIST
101056: PUSH
101057: EMPTY
101058: LIST
101059: LIST
101060: LIST
101061: PPUSH
101062: CALL_OW 69
101066: ST_TO_ADDR
// if not tmp then
101067: LD_VAR 0 1
101071: NOT
101072: IFFALSE 101076
// exit ;
101074: GO 101113
// for i in tmp do
101076: LD_ADDR_VAR 0 2
101080: PUSH
101081: LD_VAR 0 1
101085: PUSH
101086: FOR_IN
101087: IFFALSE 101111
// if IsControledBy ( i ) then
101089: LD_VAR 0 2
101093: PPUSH
101094: CALL_OW 312
101098: IFFALSE 101109
// ComUnlink ( i ) ;
101100: LD_VAR 0 2
101104: PPUSH
101105: CALL_OW 136
101109: GO 101086
101111: POP
101112: POP
// end ;
101113: PPOPN 2
101115: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101116: LD_EXP 109
101120: IFFALSE 101128
101122: PUSH
101123: LD_EXP 140
101127: AND
101128: IFFALSE 101268
101130: GO 101132
101132: DISABLE
101133: LD_INT 0
101135: PPUSH
101136: PPUSH
// begin ToLua ( displayPowell(); ) ;
101137: LD_STRING displayPowell();
101139: PPUSH
101140: CALL_OW 559
// uc_side := 0 ;
101144: LD_ADDR_OWVAR 20
101148: PUSH
101149: LD_INT 0
101151: ST_TO_ADDR
// uc_nation := 2 ;
101152: LD_ADDR_OWVAR 21
101156: PUSH
101157: LD_INT 2
101159: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101160: LD_ADDR_OWVAR 37
101164: PUSH
101165: LD_INT 14
101167: ST_TO_ADDR
// vc_engine := engine_siberite ;
101168: LD_ADDR_OWVAR 39
101172: PUSH
101173: LD_INT 3
101175: ST_TO_ADDR
// vc_control := control_apeman ;
101176: LD_ADDR_OWVAR 38
101180: PUSH
101181: LD_INT 5
101183: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101184: LD_ADDR_OWVAR 40
101188: PUSH
101189: LD_INT 29
101191: ST_TO_ADDR
// un := CreateVehicle ;
101192: LD_ADDR_VAR 0 2
101196: PUSH
101197: CALL_OW 45
101201: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101202: LD_VAR 0 2
101206: PPUSH
101207: LD_INT 1
101209: PPUSH
101210: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101214: LD_INT 35
101216: PPUSH
101217: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101221: LD_VAR 0 2
101225: PPUSH
101226: LD_INT 22
101228: PUSH
101229: LD_OWVAR 2
101233: PUSH
101234: EMPTY
101235: LIST
101236: LIST
101237: PPUSH
101238: CALL_OW 69
101242: PPUSH
101243: LD_VAR 0 2
101247: PPUSH
101248: CALL_OW 74
101252: PPUSH
101253: CALL_OW 115
// until IsDead ( un ) ;
101257: LD_VAR 0 2
101261: PPUSH
101262: CALL_OW 301
101266: IFFALSE 101214
// end ;
101268: PPOPN 2
101270: END
// every 0 0$1 trigger StreamModeActive and sStu do
101271: LD_EXP 109
101275: IFFALSE 101283
101277: PUSH
101278: LD_EXP 148
101282: AND
101283: IFFALSE 101299
101285: GO 101287
101287: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101288: LD_STRING displayStucuk();
101290: PPUSH
101291: CALL_OW 559
// ResetFog ;
101295: CALL_OW 335
// end ;
101299: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101300: LD_EXP 109
101304: IFFALSE 101312
101306: PUSH
101307: LD_EXP 141
101311: AND
101312: IFFALSE 101453
101314: GO 101316
101316: DISABLE
101317: LD_INT 0
101319: PPUSH
101320: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101321: LD_ADDR_VAR 0 2
101325: PUSH
101326: LD_INT 22
101328: PUSH
101329: LD_OWVAR 2
101333: PUSH
101334: EMPTY
101335: LIST
101336: LIST
101337: PUSH
101338: LD_INT 21
101340: PUSH
101341: LD_INT 1
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: EMPTY
101349: LIST
101350: LIST
101351: PPUSH
101352: CALL_OW 69
101356: ST_TO_ADDR
// if not tmp then
101357: LD_VAR 0 2
101361: NOT
101362: IFFALSE 101366
// exit ;
101364: GO 101453
// un := tmp [ rand ( 1 , tmp ) ] ;
101366: LD_ADDR_VAR 0 1
101370: PUSH
101371: LD_VAR 0 2
101375: PUSH
101376: LD_INT 1
101378: PPUSH
101379: LD_VAR 0 2
101383: PPUSH
101384: CALL_OW 12
101388: ARRAY
101389: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101390: LD_VAR 0 1
101394: PPUSH
101395: LD_INT 0
101397: PPUSH
101398: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101402: LD_VAR 0 1
101406: PPUSH
101407: LD_OWVAR 3
101411: PUSH
101412: LD_VAR 0 1
101416: DIFF
101417: PPUSH
101418: LD_VAR 0 1
101422: PPUSH
101423: CALL_OW 74
101427: PPUSH
101428: CALL_OW 115
// wait ( 0 0$20 ) ;
101432: LD_INT 700
101434: PPUSH
101435: CALL_OW 67
// SetSide ( un , your_side ) ;
101439: LD_VAR 0 1
101443: PPUSH
101444: LD_OWVAR 2
101448: PPUSH
101449: CALL_OW 235
// end ;
101453: PPOPN 2
101455: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101456: LD_EXP 109
101460: IFFALSE 101468
101462: PUSH
101463: LD_EXP 142
101467: AND
101468: IFFALSE 101574
101470: GO 101472
101472: DISABLE
101473: LD_INT 0
101475: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101476: LD_ADDR_VAR 0 1
101480: PUSH
101481: LD_INT 22
101483: PUSH
101484: LD_OWVAR 2
101488: PUSH
101489: EMPTY
101490: LIST
101491: LIST
101492: PUSH
101493: LD_INT 2
101495: PUSH
101496: LD_INT 30
101498: PUSH
101499: LD_INT 0
101501: PUSH
101502: EMPTY
101503: LIST
101504: LIST
101505: PUSH
101506: LD_INT 30
101508: PUSH
101509: LD_INT 1
101511: PUSH
101512: EMPTY
101513: LIST
101514: LIST
101515: PUSH
101516: EMPTY
101517: LIST
101518: LIST
101519: LIST
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL_OW 69
101529: ST_TO_ADDR
// if not depot then
101530: LD_VAR 0 1
101534: NOT
101535: IFFALSE 101539
// exit ;
101537: GO 101574
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101539: LD_VAR 0 1
101543: PUSH
101544: LD_INT 1
101546: ARRAY
101547: PPUSH
101548: CALL_OW 250
101552: PPUSH
101553: LD_VAR 0 1
101557: PUSH
101558: LD_INT 1
101560: ARRAY
101561: PPUSH
101562: CALL_OW 251
101566: PPUSH
101567: LD_INT 70
101569: PPUSH
101570: CALL_OW 495
// end ;
101574: PPOPN 1
101576: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101577: LD_EXP 109
101581: IFFALSE 101589
101583: PUSH
101584: LD_EXP 143
101588: AND
101589: IFFALSE 101800
101591: GO 101593
101593: DISABLE
101594: LD_INT 0
101596: PPUSH
101597: PPUSH
101598: PPUSH
101599: PPUSH
101600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101601: LD_ADDR_VAR 0 5
101605: PUSH
101606: LD_INT 22
101608: PUSH
101609: LD_OWVAR 2
101613: PUSH
101614: EMPTY
101615: LIST
101616: LIST
101617: PUSH
101618: LD_INT 21
101620: PUSH
101621: LD_INT 1
101623: PUSH
101624: EMPTY
101625: LIST
101626: LIST
101627: PUSH
101628: EMPTY
101629: LIST
101630: LIST
101631: PPUSH
101632: CALL_OW 69
101636: ST_TO_ADDR
// if not tmp then
101637: LD_VAR 0 5
101641: NOT
101642: IFFALSE 101646
// exit ;
101644: GO 101800
// for i in tmp do
101646: LD_ADDR_VAR 0 1
101650: PUSH
101651: LD_VAR 0 5
101655: PUSH
101656: FOR_IN
101657: IFFALSE 101798
// begin d := rand ( 0 , 5 ) ;
101659: LD_ADDR_VAR 0 4
101663: PUSH
101664: LD_INT 0
101666: PPUSH
101667: LD_INT 5
101669: PPUSH
101670: CALL_OW 12
101674: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101675: LD_ADDR_VAR 0 2
101679: PUSH
101680: LD_VAR 0 1
101684: PPUSH
101685: CALL_OW 250
101689: PPUSH
101690: LD_VAR 0 4
101694: PPUSH
101695: LD_INT 3
101697: PPUSH
101698: LD_INT 12
101700: PPUSH
101701: CALL_OW 12
101705: PPUSH
101706: CALL_OW 272
101710: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101711: LD_ADDR_VAR 0 3
101715: PUSH
101716: LD_VAR 0 1
101720: PPUSH
101721: CALL_OW 251
101725: PPUSH
101726: LD_VAR 0 4
101730: PPUSH
101731: LD_INT 3
101733: PPUSH
101734: LD_INT 12
101736: PPUSH
101737: CALL_OW 12
101741: PPUSH
101742: CALL_OW 273
101746: ST_TO_ADDR
// if ValidHex ( x , y ) then
101747: LD_VAR 0 2
101751: PPUSH
101752: LD_VAR 0 3
101756: PPUSH
101757: CALL_OW 488
101761: IFFALSE 101796
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101763: LD_VAR 0 1
101767: PPUSH
101768: LD_VAR 0 2
101772: PPUSH
101773: LD_VAR 0 3
101777: PPUSH
101778: LD_INT 3
101780: PPUSH
101781: LD_INT 6
101783: PPUSH
101784: CALL_OW 12
101788: PPUSH
101789: LD_INT 1
101791: PPUSH
101792: CALL_OW 483
// end ;
101796: GO 101656
101798: POP
101799: POP
// end ;
101800: PPOPN 5
101802: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101803: LD_EXP 109
101807: IFFALSE 101815
101809: PUSH
101810: LD_EXP 144
101814: AND
101815: IFFALSE 101909
101817: GO 101819
101819: DISABLE
101820: LD_INT 0
101822: PPUSH
101823: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101824: LD_ADDR_VAR 0 2
101828: PUSH
101829: LD_INT 22
101831: PUSH
101832: LD_OWVAR 2
101836: PUSH
101837: EMPTY
101838: LIST
101839: LIST
101840: PUSH
101841: LD_INT 32
101843: PUSH
101844: LD_INT 1
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: PUSH
101851: LD_INT 21
101853: PUSH
101854: LD_INT 2
101856: PUSH
101857: EMPTY
101858: LIST
101859: LIST
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: LIST
101865: PPUSH
101866: CALL_OW 69
101870: ST_TO_ADDR
// if not tmp then
101871: LD_VAR 0 2
101875: NOT
101876: IFFALSE 101880
// exit ;
101878: GO 101909
// for i in tmp do
101880: LD_ADDR_VAR 0 1
101884: PUSH
101885: LD_VAR 0 2
101889: PUSH
101890: FOR_IN
101891: IFFALSE 101907
// SetFuel ( i , 0 ) ;
101893: LD_VAR 0 1
101897: PPUSH
101898: LD_INT 0
101900: PPUSH
101901: CALL_OW 240
101905: GO 101890
101907: POP
101908: POP
// end ;
101909: PPOPN 2
101911: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101912: LD_EXP 109
101916: IFFALSE 101924
101918: PUSH
101919: LD_EXP 145
101923: AND
101924: IFFALSE 101990
101926: GO 101928
101928: DISABLE
101929: LD_INT 0
101931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101932: LD_ADDR_VAR 0 1
101936: PUSH
101937: LD_INT 22
101939: PUSH
101940: LD_OWVAR 2
101944: PUSH
101945: EMPTY
101946: LIST
101947: LIST
101948: PUSH
101949: LD_INT 30
101951: PUSH
101952: LD_INT 29
101954: PUSH
101955: EMPTY
101956: LIST
101957: LIST
101958: PUSH
101959: EMPTY
101960: LIST
101961: LIST
101962: PPUSH
101963: CALL_OW 69
101967: ST_TO_ADDR
// if not tmp then
101968: LD_VAR 0 1
101972: NOT
101973: IFFALSE 101977
// exit ;
101975: GO 101990
// DestroyUnit ( tmp [ 1 ] ) ;
101977: LD_VAR 0 1
101981: PUSH
101982: LD_INT 1
101984: ARRAY
101985: PPUSH
101986: CALL_OW 65
// end ;
101990: PPOPN 1
101992: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101993: LD_EXP 109
101997: IFFALSE 102005
101999: PUSH
102000: LD_EXP 147
102004: AND
102005: IFFALSE 102134
102007: GO 102009
102009: DISABLE
102010: LD_INT 0
102012: PPUSH
// begin uc_side := 0 ;
102013: LD_ADDR_OWVAR 20
102017: PUSH
102018: LD_INT 0
102020: ST_TO_ADDR
// uc_nation := nation_arabian ;
102021: LD_ADDR_OWVAR 21
102025: PUSH
102026: LD_INT 2
102028: ST_TO_ADDR
// hc_gallery :=  ;
102029: LD_ADDR_OWVAR 33
102033: PUSH
102034: LD_STRING 
102036: ST_TO_ADDR
// hc_name :=  ;
102037: LD_ADDR_OWVAR 26
102041: PUSH
102042: LD_STRING 
102044: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
102045: LD_INT 1
102047: PPUSH
102048: LD_INT 11
102050: PPUSH
102051: LD_INT 10
102053: PPUSH
102054: CALL_OW 380
// un := CreateHuman ;
102058: LD_ADDR_VAR 0 1
102062: PUSH
102063: CALL_OW 44
102067: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102068: LD_VAR 0 1
102072: PPUSH
102073: LD_INT 1
102075: PPUSH
102076: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
102080: LD_INT 35
102082: PPUSH
102083: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
102087: LD_VAR 0 1
102091: PPUSH
102092: LD_INT 22
102094: PUSH
102095: LD_OWVAR 2
102099: PUSH
102100: EMPTY
102101: LIST
102102: LIST
102103: PPUSH
102104: CALL_OW 69
102108: PPUSH
102109: LD_VAR 0 1
102113: PPUSH
102114: CALL_OW 74
102118: PPUSH
102119: CALL_OW 115
// until IsDead ( un ) ;
102123: LD_VAR 0 1
102127: PPUSH
102128: CALL_OW 301
102132: IFFALSE 102080
// end ;
102134: PPOPN 1
102136: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102137: LD_EXP 109
102141: IFFALSE 102149
102143: PUSH
102144: LD_EXP 149
102148: AND
102149: IFFALSE 102161
102151: GO 102153
102153: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102154: LD_STRING earthquake(getX(game), 0, 32)
102156: PPUSH
102157: CALL_OW 559
102161: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102162: LD_EXP 109
102166: IFFALSE 102174
102168: PUSH
102169: LD_EXP 150
102173: AND
102174: IFFALSE 102265
102176: GO 102178
102178: DISABLE
102179: LD_INT 0
102181: PPUSH
// begin enable ;
102182: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102183: LD_ADDR_VAR 0 1
102187: PUSH
102188: LD_INT 22
102190: PUSH
102191: LD_OWVAR 2
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PUSH
102200: LD_INT 21
102202: PUSH
102203: LD_INT 2
102205: PUSH
102206: EMPTY
102207: LIST
102208: LIST
102209: PUSH
102210: LD_INT 33
102212: PUSH
102213: LD_INT 3
102215: PUSH
102216: EMPTY
102217: LIST
102218: LIST
102219: PUSH
102220: EMPTY
102221: LIST
102222: LIST
102223: LIST
102224: PPUSH
102225: CALL_OW 69
102229: ST_TO_ADDR
// if not tmp then
102230: LD_VAR 0 1
102234: NOT
102235: IFFALSE 102239
// exit ;
102237: GO 102265
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102239: LD_VAR 0 1
102243: PUSH
102244: LD_INT 1
102246: PPUSH
102247: LD_VAR 0 1
102251: PPUSH
102252: CALL_OW 12
102256: ARRAY
102257: PPUSH
102258: LD_INT 1
102260: PPUSH
102261: CALL_OW 234
// end ;
102265: PPOPN 1
102267: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102268: LD_EXP 109
102272: IFFALSE 102280
102274: PUSH
102275: LD_EXP 151
102279: AND
102280: IFFALSE 102421
102282: GO 102284
102284: DISABLE
102285: LD_INT 0
102287: PPUSH
102288: PPUSH
102289: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102290: LD_ADDR_VAR 0 3
102294: PUSH
102295: LD_INT 22
102297: PUSH
102298: LD_OWVAR 2
102302: PUSH
102303: EMPTY
102304: LIST
102305: LIST
102306: PUSH
102307: LD_INT 25
102309: PUSH
102310: LD_INT 1
102312: PUSH
102313: EMPTY
102314: LIST
102315: LIST
102316: PUSH
102317: EMPTY
102318: LIST
102319: LIST
102320: PPUSH
102321: CALL_OW 69
102325: ST_TO_ADDR
// if not tmp then
102326: LD_VAR 0 3
102330: NOT
102331: IFFALSE 102335
// exit ;
102333: GO 102421
// un := tmp [ rand ( 1 , tmp ) ] ;
102335: LD_ADDR_VAR 0 2
102339: PUSH
102340: LD_VAR 0 3
102344: PUSH
102345: LD_INT 1
102347: PPUSH
102348: LD_VAR 0 3
102352: PPUSH
102353: CALL_OW 12
102357: ARRAY
102358: ST_TO_ADDR
// if Crawls ( un ) then
102359: LD_VAR 0 2
102363: PPUSH
102364: CALL_OW 318
102368: IFFALSE 102379
// ComWalk ( un ) ;
102370: LD_VAR 0 2
102374: PPUSH
102375: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102379: LD_VAR 0 2
102383: PPUSH
102384: LD_INT 9
102386: PPUSH
102387: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102391: LD_INT 28
102393: PPUSH
102394: LD_OWVAR 2
102398: PPUSH
102399: LD_INT 2
102401: PPUSH
102402: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102406: LD_INT 29
102408: PPUSH
102409: LD_OWVAR 2
102413: PPUSH
102414: LD_INT 2
102416: PPUSH
102417: CALL_OW 322
// end ;
102421: PPOPN 3
102423: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102424: LD_EXP 109
102428: IFFALSE 102436
102430: PUSH
102431: LD_EXP 152
102435: AND
102436: IFFALSE 102547
102438: GO 102440
102440: DISABLE
102441: LD_INT 0
102443: PPUSH
102444: PPUSH
102445: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102446: LD_ADDR_VAR 0 3
102450: PUSH
102451: LD_INT 22
102453: PUSH
102454: LD_OWVAR 2
102458: PUSH
102459: EMPTY
102460: LIST
102461: LIST
102462: PUSH
102463: LD_INT 25
102465: PUSH
102466: LD_INT 1
102468: PUSH
102469: EMPTY
102470: LIST
102471: LIST
102472: PUSH
102473: EMPTY
102474: LIST
102475: LIST
102476: PPUSH
102477: CALL_OW 69
102481: ST_TO_ADDR
// if not tmp then
102482: LD_VAR 0 3
102486: NOT
102487: IFFALSE 102491
// exit ;
102489: GO 102547
// un := tmp [ rand ( 1 , tmp ) ] ;
102491: LD_ADDR_VAR 0 2
102495: PUSH
102496: LD_VAR 0 3
102500: PUSH
102501: LD_INT 1
102503: PPUSH
102504: LD_VAR 0 3
102508: PPUSH
102509: CALL_OW 12
102513: ARRAY
102514: ST_TO_ADDR
// if Crawls ( un ) then
102515: LD_VAR 0 2
102519: PPUSH
102520: CALL_OW 318
102524: IFFALSE 102535
// ComWalk ( un ) ;
102526: LD_VAR 0 2
102530: PPUSH
102531: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102535: LD_VAR 0 2
102539: PPUSH
102540: LD_INT 8
102542: PPUSH
102543: CALL_OW 336
// end ;
102547: PPOPN 3
102549: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102550: LD_EXP 109
102554: IFFALSE 102562
102556: PUSH
102557: LD_EXP 153
102561: AND
102562: IFFALSE 102706
102564: GO 102566
102566: DISABLE
102567: LD_INT 0
102569: PPUSH
102570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102571: LD_ADDR_VAR 0 2
102575: PUSH
102576: LD_INT 22
102578: PUSH
102579: LD_OWVAR 2
102583: PUSH
102584: EMPTY
102585: LIST
102586: LIST
102587: PUSH
102588: LD_INT 21
102590: PUSH
102591: LD_INT 2
102593: PUSH
102594: EMPTY
102595: LIST
102596: LIST
102597: PUSH
102598: LD_INT 2
102600: PUSH
102601: LD_INT 34
102603: PUSH
102604: LD_INT 12
102606: PUSH
102607: EMPTY
102608: LIST
102609: LIST
102610: PUSH
102611: LD_INT 34
102613: PUSH
102614: LD_INT 51
102616: PUSH
102617: EMPTY
102618: LIST
102619: LIST
102620: PUSH
102621: LD_INT 34
102623: PUSH
102624: LD_INT 32
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: LIST
102635: LIST
102636: PUSH
102637: EMPTY
102638: LIST
102639: LIST
102640: LIST
102641: PPUSH
102642: CALL_OW 69
102646: ST_TO_ADDR
// if not tmp then
102647: LD_VAR 0 2
102651: NOT
102652: IFFALSE 102656
// exit ;
102654: GO 102706
// for i in tmp do
102656: LD_ADDR_VAR 0 1
102660: PUSH
102661: LD_VAR 0 2
102665: PUSH
102666: FOR_IN
102667: IFFALSE 102704
// if GetCargo ( i , mat_artifact ) = 0 then
102669: LD_VAR 0 1
102673: PPUSH
102674: LD_INT 4
102676: PPUSH
102677: CALL_OW 289
102681: PUSH
102682: LD_INT 0
102684: EQUAL
102685: IFFALSE 102702
// SetCargo ( i , mat_siberit , 100 ) ;
102687: LD_VAR 0 1
102691: PPUSH
102692: LD_INT 3
102694: PPUSH
102695: LD_INT 100
102697: PPUSH
102698: CALL_OW 290
102702: GO 102666
102704: POP
102705: POP
// end ;
102706: PPOPN 2
102708: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102709: LD_EXP 109
102713: IFFALSE 102721
102715: PUSH
102716: LD_EXP 154
102720: AND
102721: IFFALSE 102904
102723: GO 102725
102725: DISABLE
102726: LD_INT 0
102728: PPUSH
102729: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102730: LD_ADDR_VAR 0 2
102734: PUSH
102735: LD_INT 22
102737: PUSH
102738: LD_OWVAR 2
102742: PUSH
102743: EMPTY
102744: LIST
102745: LIST
102746: PPUSH
102747: CALL_OW 69
102751: ST_TO_ADDR
// if not tmp then
102752: LD_VAR 0 2
102756: NOT
102757: IFFALSE 102761
// exit ;
102759: GO 102904
// for i := 1 to 2 do
102761: LD_ADDR_VAR 0 1
102765: PUSH
102766: DOUBLE
102767: LD_INT 1
102769: DEC
102770: ST_TO_ADDR
102771: LD_INT 2
102773: PUSH
102774: FOR_TO
102775: IFFALSE 102902
// begin uc_side := your_side ;
102777: LD_ADDR_OWVAR 20
102781: PUSH
102782: LD_OWVAR 2
102786: ST_TO_ADDR
// uc_nation := nation_american ;
102787: LD_ADDR_OWVAR 21
102791: PUSH
102792: LD_INT 1
102794: ST_TO_ADDR
// vc_chassis := us_morphling ;
102795: LD_ADDR_OWVAR 37
102799: PUSH
102800: LD_INT 5
102802: ST_TO_ADDR
// vc_engine := engine_siberite ;
102803: LD_ADDR_OWVAR 39
102807: PUSH
102808: LD_INT 3
102810: ST_TO_ADDR
// vc_control := control_computer ;
102811: LD_ADDR_OWVAR 38
102815: PUSH
102816: LD_INT 3
102818: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102819: LD_ADDR_OWVAR 40
102823: PUSH
102824: LD_INT 10
102826: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102827: LD_VAR 0 2
102831: PUSH
102832: LD_INT 1
102834: ARRAY
102835: PPUSH
102836: CALL_OW 310
102840: NOT
102841: IFFALSE 102888
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102843: CALL_OW 45
102847: PPUSH
102848: LD_VAR 0 2
102852: PUSH
102853: LD_INT 1
102855: ARRAY
102856: PPUSH
102857: CALL_OW 250
102861: PPUSH
102862: LD_VAR 0 2
102866: PUSH
102867: LD_INT 1
102869: ARRAY
102870: PPUSH
102871: CALL_OW 251
102875: PPUSH
102876: LD_INT 12
102878: PPUSH
102879: LD_INT 1
102881: PPUSH
102882: CALL_OW 50
102886: GO 102900
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102888: CALL_OW 45
102892: PPUSH
102893: LD_INT 1
102895: PPUSH
102896: CALL_OW 51
// end ;
102900: GO 102774
102902: POP
102903: POP
// end ;
102904: PPOPN 2
102906: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102907: LD_EXP 109
102911: IFFALSE 102919
102913: PUSH
102914: LD_EXP 155
102918: AND
102919: IFFALSE 103141
102921: GO 102923
102923: DISABLE
102924: LD_INT 0
102926: PPUSH
102927: PPUSH
102928: PPUSH
102929: PPUSH
102930: PPUSH
102931: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102932: LD_ADDR_VAR 0 6
102936: PUSH
102937: LD_INT 22
102939: PUSH
102940: LD_OWVAR 2
102944: PUSH
102945: EMPTY
102946: LIST
102947: LIST
102948: PUSH
102949: LD_INT 21
102951: PUSH
102952: LD_INT 1
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: PUSH
102959: LD_INT 3
102961: PUSH
102962: LD_INT 23
102964: PUSH
102965: LD_INT 0
102967: PUSH
102968: EMPTY
102969: LIST
102970: LIST
102971: PUSH
102972: EMPTY
102973: LIST
102974: LIST
102975: PUSH
102976: EMPTY
102977: LIST
102978: LIST
102979: LIST
102980: PPUSH
102981: CALL_OW 69
102985: ST_TO_ADDR
// if not tmp then
102986: LD_VAR 0 6
102990: NOT
102991: IFFALSE 102995
// exit ;
102993: GO 103141
// s1 := rand ( 1 , 4 ) ;
102995: LD_ADDR_VAR 0 2
102999: PUSH
103000: LD_INT 1
103002: PPUSH
103003: LD_INT 4
103005: PPUSH
103006: CALL_OW 12
103010: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
103011: LD_ADDR_VAR 0 4
103015: PUSH
103016: LD_VAR 0 6
103020: PUSH
103021: LD_INT 1
103023: ARRAY
103024: PPUSH
103025: LD_VAR 0 2
103029: PPUSH
103030: CALL_OW 259
103034: ST_TO_ADDR
// if s1 = 1 then
103035: LD_VAR 0 2
103039: PUSH
103040: LD_INT 1
103042: EQUAL
103043: IFFALSE 103063
// s2 := rand ( 2 , 4 ) else
103045: LD_ADDR_VAR 0 3
103049: PUSH
103050: LD_INT 2
103052: PPUSH
103053: LD_INT 4
103055: PPUSH
103056: CALL_OW 12
103060: ST_TO_ADDR
103061: GO 103071
// s2 := 1 ;
103063: LD_ADDR_VAR 0 3
103067: PUSH
103068: LD_INT 1
103070: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
103071: LD_ADDR_VAR 0 5
103075: PUSH
103076: LD_VAR 0 6
103080: PUSH
103081: LD_INT 1
103083: ARRAY
103084: PPUSH
103085: LD_VAR 0 3
103089: PPUSH
103090: CALL_OW 259
103094: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
103095: LD_VAR 0 6
103099: PUSH
103100: LD_INT 1
103102: ARRAY
103103: PPUSH
103104: LD_VAR 0 2
103108: PPUSH
103109: LD_VAR 0 5
103113: PPUSH
103114: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103118: LD_VAR 0 6
103122: PUSH
103123: LD_INT 1
103125: ARRAY
103126: PPUSH
103127: LD_VAR 0 3
103131: PPUSH
103132: LD_VAR 0 4
103136: PPUSH
103137: CALL_OW 237
// end ;
103141: PPOPN 6
103143: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103144: LD_EXP 109
103148: IFFALSE 103156
103150: PUSH
103151: LD_EXP 156
103155: AND
103156: IFFALSE 103235
103158: GO 103160
103160: DISABLE
103161: LD_INT 0
103163: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103164: LD_ADDR_VAR 0 1
103168: PUSH
103169: LD_INT 22
103171: PUSH
103172: LD_OWVAR 2
103176: PUSH
103177: EMPTY
103178: LIST
103179: LIST
103180: PUSH
103181: LD_INT 30
103183: PUSH
103184: LD_INT 3
103186: PUSH
103187: EMPTY
103188: LIST
103189: LIST
103190: PUSH
103191: EMPTY
103192: LIST
103193: LIST
103194: PPUSH
103195: CALL_OW 69
103199: ST_TO_ADDR
// if not tmp then
103200: LD_VAR 0 1
103204: NOT
103205: IFFALSE 103209
// exit ;
103207: GO 103235
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103209: LD_VAR 0 1
103213: PUSH
103214: LD_INT 1
103216: PPUSH
103217: LD_VAR 0 1
103221: PPUSH
103222: CALL_OW 12
103226: ARRAY
103227: PPUSH
103228: LD_INT 1
103230: PPUSH
103231: CALL_OW 234
// end ;
103235: PPOPN 1
103237: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103238: LD_EXP 109
103242: IFFALSE 103250
103244: PUSH
103245: LD_EXP 157
103249: AND
103250: IFFALSE 103362
103252: GO 103254
103254: DISABLE
103255: LD_INT 0
103257: PPUSH
103258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103259: LD_ADDR_VAR 0 2
103263: PUSH
103264: LD_INT 22
103266: PUSH
103267: LD_OWVAR 2
103271: PUSH
103272: EMPTY
103273: LIST
103274: LIST
103275: PUSH
103276: LD_INT 2
103278: PUSH
103279: LD_INT 30
103281: PUSH
103282: LD_INT 27
103284: PUSH
103285: EMPTY
103286: LIST
103287: LIST
103288: PUSH
103289: LD_INT 30
103291: PUSH
103292: LD_INT 26
103294: PUSH
103295: EMPTY
103296: LIST
103297: LIST
103298: PUSH
103299: LD_INT 30
103301: PUSH
103302: LD_INT 28
103304: PUSH
103305: EMPTY
103306: LIST
103307: LIST
103308: PUSH
103309: EMPTY
103310: LIST
103311: LIST
103312: LIST
103313: LIST
103314: PUSH
103315: EMPTY
103316: LIST
103317: LIST
103318: PPUSH
103319: CALL_OW 69
103323: ST_TO_ADDR
// if not tmp then
103324: LD_VAR 0 2
103328: NOT
103329: IFFALSE 103333
// exit ;
103331: GO 103362
// for i in tmp do
103333: LD_ADDR_VAR 0 1
103337: PUSH
103338: LD_VAR 0 2
103342: PUSH
103343: FOR_IN
103344: IFFALSE 103360
// SetLives ( i , 1 ) ;
103346: LD_VAR 0 1
103350: PPUSH
103351: LD_INT 1
103353: PPUSH
103354: CALL_OW 234
103358: GO 103343
103360: POP
103361: POP
// end ;
103362: PPOPN 2
103364: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103365: LD_EXP 109
103369: IFFALSE 103377
103371: PUSH
103372: LD_EXP 158
103376: AND
103377: IFFALSE 103664
103379: GO 103381
103381: DISABLE
103382: LD_INT 0
103384: PPUSH
103385: PPUSH
103386: PPUSH
// begin i := rand ( 1 , 7 ) ;
103387: LD_ADDR_VAR 0 1
103391: PUSH
103392: LD_INT 1
103394: PPUSH
103395: LD_INT 7
103397: PPUSH
103398: CALL_OW 12
103402: ST_TO_ADDR
// case i of 1 :
103403: LD_VAR 0 1
103407: PUSH
103408: LD_INT 1
103410: DOUBLE
103411: EQUAL
103412: IFTRUE 103416
103414: GO 103426
103416: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103417: LD_STRING earthquake(getX(game), 0, 32)
103419: PPUSH
103420: CALL_OW 559
103424: GO 103664
103426: LD_INT 2
103428: DOUBLE
103429: EQUAL
103430: IFTRUE 103434
103432: GO 103448
103434: POP
// begin ToLua ( displayStucuk(); ) ;
103435: LD_STRING displayStucuk();
103437: PPUSH
103438: CALL_OW 559
// ResetFog ;
103442: CALL_OW 335
// end ; 3 :
103446: GO 103664
103448: LD_INT 3
103450: DOUBLE
103451: EQUAL
103452: IFTRUE 103456
103454: GO 103560
103456: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103457: LD_ADDR_VAR 0 2
103461: PUSH
103462: LD_INT 22
103464: PUSH
103465: LD_OWVAR 2
103469: PUSH
103470: EMPTY
103471: LIST
103472: LIST
103473: PUSH
103474: LD_INT 25
103476: PUSH
103477: LD_INT 1
103479: PUSH
103480: EMPTY
103481: LIST
103482: LIST
103483: PUSH
103484: EMPTY
103485: LIST
103486: LIST
103487: PPUSH
103488: CALL_OW 69
103492: ST_TO_ADDR
// if not tmp then
103493: LD_VAR 0 2
103497: NOT
103498: IFFALSE 103502
// exit ;
103500: GO 103664
// un := tmp [ rand ( 1 , tmp ) ] ;
103502: LD_ADDR_VAR 0 3
103506: PUSH
103507: LD_VAR 0 2
103511: PUSH
103512: LD_INT 1
103514: PPUSH
103515: LD_VAR 0 2
103519: PPUSH
103520: CALL_OW 12
103524: ARRAY
103525: ST_TO_ADDR
// if Crawls ( un ) then
103526: LD_VAR 0 3
103530: PPUSH
103531: CALL_OW 318
103535: IFFALSE 103546
// ComWalk ( un ) ;
103537: LD_VAR 0 3
103541: PPUSH
103542: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103546: LD_VAR 0 3
103550: PPUSH
103551: LD_INT 8
103553: PPUSH
103554: CALL_OW 336
// end ; 4 :
103558: GO 103664
103560: LD_INT 4
103562: DOUBLE
103563: EQUAL
103564: IFTRUE 103568
103566: GO 103642
103568: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103569: LD_ADDR_VAR 0 2
103573: PUSH
103574: LD_INT 22
103576: PUSH
103577: LD_OWVAR 2
103581: PUSH
103582: EMPTY
103583: LIST
103584: LIST
103585: PUSH
103586: LD_INT 30
103588: PUSH
103589: LD_INT 29
103591: PUSH
103592: EMPTY
103593: LIST
103594: LIST
103595: PUSH
103596: EMPTY
103597: LIST
103598: LIST
103599: PPUSH
103600: CALL_OW 69
103604: ST_TO_ADDR
// if not tmp then
103605: LD_VAR 0 2
103609: NOT
103610: IFFALSE 103614
// exit ;
103612: GO 103664
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103614: LD_VAR 0 2
103618: PUSH
103619: LD_INT 1
103621: ARRAY
103622: PPUSH
103623: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103627: LD_VAR 0 2
103631: PUSH
103632: LD_INT 1
103634: ARRAY
103635: PPUSH
103636: CALL_OW 65
// end ; 5 .. 7 :
103640: GO 103664
103642: LD_INT 5
103644: DOUBLE
103645: GREATEREQUAL
103646: IFFALSE 103654
103648: LD_INT 7
103650: DOUBLE
103651: LESSEQUAL
103652: IFTRUE 103656
103654: GO 103663
103656: POP
// StreamSibBomb ; end ;
103657: CALL 99845 0 0
103661: GO 103664
103663: POP
// end ;
103664: PPOPN 3
103666: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103667: LD_EXP 109
103671: IFFALSE 103679
103673: PUSH
103674: LD_EXP 159
103678: AND
103679: IFFALSE 103835
103681: GO 103683
103683: DISABLE
103684: LD_INT 0
103686: PPUSH
103687: PPUSH
103688: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103689: LD_ADDR_VAR 0 2
103693: PUSH
103694: LD_INT 81
103696: PUSH
103697: LD_OWVAR 2
103701: PUSH
103702: EMPTY
103703: LIST
103704: LIST
103705: PUSH
103706: LD_INT 2
103708: PUSH
103709: LD_INT 21
103711: PUSH
103712: LD_INT 1
103714: PUSH
103715: EMPTY
103716: LIST
103717: LIST
103718: PUSH
103719: LD_INT 21
103721: PUSH
103722: LD_INT 2
103724: PUSH
103725: EMPTY
103726: LIST
103727: LIST
103728: PUSH
103729: EMPTY
103730: LIST
103731: LIST
103732: LIST
103733: PUSH
103734: EMPTY
103735: LIST
103736: LIST
103737: PPUSH
103738: CALL_OW 69
103742: ST_TO_ADDR
// if not tmp then
103743: LD_VAR 0 2
103747: NOT
103748: IFFALSE 103752
// exit ;
103750: GO 103835
// p := 0 ;
103752: LD_ADDR_VAR 0 3
103756: PUSH
103757: LD_INT 0
103759: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103760: LD_INT 35
103762: PPUSH
103763: CALL_OW 67
// p := p + 1 ;
103767: LD_ADDR_VAR 0 3
103771: PUSH
103772: LD_VAR 0 3
103776: PUSH
103777: LD_INT 1
103779: PLUS
103780: ST_TO_ADDR
// for i in tmp do
103781: LD_ADDR_VAR 0 1
103785: PUSH
103786: LD_VAR 0 2
103790: PUSH
103791: FOR_IN
103792: IFFALSE 103823
// if GetLives ( i ) < 1000 then
103794: LD_VAR 0 1
103798: PPUSH
103799: CALL_OW 256
103803: PUSH
103804: LD_INT 1000
103806: LESS
103807: IFFALSE 103821
// SetLives ( i , 1000 ) ;
103809: LD_VAR 0 1
103813: PPUSH
103814: LD_INT 1000
103816: PPUSH
103817: CALL_OW 234
103821: GO 103791
103823: POP
103824: POP
// until p > 20 ;
103825: LD_VAR 0 3
103829: PUSH
103830: LD_INT 20
103832: GREATER
103833: IFFALSE 103760
// end ;
103835: PPOPN 3
103837: END
// every 0 0$1 trigger StreamModeActive and sTime do
103838: LD_EXP 109
103842: IFFALSE 103850
103844: PUSH
103845: LD_EXP 160
103849: AND
103850: IFFALSE 103885
103852: GO 103854
103854: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103855: LD_INT 28
103857: PPUSH
103858: LD_OWVAR 2
103862: PPUSH
103863: LD_INT 2
103865: PPUSH
103866: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103870: LD_INT 30
103872: PPUSH
103873: LD_OWVAR 2
103877: PPUSH
103878: LD_INT 2
103880: PPUSH
103881: CALL_OW 322
// end ;
103885: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103886: LD_EXP 109
103890: IFFALSE 103898
103892: PUSH
103893: LD_EXP 161
103897: AND
103898: IFFALSE 104019
103900: GO 103902
103902: DISABLE
103903: LD_INT 0
103905: PPUSH
103906: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103907: LD_ADDR_VAR 0 2
103911: PUSH
103912: LD_INT 22
103914: PUSH
103915: LD_OWVAR 2
103919: PUSH
103920: EMPTY
103921: LIST
103922: LIST
103923: PUSH
103924: LD_INT 21
103926: PUSH
103927: LD_INT 1
103929: PUSH
103930: EMPTY
103931: LIST
103932: LIST
103933: PUSH
103934: LD_INT 3
103936: PUSH
103937: LD_INT 23
103939: PUSH
103940: LD_INT 0
103942: PUSH
103943: EMPTY
103944: LIST
103945: LIST
103946: PUSH
103947: EMPTY
103948: LIST
103949: LIST
103950: PUSH
103951: EMPTY
103952: LIST
103953: LIST
103954: LIST
103955: PPUSH
103956: CALL_OW 69
103960: ST_TO_ADDR
// if not tmp then
103961: LD_VAR 0 2
103965: NOT
103966: IFFALSE 103970
// exit ;
103968: GO 104019
// for i in tmp do
103970: LD_ADDR_VAR 0 1
103974: PUSH
103975: LD_VAR 0 2
103979: PUSH
103980: FOR_IN
103981: IFFALSE 104017
// begin if Crawls ( i ) then
103983: LD_VAR 0 1
103987: PPUSH
103988: CALL_OW 318
103992: IFFALSE 104003
// ComWalk ( i ) ;
103994: LD_VAR 0 1
103998: PPUSH
103999: CALL_OW 138
// SetClass ( i , 2 ) ;
104003: LD_VAR 0 1
104007: PPUSH
104008: LD_INT 2
104010: PPUSH
104011: CALL_OW 336
// end ;
104015: GO 103980
104017: POP
104018: POP
// end ;
104019: PPOPN 2
104021: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
104022: LD_EXP 109
104026: IFFALSE 104034
104028: PUSH
104029: LD_EXP 162
104033: AND
104034: IFFALSE 104324
104036: GO 104038
104038: DISABLE
104039: LD_INT 0
104041: PPUSH
104042: PPUSH
104043: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
104044: LD_OWVAR 2
104048: PPUSH
104049: LD_INT 9
104051: PPUSH
104052: LD_INT 1
104054: PPUSH
104055: LD_INT 1
104057: PPUSH
104058: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
104062: LD_INT 9
104064: PPUSH
104065: LD_OWVAR 2
104069: PPUSH
104070: CALL_OW 343
// uc_side := 9 ;
104074: LD_ADDR_OWVAR 20
104078: PUSH
104079: LD_INT 9
104081: ST_TO_ADDR
// uc_nation := 2 ;
104082: LD_ADDR_OWVAR 21
104086: PUSH
104087: LD_INT 2
104089: ST_TO_ADDR
// hc_name := Dark Warrior ;
104090: LD_ADDR_OWVAR 26
104094: PUSH
104095: LD_STRING Dark Warrior
104097: ST_TO_ADDR
// hc_gallery :=  ;
104098: LD_ADDR_OWVAR 33
104102: PUSH
104103: LD_STRING 
104105: ST_TO_ADDR
// hc_noskilllimit := true ;
104106: LD_ADDR_OWVAR 76
104110: PUSH
104111: LD_INT 1
104113: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
104114: LD_ADDR_OWVAR 31
104118: PUSH
104119: LD_INT 30
104121: PUSH
104122: LD_INT 30
104124: PUSH
104125: LD_INT 30
104127: PUSH
104128: LD_INT 30
104130: PUSH
104131: EMPTY
104132: LIST
104133: LIST
104134: LIST
104135: LIST
104136: ST_TO_ADDR
// un := CreateHuman ;
104137: LD_ADDR_VAR 0 3
104141: PUSH
104142: CALL_OW 44
104146: ST_TO_ADDR
// hc_noskilllimit := false ;
104147: LD_ADDR_OWVAR 76
104151: PUSH
104152: LD_INT 0
104154: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104155: LD_VAR 0 3
104159: PPUSH
104160: LD_INT 1
104162: PPUSH
104163: CALL_OW 51
// ToLua ( playRanger() ) ;
104167: LD_STRING playRanger()
104169: PPUSH
104170: CALL_OW 559
// p := 0 ;
104174: LD_ADDR_VAR 0 2
104178: PUSH
104179: LD_INT 0
104181: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104182: LD_INT 35
104184: PPUSH
104185: CALL_OW 67
// p := p + 1 ;
104189: LD_ADDR_VAR 0 2
104193: PUSH
104194: LD_VAR 0 2
104198: PUSH
104199: LD_INT 1
104201: PLUS
104202: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104203: LD_VAR 0 3
104207: PPUSH
104208: CALL_OW 256
104212: PUSH
104213: LD_INT 1000
104215: LESS
104216: IFFALSE 104230
// SetLives ( un , 1000 ) ;
104218: LD_VAR 0 3
104222: PPUSH
104223: LD_INT 1000
104225: PPUSH
104226: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104230: LD_VAR 0 3
104234: PPUSH
104235: LD_INT 81
104237: PUSH
104238: LD_OWVAR 2
104242: PUSH
104243: EMPTY
104244: LIST
104245: LIST
104246: PUSH
104247: LD_INT 91
104249: PUSH
104250: LD_VAR 0 3
104254: PUSH
104255: LD_INT 30
104257: PUSH
104258: EMPTY
104259: LIST
104260: LIST
104261: LIST
104262: PUSH
104263: EMPTY
104264: LIST
104265: LIST
104266: PPUSH
104267: CALL_OW 69
104271: PPUSH
104272: LD_VAR 0 3
104276: PPUSH
104277: CALL_OW 74
104281: PPUSH
104282: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104286: LD_VAR 0 2
104290: PUSH
104291: LD_INT 80
104293: GREATER
104294: IFTRUE 104307
104296: PUSH
104297: LD_VAR 0 3
104301: PPUSH
104302: CALL_OW 301
104306: OR
104307: IFFALSE 104182
// if un then
104309: LD_VAR 0 3
104313: IFFALSE 104324
// RemoveUnit ( un ) ;
104315: LD_VAR 0 3
104319: PPUSH
104320: CALL_OW 64
// end ;
104324: PPOPN 3
104326: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104327: LD_EXP 163
104331: IFFALSE 104447
104333: GO 104335
104335: DISABLE
104336: LD_INT 0
104338: PPUSH
104339: PPUSH
104340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104341: LD_ADDR_VAR 0 2
104345: PUSH
104346: LD_INT 81
104348: PUSH
104349: LD_OWVAR 2
104353: PUSH
104354: EMPTY
104355: LIST
104356: LIST
104357: PUSH
104358: LD_INT 21
104360: PUSH
104361: LD_INT 1
104363: PUSH
104364: EMPTY
104365: LIST
104366: LIST
104367: PUSH
104368: EMPTY
104369: LIST
104370: LIST
104371: PPUSH
104372: CALL_OW 69
104376: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104377: LD_STRING playComputer()
104379: PPUSH
104380: CALL_OW 559
// if not tmp then
104384: LD_VAR 0 2
104388: NOT
104389: IFFALSE 104393
// exit ;
104391: GO 104447
// for i in tmp do
104393: LD_ADDR_VAR 0 1
104397: PUSH
104398: LD_VAR 0 2
104402: PUSH
104403: FOR_IN
104404: IFFALSE 104445
// for j := 1 to 4 do
104406: LD_ADDR_VAR 0 3
104410: PUSH
104411: DOUBLE
104412: LD_INT 1
104414: DEC
104415: ST_TO_ADDR
104416: LD_INT 4
104418: PUSH
104419: FOR_TO
104420: IFFALSE 104441
// SetSkill ( i , j , 10 ) ;
104422: LD_VAR 0 1
104426: PPUSH
104427: LD_VAR 0 3
104431: PPUSH
104432: LD_INT 10
104434: PPUSH
104435: CALL_OW 237
104439: GO 104419
104441: POP
104442: POP
104443: GO 104403
104445: POP
104446: POP
// end ;
104447: PPOPN 3
104449: END
// every 0 0$1 trigger s30 do var i , tmp ;
104450: LD_EXP 164
104454: IFFALSE 104523
104456: GO 104458
104458: DISABLE
104459: LD_INT 0
104461: PPUSH
104462: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104463: LD_ADDR_VAR 0 2
104467: PUSH
104468: LD_INT 22
104470: PUSH
104471: LD_OWVAR 2
104475: PUSH
104476: EMPTY
104477: LIST
104478: LIST
104479: PPUSH
104480: CALL_OW 69
104484: ST_TO_ADDR
// if not tmp then
104485: LD_VAR 0 2
104489: NOT
104490: IFFALSE 104494
// exit ;
104492: GO 104523
// for i in tmp do
104494: LD_ADDR_VAR 0 1
104498: PUSH
104499: LD_VAR 0 2
104503: PUSH
104504: FOR_IN
104505: IFFALSE 104521
// SetLives ( i , 300 ) ;
104507: LD_VAR 0 1
104511: PPUSH
104512: LD_INT 300
104514: PPUSH
104515: CALL_OW 234
104519: GO 104504
104521: POP
104522: POP
// end ;
104523: PPOPN 2
104525: END
// every 0 0$1 trigger s60 do var i , tmp ;
104526: LD_EXP 165
104530: IFFALSE 104599
104532: GO 104534
104534: DISABLE
104535: LD_INT 0
104537: PPUSH
104538: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104539: LD_ADDR_VAR 0 2
104543: PUSH
104544: LD_INT 22
104546: PUSH
104547: LD_OWVAR 2
104551: PUSH
104552: EMPTY
104553: LIST
104554: LIST
104555: PPUSH
104556: CALL_OW 69
104560: ST_TO_ADDR
// if not tmp then
104561: LD_VAR 0 2
104565: NOT
104566: IFFALSE 104570
// exit ;
104568: GO 104599
// for i in tmp do
104570: LD_ADDR_VAR 0 1
104574: PUSH
104575: LD_VAR 0 2
104579: PUSH
104580: FOR_IN
104581: IFFALSE 104597
// SetLives ( i , 600 ) ;
104583: LD_VAR 0 1
104587: PPUSH
104588: LD_INT 600
104590: PPUSH
104591: CALL_OW 234
104595: GO 104580
104597: POP
104598: POP
// end ;
104599: PPOPN 2
104601: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104602: LD_INT 0
104604: PPUSH
// case cmd of 301 :
104605: LD_VAR 0 1
104609: PUSH
104610: LD_INT 301
104612: DOUBLE
104613: EQUAL
104614: IFTRUE 104618
104616: GO 104650
104618: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104619: LD_VAR 0 6
104623: PPUSH
104624: LD_VAR 0 7
104628: PPUSH
104629: LD_VAR 0 8
104633: PPUSH
104634: LD_VAR 0 4
104638: PPUSH
104639: LD_VAR 0 5
104643: PPUSH
104644: CALL 105863 0 5
104648: GO 104771
104650: LD_INT 302
104652: DOUBLE
104653: EQUAL
104654: IFTRUE 104658
104656: GO 104695
104658: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104659: LD_VAR 0 6
104663: PPUSH
104664: LD_VAR 0 7
104668: PPUSH
104669: LD_VAR 0 8
104673: PPUSH
104674: LD_VAR 0 9
104678: PPUSH
104679: LD_VAR 0 4
104683: PPUSH
104684: LD_VAR 0 5
104688: PPUSH
104689: CALL 105954 0 6
104693: GO 104771
104695: LD_INT 303
104697: DOUBLE
104698: EQUAL
104699: IFTRUE 104703
104701: GO 104740
104703: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104704: LD_VAR 0 6
104708: PPUSH
104709: LD_VAR 0 7
104713: PPUSH
104714: LD_VAR 0 8
104718: PPUSH
104719: LD_VAR 0 9
104723: PPUSH
104724: LD_VAR 0 4
104728: PPUSH
104729: LD_VAR 0 5
104733: PPUSH
104734: CALL 104776 0 6
104738: GO 104771
104740: LD_INT 304
104742: DOUBLE
104743: EQUAL
104744: IFTRUE 104748
104746: GO 104770
104748: POP
// hHackTeleport ( unit , x , y ) ; end ;
104749: LD_VAR 0 2
104753: PPUSH
104754: LD_VAR 0 4
104758: PPUSH
104759: LD_VAR 0 5
104763: PPUSH
104764: CALL 106547 0 3
104768: GO 104771
104770: POP
// end ;
104771: LD_VAR 0 12
104775: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104776: LD_INT 0
104778: PPUSH
104779: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104780: LD_VAR 0 1
104784: PUSH
104785: LD_INT 1
104787: LESS
104788: IFTRUE 104800
104790: PUSH
104791: LD_VAR 0 1
104795: PUSH
104796: LD_INT 3
104798: GREATER
104799: OR
104800: IFTRUE 104818
104802: PUSH
104803: LD_VAR 0 5
104807: PPUSH
104808: LD_VAR 0 6
104812: PPUSH
104813: CALL_OW 428
104817: OR
104818: IFFALSE 104822
// exit ;
104820: GO 105550
// uc_side := your_side ;
104822: LD_ADDR_OWVAR 20
104826: PUSH
104827: LD_OWVAR 2
104831: ST_TO_ADDR
// uc_nation := nation ;
104832: LD_ADDR_OWVAR 21
104836: PUSH
104837: LD_VAR 0 1
104841: ST_TO_ADDR
// bc_level = 1 ;
104842: LD_ADDR_OWVAR 43
104846: PUSH
104847: LD_INT 1
104849: ST_TO_ADDR
// case btype of 1 :
104850: LD_VAR 0 2
104854: PUSH
104855: LD_INT 1
104857: DOUBLE
104858: EQUAL
104859: IFTRUE 104863
104861: GO 104874
104863: POP
// bc_type := b_depot ; 2 :
104864: LD_ADDR_OWVAR 42
104868: PUSH
104869: LD_INT 0
104871: ST_TO_ADDR
104872: GO 105494
104874: LD_INT 2
104876: DOUBLE
104877: EQUAL
104878: IFTRUE 104882
104880: GO 104893
104882: POP
// bc_type := b_warehouse ; 3 :
104883: LD_ADDR_OWVAR 42
104887: PUSH
104888: LD_INT 1
104890: ST_TO_ADDR
104891: GO 105494
104893: LD_INT 3
104895: DOUBLE
104896: EQUAL
104897: IFTRUE 104901
104899: GO 104912
104901: POP
// bc_type := b_lab ; 4 .. 9 :
104902: LD_ADDR_OWVAR 42
104906: PUSH
104907: LD_INT 6
104909: ST_TO_ADDR
104910: GO 105494
104912: LD_INT 4
104914: DOUBLE
104915: GREATEREQUAL
104916: IFFALSE 104924
104918: LD_INT 9
104920: DOUBLE
104921: LESSEQUAL
104922: IFTRUE 104926
104924: GO 104986
104926: POP
// begin bc_type := b_lab_half ;
104927: LD_ADDR_OWVAR 42
104931: PUSH
104932: LD_INT 7
104934: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104935: LD_ADDR_OWVAR 44
104939: PUSH
104940: LD_INT 10
104942: PUSH
104943: LD_INT 11
104945: PUSH
104946: LD_INT 12
104948: PUSH
104949: LD_INT 15
104951: PUSH
104952: LD_INT 14
104954: PUSH
104955: LD_INT 13
104957: PUSH
104958: EMPTY
104959: LIST
104960: LIST
104961: LIST
104962: LIST
104963: LIST
104964: LIST
104965: PUSH
104966: LD_VAR 0 2
104970: PUSH
104971: LD_INT 3
104973: MINUS
104974: ARRAY
104975: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104976: LD_ADDR_OWVAR 45
104980: PUSH
104981: LD_INT 9
104983: ST_TO_ADDR
// end ; 10 .. 13 :
104984: GO 105494
104986: LD_INT 10
104988: DOUBLE
104989: GREATEREQUAL
104990: IFFALSE 104998
104992: LD_INT 13
104994: DOUBLE
104995: LESSEQUAL
104996: IFTRUE 105000
104998: GO 105077
105000: POP
// begin bc_type := b_lab_full ;
105001: LD_ADDR_OWVAR 42
105005: PUSH
105006: LD_INT 8
105008: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
105009: LD_ADDR_OWVAR 44
105013: PUSH
105014: LD_INT 10
105016: PUSH
105017: LD_INT 12
105019: PUSH
105020: LD_INT 14
105022: PUSH
105023: LD_INT 13
105025: PUSH
105026: EMPTY
105027: LIST
105028: LIST
105029: LIST
105030: LIST
105031: PUSH
105032: LD_VAR 0 2
105036: PUSH
105037: LD_INT 9
105039: MINUS
105040: ARRAY
105041: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
105042: LD_ADDR_OWVAR 45
105046: PUSH
105047: LD_INT 11
105049: PUSH
105050: LD_INT 15
105052: PUSH
105053: LD_INT 12
105055: PUSH
105056: LD_INT 15
105058: PUSH
105059: EMPTY
105060: LIST
105061: LIST
105062: LIST
105063: LIST
105064: PUSH
105065: LD_VAR 0 2
105069: PUSH
105070: LD_INT 9
105072: MINUS
105073: ARRAY
105074: ST_TO_ADDR
// end ; 14 :
105075: GO 105494
105077: LD_INT 14
105079: DOUBLE
105080: EQUAL
105081: IFTRUE 105085
105083: GO 105096
105085: POP
// bc_type := b_workshop ; 15 :
105086: LD_ADDR_OWVAR 42
105090: PUSH
105091: LD_INT 2
105093: ST_TO_ADDR
105094: GO 105494
105096: LD_INT 15
105098: DOUBLE
105099: EQUAL
105100: IFTRUE 105104
105102: GO 105115
105104: POP
// bc_type := b_factory ; 16 :
105105: LD_ADDR_OWVAR 42
105109: PUSH
105110: LD_INT 3
105112: ST_TO_ADDR
105113: GO 105494
105115: LD_INT 16
105117: DOUBLE
105118: EQUAL
105119: IFTRUE 105123
105121: GO 105134
105123: POP
// bc_type := b_ext_gun ; 17 :
105124: LD_ADDR_OWVAR 42
105128: PUSH
105129: LD_INT 17
105131: ST_TO_ADDR
105132: GO 105494
105134: LD_INT 17
105136: DOUBLE
105137: EQUAL
105138: IFTRUE 105142
105140: GO 105170
105142: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105143: LD_ADDR_OWVAR 42
105147: PUSH
105148: LD_INT 19
105150: PUSH
105151: LD_INT 23
105153: PUSH
105154: LD_INT 19
105156: PUSH
105157: EMPTY
105158: LIST
105159: LIST
105160: LIST
105161: PUSH
105162: LD_VAR 0 1
105166: ARRAY
105167: ST_TO_ADDR
105168: GO 105494
105170: LD_INT 18
105172: DOUBLE
105173: EQUAL
105174: IFTRUE 105178
105176: GO 105189
105178: POP
// bc_type := b_ext_radar ; 19 :
105179: LD_ADDR_OWVAR 42
105183: PUSH
105184: LD_INT 20
105186: ST_TO_ADDR
105187: GO 105494
105189: LD_INT 19
105191: DOUBLE
105192: EQUAL
105193: IFTRUE 105197
105195: GO 105208
105197: POP
// bc_type := b_ext_radio ; 20 :
105198: LD_ADDR_OWVAR 42
105202: PUSH
105203: LD_INT 22
105205: ST_TO_ADDR
105206: GO 105494
105208: LD_INT 20
105210: DOUBLE
105211: EQUAL
105212: IFTRUE 105216
105214: GO 105227
105216: POP
// bc_type := b_ext_siberium ; 21 :
105217: LD_ADDR_OWVAR 42
105221: PUSH
105222: LD_INT 21
105224: ST_TO_ADDR
105225: GO 105494
105227: LD_INT 21
105229: DOUBLE
105230: EQUAL
105231: IFTRUE 105235
105233: GO 105246
105235: POP
// bc_type := b_ext_computer ; 22 :
105236: LD_ADDR_OWVAR 42
105240: PUSH
105241: LD_INT 24
105243: ST_TO_ADDR
105244: GO 105494
105246: LD_INT 22
105248: DOUBLE
105249: EQUAL
105250: IFTRUE 105254
105252: GO 105265
105254: POP
// bc_type := b_ext_track ; 23 :
105255: LD_ADDR_OWVAR 42
105259: PUSH
105260: LD_INT 16
105262: ST_TO_ADDR
105263: GO 105494
105265: LD_INT 23
105267: DOUBLE
105268: EQUAL
105269: IFTRUE 105273
105271: GO 105284
105273: POP
// bc_type := b_ext_laser ; 24 :
105274: LD_ADDR_OWVAR 42
105278: PUSH
105279: LD_INT 25
105281: ST_TO_ADDR
105282: GO 105494
105284: LD_INT 24
105286: DOUBLE
105287: EQUAL
105288: IFTRUE 105292
105290: GO 105303
105292: POP
// bc_type := b_control_tower ; 25 :
105293: LD_ADDR_OWVAR 42
105297: PUSH
105298: LD_INT 36
105300: ST_TO_ADDR
105301: GO 105494
105303: LD_INT 25
105305: DOUBLE
105306: EQUAL
105307: IFTRUE 105311
105309: GO 105322
105311: POP
// bc_type := b_breastwork ; 26 :
105312: LD_ADDR_OWVAR 42
105316: PUSH
105317: LD_INT 31
105319: ST_TO_ADDR
105320: GO 105494
105322: LD_INT 26
105324: DOUBLE
105325: EQUAL
105326: IFTRUE 105330
105328: GO 105341
105330: POP
// bc_type := b_bunker ; 27 :
105331: LD_ADDR_OWVAR 42
105335: PUSH
105336: LD_INT 32
105338: ST_TO_ADDR
105339: GO 105494
105341: LD_INT 27
105343: DOUBLE
105344: EQUAL
105345: IFTRUE 105349
105347: GO 105360
105349: POP
// bc_type := b_turret ; 28 :
105350: LD_ADDR_OWVAR 42
105354: PUSH
105355: LD_INT 33
105357: ST_TO_ADDR
105358: GO 105494
105360: LD_INT 28
105362: DOUBLE
105363: EQUAL
105364: IFTRUE 105368
105366: GO 105379
105368: POP
// bc_type := b_armoury ; 29 :
105369: LD_ADDR_OWVAR 42
105373: PUSH
105374: LD_INT 4
105376: ST_TO_ADDR
105377: GO 105494
105379: LD_INT 29
105381: DOUBLE
105382: EQUAL
105383: IFTRUE 105387
105385: GO 105398
105387: POP
// bc_type := b_barracks ; 30 :
105388: LD_ADDR_OWVAR 42
105392: PUSH
105393: LD_INT 5
105395: ST_TO_ADDR
105396: GO 105494
105398: LD_INT 30
105400: DOUBLE
105401: EQUAL
105402: IFTRUE 105406
105404: GO 105417
105406: POP
// bc_type := b_solar_power ; 31 :
105407: LD_ADDR_OWVAR 42
105411: PUSH
105412: LD_INT 27
105414: ST_TO_ADDR
105415: GO 105494
105417: LD_INT 31
105419: DOUBLE
105420: EQUAL
105421: IFTRUE 105425
105423: GO 105436
105425: POP
// bc_type := b_oil_power ; 32 :
105426: LD_ADDR_OWVAR 42
105430: PUSH
105431: LD_INT 26
105433: ST_TO_ADDR
105434: GO 105494
105436: LD_INT 32
105438: DOUBLE
105439: EQUAL
105440: IFTRUE 105444
105442: GO 105455
105444: POP
// bc_type := b_siberite_power ; 33 :
105445: LD_ADDR_OWVAR 42
105449: PUSH
105450: LD_INT 28
105452: ST_TO_ADDR
105453: GO 105494
105455: LD_INT 33
105457: DOUBLE
105458: EQUAL
105459: IFTRUE 105463
105461: GO 105474
105463: POP
// bc_type := b_oil_mine ; 34 :
105464: LD_ADDR_OWVAR 42
105468: PUSH
105469: LD_INT 29
105471: ST_TO_ADDR
105472: GO 105494
105474: LD_INT 34
105476: DOUBLE
105477: EQUAL
105478: IFTRUE 105482
105480: GO 105493
105482: POP
// bc_type := b_siberite_mine ; end ;
105483: LD_ADDR_OWVAR 42
105487: PUSH
105488: LD_INT 30
105490: ST_TO_ADDR
105491: GO 105494
105493: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105494: LD_ADDR_VAR 0 8
105498: PUSH
105499: LD_VAR 0 5
105503: PPUSH
105504: LD_VAR 0 6
105508: PPUSH
105509: LD_VAR 0 3
105513: PPUSH
105514: CALL_OW 47
105518: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105519: LD_OWVAR 42
105523: PUSH
105524: LD_INT 32
105526: PUSH
105527: LD_INT 33
105529: PUSH
105530: EMPTY
105531: LIST
105532: LIST
105533: IN
105534: IFFALSE 105550
// PlaceWeaponTurret ( b , weapon ) ;
105536: LD_VAR 0 8
105540: PPUSH
105541: LD_VAR 0 4
105545: PPUSH
105546: CALL_OW 431
// end ;
105550: LD_VAR 0 7
105554: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105555: LD_INT 0
105557: PPUSH
105558: PPUSH
105559: PPUSH
105560: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105561: LD_ADDR_VAR 0 4
105565: PUSH
105566: LD_INT 22
105568: PUSH
105569: LD_OWVAR 2
105573: PUSH
105574: EMPTY
105575: LIST
105576: LIST
105577: PUSH
105578: LD_INT 2
105580: PUSH
105581: LD_INT 30
105583: PUSH
105584: LD_INT 0
105586: PUSH
105587: EMPTY
105588: LIST
105589: LIST
105590: PUSH
105591: LD_INT 30
105593: PUSH
105594: LD_INT 1
105596: PUSH
105597: EMPTY
105598: LIST
105599: LIST
105600: PUSH
105601: EMPTY
105602: LIST
105603: LIST
105604: LIST
105605: PUSH
105606: EMPTY
105607: LIST
105608: LIST
105609: PPUSH
105610: CALL_OW 69
105614: ST_TO_ADDR
// if not tmp then
105615: LD_VAR 0 4
105619: NOT
105620: IFFALSE 105624
// exit ;
105622: GO 105683
// for i in tmp do
105624: LD_ADDR_VAR 0 2
105628: PUSH
105629: LD_VAR 0 4
105633: PUSH
105634: FOR_IN
105635: IFFALSE 105681
// for j = 1 to 3 do
105637: LD_ADDR_VAR 0 3
105641: PUSH
105642: DOUBLE
105643: LD_INT 1
105645: DEC
105646: ST_TO_ADDR
105647: LD_INT 3
105649: PUSH
105650: FOR_TO
105651: IFFALSE 105677
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105653: LD_VAR 0 2
105657: PPUSH
105658: CALL_OW 274
105662: PPUSH
105663: LD_VAR 0 3
105667: PPUSH
105668: LD_INT 99999
105670: PPUSH
105671: CALL_OW 277
105675: GO 105650
105677: POP
105678: POP
105679: GO 105634
105681: POP
105682: POP
// end ;
105683: LD_VAR 0 1
105687: RET
// export function hHackSetLevel10 ; var i , j ; begin
105688: LD_INT 0
105690: PPUSH
105691: PPUSH
105692: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105693: LD_ADDR_VAR 0 2
105697: PUSH
105698: LD_INT 21
105700: PUSH
105701: LD_INT 1
105703: PUSH
105704: EMPTY
105705: LIST
105706: LIST
105707: PPUSH
105708: CALL_OW 69
105712: PUSH
105713: FOR_IN
105714: IFFALSE 105766
// if IsSelected ( i ) then
105716: LD_VAR 0 2
105720: PPUSH
105721: CALL_OW 306
105725: IFFALSE 105764
// begin for j := 1 to 4 do
105727: LD_ADDR_VAR 0 3
105731: PUSH
105732: DOUBLE
105733: LD_INT 1
105735: DEC
105736: ST_TO_ADDR
105737: LD_INT 4
105739: PUSH
105740: FOR_TO
105741: IFFALSE 105762
// SetSkill ( i , j , 10 ) ;
105743: LD_VAR 0 2
105747: PPUSH
105748: LD_VAR 0 3
105752: PPUSH
105753: LD_INT 10
105755: PPUSH
105756: CALL_OW 237
105760: GO 105740
105762: POP
105763: POP
// end ;
105764: GO 105713
105766: POP
105767: POP
// end ;
105768: LD_VAR 0 1
105772: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105773: LD_INT 0
105775: PPUSH
105776: PPUSH
105777: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105778: LD_ADDR_VAR 0 2
105782: PUSH
105783: LD_INT 22
105785: PUSH
105786: LD_OWVAR 2
105790: PUSH
105791: EMPTY
105792: LIST
105793: LIST
105794: PUSH
105795: LD_INT 21
105797: PUSH
105798: LD_INT 1
105800: PUSH
105801: EMPTY
105802: LIST
105803: LIST
105804: PUSH
105805: EMPTY
105806: LIST
105807: LIST
105808: PPUSH
105809: CALL_OW 69
105813: PUSH
105814: FOR_IN
105815: IFFALSE 105856
// begin for j := 1 to 4 do
105817: LD_ADDR_VAR 0 3
105821: PUSH
105822: DOUBLE
105823: LD_INT 1
105825: DEC
105826: ST_TO_ADDR
105827: LD_INT 4
105829: PUSH
105830: FOR_TO
105831: IFFALSE 105852
// SetSkill ( i , j , 10 ) ;
105833: LD_VAR 0 2
105837: PPUSH
105838: LD_VAR 0 3
105842: PPUSH
105843: LD_INT 10
105845: PPUSH
105846: CALL_OW 237
105850: GO 105830
105852: POP
105853: POP
// end ;
105854: GO 105814
105856: POP
105857: POP
// end ;
105858: LD_VAR 0 1
105862: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105863: LD_INT 0
105865: PPUSH
// uc_side := your_side ;
105866: LD_ADDR_OWVAR 20
105870: PUSH
105871: LD_OWVAR 2
105875: ST_TO_ADDR
// uc_nation := nation ;
105876: LD_ADDR_OWVAR 21
105880: PUSH
105881: LD_VAR 0 1
105885: ST_TO_ADDR
// InitHc ;
105886: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105890: LD_INT 0
105892: PPUSH
105893: LD_VAR 0 2
105897: PPUSH
105898: LD_VAR 0 3
105902: PPUSH
105903: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105907: LD_VAR 0 4
105911: PPUSH
105912: LD_VAR 0 5
105916: PPUSH
105917: CALL_OW 428
105921: PUSH
105922: LD_INT 0
105924: EQUAL
105925: IFFALSE 105949
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105927: CALL_OW 44
105931: PPUSH
105932: LD_VAR 0 4
105936: PPUSH
105937: LD_VAR 0 5
105941: PPUSH
105942: LD_INT 1
105944: PPUSH
105945: CALL_OW 48
// end ;
105949: LD_VAR 0 6
105953: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105954: LD_INT 0
105956: PPUSH
105957: PPUSH
// uc_side := your_side ;
105958: LD_ADDR_OWVAR 20
105962: PUSH
105963: LD_OWVAR 2
105967: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105968: LD_VAR 0 1
105972: PUSH
105973: LD_INT 1
105975: PUSH
105976: LD_INT 2
105978: PUSH
105979: LD_INT 3
105981: PUSH
105982: LD_INT 4
105984: PUSH
105985: LD_INT 5
105987: PUSH
105988: EMPTY
105989: LIST
105990: LIST
105991: LIST
105992: LIST
105993: LIST
105994: IN
105995: IFFALSE 106007
// uc_nation := nation_american else
105997: LD_ADDR_OWVAR 21
106001: PUSH
106002: LD_INT 1
106004: ST_TO_ADDR
106005: GO 106050
// if chassis in [ 11 , 12 , 13 , 14 ] then
106007: LD_VAR 0 1
106011: PUSH
106012: LD_INT 11
106014: PUSH
106015: LD_INT 12
106017: PUSH
106018: LD_INT 13
106020: PUSH
106021: LD_INT 14
106023: PUSH
106024: EMPTY
106025: LIST
106026: LIST
106027: LIST
106028: LIST
106029: IN
106030: IFFALSE 106042
// uc_nation := nation_arabian else
106032: LD_ADDR_OWVAR 21
106036: PUSH
106037: LD_INT 2
106039: ST_TO_ADDR
106040: GO 106050
// uc_nation := nation_russian ;
106042: LD_ADDR_OWVAR 21
106046: PUSH
106047: LD_INT 3
106049: ST_TO_ADDR
// vc_chassis := chassis ;
106050: LD_ADDR_OWVAR 37
106054: PUSH
106055: LD_VAR 0 1
106059: ST_TO_ADDR
// vc_engine := engine ;
106060: LD_ADDR_OWVAR 39
106064: PUSH
106065: LD_VAR 0 2
106069: ST_TO_ADDR
// vc_control := control ;
106070: LD_ADDR_OWVAR 38
106074: PUSH
106075: LD_VAR 0 3
106079: ST_TO_ADDR
// vc_weapon := weapon ;
106080: LD_ADDR_OWVAR 40
106084: PUSH
106085: LD_VAR 0 4
106089: ST_TO_ADDR
// un := CreateVehicle ;
106090: LD_ADDR_VAR 0 8
106094: PUSH
106095: CALL_OW 45
106099: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
106100: LD_VAR 0 8
106104: PPUSH
106105: LD_INT 0
106107: PPUSH
106108: LD_INT 5
106110: PPUSH
106111: CALL_OW 12
106115: PPUSH
106116: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
106120: LD_VAR 0 8
106124: PPUSH
106125: LD_VAR 0 5
106129: PPUSH
106130: LD_VAR 0 6
106134: PPUSH
106135: LD_INT 1
106137: PPUSH
106138: CALL_OW 48
// end ;
106142: LD_VAR 0 7
106146: RET
// export hInvincible ; every 1 do
106147: GO 106149
106149: DISABLE
// hInvincible := [ ] ;
106150: LD_ADDR_EXP 166
106154: PUSH
106155: EMPTY
106156: ST_TO_ADDR
106157: END
// every 10 do var i ;
106158: GO 106160
106160: DISABLE
106161: LD_INT 0
106163: PPUSH
// begin enable ;
106164: ENABLE
// if not hInvincible then
106165: LD_EXP 166
106169: NOT
106170: IFFALSE 106174
// exit ;
106172: GO 106218
// for i in hInvincible do
106174: LD_ADDR_VAR 0 1
106178: PUSH
106179: LD_EXP 166
106183: PUSH
106184: FOR_IN
106185: IFFALSE 106216
// if GetLives ( i ) < 1000 then
106187: LD_VAR 0 1
106191: PPUSH
106192: CALL_OW 256
106196: PUSH
106197: LD_INT 1000
106199: LESS
106200: IFFALSE 106214
// SetLives ( i , 1000 ) ;
106202: LD_VAR 0 1
106206: PPUSH
106207: LD_INT 1000
106209: PPUSH
106210: CALL_OW 234
106214: GO 106184
106216: POP
106217: POP
// end ;
106218: PPOPN 1
106220: END
// export function hHackInvincible ; var i ; begin
106221: LD_INT 0
106223: PPUSH
106224: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106225: LD_ADDR_VAR 0 2
106229: PUSH
106230: LD_INT 2
106232: PUSH
106233: LD_INT 21
106235: PUSH
106236: LD_INT 1
106238: PUSH
106239: EMPTY
106240: LIST
106241: LIST
106242: PUSH
106243: LD_INT 21
106245: PUSH
106246: LD_INT 2
106248: PUSH
106249: EMPTY
106250: LIST
106251: LIST
106252: PUSH
106253: EMPTY
106254: LIST
106255: LIST
106256: LIST
106257: PPUSH
106258: CALL_OW 69
106262: PUSH
106263: FOR_IN
106264: IFFALSE 106325
// if IsSelected ( i ) then
106266: LD_VAR 0 2
106270: PPUSH
106271: CALL_OW 306
106275: IFFALSE 106323
// begin if i in hInvincible then
106277: LD_VAR 0 2
106281: PUSH
106282: LD_EXP 166
106286: IN
106287: IFFALSE 106307
// hInvincible := hInvincible diff i else
106289: LD_ADDR_EXP 166
106293: PUSH
106294: LD_EXP 166
106298: PUSH
106299: LD_VAR 0 2
106303: DIFF
106304: ST_TO_ADDR
106305: GO 106323
// hInvincible := hInvincible union i ;
106307: LD_ADDR_EXP 166
106311: PUSH
106312: LD_EXP 166
106316: PUSH
106317: LD_VAR 0 2
106321: UNION
106322: ST_TO_ADDR
// end ;
106323: GO 106263
106325: POP
106326: POP
// end ;
106327: LD_VAR 0 1
106331: RET
// export function hHackInvisible ; var i , j ; begin
106332: LD_INT 0
106334: PPUSH
106335: PPUSH
106336: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106337: LD_ADDR_VAR 0 2
106341: PUSH
106342: LD_INT 21
106344: PUSH
106345: LD_INT 1
106347: PUSH
106348: EMPTY
106349: LIST
106350: LIST
106351: PPUSH
106352: CALL_OW 69
106356: PUSH
106357: FOR_IN
106358: IFFALSE 106382
// if IsSelected ( i ) then
106360: LD_VAR 0 2
106364: PPUSH
106365: CALL_OW 306
106369: IFFALSE 106380
// ComForceInvisible ( i ) ;
106371: LD_VAR 0 2
106375: PPUSH
106376: CALL_OW 496
106380: GO 106357
106382: POP
106383: POP
// end ;
106384: LD_VAR 0 1
106388: RET
// export function hHackChangeYourSide ; begin
106389: LD_INT 0
106391: PPUSH
// if your_side = 8 then
106392: LD_OWVAR 2
106396: PUSH
106397: LD_INT 8
106399: EQUAL
106400: IFFALSE 106412
// your_side := 0 else
106402: LD_ADDR_OWVAR 2
106406: PUSH
106407: LD_INT 0
106409: ST_TO_ADDR
106410: GO 106426
// your_side := your_side + 1 ;
106412: LD_ADDR_OWVAR 2
106416: PUSH
106417: LD_OWVAR 2
106421: PUSH
106422: LD_INT 1
106424: PLUS
106425: ST_TO_ADDR
// end ;
106426: LD_VAR 0 1
106430: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106431: LD_INT 0
106433: PPUSH
106434: PPUSH
106435: PPUSH
// for i in all_units do
106436: LD_ADDR_VAR 0 2
106440: PUSH
106441: LD_OWVAR 3
106445: PUSH
106446: FOR_IN
106447: IFFALSE 106525
// if IsSelected ( i ) then
106449: LD_VAR 0 2
106453: PPUSH
106454: CALL_OW 306
106458: IFFALSE 106523
// begin j := GetSide ( i ) ;
106460: LD_ADDR_VAR 0 3
106464: PUSH
106465: LD_VAR 0 2
106469: PPUSH
106470: CALL_OW 255
106474: ST_TO_ADDR
// if j = 8 then
106475: LD_VAR 0 3
106479: PUSH
106480: LD_INT 8
106482: EQUAL
106483: IFFALSE 106495
// j := 0 else
106485: LD_ADDR_VAR 0 3
106489: PUSH
106490: LD_INT 0
106492: ST_TO_ADDR
106493: GO 106509
// j := j + 1 ;
106495: LD_ADDR_VAR 0 3
106499: PUSH
106500: LD_VAR 0 3
106504: PUSH
106505: LD_INT 1
106507: PLUS
106508: ST_TO_ADDR
// SetSide ( i , j ) ;
106509: LD_VAR 0 2
106513: PPUSH
106514: LD_VAR 0 3
106518: PPUSH
106519: CALL_OW 235
// end ;
106523: GO 106446
106525: POP
106526: POP
// end ;
106527: LD_VAR 0 1
106531: RET
// export function hHackFog ; begin
106532: LD_INT 0
106534: PPUSH
// FogOff ( true ) ;
106535: LD_INT 1
106537: PPUSH
106538: CALL_OW 344
// end ;
106542: LD_VAR 0 1
106546: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106547: LD_INT 0
106549: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106550: LD_VAR 0 1
106554: PPUSH
106555: LD_VAR 0 2
106559: PPUSH
106560: LD_VAR 0 3
106564: PPUSH
106565: LD_INT 1
106567: PPUSH
106568: LD_INT 1
106570: PPUSH
106571: CALL_OW 483
// CenterOnXY ( x , y ) ;
106575: LD_VAR 0 2
106579: PPUSH
106580: LD_VAR 0 3
106584: PPUSH
106585: CALL_OW 84
// end ;
106589: LD_VAR 0 4
106593: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106594: LD_INT 0
106596: PPUSH
106597: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106598: LD_VAR 0 1
106602: NOT
106603: IFTRUE 106622
106605: PUSH
106606: LD_VAR 0 2
106610: PPUSH
106611: LD_VAR 0 3
106615: PPUSH
106616: CALL_OW 488
106620: NOT
106621: OR
106622: IFTRUE 106657
106624: PUSH
106625: LD_VAR 0 1
106629: PPUSH
106630: CALL_OW 266
106634: PUSH
106635: LD_INT 3
106637: NONEQUAL
106638: IFFALSE 106656
106640: PUSH
106641: LD_VAR 0 1
106645: PPUSH
106646: CALL_OW 247
106650: PUSH
106651: LD_INT 1
106653: EQUAL
106654: NOT
106655: AND
106656: OR
106657: IFFALSE 106661
// exit ;
106659: GO 106943
// if GetType ( factory ) = unit_human then
106661: LD_VAR 0 1
106665: PPUSH
106666: CALL_OW 247
106670: PUSH
106671: LD_INT 1
106673: EQUAL
106674: IFFALSE 106691
// factory := IsInUnit ( factory ) ;
106676: LD_ADDR_VAR 0 1
106680: PUSH
106681: LD_VAR 0 1
106685: PPUSH
106686: CALL_OW 310
106690: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106691: LD_VAR 0 1
106695: PPUSH
106696: CALL_OW 266
106700: PUSH
106701: LD_INT 3
106703: NONEQUAL
106704: IFFALSE 106708
// exit ;
106706: GO 106943
// for i := 1 to Count ( factoryWaypoints ) do
106708: LD_ADDR_VAR 0 5
106712: PUSH
106713: DOUBLE
106714: LD_INT 1
106716: DEC
106717: ST_TO_ADDR
106718: LD_EXP 167
106722: PPUSH
106723: CALL 19622 0 1
106727: PUSH
106728: FOR_TO
106729: IFFALSE 106891
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
106731: LD_VAR 0 2
106735: PPUSH
106736: LD_VAR 0 3
106740: PPUSH
106741: CALL_OW 428
106745: PUSH
106746: LD_EXP 167
106750: PUSH
106751: LD_VAR 0 5
106755: ARRAY
106756: PUSH
106757: LD_INT 2
106759: ARRAY
106760: EQUAL
106761: IFFALSE 106793
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106763: LD_ADDR_EXP 167
106767: PUSH
106768: LD_EXP 167
106772: PPUSH
106773: LD_VAR 0 5
106777: PPUSH
106778: CALL_OW 3
106782: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106783: CALL 106948 0 0
// exit ;
106787: POP
106788: POP
106789: GO 106943
// end else
106791: GO 106889
// if factory = factoryWaypoints [ i ] [ 2 ] then
106793: LD_VAR 0 1
106797: PUSH
106798: LD_EXP 167
106802: PUSH
106803: LD_VAR 0 5
106807: ARRAY
106808: PUSH
106809: LD_INT 2
106811: ARRAY
106812: EQUAL
106813: IFFALSE 106889
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
106815: LD_ADDR_EXP 167
106819: PUSH
106820: LD_EXP 167
106824: PPUSH
106825: LD_VAR 0 5
106829: PPUSH
106830: CALL_OW 3
106834: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106835: LD_ADDR_EXP 167
106839: PUSH
106840: LD_EXP 167
106844: PPUSH
106845: LD_VAR 0 1
106849: PPUSH
106850: CALL_OW 255
106854: PUSH
106855: LD_VAR 0 1
106859: PUSH
106860: LD_VAR 0 2
106864: PUSH
106865: LD_VAR 0 3
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: LIST
106874: LIST
106875: PPUSH
106876: CALL 55554 0 2
106880: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106881: CALL 106948 0 0
// exit ;
106885: POP
106886: POP
106887: GO 106943
// end ; end ;
106889: GO 106728
106891: POP
106892: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
106893: LD_ADDR_EXP 167
106897: PUSH
106898: LD_EXP 167
106902: PPUSH
106903: LD_VAR 0 1
106907: PPUSH
106908: CALL_OW 255
106912: PUSH
106913: LD_VAR 0 1
106917: PUSH
106918: LD_VAR 0 2
106922: PUSH
106923: LD_VAR 0 3
106927: PUSH
106928: EMPTY
106929: LIST
106930: LIST
106931: LIST
106932: LIST
106933: PPUSH
106934: CALL 55554 0 2
106938: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106939: CALL 106948 0 0
// end ;
106943: LD_VAR 0 4
106947: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106948: LD_INT 0
106950: PPUSH
106951: PPUSH
106952: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106953: LD_STRING resetFactoryWaypoint();
106955: PPUSH
106956: CALL_OW 559
// if factoryWaypoints then
106960: LD_EXP 167
106964: IFFALSE 107085
// begin list := factoryWaypoints ;
106966: LD_ADDR_VAR 0 3
106970: PUSH
106971: LD_EXP 167
106975: ST_TO_ADDR
// for i := 1 to list do
106976: LD_ADDR_VAR 0 2
106980: PUSH
106981: DOUBLE
106982: LD_INT 1
106984: DEC
106985: ST_TO_ADDR
106986: LD_VAR 0 3
106990: PUSH
106991: FOR_TO
106992: IFFALSE 107083
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106994: LD_STRING setFactoryWaypointXY(
106996: PUSH
106997: LD_VAR 0 3
107001: PUSH
107002: LD_VAR 0 2
107006: ARRAY
107007: PUSH
107008: LD_INT 1
107010: ARRAY
107011: STR
107012: PUSH
107013: LD_STRING ,
107015: STR
107016: PUSH
107017: LD_VAR 0 3
107021: PUSH
107022: LD_VAR 0 2
107026: ARRAY
107027: PUSH
107028: LD_INT 2
107030: ARRAY
107031: STR
107032: PUSH
107033: LD_STRING ,
107035: STR
107036: PUSH
107037: LD_VAR 0 3
107041: PUSH
107042: LD_VAR 0 2
107046: ARRAY
107047: PUSH
107048: LD_INT 3
107050: ARRAY
107051: STR
107052: PUSH
107053: LD_STRING ,
107055: STR
107056: PUSH
107057: LD_VAR 0 3
107061: PUSH
107062: LD_VAR 0 2
107066: ARRAY
107067: PUSH
107068: LD_INT 4
107070: ARRAY
107071: STR
107072: PUSH
107073: LD_STRING )
107075: STR
107076: PPUSH
107077: CALL_OW 559
107081: GO 106991
107083: POP
107084: POP
// end ; end ;
107085: LD_VAR 0 1
107089: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
107090: LD_INT 0
107092: PPUSH
// if HexInfo ( x , y ) = warehouse then
107093: LD_VAR 0 2
107097: PPUSH
107098: LD_VAR 0 3
107102: PPUSH
107103: CALL_OW 428
107107: PUSH
107108: LD_VAR 0 1
107112: EQUAL
107113: IFFALSE 107140
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
107115: LD_ADDR_EXP 169
107119: PUSH
107120: LD_EXP 169
107124: PPUSH
107125: LD_VAR 0 1
107129: PPUSH
107130: LD_INT 0
107132: PPUSH
107133: CALL_OW 1
107137: ST_TO_ADDR
107138: GO 107191
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
107140: LD_ADDR_EXP 169
107144: PUSH
107145: LD_EXP 169
107149: PPUSH
107150: LD_VAR 0 1
107154: PPUSH
107155: LD_VAR 0 1
107159: PPUSH
107160: CALL_OW 255
107164: PUSH
107165: LD_VAR 0 1
107169: PUSH
107170: LD_VAR 0 2
107174: PUSH
107175: LD_VAR 0 3
107179: PUSH
107180: EMPTY
107181: LIST
107182: LIST
107183: LIST
107184: LIST
107185: PPUSH
107186: CALL_OW 1
107190: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
107191: CALL 107200 0 0
// end ;
107195: LD_VAR 0 4
107199: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
107200: LD_INT 0
107202: PPUSH
107203: PPUSH
107204: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
107205: LD_STRING resetWarehouseGatheringPoints();
107207: PPUSH
107208: CALL_OW 559
// if warehouseGatheringPoints then
107212: LD_EXP 169
107216: IFFALSE 107342
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
107218: LD_ADDR_VAR 0 3
107222: PUSH
107223: LD_EXP 169
107227: PPUSH
107228: CALL 59488 0 1
107232: ST_TO_ADDR
// for i := 1 to list do
107233: LD_ADDR_VAR 0 2
107237: PUSH
107238: DOUBLE
107239: LD_INT 1
107241: DEC
107242: ST_TO_ADDR
107243: LD_VAR 0 3
107247: PUSH
107248: FOR_TO
107249: IFFALSE 107340
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
107251: LD_STRING setWarehouseGatheringPointXY(
107253: PUSH
107254: LD_VAR 0 3
107258: PUSH
107259: LD_VAR 0 2
107263: ARRAY
107264: PUSH
107265: LD_INT 1
107267: ARRAY
107268: STR
107269: PUSH
107270: LD_STRING ,
107272: STR
107273: PUSH
107274: LD_VAR 0 3
107278: PUSH
107279: LD_VAR 0 2
107283: ARRAY
107284: PUSH
107285: LD_INT 2
107287: ARRAY
107288: STR
107289: PUSH
107290: LD_STRING ,
107292: STR
107293: PUSH
107294: LD_VAR 0 3
107298: PUSH
107299: LD_VAR 0 2
107303: ARRAY
107304: PUSH
107305: LD_INT 3
107307: ARRAY
107308: STR
107309: PUSH
107310: LD_STRING ,
107312: STR
107313: PUSH
107314: LD_VAR 0 3
107318: PUSH
107319: LD_VAR 0 2
107323: ARRAY
107324: PUSH
107325: LD_INT 4
107327: ARRAY
107328: STR
107329: PUSH
107330: LD_STRING )
107332: STR
107333: PPUSH
107334: CALL_OW 559
107338: GO 107248
107340: POP
107341: POP
// end ; end ;
107342: LD_VAR 0 1
107346: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107347: LD_EXP 169
107351: IFFALSE 108046
107353: GO 107355
107355: DISABLE
107356: LD_INT 0
107358: PPUSH
107359: PPUSH
107360: PPUSH
107361: PPUSH
107362: PPUSH
107363: PPUSH
107364: PPUSH
107365: PPUSH
107366: PPUSH
// begin enable ;
107367: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107368: LD_ADDR_VAR 0 3
107372: PUSH
107373: LD_EXP 169
107377: PPUSH
107378: CALL 59488 0 1
107382: ST_TO_ADDR
// if not list then
107383: LD_VAR 0 3
107387: NOT
107388: IFFALSE 107392
// exit ;
107390: GO 108046
// for i := 1 to list do
107392: LD_ADDR_VAR 0 1
107396: PUSH
107397: DOUBLE
107398: LD_INT 1
107400: DEC
107401: ST_TO_ADDR
107402: LD_VAR 0 3
107406: PUSH
107407: FOR_TO
107408: IFFALSE 108044
// begin depot := list [ i ] [ 2 ] ;
107410: LD_ADDR_VAR 0 8
107414: PUSH
107415: LD_VAR 0 3
107419: PUSH
107420: LD_VAR 0 1
107424: ARRAY
107425: PUSH
107426: LD_INT 2
107428: ARRAY
107429: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107430: LD_ADDR_VAR 0 5
107434: PUSH
107435: LD_VAR 0 3
107439: PUSH
107440: LD_VAR 0 1
107444: ARRAY
107445: PUSH
107446: LD_INT 1
107448: ARRAY
107449: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107450: LD_VAR 0 8
107454: PPUSH
107455: CALL_OW 301
107459: IFTRUE 107478
107461: PUSH
107462: LD_VAR 0 5
107466: PUSH
107467: LD_VAR 0 8
107471: PPUSH
107472: CALL_OW 255
107476: NONEQUAL
107477: OR
107478: IFFALSE 107507
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107480: LD_ADDR_EXP 169
107484: PUSH
107485: LD_EXP 169
107489: PPUSH
107490: LD_VAR 0 8
107494: PPUSH
107495: LD_INT 0
107497: PPUSH
107498: CALL_OW 1
107502: ST_TO_ADDR
// exit ;
107503: POP
107504: POP
107505: GO 108046
// end ; x := list [ i ] [ 3 ] ;
107507: LD_ADDR_VAR 0 6
107511: PUSH
107512: LD_VAR 0 3
107516: PUSH
107517: LD_VAR 0 1
107521: ARRAY
107522: PUSH
107523: LD_INT 3
107525: ARRAY
107526: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107527: LD_ADDR_VAR 0 7
107531: PUSH
107532: LD_VAR 0 3
107536: PUSH
107537: LD_VAR 0 1
107541: ARRAY
107542: PUSH
107543: LD_INT 4
107545: ARRAY
107546: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107547: LD_ADDR_VAR 0 9
107551: PUSH
107552: LD_VAR 0 6
107556: PPUSH
107557: LD_VAR 0 7
107561: PPUSH
107562: LD_INT 16
107564: PPUSH
107565: CALL 58062 0 3
107569: ST_TO_ADDR
// if not cratesNearbyPoint then
107570: LD_VAR 0 9
107574: NOT
107575: IFFALSE 107581
// exit ;
107577: POP
107578: POP
107579: GO 108046
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107581: LD_ADDR_VAR 0 4
107585: PUSH
107586: LD_INT 22
107588: PUSH
107589: LD_VAR 0 5
107593: PUSH
107594: EMPTY
107595: LIST
107596: LIST
107597: PUSH
107598: LD_INT 3
107600: PUSH
107601: LD_INT 60
107603: PUSH
107604: EMPTY
107605: LIST
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: PUSH
107611: LD_INT 91
107613: PUSH
107614: LD_VAR 0 8
107618: PUSH
107619: LD_INT 6
107621: PUSH
107622: EMPTY
107623: LIST
107624: LIST
107625: LIST
107626: PUSH
107627: LD_INT 2
107629: PUSH
107630: LD_INT 25
107632: PUSH
107633: LD_INT 2
107635: PUSH
107636: EMPTY
107637: LIST
107638: LIST
107639: PUSH
107640: LD_INT 25
107642: PUSH
107643: LD_INT 16
107645: PUSH
107646: EMPTY
107647: LIST
107648: LIST
107649: PUSH
107650: EMPTY
107651: LIST
107652: LIST
107653: LIST
107654: PUSH
107655: EMPTY
107656: LIST
107657: LIST
107658: LIST
107659: LIST
107660: PPUSH
107661: CALL_OW 69
107665: PUSH
107666: LD_VAR 0 8
107670: PPUSH
107671: CALL_OW 313
107675: PPUSH
107676: LD_INT 3
107678: PUSH
107679: LD_INT 60
107681: PUSH
107682: EMPTY
107683: LIST
107684: PUSH
107685: EMPTY
107686: LIST
107687: LIST
107688: PUSH
107689: LD_INT 2
107691: PUSH
107692: LD_INT 25
107694: PUSH
107695: LD_INT 2
107697: PUSH
107698: EMPTY
107699: LIST
107700: LIST
107701: PUSH
107702: LD_INT 25
107704: PUSH
107705: LD_INT 16
107707: PUSH
107708: EMPTY
107709: LIST
107710: LIST
107711: PUSH
107712: EMPTY
107713: LIST
107714: LIST
107715: LIST
107716: PUSH
107717: EMPTY
107718: LIST
107719: LIST
107720: PPUSH
107721: CALL_OW 72
107725: UNION
107726: ST_TO_ADDR
// if tmp then
107727: LD_VAR 0 4
107731: IFFALSE 107811
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107733: LD_ADDR_VAR 0 4
107737: PUSH
107738: LD_VAR 0 4
107742: PPUSH
107743: LD_INT 3
107745: PPUSH
107746: CALL 55869 0 2
107750: ST_TO_ADDR
// for j in tmp do
107751: LD_ADDR_VAR 0 2
107755: PUSH
107756: LD_VAR 0 4
107760: PUSH
107761: FOR_IN
107762: IFFALSE 107805
// begin if IsInUnit ( j ) then
107764: LD_VAR 0 2
107768: PPUSH
107769: CALL_OW 310
107773: IFFALSE 107784
// ComExit ( j ) ;
107775: LD_VAR 0 2
107779: PPUSH
107780: CALL 55952 0 1
// AddComCollect ( j , x , y ) ;
107784: LD_VAR 0 2
107788: PPUSH
107789: LD_VAR 0 6
107793: PPUSH
107794: LD_VAR 0 7
107798: PPUSH
107799: CALL_OW 177
// end ;
107803: GO 107761
107805: POP
107806: POP
// exit ;
107807: POP
107808: POP
107809: GO 108046
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107811: LD_ADDR_VAR 0 4
107815: PUSH
107816: LD_INT 22
107818: PUSH
107819: LD_VAR 0 5
107823: PUSH
107824: EMPTY
107825: LIST
107826: LIST
107827: PUSH
107828: LD_INT 91
107830: PUSH
107831: LD_VAR 0 8
107835: PUSH
107836: LD_INT 8
107838: PUSH
107839: EMPTY
107840: LIST
107841: LIST
107842: LIST
107843: PUSH
107844: LD_INT 2
107846: PUSH
107847: LD_INT 34
107849: PUSH
107850: LD_INT 12
107852: PUSH
107853: EMPTY
107854: LIST
107855: LIST
107856: PUSH
107857: LD_INT 34
107859: PUSH
107860: LD_INT 51
107862: PUSH
107863: EMPTY
107864: LIST
107865: LIST
107866: PUSH
107867: LD_INT 34
107869: PUSH
107870: LD_INT 32
107872: PUSH
107873: EMPTY
107874: LIST
107875: LIST
107876: PUSH
107877: LD_INT 34
107879: PUSH
107880: LD_INT 89
107882: PUSH
107883: EMPTY
107884: LIST
107885: LIST
107886: PUSH
107887: EMPTY
107888: LIST
107889: LIST
107890: LIST
107891: LIST
107892: LIST
107893: PUSH
107894: EMPTY
107895: LIST
107896: LIST
107897: LIST
107898: PPUSH
107899: CALL_OW 69
107903: ST_TO_ADDR
// if tmp then
107904: LD_VAR 0 4
107908: IFFALSE 108042
// begin for j in tmp do
107910: LD_ADDR_VAR 0 2
107914: PUSH
107915: LD_VAR 0 4
107919: PUSH
107920: FOR_IN
107921: IFFALSE 108040
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107923: LD_VAR 0 2
107927: PPUSH
107928: CALL_OW 262
107932: PUSH
107933: LD_INT 3
107935: EQUAL
107936: IFTRUE 107953
107938: PUSH
107939: LD_VAR 0 2
107943: PPUSH
107944: CALL_OW 261
107948: PUSH
107949: LD_INT 20
107951: GREATER
107952: OR
107953: IFFALSE 107967
107955: PUSH
107956: LD_VAR 0 2
107960: PPUSH
107961: CALL_OW 314
107965: NOT
107966: AND
107967: IFFALSE 107997
107969: PUSH
107970: LD_VAR 0 2
107974: PPUSH
107975: CALL_OW 263
107979: PUSH
107980: LD_INT 1
107982: NONEQUAL
107983: IFTRUE 107996
107985: PUSH
107986: LD_VAR 0 2
107990: PPUSH
107991: CALL_OW 311
107995: OR
107996: AND
107997: IFFALSE 108038
// begin ComCollect ( j , x , y ) ;
107999: LD_VAR 0 2
108003: PPUSH
108004: LD_VAR 0 6
108008: PPUSH
108009: LD_VAR 0 7
108013: PPUSH
108014: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
108018: LD_VAR 0 2
108022: PPUSH
108023: LD_VAR 0 8
108027: PPUSH
108028: CALL_OW 172
// exit ;
108032: POP
108033: POP
108034: POP
108035: POP
108036: GO 108046
// end ;
108038: GO 107920
108040: POP
108041: POP
// end ; end ;
108042: GO 107407
108044: POP
108045: POP
// end ; end_of_file
108046: PPOPN 9
108048: END
// export function SOS_UnitDestroyed ( un ) ; begin
108049: LD_INT 0
108051: PPUSH
// ComRadiation ( un ) ;
108052: LD_VAR 0 1
108056: PPUSH
108057: CALL 109138 0 1
// end ;
108061: LD_VAR 0 2
108065: RET
// export function SOS_UnitKamikazed ( un ) ; begin
108066: LD_INT 0
108068: PPUSH
// ComRadiation ( un ) ;
108069: LD_VAR 0 1
108073: PPUSH
108074: CALL 109138 0 1
// end ;
108078: LD_VAR 0 2
108082: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
108083: LD_INT 0
108085: PPUSH
// end ;
108086: LD_VAR 0 4
108090: RET
// export function SOS_Command ( cmd ) ; begin
108091: LD_INT 0
108093: PPUSH
// end ;
108094: LD_VAR 0 2
108098: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
108099: LD_INT 0
108101: PPUSH
// end ;
108102: LD_VAR 0 6
108106: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
108107: LD_INT 0
108109: PPUSH
108110: PPUSH
108111: PPUSH
108112: PPUSH
// if not vehicle or not factory then
108113: LD_VAR 0 1
108117: NOT
108118: IFTRUE 108127
108120: PUSH
108121: LD_VAR 0 2
108125: NOT
108126: OR
108127: IFFALSE 108131
// exit ;
108129: GO 108713
// if not factoryWaypoints then
108131: LD_EXP 167
108135: NOT
108136: IFFALSE 108140
// exit ;
108138: GO 108713
// for i := 1 to Count ( factoryWaypoints ) do
108140: LD_ADDR_VAR 0 4
108144: PUSH
108145: DOUBLE
108146: LD_INT 1
108148: DEC
108149: ST_TO_ADDR
108150: LD_EXP 167
108154: PPUSH
108155: CALL 19622 0 1
108159: PUSH
108160: FOR_TO
108161: IFFALSE 108711
// if factoryWaypoints [ i ] [ 2 ] = factory then
108163: LD_EXP 167
108167: PUSH
108168: LD_VAR 0 4
108172: ARRAY
108173: PUSH
108174: LD_INT 2
108176: ARRAY
108177: PUSH
108178: LD_VAR 0 2
108182: EQUAL
108183: IFFALSE 108709
// begin if GetControl ( vehicle ) = control_manual then
108185: LD_VAR 0 1
108189: PPUSH
108190: CALL_OW 263
108194: PUSH
108195: LD_INT 1
108197: EQUAL
108198: IFFALSE 108562
// begin driver := IsDrivenBy ( vehicle ) ;
108200: LD_ADDR_VAR 0 5
108204: PUSH
108205: LD_VAR 0 1
108209: PPUSH
108210: CALL_OW 311
108214: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
108215: LD_VAR 0 5
108219: PUSH
108220: LD_EXP 168
108224: IN
108225: IFTRUE 108239
108227: PUSH
108228: LD_VAR 0 1
108232: PUSH
108233: LD_EXP 168
108237: IN
108238: OR
108239: IFFALSE 108245
// exit ;
108241: POP
108242: POP
108243: GO 108713
// if not HasTask ( driver ) then
108245: LD_VAR 0 5
108249: PPUSH
108250: CALL_OW 314
108254: NOT
108255: IFFALSE 108560
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
108257: LD_ADDR_EXP 168
108261: PUSH
108262: LD_EXP 168
108266: PPUSH
108267: LD_VAR 0 5
108271: PPUSH
108272: CALL 55554 0 2
108276: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
108277: LD_ADDR_EXP 168
108281: PUSH
108282: LD_EXP 168
108286: PPUSH
108287: LD_VAR 0 1
108291: PPUSH
108292: CALL 55554 0 2
108296: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108297: LD_ADDR_VAR 0 6
108301: PUSH
108302: LD_EXP 167
108306: PUSH
108307: LD_VAR 0 4
108311: ARRAY
108312: PUSH
108313: LD_INT 3
108315: ARRAY
108316: PPUSH
108317: LD_EXP 167
108321: PUSH
108322: LD_VAR 0 4
108326: ARRAY
108327: PUSH
108328: LD_INT 4
108330: ARRAY
108331: PPUSH
108332: CALL_OW 428
108336: ST_TO_ADDR
// if hex then
108337: LD_VAR 0 6
108341: IFFALSE 108359
// ComMoveUnit ( driver , hex ) else
108343: LD_VAR 0 5
108347: PPUSH
108348: LD_VAR 0 6
108352: PPUSH
108353: CALL_OW 112
108357: GO 108443
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
108359: LD_VAR 0 1
108363: PPUSH
108364: LD_EXP 167
108368: PUSH
108369: LD_VAR 0 4
108373: ARRAY
108374: PUSH
108375: LD_INT 3
108377: ARRAY
108378: PPUSH
108379: LD_EXP 167
108383: PUSH
108384: LD_VAR 0 4
108388: ARRAY
108389: PUSH
108390: LD_INT 4
108392: ARRAY
108393: PPUSH
108394: CALL_OW 297
108398: PUSH
108399: LD_INT 0
108401: GREATER
108402: IFFALSE 108443
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108404: LD_VAR 0 5
108408: PPUSH
108409: LD_EXP 167
108413: PUSH
108414: LD_VAR 0 4
108418: ARRAY
108419: PUSH
108420: LD_INT 3
108422: ARRAY
108423: PPUSH
108424: LD_EXP 167
108428: PUSH
108429: LD_VAR 0 4
108433: ARRAY
108434: PUSH
108435: LD_INT 4
108437: ARRAY
108438: PPUSH
108439: CALL_OW 111
// AddComExitVehicle ( driver ) ;
108443: LD_VAR 0 5
108447: PPUSH
108448: CALL_OW 181
// if Multiplayer then
108452: LD_OWVAR 4
108456: IFFALSE 108505
// begin repeat wait ( 10 ) ;
108458: LD_INT 10
108460: PPUSH
108461: CALL_OW 67
// until not IsInUnit ( driver ) ;
108465: LD_VAR 0 5
108469: PPUSH
108470: CALL_OW 310
108474: NOT
108475: IFFALSE 108458
// if not HasTask ( driver ) then
108477: LD_VAR 0 5
108481: PPUSH
108482: CALL_OW 314
108486: NOT
108487: IFFALSE 108503
// ComEnterUnit ( driver , factory ) ;
108489: LD_VAR 0 5
108493: PPUSH
108494: LD_VAR 0 2
108498: PPUSH
108499: CALL_OW 120
// end else
108503: GO 108519
// AddComEnterUnit ( driver , factory ) ;
108505: LD_VAR 0 5
108509: PPUSH
108510: LD_VAR 0 2
108514: PPUSH
108515: CALL_OW 180
// wait ( 0 0$1 ) ;
108519: LD_INT 35
108521: PPUSH
108522: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
108526: LD_ADDR_EXP 168
108530: PUSH
108531: LD_EXP 168
108535: PUSH
108536: LD_VAR 0 5
108540: DIFF
108541: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
108542: LD_ADDR_EXP 168
108546: PUSH
108547: LD_EXP 168
108551: PUSH
108552: LD_VAR 0 1
108556: DIFF
108557: ST_TO_ADDR
// break ;
108558: GO 108711
// end ; end else
108560: GO 108709
// if GetControl ( vehicle ) = control_remote then
108562: LD_VAR 0 1
108566: PPUSH
108567: CALL_OW 263
108571: PUSH
108572: LD_INT 2
108574: EQUAL
108575: IFFALSE 108661
// begin wait ( 0 0$2 ) ;
108577: LD_INT 70
108579: PPUSH
108580: CALL_OW 67
// repeat wait ( 10 ) ;
108584: LD_INT 10
108586: PPUSH
108587: CALL_OW 67
// Connect ( vehicle ) ;
108591: LD_VAR 0 1
108595: PPUSH
108596: CALL 25866 0 1
// until IsControledBy ( vehicle ) ;
108600: LD_VAR 0 1
108604: PPUSH
108605: CALL_OW 312
108609: IFFALSE 108584
// wait ( 10 ) ;
108611: LD_INT 10
108613: PPUSH
108614: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108618: LD_VAR 0 1
108622: PPUSH
108623: LD_EXP 167
108627: PUSH
108628: LD_VAR 0 4
108632: ARRAY
108633: PUSH
108634: LD_INT 3
108636: ARRAY
108637: PPUSH
108638: LD_EXP 167
108642: PUSH
108643: LD_VAR 0 4
108647: ARRAY
108648: PUSH
108649: LD_INT 4
108651: ARRAY
108652: PPUSH
108653: CALL_OW 111
// break ;
108657: GO 108711
// end else
108659: GO 108709
// begin wait ( 0 0$3 ) ;
108661: LD_INT 105
108663: PPUSH
108664: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
108668: LD_VAR 0 1
108672: PPUSH
108673: LD_EXP 167
108677: PUSH
108678: LD_VAR 0 4
108682: ARRAY
108683: PUSH
108684: LD_INT 3
108686: ARRAY
108687: PPUSH
108688: LD_EXP 167
108692: PUSH
108693: LD_VAR 0 4
108697: ARRAY
108698: PUSH
108699: LD_INT 4
108701: ARRAY
108702: PPUSH
108703: CALL_OW 111
// break ;
108707: GO 108711
// end ; end ;
108709: GO 108160
108711: POP
108712: POP
// end ;
108713: LD_VAR 0 3
108717: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108718: LD_INT 0
108720: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108721: LD_VAR 0 1
108725: PUSH
108726: LD_INT 250
108728: EQUAL
108729: IFFALSE 108746
108731: PUSH
108732: LD_VAR 0 2
108736: PPUSH
108737: CALL_OW 264
108741: PUSH
108742: LD_INT 81
108744: EQUAL
108745: AND
108746: IFFALSE 108767
// MinerPlaceMine ( unit , x , y ) ;
108748: LD_VAR 0 2
108752: PPUSH
108753: LD_VAR 0 4
108757: PPUSH
108758: LD_VAR 0 5
108762: PPUSH
108763: CALL 111899 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108767: LD_VAR 0 1
108771: PUSH
108772: LD_INT 251
108774: EQUAL
108775: IFFALSE 108792
108777: PUSH
108778: LD_VAR 0 2
108782: PPUSH
108783: CALL_OW 264
108787: PUSH
108788: LD_INT 81
108790: EQUAL
108791: AND
108792: IFFALSE 108813
// MinerDetonateMine ( unit , x , y ) ;
108794: LD_VAR 0 2
108798: PPUSH
108799: LD_VAR 0 4
108803: PPUSH
108804: LD_VAR 0 5
108808: PPUSH
108809: CALL 112178 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108813: LD_VAR 0 1
108817: PUSH
108818: LD_INT 252
108820: EQUAL
108821: IFFALSE 108838
108823: PUSH
108824: LD_VAR 0 2
108828: PPUSH
108829: CALL_OW 264
108833: PUSH
108834: LD_INT 81
108836: EQUAL
108837: AND
108838: IFFALSE 108859
// MinerCreateMinefield ( unit , x , y ) ;
108840: LD_VAR 0 2
108844: PPUSH
108845: LD_VAR 0 4
108849: PPUSH
108850: LD_VAR 0 5
108854: PPUSH
108855: CALL 112597 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108859: LD_VAR 0 1
108863: PUSH
108864: LD_INT 253
108866: EQUAL
108867: IFFALSE 108884
108869: PUSH
108870: LD_VAR 0 2
108874: PPUSH
108875: CALL_OW 257
108879: PUSH
108880: LD_INT 5
108882: EQUAL
108883: AND
108884: IFFALSE 108905
// ComBinocular ( unit , x , y ) ;
108886: LD_VAR 0 2
108890: PPUSH
108891: LD_VAR 0 4
108895: PPUSH
108896: LD_VAR 0 5
108900: PPUSH
108901: CALL 112972 0 3
// if selectedUnit then
108905: LD_VAR 0 3
108909: IFFALSE 108969
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108911: LD_VAR 0 1
108915: PUSH
108916: LD_INT 254
108918: EQUAL
108919: IFFALSE 108936
108921: PUSH
108922: LD_VAR 0 2
108926: PPUSH
108927: CALL_OW 264
108931: PUSH
108932: LD_INT 99
108934: EQUAL
108935: AND
108936: IFFALSE 108953
108938: PUSH
108939: LD_VAR 0 3
108943: PPUSH
108944: CALL_OW 263
108948: PUSH
108949: LD_INT 3
108951: EQUAL
108952: AND
108953: IFFALSE 108969
// HackDestroyVehicle ( unit , selectedUnit ) ;
108955: LD_VAR 0 2
108959: PPUSH
108960: LD_VAR 0 3
108964: PPUSH
108965: CALL 111259 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108969: LD_VAR 0 1
108973: PUSH
108974: LD_INT 255
108976: EQUAL
108977: IFFALSE 109001
108979: PUSH
108980: LD_VAR 0 2
108984: PPUSH
108985: CALL_OW 264
108989: PUSH
108990: LD_INT 14
108992: PUSH
108993: LD_INT 53
108995: PUSH
108996: EMPTY
108997: LIST
108998: LIST
108999: IN
109000: AND
109001: IFFALSE 109019
109003: PUSH
109004: LD_VAR 0 4
109008: PPUSH
109009: LD_VAR 0 5
109013: PPUSH
109014: CALL_OW 488
109018: AND
109019: IFFALSE 109043
// CutTreeXYR ( unit , x , y , 12 ) ;
109021: LD_VAR 0 2
109025: PPUSH
109026: LD_VAR 0 4
109030: PPUSH
109031: LD_VAR 0 5
109035: PPUSH
109036: LD_INT 12
109038: PPUSH
109039: CALL 109234 0 4
// if cmd = 256 then
109043: LD_VAR 0 1
109047: PUSH
109048: LD_INT 256
109050: EQUAL
109051: IFFALSE 109072
// SetFactoryWaypoint ( unit , x , y ) ;
109053: LD_VAR 0 2
109057: PPUSH
109058: LD_VAR 0 4
109062: PPUSH
109063: LD_VAR 0 5
109067: PPUSH
109068: CALL 106594 0 3
// if cmd = 257 then
109072: LD_VAR 0 1
109076: PUSH
109077: LD_INT 257
109079: EQUAL
109080: IFFALSE 109101
// SetWarehouseGatheringPoint ( unit , x , y ) ;
109082: LD_VAR 0 2
109086: PPUSH
109087: LD_VAR 0 4
109091: PPUSH
109092: LD_VAR 0 5
109096: PPUSH
109097: CALL 107090 0 3
// if cmd = 258 then
109101: LD_VAR 0 1
109105: PUSH
109106: LD_INT 258
109108: EQUAL
109109: IFFALSE 109133
// BurnTreeXYR ( unit , x , y , 8 ) ;
109111: LD_VAR 0 2
109115: PPUSH
109116: LD_VAR 0 4
109120: PPUSH
109121: LD_VAR 0 5
109125: PPUSH
109126: LD_INT 8
109128: PPUSH
109129: CALL 109634 0 4
// end ;
109133: LD_VAR 0 6
109137: RET
// export function ComRadiation ( un ) ; var eff ; begin
109138: LD_INT 0
109140: PPUSH
109141: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
109142: LD_VAR 0 1
109146: PPUSH
109147: CALL_OW 264
109151: PUSH
109152: LD_INT 91
109154: NONEQUAL
109155: IFFALSE 109159
// exit ;
109157: GO 109229
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
109159: LD_INT 68
109161: PPUSH
109162: LD_VAR 0 1
109166: PPUSH
109167: CALL_OW 255
109171: PPUSH
109172: CALL_OW 321
109176: PUSH
109177: LD_INT 2
109179: EQUAL
109180: IFFALSE 109192
// eff := 50 else
109182: LD_ADDR_VAR 0 3
109186: PUSH
109187: LD_INT 50
109189: ST_TO_ADDR
109190: GO 109200
// eff := 25 ;
109192: LD_ADDR_VAR 0 3
109196: PUSH
109197: LD_INT 25
109199: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
109200: LD_VAR 0 1
109204: PPUSH
109205: CALL_OW 250
109209: PPUSH
109210: LD_VAR 0 1
109214: PPUSH
109215: CALL_OW 251
109219: PPUSH
109220: LD_VAR 0 3
109224: PPUSH
109225: CALL_OW 495
// end ;
109229: LD_VAR 0 2
109233: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
109234: LD_INT 0
109236: PPUSH
109237: PPUSH
109238: PPUSH
109239: PPUSH
109240: PPUSH
109241: PPUSH
109242: PPUSH
109243: PPUSH
109244: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
109245: LD_VAR 0 1
109249: PPUSH
109250: CALL_OW 302
109254: NOT
109255: IFTRUE 109274
109257: PUSH
109258: LD_VAR 0 2
109262: PPUSH
109263: LD_VAR 0 3
109267: PPUSH
109268: CALL_OW 488
109272: NOT
109273: OR
109274: IFTRUE 109283
109276: PUSH
109277: LD_VAR 0 4
109281: NOT
109282: OR
109283: IFFALSE 109287
// exit ;
109285: GO 109629
// list := [ ] ;
109287: LD_ADDR_VAR 0 13
109291: PUSH
109292: EMPTY
109293: ST_TO_ADDR
// if x - r < 0 then
109294: LD_VAR 0 2
109298: PUSH
109299: LD_VAR 0 4
109303: MINUS
109304: PUSH
109305: LD_INT 0
109307: LESS
109308: IFFALSE 109320
// min_x := 0 else
109310: LD_ADDR_VAR 0 7
109314: PUSH
109315: LD_INT 0
109317: ST_TO_ADDR
109318: GO 109336
// min_x := x - r ;
109320: LD_ADDR_VAR 0 7
109324: PUSH
109325: LD_VAR 0 2
109329: PUSH
109330: LD_VAR 0 4
109334: MINUS
109335: ST_TO_ADDR
// if y - r < 0 then
109336: LD_VAR 0 3
109340: PUSH
109341: LD_VAR 0 4
109345: MINUS
109346: PUSH
109347: LD_INT 0
109349: LESS
109350: IFFALSE 109362
// min_y := 0 else
109352: LD_ADDR_VAR 0 8
109356: PUSH
109357: LD_INT 0
109359: ST_TO_ADDR
109360: GO 109378
// min_y := y - r ;
109362: LD_ADDR_VAR 0 8
109366: PUSH
109367: LD_VAR 0 3
109371: PUSH
109372: LD_VAR 0 4
109376: MINUS
109377: ST_TO_ADDR
// max_x := x + r ;
109378: LD_ADDR_VAR 0 9
109382: PUSH
109383: LD_VAR 0 2
109387: PUSH
109388: LD_VAR 0 4
109392: PLUS
109393: ST_TO_ADDR
// max_y := y + r ;
109394: LD_ADDR_VAR 0 10
109398: PUSH
109399: LD_VAR 0 3
109403: PUSH
109404: LD_VAR 0 4
109408: PLUS
109409: ST_TO_ADDR
// for _x = min_x to max_x do
109410: LD_ADDR_VAR 0 11
109414: PUSH
109415: DOUBLE
109416: LD_VAR 0 7
109420: DEC
109421: ST_TO_ADDR
109422: LD_VAR 0 9
109426: PUSH
109427: FOR_TO
109428: IFFALSE 109547
// for _y = min_y to max_y do
109430: LD_ADDR_VAR 0 12
109434: PUSH
109435: DOUBLE
109436: LD_VAR 0 8
109440: DEC
109441: ST_TO_ADDR
109442: LD_VAR 0 10
109446: PUSH
109447: FOR_TO
109448: IFFALSE 109543
// begin if not ValidHex ( _x , _y ) then
109450: LD_VAR 0 11
109454: PPUSH
109455: LD_VAR 0 12
109459: PPUSH
109460: CALL_OW 488
109464: NOT
109465: IFFALSE 109469
// continue ;
109467: GO 109447
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109469: LD_VAR 0 11
109473: PPUSH
109474: LD_VAR 0 12
109478: PPUSH
109479: CALL_OW 351
109483: IFFALSE 109501
109485: PUSH
109486: LD_VAR 0 11
109490: PPUSH
109491: LD_VAR 0 12
109495: PPUSH
109496: CALL_OW 554
109500: AND
109501: IFFALSE 109541
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109503: LD_ADDR_VAR 0 13
109507: PUSH
109508: LD_VAR 0 13
109512: PPUSH
109513: LD_VAR 0 13
109517: PUSH
109518: LD_INT 1
109520: PLUS
109521: PPUSH
109522: LD_VAR 0 11
109526: PUSH
109527: LD_VAR 0 12
109531: PUSH
109532: EMPTY
109533: LIST
109534: LIST
109535: PPUSH
109536: CALL_OW 2
109540: ST_TO_ADDR
// end ;
109541: GO 109447
109543: POP
109544: POP
109545: GO 109427
109547: POP
109548: POP
// if not list then
109549: LD_VAR 0 13
109553: NOT
109554: IFFALSE 109558
// exit ;
109556: GO 109629
// for i in list do
109558: LD_ADDR_VAR 0 6
109562: PUSH
109563: LD_VAR 0 13
109567: PUSH
109568: FOR_IN
109569: IFFALSE 109627
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
109571: LD_VAR 0 1
109575: PPUSH
109576: LD_STRING M
109578: PUSH
109579: LD_VAR 0 6
109583: PUSH
109584: LD_INT 1
109586: ARRAY
109587: PUSH
109588: LD_VAR 0 6
109592: PUSH
109593: LD_INT 2
109595: ARRAY
109596: PUSH
109597: LD_INT 0
109599: PUSH
109600: LD_INT 0
109602: PUSH
109603: LD_INT 0
109605: PUSH
109606: LD_INT 0
109608: PUSH
109609: EMPTY
109610: LIST
109611: LIST
109612: LIST
109613: LIST
109614: LIST
109615: LIST
109616: LIST
109617: PUSH
109618: EMPTY
109619: LIST
109620: PPUSH
109621: CALL_OW 447
109625: GO 109568
109627: POP
109628: POP
// end ;
109629: LD_VAR 0 5
109633: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
109634: LD_INT 0
109636: PPUSH
109637: PPUSH
109638: PPUSH
109639: PPUSH
109640: PPUSH
109641: PPUSH
109642: PPUSH
109643: PPUSH
109644: PPUSH
109645: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
109646: LD_VAR 0 1
109650: PPUSH
109651: CALL_OW 302
109655: NOT
109656: IFTRUE 109675
109658: PUSH
109659: LD_VAR 0 2
109663: PPUSH
109664: LD_VAR 0 3
109668: PPUSH
109669: CALL_OW 488
109673: NOT
109674: OR
109675: IFTRUE 109684
109677: PUSH
109678: LD_VAR 0 4
109682: NOT
109683: OR
109684: IFFALSE 109688
// exit ;
109686: GO 110205
// list := [ ] ;
109688: LD_ADDR_VAR 0 13
109692: PUSH
109693: EMPTY
109694: ST_TO_ADDR
// if x - r < 0 then
109695: LD_VAR 0 2
109699: PUSH
109700: LD_VAR 0 4
109704: MINUS
109705: PUSH
109706: LD_INT 0
109708: LESS
109709: IFFALSE 109721
// min_x := 0 else
109711: LD_ADDR_VAR 0 7
109715: PUSH
109716: LD_INT 0
109718: ST_TO_ADDR
109719: GO 109737
// min_x := x - r ;
109721: LD_ADDR_VAR 0 7
109725: PUSH
109726: LD_VAR 0 2
109730: PUSH
109731: LD_VAR 0 4
109735: MINUS
109736: ST_TO_ADDR
// if y - r < 0 then
109737: LD_VAR 0 3
109741: PUSH
109742: LD_VAR 0 4
109746: MINUS
109747: PUSH
109748: LD_INT 0
109750: LESS
109751: IFFALSE 109763
// min_y := 0 else
109753: LD_ADDR_VAR 0 8
109757: PUSH
109758: LD_INT 0
109760: ST_TO_ADDR
109761: GO 109779
// min_y := y - r ;
109763: LD_ADDR_VAR 0 8
109767: PUSH
109768: LD_VAR 0 3
109772: PUSH
109773: LD_VAR 0 4
109777: MINUS
109778: ST_TO_ADDR
// max_x := x + r ;
109779: LD_ADDR_VAR 0 9
109783: PUSH
109784: LD_VAR 0 2
109788: PUSH
109789: LD_VAR 0 4
109793: PLUS
109794: ST_TO_ADDR
// max_y := y + r ;
109795: LD_ADDR_VAR 0 10
109799: PUSH
109800: LD_VAR 0 3
109804: PUSH
109805: LD_VAR 0 4
109809: PLUS
109810: ST_TO_ADDR
// for _x = min_x to max_x do
109811: LD_ADDR_VAR 0 11
109815: PUSH
109816: DOUBLE
109817: LD_VAR 0 7
109821: DEC
109822: ST_TO_ADDR
109823: LD_VAR 0 9
109827: PUSH
109828: FOR_TO
109829: IFFALSE 109948
// for _y = min_y to max_y do
109831: LD_ADDR_VAR 0 12
109835: PUSH
109836: DOUBLE
109837: LD_VAR 0 8
109841: DEC
109842: ST_TO_ADDR
109843: LD_VAR 0 10
109847: PUSH
109848: FOR_TO
109849: IFFALSE 109944
// begin if not ValidHex ( _x , _y ) then
109851: LD_VAR 0 11
109855: PPUSH
109856: LD_VAR 0 12
109860: PPUSH
109861: CALL_OW 488
109865: NOT
109866: IFFALSE 109870
// continue ;
109868: GO 109848
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109870: LD_VAR 0 11
109874: PPUSH
109875: LD_VAR 0 12
109879: PPUSH
109880: CALL_OW 351
109884: IFFALSE 109902
109886: PUSH
109887: LD_VAR 0 11
109891: PPUSH
109892: LD_VAR 0 12
109896: PPUSH
109897: CALL_OW 554
109901: AND
109902: IFFALSE 109942
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109904: LD_ADDR_VAR 0 13
109908: PUSH
109909: LD_VAR 0 13
109913: PPUSH
109914: LD_VAR 0 13
109918: PUSH
109919: LD_INT 1
109921: PLUS
109922: PPUSH
109923: LD_VAR 0 11
109927: PUSH
109928: LD_VAR 0 12
109932: PUSH
109933: EMPTY
109934: LIST
109935: LIST
109936: PPUSH
109937: CALL_OW 2
109941: ST_TO_ADDR
// end ;
109942: GO 109848
109944: POP
109945: POP
109946: GO 109828
109948: POP
109949: POP
// if not list then
109950: LD_VAR 0 13
109954: NOT
109955: IFFALSE 109959
// exit ;
109957: GO 110205
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109959: LD_ADDR_VAR 0 13
109963: PUSH
109964: LD_VAR 0 1
109968: PPUSH
109969: LD_VAR 0 13
109973: PPUSH
109974: LD_INT 1
109976: PPUSH
109977: LD_INT 1
109979: PPUSH
109980: CALL 22994 0 4
109984: ST_TO_ADDR
// ComStop ( flame ) ;
109985: LD_VAR 0 1
109989: PPUSH
109990: CALL_OW 141
// for i in list do
109994: LD_ADDR_VAR 0 6
109998: PUSH
109999: LD_VAR 0 13
110003: PUSH
110004: FOR_IN
110005: IFFALSE 110036
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
110007: LD_VAR 0 1
110011: PPUSH
110012: LD_VAR 0 6
110016: PUSH
110017: LD_INT 1
110019: ARRAY
110020: PPUSH
110021: LD_VAR 0 6
110025: PUSH
110026: LD_INT 2
110028: ARRAY
110029: PPUSH
110030: CALL_OW 176
110034: GO 110004
110036: POP
110037: POP
// repeat wait ( 0 0$1 ) ;
110038: LD_INT 35
110040: PPUSH
110041: CALL_OW 67
// task := GetTaskList ( flame ) ;
110045: LD_ADDR_VAR 0 14
110049: PUSH
110050: LD_VAR 0 1
110054: PPUSH
110055: CALL_OW 437
110059: ST_TO_ADDR
// if not task then
110060: LD_VAR 0 14
110064: NOT
110065: IFFALSE 110069
// exit ;
110067: GO 110205
// if task [ 1 ] [ 1 ] <> | then
110069: LD_VAR 0 14
110073: PUSH
110074: LD_INT 1
110076: ARRAY
110077: PUSH
110078: LD_INT 1
110080: ARRAY
110081: PUSH
110082: LD_STRING |
110084: NONEQUAL
110085: IFFALSE 110089
// exit ;
110087: GO 110205
// _x := task [ 1 ] [ 2 ] ;
110089: LD_ADDR_VAR 0 11
110093: PUSH
110094: LD_VAR 0 14
110098: PUSH
110099: LD_INT 1
110101: ARRAY
110102: PUSH
110103: LD_INT 2
110105: ARRAY
110106: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
110107: LD_ADDR_VAR 0 12
110111: PUSH
110112: LD_VAR 0 14
110116: PUSH
110117: LD_INT 1
110119: ARRAY
110120: PUSH
110121: LD_INT 3
110123: ARRAY
110124: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
110125: LD_VAR 0 11
110129: PPUSH
110130: LD_VAR 0 12
110134: PPUSH
110135: CALL_OW 351
110139: NOT
110140: IFTRUE 110159
110142: PUSH
110143: LD_VAR 0 11
110147: PPUSH
110148: LD_VAR 0 12
110152: PPUSH
110153: CALL_OW 554
110157: NOT
110158: OR
110159: IFFALSE 110193
// begin task := Delete ( task , 1 ) ;
110161: LD_ADDR_VAR 0 14
110165: PUSH
110166: LD_VAR 0 14
110170: PPUSH
110171: LD_INT 1
110173: PPUSH
110174: CALL_OW 3
110178: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
110179: LD_VAR 0 1
110183: PPUSH
110184: LD_VAR 0 14
110188: PPUSH
110189: CALL_OW 446
// end ; until not HasTask ( flame ) ;
110193: LD_VAR 0 1
110197: PPUSH
110198: CALL_OW 314
110202: NOT
110203: IFFALSE 110038
// end ;
110205: LD_VAR 0 5
110209: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
110210: LD_EXP 171
110214: NOT
110215: IFFALSE 110265
110217: GO 110219
110219: DISABLE
// begin initHack := true ;
110220: LD_ADDR_EXP 171
110224: PUSH
110225: LD_INT 1
110227: ST_TO_ADDR
// hackTanks := [ ] ;
110228: LD_ADDR_EXP 172
110232: PUSH
110233: EMPTY
110234: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
110235: LD_ADDR_EXP 173
110239: PUSH
110240: EMPTY
110241: ST_TO_ADDR
// hackLimit := 3 ;
110242: LD_ADDR_EXP 174
110246: PUSH
110247: LD_INT 3
110249: ST_TO_ADDR
// hackDist := 12 ;
110250: LD_ADDR_EXP 175
110254: PUSH
110255: LD_INT 12
110257: ST_TO_ADDR
// hackCounter := [ ] ;
110258: LD_ADDR_EXP 176
110262: PUSH
110263: EMPTY
110264: ST_TO_ADDR
// end ;
110265: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
110266: LD_EXP 171
110270: IFFALSE 110288
110272: PUSH
110273: LD_INT 34
110275: PUSH
110276: LD_INT 99
110278: PUSH
110279: EMPTY
110280: LIST
110281: LIST
110282: PPUSH
110283: CALL_OW 69
110287: AND
110288: IFFALSE 110541
110290: GO 110292
110292: DISABLE
110293: LD_INT 0
110295: PPUSH
110296: PPUSH
// begin enable ;
110297: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
110298: LD_ADDR_VAR 0 1
110302: PUSH
110303: LD_INT 34
110305: PUSH
110306: LD_INT 99
110308: PUSH
110309: EMPTY
110310: LIST
110311: LIST
110312: PPUSH
110313: CALL_OW 69
110317: PUSH
110318: FOR_IN
110319: IFFALSE 110539
// begin if not i in hackTanks then
110321: LD_VAR 0 1
110325: PUSH
110326: LD_EXP 172
110330: IN
110331: NOT
110332: IFFALSE 110415
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
110334: LD_ADDR_EXP 172
110338: PUSH
110339: LD_EXP 172
110343: PPUSH
110344: LD_EXP 172
110348: PUSH
110349: LD_INT 1
110351: PLUS
110352: PPUSH
110353: LD_VAR 0 1
110357: PPUSH
110358: CALL_OW 1
110362: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
110363: LD_ADDR_EXP 173
110367: PUSH
110368: LD_EXP 173
110372: PPUSH
110373: LD_EXP 173
110377: PUSH
110378: LD_INT 1
110380: PLUS
110381: PPUSH
110382: EMPTY
110383: PPUSH
110384: CALL_OW 1
110388: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
110389: LD_ADDR_EXP 176
110393: PUSH
110394: LD_EXP 176
110398: PPUSH
110399: LD_EXP 176
110403: PUSH
110404: LD_INT 1
110406: PLUS
110407: PPUSH
110408: EMPTY
110409: PPUSH
110410: CALL_OW 1
110414: ST_TO_ADDR
// end ; if not IsOk ( i ) then
110415: LD_VAR 0 1
110419: PPUSH
110420: CALL_OW 302
110424: NOT
110425: IFFALSE 110438
// begin HackUnlinkAll ( i ) ;
110427: LD_VAR 0 1
110431: PPUSH
110432: CALL 110544 0 1
// continue ;
110436: GO 110318
// end ; HackCheckCapturedStatus ( i ) ;
110438: LD_VAR 0 1
110442: PPUSH
110443: CALL 110989 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
110447: LD_ADDR_VAR 0 2
110451: PUSH
110452: LD_INT 81
110454: PUSH
110455: LD_VAR 0 1
110459: PPUSH
110460: CALL_OW 255
110464: PUSH
110465: EMPTY
110466: LIST
110467: LIST
110468: PUSH
110469: LD_INT 33
110471: PUSH
110472: LD_INT 3
110474: PUSH
110475: EMPTY
110476: LIST
110477: LIST
110478: PUSH
110479: LD_INT 91
110481: PUSH
110482: LD_VAR 0 1
110486: PUSH
110487: LD_EXP 175
110491: PUSH
110492: EMPTY
110493: LIST
110494: LIST
110495: LIST
110496: PUSH
110497: LD_INT 50
110499: PUSH
110500: EMPTY
110501: LIST
110502: PUSH
110503: EMPTY
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: PPUSH
110509: CALL_OW 69
110513: ST_TO_ADDR
// if not tmp then
110514: LD_VAR 0 2
110518: NOT
110519: IFFALSE 110523
// continue ;
110521: GO 110318
// HackLink ( i , tmp ) ;
110523: LD_VAR 0 1
110527: PPUSH
110528: LD_VAR 0 2
110532: PPUSH
110533: CALL 110680 0 2
// end ;
110537: GO 110318
110539: POP
110540: POP
// end ;
110541: PPOPN 2
110543: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
110544: LD_INT 0
110546: PPUSH
110547: PPUSH
110548: PPUSH
// if not hack in hackTanks then
110549: LD_VAR 0 1
110553: PUSH
110554: LD_EXP 172
110558: IN
110559: NOT
110560: IFFALSE 110564
// exit ;
110562: GO 110675
// index := GetElementIndex ( hackTanks , hack ) ;
110564: LD_ADDR_VAR 0 4
110568: PUSH
110569: LD_EXP 172
110573: PPUSH
110574: LD_VAR 0 1
110578: PPUSH
110579: CALL 22289 0 2
110583: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
110584: LD_EXP 173
110588: PUSH
110589: LD_VAR 0 4
110593: ARRAY
110594: IFFALSE 110675
// begin for i in hackTanksCaptured [ index ] do
110596: LD_ADDR_VAR 0 3
110600: PUSH
110601: LD_EXP 173
110605: PUSH
110606: LD_VAR 0 4
110610: ARRAY
110611: PUSH
110612: FOR_IN
110613: IFFALSE 110639
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
110615: LD_VAR 0 3
110619: PUSH
110620: LD_INT 1
110622: ARRAY
110623: PPUSH
110624: LD_VAR 0 3
110628: PUSH
110629: LD_INT 2
110631: ARRAY
110632: PPUSH
110633: CALL_OW 235
110637: GO 110612
110639: POP
110640: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
110641: LD_ADDR_EXP 173
110645: PUSH
110646: LD_EXP 173
110650: PPUSH
110651: LD_VAR 0 4
110655: PPUSH
110656: EMPTY
110657: PPUSH
110658: CALL_OW 1
110662: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
110663: LD_VAR 0 1
110667: PPUSH
110668: LD_INT 0
110670: PPUSH
110671: CALL_OW 505
// end ; end ;
110675: LD_VAR 0 2
110679: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
110680: LD_INT 0
110682: PPUSH
110683: PPUSH
110684: PPUSH
// if not hack in hackTanks or not vehicles then
110685: LD_VAR 0 1
110689: PUSH
110690: LD_EXP 172
110694: IN
110695: NOT
110696: IFTRUE 110705
110698: PUSH
110699: LD_VAR 0 2
110703: NOT
110704: OR
110705: IFFALSE 110709
// exit ;
110707: GO 110984
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110709: LD_ADDR_VAR 0 2
110713: PUSH
110714: LD_VAR 0 1
110718: PPUSH
110719: LD_VAR 0 2
110723: PPUSH
110724: LD_INT 1
110726: PPUSH
110727: LD_INT 1
110729: PPUSH
110730: CALL 22941 0 4
110734: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110735: LD_ADDR_VAR 0 5
110739: PUSH
110740: LD_EXP 172
110744: PPUSH
110745: LD_VAR 0 1
110749: PPUSH
110750: CALL 22289 0 2
110754: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110755: LD_EXP 173
110759: PUSH
110760: LD_VAR 0 5
110764: ARRAY
110765: PUSH
110766: LD_EXP 174
110770: LESS
110771: IFFALSE 110960
// begin for i := 1 to vehicles do
110773: LD_ADDR_VAR 0 4
110777: PUSH
110778: DOUBLE
110779: LD_INT 1
110781: DEC
110782: ST_TO_ADDR
110783: LD_VAR 0 2
110787: PUSH
110788: FOR_TO
110789: IFFALSE 110958
// begin if hackTanksCaptured [ index ] = hackLimit then
110791: LD_EXP 173
110795: PUSH
110796: LD_VAR 0 5
110800: ARRAY
110801: PUSH
110802: LD_EXP 174
110806: EQUAL
110807: IFFALSE 110811
// break ;
110809: GO 110958
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110811: LD_ADDR_EXP 176
110815: PUSH
110816: LD_EXP 176
110820: PPUSH
110821: LD_VAR 0 5
110825: PPUSH
110826: LD_EXP 176
110830: PUSH
110831: LD_VAR 0 5
110835: ARRAY
110836: PUSH
110837: LD_INT 1
110839: PLUS
110840: PPUSH
110841: CALL_OW 1
110845: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110846: LD_ADDR_EXP 173
110850: PUSH
110851: LD_EXP 173
110855: PPUSH
110856: LD_VAR 0 5
110860: PUSH
110861: LD_EXP 173
110865: PUSH
110866: LD_VAR 0 5
110870: ARRAY
110871: PUSH
110872: LD_INT 1
110874: PLUS
110875: PUSH
110876: EMPTY
110877: LIST
110878: LIST
110879: PPUSH
110880: LD_VAR 0 2
110884: PUSH
110885: LD_VAR 0 4
110889: ARRAY
110890: PUSH
110891: LD_VAR 0 2
110895: PUSH
110896: LD_VAR 0 4
110900: ARRAY
110901: PPUSH
110902: CALL_OW 255
110906: PUSH
110907: EMPTY
110908: LIST
110909: LIST
110910: PPUSH
110911: CALL 22506 0 3
110915: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110916: LD_VAR 0 2
110920: PUSH
110921: LD_VAR 0 4
110925: ARRAY
110926: PPUSH
110927: LD_VAR 0 1
110931: PPUSH
110932: CALL_OW 255
110936: PPUSH
110937: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110941: LD_VAR 0 2
110945: PUSH
110946: LD_VAR 0 4
110950: ARRAY
110951: PPUSH
110952: CALL_OW 141
// end ;
110956: GO 110788
110958: POP
110959: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110960: LD_VAR 0 1
110964: PPUSH
110965: LD_EXP 173
110969: PUSH
110970: LD_VAR 0 5
110974: ARRAY
110975: PUSH
110976: LD_INT 0
110978: PLUS
110979: PPUSH
110980: CALL_OW 505
// end ;
110984: LD_VAR 0 3
110988: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110989: LD_INT 0
110991: PPUSH
110992: PPUSH
110993: PPUSH
110994: PPUSH
// if not hack in hackTanks then
110995: LD_VAR 0 1
110999: PUSH
111000: LD_EXP 172
111004: IN
111005: NOT
111006: IFFALSE 111010
// exit ;
111008: GO 111254
// index := GetElementIndex ( hackTanks , hack ) ;
111010: LD_ADDR_VAR 0 4
111014: PUSH
111015: LD_EXP 172
111019: PPUSH
111020: LD_VAR 0 1
111024: PPUSH
111025: CALL 22289 0 2
111029: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
111030: LD_ADDR_VAR 0 3
111034: PUSH
111035: DOUBLE
111036: LD_EXP 173
111040: PUSH
111041: LD_VAR 0 4
111045: ARRAY
111046: INC
111047: ST_TO_ADDR
111048: LD_INT 1
111050: PUSH
111051: FOR_DOWNTO
111052: IFFALSE 111228
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
111054: LD_ADDR_VAR 0 5
111058: PUSH
111059: LD_EXP 173
111063: PUSH
111064: LD_VAR 0 4
111068: ARRAY
111069: PUSH
111070: LD_VAR 0 3
111074: ARRAY
111075: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
111076: LD_VAR 0 5
111080: PUSH
111081: LD_INT 1
111083: ARRAY
111084: PPUSH
111085: CALL_OW 302
111089: NOT
111090: IFTRUE 111118
111092: PUSH
111093: LD_VAR 0 5
111097: PUSH
111098: LD_INT 1
111100: ARRAY
111101: PPUSH
111102: CALL_OW 255
111106: PUSH
111107: LD_VAR 0 1
111111: PPUSH
111112: CALL_OW 255
111116: NONEQUAL
111117: OR
111118: IFFALSE 111226
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
111120: LD_VAR 0 5
111124: PUSH
111125: LD_INT 1
111127: ARRAY
111128: PPUSH
111129: CALL_OW 305
111133: IFFALSE 111161
111135: PUSH
111136: LD_VAR 0 5
111140: PUSH
111141: LD_INT 1
111143: ARRAY
111144: PPUSH
111145: CALL_OW 255
111149: PUSH
111150: LD_VAR 0 1
111154: PPUSH
111155: CALL_OW 255
111159: EQUAL
111160: AND
111161: IFFALSE 111185
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
111163: LD_VAR 0 5
111167: PUSH
111168: LD_INT 1
111170: ARRAY
111171: PPUSH
111172: LD_VAR 0 5
111176: PUSH
111177: LD_INT 2
111179: ARRAY
111180: PPUSH
111181: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
111185: LD_ADDR_EXP 173
111189: PUSH
111190: LD_EXP 173
111194: PPUSH
111195: LD_VAR 0 4
111199: PPUSH
111200: LD_EXP 173
111204: PUSH
111205: LD_VAR 0 4
111209: ARRAY
111210: PPUSH
111211: LD_VAR 0 3
111215: PPUSH
111216: CALL_OW 3
111220: PPUSH
111221: CALL_OW 1
111225: ST_TO_ADDR
// end ; end ;
111226: GO 111051
111228: POP
111229: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
111230: LD_VAR 0 1
111234: PPUSH
111235: LD_EXP 173
111239: PUSH
111240: LD_VAR 0 4
111244: ARRAY
111245: PUSH
111246: LD_INT 0
111248: PLUS
111249: PPUSH
111250: CALL_OW 505
// end ;
111254: LD_VAR 0 2
111258: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
111259: LD_INT 0
111261: PPUSH
111262: PPUSH
111263: PPUSH
111264: PPUSH
// if not hack in hackTanks then
111265: LD_VAR 0 1
111269: PUSH
111270: LD_EXP 172
111274: IN
111275: NOT
111276: IFFALSE 111280
// exit ;
111278: GO 111365
// index := GetElementIndex ( hackTanks , hack ) ;
111280: LD_ADDR_VAR 0 5
111284: PUSH
111285: LD_EXP 172
111289: PPUSH
111290: LD_VAR 0 1
111294: PPUSH
111295: CALL 22289 0 2
111299: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
111300: LD_ADDR_VAR 0 4
111304: PUSH
111305: DOUBLE
111306: LD_INT 1
111308: DEC
111309: ST_TO_ADDR
111310: LD_EXP 173
111314: PUSH
111315: LD_VAR 0 5
111319: ARRAY
111320: PUSH
111321: FOR_TO
111322: IFFALSE 111363
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
111324: LD_EXP 173
111328: PUSH
111329: LD_VAR 0 5
111333: ARRAY
111334: PUSH
111335: LD_VAR 0 4
111339: ARRAY
111340: PUSH
111341: LD_INT 1
111343: ARRAY
111344: PUSH
111345: LD_VAR 0 2
111349: EQUAL
111350: IFFALSE 111361
// KillUnit ( vehicle ) ;
111352: LD_VAR 0 2
111356: PPUSH
111357: CALL_OW 66
111361: GO 111321
111363: POP
111364: POP
// end ;
111365: LD_VAR 0 3
111369: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
111370: LD_EXP 177
111374: NOT
111375: IFFALSE 111410
111377: GO 111379
111379: DISABLE
// begin initMiner := true ;
111380: LD_ADDR_EXP 177
111384: PUSH
111385: LD_INT 1
111387: ST_TO_ADDR
// minersList := [ ] ;
111388: LD_ADDR_EXP 178
111392: PUSH
111393: EMPTY
111394: ST_TO_ADDR
// minerMinesList := [ ] ;
111395: LD_ADDR_EXP 179
111399: PUSH
111400: EMPTY
111401: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
111402: LD_ADDR_EXP 180
111406: PUSH
111407: LD_INT 5
111409: ST_TO_ADDR
// end ;
111410: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
111411: LD_EXP 177
111415: IFFALSE 111433
111417: PUSH
111418: LD_INT 34
111420: PUSH
111421: LD_INT 81
111423: PUSH
111424: EMPTY
111425: LIST
111426: LIST
111427: PPUSH
111428: CALL_OW 69
111432: AND
111433: IFFALSE 111896
111435: GO 111437
111437: DISABLE
111438: LD_INT 0
111440: PPUSH
111441: PPUSH
111442: PPUSH
111443: PPUSH
// begin enable ;
111444: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
111445: LD_ADDR_VAR 0 1
111449: PUSH
111450: LD_INT 34
111452: PUSH
111453: LD_INT 81
111455: PUSH
111456: EMPTY
111457: LIST
111458: LIST
111459: PPUSH
111460: CALL_OW 69
111464: PUSH
111465: FOR_IN
111466: IFFALSE 111538
// begin if not i in minersList then
111468: LD_VAR 0 1
111472: PUSH
111473: LD_EXP 178
111477: IN
111478: NOT
111479: IFFALSE 111536
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
111481: LD_ADDR_EXP 178
111485: PUSH
111486: LD_EXP 178
111490: PPUSH
111491: LD_EXP 178
111495: PUSH
111496: LD_INT 1
111498: PLUS
111499: PPUSH
111500: LD_VAR 0 1
111504: PPUSH
111505: CALL_OW 1
111509: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
111510: LD_ADDR_EXP 179
111514: PUSH
111515: LD_EXP 179
111519: PPUSH
111520: LD_EXP 179
111524: PUSH
111525: LD_INT 1
111527: PLUS
111528: PPUSH
111529: EMPTY
111530: PPUSH
111531: CALL_OW 1
111535: ST_TO_ADDR
// end end ;
111536: GO 111465
111538: POP
111539: POP
// for i := minerMinesList downto 1 do
111540: LD_ADDR_VAR 0 1
111544: PUSH
111545: DOUBLE
111546: LD_EXP 179
111550: INC
111551: ST_TO_ADDR
111552: LD_INT 1
111554: PUSH
111555: FOR_DOWNTO
111556: IFFALSE 111894
// begin if IsLive ( minersList [ i ] ) then
111558: LD_EXP 178
111562: PUSH
111563: LD_VAR 0 1
111567: ARRAY
111568: PPUSH
111569: CALL_OW 300
111573: IFFALSE 111601
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
111575: LD_EXP 178
111579: PUSH
111580: LD_VAR 0 1
111584: ARRAY
111585: PPUSH
111586: LD_EXP 179
111590: PUSH
111591: LD_VAR 0 1
111595: ARRAY
111596: PPUSH
111597: CALL_OW 505
// if not minerMinesList [ i ] then
111601: LD_EXP 179
111605: PUSH
111606: LD_VAR 0 1
111610: ARRAY
111611: NOT
111612: IFFALSE 111616
// continue ;
111614: GO 111555
// for j := minerMinesList [ i ] downto 1 do
111616: LD_ADDR_VAR 0 2
111620: PUSH
111621: DOUBLE
111622: LD_EXP 179
111626: PUSH
111627: LD_VAR 0 1
111631: ARRAY
111632: INC
111633: ST_TO_ADDR
111634: LD_INT 1
111636: PUSH
111637: FOR_DOWNTO
111638: IFFALSE 111890
// begin side := GetSide ( minersList [ i ] ) ;
111640: LD_ADDR_VAR 0 3
111644: PUSH
111645: LD_EXP 178
111649: PUSH
111650: LD_VAR 0 1
111654: ARRAY
111655: PPUSH
111656: CALL_OW 255
111660: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
111661: LD_ADDR_VAR 0 4
111665: PUSH
111666: LD_EXP 179
111670: PUSH
111671: LD_VAR 0 1
111675: ARRAY
111676: PUSH
111677: LD_VAR 0 2
111681: ARRAY
111682: PUSH
111683: LD_INT 1
111685: ARRAY
111686: PPUSH
111687: LD_EXP 179
111691: PUSH
111692: LD_VAR 0 1
111696: ARRAY
111697: PUSH
111698: LD_VAR 0 2
111702: ARRAY
111703: PUSH
111704: LD_INT 2
111706: ARRAY
111707: PPUSH
111708: CALL_OW 428
111712: ST_TO_ADDR
// if not tmp then
111713: LD_VAR 0 4
111717: NOT
111718: IFFALSE 111722
// continue ;
111720: GO 111637
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111722: LD_VAR 0 4
111726: PUSH
111727: LD_INT 81
111729: PUSH
111730: LD_VAR 0 3
111734: PUSH
111735: EMPTY
111736: LIST
111737: LIST
111738: PPUSH
111739: CALL_OW 69
111743: IN
111744: IFFALSE 111794
111746: PUSH
111747: LD_EXP 179
111751: PUSH
111752: LD_VAR 0 1
111756: ARRAY
111757: PUSH
111758: LD_VAR 0 2
111762: ARRAY
111763: PUSH
111764: LD_INT 1
111766: ARRAY
111767: PPUSH
111768: LD_EXP 179
111772: PUSH
111773: LD_VAR 0 1
111777: ARRAY
111778: PUSH
111779: LD_VAR 0 2
111783: ARRAY
111784: PUSH
111785: LD_INT 2
111787: ARRAY
111788: PPUSH
111789: CALL_OW 458
111793: AND
111794: IFFALSE 111888
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111796: LD_EXP 179
111800: PUSH
111801: LD_VAR 0 1
111805: ARRAY
111806: PUSH
111807: LD_VAR 0 2
111811: ARRAY
111812: PUSH
111813: LD_INT 1
111815: ARRAY
111816: PPUSH
111817: LD_EXP 179
111821: PUSH
111822: LD_VAR 0 1
111826: ARRAY
111827: PUSH
111828: LD_VAR 0 2
111832: ARRAY
111833: PUSH
111834: LD_INT 2
111836: ARRAY
111837: PPUSH
111838: LD_VAR 0 3
111842: PPUSH
111843: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111847: LD_ADDR_EXP 179
111851: PUSH
111852: LD_EXP 179
111856: PPUSH
111857: LD_VAR 0 1
111861: PPUSH
111862: LD_EXP 179
111866: PUSH
111867: LD_VAR 0 1
111871: ARRAY
111872: PPUSH
111873: LD_VAR 0 2
111877: PPUSH
111878: CALL_OW 3
111882: PPUSH
111883: CALL_OW 1
111887: ST_TO_ADDR
// end ; end ;
111888: GO 111637
111890: POP
111891: POP
// end ;
111892: GO 111555
111894: POP
111895: POP
// end ;
111896: PPOPN 4
111898: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111899: LD_INT 0
111901: PPUSH
111902: PPUSH
// result := false ;
111903: LD_ADDR_VAR 0 4
111907: PUSH
111908: LD_INT 0
111910: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111911: LD_VAR 0 1
111915: PPUSH
111916: CALL_OW 264
111920: PUSH
111921: LD_INT 81
111923: EQUAL
111924: NOT
111925: IFFALSE 111929
// exit ;
111927: GO 112173
// index := GetElementIndex ( minersList , unit ) ;
111929: LD_ADDR_VAR 0 5
111933: PUSH
111934: LD_EXP 178
111938: PPUSH
111939: LD_VAR 0 1
111943: PPUSH
111944: CALL 22289 0 2
111948: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111949: LD_EXP 179
111953: PUSH
111954: LD_VAR 0 5
111958: ARRAY
111959: PUSH
111960: LD_EXP 180
111964: GREATEREQUAL
111965: IFFALSE 111969
// exit ;
111967: GO 112173
// ComMoveXY ( unit , x , y ) ;
111969: LD_VAR 0 1
111973: PPUSH
111974: LD_VAR 0 2
111978: PPUSH
111979: LD_VAR 0 3
111983: PPUSH
111984: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111988: LD_INT 35
111990: PPUSH
111991: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111995: LD_VAR 0 1
111999: PPUSH
112000: LD_VAR 0 2
112004: PPUSH
112005: LD_VAR 0 3
112009: PPUSH
112010: CALL 54335 0 3
112014: NOT
112015: IFFALSE 112028
112017: PUSH
112018: LD_VAR 0 1
112022: PPUSH
112023: CALL_OW 314
112027: AND
112028: IFFALSE 112032
// exit ;
112030: GO 112173
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
112032: LD_VAR 0 2
112036: PPUSH
112037: LD_VAR 0 3
112041: PPUSH
112042: CALL_OW 428
112046: PUSH
112047: LD_VAR 0 1
112051: EQUAL
112052: IFFALSE 112066
112054: PUSH
112055: LD_VAR 0 1
112059: PPUSH
112060: CALL_OW 314
112064: NOT
112065: AND
112066: IFFALSE 111988
// PlaySoundXY ( x , y , PlantMine ) ;
112068: LD_VAR 0 2
112072: PPUSH
112073: LD_VAR 0 3
112077: PPUSH
112078: LD_STRING PlantMine
112080: PPUSH
112081: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
112085: LD_VAR 0 2
112089: PPUSH
112090: LD_VAR 0 3
112094: PPUSH
112095: LD_VAR 0 1
112099: PPUSH
112100: CALL_OW 255
112104: PPUSH
112105: LD_INT 0
112107: PPUSH
112108: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
112112: LD_ADDR_EXP 179
112116: PUSH
112117: LD_EXP 179
112121: PPUSH
112122: LD_VAR 0 5
112126: PUSH
112127: LD_EXP 179
112131: PUSH
112132: LD_VAR 0 5
112136: ARRAY
112137: PUSH
112138: LD_INT 1
112140: PLUS
112141: PUSH
112142: EMPTY
112143: LIST
112144: LIST
112145: PPUSH
112146: LD_VAR 0 2
112150: PUSH
112151: LD_VAR 0 3
112155: PUSH
112156: EMPTY
112157: LIST
112158: LIST
112159: PPUSH
112160: CALL 22506 0 3
112164: ST_TO_ADDR
// result := true ;
112165: LD_ADDR_VAR 0 4
112169: PUSH
112170: LD_INT 1
112172: ST_TO_ADDR
// end ;
112173: LD_VAR 0 4
112177: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
112178: LD_INT 0
112180: PPUSH
112181: PPUSH
112182: PPUSH
// if not unit in minersList then
112183: LD_VAR 0 1
112187: PUSH
112188: LD_EXP 178
112192: IN
112193: NOT
112194: IFFALSE 112198
// exit ;
112196: GO 112592
// index := GetElementIndex ( minersList , unit ) ;
112198: LD_ADDR_VAR 0 6
112202: PUSH
112203: LD_EXP 178
112207: PPUSH
112208: LD_VAR 0 1
112212: PPUSH
112213: CALL 22289 0 2
112217: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
112218: LD_ADDR_VAR 0 5
112222: PUSH
112223: DOUBLE
112224: LD_EXP 179
112228: PUSH
112229: LD_VAR 0 6
112233: ARRAY
112234: INC
112235: ST_TO_ADDR
112236: LD_INT 1
112238: PUSH
112239: FOR_DOWNTO
112240: IFFALSE 112403
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
112242: LD_EXP 179
112246: PUSH
112247: LD_VAR 0 6
112251: ARRAY
112252: PUSH
112253: LD_VAR 0 5
112257: ARRAY
112258: PUSH
112259: LD_INT 1
112261: ARRAY
112262: PUSH
112263: LD_VAR 0 2
112267: EQUAL
112268: IFFALSE 112298
112270: PUSH
112271: LD_EXP 179
112275: PUSH
112276: LD_VAR 0 6
112280: ARRAY
112281: PUSH
112282: LD_VAR 0 5
112286: ARRAY
112287: PUSH
112288: LD_INT 2
112290: ARRAY
112291: PUSH
112292: LD_VAR 0 3
112296: EQUAL
112297: AND
112298: IFFALSE 112401
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112300: LD_EXP 179
112304: PUSH
112305: LD_VAR 0 6
112309: ARRAY
112310: PUSH
112311: LD_VAR 0 5
112315: ARRAY
112316: PUSH
112317: LD_INT 1
112319: ARRAY
112320: PPUSH
112321: LD_EXP 179
112325: PUSH
112326: LD_VAR 0 6
112330: ARRAY
112331: PUSH
112332: LD_VAR 0 5
112336: ARRAY
112337: PUSH
112338: LD_INT 2
112340: ARRAY
112341: PPUSH
112342: LD_VAR 0 1
112346: PPUSH
112347: CALL_OW 255
112351: PPUSH
112352: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112356: LD_ADDR_EXP 179
112360: PUSH
112361: LD_EXP 179
112365: PPUSH
112366: LD_VAR 0 6
112370: PPUSH
112371: LD_EXP 179
112375: PUSH
112376: LD_VAR 0 6
112380: ARRAY
112381: PPUSH
112382: LD_VAR 0 5
112386: PPUSH
112387: CALL_OW 3
112391: PPUSH
112392: CALL_OW 1
112396: ST_TO_ADDR
// exit ;
112397: POP
112398: POP
112399: GO 112592
// end ; end ;
112401: GO 112239
112403: POP
112404: POP
// for i := minerMinesList [ index ] downto 1 do
112405: LD_ADDR_VAR 0 5
112409: PUSH
112410: DOUBLE
112411: LD_EXP 179
112415: PUSH
112416: LD_VAR 0 6
112420: ARRAY
112421: INC
112422: ST_TO_ADDR
112423: LD_INT 1
112425: PUSH
112426: FOR_DOWNTO
112427: IFFALSE 112590
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
112429: LD_EXP 179
112433: PUSH
112434: LD_VAR 0 6
112438: ARRAY
112439: PUSH
112440: LD_VAR 0 5
112444: ARRAY
112445: PUSH
112446: LD_INT 1
112448: ARRAY
112449: PPUSH
112450: LD_EXP 179
112454: PUSH
112455: LD_VAR 0 6
112459: ARRAY
112460: PUSH
112461: LD_VAR 0 5
112465: ARRAY
112466: PUSH
112467: LD_INT 2
112469: ARRAY
112470: PPUSH
112471: LD_VAR 0 2
112475: PPUSH
112476: LD_VAR 0 3
112480: PPUSH
112481: CALL_OW 298
112485: PUSH
112486: LD_INT 6
112488: LESS
112489: IFFALSE 112588
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
112491: LD_EXP 179
112495: PUSH
112496: LD_VAR 0 6
112500: ARRAY
112501: PUSH
112502: LD_VAR 0 5
112506: ARRAY
112507: PUSH
112508: LD_INT 1
112510: ARRAY
112511: PPUSH
112512: LD_EXP 179
112516: PUSH
112517: LD_VAR 0 6
112521: ARRAY
112522: PUSH
112523: LD_VAR 0 5
112527: ARRAY
112528: PUSH
112529: LD_INT 2
112531: ARRAY
112532: PPUSH
112533: LD_VAR 0 1
112537: PPUSH
112538: CALL_OW 255
112542: PPUSH
112543: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
112547: LD_ADDR_EXP 179
112551: PUSH
112552: LD_EXP 179
112556: PPUSH
112557: LD_VAR 0 6
112561: PPUSH
112562: LD_EXP 179
112566: PUSH
112567: LD_VAR 0 6
112571: ARRAY
112572: PPUSH
112573: LD_VAR 0 5
112577: PPUSH
112578: CALL_OW 3
112582: PPUSH
112583: CALL_OW 1
112587: ST_TO_ADDR
// end ; end ;
112588: GO 112426
112590: POP
112591: POP
// end ;
112592: LD_VAR 0 4
112596: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
112597: LD_INT 0
112599: PPUSH
112600: PPUSH
112601: PPUSH
112602: PPUSH
112603: PPUSH
112604: PPUSH
112605: PPUSH
112606: PPUSH
112607: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
112608: LD_VAR 0 1
112612: PPUSH
112613: CALL_OW 264
112617: PUSH
112618: LD_INT 81
112620: EQUAL
112621: NOT
112622: IFTRUE 112637
112624: PUSH
112625: LD_VAR 0 1
112629: PUSH
112630: LD_EXP 178
112634: IN
112635: NOT
112636: OR
112637: IFFALSE 112641
// exit ;
112639: GO 112967
// index := GetElementIndex ( minersList , unit ) ;
112641: LD_ADDR_VAR 0 6
112645: PUSH
112646: LD_EXP 178
112650: PPUSH
112651: LD_VAR 0 1
112655: PPUSH
112656: CALL 22289 0 2
112660: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
112661: LD_ADDR_VAR 0 8
112665: PUSH
112666: LD_EXP 180
112670: PUSH
112671: LD_EXP 179
112675: PUSH
112676: LD_VAR 0 6
112680: ARRAY
112681: MINUS
112682: ST_TO_ADDR
// if not minesFreeAmount then
112683: LD_VAR 0 8
112687: NOT
112688: IFFALSE 112692
// exit ;
112690: GO 112967
// tmp := [ ] ;
112692: LD_ADDR_VAR 0 7
112696: PUSH
112697: EMPTY
112698: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
112699: LD_ADDR_VAR 0 5
112703: PUSH
112704: DOUBLE
112705: LD_INT 1
112707: DEC
112708: ST_TO_ADDR
112709: LD_VAR 0 8
112713: PUSH
112714: FOR_TO
112715: IFFALSE 112914
// begin _d := rand ( 0 , 5 ) ;
112717: LD_ADDR_VAR 0 11
112721: PUSH
112722: LD_INT 0
112724: PPUSH
112725: LD_INT 5
112727: PPUSH
112728: CALL_OW 12
112732: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112733: LD_ADDR_VAR 0 12
112737: PUSH
112738: LD_INT 2
112740: PPUSH
112741: LD_INT 6
112743: PPUSH
112744: CALL_OW 12
112748: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112749: LD_ADDR_VAR 0 9
112753: PUSH
112754: LD_VAR 0 2
112758: PPUSH
112759: LD_VAR 0 11
112763: PPUSH
112764: LD_VAR 0 12
112768: PPUSH
112769: CALL_OW 272
112773: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112774: LD_ADDR_VAR 0 10
112778: PUSH
112779: LD_VAR 0 3
112783: PPUSH
112784: LD_VAR 0 11
112788: PPUSH
112789: LD_VAR 0 12
112793: PPUSH
112794: CALL_OW 273
112798: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112799: LD_VAR 0 9
112803: PPUSH
112804: LD_VAR 0 10
112808: PPUSH
112809: CALL_OW 488
112813: IFFALSE 112837
112815: PUSH
112816: LD_VAR 0 9
112820: PUSH
112821: LD_VAR 0 10
112825: PUSH
112826: EMPTY
112827: LIST
112828: LIST
112829: PUSH
112830: LD_VAR 0 7
112834: IN
112835: NOT
112836: AND
112837: IFFALSE 112856
112839: PUSH
112840: LD_VAR 0 9
112844: PPUSH
112845: LD_VAR 0 10
112849: PPUSH
112850: CALL_OW 458
112854: NOT
112855: AND
112856: IFFALSE 112898
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112858: LD_ADDR_VAR 0 7
112862: PUSH
112863: LD_VAR 0 7
112867: PPUSH
112868: LD_VAR 0 7
112872: PUSH
112873: LD_INT 1
112875: PLUS
112876: PPUSH
112877: LD_VAR 0 9
112881: PUSH
112882: LD_VAR 0 10
112886: PUSH
112887: EMPTY
112888: LIST
112889: LIST
112890: PPUSH
112891: CALL_OW 1
112895: ST_TO_ADDR
112896: GO 112912
// i := i - 1 ;
112898: LD_ADDR_VAR 0 5
112902: PUSH
112903: LD_VAR 0 5
112907: PUSH
112908: LD_INT 1
112910: MINUS
112911: ST_TO_ADDR
// end ;
112912: GO 112714
112914: POP
112915: POP
// for i in tmp do
112916: LD_ADDR_VAR 0 5
112920: PUSH
112921: LD_VAR 0 7
112925: PUSH
112926: FOR_IN
112927: IFFALSE 112965
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112929: LD_VAR 0 1
112933: PPUSH
112934: LD_VAR 0 5
112938: PUSH
112939: LD_INT 1
112941: ARRAY
112942: PPUSH
112943: LD_VAR 0 5
112947: PUSH
112948: LD_INT 2
112950: ARRAY
112951: PPUSH
112952: CALL 111899 0 3
112956: NOT
112957: IFFALSE 112963
// exit ;
112959: POP
112960: POP
112961: GO 112967
112963: GO 112926
112965: POP
112966: POP
// end ;
112967: LD_VAR 0 4
112971: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
112972: LD_INT 0
112974: PPUSH
112975: PPUSH
112976: PPUSH
112977: PPUSH
112978: PPUSH
112979: PPUSH
112980: PPUSH
112981: PPUSH
112982: PPUSH
// if GetClass ( unit ) <> class_sniper then
112983: LD_VAR 0 1
112987: PPUSH
112988: CALL_OW 257
112992: PUSH
112993: LD_INT 5
112995: NONEQUAL
112996: IFFALSE 113000
// exit ;
112998: GO 113470
// dist := 8 ;
113000: LD_ADDR_VAR 0 5
113004: PUSH
113005: LD_INT 8
113007: ST_TO_ADDR
// viewRange := 12 ;
113008: LD_ADDR_VAR 0 8
113012: PUSH
113013: LD_INT 12
113015: ST_TO_ADDR
// side := GetSide ( unit ) ;
113016: LD_ADDR_VAR 0 6
113020: PUSH
113021: LD_VAR 0 1
113025: PPUSH
113026: CALL_OW 255
113030: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
113031: LD_INT 61
113033: PPUSH
113034: LD_VAR 0 6
113038: PPUSH
113039: CALL_OW 321
113043: PUSH
113044: LD_INT 2
113046: EQUAL
113047: IFFALSE 113057
// viewRange := 16 ;
113049: LD_ADDR_VAR 0 8
113053: PUSH
113054: LD_INT 16
113056: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
113057: LD_VAR 0 1
113061: PPUSH
113062: LD_VAR 0 2
113066: PPUSH
113067: LD_VAR 0 3
113071: PPUSH
113072: CALL_OW 297
113076: PUSH
113077: LD_VAR 0 5
113081: GREATER
113082: IFFALSE 113161
// begin ComMoveXY ( unit , x , y ) ;
113084: LD_VAR 0 1
113088: PPUSH
113089: LD_VAR 0 2
113093: PPUSH
113094: LD_VAR 0 3
113098: PPUSH
113099: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
113103: LD_INT 35
113105: PPUSH
113106: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
113110: LD_VAR 0 1
113114: PPUSH
113115: LD_VAR 0 2
113119: PPUSH
113120: LD_VAR 0 3
113124: PPUSH
113125: CALL 54335 0 3
113129: NOT
113130: IFFALSE 113134
// exit ;
113132: GO 113470
// until GetDistUnitXY ( unit , x , y ) < dist ;
113134: LD_VAR 0 1
113138: PPUSH
113139: LD_VAR 0 2
113143: PPUSH
113144: LD_VAR 0 3
113148: PPUSH
113149: CALL_OW 297
113153: PUSH
113154: LD_VAR 0 5
113158: LESS
113159: IFFALSE 113103
// end ; ComTurnXY ( unit , x , y ) ;
113161: LD_VAR 0 1
113165: PPUSH
113166: LD_VAR 0 2
113170: PPUSH
113171: LD_VAR 0 3
113175: PPUSH
113176: CALL_OW 118
// repeat if Multiplayer then
113180: LD_OWVAR 4
113184: IFFALSE 113195
// wait ( 35 ) else
113186: LD_INT 35
113188: PPUSH
113189: CALL_OW 67
113193: GO 113202
// wait ( 5 ) ;
113195: LD_INT 5
113197: PPUSH
113198: CALL_OW 67
// _d := GetDir ( unit ) ;
113202: LD_ADDR_VAR 0 11
113206: PUSH
113207: LD_VAR 0 1
113211: PPUSH
113212: CALL_OW 254
113216: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
113217: LD_ADDR_VAR 0 7
113221: PUSH
113222: LD_VAR 0 1
113226: PPUSH
113227: CALL_OW 250
113231: PPUSH
113232: LD_VAR 0 1
113236: PPUSH
113237: CALL_OW 251
113241: PPUSH
113242: LD_VAR 0 2
113246: PPUSH
113247: LD_VAR 0 3
113251: PPUSH
113252: CALL 56971 0 4
113256: ST_TO_ADDR
// until dir = _d ;
113257: LD_VAR 0 7
113261: PUSH
113262: LD_VAR 0 11
113266: EQUAL
113267: IFFALSE 113180
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
113269: LD_ADDR_VAR 0 9
113273: PUSH
113274: LD_VAR 0 1
113278: PPUSH
113279: CALL_OW 250
113283: PPUSH
113284: LD_VAR 0 7
113288: PPUSH
113289: LD_VAR 0 5
113293: PPUSH
113294: CALL_OW 272
113298: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
113299: LD_ADDR_VAR 0 10
113303: PUSH
113304: LD_VAR 0 1
113308: PPUSH
113309: CALL_OW 251
113313: PPUSH
113314: LD_VAR 0 7
113318: PPUSH
113319: LD_VAR 0 5
113323: PPUSH
113324: CALL_OW 273
113328: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
113329: LD_VAR 0 9
113333: PPUSH
113334: LD_VAR 0 10
113338: PPUSH
113339: CALL_OW 488
113343: NOT
113344: IFFALSE 113348
// exit ;
113346: GO 113470
// ComAnimCustom ( unit , 1 ) ;
113348: LD_VAR 0 1
113352: PPUSH
113353: LD_INT 1
113355: PPUSH
113356: CALL_OW 592
// p := 0 ;
113360: LD_ADDR_VAR 0 12
113364: PUSH
113365: LD_INT 0
113367: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
113368: LD_VAR 0 9
113372: PPUSH
113373: LD_VAR 0 10
113377: PPUSH
113378: LD_VAR 0 6
113382: PPUSH
113383: LD_VAR 0 8
113387: PPUSH
113388: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
113392: LD_INT 35
113394: PPUSH
113395: CALL_OW 67
// p := Inc ( p ) ;
113399: LD_ADDR_VAR 0 12
113403: PUSH
113404: LD_VAR 0 12
113408: PPUSH
113409: CALL 56927 0 1
113413: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
113414: LD_VAR 0 12
113418: PUSH
113419: LD_INT 3
113421: EQUAL
113422: IFTRUE 113436
113424: PUSH
113425: LD_VAR 0 1
113429: PPUSH
113430: CALL_OW 302
113434: NOT
113435: OR
113436: IFTRUE 113449
113438: PUSH
113439: LD_VAR 0 1
113443: PPUSH
113444: CALL_OW 301
113448: OR
113449: IFFALSE 113392
// RemoveSeeing ( _x , _y , side ) ;
113451: LD_VAR 0 9
113455: PPUSH
113456: LD_VAR 0 10
113460: PPUSH
113461: LD_VAR 0 6
113465: PPUSH
113466: CALL_OW 331
// end ;
113470: LD_VAR 0 4
113474: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
113475: LD_INT 0
113477: PPUSH
113478: PPUSH
113479: PPUSH
113480: PPUSH
113481: PPUSH
113482: PPUSH
113483: PPUSH
113484: PPUSH
113485: PPUSH
113486: PPUSH
113487: PPUSH
// if not unit then
113488: LD_VAR 0 1
113492: NOT
113493: IFFALSE 113497
// exit ;
113495: GO 113768
// side := GetSide ( unit ) ;
113497: LD_ADDR_VAR 0 3
113501: PUSH
113502: LD_VAR 0 1
113506: PPUSH
113507: CALL_OW 255
113511: ST_TO_ADDR
// x := GetX ( unit ) ;
113512: LD_ADDR_VAR 0 5
113516: PUSH
113517: LD_VAR 0 1
113521: PPUSH
113522: CALL_OW 250
113526: ST_TO_ADDR
// y := GetY ( unit ) ;
113527: LD_ADDR_VAR 0 6
113531: PUSH
113532: LD_VAR 0 1
113536: PPUSH
113537: CALL_OW 251
113541: ST_TO_ADDR
// r := 8 ;
113542: LD_ADDR_VAR 0 4
113546: PUSH
113547: LD_INT 8
113549: ST_TO_ADDR
// if x - r < 0 then
113550: LD_VAR 0 5
113554: PUSH
113555: LD_VAR 0 4
113559: MINUS
113560: PUSH
113561: LD_INT 0
113563: LESS
113564: IFFALSE 113576
// min_x := 0 else
113566: LD_ADDR_VAR 0 7
113570: PUSH
113571: LD_INT 0
113573: ST_TO_ADDR
113574: GO 113592
// min_x := x - r ;
113576: LD_ADDR_VAR 0 7
113580: PUSH
113581: LD_VAR 0 5
113585: PUSH
113586: LD_VAR 0 4
113590: MINUS
113591: ST_TO_ADDR
// if y - r < 0 then
113592: LD_VAR 0 6
113596: PUSH
113597: LD_VAR 0 4
113601: MINUS
113602: PUSH
113603: LD_INT 0
113605: LESS
113606: IFFALSE 113618
// min_y := 0 else
113608: LD_ADDR_VAR 0 8
113612: PUSH
113613: LD_INT 0
113615: ST_TO_ADDR
113616: GO 113634
// min_y := y - r ;
113618: LD_ADDR_VAR 0 8
113622: PUSH
113623: LD_VAR 0 6
113627: PUSH
113628: LD_VAR 0 4
113632: MINUS
113633: ST_TO_ADDR
// max_x := x + r ;
113634: LD_ADDR_VAR 0 9
113638: PUSH
113639: LD_VAR 0 5
113643: PUSH
113644: LD_VAR 0 4
113648: PLUS
113649: ST_TO_ADDR
// max_y := y + r ;
113650: LD_ADDR_VAR 0 10
113654: PUSH
113655: LD_VAR 0 6
113659: PUSH
113660: LD_VAR 0 4
113664: PLUS
113665: ST_TO_ADDR
// for _x = min_x to max_x do
113666: LD_ADDR_VAR 0 11
113670: PUSH
113671: DOUBLE
113672: LD_VAR 0 7
113676: DEC
113677: ST_TO_ADDR
113678: LD_VAR 0 9
113682: PUSH
113683: FOR_TO
113684: IFFALSE 113766
// for _y = min_y to max_y do
113686: LD_ADDR_VAR 0 12
113690: PUSH
113691: DOUBLE
113692: LD_VAR 0 8
113696: DEC
113697: ST_TO_ADDR
113698: LD_VAR 0 10
113702: PUSH
113703: FOR_TO
113704: IFFALSE 113762
// begin if not ValidHex ( _x , _y ) then
113706: LD_VAR 0 11
113710: PPUSH
113711: LD_VAR 0 12
113715: PPUSH
113716: CALL_OW 488
113720: NOT
113721: IFFALSE 113725
// continue ;
113723: GO 113703
// if MineAtPos ( _x , _y ) then
113725: LD_VAR 0 11
113729: PPUSH
113730: LD_VAR 0 12
113734: PPUSH
113735: CALL_OW 458
113739: IFFALSE 113760
// ViewMineAtPos ( _x , _y , side ) ;
113741: LD_VAR 0 11
113745: PPUSH
113746: LD_VAR 0 12
113750: PPUSH
113751: LD_VAR 0 3
113755: PPUSH
113756: CALL_OW 457
// end ;
113760: GO 113703
113762: POP
113763: POP
113764: GO 113683
113766: POP
113767: POP
// end ;
113768: LD_VAR 0 2
113772: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer ; begin
113773: LD_INT 0
113775: PPUSH
113776: PPUSH
113777: PPUSH
113778: PPUSH
113779: PPUSH
113780: PPUSH
// if not units then
113781: LD_VAR 0 1
113785: NOT
113786: IFFALSE 113790
// exit ;
113788: GO 114220
// scaners := [ ] ;
113790: LD_ADDR_VAR 0 6
113794: PUSH
113795: EMPTY
113796: ST_TO_ADDR
// for i in units do
113797: LD_ADDR_VAR 0 3
113801: PUSH
113802: LD_VAR 0 1
113806: PUSH
113807: FOR_IN
113808: IFFALSE 113965
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
113810: LD_VAR 0 3
113814: PPUSH
113815: CALL_OW 264
113819: PUSH
113820: LD_INT 11
113822: NONEQUAL
113823: IFTRUE 113837
113825: PUSH
113826: LD_VAR 0 3
113830: PPUSH
113831: CALL_OW 302
113835: NOT
113836: OR
113837: IFTRUE 113854
113839: PUSH
113840: LD_VAR 0 3
113844: PPUSH
113845: CALL_OW 110
113849: PUSH
113850: LD_INT 502
113852: EQUAL
113853: OR
113854: IFFALSE 113858
// continue ;
113856: GO 113807
// ComStop ( i ) ;
113858: LD_VAR 0 3
113862: PPUSH
113863: CALL_OW 141
// x := GetX ( i ) ;
113867: LD_ADDR_VAR 0 4
113871: PUSH
113872: LD_VAR 0 3
113876: PPUSH
113877: CALL_OW 250
113881: ST_TO_ADDR
// y := GetY ( i ) ;
113882: LD_ADDR_VAR 0 5
113886: PUSH
113887: LD_VAR 0 3
113891: PPUSH
113892: CALL_OW 251
113896: ST_TO_ADDR
// if GetSide ( i ) = your_side then
113897: LD_VAR 0 3
113901: PPUSH
113902: CALL_OW 255
113906: PUSH
113907: LD_OWVAR 2
113911: EQUAL
113912: IFFALSE 113931
// PlaySoundXY ( x , y , mineDetector ) ;
113914: LD_VAR 0 4
113918: PPUSH
113919: LD_VAR 0 5
113923: PPUSH
113924: LD_STRING mineDetector
113926: PPUSH
113927: CALL_OW 366
// scaners := Join ( scaners , i ) ;
113931: LD_ADDR_VAR 0 6
113935: PUSH
113936: LD_VAR 0 6
113940: PPUSH
113941: LD_VAR 0 3
113945: PPUSH
113946: CALL 55554 0 2
113950: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
113951: LD_VAR 0 3
113955: PPUSH
113956: LD_INT 502
113958: PPUSH
113959: CALL_OW 109
// end ;
113963: GO 113807
113965: POP
113966: POP
// if not scaners then
113967: LD_VAR 0 6
113971: NOT
113972: IFFALSE 113976
// exit ;
113974: GO 114220
// wait ( 3 ) ;
113976: LD_INT 3
113978: PPUSH
113979: CALL_OW 67
// timer := 6 ;
113983: LD_ADDR_VAR 0 7
113987: PUSH
113988: LD_INT 6
113990: ST_TO_ADDR
// repeat for i in scaners do
113991: LD_ADDR_VAR 0 3
113995: PUSH
113996: LD_VAR 0 6
114000: PUSH
114001: FOR_IN
114002: IFFALSE 114118
// begin if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
114004: LD_VAR 0 3
114008: PPUSH
114009: CALL_OW 302
114013: NOT
114014: IFTRUE 114027
114016: PUSH
114017: LD_VAR 0 3
114021: PPUSH
114022: CALL_OW 314
114026: OR
114027: IFTRUE 114058
114029: PUSH
114030: LD_VAR 0 3
114034: PPUSH
114035: CALL_OW 263
114039: PUSH
114040: LD_INT 1
114042: EQUAL
114043: IFFALSE 114057
114045: PUSH
114046: LD_VAR 0 3
114050: PPUSH
114051: CALL_OW 311
114055: NOT
114056: AND
114057: OR
114058: IFFALSE 114102
// begin SetUnitDisplayNumber ( i , 0 ) ;
114060: LD_VAR 0 3
114064: PPUSH
114065: LD_INT 0
114067: PPUSH
114068: CALL_OW 505
// SetTag ( i , 0 ) ;
114072: LD_VAR 0 3
114076: PPUSH
114077: LD_INT 0
114079: PPUSH
114080: CALL_OW 109
// scaners := scaners diff i ;
114084: LD_ADDR_VAR 0 6
114088: PUSH
114089: LD_VAR 0 6
114093: PUSH
114094: LD_VAR 0 3
114098: DIFF
114099: ST_TO_ADDR
// continue ;
114100: GO 114001
// end ; SetUnitDisplayNumber ( i , timer ) ;
114102: LD_VAR 0 3
114106: PPUSH
114107: LD_VAR 0 7
114111: PPUSH
114112: CALL_OW 505
// end ;
114116: GO 114001
114118: POP
114119: POP
// if not scaners then
114120: LD_VAR 0 6
114124: NOT
114125: IFFALSE 114129
// exit ;
114127: GO 114220
// timer := Dec ( timer ) ;
114129: LD_ADDR_VAR 0 7
114133: PUSH
114134: LD_VAR 0 7
114138: PPUSH
114139: CALL 56949 0 1
114143: ST_TO_ADDR
// wait ( 0 0$1 ) ;
114144: LD_INT 35
114146: PPUSH
114147: CALL_OW 67
// until timer = 0 ;
114151: LD_VAR 0 7
114155: PUSH
114156: LD_INT 0
114158: EQUAL
114159: IFFALSE 113991
// if not scaners then
114161: LD_VAR 0 6
114165: NOT
114166: IFFALSE 114170
// exit ;
114168: GO 114220
// for i in scaners do
114170: LD_ADDR_VAR 0 3
114174: PUSH
114175: LD_VAR 0 6
114179: PUSH
114180: FOR_IN
114181: IFFALSE 114218
// begin SetUnitDisplayNumber ( i , 0 ) ;
114183: LD_VAR 0 3
114187: PPUSH
114188: LD_INT 0
114190: PPUSH
114191: CALL_OW 505
// SetTag ( i , 0 ) ;
114195: LD_VAR 0 3
114199: PPUSH
114200: LD_INT 0
114202: PPUSH
114203: CALL_OW 109
// RevealDetectorMine ( i ) ;
114207: LD_VAR 0 3
114211: PPUSH
114212: CALL 113475 0 1
// end ;
114216: GO 114180
114218: POP
114219: POP
// end ;
114220: LD_VAR 0 2
114224: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
114225: LD_INT 0
114227: PPUSH
// if p1 = mine_detector_mode then
114228: LD_VAR 0 2
114232: PUSH
114233: LD_INT 103
114235: EQUAL
114236: IFFALSE 114247
// DetectMine ( units ) ;
114238: LD_VAR 0 1
114242: PPUSH
114243: CALL 113773 0 1
// end ; end_of_file
114247: LD_VAR 0 7
114251: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
114252: LD_INT 0
114254: PPUSH
114255: PPUSH
114256: PPUSH
114257: PPUSH
114258: PPUSH
114259: PPUSH
114260: PPUSH
114261: PPUSH
114262: PPUSH
114263: PPUSH
114264: PPUSH
114265: PPUSH
114266: PPUSH
114267: PPUSH
114268: PPUSH
114269: PPUSH
114270: PPUSH
114271: PPUSH
114272: PPUSH
114273: PPUSH
114274: PPUSH
114275: PPUSH
114276: PPUSH
114277: PPUSH
114278: PPUSH
114279: PPUSH
114280: PPUSH
114281: PPUSH
114282: PPUSH
114283: PPUSH
114284: PPUSH
114285: PPUSH
114286: PPUSH
114287: PPUSH
// if not list then
114288: LD_VAR 0 1
114292: NOT
114293: IFFALSE 114297
// exit ;
114295: GO 119016
// base := list [ 1 ] ;
114297: LD_ADDR_VAR 0 3
114301: PUSH
114302: LD_VAR 0 1
114306: PUSH
114307: LD_INT 1
114309: ARRAY
114310: ST_TO_ADDR
// group := list [ 2 ] ;
114311: LD_ADDR_VAR 0 4
114315: PUSH
114316: LD_VAR 0 1
114320: PUSH
114321: LD_INT 2
114323: ARRAY
114324: ST_TO_ADDR
// path := list [ 3 ] ;
114325: LD_ADDR_VAR 0 5
114329: PUSH
114330: LD_VAR 0 1
114334: PUSH
114335: LD_INT 3
114337: ARRAY
114338: ST_TO_ADDR
// flags := list [ 4 ] ;
114339: LD_ADDR_VAR 0 6
114343: PUSH
114344: LD_VAR 0 1
114348: PUSH
114349: LD_INT 4
114351: ARRAY
114352: ST_TO_ADDR
// mined := [ ] ;
114353: LD_ADDR_VAR 0 27
114357: PUSH
114358: EMPTY
114359: ST_TO_ADDR
// bombed := [ ] ;
114360: LD_ADDR_VAR 0 28
114364: PUSH
114365: EMPTY
114366: ST_TO_ADDR
// healers := [ ] ;
114367: LD_ADDR_VAR 0 31
114371: PUSH
114372: EMPTY
114373: ST_TO_ADDR
// to_heal := [ ] ;
114374: LD_ADDR_VAR 0 30
114378: PUSH
114379: EMPTY
114380: ST_TO_ADDR
// repairs := [ ] ;
114381: LD_ADDR_VAR 0 33
114385: PUSH
114386: EMPTY
114387: ST_TO_ADDR
// to_repair := [ ] ;
114388: LD_ADDR_VAR 0 32
114392: PUSH
114393: EMPTY
114394: ST_TO_ADDR
// if not group or not path then
114395: LD_VAR 0 4
114399: NOT
114400: IFTRUE 114409
114402: PUSH
114403: LD_VAR 0 5
114407: NOT
114408: OR
114409: IFFALSE 114413
// exit ;
114411: GO 119016
// side := GetSide ( group [ 1 ] ) ;
114413: LD_ADDR_VAR 0 35
114417: PUSH
114418: LD_VAR 0 4
114422: PUSH
114423: LD_INT 1
114425: ARRAY
114426: PPUSH
114427: CALL_OW 255
114431: ST_TO_ADDR
// if flags then
114432: LD_VAR 0 6
114436: IFFALSE 114580
// begin f_ignore_area := flags [ 1 ] ;
114438: LD_ADDR_VAR 0 17
114442: PUSH
114443: LD_VAR 0 6
114447: PUSH
114448: LD_INT 1
114450: ARRAY
114451: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
114452: LD_ADDR_VAR 0 18
114456: PUSH
114457: LD_VAR 0 6
114461: PUSH
114462: LD_INT 2
114464: ARRAY
114465: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
114466: LD_ADDR_VAR 0 19
114470: PUSH
114471: LD_VAR 0 6
114475: PUSH
114476: LD_INT 3
114478: ARRAY
114479: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
114480: LD_ADDR_VAR 0 20
114484: PUSH
114485: LD_VAR 0 6
114489: PUSH
114490: LD_INT 4
114492: ARRAY
114493: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
114494: LD_ADDR_VAR 0 21
114498: PUSH
114499: LD_VAR 0 6
114503: PUSH
114504: LD_INT 5
114506: ARRAY
114507: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
114508: LD_ADDR_VAR 0 22
114512: PUSH
114513: LD_VAR 0 6
114517: PUSH
114518: LD_INT 6
114520: ARRAY
114521: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
114522: LD_ADDR_VAR 0 23
114526: PUSH
114527: LD_VAR 0 6
114531: PUSH
114532: LD_INT 7
114534: ARRAY
114535: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
114536: LD_ADDR_VAR 0 24
114540: PUSH
114541: LD_VAR 0 6
114545: PUSH
114546: LD_INT 8
114548: ARRAY
114549: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
114550: LD_ADDR_VAR 0 25
114554: PUSH
114555: LD_VAR 0 6
114559: PUSH
114560: LD_INT 9
114562: ARRAY
114563: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
114564: LD_ADDR_VAR 0 26
114568: PUSH
114569: LD_VAR 0 6
114573: PUSH
114574: LD_INT 10
114576: ARRAY
114577: ST_TO_ADDR
// end else
114578: GO 114660
// begin f_ignore_area := false ;
114580: LD_ADDR_VAR 0 17
114584: PUSH
114585: LD_INT 0
114587: ST_TO_ADDR
// f_capture := false ;
114588: LD_ADDR_VAR 0 18
114592: PUSH
114593: LD_INT 0
114595: ST_TO_ADDR
// f_ignore_civ := false ;
114596: LD_ADDR_VAR 0 19
114600: PUSH
114601: LD_INT 0
114603: ST_TO_ADDR
// f_murder := false ;
114604: LD_ADDR_VAR 0 20
114608: PUSH
114609: LD_INT 0
114611: ST_TO_ADDR
// f_mines := false ;
114612: LD_ADDR_VAR 0 21
114616: PUSH
114617: LD_INT 0
114619: ST_TO_ADDR
// f_repair := false ;
114620: LD_ADDR_VAR 0 22
114624: PUSH
114625: LD_INT 0
114627: ST_TO_ADDR
// f_heal := false ;
114628: LD_ADDR_VAR 0 23
114632: PUSH
114633: LD_INT 0
114635: ST_TO_ADDR
// f_spacetime := false ;
114636: LD_ADDR_VAR 0 24
114640: PUSH
114641: LD_INT 0
114643: ST_TO_ADDR
// f_attack_depot := false ;
114644: LD_ADDR_VAR 0 25
114648: PUSH
114649: LD_INT 0
114651: ST_TO_ADDR
// f_crawl := false ;
114652: LD_ADDR_VAR 0 26
114656: PUSH
114657: LD_INT 0
114659: ST_TO_ADDR
// end ; if f_heal then
114660: LD_VAR 0 23
114664: IFFALSE 114691
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
114666: LD_ADDR_VAR 0 31
114670: PUSH
114671: LD_VAR 0 4
114675: PPUSH
114676: LD_INT 25
114678: PUSH
114679: LD_INT 4
114681: PUSH
114682: EMPTY
114683: LIST
114684: LIST
114685: PPUSH
114686: CALL_OW 72
114690: ST_TO_ADDR
// if f_repair then
114691: LD_VAR 0 22
114695: IFFALSE 114722
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
114697: LD_ADDR_VAR 0 33
114701: PUSH
114702: LD_VAR 0 4
114706: PPUSH
114707: LD_INT 25
114709: PUSH
114710: LD_INT 3
114712: PUSH
114713: EMPTY
114714: LIST
114715: LIST
114716: PPUSH
114717: CALL_OW 72
114721: ST_TO_ADDR
// units_path := [ ] ;
114722: LD_ADDR_VAR 0 16
114726: PUSH
114727: EMPTY
114728: ST_TO_ADDR
// for i = 1 to group do
114729: LD_ADDR_VAR 0 7
114733: PUSH
114734: DOUBLE
114735: LD_INT 1
114737: DEC
114738: ST_TO_ADDR
114739: LD_VAR 0 4
114743: PUSH
114744: FOR_TO
114745: IFFALSE 114774
// units_path := Replace ( units_path , i , path ) ;
114747: LD_ADDR_VAR 0 16
114751: PUSH
114752: LD_VAR 0 16
114756: PPUSH
114757: LD_VAR 0 7
114761: PPUSH
114762: LD_VAR 0 5
114766: PPUSH
114767: CALL_OW 1
114771: ST_TO_ADDR
114772: GO 114744
114774: POP
114775: POP
// repeat for i = group downto 1 do
114776: LD_ADDR_VAR 0 7
114780: PUSH
114781: DOUBLE
114782: LD_VAR 0 4
114786: INC
114787: ST_TO_ADDR
114788: LD_INT 1
114790: PUSH
114791: FOR_DOWNTO
114792: IFFALSE 118968
// begin wait ( 5 ) ;
114794: LD_INT 5
114796: PPUSH
114797: CALL_OW 67
// tmp := [ ] ;
114801: LD_ADDR_VAR 0 14
114805: PUSH
114806: EMPTY
114807: ST_TO_ADDR
// attacking := false ;
114808: LD_ADDR_VAR 0 29
114812: PUSH
114813: LD_INT 0
114815: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
114816: LD_VAR 0 4
114820: PUSH
114821: LD_VAR 0 7
114825: ARRAY
114826: PPUSH
114827: CALL_OW 301
114831: IFTRUE 114846
114833: PUSH
114834: LD_VAR 0 4
114838: PUSH
114839: LD_VAR 0 7
114843: ARRAY
114844: NOT
114845: OR
114846: IFFALSE 114955
// begin if GetType ( group [ i ] ) = unit_human then
114848: LD_VAR 0 4
114852: PUSH
114853: LD_VAR 0 7
114857: ARRAY
114858: PPUSH
114859: CALL_OW 247
114863: PUSH
114864: LD_INT 1
114866: EQUAL
114867: IFFALSE 114913
// begin to_heal := to_heal diff group [ i ] ;
114869: LD_ADDR_VAR 0 30
114873: PUSH
114874: LD_VAR 0 30
114878: PUSH
114879: LD_VAR 0 4
114883: PUSH
114884: LD_VAR 0 7
114888: ARRAY
114889: DIFF
114890: ST_TO_ADDR
// healers := healers diff group [ i ] ;
114891: LD_ADDR_VAR 0 31
114895: PUSH
114896: LD_VAR 0 31
114900: PUSH
114901: LD_VAR 0 4
114905: PUSH
114906: LD_VAR 0 7
114910: ARRAY
114911: DIFF
114912: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
114913: LD_ADDR_VAR 0 4
114917: PUSH
114918: LD_VAR 0 4
114922: PPUSH
114923: LD_VAR 0 7
114927: PPUSH
114928: CALL_OW 3
114932: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
114933: LD_ADDR_VAR 0 16
114937: PUSH
114938: LD_VAR 0 16
114942: PPUSH
114943: LD_VAR 0 7
114947: PPUSH
114948: CALL_OW 3
114952: ST_TO_ADDR
// continue ;
114953: GO 114791
// end ; if f_repair then
114955: LD_VAR 0 22
114959: IFFALSE 115456
// begin if GetType ( group [ i ] ) = unit_vehicle then
114961: LD_VAR 0 4
114965: PUSH
114966: LD_VAR 0 7
114970: ARRAY
114971: PPUSH
114972: CALL_OW 247
114976: PUSH
114977: LD_INT 2
114979: EQUAL
114980: IFFALSE 115174
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
114982: LD_VAR 0 4
114986: PUSH
114987: LD_VAR 0 7
114991: ARRAY
114992: PPUSH
114993: CALL_OW 256
114997: PUSH
114998: LD_INT 700
115000: LESS
115001: IFFALSE 115022
115003: PUSH
115004: LD_VAR 0 4
115008: PUSH
115009: LD_VAR 0 7
115013: ARRAY
115014: PUSH
115015: LD_VAR 0 32
115019: IN
115020: NOT
115021: AND
115022: IFFALSE 115046
// to_repair := to_repair union group [ i ] ;
115024: LD_ADDR_VAR 0 32
115028: PUSH
115029: LD_VAR 0 32
115033: PUSH
115034: LD_VAR 0 4
115038: PUSH
115039: LD_VAR 0 7
115043: ARRAY
115044: UNION
115045: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
115046: LD_VAR 0 4
115050: PUSH
115051: LD_VAR 0 7
115055: ARRAY
115056: PPUSH
115057: CALL_OW 256
115061: PUSH
115062: LD_INT 1000
115064: EQUAL
115065: IFFALSE 115085
115067: PUSH
115068: LD_VAR 0 4
115072: PUSH
115073: LD_VAR 0 7
115077: ARRAY
115078: PUSH
115079: LD_VAR 0 32
115083: IN
115084: AND
115085: IFFALSE 115109
// to_repair := to_repair diff group [ i ] ;
115087: LD_ADDR_VAR 0 32
115091: PUSH
115092: LD_VAR 0 32
115096: PUSH
115097: LD_VAR 0 4
115101: PUSH
115102: LD_VAR 0 7
115106: ARRAY
115107: DIFF
115108: ST_TO_ADDR
// if group [ i ] in to_repair then
115109: LD_VAR 0 4
115113: PUSH
115114: LD_VAR 0 7
115118: ARRAY
115119: PUSH
115120: LD_VAR 0 32
115124: IN
115125: IFFALSE 115172
// begin if not IsInArea ( group [ i ] , f_repair ) then
115127: LD_VAR 0 4
115131: PUSH
115132: LD_VAR 0 7
115136: ARRAY
115137: PPUSH
115138: LD_VAR 0 22
115142: PPUSH
115143: CALL_OW 308
115147: NOT
115148: IFFALSE 115170
// ComMoveToArea ( group [ i ] , f_repair ) ;
115150: LD_VAR 0 4
115154: PUSH
115155: LD_VAR 0 7
115159: ARRAY
115160: PPUSH
115161: LD_VAR 0 22
115165: PPUSH
115166: CALL_OW 113
// continue ;
115170: GO 114791
// end ; end else
115172: GO 115456
// if group [ i ] in repairs then
115174: LD_VAR 0 4
115178: PUSH
115179: LD_VAR 0 7
115183: ARRAY
115184: PUSH
115185: LD_VAR 0 33
115189: IN
115190: IFFALSE 115456
// begin if IsInUnit ( group [ i ] ) then
115192: LD_VAR 0 4
115196: PUSH
115197: LD_VAR 0 7
115201: ARRAY
115202: PPUSH
115203: CALL_OW 310
115207: IFFALSE 115277
// begin z := IsInUnit ( group [ i ] ) ;
115209: LD_ADDR_VAR 0 13
115213: PUSH
115214: LD_VAR 0 4
115218: PUSH
115219: LD_VAR 0 7
115223: ARRAY
115224: PPUSH
115225: CALL_OW 310
115229: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
115230: LD_VAR 0 13
115234: PUSH
115235: LD_VAR 0 32
115239: IN
115240: IFFALSE 115258
115242: PUSH
115243: LD_VAR 0 13
115247: PPUSH
115248: LD_VAR 0 22
115252: PPUSH
115253: CALL_OW 308
115257: AND
115258: IFFALSE 115275
// ComExitVehicle ( group [ i ] ) ;
115260: LD_VAR 0 4
115264: PUSH
115265: LD_VAR 0 7
115269: ARRAY
115270: PPUSH
115271: CALL_OW 121
// end else
115275: GO 115456
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
115277: LD_ADDR_VAR 0 13
115281: PUSH
115282: LD_VAR 0 4
115286: PPUSH
115287: LD_INT 95
115289: PUSH
115290: LD_VAR 0 22
115294: PUSH
115295: EMPTY
115296: LIST
115297: LIST
115298: PUSH
115299: LD_INT 58
115301: PUSH
115302: EMPTY
115303: LIST
115304: PUSH
115305: EMPTY
115306: LIST
115307: LIST
115308: PPUSH
115309: CALL_OW 72
115313: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
115314: LD_VAR 0 4
115318: PUSH
115319: LD_VAR 0 7
115323: ARRAY
115324: PPUSH
115325: CALL_OW 314
115329: NOT
115330: IFFALSE 115454
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
115332: LD_ADDR_VAR 0 10
115336: PUSH
115337: LD_VAR 0 13
115341: PPUSH
115342: LD_VAR 0 4
115346: PUSH
115347: LD_VAR 0 7
115351: ARRAY
115352: PPUSH
115353: CALL_OW 74
115357: ST_TO_ADDR
// if not x then
115358: LD_VAR 0 10
115362: NOT
115363: IFFALSE 115367
// continue ;
115365: GO 114791
// if GetLives ( x ) < 1000 then
115367: LD_VAR 0 10
115371: PPUSH
115372: CALL_OW 256
115376: PUSH
115377: LD_INT 1000
115379: LESS
115380: IFFALSE 115404
// ComRepairVehicle ( group [ i ] , x ) else
115382: LD_VAR 0 4
115386: PUSH
115387: LD_VAR 0 7
115391: ARRAY
115392: PPUSH
115393: LD_VAR 0 10
115397: PPUSH
115398: CALL_OW 129
115402: GO 115454
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
115404: LD_VAR 0 23
115408: IFFALSE 115431
115410: PUSH
115411: LD_VAR 0 4
115415: PUSH
115416: LD_VAR 0 7
115420: ARRAY
115421: PPUSH
115422: CALL_OW 256
115426: PUSH
115427: LD_INT 1000
115429: LESS
115430: AND
115431: NOT
115432: IFFALSE 115454
// ComEnterUnit ( group [ i ] , x ) ;
115434: LD_VAR 0 4
115438: PUSH
115439: LD_VAR 0 7
115443: ARRAY
115444: PPUSH
115445: LD_VAR 0 10
115449: PPUSH
115450: CALL_OW 120
// end ; continue ;
115454: GO 114791
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
115456: LD_VAR 0 23
115460: IFFALSE 115483
115462: PUSH
115463: LD_VAR 0 4
115467: PUSH
115468: LD_VAR 0 7
115472: ARRAY
115473: PPUSH
115474: CALL_OW 247
115478: PUSH
115479: LD_INT 1
115481: EQUAL
115482: AND
115483: IFFALSE 115967
// begin if group [ i ] in healers then
115485: LD_VAR 0 4
115489: PUSH
115490: LD_VAR 0 7
115494: ARRAY
115495: PUSH
115496: LD_VAR 0 31
115500: IN
115501: IFFALSE 115778
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
115503: LD_VAR 0 4
115507: PUSH
115508: LD_VAR 0 7
115512: ARRAY
115513: PPUSH
115514: LD_VAR 0 23
115518: PPUSH
115519: CALL_OW 308
115523: NOT
115524: IFFALSE 115544
115526: PUSH
115527: LD_VAR 0 4
115531: PUSH
115532: LD_VAR 0 7
115536: ARRAY
115537: PPUSH
115538: CALL_OW 314
115542: NOT
115543: AND
115544: IFFALSE 115568
// ComMoveToArea ( group [ i ] , f_heal ) else
115546: LD_VAR 0 4
115550: PUSH
115551: LD_VAR 0 7
115555: ARRAY
115556: PPUSH
115557: LD_VAR 0 23
115561: PPUSH
115562: CALL_OW 113
115566: GO 115776
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
115568: LD_VAR 0 4
115572: PUSH
115573: LD_VAR 0 7
115577: ARRAY
115578: PPUSH
115579: CALL 52910 0 1
115583: PPUSH
115584: CALL_OW 256
115588: PUSH
115589: LD_INT 1000
115591: EQUAL
115592: IFFALSE 115611
// ComStop ( group [ i ] ) else
115594: LD_VAR 0 4
115598: PUSH
115599: LD_VAR 0 7
115603: ARRAY
115604: PPUSH
115605: CALL_OW 141
115609: GO 115776
// if not HasTask ( group [ i ] ) and to_heal then
115611: LD_VAR 0 4
115615: PUSH
115616: LD_VAR 0 7
115620: ARRAY
115621: PPUSH
115622: CALL_OW 314
115626: NOT
115627: IFFALSE 115635
115629: PUSH
115630: LD_VAR 0 30
115634: AND
115635: IFFALSE 115776
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
115637: LD_ADDR_VAR 0 13
115641: PUSH
115642: LD_VAR 0 30
115646: PPUSH
115647: LD_INT 3
115649: PUSH
115650: LD_INT 54
115652: PUSH
115653: EMPTY
115654: LIST
115655: PUSH
115656: EMPTY
115657: LIST
115658: LIST
115659: PPUSH
115660: CALL_OW 72
115664: PPUSH
115665: LD_VAR 0 4
115669: PUSH
115670: LD_VAR 0 7
115674: ARRAY
115675: PPUSH
115676: CALL_OW 74
115680: ST_TO_ADDR
// if z then
115681: LD_VAR 0 13
115685: IFFALSE 115776
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
115687: LD_INT 91
115689: PUSH
115690: LD_VAR 0 13
115694: PUSH
115695: LD_INT 10
115697: PUSH
115698: EMPTY
115699: LIST
115700: LIST
115701: LIST
115702: PUSH
115703: LD_INT 81
115705: PUSH
115706: LD_VAR 0 13
115710: PPUSH
115711: CALL_OW 255
115715: PUSH
115716: EMPTY
115717: LIST
115718: LIST
115719: PUSH
115720: EMPTY
115721: LIST
115722: LIST
115723: PPUSH
115724: CALL_OW 69
115728: PUSH
115729: LD_INT 0
115731: EQUAL
115732: IFFALSE 115756
// ComHeal ( group [ i ] , z ) else
115734: LD_VAR 0 4
115738: PUSH
115739: LD_VAR 0 7
115743: ARRAY
115744: PPUSH
115745: LD_VAR 0 13
115749: PPUSH
115750: CALL_OW 128
115754: GO 115776
// ComMoveToArea ( group [ i ] , f_heal ) ;
115756: LD_VAR 0 4
115760: PUSH
115761: LD_VAR 0 7
115765: ARRAY
115766: PPUSH
115767: LD_VAR 0 23
115771: PPUSH
115772: CALL_OW 113
// end ; continue ;
115776: GO 114791
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
115778: LD_VAR 0 4
115782: PUSH
115783: LD_VAR 0 7
115787: ARRAY
115788: PPUSH
115789: CALL_OW 256
115793: PUSH
115794: LD_INT 700
115796: LESS
115797: IFFALSE 115818
115799: PUSH
115800: LD_VAR 0 4
115804: PUSH
115805: LD_VAR 0 7
115809: ARRAY
115810: PUSH
115811: LD_VAR 0 30
115815: IN
115816: NOT
115817: AND
115818: IFFALSE 115842
// to_heal := to_heal union group [ i ] ;
115820: LD_ADDR_VAR 0 30
115824: PUSH
115825: LD_VAR 0 30
115829: PUSH
115830: LD_VAR 0 4
115834: PUSH
115835: LD_VAR 0 7
115839: ARRAY
115840: UNION
115841: ST_TO_ADDR
// if group [ i ] in to_heal then
115842: LD_VAR 0 4
115846: PUSH
115847: LD_VAR 0 7
115851: ARRAY
115852: PUSH
115853: LD_VAR 0 30
115857: IN
115858: IFFALSE 115967
// begin if GetLives ( group [ i ] ) = 1000 then
115860: LD_VAR 0 4
115864: PUSH
115865: LD_VAR 0 7
115869: ARRAY
115870: PPUSH
115871: CALL_OW 256
115875: PUSH
115876: LD_INT 1000
115878: EQUAL
115879: IFFALSE 115905
// to_heal := to_heal diff group [ i ] else
115881: LD_ADDR_VAR 0 30
115885: PUSH
115886: LD_VAR 0 30
115890: PUSH
115891: LD_VAR 0 4
115895: PUSH
115896: LD_VAR 0 7
115900: ARRAY
115901: DIFF
115902: ST_TO_ADDR
115903: GO 115967
// begin if not IsInArea ( group [ i ] , to_heal ) then
115905: LD_VAR 0 4
115909: PUSH
115910: LD_VAR 0 7
115914: ARRAY
115915: PPUSH
115916: LD_VAR 0 30
115920: PPUSH
115921: CALL_OW 308
115925: NOT
115926: IFFALSE 115950
// ComMoveToArea ( group [ i ] , f_heal ) else
115928: LD_VAR 0 4
115932: PUSH
115933: LD_VAR 0 7
115937: ARRAY
115938: PPUSH
115939: LD_VAR 0 23
115943: PPUSH
115944: CALL_OW 113
115948: GO 115965
// ComHold ( group [ i ] ) ;
115950: LD_VAR 0 4
115954: PUSH
115955: LD_VAR 0 7
115959: ARRAY
115960: PPUSH
115961: CALL_OW 140
// continue ;
115965: GO 114791
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
115967: LD_VAR 0 4
115971: PUSH
115972: LD_VAR 0 7
115976: ARRAY
115977: PPUSH
115978: LD_INT 10
115980: PPUSH
115981: CALL 50519 0 2
115985: NOT
115986: IFFALSE 116004
115988: PUSH
115989: LD_VAR 0 16
115993: PUSH
115994: LD_VAR 0 7
115998: ARRAY
115999: PUSH
116000: EMPTY
116001: EQUAL
116002: NOT
116003: AND
116004: IFFALSE 116270
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
116006: LD_VAR 0 4
116010: PUSH
116011: LD_VAR 0 7
116015: ARRAY
116016: PPUSH
116017: CALL_OW 262
116021: PUSH
116022: LD_INT 1
116024: PUSH
116025: LD_INT 2
116027: PUSH
116028: EMPTY
116029: LIST
116030: LIST
116031: IN
116032: IFFALSE 116073
// if GetFuel ( group [ i ] ) < 10 then
116034: LD_VAR 0 4
116038: PUSH
116039: LD_VAR 0 7
116043: ARRAY
116044: PPUSH
116045: CALL_OW 261
116049: PUSH
116050: LD_INT 10
116052: LESS
116053: IFFALSE 116073
// SetFuel ( group [ i ] , 12 ) ;
116055: LD_VAR 0 4
116059: PUSH
116060: LD_VAR 0 7
116064: ARRAY
116065: PPUSH
116066: LD_INT 12
116068: PPUSH
116069: CALL_OW 240
// if units_path [ i ] then
116073: LD_VAR 0 16
116077: PUSH
116078: LD_VAR 0 7
116082: ARRAY
116083: IFFALSE 116268
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
116085: LD_VAR 0 4
116089: PUSH
116090: LD_VAR 0 7
116094: ARRAY
116095: PPUSH
116096: LD_VAR 0 16
116100: PUSH
116101: LD_VAR 0 7
116105: ARRAY
116106: PUSH
116107: LD_INT 1
116109: ARRAY
116110: PUSH
116111: LD_INT 1
116113: ARRAY
116114: PPUSH
116115: LD_VAR 0 16
116119: PUSH
116120: LD_VAR 0 7
116124: ARRAY
116125: PUSH
116126: LD_INT 1
116128: ARRAY
116129: PUSH
116130: LD_INT 2
116132: ARRAY
116133: PPUSH
116134: CALL_OW 297
116138: PUSH
116139: LD_INT 6
116141: GREATER
116142: IFFALSE 116217
// begin if not HasTask ( group [ i ] ) then
116144: LD_VAR 0 4
116148: PUSH
116149: LD_VAR 0 7
116153: ARRAY
116154: PPUSH
116155: CALL_OW 314
116159: NOT
116160: IFFALSE 116215
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
116162: LD_VAR 0 4
116166: PUSH
116167: LD_VAR 0 7
116171: ARRAY
116172: PPUSH
116173: LD_VAR 0 16
116177: PUSH
116178: LD_VAR 0 7
116182: ARRAY
116183: PUSH
116184: LD_INT 1
116186: ARRAY
116187: PUSH
116188: LD_INT 1
116190: ARRAY
116191: PPUSH
116192: LD_VAR 0 16
116196: PUSH
116197: LD_VAR 0 7
116201: ARRAY
116202: PUSH
116203: LD_INT 1
116205: ARRAY
116206: PUSH
116207: LD_INT 2
116209: ARRAY
116210: PPUSH
116211: CALL_OW 114
// end else
116215: GO 116268
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
116217: LD_ADDR_VAR 0 15
116221: PUSH
116222: LD_VAR 0 16
116226: PUSH
116227: LD_VAR 0 7
116231: ARRAY
116232: PPUSH
116233: LD_INT 1
116235: PPUSH
116236: CALL_OW 3
116240: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
116241: LD_ADDR_VAR 0 16
116245: PUSH
116246: LD_VAR 0 16
116250: PPUSH
116251: LD_VAR 0 7
116255: PPUSH
116256: LD_VAR 0 15
116260: PPUSH
116261: CALL_OW 1
116265: ST_TO_ADDR
// continue ;
116266: GO 114791
// end ; end ; end else
116268: GO 118966
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
116270: LD_ADDR_VAR 0 14
116274: PUSH
116275: LD_INT 81
116277: PUSH
116278: LD_VAR 0 4
116282: PUSH
116283: LD_VAR 0 7
116287: ARRAY
116288: PPUSH
116289: CALL_OW 255
116293: PUSH
116294: EMPTY
116295: LIST
116296: LIST
116297: PPUSH
116298: CALL_OW 69
116302: ST_TO_ADDR
// if not tmp then
116303: LD_VAR 0 14
116307: NOT
116308: IFFALSE 116312
// continue ;
116310: GO 114791
// if f_ignore_area then
116312: LD_VAR 0 17
116316: IFFALSE 116404
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
116318: LD_ADDR_VAR 0 15
116322: PUSH
116323: LD_VAR 0 14
116327: PPUSH
116328: LD_INT 3
116330: PUSH
116331: LD_INT 92
116333: PUSH
116334: LD_VAR 0 17
116338: PUSH
116339: LD_INT 1
116341: ARRAY
116342: PUSH
116343: LD_VAR 0 17
116347: PUSH
116348: LD_INT 2
116350: ARRAY
116351: PUSH
116352: LD_VAR 0 17
116356: PUSH
116357: LD_INT 3
116359: ARRAY
116360: PUSH
116361: EMPTY
116362: LIST
116363: LIST
116364: LIST
116365: LIST
116366: PUSH
116367: EMPTY
116368: LIST
116369: LIST
116370: PPUSH
116371: CALL_OW 72
116375: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116376: LD_VAR 0 14
116380: PUSH
116381: LD_VAR 0 15
116385: DIFF
116386: IFFALSE 116404
// tmp := tmp diff tmp2 ;
116388: LD_ADDR_VAR 0 14
116392: PUSH
116393: LD_VAR 0 14
116397: PUSH
116398: LD_VAR 0 15
116402: DIFF
116403: ST_TO_ADDR
// end ; if not f_murder then
116404: LD_VAR 0 20
116408: NOT
116409: IFFALSE 116467
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
116411: LD_ADDR_VAR 0 15
116415: PUSH
116416: LD_VAR 0 14
116420: PPUSH
116421: LD_INT 3
116423: PUSH
116424: LD_INT 50
116426: PUSH
116427: EMPTY
116428: LIST
116429: PUSH
116430: EMPTY
116431: LIST
116432: LIST
116433: PPUSH
116434: CALL_OW 72
116438: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
116439: LD_VAR 0 14
116443: PUSH
116444: LD_VAR 0 15
116448: DIFF
116449: IFFALSE 116467
// tmp := tmp diff tmp2 ;
116451: LD_ADDR_VAR 0 14
116455: PUSH
116456: LD_VAR 0 14
116460: PUSH
116461: LD_VAR 0 15
116465: DIFF
116466: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
116467: LD_ADDR_VAR 0 14
116471: PUSH
116472: LD_VAR 0 4
116476: PUSH
116477: LD_VAR 0 7
116481: ARRAY
116482: PPUSH
116483: LD_VAR 0 14
116487: PPUSH
116488: LD_INT 1
116490: PPUSH
116491: LD_INT 1
116493: PPUSH
116494: CALL 22941 0 4
116498: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
116499: LD_VAR 0 4
116503: PUSH
116504: LD_VAR 0 7
116508: ARRAY
116509: PPUSH
116510: CALL_OW 257
116514: PUSH
116515: LD_INT 1
116517: EQUAL
116518: IFFALSE 116978
// begin if WantPlant ( group [ i ] ) then
116520: LD_VAR 0 4
116524: PUSH
116525: LD_VAR 0 7
116529: ARRAY
116530: PPUSH
116531: CALL 22442 0 1
116535: IFFALSE 116539
// continue ;
116537: GO 114791
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
116539: LD_VAR 0 18
116543: IFFALSE 116563
116545: PUSH
116546: LD_VAR 0 4
116550: PUSH
116551: LD_VAR 0 7
116555: ARRAY
116556: PPUSH
116557: CALL_OW 310
116561: NOT
116562: AND
116563: IFFALSE 116606
116565: PUSH
116566: LD_VAR 0 14
116570: PUSH
116571: LD_INT 1
116573: ARRAY
116574: PUSH
116575: LD_VAR 0 14
116579: PPUSH
116580: LD_INT 21
116582: PUSH
116583: LD_INT 2
116585: PUSH
116586: EMPTY
116587: LIST
116588: LIST
116589: PUSH
116590: LD_INT 58
116592: PUSH
116593: EMPTY
116594: LIST
116595: PUSH
116596: EMPTY
116597: LIST
116598: LIST
116599: PPUSH
116600: CALL_OW 72
116604: IN
116605: AND
116606: IFFALSE 116642
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
116608: LD_VAR 0 4
116612: PUSH
116613: LD_VAR 0 7
116617: ARRAY
116618: PPUSH
116619: LD_VAR 0 14
116623: PUSH
116624: LD_INT 1
116626: ARRAY
116627: PPUSH
116628: CALL_OW 120
// attacking := true ;
116632: LD_ADDR_VAR 0 29
116636: PUSH
116637: LD_INT 1
116639: ST_TO_ADDR
// continue ;
116640: GO 114791
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
116642: LD_VAR 0 26
116646: IFFALSE 116669
116648: PUSH
116649: LD_VAR 0 4
116653: PUSH
116654: LD_VAR 0 7
116658: ARRAY
116659: PPUSH
116660: CALL_OW 257
116664: PUSH
116665: LD_INT 1
116667: EQUAL
116668: AND
116669: IFFALSE 116692
116671: PUSH
116672: LD_VAR 0 4
116676: PUSH
116677: LD_VAR 0 7
116681: ARRAY
116682: PPUSH
116683: CALL_OW 256
116687: PUSH
116688: LD_INT 800
116690: LESS
116691: AND
116692: IFFALSE 116712
116694: PUSH
116695: LD_VAR 0 4
116699: PUSH
116700: LD_VAR 0 7
116704: ARRAY
116705: PPUSH
116706: CALL_OW 318
116710: NOT
116711: AND
116712: IFFALSE 116729
// ComCrawl ( group [ i ] ) ;
116714: LD_VAR 0 4
116718: PUSH
116719: LD_VAR 0 7
116723: ARRAY
116724: PPUSH
116725: CALL_OW 137
// if f_mines then
116729: LD_VAR 0 21
116733: IFFALSE 116978
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
116735: LD_VAR 0 14
116739: PUSH
116740: LD_INT 1
116742: ARRAY
116743: PPUSH
116744: CALL_OW 247
116748: PUSH
116749: LD_INT 3
116751: EQUAL
116752: IFFALSE 116771
116754: PUSH
116755: LD_VAR 0 14
116759: PUSH
116760: LD_INT 1
116762: ARRAY
116763: PUSH
116764: LD_VAR 0 27
116768: IN
116769: NOT
116770: AND
116771: IFFALSE 116978
// begin x := GetX ( tmp [ 1 ] ) ;
116773: LD_ADDR_VAR 0 10
116777: PUSH
116778: LD_VAR 0 14
116782: PUSH
116783: LD_INT 1
116785: ARRAY
116786: PPUSH
116787: CALL_OW 250
116791: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
116792: LD_ADDR_VAR 0 11
116796: PUSH
116797: LD_VAR 0 14
116801: PUSH
116802: LD_INT 1
116804: ARRAY
116805: PPUSH
116806: CALL_OW 251
116810: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
116811: LD_ADDR_VAR 0 12
116815: PUSH
116816: LD_VAR 0 4
116820: PUSH
116821: LD_VAR 0 7
116825: ARRAY
116826: PPUSH
116827: CALL 50604 0 1
116831: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
116832: LD_VAR 0 4
116836: PUSH
116837: LD_VAR 0 7
116841: ARRAY
116842: PPUSH
116843: LD_VAR 0 10
116847: PPUSH
116848: LD_VAR 0 11
116852: PPUSH
116853: LD_VAR 0 14
116857: PUSH
116858: LD_INT 1
116860: ARRAY
116861: PPUSH
116862: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
116866: LD_VAR 0 4
116870: PUSH
116871: LD_VAR 0 7
116875: ARRAY
116876: PPUSH
116877: LD_VAR 0 10
116881: PPUSH
116882: LD_VAR 0 12
116886: PPUSH
116887: LD_INT 7
116889: PPUSH
116890: CALL_OW 272
116894: PPUSH
116895: LD_VAR 0 11
116899: PPUSH
116900: LD_VAR 0 12
116904: PPUSH
116905: LD_INT 7
116907: PPUSH
116908: CALL_OW 273
116912: PPUSH
116913: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
116917: LD_VAR 0 4
116921: PUSH
116922: LD_VAR 0 7
116926: ARRAY
116927: PPUSH
116928: LD_INT 71
116930: PPUSH
116931: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
116935: LD_ADDR_VAR 0 27
116939: PUSH
116940: LD_VAR 0 27
116944: PPUSH
116945: LD_VAR 0 27
116949: PUSH
116950: LD_INT 1
116952: PLUS
116953: PPUSH
116954: LD_VAR 0 14
116958: PUSH
116959: LD_INT 1
116961: ARRAY
116962: PPUSH
116963: CALL_OW 1
116967: ST_TO_ADDR
// attacking := true ;
116968: LD_ADDR_VAR 0 29
116972: PUSH
116973: LD_INT 1
116975: ST_TO_ADDR
// continue ;
116976: GO 114791
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
116978: LD_VAR 0 4
116982: PUSH
116983: LD_VAR 0 7
116987: ARRAY
116988: PPUSH
116989: CALL_OW 257
116993: PUSH
116994: LD_INT 17
116996: EQUAL
116997: IFFALSE 117021
116999: PUSH
117000: LD_VAR 0 4
117004: PUSH
117005: LD_VAR 0 7
117009: ARRAY
117010: PPUSH
117011: CALL_OW 110
117015: PUSH
117016: LD_INT 71
117018: EQUAL
117019: NOT
117020: AND
117021: IFFALSE 117167
// begin attacking := false ;
117023: LD_ADDR_VAR 0 29
117027: PUSH
117028: LD_INT 0
117030: ST_TO_ADDR
// k := 5 ;
117031: LD_ADDR_VAR 0 9
117035: PUSH
117036: LD_INT 5
117038: ST_TO_ADDR
// if tmp < k then
117039: LD_VAR 0 14
117043: PUSH
117044: LD_VAR 0 9
117048: LESS
117049: IFFALSE 117061
// k := tmp ;
117051: LD_ADDR_VAR 0 9
117055: PUSH
117056: LD_VAR 0 14
117060: ST_TO_ADDR
// for j = 1 to k do
117061: LD_ADDR_VAR 0 8
117065: PUSH
117066: DOUBLE
117067: LD_INT 1
117069: DEC
117070: ST_TO_ADDR
117071: LD_VAR 0 9
117075: PUSH
117076: FOR_TO
117077: IFFALSE 117165
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
117079: LD_VAR 0 14
117083: PUSH
117084: LD_VAR 0 8
117088: ARRAY
117089: PUSH
117090: LD_VAR 0 14
117094: PPUSH
117095: LD_INT 58
117097: PUSH
117098: EMPTY
117099: LIST
117100: PPUSH
117101: CALL_OW 72
117105: IN
117106: NOT
117107: IFFALSE 117163
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117109: LD_VAR 0 4
117113: PUSH
117114: LD_VAR 0 7
117118: ARRAY
117119: PPUSH
117120: LD_VAR 0 14
117124: PUSH
117125: LD_VAR 0 8
117129: ARRAY
117130: PPUSH
117131: CALL_OW 115
// attacking := true ;
117135: LD_ADDR_VAR 0 29
117139: PUSH
117140: LD_INT 1
117142: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
117143: LD_VAR 0 4
117147: PUSH
117148: LD_VAR 0 7
117152: ARRAY
117153: PPUSH
117154: LD_INT 71
117156: PPUSH
117157: CALL_OW 109
// continue ;
117161: GO 117076
// end ; end ;
117163: GO 117076
117165: POP
117166: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
117167: LD_VAR 0 4
117171: PUSH
117172: LD_VAR 0 7
117176: ARRAY
117177: PPUSH
117178: CALL_OW 257
117182: PUSH
117183: LD_INT 8
117185: EQUAL
117186: IFTRUE 117224
117188: PUSH
117189: LD_VAR 0 4
117193: PUSH
117194: LD_VAR 0 7
117198: ARRAY
117199: PPUSH
117200: CALL_OW 264
117204: PUSH
117205: LD_INT 28
117207: PUSH
117208: LD_INT 45
117210: PUSH
117211: LD_INT 7
117213: PUSH
117214: LD_INT 47
117216: PUSH
117217: EMPTY
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: IN
117223: OR
117224: IFFALSE 117480
// begin attacking := false ;
117226: LD_ADDR_VAR 0 29
117230: PUSH
117231: LD_INT 0
117233: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
117234: LD_VAR 0 14
117238: PUSH
117239: LD_INT 1
117241: ARRAY
117242: PPUSH
117243: CALL_OW 266
117247: PUSH
117248: LD_INT 32
117250: PUSH
117251: LD_INT 31
117253: PUSH
117254: LD_INT 33
117256: PUSH
117257: LD_INT 4
117259: PUSH
117260: LD_INT 5
117262: PUSH
117263: EMPTY
117264: LIST
117265: LIST
117266: LIST
117267: LIST
117268: LIST
117269: IN
117270: IFFALSE 117456
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
117272: LD_ADDR_VAR 0 9
117276: PUSH
117277: LD_VAR 0 14
117281: PUSH
117282: LD_INT 1
117284: ARRAY
117285: PPUSH
117286: CALL_OW 266
117290: PPUSH
117291: LD_VAR 0 14
117295: PUSH
117296: LD_INT 1
117298: ARRAY
117299: PPUSH
117300: CALL_OW 250
117304: PPUSH
117305: LD_VAR 0 14
117309: PUSH
117310: LD_INT 1
117312: ARRAY
117313: PPUSH
117314: CALL_OW 251
117318: PPUSH
117319: LD_VAR 0 14
117323: PUSH
117324: LD_INT 1
117326: ARRAY
117327: PPUSH
117328: CALL_OW 254
117332: PPUSH
117333: LD_VAR 0 14
117337: PUSH
117338: LD_INT 1
117340: ARRAY
117341: PPUSH
117342: CALL_OW 248
117346: PPUSH
117347: LD_INT 0
117349: PPUSH
117350: CALL 31962 0 6
117354: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
117355: LD_ADDR_VAR 0 8
117359: PUSH
117360: LD_VAR 0 4
117364: PUSH
117365: LD_VAR 0 7
117369: ARRAY
117370: PPUSH
117371: LD_VAR 0 9
117375: PPUSH
117376: CALL 50717 0 2
117380: ST_TO_ADDR
// if j then
117381: LD_VAR 0 8
117385: IFFALSE 117454
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
117387: LD_VAR 0 8
117391: PUSH
117392: LD_INT 1
117394: ARRAY
117395: PPUSH
117396: LD_VAR 0 8
117400: PUSH
117401: LD_INT 2
117403: ARRAY
117404: PPUSH
117405: CALL_OW 488
117409: IFFALSE 117454
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
117411: LD_VAR 0 4
117415: PUSH
117416: LD_VAR 0 7
117420: ARRAY
117421: PPUSH
117422: LD_VAR 0 8
117426: PUSH
117427: LD_INT 1
117429: ARRAY
117430: PPUSH
117431: LD_VAR 0 8
117435: PUSH
117436: LD_INT 2
117438: ARRAY
117439: PPUSH
117440: CALL_OW 116
// attacking := true ;
117444: LD_ADDR_VAR 0 29
117448: PUSH
117449: LD_INT 1
117451: ST_TO_ADDR
// continue ;
117452: GO 114791
// end ; end else
117454: GO 117480
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117456: LD_VAR 0 4
117460: PUSH
117461: LD_VAR 0 7
117465: ARRAY
117466: PPUSH
117467: LD_VAR 0 14
117471: PUSH
117472: LD_INT 1
117474: ARRAY
117475: PPUSH
117476: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
117480: LD_VAR 0 4
117484: PUSH
117485: LD_VAR 0 7
117489: ARRAY
117490: PPUSH
117491: CALL_OW 265
117495: PUSH
117496: LD_INT 11
117498: EQUAL
117499: IFFALSE 117777
// begin k := 10 ;
117501: LD_ADDR_VAR 0 9
117505: PUSH
117506: LD_INT 10
117508: ST_TO_ADDR
// x := 0 ;
117509: LD_ADDR_VAR 0 10
117513: PUSH
117514: LD_INT 0
117516: ST_TO_ADDR
// if tmp < k then
117517: LD_VAR 0 14
117521: PUSH
117522: LD_VAR 0 9
117526: LESS
117527: IFFALSE 117539
// k := tmp ;
117529: LD_ADDR_VAR 0 9
117533: PUSH
117534: LD_VAR 0 14
117538: ST_TO_ADDR
// for j = k downto 1 do
117539: LD_ADDR_VAR 0 8
117543: PUSH
117544: DOUBLE
117545: LD_VAR 0 9
117549: INC
117550: ST_TO_ADDR
117551: LD_INT 1
117553: PUSH
117554: FOR_DOWNTO
117555: IFFALSE 117630
// begin if GetType ( tmp [ j ] ) = unit_human then
117557: LD_VAR 0 14
117561: PUSH
117562: LD_VAR 0 8
117566: ARRAY
117567: PPUSH
117568: CALL_OW 247
117572: PUSH
117573: LD_INT 1
117575: EQUAL
117576: IFFALSE 117628
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
117578: LD_VAR 0 4
117582: PUSH
117583: LD_VAR 0 7
117587: ARRAY
117588: PPUSH
117589: LD_VAR 0 14
117593: PUSH
117594: LD_VAR 0 8
117598: ARRAY
117599: PPUSH
117600: CALL 50975 0 2
// x := tmp [ j ] ;
117604: LD_ADDR_VAR 0 10
117608: PUSH
117609: LD_VAR 0 14
117613: PUSH
117614: LD_VAR 0 8
117618: ARRAY
117619: ST_TO_ADDR
// attacking := true ;
117620: LD_ADDR_VAR 0 29
117624: PUSH
117625: LD_INT 1
117627: ST_TO_ADDR
// end ; end ;
117628: GO 117554
117630: POP
117631: POP
// if not x then
117632: LD_VAR 0 10
117636: NOT
117637: IFFALSE 117777
// begin attacking := true ;
117639: LD_ADDR_VAR 0 29
117643: PUSH
117644: LD_INT 1
117646: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
117647: LD_VAR 0 4
117651: PUSH
117652: LD_VAR 0 7
117656: ARRAY
117657: PPUSH
117658: CALL_OW 250
117662: PPUSH
117663: LD_VAR 0 4
117667: PUSH
117668: LD_VAR 0 7
117672: ARRAY
117673: PPUSH
117674: CALL_OW 251
117678: PPUSH
117679: CALL_OW 546
117683: PUSH
117684: LD_INT 2
117686: ARRAY
117687: PUSH
117688: LD_VAR 0 14
117692: PUSH
117693: LD_INT 1
117695: ARRAY
117696: PPUSH
117697: CALL_OW 250
117701: PPUSH
117702: LD_VAR 0 14
117706: PUSH
117707: LD_INT 1
117709: ARRAY
117710: PPUSH
117711: CALL_OW 251
117715: PPUSH
117716: CALL_OW 546
117720: PUSH
117721: LD_INT 2
117723: ARRAY
117724: EQUAL
117725: IFFALSE 117753
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
117727: LD_VAR 0 4
117731: PUSH
117732: LD_VAR 0 7
117736: ARRAY
117737: PPUSH
117738: LD_VAR 0 14
117742: PUSH
117743: LD_INT 1
117745: ARRAY
117746: PPUSH
117747: CALL 50975 0 2
117751: GO 117777
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117753: LD_VAR 0 4
117757: PUSH
117758: LD_VAR 0 7
117762: ARRAY
117763: PPUSH
117764: LD_VAR 0 14
117768: PUSH
117769: LD_INT 1
117771: ARRAY
117772: PPUSH
117773: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
117777: LD_VAR 0 4
117781: PUSH
117782: LD_VAR 0 7
117786: ARRAY
117787: PPUSH
117788: CALL_OW 264
117792: PUSH
117793: LD_INT 29
117795: EQUAL
117796: IFFALSE 118166
// begin if WantsToAttack ( group [ i ] ) in bombed then
117798: LD_VAR 0 4
117802: PUSH
117803: LD_VAR 0 7
117807: ARRAY
117808: PPUSH
117809: CALL_OW 319
117813: PUSH
117814: LD_VAR 0 28
117818: IN
117819: IFFALSE 117823
// continue ;
117821: GO 114791
// k := 8 ;
117823: LD_ADDR_VAR 0 9
117827: PUSH
117828: LD_INT 8
117830: ST_TO_ADDR
// x := 0 ;
117831: LD_ADDR_VAR 0 10
117835: PUSH
117836: LD_INT 0
117838: ST_TO_ADDR
// if tmp < k then
117839: LD_VAR 0 14
117843: PUSH
117844: LD_VAR 0 9
117848: LESS
117849: IFFALSE 117861
// k := tmp ;
117851: LD_ADDR_VAR 0 9
117855: PUSH
117856: LD_VAR 0 14
117860: ST_TO_ADDR
// for j = 1 to k do
117861: LD_ADDR_VAR 0 8
117865: PUSH
117866: DOUBLE
117867: LD_INT 1
117869: DEC
117870: ST_TO_ADDR
117871: LD_VAR 0 9
117875: PUSH
117876: FOR_TO
117877: IFFALSE 118011
// begin if GetType ( tmp [ j ] ) = unit_building then
117879: LD_VAR 0 14
117883: PUSH
117884: LD_VAR 0 8
117888: ARRAY
117889: PPUSH
117890: CALL_OW 247
117894: PUSH
117895: LD_INT 3
117897: EQUAL
117898: IFFALSE 118009
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
117900: LD_VAR 0 14
117904: PUSH
117905: LD_VAR 0 8
117909: ARRAY
117910: PUSH
117911: LD_VAR 0 28
117915: IN
117916: NOT
117917: IFFALSE 117936
117919: PUSH
117920: LD_VAR 0 14
117924: PUSH
117925: LD_VAR 0 8
117929: ARRAY
117930: PPUSH
117931: CALL_OW 313
117935: AND
117936: IFFALSE 118009
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
117938: LD_VAR 0 4
117942: PUSH
117943: LD_VAR 0 7
117947: ARRAY
117948: PPUSH
117949: LD_VAR 0 14
117953: PUSH
117954: LD_VAR 0 8
117958: ARRAY
117959: PPUSH
117960: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
117964: LD_ADDR_VAR 0 28
117968: PUSH
117969: LD_VAR 0 28
117973: PPUSH
117974: LD_VAR 0 28
117978: PUSH
117979: LD_INT 1
117981: PLUS
117982: PPUSH
117983: LD_VAR 0 14
117987: PUSH
117988: LD_VAR 0 8
117992: ARRAY
117993: PPUSH
117994: CALL_OW 1
117998: ST_TO_ADDR
// attacking := true ;
117999: LD_ADDR_VAR 0 29
118003: PUSH
118004: LD_INT 1
118006: ST_TO_ADDR
// break ;
118007: GO 118011
// end ; end ;
118009: GO 117876
118011: POP
118012: POP
// if not attacking and f_attack_depot then
118013: LD_VAR 0 29
118017: NOT
118018: IFFALSE 118026
118020: PUSH
118021: LD_VAR 0 25
118025: AND
118026: IFFALSE 118121
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118028: LD_ADDR_VAR 0 13
118032: PUSH
118033: LD_VAR 0 14
118037: PPUSH
118038: LD_INT 2
118040: PUSH
118041: LD_INT 30
118043: PUSH
118044: LD_INT 0
118046: PUSH
118047: EMPTY
118048: LIST
118049: LIST
118050: PUSH
118051: LD_INT 30
118053: PUSH
118054: LD_INT 1
118056: PUSH
118057: EMPTY
118058: LIST
118059: LIST
118060: PUSH
118061: EMPTY
118062: LIST
118063: LIST
118064: LIST
118065: PPUSH
118066: CALL_OW 72
118070: ST_TO_ADDR
// if z then
118071: LD_VAR 0 13
118075: IFFALSE 118121
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
118077: LD_VAR 0 4
118081: PUSH
118082: LD_VAR 0 7
118086: ARRAY
118087: PPUSH
118088: LD_VAR 0 13
118092: PPUSH
118093: LD_VAR 0 4
118097: PUSH
118098: LD_VAR 0 7
118102: ARRAY
118103: PPUSH
118104: CALL_OW 74
118108: PPUSH
118109: CALL_OW 115
// attacking := true ;
118113: LD_ADDR_VAR 0 29
118117: PUSH
118118: LD_INT 1
118120: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
118121: LD_VAR 0 4
118125: PUSH
118126: LD_VAR 0 7
118130: ARRAY
118131: PPUSH
118132: CALL_OW 256
118136: PUSH
118137: LD_INT 500
118139: LESS
118140: IFFALSE 118166
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118142: LD_VAR 0 4
118146: PUSH
118147: LD_VAR 0 7
118151: ARRAY
118152: PPUSH
118153: LD_VAR 0 14
118157: PUSH
118158: LD_INT 1
118160: ARRAY
118161: PPUSH
118162: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
118166: LD_VAR 0 4
118170: PUSH
118171: LD_VAR 0 7
118175: ARRAY
118176: PPUSH
118177: CALL_OW 264
118181: PUSH
118182: LD_INT 49
118184: EQUAL
118185: IFFALSE 118306
// begin if not HasTask ( group [ i ] ) then
118187: LD_VAR 0 4
118191: PUSH
118192: LD_VAR 0 7
118196: ARRAY
118197: PPUSH
118198: CALL_OW 314
118202: NOT
118203: IFFALSE 118306
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
118205: LD_ADDR_VAR 0 9
118209: PUSH
118210: LD_INT 81
118212: PUSH
118213: LD_VAR 0 4
118217: PUSH
118218: LD_VAR 0 7
118222: ARRAY
118223: PPUSH
118224: CALL_OW 255
118228: PUSH
118229: EMPTY
118230: LIST
118231: LIST
118232: PPUSH
118233: CALL_OW 69
118237: PPUSH
118238: LD_VAR 0 4
118242: PUSH
118243: LD_VAR 0 7
118247: ARRAY
118248: PPUSH
118249: CALL_OW 74
118253: ST_TO_ADDR
// if k then
118254: LD_VAR 0 9
118258: IFFALSE 118306
// if GetDistUnits ( group [ i ] , k ) > 10 then
118260: LD_VAR 0 4
118264: PUSH
118265: LD_VAR 0 7
118269: ARRAY
118270: PPUSH
118271: LD_VAR 0 9
118275: PPUSH
118276: CALL_OW 296
118280: PUSH
118281: LD_INT 10
118283: GREATER
118284: IFFALSE 118306
// ComMoveUnit ( group [ i ] , k ) ;
118286: LD_VAR 0 4
118290: PUSH
118291: LD_VAR 0 7
118295: ARRAY
118296: PPUSH
118297: LD_VAR 0 9
118301: PPUSH
118302: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
118306: LD_VAR 0 4
118310: PUSH
118311: LD_VAR 0 7
118315: ARRAY
118316: PPUSH
118317: CALL_OW 256
118321: PUSH
118322: LD_INT 250
118324: LESS
118325: IFFALSE 118369
118327: PUSH
118328: LD_VAR 0 4
118332: PUSH
118333: LD_VAR 0 7
118337: ARRAY
118338: PUSH
118339: LD_INT 21
118341: PUSH
118342: LD_INT 2
118344: PUSH
118345: EMPTY
118346: LIST
118347: LIST
118348: PUSH
118349: LD_INT 23
118351: PUSH
118352: LD_INT 2
118354: PUSH
118355: EMPTY
118356: LIST
118357: LIST
118358: PUSH
118359: EMPTY
118360: LIST
118361: LIST
118362: PPUSH
118363: CALL_OW 69
118367: IN
118368: AND
118369: IFFALSE 118496
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
118371: LD_ADDR_VAR 0 9
118375: PUSH
118376: LD_OWVAR 3
118380: PUSH
118381: LD_VAR 0 4
118385: PUSH
118386: LD_VAR 0 7
118390: ARRAY
118391: DIFF
118392: PPUSH
118393: LD_VAR 0 4
118397: PUSH
118398: LD_VAR 0 7
118402: ARRAY
118403: PPUSH
118404: CALL_OW 74
118408: ST_TO_ADDR
// if not k then
118409: LD_VAR 0 9
118413: NOT
118414: IFFALSE 118418
// continue ;
118416: GO 114791
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
118418: LD_VAR 0 9
118422: PUSH
118423: LD_INT 81
118425: PUSH
118426: LD_VAR 0 4
118430: PUSH
118431: LD_VAR 0 7
118435: ARRAY
118436: PPUSH
118437: CALL_OW 255
118441: PUSH
118442: EMPTY
118443: LIST
118444: LIST
118445: PPUSH
118446: CALL_OW 69
118450: IN
118451: IFFALSE 118479
118453: PUSH
118454: LD_VAR 0 9
118458: PPUSH
118459: LD_VAR 0 4
118463: PUSH
118464: LD_VAR 0 7
118468: ARRAY
118469: PPUSH
118470: CALL_OW 296
118474: PUSH
118475: LD_INT 5
118477: LESS
118478: AND
118479: IFFALSE 118496
// ComAutodestruct ( group [ i ] ) ;
118481: LD_VAR 0 4
118485: PUSH
118486: LD_VAR 0 7
118490: ARRAY
118491: PPUSH
118492: CALL 50871 0 1
// end ; if f_attack_depot then
118496: LD_VAR 0 25
118500: IFFALSE 118612
// begin k := 6 ;
118502: LD_ADDR_VAR 0 9
118506: PUSH
118507: LD_INT 6
118509: ST_TO_ADDR
// if tmp < k then
118510: LD_VAR 0 14
118514: PUSH
118515: LD_VAR 0 9
118519: LESS
118520: IFFALSE 118532
// k := tmp ;
118522: LD_ADDR_VAR 0 9
118526: PUSH
118527: LD_VAR 0 14
118531: ST_TO_ADDR
// for j = 1 to k do
118532: LD_ADDR_VAR 0 8
118536: PUSH
118537: DOUBLE
118538: LD_INT 1
118540: DEC
118541: ST_TO_ADDR
118542: LD_VAR 0 9
118546: PUSH
118547: FOR_TO
118548: IFFALSE 118610
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
118550: LD_VAR 0 8
118554: PPUSH
118555: CALL_OW 266
118559: PUSH
118560: LD_INT 0
118562: PUSH
118563: LD_INT 1
118565: PUSH
118566: EMPTY
118567: LIST
118568: LIST
118569: IN
118570: IFFALSE 118608
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
118572: LD_VAR 0 4
118576: PUSH
118577: LD_VAR 0 7
118581: ARRAY
118582: PPUSH
118583: LD_VAR 0 14
118587: PUSH
118588: LD_VAR 0 8
118592: ARRAY
118593: PPUSH
118594: CALL_OW 115
// attacking := true ;
118598: LD_ADDR_VAR 0 29
118602: PUSH
118603: LD_INT 1
118605: ST_TO_ADDR
// break ;
118606: GO 118610
// end ;
118608: GO 118547
118610: POP
118611: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
118612: LD_VAR 0 4
118616: PUSH
118617: LD_VAR 0 7
118621: ARRAY
118622: PPUSH
118623: CALL_OW 302
118627: IFFALSE 118636
118629: PUSH
118630: LD_VAR 0 29
118634: NOT
118635: AND
118636: IFFALSE 118966
// begin if GetTag ( group [ i ] ) = 71 then
118638: LD_VAR 0 4
118642: PUSH
118643: LD_VAR 0 7
118647: ARRAY
118648: PPUSH
118649: CALL_OW 110
118653: PUSH
118654: LD_INT 71
118656: EQUAL
118657: IFFALSE 118698
// begin if HasTask ( group [ i ] ) then
118659: LD_VAR 0 4
118663: PUSH
118664: LD_VAR 0 7
118668: ARRAY
118669: PPUSH
118670: CALL_OW 314
118674: IFFALSE 118680
// continue else
118676: GO 114791
118678: GO 118698
// SetTag ( group [ i ] , 0 ) ;
118680: LD_VAR 0 4
118684: PUSH
118685: LD_VAR 0 7
118689: ARRAY
118690: PPUSH
118691: LD_INT 0
118693: PPUSH
118694: CALL_OW 109
// end ; k := 8 ;
118698: LD_ADDR_VAR 0 9
118702: PUSH
118703: LD_INT 8
118705: ST_TO_ADDR
// x := 0 ;
118706: LD_ADDR_VAR 0 10
118710: PUSH
118711: LD_INT 0
118713: ST_TO_ADDR
// if tmp < k then
118714: LD_VAR 0 14
118718: PUSH
118719: LD_VAR 0 9
118723: LESS
118724: IFFALSE 118736
// k := tmp ;
118726: LD_ADDR_VAR 0 9
118730: PUSH
118731: LD_VAR 0 14
118735: ST_TO_ADDR
// for j = 1 to k do
118736: LD_ADDR_VAR 0 8
118740: PUSH
118741: DOUBLE
118742: LD_INT 1
118744: DEC
118745: ST_TO_ADDR
118746: LD_VAR 0 9
118750: PUSH
118751: FOR_TO
118752: IFFALSE 118858
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
118754: LD_VAR 0 14
118758: PUSH
118759: LD_VAR 0 8
118763: ARRAY
118764: PPUSH
118765: CALL_OW 247
118769: PUSH
118770: LD_INT 1
118772: EQUAL
118773: IFFALSE 118836
118775: PUSH
118776: LD_VAR 0 14
118780: PUSH
118781: LD_VAR 0 8
118785: ARRAY
118786: PPUSH
118787: CALL_OW 256
118791: PUSH
118792: LD_INT 250
118794: LESS
118795: IFFALSE 118803
118797: PUSH
118798: LD_VAR 0 20
118802: AND
118803: IFTRUE 118835
118805: PUSH
118806: LD_VAR 0 20
118810: NOT
118811: IFFALSE 118834
118813: PUSH
118814: LD_VAR 0 14
118818: PUSH
118819: LD_VAR 0 8
118823: ARRAY
118824: PPUSH
118825: CALL_OW 256
118829: PUSH
118830: LD_INT 250
118832: GREATEREQUAL
118833: AND
118834: OR
118835: AND
118836: IFFALSE 118856
// begin x := tmp [ j ] ;
118838: LD_ADDR_VAR 0 10
118842: PUSH
118843: LD_VAR 0 14
118847: PUSH
118848: LD_VAR 0 8
118852: ARRAY
118853: ST_TO_ADDR
// break ;
118854: GO 118858
// end ;
118856: GO 118751
118858: POP
118859: POP
// if x then
118860: LD_VAR 0 10
118864: IFFALSE 118888
// ComAttackUnit ( group [ i ] , x ) else
118866: LD_VAR 0 4
118870: PUSH
118871: LD_VAR 0 7
118875: ARRAY
118876: PPUSH
118877: LD_VAR 0 10
118881: PPUSH
118882: CALL_OW 115
118886: GO 118912
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
118888: LD_VAR 0 4
118892: PUSH
118893: LD_VAR 0 7
118897: ARRAY
118898: PPUSH
118899: LD_VAR 0 14
118903: PUSH
118904: LD_INT 1
118906: ARRAY
118907: PPUSH
118908: CALL_OW 115
// if not HasTask ( group [ i ] ) then
118912: LD_VAR 0 4
118916: PUSH
118917: LD_VAR 0 7
118921: ARRAY
118922: PPUSH
118923: CALL_OW 314
118927: NOT
118928: IFFALSE 118966
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
118930: LD_VAR 0 4
118934: PUSH
118935: LD_VAR 0 7
118939: ARRAY
118940: PPUSH
118941: LD_VAR 0 14
118945: PPUSH
118946: LD_VAR 0 4
118950: PUSH
118951: LD_VAR 0 7
118955: ARRAY
118956: PPUSH
118957: CALL_OW 74
118961: PPUSH
118962: CALL_OW 115
// end ; end ; end ;
118966: GO 114791
118968: POP
118969: POP
// wait ( 0 0$2 ) ;
118970: LD_INT 70
118972: PPUSH
118973: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
118977: LD_VAR 0 4
118981: NOT
118982: IFTRUE 118993
118984: PUSH
118985: LD_VAR 0 4
118989: PUSH
118990: EMPTY
118991: EQUAL
118992: OR
118993: IFTRUE 119014
118995: PUSH
118996: LD_INT 81
118998: PUSH
118999: LD_VAR 0 35
119003: PUSH
119004: EMPTY
119005: LIST
119006: LIST
119007: PPUSH
119008: CALL_OW 69
119012: NOT
119013: OR
119014: IFFALSE 114776
// end ;
119016: LD_VAR 0 2
119020: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
119021: LD_INT 0
119023: PPUSH
119024: PPUSH
119025: PPUSH
119026: PPUSH
119027: PPUSH
119028: PPUSH
// if not base or not mc_bases [ base ] or not solds then
119029: LD_VAR 0 1
119033: NOT
119034: IFTRUE 119049
119036: PUSH
119037: LD_EXP 63
119041: PUSH
119042: LD_VAR 0 1
119046: ARRAY
119047: NOT
119048: OR
119049: IFTRUE 119058
119051: PUSH
119052: LD_VAR 0 2
119056: NOT
119057: OR
119058: IFFALSE 119062
// exit ;
119060: GO 119620
// side := mc_sides [ base ] ;
119062: LD_ADDR_VAR 0 6
119066: PUSH
119067: LD_EXP 89
119071: PUSH
119072: LD_VAR 0 1
119076: ARRAY
119077: ST_TO_ADDR
// if not side then
119078: LD_VAR 0 6
119082: NOT
119083: IFFALSE 119087
// exit ;
119085: GO 119620
// for i in solds do
119087: LD_ADDR_VAR 0 7
119091: PUSH
119092: LD_VAR 0 2
119096: PUSH
119097: FOR_IN
119098: IFFALSE 119159
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
119100: LD_VAR 0 7
119104: PPUSH
119105: CALL_OW 310
119109: PPUSH
119110: CALL_OW 266
119114: PUSH
119115: LD_INT 32
119117: PUSH
119118: LD_INT 31
119120: PUSH
119121: EMPTY
119122: LIST
119123: LIST
119124: IN
119125: IFFALSE 119145
// solds := solds diff i else
119127: LD_ADDR_VAR 0 2
119131: PUSH
119132: LD_VAR 0 2
119136: PUSH
119137: LD_VAR 0 7
119141: DIFF
119142: ST_TO_ADDR
119143: GO 119157
// SetTag ( i , 18 ) ;
119145: LD_VAR 0 7
119149: PPUSH
119150: LD_INT 18
119152: PPUSH
119153: CALL_OW 109
119157: GO 119097
119159: POP
119160: POP
// if not solds then
119161: LD_VAR 0 2
119165: NOT
119166: IFFALSE 119170
// exit ;
119168: GO 119620
// repeat wait ( 0 0$2 ) ;
119170: LD_INT 70
119172: PPUSH
119173: CALL_OW 67
// enemy := mc_scan [ base ] ;
119177: LD_ADDR_VAR 0 4
119181: PUSH
119182: LD_EXP 86
119186: PUSH
119187: LD_VAR 0 1
119191: ARRAY
119192: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119193: LD_EXP 63
119197: PUSH
119198: LD_VAR 0 1
119202: ARRAY
119203: NOT
119204: IFTRUE 119221
119206: PUSH
119207: LD_EXP 63
119211: PUSH
119212: LD_VAR 0 1
119216: ARRAY
119217: PUSH
119218: EMPTY
119219: EQUAL
119220: OR
119221: IFFALSE 119258
// begin for i in solds do
119223: LD_ADDR_VAR 0 7
119227: PUSH
119228: LD_VAR 0 2
119232: PUSH
119233: FOR_IN
119234: IFFALSE 119247
// ComStop ( i ) ;
119236: LD_VAR 0 7
119240: PPUSH
119241: CALL_OW 141
119245: GO 119233
119247: POP
119248: POP
// solds := [ ] ;
119249: LD_ADDR_VAR 0 2
119253: PUSH
119254: EMPTY
119255: ST_TO_ADDR
// exit ;
119256: GO 119620
// end ; for i in solds do
119258: LD_ADDR_VAR 0 7
119262: PUSH
119263: LD_VAR 0 2
119267: PUSH
119268: FOR_IN
119269: IFFALSE 119590
// begin if IsInUnit ( i ) then
119271: LD_VAR 0 7
119275: PPUSH
119276: CALL_OW 310
119280: IFFALSE 119291
// ComExitBuilding ( i ) ;
119282: LD_VAR 0 7
119286: PPUSH
119287: CALL_OW 122
// if GetLives ( i ) > 500 then
119291: LD_VAR 0 7
119295: PPUSH
119296: CALL_OW 256
119300: PUSH
119301: LD_INT 500
119303: GREATER
119304: IFFALSE 119357
// begin e := NearestUnitToUnit ( enemy , i ) ;
119306: LD_ADDR_VAR 0 5
119310: PUSH
119311: LD_VAR 0 4
119315: PPUSH
119316: LD_VAR 0 7
119320: PPUSH
119321: CALL_OW 74
119325: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
119326: LD_VAR 0 7
119330: PPUSH
119331: LD_VAR 0 5
119335: PPUSH
119336: CALL_OW 250
119340: PPUSH
119341: LD_VAR 0 5
119345: PPUSH
119346: CALL_OW 251
119350: PPUSH
119351: CALL_OW 114
// end else
119355: GO 119588
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
119357: LD_VAR 0 7
119361: PPUSH
119362: LD_EXP 63
119366: PUSH
119367: LD_VAR 0 1
119371: ARRAY
119372: PPUSH
119373: LD_INT 2
119375: PUSH
119376: LD_INT 30
119378: PUSH
119379: LD_INT 0
119381: PUSH
119382: EMPTY
119383: LIST
119384: LIST
119385: PUSH
119386: LD_INT 30
119388: PUSH
119389: LD_INT 1
119391: PUSH
119392: EMPTY
119393: LIST
119394: LIST
119395: PUSH
119396: LD_INT 30
119398: PUSH
119399: LD_INT 6
119401: PUSH
119402: EMPTY
119403: LIST
119404: LIST
119405: PUSH
119406: EMPTY
119407: LIST
119408: LIST
119409: LIST
119410: LIST
119411: PPUSH
119412: CALL_OW 72
119416: PPUSH
119417: LD_VAR 0 7
119421: PPUSH
119422: CALL_OW 74
119426: PPUSH
119427: CALL_OW 296
119431: PUSH
119432: LD_INT 10
119434: GREATER
119435: IFFALSE 119588
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
119437: LD_ADDR_VAR 0 8
119441: PUSH
119442: LD_EXP 63
119446: PUSH
119447: LD_VAR 0 1
119451: ARRAY
119452: PPUSH
119453: LD_INT 2
119455: PUSH
119456: LD_INT 30
119458: PUSH
119459: LD_INT 0
119461: PUSH
119462: EMPTY
119463: LIST
119464: LIST
119465: PUSH
119466: LD_INT 30
119468: PUSH
119469: LD_INT 1
119471: PUSH
119472: EMPTY
119473: LIST
119474: LIST
119475: PUSH
119476: LD_INT 30
119478: PUSH
119479: LD_INT 6
119481: PUSH
119482: EMPTY
119483: LIST
119484: LIST
119485: PUSH
119486: EMPTY
119487: LIST
119488: LIST
119489: LIST
119490: LIST
119491: PPUSH
119492: CALL_OW 72
119496: PPUSH
119497: LD_VAR 0 7
119501: PPUSH
119502: CALL_OW 74
119506: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
119507: LD_VAR 0 7
119511: PPUSH
119512: LD_VAR 0 8
119516: PPUSH
119517: CALL_OW 250
119521: PPUSH
119522: LD_INT 3
119524: PPUSH
119525: LD_INT 5
119527: PPUSH
119528: CALL_OW 272
119532: PPUSH
119533: LD_VAR 0 8
119537: PPUSH
119538: CALL_OW 251
119542: PPUSH
119543: LD_INT 3
119545: PPUSH
119546: LD_INT 5
119548: PPUSH
119549: CALL_OW 273
119553: PPUSH
119554: CALL_OW 111
// SetTag ( i , 0 ) ;
119558: LD_VAR 0 7
119562: PPUSH
119563: LD_INT 0
119565: PPUSH
119566: CALL_OW 109
// solds := solds diff i ;
119570: LD_ADDR_VAR 0 2
119574: PUSH
119575: LD_VAR 0 2
119579: PUSH
119580: LD_VAR 0 7
119584: DIFF
119585: ST_TO_ADDR
// continue ;
119586: GO 119268
// end ; end ;
119588: GO 119268
119590: POP
119591: POP
// until not solds or not enemy ;
119592: LD_VAR 0 2
119596: NOT
119597: IFTRUE 119606
119599: PUSH
119600: LD_VAR 0 4
119604: NOT
119605: OR
119606: IFFALSE 119170
// MC_Reset ( base , 18 ) ;
119608: LD_VAR 0 1
119612: PPUSH
119613: LD_INT 18
119615: PPUSH
119616: CALL 65077 0 2
// end ;
119620: LD_VAR 0 3
119624: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
119625: LD_INT 0
119627: PPUSH
119628: PPUSH
119629: PPUSH
119630: PPUSH
119631: PPUSH
119632: PPUSH
119633: PPUSH
119634: PPUSH
119635: PPUSH
119636: PPUSH
119637: PPUSH
119638: PPUSH
119639: PPUSH
119640: PPUSH
119641: PPUSH
119642: PPUSH
119643: PPUSH
119644: PPUSH
119645: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
119646: LD_ADDR_VAR 0 12
119650: PUSH
119651: LD_EXP 63
119655: PUSH
119656: LD_VAR 0 1
119660: ARRAY
119661: PPUSH
119662: LD_INT 25
119664: PUSH
119665: LD_INT 3
119667: PUSH
119668: EMPTY
119669: LIST
119670: LIST
119671: PPUSH
119672: CALL_OW 72
119676: ST_TO_ADDR
// if mc_remote_driver [ base ] then
119677: LD_EXP 103
119681: PUSH
119682: LD_VAR 0 1
119686: ARRAY
119687: IFFALSE 119711
// mechs := mechs diff mc_remote_driver [ base ] ;
119689: LD_ADDR_VAR 0 12
119693: PUSH
119694: LD_VAR 0 12
119698: PUSH
119699: LD_EXP 103
119703: PUSH
119704: LD_VAR 0 1
119708: ARRAY
119709: DIFF
119710: ST_TO_ADDR
// for i in mechs do
119711: LD_ADDR_VAR 0 4
119715: PUSH
119716: LD_VAR 0 12
119720: PUSH
119721: FOR_IN
119722: IFFALSE 119757
// if GetTag ( i ) > 0 then
119724: LD_VAR 0 4
119728: PPUSH
119729: CALL_OW 110
119733: PUSH
119734: LD_INT 0
119736: GREATER
119737: IFFALSE 119755
// mechs := mechs diff i ;
119739: LD_ADDR_VAR 0 12
119743: PUSH
119744: LD_VAR 0 12
119748: PUSH
119749: LD_VAR 0 4
119753: DIFF
119754: ST_TO_ADDR
119755: GO 119721
119757: POP
119758: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119759: LD_ADDR_VAR 0 8
119763: PUSH
119764: LD_EXP 63
119768: PUSH
119769: LD_VAR 0 1
119773: ARRAY
119774: PPUSH
119775: LD_INT 2
119777: PUSH
119778: LD_INT 25
119780: PUSH
119781: LD_INT 1
119783: PUSH
119784: EMPTY
119785: LIST
119786: LIST
119787: PUSH
119788: LD_INT 25
119790: PUSH
119791: LD_INT 5
119793: PUSH
119794: EMPTY
119795: LIST
119796: LIST
119797: PUSH
119798: LD_INT 25
119800: PUSH
119801: LD_INT 8
119803: PUSH
119804: EMPTY
119805: LIST
119806: LIST
119807: PUSH
119808: LD_INT 25
119810: PUSH
119811: LD_INT 9
119813: PUSH
119814: EMPTY
119815: LIST
119816: LIST
119817: PUSH
119818: EMPTY
119819: LIST
119820: LIST
119821: LIST
119822: LIST
119823: LIST
119824: PPUSH
119825: CALL_OW 72
119829: ST_TO_ADDR
// if not defenders and not solds then
119830: LD_VAR 0 2
119834: NOT
119835: IFFALSE 119844
119837: PUSH
119838: LD_VAR 0 8
119842: NOT
119843: AND
119844: IFFALSE 119848
// exit ;
119846: GO 121670
// depot_under_attack := false ;
119848: LD_ADDR_VAR 0 16
119852: PUSH
119853: LD_INT 0
119855: ST_TO_ADDR
// sold_defenders := [ ] ;
119856: LD_ADDR_VAR 0 17
119860: PUSH
119861: EMPTY
119862: ST_TO_ADDR
// if mechs then
119863: LD_VAR 0 12
119867: IFFALSE 120022
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
119869: LD_ADDR_VAR 0 4
119873: PUSH
119874: LD_VAR 0 2
119878: PPUSH
119879: LD_INT 21
119881: PUSH
119882: LD_INT 2
119884: PUSH
119885: EMPTY
119886: LIST
119887: LIST
119888: PPUSH
119889: CALL_OW 72
119893: PUSH
119894: FOR_IN
119895: IFFALSE 120020
// begin if GetTag ( i ) <> 20 then
119897: LD_VAR 0 4
119901: PPUSH
119902: CALL_OW 110
119906: PUSH
119907: LD_INT 20
119909: NONEQUAL
119910: IFFALSE 119924
// SetTag ( i , 20 ) ;
119912: LD_VAR 0 4
119916: PPUSH
119917: LD_INT 20
119919: PPUSH
119920: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
119924: LD_VAR 0 4
119928: PPUSH
119929: CALL_OW 263
119933: PUSH
119934: LD_INT 1
119936: EQUAL
119937: IFFALSE 119951
119939: PUSH
119940: LD_VAR 0 4
119944: PPUSH
119945: CALL_OW 311
119949: NOT
119950: AND
119951: IFFALSE 120018
// begin un := mechs [ 1 ] ;
119953: LD_ADDR_VAR 0 10
119957: PUSH
119958: LD_VAR 0 12
119962: PUSH
119963: LD_INT 1
119965: ARRAY
119966: ST_TO_ADDR
// ComExit ( un ) ;
119967: LD_VAR 0 10
119971: PPUSH
119972: CALL 55952 0 1
// AddComEnterUnit ( un , i ) ;
119976: LD_VAR 0 10
119980: PPUSH
119981: LD_VAR 0 4
119985: PPUSH
119986: CALL_OW 180
// SetTag ( un , 19 ) ;
119990: LD_VAR 0 10
119994: PPUSH
119995: LD_INT 19
119997: PPUSH
119998: CALL_OW 109
// mechs := mechs diff un ;
120002: LD_ADDR_VAR 0 12
120006: PUSH
120007: LD_VAR 0 12
120011: PUSH
120012: LD_VAR 0 10
120016: DIFF
120017: ST_TO_ADDR
// end ; end ;
120018: GO 119894
120020: POP
120021: POP
// if solds then
120022: LD_VAR 0 8
120026: IFFALSE 120085
// for i in solds do
120028: LD_ADDR_VAR 0 4
120032: PUSH
120033: LD_VAR 0 8
120037: PUSH
120038: FOR_IN
120039: IFFALSE 120083
// if not GetTag ( i ) then
120041: LD_VAR 0 4
120045: PPUSH
120046: CALL_OW 110
120050: NOT
120051: IFFALSE 120081
// begin defenders := defenders union i ;
120053: LD_ADDR_VAR 0 2
120057: PUSH
120058: LD_VAR 0 2
120062: PUSH
120063: LD_VAR 0 4
120067: UNION
120068: ST_TO_ADDR
// SetTag ( i , 18 ) ;
120069: LD_VAR 0 4
120073: PPUSH
120074: LD_INT 18
120076: PPUSH
120077: CALL_OW 109
// end ;
120081: GO 120038
120083: POP
120084: POP
// repeat wait ( 0 0$2 ) ;
120085: LD_INT 70
120087: PPUSH
120088: CALL_OW 67
// enemy := mc_scan [ base ] ;
120092: LD_ADDR_VAR 0 21
120096: PUSH
120097: LD_EXP 86
120101: PUSH
120102: LD_VAR 0 1
120106: ARRAY
120107: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
120108: LD_EXP 63
120112: PUSH
120113: LD_VAR 0 1
120117: ARRAY
120118: NOT
120119: IFTRUE 120136
120121: PUSH
120122: LD_EXP 63
120126: PUSH
120127: LD_VAR 0 1
120131: ARRAY
120132: PUSH
120133: EMPTY
120134: EQUAL
120135: OR
120136: IFFALSE 120173
// begin for i in defenders do
120138: LD_ADDR_VAR 0 4
120142: PUSH
120143: LD_VAR 0 2
120147: PUSH
120148: FOR_IN
120149: IFFALSE 120162
// ComStop ( i ) ;
120151: LD_VAR 0 4
120155: PPUSH
120156: CALL_OW 141
120160: GO 120148
120162: POP
120163: POP
// defenders := [ ] ;
120164: LD_ADDR_VAR 0 2
120168: PUSH
120169: EMPTY
120170: ST_TO_ADDR
// exit ;
120171: GO 121670
// end ; for i in defenders do
120173: LD_ADDR_VAR 0 4
120177: PUSH
120178: LD_VAR 0 2
120182: PUSH
120183: FOR_IN
120184: IFFALSE 121118
// begin e := NearestUnitToUnit ( enemy , i ) ;
120186: LD_ADDR_VAR 0 13
120190: PUSH
120191: LD_VAR 0 21
120195: PPUSH
120196: LD_VAR 0 4
120200: PPUSH
120201: CALL_OW 74
120205: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
120206: LD_ADDR_VAR 0 7
120210: PUSH
120211: LD_EXP 63
120215: PUSH
120216: LD_VAR 0 1
120220: ARRAY
120221: PPUSH
120222: LD_INT 2
120224: PUSH
120225: LD_INT 30
120227: PUSH
120228: LD_INT 0
120230: PUSH
120231: EMPTY
120232: LIST
120233: LIST
120234: PUSH
120235: LD_INT 30
120237: PUSH
120238: LD_INT 1
120240: PUSH
120241: EMPTY
120242: LIST
120243: LIST
120244: PUSH
120245: EMPTY
120246: LIST
120247: LIST
120248: LIST
120249: PPUSH
120250: CALL_OW 72
120254: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
120255: LD_ADDR_VAR 0 16
120259: PUSH
120260: LD_VAR 0 7
120264: NOT
120265: IFTRUE 120295
120267: PUSH
120268: LD_VAR 0 7
120272: PPUSH
120273: LD_INT 3
120275: PUSH
120276: LD_INT 24
120278: PUSH
120279: LD_INT 600
120281: PUSH
120282: EMPTY
120283: LIST
120284: LIST
120285: PUSH
120286: EMPTY
120287: LIST
120288: LIST
120289: PPUSH
120290: CALL_OW 72
120294: OR
120295: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
120296: LD_VAR 0 4
120300: PPUSH
120301: CALL_OW 247
120305: PUSH
120306: LD_INT 2
120308: DOUBLE
120309: EQUAL
120310: IFTRUE 120314
120312: GO 120730
120314: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
120315: LD_VAR 0 4
120319: PPUSH
120320: CALL_OW 256
120324: PUSH
120325: LD_INT 1000
120327: EQUAL
120328: IFFALSE 120374
120330: PUSH
120331: LD_VAR 0 4
120335: PPUSH
120336: LD_VAR 0 13
120340: PPUSH
120341: CALL_OW 296
120345: PUSH
120346: LD_INT 40
120348: LESS
120349: IFTRUE 120373
120351: PUSH
120352: LD_VAR 0 13
120356: PPUSH
120357: LD_EXP 88
120361: PUSH
120362: LD_VAR 0 1
120366: ARRAY
120367: PPUSH
120368: CALL_OW 308
120372: OR
120373: AND
120374: IFFALSE 120500
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
120376: LD_VAR 0 4
120380: PPUSH
120381: CALL_OW 262
120385: PUSH
120386: LD_INT 1
120388: EQUAL
120389: IFFALSE 120406
120391: PUSH
120392: LD_VAR 0 4
120396: PPUSH
120397: CALL_OW 261
120401: PUSH
120402: LD_INT 30
120404: LESS
120405: AND
120406: IFFALSE 120414
120408: PUSH
120409: LD_VAR 0 7
120413: AND
120414: IFFALSE 120484
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
120416: LD_VAR 0 4
120420: PPUSH
120421: LD_VAR 0 7
120425: PPUSH
120426: LD_VAR 0 4
120430: PPUSH
120431: CALL_OW 74
120435: PPUSH
120436: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
120440: LD_VAR 0 4
120444: PPUSH
120445: LD_VAR 0 7
120449: PPUSH
120450: LD_VAR 0 4
120454: PPUSH
120455: CALL_OW 74
120459: PPUSH
120460: CALL_OW 296
120464: PUSH
120465: LD_INT 6
120467: LESS
120468: IFFALSE 120482
// SetFuel ( i , 100 ) ;
120470: LD_VAR 0 4
120474: PPUSH
120475: LD_INT 100
120477: PPUSH
120478: CALL_OW 240
// end else
120482: GO 120498
// ComAttackUnit ( i , e ) ;
120484: LD_VAR 0 4
120488: PPUSH
120489: LD_VAR 0 13
120493: PPUSH
120494: CALL_OW 115
// end else
120498: GO 120607
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
120500: LD_VAR 0 13
120504: PPUSH
120505: LD_EXP 88
120509: PUSH
120510: LD_VAR 0 1
120514: ARRAY
120515: PPUSH
120516: CALL_OW 308
120520: NOT
120521: IFFALSE 120543
120523: PUSH
120524: LD_VAR 0 4
120528: PPUSH
120529: LD_VAR 0 13
120533: PPUSH
120534: CALL_OW 296
120538: PUSH
120539: LD_INT 40
120541: GREATEREQUAL
120542: AND
120543: IFTRUE 120560
120545: PUSH
120546: LD_VAR 0 4
120550: PPUSH
120551: CALL_OW 256
120555: PUSH
120556: LD_INT 650
120558: LESSEQUAL
120559: OR
120560: IFFALSE 120585
120562: PUSH
120563: LD_VAR 0 4
120567: PPUSH
120568: LD_EXP 87
120572: PUSH
120573: LD_VAR 0 1
120577: ARRAY
120578: PPUSH
120579: CALL_OW 308
120583: NOT
120584: AND
120585: IFFALSE 120607
// ComMoveToArea ( i , mc_parking [ base ] ) ;
120587: LD_VAR 0 4
120591: PPUSH
120592: LD_EXP 87
120596: PUSH
120597: LD_VAR 0 1
120601: ARRAY
120602: PPUSH
120603: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
120607: LD_VAR 0 4
120611: PPUSH
120612: CALL_OW 256
120616: PUSH
120617: LD_INT 1000
120619: LESS
120620: IFFALSE 120637
120622: PUSH
120623: LD_VAR 0 4
120627: PPUSH
120628: CALL_OW 263
120632: PUSH
120633: LD_INT 1
120635: EQUAL
120636: AND
120637: IFFALSE 120650
120639: PUSH
120640: LD_VAR 0 4
120644: PPUSH
120645: CALL_OW 311
120649: AND
120650: IFFALSE 120674
120652: PUSH
120653: LD_VAR 0 4
120657: PPUSH
120658: LD_EXP 87
120662: PUSH
120663: LD_VAR 0 1
120667: ARRAY
120668: PPUSH
120669: CALL_OW 308
120673: AND
120674: IFFALSE 120728
// begin mech := IsDrivenBy ( i ) ;
120676: LD_ADDR_VAR 0 9
120680: PUSH
120681: LD_VAR 0 4
120685: PPUSH
120686: CALL_OW 311
120690: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
120691: LD_VAR 0 9
120695: PPUSH
120696: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
120700: LD_VAR 0 9
120704: PPUSH
120705: LD_VAR 0 4
120709: PPUSH
120710: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
120714: LD_VAR 0 9
120718: PPUSH
120719: LD_VAR 0 4
120723: PPUSH
120724: CALL_OW 180
// end ; end ; unit_human :
120728: GO 121089
120730: LD_INT 1
120732: DOUBLE
120733: EQUAL
120734: IFTRUE 120738
120736: GO 121088
120738: POP
// begin b := IsInUnit ( i ) ;
120739: LD_ADDR_VAR 0 18
120743: PUSH
120744: LD_VAR 0 4
120748: PPUSH
120749: CALL_OW 310
120753: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
120754: LD_ADDR_VAR 0 19
120758: PUSH
120759: LD_VAR 0 18
120763: NOT
120764: IFTRUE 120788
120766: PUSH
120767: LD_VAR 0 18
120771: PPUSH
120772: CALL_OW 266
120776: PUSH
120777: LD_INT 32
120779: PUSH
120780: LD_INT 31
120782: PUSH
120783: EMPTY
120784: LIST
120785: LIST
120786: IN
120787: OR
120788: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
120789: LD_VAR 0 18
120793: PPUSH
120794: CALL_OW 266
120798: PUSH
120799: LD_INT 5
120801: EQUAL
120802: IFFALSE 120834
120804: PUSH
120805: LD_VAR 0 4
120809: PPUSH
120810: CALL_OW 257
120814: PUSH
120815: LD_INT 1
120817: PUSH
120818: LD_INT 2
120820: PUSH
120821: LD_INT 3
120823: PUSH
120824: LD_INT 4
120826: PUSH
120827: EMPTY
120828: LIST
120829: LIST
120830: LIST
120831: LIST
120832: IN
120833: AND
120834: IFFALSE 120871
// begin class := AllowSpecClass ( i ) ;
120836: LD_ADDR_VAR 0 20
120840: PUSH
120841: LD_VAR 0 4
120845: PPUSH
120846: CALL 19306 0 1
120850: ST_TO_ADDR
// if class then
120851: LD_VAR 0 20
120855: IFFALSE 120871
// ComChangeProfession ( i , class ) ;
120857: LD_VAR 0 4
120861: PPUSH
120862: LD_VAR 0 20
120866: PPUSH
120867: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
120871: LD_VAR 0 16
120875: IFTRUE 120902
120877: PUSH
120878: LD_VAR 0 2
120882: PPUSH
120883: LD_INT 21
120885: PUSH
120886: LD_INT 2
120888: PUSH
120889: EMPTY
120890: LIST
120891: LIST
120892: PPUSH
120893: CALL_OW 72
120897: PUSH
120898: LD_INT 1
120900: LESSEQUAL
120901: OR
120902: IFFALSE 120910
120904: PUSH
120905: LD_VAR 0 19
120909: AND
120910: IFFALSE 120925
120912: PUSH
120913: LD_VAR 0 4
120917: PUSH
120918: LD_VAR 0 17
120922: IN
120923: NOT
120924: AND
120925: IFFALSE 121020
// begin if b then
120927: LD_VAR 0 18
120931: IFFALSE 120982
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
120933: LD_VAR 0 18
120937: PPUSH
120938: LD_VAR 0 21
120942: PPUSH
120943: LD_VAR 0 18
120947: PPUSH
120948: CALL_OW 74
120952: PPUSH
120953: CALL_OW 296
120957: PUSH
120958: LD_INT 10
120960: LESS
120961: IFFALSE 120978
120963: PUSH
120964: LD_VAR 0 18
120968: PPUSH
120969: CALL_OW 461
120973: PUSH
120974: LD_INT 7
120976: NONEQUAL
120977: AND
120978: IFFALSE 120982
// continue ;
120980: GO 120183
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
120982: LD_ADDR_VAR 0 17
120986: PUSH
120987: LD_VAR 0 17
120991: PPUSH
120992: LD_VAR 0 17
120996: PUSH
120997: LD_INT 1
120999: PLUS
121000: PPUSH
121001: LD_VAR 0 4
121005: PPUSH
121006: CALL_OW 1
121010: ST_TO_ADDR
// ComExitBuilding ( i ) ;
121011: LD_VAR 0 4
121015: PPUSH
121016: CALL_OW 122
// end ; if sold_defenders then
121020: LD_VAR 0 17
121024: IFFALSE 121086
// if i in sold_defenders then
121026: LD_VAR 0 4
121030: PUSH
121031: LD_VAR 0 17
121035: IN
121036: IFFALSE 121086
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
121038: LD_VAR 0 4
121042: PPUSH
121043: CALL_OW 314
121047: NOT
121048: IFFALSE 121070
121050: PUSH
121051: LD_VAR 0 4
121055: PPUSH
121056: LD_VAR 0 13
121060: PPUSH
121061: CALL_OW 296
121065: PUSH
121066: LD_INT 30
121068: LESS
121069: AND
121070: IFFALSE 121086
// ComAttackUnit ( i , e ) ;
121072: LD_VAR 0 4
121076: PPUSH
121077: LD_VAR 0 13
121081: PPUSH
121082: CALL_OW 115
// end ; end ; end ;
121086: GO 121089
121088: POP
// if IsDead ( i ) then
121089: LD_VAR 0 4
121093: PPUSH
121094: CALL_OW 301
121098: IFFALSE 121116
// defenders := defenders diff i ;
121100: LD_ADDR_VAR 0 2
121104: PUSH
121105: LD_VAR 0 2
121109: PUSH
121110: LD_VAR 0 4
121114: DIFF
121115: ST_TO_ADDR
// end ;
121116: GO 120183
121118: POP
121119: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
121120: LD_VAR 0 21
121124: NOT
121125: IFTRUE 121134
121127: PUSH
121128: LD_VAR 0 2
121132: NOT
121133: OR
121134: IFTRUE 121149
121136: PUSH
121137: LD_EXP 63
121141: PUSH
121142: LD_VAR 0 1
121146: ARRAY
121147: NOT
121148: OR
121149: IFFALSE 120085
// MC_Reset ( base , 18 ) ;
121151: LD_VAR 0 1
121155: PPUSH
121156: LD_INT 18
121158: PPUSH
121159: CALL 65077 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
121163: LD_ADDR_VAR 0 2
121167: PUSH
121168: LD_VAR 0 2
121172: PUSH
121173: LD_VAR 0 2
121177: PPUSH
121178: LD_INT 2
121180: PUSH
121181: LD_INT 25
121183: PUSH
121184: LD_INT 1
121186: PUSH
121187: EMPTY
121188: LIST
121189: LIST
121190: PUSH
121191: LD_INT 25
121193: PUSH
121194: LD_INT 5
121196: PUSH
121197: EMPTY
121198: LIST
121199: LIST
121200: PUSH
121201: LD_INT 25
121203: PUSH
121204: LD_INT 8
121206: PUSH
121207: EMPTY
121208: LIST
121209: LIST
121210: PUSH
121211: LD_INT 25
121213: PUSH
121214: LD_INT 9
121216: PUSH
121217: EMPTY
121218: LIST
121219: LIST
121220: PUSH
121221: EMPTY
121222: LIST
121223: LIST
121224: LIST
121225: LIST
121226: LIST
121227: PPUSH
121228: CALL_OW 72
121232: DIFF
121233: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
121234: LD_VAR 0 21
121238: NOT
121239: IFFALSE 121262
121241: PUSH
121242: LD_VAR 0 2
121246: PPUSH
121247: LD_INT 21
121249: PUSH
121250: LD_INT 2
121252: PUSH
121253: EMPTY
121254: LIST
121255: LIST
121256: PPUSH
121257: CALL_OW 72
121261: AND
121262: IFFALSE 121606
// begin tmp := FilterByTag ( defenders , 19 ) ;
121264: LD_ADDR_VAR 0 11
121268: PUSH
121269: LD_VAR 0 2
121273: PPUSH
121274: LD_INT 19
121276: PPUSH
121277: CALL 53099 0 2
121281: ST_TO_ADDR
// if tmp then
121282: LD_VAR 0 11
121286: IFFALSE 121356
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
121288: LD_ADDR_VAR 0 11
121292: PUSH
121293: LD_VAR 0 11
121297: PPUSH
121298: LD_INT 25
121300: PUSH
121301: LD_INT 3
121303: PUSH
121304: EMPTY
121305: LIST
121306: LIST
121307: PPUSH
121308: CALL_OW 72
121312: ST_TO_ADDR
// if tmp then
121313: LD_VAR 0 11
121317: IFFALSE 121356
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
121319: LD_ADDR_EXP 75
121323: PUSH
121324: LD_EXP 75
121328: PPUSH
121329: LD_VAR 0 1
121333: PPUSH
121334: LD_EXP 75
121338: PUSH
121339: LD_VAR 0 1
121343: ARRAY
121344: PUSH
121345: LD_VAR 0 11
121349: UNION
121350: PPUSH
121351: CALL_OW 1
121355: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
121356: LD_VAR 0 1
121360: PPUSH
121361: LD_INT 19
121363: PPUSH
121364: CALL 65077 0 2
// repeat wait ( 0 0$1 ) ;
121368: LD_INT 35
121370: PPUSH
121371: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
121375: LD_EXP 63
121379: PUSH
121380: LD_VAR 0 1
121384: ARRAY
121385: NOT
121386: IFTRUE 121403
121388: PUSH
121389: LD_EXP 63
121393: PUSH
121394: LD_VAR 0 1
121398: ARRAY
121399: PUSH
121400: EMPTY
121401: EQUAL
121402: OR
121403: IFFALSE 121440
// begin for i in defenders do
121405: LD_ADDR_VAR 0 4
121409: PUSH
121410: LD_VAR 0 2
121414: PUSH
121415: FOR_IN
121416: IFFALSE 121429
// ComStop ( i ) ;
121418: LD_VAR 0 4
121422: PPUSH
121423: CALL_OW 141
121427: GO 121415
121429: POP
121430: POP
// defenders := [ ] ;
121431: LD_ADDR_VAR 0 2
121435: PUSH
121436: EMPTY
121437: ST_TO_ADDR
// exit ;
121438: GO 121670
// end ; for i in defenders do
121440: LD_ADDR_VAR 0 4
121444: PUSH
121445: LD_VAR 0 2
121449: PUSH
121450: FOR_IN
121451: IFFALSE 121540
// begin if not IsInArea ( i , mc_parking [ base ] ) then
121453: LD_VAR 0 4
121457: PPUSH
121458: LD_EXP 87
121462: PUSH
121463: LD_VAR 0 1
121467: ARRAY
121468: PPUSH
121469: CALL_OW 308
121473: NOT
121474: IFFALSE 121498
// ComMoveToArea ( i , mc_parking [ base ] ) else
121476: LD_VAR 0 4
121480: PPUSH
121481: LD_EXP 87
121485: PUSH
121486: LD_VAR 0 1
121490: ARRAY
121491: PPUSH
121492: CALL_OW 113
121496: GO 121538
// if GetControl ( i ) = control_manual then
121498: LD_VAR 0 4
121502: PPUSH
121503: CALL_OW 263
121507: PUSH
121508: LD_INT 1
121510: EQUAL
121511: IFFALSE 121538
// if IsDrivenBy ( i ) then
121513: LD_VAR 0 4
121517: PPUSH
121518: CALL_OW 311
121522: IFFALSE 121538
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
121524: LD_VAR 0 4
121528: PPUSH
121529: CALL_OW 311
121533: PPUSH
121534: CALL_OW 121
// end ;
121538: GO 121450
121540: POP
121541: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
121542: LD_VAR 0 2
121546: PPUSH
121547: LD_INT 95
121549: PUSH
121550: LD_EXP 87
121554: PUSH
121555: LD_VAR 0 1
121559: ARRAY
121560: PUSH
121561: EMPTY
121562: LIST
121563: LIST
121564: PPUSH
121565: CALL_OW 72
121569: PUSH
121570: LD_VAR 0 2
121574: EQUAL
121575: IFTRUE 121589
121577: PUSH
121578: LD_EXP 86
121582: PUSH
121583: LD_VAR 0 1
121587: ARRAY
121588: OR
121589: IFTRUE 121604
121591: PUSH
121592: LD_EXP 63
121596: PUSH
121597: LD_VAR 0 1
121601: ARRAY
121602: NOT
121603: OR
121604: IFFALSE 121368
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
121606: LD_ADDR_EXP 85
121610: PUSH
121611: LD_EXP 85
121615: PPUSH
121616: LD_VAR 0 1
121620: PPUSH
121621: LD_VAR 0 2
121625: PPUSH
121626: LD_INT 21
121628: PUSH
121629: LD_INT 2
121631: PUSH
121632: EMPTY
121633: LIST
121634: LIST
121635: PPUSH
121636: CALL_OW 72
121640: PPUSH
121641: CALL_OW 1
121645: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
121646: LD_VAR 0 1
121650: PPUSH
121651: LD_INT 19
121653: PPUSH
121654: CALL 65077 0 2
// MC_Reset ( base , 20 ) ;
121658: LD_VAR 0 1
121662: PPUSH
121663: LD_INT 20
121665: PPUSH
121666: CALL 65077 0 2
// end ; end_of_file
121670: LD_VAR 0 3
121674: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
121675: LD_VAR 0 1
121679: PUSH
121680: LD_INT 200
121682: DOUBLE
121683: GREATEREQUAL
121684: IFFALSE 121692
121686: LD_INT 299
121688: DOUBLE
121689: LESSEQUAL
121690: IFTRUE 121694
121692: GO 121726
121694: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
121695: LD_VAR 0 1
121699: PPUSH
121700: LD_VAR 0 2
121704: PPUSH
121705: LD_VAR 0 3
121709: PPUSH
121710: LD_VAR 0 4
121714: PPUSH
121715: LD_VAR 0 5
121719: PPUSH
121720: CALL 108718 0 5
121724: GO 121803
121726: LD_INT 300
121728: DOUBLE
121729: GREATEREQUAL
121730: IFFALSE 121738
121732: LD_INT 399
121734: DOUBLE
121735: LESSEQUAL
121736: IFTRUE 121740
121738: GO 121802
121740: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
121741: LD_VAR 0 1
121745: PPUSH
121746: LD_VAR 0 2
121750: PPUSH
121751: LD_VAR 0 3
121755: PPUSH
121756: LD_VAR 0 4
121760: PPUSH
121761: LD_VAR 0 5
121765: PPUSH
121766: LD_VAR 0 6
121770: PPUSH
121771: LD_VAR 0 7
121775: PPUSH
121776: LD_VAR 0 8
121780: PPUSH
121781: LD_VAR 0 9
121785: PPUSH
121786: LD_VAR 0 10
121790: PPUSH
121791: LD_VAR 0 11
121795: PPUSH
121796: CALL 104602 0 11
121800: GO 121803
121802: POP
// end ;
121803: PPOPN 11
121805: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
121806: LD_VAR 0 1
121810: PPUSH
121811: LD_VAR 0 2
121815: PPUSH
121816: LD_VAR 0 3
121820: PPUSH
121821: LD_VAR 0 4
121825: PPUSH
121826: LD_VAR 0 5
121830: PPUSH
121831: CALL 108099 0 5
// end ; end_of_file
121835: PPOPN 5
121837: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
121838: LD_VAR 0 1
121842: PPUSH
121843: LD_VAR 0 2
121847: PPUSH
121848: LD_VAR 0 3
121852: PPUSH
121853: LD_VAR 0 4
121857: PPUSH
121858: LD_VAR 0 5
121862: PPUSH
121863: LD_VAR 0 6
121867: PPUSH
121868: CALL 92142 0 6
// end ;
121872: PPOPN 6
121874: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
121875: LD_INT 0
121877: PPUSH
// begin if not units then
121878: LD_VAR 0 1
121882: NOT
121883: IFFALSE 121887
// exit ;
121885: GO 121921
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
121887: LD_VAR 0 1
121891: PPUSH
121892: LD_VAR 0 2
121896: PPUSH
121897: LD_VAR 0 3
121901: PPUSH
121902: LD_VAR 0 4
121906: PPUSH
121907: LD_VAR 0 5
121911: PPUSH
121912: LD_VAR 0 6
121916: PPUSH
121917: CALL 114225 0 6
// end ;
121921: PPOPN 7
121923: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
121924: CALL 92029 0 0
// end ;
121928: PPOPN 1
121930: END
