// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 84996 0 0
// InitMacro ;
  23: CALL 54370 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48178 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48178 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48178 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48178 0 9
// PrepareArabian ;
 172: CALL 3964 0 0
// PrepareRussian ;
 176: CALL 2935 0 0
// PrepareAlliance ;
 180: CALL 900 0 0
// MC_Start ( ) ;
 184: CALL 56535 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7326 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 84
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 85
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 78224 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 55
 281: PPUSH
 282: CALL 78650 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 79108 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 79377 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 110
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 78590 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 79284 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 52
 390: PPUSH
 391: CALL 78650 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 79108 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 79377 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 78434 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 79695 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 78590 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 53
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 11
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// masha_killed := false ;
 779: LD_ADDR_EXP 10
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// abdul_escaped := true ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 1
 794: ST_TO_ADDR
// loss_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// hack_counter := 0 ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_INT 0
 810: ST_TO_ADDR
// end ;
 811: LD_VAR 0 1
 815: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 816: LD_EXP 49
 820: PPUSH
 821: CALL_OW 255
 825: PUSH
 826: LD_INT 7
 828: EQUAL
 829: PUSH
 830: LD_EXP 48
 834: PPUSH
 835: CALL_OW 255
 839: PUSH
 840: LD_INT 7
 842: EQUAL
 843: AND
 844: PUSH
 845: LD_EXP 49
 849: PPUSH
 850: CALL_OW 302
 854: AND
 855: PUSH
 856: LD_EXP 48
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: IFFALSE 878
 868: GO 870
 870: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 871: LD_STRING ACH_COMRADE
 873: PPUSH
 874: CALL_OW 543
 878: END
// every 0 0$1 trigger hack_counter >= 10 do
 879: LD_EXP 15
 883: PUSH
 884: LD_INT 10
 886: GREATEREQUAL
 887: IFFALSE 899
 889: GO 891
 891: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 892: LD_STRING ACH_HACK
 894: PPUSH
 895: CALL_OW 543
 899: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 900: LD_INT 0
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
// uc_side := 7 ;
 906: LD_ADDR_OWVAR 20
 910: PUSH
 911: LD_INT 7
 913: ST_TO_ADDR
// uc_nation := 1 ;
 914: LD_ADDR_OWVAR 21
 918: PUSH
 919: LD_INT 1
 921: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 922: LD_ADDR_EXP 16
 926: PUSH
 927: LD_STRING JMM
 929: PPUSH
 930: LD_EXP 1
 934: NOT
 935: PPUSH
 936: LD_STRING 12a_
 938: PPUSH
 939: CALL 14815 0 3
 943: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 944: LD_EXP 16
 948: PPUSH
 949: LD_INT 71
 951: PPUSH
 952: LD_INT 23
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 962: LD_EXP 16
 966: PPUSH
 967: LD_INT 2
 969: PPUSH
 970: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 974: LD_ADDR_EXP 17
 978: PUSH
 979: LD_STRING Roth
 981: PPUSH
 982: LD_EXP 1
 986: NOT
 987: PPUSH
 988: LD_STRING 12a_
 990: PPUSH
 991: CALL 14815 0 3
 995: ST_TO_ADDR
// if Roth then
 996: LD_EXP 17
1000: IFFALSE 1020
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1002: LD_EXP 17
1006: PPUSH
1007: LD_INT 71
1009: PPUSH
1010: LD_INT 21
1012: PPUSH
1013: LD_INT 0
1015: PPUSH
1016: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1020: LD_ADDR_EXP 18
1024: PUSH
1025: LD_STRING Lisa
1027: PPUSH
1028: LD_EXP 1
1032: NOT
1033: PPUSH
1034: LD_STRING 12a_
1036: PPUSH
1037: CALL 14815 0 3
1041: ST_TO_ADDR
// if Lisa then
1042: LD_EXP 18
1046: IFFALSE 1063
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1048: LD_EXP 18
1052: PPUSH
1053: LD_INT 13
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1063: LD_ADDR_EXP 19
1067: PUSH
1068: LD_STRING Donaldson
1070: PPUSH
1071: LD_EXP 1
1075: NOT
1076: PPUSH
1077: LD_STRING 12a_
1079: PPUSH
1080: CALL 14815 0 3
1084: ST_TO_ADDR
// if Donaldson then
1085: LD_EXP 19
1089: IFFALSE 1106
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1091: LD_EXP 19
1095: PPUSH
1096: LD_INT 13
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1106: LD_ADDR_EXP 20
1110: PUSH
1111: LD_STRING Bobby
1113: PPUSH
1114: LD_EXP 1
1118: NOT
1119: PPUSH
1120: LD_STRING 12a_
1122: PPUSH
1123: CALL 14815 0 3
1127: ST_TO_ADDR
// if Bobby then
1128: LD_EXP 20
1132: IFFALSE 1149
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1134: LD_EXP 20
1138: PPUSH
1139: LD_INT 13
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1149: LD_ADDR_EXP 21
1153: PUSH
1154: LD_STRING Cyrus
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_STRING 12a_
1165: PPUSH
1166: CALL 14815 0 3
1170: ST_TO_ADDR
// if Cyrus then
1171: LD_EXP 21
1175: IFFALSE 1192
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1177: LD_EXP 21
1181: PPUSH
1182: LD_INT 13
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1192: LD_ADDR_EXP 22
1196: PUSH
1197: LD_STRING Denis
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: LD_STRING 12a_
1208: PPUSH
1209: CALL 14815 0 3
1213: ST_TO_ADDR
// if Denis then
1214: LD_EXP 22
1218: IFFALSE 1235
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1220: LD_EXP 22
1224: PPUSH
1225: LD_INT 13
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1235: LD_ADDR_EXP 23
1239: PUSH
1240: LD_STRING Brown
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: LD_STRING 12a_
1251: PPUSH
1252: CALL 14815 0 3
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 23
1261: IFFALSE 1278
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1263: LD_EXP 23
1267: PPUSH
1268: LD_INT 13
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1278: LD_ADDR_EXP 24
1282: PUSH
1283: LD_STRING Gladstone
1285: PPUSH
1286: LD_EXP 1
1290: NOT
1291: PPUSH
1292: LD_STRING 12a_
1294: PPUSH
1295: CALL 14815 0 3
1299: ST_TO_ADDR
// if Gladstone then
1300: LD_EXP 24
1304: IFFALSE 1321
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1306: LD_EXP 24
1310: PPUSH
1311: LD_INT 13
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1321: LD_ADDR_EXP 25
1325: PUSH
1326: LD_STRING Houten
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_STRING 12a_
1337: PPUSH
1338: CALL 14815 0 3
1342: ST_TO_ADDR
// if Houten then
1343: LD_EXP 25
1347: IFFALSE 1364
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1349: LD_EXP 25
1353: PPUSH
1354: LD_INT 13
1356: PPUSH
1357: LD_INT 0
1359: PPUSH
1360: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1364: LD_ADDR_EXP 26
1368: PUSH
1369: LD_STRING Cornell
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: LD_STRING 12a_
1380: PPUSH
1381: CALL 14815 0 3
1385: ST_TO_ADDR
// if Cornel then
1386: LD_EXP 26
1390: IFFALSE 1407
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1392: LD_EXP 26
1396: PPUSH
1397: LD_INT 13
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1407: LD_ADDR_EXP 27
1411: PUSH
1412: LD_STRING Gary
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: LD_STRING 12a_
1423: PPUSH
1424: CALL 14815 0 3
1428: ST_TO_ADDR
// if Gary then
1429: LD_EXP 27
1433: IFFALSE 1450
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1435: LD_EXP 27
1439: PPUSH
1440: LD_INT 13
1442: PPUSH
1443: LD_INT 0
1445: PPUSH
1446: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1450: LD_ADDR_EXP 28
1454: PUSH
1455: LD_STRING Frank
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: LD_STRING 12a_
1466: PPUSH
1467: CALL 14815 0 3
1471: ST_TO_ADDR
// if Frank then
1472: LD_EXP 28
1476: IFFALSE 1493
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1478: LD_EXP 28
1482: PPUSH
1483: LD_INT 13
1485: PPUSH
1486: LD_INT 0
1488: PPUSH
1489: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1493: LD_ADDR_EXP 29
1497: PUSH
1498: LD_STRING Kikuchi
1500: PPUSH
1501: LD_EXP 1
1505: NOT
1506: PPUSH
1507: LD_STRING 12a_
1509: PPUSH
1510: CALL 14815 0 3
1514: ST_TO_ADDR
// if Kikuchi then
1515: LD_EXP 29
1519: IFFALSE 1536
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1521: LD_EXP 29
1525: PPUSH
1526: LD_INT 13
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1536: LD_ADDR_EXP 30
1540: PUSH
1541: LD_STRING Simms
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 12a_
1552: PPUSH
1553: CALL 14815 0 3
1557: ST_TO_ADDR
// if Simms then
1558: LD_EXP 30
1562: IFFALSE 1579
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1564: LD_EXP 30
1568: PPUSH
1569: LD_INT 13
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1579: LD_ADDR_EXP 31
1583: PUSH
1584: LD_STRING Joan
1586: PPUSH
1587: LD_EXP 1
1591: NOT
1592: PPUSH
1593: LD_STRING 12a_
1595: PPUSH
1596: CALL 14815 0 3
1600: ST_TO_ADDR
// if Joan then
1601: LD_EXP 31
1605: IFFALSE 1622
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1607: LD_EXP 31
1611: PPUSH
1612: LD_INT 13
1614: PPUSH
1615: LD_INT 0
1617: PPUSH
1618: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING DeltaDoctor
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 12a_
1638: PPUSH
1639: CALL 14815 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 32
1648: IFFALSE 1665
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1650: LD_EXP 32
1654: PPUSH
1655: LD_INT 13
1657: PPUSH
1658: LD_INT 0
1660: PPUSH
1661: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_STRING 12a_others
1672: PPUSH
1673: CALL_OW 31
1677: ST_TO_ADDR
// if tmp then
1678: LD_VAR 0 4
1682: IFFALSE 1716
// for i in tmp do
1684: LD_ADDR_VAR 0 3
1688: PUSH
1689: LD_VAR 0 4
1693: PUSH
1694: FOR_IN
1695: IFFALSE 1714
// PlaceUnitArea ( i , alliance_start , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 13
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
1712: GO 1694
1714: POP
1715: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 3
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 19679 0 5
// veh := CreateVehicle ;
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: CALL_OW 45
1744: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1745: LD_VAR 0 2
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1757: LD_VAR 0 2
1761: PPUSH
1762: LD_INT 60
1764: PPUSH
1765: LD_INT 6
1767: PPUSH
1768: LD_INT 0
1770: PPUSH
1771: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1775: LD_VAR 0 2
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 30
1785: PPUSH
1786: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1790: LD_STRING 11_artifact_captured
1792: PPUSH
1793: LD_INT 0
1795: PPUSH
1796: CALL_OW 30
1800: IFFALSE 1876
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 3
1807: PPUSH
1808: LD_INT 3
1810: PPUSH
1811: LD_INT 12
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 19679 0 5
// veh := CreateVehicle ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: CALL_OW 45
1830: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1831: LD_VAR 0 2
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 75
1850: PPUSH
1851: LD_INT 6
1853: PPUSH
1854: LD_INT 0
1856: PPUSH
1857: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1861: LD_VAR 0 2
1865: PPUSH
1866: LD_INT 4
1868: PPUSH
1869: LD_INT 50
1871: PPUSH
1872: CALL_OW 290
// end ; end ;
1876: LD_VAR 0 1
1880: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1881: LD_INT 0
1883: PPUSH
1884: PPUSH
1885: PPUSH
1886: PPUSH
// uc_side := 6 ;
1887: LD_ADDR_OWVAR 20
1891: PUSH
1892: LD_INT 6
1894: ST_TO_ADDR
// uc_nation := 3 ;
1895: LD_ADDR_OWVAR 21
1899: PUSH
1900: LD_INT 3
1902: ST_TO_ADDR
// InitHc ;
1903: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1907: LD_ADDR_EXP 33
1911: PUSH
1912: LD_STRING Gossudarov
1914: PPUSH
1915: CALL_OW 25
1919: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1920: LD_ADDR_EXP 34
1924: PUSH
1925: LD_STRING Kirilenkova
1927: PPUSH
1928: CALL_OW 25
1932: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1933: LD_ADDR_EXP 35
1937: PUSH
1938: LD_STRING Titov
1940: PPUSH
1941: CALL_OW 25
1945: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1946: LD_ADDR_EXP 40
1950: PUSH
1951: LD_STRING Oblukov
1953: PPUSH
1954: CALL_OW 25
1958: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1959: LD_ADDR_EXP 37
1963: PUSH
1964: LD_STRING Dolgov
1966: PPUSH
1967: CALL_OW 25
1971: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1972: LD_ADDR_EXP 38
1976: PUSH
1977: LD_STRING Petrosyan
1979: PPUSH
1980: CALL_OW 25
1984: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1985: LD_ADDR_EXP 39
1989: PUSH
1990: LD_STRING Scholtze
1992: PPUSH
1993: CALL_OW 25
1997: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1998: LD_ADDR_EXP 41
2002: PUSH
2003: LD_STRING Kapitsova
2005: PPUSH
2006: CALL_OW 25
2010: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2011: LD_ADDR_VAR 0 2
2015: PUSH
2016: LD_EXP 33
2020: PUSH
2021: LD_EXP 34
2025: PUSH
2026: LD_EXP 35
2030: PUSH
2031: LD_EXP 40
2035: PUSH
2036: LD_EXP 37
2040: PUSH
2041: LD_EXP 38
2045: PUSH
2046: LD_EXP 39
2050: PUSH
2051: LD_EXP 41
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2066: LD_INT 1
2068: PPUSH
2069: LD_INT 4
2071: PPUSH
2072: LD_INT 8
2074: PPUSH
2075: CALL_OW 380
// un := CreateHuman ;
2079: LD_ADDR_VAR 0 4
2083: PUSH
2084: CALL_OW 44
2088: ST_TO_ADDR
// tmp := tmp ^ un ;
2089: LD_ADDR_VAR 0 2
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: LD_VAR 0 4
2103: ADD
2104: ST_TO_ADDR
// for i in tmp do
2105: LD_ADDR_VAR 0 3
2109: PUSH
2110: LD_VAR 0 2
2114: PUSH
2115: FOR_IN
2116: IFFALSE 2135
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2118: LD_VAR 0 3
2122: PPUSH
2123: LD_INT 14
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: CALL_OW 49
2133: GO 2115
2135: POP
2136: POP
// if freedom then
2137: LD_EXP 3
2141: IFFALSE 2174
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2143: LD_VAR 0 2
2147: PPUSH
2148: LD_EXP 3
2152: PPUSH
2153: CALL_OW 250
2157: PPUSH
2158: LD_EXP 3
2162: PPUSH
2163: CALL_OW 251
2167: PPUSH
2168: CALL_OW 111
2172: GO 2189
// ComMoveXY ( tmp , 70 , 48 ) ;
2174: LD_VAR 0 2
2178: PPUSH
2179: LD_INT 70
2181: PPUSH
2182: LD_INT 48
2184: PPUSH
2185: CALL_OW 111
// end ;
2189: LD_VAR 0 1
2193: RET
// export function PrepareBelkov ; begin
2194: LD_INT 0
2196: PPUSH
// uc_side := 4 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 4
2204: ST_TO_ADDR
// uc_nation := 3 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 3
2212: ST_TO_ADDR
// InitHc ;
2213: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2217: LD_ADDR_EXP 48
2221: PUSH
2222: LD_STRING Belkov
2224: PPUSH
2225: CALL_OW 25
2229: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2230: LD_EXP 48
2234: PPUSH
2235: LD_INT 14
2237: PPUSH
2238: LD_INT 0
2240: PPUSH
2241: CALL_OW 49
// end ;
2245: LD_VAR 0 1
2249: RET
// export function PrepareGnyevko ; begin
2250: LD_INT 0
2252: PPUSH
// uc_side := 4 ;
2253: LD_ADDR_OWVAR 20
2257: PUSH
2258: LD_INT 4
2260: ST_TO_ADDR
// uc_nation := 3 ;
2261: LD_ADDR_OWVAR 21
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// InitHc ;
2269: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2273: LD_ADDR_EXP 49
2277: PUSH
2278: LD_STRING Gnyevko
2280: PPUSH
2281: CALL_OW 25
2285: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2286: LD_EXP 49
2290: PPUSH
2291: LD_INT 14
2293: PPUSH
2294: LD_INT 0
2296: PPUSH
2297: CALL_OW 49
// end ;
2301: LD_VAR 0 1
2305: RET
// export function PrepareBurlak ; var i , tmp ; begin
2306: LD_INT 0
2308: PPUSH
2309: PPUSH
2310: PPUSH
// uc_side := 4 ;
2311: LD_ADDR_OWVAR 20
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// uc_nation := 3 ;
2319: LD_ADDR_OWVAR 21
2323: PUSH
2324: LD_INT 3
2326: ST_TO_ADDR
// InitHc ;
2327: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2331: LD_ADDR_EXP 47
2335: PUSH
2336: LD_STRING Burlak
2338: PPUSH
2339: CALL_OW 25
2343: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2344: LD_INT 24
2346: PUSH
2347: LD_INT 23
2349: PUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 22
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PUSH
2362: LD_OWVAR 67
2366: ARRAY
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: LD_INT 1
2373: PPUSH
2374: LD_INT 45
2376: PUSH
2377: LD_INT 44
2379: PUSH
2380: LD_INT 43
2382: PUSH
2383: LD_INT 42
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_OWVAR 67
2396: ARRAY
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL 19679 0 5
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 50
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2415: LD_EXP 50
2419: PUSH
2420: LD_EXP 47
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PPUSH
2429: LD_INT 499
2431: PPUSH
2432: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2436: LD_EXP 50
2440: PPUSH
2441: LD_INT 3
2443: PPUSH
2444: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2448: LD_EXP 50
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 18
2465: PPUSH
2466: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2470: LD_INT 35
2472: PPUSH
2473: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2477: LD_ADDR_VAR 0 3
2481: PUSH
2482: LD_INT 18
2484: PPUSH
2485: EMPTY
2486: PPUSH
2487: CALL_OW 70
2491: ST_TO_ADDR
// if tmp then
2492: LD_VAR 0 3
2496: IFFALSE 2530
// for i in tmp do
2498: LD_ADDR_VAR 0 2
2502: PUSH
2503: LD_VAR 0 3
2507: PUSH
2508: FOR_IN
2509: IFFALSE 2528
// ComMoveXY ( i , 114 , 9 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 114
2518: PPUSH
2519: LD_INT 9
2521: PPUSH
2522: CALL_OW 111
2526: GO 2508
2528: POP
2529: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2530: LD_INT 18
2532: PPUSH
2533: EMPTY
2534: PPUSH
2535: CALL_OW 70
2539: NOT
2540: PUSH
2541: LD_INT 123
2543: PPUSH
2544: LD_INT 3
2546: PPUSH
2547: CALL_OW 428
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: AND
2556: IFFALSE 2470
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2558: LD_EXP 50
2562: PPUSH
2563: LD_INT 123
2565: PPUSH
2566: LD_INT 3
2568: PPUSH
2569: LD_INT 0
2571: PPUSH
2572: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2576: LD_EXP 47
2580: PPUSH
2581: LD_INT 125
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: LD_INT 0
2589: PPUSH
2590: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2594: LD_EXP 47
2598: PPUSH
2599: LD_EXP 50
2603: PPUSH
2604: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2608: LD_INT 10
2610: PPUSH
2611: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2615: LD_EXP 50
2619: PPUSH
2620: LD_INT 110
2622: PPUSH
2623: LD_INT 10
2625: PPUSH
2626: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2630: LD_ADDR_EXP 43
2634: PUSH
2635: LD_STRING Petrovova
2637: PPUSH
2638: CALL_OW 25
2642: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2643: LD_ADDR_EXP 45
2647: PUSH
2648: LD_STRING Kuzmov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2656: LD_ADDR_EXP 44
2660: PUSH
2661: LD_STRING Kovalyuk
2663: PPUSH
2664: CALL_OW 25
2668: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2669: LD_ADDR_EXP 42
2673: PUSH
2674: LD_STRING Lipshchin
2676: PPUSH
2677: CALL_OW 25
2681: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2682: LD_ADDR_EXP 46
2686: PUSH
2687: LD_STRING Karamazov
2689: PPUSH
2690: CALL_OW 25
2694: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2695: LD_ADDR_VAR 0 3
2699: PUSH
2700: LD_EXP 43
2704: PUSH
2705: LD_EXP 45
2709: PUSH
2710: LD_EXP 44
2714: PUSH
2715: LD_EXP 42
2719: PUSH
2720: LD_EXP 46
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: ST_TO_ADDR
// for i in tmp do
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 3
2741: PUSH
2742: FOR_IN
2743: IFFALSE 2782
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2745: LD_VAR 0 2
2749: PPUSH
2750: LD_INT 399
2752: PPUSH
2753: LD_INT 799
2755: PPUSH
2756: CALL_OW 12
2760: PPUSH
2761: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2765: LD_VAR 0 2
2769: PPUSH
2770: LD_INT 19
2772: PPUSH
2773: LD_INT 0
2775: PPUSH
2776: CALL_OW 49
// end ;
2780: GO 2742
2782: POP
2783: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 112
2791: PPUSH
2792: LD_INT 5
2794: PPUSH
2795: CALL_OW 111
// AddComHold ( tmp ) ;
2799: LD_VAR 0 3
2803: PPUSH
2804: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2808: LD_ADDR_VAR 0 2
2812: PUSH
2813: LD_VAR 0 3
2817: PPUSH
2818: LD_INT 25
2820: PUSH
2821: LD_INT 1
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PPUSH
2828: CALL_OW 72
2832: PUSH
2833: FOR_IN
2834: IFFALSE 2874
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2836: LD_VAR 0 2
2840: PPUSH
2841: LD_INT 20
2843: PPUSH
2844: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2848: LD_VAR 0 2
2852: PPUSH
2853: LD_INT 147
2855: PPUSH
2856: LD_INT 45
2858: PPUSH
2859: CALL_OW 178
// AddComCrawl ( i ) ;
2863: LD_VAR 0 2
2867: PPUSH
2868: CALL_OW 197
// end ;
2872: GO 2833
2874: POP
2875: POP
// repeat wait ( 0 0$1 ) ;
2876: LD_INT 35
2878: PPUSH
2879: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2883: LD_EXP 50
2887: PPUSH
2888: LD_INT 110
2890: PPUSH
2891: LD_INT 10
2893: PPUSH
2894: CALL_OW 307
2898: PUSH
2899: LD_EXP 50
2903: PPUSH
2904: CALL_OW 305
2908: NOT
2909: OR
2910: IFFALSE 2876
// ComStop ( Burlak ) ;
2912: LD_EXP 47
2916: PPUSH
2917: CALL_OW 141
// AddComHold ( Burlak ) ;
2921: LD_EXP 47
2925: PPUSH
2926: CALL_OW 200
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
// uc_side := 3 ;
2942: LD_ADDR_OWVAR 20
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// uc_nation := 3 ;
2950: LD_ADDR_OWVAR 21
2954: PUSH
2955: LD_INT 3
2957: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2958: LD_ADDR_EXP 51
2962: PUSH
2963: LD_INT 47
2965: PPUSH
2966: LD_INT 4
2968: PPUSH
2969: LD_STRING 
2971: PPUSH
2972: LD_INT 7
2974: PUSH
2975: LD_INT 8
2977: PUSH
2978: LD_INT 9
2980: PUSH
2981: LD_INT 10
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PPUSH
2996: LD_INT 10000
2998: PUSH
2999: LD_INT 3000
3001: PUSH
3002: LD_INT 300
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: PPUSH
3010: LD_INT 9
3012: PUSH
3013: LD_INT 5
3015: PUSH
3016: LD_INT 6
3018: PUSH
3019: LD_INT 6
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 23125 0 6
3032: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3033: LD_ADDR_EXP 60
3037: PUSH
3038: LD_EXP 60
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_EXP 51
3050: PPUSH
3051: CALL_OW 1
3055: ST_TO_ADDR
// tmp := [ ] ;
3056: LD_ADDR_VAR 0 4
3060: PUSH
3061: EMPTY
3062: ST_TO_ADDR
// for i = 1 to 4 do
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: DOUBLE
3069: LD_INT 1
3071: DEC
3072: ST_TO_ADDR
3073: LD_INT 4
3075: PUSH
3076: FOR_TO
3077: IFFALSE 3170
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3079: LD_INT 22
3081: PPUSH
3082: LD_INT 3
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 43
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: LD_INT 45
3096: PUSH
3097: LD_INT 44
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: PUSH
3106: LD_VAR 0 2
3110: PUSH
3111: LD_INT 4
3113: MOD
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: ARRAY
3119: PPUSH
3120: LD_INT 100
3122: PPUSH
3123: CALL 19679 0 5
// veh := CreateVehicle ;
3127: LD_ADDR_VAR 0 3
3131: PUSH
3132: CALL_OW 45
3136: ST_TO_ADDR
// tmp := tmp ^ veh ;
3137: LD_ADDR_VAR 0 4
3141: PUSH
3142: LD_VAR 0 4
3146: PUSH
3147: LD_VAR 0 3
3151: ADD
3152: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_INT 2
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3076
3170: POP
3171: POP
// russian_guard := tmp ;
3172: LD_ADDR_EXP 52
3176: PUSH
3177: LD_VAR 0 4
3181: ST_TO_ADDR
// if Difficulty >= 3 then
3182: LD_OWVAR 67
3186: PUSH
3187: LD_INT 3
3189: GREATEREQUAL
3190: IFFALSE 3254
// begin bc_type := b_breastwork ;
3192: LD_ADDR_OWVAR 42
3196: PUSH
3197: LD_INT 31
3199: ST_TO_ADDR
// bc_level := 10 ;
3200: LD_ADDR_OWVAR 43
3204: PUSH
3205: LD_INT 10
3207: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3208: LD_ADDR_VAR 0 5
3212: PUSH
3213: LD_INT 96
3215: PPUSH
3216: LD_INT 105
3218: PPUSH
3219: LD_INT 3
3221: PPUSH
3222: CALL_OW 47
3226: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3227: LD_INT 0
3229: PPUSH
3230: LD_INT 9
3232: PPUSH
3233: LD_INT 10
3235: PPUSH
3236: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3240: CALL_OW 44
3244: PPUSH
3245: LD_VAR 0 5
3249: PPUSH
3250: CALL_OW 52
// end ; end ;
3254: LD_VAR 0 1
3258: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3259: LD_INT 47
3261: PPUSH
3262: CALL_OW 302
3266: PUSH
3267: LD_EXP 6
3271: AND
3272: IFFALSE 3961
3274: GO 3276
3276: DISABLE
3277: LD_INT 0
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
// begin enable ;
3286: ENABLE
// base := 2 ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 2
3294: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3295: LD_ADDR_VAR 0 4
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: LD_INT 1
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 22
3349: PUSH
3350: LD_INT 1
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 45
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 21
3367: PUSH
3368: LD_INT 1
3370: PUSH
3371: LD_INT 3
3373: PUSH
3374: LD_INT 45
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 1
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: LD_INT 45
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 23
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 46
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: ST_TO_ADDR
// amount := Difficulty ;
3425: LD_ADDR_VAR 0 7
3429: PUSH
3430: LD_OWVAR 67
3434: ST_TO_ADDR
// if tick > 30 30$00 then
3435: LD_OWVAR 1
3439: PUSH
3440: LD_INT 63000
3442: GREATER
3443: IFFALSE 3480
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 7
3449: PUSH
3450: LD_VAR 0 7
3454: PUSH
3455: LD_INT 2
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: LD_INT 4
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_OWVAR 67
3477: ARRAY
3478: PLUS
3479: ST_TO_ADDR
// for i = 1 to amount do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 7
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3584
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_VAR 0 3
3507: PPUSH
3508: LD_VAR 0 3
3512: PUSH
3513: LD_INT 1
3515: PLUS
3516: PPUSH
3517: LD_INT 23
3519: PUSH
3520: LD_INT 24
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 2
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: LD_INT 3
3544: PUSH
3545: LD_INT 46
3547: PUSH
3548: LD_INT 47
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: CALL_OW 12
3569: ARRAY
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PPUSH
3577: CALL_OW 2
3581: ST_TO_ADDR
3582: GO 3495
3584: POP
3585: POP
// MC_InsertProduceList ( base , tmp ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_VAR 0 3
3595: PPUSH
3596: CALL 78590 0 2
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 1
3614: PPUSH
3615: CALL 80008 0 2
3619: PUSH
3620: LD_VAR 0 7
3624: GREATEREQUAL
3625: IFFALSE 3600
// wait ( 0 0$30 ) ;
3627: LD_INT 1050
3629: PPUSH
3630: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3634: LD_ADDR_VAR 0 5
3638: PUSH
3639: LD_INT 71
3641: PUSH
3642: LD_INT 19
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 91
3651: PUSH
3652: LD_INT 67
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 52
3661: PUSH
3662: LD_INT 44
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 48
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3685: LD_ADDR_VAR 0 6
3689: PUSH
3690: LD_EXP 79
3694: PUSH
3695: LD_VAR 0 2
3699: ARRAY
3700: PUSH
3701: LD_EXP 79
3705: PUSH
3706: LD_VAR 0 2
3710: ARRAY
3711: PPUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 34
3717: PUSH
3718: LD_INT 51
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 34
3727: PUSH
3728: LD_INT 52
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PPUSH
3740: CALL_OW 72
3744: DIFF
3745: ST_TO_ADDR
// if not attackers then
3746: LD_VAR 0 6
3750: NOT
3751: IFFALSE 3755
// exit ;
3753: GO 3961
// ru_attackers := attackers ;
3755: LD_ADDR_EXP 53
3759: PUSH
3760: LD_VAR 0 6
3764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3765: LD_ADDR_EXP 79
3769: PUSH
3770: LD_EXP 79
3774: PPUSH
3775: LD_VAR 0 2
3779: PPUSH
3780: LD_EXP 79
3784: PUSH
3785: LD_VAR 0 2
3789: ARRAY
3790: PUSH
3791: LD_VAR 0 6
3795: DIFF
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// for i = 1 to attackers do
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: DOUBLE
3808: LD_INT 1
3810: DEC
3811: ST_TO_ADDR
3812: LD_VAR 0 6
3816: PUSH
3817: FOR_TO
3818: IFFALSE 3895
// begin case i mod 3 of 0 :
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 3
3827: MOD
3828: PUSH
3829: LD_INT 0
3831: DOUBLE
3832: EQUAL
3833: IFTRUE 3837
3835: GO 3840
3837: POP
// ; 1 :
3838: GO 3893
3840: LD_INT 1
3842: DOUBLE
3843: EQUAL
3844: IFTRUE 3848
3846: GO 3866
3848: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3849: LD_VAR 0 1
3853: PPUSH
3854: LD_INT 32
3856: PPUSH
3857: LD_INT 49
3859: PPUSH
3860: CALL_OW 114
3864: GO 3893
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3892
3874: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3875: LD_VAR 0 1
3879: PPUSH
3880: LD_INT 117
3882: PPUSH
3883: LD_INT 107
3885: PPUSH
3886: CALL_OW 114
3890: GO 3893
3892: POP
// end ;
3893: GO 3817
3895: POP
3896: POP
// repeat wait ( 0 0$1 ) ;
3897: LD_INT 35
3899: PPUSH
3900: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3904: LD_VAR 0 6
3908: PPUSH
3909: LD_INT 60
3911: PUSH
3912: EMPTY
3913: LIST
3914: PPUSH
3915: CALL_OW 72
3919: NOT
3920: IFFALSE 3897
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3922: LD_VAR 0 2
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: LD_VAR 0 5
3936: PPUSH
3937: LD_VAR 0 4
3941: PPUSH
3942: CALL 78775 0 4
// if not first_attack then
3946: LD_EXP 7
3950: NOT
3951: IFFALSE 3961
// first_attack := true ;
3953: LD_ADDR_EXP 7
3957: PUSH
3958: LD_INT 1
3960: ST_TO_ADDR
// end ; end_of_file
3961: PPOPN 7
3963: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 2 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// uc_nation := 2 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 2
3988: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3989: LD_ADDR_EXP 56
3993: PUSH
3994: LD_STRING Abdul
3996: PPUSH
3997: CALL_OW 25
4001: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4002: LD_EXP 56
4006: PPUSH
4007: LD_INT 11
4009: PPUSH
4010: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4014: LD_EXP 56
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 52
// vc_chassis := 31 ;
4026: LD_ADDR_OWVAR 37
4030: PUSH
4031: LD_INT 31
4033: ST_TO_ADDR
// vc_control := control_rider ;
4034: LD_ADDR_OWVAR 38
4038: PUSH
4039: LD_INT 4
4041: ST_TO_ADDR
// mastodont := CreateVehicle ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: CALL_OW 45
4051: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4052: LD_EXP 57
4056: PPUSH
4057: LD_INT 153
4059: PPUSH
4060: LD_INT 71
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 48
// InitVc ;
4070: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4074: LD_ADDR_EXP 54
4078: PUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_STRING 
4087: PPUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: LD_INT 9
4096: PUSH
4097: LD_INT 10
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: LD_OWVAR 67
4110: ARRAY
4111: PPUSH
4112: LD_INT 5000
4114: PUSH
4115: LD_INT 1000
4117: PUSH
4118: LD_INT 300
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PPUSH
4126: LD_INT 18
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: LD_INT 6
4134: PUSH
4135: LD_INT 9
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL 23125 0 6
4148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4149: LD_ADDR_EXP 60
4153: PUSH
4154: LD_EXP 60
4158: PPUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_EXP 54
4166: PPUSH
4167: CALL_OW 1
4171: ST_TO_ADDR
// tmp := [ ] ;
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4179: LD_ADDR_OWVAR 37
4183: PUSH
4184: LD_INT 14
4186: ST_TO_ADDR
// vc_engine := engine_siberite ;
4187: LD_ADDR_OWVAR 39
4191: PUSH
4192: LD_INT 3
4194: ST_TO_ADDR
// vc_control := control_manual ;
4195: LD_ADDR_OWVAR 38
4199: PUSH
4200: LD_INT 1
4202: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4203: LD_ADDR_OWVAR 40
4207: PUSH
4208: LD_INT 31
4210: ST_TO_ADDR
// for i = 1 to 3 do
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: DOUBLE
4217: LD_INT 1
4219: DEC
4220: ST_TO_ADDR
4221: LD_INT 3
4223: PUSH
4224: FOR_TO
4225: IFFALSE 4473
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4227: LD_ADDR_VAR 0 5
4231: PUSH
4232: LD_INT 153
4234: PUSH
4235: LD_INT 71
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 155
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_VAR 0 2
4260: PUSH
4261: LD_INT 2
4263: MOD
4264: PUSH
4265: LD_INT 1
4267: PLUS
4268: ARRAY
4269: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4270: LD_INT 0
4272: PPUSH
4273: LD_INT 3
4275: PPUSH
4276: LD_INT 7
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_INT 10
4284: PUSH
4285: LD_INT 10
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_OWVAR 67
4298: ARRAY
4299: PPUSH
4300: CALL_OW 380
// un := CreateVehicle ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: CALL_OW 45
4313: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4314: LD_VAR 0 6
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: LD_INT 5
4324: PPUSH
4325: CALL_OW 12
4329: PPUSH
4330: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4334: LD_VAR 0 6
4338: PPUSH
4339: LD_VAR 0 5
4343: PUSH
4344: LD_INT 1
4346: ARRAY
4347: PPUSH
4348: LD_VAR 0 5
4352: PUSH
4353: LD_INT 2
4355: ARRAY
4356: PPUSH
4357: LD_INT 6
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// un2 := CreateHuman ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: CALL_OW 44
4376: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4377: LD_VAR 0 7
4381: PPUSH
4382: LD_VAR 0 6
4386: PPUSH
4387: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4391: LD_ADDR_EXP 60
4395: PUSH
4396: LD_EXP 60
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 60
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 6
4425: PPUSH
4426: CALL 19801 0 3
4430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4431: LD_ADDR_EXP 60
4435: PUSH
4436: LD_EXP 60
4440: PPUSH
4441: LD_INT 1
4443: PUSH
4444: LD_EXP 60
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: LD_VAR 0 7
4465: PPUSH
4466: CALL 19801 0 3
4470: ST_TO_ADDR
// end ;
4471: GO 4224
4473: POP
4474: POP
// for i = 1 to 5 do
4475: LD_ADDR_VAR 0 2
4479: PUSH
4480: DOUBLE
4481: LD_INT 1
4483: DEC
4484: ST_TO_ADDR
4485: LD_INT 5
4487: PUSH
4488: FOR_TO
4489: IFFALSE 4582
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4491: LD_INT 14
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 25
4502: PUSH
4503: LD_INT 28
4505: PUSH
4506: LD_INT 28
4508: PUSH
4509: LD_INT 26
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PUSH
4518: LD_VAR 0 2
4522: PUSH
4523: LD_INT 4
4525: MOD
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: ARRAY
4531: PPUSH
4532: LD_INT 100
4534: PPUSH
4535: CALL 19679 0 5
// veh := CreateVehicle ;
4539: LD_ADDR_VAR 0 3
4543: PUSH
4544: CALL_OW 45
4548: ST_TO_ADDR
// tmp := tmp ^ veh ;
4549: LD_ADDR_VAR 0 4
4553: PUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_VAR 0 3
4563: ADD
4564: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4565: LD_VAR 0 3
4569: PPUSH
4570: LD_INT 1
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 49
// end ;
4580: GO 4488
4582: POP
4583: POP
// arabian_guard := tmp ;
4584: LD_ADDR_EXP 55
4588: PUSH
4589: LD_VAR 0 4
4593: ST_TO_ADDR
// end ;
4594: LD_VAR 0 1
4598: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4599: LD_INT 22
4601: PUSH
4602: LD_INT 7
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 91
4611: PUSH
4612: LD_INT 1
4614: PUSH
4615: LD_INT 12
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PPUSH
4627: CALL_OW 69
4631: PUSH
4632: LD_EXP 57
4636: PPUSH
4637: CALL_OW 256
4641: PUSH
4642: LD_INT 990
4644: LESS
4645: OR
4646: PUSH
4647: LD_EXP 56
4651: PPUSH
4652: CALL_OW 256
4656: PUSH
4657: LD_INT 990
4659: LESS
4660: OR
4661: IFFALSE 4804
4663: GO 4665
4665: DISABLE
// begin if IsInUnit ( Abdul ) then
4666: LD_EXP 56
4670: PPUSH
4671: CALL_OW 310
4675: IFFALSE 4686
// ComExitBuilding ( Abdul ) ;
4677: LD_EXP 56
4681: PPUSH
4682: CALL_OW 122
// if Mastodont then
4686: LD_EXP 57
4690: IFFALSE 4707
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4692: LD_EXP 57
4696: PPUSH
4697: LD_INT 205
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4707: LD_EXP 56
4711: PPUSH
4712: LD_INT 205
4714: PPUSH
4715: LD_INT 132
4717: PPUSH
4718: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4729: LD_EXP 56
4733: PPUSH
4734: LD_INT 21
4736: PPUSH
4737: CALL_OW 308
4741: IFFALSE 4722
// RemoveUnit ( Abdul ) ;
4743: LD_EXP 56
4747: PPUSH
4748: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4752: LD_INT 35
4754: PPUSH
4755: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4759: LD_EXP 57
4763: PPUSH
4764: LD_INT 21
4766: PPUSH
4767: CALL_OW 308
4771: PUSH
4772: LD_EXP 57
4776: PPUSH
4777: CALL_OW 301
4781: OR
4782: IFFALSE 4752
// if IsOk ( Mastodont ) then
4784: LD_EXP 57
4788: PPUSH
4789: CALL_OW 302
4793: IFFALSE 4804
// RemoveUnit ( Mastodont ) ;
4795: LD_EXP 57
4799: PPUSH
4800: CALL_OW 64
// end ;
4804: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4805: LD_EXP 56
4809: PPUSH
4810: CALL_OW 301
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 25
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 25
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 25
4860: PUSH
4861: LD_INT 4
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 8
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: PUSH
4895: LD_INT 16
4897: PUSH
4898: LD_INT 19
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 22
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_OWVAR 67
4917: ARRAY
4918: LESS
4919: OR
4920: IFFALSE 5593
4922: GO 4924
4924: DISABLE
4925: LD_INT 0
4927: PPUSH
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
// begin MC_Kill ( 1 ) ;
4933: LD_INT 1
4935: PPUSH
4936: CALL 54612 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 25
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 25
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 3
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 25
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 69
5024: ST_TO_ADDR
// for i in tmp do
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_VAR 0 2
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5052
// SetTag ( i , 10 ) ;
5038: LD_VAR 0 5
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 109
5050: GO 5035
5052: POP
5053: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5054: LD_ADDR_VAR 0 3
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 21
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: PUSH
5088: LD_VAR 0 2
5092: DIFF
5093: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_INT 22
5101: PUSH
5102: LD_INT 2
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 21
5111: PUSH
5112: LD_INT 2
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 24
5121: PUSH
5122: LD_INT 300
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PPUSH
5134: CALL_OW 69
5138: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5139: LD_ADDR_VAR 0 4
5143: PUSH
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 33
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 58
5161: PUSH
5162: EMPTY
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 72
5173: ST_TO_ADDR
// for i in tmp do
5174: LD_ADDR_VAR 0 5
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5369
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5187: LD_VAR 0 5
5191: PUSH
5192: LD_INT 55
5194: PUSH
5195: EMPTY
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: IN
5203: IFFALSE 5222
// begin AddComMoveXY ( i , 209 , 132 ) ;
5205: LD_VAR 0 5
5209: PPUSH
5210: LD_INT 209
5212: PPUSH
5213: LD_INT 132
5215: PPUSH
5216: CALL_OW 171
// continue ;
5220: GO 5184
// end ; if IsInUnit ( i ) then
5222: LD_VAR 0 5
5226: PPUSH
5227: CALL_OW 310
5231: IFFALSE 5249
// begin ComExitBuilding ( i ) ;
5233: LD_VAR 0 5
5237: PPUSH
5238: CALL_OW 122
// wait ( 3 ) ;
5242: LD_INT 3
5244: PPUSH
5245: CALL_OW 67
// end ; if tmp_empty then
5249: LD_VAR 0 4
5253: IFFALSE 5352
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5255: LD_VAR 0 5
5259: PPUSH
5260: LD_VAR 0 4
5264: PPUSH
5265: LD_VAR 0 5
5269: PPUSH
5270: CALL_OW 74
5274: PPUSH
5275: CALL_OW 296
5279: PUSH
5280: LD_INT 25
5282: LESS
5283: IFFALSE 5352
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 5
5299: PPUSH
5300: CALL_OW 74
5304: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5305: LD_VAR 0 5
5309: PPUSH
5310: LD_VAR 0 6
5314: PPUSH
5315: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5319: LD_VAR 0 5
5323: PPUSH
5324: LD_INT 209
5326: PPUSH
5327: LD_INT 132
5329: PPUSH
5330: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 6
5348: DIFF
5349: ST_TO_ADDR
// continue ;
5350: GO 5184
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5352: LD_VAR 0 5
5356: PPUSH
5357: LD_INT 201
5359: PPUSH
5360: LD_INT 132
5362: PPUSH
5363: CALL_OW 171
// end ;
5367: GO 5184
5369: POP
5370: POP
// for i in tmp_ape do
5371: LD_ADDR_VAR 0 5
5375: PUSH
5376: LD_VAR 0 3
5380: PUSH
5381: FOR_IN
5382: IFFALSE 5421
// begin if IsInUnit ( i ) then
5384: LD_VAR 0 5
5388: PPUSH
5389: CALL_OW 310
5393: IFFALSE 5404
// ComExitBuilding ( i ) ;
5395: LD_VAR 0 5
5399: PPUSH
5400: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5404: LD_VAR 0 5
5408: PPUSH
5409: LD_INT 201
5411: PPUSH
5412: LD_INT 132
5414: PPUSH
5415: CALL_OW 171
// end ;
5419: GO 5381
5421: POP
5422: POP
// repeat wait ( 0 0$1 ) ;
5423: LD_INT 35
5425: PPUSH
5426: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 2
5439: PUSH
5440: LD_VAR 0 3
5444: UNION
5445: PUSH
5446: LD_VAR 0 1
5450: UNION
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5484
// if not HasTask ( i ) then
5455: LD_VAR 0 5
5459: PPUSH
5460: CALL_OW 314
5464: NOT
5465: IFFALSE 5482
// ComMoveXY ( i , 201 , 132 ) ;
5467: LD_VAR 0 5
5471: PPUSH
5472: LD_INT 201
5474: PPUSH
5475: LD_INT 132
5477: PPUSH
5478: CALL_OW 111
5482: GO 5452
5484: POP
5485: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5486: LD_INT 21
5488: PPUSH
5489: LD_INT 22
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL_OW 70
5503: IFFALSE 5544
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 21
5512: PPUSH
5513: LD_INT 22
5515: PUSH
5516: LD_INT 2
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: PUSH
5528: FOR_IN
5529: IFFALSE 5542
// RemoveUnit ( i ) ;
5531: LD_VAR 0 5
5535: PPUSH
5536: CALL_OW 64
5540: GO 5528
5542: POP
5543: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 2
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 2
5556: PUSH
5557: LD_INT 21
5559: PUSH
5560: LD_INT 1
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 21
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: NOT
5591: IFFALSE 5423
// end ;
5593: PPOPN 6
5595: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5596: LD_EXP 9
5600: PUSH
5601: LD_INT 92
5603: PPUSH
5604: LD_INT 40
5606: PPUSH
5607: CALL_OW 428
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 30
5619: EQUAL
5620: AND
5621: IFFALSE 5817
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5629: LD_ADDR_VAR 0 1
5633: PUSH
5634: LD_EXP 60
5638: PUSH
5639: LD_INT 1
5641: ARRAY
5642: PPUSH
5643: LD_INT 25
5645: PUSH
5646: LD_INT 4
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PPUSH
5653: CALL_OW 72
5657: ST_TO_ADDR
// if not sci then
5658: LD_VAR 0 1
5662: NOT
5663: IFFALSE 5667
// exit ;
5665: GO 5817
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5667: LD_ADDR_EXP 60
5671: PUSH
5672: LD_EXP 60
5676: PPUSH
5677: LD_INT 1
5679: PPUSH
5680: LD_EXP 60
5684: PUSH
5685: LD_INT 1
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 1
5693: PUSH
5694: LD_INT 1
5696: ARRAY
5697: DIFF
5698: PPUSH
5699: CALL_OW 1
5703: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5704: LD_VAR 0 1
5708: PUSH
5709: LD_INT 1
5711: ARRAY
5712: PPUSH
5713: CALL_OW 310
5717: IFFALSE 5732
// ComExitBuilding ( sci [ 1 ] ) ;
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5732: LD_INT 2
5734: PPUSH
5735: LD_INT 105
5737: PPUSH
5738: LD_INT 14
5740: PPUSH
5741: LD_INT 20
5743: PPUSH
5744: CALL 20697 0 4
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 10
5755: LESS
5756: IFFALSE 5779
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: LD_INT 105
5769: PPUSH
5770: LD_INT 14
5772: PPUSH
5773: CALL_OW 171
5777: GO 5798
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5779: LD_VAR 0 1
5783: PUSH
5784: LD_INT 1
5786: ARRAY
5787: PPUSH
5788: LD_INT 118
5790: PPUSH
5791: LD_INT 77
5793: PPUSH
5794: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5798: LD_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ARRAY
5806: PPUSH
5807: LD_INT 92
5809: PPUSH
5810: LD_INT 40
5812: PPUSH
5813: CALL_OW 218
// end ;
5817: PPOPN 1
5819: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5820: LD_INT 1
5822: PPUSH
5823: CALL_OW 302
5827: PUSH
5828: LD_EXP 9
5832: AND
5833: IFFALSE 6312
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
5844: PPUSH
5845: PPUSH
// begin enable ;
5846: ENABLE
// base := 1 ;
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_INT 1
5854: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 0
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 0
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5902: LD_ADDR_VAR 0 3
5906: PUSH
5907: LD_INT 14
5909: PUSH
5910: LD_INT 1
5912: PUSH
5913: LD_INT 2
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 14
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 28
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 29
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_OWVAR 67
5980: PUSH
5981: LD_OWVAR 1
5985: PUSH
5986: LD_INT 21000
5988: DIV
5989: PLUS
5990: PUSH
5991: FOR_TO
5992: IFFALSE 6084
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5994: LD_ADDR_VAR 0 3
5998: PUSH
5999: LD_VAR 0 3
6003: PPUSH
6004: LD_VAR 0 3
6008: PUSH
6009: LD_INT 1
6011: PLUS
6012: PPUSH
6013: LD_INT 13
6015: PUSH
6016: LD_INT 14
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 26
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 1
6061: PPUSH
6062: LD_INT 4
6064: PPUSH
6065: CALL_OW 12
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PPUSH
6077: CALL_OW 2
6081: ST_TO_ADDR
6082: GO 5991
6084: POP
6085: POP
// MC_InsertProduceList ( base , tmp ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_VAR 0 3
6095: PPUSH
6096: CALL 78590 0 2
// repeat wait ( 0 0$1 ) ;
6100: LD_INT 35
6102: PPUSH
6103: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6107: LD_EXP 79
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_INT 6
6120: GREATER
6121: IFFALSE 6100
// wait ( 0 0$20 ) ;
6123: LD_INT 700
6125: PPUSH
6126: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6130: LD_ADDR_VAR 0 5
6134: PUSH
6135: LD_INT 124
6137: PUSH
6138: LD_INT 85
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 90
6147: PUSH
6148: LD_INT 61
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 69
6157: PUSH
6158: LD_INT 48
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 68
6167: PUSH
6168: LD_INT 48
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_EXP 79
6190: PUSH
6191: LD_VAR 0 2
6195: ARRAY
6196: PUSH
6197: LD_EXP 79
6201: PUSH
6202: LD_VAR 0 2
6206: ARRAY
6207: PPUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 34
6213: PUSH
6214: LD_INT 32
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 34
6223: PUSH
6224: LD_EXP 110
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6312
// ar_attackers := attackers ;
6253: LD_ADDR_EXP 11
6257: PUSH
6258: LD_VAR 0 6
6262: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6270: LD_VAR 0 6
6274: PPUSH
6275: LD_INT 60
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: NOT
6286: IFFALSE 6263
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 78775 0 4
// end ;
6312: PPOPN 6
6314: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6315: LD_INT 1
6317: PPUSH
6318: CALL_OW 302
6322: PUSH
6323: LD_EXP 9
6327: AND
6328: PUSH
6329: LD_EXP 50
6333: PPUSH
6334: LD_INT 22
6336: PPUSH
6337: CALL_OW 308
6341: AND
6342: PUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 78938 0 1
6350: PUSH
6351: LD_INT 0
6353: EQUAL
6354: AND
6355: PUSH
6356: LD_EXP 11
6360: NOT
6361: AND
6362: IFFALSE 6850
6364: GO 6366
6366: DISABLE
6367: LD_INT 0
6369: PPUSH
6370: PPUSH
6371: PPUSH
6372: PPUSH
6373: PPUSH
6374: PPUSH
6375: PPUSH
// begin base := 1 ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 0
6391: PUSH
6392: LD_INT 0
6394: PUSH
6395: LD_INT 0
6397: PUSH
6398: LD_INT 0
6400: PUSH
6401: LD_INT 0
6403: PUSH
6404: LD_INT 0
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: LD_INT 0
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6431: LD_ADDR_VAR 0 3
6435: PUSH
6436: LD_INT 13
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 28
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 27
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 25
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 11
6492: PUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 24
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 11
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 2
6516: PUSH
6517: LD_INT 24
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 78590 0 2
// repeat wait ( 0 0$1 ) ;
6547: LD_INT 35
6549: PPUSH
6550: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6554: LD_EXP 79
6558: PUSH
6559: LD_VAR 0 2
6563: ARRAY
6564: PUSH
6565: LD_INT 6
6567: GREATEREQUAL
6568: IFFALSE 6547
// wait ( 0 0$20 ) ;
6570: LD_INT 700
6572: PPUSH
6573: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6577: LD_ADDR_VAR 0 5
6581: PUSH
6582: LD_INT 119
6584: PUSH
6585: LD_INT 9
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6595: LD_ADDR_VAR 0 6
6599: PUSH
6600: LD_EXP 79
6604: PUSH
6605: LD_VAR 0 2
6609: ARRAY
6610: PUSH
6611: LD_EXP 79
6615: PUSH
6616: LD_VAR 0 2
6620: ARRAY
6621: PPUSH
6622: LD_INT 2
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 34
6637: PUSH
6638: LD_EXP 110
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PPUSH
6652: CALL_OW 72
6656: DIFF
6657: ST_TO_ADDR
// if not attackers then
6658: LD_VAR 0 6
6662: NOT
6663: IFFALSE 6667
// exit ;
6665: GO 6850
// uc_side := 2 ;
6667: LD_ADDR_OWVAR 20
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// uc_nation := 2 ;
6675: LD_ADDR_OWVAR 21
6679: PUSH
6680: LD_INT 2
6682: ST_TO_ADDR
// InitHc ;
6683: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6687: LD_ADDR_VAR 0 1
6691: PUSH
6692: DOUBLE
6693: LD_INT 1
6695: DEC
6696: ST_TO_ADDR
6697: LD_INT 4
6699: PUSH
6700: LD_INT 5
6702: PUSH
6703: LD_INT 6
6705: PUSH
6706: LD_INT 6
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: PUSH
6715: LD_OWVAR 67
6719: ARRAY
6720: PUSH
6721: FOR_TO
6722: IFFALSE 6799
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6724: LD_INT 0
6726: PPUSH
6727: LD_INT 15
6729: PUSH
6730: LD_INT 17
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 2
6742: PPUSH
6743: CALL_OW 12
6747: ARRAY
6748: PPUSH
6749: LD_INT 8
6751: PPUSH
6752: CALL_OW 380
// un := CreateHuman ;
6756: LD_ADDR_VAR 0 7
6760: PUSH
6761: CALL_OW 44
6765: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 23
6773: PPUSH
6774: LD_INT 0
6776: PPUSH
6777: CALL_OW 49
// attackers := attackers union un ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_VAR 0 6
6790: PUSH
6791: LD_VAR 0 7
6795: UNION
6796: ST_TO_ADDR
// end ;
6797: GO 6721
6799: POP
6800: POP
// repeat wait ( 0 0$1 ) ;
6801: LD_INT 35
6803: PPUSH
6804: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6808: LD_VAR 0 6
6812: PPUSH
6813: LD_INT 60
6815: PUSH
6816: EMPTY
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: NOT
6824: IFFALSE 6801
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 6
6835: PPUSH
6836: LD_VAR 0 5
6840: PPUSH
6841: LD_VAR 0 4
6845: PPUSH
6846: CALL 78775 0 4
// end ; end_of_file
6850: PPOPN 7
6852: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
6859: PPUSH
6860: PPUSH
// uc_side := 1 ;
6861: LD_ADDR_OWVAR 20
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// uc_nation := 1 ;
6869: LD_ADDR_OWVAR 21
6873: PUSH
6874: LD_INT 1
6876: ST_TO_ADDR
// InitHc ;
6877: CALL_OW 19
// InitVc ;
6881: CALL_OW 20
// tmp := [ ] ;
6885: LD_ADDR_VAR 0 3
6889: PUSH
6890: EMPTY
6891: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: DOUBLE
6898: LD_INT 1
6900: DEC
6901: ST_TO_ADDR
6902: LD_INT 6
6904: PUSH
6905: LD_INT 8
6907: PUSH
6908: LD_INT 10
6910: PUSH
6911: LD_INT 10
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: LD_OWVAR 67
6924: ARRAY
6925: PUSH
6926: FOR_TO
6927: IFFALSE 7201
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6929: LD_ADDR_VAR 0 5
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: LD_INT 5
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 1
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: CALL_OW 12
6958: ARRAY
6959: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6960: LD_VAR 0 5
6964: PUSH
6965: LD_INT 2
6967: DOUBLE
6968: EQUAL
6969: IFTRUE 6973
6971: GO 7007
6973: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6974: LD_ADDR_VAR 0 6
6978: PUSH
6979: LD_INT 9
6981: PUSH
6982: LD_INT 5
6984: PUSH
6985: LD_INT 7
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 1
6995: PPUSH
6996: LD_INT 3
6998: PPUSH
6999: CALL_OW 12
7003: ARRAY
7004: ST_TO_ADDR
7005: GO 7096
7007: LD_INT 4
7009: DOUBLE
7010: EQUAL
7011: IFTRUE 7015
7013: GO 7053
7015: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7016: LD_ADDR_VAR 0 6
7020: PUSH
7021: LD_INT 9
7023: PUSH
7024: LD_INT 6
7026: PUSH
7027: LD_INT 6
7029: PUSH
7030: LD_INT 7
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 1
7041: PPUSH
7042: LD_INT 4
7044: PPUSH
7045: CALL_OW 12
7049: ARRAY
7050: ST_TO_ADDR
7051: GO 7096
7053: LD_INT 5
7055: DOUBLE
7056: EQUAL
7057: IFTRUE 7061
7059: GO 7095
7061: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7062: LD_ADDR_VAR 0 6
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: LD_INT 6
7072: PUSH
7073: LD_INT 7
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 3
7086: PPUSH
7087: CALL_OW 12
7091: ARRAY
7092: ST_TO_ADDR
7093: GO 7096
7095: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 2
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_VAR 0 6
7130: PPUSH
7131: LD_INT 70
7133: PPUSH
7134: LD_INT 90
7136: PPUSH
7137: CALL_OW 12
7141: PPUSH
7142: CALL 19679 0 5
// veh := CreateVehicle ;
7146: LD_ADDR_VAR 0 4
7150: PUSH
7151: CALL_OW 45
7155: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7168: LD_VAR 0 4
7172: PPUSH
7173: LD_INT 17
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL_OW 49
// tmp := tmp ^ veh ;
7183: LD_ADDR_VAR 0 3
7187: PUSH
7188: LD_VAR 0 3
7192: PUSH
7193: LD_VAR 0 4
7197: ADD
7198: ST_TO_ADDR
// end ;
7199: GO 6926
7201: POP
7202: POP
// if not tmp then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7321
// if not first_powell_attack then
7212: LD_EXP 12
7216: NOT
7217: IFFALSE 7227
// first_powell_attack := true ;
7219: LD_ADDR_EXP 12
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7227: LD_INT 70
7229: PPUSH
7230: CALL_OW 67
// for i in tmp do
7234: LD_ADDR_VAR 0 2
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: FOR_IN
7245: IFFALSE 7312
// if IsOk ( i ) then
7247: LD_VAR 0 2
7251: PPUSH
7252: CALL_OW 302
7256: IFFALSE 7294
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 81
7265: PUSH
7266: LD_INT 1
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 74
7287: PPUSH
7288: CALL_OW 115
7292: GO 7310
// tmp := tmp diff i ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: DIFF
7309: ST_TO_ADDR
7310: GO 7244
7312: POP
7313: POP
// until not tmp ;
7314: LD_VAR 0 3
7318: NOT
7319: IFFALSE 7227
// end ; end_of_file
7321: LD_VAR 0 1
7325: RET
// export function Action ; var tmp , i , un ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7332: LD_INT 68
7334: PPUSH
7335: LD_INT 39
7337: PPUSH
7338: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: LD_INT 22
7349: PUSH
7350: LD_INT 7
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PPUSH
7357: CALL_OW 69
7361: ST_TO_ADDR
// InGameOn ;
7362: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7366: LD_VAR 0 2
7370: PPUSH
7371: LD_INT 71
7373: PPUSH
7374: LD_INT 49
7376: PPUSH
7377: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7381: LD_INT 35
7383: PPUSH
7384: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7388: LD_INT 7
7390: PPUSH
7391: LD_INT 71
7393: PPUSH
7394: LD_INT 51
7396: PPUSH
7397: CALL_OW 293
7401: IFFALSE 7381
// DialogueOn ;
7403: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7407: LD_EXP 16
7411: PPUSH
7412: LD_STRING D1-JMM-1
7414: PPUSH
7415: CALL_OW 88
// if Joan then
7419: LD_EXP 31
7423: IFFALSE 7437
// Say ( Joan , D1-Joan-1 ) ;
7425: LD_EXP 31
7429: PPUSH
7430: LD_STRING D1-Joan-1
7432: PPUSH
7433: CALL_OW 88
// if Lisa then
7437: LD_EXP 18
7441: IFFALSE 7455
// Say ( Lisa , D1-Lisa-1 ) ;
7443: LD_EXP 18
7447: PPUSH
7448: LD_STRING D1-Lisa-1
7450: PPUSH
7451: CALL_OW 88
// if Joan or Lisa then
7455: LD_EXP 31
7459: PUSH
7460: LD_EXP 18
7464: OR
7465: IFFALSE 7479
// Say ( JMM , D1-JMM-2 ) ;
7467: LD_EXP 16
7471: PPUSH
7472: LD_STRING D1-JMM-2
7474: PPUSH
7475: CALL_OW 88
// DialogueOff ;
7479: CALL_OW 7
// InGameOff ;
7483: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7487: LD_INT 71
7489: PPUSH
7490: LD_INT 50
7492: PPUSH
7493: LD_INT 7
7495: PPUSH
7496: LD_INT 30
7498: NEG
7499: PPUSH
7500: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 50
7509: PPUSH
7510: LD_INT 7
7512: PPUSH
7513: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7517: LD_STRING M1
7519: PPUSH
7520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7524: LD_INT 35
7526: PPUSH
7527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7531: LD_EXP 3
7535: PUSH
7536: LD_OWVAR 1
7540: PUSH
7541: LD_INT 2100
7543: GREATER
7544: OR
7545: IFFALSE 7524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7547: LD_INT 350
7549: PPUSH
7550: LD_INT 700
7552: PPUSH
7553: CALL_OW 12
7557: PPUSH
7558: CALL_OW 67
// PrepareGossudarov ;
7562: CALL 1881 0 0
// repeat wait ( 0 0$1 ) ;
7566: LD_INT 35
7568: PPUSH
7569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7573: LD_INT 22
7575: PUSH
7576: LD_INT 6
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 24
7588: PUSH
7589: LD_INT 1000
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PPUSH
7604: CALL_OW 69
7608: PUSH
7609: LD_INT 7
7611: PPUSH
7612: LD_EXP 33
7616: PPUSH
7617: CALL_OW 292
7621: OR
7622: IFFALSE 7566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7624: LD_ADDR_VAR 0 2
7628: PUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 69
7643: ST_TO_ADDR
// for i in tmp do
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_VAR 0 2
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7671
// SetSide ( i , 7 ) ;
7657: LD_VAR 0 3
7661: PPUSH
7662: LD_INT 7
7664: PPUSH
7665: CALL_OW 235
7669: GO 7654
7671: POP
7672: POP
// DialogueOn ;
7673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7677: LD_EXP 16
7681: PUSH
7682: LD_EXP 17
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: LD_EXP 33
7695: PPUSH
7696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7700: LD_EXP 33
7704: PPUSH
7705: CALL_OW 87
// if not Roth then
7709: LD_EXP 17
7713: NOT
7714: IFFALSE 7806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7716: LD_VAR 0 2
7720: PPUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 24
7726: PUSH
7727: LD_INT 1000
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 72
7742: IFFALSE 7756
// Say ( JMM , D2-JMM-1 ) ;
7744: LD_EXP 16
7748: PPUSH
7749: LD_STRING D2-JMM-1
7751: PPUSH
7752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7756: LD_EXP 16
7760: PPUSH
7761: LD_STRING D2-JMM-1b
7763: PPUSH
7764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7768: LD_EXP 33
7772: PPUSH
7773: LD_STRING D2-Gos-1
7775: PPUSH
7776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7780: LD_EXP 16
7784: PPUSH
7785: LD_STRING D2-JMM-2
7787: PPUSH
7788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7792: LD_EXP 33
7796: PPUSH
7797: LD_STRING D2-Gos-2
7799: PPUSH
7800: CALL_OW 88
// end else
7804: GO 7958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 24
7816: PUSH
7817: LD_INT 1000
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PPUSH
7828: CALL_OW 72
7832: IFFALSE 7858
// begin Say ( Roth , D2-Roth-2 ) ;
7834: LD_EXP 17
7838: PPUSH
7839: LD_STRING D2-Roth-2
7841: PPUSH
7842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7846: LD_EXP 16
7850: PPUSH
7851: LD_STRING D2-JMM-1a
7853: PPUSH
7854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7858: LD_EXP 17
7862: PPUSH
7863: LD_STRING D2-Roth-2a
7865: PPUSH
7866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7870: LD_EXP 17
7874: PPUSH
7875: LD_STRING D2-Roth-2b
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7882: LD_EXP 16
7886: PPUSH
7887: LD_STRING D2-JMM-3
7889: PPUSH
7890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7894: LD_VAR 0 2
7898: PPUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PPUSH
7916: CALL_OW 72
7920: IFFALSE 7958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7922: LD_EXP 33
7926: PPUSH
7927: LD_STRING D2-Gos-3
7929: PPUSH
7930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7934: LD_EXP 16
7938: PPUSH
7939: LD_STRING D2-JMM-4
7941: PPUSH
7942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7946: LD_EXP 33
7950: PPUSH
7951: LD_STRING D2-Gos-4
7953: PPUSH
7954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7958: LD_EXP 16
7962: PPUSH
7963: LD_STRING D2-JMM-5
7965: PPUSH
7966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7970: LD_EXP 33
7974: PPUSH
7975: LD_STRING D2-Gos-5
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7982: LD_EXP 16
7986: PPUSH
7987: LD_STRING D2-JMM-6
7989: PPUSH
7990: CALL_OW 88
// DialogueOff ;
7994: CALL_OW 7
// wait ( 0 0$2 ) ;
7998: LD_INT 70
8000: PPUSH
8001: CALL_OW 67
// if Kirilenkova then
8005: LD_EXP 34
8009: IFFALSE 8023
// Say ( Kirilenkova , D3-Kir-1 ) ;
8011: LD_EXP 34
8015: PPUSH
8016: LD_STRING D3-Kir-1
8018: PPUSH
8019: CALL_OW 88
// gossudarov_arrive := true ;
8023: LD_ADDR_EXP 4
8027: PUSH
8028: LD_INT 1
8030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// until ru_lab_builded ;
8038: LD_EXP 5
8042: IFFALSE 8031
// DialogueOn ;
8044: CALL_OW 6
// if Kirilenkova then
8048: LD_EXP 34
8052: IFFALSE 8068
// Say ( Kirilenkova , D3a-Kir-1 ) else
8054: LD_EXP 34
8058: PPUSH
8059: LD_STRING D3a-Kir-1
8061: PPUSH
8062: CALL_OW 88
8066: GO 8090
// begin un := SciRu ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: CALL 13222 0 0
8077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8078: LD_VAR 0 4
8082: PPUSH
8083: LD_STRING D3a-Sci1-1
8085: PPUSH
8086: CALL_OW 88
// end ; if Kirilenkova or un then
8090: LD_EXP 34
8094: PUSH
8095: LD_VAR 0 4
8099: OR
8100: IFFALSE 8114
// Say ( JMM , D3a-JMM-1 ) ;
8102: LD_EXP 16
8106: PPUSH
8107: LD_STRING D3a-JMM-1
8109: PPUSH
8110: CALL_OW 88
// DialogueOff ;
8114: CALL_OW 7
// end ;
8118: LD_VAR 0 1
8122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8123: LD_EXP 4
8127: PUSH
8128: LD_INT 22
8130: PUSH
8131: LD_INT 7
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 4
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 5
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 8
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 9
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 7
8232: LESS
8233: AND
8234: IFFALSE 8246
8236: GO 8238
8238: DISABLE
// YouLost ( TooMany ) ;
8239: LD_STRING TooMany
8241: PPUSH
8242: CALL_OW 104
8246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8247: LD_EXP 33
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 7
8259: EQUAL
8260: IFFALSE 8477
8262: GO 8264
8264: DISABLE
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
// begin uc_side := 3 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// uc_nation := 3 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 3
8285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8286: LD_INT 21
8288: PPUSH
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 42
8297: PPUSH
8298: LD_INT 100
8300: PPUSH
8301: CALL 19679 0 5
// un := CreateVehicle ;
8305: LD_ADDR_VAR 0 3
8309: PUSH
8310: CALL_OW 45
8314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8315: LD_VAR 0 3
8319: PPUSH
8320: LD_INT 15
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8330: LD_VAR 0 3
8334: PPUSH
8335: LD_INT 67
8337: PPUSH
8338: LD_INT 45
8340: PPUSH
8341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_INT 70
8352: PPUSH
8353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8357: LD_VAR 0 3
8361: PPUSH
8362: LD_INT 69
8364: PPUSH
8365: LD_INT 18
8367: PPUSH
8368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8372: LD_VAR 0 3
8376: PPUSH
8377: LD_INT 60
8379: PPUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8387: LD_INT 35
8389: PPUSH
8390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8394: LD_VAR 0 3
8398: PPUSH
8399: CALL_OW 302
8403: NOT
8404: PUSH
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 17
8412: PPUSH
8413: CALL_OW 308
8417: OR
8418: PUSH
8419: LD_VAR 0 3
8423: PPUSH
8424: LD_INT 60
8426: PPUSH
8427: LD_INT 3
8429: PPUSH
8430: CALL_OW 307
8434: OR
8435: IFFALSE 8387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_INT 17
8444: PPUSH
8445: CALL_OW 308
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 60
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 307
8465: OR
8466: IFFALSE 8477
// RemoveUnit ( un ) ;
8468: LD_VAR 0 3
8472: PPUSH
8473: CALL_OW 64
// end ;
8477: PPOPN 3
8479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8480: LD_EXP 4
8484: IFFALSE 8726
8486: GO 8488
8488: DISABLE
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8494: LD_INT 70
8496: PPUSH
8497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 7
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: LD_INT 101
8518: PUSH
8519: LD_INT 3
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// until tmp ;
8535: LD_VAR 0 3
8539: IFFALSE 8494
// un := NearestUnitToUnit ( tmp , JMM ) ;
8541: LD_ADDR_VAR 0 2
8545: PUSH
8546: LD_VAR 0 3
8550: PPUSH
8551: LD_EXP 16
8555: PPUSH
8556: CALL_OW 74
8560: ST_TO_ADDR
// player_spotted := true ;
8561: LD_ADDR_EXP 6
8565: PUSH
8566: LD_INT 1
8568: ST_TO_ADDR
// tmp := SciRu ;
8569: LD_ADDR_VAR 0 3
8573: PUSH
8574: CALL 13222 0 0
8578: ST_TO_ADDR
// if not tmp then
8579: LD_VAR 0 3
8583: NOT
8584: IFFALSE 8596
// tmp := SolRu ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: CALL 13369 0 0
8595: ST_TO_ADDR
// DialogueOn ;
8596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 250
8609: PPUSH
8610: LD_VAR 0 2
8614: PPUSH
8615: CALL_OW 251
8619: PPUSH
8620: LD_INT 7
8622: PPUSH
8623: LD_INT 8
8625: NEG
8626: PPUSH
8627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8631: LD_VAR 0 2
8635: PPUSH
8636: CALL_OW 87
// if tmp then
8640: LD_VAR 0 3
8644: IFFALSE 8658
// Say ( tmp , D4-RSci1-1 ) ;
8646: LD_VAR 0 3
8650: PPUSH
8651: LD_STRING D4-RSci1-1
8653: PPUSH
8654: CALL_OW 88
// if Gossudarov then
8658: LD_EXP 33
8662: IFFALSE 8688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8664: LD_EXP 33
8668: PPUSH
8669: LD_STRING D4-Gos-1
8671: PPUSH
8672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8676: LD_EXP 16
8680: PPUSH
8681: LD_STRING D4-JMM-1
8683: PPUSH
8684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 250
8697: PPUSH
8698: LD_VAR 0 2
8702: PPUSH
8703: CALL_OW 251
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 331
// DialogueOff ;
8715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8719: LD_STRING M5
8721: PPUSH
8722: CALL_OW 337
// end ;
8726: PPOPN 3
8728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8729: LD_EXP 6
8733: IFFALSE 9326
8735: GO 8737
8737: DISABLE
8738: LD_INT 0
8740: PPUSH
8741: PPUSH
8742: PPUSH
// begin PrepareBelkov ;
8743: CALL 2194 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8747: LD_EXP 48
8751: PPUSH
8752: LD_INT 118
8754: PPUSH
8755: LD_INT 106
8757: PPUSH
8758: CALL_OW 111
// AddComHold ( Belkov ) ;
8762: LD_EXP 48
8766: PPUSH
8767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8778: LD_EXP 48
8782: PPUSH
8783: LD_INT 118
8785: PPUSH
8786: LD_INT 106
8788: PPUSH
8789: CALL_OW 307
8793: IFFALSE 8771
// ChangeSideFog ( 4 , 7 ) ;
8795: LD_INT 4
8797: PPUSH
8798: LD_INT 7
8800: PPUSH
8801: CALL_OW 343
// if IsOk ( Belkov ) then
8805: LD_EXP 48
8809: PPUSH
8810: CALL_OW 302
8814: IFFALSE 8898
// begin InGameOn ;
8816: CALL_OW 8
// DialogueOn ;
8820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8824: LD_EXP 48
8828: PPUSH
8829: LD_STRING D5-Bel-1
8831: PPUSH
8832: CALL_OW 94
// if Gossudarov then
8836: LD_EXP 33
8840: IFFALSE 8890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8842: LD_EXP 33
8846: PPUSH
8847: LD_STRING D5-Gos-1
8849: PPUSH
8850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8854: LD_EXP 16
8858: PPUSH
8859: LD_STRING D5-JMM-1
8861: PPUSH
8862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8866: LD_EXP 33
8870: PPUSH
8871: LD_STRING D5-Gos-2
8873: PPUSH
8874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8878: LD_EXP 16
8882: PPUSH
8883: LD_STRING D5-JMM-2
8885: PPUSH
8886: CALL_OW 88
// end ; DialogueOff ;
8890: CALL_OW 7
// InGameOff ;
8894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8898: LD_STRING QSaveBelkov
8900: PPUSH
8901: CALL_OW 97
8905: PUSH
8906: LD_INT 1
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 8964
8914: POP
// begin DialogueOn ;
8915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8919: LD_EXP 16
8923: PPUSH
8924: LD_STRING D5a-JMM-1
8926: PPUSH
8927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8931: LD_EXP 48
8935: PPUSH
8936: LD_STRING D5a-Bel-1
8938: PPUSH
8939: CALL_OW 94
// DialogueOff ;
8943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8947: LD_EXP 48
8951: PPUSH
8952: LD_INT 83
8954: PPUSH
8955: LD_INT 49
8957: PPUSH
8958: CALL_OW 111
// end ; 2 :
8962: GO 8997
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 8996
8972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8973: LD_EXP 16
8977: PPUSH
8978: LD_STRING D5a-JMM-2
8980: PPUSH
8981: CALL_OW 88
// ComHold ( Belkov ) ;
8985: LD_EXP 48
8989: PPUSH
8990: CALL_OW 140
// end ; end ;
8994: GO 8997
8996: POP
// time := 0 0$00 ;
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// vehSpawned := false ;
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9020: LD_VAR 0 1
9024: PUSH
9025: LD_INT 350
9027: PUSH
9028: LD_INT 175
9030: PUSH
9031: LD_INT 105
9033: PUSH
9034: LD_INT 70
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: LD_OWVAR 67
9047: ARRAY
9048: GREATEREQUAL
9049: PUSH
9050: LD_VAR 0 3
9054: NOT
9055: AND
9056: IFFALSE 9146
// begin vehSpawned := true ;
9058: LD_ADDR_VAR 0 3
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// uc_side := 3 ;
9066: LD_ADDR_OWVAR 20
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// uc_nation := 3 ;
9074: LD_ADDR_OWVAR 21
9078: PUSH
9079: LD_INT 3
9081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9082: LD_INT 22
9084: PPUSH
9085: LD_INT 3
9087: PPUSH
9088: LD_INT 3
9090: PPUSH
9091: LD_INT 43
9093: PPUSH
9094: LD_INT 100
9096: PPUSH
9097: CALL 19679 0 5
// veh := CreateVehicle ;
9101: LD_ADDR_VAR 0 2
9105: PUSH
9106: CALL_OW 45
9110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 130
9118: PPUSH
9119: LD_INT 131
9121: PPUSH
9122: LD_INT 0
9124: PPUSH
9125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_INT 100
9136: PPUSH
9137: LD_INT 82
9139: PPUSH
9140: CALL_OW 114
// end else
9144: GO 9160
// time := time + 0 0$1 ;
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_VAR 0 1
9155: PUSH
9156: LD_INT 35
9158: PLUS
9159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 301
9169: PUSH
9170: LD_EXP 48
9174: PPUSH
9175: CALL_OW 255
9179: PUSH
9180: LD_INT 4
9182: EQUAL
9183: AND
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 74
9209: PPUSH
9210: LD_EXP 48
9214: PPUSH
9215: CALL_OW 296
9219: PUSH
9220: LD_INT 10
9222: LESS
9223: OR
9224: IFFALSE 9013
// if IsDead ( Belkov ) then
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 301
9235: IFFALSE 9260
// begin CenterNowOnUnits ( Belkov ) ;
9237: LD_EXP 48
9241: PPUSH
9242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9246: LD_EXP 16
9250: PPUSH
9251: LD_STRING D5a-JMM-2a
9253: PPUSH
9254: CALL_OW 88
// exit ;
9258: GO 9326
// end ; if See ( 7 , Belkov ) then
9260: LD_INT 7
9262: PPUSH
9263: LD_EXP 48
9267: PPUSH
9268: CALL_OW 292
9272: IFFALSE 9286
// SetSide ( Belkov , 7 ) ;
9274: LD_EXP 48
9278: PPUSH
9279: LD_INT 7
9281: PPUSH
9282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9293: LD_EXP 48
9297: PPUSH
9298: LD_INT 66
9300: PPUSH
9301: LD_INT 45
9303: PPUSH
9304: CALL_OW 297
9308: PUSH
9309: LD_INT 30
9311: LESS
9312: IFFALSE 9286
// Say ( Belkov , D6-Bel-1 ) ;
9314: LD_EXP 48
9318: PPUSH
9319: LD_STRING D6-Bel-1
9321: PPUSH
9322: CALL_OW 88
// end ;
9326: PPOPN 3
9328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 302
9338: PUSH
9339: LD_EXP 48
9343: PPUSH
9344: CALL_OW 504
9348: PUSH
9349: LD_INT 2
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 47
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 34
9364: PUSH
9365: LD_INT 45
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: LIST
9376: PPUSH
9377: CALL_OW 69
9381: IN
9382: AND
9383: IFFALSE 9400
9385: GO 9387
9387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9388: LD_EXP 48
9392: PPUSH
9393: LD_STRING D7-Bel-1
9395: PPUSH
9396: CALL_OW 88
9400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9401: LD_INT 22
9403: PUSH
9404: LD_INT 7
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 101
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 8
9434: NOT
9435: AND
9436: PUSH
9437: LD_EXP 47
9441: PPUSH
9442: CALL_OW 305
9446: NOT
9447: AND
9448: IFFALSE 9918
9450: GO 9452
9452: DISABLE
9453: LD_INT 0
9455: PPUSH
// begin ar_base_spotted := true ;
9456: LD_ADDR_EXP 8
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 21
9481: PUSH
9482: LD_INT 3
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9498: LD_ADDR_VAR 0 1
9502: PUSH
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 16
9512: PPUSH
9513: CALL_OW 74
9517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9518: LD_INT 7
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: CALL_OW 332
// DialogueOn ;
9528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 250
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 251
9551: PPUSH
9552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 22
9563: PUSH
9564: LD_INT 7
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 23
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 26
9583: PUSH
9584: LD_INT 1
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: PUSH
9601: LD_EXP 16
9605: PUSH
9606: LD_EXP 20
9610: PUSH
9611: LD_EXP 21
9615: PUSH
9616: LD_EXP 28
9620: PUSH
9621: LD_EXP 17
9625: PUSH
9626: LD_EXP 26
9630: PUSH
9631: LD_EXP 22
9635: PUSH
9636: LD_EXP 24
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: DIFF
9651: ST_TO_ADDR
// if not tmp then
9652: LD_VAR 0 1
9656: NOT
9657: IFFALSE 9731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9659: LD_ADDR_VAR 0 1
9663: PUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 7
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: LD_INT 26
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: PUSH
9704: LD_EXP 31
9708: PUSH
9709: LD_EXP 18
9713: PUSH
9714: LD_EXP 29
9718: PUSH
9719: LD_EXP 30
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: DIFF
9730: ST_TO_ADDR
// if tmp then
9731: LD_VAR 0 1
9735: IFFALSE 9806
// case GetSex ( tmp [ 1 ] ) of sex_male :
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 1
9744: ARRAY
9745: PPUSH
9746: CALL_OW 258
9750: PUSH
9751: LD_INT 1
9753: DOUBLE
9754: EQUAL
9755: IFTRUE 9759
9757: GO 9778
9759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9760: LD_VAR 0 1
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_STRING D9-Sol1-1
9771: PPUSH
9772: CALL_OW 88
9776: GO 9806
9778: LD_INT 2
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9805
9786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_STRING D9-FSol1-1
9798: PPUSH
9799: CALL_OW 88
9803: GO 9806
9805: POP
// if Frank then
9806: LD_EXP 28
9810: IFFALSE 9914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 250
9821: PPUSH
9822: LD_EXP 57
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: LD_INT 7
9834: PPUSH
9835: LD_INT 8
9837: PPUSH
9838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9842: LD_EXP 57
9846: PPUSH
9847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9851: LD_EXP 28
9855: PPUSH
9856: LD_STRING D9-Frank-1
9858: PPUSH
9859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9863: LD_EXP 16
9867: PPUSH
9868: LD_STRING D9-JMM-1
9870: PPUSH
9871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9875: LD_EXP 28
9879: PPUSH
9880: LD_STRING D9-Frank-2
9882: PPUSH
9883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 250
9896: PPUSH
9897: LD_EXP 57
9901: PPUSH
9902: CALL_OW 251
9906: PPUSH
9907: LD_INT 7
9909: PPUSH
9910: CALL_OW 331
// end ; DialogueOff ;
9914: CALL_OW 7
// end ;
9918: PPOPN 1
9920: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9921: LD_EXP 7
9925: PUSH
9926: LD_OWVAR 1
9930: PUSH
9931: LD_INT 42000
9933: GREATEREQUAL
9934: OR
9935: IFFALSE 10962
9937: GO 9939
9939: DISABLE
9940: LD_INT 0
9942: PPUSH
9943: PPUSH
// begin selected_option := 1 ;
9944: LD_ADDR_VAR 0 2
9948: PUSH
9949: LD_INT 1
9951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9952: LD_INT 10500
9954: PPUSH
9955: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// until not ru_attackers ;
9966: LD_EXP 53
9970: NOT
9971: IFFALSE 9959
// PrepareBurlak ;
9973: CALL 2306 0 0
// repeat wait ( 0 0$2 ) ;
9977: LD_INT 70
9979: PPUSH
9980: CALL_OW 67
// until not HasTask ( Burlak ) ;
9984: LD_EXP 47
9988: PPUSH
9989: CALL_OW 314
9993: NOT
9994: IFFALSE 9977
// InGameOn ;
9996: CALL_OW 8
// DialogueOn ;
10000: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10004: LD_EXP 50
10008: PPUSH
10009: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10013: LD_EXP 47
10017: PPUSH
10018: LD_STRING D10-Bur-1
10020: PPUSH
10021: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10025: LD_EXP 48
10029: PUSH
10030: LD_EXP 48
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 7
10042: EQUAL
10043: AND
10044: IFFALSE 10058
// Say ( Belkov , D10-Bel-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bel-1
10053: PPUSH
10054: CALL_OW 88
// if Gossudarov then
10058: LD_EXP 33
10062: IFFALSE 10076
// Say ( Gossudarov , D10-Gos-1 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D10-Gos-1
10071: PPUSH
10072: CALL_OW 88
// if Kirilenkova then
10076: LD_EXP 34
10080: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-1 ) ;
10082: LD_EXP 34
10086: PPUSH
10087: LD_STRING D10-Kir-1
10089: PPUSH
10090: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10094: CALL 13369 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-1
10101: PPUSH
10102: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10106: LD_EXP 47
10110: PPUSH
10111: LD_STRING D10-Bur-2
10113: PPUSH
10114: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D10-JMM-2
10125: PPUSH
10126: CALL_OW 88
// if Kirilenkova then
10130: LD_EXP 34
10134: IFFALSE 10150
// Say ( Kirilenkova , D10-Kir-2 ) else
10136: LD_EXP 34
10140: PPUSH
10141: LD_STRING D10-Kir-2
10143: PPUSH
10144: CALL_OW 88
10148: GO 10162
// Say ( SolRu , D10-RSol1-2 ) ;
10150: CALL 13369 0 0
10154: PPUSH
10155: LD_STRING D10-RSol1-2
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D10-JMM-3
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10174: LD_EXP 47
10178: PPUSH
10179: LD_STRING D10-Bur-3
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10186: LD_EXP 16
10190: PPUSH
10191: LD_STRING D10-JMM-4
10193: PPUSH
10194: CALL_OW 88
// DialogueOff ;
10198: CALL_OW 7
// InGameOff ;
10202: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10206: LD_STRING M2
10208: PPUSH
10209: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10213: LD_INT 35
10215: PPUSH
10216: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10220: LD_INT 22
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 91
10232: PUSH
10233: LD_EXP 47
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10213
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 4
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10293
// SetSide ( i , 7 ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 235
10291: GO 10276
10293: POP
10294: POP
// ChangeMissionObjectives ( M3 ) ;
10295: LD_STRING M3
10297: PPUSH
10298: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10302: LD_INT 35
10304: PPUSH
10305: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10309: LD_EXP 16
10313: PPUSH
10314: LD_EXP 47
10318: PPUSH
10319: CALL_OW 296
10323: PUSH
10324: LD_INT 8
10326: LESS
10327: IFFALSE 10302
// ComTurnUnit ( JMM , Burlak ) ;
10329: LD_EXP 16
10333: PPUSH
10334: LD_EXP 47
10338: PPUSH
10339: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10343: LD_EXP 47
10347: PPUSH
10348: LD_EXP 16
10352: PPUSH
10353: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10357: LD_INT 10
10359: PPUSH
10360: CALL_OW 67
// DialogueOn ;
10364: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10368: LD_EXP 16
10372: PPUSH
10373: LD_STRING D11-JMM-1
10375: PPUSH
10376: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10380: LD_EXP 47
10384: PPUSH
10385: LD_STRING D11-Bur-1
10387: PPUSH
10388: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10392: LD_EXP 16
10396: PPUSH
10397: LD_STRING D11-JMM-2
10399: PPUSH
10400: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING D11-Bur-2
10411: PPUSH
10412: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10416: LD_EXP 16
10420: PPUSH
10421: LD_STRING D11-JMM-3
10423: PPUSH
10424: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10428: LD_EXP 47
10432: PPUSH
10433: LD_STRING D11-Bur-3
10435: PPUSH
10436: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10440: LD_EXP 16
10444: PPUSH
10445: LD_STRING D11-JMM-4
10447: PPUSH
10448: CALL_OW 88
// if ar_base_spotted then
10452: LD_EXP 8
10456: IFFALSE 10472
// Say ( Burlak , D12-Bur-1 ) else
10458: LD_EXP 47
10462: PPUSH
10463: LD_STRING D12-Bur-1
10465: PPUSH
10466: CALL_OW 88
10470: GO 10511
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10472: LD_INT 7
10474: PPUSH
10475: LD_INT 3
10477: PPUSH
10478: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10482: LD_INT 127
10484: PPUSH
10485: LD_INT 45
10487: PPUSH
10488: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10492: LD_EXP 47
10496: PPUSH
10497: LD_STRING D12-Bur-1a
10499: PPUSH
10500: CALL_OW 88
// dwait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10511: LD_EXP 47
10515: PPUSH
10516: LD_STRING D12-Bur-1b
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10523: LD_EXP 16
10527: PPUSH
10528: LD_STRING D12-JMM-1
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10535: LD_EXP 47
10539: PPUSH
10540: LD_STRING D12-Bur-2
10542: PPUSH
10543: CALL_OW 88
// if Roth then
10547: LD_EXP 17
10551: IFFALSE 10567
// Say ( Roth , D12-Roth-2 ) else
10553: LD_EXP 17
10557: PPUSH
10558: LD_STRING D12-Roth-2
10560: PPUSH
10561: CALL_OW 88
10565: GO 10579
// Say ( SciRu , D12-RSci1-2 ) ;
10567: CALL 13222 0 0
10571: PPUSH
10572: LD_STRING D12-RSci1-2
10574: PPUSH
10575: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10579: LD_EXP 16
10583: PPUSH
10584: LD_STRING D12-JMM-2
10586: PPUSH
10587: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10591: LD_EXP 47
10595: PPUSH
10596: LD_STRING D12-Bur-3
10598: PPUSH
10599: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10603: LD_EXP 16
10607: PPUSH
10608: LD_STRING D12-JMM-3
10610: PPUSH
10611: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10615: LD_EXP 47
10619: PPUSH
10620: LD_STRING D12-Bur-4
10622: PPUSH
10623: CALL_OW 88
// case Query ( QBase ) of 1 :
10627: LD_STRING QBase
10629: PPUSH
10630: CALL_OW 97
10634: PUSH
10635: LD_INT 1
10637: DOUBLE
10638: EQUAL
10639: IFTRUE 10643
10641: GO 10761
10643: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10644: LD_EXP 16
10648: PPUSH
10649: LD_STRING D13a-JMM-1
10651: PPUSH
10652: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10656: LD_EXP 47
10660: PPUSH
10661: LD_STRING D13a-Bur-1
10663: PPUSH
10664: CALL_OW 88
// if Roth then
10668: LD_EXP 17
10672: IFFALSE 10688
// Say ( Roth , D13a-Roth-1 ) else
10674: LD_EXP 17
10678: PPUSH
10679: LD_STRING D13a-Roth-1
10681: PPUSH
10682: CALL_OW 88
10686: GO 10700
// Say ( SciRu , D13a-RSci1-1 ) ;
10688: CALL 13222 0 0
10692: PPUSH
10693: LD_STRING D13a-RSci1-1
10695: PPUSH
10696: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10700: LD_EXP 16
10704: PPUSH
10705: LD_STRING D13a-JMM-2
10707: PPUSH
10708: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10712: LD_STRING QBaseAgain
10714: PPUSH
10715: CALL_OW 97
10719: PUSH
10720: LD_INT 1
10722: DOUBLE
10723: EQUAL
10724: IFTRUE 10728
10726: GO 10739
10728: POP
// selected_option := 2 ; 2 :
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_INT 2
10736: ST_TO_ADDR
10737: GO 10759
10739: LD_INT 2
10741: DOUBLE
10742: EQUAL
10743: IFTRUE 10747
10745: GO 10758
10747: POP
// selected_option := 3 ; end ;
10748: LD_ADDR_VAR 0 2
10752: PUSH
10753: LD_INT 3
10755: ST_TO_ADDR
10756: GO 10759
10758: POP
// end ; 2 :
10759: GO 10800
10761: LD_INT 2
10763: DOUBLE
10764: EQUAL
10765: IFTRUE 10769
10767: GO 10780
10769: POP
// selected_option := 2 ; 3 :
10770: LD_ADDR_VAR 0 2
10774: PUSH
10775: LD_INT 2
10777: ST_TO_ADDR
10778: GO 10800
10780: LD_INT 3
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 10799
10788: POP
// selected_option := 3 ; end ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 3
10796: ST_TO_ADDR
10797: GO 10800
10799: POP
// if selected_option = 2 then
10800: LD_VAR 0 2
10804: PUSH
10805: LD_INT 2
10807: EQUAL
10808: IFFALSE 10902
// begin Say ( JMM , D13b-JMM-1 ) ;
10810: LD_EXP 16
10814: PPUSH
10815: LD_STRING D13b-JMM-1
10817: PPUSH
10818: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10822: LD_EXP 47
10826: PPUSH
10827: LD_STRING D13b-Bur-1
10829: PPUSH
10830: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10834: LD_EXP 16
10838: PPUSH
10839: LD_STRING D13b-JMM-2
10841: PPUSH
10842: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10846: LD_EXP 56
10850: PPUSH
10851: LD_STRING D13b-Abd-2
10853: PPUSH
10854: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10858: LD_EXP 16
10862: PPUSH
10863: LD_STRING D13b-JMM-3
10865: PPUSH
10866: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10870: LD_EXP 56
10874: PPUSH
10875: LD_STRING D13b-Abd-3
10877: PPUSH
10878: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10882: LD_EXP 16
10886: PPUSH
10887: LD_STRING D13b-JMM-4
10889: PPUSH
10890: CALL_OW 88
// ar_active_attack := true ;
10894: LD_ADDR_EXP 9
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// end ; if selected_option = 3 then
10902: LD_VAR 0 2
10906: PUSH
10907: LD_INT 3
10909: EQUAL
10910: IFFALSE 10936
// begin Say ( JMM , D13c-JMM-1 ) ;
10912: LD_EXP 16
10916: PPUSH
10917: LD_STRING D13c-JMM-1
10919: PPUSH
10920: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10924: LD_EXP 47
10928: PPUSH
10929: LD_STRING D13c-Bur-1
10931: PPUSH
10932: CALL_OW 88
// end ; DialogueOff ;
10936: CALL_OW 7
// if not ar_active_attack then
10940: LD_EXP 9
10944: NOT
10945: IFFALSE 10962
// begin wait ( 6 6$00 ) ;
10947: LD_INT 12600
10949: PPUSH
10950: CALL_OW 67
// ar_active_attack := true ;
10954: LD_ADDR_EXP 9
10958: PUSH
10959: LD_INT 1
10961: ST_TO_ADDR
// end ; end ;
10962: PPOPN 2
10964: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 305
10974: PUSH
10975: LD_EXP 47
10979: PPUSH
10980: CALL_OW 255
10984: PUSH
10985: LD_INT 7
10987: EQUAL
10988: AND
10989: IFFALSE 11185
10991: GO 10993
10993: DISABLE
10994: LD_INT 0
10996: PPUSH
// begin wait ( 4 4$40 ) ;
10997: LD_INT 9800
10999: PPUSH
11000: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// until not ru_attackers ;
11011: LD_EXP 53
11015: NOT
11016: IFFALSE 11004
// PrepareGnyevko ;
11018: CALL 2250 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11022: LD_EXP 49
11026: PPUSH
11027: LD_INT 124
11029: PPUSH
11030: LD_INT 118
11032: PPUSH
11033: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11037: LD_EXP 49
11041: PPUSH
11042: CALL_OW 200
// time := 0 0$00 ;
11046: LD_ADDR_VAR 0 1
11050: PUSH
11051: LD_INT 0
11053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// time := time + 0 0$1 ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: LD_INT 35
11073: PLUS
11074: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11075: LD_EXP 49
11079: PPUSH
11080: LD_INT 124
11082: PPUSH
11083: LD_INT 118
11085: PPUSH
11086: CALL_OW 307
11090: PUSH
11091: LD_VAR 0 1
11095: PUSH
11096: LD_INT 1050
11098: GREATEREQUAL
11099: OR
11100: IFFALSE 11054
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11102: LD_EXP 49
11106: PPUSH
11107: LD_STRING DBelkov-Gny-1
11109: PPUSH
11110: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11114: LD_EXP 47
11118: PPUSH
11119: LD_STRING DBelkov-Bur-1a
11121: PPUSH
11122: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11126: LD_INT 35
11128: PPUSH
11129: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11133: LD_EXP 49
11137: PPUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 7
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_EXP 49
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 296
11167: PUSH
11168: LD_INT 8
11170: LESS
11171: IFFALSE 11126
// SetSide ( Gnyevko , 7 ) ;
11173: LD_EXP 49
11177: PPUSH
11178: LD_INT 7
11180: PPUSH
11181: CALL_OW 235
// end ;
11185: PPOPN 1
11187: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11188: LD_EXP 47
11192: PPUSH
11193: CALL_OW 255
11197: PUSH
11198: LD_INT 7
11200: EQUAL
11201: IFFALSE 11211
11203: GO 11205
11205: DISABLE
// begin enable ;
11206: ENABLE
// PrepareAmericanAttack ;
11207: CALL 6853 0 0
// end ;
11211: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11212: LD_INT 22
11214: PUSH
11215: LD_INT 1
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: IFFALSE 11410
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// begin while true do
11235: LD_INT 1
11237: IFFALSE 11294
// begin wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11246: LD_ADDR_VAR 0 2
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PPUSH
11261: CALL_OW 69
11265: PPUSH
11266: LD_EXP 16
11270: PPUSH
11271: CALL_OW 74
11275: ST_TO_ADDR
// if See ( 7 , tmp ) then
11276: LD_INT 7
11278: PPUSH
11279: LD_VAR 0 2
11283: PPUSH
11284: CALL_OW 292
11288: IFFALSE 11292
// break ;
11290: GO 11294
// end ;
11292: GO 11235
// DialogueOn ;
11294: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 250
11316: PPUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PPUSH
11327: LD_INT 7
11329: PPUSH
11330: LD_INT 8
11332: PPUSH
11333: CALL_OW 330
// if Denis then
11337: LD_EXP 22
11341: IFFALSE 11355
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11343: LD_EXP 22
11347: PPUSH
11348: LD_STRING DAmerAttack-Pet-1
11350: PPUSH
11351: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11355: LD_EXP 16
11359: PPUSH
11360: LD_STRING DAmerAttack-JMM-1
11362: PPUSH
11363: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11367: LD_EXP 47
11371: PPUSH
11372: LD_STRING DStop-Bur-1
11374: PPUSH
11375: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 250
11388: PPUSH
11389: LD_VAR 0 2
11393: PPUSH
11394: CALL_OW 251
11398: PPUSH
11399: LD_INT 7
11401: PPUSH
11402: CALL_OW 331
// DialogueOff ;
11406: CALL_OW 7
// end ;
11410: PPOPN 2
11412: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11413: LD_INT 22
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 21
11425: PUSH
11426: LD_INT 1
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PPUSH
11437: CALL_OW 69
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11487
11447: GO 11449
11449: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11450: LD_STRING M5a
11452: PPUSH
11453: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11457: LD_EXP 16
11461: PPUSH
11462: LD_STRING D8-JMM-1
11464: PPUSH
11465: CALL_OW 88
// if Gossudarov then
11469: LD_EXP 33
11473: IFFALSE 11487
// Say ( Gossudarov , D8-Gos-1 ) ;
11475: LD_EXP 33
11479: PPUSH
11480: LD_STRING D8-Gos-1
11482: PPUSH
11483: CALL_OW 88
// end ;
11487: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11488: LD_INT 22
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 21
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: PUSH
11517: LD_INT 0
11519: EQUAL
11520: IFFALSE 11570
11522: GO 11524
11524: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11525: LD_STRING M4c
11527: PPUSH
11528: CALL_OW 337
// if Roth then
11532: LD_EXP 17
11536: IFFALSE 11552
// Say ( Roth , DStop-Roth-1 ) else
11538: LD_EXP 17
11542: PPUSH
11543: LD_STRING DStop-Roth-1
11545: PPUSH
11546: CALL_OW 88
11550: GO 11570
// if Gossudarov then
11552: LD_EXP 33
11556: IFFALSE 11570
// Say ( Gossudarov , D8-Gos-1a ) ;
11558: LD_EXP 33
11562: PPUSH
11563: LD_STRING D8-Gos-1a
11565: PPUSH
11566: CALL_OW 88
// end ;
11570: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11571: LD_INT 7
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 14878 0 3
11584: PUSH
11585: LD_INT 0
11587: EQUAL
11588: PUSH
11589: LD_INT 7
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 1
11597: PPUSH
11598: CALL 14878 0 3
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: AND
11607: IFFALSE 11619
11609: GO 11611
11611: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11612: LD_STRING M1a
11614: PPUSH
11615: CALL_OW 337
// end ;
11619: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11620: LD_INT 22
11622: PUSH
11623: LD_INT 2
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PPUSH
11644: CALL_OW 69
11648: PUSH
11649: LD_INT 0
11651: EQUAL
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 3
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: AND
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 1
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PPUSH
11697: CALL_OW 69
11701: PUSH
11702: LD_INT 0
11704: EQUAL
11705: AND
11706: PUSH
11707: LD_INT 7
11709: PPUSH
11710: LD_INT 1
11712: PPUSH
11713: LD_INT 1
11715: PPUSH
11716: CALL 14878 0 3
11720: PUSH
11721: LD_INT 0
11723: EQUAL
11724: AND
11725: PUSH
11726: LD_INT 7
11728: PPUSH
11729: LD_INT 3
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL 14878 0 3
11739: PUSH
11740: LD_INT 0
11742: EQUAL
11743: AND
11744: IFFALSE 13219
11746: GO 11748
11748: DISABLE
11749: LD_INT 0
11751: PPUSH
11752: PPUSH
11753: PPUSH
11754: PPUSH
11755: PPUSH
11756: PPUSH
// begin m1 := false ;
11757: LD_ADDR_VAR 0 4
11761: PUSH
11762: LD_INT 0
11764: ST_TO_ADDR
// m2 := false ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 0
11772: ST_TO_ADDR
// m3 := false ;
11773: LD_ADDR_VAR 0 6
11777: PUSH
11778: LD_INT 0
11780: ST_TO_ADDR
// if tick < 40 40$00 then
11781: LD_OWVAR 1
11785: PUSH
11786: LD_INT 84000
11788: LESS
11789: IFFALSE 11798
// SetAchievement ( ACH_ASPEED_17 ) ;
11791: LD_STRING ACH_ASPEED_17
11793: PPUSH
11794: CALL_OW 543
// wait ( 0 0$5 ) ;
11798: LD_INT 175
11800: PPUSH
11801: CALL_OW 67
// if not masha_killed then
11805: LD_EXP 10
11809: NOT
11810: IFFALSE 11832
// begin m1 := true ;
11812: LD_ADDR_VAR 0 4
11816: PUSH
11817: LD_INT 1
11819: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11820: LD_STRING Masha
11822: PPUSH
11823: LD_INT 1
11825: PPUSH
11826: CALL_OW 101
// end else
11830: GO 11843
// AddMedal ( Masha , - 1 ) ;
11832: LD_STRING Masha
11834: PPUSH
11835: LD_INT 1
11837: NEG
11838: PPUSH
11839: CALL_OW 101
// if abdul_escaped then
11843: LD_EXP 13
11847: IFFALSE 11862
// AddMedal ( Abdul , - 1 ) else
11849: LD_STRING Abdul
11851: PPUSH
11852: LD_INT 1
11854: NEG
11855: PPUSH
11856: CALL_OW 101
11860: GO 11880
// begin m2 := true ;
11862: LD_ADDR_VAR 0 5
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11870: LD_STRING Abdul
11872: PPUSH
11873: LD_INT 1
11875: PPUSH
11876: CALL_OW 101
// end ; if loss_counter = 0 then
11880: LD_EXP 14
11884: PUSH
11885: LD_INT 0
11887: EQUAL
11888: IFFALSE 11910
// begin m3 := true ;
11890: LD_ADDR_VAR 0 6
11894: PUSH
11895: LD_INT 1
11897: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11898: LD_STRING People
11900: PPUSH
11901: LD_INT 2
11903: PPUSH
11904: CALL_OW 101
// end else
11908: GO 11972
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11910: LD_EXP 14
11914: PUSH
11915: LD_INT 3
11917: PUSH
11918: LD_INT 2
11920: PUSH
11921: LD_INT 2
11923: PUSH
11924: LD_INT 1
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: PUSH
11933: LD_OWVAR 67
11937: ARRAY
11938: LESSEQUAL
11939: IFFALSE 11961
// begin AddMedal ( People , 1 ) ;
11941: LD_STRING People
11943: PPUSH
11944: LD_INT 1
11946: PPUSH
11947: CALL_OW 101
// m3 := true ;
11951: LD_ADDR_VAR 0 6
11955: PUSH
11956: LD_INT 1
11958: ST_TO_ADDR
// end else
11959: GO 11972
// AddMedal ( People , - 1 ) ;
11961: LD_STRING People
11963: PPUSH
11964: LD_INT 1
11966: NEG
11967: PPUSH
11968: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11972: LD_OWVAR 67
11976: PUSH
11977: LD_INT 3
11979: GREATEREQUAL
11980: PUSH
11981: LD_VAR 0 4
11985: AND
11986: PUSH
11987: LD_VAR 0 5
11991: AND
11992: PUSH
11993: LD_VAR 0 6
11997: AND
11998: IFFALSE 12010
// SetAchievementEX ( ACH_AMER , 17 ) ;
12000: LD_STRING ACH_AMER
12002: PPUSH
12003: LD_INT 17
12005: PPUSH
12006: CALL_OW 564
// GiveMedals ( MAIN ) ;
12010: LD_STRING MAIN
12012: PPUSH
12013: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12017: LD_ADDR_VAR 0 2
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 7
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 2
12034: PUSH
12035: LD_INT 25
12037: PUSH
12038: LD_INT 1
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: LD_INT 25
12047: PUSH
12048: LD_INT 2
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 25
12057: PUSH
12058: LD_INT 3
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 25
12067: PUSH
12068: LD_INT 4
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 25
12077: PUSH
12078: LD_INT 5
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: LD_INT 25
12087: PUSH
12088: LD_INT 8
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 25
12097: PUSH
12098: LD_INT 9
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12124: LD_VAR 0 2
12128: PPUSH
12129: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12133: LD_ADDR_VAR 0 3
12137: PUSH
12138: LD_EXP 16
12142: PUSH
12143: LD_EXP 17
12147: PUSH
12148: LD_EXP 18
12152: PUSH
12153: LD_EXP 19
12157: PUSH
12158: LD_EXP 20
12162: PUSH
12163: LD_EXP 21
12167: PUSH
12168: LD_EXP 22
12172: PUSH
12173: LD_EXP 23
12177: PUSH
12178: LD_EXP 24
12182: PUSH
12183: LD_EXP 25
12187: PUSH
12188: LD_EXP 26
12192: PUSH
12193: LD_EXP 27
12197: PUSH
12198: LD_EXP 28
12202: PUSH
12203: LD_EXP 29
12207: PUSH
12208: LD_EXP 30
12212: PUSH
12213: LD_EXP 31
12217: PUSH
12218: LD_EXP 32
12222: PUSH
12223: LD_EXP 33
12227: PUSH
12228: LD_EXP 34
12232: PUSH
12233: LD_EXP 35
12237: PUSH
12238: LD_EXP 37
12242: PUSH
12243: LD_EXP 38
12247: PUSH
12248: LD_EXP 39
12252: PUSH
12253: LD_EXP 40
12257: PUSH
12258: LD_EXP 41
12262: PUSH
12263: LD_EXP 42
12267: PUSH
12268: LD_EXP 43
12272: PUSH
12273: LD_EXP 44
12277: PUSH
12278: LD_EXP 45
12282: PUSH
12283: LD_EXP 46
12287: PUSH
12288: LD_EXP 47
12292: PUSH
12293: LD_EXP 48
12297: PUSH
12298: LD_EXP 49
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: ST_TO_ADDR
// if tmp diff tmp2 then
12338: LD_VAR 0 2
12342: PUSH
12343: LD_VAR 0 3
12347: DIFF
12348: IFFALSE 12368
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12350: LD_VAR 0 2
12354: PUSH
12355: LD_VAR 0 3
12359: DIFF
12360: PPUSH
12361: LD_STRING 13a_others
12363: PPUSH
12364: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12368: LD_EXP 16
12372: PPUSH
12373: LD_STRING 13a_JMM
12375: PPUSH
12376: CALL_OW 38
// if Titov then
12380: LD_EXP 35
12384: IFFALSE 12398
// SaveCharacters ( Titov , 13a_Titov ) ;
12386: LD_EXP 35
12390: PPUSH
12391: LD_STRING 13a_Titov
12393: PPUSH
12394: CALL_OW 38
// if Dolgov then
12398: LD_EXP 37
12402: IFFALSE 12416
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12404: LD_EXP 37
12408: PPUSH
12409: LD_STRING 13a_Dolgov
12411: PPUSH
12412: CALL_OW 38
// if Petrosyan then
12416: LD_EXP 38
12420: IFFALSE 12434
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12422: LD_EXP 38
12426: PPUSH
12427: LD_STRING 13a_Petrosyan
12429: PPUSH
12430: CALL_OW 38
// if Scholtze then
12434: LD_EXP 39
12438: IFFALSE 12452
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12440: LD_EXP 39
12444: PPUSH
12445: LD_STRING 13a_Scholtze
12447: PPUSH
12448: CALL_OW 38
// if Oblukov then
12452: LD_EXP 40
12456: IFFALSE 12470
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12458: LD_EXP 40
12462: PPUSH
12463: LD_STRING 13a_Oblukov
12465: PPUSH
12466: CALL_OW 38
// if Kapitsova then
12470: LD_EXP 41
12474: IFFALSE 12488
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12476: LD_EXP 41
12480: PPUSH
12481: LD_STRING 13a_Kapitsova
12483: PPUSH
12484: CALL_OW 38
// if Lipshchin then
12488: LD_EXP 42
12492: IFFALSE 12506
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12494: LD_EXP 42
12498: PPUSH
12499: LD_STRING 13a_Lipshchin
12501: PPUSH
12502: CALL_OW 38
// if Petrovova then
12506: LD_EXP 43
12510: IFFALSE 12524
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12512: LD_EXP 43
12516: PPUSH
12517: LD_STRING 13a_Petrovova
12519: PPUSH
12520: CALL_OW 38
// if Kovalyuk then
12524: LD_EXP 44
12528: IFFALSE 12542
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12530: LD_EXP 44
12534: PPUSH
12535: LD_STRING 13a_Kovalyuk
12537: PPUSH
12538: CALL_OW 38
// if Kuzmov then
12542: LD_EXP 45
12546: IFFALSE 12560
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12548: LD_EXP 45
12552: PPUSH
12553: LD_STRING 13a_Kuzmov
12555: PPUSH
12556: CALL_OW 38
// if Karamazov then
12560: LD_EXP 46
12564: IFFALSE 12578
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12566: LD_EXP 46
12570: PPUSH
12571: LD_STRING 13a_Karamazov
12573: PPUSH
12574: CALL_OW 38
// if Burlak then
12578: LD_EXP 47
12582: IFFALSE 12596
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12584: LD_EXP 47
12588: PPUSH
12589: LD_STRING 13a_Burlak
12591: PPUSH
12592: CALL_OW 38
// if Belkov then
12596: LD_EXP 48
12600: IFFALSE 12614
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12602: LD_EXP 48
12606: PPUSH
12607: LD_STRING 13a_Belkov
12609: PPUSH
12610: CALL_OW 38
// if Gnyevko then
12614: LD_EXP 49
12618: IFFALSE 12632
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12620: LD_EXP 49
12624: PPUSH
12625: LD_STRING 13a_Gnyevko
12627: PPUSH
12628: CALL_OW 38
// if Lisa then
12632: LD_EXP 18
12636: IFFALSE 12650
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12638: LD_EXP 18
12642: PPUSH
12643: LD_STRING 13a_Lisa
12645: PPUSH
12646: CALL_OW 38
// if Donaldson then
12650: LD_EXP 19
12654: IFFALSE 12668
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12656: LD_EXP 19
12660: PPUSH
12661: LD_STRING 13a_Donaldson
12663: PPUSH
12664: CALL_OW 38
// if Bobby then
12668: LD_EXP 20
12672: IFFALSE 12686
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12674: LD_EXP 20
12678: PPUSH
12679: LD_STRING 13a_Bobby
12681: PPUSH
12682: CALL_OW 38
// if Cyrus then
12686: LD_EXP 21
12690: IFFALSE 12704
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12692: LD_EXP 21
12696: PPUSH
12697: LD_STRING 13a_Cyrus
12699: PPUSH
12700: CALL_OW 38
// if Denis then
12704: LD_EXP 22
12708: IFFALSE 12722
// SaveCharacters ( Denis , 13a_Denis ) ;
12710: LD_EXP 22
12714: PPUSH
12715: LD_STRING 13a_Denis
12717: PPUSH
12718: CALL_OW 38
// if Brown then
12722: LD_EXP 23
12726: IFFALSE 12740
// SaveCharacters ( Brown , 13a_Brown ) ;
12728: LD_EXP 23
12732: PPUSH
12733: LD_STRING 13a_Brown
12735: PPUSH
12736: CALL_OW 38
// if Gladstone then
12740: LD_EXP 24
12744: IFFALSE 12758
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12746: LD_EXP 24
12750: PPUSH
12751: LD_STRING 13a_Gladstone
12753: PPUSH
12754: CALL_OW 38
// if Houten then
12758: LD_EXP 25
12762: IFFALSE 12776
// SaveCharacters ( Houten , 13a_Houten ) ;
12764: LD_EXP 25
12768: PPUSH
12769: LD_STRING 13a_Houten
12771: PPUSH
12772: CALL_OW 38
// if Cornel then
12776: LD_EXP 26
12780: IFFALSE 12794
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12782: LD_EXP 26
12786: PPUSH
12787: LD_STRING 13a_Cornel
12789: PPUSH
12790: CALL_OW 38
// if Gary then
12794: LD_EXP 27
12798: IFFALSE 12812
// SaveCharacters ( Gary , 13a_Gary ) ;
12800: LD_EXP 27
12804: PPUSH
12805: LD_STRING 13a_Gary
12807: PPUSH
12808: CALL_OW 38
// if Frank then
12812: LD_EXP 28
12816: IFFALSE 12830
// SaveCharacters ( Frank , 13a_Frank ) ;
12818: LD_EXP 28
12822: PPUSH
12823: LD_STRING 13a_Frank
12825: PPUSH
12826: CALL_OW 38
// if Kikuchi then
12830: LD_EXP 29
12834: IFFALSE 12848
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12836: LD_EXP 29
12840: PPUSH
12841: LD_STRING 13a_Kikuchi
12843: PPUSH
12844: CALL_OW 38
// if Simms then
12848: LD_EXP 30
12852: IFFALSE 12866
// SaveCharacters ( Simms , 13a_Simms ) ;
12854: LD_EXP 30
12858: PPUSH
12859: LD_STRING 13a_Simms
12861: PPUSH
12862: CALL_OW 38
// if Joan then
12866: LD_EXP 31
12870: IFFALSE 12884
// SaveCharacters ( Joan , 13a_Joan ) ;
12872: LD_EXP 31
12876: PPUSH
12877: LD_STRING 13a_Joan
12879: PPUSH
12880: CALL_OW 38
// if DeltaDoctor then
12884: LD_EXP 32
12888: IFFALSE 12902
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12890: LD_EXP 32
12894: PPUSH
12895: LD_STRING 13a_DeltaDoctor
12897: PPUSH
12898: CALL_OW 38
// if Gossudarov then
12902: LD_EXP 33
12906: IFFALSE 12920
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12908: LD_EXP 33
12912: PPUSH
12913: LD_STRING 13a_Gossudarov
12915: PPUSH
12916: CALL_OW 38
// if Kirilenkova then
12920: LD_EXP 34
12924: IFFALSE 12938
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12926: LD_EXP 34
12930: PPUSH
12931: LD_STRING 13a_Kirilenkova
12933: PPUSH
12934: CALL_OW 38
// if Roth then
12938: LD_EXP 17
12942: IFFALSE 12956
// SaveCharacters ( Roth , 13a_Roth ) ;
12944: LD_EXP 17
12948: PPUSH
12949: LD_STRING 13a_Roth
12951: PPUSH
12952: CALL_OW 38
// if Masha then
12956: LD_EXP 50
12960: IFFALSE 13015
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12962: LD_EXP 50
12966: PPUSH
12967: CALL_OW 265
12971: PUSH
12972: LD_EXP 50
12976: PPUSH
12977: CALL_OW 262
12981: PUSH
12982: LD_EXP 50
12986: PPUSH
12987: CALL_OW 263
12991: PUSH
12992: LD_EXP 50
12996: PPUSH
12997: CALL_OW 264
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PPUSH
13008: LD_STRING 13a_Masha
13010: PPUSH
13011: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13015: LD_ADDR_VAR 0 2
13019: PUSH
13020: LD_INT 21
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PPUSH
13030: CALL_OW 69
13034: ST_TO_ADDR
// tmp2 := [ ] ;
13035: LD_ADDR_VAR 0 3
13039: PUSH
13040: EMPTY
13041: ST_TO_ADDR
// if tmp then
13042: LD_VAR 0 2
13046: IFFALSE 13197
// for i in tmp do
13048: LD_ADDR_VAR 0 1
13052: PUSH
13053: LD_VAR 0 2
13057: PUSH
13058: FOR_IN
13059: IFFALSE 13195
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: LD_VAR 0 3
13070: PUSH
13071: LD_VAR 0 1
13075: PPUSH
13076: CALL_OW 255
13080: PUSH
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 248
13090: PUSH
13091: LD_VAR 0 1
13095: PPUSH
13096: CALL_OW 266
13100: PUSH
13101: LD_VAR 0 1
13105: PPUSH
13106: CALL_OW 250
13110: PUSH
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 251
13120: PUSH
13121: LD_VAR 0 1
13125: PPUSH
13126: CALL_OW 254
13130: PUSH
13131: LD_VAR 0 1
13135: PPUSH
13136: CALL_OW 267
13140: PUSH
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_INT 1
13148: PPUSH
13149: CALL_OW 268
13153: PUSH
13154: LD_VAR 0 1
13158: PPUSH
13159: LD_INT 2
13161: PPUSH
13162: CALL_OW 268
13166: PUSH
13167: LD_VAR 0 1
13171: PPUSH
13172: CALL_OW 269
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: EMPTY
13190: LIST
13191: ADD
13192: ST_TO_ADDR
13193: GO 13058
13195: POP
13196: POP
// if tmp2 then
13197: LD_VAR 0 3
13201: IFFALSE 13215
// SaveVariable ( tmp2 , 13a_buildings ) ;
13203: LD_VAR 0 3
13207: PPUSH
13208: LD_STRING 13a_buildings
13210: PPUSH
13211: CALL_OW 39
// YouWin ;
13215: CALL_OW 103
// end ;
13219: PPOPN 6
13221: END
// export function SciRu ; var tmp , t ; begin
13222: LD_INT 0
13224: PPUSH
13225: PPUSH
13226: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_EXP 33
13236: PUSH
13237: LD_EXP 47
13241: PUSH
13242: LD_EXP 35
13246: PUSH
13247: LD_EXP 48
13251: PUSH
13252: LD_EXP 49
13256: PUSH
13257: LD_EXP 38
13261: PUSH
13262: LD_EXP 39
13266: PUSH
13267: LD_EXP 37
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13282: LD_ADDR_VAR 0 2
13286: PUSH
13287: LD_INT 22
13289: PUSH
13290: LD_INT 7
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 23
13299: PUSH
13300: LD_INT 3
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 25
13309: PUSH
13310: LD_INT 4
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PUSH
13317: LD_INT 26
13319: PUSH
13320: LD_INT 1
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 69
13337: PUSH
13338: LD_VAR 0 3
13342: DIFF
13343: ST_TO_ADDR
// if tmp then
13344: LD_VAR 0 2
13348: IFFALSE 13364
// result := tmp [ 1 ] ;
13350: LD_ADDR_VAR 0 1
13354: PUSH
13355: LD_VAR 0 2
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: ST_TO_ADDR
// end ;
13364: LD_VAR 0 1
13368: RET
// export function SolRu ; var tmp , t ; begin
13369: LD_INT 0
13371: PPUSH
13372: PPUSH
13373: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13374: LD_ADDR_VAR 0 3
13378: PUSH
13379: LD_EXP 33
13383: PUSH
13384: LD_EXP 47
13388: PUSH
13389: LD_EXP 35
13393: PUSH
13394: LD_EXP 48
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: LD_EXP 38
13408: PUSH
13409: LD_EXP 39
13413: PUSH
13414: LD_EXP 37
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: LD_INT 22
13436: PUSH
13437: LD_INT 7
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: LD_INT 23
13446: PUSH
13447: LD_INT 3
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 25
13456: PUSH
13457: LD_INT 1
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 26
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: PUSH
13485: LD_VAR 0 3
13489: DIFF
13490: ST_TO_ADDR
// if tmp then
13491: LD_VAR 0 2
13495: IFFALSE 13511
// result := tmp [ 1 ] ;
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: LD_INT 1
13509: ARRAY
13510: ST_TO_ADDR
// end ; end_of_file
13511: LD_VAR 0 1
13515: RET
// export function CustomEvent ( event ) ; begin
13516: LD_INT 0
13518: PPUSH
// end ;
13519: LD_VAR 0 2
13523: RET
// on UnitDestroyed ( un ) do var i , side ;
13524: LD_INT 0
13526: PPUSH
13527: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13528: LD_VAR 0 1
13532: PUSH
13533: LD_INT 22
13535: PUSH
13536: LD_INT 7
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 2
13545: PUSH
13546: LD_INT 25
13548: PUSH
13549: LD_INT 1
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 25
13558: PUSH
13559: LD_INT 2
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 3
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 25
13578: PUSH
13579: LD_INT 4
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: LD_INT 25
13588: PUSH
13589: LD_INT 5
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 25
13598: PUSH
13599: LD_INT 8
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 25
13608: PUSH
13609: LD_INT 9
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: IN
13635: IFFALSE 13651
// loss_counter := loss_counter + 1 ;
13637: LD_ADDR_EXP 14
13641: PUSH
13642: LD_EXP 14
13646: PUSH
13647: LD_INT 1
13649: PLUS
13650: ST_TO_ADDR
// if un = Abdul then
13651: LD_VAR 0 1
13655: PUSH
13656: LD_EXP 56
13660: EQUAL
13661: IFFALSE 13671
// abdul_escaped := false ;
13663: LD_ADDR_EXP 13
13667: PUSH
13668: LD_INT 0
13670: ST_TO_ADDR
// if un in ru_attackers then
13671: LD_VAR 0 1
13675: PUSH
13676: LD_EXP 53
13680: IN
13681: IFFALSE 13699
// ru_attackers := ru_attackers diff un ;
13683: LD_ADDR_EXP 53
13687: PUSH
13688: LD_EXP 53
13692: PUSH
13693: LD_VAR 0 1
13697: DIFF
13698: ST_TO_ADDR
// if un in ar_attackers then
13699: LD_VAR 0 1
13703: PUSH
13704: LD_EXP 11
13708: IN
13709: IFFALSE 13727
// ar_attackers := ar_attackers diff un ;
13711: LD_ADDR_EXP 11
13715: PUSH
13716: LD_EXP 11
13720: PUSH
13721: LD_VAR 0 1
13725: DIFF
13726: ST_TO_ADDR
// if un = JMM then
13727: LD_VAR 0 1
13731: PUSH
13732: LD_EXP 16
13736: EQUAL
13737: IFFALSE 13748
// begin YouLost ( JMM ) ;
13739: LD_STRING JMM
13741: PPUSH
13742: CALL_OW 104
// exit ;
13746: GO 13845
// end ; if un = Burlak then
13748: LD_VAR 0 1
13752: PUSH
13753: LD_EXP 47
13757: EQUAL
13758: IFFALSE 13769
// begin YouLost ( Burlak ) ;
13760: LD_STRING Burlak
13762: PPUSH
13763: CALL_OW 104
// exit ;
13767: GO 13845
// end ; if un = freedom then
13769: LD_VAR 0 1
13773: PUSH
13774: LD_EXP 3
13778: EQUAL
13779: IFFALSE 13790
// begin YouLost ( Destroyed ) ;
13781: LD_STRING Destroyed
13783: PPUSH
13784: CALL_OW 104
// exit ;
13788: GO 13845
// end ; if un = Masha then
13790: LD_VAR 0 1
13794: PUSH
13795: LD_EXP 50
13799: EQUAL
13800: IFFALSE 13817
// begin ChangeMissionObjectives ( M4b ) ;
13802: LD_STRING M4b
13804: PPUSH
13805: CALL_OW 337
// masha_killed := true ;
13809: LD_ADDR_EXP 10
13813: PUSH
13814: LD_INT 1
13816: ST_TO_ADDR
// end ; if un = Mastodont then
13817: LD_VAR 0 1
13821: PUSH
13822: LD_EXP 57
13826: EQUAL
13827: IFFALSE 13836
// ChangeMissionObjectives ( M4a ) ;
13829: LD_STRING M4a
13831: PPUSH
13832: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13836: LD_VAR 0 1
13840: PPUSH
13841: CALL 82010 0 1
// end ;
13845: PPOPN 3
13847: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13848: LD_VAR 0 1
13852: PPUSH
13853: LD_VAR 0 2
13857: PPUSH
13858: CALL 84344 0 2
// end ;
13862: PPOPN 2
13864: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13865: LD_VAR 0 1
13869: PPUSH
13870: CALL 83412 0 1
// end ;
13874: PPOPN 1
13876: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13877: LD_VAR 0 1
13881: PUSH
13882: LD_INT 22
13884: PUSH
13885: LD_INT 7
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: LD_INT 30
13894: PUSH
13895: LD_INT 0
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PPUSH
13906: CALL_OW 69
13910: IN
13911: IFFALSE 13950
// begin SetBName ( building , freedom ) ;
13913: LD_VAR 0 1
13917: PPUSH
13918: LD_STRING freedom
13920: PPUSH
13921: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13925: LD_INT 0
13927: PPUSH
13928: LD_INT 7
13930: PPUSH
13931: LD_INT 0
13933: PPUSH
13934: CALL_OW 324
// freedom := building ;
13938: LD_ADDR_EXP 3
13942: PUSH
13943: LD_VAR 0 1
13947: ST_TO_ADDR
// exit ;
13948: GO 14016
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13950: LD_VAR 0 1
13954: PUSH
13955: LD_INT 22
13957: PUSH
13958: LD_INT 7
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 3
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: LD_INT 30
13977: PUSH
13978: LD_INT 6
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: LIST
13989: PPUSH
13990: CALL_OW 69
13994: IN
13995: IFFALSE 14007
// begin ru_lab_builded := true ;
13997: LD_ADDR_EXP 5
14001: PUSH
14002: LD_INT 1
14004: ST_TO_ADDR
// exit ;
14005: GO 14016
// end ; MCE_BuildingComplete ( building ) ;
14007: LD_VAR 0 1
14011: PPUSH
14012: CALL 83653 0 1
// end ;
14016: PPOPN 1
14018: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14019: LD_VAR 0 1
14023: PPUSH
14024: LD_VAR 0 2
14028: PPUSH
14029: CALL 81706 0 2
// end ;
14033: PPOPN 2
14035: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14036: LD_VAR 0 1
14040: PPUSH
14041: LD_VAR 0 2
14045: PPUSH
14046: LD_VAR 0 3
14050: PPUSH
14051: LD_VAR 0 4
14055: PPUSH
14056: LD_VAR 0 5
14060: PPUSH
14061: CALL 81326 0 5
// end ;
14065: PPOPN 5
14067: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14068: LD_VAR 0 1
14072: PPUSH
14073: LD_VAR 0 2
14077: PPUSH
14078: CALL 80907 0 2
// end ;
14082: PPOPN 2
14084: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14085: LD_VAR 0 1
14089: PPUSH
14090: CALL_OW 263
14094: PUSH
14095: LD_INT 3
14097: EQUAL
14098: PUSH
14099: LD_VAR 0 2
14103: PPUSH
14104: CALL_OW 263
14108: PUSH
14109: LD_INT 3
14111: EQUAL
14112: OR
14113: IFFALSE 14129
// hack_counter := hack_counter + 1 ;
14115: LD_ADDR_EXP 15
14119: PUSH
14120: LD_EXP 15
14124: PUSH
14125: LD_INT 1
14127: PLUS
14128: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14129: LD_VAR 0 1
14133: PPUSH
14134: LD_VAR 0 2
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: LD_VAR 0 4
14148: PPUSH
14149: CALL 80745 0 4
// end ;
14153: PPOPN 4
14155: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14156: LD_VAR 0 1
14160: PPUSH
14161: LD_VAR 0 2
14165: PPUSH
14166: LD_VAR 0 3
14170: PPUSH
14171: CALL 80520 0 3
// end ;
14175: PPOPN 3
14177: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14178: LD_VAR 0 1
14182: PPUSH
14183: LD_VAR 0 2
14187: PPUSH
14188: CALL 80405 0 2
// end ;
14192: PPOPN 2
14194: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14195: LD_VAR 0 1
14199: PPUSH
14200: LD_VAR 0 2
14204: PPUSH
14205: CALL 84639 0 2
// end ;
14209: PPOPN 2
14211: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14212: LD_VAR 0 1
14216: PPUSH
14217: LD_VAR 0 2
14221: PPUSH
14222: LD_VAR 0 3
14226: PPUSH
14227: LD_VAR 0 4
14231: PPUSH
14232: CALL 84855 0 4
// end ;
14236: PPOPN 4
14238: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14239: LD_VAR 0 1
14243: PPUSH
14244: LD_VAR 0 2
14248: PPUSH
14249: CALL 80214 0 2
// end ;
14253: PPOPN 2
14255: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14256: LD_VAR 0 1
14260: PPUSH
14261: CALL 99055 0 1
// end ; end_of_file
14265: PPOPN 1
14267: END
// every 0 0$30 do var cr , time ;
14268: GO 14270
14270: DISABLE
14271: LD_INT 0
14273: PPUSH
14274: PPUSH
// begin time := 0 0$20 ;
14275: LD_ADDR_VAR 0 2
14279: PUSH
14280: LD_INT 700
14282: ST_TO_ADDR
// while game do
14283: LD_EXP 2
14287: IFFALSE 14390
// begin wait ( time ) ;
14289: LD_VAR 0 2
14293: PPUSH
14294: CALL_OW 67
// if tick > 2 2$00 then
14298: LD_OWVAR 1
14302: PUSH
14303: LD_INT 4200
14305: GREATER
14306: IFFALSE 14343
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14308: LD_ADDR_VAR 0 2
14312: PUSH
14313: LD_VAR 0 2
14317: PUSH
14318: LD_INT 140
14320: PUSH
14321: LD_INT 140
14323: PUSH
14324: LD_INT 210
14326: PUSH
14327: LD_INT 280
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: PUSH
14336: LD_OWVAR 67
14340: ARRAY
14341: PLUS
14342: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14343: LD_INT 1
14345: PPUSH
14346: LD_INT 5
14348: PPUSH
14349: CALL_OW 12
14353: PPUSH
14354: LD_INT 70
14356: PPUSH
14357: LD_INT 49
14359: PPUSH
14360: LD_INT 25
14362: PPUSH
14363: LD_INT 1
14365: PPUSH
14366: CALL_OW 56
// if time > 3 3$00 then
14370: LD_VAR 0 2
14374: PUSH
14375: LD_INT 6300
14377: GREATER
14378: IFFALSE 14388
// time := 0 0$30 ;
14380: LD_ADDR_VAR 0 2
14384: PUSH
14385: LD_INT 1050
14387: ST_TO_ADDR
// end ;
14388: GO 14283
// end ;
14390: PPOPN 2
14392: END
// every 0 0$30 do var cr , time ;
14393: GO 14395
14395: DISABLE
14396: LD_INT 0
14398: PPUSH
14399: PPUSH
// begin time := 0 0$20 ;
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: LD_INT 700
14407: ST_TO_ADDR
// while game do
14408: LD_EXP 2
14412: IFFALSE 14505
// begin wait ( time ) ;
14414: LD_VAR 0 2
14418: PPUSH
14419: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14423: LD_ADDR_VAR 0 2
14427: PUSH
14428: LD_VAR 0 2
14432: PUSH
14433: LD_INT 140
14435: PUSH
14436: LD_INT 175
14438: PUSH
14439: LD_INT 210
14441: PUSH
14442: LD_INT 280
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: PUSH
14451: LD_OWVAR 67
14455: ARRAY
14456: PLUS
14457: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14458: LD_INT 3
14460: PPUSH
14461: LD_INT 5
14463: PPUSH
14464: CALL_OW 12
14468: PPUSH
14469: LD_INT 26
14471: PPUSH
14472: LD_INT 9
14474: PPUSH
14475: LD_INT 30
14477: PPUSH
14478: LD_INT 1
14480: PPUSH
14481: CALL_OW 56
// if time > 3 3$00 then
14485: LD_VAR 0 2
14489: PUSH
14490: LD_INT 6300
14492: GREATER
14493: IFFALSE 14503
// time := 0 0$20 ;
14495: LD_ADDR_VAR 0 2
14499: PUSH
14500: LD_INT 700
14502: ST_TO_ADDR
// end ;
14503: GO 14408
// end ;
14505: PPOPN 2
14507: END
// every 0 0$30 do var cr , time ;
14508: GO 14510
14510: DISABLE
14511: LD_INT 0
14513: PPUSH
14514: PPUSH
// begin time := 0 0$20 ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_INT 700
14522: ST_TO_ADDR
// while game do
14523: LD_EXP 2
14527: IFFALSE 14656
// begin wait ( time ) ;
14529: LD_VAR 0 2
14533: PPUSH
14534: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14538: LD_ADDR_VAR 0 2
14542: PUSH
14543: LD_VAR 0 2
14547: PUSH
14548: LD_INT 175
14550: PUSH
14551: LD_INT 210
14553: PUSH
14554: LD_INT 280
14556: PUSH
14557: LD_INT 350
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: PUSH
14566: LD_OWVAR 67
14570: ARRAY
14571: PLUS
14572: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14573: LD_INT 1
14575: PPUSH
14576: LD_INT 5
14578: PPUSH
14579: CALL_OW 12
14583: PPUSH
14584: LD_INT 179
14586: PPUSH
14587: LD_INT 101
14589: PPUSH
14590: LD_INT 20
14592: PPUSH
14593: LD_INT 1
14595: PPUSH
14596: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14600: LD_INT 350
14602: PPUSH
14603: LD_INT 525
14605: PPUSH
14606: CALL_OW 12
14610: PPUSH
14611: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14615: LD_INT 1
14617: PPUSH
14618: LD_INT 5
14620: PPUSH
14621: CALL_OW 12
14625: PPUSH
14626: LD_INT 9
14628: PPUSH
14629: LD_INT 1
14631: PPUSH
14632: CALL_OW 55
// if time > 4 4$00 then
14636: LD_VAR 0 2
14640: PUSH
14641: LD_INT 8400
14643: GREATER
14644: IFFALSE 14654
// time := 0 0$30 ;
14646: LD_ADDR_VAR 0 2
14650: PUSH
14651: LD_INT 1050
14653: ST_TO_ADDR
// end ;
14654: GO 14523
// end ;
14656: PPOPN 2
14658: END
// every 0 0$30 do var cr , time ;
14659: GO 14661
14661: DISABLE
14662: LD_INT 0
14664: PPUSH
14665: PPUSH
// begin time := 0 0$10 ;
14666: LD_ADDR_VAR 0 2
14670: PUSH
14671: LD_INT 350
14673: ST_TO_ADDR
// while game do
14674: LD_EXP 2
14678: IFFALSE 14812
// begin wait ( time ) ;
14680: LD_VAR 0 2
14684: PPUSH
14685: CALL_OW 67
// time := time + 0 0$10 ;
14689: LD_ADDR_VAR 0 2
14693: PUSH
14694: LD_VAR 0 2
14698: PUSH
14699: LD_INT 350
14701: PLUS
14702: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14703: LD_INT 1
14705: PPUSH
14706: LD_INT 5
14708: PPUSH
14709: CALL_OW 12
14713: PPUSH
14714: LD_INT 11
14716: PPUSH
14717: LD_INT 1
14719: PPUSH
14720: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14724: LD_ADDR_VAR 0 1
14728: PUSH
14729: LD_INT 1
14731: PPUSH
14732: LD_INT 3
14734: PPUSH
14735: CALL_OW 12
14739: ST_TO_ADDR
// if cr = 1 then
14740: LD_VAR 0 1
14744: PUSH
14745: LD_INT 1
14747: EQUAL
14748: IFFALSE 14792
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14750: LD_INT 700
14752: PPUSH
14753: LD_INT 1575
14755: PPUSH
14756: CALL_OW 12
14760: PPUSH
14761: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14765: LD_INT 1
14767: PPUSH
14768: LD_INT 5
14770: PPUSH
14771: CALL_OW 12
14775: PPUSH
14776: LD_INT 34
14778: PPUSH
14779: LD_INT 50
14781: PPUSH
14782: LD_INT 7
14784: PPUSH
14785: LD_INT 1
14787: PPUSH
14788: CALL_OW 56
// end ; if time > 4 4$00 then
14792: LD_VAR 0 2
14796: PUSH
14797: LD_INT 8400
14799: GREATER
14800: IFFALSE 14810
// time := 0 0$40 ;
14802: LD_ADDR_VAR 0 2
14806: PUSH
14807: LD_INT 1400
14809: ST_TO_ADDR
// end ;
14810: GO 14674
// end ; end_of_file
14812: PPOPN 2
14814: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14815: LD_INT 0
14817: PPUSH
14818: PPUSH
// if exist_mode then
14819: LD_VAR 0 2
14823: IFFALSE 14848
// unit := CreateCharacter ( prefix & ident ) else
14825: LD_ADDR_VAR 0 5
14829: PUSH
14830: LD_VAR 0 3
14834: PUSH
14835: LD_VAR 0 1
14839: STR
14840: PPUSH
14841: CALL_OW 34
14845: ST_TO_ADDR
14846: GO 14863
// unit := NewCharacter ( ident ) ;
14848: LD_ADDR_VAR 0 5
14852: PUSH
14853: LD_VAR 0 1
14857: PPUSH
14858: CALL_OW 25
14862: ST_TO_ADDR
// result := unit ;
14863: LD_ADDR_VAR 0 4
14867: PUSH
14868: LD_VAR 0 5
14872: ST_TO_ADDR
// end ;
14873: LD_VAR 0 4
14877: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14878: LD_INT 0
14880: PPUSH
14881: PPUSH
// if not side or not nation then
14882: LD_VAR 0 1
14886: NOT
14887: PUSH
14888: LD_VAR 0 2
14892: NOT
14893: OR
14894: IFFALSE 14898
// exit ;
14896: GO 15666
// case nation of nation_american :
14898: LD_VAR 0 2
14902: PUSH
14903: LD_INT 1
14905: DOUBLE
14906: EQUAL
14907: IFTRUE 14911
14909: GO 15125
14911: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14912: LD_ADDR_VAR 0 4
14916: PUSH
14917: LD_INT 35
14919: PUSH
14920: LD_INT 45
14922: PUSH
14923: LD_INT 46
14925: PUSH
14926: LD_INT 47
14928: PUSH
14929: LD_INT 82
14931: PUSH
14932: LD_INT 83
14934: PUSH
14935: LD_INT 84
14937: PUSH
14938: LD_INT 85
14940: PUSH
14941: LD_INT 86
14943: PUSH
14944: LD_INT 1
14946: PUSH
14947: LD_INT 2
14949: PUSH
14950: LD_INT 6
14952: PUSH
14953: LD_INT 15
14955: PUSH
14956: LD_INT 16
14958: PUSH
14959: LD_INT 7
14961: PUSH
14962: LD_INT 12
14964: PUSH
14965: LD_INT 13
14967: PUSH
14968: LD_INT 10
14970: PUSH
14971: LD_INT 14
14973: PUSH
14974: LD_INT 20
14976: PUSH
14977: LD_INT 21
14979: PUSH
14980: LD_INT 22
14982: PUSH
14983: LD_INT 25
14985: PUSH
14986: LD_INT 32
14988: PUSH
14989: LD_INT 27
14991: PUSH
14992: LD_INT 36
14994: PUSH
14995: LD_INT 69
14997: PUSH
14998: LD_INT 39
15000: PUSH
15001: LD_INT 34
15003: PUSH
15004: LD_INT 40
15006: PUSH
15007: LD_INT 48
15009: PUSH
15010: LD_INT 49
15012: PUSH
15013: LD_INT 50
15015: PUSH
15016: LD_INT 51
15018: PUSH
15019: LD_INT 52
15021: PUSH
15022: LD_INT 53
15024: PUSH
15025: LD_INT 54
15027: PUSH
15028: LD_INT 55
15030: PUSH
15031: LD_INT 56
15033: PUSH
15034: LD_INT 57
15036: PUSH
15037: LD_INT 58
15039: PUSH
15040: LD_INT 59
15042: PUSH
15043: LD_INT 60
15045: PUSH
15046: LD_INT 61
15048: PUSH
15049: LD_INT 62
15051: PUSH
15052: LD_INT 80
15054: PUSH
15055: LD_INT 82
15057: PUSH
15058: LD_INT 83
15060: PUSH
15061: LD_INT 84
15063: PUSH
15064: LD_INT 85
15066: PUSH
15067: LD_INT 86
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: LIST
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: LIST
15122: ST_TO_ADDR
15123: GO 15590
15125: LD_INT 2
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15359
15133: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15134: LD_ADDR_VAR 0 4
15138: PUSH
15139: LD_INT 35
15141: PUSH
15142: LD_INT 45
15144: PUSH
15145: LD_INT 46
15147: PUSH
15148: LD_INT 47
15150: PUSH
15151: LD_INT 82
15153: PUSH
15154: LD_INT 83
15156: PUSH
15157: LD_INT 84
15159: PUSH
15160: LD_INT 85
15162: PUSH
15163: LD_INT 87
15165: PUSH
15166: LD_INT 70
15168: PUSH
15169: LD_INT 1
15171: PUSH
15172: LD_INT 11
15174: PUSH
15175: LD_INT 3
15177: PUSH
15178: LD_INT 4
15180: PUSH
15181: LD_INT 5
15183: PUSH
15184: LD_INT 6
15186: PUSH
15187: LD_INT 15
15189: PUSH
15190: LD_INT 18
15192: PUSH
15193: LD_INT 7
15195: PUSH
15196: LD_INT 17
15198: PUSH
15199: LD_INT 8
15201: PUSH
15202: LD_INT 20
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 22
15210: PUSH
15211: LD_INT 72
15213: PUSH
15214: LD_INT 26
15216: PUSH
15217: LD_INT 69
15219: PUSH
15220: LD_INT 39
15222: PUSH
15223: LD_INT 40
15225: PUSH
15226: LD_INT 41
15228: PUSH
15229: LD_INT 42
15231: PUSH
15232: LD_INT 43
15234: PUSH
15235: LD_INT 48
15237: PUSH
15238: LD_INT 49
15240: PUSH
15241: LD_INT 50
15243: PUSH
15244: LD_INT 51
15246: PUSH
15247: LD_INT 52
15249: PUSH
15250: LD_INT 53
15252: PUSH
15253: LD_INT 54
15255: PUSH
15256: LD_INT 55
15258: PUSH
15259: LD_INT 56
15261: PUSH
15262: LD_INT 60
15264: PUSH
15265: LD_INT 61
15267: PUSH
15268: LD_INT 62
15270: PUSH
15271: LD_INT 66
15273: PUSH
15274: LD_INT 67
15276: PUSH
15277: LD_INT 68
15279: PUSH
15280: LD_INT 81
15282: PUSH
15283: LD_INT 82
15285: PUSH
15286: LD_INT 83
15288: PUSH
15289: LD_INT 84
15291: PUSH
15292: LD_INT 85
15294: PUSH
15295: LD_INT 87
15297: PUSH
15298: LD_INT 88
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: LIST
15317: LIST
15318: LIST
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: LIST
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: ST_TO_ADDR
15357: GO 15590
15359: LD_INT 3
15361: DOUBLE
15362: EQUAL
15363: IFTRUE 15367
15365: GO 15589
15367: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15368: LD_ADDR_VAR 0 4
15372: PUSH
15373: LD_INT 46
15375: PUSH
15376: LD_INT 47
15378: PUSH
15379: LD_INT 1
15381: PUSH
15382: LD_INT 2
15384: PUSH
15385: LD_INT 82
15387: PUSH
15388: LD_INT 83
15390: PUSH
15391: LD_INT 84
15393: PUSH
15394: LD_INT 85
15396: PUSH
15397: LD_INT 86
15399: PUSH
15400: LD_INT 11
15402: PUSH
15403: LD_INT 9
15405: PUSH
15406: LD_INT 20
15408: PUSH
15409: LD_INT 19
15411: PUSH
15412: LD_INT 21
15414: PUSH
15415: LD_INT 24
15417: PUSH
15418: LD_INT 22
15420: PUSH
15421: LD_INT 25
15423: PUSH
15424: LD_INT 28
15426: PUSH
15427: LD_INT 29
15429: PUSH
15430: LD_INT 30
15432: PUSH
15433: LD_INT 31
15435: PUSH
15436: LD_INT 37
15438: PUSH
15439: LD_INT 38
15441: PUSH
15442: LD_INT 32
15444: PUSH
15445: LD_INT 27
15447: PUSH
15448: LD_INT 33
15450: PUSH
15451: LD_INT 69
15453: PUSH
15454: LD_INT 39
15456: PUSH
15457: LD_INT 34
15459: PUSH
15460: LD_INT 40
15462: PUSH
15463: LD_INT 71
15465: PUSH
15466: LD_INT 23
15468: PUSH
15469: LD_INT 44
15471: PUSH
15472: LD_INT 48
15474: PUSH
15475: LD_INT 49
15477: PUSH
15478: LD_INT 50
15480: PUSH
15481: LD_INT 51
15483: PUSH
15484: LD_INT 52
15486: PUSH
15487: LD_INT 53
15489: PUSH
15490: LD_INT 54
15492: PUSH
15493: LD_INT 55
15495: PUSH
15496: LD_INT 56
15498: PUSH
15499: LD_INT 57
15501: PUSH
15502: LD_INT 58
15504: PUSH
15505: LD_INT 59
15507: PUSH
15508: LD_INT 63
15510: PUSH
15511: LD_INT 64
15513: PUSH
15514: LD_INT 65
15516: PUSH
15517: LD_INT 82
15519: PUSH
15520: LD_INT 83
15522: PUSH
15523: LD_INT 84
15525: PUSH
15526: LD_INT 85
15528: PUSH
15529: LD_INT 86
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: LIST
15544: LIST
15545: LIST
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: LIST
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: ST_TO_ADDR
15587: GO 15590
15589: POP
// if state > - 1 and state < 3 then
15590: LD_VAR 0 3
15594: PUSH
15595: LD_INT 1
15597: NEG
15598: GREATER
15599: PUSH
15600: LD_VAR 0 3
15604: PUSH
15605: LD_INT 3
15607: LESS
15608: AND
15609: IFFALSE 15666
// for i in result do
15611: LD_ADDR_VAR 0 5
15615: PUSH
15616: LD_VAR 0 4
15620: PUSH
15621: FOR_IN
15622: IFFALSE 15664
// if GetTech ( i , side ) <> state then
15624: LD_VAR 0 5
15628: PPUSH
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 321
15638: PUSH
15639: LD_VAR 0 3
15643: NONEQUAL
15644: IFFALSE 15662
// result := result diff i ;
15646: LD_ADDR_VAR 0 4
15650: PUSH
15651: LD_VAR 0 4
15655: PUSH
15656: LD_VAR 0 5
15660: DIFF
15661: ST_TO_ADDR
15662: GO 15621
15664: POP
15665: POP
// end ;
15666: LD_VAR 0 4
15670: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15671: LD_INT 0
15673: PPUSH
15674: PPUSH
15675: PPUSH
// result := true ;
15676: LD_ADDR_VAR 0 3
15680: PUSH
15681: LD_INT 1
15683: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15684: LD_ADDR_VAR 0 5
15688: PUSH
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 480
15698: ST_TO_ADDR
// if not tmp then
15699: LD_VAR 0 5
15703: NOT
15704: IFFALSE 15708
// exit ;
15706: GO 15757
// for i in tmp do
15708: LD_ADDR_VAR 0 4
15712: PUSH
15713: LD_VAR 0 5
15717: PUSH
15718: FOR_IN
15719: IFFALSE 15755
// if GetTech ( i , side ) <> state_researched then
15721: LD_VAR 0 4
15725: PPUSH
15726: LD_VAR 0 1
15730: PPUSH
15731: CALL_OW 321
15735: PUSH
15736: LD_INT 2
15738: NONEQUAL
15739: IFFALSE 15753
// begin result := false ;
15741: LD_ADDR_VAR 0 3
15745: PUSH
15746: LD_INT 0
15748: ST_TO_ADDR
// exit ;
15749: POP
15750: POP
15751: GO 15757
// end ;
15753: GO 15718
15755: POP
15756: POP
// end ;
15757: LD_VAR 0 3
15761: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15762: LD_INT 0
15764: PPUSH
15765: PPUSH
15766: PPUSH
15767: PPUSH
15768: PPUSH
15769: PPUSH
15770: PPUSH
15771: PPUSH
15772: PPUSH
15773: PPUSH
15774: PPUSH
15775: PPUSH
15776: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15777: LD_VAR 0 1
15781: NOT
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 257
15792: PUSH
15793: LD_INT 9
15795: NONEQUAL
15796: OR
15797: IFFALSE 15801
// exit ;
15799: GO 16374
// side := GetSide ( unit ) ;
15801: LD_ADDR_VAR 0 9
15805: PUSH
15806: LD_VAR 0 1
15810: PPUSH
15811: CALL_OW 255
15815: ST_TO_ADDR
// tech_space := tech_spacanom ;
15816: LD_ADDR_VAR 0 12
15820: PUSH
15821: LD_INT 29
15823: ST_TO_ADDR
// tech_time := tech_taurad ;
15824: LD_ADDR_VAR 0 13
15828: PUSH
15829: LD_INT 28
15831: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15832: LD_ADDR_VAR 0 11
15836: PUSH
15837: LD_VAR 0 1
15841: PPUSH
15842: CALL_OW 310
15846: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15847: LD_VAR 0 11
15851: PPUSH
15852: CALL_OW 247
15856: PUSH
15857: LD_INT 2
15859: EQUAL
15860: IFFALSE 15864
// exit ;
15862: GO 16374
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15864: LD_ADDR_VAR 0 8
15868: PUSH
15869: LD_INT 81
15871: PUSH
15872: LD_VAR 0 9
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: LD_INT 21
15886: PUSH
15887: LD_INT 3
15889: PUSH
15890: EMPTY
15891: LIST
15892: LIST
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PPUSH
15902: CALL_OW 69
15906: ST_TO_ADDR
// if not tmp then
15907: LD_VAR 0 8
15911: NOT
15912: IFFALSE 15916
// exit ;
15914: GO 16374
// if in_unit then
15916: LD_VAR 0 11
15920: IFFALSE 15944
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15922: LD_ADDR_VAR 0 10
15926: PUSH
15927: LD_VAR 0 8
15931: PPUSH
15932: LD_VAR 0 11
15936: PPUSH
15937: CALL_OW 74
15941: ST_TO_ADDR
15942: GO 15964
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15944: LD_ADDR_VAR 0 10
15948: PUSH
15949: LD_VAR 0 8
15953: PPUSH
15954: LD_VAR 0 1
15958: PPUSH
15959: CALL_OW 74
15963: ST_TO_ADDR
// if not enemy then
15964: LD_VAR 0 10
15968: NOT
15969: IFFALSE 15973
// exit ;
15971: GO 16374
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15973: LD_VAR 0 11
15977: PUSH
15978: LD_VAR 0 11
15982: PPUSH
15983: LD_VAR 0 10
15987: PPUSH
15988: CALL_OW 296
15992: PUSH
15993: LD_INT 13
15995: GREATER
15996: AND
15997: PUSH
15998: LD_VAR 0 1
16002: PPUSH
16003: LD_VAR 0 10
16007: PPUSH
16008: CALL_OW 296
16012: PUSH
16013: LD_INT 12
16015: GREATER
16016: OR
16017: IFFALSE 16021
// exit ;
16019: GO 16374
// missile := [ 1 ] ;
16021: LD_ADDR_VAR 0 14
16025: PUSH
16026: LD_INT 1
16028: PUSH
16029: EMPTY
16030: LIST
16031: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16032: LD_VAR 0 9
16036: PPUSH
16037: LD_VAR 0 12
16041: PPUSH
16042: CALL_OW 325
16046: IFFALSE 16075
// missile := Insert ( missile , missile + 1 , 2 ) ;
16048: LD_ADDR_VAR 0 14
16052: PUSH
16053: LD_VAR 0 14
16057: PPUSH
16058: LD_VAR 0 14
16062: PUSH
16063: LD_INT 1
16065: PLUS
16066: PPUSH
16067: LD_INT 2
16069: PPUSH
16070: CALL_OW 2
16074: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16075: LD_VAR 0 9
16079: PPUSH
16080: LD_VAR 0 13
16084: PPUSH
16085: CALL_OW 325
16089: PUSH
16090: LD_VAR 0 10
16094: PPUSH
16095: CALL_OW 255
16099: PPUSH
16100: LD_VAR 0 13
16104: PPUSH
16105: CALL_OW 325
16109: NOT
16110: AND
16111: IFFALSE 16140
// missile := Insert ( missile , missile + 1 , 3 ) ;
16113: LD_ADDR_VAR 0 14
16117: PUSH
16118: LD_VAR 0 14
16122: PPUSH
16123: LD_VAR 0 14
16127: PUSH
16128: LD_INT 1
16130: PLUS
16131: PPUSH
16132: LD_INT 3
16134: PPUSH
16135: CALL_OW 2
16139: ST_TO_ADDR
// if missile < 2 then
16140: LD_VAR 0 14
16144: PUSH
16145: LD_INT 2
16147: LESS
16148: IFFALSE 16152
// exit ;
16150: GO 16374
// x := GetX ( enemy ) ;
16152: LD_ADDR_VAR 0 4
16156: PUSH
16157: LD_VAR 0 10
16161: PPUSH
16162: CALL_OW 250
16166: ST_TO_ADDR
// y := GetY ( enemy ) ;
16167: LD_ADDR_VAR 0 5
16171: PUSH
16172: LD_VAR 0 10
16176: PPUSH
16177: CALL_OW 251
16181: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16182: LD_ADDR_VAR 0 6
16186: PUSH
16187: LD_VAR 0 4
16191: PUSH
16192: LD_INT 1
16194: NEG
16195: PPUSH
16196: LD_INT 1
16198: PPUSH
16199: CALL_OW 12
16203: PLUS
16204: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16205: LD_ADDR_VAR 0 7
16209: PUSH
16210: LD_VAR 0 5
16214: PUSH
16215: LD_INT 1
16217: NEG
16218: PPUSH
16219: LD_INT 1
16221: PPUSH
16222: CALL_OW 12
16226: PLUS
16227: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16228: LD_VAR 0 6
16232: PPUSH
16233: LD_VAR 0 7
16237: PPUSH
16238: CALL_OW 488
16242: NOT
16243: IFFALSE 16265
// begin _x := x ;
16245: LD_ADDR_VAR 0 6
16249: PUSH
16250: LD_VAR 0 4
16254: ST_TO_ADDR
// _y := y ;
16255: LD_ADDR_VAR 0 7
16259: PUSH
16260: LD_VAR 0 5
16264: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16265: LD_ADDR_VAR 0 3
16269: PUSH
16270: LD_INT 1
16272: PPUSH
16273: LD_VAR 0 14
16277: PPUSH
16278: CALL_OW 12
16282: ST_TO_ADDR
// case i of 1 :
16283: LD_VAR 0 3
16287: PUSH
16288: LD_INT 1
16290: DOUBLE
16291: EQUAL
16292: IFTRUE 16296
16294: GO 16313
16296: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16297: LD_VAR 0 1
16301: PPUSH
16302: LD_VAR 0 10
16306: PPUSH
16307: CALL_OW 115
16311: GO 16374
16313: LD_INT 2
16315: DOUBLE
16316: EQUAL
16317: IFTRUE 16321
16319: GO 16343
16321: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16322: LD_VAR 0 1
16326: PPUSH
16327: LD_VAR 0 6
16331: PPUSH
16332: LD_VAR 0 7
16336: PPUSH
16337: CALL_OW 153
16341: GO 16374
16343: LD_INT 3
16345: DOUBLE
16346: EQUAL
16347: IFTRUE 16351
16349: GO 16373
16351: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16352: LD_VAR 0 1
16356: PPUSH
16357: LD_VAR 0 6
16361: PPUSH
16362: LD_VAR 0 7
16366: PPUSH
16367: CALL_OW 154
16371: GO 16374
16373: POP
// end ;
16374: LD_VAR 0 2
16378: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16379: LD_INT 0
16381: PPUSH
16382: PPUSH
16383: PPUSH
16384: PPUSH
16385: PPUSH
16386: PPUSH
// if not unit or not building then
16387: LD_VAR 0 1
16391: NOT
16392: PUSH
16393: LD_VAR 0 2
16397: NOT
16398: OR
16399: IFFALSE 16403
// exit ;
16401: GO 16561
// x := GetX ( building ) ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_VAR 0 2
16412: PPUSH
16413: CALL_OW 250
16417: ST_TO_ADDR
// y := GetY ( building ) ;
16418: LD_ADDR_VAR 0 6
16422: PUSH
16423: LD_VAR 0 2
16427: PPUSH
16428: CALL_OW 251
16432: ST_TO_ADDR
// for i = 0 to 5 do
16433: LD_ADDR_VAR 0 4
16437: PUSH
16438: DOUBLE
16439: LD_INT 0
16441: DEC
16442: ST_TO_ADDR
16443: LD_INT 5
16445: PUSH
16446: FOR_TO
16447: IFFALSE 16559
// begin _x := ShiftX ( x , i , 3 ) ;
16449: LD_ADDR_VAR 0 7
16453: PUSH
16454: LD_VAR 0 5
16458: PPUSH
16459: LD_VAR 0 4
16463: PPUSH
16464: LD_INT 3
16466: PPUSH
16467: CALL_OW 272
16471: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16472: LD_ADDR_VAR 0 8
16476: PUSH
16477: LD_VAR 0 6
16481: PPUSH
16482: LD_VAR 0 4
16486: PPUSH
16487: LD_INT 3
16489: PPUSH
16490: CALL_OW 273
16494: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16495: LD_VAR 0 7
16499: PPUSH
16500: LD_VAR 0 8
16504: PPUSH
16505: CALL_OW 488
16509: NOT
16510: IFFALSE 16514
// continue ;
16512: GO 16446
// if HexInfo ( _x , _y ) = 0 then
16514: LD_VAR 0 7
16518: PPUSH
16519: LD_VAR 0 8
16523: PPUSH
16524: CALL_OW 428
16528: PUSH
16529: LD_INT 0
16531: EQUAL
16532: IFFALSE 16557
// begin ComMoveXY ( unit , _x , _y ) ;
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_VAR 0 7
16543: PPUSH
16544: LD_VAR 0 8
16548: PPUSH
16549: CALL_OW 111
// exit ;
16553: POP
16554: POP
16555: GO 16561
// end ; end ;
16557: GO 16446
16559: POP
16560: POP
// end ;
16561: LD_VAR 0 3
16565: RET
// export function ScanBase ( side , base_area ) ; begin
16566: LD_INT 0
16568: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16569: LD_ADDR_VAR 0 3
16573: PUSH
16574: LD_VAR 0 2
16578: PPUSH
16579: LD_INT 81
16581: PUSH
16582: LD_VAR 0 1
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 70
16595: ST_TO_ADDR
// end ;
16596: LD_VAR 0 3
16600: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16601: LD_INT 0
16603: PPUSH
16604: PPUSH
16605: PPUSH
16606: PPUSH
// result := false ;
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: LD_INT 0
16614: ST_TO_ADDR
// side := GetSide ( unit ) ;
16615: LD_ADDR_VAR 0 3
16619: PUSH
16620: LD_VAR 0 1
16624: PPUSH
16625: CALL_OW 255
16629: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16630: LD_ADDR_VAR 0 4
16634: PUSH
16635: LD_VAR 0 1
16639: PPUSH
16640: CALL_OW 248
16644: ST_TO_ADDR
// case nat of 1 :
16645: LD_VAR 0 4
16649: PUSH
16650: LD_INT 1
16652: DOUBLE
16653: EQUAL
16654: IFTRUE 16658
16656: GO 16669
16658: POP
// tech := tech_lassight ; 2 :
16659: LD_ADDR_VAR 0 5
16663: PUSH
16664: LD_INT 12
16666: ST_TO_ADDR
16667: GO 16708
16669: LD_INT 2
16671: DOUBLE
16672: EQUAL
16673: IFTRUE 16677
16675: GO 16688
16677: POP
// tech := tech_mortar ; 3 :
16678: LD_ADDR_VAR 0 5
16682: PUSH
16683: LD_INT 41
16685: ST_TO_ADDR
16686: GO 16708
16688: LD_INT 3
16690: DOUBLE
16691: EQUAL
16692: IFTRUE 16696
16694: GO 16707
16696: POP
// tech := tech_bazooka ; end ;
16697: LD_ADDR_VAR 0 5
16701: PUSH
16702: LD_INT 44
16704: ST_TO_ADDR
16705: GO 16708
16707: POP
// if Researched ( side , tech ) then
16708: LD_VAR 0 3
16712: PPUSH
16713: LD_VAR 0 5
16717: PPUSH
16718: CALL_OW 325
16722: IFFALSE 16749
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16724: LD_ADDR_VAR 0 2
16728: PUSH
16729: LD_INT 5
16731: PUSH
16732: LD_INT 8
16734: PUSH
16735: LD_INT 9
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: LIST
16742: PUSH
16743: LD_VAR 0 4
16747: ARRAY
16748: ST_TO_ADDR
// end ;
16749: LD_VAR 0 2
16753: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16754: LD_INT 0
16756: PPUSH
16757: PPUSH
16758: PPUSH
// if not mines then
16759: LD_VAR 0 2
16763: NOT
16764: IFFALSE 16768
// exit ;
16766: GO 16912
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16768: LD_ADDR_VAR 0 5
16772: PUSH
16773: LD_INT 81
16775: PUSH
16776: LD_VAR 0 1
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: PUSH
16785: LD_INT 3
16787: PUSH
16788: LD_INT 21
16790: PUSH
16791: LD_INT 3
16793: PUSH
16794: EMPTY
16795: LIST
16796: LIST
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 69
16810: ST_TO_ADDR
// for i in mines do
16811: LD_ADDR_VAR 0 4
16815: PUSH
16816: LD_VAR 0 2
16820: PUSH
16821: FOR_IN
16822: IFFALSE 16910
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16824: LD_VAR 0 4
16828: PUSH
16829: LD_INT 1
16831: ARRAY
16832: PPUSH
16833: LD_VAR 0 4
16837: PUSH
16838: LD_INT 2
16840: ARRAY
16841: PPUSH
16842: CALL_OW 458
16846: NOT
16847: IFFALSE 16851
// continue ;
16849: GO 16821
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16851: LD_VAR 0 4
16855: PUSH
16856: LD_INT 1
16858: ARRAY
16859: PPUSH
16860: LD_VAR 0 4
16864: PUSH
16865: LD_INT 2
16867: ARRAY
16868: PPUSH
16869: CALL_OW 428
16873: PUSH
16874: LD_VAR 0 5
16878: IN
16879: IFFALSE 16908
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16881: LD_VAR 0 4
16885: PUSH
16886: LD_INT 1
16888: ARRAY
16889: PPUSH
16890: LD_VAR 0 4
16894: PUSH
16895: LD_INT 2
16897: ARRAY
16898: PPUSH
16899: LD_VAR 0 1
16903: PPUSH
16904: CALL_OW 456
// end ;
16908: GO 16821
16910: POP
16911: POP
// end ;
16912: LD_VAR 0 3
16916: RET
// export function Count ( array ) ; var i ; begin
16917: LD_INT 0
16919: PPUSH
16920: PPUSH
// result := 0 ;
16921: LD_ADDR_VAR 0 2
16925: PUSH
16926: LD_INT 0
16928: ST_TO_ADDR
// for i in array do
16929: LD_ADDR_VAR 0 3
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: FOR_IN
16940: IFFALSE 16964
// if i then
16942: LD_VAR 0 3
16946: IFFALSE 16962
// result := result + 1 ;
16948: LD_ADDR_VAR 0 2
16952: PUSH
16953: LD_VAR 0 2
16957: PUSH
16958: LD_INT 1
16960: PLUS
16961: ST_TO_ADDR
16962: GO 16939
16964: POP
16965: POP
// end ;
16966: LD_VAR 0 2
16970: RET
// export function IsEmpty ( building ) ; begin
16971: LD_INT 0
16973: PPUSH
// if not building then
16974: LD_VAR 0 1
16978: NOT
16979: IFFALSE 16983
// exit ;
16981: GO 17026
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_VAR 0 1
16992: PUSH
16993: LD_INT 22
16995: PUSH
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 255
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: LD_INT 58
17012: PUSH
17013: EMPTY
17014: LIST
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: IN
17025: ST_TO_ADDR
// end ;
17026: LD_VAR 0 2
17030: RET
// export function IsNotFull ( building ) ; begin
17031: LD_INT 0
17033: PPUSH
// if not building then
17034: LD_VAR 0 1
17038: NOT
17039: IFFALSE 17043
// exit ;
17041: GO 17062
// result := UnitsInside ( building ) < 6 ;
17043: LD_ADDR_VAR 0 2
17047: PUSH
17048: LD_VAR 0 1
17052: PPUSH
17053: CALL_OW 313
17057: PUSH
17058: LD_INT 6
17060: LESS
17061: ST_TO_ADDR
// end ;
17062: LD_VAR 0 2
17066: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17067: LD_INT 0
17069: PPUSH
17070: PPUSH
17071: PPUSH
17072: PPUSH
// tmp := [ ] ;
17073: LD_ADDR_VAR 0 3
17077: PUSH
17078: EMPTY
17079: ST_TO_ADDR
// list := [ ] ;
17080: LD_ADDR_VAR 0 5
17084: PUSH
17085: EMPTY
17086: ST_TO_ADDR
// for i = 16 to 25 do
17087: LD_ADDR_VAR 0 4
17091: PUSH
17092: DOUBLE
17093: LD_INT 16
17095: DEC
17096: ST_TO_ADDR
17097: LD_INT 25
17099: PUSH
17100: FOR_TO
17101: IFFALSE 17174
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17103: LD_ADDR_VAR 0 3
17107: PUSH
17108: LD_VAR 0 3
17112: PUSH
17113: LD_INT 22
17115: PUSH
17116: LD_VAR 0 1
17120: PPUSH
17121: CALL_OW 255
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: LD_INT 91
17132: PUSH
17133: LD_VAR 0 1
17137: PUSH
17138: LD_INT 6
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: LIST
17145: PUSH
17146: LD_INT 30
17148: PUSH
17149: LD_VAR 0 4
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: PPUSH
17166: CALL_OW 69
17170: ADD
17171: ST_TO_ADDR
17172: GO 17100
17174: POP
17175: POP
// for i = 1 to tmp do
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: DOUBLE
17182: LD_INT 1
17184: DEC
17185: ST_TO_ADDR
17186: LD_VAR 0 3
17190: PUSH
17191: FOR_TO
17192: IFFALSE 17280
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17194: LD_ADDR_VAR 0 5
17198: PUSH
17199: LD_VAR 0 5
17203: PUSH
17204: LD_VAR 0 3
17208: PUSH
17209: LD_VAR 0 4
17213: ARRAY
17214: PPUSH
17215: CALL_OW 266
17219: PUSH
17220: LD_VAR 0 3
17224: PUSH
17225: LD_VAR 0 4
17229: ARRAY
17230: PPUSH
17231: CALL_OW 250
17235: PUSH
17236: LD_VAR 0 3
17240: PUSH
17241: LD_VAR 0 4
17245: ARRAY
17246: PPUSH
17247: CALL_OW 251
17251: PUSH
17252: LD_VAR 0 3
17256: PUSH
17257: LD_VAR 0 4
17261: ARRAY
17262: PPUSH
17263: CALL_OW 254
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: ADD
17277: ST_TO_ADDR
17278: GO 17191
17280: POP
17281: POP
// result := list ;
17282: LD_ADDR_VAR 0 2
17286: PUSH
17287: LD_VAR 0 5
17291: ST_TO_ADDR
// end ;
17292: LD_VAR 0 2
17296: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17297: LD_INT 0
17299: PPUSH
17300: PPUSH
17301: PPUSH
17302: PPUSH
17303: PPUSH
17304: PPUSH
17305: PPUSH
// if not factory then
17306: LD_VAR 0 1
17310: NOT
17311: IFFALSE 17315
// exit ;
17313: GO 17908
// if control = control_apeman then
17315: LD_VAR 0 4
17319: PUSH
17320: LD_INT 5
17322: EQUAL
17323: IFFALSE 17432
// begin tmp := UnitsInside ( factory ) ;
17325: LD_ADDR_VAR 0 8
17329: PUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: CALL_OW 313
17339: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17340: LD_VAR 0 8
17344: PPUSH
17345: LD_INT 25
17347: PUSH
17348: LD_INT 12
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: PPUSH
17355: CALL_OW 72
17359: NOT
17360: IFFALSE 17370
// control := control_manual ;
17362: LD_ADDR_VAR 0 4
17366: PUSH
17367: LD_INT 1
17369: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17370: LD_ADDR_VAR 0 8
17374: PUSH
17375: LD_VAR 0 1
17379: PPUSH
17380: CALL 17067 0 1
17384: ST_TO_ADDR
// if tmp then
17385: LD_VAR 0 8
17389: IFFALSE 17432
// begin for i in tmp do
17391: LD_ADDR_VAR 0 7
17395: PUSH
17396: LD_VAR 0 8
17400: PUSH
17401: FOR_IN
17402: IFFALSE 17430
// if i [ 1 ] = b_ext_radio then
17404: LD_VAR 0 7
17408: PUSH
17409: LD_INT 1
17411: ARRAY
17412: PUSH
17413: LD_INT 22
17415: EQUAL
17416: IFFALSE 17428
// begin control := control_remote ;
17418: LD_ADDR_VAR 0 4
17422: PUSH
17423: LD_INT 2
17425: ST_TO_ADDR
// break ;
17426: GO 17430
// end ;
17428: GO 17401
17430: POP
17431: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17432: LD_VAR 0 1
17436: PPUSH
17437: LD_VAR 0 2
17441: PPUSH
17442: LD_VAR 0 3
17446: PPUSH
17447: LD_VAR 0 4
17451: PPUSH
17452: LD_VAR 0 5
17456: PPUSH
17457: CALL_OW 448
17461: IFFALSE 17496
// begin result := [ chassis , engine , control , weapon ] ;
17463: LD_ADDR_VAR 0 6
17467: PUSH
17468: LD_VAR 0 2
17472: PUSH
17473: LD_VAR 0 3
17477: PUSH
17478: LD_VAR 0 4
17482: PUSH
17483: LD_VAR 0 5
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: LIST
17492: LIST
17493: ST_TO_ADDR
// exit ;
17494: GO 17908
// end ; _chassis := AvailableChassisList ( factory ) ;
17496: LD_ADDR_VAR 0 9
17500: PUSH
17501: LD_VAR 0 1
17505: PPUSH
17506: CALL_OW 475
17510: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17511: LD_ADDR_VAR 0 11
17515: PUSH
17516: LD_VAR 0 1
17520: PPUSH
17521: CALL_OW 476
17525: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17526: LD_ADDR_VAR 0 12
17530: PUSH
17531: LD_VAR 0 1
17535: PPUSH
17536: CALL_OW 477
17540: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17541: LD_ADDR_VAR 0 10
17545: PUSH
17546: LD_VAR 0 1
17550: PPUSH
17551: CALL_OW 478
17555: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17556: LD_VAR 0 9
17560: NOT
17561: PUSH
17562: LD_VAR 0 11
17566: NOT
17567: OR
17568: PUSH
17569: LD_VAR 0 12
17573: NOT
17574: OR
17575: PUSH
17576: LD_VAR 0 10
17580: NOT
17581: OR
17582: IFFALSE 17617
// begin result := [ chassis , engine , control , weapon ] ;
17584: LD_ADDR_VAR 0 6
17588: PUSH
17589: LD_VAR 0 2
17593: PUSH
17594: LD_VAR 0 3
17598: PUSH
17599: LD_VAR 0 4
17603: PUSH
17604: LD_VAR 0 5
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: LIST
17614: ST_TO_ADDR
// exit ;
17615: GO 17908
// end ; if not chassis in _chassis then
17617: LD_VAR 0 2
17621: PUSH
17622: LD_VAR 0 9
17626: IN
17627: NOT
17628: IFFALSE 17654
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17630: LD_ADDR_VAR 0 2
17634: PUSH
17635: LD_VAR 0 9
17639: PUSH
17640: LD_INT 1
17642: PPUSH
17643: LD_VAR 0 9
17647: PPUSH
17648: CALL_OW 12
17652: ARRAY
17653: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17654: LD_VAR 0 2
17658: PPUSH
17659: LD_VAR 0 3
17663: PPUSH
17664: CALL 17913 0 2
17668: NOT
17669: IFFALSE 17728
// repeat engine := _engine [ 1 ] ;
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_VAR 0 11
17680: PUSH
17681: LD_INT 1
17683: ARRAY
17684: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17685: LD_ADDR_VAR 0 11
17689: PUSH
17690: LD_VAR 0 11
17694: PPUSH
17695: LD_INT 1
17697: PPUSH
17698: CALL_OW 3
17702: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17703: LD_VAR 0 2
17707: PPUSH
17708: LD_VAR 0 3
17712: PPUSH
17713: CALL 17913 0 2
17717: PUSH
17718: LD_VAR 0 11
17722: PUSH
17723: EMPTY
17724: EQUAL
17725: OR
17726: IFFALSE 17671
// if not control in _control then
17728: LD_VAR 0 4
17732: PUSH
17733: LD_VAR 0 12
17737: IN
17738: NOT
17739: IFFALSE 17765
// control := _control [ rand ( 1 , _control ) ] ;
17741: LD_ADDR_VAR 0 4
17745: PUSH
17746: LD_VAR 0 12
17750: PUSH
17751: LD_INT 1
17753: PPUSH
17754: LD_VAR 0 12
17758: PPUSH
17759: CALL_OW 12
17763: ARRAY
17764: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17765: LD_VAR 0 2
17769: PPUSH
17770: LD_VAR 0 5
17774: PPUSH
17775: CALL 18133 0 2
17779: NOT
17780: IFFALSE 17839
// repeat weapon := _weapon [ 1 ] ;
17782: LD_ADDR_VAR 0 5
17786: PUSH
17787: LD_VAR 0 10
17791: PUSH
17792: LD_INT 1
17794: ARRAY
17795: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17796: LD_ADDR_VAR 0 10
17800: PUSH
17801: LD_VAR 0 10
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 3
17813: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17814: LD_VAR 0 2
17818: PPUSH
17819: LD_VAR 0 5
17823: PPUSH
17824: CALL 18133 0 2
17828: PUSH
17829: LD_VAR 0 10
17833: PUSH
17834: EMPTY
17835: EQUAL
17836: OR
17837: IFFALSE 17782
// result := [ ] ;
17839: LD_ADDR_VAR 0 6
17843: PUSH
17844: EMPTY
17845: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17846: LD_VAR 0 1
17850: PPUSH
17851: LD_VAR 0 2
17855: PPUSH
17856: LD_VAR 0 3
17860: PPUSH
17861: LD_VAR 0 4
17865: PPUSH
17866: LD_VAR 0 5
17870: PPUSH
17871: CALL_OW 448
17875: IFFALSE 17908
// result := [ chassis , engine , control , weapon ] ;
17877: LD_ADDR_VAR 0 6
17881: PUSH
17882: LD_VAR 0 2
17886: PUSH
17887: LD_VAR 0 3
17891: PUSH
17892: LD_VAR 0 4
17896: PUSH
17897: LD_VAR 0 5
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: LIST
17906: LIST
17907: ST_TO_ADDR
// end ;
17908: LD_VAR 0 6
17912: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17913: LD_INT 0
17915: PPUSH
// if not chassis or not engine then
17916: LD_VAR 0 1
17920: NOT
17921: PUSH
17922: LD_VAR 0 2
17926: NOT
17927: OR
17928: IFFALSE 17932
// exit ;
17930: GO 18128
// case engine of engine_solar :
17932: LD_VAR 0 2
17936: PUSH
17937: LD_INT 2
17939: DOUBLE
17940: EQUAL
17941: IFTRUE 17945
17943: GO 17983
17945: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17946: LD_ADDR_VAR 0 3
17950: PUSH
17951: LD_INT 11
17953: PUSH
17954: LD_INT 12
17956: PUSH
17957: LD_INT 13
17959: PUSH
17960: LD_INT 14
17962: PUSH
17963: LD_INT 1
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: ST_TO_ADDR
17981: GO 18112
17983: LD_INT 1
17985: DOUBLE
17986: EQUAL
17987: IFTRUE 17991
17989: GO 18053
17991: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17992: LD_ADDR_VAR 0 3
17996: PUSH
17997: LD_INT 11
17999: PUSH
18000: LD_INT 12
18002: PUSH
18003: LD_INT 13
18005: PUSH
18006: LD_INT 14
18008: PUSH
18009: LD_INT 1
18011: PUSH
18012: LD_INT 2
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 4
18020: PUSH
18021: LD_INT 5
18023: PUSH
18024: LD_INT 21
18026: PUSH
18027: LD_INT 23
18029: PUSH
18030: LD_INT 22
18032: PUSH
18033: LD_INT 24
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: ST_TO_ADDR
18051: GO 18112
18053: LD_INT 3
18055: DOUBLE
18056: EQUAL
18057: IFTRUE 18061
18059: GO 18111
18061: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18062: LD_ADDR_VAR 0 3
18066: PUSH
18067: LD_INT 13
18069: PUSH
18070: LD_INT 14
18072: PUSH
18073: LD_INT 2
18075: PUSH
18076: LD_INT 3
18078: PUSH
18079: LD_INT 4
18081: PUSH
18082: LD_INT 5
18084: PUSH
18085: LD_INT 21
18087: PUSH
18088: LD_INT 22
18090: PUSH
18091: LD_INT 23
18093: PUSH
18094: LD_INT 24
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: ST_TO_ADDR
18109: GO 18112
18111: POP
// result := ( chassis in result ) ;
18112: LD_ADDR_VAR 0 3
18116: PUSH
18117: LD_VAR 0 1
18121: PUSH
18122: LD_VAR 0 3
18126: IN
18127: ST_TO_ADDR
// end ;
18128: LD_VAR 0 3
18132: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18133: LD_INT 0
18135: PPUSH
// if not chassis or not weapon then
18136: LD_VAR 0 1
18140: NOT
18141: PUSH
18142: LD_VAR 0 2
18146: NOT
18147: OR
18148: IFFALSE 18152
// exit ;
18150: GO 19214
// case weapon of us_machine_gun :
18152: LD_VAR 0 2
18156: PUSH
18157: LD_INT 2
18159: DOUBLE
18160: EQUAL
18161: IFTRUE 18165
18163: GO 18195
18165: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18166: LD_ADDR_VAR 0 3
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: LD_INT 2
18176: PUSH
18177: LD_INT 3
18179: PUSH
18180: LD_INT 4
18182: PUSH
18183: LD_INT 5
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: ST_TO_ADDR
18193: GO 19198
18195: LD_INT 3
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18233
18203: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18204: LD_ADDR_VAR 0 3
18208: PUSH
18209: LD_INT 1
18211: PUSH
18212: LD_INT 2
18214: PUSH
18215: LD_INT 3
18217: PUSH
18218: LD_INT 4
18220: PUSH
18221: LD_INT 5
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: ST_TO_ADDR
18231: GO 19198
18233: LD_INT 11
18235: DOUBLE
18236: EQUAL
18237: IFTRUE 18241
18239: GO 18271
18241: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18242: LD_ADDR_VAR 0 3
18246: PUSH
18247: LD_INT 1
18249: PUSH
18250: LD_INT 2
18252: PUSH
18253: LD_INT 3
18255: PUSH
18256: LD_INT 4
18258: PUSH
18259: LD_INT 5
18261: PUSH
18262: EMPTY
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: ST_TO_ADDR
18269: GO 19198
18271: LD_INT 4
18273: DOUBLE
18274: EQUAL
18275: IFTRUE 18279
18277: GO 18305
18279: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18280: LD_ADDR_VAR 0 3
18284: PUSH
18285: LD_INT 2
18287: PUSH
18288: LD_INT 3
18290: PUSH
18291: LD_INT 4
18293: PUSH
18294: LD_INT 5
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: LIST
18301: LIST
18302: ST_TO_ADDR
18303: GO 19198
18305: LD_INT 5
18307: DOUBLE
18308: EQUAL
18309: IFTRUE 18313
18311: GO 18339
18313: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18314: LD_ADDR_VAR 0 3
18318: PUSH
18319: LD_INT 2
18321: PUSH
18322: LD_INT 3
18324: PUSH
18325: LD_INT 4
18327: PUSH
18328: LD_INT 5
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: ST_TO_ADDR
18337: GO 19198
18339: LD_INT 9
18341: DOUBLE
18342: EQUAL
18343: IFTRUE 18347
18345: GO 18373
18347: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18348: LD_ADDR_VAR 0 3
18352: PUSH
18353: LD_INT 2
18355: PUSH
18356: LD_INT 3
18358: PUSH
18359: LD_INT 4
18361: PUSH
18362: LD_INT 5
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: ST_TO_ADDR
18371: GO 19198
18373: LD_INT 7
18375: DOUBLE
18376: EQUAL
18377: IFTRUE 18381
18379: GO 18407
18381: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18382: LD_ADDR_VAR 0 3
18386: PUSH
18387: LD_INT 2
18389: PUSH
18390: LD_INT 3
18392: PUSH
18393: LD_INT 4
18395: PUSH
18396: LD_INT 5
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: ST_TO_ADDR
18405: GO 19198
18407: LD_INT 12
18409: DOUBLE
18410: EQUAL
18411: IFTRUE 18415
18413: GO 18441
18415: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18416: LD_ADDR_VAR 0 3
18420: PUSH
18421: LD_INT 2
18423: PUSH
18424: LD_INT 3
18426: PUSH
18427: LD_INT 4
18429: PUSH
18430: LD_INT 5
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: ST_TO_ADDR
18439: GO 19198
18441: LD_INT 13
18443: DOUBLE
18444: EQUAL
18445: IFTRUE 18449
18447: GO 18475
18449: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18450: LD_ADDR_VAR 0 3
18454: PUSH
18455: LD_INT 2
18457: PUSH
18458: LD_INT 3
18460: PUSH
18461: LD_INT 4
18463: PUSH
18464: LD_INT 5
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: ST_TO_ADDR
18473: GO 19198
18475: LD_INT 14
18477: DOUBLE
18478: EQUAL
18479: IFTRUE 18483
18481: GO 18501
18483: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18484: LD_ADDR_VAR 0 3
18488: PUSH
18489: LD_INT 4
18491: PUSH
18492: LD_INT 5
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: ST_TO_ADDR
18499: GO 19198
18501: LD_INT 6
18503: DOUBLE
18504: EQUAL
18505: IFTRUE 18509
18507: GO 18527
18509: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18510: LD_ADDR_VAR 0 3
18514: PUSH
18515: LD_INT 4
18517: PUSH
18518: LD_INT 5
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: ST_TO_ADDR
18525: GO 19198
18527: LD_INT 10
18529: DOUBLE
18530: EQUAL
18531: IFTRUE 18535
18533: GO 18553
18535: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18536: LD_ADDR_VAR 0 3
18540: PUSH
18541: LD_INT 4
18543: PUSH
18544: LD_INT 5
18546: PUSH
18547: EMPTY
18548: LIST
18549: LIST
18550: ST_TO_ADDR
18551: GO 19198
18553: LD_INT 22
18555: DOUBLE
18556: EQUAL
18557: IFTRUE 18561
18559: GO 18587
18561: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18562: LD_ADDR_VAR 0 3
18566: PUSH
18567: LD_INT 11
18569: PUSH
18570: LD_INT 12
18572: PUSH
18573: LD_INT 13
18575: PUSH
18576: LD_INT 14
18578: PUSH
18579: EMPTY
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: ST_TO_ADDR
18585: GO 19198
18587: LD_INT 23
18589: DOUBLE
18590: EQUAL
18591: IFTRUE 18595
18593: GO 18621
18595: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18596: LD_ADDR_VAR 0 3
18600: PUSH
18601: LD_INT 11
18603: PUSH
18604: LD_INT 12
18606: PUSH
18607: LD_INT 13
18609: PUSH
18610: LD_INT 14
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: ST_TO_ADDR
18619: GO 19198
18621: LD_INT 24
18623: DOUBLE
18624: EQUAL
18625: IFTRUE 18629
18627: GO 18655
18629: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18630: LD_ADDR_VAR 0 3
18634: PUSH
18635: LD_INT 11
18637: PUSH
18638: LD_INT 12
18640: PUSH
18641: LD_INT 13
18643: PUSH
18644: LD_INT 14
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
18653: GO 19198
18655: LD_INT 30
18657: DOUBLE
18658: EQUAL
18659: IFTRUE 18663
18661: GO 18689
18663: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18664: LD_ADDR_VAR 0 3
18668: PUSH
18669: LD_INT 11
18671: PUSH
18672: LD_INT 12
18674: PUSH
18675: LD_INT 13
18677: PUSH
18678: LD_INT 14
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: ST_TO_ADDR
18687: GO 19198
18689: LD_INT 25
18691: DOUBLE
18692: EQUAL
18693: IFTRUE 18697
18695: GO 18715
18697: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18698: LD_ADDR_VAR 0 3
18702: PUSH
18703: LD_INT 13
18705: PUSH
18706: LD_INT 14
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: ST_TO_ADDR
18713: GO 19198
18715: LD_INT 27
18717: DOUBLE
18718: EQUAL
18719: IFTRUE 18723
18721: GO 18741
18723: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18724: LD_ADDR_VAR 0 3
18728: PUSH
18729: LD_INT 13
18731: PUSH
18732: LD_INT 14
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: ST_TO_ADDR
18739: GO 19198
18741: LD_EXP 109
18745: DOUBLE
18746: EQUAL
18747: IFTRUE 18751
18749: GO 18777
18751: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18752: LD_ADDR_VAR 0 3
18756: PUSH
18757: LD_INT 11
18759: PUSH
18760: LD_INT 12
18762: PUSH
18763: LD_INT 13
18765: PUSH
18766: LD_INT 14
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: ST_TO_ADDR
18775: GO 19198
18777: LD_INT 28
18779: DOUBLE
18780: EQUAL
18781: IFTRUE 18785
18783: GO 18803
18785: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18786: LD_ADDR_VAR 0 3
18790: PUSH
18791: LD_INT 13
18793: PUSH
18794: LD_INT 14
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: ST_TO_ADDR
18801: GO 19198
18803: LD_INT 29
18805: DOUBLE
18806: EQUAL
18807: IFTRUE 18811
18809: GO 18829
18811: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18812: LD_ADDR_VAR 0 3
18816: PUSH
18817: LD_INT 13
18819: PUSH
18820: LD_INT 14
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: ST_TO_ADDR
18827: GO 19198
18829: LD_INT 31
18831: DOUBLE
18832: EQUAL
18833: IFTRUE 18837
18835: GO 18855
18837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18838: LD_ADDR_VAR 0 3
18842: PUSH
18843: LD_INT 13
18845: PUSH
18846: LD_INT 14
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: ST_TO_ADDR
18853: GO 19198
18855: LD_INT 26
18857: DOUBLE
18858: EQUAL
18859: IFTRUE 18863
18861: GO 18881
18863: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18864: LD_ADDR_VAR 0 3
18868: PUSH
18869: LD_INT 13
18871: PUSH
18872: LD_INT 14
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: ST_TO_ADDR
18879: GO 19198
18881: LD_INT 42
18883: DOUBLE
18884: EQUAL
18885: IFTRUE 18889
18887: GO 18915
18889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18890: LD_ADDR_VAR 0 3
18894: PUSH
18895: LD_INT 21
18897: PUSH
18898: LD_INT 22
18900: PUSH
18901: LD_INT 23
18903: PUSH
18904: LD_INT 24
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: LIST
18911: LIST
18912: ST_TO_ADDR
18913: GO 19198
18915: LD_INT 43
18917: DOUBLE
18918: EQUAL
18919: IFTRUE 18923
18921: GO 18949
18923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18924: LD_ADDR_VAR 0 3
18928: PUSH
18929: LD_INT 21
18931: PUSH
18932: LD_INT 22
18934: PUSH
18935: LD_INT 23
18937: PUSH
18938: LD_INT 24
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: ST_TO_ADDR
18947: GO 19198
18949: LD_INT 44
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 18983
18957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18958: LD_ADDR_VAR 0 3
18962: PUSH
18963: LD_INT 21
18965: PUSH
18966: LD_INT 22
18968: PUSH
18969: LD_INT 23
18971: PUSH
18972: LD_INT 24
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: ST_TO_ADDR
18981: GO 19198
18983: LD_INT 45
18985: DOUBLE
18986: EQUAL
18987: IFTRUE 18991
18989: GO 19017
18991: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18992: LD_ADDR_VAR 0 3
18996: PUSH
18997: LD_INT 21
18999: PUSH
19000: LD_INT 22
19002: PUSH
19003: LD_INT 23
19005: PUSH
19006: LD_INT 24
19008: PUSH
19009: EMPTY
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: ST_TO_ADDR
19015: GO 19198
19017: LD_INT 49
19019: DOUBLE
19020: EQUAL
19021: IFTRUE 19025
19023: GO 19051
19025: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19026: LD_ADDR_VAR 0 3
19030: PUSH
19031: LD_INT 21
19033: PUSH
19034: LD_INT 22
19036: PUSH
19037: LD_INT 23
19039: PUSH
19040: LD_INT 24
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: LIST
19047: LIST
19048: ST_TO_ADDR
19049: GO 19198
19051: LD_INT 51
19053: DOUBLE
19054: EQUAL
19055: IFTRUE 19059
19057: GO 19085
19059: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19060: LD_ADDR_VAR 0 3
19064: PUSH
19065: LD_INT 21
19067: PUSH
19068: LD_INT 22
19070: PUSH
19071: LD_INT 23
19073: PUSH
19074: LD_INT 24
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: LIST
19082: ST_TO_ADDR
19083: GO 19198
19085: LD_INT 52
19087: DOUBLE
19088: EQUAL
19089: IFTRUE 19093
19091: GO 19119
19093: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19094: LD_ADDR_VAR 0 3
19098: PUSH
19099: LD_INT 21
19101: PUSH
19102: LD_INT 22
19104: PUSH
19105: LD_INT 23
19107: PUSH
19108: LD_INT 24
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: ST_TO_ADDR
19117: GO 19198
19119: LD_INT 53
19121: DOUBLE
19122: EQUAL
19123: IFTRUE 19127
19125: GO 19145
19127: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19128: LD_ADDR_VAR 0 3
19132: PUSH
19133: LD_INT 23
19135: PUSH
19136: LD_INT 24
19138: PUSH
19139: EMPTY
19140: LIST
19141: LIST
19142: ST_TO_ADDR
19143: GO 19198
19145: LD_INT 46
19147: DOUBLE
19148: EQUAL
19149: IFTRUE 19153
19151: GO 19171
19153: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19154: LD_ADDR_VAR 0 3
19158: PUSH
19159: LD_INT 23
19161: PUSH
19162: LD_INT 24
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: ST_TO_ADDR
19169: GO 19198
19171: LD_INT 47
19173: DOUBLE
19174: EQUAL
19175: IFTRUE 19179
19177: GO 19197
19179: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19180: LD_ADDR_VAR 0 3
19184: PUSH
19185: LD_INT 23
19187: PUSH
19188: LD_INT 24
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: ST_TO_ADDR
19195: GO 19198
19197: POP
// result := ( chassis in result ) ;
19198: LD_ADDR_VAR 0 3
19202: PUSH
19203: LD_VAR 0 1
19207: PUSH
19208: LD_VAR 0 3
19212: IN
19213: ST_TO_ADDR
// end ;
19214: LD_VAR 0 3
19218: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19219: LD_INT 0
19221: PPUSH
19222: PPUSH
19223: PPUSH
19224: PPUSH
19225: PPUSH
19226: PPUSH
19227: PPUSH
// result := array ;
19228: LD_ADDR_VAR 0 5
19232: PUSH
19233: LD_VAR 0 1
19237: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19238: LD_VAR 0 1
19242: NOT
19243: PUSH
19244: LD_VAR 0 2
19248: NOT
19249: OR
19250: PUSH
19251: LD_VAR 0 3
19255: NOT
19256: OR
19257: PUSH
19258: LD_VAR 0 2
19262: PUSH
19263: LD_VAR 0 1
19267: GREATER
19268: OR
19269: PUSH
19270: LD_VAR 0 3
19274: PUSH
19275: LD_VAR 0 1
19279: GREATER
19280: OR
19281: IFFALSE 19285
// exit ;
19283: GO 19581
// if direction then
19285: LD_VAR 0 4
19289: IFFALSE 19353
// begin d := 1 ;
19291: LD_ADDR_VAR 0 9
19295: PUSH
19296: LD_INT 1
19298: ST_TO_ADDR
// if i_from > i_to then
19299: LD_VAR 0 2
19303: PUSH
19304: LD_VAR 0 3
19308: GREATER
19309: IFFALSE 19335
// length := ( array - i_from ) + i_to else
19311: LD_ADDR_VAR 0 11
19315: PUSH
19316: LD_VAR 0 1
19320: PUSH
19321: LD_VAR 0 2
19325: MINUS
19326: PUSH
19327: LD_VAR 0 3
19331: PLUS
19332: ST_TO_ADDR
19333: GO 19351
// length := i_to - i_from ;
19335: LD_ADDR_VAR 0 11
19339: PUSH
19340: LD_VAR 0 3
19344: PUSH
19345: LD_VAR 0 2
19349: MINUS
19350: ST_TO_ADDR
// end else
19351: GO 19414
// begin d := - 1 ;
19353: LD_ADDR_VAR 0 9
19357: PUSH
19358: LD_INT 1
19360: NEG
19361: ST_TO_ADDR
// if i_from > i_to then
19362: LD_VAR 0 2
19366: PUSH
19367: LD_VAR 0 3
19371: GREATER
19372: IFFALSE 19392
// length := i_from - i_to else
19374: LD_ADDR_VAR 0 11
19378: PUSH
19379: LD_VAR 0 2
19383: PUSH
19384: LD_VAR 0 3
19388: MINUS
19389: ST_TO_ADDR
19390: GO 19414
// length := ( array - i_to ) + i_from ;
19392: LD_ADDR_VAR 0 11
19396: PUSH
19397: LD_VAR 0 1
19401: PUSH
19402: LD_VAR 0 3
19406: MINUS
19407: PUSH
19408: LD_VAR 0 2
19412: PLUS
19413: ST_TO_ADDR
// end ; if not length then
19414: LD_VAR 0 11
19418: NOT
19419: IFFALSE 19423
// exit ;
19421: GO 19581
// tmp := array ;
19423: LD_ADDR_VAR 0 10
19427: PUSH
19428: LD_VAR 0 1
19432: ST_TO_ADDR
// for i = 1 to length do
19433: LD_ADDR_VAR 0 6
19437: PUSH
19438: DOUBLE
19439: LD_INT 1
19441: DEC
19442: ST_TO_ADDR
19443: LD_VAR 0 11
19447: PUSH
19448: FOR_TO
19449: IFFALSE 19569
// begin for j = 1 to array do
19451: LD_ADDR_VAR 0 7
19455: PUSH
19456: DOUBLE
19457: LD_INT 1
19459: DEC
19460: ST_TO_ADDR
19461: LD_VAR 0 1
19465: PUSH
19466: FOR_TO
19467: IFFALSE 19555
// begin k := j + d ;
19469: LD_ADDR_VAR 0 8
19473: PUSH
19474: LD_VAR 0 7
19478: PUSH
19479: LD_VAR 0 9
19483: PLUS
19484: ST_TO_ADDR
// if k > array then
19485: LD_VAR 0 8
19489: PUSH
19490: LD_VAR 0 1
19494: GREATER
19495: IFFALSE 19505
// k := 1 ;
19497: LD_ADDR_VAR 0 8
19501: PUSH
19502: LD_INT 1
19504: ST_TO_ADDR
// if not k then
19505: LD_VAR 0 8
19509: NOT
19510: IFFALSE 19522
// k := array ;
19512: LD_ADDR_VAR 0 8
19516: PUSH
19517: LD_VAR 0 1
19521: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19522: LD_ADDR_VAR 0 10
19526: PUSH
19527: LD_VAR 0 10
19531: PPUSH
19532: LD_VAR 0 8
19536: PPUSH
19537: LD_VAR 0 1
19541: PUSH
19542: LD_VAR 0 7
19546: ARRAY
19547: PPUSH
19548: CALL_OW 1
19552: ST_TO_ADDR
// end ;
19553: GO 19466
19555: POP
19556: POP
// array := tmp ;
19557: LD_ADDR_VAR 0 1
19561: PUSH
19562: LD_VAR 0 10
19566: ST_TO_ADDR
// end ;
19567: GO 19448
19569: POP
19570: POP
// result := array ;
19571: LD_ADDR_VAR 0 5
19575: PUSH
19576: LD_VAR 0 1
19580: ST_TO_ADDR
// end ;
19581: LD_VAR 0 5
19585: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19586: LD_INT 0
19588: PPUSH
19589: PPUSH
// result := 0 ;
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 0
19597: ST_TO_ADDR
// if not array or not value in array then
19598: LD_VAR 0 1
19602: NOT
19603: PUSH
19604: LD_VAR 0 2
19608: PUSH
19609: LD_VAR 0 1
19613: IN
19614: NOT
19615: OR
19616: IFFALSE 19620
// exit ;
19618: GO 19674
// for i = 1 to array do
19620: LD_ADDR_VAR 0 4
19624: PUSH
19625: DOUBLE
19626: LD_INT 1
19628: DEC
19629: ST_TO_ADDR
19630: LD_VAR 0 1
19634: PUSH
19635: FOR_TO
19636: IFFALSE 19672
// if value = array [ i ] then
19638: LD_VAR 0 2
19642: PUSH
19643: LD_VAR 0 1
19647: PUSH
19648: LD_VAR 0 4
19652: ARRAY
19653: EQUAL
19654: IFFALSE 19670
// begin result := i ;
19656: LD_ADDR_VAR 0 3
19660: PUSH
19661: LD_VAR 0 4
19665: ST_TO_ADDR
// exit ;
19666: POP
19667: POP
19668: GO 19674
// end ;
19670: GO 19635
19672: POP
19673: POP
// end ;
19674: LD_VAR 0 3
19678: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19679: LD_INT 0
19681: PPUSH
// vc_chassis := chassis ;
19682: LD_ADDR_OWVAR 37
19686: PUSH
19687: LD_VAR 0 1
19691: ST_TO_ADDR
// vc_engine := engine ;
19692: LD_ADDR_OWVAR 39
19696: PUSH
19697: LD_VAR 0 2
19701: ST_TO_ADDR
// vc_control := control ;
19702: LD_ADDR_OWVAR 38
19706: PUSH
19707: LD_VAR 0 3
19711: ST_TO_ADDR
// vc_weapon := weapon ;
19712: LD_ADDR_OWVAR 40
19716: PUSH
19717: LD_VAR 0 4
19721: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19722: LD_ADDR_OWVAR 41
19726: PUSH
19727: LD_VAR 0 5
19731: ST_TO_ADDR
// end ;
19732: LD_VAR 0 6
19736: RET
// export function WantPlant ( unit ) ; var task ; begin
19737: LD_INT 0
19739: PPUSH
19740: PPUSH
// result := false ;
19741: LD_ADDR_VAR 0 2
19745: PUSH
19746: LD_INT 0
19748: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19749: LD_ADDR_VAR 0 3
19753: PUSH
19754: LD_VAR 0 1
19758: PPUSH
19759: CALL_OW 437
19763: ST_TO_ADDR
// if task then
19764: LD_VAR 0 3
19768: IFFALSE 19796
// if task [ 1 ] [ 1 ] = p then
19770: LD_VAR 0 3
19774: PUSH
19775: LD_INT 1
19777: ARRAY
19778: PUSH
19779: LD_INT 1
19781: ARRAY
19782: PUSH
19783: LD_STRING p
19785: EQUAL
19786: IFFALSE 19796
// result := true ;
19788: LD_ADDR_VAR 0 2
19792: PUSH
19793: LD_INT 1
19795: ST_TO_ADDR
// end ;
19796: LD_VAR 0 2
19800: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19801: LD_INT 0
19803: PPUSH
19804: PPUSH
19805: PPUSH
19806: PPUSH
// if pos < 1 then
19807: LD_VAR 0 2
19811: PUSH
19812: LD_INT 1
19814: LESS
19815: IFFALSE 19819
// exit ;
19817: GO 20122
// if pos = 1 then
19819: LD_VAR 0 2
19823: PUSH
19824: LD_INT 1
19826: EQUAL
19827: IFFALSE 19860
// result := Replace ( arr , pos [ 1 ] , value ) else
19829: LD_ADDR_VAR 0 4
19833: PUSH
19834: LD_VAR 0 1
19838: PPUSH
19839: LD_VAR 0 2
19843: PUSH
19844: LD_INT 1
19846: ARRAY
19847: PPUSH
19848: LD_VAR 0 3
19852: PPUSH
19853: CALL_OW 1
19857: ST_TO_ADDR
19858: GO 20122
// begin tmp := arr ;
19860: LD_ADDR_VAR 0 6
19864: PUSH
19865: LD_VAR 0 1
19869: ST_TO_ADDR
// s_arr := [ tmp ] ;
19870: LD_ADDR_VAR 0 7
19874: PUSH
19875: LD_VAR 0 6
19879: PUSH
19880: EMPTY
19881: LIST
19882: ST_TO_ADDR
// for i = 1 to pos - 1 do
19883: LD_ADDR_VAR 0 5
19887: PUSH
19888: DOUBLE
19889: LD_INT 1
19891: DEC
19892: ST_TO_ADDR
19893: LD_VAR 0 2
19897: PUSH
19898: LD_INT 1
19900: MINUS
19901: PUSH
19902: FOR_TO
19903: IFFALSE 19948
// begin tmp := tmp [ pos [ i ] ] ;
19905: LD_ADDR_VAR 0 6
19909: PUSH
19910: LD_VAR 0 6
19914: PUSH
19915: LD_VAR 0 2
19919: PUSH
19920: LD_VAR 0 5
19924: ARRAY
19925: ARRAY
19926: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19927: LD_ADDR_VAR 0 7
19931: PUSH
19932: LD_VAR 0 7
19936: PUSH
19937: LD_VAR 0 6
19941: PUSH
19942: EMPTY
19943: LIST
19944: ADD
19945: ST_TO_ADDR
// end ;
19946: GO 19902
19948: POP
19949: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19950: LD_ADDR_VAR 0 6
19954: PUSH
19955: LD_VAR 0 6
19959: PPUSH
19960: LD_VAR 0 2
19964: PUSH
19965: LD_VAR 0 2
19969: ARRAY
19970: PPUSH
19971: LD_VAR 0 3
19975: PPUSH
19976: CALL_OW 1
19980: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19981: LD_ADDR_VAR 0 7
19985: PUSH
19986: LD_VAR 0 7
19990: PPUSH
19991: LD_VAR 0 7
19995: PPUSH
19996: LD_VAR 0 6
20000: PPUSH
20001: CALL_OW 1
20005: ST_TO_ADDR
// for i = s_arr downto 2 do
20006: LD_ADDR_VAR 0 5
20010: PUSH
20011: DOUBLE
20012: LD_VAR 0 7
20016: INC
20017: ST_TO_ADDR
20018: LD_INT 2
20020: PUSH
20021: FOR_DOWNTO
20022: IFFALSE 20106
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: LD_VAR 0 7
20033: PUSH
20034: LD_VAR 0 5
20038: PUSH
20039: LD_INT 1
20041: MINUS
20042: ARRAY
20043: PPUSH
20044: LD_VAR 0 2
20048: PUSH
20049: LD_VAR 0 5
20053: PUSH
20054: LD_INT 1
20056: MINUS
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 7
20063: PUSH
20064: LD_VAR 0 5
20068: ARRAY
20069: PPUSH
20070: CALL_OW 1
20074: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20075: LD_ADDR_VAR 0 7
20079: PUSH
20080: LD_VAR 0 7
20084: PPUSH
20085: LD_VAR 0 5
20089: PUSH
20090: LD_INT 1
20092: MINUS
20093: PPUSH
20094: LD_VAR 0 6
20098: PPUSH
20099: CALL_OW 1
20103: ST_TO_ADDR
// end ;
20104: GO 20021
20106: POP
20107: POP
// result := s_arr [ 1 ] ;
20108: LD_ADDR_VAR 0 4
20112: PUSH
20113: LD_VAR 0 7
20117: PUSH
20118: LD_INT 1
20120: ARRAY
20121: ST_TO_ADDR
// end ; end ;
20122: LD_VAR 0 4
20126: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20127: LD_INT 0
20129: PPUSH
20130: PPUSH
// if not list then
20131: LD_VAR 0 1
20135: NOT
20136: IFFALSE 20140
// exit ;
20138: GO 20231
// i := list [ pos1 ] ;
20140: LD_ADDR_VAR 0 5
20144: PUSH
20145: LD_VAR 0 1
20149: PUSH
20150: LD_VAR 0 2
20154: ARRAY
20155: ST_TO_ADDR
// if not i then
20156: LD_VAR 0 5
20160: NOT
20161: IFFALSE 20165
// exit ;
20163: GO 20231
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20165: LD_ADDR_VAR 0 1
20169: PUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 2
20179: PPUSH
20180: LD_VAR 0 1
20184: PUSH
20185: LD_VAR 0 3
20189: ARRAY
20190: PPUSH
20191: CALL_OW 1
20195: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20196: LD_ADDR_VAR 0 1
20200: PUSH
20201: LD_VAR 0 1
20205: PPUSH
20206: LD_VAR 0 3
20210: PPUSH
20211: LD_VAR 0 5
20215: PPUSH
20216: CALL_OW 1
20220: ST_TO_ADDR
// result := list ;
20221: LD_ADDR_VAR 0 4
20225: PUSH
20226: LD_VAR 0 1
20230: ST_TO_ADDR
// end ;
20231: LD_VAR 0 4
20235: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20236: LD_INT 0
20238: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20239: LD_ADDR_VAR 0 5
20243: PUSH
20244: LD_VAR 0 1
20248: PPUSH
20249: CALL_OW 250
20253: PPUSH
20254: LD_VAR 0 1
20258: PPUSH
20259: CALL_OW 251
20263: PPUSH
20264: LD_VAR 0 2
20268: PPUSH
20269: LD_VAR 0 3
20273: PPUSH
20274: LD_VAR 0 4
20278: PPUSH
20279: CALL 20289 0 5
20283: ST_TO_ADDR
// end ;
20284: LD_VAR 0 5
20288: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20289: LD_INT 0
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
// if not list then
20295: LD_VAR 0 3
20299: NOT
20300: IFFALSE 20304
// exit ;
20302: GO 20692
// result := [ ] ;
20304: LD_ADDR_VAR 0 6
20308: PUSH
20309: EMPTY
20310: ST_TO_ADDR
// for i in list do
20311: LD_ADDR_VAR 0 7
20315: PUSH
20316: LD_VAR 0 3
20320: PUSH
20321: FOR_IN
20322: IFFALSE 20524
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20324: LD_ADDR_VAR 0 9
20328: PUSH
20329: LD_VAR 0 7
20333: PPUSH
20334: LD_VAR 0 1
20338: PPUSH
20339: LD_VAR 0 2
20343: PPUSH
20344: CALL_OW 297
20348: ST_TO_ADDR
// if not result then
20349: LD_VAR 0 6
20353: NOT
20354: IFFALSE 20380
// result := [ [ i , tmp ] ] else
20356: LD_ADDR_VAR 0 6
20360: PUSH
20361: LD_VAR 0 7
20365: PUSH
20366: LD_VAR 0 9
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: PUSH
20375: EMPTY
20376: LIST
20377: ST_TO_ADDR
20378: GO 20522
// begin if result [ result ] [ 2 ] < tmp then
20380: LD_VAR 0 6
20384: PUSH
20385: LD_VAR 0 6
20389: ARRAY
20390: PUSH
20391: LD_INT 2
20393: ARRAY
20394: PUSH
20395: LD_VAR 0 9
20399: LESS
20400: IFFALSE 20442
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20402: LD_ADDR_VAR 0 6
20406: PUSH
20407: LD_VAR 0 6
20411: PPUSH
20412: LD_VAR 0 6
20416: PUSH
20417: LD_INT 1
20419: PLUS
20420: PPUSH
20421: LD_VAR 0 7
20425: PUSH
20426: LD_VAR 0 9
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: PPUSH
20435: CALL_OW 2
20439: ST_TO_ADDR
20440: GO 20522
// for j = 1 to result do
20442: LD_ADDR_VAR 0 8
20446: PUSH
20447: DOUBLE
20448: LD_INT 1
20450: DEC
20451: ST_TO_ADDR
20452: LD_VAR 0 6
20456: PUSH
20457: FOR_TO
20458: IFFALSE 20520
// begin if tmp < result [ j ] [ 2 ] then
20460: LD_VAR 0 9
20464: PUSH
20465: LD_VAR 0 6
20469: PUSH
20470: LD_VAR 0 8
20474: ARRAY
20475: PUSH
20476: LD_INT 2
20478: ARRAY
20479: LESS
20480: IFFALSE 20518
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20482: LD_ADDR_VAR 0 6
20486: PUSH
20487: LD_VAR 0 6
20491: PPUSH
20492: LD_VAR 0 8
20496: PPUSH
20497: LD_VAR 0 7
20501: PUSH
20502: LD_VAR 0 9
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: PPUSH
20511: CALL_OW 2
20515: ST_TO_ADDR
// break ;
20516: GO 20520
// end ; end ;
20518: GO 20457
20520: POP
20521: POP
// end ; end ;
20522: GO 20321
20524: POP
20525: POP
// if result and not asc then
20526: LD_VAR 0 6
20530: PUSH
20531: LD_VAR 0 4
20535: NOT
20536: AND
20537: IFFALSE 20612
// begin tmp := result ;
20539: LD_ADDR_VAR 0 9
20543: PUSH
20544: LD_VAR 0 6
20548: ST_TO_ADDR
// for i = tmp downto 1 do
20549: LD_ADDR_VAR 0 7
20553: PUSH
20554: DOUBLE
20555: LD_VAR 0 9
20559: INC
20560: ST_TO_ADDR
20561: LD_INT 1
20563: PUSH
20564: FOR_DOWNTO
20565: IFFALSE 20610
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 6
20576: PPUSH
20577: LD_VAR 0 9
20581: PUSH
20582: LD_VAR 0 7
20586: MINUS
20587: PUSH
20588: LD_INT 1
20590: PLUS
20591: PPUSH
20592: LD_VAR 0 9
20596: PUSH
20597: LD_VAR 0 7
20601: ARRAY
20602: PPUSH
20603: CALL_OW 1
20607: ST_TO_ADDR
20608: GO 20564
20610: POP
20611: POP
// end ; tmp := [ ] ;
20612: LD_ADDR_VAR 0 9
20616: PUSH
20617: EMPTY
20618: ST_TO_ADDR
// if mode then
20619: LD_VAR 0 5
20623: IFFALSE 20692
// begin for i = 1 to result do
20625: LD_ADDR_VAR 0 7
20629: PUSH
20630: DOUBLE
20631: LD_INT 1
20633: DEC
20634: ST_TO_ADDR
20635: LD_VAR 0 6
20639: PUSH
20640: FOR_TO
20641: IFFALSE 20680
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20643: LD_ADDR_VAR 0 9
20647: PUSH
20648: LD_VAR 0 9
20652: PPUSH
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 6
20662: PUSH
20663: LD_VAR 0 7
20667: ARRAY
20668: PUSH
20669: LD_INT 1
20671: ARRAY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
20678: GO 20640
20680: POP
20681: POP
// result := tmp ;
20682: LD_ADDR_VAR 0 6
20686: PUSH
20687: LD_VAR 0 9
20691: ST_TO_ADDR
// end ; end ;
20692: LD_VAR 0 6
20696: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20697: LD_INT 0
20699: PPUSH
20700: PPUSH
20701: PPUSH
20702: PPUSH
20703: PPUSH
20704: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20705: LD_ADDR_VAR 0 5
20709: PUSH
20710: LD_INT 0
20712: PUSH
20713: LD_INT 0
20715: PUSH
20716: LD_INT 0
20718: PUSH
20719: EMPTY
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: LIST
20725: LIST
20726: ST_TO_ADDR
// if not x or not y then
20727: LD_VAR 0 2
20731: NOT
20732: PUSH
20733: LD_VAR 0 3
20737: NOT
20738: OR
20739: IFFALSE 20743
// exit ;
20741: GO 22395
// if not range then
20743: LD_VAR 0 4
20747: NOT
20748: IFFALSE 20758
// range := 10 ;
20750: LD_ADDR_VAR 0 4
20754: PUSH
20755: LD_INT 10
20757: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20758: LD_ADDR_VAR 0 8
20762: PUSH
20763: LD_INT 81
20765: PUSH
20766: LD_VAR 0 1
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: PUSH
20775: LD_INT 92
20777: PUSH
20778: LD_VAR 0 2
20782: PUSH
20783: LD_VAR 0 3
20787: PUSH
20788: LD_VAR 0 4
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: PUSH
20799: LD_INT 3
20801: PUSH
20802: LD_INT 21
20804: PUSH
20805: LD_INT 3
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: LIST
20820: PPUSH
20821: CALL_OW 69
20825: ST_TO_ADDR
// if not tmp then
20826: LD_VAR 0 8
20830: NOT
20831: IFFALSE 20835
// exit ;
20833: GO 22395
// for i in tmp do
20835: LD_ADDR_VAR 0 6
20839: PUSH
20840: LD_VAR 0 8
20844: PUSH
20845: FOR_IN
20846: IFFALSE 22370
// begin points := [ 0 , 0 , 0 ] ;
20848: LD_ADDR_VAR 0 9
20852: PUSH
20853: LD_INT 0
20855: PUSH
20856: LD_INT 0
20858: PUSH
20859: LD_INT 0
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: LIST
20866: ST_TO_ADDR
// bpoints := 1 ;
20867: LD_ADDR_VAR 0 10
20871: PUSH
20872: LD_INT 1
20874: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20875: LD_VAR 0 6
20879: PPUSH
20880: CALL_OW 247
20884: PUSH
20885: LD_INT 1
20887: DOUBLE
20888: EQUAL
20889: IFTRUE 20893
20891: GO 21471
20893: POP
// begin if GetClass ( i ) = 1 then
20894: LD_VAR 0 6
20898: PPUSH
20899: CALL_OW 257
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20928
// points := [ 10 , 5 , 3 ] ;
20909: LD_ADDR_VAR 0 9
20913: PUSH
20914: LD_INT 10
20916: PUSH
20917: LD_INT 5
20919: PUSH
20920: LD_INT 3
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: LIST
20927: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20928: LD_VAR 0 6
20932: PPUSH
20933: CALL_OW 257
20937: PUSH
20938: LD_INT 2
20940: PUSH
20941: LD_INT 3
20943: PUSH
20944: LD_INT 4
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: LIST
20951: IN
20952: IFFALSE 20973
// points := [ 3 , 2 , 1 ] ;
20954: LD_ADDR_VAR 0 9
20958: PUSH
20959: LD_INT 3
20961: PUSH
20962: LD_INT 2
20964: PUSH
20965: LD_INT 1
20967: PUSH
20968: EMPTY
20969: LIST
20970: LIST
20971: LIST
20972: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20973: LD_VAR 0 6
20977: PPUSH
20978: CALL_OW 257
20982: PUSH
20983: LD_INT 5
20985: EQUAL
20986: IFFALSE 21007
// points := [ 130 , 5 , 2 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 130
20995: PUSH
20996: LD_INT 5
20998: PUSH
20999: LD_INT 2
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 257
21016: PUSH
21017: LD_INT 8
21019: EQUAL
21020: IFFALSE 21041
// points := [ 35 , 35 , 30 ] ;
21022: LD_ADDR_VAR 0 9
21026: PUSH
21027: LD_INT 35
21029: PUSH
21030: LD_INT 35
21032: PUSH
21033: LD_INT 30
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: LIST
21040: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21041: LD_VAR 0 6
21045: PPUSH
21046: CALL_OW 257
21050: PUSH
21051: LD_INT 9
21053: EQUAL
21054: IFFALSE 21075
// points := [ 20 , 55 , 40 ] ;
21056: LD_ADDR_VAR 0 9
21060: PUSH
21061: LD_INT 20
21063: PUSH
21064: LD_INT 55
21066: PUSH
21067: LD_INT 40
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: LIST
21074: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21075: LD_VAR 0 6
21079: PPUSH
21080: CALL_OW 257
21084: PUSH
21085: LD_INT 12
21087: PUSH
21088: LD_INT 16
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: IN
21095: IFFALSE 21116
// points := [ 5 , 3 , 2 ] ;
21097: LD_ADDR_VAR 0 9
21101: PUSH
21102: LD_INT 5
21104: PUSH
21105: LD_INT 3
21107: PUSH
21108: LD_INT 2
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: LIST
21115: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21116: LD_VAR 0 6
21120: PPUSH
21121: CALL_OW 257
21125: PUSH
21126: LD_INT 17
21128: EQUAL
21129: IFFALSE 21150
// points := [ 100 , 50 , 75 ] ;
21131: LD_ADDR_VAR 0 9
21135: PUSH
21136: LD_INT 100
21138: PUSH
21139: LD_INT 50
21141: PUSH
21142: LD_INT 75
21144: PUSH
21145: EMPTY
21146: LIST
21147: LIST
21148: LIST
21149: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21150: LD_VAR 0 6
21154: PPUSH
21155: CALL_OW 257
21159: PUSH
21160: LD_INT 15
21162: EQUAL
21163: IFFALSE 21184
// points := [ 10 , 5 , 3 ] ;
21165: LD_ADDR_VAR 0 9
21169: PUSH
21170: LD_INT 10
21172: PUSH
21173: LD_INT 5
21175: PUSH
21176: LD_INT 3
21178: PUSH
21179: EMPTY
21180: LIST
21181: LIST
21182: LIST
21183: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21184: LD_VAR 0 6
21188: PPUSH
21189: CALL_OW 257
21193: PUSH
21194: LD_INT 14
21196: EQUAL
21197: IFFALSE 21218
// points := [ 10 , 0 , 0 ] ;
21199: LD_ADDR_VAR 0 9
21203: PUSH
21204: LD_INT 10
21206: PUSH
21207: LD_INT 0
21209: PUSH
21210: LD_INT 0
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: LIST
21217: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21218: LD_VAR 0 6
21222: PPUSH
21223: CALL_OW 257
21227: PUSH
21228: LD_INT 11
21230: EQUAL
21231: IFFALSE 21252
// points := [ 30 , 10 , 5 ] ;
21233: LD_ADDR_VAR 0 9
21237: PUSH
21238: LD_INT 30
21240: PUSH
21241: LD_INT 10
21243: PUSH
21244: LD_INT 5
21246: PUSH
21247: EMPTY
21248: LIST
21249: LIST
21250: LIST
21251: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21252: LD_VAR 0 1
21256: PPUSH
21257: LD_INT 5
21259: PPUSH
21260: CALL_OW 321
21264: PUSH
21265: LD_INT 2
21267: EQUAL
21268: IFFALSE 21285
// bpoints := bpoints * 1.8 ;
21270: LD_ADDR_VAR 0 10
21274: PUSH
21275: LD_VAR 0 10
21279: PUSH
21280: LD_REAL  1.80000000000000E+0000
21283: MUL
21284: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21285: LD_VAR 0 6
21289: PPUSH
21290: CALL_OW 257
21294: PUSH
21295: LD_INT 1
21297: PUSH
21298: LD_INT 2
21300: PUSH
21301: LD_INT 3
21303: PUSH
21304: LD_INT 4
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: IN
21313: PUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: LD_INT 51
21321: PPUSH
21322: CALL_OW 321
21326: PUSH
21327: LD_INT 2
21329: EQUAL
21330: AND
21331: IFFALSE 21348
// bpoints := bpoints * 1.2 ;
21333: LD_ADDR_VAR 0 10
21337: PUSH
21338: LD_VAR 0 10
21342: PUSH
21343: LD_REAL  1.20000000000000E+0000
21346: MUL
21347: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21348: LD_VAR 0 6
21352: PPUSH
21353: CALL_OW 257
21357: PUSH
21358: LD_INT 5
21360: PUSH
21361: LD_INT 7
21363: PUSH
21364: LD_INT 9
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: IN
21372: PUSH
21373: LD_VAR 0 1
21377: PPUSH
21378: LD_INT 52
21380: PPUSH
21381: CALL_OW 321
21385: PUSH
21386: LD_INT 2
21388: EQUAL
21389: AND
21390: IFFALSE 21407
// bpoints := bpoints * 1.5 ;
21392: LD_ADDR_VAR 0 10
21396: PUSH
21397: LD_VAR 0 10
21401: PUSH
21402: LD_REAL  1.50000000000000E+0000
21405: MUL
21406: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21407: LD_VAR 0 1
21411: PPUSH
21412: LD_INT 66
21414: PPUSH
21415: CALL_OW 321
21419: PUSH
21420: LD_INT 2
21422: EQUAL
21423: IFFALSE 21440
// bpoints := bpoints * 1.1 ;
21425: LD_ADDR_VAR 0 10
21429: PUSH
21430: LD_VAR 0 10
21434: PUSH
21435: LD_REAL  1.10000000000000E+0000
21438: MUL
21439: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21440: LD_ADDR_VAR 0 10
21444: PUSH
21445: LD_VAR 0 10
21449: PUSH
21450: LD_VAR 0 6
21454: PPUSH
21455: LD_INT 1
21457: PPUSH
21458: CALL_OW 259
21462: PUSH
21463: LD_REAL  1.15000000000000E+0000
21466: MUL
21467: MUL
21468: ST_TO_ADDR
// end ; unit_vehicle :
21469: GO 22299
21471: LD_INT 2
21473: DOUBLE
21474: EQUAL
21475: IFTRUE 21479
21477: GO 22287
21479: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21480: LD_VAR 0 6
21484: PPUSH
21485: CALL_OW 264
21489: PUSH
21490: LD_INT 2
21492: PUSH
21493: LD_INT 42
21495: PUSH
21496: LD_INT 24
21498: PUSH
21499: EMPTY
21500: LIST
21501: LIST
21502: LIST
21503: IN
21504: IFFALSE 21525
// points := [ 25 , 5 , 3 ] ;
21506: LD_ADDR_VAR 0 9
21510: PUSH
21511: LD_INT 25
21513: PUSH
21514: LD_INT 5
21516: PUSH
21517: LD_INT 3
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: LIST
21524: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21525: LD_VAR 0 6
21529: PPUSH
21530: CALL_OW 264
21534: PUSH
21535: LD_INT 4
21537: PUSH
21538: LD_INT 43
21540: PUSH
21541: LD_INT 25
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: LIST
21548: IN
21549: IFFALSE 21570
// points := [ 40 , 15 , 5 ] ;
21551: LD_ADDR_VAR 0 9
21555: PUSH
21556: LD_INT 40
21558: PUSH
21559: LD_INT 15
21561: PUSH
21562: LD_INT 5
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21570: LD_VAR 0 6
21574: PPUSH
21575: CALL_OW 264
21579: PUSH
21580: LD_INT 3
21582: PUSH
21583: LD_INT 23
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: IN
21590: IFFALSE 21611
// points := [ 7 , 25 , 8 ] ;
21592: LD_ADDR_VAR 0 9
21596: PUSH
21597: LD_INT 7
21599: PUSH
21600: LD_INT 25
21602: PUSH
21603: LD_INT 8
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: LIST
21610: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21611: LD_VAR 0 6
21615: PPUSH
21616: CALL_OW 264
21620: PUSH
21621: LD_INT 5
21623: PUSH
21624: LD_INT 27
21626: PUSH
21627: LD_INT 44
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: LIST
21634: IN
21635: IFFALSE 21656
// points := [ 14 , 50 , 16 ] ;
21637: LD_ADDR_VAR 0 9
21641: PUSH
21642: LD_INT 14
21644: PUSH
21645: LD_INT 50
21647: PUSH
21648: LD_INT 16
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: LIST
21655: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21656: LD_VAR 0 6
21660: PPUSH
21661: CALL_OW 264
21665: PUSH
21666: LD_INT 6
21668: PUSH
21669: LD_INT 46
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: IN
21676: IFFALSE 21697
// points := [ 32 , 120 , 70 ] ;
21678: LD_ADDR_VAR 0 9
21682: PUSH
21683: LD_INT 32
21685: PUSH
21686: LD_INT 120
21688: PUSH
21689: LD_INT 70
21691: PUSH
21692: EMPTY
21693: LIST
21694: LIST
21695: LIST
21696: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21697: LD_VAR 0 6
21701: PPUSH
21702: CALL_OW 264
21706: PUSH
21707: LD_INT 7
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_INT 45
21715: PUSH
21716: LD_EXP 109
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: LIST
21725: LIST
21726: IN
21727: IFFALSE 21748
// points := [ 35 , 20 , 45 ] ;
21729: LD_ADDR_VAR 0 9
21733: PUSH
21734: LD_INT 35
21736: PUSH
21737: LD_INT 20
21739: PUSH
21740: LD_INT 45
21742: PUSH
21743: EMPTY
21744: LIST
21745: LIST
21746: LIST
21747: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21748: LD_VAR 0 6
21752: PPUSH
21753: CALL_OW 264
21757: PUSH
21758: LD_INT 47
21760: PUSH
21761: EMPTY
21762: LIST
21763: IN
21764: IFFALSE 21785
// points := [ 67 , 45 , 75 ] ;
21766: LD_ADDR_VAR 0 9
21770: PUSH
21771: LD_INT 67
21773: PUSH
21774: LD_INT 45
21776: PUSH
21777: LD_INT 75
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: LIST
21784: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21785: LD_VAR 0 6
21789: PPUSH
21790: CALL_OW 264
21794: PUSH
21795: LD_INT 26
21797: PUSH
21798: EMPTY
21799: LIST
21800: IN
21801: IFFALSE 21822
// points := [ 120 , 30 , 80 ] ;
21803: LD_ADDR_VAR 0 9
21807: PUSH
21808: LD_INT 120
21810: PUSH
21811: LD_INT 30
21813: PUSH
21814: LD_INT 80
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: LIST
21821: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21822: LD_VAR 0 6
21826: PPUSH
21827: CALL_OW 264
21831: PUSH
21832: LD_INT 22
21834: PUSH
21835: EMPTY
21836: LIST
21837: IN
21838: IFFALSE 21859
// points := [ 40 , 1 , 1 ] ;
21840: LD_ADDR_VAR 0 9
21844: PUSH
21845: LD_INT 40
21847: PUSH
21848: LD_INT 1
21850: PUSH
21851: LD_INT 1
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21859: LD_VAR 0 6
21863: PPUSH
21864: CALL_OW 264
21868: PUSH
21869: LD_INT 29
21871: PUSH
21872: EMPTY
21873: LIST
21874: IN
21875: IFFALSE 21896
// points := [ 70 , 200 , 400 ] ;
21877: LD_ADDR_VAR 0 9
21881: PUSH
21882: LD_INT 70
21884: PUSH
21885: LD_INT 200
21887: PUSH
21888: LD_INT 400
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21896: LD_VAR 0 6
21900: PPUSH
21901: CALL_OW 264
21905: PUSH
21906: LD_INT 14
21908: PUSH
21909: LD_INT 53
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: IN
21916: IFFALSE 21937
// points := [ 40 , 10 , 20 ] ;
21918: LD_ADDR_VAR 0 9
21922: PUSH
21923: LD_INT 40
21925: PUSH
21926: LD_INT 10
21928: PUSH
21929: LD_INT 20
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: LIST
21936: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21937: LD_VAR 0 6
21941: PPUSH
21942: CALL_OW 264
21946: PUSH
21947: LD_INT 9
21949: PUSH
21950: EMPTY
21951: LIST
21952: IN
21953: IFFALSE 21974
// points := [ 5 , 70 , 20 ] ;
21955: LD_ADDR_VAR 0 9
21959: PUSH
21960: LD_INT 5
21962: PUSH
21963: LD_INT 70
21965: PUSH
21966: LD_INT 20
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21974: LD_VAR 0 6
21978: PPUSH
21979: CALL_OW 264
21983: PUSH
21984: LD_INT 10
21986: PUSH
21987: EMPTY
21988: LIST
21989: IN
21990: IFFALSE 22011
// points := [ 35 , 110 , 70 ] ;
21992: LD_ADDR_VAR 0 9
21996: PUSH
21997: LD_INT 35
21999: PUSH
22000: LD_INT 110
22002: PUSH
22003: LD_INT 70
22005: PUSH
22006: EMPTY
22007: LIST
22008: LIST
22009: LIST
22010: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22011: LD_VAR 0 6
22015: PPUSH
22016: CALL_OW 265
22020: PUSH
22021: LD_INT 25
22023: EQUAL
22024: IFFALSE 22045
// points := [ 80 , 65 , 100 ] ;
22026: LD_ADDR_VAR 0 9
22030: PUSH
22031: LD_INT 80
22033: PUSH
22034: LD_INT 65
22036: PUSH
22037: LD_INT 100
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: LIST
22044: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22045: LD_VAR 0 6
22049: PPUSH
22050: CALL_OW 263
22054: PUSH
22055: LD_INT 1
22057: EQUAL
22058: IFFALSE 22093
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22060: LD_ADDR_VAR 0 10
22064: PUSH
22065: LD_VAR 0 10
22069: PUSH
22070: LD_VAR 0 6
22074: PPUSH
22075: CALL_OW 311
22079: PPUSH
22080: LD_INT 3
22082: PPUSH
22083: CALL_OW 259
22087: PUSH
22088: LD_INT 4
22090: MUL
22091: MUL
22092: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22093: LD_VAR 0 6
22097: PPUSH
22098: CALL_OW 263
22102: PUSH
22103: LD_INT 2
22105: EQUAL
22106: IFFALSE 22157
// begin j := IsControledBy ( i ) ;
22108: LD_ADDR_VAR 0 7
22112: PUSH
22113: LD_VAR 0 6
22117: PPUSH
22118: CALL_OW 312
22122: ST_TO_ADDR
// if j then
22123: LD_VAR 0 7
22127: IFFALSE 22157
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22129: LD_ADDR_VAR 0 10
22133: PUSH
22134: LD_VAR 0 10
22138: PUSH
22139: LD_VAR 0 7
22143: PPUSH
22144: LD_INT 3
22146: PPUSH
22147: CALL_OW 259
22151: PUSH
22152: LD_INT 3
22154: MUL
22155: MUL
22156: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22157: LD_VAR 0 6
22161: PPUSH
22162: CALL_OW 264
22166: PUSH
22167: LD_INT 5
22169: PUSH
22170: LD_INT 6
22172: PUSH
22173: LD_INT 46
22175: PUSH
22176: LD_INT 44
22178: PUSH
22179: LD_INT 47
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: LD_INT 28
22187: PUSH
22188: LD_INT 7
22190: PUSH
22191: LD_INT 27
22193: PUSH
22194: LD_INT 29
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: LIST
22201: LIST
22202: LIST
22203: LIST
22204: LIST
22205: LIST
22206: LIST
22207: LIST
22208: IN
22209: PUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: LD_INT 52
22217: PPUSH
22218: CALL_OW 321
22222: PUSH
22223: LD_INT 2
22225: EQUAL
22226: AND
22227: IFFALSE 22244
// bpoints := bpoints * 1.2 ;
22229: LD_ADDR_VAR 0 10
22233: PUSH
22234: LD_VAR 0 10
22238: PUSH
22239: LD_REAL  1.20000000000000E+0000
22242: MUL
22243: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22244: LD_VAR 0 6
22248: PPUSH
22249: CALL_OW 264
22253: PUSH
22254: LD_INT 6
22256: PUSH
22257: LD_INT 46
22259: PUSH
22260: LD_INT 47
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: LIST
22267: IN
22268: IFFALSE 22285
// bpoints := bpoints * 1.2 ;
22270: LD_ADDR_VAR 0 10
22274: PUSH
22275: LD_VAR 0 10
22279: PUSH
22280: LD_REAL  1.20000000000000E+0000
22283: MUL
22284: ST_TO_ADDR
// end ; unit_building :
22285: GO 22299
22287: LD_INT 3
22289: DOUBLE
22290: EQUAL
22291: IFTRUE 22295
22293: GO 22298
22295: POP
// ; end ;
22296: GO 22299
22298: POP
// for j = 1 to 3 do
22299: LD_ADDR_VAR 0 7
22303: PUSH
22304: DOUBLE
22305: LD_INT 1
22307: DEC
22308: ST_TO_ADDR
22309: LD_INT 3
22311: PUSH
22312: FOR_TO
22313: IFFALSE 22366
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22315: LD_ADDR_VAR 0 5
22319: PUSH
22320: LD_VAR 0 5
22324: PPUSH
22325: LD_VAR 0 7
22329: PPUSH
22330: LD_VAR 0 5
22334: PUSH
22335: LD_VAR 0 7
22339: ARRAY
22340: PUSH
22341: LD_VAR 0 9
22345: PUSH
22346: LD_VAR 0 7
22350: ARRAY
22351: PUSH
22352: LD_VAR 0 10
22356: MUL
22357: PLUS
22358: PPUSH
22359: CALL_OW 1
22363: ST_TO_ADDR
22364: GO 22312
22366: POP
22367: POP
// end ;
22368: GO 20845
22370: POP
22371: POP
// result := Replace ( result , 4 , tmp ) ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 5
22381: PPUSH
22382: LD_INT 4
22384: PPUSH
22385: LD_VAR 0 8
22389: PPUSH
22390: CALL_OW 1
22394: ST_TO_ADDR
// end ;
22395: LD_VAR 0 5
22399: RET
// export function DangerAtRange ( unit , range ) ; begin
22400: LD_INT 0
22402: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22403: LD_ADDR_VAR 0 3
22407: PUSH
22408: LD_VAR 0 1
22412: PPUSH
22413: CALL_OW 255
22417: PPUSH
22418: LD_VAR 0 1
22422: PPUSH
22423: CALL_OW 250
22427: PPUSH
22428: LD_VAR 0 1
22432: PPUSH
22433: CALL_OW 251
22437: PPUSH
22438: LD_VAR 0 2
22442: PPUSH
22443: CALL 20697 0 4
22447: ST_TO_ADDR
// end ;
22448: LD_VAR 0 3
22452: RET
// export function DangerInArea ( side , area ) ; begin
22453: LD_INT 0
22455: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22456: LD_ADDR_VAR 0 3
22460: PUSH
22461: LD_VAR 0 2
22465: PPUSH
22466: LD_INT 81
22468: PUSH
22469: LD_VAR 0 1
22473: PUSH
22474: EMPTY
22475: LIST
22476: LIST
22477: PPUSH
22478: CALL_OW 70
22482: ST_TO_ADDR
// end ;
22483: LD_VAR 0 3
22487: RET
// export function IsExtension ( b ) ; begin
22488: LD_INT 0
22490: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22491: LD_ADDR_VAR 0 2
22495: PUSH
22496: LD_VAR 0 1
22500: PUSH
22501: LD_INT 23
22503: PUSH
22504: LD_INT 20
22506: PUSH
22507: LD_INT 22
22509: PUSH
22510: LD_INT 17
22512: PUSH
22513: LD_INT 24
22515: PUSH
22516: LD_INT 21
22518: PUSH
22519: LD_INT 19
22521: PUSH
22522: LD_INT 16
22524: PUSH
22525: LD_INT 25
22527: PUSH
22528: LD_INT 18
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: LIST
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: IN
22543: ST_TO_ADDR
// end ;
22544: LD_VAR 0 2
22548: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22549: LD_INT 0
22551: PPUSH
22552: PPUSH
22553: PPUSH
// result := [ ] ;
22554: LD_ADDR_VAR 0 4
22558: PUSH
22559: EMPTY
22560: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22561: LD_ADDR_VAR 0 5
22565: PUSH
22566: LD_VAR 0 2
22570: PPUSH
22571: LD_INT 21
22573: PUSH
22574: LD_INT 3
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PPUSH
22581: CALL_OW 70
22585: ST_TO_ADDR
// if not tmp then
22586: LD_VAR 0 5
22590: NOT
22591: IFFALSE 22595
// exit ;
22593: GO 22659
// if checkLink then
22595: LD_VAR 0 3
22599: IFFALSE 22649
// begin for i in tmp do
22601: LD_ADDR_VAR 0 6
22605: PUSH
22606: LD_VAR 0 5
22610: PUSH
22611: FOR_IN
22612: IFFALSE 22647
// if GetBase ( i ) <> base then
22614: LD_VAR 0 6
22618: PPUSH
22619: CALL_OW 274
22623: PUSH
22624: LD_VAR 0 1
22628: NONEQUAL
22629: IFFALSE 22645
// ComLinkToBase ( base , i ) ;
22631: LD_VAR 0 1
22635: PPUSH
22636: LD_VAR 0 6
22640: PPUSH
22641: CALL_OW 169
22645: GO 22611
22647: POP
22648: POP
// end ; result := tmp ;
22649: LD_ADDR_VAR 0 4
22653: PUSH
22654: LD_VAR 0 5
22658: ST_TO_ADDR
// end ;
22659: LD_VAR 0 4
22663: RET
// export function ComComplete ( units , b ) ; var i ; begin
22664: LD_INT 0
22666: PPUSH
22667: PPUSH
// if not units then
22668: LD_VAR 0 1
22672: NOT
22673: IFFALSE 22677
// exit ;
22675: GO 22767
// for i in units do
22677: LD_ADDR_VAR 0 4
22681: PUSH
22682: LD_VAR 0 1
22686: PUSH
22687: FOR_IN
22688: IFFALSE 22765
// if BuildingStatus ( b ) = bs_build then
22690: LD_VAR 0 2
22694: PPUSH
22695: CALL_OW 461
22699: PUSH
22700: LD_INT 1
22702: EQUAL
22703: IFFALSE 22763
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22705: LD_VAR 0 4
22709: PPUSH
22710: LD_STRING h
22712: PUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: CALL_OW 250
22722: PUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: CALL_OW 251
22732: PUSH
22733: LD_VAR 0 2
22737: PUSH
22738: LD_INT 0
22740: PUSH
22741: LD_INT 0
22743: PUSH
22744: LD_INT 0
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: PUSH
22756: EMPTY
22757: LIST
22758: PPUSH
22759: CALL_OW 446
22763: GO 22687
22765: POP
22766: POP
// end ;
22767: LD_VAR 0 3
22771: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22772: LD_INT 0
22774: PPUSH
22775: PPUSH
22776: PPUSH
22777: PPUSH
22778: PPUSH
22779: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22780: LD_VAR 0 1
22784: NOT
22785: PUSH
22786: LD_VAR 0 1
22790: PPUSH
22791: CALL_OW 263
22795: PUSH
22796: LD_INT 2
22798: NONEQUAL
22799: OR
22800: IFFALSE 22804
// exit ;
22802: GO 23120
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22804: LD_ADDR_VAR 0 6
22808: PUSH
22809: LD_INT 22
22811: PUSH
22812: LD_VAR 0 1
22816: PPUSH
22817: CALL_OW 255
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: PUSH
22826: LD_INT 2
22828: PUSH
22829: LD_INT 30
22831: PUSH
22832: LD_INT 36
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 34
22841: PUSH
22842: LD_INT 31
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: EMPTY
22850: LIST
22851: LIST
22852: LIST
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: PPUSH
22858: CALL_OW 69
22862: ST_TO_ADDR
// if not tmp then
22863: LD_VAR 0 6
22867: NOT
22868: IFFALSE 22872
// exit ;
22870: GO 23120
// result := [ ] ;
22872: LD_ADDR_VAR 0 2
22876: PUSH
22877: EMPTY
22878: ST_TO_ADDR
// for i in tmp do
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_VAR 0 6
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22961
// begin t := UnitsInside ( i ) ;
22892: LD_ADDR_VAR 0 4
22896: PUSH
22897: LD_VAR 0 3
22901: PPUSH
22902: CALL_OW 313
22906: ST_TO_ADDR
// if t then
22907: LD_VAR 0 4
22911: IFFALSE 22959
// for j in t do
22913: LD_ADDR_VAR 0 7
22917: PUSH
22918: LD_VAR 0 4
22922: PUSH
22923: FOR_IN
22924: IFFALSE 22957
// result := Replace ( result , result + 1 , j ) ;
22926: LD_ADDR_VAR 0 2
22930: PUSH
22931: LD_VAR 0 2
22935: PPUSH
22936: LD_VAR 0 2
22940: PUSH
22941: LD_INT 1
22943: PLUS
22944: PPUSH
22945: LD_VAR 0 7
22949: PPUSH
22950: CALL_OW 1
22954: ST_TO_ADDR
22955: GO 22923
22957: POP
22958: POP
// end ;
22959: GO 22889
22961: POP
22962: POP
// if not result then
22963: LD_VAR 0 2
22967: NOT
22968: IFFALSE 22972
// exit ;
22970: GO 23120
// mech := result [ 1 ] ;
22972: LD_ADDR_VAR 0 5
22976: PUSH
22977: LD_VAR 0 2
22981: PUSH
22982: LD_INT 1
22984: ARRAY
22985: ST_TO_ADDR
// if result > 1 then
22986: LD_VAR 0 2
22990: PUSH
22991: LD_INT 1
22993: GREATER
22994: IFFALSE 23106
// begin for i = 2 to result do
22996: LD_ADDR_VAR 0 3
23000: PUSH
23001: DOUBLE
23002: LD_INT 2
23004: DEC
23005: ST_TO_ADDR
23006: LD_VAR 0 2
23010: PUSH
23011: FOR_TO
23012: IFFALSE 23104
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23014: LD_ADDR_VAR 0 4
23018: PUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_VAR 0 3
23028: ARRAY
23029: PPUSH
23030: LD_INT 3
23032: PPUSH
23033: CALL_OW 259
23037: PUSH
23038: LD_VAR 0 2
23042: PUSH
23043: LD_VAR 0 3
23047: ARRAY
23048: PPUSH
23049: CALL_OW 432
23053: MINUS
23054: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23055: LD_VAR 0 4
23059: PUSH
23060: LD_VAR 0 5
23064: PPUSH
23065: LD_INT 3
23067: PPUSH
23068: CALL_OW 259
23072: PUSH
23073: LD_VAR 0 5
23077: PPUSH
23078: CALL_OW 432
23082: MINUS
23083: GREATEREQUAL
23084: IFFALSE 23102
// mech := result [ i ] ;
23086: LD_ADDR_VAR 0 5
23090: PUSH
23091: LD_VAR 0 2
23095: PUSH
23096: LD_VAR 0 3
23100: ARRAY
23101: ST_TO_ADDR
// end ;
23102: GO 23011
23104: POP
23105: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23106: LD_VAR 0 1
23110: PPUSH
23111: LD_VAR 0 5
23115: PPUSH
23116: CALL_OW 135
// end ;
23120: LD_VAR 0 2
23124: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23125: LD_INT 0
23127: PPUSH
23128: PPUSH
23129: PPUSH
23130: PPUSH
23131: PPUSH
23132: PPUSH
23133: PPUSH
23134: PPUSH
23135: PPUSH
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
// result := [ ] ;
23140: LD_ADDR_VAR 0 7
23144: PUSH
23145: EMPTY
23146: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23147: LD_VAR 0 1
23151: PPUSH
23152: CALL_OW 266
23156: PUSH
23157: LD_INT 0
23159: PUSH
23160: LD_INT 1
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: IN
23167: NOT
23168: IFFALSE 23172
// exit ;
23170: GO 24806
// if name then
23172: LD_VAR 0 3
23176: IFFALSE 23192
// SetBName ( base_dep , name ) ;
23178: LD_VAR 0 1
23182: PPUSH
23183: LD_VAR 0 3
23187: PPUSH
23188: CALL_OW 500
// base := GetBase ( base_dep ) ;
23192: LD_ADDR_VAR 0 15
23196: PUSH
23197: LD_VAR 0 1
23201: PPUSH
23202: CALL_OW 274
23206: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23207: LD_ADDR_VAR 0 16
23211: PUSH
23212: LD_VAR 0 1
23216: PPUSH
23217: CALL_OW 255
23221: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23222: LD_ADDR_VAR 0 17
23226: PUSH
23227: LD_VAR 0 1
23231: PPUSH
23232: CALL_OW 248
23236: ST_TO_ADDR
// if sources then
23237: LD_VAR 0 5
23241: IFFALSE 23288
// for i = 1 to 3 do
23243: LD_ADDR_VAR 0 8
23247: PUSH
23248: DOUBLE
23249: LD_INT 1
23251: DEC
23252: ST_TO_ADDR
23253: LD_INT 3
23255: PUSH
23256: FOR_TO
23257: IFFALSE 23286
// AddResourceType ( base , i , sources [ i ] ) ;
23259: LD_VAR 0 15
23263: PPUSH
23264: LD_VAR 0 8
23268: PPUSH
23269: LD_VAR 0 5
23273: PUSH
23274: LD_VAR 0 8
23278: ARRAY
23279: PPUSH
23280: CALL_OW 276
23284: GO 23256
23286: POP
23287: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23288: LD_ADDR_VAR 0 18
23292: PUSH
23293: LD_VAR 0 15
23297: PPUSH
23298: LD_VAR 0 2
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL 22549 0 3
23310: ST_TO_ADDR
// InitHc ;
23311: CALL_OW 19
// InitUc ;
23315: CALL_OW 18
// uc_side := side ;
23319: LD_ADDR_OWVAR 20
23323: PUSH
23324: LD_VAR 0 16
23328: ST_TO_ADDR
// uc_nation := nation ;
23329: LD_ADDR_OWVAR 21
23333: PUSH
23334: LD_VAR 0 17
23338: ST_TO_ADDR
// if buildings then
23339: LD_VAR 0 18
23343: IFFALSE 24665
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23345: LD_ADDR_VAR 0 19
23349: PUSH
23350: LD_VAR 0 18
23354: PPUSH
23355: LD_INT 2
23357: PUSH
23358: LD_INT 30
23360: PUSH
23361: LD_INT 29
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: LD_INT 30
23370: PUSH
23371: LD_INT 30
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: PPUSH
23383: CALL_OW 72
23387: ST_TO_ADDR
// if tmp then
23388: LD_VAR 0 19
23392: IFFALSE 23440
// for i in tmp do
23394: LD_ADDR_VAR 0 8
23398: PUSH
23399: LD_VAR 0 19
23403: PUSH
23404: FOR_IN
23405: IFFALSE 23438
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23407: LD_VAR 0 8
23411: PPUSH
23412: CALL_OW 250
23416: PPUSH
23417: LD_VAR 0 8
23421: PPUSH
23422: CALL_OW 251
23426: PPUSH
23427: LD_VAR 0 16
23431: PPUSH
23432: CALL_OW 441
23436: GO 23404
23438: POP
23439: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23440: LD_VAR 0 18
23444: PPUSH
23445: LD_INT 2
23447: PUSH
23448: LD_INT 30
23450: PUSH
23451: LD_INT 32
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 30
23460: PUSH
23461: LD_INT 33
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: LIST
23472: PPUSH
23473: CALL_OW 72
23477: IFFALSE 23565
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23479: LD_ADDR_VAR 0 8
23483: PUSH
23484: LD_VAR 0 18
23488: PPUSH
23489: LD_INT 2
23491: PUSH
23492: LD_INT 30
23494: PUSH
23495: LD_INT 32
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PUSH
23502: LD_INT 30
23504: PUSH
23505: LD_INT 33
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PPUSH
23517: CALL_OW 72
23521: PUSH
23522: FOR_IN
23523: IFFALSE 23563
// begin if not GetBWeapon ( i ) then
23525: LD_VAR 0 8
23529: PPUSH
23530: CALL_OW 269
23534: NOT
23535: IFFALSE 23561
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 8
23546: PPUSH
23547: LD_VAR 0 2
23551: PPUSH
23552: CALL 24811 0 2
23556: PPUSH
23557: CALL_OW 431
// end ;
23561: GO 23522
23563: POP
23564: POP
// end ; for i = 1 to personel do
23565: LD_ADDR_VAR 0 8
23569: PUSH
23570: DOUBLE
23571: LD_INT 1
23573: DEC
23574: ST_TO_ADDR
23575: LD_VAR 0 6
23579: PUSH
23580: FOR_TO
23581: IFFALSE 24645
// begin if i > 4 then
23583: LD_VAR 0 8
23587: PUSH
23588: LD_INT 4
23590: GREATER
23591: IFFALSE 23595
// break ;
23593: GO 24645
// case i of 1 :
23595: LD_VAR 0 8
23599: PUSH
23600: LD_INT 1
23602: DOUBLE
23603: EQUAL
23604: IFTRUE 23608
23606: GO 23688
23608: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23609: LD_ADDR_VAR 0 12
23613: PUSH
23614: LD_VAR 0 18
23618: PPUSH
23619: LD_INT 22
23621: PUSH
23622: LD_VAR 0 16
23626: PUSH
23627: EMPTY
23628: LIST
23629: LIST
23630: PUSH
23631: LD_INT 58
23633: PUSH
23634: EMPTY
23635: LIST
23636: PUSH
23637: LD_INT 2
23639: PUSH
23640: LD_INT 30
23642: PUSH
23643: LD_INT 32
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 4
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 5
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: LIST
23680: PPUSH
23681: CALL_OW 72
23685: ST_TO_ADDR
23686: GO 23910
23688: LD_INT 2
23690: DOUBLE
23691: EQUAL
23692: IFTRUE 23696
23694: GO 23758
23696: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23697: LD_ADDR_VAR 0 12
23701: PUSH
23702: LD_VAR 0 18
23706: PPUSH
23707: LD_INT 22
23709: PUSH
23710: LD_VAR 0 16
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 2
23721: PUSH
23722: LD_INT 30
23724: PUSH
23725: LD_INT 0
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: LD_INT 30
23734: PUSH
23735: LD_INT 1
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: LIST
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PPUSH
23751: CALL_OW 72
23755: ST_TO_ADDR
23756: GO 23910
23758: LD_INT 3
23760: DOUBLE
23761: EQUAL
23762: IFTRUE 23766
23764: GO 23828
23766: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23767: LD_ADDR_VAR 0 12
23771: PUSH
23772: LD_VAR 0 18
23776: PPUSH
23777: LD_INT 22
23779: PUSH
23780: LD_VAR 0 16
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: PUSH
23789: LD_INT 2
23791: PUSH
23792: LD_INT 30
23794: PUSH
23795: LD_INT 2
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 30
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: LIST
23816: PUSH
23817: EMPTY
23818: LIST
23819: LIST
23820: PPUSH
23821: CALL_OW 72
23825: ST_TO_ADDR
23826: GO 23910
23828: LD_INT 4
23830: DOUBLE
23831: EQUAL
23832: IFTRUE 23836
23834: GO 23909
23836: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23837: LD_ADDR_VAR 0 12
23841: PUSH
23842: LD_VAR 0 18
23846: PPUSH
23847: LD_INT 22
23849: PUSH
23850: LD_VAR 0 16
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: PUSH
23859: LD_INT 2
23861: PUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 6
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: LD_INT 30
23874: PUSH
23875: LD_INT 7
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PUSH
23882: LD_INT 30
23884: PUSH
23885: LD_INT 8
23887: PUSH
23888: EMPTY
23889: LIST
23890: LIST
23891: PUSH
23892: EMPTY
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 72
23906: ST_TO_ADDR
23907: GO 23910
23909: POP
// if i = 1 then
23910: LD_VAR 0 8
23914: PUSH
23915: LD_INT 1
23917: EQUAL
23918: IFFALSE 24029
// begin tmp := [ ] ;
23920: LD_ADDR_VAR 0 19
23924: PUSH
23925: EMPTY
23926: ST_TO_ADDR
// for j in f do
23927: LD_ADDR_VAR 0 9
23931: PUSH
23932: LD_VAR 0 12
23936: PUSH
23937: FOR_IN
23938: IFFALSE 24011
// if GetBType ( j ) = b_bunker then
23940: LD_VAR 0 9
23944: PPUSH
23945: CALL_OW 266
23949: PUSH
23950: LD_INT 32
23952: EQUAL
23953: IFFALSE 23980
// tmp := Insert ( tmp , 1 , j ) else
23955: LD_ADDR_VAR 0 19
23959: PUSH
23960: LD_VAR 0 19
23964: PPUSH
23965: LD_INT 1
23967: PPUSH
23968: LD_VAR 0 9
23972: PPUSH
23973: CALL_OW 2
23977: ST_TO_ADDR
23978: GO 24009
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23980: LD_ADDR_VAR 0 19
23984: PUSH
23985: LD_VAR 0 19
23989: PPUSH
23990: LD_VAR 0 19
23994: PUSH
23995: LD_INT 1
23997: PLUS
23998: PPUSH
23999: LD_VAR 0 9
24003: PPUSH
24004: CALL_OW 2
24008: ST_TO_ADDR
24009: GO 23937
24011: POP
24012: POP
// if tmp then
24013: LD_VAR 0 19
24017: IFFALSE 24029
// f := tmp ;
24019: LD_ADDR_VAR 0 12
24023: PUSH
24024: LD_VAR 0 19
24028: ST_TO_ADDR
// end ; x := personel [ i ] ;
24029: LD_ADDR_VAR 0 13
24033: PUSH
24034: LD_VAR 0 6
24038: PUSH
24039: LD_VAR 0 8
24043: ARRAY
24044: ST_TO_ADDR
// if x = - 1 then
24045: LD_VAR 0 13
24049: PUSH
24050: LD_INT 1
24052: NEG
24053: EQUAL
24054: IFFALSE 24263
// begin for j in f do
24056: LD_ADDR_VAR 0 9
24060: PUSH
24061: LD_VAR 0 12
24065: PUSH
24066: FOR_IN
24067: IFFALSE 24259
// repeat InitHc ;
24069: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24073: LD_VAR 0 9
24077: PPUSH
24078: CALL_OW 266
24082: PUSH
24083: LD_INT 5
24085: EQUAL
24086: IFFALSE 24156
// begin if UnitsInside ( j ) < 3 then
24088: LD_VAR 0 9
24092: PPUSH
24093: CALL_OW 313
24097: PUSH
24098: LD_INT 3
24100: LESS
24101: IFFALSE 24137
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24103: LD_INT 0
24105: PPUSH
24106: LD_INT 5
24108: PUSH
24109: LD_INT 8
24111: PUSH
24112: LD_INT 9
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: PUSH
24120: LD_VAR 0 17
24124: ARRAY
24125: PPUSH
24126: LD_VAR 0 4
24130: PPUSH
24131: CALL_OW 380
24135: GO 24154
// PrepareHuman ( false , i , skill ) ;
24137: LD_INT 0
24139: PPUSH
24140: LD_VAR 0 8
24144: PPUSH
24145: LD_VAR 0 4
24149: PPUSH
24150: CALL_OW 380
// end else
24154: GO 24173
// PrepareHuman ( false , i , skill ) ;
24156: LD_INT 0
24158: PPUSH
24159: LD_VAR 0 8
24163: PPUSH
24164: LD_VAR 0 4
24168: PPUSH
24169: CALL_OW 380
// un := CreateHuman ;
24173: LD_ADDR_VAR 0 14
24177: PUSH
24178: CALL_OW 44
24182: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PPUSH
24193: LD_INT 1
24195: PPUSH
24196: LD_VAR 0 14
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24206: LD_VAR 0 14
24210: PPUSH
24211: LD_VAR 0 9
24215: PPUSH
24216: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24220: LD_VAR 0 9
24224: PPUSH
24225: CALL_OW 313
24229: PUSH
24230: LD_INT 6
24232: EQUAL
24233: PUSH
24234: LD_VAR 0 9
24238: PPUSH
24239: CALL_OW 266
24243: PUSH
24244: LD_INT 32
24246: PUSH
24247: LD_INT 31
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: IN
24254: OR
24255: IFFALSE 24069
24257: GO 24066
24259: POP
24260: POP
// end else
24261: GO 24643
// for j = 1 to x do
24263: LD_ADDR_VAR 0 9
24267: PUSH
24268: DOUBLE
24269: LD_INT 1
24271: DEC
24272: ST_TO_ADDR
24273: LD_VAR 0 13
24277: PUSH
24278: FOR_TO
24279: IFFALSE 24641
// begin InitHc ;
24281: CALL_OW 19
// if not f then
24285: LD_VAR 0 12
24289: NOT
24290: IFFALSE 24379
// begin PrepareHuman ( false , i , skill ) ;
24292: LD_INT 0
24294: PPUSH
24295: LD_VAR 0 8
24299: PPUSH
24300: LD_VAR 0 4
24304: PPUSH
24305: CALL_OW 380
// un := CreateHuman ;
24309: LD_ADDR_VAR 0 14
24313: PUSH
24314: CALL_OW 44
24318: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24319: LD_ADDR_VAR 0 7
24323: PUSH
24324: LD_VAR 0 7
24328: PPUSH
24329: LD_INT 1
24331: PPUSH
24332: LD_VAR 0 14
24336: PPUSH
24337: CALL_OW 2
24341: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24342: LD_VAR 0 14
24346: PPUSH
24347: LD_VAR 0 1
24351: PPUSH
24352: CALL_OW 250
24356: PPUSH
24357: LD_VAR 0 1
24361: PPUSH
24362: CALL_OW 251
24366: PPUSH
24367: LD_INT 10
24369: PPUSH
24370: LD_INT 0
24372: PPUSH
24373: CALL_OW 50
// continue ;
24377: GO 24278
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24379: LD_VAR 0 12
24383: PUSH
24384: LD_INT 1
24386: ARRAY
24387: PPUSH
24388: CALL_OW 313
24392: PUSH
24393: LD_VAR 0 12
24397: PUSH
24398: LD_INT 1
24400: ARRAY
24401: PPUSH
24402: CALL_OW 266
24406: PUSH
24407: LD_INT 32
24409: PUSH
24410: LD_INT 31
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: IN
24417: AND
24418: PUSH
24419: LD_VAR 0 12
24423: PUSH
24424: LD_INT 1
24426: ARRAY
24427: PPUSH
24428: CALL_OW 313
24432: PUSH
24433: LD_INT 6
24435: EQUAL
24436: OR
24437: IFFALSE 24457
// f := Delete ( f , 1 ) ;
24439: LD_ADDR_VAR 0 12
24443: PUSH
24444: LD_VAR 0 12
24448: PPUSH
24449: LD_INT 1
24451: PPUSH
24452: CALL_OW 3
24456: ST_TO_ADDR
// if not f then
24457: LD_VAR 0 12
24461: NOT
24462: IFFALSE 24480
// begin x := x + 2 ;
24464: LD_ADDR_VAR 0 13
24468: PUSH
24469: LD_VAR 0 13
24473: PUSH
24474: LD_INT 2
24476: PLUS
24477: ST_TO_ADDR
// continue ;
24478: GO 24278
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24480: LD_VAR 0 12
24484: PUSH
24485: LD_INT 1
24487: ARRAY
24488: PPUSH
24489: CALL_OW 266
24493: PUSH
24494: LD_INT 5
24496: EQUAL
24497: IFFALSE 24571
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24499: LD_VAR 0 12
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 313
24512: PUSH
24513: LD_INT 3
24515: LESS
24516: IFFALSE 24552
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24518: LD_INT 0
24520: PPUSH
24521: LD_INT 5
24523: PUSH
24524: LD_INT 8
24526: PUSH
24527: LD_INT 9
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: LIST
24534: PUSH
24535: LD_VAR 0 17
24539: ARRAY
24540: PPUSH
24541: LD_VAR 0 4
24545: PPUSH
24546: CALL_OW 380
24550: GO 24569
// PrepareHuman ( false , i , skill ) ;
24552: LD_INT 0
24554: PPUSH
24555: LD_VAR 0 8
24559: PPUSH
24560: LD_VAR 0 4
24564: PPUSH
24565: CALL_OW 380
// end else
24569: GO 24588
// PrepareHuman ( false , i , skill ) ;
24571: LD_INT 0
24573: PPUSH
24574: LD_VAR 0 8
24578: PPUSH
24579: LD_VAR 0 4
24583: PPUSH
24584: CALL_OW 380
// un := CreateHuman ;
24588: LD_ADDR_VAR 0 14
24592: PUSH
24593: CALL_OW 44
24597: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24598: LD_ADDR_VAR 0 7
24602: PUSH
24603: LD_VAR 0 7
24607: PPUSH
24608: LD_INT 1
24610: PPUSH
24611: LD_VAR 0 14
24615: PPUSH
24616: CALL_OW 2
24620: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24621: LD_VAR 0 14
24625: PPUSH
24626: LD_VAR 0 12
24630: PUSH
24631: LD_INT 1
24633: ARRAY
24634: PPUSH
24635: CALL_OW 52
// end ;
24639: GO 24278
24641: POP
24642: POP
// end ;
24643: GO 23580
24645: POP
24646: POP
// result := result ^ buildings ;
24647: LD_ADDR_VAR 0 7
24651: PUSH
24652: LD_VAR 0 7
24656: PUSH
24657: LD_VAR 0 18
24661: ADD
24662: ST_TO_ADDR
// end else
24663: GO 24806
// begin for i = 1 to personel do
24665: LD_ADDR_VAR 0 8
24669: PUSH
24670: DOUBLE
24671: LD_INT 1
24673: DEC
24674: ST_TO_ADDR
24675: LD_VAR 0 6
24679: PUSH
24680: FOR_TO
24681: IFFALSE 24804
// begin if i > 4 then
24683: LD_VAR 0 8
24687: PUSH
24688: LD_INT 4
24690: GREATER
24691: IFFALSE 24695
// break ;
24693: GO 24804
// x := personel [ i ] ;
24695: LD_ADDR_VAR 0 13
24699: PUSH
24700: LD_VAR 0 6
24704: PUSH
24705: LD_VAR 0 8
24709: ARRAY
24710: ST_TO_ADDR
// if x = - 1 then
24711: LD_VAR 0 13
24715: PUSH
24716: LD_INT 1
24718: NEG
24719: EQUAL
24720: IFFALSE 24724
// continue ;
24722: GO 24680
// PrepareHuman ( false , i , skill ) ;
24724: LD_INT 0
24726: PPUSH
24727: LD_VAR 0 8
24731: PPUSH
24732: LD_VAR 0 4
24736: PPUSH
24737: CALL_OW 380
// un := CreateHuman ;
24741: LD_ADDR_VAR 0 14
24745: PUSH
24746: CALL_OW 44
24750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24751: LD_VAR 0 14
24755: PPUSH
24756: LD_VAR 0 1
24760: PPUSH
24761: CALL_OW 250
24765: PPUSH
24766: LD_VAR 0 1
24770: PPUSH
24771: CALL_OW 251
24775: PPUSH
24776: LD_INT 10
24778: PPUSH
24779: LD_INT 0
24781: PPUSH
24782: CALL_OW 50
// result := result ^ un ;
24786: LD_ADDR_VAR 0 7
24790: PUSH
24791: LD_VAR 0 7
24795: PUSH
24796: LD_VAR 0 14
24800: ADD
24801: ST_TO_ADDR
// end ;
24802: GO 24680
24804: POP
24805: POP
// end ; end ;
24806: LD_VAR 0 7
24810: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24811: LD_INT 0
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
// result := false ;
24829: LD_ADDR_VAR 0 3
24833: PUSH
24834: LD_INT 0
24836: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24837: LD_VAR 0 1
24841: NOT
24842: PUSH
24843: LD_VAR 0 1
24847: PPUSH
24848: CALL_OW 266
24852: PUSH
24853: LD_INT 32
24855: PUSH
24856: LD_INT 33
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: IN
24863: NOT
24864: OR
24865: IFFALSE 24869
// exit ;
24867: GO 25978
// nat := GetNation ( tower ) ;
24869: LD_ADDR_VAR 0 12
24873: PUSH
24874: LD_VAR 0 1
24878: PPUSH
24879: CALL_OW 248
24883: ST_TO_ADDR
// side := GetSide ( tower ) ;
24884: LD_ADDR_VAR 0 16
24888: PUSH
24889: LD_VAR 0 1
24893: PPUSH
24894: CALL_OW 255
24898: ST_TO_ADDR
// x := GetX ( tower ) ;
24899: LD_ADDR_VAR 0 10
24903: PUSH
24904: LD_VAR 0 1
24908: PPUSH
24909: CALL_OW 250
24913: ST_TO_ADDR
// y := GetY ( tower ) ;
24914: LD_ADDR_VAR 0 11
24918: PUSH
24919: LD_VAR 0 1
24923: PPUSH
24924: CALL_OW 251
24928: ST_TO_ADDR
// if not x or not y then
24929: LD_VAR 0 10
24933: NOT
24934: PUSH
24935: LD_VAR 0 11
24939: NOT
24940: OR
24941: IFFALSE 24945
// exit ;
24943: GO 25978
// weapon := 0 ;
24945: LD_ADDR_VAR 0 18
24949: PUSH
24950: LD_INT 0
24952: ST_TO_ADDR
// fac_list := [ ] ;
24953: LD_ADDR_VAR 0 17
24957: PUSH
24958: EMPTY
24959: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24960: LD_ADDR_VAR 0 6
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: CALL_OW 274
24974: PPUSH
24975: LD_VAR 0 2
24979: PPUSH
24980: LD_INT 0
24982: PPUSH
24983: CALL 22549 0 3
24987: PPUSH
24988: LD_INT 30
24990: PUSH
24991: LD_INT 3
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PPUSH
24998: CALL_OW 72
25002: ST_TO_ADDR
// if not factories then
25003: LD_VAR 0 6
25007: NOT
25008: IFFALSE 25012
// exit ;
25010: GO 25978
// for i in factories do
25012: LD_ADDR_VAR 0 8
25016: PUSH
25017: LD_VAR 0 6
25021: PUSH
25022: FOR_IN
25023: IFFALSE 25048
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25025: LD_ADDR_VAR 0 17
25029: PUSH
25030: LD_VAR 0 17
25034: PUSH
25035: LD_VAR 0 8
25039: PPUSH
25040: CALL_OW 478
25044: UNION
25045: ST_TO_ADDR
25046: GO 25022
25048: POP
25049: POP
// if not fac_list then
25050: LD_VAR 0 17
25054: NOT
25055: IFFALSE 25059
// exit ;
25057: GO 25978
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25059: LD_ADDR_VAR 0 5
25063: PUSH
25064: LD_INT 4
25066: PUSH
25067: LD_INT 5
25069: PUSH
25070: LD_INT 9
25072: PUSH
25073: LD_INT 10
25075: PUSH
25076: LD_INT 6
25078: PUSH
25079: LD_INT 7
25081: PUSH
25082: LD_INT 11
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: LIST
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: PUSH
25094: LD_INT 27
25096: PUSH
25097: LD_INT 28
25099: PUSH
25100: LD_INT 26
25102: PUSH
25103: LD_INT 30
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 43
25114: PUSH
25115: LD_INT 44
25117: PUSH
25118: LD_INT 46
25120: PUSH
25121: LD_INT 45
25123: PUSH
25124: LD_INT 47
25126: PUSH
25127: LD_INT 49
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: LIST
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: LIST
25142: PUSH
25143: LD_VAR 0 12
25147: ARRAY
25148: ST_TO_ADDR
// list := list isect fac_list ;
25149: LD_ADDR_VAR 0 5
25153: PUSH
25154: LD_VAR 0 5
25158: PUSH
25159: LD_VAR 0 17
25163: ISECT
25164: ST_TO_ADDR
// if not list then
25165: LD_VAR 0 5
25169: NOT
25170: IFFALSE 25174
// exit ;
25172: GO 25978
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25174: LD_VAR 0 12
25178: PUSH
25179: LD_INT 3
25181: EQUAL
25182: PUSH
25183: LD_INT 49
25185: PUSH
25186: LD_VAR 0 5
25190: IN
25191: AND
25192: PUSH
25193: LD_INT 31
25195: PPUSH
25196: LD_VAR 0 16
25200: PPUSH
25201: CALL_OW 321
25205: PUSH
25206: LD_INT 2
25208: EQUAL
25209: AND
25210: IFFALSE 25270
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25212: LD_INT 22
25214: PUSH
25215: LD_VAR 0 16
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: PUSH
25224: LD_INT 35
25226: PUSH
25227: LD_INT 49
25229: PUSH
25230: EMPTY
25231: LIST
25232: LIST
25233: PUSH
25234: LD_INT 91
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: LD_INT 10
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: PUSH
25250: EMPTY
25251: LIST
25252: LIST
25253: LIST
25254: PPUSH
25255: CALL_OW 69
25259: NOT
25260: IFFALSE 25270
// weapon := ru_time_lapser ;
25262: LD_ADDR_VAR 0 18
25266: PUSH
25267: LD_INT 49
25269: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25270: LD_VAR 0 12
25274: PUSH
25275: LD_INT 1
25277: PUSH
25278: LD_INT 2
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: IN
25285: PUSH
25286: LD_INT 11
25288: PUSH
25289: LD_VAR 0 5
25293: IN
25294: PUSH
25295: LD_INT 30
25297: PUSH
25298: LD_VAR 0 5
25302: IN
25303: OR
25304: AND
25305: PUSH
25306: LD_INT 6
25308: PPUSH
25309: LD_VAR 0 16
25313: PPUSH
25314: CALL_OW 321
25318: PUSH
25319: LD_INT 2
25321: EQUAL
25322: AND
25323: IFFALSE 25488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25325: LD_INT 22
25327: PUSH
25328: LD_VAR 0 16
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 2
25339: PUSH
25340: LD_INT 35
25342: PUSH
25343: LD_INT 11
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 35
25352: PUSH
25353: LD_INT 30
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 91
25367: PUSH
25368: LD_VAR 0 1
25372: PUSH
25373: LD_INT 18
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: LIST
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: LIST
25385: PPUSH
25386: CALL_OW 69
25390: NOT
25391: PUSH
25392: LD_INT 22
25394: PUSH
25395: LD_VAR 0 16
25399: PUSH
25400: EMPTY
25401: LIST
25402: LIST
25403: PUSH
25404: LD_INT 2
25406: PUSH
25407: LD_INT 30
25409: PUSH
25410: LD_INT 32
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 30
25419: PUSH
25420: LD_INT 33
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: PUSH
25432: LD_INT 91
25434: PUSH
25435: LD_VAR 0 1
25439: PUSH
25440: LD_INT 12
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: LIST
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: LIST
25452: PUSH
25453: EMPTY
25454: LIST
25455: PPUSH
25456: CALL_OW 69
25460: PUSH
25461: LD_INT 2
25463: GREATER
25464: AND
25465: IFFALSE 25488
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25467: LD_ADDR_VAR 0 18
25471: PUSH
25472: LD_INT 11
25474: PUSH
25475: LD_INT 30
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_VAR 0 12
25486: ARRAY
25487: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25488: LD_VAR 0 18
25492: NOT
25493: PUSH
25494: LD_INT 40
25496: PPUSH
25497: LD_VAR 0 16
25501: PPUSH
25502: CALL_OW 321
25506: PUSH
25507: LD_INT 2
25509: EQUAL
25510: AND
25511: PUSH
25512: LD_INT 7
25514: PUSH
25515: LD_VAR 0 5
25519: IN
25520: PUSH
25521: LD_INT 28
25523: PUSH
25524: LD_VAR 0 5
25528: IN
25529: OR
25530: PUSH
25531: LD_INT 45
25533: PUSH
25534: LD_VAR 0 5
25538: IN
25539: OR
25540: AND
25541: IFFALSE 25795
// begin hex := GetHexInfo ( x , y ) ;
25543: LD_ADDR_VAR 0 4
25547: PUSH
25548: LD_VAR 0 10
25552: PPUSH
25553: LD_VAR 0 11
25557: PPUSH
25558: CALL_OW 546
25562: ST_TO_ADDR
// if hex [ 1 ] then
25563: LD_VAR 0 4
25567: PUSH
25568: LD_INT 1
25570: ARRAY
25571: IFFALSE 25575
// exit ;
25573: GO 25978
// height := hex [ 2 ] ;
25575: LD_ADDR_VAR 0 15
25579: PUSH
25580: LD_VAR 0 4
25584: PUSH
25585: LD_INT 2
25587: ARRAY
25588: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25589: LD_ADDR_VAR 0 14
25593: PUSH
25594: LD_INT 0
25596: PUSH
25597: LD_INT 2
25599: PUSH
25600: LD_INT 3
25602: PUSH
25603: LD_INT 5
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: ST_TO_ADDR
// for i in tmp do
25612: LD_ADDR_VAR 0 8
25616: PUSH
25617: LD_VAR 0 14
25621: PUSH
25622: FOR_IN
25623: IFFALSE 25793
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25625: LD_ADDR_VAR 0 9
25629: PUSH
25630: LD_VAR 0 10
25634: PPUSH
25635: LD_VAR 0 8
25639: PPUSH
25640: LD_INT 5
25642: PPUSH
25643: CALL_OW 272
25647: PUSH
25648: LD_VAR 0 11
25652: PPUSH
25653: LD_VAR 0 8
25657: PPUSH
25658: LD_INT 5
25660: PPUSH
25661: CALL_OW 273
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25670: LD_VAR 0 9
25674: PUSH
25675: LD_INT 1
25677: ARRAY
25678: PPUSH
25679: LD_VAR 0 9
25683: PUSH
25684: LD_INT 2
25686: ARRAY
25687: PPUSH
25688: CALL_OW 488
25692: IFFALSE 25791
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25694: LD_ADDR_VAR 0 4
25698: PUSH
25699: LD_VAR 0 9
25703: PUSH
25704: LD_INT 1
25706: ARRAY
25707: PPUSH
25708: LD_VAR 0 9
25712: PUSH
25713: LD_INT 2
25715: ARRAY
25716: PPUSH
25717: CALL_OW 546
25721: ST_TO_ADDR
// if hex [ 1 ] then
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 1
25729: ARRAY
25730: IFFALSE 25734
// continue ;
25732: GO 25622
// h := hex [ 2 ] ;
25734: LD_ADDR_VAR 0 13
25738: PUSH
25739: LD_VAR 0 4
25743: PUSH
25744: LD_INT 2
25746: ARRAY
25747: ST_TO_ADDR
// if h + 7 < height then
25748: LD_VAR 0 13
25752: PUSH
25753: LD_INT 7
25755: PLUS
25756: PUSH
25757: LD_VAR 0 15
25761: LESS
25762: IFFALSE 25791
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25764: LD_ADDR_VAR 0 18
25768: PUSH
25769: LD_INT 7
25771: PUSH
25772: LD_INT 28
25774: PUSH
25775: LD_INT 45
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: LIST
25782: PUSH
25783: LD_VAR 0 12
25787: ARRAY
25788: ST_TO_ADDR
// break ;
25789: GO 25793
// end ; end ; end ;
25791: GO 25622
25793: POP
25794: POP
// end ; if not weapon then
25795: LD_VAR 0 18
25799: NOT
25800: IFFALSE 25860
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25802: LD_ADDR_VAR 0 5
25806: PUSH
25807: LD_VAR 0 5
25811: PUSH
25812: LD_INT 11
25814: PUSH
25815: LD_INT 30
25817: PUSH
25818: LD_INT 49
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: LIST
25825: DIFF
25826: ST_TO_ADDR
// if not list then
25827: LD_VAR 0 5
25831: NOT
25832: IFFALSE 25836
// exit ;
25834: GO 25978
// weapon := list [ rand ( 1 , list ) ] ;
25836: LD_ADDR_VAR 0 18
25840: PUSH
25841: LD_VAR 0 5
25845: PUSH
25846: LD_INT 1
25848: PPUSH
25849: LD_VAR 0 5
25853: PPUSH
25854: CALL_OW 12
25858: ARRAY
25859: ST_TO_ADDR
// end ; if weapon then
25860: LD_VAR 0 18
25864: IFFALSE 25978
// begin tmp := CostOfWeapon ( weapon ) ;
25866: LD_ADDR_VAR 0 14
25870: PUSH
25871: LD_VAR 0 18
25875: PPUSH
25876: CALL_OW 451
25880: ST_TO_ADDR
// j := GetBase ( tower ) ;
25881: LD_ADDR_VAR 0 9
25885: PUSH
25886: LD_VAR 0 1
25890: PPUSH
25891: CALL_OW 274
25895: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25896: LD_VAR 0 9
25900: PPUSH
25901: LD_INT 1
25903: PPUSH
25904: CALL_OW 275
25908: PUSH
25909: LD_VAR 0 14
25913: PUSH
25914: LD_INT 1
25916: ARRAY
25917: GREATEREQUAL
25918: PUSH
25919: LD_VAR 0 9
25923: PPUSH
25924: LD_INT 2
25926: PPUSH
25927: CALL_OW 275
25931: PUSH
25932: LD_VAR 0 14
25936: PUSH
25937: LD_INT 2
25939: ARRAY
25940: GREATEREQUAL
25941: AND
25942: PUSH
25943: LD_VAR 0 9
25947: PPUSH
25948: LD_INT 3
25950: PPUSH
25951: CALL_OW 275
25955: PUSH
25956: LD_VAR 0 14
25960: PUSH
25961: LD_INT 3
25963: ARRAY
25964: GREATEREQUAL
25965: AND
25966: IFFALSE 25978
// result := weapon ;
25968: LD_ADDR_VAR 0 3
25972: PUSH
25973: LD_VAR 0 18
25977: ST_TO_ADDR
// end ; end ;
25978: LD_VAR 0 3
25982: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25983: LD_INT 0
25985: PPUSH
25986: PPUSH
// result := true ;
25987: LD_ADDR_VAR 0 3
25991: PUSH
25992: LD_INT 1
25994: ST_TO_ADDR
// if array1 = array2 then
25995: LD_VAR 0 1
25999: PUSH
26000: LD_VAR 0 2
26004: EQUAL
26005: IFFALSE 26065
// begin for i = 1 to array1 do
26007: LD_ADDR_VAR 0 4
26011: PUSH
26012: DOUBLE
26013: LD_INT 1
26015: DEC
26016: ST_TO_ADDR
26017: LD_VAR 0 1
26021: PUSH
26022: FOR_TO
26023: IFFALSE 26061
// if array1 [ i ] <> array2 [ i ] then
26025: LD_VAR 0 1
26029: PUSH
26030: LD_VAR 0 4
26034: ARRAY
26035: PUSH
26036: LD_VAR 0 2
26040: PUSH
26041: LD_VAR 0 4
26045: ARRAY
26046: NONEQUAL
26047: IFFALSE 26059
// begin result := false ;
26049: LD_ADDR_VAR 0 3
26053: PUSH
26054: LD_INT 0
26056: ST_TO_ADDR
// break ;
26057: GO 26061
// end ;
26059: GO 26022
26061: POP
26062: POP
// end else
26063: GO 26073
// result := false ;
26065: LD_ADDR_VAR 0 3
26069: PUSH
26070: LD_INT 0
26072: ST_TO_ADDR
// end ;
26073: LD_VAR 0 3
26077: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26078: LD_INT 0
26080: PPUSH
26081: PPUSH
// if not array1 or not array2 then
26082: LD_VAR 0 1
26086: NOT
26087: PUSH
26088: LD_VAR 0 2
26092: NOT
26093: OR
26094: IFFALSE 26098
// exit ;
26096: GO 26162
// result := true ;
26098: LD_ADDR_VAR 0 3
26102: PUSH
26103: LD_INT 1
26105: ST_TO_ADDR
// for i = 1 to array1 do
26106: LD_ADDR_VAR 0 4
26110: PUSH
26111: DOUBLE
26112: LD_INT 1
26114: DEC
26115: ST_TO_ADDR
26116: LD_VAR 0 1
26120: PUSH
26121: FOR_TO
26122: IFFALSE 26160
// if array1 [ i ] <> array2 [ i ] then
26124: LD_VAR 0 1
26128: PUSH
26129: LD_VAR 0 4
26133: ARRAY
26134: PUSH
26135: LD_VAR 0 2
26139: PUSH
26140: LD_VAR 0 4
26144: ARRAY
26145: NONEQUAL
26146: IFFALSE 26158
// begin result := false ;
26148: LD_ADDR_VAR 0 3
26152: PUSH
26153: LD_INT 0
26155: ST_TO_ADDR
// break ;
26156: GO 26160
// end ;
26158: GO 26121
26160: POP
26161: POP
// end ;
26162: LD_VAR 0 3
26166: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26167: LD_INT 0
26169: PPUSH
26170: PPUSH
26171: PPUSH
// pom := GetBase ( fac ) ;
26172: LD_ADDR_VAR 0 5
26176: PUSH
26177: LD_VAR 0 1
26181: PPUSH
26182: CALL_OW 274
26186: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26187: LD_ADDR_VAR 0 4
26191: PUSH
26192: LD_VAR 0 2
26196: PUSH
26197: LD_INT 1
26199: ARRAY
26200: PPUSH
26201: LD_VAR 0 2
26205: PUSH
26206: LD_INT 2
26208: ARRAY
26209: PPUSH
26210: LD_VAR 0 2
26214: PUSH
26215: LD_INT 3
26217: ARRAY
26218: PPUSH
26219: LD_VAR 0 2
26223: PUSH
26224: LD_INT 4
26226: ARRAY
26227: PPUSH
26228: CALL_OW 449
26232: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26233: LD_ADDR_VAR 0 3
26237: PUSH
26238: LD_VAR 0 5
26242: PPUSH
26243: LD_INT 1
26245: PPUSH
26246: CALL_OW 275
26250: PUSH
26251: LD_VAR 0 4
26255: PUSH
26256: LD_INT 1
26258: ARRAY
26259: GREATEREQUAL
26260: PUSH
26261: LD_VAR 0 5
26265: PPUSH
26266: LD_INT 2
26268: PPUSH
26269: CALL_OW 275
26273: PUSH
26274: LD_VAR 0 4
26278: PUSH
26279: LD_INT 2
26281: ARRAY
26282: GREATEREQUAL
26283: AND
26284: PUSH
26285: LD_VAR 0 5
26289: PPUSH
26290: LD_INT 3
26292: PPUSH
26293: CALL_OW 275
26297: PUSH
26298: LD_VAR 0 4
26302: PUSH
26303: LD_INT 3
26305: ARRAY
26306: GREATEREQUAL
26307: AND
26308: ST_TO_ADDR
// end ;
26309: LD_VAR 0 3
26313: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26314: LD_INT 0
26316: PPUSH
26317: PPUSH
26318: PPUSH
26319: PPUSH
// pom := GetBase ( building ) ;
26320: LD_ADDR_VAR 0 3
26324: PUSH
26325: LD_VAR 0 1
26329: PPUSH
26330: CALL_OW 274
26334: ST_TO_ADDR
// if not pom then
26335: LD_VAR 0 3
26339: NOT
26340: IFFALSE 26344
// exit ;
26342: GO 26514
// btype := GetBType ( building ) ;
26344: LD_ADDR_VAR 0 5
26348: PUSH
26349: LD_VAR 0 1
26353: PPUSH
26354: CALL_OW 266
26358: ST_TO_ADDR
// if btype = b_armoury then
26359: LD_VAR 0 5
26363: PUSH
26364: LD_INT 4
26366: EQUAL
26367: IFFALSE 26377
// btype := b_barracks ;
26369: LD_ADDR_VAR 0 5
26373: PUSH
26374: LD_INT 5
26376: ST_TO_ADDR
// if btype = b_depot then
26377: LD_VAR 0 5
26381: PUSH
26382: LD_INT 0
26384: EQUAL
26385: IFFALSE 26395
// btype := b_warehouse ;
26387: LD_ADDR_VAR 0 5
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// if btype = b_workshop then
26395: LD_VAR 0 5
26399: PUSH
26400: LD_INT 2
26402: EQUAL
26403: IFFALSE 26413
// btype := b_factory ;
26405: LD_ADDR_VAR 0 5
26409: PUSH
26410: LD_INT 3
26412: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26413: LD_ADDR_VAR 0 4
26417: PUSH
26418: LD_VAR 0 5
26422: PPUSH
26423: LD_VAR 0 1
26427: PPUSH
26428: CALL_OW 248
26432: PPUSH
26433: CALL_OW 450
26437: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26438: LD_ADDR_VAR 0 2
26442: PUSH
26443: LD_VAR 0 3
26447: PPUSH
26448: LD_INT 1
26450: PPUSH
26451: CALL_OW 275
26455: PUSH
26456: LD_VAR 0 4
26460: PUSH
26461: LD_INT 1
26463: ARRAY
26464: GREATEREQUAL
26465: PUSH
26466: LD_VAR 0 3
26470: PPUSH
26471: LD_INT 2
26473: PPUSH
26474: CALL_OW 275
26478: PUSH
26479: LD_VAR 0 4
26483: PUSH
26484: LD_INT 2
26486: ARRAY
26487: GREATEREQUAL
26488: AND
26489: PUSH
26490: LD_VAR 0 3
26494: PPUSH
26495: LD_INT 3
26497: PPUSH
26498: CALL_OW 275
26502: PUSH
26503: LD_VAR 0 4
26507: PUSH
26508: LD_INT 3
26510: ARRAY
26511: GREATEREQUAL
26512: AND
26513: ST_TO_ADDR
// end ;
26514: LD_VAR 0 2
26518: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26519: LD_INT 0
26521: PPUSH
26522: PPUSH
26523: PPUSH
// pom := GetBase ( building ) ;
26524: LD_ADDR_VAR 0 4
26528: PUSH
26529: LD_VAR 0 1
26533: PPUSH
26534: CALL_OW 274
26538: ST_TO_ADDR
// if not pom then
26539: LD_VAR 0 4
26543: NOT
26544: IFFALSE 26548
// exit ;
26546: GO 26649
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26548: LD_ADDR_VAR 0 5
26552: PUSH
26553: LD_VAR 0 2
26557: PPUSH
26558: LD_VAR 0 1
26562: PPUSH
26563: CALL_OW 248
26567: PPUSH
26568: CALL_OW 450
26572: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26573: LD_ADDR_VAR 0 3
26577: PUSH
26578: LD_VAR 0 4
26582: PPUSH
26583: LD_INT 1
26585: PPUSH
26586: CALL_OW 275
26590: PUSH
26591: LD_VAR 0 5
26595: PUSH
26596: LD_INT 1
26598: ARRAY
26599: GREATEREQUAL
26600: PUSH
26601: LD_VAR 0 4
26605: PPUSH
26606: LD_INT 2
26608: PPUSH
26609: CALL_OW 275
26613: PUSH
26614: LD_VAR 0 5
26618: PUSH
26619: LD_INT 2
26621: ARRAY
26622: GREATEREQUAL
26623: AND
26624: PUSH
26625: LD_VAR 0 4
26629: PPUSH
26630: LD_INT 3
26632: PPUSH
26633: CALL_OW 275
26637: PUSH
26638: LD_VAR 0 5
26642: PUSH
26643: LD_INT 3
26645: ARRAY
26646: GREATEREQUAL
26647: AND
26648: ST_TO_ADDR
// end ;
26649: LD_VAR 0 3
26653: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26654: LD_INT 0
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
26665: PPUSH
26666: PPUSH
// result := false ;
26667: LD_ADDR_VAR 0 8
26671: PUSH
26672: LD_INT 0
26674: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26675: LD_VAR 0 5
26679: NOT
26680: PUSH
26681: LD_VAR 0 1
26685: NOT
26686: OR
26687: PUSH
26688: LD_VAR 0 2
26692: NOT
26693: OR
26694: PUSH
26695: LD_VAR 0 3
26699: NOT
26700: OR
26701: IFFALSE 26705
// exit ;
26703: GO 27519
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26705: LD_ADDR_VAR 0 14
26709: PUSH
26710: LD_VAR 0 1
26714: PPUSH
26715: LD_VAR 0 2
26719: PPUSH
26720: LD_VAR 0 3
26724: PPUSH
26725: LD_VAR 0 4
26729: PPUSH
26730: LD_VAR 0 5
26734: PUSH
26735: LD_INT 1
26737: ARRAY
26738: PPUSH
26739: CALL_OW 248
26743: PPUSH
26744: LD_INT 0
26746: PPUSH
26747: CALL 28756 0 6
26751: ST_TO_ADDR
// if not hexes then
26752: LD_VAR 0 14
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 27519
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26761: LD_ADDR_VAR 0 17
26765: PUSH
26766: LD_VAR 0 5
26770: PPUSH
26771: LD_INT 22
26773: PUSH
26774: LD_VAR 0 13
26778: PPUSH
26779: CALL_OW 255
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 2
26790: PUSH
26791: LD_INT 30
26793: PUSH
26794: LD_INT 0
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 30
26803: PUSH
26804: LD_INT 1
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: LIST
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PPUSH
26820: CALL_OW 72
26824: ST_TO_ADDR
// for i = 1 to hexes do
26825: LD_ADDR_VAR 0 9
26829: PUSH
26830: DOUBLE
26831: LD_INT 1
26833: DEC
26834: ST_TO_ADDR
26835: LD_VAR 0 14
26839: PUSH
26840: FOR_TO
26841: IFFALSE 27517
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26843: LD_ADDR_VAR 0 13
26847: PUSH
26848: LD_VAR 0 14
26852: PUSH
26853: LD_VAR 0 9
26857: ARRAY
26858: PUSH
26859: LD_INT 1
26861: ARRAY
26862: PPUSH
26863: LD_VAR 0 14
26867: PUSH
26868: LD_VAR 0 9
26872: ARRAY
26873: PUSH
26874: LD_INT 2
26876: ARRAY
26877: PPUSH
26878: CALL_OW 428
26882: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26883: LD_VAR 0 14
26887: PUSH
26888: LD_VAR 0 9
26892: ARRAY
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: PPUSH
26898: LD_VAR 0 14
26902: PUSH
26903: LD_VAR 0 9
26907: ARRAY
26908: PUSH
26909: LD_INT 2
26911: ARRAY
26912: PPUSH
26913: CALL_OW 351
26917: PUSH
26918: LD_VAR 0 14
26922: PUSH
26923: LD_VAR 0 9
26927: ARRAY
26928: PUSH
26929: LD_INT 1
26931: ARRAY
26932: PPUSH
26933: LD_VAR 0 14
26937: PUSH
26938: LD_VAR 0 9
26942: ARRAY
26943: PUSH
26944: LD_INT 2
26946: ARRAY
26947: PPUSH
26948: CALL_OW 488
26952: NOT
26953: OR
26954: PUSH
26955: LD_VAR 0 13
26959: PPUSH
26960: CALL_OW 247
26964: PUSH
26965: LD_INT 3
26967: EQUAL
26968: OR
26969: IFFALSE 26975
// exit ;
26971: POP
26972: POP
26973: GO 27519
// if not tmp then
26975: LD_VAR 0 13
26979: NOT
26980: IFFALSE 26984
// continue ;
26982: GO 26840
// result := true ;
26984: LD_ADDR_VAR 0 8
26988: PUSH
26989: LD_INT 1
26991: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26992: LD_VAR 0 6
26996: PUSH
26997: LD_VAR 0 13
27001: PPUSH
27002: CALL_OW 247
27006: PUSH
27007: LD_INT 2
27009: EQUAL
27010: AND
27011: PUSH
27012: LD_VAR 0 13
27016: PPUSH
27017: CALL_OW 263
27021: PUSH
27022: LD_INT 1
27024: EQUAL
27025: AND
27026: IFFALSE 27190
// begin if IsDrivenBy ( tmp ) then
27028: LD_VAR 0 13
27032: PPUSH
27033: CALL_OW 311
27037: IFFALSE 27041
// continue ;
27039: GO 26840
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27041: LD_VAR 0 6
27045: PPUSH
27046: LD_INT 3
27048: PUSH
27049: LD_INT 60
27051: PUSH
27052: EMPTY
27053: LIST
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 3
27061: PUSH
27062: LD_INT 55
27064: PUSH
27065: EMPTY
27066: LIST
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PPUSH
27076: CALL_OW 72
27080: IFFALSE 27188
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27082: LD_ADDR_VAR 0 18
27086: PUSH
27087: LD_VAR 0 6
27091: PPUSH
27092: LD_INT 3
27094: PUSH
27095: LD_INT 60
27097: PUSH
27098: EMPTY
27099: LIST
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 3
27107: PUSH
27108: LD_INT 55
27110: PUSH
27111: EMPTY
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PPUSH
27122: CALL_OW 72
27126: PUSH
27127: LD_INT 1
27129: ARRAY
27130: ST_TO_ADDR
// if IsInUnit ( driver ) then
27131: LD_VAR 0 18
27135: PPUSH
27136: CALL_OW 310
27140: IFFALSE 27151
// ComExit ( driver ) ;
27142: LD_VAR 0 18
27146: PPUSH
27147: CALL 51940 0 1
// AddComEnterUnit ( driver , tmp ) ;
27151: LD_VAR 0 18
27155: PPUSH
27156: LD_VAR 0 13
27160: PPUSH
27161: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27165: LD_VAR 0 18
27169: PPUSH
27170: LD_VAR 0 7
27174: PPUSH
27175: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27179: LD_VAR 0 18
27183: PPUSH
27184: CALL_OW 181
// end ; continue ;
27188: GO 26840
// end ; if not cleaners or not tmp in cleaners then
27190: LD_VAR 0 6
27194: NOT
27195: PUSH
27196: LD_VAR 0 13
27200: PUSH
27201: LD_VAR 0 6
27205: IN
27206: NOT
27207: OR
27208: IFFALSE 27515
// begin if dep then
27210: LD_VAR 0 17
27214: IFFALSE 27350
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27216: LD_ADDR_VAR 0 16
27220: PUSH
27221: LD_VAR 0 17
27225: PUSH
27226: LD_INT 1
27228: ARRAY
27229: PPUSH
27230: CALL_OW 250
27234: PPUSH
27235: LD_VAR 0 17
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: PPUSH
27244: CALL_OW 254
27248: PPUSH
27249: LD_INT 5
27251: PPUSH
27252: CALL_OW 272
27256: PUSH
27257: LD_VAR 0 17
27261: PUSH
27262: LD_INT 1
27264: ARRAY
27265: PPUSH
27266: CALL_OW 251
27270: PPUSH
27271: LD_VAR 0 17
27275: PUSH
27276: LD_INT 1
27278: ARRAY
27279: PPUSH
27280: CALL_OW 254
27284: PPUSH
27285: LD_INT 5
27287: PPUSH
27288: CALL_OW 273
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27297: LD_VAR 0 16
27301: PUSH
27302: LD_INT 1
27304: ARRAY
27305: PPUSH
27306: LD_VAR 0 16
27310: PUSH
27311: LD_INT 2
27313: ARRAY
27314: PPUSH
27315: CALL_OW 488
27319: IFFALSE 27350
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27321: LD_VAR 0 13
27325: PPUSH
27326: LD_VAR 0 16
27330: PUSH
27331: LD_INT 1
27333: ARRAY
27334: PPUSH
27335: LD_VAR 0 16
27339: PUSH
27340: LD_INT 2
27342: ARRAY
27343: PPUSH
27344: CALL_OW 111
// continue ;
27348: GO 26840
// end ; end ; r := GetDir ( tmp ) ;
27350: LD_ADDR_VAR 0 15
27354: PUSH
27355: LD_VAR 0 13
27359: PPUSH
27360: CALL_OW 254
27364: ST_TO_ADDR
// if r = 5 then
27365: LD_VAR 0 15
27369: PUSH
27370: LD_INT 5
27372: EQUAL
27373: IFFALSE 27383
// r := 0 ;
27375: LD_ADDR_VAR 0 15
27379: PUSH
27380: LD_INT 0
27382: ST_TO_ADDR
// for j = r to 5 do
27383: LD_ADDR_VAR 0 10
27387: PUSH
27388: DOUBLE
27389: LD_VAR 0 15
27393: DEC
27394: ST_TO_ADDR
27395: LD_INT 5
27397: PUSH
27398: FOR_TO
27399: IFFALSE 27513
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27401: LD_ADDR_VAR 0 11
27405: PUSH
27406: LD_VAR 0 13
27410: PPUSH
27411: CALL_OW 250
27415: PPUSH
27416: LD_VAR 0 10
27420: PPUSH
27421: LD_INT 2
27423: PPUSH
27424: CALL_OW 272
27428: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27429: LD_ADDR_VAR 0 12
27433: PUSH
27434: LD_VAR 0 13
27438: PPUSH
27439: CALL_OW 251
27443: PPUSH
27444: LD_VAR 0 10
27448: PPUSH
27449: LD_INT 2
27451: PPUSH
27452: CALL_OW 273
27456: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27457: LD_VAR 0 11
27461: PPUSH
27462: LD_VAR 0 12
27466: PPUSH
27467: CALL_OW 488
27471: PUSH
27472: LD_VAR 0 11
27476: PPUSH
27477: LD_VAR 0 12
27481: PPUSH
27482: CALL_OW 428
27486: NOT
27487: AND
27488: IFFALSE 27511
// begin ComMoveXY ( tmp , _x , _y ) ;
27490: LD_VAR 0 13
27494: PPUSH
27495: LD_VAR 0 11
27499: PPUSH
27500: LD_VAR 0 12
27504: PPUSH
27505: CALL_OW 111
// break ;
27509: GO 27513
// end ; end ;
27511: GO 27398
27513: POP
27514: POP
// end ; end ;
27515: GO 26840
27517: POP
27518: POP
// end ;
27519: LD_VAR 0 8
27523: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27524: LD_INT 0
27526: PPUSH
// result := true ;
27527: LD_ADDR_VAR 0 3
27531: PUSH
27532: LD_INT 1
27534: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27535: LD_VAR 0 2
27539: PUSH
27540: LD_INT 24
27542: DOUBLE
27543: EQUAL
27544: IFTRUE 27554
27546: LD_INT 33
27548: DOUBLE
27549: EQUAL
27550: IFTRUE 27554
27552: GO 27579
27554: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27555: LD_ADDR_VAR 0 3
27559: PUSH
27560: LD_INT 32
27562: PPUSH
27563: LD_VAR 0 1
27567: PPUSH
27568: CALL_OW 321
27572: PUSH
27573: LD_INT 2
27575: EQUAL
27576: ST_TO_ADDR
27577: GO 27899
27579: LD_INT 20
27581: DOUBLE
27582: EQUAL
27583: IFTRUE 27587
27585: GO 27612
27587: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27588: LD_ADDR_VAR 0 3
27592: PUSH
27593: LD_INT 6
27595: PPUSH
27596: LD_VAR 0 1
27600: PPUSH
27601: CALL_OW 321
27605: PUSH
27606: LD_INT 2
27608: EQUAL
27609: ST_TO_ADDR
27610: GO 27899
27612: LD_INT 22
27614: DOUBLE
27615: EQUAL
27616: IFTRUE 27626
27618: LD_INT 36
27620: DOUBLE
27621: EQUAL
27622: IFTRUE 27626
27624: GO 27651
27626: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27627: LD_ADDR_VAR 0 3
27631: PUSH
27632: LD_INT 15
27634: PPUSH
27635: LD_VAR 0 1
27639: PPUSH
27640: CALL_OW 321
27644: PUSH
27645: LD_INT 2
27647: EQUAL
27648: ST_TO_ADDR
27649: GO 27899
27651: LD_INT 30
27653: DOUBLE
27654: EQUAL
27655: IFTRUE 27659
27657: GO 27684
27659: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27660: LD_ADDR_VAR 0 3
27664: PUSH
27665: LD_INT 20
27667: PPUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 321
27677: PUSH
27678: LD_INT 2
27680: EQUAL
27681: ST_TO_ADDR
27682: GO 27899
27684: LD_INT 28
27686: DOUBLE
27687: EQUAL
27688: IFTRUE 27698
27690: LD_INT 21
27692: DOUBLE
27693: EQUAL
27694: IFTRUE 27698
27696: GO 27723
27698: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27699: LD_ADDR_VAR 0 3
27703: PUSH
27704: LD_INT 21
27706: PPUSH
27707: LD_VAR 0 1
27711: PPUSH
27712: CALL_OW 321
27716: PUSH
27717: LD_INT 2
27719: EQUAL
27720: ST_TO_ADDR
27721: GO 27899
27723: LD_INT 16
27725: DOUBLE
27726: EQUAL
27727: IFTRUE 27731
27729: GO 27758
27731: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27732: LD_ADDR_VAR 0 3
27736: PUSH
27737: LD_EXP 116
27741: PPUSH
27742: LD_VAR 0 1
27746: PPUSH
27747: CALL_OW 321
27751: PUSH
27752: LD_INT 2
27754: EQUAL
27755: ST_TO_ADDR
27756: GO 27899
27758: LD_INT 19
27760: DOUBLE
27761: EQUAL
27762: IFTRUE 27772
27764: LD_INT 23
27766: DOUBLE
27767: EQUAL
27768: IFTRUE 27772
27770: GO 27799
27772: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27773: LD_ADDR_VAR 0 3
27777: PUSH
27778: LD_EXP 115
27782: PPUSH
27783: LD_VAR 0 1
27787: PPUSH
27788: CALL_OW 321
27792: PUSH
27793: LD_INT 2
27795: EQUAL
27796: ST_TO_ADDR
27797: GO 27899
27799: LD_INT 17
27801: DOUBLE
27802: EQUAL
27803: IFTRUE 27807
27805: GO 27832
27807: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27808: LD_ADDR_VAR 0 3
27812: PUSH
27813: LD_INT 39
27815: PPUSH
27816: LD_VAR 0 1
27820: PPUSH
27821: CALL_OW 321
27825: PUSH
27826: LD_INT 2
27828: EQUAL
27829: ST_TO_ADDR
27830: GO 27899
27832: LD_INT 18
27834: DOUBLE
27835: EQUAL
27836: IFTRUE 27840
27838: GO 27865
27840: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27841: LD_ADDR_VAR 0 3
27845: PUSH
27846: LD_INT 40
27848: PPUSH
27849: LD_VAR 0 1
27853: PPUSH
27854: CALL_OW 321
27858: PUSH
27859: LD_INT 2
27861: EQUAL
27862: ST_TO_ADDR
27863: GO 27899
27865: LD_INT 27
27867: DOUBLE
27868: EQUAL
27869: IFTRUE 27873
27871: GO 27898
27873: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27874: LD_ADDR_VAR 0 3
27878: PUSH
27879: LD_INT 35
27881: PPUSH
27882: LD_VAR 0 1
27886: PPUSH
27887: CALL_OW 321
27891: PUSH
27892: LD_INT 2
27894: EQUAL
27895: ST_TO_ADDR
27896: GO 27899
27898: POP
// end ;
27899: LD_VAR 0 3
27903: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27904: LD_INT 0
27906: PPUSH
27907: PPUSH
27908: PPUSH
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
27914: PPUSH
27915: PPUSH
27916: PPUSH
// result := false ;
27917: LD_ADDR_VAR 0 6
27921: PUSH
27922: LD_INT 0
27924: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27925: LD_VAR 0 1
27929: NOT
27930: PUSH
27931: LD_VAR 0 1
27935: PPUSH
27936: CALL_OW 266
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: LD_INT 1
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: IN
27951: NOT
27952: OR
27953: PUSH
27954: LD_VAR 0 2
27958: NOT
27959: OR
27960: PUSH
27961: LD_VAR 0 5
27965: PUSH
27966: LD_INT 0
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 2
27974: PUSH
27975: LD_INT 3
27977: PUSH
27978: LD_INT 4
27980: PUSH
27981: LD_INT 5
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: IN
27992: NOT
27993: OR
27994: PUSH
27995: LD_VAR 0 3
27999: PPUSH
28000: LD_VAR 0 4
28004: PPUSH
28005: CALL_OW 488
28009: NOT
28010: OR
28011: IFFALSE 28015
// exit ;
28013: GO 28751
// side := GetSide ( depot ) ;
28015: LD_ADDR_VAR 0 9
28019: PUSH
28020: LD_VAR 0 1
28024: PPUSH
28025: CALL_OW 255
28029: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28030: LD_VAR 0 9
28034: PPUSH
28035: LD_VAR 0 2
28039: PPUSH
28040: CALL 27524 0 2
28044: NOT
28045: IFFALSE 28049
// exit ;
28047: GO 28751
// pom := GetBase ( depot ) ;
28049: LD_ADDR_VAR 0 10
28053: PUSH
28054: LD_VAR 0 1
28058: PPUSH
28059: CALL_OW 274
28063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28064: LD_ADDR_VAR 0 11
28068: PUSH
28069: LD_VAR 0 2
28073: PPUSH
28074: LD_VAR 0 1
28078: PPUSH
28079: CALL_OW 248
28083: PPUSH
28084: CALL_OW 450
28088: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28089: LD_VAR 0 10
28093: PPUSH
28094: LD_INT 1
28096: PPUSH
28097: CALL_OW 275
28101: PUSH
28102: LD_VAR 0 11
28106: PUSH
28107: LD_INT 1
28109: ARRAY
28110: GREATEREQUAL
28111: PUSH
28112: LD_VAR 0 10
28116: PPUSH
28117: LD_INT 2
28119: PPUSH
28120: CALL_OW 275
28124: PUSH
28125: LD_VAR 0 11
28129: PUSH
28130: LD_INT 2
28132: ARRAY
28133: GREATEREQUAL
28134: AND
28135: PUSH
28136: LD_VAR 0 10
28140: PPUSH
28141: LD_INT 3
28143: PPUSH
28144: CALL_OW 275
28148: PUSH
28149: LD_VAR 0 11
28153: PUSH
28154: LD_INT 3
28156: ARRAY
28157: GREATEREQUAL
28158: AND
28159: NOT
28160: IFFALSE 28164
// exit ;
28162: GO 28751
// if GetBType ( depot ) = b_depot then
28164: LD_VAR 0 1
28168: PPUSH
28169: CALL_OW 266
28173: PUSH
28174: LD_INT 0
28176: EQUAL
28177: IFFALSE 28189
// dist := 28 else
28179: LD_ADDR_VAR 0 14
28183: PUSH
28184: LD_INT 28
28186: ST_TO_ADDR
28187: GO 28197
// dist := 36 ;
28189: LD_ADDR_VAR 0 14
28193: PUSH
28194: LD_INT 36
28196: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28197: LD_VAR 0 1
28201: PPUSH
28202: LD_VAR 0 3
28206: PPUSH
28207: LD_VAR 0 4
28211: PPUSH
28212: CALL_OW 297
28216: PUSH
28217: LD_VAR 0 14
28221: GREATER
28222: IFFALSE 28226
// exit ;
28224: GO 28751
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28226: LD_ADDR_VAR 0 12
28230: PUSH
28231: LD_VAR 0 2
28235: PPUSH
28236: LD_VAR 0 3
28240: PPUSH
28241: LD_VAR 0 4
28245: PPUSH
28246: LD_VAR 0 5
28250: PPUSH
28251: LD_VAR 0 1
28255: PPUSH
28256: CALL_OW 248
28260: PPUSH
28261: LD_INT 0
28263: PPUSH
28264: CALL 28756 0 6
28268: ST_TO_ADDR
// if not hexes then
28269: LD_VAR 0 12
28273: NOT
28274: IFFALSE 28278
// exit ;
28276: GO 28751
// hex := GetHexInfo ( x , y ) ;
28278: LD_ADDR_VAR 0 15
28282: PUSH
28283: LD_VAR 0 3
28287: PPUSH
28288: LD_VAR 0 4
28292: PPUSH
28293: CALL_OW 546
28297: ST_TO_ADDR
// if hex [ 1 ] then
28298: LD_VAR 0 15
28302: PUSH
28303: LD_INT 1
28305: ARRAY
28306: IFFALSE 28310
// exit ;
28308: GO 28751
// height := hex [ 2 ] ;
28310: LD_ADDR_VAR 0 13
28314: PUSH
28315: LD_VAR 0 15
28319: PUSH
28320: LD_INT 2
28322: ARRAY
28323: ST_TO_ADDR
// for i = 1 to hexes do
28324: LD_ADDR_VAR 0 7
28328: PUSH
28329: DOUBLE
28330: LD_INT 1
28332: DEC
28333: ST_TO_ADDR
28334: LD_VAR 0 12
28338: PUSH
28339: FOR_TO
28340: IFFALSE 28670
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28342: LD_VAR 0 12
28346: PUSH
28347: LD_VAR 0 7
28351: ARRAY
28352: PUSH
28353: LD_INT 1
28355: ARRAY
28356: PPUSH
28357: LD_VAR 0 12
28361: PUSH
28362: LD_VAR 0 7
28366: ARRAY
28367: PUSH
28368: LD_INT 2
28370: ARRAY
28371: PPUSH
28372: CALL_OW 488
28376: NOT
28377: PUSH
28378: LD_VAR 0 12
28382: PUSH
28383: LD_VAR 0 7
28387: ARRAY
28388: PUSH
28389: LD_INT 1
28391: ARRAY
28392: PPUSH
28393: LD_VAR 0 12
28397: PUSH
28398: LD_VAR 0 7
28402: ARRAY
28403: PUSH
28404: LD_INT 2
28406: ARRAY
28407: PPUSH
28408: CALL_OW 428
28412: PUSH
28413: LD_INT 0
28415: GREATER
28416: OR
28417: PUSH
28418: LD_VAR 0 12
28422: PUSH
28423: LD_VAR 0 7
28427: ARRAY
28428: PUSH
28429: LD_INT 1
28431: ARRAY
28432: PPUSH
28433: LD_VAR 0 12
28437: PUSH
28438: LD_VAR 0 7
28442: ARRAY
28443: PUSH
28444: LD_INT 2
28446: ARRAY
28447: PPUSH
28448: CALL_OW 351
28452: OR
28453: IFFALSE 28459
// exit ;
28455: POP
28456: POP
28457: GO 28751
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28459: LD_ADDR_VAR 0 8
28463: PUSH
28464: LD_VAR 0 12
28468: PUSH
28469: LD_VAR 0 7
28473: ARRAY
28474: PUSH
28475: LD_INT 1
28477: ARRAY
28478: PPUSH
28479: LD_VAR 0 12
28483: PUSH
28484: LD_VAR 0 7
28488: ARRAY
28489: PUSH
28490: LD_INT 2
28492: ARRAY
28493: PPUSH
28494: CALL_OW 546
28498: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28499: LD_VAR 0 8
28503: PUSH
28504: LD_INT 1
28506: ARRAY
28507: PUSH
28508: LD_VAR 0 8
28512: PUSH
28513: LD_INT 2
28515: ARRAY
28516: PUSH
28517: LD_VAR 0 13
28521: PUSH
28522: LD_INT 2
28524: PLUS
28525: GREATER
28526: OR
28527: PUSH
28528: LD_VAR 0 8
28532: PUSH
28533: LD_INT 2
28535: ARRAY
28536: PUSH
28537: LD_VAR 0 13
28541: PUSH
28542: LD_INT 2
28544: MINUS
28545: LESS
28546: OR
28547: PUSH
28548: LD_VAR 0 8
28552: PUSH
28553: LD_INT 3
28555: ARRAY
28556: PUSH
28557: LD_INT 0
28559: PUSH
28560: LD_INT 8
28562: PUSH
28563: LD_INT 9
28565: PUSH
28566: LD_INT 10
28568: PUSH
28569: LD_INT 11
28571: PUSH
28572: LD_INT 12
28574: PUSH
28575: LD_INT 13
28577: PUSH
28578: LD_INT 16
28580: PUSH
28581: LD_INT 17
28583: PUSH
28584: LD_INT 18
28586: PUSH
28587: LD_INT 19
28589: PUSH
28590: LD_INT 20
28592: PUSH
28593: LD_INT 21
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: IN
28611: NOT
28612: OR
28613: PUSH
28614: LD_VAR 0 8
28618: PUSH
28619: LD_INT 5
28621: ARRAY
28622: NOT
28623: OR
28624: PUSH
28625: LD_VAR 0 8
28629: PUSH
28630: LD_INT 6
28632: ARRAY
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: LD_INT 7
28642: PUSH
28643: LD_INT 9
28645: PUSH
28646: LD_INT 10
28648: PUSH
28649: LD_INT 11
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: IN
28660: NOT
28661: OR
28662: IFFALSE 28668
// exit ;
28664: POP
28665: POP
28666: GO 28751
// end ;
28668: GO 28339
28670: POP
28671: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28672: LD_VAR 0 9
28676: PPUSH
28677: LD_VAR 0 3
28681: PPUSH
28682: LD_VAR 0 4
28686: PPUSH
28687: LD_INT 20
28689: PPUSH
28690: CALL 20697 0 4
28694: PUSH
28695: LD_INT 4
28697: ARRAY
28698: IFFALSE 28702
// exit ;
28700: GO 28751
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28702: LD_VAR 0 2
28706: PUSH
28707: LD_INT 29
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: IN
28717: PUSH
28718: LD_VAR 0 3
28722: PPUSH
28723: LD_VAR 0 4
28727: PPUSH
28728: LD_VAR 0 9
28732: PPUSH
28733: CALL_OW 440
28737: NOT
28738: AND
28739: IFFALSE 28743
// exit ;
28741: GO 28751
// result := true ;
28743: LD_ADDR_VAR 0 6
28747: PUSH
28748: LD_INT 1
28750: ST_TO_ADDR
// end ;
28751: LD_VAR 0 6
28755: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28756: LD_INT 0
28758: PPUSH
28759: PPUSH
28760: PPUSH
28761: PPUSH
28762: PPUSH
28763: PPUSH
28764: PPUSH
28765: PPUSH
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
28770: PPUSH
28771: PPUSH
28772: PPUSH
28773: PPUSH
28774: PPUSH
28775: PPUSH
28776: PPUSH
28777: PPUSH
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
28793: PPUSH
28794: PPUSH
28795: PPUSH
28796: PPUSH
28797: PPUSH
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
28805: PPUSH
28806: PPUSH
28807: PPUSH
28808: PPUSH
28809: PPUSH
28810: PPUSH
28811: PPUSH
28812: PPUSH
28813: PPUSH
28814: PPUSH
28815: PPUSH
// result = [ ] ;
28816: LD_ADDR_VAR 0 7
28820: PUSH
28821: EMPTY
28822: ST_TO_ADDR
// temp_list = [ ] ;
28823: LD_ADDR_VAR 0 9
28827: PUSH
28828: EMPTY
28829: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28830: LD_VAR 0 4
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: LD_INT 1
28840: PUSH
28841: LD_INT 2
28843: PUSH
28844: LD_INT 3
28846: PUSH
28847: LD_INT 4
28849: PUSH
28850: LD_INT 5
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: IN
28861: NOT
28862: PUSH
28863: LD_VAR 0 1
28867: PUSH
28868: LD_INT 0
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: IN
28878: PUSH
28879: LD_VAR 0 5
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 2
28889: PUSH
28890: LD_INT 3
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: LIST
28897: IN
28898: NOT
28899: AND
28900: OR
28901: IFFALSE 28905
// exit ;
28903: GO 47296
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28905: LD_VAR 0 1
28909: PUSH
28910: LD_INT 6
28912: PUSH
28913: LD_INT 7
28915: PUSH
28916: LD_INT 8
28918: PUSH
28919: LD_INT 13
28921: PUSH
28922: LD_INT 12
28924: PUSH
28925: LD_INT 15
28927: PUSH
28928: LD_INT 11
28930: PUSH
28931: LD_INT 14
28933: PUSH
28934: LD_INT 10
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: IN
28948: IFFALSE 28958
// btype = b_lab ;
28950: LD_ADDR_VAR 0 1
28954: PUSH
28955: LD_INT 6
28957: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28958: LD_VAR 0 6
28962: PUSH
28963: LD_INT 0
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: LD_INT 2
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: LIST
28976: IN
28977: NOT
28978: PUSH
28979: LD_VAR 0 1
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: LD_INT 1
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 3
28995: PUSH
28996: LD_INT 6
28998: PUSH
28999: LD_INT 36
29001: PUSH
29002: LD_INT 4
29004: PUSH
29005: LD_INT 5
29007: PUSH
29008: LD_INT 31
29010: PUSH
29011: LD_INT 32
29013: PUSH
29014: LD_INT 33
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: IN
29030: NOT
29031: PUSH
29032: LD_VAR 0 6
29036: PUSH
29037: LD_INT 1
29039: EQUAL
29040: AND
29041: OR
29042: PUSH
29043: LD_VAR 0 1
29047: PUSH
29048: LD_INT 2
29050: PUSH
29051: LD_INT 3
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: IN
29058: NOT
29059: PUSH
29060: LD_VAR 0 6
29064: PUSH
29065: LD_INT 2
29067: EQUAL
29068: AND
29069: OR
29070: IFFALSE 29080
// mode = 0 ;
29072: LD_ADDR_VAR 0 6
29076: PUSH
29077: LD_INT 0
29079: ST_TO_ADDR
// case mode of 0 :
29080: LD_VAR 0 6
29084: PUSH
29085: LD_INT 0
29087: DOUBLE
29088: EQUAL
29089: IFTRUE 29093
29091: GO 40546
29093: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29094: LD_ADDR_VAR 0 11
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 1
29152: NEG
29153: PUSH
29154: LD_INT 0
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: LD_INT 1
29167: NEG
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 1
29175: NEG
29176: PUSH
29177: LD_INT 2
29179: NEG
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 0
29187: PUSH
29188: LD_INT 2
29190: NEG
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: LD_INT 1
29209: PUSH
29210: LD_INT 2
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: LD_INT 0
29219: PUSH
29220: LD_INT 2
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 1
29229: NEG
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 3
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 3
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 2
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29287: LD_ADDR_VAR 0 12
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: LD_INT 0
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 0
29304: PUSH
29305: LD_INT 1
29307: NEG
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: PUSH
29316: LD_INT 0
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 1
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: LD_INT 0
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 1
29356: NEG
29357: PUSH
29358: LD_INT 1
29360: NEG
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 1
29371: NEG
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 2
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 2
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 0
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 2
29433: NEG
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 3
29444: NEG
29445: PUSH
29446: LD_INT 0
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 3
29455: NEG
29456: PUSH
29457: LD_INT 1
29459: NEG
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29483: LD_ADDR_VAR 0 13
29487: PUSH
29488: LD_INT 0
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 0
29500: PUSH
29501: LD_INT 1
29503: NEG
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 0
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: LD_INT 0
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: LD_INT 1
29564: NEG
29565: PUSH
29566: LD_INT 2
29568: NEG
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 2
29576: PUSH
29577: LD_INT 1
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 2
29586: PUSH
29587: LD_INT 2
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 1
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 2
29606: NEG
29607: PUSH
29608: LD_INT 1
29610: NEG
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 2
29618: NEG
29619: PUSH
29620: LD_INT 2
29622: NEG
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: LD_INT 3
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 3
29642: NEG
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 3
29654: NEG
29655: PUSH
29656: LD_INT 3
29658: NEG
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29682: LD_ADDR_VAR 0 14
29686: PUSH
29687: LD_INT 0
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 1
29710: PUSH
29711: LD_INT 0
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 1
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 0
29730: PUSH
29731: LD_INT 1
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: LD_INT 0
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 1
29751: NEG
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 1
29763: NEG
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: LD_INT 2
29778: NEG
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: LD_INT 2
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 0
29807: PUSH
29808: LD_INT 2
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: NEG
29829: PUSH
29830: LD_INT 3
29832: NEG
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 0
29840: PUSH
29841: LD_INT 3
29843: NEG
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 1
29851: PUSH
29852: LD_INT 2
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29878: LD_ADDR_VAR 0 15
29882: PUSH
29883: LD_INT 0
29885: PUSH
29886: LD_INT 0
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 0
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: LD_INT 0
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 1
29916: PUSH
29917: LD_INT 1
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 0
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: LD_INT 0
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 1
29947: NEG
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 2
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: NEG
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 2
30001: NEG
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: NEG
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 2
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: LIST
30062: LIST
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30071: LD_ADDR_VAR 0 16
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 0
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: LD_INT 0
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: LD_INT 1
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 0
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: LD_INT 0
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 1
30140: NEG
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: LD_INT 2
30156: NEG
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: LD_INT 2
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: LD_INT 2
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 2
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 3
30218: PUSH
30219: LD_INT 2
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 3
30228: PUSH
30229: LD_INT 3
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 2
30238: PUSH
30239: LD_INT 3
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30264: LD_ADDR_VAR 0 17
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: LD_INT 0
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PUSH
30279: LD_INT 0
30281: PUSH
30282: LD_INT 1
30284: NEG
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: PUSH
30293: LD_INT 0
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 0
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: NEG
30323: PUSH
30324: LD_INT 0
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 1
30333: NEG
30334: PUSH
30335: LD_INT 1
30337: NEG
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 1
30345: NEG
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: LD_INT 2
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 1
30371: NEG
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 2
30379: PUSH
30380: LD_INT 0
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 2
30389: PUSH
30390: LD_INT 1
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 2
30399: PUSH
30400: LD_INT 2
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: PUSH
30410: LD_INT 2
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: LD_INT 2
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: LD_INT 0
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: NEG
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30494: LD_ADDR_VAR 0 18
30498: PUSH
30499: LD_INT 0
30501: PUSH
30502: LD_INT 0
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 0
30511: PUSH
30512: LD_INT 1
30514: NEG
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PUSH
30520: LD_INT 1
30522: PUSH
30523: LD_INT 0
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: LD_INT 1
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 0
30542: PUSH
30543: LD_INT 1
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 1
30552: NEG
30553: PUSH
30554: LD_INT 0
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 1
30563: NEG
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 1
30575: NEG
30576: PUSH
30577: LD_INT 2
30579: NEG
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 2
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 1
30598: PUSH
30599: LD_INT 1
30601: NEG
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 2
30609: PUSH
30610: LD_INT 0
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 2
30629: PUSH
30630: LD_INT 2
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 1
30659: NEG
30660: PUSH
30661: LD_INT 1
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: LD_INT 0
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 2
30681: NEG
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 2
30693: NEG
30694: PUSH
30695: LD_INT 2
30697: NEG
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30724: LD_ADDR_VAR 0 19
30728: PUSH
30729: LD_INT 0
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 0
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: LD_INT 0
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 0
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 0
30817: PUSH
30818: LD_INT 2
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 0
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: LD_INT 2
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: NEG
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 2
30911: NEG
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 2
30923: NEG
30924: PUSH
30925: LD_INT 2
30927: NEG
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30954: LD_ADDR_VAR 0 20
30958: PUSH
30959: LD_INT 0
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 1
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 2
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 2
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 2
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 2
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 2
31141: NEG
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 2
31157: NEG
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31184: LD_ADDR_VAR 0 21
31188: PUSH
31189: LD_INT 0
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 0
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 1
31212: PUSH
31213: LD_INT 0
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 1
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 0
31232: PUSH
31233: LD_INT 1
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 0
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 2
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 1
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 2
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 2
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 2
31319: PUSH
31320: LD_INT 2
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PUSH
31327: LD_INT 1
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: LD_INT 1
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: LD_INT 0
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: LD_INT 2
31371: NEG
31372: PUSH
31373: LD_INT 1
31375: NEG
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 2
31383: NEG
31384: PUSH
31385: LD_INT 2
31387: NEG
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31414: LD_ADDR_VAR 0 22
31418: PUSH
31419: LD_INT 0
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 0
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 1
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: LD_INT 1
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: LD_INT 0
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 1
31483: NEG
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: LD_INT 2
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 0
31507: PUSH
31508: LD_INT 2
31510: NEG
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 2
31549: PUSH
31550: LD_INT 2
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 1
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 2
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: LD_INT 0
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 2
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31644: LD_ADDR_VAR 0 23
31648: PUSH
31649: LD_INT 0
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: LD_INT 1
31664: NEG
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 0
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: NEG
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 2
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: LD_INT 2
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: PUSH
31749: LD_INT 1
31751: NEG
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 2
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 2
31820: NEG
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 2
31831: NEG
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 2
31847: NEG
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: LD_INT 3
31859: NEG
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 1
31867: NEG
31868: PUSH
31869: LD_INT 3
31871: NEG
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 1
31879: PUSH
31880: LD_INT 2
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: LIST
31909: LIST
31910: LIST
31911: LIST
31912: LIST
31913: LIST
31914: LIST
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31924: LD_ADDR_VAR 0 24
31928: PUSH
31929: LD_INT 0
31931: PUSH
31932: LD_INT 0
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 1
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 1
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: LD_INT 1
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 2
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 2
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: PUSH
32060: LD_INT 2
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 1
32089: NEG
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 2
32111: NEG
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 2
32123: NEG
32124: PUSH
32125: LD_INT 2
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 2
32138: NEG
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: PUSH
32147: LD_INT 1
32149: NEG
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 3
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 3
32167: PUSH
32168: LD_INT 2
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32200: LD_ADDR_VAR 0 25
32204: PUSH
32205: LD_INT 0
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 1
32228: PUSH
32229: LD_INT 0
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 1
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: LD_INT 2
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: PUSH
32326: LD_INT 1
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 2
32335: PUSH
32336: LD_INT 2
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: LD_INT 1
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 2
32387: NEG
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 3
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 3
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: PUSH
32432: LD_INT 3
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32474: LD_ADDR_VAR 0 26
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: LD_INT 0
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 1
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 1
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 1
32543: NEG
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: NEG
32556: PUSH
32557: LD_INT 2
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 2
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: LD_INT 1
32581: NEG
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 2
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: LD_INT 1
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: PUSH
32610: LD_INT 2
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: LD_INT 2
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 2
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: NEG
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 2
32673: NEG
32674: PUSH
32675: LD_INT 2
32677: NEG
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: PUSH
32686: LD_INT 3
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: PUSH
32696: LD_INT 3
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 1
32705: NEG
32706: PUSH
32707: LD_INT 2
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 2
32716: NEG
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32750: LD_ADDR_VAR 0 27
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 0
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: LD_INT 0
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: LD_INT 1
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: LD_INT 0
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 1
32823: NEG
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 2
32835: NEG
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 0
32843: PUSH
32844: LD_INT 2
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 2
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 2
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 1
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: LD_INT 1
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: LD_INT 0
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 2
32937: NEG
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 2
32953: NEG
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 3
32983: NEG
32984: PUSH
32985: LD_INT 1
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 3
32995: NEG
32996: PUSH
32997: LD_INT 2
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33030: LD_ADDR_VAR 0 28
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 0
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 1
33068: PUSH
33069: LD_INT 1
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 0
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 0
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: LD_INT 2
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 2
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 2
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 2
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: PUSH
33166: LD_INT 2
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 2
33229: NEG
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 2
33241: NEG
33242: PUSH
33243: LD_INT 3
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: NEG
33254: PUSH
33255: LD_INT 3
33257: NEG
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 3
33265: NEG
33266: PUSH
33267: LD_INT 1
33269: NEG
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 3
33277: NEG
33278: PUSH
33279: LD_INT 2
33281: NEG
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33312: LD_ADDR_VAR 0 29
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: LD_INT 0
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: LD_INT 1
33332: NEG
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 1
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: NEG
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 1
33393: NEG
33394: PUSH
33395: LD_INT 2
33397: NEG
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: LD_INT 2
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 2
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 2
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: LD_INT 2
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 2
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: NEG
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 2
33490: NEG
33491: PUSH
33492: LD_INT 2
33494: NEG
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 2
33502: NEG
33503: PUSH
33504: LD_INT 3
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 1
33517: NEG
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 3
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 3
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 1
33545: NEG
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: LD_INT 2
33560: NEG
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33591: LD_ADDR_VAR 0 30
33595: PUSH
33596: LD_INT 0
33598: PUSH
33599: LD_INT 0
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 0
33608: PUSH
33609: LD_INT 1
33611: NEG
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 1
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 1
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 0
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 0
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: LD_INT 1
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 2
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: LD_INT 2
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: LD_INT 1
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 2
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 1
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: LD_INT 1
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: LD_INT 1
33772: NEG
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: LD_INT 3
33784: NEG
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: LD_INT 2
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 3
33803: PUSH
33804: LD_INT 2
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 3
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 3
33834: NEG
33835: PUSH
33836: LD_INT 1
33838: NEG
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33869: LD_ADDR_VAR 0 31
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 0
33886: PUSH
33887: LD_INT 1
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 0
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 2
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: LD_INT 0
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 2
33983: PUSH
33984: LD_INT 1
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 2
33993: PUSH
33994: LD_INT 2
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: LD_INT 2
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: LD_INT 2
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 1
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 2
34034: NEG
34035: PUSH
34036: LD_INT 1
34038: NEG
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: NEG
34047: PUSH
34048: LD_INT 2
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 2
34058: NEG
34059: PUSH
34060: LD_INT 3
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 2
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 3
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 3
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 3
34112: NEG
34113: PUSH
34114: LD_INT 2
34116: NEG
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: LIST
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34147: LD_ADDR_VAR 0 32
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: LD_INT 0
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 1
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 0
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 1
34216: NEG
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 0
34240: PUSH
34241: LD_INT 2
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 1
34251: PUSH
34252: LD_INT 1
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 2
34262: PUSH
34263: LD_INT 1
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 2
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 1
34282: PUSH
34283: LD_INT 2
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: NEG
34303: PUSH
34304: LD_INT 1
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: NEG
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: LD_INT 3
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 3
34359: PUSH
34360: LD_INT 2
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 2
34369: PUSH
34370: LD_INT 3
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 3
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: NEG
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34425: LD_ADDR_VAR 0 33
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: LD_INT 0
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: LD_INT 1
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 0
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 1
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 0
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 2
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 2
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: LD_INT 1
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 2
34580: NEG
34581: PUSH
34582: LD_INT 0
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 2
34591: NEG
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 2
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 3
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 2
34627: PUSH
34628: LD_INT 1
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 3
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 1
34648: PUSH
34649: LD_INT 3
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 1
34658: NEG
34659: PUSH
34660: LD_INT 2
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 2
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34704: LD_ADDR_VAR 0 34
34708: PUSH
34709: LD_INT 0
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: NEG
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 1
34762: NEG
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: LD_INT 1
34777: NEG
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: LD_INT 2
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: PUSH
34809: LD_INT 1
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 2
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 1
34849: NEG
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 2
34871: NEG
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: LD_INT 2
34887: NEG
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: LD_INT 3
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 3
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 2
34928: PUSH
34929: LD_INT 3
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 3
34949: NEG
34950: PUSH
34951: LD_INT 1
34953: NEG
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34984: LD_ADDR_VAR 0 35
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 1
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: LD_INT 1
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 0
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 1
35053: NEG
35054: PUSH
35055: LD_INT 1
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 2
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 2
35075: NEG
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35096: LD_ADDR_VAR 0 36
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 0
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 0
35113: PUSH
35114: LD_INT 1
35116: NEG
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: LD_INT 1
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 2
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35208: LD_ADDR_VAR 0 37
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 0
35225: PUSH
35226: LD_INT 1
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: PUSH
35237: LD_INT 0
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 0
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: NEG
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 1
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35320: LD_ADDR_VAR 0 38
35324: PUSH
35325: LD_INT 0
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 0
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 1
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: EMPTY
35353: LIST
35354: LIST
35355: PUSH
35356: LD_INT 1
35358: PUSH
35359: LD_INT 1
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 0
35368: PUSH
35369: LD_INT 1
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: LD_INT 0
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 2
35411: NEG
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35432: LD_ADDR_VAR 0 39
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 0
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: PUSH
35461: LD_INT 0
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 1
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: NEG
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: NEG
35502: PUSH
35503: LD_INT 1
35505: NEG
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: LD_INT 2
35517: NEG
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 1
35525: PUSH
35526: LD_INT 2
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35544: LD_ADDR_VAR 0 40
35548: PUSH
35549: LD_INT 0
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 1
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35656: LD_ADDR_VAR 0 41
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 0
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: LD_INT 0
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 0
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 1
35725: NEG
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: LD_INT 2
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 2
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 2
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 1
35800: NEG
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 2
35811: NEG
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 2
35822: NEG
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: LD_INT 2
35838: NEG
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 2
35846: NEG
35847: PUSH
35848: LD_INT 3
35850: NEG
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 3
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 3
35889: PUSH
35890: LD_INT 2
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 3
35899: PUSH
35900: LD_INT 3
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 2
35909: PUSH
35910: LD_INT 3
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: NEG
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 3
35941: NEG
35942: PUSH
35943: LD_INT 1
35945: NEG
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 3
35953: NEG
35954: PUSH
35955: LD_INT 2
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36006: LD_ADDR_VAR 0 42
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 0
36054: PUSH
36055: LD_INT 1
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 1
36064: NEG
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: LD_INT 1
36079: NEG
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 1
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 1
36141: PUSH
36142: LD_INT 2
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 2
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: NEG
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 2
36172: NEG
36173: PUSH
36174: LD_INT 1
36176: NEG
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 2
36184: NEG
36185: PUSH
36186: LD_INT 2
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: LD_INT 3
36200: NEG
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: LD_INT 3
36212: NEG
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: LD_INT 3
36223: NEG
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 1
36231: PUSH
36232: LD_INT 2
36234: NEG
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 3
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 3
36252: PUSH
36253: LD_INT 3
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: LD_INT 3
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 3
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: LD_INT 3
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 3
36303: NEG
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 3
36315: NEG
36316: PUSH
36317: LD_INT 3
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36356: LD_ADDR_VAR 0 43
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 0
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 0
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: LD_INT 1
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 0
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 2
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: LD_INT 2
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: LD_INT 0
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: LD_INT 1
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 2
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 2
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 1
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 2
36522: NEG
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: NEG
36534: PUSH
36535: LD_INT 1
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: NEG
36546: PUSH
36547: LD_INT 3
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: LD_INT 3
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 2
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 3
36590: PUSH
36591: LD_INT 0
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 3
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 3
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: LD_INT 3
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 2
36641: NEG
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 3
36652: NEG
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 3
36663: NEG
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36704: LD_ADDR_VAR 0 44
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 1
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 0
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: LD_INT 1
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 0
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: LD_INT 1
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: LD_INT 2
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: LD_INT 1
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: LD_INT 3
36898: NEG
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 2
36906: PUSH
36907: LD_INT 1
36909: NEG
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 3
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 3
36937: PUSH
36938: LD_INT 2
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 3
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 2
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 2
36967: NEG
36968: PUSH
36969: LD_INT 1
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 3
36978: NEG
36979: PUSH
36980: LD_INT 0
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: LD_INT 1
36993: NEG
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 3
37001: NEG
37002: PUSH
37003: LD_INT 2
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 3
37013: NEG
37014: PUSH
37015: LD_INT 3
37017: NEG
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37054: LD_ADDR_VAR 0 45
37058: PUSH
37059: LD_INT 0
37061: PUSH
37062: LD_INT 0
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 0
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 1
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: LD_INT 0
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 1
37123: NEG
37124: PUSH
37125: LD_INT 1
37127: NEG
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 0
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 1
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: LD_INT 2
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: LD_INT 2
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 2
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 1
37209: NEG
37210: PUSH
37211: LD_INT 1
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: LD_INT 1
37224: NEG
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 2
37232: NEG
37233: PUSH
37234: LD_INT 2
37236: NEG
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: LD_INT 3
37248: NEG
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 3
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 0
37268: PUSH
37269: LD_INT 3
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: LD_INT 2
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 3
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 3
37300: PUSH
37301: LD_INT 3
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 2
37310: PUSH
37311: LD_INT 3
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: PUSH
37321: LD_INT 3
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 1
37340: NEG
37341: PUSH
37342: LD_INT 2
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: LD_INT 2
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 3
37363: NEG
37364: PUSH
37365: LD_INT 3
37367: NEG
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37404: LD_ADDR_VAR 0 46
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: LD_INT 0
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: NEG
37463: PUSH
37464: LD_INT 0
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 2
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: LD_INT 2
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 2
37519: PUSH
37520: LD_INT 0
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 1
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 1
37539: PUSH
37540: LD_INT 2
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: NEG
37560: PUSH
37561: LD_INT 1
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 2
37570: NEG
37571: PUSH
37572: LD_INT 0
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 2
37581: NEG
37582: PUSH
37583: LD_INT 1
37585: NEG
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 1
37593: NEG
37594: PUSH
37595: LD_INT 3
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: LD_INT 3
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 1
37616: PUSH
37617: LD_INT 2
37619: NEG
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 2
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 3
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: LD_INT 1
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: PUSH
37659: LD_INT 3
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 3
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 2
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: LD_INT 1
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 3
37700: NEG
37701: PUSH
37702: LD_INT 0
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 3
37711: NEG
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: LIST
37741: LIST
37742: LIST
37743: LIST
37744: LIST
37745: LIST
37746: LIST
37747: LIST
37748: LIST
37749: LIST
37750: LIST
37751: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37752: LD_ADDR_VAR 0 47
37756: PUSH
37757: LD_INT 0
37759: PUSH
37760: LD_INT 0
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: NEG
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 1
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: PUSH
37791: LD_INT 1
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 1
37810: NEG
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: NEG
37822: PUSH
37823: LD_INT 1
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: LD_INT 2
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 0
37845: PUSH
37846: LD_INT 2
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 2
37867: NEG
37868: PUSH
37869: LD_INT 1
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: LD_INT 2
37883: NEG
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: LIST
37897: LIST
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37903: LD_ADDR_VAR 0 48
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: LD_INT 0
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 0
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 0
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 1
37961: NEG
37962: PUSH
37963: LD_INT 0
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 0
37996: PUSH
37997: LD_INT 2
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38050: LD_ADDR_VAR 0 49
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 0
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: LD_INT 1
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: LD_INT 1
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: LD_INT 1
38123: NEG
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: LD_INT 1
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 2
38142: PUSH
38143: LD_INT 0
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 2
38152: PUSH
38153: LD_INT 1
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 1
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38194: LD_ADDR_VAR 0 50
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 0
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 2
38275: PUSH
38276: LD_INT 1
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: PUSH
38286: LD_INT 2
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 0
38305: PUSH
38306: LD_INT 2
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 1
38315: NEG
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38338: LD_ADDR_VAR 0 51
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: LD_INT 0
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 0
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 1
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: NEG
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: NEG
38408: PUSH
38409: LD_INT 1
38411: NEG
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: PUSH
38420: LD_INT 2
38422: PUSH
38423: EMPTY
38424: LIST
38425: LIST
38426: PUSH
38427: LD_INT 0
38429: PUSH
38430: LD_INT 2
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 1
38439: NEG
38440: PUSH
38441: LD_INT 1
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 2
38450: NEG
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: LIST
38484: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38485: LD_ADDR_VAR 0 52
38489: PUSH
38490: LD_INT 0
38492: PUSH
38493: LD_INT 0
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 1
38513: PUSH
38514: LD_INT 0
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 1
38523: PUSH
38524: LD_INT 1
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: NEG
38555: PUSH
38556: LD_INT 1
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: LD_INT 2
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 1
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 2
38589: NEG
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: LD_INT 2
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38636: LD_ADDR_VAR 0 53
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: LD_INT 0
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: LD_INT 1
38656: NEG
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: LD_INT 0
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 0
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: NEG
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: NEG
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 0
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: LD_INT 1
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 2
38751: PUSH
38752: LD_INT 0
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 2
38761: PUSH
38762: LD_INT 1
38764: PUSH
38765: EMPTY
38766: LIST
38767: LIST
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: LD_INT 2
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 1
38781: PUSH
38782: LD_INT 2
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 1
38801: NEG
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: LD_INT 0
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 2
38823: NEG
38824: PUSH
38825: LD_INT 1
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 2
38835: NEG
38836: PUSH
38837: LD_INT 2
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38866: LD_ADDR_VAR 0 54
38870: PUSH
38871: LD_INT 0
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 0
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 1
38894: PUSH
38895: LD_INT 0
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 1
38904: PUSH
38905: LD_INT 1
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 1
38935: NEG
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 1
38947: NEG
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 0
38959: PUSH
38960: LD_INT 2
38962: NEG
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 1
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: PUSH
38982: LD_INT 0
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 2
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 2
39001: PUSH
39002: LD_INT 2
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 1
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 1
39031: NEG
39032: PUSH
39033: LD_INT 1
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: LD_INT 0
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 2
39053: NEG
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 2
39065: NEG
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39096: LD_ADDR_VAR 0 55
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: LD_INT 0
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 1
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: LD_INT 1
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 1
39154: NEG
39155: PUSH
39156: LD_INT 0
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 1
39165: NEG
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 1
39177: NEG
39178: PUSH
39179: LD_INT 2
39181: NEG
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 0
39189: PUSH
39190: LD_INT 2
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: LD_INT 1
39203: NEG
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 2
39211: PUSH
39212: LD_INT 0
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 2
39283: NEG
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: NEG
39296: PUSH
39297: LD_INT 2
39299: NEG
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: LIST
39323: LIST
39324: LIST
39325: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39326: LD_ADDR_VAR 0 56
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 0
39343: PUSH
39344: LD_INT 1
39346: NEG
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 1
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: LD_INT 1
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 1
39384: NEG
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: LD_INT 1
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: LD_INT 2
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 0
39419: PUSH
39420: LD_INT 2
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 2
39441: PUSH
39442: LD_INT 0
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: PUSH
39452: LD_INT 1
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 2
39461: PUSH
39462: LD_INT 2
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 1
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 2
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 2
39513: NEG
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: LD_INT 2
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39556: LD_ADDR_VAR 0 57
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: LD_INT 0
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 0
39573: PUSH
39574: LD_INT 1
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: LD_INT 1
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 1
39614: NEG
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: NEG
39626: PUSH
39627: LD_INT 1
39629: NEG
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 2
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: LD_INT 2
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 1
39660: PUSH
39661: LD_INT 1
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 2
39671: PUSH
39672: LD_INT 0
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 1
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: LD_INT 2
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: LD_INT 1
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 2
39755: NEG
39756: PUSH
39757: LD_INT 2
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: LIST
39784: LIST
39785: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39786: LD_ADDR_VAR 0 58
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: LD_INT 0
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 0
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 1
39855: NEG
39856: PUSH
39857: LD_INT 1
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: LD_INT 2
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: LD_INT 2
39882: NEG
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 1
39890: PUSH
39891: LD_INT 1
39893: NEG
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 2
39901: PUSH
39902: LD_INT 0
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 2
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 2
39921: PUSH
39922: LD_INT 2
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 2
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 2
39962: NEG
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 2
39973: NEG
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: LD_INT 2
39989: NEG
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40016: LD_ADDR_VAR 0 59
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 0
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 1
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 0
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 1
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40104: LD_ADDR_VAR 0 60
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: LD_INT 1
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: PUSH
40133: LD_INT 0
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: LD_INT 1
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 0
40152: PUSH
40153: LD_INT 1
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: PUSH
40160: LD_INT 1
40162: NEG
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 1
40173: NEG
40174: PUSH
40175: LD_INT 1
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40192: LD_ADDR_VAR 0 61
40196: PUSH
40197: LD_INT 0
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: PUSH
40231: LD_INT 1
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 1
40261: NEG
40262: PUSH
40263: LD_INT 1
40265: NEG
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40280: LD_ADDR_VAR 0 62
40284: PUSH
40285: LD_INT 0
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: LD_INT 1
40300: NEG
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 1
40308: PUSH
40309: LD_INT 0
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 0
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: NEG
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: LD_INT 1
40353: NEG
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40368: LD_ADDR_VAR 0 63
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 1
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: LD_INT 1
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40456: LD_ADDR_VAR 0 64
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 0
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 1
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: PUSH
40485: LD_INT 0
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 0
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 1
40525: NEG
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: ST_TO_ADDR
// end ; 1 :
40544: GO 46441
40546: LD_INT 1
40548: DOUBLE
40549: EQUAL
40550: IFTRUE 40554
40552: GO 43177
40554: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40555: LD_ADDR_VAR 0 11
40559: PUSH
40560: LD_INT 1
40562: NEG
40563: PUSH
40564: LD_INT 3
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 0
40574: PUSH
40575: LD_INT 3
40577: NEG
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: LD_INT 2
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: LIST
40598: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40599: LD_ADDR_VAR 0 12
40603: PUSH
40604: LD_INT 2
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 3
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40640: LD_ADDR_VAR 0 13
40644: PUSH
40645: LD_INT 3
40647: PUSH
40648: LD_INT 2
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 3
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 2
40667: PUSH
40668: LD_INT 3
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: LIST
40679: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40680: LD_ADDR_VAR 0 14
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: LD_INT 3
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: LD_INT 3
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 1
40707: NEG
40708: PUSH
40709: LD_INT 2
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: LIST
40720: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40721: LD_ADDR_VAR 0 15
40725: PUSH
40726: LD_INT 2
40728: NEG
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 3
40739: NEG
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 3
40750: NEG
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40765: LD_ADDR_VAR 0 16
40769: PUSH
40770: LD_INT 2
40772: NEG
40773: PUSH
40774: LD_INT 3
40776: NEG
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 3
40784: NEG
40785: PUSH
40786: LD_INT 2
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: NEG
40797: PUSH
40798: LD_INT 3
40800: NEG
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: LIST
40810: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40811: LD_ADDR_VAR 0 17
40815: PUSH
40816: LD_INT 1
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: LD_INT 3
40833: NEG
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 1
40841: PUSH
40842: LD_INT 2
40844: NEG
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: LIST
40854: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40855: LD_ADDR_VAR 0 18
40859: PUSH
40860: LD_INT 2
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 3
40883: PUSH
40884: LD_INT 1
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: LIST
40895: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40896: LD_ADDR_VAR 0 19
40900: PUSH
40901: LD_INT 3
40903: PUSH
40904: LD_INT 2
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 3
40913: PUSH
40914: LD_INT 3
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 2
40923: PUSH
40924: LD_INT 3
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: LIST
40935: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40936: LD_ADDR_VAR 0 20
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 3
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 3
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 2
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: LIST
40976: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40977: LD_ADDR_VAR 0 21
40981: PUSH
40982: LD_INT 2
40984: NEG
40985: PUSH
40986: LD_INT 1
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 3
40995: NEG
40996: PUSH
40997: LD_INT 0
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 3
41006: NEG
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: LIST
41020: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41021: LD_ADDR_VAR 0 22
41025: PUSH
41026: LD_INT 2
41028: NEG
41029: PUSH
41030: LD_INT 3
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 2
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: NEG
41053: PUSH
41054: LD_INT 3
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: LIST
41066: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41067: LD_ADDR_VAR 0 23
41071: PUSH
41072: LD_INT 0
41074: PUSH
41075: LD_INT 3
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 1
41085: NEG
41086: PUSH
41087: LD_INT 4
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 1
41097: PUSH
41098: LD_INT 3
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: LIST
41110: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41111: LD_ADDR_VAR 0 24
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 0
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 1
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: LIST
41151: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41152: LD_ADDR_VAR 0 25
41156: PUSH
41157: LD_INT 3
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 4
41169: PUSH
41170: LD_INT 3
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: LD_INT 4
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: LIST
41191: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41192: LD_ADDR_VAR 0 26
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: LD_INT 3
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: LD_INT 4
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 1
41219: NEG
41220: PUSH
41221: LD_INT 3
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: LIST
41232: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41233: LD_ADDR_VAR 0 27
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 4
41262: NEG
41263: PUSH
41264: LD_INT 1
41266: NEG
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: LIST
41276: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41277: LD_ADDR_VAR 0 28
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: LD_INT 3
41288: NEG
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 3
41296: NEG
41297: PUSH
41298: LD_INT 4
41300: NEG
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: PUSH
41306: LD_INT 4
41308: NEG
41309: PUSH
41310: LD_INT 3
41312: NEG
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: LIST
41322: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41323: LD_ADDR_VAR 0 29
41327: PUSH
41328: LD_INT 1
41330: NEG
41331: PUSH
41332: LD_INT 3
41334: NEG
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_INT 3
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 1
41353: PUSH
41354: LD_INT 2
41356: NEG
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 1
41364: NEG
41365: PUSH
41366: LD_INT 4
41368: NEG
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 0
41376: PUSH
41377: LD_INT 4
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 1
41387: PUSH
41388: LD_INT 3
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: LD_INT 5
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 0
41410: PUSH
41411: LD_INT 5
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: LD_INT 4
41424: NEG
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: LD_INT 6
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 0
41444: PUSH
41445: LD_INT 6
41447: NEG
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: LD_INT 5
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41478: LD_ADDR_VAR 0 30
41482: PUSH
41483: LD_INT 2
41485: PUSH
41486: LD_INT 1
41488: NEG
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 3
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 3
41506: PUSH
41507: LD_INT 1
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 3
41516: PUSH
41517: LD_INT 1
41519: NEG
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: LD_INT 4
41527: PUSH
41528: LD_INT 0
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 4
41537: PUSH
41538: LD_INT 1
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 4
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 5
41558: PUSH
41559: LD_INT 0
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 5
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 5
41578: PUSH
41579: LD_INT 1
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 6
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 6
41599: PUSH
41600: LD_INT 1
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41621: LD_ADDR_VAR 0 31
41625: PUSH
41626: LD_INT 3
41628: PUSH
41629: LD_INT 2
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 3
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 2
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 4
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 4
41668: PUSH
41669: LD_INT 4
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: PUSH
41679: LD_INT 4
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 5
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 5
41698: PUSH
41699: LD_INT 5
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 4
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 6
41718: PUSH
41719: LD_INT 5
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 6
41728: PUSH
41729: LD_INT 6
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 5
41738: PUSH
41739: LD_INT 6
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41760: LD_ADDR_VAR 0 32
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: LD_INT 3
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: LD_INT 2
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 1
41798: PUSH
41799: LD_INT 4
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 0
41808: PUSH
41809: LD_INT 4
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: NEG
41819: PUSH
41820: LD_INT 3
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 1
41829: PUSH
41830: LD_INT 5
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 0
41839: PUSH
41840: LD_INT 5
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 1
41849: NEG
41850: PUSH
41851: LD_INT 4
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 1
41860: PUSH
41861: LD_INT 6
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: LD_INT 6
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: LD_INT 5
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41903: LD_ADDR_VAR 0 33
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: LD_INT 1
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 3
41921: NEG
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 3
41932: NEG
41933: PUSH
41934: LD_INT 1
41936: NEG
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 3
41944: NEG
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 4
41955: NEG
41956: PUSH
41957: LD_INT 0
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 4
41966: NEG
41967: PUSH
41968: LD_INT 1
41970: NEG
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 4
41978: NEG
41979: PUSH
41980: LD_INT 1
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 5
41989: NEG
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 5
42000: NEG
42001: PUSH
42002: LD_INT 1
42004: NEG
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 5
42012: NEG
42013: PUSH
42014: LD_INT 1
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 6
42023: NEG
42024: PUSH
42025: LD_INT 0
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: LD_INT 6
42034: NEG
42035: PUSH
42036: LD_INT 1
42038: NEG
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: LIST
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42058: LD_ADDR_VAR 0 34
42062: PUSH
42063: LD_INT 2
42065: NEG
42066: PUSH
42067: LD_INT 3
42069: NEG
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 3
42077: NEG
42078: PUSH
42079: LD_INT 2
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: LD_INT 3
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 3
42101: NEG
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 4
42113: NEG
42114: PUSH
42115: LD_INT 3
42117: NEG
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 4
42125: NEG
42126: PUSH
42127: LD_INT 4
42129: NEG
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PUSH
42135: LD_INT 4
42137: NEG
42138: PUSH
42139: LD_INT 5
42141: NEG
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 5
42149: NEG
42150: PUSH
42151: LD_INT 4
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 5
42161: NEG
42162: PUSH
42163: LD_INT 5
42165: NEG
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: LD_INT 6
42177: NEG
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 6
42185: NEG
42186: PUSH
42187: LD_INT 5
42189: NEG
42190: PUSH
42191: EMPTY
42192: LIST
42193: LIST
42194: PUSH
42195: LD_INT 6
42197: NEG
42198: PUSH
42199: LD_INT 6
42201: NEG
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42221: LD_ADDR_VAR 0 41
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: LD_INT 2
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 1
42251: PUSH
42252: LD_INT 2
42254: NEG
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: LIST
42264: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42265: LD_ADDR_VAR 0 42
42269: PUSH
42270: LD_INT 2
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: LD_INT 1
42285: NEG
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42306: LD_ADDR_VAR 0 43
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: LD_INT 2
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: LD_INT 2
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: LIST
42345: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42346: LD_ADDR_VAR 0 44
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: LD_INT 2
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: LD_INT 3
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 1
42373: NEG
42374: PUSH
42375: LD_INT 2
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: LIST
42386: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42387: LD_ADDR_VAR 0 45
42391: PUSH
42392: LD_INT 2
42394: NEG
42395: PUSH
42396: LD_INT 0
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 2
42405: NEG
42406: PUSH
42407: LD_INT 1
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 3
42416: NEG
42417: PUSH
42418: LD_INT 1
42420: NEG
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: LIST
42430: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42431: LD_ADDR_VAR 0 46
42435: PUSH
42436: LD_INT 2
42438: NEG
42439: PUSH
42440: LD_INT 2
42442: NEG
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: LD_INT 3
42454: NEG
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: LD_INT 2
42466: NEG
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: LIST
42476: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42477: LD_ADDR_VAR 0 47
42481: PUSH
42482: LD_INT 2
42484: NEG
42485: PUSH
42486: LD_INT 3
42488: NEG
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: NEG
42497: PUSH
42498: LD_INT 3
42500: NEG
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42510: LD_ADDR_VAR 0 48
42514: PUSH
42515: LD_INT 1
42517: PUSH
42518: LD_INT 2
42520: NEG
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 2
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42541: LD_ADDR_VAR 0 49
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: LD_INT 1
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 3
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42570: LD_ADDR_VAR 0 50
42574: PUSH
42575: LD_INT 2
42577: PUSH
42578: LD_INT 3
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 1
42587: PUSH
42588: LD_INT 3
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42599: LD_ADDR_VAR 0 51
42603: PUSH
42604: LD_INT 1
42606: NEG
42607: PUSH
42608: LD_INT 2
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 2
42617: NEG
42618: PUSH
42619: LD_INT 1
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42630: LD_ADDR_VAR 0 52
42634: PUSH
42635: LD_INT 3
42637: NEG
42638: PUSH
42639: LD_INT 1
42641: NEG
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: PUSH
42647: LD_INT 3
42649: NEG
42650: PUSH
42651: LD_INT 2
42653: NEG
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42663: LD_ADDR_VAR 0 53
42667: PUSH
42668: LD_INT 1
42670: NEG
42671: PUSH
42672: LD_INT 3
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 0
42682: PUSH
42683: LD_INT 3
42685: NEG
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 2
42696: NEG
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: LIST
42706: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42707: LD_ADDR_VAR 0 54
42711: PUSH
42712: LD_INT 2
42714: PUSH
42715: LD_INT 1
42717: NEG
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: LD_INT 1
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: LIST
42747: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42748: LD_ADDR_VAR 0 55
42752: PUSH
42753: LD_INT 3
42755: PUSH
42756: LD_INT 2
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 3
42765: PUSH
42766: LD_INT 3
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 2
42775: PUSH
42776: LD_INT 3
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: LIST
42787: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42788: LD_ADDR_VAR 0 56
42792: PUSH
42793: LD_INT 1
42795: PUSH
42796: LD_INT 3
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 0
42805: PUSH
42806: LD_INT 3
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 2
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: LIST
42828: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42829: LD_ADDR_VAR 0 57
42833: PUSH
42834: LD_INT 2
42836: NEG
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 3
42847: NEG
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 3
42858: NEG
42859: PUSH
42860: LD_INT 1
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: LIST
42872: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42873: LD_ADDR_VAR 0 58
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: LD_INT 3
42884: NEG
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 3
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: LD_INT 3
42904: NEG
42905: PUSH
42906: LD_INT 3
42908: NEG
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: LIST
42918: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42919: LD_ADDR_VAR 0 59
42923: PUSH
42924: LD_INT 1
42926: NEG
42927: PUSH
42928: LD_INT 2
42930: NEG
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 0
42938: PUSH
42939: LD_INT 2
42941: NEG
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 1
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: LIST
42962: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42963: LD_ADDR_VAR 0 60
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 2
42981: PUSH
42982: LD_INT 0
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 2
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: LIST
43003: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43004: LD_ADDR_VAR 0 61
43008: PUSH
43009: LD_INT 2
43011: PUSH
43012: LD_INT 1
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: LD_INT 2
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 1
43031: PUSH
43032: LD_INT 2
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: LIST
43043: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43044: LD_ADDR_VAR 0 62
43048: PUSH
43049: LD_INT 1
43051: PUSH
43052: LD_INT 2
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 2
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: LD_INT 1
43071: NEG
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: LIST
43084: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43085: LD_ADDR_VAR 0 63
43089: PUSH
43090: LD_INT 1
43092: NEG
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 2
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 2
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: LIST
43128: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43129: LD_ADDR_VAR 0 64
43133: PUSH
43134: LD_INT 1
43136: NEG
43137: PUSH
43138: LD_INT 2
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: NEG
43161: PUSH
43162: LD_INT 2
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: LIST
43174: ST_TO_ADDR
// end ; 2 :
43175: GO 46441
43177: LD_INT 2
43179: DOUBLE
43180: EQUAL
43181: IFTRUE 43185
43183: GO 46440
43185: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43186: LD_ADDR_VAR 0 29
43190: PUSH
43191: LD_INT 4
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 4
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 5
43214: PUSH
43215: LD_INT 0
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 5
43224: PUSH
43225: LD_INT 1
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: LD_INT 1
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 3
43244: PUSH
43245: LD_INT 0
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 3
43254: PUSH
43255: LD_INT 1
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 3
43265: PUSH
43266: LD_INT 2
43268: NEG
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: LD_INT 5
43276: PUSH
43277: LD_INT 2
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: PUSH
43287: LD_INT 3
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: PUSH
43297: LD_INT 2
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: PUSH
43304: LD_INT 4
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 4
43316: PUSH
43317: LD_INT 4
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 3
43326: PUSH
43327: LD_INT 4
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: LD_INT 3
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: LD_INT 2
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 4
43356: PUSH
43357: LD_INT 2
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 4
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 0
43376: PUSH
43377: LD_INT 4
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 0
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: PUSH
43397: LD_INT 4
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: LD_INT 1
43406: PUSH
43407: LD_INT 5
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 0
43416: PUSH
43417: LD_INT 5
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: LD_INT 4
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: LD_INT 3
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 2
43448: PUSH
43449: LD_INT 5
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 3
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 3
43469: NEG
43470: PUSH
43471: LD_INT 0
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 3
43480: NEG
43481: PUSH
43482: LD_INT 1
43484: NEG
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 2
43492: NEG
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 2
43503: NEG
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 3
43514: NEG
43515: PUSH
43516: LD_INT 1
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 4
43525: NEG
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 4
43536: NEG
43537: PUSH
43538: LD_INT 1
43540: NEG
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 4
43548: NEG
43549: PUSH
43550: LD_INT 2
43552: NEG
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 2
43560: NEG
43561: PUSH
43562: LD_INT 2
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 4
43571: NEG
43572: PUSH
43573: LD_INT 4
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 4
43583: NEG
43584: PUSH
43585: LD_INT 5
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: LD_INT 3
43595: NEG
43596: PUSH
43597: LD_INT 4
43599: NEG
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 3
43607: NEG
43608: PUSH
43609: LD_INT 3
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 4
43619: NEG
43620: PUSH
43621: LD_INT 3
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 5
43631: NEG
43632: PUSH
43633: LD_INT 4
43635: NEG
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 5
43643: NEG
43644: PUSH
43645: LD_INT 5
43647: NEG
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 3
43655: NEG
43656: PUSH
43657: LD_INT 5
43659: NEG
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 5
43667: NEG
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43724: LD_ADDR_VAR 0 30
43728: PUSH
43729: LD_INT 4
43731: PUSH
43732: LD_INT 4
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 4
43741: PUSH
43742: LD_INT 3
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 5
43751: PUSH
43752: LD_INT 4
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 5
43761: PUSH
43762: LD_INT 5
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 4
43771: PUSH
43772: LD_INT 5
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: PUSH
43782: LD_INT 4
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 3
43791: PUSH
43792: LD_INT 3
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 5
43801: PUSH
43802: LD_INT 3
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 3
43811: PUSH
43812: LD_INT 5
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 0
43821: PUSH
43822: LD_INT 3
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 0
43831: PUSH
43832: LD_INT 2
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 1
43841: PUSH
43842: LD_INT 3
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 1
43851: PUSH
43852: LD_INT 4
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 0
43861: PUSH
43862: LD_INT 4
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 1
43871: NEG
43872: PUSH
43873: LD_INT 3
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: LD_INT 2
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: LD_INT 4
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 2
43903: NEG
43904: PUSH
43905: LD_INT 2
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 4
43914: NEG
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 4
43925: NEG
43926: PUSH
43927: LD_INT 1
43929: NEG
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: NEG
43938: PUSH
43939: LD_INT 0
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 3
43948: NEG
43949: PUSH
43950: LD_INT 1
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 4
43959: NEG
43960: PUSH
43961: LD_INT 1
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 5
43970: NEG
43971: PUSH
43972: LD_INT 0
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 5
43981: NEG
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 5
43993: NEG
43994: PUSH
43995: LD_INT 2
43997: NEG
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: LD_INT 2
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 3
44016: NEG
44017: PUSH
44018: LD_INT 3
44020: NEG
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 3
44028: NEG
44029: PUSH
44030: LD_INT 4
44032: NEG
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 2
44040: NEG
44041: PUSH
44042: LD_INT 3
44044: NEG
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: LD_INT 2
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: LD_INT 2
44068: NEG
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: LD_INT 4
44076: NEG
44077: PUSH
44078: LD_INT 3
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 4
44088: NEG
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: NEG
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: NEG
44113: PUSH
44114: LD_INT 2
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: LD_INT 4
44127: NEG
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 0
44135: PUSH
44136: LD_INT 5
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 1
44146: PUSH
44147: LD_INT 4
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 1
44157: PUSH
44158: LD_INT 3
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 0
44168: PUSH
44169: LD_INT 3
44171: NEG
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: LD_INT 4
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: LD_INT 5
44195: NEG
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 2
44203: PUSH
44204: LD_INT 3
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 2
44214: NEG
44215: PUSH
44216: LD_INT 5
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: LIST
44228: LIST
44229: LIST
44230: LIST
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44271: LD_ADDR_VAR 0 31
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: LD_INT 4
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 4
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 1
44308: PUSH
44309: LD_INT 5
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 0
44318: PUSH
44319: LD_INT 5
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 1
44328: NEG
44329: PUSH
44330: LD_INT 4
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 1
44339: NEG
44340: PUSH
44341: LD_INT 3
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 2
44350: PUSH
44351: LD_INT 5
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 3
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 3
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 3
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 2
44405: NEG
44406: PUSH
44407: LD_INT 1
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 3
44416: NEG
44417: PUSH
44418: LD_INT 1
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: NEG
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 4
44438: NEG
44439: PUSH
44440: LD_INT 1
44442: NEG
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: PUSH
44448: LD_INT 4
44450: NEG
44451: PUSH
44452: LD_INT 2
44454: NEG
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 2
44462: NEG
44463: PUSH
44464: LD_INT 2
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 4
44473: NEG
44474: PUSH
44475: LD_INT 4
44477: NEG
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 4
44485: NEG
44486: PUSH
44487: LD_INT 5
44489: NEG
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 3
44497: NEG
44498: PUSH
44499: LD_INT 4
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: LD_INT 3
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 4
44521: NEG
44522: PUSH
44523: LD_INT 3
44525: NEG
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 5
44533: NEG
44534: PUSH
44535: LD_INT 4
44537: NEG
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 5
44545: NEG
44546: PUSH
44547: LD_INT 5
44549: NEG
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 3
44557: NEG
44558: PUSH
44559: LD_INT 5
44561: NEG
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 5
44569: NEG
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: LD_INT 3
44584: NEG
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 0
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 1
44603: PUSH
44604: LD_INT 3
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 1
44614: PUSH
44615: LD_INT 2
44617: NEG
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 0
44625: PUSH
44626: LD_INT 2
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: LD_INT 3
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 1
44648: NEG
44649: PUSH
44650: LD_INT 4
44652: NEG
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 2
44660: PUSH
44661: LD_INT 2
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 2
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 4
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 4
44693: PUSH
44694: LD_INT 1
44696: NEG
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 5
44704: PUSH
44705: LD_INT 0
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 5
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 4
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 3
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 3
44755: PUSH
44756: LD_INT 2
44758: NEG
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 5
44766: PUSH
44767: LD_INT 2
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44821: LD_ADDR_VAR 0 32
44825: PUSH
44826: LD_INT 4
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 4
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 3
44851: NEG
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 3
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 4
44873: NEG
44874: PUSH
44875: LD_INT 1
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 5
44884: NEG
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 5
44895: NEG
44896: PUSH
44897: LD_INT 1
44899: NEG
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: NEG
44908: PUSH
44909: LD_INT 2
44911: NEG
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 3
44919: NEG
44920: PUSH
44921: LD_INT 2
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 3
44930: NEG
44931: PUSH
44932: LD_INT 3
44934: NEG
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 3
44942: NEG
44943: PUSH
44944: LD_INT 4
44946: NEG
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: LD_INT 2
44954: NEG
44955: PUSH
44956: LD_INT 3
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 2
44966: NEG
44967: PUSH
44968: LD_INT 2
44970: NEG
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 3
44978: NEG
44979: PUSH
44980: LD_INT 2
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 4
44990: NEG
44991: PUSH
44992: LD_INT 3
44994: NEG
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 4
45002: NEG
45003: PUSH
45004: LD_INT 4
45006: NEG
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: LD_INT 2
45014: NEG
45015: PUSH
45016: LD_INT 4
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 4
45026: NEG
45027: PUSH
45028: LD_INT 2
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 0
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 1
45060: PUSH
45061: LD_INT 4
45063: NEG
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 1
45071: PUSH
45072: LD_INT 3
45074: NEG
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: LD_INT 0
45082: PUSH
45083: LD_INT 3
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: LD_INT 4
45097: NEG
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 1
45105: NEG
45106: PUSH
45107: LD_INT 5
45109: NEG
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 2
45117: PUSH
45118: LD_INT 3
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: LD_INT 5
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 3
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 3
45150: PUSH
45151: LD_INT 1
45153: NEG
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: PUSH
45172: LD_INT 1
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: LD_INT 1
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 2
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 2
45201: PUSH
45202: LD_INT 1
45204: NEG
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: LD_INT 2
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 4
45223: PUSH
45224: LD_INT 2
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 4
45233: PUSH
45234: LD_INT 4
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 4
45243: PUSH
45244: LD_INT 3
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 5
45253: PUSH
45254: LD_INT 4
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 5
45263: PUSH
45264: LD_INT 5
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 4
45273: PUSH
45274: LD_INT 5
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 4
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 5
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 5
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45368: LD_ADDR_VAR 0 33
45372: PUSH
45373: LD_INT 4
45375: NEG
45376: PUSH
45377: LD_INT 4
45379: NEG
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 4
45387: NEG
45388: PUSH
45389: LD_INT 5
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: LD_INT 3
45399: NEG
45400: PUSH
45401: LD_INT 4
45403: NEG
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 3
45411: NEG
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 4
45423: NEG
45424: PUSH
45425: LD_INT 3
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 5
45435: NEG
45436: PUSH
45437: LD_INT 4
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 5
45447: NEG
45448: PUSH
45449: LD_INT 5
45451: NEG
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: PUSH
45457: LD_INT 3
45459: NEG
45460: PUSH
45461: LD_INT 5
45463: NEG
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 5
45471: NEG
45472: PUSH
45473: LD_INT 3
45475: NEG
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 0
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 3
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 1
45516: PUSH
45517: LD_INT 2
45519: NEG
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 0
45527: PUSH
45528: LD_INT 2
45530: NEG
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 1
45538: NEG
45539: PUSH
45540: LD_INT 3
45542: NEG
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 1
45550: NEG
45551: PUSH
45552: LD_INT 4
45554: NEG
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 2
45562: PUSH
45563: LD_INT 2
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 2
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 4
45585: PUSH
45586: LD_INT 0
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 4
45595: PUSH
45596: LD_INT 1
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 5
45606: PUSH
45607: LD_INT 0
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 5
45616: PUSH
45617: LD_INT 1
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: LD_INT 4
45626: PUSH
45627: LD_INT 1
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PUSH
45634: LD_INT 3
45636: PUSH
45637: LD_INT 0
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: PUSH
45644: LD_INT 3
45646: PUSH
45647: LD_INT 1
45649: NEG
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: LD_INT 3
45657: PUSH
45658: LD_INT 2
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 5
45668: PUSH
45669: LD_INT 2
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 3
45678: PUSH
45679: LD_INT 3
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 3
45688: PUSH
45689: LD_INT 2
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 4
45698: PUSH
45699: LD_INT 3
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 4
45708: PUSH
45709: LD_INT 4
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 3
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 2
45728: PUSH
45729: LD_INT 3
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 2
45738: PUSH
45739: LD_INT 2
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 4
45748: PUSH
45749: LD_INT 2
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 2
45758: PUSH
45759: LD_INT 4
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 0
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 0
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 1
45788: PUSH
45789: LD_INT 4
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 1
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 5
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 1
45829: NEG
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 2
45840: PUSH
45841: LD_INT 5
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 2
45850: NEG
45851: PUSH
45852: LD_INT 3
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45906: LD_ADDR_VAR 0 34
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 4
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 0
45924: PUSH
45925: LD_INT 5
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 1
45935: PUSH
45936: LD_INT 4
45938: NEG
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: LD_INT 3
45949: NEG
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: LD_INT 3
45960: NEG
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: LD_INT 4
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 1
45980: NEG
45981: PUSH
45982: LD_INT 5
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 2
45992: PUSH
45993: LD_INT 3
45995: NEG
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 2
46003: NEG
46004: PUSH
46005: LD_INT 5
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 3
46025: PUSH
46026: LD_INT 1
46028: NEG
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 4
46036: PUSH
46037: LD_INT 0
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 1
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 3
46056: PUSH
46057: LD_INT 1
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: LD_INT 2
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 2
46087: PUSH
46088: LD_INT 2
46090: NEG
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 4
46098: PUSH
46099: LD_INT 2
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 4
46108: PUSH
46109: LD_INT 4
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 4
46118: PUSH
46119: LD_INT 3
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 5
46128: PUSH
46129: LD_INT 4
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 5
46138: PUSH
46139: LD_INT 5
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 4
46148: PUSH
46149: LD_INT 5
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 3
46158: PUSH
46159: LD_INT 4
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: LD_INT 3
46168: PUSH
46169: LD_INT 3
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 5
46178: PUSH
46179: LD_INT 3
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 3
46188: PUSH
46189: LD_INT 5
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 0
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 0
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 1
46218: PUSH
46219: LD_INT 3
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 1
46228: PUSH
46229: LD_INT 4
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 0
46238: PUSH
46239: LD_INT 4
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 1
46248: NEG
46249: PUSH
46250: LD_INT 3
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 1
46259: NEG
46260: PUSH
46261: LD_INT 2
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 2
46270: PUSH
46271: LD_INT 4
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 2
46280: NEG
46281: PUSH
46282: LD_INT 2
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 4
46291: NEG
46292: PUSH
46293: LD_INT 0
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: LD_INT 4
46302: NEG
46303: PUSH
46304: LD_INT 1
46306: NEG
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 3
46325: NEG
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 4
46336: NEG
46337: PUSH
46338: LD_INT 1
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 5
46347: NEG
46348: PUSH
46349: LD_INT 0
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 5
46358: NEG
46359: PUSH
46360: LD_INT 1
46362: NEG
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 5
46370: NEG
46371: PUSH
46372: LD_INT 2
46374: NEG
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: LD_INT 3
46382: NEG
46383: PUSH
46384: LD_INT 2
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: ST_TO_ADDR
// end ; end ;
46438: GO 46441
46440: POP
// case btype of b_depot , b_warehouse :
46441: LD_VAR 0 1
46445: PUSH
46446: LD_INT 0
46448: DOUBLE
46449: EQUAL
46450: IFTRUE 46460
46452: LD_INT 1
46454: DOUBLE
46455: EQUAL
46456: IFTRUE 46460
46458: GO 46661
46460: POP
// case nation of nation_american :
46461: LD_VAR 0 5
46465: PUSH
46466: LD_INT 1
46468: DOUBLE
46469: EQUAL
46470: IFTRUE 46474
46472: GO 46530
46474: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46475: LD_ADDR_VAR 0 9
46479: PUSH
46480: LD_VAR 0 11
46484: PUSH
46485: LD_VAR 0 12
46489: PUSH
46490: LD_VAR 0 13
46494: PUSH
46495: LD_VAR 0 14
46499: PUSH
46500: LD_VAR 0 15
46504: PUSH
46505: LD_VAR 0 16
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: PUSH
46518: LD_VAR 0 4
46522: PUSH
46523: LD_INT 1
46525: PLUS
46526: ARRAY
46527: ST_TO_ADDR
46528: GO 46659
46530: LD_INT 2
46532: DOUBLE
46533: EQUAL
46534: IFTRUE 46538
46536: GO 46594
46538: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46539: LD_ADDR_VAR 0 9
46543: PUSH
46544: LD_VAR 0 17
46548: PUSH
46549: LD_VAR 0 18
46553: PUSH
46554: LD_VAR 0 19
46558: PUSH
46559: LD_VAR 0 20
46563: PUSH
46564: LD_VAR 0 21
46568: PUSH
46569: LD_VAR 0 22
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: PUSH
46582: LD_VAR 0 4
46586: PUSH
46587: LD_INT 1
46589: PLUS
46590: ARRAY
46591: ST_TO_ADDR
46592: GO 46659
46594: LD_INT 3
46596: DOUBLE
46597: EQUAL
46598: IFTRUE 46602
46600: GO 46658
46602: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46603: LD_ADDR_VAR 0 9
46607: PUSH
46608: LD_VAR 0 23
46612: PUSH
46613: LD_VAR 0 24
46617: PUSH
46618: LD_VAR 0 25
46622: PUSH
46623: LD_VAR 0 26
46627: PUSH
46628: LD_VAR 0 27
46632: PUSH
46633: LD_VAR 0 28
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: PUSH
46646: LD_VAR 0 4
46650: PUSH
46651: LD_INT 1
46653: PLUS
46654: ARRAY
46655: ST_TO_ADDR
46656: GO 46659
46658: POP
46659: GO 47214
46661: LD_INT 2
46663: DOUBLE
46664: EQUAL
46665: IFTRUE 46675
46667: LD_INT 3
46669: DOUBLE
46670: EQUAL
46671: IFTRUE 46675
46673: GO 46731
46675: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46676: LD_ADDR_VAR 0 9
46680: PUSH
46681: LD_VAR 0 29
46685: PUSH
46686: LD_VAR 0 30
46690: PUSH
46691: LD_VAR 0 31
46695: PUSH
46696: LD_VAR 0 32
46700: PUSH
46701: LD_VAR 0 33
46705: PUSH
46706: LD_VAR 0 34
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: PUSH
46719: LD_VAR 0 4
46723: PUSH
46724: LD_INT 1
46726: PLUS
46727: ARRAY
46728: ST_TO_ADDR
46729: GO 47214
46731: LD_INT 16
46733: DOUBLE
46734: EQUAL
46735: IFTRUE 46793
46737: LD_INT 17
46739: DOUBLE
46740: EQUAL
46741: IFTRUE 46793
46743: LD_INT 18
46745: DOUBLE
46746: EQUAL
46747: IFTRUE 46793
46749: LD_INT 19
46751: DOUBLE
46752: EQUAL
46753: IFTRUE 46793
46755: LD_INT 22
46757: DOUBLE
46758: EQUAL
46759: IFTRUE 46793
46761: LD_INT 20
46763: DOUBLE
46764: EQUAL
46765: IFTRUE 46793
46767: LD_INT 21
46769: DOUBLE
46770: EQUAL
46771: IFTRUE 46793
46773: LD_INT 23
46775: DOUBLE
46776: EQUAL
46777: IFTRUE 46793
46779: LD_INT 24
46781: DOUBLE
46782: EQUAL
46783: IFTRUE 46793
46785: LD_INT 25
46787: DOUBLE
46788: EQUAL
46789: IFTRUE 46793
46791: GO 46849
46793: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46794: LD_ADDR_VAR 0 9
46798: PUSH
46799: LD_VAR 0 35
46803: PUSH
46804: LD_VAR 0 36
46808: PUSH
46809: LD_VAR 0 37
46813: PUSH
46814: LD_VAR 0 38
46818: PUSH
46819: LD_VAR 0 39
46823: PUSH
46824: LD_VAR 0 40
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: PUSH
46837: LD_VAR 0 4
46841: PUSH
46842: LD_INT 1
46844: PLUS
46845: ARRAY
46846: ST_TO_ADDR
46847: GO 47214
46849: LD_INT 6
46851: DOUBLE
46852: EQUAL
46853: IFTRUE 46905
46855: LD_INT 7
46857: DOUBLE
46858: EQUAL
46859: IFTRUE 46905
46861: LD_INT 8
46863: DOUBLE
46864: EQUAL
46865: IFTRUE 46905
46867: LD_INT 13
46869: DOUBLE
46870: EQUAL
46871: IFTRUE 46905
46873: LD_INT 12
46875: DOUBLE
46876: EQUAL
46877: IFTRUE 46905
46879: LD_INT 15
46881: DOUBLE
46882: EQUAL
46883: IFTRUE 46905
46885: LD_INT 11
46887: DOUBLE
46888: EQUAL
46889: IFTRUE 46905
46891: LD_INT 14
46893: DOUBLE
46894: EQUAL
46895: IFTRUE 46905
46897: LD_INT 10
46899: DOUBLE
46900: EQUAL
46901: IFTRUE 46905
46903: GO 46961
46905: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46906: LD_ADDR_VAR 0 9
46910: PUSH
46911: LD_VAR 0 41
46915: PUSH
46916: LD_VAR 0 42
46920: PUSH
46921: LD_VAR 0 43
46925: PUSH
46926: LD_VAR 0 44
46930: PUSH
46931: LD_VAR 0 45
46935: PUSH
46936: LD_VAR 0 46
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: PUSH
46949: LD_VAR 0 4
46953: PUSH
46954: LD_INT 1
46956: PLUS
46957: ARRAY
46958: ST_TO_ADDR
46959: GO 47214
46961: LD_INT 36
46963: DOUBLE
46964: EQUAL
46965: IFTRUE 46969
46967: GO 47025
46969: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46970: LD_ADDR_VAR 0 9
46974: PUSH
46975: LD_VAR 0 47
46979: PUSH
46980: LD_VAR 0 48
46984: PUSH
46985: LD_VAR 0 49
46989: PUSH
46990: LD_VAR 0 50
46994: PUSH
46995: LD_VAR 0 51
46999: PUSH
47000: LD_VAR 0 52
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: PUSH
47013: LD_VAR 0 4
47017: PUSH
47018: LD_INT 1
47020: PLUS
47021: ARRAY
47022: ST_TO_ADDR
47023: GO 47214
47025: LD_INT 4
47027: DOUBLE
47028: EQUAL
47029: IFTRUE 47051
47031: LD_INT 5
47033: DOUBLE
47034: EQUAL
47035: IFTRUE 47051
47037: LD_INT 34
47039: DOUBLE
47040: EQUAL
47041: IFTRUE 47051
47043: LD_INT 37
47045: DOUBLE
47046: EQUAL
47047: IFTRUE 47051
47049: GO 47107
47051: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47052: LD_ADDR_VAR 0 9
47056: PUSH
47057: LD_VAR 0 53
47061: PUSH
47062: LD_VAR 0 54
47066: PUSH
47067: LD_VAR 0 55
47071: PUSH
47072: LD_VAR 0 56
47076: PUSH
47077: LD_VAR 0 57
47081: PUSH
47082: LD_VAR 0 58
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: PUSH
47095: LD_VAR 0 4
47099: PUSH
47100: LD_INT 1
47102: PLUS
47103: ARRAY
47104: ST_TO_ADDR
47105: GO 47214
47107: LD_INT 31
47109: DOUBLE
47110: EQUAL
47111: IFTRUE 47157
47113: LD_INT 32
47115: DOUBLE
47116: EQUAL
47117: IFTRUE 47157
47119: LD_INT 33
47121: DOUBLE
47122: EQUAL
47123: IFTRUE 47157
47125: LD_INT 27
47127: DOUBLE
47128: EQUAL
47129: IFTRUE 47157
47131: LD_INT 26
47133: DOUBLE
47134: EQUAL
47135: IFTRUE 47157
47137: LD_INT 28
47139: DOUBLE
47140: EQUAL
47141: IFTRUE 47157
47143: LD_INT 29
47145: DOUBLE
47146: EQUAL
47147: IFTRUE 47157
47149: LD_INT 30
47151: DOUBLE
47152: EQUAL
47153: IFTRUE 47157
47155: GO 47213
47157: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47158: LD_ADDR_VAR 0 9
47162: PUSH
47163: LD_VAR 0 59
47167: PUSH
47168: LD_VAR 0 60
47172: PUSH
47173: LD_VAR 0 61
47177: PUSH
47178: LD_VAR 0 62
47182: PUSH
47183: LD_VAR 0 63
47187: PUSH
47188: LD_VAR 0 64
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: PUSH
47201: LD_VAR 0 4
47205: PUSH
47206: LD_INT 1
47208: PLUS
47209: ARRAY
47210: ST_TO_ADDR
47211: GO 47214
47213: POP
// temp_list2 = [ ] ;
47214: LD_ADDR_VAR 0 10
47218: PUSH
47219: EMPTY
47220: ST_TO_ADDR
// for i in temp_list do
47221: LD_ADDR_VAR 0 8
47225: PUSH
47226: LD_VAR 0 9
47230: PUSH
47231: FOR_IN
47232: IFFALSE 47284
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47234: LD_ADDR_VAR 0 10
47238: PUSH
47239: LD_VAR 0 10
47243: PUSH
47244: LD_VAR 0 8
47248: PUSH
47249: LD_INT 1
47251: ARRAY
47252: PUSH
47253: LD_VAR 0 2
47257: PLUS
47258: PUSH
47259: LD_VAR 0 8
47263: PUSH
47264: LD_INT 2
47266: ARRAY
47267: PUSH
47268: LD_VAR 0 3
47272: PLUS
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: ADD
47281: ST_TO_ADDR
47282: GO 47231
47284: POP
47285: POP
// result = temp_list2 ;
47286: LD_ADDR_VAR 0 7
47290: PUSH
47291: LD_VAR 0 10
47295: ST_TO_ADDR
// end ;
47296: LD_VAR 0 7
47300: RET
// export function EnemyInRange ( unit , dist ) ; begin
47301: LD_INT 0
47303: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47304: LD_ADDR_VAR 0 3
47308: PUSH
47309: LD_VAR 0 1
47313: PPUSH
47314: CALL_OW 255
47318: PPUSH
47319: LD_VAR 0 1
47323: PPUSH
47324: CALL_OW 250
47328: PPUSH
47329: LD_VAR 0 1
47333: PPUSH
47334: CALL_OW 251
47338: PPUSH
47339: LD_VAR 0 2
47343: PPUSH
47344: CALL 20697 0 4
47348: PUSH
47349: LD_INT 4
47351: ARRAY
47352: ST_TO_ADDR
// end ;
47353: LD_VAR 0 3
47357: RET
// export function PlayerSeeMe ( unit ) ; begin
47358: LD_INT 0
47360: PPUSH
// result := See ( your_side , unit ) ;
47361: LD_ADDR_VAR 0 2
47365: PUSH
47366: LD_OWVAR 2
47370: PPUSH
47371: LD_VAR 0 1
47375: PPUSH
47376: CALL_OW 292
47380: ST_TO_ADDR
// end ;
47381: LD_VAR 0 2
47385: RET
// export function ReverseDir ( unit ) ; begin
47386: LD_INT 0
47388: PPUSH
// if not unit then
47389: LD_VAR 0 1
47393: NOT
47394: IFFALSE 47398
// exit ;
47396: GO 47421
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47398: LD_ADDR_VAR 0 2
47402: PUSH
47403: LD_VAR 0 1
47407: PPUSH
47408: CALL_OW 254
47412: PUSH
47413: LD_INT 3
47415: PLUS
47416: PUSH
47417: LD_INT 6
47419: MOD
47420: ST_TO_ADDR
// end ;
47421: LD_VAR 0 2
47425: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47426: LD_INT 0
47428: PPUSH
47429: PPUSH
47430: PPUSH
47431: PPUSH
47432: PPUSH
// if not hexes then
47433: LD_VAR 0 2
47437: NOT
47438: IFFALSE 47442
// exit ;
47440: GO 47590
// dist := 9999 ;
47442: LD_ADDR_VAR 0 5
47446: PUSH
47447: LD_INT 9999
47449: ST_TO_ADDR
// for i = 1 to hexes do
47450: LD_ADDR_VAR 0 4
47454: PUSH
47455: DOUBLE
47456: LD_INT 1
47458: DEC
47459: ST_TO_ADDR
47460: LD_VAR 0 2
47464: PUSH
47465: FOR_TO
47466: IFFALSE 47578
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47468: LD_VAR 0 1
47472: PPUSH
47473: LD_VAR 0 2
47477: PUSH
47478: LD_VAR 0 4
47482: ARRAY
47483: PUSH
47484: LD_INT 1
47486: ARRAY
47487: PPUSH
47488: LD_VAR 0 2
47492: PUSH
47493: LD_VAR 0 4
47497: ARRAY
47498: PUSH
47499: LD_INT 2
47501: ARRAY
47502: PPUSH
47503: CALL_OW 297
47507: PUSH
47508: LD_VAR 0 5
47512: LESS
47513: IFFALSE 47576
// begin hex := hexes [ i ] ;
47515: LD_ADDR_VAR 0 7
47519: PUSH
47520: LD_VAR 0 2
47524: PUSH
47525: LD_VAR 0 4
47529: ARRAY
47530: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47531: LD_ADDR_VAR 0 5
47535: PUSH
47536: LD_VAR 0 1
47540: PPUSH
47541: LD_VAR 0 2
47545: PUSH
47546: LD_VAR 0 4
47550: ARRAY
47551: PUSH
47552: LD_INT 1
47554: ARRAY
47555: PPUSH
47556: LD_VAR 0 2
47560: PUSH
47561: LD_VAR 0 4
47565: ARRAY
47566: PUSH
47567: LD_INT 2
47569: ARRAY
47570: PPUSH
47571: CALL_OW 297
47575: ST_TO_ADDR
// end ; end ;
47576: GO 47465
47578: POP
47579: POP
// result := hex ;
47580: LD_ADDR_VAR 0 3
47584: PUSH
47585: LD_VAR 0 7
47589: ST_TO_ADDR
// end ;
47590: LD_VAR 0 3
47594: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47595: LD_INT 0
47597: PPUSH
47598: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47599: LD_VAR 0 1
47603: NOT
47604: PUSH
47605: LD_VAR 0 1
47609: PUSH
47610: LD_INT 21
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 23
47622: PUSH
47623: LD_INT 2
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PPUSH
47634: CALL_OW 69
47638: IN
47639: NOT
47640: OR
47641: IFFALSE 47645
// exit ;
47643: GO 47692
// for i = 1 to 3 do
47645: LD_ADDR_VAR 0 3
47649: PUSH
47650: DOUBLE
47651: LD_INT 1
47653: DEC
47654: ST_TO_ADDR
47655: LD_INT 3
47657: PUSH
47658: FOR_TO
47659: IFFALSE 47690
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47661: LD_VAR 0 1
47665: PPUSH
47666: CALL_OW 250
47670: PPUSH
47671: LD_VAR 0 1
47675: PPUSH
47676: CALL_OW 251
47680: PPUSH
47681: LD_INT 1
47683: PPUSH
47684: CALL_OW 453
47688: GO 47658
47690: POP
47691: POP
// end ;
47692: LD_VAR 0 2
47696: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47697: LD_INT 0
47699: PPUSH
47700: PPUSH
47701: PPUSH
47702: PPUSH
47703: PPUSH
47704: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47705: LD_VAR 0 1
47709: NOT
47710: PUSH
47711: LD_VAR 0 2
47715: NOT
47716: OR
47717: PUSH
47718: LD_VAR 0 1
47722: PPUSH
47723: CALL_OW 314
47727: OR
47728: IFFALSE 47732
// exit ;
47730: GO 48173
// x := GetX ( enemy_unit ) ;
47732: LD_ADDR_VAR 0 7
47736: PUSH
47737: LD_VAR 0 2
47741: PPUSH
47742: CALL_OW 250
47746: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47747: LD_ADDR_VAR 0 8
47751: PUSH
47752: LD_VAR 0 2
47756: PPUSH
47757: CALL_OW 251
47761: ST_TO_ADDR
// if not x or not y then
47762: LD_VAR 0 7
47766: NOT
47767: PUSH
47768: LD_VAR 0 8
47772: NOT
47773: OR
47774: IFFALSE 47778
// exit ;
47776: GO 48173
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47778: LD_ADDR_VAR 0 6
47782: PUSH
47783: LD_VAR 0 7
47787: PPUSH
47788: LD_INT 0
47790: PPUSH
47791: LD_INT 4
47793: PPUSH
47794: CALL_OW 272
47798: PUSH
47799: LD_VAR 0 8
47803: PPUSH
47804: LD_INT 0
47806: PPUSH
47807: LD_INT 4
47809: PPUSH
47810: CALL_OW 273
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_VAR 0 7
47823: PPUSH
47824: LD_INT 1
47826: PPUSH
47827: LD_INT 4
47829: PPUSH
47830: CALL_OW 272
47834: PUSH
47835: LD_VAR 0 8
47839: PPUSH
47840: LD_INT 1
47842: PPUSH
47843: LD_INT 4
47845: PPUSH
47846: CALL_OW 273
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_VAR 0 7
47859: PPUSH
47860: LD_INT 2
47862: PPUSH
47863: LD_INT 4
47865: PPUSH
47866: CALL_OW 272
47870: PUSH
47871: LD_VAR 0 8
47875: PPUSH
47876: LD_INT 2
47878: PPUSH
47879: LD_INT 4
47881: PPUSH
47882: CALL_OW 273
47886: PUSH
47887: EMPTY
47888: LIST
47889: LIST
47890: PUSH
47891: LD_VAR 0 7
47895: PPUSH
47896: LD_INT 3
47898: PPUSH
47899: LD_INT 4
47901: PPUSH
47902: CALL_OW 272
47906: PUSH
47907: LD_VAR 0 8
47911: PPUSH
47912: LD_INT 3
47914: PPUSH
47915: LD_INT 4
47917: PPUSH
47918: CALL_OW 273
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_VAR 0 7
47931: PPUSH
47932: LD_INT 4
47934: PPUSH
47935: LD_INT 4
47937: PPUSH
47938: CALL_OW 272
47942: PUSH
47943: LD_VAR 0 8
47947: PPUSH
47948: LD_INT 4
47950: PPUSH
47951: LD_INT 4
47953: PPUSH
47954: CALL_OW 273
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: LD_VAR 0 7
47967: PPUSH
47968: LD_INT 5
47970: PPUSH
47971: LD_INT 4
47973: PPUSH
47974: CALL_OW 272
47978: PUSH
47979: LD_VAR 0 8
47983: PPUSH
47984: LD_INT 5
47986: PPUSH
47987: LD_INT 4
47989: PPUSH
47990: CALL_OW 273
47994: PUSH
47995: EMPTY
47996: LIST
47997: LIST
47998: PUSH
47999: EMPTY
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: ST_TO_ADDR
// for i = tmp downto 1 do
48007: LD_ADDR_VAR 0 4
48011: PUSH
48012: DOUBLE
48013: LD_VAR 0 6
48017: INC
48018: ST_TO_ADDR
48019: LD_INT 1
48021: PUSH
48022: FOR_DOWNTO
48023: IFFALSE 48124
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48025: LD_VAR 0 6
48029: PUSH
48030: LD_VAR 0 4
48034: ARRAY
48035: PUSH
48036: LD_INT 1
48038: ARRAY
48039: PPUSH
48040: LD_VAR 0 6
48044: PUSH
48045: LD_VAR 0 4
48049: ARRAY
48050: PUSH
48051: LD_INT 2
48053: ARRAY
48054: PPUSH
48055: CALL_OW 488
48059: NOT
48060: PUSH
48061: LD_VAR 0 6
48065: PUSH
48066: LD_VAR 0 4
48070: ARRAY
48071: PUSH
48072: LD_INT 1
48074: ARRAY
48075: PPUSH
48076: LD_VAR 0 6
48080: PUSH
48081: LD_VAR 0 4
48085: ARRAY
48086: PUSH
48087: LD_INT 2
48089: ARRAY
48090: PPUSH
48091: CALL_OW 428
48095: PUSH
48096: LD_INT 0
48098: NONEQUAL
48099: OR
48100: IFFALSE 48122
// tmp := Delete ( tmp , i ) ;
48102: LD_ADDR_VAR 0 6
48106: PUSH
48107: LD_VAR 0 6
48111: PPUSH
48112: LD_VAR 0 4
48116: PPUSH
48117: CALL_OW 3
48121: ST_TO_ADDR
48122: GO 48022
48124: POP
48125: POP
// j := GetClosestHex ( unit , tmp ) ;
48126: LD_ADDR_VAR 0 5
48130: PUSH
48131: LD_VAR 0 1
48135: PPUSH
48136: LD_VAR 0 6
48140: PPUSH
48141: CALL 47426 0 2
48145: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48146: LD_VAR 0 1
48150: PPUSH
48151: LD_VAR 0 5
48155: PUSH
48156: LD_INT 1
48158: ARRAY
48159: PPUSH
48160: LD_VAR 0 5
48164: PUSH
48165: LD_INT 2
48167: ARRAY
48168: PPUSH
48169: CALL_OW 111
// end ;
48173: LD_VAR 0 3
48177: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48178: LD_INT 0
48180: PPUSH
48181: PPUSH
48182: PPUSH
// uc_side = 0 ;
48183: LD_ADDR_OWVAR 20
48187: PUSH
48188: LD_INT 0
48190: ST_TO_ADDR
// uc_nation = 0 ;
48191: LD_ADDR_OWVAR 21
48195: PUSH
48196: LD_INT 0
48198: ST_TO_ADDR
// InitHc_All ( ) ;
48199: CALL_OW 584
// InitVc ;
48203: CALL_OW 20
// if mastodonts then
48207: LD_VAR 0 6
48211: IFFALSE 48278
// for i = 1 to mastodonts do
48213: LD_ADDR_VAR 0 11
48217: PUSH
48218: DOUBLE
48219: LD_INT 1
48221: DEC
48222: ST_TO_ADDR
48223: LD_VAR 0 6
48227: PUSH
48228: FOR_TO
48229: IFFALSE 48276
// begin vc_chassis := 31 ;
48231: LD_ADDR_OWVAR 37
48235: PUSH
48236: LD_INT 31
48238: ST_TO_ADDR
// vc_control := control_rider ;
48239: LD_ADDR_OWVAR 38
48243: PUSH
48244: LD_INT 4
48246: ST_TO_ADDR
// animal := CreateVehicle ;
48247: LD_ADDR_VAR 0 12
48251: PUSH
48252: CALL_OW 45
48256: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48257: LD_VAR 0 12
48261: PPUSH
48262: LD_VAR 0 8
48266: PPUSH
48267: LD_INT 0
48269: PPUSH
48270: CALL 50466 0 3
// end ;
48274: GO 48228
48276: POP
48277: POP
// if horses then
48278: LD_VAR 0 5
48282: IFFALSE 48349
// for i = 1 to horses do
48284: LD_ADDR_VAR 0 11
48288: PUSH
48289: DOUBLE
48290: LD_INT 1
48292: DEC
48293: ST_TO_ADDR
48294: LD_VAR 0 5
48298: PUSH
48299: FOR_TO
48300: IFFALSE 48347
// begin hc_class := 21 ;
48302: LD_ADDR_OWVAR 28
48306: PUSH
48307: LD_INT 21
48309: ST_TO_ADDR
// hc_gallery :=  ;
48310: LD_ADDR_OWVAR 33
48314: PUSH
48315: LD_STRING 
48317: ST_TO_ADDR
// animal := CreateHuman ;
48318: LD_ADDR_VAR 0 12
48322: PUSH
48323: CALL_OW 44
48327: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48328: LD_VAR 0 12
48332: PPUSH
48333: LD_VAR 0 8
48337: PPUSH
48338: LD_INT 0
48340: PPUSH
48341: CALL 50466 0 3
// end ;
48345: GO 48299
48347: POP
48348: POP
// if birds then
48349: LD_VAR 0 1
48353: IFFALSE 48420
// for i = 1 to birds do
48355: LD_ADDR_VAR 0 11
48359: PUSH
48360: DOUBLE
48361: LD_INT 1
48363: DEC
48364: ST_TO_ADDR
48365: LD_VAR 0 1
48369: PUSH
48370: FOR_TO
48371: IFFALSE 48418
// begin hc_class = 18 ;
48373: LD_ADDR_OWVAR 28
48377: PUSH
48378: LD_INT 18
48380: ST_TO_ADDR
// hc_gallery =  ;
48381: LD_ADDR_OWVAR 33
48385: PUSH
48386: LD_STRING 
48388: ST_TO_ADDR
// animal := CreateHuman ;
48389: LD_ADDR_VAR 0 12
48393: PUSH
48394: CALL_OW 44
48398: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48399: LD_VAR 0 12
48403: PPUSH
48404: LD_VAR 0 8
48408: PPUSH
48409: LD_INT 0
48411: PPUSH
48412: CALL 50466 0 3
// end ;
48416: GO 48370
48418: POP
48419: POP
// if tigers then
48420: LD_VAR 0 2
48424: IFFALSE 48508
// for i = 1 to tigers do
48426: LD_ADDR_VAR 0 11
48430: PUSH
48431: DOUBLE
48432: LD_INT 1
48434: DEC
48435: ST_TO_ADDR
48436: LD_VAR 0 2
48440: PUSH
48441: FOR_TO
48442: IFFALSE 48506
// begin hc_class = class_tiger ;
48444: LD_ADDR_OWVAR 28
48448: PUSH
48449: LD_INT 14
48451: ST_TO_ADDR
// hc_gallery =  ;
48452: LD_ADDR_OWVAR 33
48456: PUSH
48457: LD_STRING 
48459: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48460: LD_ADDR_OWVAR 35
48464: PUSH
48465: LD_INT 7
48467: NEG
48468: PPUSH
48469: LD_INT 7
48471: PPUSH
48472: CALL_OW 12
48476: ST_TO_ADDR
// animal := CreateHuman ;
48477: LD_ADDR_VAR 0 12
48481: PUSH
48482: CALL_OW 44
48486: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48487: LD_VAR 0 12
48491: PPUSH
48492: LD_VAR 0 8
48496: PPUSH
48497: LD_INT 0
48499: PPUSH
48500: CALL 50466 0 3
// end ;
48504: GO 48441
48506: POP
48507: POP
// if apemans then
48508: LD_VAR 0 3
48512: IFFALSE 48635
// for i = 1 to apemans do
48514: LD_ADDR_VAR 0 11
48518: PUSH
48519: DOUBLE
48520: LD_INT 1
48522: DEC
48523: ST_TO_ADDR
48524: LD_VAR 0 3
48528: PUSH
48529: FOR_TO
48530: IFFALSE 48633
// begin hc_class = class_apeman ;
48532: LD_ADDR_OWVAR 28
48536: PUSH
48537: LD_INT 12
48539: ST_TO_ADDR
// hc_gallery =  ;
48540: LD_ADDR_OWVAR 33
48544: PUSH
48545: LD_STRING 
48547: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48548: LD_ADDR_OWVAR 35
48552: PUSH
48553: LD_INT 2
48555: NEG
48556: PPUSH
48557: LD_INT 2
48559: PPUSH
48560: CALL_OW 12
48564: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48565: LD_ADDR_OWVAR 31
48569: PUSH
48570: LD_INT 1
48572: PPUSH
48573: LD_INT 3
48575: PPUSH
48576: CALL_OW 12
48580: PUSH
48581: LD_INT 1
48583: PPUSH
48584: LD_INT 3
48586: PPUSH
48587: CALL_OW 12
48591: PUSH
48592: LD_INT 0
48594: PUSH
48595: LD_INT 0
48597: PUSH
48598: EMPTY
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: ST_TO_ADDR
// animal := CreateHuman ;
48604: LD_ADDR_VAR 0 12
48608: PUSH
48609: CALL_OW 44
48613: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48614: LD_VAR 0 12
48618: PPUSH
48619: LD_VAR 0 8
48623: PPUSH
48624: LD_INT 0
48626: PPUSH
48627: CALL 50466 0 3
// end ;
48631: GO 48529
48633: POP
48634: POP
// if enchidnas then
48635: LD_VAR 0 4
48639: IFFALSE 48706
// for i = 1 to enchidnas do
48641: LD_ADDR_VAR 0 11
48645: PUSH
48646: DOUBLE
48647: LD_INT 1
48649: DEC
48650: ST_TO_ADDR
48651: LD_VAR 0 4
48655: PUSH
48656: FOR_TO
48657: IFFALSE 48704
// begin hc_class = 13 ;
48659: LD_ADDR_OWVAR 28
48663: PUSH
48664: LD_INT 13
48666: ST_TO_ADDR
// hc_gallery =  ;
48667: LD_ADDR_OWVAR 33
48671: PUSH
48672: LD_STRING 
48674: ST_TO_ADDR
// animal := CreateHuman ;
48675: LD_ADDR_VAR 0 12
48679: PUSH
48680: CALL_OW 44
48684: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48685: LD_VAR 0 12
48689: PPUSH
48690: LD_VAR 0 8
48694: PPUSH
48695: LD_INT 0
48697: PPUSH
48698: CALL 50466 0 3
// end ;
48702: GO 48656
48704: POP
48705: POP
// if fishes then
48706: LD_VAR 0 7
48710: IFFALSE 48777
// for i = 1 to fishes do
48712: LD_ADDR_VAR 0 11
48716: PUSH
48717: DOUBLE
48718: LD_INT 1
48720: DEC
48721: ST_TO_ADDR
48722: LD_VAR 0 7
48726: PUSH
48727: FOR_TO
48728: IFFALSE 48775
// begin hc_class = 20 ;
48730: LD_ADDR_OWVAR 28
48734: PUSH
48735: LD_INT 20
48737: ST_TO_ADDR
// hc_gallery =  ;
48738: LD_ADDR_OWVAR 33
48742: PUSH
48743: LD_STRING 
48745: ST_TO_ADDR
// animal := CreateHuman ;
48746: LD_ADDR_VAR 0 12
48750: PUSH
48751: CALL_OW 44
48755: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48756: LD_VAR 0 12
48760: PPUSH
48761: LD_VAR 0 9
48765: PPUSH
48766: LD_INT 0
48768: PPUSH
48769: CALL 50466 0 3
// end ;
48773: GO 48727
48775: POP
48776: POP
// end ;
48777: LD_VAR 0 10
48781: RET
// export function WantHeal ( sci , unit ) ; begin
48782: LD_INT 0
48784: PPUSH
// if GetTaskList ( sci ) > 0 then
48785: LD_VAR 0 1
48789: PPUSH
48790: CALL_OW 437
48794: PUSH
48795: LD_INT 0
48797: GREATER
48798: IFFALSE 48868
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48800: LD_VAR 0 1
48804: PPUSH
48805: CALL_OW 437
48809: PUSH
48810: LD_INT 1
48812: ARRAY
48813: PUSH
48814: LD_INT 1
48816: ARRAY
48817: PUSH
48818: LD_STRING l
48820: EQUAL
48821: PUSH
48822: LD_VAR 0 1
48826: PPUSH
48827: CALL_OW 437
48831: PUSH
48832: LD_INT 1
48834: ARRAY
48835: PUSH
48836: LD_INT 4
48838: ARRAY
48839: PUSH
48840: LD_VAR 0 2
48844: EQUAL
48845: AND
48846: IFFALSE 48858
// result := true else
48848: LD_ADDR_VAR 0 3
48852: PUSH
48853: LD_INT 1
48855: ST_TO_ADDR
48856: GO 48866
// result := false ;
48858: LD_ADDR_VAR 0 3
48862: PUSH
48863: LD_INT 0
48865: ST_TO_ADDR
// end else
48866: GO 48876
// result := false ;
48868: LD_ADDR_VAR 0 3
48872: PUSH
48873: LD_INT 0
48875: ST_TO_ADDR
// end ;
48876: LD_VAR 0 3
48880: RET
// export function HealTarget ( sci ) ; begin
48881: LD_INT 0
48883: PPUSH
// if not sci then
48884: LD_VAR 0 1
48888: NOT
48889: IFFALSE 48893
// exit ;
48891: GO 48958
// result := 0 ;
48893: LD_ADDR_VAR 0 2
48897: PUSH
48898: LD_INT 0
48900: ST_TO_ADDR
// if GetTaskList ( sci ) then
48901: LD_VAR 0 1
48905: PPUSH
48906: CALL_OW 437
48910: IFFALSE 48958
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48912: LD_VAR 0 1
48916: PPUSH
48917: CALL_OW 437
48921: PUSH
48922: LD_INT 1
48924: ARRAY
48925: PUSH
48926: LD_INT 1
48928: ARRAY
48929: PUSH
48930: LD_STRING l
48932: EQUAL
48933: IFFALSE 48958
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48935: LD_ADDR_VAR 0 2
48939: PUSH
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 437
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PUSH
48954: LD_INT 4
48956: ARRAY
48957: ST_TO_ADDR
// end ;
48958: LD_VAR 0 2
48962: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48963: LD_INT 0
48965: PPUSH
48966: PPUSH
48967: PPUSH
48968: PPUSH
// if not base_units then
48969: LD_VAR 0 1
48973: NOT
48974: IFFALSE 48978
// exit ;
48976: GO 49065
// result := false ;
48978: LD_ADDR_VAR 0 2
48982: PUSH
48983: LD_INT 0
48985: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48986: LD_ADDR_VAR 0 5
48990: PUSH
48991: LD_VAR 0 1
48995: PPUSH
48996: LD_INT 21
48998: PUSH
48999: LD_INT 3
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: PPUSH
49006: CALL_OW 72
49010: ST_TO_ADDR
// if not tmp then
49011: LD_VAR 0 5
49015: NOT
49016: IFFALSE 49020
// exit ;
49018: GO 49065
// for i in tmp do
49020: LD_ADDR_VAR 0 3
49024: PUSH
49025: LD_VAR 0 5
49029: PUSH
49030: FOR_IN
49031: IFFALSE 49063
// begin result := EnemyInRange ( i , 22 ) ;
49033: LD_ADDR_VAR 0 2
49037: PUSH
49038: LD_VAR 0 3
49042: PPUSH
49043: LD_INT 22
49045: PPUSH
49046: CALL 47301 0 2
49050: ST_TO_ADDR
// if result then
49051: LD_VAR 0 2
49055: IFFALSE 49061
// exit ;
49057: POP
49058: POP
49059: GO 49065
// end ;
49061: GO 49030
49063: POP
49064: POP
// end ;
49065: LD_VAR 0 2
49069: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
49070: LD_INT 0
49072: PPUSH
49073: PPUSH
// if not units then
49074: LD_VAR 0 1
49078: NOT
49079: IFFALSE 49083
// exit ;
49081: GO 49153
// result := [ ] ;
49083: LD_ADDR_VAR 0 3
49087: PUSH
49088: EMPTY
49089: ST_TO_ADDR
// for i in units do
49090: LD_ADDR_VAR 0 4
49094: PUSH
49095: LD_VAR 0 1
49099: PUSH
49100: FOR_IN
49101: IFFALSE 49151
// if GetTag ( i ) = tag then
49103: LD_VAR 0 4
49107: PPUSH
49108: CALL_OW 110
49112: PUSH
49113: LD_VAR 0 2
49117: EQUAL
49118: IFFALSE 49149
// result := Replace ( result , result + 1 , i ) ;
49120: LD_ADDR_VAR 0 3
49124: PUSH
49125: LD_VAR 0 3
49129: PPUSH
49130: LD_VAR 0 3
49134: PUSH
49135: LD_INT 1
49137: PLUS
49138: PPUSH
49139: LD_VAR 0 4
49143: PPUSH
49144: CALL_OW 1
49148: ST_TO_ADDR
49149: GO 49100
49151: POP
49152: POP
// end ;
49153: LD_VAR 0 3
49157: RET
// export function IsDriver ( un ) ; begin
49158: LD_INT 0
49160: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49161: LD_ADDR_VAR 0 2
49165: PUSH
49166: LD_VAR 0 1
49170: PUSH
49171: LD_INT 55
49173: PUSH
49174: EMPTY
49175: LIST
49176: PPUSH
49177: CALL_OW 69
49181: IN
49182: ST_TO_ADDR
// end ;
49183: LD_VAR 0 2
49187: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49188: LD_INT 0
49190: PPUSH
49191: PPUSH
// list := [ ] ;
49192: LD_ADDR_VAR 0 5
49196: PUSH
49197: EMPTY
49198: ST_TO_ADDR
// case d of 0 :
49199: LD_VAR 0 3
49203: PUSH
49204: LD_INT 0
49206: DOUBLE
49207: EQUAL
49208: IFTRUE 49212
49210: GO 49345
49212: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49213: LD_ADDR_VAR 0 5
49217: PUSH
49218: LD_VAR 0 1
49222: PUSH
49223: LD_INT 4
49225: MINUS
49226: PUSH
49227: LD_VAR 0 2
49231: PUSH
49232: LD_INT 4
49234: MINUS
49235: PUSH
49236: LD_INT 2
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: LIST
49243: PUSH
49244: LD_VAR 0 1
49248: PUSH
49249: LD_INT 3
49251: MINUS
49252: PUSH
49253: LD_VAR 0 2
49257: PUSH
49258: LD_INT 1
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: LIST
49265: PUSH
49266: LD_VAR 0 1
49270: PUSH
49271: LD_INT 4
49273: PLUS
49274: PUSH
49275: LD_VAR 0 2
49279: PUSH
49280: LD_INT 4
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: LIST
49287: PUSH
49288: LD_VAR 0 1
49292: PUSH
49293: LD_INT 3
49295: PLUS
49296: PUSH
49297: LD_VAR 0 2
49301: PUSH
49302: LD_INT 3
49304: PLUS
49305: PUSH
49306: LD_INT 5
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: LIST
49313: PUSH
49314: LD_VAR 0 1
49318: PUSH
49319: LD_VAR 0 2
49323: PUSH
49324: LD_INT 4
49326: PLUS
49327: PUSH
49328: LD_INT 0
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: LIST
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: ST_TO_ADDR
// end ; 1 :
49343: GO 50043
49345: LD_INT 1
49347: DOUBLE
49348: EQUAL
49349: IFTRUE 49353
49351: GO 49486
49353: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49354: LD_ADDR_VAR 0 5
49358: PUSH
49359: LD_VAR 0 1
49363: PUSH
49364: LD_VAR 0 2
49368: PUSH
49369: LD_INT 4
49371: MINUS
49372: PUSH
49373: LD_INT 3
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: LIST
49380: PUSH
49381: LD_VAR 0 1
49385: PUSH
49386: LD_INT 3
49388: MINUS
49389: PUSH
49390: LD_VAR 0 2
49394: PUSH
49395: LD_INT 3
49397: MINUS
49398: PUSH
49399: LD_INT 2
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: PUSH
49407: LD_VAR 0 1
49411: PUSH
49412: LD_INT 4
49414: MINUS
49415: PUSH
49416: LD_VAR 0 2
49420: PUSH
49421: LD_INT 1
49423: PUSH
49424: EMPTY
49425: LIST
49426: LIST
49427: LIST
49428: PUSH
49429: LD_VAR 0 1
49433: PUSH
49434: LD_VAR 0 2
49438: PUSH
49439: LD_INT 3
49441: PLUS
49442: PUSH
49443: LD_INT 0
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: LIST
49450: PUSH
49451: LD_VAR 0 1
49455: PUSH
49456: LD_INT 4
49458: PLUS
49459: PUSH
49460: LD_VAR 0 2
49464: PUSH
49465: LD_INT 4
49467: PLUS
49468: PUSH
49469: LD_INT 5
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: LIST
49476: PUSH
49477: EMPTY
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: ST_TO_ADDR
// end ; 2 :
49484: GO 50043
49486: LD_INT 2
49488: DOUBLE
49489: EQUAL
49490: IFTRUE 49494
49492: GO 49623
49494: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49495: LD_ADDR_VAR 0 5
49499: PUSH
49500: LD_VAR 0 1
49504: PUSH
49505: LD_VAR 0 2
49509: PUSH
49510: LD_INT 3
49512: MINUS
49513: PUSH
49514: LD_INT 3
49516: PUSH
49517: EMPTY
49518: LIST
49519: LIST
49520: LIST
49521: PUSH
49522: LD_VAR 0 1
49526: PUSH
49527: LD_INT 4
49529: PLUS
49530: PUSH
49531: LD_VAR 0 2
49535: PUSH
49536: LD_INT 4
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: LIST
49543: PUSH
49544: LD_VAR 0 1
49548: PUSH
49549: LD_VAR 0 2
49553: PUSH
49554: LD_INT 4
49556: PLUS
49557: PUSH
49558: LD_INT 0
49560: PUSH
49561: EMPTY
49562: LIST
49563: LIST
49564: LIST
49565: PUSH
49566: LD_VAR 0 1
49570: PUSH
49571: LD_INT 3
49573: MINUS
49574: PUSH
49575: LD_VAR 0 2
49579: PUSH
49580: LD_INT 1
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: LIST
49587: PUSH
49588: LD_VAR 0 1
49592: PUSH
49593: LD_INT 4
49595: MINUS
49596: PUSH
49597: LD_VAR 0 2
49601: PUSH
49602: LD_INT 4
49604: MINUS
49605: PUSH
49606: LD_INT 2
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: LIST
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: ST_TO_ADDR
// end ; 3 :
49621: GO 50043
49623: LD_INT 3
49625: DOUBLE
49626: EQUAL
49627: IFTRUE 49631
49629: GO 49764
49631: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49632: LD_ADDR_VAR 0 5
49636: PUSH
49637: LD_VAR 0 1
49641: PUSH
49642: LD_INT 3
49644: PLUS
49645: PUSH
49646: LD_VAR 0 2
49650: PUSH
49651: LD_INT 4
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: LIST
49658: PUSH
49659: LD_VAR 0 1
49663: PUSH
49664: LD_INT 4
49666: PLUS
49667: PUSH
49668: LD_VAR 0 2
49672: PUSH
49673: LD_INT 4
49675: PLUS
49676: PUSH
49677: LD_INT 5
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: PUSH
49685: LD_VAR 0 1
49689: PUSH
49690: LD_INT 4
49692: MINUS
49693: PUSH
49694: LD_VAR 0 2
49698: PUSH
49699: LD_INT 1
49701: PUSH
49702: EMPTY
49703: LIST
49704: LIST
49705: LIST
49706: PUSH
49707: LD_VAR 0 1
49711: PUSH
49712: LD_VAR 0 2
49716: PUSH
49717: LD_INT 4
49719: MINUS
49720: PUSH
49721: LD_INT 3
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: LIST
49728: PUSH
49729: LD_VAR 0 1
49733: PUSH
49734: LD_INT 3
49736: MINUS
49737: PUSH
49738: LD_VAR 0 2
49742: PUSH
49743: LD_INT 3
49745: MINUS
49746: PUSH
49747: LD_INT 2
49749: PUSH
49750: EMPTY
49751: LIST
49752: LIST
49753: LIST
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: ST_TO_ADDR
// end ; 4 :
49762: GO 50043
49764: LD_INT 4
49766: DOUBLE
49767: EQUAL
49768: IFTRUE 49772
49770: GO 49905
49772: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49773: LD_ADDR_VAR 0 5
49777: PUSH
49778: LD_VAR 0 1
49782: PUSH
49783: LD_VAR 0 2
49787: PUSH
49788: LD_INT 4
49790: PLUS
49791: PUSH
49792: LD_INT 0
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: LIST
49799: PUSH
49800: LD_VAR 0 1
49804: PUSH
49805: LD_INT 3
49807: PLUS
49808: PUSH
49809: LD_VAR 0 2
49813: PUSH
49814: LD_INT 3
49816: PLUS
49817: PUSH
49818: LD_INT 5
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: LIST
49825: PUSH
49826: LD_VAR 0 1
49830: PUSH
49831: LD_INT 4
49833: PLUS
49834: PUSH
49835: LD_VAR 0 2
49839: PUSH
49840: LD_INT 4
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: LIST
49847: PUSH
49848: LD_VAR 0 1
49852: PUSH
49853: LD_VAR 0 2
49857: PUSH
49858: LD_INT 3
49860: MINUS
49861: PUSH
49862: LD_INT 3
49864: PUSH
49865: EMPTY
49866: LIST
49867: LIST
49868: LIST
49869: PUSH
49870: LD_VAR 0 1
49874: PUSH
49875: LD_INT 4
49877: MINUS
49878: PUSH
49879: LD_VAR 0 2
49883: PUSH
49884: LD_INT 4
49886: MINUS
49887: PUSH
49888: LD_INT 2
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: LIST
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: ST_TO_ADDR
// end ; 5 :
49903: GO 50043
49905: LD_INT 5
49907: DOUBLE
49908: EQUAL
49909: IFTRUE 49913
49911: GO 50042
49913: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49914: LD_ADDR_VAR 0 5
49918: PUSH
49919: LD_VAR 0 1
49923: PUSH
49924: LD_INT 4
49926: MINUS
49927: PUSH
49928: LD_VAR 0 2
49932: PUSH
49933: LD_INT 1
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: LIST
49940: PUSH
49941: LD_VAR 0 1
49945: PUSH
49946: LD_VAR 0 2
49950: PUSH
49951: LD_INT 4
49953: MINUS
49954: PUSH
49955: LD_INT 3
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: LIST
49962: PUSH
49963: LD_VAR 0 1
49967: PUSH
49968: LD_INT 4
49970: PLUS
49971: PUSH
49972: LD_VAR 0 2
49976: PUSH
49977: LD_INT 4
49979: PLUS
49980: PUSH
49981: LD_INT 5
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: LIST
49988: PUSH
49989: LD_VAR 0 1
49993: PUSH
49994: LD_INT 3
49996: PLUS
49997: PUSH
49998: LD_VAR 0 2
50002: PUSH
50003: LD_INT 4
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: LIST
50010: PUSH
50011: LD_VAR 0 1
50015: PUSH
50016: LD_VAR 0 2
50020: PUSH
50021: LD_INT 3
50023: PLUS
50024: PUSH
50025: LD_INT 0
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: LIST
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: ST_TO_ADDR
// end ; end ;
50040: GO 50043
50042: POP
// result := list ;
50043: LD_ADDR_VAR 0 4
50047: PUSH
50048: LD_VAR 0 5
50052: ST_TO_ADDR
// end ;
50053: LD_VAR 0 4
50057: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50058: LD_INT 0
50060: PPUSH
50061: PPUSH
50062: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50063: LD_VAR 0 1
50067: NOT
50068: PUSH
50069: LD_VAR 0 2
50073: PUSH
50074: LD_INT 1
50076: PUSH
50077: LD_INT 2
50079: PUSH
50080: LD_INT 3
50082: PUSH
50083: LD_INT 4
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: LIST
50090: LIST
50091: IN
50092: NOT
50093: OR
50094: IFFALSE 50098
// exit ;
50096: GO 50190
// tmp := [ ] ;
50098: LD_ADDR_VAR 0 5
50102: PUSH
50103: EMPTY
50104: ST_TO_ADDR
// for i in units do
50105: LD_ADDR_VAR 0 4
50109: PUSH
50110: LD_VAR 0 1
50114: PUSH
50115: FOR_IN
50116: IFFALSE 50159
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50118: LD_ADDR_VAR 0 5
50122: PUSH
50123: LD_VAR 0 5
50127: PPUSH
50128: LD_VAR 0 5
50132: PUSH
50133: LD_INT 1
50135: PLUS
50136: PPUSH
50137: LD_VAR 0 4
50141: PPUSH
50142: LD_VAR 0 2
50146: PPUSH
50147: CALL_OW 259
50151: PPUSH
50152: CALL_OW 2
50156: ST_TO_ADDR
50157: GO 50115
50159: POP
50160: POP
// if not tmp then
50161: LD_VAR 0 5
50165: NOT
50166: IFFALSE 50170
// exit ;
50168: GO 50190
// result := SortListByListDesc ( units , tmp ) ;
50170: LD_ADDR_VAR 0 3
50174: PUSH
50175: LD_VAR 0 1
50179: PPUSH
50180: LD_VAR 0 5
50184: PPUSH
50185: CALL_OW 77
50189: ST_TO_ADDR
// end ;
50190: LD_VAR 0 3
50194: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50195: LD_INT 0
50197: PPUSH
50198: PPUSH
50199: PPUSH
// result := false ;
50200: LD_ADDR_VAR 0 3
50204: PUSH
50205: LD_INT 0
50207: ST_TO_ADDR
// x := GetX ( building ) ;
50208: LD_ADDR_VAR 0 4
50212: PUSH
50213: LD_VAR 0 2
50217: PPUSH
50218: CALL_OW 250
50222: ST_TO_ADDR
// y := GetY ( building ) ;
50223: LD_ADDR_VAR 0 5
50227: PUSH
50228: LD_VAR 0 2
50232: PPUSH
50233: CALL_OW 251
50237: ST_TO_ADDR
// if not building or not x or not y then
50238: LD_VAR 0 2
50242: NOT
50243: PUSH
50244: LD_VAR 0 4
50248: NOT
50249: OR
50250: PUSH
50251: LD_VAR 0 5
50255: NOT
50256: OR
50257: IFFALSE 50261
// exit ;
50259: GO 50353
// if GetTaskList ( unit ) then
50261: LD_VAR 0 1
50265: PPUSH
50266: CALL_OW 437
50270: IFFALSE 50353
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50272: LD_STRING e
50274: PUSH
50275: LD_VAR 0 1
50279: PPUSH
50280: CALL_OW 437
50284: PUSH
50285: LD_INT 1
50287: ARRAY
50288: PUSH
50289: LD_INT 1
50291: ARRAY
50292: EQUAL
50293: PUSH
50294: LD_VAR 0 4
50298: PUSH
50299: LD_VAR 0 1
50303: PPUSH
50304: CALL_OW 437
50308: PUSH
50309: LD_INT 1
50311: ARRAY
50312: PUSH
50313: LD_INT 2
50315: ARRAY
50316: EQUAL
50317: AND
50318: PUSH
50319: LD_VAR 0 5
50323: PUSH
50324: LD_VAR 0 1
50328: PPUSH
50329: CALL_OW 437
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 3
50340: ARRAY
50341: EQUAL
50342: AND
50343: IFFALSE 50353
// result := true end ;
50345: LD_ADDR_VAR 0 3
50349: PUSH
50350: LD_INT 1
50352: ST_TO_ADDR
// end ;
50353: LD_VAR 0 3
50357: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50358: LD_INT 0
50360: PPUSH
// result := false ;
50361: LD_ADDR_VAR 0 4
50365: PUSH
50366: LD_INT 0
50368: ST_TO_ADDR
// if GetTaskList ( unit ) then
50369: LD_VAR 0 1
50373: PPUSH
50374: CALL_OW 437
50378: IFFALSE 50461
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50380: LD_STRING M
50382: PUSH
50383: LD_VAR 0 1
50387: PPUSH
50388: CALL_OW 437
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: EQUAL
50401: PUSH
50402: LD_VAR 0 2
50406: PUSH
50407: LD_VAR 0 1
50411: PPUSH
50412: CALL_OW 437
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_INT 2
50423: ARRAY
50424: EQUAL
50425: AND
50426: PUSH
50427: LD_VAR 0 3
50431: PUSH
50432: LD_VAR 0 1
50436: PPUSH
50437: CALL_OW 437
50441: PUSH
50442: LD_INT 1
50444: ARRAY
50445: PUSH
50446: LD_INT 3
50448: ARRAY
50449: EQUAL
50450: AND
50451: IFFALSE 50461
// result := true ;
50453: LD_ADDR_VAR 0 4
50457: PUSH
50458: LD_INT 1
50460: ST_TO_ADDR
// end ; end ;
50461: LD_VAR 0 4
50465: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50466: LD_INT 0
50468: PPUSH
50469: PPUSH
50470: PPUSH
50471: PPUSH
// if not unit or not area then
50472: LD_VAR 0 1
50476: NOT
50477: PUSH
50478: LD_VAR 0 2
50482: NOT
50483: OR
50484: IFFALSE 50488
// exit ;
50486: GO 50652
// tmp := AreaToList ( area , i ) ;
50488: LD_ADDR_VAR 0 6
50492: PUSH
50493: LD_VAR 0 2
50497: PPUSH
50498: LD_VAR 0 5
50502: PPUSH
50503: CALL_OW 517
50507: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50508: LD_ADDR_VAR 0 5
50512: PUSH
50513: DOUBLE
50514: LD_INT 1
50516: DEC
50517: ST_TO_ADDR
50518: LD_VAR 0 6
50522: PUSH
50523: LD_INT 1
50525: ARRAY
50526: PUSH
50527: FOR_TO
50528: IFFALSE 50650
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50530: LD_ADDR_VAR 0 7
50534: PUSH
50535: LD_VAR 0 6
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PUSH
50544: LD_VAR 0 5
50548: ARRAY
50549: PUSH
50550: LD_VAR 0 6
50554: PUSH
50555: LD_INT 2
50557: ARRAY
50558: PUSH
50559: LD_VAR 0 5
50563: ARRAY
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50569: LD_VAR 0 7
50573: PUSH
50574: LD_INT 1
50576: ARRAY
50577: PPUSH
50578: LD_VAR 0 7
50582: PUSH
50583: LD_INT 2
50585: ARRAY
50586: PPUSH
50587: CALL_OW 428
50591: PUSH
50592: LD_INT 0
50594: EQUAL
50595: IFFALSE 50648
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50597: LD_VAR 0 1
50601: PPUSH
50602: LD_VAR 0 7
50606: PUSH
50607: LD_INT 1
50609: ARRAY
50610: PPUSH
50611: LD_VAR 0 7
50615: PUSH
50616: LD_INT 2
50618: ARRAY
50619: PPUSH
50620: LD_VAR 0 3
50624: PPUSH
50625: CALL_OW 48
// result := IsPlaced ( unit ) ;
50629: LD_ADDR_VAR 0 4
50633: PUSH
50634: LD_VAR 0 1
50638: PPUSH
50639: CALL_OW 305
50643: ST_TO_ADDR
// exit ;
50644: POP
50645: POP
50646: GO 50652
// end ; end ;
50648: GO 50527
50650: POP
50651: POP
// end ;
50652: LD_VAR 0 4
50656: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50657: LD_INT 0
50659: PPUSH
50660: PPUSH
50661: PPUSH
// if not side or side > 8 then
50662: LD_VAR 0 1
50666: NOT
50667: PUSH
50668: LD_VAR 0 1
50672: PUSH
50673: LD_INT 8
50675: GREATER
50676: OR
50677: IFFALSE 50681
// exit ;
50679: GO 50868
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50681: LD_ADDR_VAR 0 4
50685: PUSH
50686: LD_INT 22
50688: PUSH
50689: LD_VAR 0 1
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 21
50700: PUSH
50701: LD_INT 3
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: PPUSH
50712: CALL_OW 69
50716: ST_TO_ADDR
// if not tmp then
50717: LD_VAR 0 4
50721: NOT
50722: IFFALSE 50726
// exit ;
50724: GO 50868
// enable_addtolog := true ;
50726: LD_ADDR_OWVAR 81
50730: PUSH
50731: LD_INT 1
50733: ST_TO_ADDR
// AddToLog ( [ ) ;
50734: LD_STRING [
50736: PPUSH
50737: CALL_OW 561
// for i in tmp do
50741: LD_ADDR_VAR 0 3
50745: PUSH
50746: LD_VAR 0 4
50750: PUSH
50751: FOR_IN
50752: IFFALSE 50859
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50754: LD_STRING [
50756: PUSH
50757: LD_VAR 0 3
50761: PPUSH
50762: CALL_OW 266
50766: STR
50767: PUSH
50768: LD_STRING , 
50770: STR
50771: PUSH
50772: LD_VAR 0 3
50776: PPUSH
50777: CALL_OW 250
50781: STR
50782: PUSH
50783: LD_STRING , 
50785: STR
50786: PUSH
50787: LD_VAR 0 3
50791: PPUSH
50792: CALL_OW 251
50796: STR
50797: PUSH
50798: LD_STRING , 
50800: STR
50801: PUSH
50802: LD_VAR 0 3
50806: PPUSH
50807: CALL_OW 254
50811: STR
50812: PUSH
50813: LD_STRING , 
50815: STR
50816: PUSH
50817: LD_VAR 0 3
50821: PPUSH
50822: LD_INT 1
50824: PPUSH
50825: CALL_OW 268
50829: STR
50830: PUSH
50831: LD_STRING , 
50833: STR
50834: PUSH
50835: LD_VAR 0 3
50839: PPUSH
50840: LD_INT 2
50842: PPUSH
50843: CALL_OW 268
50847: STR
50848: PUSH
50849: LD_STRING ],
50851: STR
50852: PPUSH
50853: CALL_OW 561
// end ;
50857: GO 50751
50859: POP
50860: POP
// AddToLog ( ]; ) ;
50861: LD_STRING ];
50863: PPUSH
50864: CALL_OW 561
// end ;
50868: LD_VAR 0 2
50872: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50873: LD_INT 0
50875: PPUSH
50876: PPUSH
50877: PPUSH
50878: PPUSH
50879: PPUSH
// if not area or not rate or not max then
50880: LD_VAR 0 1
50884: NOT
50885: PUSH
50886: LD_VAR 0 2
50890: NOT
50891: OR
50892: PUSH
50893: LD_VAR 0 4
50897: NOT
50898: OR
50899: IFFALSE 50903
// exit ;
50901: GO 51095
// while 1 do
50903: LD_INT 1
50905: IFFALSE 51095
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50907: LD_ADDR_VAR 0 9
50911: PUSH
50912: LD_VAR 0 1
50916: PPUSH
50917: LD_INT 1
50919: PPUSH
50920: CALL_OW 287
50924: PUSH
50925: LD_INT 10
50927: MUL
50928: ST_TO_ADDR
// r := rate / 10 ;
50929: LD_ADDR_VAR 0 7
50933: PUSH
50934: LD_VAR 0 2
50938: PUSH
50939: LD_INT 10
50941: DIVREAL
50942: ST_TO_ADDR
// time := 1 1$00 ;
50943: LD_ADDR_VAR 0 8
50947: PUSH
50948: LD_INT 2100
50950: ST_TO_ADDR
// if amount < min then
50951: LD_VAR 0 9
50955: PUSH
50956: LD_VAR 0 3
50960: LESS
50961: IFFALSE 50979
// r := r * 2 else
50963: LD_ADDR_VAR 0 7
50967: PUSH
50968: LD_VAR 0 7
50972: PUSH
50973: LD_INT 2
50975: MUL
50976: ST_TO_ADDR
50977: GO 51005
// if amount > max then
50979: LD_VAR 0 9
50983: PUSH
50984: LD_VAR 0 4
50988: GREATER
50989: IFFALSE 51005
// r := r / 2 ;
50991: LD_ADDR_VAR 0 7
50995: PUSH
50996: LD_VAR 0 7
51000: PUSH
51001: LD_INT 2
51003: DIVREAL
51004: ST_TO_ADDR
// time := time / r ;
51005: LD_ADDR_VAR 0 8
51009: PUSH
51010: LD_VAR 0 8
51014: PUSH
51015: LD_VAR 0 7
51019: DIVREAL
51020: ST_TO_ADDR
// if time < 0 then
51021: LD_VAR 0 8
51025: PUSH
51026: LD_INT 0
51028: LESS
51029: IFFALSE 51046
// time := time * - 1 ;
51031: LD_ADDR_VAR 0 8
51035: PUSH
51036: LD_VAR 0 8
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: MUL
51045: ST_TO_ADDR
// wait ( time ) ;
51046: LD_VAR 0 8
51050: PPUSH
51051: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
51055: LD_INT 35
51057: PPUSH
51058: LD_INT 875
51060: PPUSH
51061: CALL_OW 12
51065: PPUSH
51066: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51070: LD_INT 1
51072: PPUSH
51073: LD_INT 5
51075: PPUSH
51076: CALL_OW 12
51080: PPUSH
51081: LD_VAR 0 1
51085: PPUSH
51086: LD_INT 1
51088: PPUSH
51089: CALL_OW 55
// end ;
51093: GO 50903
// end ;
51095: LD_VAR 0 5
51099: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51100: LD_INT 0
51102: PPUSH
51103: PPUSH
51104: PPUSH
51105: PPUSH
51106: PPUSH
51107: PPUSH
51108: PPUSH
51109: PPUSH
// if not turrets or not factories then
51110: LD_VAR 0 1
51114: NOT
51115: PUSH
51116: LD_VAR 0 2
51120: NOT
51121: OR
51122: IFFALSE 51126
// exit ;
51124: GO 51433
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51126: LD_ADDR_VAR 0 10
51130: PUSH
51131: LD_INT 5
51133: PUSH
51134: LD_INT 6
51136: PUSH
51137: EMPTY
51138: LIST
51139: LIST
51140: PUSH
51141: LD_INT 2
51143: PUSH
51144: LD_INT 4
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: PUSH
51151: LD_INT 3
51153: PUSH
51154: LD_INT 5
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: LIST
51165: PUSH
51166: LD_INT 24
51168: PUSH
51169: LD_INT 25
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PUSH
51176: LD_INT 23
51178: PUSH
51179: LD_INT 27
51181: PUSH
51182: EMPTY
51183: LIST
51184: LIST
51185: PUSH
51186: EMPTY
51187: LIST
51188: LIST
51189: PUSH
51190: LD_INT 42
51192: PUSH
51193: LD_INT 43
51195: PUSH
51196: EMPTY
51197: LIST
51198: LIST
51199: PUSH
51200: LD_INT 44
51202: PUSH
51203: LD_INT 46
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: LD_INT 45
51212: PUSH
51213: LD_INT 47
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: LIST
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: LIST
51229: ST_TO_ADDR
// result := [ ] ;
51230: LD_ADDR_VAR 0 3
51234: PUSH
51235: EMPTY
51236: ST_TO_ADDR
// for i in turrets do
51237: LD_ADDR_VAR 0 4
51241: PUSH
51242: LD_VAR 0 1
51246: PUSH
51247: FOR_IN
51248: IFFALSE 51431
// begin nat := GetNation ( i ) ;
51250: LD_ADDR_VAR 0 7
51254: PUSH
51255: LD_VAR 0 4
51259: PPUSH
51260: CALL_OW 248
51264: ST_TO_ADDR
// weapon := 0 ;
51265: LD_ADDR_VAR 0 8
51269: PUSH
51270: LD_INT 0
51272: ST_TO_ADDR
// if not nat then
51273: LD_VAR 0 7
51277: NOT
51278: IFFALSE 51282
// continue ;
51280: GO 51247
// for j in list [ nat ] do
51282: LD_ADDR_VAR 0 5
51286: PUSH
51287: LD_VAR 0 10
51291: PUSH
51292: LD_VAR 0 7
51296: ARRAY
51297: PUSH
51298: FOR_IN
51299: IFFALSE 51340
// if GetBWeapon ( i ) = j [ 1 ] then
51301: LD_VAR 0 4
51305: PPUSH
51306: CALL_OW 269
51310: PUSH
51311: LD_VAR 0 5
51315: PUSH
51316: LD_INT 1
51318: ARRAY
51319: EQUAL
51320: IFFALSE 51338
// begin weapon := j [ 2 ] ;
51322: LD_ADDR_VAR 0 8
51326: PUSH
51327: LD_VAR 0 5
51331: PUSH
51332: LD_INT 2
51334: ARRAY
51335: ST_TO_ADDR
// break ;
51336: GO 51340
// end ;
51338: GO 51298
51340: POP
51341: POP
// if not weapon then
51342: LD_VAR 0 8
51346: NOT
51347: IFFALSE 51351
// continue ;
51349: GO 51247
// for k in factories do
51351: LD_ADDR_VAR 0 6
51355: PUSH
51356: LD_VAR 0 2
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51427
// begin weapons := AvailableWeaponList ( k ) ;
51364: LD_ADDR_VAR 0 9
51368: PUSH
51369: LD_VAR 0 6
51373: PPUSH
51374: CALL_OW 478
51378: ST_TO_ADDR
// if not weapons then
51379: LD_VAR 0 9
51383: NOT
51384: IFFALSE 51388
// continue ;
51386: GO 51361
// if weapon in weapons then
51388: LD_VAR 0 8
51392: PUSH
51393: LD_VAR 0 9
51397: IN
51398: IFFALSE 51425
// begin result := [ i , weapon ] ;
51400: LD_ADDR_VAR 0 3
51404: PUSH
51405: LD_VAR 0 4
51409: PUSH
51410: LD_VAR 0 8
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: ST_TO_ADDR
// exit ;
51419: POP
51420: POP
51421: POP
51422: POP
51423: GO 51433
// end ; end ;
51425: GO 51361
51427: POP
51428: POP
// end ;
51429: GO 51247
51431: POP
51432: POP
// end ;
51433: LD_VAR 0 3
51437: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51438: LD_INT 0
51440: PPUSH
// if not side or side > 8 then
51441: LD_VAR 0 3
51445: NOT
51446: PUSH
51447: LD_VAR 0 3
51451: PUSH
51452: LD_INT 8
51454: GREATER
51455: OR
51456: IFFALSE 51460
// exit ;
51458: GO 51519
// if not range then
51460: LD_VAR 0 4
51464: NOT
51465: IFFALSE 51476
// range := - 12 ;
51467: LD_ADDR_VAR 0 4
51471: PUSH
51472: LD_INT 12
51474: NEG
51475: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51476: LD_VAR 0 1
51480: PPUSH
51481: LD_VAR 0 2
51485: PPUSH
51486: LD_VAR 0 3
51490: PPUSH
51491: LD_VAR 0 4
51495: PPUSH
51496: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51500: LD_VAR 0 1
51504: PPUSH
51505: LD_VAR 0 2
51509: PPUSH
51510: LD_VAR 0 3
51514: PPUSH
51515: CALL_OW 331
// end ;
51519: LD_VAR 0 5
51523: RET
// export function Video ( mode ) ; begin
51524: LD_INT 0
51526: PPUSH
// ingame_video = mode ;
51527: LD_ADDR_OWVAR 52
51531: PUSH
51532: LD_VAR 0 1
51536: ST_TO_ADDR
// interface_hidden = mode ;
51537: LD_ADDR_OWVAR 54
51541: PUSH
51542: LD_VAR 0 1
51546: ST_TO_ADDR
// end ;
51547: LD_VAR 0 2
51551: RET
// export function Join ( array , element ) ; begin
51552: LD_INT 0
51554: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51555: LD_ADDR_VAR 0 3
51559: PUSH
51560: LD_VAR 0 1
51564: PPUSH
51565: LD_VAR 0 1
51569: PUSH
51570: LD_INT 1
51572: PLUS
51573: PPUSH
51574: LD_VAR 0 2
51578: PPUSH
51579: CALL_OW 1
51583: ST_TO_ADDR
// end ;
51584: LD_VAR 0 3
51588: RET
// export function JoinUnion ( array , element ) ; begin
51589: LD_INT 0
51591: PPUSH
// result := array union element ;
51592: LD_ADDR_VAR 0 3
51596: PUSH
51597: LD_VAR 0 1
51601: PUSH
51602: LD_VAR 0 2
51606: UNION
51607: ST_TO_ADDR
// end ;
51608: LD_VAR 0 3
51612: RET
// export function GetBehemoths ( side ) ; begin
51613: LD_INT 0
51615: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_INT 22
51623: PUSH
51624: LD_VAR 0 1
51628: PUSH
51629: EMPTY
51630: LIST
51631: LIST
51632: PUSH
51633: LD_INT 31
51635: PUSH
51636: LD_INT 25
51638: PUSH
51639: EMPTY
51640: LIST
51641: LIST
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: PPUSH
51647: CALL_OW 69
51651: ST_TO_ADDR
// end ;
51652: LD_VAR 0 2
51656: RET
// export function Shuffle ( array ) ; var i , index ; begin
51657: LD_INT 0
51659: PPUSH
51660: PPUSH
51661: PPUSH
// result := [ ] ;
51662: LD_ADDR_VAR 0 2
51666: PUSH
51667: EMPTY
51668: ST_TO_ADDR
// if not array then
51669: LD_VAR 0 1
51673: NOT
51674: IFFALSE 51678
// exit ;
51676: GO 51777
// Randomize ;
51678: CALL_OW 10
// for i = array downto 1 do
51682: LD_ADDR_VAR 0 3
51686: PUSH
51687: DOUBLE
51688: LD_VAR 0 1
51692: INC
51693: ST_TO_ADDR
51694: LD_INT 1
51696: PUSH
51697: FOR_DOWNTO
51698: IFFALSE 51775
// begin index := rand ( 1 , array ) ;
51700: LD_ADDR_VAR 0 4
51704: PUSH
51705: LD_INT 1
51707: PPUSH
51708: LD_VAR 0 1
51712: PPUSH
51713: CALL_OW 12
51717: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51718: LD_ADDR_VAR 0 2
51722: PUSH
51723: LD_VAR 0 2
51727: PPUSH
51728: LD_VAR 0 2
51732: PUSH
51733: LD_INT 1
51735: PLUS
51736: PPUSH
51737: LD_VAR 0 1
51741: PUSH
51742: LD_VAR 0 4
51746: ARRAY
51747: PPUSH
51748: CALL_OW 2
51752: ST_TO_ADDR
// array := Delete ( array , index ) ;
51753: LD_ADDR_VAR 0 1
51757: PUSH
51758: LD_VAR 0 1
51762: PPUSH
51763: LD_VAR 0 4
51767: PPUSH
51768: CALL_OW 3
51772: ST_TO_ADDR
// end ;
51773: GO 51697
51775: POP
51776: POP
// end ;
51777: LD_VAR 0 2
51781: RET
// export function GetBaseMaterials ( base ) ; begin
51782: LD_INT 0
51784: PPUSH
// result := [ 0 , 0 , 0 ] ;
51785: LD_ADDR_VAR 0 2
51789: PUSH
51790: LD_INT 0
51792: PUSH
51793: LD_INT 0
51795: PUSH
51796: LD_INT 0
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: LIST
51803: ST_TO_ADDR
// if not base then
51804: LD_VAR 0 1
51808: NOT
51809: IFFALSE 51813
// exit ;
51811: GO 51862
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51813: LD_ADDR_VAR 0 2
51817: PUSH
51818: LD_VAR 0 1
51822: PPUSH
51823: LD_INT 1
51825: PPUSH
51826: CALL_OW 275
51830: PUSH
51831: LD_VAR 0 1
51835: PPUSH
51836: LD_INT 2
51838: PPUSH
51839: CALL_OW 275
51843: PUSH
51844: LD_VAR 0 1
51848: PPUSH
51849: LD_INT 3
51851: PPUSH
51852: CALL_OW 275
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: LIST
51861: ST_TO_ADDR
// end ;
51862: LD_VAR 0 2
51866: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51867: LD_INT 0
51869: PPUSH
51870: PPUSH
// result := array ;
51871: LD_ADDR_VAR 0 3
51875: PUSH
51876: LD_VAR 0 1
51880: ST_TO_ADDR
// if size > 0 then
51881: LD_VAR 0 2
51885: PUSH
51886: LD_INT 0
51888: GREATER
51889: IFFALSE 51935
// for i := array downto size do
51891: LD_ADDR_VAR 0 4
51895: PUSH
51896: DOUBLE
51897: LD_VAR 0 1
51901: INC
51902: ST_TO_ADDR
51903: LD_VAR 0 2
51907: PUSH
51908: FOR_DOWNTO
51909: IFFALSE 51933
// result := Delete ( result , result ) ;
51911: LD_ADDR_VAR 0 3
51915: PUSH
51916: LD_VAR 0 3
51920: PPUSH
51921: LD_VAR 0 3
51925: PPUSH
51926: CALL_OW 3
51930: ST_TO_ADDR
51931: GO 51908
51933: POP
51934: POP
// end ;
51935: LD_VAR 0 3
51939: RET
// export function ComExit ( unit ) ; var tmp ; begin
51940: LD_INT 0
51942: PPUSH
51943: PPUSH
// if not IsInUnit ( unit ) then
51944: LD_VAR 0 1
51948: PPUSH
51949: CALL_OW 310
51953: NOT
51954: IFFALSE 51958
// exit ;
51956: GO 52018
// tmp := IsInUnit ( unit ) ;
51958: LD_ADDR_VAR 0 3
51962: PUSH
51963: LD_VAR 0 1
51967: PPUSH
51968: CALL_OW 310
51972: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51973: LD_VAR 0 3
51977: PPUSH
51978: CALL_OW 247
51982: PUSH
51983: LD_INT 2
51985: EQUAL
51986: IFFALSE 51999
// ComExitVehicle ( unit ) else
51988: LD_VAR 0 1
51992: PPUSH
51993: CALL_OW 121
51997: GO 52008
// ComExitBuilding ( unit ) ;
51999: LD_VAR 0 1
52003: PPUSH
52004: CALL_OW 122
// result := tmp ;
52008: LD_ADDR_VAR 0 2
52012: PUSH
52013: LD_VAR 0 3
52017: ST_TO_ADDR
// end ;
52018: LD_VAR 0 2
52022: RET
// export function ComExitAll ( units ) ; var i ; begin
52023: LD_INT 0
52025: PPUSH
52026: PPUSH
// if not units then
52027: LD_VAR 0 1
52031: NOT
52032: IFFALSE 52036
// exit ;
52034: GO 52062
// for i in units do
52036: LD_ADDR_VAR 0 3
52040: PUSH
52041: LD_VAR 0 1
52045: PUSH
52046: FOR_IN
52047: IFFALSE 52060
// ComExit ( i ) ;
52049: LD_VAR 0 3
52053: PPUSH
52054: CALL 51940 0 1
52058: GO 52046
52060: POP
52061: POP
// end ;
52062: LD_VAR 0 2
52066: RET
// export function ResetHc ; begin
52067: LD_INT 0
52069: PPUSH
// InitHc ;
52070: CALL_OW 19
// hc_importance := 0 ;
52074: LD_ADDR_OWVAR 32
52078: PUSH
52079: LD_INT 0
52081: ST_TO_ADDR
// end ;
52082: LD_VAR 0 1
52086: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52087: LD_INT 0
52089: PPUSH
52090: PPUSH
52091: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52092: LD_ADDR_VAR 0 6
52096: PUSH
52097: LD_VAR 0 1
52101: PUSH
52102: LD_VAR 0 3
52106: PLUS
52107: PUSH
52108: LD_INT 2
52110: DIV
52111: ST_TO_ADDR
// if _x < 0 then
52112: LD_VAR 0 6
52116: PUSH
52117: LD_INT 0
52119: LESS
52120: IFFALSE 52137
// _x := _x * - 1 ;
52122: LD_ADDR_VAR 0 6
52126: PUSH
52127: LD_VAR 0 6
52131: PUSH
52132: LD_INT 1
52134: NEG
52135: MUL
52136: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52137: LD_ADDR_VAR 0 7
52141: PUSH
52142: LD_VAR 0 2
52146: PUSH
52147: LD_VAR 0 4
52151: PLUS
52152: PUSH
52153: LD_INT 2
52155: DIV
52156: ST_TO_ADDR
// if _y < 0 then
52157: LD_VAR 0 7
52161: PUSH
52162: LD_INT 0
52164: LESS
52165: IFFALSE 52182
// _y := _y * - 1 ;
52167: LD_ADDR_VAR 0 7
52171: PUSH
52172: LD_VAR 0 7
52176: PUSH
52177: LD_INT 1
52179: NEG
52180: MUL
52181: ST_TO_ADDR
// result := [ _x , _y ] ;
52182: LD_ADDR_VAR 0 5
52186: PUSH
52187: LD_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: ST_TO_ADDR
// end ;
52201: LD_VAR 0 5
52205: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52206: LD_INT 0
52208: PPUSH
52209: PPUSH
52210: PPUSH
52211: PPUSH
// task := GetTaskList ( unit ) ;
52212: LD_ADDR_VAR 0 7
52216: PUSH
52217: LD_VAR 0 1
52221: PPUSH
52222: CALL_OW 437
52226: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52227: LD_VAR 0 7
52231: NOT
52232: PUSH
52233: LD_VAR 0 1
52237: PPUSH
52238: LD_VAR 0 2
52242: PPUSH
52243: CALL_OW 308
52247: NOT
52248: AND
52249: IFFALSE 52253
// exit ;
52251: GO 52371
// if IsInArea ( unit , area ) then
52253: LD_VAR 0 1
52257: PPUSH
52258: LD_VAR 0 2
52262: PPUSH
52263: CALL_OW 308
52267: IFFALSE 52285
// begin ComMoveToArea ( unit , goAway ) ;
52269: LD_VAR 0 1
52273: PPUSH
52274: LD_VAR 0 3
52278: PPUSH
52279: CALL_OW 113
// exit ;
52283: GO 52371
// end ; if task [ 1 ] [ 1 ] <> M then
52285: LD_VAR 0 7
52289: PUSH
52290: LD_INT 1
52292: ARRAY
52293: PUSH
52294: LD_INT 1
52296: ARRAY
52297: PUSH
52298: LD_STRING M
52300: NONEQUAL
52301: IFFALSE 52305
// exit ;
52303: GO 52371
// x := task [ 1 ] [ 2 ] ;
52305: LD_ADDR_VAR 0 5
52309: PUSH
52310: LD_VAR 0 7
52314: PUSH
52315: LD_INT 1
52317: ARRAY
52318: PUSH
52319: LD_INT 2
52321: ARRAY
52322: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52323: LD_ADDR_VAR 0 6
52327: PUSH
52328: LD_VAR 0 7
52332: PUSH
52333: LD_INT 1
52335: ARRAY
52336: PUSH
52337: LD_INT 3
52339: ARRAY
52340: ST_TO_ADDR
// if InArea ( x , y , area ) then
52341: LD_VAR 0 5
52345: PPUSH
52346: LD_VAR 0 6
52350: PPUSH
52351: LD_VAR 0 2
52355: PPUSH
52356: CALL_OW 309
52360: IFFALSE 52371
// ComStop ( unit ) ;
52362: LD_VAR 0 1
52366: PPUSH
52367: CALL_OW 141
// end ;
52371: LD_VAR 0 4
52375: RET
// export function Abs ( value ) ; begin
52376: LD_INT 0
52378: PPUSH
// result := value ;
52379: LD_ADDR_VAR 0 2
52383: PUSH
52384: LD_VAR 0 1
52388: ST_TO_ADDR
// if value < 0 then
52389: LD_VAR 0 1
52393: PUSH
52394: LD_INT 0
52396: LESS
52397: IFFALSE 52414
// result := value * - 1 ;
52399: LD_ADDR_VAR 0 2
52403: PUSH
52404: LD_VAR 0 1
52408: PUSH
52409: LD_INT 1
52411: NEG
52412: MUL
52413: ST_TO_ADDR
// end ;
52414: LD_VAR 0 2
52418: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52419: LD_INT 0
52421: PPUSH
52422: PPUSH
52423: PPUSH
52424: PPUSH
52425: PPUSH
52426: PPUSH
52427: PPUSH
52428: PPUSH
// if not unit or not building then
52429: LD_VAR 0 1
52433: NOT
52434: PUSH
52435: LD_VAR 0 2
52439: NOT
52440: OR
52441: IFFALSE 52445
// exit ;
52443: GO 52671
// x := GetX ( building ) ;
52445: LD_ADDR_VAR 0 4
52449: PUSH
52450: LD_VAR 0 2
52454: PPUSH
52455: CALL_OW 250
52459: ST_TO_ADDR
// y := GetY ( building ) ;
52460: LD_ADDR_VAR 0 6
52464: PUSH
52465: LD_VAR 0 2
52469: PPUSH
52470: CALL_OW 251
52474: ST_TO_ADDR
// d := GetDir ( building ) ;
52475: LD_ADDR_VAR 0 8
52479: PUSH
52480: LD_VAR 0 2
52484: PPUSH
52485: CALL_OW 254
52489: ST_TO_ADDR
// r := 4 ;
52490: LD_ADDR_VAR 0 9
52494: PUSH
52495: LD_INT 4
52497: ST_TO_ADDR
// for i := 1 to 5 do
52498: LD_ADDR_VAR 0 10
52502: PUSH
52503: DOUBLE
52504: LD_INT 1
52506: DEC
52507: ST_TO_ADDR
52508: LD_INT 5
52510: PUSH
52511: FOR_TO
52512: IFFALSE 52669
// begin _x := ShiftX ( x , d , r + i ) ;
52514: LD_ADDR_VAR 0 5
52518: PUSH
52519: LD_VAR 0 4
52523: PPUSH
52524: LD_VAR 0 8
52528: PPUSH
52529: LD_VAR 0 9
52533: PUSH
52534: LD_VAR 0 10
52538: PLUS
52539: PPUSH
52540: CALL_OW 272
52544: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52545: LD_ADDR_VAR 0 7
52549: PUSH
52550: LD_VAR 0 6
52554: PPUSH
52555: LD_VAR 0 8
52559: PPUSH
52560: LD_VAR 0 9
52564: PUSH
52565: LD_VAR 0 10
52569: PLUS
52570: PPUSH
52571: CALL_OW 273
52575: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52576: LD_VAR 0 5
52580: PPUSH
52581: LD_VAR 0 7
52585: PPUSH
52586: CALL_OW 488
52590: PUSH
52591: LD_VAR 0 5
52595: PPUSH
52596: LD_VAR 0 7
52600: PPUSH
52601: CALL_OW 428
52605: PPUSH
52606: CALL_OW 247
52610: PUSH
52611: LD_INT 3
52613: PUSH
52614: LD_INT 2
52616: PUSH
52617: EMPTY
52618: LIST
52619: LIST
52620: IN
52621: NOT
52622: AND
52623: IFFALSE 52667
// begin ComMoveXY ( unit , _x , _y ) ;
52625: LD_VAR 0 1
52629: PPUSH
52630: LD_VAR 0 5
52634: PPUSH
52635: LD_VAR 0 7
52639: PPUSH
52640: CALL_OW 111
// result := [ _x , _y ] ;
52644: LD_ADDR_VAR 0 3
52648: PUSH
52649: LD_VAR 0 5
52653: PUSH
52654: LD_VAR 0 7
52658: PUSH
52659: EMPTY
52660: LIST
52661: LIST
52662: ST_TO_ADDR
// exit ;
52663: POP
52664: POP
52665: GO 52671
// end ; end ;
52667: GO 52511
52669: POP
52670: POP
// end ;
52671: LD_VAR 0 3
52675: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52676: LD_INT 0
52678: PPUSH
52679: PPUSH
52680: PPUSH
// result := 0 ;
52681: LD_ADDR_VAR 0 3
52685: PUSH
52686: LD_INT 0
52688: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52689: LD_VAR 0 1
52693: PUSH
52694: LD_INT 0
52696: LESS
52697: PUSH
52698: LD_VAR 0 1
52702: PUSH
52703: LD_INT 8
52705: GREATER
52706: OR
52707: PUSH
52708: LD_VAR 0 2
52712: PUSH
52713: LD_INT 0
52715: LESS
52716: OR
52717: PUSH
52718: LD_VAR 0 2
52722: PUSH
52723: LD_INT 8
52725: GREATER
52726: OR
52727: IFFALSE 52731
// exit ;
52729: GO 52806
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52731: LD_ADDR_VAR 0 4
52735: PUSH
52736: LD_INT 22
52738: PUSH
52739: LD_VAR 0 2
52743: PUSH
52744: EMPTY
52745: LIST
52746: LIST
52747: PPUSH
52748: CALL_OW 69
52752: PUSH
52753: FOR_IN
52754: IFFALSE 52804
// begin un := UnitShoot ( i ) ;
52756: LD_ADDR_VAR 0 5
52760: PUSH
52761: LD_VAR 0 4
52765: PPUSH
52766: CALL_OW 504
52770: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52771: LD_VAR 0 5
52775: PPUSH
52776: CALL_OW 255
52780: PUSH
52781: LD_VAR 0 1
52785: EQUAL
52786: IFFALSE 52802
// begin result := un ;
52788: LD_ADDR_VAR 0 3
52792: PUSH
52793: LD_VAR 0 5
52797: ST_TO_ADDR
// exit ;
52798: POP
52799: POP
52800: GO 52806
// end ; end ;
52802: GO 52753
52804: POP
52805: POP
// end ;
52806: LD_VAR 0 3
52810: RET
// export function GetCargoBay ( units ) ; begin
52811: LD_INT 0
52813: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52814: LD_ADDR_VAR 0 2
52818: PUSH
52819: LD_VAR 0 1
52823: PPUSH
52824: LD_INT 2
52826: PUSH
52827: LD_INT 34
52829: PUSH
52830: LD_INT 12
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: PUSH
52837: LD_INT 34
52839: PUSH
52840: LD_INT 51
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: PUSH
52847: LD_INT 34
52849: PUSH
52850: LD_INT 32
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: PUSH
52857: LD_INT 34
52859: PUSH
52860: LD_EXP 105
52864: PUSH
52865: EMPTY
52866: LIST
52867: LIST
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: LIST
52873: LIST
52874: LIST
52875: PPUSH
52876: CALL_OW 72
52880: ST_TO_ADDR
// end ;
52881: LD_VAR 0 2
52885: RET
// export function Negate ( value ) ; begin
52886: LD_INT 0
52888: PPUSH
// result := not value ;
52889: LD_ADDR_VAR 0 2
52893: PUSH
52894: LD_VAR 0 1
52898: NOT
52899: ST_TO_ADDR
// end ;
52900: LD_VAR 0 2
52904: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
52905: LD_INT 0
52907: PPUSH
// if x1 = x2 then
52908: LD_VAR 0 1
52912: PUSH
52913: LD_VAR 0 3
52917: EQUAL
52918: IFFALSE 52952
// begin if y1 > y2 then
52920: LD_VAR 0 2
52924: PUSH
52925: LD_VAR 0 4
52929: GREATER
52930: IFFALSE 52942
// result := 0 else
52932: LD_ADDR_VAR 0 5
52936: PUSH
52937: LD_INT 0
52939: ST_TO_ADDR
52940: GO 52950
// result := 3 ;
52942: LD_ADDR_VAR 0 5
52946: PUSH
52947: LD_INT 3
52949: ST_TO_ADDR
// exit ;
52950: GO 53038
// end ; if y1 = y2 then
52952: LD_VAR 0 2
52956: PUSH
52957: LD_VAR 0 4
52961: EQUAL
52962: IFFALSE 52996
// begin if x1 > x2 then
52964: LD_VAR 0 1
52968: PUSH
52969: LD_VAR 0 3
52973: GREATER
52974: IFFALSE 52986
// result := 1 else
52976: LD_ADDR_VAR 0 5
52980: PUSH
52981: LD_INT 1
52983: ST_TO_ADDR
52984: GO 52994
// result := 4 ;
52986: LD_ADDR_VAR 0 5
52990: PUSH
52991: LD_INT 4
52993: ST_TO_ADDR
// exit ;
52994: GO 53038
// end ; if x1 > x2 and y1 > y2 then
52996: LD_VAR 0 1
53000: PUSH
53001: LD_VAR 0 3
53005: GREATER
53006: PUSH
53007: LD_VAR 0 2
53011: PUSH
53012: LD_VAR 0 4
53016: GREATER
53017: AND
53018: IFFALSE 53030
// result := 2 else
53020: LD_ADDR_VAR 0 5
53024: PUSH
53025: LD_INT 2
53027: ST_TO_ADDR
53028: GO 53038
// result := 5 ;
53030: LD_ADDR_VAR 0 5
53034: PUSH
53035: LD_INT 5
53037: ST_TO_ADDR
// end ;
53038: LD_VAR 0 5
53042: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53043: LD_INT 0
53045: PPUSH
53046: PPUSH
// if not driver or not IsInUnit ( driver ) then
53047: LD_VAR 0 1
53051: NOT
53052: PUSH
53053: LD_VAR 0 1
53057: PPUSH
53058: CALL_OW 310
53062: NOT
53063: OR
53064: IFFALSE 53068
// exit ;
53066: GO 53158
// vehicle := IsInUnit ( driver ) ;
53068: LD_ADDR_VAR 0 3
53072: PUSH
53073: LD_VAR 0 1
53077: PPUSH
53078: CALL_OW 310
53082: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53083: LD_VAR 0 1
53087: PPUSH
53088: LD_STRING \
53090: PUSH
53091: LD_INT 0
53093: PUSH
53094: LD_INT 0
53096: PUSH
53097: LD_INT 0
53099: PUSH
53100: LD_INT 0
53102: PUSH
53103: LD_INT 0
53105: PUSH
53106: LD_INT 0
53108: PUSH
53109: EMPTY
53110: LIST
53111: LIST
53112: LIST
53113: LIST
53114: LIST
53115: LIST
53116: LIST
53117: PUSH
53118: LD_STRING E
53120: PUSH
53121: LD_INT 0
53123: PUSH
53124: LD_INT 0
53126: PUSH
53127: LD_VAR 0 3
53131: PUSH
53132: LD_INT 0
53134: PUSH
53135: LD_INT 0
53137: PUSH
53138: LD_INT 0
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: LIST
53145: LIST
53146: LIST
53147: LIST
53148: LIST
53149: PUSH
53150: EMPTY
53151: LIST
53152: LIST
53153: PPUSH
53154: CALL_OW 446
// end ;
53158: LD_VAR 0 2
53162: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53163: LD_INT 0
53165: PPUSH
53166: PPUSH
// if not driver or not IsInUnit ( driver ) then
53167: LD_VAR 0 1
53171: NOT
53172: PUSH
53173: LD_VAR 0 1
53177: PPUSH
53178: CALL_OW 310
53182: NOT
53183: OR
53184: IFFALSE 53188
// exit ;
53186: GO 53278
// vehicle := IsInUnit ( driver ) ;
53188: LD_ADDR_VAR 0 3
53192: PUSH
53193: LD_VAR 0 1
53197: PPUSH
53198: CALL_OW 310
53202: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53203: LD_VAR 0 1
53207: PPUSH
53208: LD_STRING \
53210: PUSH
53211: LD_INT 0
53213: PUSH
53214: LD_INT 0
53216: PUSH
53217: LD_INT 0
53219: PUSH
53220: LD_INT 0
53222: PUSH
53223: LD_INT 0
53225: PUSH
53226: LD_INT 0
53228: PUSH
53229: EMPTY
53230: LIST
53231: LIST
53232: LIST
53233: LIST
53234: LIST
53235: LIST
53236: LIST
53237: PUSH
53238: LD_STRING E
53240: PUSH
53241: LD_INT 0
53243: PUSH
53244: LD_INT 0
53246: PUSH
53247: LD_VAR 0 3
53251: PUSH
53252: LD_INT 0
53254: PUSH
53255: LD_INT 0
53257: PUSH
53258: LD_INT 0
53260: PUSH
53261: EMPTY
53262: LIST
53263: LIST
53264: LIST
53265: LIST
53266: LIST
53267: LIST
53268: LIST
53269: PUSH
53270: EMPTY
53271: LIST
53272: LIST
53273: PPUSH
53274: CALL_OW 447
// end ;
53278: LD_VAR 0 2
53282: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53283: LD_INT 0
53285: PPUSH
53286: PPUSH
53287: PPUSH
// tmp := [ ] ;
53288: LD_ADDR_VAR 0 5
53292: PUSH
53293: EMPTY
53294: ST_TO_ADDR
// for i in units do
53295: LD_ADDR_VAR 0 4
53299: PUSH
53300: LD_VAR 0 1
53304: PUSH
53305: FOR_IN
53306: IFFALSE 53344
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53308: LD_ADDR_VAR 0 5
53312: PUSH
53313: LD_VAR 0 5
53317: PPUSH
53318: LD_VAR 0 5
53322: PUSH
53323: LD_INT 1
53325: PLUS
53326: PPUSH
53327: LD_VAR 0 4
53331: PPUSH
53332: CALL_OW 256
53336: PPUSH
53337: CALL_OW 2
53341: ST_TO_ADDR
53342: GO 53305
53344: POP
53345: POP
// if not tmp then
53346: LD_VAR 0 5
53350: NOT
53351: IFFALSE 53355
// exit ;
53353: GO 53403
// if asc then
53355: LD_VAR 0 2
53359: IFFALSE 53383
// result := SortListByListAsc ( units , tmp ) else
53361: LD_ADDR_VAR 0 3
53365: PUSH
53366: LD_VAR 0 1
53370: PPUSH
53371: LD_VAR 0 5
53375: PPUSH
53376: CALL_OW 76
53380: ST_TO_ADDR
53381: GO 53403
// result := SortListByListDesc ( units , tmp ) ;
53383: LD_ADDR_VAR 0 3
53387: PUSH
53388: LD_VAR 0 1
53392: PPUSH
53393: LD_VAR 0 5
53397: PPUSH
53398: CALL_OW 77
53402: ST_TO_ADDR
// end ;
53403: LD_VAR 0 3
53407: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53408: LD_INT 0
53410: PPUSH
53411: PPUSH
// task := GetTaskList ( mech ) ;
53412: LD_ADDR_VAR 0 4
53416: PUSH
53417: LD_VAR 0 1
53421: PPUSH
53422: CALL_OW 437
53426: ST_TO_ADDR
// if not task then
53427: LD_VAR 0 4
53431: NOT
53432: IFFALSE 53436
// exit ;
53434: GO 53478
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53436: LD_ADDR_VAR 0 3
53440: PUSH
53441: LD_VAR 0 4
53445: PUSH
53446: LD_INT 1
53448: ARRAY
53449: PUSH
53450: LD_INT 1
53452: ARRAY
53453: PUSH
53454: LD_STRING r
53456: EQUAL
53457: PUSH
53458: LD_VAR 0 4
53462: PUSH
53463: LD_INT 1
53465: ARRAY
53466: PUSH
53467: LD_INT 4
53469: ARRAY
53470: PUSH
53471: LD_VAR 0 2
53475: EQUAL
53476: AND
53477: ST_TO_ADDR
// end ;
53478: LD_VAR 0 3
53482: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53483: LD_INT 0
53485: PPUSH
// SetDir ( unit , d ) ;
53486: LD_VAR 0 1
53490: PPUSH
53491: LD_VAR 0 4
53495: PPUSH
53496: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53500: LD_VAR 0 1
53504: PPUSH
53505: LD_VAR 0 2
53509: PPUSH
53510: LD_VAR 0 3
53514: PPUSH
53515: LD_VAR 0 5
53519: PPUSH
53520: CALL_OW 48
// end ;
53524: LD_VAR 0 6
53528: RET
// export function ToNaturalNumber ( number ) ; begin
53529: LD_INT 0
53531: PPUSH
// result := number div 1 ;
53532: LD_ADDR_VAR 0 2
53536: PUSH
53537: LD_VAR 0 1
53541: PUSH
53542: LD_INT 1
53544: DIV
53545: ST_TO_ADDR
// if number < 0 then
53546: LD_VAR 0 1
53550: PUSH
53551: LD_INT 0
53553: LESS
53554: IFFALSE 53564
// result := 0 ;
53556: LD_ADDR_VAR 0 2
53560: PUSH
53561: LD_INT 0
53563: ST_TO_ADDR
// end ;
53564: LD_VAR 0 2
53568: RET
// export function SortByClass ( units , class ) ; var un ; begin
53569: LD_INT 0
53571: PPUSH
53572: PPUSH
// if not units or not class then
53573: LD_VAR 0 1
53577: NOT
53578: PUSH
53579: LD_VAR 0 2
53583: NOT
53584: OR
53585: IFFALSE 53589
// exit ;
53587: GO 53684
// result := [ ] ;
53589: LD_ADDR_VAR 0 3
53593: PUSH
53594: EMPTY
53595: ST_TO_ADDR
// for un in units do
53596: LD_ADDR_VAR 0 4
53600: PUSH
53601: LD_VAR 0 1
53605: PUSH
53606: FOR_IN
53607: IFFALSE 53682
// if GetClass ( un ) = class then
53609: LD_VAR 0 4
53613: PPUSH
53614: CALL_OW 257
53618: PUSH
53619: LD_VAR 0 2
53623: EQUAL
53624: IFFALSE 53651
// result := Insert ( result , 1 , un ) else
53626: LD_ADDR_VAR 0 3
53630: PUSH
53631: LD_VAR 0 3
53635: PPUSH
53636: LD_INT 1
53638: PPUSH
53639: LD_VAR 0 4
53643: PPUSH
53644: CALL_OW 2
53648: ST_TO_ADDR
53649: GO 53680
// result := Replace ( result , result + 1 , un ) ;
53651: LD_ADDR_VAR 0 3
53655: PUSH
53656: LD_VAR 0 3
53660: PPUSH
53661: LD_VAR 0 3
53665: PUSH
53666: LD_INT 1
53668: PLUS
53669: PPUSH
53670: LD_VAR 0 4
53674: PPUSH
53675: CALL_OW 1
53679: ST_TO_ADDR
53680: GO 53606
53682: POP
53683: POP
// end ;
53684: LD_VAR 0 3
53688: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53689: LD_INT 0
53691: PPUSH
53692: PPUSH
53693: PPUSH
53694: PPUSH
53695: PPUSH
53696: PPUSH
53697: PPUSH
// result := [ ] ;
53698: LD_ADDR_VAR 0 4
53702: PUSH
53703: EMPTY
53704: ST_TO_ADDR
// if x - r < 0 then
53705: LD_VAR 0 1
53709: PUSH
53710: LD_VAR 0 3
53714: MINUS
53715: PUSH
53716: LD_INT 0
53718: LESS
53719: IFFALSE 53731
// min_x := 0 else
53721: LD_ADDR_VAR 0 8
53725: PUSH
53726: LD_INT 0
53728: ST_TO_ADDR
53729: GO 53747
// min_x := x - r ;
53731: LD_ADDR_VAR 0 8
53735: PUSH
53736: LD_VAR 0 1
53740: PUSH
53741: LD_VAR 0 3
53745: MINUS
53746: ST_TO_ADDR
// if y - r < 0 then
53747: LD_VAR 0 2
53751: PUSH
53752: LD_VAR 0 3
53756: MINUS
53757: PUSH
53758: LD_INT 0
53760: LESS
53761: IFFALSE 53773
// min_y := 0 else
53763: LD_ADDR_VAR 0 7
53767: PUSH
53768: LD_INT 0
53770: ST_TO_ADDR
53771: GO 53789
// min_y := y - r ;
53773: LD_ADDR_VAR 0 7
53777: PUSH
53778: LD_VAR 0 2
53782: PUSH
53783: LD_VAR 0 3
53787: MINUS
53788: ST_TO_ADDR
// max_x := x + r ;
53789: LD_ADDR_VAR 0 9
53793: PUSH
53794: LD_VAR 0 1
53798: PUSH
53799: LD_VAR 0 3
53803: PLUS
53804: ST_TO_ADDR
// max_y := y + r ;
53805: LD_ADDR_VAR 0 10
53809: PUSH
53810: LD_VAR 0 2
53814: PUSH
53815: LD_VAR 0 3
53819: PLUS
53820: ST_TO_ADDR
// for _x = min_x to max_x do
53821: LD_ADDR_VAR 0 5
53825: PUSH
53826: DOUBLE
53827: LD_VAR 0 8
53831: DEC
53832: ST_TO_ADDR
53833: LD_VAR 0 9
53837: PUSH
53838: FOR_TO
53839: IFFALSE 53940
// for _y = min_y to max_y do
53841: LD_ADDR_VAR 0 6
53845: PUSH
53846: DOUBLE
53847: LD_VAR 0 7
53851: DEC
53852: ST_TO_ADDR
53853: LD_VAR 0 10
53857: PUSH
53858: FOR_TO
53859: IFFALSE 53936
// begin if not ValidHex ( _x , _y ) then
53861: LD_VAR 0 5
53865: PPUSH
53866: LD_VAR 0 6
53870: PPUSH
53871: CALL_OW 488
53875: NOT
53876: IFFALSE 53880
// continue ;
53878: GO 53858
// if GetResourceTypeXY ( _x , _y ) then
53880: LD_VAR 0 5
53884: PPUSH
53885: LD_VAR 0 6
53889: PPUSH
53890: CALL_OW 283
53894: IFFALSE 53934
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
53896: LD_ADDR_VAR 0 4
53900: PUSH
53901: LD_VAR 0 4
53905: PPUSH
53906: LD_VAR 0 4
53910: PUSH
53911: LD_INT 1
53913: PLUS
53914: PPUSH
53915: LD_VAR 0 5
53919: PUSH
53920: LD_VAR 0 6
53924: PUSH
53925: EMPTY
53926: LIST
53927: LIST
53928: PPUSH
53929: CALL_OW 1
53933: ST_TO_ADDR
// end ;
53934: GO 53858
53936: POP
53937: POP
53938: GO 53838
53940: POP
53941: POP
// end ;
53942: LD_VAR 0 4
53946: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , cr , side , tag ; begin
53947: LD_INT 0
53949: PPUSH
53950: PPUSH
53951: PPUSH
53952: PPUSH
53953: PPUSH
53954: PPUSH
// if not units then
53955: LD_VAR 0 1
53959: NOT
53960: IFFALSE 53964
// exit ;
53962: GO 54365
// result := UnitFilter ( units , [ f_ok ] ) ;
53964: LD_ADDR_VAR 0 3
53968: PUSH
53969: LD_VAR 0 1
53973: PPUSH
53974: LD_INT 50
53976: PUSH
53977: EMPTY
53978: LIST
53979: PPUSH
53980: CALL_OW 72
53984: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
53985: LD_ADDR_VAR 0 7
53989: PUSH
53990: LD_VAR 0 1
53994: PUSH
53995: LD_INT 1
53997: ARRAY
53998: PPUSH
53999: CALL_OW 255
54003: ST_TO_ADDR
// if not result then
54004: LD_VAR 0 3
54008: NOT
54009: IFFALSE 54013
// exit ;
54011: GO 54365
// for i in result do
54013: LD_ADDR_VAR 0 4
54017: PUSH
54018: LD_VAR 0 3
54022: PUSH
54023: FOR_IN
54024: IFFALSE 54363
// begin tag := GetTag ( i ) + 1 ;
54026: LD_ADDR_VAR 0 8
54030: PUSH
54031: LD_VAR 0 4
54035: PPUSH
54036: CALL_OW 110
54040: PUSH
54041: LD_INT 1
54043: PLUS
54044: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54045: LD_ADDR_VAR 0 6
54049: PUSH
54050: LD_VAR 0 4
54054: PPUSH
54055: CALL_OW 250
54059: PPUSH
54060: LD_VAR 0 4
54064: PPUSH
54065: CALL_OW 251
54069: PPUSH
54070: LD_INT 6
54072: PPUSH
54073: CALL 53689 0 3
54077: ST_TO_ADDR
// if cr then
54078: LD_VAR 0 6
54082: IFFALSE 54121
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
54084: LD_VAR 0 4
54088: PPUSH
54089: LD_VAR 0 6
54093: PUSH
54094: LD_INT 1
54096: ARRAY
54097: PUSH
54098: LD_INT 1
54100: ARRAY
54101: PPUSH
54102: LD_VAR 0 6
54106: PUSH
54107: LD_INT 1
54109: ARRAY
54110: PUSH
54111: LD_INT 2
54113: ARRAY
54114: PPUSH
54115: CALL_OW 116
54119: GO 54361
// if path > tag then
54121: LD_VAR 0 2
54125: PUSH
54126: LD_VAR 0 8
54130: GREATER
54131: IFFALSE 54309
// begin enemy := FilterAllUnits ( [ [ f_enemy , side ] , [ f_dist , i , 12 ] ] ) ;
54133: LD_ADDR_VAR 0 5
54137: PUSH
54138: LD_INT 81
54140: PUSH
54141: LD_VAR 0 7
54145: PUSH
54146: EMPTY
54147: LIST
54148: LIST
54149: PUSH
54150: LD_INT 91
54152: PUSH
54153: LD_VAR 0 4
54157: PUSH
54158: LD_INT 12
54160: PUSH
54161: EMPTY
54162: LIST
54163: LIST
54164: LIST
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: PPUSH
54170: CALL_OW 69
54174: ST_TO_ADDR
// if enemy then
54175: LD_VAR 0 5
54179: IFFALSE 54207
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
54181: LD_VAR 0 4
54185: PPUSH
54186: LD_VAR 0 5
54190: PPUSH
54191: LD_VAR 0 4
54195: PPUSH
54196: CALL_OW 74
54200: PPUSH
54201: CALL_OW 115
54205: GO 54307
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54207: LD_VAR 0 4
54211: PPUSH
54212: LD_VAR 0 2
54216: PUSH
54217: LD_VAR 0 8
54221: ARRAY
54222: PUSH
54223: LD_INT 1
54225: ARRAY
54226: PPUSH
54227: LD_VAR 0 2
54231: PUSH
54232: LD_VAR 0 8
54236: ARRAY
54237: PUSH
54238: LD_INT 2
54240: ARRAY
54241: PPUSH
54242: CALL_OW 297
54246: PUSH
54247: LD_INT 6
54249: GREATER
54250: IFFALSE 54293
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54252: LD_VAR 0 4
54256: PPUSH
54257: LD_VAR 0 2
54261: PUSH
54262: LD_VAR 0 8
54266: ARRAY
54267: PUSH
54268: LD_INT 1
54270: ARRAY
54271: PPUSH
54272: LD_VAR 0 2
54276: PUSH
54277: LD_VAR 0 8
54281: ARRAY
54282: PUSH
54283: LD_INT 2
54285: ARRAY
54286: PPUSH
54287: CALL_OW 114
54291: GO 54307
// SetTag ( i , tag ) ;
54293: LD_VAR 0 4
54297: PPUSH
54298: LD_VAR 0 8
54302: PPUSH
54303: CALL_OW 109
// end else
54307: GO 54361
// begin enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54309: LD_ADDR_VAR 0 5
54313: PUSH
54314: LD_INT 81
54316: PUSH
54317: LD_VAR 0 7
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: PPUSH
54326: CALL_OW 69
54330: ST_TO_ADDR
// if enemy then
54331: LD_VAR 0 5
54335: IFFALSE 54361
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54337: LD_VAR 0 4
54341: PPUSH
54342: LD_VAR 0 5
54346: PPUSH
54347: LD_VAR 0 4
54351: PPUSH
54352: CALL_OW 74
54356: PPUSH
54357: CALL_OW 115
// end ; end ;
54361: GO 54023
54363: POP
54364: POP
// end ; end_of_file
54365: LD_VAR 0 3
54369: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54370: LD_INT 0
54372: PPUSH
54373: PPUSH
// skirmish := false ;
54374: LD_ADDR_EXP 58
54378: PUSH
54379: LD_INT 0
54381: ST_TO_ADDR
// debug_mc := false ;
54382: LD_ADDR_EXP 59
54386: PUSH
54387: LD_INT 0
54389: ST_TO_ADDR
// mc_bases := [ ] ;
54390: LD_ADDR_EXP 60
54394: PUSH
54395: EMPTY
54396: ST_TO_ADDR
// mc_sides := [ ] ;
54397: LD_ADDR_EXP 86
54401: PUSH
54402: EMPTY
54403: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54404: LD_ADDR_EXP 61
54408: PUSH
54409: EMPTY
54410: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54411: LD_ADDR_EXP 62
54415: PUSH
54416: EMPTY
54417: ST_TO_ADDR
// mc_need_heal := [ ] ;
54418: LD_ADDR_EXP 63
54422: PUSH
54423: EMPTY
54424: ST_TO_ADDR
// mc_healers := [ ] ;
54425: LD_ADDR_EXP 64
54429: PUSH
54430: EMPTY
54431: ST_TO_ADDR
// mc_build_list := [ ] ;
54432: LD_ADDR_EXP 65
54436: PUSH
54437: EMPTY
54438: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54439: LD_ADDR_EXP 92
54443: PUSH
54444: EMPTY
54445: ST_TO_ADDR
// mc_builders := [ ] ;
54446: LD_ADDR_EXP 66
54450: PUSH
54451: EMPTY
54452: ST_TO_ADDR
// mc_construct_list := [ ] ;
54453: LD_ADDR_EXP 67
54457: PUSH
54458: EMPTY
54459: ST_TO_ADDR
// mc_turret_list := [ ] ;
54460: LD_ADDR_EXP 68
54464: PUSH
54465: EMPTY
54466: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
54467: LD_ADDR_EXP 69
54471: PUSH
54472: EMPTY
54473: ST_TO_ADDR
// mc_miners := [ ] ;
54474: LD_ADDR_EXP 74
54478: PUSH
54479: EMPTY
54480: ST_TO_ADDR
// mc_mines := [ ] ;
54481: LD_ADDR_EXP 73
54485: PUSH
54486: EMPTY
54487: ST_TO_ADDR
// mc_minefields := [ ] ;
54488: LD_ADDR_EXP 75
54492: PUSH
54493: EMPTY
54494: ST_TO_ADDR
// mc_crates := [ ] ;
54495: LD_ADDR_EXP 76
54499: PUSH
54500: EMPTY
54501: ST_TO_ADDR
// mc_crates_collector := [ ] ;
54502: LD_ADDR_EXP 77
54506: PUSH
54507: EMPTY
54508: ST_TO_ADDR
// mc_crates_area := [ ] ;
54509: LD_ADDR_EXP 78
54513: PUSH
54514: EMPTY
54515: ST_TO_ADDR
// mc_vehicles := [ ] ;
54516: LD_ADDR_EXP 79
54520: PUSH
54521: EMPTY
54522: ST_TO_ADDR
// mc_attack := [ ] ;
54523: LD_ADDR_EXP 80
54527: PUSH
54528: EMPTY
54529: ST_TO_ADDR
// mc_produce := [ ] ;
54530: LD_ADDR_EXP 81
54534: PUSH
54535: EMPTY
54536: ST_TO_ADDR
// mc_defender := [ ] ;
54537: LD_ADDR_EXP 82
54541: PUSH
54542: EMPTY
54543: ST_TO_ADDR
// mc_parking := [ ] ;
54544: LD_ADDR_EXP 84
54548: PUSH
54549: EMPTY
54550: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
54551: LD_ADDR_EXP 70
54555: PUSH
54556: EMPTY
54557: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
54558: LD_ADDR_EXP 72
54562: PUSH
54563: EMPTY
54564: ST_TO_ADDR
// mc_scan := [ ] ;
54565: LD_ADDR_EXP 83
54569: PUSH
54570: EMPTY
54571: ST_TO_ADDR
// mc_scan_area := [ ] ;
54572: LD_ADDR_EXP 85
54576: PUSH
54577: EMPTY
54578: ST_TO_ADDR
// mc_tech := [ ] ;
54579: LD_ADDR_EXP 87
54583: PUSH
54584: EMPTY
54585: ST_TO_ADDR
// mc_class := [ ] ;
54586: LD_ADDR_EXP 101
54590: PUSH
54591: EMPTY
54592: ST_TO_ADDR
// mc_class_case_use := [ ] ;
54593: LD_ADDR_EXP 102
54597: PUSH
54598: EMPTY
54599: ST_TO_ADDR
// mc_is_defending := [ ] ;
54600: LD_ADDR_EXP 103
54604: PUSH
54605: EMPTY
54606: ST_TO_ADDR
// end ;
54607: LD_VAR 0 1
54611: RET
// export function MC_Kill ( base ) ; begin
54612: LD_INT 0
54614: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
54615: LD_ADDR_EXP 60
54619: PUSH
54620: LD_EXP 60
54624: PPUSH
54625: LD_VAR 0 1
54629: PPUSH
54630: EMPTY
54631: PPUSH
54632: CALL_OW 1
54636: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
54637: LD_ADDR_EXP 61
54641: PUSH
54642: LD_EXP 61
54646: PPUSH
54647: LD_VAR 0 1
54651: PPUSH
54652: EMPTY
54653: PPUSH
54654: CALL_OW 1
54658: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
54659: LD_ADDR_EXP 62
54663: PUSH
54664: LD_EXP 62
54668: PPUSH
54669: LD_VAR 0 1
54673: PPUSH
54674: EMPTY
54675: PPUSH
54676: CALL_OW 1
54680: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
54681: LD_ADDR_EXP 63
54685: PUSH
54686: LD_EXP 63
54690: PPUSH
54691: LD_VAR 0 1
54695: PPUSH
54696: EMPTY
54697: PPUSH
54698: CALL_OW 1
54702: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
54703: LD_ADDR_EXP 64
54707: PUSH
54708: LD_EXP 64
54712: PPUSH
54713: LD_VAR 0 1
54717: PPUSH
54718: EMPTY
54719: PPUSH
54720: CALL_OW 1
54724: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
54725: LD_ADDR_EXP 65
54729: PUSH
54730: LD_EXP 65
54734: PPUSH
54735: LD_VAR 0 1
54739: PPUSH
54740: EMPTY
54741: PPUSH
54742: CALL_OW 1
54746: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
54747: LD_ADDR_EXP 66
54751: PUSH
54752: LD_EXP 66
54756: PPUSH
54757: LD_VAR 0 1
54761: PPUSH
54762: EMPTY
54763: PPUSH
54764: CALL_OW 1
54768: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
54769: LD_ADDR_EXP 67
54773: PUSH
54774: LD_EXP 67
54778: PPUSH
54779: LD_VAR 0 1
54783: PPUSH
54784: EMPTY
54785: PPUSH
54786: CALL_OW 1
54790: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
54791: LD_ADDR_EXP 68
54795: PUSH
54796: LD_EXP 68
54800: PPUSH
54801: LD_VAR 0 1
54805: PPUSH
54806: EMPTY
54807: PPUSH
54808: CALL_OW 1
54812: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
54813: LD_ADDR_EXP 69
54817: PUSH
54818: LD_EXP 69
54822: PPUSH
54823: LD_VAR 0 1
54827: PPUSH
54828: EMPTY
54829: PPUSH
54830: CALL_OW 1
54834: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
54835: LD_ADDR_EXP 70
54839: PUSH
54840: LD_EXP 70
54844: PPUSH
54845: LD_VAR 0 1
54849: PPUSH
54850: EMPTY
54851: PPUSH
54852: CALL_OW 1
54856: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
54857: LD_ADDR_EXP 71
54861: PUSH
54862: LD_EXP 71
54866: PPUSH
54867: LD_VAR 0 1
54871: PPUSH
54872: LD_INT 0
54874: PPUSH
54875: CALL_OW 1
54879: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
54880: LD_ADDR_EXP 72
54884: PUSH
54885: LD_EXP 72
54889: PPUSH
54890: LD_VAR 0 1
54894: PPUSH
54895: EMPTY
54896: PPUSH
54897: CALL_OW 1
54901: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
54902: LD_ADDR_EXP 73
54906: PUSH
54907: LD_EXP 73
54911: PPUSH
54912: LD_VAR 0 1
54916: PPUSH
54917: EMPTY
54918: PPUSH
54919: CALL_OW 1
54923: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
54924: LD_ADDR_EXP 74
54928: PUSH
54929: LD_EXP 74
54933: PPUSH
54934: LD_VAR 0 1
54938: PPUSH
54939: EMPTY
54940: PPUSH
54941: CALL_OW 1
54945: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
54946: LD_ADDR_EXP 75
54950: PUSH
54951: LD_EXP 75
54955: PPUSH
54956: LD_VAR 0 1
54960: PPUSH
54961: EMPTY
54962: PPUSH
54963: CALL_OW 1
54967: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
54968: LD_ADDR_EXP 76
54972: PUSH
54973: LD_EXP 76
54977: PPUSH
54978: LD_VAR 0 1
54982: PPUSH
54983: EMPTY
54984: PPUSH
54985: CALL_OW 1
54989: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
54990: LD_ADDR_EXP 77
54994: PUSH
54995: LD_EXP 77
54999: PPUSH
55000: LD_VAR 0 1
55004: PPUSH
55005: EMPTY
55006: PPUSH
55007: CALL_OW 1
55011: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55012: LD_ADDR_EXP 78
55016: PUSH
55017: LD_EXP 78
55021: PPUSH
55022: LD_VAR 0 1
55026: PPUSH
55027: EMPTY
55028: PPUSH
55029: CALL_OW 1
55033: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55034: LD_ADDR_EXP 79
55038: PUSH
55039: LD_EXP 79
55043: PPUSH
55044: LD_VAR 0 1
55048: PPUSH
55049: EMPTY
55050: PPUSH
55051: CALL_OW 1
55055: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55056: LD_ADDR_EXP 80
55060: PUSH
55061: LD_EXP 80
55065: PPUSH
55066: LD_VAR 0 1
55070: PPUSH
55071: EMPTY
55072: PPUSH
55073: CALL_OW 1
55077: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55078: LD_ADDR_EXP 81
55082: PUSH
55083: LD_EXP 81
55087: PPUSH
55088: LD_VAR 0 1
55092: PPUSH
55093: EMPTY
55094: PPUSH
55095: CALL_OW 1
55099: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55100: LD_ADDR_EXP 82
55104: PUSH
55105: LD_EXP 82
55109: PPUSH
55110: LD_VAR 0 1
55114: PPUSH
55115: EMPTY
55116: PPUSH
55117: CALL_OW 1
55121: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55122: LD_ADDR_EXP 83
55126: PUSH
55127: LD_EXP 83
55131: PPUSH
55132: LD_VAR 0 1
55136: PPUSH
55137: EMPTY
55138: PPUSH
55139: CALL_OW 1
55143: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55144: LD_ADDR_EXP 84
55148: PUSH
55149: LD_EXP 84
55153: PPUSH
55154: LD_VAR 0 1
55158: PPUSH
55159: EMPTY
55160: PPUSH
55161: CALL_OW 1
55165: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55166: LD_ADDR_EXP 85
55170: PUSH
55171: LD_EXP 85
55175: PPUSH
55176: LD_VAR 0 1
55180: PPUSH
55181: EMPTY
55182: PPUSH
55183: CALL_OW 1
55187: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55188: LD_ADDR_EXP 87
55192: PUSH
55193: LD_EXP 87
55197: PPUSH
55198: LD_VAR 0 1
55202: PPUSH
55203: EMPTY
55204: PPUSH
55205: CALL_OW 1
55209: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55210: LD_ADDR_EXP 89
55214: PUSH
55215: LD_EXP 89
55219: PPUSH
55220: LD_VAR 0 1
55224: PPUSH
55225: EMPTY
55226: PPUSH
55227: CALL_OW 1
55231: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55232: LD_ADDR_EXP 90
55236: PUSH
55237: LD_EXP 90
55241: PPUSH
55242: LD_VAR 0 1
55246: PPUSH
55247: EMPTY
55248: PPUSH
55249: CALL_OW 1
55253: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55254: LD_ADDR_EXP 91
55258: PUSH
55259: LD_EXP 91
55263: PPUSH
55264: LD_VAR 0 1
55268: PPUSH
55269: EMPTY
55270: PPUSH
55271: CALL_OW 1
55275: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55276: LD_ADDR_EXP 92
55280: PUSH
55281: LD_EXP 92
55285: PPUSH
55286: LD_VAR 0 1
55290: PPUSH
55291: EMPTY
55292: PPUSH
55293: CALL_OW 1
55297: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55298: LD_ADDR_EXP 93
55302: PUSH
55303: LD_EXP 93
55307: PPUSH
55308: LD_VAR 0 1
55312: PPUSH
55313: EMPTY
55314: PPUSH
55315: CALL_OW 1
55319: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55320: LD_ADDR_EXP 94
55324: PUSH
55325: LD_EXP 94
55329: PPUSH
55330: LD_VAR 0 1
55334: PPUSH
55335: EMPTY
55336: PPUSH
55337: CALL_OW 1
55341: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55342: LD_ADDR_EXP 95
55346: PUSH
55347: LD_EXP 95
55351: PPUSH
55352: LD_VAR 0 1
55356: PPUSH
55357: EMPTY
55358: PPUSH
55359: CALL_OW 1
55363: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55364: LD_ADDR_EXP 96
55368: PUSH
55369: LD_EXP 96
55373: PPUSH
55374: LD_VAR 0 1
55378: PPUSH
55379: EMPTY
55380: PPUSH
55381: CALL_OW 1
55385: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55386: LD_ADDR_EXP 97
55390: PUSH
55391: LD_EXP 97
55395: PPUSH
55396: LD_VAR 0 1
55400: PPUSH
55401: EMPTY
55402: PPUSH
55403: CALL_OW 1
55407: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55408: LD_ADDR_EXP 98
55412: PUSH
55413: LD_EXP 98
55417: PPUSH
55418: LD_VAR 0 1
55422: PPUSH
55423: EMPTY
55424: PPUSH
55425: CALL_OW 1
55429: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55430: LD_ADDR_EXP 99
55434: PUSH
55435: LD_EXP 99
55439: PPUSH
55440: LD_VAR 0 1
55444: PPUSH
55445: EMPTY
55446: PPUSH
55447: CALL_OW 1
55451: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55452: LD_ADDR_EXP 100
55456: PUSH
55457: LD_EXP 100
55461: PPUSH
55462: LD_VAR 0 1
55466: PPUSH
55467: EMPTY
55468: PPUSH
55469: CALL_OW 1
55473: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
55474: LD_ADDR_EXP 101
55478: PUSH
55479: LD_EXP 101
55483: PPUSH
55484: LD_VAR 0 1
55488: PPUSH
55489: EMPTY
55490: PPUSH
55491: CALL_OW 1
55495: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
55496: LD_ADDR_EXP 102
55500: PUSH
55501: LD_EXP 102
55505: PPUSH
55506: LD_VAR 0 1
55510: PPUSH
55511: LD_INT 0
55513: PPUSH
55514: CALL_OW 1
55518: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
55519: LD_ADDR_EXP 103
55523: PUSH
55524: LD_EXP 103
55528: PPUSH
55529: LD_VAR 0 1
55533: PPUSH
55534: LD_INT 0
55536: PPUSH
55537: CALL_OW 1
55541: ST_TO_ADDR
// end ;
55542: LD_VAR 0 2
55546: RET
// export function MC_Add ( side , units ) ; var base ; begin
55547: LD_INT 0
55549: PPUSH
55550: PPUSH
// base := mc_bases + 1 ;
55551: LD_ADDR_VAR 0 4
55555: PUSH
55556: LD_EXP 60
55560: PUSH
55561: LD_INT 1
55563: PLUS
55564: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
55565: LD_ADDR_EXP 86
55569: PUSH
55570: LD_EXP 86
55574: PPUSH
55575: LD_VAR 0 4
55579: PPUSH
55580: LD_VAR 0 1
55584: PPUSH
55585: CALL_OW 1
55589: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
55590: LD_ADDR_EXP 60
55594: PUSH
55595: LD_EXP 60
55599: PPUSH
55600: LD_VAR 0 4
55604: PPUSH
55605: LD_VAR 0 2
55609: PPUSH
55610: CALL_OW 1
55614: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55615: LD_ADDR_EXP 61
55619: PUSH
55620: LD_EXP 61
55624: PPUSH
55625: LD_VAR 0 4
55629: PPUSH
55630: EMPTY
55631: PPUSH
55632: CALL_OW 1
55636: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55637: LD_ADDR_EXP 62
55641: PUSH
55642: LD_EXP 62
55646: PPUSH
55647: LD_VAR 0 4
55651: PPUSH
55652: EMPTY
55653: PPUSH
55654: CALL_OW 1
55658: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55659: LD_ADDR_EXP 63
55663: PUSH
55664: LD_EXP 63
55668: PPUSH
55669: LD_VAR 0 4
55673: PPUSH
55674: EMPTY
55675: PPUSH
55676: CALL_OW 1
55680: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55681: LD_ADDR_EXP 64
55685: PUSH
55686: LD_EXP 64
55690: PPUSH
55691: LD_VAR 0 4
55695: PPUSH
55696: EMPTY
55697: PPUSH
55698: CALL_OW 1
55702: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55703: LD_ADDR_EXP 65
55707: PUSH
55708: LD_EXP 65
55712: PPUSH
55713: LD_VAR 0 4
55717: PPUSH
55718: EMPTY
55719: PPUSH
55720: CALL_OW 1
55724: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55725: LD_ADDR_EXP 66
55729: PUSH
55730: LD_EXP 66
55734: PPUSH
55735: LD_VAR 0 4
55739: PPUSH
55740: EMPTY
55741: PPUSH
55742: CALL_OW 1
55746: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55747: LD_ADDR_EXP 67
55751: PUSH
55752: LD_EXP 67
55756: PPUSH
55757: LD_VAR 0 4
55761: PPUSH
55762: EMPTY
55763: PPUSH
55764: CALL_OW 1
55768: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55769: LD_ADDR_EXP 68
55773: PUSH
55774: LD_EXP 68
55778: PPUSH
55779: LD_VAR 0 4
55783: PPUSH
55784: EMPTY
55785: PPUSH
55786: CALL_OW 1
55790: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55791: LD_ADDR_EXP 69
55795: PUSH
55796: LD_EXP 69
55800: PPUSH
55801: LD_VAR 0 4
55805: PPUSH
55806: EMPTY
55807: PPUSH
55808: CALL_OW 1
55812: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55813: LD_ADDR_EXP 70
55817: PUSH
55818: LD_EXP 70
55822: PPUSH
55823: LD_VAR 0 4
55827: PPUSH
55828: EMPTY
55829: PPUSH
55830: CALL_OW 1
55834: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55835: LD_ADDR_EXP 71
55839: PUSH
55840: LD_EXP 71
55844: PPUSH
55845: LD_VAR 0 4
55849: PPUSH
55850: LD_INT 0
55852: PPUSH
55853: CALL_OW 1
55857: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55858: LD_ADDR_EXP 72
55862: PUSH
55863: LD_EXP 72
55867: PPUSH
55868: LD_VAR 0 4
55872: PPUSH
55873: EMPTY
55874: PPUSH
55875: CALL_OW 1
55879: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55880: LD_ADDR_EXP 73
55884: PUSH
55885: LD_EXP 73
55889: PPUSH
55890: LD_VAR 0 4
55894: PPUSH
55895: EMPTY
55896: PPUSH
55897: CALL_OW 1
55901: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55902: LD_ADDR_EXP 74
55906: PUSH
55907: LD_EXP 74
55911: PPUSH
55912: LD_VAR 0 4
55916: PPUSH
55917: EMPTY
55918: PPUSH
55919: CALL_OW 1
55923: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55924: LD_ADDR_EXP 75
55928: PUSH
55929: LD_EXP 75
55933: PPUSH
55934: LD_VAR 0 4
55938: PPUSH
55939: EMPTY
55940: PPUSH
55941: CALL_OW 1
55945: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55946: LD_ADDR_EXP 76
55950: PUSH
55951: LD_EXP 76
55955: PPUSH
55956: LD_VAR 0 4
55960: PPUSH
55961: EMPTY
55962: PPUSH
55963: CALL_OW 1
55967: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55968: LD_ADDR_EXP 77
55972: PUSH
55973: LD_EXP 77
55977: PPUSH
55978: LD_VAR 0 4
55982: PPUSH
55983: EMPTY
55984: PPUSH
55985: CALL_OW 1
55989: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55990: LD_ADDR_EXP 78
55994: PUSH
55995: LD_EXP 78
55999: PPUSH
56000: LD_VAR 0 4
56004: PPUSH
56005: EMPTY
56006: PPUSH
56007: CALL_OW 1
56011: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56012: LD_ADDR_EXP 79
56016: PUSH
56017: LD_EXP 79
56021: PPUSH
56022: LD_VAR 0 4
56026: PPUSH
56027: EMPTY
56028: PPUSH
56029: CALL_OW 1
56033: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56034: LD_ADDR_EXP 80
56038: PUSH
56039: LD_EXP 80
56043: PPUSH
56044: LD_VAR 0 4
56048: PPUSH
56049: EMPTY
56050: PPUSH
56051: CALL_OW 1
56055: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56056: LD_ADDR_EXP 81
56060: PUSH
56061: LD_EXP 81
56065: PPUSH
56066: LD_VAR 0 4
56070: PPUSH
56071: EMPTY
56072: PPUSH
56073: CALL_OW 1
56077: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56078: LD_ADDR_EXP 82
56082: PUSH
56083: LD_EXP 82
56087: PPUSH
56088: LD_VAR 0 4
56092: PPUSH
56093: EMPTY
56094: PPUSH
56095: CALL_OW 1
56099: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56100: LD_ADDR_EXP 83
56104: PUSH
56105: LD_EXP 83
56109: PPUSH
56110: LD_VAR 0 4
56114: PPUSH
56115: EMPTY
56116: PPUSH
56117: CALL_OW 1
56121: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56122: LD_ADDR_EXP 84
56126: PUSH
56127: LD_EXP 84
56131: PPUSH
56132: LD_VAR 0 4
56136: PPUSH
56137: EMPTY
56138: PPUSH
56139: CALL_OW 1
56143: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56144: LD_ADDR_EXP 85
56148: PUSH
56149: LD_EXP 85
56153: PPUSH
56154: LD_VAR 0 4
56158: PPUSH
56159: EMPTY
56160: PPUSH
56161: CALL_OW 1
56165: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56166: LD_ADDR_EXP 87
56170: PUSH
56171: LD_EXP 87
56175: PPUSH
56176: LD_VAR 0 4
56180: PPUSH
56181: EMPTY
56182: PPUSH
56183: CALL_OW 1
56187: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56188: LD_ADDR_EXP 89
56192: PUSH
56193: LD_EXP 89
56197: PPUSH
56198: LD_VAR 0 4
56202: PPUSH
56203: EMPTY
56204: PPUSH
56205: CALL_OW 1
56209: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56210: LD_ADDR_EXP 90
56214: PUSH
56215: LD_EXP 90
56219: PPUSH
56220: LD_VAR 0 4
56224: PPUSH
56225: EMPTY
56226: PPUSH
56227: CALL_OW 1
56231: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56232: LD_ADDR_EXP 91
56236: PUSH
56237: LD_EXP 91
56241: PPUSH
56242: LD_VAR 0 4
56246: PPUSH
56247: EMPTY
56248: PPUSH
56249: CALL_OW 1
56253: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56254: LD_ADDR_EXP 92
56258: PUSH
56259: LD_EXP 92
56263: PPUSH
56264: LD_VAR 0 4
56268: PPUSH
56269: EMPTY
56270: PPUSH
56271: CALL_OW 1
56275: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56276: LD_ADDR_EXP 93
56280: PUSH
56281: LD_EXP 93
56285: PPUSH
56286: LD_VAR 0 4
56290: PPUSH
56291: EMPTY
56292: PPUSH
56293: CALL_OW 1
56297: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56298: LD_ADDR_EXP 94
56302: PUSH
56303: LD_EXP 94
56307: PPUSH
56308: LD_VAR 0 4
56312: PPUSH
56313: EMPTY
56314: PPUSH
56315: CALL_OW 1
56319: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56320: LD_ADDR_EXP 95
56324: PUSH
56325: LD_EXP 95
56329: PPUSH
56330: LD_VAR 0 4
56334: PPUSH
56335: EMPTY
56336: PPUSH
56337: CALL_OW 1
56341: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56342: LD_ADDR_EXP 96
56346: PUSH
56347: LD_EXP 96
56351: PPUSH
56352: LD_VAR 0 4
56356: PPUSH
56357: EMPTY
56358: PPUSH
56359: CALL_OW 1
56363: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56364: LD_ADDR_EXP 97
56368: PUSH
56369: LD_EXP 97
56373: PPUSH
56374: LD_VAR 0 4
56378: PPUSH
56379: EMPTY
56380: PPUSH
56381: CALL_OW 1
56385: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56386: LD_ADDR_EXP 98
56390: PUSH
56391: LD_EXP 98
56395: PPUSH
56396: LD_VAR 0 4
56400: PPUSH
56401: EMPTY
56402: PPUSH
56403: CALL_OW 1
56407: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56408: LD_ADDR_EXP 99
56412: PUSH
56413: LD_EXP 99
56417: PPUSH
56418: LD_VAR 0 4
56422: PPUSH
56423: EMPTY
56424: PPUSH
56425: CALL_OW 1
56429: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56430: LD_ADDR_EXP 100
56434: PUSH
56435: LD_EXP 100
56439: PPUSH
56440: LD_VAR 0 4
56444: PPUSH
56445: EMPTY
56446: PPUSH
56447: CALL_OW 1
56451: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56452: LD_ADDR_EXP 101
56456: PUSH
56457: LD_EXP 101
56461: PPUSH
56462: LD_VAR 0 4
56466: PPUSH
56467: EMPTY
56468: PPUSH
56469: CALL_OW 1
56473: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56474: LD_ADDR_EXP 102
56478: PUSH
56479: LD_EXP 102
56483: PPUSH
56484: LD_VAR 0 4
56488: PPUSH
56489: LD_INT 0
56491: PPUSH
56492: CALL_OW 1
56496: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56497: LD_ADDR_EXP 103
56501: PUSH
56502: LD_EXP 103
56506: PPUSH
56507: LD_VAR 0 4
56511: PPUSH
56512: LD_INT 0
56514: PPUSH
56515: CALL_OW 1
56519: ST_TO_ADDR
// result := base ;
56520: LD_ADDR_VAR 0 3
56524: PUSH
56525: LD_VAR 0 4
56529: ST_TO_ADDR
// end ;
56530: LD_VAR 0 3
56534: RET
// export function MC_Start ( ) ; var i ; begin
56535: LD_INT 0
56537: PPUSH
56538: PPUSH
// for i = 1 to mc_bases do
56539: LD_ADDR_VAR 0 2
56543: PUSH
56544: DOUBLE
56545: LD_INT 1
56547: DEC
56548: ST_TO_ADDR
56549: LD_EXP 60
56553: PUSH
56554: FOR_TO
56555: IFFALSE 57655
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
56557: LD_ADDR_EXP 60
56561: PUSH
56562: LD_EXP 60
56566: PPUSH
56567: LD_VAR 0 2
56571: PPUSH
56572: LD_EXP 60
56576: PUSH
56577: LD_VAR 0 2
56581: ARRAY
56582: PUSH
56583: LD_INT 0
56585: DIFF
56586: PPUSH
56587: CALL_OW 1
56591: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
56592: LD_ADDR_EXP 61
56596: PUSH
56597: LD_EXP 61
56601: PPUSH
56602: LD_VAR 0 2
56606: PPUSH
56607: EMPTY
56608: PPUSH
56609: CALL_OW 1
56613: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
56614: LD_ADDR_EXP 62
56618: PUSH
56619: LD_EXP 62
56623: PPUSH
56624: LD_VAR 0 2
56628: PPUSH
56629: EMPTY
56630: PPUSH
56631: CALL_OW 1
56635: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
56636: LD_ADDR_EXP 63
56640: PUSH
56641: LD_EXP 63
56645: PPUSH
56646: LD_VAR 0 2
56650: PPUSH
56651: EMPTY
56652: PPUSH
56653: CALL_OW 1
56657: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
56658: LD_ADDR_EXP 64
56662: PUSH
56663: LD_EXP 64
56667: PPUSH
56668: LD_VAR 0 2
56672: PPUSH
56673: EMPTY
56674: PUSH
56675: EMPTY
56676: PUSH
56677: EMPTY
56678: LIST
56679: LIST
56680: PPUSH
56681: CALL_OW 1
56685: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
56686: LD_ADDR_EXP 65
56690: PUSH
56691: LD_EXP 65
56695: PPUSH
56696: LD_VAR 0 2
56700: PPUSH
56701: EMPTY
56702: PPUSH
56703: CALL_OW 1
56707: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
56708: LD_ADDR_EXP 92
56712: PUSH
56713: LD_EXP 92
56717: PPUSH
56718: LD_VAR 0 2
56722: PPUSH
56723: EMPTY
56724: PPUSH
56725: CALL_OW 1
56729: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
56730: LD_ADDR_EXP 66
56734: PUSH
56735: LD_EXP 66
56739: PPUSH
56740: LD_VAR 0 2
56744: PPUSH
56745: EMPTY
56746: PPUSH
56747: CALL_OW 1
56751: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
56752: LD_ADDR_EXP 67
56756: PUSH
56757: LD_EXP 67
56761: PPUSH
56762: LD_VAR 0 2
56766: PPUSH
56767: EMPTY
56768: PPUSH
56769: CALL_OW 1
56773: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
56774: LD_ADDR_EXP 68
56778: PUSH
56779: LD_EXP 68
56783: PPUSH
56784: LD_VAR 0 2
56788: PPUSH
56789: LD_EXP 60
56793: PUSH
56794: LD_VAR 0 2
56798: ARRAY
56799: PPUSH
56800: LD_INT 2
56802: PUSH
56803: LD_INT 30
56805: PUSH
56806: LD_INT 32
56808: PUSH
56809: EMPTY
56810: LIST
56811: LIST
56812: PUSH
56813: LD_INT 30
56815: PUSH
56816: LD_INT 33
56818: PUSH
56819: EMPTY
56820: LIST
56821: LIST
56822: PUSH
56823: EMPTY
56824: LIST
56825: LIST
56826: LIST
56827: PPUSH
56828: CALL_OW 72
56832: PPUSH
56833: CALL_OW 1
56837: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
56838: LD_ADDR_EXP 69
56842: PUSH
56843: LD_EXP 69
56847: PPUSH
56848: LD_VAR 0 2
56852: PPUSH
56853: LD_EXP 60
56857: PUSH
56858: LD_VAR 0 2
56862: ARRAY
56863: PPUSH
56864: LD_INT 2
56866: PUSH
56867: LD_INT 30
56869: PUSH
56870: LD_INT 32
56872: PUSH
56873: EMPTY
56874: LIST
56875: LIST
56876: PUSH
56877: LD_INT 30
56879: PUSH
56880: LD_INT 31
56882: PUSH
56883: EMPTY
56884: LIST
56885: LIST
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: LIST
56891: PUSH
56892: LD_INT 58
56894: PUSH
56895: EMPTY
56896: LIST
56897: PUSH
56898: EMPTY
56899: LIST
56900: LIST
56901: PPUSH
56902: CALL_OW 72
56906: PPUSH
56907: CALL_OW 1
56911: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
56912: LD_ADDR_EXP 70
56916: PUSH
56917: LD_EXP 70
56921: PPUSH
56922: LD_VAR 0 2
56926: PPUSH
56927: EMPTY
56928: PPUSH
56929: CALL_OW 1
56933: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
56934: LD_ADDR_EXP 74
56938: PUSH
56939: LD_EXP 74
56943: PPUSH
56944: LD_VAR 0 2
56948: PPUSH
56949: EMPTY
56950: PPUSH
56951: CALL_OW 1
56955: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
56956: LD_ADDR_EXP 73
56960: PUSH
56961: LD_EXP 73
56965: PPUSH
56966: LD_VAR 0 2
56970: PPUSH
56971: EMPTY
56972: PPUSH
56973: CALL_OW 1
56977: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
56978: LD_ADDR_EXP 75
56982: PUSH
56983: LD_EXP 75
56987: PPUSH
56988: LD_VAR 0 2
56992: PPUSH
56993: EMPTY
56994: PPUSH
56995: CALL_OW 1
56999: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57000: LD_ADDR_EXP 76
57004: PUSH
57005: LD_EXP 76
57009: PPUSH
57010: LD_VAR 0 2
57014: PPUSH
57015: EMPTY
57016: PPUSH
57017: CALL_OW 1
57021: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57022: LD_ADDR_EXP 77
57026: PUSH
57027: LD_EXP 77
57031: PPUSH
57032: LD_VAR 0 2
57036: PPUSH
57037: EMPTY
57038: PPUSH
57039: CALL_OW 1
57043: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57044: LD_ADDR_EXP 78
57048: PUSH
57049: LD_EXP 78
57053: PPUSH
57054: LD_VAR 0 2
57058: PPUSH
57059: EMPTY
57060: PPUSH
57061: CALL_OW 1
57065: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57066: LD_ADDR_EXP 79
57070: PUSH
57071: LD_EXP 79
57075: PPUSH
57076: LD_VAR 0 2
57080: PPUSH
57081: EMPTY
57082: PPUSH
57083: CALL_OW 1
57087: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57088: LD_ADDR_EXP 80
57092: PUSH
57093: LD_EXP 80
57097: PPUSH
57098: LD_VAR 0 2
57102: PPUSH
57103: EMPTY
57104: PPUSH
57105: CALL_OW 1
57109: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57110: LD_ADDR_EXP 81
57114: PUSH
57115: LD_EXP 81
57119: PPUSH
57120: LD_VAR 0 2
57124: PPUSH
57125: EMPTY
57126: PPUSH
57127: CALL_OW 1
57131: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57132: LD_ADDR_EXP 82
57136: PUSH
57137: LD_EXP 82
57141: PPUSH
57142: LD_VAR 0 2
57146: PPUSH
57147: EMPTY
57148: PPUSH
57149: CALL_OW 1
57153: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57154: LD_ADDR_EXP 71
57158: PUSH
57159: LD_EXP 71
57163: PPUSH
57164: LD_VAR 0 2
57168: PPUSH
57169: LD_INT 0
57171: PPUSH
57172: CALL_OW 1
57176: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57177: LD_ADDR_EXP 84
57181: PUSH
57182: LD_EXP 84
57186: PPUSH
57187: LD_VAR 0 2
57191: PPUSH
57192: LD_INT 0
57194: PPUSH
57195: CALL_OW 1
57199: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57200: LD_ADDR_EXP 72
57204: PUSH
57205: LD_EXP 72
57209: PPUSH
57210: LD_VAR 0 2
57214: PPUSH
57215: EMPTY
57216: PPUSH
57217: CALL_OW 1
57221: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57222: LD_ADDR_EXP 83
57226: PUSH
57227: LD_EXP 83
57231: PPUSH
57232: LD_VAR 0 2
57236: PPUSH
57237: LD_INT 0
57239: PPUSH
57240: CALL_OW 1
57244: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57245: LD_ADDR_EXP 85
57249: PUSH
57250: LD_EXP 85
57254: PPUSH
57255: LD_VAR 0 2
57259: PPUSH
57260: EMPTY
57261: PPUSH
57262: CALL_OW 1
57266: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57267: LD_ADDR_EXP 88
57271: PUSH
57272: LD_EXP 88
57276: PPUSH
57277: LD_VAR 0 2
57281: PPUSH
57282: LD_INT 0
57284: PPUSH
57285: CALL_OW 1
57289: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57290: LD_ADDR_EXP 89
57294: PUSH
57295: LD_EXP 89
57299: PPUSH
57300: LD_VAR 0 2
57304: PPUSH
57305: EMPTY
57306: PPUSH
57307: CALL_OW 1
57311: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57312: LD_ADDR_EXP 90
57316: PUSH
57317: LD_EXP 90
57321: PPUSH
57322: LD_VAR 0 2
57326: PPUSH
57327: EMPTY
57328: PPUSH
57329: CALL_OW 1
57333: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57334: LD_ADDR_EXP 91
57338: PUSH
57339: LD_EXP 91
57343: PPUSH
57344: LD_VAR 0 2
57348: PPUSH
57349: EMPTY
57350: PPUSH
57351: CALL_OW 1
57355: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57356: LD_ADDR_EXP 93
57360: PUSH
57361: LD_EXP 93
57365: PPUSH
57366: LD_VAR 0 2
57370: PPUSH
57371: LD_EXP 60
57375: PUSH
57376: LD_VAR 0 2
57380: ARRAY
57381: PPUSH
57382: LD_INT 2
57384: PUSH
57385: LD_INT 30
57387: PUSH
57388: LD_INT 6
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 7
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PUSH
57405: LD_INT 30
57407: PUSH
57408: LD_INT 8
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PUSH
57415: EMPTY
57416: LIST
57417: LIST
57418: LIST
57419: LIST
57420: PPUSH
57421: CALL_OW 72
57425: PPUSH
57426: CALL_OW 1
57430: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57431: LD_ADDR_EXP 94
57435: PUSH
57436: LD_EXP 94
57440: PPUSH
57441: LD_VAR 0 2
57445: PPUSH
57446: EMPTY
57447: PPUSH
57448: CALL_OW 1
57452: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57453: LD_ADDR_EXP 95
57457: PUSH
57458: LD_EXP 95
57462: PPUSH
57463: LD_VAR 0 2
57467: PPUSH
57468: EMPTY
57469: PPUSH
57470: CALL_OW 1
57474: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
57475: LD_ADDR_EXP 96
57479: PUSH
57480: LD_EXP 96
57484: PPUSH
57485: LD_VAR 0 2
57489: PPUSH
57490: EMPTY
57491: PPUSH
57492: CALL_OW 1
57496: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
57497: LD_ADDR_EXP 97
57501: PUSH
57502: LD_EXP 97
57506: PPUSH
57507: LD_VAR 0 2
57511: PPUSH
57512: EMPTY
57513: PPUSH
57514: CALL_OW 1
57518: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
57519: LD_ADDR_EXP 98
57523: PUSH
57524: LD_EXP 98
57528: PPUSH
57529: LD_VAR 0 2
57533: PPUSH
57534: EMPTY
57535: PPUSH
57536: CALL_OW 1
57540: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
57541: LD_ADDR_EXP 99
57545: PUSH
57546: LD_EXP 99
57550: PPUSH
57551: LD_VAR 0 2
57555: PPUSH
57556: EMPTY
57557: PPUSH
57558: CALL_OW 1
57562: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
57563: LD_ADDR_EXP 100
57567: PUSH
57568: LD_EXP 100
57572: PPUSH
57573: LD_VAR 0 2
57577: PPUSH
57578: EMPTY
57579: PPUSH
57580: CALL_OW 1
57584: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
57585: LD_ADDR_EXP 101
57589: PUSH
57590: LD_EXP 101
57594: PPUSH
57595: LD_VAR 0 2
57599: PPUSH
57600: EMPTY
57601: PPUSH
57602: CALL_OW 1
57606: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
57607: LD_ADDR_EXP 102
57611: PUSH
57612: LD_EXP 102
57616: PPUSH
57617: LD_VAR 0 2
57621: PPUSH
57622: LD_INT 0
57624: PPUSH
57625: CALL_OW 1
57629: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
57630: LD_ADDR_EXP 103
57634: PUSH
57635: LD_EXP 103
57639: PPUSH
57640: LD_VAR 0 2
57644: PPUSH
57645: LD_INT 0
57647: PPUSH
57648: CALL_OW 1
57652: ST_TO_ADDR
// end ;
57653: GO 56554
57655: POP
57656: POP
// MC_InitSides ( ) ;
57657: CALL 57943 0 0
// MC_InitResearch ( ) ;
57661: CALL 57682 0 0
// CustomInitMacro ( ) ;
57665: CALL 206 0 0
// skirmish := true ;
57669: LD_ADDR_EXP 58
57673: PUSH
57674: LD_INT 1
57676: ST_TO_ADDR
// end ;
57677: LD_VAR 0 1
57681: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
57682: LD_INT 0
57684: PPUSH
57685: PPUSH
57686: PPUSH
57687: PPUSH
57688: PPUSH
57689: PPUSH
// if not mc_bases then
57690: LD_EXP 60
57694: NOT
57695: IFFALSE 57699
// exit ;
57697: GO 57938
// for i = 1 to 8 do
57699: LD_ADDR_VAR 0 2
57703: PUSH
57704: DOUBLE
57705: LD_INT 1
57707: DEC
57708: ST_TO_ADDR
57709: LD_INT 8
57711: PUSH
57712: FOR_TO
57713: IFFALSE 57739
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
57715: LD_ADDR_EXP 87
57719: PUSH
57720: LD_EXP 87
57724: PPUSH
57725: LD_VAR 0 2
57729: PPUSH
57730: EMPTY
57731: PPUSH
57732: CALL_OW 1
57736: ST_TO_ADDR
57737: GO 57712
57739: POP
57740: POP
// tmp := [ ] ;
57741: LD_ADDR_VAR 0 5
57745: PUSH
57746: EMPTY
57747: ST_TO_ADDR
// for i = 1 to mc_sides do
57748: LD_ADDR_VAR 0 2
57752: PUSH
57753: DOUBLE
57754: LD_INT 1
57756: DEC
57757: ST_TO_ADDR
57758: LD_EXP 86
57762: PUSH
57763: FOR_TO
57764: IFFALSE 57822
// if not mc_sides [ i ] in tmp then
57766: LD_EXP 86
57770: PUSH
57771: LD_VAR 0 2
57775: ARRAY
57776: PUSH
57777: LD_VAR 0 5
57781: IN
57782: NOT
57783: IFFALSE 57820
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
57785: LD_ADDR_VAR 0 5
57789: PUSH
57790: LD_VAR 0 5
57794: PPUSH
57795: LD_VAR 0 5
57799: PUSH
57800: LD_INT 1
57802: PLUS
57803: PPUSH
57804: LD_EXP 86
57808: PUSH
57809: LD_VAR 0 2
57813: ARRAY
57814: PPUSH
57815: CALL_OW 2
57819: ST_TO_ADDR
57820: GO 57763
57822: POP
57823: POP
// if not tmp then
57824: LD_VAR 0 5
57828: NOT
57829: IFFALSE 57833
// exit ;
57831: GO 57938
// for j in tmp do
57833: LD_ADDR_VAR 0 3
57837: PUSH
57838: LD_VAR 0 5
57842: PUSH
57843: FOR_IN
57844: IFFALSE 57936
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
57846: LD_ADDR_VAR 0 6
57850: PUSH
57851: LD_INT 22
57853: PUSH
57854: LD_VAR 0 3
57858: PUSH
57859: EMPTY
57860: LIST
57861: LIST
57862: PPUSH
57863: CALL_OW 69
57867: ST_TO_ADDR
// if not un then
57868: LD_VAR 0 6
57872: NOT
57873: IFFALSE 57877
// continue ;
57875: GO 57843
// nation := GetNation ( un [ 1 ] ) ;
57877: LD_ADDR_VAR 0 4
57881: PUSH
57882: LD_VAR 0 6
57886: PUSH
57887: LD_INT 1
57889: ARRAY
57890: PPUSH
57891: CALL_OW 248
57895: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
57896: LD_ADDR_EXP 87
57900: PUSH
57901: LD_EXP 87
57905: PPUSH
57906: LD_VAR 0 3
57910: PPUSH
57911: LD_VAR 0 3
57915: PPUSH
57916: LD_VAR 0 4
57920: PPUSH
57921: LD_INT 1
57923: PPUSH
57924: CALL 14878 0 3
57928: PPUSH
57929: CALL_OW 1
57933: ST_TO_ADDR
// end ;
57934: GO 57843
57936: POP
57937: POP
// end ;
57938: LD_VAR 0 1
57942: RET
// export function MC_InitSides ( ) ; var i ; begin
57943: LD_INT 0
57945: PPUSH
57946: PPUSH
// if not mc_bases then
57947: LD_EXP 60
57951: NOT
57952: IFFALSE 57956
// exit ;
57954: GO 58030
// for i = 1 to mc_bases do
57956: LD_ADDR_VAR 0 2
57960: PUSH
57961: DOUBLE
57962: LD_INT 1
57964: DEC
57965: ST_TO_ADDR
57966: LD_EXP 60
57970: PUSH
57971: FOR_TO
57972: IFFALSE 58028
// if mc_bases [ i ] then
57974: LD_EXP 60
57978: PUSH
57979: LD_VAR 0 2
57983: ARRAY
57984: IFFALSE 58026
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
57986: LD_ADDR_EXP 86
57990: PUSH
57991: LD_EXP 86
57995: PPUSH
57996: LD_VAR 0 2
58000: PPUSH
58001: LD_EXP 60
58005: PUSH
58006: LD_VAR 0 2
58010: ARRAY
58011: PUSH
58012: LD_INT 1
58014: ARRAY
58015: PPUSH
58016: CALL_OW 255
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
58026: GO 57971
58028: POP
58029: POP
// end ;
58030: LD_VAR 0 1
58034: RET
// every 0 0$03 trigger skirmish do
58035: LD_EXP 58
58039: IFFALSE 58193
58041: GO 58043
58043: DISABLE
// begin enable ;
58044: ENABLE
// MC_CheckBuildings ( ) ;
58045: CALL 62691 0 0
// MC_CheckPeopleLife ( ) ;
58049: CALL 62852 0 0
// RaiseSailEvent ( 100 ) ;
58053: LD_INT 100
58055: PPUSH
58056: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58060: LD_INT 103
58062: PPUSH
58063: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58067: LD_INT 104
58069: PPUSH
58070: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58074: LD_INT 105
58076: PPUSH
58077: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58081: LD_INT 106
58083: PPUSH
58084: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58088: LD_INT 107
58090: PPUSH
58091: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58095: LD_INT 108
58097: PPUSH
58098: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58102: LD_INT 109
58104: PPUSH
58105: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58109: LD_INT 110
58111: PPUSH
58112: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58116: LD_INT 111
58118: PPUSH
58119: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58123: LD_INT 112
58125: PPUSH
58126: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58130: LD_INT 113
58132: PPUSH
58133: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58137: LD_INT 120
58139: PPUSH
58140: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58144: LD_INT 121
58146: PPUSH
58147: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58151: LD_INT 122
58153: PPUSH
58154: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58158: LD_INT 123
58160: PPUSH
58161: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58165: LD_INT 124
58167: PPUSH
58168: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58172: LD_INT 125
58174: PPUSH
58175: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58179: LD_INT 126
58181: PPUSH
58182: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58186: LD_INT 200
58188: PPUSH
58189: CALL_OW 427
// end ;
58193: END
// on SailEvent ( event ) do begin if event < 100 then
58194: LD_VAR 0 1
58198: PUSH
58199: LD_INT 100
58201: LESS
58202: IFFALSE 58213
// CustomEvent ( event ) ;
58204: LD_VAR 0 1
58208: PPUSH
58209: CALL 13516 0 1
// if event = 100 then
58213: LD_VAR 0 1
58217: PUSH
58218: LD_INT 100
58220: EQUAL
58221: IFFALSE 58227
// MC_ClassManager ( ) ;
58223: CALL 58619 0 0
// if event = 101 then
58227: LD_VAR 0 1
58231: PUSH
58232: LD_INT 101
58234: EQUAL
58235: IFFALSE 58241
// MC_RepairBuildings ( ) ;
58237: CALL 63437 0 0
// if event = 102 then
58241: LD_VAR 0 1
58245: PUSH
58246: LD_INT 102
58248: EQUAL
58249: IFFALSE 58255
// MC_Heal ( ) ;
58251: CALL 64344 0 0
// if event = 103 then
58255: LD_VAR 0 1
58259: PUSH
58260: LD_INT 103
58262: EQUAL
58263: IFFALSE 58269
// MC_Build ( ) ;
58265: CALL 64766 0 0
// if event = 104 then
58269: LD_VAR 0 1
58273: PUSH
58274: LD_INT 104
58276: EQUAL
58277: IFFALSE 58283
// MC_TurretWeapon ( ) ;
58279: CALL 66407 0 0
// if event = 105 then
58283: LD_VAR 0 1
58287: PUSH
58288: LD_INT 105
58290: EQUAL
58291: IFFALSE 58297
// MC_BuildUpgrade ( ) ;
58293: CALL 65958 0 0
// if event = 106 then
58297: LD_VAR 0 1
58301: PUSH
58302: LD_INT 106
58304: EQUAL
58305: IFFALSE 58311
// MC_PlantMines ( ) ;
58307: CALL 66837 0 0
// if event = 107 then
58311: LD_VAR 0 1
58315: PUSH
58316: LD_INT 107
58318: EQUAL
58319: IFFALSE 58325
// MC_CollectCrates ( ) ;
58321: CALL 67628 0 0
// if event = 108 then
58325: LD_VAR 0 1
58329: PUSH
58330: LD_INT 108
58332: EQUAL
58333: IFFALSE 58339
// MC_LinkRemoteControl ( ) ;
58335: CALL 69478 0 0
// if event = 109 then
58339: LD_VAR 0 1
58343: PUSH
58344: LD_INT 109
58346: EQUAL
58347: IFFALSE 58353
// MC_ProduceVehicle ( ) ;
58349: CALL 69659 0 0
// if event = 110 then
58353: LD_VAR 0 1
58357: PUSH
58358: LD_INT 110
58360: EQUAL
58361: IFFALSE 58367
// MC_SendAttack ( ) ;
58363: CALL 70125 0 0
// if event = 111 then
58367: LD_VAR 0 1
58371: PUSH
58372: LD_INT 111
58374: EQUAL
58375: IFFALSE 58381
// MC_Defend ( ) ;
58377: CALL 70233 0 0
// if event = 112 then
58381: LD_VAR 0 1
58385: PUSH
58386: LD_INT 112
58388: EQUAL
58389: IFFALSE 58395
// MC_Research ( ) ;
58391: CALL 71113 0 0
// if event = 113 then
58395: LD_VAR 0 1
58399: PUSH
58400: LD_INT 113
58402: EQUAL
58403: IFFALSE 58409
// MC_MinesTrigger ( ) ;
58405: CALL 72227 0 0
// if event = 120 then
58409: LD_VAR 0 1
58413: PUSH
58414: LD_INT 120
58416: EQUAL
58417: IFFALSE 58423
// MC_RepairVehicle ( ) ;
58419: CALL 72326 0 0
// if event = 121 then
58423: LD_VAR 0 1
58427: PUSH
58428: LD_INT 121
58430: EQUAL
58431: IFFALSE 58437
// MC_TameApe ( ) ;
58433: CALL 73067 0 0
// if event = 122 then
58437: LD_VAR 0 1
58441: PUSH
58442: LD_INT 122
58444: EQUAL
58445: IFFALSE 58451
// MC_ChangeApeClass ( ) ;
58447: CALL 73896 0 0
// if event = 123 then
58451: LD_VAR 0 1
58455: PUSH
58456: LD_INT 123
58458: EQUAL
58459: IFFALSE 58465
// MC_Bazooka ( ) ;
58461: CALL 74546 0 0
// if event = 124 then
58465: LD_VAR 0 1
58469: PUSH
58470: LD_INT 124
58472: EQUAL
58473: IFFALSE 58479
// MC_TeleportExit ( ) ;
58475: CALL 74744 0 0
// if event = 125 then
58479: LD_VAR 0 1
58483: PUSH
58484: LD_INT 125
58486: EQUAL
58487: IFFALSE 58493
// MC_Deposits ( ) ;
58489: CALL 75391 0 0
// if event = 126 then
58493: LD_VAR 0 1
58497: PUSH
58498: LD_INT 126
58500: EQUAL
58501: IFFALSE 58507
// MC_RemoteDriver ( ) ;
58503: CALL 76016 0 0
// if event = 200 then
58507: LD_VAR 0 1
58511: PUSH
58512: LD_INT 200
58514: EQUAL
58515: IFFALSE 58521
// MC_Idle ( ) ;
58517: CALL 77965 0 0
// end ;
58521: PPOPN 1
58523: END
// export function MC_Reset ( base , tag ) ; var i ; begin
58524: LD_INT 0
58526: PPUSH
58527: PPUSH
// if not mc_bases [ base ] or not tag then
58528: LD_EXP 60
58532: PUSH
58533: LD_VAR 0 1
58537: ARRAY
58538: NOT
58539: PUSH
58540: LD_VAR 0 2
58544: NOT
58545: OR
58546: IFFALSE 58550
// exit ;
58548: GO 58614
// for i in mc_bases [ base ] union mc_ape [ base ] do
58550: LD_ADDR_VAR 0 4
58554: PUSH
58555: LD_EXP 60
58559: PUSH
58560: LD_VAR 0 1
58564: ARRAY
58565: PUSH
58566: LD_EXP 89
58570: PUSH
58571: LD_VAR 0 1
58575: ARRAY
58576: UNION
58577: PUSH
58578: FOR_IN
58579: IFFALSE 58612
// if GetTag ( i ) = tag then
58581: LD_VAR 0 4
58585: PPUSH
58586: CALL_OW 110
58590: PUSH
58591: LD_VAR 0 2
58595: EQUAL
58596: IFFALSE 58610
// SetTag ( i , 0 ) ;
58598: LD_VAR 0 4
58602: PPUSH
58603: LD_INT 0
58605: PPUSH
58606: CALL_OW 109
58610: GO 58578
58612: POP
58613: POP
// end ;
58614: LD_VAR 0 3
58618: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
58619: LD_INT 0
58621: PPUSH
58622: PPUSH
58623: PPUSH
58624: PPUSH
58625: PPUSH
58626: PPUSH
58627: PPUSH
58628: PPUSH
// if not mc_bases then
58629: LD_EXP 60
58633: NOT
58634: IFFALSE 58638
// exit ;
58636: GO 59096
// for i = 1 to mc_bases do
58638: LD_ADDR_VAR 0 2
58642: PUSH
58643: DOUBLE
58644: LD_INT 1
58646: DEC
58647: ST_TO_ADDR
58648: LD_EXP 60
58652: PUSH
58653: FOR_TO
58654: IFFALSE 59094
// begin tmp := MC_ClassCheckReq ( i ) ;
58656: LD_ADDR_VAR 0 4
58660: PUSH
58661: LD_VAR 0 2
58665: PPUSH
58666: CALL 59101 0 1
58670: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
58671: LD_ADDR_EXP 101
58675: PUSH
58676: LD_EXP 101
58680: PPUSH
58681: LD_VAR 0 2
58685: PPUSH
58686: LD_VAR 0 4
58690: PPUSH
58691: CALL_OW 1
58695: ST_TO_ADDR
// if not tmp then
58696: LD_VAR 0 4
58700: NOT
58701: IFFALSE 58705
// continue ;
58703: GO 58653
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
58705: LD_ADDR_VAR 0 6
58709: PUSH
58710: LD_EXP 60
58714: PUSH
58715: LD_VAR 0 2
58719: ARRAY
58720: PPUSH
58721: LD_INT 2
58723: PUSH
58724: LD_INT 30
58726: PUSH
58727: LD_INT 4
58729: PUSH
58730: EMPTY
58731: LIST
58732: LIST
58733: PUSH
58734: LD_INT 30
58736: PUSH
58737: LD_INT 5
58739: PUSH
58740: EMPTY
58741: LIST
58742: LIST
58743: PUSH
58744: EMPTY
58745: LIST
58746: LIST
58747: LIST
58748: PPUSH
58749: CALL_OW 72
58753: PUSH
58754: LD_EXP 60
58758: PUSH
58759: LD_VAR 0 2
58763: ARRAY
58764: PPUSH
58765: LD_INT 2
58767: PUSH
58768: LD_INT 30
58770: PUSH
58771: LD_INT 0
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: PUSH
58778: LD_INT 30
58780: PUSH
58781: LD_INT 1
58783: PUSH
58784: EMPTY
58785: LIST
58786: LIST
58787: PUSH
58788: EMPTY
58789: LIST
58790: LIST
58791: LIST
58792: PPUSH
58793: CALL_OW 72
58797: PUSH
58798: LD_EXP 60
58802: PUSH
58803: LD_VAR 0 2
58807: ARRAY
58808: PPUSH
58809: LD_INT 30
58811: PUSH
58812: LD_INT 3
58814: PUSH
58815: EMPTY
58816: LIST
58817: LIST
58818: PPUSH
58819: CALL_OW 72
58823: PUSH
58824: LD_EXP 60
58828: PUSH
58829: LD_VAR 0 2
58833: ARRAY
58834: PPUSH
58835: LD_INT 2
58837: PUSH
58838: LD_INT 30
58840: PUSH
58841: LD_INT 6
58843: PUSH
58844: EMPTY
58845: LIST
58846: LIST
58847: PUSH
58848: LD_INT 30
58850: PUSH
58851: LD_INT 7
58853: PUSH
58854: EMPTY
58855: LIST
58856: LIST
58857: PUSH
58858: LD_INT 30
58860: PUSH
58861: LD_INT 8
58863: PUSH
58864: EMPTY
58865: LIST
58866: LIST
58867: PUSH
58868: EMPTY
58869: LIST
58870: LIST
58871: LIST
58872: LIST
58873: PPUSH
58874: CALL_OW 72
58878: PUSH
58879: EMPTY
58880: LIST
58881: LIST
58882: LIST
58883: LIST
58884: ST_TO_ADDR
// for j = 1 to 4 do
58885: LD_ADDR_VAR 0 3
58889: PUSH
58890: DOUBLE
58891: LD_INT 1
58893: DEC
58894: ST_TO_ADDR
58895: LD_INT 4
58897: PUSH
58898: FOR_TO
58899: IFFALSE 59090
// begin if not tmp [ j ] then
58901: LD_VAR 0 4
58905: PUSH
58906: LD_VAR 0 3
58910: ARRAY
58911: NOT
58912: IFFALSE 58916
// continue ;
58914: GO 58898
// for p in tmp [ j ] do
58916: LD_ADDR_VAR 0 5
58920: PUSH
58921: LD_VAR 0 4
58925: PUSH
58926: LD_VAR 0 3
58930: ARRAY
58931: PUSH
58932: FOR_IN
58933: IFFALSE 59086
// begin if not b [ j ] then
58935: LD_VAR 0 6
58939: PUSH
58940: LD_VAR 0 3
58944: ARRAY
58945: NOT
58946: IFFALSE 58950
// break ;
58948: GO 59086
// e := 0 ;
58950: LD_ADDR_VAR 0 7
58954: PUSH
58955: LD_INT 0
58957: ST_TO_ADDR
// for k in b [ j ] do
58958: LD_ADDR_VAR 0 8
58962: PUSH
58963: LD_VAR 0 6
58967: PUSH
58968: LD_VAR 0 3
58972: ARRAY
58973: PUSH
58974: FOR_IN
58975: IFFALSE 59002
// if IsNotFull ( k ) then
58977: LD_VAR 0 8
58981: PPUSH
58982: CALL 17031 0 1
58986: IFFALSE 59000
// begin e := k ;
58988: LD_ADDR_VAR 0 7
58992: PUSH
58993: LD_VAR 0 8
58997: ST_TO_ADDR
// break ;
58998: GO 59002
// end ;
59000: GO 58974
59002: POP
59003: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59004: LD_VAR 0 7
59008: PUSH
59009: LD_VAR 0 5
59013: PPUSH
59014: LD_VAR 0 7
59018: PPUSH
59019: CALL 50195 0 2
59023: NOT
59024: AND
59025: IFFALSE 59084
// begin if IsInUnit ( p ) then
59027: LD_VAR 0 5
59031: PPUSH
59032: CALL_OW 310
59036: IFFALSE 59047
// ComExitBuilding ( p ) ;
59038: LD_VAR 0 5
59042: PPUSH
59043: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59047: LD_VAR 0 5
59051: PPUSH
59052: LD_VAR 0 7
59056: PPUSH
59057: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59061: LD_VAR 0 5
59065: PPUSH
59066: LD_VAR 0 3
59070: PPUSH
59071: CALL_OW 183
// AddComExitBuilding ( p ) ;
59075: LD_VAR 0 5
59079: PPUSH
59080: CALL_OW 182
// end ; end ;
59084: GO 58932
59086: POP
59087: POP
// end ;
59088: GO 58898
59090: POP
59091: POP
// end ;
59092: GO 58653
59094: POP
59095: POP
// end ;
59096: LD_VAR 0 1
59100: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59101: LD_INT 0
59103: PPUSH
59104: PPUSH
59105: PPUSH
59106: PPUSH
59107: PPUSH
59108: PPUSH
59109: PPUSH
59110: PPUSH
59111: PPUSH
59112: PPUSH
59113: PPUSH
59114: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59115: LD_VAR 0 1
59119: NOT
59120: PUSH
59121: LD_EXP 60
59125: PUSH
59126: LD_VAR 0 1
59130: ARRAY
59131: NOT
59132: OR
59133: PUSH
59134: LD_EXP 60
59138: PUSH
59139: LD_VAR 0 1
59143: ARRAY
59144: PPUSH
59145: LD_INT 2
59147: PUSH
59148: LD_INT 30
59150: PUSH
59151: LD_INT 0
59153: PUSH
59154: EMPTY
59155: LIST
59156: LIST
59157: PUSH
59158: LD_INT 30
59160: PUSH
59161: LD_INT 1
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: PUSH
59168: EMPTY
59169: LIST
59170: LIST
59171: LIST
59172: PPUSH
59173: CALL_OW 72
59177: NOT
59178: OR
59179: IFFALSE 59183
// exit ;
59181: GO 62686
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59183: LD_ADDR_VAR 0 4
59187: PUSH
59188: LD_EXP 60
59192: PUSH
59193: LD_VAR 0 1
59197: ARRAY
59198: PPUSH
59199: LD_INT 2
59201: PUSH
59202: LD_INT 25
59204: PUSH
59205: LD_INT 1
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PUSH
59212: LD_INT 25
59214: PUSH
59215: LD_INT 2
59217: PUSH
59218: EMPTY
59219: LIST
59220: LIST
59221: PUSH
59222: LD_INT 25
59224: PUSH
59225: LD_INT 3
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: PUSH
59232: LD_INT 25
59234: PUSH
59235: LD_INT 4
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: PUSH
59242: LD_INT 25
59244: PUSH
59245: LD_INT 5
59247: PUSH
59248: EMPTY
59249: LIST
59250: LIST
59251: PUSH
59252: LD_INT 25
59254: PUSH
59255: LD_INT 8
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PUSH
59262: LD_INT 25
59264: PUSH
59265: LD_INT 9
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PUSH
59272: EMPTY
59273: LIST
59274: LIST
59275: LIST
59276: LIST
59277: LIST
59278: LIST
59279: LIST
59280: LIST
59281: PPUSH
59282: CALL_OW 72
59286: ST_TO_ADDR
// if not tmp then
59287: LD_VAR 0 4
59291: NOT
59292: IFFALSE 59296
// exit ;
59294: GO 62686
// for i in tmp do
59296: LD_ADDR_VAR 0 3
59300: PUSH
59301: LD_VAR 0 4
59305: PUSH
59306: FOR_IN
59307: IFFALSE 59338
// if GetTag ( i ) then
59309: LD_VAR 0 3
59313: PPUSH
59314: CALL_OW 110
59318: IFFALSE 59336
// tmp := tmp diff i ;
59320: LD_ADDR_VAR 0 4
59324: PUSH
59325: LD_VAR 0 4
59329: PUSH
59330: LD_VAR 0 3
59334: DIFF
59335: ST_TO_ADDR
59336: GO 59306
59338: POP
59339: POP
// if not tmp then
59340: LD_VAR 0 4
59344: NOT
59345: IFFALSE 59349
// exit ;
59347: GO 62686
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59349: LD_ADDR_VAR 0 5
59353: PUSH
59354: LD_EXP 60
59358: PUSH
59359: LD_VAR 0 1
59363: ARRAY
59364: PPUSH
59365: LD_INT 2
59367: PUSH
59368: LD_INT 25
59370: PUSH
59371: LD_INT 1
59373: PUSH
59374: EMPTY
59375: LIST
59376: LIST
59377: PUSH
59378: LD_INT 25
59380: PUSH
59381: LD_INT 5
59383: PUSH
59384: EMPTY
59385: LIST
59386: LIST
59387: PUSH
59388: LD_INT 25
59390: PUSH
59391: LD_INT 8
59393: PUSH
59394: EMPTY
59395: LIST
59396: LIST
59397: PUSH
59398: LD_INT 25
59400: PUSH
59401: LD_INT 9
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: LIST
59412: LIST
59413: LIST
59414: PPUSH
59415: CALL_OW 72
59419: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59420: LD_ADDR_VAR 0 6
59424: PUSH
59425: LD_EXP 60
59429: PUSH
59430: LD_VAR 0 1
59434: ARRAY
59435: PPUSH
59436: LD_INT 25
59438: PUSH
59439: LD_INT 2
59441: PUSH
59442: EMPTY
59443: LIST
59444: LIST
59445: PPUSH
59446: CALL_OW 72
59450: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59451: LD_ADDR_VAR 0 7
59455: PUSH
59456: LD_EXP 60
59460: PUSH
59461: LD_VAR 0 1
59465: ARRAY
59466: PPUSH
59467: LD_INT 25
59469: PUSH
59470: LD_INT 3
59472: PUSH
59473: EMPTY
59474: LIST
59475: LIST
59476: PPUSH
59477: CALL_OW 72
59481: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
59482: LD_ADDR_VAR 0 8
59486: PUSH
59487: LD_EXP 60
59491: PUSH
59492: LD_VAR 0 1
59496: ARRAY
59497: PPUSH
59498: LD_INT 25
59500: PUSH
59501: LD_INT 4
59503: PUSH
59504: EMPTY
59505: LIST
59506: LIST
59507: PUSH
59508: LD_INT 24
59510: PUSH
59511: LD_INT 251
59513: PUSH
59514: EMPTY
59515: LIST
59516: LIST
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: PPUSH
59522: CALL_OW 72
59526: ST_TO_ADDR
// if mc_is_defending [ base ] then
59527: LD_EXP 103
59531: PUSH
59532: LD_VAR 0 1
59536: ARRAY
59537: IFFALSE 59998
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
59539: LD_ADDR_EXP 102
59543: PUSH
59544: LD_EXP 102
59548: PPUSH
59549: LD_VAR 0 1
59553: PPUSH
59554: LD_INT 4
59556: PPUSH
59557: CALL_OW 1
59561: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
59562: LD_ADDR_VAR 0 12
59566: PUSH
59567: LD_EXP 60
59571: PUSH
59572: LD_VAR 0 1
59576: ARRAY
59577: PPUSH
59578: LD_INT 2
59580: PUSH
59581: LD_INT 30
59583: PUSH
59584: LD_INT 4
59586: PUSH
59587: EMPTY
59588: LIST
59589: LIST
59590: PUSH
59591: LD_INT 30
59593: PUSH
59594: LD_INT 5
59596: PUSH
59597: EMPTY
59598: LIST
59599: LIST
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: LIST
59605: PPUSH
59606: CALL_OW 72
59610: ST_TO_ADDR
// if not b then
59611: LD_VAR 0 12
59615: NOT
59616: IFFALSE 59620
// exit ;
59618: GO 62686
// p := [ ] ;
59620: LD_ADDR_VAR 0 11
59624: PUSH
59625: EMPTY
59626: ST_TO_ADDR
// if sci >= 2 then
59627: LD_VAR 0 8
59631: PUSH
59632: LD_INT 2
59634: GREATEREQUAL
59635: IFFALSE 59666
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
59637: LD_ADDR_VAR 0 8
59641: PUSH
59642: LD_VAR 0 8
59646: PUSH
59647: LD_INT 1
59649: ARRAY
59650: PUSH
59651: LD_VAR 0 8
59655: PUSH
59656: LD_INT 2
59658: ARRAY
59659: PUSH
59660: EMPTY
59661: LIST
59662: LIST
59663: ST_TO_ADDR
59664: GO 59727
// if sci = 1 then
59666: LD_VAR 0 8
59670: PUSH
59671: LD_INT 1
59673: EQUAL
59674: IFFALSE 59695
// sci := [ sci [ 1 ] ] else
59676: LD_ADDR_VAR 0 8
59680: PUSH
59681: LD_VAR 0 8
59685: PUSH
59686: LD_INT 1
59688: ARRAY
59689: PUSH
59690: EMPTY
59691: LIST
59692: ST_TO_ADDR
59693: GO 59727
// if sci = 0 then
59695: LD_VAR 0 8
59699: PUSH
59700: LD_INT 0
59702: EQUAL
59703: IFFALSE 59727
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
59705: LD_ADDR_VAR 0 11
59709: PUSH
59710: LD_VAR 0 4
59714: PPUSH
59715: LD_INT 4
59717: PPUSH
59718: CALL 50058 0 2
59722: PUSH
59723: LD_INT 1
59725: ARRAY
59726: ST_TO_ADDR
// if eng > 4 then
59727: LD_VAR 0 6
59731: PUSH
59732: LD_INT 4
59734: GREATER
59735: IFFALSE 59781
// for i = eng downto 4 do
59737: LD_ADDR_VAR 0 3
59741: PUSH
59742: DOUBLE
59743: LD_VAR 0 6
59747: INC
59748: ST_TO_ADDR
59749: LD_INT 4
59751: PUSH
59752: FOR_DOWNTO
59753: IFFALSE 59779
// eng := eng diff eng [ i ] ;
59755: LD_ADDR_VAR 0 6
59759: PUSH
59760: LD_VAR 0 6
59764: PUSH
59765: LD_VAR 0 6
59769: PUSH
59770: LD_VAR 0 3
59774: ARRAY
59775: DIFF
59776: ST_TO_ADDR
59777: GO 59752
59779: POP
59780: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
59781: LD_ADDR_VAR 0 4
59785: PUSH
59786: LD_VAR 0 4
59790: PUSH
59791: LD_VAR 0 5
59795: PUSH
59796: LD_VAR 0 6
59800: UNION
59801: PUSH
59802: LD_VAR 0 7
59806: UNION
59807: PUSH
59808: LD_VAR 0 8
59812: UNION
59813: DIFF
59814: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
59815: LD_ADDR_VAR 0 13
59819: PUSH
59820: LD_EXP 60
59824: PUSH
59825: LD_VAR 0 1
59829: ARRAY
59830: PPUSH
59831: LD_INT 2
59833: PUSH
59834: LD_INT 30
59836: PUSH
59837: LD_INT 32
59839: PUSH
59840: EMPTY
59841: LIST
59842: LIST
59843: PUSH
59844: LD_INT 30
59846: PUSH
59847: LD_INT 31
59849: PUSH
59850: EMPTY
59851: LIST
59852: LIST
59853: PUSH
59854: EMPTY
59855: LIST
59856: LIST
59857: LIST
59858: PPUSH
59859: CALL_OW 72
59863: PUSH
59864: LD_EXP 60
59868: PUSH
59869: LD_VAR 0 1
59873: ARRAY
59874: PPUSH
59875: LD_INT 2
59877: PUSH
59878: LD_INT 30
59880: PUSH
59881: LD_INT 4
59883: PUSH
59884: EMPTY
59885: LIST
59886: LIST
59887: PUSH
59888: LD_INT 30
59890: PUSH
59891: LD_INT 5
59893: PUSH
59894: EMPTY
59895: LIST
59896: LIST
59897: PUSH
59898: EMPTY
59899: LIST
59900: LIST
59901: LIST
59902: PPUSH
59903: CALL_OW 72
59907: PUSH
59908: LD_INT 6
59910: MUL
59911: PLUS
59912: ST_TO_ADDR
// if bcount < tmp then
59913: LD_VAR 0 13
59917: PUSH
59918: LD_VAR 0 4
59922: LESS
59923: IFFALSE 59969
// for i = tmp downto bcount do
59925: LD_ADDR_VAR 0 3
59929: PUSH
59930: DOUBLE
59931: LD_VAR 0 4
59935: INC
59936: ST_TO_ADDR
59937: LD_VAR 0 13
59941: PUSH
59942: FOR_DOWNTO
59943: IFFALSE 59967
// tmp := Delete ( tmp , tmp ) ;
59945: LD_ADDR_VAR 0 4
59949: PUSH
59950: LD_VAR 0 4
59954: PPUSH
59955: LD_VAR 0 4
59959: PPUSH
59960: CALL_OW 3
59964: ST_TO_ADDR
59965: GO 59942
59967: POP
59968: POP
// result := [ tmp , 0 , 0 , p ] ;
59969: LD_ADDR_VAR 0 2
59973: PUSH
59974: LD_VAR 0 4
59978: PUSH
59979: LD_INT 0
59981: PUSH
59982: LD_INT 0
59984: PUSH
59985: LD_VAR 0 11
59989: PUSH
59990: EMPTY
59991: LIST
59992: LIST
59993: LIST
59994: LIST
59995: ST_TO_ADDR
// exit ;
59996: GO 62686
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
59998: LD_EXP 60
60002: PUSH
60003: LD_VAR 0 1
60007: ARRAY
60008: PPUSH
60009: LD_INT 2
60011: PUSH
60012: LD_INT 30
60014: PUSH
60015: LD_INT 6
60017: PUSH
60018: EMPTY
60019: LIST
60020: LIST
60021: PUSH
60022: LD_INT 30
60024: PUSH
60025: LD_INT 7
60027: PUSH
60028: EMPTY
60029: LIST
60030: LIST
60031: PUSH
60032: LD_INT 30
60034: PUSH
60035: LD_INT 8
60037: PUSH
60038: EMPTY
60039: LIST
60040: LIST
60041: PUSH
60042: EMPTY
60043: LIST
60044: LIST
60045: LIST
60046: LIST
60047: PPUSH
60048: CALL_OW 72
60052: NOT
60053: PUSH
60054: LD_EXP 60
60058: PUSH
60059: LD_VAR 0 1
60063: ARRAY
60064: PPUSH
60065: LD_INT 30
60067: PUSH
60068: LD_INT 3
60070: PUSH
60071: EMPTY
60072: LIST
60073: LIST
60074: PPUSH
60075: CALL_OW 72
60079: NOT
60080: AND
60081: IFFALSE 60153
// begin if eng = tmp then
60083: LD_VAR 0 6
60087: PUSH
60088: LD_VAR 0 4
60092: EQUAL
60093: IFFALSE 60097
// exit ;
60095: GO 62686
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60097: LD_ADDR_EXP 102
60101: PUSH
60102: LD_EXP 102
60106: PPUSH
60107: LD_VAR 0 1
60111: PPUSH
60112: LD_INT 1
60114: PPUSH
60115: CALL_OW 1
60119: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60120: LD_ADDR_VAR 0 2
60124: PUSH
60125: LD_INT 0
60127: PUSH
60128: LD_VAR 0 4
60132: PUSH
60133: LD_VAR 0 6
60137: DIFF
60138: PUSH
60139: LD_INT 0
60141: PUSH
60142: LD_INT 0
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: LIST
60149: LIST
60150: ST_TO_ADDR
// exit ;
60151: GO 62686
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60153: LD_EXP 87
60157: PUSH
60158: LD_EXP 86
60162: PUSH
60163: LD_VAR 0 1
60167: ARRAY
60168: ARRAY
60169: PUSH
60170: LD_EXP 60
60174: PUSH
60175: LD_VAR 0 1
60179: ARRAY
60180: PPUSH
60181: LD_INT 2
60183: PUSH
60184: LD_INT 30
60186: PUSH
60187: LD_INT 6
60189: PUSH
60190: EMPTY
60191: LIST
60192: LIST
60193: PUSH
60194: LD_INT 30
60196: PUSH
60197: LD_INT 7
60199: PUSH
60200: EMPTY
60201: LIST
60202: LIST
60203: PUSH
60204: LD_INT 30
60206: PUSH
60207: LD_INT 8
60209: PUSH
60210: EMPTY
60211: LIST
60212: LIST
60213: PUSH
60214: EMPTY
60215: LIST
60216: LIST
60217: LIST
60218: LIST
60219: PPUSH
60220: CALL_OW 72
60224: AND
60225: PUSH
60226: LD_EXP 60
60230: PUSH
60231: LD_VAR 0 1
60235: ARRAY
60236: PPUSH
60237: LD_INT 30
60239: PUSH
60240: LD_INT 3
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PPUSH
60247: CALL_OW 72
60251: NOT
60252: AND
60253: IFFALSE 60467
// begin if sci >= 6 then
60255: LD_VAR 0 8
60259: PUSH
60260: LD_INT 6
60262: GREATEREQUAL
60263: IFFALSE 60267
// exit ;
60265: GO 62686
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60267: LD_ADDR_EXP 102
60271: PUSH
60272: LD_EXP 102
60276: PPUSH
60277: LD_VAR 0 1
60281: PPUSH
60282: LD_INT 2
60284: PPUSH
60285: CALL_OW 1
60289: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60290: LD_ADDR_VAR 0 9
60294: PUSH
60295: LD_VAR 0 4
60299: PUSH
60300: LD_VAR 0 8
60304: DIFF
60305: PPUSH
60306: LD_INT 4
60308: PPUSH
60309: CALL 50058 0 2
60313: ST_TO_ADDR
// p := [ ] ;
60314: LD_ADDR_VAR 0 11
60318: PUSH
60319: EMPTY
60320: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60321: LD_VAR 0 8
60325: PUSH
60326: LD_INT 6
60328: LESS
60329: PUSH
60330: LD_VAR 0 9
60334: PUSH
60335: LD_INT 6
60337: GREATER
60338: AND
60339: IFFALSE 60420
// begin for i = 1 to 6 - sci do
60341: LD_ADDR_VAR 0 3
60345: PUSH
60346: DOUBLE
60347: LD_INT 1
60349: DEC
60350: ST_TO_ADDR
60351: LD_INT 6
60353: PUSH
60354: LD_VAR 0 8
60358: MINUS
60359: PUSH
60360: FOR_TO
60361: IFFALSE 60416
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60363: LD_ADDR_VAR 0 11
60367: PUSH
60368: LD_VAR 0 11
60372: PPUSH
60373: LD_VAR 0 11
60377: PUSH
60378: LD_INT 1
60380: PLUS
60381: PPUSH
60382: LD_VAR 0 9
60386: PUSH
60387: LD_INT 1
60389: ARRAY
60390: PPUSH
60391: CALL_OW 2
60395: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60396: LD_ADDR_VAR 0 9
60400: PUSH
60401: LD_VAR 0 9
60405: PPUSH
60406: LD_INT 1
60408: PPUSH
60409: CALL_OW 3
60413: ST_TO_ADDR
// end ;
60414: GO 60360
60416: POP
60417: POP
// end else
60418: GO 60440
// if sort then
60420: LD_VAR 0 9
60424: IFFALSE 60440
// p := sort [ 1 ] ;
60426: LD_ADDR_VAR 0 11
60430: PUSH
60431: LD_VAR 0 9
60435: PUSH
60436: LD_INT 1
60438: ARRAY
60439: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60440: LD_ADDR_VAR 0 2
60444: PUSH
60445: LD_INT 0
60447: PUSH
60448: LD_INT 0
60450: PUSH
60451: LD_INT 0
60453: PUSH
60454: LD_VAR 0 11
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: LIST
60463: LIST
60464: ST_TO_ADDR
// exit ;
60465: GO 62686
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60467: LD_EXP 87
60471: PUSH
60472: LD_EXP 86
60476: PUSH
60477: LD_VAR 0 1
60481: ARRAY
60482: ARRAY
60483: PUSH
60484: LD_EXP 60
60488: PUSH
60489: LD_VAR 0 1
60493: ARRAY
60494: PPUSH
60495: LD_INT 2
60497: PUSH
60498: LD_INT 30
60500: PUSH
60501: LD_INT 6
60503: PUSH
60504: EMPTY
60505: LIST
60506: LIST
60507: PUSH
60508: LD_INT 30
60510: PUSH
60511: LD_INT 7
60513: PUSH
60514: EMPTY
60515: LIST
60516: LIST
60517: PUSH
60518: LD_INT 30
60520: PUSH
60521: LD_INT 8
60523: PUSH
60524: EMPTY
60525: LIST
60526: LIST
60527: PUSH
60528: EMPTY
60529: LIST
60530: LIST
60531: LIST
60532: LIST
60533: PPUSH
60534: CALL_OW 72
60538: AND
60539: PUSH
60540: LD_EXP 60
60544: PUSH
60545: LD_VAR 0 1
60549: ARRAY
60550: PPUSH
60551: LD_INT 30
60553: PUSH
60554: LD_INT 3
60556: PUSH
60557: EMPTY
60558: LIST
60559: LIST
60560: PPUSH
60561: CALL_OW 72
60565: AND
60566: IFFALSE 61300
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
60568: LD_ADDR_EXP 102
60572: PUSH
60573: LD_EXP 102
60577: PPUSH
60578: LD_VAR 0 1
60582: PPUSH
60583: LD_INT 3
60585: PPUSH
60586: CALL_OW 1
60590: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
60591: LD_ADDR_VAR 0 2
60595: PUSH
60596: LD_INT 0
60598: PUSH
60599: LD_INT 0
60601: PUSH
60602: LD_INT 0
60604: PUSH
60605: LD_INT 0
60607: PUSH
60608: EMPTY
60609: LIST
60610: LIST
60611: LIST
60612: LIST
60613: ST_TO_ADDR
// if not eng then
60614: LD_VAR 0 6
60618: NOT
60619: IFFALSE 60682
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
60621: LD_ADDR_VAR 0 11
60625: PUSH
60626: LD_VAR 0 4
60630: PPUSH
60631: LD_INT 2
60633: PPUSH
60634: CALL 50058 0 2
60638: PUSH
60639: LD_INT 1
60641: ARRAY
60642: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
60643: LD_ADDR_VAR 0 2
60647: PUSH
60648: LD_VAR 0 2
60652: PPUSH
60653: LD_INT 2
60655: PPUSH
60656: LD_VAR 0 11
60660: PPUSH
60661: CALL_OW 1
60665: ST_TO_ADDR
// tmp := tmp diff p ;
60666: LD_ADDR_VAR 0 4
60670: PUSH
60671: LD_VAR 0 4
60675: PUSH
60676: LD_VAR 0 11
60680: DIFF
60681: ST_TO_ADDR
// end ; if tmp and sci < 6 then
60682: LD_VAR 0 4
60686: PUSH
60687: LD_VAR 0 8
60691: PUSH
60692: LD_INT 6
60694: LESS
60695: AND
60696: IFFALSE 60884
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
60698: LD_ADDR_VAR 0 9
60702: PUSH
60703: LD_VAR 0 4
60707: PUSH
60708: LD_VAR 0 8
60712: PUSH
60713: LD_VAR 0 7
60717: UNION
60718: DIFF
60719: PPUSH
60720: LD_INT 4
60722: PPUSH
60723: CALL 50058 0 2
60727: ST_TO_ADDR
// p := [ ] ;
60728: LD_ADDR_VAR 0 11
60732: PUSH
60733: EMPTY
60734: ST_TO_ADDR
// if sort then
60735: LD_VAR 0 9
60739: IFFALSE 60855
// for i = 1 to 6 - sci do
60741: LD_ADDR_VAR 0 3
60745: PUSH
60746: DOUBLE
60747: LD_INT 1
60749: DEC
60750: ST_TO_ADDR
60751: LD_INT 6
60753: PUSH
60754: LD_VAR 0 8
60758: MINUS
60759: PUSH
60760: FOR_TO
60761: IFFALSE 60853
// begin if i = sort then
60763: LD_VAR 0 3
60767: PUSH
60768: LD_VAR 0 9
60772: EQUAL
60773: IFFALSE 60777
// break ;
60775: GO 60853
// if GetClass ( i ) = 4 then
60777: LD_VAR 0 3
60781: PPUSH
60782: CALL_OW 257
60786: PUSH
60787: LD_INT 4
60789: EQUAL
60790: IFFALSE 60794
// continue ;
60792: GO 60760
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60794: LD_ADDR_VAR 0 11
60798: PUSH
60799: LD_VAR 0 11
60803: PPUSH
60804: LD_VAR 0 11
60808: PUSH
60809: LD_INT 1
60811: PLUS
60812: PPUSH
60813: LD_VAR 0 9
60817: PUSH
60818: LD_VAR 0 3
60822: ARRAY
60823: PPUSH
60824: CALL_OW 2
60828: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60829: LD_ADDR_VAR 0 4
60833: PUSH
60834: LD_VAR 0 4
60838: PUSH
60839: LD_VAR 0 9
60843: PUSH
60844: LD_VAR 0 3
60848: ARRAY
60849: DIFF
60850: ST_TO_ADDR
// end ;
60851: GO 60760
60853: POP
60854: POP
// if p then
60855: LD_VAR 0 11
60859: IFFALSE 60884
// result := Replace ( result , 4 , p ) ;
60861: LD_ADDR_VAR 0 2
60865: PUSH
60866: LD_VAR 0 2
60870: PPUSH
60871: LD_INT 4
60873: PPUSH
60874: LD_VAR 0 11
60878: PPUSH
60879: CALL_OW 1
60883: ST_TO_ADDR
// end ; if tmp and mech < 6 then
60884: LD_VAR 0 4
60888: PUSH
60889: LD_VAR 0 7
60893: PUSH
60894: LD_INT 6
60896: LESS
60897: AND
60898: IFFALSE 61086
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
60900: LD_ADDR_VAR 0 9
60904: PUSH
60905: LD_VAR 0 4
60909: PUSH
60910: LD_VAR 0 8
60914: PUSH
60915: LD_VAR 0 7
60919: UNION
60920: DIFF
60921: PPUSH
60922: LD_INT 3
60924: PPUSH
60925: CALL 50058 0 2
60929: ST_TO_ADDR
// p := [ ] ;
60930: LD_ADDR_VAR 0 11
60934: PUSH
60935: EMPTY
60936: ST_TO_ADDR
// if sort then
60937: LD_VAR 0 9
60941: IFFALSE 61057
// for i = 1 to 6 - mech do
60943: LD_ADDR_VAR 0 3
60947: PUSH
60948: DOUBLE
60949: LD_INT 1
60951: DEC
60952: ST_TO_ADDR
60953: LD_INT 6
60955: PUSH
60956: LD_VAR 0 7
60960: MINUS
60961: PUSH
60962: FOR_TO
60963: IFFALSE 61055
// begin if i = sort then
60965: LD_VAR 0 3
60969: PUSH
60970: LD_VAR 0 9
60974: EQUAL
60975: IFFALSE 60979
// break ;
60977: GO 61055
// if GetClass ( i ) = 3 then
60979: LD_VAR 0 3
60983: PPUSH
60984: CALL_OW 257
60988: PUSH
60989: LD_INT 3
60991: EQUAL
60992: IFFALSE 60996
// continue ;
60994: GO 60962
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60996: LD_ADDR_VAR 0 11
61000: PUSH
61001: LD_VAR 0 11
61005: PPUSH
61006: LD_VAR 0 11
61010: PUSH
61011: LD_INT 1
61013: PLUS
61014: PPUSH
61015: LD_VAR 0 9
61019: PUSH
61020: LD_VAR 0 3
61024: ARRAY
61025: PPUSH
61026: CALL_OW 2
61030: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61031: LD_ADDR_VAR 0 4
61035: PUSH
61036: LD_VAR 0 4
61040: PUSH
61041: LD_VAR 0 9
61045: PUSH
61046: LD_VAR 0 3
61050: ARRAY
61051: DIFF
61052: ST_TO_ADDR
// end ;
61053: GO 60962
61055: POP
61056: POP
// if p then
61057: LD_VAR 0 11
61061: IFFALSE 61086
// result := Replace ( result , 3 , p ) ;
61063: LD_ADDR_VAR 0 2
61067: PUSH
61068: LD_VAR 0 2
61072: PPUSH
61073: LD_INT 3
61075: PPUSH
61076: LD_VAR 0 11
61080: PPUSH
61081: CALL_OW 1
61085: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61086: LD_VAR 0 4
61090: PUSH
61091: LD_INT 6
61093: GREATER
61094: PUSH
61095: LD_VAR 0 6
61099: PUSH
61100: LD_INT 6
61102: LESS
61103: AND
61104: IFFALSE 61298
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61106: LD_ADDR_VAR 0 9
61110: PUSH
61111: LD_VAR 0 4
61115: PUSH
61116: LD_VAR 0 8
61120: PUSH
61121: LD_VAR 0 7
61125: UNION
61126: PUSH
61127: LD_VAR 0 6
61131: UNION
61132: DIFF
61133: PPUSH
61134: LD_INT 2
61136: PPUSH
61137: CALL 50058 0 2
61141: ST_TO_ADDR
// p := [ ] ;
61142: LD_ADDR_VAR 0 11
61146: PUSH
61147: EMPTY
61148: ST_TO_ADDR
// if sort then
61149: LD_VAR 0 9
61153: IFFALSE 61269
// for i = 1 to 6 - eng do
61155: LD_ADDR_VAR 0 3
61159: PUSH
61160: DOUBLE
61161: LD_INT 1
61163: DEC
61164: ST_TO_ADDR
61165: LD_INT 6
61167: PUSH
61168: LD_VAR 0 6
61172: MINUS
61173: PUSH
61174: FOR_TO
61175: IFFALSE 61267
// begin if i = sort then
61177: LD_VAR 0 3
61181: PUSH
61182: LD_VAR 0 9
61186: EQUAL
61187: IFFALSE 61191
// break ;
61189: GO 61267
// if GetClass ( i ) = 2 then
61191: LD_VAR 0 3
61195: PPUSH
61196: CALL_OW 257
61200: PUSH
61201: LD_INT 2
61203: EQUAL
61204: IFFALSE 61208
// continue ;
61206: GO 61174
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61208: LD_ADDR_VAR 0 11
61212: PUSH
61213: LD_VAR 0 11
61217: PPUSH
61218: LD_VAR 0 11
61222: PUSH
61223: LD_INT 1
61225: PLUS
61226: PPUSH
61227: LD_VAR 0 9
61231: PUSH
61232: LD_VAR 0 3
61236: ARRAY
61237: PPUSH
61238: CALL_OW 2
61242: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61243: LD_ADDR_VAR 0 4
61247: PUSH
61248: LD_VAR 0 4
61252: PUSH
61253: LD_VAR 0 9
61257: PUSH
61258: LD_VAR 0 3
61262: ARRAY
61263: DIFF
61264: ST_TO_ADDR
// end ;
61265: GO 61174
61267: POP
61268: POP
// if p then
61269: LD_VAR 0 11
61273: IFFALSE 61298
// result := Replace ( result , 2 , p ) ;
61275: LD_ADDR_VAR 0 2
61279: PUSH
61280: LD_VAR 0 2
61284: PPUSH
61285: LD_INT 2
61287: PPUSH
61288: LD_VAR 0 11
61292: PPUSH
61293: CALL_OW 1
61297: ST_TO_ADDR
// end ; exit ;
61298: GO 62686
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61300: LD_EXP 87
61304: PUSH
61305: LD_EXP 86
61309: PUSH
61310: LD_VAR 0 1
61314: ARRAY
61315: ARRAY
61316: NOT
61317: PUSH
61318: LD_EXP 60
61322: PUSH
61323: LD_VAR 0 1
61327: ARRAY
61328: PPUSH
61329: LD_INT 30
61331: PUSH
61332: LD_INT 3
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: PPUSH
61339: CALL_OW 72
61343: AND
61344: PUSH
61345: LD_EXP 65
61349: PUSH
61350: LD_VAR 0 1
61354: ARRAY
61355: AND
61356: IFFALSE 61964
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61358: LD_ADDR_EXP 102
61362: PUSH
61363: LD_EXP 102
61367: PPUSH
61368: LD_VAR 0 1
61372: PPUSH
61373: LD_INT 5
61375: PPUSH
61376: CALL_OW 1
61380: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61381: LD_ADDR_VAR 0 2
61385: PUSH
61386: LD_INT 0
61388: PUSH
61389: LD_INT 0
61391: PUSH
61392: LD_INT 0
61394: PUSH
61395: LD_INT 0
61397: PUSH
61398: EMPTY
61399: LIST
61400: LIST
61401: LIST
61402: LIST
61403: ST_TO_ADDR
// if sci > 1 then
61404: LD_VAR 0 8
61408: PUSH
61409: LD_INT 1
61411: GREATER
61412: IFFALSE 61440
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61414: LD_ADDR_VAR 0 4
61418: PUSH
61419: LD_VAR 0 4
61423: PUSH
61424: LD_VAR 0 8
61428: PUSH
61429: LD_VAR 0 8
61433: PUSH
61434: LD_INT 1
61436: ARRAY
61437: DIFF
61438: DIFF
61439: ST_TO_ADDR
// if tmp and not sci then
61440: LD_VAR 0 4
61444: PUSH
61445: LD_VAR 0 8
61449: NOT
61450: AND
61451: IFFALSE 61520
// begin sort := SortBySkill ( tmp , 4 ) ;
61453: LD_ADDR_VAR 0 9
61457: PUSH
61458: LD_VAR 0 4
61462: PPUSH
61463: LD_INT 4
61465: PPUSH
61466: CALL 50058 0 2
61470: ST_TO_ADDR
// if sort then
61471: LD_VAR 0 9
61475: IFFALSE 61491
// p := sort [ 1 ] ;
61477: LD_ADDR_VAR 0 11
61481: PUSH
61482: LD_VAR 0 9
61486: PUSH
61487: LD_INT 1
61489: ARRAY
61490: ST_TO_ADDR
// if p then
61491: LD_VAR 0 11
61495: IFFALSE 61520
// result := Replace ( result , 4 , p ) ;
61497: LD_ADDR_VAR 0 2
61501: PUSH
61502: LD_VAR 0 2
61506: PPUSH
61507: LD_INT 4
61509: PPUSH
61510: LD_VAR 0 11
61514: PPUSH
61515: CALL_OW 1
61519: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
61520: LD_ADDR_VAR 0 4
61524: PUSH
61525: LD_VAR 0 4
61529: PUSH
61530: LD_VAR 0 7
61534: DIFF
61535: ST_TO_ADDR
// if tmp and mech < 6 then
61536: LD_VAR 0 4
61540: PUSH
61541: LD_VAR 0 7
61545: PUSH
61546: LD_INT 6
61548: LESS
61549: AND
61550: IFFALSE 61738
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61552: LD_ADDR_VAR 0 9
61556: PUSH
61557: LD_VAR 0 4
61561: PUSH
61562: LD_VAR 0 8
61566: PUSH
61567: LD_VAR 0 7
61571: UNION
61572: DIFF
61573: PPUSH
61574: LD_INT 3
61576: PPUSH
61577: CALL 50058 0 2
61581: ST_TO_ADDR
// p := [ ] ;
61582: LD_ADDR_VAR 0 11
61586: PUSH
61587: EMPTY
61588: ST_TO_ADDR
// if sort then
61589: LD_VAR 0 9
61593: IFFALSE 61709
// for i = 1 to 6 - mech do
61595: LD_ADDR_VAR 0 3
61599: PUSH
61600: DOUBLE
61601: LD_INT 1
61603: DEC
61604: ST_TO_ADDR
61605: LD_INT 6
61607: PUSH
61608: LD_VAR 0 7
61612: MINUS
61613: PUSH
61614: FOR_TO
61615: IFFALSE 61707
// begin if i = sort then
61617: LD_VAR 0 3
61621: PUSH
61622: LD_VAR 0 9
61626: EQUAL
61627: IFFALSE 61631
// break ;
61629: GO 61707
// if GetClass ( i ) = 3 then
61631: LD_VAR 0 3
61635: PPUSH
61636: CALL_OW 257
61640: PUSH
61641: LD_INT 3
61643: EQUAL
61644: IFFALSE 61648
// continue ;
61646: GO 61614
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61648: LD_ADDR_VAR 0 11
61652: PUSH
61653: LD_VAR 0 11
61657: PPUSH
61658: LD_VAR 0 11
61662: PUSH
61663: LD_INT 1
61665: PLUS
61666: PPUSH
61667: LD_VAR 0 9
61671: PUSH
61672: LD_VAR 0 3
61676: ARRAY
61677: PPUSH
61678: CALL_OW 2
61682: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61683: LD_ADDR_VAR 0 4
61687: PUSH
61688: LD_VAR 0 4
61692: PUSH
61693: LD_VAR 0 9
61697: PUSH
61698: LD_VAR 0 3
61702: ARRAY
61703: DIFF
61704: ST_TO_ADDR
// end ;
61705: GO 61614
61707: POP
61708: POP
// if p then
61709: LD_VAR 0 11
61713: IFFALSE 61738
// result := Replace ( result , 3 , p ) ;
61715: LD_ADDR_VAR 0 2
61719: PUSH
61720: LD_VAR 0 2
61724: PPUSH
61725: LD_INT 3
61727: PPUSH
61728: LD_VAR 0 11
61732: PPUSH
61733: CALL_OW 1
61737: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
61738: LD_ADDR_VAR 0 4
61742: PUSH
61743: LD_VAR 0 4
61747: PUSH
61748: LD_VAR 0 6
61752: DIFF
61753: ST_TO_ADDR
// if tmp and eng < 6 then
61754: LD_VAR 0 4
61758: PUSH
61759: LD_VAR 0 6
61763: PUSH
61764: LD_INT 6
61766: LESS
61767: AND
61768: IFFALSE 61962
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61770: LD_ADDR_VAR 0 9
61774: PUSH
61775: LD_VAR 0 4
61779: PUSH
61780: LD_VAR 0 8
61784: PUSH
61785: LD_VAR 0 7
61789: UNION
61790: PUSH
61791: LD_VAR 0 6
61795: UNION
61796: DIFF
61797: PPUSH
61798: LD_INT 2
61800: PPUSH
61801: CALL 50058 0 2
61805: ST_TO_ADDR
// p := [ ] ;
61806: LD_ADDR_VAR 0 11
61810: PUSH
61811: EMPTY
61812: ST_TO_ADDR
// if sort then
61813: LD_VAR 0 9
61817: IFFALSE 61933
// for i = 1 to 6 - eng do
61819: LD_ADDR_VAR 0 3
61823: PUSH
61824: DOUBLE
61825: LD_INT 1
61827: DEC
61828: ST_TO_ADDR
61829: LD_INT 6
61831: PUSH
61832: LD_VAR 0 6
61836: MINUS
61837: PUSH
61838: FOR_TO
61839: IFFALSE 61931
// begin if i = sort then
61841: LD_VAR 0 3
61845: PUSH
61846: LD_VAR 0 9
61850: EQUAL
61851: IFFALSE 61855
// break ;
61853: GO 61931
// if GetClass ( i ) = 2 then
61855: LD_VAR 0 3
61859: PPUSH
61860: CALL_OW 257
61864: PUSH
61865: LD_INT 2
61867: EQUAL
61868: IFFALSE 61872
// continue ;
61870: GO 61838
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61872: LD_ADDR_VAR 0 11
61876: PUSH
61877: LD_VAR 0 11
61881: PPUSH
61882: LD_VAR 0 11
61886: PUSH
61887: LD_INT 1
61889: PLUS
61890: PPUSH
61891: LD_VAR 0 9
61895: PUSH
61896: LD_VAR 0 3
61900: ARRAY
61901: PPUSH
61902: CALL_OW 2
61906: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61907: LD_ADDR_VAR 0 4
61911: PUSH
61912: LD_VAR 0 4
61916: PUSH
61917: LD_VAR 0 9
61921: PUSH
61922: LD_VAR 0 3
61926: ARRAY
61927: DIFF
61928: ST_TO_ADDR
// end ;
61929: GO 61838
61931: POP
61932: POP
// if p then
61933: LD_VAR 0 11
61937: IFFALSE 61962
// result := Replace ( result , 2 , p ) ;
61939: LD_ADDR_VAR 0 2
61943: PUSH
61944: LD_VAR 0 2
61948: PPUSH
61949: LD_INT 2
61951: PPUSH
61952: LD_VAR 0 11
61956: PPUSH
61957: CALL_OW 1
61961: ST_TO_ADDR
// end ; exit ;
61962: GO 62686
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
61964: LD_EXP 87
61968: PUSH
61969: LD_EXP 86
61973: PUSH
61974: LD_VAR 0 1
61978: ARRAY
61979: ARRAY
61980: NOT
61981: PUSH
61982: LD_EXP 60
61986: PUSH
61987: LD_VAR 0 1
61991: ARRAY
61992: PPUSH
61993: LD_INT 30
61995: PUSH
61996: LD_INT 3
61998: PUSH
61999: EMPTY
62000: LIST
62001: LIST
62002: PPUSH
62003: CALL_OW 72
62007: AND
62008: PUSH
62009: LD_EXP 65
62013: PUSH
62014: LD_VAR 0 1
62018: ARRAY
62019: NOT
62020: AND
62021: IFFALSE 62686
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62023: LD_ADDR_EXP 102
62027: PUSH
62028: LD_EXP 102
62032: PPUSH
62033: LD_VAR 0 1
62037: PPUSH
62038: LD_INT 6
62040: PPUSH
62041: CALL_OW 1
62045: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62046: LD_ADDR_VAR 0 2
62050: PUSH
62051: LD_INT 0
62053: PUSH
62054: LD_INT 0
62056: PUSH
62057: LD_INT 0
62059: PUSH
62060: LD_INT 0
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: LIST
62067: LIST
62068: ST_TO_ADDR
// if sci >= 1 then
62069: LD_VAR 0 8
62073: PUSH
62074: LD_INT 1
62076: GREATEREQUAL
62077: IFFALSE 62099
// tmp := tmp diff sci [ 1 ] ;
62079: LD_ADDR_VAR 0 4
62083: PUSH
62084: LD_VAR 0 4
62088: PUSH
62089: LD_VAR 0 8
62093: PUSH
62094: LD_INT 1
62096: ARRAY
62097: DIFF
62098: ST_TO_ADDR
// if tmp and not sci then
62099: LD_VAR 0 4
62103: PUSH
62104: LD_VAR 0 8
62108: NOT
62109: AND
62110: IFFALSE 62179
// begin sort := SortBySkill ( tmp , 4 ) ;
62112: LD_ADDR_VAR 0 9
62116: PUSH
62117: LD_VAR 0 4
62121: PPUSH
62122: LD_INT 4
62124: PPUSH
62125: CALL 50058 0 2
62129: ST_TO_ADDR
// if sort then
62130: LD_VAR 0 9
62134: IFFALSE 62150
// p := sort [ 1 ] ;
62136: LD_ADDR_VAR 0 11
62140: PUSH
62141: LD_VAR 0 9
62145: PUSH
62146: LD_INT 1
62148: ARRAY
62149: ST_TO_ADDR
// if p then
62150: LD_VAR 0 11
62154: IFFALSE 62179
// result := Replace ( result , 4 , p ) ;
62156: LD_ADDR_VAR 0 2
62160: PUSH
62161: LD_VAR 0 2
62165: PPUSH
62166: LD_INT 4
62168: PPUSH
62169: LD_VAR 0 11
62173: PPUSH
62174: CALL_OW 1
62178: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62179: LD_ADDR_VAR 0 4
62183: PUSH
62184: LD_VAR 0 4
62188: PUSH
62189: LD_VAR 0 7
62193: DIFF
62194: ST_TO_ADDR
// if tmp and mech < 6 then
62195: LD_VAR 0 4
62199: PUSH
62200: LD_VAR 0 7
62204: PUSH
62205: LD_INT 6
62207: LESS
62208: AND
62209: IFFALSE 62391
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62211: LD_ADDR_VAR 0 9
62215: PUSH
62216: LD_VAR 0 4
62220: PUSH
62221: LD_VAR 0 7
62225: DIFF
62226: PPUSH
62227: LD_INT 3
62229: PPUSH
62230: CALL 50058 0 2
62234: ST_TO_ADDR
// p := [ ] ;
62235: LD_ADDR_VAR 0 11
62239: PUSH
62240: EMPTY
62241: ST_TO_ADDR
// if sort then
62242: LD_VAR 0 9
62246: IFFALSE 62362
// for i = 1 to 6 - mech do
62248: LD_ADDR_VAR 0 3
62252: PUSH
62253: DOUBLE
62254: LD_INT 1
62256: DEC
62257: ST_TO_ADDR
62258: LD_INT 6
62260: PUSH
62261: LD_VAR 0 7
62265: MINUS
62266: PUSH
62267: FOR_TO
62268: IFFALSE 62360
// begin if i = sort then
62270: LD_VAR 0 3
62274: PUSH
62275: LD_VAR 0 9
62279: EQUAL
62280: IFFALSE 62284
// break ;
62282: GO 62360
// if GetClass ( i ) = 3 then
62284: LD_VAR 0 3
62288: PPUSH
62289: CALL_OW 257
62293: PUSH
62294: LD_INT 3
62296: EQUAL
62297: IFFALSE 62301
// continue ;
62299: GO 62267
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62301: LD_ADDR_VAR 0 11
62305: PUSH
62306: LD_VAR 0 11
62310: PPUSH
62311: LD_VAR 0 11
62315: PUSH
62316: LD_INT 1
62318: PLUS
62319: PPUSH
62320: LD_VAR 0 9
62324: PUSH
62325: LD_VAR 0 3
62329: ARRAY
62330: PPUSH
62331: CALL_OW 2
62335: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62336: LD_ADDR_VAR 0 4
62340: PUSH
62341: LD_VAR 0 4
62345: PUSH
62346: LD_VAR 0 9
62350: PUSH
62351: LD_VAR 0 3
62355: ARRAY
62356: DIFF
62357: ST_TO_ADDR
// end ;
62358: GO 62267
62360: POP
62361: POP
// if p then
62362: LD_VAR 0 11
62366: IFFALSE 62391
// result := Replace ( result , 3 , p ) ;
62368: LD_ADDR_VAR 0 2
62372: PUSH
62373: LD_VAR 0 2
62377: PPUSH
62378: LD_INT 3
62380: PPUSH
62381: LD_VAR 0 11
62385: PPUSH
62386: CALL_OW 1
62390: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62391: LD_ADDR_VAR 0 4
62395: PUSH
62396: LD_VAR 0 4
62400: PUSH
62401: LD_VAR 0 6
62405: DIFF
62406: ST_TO_ADDR
// if tmp and eng < 4 then
62407: LD_VAR 0 4
62411: PUSH
62412: LD_VAR 0 6
62416: PUSH
62417: LD_INT 4
62419: LESS
62420: AND
62421: IFFALSE 62611
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62423: LD_ADDR_VAR 0 9
62427: PUSH
62428: LD_VAR 0 4
62432: PUSH
62433: LD_VAR 0 7
62437: PUSH
62438: LD_VAR 0 6
62442: UNION
62443: DIFF
62444: PPUSH
62445: LD_INT 2
62447: PPUSH
62448: CALL 50058 0 2
62452: ST_TO_ADDR
// p := [ ] ;
62453: LD_ADDR_VAR 0 11
62457: PUSH
62458: EMPTY
62459: ST_TO_ADDR
// if sort then
62460: LD_VAR 0 9
62464: IFFALSE 62580
// for i = 1 to 4 - eng do
62466: LD_ADDR_VAR 0 3
62470: PUSH
62471: DOUBLE
62472: LD_INT 1
62474: DEC
62475: ST_TO_ADDR
62476: LD_INT 4
62478: PUSH
62479: LD_VAR 0 6
62483: MINUS
62484: PUSH
62485: FOR_TO
62486: IFFALSE 62578
// begin if i = sort then
62488: LD_VAR 0 3
62492: PUSH
62493: LD_VAR 0 9
62497: EQUAL
62498: IFFALSE 62502
// break ;
62500: GO 62578
// if GetClass ( i ) = 2 then
62502: LD_VAR 0 3
62506: PPUSH
62507: CALL_OW 257
62511: PUSH
62512: LD_INT 2
62514: EQUAL
62515: IFFALSE 62519
// continue ;
62517: GO 62485
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62519: LD_ADDR_VAR 0 11
62523: PUSH
62524: LD_VAR 0 11
62528: PPUSH
62529: LD_VAR 0 11
62533: PUSH
62534: LD_INT 1
62536: PLUS
62537: PPUSH
62538: LD_VAR 0 9
62542: PUSH
62543: LD_VAR 0 3
62547: ARRAY
62548: PPUSH
62549: CALL_OW 2
62553: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62554: LD_ADDR_VAR 0 4
62558: PUSH
62559: LD_VAR 0 4
62563: PUSH
62564: LD_VAR 0 9
62568: PUSH
62569: LD_VAR 0 3
62573: ARRAY
62574: DIFF
62575: ST_TO_ADDR
// end ;
62576: GO 62485
62578: POP
62579: POP
// if p then
62580: LD_VAR 0 11
62584: IFFALSE 62609
// result := Replace ( result , 2 , p ) ;
62586: LD_ADDR_VAR 0 2
62590: PUSH
62591: LD_VAR 0 2
62595: PPUSH
62596: LD_INT 2
62598: PPUSH
62599: LD_VAR 0 11
62603: PPUSH
62604: CALL_OW 1
62608: ST_TO_ADDR
// end else
62609: GO 62655
// for i = eng downto 5 do
62611: LD_ADDR_VAR 0 3
62615: PUSH
62616: DOUBLE
62617: LD_VAR 0 6
62621: INC
62622: ST_TO_ADDR
62623: LD_INT 5
62625: PUSH
62626: FOR_DOWNTO
62627: IFFALSE 62653
// tmp := tmp union eng [ i ] ;
62629: LD_ADDR_VAR 0 4
62633: PUSH
62634: LD_VAR 0 4
62638: PUSH
62639: LD_VAR 0 6
62643: PUSH
62644: LD_VAR 0 3
62648: ARRAY
62649: UNION
62650: ST_TO_ADDR
62651: GO 62626
62653: POP
62654: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
62655: LD_ADDR_VAR 0 2
62659: PUSH
62660: LD_VAR 0 2
62664: PPUSH
62665: LD_INT 1
62667: PPUSH
62668: LD_VAR 0 4
62672: PUSH
62673: LD_VAR 0 5
62677: DIFF
62678: PPUSH
62679: CALL_OW 1
62683: ST_TO_ADDR
// exit ;
62684: GO 62686
// end ; end ;
62686: LD_VAR 0 2
62690: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
62691: LD_INT 0
62693: PPUSH
62694: PPUSH
62695: PPUSH
// if not mc_bases then
62696: LD_EXP 60
62700: NOT
62701: IFFALSE 62705
// exit ;
62703: GO 62847
// for i = 1 to mc_bases do
62705: LD_ADDR_VAR 0 2
62709: PUSH
62710: DOUBLE
62711: LD_INT 1
62713: DEC
62714: ST_TO_ADDR
62715: LD_EXP 60
62719: PUSH
62720: FOR_TO
62721: IFFALSE 62838
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
62723: LD_ADDR_VAR 0 3
62727: PUSH
62728: LD_EXP 60
62732: PUSH
62733: LD_VAR 0 2
62737: ARRAY
62738: PPUSH
62739: LD_INT 21
62741: PUSH
62742: LD_INT 3
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: PUSH
62749: LD_INT 3
62751: PUSH
62752: LD_INT 2
62754: PUSH
62755: LD_INT 30
62757: PUSH
62758: LD_INT 29
62760: PUSH
62761: EMPTY
62762: LIST
62763: LIST
62764: PUSH
62765: LD_INT 30
62767: PUSH
62768: LD_INT 30
62770: PUSH
62771: EMPTY
62772: LIST
62773: LIST
62774: PUSH
62775: EMPTY
62776: LIST
62777: LIST
62778: LIST
62779: PUSH
62780: EMPTY
62781: LIST
62782: LIST
62783: PUSH
62784: LD_INT 3
62786: PUSH
62787: LD_INT 24
62789: PUSH
62790: LD_INT 1000
62792: PUSH
62793: EMPTY
62794: LIST
62795: LIST
62796: PUSH
62797: EMPTY
62798: LIST
62799: LIST
62800: PUSH
62801: EMPTY
62802: LIST
62803: LIST
62804: LIST
62805: PPUSH
62806: CALL_OW 72
62810: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
62811: LD_ADDR_EXP 61
62815: PUSH
62816: LD_EXP 61
62820: PPUSH
62821: LD_VAR 0 2
62825: PPUSH
62826: LD_VAR 0 3
62830: PPUSH
62831: CALL_OW 1
62835: ST_TO_ADDR
// end ;
62836: GO 62720
62838: POP
62839: POP
// RaiseSailEvent ( 101 ) ;
62840: LD_INT 101
62842: PPUSH
62843: CALL_OW 427
// end ;
62847: LD_VAR 0 1
62851: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
62852: LD_INT 0
62854: PPUSH
62855: PPUSH
62856: PPUSH
62857: PPUSH
62858: PPUSH
62859: PPUSH
62860: PPUSH
// if not mc_bases then
62861: LD_EXP 60
62865: NOT
62866: IFFALSE 62870
// exit ;
62868: GO 63432
// for i = 1 to mc_bases do
62870: LD_ADDR_VAR 0 2
62874: PUSH
62875: DOUBLE
62876: LD_INT 1
62878: DEC
62879: ST_TO_ADDR
62880: LD_EXP 60
62884: PUSH
62885: FOR_TO
62886: IFFALSE 63423
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
62888: LD_ADDR_VAR 0 5
62892: PUSH
62893: LD_EXP 60
62897: PUSH
62898: LD_VAR 0 2
62902: ARRAY
62903: PUSH
62904: LD_EXP 89
62908: PUSH
62909: LD_VAR 0 2
62913: ARRAY
62914: UNION
62915: PPUSH
62916: LD_INT 21
62918: PUSH
62919: LD_INT 1
62921: PUSH
62922: EMPTY
62923: LIST
62924: LIST
62925: PUSH
62926: LD_INT 1
62928: PUSH
62929: LD_INT 3
62931: PUSH
62932: LD_INT 54
62934: PUSH
62935: EMPTY
62936: LIST
62937: PUSH
62938: EMPTY
62939: LIST
62940: LIST
62941: PUSH
62942: LD_INT 3
62944: PUSH
62945: LD_INT 24
62947: PUSH
62948: LD_INT 1000
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PUSH
62955: EMPTY
62956: LIST
62957: LIST
62958: PUSH
62959: EMPTY
62960: LIST
62961: LIST
62962: LIST
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: PPUSH
62968: CALL_OW 72
62972: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
62973: LD_ADDR_VAR 0 6
62977: PUSH
62978: LD_EXP 60
62982: PUSH
62983: LD_VAR 0 2
62987: ARRAY
62988: PPUSH
62989: LD_INT 21
62991: PUSH
62992: LD_INT 1
62994: PUSH
62995: EMPTY
62996: LIST
62997: LIST
62998: PUSH
62999: LD_INT 1
63001: PUSH
63002: LD_INT 3
63004: PUSH
63005: LD_INT 54
63007: PUSH
63008: EMPTY
63009: LIST
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PUSH
63015: LD_INT 3
63017: PUSH
63018: LD_INT 24
63020: PUSH
63021: LD_INT 250
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: LIST
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PPUSH
63041: CALL_OW 72
63045: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63046: LD_ADDR_VAR 0 7
63050: PUSH
63051: LD_VAR 0 5
63055: PUSH
63056: LD_VAR 0 6
63060: DIFF
63061: ST_TO_ADDR
// if not need_heal_1 then
63062: LD_VAR 0 6
63066: NOT
63067: IFFALSE 63100
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63069: LD_ADDR_EXP 63
63073: PUSH
63074: LD_EXP 63
63078: PPUSH
63079: LD_VAR 0 2
63083: PUSH
63084: LD_INT 1
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PPUSH
63091: EMPTY
63092: PPUSH
63093: CALL 19801 0 3
63097: ST_TO_ADDR
63098: GO 63170
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63100: LD_ADDR_EXP 63
63104: PUSH
63105: LD_EXP 63
63109: PPUSH
63110: LD_VAR 0 2
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PPUSH
63122: LD_EXP 63
63126: PUSH
63127: LD_VAR 0 2
63131: ARRAY
63132: PUSH
63133: LD_INT 1
63135: ARRAY
63136: PPUSH
63137: LD_INT 3
63139: PUSH
63140: LD_INT 24
63142: PUSH
63143: LD_INT 1000
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: PUSH
63150: EMPTY
63151: LIST
63152: LIST
63153: PPUSH
63154: CALL_OW 72
63158: PUSH
63159: LD_VAR 0 6
63163: UNION
63164: PPUSH
63165: CALL 19801 0 3
63169: ST_TO_ADDR
// if not need_heal_2 then
63170: LD_VAR 0 7
63174: NOT
63175: IFFALSE 63208
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63177: LD_ADDR_EXP 63
63181: PUSH
63182: LD_EXP 63
63186: PPUSH
63187: LD_VAR 0 2
63191: PUSH
63192: LD_INT 2
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PPUSH
63199: EMPTY
63200: PPUSH
63201: CALL 19801 0 3
63205: ST_TO_ADDR
63206: GO 63240
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63208: LD_ADDR_EXP 63
63212: PUSH
63213: LD_EXP 63
63217: PPUSH
63218: LD_VAR 0 2
63222: PUSH
63223: LD_INT 2
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PPUSH
63230: LD_VAR 0 7
63234: PPUSH
63235: CALL 19801 0 3
63239: ST_TO_ADDR
// if need_heal_2 then
63240: LD_VAR 0 7
63244: IFFALSE 63405
// for j in need_heal_2 do
63246: LD_ADDR_VAR 0 3
63250: PUSH
63251: LD_VAR 0 7
63255: PUSH
63256: FOR_IN
63257: IFFALSE 63403
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63259: LD_ADDR_VAR 0 5
63263: PUSH
63264: LD_EXP 60
63268: PUSH
63269: LD_VAR 0 2
63273: ARRAY
63274: PPUSH
63275: LD_INT 2
63277: PUSH
63278: LD_INT 30
63280: PUSH
63281: LD_INT 6
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: PUSH
63288: LD_INT 30
63290: PUSH
63291: LD_INT 7
63293: PUSH
63294: EMPTY
63295: LIST
63296: LIST
63297: PUSH
63298: LD_INT 30
63300: PUSH
63301: LD_INT 8
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 30
63310: PUSH
63311: LD_INT 0
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PUSH
63318: LD_INT 30
63320: PUSH
63321: LD_INT 1
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: PPUSH
63336: CALL_OW 72
63340: ST_TO_ADDR
// if tmp then
63341: LD_VAR 0 5
63345: IFFALSE 63401
// begin k := NearestUnitToUnit ( tmp , j ) ;
63347: LD_ADDR_VAR 0 4
63351: PUSH
63352: LD_VAR 0 5
63356: PPUSH
63357: LD_VAR 0 3
63361: PPUSH
63362: CALL_OW 74
63366: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63367: LD_VAR 0 3
63371: PPUSH
63372: LD_VAR 0 4
63376: PPUSH
63377: CALL_OW 296
63381: PUSH
63382: LD_INT 5
63384: GREATER
63385: IFFALSE 63401
// ComMoveToNearbyEntrance ( j , k ) ;
63387: LD_VAR 0 3
63391: PPUSH
63392: LD_VAR 0 4
63396: PPUSH
63397: CALL 52419 0 2
// end ; end ;
63401: GO 63256
63403: POP
63404: POP
// if not need_heal_1 and not need_heal_2 then
63405: LD_VAR 0 6
63409: NOT
63410: PUSH
63411: LD_VAR 0 7
63415: NOT
63416: AND
63417: IFFALSE 63421
// continue ;
63419: GO 62885
// end ;
63421: GO 62885
63423: POP
63424: POP
// RaiseSailEvent ( 102 ) ;
63425: LD_INT 102
63427: PPUSH
63428: CALL_OW 427
// end ;
63432: LD_VAR 0 1
63436: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63437: LD_INT 0
63439: PPUSH
63440: PPUSH
63441: PPUSH
63442: PPUSH
63443: PPUSH
63444: PPUSH
63445: PPUSH
63446: PPUSH
// if not mc_bases then
63447: LD_EXP 60
63451: NOT
63452: IFFALSE 63456
// exit ;
63454: GO 64339
// for i = 1 to mc_bases do
63456: LD_ADDR_VAR 0 2
63460: PUSH
63461: DOUBLE
63462: LD_INT 1
63464: DEC
63465: ST_TO_ADDR
63466: LD_EXP 60
63470: PUSH
63471: FOR_TO
63472: IFFALSE 64337
// begin if not mc_building_need_repair [ i ] then
63474: LD_EXP 61
63478: PUSH
63479: LD_VAR 0 2
63483: ARRAY
63484: NOT
63485: IFFALSE 63672
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
63487: LD_ADDR_VAR 0 6
63491: PUSH
63492: LD_EXP 79
63496: PUSH
63497: LD_VAR 0 2
63501: ARRAY
63502: PPUSH
63503: LD_INT 3
63505: PUSH
63506: LD_INT 24
63508: PUSH
63509: LD_INT 1000
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PUSH
63516: EMPTY
63517: LIST
63518: LIST
63519: PUSH
63520: LD_INT 2
63522: PUSH
63523: LD_INT 34
63525: PUSH
63526: LD_INT 13
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 34
63535: PUSH
63536: LD_INT 52
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 34
63545: PUSH
63546: LD_EXP 110
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: EMPTY
63556: LIST
63557: LIST
63558: LIST
63559: LIST
63560: PUSH
63561: EMPTY
63562: LIST
63563: LIST
63564: PPUSH
63565: CALL_OW 72
63569: ST_TO_ADDR
// if cranes then
63570: LD_VAR 0 6
63574: IFFALSE 63636
// for j in cranes do
63576: LD_ADDR_VAR 0 3
63580: PUSH
63581: LD_VAR 0 6
63585: PUSH
63586: FOR_IN
63587: IFFALSE 63634
// if not IsInArea ( j , mc_parking [ i ] ) then
63589: LD_VAR 0 3
63593: PPUSH
63594: LD_EXP 84
63598: PUSH
63599: LD_VAR 0 2
63603: ARRAY
63604: PPUSH
63605: CALL_OW 308
63609: NOT
63610: IFFALSE 63632
// ComMoveToArea ( j , mc_parking [ i ] ) ;
63612: LD_VAR 0 3
63616: PPUSH
63617: LD_EXP 84
63621: PUSH
63622: LD_VAR 0 2
63626: ARRAY
63627: PPUSH
63628: CALL_OW 113
63632: GO 63586
63634: POP
63635: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
63636: LD_ADDR_EXP 62
63640: PUSH
63641: LD_EXP 62
63645: PPUSH
63646: LD_VAR 0 2
63650: PPUSH
63651: EMPTY
63652: PPUSH
63653: CALL_OW 1
63657: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
63658: LD_VAR 0 2
63662: PPUSH
63663: LD_INT 101
63665: PPUSH
63666: CALL 58524 0 2
// continue ;
63670: GO 63471
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
63672: LD_ADDR_EXP 66
63676: PUSH
63677: LD_EXP 66
63681: PPUSH
63682: LD_VAR 0 2
63686: PPUSH
63687: EMPTY
63688: PPUSH
63689: CALL_OW 1
63693: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
63694: LD_VAR 0 2
63698: PPUSH
63699: LD_INT 103
63701: PPUSH
63702: CALL 58524 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
63706: LD_ADDR_VAR 0 5
63710: PUSH
63711: LD_EXP 60
63715: PUSH
63716: LD_VAR 0 2
63720: ARRAY
63721: PUSH
63722: LD_EXP 89
63726: PUSH
63727: LD_VAR 0 2
63731: ARRAY
63732: UNION
63733: PPUSH
63734: LD_INT 2
63736: PUSH
63737: LD_INT 25
63739: PUSH
63740: LD_INT 2
63742: PUSH
63743: EMPTY
63744: LIST
63745: LIST
63746: PUSH
63747: LD_INT 25
63749: PUSH
63750: LD_INT 16
63752: PUSH
63753: EMPTY
63754: LIST
63755: LIST
63756: PUSH
63757: EMPTY
63758: LIST
63759: LIST
63760: LIST
63761: PUSH
63762: EMPTY
63763: LIST
63764: PPUSH
63765: CALL_OW 72
63769: ST_TO_ADDR
// if mc_need_heal [ i ] then
63770: LD_EXP 63
63774: PUSH
63775: LD_VAR 0 2
63779: ARRAY
63780: IFFALSE 63824
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
63782: LD_ADDR_VAR 0 5
63786: PUSH
63787: LD_VAR 0 5
63791: PUSH
63792: LD_EXP 63
63796: PUSH
63797: LD_VAR 0 2
63801: ARRAY
63802: PUSH
63803: LD_INT 1
63805: ARRAY
63806: PUSH
63807: LD_EXP 63
63811: PUSH
63812: LD_VAR 0 2
63816: ARRAY
63817: PUSH
63818: LD_INT 2
63820: ARRAY
63821: UNION
63822: DIFF
63823: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
63824: LD_ADDR_VAR 0 6
63828: PUSH
63829: LD_EXP 79
63833: PUSH
63834: LD_VAR 0 2
63838: ARRAY
63839: PPUSH
63840: LD_INT 2
63842: PUSH
63843: LD_INT 34
63845: PUSH
63846: LD_INT 13
63848: PUSH
63849: EMPTY
63850: LIST
63851: LIST
63852: PUSH
63853: LD_INT 34
63855: PUSH
63856: LD_INT 52
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PUSH
63863: LD_INT 34
63865: PUSH
63866: LD_EXP 110
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: LIST
63879: LIST
63880: PPUSH
63881: CALL_OW 72
63885: ST_TO_ADDR
// if cranes then
63886: LD_VAR 0 6
63890: IFFALSE 64026
// begin for j in cranes do
63892: LD_ADDR_VAR 0 3
63896: PUSH
63897: LD_VAR 0 6
63901: PUSH
63902: FOR_IN
63903: IFFALSE 64024
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
63905: LD_VAR 0 3
63909: PPUSH
63910: CALL_OW 256
63914: PUSH
63915: LD_INT 1000
63917: EQUAL
63918: PUSH
63919: LD_VAR 0 3
63923: PPUSH
63924: CALL_OW 314
63928: NOT
63929: AND
63930: IFFALSE 63964
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
63932: LD_VAR 0 3
63936: PPUSH
63937: LD_EXP 61
63941: PUSH
63942: LD_VAR 0 2
63946: ARRAY
63947: PPUSH
63948: LD_VAR 0 3
63952: PPUSH
63953: CALL_OW 74
63957: PPUSH
63958: CALL_OW 130
63962: GO 64022
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
63964: LD_VAR 0 3
63968: PPUSH
63969: CALL_OW 256
63973: PUSH
63974: LD_INT 500
63976: LESS
63977: PUSH
63978: LD_VAR 0 3
63982: PPUSH
63983: LD_EXP 84
63987: PUSH
63988: LD_VAR 0 2
63992: ARRAY
63993: PPUSH
63994: CALL_OW 308
63998: NOT
63999: AND
64000: IFFALSE 64022
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64002: LD_VAR 0 3
64006: PPUSH
64007: LD_EXP 84
64011: PUSH
64012: LD_VAR 0 2
64016: ARRAY
64017: PPUSH
64018: CALL_OW 113
// end ;
64022: GO 63902
64024: POP
64025: POP
// end ; if tmp > 3 then
64026: LD_VAR 0 5
64030: PUSH
64031: LD_INT 3
64033: GREATER
64034: IFFALSE 64054
// tmp := ShrinkArray ( tmp , 4 ) ;
64036: LD_ADDR_VAR 0 5
64040: PUSH
64041: LD_VAR 0 5
64045: PPUSH
64046: LD_INT 4
64048: PPUSH
64049: CALL 51867 0 2
64053: ST_TO_ADDR
// if not tmp then
64054: LD_VAR 0 5
64058: NOT
64059: IFFALSE 64063
// continue ;
64061: GO 63471
// for j in tmp do
64063: LD_ADDR_VAR 0 3
64067: PUSH
64068: LD_VAR 0 5
64072: PUSH
64073: FOR_IN
64074: IFFALSE 64333
// begin if IsInUnit ( j ) then
64076: LD_VAR 0 3
64080: PPUSH
64081: CALL_OW 310
64085: IFFALSE 64096
// ComExitBuilding ( j ) ;
64087: LD_VAR 0 3
64091: PPUSH
64092: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64096: LD_VAR 0 3
64100: PUSH
64101: LD_EXP 62
64105: PUSH
64106: LD_VAR 0 2
64110: ARRAY
64111: IN
64112: NOT
64113: IFFALSE 64171
// begin SetTag ( j , 101 ) ;
64115: LD_VAR 0 3
64119: PPUSH
64120: LD_INT 101
64122: PPUSH
64123: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64127: LD_ADDR_EXP 62
64131: PUSH
64132: LD_EXP 62
64136: PPUSH
64137: LD_VAR 0 2
64141: PUSH
64142: LD_EXP 62
64146: PUSH
64147: LD_VAR 0 2
64151: ARRAY
64152: PUSH
64153: LD_INT 1
64155: PLUS
64156: PUSH
64157: EMPTY
64158: LIST
64159: LIST
64160: PPUSH
64161: LD_VAR 0 3
64165: PPUSH
64166: CALL 19801 0 3
64170: ST_TO_ADDR
// end ; wait ( 1 ) ;
64171: LD_INT 1
64173: PPUSH
64174: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64178: LD_ADDR_VAR 0 7
64182: PUSH
64183: LD_EXP 61
64187: PUSH
64188: LD_VAR 0 2
64192: ARRAY
64193: ST_TO_ADDR
// if mc_scan [ i ] then
64194: LD_EXP 83
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: IFFALSE 64266
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64206: LD_ADDR_VAR 0 7
64210: PUSH
64211: LD_EXP 61
64215: PUSH
64216: LD_VAR 0 2
64220: ARRAY
64221: PPUSH
64222: LD_INT 3
64224: PUSH
64225: LD_INT 30
64227: PUSH
64228: LD_INT 32
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: LD_INT 30
64237: PUSH
64238: LD_INT 33
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 30
64247: PUSH
64248: LD_INT 31
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: PPUSH
64261: CALL_OW 72
64265: ST_TO_ADDR
// if not to_repair_tmp then
64266: LD_VAR 0 7
64270: NOT
64271: IFFALSE 64275
// continue ;
64273: GO 64073
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64275: LD_ADDR_VAR 0 8
64279: PUSH
64280: LD_VAR 0 7
64284: PPUSH
64285: LD_VAR 0 3
64289: PPUSH
64290: CALL_OW 74
64294: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64295: LD_VAR 0 8
64299: PPUSH
64300: LD_INT 16
64302: PPUSH
64303: CALL 22400 0 2
64307: PUSH
64308: LD_INT 4
64310: ARRAY
64311: PUSH
64312: LD_INT 10
64314: LESS
64315: IFFALSE 64331
// ComRepairBuilding ( j , to_repair ) ;
64317: LD_VAR 0 3
64321: PPUSH
64322: LD_VAR 0 8
64326: PPUSH
64327: CALL_OW 130
// end ;
64331: GO 64073
64333: POP
64334: POP
// end ;
64335: GO 63471
64337: POP
64338: POP
// end ;
64339: LD_VAR 0 1
64343: RET
// export function MC_Heal ; var i , j , tmp ; begin
64344: LD_INT 0
64346: PPUSH
64347: PPUSH
64348: PPUSH
64349: PPUSH
// if not mc_bases then
64350: LD_EXP 60
64354: NOT
64355: IFFALSE 64359
// exit ;
64357: GO 64761
// for i = 1 to mc_bases do
64359: LD_ADDR_VAR 0 2
64363: PUSH
64364: DOUBLE
64365: LD_INT 1
64367: DEC
64368: ST_TO_ADDR
64369: LD_EXP 60
64373: PUSH
64374: FOR_TO
64375: IFFALSE 64759
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64377: LD_EXP 63
64381: PUSH
64382: LD_VAR 0 2
64386: ARRAY
64387: PUSH
64388: LD_INT 1
64390: ARRAY
64391: NOT
64392: PUSH
64393: LD_EXP 63
64397: PUSH
64398: LD_VAR 0 2
64402: ARRAY
64403: PUSH
64404: LD_INT 2
64406: ARRAY
64407: NOT
64408: AND
64409: IFFALSE 64447
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64411: LD_ADDR_EXP 64
64415: PUSH
64416: LD_EXP 64
64420: PPUSH
64421: LD_VAR 0 2
64425: PPUSH
64426: EMPTY
64427: PPUSH
64428: CALL_OW 1
64432: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64433: LD_VAR 0 2
64437: PPUSH
64438: LD_INT 102
64440: PPUSH
64441: CALL 58524 0 2
// continue ;
64445: GO 64374
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64447: LD_ADDR_VAR 0 4
64451: PUSH
64452: LD_EXP 60
64456: PUSH
64457: LD_VAR 0 2
64461: ARRAY
64462: PPUSH
64463: LD_INT 25
64465: PUSH
64466: LD_INT 4
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: PPUSH
64473: CALL_OW 72
64477: ST_TO_ADDR
// if not tmp then
64478: LD_VAR 0 4
64482: NOT
64483: IFFALSE 64487
// continue ;
64485: GO 64374
// if mc_taming [ i ] then
64487: LD_EXP 91
64491: PUSH
64492: LD_VAR 0 2
64496: ARRAY
64497: IFFALSE 64521
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
64499: LD_ADDR_EXP 91
64503: PUSH
64504: LD_EXP 91
64508: PPUSH
64509: LD_VAR 0 2
64513: PPUSH
64514: EMPTY
64515: PPUSH
64516: CALL_OW 1
64520: ST_TO_ADDR
// for j in tmp do
64521: LD_ADDR_VAR 0 3
64525: PUSH
64526: LD_VAR 0 4
64530: PUSH
64531: FOR_IN
64532: IFFALSE 64755
// begin if IsInUnit ( j ) then
64534: LD_VAR 0 3
64538: PPUSH
64539: CALL_OW 310
64543: IFFALSE 64554
// ComExitBuilding ( j ) ;
64545: LD_VAR 0 3
64549: PPUSH
64550: CALL_OW 122
// if not j in mc_healers [ i ] then
64554: LD_VAR 0 3
64558: PUSH
64559: LD_EXP 64
64563: PUSH
64564: LD_VAR 0 2
64568: ARRAY
64569: IN
64570: NOT
64571: IFFALSE 64617
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
64573: LD_ADDR_EXP 64
64577: PUSH
64578: LD_EXP 64
64582: PPUSH
64583: LD_VAR 0 2
64587: PUSH
64588: LD_EXP 64
64592: PUSH
64593: LD_VAR 0 2
64597: ARRAY
64598: PUSH
64599: LD_INT 1
64601: PLUS
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PPUSH
64607: LD_VAR 0 3
64611: PPUSH
64612: CALL 19801 0 3
64616: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
64617: LD_VAR 0 3
64621: PPUSH
64622: CALL_OW 110
64626: PUSH
64627: LD_INT 102
64629: NONEQUAL
64630: IFFALSE 64644
// SetTag ( j , 102 ) ;
64632: LD_VAR 0 3
64636: PPUSH
64637: LD_INT 102
64639: PPUSH
64640: CALL_OW 109
// Wait ( 3 ) ;
64644: LD_INT 3
64646: PPUSH
64647: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
64651: LD_EXP 63
64655: PUSH
64656: LD_VAR 0 2
64660: ARRAY
64661: PUSH
64662: LD_INT 1
64664: ARRAY
64665: IFFALSE 64697
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
64667: LD_VAR 0 3
64671: PPUSH
64672: LD_EXP 63
64676: PUSH
64677: LD_VAR 0 2
64681: ARRAY
64682: PUSH
64683: LD_INT 1
64685: ARRAY
64686: PUSH
64687: LD_INT 1
64689: ARRAY
64690: PPUSH
64691: CALL_OW 128
64695: GO 64753
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
64697: LD_VAR 0 3
64701: PPUSH
64702: CALL_OW 314
64706: NOT
64707: PUSH
64708: LD_EXP 63
64712: PUSH
64713: LD_VAR 0 2
64717: ARRAY
64718: PUSH
64719: LD_INT 2
64721: ARRAY
64722: AND
64723: IFFALSE 64753
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
64725: LD_VAR 0 3
64729: PPUSH
64730: LD_EXP 63
64734: PUSH
64735: LD_VAR 0 2
64739: ARRAY
64740: PUSH
64741: LD_INT 2
64743: ARRAY
64744: PUSH
64745: LD_INT 1
64747: ARRAY
64748: PPUSH
64749: CALL_OW 128
// end ;
64753: GO 64531
64755: POP
64756: POP
// end ;
64757: GO 64374
64759: POP
64760: POP
// end ;
64761: LD_VAR 0 1
64765: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
64766: LD_INT 0
64768: PPUSH
64769: PPUSH
64770: PPUSH
64771: PPUSH
64772: PPUSH
// if not mc_bases then
64773: LD_EXP 60
64777: NOT
64778: IFFALSE 64782
// exit ;
64780: GO 65953
// for i = 1 to mc_bases do
64782: LD_ADDR_VAR 0 2
64786: PUSH
64787: DOUBLE
64788: LD_INT 1
64790: DEC
64791: ST_TO_ADDR
64792: LD_EXP 60
64796: PUSH
64797: FOR_TO
64798: IFFALSE 65951
// begin if mc_scan [ i ] then
64800: LD_EXP 83
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: IFFALSE 64814
// continue ;
64812: GO 64797
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
64814: LD_EXP 65
64818: PUSH
64819: LD_VAR 0 2
64823: ARRAY
64824: NOT
64825: PUSH
64826: LD_EXP 67
64830: PUSH
64831: LD_VAR 0 2
64835: ARRAY
64836: NOT
64837: AND
64838: PUSH
64839: LD_EXP 66
64843: PUSH
64844: LD_VAR 0 2
64848: ARRAY
64849: AND
64850: IFFALSE 64888
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
64852: LD_ADDR_EXP 66
64856: PUSH
64857: LD_EXP 66
64861: PPUSH
64862: LD_VAR 0 2
64866: PPUSH
64867: EMPTY
64868: PPUSH
64869: CALL_OW 1
64873: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64874: LD_VAR 0 2
64878: PPUSH
64879: LD_INT 103
64881: PPUSH
64882: CALL 58524 0 2
// continue ;
64886: GO 64797
// end ; if mc_construct_list [ i ] then
64888: LD_EXP 67
64892: PUSH
64893: LD_VAR 0 2
64897: ARRAY
64898: IFFALSE 65118
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
64900: LD_ADDR_VAR 0 4
64904: PUSH
64905: LD_EXP 60
64909: PUSH
64910: LD_VAR 0 2
64914: ARRAY
64915: PPUSH
64916: LD_INT 25
64918: PUSH
64919: LD_INT 2
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PPUSH
64926: CALL_OW 72
64930: PUSH
64931: LD_EXP 62
64935: PUSH
64936: LD_VAR 0 2
64940: ARRAY
64941: DIFF
64942: ST_TO_ADDR
// if not tmp then
64943: LD_VAR 0 4
64947: NOT
64948: IFFALSE 64952
// continue ;
64950: GO 64797
// for j in tmp do
64952: LD_ADDR_VAR 0 3
64956: PUSH
64957: LD_VAR 0 4
64961: PUSH
64962: FOR_IN
64963: IFFALSE 65114
// begin if not mc_builders [ i ] then
64965: LD_EXP 66
64969: PUSH
64970: LD_VAR 0 2
64974: ARRAY
64975: NOT
64976: IFFALSE 65034
// begin SetTag ( j , 103 ) ;
64978: LD_VAR 0 3
64982: PPUSH
64983: LD_INT 103
64985: PPUSH
64986: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
64990: LD_ADDR_EXP 66
64994: PUSH
64995: LD_EXP 66
64999: PPUSH
65000: LD_VAR 0 2
65004: PUSH
65005: LD_EXP 66
65009: PUSH
65010: LD_VAR 0 2
65014: ARRAY
65015: PUSH
65016: LD_INT 1
65018: PLUS
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PPUSH
65024: LD_VAR 0 3
65028: PPUSH
65029: CALL 19801 0 3
65033: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65034: LD_VAR 0 3
65038: PPUSH
65039: CALL_OW 310
65043: IFFALSE 65054
// ComExitBuilding ( j ) ;
65045: LD_VAR 0 3
65049: PPUSH
65050: CALL_OW 122
// wait ( 3 ) ;
65054: LD_INT 3
65056: PPUSH
65057: CALL_OW 67
// if not mc_construct_list [ i ] then
65061: LD_EXP 67
65065: PUSH
65066: LD_VAR 0 2
65070: ARRAY
65071: NOT
65072: IFFALSE 65076
// break ;
65074: GO 65114
// if not HasTask ( j ) then
65076: LD_VAR 0 3
65080: PPUSH
65081: CALL_OW 314
65085: NOT
65086: IFFALSE 65112
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65088: LD_VAR 0 3
65092: PPUSH
65093: LD_EXP 67
65097: PUSH
65098: LD_VAR 0 2
65102: ARRAY
65103: PUSH
65104: LD_INT 1
65106: ARRAY
65107: PPUSH
65108: CALL 22664 0 2
// end ;
65112: GO 64962
65114: POP
65115: POP
// end else
65116: GO 65949
// if mc_build_list [ i ] then
65118: LD_EXP 65
65122: PUSH
65123: LD_VAR 0 2
65127: ARRAY
65128: IFFALSE 65949
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65130: LD_ADDR_VAR 0 5
65134: PUSH
65135: LD_EXP 60
65139: PUSH
65140: LD_VAR 0 2
65144: ARRAY
65145: PPUSH
65146: LD_INT 2
65148: PUSH
65149: LD_INT 30
65151: PUSH
65152: LD_INT 0
65154: PUSH
65155: EMPTY
65156: LIST
65157: LIST
65158: PUSH
65159: LD_INT 30
65161: PUSH
65162: LD_INT 1
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: EMPTY
65170: LIST
65171: LIST
65172: LIST
65173: PPUSH
65174: CALL_OW 72
65178: ST_TO_ADDR
// if depot then
65179: LD_VAR 0 5
65183: IFFALSE 65201
// depot := depot [ 1 ] else
65185: LD_ADDR_VAR 0 5
65189: PUSH
65190: LD_VAR 0 5
65194: PUSH
65195: LD_INT 1
65197: ARRAY
65198: ST_TO_ADDR
65199: GO 65209
// depot := 0 ;
65201: LD_ADDR_VAR 0 5
65205: PUSH
65206: LD_INT 0
65208: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65209: LD_EXP 65
65213: PUSH
65214: LD_VAR 0 2
65218: ARRAY
65219: PUSH
65220: LD_INT 1
65222: ARRAY
65223: PUSH
65224: LD_INT 1
65226: ARRAY
65227: PPUSH
65228: CALL 22488 0 1
65232: PUSH
65233: LD_EXP 60
65237: PUSH
65238: LD_VAR 0 2
65242: ARRAY
65243: PPUSH
65244: LD_INT 2
65246: PUSH
65247: LD_INT 30
65249: PUSH
65250: LD_INT 2
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 30
65259: PUSH
65260: LD_INT 3
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: EMPTY
65268: LIST
65269: LIST
65270: LIST
65271: PPUSH
65272: CALL_OW 72
65276: NOT
65277: AND
65278: IFFALSE 65383
// begin for j = 1 to mc_build_list [ i ] do
65280: LD_ADDR_VAR 0 3
65284: PUSH
65285: DOUBLE
65286: LD_INT 1
65288: DEC
65289: ST_TO_ADDR
65290: LD_EXP 65
65294: PUSH
65295: LD_VAR 0 2
65299: ARRAY
65300: PUSH
65301: FOR_TO
65302: IFFALSE 65381
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65304: LD_EXP 65
65308: PUSH
65309: LD_VAR 0 2
65313: ARRAY
65314: PUSH
65315: LD_VAR 0 3
65319: ARRAY
65320: PUSH
65321: LD_INT 1
65323: ARRAY
65324: PUSH
65325: LD_INT 2
65327: EQUAL
65328: IFFALSE 65379
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65330: LD_ADDR_EXP 65
65334: PUSH
65335: LD_EXP 65
65339: PPUSH
65340: LD_VAR 0 2
65344: PPUSH
65345: LD_EXP 65
65349: PUSH
65350: LD_VAR 0 2
65354: ARRAY
65355: PPUSH
65356: LD_VAR 0 3
65360: PPUSH
65361: LD_INT 1
65363: PPUSH
65364: LD_INT 0
65366: PPUSH
65367: CALL 19219 0 4
65371: PPUSH
65372: CALL_OW 1
65376: ST_TO_ADDR
// break ;
65377: GO 65381
// end ;
65379: GO 65301
65381: POP
65382: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65383: LD_EXP 65
65387: PUSH
65388: LD_VAR 0 2
65392: ARRAY
65393: PUSH
65394: LD_INT 1
65396: ARRAY
65397: PUSH
65398: LD_INT 1
65400: ARRAY
65401: PUSH
65402: LD_INT 0
65404: EQUAL
65405: PUSH
65406: LD_VAR 0 5
65410: PUSH
65411: LD_VAR 0 5
65415: PPUSH
65416: LD_EXP 65
65420: PUSH
65421: LD_VAR 0 2
65425: ARRAY
65426: PUSH
65427: LD_INT 1
65429: ARRAY
65430: PUSH
65431: LD_INT 1
65433: ARRAY
65434: PPUSH
65435: LD_EXP 65
65439: PUSH
65440: LD_VAR 0 2
65444: ARRAY
65445: PUSH
65446: LD_INT 1
65448: ARRAY
65449: PUSH
65450: LD_INT 2
65452: ARRAY
65453: PPUSH
65454: LD_EXP 65
65458: PUSH
65459: LD_VAR 0 2
65463: ARRAY
65464: PUSH
65465: LD_INT 1
65467: ARRAY
65468: PUSH
65469: LD_INT 3
65471: ARRAY
65472: PPUSH
65473: LD_EXP 65
65477: PUSH
65478: LD_VAR 0 2
65482: ARRAY
65483: PUSH
65484: LD_INT 1
65486: ARRAY
65487: PUSH
65488: LD_INT 4
65490: ARRAY
65491: PPUSH
65492: CALL 27904 0 5
65496: AND
65497: OR
65498: IFFALSE 65779
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65500: LD_ADDR_VAR 0 4
65504: PUSH
65505: LD_EXP 60
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PPUSH
65516: LD_INT 25
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PPUSH
65526: CALL_OW 72
65530: PUSH
65531: LD_EXP 62
65535: PUSH
65536: LD_VAR 0 2
65540: ARRAY
65541: DIFF
65542: ST_TO_ADDR
// if not tmp then
65543: LD_VAR 0 4
65547: NOT
65548: IFFALSE 65552
// continue ;
65550: GO 64797
// for j in tmp do
65552: LD_ADDR_VAR 0 3
65556: PUSH
65557: LD_VAR 0 4
65561: PUSH
65562: FOR_IN
65563: IFFALSE 65775
// begin if not mc_builders [ i ] then
65565: LD_EXP 66
65569: PUSH
65570: LD_VAR 0 2
65574: ARRAY
65575: NOT
65576: IFFALSE 65634
// begin SetTag ( j , 103 ) ;
65578: LD_VAR 0 3
65582: PPUSH
65583: LD_INT 103
65585: PPUSH
65586: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65590: LD_ADDR_EXP 66
65594: PUSH
65595: LD_EXP 66
65599: PPUSH
65600: LD_VAR 0 2
65604: PUSH
65605: LD_EXP 66
65609: PUSH
65610: LD_VAR 0 2
65614: ARRAY
65615: PUSH
65616: LD_INT 1
65618: PLUS
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PPUSH
65624: LD_VAR 0 3
65628: PPUSH
65629: CALL 19801 0 3
65633: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65634: LD_VAR 0 3
65638: PPUSH
65639: CALL_OW 310
65643: IFFALSE 65654
// ComExitBuilding ( j ) ;
65645: LD_VAR 0 3
65649: PPUSH
65650: CALL_OW 122
// wait ( 3 ) ;
65654: LD_INT 3
65656: PPUSH
65657: CALL_OW 67
// if not mc_build_list [ i ] then
65661: LD_EXP 65
65665: PUSH
65666: LD_VAR 0 2
65670: ARRAY
65671: NOT
65672: IFFALSE 65676
// break ;
65674: GO 65775
// if not HasTask ( j ) then
65676: LD_VAR 0 3
65680: PPUSH
65681: CALL_OW 314
65685: NOT
65686: IFFALSE 65773
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
65688: LD_VAR 0 3
65692: PPUSH
65693: LD_EXP 65
65697: PUSH
65698: LD_VAR 0 2
65702: ARRAY
65703: PUSH
65704: LD_INT 1
65706: ARRAY
65707: PUSH
65708: LD_INT 1
65710: ARRAY
65711: PPUSH
65712: LD_EXP 65
65716: PUSH
65717: LD_VAR 0 2
65721: ARRAY
65722: PUSH
65723: LD_INT 1
65725: ARRAY
65726: PUSH
65727: LD_INT 2
65729: ARRAY
65730: PPUSH
65731: LD_EXP 65
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: PUSH
65742: LD_INT 1
65744: ARRAY
65745: PUSH
65746: LD_INT 3
65748: ARRAY
65749: PPUSH
65750: LD_EXP 65
65754: PUSH
65755: LD_VAR 0 2
65759: ARRAY
65760: PUSH
65761: LD_INT 1
65763: ARRAY
65764: PUSH
65765: LD_INT 4
65767: ARRAY
65768: PPUSH
65769: CALL_OW 145
// end ;
65773: GO 65562
65775: POP
65776: POP
// end else
65777: GO 65949
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
65779: LD_EXP 60
65783: PUSH
65784: LD_VAR 0 2
65788: ARRAY
65789: PPUSH
65790: LD_EXP 65
65794: PUSH
65795: LD_VAR 0 2
65799: ARRAY
65800: PUSH
65801: LD_INT 1
65803: ARRAY
65804: PUSH
65805: LD_INT 1
65807: ARRAY
65808: PPUSH
65809: LD_EXP 65
65813: PUSH
65814: LD_VAR 0 2
65818: ARRAY
65819: PUSH
65820: LD_INT 1
65822: ARRAY
65823: PUSH
65824: LD_INT 2
65826: ARRAY
65827: PPUSH
65828: LD_EXP 65
65832: PUSH
65833: LD_VAR 0 2
65837: ARRAY
65838: PUSH
65839: LD_INT 1
65841: ARRAY
65842: PUSH
65843: LD_INT 3
65845: ARRAY
65846: PPUSH
65847: LD_EXP 65
65851: PUSH
65852: LD_VAR 0 2
65856: ARRAY
65857: PUSH
65858: LD_INT 1
65860: ARRAY
65861: PUSH
65862: LD_INT 4
65864: ARRAY
65865: PPUSH
65866: LD_EXP 60
65870: PUSH
65871: LD_VAR 0 2
65875: ARRAY
65876: PPUSH
65877: LD_INT 21
65879: PUSH
65880: LD_INT 3
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PPUSH
65887: CALL_OW 72
65891: PPUSH
65892: EMPTY
65893: PPUSH
65894: CALL 26654 0 7
65898: NOT
65899: IFFALSE 65949
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
65901: LD_ADDR_EXP 65
65905: PUSH
65906: LD_EXP 65
65910: PPUSH
65911: LD_VAR 0 2
65915: PPUSH
65916: LD_EXP 65
65920: PUSH
65921: LD_VAR 0 2
65925: ARRAY
65926: PPUSH
65927: LD_INT 1
65929: PPUSH
65930: LD_INT 1
65932: NEG
65933: PPUSH
65934: LD_INT 0
65936: PPUSH
65937: CALL 19219 0 4
65941: PPUSH
65942: CALL_OW 1
65946: ST_TO_ADDR
// continue ;
65947: GO 64797
// end ; end ; end ;
65949: GO 64797
65951: POP
65952: POP
// end ;
65953: LD_VAR 0 1
65957: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
65958: LD_INT 0
65960: PPUSH
65961: PPUSH
65962: PPUSH
65963: PPUSH
65964: PPUSH
65965: PPUSH
// if not mc_bases then
65966: LD_EXP 60
65970: NOT
65971: IFFALSE 65975
// exit ;
65973: GO 66402
// for i = 1 to mc_bases do
65975: LD_ADDR_VAR 0 2
65979: PUSH
65980: DOUBLE
65981: LD_INT 1
65983: DEC
65984: ST_TO_ADDR
65985: LD_EXP 60
65989: PUSH
65990: FOR_TO
65991: IFFALSE 66400
// begin tmp := mc_build_upgrade [ i ] ;
65993: LD_ADDR_VAR 0 4
65997: PUSH
65998: LD_EXP 92
66002: PUSH
66003: LD_VAR 0 2
66007: ARRAY
66008: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66009: LD_ADDR_VAR 0 6
66013: PUSH
66014: LD_EXP 93
66018: PUSH
66019: LD_VAR 0 2
66023: ARRAY
66024: PPUSH
66025: LD_INT 2
66027: PUSH
66028: LD_INT 30
66030: PUSH
66031: LD_INT 6
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 30
66040: PUSH
66041: LD_INT 7
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: EMPTY
66049: LIST
66050: LIST
66051: LIST
66052: PPUSH
66053: CALL_OW 72
66057: ST_TO_ADDR
// if not tmp and not lab then
66058: LD_VAR 0 4
66062: NOT
66063: PUSH
66064: LD_VAR 0 6
66068: NOT
66069: AND
66070: IFFALSE 66074
// continue ;
66072: GO 65990
// if tmp then
66074: LD_VAR 0 4
66078: IFFALSE 66198
// for j in tmp do
66080: LD_ADDR_VAR 0 3
66084: PUSH
66085: LD_VAR 0 4
66089: PUSH
66090: FOR_IN
66091: IFFALSE 66196
// begin if UpgradeCost ( j ) then
66093: LD_VAR 0 3
66097: PPUSH
66098: CALL 26314 0 1
66102: IFFALSE 66194
// begin ComUpgrade ( j ) ;
66104: LD_VAR 0 3
66108: PPUSH
66109: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66113: LD_ADDR_EXP 92
66117: PUSH
66118: LD_EXP 92
66122: PPUSH
66123: LD_VAR 0 2
66127: PPUSH
66128: LD_EXP 92
66132: PUSH
66133: LD_VAR 0 2
66137: ARRAY
66138: PUSH
66139: LD_VAR 0 3
66143: DIFF
66144: PPUSH
66145: CALL_OW 1
66149: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66150: LD_ADDR_EXP 67
66154: PUSH
66155: LD_EXP 67
66159: PPUSH
66160: LD_VAR 0 2
66164: PUSH
66165: LD_EXP 67
66169: PUSH
66170: LD_VAR 0 2
66174: ARRAY
66175: PUSH
66176: LD_INT 1
66178: PLUS
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PPUSH
66184: LD_VAR 0 3
66188: PPUSH
66189: CALL 19801 0 3
66193: ST_TO_ADDR
// end ; end ;
66194: GO 66090
66196: POP
66197: POP
// if not lab or not mc_lab_upgrade [ i ] then
66198: LD_VAR 0 6
66202: NOT
66203: PUSH
66204: LD_EXP 94
66208: PUSH
66209: LD_VAR 0 2
66213: ARRAY
66214: NOT
66215: OR
66216: IFFALSE 66220
// continue ;
66218: GO 65990
// for j in lab do
66220: LD_ADDR_VAR 0 3
66224: PUSH
66225: LD_VAR 0 6
66229: PUSH
66230: FOR_IN
66231: IFFALSE 66396
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66233: LD_VAR 0 3
66237: PPUSH
66238: CALL_OW 266
66242: PUSH
66243: LD_INT 6
66245: PUSH
66246: LD_INT 7
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: IN
66253: PUSH
66254: LD_VAR 0 3
66258: PPUSH
66259: CALL_OW 461
66263: PUSH
66264: LD_INT 1
66266: NONEQUAL
66267: AND
66268: IFFALSE 66394
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66270: LD_VAR 0 3
66274: PPUSH
66275: LD_EXP 94
66279: PUSH
66280: LD_VAR 0 2
66284: ARRAY
66285: PUSH
66286: LD_INT 1
66288: ARRAY
66289: PPUSH
66290: CALL 26519 0 2
66294: IFFALSE 66394
// begin ComCancel ( j ) ;
66296: LD_VAR 0 3
66300: PPUSH
66301: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66305: LD_VAR 0 3
66309: PPUSH
66310: LD_EXP 94
66314: PUSH
66315: LD_VAR 0 2
66319: ARRAY
66320: PUSH
66321: LD_INT 1
66323: ARRAY
66324: PPUSH
66325: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66329: LD_VAR 0 3
66333: PUSH
66334: LD_EXP 67
66338: PUSH
66339: LD_VAR 0 2
66343: ARRAY
66344: IN
66345: NOT
66346: IFFALSE 66392
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66348: LD_ADDR_EXP 67
66352: PUSH
66353: LD_EXP 67
66357: PPUSH
66358: LD_VAR 0 2
66362: PUSH
66363: LD_EXP 67
66367: PUSH
66368: LD_VAR 0 2
66372: ARRAY
66373: PUSH
66374: LD_INT 1
66376: PLUS
66377: PUSH
66378: EMPTY
66379: LIST
66380: LIST
66381: PPUSH
66382: LD_VAR 0 3
66386: PPUSH
66387: CALL 19801 0 3
66391: ST_TO_ADDR
// break ;
66392: GO 66396
// end ; end ; end ;
66394: GO 66230
66396: POP
66397: POP
// end ;
66398: GO 65990
66400: POP
66401: POP
// end ;
66402: LD_VAR 0 1
66406: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66407: LD_INT 0
66409: PPUSH
66410: PPUSH
66411: PPUSH
66412: PPUSH
66413: PPUSH
66414: PPUSH
66415: PPUSH
66416: PPUSH
66417: PPUSH
// if not mc_bases then
66418: LD_EXP 60
66422: NOT
66423: IFFALSE 66427
// exit ;
66425: GO 66832
// for i = 1 to mc_bases do
66427: LD_ADDR_VAR 0 2
66431: PUSH
66432: DOUBLE
66433: LD_INT 1
66435: DEC
66436: ST_TO_ADDR
66437: LD_EXP 60
66441: PUSH
66442: FOR_TO
66443: IFFALSE 66830
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66445: LD_EXP 68
66449: PUSH
66450: LD_VAR 0 2
66454: ARRAY
66455: NOT
66456: PUSH
66457: LD_EXP 60
66461: PUSH
66462: LD_VAR 0 2
66466: ARRAY
66467: PPUSH
66468: LD_INT 30
66470: PUSH
66471: LD_INT 3
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: PPUSH
66478: CALL_OW 72
66482: NOT
66483: OR
66484: IFFALSE 66488
// continue ;
66486: GO 66442
// busy := false ;
66488: LD_ADDR_VAR 0 8
66492: PUSH
66493: LD_INT 0
66495: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66496: LD_ADDR_VAR 0 4
66500: PUSH
66501: LD_EXP 60
66505: PUSH
66506: LD_VAR 0 2
66510: ARRAY
66511: PPUSH
66512: LD_INT 30
66514: PUSH
66515: LD_INT 3
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: PPUSH
66522: CALL_OW 72
66526: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
66527: LD_ADDR_VAR 0 6
66531: PUSH
66532: LD_EXP 68
66536: PUSH
66537: LD_VAR 0 2
66541: ARRAY
66542: PPUSH
66543: LD_INT 2
66545: PUSH
66546: LD_INT 30
66548: PUSH
66549: LD_INT 32
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 30
66558: PUSH
66559: LD_INT 33
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: EMPTY
66567: LIST
66568: LIST
66569: LIST
66570: PPUSH
66571: CALL_OW 72
66575: ST_TO_ADDR
// if not t then
66576: LD_VAR 0 6
66580: NOT
66581: IFFALSE 66585
// continue ;
66583: GO 66442
// for j in tmp do
66585: LD_ADDR_VAR 0 3
66589: PUSH
66590: LD_VAR 0 4
66594: PUSH
66595: FOR_IN
66596: IFFALSE 66626
// if not BuildingStatus ( j ) = bs_idle then
66598: LD_VAR 0 3
66602: PPUSH
66603: CALL_OW 461
66607: PUSH
66608: LD_INT 2
66610: EQUAL
66611: NOT
66612: IFFALSE 66624
// begin busy := true ;
66614: LD_ADDR_VAR 0 8
66618: PUSH
66619: LD_INT 1
66621: ST_TO_ADDR
// break ;
66622: GO 66626
// end ;
66624: GO 66595
66626: POP
66627: POP
// if busy then
66628: LD_VAR 0 8
66632: IFFALSE 66636
// continue ;
66634: GO 66442
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
66636: LD_ADDR_VAR 0 7
66640: PUSH
66641: LD_VAR 0 6
66645: PPUSH
66646: LD_INT 35
66648: PUSH
66649: LD_INT 0
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PPUSH
66656: CALL_OW 72
66660: ST_TO_ADDR
// if tw then
66661: LD_VAR 0 7
66665: IFFALSE 66742
// begin tw := tw [ 1 ] ;
66667: LD_ADDR_VAR 0 7
66671: PUSH
66672: LD_VAR 0 7
66676: PUSH
66677: LD_INT 1
66679: ARRAY
66680: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
66681: LD_ADDR_VAR 0 9
66685: PUSH
66686: LD_VAR 0 7
66690: PPUSH
66691: LD_EXP 85
66695: PUSH
66696: LD_VAR 0 2
66700: ARRAY
66701: PPUSH
66702: CALL 24811 0 2
66706: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
66707: LD_EXP 99
66711: PUSH
66712: LD_VAR 0 2
66716: ARRAY
66717: IFFALSE 66740
// if not weapon in mc_allowed_tower_weapons [ i ] then
66719: LD_VAR 0 9
66723: PUSH
66724: LD_EXP 99
66728: PUSH
66729: LD_VAR 0 2
66733: ARRAY
66734: IN
66735: NOT
66736: IFFALSE 66740
// continue ;
66738: GO 66442
// end else
66740: GO 66805
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
66742: LD_ADDR_VAR 0 5
66746: PUSH
66747: LD_EXP 68
66751: PUSH
66752: LD_VAR 0 2
66756: ARRAY
66757: PPUSH
66758: LD_VAR 0 4
66762: PPUSH
66763: CALL 51100 0 2
66767: ST_TO_ADDR
// if not tmp2 then
66768: LD_VAR 0 5
66772: NOT
66773: IFFALSE 66777
// continue ;
66775: GO 66442
// tw := tmp2 [ 1 ] ;
66777: LD_ADDR_VAR 0 7
66781: PUSH
66782: LD_VAR 0 5
66786: PUSH
66787: LD_INT 1
66789: ARRAY
66790: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
66791: LD_ADDR_VAR 0 9
66795: PUSH
66796: LD_VAR 0 5
66800: PUSH
66801: LD_INT 2
66803: ARRAY
66804: ST_TO_ADDR
// end ; if not weapon then
66805: LD_VAR 0 9
66809: NOT
66810: IFFALSE 66814
// continue ;
66812: GO 66442
// ComPlaceWeapon ( tw , weapon ) ;
66814: LD_VAR 0 7
66818: PPUSH
66819: LD_VAR 0 9
66823: PPUSH
66824: CALL_OW 148
// end ;
66828: GO 66442
66830: POP
66831: POP
// end ;
66832: LD_VAR 0 1
66836: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
66837: LD_INT 0
66839: PPUSH
66840: PPUSH
66841: PPUSH
66842: PPUSH
66843: PPUSH
66844: PPUSH
66845: PPUSH
// if not mc_bases then
66846: LD_EXP 60
66850: NOT
66851: IFFALSE 66855
// exit ;
66853: GO 67623
// for i = 1 to mc_bases do
66855: LD_ADDR_VAR 0 2
66859: PUSH
66860: DOUBLE
66861: LD_INT 1
66863: DEC
66864: ST_TO_ADDR
66865: LD_EXP 60
66869: PUSH
66870: FOR_TO
66871: IFFALSE 67621
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
66873: LD_EXP 73
66877: PUSH
66878: LD_VAR 0 2
66882: ARRAY
66883: NOT
66884: PUSH
66885: LD_EXP 73
66889: PUSH
66890: LD_VAR 0 2
66894: ARRAY
66895: PUSH
66896: LD_EXP 74
66900: PUSH
66901: LD_VAR 0 2
66905: ARRAY
66906: EQUAL
66907: OR
66908: PUSH
66909: LD_EXP 83
66913: PUSH
66914: LD_VAR 0 2
66918: ARRAY
66919: OR
66920: IFFALSE 66924
// continue ;
66922: GO 66870
// if mc_miners [ i ] then
66924: LD_EXP 74
66928: PUSH
66929: LD_VAR 0 2
66933: ARRAY
66934: IFFALSE 67308
// begin for j = mc_miners [ i ] downto 1 do
66936: LD_ADDR_VAR 0 3
66940: PUSH
66941: DOUBLE
66942: LD_EXP 74
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: INC
66953: ST_TO_ADDR
66954: LD_INT 1
66956: PUSH
66957: FOR_DOWNTO
66958: IFFALSE 67306
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
66960: LD_EXP 74
66964: PUSH
66965: LD_VAR 0 2
66969: ARRAY
66970: PUSH
66971: LD_VAR 0 3
66975: ARRAY
66976: PPUSH
66977: CALL_OW 301
66981: PUSH
66982: LD_EXP 74
66986: PUSH
66987: LD_VAR 0 2
66991: ARRAY
66992: PUSH
66993: LD_VAR 0 3
66997: ARRAY
66998: PPUSH
66999: CALL_OW 257
67003: PUSH
67004: LD_INT 1
67006: NONEQUAL
67007: OR
67008: IFFALSE 67071
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67010: LD_ADDR_VAR 0 5
67014: PUSH
67015: LD_EXP 74
67019: PUSH
67020: LD_VAR 0 2
67024: ARRAY
67025: PUSH
67026: LD_EXP 74
67030: PUSH
67031: LD_VAR 0 2
67035: ARRAY
67036: PUSH
67037: LD_VAR 0 3
67041: ARRAY
67042: DIFF
67043: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67044: LD_ADDR_EXP 74
67048: PUSH
67049: LD_EXP 74
67053: PPUSH
67054: LD_VAR 0 2
67058: PPUSH
67059: LD_VAR 0 5
67063: PPUSH
67064: CALL_OW 1
67068: ST_TO_ADDR
// continue ;
67069: GO 66957
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67071: LD_EXP 74
67075: PUSH
67076: LD_VAR 0 2
67080: ARRAY
67081: PUSH
67082: LD_VAR 0 3
67086: ARRAY
67087: PPUSH
67088: CALL_OW 257
67092: PUSH
67093: LD_INT 1
67095: EQUAL
67096: PUSH
67097: LD_EXP 74
67101: PUSH
67102: LD_VAR 0 2
67106: ARRAY
67107: PUSH
67108: LD_VAR 0 3
67112: ARRAY
67113: PPUSH
67114: CALL_OW 459
67118: NOT
67119: AND
67120: PUSH
67121: LD_EXP 74
67125: PUSH
67126: LD_VAR 0 2
67130: ARRAY
67131: PUSH
67132: LD_VAR 0 3
67136: ARRAY
67137: PPUSH
67138: CALL_OW 314
67142: NOT
67143: AND
67144: IFFALSE 67304
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67146: LD_EXP 74
67150: PUSH
67151: LD_VAR 0 2
67155: ARRAY
67156: PUSH
67157: LD_VAR 0 3
67161: ARRAY
67162: PPUSH
67163: CALL_OW 310
67167: IFFALSE 67190
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67169: LD_EXP 74
67173: PUSH
67174: LD_VAR 0 2
67178: ARRAY
67179: PUSH
67180: LD_VAR 0 3
67184: ARRAY
67185: PPUSH
67186: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67190: LD_EXP 74
67194: PUSH
67195: LD_VAR 0 2
67199: ARRAY
67200: PUSH
67201: LD_VAR 0 3
67205: ARRAY
67206: PPUSH
67207: CALL_OW 314
67211: NOT
67212: IFFALSE 67304
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67214: LD_ADDR_VAR 0 7
67218: PUSH
67219: LD_INT 1
67221: PPUSH
67222: LD_EXP 73
67226: PUSH
67227: LD_VAR 0 2
67231: ARRAY
67232: PPUSH
67233: CALL_OW 12
67237: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67238: LD_EXP 74
67242: PUSH
67243: LD_VAR 0 2
67247: ARRAY
67248: PUSH
67249: LD_VAR 0 3
67253: ARRAY
67254: PPUSH
67255: LD_EXP 73
67259: PUSH
67260: LD_VAR 0 2
67264: ARRAY
67265: PUSH
67266: LD_VAR 0 7
67270: ARRAY
67271: PUSH
67272: LD_INT 1
67274: ARRAY
67275: PPUSH
67276: LD_EXP 73
67280: PUSH
67281: LD_VAR 0 2
67285: ARRAY
67286: PUSH
67287: LD_VAR 0 7
67291: ARRAY
67292: PUSH
67293: LD_INT 2
67295: ARRAY
67296: PPUSH
67297: LD_INT 0
67299: PPUSH
67300: CALL_OW 193
// end ; end ; end ;
67304: GO 66957
67306: POP
67307: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67308: LD_ADDR_VAR 0 5
67312: PUSH
67313: LD_EXP 60
67317: PUSH
67318: LD_VAR 0 2
67322: ARRAY
67323: PPUSH
67324: LD_INT 2
67326: PUSH
67327: LD_INT 30
67329: PUSH
67330: LD_INT 4
67332: PUSH
67333: EMPTY
67334: LIST
67335: LIST
67336: PUSH
67337: LD_INT 30
67339: PUSH
67340: LD_INT 5
67342: PUSH
67343: EMPTY
67344: LIST
67345: LIST
67346: PUSH
67347: LD_INT 30
67349: PUSH
67350: LD_INT 32
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: PPUSH
67363: CALL_OW 72
67367: ST_TO_ADDR
// if not tmp then
67368: LD_VAR 0 5
67372: NOT
67373: IFFALSE 67377
// continue ;
67375: GO 66870
// list := [ ] ;
67377: LD_ADDR_VAR 0 6
67381: PUSH
67382: EMPTY
67383: ST_TO_ADDR
// for j in tmp do
67384: LD_ADDR_VAR 0 3
67388: PUSH
67389: LD_VAR 0 5
67393: PUSH
67394: FOR_IN
67395: IFFALSE 67464
// begin for k in UnitsInside ( j ) do
67397: LD_ADDR_VAR 0 4
67401: PUSH
67402: LD_VAR 0 3
67406: PPUSH
67407: CALL_OW 313
67411: PUSH
67412: FOR_IN
67413: IFFALSE 67460
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67415: LD_VAR 0 4
67419: PPUSH
67420: CALL_OW 257
67424: PUSH
67425: LD_INT 1
67427: EQUAL
67428: PUSH
67429: LD_VAR 0 4
67433: PPUSH
67434: CALL_OW 459
67438: NOT
67439: AND
67440: IFFALSE 67458
// list := list ^ k ;
67442: LD_ADDR_VAR 0 6
67446: PUSH
67447: LD_VAR 0 6
67451: PUSH
67452: LD_VAR 0 4
67456: ADD
67457: ST_TO_ADDR
67458: GO 67412
67460: POP
67461: POP
// end ;
67462: GO 67394
67464: POP
67465: POP
// list := list diff mc_miners [ i ] ;
67466: LD_ADDR_VAR 0 6
67470: PUSH
67471: LD_VAR 0 6
67475: PUSH
67476: LD_EXP 74
67480: PUSH
67481: LD_VAR 0 2
67485: ARRAY
67486: DIFF
67487: ST_TO_ADDR
// if not list then
67488: LD_VAR 0 6
67492: NOT
67493: IFFALSE 67497
// continue ;
67495: GO 66870
// k := mc_mines [ i ] - mc_miners [ i ] ;
67497: LD_ADDR_VAR 0 4
67501: PUSH
67502: LD_EXP 73
67506: PUSH
67507: LD_VAR 0 2
67511: ARRAY
67512: PUSH
67513: LD_EXP 74
67517: PUSH
67518: LD_VAR 0 2
67522: ARRAY
67523: MINUS
67524: ST_TO_ADDR
// if k > list then
67525: LD_VAR 0 4
67529: PUSH
67530: LD_VAR 0 6
67534: GREATER
67535: IFFALSE 67547
// k := list ;
67537: LD_ADDR_VAR 0 4
67541: PUSH
67542: LD_VAR 0 6
67546: ST_TO_ADDR
// for j = 1 to k do
67547: LD_ADDR_VAR 0 3
67551: PUSH
67552: DOUBLE
67553: LD_INT 1
67555: DEC
67556: ST_TO_ADDR
67557: LD_VAR 0 4
67561: PUSH
67562: FOR_TO
67563: IFFALSE 67617
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
67565: LD_ADDR_EXP 74
67569: PUSH
67570: LD_EXP 74
67574: PPUSH
67575: LD_VAR 0 2
67579: PUSH
67580: LD_EXP 74
67584: PUSH
67585: LD_VAR 0 2
67589: ARRAY
67590: PUSH
67591: LD_INT 1
67593: PLUS
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PPUSH
67599: LD_VAR 0 6
67603: PUSH
67604: LD_VAR 0 3
67608: ARRAY
67609: PPUSH
67610: CALL 19801 0 3
67614: ST_TO_ADDR
67615: GO 67562
67617: POP
67618: POP
// end ;
67619: GO 66870
67621: POP
67622: POP
// end ;
67623: LD_VAR 0 1
67627: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
67628: LD_INT 0
67630: PPUSH
67631: PPUSH
67632: PPUSH
67633: PPUSH
67634: PPUSH
67635: PPUSH
67636: PPUSH
67637: PPUSH
67638: PPUSH
67639: PPUSH
67640: PPUSH
// if not mc_bases then
67641: LD_EXP 60
67645: NOT
67646: IFFALSE 67650
// exit ;
67648: GO 69473
// for i = 1 to mc_bases do
67650: LD_ADDR_VAR 0 2
67654: PUSH
67655: DOUBLE
67656: LD_INT 1
67658: DEC
67659: ST_TO_ADDR
67660: LD_EXP 60
67664: PUSH
67665: FOR_TO
67666: IFFALSE 69471
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
67668: LD_EXP 60
67672: PUSH
67673: LD_VAR 0 2
67677: ARRAY
67678: NOT
67679: PUSH
67680: LD_EXP 67
67684: PUSH
67685: LD_VAR 0 2
67689: ARRAY
67690: OR
67691: IFFALSE 67695
// continue ;
67693: GO 67665
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
67695: LD_EXP 76
67699: PUSH
67700: LD_VAR 0 2
67704: ARRAY
67705: NOT
67706: PUSH
67707: LD_EXP 77
67711: PUSH
67712: LD_VAR 0 2
67716: ARRAY
67717: AND
67718: IFFALSE 67756
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
67720: LD_ADDR_EXP 77
67724: PUSH
67725: LD_EXP 77
67729: PPUSH
67730: LD_VAR 0 2
67734: PPUSH
67735: EMPTY
67736: PPUSH
67737: CALL_OW 1
67741: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
67742: LD_VAR 0 2
67746: PPUSH
67747: LD_INT 107
67749: PPUSH
67750: CALL 58524 0 2
// continue ;
67754: GO 67665
// end ; target := [ ] ;
67756: LD_ADDR_VAR 0 7
67760: PUSH
67761: EMPTY
67762: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
67763: LD_ADDR_VAR 0 6
67767: PUSH
67768: LD_EXP 60
67772: PUSH
67773: LD_VAR 0 2
67777: ARRAY
67778: PUSH
67779: LD_INT 1
67781: ARRAY
67782: PPUSH
67783: CALL_OW 255
67787: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67788: LD_ADDR_VAR 0 9
67792: PUSH
67793: LD_EXP 60
67797: PUSH
67798: LD_VAR 0 2
67802: ARRAY
67803: PPUSH
67804: LD_INT 2
67806: PUSH
67807: LD_INT 30
67809: PUSH
67810: LD_INT 0
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 30
67819: PUSH
67820: LD_INT 1
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: PPUSH
67832: CALL_OW 72
67836: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
67837: LD_ADDR_VAR 0 3
67841: PUSH
67842: DOUBLE
67843: LD_EXP 76
67847: PUSH
67848: LD_VAR 0 2
67852: ARRAY
67853: INC
67854: ST_TO_ADDR
67855: LD_INT 1
67857: PUSH
67858: FOR_DOWNTO
67859: IFFALSE 68104
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
67861: LD_EXP 76
67865: PUSH
67866: LD_VAR 0 2
67870: ARRAY
67871: PUSH
67872: LD_VAR 0 3
67876: ARRAY
67877: PUSH
67878: LD_INT 2
67880: ARRAY
67881: PPUSH
67882: LD_EXP 76
67886: PUSH
67887: LD_VAR 0 2
67891: ARRAY
67892: PUSH
67893: LD_VAR 0 3
67897: ARRAY
67898: PUSH
67899: LD_INT 3
67901: ARRAY
67902: PPUSH
67903: CALL_OW 488
67907: PUSH
67908: LD_EXP 76
67912: PUSH
67913: LD_VAR 0 2
67917: ARRAY
67918: PUSH
67919: LD_VAR 0 3
67923: ARRAY
67924: PUSH
67925: LD_INT 2
67927: ARRAY
67928: PPUSH
67929: LD_EXP 76
67933: PUSH
67934: LD_VAR 0 2
67938: ARRAY
67939: PUSH
67940: LD_VAR 0 3
67944: ARRAY
67945: PUSH
67946: LD_INT 3
67948: ARRAY
67949: PPUSH
67950: CALL_OW 284
67954: PUSH
67955: LD_INT 0
67957: EQUAL
67958: AND
67959: IFFALSE 68014
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
67961: LD_ADDR_VAR 0 5
67965: PUSH
67966: LD_EXP 76
67970: PUSH
67971: LD_VAR 0 2
67975: ARRAY
67976: PPUSH
67977: LD_VAR 0 3
67981: PPUSH
67982: CALL_OW 3
67986: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
67987: LD_ADDR_EXP 76
67991: PUSH
67992: LD_EXP 76
67996: PPUSH
67997: LD_VAR 0 2
68001: PPUSH
68002: LD_VAR 0 5
68006: PPUSH
68007: CALL_OW 1
68011: ST_TO_ADDR
// continue ;
68012: GO 67858
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68014: LD_VAR 0 6
68018: PPUSH
68019: LD_EXP 76
68023: PUSH
68024: LD_VAR 0 2
68028: ARRAY
68029: PUSH
68030: LD_VAR 0 3
68034: ARRAY
68035: PUSH
68036: LD_INT 2
68038: ARRAY
68039: PPUSH
68040: LD_EXP 76
68044: PUSH
68045: LD_VAR 0 2
68049: ARRAY
68050: PUSH
68051: LD_VAR 0 3
68055: ARRAY
68056: PUSH
68057: LD_INT 3
68059: ARRAY
68060: PPUSH
68061: LD_INT 30
68063: PPUSH
68064: CALL 20697 0 4
68068: PUSH
68069: LD_INT 4
68071: ARRAY
68072: PUSH
68073: LD_INT 0
68075: EQUAL
68076: IFFALSE 68102
// begin target := mc_crates [ i ] [ j ] ;
68078: LD_ADDR_VAR 0 7
68082: PUSH
68083: LD_EXP 76
68087: PUSH
68088: LD_VAR 0 2
68092: ARRAY
68093: PUSH
68094: LD_VAR 0 3
68098: ARRAY
68099: ST_TO_ADDR
// break ;
68100: GO 68104
// end ; end ;
68102: GO 67858
68104: POP
68105: POP
// if not target then
68106: LD_VAR 0 7
68110: NOT
68111: IFFALSE 68115
// continue ;
68113: GO 67665
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68115: LD_ADDR_VAR 0 8
68119: PUSH
68120: LD_EXP 79
68124: PUSH
68125: LD_VAR 0 2
68129: ARRAY
68130: PPUSH
68131: LD_INT 2
68133: PUSH
68134: LD_INT 3
68136: PUSH
68137: LD_INT 58
68139: PUSH
68140: EMPTY
68141: LIST
68142: PUSH
68143: EMPTY
68144: LIST
68145: LIST
68146: PUSH
68147: LD_INT 61
68149: PUSH
68150: EMPTY
68151: LIST
68152: PUSH
68153: LD_INT 33
68155: PUSH
68156: LD_INT 5
68158: PUSH
68159: EMPTY
68160: LIST
68161: LIST
68162: PUSH
68163: LD_INT 33
68165: PUSH
68166: LD_INT 3
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: EMPTY
68174: LIST
68175: LIST
68176: LIST
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 2
68182: PUSH
68183: LD_INT 34
68185: PUSH
68186: LD_INT 32
68188: PUSH
68189: EMPTY
68190: LIST
68191: LIST
68192: PUSH
68193: LD_INT 34
68195: PUSH
68196: LD_INT 51
68198: PUSH
68199: EMPTY
68200: LIST
68201: LIST
68202: PUSH
68203: LD_INT 34
68205: PUSH
68206: LD_INT 12
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: LIST
68217: LIST
68218: PUSH
68219: EMPTY
68220: LIST
68221: LIST
68222: PPUSH
68223: CALL_OW 72
68227: ST_TO_ADDR
// if not cargo then
68228: LD_VAR 0 8
68232: NOT
68233: IFFALSE 68939
// begin if mc_crates_collector [ i ] < 5 then
68235: LD_EXP 77
68239: PUSH
68240: LD_VAR 0 2
68244: ARRAY
68245: PUSH
68246: LD_INT 5
68248: LESS
68249: IFFALSE 68615
// begin if mc_ape [ i ] then
68251: LD_EXP 89
68255: PUSH
68256: LD_VAR 0 2
68260: ARRAY
68261: IFFALSE 68308
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68263: LD_ADDR_VAR 0 5
68267: PUSH
68268: LD_EXP 89
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: PPUSH
68279: LD_INT 25
68281: PUSH
68282: LD_INT 16
68284: PUSH
68285: EMPTY
68286: LIST
68287: LIST
68288: PUSH
68289: LD_INT 24
68291: PUSH
68292: LD_INT 750
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PPUSH
68303: CALL_OW 72
68307: ST_TO_ADDR
// if not tmp then
68308: LD_VAR 0 5
68312: NOT
68313: IFFALSE 68360
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68315: LD_ADDR_VAR 0 5
68319: PUSH
68320: LD_EXP 60
68324: PUSH
68325: LD_VAR 0 2
68329: ARRAY
68330: PPUSH
68331: LD_INT 25
68333: PUSH
68334: LD_INT 2
68336: PUSH
68337: EMPTY
68338: LIST
68339: LIST
68340: PUSH
68341: LD_INT 24
68343: PUSH
68344: LD_INT 750
68346: PUSH
68347: EMPTY
68348: LIST
68349: LIST
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: PPUSH
68355: CALL_OW 72
68359: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68360: LD_EXP 89
68364: PUSH
68365: LD_VAR 0 2
68369: ARRAY
68370: PUSH
68371: LD_EXP 60
68375: PUSH
68376: LD_VAR 0 2
68380: ARRAY
68381: PPUSH
68382: LD_INT 25
68384: PUSH
68385: LD_INT 2
68387: PUSH
68388: EMPTY
68389: LIST
68390: LIST
68391: PUSH
68392: LD_INT 24
68394: PUSH
68395: LD_INT 750
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: EMPTY
68403: LIST
68404: LIST
68405: PPUSH
68406: CALL_OW 72
68410: AND
68411: PUSH
68412: LD_VAR 0 5
68416: PUSH
68417: LD_INT 5
68419: LESS
68420: AND
68421: IFFALSE 68503
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68423: LD_ADDR_VAR 0 3
68427: PUSH
68428: LD_EXP 60
68432: PUSH
68433: LD_VAR 0 2
68437: ARRAY
68438: PPUSH
68439: LD_INT 25
68441: PUSH
68442: LD_INT 2
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 24
68451: PUSH
68452: LD_INT 750
68454: PUSH
68455: EMPTY
68456: LIST
68457: LIST
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PPUSH
68463: CALL_OW 72
68467: PUSH
68468: FOR_IN
68469: IFFALSE 68501
// begin tmp := tmp union j ;
68471: LD_ADDR_VAR 0 5
68475: PUSH
68476: LD_VAR 0 5
68480: PUSH
68481: LD_VAR 0 3
68485: UNION
68486: ST_TO_ADDR
// if tmp >= 5 then
68487: LD_VAR 0 5
68491: PUSH
68492: LD_INT 5
68494: GREATEREQUAL
68495: IFFALSE 68499
// break ;
68497: GO 68501
// end ;
68499: GO 68468
68501: POP
68502: POP
// end ; if not tmp then
68503: LD_VAR 0 5
68507: NOT
68508: IFFALSE 68512
// continue ;
68510: GO 67665
// for j in tmp do
68512: LD_ADDR_VAR 0 3
68516: PUSH
68517: LD_VAR 0 5
68521: PUSH
68522: FOR_IN
68523: IFFALSE 68613
// if not GetTag ( j ) then
68525: LD_VAR 0 3
68529: PPUSH
68530: CALL_OW 110
68534: NOT
68535: IFFALSE 68611
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
68537: LD_ADDR_EXP 77
68541: PUSH
68542: LD_EXP 77
68546: PPUSH
68547: LD_VAR 0 2
68551: PUSH
68552: LD_EXP 77
68556: PUSH
68557: LD_VAR 0 2
68561: ARRAY
68562: PUSH
68563: LD_INT 1
68565: PLUS
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PPUSH
68571: LD_VAR 0 3
68575: PPUSH
68576: CALL 19801 0 3
68580: ST_TO_ADDR
// SetTag ( j , 107 ) ;
68581: LD_VAR 0 3
68585: PPUSH
68586: LD_INT 107
68588: PPUSH
68589: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
68593: LD_EXP 77
68597: PUSH
68598: LD_VAR 0 2
68602: ARRAY
68603: PUSH
68604: LD_INT 5
68606: GREATEREQUAL
68607: IFFALSE 68611
// break ;
68609: GO 68613
// end ;
68611: GO 68522
68613: POP
68614: POP
// end ; if mc_crates_collector [ i ] and target then
68615: LD_EXP 77
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: PUSH
68626: LD_VAR 0 7
68630: AND
68631: IFFALSE 68937
// begin if mc_crates_collector [ i ] < target [ 1 ] then
68633: LD_EXP 77
68637: PUSH
68638: LD_VAR 0 2
68642: ARRAY
68643: PUSH
68644: LD_VAR 0 7
68648: PUSH
68649: LD_INT 1
68651: ARRAY
68652: LESS
68653: IFFALSE 68673
// tmp := mc_crates_collector [ i ] else
68655: LD_ADDR_VAR 0 5
68659: PUSH
68660: LD_EXP 77
68664: PUSH
68665: LD_VAR 0 2
68669: ARRAY
68670: ST_TO_ADDR
68671: GO 68687
// tmp := target [ 1 ] ;
68673: LD_ADDR_VAR 0 5
68677: PUSH
68678: LD_VAR 0 7
68682: PUSH
68683: LD_INT 1
68685: ARRAY
68686: ST_TO_ADDR
// k := 0 ;
68687: LD_ADDR_VAR 0 4
68691: PUSH
68692: LD_INT 0
68694: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
68695: LD_ADDR_VAR 0 3
68699: PUSH
68700: LD_EXP 77
68704: PUSH
68705: LD_VAR 0 2
68709: ARRAY
68710: PUSH
68711: FOR_IN
68712: IFFALSE 68935
// begin k := k + 1 ;
68714: LD_ADDR_VAR 0 4
68718: PUSH
68719: LD_VAR 0 4
68723: PUSH
68724: LD_INT 1
68726: PLUS
68727: ST_TO_ADDR
// if k > tmp then
68728: LD_VAR 0 4
68732: PUSH
68733: LD_VAR 0 5
68737: GREATER
68738: IFFALSE 68742
// break ;
68740: GO 68935
// if not GetClass ( j ) in [ 2 , 16 ] then
68742: LD_VAR 0 3
68746: PPUSH
68747: CALL_OW 257
68751: PUSH
68752: LD_INT 2
68754: PUSH
68755: LD_INT 16
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: IN
68762: NOT
68763: IFFALSE 68816
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
68765: LD_ADDR_EXP 77
68769: PUSH
68770: LD_EXP 77
68774: PPUSH
68775: LD_VAR 0 2
68779: PPUSH
68780: LD_EXP 77
68784: PUSH
68785: LD_VAR 0 2
68789: ARRAY
68790: PUSH
68791: LD_VAR 0 3
68795: DIFF
68796: PPUSH
68797: CALL_OW 1
68801: ST_TO_ADDR
// SetTag ( j , 0 ) ;
68802: LD_VAR 0 3
68806: PPUSH
68807: LD_INT 0
68809: PPUSH
68810: CALL_OW 109
// continue ;
68814: GO 68711
// end ; if IsInUnit ( j ) then
68816: LD_VAR 0 3
68820: PPUSH
68821: CALL_OW 310
68825: IFFALSE 68836
// ComExitBuilding ( j ) ;
68827: LD_VAR 0 3
68831: PPUSH
68832: CALL_OW 122
// wait ( 3 ) ;
68836: LD_INT 3
68838: PPUSH
68839: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
68843: LD_VAR 0 3
68847: PPUSH
68848: CALL_OW 314
68852: PUSH
68853: LD_VAR 0 6
68857: PPUSH
68858: LD_VAR 0 7
68862: PUSH
68863: LD_INT 2
68865: ARRAY
68866: PPUSH
68867: LD_VAR 0 7
68871: PUSH
68872: LD_INT 3
68874: ARRAY
68875: PPUSH
68876: LD_INT 30
68878: PPUSH
68879: CALL 20697 0 4
68883: PUSH
68884: LD_INT 4
68886: ARRAY
68887: AND
68888: IFFALSE 68906
// ComStandNearbyBuilding ( j , depot ) else
68890: LD_VAR 0 3
68894: PPUSH
68895: LD_VAR 0 9
68899: PPUSH
68900: CALL 16379 0 2
68904: GO 68933
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
68906: LD_VAR 0 3
68910: PPUSH
68911: LD_VAR 0 7
68915: PUSH
68916: LD_INT 2
68918: ARRAY
68919: PPUSH
68920: LD_VAR 0 7
68924: PUSH
68925: LD_INT 3
68927: ARRAY
68928: PPUSH
68929: CALL_OW 117
// end ;
68933: GO 68711
68935: POP
68936: POP
// end ; end else
68937: GO 69469
// begin for j in cargo do
68939: LD_ADDR_VAR 0 3
68943: PUSH
68944: LD_VAR 0 8
68948: PUSH
68949: FOR_IN
68950: IFFALSE 69467
// begin if GetTag ( j ) <> 0 then
68952: LD_VAR 0 3
68956: PPUSH
68957: CALL_OW 110
68961: PUSH
68962: LD_INT 0
68964: NONEQUAL
68965: IFFALSE 68969
// continue ;
68967: GO 68949
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
68969: LD_VAR 0 3
68973: PPUSH
68974: CALL_OW 256
68978: PUSH
68979: LD_INT 1000
68981: LESS
68982: PUSH
68983: LD_VAR 0 3
68987: PPUSH
68988: LD_EXP 84
68992: PUSH
68993: LD_VAR 0 2
68997: ARRAY
68998: PPUSH
68999: CALL_OW 308
69003: NOT
69004: AND
69005: IFFALSE 69027
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69007: LD_VAR 0 3
69011: PPUSH
69012: LD_EXP 84
69016: PUSH
69017: LD_VAR 0 2
69021: ARRAY
69022: PPUSH
69023: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69027: LD_VAR 0 3
69031: PPUSH
69032: CALL_OW 256
69036: PUSH
69037: LD_INT 1000
69039: LESS
69040: PUSH
69041: LD_VAR 0 3
69045: PPUSH
69046: LD_EXP 84
69050: PUSH
69051: LD_VAR 0 2
69055: ARRAY
69056: PPUSH
69057: CALL_OW 308
69061: AND
69062: IFFALSE 69066
// continue ;
69064: GO 68949
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69066: LD_VAR 0 3
69070: PPUSH
69071: CALL_OW 262
69075: PUSH
69076: LD_INT 2
69078: EQUAL
69079: PUSH
69080: LD_VAR 0 3
69084: PPUSH
69085: CALL_OW 261
69089: PUSH
69090: LD_INT 15
69092: LESS
69093: AND
69094: IFFALSE 69098
// continue ;
69096: GO 68949
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69098: LD_VAR 0 3
69102: PPUSH
69103: CALL_OW 262
69107: PUSH
69108: LD_INT 1
69110: EQUAL
69111: PUSH
69112: LD_VAR 0 3
69116: PPUSH
69117: CALL_OW 261
69121: PUSH
69122: LD_INT 10
69124: LESS
69125: AND
69126: IFFALSE 69406
// begin if not depot then
69128: LD_VAR 0 9
69132: NOT
69133: IFFALSE 69137
// continue ;
69135: GO 68949
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69137: LD_VAR 0 3
69141: PPUSH
69142: LD_VAR 0 9
69146: PPUSH
69147: LD_VAR 0 3
69151: PPUSH
69152: CALL_OW 74
69156: PPUSH
69157: CALL_OW 296
69161: PUSH
69162: LD_INT 6
69164: LESS
69165: IFFALSE 69181
// SetFuel ( j , 100 ) else
69167: LD_VAR 0 3
69171: PPUSH
69172: LD_INT 100
69174: PPUSH
69175: CALL_OW 240
69179: GO 69406
// if GetFuel ( j ) = 0 then
69181: LD_VAR 0 3
69185: PPUSH
69186: CALL_OW 261
69190: PUSH
69191: LD_INT 0
69193: EQUAL
69194: IFFALSE 69406
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69196: LD_ADDR_EXP 79
69200: PUSH
69201: LD_EXP 79
69205: PPUSH
69206: LD_VAR 0 2
69210: PPUSH
69211: LD_EXP 79
69215: PUSH
69216: LD_VAR 0 2
69220: ARRAY
69221: PUSH
69222: LD_VAR 0 3
69226: DIFF
69227: PPUSH
69228: CALL_OW 1
69232: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69233: LD_VAR 0 3
69237: PPUSH
69238: CALL_OW 263
69242: PUSH
69243: LD_INT 1
69245: EQUAL
69246: IFFALSE 69262
// ComExitVehicle ( IsInUnit ( j ) ) ;
69248: LD_VAR 0 3
69252: PPUSH
69253: CALL_OW 310
69257: PPUSH
69258: CALL_OW 121
// if GetControl ( j ) = control_remote then
69262: LD_VAR 0 3
69266: PPUSH
69267: CALL_OW 263
69271: PUSH
69272: LD_INT 2
69274: EQUAL
69275: IFFALSE 69286
// ComUnlink ( j ) ;
69277: LD_VAR 0 3
69281: PPUSH
69282: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69286: LD_ADDR_VAR 0 10
69290: PUSH
69291: LD_VAR 0 2
69295: PPUSH
69296: LD_INT 3
69298: PPUSH
69299: CALL 79045 0 2
69303: ST_TO_ADDR
// if fac then
69304: LD_VAR 0 10
69308: IFFALSE 69404
// begin for k in fac do
69310: LD_ADDR_VAR 0 4
69314: PUSH
69315: LD_VAR 0 10
69319: PUSH
69320: FOR_IN
69321: IFFALSE 69402
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69323: LD_ADDR_VAR 0 11
69327: PUSH
69328: LD_VAR 0 10
69332: PPUSH
69333: LD_VAR 0 3
69337: PPUSH
69338: CALL_OW 265
69342: PPUSH
69343: LD_VAR 0 3
69347: PPUSH
69348: CALL_OW 262
69352: PPUSH
69353: LD_VAR 0 3
69357: PPUSH
69358: CALL_OW 263
69362: PPUSH
69363: LD_VAR 0 3
69367: PPUSH
69368: CALL_OW 264
69372: PPUSH
69373: CALL 17297 0 5
69377: ST_TO_ADDR
// if components then
69378: LD_VAR 0 11
69382: IFFALSE 69400
// begin MC_InsertProduceList ( i , components ) ;
69384: LD_VAR 0 2
69388: PPUSH
69389: LD_VAR 0 11
69393: PPUSH
69394: CALL 78590 0 2
// break ;
69398: GO 69402
// end ; end ;
69400: GO 69320
69402: POP
69403: POP
// end ; continue ;
69404: GO 68949
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69406: LD_VAR 0 3
69410: PPUSH
69411: LD_INT 1
69413: PPUSH
69414: CALL_OW 289
69418: PUSH
69419: LD_INT 100
69421: LESS
69422: PUSH
69423: LD_VAR 0 3
69427: PPUSH
69428: CALL_OW 314
69432: NOT
69433: AND
69434: IFFALSE 69463
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69436: LD_VAR 0 3
69440: PPUSH
69441: LD_VAR 0 7
69445: PUSH
69446: LD_INT 2
69448: ARRAY
69449: PPUSH
69450: LD_VAR 0 7
69454: PUSH
69455: LD_INT 3
69457: ARRAY
69458: PPUSH
69459: CALL_OW 117
// break ;
69463: GO 69467
// end ;
69465: GO 68949
69467: POP
69468: POP
// end ; end ;
69469: GO 67665
69471: POP
69472: POP
// end ;
69473: LD_VAR 0 1
69477: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
69478: LD_INT 0
69480: PPUSH
69481: PPUSH
69482: PPUSH
69483: PPUSH
// if not mc_bases then
69484: LD_EXP 60
69488: NOT
69489: IFFALSE 69493
// exit ;
69491: GO 69654
// for i = 1 to mc_bases do
69493: LD_ADDR_VAR 0 2
69497: PUSH
69498: DOUBLE
69499: LD_INT 1
69501: DEC
69502: ST_TO_ADDR
69503: LD_EXP 60
69507: PUSH
69508: FOR_TO
69509: IFFALSE 69652
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
69511: LD_ADDR_VAR 0 4
69515: PUSH
69516: LD_EXP 79
69520: PUSH
69521: LD_VAR 0 2
69525: ARRAY
69526: PUSH
69527: LD_EXP 82
69531: PUSH
69532: LD_VAR 0 2
69536: ARRAY
69537: UNION
69538: PPUSH
69539: LD_INT 33
69541: PUSH
69542: LD_INT 2
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: PPUSH
69549: CALL_OW 72
69553: ST_TO_ADDR
// if tmp then
69554: LD_VAR 0 4
69558: IFFALSE 69650
// for j in tmp do
69560: LD_ADDR_VAR 0 3
69564: PUSH
69565: LD_VAR 0 4
69569: PUSH
69570: FOR_IN
69571: IFFALSE 69648
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
69573: LD_VAR 0 3
69577: PPUSH
69578: CALL_OW 312
69582: NOT
69583: PUSH
69584: LD_VAR 0 3
69588: PPUSH
69589: CALL_OW 256
69593: PUSH
69594: LD_INT 250
69596: GREATEREQUAL
69597: AND
69598: IFFALSE 69611
// Connect ( j ) else
69600: LD_VAR 0 3
69604: PPUSH
69605: CALL 22772 0 1
69609: GO 69646
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
69611: LD_VAR 0 3
69615: PPUSH
69616: CALL_OW 256
69620: PUSH
69621: LD_INT 250
69623: LESS
69624: PUSH
69625: LD_VAR 0 3
69629: PPUSH
69630: CALL_OW 312
69634: AND
69635: IFFALSE 69646
// ComUnlink ( j ) ;
69637: LD_VAR 0 3
69641: PPUSH
69642: CALL_OW 136
69646: GO 69570
69648: POP
69649: POP
// end ;
69650: GO 69508
69652: POP
69653: POP
// end ;
69654: LD_VAR 0 1
69658: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
69659: LD_INT 0
69661: PPUSH
69662: PPUSH
69663: PPUSH
69664: PPUSH
69665: PPUSH
// if not mc_bases then
69666: LD_EXP 60
69670: NOT
69671: IFFALSE 69675
// exit ;
69673: GO 70120
// for i = 1 to mc_bases do
69675: LD_ADDR_VAR 0 2
69679: PUSH
69680: DOUBLE
69681: LD_INT 1
69683: DEC
69684: ST_TO_ADDR
69685: LD_EXP 60
69689: PUSH
69690: FOR_TO
69691: IFFALSE 70118
// begin if not mc_produce [ i ] then
69693: LD_EXP 81
69697: PUSH
69698: LD_VAR 0 2
69702: ARRAY
69703: NOT
69704: IFFALSE 69708
// continue ;
69706: GO 69690
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69708: LD_ADDR_VAR 0 5
69712: PUSH
69713: LD_EXP 60
69717: PUSH
69718: LD_VAR 0 2
69722: ARRAY
69723: PPUSH
69724: LD_INT 30
69726: PUSH
69727: LD_INT 3
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PPUSH
69734: CALL_OW 72
69738: ST_TO_ADDR
// if not fac then
69739: LD_VAR 0 5
69743: NOT
69744: IFFALSE 69748
// continue ;
69746: GO 69690
// for j in fac do
69748: LD_ADDR_VAR 0 3
69752: PUSH
69753: LD_VAR 0 5
69757: PUSH
69758: FOR_IN
69759: IFFALSE 70114
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
69761: LD_VAR 0 3
69765: PPUSH
69766: CALL_OW 461
69770: PUSH
69771: LD_INT 2
69773: NONEQUAL
69774: PUSH
69775: LD_VAR 0 3
69779: PPUSH
69780: LD_INT 15
69782: PPUSH
69783: CALL 22400 0 2
69787: PUSH
69788: LD_INT 4
69790: ARRAY
69791: OR
69792: IFFALSE 69796
// continue ;
69794: GO 69758
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
69796: LD_VAR 0 3
69800: PPUSH
69801: LD_EXP 81
69805: PUSH
69806: LD_VAR 0 2
69810: ARRAY
69811: PUSH
69812: LD_INT 1
69814: ARRAY
69815: PUSH
69816: LD_INT 1
69818: ARRAY
69819: PPUSH
69820: LD_EXP 81
69824: PUSH
69825: LD_VAR 0 2
69829: ARRAY
69830: PUSH
69831: LD_INT 1
69833: ARRAY
69834: PUSH
69835: LD_INT 2
69837: ARRAY
69838: PPUSH
69839: LD_EXP 81
69843: PUSH
69844: LD_VAR 0 2
69848: ARRAY
69849: PUSH
69850: LD_INT 1
69852: ARRAY
69853: PUSH
69854: LD_INT 3
69856: ARRAY
69857: PPUSH
69858: LD_EXP 81
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: PUSH
69869: LD_INT 1
69871: ARRAY
69872: PUSH
69873: LD_INT 4
69875: ARRAY
69876: PPUSH
69877: CALL_OW 448
69881: PUSH
69882: LD_VAR 0 3
69886: PPUSH
69887: LD_EXP 81
69891: PUSH
69892: LD_VAR 0 2
69896: ARRAY
69897: PUSH
69898: LD_INT 1
69900: ARRAY
69901: PUSH
69902: LD_INT 1
69904: ARRAY
69905: PUSH
69906: LD_EXP 81
69910: PUSH
69911: LD_VAR 0 2
69915: ARRAY
69916: PUSH
69917: LD_INT 1
69919: ARRAY
69920: PUSH
69921: LD_INT 2
69923: ARRAY
69924: PUSH
69925: LD_EXP 81
69929: PUSH
69930: LD_VAR 0 2
69934: ARRAY
69935: PUSH
69936: LD_INT 1
69938: ARRAY
69939: PUSH
69940: LD_INT 3
69942: ARRAY
69943: PUSH
69944: LD_EXP 81
69948: PUSH
69949: LD_VAR 0 2
69953: ARRAY
69954: PUSH
69955: LD_INT 1
69957: ARRAY
69958: PUSH
69959: LD_INT 4
69961: ARRAY
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: PPUSH
69969: CALL 26167 0 2
69973: AND
69974: IFFALSE 70112
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
69976: LD_VAR 0 3
69980: PPUSH
69981: LD_EXP 81
69985: PUSH
69986: LD_VAR 0 2
69990: ARRAY
69991: PUSH
69992: LD_INT 1
69994: ARRAY
69995: PUSH
69996: LD_INT 1
69998: ARRAY
69999: PPUSH
70000: LD_EXP 81
70004: PUSH
70005: LD_VAR 0 2
70009: ARRAY
70010: PUSH
70011: LD_INT 1
70013: ARRAY
70014: PUSH
70015: LD_INT 2
70017: ARRAY
70018: PPUSH
70019: LD_EXP 81
70023: PUSH
70024: LD_VAR 0 2
70028: ARRAY
70029: PUSH
70030: LD_INT 1
70032: ARRAY
70033: PUSH
70034: LD_INT 3
70036: ARRAY
70037: PPUSH
70038: LD_EXP 81
70042: PUSH
70043: LD_VAR 0 2
70047: ARRAY
70048: PUSH
70049: LD_INT 1
70051: ARRAY
70052: PUSH
70053: LD_INT 4
70055: ARRAY
70056: PPUSH
70057: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70061: LD_ADDR_VAR 0 4
70065: PUSH
70066: LD_EXP 81
70070: PUSH
70071: LD_VAR 0 2
70075: ARRAY
70076: PPUSH
70077: LD_INT 1
70079: PPUSH
70080: CALL_OW 3
70084: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70085: LD_ADDR_EXP 81
70089: PUSH
70090: LD_EXP 81
70094: PPUSH
70095: LD_VAR 0 2
70099: PPUSH
70100: LD_VAR 0 4
70104: PPUSH
70105: CALL_OW 1
70109: ST_TO_ADDR
// break ;
70110: GO 70114
// end ; end ;
70112: GO 69758
70114: POP
70115: POP
// end ;
70116: GO 69690
70118: POP
70119: POP
// end ;
70120: LD_VAR 0 1
70124: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70125: LD_INT 0
70127: PPUSH
70128: PPUSH
70129: PPUSH
// if not mc_bases then
70130: LD_EXP 60
70134: NOT
70135: IFFALSE 70139
// exit ;
70137: GO 70228
// for i = 1 to mc_bases do
70139: LD_ADDR_VAR 0 2
70143: PUSH
70144: DOUBLE
70145: LD_INT 1
70147: DEC
70148: ST_TO_ADDR
70149: LD_EXP 60
70153: PUSH
70154: FOR_TO
70155: IFFALSE 70226
// begin if mc_attack [ i ] then
70157: LD_EXP 80
70161: PUSH
70162: LD_VAR 0 2
70166: ARRAY
70167: IFFALSE 70224
// begin tmp := mc_attack [ i ] [ 1 ] ;
70169: LD_ADDR_VAR 0 3
70173: PUSH
70174: LD_EXP 80
70178: PUSH
70179: LD_VAR 0 2
70183: ARRAY
70184: PUSH
70185: LD_INT 1
70187: ARRAY
70188: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70189: LD_ADDR_EXP 80
70193: PUSH
70194: LD_EXP 80
70198: PPUSH
70199: LD_VAR 0 2
70203: PPUSH
70204: EMPTY
70205: PPUSH
70206: CALL_OW 1
70210: ST_TO_ADDR
// Attack ( tmp ) ;
70211: LD_VAR 0 3
70215: PPUSH
70216: CALL 102954 0 1
// exit ;
70220: POP
70221: POP
70222: GO 70228
// end ; end ;
70224: GO 70154
70226: POP
70227: POP
// end ;
70228: LD_VAR 0 1
70232: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70233: LD_INT 0
70235: PPUSH
70236: PPUSH
70237: PPUSH
70238: PPUSH
70239: PPUSH
70240: PPUSH
70241: PPUSH
// if not mc_bases then
70242: LD_EXP 60
70246: NOT
70247: IFFALSE 70251
// exit ;
70249: GO 71108
// for i = 1 to mc_bases do
70251: LD_ADDR_VAR 0 2
70255: PUSH
70256: DOUBLE
70257: LD_INT 1
70259: DEC
70260: ST_TO_ADDR
70261: LD_EXP 60
70265: PUSH
70266: FOR_TO
70267: IFFALSE 71106
// begin if not mc_bases [ i ] then
70269: LD_EXP 60
70273: PUSH
70274: LD_VAR 0 2
70278: ARRAY
70279: NOT
70280: IFFALSE 70284
// continue ;
70282: GO 70266
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70284: LD_ADDR_VAR 0 7
70288: PUSH
70289: LD_EXP 60
70293: PUSH
70294: LD_VAR 0 2
70298: ARRAY
70299: PUSH
70300: LD_INT 1
70302: ARRAY
70303: PPUSH
70304: CALL 16601 0 1
70308: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70309: LD_ADDR_EXP 83
70313: PUSH
70314: LD_EXP 83
70318: PPUSH
70319: LD_VAR 0 2
70323: PPUSH
70324: LD_EXP 60
70328: PUSH
70329: LD_VAR 0 2
70333: ARRAY
70334: PUSH
70335: LD_INT 1
70337: ARRAY
70338: PPUSH
70339: CALL_OW 255
70343: PPUSH
70344: LD_EXP 85
70348: PUSH
70349: LD_VAR 0 2
70353: ARRAY
70354: PPUSH
70355: CALL 16566 0 2
70359: PPUSH
70360: CALL_OW 1
70364: ST_TO_ADDR
// if not mc_scan [ i ] then
70365: LD_EXP 83
70369: PUSH
70370: LD_VAR 0 2
70374: ARRAY
70375: NOT
70376: IFFALSE 70554
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70378: LD_ADDR_EXP 103
70382: PUSH
70383: LD_EXP 103
70387: PPUSH
70388: LD_VAR 0 2
70392: PPUSH
70393: LD_INT 0
70395: PPUSH
70396: CALL_OW 1
70400: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70401: LD_ADDR_VAR 0 4
70405: PUSH
70406: LD_EXP 60
70410: PUSH
70411: LD_VAR 0 2
70415: ARRAY
70416: PPUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 25
70422: PUSH
70423: LD_INT 5
70425: PUSH
70426: EMPTY
70427: LIST
70428: LIST
70429: PUSH
70430: LD_INT 25
70432: PUSH
70433: LD_INT 8
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 25
70442: PUSH
70443: LD_INT 9
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: LIST
70454: LIST
70455: PPUSH
70456: CALL_OW 72
70460: ST_TO_ADDR
// if not tmp then
70461: LD_VAR 0 4
70465: NOT
70466: IFFALSE 70470
// continue ;
70468: GO 70266
// for j in tmp do
70470: LD_ADDR_VAR 0 3
70474: PUSH
70475: LD_VAR 0 4
70479: PUSH
70480: FOR_IN
70481: IFFALSE 70552
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
70483: LD_VAR 0 3
70487: PPUSH
70488: CALL_OW 310
70492: PPUSH
70493: CALL_OW 266
70497: PUSH
70498: LD_INT 5
70500: EQUAL
70501: PUSH
70502: LD_VAR 0 3
70506: PPUSH
70507: CALL_OW 257
70511: PUSH
70512: LD_INT 1
70514: EQUAL
70515: AND
70516: PUSH
70517: LD_VAR 0 3
70521: PPUSH
70522: CALL_OW 459
70526: NOT
70527: AND
70528: PUSH
70529: LD_VAR 0 7
70533: AND
70534: IFFALSE 70550
// ComChangeProfession ( j , class ) ;
70536: LD_VAR 0 3
70540: PPUSH
70541: LD_VAR 0 7
70545: PPUSH
70546: CALL_OW 123
70550: GO 70480
70552: POP
70553: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
70554: LD_EXP 83
70558: PUSH
70559: LD_VAR 0 2
70563: ARRAY
70564: PUSH
70565: LD_EXP 103
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: NOT
70576: AND
70577: PUSH
70578: LD_EXP 82
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: NOT
70589: AND
70590: PUSH
70591: LD_EXP 60
70595: PUSH
70596: LD_VAR 0 2
70600: ARRAY
70601: PPUSH
70602: LD_INT 50
70604: PUSH
70605: EMPTY
70606: LIST
70607: PUSH
70608: LD_INT 2
70610: PUSH
70611: LD_INT 30
70613: PUSH
70614: LD_INT 32
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 30
70623: PUSH
70624: LD_INT 33
70626: PUSH
70627: EMPTY
70628: LIST
70629: LIST
70630: PUSH
70631: LD_INT 30
70633: PUSH
70634: LD_INT 4
70636: PUSH
70637: EMPTY
70638: LIST
70639: LIST
70640: PUSH
70641: LD_INT 30
70643: PUSH
70644: LD_INT 5
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: LIST
70657: PUSH
70658: EMPTY
70659: LIST
70660: LIST
70661: PPUSH
70662: CALL_OW 72
70666: PUSH
70667: LD_INT 4
70669: LESS
70670: PUSH
70671: LD_EXP 60
70675: PUSH
70676: LD_VAR 0 2
70680: ARRAY
70681: PPUSH
70682: LD_INT 3
70684: PUSH
70685: LD_INT 24
70687: PUSH
70688: LD_INT 1000
70690: PUSH
70691: EMPTY
70692: LIST
70693: LIST
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 2
70701: PUSH
70702: LD_INT 30
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 30
70714: PUSH
70715: LD_INT 1
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: EMPTY
70723: LIST
70724: LIST
70725: LIST
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PPUSH
70731: CALL_OW 72
70735: OR
70736: AND
70737: IFFALSE 70988
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
70739: LD_ADDR_EXP 103
70743: PUSH
70744: LD_EXP 103
70748: PPUSH
70749: LD_VAR 0 2
70753: PPUSH
70754: LD_INT 1
70756: PPUSH
70757: CALL_OW 1
70761: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70762: LD_ADDR_VAR 0 4
70766: PUSH
70767: LD_EXP 60
70771: PUSH
70772: LD_VAR 0 2
70776: ARRAY
70777: PPUSH
70778: LD_INT 2
70780: PUSH
70781: LD_INT 25
70783: PUSH
70784: LD_INT 1
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 25
70793: PUSH
70794: LD_INT 5
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 25
70803: PUSH
70804: LD_INT 8
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 25
70813: PUSH
70814: LD_INT 9
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: LIST
70825: LIST
70826: LIST
70827: PPUSH
70828: CALL_OW 72
70832: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
70833: LD_ADDR_VAR 0 4
70837: PUSH
70838: LD_VAR 0 4
70842: PUSH
70843: LD_VAR 0 4
70847: PPUSH
70848: LD_INT 18
70850: PPUSH
70851: CALL 49070 0 2
70855: DIFF
70856: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
70857: LD_VAR 0 4
70861: NOT
70862: PUSH
70863: LD_EXP 60
70867: PUSH
70868: LD_VAR 0 2
70872: ARRAY
70873: PPUSH
70874: LD_INT 2
70876: PUSH
70877: LD_INT 30
70879: PUSH
70880: LD_INT 4
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 30
70889: PUSH
70890: LD_INT 5
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: EMPTY
70898: LIST
70899: LIST
70900: LIST
70901: PPUSH
70902: CALL_OW 72
70906: NOT
70907: AND
70908: IFFALSE 70970
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
70910: LD_ADDR_VAR 0 4
70914: PUSH
70915: LD_EXP 60
70919: PUSH
70920: LD_VAR 0 2
70924: ARRAY
70925: PPUSH
70926: LD_INT 2
70928: PUSH
70929: LD_INT 25
70931: PUSH
70932: LD_INT 2
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 25
70941: PUSH
70942: LD_INT 3
70944: PUSH
70945: EMPTY
70946: LIST
70947: LIST
70948: PUSH
70949: LD_INT 25
70951: PUSH
70952: LD_INT 4
70954: PUSH
70955: EMPTY
70956: LIST
70957: LIST
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: LIST
70963: LIST
70964: PPUSH
70965: CALL_OW 72
70969: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
70970: LD_VAR 0 2
70974: PPUSH
70975: LD_VAR 0 4
70979: PPUSH
70980: CALL 107663 0 2
// exit ;
70984: POP
70985: POP
70986: GO 71108
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
70988: LD_EXP 83
70992: PUSH
70993: LD_VAR 0 2
70997: ARRAY
70998: PUSH
70999: LD_EXP 103
71003: PUSH
71004: LD_VAR 0 2
71008: ARRAY
71009: NOT
71010: AND
71011: PUSH
71012: LD_EXP 82
71016: PUSH
71017: LD_VAR 0 2
71021: ARRAY
71022: AND
71023: IFFALSE 71104
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71025: LD_ADDR_EXP 103
71029: PUSH
71030: LD_EXP 103
71034: PPUSH
71035: LD_VAR 0 2
71039: PPUSH
71040: LD_INT 1
71042: PPUSH
71043: CALL_OW 1
71047: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71048: LD_ADDR_VAR 0 4
71052: PUSH
71053: LD_EXP 82
71057: PUSH
71058: LD_VAR 0 2
71062: ARRAY
71063: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71064: LD_ADDR_EXP 82
71068: PUSH
71069: LD_EXP 82
71073: PPUSH
71074: LD_VAR 0 2
71078: PPUSH
71079: EMPTY
71080: PPUSH
71081: CALL_OW 1
71085: ST_TO_ADDR
// Defend ( i , tmp ) ;
71086: LD_VAR 0 2
71090: PPUSH
71091: LD_VAR 0 4
71095: PPUSH
71096: CALL 108259 0 2
// exit ;
71100: POP
71101: POP
71102: GO 71108
// end ; end ;
71104: GO 70266
71106: POP
71107: POP
// end ;
71108: LD_VAR 0 1
71112: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71113: LD_INT 0
71115: PPUSH
71116: PPUSH
71117: PPUSH
71118: PPUSH
71119: PPUSH
71120: PPUSH
71121: PPUSH
71122: PPUSH
71123: PPUSH
71124: PPUSH
71125: PPUSH
// if not mc_bases then
71126: LD_EXP 60
71130: NOT
71131: IFFALSE 71135
// exit ;
71133: GO 72222
// for i = 1 to mc_bases do
71135: LD_ADDR_VAR 0 2
71139: PUSH
71140: DOUBLE
71141: LD_INT 1
71143: DEC
71144: ST_TO_ADDR
71145: LD_EXP 60
71149: PUSH
71150: FOR_TO
71151: IFFALSE 72220
// begin tmp := mc_lab [ i ] ;
71153: LD_ADDR_VAR 0 6
71157: PUSH
71158: LD_EXP 93
71162: PUSH
71163: LD_VAR 0 2
71167: ARRAY
71168: ST_TO_ADDR
// if not tmp then
71169: LD_VAR 0 6
71173: NOT
71174: IFFALSE 71178
// continue ;
71176: GO 71150
// idle_lab := 0 ;
71178: LD_ADDR_VAR 0 11
71182: PUSH
71183: LD_INT 0
71185: ST_TO_ADDR
// for j in tmp do
71186: LD_ADDR_VAR 0 3
71190: PUSH
71191: LD_VAR 0 6
71195: PUSH
71196: FOR_IN
71197: IFFALSE 72216
// begin researching := false ;
71199: LD_ADDR_VAR 0 10
71203: PUSH
71204: LD_INT 0
71206: ST_TO_ADDR
// side := GetSide ( j ) ;
71207: LD_ADDR_VAR 0 4
71211: PUSH
71212: LD_VAR 0 3
71216: PPUSH
71217: CALL_OW 255
71221: ST_TO_ADDR
// if not mc_tech [ side ] then
71222: LD_EXP 87
71226: PUSH
71227: LD_VAR 0 4
71231: ARRAY
71232: NOT
71233: IFFALSE 71237
// continue ;
71235: GO 71196
// if BuildingStatus ( j ) = bs_idle then
71237: LD_VAR 0 3
71241: PPUSH
71242: CALL_OW 461
71246: PUSH
71247: LD_INT 2
71249: EQUAL
71250: IFFALSE 71438
// begin if idle_lab and UnitsInside ( j ) < 6 then
71252: LD_VAR 0 11
71256: PUSH
71257: LD_VAR 0 3
71261: PPUSH
71262: CALL_OW 313
71266: PUSH
71267: LD_INT 6
71269: LESS
71270: AND
71271: IFFALSE 71342
// begin tmp2 := UnitsInside ( idle_lab ) ;
71273: LD_ADDR_VAR 0 9
71277: PUSH
71278: LD_VAR 0 11
71282: PPUSH
71283: CALL_OW 313
71287: ST_TO_ADDR
// if tmp2 then
71288: LD_VAR 0 9
71292: IFFALSE 71334
// for x in tmp2 do
71294: LD_ADDR_VAR 0 7
71298: PUSH
71299: LD_VAR 0 9
71303: PUSH
71304: FOR_IN
71305: IFFALSE 71332
// begin ComExitBuilding ( x ) ;
71307: LD_VAR 0 7
71311: PPUSH
71312: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71316: LD_VAR 0 7
71320: PPUSH
71321: LD_VAR 0 3
71325: PPUSH
71326: CALL_OW 180
// end ;
71330: GO 71304
71332: POP
71333: POP
// idle_lab := 0 ;
71334: LD_ADDR_VAR 0 11
71338: PUSH
71339: LD_INT 0
71341: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71342: LD_ADDR_VAR 0 5
71346: PUSH
71347: LD_EXP 87
71351: PUSH
71352: LD_VAR 0 4
71356: ARRAY
71357: PUSH
71358: FOR_IN
71359: IFFALSE 71419
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71361: LD_VAR 0 3
71365: PPUSH
71366: LD_VAR 0 5
71370: PPUSH
71371: CALL_OW 430
71375: PUSH
71376: LD_VAR 0 4
71380: PPUSH
71381: LD_VAR 0 5
71385: PPUSH
71386: CALL 15671 0 2
71390: AND
71391: IFFALSE 71417
// begin researching := true ;
71393: LD_ADDR_VAR 0 10
71397: PUSH
71398: LD_INT 1
71400: ST_TO_ADDR
// ComResearch ( j , t ) ;
71401: LD_VAR 0 3
71405: PPUSH
71406: LD_VAR 0 5
71410: PPUSH
71411: CALL_OW 124
// break ;
71415: GO 71419
// end ;
71417: GO 71358
71419: POP
71420: POP
// if not researching then
71421: LD_VAR 0 10
71425: NOT
71426: IFFALSE 71438
// idle_lab := j ;
71428: LD_ADDR_VAR 0 11
71432: PUSH
71433: LD_VAR 0 3
71437: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71438: LD_VAR 0 3
71442: PPUSH
71443: CALL_OW 461
71447: PUSH
71448: LD_INT 10
71450: EQUAL
71451: IFFALSE 72039
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71453: LD_EXP 89
71457: PUSH
71458: LD_VAR 0 2
71462: ARRAY
71463: NOT
71464: PUSH
71465: LD_EXP 90
71469: PUSH
71470: LD_VAR 0 2
71474: ARRAY
71475: NOT
71476: AND
71477: PUSH
71478: LD_EXP 87
71482: PUSH
71483: LD_VAR 0 4
71487: ARRAY
71488: PUSH
71489: LD_INT 1
71491: GREATER
71492: AND
71493: IFFALSE 71624
// begin ComCancel ( j ) ;
71495: LD_VAR 0 3
71499: PPUSH
71500: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
71504: LD_ADDR_EXP 87
71508: PUSH
71509: LD_EXP 87
71513: PPUSH
71514: LD_VAR 0 4
71518: PPUSH
71519: LD_EXP 87
71523: PUSH
71524: LD_VAR 0 4
71528: ARRAY
71529: PPUSH
71530: LD_EXP 87
71534: PUSH
71535: LD_VAR 0 4
71539: ARRAY
71540: PUSH
71541: LD_INT 1
71543: MINUS
71544: PPUSH
71545: LD_EXP 87
71549: PUSH
71550: LD_VAR 0 4
71554: ARRAY
71555: PPUSH
71556: LD_INT 0
71558: PPUSH
71559: CALL 19219 0 4
71563: PPUSH
71564: CALL_OW 1
71568: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
71569: LD_ADDR_EXP 87
71573: PUSH
71574: LD_EXP 87
71578: PPUSH
71579: LD_VAR 0 4
71583: PPUSH
71584: LD_EXP 87
71588: PUSH
71589: LD_VAR 0 4
71593: ARRAY
71594: PPUSH
71595: LD_EXP 87
71599: PUSH
71600: LD_VAR 0 4
71604: ARRAY
71605: PPUSH
71606: LD_INT 1
71608: PPUSH
71609: LD_INT 0
71611: PPUSH
71612: CALL 19219 0 4
71616: PPUSH
71617: CALL_OW 1
71621: ST_TO_ADDR
// continue ;
71622: GO 71196
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
71624: LD_EXP 89
71628: PUSH
71629: LD_VAR 0 2
71633: ARRAY
71634: PUSH
71635: LD_EXP 90
71639: PUSH
71640: LD_VAR 0 2
71644: ARRAY
71645: NOT
71646: AND
71647: IFFALSE 71774
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
71649: LD_ADDR_EXP 90
71653: PUSH
71654: LD_EXP 90
71658: PPUSH
71659: LD_VAR 0 2
71663: PUSH
71664: LD_EXP 90
71668: PUSH
71669: LD_VAR 0 2
71673: ARRAY
71674: PUSH
71675: LD_INT 1
71677: PLUS
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PPUSH
71683: LD_EXP 89
71687: PUSH
71688: LD_VAR 0 2
71692: ARRAY
71693: PUSH
71694: LD_INT 1
71696: ARRAY
71697: PPUSH
71698: CALL 19801 0 3
71702: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
71703: LD_EXP 89
71707: PUSH
71708: LD_VAR 0 2
71712: ARRAY
71713: PUSH
71714: LD_INT 1
71716: ARRAY
71717: PPUSH
71718: LD_INT 112
71720: PPUSH
71721: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
71725: LD_ADDR_VAR 0 9
71729: PUSH
71730: LD_EXP 89
71734: PUSH
71735: LD_VAR 0 2
71739: ARRAY
71740: PPUSH
71741: LD_INT 1
71743: PPUSH
71744: CALL_OW 3
71748: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
71749: LD_ADDR_EXP 89
71753: PUSH
71754: LD_EXP 89
71758: PPUSH
71759: LD_VAR 0 2
71763: PPUSH
71764: LD_VAR 0 9
71768: PPUSH
71769: CALL_OW 1
71773: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
71774: LD_EXP 89
71778: PUSH
71779: LD_VAR 0 2
71783: ARRAY
71784: PUSH
71785: LD_EXP 90
71789: PUSH
71790: LD_VAR 0 2
71794: ARRAY
71795: AND
71796: PUSH
71797: LD_EXP 90
71801: PUSH
71802: LD_VAR 0 2
71806: ARRAY
71807: PUSH
71808: LD_INT 1
71810: ARRAY
71811: PPUSH
71812: CALL_OW 310
71816: NOT
71817: AND
71818: PUSH
71819: LD_VAR 0 3
71823: PPUSH
71824: CALL_OW 313
71828: PUSH
71829: LD_INT 6
71831: EQUAL
71832: AND
71833: IFFALSE 71889
// begin tmp2 := UnitsInside ( j ) ;
71835: LD_ADDR_VAR 0 9
71839: PUSH
71840: LD_VAR 0 3
71844: PPUSH
71845: CALL_OW 313
71849: ST_TO_ADDR
// if tmp2 = 6 then
71850: LD_VAR 0 9
71854: PUSH
71855: LD_INT 6
71857: EQUAL
71858: IFFALSE 71889
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
71860: LD_VAR 0 9
71864: PUSH
71865: LD_INT 1
71867: ARRAY
71868: PPUSH
71869: LD_INT 112
71871: PPUSH
71872: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
71876: LD_VAR 0 9
71880: PUSH
71881: LD_INT 1
71883: ARRAY
71884: PPUSH
71885: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
71889: LD_EXP 90
71893: PUSH
71894: LD_VAR 0 2
71898: ARRAY
71899: PUSH
71900: LD_EXP 90
71904: PUSH
71905: LD_VAR 0 2
71909: ARRAY
71910: PUSH
71911: LD_INT 1
71913: ARRAY
71914: PPUSH
71915: CALL_OW 314
71919: NOT
71920: AND
71921: PUSH
71922: LD_EXP 90
71926: PUSH
71927: LD_VAR 0 2
71931: ARRAY
71932: PUSH
71933: LD_INT 1
71935: ARRAY
71936: PPUSH
71937: CALL_OW 310
71941: NOT
71942: AND
71943: IFFALSE 71969
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
71945: LD_EXP 90
71949: PUSH
71950: LD_VAR 0 2
71954: ARRAY
71955: PUSH
71956: LD_INT 1
71958: ARRAY
71959: PPUSH
71960: LD_VAR 0 3
71964: PPUSH
71965: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
71969: LD_EXP 90
71973: PUSH
71974: LD_VAR 0 2
71978: ARRAY
71979: PUSH
71980: LD_INT 1
71982: ARRAY
71983: PPUSH
71984: CALL_OW 310
71988: PUSH
71989: LD_EXP 90
71993: PUSH
71994: LD_VAR 0 2
71998: ARRAY
71999: PUSH
72000: LD_INT 1
72002: ARRAY
72003: PPUSH
72004: CALL_OW 310
72008: PPUSH
72009: CALL_OW 461
72013: PUSH
72014: LD_INT 3
72016: NONEQUAL
72017: AND
72018: IFFALSE 72039
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72020: LD_EXP 90
72024: PUSH
72025: LD_VAR 0 2
72029: ARRAY
72030: PUSH
72031: LD_INT 1
72033: ARRAY
72034: PPUSH
72035: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72039: LD_VAR 0 3
72043: PPUSH
72044: CALL_OW 461
72048: PUSH
72049: LD_INT 6
72051: EQUAL
72052: PUSH
72053: LD_VAR 0 6
72057: PUSH
72058: LD_INT 1
72060: GREATER
72061: AND
72062: IFFALSE 72214
// begin sci := [ ] ;
72064: LD_ADDR_VAR 0 8
72068: PUSH
72069: EMPTY
72070: ST_TO_ADDR
// for x in ( tmp diff j ) do
72071: LD_ADDR_VAR 0 7
72075: PUSH
72076: LD_VAR 0 6
72080: PUSH
72081: LD_VAR 0 3
72085: DIFF
72086: PUSH
72087: FOR_IN
72088: IFFALSE 72140
// begin if sci = 6 then
72090: LD_VAR 0 8
72094: PUSH
72095: LD_INT 6
72097: EQUAL
72098: IFFALSE 72102
// break ;
72100: GO 72140
// if BuildingStatus ( x ) = bs_idle then
72102: LD_VAR 0 7
72106: PPUSH
72107: CALL_OW 461
72111: PUSH
72112: LD_INT 2
72114: EQUAL
72115: IFFALSE 72138
// sci := sci ^ UnitsInside ( x ) ;
72117: LD_ADDR_VAR 0 8
72121: PUSH
72122: LD_VAR 0 8
72126: PUSH
72127: LD_VAR 0 7
72131: PPUSH
72132: CALL_OW 313
72136: ADD
72137: ST_TO_ADDR
// end ;
72138: GO 72087
72140: POP
72141: POP
// if not sci then
72142: LD_VAR 0 8
72146: NOT
72147: IFFALSE 72151
// continue ;
72149: GO 71196
// for x in sci do
72151: LD_ADDR_VAR 0 7
72155: PUSH
72156: LD_VAR 0 8
72160: PUSH
72161: FOR_IN
72162: IFFALSE 72212
// if IsInUnit ( x ) and not HasTask ( x ) then
72164: LD_VAR 0 7
72168: PPUSH
72169: CALL_OW 310
72173: PUSH
72174: LD_VAR 0 7
72178: PPUSH
72179: CALL_OW 314
72183: NOT
72184: AND
72185: IFFALSE 72210
// begin ComExitBuilding ( x ) ;
72187: LD_VAR 0 7
72191: PPUSH
72192: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72196: LD_VAR 0 7
72200: PPUSH
72201: LD_VAR 0 3
72205: PPUSH
72206: CALL_OW 180
// end ;
72210: GO 72161
72212: POP
72213: POP
// end ; end ;
72214: GO 71196
72216: POP
72217: POP
// end ;
72218: GO 71150
72220: POP
72221: POP
// end ;
72222: LD_VAR 0 1
72226: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72227: LD_INT 0
72229: PPUSH
72230: PPUSH
// if not mc_bases then
72231: LD_EXP 60
72235: NOT
72236: IFFALSE 72240
// exit ;
72238: GO 72321
// for i = 1 to mc_bases do
72240: LD_ADDR_VAR 0 2
72244: PUSH
72245: DOUBLE
72246: LD_INT 1
72248: DEC
72249: ST_TO_ADDR
72250: LD_EXP 60
72254: PUSH
72255: FOR_TO
72256: IFFALSE 72319
// if mc_mines [ i ] and mc_miners [ i ] then
72258: LD_EXP 73
72262: PUSH
72263: LD_VAR 0 2
72267: ARRAY
72268: PUSH
72269: LD_EXP 74
72273: PUSH
72274: LD_VAR 0 2
72278: ARRAY
72279: AND
72280: IFFALSE 72317
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72282: LD_EXP 74
72286: PUSH
72287: LD_VAR 0 2
72291: ARRAY
72292: PUSH
72293: LD_INT 1
72295: ARRAY
72296: PPUSH
72297: CALL_OW 255
72301: PPUSH
72302: LD_EXP 73
72306: PUSH
72307: LD_VAR 0 2
72311: ARRAY
72312: PPUSH
72313: CALL 16754 0 2
72317: GO 72255
72319: POP
72320: POP
// end ;
72321: LD_VAR 0 1
72325: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72326: LD_INT 0
72328: PPUSH
72329: PPUSH
72330: PPUSH
72331: PPUSH
72332: PPUSH
72333: PPUSH
72334: PPUSH
72335: PPUSH
// if not mc_bases or not mc_parking then
72336: LD_EXP 60
72340: NOT
72341: PUSH
72342: LD_EXP 84
72346: NOT
72347: OR
72348: IFFALSE 72352
// exit ;
72350: GO 73062
// for i = 1 to mc_bases do
72352: LD_ADDR_VAR 0 2
72356: PUSH
72357: DOUBLE
72358: LD_INT 1
72360: DEC
72361: ST_TO_ADDR
72362: LD_EXP 60
72366: PUSH
72367: FOR_TO
72368: IFFALSE 73060
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72370: LD_EXP 60
72374: PUSH
72375: LD_VAR 0 2
72379: ARRAY
72380: NOT
72381: PUSH
72382: LD_EXP 84
72386: PUSH
72387: LD_VAR 0 2
72391: ARRAY
72392: NOT
72393: OR
72394: IFFALSE 72398
// continue ;
72396: GO 72367
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72398: LD_ADDR_VAR 0 5
72402: PUSH
72403: LD_EXP 60
72407: PUSH
72408: LD_VAR 0 2
72412: ARRAY
72413: PUSH
72414: LD_INT 1
72416: ARRAY
72417: PPUSH
72418: CALL_OW 255
72422: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72423: LD_ADDR_VAR 0 6
72427: PUSH
72428: LD_EXP 60
72432: PUSH
72433: LD_VAR 0 2
72437: ARRAY
72438: PPUSH
72439: LD_INT 30
72441: PUSH
72442: LD_INT 3
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PPUSH
72449: CALL_OW 72
72453: ST_TO_ADDR
// if not fac then
72454: LD_VAR 0 6
72458: NOT
72459: IFFALSE 72510
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72461: LD_ADDR_VAR 0 6
72465: PUSH
72466: LD_EXP 60
72470: PUSH
72471: LD_VAR 0 2
72475: ARRAY
72476: PPUSH
72477: LD_INT 2
72479: PUSH
72480: LD_INT 30
72482: PUSH
72483: LD_INT 0
72485: PUSH
72486: EMPTY
72487: LIST
72488: LIST
72489: PUSH
72490: LD_INT 30
72492: PUSH
72493: LD_INT 1
72495: PUSH
72496: EMPTY
72497: LIST
72498: LIST
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: LIST
72504: PPUSH
72505: CALL_OW 72
72509: ST_TO_ADDR
// if not fac then
72510: LD_VAR 0 6
72514: NOT
72515: IFFALSE 72519
// continue ;
72517: GO 72367
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72519: LD_ADDR_VAR 0 7
72523: PUSH
72524: LD_EXP 84
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PPUSH
72535: LD_INT 22
72537: PUSH
72538: LD_VAR 0 5
72542: PUSH
72543: EMPTY
72544: LIST
72545: LIST
72546: PUSH
72547: LD_INT 21
72549: PUSH
72550: LD_INT 2
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: PUSH
72557: LD_INT 3
72559: PUSH
72560: LD_INT 24
72562: PUSH
72563: LD_INT 1000
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: EMPTY
72571: LIST
72572: LIST
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: LIST
72578: PPUSH
72579: CALL_OW 70
72583: ST_TO_ADDR
// for j in fac do
72584: LD_ADDR_VAR 0 3
72588: PUSH
72589: LD_VAR 0 6
72593: PUSH
72594: FOR_IN
72595: IFFALSE 72676
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
72597: LD_ADDR_VAR 0 7
72601: PUSH
72602: LD_VAR 0 7
72606: PUSH
72607: LD_INT 22
72609: PUSH
72610: LD_VAR 0 5
72614: PUSH
72615: EMPTY
72616: LIST
72617: LIST
72618: PUSH
72619: LD_INT 91
72621: PUSH
72622: LD_VAR 0 3
72626: PUSH
72627: LD_INT 15
72629: PUSH
72630: EMPTY
72631: LIST
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 21
72637: PUSH
72638: LD_INT 2
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 3
72647: PUSH
72648: LD_INT 24
72650: PUSH
72651: LD_INT 1000
72653: PUSH
72654: EMPTY
72655: LIST
72656: LIST
72657: PUSH
72658: EMPTY
72659: LIST
72660: LIST
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: PPUSH
72668: CALL_OW 69
72672: UNION
72673: ST_TO_ADDR
72674: GO 72594
72676: POP
72677: POP
// if not vehs then
72678: LD_VAR 0 7
72682: NOT
72683: IFFALSE 72709
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
72685: LD_ADDR_EXP 72
72689: PUSH
72690: LD_EXP 72
72694: PPUSH
72695: LD_VAR 0 2
72699: PPUSH
72700: EMPTY
72701: PPUSH
72702: CALL_OW 1
72706: ST_TO_ADDR
// continue ;
72707: GO 72367
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72709: LD_ADDR_VAR 0 8
72713: PUSH
72714: LD_EXP 60
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: PPUSH
72725: LD_INT 30
72727: PUSH
72728: LD_INT 3
72730: PUSH
72731: EMPTY
72732: LIST
72733: LIST
72734: PPUSH
72735: CALL_OW 72
72739: ST_TO_ADDR
// if tmp then
72740: LD_VAR 0 8
72744: IFFALSE 72847
// begin for j in tmp do
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_VAR 0 8
72755: PUSH
72756: FOR_IN
72757: IFFALSE 72845
// for k in UnitsInside ( j ) do
72759: LD_ADDR_VAR 0 4
72763: PUSH
72764: LD_VAR 0 3
72768: PPUSH
72769: CALL_OW 313
72773: PUSH
72774: FOR_IN
72775: IFFALSE 72841
// if k then
72777: LD_VAR 0 4
72781: IFFALSE 72839
// if not k in mc_repair_vehicle [ i ] then
72783: LD_VAR 0 4
72787: PUSH
72788: LD_EXP 72
72792: PUSH
72793: LD_VAR 0 2
72797: ARRAY
72798: IN
72799: NOT
72800: IFFALSE 72839
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
72802: LD_ADDR_EXP 72
72806: PUSH
72807: LD_EXP 72
72811: PPUSH
72812: LD_VAR 0 2
72816: PPUSH
72817: LD_EXP 72
72821: PUSH
72822: LD_VAR 0 2
72826: ARRAY
72827: PUSH
72828: LD_VAR 0 4
72832: UNION
72833: PPUSH
72834: CALL_OW 1
72838: ST_TO_ADDR
72839: GO 72774
72841: POP
72842: POP
72843: GO 72756
72845: POP
72846: POP
// end ; if not mc_repair_vehicle [ i ] then
72847: LD_EXP 72
72851: PUSH
72852: LD_VAR 0 2
72856: ARRAY
72857: NOT
72858: IFFALSE 72862
// continue ;
72860: GO 72367
// for j in mc_repair_vehicle [ i ] do
72862: LD_ADDR_VAR 0 3
72866: PUSH
72867: LD_EXP 72
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: PUSH
72878: FOR_IN
72879: IFFALSE 73056
// begin if GetClass ( j ) <> 3 then
72881: LD_VAR 0 3
72885: PPUSH
72886: CALL_OW 257
72890: PUSH
72891: LD_INT 3
72893: NONEQUAL
72894: IFFALSE 72935
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
72896: LD_ADDR_EXP 72
72900: PUSH
72901: LD_EXP 72
72905: PPUSH
72906: LD_VAR 0 2
72910: PPUSH
72911: LD_EXP 72
72915: PUSH
72916: LD_VAR 0 2
72920: ARRAY
72921: PUSH
72922: LD_VAR 0 3
72926: DIFF
72927: PPUSH
72928: CALL_OW 1
72932: ST_TO_ADDR
// continue ;
72933: GO 72878
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
72935: LD_VAR 0 3
72939: PPUSH
72940: CALL_OW 311
72944: NOT
72945: PUSH
72946: LD_VAR 0 3
72950: PUSH
72951: LD_EXP 63
72955: PUSH
72956: LD_VAR 0 2
72960: ARRAY
72961: PUSH
72962: LD_INT 1
72964: ARRAY
72965: IN
72966: NOT
72967: AND
72968: PUSH
72969: LD_VAR 0 3
72973: PUSH
72974: LD_EXP 63
72978: PUSH
72979: LD_VAR 0 2
72983: ARRAY
72984: PUSH
72985: LD_INT 2
72987: ARRAY
72988: IN
72989: NOT
72990: AND
72991: IFFALSE 73054
// begin if IsInUnit ( j ) then
72993: LD_VAR 0 3
72997: PPUSH
72998: CALL_OW 310
73002: IFFALSE 73015
// ComExitBuilding ( j ) else
73004: LD_VAR 0 3
73008: PPUSH
73009: CALL_OW 122
73013: GO 73054
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73015: LD_VAR 0 3
73019: PPUSH
73020: LD_VAR 0 7
73024: PUSH
73025: LD_INT 1
73027: ARRAY
73028: PPUSH
73029: CALL 53408 0 2
73033: NOT
73034: IFFALSE 73054
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73036: LD_VAR 0 3
73040: PPUSH
73041: LD_VAR 0 7
73045: PUSH
73046: LD_INT 1
73048: ARRAY
73049: PPUSH
73050: CALL_OW 129
// end ; end ;
73054: GO 72878
73056: POP
73057: POP
// end ;
73058: GO 72367
73060: POP
73061: POP
// end ;
73062: LD_VAR 0 1
73066: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73067: LD_INT 0
73069: PPUSH
73070: PPUSH
73071: PPUSH
73072: PPUSH
73073: PPUSH
73074: PPUSH
73075: PPUSH
73076: PPUSH
73077: PPUSH
73078: PPUSH
73079: PPUSH
// if not mc_bases then
73080: LD_EXP 60
73084: NOT
73085: IFFALSE 73089
// exit ;
73087: GO 73891
// for i = 1 to mc_bases do
73089: LD_ADDR_VAR 0 2
73093: PUSH
73094: DOUBLE
73095: LD_INT 1
73097: DEC
73098: ST_TO_ADDR
73099: LD_EXP 60
73103: PUSH
73104: FOR_TO
73105: IFFALSE 73889
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73107: LD_EXP 88
73111: PUSH
73112: LD_VAR 0 2
73116: ARRAY
73117: NOT
73118: PUSH
73119: LD_EXP 63
73123: PUSH
73124: LD_VAR 0 2
73128: ARRAY
73129: PUSH
73130: LD_INT 1
73132: ARRAY
73133: OR
73134: PUSH
73135: LD_EXP 63
73139: PUSH
73140: LD_VAR 0 2
73144: ARRAY
73145: PUSH
73146: LD_INT 2
73148: ARRAY
73149: OR
73150: PUSH
73151: LD_EXP 86
73155: PUSH
73156: LD_VAR 0 2
73160: ARRAY
73161: PPUSH
73162: LD_INT 1
73164: PPUSH
73165: CALL_OW 325
73169: NOT
73170: OR
73171: PUSH
73172: LD_EXP 83
73176: PUSH
73177: LD_VAR 0 2
73181: ARRAY
73182: OR
73183: IFFALSE 73187
// continue ;
73185: GO 73104
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73187: LD_ADDR_VAR 0 8
73191: PUSH
73192: LD_EXP 60
73196: PUSH
73197: LD_VAR 0 2
73201: ARRAY
73202: PPUSH
73203: LD_INT 25
73205: PUSH
73206: LD_INT 4
73208: PUSH
73209: EMPTY
73210: LIST
73211: LIST
73212: PUSH
73213: LD_INT 50
73215: PUSH
73216: EMPTY
73217: LIST
73218: PUSH
73219: LD_INT 3
73221: PUSH
73222: LD_INT 60
73224: PUSH
73225: EMPTY
73226: LIST
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: EMPTY
73233: LIST
73234: LIST
73235: LIST
73236: PPUSH
73237: CALL_OW 72
73241: PUSH
73242: LD_EXP 64
73246: PUSH
73247: LD_VAR 0 2
73251: ARRAY
73252: DIFF
73253: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73254: LD_ADDR_VAR 0 9
73258: PUSH
73259: LD_EXP 60
73263: PUSH
73264: LD_VAR 0 2
73268: ARRAY
73269: PPUSH
73270: LD_INT 2
73272: PUSH
73273: LD_INT 30
73275: PUSH
73276: LD_INT 0
73278: PUSH
73279: EMPTY
73280: LIST
73281: LIST
73282: PUSH
73283: LD_INT 30
73285: PUSH
73286: LD_INT 1
73288: PUSH
73289: EMPTY
73290: LIST
73291: LIST
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: PPUSH
73298: CALL_OW 72
73302: ST_TO_ADDR
// if not tmp or not dep then
73303: LD_VAR 0 8
73307: NOT
73308: PUSH
73309: LD_VAR 0 9
73313: NOT
73314: OR
73315: IFFALSE 73319
// continue ;
73317: GO 73104
// side := GetSide ( tmp [ 1 ] ) ;
73319: LD_ADDR_VAR 0 11
73323: PUSH
73324: LD_VAR 0 8
73328: PUSH
73329: LD_INT 1
73331: ARRAY
73332: PPUSH
73333: CALL_OW 255
73337: ST_TO_ADDR
// dep := dep [ 1 ] ;
73338: LD_ADDR_VAR 0 9
73342: PUSH
73343: LD_VAR 0 9
73347: PUSH
73348: LD_INT 1
73350: ARRAY
73351: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73352: LD_ADDR_VAR 0 7
73356: PUSH
73357: LD_EXP 88
73361: PUSH
73362: LD_VAR 0 2
73366: ARRAY
73367: PPUSH
73368: LD_INT 22
73370: PUSH
73371: LD_INT 0
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 25
73380: PUSH
73381: LD_INT 12
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: EMPTY
73389: LIST
73390: LIST
73391: PPUSH
73392: CALL_OW 70
73396: PUSH
73397: LD_INT 22
73399: PUSH
73400: LD_INT 0
73402: PUSH
73403: EMPTY
73404: LIST
73405: LIST
73406: PUSH
73407: LD_INT 25
73409: PUSH
73410: LD_INT 12
73412: PUSH
73413: EMPTY
73414: LIST
73415: LIST
73416: PUSH
73417: LD_INT 91
73419: PUSH
73420: LD_VAR 0 9
73424: PUSH
73425: LD_INT 20
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: LIST
73432: PUSH
73433: EMPTY
73434: LIST
73435: LIST
73436: LIST
73437: PPUSH
73438: CALL_OW 69
73442: UNION
73443: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73444: LD_ADDR_VAR 0 10
73448: PUSH
73449: LD_EXP 88
73453: PUSH
73454: LD_VAR 0 2
73458: ARRAY
73459: PPUSH
73460: LD_INT 81
73462: PUSH
73463: LD_VAR 0 11
73467: PUSH
73468: EMPTY
73469: LIST
73470: LIST
73471: PPUSH
73472: CALL_OW 70
73476: ST_TO_ADDR
// if not apes or danger_at_area then
73477: LD_VAR 0 7
73481: NOT
73482: PUSH
73483: LD_VAR 0 10
73487: OR
73488: IFFALSE 73538
// begin if mc_taming [ i ] then
73490: LD_EXP 91
73494: PUSH
73495: LD_VAR 0 2
73499: ARRAY
73500: IFFALSE 73536
// begin MC_Reset ( i , 121 ) ;
73502: LD_VAR 0 2
73506: PPUSH
73507: LD_INT 121
73509: PPUSH
73510: CALL 58524 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
73514: LD_ADDR_EXP 91
73518: PUSH
73519: LD_EXP 91
73523: PPUSH
73524: LD_VAR 0 2
73528: PPUSH
73529: EMPTY
73530: PPUSH
73531: CALL_OW 1
73535: ST_TO_ADDR
// end ; continue ;
73536: GO 73104
// end ; for j in tmp do
73538: LD_ADDR_VAR 0 3
73542: PUSH
73543: LD_VAR 0 8
73547: PUSH
73548: FOR_IN
73549: IFFALSE 73885
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
73551: LD_VAR 0 3
73555: PUSH
73556: LD_EXP 91
73560: PUSH
73561: LD_VAR 0 2
73565: ARRAY
73566: IN
73567: NOT
73568: PUSH
73569: LD_EXP 91
73573: PUSH
73574: LD_VAR 0 2
73578: ARRAY
73579: PUSH
73580: LD_INT 3
73582: LESS
73583: AND
73584: IFFALSE 73642
// begin SetTag ( j , 121 ) ;
73586: LD_VAR 0 3
73590: PPUSH
73591: LD_INT 121
73593: PPUSH
73594: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
73598: LD_ADDR_EXP 91
73602: PUSH
73603: LD_EXP 91
73607: PPUSH
73608: LD_VAR 0 2
73612: PUSH
73613: LD_EXP 91
73617: PUSH
73618: LD_VAR 0 2
73622: ARRAY
73623: PUSH
73624: LD_INT 1
73626: PLUS
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PPUSH
73632: LD_VAR 0 3
73636: PPUSH
73637: CALL 19801 0 3
73641: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
73642: LD_VAR 0 3
73646: PUSH
73647: LD_EXP 91
73651: PUSH
73652: LD_VAR 0 2
73656: ARRAY
73657: IN
73658: IFFALSE 73883
// begin if GetClass ( j ) <> 4 then
73660: LD_VAR 0 3
73664: PPUSH
73665: CALL_OW 257
73669: PUSH
73670: LD_INT 4
73672: NONEQUAL
73673: IFFALSE 73726
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
73675: LD_ADDR_EXP 91
73679: PUSH
73680: LD_EXP 91
73684: PPUSH
73685: LD_VAR 0 2
73689: PPUSH
73690: LD_EXP 91
73694: PUSH
73695: LD_VAR 0 2
73699: ARRAY
73700: PUSH
73701: LD_VAR 0 3
73705: DIFF
73706: PPUSH
73707: CALL_OW 1
73711: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73712: LD_VAR 0 3
73716: PPUSH
73717: LD_INT 0
73719: PPUSH
73720: CALL_OW 109
// continue ;
73724: GO 73548
// end ; if IsInUnit ( j ) then
73726: LD_VAR 0 3
73730: PPUSH
73731: CALL_OW 310
73735: IFFALSE 73746
// ComExitBuilding ( j ) ;
73737: LD_VAR 0 3
73741: PPUSH
73742: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
73746: LD_ADDR_VAR 0 6
73750: PUSH
73751: LD_VAR 0 7
73755: PPUSH
73756: LD_VAR 0 3
73760: PPUSH
73761: CALL_OW 74
73765: ST_TO_ADDR
// if not ape then
73766: LD_VAR 0 6
73770: NOT
73771: IFFALSE 73775
// break ;
73773: GO 73885
// x := GetX ( ape ) ;
73775: LD_ADDR_VAR 0 4
73779: PUSH
73780: LD_VAR 0 6
73784: PPUSH
73785: CALL_OW 250
73789: ST_TO_ADDR
// y := GetY ( ape ) ;
73790: LD_ADDR_VAR 0 5
73794: PUSH
73795: LD_VAR 0 6
73799: PPUSH
73800: CALL_OW 251
73804: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
73805: LD_VAR 0 4
73809: PPUSH
73810: LD_VAR 0 5
73814: PPUSH
73815: CALL_OW 488
73819: NOT
73820: PUSH
73821: LD_VAR 0 11
73825: PPUSH
73826: LD_VAR 0 4
73830: PPUSH
73831: LD_VAR 0 5
73835: PPUSH
73836: LD_INT 20
73838: PPUSH
73839: CALL 20697 0 4
73843: PUSH
73844: LD_INT 4
73846: ARRAY
73847: OR
73848: IFFALSE 73852
// break ;
73850: GO 73885
// if not HasTask ( j ) then
73852: LD_VAR 0 3
73856: PPUSH
73857: CALL_OW 314
73861: NOT
73862: IFFALSE 73883
// ComTameXY ( j , x , y ) ;
73864: LD_VAR 0 3
73868: PPUSH
73869: LD_VAR 0 4
73873: PPUSH
73874: LD_VAR 0 5
73878: PPUSH
73879: CALL_OW 131
// end ; end ;
73883: GO 73548
73885: POP
73886: POP
// end ;
73887: GO 73104
73889: POP
73890: POP
// end ;
73891: LD_VAR 0 1
73895: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
73896: LD_INT 0
73898: PPUSH
73899: PPUSH
73900: PPUSH
73901: PPUSH
73902: PPUSH
73903: PPUSH
73904: PPUSH
73905: PPUSH
// if not mc_bases then
73906: LD_EXP 60
73910: NOT
73911: IFFALSE 73915
// exit ;
73913: GO 74541
// for i = 1 to mc_bases do
73915: LD_ADDR_VAR 0 2
73919: PUSH
73920: DOUBLE
73921: LD_INT 1
73923: DEC
73924: ST_TO_ADDR
73925: LD_EXP 60
73929: PUSH
73930: FOR_TO
73931: IFFALSE 74539
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
73933: LD_EXP 89
73937: PUSH
73938: LD_VAR 0 2
73942: ARRAY
73943: NOT
73944: PUSH
73945: LD_EXP 89
73949: PUSH
73950: LD_VAR 0 2
73954: ARRAY
73955: PPUSH
73956: LD_INT 25
73958: PUSH
73959: LD_INT 12
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PPUSH
73966: CALL_OW 72
73970: NOT
73971: OR
73972: IFFALSE 73976
// continue ;
73974: GO 73930
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
73976: LD_ADDR_VAR 0 5
73980: PUSH
73981: LD_EXP 89
73985: PUSH
73986: LD_VAR 0 2
73990: ARRAY
73991: PUSH
73992: LD_INT 1
73994: ARRAY
73995: PPUSH
73996: CALL_OW 255
74000: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74001: LD_VAR 0 5
74005: PPUSH
74006: LD_INT 2
74008: PPUSH
74009: CALL_OW 325
74013: IFFALSE 74266
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74015: LD_ADDR_VAR 0 4
74019: PUSH
74020: LD_EXP 89
74024: PUSH
74025: LD_VAR 0 2
74029: ARRAY
74030: PPUSH
74031: LD_INT 25
74033: PUSH
74034: LD_INT 16
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PPUSH
74041: CALL_OW 72
74045: ST_TO_ADDR
// if tmp < 6 then
74046: LD_VAR 0 4
74050: PUSH
74051: LD_INT 6
74053: LESS
74054: IFFALSE 74266
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74056: LD_ADDR_VAR 0 6
74060: PUSH
74061: LD_EXP 60
74065: PUSH
74066: LD_VAR 0 2
74070: ARRAY
74071: PPUSH
74072: LD_INT 2
74074: PUSH
74075: LD_INT 30
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 30
74087: PUSH
74088: LD_INT 1
74090: PUSH
74091: EMPTY
74092: LIST
74093: LIST
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: LIST
74099: PPUSH
74100: CALL_OW 72
74104: ST_TO_ADDR
// if depot then
74105: LD_VAR 0 6
74109: IFFALSE 74266
// begin selected := 0 ;
74111: LD_ADDR_VAR 0 7
74115: PUSH
74116: LD_INT 0
74118: ST_TO_ADDR
// for j in depot do
74119: LD_ADDR_VAR 0 3
74123: PUSH
74124: LD_VAR 0 6
74128: PUSH
74129: FOR_IN
74130: IFFALSE 74161
// begin if UnitsInside ( j ) < 6 then
74132: LD_VAR 0 3
74136: PPUSH
74137: CALL_OW 313
74141: PUSH
74142: LD_INT 6
74144: LESS
74145: IFFALSE 74159
// begin selected := j ;
74147: LD_ADDR_VAR 0 7
74151: PUSH
74152: LD_VAR 0 3
74156: ST_TO_ADDR
// break ;
74157: GO 74161
// end ; end ;
74159: GO 74129
74161: POP
74162: POP
// if selected then
74163: LD_VAR 0 7
74167: IFFALSE 74266
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74169: LD_ADDR_VAR 0 3
74173: PUSH
74174: LD_EXP 89
74178: PUSH
74179: LD_VAR 0 2
74183: ARRAY
74184: PPUSH
74185: LD_INT 25
74187: PUSH
74188: LD_INT 12
74190: PUSH
74191: EMPTY
74192: LIST
74193: LIST
74194: PPUSH
74195: CALL_OW 72
74199: PUSH
74200: FOR_IN
74201: IFFALSE 74264
// if not HasTask ( j ) then
74203: LD_VAR 0 3
74207: PPUSH
74208: CALL_OW 314
74212: NOT
74213: IFFALSE 74262
// begin if not IsInUnit ( j ) then
74215: LD_VAR 0 3
74219: PPUSH
74220: CALL_OW 310
74224: NOT
74225: IFFALSE 74241
// ComEnterUnit ( j , selected ) ;
74227: LD_VAR 0 3
74231: PPUSH
74232: LD_VAR 0 7
74236: PPUSH
74237: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74241: LD_VAR 0 3
74245: PPUSH
74246: LD_INT 16
74248: PPUSH
74249: CALL_OW 183
// AddComExitBuilding ( j ) ;
74253: LD_VAR 0 3
74257: PPUSH
74258: CALL_OW 182
// end ;
74262: GO 74200
74264: POP
74265: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74266: LD_VAR 0 5
74270: PPUSH
74271: LD_INT 11
74273: PPUSH
74274: CALL_OW 325
74278: IFFALSE 74537
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74280: LD_ADDR_VAR 0 4
74284: PUSH
74285: LD_EXP 89
74289: PUSH
74290: LD_VAR 0 2
74294: ARRAY
74295: PPUSH
74296: LD_INT 25
74298: PUSH
74299: LD_INT 16
74301: PUSH
74302: EMPTY
74303: LIST
74304: LIST
74305: PPUSH
74306: CALL_OW 72
74310: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74311: LD_VAR 0 4
74315: PUSH
74316: LD_INT 6
74318: GREATEREQUAL
74319: PUSH
74320: LD_VAR 0 5
74324: PPUSH
74325: LD_INT 2
74327: PPUSH
74328: CALL_OW 325
74332: NOT
74333: OR
74334: IFFALSE 74537
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74336: LD_ADDR_VAR 0 8
74340: PUSH
74341: LD_EXP 60
74345: PUSH
74346: LD_VAR 0 2
74350: ARRAY
74351: PPUSH
74352: LD_INT 2
74354: PUSH
74355: LD_INT 30
74357: PUSH
74358: LD_INT 4
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 30
74367: PUSH
74368: LD_INT 5
74370: PUSH
74371: EMPTY
74372: LIST
74373: LIST
74374: PUSH
74375: EMPTY
74376: LIST
74377: LIST
74378: LIST
74379: PPUSH
74380: CALL_OW 72
74384: ST_TO_ADDR
// if barracks then
74385: LD_VAR 0 8
74389: IFFALSE 74537
// begin selected := 0 ;
74391: LD_ADDR_VAR 0 7
74395: PUSH
74396: LD_INT 0
74398: ST_TO_ADDR
// for j in barracks do
74399: LD_ADDR_VAR 0 3
74403: PUSH
74404: LD_VAR 0 8
74408: PUSH
74409: FOR_IN
74410: IFFALSE 74441
// begin if UnitsInside ( j ) < 6 then
74412: LD_VAR 0 3
74416: PPUSH
74417: CALL_OW 313
74421: PUSH
74422: LD_INT 6
74424: LESS
74425: IFFALSE 74439
// begin selected := j ;
74427: LD_ADDR_VAR 0 7
74431: PUSH
74432: LD_VAR 0 3
74436: ST_TO_ADDR
// break ;
74437: GO 74441
// end ; end ;
74439: GO 74409
74441: POP
74442: POP
// if selected then
74443: LD_VAR 0 7
74447: IFFALSE 74537
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74449: LD_ADDR_VAR 0 3
74453: PUSH
74454: LD_EXP 89
74458: PUSH
74459: LD_VAR 0 2
74463: ARRAY
74464: PPUSH
74465: LD_INT 25
74467: PUSH
74468: LD_INT 12
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PPUSH
74475: CALL_OW 72
74479: PUSH
74480: FOR_IN
74481: IFFALSE 74535
// if not IsInUnit ( j ) and not HasTask ( j ) then
74483: LD_VAR 0 3
74487: PPUSH
74488: CALL_OW 310
74492: NOT
74493: PUSH
74494: LD_VAR 0 3
74498: PPUSH
74499: CALL_OW 314
74503: NOT
74504: AND
74505: IFFALSE 74533
// begin ComEnterUnit ( j , selected ) ;
74507: LD_VAR 0 3
74511: PPUSH
74512: LD_VAR 0 7
74516: PPUSH
74517: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
74521: LD_VAR 0 3
74525: PPUSH
74526: LD_INT 15
74528: PPUSH
74529: CALL_OW 183
// end ;
74533: GO 74480
74535: POP
74536: POP
// end ; end ; end ; end ; end ;
74537: GO 73930
74539: POP
74540: POP
// end ;
74541: LD_VAR 0 1
74545: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
74546: LD_INT 0
74548: PPUSH
74549: PPUSH
74550: PPUSH
74551: PPUSH
// if not mc_bases then
74552: LD_EXP 60
74556: NOT
74557: IFFALSE 74561
// exit ;
74559: GO 74739
// for i = 1 to mc_bases do
74561: LD_ADDR_VAR 0 2
74565: PUSH
74566: DOUBLE
74567: LD_INT 1
74569: DEC
74570: ST_TO_ADDR
74571: LD_EXP 60
74575: PUSH
74576: FOR_TO
74577: IFFALSE 74737
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
74579: LD_ADDR_VAR 0 4
74583: PUSH
74584: LD_EXP 60
74588: PUSH
74589: LD_VAR 0 2
74593: ARRAY
74594: PPUSH
74595: LD_INT 25
74597: PUSH
74598: LD_INT 9
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PPUSH
74605: CALL_OW 72
74609: ST_TO_ADDR
// if not tmp then
74610: LD_VAR 0 4
74614: NOT
74615: IFFALSE 74619
// continue ;
74617: GO 74576
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
74619: LD_EXP 86
74623: PUSH
74624: LD_VAR 0 2
74628: ARRAY
74629: PPUSH
74630: LD_INT 29
74632: PPUSH
74633: CALL_OW 325
74637: NOT
74638: PUSH
74639: LD_EXP 86
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: PPUSH
74650: LD_INT 28
74652: PPUSH
74653: CALL_OW 325
74657: NOT
74658: AND
74659: IFFALSE 74663
// continue ;
74661: GO 74576
// for j in tmp do
74663: LD_ADDR_VAR 0 3
74667: PUSH
74668: LD_VAR 0 4
74672: PUSH
74673: FOR_IN
74674: IFFALSE 74733
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74676: LD_VAR 0 3
74680: PUSH
74681: LD_EXP 63
74685: PUSH
74686: LD_VAR 0 2
74690: ARRAY
74691: PUSH
74692: LD_INT 1
74694: ARRAY
74695: IN
74696: NOT
74697: PUSH
74698: LD_VAR 0 3
74702: PUSH
74703: LD_EXP 63
74707: PUSH
74708: LD_VAR 0 2
74712: ARRAY
74713: PUSH
74714: LD_INT 2
74716: ARRAY
74717: IN
74718: NOT
74719: AND
74720: IFFALSE 74731
// ComSpaceTimeShoot ( j ) ;
74722: LD_VAR 0 3
74726: PPUSH
74727: CALL 15762 0 1
74731: GO 74673
74733: POP
74734: POP
// end ;
74735: GO 74576
74737: POP
74738: POP
// end ;
74739: LD_VAR 0 1
74743: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
74744: LD_INT 0
74746: PPUSH
74747: PPUSH
74748: PPUSH
74749: PPUSH
74750: PPUSH
74751: PPUSH
74752: PPUSH
74753: PPUSH
74754: PPUSH
// if not mc_bases then
74755: LD_EXP 60
74759: NOT
74760: IFFALSE 74764
// exit ;
74762: GO 75386
// for i = 1 to mc_bases do
74764: LD_ADDR_VAR 0 2
74768: PUSH
74769: DOUBLE
74770: LD_INT 1
74772: DEC
74773: ST_TO_ADDR
74774: LD_EXP 60
74778: PUSH
74779: FOR_TO
74780: IFFALSE 75384
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
74782: LD_EXP 95
74786: PUSH
74787: LD_VAR 0 2
74791: ARRAY
74792: NOT
74793: PUSH
74794: LD_INT 38
74796: PPUSH
74797: LD_EXP 86
74801: PUSH
74802: LD_VAR 0 2
74806: ARRAY
74807: PPUSH
74808: CALL_OW 321
74812: PUSH
74813: LD_INT 2
74815: NONEQUAL
74816: OR
74817: IFFALSE 74821
// continue ;
74819: GO 74779
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
74821: LD_ADDR_VAR 0 8
74825: PUSH
74826: LD_EXP 60
74830: PUSH
74831: LD_VAR 0 2
74835: ARRAY
74836: PPUSH
74837: LD_INT 30
74839: PUSH
74840: LD_INT 34
74842: PUSH
74843: EMPTY
74844: LIST
74845: LIST
74846: PPUSH
74847: CALL_OW 72
74851: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
74852: LD_ADDR_VAR 0 9
74856: PUSH
74857: LD_EXP 60
74861: PUSH
74862: LD_VAR 0 2
74866: ARRAY
74867: PPUSH
74868: LD_INT 25
74870: PUSH
74871: LD_INT 4
74873: PUSH
74874: EMPTY
74875: LIST
74876: LIST
74877: PPUSH
74878: CALL_OW 72
74882: PPUSH
74883: LD_INT 0
74885: PPUSH
74886: CALL 49070 0 2
74890: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
74891: LD_VAR 0 9
74895: NOT
74896: PUSH
74897: LD_VAR 0 8
74901: NOT
74902: OR
74903: PUSH
74904: LD_EXP 60
74908: PUSH
74909: LD_VAR 0 2
74913: ARRAY
74914: PPUSH
74915: LD_INT 124
74917: PPUSH
74918: CALL 49070 0 2
74922: OR
74923: IFFALSE 74927
// continue ;
74925: GO 74779
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
74927: LD_EXP 96
74931: PUSH
74932: LD_VAR 0 2
74936: ARRAY
74937: PUSH
74938: LD_EXP 95
74942: PUSH
74943: LD_VAR 0 2
74947: ARRAY
74948: LESS
74949: PUSH
74950: LD_EXP 96
74954: PUSH
74955: LD_VAR 0 2
74959: ARRAY
74960: PUSH
74961: LD_VAR 0 8
74965: LESS
74966: AND
74967: IFFALSE 75382
// begin tmp := sci [ 1 ] ;
74969: LD_ADDR_VAR 0 7
74973: PUSH
74974: LD_VAR 0 9
74978: PUSH
74979: LD_INT 1
74981: ARRAY
74982: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
74983: LD_VAR 0 7
74987: PPUSH
74988: LD_INT 124
74990: PPUSH
74991: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
74995: LD_ADDR_VAR 0 3
74999: PUSH
75000: DOUBLE
75001: LD_EXP 95
75005: PUSH
75006: LD_VAR 0 2
75010: ARRAY
75011: INC
75012: ST_TO_ADDR
75013: LD_EXP 95
75017: PUSH
75018: LD_VAR 0 2
75022: ARRAY
75023: PUSH
75024: FOR_DOWNTO
75025: IFFALSE 75368
// begin if IsInUnit ( tmp ) then
75027: LD_VAR 0 7
75031: PPUSH
75032: CALL_OW 310
75036: IFFALSE 75047
// ComExitBuilding ( tmp ) ;
75038: LD_VAR 0 7
75042: PPUSH
75043: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75047: LD_INT 35
75049: PPUSH
75050: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75054: LD_VAR 0 7
75058: PPUSH
75059: CALL_OW 310
75063: NOT
75064: PUSH
75065: LD_VAR 0 7
75069: PPUSH
75070: CALL_OW 314
75074: NOT
75075: AND
75076: IFFALSE 75047
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75078: LD_ADDR_VAR 0 6
75082: PUSH
75083: LD_VAR 0 7
75087: PPUSH
75088: CALL_OW 250
75092: PUSH
75093: LD_VAR 0 7
75097: PPUSH
75098: CALL_OW 251
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75107: LD_INT 35
75109: PPUSH
75110: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75114: LD_ADDR_VAR 0 4
75118: PUSH
75119: LD_EXP 95
75123: PUSH
75124: LD_VAR 0 2
75128: ARRAY
75129: PUSH
75130: LD_VAR 0 3
75134: ARRAY
75135: PUSH
75136: LD_INT 1
75138: ARRAY
75139: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75140: LD_ADDR_VAR 0 5
75144: PUSH
75145: LD_EXP 95
75149: PUSH
75150: LD_VAR 0 2
75154: ARRAY
75155: PUSH
75156: LD_VAR 0 3
75160: ARRAY
75161: PUSH
75162: LD_INT 2
75164: ARRAY
75165: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75166: LD_VAR 0 7
75170: PPUSH
75171: LD_INT 10
75173: PPUSH
75174: CALL 22400 0 2
75178: PUSH
75179: LD_INT 4
75181: ARRAY
75182: IFFALSE 75220
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75184: LD_VAR 0 7
75188: PPUSH
75189: LD_VAR 0 6
75193: PUSH
75194: LD_INT 1
75196: ARRAY
75197: PPUSH
75198: LD_VAR 0 6
75202: PUSH
75203: LD_INT 2
75205: ARRAY
75206: PPUSH
75207: CALL_OW 111
// wait ( 0 0$10 ) ;
75211: LD_INT 350
75213: PPUSH
75214: CALL_OW 67
// end else
75218: GO 75246
// begin ComMoveXY ( tmp , x , y ) ;
75220: LD_VAR 0 7
75224: PPUSH
75225: LD_VAR 0 4
75229: PPUSH
75230: LD_VAR 0 5
75234: PPUSH
75235: CALL_OW 111
// wait ( 0 0$3 ) ;
75239: LD_INT 105
75241: PPUSH
75242: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75246: LD_VAR 0 7
75250: PPUSH
75251: LD_VAR 0 4
75255: PPUSH
75256: LD_VAR 0 5
75260: PPUSH
75261: CALL_OW 307
75265: IFFALSE 75107
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75267: LD_VAR 0 7
75271: PPUSH
75272: LD_VAR 0 4
75276: PPUSH
75277: LD_VAR 0 5
75281: PPUSH
75282: LD_VAR 0 8
75286: PUSH
75287: LD_VAR 0 3
75291: ARRAY
75292: PPUSH
75293: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75297: LD_INT 35
75299: PPUSH
75300: CALL_OW 67
// until not HasTask ( tmp ) ;
75304: LD_VAR 0 7
75308: PPUSH
75309: CALL_OW 314
75313: NOT
75314: IFFALSE 75297
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75316: LD_ADDR_EXP 96
75320: PUSH
75321: LD_EXP 96
75325: PPUSH
75326: LD_VAR 0 2
75330: PUSH
75331: LD_EXP 96
75335: PUSH
75336: LD_VAR 0 2
75340: ARRAY
75341: PUSH
75342: LD_INT 1
75344: PLUS
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PPUSH
75350: LD_VAR 0 8
75354: PUSH
75355: LD_VAR 0 3
75359: ARRAY
75360: PPUSH
75361: CALL 19801 0 3
75365: ST_TO_ADDR
// end ;
75366: GO 75024
75368: POP
75369: POP
// MC_Reset ( i , 124 ) ;
75370: LD_VAR 0 2
75374: PPUSH
75375: LD_INT 124
75377: PPUSH
75378: CALL 58524 0 2
// end ; end ;
75382: GO 74779
75384: POP
75385: POP
// end ;
75386: LD_VAR 0 1
75390: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75391: LD_INT 0
75393: PPUSH
75394: PPUSH
75395: PPUSH
// if not mc_bases then
75396: LD_EXP 60
75400: NOT
75401: IFFALSE 75405
// exit ;
75403: GO 76011
// for i = 1 to mc_bases do
75405: LD_ADDR_VAR 0 2
75409: PUSH
75410: DOUBLE
75411: LD_INT 1
75413: DEC
75414: ST_TO_ADDR
75415: LD_EXP 60
75419: PUSH
75420: FOR_TO
75421: IFFALSE 76009
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75423: LD_ADDR_VAR 0 3
75427: PUSH
75428: LD_EXP 60
75432: PUSH
75433: LD_VAR 0 2
75437: ARRAY
75438: PPUSH
75439: LD_INT 25
75441: PUSH
75442: LD_INT 4
75444: PUSH
75445: EMPTY
75446: LIST
75447: LIST
75448: PPUSH
75449: CALL_OW 72
75453: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75454: LD_VAR 0 3
75458: NOT
75459: PUSH
75460: LD_EXP 97
75464: PUSH
75465: LD_VAR 0 2
75469: ARRAY
75470: NOT
75471: OR
75472: PUSH
75473: LD_EXP 60
75477: PUSH
75478: LD_VAR 0 2
75482: ARRAY
75483: PPUSH
75484: LD_INT 2
75486: PUSH
75487: LD_INT 30
75489: PUSH
75490: LD_INT 0
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: LD_INT 30
75499: PUSH
75500: LD_INT 1
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: LIST
75511: PPUSH
75512: CALL_OW 72
75516: NOT
75517: OR
75518: IFFALSE 75568
// begin if mc_deposits_finder [ i ] then
75520: LD_EXP 98
75524: PUSH
75525: LD_VAR 0 2
75529: ARRAY
75530: IFFALSE 75566
// begin MC_Reset ( i , 125 ) ;
75532: LD_VAR 0 2
75536: PPUSH
75537: LD_INT 125
75539: PPUSH
75540: CALL 58524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75544: LD_ADDR_EXP 98
75548: PUSH
75549: LD_EXP 98
75553: PPUSH
75554: LD_VAR 0 2
75558: PPUSH
75559: EMPTY
75560: PPUSH
75561: CALL_OW 1
75565: ST_TO_ADDR
// end ; continue ;
75566: GO 75420
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
75568: LD_EXP 97
75572: PUSH
75573: LD_VAR 0 2
75577: ARRAY
75578: PUSH
75579: LD_INT 1
75581: ARRAY
75582: PUSH
75583: LD_INT 3
75585: ARRAY
75586: PUSH
75587: LD_INT 1
75589: EQUAL
75590: PUSH
75591: LD_INT 20
75593: PPUSH
75594: LD_EXP 86
75598: PUSH
75599: LD_VAR 0 2
75603: ARRAY
75604: PPUSH
75605: CALL_OW 321
75609: PUSH
75610: LD_INT 2
75612: NONEQUAL
75613: AND
75614: IFFALSE 75664
// begin if mc_deposits_finder [ i ] then
75616: LD_EXP 98
75620: PUSH
75621: LD_VAR 0 2
75625: ARRAY
75626: IFFALSE 75662
// begin MC_Reset ( i , 125 ) ;
75628: LD_VAR 0 2
75632: PPUSH
75633: LD_INT 125
75635: PPUSH
75636: CALL 58524 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
75640: LD_ADDR_EXP 98
75644: PUSH
75645: LD_EXP 98
75649: PPUSH
75650: LD_VAR 0 2
75654: PPUSH
75655: EMPTY
75656: PPUSH
75657: CALL_OW 1
75661: ST_TO_ADDR
// end ; continue ;
75662: GO 75420
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
75664: LD_EXP 97
75668: PUSH
75669: LD_VAR 0 2
75673: ARRAY
75674: PUSH
75675: LD_INT 1
75677: ARRAY
75678: PUSH
75679: LD_INT 1
75681: ARRAY
75682: PPUSH
75683: LD_EXP 97
75687: PUSH
75688: LD_VAR 0 2
75692: ARRAY
75693: PUSH
75694: LD_INT 1
75696: ARRAY
75697: PUSH
75698: LD_INT 2
75700: ARRAY
75701: PPUSH
75702: LD_EXP 86
75706: PUSH
75707: LD_VAR 0 2
75711: ARRAY
75712: PPUSH
75713: CALL_OW 440
75717: IFFALSE 75760
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
75719: LD_ADDR_EXP 97
75723: PUSH
75724: LD_EXP 97
75728: PPUSH
75729: LD_VAR 0 2
75733: PPUSH
75734: LD_EXP 97
75738: PUSH
75739: LD_VAR 0 2
75743: ARRAY
75744: PPUSH
75745: LD_INT 1
75747: PPUSH
75748: CALL_OW 3
75752: PPUSH
75753: CALL_OW 1
75757: ST_TO_ADDR
75758: GO 76007
// begin if not mc_deposits_finder [ i ] then
75760: LD_EXP 98
75764: PUSH
75765: LD_VAR 0 2
75769: ARRAY
75770: NOT
75771: IFFALSE 75823
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
75773: LD_ADDR_EXP 98
75777: PUSH
75778: LD_EXP 98
75782: PPUSH
75783: LD_VAR 0 2
75787: PPUSH
75788: LD_VAR 0 3
75792: PUSH
75793: LD_INT 1
75795: ARRAY
75796: PUSH
75797: EMPTY
75798: LIST
75799: PPUSH
75800: CALL_OW 1
75804: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
75805: LD_VAR 0 3
75809: PUSH
75810: LD_INT 1
75812: ARRAY
75813: PPUSH
75814: LD_INT 125
75816: PPUSH
75817: CALL_OW 109
// end else
75821: GO 76007
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
75823: LD_EXP 98
75827: PUSH
75828: LD_VAR 0 2
75832: ARRAY
75833: PUSH
75834: LD_INT 1
75836: ARRAY
75837: PPUSH
75838: CALL_OW 310
75842: IFFALSE 75865
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
75844: LD_EXP 98
75848: PUSH
75849: LD_VAR 0 2
75853: ARRAY
75854: PUSH
75855: LD_INT 1
75857: ARRAY
75858: PPUSH
75859: CALL_OW 122
75863: GO 76007
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
75865: LD_EXP 98
75869: PUSH
75870: LD_VAR 0 2
75874: ARRAY
75875: PUSH
75876: LD_INT 1
75878: ARRAY
75879: PPUSH
75880: CALL_OW 314
75884: NOT
75885: PUSH
75886: LD_EXP 98
75890: PUSH
75891: LD_VAR 0 2
75895: ARRAY
75896: PUSH
75897: LD_INT 1
75899: ARRAY
75900: PPUSH
75901: LD_EXP 97
75905: PUSH
75906: LD_VAR 0 2
75910: ARRAY
75911: PUSH
75912: LD_INT 1
75914: ARRAY
75915: PUSH
75916: LD_INT 1
75918: ARRAY
75919: PPUSH
75920: LD_EXP 97
75924: PUSH
75925: LD_VAR 0 2
75929: ARRAY
75930: PUSH
75931: LD_INT 1
75933: ARRAY
75934: PUSH
75935: LD_INT 2
75937: ARRAY
75938: PPUSH
75939: CALL_OW 297
75943: PUSH
75944: LD_INT 6
75946: GREATER
75947: AND
75948: IFFALSE 76007
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
75950: LD_EXP 98
75954: PUSH
75955: LD_VAR 0 2
75959: ARRAY
75960: PUSH
75961: LD_INT 1
75963: ARRAY
75964: PPUSH
75965: LD_EXP 97
75969: PUSH
75970: LD_VAR 0 2
75974: ARRAY
75975: PUSH
75976: LD_INT 1
75978: ARRAY
75979: PUSH
75980: LD_INT 1
75982: ARRAY
75983: PPUSH
75984: LD_EXP 97
75988: PUSH
75989: LD_VAR 0 2
75993: ARRAY
75994: PUSH
75995: LD_INT 1
75997: ARRAY
75998: PUSH
75999: LD_INT 2
76001: ARRAY
76002: PPUSH
76003: CALL_OW 111
// end ; end ; end ;
76007: GO 75420
76009: POP
76010: POP
// end ;
76011: LD_VAR 0 1
76015: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76016: LD_INT 0
76018: PPUSH
76019: PPUSH
76020: PPUSH
76021: PPUSH
76022: PPUSH
76023: PPUSH
76024: PPUSH
76025: PPUSH
76026: PPUSH
76027: PPUSH
76028: PPUSH
// if not mc_bases then
76029: LD_EXP 60
76033: NOT
76034: IFFALSE 76038
// exit ;
76036: GO 76978
// for i = 1 to mc_bases do
76038: LD_ADDR_VAR 0 2
76042: PUSH
76043: DOUBLE
76044: LD_INT 1
76046: DEC
76047: ST_TO_ADDR
76048: LD_EXP 60
76052: PUSH
76053: FOR_TO
76054: IFFALSE 76976
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76056: LD_EXP 60
76060: PUSH
76061: LD_VAR 0 2
76065: ARRAY
76066: NOT
76067: PUSH
76068: LD_EXP 83
76072: PUSH
76073: LD_VAR 0 2
76077: ARRAY
76078: OR
76079: IFFALSE 76083
// continue ;
76081: GO 76053
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76083: LD_ADDR_VAR 0 7
76087: PUSH
76088: LD_EXP 60
76092: PUSH
76093: LD_VAR 0 2
76097: ARRAY
76098: PUSH
76099: LD_INT 1
76101: ARRAY
76102: PPUSH
76103: CALL_OW 248
76107: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76108: LD_VAR 0 7
76112: PUSH
76113: LD_INT 3
76115: EQUAL
76116: PUSH
76117: LD_EXP 79
76121: PUSH
76122: LD_VAR 0 2
76126: ARRAY
76127: PUSH
76128: LD_EXP 82
76132: PUSH
76133: LD_VAR 0 2
76137: ARRAY
76138: UNION
76139: PPUSH
76140: LD_INT 33
76142: PUSH
76143: LD_INT 2
76145: PUSH
76146: EMPTY
76147: LIST
76148: LIST
76149: PPUSH
76150: CALL_OW 72
76154: NOT
76155: OR
76156: IFFALSE 76160
// continue ;
76158: GO 76053
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76160: LD_ADDR_VAR 0 9
76164: PUSH
76165: LD_EXP 60
76169: PUSH
76170: LD_VAR 0 2
76174: ARRAY
76175: PPUSH
76176: LD_INT 30
76178: PUSH
76179: LD_INT 36
76181: PUSH
76182: EMPTY
76183: LIST
76184: LIST
76185: PPUSH
76186: CALL_OW 72
76190: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76191: LD_ADDR_VAR 0 10
76195: PUSH
76196: LD_EXP 79
76200: PUSH
76201: LD_VAR 0 2
76205: ARRAY
76206: PPUSH
76207: LD_INT 34
76209: PUSH
76210: LD_INT 31
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PPUSH
76217: CALL_OW 72
76221: ST_TO_ADDR
// if not cts and not mcts then
76222: LD_VAR 0 9
76226: NOT
76227: PUSH
76228: LD_VAR 0 10
76232: NOT
76233: AND
76234: IFFALSE 76238
// continue ;
76236: GO 76053
// x := cts ;
76238: LD_ADDR_VAR 0 11
76242: PUSH
76243: LD_VAR 0 9
76247: ST_TO_ADDR
// if not x then
76248: LD_VAR 0 11
76252: NOT
76253: IFFALSE 76265
// x := mcts ;
76255: LD_ADDR_VAR 0 11
76259: PUSH
76260: LD_VAR 0 10
76264: ST_TO_ADDR
// if not x then
76265: LD_VAR 0 11
76269: NOT
76270: IFFALSE 76274
// continue ;
76272: GO 76053
// if mc_remote_driver [ i ] then
76274: LD_EXP 100
76278: PUSH
76279: LD_VAR 0 2
76283: ARRAY
76284: IFFALSE 76671
// for j in mc_remote_driver [ i ] do
76286: LD_ADDR_VAR 0 3
76290: PUSH
76291: LD_EXP 100
76295: PUSH
76296: LD_VAR 0 2
76300: ARRAY
76301: PUSH
76302: FOR_IN
76303: IFFALSE 76669
// begin if GetClass ( j ) <> 3 then
76305: LD_VAR 0 3
76309: PPUSH
76310: CALL_OW 257
76314: PUSH
76315: LD_INT 3
76317: NONEQUAL
76318: IFFALSE 76371
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76320: LD_ADDR_EXP 100
76324: PUSH
76325: LD_EXP 100
76329: PPUSH
76330: LD_VAR 0 2
76334: PPUSH
76335: LD_EXP 100
76339: PUSH
76340: LD_VAR 0 2
76344: ARRAY
76345: PUSH
76346: LD_VAR 0 3
76350: DIFF
76351: PPUSH
76352: CALL_OW 1
76356: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76357: LD_VAR 0 3
76361: PPUSH
76362: LD_INT 0
76364: PPUSH
76365: CALL_OW 109
// continue ;
76369: GO 76302
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76371: LD_EXP 79
76375: PUSH
76376: LD_VAR 0 2
76380: ARRAY
76381: PPUSH
76382: LD_INT 34
76384: PUSH
76385: LD_INT 31
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 58
76394: PUSH
76395: EMPTY
76396: LIST
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PPUSH
76402: CALL_OW 72
76406: PUSH
76407: LD_VAR 0 3
76411: PPUSH
76412: CALL 49158 0 1
76416: NOT
76417: AND
76418: IFFALSE 76489
// begin if IsInUnit ( j ) then
76420: LD_VAR 0 3
76424: PPUSH
76425: CALL_OW 310
76429: IFFALSE 76440
// ComExitBuilding ( j ) ;
76431: LD_VAR 0 3
76435: PPUSH
76436: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
76440: LD_VAR 0 3
76444: PPUSH
76445: LD_EXP 79
76449: PUSH
76450: LD_VAR 0 2
76454: ARRAY
76455: PPUSH
76456: LD_INT 34
76458: PUSH
76459: LD_INT 31
76461: PUSH
76462: EMPTY
76463: LIST
76464: LIST
76465: PUSH
76466: LD_INT 58
76468: PUSH
76469: EMPTY
76470: LIST
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PPUSH
76476: CALL_OW 72
76480: PUSH
76481: LD_INT 1
76483: ARRAY
76484: PPUSH
76485: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
76489: LD_VAR 0 3
76493: PPUSH
76494: CALL_OW 310
76498: NOT
76499: PUSH
76500: LD_VAR 0 3
76504: PPUSH
76505: CALL_OW 310
76509: PPUSH
76510: CALL_OW 266
76514: PUSH
76515: LD_INT 36
76517: NONEQUAL
76518: PUSH
76519: LD_VAR 0 3
76523: PPUSH
76524: CALL 49158 0 1
76528: NOT
76529: AND
76530: OR
76531: IFFALSE 76667
// begin if IsInUnit ( j ) then
76533: LD_VAR 0 3
76537: PPUSH
76538: CALL_OW 310
76542: IFFALSE 76553
// ComExitBuilding ( j ) ;
76544: LD_VAR 0 3
76548: PPUSH
76549: CALL_OW 122
// ct := 0 ;
76553: LD_ADDR_VAR 0 8
76557: PUSH
76558: LD_INT 0
76560: ST_TO_ADDR
// for k in x do
76561: LD_ADDR_VAR 0 4
76565: PUSH
76566: LD_VAR 0 11
76570: PUSH
76571: FOR_IN
76572: IFFALSE 76645
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
76574: LD_VAR 0 4
76578: PPUSH
76579: CALL_OW 264
76583: PUSH
76584: LD_INT 31
76586: EQUAL
76587: PUSH
76588: LD_VAR 0 4
76592: PPUSH
76593: CALL_OW 311
76597: NOT
76598: AND
76599: PUSH
76600: LD_VAR 0 4
76604: PPUSH
76605: CALL_OW 266
76609: PUSH
76610: LD_INT 36
76612: EQUAL
76613: PUSH
76614: LD_VAR 0 4
76618: PPUSH
76619: CALL_OW 313
76623: PUSH
76624: LD_INT 3
76626: LESS
76627: AND
76628: OR
76629: IFFALSE 76643
// begin ct := k ;
76631: LD_ADDR_VAR 0 8
76635: PUSH
76636: LD_VAR 0 4
76640: ST_TO_ADDR
// break ;
76641: GO 76645
// end ;
76643: GO 76571
76645: POP
76646: POP
// if ct then
76647: LD_VAR 0 8
76651: IFFALSE 76667
// ComEnterUnit ( j , ct ) ;
76653: LD_VAR 0 3
76657: PPUSH
76658: LD_VAR 0 8
76662: PPUSH
76663: CALL_OW 120
// end ; end ;
76667: GO 76302
76669: POP
76670: POP
// places := 0 ;
76671: LD_ADDR_VAR 0 5
76675: PUSH
76676: LD_INT 0
76678: ST_TO_ADDR
// for j = 1 to x do
76679: LD_ADDR_VAR 0 3
76683: PUSH
76684: DOUBLE
76685: LD_INT 1
76687: DEC
76688: ST_TO_ADDR
76689: LD_VAR 0 11
76693: PUSH
76694: FOR_TO
76695: IFFALSE 76771
// if GetWeapon ( x [ j ] ) = ar_control_tower then
76697: LD_VAR 0 11
76701: PUSH
76702: LD_VAR 0 3
76706: ARRAY
76707: PPUSH
76708: CALL_OW 264
76712: PUSH
76713: LD_INT 31
76715: EQUAL
76716: IFFALSE 76734
// places := places + 1 else
76718: LD_ADDR_VAR 0 5
76722: PUSH
76723: LD_VAR 0 5
76727: PUSH
76728: LD_INT 1
76730: PLUS
76731: ST_TO_ADDR
76732: GO 76769
// if GetBType ( x [ j ] ) = b_control_tower then
76734: LD_VAR 0 11
76738: PUSH
76739: LD_VAR 0 3
76743: ARRAY
76744: PPUSH
76745: CALL_OW 266
76749: PUSH
76750: LD_INT 36
76752: EQUAL
76753: IFFALSE 76769
// places := places + 3 ;
76755: LD_ADDR_VAR 0 5
76759: PUSH
76760: LD_VAR 0 5
76764: PUSH
76765: LD_INT 3
76767: PLUS
76768: ST_TO_ADDR
76769: GO 76694
76771: POP
76772: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
76773: LD_VAR 0 5
76777: PUSH
76778: LD_INT 0
76780: EQUAL
76781: PUSH
76782: LD_VAR 0 5
76786: PUSH
76787: LD_EXP 100
76791: PUSH
76792: LD_VAR 0 2
76796: ARRAY
76797: LESSEQUAL
76798: OR
76799: IFFALSE 76803
// continue ;
76801: GO 76053
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
76803: LD_ADDR_VAR 0 6
76807: PUSH
76808: LD_EXP 60
76812: PUSH
76813: LD_VAR 0 2
76817: ARRAY
76818: PPUSH
76819: LD_INT 25
76821: PUSH
76822: LD_INT 3
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PPUSH
76829: CALL_OW 72
76833: PUSH
76834: LD_EXP 100
76838: PUSH
76839: LD_VAR 0 2
76843: ARRAY
76844: DIFF
76845: PPUSH
76846: LD_INT 3
76848: PPUSH
76849: CALL 50058 0 2
76853: ST_TO_ADDR
// for j in tmp do
76854: LD_ADDR_VAR 0 3
76858: PUSH
76859: LD_VAR 0 6
76863: PUSH
76864: FOR_IN
76865: IFFALSE 76900
// if GetTag ( j ) > 0 then
76867: LD_VAR 0 3
76871: PPUSH
76872: CALL_OW 110
76876: PUSH
76877: LD_INT 0
76879: GREATER
76880: IFFALSE 76898
// tmp := tmp diff j ;
76882: LD_ADDR_VAR 0 6
76886: PUSH
76887: LD_VAR 0 6
76891: PUSH
76892: LD_VAR 0 3
76896: DIFF
76897: ST_TO_ADDR
76898: GO 76864
76900: POP
76901: POP
// if not tmp then
76902: LD_VAR 0 6
76906: NOT
76907: IFFALSE 76911
// continue ;
76909: GO 76053
// if places then
76911: LD_VAR 0 5
76915: IFFALSE 76974
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
76917: LD_ADDR_EXP 100
76921: PUSH
76922: LD_EXP 100
76926: PPUSH
76927: LD_VAR 0 2
76931: PPUSH
76932: LD_EXP 100
76936: PUSH
76937: LD_VAR 0 2
76941: ARRAY
76942: PUSH
76943: LD_VAR 0 6
76947: PUSH
76948: LD_INT 1
76950: ARRAY
76951: UNION
76952: PPUSH
76953: CALL_OW 1
76957: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
76958: LD_VAR 0 6
76962: PUSH
76963: LD_INT 1
76965: ARRAY
76966: PPUSH
76967: LD_INT 126
76969: PPUSH
76970: CALL_OW 109
// end ; end ;
76974: GO 76053
76976: POP
76977: POP
// end ;
76978: LD_VAR 0 1
76982: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
76983: LD_INT 0
76985: PPUSH
76986: PPUSH
76987: PPUSH
76988: PPUSH
76989: PPUSH
76990: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
76991: LD_VAR 0 1
76995: NOT
76996: PUSH
76997: LD_VAR 0 2
77001: NOT
77002: OR
77003: PUSH
77004: LD_VAR 0 3
77008: NOT
77009: OR
77010: PUSH
77011: LD_VAR 0 4
77015: PUSH
77016: LD_INT 1
77018: PUSH
77019: LD_INT 2
77021: PUSH
77022: LD_INT 3
77024: PUSH
77025: LD_INT 4
77027: PUSH
77028: LD_INT 5
77030: PUSH
77031: LD_INT 8
77033: PUSH
77034: LD_INT 9
77036: PUSH
77037: LD_INT 15
77039: PUSH
77040: LD_INT 16
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: IN
77054: NOT
77055: OR
77056: IFFALSE 77060
// exit ;
77058: GO 77960
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77060: LD_ADDR_VAR 0 2
77064: PUSH
77065: LD_VAR 0 2
77069: PPUSH
77070: LD_INT 21
77072: PUSH
77073: LD_INT 3
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: PUSH
77080: LD_INT 24
77082: PUSH
77083: LD_INT 250
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PPUSH
77094: CALL_OW 72
77098: ST_TO_ADDR
// case class of 1 , 15 :
77099: LD_VAR 0 4
77103: PUSH
77104: LD_INT 1
77106: DOUBLE
77107: EQUAL
77108: IFTRUE 77118
77110: LD_INT 15
77112: DOUBLE
77113: EQUAL
77114: IFTRUE 77118
77116: GO 77203
77118: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77119: LD_ADDR_VAR 0 8
77123: PUSH
77124: LD_VAR 0 2
77128: PPUSH
77129: LD_INT 2
77131: PUSH
77132: LD_INT 30
77134: PUSH
77135: LD_INT 32
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 30
77144: PUSH
77145: LD_INT 31
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: LIST
77156: PPUSH
77157: CALL_OW 72
77161: PUSH
77162: LD_VAR 0 2
77166: PPUSH
77167: LD_INT 2
77169: PUSH
77170: LD_INT 30
77172: PUSH
77173: LD_INT 4
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 30
77182: PUSH
77183: LD_INT 5
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: LIST
77194: PPUSH
77195: CALL_OW 72
77199: ADD
77200: ST_TO_ADDR
77201: GO 77449
77203: LD_INT 2
77205: DOUBLE
77206: EQUAL
77207: IFTRUE 77217
77209: LD_INT 16
77211: DOUBLE
77212: EQUAL
77213: IFTRUE 77217
77215: GO 77263
77217: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77218: LD_ADDR_VAR 0 8
77222: PUSH
77223: LD_VAR 0 2
77227: PPUSH
77228: LD_INT 2
77230: PUSH
77231: LD_INT 30
77233: PUSH
77234: LD_INT 0
77236: PUSH
77237: EMPTY
77238: LIST
77239: LIST
77240: PUSH
77241: LD_INT 30
77243: PUSH
77244: LD_INT 1
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: PUSH
77251: EMPTY
77252: LIST
77253: LIST
77254: LIST
77255: PPUSH
77256: CALL_OW 72
77260: ST_TO_ADDR
77261: GO 77449
77263: LD_INT 3
77265: DOUBLE
77266: EQUAL
77267: IFTRUE 77271
77269: GO 77317
77271: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77272: LD_ADDR_VAR 0 8
77276: PUSH
77277: LD_VAR 0 2
77281: PPUSH
77282: LD_INT 2
77284: PUSH
77285: LD_INT 30
77287: PUSH
77288: LD_INT 2
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: PUSH
77295: LD_INT 30
77297: PUSH
77298: LD_INT 3
77300: PUSH
77301: EMPTY
77302: LIST
77303: LIST
77304: PUSH
77305: EMPTY
77306: LIST
77307: LIST
77308: LIST
77309: PPUSH
77310: CALL_OW 72
77314: ST_TO_ADDR
77315: GO 77449
77317: LD_INT 4
77319: DOUBLE
77320: EQUAL
77321: IFTRUE 77325
77323: GO 77382
77325: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77326: LD_ADDR_VAR 0 8
77330: PUSH
77331: LD_VAR 0 2
77335: PPUSH
77336: LD_INT 2
77338: PUSH
77339: LD_INT 30
77341: PUSH
77342: LD_INT 6
77344: PUSH
77345: EMPTY
77346: LIST
77347: LIST
77348: PUSH
77349: LD_INT 30
77351: PUSH
77352: LD_INT 7
77354: PUSH
77355: EMPTY
77356: LIST
77357: LIST
77358: PUSH
77359: LD_INT 30
77361: PUSH
77362: LD_INT 8
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: LIST
77373: LIST
77374: PPUSH
77375: CALL_OW 72
77379: ST_TO_ADDR
77380: GO 77449
77382: LD_INT 5
77384: DOUBLE
77385: EQUAL
77386: IFTRUE 77402
77388: LD_INT 8
77390: DOUBLE
77391: EQUAL
77392: IFTRUE 77402
77394: LD_INT 9
77396: DOUBLE
77397: EQUAL
77398: IFTRUE 77402
77400: GO 77448
77402: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77403: LD_ADDR_VAR 0 8
77407: PUSH
77408: LD_VAR 0 2
77412: PPUSH
77413: LD_INT 2
77415: PUSH
77416: LD_INT 30
77418: PUSH
77419: LD_INT 4
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 30
77428: PUSH
77429: LD_INT 5
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: EMPTY
77437: LIST
77438: LIST
77439: LIST
77440: PPUSH
77441: CALL_OW 72
77445: ST_TO_ADDR
77446: GO 77449
77448: POP
// if not tmp then
77449: LD_VAR 0 8
77453: NOT
77454: IFFALSE 77458
// exit ;
77456: GO 77960
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77458: LD_VAR 0 4
77462: PUSH
77463: LD_INT 1
77465: PUSH
77466: LD_INT 15
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: IN
77473: PUSH
77474: LD_EXP 69
77478: PUSH
77479: LD_VAR 0 1
77483: ARRAY
77484: AND
77485: IFFALSE 77641
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
77487: LD_ADDR_VAR 0 9
77491: PUSH
77492: LD_EXP 69
77496: PUSH
77497: LD_VAR 0 1
77501: ARRAY
77502: PUSH
77503: LD_INT 1
77505: ARRAY
77506: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
77507: LD_VAR 0 9
77511: PUSH
77512: LD_EXP 70
77516: PUSH
77517: LD_VAR 0 1
77521: ARRAY
77522: IN
77523: NOT
77524: IFFALSE 77639
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
77526: LD_ADDR_EXP 70
77530: PUSH
77531: LD_EXP 70
77535: PPUSH
77536: LD_VAR 0 1
77540: PUSH
77541: LD_EXP 70
77545: PUSH
77546: LD_VAR 0 1
77550: ARRAY
77551: PUSH
77552: LD_INT 1
77554: PLUS
77555: PUSH
77556: EMPTY
77557: LIST
77558: LIST
77559: PPUSH
77560: LD_VAR 0 9
77564: PPUSH
77565: CALL 19801 0 3
77569: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
77570: LD_ADDR_EXP 69
77574: PUSH
77575: LD_EXP 69
77579: PPUSH
77580: LD_VAR 0 1
77584: PPUSH
77585: LD_EXP 69
77589: PUSH
77590: LD_VAR 0 1
77594: ARRAY
77595: PUSH
77596: LD_VAR 0 9
77600: DIFF
77601: PPUSH
77602: CALL_OW 1
77606: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
77607: LD_VAR 0 3
77611: PPUSH
77612: LD_EXP 70
77616: PUSH
77617: LD_VAR 0 1
77621: ARRAY
77622: PUSH
77623: LD_EXP 70
77627: PUSH
77628: LD_VAR 0 1
77632: ARRAY
77633: ARRAY
77634: PPUSH
77635: CALL_OW 120
// end ; exit ;
77639: GO 77960
// end ; if tmp > 1 then
77641: LD_VAR 0 8
77645: PUSH
77646: LD_INT 1
77648: GREATER
77649: IFFALSE 77753
// for i = 2 to tmp do
77651: LD_ADDR_VAR 0 6
77655: PUSH
77656: DOUBLE
77657: LD_INT 2
77659: DEC
77660: ST_TO_ADDR
77661: LD_VAR 0 8
77665: PUSH
77666: FOR_TO
77667: IFFALSE 77751
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
77669: LD_VAR 0 8
77673: PUSH
77674: LD_VAR 0 6
77678: ARRAY
77679: PPUSH
77680: CALL_OW 461
77684: PUSH
77685: LD_INT 6
77687: EQUAL
77688: IFFALSE 77749
// begin x := tmp [ i ] ;
77690: LD_ADDR_VAR 0 9
77694: PUSH
77695: LD_VAR 0 8
77699: PUSH
77700: LD_VAR 0 6
77704: ARRAY
77705: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
77706: LD_ADDR_VAR 0 8
77710: PUSH
77711: LD_VAR 0 8
77715: PPUSH
77716: LD_VAR 0 6
77720: PPUSH
77721: CALL_OW 3
77725: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
77726: LD_ADDR_VAR 0 8
77730: PUSH
77731: LD_VAR 0 8
77735: PPUSH
77736: LD_INT 1
77738: PPUSH
77739: LD_VAR 0 9
77743: PPUSH
77744: CALL_OW 2
77748: ST_TO_ADDR
// end ;
77749: GO 77666
77751: POP
77752: POP
// for i in tmp do
77753: LD_ADDR_VAR 0 6
77757: PUSH
77758: LD_VAR 0 8
77762: PUSH
77763: FOR_IN
77764: IFFALSE 77833
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
77766: LD_VAR 0 6
77770: PPUSH
77771: CALL_OW 313
77775: PUSH
77776: LD_INT 6
77778: LESS
77779: PUSH
77780: LD_VAR 0 6
77784: PPUSH
77785: CALL_OW 266
77789: PUSH
77790: LD_INT 31
77792: PUSH
77793: LD_INT 32
77795: PUSH
77796: EMPTY
77797: LIST
77798: LIST
77799: IN
77800: NOT
77801: AND
77802: PUSH
77803: LD_VAR 0 6
77807: PPUSH
77808: CALL_OW 313
77812: PUSH
77813: LD_INT 0
77815: EQUAL
77816: OR
77817: IFFALSE 77831
// begin j := i ;
77819: LD_ADDR_VAR 0 7
77823: PUSH
77824: LD_VAR 0 6
77828: ST_TO_ADDR
// break ;
77829: GO 77833
// end ; end ;
77831: GO 77763
77833: POP
77834: POP
// if j then
77835: LD_VAR 0 7
77839: IFFALSE 77857
// ComEnterUnit ( unit , j ) else
77841: LD_VAR 0 3
77845: PPUSH
77846: LD_VAR 0 7
77850: PPUSH
77851: CALL_OW 120
77855: GO 77960
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77857: LD_ADDR_VAR 0 10
77861: PUSH
77862: LD_VAR 0 2
77866: PPUSH
77867: LD_INT 2
77869: PUSH
77870: LD_INT 30
77872: PUSH
77873: LD_INT 0
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: PUSH
77880: LD_INT 30
77882: PUSH
77883: LD_INT 1
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: LIST
77894: PPUSH
77895: CALL_OW 72
77899: ST_TO_ADDR
// if depot then
77900: LD_VAR 0 10
77904: IFFALSE 77960
// begin depot := NearestUnitToUnit ( depot , unit ) ;
77906: LD_ADDR_VAR 0 10
77910: PUSH
77911: LD_VAR 0 10
77915: PPUSH
77916: LD_VAR 0 3
77920: PPUSH
77921: CALL_OW 74
77925: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
77926: LD_VAR 0 3
77930: PPUSH
77931: LD_VAR 0 10
77935: PPUSH
77936: CALL_OW 296
77940: PUSH
77941: LD_INT 10
77943: GREATER
77944: IFFALSE 77960
// ComStandNearbyBuilding ( unit , depot ) ;
77946: LD_VAR 0 3
77950: PPUSH
77951: LD_VAR 0 10
77955: PPUSH
77956: CALL 16379 0 2
// end ; end ; end ;
77960: LD_VAR 0 5
77964: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
77965: LD_INT 0
77967: PPUSH
77968: PPUSH
77969: PPUSH
77970: PPUSH
// if not mc_bases then
77971: LD_EXP 60
77975: NOT
77976: IFFALSE 77980
// exit ;
77978: GO 78219
// for i = 1 to mc_bases do
77980: LD_ADDR_VAR 0 2
77984: PUSH
77985: DOUBLE
77986: LD_INT 1
77988: DEC
77989: ST_TO_ADDR
77990: LD_EXP 60
77994: PUSH
77995: FOR_TO
77996: IFFALSE 78217
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
77998: LD_ADDR_VAR 0 4
78002: PUSH
78003: LD_EXP 60
78007: PUSH
78008: LD_VAR 0 2
78012: ARRAY
78013: PPUSH
78014: LD_INT 21
78016: PUSH
78017: LD_INT 1
78019: PUSH
78020: EMPTY
78021: LIST
78022: LIST
78023: PPUSH
78024: CALL_OW 72
78028: PUSH
78029: LD_EXP 89
78033: PUSH
78034: LD_VAR 0 2
78038: ARRAY
78039: UNION
78040: ST_TO_ADDR
// if not tmp then
78041: LD_VAR 0 4
78045: NOT
78046: IFFALSE 78050
// continue ;
78048: GO 77995
// for j in tmp do
78050: LD_ADDR_VAR 0 3
78054: PUSH
78055: LD_VAR 0 4
78059: PUSH
78060: FOR_IN
78061: IFFALSE 78213
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78063: LD_VAR 0 3
78067: PPUSH
78068: CALL_OW 110
78072: NOT
78073: PUSH
78074: LD_VAR 0 3
78078: PPUSH
78079: CALL_OW 314
78083: NOT
78084: AND
78085: PUSH
78086: LD_VAR 0 3
78090: PPUSH
78091: CALL_OW 311
78095: NOT
78096: AND
78097: PUSH
78098: LD_VAR 0 3
78102: PPUSH
78103: CALL_OW 310
78107: NOT
78108: AND
78109: PUSH
78110: LD_VAR 0 3
78114: PUSH
78115: LD_EXP 63
78119: PUSH
78120: LD_VAR 0 2
78124: ARRAY
78125: PUSH
78126: LD_INT 1
78128: ARRAY
78129: IN
78130: NOT
78131: AND
78132: PUSH
78133: LD_VAR 0 3
78137: PUSH
78138: LD_EXP 63
78142: PUSH
78143: LD_VAR 0 2
78147: ARRAY
78148: PUSH
78149: LD_INT 2
78151: ARRAY
78152: IN
78153: NOT
78154: AND
78155: PUSH
78156: LD_VAR 0 3
78160: PUSH
78161: LD_EXP 72
78165: PUSH
78166: LD_VAR 0 2
78170: ARRAY
78171: IN
78172: NOT
78173: AND
78174: IFFALSE 78211
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78176: LD_VAR 0 2
78180: PPUSH
78181: LD_EXP 60
78185: PUSH
78186: LD_VAR 0 2
78190: ARRAY
78191: PPUSH
78192: LD_VAR 0 3
78196: PPUSH
78197: LD_VAR 0 3
78201: PPUSH
78202: CALL_OW 257
78206: PPUSH
78207: CALL 76983 0 4
// end ;
78211: GO 78060
78213: POP
78214: POP
// end ;
78215: GO 77995
78217: POP
78218: POP
// end ;
78219: LD_VAR 0 1
78223: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78224: LD_INT 0
78226: PPUSH
78227: PPUSH
78228: PPUSH
78229: PPUSH
78230: PPUSH
78231: PPUSH
// if not mc_bases [ base ] then
78232: LD_EXP 60
78236: PUSH
78237: LD_VAR 0 1
78241: ARRAY
78242: NOT
78243: IFFALSE 78247
// exit ;
78245: GO 78429
// tmp := [ ] ;
78247: LD_ADDR_VAR 0 6
78251: PUSH
78252: EMPTY
78253: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78254: LD_ADDR_VAR 0 7
78258: PUSH
78259: LD_VAR 0 3
78263: PPUSH
78264: LD_INT 0
78266: PPUSH
78267: CALL_OW 517
78271: ST_TO_ADDR
// if not list then
78272: LD_VAR 0 7
78276: NOT
78277: IFFALSE 78281
// exit ;
78279: GO 78429
// for i = 1 to amount do
78281: LD_ADDR_VAR 0 5
78285: PUSH
78286: DOUBLE
78287: LD_INT 1
78289: DEC
78290: ST_TO_ADDR
78291: LD_VAR 0 2
78295: PUSH
78296: FOR_TO
78297: IFFALSE 78377
// begin x := rand ( 1 , list [ 1 ] ) ;
78299: LD_ADDR_VAR 0 8
78303: PUSH
78304: LD_INT 1
78306: PPUSH
78307: LD_VAR 0 7
78311: PUSH
78312: LD_INT 1
78314: ARRAY
78315: PPUSH
78316: CALL_OW 12
78320: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78321: LD_ADDR_VAR 0 6
78325: PUSH
78326: LD_VAR 0 6
78330: PPUSH
78331: LD_VAR 0 5
78335: PPUSH
78336: LD_VAR 0 7
78340: PUSH
78341: LD_INT 1
78343: ARRAY
78344: PUSH
78345: LD_VAR 0 8
78349: ARRAY
78350: PUSH
78351: LD_VAR 0 7
78355: PUSH
78356: LD_INT 2
78358: ARRAY
78359: PUSH
78360: LD_VAR 0 8
78364: ARRAY
78365: PUSH
78366: EMPTY
78367: LIST
78368: LIST
78369: PPUSH
78370: CALL_OW 1
78374: ST_TO_ADDR
// end ;
78375: GO 78296
78377: POP
78378: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78379: LD_ADDR_EXP 73
78383: PUSH
78384: LD_EXP 73
78388: PPUSH
78389: LD_VAR 0 1
78393: PPUSH
78394: LD_VAR 0 6
78398: PPUSH
78399: CALL_OW 1
78403: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78404: LD_ADDR_EXP 75
78408: PUSH
78409: LD_EXP 75
78413: PPUSH
78414: LD_VAR 0 1
78418: PPUSH
78419: LD_VAR 0 3
78423: PPUSH
78424: CALL_OW 1
78428: ST_TO_ADDR
// end ;
78429: LD_VAR 0 4
78433: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78434: LD_INT 0
78436: PPUSH
// if not mc_bases [ base ] then
78437: LD_EXP 60
78441: PUSH
78442: LD_VAR 0 1
78446: ARRAY
78447: NOT
78448: IFFALSE 78452
// exit ;
78450: GO 78477
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78452: LD_ADDR_EXP 65
78456: PUSH
78457: LD_EXP 65
78461: PPUSH
78462: LD_VAR 0 1
78466: PPUSH
78467: LD_VAR 0 2
78471: PPUSH
78472: CALL_OW 1
78476: ST_TO_ADDR
// end ;
78477: LD_VAR 0 3
78481: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
78482: LD_INT 0
78484: PPUSH
// if not mc_bases [ base ] then
78485: LD_EXP 60
78489: PUSH
78490: LD_VAR 0 1
78494: ARRAY
78495: NOT
78496: IFFALSE 78500
// exit ;
78498: GO 78537
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
78500: LD_ADDR_EXP 65
78504: PUSH
78505: LD_EXP 65
78509: PPUSH
78510: LD_VAR 0 1
78514: PPUSH
78515: LD_EXP 65
78519: PUSH
78520: LD_VAR 0 1
78524: ARRAY
78525: PUSH
78526: LD_VAR 0 2
78530: UNION
78531: PPUSH
78532: CALL_OW 1
78536: ST_TO_ADDR
// end ;
78537: LD_VAR 0 3
78541: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
78542: LD_INT 0
78544: PPUSH
// if not mc_bases [ base ] then
78545: LD_EXP 60
78549: PUSH
78550: LD_VAR 0 1
78554: ARRAY
78555: NOT
78556: IFFALSE 78560
// exit ;
78558: GO 78585
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
78560: LD_ADDR_EXP 81
78564: PUSH
78565: LD_EXP 81
78569: PPUSH
78570: LD_VAR 0 1
78574: PPUSH
78575: LD_VAR 0 2
78579: PPUSH
78580: CALL_OW 1
78584: ST_TO_ADDR
// end ;
78585: LD_VAR 0 3
78589: RET
// export function MC_InsertProduceList ( base , components ) ; begin
78590: LD_INT 0
78592: PPUSH
// if not mc_bases [ base ] then
78593: LD_EXP 60
78597: PUSH
78598: LD_VAR 0 1
78602: ARRAY
78603: NOT
78604: IFFALSE 78608
// exit ;
78606: GO 78645
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
78608: LD_ADDR_EXP 81
78612: PUSH
78613: LD_EXP 81
78617: PPUSH
78618: LD_VAR 0 1
78622: PPUSH
78623: LD_EXP 81
78627: PUSH
78628: LD_VAR 0 1
78632: ARRAY
78633: PUSH
78634: LD_VAR 0 2
78638: ADD
78639: PPUSH
78640: CALL_OW 1
78644: ST_TO_ADDR
// end ;
78645: LD_VAR 0 3
78649: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
78650: LD_INT 0
78652: PPUSH
// if not mc_bases [ base ] then
78653: LD_EXP 60
78657: PUSH
78658: LD_VAR 0 1
78662: ARRAY
78663: NOT
78664: IFFALSE 78668
// exit ;
78666: GO 78722
// mc_defender := Replace ( mc_defender , base , deflist ) ;
78668: LD_ADDR_EXP 82
78672: PUSH
78673: LD_EXP 82
78677: PPUSH
78678: LD_VAR 0 1
78682: PPUSH
78683: LD_VAR 0 2
78687: PPUSH
78688: CALL_OW 1
78692: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
78693: LD_ADDR_EXP 71
78697: PUSH
78698: LD_EXP 71
78702: PPUSH
78703: LD_VAR 0 1
78707: PPUSH
78708: LD_VAR 0 2
78712: PUSH
78713: LD_INT 0
78715: PLUS
78716: PPUSH
78717: CALL_OW 1
78721: ST_TO_ADDR
// end ;
78722: LD_VAR 0 3
78726: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
78727: LD_INT 0
78729: PPUSH
// if not mc_bases [ base ] then
78730: LD_EXP 60
78734: PUSH
78735: LD_VAR 0 1
78739: ARRAY
78740: NOT
78741: IFFALSE 78745
// exit ;
78743: GO 78770
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
78745: LD_ADDR_EXP 71
78749: PUSH
78750: LD_EXP 71
78754: PPUSH
78755: LD_VAR 0 1
78759: PPUSH
78760: LD_VAR 0 2
78764: PPUSH
78765: CALL_OW 1
78769: ST_TO_ADDR
// end ;
78770: LD_VAR 0 3
78774: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
// if not mc_bases [ base ] then
78781: LD_EXP 60
78785: PUSH
78786: LD_VAR 0 1
78790: ARRAY
78791: NOT
78792: IFFALSE 78796
// exit ;
78794: GO 78861
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
78796: LD_ADDR_EXP 80
78800: PUSH
78801: LD_EXP 80
78805: PPUSH
78806: LD_VAR 0 1
78810: PUSH
78811: LD_EXP 80
78815: PUSH
78816: LD_VAR 0 1
78820: ARRAY
78821: PUSH
78822: LD_INT 1
78824: PLUS
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: PPUSH
78830: LD_VAR 0 1
78834: PUSH
78835: LD_VAR 0 2
78839: PUSH
78840: LD_VAR 0 3
78844: PUSH
78845: LD_VAR 0 4
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: PPUSH
78856: CALL 19801 0 3
78860: ST_TO_ADDR
// end ;
78861: LD_VAR 0 5
78865: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
78866: LD_INT 0
78868: PPUSH
// if not mc_bases [ base ] then
78869: LD_EXP 60
78873: PUSH
78874: LD_VAR 0 1
78878: ARRAY
78879: NOT
78880: IFFALSE 78884
// exit ;
78882: GO 78909
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
78884: LD_ADDR_EXP 97
78888: PUSH
78889: LD_EXP 97
78893: PPUSH
78894: LD_VAR 0 1
78898: PPUSH
78899: LD_VAR 0 2
78903: PPUSH
78904: CALL_OW 1
78908: ST_TO_ADDR
// end ;
78909: LD_VAR 0 3
78913: RET
// export function MC_GetMinesField ( base ) ; begin
78914: LD_INT 0
78916: PPUSH
// result := mc_mines [ base ] ;
78917: LD_ADDR_VAR 0 2
78921: PUSH
78922: LD_EXP 73
78926: PUSH
78927: LD_VAR 0 1
78931: ARRAY
78932: ST_TO_ADDR
// end ;
78933: LD_VAR 0 2
78937: RET
// export function MC_GetProduceList ( base ) ; begin
78938: LD_INT 0
78940: PPUSH
// result := mc_produce [ base ] ;
78941: LD_ADDR_VAR 0 2
78945: PUSH
78946: LD_EXP 81
78950: PUSH
78951: LD_VAR 0 1
78955: ARRAY
78956: ST_TO_ADDR
// end ;
78957: LD_VAR 0 2
78961: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
78962: LD_INT 0
78964: PPUSH
78965: PPUSH
// if not mc_bases then
78966: LD_EXP 60
78970: NOT
78971: IFFALSE 78975
// exit ;
78973: GO 79040
// if mc_bases [ base ] then
78975: LD_EXP 60
78979: PUSH
78980: LD_VAR 0 1
78984: ARRAY
78985: IFFALSE 79040
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
78987: LD_ADDR_VAR 0 3
78991: PUSH
78992: LD_EXP 60
78996: PUSH
78997: LD_VAR 0 1
79001: ARRAY
79002: PPUSH
79003: LD_INT 30
79005: PUSH
79006: LD_VAR 0 2
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PPUSH
79015: CALL_OW 72
79019: ST_TO_ADDR
// if result then
79020: LD_VAR 0 3
79024: IFFALSE 79040
// result := result [ 1 ] ;
79026: LD_ADDR_VAR 0 3
79030: PUSH
79031: LD_VAR 0 3
79035: PUSH
79036: LD_INT 1
79038: ARRAY
79039: ST_TO_ADDR
// end ; end ;
79040: LD_VAR 0 3
79044: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79045: LD_INT 0
79047: PPUSH
79048: PPUSH
// if not mc_bases then
79049: LD_EXP 60
79053: NOT
79054: IFFALSE 79058
// exit ;
79056: GO 79103
// if mc_bases [ base ] then
79058: LD_EXP 60
79062: PUSH
79063: LD_VAR 0 1
79067: ARRAY
79068: IFFALSE 79103
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79070: LD_ADDR_VAR 0 3
79074: PUSH
79075: LD_EXP 60
79079: PUSH
79080: LD_VAR 0 1
79084: ARRAY
79085: PPUSH
79086: LD_INT 30
79088: PUSH
79089: LD_VAR 0 2
79093: PUSH
79094: EMPTY
79095: LIST
79096: LIST
79097: PPUSH
79098: CALL_OW 72
79102: ST_TO_ADDR
// end ;
79103: LD_VAR 0 3
79107: RET
// export function MC_SetTame ( base , area ) ; begin
79108: LD_INT 0
79110: PPUSH
// if not mc_bases or not base then
79111: LD_EXP 60
79115: NOT
79116: PUSH
79117: LD_VAR 0 1
79121: NOT
79122: OR
79123: IFFALSE 79127
// exit ;
79125: GO 79152
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79127: LD_ADDR_EXP 88
79131: PUSH
79132: LD_EXP 88
79136: PPUSH
79137: LD_VAR 0 1
79141: PPUSH
79142: LD_VAR 0 2
79146: PPUSH
79147: CALL_OW 1
79151: ST_TO_ADDR
// end ;
79152: LD_VAR 0 3
79156: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79157: LD_INT 0
79159: PPUSH
79160: PPUSH
// if not mc_bases or not base then
79161: LD_EXP 60
79165: NOT
79166: PUSH
79167: LD_VAR 0 1
79171: NOT
79172: OR
79173: IFFALSE 79177
// exit ;
79175: GO 79279
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79177: LD_ADDR_VAR 0 4
79181: PUSH
79182: LD_EXP 60
79186: PUSH
79187: LD_VAR 0 1
79191: ARRAY
79192: PPUSH
79193: LD_INT 30
79195: PUSH
79196: LD_VAR 0 2
79200: PUSH
79201: EMPTY
79202: LIST
79203: LIST
79204: PPUSH
79205: CALL_OW 72
79209: ST_TO_ADDR
// if not tmp then
79210: LD_VAR 0 4
79214: NOT
79215: IFFALSE 79219
// exit ;
79217: GO 79279
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79219: LD_ADDR_EXP 92
79223: PUSH
79224: LD_EXP 92
79228: PPUSH
79229: LD_VAR 0 1
79233: PPUSH
79234: LD_EXP 92
79238: PUSH
79239: LD_VAR 0 1
79243: ARRAY
79244: PPUSH
79245: LD_EXP 92
79249: PUSH
79250: LD_VAR 0 1
79254: ARRAY
79255: PUSH
79256: LD_INT 1
79258: PLUS
79259: PPUSH
79260: LD_VAR 0 4
79264: PUSH
79265: LD_INT 1
79267: ARRAY
79268: PPUSH
79269: CALL_OW 2
79273: PPUSH
79274: CALL_OW 1
79278: ST_TO_ADDR
// end ;
79279: LD_VAR 0 3
79283: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79284: LD_INT 0
79286: PPUSH
79287: PPUSH
// if not mc_bases or not base or not kinds then
79288: LD_EXP 60
79292: NOT
79293: PUSH
79294: LD_VAR 0 1
79298: NOT
79299: OR
79300: PUSH
79301: LD_VAR 0 2
79305: NOT
79306: OR
79307: IFFALSE 79311
// exit ;
79309: GO 79372
// for i in kinds do
79311: LD_ADDR_VAR 0 4
79315: PUSH
79316: LD_VAR 0 2
79320: PUSH
79321: FOR_IN
79322: IFFALSE 79370
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79324: LD_ADDR_EXP 94
79328: PUSH
79329: LD_EXP 94
79333: PPUSH
79334: LD_VAR 0 1
79338: PUSH
79339: LD_EXP 94
79343: PUSH
79344: LD_VAR 0 1
79348: ARRAY
79349: PUSH
79350: LD_INT 1
79352: PLUS
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PPUSH
79358: LD_VAR 0 4
79362: PPUSH
79363: CALL 19801 0 3
79367: ST_TO_ADDR
79368: GO 79321
79370: POP
79371: POP
// end ;
79372: LD_VAR 0 3
79376: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79377: LD_INT 0
79379: PPUSH
// if not mc_bases or not base or not areas then
79380: LD_EXP 60
79384: NOT
79385: PUSH
79386: LD_VAR 0 1
79390: NOT
79391: OR
79392: PUSH
79393: LD_VAR 0 2
79397: NOT
79398: OR
79399: IFFALSE 79403
// exit ;
79401: GO 79428
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79403: LD_ADDR_EXP 78
79407: PUSH
79408: LD_EXP 78
79412: PPUSH
79413: LD_VAR 0 1
79417: PPUSH
79418: LD_VAR 0 2
79422: PPUSH
79423: CALL_OW 1
79427: ST_TO_ADDR
// end ;
79428: LD_VAR 0 3
79432: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79433: LD_INT 0
79435: PPUSH
// if not mc_bases or not base or not teleports_exit then
79436: LD_EXP 60
79440: NOT
79441: PUSH
79442: LD_VAR 0 1
79446: NOT
79447: OR
79448: PUSH
79449: LD_VAR 0 2
79453: NOT
79454: OR
79455: IFFALSE 79459
// exit ;
79457: GO 79484
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79459: LD_ADDR_EXP 95
79463: PUSH
79464: LD_EXP 95
79468: PPUSH
79469: LD_VAR 0 1
79473: PPUSH
79474: LD_VAR 0 2
79478: PPUSH
79479: CALL_OW 1
79483: ST_TO_ADDR
// end ;
79484: LD_VAR 0 3
79488: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
79489: LD_INT 0
79491: PPUSH
79492: PPUSH
79493: PPUSH
// if not mc_bases or not base or not ext_list then
79494: LD_EXP 60
79498: NOT
79499: PUSH
79500: LD_VAR 0 1
79504: NOT
79505: OR
79506: PUSH
79507: LD_VAR 0 5
79511: NOT
79512: OR
79513: IFFALSE 79517
// exit ;
79515: GO 79690
// tmp := GetFacExtXYD ( x , y , d ) ;
79517: LD_ADDR_VAR 0 8
79521: PUSH
79522: LD_VAR 0 2
79526: PPUSH
79527: LD_VAR 0 3
79531: PPUSH
79532: LD_VAR 0 4
79536: PPUSH
79537: CALL 49188 0 3
79541: ST_TO_ADDR
// if not tmp then
79542: LD_VAR 0 8
79546: NOT
79547: IFFALSE 79551
// exit ;
79549: GO 79690
// for i in tmp do
79551: LD_ADDR_VAR 0 7
79555: PUSH
79556: LD_VAR 0 8
79560: PUSH
79561: FOR_IN
79562: IFFALSE 79688
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
79564: LD_ADDR_EXP 65
79568: PUSH
79569: LD_EXP 65
79573: PPUSH
79574: LD_VAR 0 1
79578: PPUSH
79579: LD_EXP 65
79583: PUSH
79584: LD_VAR 0 1
79588: ARRAY
79589: PPUSH
79590: LD_EXP 65
79594: PUSH
79595: LD_VAR 0 1
79599: ARRAY
79600: PUSH
79601: LD_INT 1
79603: PLUS
79604: PPUSH
79605: LD_VAR 0 5
79609: PUSH
79610: LD_INT 1
79612: ARRAY
79613: PUSH
79614: LD_VAR 0 7
79618: PUSH
79619: LD_INT 1
79621: ARRAY
79622: PUSH
79623: LD_VAR 0 7
79627: PUSH
79628: LD_INT 2
79630: ARRAY
79631: PUSH
79632: LD_VAR 0 7
79636: PUSH
79637: LD_INT 3
79639: ARRAY
79640: PUSH
79641: EMPTY
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: PPUSH
79647: CALL_OW 2
79651: PPUSH
79652: CALL_OW 1
79656: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
79657: LD_ADDR_VAR 0 5
79661: PUSH
79662: LD_VAR 0 5
79666: PPUSH
79667: LD_INT 1
79669: PPUSH
79670: CALL_OW 3
79674: ST_TO_ADDR
// if not ext_list then
79675: LD_VAR 0 5
79679: NOT
79680: IFFALSE 79686
// exit ;
79682: POP
79683: POP
79684: GO 79690
// end ;
79686: GO 79561
79688: POP
79689: POP
// end ;
79690: LD_VAR 0 6
79694: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
79695: LD_INT 0
79697: PPUSH
// if not mc_bases or not base or not weapon_list then
79698: LD_EXP 60
79702: NOT
79703: PUSH
79704: LD_VAR 0 1
79708: NOT
79709: OR
79710: PUSH
79711: LD_VAR 0 2
79715: NOT
79716: OR
79717: IFFALSE 79721
// exit ;
79719: GO 79746
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
79721: LD_ADDR_EXP 99
79725: PUSH
79726: LD_EXP 99
79730: PPUSH
79731: LD_VAR 0 1
79735: PPUSH
79736: LD_VAR 0 2
79740: PPUSH
79741: CALL_OW 1
79745: ST_TO_ADDR
// end ;
79746: LD_VAR 0 3
79750: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
79751: LD_INT 0
79753: PPUSH
// if not mc_bases or not base or not tech_list then
79754: LD_EXP 60
79758: NOT
79759: PUSH
79760: LD_VAR 0 1
79764: NOT
79765: OR
79766: PUSH
79767: LD_VAR 0 2
79771: NOT
79772: OR
79773: IFFALSE 79777
// exit ;
79775: GO 79802
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
79777: LD_ADDR_EXP 87
79781: PUSH
79782: LD_EXP 87
79786: PPUSH
79787: LD_VAR 0 1
79791: PPUSH
79792: LD_VAR 0 2
79796: PPUSH
79797: CALL_OW 1
79801: ST_TO_ADDR
// end ;
79802: LD_VAR 0 3
79806: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
79807: LD_INT 0
79809: PPUSH
// if not mc_bases or not parking_area or not base then
79810: LD_EXP 60
79814: NOT
79815: PUSH
79816: LD_VAR 0 2
79820: NOT
79821: OR
79822: PUSH
79823: LD_VAR 0 1
79827: NOT
79828: OR
79829: IFFALSE 79833
// exit ;
79831: GO 79858
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
79833: LD_ADDR_EXP 84
79837: PUSH
79838: LD_EXP 84
79842: PPUSH
79843: LD_VAR 0 1
79847: PPUSH
79848: LD_VAR 0 2
79852: PPUSH
79853: CALL_OW 1
79857: ST_TO_ADDR
// end ;
79858: LD_VAR 0 3
79862: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
79863: LD_INT 0
79865: PPUSH
// if not mc_bases or not base or not scan_area then
79866: LD_EXP 60
79870: NOT
79871: PUSH
79872: LD_VAR 0 1
79876: NOT
79877: OR
79878: PUSH
79879: LD_VAR 0 2
79883: NOT
79884: OR
79885: IFFALSE 79889
// exit ;
79887: GO 79914
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
79889: LD_ADDR_EXP 85
79893: PUSH
79894: LD_EXP 85
79898: PPUSH
79899: LD_VAR 0 1
79903: PPUSH
79904: LD_VAR 0 2
79908: PPUSH
79909: CALL_OW 1
79913: ST_TO_ADDR
// end ;
79914: LD_VAR 0 3
79918: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
79919: LD_INT 0
79921: PPUSH
79922: PPUSH
// if not mc_bases or not base then
79923: LD_EXP 60
79927: NOT
79928: PUSH
79929: LD_VAR 0 1
79933: NOT
79934: OR
79935: IFFALSE 79939
// exit ;
79937: GO 80003
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
79939: LD_ADDR_VAR 0 3
79943: PUSH
79944: LD_INT 1
79946: PUSH
79947: LD_INT 2
79949: PUSH
79950: LD_INT 3
79952: PUSH
79953: LD_INT 4
79955: PUSH
79956: LD_INT 11
79958: PUSH
79959: EMPTY
79960: LIST
79961: LIST
79962: LIST
79963: LIST
79964: LIST
79965: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
79966: LD_ADDR_EXP 87
79970: PUSH
79971: LD_EXP 87
79975: PPUSH
79976: LD_VAR 0 1
79980: PPUSH
79981: LD_EXP 87
79985: PUSH
79986: LD_VAR 0 1
79990: ARRAY
79991: PUSH
79992: LD_VAR 0 3
79996: DIFF
79997: PPUSH
79998: CALL_OW 1
80002: ST_TO_ADDR
// end ;
80003: LD_VAR 0 2
80007: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80008: LD_INT 0
80010: PPUSH
// result := mc_vehicles [ base ] ;
80011: LD_ADDR_VAR 0 3
80015: PUSH
80016: LD_EXP 79
80020: PUSH
80021: LD_VAR 0 1
80025: ARRAY
80026: ST_TO_ADDR
// if onlyCombat then
80027: LD_VAR 0 2
80031: IFFALSE 80209
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80033: LD_ADDR_VAR 0 3
80037: PUSH
80038: LD_VAR 0 3
80042: PUSH
80043: LD_VAR 0 3
80047: PPUSH
80048: LD_INT 2
80050: PUSH
80051: LD_INT 34
80053: PUSH
80054: LD_INT 12
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 34
80063: PUSH
80064: LD_INT 51
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PUSH
80071: LD_INT 34
80073: PUSH
80074: LD_EXP 105
80078: PUSH
80079: EMPTY
80080: LIST
80081: LIST
80082: PUSH
80083: LD_INT 34
80085: PUSH
80086: LD_INT 32
80088: PUSH
80089: EMPTY
80090: LIST
80091: LIST
80092: PUSH
80093: LD_INT 34
80095: PUSH
80096: LD_INT 13
80098: PUSH
80099: EMPTY
80100: LIST
80101: LIST
80102: PUSH
80103: LD_INT 34
80105: PUSH
80106: LD_INT 52
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_INT 34
80115: PUSH
80116: LD_EXP 110
80120: PUSH
80121: EMPTY
80122: LIST
80123: LIST
80124: PUSH
80125: LD_INT 34
80127: PUSH
80128: LD_INT 14
80130: PUSH
80131: EMPTY
80132: LIST
80133: LIST
80134: PUSH
80135: LD_INT 34
80137: PUSH
80138: LD_INT 53
80140: PUSH
80141: EMPTY
80142: LIST
80143: LIST
80144: PUSH
80145: LD_INT 34
80147: PUSH
80148: LD_EXP 104
80152: PUSH
80153: EMPTY
80154: LIST
80155: LIST
80156: PUSH
80157: LD_INT 34
80159: PUSH
80160: LD_INT 31
80162: PUSH
80163: EMPTY
80164: LIST
80165: LIST
80166: PUSH
80167: LD_INT 34
80169: PUSH
80170: LD_INT 48
80172: PUSH
80173: EMPTY
80174: LIST
80175: LIST
80176: PUSH
80177: LD_INT 34
80179: PUSH
80180: LD_INT 8
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: PUSH
80187: EMPTY
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: LIST
80195: LIST
80196: LIST
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: LIST
80202: PPUSH
80203: CALL_OW 72
80207: DIFF
80208: ST_TO_ADDR
// end ; end_of_file
80209: LD_VAR 0 3
80213: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80214: LD_INT 0
80216: PPUSH
80217: PPUSH
80218: PPUSH
// if not mc_bases or not skirmish then
80219: LD_EXP 60
80223: NOT
80224: PUSH
80225: LD_EXP 58
80229: NOT
80230: OR
80231: IFFALSE 80235
// exit ;
80233: GO 80400
// for i = 1 to mc_bases do
80235: LD_ADDR_VAR 0 4
80239: PUSH
80240: DOUBLE
80241: LD_INT 1
80243: DEC
80244: ST_TO_ADDR
80245: LD_EXP 60
80249: PUSH
80250: FOR_TO
80251: IFFALSE 80398
// begin if sci in mc_bases [ i ] then
80253: LD_VAR 0 2
80257: PUSH
80258: LD_EXP 60
80262: PUSH
80263: LD_VAR 0 4
80267: ARRAY
80268: IN
80269: IFFALSE 80396
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80271: LD_ADDR_EXP 89
80275: PUSH
80276: LD_EXP 89
80280: PPUSH
80281: LD_VAR 0 4
80285: PUSH
80286: LD_EXP 89
80290: PUSH
80291: LD_VAR 0 4
80295: ARRAY
80296: PUSH
80297: LD_INT 1
80299: PLUS
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PPUSH
80305: LD_VAR 0 1
80309: PPUSH
80310: CALL 19801 0 3
80314: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80315: LD_ADDR_VAR 0 5
80319: PUSH
80320: LD_EXP 60
80324: PUSH
80325: LD_VAR 0 4
80329: ARRAY
80330: PPUSH
80331: LD_INT 2
80333: PUSH
80334: LD_INT 30
80336: PUSH
80337: LD_INT 0
80339: PUSH
80340: EMPTY
80341: LIST
80342: LIST
80343: PUSH
80344: LD_INT 30
80346: PUSH
80347: LD_INT 1
80349: PUSH
80350: EMPTY
80351: LIST
80352: LIST
80353: PUSH
80354: EMPTY
80355: LIST
80356: LIST
80357: LIST
80358: PPUSH
80359: CALL_OW 72
80363: PPUSH
80364: LD_VAR 0 1
80368: PPUSH
80369: CALL_OW 74
80373: ST_TO_ADDR
// if tmp then
80374: LD_VAR 0 5
80378: IFFALSE 80394
// ComStandNearbyBuilding ( ape , tmp ) ;
80380: LD_VAR 0 1
80384: PPUSH
80385: LD_VAR 0 5
80389: PPUSH
80390: CALL 16379 0 2
// break ;
80394: GO 80398
// end ; end ;
80396: GO 80250
80398: POP
80399: POP
// end ;
80400: LD_VAR 0 3
80404: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80405: LD_INT 0
80407: PPUSH
80408: PPUSH
80409: PPUSH
// if not mc_bases or not skirmish then
80410: LD_EXP 60
80414: NOT
80415: PUSH
80416: LD_EXP 58
80420: NOT
80421: OR
80422: IFFALSE 80426
// exit ;
80424: GO 80515
// for i = 1 to mc_bases do
80426: LD_ADDR_VAR 0 4
80430: PUSH
80431: DOUBLE
80432: LD_INT 1
80434: DEC
80435: ST_TO_ADDR
80436: LD_EXP 60
80440: PUSH
80441: FOR_TO
80442: IFFALSE 80513
// begin if building in mc_busy_turret_list [ i ] then
80444: LD_VAR 0 1
80448: PUSH
80449: LD_EXP 70
80453: PUSH
80454: LD_VAR 0 4
80458: ARRAY
80459: IN
80460: IFFALSE 80511
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80462: LD_ADDR_VAR 0 5
80466: PUSH
80467: LD_EXP 70
80471: PUSH
80472: LD_VAR 0 4
80476: ARRAY
80477: PUSH
80478: LD_VAR 0 1
80482: DIFF
80483: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
80484: LD_ADDR_EXP 70
80488: PUSH
80489: LD_EXP 70
80493: PPUSH
80494: LD_VAR 0 4
80498: PPUSH
80499: LD_VAR 0 5
80503: PPUSH
80504: CALL_OW 1
80508: ST_TO_ADDR
// break ;
80509: GO 80513
// end ; end ;
80511: GO 80441
80513: POP
80514: POP
// end ;
80515: LD_VAR 0 3
80519: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
80520: LD_INT 0
80522: PPUSH
80523: PPUSH
80524: PPUSH
// if not mc_bases or not skirmish then
80525: LD_EXP 60
80529: NOT
80530: PUSH
80531: LD_EXP 58
80535: NOT
80536: OR
80537: IFFALSE 80541
// exit ;
80539: GO 80740
// for i = 1 to mc_bases do
80541: LD_ADDR_VAR 0 5
80545: PUSH
80546: DOUBLE
80547: LD_INT 1
80549: DEC
80550: ST_TO_ADDR
80551: LD_EXP 60
80555: PUSH
80556: FOR_TO
80557: IFFALSE 80738
// if building in mc_bases [ i ] then
80559: LD_VAR 0 1
80563: PUSH
80564: LD_EXP 60
80568: PUSH
80569: LD_VAR 0 5
80573: ARRAY
80574: IN
80575: IFFALSE 80736
// begin tmp := mc_bases [ i ] diff building ;
80577: LD_ADDR_VAR 0 6
80581: PUSH
80582: LD_EXP 60
80586: PUSH
80587: LD_VAR 0 5
80591: ARRAY
80592: PUSH
80593: LD_VAR 0 1
80597: DIFF
80598: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
80599: LD_ADDR_EXP 60
80603: PUSH
80604: LD_EXP 60
80608: PPUSH
80609: LD_VAR 0 5
80613: PPUSH
80614: LD_VAR 0 6
80618: PPUSH
80619: CALL_OW 1
80623: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
80624: LD_VAR 0 1
80628: PUSH
80629: LD_EXP 68
80633: PUSH
80634: LD_VAR 0 5
80638: ARRAY
80639: IN
80640: IFFALSE 80679
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
80642: LD_ADDR_EXP 68
80646: PUSH
80647: LD_EXP 68
80651: PPUSH
80652: LD_VAR 0 5
80656: PPUSH
80657: LD_EXP 68
80661: PUSH
80662: LD_VAR 0 5
80666: ARRAY
80667: PUSH
80668: LD_VAR 0 1
80672: DIFF
80673: PPUSH
80674: CALL_OW 1
80678: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
80679: LD_VAR 0 1
80683: PUSH
80684: LD_EXP 69
80688: PUSH
80689: LD_VAR 0 5
80693: ARRAY
80694: IN
80695: IFFALSE 80734
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
80697: LD_ADDR_EXP 69
80701: PUSH
80702: LD_EXP 69
80706: PPUSH
80707: LD_VAR 0 5
80711: PPUSH
80712: LD_EXP 69
80716: PUSH
80717: LD_VAR 0 5
80721: ARRAY
80722: PUSH
80723: LD_VAR 0 1
80727: DIFF
80728: PPUSH
80729: CALL_OW 1
80733: ST_TO_ADDR
// break ;
80734: GO 80738
// end ;
80736: GO 80556
80738: POP
80739: POP
// end ;
80740: LD_VAR 0 4
80744: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
80745: LD_INT 0
80747: PPUSH
80748: PPUSH
80749: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
80750: LD_EXP 60
80754: NOT
80755: PUSH
80756: LD_EXP 58
80760: NOT
80761: OR
80762: PUSH
80763: LD_VAR 0 3
80767: PUSH
80768: LD_EXP 86
80772: IN
80773: NOT
80774: OR
80775: IFFALSE 80779
// exit ;
80777: GO 80902
// for i = 1 to mc_vehicles do
80779: LD_ADDR_VAR 0 6
80783: PUSH
80784: DOUBLE
80785: LD_INT 1
80787: DEC
80788: ST_TO_ADDR
80789: LD_EXP 79
80793: PUSH
80794: FOR_TO
80795: IFFALSE 80900
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
80797: LD_VAR 0 2
80801: PUSH
80802: LD_EXP 79
80806: PUSH
80807: LD_VAR 0 6
80811: ARRAY
80812: IN
80813: PUSH
80814: LD_VAR 0 1
80818: PUSH
80819: LD_EXP 79
80823: PUSH
80824: LD_VAR 0 6
80828: ARRAY
80829: IN
80830: OR
80831: IFFALSE 80898
// begin tmp := mc_vehicles [ i ] diff old ;
80833: LD_ADDR_VAR 0 7
80837: PUSH
80838: LD_EXP 79
80842: PUSH
80843: LD_VAR 0 6
80847: ARRAY
80848: PUSH
80849: LD_VAR 0 2
80853: DIFF
80854: ST_TO_ADDR
// tmp := tmp diff new ;
80855: LD_ADDR_VAR 0 7
80859: PUSH
80860: LD_VAR 0 7
80864: PUSH
80865: LD_VAR 0 1
80869: DIFF
80870: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
80871: LD_ADDR_EXP 79
80875: PUSH
80876: LD_EXP 79
80880: PPUSH
80881: LD_VAR 0 6
80885: PPUSH
80886: LD_VAR 0 7
80890: PPUSH
80891: CALL_OW 1
80895: ST_TO_ADDR
// break ;
80896: GO 80900
// end ;
80898: GO 80794
80900: POP
80901: POP
// end ;
80902: LD_VAR 0 5
80906: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
80907: LD_INT 0
80909: PPUSH
80910: PPUSH
80911: PPUSH
80912: PPUSH
// if not mc_bases or not skirmish then
80913: LD_EXP 60
80917: NOT
80918: PUSH
80919: LD_EXP 58
80923: NOT
80924: OR
80925: IFFALSE 80929
// exit ;
80927: GO 81321
// side := GetSide ( vehicle ) ;
80929: LD_ADDR_VAR 0 5
80933: PUSH
80934: LD_VAR 0 1
80938: PPUSH
80939: CALL_OW 255
80943: ST_TO_ADDR
// for i = 1 to mc_bases do
80944: LD_ADDR_VAR 0 4
80948: PUSH
80949: DOUBLE
80950: LD_INT 1
80952: DEC
80953: ST_TO_ADDR
80954: LD_EXP 60
80958: PUSH
80959: FOR_TO
80960: IFFALSE 81319
// begin if factory in mc_bases [ i ] then
80962: LD_VAR 0 2
80966: PUSH
80967: LD_EXP 60
80971: PUSH
80972: LD_VAR 0 4
80976: ARRAY
80977: IN
80978: IFFALSE 81317
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
80980: LD_EXP 82
80984: PUSH
80985: LD_VAR 0 4
80989: ARRAY
80990: PUSH
80991: LD_EXP 71
80995: PUSH
80996: LD_VAR 0 4
81000: ARRAY
81001: LESS
81002: PUSH
81003: LD_VAR 0 1
81007: PPUSH
81008: CALL_OW 264
81012: PUSH
81013: LD_INT 31
81015: PUSH
81016: LD_INT 32
81018: PUSH
81019: LD_INT 51
81021: PUSH
81022: LD_EXP 105
81026: PUSH
81027: LD_INT 12
81029: PUSH
81030: LD_INT 30
81032: PUSH
81033: LD_EXP 104
81037: PUSH
81038: LD_INT 11
81040: PUSH
81041: LD_INT 53
81043: PUSH
81044: LD_INT 14
81046: PUSH
81047: LD_EXP 108
81051: PUSH
81052: LD_INT 29
81054: PUSH
81055: LD_EXP 106
81059: PUSH
81060: LD_INT 13
81062: PUSH
81063: LD_INT 52
81065: PUSH
81066: LD_EXP 110
81070: PUSH
81071: LD_INT 48
81073: PUSH
81074: LD_INT 8
81076: PUSH
81077: EMPTY
81078: LIST
81079: LIST
81080: LIST
81081: LIST
81082: LIST
81083: LIST
81084: LIST
81085: LIST
81086: LIST
81087: LIST
81088: LIST
81089: LIST
81090: LIST
81091: LIST
81092: LIST
81093: LIST
81094: LIST
81095: LIST
81096: IN
81097: NOT
81098: AND
81099: IFFALSE 81147
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81101: LD_ADDR_EXP 82
81105: PUSH
81106: LD_EXP 82
81110: PPUSH
81111: LD_VAR 0 4
81115: PUSH
81116: LD_EXP 82
81120: PUSH
81121: LD_VAR 0 4
81125: ARRAY
81126: PUSH
81127: LD_INT 1
81129: PLUS
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PPUSH
81135: LD_VAR 0 1
81139: PPUSH
81140: CALL 19801 0 3
81144: ST_TO_ADDR
81145: GO 81191
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81147: LD_ADDR_EXP 79
81151: PUSH
81152: LD_EXP 79
81156: PPUSH
81157: LD_VAR 0 4
81161: PUSH
81162: LD_EXP 79
81166: PUSH
81167: LD_VAR 0 4
81171: ARRAY
81172: PUSH
81173: LD_INT 1
81175: PLUS
81176: PUSH
81177: EMPTY
81178: LIST
81179: LIST
81180: PPUSH
81181: LD_VAR 0 1
81185: PPUSH
81186: CALL 19801 0 3
81190: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81191: LD_VAR 0 1
81195: PPUSH
81196: CALL_OW 263
81200: PUSH
81201: LD_INT 2
81203: EQUAL
81204: IFFALSE 81233
// begin repeat wait ( 0 0$3 ) ;
81206: LD_INT 105
81208: PPUSH
81209: CALL_OW 67
// Connect ( vehicle ) ;
81213: LD_VAR 0 1
81217: PPUSH
81218: CALL 22772 0 1
// until IsControledBy ( vehicle ) ;
81222: LD_VAR 0 1
81226: PPUSH
81227: CALL_OW 312
81231: IFFALSE 81206
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81233: LD_VAR 0 1
81237: PPUSH
81238: LD_EXP 84
81242: PUSH
81243: LD_VAR 0 4
81247: ARRAY
81248: PPUSH
81249: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81253: LD_VAR 0 1
81257: PPUSH
81258: CALL_OW 263
81262: PUSH
81263: LD_INT 1
81265: NONEQUAL
81266: IFFALSE 81270
// break ;
81268: GO 81319
// repeat wait ( 0 0$1 ) ;
81270: LD_INT 35
81272: PPUSH
81273: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81277: LD_VAR 0 1
81281: PPUSH
81282: LD_EXP 84
81286: PUSH
81287: LD_VAR 0 4
81291: ARRAY
81292: PPUSH
81293: CALL_OW 308
81297: IFFALSE 81270
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81299: LD_VAR 0 1
81303: PPUSH
81304: CALL_OW 311
81308: PPUSH
81309: CALL_OW 121
// exit ;
81313: POP
81314: POP
81315: GO 81321
// end ; end ;
81317: GO 80959
81319: POP
81320: POP
// end ;
81321: LD_VAR 0 3
81325: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81326: LD_INT 0
81328: PPUSH
81329: PPUSH
81330: PPUSH
81331: PPUSH
// if not mc_bases or not skirmish then
81332: LD_EXP 60
81336: NOT
81337: PUSH
81338: LD_EXP 58
81342: NOT
81343: OR
81344: IFFALSE 81348
// exit ;
81346: GO 81701
// repeat wait ( 0 0$1 ) ;
81348: LD_INT 35
81350: PPUSH
81351: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81355: LD_VAR 0 2
81359: PPUSH
81360: LD_VAR 0 3
81364: PPUSH
81365: CALL_OW 284
81369: IFFALSE 81348
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81371: LD_VAR 0 2
81375: PPUSH
81376: LD_VAR 0 3
81380: PPUSH
81381: CALL_OW 283
81385: PUSH
81386: LD_INT 4
81388: EQUAL
81389: IFFALSE 81393
// exit ;
81391: GO 81701
// for i = 1 to mc_bases do
81393: LD_ADDR_VAR 0 7
81397: PUSH
81398: DOUBLE
81399: LD_INT 1
81401: DEC
81402: ST_TO_ADDR
81403: LD_EXP 60
81407: PUSH
81408: FOR_TO
81409: IFFALSE 81699
// begin if mc_crates_area [ i ] then
81411: LD_EXP 78
81415: PUSH
81416: LD_VAR 0 7
81420: ARRAY
81421: IFFALSE 81532
// for j in mc_crates_area [ i ] do
81423: LD_ADDR_VAR 0 8
81427: PUSH
81428: LD_EXP 78
81432: PUSH
81433: LD_VAR 0 7
81437: ARRAY
81438: PUSH
81439: FOR_IN
81440: IFFALSE 81530
// if InArea ( x , y , j ) then
81442: LD_VAR 0 2
81446: PPUSH
81447: LD_VAR 0 3
81451: PPUSH
81452: LD_VAR 0 8
81456: PPUSH
81457: CALL_OW 309
81461: IFFALSE 81528
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81463: LD_ADDR_EXP 76
81467: PUSH
81468: LD_EXP 76
81472: PPUSH
81473: LD_VAR 0 7
81477: PUSH
81478: LD_EXP 76
81482: PUSH
81483: LD_VAR 0 7
81487: ARRAY
81488: PUSH
81489: LD_INT 1
81491: PLUS
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PPUSH
81497: LD_VAR 0 4
81501: PUSH
81502: LD_VAR 0 2
81506: PUSH
81507: LD_VAR 0 3
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: PPUSH
81517: CALL 19801 0 3
81521: ST_TO_ADDR
// exit ;
81522: POP
81523: POP
81524: POP
81525: POP
81526: GO 81701
// end ;
81528: GO 81439
81530: POP
81531: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
81532: LD_ADDR_VAR 0 9
81536: PUSH
81537: LD_EXP 60
81541: PUSH
81542: LD_VAR 0 7
81546: ARRAY
81547: PPUSH
81548: LD_INT 2
81550: PUSH
81551: LD_INT 30
81553: PUSH
81554: LD_INT 0
81556: PUSH
81557: EMPTY
81558: LIST
81559: LIST
81560: PUSH
81561: LD_INT 30
81563: PUSH
81564: LD_INT 1
81566: PUSH
81567: EMPTY
81568: LIST
81569: LIST
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: LIST
81575: PPUSH
81576: CALL_OW 72
81580: ST_TO_ADDR
// if not depot then
81581: LD_VAR 0 9
81585: NOT
81586: IFFALSE 81590
// continue ;
81588: GO 81408
// for j in depot do
81590: LD_ADDR_VAR 0 8
81594: PUSH
81595: LD_VAR 0 9
81599: PUSH
81600: FOR_IN
81601: IFFALSE 81695
// if GetDistUnitXY ( j , x , y ) < 30 then
81603: LD_VAR 0 8
81607: PPUSH
81608: LD_VAR 0 2
81612: PPUSH
81613: LD_VAR 0 3
81617: PPUSH
81618: CALL_OW 297
81622: PUSH
81623: LD_INT 30
81625: LESS
81626: IFFALSE 81693
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81628: LD_ADDR_EXP 76
81632: PUSH
81633: LD_EXP 76
81637: PPUSH
81638: LD_VAR 0 7
81642: PUSH
81643: LD_EXP 76
81647: PUSH
81648: LD_VAR 0 7
81652: ARRAY
81653: PUSH
81654: LD_INT 1
81656: PLUS
81657: PUSH
81658: EMPTY
81659: LIST
81660: LIST
81661: PPUSH
81662: LD_VAR 0 4
81666: PUSH
81667: LD_VAR 0 2
81671: PUSH
81672: LD_VAR 0 3
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: LIST
81681: PPUSH
81682: CALL 19801 0 3
81686: ST_TO_ADDR
// exit ;
81687: POP
81688: POP
81689: POP
81690: POP
81691: GO 81701
// end ;
81693: GO 81600
81695: POP
81696: POP
// end ;
81697: GO 81408
81699: POP
81700: POP
// end ;
81701: LD_VAR 0 6
81705: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
81706: LD_INT 0
81708: PPUSH
81709: PPUSH
81710: PPUSH
81711: PPUSH
// if not mc_bases or not skirmish then
81712: LD_EXP 60
81716: NOT
81717: PUSH
81718: LD_EXP 58
81722: NOT
81723: OR
81724: IFFALSE 81728
// exit ;
81726: GO 82005
// side := GetSide ( lab ) ;
81728: LD_ADDR_VAR 0 4
81732: PUSH
81733: LD_VAR 0 2
81737: PPUSH
81738: CALL_OW 255
81742: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
81743: LD_VAR 0 4
81747: PUSH
81748: LD_EXP 86
81752: IN
81753: NOT
81754: PUSH
81755: LD_EXP 87
81759: NOT
81760: OR
81761: PUSH
81762: LD_EXP 60
81766: NOT
81767: OR
81768: IFFALSE 81772
// exit ;
81770: GO 82005
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
81772: LD_ADDR_EXP 87
81776: PUSH
81777: LD_EXP 87
81781: PPUSH
81782: LD_VAR 0 4
81786: PPUSH
81787: LD_EXP 87
81791: PUSH
81792: LD_VAR 0 4
81796: ARRAY
81797: PUSH
81798: LD_VAR 0 1
81802: DIFF
81803: PPUSH
81804: CALL_OW 1
81808: ST_TO_ADDR
// for i = 1 to mc_bases do
81809: LD_ADDR_VAR 0 5
81813: PUSH
81814: DOUBLE
81815: LD_INT 1
81817: DEC
81818: ST_TO_ADDR
81819: LD_EXP 60
81823: PUSH
81824: FOR_TO
81825: IFFALSE 82003
// begin if lab in mc_bases [ i ] then
81827: LD_VAR 0 2
81831: PUSH
81832: LD_EXP 60
81836: PUSH
81837: LD_VAR 0 5
81841: ARRAY
81842: IN
81843: IFFALSE 82001
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
81845: LD_VAR 0 1
81849: PUSH
81850: LD_INT 11
81852: PUSH
81853: LD_INT 4
81855: PUSH
81856: LD_INT 3
81858: PUSH
81859: LD_INT 2
81861: PUSH
81862: EMPTY
81863: LIST
81864: LIST
81865: LIST
81866: LIST
81867: IN
81868: PUSH
81869: LD_EXP 90
81873: PUSH
81874: LD_VAR 0 5
81878: ARRAY
81879: AND
81880: IFFALSE 82001
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
81882: LD_ADDR_VAR 0 6
81886: PUSH
81887: LD_EXP 90
81891: PUSH
81892: LD_VAR 0 5
81896: ARRAY
81897: PUSH
81898: LD_INT 1
81900: ARRAY
81901: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
81902: LD_ADDR_EXP 90
81906: PUSH
81907: LD_EXP 90
81911: PPUSH
81912: LD_VAR 0 5
81916: PPUSH
81917: EMPTY
81918: PPUSH
81919: CALL_OW 1
81923: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
81924: LD_VAR 0 6
81928: PPUSH
81929: LD_INT 0
81931: PPUSH
81932: CALL_OW 109
// ComExitBuilding ( tmp ) ;
81936: LD_VAR 0 6
81940: PPUSH
81941: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
81945: LD_ADDR_EXP 89
81949: PUSH
81950: LD_EXP 89
81954: PPUSH
81955: LD_VAR 0 5
81959: PPUSH
81960: LD_EXP 89
81964: PUSH
81965: LD_VAR 0 5
81969: ARRAY
81970: PPUSH
81971: LD_INT 1
81973: PPUSH
81974: LD_VAR 0 6
81978: PPUSH
81979: CALL_OW 2
81983: PPUSH
81984: CALL_OW 1
81988: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
81989: LD_VAR 0 5
81993: PPUSH
81994: LD_INT 112
81996: PPUSH
81997: CALL 58524 0 2
// end ; end ; end ;
82001: GO 81824
82003: POP
82004: POP
// end ;
82005: LD_VAR 0 3
82009: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82010: LD_INT 0
82012: PPUSH
82013: PPUSH
82014: PPUSH
82015: PPUSH
82016: PPUSH
82017: PPUSH
82018: PPUSH
82019: PPUSH
// if not mc_bases or not skirmish then
82020: LD_EXP 60
82024: NOT
82025: PUSH
82026: LD_EXP 58
82030: NOT
82031: OR
82032: IFFALSE 82036
// exit ;
82034: GO 83407
// for i = 1 to mc_bases do
82036: LD_ADDR_VAR 0 3
82040: PUSH
82041: DOUBLE
82042: LD_INT 1
82044: DEC
82045: ST_TO_ADDR
82046: LD_EXP 60
82050: PUSH
82051: FOR_TO
82052: IFFALSE 83405
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82054: LD_VAR 0 1
82058: PUSH
82059: LD_EXP 60
82063: PUSH
82064: LD_VAR 0 3
82068: ARRAY
82069: IN
82070: PUSH
82071: LD_VAR 0 1
82075: PUSH
82076: LD_EXP 67
82080: PUSH
82081: LD_VAR 0 3
82085: ARRAY
82086: IN
82087: OR
82088: PUSH
82089: LD_VAR 0 1
82093: PUSH
82094: LD_EXP 82
82098: PUSH
82099: LD_VAR 0 3
82103: ARRAY
82104: IN
82105: OR
82106: PUSH
82107: LD_VAR 0 1
82111: PUSH
82112: LD_EXP 79
82116: PUSH
82117: LD_VAR 0 3
82121: ARRAY
82122: IN
82123: OR
82124: PUSH
82125: LD_VAR 0 1
82129: PUSH
82130: LD_EXP 89
82134: PUSH
82135: LD_VAR 0 3
82139: ARRAY
82140: IN
82141: OR
82142: PUSH
82143: LD_VAR 0 1
82147: PUSH
82148: LD_EXP 90
82152: PUSH
82153: LD_VAR 0 3
82157: ARRAY
82158: IN
82159: OR
82160: IFFALSE 83403
// begin if un in mc_ape [ i ] then
82162: LD_VAR 0 1
82166: PUSH
82167: LD_EXP 89
82171: PUSH
82172: LD_VAR 0 3
82176: ARRAY
82177: IN
82178: IFFALSE 82217
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82180: LD_ADDR_EXP 89
82184: PUSH
82185: LD_EXP 89
82189: PPUSH
82190: LD_VAR 0 3
82194: PPUSH
82195: LD_EXP 89
82199: PUSH
82200: LD_VAR 0 3
82204: ARRAY
82205: PUSH
82206: LD_VAR 0 1
82210: DIFF
82211: PPUSH
82212: CALL_OW 1
82216: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82217: LD_VAR 0 1
82221: PUSH
82222: LD_EXP 90
82226: PUSH
82227: LD_VAR 0 3
82231: ARRAY
82232: IN
82233: IFFALSE 82257
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82235: LD_ADDR_EXP 90
82239: PUSH
82240: LD_EXP 90
82244: PPUSH
82245: LD_VAR 0 3
82249: PPUSH
82250: EMPTY
82251: PPUSH
82252: CALL_OW 1
82256: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82257: LD_VAR 0 1
82261: PPUSH
82262: CALL_OW 247
82266: PUSH
82267: LD_INT 2
82269: EQUAL
82270: PUSH
82271: LD_VAR 0 1
82275: PPUSH
82276: CALL_OW 110
82280: PUSH
82281: LD_INT 20
82283: EQUAL
82284: PUSH
82285: LD_VAR 0 1
82289: PUSH
82290: LD_EXP 82
82294: PUSH
82295: LD_VAR 0 3
82299: ARRAY
82300: IN
82301: OR
82302: PUSH
82303: LD_VAR 0 1
82307: PPUSH
82308: CALL_OW 264
82312: PUSH
82313: LD_INT 12
82315: PUSH
82316: LD_INT 51
82318: PUSH
82319: LD_EXP 105
82323: PUSH
82324: LD_INT 32
82326: PUSH
82327: LD_INT 13
82329: PUSH
82330: LD_INT 52
82332: PUSH
82333: LD_INT 31
82335: PUSH
82336: EMPTY
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: LIST
82344: IN
82345: OR
82346: AND
82347: IFFALSE 82655
// begin if un in mc_defender [ i ] then
82349: LD_VAR 0 1
82353: PUSH
82354: LD_EXP 82
82358: PUSH
82359: LD_VAR 0 3
82363: ARRAY
82364: IN
82365: IFFALSE 82404
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82367: LD_ADDR_EXP 82
82371: PUSH
82372: LD_EXP 82
82376: PPUSH
82377: LD_VAR 0 3
82381: PPUSH
82382: LD_EXP 82
82386: PUSH
82387: LD_VAR 0 3
82391: ARRAY
82392: PUSH
82393: LD_VAR 0 1
82397: DIFF
82398: PPUSH
82399: CALL_OW 1
82403: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
82404: LD_ADDR_VAR 0 8
82408: PUSH
82409: LD_VAR 0 3
82413: PPUSH
82414: LD_INT 3
82416: PPUSH
82417: CALL 79045 0 2
82421: ST_TO_ADDR
// if fac then
82422: LD_VAR 0 8
82426: IFFALSE 82655
// begin for j in fac do
82428: LD_ADDR_VAR 0 4
82432: PUSH
82433: LD_VAR 0 8
82437: PUSH
82438: FOR_IN
82439: IFFALSE 82653
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82441: LD_ADDR_VAR 0 9
82445: PUSH
82446: LD_VAR 0 8
82450: PPUSH
82451: LD_VAR 0 1
82455: PPUSH
82456: CALL_OW 265
82460: PPUSH
82461: LD_VAR 0 1
82465: PPUSH
82466: CALL_OW 262
82470: PPUSH
82471: LD_VAR 0 1
82475: PPUSH
82476: CALL_OW 263
82480: PPUSH
82481: LD_VAR 0 1
82485: PPUSH
82486: CALL_OW 264
82490: PPUSH
82491: CALL 17297 0 5
82495: ST_TO_ADDR
// if components then
82496: LD_VAR 0 9
82500: IFFALSE 82651
// begin if GetWeapon ( un ) = ar_control_tower then
82502: LD_VAR 0 1
82506: PPUSH
82507: CALL_OW 264
82511: PUSH
82512: LD_INT 31
82514: EQUAL
82515: IFFALSE 82632
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
82517: LD_VAR 0 1
82521: PPUSH
82522: CALL_OW 311
82526: PPUSH
82527: LD_INT 0
82529: PPUSH
82530: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
82534: LD_ADDR_EXP 100
82538: PUSH
82539: LD_EXP 100
82543: PPUSH
82544: LD_VAR 0 3
82548: PPUSH
82549: LD_EXP 100
82553: PUSH
82554: LD_VAR 0 3
82558: ARRAY
82559: PUSH
82560: LD_VAR 0 1
82564: PPUSH
82565: CALL_OW 311
82569: DIFF
82570: PPUSH
82571: CALL_OW 1
82575: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
82576: LD_ADDR_VAR 0 7
82580: PUSH
82581: LD_EXP 81
82585: PUSH
82586: LD_VAR 0 3
82590: ARRAY
82591: PPUSH
82592: LD_INT 1
82594: PPUSH
82595: LD_VAR 0 9
82599: PPUSH
82600: CALL_OW 2
82604: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
82605: LD_ADDR_EXP 81
82609: PUSH
82610: LD_EXP 81
82614: PPUSH
82615: LD_VAR 0 3
82619: PPUSH
82620: LD_VAR 0 7
82624: PPUSH
82625: CALL_OW 1
82629: ST_TO_ADDR
// end else
82630: GO 82649
// MC_InsertProduceList ( i , [ components ] ) ;
82632: LD_VAR 0 3
82636: PPUSH
82637: LD_VAR 0 9
82641: PUSH
82642: EMPTY
82643: LIST
82644: PPUSH
82645: CALL 78590 0 2
// break ;
82649: GO 82653
// end ; end ;
82651: GO 82438
82653: POP
82654: POP
// end ; end ; if GetType ( un ) = unit_building then
82655: LD_VAR 0 1
82659: PPUSH
82660: CALL_OW 247
82664: PUSH
82665: LD_INT 3
82667: EQUAL
82668: IFFALSE 83071
// begin btype := GetBType ( un ) ;
82670: LD_ADDR_VAR 0 5
82674: PUSH
82675: LD_VAR 0 1
82679: PPUSH
82680: CALL_OW 266
82684: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
82685: LD_VAR 0 5
82689: PUSH
82690: LD_INT 29
82692: PUSH
82693: LD_INT 30
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: IN
82700: IFFALSE 82773
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
82702: LD_VAR 0 1
82706: PPUSH
82707: CALL_OW 250
82711: PPUSH
82712: LD_VAR 0 1
82716: PPUSH
82717: CALL_OW 251
82721: PPUSH
82722: LD_VAR 0 1
82726: PPUSH
82727: CALL_OW 255
82731: PPUSH
82732: CALL_OW 440
82736: NOT
82737: IFFALSE 82773
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
82739: LD_VAR 0 1
82743: PPUSH
82744: CALL_OW 250
82748: PPUSH
82749: LD_VAR 0 1
82753: PPUSH
82754: CALL_OW 251
82758: PPUSH
82759: LD_VAR 0 1
82763: PPUSH
82764: CALL_OW 255
82768: PPUSH
82769: CALL_OW 441
// end ; if btype = b_warehouse then
82773: LD_VAR 0 5
82777: PUSH
82778: LD_INT 1
82780: EQUAL
82781: IFFALSE 82799
// begin btype := b_depot ;
82783: LD_ADDR_VAR 0 5
82787: PUSH
82788: LD_INT 0
82790: ST_TO_ADDR
// pos := 1 ;
82791: LD_ADDR_VAR 0 6
82795: PUSH
82796: LD_INT 1
82798: ST_TO_ADDR
// end ; if btype = b_factory then
82799: LD_VAR 0 5
82803: PUSH
82804: LD_INT 3
82806: EQUAL
82807: IFFALSE 82825
// begin btype := b_workshop ;
82809: LD_ADDR_VAR 0 5
82813: PUSH
82814: LD_INT 2
82816: ST_TO_ADDR
// pos := 1 ;
82817: LD_ADDR_VAR 0 6
82821: PUSH
82822: LD_INT 1
82824: ST_TO_ADDR
// end ; if btype = b_barracks then
82825: LD_VAR 0 5
82829: PUSH
82830: LD_INT 5
82832: EQUAL
82833: IFFALSE 82843
// btype := b_armoury ;
82835: LD_ADDR_VAR 0 5
82839: PUSH
82840: LD_INT 4
82842: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
82843: LD_VAR 0 5
82847: PUSH
82848: LD_INT 7
82850: PUSH
82851: LD_INT 8
82853: PUSH
82854: EMPTY
82855: LIST
82856: LIST
82857: IN
82858: IFFALSE 82868
// btype := b_lab ;
82860: LD_ADDR_VAR 0 5
82864: PUSH
82865: LD_INT 6
82867: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
82868: LD_ADDR_EXP 65
82872: PUSH
82873: LD_EXP 65
82877: PPUSH
82878: LD_VAR 0 3
82882: PUSH
82883: LD_EXP 65
82887: PUSH
82888: LD_VAR 0 3
82892: ARRAY
82893: PUSH
82894: LD_INT 1
82896: PLUS
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PPUSH
82902: LD_VAR 0 5
82906: PUSH
82907: LD_VAR 0 1
82911: PPUSH
82912: CALL_OW 250
82916: PUSH
82917: LD_VAR 0 1
82921: PPUSH
82922: CALL_OW 251
82926: PUSH
82927: LD_VAR 0 1
82931: PPUSH
82932: CALL_OW 254
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: LIST
82941: LIST
82942: PPUSH
82943: CALL 19801 0 3
82947: ST_TO_ADDR
// if pos = 1 then
82948: LD_VAR 0 6
82952: PUSH
82953: LD_INT 1
82955: EQUAL
82956: IFFALSE 83071
// begin tmp := mc_build_list [ i ] ;
82958: LD_ADDR_VAR 0 7
82962: PUSH
82963: LD_EXP 65
82967: PUSH
82968: LD_VAR 0 3
82972: ARRAY
82973: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
82974: LD_VAR 0 7
82978: PPUSH
82979: LD_INT 2
82981: PUSH
82982: LD_INT 30
82984: PUSH
82985: LD_INT 0
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 30
82994: PUSH
82995: LD_INT 1
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: LIST
83006: PPUSH
83007: CALL_OW 72
83011: IFFALSE 83021
// pos := 2 ;
83013: LD_ADDR_VAR 0 6
83017: PUSH
83018: LD_INT 2
83020: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83021: LD_ADDR_VAR 0 7
83025: PUSH
83026: LD_VAR 0 7
83030: PPUSH
83031: LD_VAR 0 6
83035: PPUSH
83036: LD_VAR 0 7
83040: PPUSH
83041: CALL 20127 0 3
83045: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83046: LD_ADDR_EXP 65
83050: PUSH
83051: LD_EXP 65
83055: PPUSH
83056: LD_VAR 0 3
83060: PPUSH
83061: LD_VAR 0 7
83065: PPUSH
83066: CALL_OW 1
83070: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83071: LD_VAR 0 1
83075: PUSH
83076: LD_EXP 60
83080: PUSH
83081: LD_VAR 0 3
83085: ARRAY
83086: IN
83087: IFFALSE 83126
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83089: LD_ADDR_EXP 60
83093: PUSH
83094: LD_EXP 60
83098: PPUSH
83099: LD_VAR 0 3
83103: PPUSH
83104: LD_EXP 60
83108: PUSH
83109: LD_VAR 0 3
83113: ARRAY
83114: PUSH
83115: LD_VAR 0 1
83119: DIFF
83120: PPUSH
83121: CALL_OW 1
83125: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83126: LD_VAR 0 1
83130: PUSH
83131: LD_EXP 67
83135: PUSH
83136: LD_VAR 0 3
83140: ARRAY
83141: IN
83142: IFFALSE 83181
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83144: LD_ADDR_EXP 67
83148: PUSH
83149: LD_EXP 67
83153: PPUSH
83154: LD_VAR 0 3
83158: PPUSH
83159: LD_EXP 67
83163: PUSH
83164: LD_VAR 0 3
83168: ARRAY
83169: PUSH
83170: LD_VAR 0 1
83174: DIFF
83175: PPUSH
83176: CALL_OW 1
83180: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83181: LD_VAR 0 1
83185: PUSH
83186: LD_EXP 79
83190: PUSH
83191: LD_VAR 0 3
83195: ARRAY
83196: IN
83197: IFFALSE 83236
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83199: LD_ADDR_EXP 79
83203: PUSH
83204: LD_EXP 79
83208: PPUSH
83209: LD_VAR 0 3
83213: PPUSH
83214: LD_EXP 79
83218: PUSH
83219: LD_VAR 0 3
83223: ARRAY
83224: PUSH
83225: LD_VAR 0 1
83229: DIFF
83230: PPUSH
83231: CALL_OW 1
83235: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83236: LD_VAR 0 1
83240: PUSH
83241: LD_EXP 82
83245: PUSH
83246: LD_VAR 0 3
83250: ARRAY
83251: IN
83252: IFFALSE 83291
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83254: LD_ADDR_EXP 82
83258: PUSH
83259: LD_EXP 82
83263: PPUSH
83264: LD_VAR 0 3
83268: PPUSH
83269: LD_EXP 82
83273: PUSH
83274: LD_VAR 0 3
83278: ARRAY
83279: PUSH
83280: LD_VAR 0 1
83284: DIFF
83285: PPUSH
83286: CALL_OW 1
83290: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83291: LD_VAR 0 1
83295: PUSH
83296: LD_EXP 69
83300: PUSH
83301: LD_VAR 0 3
83305: ARRAY
83306: IN
83307: IFFALSE 83346
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83309: LD_ADDR_EXP 69
83313: PUSH
83314: LD_EXP 69
83318: PPUSH
83319: LD_VAR 0 3
83323: PPUSH
83324: LD_EXP 69
83328: PUSH
83329: LD_VAR 0 3
83333: ARRAY
83334: PUSH
83335: LD_VAR 0 1
83339: DIFF
83340: PPUSH
83341: CALL_OW 1
83345: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83346: LD_VAR 0 1
83350: PUSH
83351: LD_EXP 68
83355: PUSH
83356: LD_VAR 0 3
83360: ARRAY
83361: IN
83362: IFFALSE 83401
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83364: LD_ADDR_EXP 68
83368: PUSH
83369: LD_EXP 68
83373: PPUSH
83374: LD_VAR 0 3
83378: PPUSH
83379: LD_EXP 68
83383: PUSH
83384: LD_VAR 0 3
83388: ARRAY
83389: PUSH
83390: LD_VAR 0 1
83394: DIFF
83395: PPUSH
83396: CALL_OW 1
83400: ST_TO_ADDR
// end ; break ;
83401: GO 83405
// end ;
83403: GO 82051
83405: POP
83406: POP
// end ;
83407: LD_VAR 0 2
83411: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83412: LD_INT 0
83414: PPUSH
83415: PPUSH
83416: PPUSH
// if not mc_bases or not skirmish then
83417: LD_EXP 60
83421: NOT
83422: PUSH
83423: LD_EXP 58
83427: NOT
83428: OR
83429: IFFALSE 83433
// exit ;
83431: GO 83648
// for i = 1 to mc_bases do
83433: LD_ADDR_VAR 0 3
83437: PUSH
83438: DOUBLE
83439: LD_INT 1
83441: DEC
83442: ST_TO_ADDR
83443: LD_EXP 60
83447: PUSH
83448: FOR_TO
83449: IFFALSE 83646
// begin if building in mc_construct_list [ i ] then
83451: LD_VAR 0 1
83455: PUSH
83456: LD_EXP 67
83460: PUSH
83461: LD_VAR 0 3
83465: ARRAY
83466: IN
83467: IFFALSE 83644
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83469: LD_ADDR_EXP 67
83473: PUSH
83474: LD_EXP 67
83478: PPUSH
83479: LD_VAR 0 3
83483: PPUSH
83484: LD_EXP 67
83488: PUSH
83489: LD_VAR 0 3
83493: ARRAY
83494: PUSH
83495: LD_VAR 0 1
83499: DIFF
83500: PPUSH
83501: CALL_OW 1
83505: ST_TO_ADDR
// if building in mc_lab [ i ] then
83506: LD_VAR 0 1
83510: PUSH
83511: LD_EXP 93
83515: PUSH
83516: LD_VAR 0 3
83520: ARRAY
83521: IN
83522: IFFALSE 83577
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
83524: LD_ADDR_EXP 94
83528: PUSH
83529: LD_EXP 94
83533: PPUSH
83534: LD_VAR 0 3
83538: PPUSH
83539: LD_EXP 94
83543: PUSH
83544: LD_VAR 0 3
83548: ARRAY
83549: PPUSH
83550: LD_INT 1
83552: PPUSH
83553: LD_EXP 94
83557: PUSH
83558: LD_VAR 0 3
83562: ARRAY
83563: PPUSH
83564: LD_INT 0
83566: PPUSH
83567: CALL 19219 0 4
83571: PPUSH
83572: CALL_OW 1
83576: ST_TO_ADDR
// if not building in mc_bases [ i ] then
83577: LD_VAR 0 1
83581: PUSH
83582: LD_EXP 60
83586: PUSH
83587: LD_VAR 0 3
83591: ARRAY
83592: IN
83593: NOT
83594: IFFALSE 83640
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83596: LD_ADDR_EXP 60
83600: PUSH
83601: LD_EXP 60
83605: PPUSH
83606: LD_VAR 0 3
83610: PUSH
83611: LD_EXP 60
83615: PUSH
83616: LD_VAR 0 3
83620: ARRAY
83621: PUSH
83622: LD_INT 1
83624: PLUS
83625: PUSH
83626: EMPTY
83627: LIST
83628: LIST
83629: PPUSH
83630: LD_VAR 0 1
83634: PPUSH
83635: CALL 19801 0 3
83639: ST_TO_ADDR
// exit ;
83640: POP
83641: POP
83642: GO 83648
// end ; end ;
83644: GO 83448
83646: POP
83647: POP
// end ;
83648: LD_VAR 0 2
83652: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
83653: LD_INT 0
83655: PPUSH
83656: PPUSH
83657: PPUSH
83658: PPUSH
83659: PPUSH
83660: PPUSH
83661: PPUSH
// if not mc_bases or not skirmish then
83662: LD_EXP 60
83666: NOT
83667: PUSH
83668: LD_EXP 58
83672: NOT
83673: OR
83674: IFFALSE 83678
// exit ;
83676: GO 84339
// for i = 1 to mc_bases do
83678: LD_ADDR_VAR 0 3
83682: PUSH
83683: DOUBLE
83684: LD_INT 1
83686: DEC
83687: ST_TO_ADDR
83688: LD_EXP 60
83692: PUSH
83693: FOR_TO
83694: IFFALSE 84337
// begin if building in mc_construct_list [ i ] then
83696: LD_VAR 0 1
83700: PUSH
83701: LD_EXP 67
83705: PUSH
83706: LD_VAR 0 3
83710: ARRAY
83711: IN
83712: IFFALSE 84335
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
83714: LD_ADDR_EXP 67
83718: PUSH
83719: LD_EXP 67
83723: PPUSH
83724: LD_VAR 0 3
83728: PPUSH
83729: LD_EXP 67
83733: PUSH
83734: LD_VAR 0 3
83738: ARRAY
83739: PUSH
83740: LD_VAR 0 1
83744: DIFF
83745: PPUSH
83746: CALL_OW 1
83750: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
83751: LD_ADDR_EXP 60
83755: PUSH
83756: LD_EXP 60
83760: PPUSH
83761: LD_VAR 0 3
83765: PUSH
83766: LD_EXP 60
83770: PUSH
83771: LD_VAR 0 3
83775: ARRAY
83776: PUSH
83777: LD_INT 1
83779: PLUS
83780: PUSH
83781: EMPTY
83782: LIST
83783: LIST
83784: PPUSH
83785: LD_VAR 0 1
83789: PPUSH
83790: CALL 19801 0 3
83794: ST_TO_ADDR
// btype := GetBType ( building ) ;
83795: LD_ADDR_VAR 0 5
83799: PUSH
83800: LD_VAR 0 1
83804: PPUSH
83805: CALL_OW 266
83809: ST_TO_ADDR
// side := GetSide ( building ) ;
83810: LD_ADDR_VAR 0 8
83814: PUSH
83815: LD_VAR 0 1
83819: PPUSH
83820: CALL_OW 255
83824: ST_TO_ADDR
// if btype = b_lab then
83825: LD_VAR 0 5
83829: PUSH
83830: LD_INT 6
83832: EQUAL
83833: IFFALSE 83883
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
83835: LD_ADDR_EXP 93
83839: PUSH
83840: LD_EXP 93
83844: PPUSH
83845: LD_VAR 0 3
83849: PUSH
83850: LD_EXP 93
83854: PUSH
83855: LD_VAR 0 3
83859: ARRAY
83860: PUSH
83861: LD_INT 1
83863: PLUS
83864: PUSH
83865: EMPTY
83866: LIST
83867: LIST
83868: PPUSH
83869: LD_VAR 0 1
83873: PPUSH
83874: CALL 19801 0 3
83878: ST_TO_ADDR
// exit ;
83879: POP
83880: POP
83881: GO 84339
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
83883: LD_VAR 0 5
83887: PUSH
83888: LD_INT 0
83890: PUSH
83891: LD_INT 2
83893: PUSH
83894: LD_INT 4
83896: PUSH
83897: EMPTY
83898: LIST
83899: LIST
83900: LIST
83901: IN
83902: IFFALSE 84026
// begin if btype = b_armoury then
83904: LD_VAR 0 5
83908: PUSH
83909: LD_INT 4
83911: EQUAL
83912: IFFALSE 83922
// btype := b_barracks ;
83914: LD_ADDR_VAR 0 5
83918: PUSH
83919: LD_INT 5
83921: ST_TO_ADDR
// if btype = b_depot then
83922: LD_VAR 0 5
83926: PUSH
83927: LD_INT 0
83929: EQUAL
83930: IFFALSE 83940
// btype := b_warehouse ;
83932: LD_ADDR_VAR 0 5
83936: PUSH
83937: LD_INT 1
83939: ST_TO_ADDR
// if btype = b_workshop then
83940: LD_VAR 0 5
83944: PUSH
83945: LD_INT 2
83947: EQUAL
83948: IFFALSE 83958
// btype := b_factory ;
83950: LD_ADDR_VAR 0 5
83954: PUSH
83955: LD_INT 3
83957: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
83958: LD_VAR 0 5
83962: PPUSH
83963: LD_VAR 0 8
83967: PPUSH
83968: CALL_OW 323
83972: PUSH
83973: LD_INT 1
83975: EQUAL
83976: IFFALSE 84022
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
83978: LD_ADDR_EXP 92
83982: PUSH
83983: LD_EXP 92
83987: PPUSH
83988: LD_VAR 0 3
83992: PUSH
83993: LD_EXP 92
83997: PUSH
83998: LD_VAR 0 3
84002: ARRAY
84003: PUSH
84004: LD_INT 1
84006: PLUS
84007: PUSH
84008: EMPTY
84009: LIST
84010: LIST
84011: PPUSH
84012: LD_VAR 0 1
84016: PPUSH
84017: CALL 19801 0 3
84021: ST_TO_ADDR
// exit ;
84022: POP
84023: POP
84024: GO 84339
// end ; if btype in [ b_bunker , b_turret ] then
84026: LD_VAR 0 5
84030: PUSH
84031: LD_INT 32
84033: PUSH
84034: LD_INT 33
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: IN
84041: IFFALSE 84331
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84043: LD_ADDR_EXP 68
84047: PUSH
84048: LD_EXP 68
84052: PPUSH
84053: LD_VAR 0 3
84057: PUSH
84058: LD_EXP 68
84062: PUSH
84063: LD_VAR 0 3
84067: ARRAY
84068: PUSH
84069: LD_INT 1
84071: PLUS
84072: PUSH
84073: EMPTY
84074: LIST
84075: LIST
84076: PPUSH
84077: LD_VAR 0 1
84081: PPUSH
84082: CALL 19801 0 3
84086: ST_TO_ADDR
// if btype = b_bunker then
84087: LD_VAR 0 5
84091: PUSH
84092: LD_INT 32
84094: EQUAL
84095: IFFALSE 84331
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84097: LD_ADDR_EXP 69
84101: PUSH
84102: LD_EXP 69
84106: PPUSH
84107: LD_VAR 0 3
84111: PUSH
84112: LD_EXP 69
84116: PUSH
84117: LD_VAR 0 3
84121: ARRAY
84122: PUSH
84123: LD_INT 1
84125: PLUS
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PPUSH
84131: LD_VAR 0 1
84135: PPUSH
84136: CALL 19801 0 3
84140: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84141: LD_ADDR_VAR 0 6
84145: PUSH
84146: LD_EXP 60
84150: PUSH
84151: LD_VAR 0 3
84155: ARRAY
84156: PPUSH
84157: LD_INT 25
84159: PUSH
84160: LD_INT 1
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 3
84169: PUSH
84170: LD_INT 54
84172: PUSH
84173: EMPTY
84174: LIST
84175: PUSH
84176: EMPTY
84177: LIST
84178: LIST
84179: PUSH
84180: EMPTY
84181: LIST
84182: LIST
84183: PPUSH
84184: CALL_OW 72
84188: ST_TO_ADDR
// if tmp then
84189: LD_VAR 0 6
84193: IFFALSE 84199
// exit ;
84195: POP
84196: POP
84197: GO 84339
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84199: LD_ADDR_VAR 0 6
84203: PUSH
84204: LD_EXP 60
84208: PUSH
84209: LD_VAR 0 3
84213: ARRAY
84214: PPUSH
84215: LD_INT 2
84217: PUSH
84218: LD_INT 30
84220: PUSH
84221: LD_INT 4
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 30
84230: PUSH
84231: LD_INT 5
84233: PUSH
84234: EMPTY
84235: LIST
84236: LIST
84237: PUSH
84238: EMPTY
84239: LIST
84240: LIST
84241: LIST
84242: PPUSH
84243: CALL_OW 72
84247: ST_TO_ADDR
// if not tmp then
84248: LD_VAR 0 6
84252: NOT
84253: IFFALSE 84259
// exit ;
84255: POP
84256: POP
84257: GO 84339
// for j in tmp do
84259: LD_ADDR_VAR 0 4
84263: PUSH
84264: LD_VAR 0 6
84268: PUSH
84269: FOR_IN
84270: IFFALSE 84329
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84272: LD_ADDR_VAR 0 7
84276: PUSH
84277: LD_VAR 0 4
84281: PPUSH
84282: CALL_OW 313
84286: PPUSH
84287: LD_INT 25
84289: PUSH
84290: LD_INT 1
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PPUSH
84297: CALL_OW 72
84301: ST_TO_ADDR
// if units then
84302: LD_VAR 0 7
84306: IFFALSE 84327
// begin ComExitBuilding ( units [ 1 ] ) ;
84308: LD_VAR 0 7
84312: PUSH
84313: LD_INT 1
84315: ARRAY
84316: PPUSH
84317: CALL_OW 122
// exit ;
84321: POP
84322: POP
84323: POP
84324: POP
84325: GO 84339
// end ; end ;
84327: GO 84269
84329: POP
84330: POP
// end ; end ; exit ;
84331: POP
84332: POP
84333: GO 84339
// end ; end ;
84335: GO 83693
84337: POP
84338: POP
// end ;
84339: LD_VAR 0 2
84343: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84344: LD_INT 0
84346: PPUSH
84347: PPUSH
84348: PPUSH
84349: PPUSH
84350: PPUSH
84351: PPUSH
84352: PPUSH
// if not mc_bases or not skirmish then
84353: LD_EXP 60
84357: NOT
84358: PUSH
84359: LD_EXP 58
84363: NOT
84364: OR
84365: IFFALSE 84369
// exit ;
84367: GO 84634
// btype := GetBType ( building ) ;
84369: LD_ADDR_VAR 0 6
84373: PUSH
84374: LD_VAR 0 1
84378: PPUSH
84379: CALL_OW 266
84383: ST_TO_ADDR
// x := GetX ( building ) ;
84384: LD_ADDR_VAR 0 7
84388: PUSH
84389: LD_VAR 0 1
84393: PPUSH
84394: CALL_OW 250
84398: ST_TO_ADDR
// y := GetY ( building ) ;
84399: LD_ADDR_VAR 0 8
84403: PUSH
84404: LD_VAR 0 1
84408: PPUSH
84409: CALL_OW 251
84413: ST_TO_ADDR
// d := GetDir ( building ) ;
84414: LD_ADDR_VAR 0 9
84418: PUSH
84419: LD_VAR 0 1
84423: PPUSH
84424: CALL_OW 254
84428: ST_TO_ADDR
// for i = 1 to mc_bases do
84429: LD_ADDR_VAR 0 4
84433: PUSH
84434: DOUBLE
84435: LD_INT 1
84437: DEC
84438: ST_TO_ADDR
84439: LD_EXP 60
84443: PUSH
84444: FOR_TO
84445: IFFALSE 84632
// begin if not mc_build_list [ i ] then
84447: LD_EXP 65
84451: PUSH
84452: LD_VAR 0 4
84456: ARRAY
84457: NOT
84458: IFFALSE 84462
// continue ;
84460: GO 84444
// for j := 1 to mc_build_list [ i ] do
84462: LD_ADDR_VAR 0 5
84466: PUSH
84467: DOUBLE
84468: LD_INT 1
84470: DEC
84471: ST_TO_ADDR
84472: LD_EXP 65
84476: PUSH
84477: LD_VAR 0 4
84481: ARRAY
84482: PUSH
84483: FOR_TO
84484: IFFALSE 84628
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
84486: LD_VAR 0 6
84490: PUSH
84491: LD_VAR 0 7
84495: PUSH
84496: LD_VAR 0 8
84500: PUSH
84501: LD_VAR 0 9
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: PPUSH
84512: LD_EXP 65
84516: PUSH
84517: LD_VAR 0 4
84521: ARRAY
84522: PUSH
84523: LD_VAR 0 5
84527: ARRAY
84528: PPUSH
84529: CALL 25983 0 2
84533: IFFALSE 84626
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
84535: LD_ADDR_EXP 65
84539: PUSH
84540: LD_EXP 65
84544: PPUSH
84545: LD_VAR 0 4
84549: PPUSH
84550: LD_EXP 65
84554: PUSH
84555: LD_VAR 0 4
84559: ARRAY
84560: PPUSH
84561: LD_VAR 0 5
84565: PPUSH
84566: CALL_OW 3
84570: PPUSH
84571: CALL_OW 1
84575: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
84576: LD_ADDR_EXP 67
84580: PUSH
84581: LD_EXP 67
84585: PPUSH
84586: LD_VAR 0 4
84590: PUSH
84591: LD_EXP 67
84595: PUSH
84596: LD_VAR 0 4
84600: ARRAY
84601: PUSH
84602: LD_INT 1
84604: PLUS
84605: PUSH
84606: EMPTY
84607: LIST
84608: LIST
84609: PPUSH
84610: LD_VAR 0 1
84614: PPUSH
84615: CALL 19801 0 3
84619: ST_TO_ADDR
// exit ;
84620: POP
84621: POP
84622: POP
84623: POP
84624: GO 84634
// end ;
84626: GO 84483
84628: POP
84629: POP
// end ;
84630: GO 84444
84632: POP
84633: POP
// end ;
84634: LD_VAR 0 3
84638: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
84639: LD_INT 0
84641: PPUSH
84642: PPUSH
84643: PPUSH
// if not mc_bases or not skirmish then
84644: LD_EXP 60
84648: NOT
84649: PUSH
84650: LD_EXP 58
84654: NOT
84655: OR
84656: IFFALSE 84660
// exit ;
84658: GO 84850
// for i = 1 to mc_bases do
84660: LD_ADDR_VAR 0 4
84664: PUSH
84665: DOUBLE
84666: LD_INT 1
84668: DEC
84669: ST_TO_ADDR
84670: LD_EXP 60
84674: PUSH
84675: FOR_TO
84676: IFFALSE 84763
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
84678: LD_VAR 0 1
84682: PUSH
84683: LD_EXP 68
84687: PUSH
84688: LD_VAR 0 4
84692: ARRAY
84693: IN
84694: PUSH
84695: LD_VAR 0 1
84699: PUSH
84700: LD_EXP 69
84704: PUSH
84705: LD_VAR 0 4
84709: ARRAY
84710: IN
84711: NOT
84712: AND
84713: IFFALSE 84761
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84715: LD_ADDR_EXP 69
84719: PUSH
84720: LD_EXP 69
84724: PPUSH
84725: LD_VAR 0 4
84729: PUSH
84730: LD_EXP 69
84734: PUSH
84735: LD_VAR 0 4
84739: ARRAY
84740: PUSH
84741: LD_INT 1
84743: PLUS
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PPUSH
84749: LD_VAR 0 1
84753: PPUSH
84754: CALL 19801 0 3
84758: ST_TO_ADDR
// break ;
84759: GO 84763
// end ; end ;
84761: GO 84675
84763: POP
84764: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
84765: LD_VAR 0 1
84769: PPUSH
84770: CALL_OW 257
84774: PUSH
84775: LD_EXP 86
84779: IN
84780: PUSH
84781: LD_VAR 0 1
84785: PPUSH
84786: CALL_OW 266
84790: PUSH
84791: LD_INT 5
84793: EQUAL
84794: AND
84795: PUSH
84796: LD_VAR 0 2
84800: PPUSH
84801: CALL_OW 110
84805: PUSH
84806: LD_INT 18
84808: NONEQUAL
84809: AND
84810: IFFALSE 84850
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
84812: LD_VAR 0 2
84816: PPUSH
84817: CALL_OW 257
84821: PUSH
84822: LD_INT 5
84824: PUSH
84825: LD_INT 8
84827: PUSH
84828: LD_INT 9
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: LIST
84835: IN
84836: IFFALSE 84850
// SetClass ( unit , 1 ) ;
84838: LD_VAR 0 2
84842: PPUSH
84843: LD_INT 1
84845: PPUSH
84846: CALL_OW 336
// end ;
84850: LD_VAR 0 3
84854: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
84855: LD_INT 0
84857: PPUSH
84858: PPUSH
// if not mc_bases or not skirmish then
84859: LD_EXP 60
84863: NOT
84864: PUSH
84865: LD_EXP 58
84869: NOT
84870: OR
84871: IFFALSE 84875
// exit ;
84873: GO 84991
// if GetLives ( abandoned_vehicle ) > 250 then
84875: LD_VAR 0 2
84879: PPUSH
84880: CALL_OW 256
84884: PUSH
84885: LD_INT 250
84887: GREATER
84888: IFFALSE 84892
// exit ;
84890: GO 84991
// for i = 1 to mc_bases do
84892: LD_ADDR_VAR 0 6
84896: PUSH
84897: DOUBLE
84898: LD_INT 1
84900: DEC
84901: ST_TO_ADDR
84902: LD_EXP 60
84906: PUSH
84907: FOR_TO
84908: IFFALSE 84989
// begin if driver in mc_bases [ i ] then
84910: LD_VAR 0 1
84914: PUSH
84915: LD_EXP 60
84919: PUSH
84920: LD_VAR 0 6
84924: ARRAY
84925: IN
84926: IFFALSE 84987
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
84928: LD_VAR 0 1
84932: PPUSH
84933: LD_EXP 60
84937: PUSH
84938: LD_VAR 0 6
84942: ARRAY
84943: PPUSH
84944: LD_INT 2
84946: PUSH
84947: LD_INT 30
84949: PUSH
84950: LD_INT 0
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 30
84959: PUSH
84960: LD_INT 1
84962: PUSH
84963: EMPTY
84964: LIST
84965: LIST
84966: PUSH
84967: EMPTY
84968: LIST
84969: LIST
84970: LIST
84971: PPUSH
84972: CALL_OW 72
84976: PUSH
84977: LD_INT 1
84979: ARRAY
84980: PPUSH
84981: CALL 52419 0 2
// break ;
84985: GO 84989
// end ; end ;
84987: GO 84907
84989: POP
84990: POP
// end ; end_of_file
84991: LD_VAR 0 5
84995: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
84996: LD_INT 0
84998: PPUSH
// ar_miner := 81 ;
84999: LD_ADDR_EXP 111
85003: PUSH
85004: LD_INT 81
85006: ST_TO_ADDR
// ar_crane := 88 ;
85007: LD_ADDR_EXP 110
85011: PUSH
85012: LD_INT 88
85014: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85015: LD_ADDR_EXP 105
85019: PUSH
85020: LD_INT 89
85022: ST_TO_ADDR
// us_hack := 99 ;
85023: LD_ADDR_EXP 106
85027: PUSH
85028: LD_INT 99
85030: ST_TO_ADDR
// us_artillery := 97 ;
85031: LD_ADDR_EXP 107
85035: PUSH
85036: LD_INT 97
85038: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85039: LD_ADDR_EXP 108
85043: PUSH
85044: LD_INT 91
85046: ST_TO_ADDR
// ar_mortar := 92 ;
85047: LD_ADDR_EXP 109
85051: PUSH
85052: LD_INT 92
85054: ST_TO_ADDR
// ru_radar := 98 ;
85055: LD_ADDR_EXP 104
85059: PUSH
85060: LD_INT 98
85062: ST_TO_ADDR
// tech_Artillery := 80 ;
85063: LD_ADDR_EXP 112
85067: PUSH
85068: LD_INT 80
85070: ST_TO_ADDR
// tech_RadMat := 81 ;
85071: LD_ADDR_EXP 113
85075: PUSH
85076: LD_INT 81
85078: ST_TO_ADDR
// tech_BasicTools := 82 ;
85079: LD_ADDR_EXP 114
85083: PUSH
85084: LD_INT 82
85086: ST_TO_ADDR
// tech_Cargo := 83 ;
85087: LD_ADDR_EXP 115
85091: PUSH
85092: LD_INT 83
85094: ST_TO_ADDR
// tech_Track := 84 ;
85095: LD_ADDR_EXP 116
85099: PUSH
85100: LD_INT 84
85102: ST_TO_ADDR
// tech_Crane := 85 ;
85103: LD_ADDR_EXP 117
85107: PUSH
85108: LD_INT 85
85110: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85111: LD_ADDR_EXP 118
85115: PUSH
85116: LD_INT 86
85118: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85119: LD_ADDR_EXP 119
85123: PUSH
85124: LD_INT 87
85126: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
85127: LD_ADDR_EXP 120
85131: PUSH
85132: LD_INT 88
85134: ST_TO_ADDR
// class_mastodont := 31 ;
85135: LD_ADDR_EXP 121
85139: PUSH
85140: LD_INT 31
85142: ST_TO_ADDR
// class_horse := 21 ;
85143: LD_ADDR_EXP 122
85147: PUSH
85148: LD_INT 21
85150: ST_TO_ADDR
// end ;
85151: LD_VAR 0 1
85155: RET
// every 1 do
85156: GO 85158
85158: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85159: CALL 84996 0 0
85163: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85164: LD_INT 0
85166: PPUSH
// if p2 = 100 then
85167: LD_VAR 0 2
85171: PUSH
85172: LD_INT 100
85174: EQUAL
85175: IFFALSE 86178
// begin if not StreamModeActive then
85177: LD_EXP 123
85181: NOT
85182: IFFALSE 85192
// StreamModeActive := true ;
85184: LD_ADDR_EXP 123
85188: PUSH
85189: LD_INT 1
85191: ST_TO_ADDR
// if p3 = 0 then
85192: LD_VAR 0 3
85196: PUSH
85197: LD_INT 0
85199: EQUAL
85200: IFFALSE 85206
// InitStreamMode ;
85202: CALL 86338 0 0
// if p3 = 1 then
85206: LD_VAR 0 3
85210: PUSH
85211: LD_INT 1
85213: EQUAL
85214: IFFALSE 85224
// sRocket := true ;
85216: LD_ADDR_EXP 128
85220: PUSH
85221: LD_INT 1
85223: ST_TO_ADDR
// if p3 = 2 then
85224: LD_VAR 0 3
85228: PUSH
85229: LD_INT 2
85231: EQUAL
85232: IFFALSE 85242
// sSpeed := true ;
85234: LD_ADDR_EXP 127
85238: PUSH
85239: LD_INT 1
85241: ST_TO_ADDR
// if p3 = 3 then
85242: LD_VAR 0 3
85246: PUSH
85247: LD_INT 3
85249: EQUAL
85250: IFFALSE 85260
// sEngine := true ;
85252: LD_ADDR_EXP 129
85256: PUSH
85257: LD_INT 1
85259: ST_TO_ADDR
// if p3 = 4 then
85260: LD_VAR 0 3
85264: PUSH
85265: LD_INT 4
85267: EQUAL
85268: IFFALSE 85278
// sSpec := true ;
85270: LD_ADDR_EXP 126
85274: PUSH
85275: LD_INT 1
85277: ST_TO_ADDR
// if p3 = 5 then
85278: LD_VAR 0 3
85282: PUSH
85283: LD_INT 5
85285: EQUAL
85286: IFFALSE 85296
// sLevel := true ;
85288: LD_ADDR_EXP 130
85292: PUSH
85293: LD_INT 1
85295: ST_TO_ADDR
// if p3 = 6 then
85296: LD_VAR 0 3
85300: PUSH
85301: LD_INT 6
85303: EQUAL
85304: IFFALSE 85314
// sArmoury := true ;
85306: LD_ADDR_EXP 131
85310: PUSH
85311: LD_INT 1
85313: ST_TO_ADDR
// if p3 = 7 then
85314: LD_VAR 0 3
85318: PUSH
85319: LD_INT 7
85321: EQUAL
85322: IFFALSE 85332
// sRadar := true ;
85324: LD_ADDR_EXP 132
85328: PUSH
85329: LD_INT 1
85331: ST_TO_ADDR
// if p3 = 8 then
85332: LD_VAR 0 3
85336: PUSH
85337: LD_INT 8
85339: EQUAL
85340: IFFALSE 85350
// sBunker := true ;
85342: LD_ADDR_EXP 133
85346: PUSH
85347: LD_INT 1
85349: ST_TO_ADDR
// if p3 = 9 then
85350: LD_VAR 0 3
85354: PUSH
85355: LD_INT 9
85357: EQUAL
85358: IFFALSE 85368
// sHack := true ;
85360: LD_ADDR_EXP 134
85364: PUSH
85365: LD_INT 1
85367: ST_TO_ADDR
// if p3 = 10 then
85368: LD_VAR 0 3
85372: PUSH
85373: LD_INT 10
85375: EQUAL
85376: IFFALSE 85386
// sFire := true ;
85378: LD_ADDR_EXP 135
85382: PUSH
85383: LD_INT 1
85385: ST_TO_ADDR
// if p3 = 11 then
85386: LD_VAR 0 3
85390: PUSH
85391: LD_INT 11
85393: EQUAL
85394: IFFALSE 85404
// sRefresh := true ;
85396: LD_ADDR_EXP 136
85400: PUSH
85401: LD_INT 1
85403: ST_TO_ADDR
// if p3 = 12 then
85404: LD_VAR 0 3
85408: PUSH
85409: LD_INT 12
85411: EQUAL
85412: IFFALSE 85422
// sExp := true ;
85414: LD_ADDR_EXP 137
85418: PUSH
85419: LD_INT 1
85421: ST_TO_ADDR
// if p3 = 13 then
85422: LD_VAR 0 3
85426: PUSH
85427: LD_INT 13
85429: EQUAL
85430: IFFALSE 85440
// sDepot := true ;
85432: LD_ADDR_EXP 138
85436: PUSH
85437: LD_INT 1
85439: ST_TO_ADDR
// if p3 = 14 then
85440: LD_VAR 0 3
85444: PUSH
85445: LD_INT 14
85447: EQUAL
85448: IFFALSE 85458
// sFlag := true ;
85450: LD_ADDR_EXP 139
85454: PUSH
85455: LD_INT 1
85457: ST_TO_ADDR
// if p3 = 15 then
85458: LD_VAR 0 3
85462: PUSH
85463: LD_INT 15
85465: EQUAL
85466: IFFALSE 85476
// sKamikadze := true ;
85468: LD_ADDR_EXP 147
85472: PUSH
85473: LD_INT 1
85475: ST_TO_ADDR
// if p3 = 16 then
85476: LD_VAR 0 3
85480: PUSH
85481: LD_INT 16
85483: EQUAL
85484: IFFALSE 85494
// sTroll := true ;
85486: LD_ADDR_EXP 148
85490: PUSH
85491: LD_INT 1
85493: ST_TO_ADDR
// if p3 = 17 then
85494: LD_VAR 0 3
85498: PUSH
85499: LD_INT 17
85501: EQUAL
85502: IFFALSE 85512
// sSlow := true ;
85504: LD_ADDR_EXP 149
85508: PUSH
85509: LD_INT 1
85511: ST_TO_ADDR
// if p3 = 18 then
85512: LD_VAR 0 3
85516: PUSH
85517: LD_INT 18
85519: EQUAL
85520: IFFALSE 85530
// sLack := true ;
85522: LD_ADDR_EXP 150
85526: PUSH
85527: LD_INT 1
85529: ST_TO_ADDR
// if p3 = 19 then
85530: LD_VAR 0 3
85534: PUSH
85535: LD_INT 19
85537: EQUAL
85538: IFFALSE 85548
// sTank := true ;
85540: LD_ADDR_EXP 152
85544: PUSH
85545: LD_INT 1
85547: ST_TO_ADDR
// if p3 = 20 then
85548: LD_VAR 0 3
85552: PUSH
85553: LD_INT 20
85555: EQUAL
85556: IFFALSE 85566
// sRemote := true ;
85558: LD_ADDR_EXP 153
85562: PUSH
85563: LD_INT 1
85565: ST_TO_ADDR
// if p3 = 21 then
85566: LD_VAR 0 3
85570: PUSH
85571: LD_INT 21
85573: EQUAL
85574: IFFALSE 85584
// sPowell := true ;
85576: LD_ADDR_EXP 154
85580: PUSH
85581: LD_INT 1
85583: ST_TO_ADDR
// if p3 = 22 then
85584: LD_VAR 0 3
85588: PUSH
85589: LD_INT 22
85591: EQUAL
85592: IFFALSE 85602
// sTeleport := true ;
85594: LD_ADDR_EXP 157
85598: PUSH
85599: LD_INT 1
85601: ST_TO_ADDR
// if p3 = 23 then
85602: LD_VAR 0 3
85606: PUSH
85607: LD_INT 23
85609: EQUAL
85610: IFFALSE 85620
// sOilTower := true ;
85612: LD_ADDR_EXP 159
85616: PUSH
85617: LD_INT 1
85619: ST_TO_ADDR
// if p3 = 24 then
85620: LD_VAR 0 3
85624: PUSH
85625: LD_INT 24
85627: EQUAL
85628: IFFALSE 85638
// sShovel := true ;
85630: LD_ADDR_EXP 160
85634: PUSH
85635: LD_INT 1
85637: ST_TO_ADDR
// if p3 = 25 then
85638: LD_VAR 0 3
85642: PUSH
85643: LD_INT 25
85645: EQUAL
85646: IFFALSE 85656
// sSheik := true ;
85648: LD_ADDR_EXP 161
85652: PUSH
85653: LD_INT 1
85655: ST_TO_ADDR
// if p3 = 26 then
85656: LD_VAR 0 3
85660: PUSH
85661: LD_INT 26
85663: EQUAL
85664: IFFALSE 85674
// sEarthquake := true ;
85666: LD_ADDR_EXP 163
85670: PUSH
85671: LD_INT 1
85673: ST_TO_ADDR
// if p3 = 27 then
85674: LD_VAR 0 3
85678: PUSH
85679: LD_INT 27
85681: EQUAL
85682: IFFALSE 85692
// sAI := true ;
85684: LD_ADDR_EXP 164
85688: PUSH
85689: LD_INT 1
85691: ST_TO_ADDR
// if p3 = 28 then
85692: LD_VAR 0 3
85696: PUSH
85697: LD_INT 28
85699: EQUAL
85700: IFFALSE 85710
// sCargo := true ;
85702: LD_ADDR_EXP 167
85706: PUSH
85707: LD_INT 1
85709: ST_TO_ADDR
// if p3 = 29 then
85710: LD_VAR 0 3
85714: PUSH
85715: LD_INT 29
85717: EQUAL
85718: IFFALSE 85728
// sDLaser := true ;
85720: LD_ADDR_EXP 168
85724: PUSH
85725: LD_INT 1
85727: ST_TO_ADDR
// if p3 = 30 then
85728: LD_VAR 0 3
85732: PUSH
85733: LD_INT 30
85735: EQUAL
85736: IFFALSE 85746
// sExchange := true ;
85738: LD_ADDR_EXP 169
85742: PUSH
85743: LD_INT 1
85745: ST_TO_ADDR
// if p3 = 31 then
85746: LD_VAR 0 3
85750: PUSH
85751: LD_INT 31
85753: EQUAL
85754: IFFALSE 85764
// sFac := true ;
85756: LD_ADDR_EXP 170
85760: PUSH
85761: LD_INT 1
85763: ST_TO_ADDR
// if p3 = 32 then
85764: LD_VAR 0 3
85768: PUSH
85769: LD_INT 32
85771: EQUAL
85772: IFFALSE 85782
// sPower := true ;
85774: LD_ADDR_EXP 171
85778: PUSH
85779: LD_INT 1
85781: ST_TO_ADDR
// if p3 = 33 then
85782: LD_VAR 0 3
85786: PUSH
85787: LD_INT 33
85789: EQUAL
85790: IFFALSE 85800
// sRandom := true ;
85792: LD_ADDR_EXP 172
85796: PUSH
85797: LD_INT 1
85799: ST_TO_ADDR
// if p3 = 34 then
85800: LD_VAR 0 3
85804: PUSH
85805: LD_INT 34
85807: EQUAL
85808: IFFALSE 85818
// sShield := true ;
85810: LD_ADDR_EXP 173
85814: PUSH
85815: LD_INT 1
85817: ST_TO_ADDR
// if p3 = 35 then
85818: LD_VAR 0 3
85822: PUSH
85823: LD_INT 35
85825: EQUAL
85826: IFFALSE 85836
// sTime := true ;
85828: LD_ADDR_EXP 174
85832: PUSH
85833: LD_INT 1
85835: ST_TO_ADDR
// if p3 = 36 then
85836: LD_VAR 0 3
85840: PUSH
85841: LD_INT 36
85843: EQUAL
85844: IFFALSE 85854
// sTools := true ;
85846: LD_ADDR_EXP 175
85850: PUSH
85851: LD_INT 1
85853: ST_TO_ADDR
// if p3 = 101 then
85854: LD_VAR 0 3
85858: PUSH
85859: LD_INT 101
85861: EQUAL
85862: IFFALSE 85872
// sSold := true ;
85864: LD_ADDR_EXP 140
85868: PUSH
85869: LD_INT 1
85871: ST_TO_ADDR
// if p3 = 102 then
85872: LD_VAR 0 3
85876: PUSH
85877: LD_INT 102
85879: EQUAL
85880: IFFALSE 85890
// sDiff := true ;
85882: LD_ADDR_EXP 141
85886: PUSH
85887: LD_INT 1
85889: ST_TO_ADDR
// if p3 = 103 then
85890: LD_VAR 0 3
85894: PUSH
85895: LD_INT 103
85897: EQUAL
85898: IFFALSE 85908
// sFog := true ;
85900: LD_ADDR_EXP 144
85904: PUSH
85905: LD_INT 1
85907: ST_TO_ADDR
// if p3 = 104 then
85908: LD_VAR 0 3
85912: PUSH
85913: LD_INT 104
85915: EQUAL
85916: IFFALSE 85926
// sReset := true ;
85918: LD_ADDR_EXP 145
85922: PUSH
85923: LD_INT 1
85925: ST_TO_ADDR
// if p3 = 105 then
85926: LD_VAR 0 3
85930: PUSH
85931: LD_INT 105
85933: EQUAL
85934: IFFALSE 85944
// sSun := true ;
85936: LD_ADDR_EXP 146
85940: PUSH
85941: LD_INT 1
85943: ST_TO_ADDR
// if p3 = 106 then
85944: LD_VAR 0 3
85948: PUSH
85949: LD_INT 106
85951: EQUAL
85952: IFFALSE 85962
// sTiger := true ;
85954: LD_ADDR_EXP 142
85958: PUSH
85959: LD_INT 1
85961: ST_TO_ADDR
// if p3 = 107 then
85962: LD_VAR 0 3
85966: PUSH
85967: LD_INT 107
85969: EQUAL
85970: IFFALSE 85980
// sBomb := true ;
85972: LD_ADDR_EXP 143
85976: PUSH
85977: LD_INT 1
85979: ST_TO_ADDR
// if p3 = 108 then
85980: LD_VAR 0 3
85984: PUSH
85985: LD_INT 108
85987: EQUAL
85988: IFFALSE 85998
// sWound := true ;
85990: LD_ADDR_EXP 151
85994: PUSH
85995: LD_INT 1
85997: ST_TO_ADDR
// if p3 = 109 then
85998: LD_VAR 0 3
86002: PUSH
86003: LD_INT 109
86005: EQUAL
86006: IFFALSE 86016
// sBetray := true ;
86008: LD_ADDR_EXP 155
86012: PUSH
86013: LD_INT 1
86015: ST_TO_ADDR
// if p3 = 110 then
86016: LD_VAR 0 3
86020: PUSH
86021: LD_INT 110
86023: EQUAL
86024: IFFALSE 86034
// sContamin := true ;
86026: LD_ADDR_EXP 156
86030: PUSH
86031: LD_INT 1
86033: ST_TO_ADDR
// if p3 = 111 then
86034: LD_VAR 0 3
86038: PUSH
86039: LD_INT 111
86041: EQUAL
86042: IFFALSE 86052
// sOil := true ;
86044: LD_ADDR_EXP 158
86048: PUSH
86049: LD_INT 1
86051: ST_TO_ADDR
// if p3 = 112 then
86052: LD_VAR 0 3
86056: PUSH
86057: LD_INT 112
86059: EQUAL
86060: IFFALSE 86070
// sStu := true ;
86062: LD_ADDR_EXP 162
86066: PUSH
86067: LD_INT 1
86069: ST_TO_ADDR
// if p3 = 113 then
86070: LD_VAR 0 3
86074: PUSH
86075: LD_INT 113
86077: EQUAL
86078: IFFALSE 86088
// sBazooka := true ;
86080: LD_ADDR_EXP 165
86084: PUSH
86085: LD_INT 1
86087: ST_TO_ADDR
// if p3 = 114 then
86088: LD_VAR 0 3
86092: PUSH
86093: LD_INT 114
86095: EQUAL
86096: IFFALSE 86106
// sMortar := true ;
86098: LD_ADDR_EXP 166
86102: PUSH
86103: LD_INT 1
86105: ST_TO_ADDR
// if p3 = 115 then
86106: LD_VAR 0 3
86110: PUSH
86111: LD_INT 115
86113: EQUAL
86114: IFFALSE 86124
// sRanger := true ;
86116: LD_ADDR_EXP 176
86120: PUSH
86121: LD_INT 1
86123: ST_TO_ADDR
// if p3 = 116 then
86124: LD_VAR 0 3
86128: PUSH
86129: LD_INT 116
86131: EQUAL
86132: IFFALSE 86142
// sComputer := true ;
86134: LD_ADDR_EXP 177
86138: PUSH
86139: LD_INT 1
86141: ST_TO_ADDR
// if p3 = 117 then
86142: LD_VAR 0 3
86146: PUSH
86147: LD_INT 117
86149: EQUAL
86150: IFFALSE 86160
// s30 := true ;
86152: LD_ADDR_EXP 178
86156: PUSH
86157: LD_INT 1
86159: ST_TO_ADDR
// if p3 = 118 then
86160: LD_VAR 0 3
86164: PUSH
86165: LD_INT 118
86167: EQUAL
86168: IFFALSE 86178
// s60 := true ;
86170: LD_ADDR_EXP 179
86174: PUSH
86175: LD_INT 1
86177: ST_TO_ADDR
// end ; if p2 = 101 then
86178: LD_VAR 0 2
86182: PUSH
86183: LD_INT 101
86185: EQUAL
86186: IFFALSE 86314
// begin case p3 of 1 :
86188: LD_VAR 0 3
86192: PUSH
86193: LD_INT 1
86195: DOUBLE
86196: EQUAL
86197: IFTRUE 86201
86199: GO 86208
86201: POP
// hHackUnlimitedResources ; 2 :
86202: CALL 97910 0 0
86206: GO 86314
86208: LD_INT 2
86210: DOUBLE
86211: EQUAL
86212: IFTRUE 86216
86214: GO 86223
86216: POP
// hHackSetLevel10 ; 3 :
86217: CALL 98043 0 0
86221: GO 86314
86223: LD_INT 3
86225: DOUBLE
86226: EQUAL
86227: IFTRUE 86231
86229: GO 86238
86231: POP
// hHackSetLevel10YourUnits ; 4 :
86232: CALL 98128 0 0
86236: GO 86314
86238: LD_INT 4
86240: DOUBLE
86241: EQUAL
86242: IFTRUE 86246
86244: GO 86253
86246: POP
// hHackInvincible ; 5 :
86247: CALL 98576 0 0
86251: GO 86314
86253: LD_INT 5
86255: DOUBLE
86256: EQUAL
86257: IFTRUE 86261
86259: GO 86268
86261: POP
// hHackInvisible ; 6 :
86262: CALL 98687 0 0
86266: GO 86314
86268: LD_INT 6
86270: DOUBLE
86271: EQUAL
86272: IFTRUE 86276
86274: GO 86283
86276: POP
// hHackChangeYourSide ; 7 :
86277: CALL 98744 0 0
86281: GO 86314
86283: LD_INT 7
86285: DOUBLE
86286: EQUAL
86287: IFTRUE 86291
86289: GO 86298
86291: POP
// hHackChangeUnitSide ; 8 :
86292: CALL 98786 0 0
86296: GO 86314
86298: LD_INT 8
86300: DOUBLE
86301: EQUAL
86302: IFTRUE 86306
86304: GO 86313
86306: POP
// hHackFog ; end ;
86307: CALL 98887 0 0
86311: GO 86314
86313: POP
// end ; end ;
86314: LD_VAR 0 7
86318: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
86319: GO 86321
86321: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86322: LD_STRING initStreamRollete();
86324: PPUSH
86325: CALL_OW 559
// InitStreamMode ;
86329: CALL 86338 0 0
// DefineStreamItems ( ) ;
86333: CALL 86802 0 0
// end ;
86337: END
// function InitStreamMode ; begin
86338: LD_INT 0
86340: PPUSH
// streamModeActive := false ;
86341: LD_ADDR_EXP 123
86345: PUSH
86346: LD_INT 0
86348: ST_TO_ADDR
// normalCounter := 36 ;
86349: LD_ADDR_EXP 124
86353: PUSH
86354: LD_INT 36
86356: ST_TO_ADDR
// hardcoreCounter := 16 ;
86357: LD_ADDR_EXP 125
86361: PUSH
86362: LD_INT 16
86364: ST_TO_ADDR
// sRocket := false ;
86365: LD_ADDR_EXP 128
86369: PUSH
86370: LD_INT 0
86372: ST_TO_ADDR
// sSpeed := false ;
86373: LD_ADDR_EXP 127
86377: PUSH
86378: LD_INT 0
86380: ST_TO_ADDR
// sEngine := false ;
86381: LD_ADDR_EXP 129
86385: PUSH
86386: LD_INT 0
86388: ST_TO_ADDR
// sSpec := false ;
86389: LD_ADDR_EXP 126
86393: PUSH
86394: LD_INT 0
86396: ST_TO_ADDR
// sLevel := false ;
86397: LD_ADDR_EXP 130
86401: PUSH
86402: LD_INT 0
86404: ST_TO_ADDR
// sArmoury := false ;
86405: LD_ADDR_EXP 131
86409: PUSH
86410: LD_INT 0
86412: ST_TO_ADDR
// sRadar := false ;
86413: LD_ADDR_EXP 132
86417: PUSH
86418: LD_INT 0
86420: ST_TO_ADDR
// sBunker := false ;
86421: LD_ADDR_EXP 133
86425: PUSH
86426: LD_INT 0
86428: ST_TO_ADDR
// sHack := false ;
86429: LD_ADDR_EXP 134
86433: PUSH
86434: LD_INT 0
86436: ST_TO_ADDR
// sFire := false ;
86437: LD_ADDR_EXP 135
86441: PUSH
86442: LD_INT 0
86444: ST_TO_ADDR
// sRefresh := false ;
86445: LD_ADDR_EXP 136
86449: PUSH
86450: LD_INT 0
86452: ST_TO_ADDR
// sExp := false ;
86453: LD_ADDR_EXP 137
86457: PUSH
86458: LD_INT 0
86460: ST_TO_ADDR
// sDepot := false ;
86461: LD_ADDR_EXP 138
86465: PUSH
86466: LD_INT 0
86468: ST_TO_ADDR
// sFlag := false ;
86469: LD_ADDR_EXP 139
86473: PUSH
86474: LD_INT 0
86476: ST_TO_ADDR
// sKamikadze := false ;
86477: LD_ADDR_EXP 147
86481: PUSH
86482: LD_INT 0
86484: ST_TO_ADDR
// sTroll := false ;
86485: LD_ADDR_EXP 148
86489: PUSH
86490: LD_INT 0
86492: ST_TO_ADDR
// sSlow := false ;
86493: LD_ADDR_EXP 149
86497: PUSH
86498: LD_INT 0
86500: ST_TO_ADDR
// sLack := false ;
86501: LD_ADDR_EXP 150
86505: PUSH
86506: LD_INT 0
86508: ST_TO_ADDR
// sTank := false ;
86509: LD_ADDR_EXP 152
86513: PUSH
86514: LD_INT 0
86516: ST_TO_ADDR
// sRemote := false ;
86517: LD_ADDR_EXP 153
86521: PUSH
86522: LD_INT 0
86524: ST_TO_ADDR
// sPowell := false ;
86525: LD_ADDR_EXP 154
86529: PUSH
86530: LD_INT 0
86532: ST_TO_ADDR
// sTeleport := false ;
86533: LD_ADDR_EXP 157
86537: PUSH
86538: LD_INT 0
86540: ST_TO_ADDR
// sOilTower := false ;
86541: LD_ADDR_EXP 159
86545: PUSH
86546: LD_INT 0
86548: ST_TO_ADDR
// sShovel := false ;
86549: LD_ADDR_EXP 160
86553: PUSH
86554: LD_INT 0
86556: ST_TO_ADDR
// sSheik := false ;
86557: LD_ADDR_EXP 161
86561: PUSH
86562: LD_INT 0
86564: ST_TO_ADDR
// sEarthquake := false ;
86565: LD_ADDR_EXP 163
86569: PUSH
86570: LD_INT 0
86572: ST_TO_ADDR
// sAI := false ;
86573: LD_ADDR_EXP 164
86577: PUSH
86578: LD_INT 0
86580: ST_TO_ADDR
// sCargo := false ;
86581: LD_ADDR_EXP 167
86585: PUSH
86586: LD_INT 0
86588: ST_TO_ADDR
// sDLaser := false ;
86589: LD_ADDR_EXP 168
86593: PUSH
86594: LD_INT 0
86596: ST_TO_ADDR
// sExchange := false ;
86597: LD_ADDR_EXP 169
86601: PUSH
86602: LD_INT 0
86604: ST_TO_ADDR
// sFac := false ;
86605: LD_ADDR_EXP 170
86609: PUSH
86610: LD_INT 0
86612: ST_TO_ADDR
// sPower := false ;
86613: LD_ADDR_EXP 171
86617: PUSH
86618: LD_INT 0
86620: ST_TO_ADDR
// sRandom := false ;
86621: LD_ADDR_EXP 172
86625: PUSH
86626: LD_INT 0
86628: ST_TO_ADDR
// sShield := false ;
86629: LD_ADDR_EXP 173
86633: PUSH
86634: LD_INT 0
86636: ST_TO_ADDR
// sTime := false ;
86637: LD_ADDR_EXP 174
86641: PUSH
86642: LD_INT 0
86644: ST_TO_ADDR
// sTools := false ;
86645: LD_ADDR_EXP 175
86649: PUSH
86650: LD_INT 0
86652: ST_TO_ADDR
// sSold := false ;
86653: LD_ADDR_EXP 140
86657: PUSH
86658: LD_INT 0
86660: ST_TO_ADDR
// sDiff := false ;
86661: LD_ADDR_EXP 141
86665: PUSH
86666: LD_INT 0
86668: ST_TO_ADDR
// sFog := false ;
86669: LD_ADDR_EXP 144
86673: PUSH
86674: LD_INT 0
86676: ST_TO_ADDR
// sReset := false ;
86677: LD_ADDR_EXP 145
86681: PUSH
86682: LD_INT 0
86684: ST_TO_ADDR
// sSun := false ;
86685: LD_ADDR_EXP 146
86689: PUSH
86690: LD_INT 0
86692: ST_TO_ADDR
// sTiger := false ;
86693: LD_ADDR_EXP 142
86697: PUSH
86698: LD_INT 0
86700: ST_TO_ADDR
// sBomb := false ;
86701: LD_ADDR_EXP 143
86705: PUSH
86706: LD_INT 0
86708: ST_TO_ADDR
// sWound := false ;
86709: LD_ADDR_EXP 151
86713: PUSH
86714: LD_INT 0
86716: ST_TO_ADDR
// sBetray := false ;
86717: LD_ADDR_EXP 155
86721: PUSH
86722: LD_INT 0
86724: ST_TO_ADDR
// sContamin := false ;
86725: LD_ADDR_EXP 156
86729: PUSH
86730: LD_INT 0
86732: ST_TO_ADDR
// sOil := false ;
86733: LD_ADDR_EXP 158
86737: PUSH
86738: LD_INT 0
86740: ST_TO_ADDR
// sStu := false ;
86741: LD_ADDR_EXP 162
86745: PUSH
86746: LD_INT 0
86748: ST_TO_ADDR
// sBazooka := false ;
86749: LD_ADDR_EXP 165
86753: PUSH
86754: LD_INT 0
86756: ST_TO_ADDR
// sMortar := false ;
86757: LD_ADDR_EXP 166
86761: PUSH
86762: LD_INT 0
86764: ST_TO_ADDR
// sRanger := false ;
86765: LD_ADDR_EXP 176
86769: PUSH
86770: LD_INT 0
86772: ST_TO_ADDR
// sComputer := false ;
86773: LD_ADDR_EXP 177
86777: PUSH
86778: LD_INT 0
86780: ST_TO_ADDR
// s30 := false ;
86781: LD_ADDR_EXP 178
86785: PUSH
86786: LD_INT 0
86788: ST_TO_ADDR
// s60 := false ;
86789: LD_ADDR_EXP 179
86793: PUSH
86794: LD_INT 0
86796: ST_TO_ADDR
// end ;
86797: LD_VAR 0 1
86801: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86802: LD_INT 0
86804: PPUSH
86805: PPUSH
86806: PPUSH
86807: PPUSH
86808: PPUSH
// result := [ ] ;
86809: LD_ADDR_VAR 0 1
86813: PUSH
86814: EMPTY
86815: ST_TO_ADDR
// if campaign_id = 1 then
86816: LD_OWVAR 69
86820: PUSH
86821: LD_INT 1
86823: EQUAL
86824: IFFALSE 89990
// begin case mission_number of 1 :
86826: LD_OWVAR 70
86830: PUSH
86831: LD_INT 1
86833: DOUBLE
86834: EQUAL
86835: IFTRUE 86839
86837: GO 86915
86839: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
86840: LD_ADDR_VAR 0 1
86844: PUSH
86845: LD_INT 2
86847: PUSH
86848: LD_INT 4
86850: PUSH
86851: LD_INT 11
86853: PUSH
86854: LD_INT 12
86856: PUSH
86857: LD_INT 15
86859: PUSH
86860: LD_INT 16
86862: PUSH
86863: LD_INT 22
86865: PUSH
86866: LD_INT 23
86868: PUSH
86869: LD_INT 26
86871: PUSH
86872: EMPTY
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: PUSH
86883: LD_INT 101
86885: PUSH
86886: LD_INT 102
86888: PUSH
86889: LD_INT 106
86891: PUSH
86892: LD_INT 116
86894: PUSH
86895: LD_INT 117
86897: PUSH
86898: LD_INT 118
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: LIST
86905: LIST
86906: LIST
86907: LIST
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: ST_TO_ADDR
86913: GO 89988
86915: LD_INT 2
86917: DOUBLE
86918: EQUAL
86919: IFTRUE 86923
86921: GO 87007
86923: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
86924: LD_ADDR_VAR 0 1
86928: PUSH
86929: LD_INT 2
86931: PUSH
86932: LD_INT 4
86934: PUSH
86935: LD_INT 11
86937: PUSH
86938: LD_INT 12
86940: PUSH
86941: LD_INT 15
86943: PUSH
86944: LD_INT 16
86946: PUSH
86947: LD_INT 22
86949: PUSH
86950: LD_INT 23
86952: PUSH
86953: LD_INT 26
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 101
86969: PUSH
86970: LD_INT 102
86972: PUSH
86973: LD_INT 105
86975: PUSH
86976: LD_INT 106
86978: PUSH
86979: LD_INT 108
86981: PUSH
86982: LD_INT 116
86984: PUSH
86985: LD_INT 117
86987: PUSH
86988: LD_INT 118
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: ST_TO_ADDR
87005: GO 89988
87007: LD_INT 3
87009: DOUBLE
87010: EQUAL
87011: IFTRUE 87015
87013: GO 87103
87015: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87016: LD_ADDR_VAR 0 1
87020: PUSH
87021: LD_INT 2
87023: PUSH
87024: LD_INT 4
87026: PUSH
87027: LD_INT 5
87029: PUSH
87030: LD_INT 11
87032: PUSH
87033: LD_INT 12
87035: PUSH
87036: LD_INT 15
87038: PUSH
87039: LD_INT 16
87041: PUSH
87042: LD_INT 22
87044: PUSH
87045: LD_INT 26
87047: PUSH
87048: LD_INT 36
87050: PUSH
87051: EMPTY
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 101
87065: PUSH
87066: LD_INT 102
87068: PUSH
87069: LD_INT 105
87071: PUSH
87072: LD_INT 106
87074: PUSH
87075: LD_INT 108
87077: PUSH
87078: LD_INT 116
87080: PUSH
87081: LD_INT 117
87083: PUSH
87084: LD_INT 118
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: PUSH
87097: EMPTY
87098: LIST
87099: LIST
87100: ST_TO_ADDR
87101: GO 89988
87103: LD_INT 4
87105: DOUBLE
87106: EQUAL
87107: IFTRUE 87111
87109: GO 87207
87111: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87112: LD_ADDR_VAR 0 1
87116: PUSH
87117: LD_INT 2
87119: PUSH
87120: LD_INT 4
87122: PUSH
87123: LD_INT 5
87125: PUSH
87126: LD_INT 8
87128: PUSH
87129: LD_INT 11
87131: PUSH
87132: LD_INT 12
87134: PUSH
87135: LD_INT 15
87137: PUSH
87138: LD_INT 16
87140: PUSH
87141: LD_INT 22
87143: PUSH
87144: LD_INT 23
87146: PUSH
87147: LD_INT 26
87149: PUSH
87150: LD_INT 36
87152: PUSH
87153: EMPTY
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 101
87169: PUSH
87170: LD_INT 102
87172: PUSH
87173: LD_INT 105
87175: PUSH
87176: LD_INT 106
87178: PUSH
87179: LD_INT 108
87181: PUSH
87182: LD_INT 116
87184: PUSH
87185: LD_INT 117
87187: PUSH
87188: LD_INT 118
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: LIST
87195: LIST
87196: LIST
87197: LIST
87198: LIST
87199: LIST
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: ST_TO_ADDR
87205: GO 89988
87207: LD_INT 5
87209: DOUBLE
87210: EQUAL
87211: IFTRUE 87215
87213: GO 87327
87215: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87216: LD_ADDR_VAR 0 1
87220: PUSH
87221: LD_INT 2
87223: PUSH
87224: LD_INT 4
87226: PUSH
87227: LD_INT 5
87229: PUSH
87230: LD_INT 6
87232: PUSH
87233: LD_INT 8
87235: PUSH
87236: LD_INT 11
87238: PUSH
87239: LD_INT 12
87241: PUSH
87242: LD_INT 15
87244: PUSH
87245: LD_INT 16
87247: PUSH
87248: LD_INT 22
87250: PUSH
87251: LD_INT 23
87253: PUSH
87254: LD_INT 25
87256: PUSH
87257: LD_INT 26
87259: PUSH
87260: LD_INT 36
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: LIST
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 101
87281: PUSH
87282: LD_INT 102
87284: PUSH
87285: LD_INT 105
87287: PUSH
87288: LD_INT 106
87290: PUSH
87291: LD_INT 108
87293: PUSH
87294: LD_INT 109
87296: PUSH
87297: LD_INT 112
87299: PUSH
87300: LD_INT 116
87302: PUSH
87303: LD_INT 117
87305: PUSH
87306: LD_INT 118
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: PUSH
87321: EMPTY
87322: LIST
87323: LIST
87324: ST_TO_ADDR
87325: GO 89988
87327: LD_INT 6
87329: DOUBLE
87330: EQUAL
87331: IFTRUE 87335
87333: GO 87467
87335: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
87336: LD_ADDR_VAR 0 1
87340: PUSH
87341: LD_INT 2
87343: PUSH
87344: LD_INT 4
87346: PUSH
87347: LD_INT 5
87349: PUSH
87350: LD_INT 6
87352: PUSH
87353: LD_INT 8
87355: PUSH
87356: LD_INT 11
87358: PUSH
87359: LD_INT 12
87361: PUSH
87362: LD_INT 15
87364: PUSH
87365: LD_INT 16
87367: PUSH
87368: LD_INT 20
87370: PUSH
87371: LD_INT 21
87373: PUSH
87374: LD_INT 22
87376: PUSH
87377: LD_INT 23
87379: PUSH
87380: LD_INT 25
87382: PUSH
87383: LD_INT 26
87385: PUSH
87386: LD_INT 30
87388: PUSH
87389: LD_INT 31
87391: PUSH
87392: LD_INT 32
87394: PUSH
87395: LD_INT 36
87397: PUSH
87398: EMPTY
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 101
87421: PUSH
87422: LD_INT 102
87424: PUSH
87425: LD_INT 105
87427: PUSH
87428: LD_INT 106
87430: PUSH
87431: LD_INT 108
87433: PUSH
87434: LD_INT 109
87436: PUSH
87437: LD_INT 112
87439: PUSH
87440: LD_INT 116
87442: PUSH
87443: LD_INT 117
87445: PUSH
87446: LD_INT 118
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: LIST
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: PUSH
87461: EMPTY
87462: LIST
87463: LIST
87464: ST_TO_ADDR
87465: GO 89988
87467: LD_INT 7
87469: DOUBLE
87470: EQUAL
87471: IFTRUE 87475
87473: GO 87587
87475: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
87476: LD_ADDR_VAR 0 1
87480: PUSH
87481: LD_INT 2
87483: PUSH
87484: LD_INT 4
87486: PUSH
87487: LD_INT 5
87489: PUSH
87490: LD_INT 7
87492: PUSH
87493: LD_INT 11
87495: PUSH
87496: LD_INT 12
87498: PUSH
87499: LD_INT 15
87501: PUSH
87502: LD_INT 16
87504: PUSH
87505: LD_INT 20
87507: PUSH
87508: LD_INT 21
87510: PUSH
87511: LD_INT 22
87513: PUSH
87514: LD_INT 23
87516: PUSH
87517: LD_INT 25
87519: PUSH
87520: LD_INT 26
87522: PUSH
87523: EMPTY
87524: LIST
87525: LIST
87526: LIST
87527: LIST
87528: LIST
87529: LIST
87530: LIST
87531: LIST
87532: LIST
87533: LIST
87534: LIST
87535: LIST
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 101
87541: PUSH
87542: LD_INT 102
87544: PUSH
87545: LD_INT 103
87547: PUSH
87548: LD_INT 105
87550: PUSH
87551: LD_INT 106
87553: PUSH
87554: LD_INT 108
87556: PUSH
87557: LD_INT 112
87559: PUSH
87560: LD_INT 116
87562: PUSH
87563: LD_INT 117
87565: PUSH
87566: LD_INT 118
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: LIST
87573: LIST
87574: LIST
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: PUSH
87581: EMPTY
87582: LIST
87583: LIST
87584: ST_TO_ADDR
87585: GO 89988
87587: LD_INT 8
87589: DOUBLE
87590: EQUAL
87591: IFTRUE 87595
87593: GO 87735
87595: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
87596: LD_ADDR_VAR 0 1
87600: PUSH
87601: LD_INT 2
87603: PUSH
87604: LD_INT 4
87606: PUSH
87607: LD_INT 5
87609: PUSH
87610: LD_INT 6
87612: PUSH
87613: LD_INT 7
87615: PUSH
87616: LD_INT 8
87618: PUSH
87619: LD_INT 11
87621: PUSH
87622: LD_INT 12
87624: PUSH
87625: LD_INT 15
87627: PUSH
87628: LD_INT 16
87630: PUSH
87631: LD_INT 20
87633: PUSH
87634: LD_INT 21
87636: PUSH
87637: LD_INT 22
87639: PUSH
87640: LD_INT 23
87642: PUSH
87643: LD_INT 25
87645: PUSH
87646: LD_INT 26
87648: PUSH
87649: LD_INT 30
87651: PUSH
87652: LD_INT 31
87654: PUSH
87655: LD_INT 32
87657: PUSH
87658: LD_INT 36
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: PUSH
87683: LD_INT 101
87685: PUSH
87686: LD_INT 102
87688: PUSH
87689: LD_INT 103
87691: PUSH
87692: LD_INT 105
87694: PUSH
87695: LD_INT 106
87697: PUSH
87698: LD_INT 108
87700: PUSH
87701: LD_INT 109
87703: PUSH
87704: LD_INT 112
87706: PUSH
87707: LD_INT 116
87709: PUSH
87710: LD_INT 117
87712: PUSH
87713: LD_INT 118
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: PUSH
87729: EMPTY
87730: LIST
87731: LIST
87732: ST_TO_ADDR
87733: GO 89988
87735: LD_INT 9
87737: DOUBLE
87738: EQUAL
87739: IFTRUE 87743
87741: GO 87891
87743: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
87744: LD_ADDR_VAR 0 1
87748: PUSH
87749: LD_INT 2
87751: PUSH
87752: LD_INT 4
87754: PUSH
87755: LD_INT 5
87757: PUSH
87758: LD_INT 6
87760: PUSH
87761: LD_INT 7
87763: PUSH
87764: LD_INT 8
87766: PUSH
87767: LD_INT 11
87769: PUSH
87770: LD_INT 12
87772: PUSH
87773: LD_INT 15
87775: PUSH
87776: LD_INT 16
87778: PUSH
87779: LD_INT 20
87781: PUSH
87782: LD_INT 21
87784: PUSH
87785: LD_INT 22
87787: PUSH
87788: LD_INT 23
87790: PUSH
87791: LD_INT 25
87793: PUSH
87794: LD_INT 26
87796: PUSH
87797: LD_INT 28
87799: PUSH
87800: LD_INT 30
87802: PUSH
87803: LD_INT 31
87805: PUSH
87806: LD_INT 32
87808: PUSH
87809: LD_INT 36
87811: PUSH
87812: EMPTY
87813: LIST
87814: LIST
87815: LIST
87816: LIST
87817: LIST
87818: LIST
87819: LIST
87820: LIST
87821: LIST
87822: LIST
87823: LIST
87824: LIST
87825: LIST
87826: LIST
87827: LIST
87828: LIST
87829: LIST
87830: LIST
87831: LIST
87832: LIST
87833: LIST
87834: PUSH
87835: LD_INT 101
87837: PUSH
87838: LD_INT 102
87840: PUSH
87841: LD_INT 103
87843: PUSH
87844: LD_INT 105
87846: PUSH
87847: LD_INT 106
87849: PUSH
87850: LD_INT 108
87852: PUSH
87853: LD_INT 109
87855: PUSH
87856: LD_INT 112
87858: PUSH
87859: LD_INT 114
87861: PUSH
87862: LD_INT 116
87864: PUSH
87865: LD_INT 117
87867: PUSH
87868: LD_INT 118
87870: PUSH
87871: EMPTY
87872: LIST
87873: LIST
87874: LIST
87875: LIST
87876: LIST
87877: LIST
87878: LIST
87879: LIST
87880: LIST
87881: LIST
87882: LIST
87883: LIST
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: ST_TO_ADDR
87889: GO 89988
87891: LD_INT 10
87893: DOUBLE
87894: EQUAL
87895: IFTRUE 87899
87897: GO 88095
87899: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
87900: LD_ADDR_VAR 0 1
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: LD_INT 4
87910: PUSH
87911: LD_INT 5
87913: PUSH
87914: LD_INT 6
87916: PUSH
87917: LD_INT 7
87919: PUSH
87920: LD_INT 8
87922: PUSH
87923: LD_INT 9
87925: PUSH
87926: LD_INT 10
87928: PUSH
87929: LD_INT 11
87931: PUSH
87932: LD_INT 12
87934: PUSH
87935: LD_INT 13
87937: PUSH
87938: LD_INT 14
87940: PUSH
87941: LD_INT 15
87943: PUSH
87944: LD_INT 16
87946: PUSH
87947: LD_INT 17
87949: PUSH
87950: LD_INT 18
87952: PUSH
87953: LD_INT 19
87955: PUSH
87956: LD_INT 20
87958: PUSH
87959: LD_INT 21
87961: PUSH
87962: LD_INT 22
87964: PUSH
87965: LD_INT 23
87967: PUSH
87968: LD_INT 24
87970: PUSH
87971: LD_INT 25
87973: PUSH
87974: LD_INT 26
87976: PUSH
87977: LD_INT 28
87979: PUSH
87980: LD_INT 30
87982: PUSH
87983: LD_INT 31
87985: PUSH
87986: LD_INT 32
87988: PUSH
87989: LD_INT 36
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 101
88025: PUSH
88026: LD_INT 102
88028: PUSH
88029: LD_INT 103
88031: PUSH
88032: LD_INT 104
88034: PUSH
88035: LD_INT 105
88037: PUSH
88038: LD_INT 106
88040: PUSH
88041: LD_INT 107
88043: PUSH
88044: LD_INT 108
88046: PUSH
88047: LD_INT 109
88049: PUSH
88050: LD_INT 110
88052: PUSH
88053: LD_INT 111
88055: PUSH
88056: LD_INT 112
88058: PUSH
88059: LD_INT 114
88061: PUSH
88062: LD_INT 116
88064: PUSH
88065: LD_INT 117
88067: PUSH
88068: LD_INT 118
88070: PUSH
88071: EMPTY
88072: LIST
88073: LIST
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: ST_TO_ADDR
88093: GO 89988
88095: LD_INT 11
88097: DOUBLE
88098: EQUAL
88099: IFTRUE 88103
88101: GO 88307
88103: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88104: LD_ADDR_VAR 0 1
88108: PUSH
88109: LD_INT 2
88111: PUSH
88112: LD_INT 3
88114: PUSH
88115: LD_INT 4
88117: PUSH
88118: LD_INT 5
88120: PUSH
88121: LD_INT 6
88123: PUSH
88124: LD_INT 7
88126: PUSH
88127: LD_INT 8
88129: PUSH
88130: LD_INT 9
88132: PUSH
88133: LD_INT 10
88135: PUSH
88136: LD_INT 11
88138: PUSH
88139: LD_INT 12
88141: PUSH
88142: LD_INT 13
88144: PUSH
88145: LD_INT 14
88147: PUSH
88148: LD_INT 15
88150: PUSH
88151: LD_INT 16
88153: PUSH
88154: LD_INT 17
88156: PUSH
88157: LD_INT 18
88159: PUSH
88160: LD_INT 19
88162: PUSH
88163: LD_INT 20
88165: PUSH
88166: LD_INT 21
88168: PUSH
88169: LD_INT 22
88171: PUSH
88172: LD_INT 23
88174: PUSH
88175: LD_INT 24
88177: PUSH
88178: LD_INT 25
88180: PUSH
88181: LD_INT 26
88183: PUSH
88184: LD_INT 28
88186: PUSH
88187: LD_INT 30
88189: PUSH
88190: LD_INT 31
88192: PUSH
88193: LD_INT 32
88195: PUSH
88196: LD_INT 34
88198: PUSH
88199: LD_INT 36
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: LIST
88208: LIST
88209: LIST
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: PUSH
88235: LD_INT 101
88237: PUSH
88238: LD_INT 102
88240: PUSH
88241: LD_INT 103
88243: PUSH
88244: LD_INT 104
88246: PUSH
88247: LD_INT 105
88249: PUSH
88250: LD_INT 106
88252: PUSH
88253: LD_INT 107
88255: PUSH
88256: LD_INT 108
88258: PUSH
88259: LD_INT 109
88261: PUSH
88262: LD_INT 110
88264: PUSH
88265: LD_INT 111
88267: PUSH
88268: LD_INT 112
88270: PUSH
88271: LD_INT 114
88273: PUSH
88274: LD_INT 116
88276: PUSH
88277: LD_INT 117
88279: PUSH
88280: LD_INT 118
88282: PUSH
88283: EMPTY
88284: LIST
88285: LIST
88286: LIST
88287: LIST
88288: LIST
88289: LIST
88290: LIST
88291: LIST
88292: LIST
88293: LIST
88294: LIST
88295: LIST
88296: LIST
88297: LIST
88298: LIST
88299: LIST
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: ST_TO_ADDR
88305: GO 89988
88307: LD_INT 12
88309: DOUBLE
88310: EQUAL
88311: IFTRUE 88315
88313: GO 88535
88315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
88316: LD_ADDR_VAR 0 1
88320: PUSH
88321: LD_INT 1
88323: PUSH
88324: LD_INT 2
88326: PUSH
88327: LD_INT 3
88329: PUSH
88330: LD_INT 4
88332: PUSH
88333: LD_INT 5
88335: PUSH
88336: LD_INT 6
88338: PUSH
88339: LD_INT 7
88341: PUSH
88342: LD_INT 8
88344: PUSH
88345: LD_INT 9
88347: PUSH
88348: LD_INT 10
88350: PUSH
88351: LD_INT 11
88353: PUSH
88354: LD_INT 12
88356: PUSH
88357: LD_INT 13
88359: PUSH
88360: LD_INT 14
88362: PUSH
88363: LD_INT 15
88365: PUSH
88366: LD_INT 16
88368: PUSH
88369: LD_INT 17
88371: PUSH
88372: LD_INT 18
88374: PUSH
88375: LD_INT 19
88377: PUSH
88378: LD_INT 20
88380: PUSH
88381: LD_INT 21
88383: PUSH
88384: LD_INT 22
88386: PUSH
88387: LD_INT 23
88389: PUSH
88390: LD_INT 24
88392: PUSH
88393: LD_INT 25
88395: PUSH
88396: LD_INT 26
88398: PUSH
88399: LD_INT 27
88401: PUSH
88402: LD_INT 28
88404: PUSH
88405: LD_INT 30
88407: PUSH
88408: LD_INT 31
88410: PUSH
88411: LD_INT 32
88413: PUSH
88414: LD_INT 33
88416: PUSH
88417: LD_INT 34
88419: PUSH
88420: LD_INT 36
88422: PUSH
88423: EMPTY
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: PUSH
88459: LD_INT 101
88461: PUSH
88462: LD_INT 102
88464: PUSH
88465: LD_INT 103
88467: PUSH
88468: LD_INT 104
88470: PUSH
88471: LD_INT 105
88473: PUSH
88474: LD_INT 106
88476: PUSH
88477: LD_INT 107
88479: PUSH
88480: LD_INT 108
88482: PUSH
88483: LD_INT 109
88485: PUSH
88486: LD_INT 110
88488: PUSH
88489: LD_INT 111
88491: PUSH
88492: LD_INT 112
88494: PUSH
88495: LD_INT 113
88497: PUSH
88498: LD_INT 114
88500: PUSH
88501: LD_INT 116
88503: PUSH
88504: LD_INT 117
88506: PUSH
88507: LD_INT 118
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: LIST
88520: LIST
88521: LIST
88522: LIST
88523: LIST
88524: LIST
88525: LIST
88526: LIST
88527: LIST
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: ST_TO_ADDR
88533: GO 89988
88535: LD_INT 13
88537: DOUBLE
88538: EQUAL
88539: IFTRUE 88543
88541: GO 88751
88543: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
88544: LD_ADDR_VAR 0 1
88548: PUSH
88549: LD_INT 1
88551: PUSH
88552: LD_INT 2
88554: PUSH
88555: LD_INT 3
88557: PUSH
88558: LD_INT 4
88560: PUSH
88561: LD_INT 5
88563: PUSH
88564: LD_INT 8
88566: PUSH
88567: LD_INT 9
88569: PUSH
88570: LD_INT 10
88572: PUSH
88573: LD_INT 11
88575: PUSH
88576: LD_INT 12
88578: PUSH
88579: LD_INT 14
88581: PUSH
88582: LD_INT 15
88584: PUSH
88585: LD_INT 16
88587: PUSH
88588: LD_INT 17
88590: PUSH
88591: LD_INT 18
88593: PUSH
88594: LD_INT 19
88596: PUSH
88597: LD_INT 20
88599: PUSH
88600: LD_INT 21
88602: PUSH
88603: LD_INT 22
88605: PUSH
88606: LD_INT 23
88608: PUSH
88609: LD_INT 24
88611: PUSH
88612: LD_INT 25
88614: PUSH
88615: LD_INT 26
88617: PUSH
88618: LD_INT 27
88620: PUSH
88621: LD_INT 28
88623: PUSH
88624: LD_INT 30
88626: PUSH
88627: LD_INT 31
88629: PUSH
88630: LD_INT 32
88632: PUSH
88633: LD_INT 33
88635: PUSH
88636: LD_INT 34
88638: PUSH
88639: LD_INT 36
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: LIST
88651: LIST
88652: LIST
88653: LIST
88654: LIST
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: LIST
88672: LIST
88673: LIST
88674: PUSH
88675: LD_INT 101
88677: PUSH
88678: LD_INT 102
88680: PUSH
88681: LD_INT 103
88683: PUSH
88684: LD_INT 104
88686: PUSH
88687: LD_INT 105
88689: PUSH
88690: LD_INT 106
88692: PUSH
88693: LD_INT 107
88695: PUSH
88696: LD_INT 108
88698: PUSH
88699: LD_INT 109
88701: PUSH
88702: LD_INT 110
88704: PUSH
88705: LD_INT 111
88707: PUSH
88708: LD_INT 112
88710: PUSH
88711: LD_INT 113
88713: PUSH
88714: LD_INT 114
88716: PUSH
88717: LD_INT 116
88719: PUSH
88720: LD_INT 117
88722: PUSH
88723: LD_INT 118
88725: PUSH
88726: EMPTY
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: PUSH
88745: EMPTY
88746: LIST
88747: LIST
88748: ST_TO_ADDR
88749: GO 89988
88751: LD_INT 14
88753: DOUBLE
88754: EQUAL
88755: IFTRUE 88759
88757: GO 88983
88759: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
88760: LD_ADDR_VAR 0 1
88764: PUSH
88765: LD_INT 1
88767: PUSH
88768: LD_INT 2
88770: PUSH
88771: LD_INT 3
88773: PUSH
88774: LD_INT 4
88776: PUSH
88777: LD_INT 5
88779: PUSH
88780: LD_INT 6
88782: PUSH
88783: LD_INT 7
88785: PUSH
88786: LD_INT 8
88788: PUSH
88789: LD_INT 9
88791: PUSH
88792: LD_INT 10
88794: PUSH
88795: LD_INT 11
88797: PUSH
88798: LD_INT 12
88800: PUSH
88801: LD_INT 13
88803: PUSH
88804: LD_INT 14
88806: PUSH
88807: LD_INT 15
88809: PUSH
88810: LD_INT 16
88812: PUSH
88813: LD_INT 17
88815: PUSH
88816: LD_INT 18
88818: PUSH
88819: LD_INT 19
88821: PUSH
88822: LD_INT 20
88824: PUSH
88825: LD_INT 21
88827: PUSH
88828: LD_INT 22
88830: PUSH
88831: LD_INT 23
88833: PUSH
88834: LD_INT 24
88836: PUSH
88837: LD_INT 25
88839: PUSH
88840: LD_INT 26
88842: PUSH
88843: LD_INT 27
88845: PUSH
88846: LD_INT 28
88848: PUSH
88849: LD_INT 29
88851: PUSH
88852: LD_INT 30
88854: PUSH
88855: LD_INT 31
88857: PUSH
88858: LD_INT 32
88860: PUSH
88861: LD_INT 33
88863: PUSH
88864: LD_INT 34
88866: PUSH
88867: LD_INT 36
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: LIST
88894: LIST
88895: LIST
88896: LIST
88897: LIST
88898: LIST
88899: LIST
88900: LIST
88901: LIST
88902: LIST
88903: LIST
88904: LIST
88905: LIST
88906: PUSH
88907: LD_INT 101
88909: PUSH
88910: LD_INT 102
88912: PUSH
88913: LD_INT 103
88915: PUSH
88916: LD_INT 104
88918: PUSH
88919: LD_INT 105
88921: PUSH
88922: LD_INT 106
88924: PUSH
88925: LD_INT 107
88927: PUSH
88928: LD_INT 108
88930: PUSH
88931: LD_INT 109
88933: PUSH
88934: LD_INT 110
88936: PUSH
88937: LD_INT 111
88939: PUSH
88940: LD_INT 112
88942: PUSH
88943: LD_INT 113
88945: PUSH
88946: LD_INT 114
88948: PUSH
88949: LD_INT 116
88951: PUSH
88952: LD_INT 117
88954: PUSH
88955: LD_INT 118
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: PUSH
88977: EMPTY
88978: LIST
88979: LIST
88980: ST_TO_ADDR
88981: GO 89988
88983: LD_INT 15
88985: DOUBLE
88986: EQUAL
88987: IFTRUE 88991
88989: GO 89215
88991: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
88992: LD_ADDR_VAR 0 1
88996: PUSH
88997: LD_INT 1
88999: PUSH
89000: LD_INT 2
89002: PUSH
89003: LD_INT 3
89005: PUSH
89006: LD_INT 4
89008: PUSH
89009: LD_INT 5
89011: PUSH
89012: LD_INT 6
89014: PUSH
89015: LD_INT 7
89017: PUSH
89018: LD_INT 8
89020: PUSH
89021: LD_INT 9
89023: PUSH
89024: LD_INT 10
89026: PUSH
89027: LD_INT 11
89029: PUSH
89030: LD_INT 12
89032: PUSH
89033: LD_INT 13
89035: PUSH
89036: LD_INT 14
89038: PUSH
89039: LD_INT 15
89041: PUSH
89042: LD_INT 16
89044: PUSH
89045: LD_INT 17
89047: PUSH
89048: LD_INT 18
89050: PUSH
89051: LD_INT 19
89053: PUSH
89054: LD_INT 20
89056: PUSH
89057: LD_INT 21
89059: PUSH
89060: LD_INT 22
89062: PUSH
89063: LD_INT 23
89065: PUSH
89066: LD_INT 24
89068: PUSH
89069: LD_INT 25
89071: PUSH
89072: LD_INT 26
89074: PUSH
89075: LD_INT 27
89077: PUSH
89078: LD_INT 28
89080: PUSH
89081: LD_INT 29
89083: PUSH
89084: LD_INT 30
89086: PUSH
89087: LD_INT 31
89089: PUSH
89090: LD_INT 32
89092: PUSH
89093: LD_INT 33
89095: PUSH
89096: LD_INT 34
89098: PUSH
89099: LD_INT 36
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: PUSH
89139: LD_INT 101
89141: PUSH
89142: LD_INT 102
89144: PUSH
89145: LD_INT 103
89147: PUSH
89148: LD_INT 104
89150: PUSH
89151: LD_INT 105
89153: PUSH
89154: LD_INT 106
89156: PUSH
89157: LD_INT 107
89159: PUSH
89160: LD_INT 108
89162: PUSH
89163: LD_INT 109
89165: PUSH
89166: LD_INT 110
89168: PUSH
89169: LD_INT 111
89171: PUSH
89172: LD_INT 112
89174: PUSH
89175: LD_INT 113
89177: PUSH
89178: LD_INT 114
89180: PUSH
89181: LD_INT 116
89183: PUSH
89184: LD_INT 117
89186: PUSH
89187: LD_INT 118
89189: PUSH
89190: EMPTY
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: LIST
89204: LIST
89205: LIST
89206: LIST
89207: LIST
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: ST_TO_ADDR
89213: GO 89988
89215: LD_INT 16
89217: DOUBLE
89218: EQUAL
89219: IFTRUE 89223
89221: GO 89359
89223: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89224: LD_ADDR_VAR 0 1
89228: PUSH
89229: LD_INT 2
89231: PUSH
89232: LD_INT 4
89234: PUSH
89235: LD_INT 5
89237: PUSH
89238: LD_INT 7
89240: PUSH
89241: LD_INT 11
89243: PUSH
89244: LD_INT 12
89246: PUSH
89247: LD_INT 15
89249: PUSH
89250: LD_INT 16
89252: PUSH
89253: LD_INT 20
89255: PUSH
89256: LD_INT 21
89258: PUSH
89259: LD_INT 22
89261: PUSH
89262: LD_INT 23
89264: PUSH
89265: LD_INT 25
89267: PUSH
89268: LD_INT 26
89270: PUSH
89271: LD_INT 30
89273: PUSH
89274: LD_INT 31
89276: PUSH
89277: LD_INT 32
89279: PUSH
89280: LD_INT 33
89282: PUSH
89283: LD_INT 34
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 101
89309: PUSH
89310: LD_INT 102
89312: PUSH
89313: LD_INT 103
89315: PUSH
89316: LD_INT 106
89318: PUSH
89319: LD_INT 108
89321: PUSH
89322: LD_INT 112
89324: PUSH
89325: LD_INT 113
89327: PUSH
89328: LD_INT 114
89330: PUSH
89331: LD_INT 116
89333: PUSH
89334: LD_INT 117
89336: PUSH
89337: LD_INT 118
89339: PUSH
89340: EMPTY
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: PUSH
89353: EMPTY
89354: LIST
89355: LIST
89356: ST_TO_ADDR
89357: GO 89988
89359: LD_INT 17
89361: DOUBLE
89362: EQUAL
89363: IFTRUE 89367
89365: GO 89591
89367: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
89368: LD_ADDR_VAR 0 1
89372: PUSH
89373: LD_INT 1
89375: PUSH
89376: LD_INT 2
89378: PUSH
89379: LD_INT 3
89381: PUSH
89382: LD_INT 4
89384: PUSH
89385: LD_INT 5
89387: PUSH
89388: LD_INT 6
89390: PUSH
89391: LD_INT 7
89393: PUSH
89394: LD_INT 8
89396: PUSH
89397: LD_INT 9
89399: PUSH
89400: LD_INT 10
89402: PUSH
89403: LD_INT 11
89405: PUSH
89406: LD_INT 12
89408: PUSH
89409: LD_INT 13
89411: PUSH
89412: LD_INT 14
89414: PUSH
89415: LD_INT 15
89417: PUSH
89418: LD_INT 16
89420: PUSH
89421: LD_INT 17
89423: PUSH
89424: LD_INT 18
89426: PUSH
89427: LD_INT 19
89429: PUSH
89430: LD_INT 20
89432: PUSH
89433: LD_INT 21
89435: PUSH
89436: LD_INT 22
89438: PUSH
89439: LD_INT 23
89441: PUSH
89442: LD_INT 24
89444: PUSH
89445: LD_INT 25
89447: PUSH
89448: LD_INT 26
89450: PUSH
89451: LD_INT 27
89453: PUSH
89454: LD_INT 28
89456: PUSH
89457: LD_INT 29
89459: PUSH
89460: LD_INT 30
89462: PUSH
89463: LD_INT 31
89465: PUSH
89466: LD_INT 32
89468: PUSH
89469: LD_INT 33
89471: PUSH
89472: LD_INT 34
89474: PUSH
89475: LD_INT 36
89477: PUSH
89478: EMPTY
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: PUSH
89515: LD_INT 101
89517: PUSH
89518: LD_INT 102
89520: PUSH
89521: LD_INT 103
89523: PUSH
89524: LD_INT 104
89526: PUSH
89527: LD_INT 105
89529: PUSH
89530: LD_INT 106
89532: PUSH
89533: LD_INT 107
89535: PUSH
89536: LD_INT 108
89538: PUSH
89539: LD_INT 109
89541: PUSH
89542: LD_INT 110
89544: PUSH
89545: LD_INT 111
89547: PUSH
89548: LD_INT 112
89550: PUSH
89551: LD_INT 113
89553: PUSH
89554: LD_INT 114
89556: PUSH
89557: LD_INT 116
89559: PUSH
89560: LD_INT 117
89562: PUSH
89563: LD_INT 118
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: ST_TO_ADDR
89589: GO 89988
89591: LD_INT 18
89593: DOUBLE
89594: EQUAL
89595: IFTRUE 89599
89597: GO 89747
89599: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
89600: LD_ADDR_VAR 0 1
89604: PUSH
89605: LD_INT 2
89607: PUSH
89608: LD_INT 4
89610: PUSH
89611: LD_INT 5
89613: PUSH
89614: LD_INT 7
89616: PUSH
89617: LD_INT 11
89619: PUSH
89620: LD_INT 12
89622: PUSH
89623: LD_INT 15
89625: PUSH
89626: LD_INT 16
89628: PUSH
89629: LD_INT 20
89631: PUSH
89632: LD_INT 21
89634: PUSH
89635: LD_INT 22
89637: PUSH
89638: LD_INT 23
89640: PUSH
89641: LD_INT 25
89643: PUSH
89644: LD_INT 26
89646: PUSH
89647: LD_INT 30
89649: PUSH
89650: LD_INT 31
89652: PUSH
89653: LD_INT 32
89655: PUSH
89656: LD_INT 33
89658: PUSH
89659: LD_INT 34
89661: PUSH
89662: LD_INT 35
89664: PUSH
89665: LD_INT 36
89667: PUSH
89668: EMPTY
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: LIST
89684: LIST
89685: LIST
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: PUSH
89691: LD_INT 101
89693: PUSH
89694: LD_INT 102
89696: PUSH
89697: LD_INT 103
89699: PUSH
89700: LD_INT 106
89702: PUSH
89703: LD_INT 108
89705: PUSH
89706: LD_INT 112
89708: PUSH
89709: LD_INT 113
89711: PUSH
89712: LD_INT 114
89714: PUSH
89715: LD_INT 115
89717: PUSH
89718: LD_INT 116
89720: PUSH
89721: LD_INT 117
89723: PUSH
89724: LD_INT 118
89726: PUSH
89727: EMPTY
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: LIST
89736: LIST
89737: LIST
89738: LIST
89739: LIST
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: ST_TO_ADDR
89745: GO 89988
89747: LD_INT 19
89749: DOUBLE
89750: EQUAL
89751: IFTRUE 89755
89753: GO 89987
89755: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
89756: LD_ADDR_VAR 0 1
89760: PUSH
89761: LD_INT 1
89763: PUSH
89764: LD_INT 2
89766: PUSH
89767: LD_INT 3
89769: PUSH
89770: LD_INT 4
89772: PUSH
89773: LD_INT 5
89775: PUSH
89776: LD_INT 6
89778: PUSH
89779: LD_INT 7
89781: PUSH
89782: LD_INT 8
89784: PUSH
89785: LD_INT 9
89787: PUSH
89788: LD_INT 10
89790: PUSH
89791: LD_INT 11
89793: PUSH
89794: LD_INT 12
89796: PUSH
89797: LD_INT 13
89799: PUSH
89800: LD_INT 14
89802: PUSH
89803: LD_INT 15
89805: PUSH
89806: LD_INT 16
89808: PUSH
89809: LD_INT 17
89811: PUSH
89812: LD_INT 18
89814: PUSH
89815: LD_INT 19
89817: PUSH
89818: LD_INT 20
89820: PUSH
89821: LD_INT 21
89823: PUSH
89824: LD_INT 22
89826: PUSH
89827: LD_INT 23
89829: PUSH
89830: LD_INT 24
89832: PUSH
89833: LD_INT 25
89835: PUSH
89836: LD_INT 26
89838: PUSH
89839: LD_INT 27
89841: PUSH
89842: LD_INT 28
89844: PUSH
89845: LD_INT 29
89847: PUSH
89848: LD_INT 30
89850: PUSH
89851: LD_INT 31
89853: PUSH
89854: LD_INT 32
89856: PUSH
89857: LD_INT 33
89859: PUSH
89860: LD_INT 34
89862: PUSH
89863: LD_INT 35
89865: PUSH
89866: LD_INT 36
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: LIST
89892: LIST
89893: LIST
89894: LIST
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: LIST
89905: LIST
89906: PUSH
89907: LD_INT 101
89909: PUSH
89910: LD_INT 102
89912: PUSH
89913: LD_INT 103
89915: PUSH
89916: LD_INT 104
89918: PUSH
89919: LD_INT 105
89921: PUSH
89922: LD_INT 106
89924: PUSH
89925: LD_INT 107
89927: PUSH
89928: LD_INT 108
89930: PUSH
89931: LD_INT 109
89933: PUSH
89934: LD_INT 110
89936: PUSH
89937: LD_INT 111
89939: PUSH
89940: LD_INT 112
89942: PUSH
89943: LD_INT 113
89945: PUSH
89946: LD_INT 114
89948: PUSH
89949: LD_INT 115
89951: PUSH
89952: LD_INT 116
89954: PUSH
89955: LD_INT 117
89957: PUSH
89958: LD_INT 118
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: ST_TO_ADDR
89985: GO 89988
89987: POP
// end else
89988: GO 90219
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
89990: LD_ADDR_VAR 0 1
89994: PUSH
89995: LD_INT 1
89997: PUSH
89998: LD_INT 2
90000: PUSH
90001: LD_INT 3
90003: PUSH
90004: LD_INT 4
90006: PUSH
90007: LD_INT 5
90009: PUSH
90010: LD_INT 6
90012: PUSH
90013: LD_INT 7
90015: PUSH
90016: LD_INT 8
90018: PUSH
90019: LD_INT 9
90021: PUSH
90022: LD_INT 10
90024: PUSH
90025: LD_INT 11
90027: PUSH
90028: LD_INT 12
90030: PUSH
90031: LD_INT 13
90033: PUSH
90034: LD_INT 14
90036: PUSH
90037: LD_INT 15
90039: PUSH
90040: LD_INT 16
90042: PUSH
90043: LD_INT 17
90045: PUSH
90046: LD_INT 18
90048: PUSH
90049: LD_INT 19
90051: PUSH
90052: LD_INT 20
90054: PUSH
90055: LD_INT 21
90057: PUSH
90058: LD_INT 22
90060: PUSH
90061: LD_INT 23
90063: PUSH
90064: LD_INT 24
90066: PUSH
90067: LD_INT 25
90069: PUSH
90070: LD_INT 26
90072: PUSH
90073: LD_INT 27
90075: PUSH
90076: LD_INT 28
90078: PUSH
90079: LD_INT 29
90081: PUSH
90082: LD_INT 30
90084: PUSH
90085: LD_INT 31
90087: PUSH
90088: LD_INT 32
90090: PUSH
90091: LD_INT 33
90093: PUSH
90094: LD_INT 34
90096: PUSH
90097: LD_INT 35
90099: PUSH
90100: LD_INT 36
90102: PUSH
90103: EMPTY
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: LIST
90110: LIST
90111: LIST
90112: LIST
90113: LIST
90114: LIST
90115: LIST
90116: LIST
90117: LIST
90118: LIST
90119: LIST
90120: LIST
90121: LIST
90122: LIST
90123: LIST
90124: LIST
90125: LIST
90126: LIST
90127: LIST
90128: LIST
90129: LIST
90130: LIST
90131: LIST
90132: LIST
90133: LIST
90134: LIST
90135: LIST
90136: LIST
90137: LIST
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 101
90143: PUSH
90144: LD_INT 102
90146: PUSH
90147: LD_INT 103
90149: PUSH
90150: LD_INT 104
90152: PUSH
90153: LD_INT 105
90155: PUSH
90156: LD_INT 106
90158: PUSH
90159: LD_INT 107
90161: PUSH
90162: LD_INT 108
90164: PUSH
90165: LD_INT 109
90167: PUSH
90168: LD_INT 110
90170: PUSH
90171: LD_INT 111
90173: PUSH
90174: LD_INT 112
90176: PUSH
90177: LD_INT 113
90179: PUSH
90180: LD_INT 114
90182: PUSH
90183: LD_INT 115
90185: PUSH
90186: LD_INT 116
90188: PUSH
90189: LD_INT 117
90191: PUSH
90192: LD_INT 118
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: ST_TO_ADDR
// if result then
90219: LD_VAR 0 1
90223: IFFALSE 90512
// begin normal :=  ;
90225: LD_ADDR_VAR 0 3
90229: PUSH
90230: LD_STRING 
90232: ST_TO_ADDR
// hardcore :=  ;
90233: LD_ADDR_VAR 0 4
90237: PUSH
90238: LD_STRING 
90240: ST_TO_ADDR
// for i = 1 to normalCounter do
90241: LD_ADDR_VAR 0 5
90245: PUSH
90246: DOUBLE
90247: LD_INT 1
90249: DEC
90250: ST_TO_ADDR
90251: LD_EXP 124
90255: PUSH
90256: FOR_TO
90257: IFFALSE 90358
// begin tmp := 0 ;
90259: LD_ADDR_VAR 0 2
90263: PUSH
90264: LD_STRING 0
90266: ST_TO_ADDR
// if result [ 1 ] then
90267: LD_VAR 0 1
90271: PUSH
90272: LD_INT 1
90274: ARRAY
90275: IFFALSE 90340
// if result [ 1 ] [ 1 ] = i then
90277: LD_VAR 0 1
90281: PUSH
90282: LD_INT 1
90284: ARRAY
90285: PUSH
90286: LD_INT 1
90288: ARRAY
90289: PUSH
90290: LD_VAR 0 5
90294: EQUAL
90295: IFFALSE 90340
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90297: LD_ADDR_VAR 0 1
90301: PUSH
90302: LD_VAR 0 1
90306: PPUSH
90307: LD_INT 1
90309: PPUSH
90310: LD_VAR 0 1
90314: PUSH
90315: LD_INT 1
90317: ARRAY
90318: PPUSH
90319: LD_INT 1
90321: PPUSH
90322: CALL_OW 3
90326: PPUSH
90327: CALL_OW 1
90331: ST_TO_ADDR
// tmp := 1 ;
90332: LD_ADDR_VAR 0 2
90336: PUSH
90337: LD_STRING 1
90339: ST_TO_ADDR
// end ; normal := normal & tmp ;
90340: LD_ADDR_VAR 0 3
90344: PUSH
90345: LD_VAR 0 3
90349: PUSH
90350: LD_VAR 0 2
90354: STR
90355: ST_TO_ADDR
// end ;
90356: GO 90256
90358: POP
90359: POP
// for i = 1 to hardcoreCounter do
90360: LD_ADDR_VAR 0 5
90364: PUSH
90365: DOUBLE
90366: LD_INT 1
90368: DEC
90369: ST_TO_ADDR
90370: LD_EXP 125
90374: PUSH
90375: FOR_TO
90376: IFFALSE 90481
// begin tmp := 0 ;
90378: LD_ADDR_VAR 0 2
90382: PUSH
90383: LD_STRING 0
90385: ST_TO_ADDR
// if result [ 2 ] then
90386: LD_VAR 0 1
90390: PUSH
90391: LD_INT 2
90393: ARRAY
90394: IFFALSE 90463
// if result [ 2 ] [ 1 ] = 100 + i then
90396: LD_VAR 0 1
90400: PUSH
90401: LD_INT 2
90403: ARRAY
90404: PUSH
90405: LD_INT 1
90407: ARRAY
90408: PUSH
90409: LD_INT 100
90411: PUSH
90412: LD_VAR 0 5
90416: PLUS
90417: EQUAL
90418: IFFALSE 90463
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90420: LD_ADDR_VAR 0 1
90424: PUSH
90425: LD_VAR 0 1
90429: PPUSH
90430: LD_INT 2
90432: PPUSH
90433: LD_VAR 0 1
90437: PUSH
90438: LD_INT 2
90440: ARRAY
90441: PPUSH
90442: LD_INT 1
90444: PPUSH
90445: CALL_OW 3
90449: PPUSH
90450: CALL_OW 1
90454: ST_TO_ADDR
// tmp := 1 ;
90455: LD_ADDR_VAR 0 2
90459: PUSH
90460: LD_STRING 1
90462: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90463: LD_ADDR_VAR 0 4
90467: PUSH
90468: LD_VAR 0 4
90472: PUSH
90473: LD_VAR 0 2
90477: STR
90478: ST_TO_ADDR
// end ;
90479: GO 90375
90481: POP
90482: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90483: LD_STRING getStreamItemsFromMission("
90485: PUSH
90486: LD_VAR 0 3
90490: STR
90491: PUSH
90492: LD_STRING ","
90494: STR
90495: PUSH
90496: LD_VAR 0 4
90500: STR
90501: PUSH
90502: LD_STRING ")
90504: STR
90505: PPUSH
90506: CALL_OW 559
// end else
90510: GO 90519
// ToLua ( getStreamItemsFromMission("","") ) ;
90512: LD_STRING getStreamItemsFromMission("","")
90514: PPUSH
90515: CALL_OW 559
// end ;
90519: LD_VAR 0 1
90523: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90524: LD_EXP 123
90528: PUSH
90529: LD_EXP 128
90533: AND
90534: IFFALSE 90658
90536: GO 90538
90538: DISABLE
90539: LD_INT 0
90541: PPUSH
90542: PPUSH
// begin enable ;
90543: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90544: LD_ADDR_VAR 0 2
90548: PUSH
90549: LD_INT 22
90551: PUSH
90552: LD_OWVAR 2
90556: PUSH
90557: EMPTY
90558: LIST
90559: LIST
90560: PUSH
90561: LD_INT 2
90563: PUSH
90564: LD_INT 34
90566: PUSH
90567: LD_INT 7
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 34
90576: PUSH
90577: LD_INT 45
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 34
90586: PUSH
90587: LD_INT 28
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 34
90596: PUSH
90597: LD_INT 47
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: PPUSH
90615: CALL_OW 69
90619: ST_TO_ADDR
// if not tmp then
90620: LD_VAR 0 2
90624: NOT
90625: IFFALSE 90629
// exit ;
90627: GO 90658
// for i in tmp do
90629: LD_ADDR_VAR 0 1
90633: PUSH
90634: LD_VAR 0 2
90638: PUSH
90639: FOR_IN
90640: IFFALSE 90656
// begin SetLives ( i , 0 ) ;
90642: LD_VAR 0 1
90646: PPUSH
90647: LD_INT 0
90649: PPUSH
90650: CALL_OW 234
// end ;
90654: GO 90639
90656: POP
90657: POP
// end ;
90658: PPOPN 2
90660: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90661: LD_EXP 123
90665: PUSH
90666: LD_EXP 129
90670: AND
90671: IFFALSE 90755
90673: GO 90675
90675: DISABLE
90676: LD_INT 0
90678: PPUSH
90679: PPUSH
// begin enable ;
90680: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90681: LD_ADDR_VAR 0 2
90685: PUSH
90686: LD_INT 22
90688: PUSH
90689: LD_OWVAR 2
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 32
90700: PUSH
90701: LD_INT 3
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: EMPTY
90709: LIST
90710: LIST
90711: PPUSH
90712: CALL_OW 69
90716: ST_TO_ADDR
// if not tmp then
90717: LD_VAR 0 2
90721: NOT
90722: IFFALSE 90726
// exit ;
90724: GO 90755
// for i in tmp do
90726: LD_ADDR_VAR 0 1
90730: PUSH
90731: LD_VAR 0 2
90735: PUSH
90736: FOR_IN
90737: IFFALSE 90753
// begin SetLives ( i , 0 ) ;
90739: LD_VAR 0 1
90743: PPUSH
90744: LD_INT 0
90746: PPUSH
90747: CALL_OW 234
// end ;
90751: GO 90736
90753: POP
90754: POP
// end ;
90755: PPOPN 2
90757: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90758: LD_EXP 123
90762: PUSH
90763: LD_EXP 126
90767: AND
90768: IFFALSE 90861
90770: GO 90772
90772: DISABLE
90773: LD_INT 0
90775: PPUSH
// begin enable ;
90776: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90777: LD_ADDR_VAR 0 1
90781: PUSH
90782: LD_INT 22
90784: PUSH
90785: LD_OWVAR 2
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 2
90796: PUSH
90797: LD_INT 25
90799: PUSH
90800: LD_INT 5
90802: PUSH
90803: EMPTY
90804: LIST
90805: LIST
90806: PUSH
90807: LD_INT 25
90809: PUSH
90810: LD_INT 9
90812: PUSH
90813: EMPTY
90814: LIST
90815: LIST
90816: PUSH
90817: LD_INT 25
90819: PUSH
90820: LD_INT 8
90822: PUSH
90823: EMPTY
90824: LIST
90825: LIST
90826: PUSH
90827: EMPTY
90828: LIST
90829: LIST
90830: LIST
90831: LIST
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PPUSH
90837: CALL_OW 69
90841: PUSH
90842: FOR_IN
90843: IFFALSE 90859
// begin SetClass ( i , 1 ) ;
90845: LD_VAR 0 1
90849: PPUSH
90850: LD_INT 1
90852: PPUSH
90853: CALL_OW 336
// end ;
90857: GO 90842
90859: POP
90860: POP
// end ;
90861: PPOPN 1
90863: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90864: LD_EXP 123
90868: PUSH
90869: LD_EXP 127
90873: AND
90874: PUSH
90875: LD_OWVAR 65
90879: PUSH
90880: LD_INT 7
90882: LESS
90883: AND
90884: IFFALSE 90898
90886: GO 90888
90888: DISABLE
// begin enable ;
90889: ENABLE
// game_speed := 7 ;
90890: LD_ADDR_OWVAR 65
90894: PUSH
90895: LD_INT 7
90897: ST_TO_ADDR
// end ;
90898: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90899: LD_EXP 123
90903: PUSH
90904: LD_EXP 130
90908: AND
90909: IFFALSE 91111
90911: GO 90913
90913: DISABLE
90914: LD_INT 0
90916: PPUSH
90917: PPUSH
90918: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90919: LD_ADDR_VAR 0 3
90923: PUSH
90924: LD_INT 81
90926: PUSH
90927: LD_OWVAR 2
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: PUSH
90936: LD_INT 21
90938: PUSH
90939: LD_INT 1
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: PPUSH
90950: CALL_OW 69
90954: ST_TO_ADDR
// if not tmp then
90955: LD_VAR 0 3
90959: NOT
90960: IFFALSE 90964
// exit ;
90962: GO 91111
// if tmp > 5 then
90964: LD_VAR 0 3
90968: PUSH
90969: LD_INT 5
90971: GREATER
90972: IFFALSE 90984
// k := 5 else
90974: LD_ADDR_VAR 0 2
90978: PUSH
90979: LD_INT 5
90981: ST_TO_ADDR
90982: GO 90994
// k := tmp ;
90984: LD_ADDR_VAR 0 2
90988: PUSH
90989: LD_VAR 0 3
90993: ST_TO_ADDR
// for i := 1 to k do
90994: LD_ADDR_VAR 0 1
90998: PUSH
90999: DOUBLE
91000: LD_INT 1
91002: DEC
91003: ST_TO_ADDR
91004: LD_VAR 0 2
91008: PUSH
91009: FOR_TO
91010: IFFALSE 91109
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
91012: LD_VAR 0 3
91016: PUSH
91017: LD_VAR 0 1
91021: ARRAY
91022: PPUSH
91023: LD_VAR 0 1
91027: PUSH
91028: LD_INT 4
91030: MOD
91031: PUSH
91032: LD_INT 1
91034: PLUS
91035: PPUSH
91036: CALL_OW 259
91040: PUSH
91041: LD_INT 10
91043: LESS
91044: IFFALSE 91107
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
91046: LD_VAR 0 3
91050: PUSH
91051: LD_VAR 0 1
91055: ARRAY
91056: PPUSH
91057: LD_VAR 0 1
91061: PUSH
91062: LD_INT 4
91064: MOD
91065: PUSH
91066: LD_INT 1
91068: PLUS
91069: PPUSH
91070: LD_VAR 0 3
91074: PUSH
91075: LD_VAR 0 1
91079: ARRAY
91080: PPUSH
91081: LD_VAR 0 1
91085: PUSH
91086: LD_INT 4
91088: MOD
91089: PUSH
91090: LD_INT 1
91092: PLUS
91093: PPUSH
91094: CALL_OW 259
91098: PUSH
91099: LD_INT 1
91101: PLUS
91102: PPUSH
91103: CALL_OW 237
91107: GO 91009
91109: POP
91110: POP
// end ;
91111: PPOPN 3
91113: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
91114: LD_EXP 123
91118: PUSH
91119: LD_EXP 131
91123: AND
91124: IFFALSE 91144
91126: GO 91128
91128: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
91129: LD_INT 4
91131: PPUSH
91132: LD_OWVAR 2
91136: PPUSH
91137: LD_INT 0
91139: PPUSH
91140: CALL_OW 324
91144: END
// every 0 0$1 trigger StreamModeActive and sShovel do
91145: LD_EXP 123
91149: PUSH
91150: LD_EXP 160
91154: AND
91155: IFFALSE 91175
91157: GO 91159
91159: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
91160: LD_INT 19
91162: PPUSH
91163: LD_OWVAR 2
91167: PPUSH
91168: LD_INT 0
91170: PPUSH
91171: CALL_OW 324
91175: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
91176: LD_EXP 123
91180: PUSH
91181: LD_EXP 132
91185: AND
91186: IFFALSE 91288
91188: GO 91190
91190: DISABLE
91191: LD_INT 0
91193: PPUSH
91194: PPUSH
// begin enable ;
91195: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
91196: LD_ADDR_VAR 0 2
91200: PUSH
91201: LD_INT 22
91203: PUSH
91204: LD_OWVAR 2
91208: PUSH
91209: EMPTY
91210: LIST
91211: LIST
91212: PUSH
91213: LD_INT 2
91215: PUSH
91216: LD_INT 34
91218: PUSH
91219: LD_INT 11
91221: PUSH
91222: EMPTY
91223: LIST
91224: LIST
91225: PUSH
91226: LD_INT 34
91228: PUSH
91229: LD_INT 30
91231: PUSH
91232: EMPTY
91233: LIST
91234: LIST
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: LIST
91240: PUSH
91241: EMPTY
91242: LIST
91243: LIST
91244: PPUSH
91245: CALL_OW 69
91249: ST_TO_ADDR
// if not tmp then
91250: LD_VAR 0 2
91254: NOT
91255: IFFALSE 91259
// exit ;
91257: GO 91288
// for i in tmp do
91259: LD_ADDR_VAR 0 1
91263: PUSH
91264: LD_VAR 0 2
91268: PUSH
91269: FOR_IN
91270: IFFALSE 91286
// begin SetLives ( i , 0 ) ;
91272: LD_VAR 0 1
91276: PPUSH
91277: LD_INT 0
91279: PPUSH
91280: CALL_OW 234
// end ;
91284: GO 91269
91286: POP
91287: POP
// end ;
91288: PPOPN 2
91290: END
// every 0 0$1 trigger StreamModeActive and sBunker do
91291: LD_EXP 123
91295: PUSH
91296: LD_EXP 133
91300: AND
91301: IFFALSE 91321
91303: GO 91305
91305: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
91306: LD_INT 32
91308: PPUSH
91309: LD_OWVAR 2
91313: PPUSH
91314: LD_INT 0
91316: PPUSH
91317: CALL_OW 324
91321: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
91322: LD_EXP 123
91326: PUSH
91327: LD_EXP 134
91331: AND
91332: IFFALSE 91513
91334: GO 91336
91336: DISABLE
91337: LD_INT 0
91339: PPUSH
91340: PPUSH
91341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
91342: LD_ADDR_VAR 0 2
91346: PUSH
91347: LD_INT 22
91349: PUSH
91350: LD_OWVAR 2
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: PUSH
91359: LD_INT 33
91361: PUSH
91362: LD_INT 3
91364: PUSH
91365: EMPTY
91366: LIST
91367: LIST
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PPUSH
91373: CALL_OW 69
91377: ST_TO_ADDR
// if not tmp then
91378: LD_VAR 0 2
91382: NOT
91383: IFFALSE 91387
// exit ;
91385: GO 91513
// side := 0 ;
91387: LD_ADDR_VAR 0 3
91391: PUSH
91392: LD_INT 0
91394: ST_TO_ADDR
// for i := 1 to 8 do
91395: LD_ADDR_VAR 0 1
91399: PUSH
91400: DOUBLE
91401: LD_INT 1
91403: DEC
91404: ST_TO_ADDR
91405: LD_INT 8
91407: PUSH
91408: FOR_TO
91409: IFFALSE 91457
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
91411: LD_OWVAR 2
91415: PUSH
91416: LD_VAR 0 1
91420: NONEQUAL
91421: PUSH
91422: LD_OWVAR 2
91426: PPUSH
91427: LD_VAR 0 1
91431: PPUSH
91432: CALL_OW 81
91436: PUSH
91437: LD_INT 2
91439: EQUAL
91440: AND
91441: IFFALSE 91455
// begin side := i ;
91443: LD_ADDR_VAR 0 3
91447: PUSH
91448: LD_VAR 0 1
91452: ST_TO_ADDR
// break ;
91453: GO 91457
// end ;
91455: GO 91408
91457: POP
91458: POP
// if not side then
91459: LD_VAR 0 3
91463: NOT
91464: IFFALSE 91468
// exit ;
91466: GO 91513
// for i := 1 to tmp do
91468: LD_ADDR_VAR 0 1
91472: PUSH
91473: DOUBLE
91474: LD_INT 1
91476: DEC
91477: ST_TO_ADDR
91478: LD_VAR 0 2
91482: PUSH
91483: FOR_TO
91484: IFFALSE 91511
// if Prob ( 60 ) then
91486: LD_INT 60
91488: PPUSH
91489: CALL_OW 13
91493: IFFALSE 91509
// SetSide ( i , side ) ;
91495: LD_VAR 0 1
91499: PPUSH
91500: LD_VAR 0 3
91504: PPUSH
91505: CALL_OW 235
91509: GO 91483
91511: POP
91512: POP
// end ;
91513: PPOPN 3
91515: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91516: LD_EXP 123
91520: PUSH
91521: LD_EXP 136
91525: AND
91526: IFFALSE 91645
91528: GO 91530
91530: DISABLE
91531: LD_INT 0
91533: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91534: LD_ADDR_VAR 0 1
91538: PUSH
91539: LD_INT 22
91541: PUSH
91542: LD_OWVAR 2
91546: PUSH
91547: EMPTY
91548: LIST
91549: LIST
91550: PUSH
91551: LD_INT 21
91553: PUSH
91554: LD_INT 1
91556: PUSH
91557: EMPTY
91558: LIST
91559: LIST
91560: PUSH
91561: LD_INT 3
91563: PUSH
91564: LD_INT 23
91566: PUSH
91567: LD_INT 0
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: EMPTY
91575: LIST
91576: LIST
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: LIST
91582: PPUSH
91583: CALL_OW 69
91587: PUSH
91588: FOR_IN
91589: IFFALSE 91643
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91591: LD_VAR 0 1
91595: PPUSH
91596: CALL_OW 257
91600: PUSH
91601: LD_INT 1
91603: PUSH
91604: LD_INT 2
91606: PUSH
91607: LD_INT 3
91609: PUSH
91610: LD_INT 4
91612: PUSH
91613: EMPTY
91614: LIST
91615: LIST
91616: LIST
91617: LIST
91618: IN
91619: IFFALSE 91641
// SetClass ( un , rand ( 1 , 4 ) ) ;
91621: LD_VAR 0 1
91625: PPUSH
91626: LD_INT 1
91628: PPUSH
91629: LD_INT 4
91631: PPUSH
91632: CALL_OW 12
91636: PPUSH
91637: CALL_OW 336
91641: GO 91588
91643: POP
91644: POP
// end ;
91645: PPOPN 1
91647: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91648: LD_EXP 123
91652: PUSH
91653: LD_EXP 135
91657: AND
91658: IFFALSE 91737
91660: GO 91662
91662: DISABLE
91663: LD_INT 0
91665: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91666: LD_ADDR_VAR 0 1
91670: PUSH
91671: LD_INT 22
91673: PUSH
91674: LD_OWVAR 2
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: LD_INT 21
91685: PUSH
91686: LD_INT 3
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: EMPTY
91694: LIST
91695: LIST
91696: PPUSH
91697: CALL_OW 69
91701: ST_TO_ADDR
// if not tmp then
91702: LD_VAR 0 1
91706: NOT
91707: IFFALSE 91711
// exit ;
91709: GO 91737
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91711: LD_VAR 0 1
91715: PUSH
91716: LD_INT 1
91718: PPUSH
91719: LD_VAR 0 1
91723: PPUSH
91724: CALL_OW 12
91728: ARRAY
91729: PPUSH
91730: LD_INT 100
91732: PPUSH
91733: CALL_OW 234
// end ;
91737: PPOPN 1
91739: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91740: LD_EXP 123
91744: PUSH
91745: LD_EXP 137
91749: AND
91750: IFFALSE 91848
91752: GO 91754
91754: DISABLE
91755: LD_INT 0
91757: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91758: LD_ADDR_VAR 0 1
91762: PUSH
91763: LD_INT 22
91765: PUSH
91766: LD_OWVAR 2
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 21
91777: PUSH
91778: LD_INT 1
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PPUSH
91789: CALL_OW 69
91793: ST_TO_ADDR
// if not tmp then
91794: LD_VAR 0 1
91798: NOT
91799: IFFALSE 91803
// exit ;
91801: GO 91848
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91803: LD_VAR 0 1
91807: PUSH
91808: LD_INT 1
91810: PPUSH
91811: LD_VAR 0 1
91815: PPUSH
91816: CALL_OW 12
91820: ARRAY
91821: PPUSH
91822: LD_INT 1
91824: PPUSH
91825: LD_INT 4
91827: PPUSH
91828: CALL_OW 12
91832: PPUSH
91833: LD_INT 3000
91835: PPUSH
91836: LD_INT 9000
91838: PPUSH
91839: CALL_OW 12
91843: PPUSH
91844: CALL_OW 492
// end ;
91848: PPOPN 1
91850: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91851: LD_EXP 123
91855: PUSH
91856: LD_EXP 138
91860: AND
91861: IFFALSE 91881
91863: GO 91865
91865: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91866: LD_INT 1
91868: PPUSH
91869: LD_OWVAR 2
91873: PPUSH
91874: LD_INT 0
91876: PPUSH
91877: CALL_OW 324
91881: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91882: LD_EXP 123
91886: PUSH
91887: LD_EXP 139
91891: AND
91892: IFFALSE 91975
91894: GO 91896
91896: DISABLE
91897: LD_INT 0
91899: PPUSH
91900: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91901: LD_ADDR_VAR 0 2
91905: PUSH
91906: LD_INT 22
91908: PUSH
91909: LD_OWVAR 2
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 21
91920: PUSH
91921: LD_INT 3
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: PPUSH
91932: CALL_OW 69
91936: ST_TO_ADDR
// if not tmp then
91937: LD_VAR 0 2
91941: NOT
91942: IFFALSE 91946
// exit ;
91944: GO 91975
// for i in tmp do
91946: LD_ADDR_VAR 0 1
91950: PUSH
91951: LD_VAR 0 2
91955: PUSH
91956: FOR_IN
91957: IFFALSE 91973
// SetBLevel ( i , 10 ) ;
91959: LD_VAR 0 1
91963: PPUSH
91964: LD_INT 10
91966: PPUSH
91967: CALL_OW 241
91971: GO 91956
91973: POP
91974: POP
// end ;
91975: PPOPN 2
91977: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91978: LD_EXP 123
91982: PUSH
91983: LD_EXP 140
91987: AND
91988: IFFALSE 92099
91990: GO 91992
91992: DISABLE
91993: LD_INT 0
91995: PPUSH
91996: PPUSH
91997: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91998: LD_ADDR_VAR 0 3
92002: PUSH
92003: LD_INT 22
92005: PUSH
92006: LD_OWVAR 2
92010: PUSH
92011: EMPTY
92012: LIST
92013: LIST
92014: PUSH
92015: LD_INT 25
92017: PUSH
92018: LD_INT 1
92020: PUSH
92021: EMPTY
92022: LIST
92023: LIST
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PPUSH
92029: CALL_OW 69
92033: ST_TO_ADDR
// if not tmp then
92034: LD_VAR 0 3
92038: NOT
92039: IFFALSE 92043
// exit ;
92041: GO 92099
// un := tmp [ rand ( 1 , tmp ) ] ;
92043: LD_ADDR_VAR 0 2
92047: PUSH
92048: LD_VAR 0 3
92052: PUSH
92053: LD_INT 1
92055: PPUSH
92056: LD_VAR 0 3
92060: PPUSH
92061: CALL_OW 12
92065: ARRAY
92066: ST_TO_ADDR
// if Crawls ( un ) then
92067: LD_VAR 0 2
92071: PPUSH
92072: CALL_OW 318
92076: IFFALSE 92087
// ComWalk ( un ) ;
92078: LD_VAR 0 2
92082: PPUSH
92083: CALL_OW 138
// SetClass ( un , class_sniper ) ;
92087: LD_VAR 0 2
92091: PPUSH
92092: LD_INT 5
92094: PPUSH
92095: CALL_OW 336
// end ;
92099: PPOPN 3
92101: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
92102: LD_EXP 123
92106: PUSH
92107: LD_EXP 141
92111: AND
92112: PUSH
92113: LD_OWVAR 67
92117: PUSH
92118: LD_INT 4
92120: LESS
92121: AND
92122: IFFALSE 92141
92124: GO 92126
92126: DISABLE
// begin Difficulty := Difficulty + 1 ;
92127: LD_ADDR_OWVAR 67
92131: PUSH
92132: LD_OWVAR 67
92136: PUSH
92137: LD_INT 1
92139: PLUS
92140: ST_TO_ADDR
// end ;
92141: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
92142: LD_EXP 123
92146: PUSH
92147: LD_EXP 142
92151: AND
92152: IFFALSE 92255
92154: GO 92156
92156: DISABLE
92157: LD_INT 0
92159: PPUSH
// begin for i := 1 to 5 do
92160: LD_ADDR_VAR 0 1
92164: PUSH
92165: DOUBLE
92166: LD_INT 1
92168: DEC
92169: ST_TO_ADDR
92170: LD_INT 5
92172: PUSH
92173: FOR_TO
92174: IFFALSE 92253
// begin uc_nation := nation_nature ;
92176: LD_ADDR_OWVAR 21
92180: PUSH
92181: LD_INT 0
92183: ST_TO_ADDR
// uc_side := 0 ;
92184: LD_ADDR_OWVAR 20
92188: PUSH
92189: LD_INT 0
92191: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92192: LD_ADDR_OWVAR 29
92196: PUSH
92197: LD_INT 12
92199: PUSH
92200: LD_INT 12
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: ST_TO_ADDR
// hc_agressivity := 20 ;
92207: LD_ADDR_OWVAR 35
92211: PUSH
92212: LD_INT 20
92214: ST_TO_ADDR
// hc_class := class_tiger ;
92215: LD_ADDR_OWVAR 28
92219: PUSH
92220: LD_INT 14
92222: ST_TO_ADDR
// hc_gallery :=  ;
92223: LD_ADDR_OWVAR 33
92227: PUSH
92228: LD_STRING 
92230: ST_TO_ADDR
// hc_name :=  ;
92231: LD_ADDR_OWVAR 26
92235: PUSH
92236: LD_STRING 
92238: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
92239: CALL_OW 44
92243: PPUSH
92244: LD_INT 0
92246: PPUSH
92247: CALL_OW 51
// end ;
92251: GO 92173
92253: POP
92254: POP
// end ;
92255: PPOPN 1
92257: END
// every 0 0$1 trigger StreamModeActive and sBomb do
92258: LD_EXP 123
92262: PUSH
92263: LD_EXP 143
92267: AND
92268: IFFALSE 92277
92270: GO 92272
92272: DISABLE
// StreamSibBomb ;
92273: CALL 92278 0 0
92277: END
// export function StreamSibBomb ; var i , x , y ; begin
92278: LD_INT 0
92280: PPUSH
92281: PPUSH
92282: PPUSH
92283: PPUSH
// result := false ;
92284: LD_ADDR_VAR 0 1
92288: PUSH
92289: LD_INT 0
92291: ST_TO_ADDR
// for i := 1 to 16 do
92292: LD_ADDR_VAR 0 2
92296: PUSH
92297: DOUBLE
92298: LD_INT 1
92300: DEC
92301: ST_TO_ADDR
92302: LD_INT 16
92304: PUSH
92305: FOR_TO
92306: IFFALSE 92505
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92308: LD_ADDR_VAR 0 3
92312: PUSH
92313: LD_INT 10
92315: PUSH
92316: LD_INT 20
92318: PUSH
92319: LD_INT 30
92321: PUSH
92322: LD_INT 40
92324: PUSH
92325: LD_INT 50
92327: PUSH
92328: LD_INT 60
92330: PUSH
92331: LD_INT 70
92333: PUSH
92334: LD_INT 80
92336: PUSH
92337: LD_INT 90
92339: PUSH
92340: LD_INT 100
92342: PUSH
92343: LD_INT 110
92345: PUSH
92346: LD_INT 120
92348: PUSH
92349: LD_INT 130
92351: PUSH
92352: LD_INT 140
92354: PUSH
92355: LD_INT 150
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: LIST
92374: PUSH
92375: LD_INT 1
92377: PPUSH
92378: LD_INT 15
92380: PPUSH
92381: CALL_OW 12
92385: ARRAY
92386: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
92387: LD_ADDR_VAR 0 4
92391: PUSH
92392: LD_INT 10
92394: PUSH
92395: LD_INT 20
92397: PUSH
92398: LD_INT 30
92400: PUSH
92401: LD_INT 40
92403: PUSH
92404: LD_INT 50
92406: PUSH
92407: LD_INT 60
92409: PUSH
92410: LD_INT 70
92412: PUSH
92413: LD_INT 80
92415: PUSH
92416: LD_INT 90
92418: PUSH
92419: LD_INT 100
92421: PUSH
92422: LD_INT 110
92424: PUSH
92425: LD_INT 120
92427: PUSH
92428: LD_INT 130
92430: PUSH
92431: LD_INT 140
92433: PUSH
92434: LD_INT 150
92436: PUSH
92437: EMPTY
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 1
92456: PPUSH
92457: LD_INT 15
92459: PPUSH
92460: CALL_OW 12
92464: ARRAY
92465: ST_TO_ADDR
// if ValidHex ( x , y ) then
92466: LD_VAR 0 3
92470: PPUSH
92471: LD_VAR 0 4
92475: PPUSH
92476: CALL_OW 488
92480: IFFALSE 92503
// begin result := [ x , y ] ;
92482: LD_ADDR_VAR 0 1
92486: PUSH
92487: LD_VAR 0 3
92491: PUSH
92492: LD_VAR 0 4
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: ST_TO_ADDR
// break ;
92501: GO 92505
// end ; end ;
92503: GO 92305
92505: POP
92506: POP
// if result then
92507: LD_VAR 0 1
92511: IFFALSE 92571
// begin ToLua ( playSibBomb() ) ;
92513: LD_STRING playSibBomb()
92515: PPUSH
92516: CALL_OW 559
// wait ( 0 0$14 ) ;
92520: LD_INT 490
92522: PPUSH
92523: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92527: LD_VAR 0 1
92531: PUSH
92532: LD_INT 1
92534: ARRAY
92535: PPUSH
92536: LD_VAR 0 1
92540: PUSH
92541: LD_INT 2
92543: ARRAY
92544: PPUSH
92545: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92549: LD_VAR 0 1
92553: PUSH
92554: LD_INT 1
92556: ARRAY
92557: PPUSH
92558: LD_VAR 0 1
92562: PUSH
92563: LD_INT 2
92565: ARRAY
92566: PPUSH
92567: CALL_OW 429
// end ; end ;
92571: LD_VAR 0 1
92575: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92576: LD_EXP 123
92580: PUSH
92581: LD_EXP 145
92585: AND
92586: IFFALSE 92598
92588: GO 92590
92590: DISABLE
// YouLost (  ) ;
92591: LD_STRING 
92593: PPUSH
92594: CALL_OW 104
92598: END
// every 0 0$1 trigger StreamModeActive and sFog do
92599: LD_EXP 123
92603: PUSH
92604: LD_EXP 144
92608: AND
92609: IFFALSE 92623
92611: GO 92613
92613: DISABLE
// FogOff ( your_side ) ;
92614: LD_OWVAR 2
92618: PPUSH
92619: CALL_OW 344
92623: END
// every 0 0$1 trigger StreamModeActive and sSun do
92624: LD_EXP 123
92628: PUSH
92629: LD_EXP 146
92633: AND
92634: IFFALSE 92662
92636: GO 92638
92638: DISABLE
// begin solar_recharge_percent := 0 ;
92639: LD_ADDR_OWVAR 79
92643: PUSH
92644: LD_INT 0
92646: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92647: LD_INT 10500
92649: PPUSH
92650: CALL_OW 67
// solar_recharge_percent := 100 ;
92654: LD_ADDR_OWVAR 79
92658: PUSH
92659: LD_INT 100
92661: ST_TO_ADDR
// end ;
92662: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92663: LD_EXP 123
92667: PUSH
92668: LD_EXP 147
92672: AND
92673: IFFALSE 92912
92675: GO 92677
92677: DISABLE
92678: LD_INT 0
92680: PPUSH
92681: PPUSH
92682: PPUSH
// begin tmp := [ ] ;
92683: LD_ADDR_VAR 0 3
92687: PUSH
92688: EMPTY
92689: ST_TO_ADDR
// for i := 1 to 6 do
92690: LD_ADDR_VAR 0 1
92694: PUSH
92695: DOUBLE
92696: LD_INT 1
92698: DEC
92699: ST_TO_ADDR
92700: LD_INT 6
92702: PUSH
92703: FOR_TO
92704: IFFALSE 92809
// begin uc_nation := nation_nature ;
92706: LD_ADDR_OWVAR 21
92710: PUSH
92711: LD_INT 0
92713: ST_TO_ADDR
// uc_side := 0 ;
92714: LD_ADDR_OWVAR 20
92718: PUSH
92719: LD_INT 0
92721: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92722: LD_ADDR_OWVAR 29
92726: PUSH
92727: LD_INT 12
92729: PUSH
92730: LD_INT 12
92732: PUSH
92733: EMPTY
92734: LIST
92735: LIST
92736: ST_TO_ADDR
// hc_agressivity := 20 ;
92737: LD_ADDR_OWVAR 35
92741: PUSH
92742: LD_INT 20
92744: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92745: LD_ADDR_OWVAR 28
92749: PUSH
92750: LD_INT 17
92752: ST_TO_ADDR
// hc_gallery :=  ;
92753: LD_ADDR_OWVAR 33
92757: PUSH
92758: LD_STRING 
92760: ST_TO_ADDR
// hc_name :=  ;
92761: LD_ADDR_OWVAR 26
92765: PUSH
92766: LD_STRING 
92768: ST_TO_ADDR
// un := CreateHuman ;
92769: LD_ADDR_VAR 0 2
92773: PUSH
92774: CALL_OW 44
92778: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92779: LD_VAR 0 2
92783: PPUSH
92784: LD_INT 1
92786: PPUSH
92787: CALL_OW 51
// tmp := tmp ^ un ;
92791: LD_ADDR_VAR 0 3
92795: PUSH
92796: LD_VAR 0 3
92800: PUSH
92801: LD_VAR 0 2
92805: ADD
92806: ST_TO_ADDR
// end ;
92807: GO 92703
92809: POP
92810: POP
// repeat wait ( 0 0$1 ) ;
92811: LD_INT 35
92813: PPUSH
92814: CALL_OW 67
// for un in tmp do
92818: LD_ADDR_VAR 0 2
92822: PUSH
92823: LD_VAR 0 3
92827: PUSH
92828: FOR_IN
92829: IFFALSE 92903
// begin if IsDead ( un ) then
92831: LD_VAR 0 2
92835: PPUSH
92836: CALL_OW 301
92840: IFFALSE 92860
// begin tmp := tmp diff un ;
92842: LD_ADDR_VAR 0 3
92846: PUSH
92847: LD_VAR 0 3
92851: PUSH
92852: LD_VAR 0 2
92856: DIFF
92857: ST_TO_ADDR
// continue ;
92858: GO 92828
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92860: LD_VAR 0 2
92864: PPUSH
92865: LD_INT 3
92867: PUSH
92868: LD_INT 22
92870: PUSH
92871: LD_INT 0
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: EMPTY
92879: LIST
92880: LIST
92881: PPUSH
92882: CALL_OW 69
92886: PPUSH
92887: LD_VAR 0 2
92891: PPUSH
92892: CALL_OW 74
92896: PPUSH
92897: CALL_OW 115
// end ;
92901: GO 92828
92903: POP
92904: POP
// until not tmp ;
92905: LD_VAR 0 3
92909: NOT
92910: IFFALSE 92811
// end ;
92912: PPOPN 3
92914: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92915: LD_EXP 123
92919: PUSH
92920: LD_EXP 148
92924: AND
92925: IFFALSE 92979
92927: GO 92929
92929: DISABLE
// begin ToLua ( displayTroll(); ) ;
92930: LD_STRING displayTroll();
92932: PPUSH
92933: CALL_OW 559
// wait ( 3 3$00 ) ;
92937: LD_INT 6300
92939: PPUSH
92940: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92944: LD_STRING hideTroll();
92946: PPUSH
92947: CALL_OW 559
// wait ( 1 1$00 ) ;
92951: LD_INT 2100
92953: PPUSH
92954: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92958: LD_STRING displayTroll();
92960: PPUSH
92961: CALL_OW 559
// wait ( 1 1$00 ) ;
92965: LD_INT 2100
92967: PPUSH
92968: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92972: LD_STRING hideTroll();
92974: PPUSH
92975: CALL_OW 559
// end ;
92979: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92980: LD_EXP 123
92984: PUSH
92985: LD_EXP 149
92989: AND
92990: IFFALSE 93053
92992: GO 92994
92994: DISABLE
92995: LD_INT 0
92997: PPUSH
// begin p := 0 ;
92998: LD_ADDR_VAR 0 1
93002: PUSH
93003: LD_INT 0
93005: ST_TO_ADDR
// repeat game_speed := 1 ;
93006: LD_ADDR_OWVAR 65
93010: PUSH
93011: LD_INT 1
93013: ST_TO_ADDR
// wait ( 0 0$1 ) ;
93014: LD_INT 35
93016: PPUSH
93017: CALL_OW 67
// p := p + 1 ;
93021: LD_ADDR_VAR 0 1
93025: PUSH
93026: LD_VAR 0 1
93030: PUSH
93031: LD_INT 1
93033: PLUS
93034: ST_TO_ADDR
// until p >= 60 ;
93035: LD_VAR 0 1
93039: PUSH
93040: LD_INT 60
93042: GREATEREQUAL
93043: IFFALSE 93006
// game_speed := 4 ;
93045: LD_ADDR_OWVAR 65
93049: PUSH
93050: LD_INT 4
93052: ST_TO_ADDR
// end ;
93053: PPOPN 1
93055: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
93056: LD_EXP 123
93060: PUSH
93061: LD_EXP 150
93065: AND
93066: IFFALSE 93212
93068: GO 93070
93070: DISABLE
93071: LD_INT 0
93073: PPUSH
93074: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93075: LD_ADDR_VAR 0 1
93079: PUSH
93080: LD_INT 22
93082: PUSH
93083: LD_OWVAR 2
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PUSH
93092: LD_INT 2
93094: PUSH
93095: LD_INT 30
93097: PUSH
93098: LD_INT 0
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: LD_INT 30
93107: PUSH
93108: LD_INT 1
93110: PUSH
93111: EMPTY
93112: LIST
93113: LIST
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: LIST
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PPUSH
93124: CALL_OW 69
93128: ST_TO_ADDR
// if not depot then
93129: LD_VAR 0 1
93133: NOT
93134: IFFALSE 93138
// exit ;
93136: GO 93212
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
93138: LD_ADDR_VAR 0 2
93142: PUSH
93143: LD_VAR 0 1
93147: PUSH
93148: LD_INT 1
93150: PPUSH
93151: LD_VAR 0 1
93155: PPUSH
93156: CALL_OW 12
93160: ARRAY
93161: PPUSH
93162: CALL_OW 274
93166: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
93167: LD_VAR 0 2
93171: PPUSH
93172: LD_INT 1
93174: PPUSH
93175: LD_INT 0
93177: PPUSH
93178: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
93182: LD_VAR 0 2
93186: PPUSH
93187: LD_INT 2
93189: PPUSH
93190: LD_INT 0
93192: PPUSH
93193: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
93197: LD_VAR 0 2
93201: PPUSH
93202: LD_INT 3
93204: PPUSH
93205: LD_INT 0
93207: PPUSH
93208: CALL_OW 277
// end ;
93212: PPOPN 2
93214: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
93215: LD_EXP 123
93219: PUSH
93220: LD_EXP 151
93224: AND
93225: IFFALSE 93322
93227: GO 93229
93229: DISABLE
93230: LD_INT 0
93232: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93233: LD_ADDR_VAR 0 1
93237: PUSH
93238: LD_INT 22
93240: PUSH
93241: LD_OWVAR 2
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 21
93252: PUSH
93253: LD_INT 1
93255: PUSH
93256: EMPTY
93257: LIST
93258: LIST
93259: PUSH
93260: LD_INT 3
93262: PUSH
93263: LD_INT 23
93265: PUSH
93266: LD_INT 0
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: PPUSH
93282: CALL_OW 69
93286: ST_TO_ADDR
// if not tmp then
93287: LD_VAR 0 1
93291: NOT
93292: IFFALSE 93296
// exit ;
93294: GO 93322
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
93296: LD_VAR 0 1
93300: PUSH
93301: LD_INT 1
93303: PPUSH
93304: LD_VAR 0 1
93308: PPUSH
93309: CALL_OW 12
93313: ARRAY
93314: PPUSH
93315: LD_INT 200
93317: PPUSH
93318: CALL_OW 234
// end ;
93322: PPOPN 1
93324: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
93325: LD_EXP 123
93329: PUSH
93330: LD_EXP 152
93334: AND
93335: IFFALSE 93414
93337: GO 93339
93339: DISABLE
93340: LD_INT 0
93342: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
93343: LD_ADDR_VAR 0 1
93347: PUSH
93348: LD_INT 22
93350: PUSH
93351: LD_OWVAR 2
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: LD_INT 21
93362: PUSH
93363: LD_INT 2
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: EMPTY
93371: LIST
93372: LIST
93373: PPUSH
93374: CALL_OW 69
93378: ST_TO_ADDR
// if not tmp then
93379: LD_VAR 0 1
93383: NOT
93384: IFFALSE 93388
// exit ;
93386: GO 93414
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
93388: LD_VAR 0 1
93392: PUSH
93393: LD_INT 1
93395: PPUSH
93396: LD_VAR 0 1
93400: PPUSH
93401: CALL_OW 12
93405: ARRAY
93406: PPUSH
93407: LD_INT 60
93409: PPUSH
93410: CALL_OW 234
// end ;
93414: PPOPN 1
93416: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93417: LD_EXP 123
93421: PUSH
93422: LD_EXP 153
93426: AND
93427: IFFALSE 93526
93429: GO 93431
93431: DISABLE
93432: LD_INT 0
93434: PPUSH
93435: PPUSH
// begin enable ;
93436: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93437: LD_ADDR_VAR 0 1
93441: PUSH
93442: LD_INT 22
93444: PUSH
93445: LD_OWVAR 2
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 61
93456: PUSH
93457: EMPTY
93458: LIST
93459: PUSH
93460: LD_INT 33
93462: PUSH
93463: LD_INT 2
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: EMPTY
93471: LIST
93472: LIST
93473: LIST
93474: PPUSH
93475: CALL_OW 69
93479: ST_TO_ADDR
// if not tmp then
93480: LD_VAR 0 1
93484: NOT
93485: IFFALSE 93489
// exit ;
93487: GO 93526
// for i in tmp do
93489: LD_ADDR_VAR 0 2
93493: PUSH
93494: LD_VAR 0 1
93498: PUSH
93499: FOR_IN
93500: IFFALSE 93524
// if IsControledBy ( i ) then
93502: LD_VAR 0 2
93506: PPUSH
93507: CALL_OW 312
93511: IFFALSE 93522
// ComUnlink ( i ) ;
93513: LD_VAR 0 2
93517: PPUSH
93518: CALL_OW 136
93522: GO 93499
93524: POP
93525: POP
// end ;
93526: PPOPN 2
93528: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93529: LD_EXP 123
93533: PUSH
93534: LD_EXP 154
93538: AND
93539: IFFALSE 93679
93541: GO 93543
93543: DISABLE
93544: LD_INT 0
93546: PPUSH
93547: PPUSH
// begin ToLua ( displayPowell(); ) ;
93548: LD_STRING displayPowell();
93550: PPUSH
93551: CALL_OW 559
// uc_side := 0 ;
93555: LD_ADDR_OWVAR 20
93559: PUSH
93560: LD_INT 0
93562: ST_TO_ADDR
// uc_nation := 2 ;
93563: LD_ADDR_OWVAR 21
93567: PUSH
93568: LD_INT 2
93570: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93571: LD_ADDR_OWVAR 37
93575: PUSH
93576: LD_INT 14
93578: ST_TO_ADDR
// vc_engine := engine_siberite ;
93579: LD_ADDR_OWVAR 39
93583: PUSH
93584: LD_INT 3
93586: ST_TO_ADDR
// vc_control := control_apeman ;
93587: LD_ADDR_OWVAR 38
93591: PUSH
93592: LD_INT 5
93594: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93595: LD_ADDR_OWVAR 40
93599: PUSH
93600: LD_INT 29
93602: ST_TO_ADDR
// un := CreateVehicle ;
93603: LD_ADDR_VAR 0 2
93607: PUSH
93608: CALL_OW 45
93612: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93613: LD_VAR 0 2
93617: PPUSH
93618: LD_INT 1
93620: PPUSH
93621: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93625: LD_INT 35
93627: PPUSH
93628: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93632: LD_VAR 0 2
93636: PPUSH
93637: LD_INT 22
93639: PUSH
93640: LD_OWVAR 2
93644: PUSH
93645: EMPTY
93646: LIST
93647: LIST
93648: PPUSH
93649: CALL_OW 69
93653: PPUSH
93654: LD_VAR 0 2
93658: PPUSH
93659: CALL_OW 74
93663: PPUSH
93664: CALL_OW 115
// until IsDead ( un ) ;
93668: LD_VAR 0 2
93672: PPUSH
93673: CALL_OW 301
93677: IFFALSE 93625
// end ;
93679: PPOPN 2
93681: END
// every 0 0$1 trigger StreamModeActive and sStu do
93682: LD_EXP 123
93686: PUSH
93687: LD_EXP 162
93691: AND
93692: IFFALSE 93708
93694: GO 93696
93696: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93697: LD_STRING displayStucuk();
93699: PPUSH
93700: CALL_OW 559
// ResetFog ;
93704: CALL_OW 335
// end ;
93708: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93709: LD_EXP 123
93713: PUSH
93714: LD_EXP 155
93718: AND
93719: IFFALSE 93860
93721: GO 93723
93723: DISABLE
93724: LD_INT 0
93726: PPUSH
93727: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93728: LD_ADDR_VAR 0 2
93732: PUSH
93733: LD_INT 22
93735: PUSH
93736: LD_OWVAR 2
93740: PUSH
93741: EMPTY
93742: LIST
93743: LIST
93744: PUSH
93745: LD_INT 21
93747: PUSH
93748: LD_INT 1
93750: PUSH
93751: EMPTY
93752: LIST
93753: LIST
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PPUSH
93759: CALL_OW 69
93763: ST_TO_ADDR
// if not tmp then
93764: LD_VAR 0 2
93768: NOT
93769: IFFALSE 93773
// exit ;
93771: GO 93860
// un := tmp [ rand ( 1 , tmp ) ] ;
93773: LD_ADDR_VAR 0 1
93777: PUSH
93778: LD_VAR 0 2
93782: PUSH
93783: LD_INT 1
93785: PPUSH
93786: LD_VAR 0 2
93790: PPUSH
93791: CALL_OW 12
93795: ARRAY
93796: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93797: LD_VAR 0 1
93801: PPUSH
93802: LD_INT 0
93804: PPUSH
93805: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93809: LD_VAR 0 1
93813: PPUSH
93814: LD_OWVAR 3
93818: PUSH
93819: LD_VAR 0 1
93823: DIFF
93824: PPUSH
93825: LD_VAR 0 1
93829: PPUSH
93830: CALL_OW 74
93834: PPUSH
93835: CALL_OW 115
// wait ( 0 0$20 ) ;
93839: LD_INT 700
93841: PPUSH
93842: CALL_OW 67
// SetSide ( un , your_side ) ;
93846: LD_VAR 0 1
93850: PPUSH
93851: LD_OWVAR 2
93855: PPUSH
93856: CALL_OW 235
// end ;
93860: PPOPN 2
93862: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93863: LD_EXP 123
93867: PUSH
93868: LD_EXP 156
93872: AND
93873: IFFALSE 93979
93875: GO 93877
93877: DISABLE
93878: LD_INT 0
93880: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93881: LD_ADDR_VAR 0 1
93885: PUSH
93886: LD_INT 22
93888: PUSH
93889: LD_OWVAR 2
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: PUSH
93898: LD_INT 2
93900: PUSH
93901: LD_INT 30
93903: PUSH
93904: LD_INT 0
93906: PUSH
93907: EMPTY
93908: LIST
93909: LIST
93910: PUSH
93911: LD_INT 30
93913: PUSH
93914: LD_INT 1
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: EMPTY
93922: LIST
93923: LIST
93924: LIST
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PPUSH
93930: CALL_OW 69
93934: ST_TO_ADDR
// if not depot then
93935: LD_VAR 0 1
93939: NOT
93940: IFFALSE 93944
// exit ;
93942: GO 93979
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93944: LD_VAR 0 1
93948: PUSH
93949: LD_INT 1
93951: ARRAY
93952: PPUSH
93953: CALL_OW 250
93957: PPUSH
93958: LD_VAR 0 1
93962: PUSH
93963: LD_INT 1
93965: ARRAY
93966: PPUSH
93967: CALL_OW 251
93971: PPUSH
93972: LD_INT 70
93974: PPUSH
93975: CALL_OW 495
// end ;
93979: PPOPN 1
93981: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93982: LD_EXP 123
93986: PUSH
93987: LD_EXP 157
93991: AND
93992: IFFALSE 94203
93994: GO 93996
93996: DISABLE
93997: LD_INT 0
93999: PPUSH
94000: PPUSH
94001: PPUSH
94002: PPUSH
94003: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94004: LD_ADDR_VAR 0 5
94008: PUSH
94009: LD_INT 22
94011: PUSH
94012: LD_OWVAR 2
94016: PUSH
94017: EMPTY
94018: LIST
94019: LIST
94020: PUSH
94021: LD_INT 21
94023: PUSH
94024: LD_INT 1
94026: PUSH
94027: EMPTY
94028: LIST
94029: LIST
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PPUSH
94035: CALL_OW 69
94039: ST_TO_ADDR
// if not tmp then
94040: LD_VAR 0 5
94044: NOT
94045: IFFALSE 94049
// exit ;
94047: GO 94203
// for i in tmp do
94049: LD_ADDR_VAR 0 1
94053: PUSH
94054: LD_VAR 0 5
94058: PUSH
94059: FOR_IN
94060: IFFALSE 94201
// begin d := rand ( 0 , 5 ) ;
94062: LD_ADDR_VAR 0 4
94066: PUSH
94067: LD_INT 0
94069: PPUSH
94070: LD_INT 5
94072: PPUSH
94073: CALL_OW 12
94077: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
94078: LD_ADDR_VAR 0 2
94082: PUSH
94083: LD_VAR 0 1
94087: PPUSH
94088: CALL_OW 250
94092: PPUSH
94093: LD_VAR 0 4
94097: PPUSH
94098: LD_INT 3
94100: PPUSH
94101: LD_INT 12
94103: PPUSH
94104: CALL_OW 12
94108: PPUSH
94109: CALL_OW 272
94113: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
94114: LD_ADDR_VAR 0 3
94118: PUSH
94119: LD_VAR 0 1
94123: PPUSH
94124: CALL_OW 251
94128: PPUSH
94129: LD_VAR 0 4
94133: PPUSH
94134: LD_INT 3
94136: PPUSH
94137: LD_INT 12
94139: PPUSH
94140: CALL_OW 12
94144: PPUSH
94145: CALL_OW 273
94149: ST_TO_ADDR
// if ValidHex ( x , y ) then
94150: LD_VAR 0 2
94154: PPUSH
94155: LD_VAR 0 3
94159: PPUSH
94160: CALL_OW 488
94164: IFFALSE 94199
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
94166: LD_VAR 0 1
94170: PPUSH
94171: LD_VAR 0 2
94175: PPUSH
94176: LD_VAR 0 3
94180: PPUSH
94181: LD_INT 3
94183: PPUSH
94184: LD_INT 6
94186: PPUSH
94187: CALL_OW 12
94191: PPUSH
94192: LD_INT 1
94194: PPUSH
94195: CALL_OW 483
// end ;
94199: GO 94059
94201: POP
94202: POP
// end ;
94203: PPOPN 5
94205: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
94206: LD_EXP 123
94210: PUSH
94211: LD_EXP 158
94215: AND
94216: IFFALSE 94310
94218: GO 94220
94220: DISABLE
94221: LD_INT 0
94223: PPUSH
94224: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
94225: LD_ADDR_VAR 0 2
94229: PUSH
94230: LD_INT 22
94232: PUSH
94233: LD_OWVAR 2
94237: PUSH
94238: EMPTY
94239: LIST
94240: LIST
94241: PUSH
94242: LD_INT 32
94244: PUSH
94245: LD_INT 1
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: PUSH
94252: LD_INT 21
94254: PUSH
94255: LD_INT 2
94257: PUSH
94258: EMPTY
94259: LIST
94260: LIST
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: LIST
94266: PPUSH
94267: CALL_OW 69
94271: ST_TO_ADDR
// if not tmp then
94272: LD_VAR 0 2
94276: NOT
94277: IFFALSE 94281
// exit ;
94279: GO 94310
// for i in tmp do
94281: LD_ADDR_VAR 0 1
94285: PUSH
94286: LD_VAR 0 2
94290: PUSH
94291: FOR_IN
94292: IFFALSE 94308
// SetFuel ( i , 0 ) ;
94294: LD_VAR 0 1
94298: PPUSH
94299: LD_INT 0
94301: PPUSH
94302: CALL_OW 240
94306: GO 94291
94308: POP
94309: POP
// end ;
94310: PPOPN 2
94312: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
94313: LD_EXP 123
94317: PUSH
94318: LD_EXP 159
94322: AND
94323: IFFALSE 94389
94325: GO 94327
94327: DISABLE
94328: LD_INT 0
94330: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
94331: LD_ADDR_VAR 0 1
94335: PUSH
94336: LD_INT 22
94338: PUSH
94339: LD_OWVAR 2
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 30
94350: PUSH
94351: LD_INT 29
94353: PUSH
94354: EMPTY
94355: LIST
94356: LIST
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PPUSH
94362: CALL_OW 69
94366: ST_TO_ADDR
// if not tmp then
94367: LD_VAR 0 1
94371: NOT
94372: IFFALSE 94376
// exit ;
94374: GO 94389
// DestroyUnit ( tmp [ 1 ] ) ;
94376: LD_VAR 0 1
94380: PUSH
94381: LD_INT 1
94383: ARRAY
94384: PPUSH
94385: CALL_OW 65
// end ;
94389: PPOPN 1
94391: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
94392: LD_EXP 123
94396: PUSH
94397: LD_EXP 161
94401: AND
94402: IFFALSE 94531
94404: GO 94406
94406: DISABLE
94407: LD_INT 0
94409: PPUSH
// begin uc_side := 0 ;
94410: LD_ADDR_OWVAR 20
94414: PUSH
94415: LD_INT 0
94417: ST_TO_ADDR
// uc_nation := nation_arabian ;
94418: LD_ADDR_OWVAR 21
94422: PUSH
94423: LD_INT 2
94425: ST_TO_ADDR
// hc_gallery :=  ;
94426: LD_ADDR_OWVAR 33
94430: PUSH
94431: LD_STRING 
94433: ST_TO_ADDR
// hc_name :=  ;
94434: LD_ADDR_OWVAR 26
94438: PUSH
94439: LD_STRING 
94441: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94442: LD_INT 1
94444: PPUSH
94445: LD_INT 11
94447: PPUSH
94448: LD_INT 10
94450: PPUSH
94451: CALL_OW 380
// un := CreateHuman ;
94455: LD_ADDR_VAR 0 1
94459: PUSH
94460: CALL_OW 44
94464: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94465: LD_VAR 0 1
94469: PPUSH
94470: LD_INT 1
94472: PPUSH
94473: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94477: LD_INT 35
94479: PPUSH
94480: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94484: LD_VAR 0 1
94488: PPUSH
94489: LD_INT 22
94491: PUSH
94492: LD_OWVAR 2
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: PPUSH
94501: CALL_OW 69
94505: PPUSH
94506: LD_VAR 0 1
94510: PPUSH
94511: CALL_OW 74
94515: PPUSH
94516: CALL_OW 115
// until IsDead ( un ) ;
94520: LD_VAR 0 1
94524: PPUSH
94525: CALL_OW 301
94529: IFFALSE 94477
// end ;
94531: PPOPN 1
94533: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94534: LD_EXP 123
94538: PUSH
94539: LD_EXP 163
94543: AND
94544: IFFALSE 94556
94546: GO 94548
94548: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94549: LD_STRING earthquake(getX(game), 0, 32)
94551: PPUSH
94552: CALL_OW 559
94556: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94557: LD_EXP 123
94561: PUSH
94562: LD_EXP 164
94566: AND
94567: IFFALSE 94658
94569: GO 94571
94571: DISABLE
94572: LD_INT 0
94574: PPUSH
// begin enable ;
94575: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94576: LD_ADDR_VAR 0 1
94580: PUSH
94581: LD_INT 22
94583: PUSH
94584: LD_OWVAR 2
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 21
94595: PUSH
94596: LD_INT 2
94598: PUSH
94599: EMPTY
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 33
94605: PUSH
94606: LD_INT 3
94608: PUSH
94609: EMPTY
94610: LIST
94611: LIST
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: LIST
94617: PPUSH
94618: CALL_OW 69
94622: ST_TO_ADDR
// if not tmp then
94623: LD_VAR 0 1
94627: NOT
94628: IFFALSE 94632
// exit ;
94630: GO 94658
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94632: LD_VAR 0 1
94636: PUSH
94637: LD_INT 1
94639: PPUSH
94640: LD_VAR 0 1
94644: PPUSH
94645: CALL_OW 12
94649: ARRAY
94650: PPUSH
94651: LD_INT 1
94653: PPUSH
94654: CALL_OW 234
// end ;
94658: PPOPN 1
94660: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94661: LD_EXP 123
94665: PUSH
94666: LD_EXP 165
94670: AND
94671: IFFALSE 94812
94673: GO 94675
94675: DISABLE
94676: LD_INT 0
94678: PPUSH
94679: PPUSH
94680: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94681: LD_ADDR_VAR 0 3
94685: PUSH
94686: LD_INT 22
94688: PUSH
94689: LD_OWVAR 2
94693: PUSH
94694: EMPTY
94695: LIST
94696: LIST
94697: PUSH
94698: LD_INT 25
94700: PUSH
94701: LD_INT 1
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: EMPTY
94709: LIST
94710: LIST
94711: PPUSH
94712: CALL_OW 69
94716: ST_TO_ADDR
// if not tmp then
94717: LD_VAR 0 3
94721: NOT
94722: IFFALSE 94726
// exit ;
94724: GO 94812
// un := tmp [ rand ( 1 , tmp ) ] ;
94726: LD_ADDR_VAR 0 2
94730: PUSH
94731: LD_VAR 0 3
94735: PUSH
94736: LD_INT 1
94738: PPUSH
94739: LD_VAR 0 3
94743: PPUSH
94744: CALL_OW 12
94748: ARRAY
94749: ST_TO_ADDR
// if Crawls ( un ) then
94750: LD_VAR 0 2
94754: PPUSH
94755: CALL_OW 318
94759: IFFALSE 94770
// ComWalk ( un ) ;
94761: LD_VAR 0 2
94765: PPUSH
94766: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94770: LD_VAR 0 2
94774: PPUSH
94775: LD_INT 9
94777: PPUSH
94778: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94782: LD_INT 28
94784: PPUSH
94785: LD_OWVAR 2
94789: PPUSH
94790: LD_INT 2
94792: PPUSH
94793: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94797: LD_INT 29
94799: PPUSH
94800: LD_OWVAR 2
94804: PPUSH
94805: LD_INT 2
94807: PPUSH
94808: CALL_OW 322
// end ;
94812: PPOPN 3
94814: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94815: LD_EXP 123
94819: PUSH
94820: LD_EXP 166
94824: AND
94825: IFFALSE 94936
94827: GO 94829
94829: DISABLE
94830: LD_INT 0
94832: PPUSH
94833: PPUSH
94834: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94835: LD_ADDR_VAR 0 3
94839: PUSH
94840: LD_INT 22
94842: PUSH
94843: LD_OWVAR 2
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: LD_INT 25
94854: PUSH
94855: LD_INT 1
94857: PUSH
94858: EMPTY
94859: LIST
94860: LIST
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PPUSH
94866: CALL_OW 69
94870: ST_TO_ADDR
// if not tmp then
94871: LD_VAR 0 3
94875: NOT
94876: IFFALSE 94880
// exit ;
94878: GO 94936
// un := tmp [ rand ( 1 , tmp ) ] ;
94880: LD_ADDR_VAR 0 2
94884: PUSH
94885: LD_VAR 0 3
94889: PUSH
94890: LD_INT 1
94892: PPUSH
94893: LD_VAR 0 3
94897: PPUSH
94898: CALL_OW 12
94902: ARRAY
94903: ST_TO_ADDR
// if Crawls ( un ) then
94904: LD_VAR 0 2
94908: PPUSH
94909: CALL_OW 318
94913: IFFALSE 94924
// ComWalk ( un ) ;
94915: LD_VAR 0 2
94919: PPUSH
94920: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94924: LD_VAR 0 2
94928: PPUSH
94929: LD_INT 8
94931: PPUSH
94932: CALL_OW 336
// end ;
94936: PPOPN 3
94938: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94939: LD_EXP 123
94943: PUSH
94944: LD_EXP 167
94948: AND
94949: IFFALSE 95093
94951: GO 94953
94953: DISABLE
94954: LD_INT 0
94956: PPUSH
94957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94958: LD_ADDR_VAR 0 2
94962: PUSH
94963: LD_INT 22
94965: PUSH
94966: LD_OWVAR 2
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: PUSH
94975: LD_INT 21
94977: PUSH
94978: LD_INT 2
94980: PUSH
94981: EMPTY
94982: LIST
94983: LIST
94984: PUSH
94985: LD_INT 2
94987: PUSH
94988: LD_INT 34
94990: PUSH
94991: LD_INT 12
94993: PUSH
94994: EMPTY
94995: LIST
94996: LIST
94997: PUSH
94998: LD_INT 34
95000: PUSH
95001: LD_INT 51
95003: PUSH
95004: EMPTY
95005: LIST
95006: LIST
95007: PUSH
95008: LD_INT 34
95010: PUSH
95011: LD_INT 32
95013: PUSH
95014: EMPTY
95015: LIST
95016: LIST
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: PUSH
95024: EMPTY
95025: LIST
95026: LIST
95027: LIST
95028: PPUSH
95029: CALL_OW 69
95033: ST_TO_ADDR
// if not tmp then
95034: LD_VAR 0 2
95038: NOT
95039: IFFALSE 95043
// exit ;
95041: GO 95093
// for i in tmp do
95043: LD_ADDR_VAR 0 1
95047: PUSH
95048: LD_VAR 0 2
95052: PUSH
95053: FOR_IN
95054: IFFALSE 95091
// if GetCargo ( i , mat_artifact ) = 0 then
95056: LD_VAR 0 1
95060: PPUSH
95061: LD_INT 4
95063: PPUSH
95064: CALL_OW 289
95068: PUSH
95069: LD_INT 0
95071: EQUAL
95072: IFFALSE 95089
// SetCargo ( i , mat_siberit , 100 ) ;
95074: LD_VAR 0 1
95078: PPUSH
95079: LD_INT 3
95081: PPUSH
95082: LD_INT 100
95084: PPUSH
95085: CALL_OW 290
95089: GO 95053
95091: POP
95092: POP
// end ;
95093: PPOPN 2
95095: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
95096: LD_EXP 123
95100: PUSH
95101: LD_EXP 168
95105: AND
95106: IFFALSE 95289
95108: GO 95110
95110: DISABLE
95111: LD_INT 0
95113: PPUSH
95114: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
95115: LD_ADDR_VAR 0 2
95119: PUSH
95120: LD_INT 22
95122: PUSH
95123: LD_OWVAR 2
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PPUSH
95132: CALL_OW 69
95136: ST_TO_ADDR
// if not tmp then
95137: LD_VAR 0 2
95141: NOT
95142: IFFALSE 95146
// exit ;
95144: GO 95289
// for i := 1 to 2 do
95146: LD_ADDR_VAR 0 1
95150: PUSH
95151: DOUBLE
95152: LD_INT 1
95154: DEC
95155: ST_TO_ADDR
95156: LD_INT 2
95158: PUSH
95159: FOR_TO
95160: IFFALSE 95287
// begin uc_side := your_side ;
95162: LD_ADDR_OWVAR 20
95166: PUSH
95167: LD_OWVAR 2
95171: ST_TO_ADDR
// uc_nation := nation_american ;
95172: LD_ADDR_OWVAR 21
95176: PUSH
95177: LD_INT 1
95179: ST_TO_ADDR
// vc_chassis := us_morphling ;
95180: LD_ADDR_OWVAR 37
95184: PUSH
95185: LD_INT 5
95187: ST_TO_ADDR
// vc_engine := engine_siberite ;
95188: LD_ADDR_OWVAR 39
95192: PUSH
95193: LD_INT 3
95195: ST_TO_ADDR
// vc_control := control_computer ;
95196: LD_ADDR_OWVAR 38
95200: PUSH
95201: LD_INT 3
95203: ST_TO_ADDR
// vc_weapon := us_double_laser ;
95204: LD_ADDR_OWVAR 40
95208: PUSH
95209: LD_INT 10
95211: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
95212: LD_VAR 0 2
95216: PUSH
95217: LD_INT 1
95219: ARRAY
95220: PPUSH
95221: CALL_OW 310
95225: NOT
95226: IFFALSE 95273
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
95228: CALL_OW 45
95232: PPUSH
95233: LD_VAR 0 2
95237: PUSH
95238: LD_INT 1
95240: ARRAY
95241: PPUSH
95242: CALL_OW 250
95246: PPUSH
95247: LD_VAR 0 2
95251: PUSH
95252: LD_INT 1
95254: ARRAY
95255: PPUSH
95256: CALL_OW 251
95260: PPUSH
95261: LD_INT 12
95263: PPUSH
95264: LD_INT 1
95266: PPUSH
95267: CALL_OW 50
95271: GO 95285
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
95273: CALL_OW 45
95277: PPUSH
95278: LD_INT 1
95280: PPUSH
95281: CALL_OW 51
// end ;
95285: GO 95159
95287: POP
95288: POP
// end ;
95289: PPOPN 2
95291: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
95292: LD_EXP 123
95296: PUSH
95297: LD_EXP 169
95301: AND
95302: IFFALSE 95524
95304: GO 95306
95306: DISABLE
95307: LD_INT 0
95309: PPUSH
95310: PPUSH
95311: PPUSH
95312: PPUSH
95313: PPUSH
95314: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95315: LD_ADDR_VAR 0 6
95319: PUSH
95320: LD_INT 22
95322: PUSH
95323: LD_OWVAR 2
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 21
95334: PUSH
95335: LD_INT 1
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: PUSH
95342: LD_INT 3
95344: PUSH
95345: LD_INT 23
95347: PUSH
95348: LD_INT 0
95350: PUSH
95351: EMPTY
95352: LIST
95353: LIST
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: EMPTY
95360: LIST
95361: LIST
95362: LIST
95363: PPUSH
95364: CALL_OW 69
95368: ST_TO_ADDR
// if not tmp then
95369: LD_VAR 0 6
95373: NOT
95374: IFFALSE 95378
// exit ;
95376: GO 95524
// s1 := rand ( 1 , 4 ) ;
95378: LD_ADDR_VAR 0 2
95382: PUSH
95383: LD_INT 1
95385: PPUSH
95386: LD_INT 4
95388: PPUSH
95389: CALL_OW 12
95393: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
95394: LD_ADDR_VAR 0 4
95398: PUSH
95399: LD_VAR 0 6
95403: PUSH
95404: LD_INT 1
95406: ARRAY
95407: PPUSH
95408: LD_VAR 0 2
95412: PPUSH
95413: CALL_OW 259
95417: ST_TO_ADDR
// if s1 = 1 then
95418: LD_VAR 0 2
95422: PUSH
95423: LD_INT 1
95425: EQUAL
95426: IFFALSE 95446
// s2 := rand ( 2 , 4 ) else
95428: LD_ADDR_VAR 0 3
95432: PUSH
95433: LD_INT 2
95435: PPUSH
95436: LD_INT 4
95438: PPUSH
95439: CALL_OW 12
95443: ST_TO_ADDR
95444: GO 95454
// s2 := 1 ;
95446: LD_ADDR_VAR 0 3
95450: PUSH
95451: LD_INT 1
95453: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95454: LD_ADDR_VAR 0 5
95458: PUSH
95459: LD_VAR 0 6
95463: PUSH
95464: LD_INT 1
95466: ARRAY
95467: PPUSH
95468: LD_VAR 0 3
95472: PPUSH
95473: CALL_OW 259
95477: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95478: LD_VAR 0 6
95482: PUSH
95483: LD_INT 1
95485: ARRAY
95486: PPUSH
95487: LD_VAR 0 2
95491: PPUSH
95492: LD_VAR 0 5
95496: PPUSH
95497: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95501: LD_VAR 0 6
95505: PUSH
95506: LD_INT 1
95508: ARRAY
95509: PPUSH
95510: LD_VAR 0 3
95514: PPUSH
95515: LD_VAR 0 4
95519: PPUSH
95520: CALL_OW 237
// end ;
95524: PPOPN 6
95526: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95527: LD_EXP 123
95531: PUSH
95532: LD_EXP 170
95536: AND
95537: IFFALSE 95616
95539: GO 95541
95541: DISABLE
95542: LD_INT 0
95544: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95545: LD_ADDR_VAR 0 1
95549: PUSH
95550: LD_INT 22
95552: PUSH
95553: LD_OWVAR 2
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 30
95564: PUSH
95565: LD_INT 3
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: EMPTY
95573: LIST
95574: LIST
95575: PPUSH
95576: CALL_OW 69
95580: ST_TO_ADDR
// if not tmp then
95581: LD_VAR 0 1
95585: NOT
95586: IFFALSE 95590
// exit ;
95588: GO 95616
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95590: LD_VAR 0 1
95594: PUSH
95595: LD_INT 1
95597: PPUSH
95598: LD_VAR 0 1
95602: PPUSH
95603: CALL_OW 12
95607: ARRAY
95608: PPUSH
95609: LD_INT 1
95611: PPUSH
95612: CALL_OW 234
// end ;
95616: PPOPN 1
95618: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95619: LD_EXP 123
95623: PUSH
95624: LD_EXP 171
95628: AND
95629: IFFALSE 95741
95631: GO 95633
95633: DISABLE
95634: LD_INT 0
95636: PPUSH
95637: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95638: LD_ADDR_VAR 0 2
95642: PUSH
95643: LD_INT 22
95645: PUSH
95646: LD_OWVAR 2
95650: PUSH
95651: EMPTY
95652: LIST
95653: LIST
95654: PUSH
95655: LD_INT 2
95657: PUSH
95658: LD_INT 30
95660: PUSH
95661: LD_INT 27
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: PUSH
95668: LD_INT 30
95670: PUSH
95671: LD_INT 26
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: PUSH
95678: LD_INT 30
95680: PUSH
95681: LD_INT 28
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: EMPTY
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: PUSH
95694: EMPTY
95695: LIST
95696: LIST
95697: PPUSH
95698: CALL_OW 69
95702: ST_TO_ADDR
// if not tmp then
95703: LD_VAR 0 2
95707: NOT
95708: IFFALSE 95712
// exit ;
95710: GO 95741
// for i in tmp do
95712: LD_ADDR_VAR 0 1
95716: PUSH
95717: LD_VAR 0 2
95721: PUSH
95722: FOR_IN
95723: IFFALSE 95739
// SetLives ( i , 1 ) ;
95725: LD_VAR 0 1
95729: PPUSH
95730: LD_INT 1
95732: PPUSH
95733: CALL_OW 234
95737: GO 95722
95739: POP
95740: POP
// end ;
95741: PPOPN 2
95743: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95744: LD_EXP 123
95748: PUSH
95749: LD_EXP 172
95753: AND
95754: IFFALSE 96041
95756: GO 95758
95758: DISABLE
95759: LD_INT 0
95761: PPUSH
95762: PPUSH
95763: PPUSH
// begin i := rand ( 1 , 7 ) ;
95764: LD_ADDR_VAR 0 1
95768: PUSH
95769: LD_INT 1
95771: PPUSH
95772: LD_INT 7
95774: PPUSH
95775: CALL_OW 12
95779: ST_TO_ADDR
// case i of 1 :
95780: LD_VAR 0 1
95784: PUSH
95785: LD_INT 1
95787: DOUBLE
95788: EQUAL
95789: IFTRUE 95793
95791: GO 95803
95793: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95794: LD_STRING earthquake(getX(game), 0, 32)
95796: PPUSH
95797: CALL_OW 559
95801: GO 96041
95803: LD_INT 2
95805: DOUBLE
95806: EQUAL
95807: IFTRUE 95811
95809: GO 95825
95811: POP
// begin ToLua ( displayStucuk(); ) ;
95812: LD_STRING displayStucuk();
95814: PPUSH
95815: CALL_OW 559
// ResetFog ;
95819: CALL_OW 335
// end ; 3 :
95823: GO 96041
95825: LD_INT 3
95827: DOUBLE
95828: EQUAL
95829: IFTRUE 95833
95831: GO 95937
95833: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95834: LD_ADDR_VAR 0 2
95838: PUSH
95839: LD_INT 22
95841: PUSH
95842: LD_OWVAR 2
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PUSH
95851: LD_INT 25
95853: PUSH
95854: LD_INT 1
95856: PUSH
95857: EMPTY
95858: LIST
95859: LIST
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PPUSH
95865: CALL_OW 69
95869: ST_TO_ADDR
// if not tmp then
95870: LD_VAR 0 2
95874: NOT
95875: IFFALSE 95879
// exit ;
95877: GO 96041
// un := tmp [ rand ( 1 , tmp ) ] ;
95879: LD_ADDR_VAR 0 3
95883: PUSH
95884: LD_VAR 0 2
95888: PUSH
95889: LD_INT 1
95891: PPUSH
95892: LD_VAR 0 2
95896: PPUSH
95897: CALL_OW 12
95901: ARRAY
95902: ST_TO_ADDR
// if Crawls ( un ) then
95903: LD_VAR 0 3
95907: PPUSH
95908: CALL_OW 318
95912: IFFALSE 95923
// ComWalk ( un ) ;
95914: LD_VAR 0 3
95918: PPUSH
95919: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95923: LD_VAR 0 3
95927: PPUSH
95928: LD_INT 8
95930: PPUSH
95931: CALL_OW 336
// end ; 4 :
95935: GO 96041
95937: LD_INT 4
95939: DOUBLE
95940: EQUAL
95941: IFTRUE 95945
95943: GO 96019
95945: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95946: LD_ADDR_VAR 0 2
95950: PUSH
95951: LD_INT 22
95953: PUSH
95954: LD_OWVAR 2
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 30
95965: PUSH
95966: LD_INT 29
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: PUSH
95973: EMPTY
95974: LIST
95975: LIST
95976: PPUSH
95977: CALL_OW 69
95981: ST_TO_ADDR
// if not tmp then
95982: LD_VAR 0 2
95986: NOT
95987: IFFALSE 95991
// exit ;
95989: GO 96041
// CenterNowOnUnits ( tmp [ 1 ] ) ;
95991: LD_VAR 0 2
95995: PUSH
95996: LD_INT 1
95998: ARRAY
95999: PPUSH
96000: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
96004: LD_VAR 0 2
96008: PUSH
96009: LD_INT 1
96011: ARRAY
96012: PPUSH
96013: CALL_OW 65
// end ; 5 .. 7 :
96017: GO 96041
96019: LD_INT 5
96021: DOUBLE
96022: GREATEREQUAL
96023: IFFALSE 96031
96025: LD_INT 7
96027: DOUBLE
96028: LESSEQUAL
96029: IFTRUE 96033
96031: GO 96040
96033: POP
// StreamSibBomb ; end ;
96034: CALL 92278 0 0
96038: GO 96041
96040: POP
// end ;
96041: PPOPN 3
96043: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
96044: LD_EXP 123
96048: PUSH
96049: LD_EXP 173
96053: AND
96054: IFFALSE 96210
96056: GO 96058
96058: DISABLE
96059: LD_INT 0
96061: PPUSH
96062: PPUSH
96063: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
96064: LD_ADDR_VAR 0 2
96068: PUSH
96069: LD_INT 81
96071: PUSH
96072: LD_OWVAR 2
96076: PUSH
96077: EMPTY
96078: LIST
96079: LIST
96080: PUSH
96081: LD_INT 2
96083: PUSH
96084: LD_INT 21
96086: PUSH
96087: LD_INT 1
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 21
96096: PUSH
96097: LD_INT 2
96099: PUSH
96100: EMPTY
96101: LIST
96102: LIST
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: LIST
96108: PUSH
96109: EMPTY
96110: LIST
96111: LIST
96112: PPUSH
96113: CALL_OW 69
96117: ST_TO_ADDR
// if not tmp then
96118: LD_VAR 0 2
96122: NOT
96123: IFFALSE 96127
// exit ;
96125: GO 96210
// p := 0 ;
96127: LD_ADDR_VAR 0 3
96131: PUSH
96132: LD_INT 0
96134: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96135: LD_INT 35
96137: PPUSH
96138: CALL_OW 67
// p := p + 1 ;
96142: LD_ADDR_VAR 0 3
96146: PUSH
96147: LD_VAR 0 3
96151: PUSH
96152: LD_INT 1
96154: PLUS
96155: ST_TO_ADDR
// for i in tmp do
96156: LD_ADDR_VAR 0 1
96160: PUSH
96161: LD_VAR 0 2
96165: PUSH
96166: FOR_IN
96167: IFFALSE 96198
// if GetLives ( i ) < 1000 then
96169: LD_VAR 0 1
96173: PPUSH
96174: CALL_OW 256
96178: PUSH
96179: LD_INT 1000
96181: LESS
96182: IFFALSE 96196
// SetLives ( i , 1000 ) ;
96184: LD_VAR 0 1
96188: PPUSH
96189: LD_INT 1000
96191: PPUSH
96192: CALL_OW 234
96196: GO 96166
96198: POP
96199: POP
// until p > 20 ;
96200: LD_VAR 0 3
96204: PUSH
96205: LD_INT 20
96207: GREATER
96208: IFFALSE 96135
// end ;
96210: PPOPN 3
96212: END
// every 0 0$1 trigger StreamModeActive and sTime do
96213: LD_EXP 123
96217: PUSH
96218: LD_EXP 174
96222: AND
96223: IFFALSE 96258
96225: GO 96227
96227: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
96228: LD_INT 28
96230: PPUSH
96231: LD_OWVAR 2
96235: PPUSH
96236: LD_INT 2
96238: PPUSH
96239: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
96243: LD_INT 30
96245: PPUSH
96246: LD_OWVAR 2
96250: PPUSH
96251: LD_INT 2
96253: PPUSH
96254: CALL_OW 322
// end ;
96258: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
96259: LD_EXP 123
96263: PUSH
96264: LD_EXP 175
96268: AND
96269: IFFALSE 96390
96271: GO 96273
96273: DISABLE
96274: LD_INT 0
96276: PPUSH
96277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96278: LD_ADDR_VAR 0 2
96282: PUSH
96283: LD_INT 22
96285: PUSH
96286: LD_OWVAR 2
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 21
96297: PUSH
96298: LD_INT 1
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 3
96307: PUSH
96308: LD_INT 23
96310: PUSH
96311: LD_INT 0
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: EMPTY
96319: LIST
96320: LIST
96321: PUSH
96322: EMPTY
96323: LIST
96324: LIST
96325: LIST
96326: PPUSH
96327: CALL_OW 69
96331: ST_TO_ADDR
// if not tmp then
96332: LD_VAR 0 2
96336: NOT
96337: IFFALSE 96341
// exit ;
96339: GO 96390
// for i in tmp do
96341: LD_ADDR_VAR 0 1
96345: PUSH
96346: LD_VAR 0 2
96350: PUSH
96351: FOR_IN
96352: IFFALSE 96388
// begin if Crawls ( i ) then
96354: LD_VAR 0 1
96358: PPUSH
96359: CALL_OW 318
96363: IFFALSE 96374
// ComWalk ( i ) ;
96365: LD_VAR 0 1
96369: PPUSH
96370: CALL_OW 138
// SetClass ( i , 2 ) ;
96374: LD_VAR 0 1
96378: PPUSH
96379: LD_INT 2
96381: PPUSH
96382: CALL_OW 336
// end ;
96386: GO 96351
96388: POP
96389: POP
// end ;
96390: PPOPN 2
96392: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
96393: LD_EXP 123
96397: PUSH
96398: LD_EXP 176
96402: AND
96403: IFFALSE 96691
96405: GO 96407
96407: DISABLE
96408: LD_INT 0
96410: PPUSH
96411: PPUSH
96412: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
96413: LD_OWVAR 2
96417: PPUSH
96418: LD_INT 9
96420: PPUSH
96421: LD_INT 1
96423: PPUSH
96424: LD_INT 1
96426: PPUSH
96427: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96431: LD_INT 9
96433: PPUSH
96434: LD_OWVAR 2
96438: PPUSH
96439: CALL_OW 343
// uc_side := 9 ;
96443: LD_ADDR_OWVAR 20
96447: PUSH
96448: LD_INT 9
96450: ST_TO_ADDR
// uc_nation := 2 ;
96451: LD_ADDR_OWVAR 21
96455: PUSH
96456: LD_INT 2
96458: ST_TO_ADDR
// hc_name := Dark Warrior ;
96459: LD_ADDR_OWVAR 26
96463: PUSH
96464: LD_STRING Dark Warrior
96466: ST_TO_ADDR
// hc_gallery :=  ;
96467: LD_ADDR_OWVAR 33
96471: PUSH
96472: LD_STRING 
96474: ST_TO_ADDR
// hc_noskilllimit := true ;
96475: LD_ADDR_OWVAR 76
96479: PUSH
96480: LD_INT 1
96482: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96483: LD_ADDR_OWVAR 31
96487: PUSH
96488: LD_INT 30
96490: PUSH
96491: LD_INT 30
96493: PUSH
96494: LD_INT 30
96496: PUSH
96497: LD_INT 30
96499: PUSH
96500: EMPTY
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: ST_TO_ADDR
// un := CreateHuman ;
96506: LD_ADDR_VAR 0 3
96510: PUSH
96511: CALL_OW 44
96515: ST_TO_ADDR
// hc_noskilllimit := false ;
96516: LD_ADDR_OWVAR 76
96520: PUSH
96521: LD_INT 0
96523: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96524: LD_VAR 0 3
96528: PPUSH
96529: LD_INT 1
96531: PPUSH
96532: CALL_OW 51
// ToLua ( playRanger() ) ;
96536: LD_STRING playRanger()
96538: PPUSH
96539: CALL_OW 559
// p := 0 ;
96543: LD_ADDR_VAR 0 2
96547: PUSH
96548: LD_INT 0
96550: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96551: LD_INT 35
96553: PPUSH
96554: CALL_OW 67
// p := p + 1 ;
96558: LD_ADDR_VAR 0 2
96562: PUSH
96563: LD_VAR 0 2
96567: PUSH
96568: LD_INT 1
96570: PLUS
96571: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96572: LD_VAR 0 3
96576: PPUSH
96577: CALL_OW 256
96581: PUSH
96582: LD_INT 1000
96584: LESS
96585: IFFALSE 96599
// SetLives ( un , 1000 ) ;
96587: LD_VAR 0 3
96591: PPUSH
96592: LD_INT 1000
96594: PPUSH
96595: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96599: LD_VAR 0 3
96603: PPUSH
96604: LD_INT 81
96606: PUSH
96607: LD_OWVAR 2
96611: PUSH
96612: EMPTY
96613: LIST
96614: LIST
96615: PUSH
96616: LD_INT 91
96618: PUSH
96619: LD_VAR 0 3
96623: PUSH
96624: LD_INT 30
96626: PUSH
96627: EMPTY
96628: LIST
96629: LIST
96630: LIST
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PPUSH
96636: CALL_OW 69
96640: PPUSH
96641: LD_VAR 0 3
96645: PPUSH
96646: CALL_OW 74
96650: PPUSH
96651: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
96655: LD_VAR 0 2
96659: PUSH
96660: LD_INT 80
96662: GREATER
96663: PUSH
96664: LD_VAR 0 3
96668: PPUSH
96669: CALL_OW 301
96673: OR
96674: IFFALSE 96551
// if un then
96676: LD_VAR 0 3
96680: IFFALSE 96691
// RemoveUnit ( un ) ;
96682: LD_VAR 0 3
96686: PPUSH
96687: CALL_OW 64
// end ;
96691: PPOPN 3
96693: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
96694: LD_EXP 177
96698: IFFALSE 96814
96700: GO 96702
96702: DISABLE
96703: LD_INT 0
96705: PPUSH
96706: PPUSH
96707: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96708: LD_ADDR_VAR 0 2
96712: PUSH
96713: LD_INT 81
96715: PUSH
96716: LD_OWVAR 2
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 21
96727: PUSH
96728: LD_INT 1
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: EMPTY
96736: LIST
96737: LIST
96738: PPUSH
96739: CALL_OW 69
96743: ST_TO_ADDR
// if not tmp then
96744: LD_VAR 0 2
96748: NOT
96749: IFFALSE 96753
// exit ;
96751: GO 96814
// ToLua ( playComputer() ) ;
96753: LD_STRING playComputer()
96755: PPUSH
96756: CALL_OW 559
// for i in tmp do
96760: LD_ADDR_VAR 0 1
96764: PUSH
96765: LD_VAR 0 2
96769: PUSH
96770: FOR_IN
96771: IFFALSE 96812
// for j := 1 to 4 do
96773: LD_ADDR_VAR 0 3
96777: PUSH
96778: DOUBLE
96779: LD_INT 1
96781: DEC
96782: ST_TO_ADDR
96783: LD_INT 4
96785: PUSH
96786: FOR_TO
96787: IFFALSE 96808
// SetSkill ( i , j , 10 ) ;
96789: LD_VAR 0 1
96793: PPUSH
96794: LD_VAR 0 3
96798: PPUSH
96799: LD_INT 10
96801: PPUSH
96802: CALL_OW 237
96806: GO 96786
96808: POP
96809: POP
96810: GO 96770
96812: POP
96813: POP
// end ;
96814: PPOPN 3
96816: END
// every 0 0$1 trigger s30 do var i , tmp ;
96817: LD_EXP 178
96821: IFFALSE 96890
96823: GO 96825
96825: DISABLE
96826: LD_INT 0
96828: PPUSH
96829: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96830: LD_ADDR_VAR 0 2
96834: PUSH
96835: LD_INT 22
96837: PUSH
96838: LD_OWVAR 2
96842: PUSH
96843: EMPTY
96844: LIST
96845: LIST
96846: PPUSH
96847: CALL_OW 69
96851: ST_TO_ADDR
// if not tmp then
96852: LD_VAR 0 2
96856: NOT
96857: IFFALSE 96861
// exit ;
96859: GO 96890
// for i in tmp do
96861: LD_ADDR_VAR 0 1
96865: PUSH
96866: LD_VAR 0 2
96870: PUSH
96871: FOR_IN
96872: IFFALSE 96888
// SetLives ( i , 300 ) ;
96874: LD_VAR 0 1
96878: PPUSH
96879: LD_INT 300
96881: PPUSH
96882: CALL_OW 234
96886: GO 96871
96888: POP
96889: POP
// end ;
96890: PPOPN 2
96892: END
// every 0 0$1 trigger s60 do var i , tmp ;
96893: LD_EXP 179
96897: IFFALSE 96966
96899: GO 96901
96901: DISABLE
96902: LD_INT 0
96904: PPUSH
96905: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96906: LD_ADDR_VAR 0 2
96910: PUSH
96911: LD_INT 22
96913: PUSH
96914: LD_OWVAR 2
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PPUSH
96923: CALL_OW 69
96927: ST_TO_ADDR
// if not tmp then
96928: LD_VAR 0 2
96932: NOT
96933: IFFALSE 96937
// exit ;
96935: GO 96966
// for i in tmp do
96937: LD_ADDR_VAR 0 1
96941: PUSH
96942: LD_VAR 0 2
96946: PUSH
96947: FOR_IN
96948: IFFALSE 96964
// SetLives ( i , 600 ) ;
96950: LD_VAR 0 1
96954: PPUSH
96955: LD_INT 600
96957: PPUSH
96958: CALL_OW 234
96962: GO 96947
96964: POP
96965: POP
// end ;
96966: PPOPN 2
96968: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96969: LD_INT 0
96971: PPUSH
// case cmd of 301 :
96972: LD_VAR 0 1
96976: PUSH
96977: LD_INT 301
96979: DOUBLE
96980: EQUAL
96981: IFTRUE 96985
96983: GO 97017
96985: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96986: LD_VAR 0 6
96990: PPUSH
96991: LD_VAR 0 7
96995: PPUSH
96996: LD_VAR 0 8
97000: PPUSH
97001: LD_VAR 0 4
97005: PPUSH
97006: LD_VAR 0 5
97010: PPUSH
97011: CALL 98218 0 5
97015: GO 97138
97017: LD_INT 302
97019: DOUBLE
97020: EQUAL
97021: IFTRUE 97025
97023: GO 97062
97025: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
97026: LD_VAR 0 6
97030: PPUSH
97031: LD_VAR 0 7
97035: PPUSH
97036: LD_VAR 0 8
97040: PPUSH
97041: LD_VAR 0 9
97045: PPUSH
97046: LD_VAR 0 4
97050: PPUSH
97051: LD_VAR 0 5
97055: PPUSH
97056: CALL 98309 0 6
97060: GO 97138
97062: LD_INT 303
97064: DOUBLE
97065: EQUAL
97066: IFTRUE 97070
97068: GO 97107
97070: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
97071: LD_VAR 0 6
97075: PPUSH
97076: LD_VAR 0 7
97080: PPUSH
97081: LD_VAR 0 8
97085: PPUSH
97086: LD_VAR 0 9
97090: PPUSH
97091: LD_VAR 0 4
97095: PPUSH
97096: LD_VAR 0 5
97100: PPUSH
97101: CALL 97143 0 6
97105: GO 97138
97107: LD_INT 304
97109: DOUBLE
97110: EQUAL
97111: IFTRUE 97115
97113: GO 97137
97115: POP
// hHackTeleport ( unit , x , y ) ; end ;
97116: LD_VAR 0 2
97120: PPUSH
97121: LD_VAR 0 4
97125: PPUSH
97126: LD_VAR 0 5
97130: PPUSH
97131: CALL 98902 0 3
97135: GO 97138
97137: POP
// end ;
97138: LD_VAR 0 12
97142: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
97143: LD_INT 0
97145: PPUSH
97146: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
97147: LD_VAR 0 1
97151: PUSH
97152: LD_INT 1
97154: LESS
97155: PUSH
97156: LD_VAR 0 1
97160: PUSH
97161: LD_INT 3
97163: GREATER
97164: OR
97165: PUSH
97166: LD_VAR 0 5
97170: PPUSH
97171: LD_VAR 0 6
97175: PPUSH
97176: CALL_OW 428
97180: OR
97181: IFFALSE 97185
// exit ;
97183: GO 97905
// uc_side := your_side ;
97185: LD_ADDR_OWVAR 20
97189: PUSH
97190: LD_OWVAR 2
97194: ST_TO_ADDR
// uc_nation := nation ;
97195: LD_ADDR_OWVAR 21
97199: PUSH
97200: LD_VAR 0 1
97204: ST_TO_ADDR
// bc_level = 1 ;
97205: LD_ADDR_OWVAR 43
97209: PUSH
97210: LD_INT 1
97212: ST_TO_ADDR
// case btype of 1 :
97213: LD_VAR 0 2
97217: PUSH
97218: LD_INT 1
97220: DOUBLE
97221: EQUAL
97222: IFTRUE 97226
97224: GO 97237
97226: POP
// bc_type := b_depot ; 2 :
97227: LD_ADDR_OWVAR 42
97231: PUSH
97232: LD_INT 0
97234: ST_TO_ADDR
97235: GO 97849
97237: LD_INT 2
97239: DOUBLE
97240: EQUAL
97241: IFTRUE 97245
97243: GO 97256
97245: POP
// bc_type := b_warehouse ; 3 :
97246: LD_ADDR_OWVAR 42
97250: PUSH
97251: LD_INT 1
97253: ST_TO_ADDR
97254: GO 97849
97256: LD_INT 3
97258: DOUBLE
97259: EQUAL
97260: IFTRUE 97264
97262: GO 97275
97264: POP
// bc_type := b_lab ; 4 .. 9 :
97265: LD_ADDR_OWVAR 42
97269: PUSH
97270: LD_INT 6
97272: ST_TO_ADDR
97273: GO 97849
97275: LD_INT 4
97277: DOUBLE
97278: GREATEREQUAL
97279: IFFALSE 97287
97281: LD_INT 9
97283: DOUBLE
97284: LESSEQUAL
97285: IFTRUE 97289
97287: GO 97341
97289: POP
// begin bc_type := b_lab_half ;
97290: LD_ADDR_OWVAR 42
97294: PUSH
97295: LD_INT 7
97297: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
97298: LD_ADDR_OWVAR 44
97302: PUSH
97303: LD_INT 10
97305: PUSH
97306: LD_INT 11
97308: PUSH
97309: LD_INT 12
97311: PUSH
97312: LD_INT 15
97314: PUSH
97315: LD_INT 14
97317: PUSH
97318: LD_INT 13
97320: PUSH
97321: EMPTY
97322: LIST
97323: LIST
97324: LIST
97325: LIST
97326: LIST
97327: LIST
97328: PUSH
97329: LD_VAR 0 2
97333: PUSH
97334: LD_INT 3
97336: MINUS
97337: ARRAY
97338: ST_TO_ADDR
// end ; 10 .. 13 :
97339: GO 97849
97341: LD_INT 10
97343: DOUBLE
97344: GREATEREQUAL
97345: IFFALSE 97353
97347: LD_INT 13
97349: DOUBLE
97350: LESSEQUAL
97351: IFTRUE 97355
97353: GO 97432
97355: POP
// begin bc_type := b_lab_full ;
97356: LD_ADDR_OWVAR 42
97360: PUSH
97361: LD_INT 8
97363: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
97364: LD_ADDR_OWVAR 44
97368: PUSH
97369: LD_INT 10
97371: PUSH
97372: LD_INT 12
97374: PUSH
97375: LD_INT 14
97377: PUSH
97378: LD_INT 13
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: LIST
97385: LIST
97386: PUSH
97387: LD_VAR 0 2
97391: PUSH
97392: LD_INT 9
97394: MINUS
97395: ARRAY
97396: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
97397: LD_ADDR_OWVAR 45
97401: PUSH
97402: LD_INT 11
97404: PUSH
97405: LD_INT 15
97407: PUSH
97408: LD_INT 12
97410: PUSH
97411: LD_INT 15
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: LIST
97418: LIST
97419: PUSH
97420: LD_VAR 0 2
97424: PUSH
97425: LD_INT 9
97427: MINUS
97428: ARRAY
97429: ST_TO_ADDR
// end ; 14 :
97430: GO 97849
97432: LD_INT 14
97434: DOUBLE
97435: EQUAL
97436: IFTRUE 97440
97438: GO 97451
97440: POP
// bc_type := b_workshop ; 15 :
97441: LD_ADDR_OWVAR 42
97445: PUSH
97446: LD_INT 2
97448: ST_TO_ADDR
97449: GO 97849
97451: LD_INT 15
97453: DOUBLE
97454: EQUAL
97455: IFTRUE 97459
97457: GO 97470
97459: POP
// bc_type := b_factory ; 16 :
97460: LD_ADDR_OWVAR 42
97464: PUSH
97465: LD_INT 3
97467: ST_TO_ADDR
97468: GO 97849
97470: LD_INT 16
97472: DOUBLE
97473: EQUAL
97474: IFTRUE 97478
97476: GO 97489
97478: POP
// bc_type := b_ext_gun ; 17 :
97479: LD_ADDR_OWVAR 42
97483: PUSH
97484: LD_INT 17
97486: ST_TO_ADDR
97487: GO 97849
97489: LD_INT 17
97491: DOUBLE
97492: EQUAL
97493: IFTRUE 97497
97495: GO 97525
97497: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
97498: LD_ADDR_OWVAR 42
97502: PUSH
97503: LD_INT 19
97505: PUSH
97506: LD_INT 23
97508: PUSH
97509: LD_INT 19
97511: PUSH
97512: EMPTY
97513: LIST
97514: LIST
97515: LIST
97516: PUSH
97517: LD_VAR 0 1
97521: ARRAY
97522: ST_TO_ADDR
97523: GO 97849
97525: LD_INT 18
97527: DOUBLE
97528: EQUAL
97529: IFTRUE 97533
97531: GO 97544
97533: POP
// bc_type := b_ext_radar ; 19 :
97534: LD_ADDR_OWVAR 42
97538: PUSH
97539: LD_INT 20
97541: ST_TO_ADDR
97542: GO 97849
97544: LD_INT 19
97546: DOUBLE
97547: EQUAL
97548: IFTRUE 97552
97550: GO 97563
97552: POP
// bc_type := b_ext_radio ; 20 :
97553: LD_ADDR_OWVAR 42
97557: PUSH
97558: LD_INT 22
97560: ST_TO_ADDR
97561: GO 97849
97563: LD_INT 20
97565: DOUBLE
97566: EQUAL
97567: IFTRUE 97571
97569: GO 97582
97571: POP
// bc_type := b_ext_siberium ; 21 :
97572: LD_ADDR_OWVAR 42
97576: PUSH
97577: LD_INT 21
97579: ST_TO_ADDR
97580: GO 97849
97582: LD_INT 21
97584: DOUBLE
97585: EQUAL
97586: IFTRUE 97590
97588: GO 97601
97590: POP
// bc_type := b_ext_computer ; 22 :
97591: LD_ADDR_OWVAR 42
97595: PUSH
97596: LD_INT 24
97598: ST_TO_ADDR
97599: GO 97849
97601: LD_INT 22
97603: DOUBLE
97604: EQUAL
97605: IFTRUE 97609
97607: GO 97620
97609: POP
// bc_type := b_ext_track ; 23 :
97610: LD_ADDR_OWVAR 42
97614: PUSH
97615: LD_INT 16
97617: ST_TO_ADDR
97618: GO 97849
97620: LD_INT 23
97622: DOUBLE
97623: EQUAL
97624: IFTRUE 97628
97626: GO 97639
97628: POP
// bc_type := b_ext_laser ; 24 :
97629: LD_ADDR_OWVAR 42
97633: PUSH
97634: LD_INT 25
97636: ST_TO_ADDR
97637: GO 97849
97639: LD_INT 24
97641: DOUBLE
97642: EQUAL
97643: IFTRUE 97647
97645: GO 97658
97647: POP
// bc_type := b_control_tower ; 25 :
97648: LD_ADDR_OWVAR 42
97652: PUSH
97653: LD_INT 36
97655: ST_TO_ADDR
97656: GO 97849
97658: LD_INT 25
97660: DOUBLE
97661: EQUAL
97662: IFTRUE 97666
97664: GO 97677
97666: POP
// bc_type := b_breastwork ; 26 :
97667: LD_ADDR_OWVAR 42
97671: PUSH
97672: LD_INT 31
97674: ST_TO_ADDR
97675: GO 97849
97677: LD_INT 26
97679: DOUBLE
97680: EQUAL
97681: IFTRUE 97685
97683: GO 97696
97685: POP
// bc_type := b_bunker ; 27 :
97686: LD_ADDR_OWVAR 42
97690: PUSH
97691: LD_INT 32
97693: ST_TO_ADDR
97694: GO 97849
97696: LD_INT 27
97698: DOUBLE
97699: EQUAL
97700: IFTRUE 97704
97702: GO 97715
97704: POP
// bc_type := b_turret ; 28 :
97705: LD_ADDR_OWVAR 42
97709: PUSH
97710: LD_INT 33
97712: ST_TO_ADDR
97713: GO 97849
97715: LD_INT 28
97717: DOUBLE
97718: EQUAL
97719: IFTRUE 97723
97721: GO 97734
97723: POP
// bc_type := b_armoury ; 29 :
97724: LD_ADDR_OWVAR 42
97728: PUSH
97729: LD_INT 4
97731: ST_TO_ADDR
97732: GO 97849
97734: LD_INT 29
97736: DOUBLE
97737: EQUAL
97738: IFTRUE 97742
97740: GO 97753
97742: POP
// bc_type := b_barracks ; 30 :
97743: LD_ADDR_OWVAR 42
97747: PUSH
97748: LD_INT 5
97750: ST_TO_ADDR
97751: GO 97849
97753: LD_INT 30
97755: DOUBLE
97756: EQUAL
97757: IFTRUE 97761
97759: GO 97772
97761: POP
// bc_type := b_solar_power ; 31 :
97762: LD_ADDR_OWVAR 42
97766: PUSH
97767: LD_INT 27
97769: ST_TO_ADDR
97770: GO 97849
97772: LD_INT 31
97774: DOUBLE
97775: EQUAL
97776: IFTRUE 97780
97778: GO 97791
97780: POP
// bc_type := b_oil_power ; 32 :
97781: LD_ADDR_OWVAR 42
97785: PUSH
97786: LD_INT 26
97788: ST_TO_ADDR
97789: GO 97849
97791: LD_INT 32
97793: DOUBLE
97794: EQUAL
97795: IFTRUE 97799
97797: GO 97810
97799: POP
// bc_type := b_siberite_power ; 33 :
97800: LD_ADDR_OWVAR 42
97804: PUSH
97805: LD_INT 28
97807: ST_TO_ADDR
97808: GO 97849
97810: LD_INT 33
97812: DOUBLE
97813: EQUAL
97814: IFTRUE 97818
97816: GO 97829
97818: POP
// bc_type := b_oil_mine ; 34 :
97819: LD_ADDR_OWVAR 42
97823: PUSH
97824: LD_INT 29
97826: ST_TO_ADDR
97827: GO 97849
97829: LD_INT 34
97831: DOUBLE
97832: EQUAL
97833: IFTRUE 97837
97835: GO 97848
97837: POP
// bc_type := b_siberite_mine ; end ;
97838: LD_ADDR_OWVAR 42
97842: PUSH
97843: LD_INT 30
97845: ST_TO_ADDR
97846: GO 97849
97848: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97849: LD_ADDR_VAR 0 8
97853: PUSH
97854: LD_VAR 0 5
97858: PPUSH
97859: LD_VAR 0 6
97863: PPUSH
97864: LD_VAR 0 3
97868: PPUSH
97869: CALL_OW 47
97873: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97874: LD_OWVAR 42
97878: PUSH
97879: LD_INT 32
97881: PUSH
97882: LD_INT 33
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: IN
97889: IFFALSE 97905
// PlaceWeaponTurret ( b , weapon ) ;
97891: LD_VAR 0 8
97895: PPUSH
97896: LD_VAR 0 4
97900: PPUSH
97901: CALL_OW 431
// end ;
97905: LD_VAR 0 7
97909: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97910: LD_INT 0
97912: PPUSH
97913: PPUSH
97914: PPUSH
97915: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97916: LD_ADDR_VAR 0 4
97920: PUSH
97921: LD_INT 22
97923: PUSH
97924: LD_OWVAR 2
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: LD_INT 2
97935: PUSH
97936: LD_INT 30
97938: PUSH
97939: LD_INT 0
97941: PUSH
97942: EMPTY
97943: LIST
97944: LIST
97945: PUSH
97946: LD_INT 30
97948: PUSH
97949: LD_INT 1
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: LIST
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PPUSH
97965: CALL_OW 69
97969: ST_TO_ADDR
// if not tmp then
97970: LD_VAR 0 4
97974: NOT
97975: IFFALSE 97979
// exit ;
97977: GO 98038
// for i in tmp do
97979: LD_ADDR_VAR 0 2
97983: PUSH
97984: LD_VAR 0 4
97988: PUSH
97989: FOR_IN
97990: IFFALSE 98036
// for j = 1 to 3 do
97992: LD_ADDR_VAR 0 3
97996: PUSH
97997: DOUBLE
97998: LD_INT 1
98000: DEC
98001: ST_TO_ADDR
98002: LD_INT 3
98004: PUSH
98005: FOR_TO
98006: IFFALSE 98032
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
98008: LD_VAR 0 2
98012: PPUSH
98013: CALL_OW 274
98017: PPUSH
98018: LD_VAR 0 3
98022: PPUSH
98023: LD_INT 99999
98025: PPUSH
98026: CALL_OW 277
98030: GO 98005
98032: POP
98033: POP
98034: GO 97989
98036: POP
98037: POP
// end ;
98038: LD_VAR 0 1
98042: RET
// export function hHackSetLevel10 ; var i , j ; begin
98043: LD_INT 0
98045: PPUSH
98046: PPUSH
98047: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98048: LD_ADDR_VAR 0 2
98052: PUSH
98053: LD_INT 21
98055: PUSH
98056: LD_INT 1
98058: PUSH
98059: EMPTY
98060: LIST
98061: LIST
98062: PPUSH
98063: CALL_OW 69
98067: PUSH
98068: FOR_IN
98069: IFFALSE 98121
// if IsSelected ( i ) then
98071: LD_VAR 0 2
98075: PPUSH
98076: CALL_OW 306
98080: IFFALSE 98119
// begin for j := 1 to 4 do
98082: LD_ADDR_VAR 0 3
98086: PUSH
98087: DOUBLE
98088: LD_INT 1
98090: DEC
98091: ST_TO_ADDR
98092: LD_INT 4
98094: PUSH
98095: FOR_TO
98096: IFFALSE 98117
// SetSkill ( i , j , 10 ) ;
98098: LD_VAR 0 2
98102: PPUSH
98103: LD_VAR 0 3
98107: PPUSH
98108: LD_INT 10
98110: PPUSH
98111: CALL_OW 237
98115: GO 98095
98117: POP
98118: POP
// end ;
98119: GO 98068
98121: POP
98122: POP
// end ;
98123: LD_VAR 0 1
98127: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
98128: LD_INT 0
98130: PPUSH
98131: PPUSH
98132: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
98133: LD_ADDR_VAR 0 2
98137: PUSH
98138: LD_INT 22
98140: PUSH
98141: LD_OWVAR 2
98145: PUSH
98146: EMPTY
98147: LIST
98148: LIST
98149: PUSH
98150: LD_INT 21
98152: PUSH
98153: LD_INT 1
98155: PUSH
98156: EMPTY
98157: LIST
98158: LIST
98159: PUSH
98160: EMPTY
98161: LIST
98162: LIST
98163: PPUSH
98164: CALL_OW 69
98168: PUSH
98169: FOR_IN
98170: IFFALSE 98211
// begin for j := 1 to 4 do
98172: LD_ADDR_VAR 0 3
98176: PUSH
98177: DOUBLE
98178: LD_INT 1
98180: DEC
98181: ST_TO_ADDR
98182: LD_INT 4
98184: PUSH
98185: FOR_TO
98186: IFFALSE 98207
// SetSkill ( i , j , 10 ) ;
98188: LD_VAR 0 2
98192: PPUSH
98193: LD_VAR 0 3
98197: PPUSH
98198: LD_INT 10
98200: PPUSH
98201: CALL_OW 237
98205: GO 98185
98207: POP
98208: POP
// end ;
98209: GO 98169
98211: POP
98212: POP
// end ;
98213: LD_VAR 0 1
98217: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
98218: LD_INT 0
98220: PPUSH
// uc_side := your_side ;
98221: LD_ADDR_OWVAR 20
98225: PUSH
98226: LD_OWVAR 2
98230: ST_TO_ADDR
// uc_nation := nation ;
98231: LD_ADDR_OWVAR 21
98235: PUSH
98236: LD_VAR 0 1
98240: ST_TO_ADDR
// InitHc ;
98241: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
98245: LD_INT 0
98247: PPUSH
98248: LD_VAR 0 2
98252: PPUSH
98253: LD_VAR 0 3
98257: PPUSH
98258: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
98262: LD_VAR 0 4
98266: PPUSH
98267: LD_VAR 0 5
98271: PPUSH
98272: CALL_OW 428
98276: PUSH
98277: LD_INT 0
98279: EQUAL
98280: IFFALSE 98304
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
98282: CALL_OW 44
98286: PPUSH
98287: LD_VAR 0 4
98291: PPUSH
98292: LD_VAR 0 5
98296: PPUSH
98297: LD_INT 1
98299: PPUSH
98300: CALL_OW 48
// end ;
98304: LD_VAR 0 6
98308: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
98309: LD_INT 0
98311: PPUSH
98312: PPUSH
// uc_side := your_side ;
98313: LD_ADDR_OWVAR 20
98317: PUSH
98318: LD_OWVAR 2
98322: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
98323: LD_VAR 0 1
98327: PUSH
98328: LD_INT 1
98330: PUSH
98331: LD_INT 2
98333: PUSH
98334: LD_INT 3
98336: PUSH
98337: LD_INT 4
98339: PUSH
98340: LD_INT 5
98342: PUSH
98343: EMPTY
98344: LIST
98345: LIST
98346: LIST
98347: LIST
98348: LIST
98349: IN
98350: IFFALSE 98362
// uc_nation := nation_american else
98352: LD_ADDR_OWVAR 21
98356: PUSH
98357: LD_INT 1
98359: ST_TO_ADDR
98360: GO 98405
// if chassis in [ 11 , 12 , 13 , 14 ] then
98362: LD_VAR 0 1
98366: PUSH
98367: LD_INT 11
98369: PUSH
98370: LD_INT 12
98372: PUSH
98373: LD_INT 13
98375: PUSH
98376: LD_INT 14
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: LIST
98383: LIST
98384: IN
98385: IFFALSE 98397
// uc_nation := nation_arabian else
98387: LD_ADDR_OWVAR 21
98391: PUSH
98392: LD_INT 2
98394: ST_TO_ADDR
98395: GO 98405
// uc_nation := nation_russian ;
98397: LD_ADDR_OWVAR 21
98401: PUSH
98402: LD_INT 3
98404: ST_TO_ADDR
// vc_chassis := chassis ;
98405: LD_ADDR_OWVAR 37
98409: PUSH
98410: LD_VAR 0 1
98414: ST_TO_ADDR
// vc_engine := engine ;
98415: LD_ADDR_OWVAR 39
98419: PUSH
98420: LD_VAR 0 2
98424: ST_TO_ADDR
// vc_control := control ;
98425: LD_ADDR_OWVAR 38
98429: PUSH
98430: LD_VAR 0 3
98434: ST_TO_ADDR
// vc_weapon := weapon ;
98435: LD_ADDR_OWVAR 40
98439: PUSH
98440: LD_VAR 0 4
98444: ST_TO_ADDR
// un := CreateVehicle ;
98445: LD_ADDR_VAR 0 8
98449: PUSH
98450: CALL_OW 45
98454: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
98455: LD_VAR 0 8
98459: PPUSH
98460: LD_INT 0
98462: PPUSH
98463: LD_INT 5
98465: PPUSH
98466: CALL_OW 12
98470: PPUSH
98471: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
98475: LD_VAR 0 8
98479: PPUSH
98480: LD_VAR 0 5
98484: PPUSH
98485: LD_VAR 0 6
98489: PPUSH
98490: LD_INT 1
98492: PPUSH
98493: CALL_OW 48
// end ;
98497: LD_VAR 0 7
98501: RET
// export hInvincible ; every 1 do
98502: GO 98504
98504: DISABLE
// hInvincible := [ ] ;
98505: LD_ADDR_EXP 180
98509: PUSH
98510: EMPTY
98511: ST_TO_ADDR
98512: END
// every 10 do var i ;
98513: GO 98515
98515: DISABLE
98516: LD_INT 0
98518: PPUSH
// begin enable ;
98519: ENABLE
// if not hInvincible then
98520: LD_EXP 180
98524: NOT
98525: IFFALSE 98529
// exit ;
98527: GO 98573
// for i in hInvincible do
98529: LD_ADDR_VAR 0 1
98533: PUSH
98534: LD_EXP 180
98538: PUSH
98539: FOR_IN
98540: IFFALSE 98571
// if GetLives ( i ) < 1000 then
98542: LD_VAR 0 1
98546: PPUSH
98547: CALL_OW 256
98551: PUSH
98552: LD_INT 1000
98554: LESS
98555: IFFALSE 98569
// SetLives ( i , 1000 ) ;
98557: LD_VAR 0 1
98561: PPUSH
98562: LD_INT 1000
98564: PPUSH
98565: CALL_OW 234
98569: GO 98539
98571: POP
98572: POP
// end ;
98573: PPOPN 1
98575: END
// export function hHackInvincible ; var i ; begin
98576: LD_INT 0
98578: PPUSH
98579: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
98580: LD_ADDR_VAR 0 2
98584: PUSH
98585: LD_INT 2
98587: PUSH
98588: LD_INT 21
98590: PUSH
98591: LD_INT 1
98593: PUSH
98594: EMPTY
98595: LIST
98596: LIST
98597: PUSH
98598: LD_INT 21
98600: PUSH
98601: LD_INT 2
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: EMPTY
98609: LIST
98610: LIST
98611: LIST
98612: PPUSH
98613: CALL_OW 69
98617: PUSH
98618: FOR_IN
98619: IFFALSE 98680
// if IsSelected ( i ) then
98621: LD_VAR 0 2
98625: PPUSH
98626: CALL_OW 306
98630: IFFALSE 98678
// begin if i in hInvincible then
98632: LD_VAR 0 2
98636: PUSH
98637: LD_EXP 180
98641: IN
98642: IFFALSE 98662
// hInvincible := hInvincible diff i else
98644: LD_ADDR_EXP 180
98648: PUSH
98649: LD_EXP 180
98653: PUSH
98654: LD_VAR 0 2
98658: DIFF
98659: ST_TO_ADDR
98660: GO 98678
// hInvincible := hInvincible union i ;
98662: LD_ADDR_EXP 180
98666: PUSH
98667: LD_EXP 180
98671: PUSH
98672: LD_VAR 0 2
98676: UNION
98677: ST_TO_ADDR
// end ;
98678: GO 98618
98680: POP
98681: POP
// end ;
98682: LD_VAR 0 1
98686: RET
// export function hHackInvisible ; var i , j ; begin
98687: LD_INT 0
98689: PPUSH
98690: PPUSH
98691: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
98692: LD_ADDR_VAR 0 2
98696: PUSH
98697: LD_INT 21
98699: PUSH
98700: LD_INT 1
98702: PUSH
98703: EMPTY
98704: LIST
98705: LIST
98706: PPUSH
98707: CALL_OW 69
98711: PUSH
98712: FOR_IN
98713: IFFALSE 98737
// if IsSelected ( i ) then
98715: LD_VAR 0 2
98719: PPUSH
98720: CALL_OW 306
98724: IFFALSE 98735
// ComForceInvisible ( i ) ;
98726: LD_VAR 0 2
98730: PPUSH
98731: CALL_OW 496
98735: GO 98712
98737: POP
98738: POP
// end ;
98739: LD_VAR 0 1
98743: RET
// export function hHackChangeYourSide ; begin
98744: LD_INT 0
98746: PPUSH
// if your_side = 8 then
98747: LD_OWVAR 2
98751: PUSH
98752: LD_INT 8
98754: EQUAL
98755: IFFALSE 98767
// your_side := 0 else
98757: LD_ADDR_OWVAR 2
98761: PUSH
98762: LD_INT 0
98764: ST_TO_ADDR
98765: GO 98781
// your_side := your_side + 1 ;
98767: LD_ADDR_OWVAR 2
98771: PUSH
98772: LD_OWVAR 2
98776: PUSH
98777: LD_INT 1
98779: PLUS
98780: ST_TO_ADDR
// end ;
98781: LD_VAR 0 1
98785: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98786: LD_INT 0
98788: PPUSH
98789: PPUSH
98790: PPUSH
// for i in all_units do
98791: LD_ADDR_VAR 0 2
98795: PUSH
98796: LD_OWVAR 3
98800: PUSH
98801: FOR_IN
98802: IFFALSE 98880
// if IsSelected ( i ) then
98804: LD_VAR 0 2
98808: PPUSH
98809: CALL_OW 306
98813: IFFALSE 98878
// begin j := GetSide ( i ) ;
98815: LD_ADDR_VAR 0 3
98819: PUSH
98820: LD_VAR 0 2
98824: PPUSH
98825: CALL_OW 255
98829: ST_TO_ADDR
// if j = 8 then
98830: LD_VAR 0 3
98834: PUSH
98835: LD_INT 8
98837: EQUAL
98838: IFFALSE 98850
// j := 0 else
98840: LD_ADDR_VAR 0 3
98844: PUSH
98845: LD_INT 0
98847: ST_TO_ADDR
98848: GO 98864
// j := j + 1 ;
98850: LD_ADDR_VAR 0 3
98854: PUSH
98855: LD_VAR 0 3
98859: PUSH
98860: LD_INT 1
98862: PLUS
98863: ST_TO_ADDR
// SetSide ( i , j ) ;
98864: LD_VAR 0 2
98868: PPUSH
98869: LD_VAR 0 3
98873: PPUSH
98874: CALL_OW 235
// end ;
98878: GO 98801
98880: POP
98881: POP
// end ;
98882: LD_VAR 0 1
98886: RET
// export function hHackFog ; begin
98887: LD_INT 0
98889: PPUSH
// FogOff ( true ) ;
98890: LD_INT 1
98892: PPUSH
98893: CALL_OW 344
// end ;
98897: LD_VAR 0 1
98901: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98902: LD_INT 0
98904: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98905: LD_VAR 0 1
98909: PPUSH
98910: LD_VAR 0 2
98914: PPUSH
98915: LD_VAR 0 3
98919: PPUSH
98920: LD_INT 1
98922: PPUSH
98923: LD_INT 1
98925: PPUSH
98926: CALL_OW 483
// CenterOnXY ( x , y ) ;
98930: LD_VAR 0 2
98934: PPUSH
98935: LD_VAR 0 3
98939: PPUSH
98940: CALL_OW 84
// end ; end_of_file
98944: LD_VAR 0 4
98948: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98949: LD_INT 0
98951: PPUSH
98952: PPUSH
98953: PPUSH
98954: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98955: LD_VAR 0 1
98959: PPUSH
98960: CALL_OW 264
98964: PUSH
98965: LD_EXP 108
98969: EQUAL
98970: IFFALSE 99042
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98972: LD_INT 68
98974: PPUSH
98975: LD_VAR 0 1
98979: PPUSH
98980: CALL_OW 255
98984: PPUSH
98985: CALL_OW 321
98989: PUSH
98990: LD_INT 2
98992: EQUAL
98993: IFFALSE 99005
// eff := 70 else
98995: LD_ADDR_VAR 0 4
98999: PUSH
99000: LD_INT 70
99002: ST_TO_ADDR
99003: GO 99013
// eff := 30 ;
99005: LD_ADDR_VAR 0 4
99009: PUSH
99010: LD_INT 30
99012: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
99013: LD_VAR 0 1
99017: PPUSH
99018: CALL_OW 250
99022: PPUSH
99023: LD_VAR 0 1
99027: PPUSH
99028: CALL_OW 251
99032: PPUSH
99033: LD_VAR 0 4
99037: PPUSH
99038: CALL_OW 495
// end ; end ;
99042: LD_VAR 0 2
99046: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
99047: LD_INT 0
99049: PPUSH
// end ;
99050: LD_VAR 0 4
99054: RET
// export function SOS_Command ( cmd ) ; begin
99055: LD_INT 0
99057: PPUSH
// end ;
99058: LD_VAR 0 2
99062: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
99063: LD_INT 0
99065: PPUSH
// end ;
99066: LD_VAR 0 6
99070: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
99071: LD_INT 0
99073: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
99074: LD_VAR 0 1
99078: PUSH
99079: LD_INT 250
99081: EQUAL
99082: PUSH
99083: LD_VAR 0 2
99087: PPUSH
99088: CALL_OW 264
99092: PUSH
99093: LD_EXP 111
99097: EQUAL
99098: AND
99099: IFFALSE 99120
// MinerPlaceMine ( unit , x , y ) ;
99101: LD_VAR 0 2
99105: PPUSH
99106: LD_VAR 0 4
99110: PPUSH
99111: LD_VAR 0 5
99115: PPUSH
99116: CALL 101469 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
99120: LD_VAR 0 1
99124: PUSH
99125: LD_INT 251
99127: EQUAL
99128: PUSH
99129: LD_VAR 0 2
99133: PPUSH
99134: CALL_OW 264
99138: PUSH
99139: LD_EXP 111
99143: EQUAL
99144: AND
99145: IFFALSE 99166
// MinerDetonateMine ( unit , x , y ) ;
99147: LD_VAR 0 2
99151: PPUSH
99152: LD_VAR 0 4
99156: PPUSH
99157: LD_VAR 0 5
99161: PPUSH
99162: CALL 101746 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
99166: LD_VAR 0 1
99170: PUSH
99171: LD_INT 252
99173: EQUAL
99174: PUSH
99175: LD_VAR 0 2
99179: PPUSH
99180: CALL_OW 264
99184: PUSH
99185: LD_EXP 111
99189: EQUAL
99190: AND
99191: IFFALSE 99212
// MinerCreateMinefield ( unit , x , y ) ;
99193: LD_VAR 0 2
99197: PPUSH
99198: LD_VAR 0 4
99202: PPUSH
99203: LD_VAR 0 5
99207: PPUSH
99208: CALL 102163 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
99212: LD_VAR 0 1
99216: PUSH
99217: LD_INT 253
99219: EQUAL
99220: PUSH
99221: LD_VAR 0 2
99225: PPUSH
99226: CALL_OW 257
99230: PUSH
99231: LD_INT 5
99233: EQUAL
99234: AND
99235: IFFALSE 99256
// ComBinocular ( unit , x , y ) ;
99237: LD_VAR 0 2
99241: PPUSH
99242: LD_VAR 0 4
99246: PPUSH
99247: LD_VAR 0 5
99251: PPUSH
99252: CALL 102534 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
99256: LD_VAR 0 1
99260: PUSH
99261: LD_INT 254
99263: EQUAL
99264: PUSH
99265: LD_VAR 0 2
99269: PPUSH
99270: CALL_OW 264
99274: PUSH
99275: LD_EXP 106
99279: EQUAL
99280: AND
99281: PUSH
99282: LD_VAR 0 3
99286: PPUSH
99287: CALL_OW 263
99291: PUSH
99292: LD_INT 3
99294: EQUAL
99295: AND
99296: IFFALSE 99312
// HackDestroyVehicle ( unit , selectedUnit ) ;
99298: LD_VAR 0 2
99302: PPUSH
99303: LD_VAR 0 3
99307: PPUSH
99308: CALL 100829 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
99312: LD_VAR 0 1
99316: PUSH
99317: LD_INT 255
99319: EQUAL
99320: PUSH
99321: LD_VAR 0 2
99325: PPUSH
99326: CALL_OW 264
99330: PUSH
99331: LD_INT 14
99333: PUSH
99334: LD_INT 53
99336: PUSH
99337: EMPTY
99338: LIST
99339: LIST
99340: IN
99341: AND
99342: PUSH
99343: LD_VAR 0 4
99347: PPUSH
99348: LD_VAR 0 5
99352: PPUSH
99353: CALL_OW 488
99357: AND
99358: IFFALSE 99382
// CutTreeXYR ( unit , x , y , 12 ) ;
99360: LD_VAR 0 2
99364: PPUSH
99365: LD_VAR 0 4
99369: PPUSH
99370: LD_VAR 0 5
99374: PPUSH
99375: LD_INT 12
99377: PPUSH
99378: CALL 99395 0 4
// end ;
99382: LD_VAR 0 6
99386: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
99387: LD_INT 0
99389: PPUSH
// end ;
99390: LD_VAR 0 4
99394: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
99395: LD_INT 0
99397: PPUSH
99398: PPUSH
99399: PPUSH
99400: PPUSH
99401: PPUSH
99402: PPUSH
99403: PPUSH
99404: PPUSH
99405: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
99406: LD_VAR 0 1
99410: NOT
99411: PUSH
99412: LD_VAR 0 2
99416: PPUSH
99417: LD_VAR 0 3
99421: PPUSH
99422: CALL_OW 488
99426: NOT
99427: OR
99428: PUSH
99429: LD_VAR 0 4
99433: NOT
99434: OR
99435: IFFALSE 99439
// exit ;
99437: GO 99779
// list := [ ] ;
99439: LD_ADDR_VAR 0 13
99443: PUSH
99444: EMPTY
99445: ST_TO_ADDR
// if x - r < 0 then
99446: LD_VAR 0 2
99450: PUSH
99451: LD_VAR 0 4
99455: MINUS
99456: PUSH
99457: LD_INT 0
99459: LESS
99460: IFFALSE 99472
// min_x := 0 else
99462: LD_ADDR_VAR 0 7
99466: PUSH
99467: LD_INT 0
99469: ST_TO_ADDR
99470: GO 99488
// min_x := x - r ;
99472: LD_ADDR_VAR 0 7
99476: PUSH
99477: LD_VAR 0 2
99481: PUSH
99482: LD_VAR 0 4
99486: MINUS
99487: ST_TO_ADDR
// if y - r < 0 then
99488: LD_VAR 0 3
99492: PUSH
99493: LD_VAR 0 4
99497: MINUS
99498: PUSH
99499: LD_INT 0
99501: LESS
99502: IFFALSE 99514
// min_y := 0 else
99504: LD_ADDR_VAR 0 8
99508: PUSH
99509: LD_INT 0
99511: ST_TO_ADDR
99512: GO 99530
// min_y := y - r ;
99514: LD_ADDR_VAR 0 8
99518: PUSH
99519: LD_VAR 0 3
99523: PUSH
99524: LD_VAR 0 4
99528: MINUS
99529: ST_TO_ADDR
// max_x := x + r ;
99530: LD_ADDR_VAR 0 9
99534: PUSH
99535: LD_VAR 0 2
99539: PUSH
99540: LD_VAR 0 4
99544: PLUS
99545: ST_TO_ADDR
// max_y := y + r ;
99546: LD_ADDR_VAR 0 10
99550: PUSH
99551: LD_VAR 0 3
99555: PUSH
99556: LD_VAR 0 4
99560: PLUS
99561: ST_TO_ADDR
// for _x = min_x to max_x do
99562: LD_ADDR_VAR 0 11
99566: PUSH
99567: DOUBLE
99568: LD_VAR 0 7
99572: DEC
99573: ST_TO_ADDR
99574: LD_VAR 0 9
99578: PUSH
99579: FOR_TO
99580: IFFALSE 99697
// for _y = min_y to max_y do
99582: LD_ADDR_VAR 0 12
99586: PUSH
99587: DOUBLE
99588: LD_VAR 0 8
99592: DEC
99593: ST_TO_ADDR
99594: LD_VAR 0 10
99598: PUSH
99599: FOR_TO
99600: IFFALSE 99693
// begin if not ValidHex ( _x , _y ) then
99602: LD_VAR 0 11
99606: PPUSH
99607: LD_VAR 0 12
99611: PPUSH
99612: CALL_OW 488
99616: NOT
99617: IFFALSE 99621
// continue ;
99619: GO 99599
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
99621: LD_VAR 0 11
99625: PPUSH
99626: LD_VAR 0 12
99630: PPUSH
99631: CALL_OW 351
99635: PUSH
99636: LD_VAR 0 11
99640: PPUSH
99641: LD_VAR 0 12
99645: PPUSH
99646: CALL_OW 554
99650: AND
99651: IFFALSE 99691
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
99653: LD_ADDR_VAR 0 13
99657: PUSH
99658: LD_VAR 0 13
99662: PPUSH
99663: LD_VAR 0 13
99667: PUSH
99668: LD_INT 1
99670: PLUS
99671: PPUSH
99672: LD_VAR 0 11
99676: PUSH
99677: LD_VAR 0 12
99681: PUSH
99682: EMPTY
99683: LIST
99684: LIST
99685: PPUSH
99686: CALL_OW 2
99690: ST_TO_ADDR
// end ;
99691: GO 99599
99693: POP
99694: POP
99695: GO 99579
99697: POP
99698: POP
// if not list then
99699: LD_VAR 0 13
99703: NOT
99704: IFFALSE 99708
// exit ;
99706: GO 99779
// for i in list do
99708: LD_ADDR_VAR 0 6
99712: PUSH
99713: LD_VAR 0 13
99717: PUSH
99718: FOR_IN
99719: IFFALSE 99777
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
99721: LD_VAR 0 1
99725: PPUSH
99726: LD_STRING M
99728: PUSH
99729: LD_VAR 0 6
99733: PUSH
99734: LD_INT 1
99736: ARRAY
99737: PUSH
99738: LD_VAR 0 6
99742: PUSH
99743: LD_INT 2
99745: ARRAY
99746: PUSH
99747: LD_INT 0
99749: PUSH
99750: LD_INT 0
99752: PUSH
99753: LD_INT 0
99755: PUSH
99756: LD_INT 0
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: LIST
99765: LIST
99766: LIST
99767: PUSH
99768: EMPTY
99769: LIST
99770: PPUSH
99771: CALL_OW 447
99775: GO 99718
99777: POP
99778: POP
// end ;
99779: LD_VAR 0 5
99783: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99784: LD_EXP 183
99788: NOT
99789: IFFALSE 99839
99791: GO 99793
99793: DISABLE
// begin initHack := true ;
99794: LD_ADDR_EXP 183
99798: PUSH
99799: LD_INT 1
99801: ST_TO_ADDR
// hackTanks := [ ] ;
99802: LD_ADDR_EXP 184
99806: PUSH
99807: EMPTY
99808: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99809: LD_ADDR_EXP 185
99813: PUSH
99814: EMPTY
99815: ST_TO_ADDR
// hackLimit := 3 ;
99816: LD_ADDR_EXP 186
99820: PUSH
99821: LD_INT 3
99823: ST_TO_ADDR
// hackDist := 12 ;
99824: LD_ADDR_EXP 187
99828: PUSH
99829: LD_INT 12
99831: ST_TO_ADDR
// hackCounter := [ ] ;
99832: LD_ADDR_EXP 188
99836: PUSH
99837: EMPTY
99838: ST_TO_ADDR
// end ;
99839: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99840: LD_EXP 183
99844: PUSH
99845: LD_INT 34
99847: PUSH
99848: LD_EXP 106
99852: PUSH
99853: EMPTY
99854: LIST
99855: LIST
99856: PPUSH
99857: CALL_OW 69
99861: AND
99862: IFFALSE 100117
99864: GO 99866
99866: DISABLE
99867: LD_INT 0
99869: PPUSH
99870: PPUSH
// begin enable ;
99871: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99872: LD_ADDR_VAR 0 1
99876: PUSH
99877: LD_INT 34
99879: PUSH
99880: LD_EXP 106
99884: PUSH
99885: EMPTY
99886: LIST
99887: LIST
99888: PPUSH
99889: CALL_OW 69
99893: PUSH
99894: FOR_IN
99895: IFFALSE 100115
// begin if not i in hackTanks then
99897: LD_VAR 0 1
99901: PUSH
99902: LD_EXP 184
99906: IN
99907: NOT
99908: IFFALSE 99991
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99910: LD_ADDR_EXP 184
99914: PUSH
99915: LD_EXP 184
99919: PPUSH
99920: LD_EXP 184
99924: PUSH
99925: LD_INT 1
99927: PLUS
99928: PPUSH
99929: LD_VAR 0 1
99933: PPUSH
99934: CALL_OW 1
99938: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99939: LD_ADDR_EXP 185
99943: PUSH
99944: LD_EXP 185
99948: PPUSH
99949: LD_EXP 185
99953: PUSH
99954: LD_INT 1
99956: PLUS
99957: PPUSH
99958: EMPTY
99959: PPUSH
99960: CALL_OW 1
99964: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99965: LD_ADDR_EXP 188
99969: PUSH
99970: LD_EXP 188
99974: PPUSH
99975: LD_EXP 188
99979: PUSH
99980: LD_INT 1
99982: PLUS
99983: PPUSH
99984: EMPTY
99985: PPUSH
99986: CALL_OW 1
99990: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99991: LD_VAR 0 1
99995: PPUSH
99996: CALL_OW 302
100000: NOT
100001: IFFALSE 100014
// begin HackUnlinkAll ( i ) ;
100003: LD_VAR 0 1
100007: PPUSH
100008: CALL 100120 0 1
// continue ;
100012: GO 99894
// end ; HackCheckCapturedStatus ( i ) ;
100014: LD_VAR 0 1
100018: PPUSH
100019: CALL 100563 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
100023: LD_ADDR_VAR 0 2
100027: PUSH
100028: LD_INT 81
100030: PUSH
100031: LD_VAR 0 1
100035: PPUSH
100036: CALL_OW 255
100040: PUSH
100041: EMPTY
100042: LIST
100043: LIST
100044: PUSH
100045: LD_INT 33
100047: PUSH
100048: LD_INT 3
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PUSH
100055: LD_INT 91
100057: PUSH
100058: LD_VAR 0 1
100062: PUSH
100063: LD_EXP 187
100067: PUSH
100068: EMPTY
100069: LIST
100070: LIST
100071: LIST
100072: PUSH
100073: LD_INT 50
100075: PUSH
100076: EMPTY
100077: LIST
100078: PUSH
100079: EMPTY
100080: LIST
100081: LIST
100082: LIST
100083: LIST
100084: PPUSH
100085: CALL_OW 69
100089: ST_TO_ADDR
// if not tmp then
100090: LD_VAR 0 2
100094: NOT
100095: IFFALSE 100099
// continue ;
100097: GO 99894
// HackLink ( i , tmp ) ;
100099: LD_VAR 0 1
100103: PPUSH
100104: LD_VAR 0 2
100108: PPUSH
100109: CALL 100256 0 2
// end ;
100113: GO 99894
100115: POP
100116: POP
// end ;
100117: PPOPN 2
100119: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
100120: LD_INT 0
100122: PPUSH
100123: PPUSH
100124: PPUSH
// if not hack in hackTanks then
100125: LD_VAR 0 1
100129: PUSH
100130: LD_EXP 184
100134: IN
100135: NOT
100136: IFFALSE 100140
// exit ;
100138: GO 100251
// index := GetElementIndex ( hackTanks , hack ) ;
100140: LD_ADDR_VAR 0 4
100144: PUSH
100145: LD_EXP 184
100149: PPUSH
100150: LD_VAR 0 1
100154: PPUSH
100155: CALL 19586 0 2
100159: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
100160: LD_EXP 185
100164: PUSH
100165: LD_VAR 0 4
100169: ARRAY
100170: IFFALSE 100251
// begin for i in hackTanksCaptured [ index ] do
100172: LD_ADDR_VAR 0 3
100176: PUSH
100177: LD_EXP 185
100181: PUSH
100182: LD_VAR 0 4
100186: ARRAY
100187: PUSH
100188: FOR_IN
100189: IFFALSE 100215
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
100191: LD_VAR 0 3
100195: PUSH
100196: LD_INT 1
100198: ARRAY
100199: PPUSH
100200: LD_VAR 0 3
100204: PUSH
100205: LD_INT 2
100207: ARRAY
100208: PPUSH
100209: CALL_OW 235
100213: GO 100188
100215: POP
100216: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
100217: LD_ADDR_EXP 185
100221: PUSH
100222: LD_EXP 185
100226: PPUSH
100227: LD_VAR 0 4
100231: PPUSH
100232: EMPTY
100233: PPUSH
100234: CALL_OW 1
100238: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
100239: LD_VAR 0 1
100243: PPUSH
100244: LD_INT 0
100246: PPUSH
100247: CALL_OW 505
// end ; end ;
100251: LD_VAR 0 2
100255: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
100256: LD_INT 0
100258: PPUSH
100259: PPUSH
100260: PPUSH
// if not hack in hackTanks or not vehicles then
100261: LD_VAR 0 1
100265: PUSH
100266: LD_EXP 184
100270: IN
100271: NOT
100272: PUSH
100273: LD_VAR 0 2
100277: NOT
100278: OR
100279: IFFALSE 100283
// exit ;
100281: GO 100558
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
100283: LD_ADDR_VAR 0 2
100287: PUSH
100288: LD_VAR 0 1
100292: PPUSH
100293: LD_VAR 0 2
100297: PPUSH
100298: LD_INT 1
100300: PPUSH
100301: LD_INT 1
100303: PPUSH
100304: CALL 20236 0 4
100308: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
100309: LD_ADDR_VAR 0 5
100313: PUSH
100314: LD_EXP 184
100318: PPUSH
100319: LD_VAR 0 1
100323: PPUSH
100324: CALL 19586 0 2
100328: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
100329: LD_EXP 185
100333: PUSH
100334: LD_VAR 0 5
100338: ARRAY
100339: PUSH
100340: LD_EXP 186
100344: LESS
100345: IFFALSE 100534
// begin for i := 1 to vehicles do
100347: LD_ADDR_VAR 0 4
100351: PUSH
100352: DOUBLE
100353: LD_INT 1
100355: DEC
100356: ST_TO_ADDR
100357: LD_VAR 0 2
100361: PUSH
100362: FOR_TO
100363: IFFALSE 100532
// begin if hackTanksCaptured [ index ] = hackLimit then
100365: LD_EXP 185
100369: PUSH
100370: LD_VAR 0 5
100374: ARRAY
100375: PUSH
100376: LD_EXP 186
100380: EQUAL
100381: IFFALSE 100385
// break ;
100383: GO 100532
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
100385: LD_ADDR_EXP 188
100389: PUSH
100390: LD_EXP 188
100394: PPUSH
100395: LD_VAR 0 5
100399: PPUSH
100400: LD_EXP 188
100404: PUSH
100405: LD_VAR 0 5
100409: ARRAY
100410: PUSH
100411: LD_INT 1
100413: PLUS
100414: PPUSH
100415: CALL_OW 1
100419: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
100420: LD_ADDR_EXP 185
100424: PUSH
100425: LD_EXP 185
100429: PPUSH
100430: LD_VAR 0 5
100434: PUSH
100435: LD_EXP 185
100439: PUSH
100440: LD_VAR 0 5
100444: ARRAY
100445: PUSH
100446: LD_INT 1
100448: PLUS
100449: PUSH
100450: EMPTY
100451: LIST
100452: LIST
100453: PPUSH
100454: LD_VAR 0 2
100458: PUSH
100459: LD_VAR 0 4
100463: ARRAY
100464: PUSH
100465: LD_VAR 0 2
100469: PUSH
100470: LD_VAR 0 4
100474: ARRAY
100475: PPUSH
100476: CALL_OW 255
100480: PUSH
100481: EMPTY
100482: LIST
100483: LIST
100484: PPUSH
100485: CALL 19801 0 3
100489: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
100490: LD_VAR 0 2
100494: PUSH
100495: LD_VAR 0 4
100499: ARRAY
100500: PPUSH
100501: LD_VAR 0 1
100505: PPUSH
100506: CALL_OW 255
100510: PPUSH
100511: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
100515: LD_VAR 0 2
100519: PUSH
100520: LD_VAR 0 4
100524: ARRAY
100525: PPUSH
100526: CALL_OW 141
// end ;
100530: GO 100362
100532: POP
100533: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100534: LD_VAR 0 1
100538: PPUSH
100539: LD_EXP 185
100543: PUSH
100544: LD_VAR 0 5
100548: ARRAY
100549: PUSH
100550: LD_INT 0
100552: PLUS
100553: PPUSH
100554: CALL_OW 505
// end ;
100558: LD_VAR 0 3
100562: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
100563: LD_INT 0
100565: PPUSH
100566: PPUSH
100567: PPUSH
100568: PPUSH
// if not hack in hackTanks then
100569: LD_VAR 0 1
100573: PUSH
100574: LD_EXP 184
100578: IN
100579: NOT
100580: IFFALSE 100584
// exit ;
100582: GO 100824
// index := GetElementIndex ( hackTanks , hack ) ;
100584: LD_ADDR_VAR 0 4
100588: PUSH
100589: LD_EXP 184
100593: PPUSH
100594: LD_VAR 0 1
100598: PPUSH
100599: CALL 19586 0 2
100603: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
100604: LD_ADDR_VAR 0 3
100608: PUSH
100609: DOUBLE
100610: LD_EXP 185
100614: PUSH
100615: LD_VAR 0 4
100619: ARRAY
100620: INC
100621: ST_TO_ADDR
100622: LD_INT 1
100624: PUSH
100625: FOR_DOWNTO
100626: IFFALSE 100798
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
100628: LD_ADDR_VAR 0 5
100632: PUSH
100633: LD_EXP 185
100637: PUSH
100638: LD_VAR 0 4
100642: ARRAY
100643: PUSH
100644: LD_VAR 0 3
100648: ARRAY
100649: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
100650: LD_VAR 0 5
100654: PUSH
100655: LD_INT 1
100657: ARRAY
100658: PPUSH
100659: CALL_OW 302
100663: NOT
100664: PUSH
100665: LD_VAR 0 5
100669: PUSH
100670: LD_INT 1
100672: ARRAY
100673: PPUSH
100674: CALL_OW 255
100678: PUSH
100679: LD_VAR 0 1
100683: PPUSH
100684: CALL_OW 255
100688: NONEQUAL
100689: OR
100690: IFFALSE 100796
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
100692: LD_VAR 0 5
100696: PUSH
100697: LD_INT 1
100699: ARRAY
100700: PPUSH
100701: CALL_OW 305
100705: PUSH
100706: LD_VAR 0 5
100710: PUSH
100711: LD_INT 1
100713: ARRAY
100714: PPUSH
100715: CALL_OW 255
100719: PUSH
100720: LD_VAR 0 1
100724: PPUSH
100725: CALL_OW 255
100729: EQUAL
100730: AND
100731: IFFALSE 100755
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100733: LD_VAR 0 5
100737: PUSH
100738: LD_INT 1
100740: ARRAY
100741: PPUSH
100742: LD_VAR 0 5
100746: PUSH
100747: LD_INT 2
100749: ARRAY
100750: PPUSH
100751: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100755: LD_ADDR_EXP 185
100759: PUSH
100760: LD_EXP 185
100764: PPUSH
100765: LD_VAR 0 4
100769: PPUSH
100770: LD_EXP 185
100774: PUSH
100775: LD_VAR 0 4
100779: ARRAY
100780: PPUSH
100781: LD_VAR 0 3
100785: PPUSH
100786: CALL_OW 3
100790: PPUSH
100791: CALL_OW 1
100795: ST_TO_ADDR
// end ; end ;
100796: GO 100625
100798: POP
100799: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100800: LD_VAR 0 1
100804: PPUSH
100805: LD_EXP 185
100809: PUSH
100810: LD_VAR 0 4
100814: ARRAY
100815: PUSH
100816: LD_INT 0
100818: PLUS
100819: PPUSH
100820: CALL_OW 505
// end ;
100824: LD_VAR 0 2
100828: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100829: LD_INT 0
100831: PPUSH
100832: PPUSH
100833: PPUSH
100834: PPUSH
// if not hack in hackTanks then
100835: LD_VAR 0 1
100839: PUSH
100840: LD_EXP 184
100844: IN
100845: NOT
100846: IFFALSE 100850
// exit ;
100848: GO 100935
// index := GetElementIndex ( hackTanks , hack ) ;
100850: LD_ADDR_VAR 0 5
100854: PUSH
100855: LD_EXP 184
100859: PPUSH
100860: LD_VAR 0 1
100864: PPUSH
100865: CALL 19586 0 2
100869: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100870: LD_ADDR_VAR 0 4
100874: PUSH
100875: DOUBLE
100876: LD_INT 1
100878: DEC
100879: ST_TO_ADDR
100880: LD_EXP 185
100884: PUSH
100885: LD_VAR 0 5
100889: ARRAY
100890: PUSH
100891: FOR_TO
100892: IFFALSE 100933
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100894: LD_EXP 185
100898: PUSH
100899: LD_VAR 0 5
100903: ARRAY
100904: PUSH
100905: LD_VAR 0 4
100909: ARRAY
100910: PUSH
100911: LD_INT 1
100913: ARRAY
100914: PUSH
100915: LD_VAR 0 2
100919: EQUAL
100920: IFFALSE 100931
// KillUnit ( vehicle ) ;
100922: LD_VAR 0 2
100926: PPUSH
100927: CALL_OW 66
100931: GO 100891
100933: POP
100934: POP
// end ;
100935: LD_VAR 0 3
100939: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100940: LD_EXP 189
100944: NOT
100945: IFFALSE 100980
100947: GO 100949
100949: DISABLE
// begin initMiner := true ;
100950: LD_ADDR_EXP 189
100954: PUSH
100955: LD_INT 1
100957: ST_TO_ADDR
// minersList := [ ] ;
100958: LD_ADDR_EXP 190
100962: PUSH
100963: EMPTY
100964: ST_TO_ADDR
// minerMinesList := [ ] ;
100965: LD_ADDR_EXP 191
100969: PUSH
100970: EMPTY
100971: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100972: LD_ADDR_EXP 192
100976: PUSH
100977: LD_INT 5
100979: ST_TO_ADDR
// end ;
100980: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100981: LD_EXP 189
100985: PUSH
100986: LD_INT 34
100988: PUSH
100989: LD_EXP 111
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: PPUSH
100998: CALL_OW 69
101002: AND
101003: IFFALSE 101466
101005: GO 101007
101007: DISABLE
101008: LD_INT 0
101010: PPUSH
101011: PPUSH
101012: PPUSH
101013: PPUSH
// begin enable ;
101014: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
101015: LD_ADDR_VAR 0 1
101019: PUSH
101020: LD_INT 34
101022: PUSH
101023: LD_EXP 111
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: PPUSH
101032: CALL_OW 69
101036: PUSH
101037: FOR_IN
101038: IFFALSE 101110
// begin if not i in minersList then
101040: LD_VAR 0 1
101044: PUSH
101045: LD_EXP 190
101049: IN
101050: NOT
101051: IFFALSE 101108
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
101053: LD_ADDR_EXP 190
101057: PUSH
101058: LD_EXP 190
101062: PPUSH
101063: LD_EXP 190
101067: PUSH
101068: LD_INT 1
101070: PLUS
101071: PPUSH
101072: LD_VAR 0 1
101076: PPUSH
101077: CALL_OW 1
101081: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
101082: LD_ADDR_EXP 191
101086: PUSH
101087: LD_EXP 191
101091: PPUSH
101092: LD_EXP 191
101096: PUSH
101097: LD_INT 1
101099: PLUS
101100: PPUSH
101101: EMPTY
101102: PPUSH
101103: CALL_OW 1
101107: ST_TO_ADDR
// end end ;
101108: GO 101037
101110: POP
101111: POP
// for i := minerMinesList downto 1 do
101112: LD_ADDR_VAR 0 1
101116: PUSH
101117: DOUBLE
101118: LD_EXP 191
101122: INC
101123: ST_TO_ADDR
101124: LD_INT 1
101126: PUSH
101127: FOR_DOWNTO
101128: IFFALSE 101464
// begin if IsLive ( minersList [ i ] ) then
101130: LD_EXP 190
101134: PUSH
101135: LD_VAR 0 1
101139: ARRAY
101140: PPUSH
101141: CALL_OW 300
101145: IFFALSE 101173
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
101147: LD_EXP 190
101151: PUSH
101152: LD_VAR 0 1
101156: ARRAY
101157: PPUSH
101158: LD_EXP 191
101162: PUSH
101163: LD_VAR 0 1
101167: ARRAY
101168: PPUSH
101169: CALL_OW 505
// if not minerMinesList [ i ] then
101173: LD_EXP 191
101177: PUSH
101178: LD_VAR 0 1
101182: ARRAY
101183: NOT
101184: IFFALSE 101188
// continue ;
101186: GO 101127
// for j := minerMinesList [ i ] downto 1 do
101188: LD_ADDR_VAR 0 2
101192: PUSH
101193: DOUBLE
101194: LD_EXP 191
101198: PUSH
101199: LD_VAR 0 1
101203: ARRAY
101204: INC
101205: ST_TO_ADDR
101206: LD_INT 1
101208: PUSH
101209: FOR_DOWNTO
101210: IFFALSE 101460
// begin side := GetSide ( minersList [ i ] ) ;
101212: LD_ADDR_VAR 0 3
101216: PUSH
101217: LD_EXP 190
101221: PUSH
101222: LD_VAR 0 1
101226: ARRAY
101227: PPUSH
101228: CALL_OW 255
101232: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
101233: LD_ADDR_VAR 0 4
101237: PUSH
101238: LD_EXP 191
101242: PUSH
101243: LD_VAR 0 1
101247: ARRAY
101248: PUSH
101249: LD_VAR 0 2
101253: ARRAY
101254: PUSH
101255: LD_INT 1
101257: ARRAY
101258: PPUSH
101259: LD_EXP 191
101263: PUSH
101264: LD_VAR 0 1
101268: ARRAY
101269: PUSH
101270: LD_VAR 0 2
101274: ARRAY
101275: PUSH
101276: LD_INT 2
101278: ARRAY
101279: PPUSH
101280: CALL_OW 428
101284: ST_TO_ADDR
// if not tmp then
101285: LD_VAR 0 4
101289: NOT
101290: IFFALSE 101294
// continue ;
101292: GO 101209
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
101294: LD_VAR 0 4
101298: PUSH
101299: LD_INT 81
101301: PUSH
101302: LD_VAR 0 3
101306: PUSH
101307: EMPTY
101308: LIST
101309: LIST
101310: PPUSH
101311: CALL_OW 69
101315: IN
101316: PUSH
101317: LD_EXP 191
101321: PUSH
101322: LD_VAR 0 1
101326: ARRAY
101327: PUSH
101328: LD_VAR 0 2
101332: ARRAY
101333: PUSH
101334: LD_INT 1
101336: ARRAY
101337: PPUSH
101338: LD_EXP 191
101342: PUSH
101343: LD_VAR 0 1
101347: ARRAY
101348: PUSH
101349: LD_VAR 0 2
101353: ARRAY
101354: PUSH
101355: LD_INT 2
101357: ARRAY
101358: PPUSH
101359: CALL_OW 458
101363: AND
101364: IFFALSE 101458
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
101366: LD_EXP 191
101370: PUSH
101371: LD_VAR 0 1
101375: ARRAY
101376: PUSH
101377: LD_VAR 0 2
101381: ARRAY
101382: PUSH
101383: LD_INT 1
101385: ARRAY
101386: PPUSH
101387: LD_EXP 191
101391: PUSH
101392: LD_VAR 0 1
101396: ARRAY
101397: PUSH
101398: LD_VAR 0 2
101402: ARRAY
101403: PUSH
101404: LD_INT 2
101406: ARRAY
101407: PPUSH
101408: LD_VAR 0 3
101412: PPUSH
101413: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
101417: LD_ADDR_EXP 191
101421: PUSH
101422: LD_EXP 191
101426: PPUSH
101427: LD_VAR 0 1
101431: PPUSH
101432: LD_EXP 191
101436: PUSH
101437: LD_VAR 0 1
101441: ARRAY
101442: PPUSH
101443: LD_VAR 0 2
101447: PPUSH
101448: CALL_OW 3
101452: PPUSH
101453: CALL_OW 1
101457: ST_TO_ADDR
// end ; end ;
101458: GO 101209
101460: POP
101461: POP
// end ;
101462: GO 101127
101464: POP
101465: POP
// end ;
101466: PPOPN 4
101468: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
101469: LD_INT 0
101471: PPUSH
101472: PPUSH
// result := false ;
101473: LD_ADDR_VAR 0 4
101477: PUSH
101478: LD_INT 0
101480: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
101481: LD_VAR 0 1
101485: PPUSH
101486: CALL_OW 264
101490: PUSH
101491: LD_EXP 111
101495: EQUAL
101496: NOT
101497: IFFALSE 101501
// exit ;
101499: GO 101741
// index := GetElementIndex ( minersList , unit ) ;
101501: LD_ADDR_VAR 0 5
101505: PUSH
101506: LD_EXP 190
101510: PPUSH
101511: LD_VAR 0 1
101515: PPUSH
101516: CALL 19586 0 2
101520: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
101521: LD_EXP 191
101525: PUSH
101526: LD_VAR 0 5
101530: ARRAY
101531: PUSH
101532: LD_EXP 192
101536: GREATEREQUAL
101537: IFFALSE 101541
// exit ;
101539: GO 101741
// ComMoveXY ( unit , x , y ) ;
101541: LD_VAR 0 1
101545: PPUSH
101546: LD_VAR 0 2
101550: PPUSH
101551: LD_VAR 0 3
101555: PPUSH
101556: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101560: LD_INT 35
101562: PPUSH
101563: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
101567: LD_VAR 0 1
101571: PPUSH
101572: LD_VAR 0 2
101576: PPUSH
101577: LD_VAR 0 3
101581: PPUSH
101582: CALL 50358 0 3
101586: NOT
101587: PUSH
101588: LD_VAR 0 1
101592: PPUSH
101593: CALL_OW 314
101597: AND
101598: IFFALSE 101602
// exit ;
101600: GO 101741
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
101602: LD_VAR 0 2
101606: PPUSH
101607: LD_VAR 0 3
101611: PPUSH
101612: CALL_OW 428
101616: PUSH
101617: LD_VAR 0 1
101621: EQUAL
101622: PUSH
101623: LD_VAR 0 1
101627: PPUSH
101628: CALL_OW 314
101632: NOT
101633: AND
101634: IFFALSE 101560
// PlaySoundXY ( x , y , PlantMine ) ;
101636: LD_VAR 0 2
101640: PPUSH
101641: LD_VAR 0 3
101645: PPUSH
101646: LD_STRING PlantMine
101648: PPUSH
101649: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
101653: LD_VAR 0 2
101657: PPUSH
101658: LD_VAR 0 3
101662: PPUSH
101663: LD_VAR 0 1
101667: PPUSH
101668: CALL_OW 255
101672: PPUSH
101673: LD_INT 0
101675: PPUSH
101676: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
101680: LD_ADDR_EXP 191
101684: PUSH
101685: LD_EXP 191
101689: PPUSH
101690: LD_VAR 0 5
101694: PUSH
101695: LD_EXP 191
101699: PUSH
101700: LD_VAR 0 5
101704: ARRAY
101705: PUSH
101706: LD_INT 1
101708: PLUS
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: PPUSH
101714: LD_VAR 0 2
101718: PUSH
101719: LD_VAR 0 3
101723: PUSH
101724: EMPTY
101725: LIST
101726: LIST
101727: PPUSH
101728: CALL 19801 0 3
101732: ST_TO_ADDR
// result := true ;
101733: LD_ADDR_VAR 0 4
101737: PUSH
101738: LD_INT 1
101740: ST_TO_ADDR
// end ;
101741: LD_VAR 0 4
101745: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101746: LD_INT 0
101748: PPUSH
101749: PPUSH
101750: PPUSH
// if not unit in minersList then
101751: LD_VAR 0 1
101755: PUSH
101756: LD_EXP 190
101760: IN
101761: NOT
101762: IFFALSE 101766
// exit ;
101764: GO 102158
// index := GetElementIndex ( minersList , unit ) ;
101766: LD_ADDR_VAR 0 6
101770: PUSH
101771: LD_EXP 190
101775: PPUSH
101776: LD_VAR 0 1
101780: PPUSH
101781: CALL 19586 0 2
101785: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101786: LD_ADDR_VAR 0 5
101790: PUSH
101791: DOUBLE
101792: LD_EXP 191
101796: PUSH
101797: LD_VAR 0 6
101801: ARRAY
101802: INC
101803: ST_TO_ADDR
101804: LD_INT 1
101806: PUSH
101807: FOR_DOWNTO
101808: IFFALSE 101969
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101810: LD_EXP 191
101814: PUSH
101815: LD_VAR 0 6
101819: ARRAY
101820: PUSH
101821: LD_VAR 0 5
101825: ARRAY
101826: PUSH
101827: LD_INT 1
101829: ARRAY
101830: PUSH
101831: LD_VAR 0 2
101835: EQUAL
101836: PUSH
101837: LD_EXP 191
101841: PUSH
101842: LD_VAR 0 6
101846: ARRAY
101847: PUSH
101848: LD_VAR 0 5
101852: ARRAY
101853: PUSH
101854: LD_INT 2
101856: ARRAY
101857: PUSH
101858: LD_VAR 0 3
101862: EQUAL
101863: AND
101864: IFFALSE 101967
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101866: LD_EXP 191
101870: PUSH
101871: LD_VAR 0 6
101875: ARRAY
101876: PUSH
101877: LD_VAR 0 5
101881: ARRAY
101882: PUSH
101883: LD_INT 1
101885: ARRAY
101886: PPUSH
101887: LD_EXP 191
101891: PUSH
101892: LD_VAR 0 6
101896: ARRAY
101897: PUSH
101898: LD_VAR 0 5
101902: ARRAY
101903: PUSH
101904: LD_INT 2
101906: ARRAY
101907: PPUSH
101908: LD_VAR 0 1
101912: PPUSH
101913: CALL_OW 255
101917: PPUSH
101918: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101922: LD_ADDR_EXP 191
101926: PUSH
101927: LD_EXP 191
101931: PPUSH
101932: LD_VAR 0 6
101936: PPUSH
101937: LD_EXP 191
101941: PUSH
101942: LD_VAR 0 6
101946: ARRAY
101947: PPUSH
101948: LD_VAR 0 5
101952: PPUSH
101953: CALL_OW 3
101957: PPUSH
101958: CALL_OW 1
101962: ST_TO_ADDR
// exit ;
101963: POP
101964: POP
101965: GO 102158
// end ; end ;
101967: GO 101807
101969: POP
101970: POP
// for i := minerMinesList [ index ] downto 1 do
101971: LD_ADDR_VAR 0 5
101975: PUSH
101976: DOUBLE
101977: LD_EXP 191
101981: PUSH
101982: LD_VAR 0 6
101986: ARRAY
101987: INC
101988: ST_TO_ADDR
101989: LD_INT 1
101991: PUSH
101992: FOR_DOWNTO
101993: IFFALSE 102156
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101995: LD_EXP 191
101999: PUSH
102000: LD_VAR 0 6
102004: ARRAY
102005: PUSH
102006: LD_VAR 0 5
102010: ARRAY
102011: PUSH
102012: LD_INT 1
102014: ARRAY
102015: PPUSH
102016: LD_EXP 191
102020: PUSH
102021: LD_VAR 0 6
102025: ARRAY
102026: PUSH
102027: LD_VAR 0 5
102031: ARRAY
102032: PUSH
102033: LD_INT 2
102035: ARRAY
102036: PPUSH
102037: LD_VAR 0 2
102041: PPUSH
102042: LD_VAR 0 3
102046: PPUSH
102047: CALL_OW 298
102051: PUSH
102052: LD_INT 6
102054: LESS
102055: IFFALSE 102154
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102057: LD_EXP 191
102061: PUSH
102062: LD_VAR 0 6
102066: ARRAY
102067: PUSH
102068: LD_VAR 0 5
102072: ARRAY
102073: PUSH
102074: LD_INT 1
102076: ARRAY
102077: PPUSH
102078: LD_EXP 191
102082: PUSH
102083: LD_VAR 0 6
102087: ARRAY
102088: PUSH
102089: LD_VAR 0 5
102093: ARRAY
102094: PUSH
102095: LD_INT 2
102097: ARRAY
102098: PPUSH
102099: LD_VAR 0 1
102103: PPUSH
102104: CALL_OW 255
102108: PPUSH
102109: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102113: LD_ADDR_EXP 191
102117: PUSH
102118: LD_EXP 191
102122: PPUSH
102123: LD_VAR 0 6
102127: PPUSH
102128: LD_EXP 191
102132: PUSH
102133: LD_VAR 0 6
102137: ARRAY
102138: PPUSH
102139: LD_VAR 0 5
102143: PPUSH
102144: CALL_OW 3
102148: PPUSH
102149: CALL_OW 1
102153: ST_TO_ADDR
// end ; end ;
102154: GO 101992
102156: POP
102157: POP
// end ;
102158: LD_VAR 0 4
102162: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
102163: LD_INT 0
102165: PPUSH
102166: PPUSH
102167: PPUSH
102168: PPUSH
102169: PPUSH
102170: PPUSH
102171: PPUSH
102172: PPUSH
102173: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
102174: LD_VAR 0 1
102178: PPUSH
102179: CALL_OW 264
102183: PUSH
102184: LD_EXP 111
102188: EQUAL
102189: NOT
102190: PUSH
102191: LD_VAR 0 1
102195: PUSH
102196: LD_EXP 190
102200: IN
102201: NOT
102202: OR
102203: IFFALSE 102207
// exit ;
102205: GO 102529
// index := GetElementIndex ( minersList , unit ) ;
102207: LD_ADDR_VAR 0 6
102211: PUSH
102212: LD_EXP 190
102216: PPUSH
102217: LD_VAR 0 1
102221: PPUSH
102222: CALL 19586 0 2
102226: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
102227: LD_ADDR_VAR 0 8
102231: PUSH
102232: LD_EXP 192
102236: PUSH
102237: LD_EXP 191
102241: PUSH
102242: LD_VAR 0 6
102246: ARRAY
102247: MINUS
102248: ST_TO_ADDR
// if not minesFreeAmount then
102249: LD_VAR 0 8
102253: NOT
102254: IFFALSE 102258
// exit ;
102256: GO 102529
// tmp := [ ] ;
102258: LD_ADDR_VAR 0 7
102262: PUSH
102263: EMPTY
102264: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
102265: LD_ADDR_VAR 0 5
102269: PUSH
102270: DOUBLE
102271: LD_INT 1
102273: DEC
102274: ST_TO_ADDR
102275: LD_VAR 0 8
102279: PUSH
102280: FOR_TO
102281: IFFALSE 102476
// begin _d := rand ( 0 , 5 ) ;
102283: LD_ADDR_VAR 0 11
102287: PUSH
102288: LD_INT 0
102290: PPUSH
102291: LD_INT 5
102293: PPUSH
102294: CALL_OW 12
102298: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
102299: LD_ADDR_VAR 0 12
102303: PUSH
102304: LD_INT 2
102306: PPUSH
102307: LD_INT 6
102309: PPUSH
102310: CALL_OW 12
102314: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
102315: LD_ADDR_VAR 0 9
102319: PUSH
102320: LD_VAR 0 2
102324: PPUSH
102325: LD_VAR 0 11
102329: PPUSH
102330: LD_VAR 0 12
102334: PPUSH
102335: CALL_OW 272
102339: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
102340: LD_ADDR_VAR 0 10
102344: PUSH
102345: LD_VAR 0 3
102349: PPUSH
102350: LD_VAR 0 11
102354: PPUSH
102355: LD_VAR 0 12
102359: PPUSH
102360: CALL_OW 273
102364: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
102365: LD_VAR 0 9
102369: PPUSH
102370: LD_VAR 0 10
102374: PPUSH
102375: CALL_OW 488
102379: PUSH
102380: LD_VAR 0 9
102384: PUSH
102385: LD_VAR 0 10
102389: PUSH
102390: EMPTY
102391: LIST
102392: LIST
102393: PUSH
102394: LD_VAR 0 7
102398: IN
102399: NOT
102400: AND
102401: PUSH
102402: LD_VAR 0 9
102406: PPUSH
102407: LD_VAR 0 10
102411: PPUSH
102412: CALL_OW 458
102416: NOT
102417: AND
102418: IFFALSE 102460
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
102420: LD_ADDR_VAR 0 7
102424: PUSH
102425: LD_VAR 0 7
102429: PPUSH
102430: LD_VAR 0 7
102434: PUSH
102435: LD_INT 1
102437: PLUS
102438: PPUSH
102439: LD_VAR 0 9
102443: PUSH
102444: LD_VAR 0 10
102448: PUSH
102449: EMPTY
102450: LIST
102451: LIST
102452: PPUSH
102453: CALL_OW 1
102457: ST_TO_ADDR
102458: GO 102474
// i := i - 1 ;
102460: LD_ADDR_VAR 0 5
102464: PUSH
102465: LD_VAR 0 5
102469: PUSH
102470: LD_INT 1
102472: MINUS
102473: ST_TO_ADDR
// end ;
102474: GO 102280
102476: POP
102477: POP
// for i in tmp do
102478: LD_ADDR_VAR 0 5
102482: PUSH
102483: LD_VAR 0 7
102487: PUSH
102488: FOR_IN
102489: IFFALSE 102527
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
102491: LD_VAR 0 1
102495: PPUSH
102496: LD_VAR 0 5
102500: PUSH
102501: LD_INT 1
102503: ARRAY
102504: PPUSH
102505: LD_VAR 0 5
102509: PUSH
102510: LD_INT 2
102512: ARRAY
102513: PPUSH
102514: CALL 101469 0 3
102518: NOT
102519: IFFALSE 102525
// exit ;
102521: POP
102522: POP
102523: GO 102529
102525: GO 102488
102527: POP
102528: POP
// end ;
102529: LD_VAR 0 4
102533: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
102534: LD_INT 0
102536: PPUSH
102537: PPUSH
102538: PPUSH
102539: PPUSH
102540: PPUSH
102541: PPUSH
102542: PPUSH
// if not GetClass ( unit ) = class_sniper then
102543: LD_VAR 0 1
102547: PPUSH
102548: CALL_OW 257
102552: PUSH
102553: LD_INT 5
102555: EQUAL
102556: NOT
102557: IFFALSE 102561
// exit ;
102559: GO 102949
// dist := 8 ;
102561: LD_ADDR_VAR 0 5
102565: PUSH
102566: LD_INT 8
102568: ST_TO_ADDR
// viewRange := 12 ;
102569: LD_ADDR_VAR 0 7
102573: PUSH
102574: LD_INT 12
102576: ST_TO_ADDR
// side := GetSide ( unit ) ;
102577: LD_ADDR_VAR 0 6
102581: PUSH
102582: LD_VAR 0 1
102586: PPUSH
102587: CALL_OW 255
102591: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
102592: LD_INT 61
102594: PPUSH
102595: LD_VAR 0 6
102599: PPUSH
102600: CALL_OW 321
102604: PUSH
102605: LD_INT 2
102607: EQUAL
102608: IFFALSE 102618
// viewRange := 16 ;
102610: LD_ADDR_VAR 0 7
102614: PUSH
102615: LD_INT 16
102617: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
102618: LD_VAR 0 1
102622: PPUSH
102623: LD_VAR 0 2
102627: PPUSH
102628: LD_VAR 0 3
102632: PPUSH
102633: CALL_OW 297
102637: PUSH
102638: LD_VAR 0 5
102642: GREATER
102643: IFFALSE 102722
// begin ComMoveXY ( unit , x , y ) ;
102645: LD_VAR 0 1
102649: PPUSH
102650: LD_VAR 0 2
102654: PPUSH
102655: LD_VAR 0 3
102659: PPUSH
102660: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102664: LD_INT 35
102666: PPUSH
102667: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
102671: LD_VAR 0 1
102675: PPUSH
102676: LD_VAR 0 2
102680: PPUSH
102681: LD_VAR 0 3
102685: PPUSH
102686: CALL 50358 0 3
102690: NOT
102691: IFFALSE 102695
// exit ;
102693: GO 102949
// until GetDistUnitXY ( unit , x , y ) < dist ;
102695: LD_VAR 0 1
102699: PPUSH
102700: LD_VAR 0 2
102704: PPUSH
102705: LD_VAR 0 3
102709: PPUSH
102710: CALL_OW 297
102714: PUSH
102715: LD_VAR 0 5
102719: LESS
102720: IFFALSE 102664
// end ; ComTurnXY ( unit , x , y ) ;
102722: LD_VAR 0 1
102726: PPUSH
102727: LD_VAR 0 2
102731: PPUSH
102732: LD_VAR 0 3
102736: PPUSH
102737: CALL_OW 118
// wait ( 5 ) ;
102741: LD_INT 5
102743: PPUSH
102744: CALL_OW 67
// _d := GetDir ( unit ) ;
102748: LD_ADDR_VAR 0 10
102752: PUSH
102753: LD_VAR 0 1
102757: PPUSH
102758: CALL_OW 254
102762: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102763: LD_ADDR_VAR 0 8
102767: PUSH
102768: LD_VAR 0 1
102772: PPUSH
102773: CALL_OW 250
102777: PPUSH
102778: LD_VAR 0 10
102782: PPUSH
102783: LD_VAR 0 5
102787: PPUSH
102788: CALL_OW 272
102792: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102793: LD_ADDR_VAR 0 9
102797: PUSH
102798: LD_VAR 0 1
102802: PPUSH
102803: CALL_OW 251
102807: PPUSH
102808: LD_VAR 0 10
102812: PPUSH
102813: LD_VAR 0 5
102817: PPUSH
102818: CALL_OW 273
102822: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102823: LD_VAR 0 8
102827: PPUSH
102828: LD_VAR 0 9
102832: PPUSH
102833: CALL_OW 488
102837: NOT
102838: IFFALSE 102842
// exit ;
102840: GO 102949
// ComAnimCustom ( unit , 1 ) ;
102842: LD_VAR 0 1
102846: PPUSH
102847: LD_INT 1
102849: PPUSH
102850: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102854: LD_VAR 0 8
102858: PPUSH
102859: LD_VAR 0 9
102863: PPUSH
102864: LD_VAR 0 6
102868: PPUSH
102869: LD_VAR 0 7
102873: PPUSH
102874: CALL_OW 330
// repeat wait ( 1 ) ;
102878: LD_INT 1
102880: PPUSH
102881: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102885: LD_VAR 0 1
102889: PPUSH
102890: CALL_OW 316
102894: PUSH
102895: LD_VAR 0 1
102899: PPUSH
102900: CALL_OW 314
102904: OR
102905: PUSH
102906: LD_VAR 0 1
102910: PPUSH
102911: CALL_OW 302
102915: NOT
102916: OR
102917: PUSH
102918: LD_VAR 0 1
102922: PPUSH
102923: CALL_OW 301
102927: OR
102928: IFFALSE 102878
// RemoveSeeing ( _x , _y , side ) ;
102930: LD_VAR 0 8
102934: PPUSH
102935: LD_VAR 0 9
102939: PPUSH
102940: LD_VAR 0 6
102944: PPUSH
102945: CALL_OW 331
// end ; end_of_file
102949: LD_VAR 0 4
102953: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102954: LD_INT 0
102956: PPUSH
102957: PPUSH
102958: PPUSH
102959: PPUSH
102960: PPUSH
102961: PPUSH
102962: PPUSH
102963: PPUSH
102964: PPUSH
102965: PPUSH
102966: PPUSH
102967: PPUSH
102968: PPUSH
102969: PPUSH
102970: PPUSH
102971: PPUSH
102972: PPUSH
102973: PPUSH
102974: PPUSH
102975: PPUSH
102976: PPUSH
102977: PPUSH
102978: PPUSH
102979: PPUSH
102980: PPUSH
102981: PPUSH
102982: PPUSH
102983: PPUSH
102984: PPUSH
102985: PPUSH
102986: PPUSH
102987: PPUSH
102988: PPUSH
102989: PPUSH
// if not list then
102990: LD_VAR 0 1
102994: NOT
102995: IFFALSE 102999
// exit ;
102997: GO 107658
// base := list [ 1 ] ;
102999: LD_ADDR_VAR 0 3
103003: PUSH
103004: LD_VAR 0 1
103008: PUSH
103009: LD_INT 1
103011: ARRAY
103012: ST_TO_ADDR
// group := list [ 2 ] ;
103013: LD_ADDR_VAR 0 4
103017: PUSH
103018: LD_VAR 0 1
103022: PUSH
103023: LD_INT 2
103025: ARRAY
103026: ST_TO_ADDR
// path := list [ 3 ] ;
103027: LD_ADDR_VAR 0 5
103031: PUSH
103032: LD_VAR 0 1
103036: PUSH
103037: LD_INT 3
103039: ARRAY
103040: ST_TO_ADDR
// flags := list [ 4 ] ;
103041: LD_ADDR_VAR 0 6
103045: PUSH
103046: LD_VAR 0 1
103050: PUSH
103051: LD_INT 4
103053: ARRAY
103054: ST_TO_ADDR
// mined := [ ] ;
103055: LD_ADDR_VAR 0 27
103059: PUSH
103060: EMPTY
103061: ST_TO_ADDR
// bombed := [ ] ;
103062: LD_ADDR_VAR 0 28
103066: PUSH
103067: EMPTY
103068: ST_TO_ADDR
// healers := [ ] ;
103069: LD_ADDR_VAR 0 31
103073: PUSH
103074: EMPTY
103075: ST_TO_ADDR
// to_heal := [ ] ;
103076: LD_ADDR_VAR 0 30
103080: PUSH
103081: EMPTY
103082: ST_TO_ADDR
// repairs := [ ] ;
103083: LD_ADDR_VAR 0 33
103087: PUSH
103088: EMPTY
103089: ST_TO_ADDR
// to_repair := [ ] ;
103090: LD_ADDR_VAR 0 32
103094: PUSH
103095: EMPTY
103096: ST_TO_ADDR
// if not group or not path then
103097: LD_VAR 0 4
103101: NOT
103102: PUSH
103103: LD_VAR 0 5
103107: NOT
103108: OR
103109: IFFALSE 103113
// exit ;
103111: GO 107658
// side := GetSide ( group [ 1 ] ) ;
103113: LD_ADDR_VAR 0 35
103117: PUSH
103118: LD_VAR 0 4
103122: PUSH
103123: LD_INT 1
103125: ARRAY
103126: PPUSH
103127: CALL_OW 255
103131: ST_TO_ADDR
// if flags then
103132: LD_VAR 0 6
103136: IFFALSE 103280
// begin f_ignore_area := flags [ 1 ] ;
103138: LD_ADDR_VAR 0 17
103142: PUSH
103143: LD_VAR 0 6
103147: PUSH
103148: LD_INT 1
103150: ARRAY
103151: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
103152: LD_ADDR_VAR 0 18
103156: PUSH
103157: LD_VAR 0 6
103161: PUSH
103162: LD_INT 2
103164: ARRAY
103165: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
103166: LD_ADDR_VAR 0 19
103170: PUSH
103171: LD_VAR 0 6
103175: PUSH
103176: LD_INT 3
103178: ARRAY
103179: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
103180: LD_ADDR_VAR 0 20
103184: PUSH
103185: LD_VAR 0 6
103189: PUSH
103190: LD_INT 4
103192: ARRAY
103193: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
103194: LD_ADDR_VAR 0 21
103198: PUSH
103199: LD_VAR 0 6
103203: PUSH
103204: LD_INT 5
103206: ARRAY
103207: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
103208: LD_ADDR_VAR 0 22
103212: PUSH
103213: LD_VAR 0 6
103217: PUSH
103218: LD_INT 6
103220: ARRAY
103221: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
103222: LD_ADDR_VAR 0 23
103226: PUSH
103227: LD_VAR 0 6
103231: PUSH
103232: LD_INT 7
103234: ARRAY
103235: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
103236: LD_ADDR_VAR 0 24
103240: PUSH
103241: LD_VAR 0 6
103245: PUSH
103246: LD_INT 8
103248: ARRAY
103249: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
103250: LD_ADDR_VAR 0 25
103254: PUSH
103255: LD_VAR 0 6
103259: PUSH
103260: LD_INT 9
103262: ARRAY
103263: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
103264: LD_ADDR_VAR 0 26
103268: PUSH
103269: LD_VAR 0 6
103273: PUSH
103274: LD_INT 10
103276: ARRAY
103277: ST_TO_ADDR
// end else
103278: GO 103360
// begin f_ignore_area := false ;
103280: LD_ADDR_VAR 0 17
103284: PUSH
103285: LD_INT 0
103287: ST_TO_ADDR
// f_capture := false ;
103288: LD_ADDR_VAR 0 18
103292: PUSH
103293: LD_INT 0
103295: ST_TO_ADDR
// f_ignore_civ := false ;
103296: LD_ADDR_VAR 0 19
103300: PUSH
103301: LD_INT 0
103303: ST_TO_ADDR
// f_murder := false ;
103304: LD_ADDR_VAR 0 20
103308: PUSH
103309: LD_INT 0
103311: ST_TO_ADDR
// f_mines := false ;
103312: LD_ADDR_VAR 0 21
103316: PUSH
103317: LD_INT 0
103319: ST_TO_ADDR
// f_repair := false ;
103320: LD_ADDR_VAR 0 22
103324: PUSH
103325: LD_INT 0
103327: ST_TO_ADDR
// f_heal := false ;
103328: LD_ADDR_VAR 0 23
103332: PUSH
103333: LD_INT 0
103335: ST_TO_ADDR
// f_spacetime := false ;
103336: LD_ADDR_VAR 0 24
103340: PUSH
103341: LD_INT 0
103343: ST_TO_ADDR
// f_attack_depot := false ;
103344: LD_ADDR_VAR 0 25
103348: PUSH
103349: LD_INT 0
103351: ST_TO_ADDR
// f_crawl := false ;
103352: LD_ADDR_VAR 0 26
103356: PUSH
103357: LD_INT 0
103359: ST_TO_ADDR
// end ; if f_heal then
103360: LD_VAR 0 23
103364: IFFALSE 103391
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
103366: LD_ADDR_VAR 0 31
103370: PUSH
103371: LD_VAR 0 4
103375: PPUSH
103376: LD_INT 25
103378: PUSH
103379: LD_INT 4
103381: PUSH
103382: EMPTY
103383: LIST
103384: LIST
103385: PPUSH
103386: CALL_OW 72
103390: ST_TO_ADDR
// if f_repair then
103391: LD_VAR 0 22
103395: IFFALSE 103422
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
103397: LD_ADDR_VAR 0 33
103401: PUSH
103402: LD_VAR 0 4
103406: PPUSH
103407: LD_INT 25
103409: PUSH
103410: LD_INT 3
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PPUSH
103417: CALL_OW 72
103421: ST_TO_ADDR
// units_path := [ ] ;
103422: LD_ADDR_VAR 0 16
103426: PUSH
103427: EMPTY
103428: ST_TO_ADDR
// for i = 1 to group do
103429: LD_ADDR_VAR 0 7
103433: PUSH
103434: DOUBLE
103435: LD_INT 1
103437: DEC
103438: ST_TO_ADDR
103439: LD_VAR 0 4
103443: PUSH
103444: FOR_TO
103445: IFFALSE 103474
// units_path := Replace ( units_path , i , path ) ;
103447: LD_ADDR_VAR 0 16
103451: PUSH
103452: LD_VAR 0 16
103456: PPUSH
103457: LD_VAR 0 7
103461: PPUSH
103462: LD_VAR 0 5
103466: PPUSH
103467: CALL_OW 1
103471: ST_TO_ADDR
103472: GO 103444
103474: POP
103475: POP
// repeat for i = group downto 1 do
103476: LD_ADDR_VAR 0 7
103480: PUSH
103481: DOUBLE
103482: LD_VAR 0 4
103486: INC
103487: ST_TO_ADDR
103488: LD_INT 1
103490: PUSH
103491: FOR_DOWNTO
103492: IFFALSE 107614
// begin wait ( 5 ) ;
103494: LD_INT 5
103496: PPUSH
103497: CALL_OW 67
// tmp := [ ] ;
103501: LD_ADDR_VAR 0 14
103505: PUSH
103506: EMPTY
103507: ST_TO_ADDR
// attacking := false ;
103508: LD_ADDR_VAR 0 29
103512: PUSH
103513: LD_INT 0
103515: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: CALL_OW 301
103531: PUSH
103532: LD_VAR 0 4
103536: PUSH
103537: LD_VAR 0 7
103541: ARRAY
103542: NOT
103543: OR
103544: IFFALSE 103653
// begin if GetType ( group [ i ] ) = unit_human then
103546: LD_VAR 0 4
103550: PUSH
103551: LD_VAR 0 7
103555: ARRAY
103556: PPUSH
103557: CALL_OW 247
103561: PUSH
103562: LD_INT 1
103564: EQUAL
103565: IFFALSE 103611
// begin to_heal := to_heal diff group [ i ] ;
103567: LD_ADDR_VAR 0 30
103571: PUSH
103572: LD_VAR 0 30
103576: PUSH
103577: LD_VAR 0 4
103581: PUSH
103582: LD_VAR 0 7
103586: ARRAY
103587: DIFF
103588: ST_TO_ADDR
// healers := healers diff group [ i ] ;
103589: LD_ADDR_VAR 0 31
103593: PUSH
103594: LD_VAR 0 31
103598: PUSH
103599: LD_VAR 0 4
103603: PUSH
103604: LD_VAR 0 7
103608: ARRAY
103609: DIFF
103610: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
103611: LD_ADDR_VAR 0 4
103615: PUSH
103616: LD_VAR 0 4
103620: PPUSH
103621: LD_VAR 0 7
103625: PPUSH
103626: CALL_OW 3
103630: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
103631: LD_ADDR_VAR 0 16
103635: PUSH
103636: LD_VAR 0 16
103640: PPUSH
103641: LD_VAR 0 7
103645: PPUSH
103646: CALL_OW 3
103650: ST_TO_ADDR
// continue ;
103651: GO 103491
// end ; if f_repair then
103653: LD_VAR 0 22
103657: IFFALSE 104146
// begin if GetType ( group [ i ] ) = unit_vehicle then
103659: LD_VAR 0 4
103663: PUSH
103664: LD_VAR 0 7
103668: ARRAY
103669: PPUSH
103670: CALL_OW 247
103674: PUSH
103675: LD_INT 2
103677: EQUAL
103678: IFFALSE 103868
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
103680: LD_VAR 0 4
103684: PUSH
103685: LD_VAR 0 7
103689: ARRAY
103690: PPUSH
103691: CALL_OW 256
103695: PUSH
103696: LD_INT 700
103698: LESS
103699: PUSH
103700: LD_VAR 0 4
103704: PUSH
103705: LD_VAR 0 7
103709: ARRAY
103710: PUSH
103711: LD_VAR 0 32
103715: IN
103716: NOT
103717: AND
103718: IFFALSE 103742
// to_repair := to_repair union group [ i ] ;
103720: LD_ADDR_VAR 0 32
103724: PUSH
103725: LD_VAR 0 32
103729: PUSH
103730: LD_VAR 0 4
103734: PUSH
103735: LD_VAR 0 7
103739: ARRAY
103740: UNION
103741: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103742: LD_VAR 0 4
103746: PUSH
103747: LD_VAR 0 7
103751: ARRAY
103752: PPUSH
103753: CALL_OW 256
103757: PUSH
103758: LD_INT 1000
103760: EQUAL
103761: PUSH
103762: LD_VAR 0 4
103766: PUSH
103767: LD_VAR 0 7
103771: ARRAY
103772: PUSH
103773: LD_VAR 0 32
103777: IN
103778: AND
103779: IFFALSE 103803
// to_repair := to_repair diff group [ i ] ;
103781: LD_ADDR_VAR 0 32
103785: PUSH
103786: LD_VAR 0 32
103790: PUSH
103791: LD_VAR 0 4
103795: PUSH
103796: LD_VAR 0 7
103800: ARRAY
103801: DIFF
103802: ST_TO_ADDR
// if group [ i ] in to_repair then
103803: LD_VAR 0 4
103807: PUSH
103808: LD_VAR 0 7
103812: ARRAY
103813: PUSH
103814: LD_VAR 0 32
103818: IN
103819: IFFALSE 103866
// begin if not IsInArea ( group [ i ] , f_repair ) then
103821: LD_VAR 0 4
103825: PUSH
103826: LD_VAR 0 7
103830: ARRAY
103831: PPUSH
103832: LD_VAR 0 22
103836: PPUSH
103837: CALL_OW 308
103841: NOT
103842: IFFALSE 103864
// ComMoveToArea ( group [ i ] , f_repair ) ;
103844: LD_VAR 0 4
103848: PUSH
103849: LD_VAR 0 7
103853: ARRAY
103854: PPUSH
103855: LD_VAR 0 22
103859: PPUSH
103860: CALL_OW 113
// continue ;
103864: GO 103491
// end ; end else
103866: GO 104146
// if group [ i ] in repairs then
103868: LD_VAR 0 4
103872: PUSH
103873: LD_VAR 0 7
103877: ARRAY
103878: PUSH
103879: LD_VAR 0 33
103883: IN
103884: IFFALSE 104146
// begin if IsInUnit ( group [ i ] ) then
103886: LD_VAR 0 4
103890: PUSH
103891: LD_VAR 0 7
103895: ARRAY
103896: PPUSH
103897: CALL_OW 310
103901: IFFALSE 103969
// begin z := IsInUnit ( group [ i ] ) ;
103903: LD_ADDR_VAR 0 13
103907: PUSH
103908: LD_VAR 0 4
103912: PUSH
103913: LD_VAR 0 7
103917: ARRAY
103918: PPUSH
103919: CALL_OW 310
103923: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103924: LD_VAR 0 13
103928: PUSH
103929: LD_VAR 0 32
103933: IN
103934: PUSH
103935: LD_VAR 0 13
103939: PPUSH
103940: LD_VAR 0 22
103944: PPUSH
103945: CALL_OW 308
103949: AND
103950: IFFALSE 103967
// ComExitVehicle ( group [ i ] ) ;
103952: LD_VAR 0 4
103956: PUSH
103957: LD_VAR 0 7
103961: ARRAY
103962: PPUSH
103963: CALL_OW 121
// end else
103967: GO 104146
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103969: LD_ADDR_VAR 0 13
103973: PUSH
103974: LD_VAR 0 4
103978: PPUSH
103979: LD_INT 95
103981: PUSH
103982: LD_VAR 0 22
103986: PUSH
103987: EMPTY
103988: LIST
103989: LIST
103990: PUSH
103991: LD_INT 58
103993: PUSH
103994: EMPTY
103995: LIST
103996: PUSH
103997: EMPTY
103998: LIST
103999: LIST
104000: PPUSH
104001: CALL_OW 72
104005: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
104006: LD_VAR 0 4
104010: PUSH
104011: LD_VAR 0 7
104015: ARRAY
104016: PPUSH
104017: CALL_OW 314
104021: NOT
104022: IFFALSE 104144
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
104024: LD_ADDR_VAR 0 10
104028: PUSH
104029: LD_VAR 0 13
104033: PPUSH
104034: LD_VAR 0 4
104038: PUSH
104039: LD_VAR 0 7
104043: ARRAY
104044: PPUSH
104045: CALL_OW 74
104049: ST_TO_ADDR
// if not x then
104050: LD_VAR 0 10
104054: NOT
104055: IFFALSE 104059
// continue ;
104057: GO 103491
// if GetLives ( x ) < 1000 then
104059: LD_VAR 0 10
104063: PPUSH
104064: CALL_OW 256
104068: PUSH
104069: LD_INT 1000
104071: LESS
104072: IFFALSE 104096
// ComRepairVehicle ( group [ i ] , x ) else
104074: LD_VAR 0 4
104078: PUSH
104079: LD_VAR 0 7
104083: ARRAY
104084: PPUSH
104085: LD_VAR 0 10
104089: PPUSH
104090: CALL_OW 129
104094: GO 104144
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
104096: LD_VAR 0 23
104100: PUSH
104101: LD_VAR 0 4
104105: PUSH
104106: LD_VAR 0 7
104110: ARRAY
104111: PPUSH
104112: CALL_OW 256
104116: PUSH
104117: LD_INT 1000
104119: LESS
104120: AND
104121: NOT
104122: IFFALSE 104144
// ComEnterUnit ( group [ i ] , x ) ;
104124: LD_VAR 0 4
104128: PUSH
104129: LD_VAR 0 7
104133: ARRAY
104134: PPUSH
104135: LD_VAR 0 10
104139: PPUSH
104140: CALL_OW 120
// end ; continue ;
104144: GO 103491
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
104146: LD_VAR 0 23
104150: PUSH
104151: LD_VAR 0 4
104155: PUSH
104156: LD_VAR 0 7
104160: ARRAY
104161: PPUSH
104162: CALL_OW 247
104166: PUSH
104167: LD_INT 1
104169: EQUAL
104170: AND
104171: IFFALSE 104649
// begin if group [ i ] in healers then
104173: LD_VAR 0 4
104177: PUSH
104178: LD_VAR 0 7
104182: ARRAY
104183: PUSH
104184: LD_VAR 0 31
104188: IN
104189: IFFALSE 104462
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
104191: LD_VAR 0 4
104195: PUSH
104196: LD_VAR 0 7
104200: ARRAY
104201: PPUSH
104202: LD_VAR 0 23
104206: PPUSH
104207: CALL_OW 308
104211: NOT
104212: PUSH
104213: LD_VAR 0 4
104217: PUSH
104218: LD_VAR 0 7
104222: ARRAY
104223: PPUSH
104224: CALL_OW 314
104228: NOT
104229: AND
104230: IFFALSE 104254
// ComMoveToArea ( group [ i ] , f_heal ) else
104232: LD_VAR 0 4
104236: PUSH
104237: LD_VAR 0 7
104241: ARRAY
104242: PPUSH
104243: LD_VAR 0 23
104247: PPUSH
104248: CALL_OW 113
104252: GO 104460
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
104254: LD_VAR 0 4
104258: PUSH
104259: LD_VAR 0 7
104263: ARRAY
104264: PPUSH
104265: CALL 48881 0 1
104269: PPUSH
104270: CALL_OW 256
104274: PUSH
104275: LD_INT 1000
104277: EQUAL
104278: IFFALSE 104297
// ComStop ( group [ i ] ) else
104280: LD_VAR 0 4
104284: PUSH
104285: LD_VAR 0 7
104289: ARRAY
104290: PPUSH
104291: CALL_OW 141
104295: GO 104460
// if not HasTask ( group [ i ] ) and to_heal then
104297: LD_VAR 0 4
104301: PUSH
104302: LD_VAR 0 7
104306: ARRAY
104307: PPUSH
104308: CALL_OW 314
104312: NOT
104313: PUSH
104314: LD_VAR 0 30
104318: AND
104319: IFFALSE 104460
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
104321: LD_ADDR_VAR 0 13
104325: PUSH
104326: LD_VAR 0 30
104330: PPUSH
104331: LD_INT 3
104333: PUSH
104334: LD_INT 54
104336: PUSH
104337: EMPTY
104338: LIST
104339: PUSH
104340: EMPTY
104341: LIST
104342: LIST
104343: PPUSH
104344: CALL_OW 72
104348: PPUSH
104349: LD_VAR 0 4
104353: PUSH
104354: LD_VAR 0 7
104358: ARRAY
104359: PPUSH
104360: CALL_OW 74
104364: ST_TO_ADDR
// if z then
104365: LD_VAR 0 13
104369: IFFALSE 104460
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
104371: LD_INT 91
104373: PUSH
104374: LD_VAR 0 13
104378: PUSH
104379: LD_INT 10
104381: PUSH
104382: EMPTY
104383: LIST
104384: LIST
104385: LIST
104386: PUSH
104387: LD_INT 81
104389: PUSH
104390: LD_VAR 0 13
104394: PPUSH
104395: CALL_OW 255
104399: PUSH
104400: EMPTY
104401: LIST
104402: LIST
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: PPUSH
104408: CALL_OW 69
104412: PUSH
104413: LD_INT 0
104415: EQUAL
104416: IFFALSE 104440
// ComHeal ( group [ i ] , z ) else
104418: LD_VAR 0 4
104422: PUSH
104423: LD_VAR 0 7
104427: ARRAY
104428: PPUSH
104429: LD_VAR 0 13
104433: PPUSH
104434: CALL_OW 128
104438: GO 104460
// ComMoveToArea ( group [ i ] , f_heal ) ;
104440: LD_VAR 0 4
104444: PUSH
104445: LD_VAR 0 7
104449: ARRAY
104450: PPUSH
104451: LD_VAR 0 23
104455: PPUSH
104456: CALL_OW 113
// end ; continue ;
104460: GO 103491
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
104462: LD_VAR 0 4
104466: PUSH
104467: LD_VAR 0 7
104471: ARRAY
104472: PPUSH
104473: CALL_OW 256
104477: PUSH
104478: LD_INT 700
104480: LESS
104481: PUSH
104482: LD_VAR 0 4
104486: PUSH
104487: LD_VAR 0 7
104491: ARRAY
104492: PUSH
104493: LD_VAR 0 30
104497: IN
104498: NOT
104499: AND
104500: IFFALSE 104524
// to_heal := to_heal union group [ i ] ;
104502: LD_ADDR_VAR 0 30
104506: PUSH
104507: LD_VAR 0 30
104511: PUSH
104512: LD_VAR 0 4
104516: PUSH
104517: LD_VAR 0 7
104521: ARRAY
104522: UNION
104523: ST_TO_ADDR
// if group [ i ] in to_heal then
104524: LD_VAR 0 4
104528: PUSH
104529: LD_VAR 0 7
104533: ARRAY
104534: PUSH
104535: LD_VAR 0 30
104539: IN
104540: IFFALSE 104649
// begin if GetLives ( group [ i ] ) = 1000 then
104542: LD_VAR 0 4
104546: PUSH
104547: LD_VAR 0 7
104551: ARRAY
104552: PPUSH
104553: CALL_OW 256
104557: PUSH
104558: LD_INT 1000
104560: EQUAL
104561: IFFALSE 104587
// to_heal := to_heal diff group [ i ] else
104563: LD_ADDR_VAR 0 30
104567: PUSH
104568: LD_VAR 0 30
104572: PUSH
104573: LD_VAR 0 4
104577: PUSH
104578: LD_VAR 0 7
104582: ARRAY
104583: DIFF
104584: ST_TO_ADDR
104585: GO 104649
// begin if not IsInArea ( group [ i ] , to_heal ) then
104587: LD_VAR 0 4
104591: PUSH
104592: LD_VAR 0 7
104596: ARRAY
104597: PPUSH
104598: LD_VAR 0 30
104602: PPUSH
104603: CALL_OW 308
104607: NOT
104608: IFFALSE 104632
// ComMoveToArea ( group [ i ] , f_heal ) else
104610: LD_VAR 0 4
104614: PUSH
104615: LD_VAR 0 7
104619: ARRAY
104620: PPUSH
104621: LD_VAR 0 23
104625: PPUSH
104626: CALL_OW 113
104630: GO 104647
// ComHold ( group [ i ] ) ;
104632: LD_VAR 0 4
104636: PUSH
104637: LD_VAR 0 7
104641: ARRAY
104642: PPUSH
104643: CALL_OW 140
// continue ;
104647: GO 103491
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
104649: LD_VAR 0 4
104653: PUSH
104654: LD_VAR 0 7
104658: ARRAY
104659: PPUSH
104660: LD_INT 10
104662: PPUSH
104663: CALL 47301 0 2
104667: NOT
104668: PUSH
104669: LD_VAR 0 16
104673: PUSH
104674: LD_VAR 0 7
104678: ARRAY
104679: PUSH
104680: EMPTY
104681: EQUAL
104682: NOT
104683: AND
104684: IFFALSE 104950
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
104686: LD_VAR 0 4
104690: PUSH
104691: LD_VAR 0 7
104695: ARRAY
104696: PPUSH
104697: CALL_OW 262
104701: PUSH
104702: LD_INT 1
104704: PUSH
104705: LD_INT 2
104707: PUSH
104708: EMPTY
104709: LIST
104710: LIST
104711: IN
104712: IFFALSE 104753
// if GetFuel ( group [ i ] ) < 10 then
104714: LD_VAR 0 4
104718: PUSH
104719: LD_VAR 0 7
104723: ARRAY
104724: PPUSH
104725: CALL_OW 261
104729: PUSH
104730: LD_INT 10
104732: LESS
104733: IFFALSE 104753
// SetFuel ( group [ i ] , 12 ) ;
104735: LD_VAR 0 4
104739: PUSH
104740: LD_VAR 0 7
104744: ARRAY
104745: PPUSH
104746: LD_INT 12
104748: PPUSH
104749: CALL_OW 240
// if units_path [ i ] then
104753: LD_VAR 0 16
104757: PUSH
104758: LD_VAR 0 7
104762: ARRAY
104763: IFFALSE 104948
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104765: LD_VAR 0 4
104769: PUSH
104770: LD_VAR 0 7
104774: ARRAY
104775: PPUSH
104776: LD_VAR 0 16
104780: PUSH
104781: LD_VAR 0 7
104785: ARRAY
104786: PUSH
104787: LD_INT 1
104789: ARRAY
104790: PUSH
104791: LD_INT 1
104793: ARRAY
104794: PPUSH
104795: LD_VAR 0 16
104799: PUSH
104800: LD_VAR 0 7
104804: ARRAY
104805: PUSH
104806: LD_INT 1
104808: ARRAY
104809: PUSH
104810: LD_INT 2
104812: ARRAY
104813: PPUSH
104814: CALL_OW 297
104818: PUSH
104819: LD_INT 6
104821: GREATER
104822: IFFALSE 104897
// begin if not HasTask ( group [ i ] ) then
104824: LD_VAR 0 4
104828: PUSH
104829: LD_VAR 0 7
104833: ARRAY
104834: PPUSH
104835: CALL_OW 314
104839: NOT
104840: IFFALSE 104895
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104842: LD_VAR 0 4
104846: PUSH
104847: LD_VAR 0 7
104851: ARRAY
104852: PPUSH
104853: LD_VAR 0 16
104857: PUSH
104858: LD_VAR 0 7
104862: ARRAY
104863: PUSH
104864: LD_INT 1
104866: ARRAY
104867: PUSH
104868: LD_INT 1
104870: ARRAY
104871: PPUSH
104872: LD_VAR 0 16
104876: PUSH
104877: LD_VAR 0 7
104881: ARRAY
104882: PUSH
104883: LD_INT 1
104885: ARRAY
104886: PUSH
104887: LD_INT 2
104889: ARRAY
104890: PPUSH
104891: CALL_OW 114
// end else
104895: GO 104948
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104897: LD_ADDR_VAR 0 15
104901: PUSH
104902: LD_VAR 0 16
104906: PUSH
104907: LD_VAR 0 7
104911: ARRAY
104912: PPUSH
104913: LD_INT 1
104915: PPUSH
104916: CALL_OW 3
104920: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104921: LD_ADDR_VAR 0 16
104925: PUSH
104926: LD_VAR 0 16
104930: PPUSH
104931: LD_VAR 0 7
104935: PPUSH
104936: LD_VAR 0 15
104940: PPUSH
104941: CALL_OW 1
104945: ST_TO_ADDR
// continue ;
104946: GO 103491
// end ; end ; end else
104948: GO 107612
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104950: LD_ADDR_VAR 0 14
104954: PUSH
104955: LD_INT 81
104957: PUSH
104958: LD_VAR 0 4
104962: PUSH
104963: LD_VAR 0 7
104967: ARRAY
104968: PPUSH
104969: CALL_OW 255
104973: PUSH
104974: EMPTY
104975: LIST
104976: LIST
104977: PPUSH
104978: CALL_OW 69
104982: ST_TO_ADDR
// if not tmp then
104983: LD_VAR 0 14
104987: NOT
104988: IFFALSE 104992
// continue ;
104990: GO 103491
// if f_ignore_area then
104992: LD_VAR 0 17
104996: IFFALSE 105084
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104998: LD_ADDR_VAR 0 15
105002: PUSH
105003: LD_VAR 0 14
105007: PPUSH
105008: LD_INT 3
105010: PUSH
105011: LD_INT 92
105013: PUSH
105014: LD_VAR 0 17
105018: PUSH
105019: LD_INT 1
105021: ARRAY
105022: PUSH
105023: LD_VAR 0 17
105027: PUSH
105028: LD_INT 2
105030: ARRAY
105031: PUSH
105032: LD_VAR 0 17
105036: PUSH
105037: LD_INT 3
105039: ARRAY
105040: PUSH
105041: EMPTY
105042: LIST
105043: LIST
105044: LIST
105045: LIST
105046: PUSH
105047: EMPTY
105048: LIST
105049: LIST
105050: PPUSH
105051: CALL_OW 72
105055: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105056: LD_VAR 0 14
105060: PUSH
105061: LD_VAR 0 15
105065: DIFF
105066: IFFALSE 105084
// tmp := tmp diff tmp2 ;
105068: LD_ADDR_VAR 0 14
105072: PUSH
105073: LD_VAR 0 14
105077: PUSH
105078: LD_VAR 0 15
105082: DIFF
105083: ST_TO_ADDR
// end ; if not f_murder then
105084: LD_VAR 0 20
105088: NOT
105089: IFFALSE 105147
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
105091: LD_ADDR_VAR 0 15
105095: PUSH
105096: LD_VAR 0 14
105100: PPUSH
105101: LD_INT 3
105103: PUSH
105104: LD_INT 50
105106: PUSH
105107: EMPTY
105108: LIST
105109: PUSH
105110: EMPTY
105111: LIST
105112: LIST
105113: PPUSH
105114: CALL_OW 72
105118: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
105119: LD_VAR 0 14
105123: PUSH
105124: LD_VAR 0 15
105128: DIFF
105129: IFFALSE 105147
// tmp := tmp diff tmp2 ;
105131: LD_ADDR_VAR 0 14
105135: PUSH
105136: LD_VAR 0 14
105140: PUSH
105141: LD_VAR 0 15
105145: DIFF
105146: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
105147: LD_ADDR_VAR 0 14
105151: PUSH
105152: LD_VAR 0 4
105156: PUSH
105157: LD_VAR 0 7
105161: ARRAY
105162: PPUSH
105163: LD_VAR 0 14
105167: PPUSH
105168: LD_INT 1
105170: PPUSH
105171: LD_INT 1
105173: PPUSH
105174: CALL 20236 0 4
105178: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
105179: LD_VAR 0 4
105183: PUSH
105184: LD_VAR 0 7
105188: ARRAY
105189: PPUSH
105190: CALL_OW 257
105194: PUSH
105195: LD_INT 1
105197: EQUAL
105198: IFFALSE 105646
// begin if WantPlant ( group [ i ] ) then
105200: LD_VAR 0 4
105204: PUSH
105205: LD_VAR 0 7
105209: ARRAY
105210: PPUSH
105211: CALL 19737 0 1
105215: IFFALSE 105219
// continue ;
105217: GO 103491
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
105219: LD_VAR 0 18
105223: PUSH
105224: LD_VAR 0 4
105228: PUSH
105229: LD_VAR 0 7
105233: ARRAY
105234: PPUSH
105235: CALL_OW 310
105239: NOT
105240: AND
105241: PUSH
105242: LD_VAR 0 14
105246: PUSH
105247: LD_INT 1
105249: ARRAY
105250: PUSH
105251: LD_VAR 0 14
105255: PPUSH
105256: LD_INT 21
105258: PUSH
105259: LD_INT 2
105261: PUSH
105262: EMPTY
105263: LIST
105264: LIST
105265: PUSH
105266: LD_INT 58
105268: PUSH
105269: EMPTY
105270: LIST
105271: PUSH
105272: EMPTY
105273: LIST
105274: LIST
105275: PPUSH
105276: CALL_OW 72
105280: IN
105281: AND
105282: IFFALSE 105318
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
105284: LD_VAR 0 4
105288: PUSH
105289: LD_VAR 0 7
105293: ARRAY
105294: PPUSH
105295: LD_VAR 0 14
105299: PUSH
105300: LD_INT 1
105302: ARRAY
105303: PPUSH
105304: CALL_OW 120
// attacking := true ;
105308: LD_ADDR_VAR 0 29
105312: PUSH
105313: LD_INT 1
105315: ST_TO_ADDR
// continue ;
105316: GO 103491
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
105318: LD_VAR 0 26
105322: PUSH
105323: LD_VAR 0 4
105327: PUSH
105328: LD_VAR 0 7
105332: ARRAY
105333: PPUSH
105334: CALL_OW 257
105338: PUSH
105339: LD_INT 1
105341: EQUAL
105342: AND
105343: PUSH
105344: LD_VAR 0 4
105348: PUSH
105349: LD_VAR 0 7
105353: ARRAY
105354: PPUSH
105355: CALL_OW 256
105359: PUSH
105360: LD_INT 800
105362: LESS
105363: AND
105364: PUSH
105365: LD_VAR 0 4
105369: PUSH
105370: LD_VAR 0 7
105374: ARRAY
105375: PPUSH
105376: CALL_OW 318
105380: NOT
105381: AND
105382: IFFALSE 105399
// ComCrawl ( group [ i ] ) ;
105384: LD_VAR 0 4
105388: PUSH
105389: LD_VAR 0 7
105393: ARRAY
105394: PPUSH
105395: CALL_OW 137
// if f_mines then
105399: LD_VAR 0 21
105403: IFFALSE 105646
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
105405: LD_VAR 0 14
105409: PUSH
105410: LD_INT 1
105412: ARRAY
105413: PPUSH
105414: CALL_OW 247
105418: PUSH
105419: LD_INT 3
105421: EQUAL
105422: PUSH
105423: LD_VAR 0 14
105427: PUSH
105428: LD_INT 1
105430: ARRAY
105431: PUSH
105432: LD_VAR 0 27
105436: IN
105437: NOT
105438: AND
105439: IFFALSE 105646
// begin x := GetX ( tmp [ 1 ] ) ;
105441: LD_ADDR_VAR 0 10
105445: PUSH
105446: LD_VAR 0 14
105450: PUSH
105451: LD_INT 1
105453: ARRAY
105454: PPUSH
105455: CALL_OW 250
105459: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
105460: LD_ADDR_VAR 0 11
105464: PUSH
105465: LD_VAR 0 14
105469: PUSH
105470: LD_INT 1
105472: ARRAY
105473: PPUSH
105474: CALL_OW 251
105478: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
105479: LD_ADDR_VAR 0 12
105483: PUSH
105484: LD_VAR 0 4
105488: PUSH
105489: LD_VAR 0 7
105493: ARRAY
105494: PPUSH
105495: CALL 47386 0 1
105499: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
105500: LD_VAR 0 4
105504: PUSH
105505: LD_VAR 0 7
105509: ARRAY
105510: PPUSH
105511: LD_VAR 0 10
105515: PPUSH
105516: LD_VAR 0 11
105520: PPUSH
105521: LD_VAR 0 14
105525: PUSH
105526: LD_INT 1
105528: ARRAY
105529: PPUSH
105530: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
105534: LD_VAR 0 4
105538: PUSH
105539: LD_VAR 0 7
105543: ARRAY
105544: PPUSH
105545: LD_VAR 0 10
105549: PPUSH
105550: LD_VAR 0 12
105554: PPUSH
105555: LD_INT 7
105557: PPUSH
105558: CALL_OW 272
105562: PPUSH
105563: LD_VAR 0 11
105567: PPUSH
105568: LD_VAR 0 12
105572: PPUSH
105573: LD_INT 7
105575: PPUSH
105576: CALL_OW 273
105580: PPUSH
105581: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
105585: LD_VAR 0 4
105589: PUSH
105590: LD_VAR 0 7
105594: ARRAY
105595: PPUSH
105596: LD_INT 71
105598: PPUSH
105599: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
105603: LD_ADDR_VAR 0 27
105607: PUSH
105608: LD_VAR 0 27
105612: PPUSH
105613: LD_VAR 0 27
105617: PUSH
105618: LD_INT 1
105620: PLUS
105621: PPUSH
105622: LD_VAR 0 14
105626: PUSH
105627: LD_INT 1
105629: ARRAY
105630: PPUSH
105631: CALL_OW 1
105635: ST_TO_ADDR
// attacking := true ;
105636: LD_ADDR_VAR 0 29
105640: PUSH
105641: LD_INT 1
105643: ST_TO_ADDR
// continue ;
105644: GO 103491
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
105646: LD_VAR 0 4
105650: PUSH
105651: LD_VAR 0 7
105655: ARRAY
105656: PPUSH
105657: CALL_OW 257
105661: PUSH
105662: LD_INT 17
105664: EQUAL
105665: PUSH
105666: LD_VAR 0 4
105670: PUSH
105671: LD_VAR 0 7
105675: ARRAY
105676: PPUSH
105677: CALL_OW 110
105681: PUSH
105682: LD_INT 71
105684: EQUAL
105685: NOT
105686: AND
105687: IFFALSE 105833
// begin attacking := false ;
105689: LD_ADDR_VAR 0 29
105693: PUSH
105694: LD_INT 0
105696: ST_TO_ADDR
// k := 5 ;
105697: LD_ADDR_VAR 0 9
105701: PUSH
105702: LD_INT 5
105704: ST_TO_ADDR
// if tmp < k then
105705: LD_VAR 0 14
105709: PUSH
105710: LD_VAR 0 9
105714: LESS
105715: IFFALSE 105727
// k := tmp ;
105717: LD_ADDR_VAR 0 9
105721: PUSH
105722: LD_VAR 0 14
105726: ST_TO_ADDR
// for j = 1 to k do
105727: LD_ADDR_VAR 0 8
105731: PUSH
105732: DOUBLE
105733: LD_INT 1
105735: DEC
105736: ST_TO_ADDR
105737: LD_VAR 0 9
105741: PUSH
105742: FOR_TO
105743: IFFALSE 105831
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105745: LD_VAR 0 14
105749: PUSH
105750: LD_VAR 0 8
105754: ARRAY
105755: PUSH
105756: LD_VAR 0 14
105760: PPUSH
105761: LD_INT 58
105763: PUSH
105764: EMPTY
105765: LIST
105766: PPUSH
105767: CALL_OW 72
105771: IN
105772: NOT
105773: IFFALSE 105829
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105775: LD_VAR 0 4
105779: PUSH
105780: LD_VAR 0 7
105784: ARRAY
105785: PPUSH
105786: LD_VAR 0 14
105790: PUSH
105791: LD_VAR 0 8
105795: ARRAY
105796: PPUSH
105797: CALL_OW 115
// attacking := true ;
105801: LD_ADDR_VAR 0 29
105805: PUSH
105806: LD_INT 1
105808: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105809: LD_VAR 0 4
105813: PUSH
105814: LD_VAR 0 7
105818: ARRAY
105819: PPUSH
105820: LD_INT 71
105822: PPUSH
105823: CALL_OW 109
// continue ;
105827: GO 105742
// end ; end ;
105829: GO 105742
105831: POP
105832: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105833: LD_VAR 0 4
105837: PUSH
105838: LD_VAR 0 7
105842: ARRAY
105843: PPUSH
105844: CALL_OW 257
105848: PUSH
105849: LD_INT 8
105851: EQUAL
105852: PUSH
105853: LD_VAR 0 4
105857: PUSH
105858: LD_VAR 0 7
105862: ARRAY
105863: PPUSH
105864: CALL_OW 264
105868: PUSH
105869: LD_INT 28
105871: PUSH
105872: LD_INT 45
105874: PUSH
105875: LD_INT 7
105877: PUSH
105878: LD_INT 47
105880: PUSH
105881: EMPTY
105882: LIST
105883: LIST
105884: LIST
105885: LIST
105886: IN
105887: OR
105888: IFFALSE 106144
// begin attacking := false ;
105890: LD_ADDR_VAR 0 29
105894: PUSH
105895: LD_INT 0
105897: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105898: LD_VAR 0 14
105902: PUSH
105903: LD_INT 1
105905: ARRAY
105906: PPUSH
105907: CALL_OW 266
105911: PUSH
105912: LD_INT 32
105914: PUSH
105915: LD_INT 31
105917: PUSH
105918: LD_INT 33
105920: PUSH
105921: LD_INT 4
105923: PUSH
105924: LD_INT 5
105926: PUSH
105927: EMPTY
105928: LIST
105929: LIST
105930: LIST
105931: LIST
105932: LIST
105933: IN
105934: IFFALSE 106120
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105936: LD_ADDR_VAR 0 9
105940: PUSH
105941: LD_VAR 0 14
105945: PUSH
105946: LD_INT 1
105948: ARRAY
105949: PPUSH
105950: CALL_OW 266
105954: PPUSH
105955: LD_VAR 0 14
105959: PUSH
105960: LD_INT 1
105962: ARRAY
105963: PPUSH
105964: CALL_OW 250
105968: PPUSH
105969: LD_VAR 0 14
105973: PUSH
105974: LD_INT 1
105976: ARRAY
105977: PPUSH
105978: CALL_OW 251
105982: PPUSH
105983: LD_VAR 0 14
105987: PUSH
105988: LD_INT 1
105990: ARRAY
105991: PPUSH
105992: CALL_OW 254
105996: PPUSH
105997: LD_VAR 0 14
106001: PUSH
106002: LD_INT 1
106004: ARRAY
106005: PPUSH
106006: CALL_OW 248
106010: PPUSH
106011: LD_INT 0
106013: PPUSH
106014: CALL 28756 0 6
106018: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
106019: LD_ADDR_VAR 0 8
106023: PUSH
106024: LD_VAR 0 4
106028: PUSH
106029: LD_VAR 0 7
106033: ARRAY
106034: PPUSH
106035: LD_VAR 0 9
106039: PPUSH
106040: CALL 47426 0 2
106044: ST_TO_ADDR
// if j then
106045: LD_VAR 0 8
106049: IFFALSE 106118
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
106051: LD_VAR 0 8
106055: PUSH
106056: LD_INT 1
106058: ARRAY
106059: PPUSH
106060: LD_VAR 0 8
106064: PUSH
106065: LD_INT 2
106067: ARRAY
106068: PPUSH
106069: CALL_OW 488
106073: IFFALSE 106118
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
106075: LD_VAR 0 4
106079: PUSH
106080: LD_VAR 0 7
106084: ARRAY
106085: PPUSH
106086: LD_VAR 0 8
106090: PUSH
106091: LD_INT 1
106093: ARRAY
106094: PPUSH
106095: LD_VAR 0 8
106099: PUSH
106100: LD_INT 2
106102: ARRAY
106103: PPUSH
106104: CALL_OW 116
// attacking := true ;
106108: LD_ADDR_VAR 0 29
106112: PUSH
106113: LD_INT 1
106115: ST_TO_ADDR
// continue ;
106116: GO 103491
// end ; end else
106118: GO 106144
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106120: LD_VAR 0 4
106124: PUSH
106125: LD_VAR 0 7
106129: ARRAY
106130: PPUSH
106131: LD_VAR 0 14
106135: PUSH
106136: LD_INT 1
106138: ARRAY
106139: PPUSH
106140: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
106144: LD_VAR 0 4
106148: PUSH
106149: LD_VAR 0 7
106153: ARRAY
106154: PPUSH
106155: CALL_OW 265
106159: PUSH
106160: LD_INT 11
106162: EQUAL
106163: IFFALSE 106441
// begin k := 10 ;
106165: LD_ADDR_VAR 0 9
106169: PUSH
106170: LD_INT 10
106172: ST_TO_ADDR
// x := 0 ;
106173: LD_ADDR_VAR 0 10
106177: PUSH
106178: LD_INT 0
106180: ST_TO_ADDR
// if tmp < k then
106181: LD_VAR 0 14
106185: PUSH
106186: LD_VAR 0 9
106190: LESS
106191: IFFALSE 106203
// k := tmp ;
106193: LD_ADDR_VAR 0 9
106197: PUSH
106198: LD_VAR 0 14
106202: ST_TO_ADDR
// for j = k downto 1 do
106203: LD_ADDR_VAR 0 8
106207: PUSH
106208: DOUBLE
106209: LD_VAR 0 9
106213: INC
106214: ST_TO_ADDR
106215: LD_INT 1
106217: PUSH
106218: FOR_DOWNTO
106219: IFFALSE 106294
// begin if GetType ( tmp [ j ] ) = unit_human then
106221: LD_VAR 0 14
106225: PUSH
106226: LD_VAR 0 8
106230: ARRAY
106231: PPUSH
106232: CALL_OW 247
106236: PUSH
106237: LD_INT 1
106239: EQUAL
106240: IFFALSE 106292
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
106242: LD_VAR 0 4
106246: PUSH
106247: LD_VAR 0 7
106251: ARRAY
106252: PPUSH
106253: LD_VAR 0 14
106257: PUSH
106258: LD_VAR 0 8
106262: ARRAY
106263: PPUSH
106264: CALL 47697 0 2
// x := tmp [ j ] ;
106268: LD_ADDR_VAR 0 10
106272: PUSH
106273: LD_VAR 0 14
106277: PUSH
106278: LD_VAR 0 8
106282: ARRAY
106283: ST_TO_ADDR
// attacking := true ;
106284: LD_ADDR_VAR 0 29
106288: PUSH
106289: LD_INT 1
106291: ST_TO_ADDR
// end ; end ;
106292: GO 106218
106294: POP
106295: POP
// if not x then
106296: LD_VAR 0 10
106300: NOT
106301: IFFALSE 106441
// begin attacking := true ;
106303: LD_ADDR_VAR 0 29
106307: PUSH
106308: LD_INT 1
106310: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
106311: LD_VAR 0 4
106315: PUSH
106316: LD_VAR 0 7
106320: ARRAY
106321: PPUSH
106322: CALL_OW 250
106326: PPUSH
106327: LD_VAR 0 4
106331: PUSH
106332: LD_VAR 0 7
106336: ARRAY
106337: PPUSH
106338: CALL_OW 251
106342: PPUSH
106343: CALL_OW 546
106347: PUSH
106348: LD_INT 2
106350: ARRAY
106351: PUSH
106352: LD_VAR 0 14
106356: PUSH
106357: LD_INT 1
106359: ARRAY
106360: PPUSH
106361: CALL_OW 250
106365: PPUSH
106366: LD_VAR 0 14
106370: PUSH
106371: LD_INT 1
106373: ARRAY
106374: PPUSH
106375: CALL_OW 251
106379: PPUSH
106380: CALL_OW 546
106384: PUSH
106385: LD_INT 2
106387: ARRAY
106388: EQUAL
106389: IFFALSE 106417
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
106391: LD_VAR 0 4
106395: PUSH
106396: LD_VAR 0 7
106400: ARRAY
106401: PPUSH
106402: LD_VAR 0 14
106406: PUSH
106407: LD_INT 1
106409: ARRAY
106410: PPUSH
106411: CALL 47697 0 2
106415: GO 106441
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106417: LD_VAR 0 4
106421: PUSH
106422: LD_VAR 0 7
106426: ARRAY
106427: PPUSH
106428: LD_VAR 0 14
106432: PUSH
106433: LD_INT 1
106435: ARRAY
106436: PPUSH
106437: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
106441: LD_VAR 0 4
106445: PUSH
106446: LD_VAR 0 7
106450: ARRAY
106451: PPUSH
106452: CALL_OW 264
106456: PUSH
106457: LD_INT 29
106459: EQUAL
106460: IFFALSE 106826
// begin if WantsToAttack ( group [ i ] ) in bombed then
106462: LD_VAR 0 4
106466: PUSH
106467: LD_VAR 0 7
106471: ARRAY
106472: PPUSH
106473: CALL_OW 319
106477: PUSH
106478: LD_VAR 0 28
106482: IN
106483: IFFALSE 106487
// continue ;
106485: GO 103491
// k := 8 ;
106487: LD_ADDR_VAR 0 9
106491: PUSH
106492: LD_INT 8
106494: ST_TO_ADDR
// x := 0 ;
106495: LD_ADDR_VAR 0 10
106499: PUSH
106500: LD_INT 0
106502: ST_TO_ADDR
// if tmp < k then
106503: LD_VAR 0 14
106507: PUSH
106508: LD_VAR 0 9
106512: LESS
106513: IFFALSE 106525
// k := tmp ;
106515: LD_ADDR_VAR 0 9
106519: PUSH
106520: LD_VAR 0 14
106524: ST_TO_ADDR
// for j = 1 to k do
106525: LD_ADDR_VAR 0 8
106529: PUSH
106530: DOUBLE
106531: LD_INT 1
106533: DEC
106534: ST_TO_ADDR
106535: LD_VAR 0 9
106539: PUSH
106540: FOR_TO
106541: IFFALSE 106673
// begin if GetType ( tmp [ j ] ) = unit_building then
106543: LD_VAR 0 14
106547: PUSH
106548: LD_VAR 0 8
106552: ARRAY
106553: PPUSH
106554: CALL_OW 247
106558: PUSH
106559: LD_INT 3
106561: EQUAL
106562: IFFALSE 106671
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
106564: LD_VAR 0 14
106568: PUSH
106569: LD_VAR 0 8
106573: ARRAY
106574: PUSH
106575: LD_VAR 0 28
106579: IN
106580: NOT
106581: PUSH
106582: LD_VAR 0 14
106586: PUSH
106587: LD_VAR 0 8
106591: ARRAY
106592: PPUSH
106593: CALL_OW 313
106597: AND
106598: IFFALSE 106671
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106600: LD_VAR 0 4
106604: PUSH
106605: LD_VAR 0 7
106609: ARRAY
106610: PPUSH
106611: LD_VAR 0 14
106615: PUSH
106616: LD_VAR 0 8
106620: ARRAY
106621: PPUSH
106622: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
106626: LD_ADDR_VAR 0 28
106630: PUSH
106631: LD_VAR 0 28
106635: PPUSH
106636: LD_VAR 0 28
106640: PUSH
106641: LD_INT 1
106643: PLUS
106644: PPUSH
106645: LD_VAR 0 14
106649: PUSH
106650: LD_VAR 0 8
106654: ARRAY
106655: PPUSH
106656: CALL_OW 1
106660: ST_TO_ADDR
// attacking := true ;
106661: LD_ADDR_VAR 0 29
106665: PUSH
106666: LD_INT 1
106668: ST_TO_ADDR
// break ;
106669: GO 106673
// end ; end ;
106671: GO 106540
106673: POP
106674: POP
// if not attacking and f_attack_depot then
106675: LD_VAR 0 29
106679: NOT
106680: PUSH
106681: LD_VAR 0 25
106685: AND
106686: IFFALSE 106781
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
106688: LD_ADDR_VAR 0 13
106692: PUSH
106693: LD_VAR 0 14
106697: PPUSH
106698: LD_INT 2
106700: PUSH
106701: LD_INT 30
106703: PUSH
106704: LD_INT 0
106706: PUSH
106707: EMPTY
106708: LIST
106709: LIST
106710: PUSH
106711: LD_INT 30
106713: PUSH
106714: LD_INT 1
106716: PUSH
106717: EMPTY
106718: LIST
106719: LIST
106720: PUSH
106721: EMPTY
106722: LIST
106723: LIST
106724: LIST
106725: PPUSH
106726: CALL_OW 72
106730: ST_TO_ADDR
// if z then
106731: LD_VAR 0 13
106735: IFFALSE 106781
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106737: LD_VAR 0 4
106741: PUSH
106742: LD_VAR 0 7
106746: ARRAY
106747: PPUSH
106748: LD_VAR 0 13
106752: PPUSH
106753: LD_VAR 0 4
106757: PUSH
106758: LD_VAR 0 7
106762: ARRAY
106763: PPUSH
106764: CALL_OW 74
106768: PPUSH
106769: CALL_OW 115
// attacking := true ;
106773: LD_ADDR_VAR 0 29
106777: PUSH
106778: LD_INT 1
106780: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106781: LD_VAR 0 4
106785: PUSH
106786: LD_VAR 0 7
106790: ARRAY
106791: PPUSH
106792: CALL_OW 256
106796: PUSH
106797: LD_INT 500
106799: LESS
106800: IFFALSE 106826
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106802: LD_VAR 0 4
106806: PUSH
106807: LD_VAR 0 7
106811: ARRAY
106812: PPUSH
106813: LD_VAR 0 14
106817: PUSH
106818: LD_INT 1
106820: ARRAY
106821: PPUSH
106822: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106826: LD_VAR 0 4
106830: PUSH
106831: LD_VAR 0 7
106835: ARRAY
106836: PPUSH
106837: CALL_OW 264
106841: PUSH
106842: LD_INT 49
106844: EQUAL
106845: IFFALSE 106966
// begin if not HasTask ( group [ i ] ) then
106847: LD_VAR 0 4
106851: PUSH
106852: LD_VAR 0 7
106856: ARRAY
106857: PPUSH
106858: CALL_OW 314
106862: NOT
106863: IFFALSE 106966
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106865: LD_ADDR_VAR 0 9
106869: PUSH
106870: LD_INT 81
106872: PUSH
106873: LD_VAR 0 4
106877: PUSH
106878: LD_VAR 0 7
106882: ARRAY
106883: PPUSH
106884: CALL_OW 255
106888: PUSH
106889: EMPTY
106890: LIST
106891: LIST
106892: PPUSH
106893: CALL_OW 69
106897: PPUSH
106898: LD_VAR 0 4
106902: PUSH
106903: LD_VAR 0 7
106907: ARRAY
106908: PPUSH
106909: CALL_OW 74
106913: ST_TO_ADDR
// if k then
106914: LD_VAR 0 9
106918: IFFALSE 106966
// if GetDistUnits ( group [ i ] , k ) > 10 then
106920: LD_VAR 0 4
106924: PUSH
106925: LD_VAR 0 7
106929: ARRAY
106930: PPUSH
106931: LD_VAR 0 9
106935: PPUSH
106936: CALL_OW 296
106940: PUSH
106941: LD_INT 10
106943: GREATER
106944: IFFALSE 106966
// ComMoveUnit ( group [ i ] , k ) ;
106946: LD_VAR 0 4
106950: PUSH
106951: LD_VAR 0 7
106955: ARRAY
106956: PPUSH
106957: LD_VAR 0 9
106961: PPUSH
106962: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106966: LD_VAR 0 4
106970: PUSH
106971: LD_VAR 0 7
106975: ARRAY
106976: PPUSH
106977: CALL_OW 256
106981: PUSH
106982: LD_INT 250
106984: LESS
106985: PUSH
106986: LD_VAR 0 4
106990: PUSH
106991: LD_VAR 0 7
106995: ARRAY
106996: PUSH
106997: LD_INT 21
106999: PUSH
107000: LD_INT 2
107002: PUSH
107003: EMPTY
107004: LIST
107005: LIST
107006: PUSH
107007: LD_INT 23
107009: PUSH
107010: LD_INT 2
107012: PUSH
107013: EMPTY
107014: LIST
107015: LIST
107016: PUSH
107017: EMPTY
107018: LIST
107019: LIST
107020: PPUSH
107021: CALL_OW 69
107025: IN
107026: AND
107027: IFFALSE 107152
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
107029: LD_ADDR_VAR 0 9
107033: PUSH
107034: LD_OWVAR 3
107038: PUSH
107039: LD_VAR 0 4
107043: PUSH
107044: LD_VAR 0 7
107048: ARRAY
107049: DIFF
107050: PPUSH
107051: LD_VAR 0 4
107055: PUSH
107056: LD_VAR 0 7
107060: ARRAY
107061: PPUSH
107062: CALL_OW 74
107066: ST_TO_ADDR
// if not k then
107067: LD_VAR 0 9
107071: NOT
107072: IFFALSE 107076
// continue ;
107074: GO 103491
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
107076: LD_VAR 0 9
107080: PUSH
107081: LD_INT 81
107083: PUSH
107084: LD_VAR 0 4
107088: PUSH
107089: LD_VAR 0 7
107093: ARRAY
107094: PPUSH
107095: CALL_OW 255
107099: PUSH
107100: EMPTY
107101: LIST
107102: LIST
107103: PPUSH
107104: CALL_OW 69
107108: IN
107109: PUSH
107110: LD_VAR 0 9
107114: PPUSH
107115: LD_VAR 0 4
107119: PUSH
107120: LD_VAR 0 7
107124: ARRAY
107125: PPUSH
107126: CALL_OW 296
107130: PUSH
107131: LD_INT 5
107133: LESS
107134: AND
107135: IFFALSE 107152
// ComAutodestruct ( group [ i ] ) ;
107137: LD_VAR 0 4
107141: PUSH
107142: LD_VAR 0 7
107146: ARRAY
107147: PPUSH
107148: CALL 47595 0 1
// end ; if f_attack_depot then
107152: LD_VAR 0 25
107156: IFFALSE 107268
// begin k := 6 ;
107158: LD_ADDR_VAR 0 9
107162: PUSH
107163: LD_INT 6
107165: ST_TO_ADDR
// if tmp < k then
107166: LD_VAR 0 14
107170: PUSH
107171: LD_VAR 0 9
107175: LESS
107176: IFFALSE 107188
// k := tmp ;
107178: LD_ADDR_VAR 0 9
107182: PUSH
107183: LD_VAR 0 14
107187: ST_TO_ADDR
// for j = 1 to k do
107188: LD_ADDR_VAR 0 8
107192: PUSH
107193: DOUBLE
107194: LD_INT 1
107196: DEC
107197: ST_TO_ADDR
107198: LD_VAR 0 9
107202: PUSH
107203: FOR_TO
107204: IFFALSE 107266
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
107206: LD_VAR 0 8
107210: PPUSH
107211: CALL_OW 266
107215: PUSH
107216: LD_INT 0
107218: PUSH
107219: LD_INT 1
107221: PUSH
107222: EMPTY
107223: LIST
107224: LIST
107225: IN
107226: IFFALSE 107264
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107228: LD_VAR 0 4
107232: PUSH
107233: LD_VAR 0 7
107237: ARRAY
107238: PPUSH
107239: LD_VAR 0 14
107243: PUSH
107244: LD_VAR 0 8
107248: ARRAY
107249: PPUSH
107250: CALL_OW 115
// attacking := true ;
107254: LD_ADDR_VAR 0 29
107258: PUSH
107259: LD_INT 1
107261: ST_TO_ADDR
// break ;
107262: GO 107266
// end ;
107264: GO 107203
107266: POP
107267: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
107268: LD_VAR 0 4
107272: PUSH
107273: LD_VAR 0 7
107277: ARRAY
107278: PPUSH
107279: CALL_OW 302
107283: PUSH
107284: LD_VAR 0 29
107288: NOT
107289: AND
107290: IFFALSE 107612
// begin if GetTag ( group [ i ] ) = 71 then
107292: LD_VAR 0 4
107296: PUSH
107297: LD_VAR 0 7
107301: ARRAY
107302: PPUSH
107303: CALL_OW 110
107307: PUSH
107308: LD_INT 71
107310: EQUAL
107311: IFFALSE 107352
// begin if HasTask ( group [ i ] ) then
107313: LD_VAR 0 4
107317: PUSH
107318: LD_VAR 0 7
107322: ARRAY
107323: PPUSH
107324: CALL_OW 314
107328: IFFALSE 107334
// continue else
107330: GO 103491
107332: GO 107352
// SetTag ( group [ i ] , 0 ) ;
107334: LD_VAR 0 4
107338: PUSH
107339: LD_VAR 0 7
107343: ARRAY
107344: PPUSH
107345: LD_INT 0
107347: PPUSH
107348: CALL_OW 109
// end ; k := 8 ;
107352: LD_ADDR_VAR 0 9
107356: PUSH
107357: LD_INT 8
107359: ST_TO_ADDR
// x := 0 ;
107360: LD_ADDR_VAR 0 10
107364: PUSH
107365: LD_INT 0
107367: ST_TO_ADDR
// if tmp < k then
107368: LD_VAR 0 14
107372: PUSH
107373: LD_VAR 0 9
107377: LESS
107378: IFFALSE 107390
// k := tmp ;
107380: LD_ADDR_VAR 0 9
107384: PUSH
107385: LD_VAR 0 14
107389: ST_TO_ADDR
// for j = 1 to k do
107390: LD_ADDR_VAR 0 8
107394: PUSH
107395: DOUBLE
107396: LD_INT 1
107398: DEC
107399: ST_TO_ADDR
107400: LD_VAR 0 9
107404: PUSH
107405: FOR_TO
107406: IFFALSE 107504
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
107408: LD_VAR 0 14
107412: PUSH
107413: LD_VAR 0 8
107417: ARRAY
107418: PPUSH
107419: CALL_OW 247
107423: PUSH
107424: LD_INT 1
107426: EQUAL
107427: PUSH
107428: LD_VAR 0 14
107432: PUSH
107433: LD_VAR 0 8
107437: ARRAY
107438: PPUSH
107439: CALL_OW 256
107443: PUSH
107444: LD_INT 250
107446: LESS
107447: PUSH
107448: LD_VAR 0 20
107452: AND
107453: PUSH
107454: LD_VAR 0 20
107458: NOT
107459: PUSH
107460: LD_VAR 0 14
107464: PUSH
107465: LD_VAR 0 8
107469: ARRAY
107470: PPUSH
107471: CALL_OW 256
107475: PUSH
107476: LD_INT 250
107478: GREATEREQUAL
107479: AND
107480: OR
107481: AND
107482: IFFALSE 107502
// begin x := tmp [ j ] ;
107484: LD_ADDR_VAR 0 10
107488: PUSH
107489: LD_VAR 0 14
107493: PUSH
107494: LD_VAR 0 8
107498: ARRAY
107499: ST_TO_ADDR
// break ;
107500: GO 107504
// end ;
107502: GO 107405
107504: POP
107505: POP
// if x then
107506: LD_VAR 0 10
107510: IFFALSE 107534
// ComAttackUnit ( group [ i ] , x ) else
107512: LD_VAR 0 4
107516: PUSH
107517: LD_VAR 0 7
107521: ARRAY
107522: PPUSH
107523: LD_VAR 0 10
107527: PPUSH
107528: CALL_OW 115
107532: GO 107558
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107534: LD_VAR 0 4
107538: PUSH
107539: LD_VAR 0 7
107543: ARRAY
107544: PPUSH
107545: LD_VAR 0 14
107549: PUSH
107550: LD_INT 1
107552: ARRAY
107553: PPUSH
107554: CALL_OW 115
// if not HasTask ( group [ i ] ) then
107558: LD_VAR 0 4
107562: PUSH
107563: LD_VAR 0 7
107567: ARRAY
107568: PPUSH
107569: CALL_OW 314
107573: NOT
107574: IFFALSE 107612
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
107576: LD_VAR 0 4
107580: PUSH
107581: LD_VAR 0 7
107585: ARRAY
107586: PPUSH
107587: LD_VAR 0 14
107591: PPUSH
107592: LD_VAR 0 4
107596: PUSH
107597: LD_VAR 0 7
107601: ARRAY
107602: PPUSH
107603: CALL_OW 74
107607: PPUSH
107608: CALL_OW 115
// end ; end ; end ;
107612: GO 103491
107614: POP
107615: POP
// wait ( 0 0$2 ) ;
107616: LD_INT 70
107618: PPUSH
107619: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
107623: LD_VAR 0 4
107627: NOT
107628: PUSH
107629: LD_VAR 0 4
107633: PUSH
107634: EMPTY
107635: EQUAL
107636: OR
107637: PUSH
107638: LD_INT 81
107640: PUSH
107641: LD_VAR 0 35
107645: PUSH
107646: EMPTY
107647: LIST
107648: LIST
107649: PPUSH
107650: CALL_OW 69
107654: NOT
107655: OR
107656: IFFALSE 103476
// end ;
107658: LD_VAR 0 2
107662: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
107663: LD_INT 0
107665: PPUSH
107666: PPUSH
107667: PPUSH
107668: PPUSH
107669: PPUSH
107670: PPUSH
// if not base or not mc_bases [ base ] or not solds then
107671: LD_VAR 0 1
107675: NOT
107676: PUSH
107677: LD_EXP 60
107681: PUSH
107682: LD_VAR 0 1
107686: ARRAY
107687: NOT
107688: OR
107689: PUSH
107690: LD_VAR 0 2
107694: NOT
107695: OR
107696: IFFALSE 107700
// exit ;
107698: GO 108254
// side := mc_sides [ base ] ;
107700: LD_ADDR_VAR 0 6
107704: PUSH
107705: LD_EXP 86
107709: PUSH
107710: LD_VAR 0 1
107714: ARRAY
107715: ST_TO_ADDR
// if not side then
107716: LD_VAR 0 6
107720: NOT
107721: IFFALSE 107725
// exit ;
107723: GO 108254
// for i in solds do
107725: LD_ADDR_VAR 0 7
107729: PUSH
107730: LD_VAR 0 2
107734: PUSH
107735: FOR_IN
107736: IFFALSE 107797
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107738: LD_VAR 0 7
107742: PPUSH
107743: CALL_OW 310
107747: PPUSH
107748: CALL_OW 266
107752: PUSH
107753: LD_INT 32
107755: PUSH
107756: LD_INT 31
107758: PUSH
107759: EMPTY
107760: LIST
107761: LIST
107762: IN
107763: IFFALSE 107783
// solds := solds diff i else
107765: LD_ADDR_VAR 0 2
107769: PUSH
107770: LD_VAR 0 2
107774: PUSH
107775: LD_VAR 0 7
107779: DIFF
107780: ST_TO_ADDR
107781: GO 107795
// SetTag ( i , 18 ) ;
107783: LD_VAR 0 7
107787: PPUSH
107788: LD_INT 18
107790: PPUSH
107791: CALL_OW 109
107795: GO 107735
107797: POP
107798: POP
// if not solds then
107799: LD_VAR 0 2
107803: NOT
107804: IFFALSE 107808
// exit ;
107806: GO 108254
// repeat wait ( 0 0$2 ) ;
107808: LD_INT 70
107810: PPUSH
107811: CALL_OW 67
// enemy := mc_scan [ base ] ;
107815: LD_ADDR_VAR 0 4
107819: PUSH
107820: LD_EXP 83
107824: PUSH
107825: LD_VAR 0 1
107829: ARRAY
107830: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107831: LD_EXP 60
107835: PUSH
107836: LD_VAR 0 1
107840: ARRAY
107841: NOT
107842: PUSH
107843: LD_EXP 60
107847: PUSH
107848: LD_VAR 0 1
107852: ARRAY
107853: PUSH
107854: EMPTY
107855: EQUAL
107856: OR
107857: IFFALSE 107894
// begin for i in solds do
107859: LD_ADDR_VAR 0 7
107863: PUSH
107864: LD_VAR 0 2
107868: PUSH
107869: FOR_IN
107870: IFFALSE 107883
// ComStop ( i ) ;
107872: LD_VAR 0 7
107876: PPUSH
107877: CALL_OW 141
107881: GO 107869
107883: POP
107884: POP
// solds := [ ] ;
107885: LD_ADDR_VAR 0 2
107889: PUSH
107890: EMPTY
107891: ST_TO_ADDR
// exit ;
107892: GO 108254
// end ; for i in solds do
107894: LD_ADDR_VAR 0 7
107898: PUSH
107899: LD_VAR 0 2
107903: PUSH
107904: FOR_IN
107905: IFFALSE 108226
// begin if IsInUnit ( i ) then
107907: LD_VAR 0 7
107911: PPUSH
107912: CALL_OW 310
107916: IFFALSE 107927
// ComExitBuilding ( i ) ;
107918: LD_VAR 0 7
107922: PPUSH
107923: CALL_OW 122
// if GetLives ( i ) > 500 then
107927: LD_VAR 0 7
107931: PPUSH
107932: CALL_OW 256
107936: PUSH
107937: LD_INT 500
107939: GREATER
107940: IFFALSE 107993
// begin e := NearestUnitToUnit ( enemy , i ) ;
107942: LD_ADDR_VAR 0 5
107946: PUSH
107947: LD_VAR 0 4
107951: PPUSH
107952: LD_VAR 0 7
107956: PPUSH
107957: CALL_OW 74
107961: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
107962: LD_VAR 0 7
107966: PPUSH
107967: LD_VAR 0 5
107971: PPUSH
107972: CALL_OW 250
107976: PPUSH
107977: LD_VAR 0 5
107981: PPUSH
107982: CALL_OW 251
107986: PPUSH
107987: CALL_OW 114
// end else
107991: GO 108224
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
107993: LD_VAR 0 7
107997: PPUSH
107998: LD_EXP 60
108002: PUSH
108003: LD_VAR 0 1
108007: ARRAY
108008: PPUSH
108009: LD_INT 2
108011: PUSH
108012: LD_INT 30
108014: PUSH
108015: LD_INT 0
108017: PUSH
108018: EMPTY
108019: LIST
108020: LIST
108021: PUSH
108022: LD_INT 30
108024: PUSH
108025: LD_INT 1
108027: PUSH
108028: EMPTY
108029: LIST
108030: LIST
108031: PUSH
108032: LD_INT 30
108034: PUSH
108035: LD_INT 6
108037: PUSH
108038: EMPTY
108039: LIST
108040: LIST
108041: PUSH
108042: EMPTY
108043: LIST
108044: LIST
108045: LIST
108046: LIST
108047: PPUSH
108048: CALL_OW 72
108052: PPUSH
108053: LD_VAR 0 7
108057: PPUSH
108058: CALL_OW 74
108062: PPUSH
108063: CALL_OW 296
108067: PUSH
108068: LD_INT 10
108070: GREATER
108071: IFFALSE 108224
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
108073: LD_ADDR_VAR 0 8
108077: PUSH
108078: LD_EXP 60
108082: PUSH
108083: LD_VAR 0 1
108087: ARRAY
108088: PPUSH
108089: LD_INT 2
108091: PUSH
108092: LD_INT 30
108094: PUSH
108095: LD_INT 0
108097: PUSH
108098: EMPTY
108099: LIST
108100: LIST
108101: PUSH
108102: LD_INT 30
108104: PUSH
108105: LD_INT 1
108107: PUSH
108108: EMPTY
108109: LIST
108110: LIST
108111: PUSH
108112: LD_INT 30
108114: PUSH
108115: LD_INT 6
108117: PUSH
108118: EMPTY
108119: LIST
108120: LIST
108121: PUSH
108122: EMPTY
108123: LIST
108124: LIST
108125: LIST
108126: LIST
108127: PPUSH
108128: CALL_OW 72
108132: PPUSH
108133: LD_VAR 0 7
108137: PPUSH
108138: CALL_OW 74
108142: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
108143: LD_VAR 0 7
108147: PPUSH
108148: LD_VAR 0 8
108152: PPUSH
108153: CALL_OW 250
108157: PPUSH
108158: LD_INT 3
108160: PPUSH
108161: LD_INT 5
108163: PPUSH
108164: CALL_OW 272
108168: PPUSH
108169: LD_VAR 0 8
108173: PPUSH
108174: CALL_OW 251
108178: PPUSH
108179: LD_INT 3
108181: PPUSH
108182: LD_INT 5
108184: PPUSH
108185: CALL_OW 273
108189: PPUSH
108190: CALL_OW 111
// SetTag ( i , 0 ) ;
108194: LD_VAR 0 7
108198: PPUSH
108199: LD_INT 0
108201: PPUSH
108202: CALL_OW 109
// solds := solds diff i ;
108206: LD_ADDR_VAR 0 2
108210: PUSH
108211: LD_VAR 0 2
108215: PUSH
108216: LD_VAR 0 7
108220: DIFF
108221: ST_TO_ADDR
// continue ;
108222: GO 107904
// end ; end ;
108224: GO 107904
108226: POP
108227: POP
// until not solds or not enemy ;
108228: LD_VAR 0 2
108232: NOT
108233: PUSH
108234: LD_VAR 0 4
108238: NOT
108239: OR
108240: IFFALSE 107808
// MC_Reset ( base , 18 ) ;
108242: LD_VAR 0 1
108246: PPUSH
108247: LD_INT 18
108249: PPUSH
108250: CALL 58524 0 2
// end ;
108254: LD_VAR 0 3
108258: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
108259: LD_INT 0
108261: PPUSH
108262: PPUSH
108263: PPUSH
108264: PPUSH
108265: PPUSH
108266: PPUSH
108267: PPUSH
108268: PPUSH
108269: PPUSH
108270: PPUSH
108271: PPUSH
108272: PPUSH
108273: PPUSH
108274: PPUSH
108275: PPUSH
108276: PPUSH
108277: PPUSH
108278: PPUSH
108279: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
108280: LD_ADDR_VAR 0 12
108284: PUSH
108285: LD_EXP 60
108289: PUSH
108290: LD_VAR 0 1
108294: ARRAY
108295: PPUSH
108296: LD_INT 25
108298: PUSH
108299: LD_INT 3
108301: PUSH
108302: EMPTY
108303: LIST
108304: LIST
108305: PPUSH
108306: CALL_OW 72
108310: ST_TO_ADDR
// if mc_remote_driver [ base ] then
108311: LD_EXP 100
108315: PUSH
108316: LD_VAR 0 1
108320: ARRAY
108321: IFFALSE 108345
// mechs := mechs diff mc_remote_driver [ base ] ;
108323: LD_ADDR_VAR 0 12
108327: PUSH
108328: LD_VAR 0 12
108332: PUSH
108333: LD_EXP 100
108337: PUSH
108338: LD_VAR 0 1
108342: ARRAY
108343: DIFF
108344: ST_TO_ADDR
// for i in mechs do
108345: LD_ADDR_VAR 0 4
108349: PUSH
108350: LD_VAR 0 12
108354: PUSH
108355: FOR_IN
108356: IFFALSE 108391
// if GetTag ( i ) > 0 then
108358: LD_VAR 0 4
108362: PPUSH
108363: CALL_OW 110
108367: PUSH
108368: LD_INT 0
108370: GREATER
108371: IFFALSE 108389
// mechs := mechs diff i ;
108373: LD_ADDR_VAR 0 12
108377: PUSH
108378: LD_VAR 0 12
108382: PUSH
108383: LD_VAR 0 4
108387: DIFF
108388: ST_TO_ADDR
108389: GO 108355
108391: POP
108392: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108393: LD_ADDR_VAR 0 8
108397: PUSH
108398: LD_EXP 60
108402: PUSH
108403: LD_VAR 0 1
108407: ARRAY
108408: PPUSH
108409: LD_INT 2
108411: PUSH
108412: LD_INT 25
108414: PUSH
108415: LD_INT 1
108417: PUSH
108418: EMPTY
108419: LIST
108420: LIST
108421: PUSH
108422: LD_INT 25
108424: PUSH
108425: LD_INT 5
108427: PUSH
108428: EMPTY
108429: LIST
108430: LIST
108431: PUSH
108432: LD_INT 25
108434: PUSH
108435: LD_INT 8
108437: PUSH
108438: EMPTY
108439: LIST
108440: LIST
108441: PUSH
108442: LD_INT 25
108444: PUSH
108445: LD_INT 9
108447: PUSH
108448: EMPTY
108449: LIST
108450: LIST
108451: PUSH
108452: EMPTY
108453: LIST
108454: LIST
108455: LIST
108456: LIST
108457: LIST
108458: PPUSH
108459: CALL_OW 72
108463: ST_TO_ADDR
// if not defenders and not solds then
108464: LD_VAR 0 2
108468: NOT
108469: PUSH
108470: LD_VAR 0 8
108474: NOT
108475: AND
108476: IFFALSE 108480
// exit ;
108478: GO 110250
// depot_under_attack := false ;
108480: LD_ADDR_VAR 0 16
108484: PUSH
108485: LD_INT 0
108487: ST_TO_ADDR
// sold_defenders := [ ] ;
108488: LD_ADDR_VAR 0 17
108492: PUSH
108493: EMPTY
108494: ST_TO_ADDR
// if mechs then
108495: LD_VAR 0 12
108499: IFFALSE 108652
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
108501: LD_ADDR_VAR 0 4
108505: PUSH
108506: LD_VAR 0 2
108510: PPUSH
108511: LD_INT 21
108513: PUSH
108514: LD_INT 2
108516: PUSH
108517: EMPTY
108518: LIST
108519: LIST
108520: PPUSH
108521: CALL_OW 72
108525: PUSH
108526: FOR_IN
108527: IFFALSE 108650
// begin if GetTag ( i ) <> 20 then
108529: LD_VAR 0 4
108533: PPUSH
108534: CALL_OW 110
108538: PUSH
108539: LD_INT 20
108541: NONEQUAL
108542: IFFALSE 108556
// SetTag ( i , 20 ) ;
108544: LD_VAR 0 4
108548: PPUSH
108549: LD_INT 20
108551: PPUSH
108552: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
108556: LD_VAR 0 4
108560: PPUSH
108561: CALL_OW 263
108565: PUSH
108566: LD_INT 1
108568: EQUAL
108569: PUSH
108570: LD_VAR 0 4
108574: PPUSH
108575: CALL_OW 311
108579: NOT
108580: AND
108581: IFFALSE 108648
// begin un := mechs [ 1 ] ;
108583: LD_ADDR_VAR 0 10
108587: PUSH
108588: LD_VAR 0 12
108592: PUSH
108593: LD_INT 1
108595: ARRAY
108596: ST_TO_ADDR
// ComExit ( un ) ;
108597: LD_VAR 0 10
108601: PPUSH
108602: CALL 51940 0 1
// AddComEnterUnit ( un , i ) ;
108606: LD_VAR 0 10
108610: PPUSH
108611: LD_VAR 0 4
108615: PPUSH
108616: CALL_OW 180
// SetTag ( un , 19 ) ;
108620: LD_VAR 0 10
108624: PPUSH
108625: LD_INT 19
108627: PPUSH
108628: CALL_OW 109
// mechs := mechs diff un ;
108632: LD_ADDR_VAR 0 12
108636: PUSH
108637: LD_VAR 0 12
108641: PUSH
108642: LD_VAR 0 10
108646: DIFF
108647: ST_TO_ADDR
// end ; end ;
108648: GO 108526
108650: POP
108651: POP
// if solds then
108652: LD_VAR 0 8
108656: IFFALSE 108715
// for i in solds do
108658: LD_ADDR_VAR 0 4
108662: PUSH
108663: LD_VAR 0 8
108667: PUSH
108668: FOR_IN
108669: IFFALSE 108713
// if not GetTag ( i ) then
108671: LD_VAR 0 4
108675: PPUSH
108676: CALL_OW 110
108680: NOT
108681: IFFALSE 108711
// begin defenders := defenders union i ;
108683: LD_ADDR_VAR 0 2
108687: PUSH
108688: LD_VAR 0 2
108692: PUSH
108693: LD_VAR 0 4
108697: UNION
108698: ST_TO_ADDR
// SetTag ( i , 18 ) ;
108699: LD_VAR 0 4
108703: PPUSH
108704: LD_INT 18
108706: PPUSH
108707: CALL_OW 109
// end ;
108711: GO 108668
108713: POP
108714: POP
// repeat wait ( 0 0$2 ) ;
108715: LD_INT 70
108717: PPUSH
108718: CALL_OW 67
// enemy := mc_scan [ base ] ;
108722: LD_ADDR_VAR 0 21
108726: PUSH
108727: LD_EXP 83
108731: PUSH
108732: LD_VAR 0 1
108736: ARRAY
108737: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108738: LD_EXP 60
108742: PUSH
108743: LD_VAR 0 1
108747: ARRAY
108748: NOT
108749: PUSH
108750: LD_EXP 60
108754: PUSH
108755: LD_VAR 0 1
108759: ARRAY
108760: PUSH
108761: EMPTY
108762: EQUAL
108763: OR
108764: IFFALSE 108801
// begin for i in defenders do
108766: LD_ADDR_VAR 0 4
108770: PUSH
108771: LD_VAR 0 2
108775: PUSH
108776: FOR_IN
108777: IFFALSE 108790
// ComStop ( i ) ;
108779: LD_VAR 0 4
108783: PPUSH
108784: CALL_OW 141
108788: GO 108776
108790: POP
108791: POP
// defenders := [ ] ;
108792: LD_ADDR_VAR 0 2
108796: PUSH
108797: EMPTY
108798: ST_TO_ADDR
// exit ;
108799: GO 110250
// end ; for i in defenders do
108801: LD_ADDR_VAR 0 4
108805: PUSH
108806: LD_VAR 0 2
108810: PUSH
108811: FOR_IN
108812: IFFALSE 109710
// begin e := NearestUnitToUnit ( enemy , i ) ;
108814: LD_ADDR_VAR 0 13
108818: PUSH
108819: LD_VAR 0 21
108823: PPUSH
108824: LD_VAR 0 4
108828: PPUSH
108829: CALL_OW 74
108833: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108834: LD_ADDR_VAR 0 7
108838: PUSH
108839: LD_EXP 60
108843: PUSH
108844: LD_VAR 0 1
108848: ARRAY
108849: PPUSH
108850: LD_INT 2
108852: PUSH
108853: LD_INT 30
108855: PUSH
108856: LD_INT 0
108858: PUSH
108859: EMPTY
108860: LIST
108861: LIST
108862: PUSH
108863: LD_INT 30
108865: PUSH
108866: LD_INT 1
108868: PUSH
108869: EMPTY
108870: LIST
108871: LIST
108872: PUSH
108873: EMPTY
108874: LIST
108875: LIST
108876: LIST
108877: PPUSH
108878: CALL_OW 72
108882: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108883: LD_ADDR_VAR 0 16
108887: PUSH
108888: LD_VAR 0 7
108892: NOT
108893: PUSH
108894: LD_VAR 0 7
108898: PPUSH
108899: LD_INT 3
108901: PUSH
108902: LD_INT 24
108904: PUSH
108905: LD_INT 600
108907: PUSH
108908: EMPTY
108909: LIST
108910: LIST
108911: PUSH
108912: EMPTY
108913: LIST
108914: LIST
108915: PPUSH
108916: CALL_OW 72
108920: OR
108921: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108922: LD_VAR 0 4
108926: PPUSH
108927: CALL_OW 247
108931: PUSH
108932: LD_INT 2
108934: DOUBLE
108935: EQUAL
108936: IFTRUE 108940
108938: GO 109336
108940: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108941: LD_VAR 0 4
108945: PPUSH
108946: CALL_OW 256
108950: PUSH
108951: LD_INT 1000
108953: EQUAL
108954: PUSH
108955: LD_VAR 0 4
108959: PPUSH
108960: LD_VAR 0 13
108964: PPUSH
108965: CALL_OW 296
108969: PUSH
108970: LD_INT 40
108972: LESS
108973: PUSH
108974: LD_VAR 0 13
108978: PPUSH
108979: LD_EXP 85
108983: PUSH
108984: LD_VAR 0 1
108988: ARRAY
108989: PPUSH
108990: CALL_OW 308
108994: OR
108995: AND
108996: IFFALSE 109118
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108998: LD_VAR 0 4
109002: PPUSH
109003: CALL_OW 262
109007: PUSH
109008: LD_INT 1
109010: EQUAL
109011: PUSH
109012: LD_VAR 0 4
109016: PPUSH
109017: CALL_OW 261
109021: PUSH
109022: LD_INT 30
109024: LESS
109025: AND
109026: PUSH
109027: LD_VAR 0 7
109031: AND
109032: IFFALSE 109102
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
109034: LD_VAR 0 4
109038: PPUSH
109039: LD_VAR 0 7
109043: PPUSH
109044: LD_VAR 0 4
109048: PPUSH
109049: CALL_OW 74
109053: PPUSH
109054: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
109058: LD_VAR 0 4
109062: PPUSH
109063: LD_VAR 0 7
109067: PPUSH
109068: LD_VAR 0 4
109072: PPUSH
109073: CALL_OW 74
109077: PPUSH
109078: CALL_OW 296
109082: PUSH
109083: LD_INT 6
109085: LESS
109086: IFFALSE 109100
// SetFuel ( i , 100 ) ;
109088: LD_VAR 0 4
109092: PPUSH
109093: LD_INT 100
109095: PPUSH
109096: CALL_OW 240
// end else
109100: GO 109116
// ComAttackUnit ( i , e ) ;
109102: LD_VAR 0 4
109106: PPUSH
109107: LD_VAR 0 13
109111: PPUSH
109112: CALL_OW 115
// end else
109116: GO 109219
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
109118: LD_VAR 0 13
109122: PPUSH
109123: LD_EXP 85
109127: PUSH
109128: LD_VAR 0 1
109132: ARRAY
109133: PPUSH
109134: CALL_OW 308
109138: NOT
109139: PUSH
109140: LD_VAR 0 4
109144: PPUSH
109145: LD_VAR 0 13
109149: PPUSH
109150: CALL_OW 296
109154: PUSH
109155: LD_INT 40
109157: GREATEREQUAL
109158: AND
109159: PUSH
109160: LD_VAR 0 4
109164: PPUSH
109165: CALL_OW 256
109169: PUSH
109170: LD_INT 650
109172: LESSEQUAL
109173: OR
109174: PUSH
109175: LD_VAR 0 4
109179: PPUSH
109180: LD_EXP 84
109184: PUSH
109185: LD_VAR 0 1
109189: ARRAY
109190: PPUSH
109191: CALL_OW 308
109195: NOT
109196: AND
109197: IFFALSE 109219
// ComMoveToArea ( i , mc_parking [ base ] ) ;
109199: LD_VAR 0 4
109203: PPUSH
109204: LD_EXP 84
109208: PUSH
109209: LD_VAR 0 1
109213: ARRAY
109214: PPUSH
109215: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
109219: LD_VAR 0 4
109223: PPUSH
109224: CALL_OW 256
109228: PUSH
109229: LD_INT 1000
109231: LESS
109232: PUSH
109233: LD_VAR 0 4
109237: PPUSH
109238: CALL_OW 263
109242: PUSH
109243: LD_INT 1
109245: EQUAL
109246: AND
109247: PUSH
109248: LD_VAR 0 4
109252: PPUSH
109253: CALL_OW 311
109257: AND
109258: PUSH
109259: LD_VAR 0 4
109263: PPUSH
109264: LD_EXP 84
109268: PUSH
109269: LD_VAR 0 1
109273: ARRAY
109274: PPUSH
109275: CALL_OW 308
109279: AND
109280: IFFALSE 109334
// begin mech := IsDrivenBy ( i ) ;
109282: LD_ADDR_VAR 0 9
109286: PUSH
109287: LD_VAR 0 4
109291: PPUSH
109292: CALL_OW 311
109296: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
109297: LD_VAR 0 9
109301: PPUSH
109302: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
109306: LD_VAR 0 9
109310: PPUSH
109311: LD_VAR 0 4
109315: PPUSH
109316: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
109320: LD_VAR 0 9
109324: PPUSH
109325: LD_VAR 0 4
109329: PPUSH
109330: CALL_OW 180
// end ; end ; unit_human :
109334: GO 109681
109336: LD_INT 1
109338: DOUBLE
109339: EQUAL
109340: IFTRUE 109344
109342: GO 109680
109344: POP
// begin b := IsInUnit ( i ) ;
109345: LD_ADDR_VAR 0 18
109349: PUSH
109350: LD_VAR 0 4
109354: PPUSH
109355: CALL_OW 310
109359: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
109360: LD_ADDR_VAR 0 19
109364: PUSH
109365: LD_VAR 0 18
109369: NOT
109370: PUSH
109371: LD_VAR 0 18
109375: PPUSH
109376: CALL_OW 266
109380: PUSH
109381: LD_INT 32
109383: PUSH
109384: LD_INT 31
109386: PUSH
109387: EMPTY
109388: LIST
109389: LIST
109390: IN
109391: OR
109392: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
109393: LD_VAR 0 18
109397: PPUSH
109398: CALL_OW 266
109402: PUSH
109403: LD_INT 5
109405: EQUAL
109406: PUSH
109407: LD_VAR 0 4
109411: PPUSH
109412: CALL_OW 257
109416: PUSH
109417: LD_INT 1
109419: PUSH
109420: LD_INT 2
109422: PUSH
109423: LD_INT 3
109425: PUSH
109426: LD_INT 4
109428: PUSH
109429: EMPTY
109430: LIST
109431: LIST
109432: LIST
109433: LIST
109434: IN
109435: AND
109436: IFFALSE 109473
// begin class := AllowSpecClass ( i ) ;
109438: LD_ADDR_VAR 0 20
109442: PUSH
109443: LD_VAR 0 4
109447: PPUSH
109448: CALL 16601 0 1
109452: ST_TO_ADDR
// if class then
109453: LD_VAR 0 20
109457: IFFALSE 109473
// ComChangeProfession ( i , class ) ;
109459: LD_VAR 0 4
109463: PPUSH
109464: LD_VAR 0 20
109468: PPUSH
109469: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
109473: LD_VAR 0 16
109477: PUSH
109478: LD_VAR 0 2
109482: PPUSH
109483: LD_INT 21
109485: PUSH
109486: LD_INT 2
109488: PUSH
109489: EMPTY
109490: LIST
109491: LIST
109492: PPUSH
109493: CALL_OW 72
109497: PUSH
109498: LD_INT 1
109500: LESSEQUAL
109501: OR
109502: PUSH
109503: LD_VAR 0 19
109507: AND
109508: PUSH
109509: LD_VAR 0 4
109513: PUSH
109514: LD_VAR 0 17
109518: IN
109519: NOT
109520: AND
109521: IFFALSE 109614
// begin if b then
109523: LD_VAR 0 18
109527: IFFALSE 109576
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
109529: LD_VAR 0 18
109533: PPUSH
109534: LD_VAR 0 21
109538: PPUSH
109539: LD_VAR 0 18
109543: PPUSH
109544: CALL_OW 74
109548: PPUSH
109549: CALL_OW 296
109553: PUSH
109554: LD_INT 10
109556: LESS
109557: PUSH
109558: LD_VAR 0 18
109562: PPUSH
109563: CALL_OW 461
109567: PUSH
109568: LD_INT 7
109570: NONEQUAL
109571: AND
109572: IFFALSE 109576
// continue ;
109574: GO 108811
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
109576: LD_ADDR_VAR 0 17
109580: PUSH
109581: LD_VAR 0 17
109585: PPUSH
109586: LD_VAR 0 17
109590: PUSH
109591: LD_INT 1
109593: PLUS
109594: PPUSH
109595: LD_VAR 0 4
109599: PPUSH
109600: CALL_OW 1
109604: ST_TO_ADDR
// ComExitBuilding ( i ) ;
109605: LD_VAR 0 4
109609: PPUSH
109610: CALL_OW 122
// end ; if sold_defenders then
109614: LD_VAR 0 17
109618: IFFALSE 109678
// if i in sold_defenders then
109620: LD_VAR 0 4
109624: PUSH
109625: LD_VAR 0 17
109629: IN
109630: IFFALSE 109678
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
109632: LD_VAR 0 4
109636: PPUSH
109637: CALL_OW 314
109641: NOT
109642: PUSH
109643: LD_VAR 0 4
109647: PPUSH
109648: LD_VAR 0 13
109652: PPUSH
109653: CALL_OW 296
109657: PUSH
109658: LD_INT 30
109660: LESS
109661: AND
109662: IFFALSE 109678
// ComAttackUnit ( i , e ) ;
109664: LD_VAR 0 4
109668: PPUSH
109669: LD_VAR 0 13
109673: PPUSH
109674: CALL_OW 115
// end ; end ; end ;
109678: GO 109681
109680: POP
// if IsDead ( i ) then
109681: LD_VAR 0 4
109685: PPUSH
109686: CALL_OW 301
109690: IFFALSE 109708
// defenders := defenders diff i ;
109692: LD_ADDR_VAR 0 2
109696: PUSH
109697: LD_VAR 0 2
109701: PUSH
109702: LD_VAR 0 4
109706: DIFF
109707: ST_TO_ADDR
// end ;
109708: GO 108811
109710: POP
109711: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
109712: LD_VAR 0 21
109716: NOT
109717: PUSH
109718: LD_VAR 0 2
109722: NOT
109723: OR
109724: PUSH
109725: LD_EXP 60
109729: PUSH
109730: LD_VAR 0 1
109734: ARRAY
109735: NOT
109736: OR
109737: IFFALSE 108715
// MC_Reset ( base , 18 ) ;
109739: LD_VAR 0 1
109743: PPUSH
109744: LD_INT 18
109746: PPUSH
109747: CALL 58524 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109751: LD_ADDR_VAR 0 2
109755: PUSH
109756: LD_VAR 0 2
109760: PUSH
109761: LD_VAR 0 2
109765: PPUSH
109766: LD_INT 2
109768: PUSH
109769: LD_INT 25
109771: PUSH
109772: LD_INT 1
109774: PUSH
109775: EMPTY
109776: LIST
109777: LIST
109778: PUSH
109779: LD_INT 25
109781: PUSH
109782: LD_INT 5
109784: PUSH
109785: EMPTY
109786: LIST
109787: LIST
109788: PUSH
109789: LD_INT 25
109791: PUSH
109792: LD_INT 8
109794: PUSH
109795: EMPTY
109796: LIST
109797: LIST
109798: PUSH
109799: LD_INT 25
109801: PUSH
109802: LD_INT 9
109804: PUSH
109805: EMPTY
109806: LIST
109807: LIST
109808: PUSH
109809: EMPTY
109810: LIST
109811: LIST
109812: LIST
109813: LIST
109814: LIST
109815: PPUSH
109816: CALL_OW 72
109820: DIFF
109821: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
109822: LD_VAR 0 21
109826: NOT
109827: PUSH
109828: LD_VAR 0 2
109832: PPUSH
109833: LD_INT 21
109835: PUSH
109836: LD_INT 2
109838: PUSH
109839: EMPTY
109840: LIST
109841: LIST
109842: PPUSH
109843: CALL_OW 72
109847: AND
109848: IFFALSE 110186
// begin tmp := FilterByTag ( defenders , 19 ) ;
109850: LD_ADDR_VAR 0 11
109854: PUSH
109855: LD_VAR 0 2
109859: PPUSH
109860: LD_INT 19
109862: PPUSH
109863: CALL 49070 0 2
109867: ST_TO_ADDR
// if tmp then
109868: LD_VAR 0 11
109872: IFFALSE 109942
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109874: LD_ADDR_VAR 0 11
109878: PUSH
109879: LD_VAR 0 11
109883: PPUSH
109884: LD_INT 25
109886: PUSH
109887: LD_INT 3
109889: PUSH
109890: EMPTY
109891: LIST
109892: LIST
109893: PPUSH
109894: CALL_OW 72
109898: ST_TO_ADDR
// if tmp then
109899: LD_VAR 0 11
109903: IFFALSE 109942
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109905: LD_ADDR_EXP 72
109909: PUSH
109910: LD_EXP 72
109914: PPUSH
109915: LD_VAR 0 1
109919: PPUSH
109920: LD_EXP 72
109924: PUSH
109925: LD_VAR 0 1
109929: ARRAY
109930: PUSH
109931: LD_VAR 0 11
109935: UNION
109936: PPUSH
109937: CALL_OW 1
109941: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109942: LD_VAR 0 1
109946: PPUSH
109947: LD_INT 19
109949: PPUSH
109950: CALL 58524 0 2
// repeat wait ( 0 0$1 ) ;
109954: LD_INT 35
109956: PPUSH
109957: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109961: LD_EXP 60
109965: PUSH
109966: LD_VAR 0 1
109970: ARRAY
109971: NOT
109972: PUSH
109973: LD_EXP 60
109977: PUSH
109978: LD_VAR 0 1
109982: ARRAY
109983: PUSH
109984: EMPTY
109985: EQUAL
109986: OR
109987: IFFALSE 110024
// begin for i in defenders do
109989: LD_ADDR_VAR 0 4
109993: PUSH
109994: LD_VAR 0 2
109998: PUSH
109999: FOR_IN
110000: IFFALSE 110013
// ComStop ( i ) ;
110002: LD_VAR 0 4
110006: PPUSH
110007: CALL_OW 141
110011: GO 109999
110013: POP
110014: POP
// defenders := [ ] ;
110015: LD_ADDR_VAR 0 2
110019: PUSH
110020: EMPTY
110021: ST_TO_ADDR
// exit ;
110022: GO 110250
// end ; for i in defenders do
110024: LD_ADDR_VAR 0 4
110028: PUSH
110029: LD_VAR 0 2
110033: PUSH
110034: FOR_IN
110035: IFFALSE 110124
// begin if not IsInArea ( i , mc_parking [ base ] ) then
110037: LD_VAR 0 4
110041: PPUSH
110042: LD_EXP 84
110046: PUSH
110047: LD_VAR 0 1
110051: ARRAY
110052: PPUSH
110053: CALL_OW 308
110057: NOT
110058: IFFALSE 110082
// ComMoveToArea ( i , mc_parking [ base ] ) else
110060: LD_VAR 0 4
110064: PPUSH
110065: LD_EXP 84
110069: PUSH
110070: LD_VAR 0 1
110074: ARRAY
110075: PPUSH
110076: CALL_OW 113
110080: GO 110122
// if GetControl ( i ) = control_manual then
110082: LD_VAR 0 4
110086: PPUSH
110087: CALL_OW 263
110091: PUSH
110092: LD_INT 1
110094: EQUAL
110095: IFFALSE 110122
// if IsDrivenBy ( i ) then
110097: LD_VAR 0 4
110101: PPUSH
110102: CALL_OW 311
110106: IFFALSE 110122
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
110108: LD_VAR 0 4
110112: PPUSH
110113: CALL_OW 311
110117: PPUSH
110118: CALL_OW 121
// end ;
110122: GO 110034
110124: POP
110125: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
110126: LD_VAR 0 2
110130: PPUSH
110131: LD_INT 95
110133: PUSH
110134: LD_EXP 84
110138: PUSH
110139: LD_VAR 0 1
110143: ARRAY
110144: PUSH
110145: EMPTY
110146: LIST
110147: LIST
110148: PPUSH
110149: CALL_OW 72
110153: PUSH
110154: LD_VAR 0 2
110158: EQUAL
110159: PUSH
110160: LD_EXP 83
110164: PUSH
110165: LD_VAR 0 1
110169: ARRAY
110170: OR
110171: PUSH
110172: LD_EXP 60
110176: PUSH
110177: LD_VAR 0 1
110181: ARRAY
110182: NOT
110183: OR
110184: IFFALSE 109954
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
110186: LD_ADDR_EXP 82
110190: PUSH
110191: LD_EXP 82
110195: PPUSH
110196: LD_VAR 0 1
110200: PPUSH
110201: LD_VAR 0 2
110205: PPUSH
110206: LD_INT 21
110208: PUSH
110209: LD_INT 2
110211: PUSH
110212: EMPTY
110213: LIST
110214: LIST
110215: PPUSH
110216: CALL_OW 72
110220: PPUSH
110221: CALL_OW 1
110225: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
110226: LD_VAR 0 1
110230: PPUSH
110231: LD_INT 19
110233: PPUSH
110234: CALL 58524 0 2
// MC_Reset ( base , 20 ) ;
110238: LD_VAR 0 1
110242: PPUSH
110243: LD_INT 20
110245: PPUSH
110246: CALL 58524 0 2
// end ; end_of_file
110250: LD_VAR 0 3
110254: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
110255: LD_VAR 0 1
110259: PUSH
110260: LD_INT 200
110262: DOUBLE
110263: GREATEREQUAL
110264: IFFALSE 110272
110266: LD_INT 299
110268: DOUBLE
110269: LESSEQUAL
110270: IFTRUE 110274
110272: GO 110306
110274: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
110275: LD_VAR 0 1
110279: PPUSH
110280: LD_VAR 0 2
110284: PPUSH
110285: LD_VAR 0 3
110289: PPUSH
110290: LD_VAR 0 4
110294: PPUSH
110295: LD_VAR 0 5
110299: PPUSH
110300: CALL 99071 0 5
110304: GO 110383
110306: LD_INT 300
110308: DOUBLE
110309: GREATEREQUAL
110310: IFFALSE 110318
110312: LD_INT 399
110314: DOUBLE
110315: LESSEQUAL
110316: IFTRUE 110320
110318: GO 110382
110320: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
110321: LD_VAR 0 1
110325: PPUSH
110326: LD_VAR 0 2
110330: PPUSH
110331: LD_VAR 0 3
110335: PPUSH
110336: LD_VAR 0 4
110340: PPUSH
110341: LD_VAR 0 5
110345: PPUSH
110346: LD_VAR 0 6
110350: PPUSH
110351: LD_VAR 0 7
110355: PPUSH
110356: LD_VAR 0 8
110360: PPUSH
110361: LD_VAR 0 9
110365: PPUSH
110366: LD_VAR 0 10
110370: PPUSH
110371: LD_VAR 0 11
110375: PPUSH
110376: CALL 96969 0 11
110380: GO 110383
110382: POP
// end ;
110383: PPOPN 11
110385: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
110386: LD_VAR 0 1
110390: PPUSH
110391: LD_VAR 0 2
110395: PPUSH
110396: LD_VAR 0 3
110400: PPUSH
110401: LD_VAR 0 4
110405: PPUSH
110406: LD_VAR 0 5
110410: PPUSH
110411: CALL 99063 0 5
// end ; end_of_file
110415: PPOPN 5
110417: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
110418: LD_VAR 0 1
110422: PPUSH
110423: LD_VAR 0 2
110427: PPUSH
110428: LD_VAR 0 3
110432: PPUSH
110433: LD_VAR 0 4
110437: PPUSH
110438: LD_VAR 0 5
110442: PPUSH
110443: LD_VAR 0 6
110447: PPUSH
110448: CALL 85164 0 6
// end ;
110452: PPOPN 6
110454: END
