// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 85532 0 0
// InitMacro ;
  23: CALL 54906 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48178 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48178 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48178 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48178 0 9
// PrepareArabian ;
 172: CALL 3964 0 0
// PrepareRussian ;
 176: CALL 2935 0 0
// PrepareAlliance ;
 180: CALL 900 0 0
// MC_Start ( ) ;
 184: CALL 57071 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7326 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 84
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 85
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 78760 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 55
 281: PPUSH
 282: CALL 79186 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 79644 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 79913 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 110
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 79126 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 79820 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 52
 390: PPUSH
 391: CALL 79186 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 79644 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 79913 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 78970 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 80231 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 79126 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 53
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 11
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// masha_killed := false ;
 779: LD_ADDR_EXP 10
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// abdul_escaped := true ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 1
 794: ST_TO_ADDR
// loss_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// hack_counter := 0 ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_INT 0
 810: ST_TO_ADDR
// end ;
 811: LD_VAR 0 1
 815: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 816: LD_EXP 49
 820: PPUSH
 821: CALL_OW 255
 825: PUSH
 826: LD_INT 7
 828: EQUAL
 829: PUSH
 830: LD_EXP 48
 834: PPUSH
 835: CALL_OW 255
 839: PUSH
 840: LD_INT 7
 842: EQUAL
 843: AND
 844: PUSH
 845: LD_EXP 49
 849: PPUSH
 850: CALL_OW 302
 854: AND
 855: PUSH
 856: LD_EXP 48
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: IFFALSE 878
 868: GO 870
 870: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 871: LD_STRING ACH_COMRADE
 873: PPUSH
 874: CALL_OW 543
 878: END
// every 0 0$1 trigger hack_counter >= 10 do
 879: LD_EXP 15
 883: PUSH
 884: LD_INT 10
 886: GREATEREQUAL
 887: IFFALSE 899
 889: GO 891
 891: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 892: LD_STRING ACH_HACK
 894: PPUSH
 895: CALL_OW 543
 899: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 900: LD_INT 0
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
// uc_side := 7 ;
 906: LD_ADDR_OWVAR 20
 910: PUSH
 911: LD_INT 7
 913: ST_TO_ADDR
// uc_nation := 1 ;
 914: LD_ADDR_OWVAR 21
 918: PUSH
 919: LD_INT 1
 921: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 922: LD_ADDR_EXP 16
 926: PUSH
 927: LD_STRING JMM
 929: PPUSH
 930: LD_EXP 1
 934: NOT
 935: PPUSH
 936: LD_STRING 12a_
 938: PPUSH
 939: CALL 14815 0 3
 943: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 944: LD_EXP 16
 948: PPUSH
 949: LD_INT 71
 951: PPUSH
 952: LD_INT 23
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 962: LD_EXP 16
 966: PPUSH
 967: LD_INT 2
 969: PPUSH
 970: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 974: LD_ADDR_EXP 17
 978: PUSH
 979: LD_STRING Roth
 981: PPUSH
 982: LD_EXP 1
 986: NOT
 987: PPUSH
 988: LD_STRING 12a_
 990: PPUSH
 991: CALL 14815 0 3
 995: ST_TO_ADDR
// if Roth then
 996: LD_EXP 17
1000: IFFALSE 1020
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1002: LD_EXP 17
1006: PPUSH
1007: LD_INT 71
1009: PPUSH
1010: LD_INT 21
1012: PPUSH
1013: LD_INT 0
1015: PPUSH
1016: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1020: LD_ADDR_EXP 18
1024: PUSH
1025: LD_STRING Lisa
1027: PPUSH
1028: LD_EXP 1
1032: NOT
1033: PPUSH
1034: LD_STRING 12a_
1036: PPUSH
1037: CALL 14815 0 3
1041: ST_TO_ADDR
// if Lisa then
1042: LD_EXP 18
1046: IFFALSE 1063
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1048: LD_EXP 18
1052: PPUSH
1053: LD_INT 13
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1063: LD_ADDR_EXP 19
1067: PUSH
1068: LD_STRING Donaldson
1070: PPUSH
1071: LD_EXP 1
1075: NOT
1076: PPUSH
1077: LD_STRING 12a_
1079: PPUSH
1080: CALL 14815 0 3
1084: ST_TO_ADDR
// if Donaldson then
1085: LD_EXP 19
1089: IFFALSE 1106
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1091: LD_EXP 19
1095: PPUSH
1096: LD_INT 13
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1106: LD_ADDR_EXP 20
1110: PUSH
1111: LD_STRING Bobby
1113: PPUSH
1114: LD_EXP 1
1118: NOT
1119: PPUSH
1120: LD_STRING 12a_
1122: PPUSH
1123: CALL 14815 0 3
1127: ST_TO_ADDR
// if Bobby then
1128: LD_EXP 20
1132: IFFALSE 1149
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1134: LD_EXP 20
1138: PPUSH
1139: LD_INT 13
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1149: LD_ADDR_EXP 21
1153: PUSH
1154: LD_STRING Cyrus
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_STRING 12a_
1165: PPUSH
1166: CALL 14815 0 3
1170: ST_TO_ADDR
// if Cyrus then
1171: LD_EXP 21
1175: IFFALSE 1192
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1177: LD_EXP 21
1181: PPUSH
1182: LD_INT 13
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1192: LD_ADDR_EXP 22
1196: PUSH
1197: LD_STRING Denis
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: LD_STRING 12a_
1208: PPUSH
1209: CALL 14815 0 3
1213: ST_TO_ADDR
// if Denis then
1214: LD_EXP 22
1218: IFFALSE 1235
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1220: LD_EXP 22
1224: PPUSH
1225: LD_INT 13
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1235: LD_ADDR_EXP 23
1239: PUSH
1240: LD_STRING Brown
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: LD_STRING 12a_
1251: PPUSH
1252: CALL 14815 0 3
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 23
1261: IFFALSE 1278
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1263: LD_EXP 23
1267: PPUSH
1268: LD_INT 13
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1278: LD_ADDR_EXP 24
1282: PUSH
1283: LD_STRING Gladstone
1285: PPUSH
1286: LD_EXP 1
1290: NOT
1291: PPUSH
1292: LD_STRING 12a_
1294: PPUSH
1295: CALL 14815 0 3
1299: ST_TO_ADDR
// if Gladstone then
1300: LD_EXP 24
1304: IFFALSE 1321
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1306: LD_EXP 24
1310: PPUSH
1311: LD_INT 13
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1321: LD_ADDR_EXP 25
1325: PUSH
1326: LD_STRING Houten
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_STRING 12a_
1337: PPUSH
1338: CALL 14815 0 3
1342: ST_TO_ADDR
// if Houten then
1343: LD_EXP 25
1347: IFFALSE 1364
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1349: LD_EXP 25
1353: PPUSH
1354: LD_INT 13
1356: PPUSH
1357: LD_INT 0
1359: PPUSH
1360: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1364: LD_ADDR_EXP 26
1368: PUSH
1369: LD_STRING Cornell
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: LD_STRING 12a_
1380: PPUSH
1381: CALL 14815 0 3
1385: ST_TO_ADDR
// if Cornel then
1386: LD_EXP 26
1390: IFFALSE 1407
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1392: LD_EXP 26
1396: PPUSH
1397: LD_INT 13
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1407: LD_ADDR_EXP 27
1411: PUSH
1412: LD_STRING Gary
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: LD_STRING 12a_
1423: PPUSH
1424: CALL 14815 0 3
1428: ST_TO_ADDR
// if Gary then
1429: LD_EXP 27
1433: IFFALSE 1450
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1435: LD_EXP 27
1439: PPUSH
1440: LD_INT 13
1442: PPUSH
1443: LD_INT 0
1445: PPUSH
1446: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1450: LD_ADDR_EXP 28
1454: PUSH
1455: LD_STRING Frank
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: LD_STRING 12a_
1466: PPUSH
1467: CALL 14815 0 3
1471: ST_TO_ADDR
// if Frank then
1472: LD_EXP 28
1476: IFFALSE 1493
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1478: LD_EXP 28
1482: PPUSH
1483: LD_INT 13
1485: PPUSH
1486: LD_INT 0
1488: PPUSH
1489: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1493: LD_ADDR_EXP 29
1497: PUSH
1498: LD_STRING Kikuchi
1500: PPUSH
1501: LD_EXP 1
1505: NOT
1506: PPUSH
1507: LD_STRING 12a_
1509: PPUSH
1510: CALL 14815 0 3
1514: ST_TO_ADDR
// if Kikuchi then
1515: LD_EXP 29
1519: IFFALSE 1536
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1521: LD_EXP 29
1525: PPUSH
1526: LD_INT 13
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1536: LD_ADDR_EXP 30
1540: PUSH
1541: LD_STRING Simms
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 12a_
1552: PPUSH
1553: CALL 14815 0 3
1557: ST_TO_ADDR
// if Simms then
1558: LD_EXP 30
1562: IFFALSE 1579
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1564: LD_EXP 30
1568: PPUSH
1569: LD_INT 13
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1579: LD_ADDR_EXP 31
1583: PUSH
1584: LD_STRING Joan
1586: PPUSH
1587: LD_EXP 1
1591: NOT
1592: PPUSH
1593: LD_STRING 12a_
1595: PPUSH
1596: CALL 14815 0 3
1600: ST_TO_ADDR
// if Joan then
1601: LD_EXP 31
1605: IFFALSE 1622
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1607: LD_EXP 31
1611: PPUSH
1612: LD_INT 13
1614: PPUSH
1615: LD_INT 0
1617: PPUSH
1618: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING DeltaDoctor
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 12a_
1638: PPUSH
1639: CALL 14815 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 32
1648: IFFALSE 1665
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1650: LD_EXP 32
1654: PPUSH
1655: LD_INT 13
1657: PPUSH
1658: LD_INT 0
1660: PPUSH
1661: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_STRING 12a_others
1672: PPUSH
1673: CALL_OW 31
1677: ST_TO_ADDR
// if tmp then
1678: LD_VAR 0 4
1682: IFFALSE 1716
// for i in tmp do
1684: LD_ADDR_VAR 0 3
1688: PUSH
1689: LD_VAR 0 4
1693: PUSH
1694: FOR_IN
1695: IFFALSE 1714
// PlaceUnitArea ( i , alliance_start , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 13
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
1712: GO 1694
1714: POP
1715: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 3
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 19679 0 5
// veh := CreateVehicle ;
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: CALL_OW 45
1744: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1745: LD_VAR 0 2
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1757: LD_VAR 0 2
1761: PPUSH
1762: LD_INT 60
1764: PPUSH
1765: LD_INT 6
1767: PPUSH
1768: LD_INT 0
1770: PPUSH
1771: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1775: LD_VAR 0 2
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 30
1785: PPUSH
1786: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1790: LD_STRING 11_artifact_captured
1792: PPUSH
1793: LD_INT 0
1795: PPUSH
1796: CALL_OW 30
1800: IFFALSE 1876
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 3
1807: PPUSH
1808: LD_INT 3
1810: PPUSH
1811: LD_INT 12
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 19679 0 5
// veh := CreateVehicle ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: CALL_OW 45
1830: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1831: LD_VAR 0 2
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 75
1850: PPUSH
1851: LD_INT 6
1853: PPUSH
1854: LD_INT 0
1856: PPUSH
1857: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1861: LD_VAR 0 2
1865: PPUSH
1866: LD_INT 4
1868: PPUSH
1869: LD_INT 50
1871: PPUSH
1872: CALL_OW 290
// end ; end ;
1876: LD_VAR 0 1
1880: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1881: LD_INT 0
1883: PPUSH
1884: PPUSH
1885: PPUSH
1886: PPUSH
// uc_side := 6 ;
1887: LD_ADDR_OWVAR 20
1891: PUSH
1892: LD_INT 6
1894: ST_TO_ADDR
// uc_nation := 3 ;
1895: LD_ADDR_OWVAR 21
1899: PUSH
1900: LD_INT 3
1902: ST_TO_ADDR
// InitHc ;
1903: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1907: LD_ADDR_EXP 33
1911: PUSH
1912: LD_STRING Gossudarov
1914: PPUSH
1915: CALL_OW 25
1919: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1920: LD_ADDR_EXP 34
1924: PUSH
1925: LD_STRING Kirilenkova
1927: PPUSH
1928: CALL_OW 25
1932: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1933: LD_ADDR_EXP 35
1937: PUSH
1938: LD_STRING Titov
1940: PPUSH
1941: CALL_OW 25
1945: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1946: LD_ADDR_EXP 40
1950: PUSH
1951: LD_STRING Oblukov
1953: PPUSH
1954: CALL_OW 25
1958: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1959: LD_ADDR_EXP 37
1963: PUSH
1964: LD_STRING Dolgov
1966: PPUSH
1967: CALL_OW 25
1971: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1972: LD_ADDR_EXP 38
1976: PUSH
1977: LD_STRING Petrosyan
1979: PPUSH
1980: CALL_OW 25
1984: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1985: LD_ADDR_EXP 39
1989: PUSH
1990: LD_STRING Scholtze
1992: PPUSH
1993: CALL_OW 25
1997: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1998: LD_ADDR_EXP 41
2002: PUSH
2003: LD_STRING Kapitsova
2005: PPUSH
2006: CALL_OW 25
2010: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2011: LD_ADDR_VAR 0 2
2015: PUSH
2016: LD_EXP 33
2020: PUSH
2021: LD_EXP 34
2025: PUSH
2026: LD_EXP 35
2030: PUSH
2031: LD_EXP 40
2035: PUSH
2036: LD_EXP 37
2040: PUSH
2041: LD_EXP 38
2045: PUSH
2046: LD_EXP 39
2050: PUSH
2051: LD_EXP 41
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2066: LD_INT 1
2068: PPUSH
2069: LD_INT 4
2071: PPUSH
2072: LD_INT 8
2074: PPUSH
2075: CALL_OW 380
// un := CreateHuman ;
2079: LD_ADDR_VAR 0 4
2083: PUSH
2084: CALL_OW 44
2088: ST_TO_ADDR
// tmp := tmp ^ un ;
2089: LD_ADDR_VAR 0 2
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: LD_VAR 0 4
2103: ADD
2104: ST_TO_ADDR
// for i in tmp do
2105: LD_ADDR_VAR 0 3
2109: PUSH
2110: LD_VAR 0 2
2114: PUSH
2115: FOR_IN
2116: IFFALSE 2135
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2118: LD_VAR 0 3
2122: PPUSH
2123: LD_INT 14
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: CALL_OW 49
2133: GO 2115
2135: POP
2136: POP
// if freedom then
2137: LD_EXP 3
2141: IFFALSE 2174
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2143: LD_VAR 0 2
2147: PPUSH
2148: LD_EXP 3
2152: PPUSH
2153: CALL_OW 250
2157: PPUSH
2158: LD_EXP 3
2162: PPUSH
2163: CALL_OW 251
2167: PPUSH
2168: CALL_OW 111
2172: GO 2189
// ComMoveXY ( tmp , 70 , 48 ) ;
2174: LD_VAR 0 2
2178: PPUSH
2179: LD_INT 70
2181: PPUSH
2182: LD_INT 48
2184: PPUSH
2185: CALL_OW 111
// end ;
2189: LD_VAR 0 1
2193: RET
// export function PrepareBelkov ; begin
2194: LD_INT 0
2196: PPUSH
// uc_side := 4 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 4
2204: ST_TO_ADDR
// uc_nation := 3 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 3
2212: ST_TO_ADDR
// InitHc ;
2213: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2217: LD_ADDR_EXP 48
2221: PUSH
2222: LD_STRING Belkov
2224: PPUSH
2225: CALL_OW 25
2229: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2230: LD_EXP 48
2234: PPUSH
2235: LD_INT 14
2237: PPUSH
2238: LD_INT 0
2240: PPUSH
2241: CALL_OW 49
// end ;
2245: LD_VAR 0 1
2249: RET
// export function PrepareGnyevko ; begin
2250: LD_INT 0
2252: PPUSH
// uc_side := 4 ;
2253: LD_ADDR_OWVAR 20
2257: PUSH
2258: LD_INT 4
2260: ST_TO_ADDR
// uc_nation := 3 ;
2261: LD_ADDR_OWVAR 21
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// InitHc ;
2269: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2273: LD_ADDR_EXP 49
2277: PUSH
2278: LD_STRING Gnyevko
2280: PPUSH
2281: CALL_OW 25
2285: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2286: LD_EXP 49
2290: PPUSH
2291: LD_INT 14
2293: PPUSH
2294: LD_INT 0
2296: PPUSH
2297: CALL_OW 49
// end ;
2301: LD_VAR 0 1
2305: RET
// export function PrepareBurlak ; var i , tmp ; begin
2306: LD_INT 0
2308: PPUSH
2309: PPUSH
2310: PPUSH
// uc_side := 4 ;
2311: LD_ADDR_OWVAR 20
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// uc_nation := 3 ;
2319: LD_ADDR_OWVAR 21
2323: PUSH
2324: LD_INT 3
2326: ST_TO_ADDR
// InitHc ;
2327: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2331: LD_ADDR_EXP 47
2335: PUSH
2336: LD_STRING Burlak
2338: PPUSH
2339: CALL_OW 25
2343: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2344: LD_INT 24
2346: PUSH
2347: LD_INT 23
2349: PUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 22
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PUSH
2362: LD_OWVAR 67
2366: ARRAY
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: LD_INT 1
2373: PPUSH
2374: LD_INT 45
2376: PUSH
2377: LD_INT 44
2379: PUSH
2380: LD_INT 43
2382: PUSH
2383: LD_INT 42
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_OWVAR 67
2396: ARRAY
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL 19679 0 5
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 50
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2415: LD_EXP 50
2419: PUSH
2420: LD_EXP 47
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PPUSH
2429: LD_INT 499
2431: PPUSH
2432: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2436: LD_EXP 50
2440: PPUSH
2441: LD_INT 3
2443: PPUSH
2444: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2448: LD_EXP 50
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 18
2465: PPUSH
2466: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2470: LD_INT 35
2472: PPUSH
2473: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2477: LD_ADDR_VAR 0 3
2481: PUSH
2482: LD_INT 18
2484: PPUSH
2485: EMPTY
2486: PPUSH
2487: CALL_OW 70
2491: ST_TO_ADDR
// if tmp then
2492: LD_VAR 0 3
2496: IFFALSE 2530
// for i in tmp do
2498: LD_ADDR_VAR 0 2
2502: PUSH
2503: LD_VAR 0 3
2507: PUSH
2508: FOR_IN
2509: IFFALSE 2528
// ComMoveXY ( i , 114 , 9 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 114
2518: PPUSH
2519: LD_INT 9
2521: PPUSH
2522: CALL_OW 111
2526: GO 2508
2528: POP
2529: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2530: LD_INT 18
2532: PPUSH
2533: EMPTY
2534: PPUSH
2535: CALL_OW 70
2539: NOT
2540: PUSH
2541: LD_INT 123
2543: PPUSH
2544: LD_INT 3
2546: PPUSH
2547: CALL_OW 428
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: AND
2556: IFFALSE 2470
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2558: LD_EXP 50
2562: PPUSH
2563: LD_INT 123
2565: PPUSH
2566: LD_INT 3
2568: PPUSH
2569: LD_INT 0
2571: PPUSH
2572: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2576: LD_EXP 47
2580: PPUSH
2581: LD_INT 125
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: LD_INT 0
2589: PPUSH
2590: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2594: LD_EXP 47
2598: PPUSH
2599: LD_EXP 50
2603: PPUSH
2604: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2608: LD_INT 10
2610: PPUSH
2611: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2615: LD_EXP 50
2619: PPUSH
2620: LD_INT 110
2622: PPUSH
2623: LD_INT 10
2625: PPUSH
2626: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2630: LD_ADDR_EXP 43
2634: PUSH
2635: LD_STRING Petrovova
2637: PPUSH
2638: CALL_OW 25
2642: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2643: LD_ADDR_EXP 45
2647: PUSH
2648: LD_STRING Kuzmov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2656: LD_ADDR_EXP 44
2660: PUSH
2661: LD_STRING Kovalyuk
2663: PPUSH
2664: CALL_OW 25
2668: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2669: LD_ADDR_EXP 42
2673: PUSH
2674: LD_STRING Lipshchin
2676: PPUSH
2677: CALL_OW 25
2681: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2682: LD_ADDR_EXP 46
2686: PUSH
2687: LD_STRING Karamazov
2689: PPUSH
2690: CALL_OW 25
2694: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2695: LD_ADDR_VAR 0 3
2699: PUSH
2700: LD_EXP 43
2704: PUSH
2705: LD_EXP 45
2709: PUSH
2710: LD_EXP 44
2714: PUSH
2715: LD_EXP 42
2719: PUSH
2720: LD_EXP 46
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: ST_TO_ADDR
// for i in tmp do
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 3
2741: PUSH
2742: FOR_IN
2743: IFFALSE 2782
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2745: LD_VAR 0 2
2749: PPUSH
2750: LD_INT 399
2752: PPUSH
2753: LD_INT 799
2755: PPUSH
2756: CALL_OW 12
2760: PPUSH
2761: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2765: LD_VAR 0 2
2769: PPUSH
2770: LD_INT 19
2772: PPUSH
2773: LD_INT 0
2775: PPUSH
2776: CALL_OW 49
// end ;
2780: GO 2742
2782: POP
2783: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 112
2791: PPUSH
2792: LD_INT 5
2794: PPUSH
2795: CALL_OW 111
// AddComHold ( tmp ) ;
2799: LD_VAR 0 3
2803: PPUSH
2804: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2808: LD_ADDR_VAR 0 2
2812: PUSH
2813: LD_VAR 0 3
2817: PPUSH
2818: LD_INT 25
2820: PUSH
2821: LD_INT 1
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PPUSH
2828: CALL_OW 72
2832: PUSH
2833: FOR_IN
2834: IFFALSE 2874
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2836: LD_VAR 0 2
2840: PPUSH
2841: LD_INT 20
2843: PPUSH
2844: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2848: LD_VAR 0 2
2852: PPUSH
2853: LD_INT 147
2855: PPUSH
2856: LD_INT 45
2858: PPUSH
2859: CALL_OW 178
// AddComCrawl ( i ) ;
2863: LD_VAR 0 2
2867: PPUSH
2868: CALL_OW 197
// end ;
2872: GO 2833
2874: POP
2875: POP
// repeat wait ( 0 0$1 ) ;
2876: LD_INT 35
2878: PPUSH
2879: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2883: LD_EXP 50
2887: PPUSH
2888: LD_INT 110
2890: PPUSH
2891: LD_INT 10
2893: PPUSH
2894: CALL_OW 307
2898: PUSH
2899: LD_EXP 50
2903: PPUSH
2904: CALL_OW 305
2908: NOT
2909: OR
2910: IFFALSE 2876
// ComStop ( Burlak ) ;
2912: LD_EXP 47
2916: PPUSH
2917: CALL_OW 141
// AddComHold ( Burlak ) ;
2921: LD_EXP 47
2925: PPUSH
2926: CALL_OW 200
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
// uc_side := 3 ;
2942: LD_ADDR_OWVAR 20
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// uc_nation := 3 ;
2950: LD_ADDR_OWVAR 21
2954: PUSH
2955: LD_INT 3
2957: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2958: LD_ADDR_EXP 51
2962: PUSH
2963: LD_INT 47
2965: PPUSH
2966: LD_INT 4
2968: PPUSH
2969: LD_STRING 
2971: PPUSH
2972: LD_INT 7
2974: PUSH
2975: LD_INT 8
2977: PUSH
2978: LD_INT 9
2980: PUSH
2981: LD_INT 10
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PPUSH
2996: LD_INT 10000
2998: PUSH
2999: LD_INT 3000
3001: PUSH
3002: LD_INT 300
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: PPUSH
3010: LD_INT 9
3012: PUSH
3013: LD_INT 5
3015: PUSH
3016: LD_INT 6
3018: PUSH
3019: LD_INT 6
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 23125 0 6
3032: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3033: LD_ADDR_EXP 60
3037: PUSH
3038: LD_EXP 60
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_EXP 51
3050: PPUSH
3051: CALL_OW 1
3055: ST_TO_ADDR
// tmp := [ ] ;
3056: LD_ADDR_VAR 0 4
3060: PUSH
3061: EMPTY
3062: ST_TO_ADDR
// for i = 1 to 4 do
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: DOUBLE
3069: LD_INT 1
3071: DEC
3072: ST_TO_ADDR
3073: LD_INT 4
3075: PUSH
3076: FOR_TO
3077: IFFALSE 3170
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3079: LD_INT 22
3081: PPUSH
3082: LD_INT 3
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 43
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: LD_INT 45
3096: PUSH
3097: LD_INT 44
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: PUSH
3106: LD_VAR 0 2
3110: PUSH
3111: LD_INT 4
3113: MOD
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: ARRAY
3119: PPUSH
3120: LD_INT 100
3122: PPUSH
3123: CALL 19679 0 5
// veh := CreateVehicle ;
3127: LD_ADDR_VAR 0 3
3131: PUSH
3132: CALL_OW 45
3136: ST_TO_ADDR
// tmp := tmp ^ veh ;
3137: LD_ADDR_VAR 0 4
3141: PUSH
3142: LD_VAR 0 4
3146: PUSH
3147: LD_VAR 0 3
3151: ADD
3152: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_INT 2
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3076
3170: POP
3171: POP
// russian_guard := tmp ;
3172: LD_ADDR_EXP 52
3176: PUSH
3177: LD_VAR 0 4
3181: ST_TO_ADDR
// if Difficulty >= 3 then
3182: LD_OWVAR 67
3186: PUSH
3187: LD_INT 3
3189: GREATEREQUAL
3190: IFFALSE 3254
// begin bc_type := b_breastwork ;
3192: LD_ADDR_OWVAR 42
3196: PUSH
3197: LD_INT 31
3199: ST_TO_ADDR
// bc_level := 10 ;
3200: LD_ADDR_OWVAR 43
3204: PUSH
3205: LD_INT 10
3207: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3208: LD_ADDR_VAR 0 5
3212: PUSH
3213: LD_INT 96
3215: PPUSH
3216: LD_INT 105
3218: PPUSH
3219: LD_INT 3
3221: PPUSH
3222: CALL_OW 47
3226: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3227: LD_INT 0
3229: PPUSH
3230: LD_INT 9
3232: PPUSH
3233: LD_INT 10
3235: PPUSH
3236: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3240: CALL_OW 44
3244: PPUSH
3245: LD_VAR 0 5
3249: PPUSH
3250: CALL_OW 52
// end ; end ;
3254: LD_VAR 0 1
3258: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3259: LD_INT 47
3261: PPUSH
3262: CALL_OW 302
3266: PUSH
3267: LD_EXP 6
3271: AND
3272: IFFALSE 3961
3274: GO 3276
3276: DISABLE
3277: LD_INT 0
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
// begin enable ;
3286: ENABLE
// base := 2 ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 2
3294: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3295: LD_ADDR_VAR 0 4
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: LD_INT 1
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 22
3349: PUSH
3350: LD_INT 1
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 45
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 21
3367: PUSH
3368: LD_INT 1
3370: PUSH
3371: LD_INT 3
3373: PUSH
3374: LD_INT 45
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 1
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: LD_INT 45
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 23
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 46
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: ST_TO_ADDR
// amount := Difficulty ;
3425: LD_ADDR_VAR 0 7
3429: PUSH
3430: LD_OWVAR 67
3434: ST_TO_ADDR
// if tick > 30 30$00 then
3435: LD_OWVAR 1
3439: PUSH
3440: LD_INT 63000
3442: GREATER
3443: IFFALSE 3480
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 7
3449: PUSH
3450: LD_VAR 0 7
3454: PUSH
3455: LD_INT 2
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: LD_INT 4
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_OWVAR 67
3477: ARRAY
3478: PLUS
3479: ST_TO_ADDR
// for i = 1 to amount do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 7
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3584
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_VAR 0 3
3507: PPUSH
3508: LD_VAR 0 3
3512: PUSH
3513: LD_INT 1
3515: PLUS
3516: PPUSH
3517: LD_INT 23
3519: PUSH
3520: LD_INT 24
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 2
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: LD_INT 3
3544: PUSH
3545: LD_INT 46
3547: PUSH
3548: LD_INT 47
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: CALL_OW 12
3569: ARRAY
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PPUSH
3577: CALL_OW 2
3581: ST_TO_ADDR
3582: GO 3495
3584: POP
3585: POP
// MC_InsertProduceList ( base , tmp ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_VAR 0 3
3595: PPUSH
3596: CALL 79126 0 2
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 1
3614: PPUSH
3615: CALL 80544 0 2
3619: PUSH
3620: LD_VAR 0 7
3624: GREATEREQUAL
3625: IFFALSE 3600
// wait ( 0 0$30 ) ;
3627: LD_INT 1050
3629: PPUSH
3630: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3634: LD_ADDR_VAR 0 5
3638: PUSH
3639: LD_INT 71
3641: PUSH
3642: LD_INT 19
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 91
3651: PUSH
3652: LD_INT 67
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 52
3661: PUSH
3662: LD_INT 44
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 48
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3685: LD_ADDR_VAR 0 6
3689: PUSH
3690: LD_EXP 79
3694: PUSH
3695: LD_VAR 0 2
3699: ARRAY
3700: PUSH
3701: LD_EXP 79
3705: PUSH
3706: LD_VAR 0 2
3710: ARRAY
3711: PPUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 34
3717: PUSH
3718: LD_INT 51
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 34
3727: PUSH
3728: LD_INT 52
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PPUSH
3740: CALL_OW 72
3744: DIFF
3745: ST_TO_ADDR
// if not attackers then
3746: LD_VAR 0 6
3750: NOT
3751: IFFALSE 3755
// exit ;
3753: GO 3961
// ru_attackers := attackers ;
3755: LD_ADDR_EXP 53
3759: PUSH
3760: LD_VAR 0 6
3764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3765: LD_ADDR_EXP 79
3769: PUSH
3770: LD_EXP 79
3774: PPUSH
3775: LD_VAR 0 2
3779: PPUSH
3780: LD_EXP 79
3784: PUSH
3785: LD_VAR 0 2
3789: ARRAY
3790: PUSH
3791: LD_VAR 0 6
3795: DIFF
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// for i = 1 to attackers do
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: DOUBLE
3808: LD_INT 1
3810: DEC
3811: ST_TO_ADDR
3812: LD_VAR 0 6
3816: PUSH
3817: FOR_TO
3818: IFFALSE 3895
// begin case i mod 3 of 0 :
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 3
3827: MOD
3828: PUSH
3829: LD_INT 0
3831: DOUBLE
3832: EQUAL
3833: IFTRUE 3837
3835: GO 3840
3837: POP
// ; 1 :
3838: GO 3893
3840: LD_INT 1
3842: DOUBLE
3843: EQUAL
3844: IFTRUE 3848
3846: GO 3866
3848: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3849: LD_VAR 0 1
3853: PPUSH
3854: LD_INT 32
3856: PPUSH
3857: LD_INT 49
3859: PPUSH
3860: CALL_OW 114
3864: GO 3893
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3892
3874: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3875: LD_VAR 0 1
3879: PPUSH
3880: LD_INT 117
3882: PPUSH
3883: LD_INT 107
3885: PPUSH
3886: CALL_OW 114
3890: GO 3893
3892: POP
// end ;
3893: GO 3817
3895: POP
3896: POP
// repeat wait ( 0 0$1 ) ;
3897: LD_INT 35
3899: PPUSH
3900: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3904: LD_VAR 0 6
3908: PPUSH
3909: LD_INT 60
3911: PUSH
3912: EMPTY
3913: LIST
3914: PPUSH
3915: CALL_OW 72
3919: NOT
3920: IFFALSE 3897
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3922: LD_VAR 0 2
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: LD_VAR 0 5
3936: PPUSH
3937: LD_VAR 0 4
3941: PPUSH
3942: CALL 79311 0 4
// if not first_attack then
3946: LD_EXP 7
3950: NOT
3951: IFFALSE 3961
// first_attack := true ;
3953: LD_ADDR_EXP 7
3957: PUSH
3958: LD_INT 1
3960: ST_TO_ADDR
// end ; end_of_file
3961: PPOPN 7
3963: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 2 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// uc_nation := 2 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 2
3988: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3989: LD_ADDR_EXP 56
3993: PUSH
3994: LD_STRING Abdul
3996: PPUSH
3997: CALL_OW 25
4001: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4002: LD_EXP 56
4006: PPUSH
4007: LD_INT 11
4009: PPUSH
4010: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4014: LD_EXP 56
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 52
// vc_chassis := 31 ;
4026: LD_ADDR_OWVAR 37
4030: PUSH
4031: LD_INT 31
4033: ST_TO_ADDR
// vc_control := control_rider ;
4034: LD_ADDR_OWVAR 38
4038: PUSH
4039: LD_INT 4
4041: ST_TO_ADDR
// mastodont := CreateVehicle ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: CALL_OW 45
4051: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4052: LD_EXP 57
4056: PPUSH
4057: LD_INT 153
4059: PPUSH
4060: LD_INT 71
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 48
// InitVc ;
4070: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4074: LD_ADDR_EXP 54
4078: PUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_STRING 
4087: PPUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: LD_INT 9
4096: PUSH
4097: LD_INT 10
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: LD_OWVAR 67
4110: ARRAY
4111: PPUSH
4112: LD_INT 5000
4114: PUSH
4115: LD_INT 1000
4117: PUSH
4118: LD_INT 300
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PPUSH
4126: LD_INT 18
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: LD_INT 6
4134: PUSH
4135: LD_INT 9
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL 23125 0 6
4148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4149: LD_ADDR_EXP 60
4153: PUSH
4154: LD_EXP 60
4158: PPUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_EXP 54
4166: PPUSH
4167: CALL_OW 1
4171: ST_TO_ADDR
// tmp := [ ] ;
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4179: LD_ADDR_OWVAR 37
4183: PUSH
4184: LD_INT 14
4186: ST_TO_ADDR
// vc_engine := engine_siberite ;
4187: LD_ADDR_OWVAR 39
4191: PUSH
4192: LD_INT 3
4194: ST_TO_ADDR
// vc_control := control_manual ;
4195: LD_ADDR_OWVAR 38
4199: PUSH
4200: LD_INT 1
4202: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4203: LD_ADDR_OWVAR 40
4207: PUSH
4208: LD_INT 31
4210: ST_TO_ADDR
// for i = 1 to 3 do
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: DOUBLE
4217: LD_INT 1
4219: DEC
4220: ST_TO_ADDR
4221: LD_INT 3
4223: PUSH
4224: FOR_TO
4225: IFFALSE 4473
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4227: LD_ADDR_VAR 0 5
4231: PUSH
4232: LD_INT 153
4234: PUSH
4235: LD_INT 71
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 155
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_VAR 0 2
4260: PUSH
4261: LD_INT 2
4263: MOD
4264: PUSH
4265: LD_INT 1
4267: PLUS
4268: ARRAY
4269: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4270: LD_INT 0
4272: PPUSH
4273: LD_INT 3
4275: PPUSH
4276: LD_INT 7
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_INT 10
4284: PUSH
4285: LD_INT 10
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_OWVAR 67
4298: ARRAY
4299: PPUSH
4300: CALL_OW 380
// un := CreateVehicle ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: CALL_OW 45
4313: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4314: LD_VAR 0 6
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: LD_INT 5
4324: PPUSH
4325: CALL_OW 12
4329: PPUSH
4330: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4334: LD_VAR 0 6
4338: PPUSH
4339: LD_VAR 0 5
4343: PUSH
4344: LD_INT 1
4346: ARRAY
4347: PPUSH
4348: LD_VAR 0 5
4352: PUSH
4353: LD_INT 2
4355: ARRAY
4356: PPUSH
4357: LD_INT 6
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// un2 := CreateHuman ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: CALL_OW 44
4376: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4377: LD_VAR 0 7
4381: PPUSH
4382: LD_VAR 0 6
4386: PPUSH
4387: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4391: LD_ADDR_EXP 60
4395: PUSH
4396: LD_EXP 60
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 60
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 6
4425: PPUSH
4426: CALL 19801 0 3
4430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4431: LD_ADDR_EXP 60
4435: PUSH
4436: LD_EXP 60
4440: PPUSH
4441: LD_INT 1
4443: PUSH
4444: LD_EXP 60
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: LD_VAR 0 7
4465: PPUSH
4466: CALL 19801 0 3
4470: ST_TO_ADDR
// end ;
4471: GO 4224
4473: POP
4474: POP
// for i = 1 to 5 do
4475: LD_ADDR_VAR 0 2
4479: PUSH
4480: DOUBLE
4481: LD_INT 1
4483: DEC
4484: ST_TO_ADDR
4485: LD_INT 5
4487: PUSH
4488: FOR_TO
4489: IFFALSE 4582
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4491: LD_INT 14
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 25
4502: PUSH
4503: LD_INT 28
4505: PUSH
4506: LD_INT 28
4508: PUSH
4509: LD_INT 26
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PUSH
4518: LD_VAR 0 2
4522: PUSH
4523: LD_INT 4
4525: MOD
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: ARRAY
4531: PPUSH
4532: LD_INT 100
4534: PPUSH
4535: CALL 19679 0 5
// veh := CreateVehicle ;
4539: LD_ADDR_VAR 0 3
4543: PUSH
4544: CALL_OW 45
4548: ST_TO_ADDR
// tmp := tmp ^ veh ;
4549: LD_ADDR_VAR 0 4
4553: PUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_VAR 0 3
4563: ADD
4564: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4565: LD_VAR 0 3
4569: PPUSH
4570: LD_INT 1
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 49
// end ;
4580: GO 4488
4582: POP
4583: POP
// arabian_guard := tmp ;
4584: LD_ADDR_EXP 55
4588: PUSH
4589: LD_VAR 0 4
4593: ST_TO_ADDR
// end ;
4594: LD_VAR 0 1
4598: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4599: LD_INT 22
4601: PUSH
4602: LD_INT 7
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 91
4611: PUSH
4612: LD_INT 1
4614: PUSH
4615: LD_INT 12
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PPUSH
4627: CALL_OW 69
4631: PUSH
4632: LD_EXP 57
4636: PPUSH
4637: CALL_OW 256
4641: PUSH
4642: LD_INT 990
4644: LESS
4645: OR
4646: PUSH
4647: LD_EXP 56
4651: PPUSH
4652: CALL_OW 256
4656: PUSH
4657: LD_INT 990
4659: LESS
4660: OR
4661: IFFALSE 4804
4663: GO 4665
4665: DISABLE
// begin if IsInUnit ( Abdul ) then
4666: LD_EXP 56
4670: PPUSH
4671: CALL_OW 310
4675: IFFALSE 4686
// ComExitBuilding ( Abdul ) ;
4677: LD_EXP 56
4681: PPUSH
4682: CALL_OW 122
// if Mastodont then
4686: LD_EXP 57
4690: IFFALSE 4707
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4692: LD_EXP 57
4696: PPUSH
4697: LD_INT 205
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4707: LD_EXP 56
4711: PPUSH
4712: LD_INT 205
4714: PPUSH
4715: LD_INT 132
4717: PPUSH
4718: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4729: LD_EXP 56
4733: PPUSH
4734: LD_INT 21
4736: PPUSH
4737: CALL_OW 308
4741: IFFALSE 4722
// RemoveUnit ( Abdul ) ;
4743: LD_EXP 56
4747: PPUSH
4748: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4752: LD_INT 35
4754: PPUSH
4755: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4759: LD_EXP 57
4763: PPUSH
4764: LD_INT 21
4766: PPUSH
4767: CALL_OW 308
4771: PUSH
4772: LD_EXP 57
4776: PPUSH
4777: CALL_OW 301
4781: OR
4782: IFFALSE 4752
// if IsOk ( Mastodont ) then
4784: LD_EXP 57
4788: PPUSH
4789: CALL_OW 302
4793: IFFALSE 4804
// RemoveUnit ( Mastodont ) ;
4795: LD_EXP 57
4799: PPUSH
4800: CALL_OW 64
// end ;
4804: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4805: LD_EXP 56
4809: PPUSH
4810: CALL_OW 301
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 25
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 25
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 25
4860: PUSH
4861: LD_INT 4
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 8
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: PUSH
4895: LD_INT 16
4897: PUSH
4898: LD_INT 19
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 22
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_OWVAR 67
4917: ARRAY
4918: LESS
4919: OR
4920: IFFALSE 5593
4922: GO 4924
4924: DISABLE
4925: LD_INT 0
4927: PPUSH
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
// begin MC_Kill ( 1 ) ;
4933: LD_INT 1
4935: PPUSH
4936: CALL 55148 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 25
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 25
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 3
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 25
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 69
5024: ST_TO_ADDR
// for i in tmp do
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_VAR 0 2
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5052
// SetTag ( i , 10 ) ;
5038: LD_VAR 0 5
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 109
5050: GO 5035
5052: POP
5053: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5054: LD_ADDR_VAR 0 3
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 21
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: PUSH
5088: LD_VAR 0 2
5092: DIFF
5093: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_INT 22
5101: PUSH
5102: LD_INT 2
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 21
5111: PUSH
5112: LD_INT 2
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 24
5121: PUSH
5122: LD_INT 300
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PPUSH
5134: CALL_OW 69
5138: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5139: LD_ADDR_VAR 0 4
5143: PUSH
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 33
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 58
5161: PUSH
5162: EMPTY
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 72
5173: ST_TO_ADDR
// for i in tmp do
5174: LD_ADDR_VAR 0 5
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5369
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5187: LD_VAR 0 5
5191: PUSH
5192: LD_INT 55
5194: PUSH
5195: EMPTY
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: IN
5203: IFFALSE 5222
// begin AddComMoveXY ( i , 209 , 132 ) ;
5205: LD_VAR 0 5
5209: PPUSH
5210: LD_INT 209
5212: PPUSH
5213: LD_INT 132
5215: PPUSH
5216: CALL_OW 171
// continue ;
5220: GO 5184
// end ; if IsInUnit ( i ) then
5222: LD_VAR 0 5
5226: PPUSH
5227: CALL_OW 310
5231: IFFALSE 5249
// begin ComExitBuilding ( i ) ;
5233: LD_VAR 0 5
5237: PPUSH
5238: CALL_OW 122
// wait ( 3 ) ;
5242: LD_INT 3
5244: PPUSH
5245: CALL_OW 67
// end ; if tmp_empty then
5249: LD_VAR 0 4
5253: IFFALSE 5352
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5255: LD_VAR 0 5
5259: PPUSH
5260: LD_VAR 0 4
5264: PPUSH
5265: LD_VAR 0 5
5269: PPUSH
5270: CALL_OW 74
5274: PPUSH
5275: CALL_OW 296
5279: PUSH
5280: LD_INT 25
5282: LESS
5283: IFFALSE 5352
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 5
5299: PPUSH
5300: CALL_OW 74
5304: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5305: LD_VAR 0 5
5309: PPUSH
5310: LD_VAR 0 6
5314: PPUSH
5315: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5319: LD_VAR 0 5
5323: PPUSH
5324: LD_INT 209
5326: PPUSH
5327: LD_INT 132
5329: PPUSH
5330: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 6
5348: DIFF
5349: ST_TO_ADDR
// continue ;
5350: GO 5184
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5352: LD_VAR 0 5
5356: PPUSH
5357: LD_INT 201
5359: PPUSH
5360: LD_INT 132
5362: PPUSH
5363: CALL_OW 171
// end ;
5367: GO 5184
5369: POP
5370: POP
// for i in tmp_ape do
5371: LD_ADDR_VAR 0 5
5375: PUSH
5376: LD_VAR 0 3
5380: PUSH
5381: FOR_IN
5382: IFFALSE 5421
// begin if IsInUnit ( i ) then
5384: LD_VAR 0 5
5388: PPUSH
5389: CALL_OW 310
5393: IFFALSE 5404
// ComExitBuilding ( i ) ;
5395: LD_VAR 0 5
5399: PPUSH
5400: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5404: LD_VAR 0 5
5408: PPUSH
5409: LD_INT 201
5411: PPUSH
5412: LD_INT 132
5414: PPUSH
5415: CALL_OW 171
// end ;
5419: GO 5381
5421: POP
5422: POP
// repeat wait ( 0 0$1 ) ;
5423: LD_INT 35
5425: PPUSH
5426: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 2
5439: PUSH
5440: LD_VAR 0 3
5444: UNION
5445: PUSH
5446: LD_VAR 0 1
5450: UNION
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5484
// if not HasTask ( i ) then
5455: LD_VAR 0 5
5459: PPUSH
5460: CALL_OW 314
5464: NOT
5465: IFFALSE 5482
// ComMoveXY ( i , 201 , 132 ) ;
5467: LD_VAR 0 5
5471: PPUSH
5472: LD_INT 201
5474: PPUSH
5475: LD_INT 132
5477: PPUSH
5478: CALL_OW 111
5482: GO 5452
5484: POP
5485: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5486: LD_INT 21
5488: PPUSH
5489: LD_INT 22
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL_OW 70
5503: IFFALSE 5544
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 21
5512: PPUSH
5513: LD_INT 22
5515: PUSH
5516: LD_INT 2
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: PUSH
5528: FOR_IN
5529: IFFALSE 5542
// RemoveUnit ( i ) ;
5531: LD_VAR 0 5
5535: PPUSH
5536: CALL_OW 64
5540: GO 5528
5542: POP
5543: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 2
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 2
5556: PUSH
5557: LD_INT 21
5559: PUSH
5560: LD_INT 1
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 21
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: NOT
5591: IFFALSE 5423
// end ;
5593: PPOPN 6
5595: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5596: LD_EXP 9
5600: PUSH
5601: LD_INT 92
5603: PPUSH
5604: LD_INT 40
5606: PPUSH
5607: CALL_OW 428
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 30
5619: EQUAL
5620: AND
5621: IFFALSE 5817
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5629: LD_ADDR_VAR 0 1
5633: PUSH
5634: LD_EXP 60
5638: PUSH
5639: LD_INT 1
5641: ARRAY
5642: PPUSH
5643: LD_INT 25
5645: PUSH
5646: LD_INT 4
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PPUSH
5653: CALL_OW 72
5657: ST_TO_ADDR
// if not sci then
5658: LD_VAR 0 1
5662: NOT
5663: IFFALSE 5667
// exit ;
5665: GO 5817
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5667: LD_ADDR_EXP 60
5671: PUSH
5672: LD_EXP 60
5676: PPUSH
5677: LD_INT 1
5679: PPUSH
5680: LD_EXP 60
5684: PUSH
5685: LD_INT 1
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 1
5693: PUSH
5694: LD_INT 1
5696: ARRAY
5697: DIFF
5698: PPUSH
5699: CALL_OW 1
5703: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5704: LD_VAR 0 1
5708: PUSH
5709: LD_INT 1
5711: ARRAY
5712: PPUSH
5713: CALL_OW 310
5717: IFFALSE 5732
// ComExitBuilding ( sci [ 1 ] ) ;
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5732: LD_INT 2
5734: PPUSH
5735: LD_INT 105
5737: PPUSH
5738: LD_INT 14
5740: PPUSH
5741: LD_INT 20
5743: PPUSH
5744: CALL 20697 0 4
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 10
5755: LESS
5756: IFFALSE 5779
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: LD_INT 105
5769: PPUSH
5770: LD_INT 14
5772: PPUSH
5773: CALL_OW 171
5777: GO 5798
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5779: LD_VAR 0 1
5783: PUSH
5784: LD_INT 1
5786: ARRAY
5787: PPUSH
5788: LD_INT 118
5790: PPUSH
5791: LD_INT 77
5793: PPUSH
5794: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5798: LD_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ARRAY
5806: PPUSH
5807: LD_INT 92
5809: PPUSH
5810: LD_INT 40
5812: PPUSH
5813: CALL_OW 218
// end ;
5817: PPOPN 1
5819: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5820: LD_INT 1
5822: PPUSH
5823: CALL_OW 302
5827: PUSH
5828: LD_EXP 9
5832: AND
5833: IFFALSE 6312
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
5844: PPUSH
5845: PPUSH
// begin enable ;
5846: ENABLE
// base := 1 ;
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_INT 1
5854: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 0
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 0
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5902: LD_ADDR_VAR 0 3
5906: PUSH
5907: LD_INT 14
5909: PUSH
5910: LD_INT 1
5912: PUSH
5913: LD_INT 2
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 14
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 28
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 29
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_OWVAR 67
5980: PUSH
5981: LD_OWVAR 1
5985: PUSH
5986: LD_INT 21000
5988: DIV
5989: PLUS
5990: PUSH
5991: FOR_TO
5992: IFFALSE 6084
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5994: LD_ADDR_VAR 0 3
5998: PUSH
5999: LD_VAR 0 3
6003: PPUSH
6004: LD_VAR 0 3
6008: PUSH
6009: LD_INT 1
6011: PLUS
6012: PPUSH
6013: LD_INT 13
6015: PUSH
6016: LD_INT 14
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 26
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 1
6061: PPUSH
6062: LD_INT 4
6064: PPUSH
6065: CALL_OW 12
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PPUSH
6077: CALL_OW 2
6081: ST_TO_ADDR
6082: GO 5991
6084: POP
6085: POP
// MC_InsertProduceList ( base , tmp ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_VAR 0 3
6095: PPUSH
6096: CALL 79126 0 2
// repeat wait ( 0 0$1 ) ;
6100: LD_INT 35
6102: PPUSH
6103: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6107: LD_EXP 79
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_INT 6
6120: GREATER
6121: IFFALSE 6100
// wait ( 0 0$20 ) ;
6123: LD_INT 700
6125: PPUSH
6126: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6130: LD_ADDR_VAR 0 5
6134: PUSH
6135: LD_INT 124
6137: PUSH
6138: LD_INT 85
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 90
6147: PUSH
6148: LD_INT 61
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 69
6157: PUSH
6158: LD_INT 48
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 68
6167: PUSH
6168: LD_INT 48
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_EXP 79
6190: PUSH
6191: LD_VAR 0 2
6195: ARRAY
6196: PUSH
6197: LD_EXP 79
6201: PUSH
6202: LD_VAR 0 2
6206: ARRAY
6207: PPUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 34
6213: PUSH
6214: LD_INT 32
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 34
6223: PUSH
6224: LD_EXP 110
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6312
// ar_attackers := attackers ;
6253: LD_ADDR_EXP 11
6257: PUSH
6258: LD_VAR 0 6
6262: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6270: LD_VAR 0 6
6274: PPUSH
6275: LD_INT 60
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: NOT
6286: IFFALSE 6263
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 79311 0 4
// end ;
6312: PPOPN 6
6314: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6315: LD_INT 1
6317: PPUSH
6318: CALL_OW 302
6322: PUSH
6323: LD_EXP 9
6327: AND
6328: PUSH
6329: LD_EXP 50
6333: PPUSH
6334: LD_INT 22
6336: PPUSH
6337: CALL_OW 308
6341: AND
6342: PUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 79474 0 1
6350: PUSH
6351: LD_INT 0
6353: EQUAL
6354: AND
6355: PUSH
6356: LD_EXP 11
6360: NOT
6361: AND
6362: IFFALSE 6850
6364: GO 6366
6366: DISABLE
6367: LD_INT 0
6369: PPUSH
6370: PPUSH
6371: PPUSH
6372: PPUSH
6373: PPUSH
6374: PPUSH
6375: PPUSH
// begin base := 1 ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 0
6391: PUSH
6392: LD_INT 0
6394: PUSH
6395: LD_INT 0
6397: PUSH
6398: LD_INT 0
6400: PUSH
6401: LD_INT 0
6403: PUSH
6404: LD_INT 0
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: LD_INT 0
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6431: LD_ADDR_VAR 0 3
6435: PUSH
6436: LD_INT 13
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 28
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 27
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 25
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 11
6492: PUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 24
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 11
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 2
6516: PUSH
6517: LD_INT 24
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 79126 0 2
// repeat wait ( 0 0$1 ) ;
6547: LD_INT 35
6549: PPUSH
6550: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6554: LD_EXP 79
6558: PUSH
6559: LD_VAR 0 2
6563: ARRAY
6564: PUSH
6565: LD_INT 6
6567: GREATEREQUAL
6568: IFFALSE 6547
// wait ( 0 0$20 ) ;
6570: LD_INT 700
6572: PPUSH
6573: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6577: LD_ADDR_VAR 0 5
6581: PUSH
6582: LD_INT 119
6584: PUSH
6585: LD_INT 9
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6595: LD_ADDR_VAR 0 6
6599: PUSH
6600: LD_EXP 79
6604: PUSH
6605: LD_VAR 0 2
6609: ARRAY
6610: PUSH
6611: LD_EXP 79
6615: PUSH
6616: LD_VAR 0 2
6620: ARRAY
6621: PPUSH
6622: LD_INT 2
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 34
6637: PUSH
6638: LD_EXP 110
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PPUSH
6652: CALL_OW 72
6656: DIFF
6657: ST_TO_ADDR
// if not attackers then
6658: LD_VAR 0 6
6662: NOT
6663: IFFALSE 6667
// exit ;
6665: GO 6850
// uc_side := 2 ;
6667: LD_ADDR_OWVAR 20
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// uc_nation := 2 ;
6675: LD_ADDR_OWVAR 21
6679: PUSH
6680: LD_INT 2
6682: ST_TO_ADDR
// InitHc ;
6683: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6687: LD_ADDR_VAR 0 1
6691: PUSH
6692: DOUBLE
6693: LD_INT 1
6695: DEC
6696: ST_TO_ADDR
6697: LD_INT 4
6699: PUSH
6700: LD_INT 5
6702: PUSH
6703: LD_INT 6
6705: PUSH
6706: LD_INT 6
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: PUSH
6715: LD_OWVAR 67
6719: ARRAY
6720: PUSH
6721: FOR_TO
6722: IFFALSE 6799
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6724: LD_INT 0
6726: PPUSH
6727: LD_INT 15
6729: PUSH
6730: LD_INT 17
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 2
6742: PPUSH
6743: CALL_OW 12
6747: ARRAY
6748: PPUSH
6749: LD_INT 8
6751: PPUSH
6752: CALL_OW 380
// un := CreateHuman ;
6756: LD_ADDR_VAR 0 7
6760: PUSH
6761: CALL_OW 44
6765: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 23
6773: PPUSH
6774: LD_INT 0
6776: PPUSH
6777: CALL_OW 49
// attackers := attackers union un ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_VAR 0 6
6790: PUSH
6791: LD_VAR 0 7
6795: UNION
6796: ST_TO_ADDR
// end ;
6797: GO 6721
6799: POP
6800: POP
// repeat wait ( 0 0$1 ) ;
6801: LD_INT 35
6803: PPUSH
6804: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6808: LD_VAR 0 6
6812: PPUSH
6813: LD_INT 60
6815: PUSH
6816: EMPTY
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: NOT
6824: IFFALSE 6801
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 6
6835: PPUSH
6836: LD_VAR 0 5
6840: PPUSH
6841: LD_VAR 0 4
6845: PPUSH
6846: CALL 79311 0 4
// end ; end_of_file
6850: PPOPN 7
6852: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
6859: PPUSH
6860: PPUSH
// uc_side := 1 ;
6861: LD_ADDR_OWVAR 20
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// uc_nation := 1 ;
6869: LD_ADDR_OWVAR 21
6873: PUSH
6874: LD_INT 1
6876: ST_TO_ADDR
// InitHc ;
6877: CALL_OW 19
// InitVc ;
6881: CALL_OW 20
// tmp := [ ] ;
6885: LD_ADDR_VAR 0 3
6889: PUSH
6890: EMPTY
6891: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: DOUBLE
6898: LD_INT 1
6900: DEC
6901: ST_TO_ADDR
6902: LD_INT 6
6904: PUSH
6905: LD_INT 8
6907: PUSH
6908: LD_INT 10
6910: PUSH
6911: LD_INT 10
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: LD_OWVAR 67
6924: ARRAY
6925: PUSH
6926: FOR_TO
6927: IFFALSE 7201
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6929: LD_ADDR_VAR 0 5
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: LD_INT 5
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 1
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: CALL_OW 12
6958: ARRAY
6959: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6960: LD_VAR 0 5
6964: PUSH
6965: LD_INT 2
6967: DOUBLE
6968: EQUAL
6969: IFTRUE 6973
6971: GO 7007
6973: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6974: LD_ADDR_VAR 0 6
6978: PUSH
6979: LD_INT 9
6981: PUSH
6982: LD_INT 5
6984: PUSH
6985: LD_INT 7
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 1
6995: PPUSH
6996: LD_INT 3
6998: PPUSH
6999: CALL_OW 12
7003: ARRAY
7004: ST_TO_ADDR
7005: GO 7096
7007: LD_INT 4
7009: DOUBLE
7010: EQUAL
7011: IFTRUE 7015
7013: GO 7053
7015: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7016: LD_ADDR_VAR 0 6
7020: PUSH
7021: LD_INT 9
7023: PUSH
7024: LD_INT 6
7026: PUSH
7027: LD_INT 6
7029: PUSH
7030: LD_INT 7
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 1
7041: PPUSH
7042: LD_INT 4
7044: PPUSH
7045: CALL_OW 12
7049: ARRAY
7050: ST_TO_ADDR
7051: GO 7096
7053: LD_INT 5
7055: DOUBLE
7056: EQUAL
7057: IFTRUE 7061
7059: GO 7095
7061: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7062: LD_ADDR_VAR 0 6
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: LD_INT 6
7072: PUSH
7073: LD_INT 7
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 3
7086: PPUSH
7087: CALL_OW 12
7091: ARRAY
7092: ST_TO_ADDR
7093: GO 7096
7095: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 2
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_VAR 0 6
7130: PPUSH
7131: LD_INT 70
7133: PPUSH
7134: LD_INT 90
7136: PPUSH
7137: CALL_OW 12
7141: PPUSH
7142: CALL 19679 0 5
// veh := CreateVehicle ;
7146: LD_ADDR_VAR 0 4
7150: PUSH
7151: CALL_OW 45
7155: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7168: LD_VAR 0 4
7172: PPUSH
7173: LD_INT 17
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL_OW 49
// tmp := tmp ^ veh ;
7183: LD_ADDR_VAR 0 3
7187: PUSH
7188: LD_VAR 0 3
7192: PUSH
7193: LD_VAR 0 4
7197: ADD
7198: ST_TO_ADDR
// end ;
7199: GO 6926
7201: POP
7202: POP
// if not tmp then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7321
// if not first_powell_attack then
7212: LD_EXP 12
7216: NOT
7217: IFFALSE 7227
// first_powell_attack := true ;
7219: LD_ADDR_EXP 12
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7227: LD_INT 70
7229: PPUSH
7230: CALL_OW 67
// for i in tmp do
7234: LD_ADDR_VAR 0 2
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: FOR_IN
7245: IFFALSE 7312
// if IsOk ( i ) then
7247: LD_VAR 0 2
7251: PPUSH
7252: CALL_OW 302
7256: IFFALSE 7294
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 81
7265: PUSH
7266: LD_INT 1
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 74
7287: PPUSH
7288: CALL_OW 115
7292: GO 7310
// tmp := tmp diff i ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: DIFF
7309: ST_TO_ADDR
7310: GO 7244
7312: POP
7313: POP
// until not tmp ;
7314: LD_VAR 0 3
7318: NOT
7319: IFFALSE 7227
// end ; end_of_file
7321: LD_VAR 0 1
7325: RET
// export function Action ; var tmp , i , un ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7332: LD_INT 68
7334: PPUSH
7335: LD_INT 39
7337: PPUSH
7338: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: LD_INT 22
7349: PUSH
7350: LD_INT 7
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PPUSH
7357: CALL_OW 69
7361: ST_TO_ADDR
// InGameOn ;
7362: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7366: LD_VAR 0 2
7370: PPUSH
7371: LD_INT 71
7373: PPUSH
7374: LD_INT 49
7376: PPUSH
7377: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7381: LD_INT 35
7383: PPUSH
7384: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7388: LD_INT 7
7390: PPUSH
7391: LD_INT 71
7393: PPUSH
7394: LD_INT 51
7396: PPUSH
7397: CALL_OW 293
7401: IFFALSE 7381
// DialogueOn ;
7403: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7407: LD_EXP 16
7411: PPUSH
7412: LD_STRING D1-JMM-1
7414: PPUSH
7415: CALL_OW 88
// if Joan then
7419: LD_EXP 31
7423: IFFALSE 7437
// Say ( Joan , D1-Joan-1 ) ;
7425: LD_EXP 31
7429: PPUSH
7430: LD_STRING D1-Joan-1
7432: PPUSH
7433: CALL_OW 88
// if Lisa then
7437: LD_EXP 18
7441: IFFALSE 7455
// Say ( Lisa , D1-Lisa-1 ) ;
7443: LD_EXP 18
7447: PPUSH
7448: LD_STRING D1-Lisa-1
7450: PPUSH
7451: CALL_OW 88
// if Joan or Lisa then
7455: LD_EXP 31
7459: PUSH
7460: LD_EXP 18
7464: OR
7465: IFFALSE 7479
// Say ( JMM , D1-JMM-2 ) ;
7467: LD_EXP 16
7471: PPUSH
7472: LD_STRING D1-JMM-2
7474: PPUSH
7475: CALL_OW 88
// DialogueOff ;
7479: CALL_OW 7
// InGameOff ;
7483: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7487: LD_INT 71
7489: PPUSH
7490: LD_INT 50
7492: PPUSH
7493: LD_INT 7
7495: PPUSH
7496: LD_INT 30
7498: NEG
7499: PPUSH
7500: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 50
7509: PPUSH
7510: LD_INT 7
7512: PPUSH
7513: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7517: LD_STRING M1
7519: PPUSH
7520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7524: LD_INT 35
7526: PPUSH
7527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7531: LD_EXP 3
7535: PUSH
7536: LD_OWVAR 1
7540: PUSH
7541: LD_INT 2100
7543: GREATER
7544: OR
7545: IFFALSE 7524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7547: LD_INT 350
7549: PPUSH
7550: LD_INT 700
7552: PPUSH
7553: CALL_OW 12
7557: PPUSH
7558: CALL_OW 67
// PrepareGossudarov ;
7562: CALL 1881 0 0
// repeat wait ( 0 0$1 ) ;
7566: LD_INT 35
7568: PPUSH
7569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7573: LD_INT 22
7575: PUSH
7576: LD_INT 6
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 24
7588: PUSH
7589: LD_INT 1000
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PPUSH
7604: CALL_OW 69
7608: PUSH
7609: LD_INT 7
7611: PPUSH
7612: LD_EXP 33
7616: PPUSH
7617: CALL_OW 292
7621: OR
7622: IFFALSE 7566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7624: LD_ADDR_VAR 0 2
7628: PUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 69
7643: ST_TO_ADDR
// for i in tmp do
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_VAR 0 2
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7671
// SetSide ( i , 7 ) ;
7657: LD_VAR 0 3
7661: PPUSH
7662: LD_INT 7
7664: PPUSH
7665: CALL_OW 235
7669: GO 7654
7671: POP
7672: POP
// DialogueOn ;
7673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7677: LD_EXP 16
7681: PUSH
7682: LD_EXP 17
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: LD_EXP 33
7695: PPUSH
7696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7700: LD_EXP 33
7704: PPUSH
7705: CALL_OW 87
// if not Roth then
7709: LD_EXP 17
7713: NOT
7714: IFFALSE 7806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7716: LD_VAR 0 2
7720: PPUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 24
7726: PUSH
7727: LD_INT 1000
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 72
7742: IFFALSE 7756
// Say ( JMM , D2-JMM-1 ) ;
7744: LD_EXP 16
7748: PPUSH
7749: LD_STRING D2-JMM-1
7751: PPUSH
7752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7756: LD_EXP 16
7760: PPUSH
7761: LD_STRING D2-JMM-1b
7763: PPUSH
7764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7768: LD_EXP 33
7772: PPUSH
7773: LD_STRING D2-Gos-1
7775: PPUSH
7776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7780: LD_EXP 16
7784: PPUSH
7785: LD_STRING D2-JMM-2
7787: PPUSH
7788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7792: LD_EXP 33
7796: PPUSH
7797: LD_STRING D2-Gos-2
7799: PPUSH
7800: CALL_OW 88
// end else
7804: GO 7958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 24
7816: PUSH
7817: LD_INT 1000
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PPUSH
7828: CALL_OW 72
7832: IFFALSE 7858
// begin Say ( Roth , D2-Roth-2 ) ;
7834: LD_EXP 17
7838: PPUSH
7839: LD_STRING D2-Roth-2
7841: PPUSH
7842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7846: LD_EXP 16
7850: PPUSH
7851: LD_STRING D2-JMM-1a
7853: PPUSH
7854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7858: LD_EXP 17
7862: PPUSH
7863: LD_STRING D2-Roth-2a
7865: PPUSH
7866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7870: LD_EXP 17
7874: PPUSH
7875: LD_STRING D2-Roth-2b
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7882: LD_EXP 16
7886: PPUSH
7887: LD_STRING D2-JMM-3
7889: PPUSH
7890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7894: LD_VAR 0 2
7898: PPUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PPUSH
7916: CALL_OW 72
7920: IFFALSE 7958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7922: LD_EXP 33
7926: PPUSH
7927: LD_STRING D2-Gos-3
7929: PPUSH
7930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7934: LD_EXP 16
7938: PPUSH
7939: LD_STRING D2-JMM-4
7941: PPUSH
7942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7946: LD_EXP 33
7950: PPUSH
7951: LD_STRING D2-Gos-4
7953: PPUSH
7954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7958: LD_EXP 16
7962: PPUSH
7963: LD_STRING D2-JMM-5
7965: PPUSH
7966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7970: LD_EXP 33
7974: PPUSH
7975: LD_STRING D2-Gos-5
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7982: LD_EXP 16
7986: PPUSH
7987: LD_STRING D2-JMM-6
7989: PPUSH
7990: CALL_OW 88
// DialogueOff ;
7994: CALL_OW 7
// wait ( 0 0$2 ) ;
7998: LD_INT 70
8000: PPUSH
8001: CALL_OW 67
// if Kirilenkova then
8005: LD_EXP 34
8009: IFFALSE 8023
// Say ( Kirilenkova , D3-Kir-1 ) ;
8011: LD_EXP 34
8015: PPUSH
8016: LD_STRING D3-Kir-1
8018: PPUSH
8019: CALL_OW 88
// gossudarov_arrive := true ;
8023: LD_ADDR_EXP 4
8027: PUSH
8028: LD_INT 1
8030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// until ru_lab_builded ;
8038: LD_EXP 5
8042: IFFALSE 8031
// DialogueOn ;
8044: CALL_OW 6
// if Kirilenkova then
8048: LD_EXP 34
8052: IFFALSE 8068
// Say ( Kirilenkova , D3a-Kir-1 ) else
8054: LD_EXP 34
8058: PPUSH
8059: LD_STRING D3a-Kir-1
8061: PPUSH
8062: CALL_OW 88
8066: GO 8090
// begin un := SciRu ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: CALL 13222 0 0
8077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8078: LD_VAR 0 4
8082: PPUSH
8083: LD_STRING D3a-Sci1-1
8085: PPUSH
8086: CALL_OW 88
// end ; if Kirilenkova or un then
8090: LD_EXP 34
8094: PUSH
8095: LD_VAR 0 4
8099: OR
8100: IFFALSE 8114
// Say ( JMM , D3a-JMM-1 ) ;
8102: LD_EXP 16
8106: PPUSH
8107: LD_STRING D3a-JMM-1
8109: PPUSH
8110: CALL_OW 88
// DialogueOff ;
8114: CALL_OW 7
// end ;
8118: LD_VAR 0 1
8122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8123: LD_EXP 4
8127: PUSH
8128: LD_INT 22
8130: PUSH
8131: LD_INT 7
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 4
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 5
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 8
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 9
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 7
8232: LESS
8233: AND
8234: IFFALSE 8246
8236: GO 8238
8238: DISABLE
// YouLost ( TooMany ) ;
8239: LD_STRING TooMany
8241: PPUSH
8242: CALL_OW 104
8246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8247: LD_EXP 33
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 7
8259: EQUAL
8260: IFFALSE 8477
8262: GO 8264
8264: DISABLE
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
// begin uc_side := 3 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// uc_nation := 3 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 3
8285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8286: LD_INT 21
8288: PPUSH
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 42
8297: PPUSH
8298: LD_INT 100
8300: PPUSH
8301: CALL 19679 0 5
// un := CreateVehicle ;
8305: LD_ADDR_VAR 0 3
8309: PUSH
8310: CALL_OW 45
8314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8315: LD_VAR 0 3
8319: PPUSH
8320: LD_INT 15
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8330: LD_VAR 0 3
8334: PPUSH
8335: LD_INT 67
8337: PPUSH
8338: LD_INT 45
8340: PPUSH
8341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_INT 70
8352: PPUSH
8353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8357: LD_VAR 0 3
8361: PPUSH
8362: LD_INT 69
8364: PPUSH
8365: LD_INT 18
8367: PPUSH
8368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8372: LD_VAR 0 3
8376: PPUSH
8377: LD_INT 60
8379: PPUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8387: LD_INT 35
8389: PPUSH
8390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8394: LD_VAR 0 3
8398: PPUSH
8399: CALL_OW 302
8403: NOT
8404: PUSH
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 17
8412: PPUSH
8413: CALL_OW 308
8417: OR
8418: PUSH
8419: LD_VAR 0 3
8423: PPUSH
8424: LD_INT 60
8426: PPUSH
8427: LD_INT 3
8429: PPUSH
8430: CALL_OW 307
8434: OR
8435: IFFALSE 8387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_INT 17
8444: PPUSH
8445: CALL_OW 308
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 60
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 307
8465: OR
8466: IFFALSE 8477
// RemoveUnit ( un ) ;
8468: LD_VAR 0 3
8472: PPUSH
8473: CALL_OW 64
// end ;
8477: PPOPN 3
8479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8480: LD_EXP 4
8484: IFFALSE 8726
8486: GO 8488
8488: DISABLE
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8494: LD_INT 70
8496: PPUSH
8497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 7
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: LD_INT 101
8518: PUSH
8519: LD_INT 3
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// until tmp ;
8535: LD_VAR 0 3
8539: IFFALSE 8494
// un := NearestUnitToUnit ( tmp , JMM ) ;
8541: LD_ADDR_VAR 0 2
8545: PUSH
8546: LD_VAR 0 3
8550: PPUSH
8551: LD_EXP 16
8555: PPUSH
8556: CALL_OW 74
8560: ST_TO_ADDR
// player_spotted := true ;
8561: LD_ADDR_EXP 6
8565: PUSH
8566: LD_INT 1
8568: ST_TO_ADDR
// tmp := SciRu ;
8569: LD_ADDR_VAR 0 3
8573: PUSH
8574: CALL 13222 0 0
8578: ST_TO_ADDR
// if not tmp then
8579: LD_VAR 0 3
8583: NOT
8584: IFFALSE 8596
// tmp := SolRu ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: CALL 13369 0 0
8595: ST_TO_ADDR
// DialogueOn ;
8596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 250
8609: PPUSH
8610: LD_VAR 0 2
8614: PPUSH
8615: CALL_OW 251
8619: PPUSH
8620: LD_INT 7
8622: PPUSH
8623: LD_INT 8
8625: NEG
8626: PPUSH
8627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8631: LD_VAR 0 2
8635: PPUSH
8636: CALL_OW 87
// if tmp then
8640: LD_VAR 0 3
8644: IFFALSE 8658
// Say ( tmp , D4-RSci1-1 ) ;
8646: LD_VAR 0 3
8650: PPUSH
8651: LD_STRING D4-RSci1-1
8653: PPUSH
8654: CALL_OW 88
// if Gossudarov then
8658: LD_EXP 33
8662: IFFALSE 8688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8664: LD_EXP 33
8668: PPUSH
8669: LD_STRING D4-Gos-1
8671: PPUSH
8672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8676: LD_EXP 16
8680: PPUSH
8681: LD_STRING D4-JMM-1
8683: PPUSH
8684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 250
8697: PPUSH
8698: LD_VAR 0 2
8702: PPUSH
8703: CALL_OW 251
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 331
// DialogueOff ;
8715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8719: LD_STRING M5
8721: PPUSH
8722: CALL_OW 337
// end ;
8726: PPOPN 3
8728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8729: LD_EXP 6
8733: IFFALSE 9326
8735: GO 8737
8737: DISABLE
8738: LD_INT 0
8740: PPUSH
8741: PPUSH
8742: PPUSH
// begin PrepareBelkov ;
8743: CALL 2194 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8747: LD_EXP 48
8751: PPUSH
8752: LD_INT 118
8754: PPUSH
8755: LD_INT 106
8757: PPUSH
8758: CALL_OW 111
// AddComHold ( Belkov ) ;
8762: LD_EXP 48
8766: PPUSH
8767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8778: LD_EXP 48
8782: PPUSH
8783: LD_INT 118
8785: PPUSH
8786: LD_INT 106
8788: PPUSH
8789: CALL_OW 307
8793: IFFALSE 8771
// ChangeSideFog ( 4 , 7 ) ;
8795: LD_INT 4
8797: PPUSH
8798: LD_INT 7
8800: PPUSH
8801: CALL_OW 343
// if IsOk ( Belkov ) then
8805: LD_EXP 48
8809: PPUSH
8810: CALL_OW 302
8814: IFFALSE 8898
// begin InGameOn ;
8816: CALL_OW 8
// DialogueOn ;
8820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8824: LD_EXP 48
8828: PPUSH
8829: LD_STRING D5-Bel-1
8831: PPUSH
8832: CALL_OW 94
// if Gossudarov then
8836: LD_EXP 33
8840: IFFALSE 8890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8842: LD_EXP 33
8846: PPUSH
8847: LD_STRING D5-Gos-1
8849: PPUSH
8850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8854: LD_EXP 16
8858: PPUSH
8859: LD_STRING D5-JMM-1
8861: PPUSH
8862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8866: LD_EXP 33
8870: PPUSH
8871: LD_STRING D5-Gos-2
8873: PPUSH
8874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8878: LD_EXP 16
8882: PPUSH
8883: LD_STRING D5-JMM-2
8885: PPUSH
8886: CALL_OW 88
// end ; DialogueOff ;
8890: CALL_OW 7
// InGameOff ;
8894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8898: LD_STRING QSaveBelkov
8900: PPUSH
8901: CALL_OW 97
8905: PUSH
8906: LD_INT 1
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 8964
8914: POP
// begin DialogueOn ;
8915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8919: LD_EXP 16
8923: PPUSH
8924: LD_STRING D5a-JMM-1
8926: PPUSH
8927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8931: LD_EXP 48
8935: PPUSH
8936: LD_STRING D5a-Bel-1
8938: PPUSH
8939: CALL_OW 94
// DialogueOff ;
8943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8947: LD_EXP 48
8951: PPUSH
8952: LD_INT 83
8954: PPUSH
8955: LD_INT 49
8957: PPUSH
8958: CALL_OW 111
// end ; 2 :
8962: GO 8997
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 8996
8972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8973: LD_EXP 16
8977: PPUSH
8978: LD_STRING D5a-JMM-2
8980: PPUSH
8981: CALL_OW 88
// ComHold ( Belkov ) ;
8985: LD_EXP 48
8989: PPUSH
8990: CALL_OW 140
// end ; end ;
8994: GO 8997
8996: POP
// time := 0 0$00 ;
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// vehSpawned := false ;
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9020: LD_VAR 0 1
9024: PUSH
9025: LD_INT 350
9027: PUSH
9028: LD_INT 175
9030: PUSH
9031: LD_INT 105
9033: PUSH
9034: LD_INT 70
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: LD_OWVAR 67
9047: ARRAY
9048: GREATEREQUAL
9049: PUSH
9050: LD_VAR 0 3
9054: NOT
9055: AND
9056: IFFALSE 9146
// begin vehSpawned := true ;
9058: LD_ADDR_VAR 0 3
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// uc_side := 3 ;
9066: LD_ADDR_OWVAR 20
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// uc_nation := 3 ;
9074: LD_ADDR_OWVAR 21
9078: PUSH
9079: LD_INT 3
9081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9082: LD_INT 22
9084: PPUSH
9085: LD_INT 3
9087: PPUSH
9088: LD_INT 3
9090: PPUSH
9091: LD_INT 43
9093: PPUSH
9094: LD_INT 100
9096: PPUSH
9097: CALL 19679 0 5
// veh := CreateVehicle ;
9101: LD_ADDR_VAR 0 2
9105: PUSH
9106: CALL_OW 45
9110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 130
9118: PPUSH
9119: LD_INT 131
9121: PPUSH
9122: LD_INT 0
9124: PPUSH
9125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_INT 100
9136: PPUSH
9137: LD_INT 82
9139: PPUSH
9140: CALL_OW 114
// end else
9144: GO 9160
// time := time + 0 0$1 ;
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_VAR 0 1
9155: PUSH
9156: LD_INT 35
9158: PLUS
9159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 301
9169: PUSH
9170: LD_EXP 48
9174: PPUSH
9175: CALL_OW 255
9179: PUSH
9180: LD_INT 4
9182: EQUAL
9183: AND
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 74
9209: PPUSH
9210: LD_EXP 48
9214: PPUSH
9215: CALL_OW 296
9219: PUSH
9220: LD_INT 10
9222: LESS
9223: OR
9224: IFFALSE 9013
// if IsDead ( Belkov ) then
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 301
9235: IFFALSE 9260
// begin CenterNowOnUnits ( Belkov ) ;
9237: LD_EXP 48
9241: PPUSH
9242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9246: LD_EXP 16
9250: PPUSH
9251: LD_STRING D5a-JMM-2a
9253: PPUSH
9254: CALL_OW 88
// exit ;
9258: GO 9326
// end ; if See ( 7 , Belkov ) then
9260: LD_INT 7
9262: PPUSH
9263: LD_EXP 48
9267: PPUSH
9268: CALL_OW 292
9272: IFFALSE 9286
// SetSide ( Belkov , 7 ) ;
9274: LD_EXP 48
9278: PPUSH
9279: LD_INT 7
9281: PPUSH
9282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9293: LD_EXP 48
9297: PPUSH
9298: LD_INT 66
9300: PPUSH
9301: LD_INT 45
9303: PPUSH
9304: CALL_OW 297
9308: PUSH
9309: LD_INT 30
9311: LESS
9312: IFFALSE 9286
// Say ( Belkov , D6-Bel-1 ) ;
9314: LD_EXP 48
9318: PPUSH
9319: LD_STRING D6-Bel-1
9321: PPUSH
9322: CALL_OW 88
// end ;
9326: PPOPN 3
9328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 302
9338: PUSH
9339: LD_EXP 48
9343: PPUSH
9344: CALL_OW 504
9348: PUSH
9349: LD_INT 2
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 47
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 34
9364: PUSH
9365: LD_INT 45
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: LIST
9376: PPUSH
9377: CALL_OW 69
9381: IN
9382: AND
9383: IFFALSE 9400
9385: GO 9387
9387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9388: LD_EXP 48
9392: PPUSH
9393: LD_STRING D7-Bel-1
9395: PPUSH
9396: CALL_OW 88
9400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9401: LD_INT 22
9403: PUSH
9404: LD_INT 7
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 101
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 8
9434: NOT
9435: AND
9436: PUSH
9437: LD_EXP 47
9441: PPUSH
9442: CALL_OW 305
9446: NOT
9447: AND
9448: IFFALSE 9918
9450: GO 9452
9452: DISABLE
9453: LD_INT 0
9455: PPUSH
// begin ar_base_spotted := true ;
9456: LD_ADDR_EXP 8
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 21
9481: PUSH
9482: LD_INT 3
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9498: LD_ADDR_VAR 0 1
9502: PUSH
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 16
9512: PPUSH
9513: CALL_OW 74
9517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9518: LD_INT 7
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: CALL_OW 332
// DialogueOn ;
9528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 250
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 251
9551: PPUSH
9552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 22
9563: PUSH
9564: LD_INT 7
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 23
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 26
9583: PUSH
9584: LD_INT 1
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: PUSH
9601: LD_EXP 16
9605: PUSH
9606: LD_EXP 20
9610: PUSH
9611: LD_EXP 21
9615: PUSH
9616: LD_EXP 28
9620: PUSH
9621: LD_EXP 17
9625: PUSH
9626: LD_EXP 26
9630: PUSH
9631: LD_EXP 22
9635: PUSH
9636: LD_EXP 24
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: DIFF
9651: ST_TO_ADDR
// if not tmp then
9652: LD_VAR 0 1
9656: NOT
9657: IFFALSE 9731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9659: LD_ADDR_VAR 0 1
9663: PUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 7
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: LD_INT 26
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: PUSH
9704: LD_EXP 31
9708: PUSH
9709: LD_EXP 18
9713: PUSH
9714: LD_EXP 29
9718: PUSH
9719: LD_EXP 30
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: DIFF
9730: ST_TO_ADDR
// if tmp then
9731: LD_VAR 0 1
9735: IFFALSE 9806
// case GetSex ( tmp [ 1 ] ) of sex_male :
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 1
9744: ARRAY
9745: PPUSH
9746: CALL_OW 258
9750: PUSH
9751: LD_INT 1
9753: DOUBLE
9754: EQUAL
9755: IFTRUE 9759
9757: GO 9778
9759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9760: LD_VAR 0 1
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_STRING D9-Sol1-1
9771: PPUSH
9772: CALL_OW 88
9776: GO 9806
9778: LD_INT 2
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9805
9786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_STRING D9-FSol1-1
9798: PPUSH
9799: CALL_OW 88
9803: GO 9806
9805: POP
// if Frank then
9806: LD_EXP 28
9810: IFFALSE 9914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 250
9821: PPUSH
9822: LD_EXP 57
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: LD_INT 7
9834: PPUSH
9835: LD_INT 8
9837: PPUSH
9838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9842: LD_EXP 57
9846: PPUSH
9847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9851: LD_EXP 28
9855: PPUSH
9856: LD_STRING D9-Frank-1
9858: PPUSH
9859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9863: LD_EXP 16
9867: PPUSH
9868: LD_STRING D9-JMM-1
9870: PPUSH
9871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9875: LD_EXP 28
9879: PPUSH
9880: LD_STRING D9-Frank-2
9882: PPUSH
9883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 250
9896: PPUSH
9897: LD_EXP 57
9901: PPUSH
9902: CALL_OW 251
9906: PPUSH
9907: LD_INT 7
9909: PPUSH
9910: CALL_OW 331
// end ; DialogueOff ;
9914: CALL_OW 7
// end ;
9918: PPOPN 1
9920: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9921: LD_EXP 7
9925: PUSH
9926: LD_OWVAR 1
9930: PUSH
9931: LD_INT 42000
9933: GREATEREQUAL
9934: OR
9935: IFFALSE 10962
9937: GO 9939
9939: DISABLE
9940: LD_INT 0
9942: PPUSH
9943: PPUSH
// begin selected_option := 1 ;
9944: LD_ADDR_VAR 0 2
9948: PUSH
9949: LD_INT 1
9951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9952: LD_INT 10500
9954: PPUSH
9955: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// until not ru_attackers ;
9966: LD_EXP 53
9970: NOT
9971: IFFALSE 9959
// PrepareBurlak ;
9973: CALL 2306 0 0
// repeat wait ( 0 0$2 ) ;
9977: LD_INT 70
9979: PPUSH
9980: CALL_OW 67
// until not HasTask ( Burlak ) ;
9984: LD_EXP 47
9988: PPUSH
9989: CALL_OW 314
9993: NOT
9994: IFFALSE 9977
// InGameOn ;
9996: CALL_OW 8
// DialogueOn ;
10000: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10004: LD_EXP 50
10008: PPUSH
10009: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10013: LD_EXP 47
10017: PPUSH
10018: LD_STRING D10-Bur-1
10020: PPUSH
10021: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10025: LD_EXP 48
10029: PUSH
10030: LD_EXP 48
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 7
10042: EQUAL
10043: AND
10044: IFFALSE 10058
// Say ( Belkov , D10-Bel-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bel-1
10053: PPUSH
10054: CALL_OW 88
// if Gossudarov then
10058: LD_EXP 33
10062: IFFALSE 10076
// Say ( Gossudarov , D10-Gos-1 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D10-Gos-1
10071: PPUSH
10072: CALL_OW 88
// if Kirilenkova then
10076: LD_EXP 34
10080: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-1 ) ;
10082: LD_EXP 34
10086: PPUSH
10087: LD_STRING D10-Kir-1
10089: PPUSH
10090: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10094: CALL 13369 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-1
10101: PPUSH
10102: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10106: LD_EXP 47
10110: PPUSH
10111: LD_STRING D10-Bur-2
10113: PPUSH
10114: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D10-JMM-2
10125: PPUSH
10126: CALL_OW 88
// if Kirilenkova then
10130: LD_EXP 34
10134: IFFALSE 10150
// Say ( Kirilenkova , D10-Kir-2 ) else
10136: LD_EXP 34
10140: PPUSH
10141: LD_STRING D10-Kir-2
10143: PPUSH
10144: CALL_OW 88
10148: GO 10162
// Say ( SolRu , D10-RSol1-2 ) ;
10150: CALL 13369 0 0
10154: PPUSH
10155: LD_STRING D10-RSol1-2
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D10-JMM-3
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10174: LD_EXP 47
10178: PPUSH
10179: LD_STRING D10-Bur-3
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10186: LD_EXP 16
10190: PPUSH
10191: LD_STRING D10-JMM-4
10193: PPUSH
10194: CALL_OW 88
// DialogueOff ;
10198: CALL_OW 7
// InGameOff ;
10202: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10206: LD_STRING M2
10208: PPUSH
10209: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10213: LD_INT 35
10215: PPUSH
10216: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10220: LD_INT 22
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 91
10232: PUSH
10233: LD_EXP 47
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10213
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 4
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10293
// SetSide ( i , 7 ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 235
10291: GO 10276
10293: POP
10294: POP
// ChangeMissionObjectives ( M3 ) ;
10295: LD_STRING M3
10297: PPUSH
10298: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10302: LD_INT 35
10304: PPUSH
10305: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10309: LD_EXP 16
10313: PPUSH
10314: LD_EXP 47
10318: PPUSH
10319: CALL_OW 296
10323: PUSH
10324: LD_INT 8
10326: LESS
10327: IFFALSE 10302
// ComTurnUnit ( JMM , Burlak ) ;
10329: LD_EXP 16
10333: PPUSH
10334: LD_EXP 47
10338: PPUSH
10339: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10343: LD_EXP 47
10347: PPUSH
10348: LD_EXP 16
10352: PPUSH
10353: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10357: LD_INT 10
10359: PPUSH
10360: CALL_OW 67
// DialogueOn ;
10364: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10368: LD_EXP 16
10372: PPUSH
10373: LD_STRING D11-JMM-1
10375: PPUSH
10376: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10380: LD_EXP 47
10384: PPUSH
10385: LD_STRING D11-Bur-1
10387: PPUSH
10388: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10392: LD_EXP 16
10396: PPUSH
10397: LD_STRING D11-JMM-2
10399: PPUSH
10400: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING D11-Bur-2
10411: PPUSH
10412: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10416: LD_EXP 16
10420: PPUSH
10421: LD_STRING D11-JMM-3
10423: PPUSH
10424: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10428: LD_EXP 47
10432: PPUSH
10433: LD_STRING D11-Bur-3
10435: PPUSH
10436: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10440: LD_EXP 16
10444: PPUSH
10445: LD_STRING D11-JMM-4
10447: PPUSH
10448: CALL_OW 88
// if ar_base_spotted then
10452: LD_EXP 8
10456: IFFALSE 10472
// Say ( Burlak , D12-Bur-1 ) else
10458: LD_EXP 47
10462: PPUSH
10463: LD_STRING D12-Bur-1
10465: PPUSH
10466: CALL_OW 88
10470: GO 10511
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10472: LD_INT 7
10474: PPUSH
10475: LD_INT 3
10477: PPUSH
10478: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10482: LD_INT 127
10484: PPUSH
10485: LD_INT 45
10487: PPUSH
10488: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10492: LD_EXP 47
10496: PPUSH
10497: LD_STRING D12-Bur-1a
10499: PPUSH
10500: CALL_OW 88
// dwait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10511: LD_EXP 47
10515: PPUSH
10516: LD_STRING D12-Bur-1b
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10523: LD_EXP 16
10527: PPUSH
10528: LD_STRING D12-JMM-1
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10535: LD_EXP 47
10539: PPUSH
10540: LD_STRING D12-Bur-2
10542: PPUSH
10543: CALL_OW 88
// if Roth then
10547: LD_EXP 17
10551: IFFALSE 10567
// Say ( Roth , D12-Roth-2 ) else
10553: LD_EXP 17
10557: PPUSH
10558: LD_STRING D12-Roth-2
10560: PPUSH
10561: CALL_OW 88
10565: GO 10579
// Say ( SciRu , D12-RSci1-2 ) ;
10567: CALL 13222 0 0
10571: PPUSH
10572: LD_STRING D12-RSci1-2
10574: PPUSH
10575: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10579: LD_EXP 16
10583: PPUSH
10584: LD_STRING D12-JMM-2
10586: PPUSH
10587: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10591: LD_EXP 47
10595: PPUSH
10596: LD_STRING D12-Bur-3
10598: PPUSH
10599: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10603: LD_EXP 16
10607: PPUSH
10608: LD_STRING D12-JMM-3
10610: PPUSH
10611: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10615: LD_EXP 47
10619: PPUSH
10620: LD_STRING D12-Bur-4
10622: PPUSH
10623: CALL_OW 88
// case Query ( QBase ) of 1 :
10627: LD_STRING QBase
10629: PPUSH
10630: CALL_OW 97
10634: PUSH
10635: LD_INT 1
10637: DOUBLE
10638: EQUAL
10639: IFTRUE 10643
10641: GO 10761
10643: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10644: LD_EXP 16
10648: PPUSH
10649: LD_STRING D13a-JMM-1
10651: PPUSH
10652: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10656: LD_EXP 47
10660: PPUSH
10661: LD_STRING D13a-Bur-1
10663: PPUSH
10664: CALL_OW 88
// if Roth then
10668: LD_EXP 17
10672: IFFALSE 10688
// Say ( Roth , D13a-Roth-1 ) else
10674: LD_EXP 17
10678: PPUSH
10679: LD_STRING D13a-Roth-1
10681: PPUSH
10682: CALL_OW 88
10686: GO 10700
// Say ( SciRu , D13a-RSci1-1 ) ;
10688: CALL 13222 0 0
10692: PPUSH
10693: LD_STRING D13a-RSci1-1
10695: PPUSH
10696: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10700: LD_EXP 16
10704: PPUSH
10705: LD_STRING D13a-JMM-2
10707: PPUSH
10708: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10712: LD_STRING QBaseAgain
10714: PPUSH
10715: CALL_OW 97
10719: PUSH
10720: LD_INT 1
10722: DOUBLE
10723: EQUAL
10724: IFTRUE 10728
10726: GO 10739
10728: POP
// selected_option := 2 ; 2 :
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_INT 2
10736: ST_TO_ADDR
10737: GO 10759
10739: LD_INT 2
10741: DOUBLE
10742: EQUAL
10743: IFTRUE 10747
10745: GO 10758
10747: POP
// selected_option := 3 ; end ;
10748: LD_ADDR_VAR 0 2
10752: PUSH
10753: LD_INT 3
10755: ST_TO_ADDR
10756: GO 10759
10758: POP
// end ; 2 :
10759: GO 10800
10761: LD_INT 2
10763: DOUBLE
10764: EQUAL
10765: IFTRUE 10769
10767: GO 10780
10769: POP
// selected_option := 2 ; 3 :
10770: LD_ADDR_VAR 0 2
10774: PUSH
10775: LD_INT 2
10777: ST_TO_ADDR
10778: GO 10800
10780: LD_INT 3
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 10799
10788: POP
// selected_option := 3 ; end ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 3
10796: ST_TO_ADDR
10797: GO 10800
10799: POP
// if selected_option = 2 then
10800: LD_VAR 0 2
10804: PUSH
10805: LD_INT 2
10807: EQUAL
10808: IFFALSE 10902
// begin Say ( JMM , D13b-JMM-1 ) ;
10810: LD_EXP 16
10814: PPUSH
10815: LD_STRING D13b-JMM-1
10817: PPUSH
10818: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10822: LD_EXP 47
10826: PPUSH
10827: LD_STRING D13b-Bur-1
10829: PPUSH
10830: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10834: LD_EXP 16
10838: PPUSH
10839: LD_STRING D13b-JMM-2
10841: PPUSH
10842: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10846: LD_EXP 56
10850: PPUSH
10851: LD_STRING D13b-Abd-2
10853: PPUSH
10854: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10858: LD_EXP 16
10862: PPUSH
10863: LD_STRING D13b-JMM-3
10865: PPUSH
10866: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10870: LD_EXP 56
10874: PPUSH
10875: LD_STRING D13b-Abd-3
10877: PPUSH
10878: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10882: LD_EXP 16
10886: PPUSH
10887: LD_STRING D13b-JMM-4
10889: PPUSH
10890: CALL_OW 88
// ar_active_attack := true ;
10894: LD_ADDR_EXP 9
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// end ; if selected_option = 3 then
10902: LD_VAR 0 2
10906: PUSH
10907: LD_INT 3
10909: EQUAL
10910: IFFALSE 10936
// begin Say ( JMM , D13c-JMM-1 ) ;
10912: LD_EXP 16
10916: PPUSH
10917: LD_STRING D13c-JMM-1
10919: PPUSH
10920: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10924: LD_EXP 47
10928: PPUSH
10929: LD_STRING D13c-Bur-1
10931: PPUSH
10932: CALL_OW 88
// end ; DialogueOff ;
10936: CALL_OW 7
// if not ar_active_attack then
10940: LD_EXP 9
10944: NOT
10945: IFFALSE 10962
// begin wait ( 6 6$00 ) ;
10947: LD_INT 12600
10949: PPUSH
10950: CALL_OW 67
// ar_active_attack := true ;
10954: LD_ADDR_EXP 9
10958: PUSH
10959: LD_INT 1
10961: ST_TO_ADDR
// end ; end ;
10962: PPOPN 2
10964: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 305
10974: PUSH
10975: LD_EXP 47
10979: PPUSH
10980: CALL_OW 255
10984: PUSH
10985: LD_INT 7
10987: EQUAL
10988: AND
10989: IFFALSE 11185
10991: GO 10993
10993: DISABLE
10994: LD_INT 0
10996: PPUSH
// begin wait ( 4 4$40 ) ;
10997: LD_INT 9800
10999: PPUSH
11000: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// until not ru_attackers ;
11011: LD_EXP 53
11015: NOT
11016: IFFALSE 11004
// PrepareGnyevko ;
11018: CALL 2250 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11022: LD_EXP 49
11026: PPUSH
11027: LD_INT 124
11029: PPUSH
11030: LD_INT 118
11032: PPUSH
11033: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11037: LD_EXP 49
11041: PPUSH
11042: CALL_OW 200
// time := 0 0$00 ;
11046: LD_ADDR_VAR 0 1
11050: PUSH
11051: LD_INT 0
11053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// time := time + 0 0$1 ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: LD_INT 35
11073: PLUS
11074: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11075: LD_EXP 49
11079: PPUSH
11080: LD_INT 124
11082: PPUSH
11083: LD_INT 118
11085: PPUSH
11086: CALL_OW 307
11090: PUSH
11091: LD_VAR 0 1
11095: PUSH
11096: LD_INT 1050
11098: GREATEREQUAL
11099: OR
11100: IFFALSE 11054
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11102: LD_EXP 49
11106: PPUSH
11107: LD_STRING DBelkov-Gny-1
11109: PPUSH
11110: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11114: LD_EXP 47
11118: PPUSH
11119: LD_STRING DBelkov-Bur-1a
11121: PPUSH
11122: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11126: LD_INT 35
11128: PPUSH
11129: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11133: LD_EXP 49
11137: PPUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 7
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_EXP 49
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 296
11167: PUSH
11168: LD_INT 8
11170: LESS
11171: IFFALSE 11126
// SetSide ( Gnyevko , 7 ) ;
11173: LD_EXP 49
11177: PPUSH
11178: LD_INT 7
11180: PPUSH
11181: CALL_OW 235
// end ;
11185: PPOPN 1
11187: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11188: LD_EXP 47
11192: PPUSH
11193: CALL_OW 255
11197: PUSH
11198: LD_INT 7
11200: EQUAL
11201: IFFALSE 11211
11203: GO 11205
11205: DISABLE
// begin enable ;
11206: ENABLE
// PrepareAmericanAttack ;
11207: CALL 6853 0 0
// end ;
11211: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11212: LD_INT 22
11214: PUSH
11215: LD_INT 1
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: IFFALSE 11410
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// begin while true do
11235: LD_INT 1
11237: IFFALSE 11294
// begin wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11246: LD_ADDR_VAR 0 2
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PPUSH
11261: CALL_OW 69
11265: PPUSH
11266: LD_EXP 16
11270: PPUSH
11271: CALL_OW 74
11275: ST_TO_ADDR
// if See ( 7 , tmp ) then
11276: LD_INT 7
11278: PPUSH
11279: LD_VAR 0 2
11283: PPUSH
11284: CALL_OW 292
11288: IFFALSE 11292
// break ;
11290: GO 11294
// end ;
11292: GO 11235
// DialogueOn ;
11294: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 250
11316: PPUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PPUSH
11327: LD_INT 7
11329: PPUSH
11330: LD_INT 8
11332: PPUSH
11333: CALL_OW 330
// if Denis then
11337: LD_EXP 22
11341: IFFALSE 11355
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11343: LD_EXP 22
11347: PPUSH
11348: LD_STRING DAmerAttack-Pet-1
11350: PPUSH
11351: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11355: LD_EXP 16
11359: PPUSH
11360: LD_STRING DAmerAttack-JMM-1
11362: PPUSH
11363: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11367: LD_EXP 47
11371: PPUSH
11372: LD_STRING DStop-Bur-1
11374: PPUSH
11375: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 250
11388: PPUSH
11389: LD_VAR 0 2
11393: PPUSH
11394: CALL_OW 251
11398: PPUSH
11399: LD_INT 7
11401: PPUSH
11402: CALL_OW 331
// DialogueOff ;
11406: CALL_OW 7
// end ;
11410: PPOPN 2
11412: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11413: LD_INT 22
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 21
11425: PUSH
11426: LD_INT 1
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PPUSH
11437: CALL_OW 69
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11487
11447: GO 11449
11449: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11450: LD_STRING M5a
11452: PPUSH
11453: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11457: LD_EXP 16
11461: PPUSH
11462: LD_STRING D8-JMM-1
11464: PPUSH
11465: CALL_OW 88
// if Gossudarov then
11469: LD_EXP 33
11473: IFFALSE 11487
// Say ( Gossudarov , D8-Gos-1 ) ;
11475: LD_EXP 33
11479: PPUSH
11480: LD_STRING D8-Gos-1
11482: PPUSH
11483: CALL_OW 88
// end ;
11487: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11488: LD_INT 22
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 21
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: PUSH
11517: LD_INT 0
11519: EQUAL
11520: IFFALSE 11570
11522: GO 11524
11524: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11525: LD_STRING M4c
11527: PPUSH
11528: CALL_OW 337
// if Roth then
11532: LD_EXP 17
11536: IFFALSE 11552
// Say ( Roth , DStop-Roth-1 ) else
11538: LD_EXP 17
11542: PPUSH
11543: LD_STRING DStop-Roth-1
11545: PPUSH
11546: CALL_OW 88
11550: GO 11570
// if Gossudarov then
11552: LD_EXP 33
11556: IFFALSE 11570
// Say ( Gossudarov , D8-Gos-1a ) ;
11558: LD_EXP 33
11562: PPUSH
11563: LD_STRING D8-Gos-1a
11565: PPUSH
11566: CALL_OW 88
// end ;
11570: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11571: LD_INT 7
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 14878 0 3
11584: PUSH
11585: LD_INT 0
11587: EQUAL
11588: PUSH
11589: LD_INT 7
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 1
11597: PPUSH
11598: CALL 14878 0 3
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: AND
11607: IFFALSE 11619
11609: GO 11611
11611: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11612: LD_STRING M1a
11614: PPUSH
11615: CALL_OW 337
// end ;
11619: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11620: LD_INT 22
11622: PUSH
11623: LD_INT 2
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PPUSH
11644: CALL_OW 69
11648: PUSH
11649: LD_INT 0
11651: EQUAL
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 3
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: AND
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 1
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PPUSH
11697: CALL_OW 69
11701: PUSH
11702: LD_INT 0
11704: EQUAL
11705: AND
11706: PUSH
11707: LD_INT 7
11709: PPUSH
11710: LD_INT 1
11712: PPUSH
11713: LD_INT 1
11715: PPUSH
11716: CALL 14878 0 3
11720: PUSH
11721: LD_INT 0
11723: EQUAL
11724: AND
11725: PUSH
11726: LD_INT 7
11728: PPUSH
11729: LD_INT 3
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL 14878 0 3
11739: PUSH
11740: LD_INT 0
11742: EQUAL
11743: AND
11744: IFFALSE 13219
11746: GO 11748
11748: DISABLE
11749: LD_INT 0
11751: PPUSH
11752: PPUSH
11753: PPUSH
11754: PPUSH
11755: PPUSH
11756: PPUSH
// begin m1 := false ;
11757: LD_ADDR_VAR 0 4
11761: PUSH
11762: LD_INT 0
11764: ST_TO_ADDR
// m2 := false ;
11765: LD_ADDR_VAR 0 5
11769: PUSH
11770: LD_INT 0
11772: ST_TO_ADDR
// m3 := false ;
11773: LD_ADDR_VAR 0 6
11777: PUSH
11778: LD_INT 0
11780: ST_TO_ADDR
// if tick < 40 40$00 then
11781: LD_OWVAR 1
11785: PUSH
11786: LD_INT 84000
11788: LESS
11789: IFFALSE 11798
// SetAchievement ( ACH_ASPEED_17 ) ;
11791: LD_STRING ACH_ASPEED_17
11793: PPUSH
11794: CALL_OW 543
// wait ( 0 0$5 ) ;
11798: LD_INT 175
11800: PPUSH
11801: CALL_OW 67
// if not masha_killed then
11805: LD_EXP 10
11809: NOT
11810: IFFALSE 11832
// begin m1 := true ;
11812: LD_ADDR_VAR 0 4
11816: PUSH
11817: LD_INT 1
11819: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11820: LD_STRING Masha
11822: PPUSH
11823: LD_INT 1
11825: PPUSH
11826: CALL_OW 101
// end else
11830: GO 11843
// AddMedal ( Masha , - 1 ) ;
11832: LD_STRING Masha
11834: PPUSH
11835: LD_INT 1
11837: NEG
11838: PPUSH
11839: CALL_OW 101
// if abdul_escaped then
11843: LD_EXP 13
11847: IFFALSE 11862
// AddMedal ( Abdul , - 1 ) else
11849: LD_STRING Abdul
11851: PPUSH
11852: LD_INT 1
11854: NEG
11855: PPUSH
11856: CALL_OW 101
11860: GO 11880
// begin m2 := true ;
11862: LD_ADDR_VAR 0 5
11866: PUSH
11867: LD_INT 1
11869: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11870: LD_STRING Abdul
11872: PPUSH
11873: LD_INT 1
11875: PPUSH
11876: CALL_OW 101
// end ; if loss_counter = 0 then
11880: LD_EXP 14
11884: PUSH
11885: LD_INT 0
11887: EQUAL
11888: IFFALSE 11910
// begin m3 := true ;
11890: LD_ADDR_VAR 0 6
11894: PUSH
11895: LD_INT 1
11897: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11898: LD_STRING People
11900: PPUSH
11901: LD_INT 2
11903: PPUSH
11904: CALL_OW 101
// end else
11908: GO 11972
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11910: LD_EXP 14
11914: PUSH
11915: LD_INT 3
11917: PUSH
11918: LD_INT 2
11920: PUSH
11921: LD_INT 2
11923: PUSH
11924: LD_INT 1
11926: PUSH
11927: EMPTY
11928: LIST
11929: LIST
11930: LIST
11931: LIST
11932: PUSH
11933: LD_OWVAR 67
11937: ARRAY
11938: LESSEQUAL
11939: IFFALSE 11961
// begin AddMedal ( People , 1 ) ;
11941: LD_STRING People
11943: PPUSH
11944: LD_INT 1
11946: PPUSH
11947: CALL_OW 101
// m3 := true ;
11951: LD_ADDR_VAR 0 6
11955: PUSH
11956: LD_INT 1
11958: ST_TO_ADDR
// end else
11959: GO 11972
// AddMedal ( People , - 1 ) ;
11961: LD_STRING People
11963: PPUSH
11964: LD_INT 1
11966: NEG
11967: PPUSH
11968: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11972: LD_OWVAR 67
11976: PUSH
11977: LD_INT 3
11979: GREATEREQUAL
11980: PUSH
11981: LD_VAR 0 4
11985: AND
11986: PUSH
11987: LD_VAR 0 5
11991: AND
11992: PUSH
11993: LD_VAR 0 6
11997: AND
11998: IFFALSE 12010
// SetAchievementEX ( ACH_AMER , 17 ) ;
12000: LD_STRING ACH_AMER
12002: PPUSH
12003: LD_INT 17
12005: PPUSH
12006: CALL_OW 564
// GiveMedals ( MAIN ) ;
12010: LD_STRING MAIN
12012: PPUSH
12013: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12017: LD_ADDR_VAR 0 2
12021: PUSH
12022: LD_INT 22
12024: PUSH
12025: LD_INT 7
12027: PUSH
12028: EMPTY
12029: LIST
12030: LIST
12031: PUSH
12032: LD_INT 2
12034: PUSH
12035: LD_INT 25
12037: PUSH
12038: LD_INT 1
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: PUSH
12045: LD_INT 25
12047: PUSH
12048: LD_INT 2
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: PUSH
12055: LD_INT 25
12057: PUSH
12058: LD_INT 3
12060: PUSH
12061: EMPTY
12062: LIST
12063: LIST
12064: PUSH
12065: LD_INT 25
12067: PUSH
12068: LD_INT 4
12070: PUSH
12071: EMPTY
12072: LIST
12073: LIST
12074: PUSH
12075: LD_INT 25
12077: PUSH
12078: LD_INT 5
12080: PUSH
12081: EMPTY
12082: LIST
12083: LIST
12084: PUSH
12085: LD_INT 25
12087: PUSH
12088: LD_INT 8
12090: PUSH
12091: EMPTY
12092: LIST
12093: LIST
12094: PUSH
12095: LD_INT 25
12097: PUSH
12098: LD_INT 9
12100: PUSH
12101: EMPTY
12102: LIST
12103: LIST
12104: PUSH
12105: EMPTY
12106: LIST
12107: LIST
12108: LIST
12109: LIST
12110: LIST
12111: LIST
12112: LIST
12113: LIST
12114: PUSH
12115: EMPTY
12116: LIST
12117: LIST
12118: PPUSH
12119: CALL_OW 69
12123: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12124: LD_VAR 0 2
12128: PPUSH
12129: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12133: LD_ADDR_VAR 0 3
12137: PUSH
12138: LD_EXP 16
12142: PUSH
12143: LD_EXP 17
12147: PUSH
12148: LD_EXP 18
12152: PUSH
12153: LD_EXP 19
12157: PUSH
12158: LD_EXP 20
12162: PUSH
12163: LD_EXP 21
12167: PUSH
12168: LD_EXP 22
12172: PUSH
12173: LD_EXP 23
12177: PUSH
12178: LD_EXP 24
12182: PUSH
12183: LD_EXP 25
12187: PUSH
12188: LD_EXP 26
12192: PUSH
12193: LD_EXP 27
12197: PUSH
12198: LD_EXP 28
12202: PUSH
12203: LD_EXP 29
12207: PUSH
12208: LD_EXP 30
12212: PUSH
12213: LD_EXP 31
12217: PUSH
12218: LD_EXP 32
12222: PUSH
12223: LD_EXP 33
12227: PUSH
12228: LD_EXP 34
12232: PUSH
12233: LD_EXP 35
12237: PUSH
12238: LD_EXP 37
12242: PUSH
12243: LD_EXP 38
12247: PUSH
12248: LD_EXP 39
12252: PUSH
12253: LD_EXP 40
12257: PUSH
12258: LD_EXP 41
12262: PUSH
12263: LD_EXP 42
12267: PUSH
12268: LD_EXP 43
12272: PUSH
12273: LD_EXP 44
12277: PUSH
12278: LD_EXP 45
12282: PUSH
12283: LD_EXP 46
12287: PUSH
12288: LD_EXP 47
12292: PUSH
12293: LD_EXP 48
12297: PUSH
12298: LD_EXP 49
12302: PUSH
12303: EMPTY
12304: LIST
12305: LIST
12306: LIST
12307: LIST
12308: LIST
12309: LIST
12310: LIST
12311: LIST
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: ST_TO_ADDR
// if tmp diff tmp2 then
12338: LD_VAR 0 2
12342: PUSH
12343: LD_VAR 0 3
12347: DIFF
12348: IFFALSE 12368
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12350: LD_VAR 0 2
12354: PUSH
12355: LD_VAR 0 3
12359: DIFF
12360: PPUSH
12361: LD_STRING 13a_others
12363: PPUSH
12364: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12368: LD_EXP 16
12372: PPUSH
12373: LD_STRING 13a_JMM
12375: PPUSH
12376: CALL_OW 38
// if Titov then
12380: LD_EXP 35
12384: IFFALSE 12398
// SaveCharacters ( Titov , 13a_Titov ) ;
12386: LD_EXP 35
12390: PPUSH
12391: LD_STRING 13a_Titov
12393: PPUSH
12394: CALL_OW 38
// if Dolgov then
12398: LD_EXP 37
12402: IFFALSE 12416
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12404: LD_EXP 37
12408: PPUSH
12409: LD_STRING 13a_Dolgov
12411: PPUSH
12412: CALL_OW 38
// if Petrosyan then
12416: LD_EXP 38
12420: IFFALSE 12434
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12422: LD_EXP 38
12426: PPUSH
12427: LD_STRING 13a_Petrosyan
12429: PPUSH
12430: CALL_OW 38
// if Scholtze then
12434: LD_EXP 39
12438: IFFALSE 12452
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12440: LD_EXP 39
12444: PPUSH
12445: LD_STRING 13a_Scholtze
12447: PPUSH
12448: CALL_OW 38
// if Oblukov then
12452: LD_EXP 40
12456: IFFALSE 12470
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12458: LD_EXP 40
12462: PPUSH
12463: LD_STRING 13a_Oblukov
12465: PPUSH
12466: CALL_OW 38
// if Kapitsova then
12470: LD_EXP 41
12474: IFFALSE 12488
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12476: LD_EXP 41
12480: PPUSH
12481: LD_STRING 13a_Kapitsova
12483: PPUSH
12484: CALL_OW 38
// if Lipshchin then
12488: LD_EXP 42
12492: IFFALSE 12506
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12494: LD_EXP 42
12498: PPUSH
12499: LD_STRING 13a_Lipshchin
12501: PPUSH
12502: CALL_OW 38
// if Petrovova then
12506: LD_EXP 43
12510: IFFALSE 12524
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12512: LD_EXP 43
12516: PPUSH
12517: LD_STRING 13a_Petrovova
12519: PPUSH
12520: CALL_OW 38
// if Kovalyuk then
12524: LD_EXP 44
12528: IFFALSE 12542
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12530: LD_EXP 44
12534: PPUSH
12535: LD_STRING 13a_Kovalyuk
12537: PPUSH
12538: CALL_OW 38
// if Kuzmov then
12542: LD_EXP 45
12546: IFFALSE 12560
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12548: LD_EXP 45
12552: PPUSH
12553: LD_STRING 13a_Kuzmov
12555: PPUSH
12556: CALL_OW 38
// if Karamazov then
12560: LD_EXP 46
12564: IFFALSE 12578
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12566: LD_EXP 46
12570: PPUSH
12571: LD_STRING 13a_Karamazov
12573: PPUSH
12574: CALL_OW 38
// if Burlak then
12578: LD_EXP 47
12582: IFFALSE 12596
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12584: LD_EXP 47
12588: PPUSH
12589: LD_STRING 13a_Burlak
12591: PPUSH
12592: CALL_OW 38
// if Belkov then
12596: LD_EXP 48
12600: IFFALSE 12614
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12602: LD_EXP 48
12606: PPUSH
12607: LD_STRING 13a_Belkov
12609: PPUSH
12610: CALL_OW 38
// if Gnyevko then
12614: LD_EXP 49
12618: IFFALSE 12632
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12620: LD_EXP 49
12624: PPUSH
12625: LD_STRING 13a_Gnyevko
12627: PPUSH
12628: CALL_OW 38
// if Lisa then
12632: LD_EXP 18
12636: IFFALSE 12650
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12638: LD_EXP 18
12642: PPUSH
12643: LD_STRING 13a_Lisa
12645: PPUSH
12646: CALL_OW 38
// if Donaldson then
12650: LD_EXP 19
12654: IFFALSE 12668
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12656: LD_EXP 19
12660: PPUSH
12661: LD_STRING 13a_Donaldson
12663: PPUSH
12664: CALL_OW 38
// if Bobby then
12668: LD_EXP 20
12672: IFFALSE 12686
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12674: LD_EXP 20
12678: PPUSH
12679: LD_STRING 13a_Bobby
12681: PPUSH
12682: CALL_OW 38
// if Cyrus then
12686: LD_EXP 21
12690: IFFALSE 12704
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12692: LD_EXP 21
12696: PPUSH
12697: LD_STRING 13a_Cyrus
12699: PPUSH
12700: CALL_OW 38
// if Denis then
12704: LD_EXP 22
12708: IFFALSE 12722
// SaveCharacters ( Denis , 13a_Denis ) ;
12710: LD_EXP 22
12714: PPUSH
12715: LD_STRING 13a_Denis
12717: PPUSH
12718: CALL_OW 38
// if Brown then
12722: LD_EXP 23
12726: IFFALSE 12740
// SaveCharacters ( Brown , 13a_Brown ) ;
12728: LD_EXP 23
12732: PPUSH
12733: LD_STRING 13a_Brown
12735: PPUSH
12736: CALL_OW 38
// if Gladstone then
12740: LD_EXP 24
12744: IFFALSE 12758
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12746: LD_EXP 24
12750: PPUSH
12751: LD_STRING 13a_Gladstone
12753: PPUSH
12754: CALL_OW 38
// if Houten then
12758: LD_EXP 25
12762: IFFALSE 12776
// SaveCharacters ( Houten , 13a_Houten ) ;
12764: LD_EXP 25
12768: PPUSH
12769: LD_STRING 13a_Houten
12771: PPUSH
12772: CALL_OW 38
// if Cornel then
12776: LD_EXP 26
12780: IFFALSE 12794
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12782: LD_EXP 26
12786: PPUSH
12787: LD_STRING 13a_Cornel
12789: PPUSH
12790: CALL_OW 38
// if Gary then
12794: LD_EXP 27
12798: IFFALSE 12812
// SaveCharacters ( Gary , 13a_Gary ) ;
12800: LD_EXP 27
12804: PPUSH
12805: LD_STRING 13a_Gary
12807: PPUSH
12808: CALL_OW 38
// if Frank then
12812: LD_EXP 28
12816: IFFALSE 12830
// SaveCharacters ( Frank , 13a_Frank ) ;
12818: LD_EXP 28
12822: PPUSH
12823: LD_STRING 13a_Frank
12825: PPUSH
12826: CALL_OW 38
// if Kikuchi then
12830: LD_EXP 29
12834: IFFALSE 12848
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12836: LD_EXP 29
12840: PPUSH
12841: LD_STRING 13a_Kikuchi
12843: PPUSH
12844: CALL_OW 38
// if Simms then
12848: LD_EXP 30
12852: IFFALSE 12866
// SaveCharacters ( Simms , 13a_Simms ) ;
12854: LD_EXP 30
12858: PPUSH
12859: LD_STRING 13a_Simms
12861: PPUSH
12862: CALL_OW 38
// if Joan then
12866: LD_EXP 31
12870: IFFALSE 12884
// SaveCharacters ( Joan , 13a_Joan ) ;
12872: LD_EXP 31
12876: PPUSH
12877: LD_STRING 13a_Joan
12879: PPUSH
12880: CALL_OW 38
// if DeltaDoctor then
12884: LD_EXP 32
12888: IFFALSE 12902
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12890: LD_EXP 32
12894: PPUSH
12895: LD_STRING 13a_DeltaDoctor
12897: PPUSH
12898: CALL_OW 38
// if Gossudarov then
12902: LD_EXP 33
12906: IFFALSE 12920
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12908: LD_EXP 33
12912: PPUSH
12913: LD_STRING 13a_Gossudarov
12915: PPUSH
12916: CALL_OW 38
// if Kirilenkova then
12920: LD_EXP 34
12924: IFFALSE 12938
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12926: LD_EXP 34
12930: PPUSH
12931: LD_STRING 13a_Kirilenkova
12933: PPUSH
12934: CALL_OW 38
// if Roth then
12938: LD_EXP 17
12942: IFFALSE 12956
// SaveCharacters ( Roth , 13a_Roth ) ;
12944: LD_EXP 17
12948: PPUSH
12949: LD_STRING 13a_Roth
12951: PPUSH
12952: CALL_OW 38
// if Masha then
12956: LD_EXP 50
12960: IFFALSE 13015
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12962: LD_EXP 50
12966: PPUSH
12967: CALL_OW 265
12971: PUSH
12972: LD_EXP 50
12976: PPUSH
12977: CALL_OW 262
12981: PUSH
12982: LD_EXP 50
12986: PPUSH
12987: CALL_OW 263
12991: PUSH
12992: LD_EXP 50
12996: PPUSH
12997: CALL_OW 264
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PPUSH
13008: LD_STRING 13a_Masha
13010: PPUSH
13011: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13015: LD_ADDR_VAR 0 2
13019: PUSH
13020: LD_INT 21
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PPUSH
13030: CALL_OW 69
13034: ST_TO_ADDR
// tmp2 := [ ] ;
13035: LD_ADDR_VAR 0 3
13039: PUSH
13040: EMPTY
13041: ST_TO_ADDR
// if tmp then
13042: LD_VAR 0 2
13046: IFFALSE 13197
// for i in tmp do
13048: LD_ADDR_VAR 0 1
13052: PUSH
13053: LD_VAR 0 2
13057: PUSH
13058: FOR_IN
13059: IFFALSE 13195
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: LD_VAR 0 3
13070: PUSH
13071: LD_VAR 0 1
13075: PPUSH
13076: CALL_OW 255
13080: PUSH
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 248
13090: PUSH
13091: LD_VAR 0 1
13095: PPUSH
13096: CALL_OW 266
13100: PUSH
13101: LD_VAR 0 1
13105: PPUSH
13106: CALL_OW 250
13110: PUSH
13111: LD_VAR 0 1
13115: PPUSH
13116: CALL_OW 251
13120: PUSH
13121: LD_VAR 0 1
13125: PPUSH
13126: CALL_OW 254
13130: PUSH
13131: LD_VAR 0 1
13135: PPUSH
13136: CALL_OW 267
13140: PUSH
13141: LD_VAR 0 1
13145: PPUSH
13146: LD_INT 1
13148: PPUSH
13149: CALL_OW 268
13153: PUSH
13154: LD_VAR 0 1
13158: PPUSH
13159: LD_INT 2
13161: PPUSH
13162: CALL_OW 268
13166: PUSH
13167: LD_VAR 0 1
13171: PPUSH
13172: CALL_OW 269
13176: PUSH
13177: EMPTY
13178: LIST
13179: LIST
13180: LIST
13181: LIST
13182: LIST
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: PUSH
13189: EMPTY
13190: LIST
13191: ADD
13192: ST_TO_ADDR
13193: GO 13058
13195: POP
13196: POP
// if tmp2 then
13197: LD_VAR 0 3
13201: IFFALSE 13215
// SaveVariable ( tmp2 , 13a_buildings ) ;
13203: LD_VAR 0 3
13207: PPUSH
13208: LD_STRING 13a_buildings
13210: PPUSH
13211: CALL_OW 39
// YouWin ;
13215: CALL_OW 103
// end ;
13219: PPOPN 6
13221: END
// export function SciRu ; var tmp , t ; begin
13222: LD_INT 0
13224: PPUSH
13225: PPUSH
13226: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13227: LD_ADDR_VAR 0 3
13231: PUSH
13232: LD_EXP 33
13236: PUSH
13237: LD_EXP 47
13241: PUSH
13242: LD_EXP 35
13246: PUSH
13247: LD_EXP 48
13251: PUSH
13252: LD_EXP 49
13256: PUSH
13257: LD_EXP 38
13261: PUSH
13262: LD_EXP 39
13266: PUSH
13267: LD_EXP 37
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: LIST
13279: LIST
13280: LIST
13281: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13282: LD_ADDR_VAR 0 2
13286: PUSH
13287: LD_INT 22
13289: PUSH
13290: LD_INT 7
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 23
13299: PUSH
13300: LD_INT 3
13302: PUSH
13303: EMPTY
13304: LIST
13305: LIST
13306: PUSH
13307: LD_INT 25
13309: PUSH
13310: LD_INT 4
13312: PUSH
13313: EMPTY
13314: LIST
13315: LIST
13316: PUSH
13317: LD_INT 26
13319: PUSH
13320: LD_INT 1
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PPUSH
13333: CALL_OW 69
13337: PUSH
13338: LD_VAR 0 3
13342: DIFF
13343: ST_TO_ADDR
// if tmp then
13344: LD_VAR 0 2
13348: IFFALSE 13364
// result := tmp [ 1 ] ;
13350: LD_ADDR_VAR 0 1
13354: PUSH
13355: LD_VAR 0 2
13359: PUSH
13360: LD_INT 1
13362: ARRAY
13363: ST_TO_ADDR
// end ;
13364: LD_VAR 0 1
13368: RET
// export function SolRu ; var tmp , t ; begin
13369: LD_INT 0
13371: PPUSH
13372: PPUSH
13373: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13374: LD_ADDR_VAR 0 3
13378: PUSH
13379: LD_EXP 33
13383: PUSH
13384: LD_EXP 47
13388: PUSH
13389: LD_EXP 35
13393: PUSH
13394: LD_EXP 48
13398: PUSH
13399: LD_EXP 49
13403: PUSH
13404: LD_EXP 38
13408: PUSH
13409: LD_EXP 39
13413: PUSH
13414: LD_EXP 37
13418: PUSH
13419: EMPTY
13420: LIST
13421: LIST
13422: LIST
13423: LIST
13424: LIST
13425: LIST
13426: LIST
13427: LIST
13428: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13429: LD_ADDR_VAR 0 2
13433: PUSH
13434: LD_INT 22
13436: PUSH
13437: LD_INT 7
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PUSH
13444: LD_INT 23
13446: PUSH
13447: LD_INT 3
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 25
13456: PUSH
13457: LD_INT 1
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 26
13466: PUSH
13467: LD_INT 1
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: LIST
13479: PPUSH
13480: CALL_OW 69
13484: PUSH
13485: LD_VAR 0 3
13489: DIFF
13490: ST_TO_ADDR
// if tmp then
13491: LD_VAR 0 2
13495: IFFALSE 13511
// result := tmp [ 1 ] ;
13497: LD_ADDR_VAR 0 1
13501: PUSH
13502: LD_VAR 0 2
13506: PUSH
13507: LD_INT 1
13509: ARRAY
13510: ST_TO_ADDR
// end ; end_of_file
13511: LD_VAR 0 1
13515: RET
// export function CustomEvent ( event ) ; begin
13516: LD_INT 0
13518: PPUSH
// end ;
13519: LD_VAR 0 2
13523: RET
// on UnitDestroyed ( un ) do var i , side ;
13524: LD_INT 0
13526: PPUSH
13527: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13528: LD_VAR 0 1
13532: PUSH
13533: LD_INT 22
13535: PUSH
13536: LD_INT 7
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: LD_INT 2
13545: PUSH
13546: LD_INT 25
13548: PUSH
13549: LD_INT 1
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: PUSH
13556: LD_INT 25
13558: PUSH
13559: LD_INT 2
13561: PUSH
13562: EMPTY
13563: LIST
13564: LIST
13565: PUSH
13566: LD_INT 25
13568: PUSH
13569: LD_INT 3
13571: PUSH
13572: EMPTY
13573: LIST
13574: LIST
13575: PUSH
13576: LD_INT 25
13578: PUSH
13579: LD_INT 4
13581: PUSH
13582: EMPTY
13583: LIST
13584: LIST
13585: PUSH
13586: LD_INT 25
13588: PUSH
13589: LD_INT 5
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 25
13598: PUSH
13599: LD_INT 8
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 25
13608: PUSH
13609: LD_INT 9
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: PUSH
13616: EMPTY
13617: LIST
13618: LIST
13619: LIST
13620: LIST
13621: LIST
13622: LIST
13623: LIST
13624: LIST
13625: PUSH
13626: EMPTY
13627: LIST
13628: LIST
13629: PPUSH
13630: CALL_OW 69
13634: IN
13635: IFFALSE 13651
// loss_counter := loss_counter + 1 ;
13637: LD_ADDR_EXP 14
13641: PUSH
13642: LD_EXP 14
13646: PUSH
13647: LD_INT 1
13649: PLUS
13650: ST_TO_ADDR
// if un = Abdul then
13651: LD_VAR 0 1
13655: PUSH
13656: LD_EXP 56
13660: EQUAL
13661: IFFALSE 13671
// abdul_escaped := false ;
13663: LD_ADDR_EXP 13
13667: PUSH
13668: LD_INT 0
13670: ST_TO_ADDR
// if un in ru_attackers then
13671: LD_VAR 0 1
13675: PUSH
13676: LD_EXP 53
13680: IN
13681: IFFALSE 13699
// ru_attackers := ru_attackers diff un ;
13683: LD_ADDR_EXP 53
13687: PUSH
13688: LD_EXP 53
13692: PUSH
13693: LD_VAR 0 1
13697: DIFF
13698: ST_TO_ADDR
// if un in ar_attackers then
13699: LD_VAR 0 1
13703: PUSH
13704: LD_EXP 11
13708: IN
13709: IFFALSE 13727
// ar_attackers := ar_attackers diff un ;
13711: LD_ADDR_EXP 11
13715: PUSH
13716: LD_EXP 11
13720: PUSH
13721: LD_VAR 0 1
13725: DIFF
13726: ST_TO_ADDR
// if un = JMM then
13727: LD_VAR 0 1
13731: PUSH
13732: LD_EXP 16
13736: EQUAL
13737: IFFALSE 13748
// begin YouLost ( JMM ) ;
13739: LD_STRING JMM
13741: PPUSH
13742: CALL_OW 104
// exit ;
13746: GO 13845
// end ; if un = Burlak then
13748: LD_VAR 0 1
13752: PUSH
13753: LD_EXP 47
13757: EQUAL
13758: IFFALSE 13769
// begin YouLost ( Burlak ) ;
13760: LD_STRING Burlak
13762: PPUSH
13763: CALL_OW 104
// exit ;
13767: GO 13845
// end ; if un = freedom then
13769: LD_VAR 0 1
13773: PUSH
13774: LD_EXP 3
13778: EQUAL
13779: IFFALSE 13790
// begin YouLost ( Destroyed ) ;
13781: LD_STRING Destroyed
13783: PPUSH
13784: CALL_OW 104
// exit ;
13788: GO 13845
// end ; if un = Masha then
13790: LD_VAR 0 1
13794: PUSH
13795: LD_EXP 50
13799: EQUAL
13800: IFFALSE 13817
// begin ChangeMissionObjectives ( M4b ) ;
13802: LD_STRING M4b
13804: PPUSH
13805: CALL_OW 337
// masha_killed := true ;
13809: LD_ADDR_EXP 10
13813: PUSH
13814: LD_INT 1
13816: ST_TO_ADDR
// end ; if un = Mastodont then
13817: LD_VAR 0 1
13821: PUSH
13822: LD_EXP 57
13826: EQUAL
13827: IFFALSE 13836
// ChangeMissionObjectives ( M4a ) ;
13829: LD_STRING M4a
13831: PPUSH
13832: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13836: LD_VAR 0 1
13840: PPUSH
13841: CALL 82546 0 1
// end ;
13845: PPOPN 3
13847: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13848: LD_VAR 0 1
13852: PPUSH
13853: LD_VAR 0 2
13857: PPUSH
13858: CALL 84880 0 2
// end ;
13862: PPOPN 2
13864: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13865: LD_VAR 0 1
13869: PPUSH
13870: CALL 83948 0 1
// end ;
13874: PPOPN 1
13876: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13877: LD_VAR 0 1
13881: PUSH
13882: LD_INT 22
13884: PUSH
13885: LD_INT 7
13887: PUSH
13888: EMPTY
13889: LIST
13890: LIST
13891: PUSH
13892: LD_INT 30
13894: PUSH
13895: LD_INT 0
13897: PUSH
13898: EMPTY
13899: LIST
13900: LIST
13901: PUSH
13902: EMPTY
13903: LIST
13904: LIST
13905: PPUSH
13906: CALL_OW 69
13910: IN
13911: IFFALSE 13950
// begin SetBName ( building , freedom ) ;
13913: LD_VAR 0 1
13917: PPUSH
13918: LD_STRING freedom
13920: PPUSH
13921: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13925: LD_INT 0
13927: PPUSH
13928: LD_INT 7
13930: PPUSH
13931: LD_INT 0
13933: PPUSH
13934: CALL_OW 324
// freedom := building ;
13938: LD_ADDR_EXP 3
13942: PUSH
13943: LD_VAR 0 1
13947: ST_TO_ADDR
// exit ;
13948: GO 14016
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13950: LD_VAR 0 1
13954: PUSH
13955: LD_INT 22
13957: PUSH
13958: LD_INT 7
13960: PUSH
13961: EMPTY
13962: LIST
13963: LIST
13964: PUSH
13965: LD_INT 23
13967: PUSH
13968: LD_INT 3
13970: PUSH
13971: EMPTY
13972: LIST
13973: LIST
13974: PUSH
13975: LD_INT 30
13977: PUSH
13978: LD_INT 6
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: EMPTY
13986: LIST
13987: LIST
13988: LIST
13989: PPUSH
13990: CALL_OW 69
13994: IN
13995: IFFALSE 14007
// begin ru_lab_builded := true ;
13997: LD_ADDR_EXP 5
14001: PUSH
14002: LD_INT 1
14004: ST_TO_ADDR
// exit ;
14005: GO 14016
// end ; MCE_BuildingComplete ( building ) ;
14007: LD_VAR 0 1
14011: PPUSH
14012: CALL 84189 0 1
// end ;
14016: PPOPN 1
14018: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14019: LD_VAR 0 1
14023: PPUSH
14024: LD_VAR 0 2
14028: PPUSH
14029: CALL 82242 0 2
// end ;
14033: PPOPN 2
14035: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14036: LD_VAR 0 1
14040: PPUSH
14041: LD_VAR 0 2
14045: PPUSH
14046: LD_VAR 0 3
14050: PPUSH
14051: LD_VAR 0 4
14055: PPUSH
14056: LD_VAR 0 5
14060: PPUSH
14061: CALL 81862 0 5
// end ;
14065: PPOPN 5
14067: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
14068: LD_VAR 0 1
14072: PPUSH
14073: LD_VAR 0 2
14077: PPUSH
14078: CALL 81443 0 2
// end ;
14082: PPOPN 2
14084: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14085: LD_VAR 0 1
14089: PPUSH
14090: CALL_OW 263
14094: PUSH
14095: LD_INT 3
14097: EQUAL
14098: PUSH
14099: LD_VAR 0 2
14103: PPUSH
14104: CALL_OW 263
14108: PUSH
14109: LD_INT 3
14111: EQUAL
14112: OR
14113: IFFALSE 14129
// hack_counter := hack_counter + 1 ;
14115: LD_ADDR_EXP 15
14119: PUSH
14120: LD_EXP 15
14124: PUSH
14125: LD_INT 1
14127: PLUS
14128: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14129: LD_VAR 0 1
14133: PPUSH
14134: LD_VAR 0 2
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: LD_VAR 0 4
14148: PPUSH
14149: CALL 81281 0 4
// end ;
14153: PPOPN 4
14155: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14156: LD_VAR 0 1
14160: PPUSH
14161: LD_VAR 0 2
14165: PPUSH
14166: LD_VAR 0 3
14170: PPUSH
14171: CALL 81056 0 3
// end ;
14175: PPOPN 3
14177: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14178: LD_VAR 0 1
14182: PPUSH
14183: LD_VAR 0 2
14187: PPUSH
14188: CALL 80941 0 2
// end ;
14192: PPOPN 2
14194: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14195: LD_VAR 0 1
14199: PPUSH
14200: LD_VAR 0 2
14204: PPUSH
14205: CALL 85175 0 2
// end ;
14209: PPOPN 2
14211: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14212: LD_VAR 0 1
14216: PPUSH
14217: LD_VAR 0 2
14221: PPUSH
14222: LD_VAR 0 3
14226: PPUSH
14227: LD_VAR 0 4
14231: PPUSH
14232: CALL 85391 0 4
// end ;
14236: PPOPN 4
14238: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14239: LD_VAR 0 1
14243: PPUSH
14244: LD_VAR 0 2
14248: PPUSH
14249: CALL 80750 0 2
// end ;
14253: PPOPN 2
14255: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14256: LD_VAR 0 1
14260: PPUSH
14261: CALL 100135 0 1
// end ; end_of_file
14265: PPOPN 1
14267: END
// every 0 0$30 do var cr , time ;
14268: GO 14270
14270: DISABLE
14271: LD_INT 0
14273: PPUSH
14274: PPUSH
// begin time := 0 0$20 ;
14275: LD_ADDR_VAR 0 2
14279: PUSH
14280: LD_INT 700
14282: ST_TO_ADDR
// while game do
14283: LD_EXP 2
14287: IFFALSE 14390
// begin wait ( time ) ;
14289: LD_VAR 0 2
14293: PPUSH
14294: CALL_OW 67
// if tick > 2 2$00 then
14298: LD_OWVAR 1
14302: PUSH
14303: LD_INT 4200
14305: GREATER
14306: IFFALSE 14343
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14308: LD_ADDR_VAR 0 2
14312: PUSH
14313: LD_VAR 0 2
14317: PUSH
14318: LD_INT 140
14320: PUSH
14321: LD_INT 140
14323: PUSH
14324: LD_INT 210
14326: PUSH
14327: LD_INT 280
14329: PUSH
14330: EMPTY
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: PUSH
14336: LD_OWVAR 67
14340: ARRAY
14341: PLUS
14342: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14343: LD_INT 1
14345: PPUSH
14346: LD_INT 5
14348: PPUSH
14349: CALL_OW 12
14353: PPUSH
14354: LD_INT 70
14356: PPUSH
14357: LD_INT 49
14359: PPUSH
14360: LD_INT 25
14362: PPUSH
14363: LD_INT 1
14365: PPUSH
14366: CALL_OW 56
// if time > 3 3$00 then
14370: LD_VAR 0 2
14374: PUSH
14375: LD_INT 6300
14377: GREATER
14378: IFFALSE 14388
// time := 0 0$30 ;
14380: LD_ADDR_VAR 0 2
14384: PUSH
14385: LD_INT 1050
14387: ST_TO_ADDR
// end ;
14388: GO 14283
// end ;
14390: PPOPN 2
14392: END
// every 0 0$30 do var cr , time ;
14393: GO 14395
14395: DISABLE
14396: LD_INT 0
14398: PPUSH
14399: PPUSH
// begin time := 0 0$20 ;
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: LD_INT 700
14407: ST_TO_ADDR
// while game do
14408: LD_EXP 2
14412: IFFALSE 14505
// begin wait ( time ) ;
14414: LD_VAR 0 2
14418: PPUSH
14419: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14423: LD_ADDR_VAR 0 2
14427: PUSH
14428: LD_VAR 0 2
14432: PUSH
14433: LD_INT 140
14435: PUSH
14436: LD_INT 175
14438: PUSH
14439: LD_INT 210
14441: PUSH
14442: LD_INT 280
14444: PUSH
14445: EMPTY
14446: LIST
14447: LIST
14448: LIST
14449: LIST
14450: PUSH
14451: LD_OWVAR 67
14455: ARRAY
14456: PLUS
14457: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14458: LD_INT 3
14460: PPUSH
14461: LD_INT 5
14463: PPUSH
14464: CALL_OW 12
14468: PPUSH
14469: LD_INT 26
14471: PPUSH
14472: LD_INT 9
14474: PPUSH
14475: LD_INT 30
14477: PPUSH
14478: LD_INT 1
14480: PPUSH
14481: CALL_OW 56
// if time > 3 3$00 then
14485: LD_VAR 0 2
14489: PUSH
14490: LD_INT 6300
14492: GREATER
14493: IFFALSE 14503
// time := 0 0$20 ;
14495: LD_ADDR_VAR 0 2
14499: PUSH
14500: LD_INT 700
14502: ST_TO_ADDR
// end ;
14503: GO 14408
// end ;
14505: PPOPN 2
14507: END
// every 0 0$30 do var cr , time ;
14508: GO 14510
14510: DISABLE
14511: LD_INT 0
14513: PPUSH
14514: PPUSH
// begin time := 0 0$20 ;
14515: LD_ADDR_VAR 0 2
14519: PUSH
14520: LD_INT 700
14522: ST_TO_ADDR
// while game do
14523: LD_EXP 2
14527: IFFALSE 14656
// begin wait ( time ) ;
14529: LD_VAR 0 2
14533: PPUSH
14534: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14538: LD_ADDR_VAR 0 2
14542: PUSH
14543: LD_VAR 0 2
14547: PUSH
14548: LD_INT 175
14550: PUSH
14551: LD_INT 210
14553: PUSH
14554: LD_INT 280
14556: PUSH
14557: LD_INT 350
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: PUSH
14566: LD_OWVAR 67
14570: ARRAY
14571: PLUS
14572: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14573: LD_INT 1
14575: PPUSH
14576: LD_INT 5
14578: PPUSH
14579: CALL_OW 12
14583: PPUSH
14584: LD_INT 179
14586: PPUSH
14587: LD_INT 101
14589: PPUSH
14590: LD_INT 20
14592: PPUSH
14593: LD_INT 1
14595: PPUSH
14596: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14600: LD_INT 350
14602: PPUSH
14603: LD_INT 525
14605: PPUSH
14606: CALL_OW 12
14610: PPUSH
14611: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14615: LD_INT 1
14617: PPUSH
14618: LD_INT 5
14620: PPUSH
14621: CALL_OW 12
14625: PPUSH
14626: LD_INT 9
14628: PPUSH
14629: LD_INT 1
14631: PPUSH
14632: CALL_OW 55
// if time > 4 4$00 then
14636: LD_VAR 0 2
14640: PUSH
14641: LD_INT 8400
14643: GREATER
14644: IFFALSE 14654
// time := 0 0$30 ;
14646: LD_ADDR_VAR 0 2
14650: PUSH
14651: LD_INT 1050
14653: ST_TO_ADDR
// end ;
14654: GO 14523
// end ;
14656: PPOPN 2
14658: END
// every 0 0$30 do var cr , time ;
14659: GO 14661
14661: DISABLE
14662: LD_INT 0
14664: PPUSH
14665: PPUSH
// begin time := 0 0$10 ;
14666: LD_ADDR_VAR 0 2
14670: PUSH
14671: LD_INT 350
14673: ST_TO_ADDR
// while game do
14674: LD_EXP 2
14678: IFFALSE 14812
// begin wait ( time ) ;
14680: LD_VAR 0 2
14684: PPUSH
14685: CALL_OW 67
// time := time + 0 0$10 ;
14689: LD_ADDR_VAR 0 2
14693: PUSH
14694: LD_VAR 0 2
14698: PUSH
14699: LD_INT 350
14701: PLUS
14702: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14703: LD_INT 1
14705: PPUSH
14706: LD_INT 5
14708: PPUSH
14709: CALL_OW 12
14713: PPUSH
14714: LD_INT 11
14716: PPUSH
14717: LD_INT 1
14719: PPUSH
14720: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14724: LD_ADDR_VAR 0 1
14728: PUSH
14729: LD_INT 1
14731: PPUSH
14732: LD_INT 3
14734: PPUSH
14735: CALL_OW 12
14739: ST_TO_ADDR
// if cr = 1 then
14740: LD_VAR 0 1
14744: PUSH
14745: LD_INT 1
14747: EQUAL
14748: IFFALSE 14792
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14750: LD_INT 700
14752: PPUSH
14753: LD_INT 1575
14755: PPUSH
14756: CALL_OW 12
14760: PPUSH
14761: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14765: LD_INT 1
14767: PPUSH
14768: LD_INT 5
14770: PPUSH
14771: CALL_OW 12
14775: PPUSH
14776: LD_INT 34
14778: PPUSH
14779: LD_INT 50
14781: PPUSH
14782: LD_INT 7
14784: PPUSH
14785: LD_INT 1
14787: PPUSH
14788: CALL_OW 56
// end ; if time > 4 4$00 then
14792: LD_VAR 0 2
14796: PUSH
14797: LD_INT 8400
14799: GREATER
14800: IFFALSE 14810
// time := 0 0$40 ;
14802: LD_ADDR_VAR 0 2
14806: PUSH
14807: LD_INT 1400
14809: ST_TO_ADDR
// end ;
14810: GO 14674
// end ; end_of_file
14812: PPOPN 2
14814: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14815: LD_INT 0
14817: PPUSH
14818: PPUSH
// if exist_mode then
14819: LD_VAR 0 2
14823: IFFALSE 14848
// unit := CreateCharacter ( prefix & ident ) else
14825: LD_ADDR_VAR 0 5
14829: PUSH
14830: LD_VAR 0 3
14834: PUSH
14835: LD_VAR 0 1
14839: STR
14840: PPUSH
14841: CALL_OW 34
14845: ST_TO_ADDR
14846: GO 14863
// unit := NewCharacter ( ident ) ;
14848: LD_ADDR_VAR 0 5
14852: PUSH
14853: LD_VAR 0 1
14857: PPUSH
14858: CALL_OW 25
14862: ST_TO_ADDR
// result := unit ;
14863: LD_ADDR_VAR 0 4
14867: PUSH
14868: LD_VAR 0 5
14872: ST_TO_ADDR
// end ;
14873: LD_VAR 0 4
14877: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14878: LD_INT 0
14880: PPUSH
14881: PPUSH
// if not side or not nation then
14882: LD_VAR 0 1
14886: NOT
14887: PUSH
14888: LD_VAR 0 2
14892: NOT
14893: OR
14894: IFFALSE 14898
// exit ;
14896: GO 15666
// case nation of nation_american :
14898: LD_VAR 0 2
14902: PUSH
14903: LD_INT 1
14905: DOUBLE
14906: EQUAL
14907: IFTRUE 14911
14909: GO 15125
14911: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14912: LD_ADDR_VAR 0 4
14916: PUSH
14917: LD_INT 35
14919: PUSH
14920: LD_INT 45
14922: PUSH
14923: LD_INT 46
14925: PUSH
14926: LD_INT 47
14928: PUSH
14929: LD_INT 82
14931: PUSH
14932: LD_INT 83
14934: PUSH
14935: LD_INT 84
14937: PUSH
14938: LD_INT 85
14940: PUSH
14941: LD_INT 86
14943: PUSH
14944: LD_INT 1
14946: PUSH
14947: LD_INT 2
14949: PUSH
14950: LD_INT 6
14952: PUSH
14953: LD_INT 15
14955: PUSH
14956: LD_INT 16
14958: PUSH
14959: LD_INT 7
14961: PUSH
14962: LD_INT 12
14964: PUSH
14965: LD_INT 13
14967: PUSH
14968: LD_INT 10
14970: PUSH
14971: LD_INT 14
14973: PUSH
14974: LD_INT 20
14976: PUSH
14977: LD_INT 21
14979: PUSH
14980: LD_INT 22
14982: PUSH
14983: LD_INT 25
14985: PUSH
14986: LD_INT 32
14988: PUSH
14989: LD_INT 27
14991: PUSH
14992: LD_INT 36
14994: PUSH
14995: LD_INT 69
14997: PUSH
14998: LD_INT 39
15000: PUSH
15001: LD_INT 34
15003: PUSH
15004: LD_INT 40
15006: PUSH
15007: LD_INT 48
15009: PUSH
15010: LD_INT 49
15012: PUSH
15013: LD_INT 50
15015: PUSH
15016: LD_INT 51
15018: PUSH
15019: LD_INT 52
15021: PUSH
15022: LD_INT 53
15024: PUSH
15025: LD_INT 54
15027: PUSH
15028: LD_INT 55
15030: PUSH
15031: LD_INT 56
15033: PUSH
15034: LD_INT 57
15036: PUSH
15037: LD_INT 58
15039: PUSH
15040: LD_INT 59
15042: PUSH
15043: LD_INT 60
15045: PUSH
15046: LD_INT 61
15048: PUSH
15049: LD_INT 62
15051: PUSH
15052: LD_INT 80
15054: PUSH
15055: LD_INT 82
15057: PUSH
15058: LD_INT 83
15060: PUSH
15061: LD_INT 84
15063: PUSH
15064: LD_INT 85
15066: PUSH
15067: LD_INT 86
15069: PUSH
15070: EMPTY
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: LIST
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: LIST
15122: ST_TO_ADDR
15123: GO 15590
15125: LD_INT 2
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15359
15133: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15134: LD_ADDR_VAR 0 4
15138: PUSH
15139: LD_INT 35
15141: PUSH
15142: LD_INT 45
15144: PUSH
15145: LD_INT 46
15147: PUSH
15148: LD_INT 47
15150: PUSH
15151: LD_INT 82
15153: PUSH
15154: LD_INT 83
15156: PUSH
15157: LD_INT 84
15159: PUSH
15160: LD_INT 85
15162: PUSH
15163: LD_INT 87
15165: PUSH
15166: LD_INT 70
15168: PUSH
15169: LD_INT 1
15171: PUSH
15172: LD_INT 11
15174: PUSH
15175: LD_INT 3
15177: PUSH
15178: LD_INT 4
15180: PUSH
15181: LD_INT 5
15183: PUSH
15184: LD_INT 6
15186: PUSH
15187: LD_INT 15
15189: PUSH
15190: LD_INT 18
15192: PUSH
15193: LD_INT 7
15195: PUSH
15196: LD_INT 17
15198: PUSH
15199: LD_INT 8
15201: PUSH
15202: LD_INT 20
15204: PUSH
15205: LD_INT 21
15207: PUSH
15208: LD_INT 22
15210: PUSH
15211: LD_INT 72
15213: PUSH
15214: LD_INT 26
15216: PUSH
15217: LD_INT 69
15219: PUSH
15220: LD_INT 39
15222: PUSH
15223: LD_INT 40
15225: PUSH
15226: LD_INT 41
15228: PUSH
15229: LD_INT 42
15231: PUSH
15232: LD_INT 43
15234: PUSH
15235: LD_INT 48
15237: PUSH
15238: LD_INT 49
15240: PUSH
15241: LD_INT 50
15243: PUSH
15244: LD_INT 51
15246: PUSH
15247: LD_INT 52
15249: PUSH
15250: LD_INT 53
15252: PUSH
15253: LD_INT 54
15255: PUSH
15256: LD_INT 55
15258: PUSH
15259: LD_INT 56
15261: PUSH
15262: LD_INT 60
15264: PUSH
15265: LD_INT 61
15267: PUSH
15268: LD_INT 62
15270: PUSH
15271: LD_INT 66
15273: PUSH
15274: LD_INT 67
15276: PUSH
15277: LD_INT 68
15279: PUSH
15280: LD_INT 81
15282: PUSH
15283: LD_INT 82
15285: PUSH
15286: LD_INT 83
15288: PUSH
15289: LD_INT 84
15291: PUSH
15292: LD_INT 85
15294: PUSH
15295: LD_INT 87
15297: PUSH
15298: LD_INT 88
15300: PUSH
15301: EMPTY
15302: LIST
15303: LIST
15304: LIST
15305: LIST
15306: LIST
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: LIST
15314: LIST
15315: LIST
15316: LIST
15317: LIST
15318: LIST
15319: LIST
15320: LIST
15321: LIST
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: LIST
15327: LIST
15328: LIST
15329: LIST
15330: LIST
15331: LIST
15332: LIST
15333: LIST
15334: LIST
15335: LIST
15336: LIST
15337: LIST
15338: LIST
15339: LIST
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: LIST
15345: LIST
15346: LIST
15347: LIST
15348: LIST
15349: LIST
15350: LIST
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: ST_TO_ADDR
15357: GO 15590
15359: LD_INT 3
15361: DOUBLE
15362: EQUAL
15363: IFTRUE 15367
15365: GO 15589
15367: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15368: LD_ADDR_VAR 0 4
15372: PUSH
15373: LD_INT 46
15375: PUSH
15376: LD_INT 47
15378: PUSH
15379: LD_INT 1
15381: PUSH
15382: LD_INT 2
15384: PUSH
15385: LD_INT 82
15387: PUSH
15388: LD_INT 83
15390: PUSH
15391: LD_INT 84
15393: PUSH
15394: LD_INT 85
15396: PUSH
15397: LD_INT 86
15399: PUSH
15400: LD_INT 11
15402: PUSH
15403: LD_INT 9
15405: PUSH
15406: LD_INT 20
15408: PUSH
15409: LD_INT 19
15411: PUSH
15412: LD_INT 21
15414: PUSH
15415: LD_INT 24
15417: PUSH
15418: LD_INT 22
15420: PUSH
15421: LD_INT 25
15423: PUSH
15424: LD_INT 28
15426: PUSH
15427: LD_INT 29
15429: PUSH
15430: LD_INT 30
15432: PUSH
15433: LD_INT 31
15435: PUSH
15436: LD_INT 37
15438: PUSH
15439: LD_INT 38
15441: PUSH
15442: LD_INT 32
15444: PUSH
15445: LD_INT 27
15447: PUSH
15448: LD_INT 33
15450: PUSH
15451: LD_INT 69
15453: PUSH
15454: LD_INT 39
15456: PUSH
15457: LD_INT 34
15459: PUSH
15460: LD_INT 40
15462: PUSH
15463: LD_INT 71
15465: PUSH
15466: LD_INT 23
15468: PUSH
15469: LD_INT 44
15471: PUSH
15472: LD_INT 48
15474: PUSH
15475: LD_INT 49
15477: PUSH
15478: LD_INT 50
15480: PUSH
15481: LD_INT 51
15483: PUSH
15484: LD_INT 52
15486: PUSH
15487: LD_INT 53
15489: PUSH
15490: LD_INT 54
15492: PUSH
15493: LD_INT 55
15495: PUSH
15496: LD_INT 56
15498: PUSH
15499: LD_INT 57
15501: PUSH
15502: LD_INT 58
15504: PUSH
15505: LD_INT 59
15507: PUSH
15508: LD_INT 63
15510: PUSH
15511: LD_INT 64
15513: PUSH
15514: LD_INT 65
15516: PUSH
15517: LD_INT 82
15519: PUSH
15520: LD_INT 83
15522: PUSH
15523: LD_INT 84
15525: PUSH
15526: LD_INT 85
15528: PUSH
15529: LD_INT 86
15531: PUSH
15532: EMPTY
15533: LIST
15534: LIST
15535: LIST
15536: LIST
15537: LIST
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: LIST
15543: LIST
15544: LIST
15545: LIST
15546: LIST
15547: LIST
15548: LIST
15549: LIST
15550: LIST
15551: LIST
15552: LIST
15553: LIST
15554: LIST
15555: LIST
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: LIST
15561: LIST
15562: LIST
15563: LIST
15564: LIST
15565: LIST
15566: LIST
15567: LIST
15568: LIST
15569: LIST
15570: LIST
15571: LIST
15572: LIST
15573: LIST
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: LIST
15579: LIST
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: ST_TO_ADDR
15587: GO 15590
15589: POP
// if state > - 1 and state < 3 then
15590: LD_VAR 0 3
15594: PUSH
15595: LD_INT 1
15597: NEG
15598: GREATER
15599: PUSH
15600: LD_VAR 0 3
15604: PUSH
15605: LD_INT 3
15607: LESS
15608: AND
15609: IFFALSE 15666
// for i in result do
15611: LD_ADDR_VAR 0 5
15615: PUSH
15616: LD_VAR 0 4
15620: PUSH
15621: FOR_IN
15622: IFFALSE 15664
// if GetTech ( i , side ) <> state then
15624: LD_VAR 0 5
15628: PPUSH
15629: LD_VAR 0 1
15633: PPUSH
15634: CALL_OW 321
15638: PUSH
15639: LD_VAR 0 3
15643: NONEQUAL
15644: IFFALSE 15662
// result := result diff i ;
15646: LD_ADDR_VAR 0 4
15650: PUSH
15651: LD_VAR 0 4
15655: PUSH
15656: LD_VAR 0 5
15660: DIFF
15661: ST_TO_ADDR
15662: GO 15621
15664: POP
15665: POP
// end ;
15666: LD_VAR 0 4
15670: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15671: LD_INT 0
15673: PPUSH
15674: PPUSH
15675: PPUSH
// result := true ;
15676: LD_ADDR_VAR 0 3
15680: PUSH
15681: LD_INT 1
15683: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15684: LD_ADDR_VAR 0 5
15688: PUSH
15689: LD_VAR 0 2
15693: PPUSH
15694: CALL_OW 480
15698: ST_TO_ADDR
// if not tmp then
15699: LD_VAR 0 5
15703: NOT
15704: IFFALSE 15708
// exit ;
15706: GO 15757
// for i in tmp do
15708: LD_ADDR_VAR 0 4
15712: PUSH
15713: LD_VAR 0 5
15717: PUSH
15718: FOR_IN
15719: IFFALSE 15755
// if GetTech ( i , side ) <> state_researched then
15721: LD_VAR 0 4
15725: PPUSH
15726: LD_VAR 0 1
15730: PPUSH
15731: CALL_OW 321
15735: PUSH
15736: LD_INT 2
15738: NONEQUAL
15739: IFFALSE 15753
// begin result := false ;
15741: LD_ADDR_VAR 0 3
15745: PUSH
15746: LD_INT 0
15748: ST_TO_ADDR
// exit ;
15749: POP
15750: POP
15751: GO 15757
// end ;
15753: GO 15718
15755: POP
15756: POP
// end ;
15757: LD_VAR 0 3
15761: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15762: LD_INT 0
15764: PPUSH
15765: PPUSH
15766: PPUSH
15767: PPUSH
15768: PPUSH
15769: PPUSH
15770: PPUSH
15771: PPUSH
15772: PPUSH
15773: PPUSH
15774: PPUSH
15775: PPUSH
15776: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15777: LD_VAR 0 1
15781: NOT
15782: PUSH
15783: LD_VAR 0 1
15787: PPUSH
15788: CALL_OW 257
15792: PUSH
15793: LD_INT 9
15795: NONEQUAL
15796: OR
15797: IFFALSE 15801
// exit ;
15799: GO 16374
// side := GetSide ( unit ) ;
15801: LD_ADDR_VAR 0 9
15805: PUSH
15806: LD_VAR 0 1
15810: PPUSH
15811: CALL_OW 255
15815: ST_TO_ADDR
// tech_space := tech_spacanom ;
15816: LD_ADDR_VAR 0 12
15820: PUSH
15821: LD_INT 29
15823: ST_TO_ADDR
// tech_time := tech_taurad ;
15824: LD_ADDR_VAR 0 13
15828: PUSH
15829: LD_INT 28
15831: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15832: LD_ADDR_VAR 0 11
15836: PUSH
15837: LD_VAR 0 1
15841: PPUSH
15842: CALL_OW 310
15846: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15847: LD_VAR 0 11
15851: PPUSH
15852: CALL_OW 247
15856: PUSH
15857: LD_INT 2
15859: EQUAL
15860: IFFALSE 15864
// exit ;
15862: GO 16374
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15864: LD_ADDR_VAR 0 8
15868: PUSH
15869: LD_INT 81
15871: PUSH
15872: LD_VAR 0 9
15876: PUSH
15877: EMPTY
15878: LIST
15879: LIST
15880: PUSH
15881: LD_INT 3
15883: PUSH
15884: LD_INT 21
15886: PUSH
15887: LD_INT 3
15889: PUSH
15890: EMPTY
15891: LIST
15892: LIST
15893: PUSH
15894: EMPTY
15895: LIST
15896: LIST
15897: PUSH
15898: EMPTY
15899: LIST
15900: LIST
15901: PPUSH
15902: CALL_OW 69
15906: ST_TO_ADDR
// if not tmp then
15907: LD_VAR 0 8
15911: NOT
15912: IFFALSE 15916
// exit ;
15914: GO 16374
// if in_unit then
15916: LD_VAR 0 11
15920: IFFALSE 15944
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15922: LD_ADDR_VAR 0 10
15926: PUSH
15927: LD_VAR 0 8
15931: PPUSH
15932: LD_VAR 0 11
15936: PPUSH
15937: CALL_OW 74
15941: ST_TO_ADDR
15942: GO 15964
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15944: LD_ADDR_VAR 0 10
15948: PUSH
15949: LD_VAR 0 8
15953: PPUSH
15954: LD_VAR 0 1
15958: PPUSH
15959: CALL_OW 74
15963: ST_TO_ADDR
// if not enemy then
15964: LD_VAR 0 10
15968: NOT
15969: IFFALSE 15973
// exit ;
15971: GO 16374
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15973: LD_VAR 0 11
15977: PUSH
15978: LD_VAR 0 11
15982: PPUSH
15983: LD_VAR 0 10
15987: PPUSH
15988: CALL_OW 296
15992: PUSH
15993: LD_INT 13
15995: GREATER
15996: AND
15997: PUSH
15998: LD_VAR 0 1
16002: PPUSH
16003: LD_VAR 0 10
16007: PPUSH
16008: CALL_OW 296
16012: PUSH
16013: LD_INT 12
16015: GREATER
16016: OR
16017: IFFALSE 16021
// exit ;
16019: GO 16374
// missile := [ 1 ] ;
16021: LD_ADDR_VAR 0 14
16025: PUSH
16026: LD_INT 1
16028: PUSH
16029: EMPTY
16030: LIST
16031: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16032: LD_VAR 0 9
16036: PPUSH
16037: LD_VAR 0 12
16041: PPUSH
16042: CALL_OW 325
16046: IFFALSE 16075
// missile := Insert ( missile , missile + 1 , 2 ) ;
16048: LD_ADDR_VAR 0 14
16052: PUSH
16053: LD_VAR 0 14
16057: PPUSH
16058: LD_VAR 0 14
16062: PUSH
16063: LD_INT 1
16065: PLUS
16066: PPUSH
16067: LD_INT 2
16069: PPUSH
16070: CALL_OW 2
16074: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16075: LD_VAR 0 9
16079: PPUSH
16080: LD_VAR 0 13
16084: PPUSH
16085: CALL_OW 325
16089: PUSH
16090: LD_VAR 0 10
16094: PPUSH
16095: CALL_OW 255
16099: PPUSH
16100: LD_VAR 0 13
16104: PPUSH
16105: CALL_OW 325
16109: NOT
16110: AND
16111: IFFALSE 16140
// missile := Insert ( missile , missile + 1 , 3 ) ;
16113: LD_ADDR_VAR 0 14
16117: PUSH
16118: LD_VAR 0 14
16122: PPUSH
16123: LD_VAR 0 14
16127: PUSH
16128: LD_INT 1
16130: PLUS
16131: PPUSH
16132: LD_INT 3
16134: PPUSH
16135: CALL_OW 2
16139: ST_TO_ADDR
// if missile < 2 then
16140: LD_VAR 0 14
16144: PUSH
16145: LD_INT 2
16147: LESS
16148: IFFALSE 16152
// exit ;
16150: GO 16374
// x := GetX ( enemy ) ;
16152: LD_ADDR_VAR 0 4
16156: PUSH
16157: LD_VAR 0 10
16161: PPUSH
16162: CALL_OW 250
16166: ST_TO_ADDR
// y := GetY ( enemy ) ;
16167: LD_ADDR_VAR 0 5
16171: PUSH
16172: LD_VAR 0 10
16176: PPUSH
16177: CALL_OW 251
16181: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16182: LD_ADDR_VAR 0 6
16186: PUSH
16187: LD_VAR 0 4
16191: PUSH
16192: LD_INT 1
16194: NEG
16195: PPUSH
16196: LD_INT 1
16198: PPUSH
16199: CALL_OW 12
16203: PLUS
16204: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16205: LD_ADDR_VAR 0 7
16209: PUSH
16210: LD_VAR 0 5
16214: PUSH
16215: LD_INT 1
16217: NEG
16218: PPUSH
16219: LD_INT 1
16221: PPUSH
16222: CALL_OW 12
16226: PLUS
16227: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16228: LD_VAR 0 6
16232: PPUSH
16233: LD_VAR 0 7
16237: PPUSH
16238: CALL_OW 488
16242: NOT
16243: IFFALSE 16265
// begin _x := x ;
16245: LD_ADDR_VAR 0 6
16249: PUSH
16250: LD_VAR 0 4
16254: ST_TO_ADDR
// _y := y ;
16255: LD_ADDR_VAR 0 7
16259: PUSH
16260: LD_VAR 0 5
16264: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16265: LD_ADDR_VAR 0 3
16269: PUSH
16270: LD_INT 1
16272: PPUSH
16273: LD_VAR 0 14
16277: PPUSH
16278: CALL_OW 12
16282: ST_TO_ADDR
// case i of 1 :
16283: LD_VAR 0 3
16287: PUSH
16288: LD_INT 1
16290: DOUBLE
16291: EQUAL
16292: IFTRUE 16296
16294: GO 16313
16296: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16297: LD_VAR 0 1
16301: PPUSH
16302: LD_VAR 0 10
16306: PPUSH
16307: CALL_OW 115
16311: GO 16374
16313: LD_INT 2
16315: DOUBLE
16316: EQUAL
16317: IFTRUE 16321
16319: GO 16343
16321: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16322: LD_VAR 0 1
16326: PPUSH
16327: LD_VAR 0 6
16331: PPUSH
16332: LD_VAR 0 7
16336: PPUSH
16337: CALL_OW 153
16341: GO 16374
16343: LD_INT 3
16345: DOUBLE
16346: EQUAL
16347: IFTRUE 16351
16349: GO 16373
16351: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16352: LD_VAR 0 1
16356: PPUSH
16357: LD_VAR 0 6
16361: PPUSH
16362: LD_VAR 0 7
16366: PPUSH
16367: CALL_OW 154
16371: GO 16374
16373: POP
// end ;
16374: LD_VAR 0 2
16378: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16379: LD_INT 0
16381: PPUSH
16382: PPUSH
16383: PPUSH
16384: PPUSH
16385: PPUSH
16386: PPUSH
// if not unit or not building then
16387: LD_VAR 0 1
16391: NOT
16392: PUSH
16393: LD_VAR 0 2
16397: NOT
16398: OR
16399: IFFALSE 16403
// exit ;
16401: GO 16561
// x := GetX ( building ) ;
16403: LD_ADDR_VAR 0 5
16407: PUSH
16408: LD_VAR 0 2
16412: PPUSH
16413: CALL_OW 250
16417: ST_TO_ADDR
// y := GetY ( building ) ;
16418: LD_ADDR_VAR 0 6
16422: PUSH
16423: LD_VAR 0 2
16427: PPUSH
16428: CALL_OW 251
16432: ST_TO_ADDR
// for i = 0 to 5 do
16433: LD_ADDR_VAR 0 4
16437: PUSH
16438: DOUBLE
16439: LD_INT 0
16441: DEC
16442: ST_TO_ADDR
16443: LD_INT 5
16445: PUSH
16446: FOR_TO
16447: IFFALSE 16559
// begin _x := ShiftX ( x , i , 3 ) ;
16449: LD_ADDR_VAR 0 7
16453: PUSH
16454: LD_VAR 0 5
16458: PPUSH
16459: LD_VAR 0 4
16463: PPUSH
16464: LD_INT 3
16466: PPUSH
16467: CALL_OW 272
16471: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16472: LD_ADDR_VAR 0 8
16476: PUSH
16477: LD_VAR 0 6
16481: PPUSH
16482: LD_VAR 0 4
16486: PPUSH
16487: LD_INT 3
16489: PPUSH
16490: CALL_OW 273
16494: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16495: LD_VAR 0 7
16499: PPUSH
16500: LD_VAR 0 8
16504: PPUSH
16505: CALL_OW 488
16509: NOT
16510: IFFALSE 16514
// continue ;
16512: GO 16446
// if HexInfo ( _x , _y ) = 0 then
16514: LD_VAR 0 7
16518: PPUSH
16519: LD_VAR 0 8
16523: PPUSH
16524: CALL_OW 428
16528: PUSH
16529: LD_INT 0
16531: EQUAL
16532: IFFALSE 16557
// begin ComMoveXY ( unit , _x , _y ) ;
16534: LD_VAR 0 1
16538: PPUSH
16539: LD_VAR 0 7
16543: PPUSH
16544: LD_VAR 0 8
16548: PPUSH
16549: CALL_OW 111
// exit ;
16553: POP
16554: POP
16555: GO 16561
// end ; end ;
16557: GO 16446
16559: POP
16560: POP
// end ;
16561: LD_VAR 0 3
16565: RET
// export function ScanBase ( side , base_area ) ; begin
16566: LD_INT 0
16568: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16569: LD_ADDR_VAR 0 3
16573: PUSH
16574: LD_VAR 0 2
16578: PPUSH
16579: LD_INT 81
16581: PUSH
16582: LD_VAR 0 1
16586: PUSH
16587: EMPTY
16588: LIST
16589: LIST
16590: PPUSH
16591: CALL_OW 70
16595: ST_TO_ADDR
// end ;
16596: LD_VAR 0 3
16600: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16601: LD_INT 0
16603: PPUSH
16604: PPUSH
16605: PPUSH
16606: PPUSH
// result := false ;
16607: LD_ADDR_VAR 0 2
16611: PUSH
16612: LD_INT 0
16614: ST_TO_ADDR
// side := GetSide ( unit ) ;
16615: LD_ADDR_VAR 0 3
16619: PUSH
16620: LD_VAR 0 1
16624: PPUSH
16625: CALL_OW 255
16629: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16630: LD_ADDR_VAR 0 4
16634: PUSH
16635: LD_VAR 0 1
16639: PPUSH
16640: CALL_OW 248
16644: ST_TO_ADDR
// case nat of 1 :
16645: LD_VAR 0 4
16649: PUSH
16650: LD_INT 1
16652: DOUBLE
16653: EQUAL
16654: IFTRUE 16658
16656: GO 16669
16658: POP
// tech := tech_lassight ; 2 :
16659: LD_ADDR_VAR 0 5
16663: PUSH
16664: LD_INT 12
16666: ST_TO_ADDR
16667: GO 16708
16669: LD_INT 2
16671: DOUBLE
16672: EQUAL
16673: IFTRUE 16677
16675: GO 16688
16677: POP
// tech := tech_mortar ; 3 :
16678: LD_ADDR_VAR 0 5
16682: PUSH
16683: LD_INT 41
16685: ST_TO_ADDR
16686: GO 16708
16688: LD_INT 3
16690: DOUBLE
16691: EQUAL
16692: IFTRUE 16696
16694: GO 16707
16696: POP
// tech := tech_bazooka ; end ;
16697: LD_ADDR_VAR 0 5
16701: PUSH
16702: LD_INT 44
16704: ST_TO_ADDR
16705: GO 16708
16707: POP
// if Researched ( side , tech ) then
16708: LD_VAR 0 3
16712: PPUSH
16713: LD_VAR 0 5
16717: PPUSH
16718: CALL_OW 325
16722: IFFALSE 16749
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16724: LD_ADDR_VAR 0 2
16728: PUSH
16729: LD_INT 5
16731: PUSH
16732: LD_INT 8
16734: PUSH
16735: LD_INT 9
16737: PUSH
16738: EMPTY
16739: LIST
16740: LIST
16741: LIST
16742: PUSH
16743: LD_VAR 0 4
16747: ARRAY
16748: ST_TO_ADDR
// end ;
16749: LD_VAR 0 2
16753: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16754: LD_INT 0
16756: PPUSH
16757: PPUSH
16758: PPUSH
// if not mines then
16759: LD_VAR 0 2
16763: NOT
16764: IFFALSE 16768
// exit ;
16766: GO 16912
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16768: LD_ADDR_VAR 0 5
16772: PUSH
16773: LD_INT 81
16775: PUSH
16776: LD_VAR 0 1
16780: PUSH
16781: EMPTY
16782: LIST
16783: LIST
16784: PUSH
16785: LD_INT 3
16787: PUSH
16788: LD_INT 21
16790: PUSH
16791: LD_INT 3
16793: PUSH
16794: EMPTY
16795: LIST
16796: LIST
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 69
16810: ST_TO_ADDR
// for i in mines do
16811: LD_ADDR_VAR 0 4
16815: PUSH
16816: LD_VAR 0 2
16820: PUSH
16821: FOR_IN
16822: IFFALSE 16910
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16824: LD_VAR 0 4
16828: PUSH
16829: LD_INT 1
16831: ARRAY
16832: PPUSH
16833: LD_VAR 0 4
16837: PUSH
16838: LD_INT 2
16840: ARRAY
16841: PPUSH
16842: CALL_OW 458
16846: NOT
16847: IFFALSE 16851
// continue ;
16849: GO 16821
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16851: LD_VAR 0 4
16855: PUSH
16856: LD_INT 1
16858: ARRAY
16859: PPUSH
16860: LD_VAR 0 4
16864: PUSH
16865: LD_INT 2
16867: ARRAY
16868: PPUSH
16869: CALL_OW 428
16873: PUSH
16874: LD_VAR 0 5
16878: IN
16879: IFFALSE 16908
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16881: LD_VAR 0 4
16885: PUSH
16886: LD_INT 1
16888: ARRAY
16889: PPUSH
16890: LD_VAR 0 4
16894: PUSH
16895: LD_INT 2
16897: ARRAY
16898: PPUSH
16899: LD_VAR 0 1
16903: PPUSH
16904: CALL_OW 456
// end ;
16908: GO 16821
16910: POP
16911: POP
// end ;
16912: LD_VAR 0 3
16916: RET
// export function Count ( array ) ; var i ; begin
16917: LD_INT 0
16919: PPUSH
16920: PPUSH
// result := 0 ;
16921: LD_ADDR_VAR 0 2
16925: PUSH
16926: LD_INT 0
16928: ST_TO_ADDR
// for i in array do
16929: LD_ADDR_VAR 0 3
16933: PUSH
16934: LD_VAR 0 1
16938: PUSH
16939: FOR_IN
16940: IFFALSE 16964
// if i then
16942: LD_VAR 0 3
16946: IFFALSE 16962
// result := result + 1 ;
16948: LD_ADDR_VAR 0 2
16952: PUSH
16953: LD_VAR 0 2
16957: PUSH
16958: LD_INT 1
16960: PLUS
16961: ST_TO_ADDR
16962: GO 16939
16964: POP
16965: POP
// end ;
16966: LD_VAR 0 2
16970: RET
// export function IsEmpty ( building ) ; begin
16971: LD_INT 0
16973: PPUSH
// if not building then
16974: LD_VAR 0 1
16978: NOT
16979: IFFALSE 16983
// exit ;
16981: GO 17026
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16983: LD_ADDR_VAR 0 2
16987: PUSH
16988: LD_VAR 0 1
16992: PUSH
16993: LD_INT 22
16995: PUSH
16996: LD_VAR 0 1
17000: PPUSH
17001: CALL_OW 255
17005: PUSH
17006: EMPTY
17007: LIST
17008: LIST
17009: PUSH
17010: LD_INT 58
17012: PUSH
17013: EMPTY
17014: LIST
17015: PUSH
17016: EMPTY
17017: LIST
17018: LIST
17019: PPUSH
17020: CALL_OW 69
17024: IN
17025: ST_TO_ADDR
// end ;
17026: LD_VAR 0 2
17030: RET
// export function IsNotFull ( building ) ; begin
17031: LD_INT 0
17033: PPUSH
// if not building then
17034: LD_VAR 0 1
17038: NOT
17039: IFFALSE 17043
// exit ;
17041: GO 17062
// result := UnitsInside ( building ) < 6 ;
17043: LD_ADDR_VAR 0 2
17047: PUSH
17048: LD_VAR 0 1
17052: PPUSH
17053: CALL_OW 313
17057: PUSH
17058: LD_INT 6
17060: LESS
17061: ST_TO_ADDR
// end ;
17062: LD_VAR 0 2
17066: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17067: LD_INT 0
17069: PPUSH
17070: PPUSH
17071: PPUSH
17072: PPUSH
// tmp := [ ] ;
17073: LD_ADDR_VAR 0 3
17077: PUSH
17078: EMPTY
17079: ST_TO_ADDR
// list := [ ] ;
17080: LD_ADDR_VAR 0 5
17084: PUSH
17085: EMPTY
17086: ST_TO_ADDR
// for i = 16 to 25 do
17087: LD_ADDR_VAR 0 4
17091: PUSH
17092: DOUBLE
17093: LD_INT 16
17095: DEC
17096: ST_TO_ADDR
17097: LD_INT 25
17099: PUSH
17100: FOR_TO
17101: IFFALSE 17174
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17103: LD_ADDR_VAR 0 3
17107: PUSH
17108: LD_VAR 0 3
17112: PUSH
17113: LD_INT 22
17115: PUSH
17116: LD_VAR 0 1
17120: PPUSH
17121: CALL_OW 255
17125: PUSH
17126: EMPTY
17127: LIST
17128: LIST
17129: PUSH
17130: LD_INT 91
17132: PUSH
17133: LD_VAR 0 1
17137: PUSH
17138: LD_INT 6
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: LIST
17145: PUSH
17146: LD_INT 30
17148: PUSH
17149: LD_VAR 0 4
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: PUSH
17158: EMPTY
17159: LIST
17160: LIST
17161: LIST
17162: PUSH
17163: EMPTY
17164: LIST
17165: PPUSH
17166: CALL_OW 69
17170: ADD
17171: ST_TO_ADDR
17172: GO 17100
17174: POP
17175: POP
// for i = 1 to tmp do
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: DOUBLE
17182: LD_INT 1
17184: DEC
17185: ST_TO_ADDR
17186: LD_VAR 0 3
17190: PUSH
17191: FOR_TO
17192: IFFALSE 17280
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17194: LD_ADDR_VAR 0 5
17198: PUSH
17199: LD_VAR 0 5
17203: PUSH
17204: LD_VAR 0 3
17208: PUSH
17209: LD_VAR 0 4
17213: ARRAY
17214: PPUSH
17215: CALL_OW 266
17219: PUSH
17220: LD_VAR 0 3
17224: PUSH
17225: LD_VAR 0 4
17229: ARRAY
17230: PPUSH
17231: CALL_OW 250
17235: PUSH
17236: LD_VAR 0 3
17240: PUSH
17241: LD_VAR 0 4
17245: ARRAY
17246: PPUSH
17247: CALL_OW 251
17251: PUSH
17252: LD_VAR 0 3
17256: PUSH
17257: LD_VAR 0 4
17261: ARRAY
17262: PPUSH
17263: CALL_OW 254
17267: PUSH
17268: EMPTY
17269: LIST
17270: LIST
17271: LIST
17272: LIST
17273: PUSH
17274: EMPTY
17275: LIST
17276: ADD
17277: ST_TO_ADDR
17278: GO 17191
17280: POP
17281: POP
// result := list ;
17282: LD_ADDR_VAR 0 2
17286: PUSH
17287: LD_VAR 0 5
17291: ST_TO_ADDR
// end ;
17292: LD_VAR 0 2
17296: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17297: LD_INT 0
17299: PPUSH
17300: PPUSH
17301: PPUSH
17302: PPUSH
17303: PPUSH
17304: PPUSH
17305: PPUSH
// if not factory then
17306: LD_VAR 0 1
17310: NOT
17311: IFFALSE 17315
// exit ;
17313: GO 17908
// if control = control_apeman then
17315: LD_VAR 0 4
17319: PUSH
17320: LD_INT 5
17322: EQUAL
17323: IFFALSE 17432
// begin tmp := UnitsInside ( factory ) ;
17325: LD_ADDR_VAR 0 8
17329: PUSH
17330: LD_VAR 0 1
17334: PPUSH
17335: CALL_OW 313
17339: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17340: LD_VAR 0 8
17344: PPUSH
17345: LD_INT 25
17347: PUSH
17348: LD_INT 12
17350: PUSH
17351: EMPTY
17352: LIST
17353: LIST
17354: PPUSH
17355: CALL_OW 72
17359: NOT
17360: IFFALSE 17370
// control := control_manual ;
17362: LD_ADDR_VAR 0 4
17366: PUSH
17367: LD_INT 1
17369: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17370: LD_ADDR_VAR 0 8
17374: PUSH
17375: LD_VAR 0 1
17379: PPUSH
17380: CALL 17067 0 1
17384: ST_TO_ADDR
// if tmp then
17385: LD_VAR 0 8
17389: IFFALSE 17432
// begin for i in tmp do
17391: LD_ADDR_VAR 0 7
17395: PUSH
17396: LD_VAR 0 8
17400: PUSH
17401: FOR_IN
17402: IFFALSE 17430
// if i [ 1 ] = b_ext_radio then
17404: LD_VAR 0 7
17408: PUSH
17409: LD_INT 1
17411: ARRAY
17412: PUSH
17413: LD_INT 22
17415: EQUAL
17416: IFFALSE 17428
// begin control := control_remote ;
17418: LD_ADDR_VAR 0 4
17422: PUSH
17423: LD_INT 2
17425: ST_TO_ADDR
// break ;
17426: GO 17430
// end ;
17428: GO 17401
17430: POP
17431: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17432: LD_VAR 0 1
17436: PPUSH
17437: LD_VAR 0 2
17441: PPUSH
17442: LD_VAR 0 3
17446: PPUSH
17447: LD_VAR 0 4
17451: PPUSH
17452: LD_VAR 0 5
17456: PPUSH
17457: CALL_OW 448
17461: IFFALSE 17496
// begin result := [ chassis , engine , control , weapon ] ;
17463: LD_ADDR_VAR 0 6
17467: PUSH
17468: LD_VAR 0 2
17472: PUSH
17473: LD_VAR 0 3
17477: PUSH
17478: LD_VAR 0 4
17482: PUSH
17483: LD_VAR 0 5
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: LIST
17492: LIST
17493: ST_TO_ADDR
// exit ;
17494: GO 17908
// end ; _chassis := AvailableChassisList ( factory ) ;
17496: LD_ADDR_VAR 0 9
17500: PUSH
17501: LD_VAR 0 1
17505: PPUSH
17506: CALL_OW 475
17510: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17511: LD_ADDR_VAR 0 11
17515: PUSH
17516: LD_VAR 0 1
17520: PPUSH
17521: CALL_OW 476
17525: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17526: LD_ADDR_VAR 0 12
17530: PUSH
17531: LD_VAR 0 1
17535: PPUSH
17536: CALL_OW 477
17540: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17541: LD_ADDR_VAR 0 10
17545: PUSH
17546: LD_VAR 0 1
17550: PPUSH
17551: CALL_OW 478
17555: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17556: LD_VAR 0 9
17560: NOT
17561: PUSH
17562: LD_VAR 0 11
17566: NOT
17567: OR
17568: PUSH
17569: LD_VAR 0 12
17573: NOT
17574: OR
17575: PUSH
17576: LD_VAR 0 10
17580: NOT
17581: OR
17582: IFFALSE 17617
// begin result := [ chassis , engine , control , weapon ] ;
17584: LD_ADDR_VAR 0 6
17588: PUSH
17589: LD_VAR 0 2
17593: PUSH
17594: LD_VAR 0 3
17598: PUSH
17599: LD_VAR 0 4
17603: PUSH
17604: LD_VAR 0 5
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: LIST
17614: ST_TO_ADDR
// exit ;
17615: GO 17908
// end ; if not chassis in _chassis then
17617: LD_VAR 0 2
17621: PUSH
17622: LD_VAR 0 9
17626: IN
17627: NOT
17628: IFFALSE 17654
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17630: LD_ADDR_VAR 0 2
17634: PUSH
17635: LD_VAR 0 9
17639: PUSH
17640: LD_INT 1
17642: PPUSH
17643: LD_VAR 0 9
17647: PPUSH
17648: CALL_OW 12
17652: ARRAY
17653: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17654: LD_VAR 0 2
17658: PPUSH
17659: LD_VAR 0 3
17663: PPUSH
17664: CALL 17913 0 2
17668: NOT
17669: IFFALSE 17728
// repeat engine := _engine [ 1 ] ;
17671: LD_ADDR_VAR 0 3
17675: PUSH
17676: LD_VAR 0 11
17680: PUSH
17681: LD_INT 1
17683: ARRAY
17684: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17685: LD_ADDR_VAR 0 11
17689: PUSH
17690: LD_VAR 0 11
17694: PPUSH
17695: LD_INT 1
17697: PPUSH
17698: CALL_OW 3
17702: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17703: LD_VAR 0 2
17707: PPUSH
17708: LD_VAR 0 3
17712: PPUSH
17713: CALL 17913 0 2
17717: PUSH
17718: LD_VAR 0 11
17722: PUSH
17723: EMPTY
17724: EQUAL
17725: OR
17726: IFFALSE 17671
// if not control in _control then
17728: LD_VAR 0 4
17732: PUSH
17733: LD_VAR 0 12
17737: IN
17738: NOT
17739: IFFALSE 17765
// control := _control [ rand ( 1 , _control ) ] ;
17741: LD_ADDR_VAR 0 4
17745: PUSH
17746: LD_VAR 0 12
17750: PUSH
17751: LD_INT 1
17753: PPUSH
17754: LD_VAR 0 12
17758: PPUSH
17759: CALL_OW 12
17763: ARRAY
17764: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17765: LD_VAR 0 2
17769: PPUSH
17770: LD_VAR 0 5
17774: PPUSH
17775: CALL 18133 0 2
17779: NOT
17780: IFFALSE 17839
// repeat weapon := _weapon [ 1 ] ;
17782: LD_ADDR_VAR 0 5
17786: PUSH
17787: LD_VAR 0 10
17791: PUSH
17792: LD_INT 1
17794: ARRAY
17795: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17796: LD_ADDR_VAR 0 10
17800: PUSH
17801: LD_VAR 0 10
17805: PPUSH
17806: LD_INT 1
17808: PPUSH
17809: CALL_OW 3
17813: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17814: LD_VAR 0 2
17818: PPUSH
17819: LD_VAR 0 5
17823: PPUSH
17824: CALL 18133 0 2
17828: PUSH
17829: LD_VAR 0 10
17833: PUSH
17834: EMPTY
17835: EQUAL
17836: OR
17837: IFFALSE 17782
// result := [ ] ;
17839: LD_ADDR_VAR 0 6
17843: PUSH
17844: EMPTY
17845: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17846: LD_VAR 0 1
17850: PPUSH
17851: LD_VAR 0 2
17855: PPUSH
17856: LD_VAR 0 3
17860: PPUSH
17861: LD_VAR 0 4
17865: PPUSH
17866: LD_VAR 0 5
17870: PPUSH
17871: CALL_OW 448
17875: IFFALSE 17908
// result := [ chassis , engine , control , weapon ] ;
17877: LD_ADDR_VAR 0 6
17881: PUSH
17882: LD_VAR 0 2
17886: PUSH
17887: LD_VAR 0 3
17891: PUSH
17892: LD_VAR 0 4
17896: PUSH
17897: LD_VAR 0 5
17901: PUSH
17902: EMPTY
17903: LIST
17904: LIST
17905: LIST
17906: LIST
17907: ST_TO_ADDR
// end ;
17908: LD_VAR 0 6
17912: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17913: LD_INT 0
17915: PPUSH
// if not chassis or not engine then
17916: LD_VAR 0 1
17920: NOT
17921: PUSH
17922: LD_VAR 0 2
17926: NOT
17927: OR
17928: IFFALSE 17932
// exit ;
17930: GO 18128
// case engine of engine_solar :
17932: LD_VAR 0 2
17936: PUSH
17937: LD_INT 2
17939: DOUBLE
17940: EQUAL
17941: IFTRUE 17945
17943: GO 17983
17945: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17946: LD_ADDR_VAR 0 3
17950: PUSH
17951: LD_INT 11
17953: PUSH
17954: LD_INT 12
17956: PUSH
17957: LD_INT 13
17959: PUSH
17960: LD_INT 14
17962: PUSH
17963: LD_INT 1
17965: PUSH
17966: LD_INT 2
17968: PUSH
17969: LD_INT 3
17971: PUSH
17972: EMPTY
17973: LIST
17974: LIST
17975: LIST
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: ST_TO_ADDR
17981: GO 18112
17983: LD_INT 1
17985: DOUBLE
17986: EQUAL
17987: IFTRUE 17991
17989: GO 18053
17991: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17992: LD_ADDR_VAR 0 3
17996: PUSH
17997: LD_INT 11
17999: PUSH
18000: LD_INT 12
18002: PUSH
18003: LD_INT 13
18005: PUSH
18006: LD_INT 14
18008: PUSH
18009: LD_INT 1
18011: PUSH
18012: LD_INT 2
18014: PUSH
18015: LD_INT 3
18017: PUSH
18018: LD_INT 4
18020: PUSH
18021: LD_INT 5
18023: PUSH
18024: LD_INT 21
18026: PUSH
18027: LD_INT 23
18029: PUSH
18030: LD_INT 22
18032: PUSH
18033: LD_INT 24
18035: PUSH
18036: EMPTY
18037: LIST
18038: LIST
18039: LIST
18040: LIST
18041: LIST
18042: LIST
18043: LIST
18044: LIST
18045: LIST
18046: LIST
18047: LIST
18048: LIST
18049: LIST
18050: ST_TO_ADDR
18051: GO 18112
18053: LD_INT 3
18055: DOUBLE
18056: EQUAL
18057: IFTRUE 18061
18059: GO 18111
18061: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18062: LD_ADDR_VAR 0 3
18066: PUSH
18067: LD_INT 13
18069: PUSH
18070: LD_INT 14
18072: PUSH
18073: LD_INT 2
18075: PUSH
18076: LD_INT 3
18078: PUSH
18079: LD_INT 4
18081: PUSH
18082: LD_INT 5
18084: PUSH
18085: LD_INT 21
18087: PUSH
18088: LD_INT 22
18090: PUSH
18091: LD_INT 23
18093: PUSH
18094: LD_INT 24
18096: PUSH
18097: EMPTY
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: ST_TO_ADDR
18109: GO 18112
18111: POP
// result := ( chassis in result ) ;
18112: LD_ADDR_VAR 0 3
18116: PUSH
18117: LD_VAR 0 1
18121: PUSH
18122: LD_VAR 0 3
18126: IN
18127: ST_TO_ADDR
// end ;
18128: LD_VAR 0 3
18132: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18133: LD_INT 0
18135: PPUSH
// if not chassis or not weapon then
18136: LD_VAR 0 1
18140: NOT
18141: PUSH
18142: LD_VAR 0 2
18146: NOT
18147: OR
18148: IFFALSE 18152
// exit ;
18150: GO 19214
// case weapon of us_machine_gun :
18152: LD_VAR 0 2
18156: PUSH
18157: LD_INT 2
18159: DOUBLE
18160: EQUAL
18161: IFTRUE 18165
18163: GO 18195
18165: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18166: LD_ADDR_VAR 0 3
18170: PUSH
18171: LD_INT 1
18173: PUSH
18174: LD_INT 2
18176: PUSH
18177: LD_INT 3
18179: PUSH
18180: LD_INT 4
18182: PUSH
18183: LD_INT 5
18185: PUSH
18186: EMPTY
18187: LIST
18188: LIST
18189: LIST
18190: LIST
18191: LIST
18192: ST_TO_ADDR
18193: GO 19198
18195: LD_INT 3
18197: DOUBLE
18198: EQUAL
18199: IFTRUE 18203
18201: GO 18233
18203: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18204: LD_ADDR_VAR 0 3
18208: PUSH
18209: LD_INT 1
18211: PUSH
18212: LD_INT 2
18214: PUSH
18215: LD_INT 3
18217: PUSH
18218: LD_INT 4
18220: PUSH
18221: LD_INT 5
18223: PUSH
18224: EMPTY
18225: LIST
18226: LIST
18227: LIST
18228: LIST
18229: LIST
18230: ST_TO_ADDR
18231: GO 19198
18233: LD_INT 11
18235: DOUBLE
18236: EQUAL
18237: IFTRUE 18241
18239: GO 18271
18241: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18242: LD_ADDR_VAR 0 3
18246: PUSH
18247: LD_INT 1
18249: PUSH
18250: LD_INT 2
18252: PUSH
18253: LD_INT 3
18255: PUSH
18256: LD_INT 4
18258: PUSH
18259: LD_INT 5
18261: PUSH
18262: EMPTY
18263: LIST
18264: LIST
18265: LIST
18266: LIST
18267: LIST
18268: ST_TO_ADDR
18269: GO 19198
18271: LD_INT 4
18273: DOUBLE
18274: EQUAL
18275: IFTRUE 18279
18277: GO 18305
18279: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18280: LD_ADDR_VAR 0 3
18284: PUSH
18285: LD_INT 2
18287: PUSH
18288: LD_INT 3
18290: PUSH
18291: LD_INT 4
18293: PUSH
18294: LD_INT 5
18296: PUSH
18297: EMPTY
18298: LIST
18299: LIST
18300: LIST
18301: LIST
18302: ST_TO_ADDR
18303: GO 19198
18305: LD_INT 5
18307: DOUBLE
18308: EQUAL
18309: IFTRUE 18313
18311: GO 18339
18313: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18314: LD_ADDR_VAR 0 3
18318: PUSH
18319: LD_INT 2
18321: PUSH
18322: LD_INT 3
18324: PUSH
18325: LD_INT 4
18327: PUSH
18328: LD_INT 5
18330: PUSH
18331: EMPTY
18332: LIST
18333: LIST
18334: LIST
18335: LIST
18336: ST_TO_ADDR
18337: GO 19198
18339: LD_INT 9
18341: DOUBLE
18342: EQUAL
18343: IFTRUE 18347
18345: GO 18373
18347: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18348: LD_ADDR_VAR 0 3
18352: PUSH
18353: LD_INT 2
18355: PUSH
18356: LD_INT 3
18358: PUSH
18359: LD_INT 4
18361: PUSH
18362: LD_INT 5
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: LIST
18369: LIST
18370: ST_TO_ADDR
18371: GO 19198
18373: LD_INT 7
18375: DOUBLE
18376: EQUAL
18377: IFTRUE 18381
18379: GO 18407
18381: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18382: LD_ADDR_VAR 0 3
18386: PUSH
18387: LD_INT 2
18389: PUSH
18390: LD_INT 3
18392: PUSH
18393: LD_INT 4
18395: PUSH
18396: LD_INT 5
18398: PUSH
18399: EMPTY
18400: LIST
18401: LIST
18402: LIST
18403: LIST
18404: ST_TO_ADDR
18405: GO 19198
18407: LD_INT 12
18409: DOUBLE
18410: EQUAL
18411: IFTRUE 18415
18413: GO 18441
18415: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18416: LD_ADDR_VAR 0 3
18420: PUSH
18421: LD_INT 2
18423: PUSH
18424: LD_INT 3
18426: PUSH
18427: LD_INT 4
18429: PUSH
18430: LD_INT 5
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: LIST
18437: LIST
18438: ST_TO_ADDR
18439: GO 19198
18441: LD_INT 13
18443: DOUBLE
18444: EQUAL
18445: IFTRUE 18449
18447: GO 18475
18449: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18450: LD_ADDR_VAR 0 3
18454: PUSH
18455: LD_INT 2
18457: PUSH
18458: LD_INT 3
18460: PUSH
18461: LD_INT 4
18463: PUSH
18464: LD_INT 5
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: ST_TO_ADDR
18473: GO 19198
18475: LD_INT 14
18477: DOUBLE
18478: EQUAL
18479: IFTRUE 18483
18481: GO 18501
18483: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18484: LD_ADDR_VAR 0 3
18488: PUSH
18489: LD_INT 4
18491: PUSH
18492: LD_INT 5
18494: PUSH
18495: EMPTY
18496: LIST
18497: LIST
18498: ST_TO_ADDR
18499: GO 19198
18501: LD_INT 6
18503: DOUBLE
18504: EQUAL
18505: IFTRUE 18509
18507: GO 18527
18509: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18510: LD_ADDR_VAR 0 3
18514: PUSH
18515: LD_INT 4
18517: PUSH
18518: LD_INT 5
18520: PUSH
18521: EMPTY
18522: LIST
18523: LIST
18524: ST_TO_ADDR
18525: GO 19198
18527: LD_INT 10
18529: DOUBLE
18530: EQUAL
18531: IFTRUE 18535
18533: GO 18553
18535: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18536: LD_ADDR_VAR 0 3
18540: PUSH
18541: LD_INT 4
18543: PUSH
18544: LD_INT 5
18546: PUSH
18547: EMPTY
18548: LIST
18549: LIST
18550: ST_TO_ADDR
18551: GO 19198
18553: LD_INT 22
18555: DOUBLE
18556: EQUAL
18557: IFTRUE 18561
18559: GO 18587
18561: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18562: LD_ADDR_VAR 0 3
18566: PUSH
18567: LD_INT 11
18569: PUSH
18570: LD_INT 12
18572: PUSH
18573: LD_INT 13
18575: PUSH
18576: LD_INT 14
18578: PUSH
18579: EMPTY
18580: LIST
18581: LIST
18582: LIST
18583: LIST
18584: ST_TO_ADDR
18585: GO 19198
18587: LD_INT 23
18589: DOUBLE
18590: EQUAL
18591: IFTRUE 18595
18593: GO 18621
18595: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18596: LD_ADDR_VAR 0 3
18600: PUSH
18601: LD_INT 11
18603: PUSH
18604: LD_INT 12
18606: PUSH
18607: LD_INT 13
18609: PUSH
18610: LD_INT 14
18612: PUSH
18613: EMPTY
18614: LIST
18615: LIST
18616: LIST
18617: LIST
18618: ST_TO_ADDR
18619: GO 19198
18621: LD_INT 24
18623: DOUBLE
18624: EQUAL
18625: IFTRUE 18629
18627: GO 18655
18629: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18630: LD_ADDR_VAR 0 3
18634: PUSH
18635: LD_INT 11
18637: PUSH
18638: LD_INT 12
18640: PUSH
18641: LD_INT 13
18643: PUSH
18644: LD_INT 14
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: LIST
18651: LIST
18652: ST_TO_ADDR
18653: GO 19198
18655: LD_INT 30
18657: DOUBLE
18658: EQUAL
18659: IFTRUE 18663
18661: GO 18689
18663: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18664: LD_ADDR_VAR 0 3
18668: PUSH
18669: LD_INT 11
18671: PUSH
18672: LD_INT 12
18674: PUSH
18675: LD_INT 13
18677: PUSH
18678: LD_INT 14
18680: PUSH
18681: EMPTY
18682: LIST
18683: LIST
18684: LIST
18685: LIST
18686: ST_TO_ADDR
18687: GO 19198
18689: LD_INT 25
18691: DOUBLE
18692: EQUAL
18693: IFTRUE 18697
18695: GO 18715
18697: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18698: LD_ADDR_VAR 0 3
18702: PUSH
18703: LD_INT 13
18705: PUSH
18706: LD_INT 14
18708: PUSH
18709: EMPTY
18710: LIST
18711: LIST
18712: ST_TO_ADDR
18713: GO 19198
18715: LD_INT 27
18717: DOUBLE
18718: EQUAL
18719: IFTRUE 18723
18721: GO 18741
18723: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18724: LD_ADDR_VAR 0 3
18728: PUSH
18729: LD_INT 13
18731: PUSH
18732: LD_INT 14
18734: PUSH
18735: EMPTY
18736: LIST
18737: LIST
18738: ST_TO_ADDR
18739: GO 19198
18741: LD_EXP 109
18745: DOUBLE
18746: EQUAL
18747: IFTRUE 18751
18749: GO 18777
18751: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18752: LD_ADDR_VAR 0 3
18756: PUSH
18757: LD_INT 11
18759: PUSH
18760: LD_INT 12
18762: PUSH
18763: LD_INT 13
18765: PUSH
18766: LD_INT 14
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: LIST
18773: LIST
18774: ST_TO_ADDR
18775: GO 19198
18777: LD_INT 28
18779: DOUBLE
18780: EQUAL
18781: IFTRUE 18785
18783: GO 18803
18785: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18786: LD_ADDR_VAR 0 3
18790: PUSH
18791: LD_INT 13
18793: PUSH
18794: LD_INT 14
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: ST_TO_ADDR
18801: GO 19198
18803: LD_INT 29
18805: DOUBLE
18806: EQUAL
18807: IFTRUE 18811
18809: GO 18829
18811: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18812: LD_ADDR_VAR 0 3
18816: PUSH
18817: LD_INT 13
18819: PUSH
18820: LD_INT 14
18822: PUSH
18823: EMPTY
18824: LIST
18825: LIST
18826: ST_TO_ADDR
18827: GO 19198
18829: LD_INT 31
18831: DOUBLE
18832: EQUAL
18833: IFTRUE 18837
18835: GO 18855
18837: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18838: LD_ADDR_VAR 0 3
18842: PUSH
18843: LD_INT 13
18845: PUSH
18846: LD_INT 14
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: ST_TO_ADDR
18853: GO 19198
18855: LD_INT 26
18857: DOUBLE
18858: EQUAL
18859: IFTRUE 18863
18861: GO 18881
18863: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18864: LD_ADDR_VAR 0 3
18868: PUSH
18869: LD_INT 13
18871: PUSH
18872: LD_INT 14
18874: PUSH
18875: EMPTY
18876: LIST
18877: LIST
18878: ST_TO_ADDR
18879: GO 19198
18881: LD_INT 42
18883: DOUBLE
18884: EQUAL
18885: IFTRUE 18889
18887: GO 18915
18889: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18890: LD_ADDR_VAR 0 3
18894: PUSH
18895: LD_INT 21
18897: PUSH
18898: LD_INT 22
18900: PUSH
18901: LD_INT 23
18903: PUSH
18904: LD_INT 24
18906: PUSH
18907: EMPTY
18908: LIST
18909: LIST
18910: LIST
18911: LIST
18912: ST_TO_ADDR
18913: GO 19198
18915: LD_INT 43
18917: DOUBLE
18918: EQUAL
18919: IFTRUE 18923
18921: GO 18949
18923: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18924: LD_ADDR_VAR 0 3
18928: PUSH
18929: LD_INT 21
18931: PUSH
18932: LD_INT 22
18934: PUSH
18935: LD_INT 23
18937: PUSH
18938: LD_INT 24
18940: PUSH
18941: EMPTY
18942: LIST
18943: LIST
18944: LIST
18945: LIST
18946: ST_TO_ADDR
18947: GO 19198
18949: LD_INT 44
18951: DOUBLE
18952: EQUAL
18953: IFTRUE 18957
18955: GO 18983
18957: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18958: LD_ADDR_VAR 0 3
18962: PUSH
18963: LD_INT 21
18965: PUSH
18966: LD_INT 22
18968: PUSH
18969: LD_INT 23
18971: PUSH
18972: LD_INT 24
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: LIST
18979: LIST
18980: ST_TO_ADDR
18981: GO 19198
18983: LD_INT 45
18985: DOUBLE
18986: EQUAL
18987: IFTRUE 18991
18989: GO 19017
18991: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18992: LD_ADDR_VAR 0 3
18996: PUSH
18997: LD_INT 21
18999: PUSH
19000: LD_INT 22
19002: PUSH
19003: LD_INT 23
19005: PUSH
19006: LD_INT 24
19008: PUSH
19009: EMPTY
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: ST_TO_ADDR
19015: GO 19198
19017: LD_INT 49
19019: DOUBLE
19020: EQUAL
19021: IFTRUE 19025
19023: GO 19051
19025: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19026: LD_ADDR_VAR 0 3
19030: PUSH
19031: LD_INT 21
19033: PUSH
19034: LD_INT 22
19036: PUSH
19037: LD_INT 23
19039: PUSH
19040: LD_INT 24
19042: PUSH
19043: EMPTY
19044: LIST
19045: LIST
19046: LIST
19047: LIST
19048: ST_TO_ADDR
19049: GO 19198
19051: LD_INT 51
19053: DOUBLE
19054: EQUAL
19055: IFTRUE 19059
19057: GO 19085
19059: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19060: LD_ADDR_VAR 0 3
19064: PUSH
19065: LD_INT 21
19067: PUSH
19068: LD_INT 22
19070: PUSH
19071: LD_INT 23
19073: PUSH
19074: LD_INT 24
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: LIST
19081: LIST
19082: ST_TO_ADDR
19083: GO 19198
19085: LD_INT 52
19087: DOUBLE
19088: EQUAL
19089: IFTRUE 19093
19091: GO 19119
19093: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19094: LD_ADDR_VAR 0 3
19098: PUSH
19099: LD_INT 21
19101: PUSH
19102: LD_INT 22
19104: PUSH
19105: LD_INT 23
19107: PUSH
19108: LD_INT 24
19110: PUSH
19111: EMPTY
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: ST_TO_ADDR
19117: GO 19198
19119: LD_INT 53
19121: DOUBLE
19122: EQUAL
19123: IFTRUE 19127
19125: GO 19145
19127: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19128: LD_ADDR_VAR 0 3
19132: PUSH
19133: LD_INT 23
19135: PUSH
19136: LD_INT 24
19138: PUSH
19139: EMPTY
19140: LIST
19141: LIST
19142: ST_TO_ADDR
19143: GO 19198
19145: LD_INT 46
19147: DOUBLE
19148: EQUAL
19149: IFTRUE 19153
19151: GO 19171
19153: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19154: LD_ADDR_VAR 0 3
19158: PUSH
19159: LD_INT 23
19161: PUSH
19162: LD_INT 24
19164: PUSH
19165: EMPTY
19166: LIST
19167: LIST
19168: ST_TO_ADDR
19169: GO 19198
19171: LD_INT 47
19173: DOUBLE
19174: EQUAL
19175: IFTRUE 19179
19177: GO 19197
19179: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19180: LD_ADDR_VAR 0 3
19184: PUSH
19185: LD_INT 23
19187: PUSH
19188: LD_INT 24
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: ST_TO_ADDR
19195: GO 19198
19197: POP
// result := ( chassis in result ) ;
19198: LD_ADDR_VAR 0 3
19202: PUSH
19203: LD_VAR 0 1
19207: PUSH
19208: LD_VAR 0 3
19212: IN
19213: ST_TO_ADDR
// end ;
19214: LD_VAR 0 3
19218: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19219: LD_INT 0
19221: PPUSH
19222: PPUSH
19223: PPUSH
19224: PPUSH
19225: PPUSH
19226: PPUSH
19227: PPUSH
// result := array ;
19228: LD_ADDR_VAR 0 5
19232: PUSH
19233: LD_VAR 0 1
19237: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19238: LD_VAR 0 1
19242: NOT
19243: PUSH
19244: LD_VAR 0 2
19248: NOT
19249: OR
19250: PUSH
19251: LD_VAR 0 3
19255: NOT
19256: OR
19257: PUSH
19258: LD_VAR 0 2
19262: PUSH
19263: LD_VAR 0 1
19267: GREATER
19268: OR
19269: PUSH
19270: LD_VAR 0 3
19274: PUSH
19275: LD_VAR 0 1
19279: GREATER
19280: OR
19281: IFFALSE 19285
// exit ;
19283: GO 19581
// if direction then
19285: LD_VAR 0 4
19289: IFFALSE 19353
// begin d := 1 ;
19291: LD_ADDR_VAR 0 9
19295: PUSH
19296: LD_INT 1
19298: ST_TO_ADDR
// if i_from > i_to then
19299: LD_VAR 0 2
19303: PUSH
19304: LD_VAR 0 3
19308: GREATER
19309: IFFALSE 19335
// length := ( array - i_from ) + i_to else
19311: LD_ADDR_VAR 0 11
19315: PUSH
19316: LD_VAR 0 1
19320: PUSH
19321: LD_VAR 0 2
19325: MINUS
19326: PUSH
19327: LD_VAR 0 3
19331: PLUS
19332: ST_TO_ADDR
19333: GO 19351
// length := i_to - i_from ;
19335: LD_ADDR_VAR 0 11
19339: PUSH
19340: LD_VAR 0 3
19344: PUSH
19345: LD_VAR 0 2
19349: MINUS
19350: ST_TO_ADDR
// end else
19351: GO 19414
// begin d := - 1 ;
19353: LD_ADDR_VAR 0 9
19357: PUSH
19358: LD_INT 1
19360: NEG
19361: ST_TO_ADDR
// if i_from > i_to then
19362: LD_VAR 0 2
19366: PUSH
19367: LD_VAR 0 3
19371: GREATER
19372: IFFALSE 19392
// length := i_from - i_to else
19374: LD_ADDR_VAR 0 11
19378: PUSH
19379: LD_VAR 0 2
19383: PUSH
19384: LD_VAR 0 3
19388: MINUS
19389: ST_TO_ADDR
19390: GO 19414
// length := ( array - i_to ) + i_from ;
19392: LD_ADDR_VAR 0 11
19396: PUSH
19397: LD_VAR 0 1
19401: PUSH
19402: LD_VAR 0 3
19406: MINUS
19407: PUSH
19408: LD_VAR 0 2
19412: PLUS
19413: ST_TO_ADDR
// end ; if not length then
19414: LD_VAR 0 11
19418: NOT
19419: IFFALSE 19423
// exit ;
19421: GO 19581
// tmp := array ;
19423: LD_ADDR_VAR 0 10
19427: PUSH
19428: LD_VAR 0 1
19432: ST_TO_ADDR
// for i = 1 to length do
19433: LD_ADDR_VAR 0 6
19437: PUSH
19438: DOUBLE
19439: LD_INT 1
19441: DEC
19442: ST_TO_ADDR
19443: LD_VAR 0 11
19447: PUSH
19448: FOR_TO
19449: IFFALSE 19569
// begin for j = 1 to array do
19451: LD_ADDR_VAR 0 7
19455: PUSH
19456: DOUBLE
19457: LD_INT 1
19459: DEC
19460: ST_TO_ADDR
19461: LD_VAR 0 1
19465: PUSH
19466: FOR_TO
19467: IFFALSE 19555
// begin k := j + d ;
19469: LD_ADDR_VAR 0 8
19473: PUSH
19474: LD_VAR 0 7
19478: PUSH
19479: LD_VAR 0 9
19483: PLUS
19484: ST_TO_ADDR
// if k > array then
19485: LD_VAR 0 8
19489: PUSH
19490: LD_VAR 0 1
19494: GREATER
19495: IFFALSE 19505
// k := 1 ;
19497: LD_ADDR_VAR 0 8
19501: PUSH
19502: LD_INT 1
19504: ST_TO_ADDR
// if not k then
19505: LD_VAR 0 8
19509: NOT
19510: IFFALSE 19522
// k := array ;
19512: LD_ADDR_VAR 0 8
19516: PUSH
19517: LD_VAR 0 1
19521: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19522: LD_ADDR_VAR 0 10
19526: PUSH
19527: LD_VAR 0 10
19531: PPUSH
19532: LD_VAR 0 8
19536: PPUSH
19537: LD_VAR 0 1
19541: PUSH
19542: LD_VAR 0 7
19546: ARRAY
19547: PPUSH
19548: CALL_OW 1
19552: ST_TO_ADDR
// end ;
19553: GO 19466
19555: POP
19556: POP
// array := tmp ;
19557: LD_ADDR_VAR 0 1
19561: PUSH
19562: LD_VAR 0 10
19566: ST_TO_ADDR
// end ;
19567: GO 19448
19569: POP
19570: POP
// result := array ;
19571: LD_ADDR_VAR 0 5
19575: PUSH
19576: LD_VAR 0 1
19580: ST_TO_ADDR
// end ;
19581: LD_VAR 0 5
19585: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19586: LD_INT 0
19588: PPUSH
19589: PPUSH
// result := 0 ;
19590: LD_ADDR_VAR 0 3
19594: PUSH
19595: LD_INT 0
19597: ST_TO_ADDR
// if not array or not value in array then
19598: LD_VAR 0 1
19602: NOT
19603: PUSH
19604: LD_VAR 0 2
19608: PUSH
19609: LD_VAR 0 1
19613: IN
19614: NOT
19615: OR
19616: IFFALSE 19620
// exit ;
19618: GO 19674
// for i = 1 to array do
19620: LD_ADDR_VAR 0 4
19624: PUSH
19625: DOUBLE
19626: LD_INT 1
19628: DEC
19629: ST_TO_ADDR
19630: LD_VAR 0 1
19634: PUSH
19635: FOR_TO
19636: IFFALSE 19672
// if value = array [ i ] then
19638: LD_VAR 0 2
19642: PUSH
19643: LD_VAR 0 1
19647: PUSH
19648: LD_VAR 0 4
19652: ARRAY
19653: EQUAL
19654: IFFALSE 19670
// begin result := i ;
19656: LD_ADDR_VAR 0 3
19660: PUSH
19661: LD_VAR 0 4
19665: ST_TO_ADDR
// exit ;
19666: POP
19667: POP
19668: GO 19674
// end ;
19670: GO 19635
19672: POP
19673: POP
// end ;
19674: LD_VAR 0 3
19678: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19679: LD_INT 0
19681: PPUSH
// vc_chassis := chassis ;
19682: LD_ADDR_OWVAR 37
19686: PUSH
19687: LD_VAR 0 1
19691: ST_TO_ADDR
// vc_engine := engine ;
19692: LD_ADDR_OWVAR 39
19696: PUSH
19697: LD_VAR 0 2
19701: ST_TO_ADDR
// vc_control := control ;
19702: LD_ADDR_OWVAR 38
19706: PUSH
19707: LD_VAR 0 3
19711: ST_TO_ADDR
// vc_weapon := weapon ;
19712: LD_ADDR_OWVAR 40
19716: PUSH
19717: LD_VAR 0 4
19721: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19722: LD_ADDR_OWVAR 41
19726: PUSH
19727: LD_VAR 0 5
19731: ST_TO_ADDR
// end ;
19732: LD_VAR 0 6
19736: RET
// export function WantPlant ( unit ) ; var task ; begin
19737: LD_INT 0
19739: PPUSH
19740: PPUSH
// result := false ;
19741: LD_ADDR_VAR 0 2
19745: PUSH
19746: LD_INT 0
19748: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19749: LD_ADDR_VAR 0 3
19753: PUSH
19754: LD_VAR 0 1
19758: PPUSH
19759: CALL_OW 437
19763: ST_TO_ADDR
// if task then
19764: LD_VAR 0 3
19768: IFFALSE 19796
// if task [ 1 ] [ 1 ] = p then
19770: LD_VAR 0 3
19774: PUSH
19775: LD_INT 1
19777: ARRAY
19778: PUSH
19779: LD_INT 1
19781: ARRAY
19782: PUSH
19783: LD_STRING p
19785: EQUAL
19786: IFFALSE 19796
// result := true ;
19788: LD_ADDR_VAR 0 2
19792: PUSH
19793: LD_INT 1
19795: ST_TO_ADDR
// end ;
19796: LD_VAR 0 2
19800: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19801: LD_INT 0
19803: PPUSH
19804: PPUSH
19805: PPUSH
19806: PPUSH
// if pos < 1 then
19807: LD_VAR 0 2
19811: PUSH
19812: LD_INT 1
19814: LESS
19815: IFFALSE 19819
// exit ;
19817: GO 20122
// if pos = 1 then
19819: LD_VAR 0 2
19823: PUSH
19824: LD_INT 1
19826: EQUAL
19827: IFFALSE 19860
// result := Replace ( arr , pos [ 1 ] , value ) else
19829: LD_ADDR_VAR 0 4
19833: PUSH
19834: LD_VAR 0 1
19838: PPUSH
19839: LD_VAR 0 2
19843: PUSH
19844: LD_INT 1
19846: ARRAY
19847: PPUSH
19848: LD_VAR 0 3
19852: PPUSH
19853: CALL_OW 1
19857: ST_TO_ADDR
19858: GO 20122
// begin tmp := arr ;
19860: LD_ADDR_VAR 0 6
19864: PUSH
19865: LD_VAR 0 1
19869: ST_TO_ADDR
// s_arr := [ tmp ] ;
19870: LD_ADDR_VAR 0 7
19874: PUSH
19875: LD_VAR 0 6
19879: PUSH
19880: EMPTY
19881: LIST
19882: ST_TO_ADDR
// for i = 1 to pos - 1 do
19883: LD_ADDR_VAR 0 5
19887: PUSH
19888: DOUBLE
19889: LD_INT 1
19891: DEC
19892: ST_TO_ADDR
19893: LD_VAR 0 2
19897: PUSH
19898: LD_INT 1
19900: MINUS
19901: PUSH
19902: FOR_TO
19903: IFFALSE 19948
// begin tmp := tmp [ pos [ i ] ] ;
19905: LD_ADDR_VAR 0 6
19909: PUSH
19910: LD_VAR 0 6
19914: PUSH
19915: LD_VAR 0 2
19919: PUSH
19920: LD_VAR 0 5
19924: ARRAY
19925: ARRAY
19926: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19927: LD_ADDR_VAR 0 7
19931: PUSH
19932: LD_VAR 0 7
19936: PUSH
19937: LD_VAR 0 6
19941: PUSH
19942: EMPTY
19943: LIST
19944: ADD
19945: ST_TO_ADDR
// end ;
19946: GO 19902
19948: POP
19949: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19950: LD_ADDR_VAR 0 6
19954: PUSH
19955: LD_VAR 0 6
19959: PPUSH
19960: LD_VAR 0 2
19964: PUSH
19965: LD_VAR 0 2
19969: ARRAY
19970: PPUSH
19971: LD_VAR 0 3
19975: PPUSH
19976: CALL_OW 1
19980: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19981: LD_ADDR_VAR 0 7
19985: PUSH
19986: LD_VAR 0 7
19990: PPUSH
19991: LD_VAR 0 7
19995: PPUSH
19996: LD_VAR 0 6
20000: PPUSH
20001: CALL_OW 1
20005: ST_TO_ADDR
// for i = s_arr downto 2 do
20006: LD_ADDR_VAR 0 5
20010: PUSH
20011: DOUBLE
20012: LD_VAR 0 7
20016: INC
20017: ST_TO_ADDR
20018: LD_INT 2
20020: PUSH
20021: FOR_DOWNTO
20022: IFFALSE 20106
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20024: LD_ADDR_VAR 0 6
20028: PUSH
20029: LD_VAR 0 7
20033: PUSH
20034: LD_VAR 0 5
20038: PUSH
20039: LD_INT 1
20041: MINUS
20042: ARRAY
20043: PPUSH
20044: LD_VAR 0 2
20048: PUSH
20049: LD_VAR 0 5
20053: PUSH
20054: LD_INT 1
20056: MINUS
20057: ARRAY
20058: PPUSH
20059: LD_VAR 0 7
20063: PUSH
20064: LD_VAR 0 5
20068: ARRAY
20069: PPUSH
20070: CALL_OW 1
20074: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20075: LD_ADDR_VAR 0 7
20079: PUSH
20080: LD_VAR 0 7
20084: PPUSH
20085: LD_VAR 0 5
20089: PUSH
20090: LD_INT 1
20092: MINUS
20093: PPUSH
20094: LD_VAR 0 6
20098: PPUSH
20099: CALL_OW 1
20103: ST_TO_ADDR
// end ;
20104: GO 20021
20106: POP
20107: POP
// result := s_arr [ 1 ] ;
20108: LD_ADDR_VAR 0 4
20112: PUSH
20113: LD_VAR 0 7
20117: PUSH
20118: LD_INT 1
20120: ARRAY
20121: ST_TO_ADDR
// end ; end ;
20122: LD_VAR 0 4
20126: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20127: LD_INT 0
20129: PPUSH
20130: PPUSH
// if not list then
20131: LD_VAR 0 1
20135: NOT
20136: IFFALSE 20140
// exit ;
20138: GO 20231
// i := list [ pos1 ] ;
20140: LD_ADDR_VAR 0 5
20144: PUSH
20145: LD_VAR 0 1
20149: PUSH
20150: LD_VAR 0 2
20154: ARRAY
20155: ST_TO_ADDR
// if not i then
20156: LD_VAR 0 5
20160: NOT
20161: IFFALSE 20165
// exit ;
20163: GO 20231
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20165: LD_ADDR_VAR 0 1
20169: PUSH
20170: LD_VAR 0 1
20174: PPUSH
20175: LD_VAR 0 2
20179: PPUSH
20180: LD_VAR 0 1
20184: PUSH
20185: LD_VAR 0 3
20189: ARRAY
20190: PPUSH
20191: CALL_OW 1
20195: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20196: LD_ADDR_VAR 0 1
20200: PUSH
20201: LD_VAR 0 1
20205: PPUSH
20206: LD_VAR 0 3
20210: PPUSH
20211: LD_VAR 0 5
20215: PPUSH
20216: CALL_OW 1
20220: ST_TO_ADDR
// result := list ;
20221: LD_ADDR_VAR 0 4
20225: PUSH
20226: LD_VAR 0 1
20230: ST_TO_ADDR
// end ;
20231: LD_VAR 0 4
20235: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20236: LD_INT 0
20238: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20239: LD_ADDR_VAR 0 5
20243: PUSH
20244: LD_VAR 0 1
20248: PPUSH
20249: CALL_OW 250
20253: PPUSH
20254: LD_VAR 0 1
20258: PPUSH
20259: CALL_OW 251
20263: PPUSH
20264: LD_VAR 0 2
20268: PPUSH
20269: LD_VAR 0 3
20273: PPUSH
20274: LD_VAR 0 4
20278: PPUSH
20279: CALL 20289 0 5
20283: ST_TO_ADDR
// end ;
20284: LD_VAR 0 5
20288: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20289: LD_INT 0
20291: PPUSH
20292: PPUSH
20293: PPUSH
20294: PPUSH
// if not list then
20295: LD_VAR 0 3
20299: NOT
20300: IFFALSE 20304
// exit ;
20302: GO 20692
// result := [ ] ;
20304: LD_ADDR_VAR 0 6
20308: PUSH
20309: EMPTY
20310: ST_TO_ADDR
// for i in list do
20311: LD_ADDR_VAR 0 7
20315: PUSH
20316: LD_VAR 0 3
20320: PUSH
20321: FOR_IN
20322: IFFALSE 20524
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20324: LD_ADDR_VAR 0 9
20328: PUSH
20329: LD_VAR 0 7
20333: PPUSH
20334: LD_VAR 0 1
20338: PPUSH
20339: LD_VAR 0 2
20343: PPUSH
20344: CALL_OW 297
20348: ST_TO_ADDR
// if not result then
20349: LD_VAR 0 6
20353: NOT
20354: IFFALSE 20380
// result := [ [ i , tmp ] ] else
20356: LD_ADDR_VAR 0 6
20360: PUSH
20361: LD_VAR 0 7
20365: PUSH
20366: LD_VAR 0 9
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: PUSH
20375: EMPTY
20376: LIST
20377: ST_TO_ADDR
20378: GO 20522
// begin if result [ result ] [ 2 ] < tmp then
20380: LD_VAR 0 6
20384: PUSH
20385: LD_VAR 0 6
20389: ARRAY
20390: PUSH
20391: LD_INT 2
20393: ARRAY
20394: PUSH
20395: LD_VAR 0 9
20399: LESS
20400: IFFALSE 20442
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20402: LD_ADDR_VAR 0 6
20406: PUSH
20407: LD_VAR 0 6
20411: PPUSH
20412: LD_VAR 0 6
20416: PUSH
20417: LD_INT 1
20419: PLUS
20420: PPUSH
20421: LD_VAR 0 7
20425: PUSH
20426: LD_VAR 0 9
20430: PUSH
20431: EMPTY
20432: LIST
20433: LIST
20434: PPUSH
20435: CALL_OW 2
20439: ST_TO_ADDR
20440: GO 20522
// for j = 1 to result do
20442: LD_ADDR_VAR 0 8
20446: PUSH
20447: DOUBLE
20448: LD_INT 1
20450: DEC
20451: ST_TO_ADDR
20452: LD_VAR 0 6
20456: PUSH
20457: FOR_TO
20458: IFFALSE 20520
// begin if tmp < result [ j ] [ 2 ] then
20460: LD_VAR 0 9
20464: PUSH
20465: LD_VAR 0 6
20469: PUSH
20470: LD_VAR 0 8
20474: ARRAY
20475: PUSH
20476: LD_INT 2
20478: ARRAY
20479: LESS
20480: IFFALSE 20518
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20482: LD_ADDR_VAR 0 6
20486: PUSH
20487: LD_VAR 0 6
20491: PPUSH
20492: LD_VAR 0 8
20496: PPUSH
20497: LD_VAR 0 7
20501: PUSH
20502: LD_VAR 0 9
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: PPUSH
20511: CALL_OW 2
20515: ST_TO_ADDR
// break ;
20516: GO 20520
// end ; end ;
20518: GO 20457
20520: POP
20521: POP
// end ; end ;
20522: GO 20321
20524: POP
20525: POP
// if result and not asc then
20526: LD_VAR 0 6
20530: PUSH
20531: LD_VAR 0 4
20535: NOT
20536: AND
20537: IFFALSE 20612
// begin tmp := result ;
20539: LD_ADDR_VAR 0 9
20543: PUSH
20544: LD_VAR 0 6
20548: ST_TO_ADDR
// for i = tmp downto 1 do
20549: LD_ADDR_VAR 0 7
20553: PUSH
20554: DOUBLE
20555: LD_VAR 0 9
20559: INC
20560: ST_TO_ADDR
20561: LD_INT 1
20563: PUSH
20564: FOR_DOWNTO
20565: IFFALSE 20610
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 6
20576: PPUSH
20577: LD_VAR 0 9
20581: PUSH
20582: LD_VAR 0 7
20586: MINUS
20587: PUSH
20588: LD_INT 1
20590: PLUS
20591: PPUSH
20592: LD_VAR 0 9
20596: PUSH
20597: LD_VAR 0 7
20601: ARRAY
20602: PPUSH
20603: CALL_OW 1
20607: ST_TO_ADDR
20608: GO 20564
20610: POP
20611: POP
// end ; tmp := [ ] ;
20612: LD_ADDR_VAR 0 9
20616: PUSH
20617: EMPTY
20618: ST_TO_ADDR
// if mode then
20619: LD_VAR 0 5
20623: IFFALSE 20692
// begin for i = 1 to result do
20625: LD_ADDR_VAR 0 7
20629: PUSH
20630: DOUBLE
20631: LD_INT 1
20633: DEC
20634: ST_TO_ADDR
20635: LD_VAR 0 6
20639: PUSH
20640: FOR_TO
20641: IFFALSE 20680
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20643: LD_ADDR_VAR 0 9
20647: PUSH
20648: LD_VAR 0 9
20652: PPUSH
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 6
20662: PUSH
20663: LD_VAR 0 7
20667: ARRAY
20668: PUSH
20669: LD_INT 1
20671: ARRAY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
20678: GO 20640
20680: POP
20681: POP
// result := tmp ;
20682: LD_ADDR_VAR 0 6
20686: PUSH
20687: LD_VAR 0 9
20691: ST_TO_ADDR
// end ; end ;
20692: LD_VAR 0 6
20696: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20697: LD_INT 0
20699: PPUSH
20700: PPUSH
20701: PPUSH
20702: PPUSH
20703: PPUSH
20704: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20705: LD_ADDR_VAR 0 5
20709: PUSH
20710: LD_INT 0
20712: PUSH
20713: LD_INT 0
20715: PUSH
20716: LD_INT 0
20718: PUSH
20719: EMPTY
20720: PUSH
20721: EMPTY
20722: LIST
20723: LIST
20724: LIST
20725: LIST
20726: ST_TO_ADDR
// if not x or not y then
20727: LD_VAR 0 2
20731: NOT
20732: PUSH
20733: LD_VAR 0 3
20737: NOT
20738: OR
20739: IFFALSE 20743
// exit ;
20741: GO 22395
// if not range then
20743: LD_VAR 0 4
20747: NOT
20748: IFFALSE 20758
// range := 10 ;
20750: LD_ADDR_VAR 0 4
20754: PUSH
20755: LD_INT 10
20757: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20758: LD_ADDR_VAR 0 8
20762: PUSH
20763: LD_INT 81
20765: PUSH
20766: LD_VAR 0 1
20770: PUSH
20771: EMPTY
20772: LIST
20773: LIST
20774: PUSH
20775: LD_INT 92
20777: PUSH
20778: LD_VAR 0 2
20782: PUSH
20783: LD_VAR 0 3
20787: PUSH
20788: LD_VAR 0 4
20792: PUSH
20793: EMPTY
20794: LIST
20795: LIST
20796: LIST
20797: LIST
20798: PUSH
20799: LD_INT 3
20801: PUSH
20802: LD_INT 21
20804: PUSH
20805: LD_INT 3
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PUSH
20812: EMPTY
20813: LIST
20814: LIST
20815: PUSH
20816: EMPTY
20817: LIST
20818: LIST
20819: LIST
20820: PPUSH
20821: CALL_OW 69
20825: ST_TO_ADDR
// if not tmp then
20826: LD_VAR 0 8
20830: NOT
20831: IFFALSE 20835
// exit ;
20833: GO 22395
// for i in tmp do
20835: LD_ADDR_VAR 0 6
20839: PUSH
20840: LD_VAR 0 8
20844: PUSH
20845: FOR_IN
20846: IFFALSE 22370
// begin points := [ 0 , 0 , 0 ] ;
20848: LD_ADDR_VAR 0 9
20852: PUSH
20853: LD_INT 0
20855: PUSH
20856: LD_INT 0
20858: PUSH
20859: LD_INT 0
20861: PUSH
20862: EMPTY
20863: LIST
20864: LIST
20865: LIST
20866: ST_TO_ADDR
// bpoints := 1 ;
20867: LD_ADDR_VAR 0 10
20871: PUSH
20872: LD_INT 1
20874: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20875: LD_VAR 0 6
20879: PPUSH
20880: CALL_OW 247
20884: PUSH
20885: LD_INT 1
20887: DOUBLE
20888: EQUAL
20889: IFTRUE 20893
20891: GO 21471
20893: POP
// begin if GetClass ( i ) = 1 then
20894: LD_VAR 0 6
20898: PPUSH
20899: CALL_OW 257
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20928
// points := [ 10 , 5 , 3 ] ;
20909: LD_ADDR_VAR 0 9
20913: PUSH
20914: LD_INT 10
20916: PUSH
20917: LD_INT 5
20919: PUSH
20920: LD_INT 3
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: LIST
20927: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20928: LD_VAR 0 6
20932: PPUSH
20933: CALL_OW 257
20937: PUSH
20938: LD_INT 2
20940: PUSH
20941: LD_INT 3
20943: PUSH
20944: LD_INT 4
20946: PUSH
20947: EMPTY
20948: LIST
20949: LIST
20950: LIST
20951: IN
20952: IFFALSE 20973
// points := [ 3 , 2 , 1 ] ;
20954: LD_ADDR_VAR 0 9
20958: PUSH
20959: LD_INT 3
20961: PUSH
20962: LD_INT 2
20964: PUSH
20965: LD_INT 1
20967: PUSH
20968: EMPTY
20969: LIST
20970: LIST
20971: LIST
20972: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20973: LD_VAR 0 6
20977: PPUSH
20978: CALL_OW 257
20982: PUSH
20983: LD_INT 5
20985: EQUAL
20986: IFFALSE 21007
// points := [ 130 , 5 , 2 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 130
20995: PUSH
20996: LD_INT 5
20998: PUSH
20999: LD_INT 2
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 257
21016: PUSH
21017: LD_INT 8
21019: EQUAL
21020: IFFALSE 21041
// points := [ 35 , 35 , 30 ] ;
21022: LD_ADDR_VAR 0 9
21026: PUSH
21027: LD_INT 35
21029: PUSH
21030: LD_INT 35
21032: PUSH
21033: LD_INT 30
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: LIST
21040: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21041: LD_VAR 0 6
21045: PPUSH
21046: CALL_OW 257
21050: PUSH
21051: LD_INT 9
21053: EQUAL
21054: IFFALSE 21075
// points := [ 20 , 55 , 40 ] ;
21056: LD_ADDR_VAR 0 9
21060: PUSH
21061: LD_INT 20
21063: PUSH
21064: LD_INT 55
21066: PUSH
21067: LD_INT 40
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: LIST
21074: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21075: LD_VAR 0 6
21079: PPUSH
21080: CALL_OW 257
21084: PUSH
21085: LD_INT 12
21087: PUSH
21088: LD_INT 16
21090: PUSH
21091: EMPTY
21092: LIST
21093: LIST
21094: IN
21095: IFFALSE 21116
// points := [ 5 , 3 , 2 ] ;
21097: LD_ADDR_VAR 0 9
21101: PUSH
21102: LD_INT 5
21104: PUSH
21105: LD_INT 3
21107: PUSH
21108: LD_INT 2
21110: PUSH
21111: EMPTY
21112: LIST
21113: LIST
21114: LIST
21115: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21116: LD_VAR 0 6
21120: PPUSH
21121: CALL_OW 257
21125: PUSH
21126: LD_INT 17
21128: EQUAL
21129: IFFALSE 21150
// points := [ 100 , 50 , 75 ] ;
21131: LD_ADDR_VAR 0 9
21135: PUSH
21136: LD_INT 100
21138: PUSH
21139: LD_INT 50
21141: PUSH
21142: LD_INT 75
21144: PUSH
21145: EMPTY
21146: LIST
21147: LIST
21148: LIST
21149: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21150: LD_VAR 0 6
21154: PPUSH
21155: CALL_OW 257
21159: PUSH
21160: LD_INT 15
21162: EQUAL
21163: IFFALSE 21184
// points := [ 10 , 5 , 3 ] ;
21165: LD_ADDR_VAR 0 9
21169: PUSH
21170: LD_INT 10
21172: PUSH
21173: LD_INT 5
21175: PUSH
21176: LD_INT 3
21178: PUSH
21179: EMPTY
21180: LIST
21181: LIST
21182: LIST
21183: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21184: LD_VAR 0 6
21188: PPUSH
21189: CALL_OW 257
21193: PUSH
21194: LD_INT 14
21196: EQUAL
21197: IFFALSE 21218
// points := [ 10 , 0 , 0 ] ;
21199: LD_ADDR_VAR 0 9
21203: PUSH
21204: LD_INT 10
21206: PUSH
21207: LD_INT 0
21209: PUSH
21210: LD_INT 0
21212: PUSH
21213: EMPTY
21214: LIST
21215: LIST
21216: LIST
21217: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21218: LD_VAR 0 6
21222: PPUSH
21223: CALL_OW 257
21227: PUSH
21228: LD_INT 11
21230: EQUAL
21231: IFFALSE 21252
// points := [ 30 , 10 , 5 ] ;
21233: LD_ADDR_VAR 0 9
21237: PUSH
21238: LD_INT 30
21240: PUSH
21241: LD_INT 10
21243: PUSH
21244: LD_INT 5
21246: PUSH
21247: EMPTY
21248: LIST
21249: LIST
21250: LIST
21251: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21252: LD_VAR 0 1
21256: PPUSH
21257: LD_INT 5
21259: PPUSH
21260: CALL_OW 321
21264: PUSH
21265: LD_INT 2
21267: EQUAL
21268: IFFALSE 21285
// bpoints := bpoints * 1.8 ;
21270: LD_ADDR_VAR 0 10
21274: PUSH
21275: LD_VAR 0 10
21279: PUSH
21280: LD_REAL  1.80000000000000E+0000
21283: MUL
21284: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21285: LD_VAR 0 6
21289: PPUSH
21290: CALL_OW 257
21294: PUSH
21295: LD_INT 1
21297: PUSH
21298: LD_INT 2
21300: PUSH
21301: LD_INT 3
21303: PUSH
21304: LD_INT 4
21306: PUSH
21307: EMPTY
21308: LIST
21309: LIST
21310: LIST
21311: LIST
21312: IN
21313: PUSH
21314: LD_VAR 0 1
21318: PPUSH
21319: LD_INT 51
21321: PPUSH
21322: CALL_OW 321
21326: PUSH
21327: LD_INT 2
21329: EQUAL
21330: AND
21331: IFFALSE 21348
// bpoints := bpoints * 1.2 ;
21333: LD_ADDR_VAR 0 10
21337: PUSH
21338: LD_VAR 0 10
21342: PUSH
21343: LD_REAL  1.20000000000000E+0000
21346: MUL
21347: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21348: LD_VAR 0 6
21352: PPUSH
21353: CALL_OW 257
21357: PUSH
21358: LD_INT 5
21360: PUSH
21361: LD_INT 7
21363: PUSH
21364: LD_INT 9
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: LIST
21371: IN
21372: PUSH
21373: LD_VAR 0 1
21377: PPUSH
21378: LD_INT 52
21380: PPUSH
21381: CALL_OW 321
21385: PUSH
21386: LD_INT 2
21388: EQUAL
21389: AND
21390: IFFALSE 21407
// bpoints := bpoints * 1.5 ;
21392: LD_ADDR_VAR 0 10
21396: PUSH
21397: LD_VAR 0 10
21401: PUSH
21402: LD_REAL  1.50000000000000E+0000
21405: MUL
21406: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21407: LD_VAR 0 1
21411: PPUSH
21412: LD_INT 66
21414: PPUSH
21415: CALL_OW 321
21419: PUSH
21420: LD_INT 2
21422: EQUAL
21423: IFFALSE 21440
// bpoints := bpoints * 1.1 ;
21425: LD_ADDR_VAR 0 10
21429: PUSH
21430: LD_VAR 0 10
21434: PUSH
21435: LD_REAL  1.10000000000000E+0000
21438: MUL
21439: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21440: LD_ADDR_VAR 0 10
21444: PUSH
21445: LD_VAR 0 10
21449: PUSH
21450: LD_VAR 0 6
21454: PPUSH
21455: LD_INT 1
21457: PPUSH
21458: CALL_OW 259
21462: PUSH
21463: LD_REAL  1.15000000000000E+0000
21466: MUL
21467: MUL
21468: ST_TO_ADDR
// end ; unit_vehicle :
21469: GO 22299
21471: LD_INT 2
21473: DOUBLE
21474: EQUAL
21475: IFTRUE 21479
21477: GO 22287
21479: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21480: LD_VAR 0 6
21484: PPUSH
21485: CALL_OW 264
21489: PUSH
21490: LD_INT 2
21492: PUSH
21493: LD_INT 42
21495: PUSH
21496: LD_INT 24
21498: PUSH
21499: EMPTY
21500: LIST
21501: LIST
21502: LIST
21503: IN
21504: IFFALSE 21525
// points := [ 25 , 5 , 3 ] ;
21506: LD_ADDR_VAR 0 9
21510: PUSH
21511: LD_INT 25
21513: PUSH
21514: LD_INT 5
21516: PUSH
21517: LD_INT 3
21519: PUSH
21520: EMPTY
21521: LIST
21522: LIST
21523: LIST
21524: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21525: LD_VAR 0 6
21529: PPUSH
21530: CALL_OW 264
21534: PUSH
21535: LD_INT 4
21537: PUSH
21538: LD_INT 43
21540: PUSH
21541: LD_INT 25
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: LIST
21548: IN
21549: IFFALSE 21570
// points := [ 40 , 15 , 5 ] ;
21551: LD_ADDR_VAR 0 9
21555: PUSH
21556: LD_INT 40
21558: PUSH
21559: LD_INT 15
21561: PUSH
21562: LD_INT 5
21564: PUSH
21565: EMPTY
21566: LIST
21567: LIST
21568: LIST
21569: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21570: LD_VAR 0 6
21574: PPUSH
21575: CALL_OW 264
21579: PUSH
21580: LD_INT 3
21582: PUSH
21583: LD_INT 23
21585: PUSH
21586: EMPTY
21587: LIST
21588: LIST
21589: IN
21590: IFFALSE 21611
// points := [ 7 , 25 , 8 ] ;
21592: LD_ADDR_VAR 0 9
21596: PUSH
21597: LD_INT 7
21599: PUSH
21600: LD_INT 25
21602: PUSH
21603: LD_INT 8
21605: PUSH
21606: EMPTY
21607: LIST
21608: LIST
21609: LIST
21610: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21611: LD_VAR 0 6
21615: PPUSH
21616: CALL_OW 264
21620: PUSH
21621: LD_INT 5
21623: PUSH
21624: LD_INT 27
21626: PUSH
21627: LD_INT 44
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: LIST
21634: IN
21635: IFFALSE 21656
// points := [ 14 , 50 , 16 ] ;
21637: LD_ADDR_VAR 0 9
21641: PUSH
21642: LD_INT 14
21644: PUSH
21645: LD_INT 50
21647: PUSH
21648: LD_INT 16
21650: PUSH
21651: EMPTY
21652: LIST
21653: LIST
21654: LIST
21655: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21656: LD_VAR 0 6
21660: PPUSH
21661: CALL_OW 264
21665: PUSH
21666: LD_INT 6
21668: PUSH
21669: LD_INT 46
21671: PUSH
21672: EMPTY
21673: LIST
21674: LIST
21675: IN
21676: IFFALSE 21697
// points := [ 32 , 120 , 70 ] ;
21678: LD_ADDR_VAR 0 9
21682: PUSH
21683: LD_INT 32
21685: PUSH
21686: LD_INT 120
21688: PUSH
21689: LD_INT 70
21691: PUSH
21692: EMPTY
21693: LIST
21694: LIST
21695: LIST
21696: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21697: LD_VAR 0 6
21701: PPUSH
21702: CALL_OW 264
21706: PUSH
21707: LD_INT 7
21709: PUSH
21710: LD_INT 28
21712: PUSH
21713: LD_INT 45
21715: PUSH
21716: LD_EXP 109
21720: PUSH
21721: EMPTY
21722: LIST
21723: LIST
21724: LIST
21725: LIST
21726: IN
21727: IFFALSE 21748
// points := [ 35 , 20 , 45 ] ;
21729: LD_ADDR_VAR 0 9
21733: PUSH
21734: LD_INT 35
21736: PUSH
21737: LD_INT 20
21739: PUSH
21740: LD_INT 45
21742: PUSH
21743: EMPTY
21744: LIST
21745: LIST
21746: LIST
21747: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21748: LD_VAR 0 6
21752: PPUSH
21753: CALL_OW 264
21757: PUSH
21758: LD_INT 47
21760: PUSH
21761: EMPTY
21762: LIST
21763: IN
21764: IFFALSE 21785
// points := [ 67 , 45 , 75 ] ;
21766: LD_ADDR_VAR 0 9
21770: PUSH
21771: LD_INT 67
21773: PUSH
21774: LD_INT 45
21776: PUSH
21777: LD_INT 75
21779: PUSH
21780: EMPTY
21781: LIST
21782: LIST
21783: LIST
21784: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21785: LD_VAR 0 6
21789: PPUSH
21790: CALL_OW 264
21794: PUSH
21795: LD_INT 26
21797: PUSH
21798: EMPTY
21799: LIST
21800: IN
21801: IFFALSE 21822
// points := [ 120 , 30 , 80 ] ;
21803: LD_ADDR_VAR 0 9
21807: PUSH
21808: LD_INT 120
21810: PUSH
21811: LD_INT 30
21813: PUSH
21814: LD_INT 80
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: LIST
21821: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21822: LD_VAR 0 6
21826: PPUSH
21827: CALL_OW 264
21831: PUSH
21832: LD_INT 22
21834: PUSH
21835: EMPTY
21836: LIST
21837: IN
21838: IFFALSE 21859
// points := [ 40 , 1 , 1 ] ;
21840: LD_ADDR_VAR 0 9
21844: PUSH
21845: LD_INT 40
21847: PUSH
21848: LD_INT 1
21850: PUSH
21851: LD_INT 1
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: LIST
21858: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21859: LD_VAR 0 6
21863: PPUSH
21864: CALL_OW 264
21868: PUSH
21869: LD_INT 29
21871: PUSH
21872: EMPTY
21873: LIST
21874: IN
21875: IFFALSE 21896
// points := [ 70 , 200 , 400 ] ;
21877: LD_ADDR_VAR 0 9
21881: PUSH
21882: LD_INT 70
21884: PUSH
21885: LD_INT 200
21887: PUSH
21888: LD_INT 400
21890: PUSH
21891: EMPTY
21892: LIST
21893: LIST
21894: LIST
21895: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21896: LD_VAR 0 6
21900: PPUSH
21901: CALL_OW 264
21905: PUSH
21906: LD_INT 14
21908: PUSH
21909: LD_INT 53
21911: PUSH
21912: EMPTY
21913: LIST
21914: LIST
21915: IN
21916: IFFALSE 21937
// points := [ 40 , 10 , 20 ] ;
21918: LD_ADDR_VAR 0 9
21922: PUSH
21923: LD_INT 40
21925: PUSH
21926: LD_INT 10
21928: PUSH
21929: LD_INT 20
21931: PUSH
21932: EMPTY
21933: LIST
21934: LIST
21935: LIST
21936: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21937: LD_VAR 0 6
21941: PPUSH
21942: CALL_OW 264
21946: PUSH
21947: LD_INT 9
21949: PUSH
21950: EMPTY
21951: LIST
21952: IN
21953: IFFALSE 21974
// points := [ 5 , 70 , 20 ] ;
21955: LD_ADDR_VAR 0 9
21959: PUSH
21960: LD_INT 5
21962: PUSH
21963: LD_INT 70
21965: PUSH
21966: LD_INT 20
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21974: LD_VAR 0 6
21978: PPUSH
21979: CALL_OW 264
21983: PUSH
21984: LD_INT 10
21986: PUSH
21987: EMPTY
21988: LIST
21989: IN
21990: IFFALSE 22011
// points := [ 35 , 110 , 70 ] ;
21992: LD_ADDR_VAR 0 9
21996: PUSH
21997: LD_INT 35
21999: PUSH
22000: LD_INT 110
22002: PUSH
22003: LD_INT 70
22005: PUSH
22006: EMPTY
22007: LIST
22008: LIST
22009: LIST
22010: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22011: LD_VAR 0 6
22015: PPUSH
22016: CALL_OW 265
22020: PUSH
22021: LD_INT 25
22023: EQUAL
22024: IFFALSE 22045
// points := [ 80 , 65 , 100 ] ;
22026: LD_ADDR_VAR 0 9
22030: PUSH
22031: LD_INT 80
22033: PUSH
22034: LD_INT 65
22036: PUSH
22037: LD_INT 100
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: LIST
22044: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22045: LD_VAR 0 6
22049: PPUSH
22050: CALL_OW 263
22054: PUSH
22055: LD_INT 1
22057: EQUAL
22058: IFFALSE 22093
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22060: LD_ADDR_VAR 0 10
22064: PUSH
22065: LD_VAR 0 10
22069: PUSH
22070: LD_VAR 0 6
22074: PPUSH
22075: CALL_OW 311
22079: PPUSH
22080: LD_INT 3
22082: PPUSH
22083: CALL_OW 259
22087: PUSH
22088: LD_INT 4
22090: MUL
22091: MUL
22092: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22093: LD_VAR 0 6
22097: PPUSH
22098: CALL_OW 263
22102: PUSH
22103: LD_INT 2
22105: EQUAL
22106: IFFALSE 22157
// begin j := IsControledBy ( i ) ;
22108: LD_ADDR_VAR 0 7
22112: PUSH
22113: LD_VAR 0 6
22117: PPUSH
22118: CALL_OW 312
22122: ST_TO_ADDR
// if j then
22123: LD_VAR 0 7
22127: IFFALSE 22157
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22129: LD_ADDR_VAR 0 10
22133: PUSH
22134: LD_VAR 0 10
22138: PUSH
22139: LD_VAR 0 7
22143: PPUSH
22144: LD_INT 3
22146: PPUSH
22147: CALL_OW 259
22151: PUSH
22152: LD_INT 3
22154: MUL
22155: MUL
22156: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22157: LD_VAR 0 6
22161: PPUSH
22162: CALL_OW 264
22166: PUSH
22167: LD_INT 5
22169: PUSH
22170: LD_INT 6
22172: PUSH
22173: LD_INT 46
22175: PUSH
22176: LD_INT 44
22178: PUSH
22179: LD_INT 47
22181: PUSH
22182: LD_INT 45
22184: PUSH
22185: LD_INT 28
22187: PUSH
22188: LD_INT 7
22190: PUSH
22191: LD_INT 27
22193: PUSH
22194: LD_INT 29
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: LIST
22201: LIST
22202: LIST
22203: LIST
22204: LIST
22205: LIST
22206: LIST
22207: LIST
22208: IN
22209: PUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: LD_INT 52
22217: PPUSH
22218: CALL_OW 321
22222: PUSH
22223: LD_INT 2
22225: EQUAL
22226: AND
22227: IFFALSE 22244
// bpoints := bpoints * 1.2 ;
22229: LD_ADDR_VAR 0 10
22233: PUSH
22234: LD_VAR 0 10
22238: PUSH
22239: LD_REAL  1.20000000000000E+0000
22242: MUL
22243: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22244: LD_VAR 0 6
22248: PPUSH
22249: CALL_OW 264
22253: PUSH
22254: LD_INT 6
22256: PUSH
22257: LD_INT 46
22259: PUSH
22260: LD_INT 47
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: LIST
22267: IN
22268: IFFALSE 22285
// bpoints := bpoints * 1.2 ;
22270: LD_ADDR_VAR 0 10
22274: PUSH
22275: LD_VAR 0 10
22279: PUSH
22280: LD_REAL  1.20000000000000E+0000
22283: MUL
22284: ST_TO_ADDR
// end ; unit_building :
22285: GO 22299
22287: LD_INT 3
22289: DOUBLE
22290: EQUAL
22291: IFTRUE 22295
22293: GO 22298
22295: POP
// ; end ;
22296: GO 22299
22298: POP
// for j = 1 to 3 do
22299: LD_ADDR_VAR 0 7
22303: PUSH
22304: DOUBLE
22305: LD_INT 1
22307: DEC
22308: ST_TO_ADDR
22309: LD_INT 3
22311: PUSH
22312: FOR_TO
22313: IFFALSE 22366
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22315: LD_ADDR_VAR 0 5
22319: PUSH
22320: LD_VAR 0 5
22324: PPUSH
22325: LD_VAR 0 7
22329: PPUSH
22330: LD_VAR 0 5
22334: PUSH
22335: LD_VAR 0 7
22339: ARRAY
22340: PUSH
22341: LD_VAR 0 9
22345: PUSH
22346: LD_VAR 0 7
22350: ARRAY
22351: PUSH
22352: LD_VAR 0 10
22356: MUL
22357: PLUS
22358: PPUSH
22359: CALL_OW 1
22363: ST_TO_ADDR
22364: GO 22312
22366: POP
22367: POP
// end ;
22368: GO 20845
22370: POP
22371: POP
// result := Replace ( result , 4 , tmp ) ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 5
22381: PPUSH
22382: LD_INT 4
22384: PPUSH
22385: LD_VAR 0 8
22389: PPUSH
22390: CALL_OW 1
22394: ST_TO_ADDR
// end ;
22395: LD_VAR 0 5
22399: RET
// export function DangerAtRange ( unit , range ) ; begin
22400: LD_INT 0
22402: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22403: LD_ADDR_VAR 0 3
22407: PUSH
22408: LD_VAR 0 1
22412: PPUSH
22413: CALL_OW 255
22417: PPUSH
22418: LD_VAR 0 1
22422: PPUSH
22423: CALL_OW 250
22427: PPUSH
22428: LD_VAR 0 1
22432: PPUSH
22433: CALL_OW 251
22437: PPUSH
22438: LD_VAR 0 2
22442: PPUSH
22443: CALL 20697 0 4
22447: ST_TO_ADDR
// end ;
22448: LD_VAR 0 3
22452: RET
// export function DangerInArea ( side , area ) ; begin
22453: LD_INT 0
22455: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22456: LD_ADDR_VAR 0 3
22460: PUSH
22461: LD_VAR 0 2
22465: PPUSH
22466: LD_INT 81
22468: PUSH
22469: LD_VAR 0 1
22473: PUSH
22474: EMPTY
22475: LIST
22476: LIST
22477: PPUSH
22478: CALL_OW 70
22482: ST_TO_ADDR
// end ;
22483: LD_VAR 0 3
22487: RET
// export function IsExtension ( b ) ; begin
22488: LD_INT 0
22490: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22491: LD_ADDR_VAR 0 2
22495: PUSH
22496: LD_VAR 0 1
22500: PUSH
22501: LD_INT 23
22503: PUSH
22504: LD_INT 20
22506: PUSH
22507: LD_INT 22
22509: PUSH
22510: LD_INT 17
22512: PUSH
22513: LD_INT 24
22515: PUSH
22516: LD_INT 21
22518: PUSH
22519: LD_INT 19
22521: PUSH
22522: LD_INT 16
22524: PUSH
22525: LD_INT 25
22527: PUSH
22528: LD_INT 18
22530: PUSH
22531: EMPTY
22532: LIST
22533: LIST
22534: LIST
22535: LIST
22536: LIST
22537: LIST
22538: LIST
22539: LIST
22540: LIST
22541: LIST
22542: IN
22543: ST_TO_ADDR
// end ;
22544: LD_VAR 0 2
22548: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22549: LD_INT 0
22551: PPUSH
22552: PPUSH
22553: PPUSH
// result := [ ] ;
22554: LD_ADDR_VAR 0 4
22558: PUSH
22559: EMPTY
22560: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22561: LD_ADDR_VAR 0 5
22565: PUSH
22566: LD_VAR 0 2
22570: PPUSH
22571: LD_INT 21
22573: PUSH
22574: LD_INT 3
22576: PUSH
22577: EMPTY
22578: LIST
22579: LIST
22580: PPUSH
22581: CALL_OW 70
22585: ST_TO_ADDR
// if not tmp then
22586: LD_VAR 0 5
22590: NOT
22591: IFFALSE 22595
// exit ;
22593: GO 22659
// if checkLink then
22595: LD_VAR 0 3
22599: IFFALSE 22649
// begin for i in tmp do
22601: LD_ADDR_VAR 0 6
22605: PUSH
22606: LD_VAR 0 5
22610: PUSH
22611: FOR_IN
22612: IFFALSE 22647
// if GetBase ( i ) <> base then
22614: LD_VAR 0 6
22618: PPUSH
22619: CALL_OW 274
22623: PUSH
22624: LD_VAR 0 1
22628: NONEQUAL
22629: IFFALSE 22645
// ComLinkToBase ( base , i ) ;
22631: LD_VAR 0 1
22635: PPUSH
22636: LD_VAR 0 6
22640: PPUSH
22641: CALL_OW 169
22645: GO 22611
22647: POP
22648: POP
// end ; result := tmp ;
22649: LD_ADDR_VAR 0 4
22653: PUSH
22654: LD_VAR 0 5
22658: ST_TO_ADDR
// end ;
22659: LD_VAR 0 4
22663: RET
// export function ComComplete ( units , b ) ; var i ; begin
22664: LD_INT 0
22666: PPUSH
22667: PPUSH
// if not units then
22668: LD_VAR 0 1
22672: NOT
22673: IFFALSE 22677
// exit ;
22675: GO 22767
// for i in units do
22677: LD_ADDR_VAR 0 4
22681: PUSH
22682: LD_VAR 0 1
22686: PUSH
22687: FOR_IN
22688: IFFALSE 22765
// if BuildingStatus ( b ) = bs_build then
22690: LD_VAR 0 2
22694: PPUSH
22695: CALL_OW 461
22699: PUSH
22700: LD_INT 1
22702: EQUAL
22703: IFFALSE 22763
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22705: LD_VAR 0 4
22709: PPUSH
22710: LD_STRING h
22712: PUSH
22713: LD_VAR 0 2
22717: PPUSH
22718: CALL_OW 250
22722: PUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: CALL_OW 251
22732: PUSH
22733: LD_VAR 0 2
22737: PUSH
22738: LD_INT 0
22740: PUSH
22741: LD_INT 0
22743: PUSH
22744: LD_INT 0
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: LIST
22751: LIST
22752: LIST
22753: LIST
22754: LIST
22755: PUSH
22756: EMPTY
22757: LIST
22758: PPUSH
22759: CALL_OW 446
22763: GO 22687
22765: POP
22766: POP
// end ;
22767: LD_VAR 0 3
22771: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22772: LD_INT 0
22774: PPUSH
22775: PPUSH
22776: PPUSH
22777: PPUSH
22778: PPUSH
22779: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22780: LD_VAR 0 1
22784: NOT
22785: PUSH
22786: LD_VAR 0 1
22790: PPUSH
22791: CALL_OW 263
22795: PUSH
22796: LD_INT 2
22798: NONEQUAL
22799: OR
22800: IFFALSE 22804
// exit ;
22802: GO 23120
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22804: LD_ADDR_VAR 0 6
22808: PUSH
22809: LD_INT 22
22811: PUSH
22812: LD_VAR 0 1
22816: PPUSH
22817: CALL_OW 255
22821: PUSH
22822: EMPTY
22823: LIST
22824: LIST
22825: PUSH
22826: LD_INT 2
22828: PUSH
22829: LD_INT 30
22831: PUSH
22832: LD_INT 36
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: PUSH
22839: LD_INT 34
22841: PUSH
22842: LD_INT 31
22844: PUSH
22845: EMPTY
22846: LIST
22847: LIST
22848: PUSH
22849: EMPTY
22850: LIST
22851: LIST
22852: LIST
22853: PUSH
22854: EMPTY
22855: LIST
22856: LIST
22857: PPUSH
22858: CALL_OW 69
22862: ST_TO_ADDR
// if not tmp then
22863: LD_VAR 0 6
22867: NOT
22868: IFFALSE 22872
// exit ;
22870: GO 23120
// result := [ ] ;
22872: LD_ADDR_VAR 0 2
22876: PUSH
22877: EMPTY
22878: ST_TO_ADDR
// for i in tmp do
22879: LD_ADDR_VAR 0 3
22883: PUSH
22884: LD_VAR 0 6
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22961
// begin t := UnitsInside ( i ) ;
22892: LD_ADDR_VAR 0 4
22896: PUSH
22897: LD_VAR 0 3
22901: PPUSH
22902: CALL_OW 313
22906: ST_TO_ADDR
// if t then
22907: LD_VAR 0 4
22911: IFFALSE 22959
// for j in t do
22913: LD_ADDR_VAR 0 7
22917: PUSH
22918: LD_VAR 0 4
22922: PUSH
22923: FOR_IN
22924: IFFALSE 22957
// result := Replace ( result , result + 1 , j ) ;
22926: LD_ADDR_VAR 0 2
22930: PUSH
22931: LD_VAR 0 2
22935: PPUSH
22936: LD_VAR 0 2
22940: PUSH
22941: LD_INT 1
22943: PLUS
22944: PPUSH
22945: LD_VAR 0 7
22949: PPUSH
22950: CALL_OW 1
22954: ST_TO_ADDR
22955: GO 22923
22957: POP
22958: POP
// end ;
22959: GO 22889
22961: POP
22962: POP
// if not result then
22963: LD_VAR 0 2
22967: NOT
22968: IFFALSE 22972
// exit ;
22970: GO 23120
// mech := result [ 1 ] ;
22972: LD_ADDR_VAR 0 5
22976: PUSH
22977: LD_VAR 0 2
22981: PUSH
22982: LD_INT 1
22984: ARRAY
22985: ST_TO_ADDR
// if result > 1 then
22986: LD_VAR 0 2
22990: PUSH
22991: LD_INT 1
22993: GREATER
22994: IFFALSE 23106
// begin for i = 2 to result do
22996: LD_ADDR_VAR 0 3
23000: PUSH
23001: DOUBLE
23002: LD_INT 2
23004: DEC
23005: ST_TO_ADDR
23006: LD_VAR 0 2
23010: PUSH
23011: FOR_TO
23012: IFFALSE 23104
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23014: LD_ADDR_VAR 0 4
23018: PUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_VAR 0 3
23028: ARRAY
23029: PPUSH
23030: LD_INT 3
23032: PPUSH
23033: CALL_OW 259
23037: PUSH
23038: LD_VAR 0 2
23042: PUSH
23043: LD_VAR 0 3
23047: ARRAY
23048: PPUSH
23049: CALL_OW 432
23053: MINUS
23054: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23055: LD_VAR 0 4
23059: PUSH
23060: LD_VAR 0 5
23064: PPUSH
23065: LD_INT 3
23067: PPUSH
23068: CALL_OW 259
23072: PUSH
23073: LD_VAR 0 5
23077: PPUSH
23078: CALL_OW 432
23082: MINUS
23083: GREATEREQUAL
23084: IFFALSE 23102
// mech := result [ i ] ;
23086: LD_ADDR_VAR 0 5
23090: PUSH
23091: LD_VAR 0 2
23095: PUSH
23096: LD_VAR 0 3
23100: ARRAY
23101: ST_TO_ADDR
// end ;
23102: GO 23011
23104: POP
23105: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23106: LD_VAR 0 1
23110: PPUSH
23111: LD_VAR 0 5
23115: PPUSH
23116: CALL_OW 135
// end ;
23120: LD_VAR 0 2
23124: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23125: LD_INT 0
23127: PPUSH
23128: PPUSH
23129: PPUSH
23130: PPUSH
23131: PPUSH
23132: PPUSH
23133: PPUSH
23134: PPUSH
23135: PPUSH
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
// result := [ ] ;
23140: LD_ADDR_VAR 0 7
23144: PUSH
23145: EMPTY
23146: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23147: LD_VAR 0 1
23151: PPUSH
23152: CALL_OW 266
23156: PUSH
23157: LD_INT 0
23159: PUSH
23160: LD_INT 1
23162: PUSH
23163: EMPTY
23164: LIST
23165: LIST
23166: IN
23167: NOT
23168: IFFALSE 23172
// exit ;
23170: GO 24806
// if name then
23172: LD_VAR 0 3
23176: IFFALSE 23192
// SetBName ( base_dep , name ) ;
23178: LD_VAR 0 1
23182: PPUSH
23183: LD_VAR 0 3
23187: PPUSH
23188: CALL_OW 500
// base := GetBase ( base_dep ) ;
23192: LD_ADDR_VAR 0 15
23196: PUSH
23197: LD_VAR 0 1
23201: PPUSH
23202: CALL_OW 274
23206: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23207: LD_ADDR_VAR 0 16
23211: PUSH
23212: LD_VAR 0 1
23216: PPUSH
23217: CALL_OW 255
23221: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23222: LD_ADDR_VAR 0 17
23226: PUSH
23227: LD_VAR 0 1
23231: PPUSH
23232: CALL_OW 248
23236: ST_TO_ADDR
// if sources then
23237: LD_VAR 0 5
23241: IFFALSE 23288
// for i = 1 to 3 do
23243: LD_ADDR_VAR 0 8
23247: PUSH
23248: DOUBLE
23249: LD_INT 1
23251: DEC
23252: ST_TO_ADDR
23253: LD_INT 3
23255: PUSH
23256: FOR_TO
23257: IFFALSE 23286
// AddResourceType ( base , i , sources [ i ] ) ;
23259: LD_VAR 0 15
23263: PPUSH
23264: LD_VAR 0 8
23268: PPUSH
23269: LD_VAR 0 5
23273: PUSH
23274: LD_VAR 0 8
23278: ARRAY
23279: PPUSH
23280: CALL_OW 276
23284: GO 23256
23286: POP
23287: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23288: LD_ADDR_VAR 0 18
23292: PUSH
23293: LD_VAR 0 15
23297: PPUSH
23298: LD_VAR 0 2
23302: PPUSH
23303: LD_INT 1
23305: PPUSH
23306: CALL 22549 0 3
23310: ST_TO_ADDR
// InitHc ;
23311: CALL_OW 19
// InitUc ;
23315: CALL_OW 18
// uc_side := side ;
23319: LD_ADDR_OWVAR 20
23323: PUSH
23324: LD_VAR 0 16
23328: ST_TO_ADDR
// uc_nation := nation ;
23329: LD_ADDR_OWVAR 21
23333: PUSH
23334: LD_VAR 0 17
23338: ST_TO_ADDR
// if buildings then
23339: LD_VAR 0 18
23343: IFFALSE 24665
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23345: LD_ADDR_VAR 0 19
23349: PUSH
23350: LD_VAR 0 18
23354: PPUSH
23355: LD_INT 2
23357: PUSH
23358: LD_INT 30
23360: PUSH
23361: LD_INT 29
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: LD_INT 30
23370: PUSH
23371: LD_INT 30
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: EMPTY
23379: LIST
23380: LIST
23381: LIST
23382: PPUSH
23383: CALL_OW 72
23387: ST_TO_ADDR
// if tmp then
23388: LD_VAR 0 19
23392: IFFALSE 23440
// for i in tmp do
23394: LD_ADDR_VAR 0 8
23398: PUSH
23399: LD_VAR 0 19
23403: PUSH
23404: FOR_IN
23405: IFFALSE 23438
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23407: LD_VAR 0 8
23411: PPUSH
23412: CALL_OW 250
23416: PPUSH
23417: LD_VAR 0 8
23421: PPUSH
23422: CALL_OW 251
23426: PPUSH
23427: LD_VAR 0 16
23431: PPUSH
23432: CALL_OW 441
23436: GO 23404
23438: POP
23439: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23440: LD_VAR 0 18
23444: PPUSH
23445: LD_INT 2
23447: PUSH
23448: LD_INT 30
23450: PUSH
23451: LD_INT 32
23453: PUSH
23454: EMPTY
23455: LIST
23456: LIST
23457: PUSH
23458: LD_INT 30
23460: PUSH
23461: LD_INT 33
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: PUSH
23468: EMPTY
23469: LIST
23470: LIST
23471: LIST
23472: PPUSH
23473: CALL_OW 72
23477: IFFALSE 23565
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23479: LD_ADDR_VAR 0 8
23483: PUSH
23484: LD_VAR 0 18
23488: PPUSH
23489: LD_INT 2
23491: PUSH
23492: LD_INT 30
23494: PUSH
23495: LD_INT 32
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PUSH
23502: LD_INT 30
23504: PUSH
23505: LD_INT 33
23507: PUSH
23508: EMPTY
23509: LIST
23510: LIST
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PPUSH
23517: CALL_OW 72
23521: PUSH
23522: FOR_IN
23523: IFFALSE 23563
// begin if not GetBWeapon ( i ) then
23525: LD_VAR 0 8
23529: PPUSH
23530: CALL_OW 269
23534: NOT
23535: IFFALSE 23561
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 8
23546: PPUSH
23547: LD_VAR 0 2
23551: PPUSH
23552: CALL 24811 0 2
23556: PPUSH
23557: CALL_OW 431
// end ;
23561: GO 23522
23563: POP
23564: POP
// end ; for i = 1 to personel do
23565: LD_ADDR_VAR 0 8
23569: PUSH
23570: DOUBLE
23571: LD_INT 1
23573: DEC
23574: ST_TO_ADDR
23575: LD_VAR 0 6
23579: PUSH
23580: FOR_TO
23581: IFFALSE 24645
// begin if i > 4 then
23583: LD_VAR 0 8
23587: PUSH
23588: LD_INT 4
23590: GREATER
23591: IFFALSE 23595
// break ;
23593: GO 24645
// case i of 1 :
23595: LD_VAR 0 8
23599: PUSH
23600: LD_INT 1
23602: DOUBLE
23603: EQUAL
23604: IFTRUE 23608
23606: GO 23688
23608: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23609: LD_ADDR_VAR 0 12
23613: PUSH
23614: LD_VAR 0 18
23618: PPUSH
23619: LD_INT 22
23621: PUSH
23622: LD_VAR 0 16
23626: PUSH
23627: EMPTY
23628: LIST
23629: LIST
23630: PUSH
23631: LD_INT 58
23633: PUSH
23634: EMPTY
23635: LIST
23636: PUSH
23637: LD_INT 2
23639: PUSH
23640: LD_INT 30
23642: PUSH
23643: LD_INT 32
23645: PUSH
23646: EMPTY
23647: LIST
23648: LIST
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 4
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 5
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: LIST
23680: PPUSH
23681: CALL_OW 72
23685: ST_TO_ADDR
23686: GO 23910
23688: LD_INT 2
23690: DOUBLE
23691: EQUAL
23692: IFTRUE 23696
23694: GO 23758
23696: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23697: LD_ADDR_VAR 0 12
23701: PUSH
23702: LD_VAR 0 18
23706: PPUSH
23707: LD_INT 22
23709: PUSH
23710: LD_VAR 0 16
23714: PUSH
23715: EMPTY
23716: LIST
23717: LIST
23718: PUSH
23719: LD_INT 2
23721: PUSH
23722: LD_INT 30
23724: PUSH
23725: LD_INT 0
23727: PUSH
23728: EMPTY
23729: LIST
23730: LIST
23731: PUSH
23732: LD_INT 30
23734: PUSH
23735: LD_INT 1
23737: PUSH
23738: EMPTY
23739: LIST
23740: LIST
23741: PUSH
23742: EMPTY
23743: LIST
23744: LIST
23745: LIST
23746: PUSH
23747: EMPTY
23748: LIST
23749: LIST
23750: PPUSH
23751: CALL_OW 72
23755: ST_TO_ADDR
23756: GO 23910
23758: LD_INT 3
23760: DOUBLE
23761: EQUAL
23762: IFTRUE 23766
23764: GO 23828
23766: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23767: LD_ADDR_VAR 0 12
23771: PUSH
23772: LD_VAR 0 18
23776: PPUSH
23777: LD_INT 22
23779: PUSH
23780: LD_VAR 0 16
23784: PUSH
23785: EMPTY
23786: LIST
23787: LIST
23788: PUSH
23789: LD_INT 2
23791: PUSH
23792: LD_INT 30
23794: PUSH
23795: LD_INT 2
23797: PUSH
23798: EMPTY
23799: LIST
23800: LIST
23801: PUSH
23802: LD_INT 30
23804: PUSH
23805: LD_INT 3
23807: PUSH
23808: EMPTY
23809: LIST
23810: LIST
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: LIST
23816: PUSH
23817: EMPTY
23818: LIST
23819: LIST
23820: PPUSH
23821: CALL_OW 72
23825: ST_TO_ADDR
23826: GO 23910
23828: LD_INT 4
23830: DOUBLE
23831: EQUAL
23832: IFTRUE 23836
23834: GO 23909
23836: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23837: LD_ADDR_VAR 0 12
23841: PUSH
23842: LD_VAR 0 18
23846: PPUSH
23847: LD_INT 22
23849: PUSH
23850: LD_VAR 0 16
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: PUSH
23859: LD_INT 2
23861: PUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 6
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: LD_INT 30
23874: PUSH
23875: LD_INT 7
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: PUSH
23882: LD_INT 30
23884: PUSH
23885: LD_INT 8
23887: PUSH
23888: EMPTY
23889: LIST
23890: LIST
23891: PUSH
23892: EMPTY
23893: LIST
23894: LIST
23895: LIST
23896: LIST
23897: PUSH
23898: EMPTY
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 72
23906: ST_TO_ADDR
23907: GO 23910
23909: POP
// if i = 1 then
23910: LD_VAR 0 8
23914: PUSH
23915: LD_INT 1
23917: EQUAL
23918: IFFALSE 24029
// begin tmp := [ ] ;
23920: LD_ADDR_VAR 0 19
23924: PUSH
23925: EMPTY
23926: ST_TO_ADDR
// for j in f do
23927: LD_ADDR_VAR 0 9
23931: PUSH
23932: LD_VAR 0 12
23936: PUSH
23937: FOR_IN
23938: IFFALSE 24011
// if GetBType ( j ) = b_bunker then
23940: LD_VAR 0 9
23944: PPUSH
23945: CALL_OW 266
23949: PUSH
23950: LD_INT 32
23952: EQUAL
23953: IFFALSE 23980
// tmp := Insert ( tmp , 1 , j ) else
23955: LD_ADDR_VAR 0 19
23959: PUSH
23960: LD_VAR 0 19
23964: PPUSH
23965: LD_INT 1
23967: PPUSH
23968: LD_VAR 0 9
23972: PPUSH
23973: CALL_OW 2
23977: ST_TO_ADDR
23978: GO 24009
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23980: LD_ADDR_VAR 0 19
23984: PUSH
23985: LD_VAR 0 19
23989: PPUSH
23990: LD_VAR 0 19
23994: PUSH
23995: LD_INT 1
23997: PLUS
23998: PPUSH
23999: LD_VAR 0 9
24003: PPUSH
24004: CALL_OW 2
24008: ST_TO_ADDR
24009: GO 23937
24011: POP
24012: POP
// if tmp then
24013: LD_VAR 0 19
24017: IFFALSE 24029
// f := tmp ;
24019: LD_ADDR_VAR 0 12
24023: PUSH
24024: LD_VAR 0 19
24028: ST_TO_ADDR
// end ; x := personel [ i ] ;
24029: LD_ADDR_VAR 0 13
24033: PUSH
24034: LD_VAR 0 6
24038: PUSH
24039: LD_VAR 0 8
24043: ARRAY
24044: ST_TO_ADDR
// if x = - 1 then
24045: LD_VAR 0 13
24049: PUSH
24050: LD_INT 1
24052: NEG
24053: EQUAL
24054: IFFALSE 24263
// begin for j in f do
24056: LD_ADDR_VAR 0 9
24060: PUSH
24061: LD_VAR 0 12
24065: PUSH
24066: FOR_IN
24067: IFFALSE 24259
// repeat InitHc ;
24069: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24073: LD_VAR 0 9
24077: PPUSH
24078: CALL_OW 266
24082: PUSH
24083: LD_INT 5
24085: EQUAL
24086: IFFALSE 24156
// begin if UnitsInside ( j ) < 3 then
24088: LD_VAR 0 9
24092: PPUSH
24093: CALL_OW 313
24097: PUSH
24098: LD_INT 3
24100: LESS
24101: IFFALSE 24137
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24103: LD_INT 0
24105: PPUSH
24106: LD_INT 5
24108: PUSH
24109: LD_INT 8
24111: PUSH
24112: LD_INT 9
24114: PUSH
24115: EMPTY
24116: LIST
24117: LIST
24118: LIST
24119: PUSH
24120: LD_VAR 0 17
24124: ARRAY
24125: PPUSH
24126: LD_VAR 0 4
24130: PPUSH
24131: CALL_OW 380
24135: GO 24154
// PrepareHuman ( false , i , skill ) ;
24137: LD_INT 0
24139: PPUSH
24140: LD_VAR 0 8
24144: PPUSH
24145: LD_VAR 0 4
24149: PPUSH
24150: CALL_OW 380
// end else
24154: GO 24173
// PrepareHuman ( false , i , skill ) ;
24156: LD_INT 0
24158: PPUSH
24159: LD_VAR 0 8
24163: PPUSH
24164: LD_VAR 0 4
24168: PPUSH
24169: CALL_OW 380
// un := CreateHuman ;
24173: LD_ADDR_VAR 0 14
24177: PUSH
24178: CALL_OW 44
24182: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PPUSH
24193: LD_INT 1
24195: PPUSH
24196: LD_VAR 0 14
24200: PPUSH
24201: CALL_OW 2
24205: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24206: LD_VAR 0 14
24210: PPUSH
24211: LD_VAR 0 9
24215: PPUSH
24216: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24220: LD_VAR 0 9
24224: PPUSH
24225: CALL_OW 313
24229: PUSH
24230: LD_INT 6
24232: EQUAL
24233: PUSH
24234: LD_VAR 0 9
24238: PPUSH
24239: CALL_OW 266
24243: PUSH
24244: LD_INT 32
24246: PUSH
24247: LD_INT 31
24249: PUSH
24250: EMPTY
24251: LIST
24252: LIST
24253: IN
24254: OR
24255: IFFALSE 24069
24257: GO 24066
24259: POP
24260: POP
// end else
24261: GO 24643
// for j = 1 to x do
24263: LD_ADDR_VAR 0 9
24267: PUSH
24268: DOUBLE
24269: LD_INT 1
24271: DEC
24272: ST_TO_ADDR
24273: LD_VAR 0 13
24277: PUSH
24278: FOR_TO
24279: IFFALSE 24641
// begin InitHc ;
24281: CALL_OW 19
// if not f then
24285: LD_VAR 0 12
24289: NOT
24290: IFFALSE 24379
// begin PrepareHuman ( false , i , skill ) ;
24292: LD_INT 0
24294: PPUSH
24295: LD_VAR 0 8
24299: PPUSH
24300: LD_VAR 0 4
24304: PPUSH
24305: CALL_OW 380
// un := CreateHuman ;
24309: LD_ADDR_VAR 0 14
24313: PUSH
24314: CALL_OW 44
24318: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24319: LD_ADDR_VAR 0 7
24323: PUSH
24324: LD_VAR 0 7
24328: PPUSH
24329: LD_INT 1
24331: PPUSH
24332: LD_VAR 0 14
24336: PPUSH
24337: CALL_OW 2
24341: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24342: LD_VAR 0 14
24346: PPUSH
24347: LD_VAR 0 1
24351: PPUSH
24352: CALL_OW 250
24356: PPUSH
24357: LD_VAR 0 1
24361: PPUSH
24362: CALL_OW 251
24366: PPUSH
24367: LD_INT 10
24369: PPUSH
24370: LD_INT 0
24372: PPUSH
24373: CALL_OW 50
// continue ;
24377: GO 24278
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24379: LD_VAR 0 12
24383: PUSH
24384: LD_INT 1
24386: ARRAY
24387: PPUSH
24388: CALL_OW 313
24392: PUSH
24393: LD_VAR 0 12
24397: PUSH
24398: LD_INT 1
24400: ARRAY
24401: PPUSH
24402: CALL_OW 266
24406: PUSH
24407: LD_INT 32
24409: PUSH
24410: LD_INT 31
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: IN
24417: AND
24418: PUSH
24419: LD_VAR 0 12
24423: PUSH
24424: LD_INT 1
24426: ARRAY
24427: PPUSH
24428: CALL_OW 313
24432: PUSH
24433: LD_INT 6
24435: EQUAL
24436: OR
24437: IFFALSE 24457
// f := Delete ( f , 1 ) ;
24439: LD_ADDR_VAR 0 12
24443: PUSH
24444: LD_VAR 0 12
24448: PPUSH
24449: LD_INT 1
24451: PPUSH
24452: CALL_OW 3
24456: ST_TO_ADDR
// if not f then
24457: LD_VAR 0 12
24461: NOT
24462: IFFALSE 24480
// begin x := x + 2 ;
24464: LD_ADDR_VAR 0 13
24468: PUSH
24469: LD_VAR 0 13
24473: PUSH
24474: LD_INT 2
24476: PLUS
24477: ST_TO_ADDR
// continue ;
24478: GO 24278
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24480: LD_VAR 0 12
24484: PUSH
24485: LD_INT 1
24487: ARRAY
24488: PPUSH
24489: CALL_OW 266
24493: PUSH
24494: LD_INT 5
24496: EQUAL
24497: IFFALSE 24571
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24499: LD_VAR 0 12
24503: PUSH
24504: LD_INT 1
24506: ARRAY
24507: PPUSH
24508: CALL_OW 313
24512: PUSH
24513: LD_INT 3
24515: LESS
24516: IFFALSE 24552
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24518: LD_INT 0
24520: PPUSH
24521: LD_INT 5
24523: PUSH
24524: LD_INT 8
24526: PUSH
24527: LD_INT 9
24529: PUSH
24530: EMPTY
24531: LIST
24532: LIST
24533: LIST
24534: PUSH
24535: LD_VAR 0 17
24539: ARRAY
24540: PPUSH
24541: LD_VAR 0 4
24545: PPUSH
24546: CALL_OW 380
24550: GO 24569
// PrepareHuman ( false , i , skill ) ;
24552: LD_INT 0
24554: PPUSH
24555: LD_VAR 0 8
24559: PPUSH
24560: LD_VAR 0 4
24564: PPUSH
24565: CALL_OW 380
// end else
24569: GO 24588
// PrepareHuman ( false , i , skill ) ;
24571: LD_INT 0
24573: PPUSH
24574: LD_VAR 0 8
24578: PPUSH
24579: LD_VAR 0 4
24583: PPUSH
24584: CALL_OW 380
// un := CreateHuman ;
24588: LD_ADDR_VAR 0 14
24592: PUSH
24593: CALL_OW 44
24597: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24598: LD_ADDR_VAR 0 7
24602: PUSH
24603: LD_VAR 0 7
24607: PPUSH
24608: LD_INT 1
24610: PPUSH
24611: LD_VAR 0 14
24615: PPUSH
24616: CALL_OW 2
24620: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24621: LD_VAR 0 14
24625: PPUSH
24626: LD_VAR 0 12
24630: PUSH
24631: LD_INT 1
24633: ARRAY
24634: PPUSH
24635: CALL_OW 52
// end ;
24639: GO 24278
24641: POP
24642: POP
// end ;
24643: GO 23580
24645: POP
24646: POP
// result := result ^ buildings ;
24647: LD_ADDR_VAR 0 7
24651: PUSH
24652: LD_VAR 0 7
24656: PUSH
24657: LD_VAR 0 18
24661: ADD
24662: ST_TO_ADDR
// end else
24663: GO 24806
// begin for i = 1 to personel do
24665: LD_ADDR_VAR 0 8
24669: PUSH
24670: DOUBLE
24671: LD_INT 1
24673: DEC
24674: ST_TO_ADDR
24675: LD_VAR 0 6
24679: PUSH
24680: FOR_TO
24681: IFFALSE 24804
// begin if i > 4 then
24683: LD_VAR 0 8
24687: PUSH
24688: LD_INT 4
24690: GREATER
24691: IFFALSE 24695
// break ;
24693: GO 24804
// x := personel [ i ] ;
24695: LD_ADDR_VAR 0 13
24699: PUSH
24700: LD_VAR 0 6
24704: PUSH
24705: LD_VAR 0 8
24709: ARRAY
24710: ST_TO_ADDR
// if x = - 1 then
24711: LD_VAR 0 13
24715: PUSH
24716: LD_INT 1
24718: NEG
24719: EQUAL
24720: IFFALSE 24724
// continue ;
24722: GO 24680
// PrepareHuman ( false , i , skill ) ;
24724: LD_INT 0
24726: PPUSH
24727: LD_VAR 0 8
24731: PPUSH
24732: LD_VAR 0 4
24736: PPUSH
24737: CALL_OW 380
// un := CreateHuman ;
24741: LD_ADDR_VAR 0 14
24745: PUSH
24746: CALL_OW 44
24750: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24751: LD_VAR 0 14
24755: PPUSH
24756: LD_VAR 0 1
24760: PPUSH
24761: CALL_OW 250
24765: PPUSH
24766: LD_VAR 0 1
24770: PPUSH
24771: CALL_OW 251
24775: PPUSH
24776: LD_INT 10
24778: PPUSH
24779: LD_INT 0
24781: PPUSH
24782: CALL_OW 50
// result := result ^ un ;
24786: LD_ADDR_VAR 0 7
24790: PUSH
24791: LD_VAR 0 7
24795: PUSH
24796: LD_VAR 0 14
24800: ADD
24801: ST_TO_ADDR
// end ;
24802: GO 24680
24804: POP
24805: POP
// end ; end ;
24806: LD_VAR 0 7
24810: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24811: LD_INT 0
24813: PPUSH
24814: PPUSH
24815: PPUSH
24816: PPUSH
24817: PPUSH
24818: PPUSH
24819: PPUSH
24820: PPUSH
24821: PPUSH
24822: PPUSH
24823: PPUSH
24824: PPUSH
24825: PPUSH
24826: PPUSH
24827: PPUSH
24828: PPUSH
// result := false ;
24829: LD_ADDR_VAR 0 3
24833: PUSH
24834: LD_INT 0
24836: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24837: LD_VAR 0 1
24841: NOT
24842: PUSH
24843: LD_VAR 0 1
24847: PPUSH
24848: CALL_OW 266
24852: PUSH
24853: LD_INT 32
24855: PUSH
24856: LD_INT 33
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: IN
24863: NOT
24864: OR
24865: IFFALSE 24869
// exit ;
24867: GO 25978
// nat := GetNation ( tower ) ;
24869: LD_ADDR_VAR 0 12
24873: PUSH
24874: LD_VAR 0 1
24878: PPUSH
24879: CALL_OW 248
24883: ST_TO_ADDR
// side := GetSide ( tower ) ;
24884: LD_ADDR_VAR 0 16
24888: PUSH
24889: LD_VAR 0 1
24893: PPUSH
24894: CALL_OW 255
24898: ST_TO_ADDR
// x := GetX ( tower ) ;
24899: LD_ADDR_VAR 0 10
24903: PUSH
24904: LD_VAR 0 1
24908: PPUSH
24909: CALL_OW 250
24913: ST_TO_ADDR
// y := GetY ( tower ) ;
24914: LD_ADDR_VAR 0 11
24918: PUSH
24919: LD_VAR 0 1
24923: PPUSH
24924: CALL_OW 251
24928: ST_TO_ADDR
// if not x or not y then
24929: LD_VAR 0 10
24933: NOT
24934: PUSH
24935: LD_VAR 0 11
24939: NOT
24940: OR
24941: IFFALSE 24945
// exit ;
24943: GO 25978
// weapon := 0 ;
24945: LD_ADDR_VAR 0 18
24949: PUSH
24950: LD_INT 0
24952: ST_TO_ADDR
// fac_list := [ ] ;
24953: LD_ADDR_VAR 0 17
24957: PUSH
24958: EMPTY
24959: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24960: LD_ADDR_VAR 0 6
24964: PUSH
24965: LD_VAR 0 1
24969: PPUSH
24970: CALL_OW 274
24974: PPUSH
24975: LD_VAR 0 2
24979: PPUSH
24980: LD_INT 0
24982: PPUSH
24983: CALL 22549 0 3
24987: PPUSH
24988: LD_INT 30
24990: PUSH
24991: LD_INT 3
24993: PUSH
24994: EMPTY
24995: LIST
24996: LIST
24997: PPUSH
24998: CALL_OW 72
25002: ST_TO_ADDR
// if not factories then
25003: LD_VAR 0 6
25007: NOT
25008: IFFALSE 25012
// exit ;
25010: GO 25978
// for i in factories do
25012: LD_ADDR_VAR 0 8
25016: PUSH
25017: LD_VAR 0 6
25021: PUSH
25022: FOR_IN
25023: IFFALSE 25048
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25025: LD_ADDR_VAR 0 17
25029: PUSH
25030: LD_VAR 0 17
25034: PUSH
25035: LD_VAR 0 8
25039: PPUSH
25040: CALL_OW 478
25044: UNION
25045: ST_TO_ADDR
25046: GO 25022
25048: POP
25049: POP
// if not fac_list then
25050: LD_VAR 0 17
25054: NOT
25055: IFFALSE 25059
// exit ;
25057: GO 25978
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25059: LD_ADDR_VAR 0 5
25063: PUSH
25064: LD_INT 4
25066: PUSH
25067: LD_INT 5
25069: PUSH
25070: LD_INT 9
25072: PUSH
25073: LD_INT 10
25075: PUSH
25076: LD_INT 6
25078: PUSH
25079: LD_INT 7
25081: PUSH
25082: LD_INT 11
25084: PUSH
25085: EMPTY
25086: LIST
25087: LIST
25088: LIST
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: PUSH
25094: LD_INT 27
25096: PUSH
25097: LD_INT 28
25099: PUSH
25100: LD_INT 26
25102: PUSH
25103: LD_INT 30
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: PUSH
25112: LD_INT 43
25114: PUSH
25115: LD_INT 44
25117: PUSH
25118: LD_INT 46
25120: PUSH
25121: LD_INT 45
25123: PUSH
25124: LD_INT 47
25126: PUSH
25127: LD_INT 49
25129: PUSH
25130: EMPTY
25131: LIST
25132: LIST
25133: LIST
25134: LIST
25135: LIST
25136: LIST
25137: PUSH
25138: EMPTY
25139: LIST
25140: LIST
25141: LIST
25142: PUSH
25143: LD_VAR 0 12
25147: ARRAY
25148: ST_TO_ADDR
// list := list isect fac_list ;
25149: LD_ADDR_VAR 0 5
25153: PUSH
25154: LD_VAR 0 5
25158: PUSH
25159: LD_VAR 0 17
25163: ISECT
25164: ST_TO_ADDR
// if not list then
25165: LD_VAR 0 5
25169: NOT
25170: IFFALSE 25174
// exit ;
25172: GO 25978
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25174: LD_VAR 0 12
25178: PUSH
25179: LD_INT 3
25181: EQUAL
25182: PUSH
25183: LD_INT 49
25185: PUSH
25186: LD_VAR 0 5
25190: IN
25191: AND
25192: PUSH
25193: LD_INT 31
25195: PPUSH
25196: LD_VAR 0 16
25200: PPUSH
25201: CALL_OW 321
25205: PUSH
25206: LD_INT 2
25208: EQUAL
25209: AND
25210: IFFALSE 25270
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25212: LD_INT 22
25214: PUSH
25215: LD_VAR 0 16
25219: PUSH
25220: EMPTY
25221: LIST
25222: LIST
25223: PUSH
25224: LD_INT 35
25226: PUSH
25227: LD_INT 49
25229: PUSH
25230: EMPTY
25231: LIST
25232: LIST
25233: PUSH
25234: LD_INT 91
25236: PUSH
25237: LD_VAR 0 1
25241: PUSH
25242: LD_INT 10
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: PUSH
25250: EMPTY
25251: LIST
25252: LIST
25253: LIST
25254: PPUSH
25255: CALL_OW 69
25259: NOT
25260: IFFALSE 25270
// weapon := ru_time_lapser ;
25262: LD_ADDR_VAR 0 18
25266: PUSH
25267: LD_INT 49
25269: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25270: LD_VAR 0 12
25274: PUSH
25275: LD_INT 1
25277: PUSH
25278: LD_INT 2
25280: PUSH
25281: EMPTY
25282: LIST
25283: LIST
25284: IN
25285: PUSH
25286: LD_INT 11
25288: PUSH
25289: LD_VAR 0 5
25293: IN
25294: PUSH
25295: LD_INT 30
25297: PUSH
25298: LD_VAR 0 5
25302: IN
25303: OR
25304: AND
25305: PUSH
25306: LD_INT 6
25308: PPUSH
25309: LD_VAR 0 16
25313: PPUSH
25314: CALL_OW 321
25318: PUSH
25319: LD_INT 2
25321: EQUAL
25322: AND
25323: IFFALSE 25488
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25325: LD_INT 22
25327: PUSH
25328: LD_VAR 0 16
25332: PUSH
25333: EMPTY
25334: LIST
25335: LIST
25336: PUSH
25337: LD_INT 2
25339: PUSH
25340: LD_INT 35
25342: PUSH
25343: LD_INT 11
25345: PUSH
25346: EMPTY
25347: LIST
25348: LIST
25349: PUSH
25350: LD_INT 35
25352: PUSH
25353: LD_INT 30
25355: PUSH
25356: EMPTY
25357: LIST
25358: LIST
25359: PUSH
25360: EMPTY
25361: LIST
25362: LIST
25363: LIST
25364: PUSH
25365: LD_INT 91
25367: PUSH
25368: LD_VAR 0 1
25372: PUSH
25373: LD_INT 18
25375: PUSH
25376: EMPTY
25377: LIST
25378: LIST
25379: LIST
25380: PUSH
25381: EMPTY
25382: LIST
25383: LIST
25384: LIST
25385: PPUSH
25386: CALL_OW 69
25390: NOT
25391: PUSH
25392: LD_INT 22
25394: PUSH
25395: LD_VAR 0 16
25399: PUSH
25400: EMPTY
25401: LIST
25402: LIST
25403: PUSH
25404: LD_INT 2
25406: PUSH
25407: LD_INT 30
25409: PUSH
25410: LD_INT 32
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PUSH
25417: LD_INT 30
25419: PUSH
25420: LD_INT 33
25422: PUSH
25423: EMPTY
25424: LIST
25425: LIST
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: PUSH
25432: LD_INT 91
25434: PUSH
25435: LD_VAR 0 1
25439: PUSH
25440: LD_INT 12
25442: PUSH
25443: EMPTY
25444: LIST
25445: LIST
25446: LIST
25447: PUSH
25448: EMPTY
25449: LIST
25450: LIST
25451: LIST
25452: PUSH
25453: EMPTY
25454: LIST
25455: PPUSH
25456: CALL_OW 69
25460: PUSH
25461: LD_INT 2
25463: GREATER
25464: AND
25465: IFFALSE 25488
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25467: LD_ADDR_VAR 0 18
25471: PUSH
25472: LD_INT 11
25474: PUSH
25475: LD_INT 30
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PUSH
25482: LD_VAR 0 12
25486: ARRAY
25487: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25488: LD_VAR 0 18
25492: NOT
25493: PUSH
25494: LD_INT 40
25496: PPUSH
25497: LD_VAR 0 16
25501: PPUSH
25502: CALL_OW 321
25506: PUSH
25507: LD_INT 2
25509: EQUAL
25510: AND
25511: PUSH
25512: LD_INT 7
25514: PUSH
25515: LD_VAR 0 5
25519: IN
25520: PUSH
25521: LD_INT 28
25523: PUSH
25524: LD_VAR 0 5
25528: IN
25529: OR
25530: PUSH
25531: LD_INT 45
25533: PUSH
25534: LD_VAR 0 5
25538: IN
25539: OR
25540: AND
25541: IFFALSE 25795
// begin hex := GetHexInfo ( x , y ) ;
25543: LD_ADDR_VAR 0 4
25547: PUSH
25548: LD_VAR 0 10
25552: PPUSH
25553: LD_VAR 0 11
25557: PPUSH
25558: CALL_OW 546
25562: ST_TO_ADDR
// if hex [ 1 ] then
25563: LD_VAR 0 4
25567: PUSH
25568: LD_INT 1
25570: ARRAY
25571: IFFALSE 25575
// exit ;
25573: GO 25978
// height := hex [ 2 ] ;
25575: LD_ADDR_VAR 0 15
25579: PUSH
25580: LD_VAR 0 4
25584: PUSH
25585: LD_INT 2
25587: ARRAY
25588: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25589: LD_ADDR_VAR 0 14
25593: PUSH
25594: LD_INT 0
25596: PUSH
25597: LD_INT 2
25599: PUSH
25600: LD_INT 3
25602: PUSH
25603: LD_INT 5
25605: PUSH
25606: EMPTY
25607: LIST
25608: LIST
25609: LIST
25610: LIST
25611: ST_TO_ADDR
// for i in tmp do
25612: LD_ADDR_VAR 0 8
25616: PUSH
25617: LD_VAR 0 14
25621: PUSH
25622: FOR_IN
25623: IFFALSE 25793
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25625: LD_ADDR_VAR 0 9
25629: PUSH
25630: LD_VAR 0 10
25634: PPUSH
25635: LD_VAR 0 8
25639: PPUSH
25640: LD_INT 5
25642: PPUSH
25643: CALL_OW 272
25647: PUSH
25648: LD_VAR 0 11
25652: PPUSH
25653: LD_VAR 0 8
25657: PPUSH
25658: LD_INT 5
25660: PPUSH
25661: CALL_OW 273
25665: PUSH
25666: EMPTY
25667: LIST
25668: LIST
25669: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25670: LD_VAR 0 9
25674: PUSH
25675: LD_INT 1
25677: ARRAY
25678: PPUSH
25679: LD_VAR 0 9
25683: PUSH
25684: LD_INT 2
25686: ARRAY
25687: PPUSH
25688: CALL_OW 488
25692: IFFALSE 25791
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25694: LD_ADDR_VAR 0 4
25698: PUSH
25699: LD_VAR 0 9
25703: PUSH
25704: LD_INT 1
25706: ARRAY
25707: PPUSH
25708: LD_VAR 0 9
25712: PUSH
25713: LD_INT 2
25715: ARRAY
25716: PPUSH
25717: CALL_OW 546
25721: ST_TO_ADDR
// if hex [ 1 ] then
25722: LD_VAR 0 4
25726: PUSH
25727: LD_INT 1
25729: ARRAY
25730: IFFALSE 25734
// continue ;
25732: GO 25622
// h := hex [ 2 ] ;
25734: LD_ADDR_VAR 0 13
25738: PUSH
25739: LD_VAR 0 4
25743: PUSH
25744: LD_INT 2
25746: ARRAY
25747: ST_TO_ADDR
// if h + 7 < height then
25748: LD_VAR 0 13
25752: PUSH
25753: LD_INT 7
25755: PLUS
25756: PUSH
25757: LD_VAR 0 15
25761: LESS
25762: IFFALSE 25791
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25764: LD_ADDR_VAR 0 18
25768: PUSH
25769: LD_INT 7
25771: PUSH
25772: LD_INT 28
25774: PUSH
25775: LD_INT 45
25777: PUSH
25778: EMPTY
25779: LIST
25780: LIST
25781: LIST
25782: PUSH
25783: LD_VAR 0 12
25787: ARRAY
25788: ST_TO_ADDR
// break ;
25789: GO 25793
// end ; end ; end ;
25791: GO 25622
25793: POP
25794: POP
// end ; if not weapon then
25795: LD_VAR 0 18
25799: NOT
25800: IFFALSE 25860
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25802: LD_ADDR_VAR 0 5
25806: PUSH
25807: LD_VAR 0 5
25811: PUSH
25812: LD_INT 11
25814: PUSH
25815: LD_INT 30
25817: PUSH
25818: LD_INT 49
25820: PUSH
25821: EMPTY
25822: LIST
25823: LIST
25824: LIST
25825: DIFF
25826: ST_TO_ADDR
// if not list then
25827: LD_VAR 0 5
25831: NOT
25832: IFFALSE 25836
// exit ;
25834: GO 25978
// weapon := list [ rand ( 1 , list ) ] ;
25836: LD_ADDR_VAR 0 18
25840: PUSH
25841: LD_VAR 0 5
25845: PUSH
25846: LD_INT 1
25848: PPUSH
25849: LD_VAR 0 5
25853: PPUSH
25854: CALL_OW 12
25858: ARRAY
25859: ST_TO_ADDR
// end ; if weapon then
25860: LD_VAR 0 18
25864: IFFALSE 25978
// begin tmp := CostOfWeapon ( weapon ) ;
25866: LD_ADDR_VAR 0 14
25870: PUSH
25871: LD_VAR 0 18
25875: PPUSH
25876: CALL_OW 451
25880: ST_TO_ADDR
// j := GetBase ( tower ) ;
25881: LD_ADDR_VAR 0 9
25885: PUSH
25886: LD_VAR 0 1
25890: PPUSH
25891: CALL_OW 274
25895: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25896: LD_VAR 0 9
25900: PPUSH
25901: LD_INT 1
25903: PPUSH
25904: CALL_OW 275
25908: PUSH
25909: LD_VAR 0 14
25913: PUSH
25914: LD_INT 1
25916: ARRAY
25917: GREATEREQUAL
25918: PUSH
25919: LD_VAR 0 9
25923: PPUSH
25924: LD_INT 2
25926: PPUSH
25927: CALL_OW 275
25931: PUSH
25932: LD_VAR 0 14
25936: PUSH
25937: LD_INT 2
25939: ARRAY
25940: GREATEREQUAL
25941: AND
25942: PUSH
25943: LD_VAR 0 9
25947: PPUSH
25948: LD_INT 3
25950: PPUSH
25951: CALL_OW 275
25955: PUSH
25956: LD_VAR 0 14
25960: PUSH
25961: LD_INT 3
25963: ARRAY
25964: GREATEREQUAL
25965: AND
25966: IFFALSE 25978
// result := weapon ;
25968: LD_ADDR_VAR 0 3
25972: PUSH
25973: LD_VAR 0 18
25977: ST_TO_ADDR
// end ; end ;
25978: LD_VAR 0 3
25982: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25983: LD_INT 0
25985: PPUSH
25986: PPUSH
// result := true ;
25987: LD_ADDR_VAR 0 3
25991: PUSH
25992: LD_INT 1
25994: ST_TO_ADDR
// if array1 = array2 then
25995: LD_VAR 0 1
25999: PUSH
26000: LD_VAR 0 2
26004: EQUAL
26005: IFFALSE 26065
// begin for i = 1 to array1 do
26007: LD_ADDR_VAR 0 4
26011: PUSH
26012: DOUBLE
26013: LD_INT 1
26015: DEC
26016: ST_TO_ADDR
26017: LD_VAR 0 1
26021: PUSH
26022: FOR_TO
26023: IFFALSE 26061
// if array1 [ i ] <> array2 [ i ] then
26025: LD_VAR 0 1
26029: PUSH
26030: LD_VAR 0 4
26034: ARRAY
26035: PUSH
26036: LD_VAR 0 2
26040: PUSH
26041: LD_VAR 0 4
26045: ARRAY
26046: NONEQUAL
26047: IFFALSE 26059
// begin result := false ;
26049: LD_ADDR_VAR 0 3
26053: PUSH
26054: LD_INT 0
26056: ST_TO_ADDR
// break ;
26057: GO 26061
// end ;
26059: GO 26022
26061: POP
26062: POP
// end else
26063: GO 26073
// result := false ;
26065: LD_ADDR_VAR 0 3
26069: PUSH
26070: LD_INT 0
26072: ST_TO_ADDR
// end ;
26073: LD_VAR 0 3
26077: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26078: LD_INT 0
26080: PPUSH
26081: PPUSH
// if not array1 or not array2 then
26082: LD_VAR 0 1
26086: NOT
26087: PUSH
26088: LD_VAR 0 2
26092: NOT
26093: OR
26094: IFFALSE 26098
// exit ;
26096: GO 26162
// result := true ;
26098: LD_ADDR_VAR 0 3
26102: PUSH
26103: LD_INT 1
26105: ST_TO_ADDR
// for i = 1 to array1 do
26106: LD_ADDR_VAR 0 4
26110: PUSH
26111: DOUBLE
26112: LD_INT 1
26114: DEC
26115: ST_TO_ADDR
26116: LD_VAR 0 1
26120: PUSH
26121: FOR_TO
26122: IFFALSE 26160
// if array1 [ i ] <> array2 [ i ] then
26124: LD_VAR 0 1
26128: PUSH
26129: LD_VAR 0 4
26133: ARRAY
26134: PUSH
26135: LD_VAR 0 2
26139: PUSH
26140: LD_VAR 0 4
26144: ARRAY
26145: NONEQUAL
26146: IFFALSE 26158
// begin result := false ;
26148: LD_ADDR_VAR 0 3
26152: PUSH
26153: LD_INT 0
26155: ST_TO_ADDR
// break ;
26156: GO 26160
// end ;
26158: GO 26121
26160: POP
26161: POP
// end ;
26162: LD_VAR 0 3
26166: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26167: LD_INT 0
26169: PPUSH
26170: PPUSH
26171: PPUSH
// pom := GetBase ( fac ) ;
26172: LD_ADDR_VAR 0 5
26176: PUSH
26177: LD_VAR 0 1
26181: PPUSH
26182: CALL_OW 274
26186: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26187: LD_ADDR_VAR 0 4
26191: PUSH
26192: LD_VAR 0 2
26196: PUSH
26197: LD_INT 1
26199: ARRAY
26200: PPUSH
26201: LD_VAR 0 2
26205: PUSH
26206: LD_INT 2
26208: ARRAY
26209: PPUSH
26210: LD_VAR 0 2
26214: PUSH
26215: LD_INT 3
26217: ARRAY
26218: PPUSH
26219: LD_VAR 0 2
26223: PUSH
26224: LD_INT 4
26226: ARRAY
26227: PPUSH
26228: CALL_OW 449
26232: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26233: LD_ADDR_VAR 0 3
26237: PUSH
26238: LD_VAR 0 5
26242: PPUSH
26243: LD_INT 1
26245: PPUSH
26246: CALL_OW 275
26250: PUSH
26251: LD_VAR 0 4
26255: PUSH
26256: LD_INT 1
26258: ARRAY
26259: GREATEREQUAL
26260: PUSH
26261: LD_VAR 0 5
26265: PPUSH
26266: LD_INT 2
26268: PPUSH
26269: CALL_OW 275
26273: PUSH
26274: LD_VAR 0 4
26278: PUSH
26279: LD_INT 2
26281: ARRAY
26282: GREATEREQUAL
26283: AND
26284: PUSH
26285: LD_VAR 0 5
26289: PPUSH
26290: LD_INT 3
26292: PPUSH
26293: CALL_OW 275
26297: PUSH
26298: LD_VAR 0 4
26302: PUSH
26303: LD_INT 3
26305: ARRAY
26306: GREATEREQUAL
26307: AND
26308: ST_TO_ADDR
// end ;
26309: LD_VAR 0 3
26313: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26314: LD_INT 0
26316: PPUSH
26317: PPUSH
26318: PPUSH
26319: PPUSH
// pom := GetBase ( building ) ;
26320: LD_ADDR_VAR 0 3
26324: PUSH
26325: LD_VAR 0 1
26329: PPUSH
26330: CALL_OW 274
26334: ST_TO_ADDR
// if not pom then
26335: LD_VAR 0 3
26339: NOT
26340: IFFALSE 26344
// exit ;
26342: GO 26514
// btype := GetBType ( building ) ;
26344: LD_ADDR_VAR 0 5
26348: PUSH
26349: LD_VAR 0 1
26353: PPUSH
26354: CALL_OW 266
26358: ST_TO_ADDR
// if btype = b_armoury then
26359: LD_VAR 0 5
26363: PUSH
26364: LD_INT 4
26366: EQUAL
26367: IFFALSE 26377
// btype := b_barracks ;
26369: LD_ADDR_VAR 0 5
26373: PUSH
26374: LD_INT 5
26376: ST_TO_ADDR
// if btype = b_depot then
26377: LD_VAR 0 5
26381: PUSH
26382: LD_INT 0
26384: EQUAL
26385: IFFALSE 26395
// btype := b_warehouse ;
26387: LD_ADDR_VAR 0 5
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// if btype = b_workshop then
26395: LD_VAR 0 5
26399: PUSH
26400: LD_INT 2
26402: EQUAL
26403: IFFALSE 26413
// btype := b_factory ;
26405: LD_ADDR_VAR 0 5
26409: PUSH
26410: LD_INT 3
26412: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26413: LD_ADDR_VAR 0 4
26417: PUSH
26418: LD_VAR 0 5
26422: PPUSH
26423: LD_VAR 0 1
26427: PPUSH
26428: CALL_OW 248
26432: PPUSH
26433: CALL_OW 450
26437: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26438: LD_ADDR_VAR 0 2
26442: PUSH
26443: LD_VAR 0 3
26447: PPUSH
26448: LD_INT 1
26450: PPUSH
26451: CALL_OW 275
26455: PUSH
26456: LD_VAR 0 4
26460: PUSH
26461: LD_INT 1
26463: ARRAY
26464: GREATEREQUAL
26465: PUSH
26466: LD_VAR 0 3
26470: PPUSH
26471: LD_INT 2
26473: PPUSH
26474: CALL_OW 275
26478: PUSH
26479: LD_VAR 0 4
26483: PUSH
26484: LD_INT 2
26486: ARRAY
26487: GREATEREQUAL
26488: AND
26489: PUSH
26490: LD_VAR 0 3
26494: PPUSH
26495: LD_INT 3
26497: PPUSH
26498: CALL_OW 275
26502: PUSH
26503: LD_VAR 0 4
26507: PUSH
26508: LD_INT 3
26510: ARRAY
26511: GREATEREQUAL
26512: AND
26513: ST_TO_ADDR
// end ;
26514: LD_VAR 0 2
26518: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26519: LD_INT 0
26521: PPUSH
26522: PPUSH
26523: PPUSH
// pom := GetBase ( building ) ;
26524: LD_ADDR_VAR 0 4
26528: PUSH
26529: LD_VAR 0 1
26533: PPUSH
26534: CALL_OW 274
26538: ST_TO_ADDR
// if not pom then
26539: LD_VAR 0 4
26543: NOT
26544: IFFALSE 26548
// exit ;
26546: GO 26649
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26548: LD_ADDR_VAR 0 5
26552: PUSH
26553: LD_VAR 0 2
26557: PPUSH
26558: LD_VAR 0 1
26562: PPUSH
26563: CALL_OW 248
26567: PPUSH
26568: CALL_OW 450
26572: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26573: LD_ADDR_VAR 0 3
26577: PUSH
26578: LD_VAR 0 4
26582: PPUSH
26583: LD_INT 1
26585: PPUSH
26586: CALL_OW 275
26590: PUSH
26591: LD_VAR 0 5
26595: PUSH
26596: LD_INT 1
26598: ARRAY
26599: GREATEREQUAL
26600: PUSH
26601: LD_VAR 0 4
26605: PPUSH
26606: LD_INT 2
26608: PPUSH
26609: CALL_OW 275
26613: PUSH
26614: LD_VAR 0 5
26618: PUSH
26619: LD_INT 2
26621: ARRAY
26622: GREATEREQUAL
26623: AND
26624: PUSH
26625: LD_VAR 0 4
26629: PPUSH
26630: LD_INT 3
26632: PPUSH
26633: CALL_OW 275
26637: PUSH
26638: LD_VAR 0 5
26642: PUSH
26643: LD_INT 3
26645: ARRAY
26646: GREATEREQUAL
26647: AND
26648: ST_TO_ADDR
// end ;
26649: LD_VAR 0 3
26653: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26654: LD_INT 0
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
26665: PPUSH
26666: PPUSH
// result := false ;
26667: LD_ADDR_VAR 0 8
26671: PUSH
26672: LD_INT 0
26674: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26675: LD_VAR 0 5
26679: NOT
26680: PUSH
26681: LD_VAR 0 1
26685: NOT
26686: OR
26687: PUSH
26688: LD_VAR 0 2
26692: NOT
26693: OR
26694: PUSH
26695: LD_VAR 0 3
26699: NOT
26700: OR
26701: IFFALSE 26705
// exit ;
26703: GO 27519
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26705: LD_ADDR_VAR 0 14
26709: PUSH
26710: LD_VAR 0 1
26714: PPUSH
26715: LD_VAR 0 2
26719: PPUSH
26720: LD_VAR 0 3
26724: PPUSH
26725: LD_VAR 0 4
26729: PPUSH
26730: LD_VAR 0 5
26734: PUSH
26735: LD_INT 1
26737: ARRAY
26738: PPUSH
26739: CALL_OW 248
26743: PPUSH
26744: LD_INT 0
26746: PPUSH
26747: CALL 28756 0 6
26751: ST_TO_ADDR
// if not hexes then
26752: LD_VAR 0 14
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 27519
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26761: LD_ADDR_VAR 0 17
26765: PUSH
26766: LD_VAR 0 5
26770: PPUSH
26771: LD_INT 22
26773: PUSH
26774: LD_VAR 0 13
26778: PPUSH
26779: CALL_OW 255
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: LD_INT 2
26790: PUSH
26791: LD_INT 30
26793: PUSH
26794: LD_INT 0
26796: PUSH
26797: EMPTY
26798: LIST
26799: LIST
26800: PUSH
26801: LD_INT 30
26803: PUSH
26804: LD_INT 1
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: PUSH
26811: EMPTY
26812: LIST
26813: LIST
26814: LIST
26815: PUSH
26816: EMPTY
26817: LIST
26818: LIST
26819: PPUSH
26820: CALL_OW 72
26824: ST_TO_ADDR
// for i = 1 to hexes do
26825: LD_ADDR_VAR 0 9
26829: PUSH
26830: DOUBLE
26831: LD_INT 1
26833: DEC
26834: ST_TO_ADDR
26835: LD_VAR 0 14
26839: PUSH
26840: FOR_TO
26841: IFFALSE 27517
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26843: LD_ADDR_VAR 0 13
26847: PUSH
26848: LD_VAR 0 14
26852: PUSH
26853: LD_VAR 0 9
26857: ARRAY
26858: PUSH
26859: LD_INT 1
26861: ARRAY
26862: PPUSH
26863: LD_VAR 0 14
26867: PUSH
26868: LD_VAR 0 9
26872: ARRAY
26873: PUSH
26874: LD_INT 2
26876: ARRAY
26877: PPUSH
26878: CALL_OW 428
26882: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26883: LD_VAR 0 14
26887: PUSH
26888: LD_VAR 0 9
26892: ARRAY
26893: PUSH
26894: LD_INT 1
26896: ARRAY
26897: PPUSH
26898: LD_VAR 0 14
26902: PUSH
26903: LD_VAR 0 9
26907: ARRAY
26908: PUSH
26909: LD_INT 2
26911: ARRAY
26912: PPUSH
26913: CALL_OW 351
26917: PUSH
26918: LD_VAR 0 14
26922: PUSH
26923: LD_VAR 0 9
26927: ARRAY
26928: PUSH
26929: LD_INT 1
26931: ARRAY
26932: PPUSH
26933: LD_VAR 0 14
26937: PUSH
26938: LD_VAR 0 9
26942: ARRAY
26943: PUSH
26944: LD_INT 2
26946: ARRAY
26947: PPUSH
26948: CALL_OW 488
26952: NOT
26953: OR
26954: PUSH
26955: LD_VAR 0 13
26959: PPUSH
26960: CALL_OW 247
26964: PUSH
26965: LD_INT 3
26967: EQUAL
26968: OR
26969: IFFALSE 26975
// exit ;
26971: POP
26972: POP
26973: GO 27519
// if not tmp then
26975: LD_VAR 0 13
26979: NOT
26980: IFFALSE 26984
// continue ;
26982: GO 26840
// result := true ;
26984: LD_ADDR_VAR 0 8
26988: PUSH
26989: LD_INT 1
26991: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26992: LD_VAR 0 6
26996: PUSH
26997: LD_VAR 0 13
27001: PPUSH
27002: CALL_OW 247
27006: PUSH
27007: LD_INT 2
27009: EQUAL
27010: AND
27011: PUSH
27012: LD_VAR 0 13
27016: PPUSH
27017: CALL_OW 263
27021: PUSH
27022: LD_INT 1
27024: EQUAL
27025: AND
27026: IFFALSE 27190
// begin if IsDrivenBy ( tmp ) then
27028: LD_VAR 0 13
27032: PPUSH
27033: CALL_OW 311
27037: IFFALSE 27041
// continue ;
27039: GO 26840
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27041: LD_VAR 0 6
27045: PPUSH
27046: LD_INT 3
27048: PUSH
27049: LD_INT 60
27051: PUSH
27052: EMPTY
27053: LIST
27054: PUSH
27055: EMPTY
27056: LIST
27057: LIST
27058: PUSH
27059: LD_INT 3
27061: PUSH
27062: LD_INT 55
27064: PUSH
27065: EMPTY
27066: LIST
27067: PUSH
27068: EMPTY
27069: LIST
27070: LIST
27071: PUSH
27072: EMPTY
27073: LIST
27074: LIST
27075: PPUSH
27076: CALL_OW 72
27080: IFFALSE 27188
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27082: LD_ADDR_VAR 0 18
27086: PUSH
27087: LD_VAR 0 6
27091: PPUSH
27092: LD_INT 3
27094: PUSH
27095: LD_INT 60
27097: PUSH
27098: EMPTY
27099: LIST
27100: PUSH
27101: EMPTY
27102: LIST
27103: LIST
27104: PUSH
27105: LD_INT 3
27107: PUSH
27108: LD_INT 55
27110: PUSH
27111: EMPTY
27112: LIST
27113: PUSH
27114: EMPTY
27115: LIST
27116: LIST
27117: PUSH
27118: EMPTY
27119: LIST
27120: LIST
27121: PPUSH
27122: CALL_OW 72
27126: PUSH
27127: LD_INT 1
27129: ARRAY
27130: ST_TO_ADDR
// if IsInUnit ( driver ) then
27131: LD_VAR 0 18
27135: PPUSH
27136: CALL_OW 310
27140: IFFALSE 27151
// ComExit ( driver ) ;
27142: LD_VAR 0 18
27146: PPUSH
27147: CALL 51940 0 1
// AddComEnterUnit ( driver , tmp ) ;
27151: LD_VAR 0 18
27155: PPUSH
27156: LD_VAR 0 13
27160: PPUSH
27161: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27165: LD_VAR 0 18
27169: PPUSH
27170: LD_VAR 0 7
27174: PPUSH
27175: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27179: LD_VAR 0 18
27183: PPUSH
27184: CALL_OW 181
// end ; continue ;
27188: GO 26840
// end ; if not cleaners or not tmp in cleaners then
27190: LD_VAR 0 6
27194: NOT
27195: PUSH
27196: LD_VAR 0 13
27200: PUSH
27201: LD_VAR 0 6
27205: IN
27206: NOT
27207: OR
27208: IFFALSE 27515
// begin if dep then
27210: LD_VAR 0 17
27214: IFFALSE 27350
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27216: LD_ADDR_VAR 0 16
27220: PUSH
27221: LD_VAR 0 17
27225: PUSH
27226: LD_INT 1
27228: ARRAY
27229: PPUSH
27230: CALL_OW 250
27234: PPUSH
27235: LD_VAR 0 17
27239: PUSH
27240: LD_INT 1
27242: ARRAY
27243: PPUSH
27244: CALL_OW 254
27248: PPUSH
27249: LD_INT 5
27251: PPUSH
27252: CALL_OW 272
27256: PUSH
27257: LD_VAR 0 17
27261: PUSH
27262: LD_INT 1
27264: ARRAY
27265: PPUSH
27266: CALL_OW 251
27270: PPUSH
27271: LD_VAR 0 17
27275: PUSH
27276: LD_INT 1
27278: ARRAY
27279: PPUSH
27280: CALL_OW 254
27284: PPUSH
27285: LD_INT 5
27287: PPUSH
27288: CALL_OW 273
27292: PUSH
27293: EMPTY
27294: LIST
27295: LIST
27296: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27297: LD_VAR 0 16
27301: PUSH
27302: LD_INT 1
27304: ARRAY
27305: PPUSH
27306: LD_VAR 0 16
27310: PUSH
27311: LD_INT 2
27313: ARRAY
27314: PPUSH
27315: CALL_OW 488
27319: IFFALSE 27350
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27321: LD_VAR 0 13
27325: PPUSH
27326: LD_VAR 0 16
27330: PUSH
27331: LD_INT 1
27333: ARRAY
27334: PPUSH
27335: LD_VAR 0 16
27339: PUSH
27340: LD_INT 2
27342: ARRAY
27343: PPUSH
27344: CALL_OW 111
// continue ;
27348: GO 26840
// end ; end ; r := GetDir ( tmp ) ;
27350: LD_ADDR_VAR 0 15
27354: PUSH
27355: LD_VAR 0 13
27359: PPUSH
27360: CALL_OW 254
27364: ST_TO_ADDR
// if r = 5 then
27365: LD_VAR 0 15
27369: PUSH
27370: LD_INT 5
27372: EQUAL
27373: IFFALSE 27383
// r := 0 ;
27375: LD_ADDR_VAR 0 15
27379: PUSH
27380: LD_INT 0
27382: ST_TO_ADDR
// for j = r to 5 do
27383: LD_ADDR_VAR 0 10
27387: PUSH
27388: DOUBLE
27389: LD_VAR 0 15
27393: DEC
27394: ST_TO_ADDR
27395: LD_INT 5
27397: PUSH
27398: FOR_TO
27399: IFFALSE 27513
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27401: LD_ADDR_VAR 0 11
27405: PUSH
27406: LD_VAR 0 13
27410: PPUSH
27411: CALL_OW 250
27415: PPUSH
27416: LD_VAR 0 10
27420: PPUSH
27421: LD_INT 2
27423: PPUSH
27424: CALL_OW 272
27428: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27429: LD_ADDR_VAR 0 12
27433: PUSH
27434: LD_VAR 0 13
27438: PPUSH
27439: CALL_OW 251
27443: PPUSH
27444: LD_VAR 0 10
27448: PPUSH
27449: LD_INT 2
27451: PPUSH
27452: CALL_OW 273
27456: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27457: LD_VAR 0 11
27461: PPUSH
27462: LD_VAR 0 12
27466: PPUSH
27467: CALL_OW 488
27471: PUSH
27472: LD_VAR 0 11
27476: PPUSH
27477: LD_VAR 0 12
27481: PPUSH
27482: CALL_OW 428
27486: NOT
27487: AND
27488: IFFALSE 27511
// begin ComMoveXY ( tmp , _x , _y ) ;
27490: LD_VAR 0 13
27494: PPUSH
27495: LD_VAR 0 11
27499: PPUSH
27500: LD_VAR 0 12
27504: PPUSH
27505: CALL_OW 111
// break ;
27509: GO 27513
// end ; end ;
27511: GO 27398
27513: POP
27514: POP
// end ; end ;
27515: GO 26840
27517: POP
27518: POP
// end ;
27519: LD_VAR 0 8
27523: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27524: LD_INT 0
27526: PPUSH
// result := true ;
27527: LD_ADDR_VAR 0 3
27531: PUSH
27532: LD_INT 1
27534: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27535: LD_VAR 0 2
27539: PUSH
27540: LD_INT 24
27542: DOUBLE
27543: EQUAL
27544: IFTRUE 27554
27546: LD_INT 33
27548: DOUBLE
27549: EQUAL
27550: IFTRUE 27554
27552: GO 27579
27554: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27555: LD_ADDR_VAR 0 3
27559: PUSH
27560: LD_INT 32
27562: PPUSH
27563: LD_VAR 0 1
27567: PPUSH
27568: CALL_OW 321
27572: PUSH
27573: LD_INT 2
27575: EQUAL
27576: ST_TO_ADDR
27577: GO 27899
27579: LD_INT 20
27581: DOUBLE
27582: EQUAL
27583: IFTRUE 27587
27585: GO 27612
27587: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27588: LD_ADDR_VAR 0 3
27592: PUSH
27593: LD_INT 6
27595: PPUSH
27596: LD_VAR 0 1
27600: PPUSH
27601: CALL_OW 321
27605: PUSH
27606: LD_INT 2
27608: EQUAL
27609: ST_TO_ADDR
27610: GO 27899
27612: LD_INT 22
27614: DOUBLE
27615: EQUAL
27616: IFTRUE 27626
27618: LD_INT 36
27620: DOUBLE
27621: EQUAL
27622: IFTRUE 27626
27624: GO 27651
27626: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27627: LD_ADDR_VAR 0 3
27631: PUSH
27632: LD_INT 15
27634: PPUSH
27635: LD_VAR 0 1
27639: PPUSH
27640: CALL_OW 321
27644: PUSH
27645: LD_INT 2
27647: EQUAL
27648: ST_TO_ADDR
27649: GO 27899
27651: LD_INT 30
27653: DOUBLE
27654: EQUAL
27655: IFTRUE 27659
27657: GO 27684
27659: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27660: LD_ADDR_VAR 0 3
27664: PUSH
27665: LD_INT 20
27667: PPUSH
27668: LD_VAR 0 1
27672: PPUSH
27673: CALL_OW 321
27677: PUSH
27678: LD_INT 2
27680: EQUAL
27681: ST_TO_ADDR
27682: GO 27899
27684: LD_INT 28
27686: DOUBLE
27687: EQUAL
27688: IFTRUE 27698
27690: LD_INT 21
27692: DOUBLE
27693: EQUAL
27694: IFTRUE 27698
27696: GO 27723
27698: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27699: LD_ADDR_VAR 0 3
27703: PUSH
27704: LD_INT 21
27706: PPUSH
27707: LD_VAR 0 1
27711: PPUSH
27712: CALL_OW 321
27716: PUSH
27717: LD_INT 2
27719: EQUAL
27720: ST_TO_ADDR
27721: GO 27899
27723: LD_INT 16
27725: DOUBLE
27726: EQUAL
27727: IFTRUE 27731
27729: GO 27758
27731: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27732: LD_ADDR_VAR 0 3
27736: PUSH
27737: LD_EXP 116
27741: PPUSH
27742: LD_VAR 0 1
27746: PPUSH
27747: CALL_OW 321
27751: PUSH
27752: LD_INT 2
27754: EQUAL
27755: ST_TO_ADDR
27756: GO 27899
27758: LD_INT 19
27760: DOUBLE
27761: EQUAL
27762: IFTRUE 27772
27764: LD_INT 23
27766: DOUBLE
27767: EQUAL
27768: IFTRUE 27772
27770: GO 27799
27772: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27773: LD_ADDR_VAR 0 3
27777: PUSH
27778: LD_EXP 115
27782: PPUSH
27783: LD_VAR 0 1
27787: PPUSH
27788: CALL_OW 321
27792: PUSH
27793: LD_INT 2
27795: EQUAL
27796: ST_TO_ADDR
27797: GO 27899
27799: LD_INT 17
27801: DOUBLE
27802: EQUAL
27803: IFTRUE 27807
27805: GO 27832
27807: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
27808: LD_ADDR_VAR 0 3
27812: PUSH
27813: LD_INT 39
27815: PPUSH
27816: LD_VAR 0 1
27820: PPUSH
27821: CALL_OW 321
27825: PUSH
27826: LD_INT 2
27828: EQUAL
27829: ST_TO_ADDR
27830: GO 27899
27832: LD_INT 18
27834: DOUBLE
27835: EQUAL
27836: IFTRUE 27840
27838: GO 27865
27840: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
27841: LD_ADDR_VAR 0 3
27845: PUSH
27846: LD_INT 40
27848: PPUSH
27849: LD_VAR 0 1
27853: PPUSH
27854: CALL_OW 321
27858: PUSH
27859: LD_INT 2
27861: EQUAL
27862: ST_TO_ADDR
27863: GO 27899
27865: LD_INT 27
27867: DOUBLE
27868: EQUAL
27869: IFTRUE 27873
27871: GO 27898
27873: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
27874: LD_ADDR_VAR 0 3
27878: PUSH
27879: LD_INT 35
27881: PPUSH
27882: LD_VAR 0 1
27886: PPUSH
27887: CALL_OW 321
27891: PUSH
27892: LD_INT 2
27894: EQUAL
27895: ST_TO_ADDR
27896: GO 27899
27898: POP
// end ;
27899: LD_VAR 0 3
27903: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
27904: LD_INT 0
27906: PPUSH
27907: PPUSH
27908: PPUSH
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
27914: PPUSH
27915: PPUSH
27916: PPUSH
// result := false ;
27917: LD_ADDR_VAR 0 6
27921: PUSH
27922: LD_INT 0
27924: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27925: LD_VAR 0 1
27929: NOT
27930: PUSH
27931: LD_VAR 0 1
27935: PPUSH
27936: CALL_OW 266
27940: PUSH
27941: LD_INT 0
27943: PUSH
27944: LD_INT 1
27946: PUSH
27947: EMPTY
27948: LIST
27949: LIST
27950: IN
27951: NOT
27952: OR
27953: PUSH
27954: LD_VAR 0 2
27958: NOT
27959: OR
27960: PUSH
27961: LD_VAR 0 5
27965: PUSH
27966: LD_INT 0
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 2
27974: PUSH
27975: LD_INT 3
27977: PUSH
27978: LD_INT 4
27980: PUSH
27981: LD_INT 5
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: IN
27992: NOT
27993: OR
27994: PUSH
27995: LD_VAR 0 3
27999: PPUSH
28000: LD_VAR 0 4
28004: PPUSH
28005: CALL_OW 488
28009: NOT
28010: OR
28011: IFFALSE 28015
// exit ;
28013: GO 28751
// side := GetSide ( depot ) ;
28015: LD_ADDR_VAR 0 9
28019: PUSH
28020: LD_VAR 0 1
28024: PPUSH
28025: CALL_OW 255
28029: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28030: LD_VAR 0 9
28034: PPUSH
28035: LD_VAR 0 2
28039: PPUSH
28040: CALL 27524 0 2
28044: NOT
28045: IFFALSE 28049
// exit ;
28047: GO 28751
// pom := GetBase ( depot ) ;
28049: LD_ADDR_VAR 0 10
28053: PUSH
28054: LD_VAR 0 1
28058: PPUSH
28059: CALL_OW 274
28063: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28064: LD_ADDR_VAR 0 11
28068: PUSH
28069: LD_VAR 0 2
28073: PPUSH
28074: LD_VAR 0 1
28078: PPUSH
28079: CALL_OW 248
28083: PPUSH
28084: CALL_OW 450
28088: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28089: LD_VAR 0 10
28093: PPUSH
28094: LD_INT 1
28096: PPUSH
28097: CALL_OW 275
28101: PUSH
28102: LD_VAR 0 11
28106: PUSH
28107: LD_INT 1
28109: ARRAY
28110: GREATEREQUAL
28111: PUSH
28112: LD_VAR 0 10
28116: PPUSH
28117: LD_INT 2
28119: PPUSH
28120: CALL_OW 275
28124: PUSH
28125: LD_VAR 0 11
28129: PUSH
28130: LD_INT 2
28132: ARRAY
28133: GREATEREQUAL
28134: AND
28135: PUSH
28136: LD_VAR 0 10
28140: PPUSH
28141: LD_INT 3
28143: PPUSH
28144: CALL_OW 275
28148: PUSH
28149: LD_VAR 0 11
28153: PUSH
28154: LD_INT 3
28156: ARRAY
28157: GREATEREQUAL
28158: AND
28159: NOT
28160: IFFALSE 28164
// exit ;
28162: GO 28751
// if GetBType ( depot ) = b_depot then
28164: LD_VAR 0 1
28168: PPUSH
28169: CALL_OW 266
28173: PUSH
28174: LD_INT 0
28176: EQUAL
28177: IFFALSE 28189
// dist := 28 else
28179: LD_ADDR_VAR 0 14
28183: PUSH
28184: LD_INT 28
28186: ST_TO_ADDR
28187: GO 28197
// dist := 36 ;
28189: LD_ADDR_VAR 0 14
28193: PUSH
28194: LD_INT 36
28196: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28197: LD_VAR 0 1
28201: PPUSH
28202: LD_VAR 0 3
28206: PPUSH
28207: LD_VAR 0 4
28211: PPUSH
28212: CALL_OW 297
28216: PUSH
28217: LD_VAR 0 14
28221: GREATER
28222: IFFALSE 28226
// exit ;
28224: GO 28751
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28226: LD_ADDR_VAR 0 12
28230: PUSH
28231: LD_VAR 0 2
28235: PPUSH
28236: LD_VAR 0 3
28240: PPUSH
28241: LD_VAR 0 4
28245: PPUSH
28246: LD_VAR 0 5
28250: PPUSH
28251: LD_VAR 0 1
28255: PPUSH
28256: CALL_OW 248
28260: PPUSH
28261: LD_INT 0
28263: PPUSH
28264: CALL 28756 0 6
28268: ST_TO_ADDR
// if not hexes then
28269: LD_VAR 0 12
28273: NOT
28274: IFFALSE 28278
// exit ;
28276: GO 28751
// hex := GetHexInfo ( x , y ) ;
28278: LD_ADDR_VAR 0 15
28282: PUSH
28283: LD_VAR 0 3
28287: PPUSH
28288: LD_VAR 0 4
28292: PPUSH
28293: CALL_OW 546
28297: ST_TO_ADDR
// if hex [ 1 ] then
28298: LD_VAR 0 15
28302: PUSH
28303: LD_INT 1
28305: ARRAY
28306: IFFALSE 28310
// exit ;
28308: GO 28751
// height := hex [ 2 ] ;
28310: LD_ADDR_VAR 0 13
28314: PUSH
28315: LD_VAR 0 15
28319: PUSH
28320: LD_INT 2
28322: ARRAY
28323: ST_TO_ADDR
// for i = 1 to hexes do
28324: LD_ADDR_VAR 0 7
28328: PUSH
28329: DOUBLE
28330: LD_INT 1
28332: DEC
28333: ST_TO_ADDR
28334: LD_VAR 0 12
28338: PUSH
28339: FOR_TO
28340: IFFALSE 28670
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28342: LD_VAR 0 12
28346: PUSH
28347: LD_VAR 0 7
28351: ARRAY
28352: PUSH
28353: LD_INT 1
28355: ARRAY
28356: PPUSH
28357: LD_VAR 0 12
28361: PUSH
28362: LD_VAR 0 7
28366: ARRAY
28367: PUSH
28368: LD_INT 2
28370: ARRAY
28371: PPUSH
28372: CALL_OW 488
28376: NOT
28377: PUSH
28378: LD_VAR 0 12
28382: PUSH
28383: LD_VAR 0 7
28387: ARRAY
28388: PUSH
28389: LD_INT 1
28391: ARRAY
28392: PPUSH
28393: LD_VAR 0 12
28397: PUSH
28398: LD_VAR 0 7
28402: ARRAY
28403: PUSH
28404: LD_INT 2
28406: ARRAY
28407: PPUSH
28408: CALL_OW 428
28412: PUSH
28413: LD_INT 0
28415: GREATER
28416: OR
28417: PUSH
28418: LD_VAR 0 12
28422: PUSH
28423: LD_VAR 0 7
28427: ARRAY
28428: PUSH
28429: LD_INT 1
28431: ARRAY
28432: PPUSH
28433: LD_VAR 0 12
28437: PUSH
28438: LD_VAR 0 7
28442: ARRAY
28443: PUSH
28444: LD_INT 2
28446: ARRAY
28447: PPUSH
28448: CALL_OW 351
28452: OR
28453: IFFALSE 28459
// exit ;
28455: POP
28456: POP
28457: GO 28751
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28459: LD_ADDR_VAR 0 8
28463: PUSH
28464: LD_VAR 0 12
28468: PUSH
28469: LD_VAR 0 7
28473: ARRAY
28474: PUSH
28475: LD_INT 1
28477: ARRAY
28478: PPUSH
28479: LD_VAR 0 12
28483: PUSH
28484: LD_VAR 0 7
28488: ARRAY
28489: PUSH
28490: LD_INT 2
28492: ARRAY
28493: PPUSH
28494: CALL_OW 546
28498: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28499: LD_VAR 0 8
28503: PUSH
28504: LD_INT 1
28506: ARRAY
28507: PUSH
28508: LD_VAR 0 8
28512: PUSH
28513: LD_INT 2
28515: ARRAY
28516: PUSH
28517: LD_VAR 0 13
28521: PUSH
28522: LD_INT 2
28524: PLUS
28525: GREATER
28526: OR
28527: PUSH
28528: LD_VAR 0 8
28532: PUSH
28533: LD_INT 2
28535: ARRAY
28536: PUSH
28537: LD_VAR 0 13
28541: PUSH
28542: LD_INT 2
28544: MINUS
28545: LESS
28546: OR
28547: PUSH
28548: LD_VAR 0 8
28552: PUSH
28553: LD_INT 3
28555: ARRAY
28556: PUSH
28557: LD_INT 0
28559: PUSH
28560: LD_INT 8
28562: PUSH
28563: LD_INT 9
28565: PUSH
28566: LD_INT 10
28568: PUSH
28569: LD_INT 11
28571: PUSH
28572: LD_INT 12
28574: PUSH
28575: LD_INT 13
28577: PUSH
28578: LD_INT 16
28580: PUSH
28581: LD_INT 17
28583: PUSH
28584: LD_INT 18
28586: PUSH
28587: LD_INT 19
28589: PUSH
28590: LD_INT 20
28592: PUSH
28593: LD_INT 21
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: IN
28611: NOT
28612: OR
28613: PUSH
28614: LD_VAR 0 8
28618: PUSH
28619: LD_INT 5
28621: ARRAY
28622: NOT
28623: OR
28624: PUSH
28625: LD_VAR 0 8
28629: PUSH
28630: LD_INT 6
28632: ARRAY
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: LD_INT 7
28642: PUSH
28643: LD_INT 9
28645: PUSH
28646: LD_INT 10
28648: PUSH
28649: LD_INT 11
28651: PUSH
28652: EMPTY
28653: LIST
28654: LIST
28655: LIST
28656: LIST
28657: LIST
28658: LIST
28659: IN
28660: NOT
28661: OR
28662: IFFALSE 28668
// exit ;
28664: POP
28665: POP
28666: GO 28751
// end ;
28668: GO 28339
28670: POP
28671: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28672: LD_VAR 0 9
28676: PPUSH
28677: LD_VAR 0 3
28681: PPUSH
28682: LD_VAR 0 4
28686: PPUSH
28687: LD_INT 20
28689: PPUSH
28690: CALL 20697 0 4
28694: PUSH
28695: LD_INT 4
28697: ARRAY
28698: IFFALSE 28702
// exit ;
28700: GO 28751
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28702: LD_VAR 0 2
28706: PUSH
28707: LD_INT 29
28709: PUSH
28710: LD_INT 30
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: IN
28717: PUSH
28718: LD_VAR 0 3
28722: PPUSH
28723: LD_VAR 0 4
28727: PPUSH
28728: LD_VAR 0 9
28732: PPUSH
28733: CALL_OW 440
28737: NOT
28738: AND
28739: IFFALSE 28743
// exit ;
28741: GO 28751
// result := true ;
28743: LD_ADDR_VAR 0 6
28747: PUSH
28748: LD_INT 1
28750: ST_TO_ADDR
// end ;
28751: LD_VAR 0 6
28755: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28756: LD_INT 0
28758: PPUSH
28759: PPUSH
28760: PPUSH
28761: PPUSH
28762: PPUSH
28763: PPUSH
28764: PPUSH
28765: PPUSH
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
28770: PPUSH
28771: PPUSH
28772: PPUSH
28773: PPUSH
28774: PPUSH
28775: PPUSH
28776: PPUSH
28777: PPUSH
28778: PPUSH
28779: PPUSH
28780: PPUSH
28781: PPUSH
28782: PPUSH
28783: PPUSH
28784: PPUSH
28785: PPUSH
28786: PPUSH
28787: PPUSH
28788: PPUSH
28789: PPUSH
28790: PPUSH
28791: PPUSH
28792: PPUSH
28793: PPUSH
28794: PPUSH
28795: PPUSH
28796: PPUSH
28797: PPUSH
28798: PPUSH
28799: PPUSH
28800: PPUSH
28801: PPUSH
28802: PPUSH
28803: PPUSH
28804: PPUSH
28805: PPUSH
28806: PPUSH
28807: PPUSH
28808: PPUSH
28809: PPUSH
28810: PPUSH
28811: PPUSH
28812: PPUSH
28813: PPUSH
28814: PPUSH
28815: PPUSH
// result = [ ] ;
28816: LD_ADDR_VAR 0 7
28820: PUSH
28821: EMPTY
28822: ST_TO_ADDR
// temp_list = [ ] ;
28823: LD_ADDR_VAR 0 9
28827: PUSH
28828: EMPTY
28829: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28830: LD_VAR 0 4
28834: PUSH
28835: LD_INT 0
28837: PUSH
28838: LD_INT 1
28840: PUSH
28841: LD_INT 2
28843: PUSH
28844: LD_INT 3
28846: PUSH
28847: LD_INT 4
28849: PUSH
28850: LD_INT 5
28852: PUSH
28853: EMPTY
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: IN
28861: NOT
28862: PUSH
28863: LD_VAR 0 1
28867: PUSH
28868: LD_INT 0
28870: PUSH
28871: LD_INT 1
28873: PUSH
28874: EMPTY
28875: LIST
28876: LIST
28877: IN
28878: PUSH
28879: LD_VAR 0 5
28883: PUSH
28884: LD_INT 1
28886: PUSH
28887: LD_INT 2
28889: PUSH
28890: LD_INT 3
28892: PUSH
28893: EMPTY
28894: LIST
28895: LIST
28896: LIST
28897: IN
28898: NOT
28899: AND
28900: OR
28901: IFFALSE 28905
// exit ;
28903: GO 47296
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28905: LD_VAR 0 1
28909: PUSH
28910: LD_INT 6
28912: PUSH
28913: LD_INT 7
28915: PUSH
28916: LD_INT 8
28918: PUSH
28919: LD_INT 13
28921: PUSH
28922: LD_INT 12
28924: PUSH
28925: LD_INT 15
28927: PUSH
28928: LD_INT 11
28930: PUSH
28931: LD_INT 14
28933: PUSH
28934: LD_INT 10
28936: PUSH
28937: EMPTY
28938: LIST
28939: LIST
28940: LIST
28941: LIST
28942: LIST
28943: LIST
28944: LIST
28945: LIST
28946: LIST
28947: IN
28948: IFFALSE 28958
// btype = b_lab ;
28950: LD_ADDR_VAR 0 1
28954: PUSH
28955: LD_INT 6
28957: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28958: LD_VAR 0 6
28962: PUSH
28963: LD_INT 0
28965: PUSH
28966: LD_INT 1
28968: PUSH
28969: LD_INT 2
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: LIST
28976: IN
28977: NOT
28978: PUSH
28979: LD_VAR 0 1
28983: PUSH
28984: LD_INT 0
28986: PUSH
28987: LD_INT 1
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 3
28995: PUSH
28996: LD_INT 6
28998: PUSH
28999: LD_INT 36
29001: PUSH
29002: LD_INT 4
29004: PUSH
29005: LD_INT 5
29007: PUSH
29008: LD_INT 31
29010: PUSH
29011: LD_INT 32
29013: PUSH
29014: LD_INT 33
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: IN
29030: NOT
29031: PUSH
29032: LD_VAR 0 6
29036: PUSH
29037: LD_INT 1
29039: EQUAL
29040: AND
29041: OR
29042: PUSH
29043: LD_VAR 0 1
29047: PUSH
29048: LD_INT 2
29050: PUSH
29051: LD_INT 3
29053: PUSH
29054: EMPTY
29055: LIST
29056: LIST
29057: IN
29058: NOT
29059: PUSH
29060: LD_VAR 0 6
29064: PUSH
29065: LD_INT 2
29067: EQUAL
29068: AND
29069: OR
29070: IFFALSE 29080
// mode = 0 ;
29072: LD_ADDR_VAR 0 6
29076: PUSH
29077: LD_INT 0
29079: ST_TO_ADDR
// case mode of 0 :
29080: LD_VAR 0 6
29084: PUSH
29085: LD_INT 0
29087: DOUBLE
29088: EQUAL
29089: IFTRUE 29093
29091: GO 40546
29093: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29094: LD_ADDR_VAR 0 11
29098: PUSH
29099: LD_INT 0
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 1
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 0
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: LD_INT 1
29135: PUSH
29136: EMPTY
29137: LIST
29138: LIST
29139: PUSH
29140: LD_INT 0
29142: PUSH
29143: LD_INT 1
29145: PUSH
29146: EMPTY
29147: LIST
29148: LIST
29149: PUSH
29150: LD_INT 1
29152: NEG
29153: PUSH
29154: LD_INT 0
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: NEG
29164: PUSH
29165: LD_INT 1
29167: NEG
29168: PUSH
29169: EMPTY
29170: LIST
29171: LIST
29172: PUSH
29173: LD_INT 1
29175: NEG
29176: PUSH
29177: LD_INT 2
29179: NEG
29180: PUSH
29181: EMPTY
29182: LIST
29183: LIST
29184: PUSH
29185: LD_INT 0
29187: PUSH
29188: LD_INT 2
29190: NEG
29191: PUSH
29192: EMPTY
29193: LIST
29194: LIST
29195: PUSH
29196: LD_INT 1
29198: PUSH
29199: LD_INT 1
29201: NEG
29202: PUSH
29203: EMPTY
29204: LIST
29205: LIST
29206: PUSH
29207: LD_INT 1
29209: PUSH
29210: LD_INT 2
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: LD_INT 0
29219: PUSH
29220: LD_INT 2
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: LD_INT 1
29229: NEG
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 3
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 3
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 2
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: LIST
29278: LIST
29279: LIST
29280: LIST
29281: LIST
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29287: LD_ADDR_VAR 0 12
29291: PUSH
29292: LD_INT 0
29294: PUSH
29295: LD_INT 0
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 0
29304: PUSH
29305: LD_INT 1
29307: NEG
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: PUSH
29316: LD_INT 0
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 1
29325: PUSH
29326: LD_INT 1
29328: PUSH
29329: EMPTY
29330: LIST
29331: LIST
29332: PUSH
29333: LD_INT 0
29335: PUSH
29336: LD_INT 1
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 1
29345: NEG
29346: PUSH
29347: LD_INT 0
29349: PUSH
29350: EMPTY
29351: LIST
29352: LIST
29353: PUSH
29354: LD_INT 1
29356: NEG
29357: PUSH
29358: LD_INT 1
29360: NEG
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 1
29371: NEG
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: LD_INT 2
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 2
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 1
29399: NEG
29400: PUSH
29401: LD_INT 1
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 0
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 2
29421: NEG
29422: PUSH
29423: LD_INT 1
29425: NEG
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 2
29433: NEG
29434: PUSH
29435: LD_INT 1
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: PUSH
29442: LD_INT 3
29444: NEG
29445: PUSH
29446: LD_INT 0
29448: PUSH
29449: EMPTY
29450: LIST
29451: LIST
29452: PUSH
29453: LD_INT 3
29455: NEG
29456: PUSH
29457: LD_INT 1
29459: NEG
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29483: LD_ADDR_VAR 0 13
29487: PUSH
29488: LD_INT 0
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 0
29500: PUSH
29501: LD_INT 1
29503: NEG
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: PUSH
29512: LD_INT 0
29514: PUSH
29515: EMPTY
29516: LIST
29517: LIST
29518: PUSH
29519: LD_INT 1
29521: PUSH
29522: LD_INT 1
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PUSH
29529: LD_INT 0
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: EMPTY
29536: LIST
29537: LIST
29538: PUSH
29539: LD_INT 1
29541: NEG
29542: PUSH
29543: LD_INT 0
29545: PUSH
29546: EMPTY
29547: LIST
29548: LIST
29549: PUSH
29550: LD_INT 1
29552: NEG
29553: PUSH
29554: LD_INT 1
29556: NEG
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: PUSH
29562: LD_INT 1
29564: NEG
29565: PUSH
29566: LD_INT 2
29568: NEG
29569: PUSH
29570: EMPTY
29571: LIST
29572: LIST
29573: PUSH
29574: LD_INT 2
29576: PUSH
29577: LD_INT 1
29579: PUSH
29580: EMPTY
29581: LIST
29582: LIST
29583: PUSH
29584: LD_INT 2
29586: PUSH
29587: LD_INT 2
29589: PUSH
29590: EMPTY
29591: LIST
29592: LIST
29593: PUSH
29594: LD_INT 1
29596: PUSH
29597: LD_INT 2
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: LD_INT 2
29606: NEG
29607: PUSH
29608: LD_INT 1
29610: NEG
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 2
29618: NEG
29619: PUSH
29620: LD_INT 2
29622: NEG
29623: PUSH
29624: EMPTY
29625: LIST
29626: LIST
29627: PUSH
29628: LD_INT 2
29630: NEG
29631: PUSH
29632: LD_INT 3
29634: NEG
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 3
29642: NEG
29643: PUSH
29644: LD_INT 2
29646: NEG
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 3
29654: NEG
29655: PUSH
29656: LD_INT 3
29658: NEG
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: EMPTY
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29682: LD_ADDR_VAR 0 14
29686: PUSH
29687: LD_INT 0
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 0
29699: PUSH
29700: LD_INT 1
29702: NEG
29703: PUSH
29704: EMPTY
29705: LIST
29706: LIST
29707: PUSH
29708: LD_INT 1
29710: PUSH
29711: LD_INT 0
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 1
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: EMPTY
29725: LIST
29726: LIST
29727: PUSH
29728: LD_INT 0
29730: PUSH
29731: LD_INT 1
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 1
29740: NEG
29741: PUSH
29742: LD_INT 0
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 1
29751: NEG
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 1
29763: NEG
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 0
29775: PUSH
29776: LD_INT 2
29778: NEG
29779: PUSH
29780: EMPTY
29781: LIST
29782: LIST
29783: PUSH
29784: LD_INT 1
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: LD_INT 2
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 0
29807: PUSH
29808: LD_INT 2
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: LD_INT 1
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: NEG
29829: PUSH
29830: LD_INT 3
29832: NEG
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 0
29840: PUSH
29841: LD_INT 3
29843: NEG
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 1
29851: PUSH
29852: LD_INT 2
29854: NEG
29855: PUSH
29856: EMPTY
29857: LIST
29858: LIST
29859: PUSH
29860: EMPTY
29861: LIST
29862: LIST
29863: LIST
29864: LIST
29865: LIST
29866: LIST
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29878: LD_ADDR_VAR 0 15
29882: PUSH
29883: LD_INT 0
29885: PUSH
29886: LD_INT 0
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 0
29895: PUSH
29896: LD_INT 1
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: LD_INT 0
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 1
29916: PUSH
29917: LD_INT 1
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 0
29926: PUSH
29927: LD_INT 1
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: LD_INT 0
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 1
29947: NEG
29948: PUSH
29949: LD_INT 1
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 2
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: NEG
29991: PUSH
29992: LD_INT 1
29994: PUSH
29995: EMPTY
29996: LIST
29997: LIST
29998: PUSH
29999: LD_INT 2
30001: NEG
30002: PUSH
30003: LD_INT 0
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: LD_INT 2
30012: NEG
30013: PUSH
30014: LD_INT 1
30016: NEG
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PUSH
30022: LD_INT 2
30024: PUSH
30025: LD_INT 1
30027: NEG
30028: PUSH
30029: EMPTY
30030: LIST
30031: LIST
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 3
30045: PUSH
30046: LD_INT 1
30048: PUSH
30049: EMPTY
30050: LIST
30051: LIST
30052: PUSH
30053: EMPTY
30054: LIST
30055: LIST
30056: LIST
30057: LIST
30058: LIST
30059: LIST
30060: LIST
30061: LIST
30062: LIST
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30071: LD_ADDR_VAR 0 16
30075: PUSH
30076: LD_INT 0
30078: PUSH
30079: LD_INT 0
30081: PUSH
30082: EMPTY
30083: LIST
30084: LIST
30085: PUSH
30086: LD_INT 0
30088: PUSH
30089: LD_INT 1
30091: NEG
30092: PUSH
30093: EMPTY
30094: LIST
30095: LIST
30096: PUSH
30097: LD_INT 1
30099: PUSH
30100: LD_INT 0
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: PUSH
30110: LD_INT 1
30112: PUSH
30113: EMPTY
30114: LIST
30115: LIST
30116: PUSH
30117: LD_INT 0
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: LD_INT 0
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 1
30140: NEG
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: LD_INT 1
30152: NEG
30153: PUSH
30154: LD_INT 2
30156: NEG
30157: PUSH
30158: EMPTY
30159: LIST
30160: LIST
30161: PUSH
30162: LD_INT 2
30164: PUSH
30165: LD_INT 1
30167: PUSH
30168: EMPTY
30169: LIST
30170: LIST
30171: PUSH
30172: LD_INT 2
30174: PUSH
30175: LD_INT 2
30177: PUSH
30178: EMPTY
30179: LIST
30180: LIST
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: LD_INT 2
30187: PUSH
30188: EMPTY
30189: LIST
30190: LIST
30191: PUSH
30192: LD_INT 2
30194: NEG
30195: PUSH
30196: LD_INT 1
30198: NEG
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 2
30206: NEG
30207: PUSH
30208: LD_INT 2
30210: NEG
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: PUSH
30216: LD_INT 3
30218: PUSH
30219: LD_INT 2
30221: PUSH
30222: EMPTY
30223: LIST
30224: LIST
30225: PUSH
30226: LD_INT 3
30228: PUSH
30229: LD_INT 3
30231: PUSH
30232: EMPTY
30233: LIST
30234: LIST
30235: PUSH
30236: LD_INT 2
30238: PUSH
30239: LD_INT 3
30241: PUSH
30242: EMPTY
30243: LIST
30244: LIST
30245: PUSH
30246: EMPTY
30247: LIST
30248: LIST
30249: LIST
30250: LIST
30251: LIST
30252: LIST
30253: LIST
30254: LIST
30255: LIST
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30264: LD_ADDR_VAR 0 17
30268: PUSH
30269: LD_INT 0
30271: PUSH
30272: LD_INT 0
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PUSH
30279: LD_INT 0
30281: PUSH
30282: LD_INT 1
30284: NEG
30285: PUSH
30286: EMPTY
30287: LIST
30288: LIST
30289: PUSH
30290: LD_INT 1
30292: PUSH
30293: LD_INT 0
30295: PUSH
30296: EMPTY
30297: LIST
30298: LIST
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: LD_INT 1
30305: PUSH
30306: EMPTY
30307: LIST
30308: LIST
30309: PUSH
30310: LD_INT 0
30312: PUSH
30313: LD_INT 1
30315: PUSH
30316: EMPTY
30317: LIST
30318: LIST
30319: PUSH
30320: LD_INT 1
30322: NEG
30323: PUSH
30324: LD_INT 0
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 1
30333: NEG
30334: PUSH
30335: LD_INT 1
30337: NEG
30338: PUSH
30339: EMPTY
30340: LIST
30341: LIST
30342: PUSH
30343: LD_INT 1
30345: NEG
30346: PUSH
30347: LD_INT 2
30349: NEG
30350: PUSH
30351: EMPTY
30352: LIST
30353: LIST
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: LD_INT 2
30360: NEG
30361: PUSH
30362: EMPTY
30363: LIST
30364: LIST
30365: PUSH
30366: LD_INT 1
30368: PUSH
30369: LD_INT 1
30371: NEG
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: LD_INT 2
30379: PUSH
30380: LD_INT 0
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: PUSH
30387: LD_INT 2
30389: PUSH
30390: LD_INT 1
30392: PUSH
30393: EMPTY
30394: LIST
30395: LIST
30396: PUSH
30397: LD_INT 2
30399: PUSH
30400: LD_INT 2
30402: PUSH
30403: EMPTY
30404: LIST
30405: LIST
30406: PUSH
30407: LD_INT 1
30409: PUSH
30410: LD_INT 2
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: LD_INT 2
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: LD_INT 1
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: NEG
30441: PUSH
30442: LD_INT 0
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 2
30451: NEG
30452: PUSH
30453: LD_INT 1
30455: NEG
30456: PUSH
30457: EMPTY
30458: LIST
30459: LIST
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: LD_INT 2
30467: NEG
30468: PUSH
30469: EMPTY
30470: LIST
30471: LIST
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: LIST
30480: LIST
30481: LIST
30482: LIST
30483: LIST
30484: LIST
30485: LIST
30486: LIST
30487: LIST
30488: LIST
30489: LIST
30490: LIST
30491: LIST
30492: LIST
30493: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30494: LD_ADDR_VAR 0 18
30498: PUSH
30499: LD_INT 0
30501: PUSH
30502: LD_INT 0
30504: PUSH
30505: EMPTY
30506: LIST
30507: LIST
30508: PUSH
30509: LD_INT 0
30511: PUSH
30512: LD_INT 1
30514: NEG
30515: PUSH
30516: EMPTY
30517: LIST
30518: LIST
30519: PUSH
30520: LD_INT 1
30522: PUSH
30523: LD_INT 0
30525: PUSH
30526: EMPTY
30527: LIST
30528: LIST
30529: PUSH
30530: LD_INT 1
30532: PUSH
30533: LD_INT 1
30535: PUSH
30536: EMPTY
30537: LIST
30538: LIST
30539: PUSH
30540: LD_INT 0
30542: PUSH
30543: LD_INT 1
30545: PUSH
30546: EMPTY
30547: LIST
30548: LIST
30549: PUSH
30550: LD_INT 1
30552: NEG
30553: PUSH
30554: LD_INT 0
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 1
30563: NEG
30564: PUSH
30565: LD_INT 1
30567: NEG
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 1
30575: NEG
30576: PUSH
30577: LD_INT 2
30579: NEG
30580: PUSH
30581: EMPTY
30582: LIST
30583: LIST
30584: PUSH
30585: LD_INT 0
30587: PUSH
30588: LD_INT 2
30590: NEG
30591: PUSH
30592: EMPTY
30593: LIST
30594: LIST
30595: PUSH
30596: LD_INT 1
30598: PUSH
30599: LD_INT 1
30601: NEG
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 2
30609: PUSH
30610: LD_INT 0
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: PUSH
30623: EMPTY
30624: LIST
30625: LIST
30626: PUSH
30627: LD_INT 2
30629: PUSH
30630: LD_INT 2
30632: PUSH
30633: EMPTY
30634: LIST
30635: LIST
30636: PUSH
30637: LD_INT 1
30639: PUSH
30640: LD_INT 2
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: LD_INT 2
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: PUSH
30657: LD_INT 1
30659: NEG
30660: PUSH
30661: LD_INT 1
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 2
30670: NEG
30671: PUSH
30672: LD_INT 0
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 2
30681: NEG
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: EMPTY
30688: LIST
30689: LIST
30690: PUSH
30691: LD_INT 2
30693: NEG
30694: PUSH
30695: LD_INT 2
30697: NEG
30698: PUSH
30699: EMPTY
30700: LIST
30701: LIST
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: LIST
30707: LIST
30708: LIST
30709: LIST
30710: LIST
30711: LIST
30712: LIST
30713: LIST
30714: LIST
30715: LIST
30716: LIST
30717: LIST
30718: LIST
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30724: LD_ADDR_VAR 0 19
30728: PUSH
30729: LD_INT 0
30731: PUSH
30732: LD_INT 0
30734: PUSH
30735: EMPTY
30736: LIST
30737: LIST
30738: PUSH
30739: LD_INT 0
30741: PUSH
30742: LD_INT 1
30744: NEG
30745: PUSH
30746: EMPTY
30747: LIST
30748: LIST
30749: PUSH
30750: LD_INT 1
30752: PUSH
30753: LD_INT 0
30755: PUSH
30756: EMPTY
30757: LIST
30758: LIST
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: LD_INT 1
30765: PUSH
30766: EMPTY
30767: LIST
30768: LIST
30769: PUSH
30770: LD_INT 0
30772: PUSH
30773: LD_INT 1
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: NEG
30783: PUSH
30784: LD_INT 0
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 1
30793: NEG
30794: PUSH
30795: LD_INT 1
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 2
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 0
30817: PUSH
30818: LD_INT 2
30820: NEG
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 1
30828: PUSH
30829: LD_INT 1
30831: NEG
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 0
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: LD_INT 2
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: LD_INT 2
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: NEG
30890: PUSH
30891: LD_INT 1
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: NEG
30901: PUSH
30902: LD_INT 0
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 2
30911: NEG
30912: PUSH
30913: LD_INT 1
30915: NEG
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 2
30923: NEG
30924: PUSH
30925: LD_INT 2
30927: NEG
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30954: LD_ADDR_VAR 0 20
30958: PUSH
30959: LD_INT 0
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 1
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 2
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 2
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 2
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 2
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 2
31141: NEG
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 2
31157: NEG
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: LIST
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31184: LD_ADDR_VAR 0 21
31188: PUSH
31189: LD_INT 0
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: EMPTY
31196: LIST
31197: LIST
31198: PUSH
31199: LD_INT 0
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: EMPTY
31207: LIST
31208: LIST
31209: PUSH
31210: LD_INT 1
31212: PUSH
31213: LD_INT 0
31215: PUSH
31216: EMPTY
31217: LIST
31218: LIST
31219: PUSH
31220: LD_INT 1
31222: PUSH
31223: LD_INT 1
31225: PUSH
31226: EMPTY
31227: LIST
31228: LIST
31229: PUSH
31230: LD_INT 0
31232: PUSH
31233: LD_INT 1
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 1
31242: NEG
31243: PUSH
31244: LD_INT 0
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 1
31253: NEG
31254: PUSH
31255: LD_INT 1
31257: NEG
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: LD_INT 1
31265: NEG
31266: PUSH
31267: LD_INT 2
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: LD_INT 2
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 1
31288: PUSH
31289: LD_INT 1
31291: NEG
31292: PUSH
31293: EMPTY
31294: LIST
31295: LIST
31296: PUSH
31297: LD_INT 2
31299: PUSH
31300: LD_INT 0
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 2
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: EMPTY
31314: LIST
31315: LIST
31316: PUSH
31317: LD_INT 2
31319: PUSH
31320: LD_INT 2
31322: PUSH
31323: EMPTY
31324: LIST
31325: LIST
31326: PUSH
31327: LD_INT 1
31329: PUSH
31330: LD_INT 2
31332: PUSH
31333: EMPTY
31334: LIST
31335: LIST
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: LD_INT 2
31342: PUSH
31343: EMPTY
31344: LIST
31345: LIST
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: LD_INT 1
31353: PUSH
31354: EMPTY
31355: LIST
31356: LIST
31357: PUSH
31358: LD_INT 2
31360: NEG
31361: PUSH
31362: LD_INT 0
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: PUSH
31369: LD_INT 2
31371: NEG
31372: PUSH
31373: LD_INT 1
31375: NEG
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 2
31383: NEG
31384: PUSH
31385: LD_INT 2
31387: NEG
31388: PUSH
31389: EMPTY
31390: LIST
31391: LIST
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: LIST
31409: LIST
31410: LIST
31411: LIST
31412: LIST
31413: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31414: LD_ADDR_VAR 0 22
31418: PUSH
31419: LD_INT 0
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: EMPTY
31426: LIST
31427: LIST
31428: PUSH
31429: LD_INT 0
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: EMPTY
31437: LIST
31438: LIST
31439: PUSH
31440: LD_INT 1
31442: PUSH
31443: LD_INT 0
31445: PUSH
31446: EMPTY
31447: LIST
31448: LIST
31449: PUSH
31450: LD_INT 1
31452: PUSH
31453: LD_INT 1
31455: PUSH
31456: EMPTY
31457: LIST
31458: LIST
31459: PUSH
31460: LD_INT 0
31462: PUSH
31463: LD_INT 1
31465: PUSH
31466: EMPTY
31467: LIST
31468: LIST
31469: PUSH
31470: LD_INT 1
31472: NEG
31473: PUSH
31474: LD_INT 0
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 1
31483: NEG
31484: PUSH
31485: LD_INT 1
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 1
31495: NEG
31496: PUSH
31497: LD_INT 2
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 0
31507: PUSH
31508: LD_INT 2
31510: NEG
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 1
31518: PUSH
31519: LD_INT 1
31521: NEG
31522: PUSH
31523: EMPTY
31524: LIST
31525: LIST
31526: PUSH
31527: LD_INT 2
31529: PUSH
31530: LD_INT 0
31532: PUSH
31533: EMPTY
31534: LIST
31535: LIST
31536: PUSH
31537: LD_INT 2
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: EMPTY
31544: LIST
31545: LIST
31546: PUSH
31547: LD_INT 2
31549: PUSH
31550: LD_INT 2
31552: PUSH
31553: EMPTY
31554: LIST
31555: LIST
31556: PUSH
31557: LD_INT 1
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: LD_INT 2
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: EMPTY
31585: LIST
31586: LIST
31587: PUSH
31588: LD_INT 2
31590: NEG
31591: PUSH
31592: LD_INT 0
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: PUSH
31599: LD_INT 2
31601: NEG
31602: PUSH
31603: LD_INT 1
31605: NEG
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 2
31613: NEG
31614: PUSH
31615: LD_INT 2
31617: NEG
31618: PUSH
31619: EMPTY
31620: LIST
31621: LIST
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: LIST
31639: LIST
31640: LIST
31641: LIST
31642: LIST
31643: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31644: LD_ADDR_VAR 0 23
31648: PUSH
31649: LD_INT 0
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 0
31661: PUSH
31662: LD_INT 1
31664: NEG
31665: PUSH
31666: EMPTY
31667: LIST
31668: LIST
31669: PUSH
31670: LD_INT 1
31672: PUSH
31673: LD_INT 0
31675: PUSH
31676: EMPTY
31677: LIST
31678: LIST
31679: PUSH
31680: LD_INT 1
31682: PUSH
31683: LD_INT 1
31685: PUSH
31686: EMPTY
31687: LIST
31688: LIST
31689: PUSH
31690: LD_INT 0
31692: PUSH
31693: LD_INT 1
31695: PUSH
31696: EMPTY
31697: LIST
31698: LIST
31699: PUSH
31700: LD_INT 1
31702: NEG
31703: PUSH
31704: LD_INT 0
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 1
31713: NEG
31714: PUSH
31715: LD_INT 1
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: LD_INT 1
31725: NEG
31726: PUSH
31727: LD_INT 2
31729: NEG
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: LD_INT 2
31740: NEG
31741: PUSH
31742: EMPTY
31743: LIST
31744: LIST
31745: PUSH
31746: LD_INT 1
31748: PUSH
31749: LD_INT 1
31751: NEG
31752: PUSH
31753: EMPTY
31754: LIST
31755: LIST
31756: PUSH
31757: LD_INT 2
31759: PUSH
31760: LD_INT 0
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PUSH
31767: LD_INT 2
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: EMPTY
31774: LIST
31775: LIST
31776: PUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 2
31782: PUSH
31783: EMPTY
31784: LIST
31785: LIST
31786: PUSH
31787: LD_INT 1
31789: PUSH
31790: LD_INT 2
31792: PUSH
31793: EMPTY
31794: LIST
31795: LIST
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: LD_INT 2
31802: PUSH
31803: EMPTY
31804: LIST
31805: LIST
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: LD_INT 1
31813: PUSH
31814: EMPTY
31815: LIST
31816: LIST
31817: PUSH
31818: LD_INT 2
31820: NEG
31821: PUSH
31822: LD_INT 0
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: PUSH
31829: LD_INT 2
31831: NEG
31832: PUSH
31833: LD_INT 1
31835: NEG
31836: PUSH
31837: EMPTY
31838: LIST
31839: LIST
31840: PUSH
31841: LD_INT 2
31843: NEG
31844: PUSH
31845: LD_INT 2
31847: NEG
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: LD_INT 3
31859: NEG
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 1
31867: NEG
31868: PUSH
31869: LD_INT 3
31871: NEG
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 1
31879: PUSH
31880: LD_INT 2
31882: NEG
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: PUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 1
31893: NEG
31894: PUSH
31895: EMPTY
31896: LIST
31897: LIST
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: LIST
31903: LIST
31904: LIST
31905: LIST
31906: LIST
31907: LIST
31908: LIST
31909: LIST
31910: LIST
31911: LIST
31912: LIST
31913: LIST
31914: LIST
31915: LIST
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: LIST
31921: LIST
31922: LIST
31923: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31924: LD_ADDR_VAR 0 24
31928: PUSH
31929: LD_INT 0
31931: PUSH
31932: LD_INT 0
31934: PUSH
31935: EMPTY
31936: LIST
31937: LIST
31938: PUSH
31939: LD_INT 0
31941: PUSH
31942: LD_INT 1
31944: NEG
31945: PUSH
31946: EMPTY
31947: LIST
31948: LIST
31949: PUSH
31950: LD_INT 1
31952: PUSH
31953: LD_INT 0
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: PUSH
31963: LD_INT 1
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: PUSH
31970: LD_INT 0
31972: PUSH
31973: LD_INT 1
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 0
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: LD_INT 1
31993: NEG
31994: PUSH
31995: LD_INT 1
31997: NEG
31998: PUSH
31999: EMPTY
32000: LIST
32001: LIST
32002: PUSH
32003: LD_INT 1
32005: NEG
32006: PUSH
32007: LD_INT 2
32009: NEG
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 0
32017: PUSH
32018: LD_INT 2
32020: NEG
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: PUSH
32029: LD_INT 1
32031: NEG
32032: PUSH
32033: EMPTY
32034: LIST
32035: LIST
32036: PUSH
32037: LD_INT 2
32039: PUSH
32040: LD_INT 0
32042: PUSH
32043: EMPTY
32044: LIST
32045: LIST
32046: PUSH
32047: LD_INT 2
32049: PUSH
32050: LD_INT 1
32052: PUSH
32053: EMPTY
32054: LIST
32055: LIST
32056: PUSH
32057: LD_INT 2
32059: PUSH
32060: LD_INT 2
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 2
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: LD_INT 2
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 1
32089: NEG
32090: PUSH
32091: LD_INT 1
32093: PUSH
32094: EMPTY
32095: LIST
32096: LIST
32097: PUSH
32098: LD_INT 2
32100: NEG
32101: PUSH
32102: LD_INT 0
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PUSH
32109: LD_INT 2
32111: NEG
32112: PUSH
32113: LD_INT 1
32115: NEG
32116: PUSH
32117: EMPTY
32118: LIST
32119: LIST
32120: PUSH
32121: LD_INT 2
32123: NEG
32124: PUSH
32125: LD_INT 2
32127: NEG
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: PUSH
32136: LD_INT 2
32138: NEG
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: PUSH
32147: LD_INT 1
32149: NEG
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 3
32157: PUSH
32158: LD_INT 1
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: PUSH
32165: LD_INT 3
32167: PUSH
32168: LD_INT 2
32170: PUSH
32171: EMPTY
32172: LIST
32173: LIST
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: LIST
32199: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32200: LD_ADDR_VAR 0 25
32204: PUSH
32205: LD_INT 0
32207: PUSH
32208: LD_INT 0
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: LD_INT 1
32220: NEG
32221: PUSH
32222: EMPTY
32223: LIST
32224: LIST
32225: PUSH
32226: LD_INT 1
32228: PUSH
32229: LD_INT 0
32231: PUSH
32232: EMPTY
32233: LIST
32234: LIST
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: LD_INT 1
32241: PUSH
32242: EMPTY
32243: LIST
32244: LIST
32245: PUSH
32246: LD_INT 0
32248: PUSH
32249: LD_INT 1
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 0
32262: PUSH
32263: EMPTY
32264: LIST
32265: LIST
32266: PUSH
32267: LD_INT 1
32269: NEG
32270: PUSH
32271: LD_INT 1
32273: NEG
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 1
32281: NEG
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: LD_INT 2
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: LD_INT 1
32307: NEG
32308: PUSH
32309: EMPTY
32310: LIST
32311: LIST
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: LD_INT 0
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: PUSH
32326: LD_INT 1
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 2
32335: PUSH
32336: LD_INT 2
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 1
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: EMPTY
32350: LIST
32351: LIST
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: LD_INT 2
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: LD_INT 1
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 0
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 2
32387: NEG
32388: PUSH
32389: LD_INT 1
32391: NEG
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 2
32399: NEG
32400: PUSH
32401: LD_INT 2
32403: NEG
32404: PUSH
32405: EMPTY
32406: LIST
32407: LIST
32408: PUSH
32409: LD_INT 3
32411: PUSH
32412: LD_INT 1
32414: PUSH
32415: EMPTY
32416: LIST
32417: LIST
32418: PUSH
32419: LD_INT 3
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: EMPTY
32426: LIST
32427: LIST
32428: PUSH
32429: LD_INT 2
32431: PUSH
32432: LD_INT 3
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 1
32441: PUSH
32442: LD_INT 3
32444: PUSH
32445: EMPTY
32446: LIST
32447: LIST
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: LIST
32469: LIST
32470: LIST
32471: LIST
32472: LIST
32473: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32474: LD_ADDR_VAR 0 26
32478: PUSH
32479: LD_INT 0
32481: PUSH
32482: LD_INT 0
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: EMPTY
32497: LIST
32498: LIST
32499: PUSH
32500: LD_INT 1
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 1
32512: PUSH
32513: LD_INT 1
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 0
32522: PUSH
32523: LD_INT 1
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: EMPTY
32538: LIST
32539: LIST
32540: PUSH
32541: LD_INT 1
32543: NEG
32544: PUSH
32545: LD_INT 1
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 1
32555: NEG
32556: PUSH
32557: LD_INT 2
32559: NEG
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 2
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: LD_INT 1
32581: NEG
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 2
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 2
32599: PUSH
32600: LD_INT 1
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: PUSH
32610: LD_INT 2
32612: PUSH
32613: EMPTY
32614: LIST
32615: LIST
32616: PUSH
32617: LD_INT 1
32619: PUSH
32620: LD_INT 2
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: LD_INT 2
32632: PUSH
32633: EMPTY
32634: LIST
32635: LIST
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: EMPTY
32645: LIST
32646: LIST
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 2
32661: NEG
32662: PUSH
32663: LD_INT 1
32665: NEG
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: PUSH
32671: LD_INT 2
32673: NEG
32674: PUSH
32675: LD_INT 2
32677: NEG
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 2
32685: PUSH
32686: LD_INT 3
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: PUSH
32696: LD_INT 3
32698: PUSH
32699: EMPTY
32700: LIST
32701: LIST
32702: PUSH
32703: LD_INT 1
32705: NEG
32706: PUSH
32707: LD_INT 2
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 2
32716: NEG
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: EMPTY
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: LIST
32745: LIST
32746: LIST
32747: LIST
32748: LIST
32749: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32750: LD_ADDR_VAR 0 27
32754: PUSH
32755: LD_INT 0
32757: PUSH
32758: LD_INT 0
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 1
32770: NEG
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: LD_INT 0
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: LD_INT 1
32791: PUSH
32792: EMPTY
32793: LIST
32794: LIST
32795: PUSH
32796: LD_INT 0
32798: PUSH
32799: LD_INT 1
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 1
32808: NEG
32809: PUSH
32810: LD_INT 0
32812: PUSH
32813: EMPTY
32814: LIST
32815: LIST
32816: PUSH
32817: LD_INT 1
32819: NEG
32820: PUSH
32821: LD_INT 1
32823: NEG
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 1
32831: NEG
32832: PUSH
32833: LD_INT 2
32835: NEG
32836: PUSH
32837: EMPTY
32838: LIST
32839: LIST
32840: PUSH
32841: LD_INT 0
32843: PUSH
32844: LD_INT 2
32846: NEG
32847: PUSH
32848: EMPTY
32849: LIST
32850: LIST
32851: PUSH
32852: LD_INT 1
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: EMPTY
32860: LIST
32861: LIST
32862: PUSH
32863: LD_INT 2
32865: PUSH
32866: LD_INT 0
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: PUSH
32876: LD_INT 1
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 2
32885: PUSH
32886: LD_INT 2
32888: PUSH
32889: EMPTY
32890: LIST
32891: LIST
32892: PUSH
32893: LD_INT 1
32895: PUSH
32896: LD_INT 2
32898: PUSH
32899: EMPTY
32900: LIST
32901: LIST
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: LD_INT 2
32908: PUSH
32909: EMPTY
32910: LIST
32911: LIST
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: LD_INT 1
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: LD_INT 0
32930: PUSH
32931: EMPTY
32932: LIST
32933: LIST
32934: PUSH
32935: LD_INT 2
32937: NEG
32938: PUSH
32939: LD_INT 1
32941: NEG
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 2
32949: NEG
32950: PUSH
32951: LD_INT 2
32953: NEG
32954: PUSH
32955: EMPTY
32956: LIST
32957: LIST
32958: PUSH
32959: LD_INT 1
32961: NEG
32962: PUSH
32963: LD_INT 2
32965: PUSH
32966: EMPTY
32967: LIST
32968: LIST
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: LD_INT 1
32976: PUSH
32977: EMPTY
32978: LIST
32979: LIST
32980: PUSH
32981: LD_INT 3
32983: NEG
32984: PUSH
32985: LD_INT 1
32987: NEG
32988: PUSH
32989: EMPTY
32990: LIST
32991: LIST
32992: PUSH
32993: LD_INT 3
32995: NEG
32996: PUSH
32997: LD_INT 2
32999: NEG
33000: PUSH
33001: EMPTY
33002: LIST
33003: LIST
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: LIST
33019: LIST
33020: LIST
33021: LIST
33022: LIST
33023: LIST
33024: LIST
33025: LIST
33026: LIST
33027: LIST
33028: LIST
33029: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33030: LD_ADDR_VAR 0 28
33034: PUSH
33035: LD_INT 0
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 0
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: EMPTY
33063: LIST
33064: LIST
33065: PUSH
33066: LD_INT 1
33068: PUSH
33069: LD_INT 1
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 0
33078: PUSH
33079: LD_INT 1
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 0
33092: PUSH
33093: EMPTY
33094: LIST
33095: LIST
33096: PUSH
33097: LD_INT 1
33099: NEG
33100: PUSH
33101: LD_INT 1
33103: NEG
33104: PUSH
33105: EMPTY
33106: LIST
33107: LIST
33108: PUSH
33109: LD_INT 1
33111: NEG
33112: PUSH
33113: LD_INT 2
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 2
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 1
33137: NEG
33138: PUSH
33139: EMPTY
33140: LIST
33141: LIST
33142: PUSH
33143: LD_INT 2
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 2
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: PUSH
33166: LD_INT 2
33168: PUSH
33169: EMPTY
33170: LIST
33171: LIST
33172: PUSH
33173: LD_INT 1
33175: PUSH
33176: LD_INT 2
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: LD_INT 2
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: LD_INT 1
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 2
33217: NEG
33218: PUSH
33219: LD_INT 1
33221: NEG
33222: PUSH
33223: EMPTY
33224: LIST
33225: LIST
33226: PUSH
33227: LD_INT 2
33229: NEG
33230: PUSH
33231: LD_INT 2
33233: NEG
33234: PUSH
33235: EMPTY
33236: LIST
33237: LIST
33238: PUSH
33239: LD_INT 2
33241: NEG
33242: PUSH
33243: LD_INT 3
33245: NEG
33246: PUSH
33247: EMPTY
33248: LIST
33249: LIST
33250: PUSH
33251: LD_INT 1
33253: NEG
33254: PUSH
33255: LD_INT 3
33257: NEG
33258: PUSH
33259: EMPTY
33260: LIST
33261: LIST
33262: PUSH
33263: LD_INT 3
33265: NEG
33266: PUSH
33267: LD_INT 1
33269: NEG
33270: PUSH
33271: EMPTY
33272: LIST
33273: LIST
33274: PUSH
33275: LD_INT 3
33277: NEG
33278: PUSH
33279: LD_INT 2
33281: NEG
33282: PUSH
33283: EMPTY
33284: LIST
33285: LIST
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: LIST
33295: LIST
33296: LIST
33297: LIST
33298: LIST
33299: LIST
33300: LIST
33301: LIST
33302: LIST
33303: LIST
33304: LIST
33305: LIST
33306: LIST
33307: LIST
33308: LIST
33309: LIST
33310: LIST
33311: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33312: LD_ADDR_VAR 0 29
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: LD_INT 0
33322: PUSH
33323: EMPTY
33324: LIST
33325: LIST
33326: PUSH
33327: LD_INT 0
33329: PUSH
33330: LD_INT 1
33332: NEG
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 1
33350: PUSH
33351: LD_INT 1
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: LD_INT 1
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 0
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 1
33381: NEG
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 1
33393: NEG
33394: PUSH
33395: LD_INT 2
33397: NEG
33398: PUSH
33399: EMPTY
33400: LIST
33401: LIST
33402: PUSH
33403: LD_INT 0
33405: PUSH
33406: LD_INT 2
33408: NEG
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: PUSH
33414: LD_INT 1
33416: PUSH
33417: LD_INT 1
33419: NEG
33420: PUSH
33421: EMPTY
33422: LIST
33423: LIST
33424: PUSH
33425: LD_INT 2
33427: PUSH
33428: LD_INT 0
33430: PUSH
33431: EMPTY
33432: LIST
33433: LIST
33434: PUSH
33435: LD_INT 2
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: LD_INT 2
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: LD_INT 0
33457: PUSH
33458: LD_INT 2
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: EMPTY
33473: LIST
33474: LIST
33475: PUSH
33476: LD_INT 2
33478: NEG
33479: PUSH
33480: LD_INT 1
33482: NEG
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 2
33490: NEG
33491: PUSH
33492: LD_INT 2
33494: NEG
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 2
33502: NEG
33503: PUSH
33504: LD_INT 3
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 2
33514: PUSH
33515: LD_INT 1
33517: NEG
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 3
33525: PUSH
33526: LD_INT 1
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 1
33535: PUSH
33536: LD_INT 3
33538: PUSH
33539: EMPTY
33540: LIST
33541: LIST
33542: PUSH
33543: LD_INT 1
33545: NEG
33546: PUSH
33547: LD_INT 2
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 3
33556: NEG
33557: PUSH
33558: LD_INT 2
33560: NEG
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: LIST
33575: LIST
33576: LIST
33577: LIST
33578: LIST
33579: LIST
33580: LIST
33581: LIST
33582: LIST
33583: LIST
33584: LIST
33585: LIST
33586: LIST
33587: LIST
33588: LIST
33589: LIST
33590: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33591: LD_ADDR_VAR 0 30
33595: PUSH
33596: LD_INT 0
33598: PUSH
33599: LD_INT 0
33601: PUSH
33602: EMPTY
33603: LIST
33604: LIST
33605: PUSH
33606: LD_INT 0
33608: PUSH
33609: LD_INT 1
33611: NEG
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: LD_INT 1
33619: PUSH
33620: LD_INT 0
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 1
33629: PUSH
33630: LD_INT 1
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 0
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 0
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 1
33660: NEG
33661: PUSH
33662: LD_INT 1
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: LD_INT 2
33676: NEG
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: LD_INT 2
33687: NEG
33688: PUSH
33689: EMPTY
33690: LIST
33691: LIST
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: LD_INT 1
33698: NEG
33699: PUSH
33700: EMPTY
33701: LIST
33702: LIST
33703: PUSH
33704: LD_INT 2
33706: PUSH
33707: LD_INT 0
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 1
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: LD_INT 2
33726: PUSH
33727: LD_INT 2
33729: PUSH
33730: EMPTY
33731: LIST
33732: LIST
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: LD_INT 2
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: NEG
33747: PUSH
33748: LD_INT 1
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 2
33757: NEG
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PUSH
33766: LD_INT 2
33768: NEG
33769: PUSH
33770: LD_INT 1
33772: NEG
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: PUSH
33778: LD_INT 1
33780: NEG
33781: PUSH
33782: LD_INT 3
33784: NEG
33785: PUSH
33786: EMPTY
33787: LIST
33788: LIST
33789: PUSH
33790: LD_INT 1
33792: PUSH
33793: LD_INT 2
33795: NEG
33796: PUSH
33797: EMPTY
33798: LIST
33799: LIST
33800: PUSH
33801: LD_INT 3
33803: PUSH
33804: LD_INT 2
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: PUSH
33811: LD_INT 2
33813: PUSH
33814: LD_INT 3
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: LD_INT 1
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: LD_INT 3
33834: NEG
33835: PUSH
33836: LD_INT 1
33838: NEG
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: LIST
33866: LIST
33867: LIST
33868: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33869: LD_ADDR_VAR 0 31
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: LD_INT 0
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 0
33886: PUSH
33887: LD_INT 1
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 0
33900: PUSH
33901: EMPTY
33902: LIST
33903: LIST
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: LD_INT 1
33910: PUSH
33911: EMPTY
33912: LIST
33913: LIST
33914: PUSH
33915: LD_INT 0
33917: PUSH
33918: LD_INT 1
33920: PUSH
33921: EMPTY
33922: LIST
33923: LIST
33924: PUSH
33925: LD_INT 1
33927: NEG
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 1
33950: NEG
33951: PUSH
33952: LD_INT 2
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: LD_INT 1
33965: NEG
33966: PUSH
33967: EMPTY
33968: LIST
33969: LIST
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: LD_INT 0
33976: PUSH
33977: EMPTY
33978: LIST
33979: LIST
33980: PUSH
33981: LD_INT 2
33983: PUSH
33984: LD_INT 1
33986: PUSH
33987: EMPTY
33988: LIST
33989: LIST
33990: PUSH
33991: LD_INT 2
33993: PUSH
33994: LD_INT 2
33996: PUSH
33997: EMPTY
33998: LIST
33999: LIST
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: LD_INT 2
34006: PUSH
34007: EMPTY
34008: LIST
34009: LIST
34010: PUSH
34011: LD_INT 0
34013: PUSH
34014: LD_INT 2
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 1
34023: NEG
34024: PUSH
34025: LD_INT 1
34027: PUSH
34028: EMPTY
34029: LIST
34030: LIST
34031: PUSH
34032: LD_INT 2
34034: NEG
34035: PUSH
34036: LD_INT 1
34038: NEG
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: NEG
34047: PUSH
34048: LD_INT 2
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 2
34058: NEG
34059: PUSH
34060: LD_INT 3
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 2
34070: PUSH
34071: LD_INT 1
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 3
34081: PUSH
34082: LD_INT 1
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 1
34091: PUSH
34092: LD_INT 3
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 3
34112: NEG
34113: PUSH
34114: LD_INT 2
34116: NEG
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: LIST
34136: LIST
34137: LIST
34138: LIST
34139: LIST
34140: LIST
34141: LIST
34142: LIST
34143: LIST
34144: LIST
34145: LIST
34146: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34147: LD_ADDR_VAR 0 32
34151: PUSH
34152: LD_INT 0
34154: PUSH
34155: LD_INT 0
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 0
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 1
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 1
34185: PUSH
34186: LD_INT 1
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 0
34195: PUSH
34196: LD_INT 1
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 1
34216: NEG
34217: PUSH
34218: LD_INT 1
34220: NEG
34221: PUSH
34222: EMPTY
34223: LIST
34224: LIST
34225: PUSH
34226: LD_INT 1
34228: NEG
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 0
34240: PUSH
34241: LD_INT 2
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 1
34251: PUSH
34252: LD_INT 1
34254: NEG
34255: PUSH
34256: EMPTY
34257: LIST
34258: LIST
34259: PUSH
34260: LD_INT 2
34262: PUSH
34263: LD_INT 1
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 2
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 1
34282: PUSH
34283: LD_INT 2
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 0
34292: PUSH
34293: LD_INT 2
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 1
34302: NEG
34303: PUSH
34304: LD_INT 1
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: LD_INT 0
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 2
34324: NEG
34325: PUSH
34326: LD_INT 1
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: NEG
34337: PUSH
34338: LD_INT 3
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 1
34348: PUSH
34349: LD_INT 2
34351: NEG
34352: PUSH
34353: EMPTY
34354: LIST
34355: LIST
34356: PUSH
34357: LD_INT 3
34359: PUSH
34360: LD_INT 2
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 2
34369: PUSH
34370: LD_INT 3
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 2
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 3
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: NEG
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: EMPTY
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: LIST
34414: LIST
34415: LIST
34416: LIST
34417: LIST
34418: LIST
34419: LIST
34420: LIST
34421: LIST
34422: LIST
34423: LIST
34424: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34425: LD_ADDR_VAR 0 33
34429: PUSH
34430: LD_INT 0
34432: PUSH
34433: LD_INT 0
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: LD_INT 1
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 0
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 1
34463: PUSH
34464: LD_INT 1
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: PUSH
34471: LD_INT 0
34473: PUSH
34474: LD_INT 1
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 1
34494: NEG
34495: PUSH
34496: LD_INT 1
34498: NEG
34499: PUSH
34500: EMPTY
34501: LIST
34502: LIST
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: LD_INT 2
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: LD_INT 1
34521: NEG
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 2
34529: PUSH
34530: LD_INT 0
34532: PUSH
34533: EMPTY
34534: LIST
34535: LIST
34536: PUSH
34537: LD_INT 2
34539: PUSH
34540: LD_INT 1
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: PUSH
34547: LD_INT 1
34549: PUSH
34550: LD_INT 2
34552: PUSH
34553: EMPTY
34554: LIST
34555: LIST
34556: PUSH
34557: LD_INT 0
34559: PUSH
34560: LD_INT 2
34562: PUSH
34563: EMPTY
34564: LIST
34565: LIST
34566: PUSH
34567: LD_INT 1
34569: NEG
34570: PUSH
34571: LD_INT 1
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 2
34580: NEG
34581: PUSH
34582: LD_INT 0
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 2
34591: NEG
34592: PUSH
34593: LD_INT 1
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 2
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: NEG
34616: PUSH
34617: LD_INT 3
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 2
34627: PUSH
34628: LD_INT 1
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 3
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 1
34648: PUSH
34649: LD_INT 3
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 1
34658: NEG
34659: PUSH
34660: LD_INT 2
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: LD_INT 3
34669: NEG
34670: PUSH
34671: LD_INT 2
34673: NEG
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: LIST
34692: LIST
34693: LIST
34694: LIST
34695: LIST
34696: LIST
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34704: LD_ADDR_VAR 0 34
34708: PUSH
34709: LD_INT 0
34711: PUSH
34712: LD_INT 0
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 0
34721: PUSH
34722: LD_INT 1
34724: NEG
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 1
34732: PUSH
34733: LD_INT 0
34735: PUSH
34736: EMPTY
34737: LIST
34738: LIST
34739: PUSH
34740: LD_INT 1
34742: PUSH
34743: LD_INT 1
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: PUSH
34756: EMPTY
34757: LIST
34758: LIST
34759: PUSH
34760: LD_INT 1
34762: NEG
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: LD_INT 1
34777: NEG
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 1
34785: NEG
34786: PUSH
34787: LD_INT 2
34789: NEG
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: LD_INT 2
34800: NEG
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 1
34808: PUSH
34809: LD_INT 1
34811: NEG
34812: PUSH
34813: EMPTY
34814: LIST
34815: LIST
34816: PUSH
34817: LD_INT 2
34819: PUSH
34820: LD_INT 1
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 2
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 2
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 1
34849: NEG
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: NEG
34861: PUSH
34862: LD_INT 0
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 2
34871: NEG
34872: PUSH
34873: LD_INT 1
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: LD_INT 2
34883: NEG
34884: PUSH
34885: LD_INT 2
34887: NEG
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: NEG
34896: PUSH
34897: LD_INT 3
34899: NEG
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 3
34918: PUSH
34919: LD_INT 2
34921: PUSH
34922: EMPTY
34923: LIST
34924: LIST
34925: PUSH
34926: LD_INT 2
34928: PUSH
34929: LD_INT 3
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 1
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 3
34949: NEG
34950: PUSH
34951: LD_INT 1
34953: NEG
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: LIST
34970: LIST
34971: LIST
34972: LIST
34973: LIST
34974: LIST
34975: LIST
34976: LIST
34977: LIST
34978: LIST
34979: LIST
34980: LIST
34981: LIST
34982: LIST
34983: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34984: LD_ADDR_VAR 0 35
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: LD_INT 0
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: LD_INT 1
35004: NEG
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 1
35012: PUSH
35013: LD_INT 0
35015: PUSH
35016: EMPTY
35017: LIST
35018: LIST
35019: PUSH
35020: LD_INT 1
35022: PUSH
35023: LD_INT 1
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: LD_INT 1
35035: PUSH
35036: EMPTY
35037: LIST
35038: LIST
35039: PUSH
35040: LD_INT 1
35042: NEG
35043: PUSH
35044: LD_INT 0
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 1
35053: NEG
35054: PUSH
35055: LD_INT 1
35057: NEG
35058: PUSH
35059: EMPTY
35060: LIST
35061: LIST
35062: PUSH
35063: LD_INT 2
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 2
35075: NEG
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35096: LD_ADDR_VAR 0 36
35100: PUSH
35101: LD_INT 0
35103: PUSH
35104: LD_INT 0
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 0
35113: PUSH
35114: LD_INT 1
35116: NEG
35117: PUSH
35118: EMPTY
35119: LIST
35120: LIST
35121: PUSH
35122: LD_INT 1
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: EMPTY
35129: LIST
35130: LIST
35131: PUSH
35132: LD_INT 1
35134: PUSH
35135: LD_INT 1
35137: PUSH
35138: EMPTY
35139: LIST
35140: LIST
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 1
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 1
35165: NEG
35166: PUSH
35167: LD_INT 1
35169: NEG
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 1
35177: NEG
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 2
35192: PUSH
35193: EMPTY
35194: LIST
35195: LIST
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: LIST
35201: LIST
35202: LIST
35203: LIST
35204: LIST
35205: LIST
35206: LIST
35207: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35208: LD_ADDR_VAR 0 37
35212: PUSH
35213: LD_INT 0
35215: PUSH
35216: LD_INT 0
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 0
35225: PUSH
35226: LD_INT 1
35228: NEG
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: PUSH
35234: LD_INT 1
35236: PUSH
35237: LD_INT 0
35239: PUSH
35240: EMPTY
35241: LIST
35242: LIST
35243: PUSH
35244: LD_INT 1
35246: PUSH
35247: LD_INT 1
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: LD_INT 1
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: LD_INT 0
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: NEG
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 1
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 1
35300: NEG
35301: PUSH
35302: LD_INT 1
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: LIST
35313: LIST
35314: LIST
35315: LIST
35316: LIST
35317: LIST
35318: LIST
35319: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35320: LD_ADDR_VAR 0 38
35324: PUSH
35325: LD_INT 0
35327: PUSH
35328: LD_INT 0
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 0
35337: PUSH
35338: LD_INT 1
35340: NEG
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 1
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: EMPTY
35353: LIST
35354: LIST
35355: PUSH
35356: LD_INT 1
35358: PUSH
35359: LD_INT 1
35361: PUSH
35362: EMPTY
35363: LIST
35364: LIST
35365: PUSH
35366: LD_INT 0
35368: PUSH
35369: LD_INT 1
35371: PUSH
35372: EMPTY
35373: LIST
35374: LIST
35375: PUSH
35376: LD_INT 1
35378: NEG
35379: PUSH
35380: LD_INT 0
35382: PUSH
35383: EMPTY
35384: LIST
35385: LIST
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: LD_INT 1
35393: NEG
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 2
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 2
35411: NEG
35412: PUSH
35413: LD_INT 1
35415: NEG
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35432: LD_ADDR_VAR 0 39
35436: PUSH
35437: LD_INT 0
35439: PUSH
35440: LD_INT 0
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: LD_INT 0
35449: PUSH
35450: LD_INT 1
35452: NEG
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: PUSH
35458: LD_INT 1
35460: PUSH
35461: LD_INT 0
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 1
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: EMPTY
35475: LIST
35476: LIST
35477: PUSH
35478: LD_INT 0
35480: PUSH
35481: LD_INT 1
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: NEG
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 1
35501: NEG
35502: PUSH
35503: LD_INT 1
35505: NEG
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 1
35513: NEG
35514: PUSH
35515: LD_INT 2
35517: NEG
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 1
35525: PUSH
35526: LD_INT 2
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: LIST
35537: LIST
35538: LIST
35539: LIST
35540: LIST
35541: LIST
35542: LIST
35543: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35544: LD_ADDR_VAR 0 40
35548: PUSH
35549: LD_INT 0
35551: PUSH
35552: LD_INT 0
35554: PUSH
35555: EMPTY
35556: LIST
35557: LIST
35558: PUSH
35559: LD_INT 0
35561: PUSH
35562: LD_INT 1
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: PUSH
35573: LD_INT 0
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 1
35582: PUSH
35583: LD_INT 1
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: LD_INT 1
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 0
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 1
35613: NEG
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 1
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 1
35636: NEG
35637: PUSH
35638: LD_INT 1
35640: PUSH
35641: EMPTY
35642: LIST
35643: LIST
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35656: LD_ADDR_VAR 0 41
35660: PUSH
35661: LD_INT 0
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: EMPTY
35668: LIST
35669: LIST
35670: PUSH
35671: LD_INT 0
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: LD_INT 0
35687: PUSH
35688: EMPTY
35689: LIST
35690: LIST
35691: PUSH
35692: LD_INT 1
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: EMPTY
35699: LIST
35700: LIST
35701: PUSH
35702: LD_INT 0
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: EMPTY
35709: LIST
35710: LIST
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: LD_INT 0
35718: PUSH
35719: EMPTY
35720: LIST
35721: LIST
35722: PUSH
35723: LD_INT 1
35725: NEG
35726: PUSH
35727: LD_INT 1
35729: NEG
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 1
35737: NEG
35738: PUSH
35739: LD_INT 2
35741: NEG
35742: PUSH
35743: EMPTY
35744: LIST
35745: LIST
35746: PUSH
35747: LD_INT 1
35749: PUSH
35750: LD_INT 1
35752: NEG
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 2
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 2
35770: PUSH
35771: LD_INT 1
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 2
35780: PUSH
35781: LD_INT 2
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: LD_INT 2
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 1
35800: NEG
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 2
35811: NEG
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 2
35822: NEG
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 2
35834: NEG
35835: PUSH
35836: LD_INT 2
35838: NEG
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 2
35846: NEG
35847: PUSH
35848: LD_INT 3
35850: NEG
35851: PUSH
35852: EMPTY
35853: LIST
35854: LIST
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: LD_INT 1
35861: NEG
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: PUSH
35867: LD_INT 3
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: EMPTY
35874: LIST
35875: LIST
35876: PUSH
35877: LD_INT 3
35879: PUSH
35880: LD_INT 1
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 3
35889: PUSH
35890: LD_INT 2
35892: PUSH
35893: EMPTY
35894: LIST
35895: LIST
35896: PUSH
35897: LD_INT 3
35899: PUSH
35900: LD_INT 3
35902: PUSH
35903: EMPTY
35904: LIST
35905: LIST
35906: PUSH
35907: LD_INT 2
35909: PUSH
35910: LD_INT 3
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: LD_INT 2
35919: NEG
35920: PUSH
35921: LD_INT 1
35923: PUSH
35924: EMPTY
35925: LIST
35926: LIST
35927: PUSH
35928: LD_INT 3
35930: NEG
35931: PUSH
35932: LD_INT 0
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 3
35941: NEG
35942: PUSH
35943: LD_INT 1
35945: NEG
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 3
35953: NEG
35954: PUSH
35955: LD_INT 2
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 3
35965: NEG
35966: PUSH
35967: LD_INT 3
35969: NEG
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: LIST
35986: LIST
35987: LIST
35988: LIST
35989: LIST
35990: LIST
35991: LIST
35992: LIST
35993: LIST
35994: LIST
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: LIST
36005: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36006: LD_ADDR_VAR 0 42
36010: PUSH
36011: LD_INT 0
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 0
36023: PUSH
36024: LD_INT 1
36026: NEG
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: PUSH
36035: LD_INT 0
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: PUSH
36045: LD_INT 1
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 0
36054: PUSH
36055: LD_INT 1
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 1
36064: NEG
36065: PUSH
36066: LD_INT 0
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 1
36075: NEG
36076: PUSH
36077: LD_INT 1
36079: NEG
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: NEG
36088: PUSH
36089: LD_INT 2
36091: NEG
36092: PUSH
36093: EMPTY
36094: LIST
36095: LIST
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 1
36110: PUSH
36111: LD_INT 1
36113: NEG
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: PUSH
36122: LD_INT 1
36124: PUSH
36125: EMPTY
36126: LIST
36127: LIST
36128: PUSH
36129: LD_INT 2
36131: PUSH
36132: LD_INT 2
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 1
36141: PUSH
36142: LD_INT 2
36144: PUSH
36145: EMPTY
36146: LIST
36147: LIST
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: LD_INT 2
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: NEG
36162: PUSH
36163: LD_INT 1
36165: PUSH
36166: EMPTY
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 2
36172: NEG
36173: PUSH
36174: LD_INT 1
36176: NEG
36177: PUSH
36178: EMPTY
36179: LIST
36180: LIST
36181: PUSH
36182: LD_INT 2
36184: NEG
36185: PUSH
36186: LD_INT 2
36188: NEG
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 2
36196: NEG
36197: PUSH
36198: LD_INT 3
36200: NEG
36201: PUSH
36202: EMPTY
36203: LIST
36204: LIST
36205: PUSH
36206: LD_INT 1
36208: NEG
36209: PUSH
36210: LD_INT 3
36212: NEG
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: LD_INT 3
36223: NEG
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: LD_INT 1
36231: PUSH
36232: LD_INT 2
36234: NEG
36235: PUSH
36236: EMPTY
36237: LIST
36238: LIST
36239: PUSH
36240: LD_INT 3
36242: PUSH
36243: LD_INT 2
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 3
36252: PUSH
36253: LD_INT 3
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 2
36262: PUSH
36263: LD_INT 3
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 1
36272: PUSH
36273: LD_INT 3
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 0
36282: PUSH
36283: LD_INT 3
36285: PUSH
36286: EMPTY
36287: LIST
36288: LIST
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 3
36303: NEG
36304: PUSH
36305: LD_INT 2
36307: NEG
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 3
36315: NEG
36316: PUSH
36317: LD_INT 3
36319: NEG
36320: PUSH
36321: EMPTY
36322: LIST
36323: LIST
36324: PUSH
36325: EMPTY
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: LIST
36342: LIST
36343: LIST
36344: LIST
36345: LIST
36346: LIST
36347: LIST
36348: LIST
36349: LIST
36350: LIST
36351: LIST
36352: LIST
36353: LIST
36354: LIST
36355: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36356: LD_ADDR_VAR 0 43
36360: PUSH
36361: LD_INT 0
36363: PUSH
36364: LD_INT 0
36366: PUSH
36367: EMPTY
36368: LIST
36369: LIST
36370: PUSH
36371: LD_INT 0
36373: PUSH
36374: LD_INT 1
36376: NEG
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 1
36384: PUSH
36385: LD_INT 0
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: PUSH
36395: LD_INT 1
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 0
36404: PUSH
36405: LD_INT 1
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: LD_INT 0
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 1
36425: NEG
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 2
36441: NEG
36442: PUSH
36443: EMPTY
36444: LIST
36445: LIST
36446: PUSH
36447: LD_INT 0
36449: PUSH
36450: LD_INT 2
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 1
36460: PUSH
36461: LD_INT 1
36463: NEG
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 2
36471: PUSH
36472: LD_INT 0
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 2
36481: PUSH
36482: LD_INT 1
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: PUSH
36492: LD_INT 2
36494: PUSH
36495: EMPTY
36496: LIST
36497: LIST
36498: PUSH
36499: LD_INT 0
36501: PUSH
36502: LD_INT 2
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: LD_INT 1
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: LD_INT 2
36522: NEG
36523: PUSH
36524: LD_INT 0
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: PUSH
36531: LD_INT 2
36533: NEG
36534: PUSH
36535: LD_INT 1
36537: NEG
36538: PUSH
36539: EMPTY
36540: LIST
36541: LIST
36542: PUSH
36543: LD_INT 1
36545: NEG
36546: PUSH
36547: LD_INT 3
36549: NEG
36550: PUSH
36551: EMPTY
36552: LIST
36553: LIST
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: LD_INT 3
36560: NEG
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: PUSH
36569: LD_INT 2
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 2
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 3
36590: PUSH
36591: LD_INT 0
36593: PUSH
36594: EMPTY
36595: LIST
36596: LIST
36597: PUSH
36598: LD_INT 3
36600: PUSH
36601: LD_INT 1
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 3
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: LD_INT 3
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: LD_INT 2
36634: PUSH
36635: EMPTY
36636: LIST
36637: LIST
36638: PUSH
36639: LD_INT 2
36641: NEG
36642: PUSH
36643: LD_INT 1
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PUSH
36650: LD_INT 3
36652: NEG
36653: PUSH
36654: LD_INT 0
36656: PUSH
36657: EMPTY
36658: LIST
36659: LIST
36660: PUSH
36661: LD_INT 3
36663: NEG
36664: PUSH
36665: LD_INT 1
36667: NEG
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: EMPTY
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: LIST
36691: LIST
36692: LIST
36693: LIST
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: LIST
36699: LIST
36700: LIST
36701: LIST
36702: LIST
36703: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36704: LD_ADDR_VAR 0 44
36708: PUSH
36709: LD_INT 0
36711: PUSH
36712: LD_INT 0
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 0
36721: PUSH
36722: LD_INT 1
36724: NEG
36725: PUSH
36726: EMPTY
36727: LIST
36728: LIST
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: LD_INT 0
36735: PUSH
36736: EMPTY
36737: LIST
36738: LIST
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: LD_INT 1
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 0
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: PUSH
36760: LD_INT 1
36762: NEG
36763: PUSH
36764: LD_INT 0
36766: PUSH
36767: EMPTY
36768: LIST
36769: LIST
36770: PUSH
36771: LD_INT 1
36773: NEG
36774: PUSH
36775: LD_INT 1
36777: NEG
36778: PUSH
36779: EMPTY
36780: LIST
36781: LIST
36782: PUSH
36783: LD_INT 1
36785: NEG
36786: PUSH
36787: LD_INT 2
36789: NEG
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 1
36797: PUSH
36798: LD_INT 1
36800: NEG
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 2
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: EMPTY
36813: LIST
36814: LIST
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: LD_INT 1
36821: PUSH
36822: EMPTY
36823: LIST
36824: LIST
36825: PUSH
36826: LD_INT 2
36828: PUSH
36829: LD_INT 2
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 1
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: LD_INT 0
36863: PUSH
36864: EMPTY
36865: LIST
36866: LIST
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: LD_INT 1
36874: NEG
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 2
36882: NEG
36883: PUSH
36884: LD_INT 2
36886: NEG
36887: PUSH
36888: EMPTY
36889: LIST
36890: LIST
36891: PUSH
36892: LD_INT 2
36894: NEG
36895: PUSH
36896: LD_INT 3
36898: NEG
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 2
36906: PUSH
36907: LD_INT 1
36909: NEG
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: PUSH
36918: LD_INT 0
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 3
36927: PUSH
36928: LD_INT 1
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 3
36937: PUSH
36938: LD_INT 2
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 3
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 2
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 2
36967: NEG
36968: PUSH
36969: LD_INT 1
36971: PUSH
36972: EMPTY
36973: LIST
36974: LIST
36975: PUSH
36976: LD_INT 3
36978: NEG
36979: PUSH
36980: LD_INT 0
36982: PUSH
36983: EMPTY
36984: LIST
36985: LIST
36986: PUSH
36987: LD_INT 3
36989: NEG
36990: PUSH
36991: LD_INT 1
36993: NEG
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: LD_INT 3
37001: NEG
37002: PUSH
37003: LD_INT 2
37005: NEG
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 3
37013: NEG
37014: PUSH
37015: LD_INT 3
37017: NEG
37018: PUSH
37019: EMPTY
37020: LIST
37021: LIST
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37054: LD_ADDR_VAR 0 45
37058: PUSH
37059: LD_INT 0
37061: PUSH
37062: LD_INT 0
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 0
37071: PUSH
37072: LD_INT 1
37074: NEG
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: LD_INT 0
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 1
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: LD_INT 0
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 1
37123: NEG
37124: PUSH
37125: LD_INT 1
37127: NEG
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 1
37135: NEG
37136: PUSH
37137: LD_INT 2
37139: NEG
37140: PUSH
37141: EMPTY
37142: LIST
37143: LIST
37144: PUSH
37145: LD_INT 0
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 1
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: LD_INT 2
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 1
37189: PUSH
37190: LD_INT 2
37192: PUSH
37193: EMPTY
37194: LIST
37195: LIST
37196: PUSH
37197: LD_INT 0
37199: PUSH
37200: LD_INT 2
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 1
37209: NEG
37210: PUSH
37211: LD_INT 1
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: LD_INT 1
37224: NEG
37225: PUSH
37226: EMPTY
37227: LIST
37228: LIST
37229: PUSH
37230: LD_INT 2
37232: NEG
37233: PUSH
37234: LD_INT 2
37236: NEG
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 2
37244: NEG
37245: PUSH
37246: LD_INT 3
37248: NEG
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 1
37256: NEG
37257: PUSH
37258: LD_INT 3
37260: NEG
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 0
37268: PUSH
37269: LD_INT 3
37271: NEG
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 1
37279: PUSH
37280: LD_INT 2
37282: NEG
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 3
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PUSH
37298: LD_INT 3
37300: PUSH
37301: LD_INT 3
37303: PUSH
37304: EMPTY
37305: LIST
37306: LIST
37307: PUSH
37308: LD_INT 2
37310: PUSH
37311: LD_INT 3
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: PUSH
37321: LD_INT 3
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 0
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: LD_INT 1
37340: NEG
37341: PUSH
37342: LD_INT 2
37344: PUSH
37345: EMPTY
37346: LIST
37347: LIST
37348: PUSH
37349: LD_INT 3
37351: NEG
37352: PUSH
37353: LD_INT 2
37355: NEG
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 3
37363: NEG
37364: PUSH
37365: LD_INT 3
37367: NEG
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: EMPTY
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: LIST
37390: LIST
37391: LIST
37392: LIST
37393: LIST
37394: LIST
37395: LIST
37396: LIST
37397: LIST
37398: LIST
37399: LIST
37400: LIST
37401: LIST
37402: LIST
37403: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37404: LD_ADDR_VAR 0 46
37408: PUSH
37409: LD_INT 0
37411: PUSH
37412: LD_INT 0
37414: PUSH
37415: EMPTY
37416: LIST
37417: LIST
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: LD_INT 1
37424: NEG
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 1
37432: PUSH
37433: LD_INT 0
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: PUSH
37443: LD_INT 1
37445: PUSH
37446: EMPTY
37447: LIST
37448: LIST
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: LD_INT 1
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: NEG
37463: PUSH
37464: LD_INT 0
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 1
37473: NEG
37474: PUSH
37475: LD_INT 1
37477: NEG
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 2
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 0
37497: PUSH
37498: LD_INT 2
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 1
37508: PUSH
37509: LD_INT 1
37511: NEG
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 2
37519: PUSH
37520: LD_INT 0
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 2
37529: PUSH
37530: LD_INT 1
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 1
37539: PUSH
37540: LD_INT 2
37542: PUSH
37543: EMPTY
37544: LIST
37545: LIST
37546: PUSH
37547: LD_INT 0
37549: PUSH
37550: LD_INT 2
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 1
37559: NEG
37560: PUSH
37561: LD_INT 1
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 2
37570: NEG
37571: PUSH
37572: LD_INT 0
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 2
37581: NEG
37582: PUSH
37583: LD_INT 1
37585: NEG
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: LD_INT 1
37593: NEG
37594: PUSH
37595: LD_INT 3
37597: NEG
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: LD_INT 3
37608: NEG
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 1
37616: PUSH
37617: LD_INT 2
37619: NEG
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 2
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 3
37638: PUSH
37639: LD_INT 0
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 3
37648: PUSH
37649: LD_INT 1
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: PUSH
37659: LD_INT 3
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 3
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 2
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 2
37689: NEG
37690: PUSH
37691: LD_INT 1
37693: PUSH
37694: EMPTY
37695: LIST
37696: LIST
37697: PUSH
37698: LD_INT 3
37700: NEG
37701: PUSH
37702: LD_INT 0
37704: PUSH
37705: EMPTY
37706: LIST
37707: LIST
37708: PUSH
37709: LD_INT 3
37711: NEG
37712: PUSH
37713: LD_INT 1
37715: NEG
37716: PUSH
37717: EMPTY
37718: LIST
37719: LIST
37720: PUSH
37721: EMPTY
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: LIST
37739: LIST
37740: LIST
37741: LIST
37742: LIST
37743: LIST
37744: LIST
37745: LIST
37746: LIST
37747: LIST
37748: LIST
37749: LIST
37750: LIST
37751: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37752: LD_ADDR_VAR 0 47
37756: PUSH
37757: LD_INT 0
37759: PUSH
37760: LD_INT 0
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 0
37769: PUSH
37770: LD_INT 1
37772: NEG
37773: PUSH
37774: EMPTY
37775: LIST
37776: LIST
37777: PUSH
37778: LD_INT 1
37780: PUSH
37781: LD_INT 0
37783: PUSH
37784: EMPTY
37785: LIST
37786: LIST
37787: PUSH
37788: LD_INT 1
37790: PUSH
37791: LD_INT 1
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: PUSH
37808: LD_INT 1
37810: NEG
37811: PUSH
37812: LD_INT 0
37814: PUSH
37815: EMPTY
37816: LIST
37817: LIST
37818: PUSH
37819: LD_INT 1
37821: NEG
37822: PUSH
37823: LD_INT 1
37825: NEG
37826: PUSH
37827: EMPTY
37828: LIST
37829: LIST
37830: PUSH
37831: LD_INT 1
37833: NEG
37834: PUSH
37835: LD_INT 2
37837: NEG
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 0
37845: PUSH
37846: LD_INT 2
37848: NEG
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 1
37856: PUSH
37857: LD_INT 1
37859: NEG
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 2
37867: NEG
37868: PUSH
37869: LD_INT 1
37871: NEG
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 2
37879: NEG
37880: PUSH
37881: LD_INT 2
37883: NEG
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: EMPTY
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: LIST
37897: LIST
37898: LIST
37899: LIST
37900: LIST
37901: LIST
37902: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37903: LD_ADDR_VAR 0 48
37907: PUSH
37908: LD_INT 0
37910: PUSH
37911: LD_INT 0
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: LD_INT 0
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 1
37931: PUSH
37932: LD_INT 0
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: EMPTY
37946: LIST
37947: LIST
37948: PUSH
37949: LD_INT 0
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: EMPTY
37956: LIST
37957: LIST
37958: PUSH
37959: LD_INT 1
37961: NEG
37962: PUSH
37963: LD_INT 0
37965: PUSH
37966: EMPTY
37967: LIST
37968: LIST
37969: PUSH
37970: LD_INT 1
37972: NEG
37973: PUSH
37974: LD_INT 1
37976: NEG
37977: PUSH
37978: EMPTY
37979: LIST
37980: LIST
37981: PUSH
37982: LD_INT 1
37984: NEG
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: EMPTY
37991: LIST
37992: LIST
37993: PUSH
37994: LD_INT 0
37996: PUSH
37997: LD_INT 2
37999: NEG
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: PUSH
38008: LD_INT 1
38010: NEG
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 2
38018: PUSH
38019: LD_INT 0
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 1
38031: PUSH
38032: EMPTY
38033: LIST
38034: LIST
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38050: LD_ADDR_VAR 0 49
38054: PUSH
38055: LD_INT 0
38057: PUSH
38058: LD_INT 0
38060: PUSH
38061: EMPTY
38062: LIST
38063: LIST
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: LD_INT 1
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: PUSH
38079: LD_INT 0
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: LD_INT 1
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 1
38119: NEG
38120: PUSH
38121: LD_INT 1
38123: NEG
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: LD_INT 1
38134: NEG
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 2
38142: PUSH
38143: LD_INT 0
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 2
38152: PUSH
38153: LD_INT 1
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 2
38162: PUSH
38163: LD_INT 2
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 1
38172: PUSH
38173: LD_INT 2
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38194: LD_ADDR_VAR 0 50
38198: PUSH
38199: LD_INT 0
38201: PUSH
38202: LD_INT 0
38204: PUSH
38205: EMPTY
38206: LIST
38207: LIST
38208: PUSH
38209: LD_INT 0
38211: PUSH
38212: LD_INT 1
38214: NEG
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: PUSH
38220: LD_INT 1
38222: PUSH
38223: LD_INT 0
38225: PUSH
38226: EMPTY
38227: LIST
38228: LIST
38229: PUSH
38230: LD_INT 1
38232: PUSH
38233: LD_INT 1
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: LD_INT 0
38256: PUSH
38257: EMPTY
38258: LIST
38259: LIST
38260: PUSH
38261: LD_INT 1
38263: NEG
38264: PUSH
38265: LD_INT 1
38267: NEG
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 2
38275: PUSH
38276: LD_INT 1
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 2
38285: PUSH
38286: LD_INT 2
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: PUSH
38293: LD_INT 1
38295: PUSH
38296: LD_INT 2
38298: PUSH
38299: EMPTY
38300: LIST
38301: LIST
38302: PUSH
38303: LD_INT 0
38305: PUSH
38306: LD_INT 2
38308: PUSH
38309: EMPTY
38310: LIST
38311: LIST
38312: PUSH
38313: LD_INT 1
38315: NEG
38316: PUSH
38317: LD_INT 1
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: EMPTY
38325: LIST
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38338: LD_ADDR_VAR 0 51
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: LD_INT 0
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 0
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 1
38376: PUSH
38377: LD_INT 1
38379: PUSH
38380: EMPTY
38381: LIST
38382: LIST
38383: PUSH
38384: LD_INT 0
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 1
38396: NEG
38397: PUSH
38398: LD_INT 0
38400: PUSH
38401: EMPTY
38402: LIST
38403: LIST
38404: PUSH
38405: LD_INT 1
38407: NEG
38408: PUSH
38409: LD_INT 1
38411: NEG
38412: PUSH
38413: EMPTY
38414: LIST
38415: LIST
38416: PUSH
38417: LD_INT 1
38419: PUSH
38420: LD_INT 2
38422: PUSH
38423: EMPTY
38424: LIST
38425: LIST
38426: PUSH
38427: LD_INT 0
38429: PUSH
38430: LD_INT 2
38432: PUSH
38433: EMPTY
38434: LIST
38435: LIST
38436: PUSH
38437: LD_INT 1
38439: NEG
38440: PUSH
38441: LD_INT 1
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 2
38450: NEG
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: LIST
38483: LIST
38484: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38485: LD_ADDR_VAR 0 52
38489: PUSH
38490: LD_INT 0
38492: PUSH
38493: LD_INT 0
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 0
38502: PUSH
38503: LD_INT 1
38505: NEG
38506: PUSH
38507: EMPTY
38508: LIST
38509: LIST
38510: PUSH
38511: LD_INT 1
38513: PUSH
38514: LD_INT 0
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PUSH
38521: LD_INT 1
38523: PUSH
38524: LD_INT 1
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: PUSH
38531: LD_INT 0
38533: PUSH
38534: LD_INT 1
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: NEG
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PUSH
38552: LD_INT 1
38554: NEG
38555: PUSH
38556: LD_INT 1
38558: NEG
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 1
38566: NEG
38567: PUSH
38568: LD_INT 2
38570: NEG
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 1
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 2
38589: NEG
38590: PUSH
38591: LD_INT 0
38593: PUSH
38594: EMPTY
38595: LIST
38596: LIST
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: LD_INT 1
38604: NEG
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 2
38612: NEG
38613: PUSH
38614: LD_INT 2
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: EMPTY
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: LIST
38630: LIST
38631: LIST
38632: LIST
38633: LIST
38634: LIST
38635: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38636: LD_ADDR_VAR 0 53
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: LD_INT 0
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 0
38653: PUSH
38654: LD_INT 1
38656: NEG
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 1
38664: PUSH
38665: LD_INT 0
38667: PUSH
38668: EMPTY
38669: LIST
38670: LIST
38671: PUSH
38672: LD_INT 1
38674: PUSH
38675: LD_INT 1
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PUSH
38682: LD_INT 0
38684: PUSH
38685: LD_INT 1
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PUSH
38692: LD_INT 1
38694: NEG
38695: PUSH
38696: LD_INT 0
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: NEG
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: NEG
38718: PUSH
38719: LD_INT 2
38721: NEG
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 0
38729: PUSH
38730: LD_INT 2
38732: NEG
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 1
38740: PUSH
38741: LD_INT 1
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: LD_INT 2
38751: PUSH
38752: LD_INT 0
38754: PUSH
38755: EMPTY
38756: LIST
38757: LIST
38758: PUSH
38759: LD_INT 2
38761: PUSH
38762: LD_INT 1
38764: PUSH
38765: EMPTY
38766: LIST
38767: LIST
38768: PUSH
38769: LD_INT 2
38771: PUSH
38772: LD_INT 2
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 1
38781: PUSH
38782: LD_INT 2
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: LD_INT 2
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 1
38801: NEG
38802: PUSH
38803: LD_INT 1
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: NEG
38813: PUSH
38814: LD_INT 0
38816: PUSH
38817: EMPTY
38818: LIST
38819: LIST
38820: PUSH
38821: LD_INT 2
38823: NEG
38824: PUSH
38825: LD_INT 1
38827: NEG
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 2
38835: NEG
38836: PUSH
38837: LD_INT 2
38839: NEG
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: LIST
38859: LIST
38860: LIST
38861: LIST
38862: LIST
38863: LIST
38864: LIST
38865: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38866: LD_ADDR_VAR 0 54
38870: PUSH
38871: LD_INT 0
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: EMPTY
38878: LIST
38879: LIST
38880: PUSH
38881: LD_INT 0
38883: PUSH
38884: LD_INT 1
38886: NEG
38887: PUSH
38888: EMPTY
38889: LIST
38890: LIST
38891: PUSH
38892: LD_INT 1
38894: PUSH
38895: LD_INT 0
38897: PUSH
38898: EMPTY
38899: LIST
38900: LIST
38901: PUSH
38902: LD_INT 1
38904: PUSH
38905: LD_INT 1
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: EMPTY
38919: LIST
38920: LIST
38921: PUSH
38922: LD_INT 1
38924: NEG
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 1
38935: NEG
38936: PUSH
38937: LD_INT 1
38939: NEG
38940: PUSH
38941: EMPTY
38942: LIST
38943: LIST
38944: PUSH
38945: LD_INT 1
38947: NEG
38948: PUSH
38949: LD_INT 2
38951: NEG
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 0
38959: PUSH
38960: LD_INT 2
38962: NEG
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 1
38970: PUSH
38971: LD_INT 1
38973: NEG
38974: PUSH
38975: EMPTY
38976: LIST
38977: LIST
38978: PUSH
38979: LD_INT 2
38981: PUSH
38982: LD_INT 0
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: LD_INT 2
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: EMPTY
38996: LIST
38997: LIST
38998: PUSH
38999: LD_INT 2
39001: PUSH
39002: LD_INT 2
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 1
39011: PUSH
39012: LD_INT 2
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: LD_INT 2
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 1
39031: NEG
39032: PUSH
39033: LD_INT 1
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 2
39042: NEG
39043: PUSH
39044: LD_INT 0
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 2
39053: NEG
39054: PUSH
39055: LD_INT 1
39057: NEG
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 2
39065: NEG
39066: PUSH
39067: LD_INT 2
39069: NEG
39070: PUSH
39071: EMPTY
39072: LIST
39073: LIST
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: LIST
39079: LIST
39080: LIST
39081: LIST
39082: LIST
39083: LIST
39084: LIST
39085: LIST
39086: LIST
39087: LIST
39088: LIST
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39096: LD_ADDR_VAR 0 55
39100: PUSH
39101: LD_INT 0
39103: PUSH
39104: LD_INT 0
39106: PUSH
39107: EMPTY
39108: LIST
39109: LIST
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 1
39116: NEG
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: PUSH
39125: LD_INT 0
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: LD_INT 1
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 0
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 1
39154: NEG
39155: PUSH
39156: LD_INT 0
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 1
39165: NEG
39166: PUSH
39167: LD_INT 1
39169: NEG
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: LD_INT 1
39177: NEG
39178: PUSH
39179: LD_INT 2
39181: NEG
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 0
39189: PUSH
39190: LD_INT 2
39192: NEG
39193: PUSH
39194: EMPTY
39195: LIST
39196: LIST
39197: PUSH
39198: LD_INT 1
39200: PUSH
39201: LD_INT 1
39203: NEG
39204: PUSH
39205: EMPTY
39206: LIST
39207: LIST
39208: PUSH
39209: LD_INT 2
39211: PUSH
39212: LD_INT 0
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: PUSH
39219: LD_INT 2
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 2
39231: PUSH
39232: LD_INT 2
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: LD_INT 1
39241: PUSH
39242: LD_INT 2
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: LD_INT 2
39254: PUSH
39255: EMPTY
39256: LIST
39257: LIST
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: LD_INT 1
39265: PUSH
39266: EMPTY
39267: LIST
39268: LIST
39269: PUSH
39270: LD_INT 2
39272: NEG
39273: PUSH
39274: LD_INT 0
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 2
39283: NEG
39284: PUSH
39285: LD_INT 1
39287: NEG
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: PUSH
39293: LD_INT 2
39295: NEG
39296: PUSH
39297: LD_INT 2
39299: NEG
39300: PUSH
39301: EMPTY
39302: LIST
39303: LIST
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: LIST
39323: LIST
39324: LIST
39325: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39326: LD_ADDR_VAR 0 56
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: EMPTY
39338: LIST
39339: LIST
39340: PUSH
39341: LD_INT 0
39343: PUSH
39344: LD_INT 1
39346: NEG
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: PUSH
39352: LD_INT 1
39354: PUSH
39355: LD_INT 0
39357: PUSH
39358: EMPTY
39359: LIST
39360: LIST
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: LD_INT 1
39367: PUSH
39368: EMPTY
39369: LIST
39370: LIST
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: LD_INT 1
39377: PUSH
39378: EMPTY
39379: LIST
39380: LIST
39381: PUSH
39382: LD_INT 1
39384: NEG
39385: PUSH
39386: LD_INT 0
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 1
39395: NEG
39396: PUSH
39397: LD_INT 1
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: LD_INT 1
39407: NEG
39408: PUSH
39409: LD_INT 2
39411: NEG
39412: PUSH
39413: EMPTY
39414: LIST
39415: LIST
39416: PUSH
39417: LD_INT 0
39419: PUSH
39420: LD_INT 2
39422: NEG
39423: PUSH
39424: EMPTY
39425: LIST
39426: LIST
39427: PUSH
39428: LD_INT 1
39430: PUSH
39431: LD_INT 1
39433: NEG
39434: PUSH
39435: EMPTY
39436: LIST
39437: LIST
39438: PUSH
39439: LD_INT 2
39441: PUSH
39442: LD_INT 0
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 2
39451: PUSH
39452: LD_INT 1
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 2
39461: PUSH
39462: LD_INT 2
39464: PUSH
39465: EMPTY
39466: LIST
39467: LIST
39468: PUSH
39469: LD_INT 1
39471: PUSH
39472: LD_INT 2
39474: PUSH
39475: EMPTY
39476: LIST
39477: LIST
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: LD_INT 2
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: LD_INT 1
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 2
39502: NEG
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 2
39513: NEG
39514: PUSH
39515: LD_INT 1
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 2
39525: NEG
39526: PUSH
39527: LD_INT 2
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: LIST
39551: LIST
39552: LIST
39553: LIST
39554: LIST
39555: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39556: LD_ADDR_VAR 0 57
39560: PUSH
39561: LD_INT 0
39563: PUSH
39564: LD_INT 0
39566: PUSH
39567: EMPTY
39568: LIST
39569: LIST
39570: PUSH
39571: LD_INT 0
39573: PUSH
39574: LD_INT 1
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 1
39584: PUSH
39585: LD_INT 0
39587: PUSH
39588: EMPTY
39589: LIST
39590: LIST
39591: PUSH
39592: LD_INT 1
39594: PUSH
39595: LD_INT 1
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: LD_INT 1
39607: PUSH
39608: EMPTY
39609: LIST
39610: LIST
39611: PUSH
39612: LD_INT 1
39614: NEG
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: NEG
39626: PUSH
39627: LD_INT 1
39629: NEG
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 1
39637: NEG
39638: PUSH
39639: LD_INT 2
39641: NEG
39642: PUSH
39643: EMPTY
39644: LIST
39645: LIST
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: LD_INT 2
39652: NEG
39653: PUSH
39654: EMPTY
39655: LIST
39656: LIST
39657: PUSH
39658: LD_INT 1
39660: PUSH
39661: LD_INT 1
39663: NEG
39664: PUSH
39665: EMPTY
39666: LIST
39667: LIST
39668: PUSH
39669: LD_INT 2
39671: PUSH
39672: LD_INT 0
39674: PUSH
39675: EMPTY
39676: LIST
39677: LIST
39678: PUSH
39679: LD_INT 2
39681: PUSH
39682: LD_INT 1
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 2
39691: PUSH
39692: LD_INT 2
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: LD_INT 1
39701: PUSH
39702: LD_INT 2
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: LD_INT 2
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: LD_INT 1
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: PUSH
39730: LD_INT 2
39732: NEG
39733: PUSH
39734: LD_INT 0
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: PUSH
39741: LD_INT 2
39743: NEG
39744: PUSH
39745: LD_INT 1
39747: NEG
39748: PUSH
39749: EMPTY
39750: LIST
39751: LIST
39752: PUSH
39753: LD_INT 2
39755: NEG
39756: PUSH
39757: LD_INT 2
39759: NEG
39760: PUSH
39761: EMPTY
39762: LIST
39763: LIST
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: LIST
39780: LIST
39781: LIST
39782: LIST
39783: LIST
39784: LIST
39785: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39786: LD_ADDR_VAR 0 58
39790: PUSH
39791: LD_INT 0
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: EMPTY
39798: LIST
39799: LIST
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: PUSH
39815: LD_INT 0
39817: PUSH
39818: EMPTY
39819: LIST
39820: LIST
39821: PUSH
39822: LD_INT 1
39824: PUSH
39825: LD_INT 1
39827: PUSH
39828: EMPTY
39829: LIST
39830: LIST
39831: PUSH
39832: LD_INT 0
39834: PUSH
39835: LD_INT 1
39837: PUSH
39838: EMPTY
39839: LIST
39840: LIST
39841: PUSH
39842: LD_INT 1
39844: NEG
39845: PUSH
39846: LD_INT 0
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 1
39855: NEG
39856: PUSH
39857: LD_INT 1
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: LD_INT 1
39867: NEG
39868: PUSH
39869: LD_INT 2
39871: NEG
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: LD_INT 2
39882: NEG
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 1
39890: PUSH
39891: LD_INT 1
39893: NEG
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 2
39901: PUSH
39902: LD_INT 0
39904: PUSH
39905: EMPTY
39906: LIST
39907: LIST
39908: PUSH
39909: LD_INT 2
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: EMPTY
39916: LIST
39917: LIST
39918: PUSH
39919: LD_INT 2
39921: PUSH
39922: LD_INT 2
39924: PUSH
39925: EMPTY
39926: LIST
39927: LIST
39928: PUSH
39929: LD_INT 1
39931: PUSH
39932: LD_INT 2
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: LD_INT 2
39944: PUSH
39945: EMPTY
39946: LIST
39947: LIST
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: LD_INT 1
39955: PUSH
39956: EMPTY
39957: LIST
39958: LIST
39959: PUSH
39960: LD_INT 2
39962: NEG
39963: PUSH
39964: LD_INT 0
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 2
39973: NEG
39974: PUSH
39975: LD_INT 1
39977: NEG
39978: PUSH
39979: EMPTY
39980: LIST
39981: LIST
39982: PUSH
39983: LD_INT 2
39985: NEG
39986: PUSH
39987: LD_INT 2
39989: NEG
39990: PUSH
39991: EMPTY
39992: LIST
39993: LIST
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: LIST
40011: LIST
40012: LIST
40013: LIST
40014: LIST
40015: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40016: LD_ADDR_VAR 0 59
40020: PUSH
40021: LD_INT 0
40023: PUSH
40024: LD_INT 0
40026: PUSH
40027: EMPTY
40028: LIST
40029: LIST
40030: PUSH
40031: LD_INT 0
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 1
40044: PUSH
40045: LD_INT 0
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 1
40054: PUSH
40055: LD_INT 1
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: LD_INT 0
40064: PUSH
40065: LD_INT 1
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: LD_INT 1
40074: NEG
40075: PUSH
40076: LD_INT 0
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 1
40085: NEG
40086: PUSH
40087: LD_INT 1
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40104: LD_ADDR_VAR 0 60
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: LD_INT 0
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 0
40121: PUSH
40122: LD_INT 1
40124: NEG
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: PUSH
40133: LD_INT 0
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: LD_INT 1
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 0
40152: PUSH
40153: LD_INT 1
40155: PUSH
40156: EMPTY
40157: LIST
40158: LIST
40159: PUSH
40160: LD_INT 1
40162: NEG
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 1
40173: NEG
40174: PUSH
40175: LD_INT 1
40177: NEG
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: LIST
40187: LIST
40188: LIST
40189: LIST
40190: LIST
40191: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40192: LD_ADDR_VAR 0 61
40196: PUSH
40197: LD_INT 0
40199: PUSH
40200: LD_INT 0
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 1
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: PUSH
40231: LD_INT 1
40233: PUSH
40234: EMPTY
40235: LIST
40236: LIST
40237: PUSH
40238: LD_INT 0
40240: PUSH
40241: LD_INT 1
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 1
40250: NEG
40251: PUSH
40252: LD_INT 0
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 1
40261: NEG
40262: PUSH
40263: LD_INT 1
40265: NEG
40266: PUSH
40267: EMPTY
40268: LIST
40269: LIST
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: LIST
40279: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40280: LD_ADDR_VAR 0 62
40284: PUSH
40285: LD_INT 0
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: LD_INT 1
40300: NEG
40301: PUSH
40302: EMPTY
40303: LIST
40304: LIST
40305: PUSH
40306: LD_INT 1
40308: PUSH
40309: LD_INT 0
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 1
40318: PUSH
40319: LD_INT 1
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 0
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: LD_INT 1
40338: NEG
40339: PUSH
40340: LD_INT 0
40342: PUSH
40343: EMPTY
40344: LIST
40345: LIST
40346: PUSH
40347: LD_INT 1
40349: NEG
40350: PUSH
40351: LD_INT 1
40353: NEG
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40368: LD_ADDR_VAR 0 63
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: LD_INT 1
40388: NEG
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 1
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: PUSH
40407: LD_INT 1
40409: PUSH
40410: EMPTY
40411: LIST
40412: LIST
40413: PUSH
40414: LD_INT 0
40416: PUSH
40417: LD_INT 1
40419: PUSH
40420: EMPTY
40421: LIST
40422: LIST
40423: PUSH
40424: LD_INT 1
40426: NEG
40427: PUSH
40428: LD_INT 0
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 1
40437: NEG
40438: PUSH
40439: LD_INT 1
40441: NEG
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: LIST
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40456: LD_ADDR_VAR 0 64
40460: PUSH
40461: LD_INT 0
40463: PUSH
40464: LD_INT 0
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 1
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: PUSH
40485: LD_INT 0
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: PUSH
40495: LD_INT 1
40497: PUSH
40498: EMPTY
40499: LIST
40500: LIST
40501: PUSH
40502: LD_INT 0
40504: PUSH
40505: LD_INT 1
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 1
40514: NEG
40515: PUSH
40516: LD_INT 0
40518: PUSH
40519: EMPTY
40520: LIST
40521: LIST
40522: PUSH
40523: LD_INT 1
40525: NEG
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: ST_TO_ADDR
// end ; 1 :
40544: GO 46441
40546: LD_INT 1
40548: DOUBLE
40549: EQUAL
40550: IFTRUE 40554
40552: GO 43177
40554: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40555: LD_ADDR_VAR 0 11
40559: PUSH
40560: LD_INT 1
40562: NEG
40563: PUSH
40564: LD_INT 3
40566: NEG
40567: PUSH
40568: EMPTY
40569: LIST
40570: LIST
40571: PUSH
40572: LD_INT 0
40574: PUSH
40575: LD_INT 3
40577: NEG
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: LD_INT 1
40585: PUSH
40586: LD_INT 2
40588: NEG
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: EMPTY
40595: LIST
40596: LIST
40597: LIST
40598: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40599: LD_ADDR_VAR 0 12
40603: PUSH
40604: LD_INT 2
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: EMPTY
40612: LIST
40613: LIST
40614: PUSH
40615: LD_INT 3
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 1
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: EMPTY
40636: LIST
40637: LIST
40638: LIST
40639: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40640: LD_ADDR_VAR 0 13
40644: PUSH
40645: LD_INT 3
40647: PUSH
40648: LD_INT 2
40650: PUSH
40651: EMPTY
40652: LIST
40653: LIST
40654: PUSH
40655: LD_INT 3
40657: PUSH
40658: LD_INT 3
40660: PUSH
40661: EMPTY
40662: LIST
40663: LIST
40664: PUSH
40665: LD_INT 2
40667: PUSH
40668: LD_INT 3
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: LIST
40679: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40680: LD_ADDR_VAR 0 14
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: LD_INT 3
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: LD_INT 3
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 1
40707: NEG
40708: PUSH
40709: LD_INT 2
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: LIST
40720: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40721: LD_ADDR_VAR 0 15
40725: PUSH
40726: LD_INT 2
40728: NEG
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 3
40739: NEG
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 3
40750: NEG
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: LIST
40764: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40765: LD_ADDR_VAR 0 16
40769: PUSH
40770: LD_INT 2
40772: NEG
40773: PUSH
40774: LD_INT 3
40776: NEG
40777: PUSH
40778: EMPTY
40779: LIST
40780: LIST
40781: PUSH
40782: LD_INT 3
40784: NEG
40785: PUSH
40786: LD_INT 2
40788: NEG
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: LD_INT 3
40796: NEG
40797: PUSH
40798: LD_INT 3
40800: NEG
40801: PUSH
40802: EMPTY
40803: LIST
40804: LIST
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: LIST
40810: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40811: LD_ADDR_VAR 0 17
40815: PUSH
40816: LD_INT 1
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 0
40830: PUSH
40831: LD_INT 3
40833: NEG
40834: PUSH
40835: EMPTY
40836: LIST
40837: LIST
40838: PUSH
40839: LD_INT 1
40841: PUSH
40842: LD_INT 2
40844: NEG
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: LIST
40854: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40855: LD_ADDR_VAR 0 18
40859: PUSH
40860: LD_INT 2
40862: PUSH
40863: LD_INT 1
40865: NEG
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 3
40873: PUSH
40874: LD_INT 0
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 3
40883: PUSH
40884: LD_INT 1
40886: PUSH
40887: EMPTY
40888: LIST
40889: LIST
40890: PUSH
40891: EMPTY
40892: LIST
40893: LIST
40894: LIST
40895: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40896: LD_ADDR_VAR 0 19
40900: PUSH
40901: LD_INT 3
40903: PUSH
40904: LD_INT 2
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 3
40913: PUSH
40914: LD_INT 3
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 2
40923: PUSH
40924: LD_INT 3
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: LIST
40935: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40936: LD_ADDR_VAR 0 20
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: LD_INT 3
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: LD_INT 0
40953: PUSH
40954: LD_INT 3
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 2
40967: PUSH
40968: EMPTY
40969: LIST
40970: LIST
40971: PUSH
40972: EMPTY
40973: LIST
40974: LIST
40975: LIST
40976: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40977: LD_ADDR_VAR 0 21
40981: PUSH
40982: LD_INT 2
40984: NEG
40985: PUSH
40986: LD_INT 1
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: PUSH
40993: LD_INT 3
40995: NEG
40996: PUSH
40997: LD_INT 0
40999: PUSH
41000: EMPTY
41001: LIST
41002: LIST
41003: PUSH
41004: LD_INT 3
41006: NEG
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: LIST
41020: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41021: LD_ADDR_VAR 0 22
41025: PUSH
41026: LD_INT 2
41028: NEG
41029: PUSH
41030: LD_INT 3
41032: NEG
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: PUSH
41038: LD_INT 3
41040: NEG
41041: PUSH
41042: LD_INT 2
41044: NEG
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: NEG
41053: PUSH
41054: LD_INT 3
41056: NEG
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: LIST
41066: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41067: LD_ADDR_VAR 0 23
41071: PUSH
41072: LD_INT 0
41074: PUSH
41075: LD_INT 3
41077: NEG
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 1
41085: NEG
41086: PUSH
41087: LD_INT 4
41089: NEG
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 1
41097: PUSH
41098: LD_INT 3
41100: NEG
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: LIST
41110: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41111: LD_ADDR_VAR 0 24
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: LD_INT 0
41121: PUSH
41122: EMPTY
41123: LIST
41124: LIST
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: LD_INT 1
41131: NEG
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 1
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: LIST
41151: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41152: LD_ADDR_VAR 0 25
41156: PUSH
41157: LD_INT 3
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 4
41169: PUSH
41170: LD_INT 3
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 3
41179: PUSH
41180: LD_INT 4
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: EMPTY
41188: LIST
41189: LIST
41190: LIST
41191: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41192: LD_ADDR_VAR 0 26
41196: PUSH
41197: LD_INT 0
41199: PUSH
41200: LD_INT 3
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: LD_INT 1
41209: PUSH
41210: LD_INT 4
41212: PUSH
41213: EMPTY
41214: LIST
41215: LIST
41216: PUSH
41217: LD_INT 1
41219: NEG
41220: PUSH
41221: LD_INT 3
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: EMPTY
41229: LIST
41230: LIST
41231: LIST
41232: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41233: LD_ADDR_VAR 0 27
41237: PUSH
41238: LD_INT 3
41240: NEG
41241: PUSH
41242: LD_INT 0
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: LD_INT 1
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 4
41262: NEG
41263: PUSH
41264: LD_INT 1
41266: NEG
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: LIST
41276: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41277: LD_ADDR_VAR 0 28
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: LD_INT 3
41288: NEG
41289: PUSH
41290: EMPTY
41291: LIST
41292: LIST
41293: PUSH
41294: LD_INT 3
41296: NEG
41297: PUSH
41298: LD_INT 4
41300: NEG
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: PUSH
41306: LD_INT 4
41308: NEG
41309: PUSH
41310: LD_INT 3
41312: NEG
41313: PUSH
41314: EMPTY
41315: LIST
41316: LIST
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: LIST
41322: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41323: LD_ADDR_VAR 0 29
41327: PUSH
41328: LD_INT 1
41330: NEG
41331: PUSH
41332: LD_INT 3
41334: NEG
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_INT 3
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 1
41353: PUSH
41354: LD_INT 2
41356: NEG
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 1
41364: NEG
41365: PUSH
41366: LD_INT 4
41368: NEG
41369: PUSH
41370: EMPTY
41371: LIST
41372: LIST
41373: PUSH
41374: LD_INT 0
41376: PUSH
41377: LD_INT 4
41379: NEG
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: PUSH
41385: LD_INT 1
41387: PUSH
41388: LD_INT 3
41390: NEG
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: PUSH
41396: LD_INT 1
41398: NEG
41399: PUSH
41400: LD_INT 5
41402: NEG
41403: PUSH
41404: EMPTY
41405: LIST
41406: LIST
41407: PUSH
41408: LD_INT 0
41410: PUSH
41411: LD_INT 5
41413: NEG
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: PUSH
41422: LD_INT 4
41424: NEG
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: LD_INT 1
41432: NEG
41433: PUSH
41434: LD_INT 6
41436: NEG
41437: PUSH
41438: EMPTY
41439: LIST
41440: LIST
41441: PUSH
41442: LD_INT 0
41444: PUSH
41445: LD_INT 6
41447: NEG
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: LD_INT 5
41458: NEG
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: EMPTY
41465: LIST
41466: LIST
41467: LIST
41468: LIST
41469: LIST
41470: LIST
41471: LIST
41472: LIST
41473: LIST
41474: LIST
41475: LIST
41476: LIST
41477: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41478: LD_ADDR_VAR 0 30
41482: PUSH
41483: LD_INT 2
41485: PUSH
41486: LD_INT 1
41488: NEG
41489: PUSH
41490: EMPTY
41491: LIST
41492: LIST
41493: PUSH
41494: LD_INT 3
41496: PUSH
41497: LD_INT 0
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 3
41506: PUSH
41507: LD_INT 1
41509: PUSH
41510: EMPTY
41511: LIST
41512: LIST
41513: PUSH
41514: LD_INT 3
41516: PUSH
41517: LD_INT 1
41519: NEG
41520: PUSH
41521: EMPTY
41522: LIST
41523: LIST
41524: PUSH
41525: LD_INT 4
41527: PUSH
41528: LD_INT 0
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: LD_INT 4
41537: PUSH
41538: LD_INT 1
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 4
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 5
41558: PUSH
41559: LD_INT 0
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 5
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 5
41578: PUSH
41579: LD_INT 1
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 6
41589: PUSH
41590: LD_INT 0
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: LD_INT 6
41599: PUSH
41600: LD_INT 1
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41621: LD_ADDR_VAR 0 31
41625: PUSH
41626: LD_INT 3
41628: PUSH
41629: LD_INT 2
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 3
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 2
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 4
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: LD_INT 4
41668: PUSH
41669: LD_INT 4
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 3
41678: PUSH
41679: LD_INT 4
41681: PUSH
41682: EMPTY
41683: LIST
41684: LIST
41685: PUSH
41686: LD_INT 5
41688: PUSH
41689: LD_INT 4
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 5
41698: PUSH
41699: LD_INT 5
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 4
41708: PUSH
41709: LD_INT 5
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 6
41718: PUSH
41719: LD_INT 5
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 6
41728: PUSH
41729: LD_INT 6
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: PUSH
41736: LD_INT 5
41738: PUSH
41739: LD_INT 6
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: EMPTY
41747: LIST
41748: LIST
41749: LIST
41750: LIST
41751: LIST
41752: LIST
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41760: LD_ADDR_VAR 0 32
41764: PUSH
41765: LD_INT 1
41767: PUSH
41768: LD_INT 3
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: PUSH
41775: LD_INT 0
41777: PUSH
41778: LD_INT 3
41780: PUSH
41781: EMPTY
41782: LIST
41783: LIST
41784: PUSH
41785: LD_INT 1
41787: NEG
41788: PUSH
41789: LD_INT 2
41791: PUSH
41792: EMPTY
41793: LIST
41794: LIST
41795: PUSH
41796: LD_INT 1
41798: PUSH
41799: LD_INT 4
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 0
41808: PUSH
41809: LD_INT 4
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: PUSH
41816: LD_INT 1
41818: NEG
41819: PUSH
41820: LD_INT 3
41822: PUSH
41823: EMPTY
41824: LIST
41825: LIST
41826: PUSH
41827: LD_INT 1
41829: PUSH
41830: LD_INT 5
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: PUSH
41837: LD_INT 0
41839: PUSH
41840: LD_INT 5
41842: PUSH
41843: EMPTY
41844: LIST
41845: LIST
41846: PUSH
41847: LD_INT 1
41849: NEG
41850: PUSH
41851: LD_INT 4
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 1
41860: PUSH
41861: LD_INT 6
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 0
41870: PUSH
41871: LD_INT 6
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: LD_INT 5
41884: PUSH
41885: EMPTY
41886: LIST
41887: LIST
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41903: LD_ADDR_VAR 0 33
41907: PUSH
41908: LD_INT 2
41910: NEG
41911: PUSH
41912: LD_INT 1
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 3
41921: NEG
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 3
41932: NEG
41933: PUSH
41934: LD_INT 1
41936: NEG
41937: PUSH
41938: EMPTY
41939: LIST
41940: LIST
41941: PUSH
41942: LD_INT 3
41944: NEG
41945: PUSH
41946: LD_INT 1
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 4
41955: NEG
41956: PUSH
41957: LD_INT 0
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 4
41966: NEG
41967: PUSH
41968: LD_INT 1
41970: NEG
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 4
41978: NEG
41979: PUSH
41980: LD_INT 1
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 5
41989: NEG
41990: PUSH
41991: LD_INT 0
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 5
42000: NEG
42001: PUSH
42002: LD_INT 1
42004: NEG
42005: PUSH
42006: EMPTY
42007: LIST
42008: LIST
42009: PUSH
42010: LD_INT 5
42012: NEG
42013: PUSH
42014: LD_INT 1
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 6
42023: NEG
42024: PUSH
42025: LD_INT 0
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: PUSH
42032: LD_INT 6
42034: NEG
42035: PUSH
42036: LD_INT 1
42038: NEG
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: LIST
42048: LIST
42049: LIST
42050: LIST
42051: LIST
42052: LIST
42053: LIST
42054: LIST
42055: LIST
42056: LIST
42057: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42058: LD_ADDR_VAR 0 34
42062: PUSH
42063: LD_INT 2
42065: NEG
42066: PUSH
42067: LD_INT 3
42069: NEG
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 3
42077: NEG
42078: PUSH
42079: LD_INT 2
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: LD_INT 3
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 3
42101: NEG
42102: PUSH
42103: LD_INT 4
42105: NEG
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 4
42113: NEG
42114: PUSH
42115: LD_INT 3
42117: NEG
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 4
42125: NEG
42126: PUSH
42127: LD_INT 4
42129: NEG
42130: PUSH
42131: EMPTY
42132: LIST
42133: LIST
42134: PUSH
42135: LD_INT 4
42137: NEG
42138: PUSH
42139: LD_INT 5
42141: NEG
42142: PUSH
42143: EMPTY
42144: LIST
42145: LIST
42146: PUSH
42147: LD_INT 5
42149: NEG
42150: PUSH
42151: LD_INT 4
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 5
42161: NEG
42162: PUSH
42163: LD_INT 5
42165: NEG
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 5
42173: NEG
42174: PUSH
42175: LD_INT 6
42177: NEG
42178: PUSH
42179: EMPTY
42180: LIST
42181: LIST
42182: PUSH
42183: LD_INT 6
42185: NEG
42186: PUSH
42187: LD_INT 5
42189: NEG
42190: PUSH
42191: EMPTY
42192: LIST
42193: LIST
42194: PUSH
42195: LD_INT 6
42197: NEG
42198: PUSH
42199: LD_INT 6
42201: NEG
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: LIST
42211: LIST
42212: LIST
42213: LIST
42214: LIST
42215: LIST
42216: LIST
42217: LIST
42218: LIST
42219: LIST
42220: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42221: LD_ADDR_VAR 0 41
42225: PUSH
42226: LD_INT 0
42228: PUSH
42229: LD_INT 2
42231: NEG
42232: PUSH
42233: EMPTY
42234: LIST
42235: LIST
42236: PUSH
42237: LD_INT 1
42239: NEG
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 1
42251: PUSH
42252: LD_INT 2
42254: NEG
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: LIST
42264: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42265: LD_ADDR_VAR 0 42
42269: PUSH
42270: LD_INT 2
42272: PUSH
42273: LD_INT 0
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 2
42282: PUSH
42283: LD_INT 1
42285: NEG
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42306: LD_ADDR_VAR 0 43
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: LD_INT 2
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: LD_INT 2
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: LIST
42345: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42346: LD_ADDR_VAR 0 44
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: LD_INT 2
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 1
42363: PUSH
42364: LD_INT 3
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 1
42373: NEG
42374: PUSH
42375: LD_INT 2
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: EMPTY
42383: LIST
42384: LIST
42385: LIST
42386: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42387: LD_ADDR_VAR 0 45
42391: PUSH
42392: LD_INT 2
42394: NEG
42395: PUSH
42396: LD_INT 0
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 2
42405: NEG
42406: PUSH
42407: LD_INT 1
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 3
42416: NEG
42417: PUSH
42418: LD_INT 1
42420: NEG
42421: PUSH
42422: EMPTY
42423: LIST
42424: LIST
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: LIST
42430: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42431: LD_ADDR_VAR 0 46
42435: PUSH
42436: LD_INT 2
42438: NEG
42439: PUSH
42440: LD_INT 2
42442: NEG
42443: PUSH
42444: EMPTY
42445: LIST
42446: LIST
42447: PUSH
42448: LD_INT 2
42450: NEG
42451: PUSH
42452: LD_INT 3
42454: NEG
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 3
42462: NEG
42463: PUSH
42464: LD_INT 2
42466: NEG
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: LIST
42476: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42477: LD_ADDR_VAR 0 47
42481: PUSH
42482: LD_INT 2
42484: NEG
42485: PUSH
42486: LD_INT 3
42488: NEG
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: NEG
42497: PUSH
42498: LD_INT 3
42500: NEG
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: EMPTY
42507: LIST
42508: LIST
42509: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42510: LD_ADDR_VAR 0 48
42514: PUSH
42515: LD_INT 1
42517: PUSH
42518: LD_INT 2
42520: NEG
42521: PUSH
42522: EMPTY
42523: LIST
42524: LIST
42525: PUSH
42526: LD_INT 2
42528: PUSH
42529: LD_INT 1
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42541: LD_ADDR_VAR 0 49
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: LD_INT 1
42551: PUSH
42552: EMPTY
42553: LIST
42554: LIST
42555: PUSH
42556: LD_INT 3
42558: PUSH
42559: LD_INT 2
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42570: LD_ADDR_VAR 0 50
42574: PUSH
42575: LD_INT 2
42577: PUSH
42578: LD_INT 3
42580: PUSH
42581: EMPTY
42582: LIST
42583: LIST
42584: PUSH
42585: LD_INT 1
42587: PUSH
42588: LD_INT 3
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: EMPTY
42596: LIST
42597: LIST
42598: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42599: LD_ADDR_VAR 0 51
42603: PUSH
42604: LD_INT 1
42606: NEG
42607: PUSH
42608: LD_INT 2
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 2
42617: NEG
42618: PUSH
42619: LD_INT 1
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42630: LD_ADDR_VAR 0 52
42634: PUSH
42635: LD_INT 3
42637: NEG
42638: PUSH
42639: LD_INT 1
42641: NEG
42642: PUSH
42643: EMPTY
42644: LIST
42645: LIST
42646: PUSH
42647: LD_INT 3
42649: NEG
42650: PUSH
42651: LD_INT 2
42653: NEG
42654: PUSH
42655: EMPTY
42656: LIST
42657: LIST
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42663: LD_ADDR_VAR 0 53
42667: PUSH
42668: LD_INT 1
42670: NEG
42671: PUSH
42672: LD_INT 3
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 0
42682: PUSH
42683: LD_INT 3
42685: NEG
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 2
42696: NEG
42697: PUSH
42698: EMPTY
42699: LIST
42700: LIST
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: LIST
42706: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42707: LD_ADDR_VAR 0 54
42711: PUSH
42712: LD_INT 2
42714: PUSH
42715: LD_INT 1
42717: NEG
42718: PUSH
42719: EMPTY
42720: LIST
42721: LIST
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: LD_INT 1
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: EMPTY
42744: LIST
42745: LIST
42746: LIST
42747: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42748: LD_ADDR_VAR 0 55
42752: PUSH
42753: LD_INT 3
42755: PUSH
42756: LD_INT 2
42758: PUSH
42759: EMPTY
42760: LIST
42761: LIST
42762: PUSH
42763: LD_INT 3
42765: PUSH
42766: LD_INT 3
42768: PUSH
42769: EMPTY
42770: LIST
42771: LIST
42772: PUSH
42773: LD_INT 2
42775: PUSH
42776: LD_INT 3
42778: PUSH
42779: EMPTY
42780: LIST
42781: LIST
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: LIST
42787: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42788: LD_ADDR_VAR 0 56
42792: PUSH
42793: LD_INT 1
42795: PUSH
42796: LD_INT 3
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 0
42805: PUSH
42806: LD_INT 3
42808: PUSH
42809: EMPTY
42810: LIST
42811: LIST
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 2
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: LIST
42828: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42829: LD_ADDR_VAR 0 57
42833: PUSH
42834: LD_INT 2
42836: NEG
42837: PUSH
42838: LD_INT 1
42840: PUSH
42841: EMPTY
42842: LIST
42843: LIST
42844: PUSH
42845: LD_INT 3
42847: NEG
42848: PUSH
42849: LD_INT 0
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 3
42858: NEG
42859: PUSH
42860: LD_INT 1
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: LIST
42872: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42873: LD_ADDR_VAR 0 58
42877: PUSH
42878: LD_INT 2
42880: NEG
42881: PUSH
42882: LD_INT 3
42884: NEG
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 3
42892: NEG
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: LD_INT 3
42904: NEG
42905: PUSH
42906: LD_INT 3
42908: NEG
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: LIST
42918: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42919: LD_ADDR_VAR 0 59
42923: PUSH
42924: LD_INT 1
42926: NEG
42927: PUSH
42928: LD_INT 2
42930: NEG
42931: PUSH
42932: EMPTY
42933: LIST
42934: LIST
42935: PUSH
42936: LD_INT 0
42938: PUSH
42939: LD_INT 2
42941: NEG
42942: PUSH
42943: EMPTY
42944: LIST
42945: LIST
42946: PUSH
42947: LD_INT 1
42949: PUSH
42950: LD_INT 1
42952: NEG
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: EMPTY
42959: LIST
42960: LIST
42961: LIST
42962: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42963: LD_ADDR_VAR 0 60
42967: PUSH
42968: LD_INT 1
42970: PUSH
42971: LD_INT 1
42973: NEG
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: PUSH
42979: LD_INT 2
42981: PUSH
42982: LD_INT 0
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: LD_INT 2
42991: PUSH
42992: LD_INT 1
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PUSH
42999: EMPTY
43000: LIST
43001: LIST
43002: LIST
43003: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43004: LD_ADDR_VAR 0 61
43008: PUSH
43009: LD_INT 2
43011: PUSH
43012: LD_INT 1
43014: PUSH
43015: EMPTY
43016: LIST
43017: LIST
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: LD_INT 2
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 1
43031: PUSH
43032: LD_INT 2
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: LIST
43043: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43044: LD_ADDR_VAR 0 62
43048: PUSH
43049: LD_INT 1
43051: PUSH
43052: LD_INT 2
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 0
43061: PUSH
43062: LD_INT 2
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: LD_INT 1
43071: NEG
43072: PUSH
43073: LD_INT 1
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: EMPTY
43081: LIST
43082: LIST
43083: LIST
43084: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43085: LD_ADDR_VAR 0 63
43089: PUSH
43090: LD_INT 1
43092: NEG
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 2
43103: NEG
43104: PUSH
43105: LD_INT 0
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 2
43114: NEG
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: EMPTY
43125: LIST
43126: LIST
43127: LIST
43128: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43129: LD_ADDR_VAR 0 64
43133: PUSH
43134: LD_INT 1
43136: NEG
43137: PUSH
43138: LD_INT 2
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: LD_INT 1
43152: NEG
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 2
43160: NEG
43161: PUSH
43162: LD_INT 2
43164: NEG
43165: PUSH
43166: EMPTY
43167: LIST
43168: LIST
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: LIST
43174: ST_TO_ADDR
// end ; 2 :
43175: GO 46441
43177: LD_INT 2
43179: DOUBLE
43180: EQUAL
43181: IFTRUE 43185
43183: GO 46440
43185: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43186: LD_ADDR_VAR 0 29
43190: PUSH
43191: LD_INT 4
43193: PUSH
43194: LD_INT 0
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: LD_INT 4
43203: PUSH
43204: LD_INT 1
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 5
43214: PUSH
43215: LD_INT 0
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: LD_INT 5
43224: PUSH
43225: LD_INT 1
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 4
43234: PUSH
43235: LD_INT 1
43237: PUSH
43238: EMPTY
43239: LIST
43240: LIST
43241: PUSH
43242: LD_INT 3
43244: PUSH
43245: LD_INT 0
43247: PUSH
43248: EMPTY
43249: LIST
43250: LIST
43251: PUSH
43252: LD_INT 3
43254: PUSH
43255: LD_INT 1
43257: NEG
43258: PUSH
43259: EMPTY
43260: LIST
43261: LIST
43262: PUSH
43263: LD_INT 3
43265: PUSH
43266: LD_INT 2
43268: NEG
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: LD_INT 5
43276: PUSH
43277: LD_INT 2
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: PUSH
43287: LD_INT 3
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 3
43296: PUSH
43297: LD_INT 2
43299: PUSH
43300: EMPTY
43301: LIST
43302: LIST
43303: PUSH
43304: LD_INT 4
43306: PUSH
43307: LD_INT 3
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 4
43316: PUSH
43317: LD_INT 4
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 3
43326: PUSH
43327: LD_INT 4
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: LD_INT 2
43336: PUSH
43337: LD_INT 3
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 2
43346: PUSH
43347: LD_INT 2
43349: PUSH
43350: EMPTY
43351: LIST
43352: LIST
43353: PUSH
43354: LD_INT 4
43356: PUSH
43357: LD_INT 2
43359: PUSH
43360: EMPTY
43361: LIST
43362: LIST
43363: PUSH
43364: LD_INT 2
43366: PUSH
43367: LD_INT 4
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PUSH
43374: LD_INT 0
43376: PUSH
43377: LD_INT 4
43379: PUSH
43380: EMPTY
43381: LIST
43382: LIST
43383: PUSH
43384: LD_INT 0
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: PUSH
43397: LD_INT 4
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: LD_INT 1
43406: PUSH
43407: LD_INT 5
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 0
43416: PUSH
43417: LD_INT 5
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: LD_INT 4
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: LD_INT 3
43441: PUSH
43442: EMPTY
43443: LIST
43444: LIST
43445: PUSH
43446: LD_INT 2
43448: PUSH
43449: LD_INT 5
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 2
43458: NEG
43459: PUSH
43460: LD_INT 3
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 3
43469: NEG
43470: PUSH
43471: LD_INT 0
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 3
43480: NEG
43481: PUSH
43482: LD_INT 1
43484: NEG
43485: PUSH
43486: EMPTY
43487: LIST
43488: LIST
43489: PUSH
43490: LD_INT 2
43492: NEG
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 2
43503: NEG
43504: PUSH
43505: LD_INT 1
43507: PUSH
43508: EMPTY
43509: LIST
43510: LIST
43511: PUSH
43512: LD_INT 3
43514: NEG
43515: PUSH
43516: LD_INT 1
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 4
43525: NEG
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 4
43536: NEG
43537: PUSH
43538: LD_INT 1
43540: NEG
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 4
43548: NEG
43549: PUSH
43550: LD_INT 2
43552: NEG
43553: PUSH
43554: EMPTY
43555: LIST
43556: LIST
43557: PUSH
43558: LD_INT 2
43560: NEG
43561: PUSH
43562: LD_INT 2
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 4
43571: NEG
43572: PUSH
43573: LD_INT 4
43575: NEG
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 4
43583: NEG
43584: PUSH
43585: LD_INT 5
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: LD_INT 3
43595: NEG
43596: PUSH
43597: LD_INT 4
43599: NEG
43600: PUSH
43601: EMPTY
43602: LIST
43603: LIST
43604: PUSH
43605: LD_INT 3
43607: NEG
43608: PUSH
43609: LD_INT 3
43611: NEG
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 4
43619: NEG
43620: PUSH
43621: LD_INT 3
43623: NEG
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: PUSH
43629: LD_INT 5
43631: NEG
43632: PUSH
43633: LD_INT 4
43635: NEG
43636: PUSH
43637: EMPTY
43638: LIST
43639: LIST
43640: PUSH
43641: LD_INT 5
43643: NEG
43644: PUSH
43645: LD_INT 5
43647: NEG
43648: PUSH
43649: EMPTY
43650: LIST
43651: LIST
43652: PUSH
43653: LD_INT 3
43655: NEG
43656: PUSH
43657: LD_INT 5
43659: NEG
43660: PUSH
43661: EMPTY
43662: LIST
43663: LIST
43664: PUSH
43665: LD_INT 5
43667: NEG
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: EMPTY
43674: LIST
43675: LIST
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: LIST
43681: LIST
43682: LIST
43683: LIST
43684: LIST
43685: LIST
43686: LIST
43687: LIST
43688: LIST
43689: LIST
43690: LIST
43691: LIST
43692: LIST
43693: LIST
43694: LIST
43695: LIST
43696: LIST
43697: LIST
43698: LIST
43699: LIST
43700: LIST
43701: LIST
43702: LIST
43703: LIST
43704: LIST
43705: LIST
43706: LIST
43707: LIST
43708: LIST
43709: LIST
43710: LIST
43711: LIST
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: LIST
43720: LIST
43721: LIST
43722: LIST
43723: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43724: LD_ADDR_VAR 0 30
43728: PUSH
43729: LD_INT 4
43731: PUSH
43732: LD_INT 4
43734: PUSH
43735: EMPTY
43736: LIST
43737: LIST
43738: PUSH
43739: LD_INT 4
43741: PUSH
43742: LD_INT 3
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: PUSH
43749: LD_INT 5
43751: PUSH
43752: LD_INT 4
43754: PUSH
43755: EMPTY
43756: LIST
43757: LIST
43758: PUSH
43759: LD_INT 5
43761: PUSH
43762: LD_INT 5
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: PUSH
43769: LD_INT 4
43771: PUSH
43772: LD_INT 5
43774: PUSH
43775: EMPTY
43776: LIST
43777: LIST
43778: PUSH
43779: LD_INT 3
43781: PUSH
43782: LD_INT 4
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 3
43791: PUSH
43792: LD_INT 3
43794: PUSH
43795: EMPTY
43796: LIST
43797: LIST
43798: PUSH
43799: LD_INT 5
43801: PUSH
43802: LD_INT 3
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 3
43811: PUSH
43812: LD_INT 5
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 0
43821: PUSH
43822: LD_INT 3
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 0
43831: PUSH
43832: LD_INT 2
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 1
43841: PUSH
43842: LD_INT 3
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 1
43851: PUSH
43852: LD_INT 4
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 0
43861: PUSH
43862: LD_INT 4
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 1
43871: NEG
43872: PUSH
43873: LD_INT 3
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: LD_INT 2
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: LD_INT 2
43893: PUSH
43894: LD_INT 4
43896: PUSH
43897: EMPTY
43898: LIST
43899: LIST
43900: PUSH
43901: LD_INT 2
43903: NEG
43904: PUSH
43905: LD_INT 2
43907: PUSH
43908: EMPTY
43909: LIST
43910: LIST
43911: PUSH
43912: LD_INT 4
43914: NEG
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 4
43925: NEG
43926: PUSH
43927: LD_INT 1
43929: NEG
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: NEG
43938: PUSH
43939: LD_INT 0
43941: PUSH
43942: EMPTY
43943: LIST
43944: LIST
43945: PUSH
43946: LD_INT 3
43948: NEG
43949: PUSH
43950: LD_INT 1
43952: PUSH
43953: EMPTY
43954: LIST
43955: LIST
43956: PUSH
43957: LD_INT 4
43959: NEG
43960: PUSH
43961: LD_INT 1
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 5
43970: NEG
43971: PUSH
43972: LD_INT 0
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 5
43981: NEG
43982: PUSH
43983: LD_INT 1
43985: NEG
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 5
43993: NEG
43994: PUSH
43995: LD_INT 2
43997: NEG
43998: PUSH
43999: EMPTY
44000: LIST
44001: LIST
44002: PUSH
44003: LD_INT 3
44005: NEG
44006: PUSH
44007: LD_INT 2
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 3
44016: NEG
44017: PUSH
44018: LD_INT 3
44020: NEG
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: PUSH
44026: LD_INT 3
44028: NEG
44029: PUSH
44030: LD_INT 4
44032: NEG
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 2
44040: NEG
44041: PUSH
44042: LD_INT 3
44044: NEG
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: LD_INT 2
44052: NEG
44053: PUSH
44054: LD_INT 2
44056: NEG
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: NEG
44065: PUSH
44066: LD_INT 2
44068: NEG
44069: PUSH
44070: EMPTY
44071: LIST
44072: LIST
44073: PUSH
44074: LD_INT 4
44076: NEG
44077: PUSH
44078: LD_INT 3
44080: NEG
44081: PUSH
44082: EMPTY
44083: LIST
44084: LIST
44085: PUSH
44086: LD_INT 4
44088: NEG
44089: PUSH
44090: LD_INT 4
44092: NEG
44093: PUSH
44094: EMPTY
44095: LIST
44096: LIST
44097: PUSH
44098: LD_INT 2
44100: NEG
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: EMPTY
44107: LIST
44108: LIST
44109: PUSH
44110: LD_INT 4
44112: NEG
44113: PUSH
44114: LD_INT 2
44116: NEG
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 0
44124: PUSH
44125: LD_INT 4
44127: NEG
44128: PUSH
44129: EMPTY
44130: LIST
44131: LIST
44132: PUSH
44133: LD_INT 0
44135: PUSH
44136: LD_INT 5
44138: NEG
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: PUSH
44144: LD_INT 1
44146: PUSH
44147: LD_INT 4
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 1
44157: PUSH
44158: LD_INT 3
44160: NEG
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 0
44168: PUSH
44169: LD_INT 3
44171: NEG
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 1
44179: NEG
44180: PUSH
44181: LD_INT 4
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: NEG
44192: PUSH
44193: LD_INT 5
44195: NEG
44196: PUSH
44197: EMPTY
44198: LIST
44199: LIST
44200: PUSH
44201: LD_INT 2
44203: PUSH
44204: LD_INT 3
44206: NEG
44207: PUSH
44208: EMPTY
44209: LIST
44210: LIST
44211: PUSH
44212: LD_INT 2
44214: NEG
44215: PUSH
44216: LD_INT 5
44218: NEG
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: LIST
44228: LIST
44229: LIST
44230: LIST
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44271: LD_ADDR_VAR 0 31
44275: PUSH
44276: LD_INT 0
44278: PUSH
44279: LD_INT 4
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 3
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: LD_INT 4
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 1
44308: PUSH
44309: LD_INT 5
44311: PUSH
44312: EMPTY
44313: LIST
44314: LIST
44315: PUSH
44316: LD_INT 0
44318: PUSH
44319: LD_INT 5
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 1
44328: NEG
44329: PUSH
44330: LD_INT 4
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 1
44339: NEG
44340: PUSH
44341: LD_INT 3
44343: PUSH
44344: EMPTY
44345: LIST
44346: LIST
44347: PUSH
44348: LD_INT 2
44350: PUSH
44351: LD_INT 5
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 2
44360: NEG
44361: PUSH
44362: LD_INT 3
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: LD_INT 3
44371: NEG
44372: PUSH
44373: LD_INT 0
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 3
44382: NEG
44383: PUSH
44384: LD_INT 1
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 2
44394: NEG
44395: PUSH
44396: LD_INT 0
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 2
44405: NEG
44406: PUSH
44407: LD_INT 1
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 3
44416: NEG
44417: PUSH
44418: LD_INT 1
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: NEG
44428: PUSH
44429: LD_INT 0
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 4
44438: NEG
44439: PUSH
44440: LD_INT 1
44442: NEG
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: PUSH
44448: LD_INT 4
44450: NEG
44451: PUSH
44452: LD_INT 2
44454: NEG
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 2
44462: NEG
44463: PUSH
44464: LD_INT 2
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 4
44473: NEG
44474: PUSH
44475: LD_INT 4
44477: NEG
44478: PUSH
44479: EMPTY
44480: LIST
44481: LIST
44482: PUSH
44483: LD_INT 4
44485: NEG
44486: PUSH
44487: LD_INT 5
44489: NEG
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 3
44497: NEG
44498: PUSH
44499: LD_INT 4
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 3
44509: NEG
44510: PUSH
44511: LD_INT 3
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 4
44521: NEG
44522: PUSH
44523: LD_INT 3
44525: NEG
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 5
44533: NEG
44534: PUSH
44535: LD_INT 4
44537: NEG
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: PUSH
44543: LD_INT 5
44545: NEG
44546: PUSH
44547: LD_INT 5
44549: NEG
44550: PUSH
44551: EMPTY
44552: LIST
44553: LIST
44554: PUSH
44555: LD_INT 3
44557: NEG
44558: PUSH
44559: LD_INT 5
44561: NEG
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 5
44569: NEG
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: EMPTY
44576: LIST
44577: LIST
44578: PUSH
44579: LD_INT 0
44581: PUSH
44582: LD_INT 3
44584: NEG
44585: PUSH
44586: EMPTY
44587: LIST
44588: LIST
44589: PUSH
44590: LD_INT 0
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: EMPTY
44598: LIST
44599: LIST
44600: PUSH
44601: LD_INT 1
44603: PUSH
44604: LD_INT 3
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 1
44614: PUSH
44615: LD_INT 2
44617: NEG
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 0
44625: PUSH
44626: LD_INT 2
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: NEG
44637: PUSH
44638: LD_INT 3
44640: NEG
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 1
44648: NEG
44649: PUSH
44650: LD_INT 4
44652: NEG
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: LD_INT 2
44660: PUSH
44661: LD_INT 2
44663: NEG
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 2
44671: NEG
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: EMPTY
44678: LIST
44679: LIST
44680: PUSH
44681: LD_INT 4
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 4
44693: PUSH
44694: LD_INT 1
44696: NEG
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 5
44704: PUSH
44705: LD_INT 0
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 5
44714: PUSH
44715: LD_INT 1
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 4
44724: PUSH
44725: LD_INT 1
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 3
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 1
44747: NEG
44748: PUSH
44749: EMPTY
44750: LIST
44751: LIST
44752: PUSH
44753: LD_INT 3
44755: PUSH
44756: LD_INT 2
44758: NEG
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: LD_INT 5
44766: PUSH
44767: LD_INT 2
44769: PUSH
44770: EMPTY
44771: LIST
44772: LIST
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: LIST
44816: LIST
44817: LIST
44818: LIST
44819: LIST
44820: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44821: LD_ADDR_VAR 0 32
44825: PUSH
44826: LD_INT 4
44828: NEG
44829: PUSH
44830: LD_INT 0
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 4
44839: NEG
44840: PUSH
44841: LD_INT 1
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 3
44851: NEG
44852: PUSH
44853: LD_INT 0
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 3
44862: NEG
44863: PUSH
44864: LD_INT 1
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 4
44873: NEG
44874: PUSH
44875: LD_INT 1
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 5
44884: NEG
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 5
44895: NEG
44896: PUSH
44897: LD_INT 1
44899: NEG
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: NEG
44908: PUSH
44909: LD_INT 2
44911: NEG
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 3
44919: NEG
44920: PUSH
44921: LD_INT 2
44923: PUSH
44924: EMPTY
44925: LIST
44926: LIST
44927: PUSH
44928: LD_INT 3
44930: NEG
44931: PUSH
44932: LD_INT 3
44934: NEG
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 3
44942: NEG
44943: PUSH
44944: LD_INT 4
44946: NEG
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: LD_INT 2
44954: NEG
44955: PUSH
44956: LD_INT 3
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 2
44966: NEG
44967: PUSH
44968: LD_INT 2
44970: NEG
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 3
44978: NEG
44979: PUSH
44980: LD_INT 2
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 4
44990: NEG
44991: PUSH
44992: LD_INT 3
44994: NEG
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 4
45002: NEG
45003: PUSH
45004: LD_INT 4
45006: NEG
45007: PUSH
45008: EMPTY
45009: LIST
45010: LIST
45011: PUSH
45012: LD_INT 2
45014: NEG
45015: PUSH
45016: LD_INT 4
45018: NEG
45019: PUSH
45020: EMPTY
45021: LIST
45022: LIST
45023: PUSH
45024: LD_INT 4
45026: NEG
45027: PUSH
45028: LD_INT 2
45030: NEG
45031: PUSH
45032: EMPTY
45033: LIST
45034: LIST
45035: PUSH
45036: LD_INT 0
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: EMPTY
45055: LIST
45056: LIST
45057: PUSH
45058: LD_INT 1
45060: PUSH
45061: LD_INT 4
45063: NEG
45064: PUSH
45065: EMPTY
45066: LIST
45067: LIST
45068: PUSH
45069: LD_INT 1
45071: PUSH
45072: LD_INT 3
45074: NEG
45075: PUSH
45076: EMPTY
45077: LIST
45078: LIST
45079: PUSH
45080: LD_INT 0
45082: PUSH
45083: LD_INT 3
45085: NEG
45086: PUSH
45087: EMPTY
45088: LIST
45089: LIST
45090: PUSH
45091: LD_INT 1
45093: NEG
45094: PUSH
45095: LD_INT 4
45097: NEG
45098: PUSH
45099: EMPTY
45100: LIST
45101: LIST
45102: PUSH
45103: LD_INT 1
45105: NEG
45106: PUSH
45107: LD_INT 5
45109: NEG
45110: PUSH
45111: EMPTY
45112: LIST
45113: LIST
45114: PUSH
45115: LD_INT 2
45117: PUSH
45118: LD_INT 3
45120: NEG
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: LD_INT 5
45132: NEG
45133: PUSH
45134: EMPTY
45135: LIST
45136: LIST
45137: PUSH
45138: LD_INT 3
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 3
45150: PUSH
45151: LD_INT 1
45153: NEG
45154: PUSH
45155: EMPTY
45156: LIST
45157: LIST
45158: PUSH
45159: LD_INT 4
45161: PUSH
45162: LD_INT 0
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: PUSH
45172: LD_INT 1
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: PUSH
45182: LD_INT 1
45184: PUSH
45185: EMPTY
45186: LIST
45187: LIST
45188: PUSH
45189: LD_INT 2
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: EMPTY
45196: LIST
45197: LIST
45198: PUSH
45199: LD_INT 2
45201: PUSH
45202: LD_INT 1
45204: NEG
45205: PUSH
45206: EMPTY
45207: LIST
45208: LIST
45209: PUSH
45210: LD_INT 2
45212: PUSH
45213: LD_INT 2
45215: NEG
45216: PUSH
45217: EMPTY
45218: LIST
45219: LIST
45220: PUSH
45221: LD_INT 4
45223: PUSH
45224: LD_INT 2
45226: PUSH
45227: EMPTY
45228: LIST
45229: LIST
45230: PUSH
45231: LD_INT 4
45233: PUSH
45234: LD_INT 4
45236: PUSH
45237: EMPTY
45238: LIST
45239: LIST
45240: PUSH
45241: LD_INT 4
45243: PUSH
45244: LD_INT 3
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 5
45253: PUSH
45254: LD_INT 4
45256: PUSH
45257: EMPTY
45258: LIST
45259: LIST
45260: PUSH
45261: LD_INT 5
45263: PUSH
45264: LD_INT 5
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 4
45273: PUSH
45274: LD_INT 5
45276: PUSH
45277: EMPTY
45278: LIST
45279: LIST
45280: PUSH
45281: LD_INT 3
45283: PUSH
45284: LD_INT 4
45286: PUSH
45287: EMPTY
45288: LIST
45289: LIST
45290: PUSH
45291: LD_INT 3
45293: PUSH
45294: LD_INT 3
45296: PUSH
45297: EMPTY
45298: LIST
45299: LIST
45300: PUSH
45301: LD_INT 5
45303: PUSH
45304: LD_INT 3
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 3
45313: PUSH
45314: LD_INT 5
45316: PUSH
45317: EMPTY
45318: LIST
45319: LIST
45320: PUSH
45321: EMPTY
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: LIST
45366: LIST
45367: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45368: LD_ADDR_VAR 0 33
45372: PUSH
45373: LD_INT 4
45375: NEG
45376: PUSH
45377: LD_INT 4
45379: NEG
45380: PUSH
45381: EMPTY
45382: LIST
45383: LIST
45384: PUSH
45385: LD_INT 4
45387: NEG
45388: PUSH
45389: LD_INT 5
45391: NEG
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: LD_INT 3
45399: NEG
45400: PUSH
45401: LD_INT 4
45403: NEG
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 3
45411: NEG
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 4
45423: NEG
45424: PUSH
45425: LD_INT 3
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 5
45435: NEG
45436: PUSH
45437: LD_INT 4
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 5
45447: NEG
45448: PUSH
45449: LD_INT 5
45451: NEG
45452: PUSH
45453: EMPTY
45454: LIST
45455: LIST
45456: PUSH
45457: LD_INT 3
45459: NEG
45460: PUSH
45461: LD_INT 5
45463: NEG
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: PUSH
45469: LD_INT 5
45471: NEG
45472: PUSH
45473: LD_INT 3
45475: NEG
45476: PUSH
45477: EMPTY
45478: LIST
45479: LIST
45480: PUSH
45481: LD_INT 0
45483: PUSH
45484: LD_INT 3
45486: NEG
45487: PUSH
45488: EMPTY
45489: LIST
45490: LIST
45491: PUSH
45492: LD_INT 0
45494: PUSH
45495: LD_INT 4
45497: NEG
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: LD_INT 3
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 1
45516: PUSH
45517: LD_INT 2
45519: NEG
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 0
45527: PUSH
45528: LD_INT 2
45530: NEG
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 1
45538: NEG
45539: PUSH
45540: LD_INT 3
45542: NEG
45543: PUSH
45544: EMPTY
45545: LIST
45546: LIST
45547: PUSH
45548: LD_INT 1
45550: NEG
45551: PUSH
45552: LD_INT 4
45554: NEG
45555: PUSH
45556: EMPTY
45557: LIST
45558: LIST
45559: PUSH
45560: LD_INT 2
45562: PUSH
45563: LD_INT 2
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 2
45573: NEG
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: EMPTY
45580: LIST
45581: LIST
45582: PUSH
45583: LD_INT 4
45585: PUSH
45586: LD_INT 0
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 4
45595: PUSH
45596: LD_INT 1
45598: NEG
45599: PUSH
45600: EMPTY
45601: LIST
45602: LIST
45603: PUSH
45604: LD_INT 5
45606: PUSH
45607: LD_INT 0
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 5
45616: PUSH
45617: LD_INT 1
45619: PUSH
45620: EMPTY
45621: LIST
45622: LIST
45623: PUSH
45624: LD_INT 4
45626: PUSH
45627: LD_INT 1
45629: PUSH
45630: EMPTY
45631: LIST
45632: LIST
45633: PUSH
45634: LD_INT 3
45636: PUSH
45637: LD_INT 0
45639: PUSH
45640: EMPTY
45641: LIST
45642: LIST
45643: PUSH
45644: LD_INT 3
45646: PUSH
45647: LD_INT 1
45649: NEG
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: LD_INT 3
45657: PUSH
45658: LD_INT 2
45660: NEG
45661: PUSH
45662: EMPTY
45663: LIST
45664: LIST
45665: PUSH
45666: LD_INT 5
45668: PUSH
45669: LD_INT 2
45671: PUSH
45672: EMPTY
45673: LIST
45674: LIST
45675: PUSH
45676: LD_INT 3
45678: PUSH
45679: LD_INT 3
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: PUSH
45686: LD_INT 3
45688: PUSH
45689: LD_INT 2
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 4
45698: PUSH
45699: LD_INT 3
45701: PUSH
45702: EMPTY
45703: LIST
45704: LIST
45705: PUSH
45706: LD_INT 4
45708: PUSH
45709: LD_INT 4
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 3
45718: PUSH
45719: LD_INT 4
45721: PUSH
45722: EMPTY
45723: LIST
45724: LIST
45725: PUSH
45726: LD_INT 2
45728: PUSH
45729: LD_INT 3
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: LD_INT 2
45738: PUSH
45739: LD_INT 2
45741: PUSH
45742: EMPTY
45743: LIST
45744: LIST
45745: PUSH
45746: LD_INT 4
45748: PUSH
45749: LD_INT 2
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 2
45758: PUSH
45759: LD_INT 4
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 0
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 0
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 1
45788: PUSH
45789: LD_INT 4
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 1
45798: PUSH
45799: LD_INT 5
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: LD_INT 5
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: LD_INT 4
45822: PUSH
45823: EMPTY
45824: LIST
45825: LIST
45826: PUSH
45827: LD_INT 1
45829: NEG
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: EMPTY
45835: LIST
45836: LIST
45837: PUSH
45838: LD_INT 2
45840: PUSH
45841: LD_INT 5
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 2
45850: NEG
45851: PUSH
45852: LD_INT 3
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: EMPTY
45860: LIST
45861: LIST
45862: LIST
45863: LIST
45864: LIST
45865: LIST
45866: LIST
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45906: LD_ADDR_VAR 0 34
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 4
45916: NEG
45917: PUSH
45918: EMPTY
45919: LIST
45920: LIST
45921: PUSH
45922: LD_INT 0
45924: PUSH
45925: LD_INT 5
45927: NEG
45928: PUSH
45929: EMPTY
45930: LIST
45931: LIST
45932: PUSH
45933: LD_INT 1
45935: PUSH
45936: LD_INT 4
45938: NEG
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 1
45946: PUSH
45947: LD_INT 3
45949: NEG
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: PUSH
45955: LD_INT 0
45957: PUSH
45958: LD_INT 3
45960: NEG
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 1
45968: NEG
45969: PUSH
45970: LD_INT 4
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 1
45980: NEG
45981: PUSH
45982: LD_INT 5
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 2
45992: PUSH
45993: LD_INT 3
45995: NEG
45996: PUSH
45997: EMPTY
45998: LIST
45999: LIST
46000: PUSH
46001: LD_INT 2
46003: NEG
46004: PUSH
46005: LD_INT 5
46007: NEG
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 3
46015: PUSH
46016: LD_INT 0
46018: PUSH
46019: EMPTY
46020: LIST
46021: LIST
46022: PUSH
46023: LD_INT 3
46025: PUSH
46026: LD_INT 1
46028: NEG
46029: PUSH
46030: EMPTY
46031: LIST
46032: LIST
46033: PUSH
46034: LD_INT 4
46036: PUSH
46037: LD_INT 0
46039: PUSH
46040: EMPTY
46041: LIST
46042: LIST
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 1
46049: PUSH
46050: EMPTY
46051: LIST
46052: LIST
46053: PUSH
46054: LD_INT 3
46056: PUSH
46057: LD_INT 1
46059: PUSH
46060: EMPTY
46061: LIST
46062: LIST
46063: PUSH
46064: LD_INT 2
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 2
46076: PUSH
46077: LD_INT 1
46079: NEG
46080: PUSH
46081: EMPTY
46082: LIST
46083: LIST
46084: PUSH
46085: LD_INT 2
46087: PUSH
46088: LD_INT 2
46090: NEG
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 4
46098: PUSH
46099: LD_INT 2
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 4
46108: PUSH
46109: LD_INT 4
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 4
46118: PUSH
46119: LD_INT 3
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 5
46128: PUSH
46129: LD_INT 4
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 5
46138: PUSH
46139: LD_INT 5
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 4
46148: PUSH
46149: LD_INT 5
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: LD_INT 3
46158: PUSH
46159: LD_INT 4
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: LD_INT 3
46168: PUSH
46169: LD_INT 3
46171: PUSH
46172: EMPTY
46173: LIST
46174: LIST
46175: PUSH
46176: LD_INT 5
46178: PUSH
46179: LD_INT 3
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 3
46188: PUSH
46189: LD_INT 5
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 0
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 0
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 1
46218: PUSH
46219: LD_INT 3
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 1
46228: PUSH
46229: LD_INT 4
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 0
46238: PUSH
46239: LD_INT 4
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 1
46248: NEG
46249: PUSH
46250: LD_INT 3
46252: PUSH
46253: EMPTY
46254: LIST
46255: LIST
46256: PUSH
46257: LD_INT 1
46259: NEG
46260: PUSH
46261: LD_INT 2
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 2
46270: PUSH
46271: LD_INT 4
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 2
46280: NEG
46281: PUSH
46282: LD_INT 2
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 4
46291: NEG
46292: PUSH
46293: LD_INT 0
46295: PUSH
46296: EMPTY
46297: LIST
46298: LIST
46299: PUSH
46300: LD_INT 4
46302: NEG
46303: PUSH
46304: LD_INT 1
46306: NEG
46307: PUSH
46308: EMPTY
46309: LIST
46310: LIST
46311: PUSH
46312: LD_INT 3
46314: NEG
46315: PUSH
46316: LD_INT 0
46318: PUSH
46319: EMPTY
46320: LIST
46321: LIST
46322: PUSH
46323: LD_INT 3
46325: NEG
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: LD_INT 4
46336: NEG
46337: PUSH
46338: LD_INT 1
46340: PUSH
46341: EMPTY
46342: LIST
46343: LIST
46344: PUSH
46345: LD_INT 5
46347: NEG
46348: PUSH
46349: LD_INT 0
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: PUSH
46356: LD_INT 5
46358: NEG
46359: PUSH
46360: LD_INT 1
46362: NEG
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 5
46370: NEG
46371: PUSH
46372: LD_INT 2
46374: NEG
46375: PUSH
46376: EMPTY
46377: LIST
46378: LIST
46379: PUSH
46380: LD_INT 3
46382: NEG
46383: PUSH
46384: LD_INT 2
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: EMPTY
46392: LIST
46393: LIST
46394: LIST
46395: LIST
46396: LIST
46397: LIST
46398: LIST
46399: LIST
46400: LIST
46401: LIST
46402: LIST
46403: LIST
46404: LIST
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: ST_TO_ADDR
// end ; end ;
46438: GO 46441
46440: POP
// case btype of b_depot , b_warehouse :
46441: LD_VAR 0 1
46445: PUSH
46446: LD_INT 0
46448: DOUBLE
46449: EQUAL
46450: IFTRUE 46460
46452: LD_INT 1
46454: DOUBLE
46455: EQUAL
46456: IFTRUE 46460
46458: GO 46661
46460: POP
// case nation of nation_american :
46461: LD_VAR 0 5
46465: PUSH
46466: LD_INT 1
46468: DOUBLE
46469: EQUAL
46470: IFTRUE 46474
46472: GO 46530
46474: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46475: LD_ADDR_VAR 0 9
46479: PUSH
46480: LD_VAR 0 11
46484: PUSH
46485: LD_VAR 0 12
46489: PUSH
46490: LD_VAR 0 13
46494: PUSH
46495: LD_VAR 0 14
46499: PUSH
46500: LD_VAR 0 15
46504: PUSH
46505: LD_VAR 0 16
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: LIST
46514: LIST
46515: LIST
46516: LIST
46517: PUSH
46518: LD_VAR 0 4
46522: PUSH
46523: LD_INT 1
46525: PLUS
46526: ARRAY
46527: ST_TO_ADDR
46528: GO 46659
46530: LD_INT 2
46532: DOUBLE
46533: EQUAL
46534: IFTRUE 46538
46536: GO 46594
46538: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46539: LD_ADDR_VAR 0 9
46543: PUSH
46544: LD_VAR 0 17
46548: PUSH
46549: LD_VAR 0 18
46553: PUSH
46554: LD_VAR 0 19
46558: PUSH
46559: LD_VAR 0 20
46563: PUSH
46564: LD_VAR 0 21
46568: PUSH
46569: LD_VAR 0 22
46573: PUSH
46574: EMPTY
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: PUSH
46582: LD_VAR 0 4
46586: PUSH
46587: LD_INT 1
46589: PLUS
46590: ARRAY
46591: ST_TO_ADDR
46592: GO 46659
46594: LD_INT 3
46596: DOUBLE
46597: EQUAL
46598: IFTRUE 46602
46600: GO 46658
46602: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46603: LD_ADDR_VAR 0 9
46607: PUSH
46608: LD_VAR 0 23
46612: PUSH
46613: LD_VAR 0 24
46617: PUSH
46618: LD_VAR 0 25
46622: PUSH
46623: LD_VAR 0 26
46627: PUSH
46628: LD_VAR 0 27
46632: PUSH
46633: LD_VAR 0 28
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: PUSH
46646: LD_VAR 0 4
46650: PUSH
46651: LD_INT 1
46653: PLUS
46654: ARRAY
46655: ST_TO_ADDR
46656: GO 46659
46658: POP
46659: GO 47214
46661: LD_INT 2
46663: DOUBLE
46664: EQUAL
46665: IFTRUE 46675
46667: LD_INT 3
46669: DOUBLE
46670: EQUAL
46671: IFTRUE 46675
46673: GO 46731
46675: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46676: LD_ADDR_VAR 0 9
46680: PUSH
46681: LD_VAR 0 29
46685: PUSH
46686: LD_VAR 0 30
46690: PUSH
46691: LD_VAR 0 31
46695: PUSH
46696: LD_VAR 0 32
46700: PUSH
46701: LD_VAR 0 33
46705: PUSH
46706: LD_VAR 0 34
46710: PUSH
46711: EMPTY
46712: LIST
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: PUSH
46719: LD_VAR 0 4
46723: PUSH
46724: LD_INT 1
46726: PLUS
46727: ARRAY
46728: ST_TO_ADDR
46729: GO 47214
46731: LD_INT 16
46733: DOUBLE
46734: EQUAL
46735: IFTRUE 46793
46737: LD_INT 17
46739: DOUBLE
46740: EQUAL
46741: IFTRUE 46793
46743: LD_INT 18
46745: DOUBLE
46746: EQUAL
46747: IFTRUE 46793
46749: LD_INT 19
46751: DOUBLE
46752: EQUAL
46753: IFTRUE 46793
46755: LD_INT 22
46757: DOUBLE
46758: EQUAL
46759: IFTRUE 46793
46761: LD_INT 20
46763: DOUBLE
46764: EQUAL
46765: IFTRUE 46793
46767: LD_INT 21
46769: DOUBLE
46770: EQUAL
46771: IFTRUE 46793
46773: LD_INT 23
46775: DOUBLE
46776: EQUAL
46777: IFTRUE 46793
46779: LD_INT 24
46781: DOUBLE
46782: EQUAL
46783: IFTRUE 46793
46785: LD_INT 25
46787: DOUBLE
46788: EQUAL
46789: IFTRUE 46793
46791: GO 46849
46793: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46794: LD_ADDR_VAR 0 9
46798: PUSH
46799: LD_VAR 0 35
46803: PUSH
46804: LD_VAR 0 36
46808: PUSH
46809: LD_VAR 0 37
46813: PUSH
46814: LD_VAR 0 38
46818: PUSH
46819: LD_VAR 0 39
46823: PUSH
46824: LD_VAR 0 40
46828: PUSH
46829: EMPTY
46830: LIST
46831: LIST
46832: LIST
46833: LIST
46834: LIST
46835: LIST
46836: PUSH
46837: LD_VAR 0 4
46841: PUSH
46842: LD_INT 1
46844: PLUS
46845: ARRAY
46846: ST_TO_ADDR
46847: GO 47214
46849: LD_INT 6
46851: DOUBLE
46852: EQUAL
46853: IFTRUE 46905
46855: LD_INT 7
46857: DOUBLE
46858: EQUAL
46859: IFTRUE 46905
46861: LD_INT 8
46863: DOUBLE
46864: EQUAL
46865: IFTRUE 46905
46867: LD_INT 13
46869: DOUBLE
46870: EQUAL
46871: IFTRUE 46905
46873: LD_INT 12
46875: DOUBLE
46876: EQUAL
46877: IFTRUE 46905
46879: LD_INT 15
46881: DOUBLE
46882: EQUAL
46883: IFTRUE 46905
46885: LD_INT 11
46887: DOUBLE
46888: EQUAL
46889: IFTRUE 46905
46891: LD_INT 14
46893: DOUBLE
46894: EQUAL
46895: IFTRUE 46905
46897: LD_INT 10
46899: DOUBLE
46900: EQUAL
46901: IFTRUE 46905
46903: GO 46961
46905: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46906: LD_ADDR_VAR 0 9
46910: PUSH
46911: LD_VAR 0 41
46915: PUSH
46916: LD_VAR 0 42
46920: PUSH
46921: LD_VAR 0 43
46925: PUSH
46926: LD_VAR 0 44
46930: PUSH
46931: LD_VAR 0 45
46935: PUSH
46936: LD_VAR 0 46
46940: PUSH
46941: EMPTY
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: PUSH
46949: LD_VAR 0 4
46953: PUSH
46954: LD_INT 1
46956: PLUS
46957: ARRAY
46958: ST_TO_ADDR
46959: GO 47214
46961: LD_INT 36
46963: DOUBLE
46964: EQUAL
46965: IFTRUE 46969
46967: GO 47025
46969: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46970: LD_ADDR_VAR 0 9
46974: PUSH
46975: LD_VAR 0 47
46979: PUSH
46980: LD_VAR 0 48
46984: PUSH
46985: LD_VAR 0 49
46989: PUSH
46990: LD_VAR 0 50
46994: PUSH
46995: LD_VAR 0 51
46999: PUSH
47000: LD_VAR 0 52
47004: PUSH
47005: EMPTY
47006: LIST
47007: LIST
47008: LIST
47009: LIST
47010: LIST
47011: LIST
47012: PUSH
47013: LD_VAR 0 4
47017: PUSH
47018: LD_INT 1
47020: PLUS
47021: ARRAY
47022: ST_TO_ADDR
47023: GO 47214
47025: LD_INT 4
47027: DOUBLE
47028: EQUAL
47029: IFTRUE 47051
47031: LD_INT 5
47033: DOUBLE
47034: EQUAL
47035: IFTRUE 47051
47037: LD_INT 34
47039: DOUBLE
47040: EQUAL
47041: IFTRUE 47051
47043: LD_INT 37
47045: DOUBLE
47046: EQUAL
47047: IFTRUE 47051
47049: GO 47107
47051: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47052: LD_ADDR_VAR 0 9
47056: PUSH
47057: LD_VAR 0 53
47061: PUSH
47062: LD_VAR 0 54
47066: PUSH
47067: LD_VAR 0 55
47071: PUSH
47072: LD_VAR 0 56
47076: PUSH
47077: LD_VAR 0 57
47081: PUSH
47082: LD_VAR 0 58
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: PUSH
47095: LD_VAR 0 4
47099: PUSH
47100: LD_INT 1
47102: PLUS
47103: ARRAY
47104: ST_TO_ADDR
47105: GO 47214
47107: LD_INT 31
47109: DOUBLE
47110: EQUAL
47111: IFTRUE 47157
47113: LD_INT 32
47115: DOUBLE
47116: EQUAL
47117: IFTRUE 47157
47119: LD_INT 33
47121: DOUBLE
47122: EQUAL
47123: IFTRUE 47157
47125: LD_INT 27
47127: DOUBLE
47128: EQUAL
47129: IFTRUE 47157
47131: LD_INT 26
47133: DOUBLE
47134: EQUAL
47135: IFTRUE 47157
47137: LD_INT 28
47139: DOUBLE
47140: EQUAL
47141: IFTRUE 47157
47143: LD_INT 29
47145: DOUBLE
47146: EQUAL
47147: IFTRUE 47157
47149: LD_INT 30
47151: DOUBLE
47152: EQUAL
47153: IFTRUE 47157
47155: GO 47213
47157: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47158: LD_ADDR_VAR 0 9
47162: PUSH
47163: LD_VAR 0 59
47167: PUSH
47168: LD_VAR 0 60
47172: PUSH
47173: LD_VAR 0 61
47177: PUSH
47178: LD_VAR 0 62
47182: PUSH
47183: LD_VAR 0 63
47187: PUSH
47188: LD_VAR 0 64
47192: PUSH
47193: EMPTY
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: PUSH
47201: LD_VAR 0 4
47205: PUSH
47206: LD_INT 1
47208: PLUS
47209: ARRAY
47210: ST_TO_ADDR
47211: GO 47214
47213: POP
// temp_list2 = [ ] ;
47214: LD_ADDR_VAR 0 10
47218: PUSH
47219: EMPTY
47220: ST_TO_ADDR
// for i in temp_list do
47221: LD_ADDR_VAR 0 8
47225: PUSH
47226: LD_VAR 0 9
47230: PUSH
47231: FOR_IN
47232: IFFALSE 47284
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47234: LD_ADDR_VAR 0 10
47238: PUSH
47239: LD_VAR 0 10
47243: PUSH
47244: LD_VAR 0 8
47248: PUSH
47249: LD_INT 1
47251: ARRAY
47252: PUSH
47253: LD_VAR 0 2
47257: PLUS
47258: PUSH
47259: LD_VAR 0 8
47263: PUSH
47264: LD_INT 2
47266: ARRAY
47267: PUSH
47268: LD_VAR 0 3
47272: PLUS
47273: PUSH
47274: EMPTY
47275: LIST
47276: LIST
47277: PUSH
47278: EMPTY
47279: LIST
47280: ADD
47281: ST_TO_ADDR
47282: GO 47231
47284: POP
47285: POP
// result = temp_list2 ;
47286: LD_ADDR_VAR 0 7
47290: PUSH
47291: LD_VAR 0 10
47295: ST_TO_ADDR
// end ;
47296: LD_VAR 0 7
47300: RET
// export function EnemyInRange ( unit , dist ) ; begin
47301: LD_INT 0
47303: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47304: LD_ADDR_VAR 0 3
47308: PUSH
47309: LD_VAR 0 1
47313: PPUSH
47314: CALL_OW 255
47318: PPUSH
47319: LD_VAR 0 1
47323: PPUSH
47324: CALL_OW 250
47328: PPUSH
47329: LD_VAR 0 1
47333: PPUSH
47334: CALL_OW 251
47338: PPUSH
47339: LD_VAR 0 2
47343: PPUSH
47344: CALL 20697 0 4
47348: PUSH
47349: LD_INT 4
47351: ARRAY
47352: ST_TO_ADDR
// end ;
47353: LD_VAR 0 3
47357: RET
// export function PlayerSeeMe ( unit ) ; begin
47358: LD_INT 0
47360: PPUSH
// result := See ( your_side , unit ) ;
47361: LD_ADDR_VAR 0 2
47365: PUSH
47366: LD_OWVAR 2
47370: PPUSH
47371: LD_VAR 0 1
47375: PPUSH
47376: CALL_OW 292
47380: ST_TO_ADDR
// end ;
47381: LD_VAR 0 2
47385: RET
// export function ReverseDir ( unit ) ; begin
47386: LD_INT 0
47388: PPUSH
// if not unit then
47389: LD_VAR 0 1
47393: NOT
47394: IFFALSE 47398
// exit ;
47396: GO 47421
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47398: LD_ADDR_VAR 0 2
47402: PUSH
47403: LD_VAR 0 1
47407: PPUSH
47408: CALL_OW 254
47412: PUSH
47413: LD_INT 3
47415: PLUS
47416: PUSH
47417: LD_INT 6
47419: MOD
47420: ST_TO_ADDR
// end ;
47421: LD_VAR 0 2
47425: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47426: LD_INT 0
47428: PPUSH
47429: PPUSH
47430: PPUSH
47431: PPUSH
47432: PPUSH
// if not hexes then
47433: LD_VAR 0 2
47437: NOT
47438: IFFALSE 47442
// exit ;
47440: GO 47590
// dist := 9999 ;
47442: LD_ADDR_VAR 0 5
47446: PUSH
47447: LD_INT 9999
47449: ST_TO_ADDR
// for i = 1 to hexes do
47450: LD_ADDR_VAR 0 4
47454: PUSH
47455: DOUBLE
47456: LD_INT 1
47458: DEC
47459: ST_TO_ADDR
47460: LD_VAR 0 2
47464: PUSH
47465: FOR_TO
47466: IFFALSE 47578
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47468: LD_VAR 0 1
47472: PPUSH
47473: LD_VAR 0 2
47477: PUSH
47478: LD_VAR 0 4
47482: ARRAY
47483: PUSH
47484: LD_INT 1
47486: ARRAY
47487: PPUSH
47488: LD_VAR 0 2
47492: PUSH
47493: LD_VAR 0 4
47497: ARRAY
47498: PUSH
47499: LD_INT 2
47501: ARRAY
47502: PPUSH
47503: CALL_OW 297
47507: PUSH
47508: LD_VAR 0 5
47512: LESS
47513: IFFALSE 47576
// begin hex := hexes [ i ] ;
47515: LD_ADDR_VAR 0 7
47519: PUSH
47520: LD_VAR 0 2
47524: PUSH
47525: LD_VAR 0 4
47529: ARRAY
47530: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47531: LD_ADDR_VAR 0 5
47535: PUSH
47536: LD_VAR 0 1
47540: PPUSH
47541: LD_VAR 0 2
47545: PUSH
47546: LD_VAR 0 4
47550: ARRAY
47551: PUSH
47552: LD_INT 1
47554: ARRAY
47555: PPUSH
47556: LD_VAR 0 2
47560: PUSH
47561: LD_VAR 0 4
47565: ARRAY
47566: PUSH
47567: LD_INT 2
47569: ARRAY
47570: PPUSH
47571: CALL_OW 297
47575: ST_TO_ADDR
// end ; end ;
47576: GO 47465
47578: POP
47579: POP
// result := hex ;
47580: LD_ADDR_VAR 0 3
47584: PUSH
47585: LD_VAR 0 7
47589: ST_TO_ADDR
// end ;
47590: LD_VAR 0 3
47594: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47595: LD_INT 0
47597: PPUSH
47598: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47599: LD_VAR 0 1
47603: NOT
47604: PUSH
47605: LD_VAR 0 1
47609: PUSH
47610: LD_INT 21
47612: PUSH
47613: LD_INT 2
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 23
47622: PUSH
47623: LD_INT 2
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PPUSH
47634: CALL_OW 69
47638: IN
47639: NOT
47640: OR
47641: IFFALSE 47645
// exit ;
47643: GO 47692
// for i = 1 to 3 do
47645: LD_ADDR_VAR 0 3
47649: PUSH
47650: DOUBLE
47651: LD_INT 1
47653: DEC
47654: ST_TO_ADDR
47655: LD_INT 3
47657: PUSH
47658: FOR_TO
47659: IFFALSE 47690
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47661: LD_VAR 0 1
47665: PPUSH
47666: CALL_OW 250
47670: PPUSH
47671: LD_VAR 0 1
47675: PPUSH
47676: CALL_OW 251
47680: PPUSH
47681: LD_INT 1
47683: PPUSH
47684: CALL_OW 453
47688: GO 47658
47690: POP
47691: POP
// end ;
47692: LD_VAR 0 2
47696: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47697: LD_INT 0
47699: PPUSH
47700: PPUSH
47701: PPUSH
47702: PPUSH
47703: PPUSH
47704: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47705: LD_VAR 0 1
47709: NOT
47710: PUSH
47711: LD_VAR 0 2
47715: NOT
47716: OR
47717: PUSH
47718: LD_VAR 0 1
47722: PPUSH
47723: CALL_OW 314
47727: OR
47728: IFFALSE 47732
// exit ;
47730: GO 48173
// x := GetX ( enemy_unit ) ;
47732: LD_ADDR_VAR 0 7
47736: PUSH
47737: LD_VAR 0 2
47741: PPUSH
47742: CALL_OW 250
47746: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47747: LD_ADDR_VAR 0 8
47751: PUSH
47752: LD_VAR 0 2
47756: PPUSH
47757: CALL_OW 251
47761: ST_TO_ADDR
// if not x or not y then
47762: LD_VAR 0 7
47766: NOT
47767: PUSH
47768: LD_VAR 0 8
47772: NOT
47773: OR
47774: IFFALSE 47778
// exit ;
47776: GO 48173
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47778: LD_ADDR_VAR 0 6
47782: PUSH
47783: LD_VAR 0 7
47787: PPUSH
47788: LD_INT 0
47790: PPUSH
47791: LD_INT 4
47793: PPUSH
47794: CALL_OW 272
47798: PUSH
47799: LD_VAR 0 8
47803: PPUSH
47804: LD_INT 0
47806: PPUSH
47807: LD_INT 4
47809: PPUSH
47810: CALL_OW 273
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_VAR 0 7
47823: PPUSH
47824: LD_INT 1
47826: PPUSH
47827: LD_INT 4
47829: PPUSH
47830: CALL_OW 272
47834: PUSH
47835: LD_VAR 0 8
47839: PPUSH
47840: LD_INT 1
47842: PPUSH
47843: LD_INT 4
47845: PPUSH
47846: CALL_OW 273
47850: PUSH
47851: EMPTY
47852: LIST
47853: LIST
47854: PUSH
47855: LD_VAR 0 7
47859: PPUSH
47860: LD_INT 2
47862: PPUSH
47863: LD_INT 4
47865: PPUSH
47866: CALL_OW 272
47870: PUSH
47871: LD_VAR 0 8
47875: PPUSH
47876: LD_INT 2
47878: PPUSH
47879: LD_INT 4
47881: PPUSH
47882: CALL_OW 273
47886: PUSH
47887: EMPTY
47888: LIST
47889: LIST
47890: PUSH
47891: LD_VAR 0 7
47895: PPUSH
47896: LD_INT 3
47898: PPUSH
47899: LD_INT 4
47901: PPUSH
47902: CALL_OW 272
47906: PUSH
47907: LD_VAR 0 8
47911: PPUSH
47912: LD_INT 3
47914: PPUSH
47915: LD_INT 4
47917: PPUSH
47918: CALL_OW 273
47922: PUSH
47923: EMPTY
47924: LIST
47925: LIST
47926: PUSH
47927: LD_VAR 0 7
47931: PPUSH
47932: LD_INT 4
47934: PPUSH
47935: LD_INT 4
47937: PPUSH
47938: CALL_OW 272
47942: PUSH
47943: LD_VAR 0 8
47947: PPUSH
47948: LD_INT 4
47950: PPUSH
47951: LD_INT 4
47953: PPUSH
47954: CALL_OW 273
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: LD_VAR 0 7
47967: PPUSH
47968: LD_INT 5
47970: PPUSH
47971: LD_INT 4
47973: PPUSH
47974: CALL_OW 272
47978: PUSH
47979: LD_VAR 0 8
47983: PPUSH
47984: LD_INT 5
47986: PPUSH
47987: LD_INT 4
47989: PPUSH
47990: CALL_OW 273
47994: PUSH
47995: EMPTY
47996: LIST
47997: LIST
47998: PUSH
47999: EMPTY
48000: LIST
48001: LIST
48002: LIST
48003: LIST
48004: LIST
48005: LIST
48006: ST_TO_ADDR
// for i = tmp downto 1 do
48007: LD_ADDR_VAR 0 4
48011: PUSH
48012: DOUBLE
48013: LD_VAR 0 6
48017: INC
48018: ST_TO_ADDR
48019: LD_INT 1
48021: PUSH
48022: FOR_DOWNTO
48023: IFFALSE 48124
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48025: LD_VAR 0 6
48029: PUSH
48030: LD_VAR 0 4
48034: ARRAY
48035: PUSH
48036: LD_INT 1
48038: ARRAY
48039: PPUSH
48040: LD_VAR 0 6
48044: PUSH
48045: LD_VAR 0 4
48049: ARRAY
48050: PUSH
48051: LD_INT 2
48053: ARRAY
48054: PPUSH
48055: CALL_OW 488
48059: NOT
48060: PUSH
48061: LD_VAR 0 6
48065: PUSH
48066: LD_VAR 0 4
48070: ARRAY
48071: PUSH
48072: LD_INT 1
48074: ARRAY
48075: PPUSH
48076: LD_VAR 0 6
48080: PUSH
48081: LD_VAR 0 4
48085: ARRAY
48086: PUSH
48087: LD_INT 2
48089: ARRAY
48090: PPUSH
48091: CALL_OW 428
48095: PUSH
48096: LD_INT 0
48098: NONEQUAL
48099: OR
48100: IFFALSE 48122
// tmp := Delete ( tmp , i ) ;
48102: LD_ADDR_VAR 0 6
48106: PUSH
48107: LD_VAR 0 6
48111: PPUSH
48112: LD_VAR 0 4
48116: PPUSH
48117: CALL_OW 3
48121: ST_TO_ADDR
48122: GO 48022
48124: POP
48125: POP
// j := GetClosestHex ( unit , tmp ) ;
48126: LD_ADDR_VAR 0 5
48130: PUSH
48131: LD_VAR 0 1
48135: PPUSH
48136: LD_VAR 0 6
48140: PPUSH
48141: CALL 47426 0 2
48145: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48146: LD_VAR 0 1
48150: PPUSH
48151: LD_VAR 0 5
48155: PUSH
48156: LD_INT 1
48158: ARRAY
48159: PPUSH
48160: LD_VAR 0 5
48164: PUSH
48165: LD_INT 2
48167: ARRAY
48168: PPUSH
48169: CALL_OW 111
// end ;
48173: LD_VAR 0 3
48177: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48178: LD_INT 0
48180: PPUSH
48181: PPUSH
48182: PPUSH
// uc_side = 0 ;
48183: LD_ADDR_OWVAR 20
48187: PUSH
48188: LD_INT 0
48190: ST_TO_ADDR
// uc_nation = 0 ;
48191: LD_ADDR_OWVAR 21
48195: PUSH
48196: LD_INT 0
48198: ST_TO_ADDR
// InitHc_All ( ) ;
48199: CALL_OW 584
// InitVc ;
48203: CALL_OW 20
// if mastodonts then
48207: LD_VAR 0 6
48211: IFFALSE 48278
// for i = 1 to mastodonts do
48213: LD_ADDR_VAR 0 11
48217: PUSH
48218: DOUBLE
48219: LD_INT 1
48221: DEC
48222: ST_TO_ADDR
48223: LD_VAR 0 6
48227: PUSH
48228: FOR_TO
48229: IFFALSE 48276
// begin vc_chassis := 31 ;
48231: LD_ADDR_OWVAR 37
48235: PUSH
48236: LD_INT 31
48238: ST_TO_ADDR
// vc_control := control_rider ;
48239: LD_ADDR_OWVAR 38
48243: PUSH
48244: LD_INT 4
48246: ST_TO_ADDR
// animal := CreateVehicle ;
48247: LD_ADDR_VAR 0 12
48251: PUSH
48252: CALL_OW 45
48256: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48257: LD_VAR 0 12
48261: PPUSH
48262: LD_VAR 0 8
48266: PPUSH
48267: LD_INT 0
48269: PPUSH
48270: CALL 50466 0 3
// end ;
48274: GO 48228
48276: POP
48277: POP
// if horses then
48278: LD_VAR 0 5
48282: IFFALSE 48349
// for i = 1 to horses do
48284: LD_ADDR_VAR 0 11
48288: PUSH
48289: DOUBLE
48290: LD_INT 1
48292: DEC
48293: ST_TO_ADDR
48294: LD_VAR 0 5
48298: PUSH
48299: FOR_TO
48300: IFFALSE 48347
// begin hc_class := 21 ;
48302: LD_ADDR_OWVAR 28
48306: PUSH
48307: LD_INT 21
48309: ST_TO_ADDR
// hc_gallery :=  ;
48310: LD_ADDR_OWVAR 33
48314: PUSH
48315: LD_STRING 
48317: ST_TO_ADDR
// animal := CreateHuman ;
48318: LD_ADDR_VAR 0 12
48322: PUSH
48323: CALL_OW 44
48327: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48328: LD_VAR 0 12
48332: PPUSH
48333: LD_VAR 0 8
48337: PPUSH
48338: LD_INT 0
48340: PPUSH
48341: CALL 50466 0 3
// end ;
48345: GO 48299
48347: POP
48348: POP
// if birds then
48349: LD_VAR 0 1
48353: IFFALSE 48420
// for i = 1 to birds do
48355: LD_ADDR_VAR 0 11
48359: PUSH
48360: DOUBLE
48361: LD_INT 1
48363: DEC
48364: ST_TO_ADDR
48365: LD_VAR 0 1
48369: PUSH
48370: FOR_TO
48371: IFFALSE 48418
// begin hc_class = 18 ;
48373: LD_ADDR_OWVAR 28
48377: PUSH
48378: LD_INT 18
48380: ST_TO_ADDR
// hc_gallery =  ;
48381: LD_ADDR_OWVAR 33
48385: PUSH
48386: LD_STRING 
48388: ST_TO_ADDR
// animal := CreateHuman ;
48389: LD_ADDR_VAR 0 12
48393: PUSH
48394: CALL_OW 44
48398: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48399: LD_VAR 0 12
48403: PPUSH
48404: LD_VAR 0 8
48408: PPUSH
48409: LD_INT 0
48411: PPUSH
48412: CALL 50466 0 3
// end ;
48416: GO 48370
48418: POP
48419: POP
// if tigers then
48420: LD_VAR 0 2
48424: IFFALSE 48508
// for i = 1 to tigers do
48426: LD_ADDR_VAR 0 11
48430: PUSH
48431: DOUBLE
48432: LD_INT 1
48434: DEC
48435: ST_TO_ADDR
48436: LD_VAR 0 2
48440: PUSH
48441: FOR_TO
48442: IFFALSE 48506
// begin hc_class = class_tiger ;
48444: LD_ADDR_OWVAR 28
48448: PUSH
48449: LD_INT 14
48451: ST_TO_ADDR
// hc_gallery =  ;
48452: LD_ADDR_OWVAR 33
48456: PUSH
48457: LD_STRING 
48459: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48460: LD_ADDR_OWVAR 35
48464: PUSH
48465: LD_INT 7
48467: NEG
48468: PPUSH
48469: LD_INT 7
48471: PPUSH
48472: CALL_OW 12
48476: ST_TO_ADDR
// animal := CreateHuman ;
48477: LD_ADDR_VAR 0 12
48481: PUSH
48482: CALL_OW 44
48486: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48487: LD_VAR 0 12
48491: PPUSH
48492: LD_VAR 0 8
48496: PPUSH
48497: LD_INT 0
48499: PPUSH
48500: CALL 50466 0 3
// end ;
48504: GO 48441
48506: POP
48507: POP
// if apemans then
48508: LD_VAR 0 3
48512: IFFALSE 48635
// for i = 1 to apemans do
48514: LD_ADDR_VAR 0 11
48518: PUSH
48519: DOUBLE
48520: LD_INT 1
48522: DEC
48523: ST_TO_ADDR
48524: LD_VAR 0 3
48528: PUSH
48529: FOR_TO
48530: IFFALSE 48633
// begin hc_class = class_apeman ;
48532: LD_ADDR_OWVAR 28
48536: PUSH
48537: LD_INT 12
48539: ST_TO_ADDR
// hc_gallery =  ;
48540: LD_ADDR_OWVAR 33
48544: PUSH
48545: LD_STRING 
48547: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
48548: LD_ADDR_OWVAR 35
48552: PUSH
48553: LD_INT 2
48555: NEG
48556: PPUSH
48557: LD_INT 2
48559: PPUSH
48560: CALL_OW 12
48564: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48565: LD_ADDR_OWVAR 31
48569: PUSH
48570: LD_INT 1
48572: PPUSH
48573: LD_INT 3
48575: PPUSH
48576: CALL_OW 12
48580: PUSH
48581: LD_INT 1
48583: PPUSH
48584: LD_INT 3
48586: PPUSH
48587: CALL_OW 12
48591: PUSH
48592: LD_INT 0
48594: PUSH
48595: LD_INT 0
48597: PUSH
48598: EMPTY
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: ST_TO_ADDR
// animal := CreateHuman ;
48604: LD_ADDR_VAR 0 12
48608: PUSH
48609: CALL_OW 44
48613: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48614: LD_VAR 0 12
48618: PPUSH
48619: LD_VAR 0 8
48623: PPUSH
48624: LD_INT 0
48626: PPUSH
48627: CALL 50466 0 3
// end ;
48631: GO 48529
48633: POP
48634: POP
// if enchidnas then
48635: LD_VAR 0 4
48639: IFFALSE 48706
// for i = 1 to enchidnas do
48641: LD_ADDR_VAR 0 11
48645: PUSH
48646: DOUBLE
48647: LD_INT 1
48649: DEC
48650: ST_TO_ADDR
48651: LD_VAR 0 4
48655: PUSH
48656: FOR_TO
48657: IFFALSE 48704
// begin hc_class = 13 ;
48659: LD_ADDR_OWVAR 28
48663: PUSH
48664: LD_INT 13
48666: ST_TO_ADDR
// hc_gallery =  ;
48667: LD_ADDR_OWVAR 33
48671: PUSH
48672: LD_STRING 
48674: ST_TO_ADDR
// animal := CreateHuman ;
48675: LD_ADDR_VAR 0 12
48679: PUSH
48680: CALL_OW 44
48684: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48685: LD_VAR 0 12
48689: PPUSH
48690: LD_VAR 0 8
48694: PPUSH
48695: LD_INT 0
48697: PPUSH
48698: CALL 50466 0 3
// end ;
48702: GO 48656
48704: POP
48705: POP
// if fishes then
48706: LD_VAR 0 7
48710: IFFALSE 48777
// for i = 1 to fishes do
48712: LD_ADDR_VAR 0 11
48716: PUSH
48717: DOUBLE
48718: LD_INT 1
48720: DEC
48721: ST_TO_ADDR
48722: LD_VAR 0 7
48726: PUSH
48727: FOR_TO
48728: IFFALSE 48775
// begin hc_class = 20 ;
48730: LD_ADDR_OWVAR 28
48734: PUSH
48735: LD_INT 20
48737: ST_TO_ADDR
// hc_gallery =  ;
48738: LD_ADDR_OWVAR 33
48742: PUSH
48743: LD_STRING 
48745: ST_TO_ADDR
// animal := CreateHuman ;
48746: LD_ADDR_VAR 0 12
48750: PUSH
48751: CALL_OW 44
48755: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48756: LD_VAR 0 12
48760: PPUSH
48761: LD_VAR 0 9
48765: PPUSH
48766: LD_INT 0
48768: PPUSH
48769: CALL 50466 0 3
// end ;
48773: GO 48727
48775: POP
48776: POP
// end ;
48777: LD_VAR 0 10
48781: RET
// export function WantHeal ( sci , unit ) ; begin
48782: LD_INT 0
48784: PPUSH
// if GetTaskList ( sci ) > 0 then
48785: LD_VAR 0 1
48789: PPUSH
48790: CALL_OW 437
48794: PUSH
48795: LD_INT 0
48797: GREATER
48798: IFFALSE 48868
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48800: LD_VAR 0 1
48804: PPUSH
48805: CALL_OW 437
48809: PUSH
48810: LD_INT 1
48812: ARRAY
48813: PUSH
48814: LD_INT 1
48816: ARRAY
48817: PUSH
48818: LD_STRING l
48820: EQUAL
48821: PUSH
48822: LD_VAR 0 1
48826: PPUSH
48827: CALL_OW 437
48831: PUSH
48832: LD_INT 1
48834: ARRAY
48835: PUSH
48836: LD_INT 4
48838: ARRAY
48839: PUSH
48840: LD_VAR 0 2
48844: EQUAL
48845: AND
48846: IFFALSE 48858
// result := true else
48848: LD_ADDR_VAR 0 3
48852: PUSH
48853: LD_INT 1
48855: ST_TO_ADDR
48856: GO 48866
// result := false ;
48858: LD_ADDR_VAR 0 3
48862: PUSH
48863: LD_INT 0
48865: ST_TO_ADDR
// end else
48866: GO 48876
// result := false ;
48868: LD_ADDR_VAR 0 3
48872: PUSH
48873: LD_INT 0
48875: ST_TO_ADDR
// end ;
48876: LD_VAR 0 3
48880: RET
// export function HealTarget ( sci ) ; begin
48881: LD_INT 0
48883: PPUSH
// if not sci then
48884: LD_VAR 0 1
48888: NOT
48889: IFFALSE 48893
// exit ;
48891: GO 48958
// result := 0 ;
48893: LD_ADDR_VAR 0 2
48897: PUSH
48898: LD_INT 0
48900: ST_TO_ADDR
// if GetTaskList ( sci ) then
48901: LD_VAR 0 1
48905: PPUSH
48906: CALL_OW 437
48910: IFFALSE 48958
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48912: LD_VAR 0 1
48916: PPUSH
48917: CALL_OW 437
48921: PUSH
48922: LD_INT 1
48924: ARRAY
48925: PUSH
48926: LD_INT 1
48928: ARRAY
48929: PUSH
48930: LD_STRING l
48932: EQUAL
48933: IFFALSE 48958
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48935: LD_ADDR_VAR 0 2
48939: PUSH
48940: LD_VAR 0 1
48944: PPUSH
48945: CALL_OW 437
48949: PUSH
48950: LD_INT 1
48952: ARRAY
48953: PUSH
48954: LD_INT 4
48956: ARRAY
48957: ST_TO_ADDR
// end ;
48958: LD_VAR 0 2
48962: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48963: LD_INT 0
48965: PPUSH
48966: PPUSH
48967: PPUSH
48968: PPUSH
// if not base_units then
48969: LD_VAR 0 1
48973: NOT
48974: IFFALSE 48978
// exit ;
48976: GO 49065
// result := false ;
48978: LD_ADDR_VAR 0 2
48982: PUSH
48983: LD_INT 0
48985: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48986: LD_ADDR_VAR 0 5
48990: PUSH
48991: LD_VAR 0 1
48995: PPUSH
48996: LD_INT 21
48998: PUSH
48999: LD_INT 3
49001: PUSH
49002: EMPTY
49003: LIST
49004: LIST
49005: PPUSH
49006: CALL_OW 72
49010: ST_TO_ADDR
// if not tmp then
49011: LD_VAR 0 5
49015: NOT
49016: IFFALSE 49020
// exit ;
49018: GO 49065
// for i in tmp do
49020: LD_ADDR_VAR 0 3
49024: PUSH
49025: LD_VAR 0 5
49029: PUSH
49030: FOR_IN
49031: IFFALSE 49063
// begin result := EnemyInRange ( i , 22 ) ;
49033: LD_ADDR_VAR 0 2
49037: PUSH
49038: LD_VAR 0 3
49042: PPUSH
49043: LD_INT 22
49045: PPUSH
49046: CALL 47301 0 2
49050: ST_TO_ADDR
// if result then
49051: LD_VAR 0 2
49055: IFFALSE 49061
// exit ;
49057: POP
49058: POP
49059: GO 49065
// end ;
49061: GO 49030
49063: POP
49064: POP
// end ;
49065: LD_VAR 0 2
49069: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
49070: LD_INT 0
49072: PPUSH
49073: PPUSH
// if not units then
49074: LD_VAR 0 1
49078: NOT
49079: IFFALSE 49083
// exit ;
49081: GO 49153
// result := [ ] ;
49083: LD_ADDR_VAR 0 3
49087: PUSH
49088: EMPTY
49089: ST_TO_ADDR
// for i in units do
49090: LD_ADDR_VAR 0 4
49094: PUSH
49095: LD_VAR 0 1
49099: PUSH
49100: FOR_IN
49101: IFFALSE 49151
// if GetTag ( i ) = tag then
49103: LD_VAR 0 4
49107: PPUSH
49108: CALL_OW 110
49112: PUSH
49113: LD_VAR 0 2
49117: EQUAL
49118: IFFALSE 49149
// result := Replace ( result , result + 1 , i ) ;
49120: LD_ADDR_VAR 0 3
49124: PUSH
49125: LD_VAR 0 3
49129: PPUSH
49130: LD_VAR 0 3
49134: PUSH
49135: LD_INT 1
49137: PLUS
49138: PPUSH
49139: LD_VAR 0 4
49143: PPUSH
49144: CALL_OW 1
49148: ST_TO_ADDR
49149: GO 49100
49151: POP
49152: POP
// end ;
49153: LD_VAR 0 3
49157: RET
// export function IsDriver ( un ) ; begin
49158: LD_INT 0
49160: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49161: LD_ADDR_VAR 0 2
49165: PUSH
49166: LD_VAR 0 1
49170: PUSH
49171: LD_INT 55
49173: PUSH
49174: EMPTY
49175: LIST
49176: PPUSH
49177: CALL_OW 69
49181: IN
49182: ST_TO_ADDR
// end ;
49183: LD_VAR 0 2
49187: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49188: LD_INT 0
49190: PPUSH
49191: PPUSH
// list := [ ] ;
49192: LD_ADDR_VAR 0 5
49196: PUSH
49197: EMPTY
49198: ST_TO_ADDR
// case d of 0 :
49199: LD_VAR 0 3
49203: PUSH
49204: LD_INT 0
49206: DOUBLE
49207: EQUAL
49208: IFTRUE 49212
49210: GO 49345
49212: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49213: LD_ADDR_VAR 0 5
49217: PUSH
49218: LD_VAR 0 1
49222: PUSH
49223: LD_INT 4
49225: MINUS
49226: PUSH
49227: LD_VAR 0 2
49231: PUSH
49232: LD_INT 4
49234: MINUS
49235: PUSH
49236: LD_INT 2
49238: PUSH
49239: EMPTY
49240: LIST
49241: LIST
49242: LIST
49243: PUSH
49244: LD_VAR 0 1
49248: PUSH
49249: LD_INT 3
49251: MINUS
49252: PUSH
49253: LD_VAR 0 2
49257: PUSH
49258: LD_INT 1
49260: PUSH
49261: EMPTY
49262: LIST
49263: LIST
49264: LIST
49265: PUSH
49266: LD_VAR 0 1
49270: PUSH
49271: LD_INT 4
49273: PLUS
49274: PUSH
49275: LD_VAR 0 2
49279: PUSH
49280: LD_INT 4
49282: PUSH
49283: EMPTY
49284: LIST
49285: LIST
49286: LIST
49287: PUSH
49288: LD_VAR 0 1
49292: PUSH
49293: LD_INT 3
49295: PLUS
49296: PUSH
49297: LD_VAR 0 2
49301: PUSH
49302: LD_INT 3
49304: PLUS
49305: PUSH
49306: LD_INT 5
49308: PUSH
49309: EMPTY
49310: LIST
49311: LIST
49312: LIST
49313: PUSH
49314: LD_VAR 0 1
49318: PUSH
49319: LD_VAR 0 2
49323: PUSH
49324: LD_INT 4
49326: PLUS
49327: PUSH
49328: LD_INT 0
49330: PUSH
49331: EMPTY
49332: LIST
49333: LIST
49334: LIST
49335: PUSH
49336: EMPTY
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: ST_TO_ADDR
// end ; 1 :
49343: GO 50043
49345: LD_INT 1
49347: DOUBLE
49348: EQUAL
49349: IFTRUE 49353
49351: GO 49486
49353: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
49354: LD_ADDR_VAR 0 5
49358: PUSH
49359: LD_VAR 0 1
49363: PUSH
49364: LD_VAR 0 2
49368: PUSH
49369: LD_INT 4
49371: MINUS
49372: PUSH
49373: LD_INT 3
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: LIST
49380: PUSH
49381: LD_VAR 0 1
49385: PUSH
49386: LD_INT 3
49388: MINUS
49389: PUSH
49390: LD_VAR 0 2
49394: PUSH
49395: LD_INT 3
49397: MINUS
49398: PUSH
49399: LD_INT 2
49401: PUSH
49402: EMPTY
49403: LIST
49404: LIST
49405: LIST
49406: PUSH
49407: LD_VAR 0 1
49411: PUSH
49412: LD_INT 4
49414: MINUS
49415: PUSH
49416: LD_VAR 0 2
49420: PUSH
49421: LD_INT 1
49423: PUSH
49424: EMPTY
49425: LIST
49426: LIST
49427: LIST
49428: PUSH
49429: LD_VAR 0 1
49433: PUSH
49434: LD_VAR 0 2
49438: PUSH
49439: LD_INT 3
49441: PLUS
49442: PUSH
49443: LD_INT 0
49445: PUSH
49446: EMPTY
49447: LIST
49448: LIST
49449: LIST
49450: PUSH
49451: LD_VAR 0 1
49455: PUSH
49456: LD_INT 4
49458: PLUS
49459: PUSH
49460: LD_VAR 0 2
49464: PUSH
49465: LD_INT 4
49467: PLUS
49468: PUSH
49469: LD_INT 5
49471: PUSH
49472: EMPTY
49473: LIST
49474: LIST
49475: LIST
49476: PUSH
49477: EMPTY
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: ST_TO_ADDR
// end ; 2 :
49484: GO 50043
49486: LD_INT 2
49488: DOUBLE
49489: EQUAL
49490: IFTRUE 49494
49492: GO 49623
49494: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
49495: LD_ADDR_VAR 0 5
49499: PUSH
49500: LD_VAR 0 1
49504: PUSH
49505: LD_VAR 0 2
49509: PUSH
49510: LD_INT 3
49512: MINUS
49513: PUSH
49514: LD_INT 3
49516: PUSH
49517: EMPTY
49518: LIST
49519: LIST
49520: LIST
49521: PUSH
49522: LD_VAR 0 1
49526: PUSH
49527: LD_INT 4
49529: PLUS
49530: PUSH
49531: LD_VAR 0 2
49535: PUSH
49536: LD_INT 4
49538: PUSH
49539: EMPTY
49540: LIST
49541: LIST
49542: LIST
49543: PUSH
49544: LD_VAR 0 1
49548: PUSH
49549: LD_VAR 0 2
49553: PUSH
49554: LD_INT 4
49556: PLUS
49557: PUSH
49558: LD_INT 0
49560: PUSH
49561: EMPTY
49562: LIST
49563: LIST
49564: LIST
49565: PUSH
49566: LD_VAR 0 1
49570: PUSH
49571: LD_INT 3
49573: MINUS
49574: PUSH
49575: LD_VAR 0 2
49579: PUSH
49580: LD_INT 1
49582: PUSH
49583: EMPTY
49584: LIST
49585: LIST
49586: LIST
49587: PUSH
49588: LD_VAR 0 1
49592: PUSH
49593: LD_INT 4
49595: MINUS
49596: PUSH
49597: LD_VAR 0 2
49601: PUSH
49602: LD_INT 4
49604: MINUS
49605: PUSH
49606: LD_INT 2
49608: PUSH
49609: EMPTY
49610: LIST
49611: LIST
49612: LIST
49613: PUSH
49614: EMPTY
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: ST_TO_ADDR
// end ; 3 :
49621: GO 50043
49623: LD_INT 3
49625: DOUBLE
49626: EQUAL
49627: IFTRUE 49631
49629: GO 49764
49631: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
49632: LD_ADDR_VAR 0 5
49636: PUSH
49637: LD_VAR 0 1
49641: PUSH
49642: LD_INT 3
49644: PLUS
49645: PUSH
49646: LD_VAR 0 2
49650: PUSH
49651: LD_INT 4
49653: PUSH
49654: EMPTY
49655: LIST
49656: LIST
49657: LIST
49658: PUSH
49659: LD_VAR 0 1
49663: PUSH
49664: LD_INT 4
49666: PLUS
49667: PUSH
49668: LD_VAR 0 2
49672: PUSH
49673: LD_INT 4
49675: PLUS
49676: PUSH
49677: LD_INT 5
49679: PUSH
49680: EMPTY
49681: LIST
49682: LIST
49683: LIST
49684: PUSH
49685: LD_VAR 0 1
49689: PUSH
49690: LD_INT 4
49692: MINUS
49693: PUSH
49694: LD_VAR 0 2
49698: PUSH
49699: LD_INT 1
49701: PUSH
49702: EMPTY
49703: LIST
49704: LIST
49705: LIST
49706: PUSH
49707: LD_VAR 0 1
49711: PUSH
49712: LD_VAR 0 2
49716: PUSH
49717: LD_INT 4
49719: MINUS
49720: PUSH
49721: LD_INT 3
49723: PUSH
49724: EMPTY
49725: LIST
49726: LIST
49727: LIST
49728: PUSH
49729: LD_VAR 0 1
49733: PUSH
49734: LD_INT 3
49736: MINUS
49737: PUSH
49738: LD_VAR 0 2
49742: PUSH
49743: LD_INT 3
49745: MINUS
49746: PUSH
49747: LD_INT 2
49749: PUSH
49750: EMPTY
49751: LIST
49752: LIST
49753: LIST
49754: PUSH
49755: EMPTY
49756: LIST
49757: LIST
49758: LIST
49759: LIST
49760: LIST
49761: ST_TO_ADDR
// end ; 4 :
49762: GO 50043
49764: LD_INT 4
49766: DOUBLE
49767: EQUAL
49768: IFTRUE 49772
49770: GO 49905
49772: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
49773: LD_ADDR_VAR 0 5
49777: PUSH
49778: LD_VAR 0 1
49782: PUSH
49783: LD_VAR 0 2
49787: PUSH
49788: LD_INT 4
49790: PLUS
49791: PUSH
49792: LD_INT 0
49794: PUSH
49795: EMPTY
49796: LIST
49797: LIST
49798: LIST
49799: PUSH
49800: LD_VAR 0 1
49804: PUSH
49805: LD_INT 3
49807: PLUS
49808: PUSH
49809: LD_VAR 0 2
49813: PUSH
49814: LD_INT 3
49816: PLUS
49817: PUSH
49818: LD_INT 5
49820: PUSH
49821: EMPTY
49822: LIST
49823: LIST
49824: LIST
49825: PUSH
49826: LD_VAR 0 1
49830: PUSH
49831: LD_INT 4
49833: PLUS
49834: PUSH
49835: LD_VAR 0 2
49839: PUSH
49840: LD_INT 4
49842: PUSH
49843: EMPTY
49844: LIST
49845: LIST
49846: LIST
49847: PUSH
49848: LD_VAR 0 1
49852: PUSH
49853: LD_VAR 0 2
49857: PUSH
49858: LD_INT 3
49860: MINUS
49861: PUSH
49862: LD_INT 3
49864: PUSH
49865: EMPTY
49866: LIST
49867: LIST
49868: LIST
49869: PUSH
49870: LD_VAR 0 1
49874: PUSH
49875: LD_INT 4
49877: MINUS
49878: PUSH
49879: LD_VAR 0 2
49883: PUSH
49884: LD_INT 4
49886: MINUS
49887: PUSH
49888: LD_INT 2
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: LIST
49895: PUSH
49896: EMPTY
49897: LIST
49898: LIST
49899: LIST
49900: LIST
49901: LIST
49902: ST_TO_ADDR
// end ; 5 :
49903: GO 50043
49905: LD_INT 5
49907: DOUBLE
49908: EQUAL
49909: IFTRUE 49913
49911: GO 50042
49913: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49914: LD_ADDR_VAR 0 5
49918: PUSH
49919: LD_VAR 0 1
49923: PUSH
49924: LD_INT 4
49926: MINUS
49927: PUSH
49928: LD_VAR 0 2
49932: PUSH
49933: LD_INT 1
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: LIST
49940: PUSH
49941: LD_VAR 0 1
49945: PUSH
49946: LD_VAR 0 2
49950: PUSH
49951: LD_INT 4
49953: MINUS
49954: PUSH
49955: LD_INT 3
49957: PUSH
49958: EMPTY
49959: LIST
49960: LIST
49961: LIST
49962: PUSH
49963: LD_VAR 0 1
49967: PUSH
49968: LD_INT 4
49970: PLUS
49971: PUSH
49972: LD_VAR 0 2
49976: PUSH
49977: LD_INT 4
49979: PLUS
49980: PUSH
49981: LD_INT 5
49983: PUSH
49984: EMPTY
49985: LIST
49986: LIST
49987: LIST
49988: PUSH
49989: LD_VAR 0 1
49993: PUSH
49994: LD_INT 3
49996: PLUS
49997: PUSH
49998: LD_VAR 0 2
50002: PUSH
50003: LD_INT 4
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: LIST
50010: PUSH
50011: LD_VAR 0 1
50015: PUSH
50016: LD_VAR 0 2
50020: PUSH
50021: LD_INT 3
50023: PLUS
50024: PUSH
50025: LD_INT 0
50027: PUSH
50028: EMPTY
50029: LIST
50030: LIST
50031: LIST
50032: PUSH
50033: EMPTY
50034: LIST
50035: LIST
50036: LIST
50037: LIST
50038: LIST
50039: ST_TO_ADDR
// end ; end ;
50040: GO 50043
50042: POP
// result := list ;
50043: LD_ADDR_VAR 0 4
50047: PUSH
50048: LD_VAR 0 5
50052: ST_TO_ADDR
// end ;
50053: LD_VAR 0 4
50057: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50058: LD_INT 0
50060: PPUSH
50061: PPUSH
50062: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50063: LD_VAR 0 1
50067: NOT
50068: PUSH
50069: LD_VAR 0 2
50073: PUSH
50074: LD_INT 1
50076: PUSH
50077: LD_INT 2
50079: PUSH
50080: LD_INT 3
50082: PUSH
50083: LD_INT 4
50085: PUSH
50086: EMPTY
50087: LIST
50088: LIST
50089: LIST
50090: LIST
50091: IN
50092: NOT
50093: OR
50094: IFFALSE 50098
// exit ;
50096: GO 50190
// tmp := [ ] ;
50098: LD_ADDR_VAR 0 5
50102: PUSH
50103: EMPTY
50104: ST_TO_ADDR
// for i in units do
50105: LD_ADDR_VAR 0 4
50109: PUSH
50110: LD_VAR 0 1
50114: PUSH
50115: FOR_IN
50116: IFFALSE 50159
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50118: LD_ADDR_VAR 0 5
50122: PUSH
50123: LD_VAR 0 5
50127: PPUSH
50128: LD_VAR 0 5
50132: PUSH
50133: LD_INT 1
50135: PLUS
50136: PPUSH
50137: LD_VAR 0 4
50141: PPUSH
50142: LD_VAR 0 2
50146: PPUSH
50147: CALL_OW 259
50151: PPUSH
50152: CALL_OW 2
50156: ST_TO_ADDR
50157: GO 50115
50159: POP
50160: POP
// if not tmp then
50161: LD_VAR 0 5
50165: NOT
50166: IFFALSE 50170
// exit ;
50168: GO 50190
// result := SortListByListDesc ( units , tmp ) ;
50170: LD_ADDR_VAR 0 3
50174: PUSH
50175: LD_VAR 0 1
50179: PPUSH
50180: LD_VAR 0 5
50184: PPUSH
50185: CALL_OW 77
50189: ST_TO_ADDR
// end ;
50190: LD_VAR 0 3
50194: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50195: LD_INT 0
50197: PPUSH
50198: PPUSH
50199: PPUSH
// result := false ;
50200: LD_ADDR_VAR 0 3
50204: PUSH
50205: LD_INT 0
50207: ST_TO_ADDR
// x := GetX ( building ) ;
50208: LD_ADDR_VAR 0 4
50212: PUSH
50213: LD_VAR 0 2
50217: PPUSH
50218: CALL_OW 250
50222: ST_TO_ADDR
// y := GetY ( building ) ;
50223: LD_ADDR_VAR 0 5
50227: PUSH
50228: LD_VAR 0 2
50232: PPUSH
50233: CALL_OW 251
50237: ST_TO_ADDR
// if not building or not x or not y then
50238: LD_VAR 0 2
50242: NOT
50243: PUSH
50244: LD_VAR 0 4
50248: NOT
50249: OR
50250: PUSH
50251: LD_VAR 0 5
50255: NOT
50256: OR
50257: IFFALSE 50261
// exit ;
50259: GO 50353
// if GetTaskList ( unit ) then
50261: LD_VAR 0 1
50265: PPUSH
50266: CALL_OW 437
50270: IFFALSE 50353
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50272: LD_STRING e
50274: PUSH
50275: LD_VAR 0 1
50279: PPUSH
50280: CALL_OW 437
50284: PUSH
50285: LD_INT 1
50287: ARRAY
50288: PUSH
50289: LD_INT 1
50291: ARRAY
50292: EQUAL
50293: PUSH
50294: LD_VAR 0 4
50298: PUSH
50299: LD_VAR 0 1
50303: PPUSH
50304: CALL_OW 437
50308: PUSH
50309: LD_INT 1
50311: ARRAY
50312: PUSH
50313: LD_INT 2
50315: ARRAY
50316: EQUAL
50317: AND
50318: PUSH
50319: LD_VAR 0 5
50323: PUSH
50324: LD_VAR 0 1
50328: PPUSH
50329: CALL_OW 437
50333: PUSH
50334: LD_INT 1
50336: ARRAY
50337: PUSH
50338: LD_INT 3
50340: ARRAY
50341: EQUAL
50342: AND
50343: IFFALSE 50353
// result := true end ;
50345: LD_ADDR_VAR 0 3
50349: PUSH
50350: LD_INT 1
50352: ST_TO_ADDR
// end ;
50353: LD_VAR 0 3
50357: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
50358: LD_INT 0
50360: PPUSH
// result := false ;
50361: LD_ADDR_VAR 0 4
50365: PUSH
50366: LD_INT 0
50368: ST_TO_ADDR
// if GetTaskList ( unit ) then
50369: LD_VAR 0 1
50373: PPUSH
50374: CALL_OW 437
50378: IFFALSE 50461
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50380: LD_STRING M
50382: PUSH
50383: LD_VAR 0 1
50387: PPUSH
50388: CALL_OW 437
50392: PUSH
50393: LD_INT 1
50395: ARRAY
50396: PUSH
50397: LD_INT 1
50399: ARRAY
50400: EQUAL
50401: PUSH
50402: LD_VAR 0 2
50406: PUSH
50407: LD_VAR 0 1
50411: PPUSH
50412: CALL_OW 437
50416: PUSH
50417: LD_INT 1
50419: ARRAY
50420: PUSH
50421: LD_INT 2
50423: ARRAY
50424: EQUAL
50425: AND
50426: PUSH
50427: LD_VAR 0 3
50431: PUSH
50432: LD_VAR 0 1
50436: PPUSH
50437: CALL_OW 437
50441: PUSH
50442: LD_INT 1
50444: ARRAY
50445: PUSH
50446: LD_INT 3
50448: ARRAY
50449: EQUAL
50450: AND
50451: IFFALSE 50461
// result := true ;
50453: LD_ADDR_VAR 0 4
50457: PUSH
50458: LD_INT 1
50460: ST_TO_ADDR
// end ; end ;
50461: LD_VAR 0 4
50465: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
50466: LD_INT 0
50468: PPUSH
50469: PPUSH
50470: PPUSH
50471: PPUSH
// if not unit or not area then
50472: LD_VAR 0 1
50476: NOT
50477: PUSH
50478: LD_VAR 0 2
50482: NOT
50483: OR
50484: IFFALSE 50488
// exit ;
50486: GO 50652
// tmp := AreaToList ( area , i ) ;
50488: LD_ADDR_VAR 0 6
50492: PUSH
50493: LD_VAR 0 2
50497: PPUSH
50498: LD_VAR 0 5
50502: PPUSH
50503: CALL_OW 517
50507: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
50508: LD_ADDR_VAR 0 5
50512: PUSH
50513: DOUBLE
50514: LD_INT 1
50516: DEC
50517: ST_TO_ADDR
50518: LD_VAR 0 6
50522: PUSH
50523: LD_INT 1
50525: ARRAY
50526: PUSH
50527: FOR_TO
50528: IFFALSE 50650
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
50530: LD_ADDR_VAR 0 7
50534: PUSH
50535: LD_VAR 0 6
50539: PUSH
50540: LD_INT 1
50542: ARRAY
50543: PUSH
50544: LD_VAR 0 5
50548: ARRAY
50549: PUSH
50550: LD_VAR 0 6
50554: PUSH
50555: LD_INT 2
50557: ARRAY
50558: PUSH
50559: LD_VAR 0 5
50563: ARRAY
50564: PUSH
50565: EMPTY
50566: LIST
50567: LIST
50568: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
50569: LD_VAR 0 7
50573: PUSH
50574: LD_INT 1
50576: ARRAY
50577: PPUSH
50578: LD_VAR 0 7
50582: PUSH
50583: LD_INT 2
50585: ARRAY
50586: PPUSH
50587: CALL_OW 428
50591: PUSH
50592: LD_INT 0
50594: EQUAL
50595: IFFALSE 50648
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
50597: LD_VAR 0 1
50601: PPUSH
50602: LD_VAR 0 7
50606: PUSH
50607: LD_INT 1
50609: ARRAY
50610: PPUSH
50611: LD_VAR 0 7
50615: PUSH
50616: LD_INT 2
50618: ARRAY
50619: PPUSH
50620: LD_VAR 0 3
50624: PPUSH
50625: CALL_OW 48
// result := IsPlaced ( unit ) ;
50629: LD_ADDR_VAR 0 4
50633: PUSH
50634: LD_VAR 0 1
50638: PPUSH
50639: CALL_OW 305
50643: ST_TO_ADDR
// exit ;
50644: POP
50645: POP
50646: GO 50652
// end ; end ;
50648: GO 50527
50650: POP
50651: POP
// end ;
50652: LD_VAR 0 4
50656: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
50657: LD_INT 0
50659: PPUSH
50660: PPUSH
50661: PPUSH
// if not side or side > 8 then
50662: LD_VAR 0 1
50666: NOT
50667: PUSH
50668: LD_VAR 0 1
50672: PUSH
50673: LD_INT 8
50675: GREATER
50676: OR
50677: IFFALSE 50681
// exit ;
50679: GO 50868
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
50681: LD_ADDR_VAR 0 4
50685: PUSH
50686: LD_INT 22
50688: PUSH
50689: LD_VAR 0 1
50693: PUSH
50694: EMPTY
50695: LIST
50696: LIST
50697: PUSH
50698: LD_INT 21
50700: PUSH
50701: LD_INT 3
50703: PUSH
50704: EMPTY
50705: LIST
50706: LIST
50707: PUSH
50708: EMPTY
50709: LIST
50710: LIST
50711: PPUSH
50712: CALL_OW 69
50716: ST_TO_ADDR
// if not tmp then
50717: LD_VAR 0 4
50721: NOT
50722: IFFALSE 50726
// exit ;
50724: GO 50868
// enable_addtolog := true ;
50726: LD_ADDR_OWVAR 81
50730: PUSH
50731: LD_INT 1
50733: ST_TO_ADDR
// AddToLog ( [ ) ;
50734: LD_STRING [
50736: PPUSH
50737: CALL_OW 561
// for i in tmp do
50741: LD_ADDR_VAR 0 3
50745: PUSH
50746: LD_VAR 0 4
50750: PUSH
50751: FOR_IN
50752: IFFALSE 50859
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
50754: LD_STRING [
50756: PUSH
50757: LD_VAR 0 3
50761: PPUSH
50762: CALL_OW 266
50766: STR
50767: PUSH
50768: LD_STRING , 
50770: STR
50771: PUSH
50772: LD_VAR 0 3
50776: PPUSH
50777: CALL_OW 250
50781: STR
50782: PUSH
50783: LD_STRING , 
50785: STR
50786: PUSH
50787: LD_VAR 0 3
50791: PPUSH
50792: CALL_OW 251
50796: STR
50797: PUSH
50798: LD_STRING , 
50800: STR
50801: PUSH
50802: LD_VAR 0 3
50806: PPUSH
50807: CALL_OW 254
50811: STR
50812: PUSH
50813: LD_STRING , 
50815: STR
50816: PUSH
50817: LD_VAR 0 3
50821: PPUSH
50822: LD_INT 1
50824: PPUSH
50825: CALL_OW 268
50829: STR
50830: PUSH
50831: LD_STRING , 
50833: STR
50834: PUSH
50835: LD_VAR 0 3
50839: PPUSH
50840: LD_INT 2
50842: PPUSH
50843: CALL_OW 268
50847: STR
50848: PUSH
50849: LD_STRING ],
50851: STR
50852: PPUSH
50853: CALL_OW 561
// end ;
50857: GO 50751
50859: POP
50860: POP
// AddToLog ( ]; ) ;
50861: LD_STRING ];
50863: PPUSH
50864: CALL_OW 561
// end ;
50868: LD_VAR 0 2
50872: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50873: LD_INT 0
50875: PPUSH
50876: PPUSH
50877: PPUSH
50878: PPUSH
50879: PPUSH
// if not area or not rate or not max then
50880: LD_VAR 0 1
50884: NOT
50885: PUSH
50886: LD_VAR 0 2
50890: NOT
50891: OR
50892: PUSH
50893: LD_VAR 0 4
50897: NOT
50898: OR
50899: IFFALSE 50903
// exit ;
50901: GO 51095
// while 1 do
50903: LD_INT 1
50905: IFFALSE 51095
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50907: LD_ADDR_VAR 0 9
50911: PUSH
50912: LD_VAR 0 1
50916: PPUSH
50917: LD_INT 1
50919: PPUSH
50920: CALL_OW 287
50924: PUSH
50925: LD_INT 10
50927: MUL
50928: ST_TO_ADDR
// r := rate / 10 ;
50929: LD_ADDR_VAR 0 7
50933: PUSH
50934: LD_VAR 0 2
50938: PUSH
50939: LD_INT 10
50941: DIVREAL
50942: ST_TO_ADDR
// time := 1 1$00 ;
50943: LD_ADDR_VAR 0 8
50947: PUSH
50948: LD_INT 2100
50950: ST_TO_ADDR
// if amount < min then
50951: LD_VAR 0 9
50955: PUSH
50956: LD_VAR 0 3
50960: LESS
50961: IFFALSE 50979
// r := r * 2 else
50963: LD_ADDR_VAR 0 7
50967: PUSH
50968: LD_VAR 0 7
50972: PUSH
50973: LD_INT 2
50975: MUL
50976: ST_TO_ADDR
50977: GO 51005
// if amount > max then
50979: LD_VAR 0 9
50983: PUSH
50984: LD_VAR 0 4
50988: GREATER
50989: IFFALSE 51005
// r := r / 2 ;
50991: LD_ADDR_VAR 0 7
50995: PUSH
50996: LD_VAR 0 7
51000: PUSH
51001: LD_INT 2
51003: DIVREAL
51004: ST_TO_ADDR
// time := time / r ;
51005: LD_ADDR_VAR 0 8
51009: PUSH
51010: LD_VAR 0 8
51014: PUSH
51015: LD_VAR 0 7
51019: DIVREAL
51020: ST_TO_ADDR
// if time < 0 then
51021: LD_VAR 0 8
51025: PUSH
51026: LD_INT 0
51028: LESS
51029: IFFALSE 51046
// time := time * - 1 ;
51031: LD_ADDR_VAR 0 8
51035: PUSH
51036: LD_VAR 0 8
51040: PUSH
51041: LD_INT 1
51043: NEG
51044: MUL
51045: ST_TO_ADDR
// wait ( time ) ;
51046: LD_VAR 0 8
51050: PPUSH
51051: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
51055: LD_INT 35
51057: PPUSH
51058: LD_INT 875
51060: PPUSH
51061: CALL_OW 12
51065: PPUSH
51066: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51070: LD_INT 1
51072: PPUSH
51073: LD_INT 5
51075: PPUSH
51076: CALL_OW 12
51080: PPUSH
51081: LD_VAR 0 1
51085: PPUSH
51086: LD_INT 1
51088: PPUSH
51089: CALL_OW 55
// end ;
51093: GO 50903
// end ;
51095: LD_VAR 0 5
51099: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51100: LD_INT 0
51102: PPUSH
51103: PPUSH
51104: PPUSH
51105: PPUSH
51106: PPUSH
51107: PPUSH
51108: PPUSH
51109: PPUSH
// if not turrets or not factories then
51110: LD_VAR 0 1
51114: NOT
51115: PUSH
51116: LD_VAR 0 2
51120: NOT
51121: OR
51122: IFFALSE 51126
// exit ;
51124: GO 51433
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51126: LD_ADDR_VAR 0 10
51130: PUSH
51131: LD_INT 5
51133: PUSH
51134: LD_INT 6
51136: PUSH
51137: EMPTY
51138: LIST
51139: LIST
51140: PUSH
51141: LD_INT 2
51143: PUSH
51144: LD_INT 4
51146: PUSH
51147: EMPTY
51148: LIST
51149: LIST
51150: PUSH
51151: LD_INT 3
51153: PUSH
51154: LD_INT 5
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: PUSH
51161: EMPTY
51162: LIST
51163: LIST
51164: LIST
51165: PUSH
51166: LD_INT 24
51168: PUSH
51169: LD_INT 25
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PUSH
51176: LD_INT 23
51178: PUSH
51179: LD_INT 27
51181: PUSH
51182: EMPTY
51183: LIST
51184: LIST
51185: PUSH
51186: EMPTY
51187: LIST
51188: LIST
51189: PUSH
51190: LD_INT 42
51192: PUSH
51193: LD_INT 43
51195: PUSH
51196: EMPTY
51197: LIST
51198: LIST
51199: PUSH
51200: LD_INT 44
51202: PUSH
51203: LD_INT 46
51205: PUSH
51206: EMPTY
51207: LIST
51208: LIST
51209: PUSH
51210: LD_INT 45
51212: PUSH
51213: LD_INT 47
51215: PUSH
51216: EMPTY
51217: LIST
51218: LIST
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: LIST
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: LIST
51229: ST_TO_ADDR
// result := [ ] ;
51230: LD_ADDR_VAR 0 3
51234: PUSH
51235: EMPTY
51236: ST_TO_ADDR
// for i in turrets do
51237: LD_ADDR_VAR 0 4
51241: PUSH
51242: LD_VAR 0 1
51246: PUSH
51247: FOR_IN
51248: IFFALSE 51431
// begin nat := GetNation ( i ) ;
51250: LD_ADDR_VAR 0 7
51254: PUSH
51255: LD_VAR 0 4
51259: PPUSH
51260: CALL_OW 248
51264: ST_TO_ADDR
// weapon := 0 ;
51265: LD_ADDR_VAR 0 8
51269: PUSH
51270: LD_INT 0
51272: ST_TO_ADDR
// if not nat then
51273: LD_VAR 0 7
51277: NOT
51278: IFFALSE 51282
// continue ;
51280: GO 51247
// for j in list [ nat ] do
51282: LD_ADDR_VAR 0 5
51286: PUSH
51287: LD_VAR 0 10
51291: PUSH
51292: LD_VAR 0 7
51296: ARRAY
51297: PUSH
51298: FOR_IN
51299: IFFALSE 51340
// if GetBWeapon ( i ) = j [ 1 ] then
51301: LD_VAR 0 4
51305: PPUSH
51306: CALL_OW 269
51310: PUSH
51311: LD_VAR 0 5
51315: PUSH
51316: LD_INT 1
51318: ARRAY
51319: EQUAL
51320: IFFALSE 51338
// begin weapon := j [ 2 ] ;
51322: LD_ADDR_VAR 0 8
51326: PUSH
51327: LD_VAR 0 5
51331: PUSH
51332: LD_INT 2
51334: ARRAY
51335: ST_TO_ADDR
// break ;
51336: GO 51340
// end ;
51338: GO 51298
51340: POP
51341: POP
// if not weapon then
51342: LD_VAR 0 8
51346: NOT
51347: IFFALSE 51351
// continue ;
51349: GO 51247
// for k in factories do
51351: LD_ADDR_VAR 0 6
51355: PUSH
51356: LD_VAR 0 2
51360: PUSH
51361: FOR_IN
51362: IFFALSE 51427
// begin weapons := AvailableWeaponList ( k ) ;
51364: LD_ADDR_VAR 0 9
51368: PUSH
51369: LD_VAR 0 6
51373: PPUSH
51374: CALL_OW 478
51378: ST_TO_ADDR
// if not weapons then
51379: LD_VAR 0 9
51383: NOT
51384: IFFALSE 51388
// continue ;
51386: GO 51361
// if weapon in weapons then
51388: LD_VAR 0 8
51392: PUSH
51393: LD_VAR 0 9
51397: IN
51398: IFFALSE 51425
// begin result := [ i , weapon ] ;
51400: LD_ADDR_VAR 0 3
51404: PUSH
51405: LD_VAR 0 4
51409: PUSH
51410: LD_VAR 0 8
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: ST_TO_ADDR
// exit ;
51419: POP
51420: POP
51421: POP
51422: POP
51423: GO 51433
// end ; end ;
51425: GO 51361
51427: POP
51428: POP
// end ;
51429: GO 51247
51431: POP
51432: POP
// end ;
51433: LD_VAR 0 3
51437: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
51438: LD_INT 0
51440: PPUSH
// if not side or side > 8 then
51441: LD_VAR 0 3
51445: NOT
51446: PUSH
51447: LD_VAR 0 3
51451: PUSH
51452: LD_INT 8
51454: GREATER
51455: OR
51456: IFFALSE 51460
// exit ;
51458: GO 51519
// if not range then
51460: LD_VAR 0 4
51464: NOT
51465: IFFALSE 51476
// range := - 12 ;
51467: LD_ADDR_VAR 0 4
51471: PUSH
51472: LD_INT 12
51474: NEG
51475: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
51476: LD_VAR 0 1
51480: PPUSH
51481: LD_VAR 0 2
51485: PPUSH
51486: LD_VAR 0 3
51490: PPUSH
51491: LD_VAR 0 4
51495: PPUSH
51496: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
51500: LD_VAR 0 1
51504: PPUSH
51505: LD_VAR 0 2
51509: PPUSH
51510: LD_VAR 0 3
51514: PPUSH
51515: CALL_OW 331
// end ;
51519: LD_VAR 0 5
51523: RET
// export function Video ( mode ) ; begin
51524: LD_INT 0
51526: PPUSH
// ingame_video = mode ;
51527: LD_ADDR_OWVAR 52
51531: PUSH
51532: LD_VAR 0 1
51536: ST_TO_ADDR
// interface_hidden = mode ;
51537: LD_ADDR_OWVAR 54
51541: PUSH
51542: LD_VAR 0 1
51546: ST_TO_ADDR
// end ;
51547: LD_VAR 0 2
51551: RET
// export function Join ( array , element ) ; begin
51552: LD_INT 0
51554: PPUSH
// result := Replace ( array , array + 1 , element ) ;
51555: LD_ADDR_VAR 0 3
51559: PUSH
51560: LD_VAR 0 1
51564: PPUSH
51565: LD_VAR 0 1
51569: PUSH
51570: LD_INT 1
51572: PLUS
51573: PPUSH
51574: LD_VAR 0 2
51578: PPUSH
51579: CALL_OW 1
51583: ST_TO_ADDR
// end ;
51584: LD_VAR 0 3
51588: RET
// export function JoinUnion ( array , element ) ; begin
51589: LD_INT 0
51591: PPUSH
// result := array union element ;
51592: LD_ADDR_VAR 0 3
51596: PUSH
51597: LD_VAR 0 1
51601: PUSH
51602: LD_VAR 0 2
51606: UNION
51607: ST_TO_ADDR
// end ;
51608: LD_VAR 0 3
51612: RET
// export function GetBehemoths ( side ) ; begin
51613: LD_INT 0
51615: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
51616: LD_ADDR_VAR 0 2
51620: PUSH
51621: LD_INT 22
51623: PUSH
51624: LD_VAR 0 1
51628: PUSH
51629: EMPTY
51630: LIST
51631: LIST
51632: PUSH
51633: LD_INT 31
51635: PUSH
51636: LD_INT 25
51638: PUSH
51639: EMPTY
51640: LIST
51641: LIST
51642: PUSH
51643: EMPTY
51644: LIST
51645: LIST
51646: PPUSH
51647: CALL_OW 69
51651: ST_TO_ADDR
// end ;
51652: LD_VAR 0 2
51656: RET
// export function Shuffle ( array ) ; var i , index ; begin
51657: LD_INT 0
51659: PPUSH
51660: PPUSH
51661: PPUSH
// result := [ ] ;
51662: LD_ADDR_VAR 0 2
51666: PUSH
51667: EMPTY
51668: ST_TO_ADDR
// if not array then
51669: LD_VAR 0 1
51673: NOT
51674: IFFALSE 51678
// exit ;
51676: GO 51777
// Randomize ;
51678: CALL_OW 10
// for i = array downto 1 do
51682: LD_ADDR_VAR 0 3
51686: PUSH
51687: DOUBLE
51688: LD_VAR 0 1
51692: INC
51693: ST_TO_ADDR
51694: LD_INT 1
51696: PUSH
51697: FOR_DOWNTO
51698: IFFALSE 51775
// begin index := rand ( 1 , array ) ;
51700: LD_ADDR_VAR 0 4
51704: PUSH
51705: LD_INT 1
51707: PPUSH
51708: LD_VAR 0 1
51712: PPUSH
51713: CALL_OW 12
51717: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
51718: LD_ADDR_VAR 0 2
51722: PUSH
51723: LD_VAR 0 2
51727: PPUSH
51728: LD_VAR 0 2
51732: PUSH
51733: LD_INT 1
51735: PLUS
51736: PPUSH
51737: LD_VAR 0 1
51741: PUSH
51742: LD_VAR 0 4
51746: ARRAY
51747: PPUSH
51748: CALL_OW 2
51752: ST_TO_ADDR
// array := Delete ( array , index ) ;
51753: LD_ADDR_VAR 0 1
51757: PUSH
51758: LD_VAR 0 1
51762: PPUSH
51763: LD_VAR 0 4
51767: PPUSH
51768: CALL_OW 3
51772: ST_TO_ADDR
// end ;
51773: GO 51697
51775: POP
51776: POP
// end ;
51777: LD_VAR 0 2
51781: RET
// export function GetBaseMaterials ( base ) ; begin
51782: LD_INT 0
51784: PPUSH
// result := [ 0 , 0 , 0 ] ;
51785: LD_ADDR_VAR 0 2
51789: PUSH
51790: LD_INT 0
51792: PUSH
51793: LD_INT 0
51795: PUSH
51796: LD_INT 0
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: LIST
51803: ST_TO_ADDR
// if not base then
51804: LD_VAR 0 1
51808: NOT
51809: IFFALSE 51813
// exit ;
51811: GO 51862
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
51813: LD_ADDR_VAR 0 2
51817: PUSH
51818: LD_VAR 0 1
51822: PPUSH
51823: LD_INT 1
51825: PPUSH
51826: CALL_OW 275
51830: PUSH
51831: LD_VAR 0 1
51835: PPUSH
51836: LD_INT 2
51838: PPUSH
51839: CALL_OW 275
51843: PUSH
51844: LD_VAR 0 1
51848: PPUSH
51849: LD_INT 3
51851: PPUSH
51852: CALL_OW 275
51856: PUSH
51857: EMPTY
51858: LIST
51859: LIST
51860: LIST
51861: ST_TO_ADDR
// end ;
51862: LD_VAR 0 2
51866: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
51867: LD_INT 0
51869: PPUSH
51870: PPUSH
// result := array ;
51871: LD_ADDR_VAR 0 3
51875: PUSH
51876: LD_VAR 0 1
51880: ST_TO_ADDR
// if size > 0 then
51881: LD_VAR 0 2
51885: PUSH
51886: LD_INT 0
51888: GREATER
51889: IFFALSE 51935
// for i := array downto size do
51891: LD_ADDR_VAR 0 4
51895: PUSH
51896: DOUBLE
51897: LD_VAR 0 1
51901: INC
51902: ST_TO_ADDR
51903: LD_VAR 0 2
51907: PUSH
51908: FOR_DOWNTO
51909: IFFALSE 51933
// result := Delete ( result , result ) ;
51911: LD_ADDR_VAR 0 3
51915: PUSH
51916: LD_VAR 0 3
51920: PPUSH
51921: LD_VAR 0 3
51925: PPUSH
51926: CALL_OW 3
51930: ST_TO_ADDR
51931: GO 51908
51933: POP
51934: POP
// end ;
51935: LD_VAR 0 3
51939: RET
// export function ComExit ( unit ) ; var tmp ; begin
51940: LD_INT 0
51942: PPUSH
51943: PPUSH
// if not IsInUnit ( unit ) then
51944: LD_VAR 0 1
51948: PPUSH
51949: CALL_OW 310
51953: NOT
51954: IFFALSE 51958
// exit ;
51956: GO 52018
// tmp := IsInUnit ( unit ) ;
51958: LD_ADDR_VAR 0 3
51962: PUSH
51963: LD_VAR 0 1
51967: PPUSH
51968: CALL_OW 310
51972: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51973: LD_VAR 0 3
51977: PPUSH
51978: CALL_OW 247
51982: PUSH
51983: LD_INT 2
51985: EQUAL
51986: IFFALSE 51999
// ComExitVehicle ( unit ) else
51988: LD_VAR 0 1
51992: PPUSH
51993: CALL_OW 121
51997: GO 52008
// ComExitBuilding ( unit ) ;
51999: LD_VAR 0 1
52003: PPUSH
52004: CALL_OW 122
// result := tmp ;
52008: LD_ADDR_VAR 0 2
52012: PUSH
52013: LD_VAR 0 3
52017: ST_TO_ADDR
// end ;
52018: LD_VAR 0 2
52022: RET
// export function ComExitAll ( units ) ; var i ; begin
52023: LD_INT 0
52025: PPUSH
52026: PPUSH
// if not units then
52027: LD_VAR 0 1
52031: NOT
52032: IFFALSE 52036
// exit ;
52034: GO 52062
// for i in units do
52036: LD_ADDR_VAR 0 3
52040: PUSH
52041: LD_VAR 0 1
52045: PUSH
52046: FOR_IN
52047: IFFALSE 52060
// ComExit ( i ) ;
52049: LD_VAR 0 3
52053: PPUSH
52054: CALL 51940 0 1
52058: GO 52046
52060: POP
52061: POP
// end ;
52062: LD_VAR 0 2
52066: RET
// export function ResetHc ; begin
52067: LD_INT 0
52069: PPUSH
// InitHc ;
52070: CALL_OW 19
// hc_importance := 0 ;
52074: LD_ADDR_OWVAR 32
52078: PUSH
52079: LD_INT 0
52081: ST_TO_ADDR
// end ;
52082: LD_VAR 0 1
52086: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52087: LD_INT 0
52089: PPUSH
52090: PPUSH
52091: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52092: LD_ADDR_VAR 0 6
52096: PUSH
52097: LD_VAR 0 1
52101: PUSH
52102: LD_VAR 0 3
52106: PLUS
52107: PUSH
52108: LD_INT 2
52110: DIV
52111: ST_TO_ADDR
// if _x < 0 then
52112: LD_VAR 0 6
52116: PUSH
52117: LD_INT 0
52119: LESS
52120: IFFALSE 52137
// _x := _x * - 1 ;
52122: LD_ADDR_VAR 0 6
52126: PUSH
52127: LD_VAR 0 6
52131: PUSH
52132: LD_INT 1
52134: NEG
52135: MUL
52136: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52137: LD_ADDR_VAR 0 7
52141: PUSH
52142: LD_VAR 0 2
52146: PUSH
52147: LD_VAR 0 4
52151: PLUS
52152: PUSH
52153: LD_INT 2
52155: DIV
52156: ST_TO_ADDR
// if _y < 0 then
52157: LD_VAR 0 7
52161: PUSH
52162: LD_INT 0
52164: LESS
52165: IFFALSE 52182
// _y := _y * - 1 ;
52167: LD_ADDR_VAR 0 7
52171: PUSH
52172: LD_VAR 0 7
52176: PUSH
52177: LD_INT 1
52179: NEG
52180: MUL
52181: ST_TO_ADDR
// result := [ _x , _y ] ;
52182: LD_ADDR_VAR 0 5
52186: PUSH
52187: LD_VAR 0 6
52191: PUSH
52192: LD_VAR 0 7
52196: PUSH
52197: EMPTY
52198: LIST
52199: LIST
52200: ST_TO_ADDR
// end ;
52201: LD_VAR 0 5
52205: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52206: LD_INT 0
52208: PPUSH
52209: PPUSH
52210: PPUSH
52211: PPUSH
// task := GetTaskList ( unit ) ;
52212: LD_ADDR_VAR 0 7
52216: PUSH
52217: LD_VAR 0 1
52221: PPUSH
52222: CALL_OW 437
52226: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52227: LD_VAR 0 7
52231: NOT
52232: PUSH
52233: LD_VAR 0 1
52237: PPUSH
52238: LD_VAR 0 2
52242: PPUSH
52243: CALL_OW 308
52247: NOT
52248: AND
52249: IFFALSE 52253
// exit ;
52251: GO 52371
// if IsInArea ( unit , area ) then
52253: LD_VAR 0 1
52257: PPUSH
52258: LD_VAR 0 2
52262: PPUSH
52263: CALL_OW 308
52267: IFFALSE 52285
// begin ComMoveToArea ( unit , goAway ) ;
52269: LD_VAR 0 1
52273: PPUSH
52274: LD_VAR 0 3
52278: PPUSH
52279: CALL_OW 113
// exit ;
52283: GO 52371
// end ; if task [ 1 ] [ 1 ] <> M then
52285: LD_VAR 0 7
52289: PUSH
52290: LD_INT 1
52292: ARRAY
52293: PUSH
52294: LD_INT 1
52296: ARRAY
52297: PUSH
52298: LD_STRING M
52300: NONEQUAL
52301: IFFALSE 52305
// exit ;
52303: GO 52371
// x := task [ 1 ] [ 2 ] ;
52305: LD_ADDR_VAR 0 5
52309: PUSH
52310: LD_VAR 0 7
52314: PUSH
52315: LD_INT 1
52317: ARRAY
52318: PUSH
52319: LD_INT 2
52321: ARRAY
52322: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
52323: LD_ADDR_VAR 0 6
52327: PUSH
52328: LD_VAR 0 7
52332: PUSH
52333: LD_INT 1
52335: ARRAY
52336: PUSH
52337: LD_INT 3
52339: ARRAY
52340: ST_TO_ADDR
// if InArea ( x , y , area ) then
52341: LD_VAR 0 5
52345: PPUSH
52346: LD_VAR 0 6
52350: PPUSH
52351: LD_VAR 0 2
52355: PPUSH
52356: CALL_OW 309
52360: IFFALSE 52371
// ComStop ( unit ) ;
52362: LD_VAR 0 1
52366: PPUSH
52367: CALL_OW 141
// end ;
52371: LD_VAR 0 4
52375: RET
// export function Abs ( value ) ; begin
52376: LD_INT 0
52378: PPUSH
// result := value ;
52379: LD_ADDR_VAR 0 2
52383: PUSH
52384: LD_VAR 0 1
52388: ST_TO_ADDR
// if value < 0 then
52389: LD_VAR 0 1
52393: PUSH
52394: LD_INT 0
52396: LESS
52397: IFFALSE 52414
// result := value * - 1 ;
52399: LD_ADDR_VAR 0 2
52403: PUSH
52404: LD_VAR 0 1
52408: PUSH
52409: LD_INT 1
52411: NEG
52412: MUL
52413: ST_TO_ADDR
// end ;
52414: LD_VAR 0 2
52418: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
52419: LD_INT 0
52421: PPUSH
52422: PPUSH
52423: PPUSH
52424: PPUSH
52425: PPUSH
52426: PPUSH
52427: PPUSH
52428: PPUSH
// if not unit or not building then
52429: LD_VAR 0 1
52433: NOT
52434: PUSH
52435: LD_VAR 0 2
52439: NOT
52440: OR
52441: IFFALSE 52445
// exit ;
52443: GO 52671
// x := GetX ( building ) ;
52445: LD_ADDR_VAR 0 4
52449: PUSH
52450: LD_VAR 0 2
52454: PPUSH
52455: CALL_OW 250
52459: ST_TO_ADDR
// y := GetY ( building ) ;
52460: LD_ADDR_VAR 0 6
52464: PUSH
52465: LD_VAR 0 2
52469: PPUSH
52470: CALL_OW 251
52474: ST_TO_ADDR
// d := GetDir ( building ) ;
52475: LD_ADDR_VAR 0 8
52479: PUSH
52480: LD_VAR 0 2
52484: PPUSH
52485: CALL_OW 254
52489: ST_TO_ADDR
// r := 4 ;
52490: LD_ADDR_VAR 0 9
52494: PUSH
52495: LD_INT 4
52497: ST_TO_ADDR
// for i := 1 to 5 do
52498: LD_ADDR_VAR 0 10
52502: PUSH
52503: DOUBLE
52504: LD_INT 1
52506: DEC
52507: ST_TO_ADDR
52508: LD_INT 5
52510: PUSH
52511: FOR_TO
52512: IFFALSE 52669
// begin _x := ShiftX ( x , d , r + i ) ;
52514: LD_ADDR_VAR 0 5
52518: PUSH
52519: LD_VAR 0 4
52523: PPUSH
52524: LD_VAR 0 8
52528: PPUSH
52529: LD_VAR 0 9
52533: PUSH
52534: LD_VAR 0 10
52538: PLUS
52539: PPUSH
52540: CALL_OW 272
52544: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
52545: LD_ADDR_VAR 0 7
52549: PUSH
52550: LD_VAR 0 6
52554: PPUSH
52555: LD_VAR 0 8
52559: PPUSH
52560: LD_VAR 0 9
52564: PUSH
52565: LD_VAR 0 10
52569: PLUS
52570: PPUSH
52571: CALL_OW 273
52575: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
52576: LD_VAR 0 5
52580: PPUSH
52581: LD_VAR 0 7
52585: PPUSH
52586: CALL_OW 488
52590: PUSH
52591: LD_VAR 0 5
52595: PPUSH
52596: LD_VAR 0 7
52600: PPUSH
52601: CALL_OW 428
52605: PPUSH
52606: CALL_OW 247
52610: PUSH
52611: LD_INT 3
52613: PUSH
52614: LD_INT 2
52616: PUSH
52617: EMPTY
52618: LIST
52619: LIST
52620: IN
52621: NOT
52622: AND
52623: IFFALSE 52667
// begin ComMoveXY ( unit , _x , _y ) ;
52625: LD_VAR 0 1
52629: PPUSH
52630: LD_VAR 0 5
52634: PPUSH
52635: LD_VAR 0 7
52639: PPUSH
52640: CALL_OW 111
// result := [ _x , _y ] ;
52644: LD_ADDR_VAR 0 3
52648: PUSH
52649: LD_VAR 0 5
52653: PUSH
52654: LD_VAR 0 7
52658: PUSH
52659: EMPTY
52660: LIST
52661: LIST
52662: ST_TO_ADDR
// exit ;
52663: POP
52664: POP
52665: GO 52671
// end ; end ;
52667: GO 52511
52669: POP
52670: POP
// end ;
52671: LD_VAR 0 3
52675: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
52676: LD_INT 0
52678: PPUSH
52679: PPUSH
52680: PPUSH
// result := 0 ;
52681: LD_ADDR_VAR 0 3
52685: PUSH
52686: LD_INT 0
52688: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
52689: LD_VAR 0 1
52693: PUSH
52694: LD_INT 0
52696: LESS
52697: PUSH
52698: LD_VAR 0 1
52702: PUSH
52703: LD_INT 8
52705: GREATER
52706: OR
52707: PUSH
52708: LD_VAR 0 2
52712: PUSH
52713: LD_INT 0
52715: LESS
52716: OR
52717: PUSH
52718: LD_VAR 0 2
52722: PUSH
52723: LD_INT 8
52725: GREATER
52726: OR
52727: IFFALSE 52731
// exit ;
52729: GO 52806
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
52731: LD_ADDR_VAR 0 4
52735: PUSH
52736: LD_INT 22
52738: PUSH
52739: LD_VAR 0 2
52743: PUSH
52744: EMPTY
52745: LIST
52746: LIST
52747: PPUSH
52748: CALL_OW 69
52752: PUSH
52753: FOR_IN
52754: IFFALSE 52804
// begin un := UnitShoot ( i ) ;
52756: LD_ADDR_VAR 0 5
52760: PUSH
52761: LD_VAR 0 4
52765: PPUSH
52766: CALL_OW 504
52770: ST_TO_ADDR
// if GetSide ( un ) = side1 then
52771: LD_VAR 0 5
52775: PPUSH
52776: CALL_OW 255
52780: PUSH
52781: LD_VAR 0 1
52785: EQUAL
52786: IFFALSE 52802
// begin result := un ;
52788: LD_ADDR_VAR 0 3
52792: PUSH
52793: LD_VAR 0 5
52797: ST_TO_ADDR
// exit ;
52798: POP
52799: POP
52800: GO 52806
// end ; end ;
52802: GO 52753
52804: POP
52805: POP
// end ;
52806: LD_VAR 0 3
52810: RET
// export function GetCargoBay ( units ) ; begin
52811: LD_INT 0
52813: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
52814: LD_ADDR_VAR 0 2
52818: PUSH
52819: LD_VAR 0 1
52823: PPUSH
52824: LD_INT 2
52826: PUSH
52827: LD_INT 34
52829: PUSH
52830: LD_INT 12
52832: PUSH
52833: EMPTY
52834: LIST
52835: LIST
52836: PUSH
52837: LD_INT 34
52839: PUSH
52840: LD_INT 51
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: PUSH
52847: LD_INT 34
52849: PUSH
52850: LD_INT 32
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: PUSH
52857: LD_INT 34
52859: PUSH
52860: LD_EXP 105
52864: PUSH
52865: EMPTY
52866: LIST
52867: LIST
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: LIST
52873: LIST
52874: LIST
52875: PPUSH
52876: CALL_OW 72
52880: ST_TO_ADDR
// end ;
52881: LD_VAR 0 2
52885: RET
// export function Negate ( value ) ; begin
52886: LD_INT 0
52888: PPUSH
// result := not value ;
52889: LD_ADDR_VAR 0 2
52893: PUSH
52894: LD_VAR 0 1
52898: NOT
52899: ST_TO_ADDR
// end ;
52900: LD_VAR 0 2
52904: RET
// export function Inc ( value ) ; begin
52905: LD_INT 0
52907: PPUSH
// result := value + 1 ;
52908: LD_ADDR_VAR 0 2
52912: PUSH
52913: LD_VAR 0 1
52917: PUSH
52918: LD_INT 1
52920: PLUS
52921: ST_TO_ADDR
// end ;
52922: LD_VAR 0 2
52926: RET
// export function Dec ( value ) ; begin
52927: LD_INT 0
52929: PPUSH
// result := value - 1 ;
52930: LD_ADDR_VAR 0 2
52934: PUSH
52935: LD_VAR 0 1
52939: PUSH
52940: LD_INT 1
52942: MINUS
52943: ST_TO_ADDR
// end ;
52944: LD_VAR 0 2
52948: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
52949: LD_INT 0
52951: PPUSH
52952: PPUSH
52953: PPUSH
52954: PPUSH
52955: PPUSH
52956: PPUSH
52957: PPUSH
52958: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
52959: LD_VAR 0 1
52963: PPUSH
52964: LD_VAR 0 2
52968: PPUSH
52969: CALL_OW 488
52973: NOT
52974: PUSH
52975: LD_VAR 0 3
52979: PPUSH
52980: LD_VAR 0 4
52984: PPUSH
52985: CALL_OW 488
52989: NOT
52990: OR
52991: IFFALSE 53004
// begin result := - 1 ;
52993: LD_ADDR_VAR 0 5
52997: PUSH
52998: LD_INT 1
53000: NEG
53001: ST_TO_ADDR
// exit ;
53002: GO 53239
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53004: LD_ADDR_VAR 0 12
53008: PUSH
53009: LD_VAR 0 1
53013: PPUSH
53014: LD_VAR 0 2
53018: PPUSH
53019: LD_VAR 0 3
53023: PPUSH
53024: LD_VAR 0 4
53028: PPUSH
53029: CALL 52087 0 4
53033: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53034: LD_ADDR_VAR 0 11
53038: PUSH
53039: LD_VAR 0 1
53043: PPUSH
53044: LD_VAR 0 2
53048: PPUSH
53049: LD_VAR 0 12
53053: PUSH
53054: LD_INT 1
53056: ARRAY
53057: PPUSH
53058: LD_VAR 0 12
53062: PUSH
53063: LD_INT 2
53065: ARRAY
53066: PPUSH
53067: CALL_OW 298
53071: ST_TO_ADDR
// distance := 9999 ;
53072: LD_ADDR_VAR 0 10
53076: PUSH
53077: LD_INT 9999
53079: ST_TO_ADDR
// for i := 0 to 5 do
53080: LD_ADDR_VAR 0 6
53084: PUSH
53085: DOUBLE
53086: LD_INT 0
53088: DEC
53089: ST_TO_ADDR
53090: LD_INT 5
53092: PUSH
53093: FOR_TO
53094: IFFALSE 53237
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53096: LD_ADDR_VAR 0 7
53100: PUSH
53101: LD_VAR 0 1
53105: PPUSH
53106: LD_VAR 0 6
53110: PPUSH
53111: LD_VAR 0 11
53115: PPUSH
53116: CALL_OW 272
53120: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53121: LD_ADDR_VAR 0 8
53125: PUSH
53126: LD_VAR 0 2
53130: PPUSH
53131: LD_VAR 0 6
53135: PPUSH
53136: LD_VAR 0 11
53140: PPUSH
53141: CALL_OW 273
53145: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53146: LD_VAR 0 7
53150: PPUSH
53151: LD_VAR 0 8
53155: PPUSH
53156: CALL_OW 488
53160: NOT
53161: IFFALSE 53165
// continue ;
53163: GO 53093
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53165: LD_ADDR_VAR 0 9
53169: PUSH
53170: LD_VAR 0 12
53174: PUSH
53175: LD_INT 1
53177: ARRAY
53178: PPUSH
53179: LD_VAR 0 12
53183: PUSH
53184: LD_INT 2
53186: ARRAY
53187: PPUSH
53188: LD_VAR 0 7
53192: PPUSH
53193: LD_VAR 0 8
53197: PPUSH
53198: CALL_OW 298
53202: ST_TO_ADDR
// if tmp < distance then
53203: LD_VAR 0 9
53207: PUSH
53208: LD_VAR 0 10
53212: LESS
53213: IFFALSE 53235
// begin result := i ;
53215: LD_ADDR_VAR 0 5
53219: PUSH
53220: LD_VAR 0 6
53224: ST_TO_ADDR
// distance := tmp ;
53225: LD_ADDR_VAR 0 10
53229: PUSH
53230: LD_VAR 0 9
53234: ST_TO_ADDR
// end ; end ;
53235: GO 53093
53237: POP
53238: POP
// end ;
53239: LD_VAR 0 5
53243: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53244: LD_INT 0
53246: PPUSH
53247: PPUSH
// if not driver or not IsInUnit ( driver ) then
53248: LD_VAR 0 1
53252: NOT
53253: PUSH
53254: LD_VAR 0 1
53258: PPUSH
53259: CALL_OW 310
53263: NOT
53264: OR
53265: IFFALSE 53269
// exit ;
53267: GO 53359
// vehicle := IsInUnit ( driver ) ;
53269: LD_ADDR_VAR 0 3
53273: PUSH
53274: LD_VAR 0 1
53278: PPUSH
53279: CALL_OW 310
53283: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53284: LD_VAR 0 1
53288: PPUSH
53289: LD_STRING \
53291: PUSH
53292: LD_INT 0
53294: PUSH
53295: LD_INT 0
53297: PUSH
53298: LD_INT 0
53300: PUSH
53301: LD_INT 0
53303: PUSH
53304: LD_INT 0
53306: PUSH
53307: LD_INT 0
53309: PUSH
53310: EMPTY
53311: LIST
53312: LIST
53313: LIST
53314: LIST
53315: LIST
53316: LIST
53317: LIST
53318: PUSH
53319: LD_STRING E
53321: PUSH
53322: LD_INT 0
53324: PUSH
53325: LD_INT 0
53327: PUSH
53328: LD_VAR 0 3
53332: PUSH
53333: LD_INT 0
53335: PUSH
53336: LD_INT 0
53338: PUSH
53339: LD_INT 0
53341: PUSH
53342: EMPTY
53343: LIST
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: LIST
53349: LIST
53350: PUSH
53351: EMPTY
53352: LIST
53353: LIST
53354: PPUSH
53355: CALL_OW 446
// end ;
53359: LD_VAR 0 2
53363: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53364: LD_INT 0
53366: PPUSH
53367: PPUSH
// if not driver or not IsInUnit ( driver ) then
53368: LD_VAR 0 1
53372: NOT
53373: PUSH
53374: LD_VAR 0 1
53378: PPUSH
53379: CALL_OW 310
53383: NOT
53384: OR
53385: IFFALSE 53389
// exit ;
53387: GO 53479
// vehicle := IsInUnit ( driver ) ;
53389: LD_ADDR_VAR 0 3
53393: PUSH
53394: LD_VAR 0 1
53398: PPUSH
53399: CALL_OW 310
53403: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
53404: LD_VAR 0 1
53408: PPUSH
53409: LD_STRING \
53411: PUSH
53412: LD_INT 0
53414: PUSH
53415: LD_INT 0
53417: PUSH
53418: LD_INT 0
53420: PUSH
53421: LD_INT 0
53423: PUSH
53424: LD_INT 0
53426: PUSH
53427: LD_INT 0
53429: PUSH
53430: EMPTY
53431: LIST
53432: LIST
53433: LIST
53434: LIST
53435: LIST
53436: LIST
53437: LIST
53438: PUSH
53439: LD_STRING E
53441: PUSH
53442: LD_INT 0
53444: PUSH
53445: LD_INT 0
53447: PUSH
53448: LD_VAR 0 3
53452: PUSH
53453: LD_INT 0
53455: PUSH
53456: LD_INT 0
53458: PUSH
53459: LD_INT 0
53461: PUSH
53462: EMPTY
53463: LIST
53464: LIST
53465: LIST
53466: LIST
53467: LIST
53468: LIST
53469: LIST
53470: PUSH
53471: EMPTY
53472: LIST
53473: LIST
53474: PPUSH
53475: CALL_OW 447
// end ;
53479: LD_VAR 0 2
53483: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
53484: LD_INT 0
53486: PPUSH
53487: PPUSH
53488: PPUSH
// tmp := [ ] ;
53489: LD_ADDR_VAR 0 5
53493: PUSH
53494: EMPTY
53495: ST_TO_ADDR
// for i in units do
53496: LD_ADDR_VAR 0 4
53500: PUSH
53501: LD_VAR 0 1
53505: PUSH
53506: FOR_IN
53507: IFFALSE 53545
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
53509: LD_ADDR_VAR 0 5
53513: PUSH
53514: LD_VAR 0 5
53518: PPUSH
53519: LD_VAR 0 5
53523: PUSH
53524: LD_INT 1
53526: PLUS
53527: PPUSH
53528: LD_VAR 0 4
53532: PPUSH
53533: CALL_OW 256
53537: PPUSH
53538: CALL_OW 2
53542: ST_TO_ADDR
53543: GO 53506
53545: POP
53546: POP
// if not tmp then
53547: LD_VAR 0 5
53551: NOT
53552: IFFALSE 53556
// exit ;
53554: GO 53604
// if asc then
53556: LD_VAR 0 2
53560: IFFALSE 53584
// result := SortListByListAsc ( units , tmp ) else
53562: LD_ADDR_VAR 0 3
53566: PUSH
53567: LD_VAR 0 1
53571: PPUSH
53572: LD_VAR 0 5
53576: PPUSH
53577: CALL_OW 76
53581: ST_TO_ADDR
53582: GO 53604
// result := SortListByListDesc ( units , tmp ) ;
53584: LD_ADDR_VAR 0 3
53588: PUSH
53589: LD_VAR 0 1
53593: PPUSH
53594: LD_VAR 0 5
53598: PPUSH
53599: CALL_OW 77
53603: ST_TO_ADDR
// end ;
53604: LD_VAR 0 3
53608: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
53609: LD_INT 0
53611: PPUSH
53612: PPUSH
// task := GetTaskList ( mech ) ;
53613: LD_ADDR_VAR 0 4
53617: PUSH
53618: LD_VAR 0 1
53622: PPUSH
53623: CALL_OW 437
53627: ST_TO_ADDR
// if not task then
53628: LD_VAR 0 4
53632: NOT
53633: IFFALSE 53637
// exit ;
53635: GO 53679
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
53637: LD_ADDR_VAR 0 3
53641: PUSH
53642: LD_VAR 0 4
53646: PUSH
53647: LD_INT 1
53649: ARRAY
53650: PUSH
53651: LD_INT 1
53653: ARRAY
53654: PUSH
53655: LD_STRING r
53657: EQUAL
53658: PUSH
53659: LD_VAR 0 4
53663: PUSH
53664: LD_INT 1
53666: ARRAY
53667: PUSH
53668: LD_INT 4
53670: ARRAY
53671: PUSH
53672: LD_VAR 0 2
53676: EQUAL
53677: AND
53678: ST_TO_ADDR
// end ;
53679: LD_VAR 0 3
53683: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
53684: LD_INT 0
53686: PPUSH
// SetDir ( unit , d ) ;
53687: LD_VAR 0 1
53691: PPUSH
53692: LD_VAR 0 4
53696: PPUSH
53697: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
53701: LD_VAR 0 1
53705: PPUSH
53706: LD_VAR 0 2
53710: PPUSH
53711: LD_VAR 0 3
53715: PPUSH
53716: LD_VAR 0 5
53720: PPUSH
53721: CALL_OW 48
// end ;
53725: LD_VAR 0 6
53729: RET
// export function ToNaturalNumber ( number ) ; begin
53730: LD_INT 0
53732: PPUSH
// result := number div 1 ;
53733: LD_ADDR_VAR 0 2
53737: PUSH
53738: LD_VAR 0 1
53742: PUSH
53743: LD_INT 1
53745: DIV
53746: ST_TO_ADDR
// if number < 0 then
53747: LD_VAR 0 1
53751: PUSH
53752: LD_INT 0
53754: LESS
53755: IFFALSE 53765
// result := 0 ;
53757: LD_ADDR_VAR 0 2
53761: PUSH
53762: LD_INT 0
53764: ST_TO_ADDR
// end ;
53765: LD_VAR 0 2
53769: RET
// export function SortByClass ( units , class ) ; var un ; begin
53770: LD_INT 0
53772: PPUSH
53773: PPUSH
// if not units or not class then
53774: LD_VAR 0 1
53778: NOT
53779: PUSH
53780: LD_VAR 0 2
53784: NOT
53785: OR
53786: IFFALSE 53790
// exit ;
53788: GO 53885
// result := [ ] ;
53790: LD_ADDR_VAR 0 3
53794: PUSH
53795: EMPTY
53796: ST_TO_ADDR
// for un in units do
53797: LD_ADDR_VAR 0 4
53801: PUSH
53802: LD_VAR 0 1
53806: PUSH
53807: FOR_IN
53808: IFFALSE 53883
// if GetClass ( un ) = class then
53810: LD_VAR 0 4
53814: PPUSH
53815: CALL_OW 257
53819: PUSH
53820: LD_VAR 0 2
53824: EQUAL
53825: IFFALSE 53852
// result := Insert ( result , 1 , un ) else
53827: LD_ADDR_VAR 0 3
53831: PUSH
53832: LD_VAR 0 3
53836: PPUSH
53837: LD_INT 1
53839: PPUSH
53840: LD_VAR 0 4
53844: PPUSH
53845: CALL_OW 2
53849: ST_TO_ADDR
53850: GO 53881
// result := Replace ( result , result + 1 , un ) ;
53852: LD_ADDR_VAR 0 3
53856: PUSH
53857: LD_VAR 0 3
53861: PPUSH
53862: LD_VAR 0 3
53866: PUSH
53867: LD_INT 1
53869: PLUS
53870: PPUSH
53871: LD_VAR 0 4
53875: PPUSH
53876: CALL_OW 1
53880: ST_TO_ADDR
53881: GO 53807
53883: POP
53884: POP
// end ;
53885: LD_VAR 0 3
53889: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
53890: LD_INT 0
53892: PPUSH
53893: PPUSH
53894: PPUSH
53895: PPUSH
53896: PPUSH
53897: PPUSH
53898: PPUSH
// result := [ ] ;
53899: LD_ADDR_VAR 0 4
53903: PUSH
53904: EMPTY
53905: ST_TO_ADDR
// if x - r < 0 then
53906: LD_VAR 0 1
53910: PUSH
53911: LD_VAR 0 3
53915: MINUS
53916: PUSH
53917: LD_INT 0
53919: LESS
53920: IFFALSE 53932
// min_x := 0 else
53922: LD_ADDR_VAR 0 8
53926: PUSH
53927: LD_INT 0
53929: ST_TO_ADDR
53930: GO 53948
// min_x := x - r ;
53932: LD_ADDR_VAR 0 8
53936: PUSH
53937: LD_VAR 0 1
53941: PUSH
53942: LD_VAR 0 3
53946: MINUS
53947: ST_TO_ADDR
// if y - r < 0 then
53948: LD_VAR 0 2
53952: PUSH
53953: LD_VAR 0 3
53957: MINUS
53958: PUSH
53959: LD_INT 0
53961: LESS
53962: IFFALSE 53974
// min_y := 0 else
53964: LD_ADDR_VAR 0 7
53968: PUSH
53969: LD_INT 0
53971: ST_TO_ADDR
53972: GO 53990
// min_y := y - r ;
53974: LD_ADDR_VAR 0 7
53978: PUSH
53979: LD_VAR 0 2
53983: PUSH
53984: LD_VAR 0 3
53988: MINUS
53989: ST_TO_ADDR
// max_x := x + r ;
53990: LD_ADDR_VAR 0 9
53994: PUSH
53995: LD_VAR 0 1
53999: PUSH
54000: LD_VAR 0 3
54004: PLUS
54005: ST_TO_ADDR
// max_y := y + r ;
54006: LD_ADDR_VAR 0 10
54010: PUSH
54011: LD_VAR 0 2
54015: PUSH
54016: LD_VAR 0 3
54020: PLUS
54021: ST_TO_ADDR
// for _x = min_x to max_x do
54022: LD_ADDR_VAR 0 5
54026: PUSH
54027: DOUBLE
54028: LD_VAR 0 8
54032: DEC
54033: ST_TO_ADDR
54034: LD_VAR 0 9
54038: PUSH
54039: FOR_TO
54040: IFFALSE 54141
// for _y = min_y to max_y do
54042: LD_ADDR_VAR 0 6
54046: PUSH
54047: DOUBLE
54048: LD_VAR 0 7
54052: DEC
54053: ST_TO_ADDR
54054: LD_VAR 0 10
54058: PUSH
54059: FOR_TO
54060: IFFALSE 54137
// begin if not ValidHex ( _x , _y ) then
54062: LD_VAR 0 5
54066: PPUSH
54067: LD_VAR 0 6
54071: PPUSH
54072: CALL_OW 488
54076: NOT
54077: IFFALSE 54081
// continue ;
54079: GO 54059
// if GetResourceTypeXY ( _x , _y ) then
54081: LD_VAR 0 5
54085: PPUSH
54086: LD_VAR 0 6
54090: PPUSH
54091: CALL_OW 283
54095: IFFALSE 54135
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54097: LD_ADDR_VAR 0 4
54101: PUSH
54102: LD_VAR 0 4
54106: PPUSH
54107: LD_VAR 0 4
54111: PUSH
54112: LD_INT 1
54114: PLUS
54115: PPUSH
54116: LD_VAR 0 5
54120: PUSH
54121: LD_VAR 0 6
54125: PUSH
54126: EMPTY
54127: LIST
54128: LIST
54129: PPUSH
54130: CALL_OW 1
54134: ST_TO_ADDR
// end ;
54135: GO 54059
54137: POP
54138: POP
54139: GO 54039
54141: POP
54142: POP
// end ;
54143: LD_VAR 0 4
54147: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54148: LD_INT 0
54150: PPUSH
54151: PPUSH
54152: PPUSH
54153: PPUSH
54154: PPUSH
54155: PPUSH
54156: PPUSH
54157: PPUSH
// if not units then
54158: LD_VAR 0 1
54162: NOT
54163: IFFALSE 54167
// exit ;
54165: GO 54592
// result := UnitFilter ( units , [ f_ok ] ) ;
54167: LD_ADDR_VAR 0 3
54171: PUSH
54172: LD_VAR 0 1
54176: PPUSH
54177: LD_INT 50
54179: PUSH
54180: EMPTY
54181: LIST
54182: PPUSH
54183: CALL_OW 72
54187: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54188: LD_ADDR_VAR 0 8
54192: PUSH
54193: LD_VAR 0 1
54197: PUSH
54198: LD_INT 1
54200: ARRAY
54201: PPUSH
54202: CALL_OW 255
54206: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
54207: LD_ADDR_VAR 0 10
54211: PUSH
54212: LD_INT 29
54214: PUSH
54215: LD_EXP 108
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: ST_TO_ADDR
// if not result then
54224: LD_VAR 0 3
54228: NOT
54229: IFFALSE 54233
// exit ;
54231: GO 54592
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54233: LD_ADDR_VAR 0 5
54237: PUSH
54238: LD_INT 81
54240: PUSH
54241: LD_VAR 0 8
54245: PUSH
54246: EMPTY
54247: LIST
54248: LIST
54249: PPUSH
54250: CALL_OW 69
54254: ST_TO_ADDR
// for i in result do
54255: LD_ADDR_VAR 0 4
54259: PUSH
54260: LD_VAR 0 3
54264: PUSH
54265: FOR_IN
54266: IFFALSE 54590
// begin tag := GetTag ( i ) + 1 ;
54268: LD_ADDR_VAR 0 9
54272: PUSH
54273: LD_VAR 0 4
54277: PPUSH
54278: CALL_OW 110
54282: PUSH
54283: LD_INT 1
54285: PLUS
54286: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
54287: LD_ADDR_VAR 0 7
54291: PUSH
54292: LD_VAR 0 4
54296: PPUSH
54297: CALL_OW 250
54301: PPUSH
54302: LD_VAR 0 4
54306: PPUSH
54307: CALL_OW 251
54311: PPUSH
54312: LD_INT 6
54314: PPUSH
54315: CALL 53890 0 3
54319: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
54320: LD_VAR 0 7
54324: PUSH
54325: LD_VAR 0 4
54329: PPUSH
54330: CALL_OW 264
54334: PUSH
54335: LD_VAR 0 10
54339: IN
54340: NOT
54341: AND
54342: IFFALSE 54381
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
54344: LD_VAR 0 4
54348: PPUSH
54349: LD_VAR 0 7
54353: PUSH
54354: LD_INT 1
54356: ARRAY
54357: PUSH
54358: LD_INT 1
54360: ARRAY
54361: PPUSH
54362: LD_VAR 0 7
54366: PUSH
54367: LD_INT 1
54369: ARRAY
54370: PUSH
54371: LD_INT 2
54373: ARRAY
54374: PPUSH
54375: CALL_OW 116
54379: GO 54588
// if path > tag then
54381: LD_VAR 0 2
54385: PUSH
54386: LD_VAR 0 9
54390: GREATER
54391: IFFALSE 54558
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
54393: LD_ADDR_VAR 0 6
54397: PUSH
54398: LD_VAR 0 5
54402: PPUSH
54403: LD_INT 91
54405: PUSH
54406: LD_VAR 0 4
54410: PUSH
54411: LD_INT 12
54413: PUSH
54414: EMPTY
54415: LIST
54416: LIST
54417: LIST
54418: PPUSH
54419: CALL_OW 72
54423: ST_TO_ADDR
// if nearEnemy then
54424: LD_VAR 0 6
54428: IFFALSE 54456
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
54430: LD_VAR 0 4
54434: PPUSH
54435: LD_VAR 0 6
54439: PPUSH
54440: LD_VAR 0 4
54444: PPUSH
54445: CALL_OW 74
54449: PPUSH
54450: CALL_OW 115
54454: GO 54556
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
54456: LD_VAR 0 4
54460: PPUSH
54461: LD_VAR 0 2
54465: PUSH
54466: LD_VAR 0 9
54470: ARRAY
54471: PUSH
54472: LD_INT 1
54474: ARRAY
54475: PPUSH
54476: LD_VAR 0 2
54480: PUSH
54481: LD_VAR 0 9
54485: ARRAY
54486: PUSH
54487: LD_INT 2
54489: ARRAY
54490: PPUSH
54491: CALL_OW 297
54495: PUSH
54496: LD_INT 6
54498: GREATER
54499: IFFALSE 54542
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
54501: LD_VAR 0 4
54505: PPUSH
54506: LD_VAR 0 2
54510: PUSH
54511: LD_VAR 0 9
54515: ARRAY
54516: PUSH
54517: LD_INT 1
54519: ARRAY
54520: PPUSH
54521: LD_VAR 0 2
54525: PUSH
54526: LD_VAR 0 9
54530: ARRAY
54531: PUSH
54532: LD_INT 2
54534: ARRAY
54535: PPUSH
54536: CALL_OW 114
54540: GO 54556
// SetTag ( i , tag ) ;
54542: LD_VAR 0 4
54546: PPUSH
54547: LD_VAR 0 9
54551: PPUSH
54552: CALL_OW 109
// end else
54556: GO 54588
// if enemy then
54558: LD_VAR 0 5
54562: IFFALSE 54588
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
54564: LD_VAR 0 4
54568: PPUSH
54569: LD_VAR 0 5
54573: PPUSH
54574: LD_VAR 0 4
54578: PPUSH
54579: CALL_OW 74
54583: PPUSH
54584: CALL_OW 115
// end ;
54588: GO 54265
54590: POP
54591: POP
// end ;
54592: LD_VAR 0 3
54596: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
54597: LD_INT 0
54599: PPUSH
54600: PPUSH
54601: PPUSH
// if not unit or IsInUnit ( unit ) then
54602: LD_VAR 0 1
54606: NOT
54607: PUSH
54608: LD_VAR 0 1
54612: PPUSH
54613: CALL_OW 310
54617: OR
54618: IFFALSE 54622
// exit ;
54620: GO 54713
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
54622: LD_ADDR_VAR 0 4
54626: PUSH
54627: LD_VAR 0 1
54631: PPUSH
54632: CALL_OW 250
54636: PPUSH
54637: LD_VAR 0 2
54641: PPUSH
54642: LD_INT 1
54644: PPUSH
54645: CALL_OW 272
54649: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
54650: LD_ADDR_VAR 0 5
54654: PUSH
54655: LD_VAR 0 1
54659: PPUSH
54660: CALL_OW 251
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: LD_INT 1
54672: PPUSH
54673: CALL_OW 273
54677: ST_TO_ADDR
// if ValidHex ( x , y ) then
54678: LD_VAR 0 4
54682: PPUSH
54683: LD_VAR 0 5
54687: PPUSH
54688: CALL_OW 488
54692: IFFALSE 54713
// ComTurnXY ( unit , x , y ) ;
54694: LD_VAR 0 1
54698: PPUSH
54699: LD_VAR 0 4
54703: PPUSH
54704: LD_VAR 0 5
54708: PPUSH
54709: CALL_OW 118
// end ;
54713: LD_VAR 0 3
54717: RET
// export function SeeUnits ( side , units ) ; var i ; begin
54718: LD_INT 0
54720: PPUSH
54721: PPUSH
// result := false ;
54722: LD_ADDR_VAR 0 3
54726: PUSH
54727: LD_INT 0
54729: ST_TO_ADDR
// if not units then
54730: LD_VAR 0 2
54734: NOT
54735: IFFALSE 54739
// exit ;
54737: GO 54784
// for i in units do
54739: LD_ADDR_VAR 0 4
54743: PUSH
54744: LD_VAR 0 2
54748: PUSH
54749: FOR_IN
54750: IFFALSE 54782
// if See ( side , i ) then
54752: LD_VAR 0 1
54756: PPUSH
54757: LD_VAR 0 4
54761: PPUSH
54762: CALL_OW 292
54766: IFFALSE 54780
// begin result := true ;
54768: LD_ADDR_VAR 0 3
54772: PUSH
54773: LD_INT 1
54775: ST_TO_ADDR
// exit ;
54776: POP
54777: POP
54778: GO 54784
// end ;
54780: GO 54749
54782: POP
54783: POP
// end ;
54784: LD_VAR 0 3
54788: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
54789: LD_INT 0
54791: PPUSH
54792: PPUSH
54793: PPUSH
54794: PPUSH
// if not unit or not points then
54795: LD_VAR 0 1
54799: NOT
54800: PUSH
54801: LD_VAR 0 2
54805: NOT
54806: OR
54807: IFFALSE 54811
// exit ;
54809: GO 54901
// dist := 99999 ;
54811: LD_ADDR_VAR 0 5
54815: PUSH
54816: LD_INT 99999
54818: ST_TO_ADDR
// for i in points do
54819: LD_ADDR_VAR 0 4
54823: PUSH
54824: LD_VAR 0 2
54828: PUSH
54829: FOR_IN
54830: IFFALSE 54899
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54832: LD_ADDR_VAR 0 6
54836: PUSH
54837: LD_VAR 0 1
54841: PPUSH
54842: LD_VAR 0 4
54846: PUSH
54847: LD_INT 1
54849: ARRAY
54850: PPUSH
54851: LD_VAR 0 4
54855: PUSH
54856: LD_INT 2
54858: ARRAY
54859: PPUSH
54860: CALL_OW 297
54864: ST_TO_ADDR
// if tmpDist < dist then
54865: LD_VAR 0 6
54869: PUSH
54870: LD_VAR 0 5
54874: LESS
54875: IFFALSE 54897
// begin result := i ;
54877: LD_ADDR_VAR 0 3
54881: PUSH
54882: LD_VAR 0 4
54886: ST_TO_ADDR
// dist := tmpDist ;
54887: LD_ADDR_VAR 0 5
54891: PUSH
54892: LD_VAR 0 6
54896: ST_TO_ADDR
// end ; end ;
54897: GO 54829
54899: POP
54900: POP
// end ; end_of_file
54901: LD_VAR 0 3
54905: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
54906: LD_INT 0
54908: PPUSH
54909: PPUSH
// skirmish := false ;
54910: LD_ADDR_EXP 58
54914: PUSH
54915: LD_INT 0
54917: ST_TO_ADDR
// debug_mc := false ;
54918: LD_ADDR_EXP 59
54922: PUSH
54923: LD_INT 0
54925: ST_TO_ADDR
// mc_bases := [ ] ;
54926: LD_ADDR_EXP 60
54930: PUSH
54931: EMPTY
54932: ST_TO_ADDR
// mc_sides := [ ] ;
54933: LD_ADDR_EXP 86
54937: PUSH
54938: EMPTY
54939: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
54940: LD_ADDR_EXP 61
54944: PUSH
54945: EMPTY
54946: ST_TO_ADDR
// mc_building_repairs := [ ] ;
54947: LD_ADDR_EXP 62
54951: PUSH
54952: EMPTY
54953: ST_TO_ADDR
// mc_need_heal := [ ] ;
54954: LD_ADDR_EXP 63
54958: PUSH
54959: EMPTY
54960: ST_TO_ADDR
// mc_healers := [ ] ;
54961: LD_ADDR_EXP 64
54965: PUSH
54966: EMPTY
54967: ST_TO_ADDR
// mc_build_list := [ ] ;
54968: LD_ADDR_EXP 65
54972: PUSH
54973: EMPTY
54974: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
54975: LD_ADDR_EXP 92
54979: PUSH
54980: EMPTY
54981: ST_TO_ADDR
// mc_builders := [ ] ;
54982: LD_ADDR_EXP 66
54986: PUSH
54987: EMPTY
54988: ST_TO_ADDR
// mc_construct_list := [ ] ;
54989: LD_ADDR_EXP 67
54993: PUSH
54994: EMPTY
54995: ST_TO_ADDR
// mc_turret_list := [ ] ;
54996: LD_ADDR_EXP 68
55000: PUSH
55001: EMPTY
55002: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
55003: LD_ADDR_EXP 69
55007: PUSH
55008: EMPTY
55009: ST_TO_ADDR
// mc_miners := [ ] ;
55010: LD_ADDR_EXP 74
55014: PUSH
55015: EMPTY
55016: ST_TO_ADDR
// mc_mines := [ ] ;
55017: LD_ADDR_EXP 73
55021: PUSH
55022: EMPTY
55023: ST_TO_ADDR
// mc_minefields := [ ] ;
55024: LD_ADDR_EXP 75
55028: PUSH
55029: EMPTY
55030: ST_TO_ADDR
// mc_crates := [ ] ;
55031: LD_ADDR_EXP 76
55035: PUSH
55036: EMPTY
55037: ST_TO_ADDR
// mc_crates_collector := [ ] ;
55038: LD_ADDR_EXP 77
55042: PUSH
55043: EMPTY
55044: ST_TO_ADDR
// mc_crates_area := [ ] ;
55045: LD_ADDR_EXP 78
55049: PUSH
55050: EMPTY
55051: ST_TO_ADDR
// mc_vehicles := [ ] ;
55052: LD_ADDR_EXP 79
55056: PUSH
55057: EMPTY
55058: ST_TO_ADDR
// mc_attack := [ ] ;
55059: LD_ADDR_EXP 80
55063: PUSH
55064: EMPTY
55065: ST_TO_ADDR
// mc_produce := [ ] ;
55066: LD_ADDR_EXP 81
55070: PUSH
55071: EMPTY
55072: ST_TO_ADDR
// mc_defender := [ ] ;
55073: LD_ADDR_EXP 82
55077: PUSH
55078: EMPTY
55079: ST_TO_ADDR
// mc_parking := [ ] ;
55080: LD_ADDR_EXP 84
55084: PUSH
55085: EMPTY
55086: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
55087: LD_ADDR_EXP 70
55091: PUSH
55092: EMPTY
55093: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
55094: LD_ADDR_EXP 72
55098: PUSH
55099: EMPTY
55100: ST_TO_ADDR
// mc_scan := [ ] ;
55101: LD_ADDR_EXP 83
55105: PUSH
55106: EMPTY
55107: ST_TO_ADDR
// mc_scan_area := [ ] ;
55108: LD_ADDR_EXP 85
55112: PUSH
55113: EMPTY
55114: ST_TO_ADDR
// mc_tech := [ ] ;
55115: LD_ADDR_EXP 87
55119: PUSH
55120: EMPTY
55121: ST_TO_ADDR
// mc_class := [ ] ;
55122: LD_ADDR_EXP 101
55126: PUSH
55127: EMPTY
55128: ST_TO_ADDR
// mc_class_case_use := [ ] ;
55129: LD_ADDR_EXP 102
55133: PUSH
55134: EMPTY
55135: ST_TO_ADDR
// mc_is_defending := [ ] ;
55136: LD_ADDR_EXP 103
55140: PUSH
55141: EMPTY
55142: ST_TO_ADDR
// end ;
55143: LD_VAR 0 1
55147: RET
// export function MC_Kill ( base ) ; begin
55148: LD_INT 0
55150: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
55151: LD_ADDR_EXP 60
55155: PUSH
55156: LD_EXP 60
55160: PPUSH
55161: LD_VAR 0 1
55165: PPUSH
55166: EMPTY
55167: PPUSH
55168: CALL_OW 1
55172: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
55173: LD_ADDR_EXP 61
55177: PUSH
55178: LD_EXP 61
55182: PPUSH
55183: LD_VAR 0 1
55187: PPUSH
55188: EMPTY
55189: PPUSH
55190: CALL_OW 1
55194: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
55195: LD_ADDR_EXP 62
55199: PUSH
55200: LD_EXP 62
55204: PPUSH
55205: LD_VAR 0 1
55209: PPUSH
55210: EMPTY
55211: PPUSH
55212: CALL_OW 1
55216: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
55217: LD_ADDR_EXP 63
55221: PUSH
55222: LD_EXP 63
55226: PPUSH
55227: LD_VAR 0 1
55231: PPUSH
55232: EMPTY
55233: PPUSH
55234: CALL_OW 1
55238: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
55239: LD_ADDR_EXP 64
55243: PUSH
55244: LD_EXP 64
55248: PPUSH
55249: LD_VAR 0 1
55253: PPUSH
55254: EMPTY
55255: PPUSH
55256: CALL_OW 1
55260: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
55261: LD_ADDR_EXP 65
55265: PUSH
55266: LD_EXP 65
55270: PPUSH
55271: LD_VAR 0 1
55275: PPUSH
55276: EMPTY
55277: PPUSH
55278: CALL_OW 1
55282: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
55283: LD_ADDR_EXP 66
55287: PUSH
55288: LD_EXP 66
55292: PPUSH
55293: LD_VAR 0 1
55297: PPUSH
55298: EMPTY
55299: PPUSH
55300: CALL_OW 1
55304: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
55305: LD_ADDR_EXP 67
55309: PUSH
55310: LD_EXP 67
55314: PPUSH
55315: LD_VAR 0 1
55319: PPUSH
55320: EMPTY
55321: PPUSH
55322: CALL_OW 1
55326: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
55327: LD_ADDR_EXP 68
55331: PUSH
55332: LD_EXP 68
55336: PPUSH
55337: LD_VAR 0 1
55341: PPUSH
55342: EMPTY
55343: PPUSH
55344: CALL_OW 1
55348: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
55349: LD_ADDR_EXP 69
55353: PUSH
55354: LD_EXP 69
55358: PPUSH
55359: LD_VAR 0 1
55363: PPUSH
55364: EMPTY
55365: PPUSH
55366: CALL_OW 1
55370: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
55371: LD_ADDR_EXP 70
55375: PUSH
55376: LD_EXP 70
55380: PPUSH
55381: LD_VAR 0 1
55385: PPUSH
55386: EMPTY
55387: PPUSH
55388: CALL_OW 1
55392: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
55393: LD_ADDR_EXP 71
55397: PUSH
55398: LD_EXP 71
55402: PPUSH
55403: LD_VAR 0 1
55407: PPUSH
55408: LD_INT 0
55410: PPUSH
55411: CALL_OW 1
55415: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
55416: LD_ADDR_EXP 72
55420: PUSH
55421: LD_EXP 72
55425: PPUSH
55426: LD_VAR 0 1
55430: PPUSH
55431: EMPTY
55432: PPUSH
55433: CALL_OW 1
55437: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
55438: LD_ADDR_EXP 73
55442: PUSH
55443: LD_EXP 73
55447: PPUSH
55448: LD_VAR 0 1
55452: PPUSH
55453: EMPTY
55454: PPUSH
55455: CALL_OW 1
55459: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
55460: LD_ADDR_EXP 74
55464: PUSH
55465: LD_EXP 74
55469: PPUSH
55470: LD_VAR 0 1
55474: PPUSH
55475: EMPTY
55476: PPUSH
55477: CALL_OW 1
55481: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
55482: LD_ADDR_EXP 75
55486: PUSH
55487: LD_EXP 75
55491: PPUSH
55492: LD_VAR 0 1
55496: PPUSH
55497: EMPTY
55498: PPUSH
55499: CALL_OW 1
55503: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
55504: LD_ADDR_EXP 76
55508: PUSH
55509: LD_EXP 76
55513: PPUSH
55514: LD_VAR 0 1
55518: PPUSH
55519: EMPTY
55520: PPUSH
55521: CALL_OW 1
55525: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
55526: LD_ADDR_EXP 77
55530: PUSH
55531: LD_EXP 77
55535: PPUSH
55536: LD_VAR 0 1
55540: PPUSH
55541: EMPTY
55542: PPUSH
55543: CALL_OW 1
55547: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
55548: LD_ADDR_EXP 78
55552: PUSH
55553: LD_EXP 78
55557: PPUSH
55558: LD_VAR 0 1
55562: PPUSH
55563: EMPTY
55564: PPUSH
55565: CALL_OW 1
55569: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
55570: LD_ADDR_EXP 79
55574: PUSH
55575: LD_EXP 79
55579: PPUSH
55580: LD_VAR 0 1
55584: PPUSH
55585: EMPTY
55586: PPUSH
55587: CALL_OW 1
55591: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
55592: LD_ADDR_EXP 80
55596: PUSH
55597: LD_EXP 80
55601: PPUSH
55602: LD_VAR 0 1
55606: PPUSH
55607: EMPTY
55608: PPUSH
55609: CALL_OW 1
55613: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
55614: LD_ADDR_EXP 81
55618: PUSH
55619: LD_EXP 81
55623: PPUSH
55624: LD_VAR 0 1
55628: PPUSH
55629: EMPTY
55630: PPUSH
55631: CALL_OW 1
55635: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
55636: LD_ADDR_EXP 82
55640: PUSH
55641: LD_EXP 82
55645: PPUSH
55646: LD_VAR 0 1
55650: PPUSH
55651: EMPTY
55652: PPUSH
55653: CALL_OW 1
55657: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
55658: LD_ADDR_EXP 83
55662: PUSH
55663: LD_EXP 83
55667: PPUSH
55668: LD_VAR 0 1
55672: PPUSH
55673: EMPTY
55674: PPUSH
55675: CALL_OW 1
55679: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
55680: LD_ADDR_EXP 84
55684: PUSH
55685: LD_EXP 84
55689: PPUSH
55690: LD_VAR 0 1
55694: PPUSH
55695: EMPTY
55696: PPUSH
55697: CALL_OW 1
55701: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
55702: LD_ADDR_EXP 85
55706: PUSH
55707: LD_EXP 85
55711: PPUSH
55712: LD_VAR 0 1
55716: PPUSH
55717: EMPTY
55718: PPUSH
55719: CALL_OW 1
55723: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
55724: LD_ADDR_EXP 87
55728: PUSH
55729: LD_EXP 87
55733: PPUSH
55734: LD_VAR 0 1
55738: PPUSH
55739: EMPTY
55740: PPUSH
55741: CALL_OW 1
55745: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
55746: LD_ADDR_EXP 89
55750: PUSH
55751: LD_EXP 89
55755: PPUSH
55756: LD_VAR 0 1
55760: PPUSH
55761: EMPTY
55762: PPUSH
55763: CALL_OW 1
55767: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
55768: LD_ADDR_EXP 90
55772: PUSH
55773: LD_EXP 90
55777: PPUSH
55778: LD_VAR 0 1
55782: PPUSH
55783: EMPTY
55784: PPUSH
55785: CALL_OW 1
55789: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
55790: LD_ADDR_EXP 91
55794: PUSH
55795: LD_EXP 91
55799: PPUSH
55800: LD_VAR 0 1
55804: PPUSH
55805: EMPTY
55806: PPUSH
55807: CALL_OW 1
55811: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
55812: LD_ADDR_EXP 92
55816: PUSH
55817: LD_EXP 92
55821: PPUSH
55822: LD_VAR 0 1
55826: PPUSH
55827: EMPTY
55828: PPUSH
55829: CALL_OW 1
55833: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
55834: LD_ADDR_EXP 93
55838: PUSH
55839: LD_EXP 93
55843: PPUSH
55844: LD_VAR 0 1
55848: PPUSH
55849: EMPTY
55850: PPUSH
55851: CALL_OW 1
55855: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
55856: LD_ADDR_EXP 94
55860: PUSH
55861: LD_EXP 94
55865: PPUSH
55866: LD_VAR 0 1
55870: PPUSH
55871: EMPTY
55872: PPUSH
55873: CALL_OW 1
55877: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
55878: LD_ADDR_EXP 95
55882: PUSH
55883: LD_EXP 95
55887: PPUSH
55888: LD_VAR 0 1
55892: PPUSH
55893: EMPTY
55894: PPUSH
55895: CALL_OW 1
55899: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
55900: LD_ADDR_EXP 96
55904: PUSH
55905: LD_EXP 96
55909: PPUSH
55910: LD_VAR 0 1
55914: PPUSH
55915: EMPTY
55916: PPUSH
55917: CALL_OW 1
55921: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
55922: LD_ADDR_EXP 97
55926: PUSH
55927: LD_EXP 97
55931: PPUSH
55932: LD_VAR 0 1
55936: PPUSH
55937: EMPTY
55938: PPUSH
55939: CALL_OW 1
55943: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
55944: LD_ADDR_EXP 98
55948: PUSH
55949: LD_EXP 98
55953: PPUSH
55954: LD_VAR 0 1
55958: PPUSH
55959: EMPTY
55960: PPUSH
55961: CALL_OW 1
55965: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
55966: LD_ADDR_EXP 99
55970: PUSH
55971: LD_EXP 99
55975: PPUSH
55976: LD_VAR 0 1
55980: PPUSH
55981: EMPTY
55982: PPUSH
55983: CALL_OW 1
55987: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
55988: LD_ADDR_EXP 100
55992: PUSH
55993: LD_EXP 100
55997: PPUSH
55998: LD_VAR 0 1
56002: PPUSH
56003: EMPTY
56004: PPUSH
56005: CALL_OW 1
56009: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56010: LD_ADDR_EXP 101
56014: PUSH
56015: LD_EXP 101
56019: PPUSH
56020: LD_VAR 0 1
56024: PPUSH
56025: EMPTY
56026: PPUSH
56027: CALL_OW 1
56031: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
56032: LD_ADDR_EXP 102
56036: PUSH
56037: LD_EXP 102
56041: PPUSH
56042: LD_VAR 0 1
56046: PPUSH
56047: LD_INT 0
56049: PPUSH
56050: CALL_OW 1
56054: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
56055: LD_ADDR_EXP 103
56059: PUSH
56060: LD_EXP 103
56064: PPUSH
56065: LD_VAR 0 1
56069: PPUSH
56070: LD_INT 0
56072: PPUSH
56073: CALL_OW 1
56077: ST_TO_ADDR
// end ;
56078: LD_VAR 0 2
56082: RET
// export function MC_Add ( side , units ) ; var base ; begin
56083: LD_INT 0
56085: PPUSH
56086: PPUSH
// base := mc_bases + 1 ;
56087: LD_ADDR_VAR 0 4
56091: PUSH
56092: LD_EXP 60
56096: PUSH
56097: LD_INT 1
56099: PLUS
56100: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
56101: LD_ADDR_EXP 86
56105: PUSH
56106: LD_EXP 86
56110: PPUSH
56111: LD_VAR 0 4
56115: PPUSH
56116: LD_VAR 0 1
56120: PPUSH
56121: CALL_OW 1
56125: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
56126: LD_ADDR_EXP 60
56130: PUSH
56131: LD_EXP 60
56135: PPUSH
56136: LD_VAR 0 4
56140: PPUSH
56141: LD_VAR 0 2
56145: PPUSH
56146: CALL_OW 1
56150: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56151: LD_ADDR_EXP 61
56155: PUSH
56156: LD_EXP 61
56160: PPUSH
56161: LD_VAR 0 4
56165: PPUSH
56166: EMPTY
56167: PPUSH
56168: CALL_OW 1
56172: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56173: LD_ADDR_EXP 62
56177: PUSH
56178: LD_EXP 62
56182: PPUSH
56183: LD_VAR 0 4
56187: PPUSH
56188: EMPTY
56189: PPUSH
56190: CALL_OW 1
56194: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56195: LD_ADDR_EXP 63
56199: PUSH
56200: LD_EXP 63
56204: PPUSH
56205: LD_VAR 0 4
56209: PPUSH
56210: EMPTY
56211: PPUSH
56212: CALL_OW 1
56216: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56217: LD_ADDR_EXP 64
56221: PUSH
56222: LD_EXP 64
56226: PPUSH
56227: LD_VAR 0 4
56231: PPUSH
56232: EMPTY
56233: PPUSH
56234: CALL_OW 1
56238: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56239: LD_ADDR_EXP 65
56243: PUSH
56244: LD_EXP 65
56248: PPUSH
56249: LD_VAR 0 4
56253: PPUSH
56254: EMPTY
56255: PPUSH
56256: CALL_OW 1
56260: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56261: LD_ADDR_EXP 66
56265: PUSH
56266: LD_EXP 66
56270: PPUSH
56271: LD_VAR 0 4
56275: PPUSH
56276: EMPTY
56277: PPUSH
56278: CALL_OW 1
56282: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56283: LD_ADDR_EXP 67
56287: PUSH
56288: LD_EXP 67
56292: PPUSH
56293: LD_VAR 0 4
56297: PPUSH
56298: EMPTY
56299: PPUSH
56300: CALL_OW 1
56304: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56305: LD_ADDR_EXP 68
56309: PUSH
56310: LD_EXP 68
56314: PPUSH
56315: LD_VAR 0 4
56319: PPUSH
56320: EMPTY
56321: PPUSH
56322: CALL_OW 1
56326: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56327: LD_ADDR_EXP 69
56331: PUSH
56332: LD_EXP 69
56336: PPUSH
56337: LD_VAR 0 4
56341: PPUSH
56342: EMPTY
56343: PPUSH
56344: CALL_OW 1
56348: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56349: LD_ADDR_EXP 70
56353: PUSH
56354: LD_EXP 70
56358: PPUSH
56359: LD_VAR 0 4
56363: PPUSH
56364: EMPTY
56365: PPUSH
56366: CALL_OW 1
56370: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56371: LD_ADDR_EXP 71
56375: PUSH
56376: LD_EXP 71
56380: PPUSH
56381: LD_VAR 0 4
56385: PPUSH
56386: LD_INT 0
56388: PPUSH
56389: CALL_OW 1
56393: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56394: LD_ADDR_EXP 72
56398: PUSH
56399: LD_EXP 72
56403: PPUSH
56404: LD_VAR 0 4
56408: PPUSH
56409: EMPTY
56410: PPUSH
56411: CALL_OW 1
56415: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56416: LD_ADDR_EXP 73
56420: PUSH
56421: LD_EXP 73
56425: PPUSH
56426: LD_VAR 0 4
56430: PPUSH
56431: EMPTY
56432: PPUSH
56433: CALL_OW 1
56437: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56438: LD_ADDR_EXP 74
56442: PUSH
56443: LD_EXP 74
56447: PPUSH
56448: LD_VAR 0 4
56452: PPUSH
56453: EMPTY
56454: PPUSH
56455: CALL_OW 1
56459: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56460: LD_ADDR_EXP 75
56464: PUSH
56465: LD_EXP 75
56469: PPUSH
56470: LD_VAR 0 4
56474: PPUSH
56475: EMPTY
56476: PPUSH
56477: CALL_OW 1
56481: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56482: LD_ADDR_EXP 76
56486: PUSH
56487: LD_EXP 76
56491: PPUSH
56492: LD_VAR 0 4
56496: PPUSH
56497: EMPTY
56498: PPUSH
56499: CALL_OW 1
56503: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56504: LD_ADDR_EXP 77
56508: PUSH
56509: LD_EXP 77
56513: PPUSH
56514: LD_VAR 0 4
56518: PPUSH
56519: EMPTY
56520: PPUSH
56521: CALL_OW 1
56525: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56526: LD_ADDR_EXP 78
56530: PUSH
56531: LD_EXP 78
56535: PPUSH
56536: LD_VAR 0 4
56540: PPUSH
56541: EMPTY
56542: PPUSH
56543: CALL_OW 1
56547: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56548: LD_ADDR_EXP 79
56552: PUSH
56553: LD_EXP 79
56557: PPUSH
56558: LD_VAR 0 4
56562: PPUSH
56563: EMPTY
56564: PPUSH
56565: CALL_OW 1
56569: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56570: LD_ADDR_EXP 80
56574: PUSH
56575: LD_EXP 80
56579: PPUSH
56580: LD_VAR 0 4
56584: PPUSH
56585: EMPTY
56586: PPUSH
56587: CALL_OW 1
56591: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56592: LD_ADDR_EXP 81
56596: PUSH
56597: LD_EXP 81
56601: PPUSH
56602: LD_VAR 0 4
56606: PPUSH
56607: EMPTY
56608: PPUSH
56609: CALL_OW 1
56613: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56614: LD_ADDR_EXP 82
56618: PUSH
56619: LD_EXP 82
56623: PPUSH
56624: LD_VAR 0 4
56628: PPUSH
56629: EMPTY
56630: PPUSH
56631: CALL_OW 1
56635: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56636: LD_ADDR_EXP 83
56640: PUSH
56641: LD_EXP 83
56645: PPUSH
56646: LD_VAR 0 4
56650: PPUSH
56651: EMPTY
56652: PPUSH
56653: CALL_OW 1
56657: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56658: LD_ADDR_EXP 84
56662: PUSH
56663: LD_EXP 84
56667: PPUSH
56668: LD_VAR 0 4
56672: PPUSH
56673: EMPTY
56674: PPUSH
56675: CALL_OW 1
56679: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56680: LD_ADDR_EXP 85
56684: PUSH
56685: LD_EXP 85
56689: PPUSH
56690: LD_VAR 0 4
56694: PPUSH
56695: EMPTY
56696: PPUSH
56697: CALL_OW 1
56701: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56702: LD_ADDR_EXP 87
56706: PUSH
56707: LD_EXP 87
56711: PPUSH
56712: LD_VAR 0 4
56716: PPUSH
56717: EMPTY
56718: PPUSH
56719: CALL_OW 1
56723: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56724: LD_ADDR_EXP 89
56728: PUSH
56729: LD_EXP 89
56733: PPUSH
56734: LD_VAR 0 4
56738: PPUSH
56739: EMPTY
56740: PPUSH
56741: CALL_OW 1
56745: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56746: LD_ADDR_EXP 90
56750: PUSH
56751: LD_EXP 90
56755: PPUSH
56756: LD_VAR 0 4
56760: PPUSH
56761: EMPTY
56762: PPUSH
56763: CALL_OW 1
56767: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56768: LD_ADDR_EXP 91
56772: PUSH
56773: LD_EXP 91
56777: PPUSH
56778: LD_VAR 0 4
56782: PPUSH
56783: EMPTY
56784: PPUSH
56785: CALL_OW 1
56789: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56790: LD_ADDR_EXP 92
56794: PUSH
56795: LD_EXP 92
56799: PPUSH
56800: LD_VAR 0 4
56804: PPUSH
56805: EMPTY
56806: PPUSH
56807: CALL_OW 1
56811: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
56812: LD_ADDR_EXP 93
56816: PUSH
56817: LD_EXP 93
56821: PPUSH
56822: LD_VAR 0 4
56826: PPUSH
56827: EMPTY
56828: PPUSH
56829: CALL_OW 1
56833: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
56834: LD_ADDR_EXP 94
56838: PUSH
56839: LD_EXP 94
56843: PPUSH
56844: LD_VAR 0 4
56848: PPUSH
56849: EMPTY
56850: PPUSH
56851: CALL_OW 1
56855: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
56856: LD_ADDR_EXP 95
56860: PUSH
56861: LD_EXP 95
56865: PPUSH
56866: LD_VAR 0 4
56870: PPUSH
56871: EMPTY
56872: PPUSH
56873: CALL_OW 1
56877: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
56878: LD_ADDR_EXP 96
56882: PUSH
56883: LD_EXP 96
56887: PPUSH
56888: LD_VAR 0 4
56892: PPUSH
56893: EMPTY
56894: PPUSH
56895: CALL_OW 1
56899: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
56900: LD_ADDR_EXP 97
56904: PUSH
56905: LD_EXP 97
56909: PPUSH
56910: LD_VAR 0 4
56914: PPUSH
56915: EMPTY
56916: PPUSH
56917: CALL_OW 1
56921: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
56922: LD_ADDR_EXP 98
56926: PUSH
56927: LD_EXP 98
56931: PPUSH
56932: LD_VAR 0 4
56936: PPUSH
56937: EMPTY
56938: PPUSH
56939: CALL_OW 1
56943: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
56944: LD_ADDR_EXP 99
56948: PUSH
56949: LD_EXP 99
56953: PPUSH
56954: LD_VAR 0 4
56958: PPUSH
56959: EMPTY
56960: PPUSH
56961: CALL_OW 1
56965: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
56966: LD_ADDR_EXP 100
56970: PUSH
56971: LD_EXP 100
56975: PPUSH
56976: LD_VAR 0 4
56980: PPUSH
56981: EMPTY
56982: PPUSH
56983: CALL_OW 1
56987: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
56988: LD_ADDR_EXP 101
56992: PUSH
56993: LD_EXP 101
56997: PPUSH
56998: LD_VAR 0 4
57002: PPUSH
57003: EMPTY
57004: PPUSH
57005: CALL_OW 1
57009: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57010: LD_ADDR_EXP 102
57014: PUSH
57015: LD_EXP 102
57019: PPUSH
57020: LD_VAR 0 4
57024: PPUSH
57025: LD_INT 0
57027: PPUSH
57028: CALL_OW 1
57032: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57033: LD_ADDR_EXP 103
57037: PUSH
57038: LD_EXP 103
57042: PPUSH
57043: LD_VAR 0 4
57047: PPUSH
57048: LD_INT 0
57050: PPUSH
57051: CALL_OW 1
57055: ST_TO_ADDR
// result := base ;
57056: LD_ADDR_VAR 0 3
57060: PUSH
57061: LD_VAR 0 4
57065: ST_TO_ADDR
// end ;
57066: LD_VAR 0 3
57070: RET
// export function MC_Start ( ) ; var i ; begin
57071: LD_INT 0
57073: PPUSH
57074: PPUSH
// for i = 1 to mc_bases do
57075: LD_ADDR_VAR 0 2
57079: PUSH
57080: DOUBLE
57081: LD_INT 1
57083: DEC
57084: ST_TO_ADDR
57085: LD_EXP 60
57089: PUSH
57090: FOR_TO
57091: IFFALSE 58191
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
57093: LD_ADDR_EXP 60
57097: PUSH
57098: LD_EXP 60
57102: PPUSH
57103: LD_VAR 0 2
57107: PPUSH
57108: LD_EXP 60
57112: PUSH
57113: LD_VAR 0 2
57117: ARRAY
57118: PUSH
57119: LD_INT 0
57121: DIFF
57122: PPUSH
57123: CALL_OW 1
57127: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
57128: LD_ADDR_EXP 61
57132: PUSH
57133: LD_EXP 61
57137: PPUSH
57138: LD_VAR 0 2
57142: PPUSH
57143: EMPTY
57144: PPUSH
57145: CALL_OW 1
57149: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
57150: LD_ADDR_EXP 62
57154: PUSH
57155: LD_EXP 62
57159: PPUSH
57160: LD_VAR 0 2
57164: PPUSH
57165: EMPTY
57166: PPUSH
57167: CALL_OW 1
57171: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
57172: LD_ADDR_EXP 63
57176: PUSH
57177: LD_EXP 63
57181: PPUSH
57182: LD_VAR 0 2
57186: PPUSH
57187: EMPTY
57188: PPUSH
57189: CALL_OW 1
57193: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
57194: LD_ADDR_EXP 64
57198: PUSH
57199: LD_EXP 64
57203: PPUSH
57204: LD_VAR 0 2
57208: PPUSH
57209: EMPTY
57210: PUSH
57211: EMPTY
57212: PUSH
57213: EMPTY
57214: LIST
57215: LIST
57216: PPUSH
57217: CALL_OW 1
57221: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
57222: LD_ADDR_EXP 65
57226: PUSH
57227: LD_EXP 65
57231: PPUSH
57232: LD_VAR 0 2
57236: PPUSH
57237: EMPTY
57238: PPUSH
57239: CALL_OW 1
57243: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
57244: LD_ADDR_EXP 92
57248: PUSH
57249: LD_EXP 92
57253: PPUSH
57254: LD_VAR 0 2
57258: PPUSH
57259: EMPTY
57260: PPUSH
57261: CALL_OW 1
57265: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
57266: LD_ADDR_EXP 66
57270: PUSH
57271: LD_EXP 66
57275: PPUSH
57276: LD_VAR 0 2
57280: PPUSH
57281: EMPTY
57282: PPUSH
57283: CALL_OW 1
57287: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
57288: LD_ADDR_EXP 67
57292: PUSH
57293: LD_EXP 67
57297: PPUSH
57298: LD_VAR 0 2
57302: PPUSH
57303: EMPTY
57304: PPUSH
57305: CALL_OW 1
57309: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
57310: LD_ADDR_EXP 68
57314: PUSH
57315: LD_EXP 68
57319: PPUSH
57320: LD_VAR 0 2
57324: PPUSH
57325: LD_EXP 60
57329: PUSH
57330: LD_VAR 0 2
57334: ARRAY
57335: PPUSH
57336: LD_INT 2
57338: PUSH
57339: LD_INT 30
57341: PUSH
57342: LD_INT 32
57344: PUSH
57345: EMPTY
57346: LIST
57347: LIST
57348: PUSH
57349: LD_INT 30
57351: PUSH
57352: LD_INT 33
57354: PUSH
57355: EMPTY
57356: LIST
57357: LIST
57358: PUSH
57359: EMPTY
57360: LIST
57361: LIST
57362: LIST
57363: PPUSH
57364: CALL_OW 72
57368: PPUSH
57369: CALL_OW 1
57373: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
57374: LD_ADDR_EXP 69
57378: PUSH
57379: LD_EXP 69
57383: PPUSH
57384: LD_VAR 0 2
57388: PPUSH
57389: LD_EXP 60
57393: PUSH
57394: LD_VAR 0 2
57398: ARRAY
57399: PPUSH
57400: LD_INT 2
57402: PUSH
57403: LD_INT 30
57405: PUSH
57406: LD_INT 32
57408: PUSH
57409: EMPTY
57410: LIST
57411: LIST
57412: PUSH
57413: LD_INT 30
57415: PUSH
57416: LD_INT 31
57418: PUSH
57419: EMPTY
57420: LIST
57421: LIST
57422: PUSH
57423: EMPTY
57424: LIST
57425: LIST
57426: LIST
57427: PUSH
57428: LD_INT 58
57430: PUSH
57431: EMPTY
57432: LIST
57433: PUSH
57434: EMPTY
57435: LIST
57436: LIST
57437: PPUSH
57438: CALL_OW 72
57442: PPUSH
57443: CALL_OW 1
57447: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
57448: LD_ADDR_EXP 70
57452: PUSH
57453: LD_EXP 70
57457: PPUSH
57458: LD_VAR 0 2
57462: PPUSH
57463: EMPTY
57464: PPUSH
57465: CALL_OW 1
57469: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
57470: LD_ADDR_EXP 74
57474: PUSH
57475: LD_EXP 74
57479: PPUSH
57480: LD_VAR 0 2
57484: PPUSH
57485: EMPTY
57486: PPUSH
57487: CALL_OW 1
57491: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
57492: LD_ADDR_EXP 73
57496: PUSH
57497: LD_EXP 73
57501: PPUSH
57502: LD_VAR 0 2
57506: PPUSH
57507: EMPTY
57508: PPUSH
57509: CALL_OW 1
57513: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
57514: LD_ADDR_EXP 75
57518: PUSH
57519: LD_EXP 75
57523: PPUSH
57524: LD_VAR 0 2
57528: PPUSH
57529: EMPTY
57530: PPUSH
57531: CALL_OW 1
57535: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
57536: LD_ADDR_EXP 76
57540: PUSH
57541: LD_EXP 76
57545: PPUSH
57546: LD_VAR 0 2
57550: PPUSH
57551: EMPTY
57552: PPUSH
57553: CALL_OW 1
57557: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
57558: LD_ADDR_EXP 77
57562: PUSH
57563: LD_EXP 77
57567: PPUSH
57568: LD_VAR 0 2
57572: PPUSH
57573: EMPTY
57574: PPUSH
57575: CALL_OW 1
57579: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
57580: LD_ADDR_EXP 78
57584: PUSH
57585: LD_EXP 78
57589: PPUSH
57590: LD_VAR 0 2
57594: PPUSH
57595: EMPTY
57596: PPUSH
57597: CALL_OW 1
57601: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
57602: LD_ADDR_EXP 79
57606: PUSH
57607: LD_EXP 79
57611: PPUSH
57612: LD_VAR 0 2
57616: PPUSH
57617: EMPTY
57618: PPUSH
57619: CALL_OW 1
57623: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
57624: LD_ADDR_EXP 80
57628: PUSH
57629: LD_EXP 80
57633: PPUSH
57634: LD_VAR 0 2
57638: PPUSH
57639: EMPTY
57640: PPUSH
57641: CALL_OW 1
57645: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
57646: LD_ADDR_EXP 81
57650: PUSH
57651: LD_EXP 81
57655: PPUSH
57656: LD_VAR 0 2
57660: PPUSH
57661: EMPTY
57662: PPUSH
57663: CALL_OW 1
57667: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
57668: LD_ADDR_EXP 82
57672: PUSH
57673: LD_EXP 82
57677: PPUSH
57678: LD_VAR 0 2
57682: PPUSH
57683: EMPTY
57684: PPUSH
57685: CALL_OW 1
57689: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
57690: LD_ADDR_EXP 71
57694: PUSH
57695: LD_EXP 71
57699: PPUSH
57700: LD_VAR 0 2
57704: PPUSH
57705: LD_INT 0
57707: PPUSH
57708: CALL_OW 1
57712: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
57713: LD_ADDR_EXP 84
57717: PUSH
57718: LD_EXP 84
57722: PPUSH
57723: LD_VAR 0 2
57727: PPUSH
57728: LD_INT 0
57730: PPUSH
57731: CALL_OW 1
57735: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
57736: LD_ADDR_EXP 72
57740: PUSH
57741: LD_EXP 72
57745: PPUSH
57746: LD_VAR 0 2
57750: PPUSH
57751: EMPTY
57752: PPUSH
57753: CALL_OW 1
57757: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
57758: LD_ADDR_EXP 83
57762: PUSH
57763: LD_EXP 83
57767: PPUSH
57768: LD_VAR 0 2
57772: PPUSH
57773: LD_INT 0
57775: PPUSH
57776: CALL_OW 1
57780: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
57781: LD_ADDR_EXP 85
57785: PUSH
57786: LD_EXP 85
57790: PPUSH
57791: LD_VAR 0 2
57795: PPUSH
57796: EMPTY
57797: PPUSH
57798: CALL_OW 1
57802: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
57803: LD_ADDR_EXP 88
57807: PUSH
57808: LD_EXP 88
57812: PPUSH
57813: LD_VAR 0 2
57817: PPUSH
57818: LD_INT 0
57820: PPUSH
57821: CALL_OW 1
57825: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
57826: LD_ADDR_EXP 89
57830: PUSH
57831: LD_EXP 89
57835: PPUSH
57836: LD_VAR 0 2
57840: PPUSH
57841: EMPTY
57842: PPUSH
57843: CALL_OW 1
57847: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
57848: LD_ADDR_EXP 90
57852: PUSH
57853: LD_EXP 90
57857: PPUSH
57858: LD_VAR 0 2
57862: PPUSH
57863: EMPTY
57864: PPUSH
57865: CALL_OW 1
57869: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57870: LD_ADDR_EXP 91
57874: PUSH
57875: LD_EXP 91
57879: PPUSH
57880: LD_VAR 0 2
57884: PPUSH
57885: EMPTY
57886: PPUSH
57887: CALL_OW 1
57891: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
57892: LD_ADDR_EXP 93
57896: PUSH
57897: LD_EXP 93
57901: PPUSH
57902: LD_VAR 0 2
57906: PPUSH
57907: LD_EXP 60
57911: PUSH
57912: LD_VAR 0 2
57916: ARRAY
57917: PPUSH
57918: LD_INT 2
57920: PUSH
57921: LD_INT 30
57923: PUSH
57924: LD_INT 6
57926: PUSH
57927: EMPTY
57928: LIST
57929: LIST
57930: PUSH
57931: LD_INT 30
57933: PUSH
57934: LD_INT 7
57936: PUSH
57937: EMPTY
57938: LIST
57939: LIST
57940: PUSH
57941: LD_INT 30
57943: PUSH
57944: LD_INT 8
57946: PUSH
57947: EMPTY
57948: LIST
57949: LIST
57950: PUSH
57951: EMPTY
57952: LIST
57953: LIST
57954: LIST
57955: LIST
57956: PPUSH
57957: CALL_OW 72
57961: PPUSH
57962: CALL_OW 1
57966: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
57967: LD_ADDR_EXP 94
57971: PUSH
57972: LD_EXP 94
57976: PPUSH
57977: LD_VAR 0 2
57981: PPUSH
57982: EMPTY
57983: PPUSH
57984: CALL_OW 1
57988: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
57989: LD_ADDR_EXP 95
57993: PUSH
57994: LD_EXP 95
57998: PPUSH
57999: LD_VAR 0 2
58003: PPUSH
58004: EMPTY
58005: PPUSH
58006: CALL_OW 1
58010: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
58011: LD_ADDR_EXP 96
58015: PUSH
58016: LD_EXP 96
58020: PPUSH
58021: LD_VAR 0 2
58025: PPUSH
58026: EMPTY
58027: PPUSH
58028: CALL_OW 1
58032: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
58033: LD_ADDR_EXP 97
58037: PUSH
58038: LD_EXP 97
58042: PPUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: EMPTY
58049: PPUSH
58050: CALL_OW 1
58054: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
58055: LD_ADDR_EXP 98
58059: PUSH
58060: LD_EXP 98
58064: PPUSH
58065: LD_VAR 0 2
58069: PPUSH
58070: EMPTY
58071: PPUSH
58072: CALL_OW 1
58076: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
58077: LD_ADDR_EXP 99
58081: PUSH
58082: LD_EXP 99
58086: PPUSH
58087: LD_VAR 0 2
58091: PPUSH
58092: EMPTY
58093: PPUSH
58094: CALL_OW 1
58098: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
58099: LD_ADDR_EXP 100
58103: PUSH
58104: LD_EXP 100
58108: PPUSH
58109: LD_VAR 0 2
58113: PPUSH
58114: EMPTY
58115: PPUSH
58116: CALL_OW 1
58120: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
58121: LD_ADDR_EXP 101
58125: PUSH
58126: LD_EXP 101
58130: PPUSH
58131: LD_VAR 0 2
58135: PPUSH
58136: EMPTY
58137: PPUSH
58138: CALL_OW 1
58142: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
58143: LD_ADDR_EXP 102
58147: PUSH
58148: LD_EXP 102
58152: PPUSH
58153: LD_VAR 0 2
58157: PPUSH
58158: LD_INT 0
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
58166: LD_ADDR_EXP 103
58170: PUSH
58171: LD_EXP 103
58175: PPUSH
58176: LD_VAR 0 2
58180: PPUSH
58181: LD_INT 0
58183: PPUSH
58184: CALL_OW 1
58188: ST_TO_ADDR
// end ;
58189: GO 57090
58191: POP
58192: POP
// MC_InitSides ( ) ;
58193: CALL 58479 0 0
// MC_InitResearch ( ) ;
58197: CALL 58218 0 0
// CustomInitMacro ( ) ;
58201: CALL 206 0 0
// skirmish := true ;
58205: LD_ADDR_EXP 58
58209: PUSH
58210: LD_INT 1
58212: ST_TO_ADDR
// end ;
58213: LD_VAR 0 1
58217: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
58218: LD_INT 0
58220: PPUSH
58221: PPUSH
58222: PPUSH
58223: PPUSH
58224: PPUSH
58225: PPUSH
// if not mc_bases then
58226: LD_EXP 60
58230: NOT
58231: IFFALSE 58235
// exit ;
58233: GO 58474
// for i = 1 to 8 do
58235: LD_ADDR_VAR 0 2
58239: PUSH
58240: DOUBLE
58241: LD_INT 1
58243: DEC
58244: ST_TO_ADDR
58245: LD_INT 8
58247: PUSH
58248: FOR_TO
58249: IFFALSE 58275
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
58251: LD_ADDR_EXP 87
58255: PUSH
58256: LD_EXP 87
58260: PPUSH
58261: LD_VAR 0 2
58265: PPUSH
58266: EMPTY
58267: PPUSH
58268: CALL_OW 1
58272: ST_TO_ADDR
58273: GO 58248
58275: POP
58276: POP
// tmp := [ ] ;
58277: LD_ADDR_VAR 0 5
58281: PUSH
58282: EMPTY
58283: ST_TO_ADDR
// for i = 1 to mc_sides do
58284: LD_ADDR_VAR 0 2
58288: PUSH
58289: DOUBLE
58290: LD_INT 1
58292: DEC
58293: ST_TO_ADDR
58294: LD_EXP 86
58298: PUSH
58299: FOR_TO
58300: IFFALSE 58358
// if not mc_sides [ i ] in tmp then
58302: LD_EXP 86
58306: PUSH
58307: LD_VAR 0 2
58311: ARRAY
58312: PUSH
58313: LD_VAR 0 5
58317: IN
58318: NOT
58319: IFFALSE 58356
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
58321: LD_ADDR_VAR 0 5
58325: PUSH
58326: LD_VAR 0 5
58330: PPUSH
58331: LD_VAR 0 5
58335: PUSH
58336: LD_INT 1
58338: PLUS
58339: PPUSH
58340: LD_EXP 86
58344: PUSH
58345: LD_VAR 0 2
58349: ARRAY
58350: PPUSH
58351: CALL_OW 2
58355: ST_TO_ADDR
58356: GO 58299
58358: POP
58359: POP
// if not tmp then
58360: LD_VAR 0 5
58364: NOT
58365: IFFALSE 58369
// exit ;
58367: GO 58474
// for j in tmp do
58369: LD_ADDR_VAR 0 3
58373: PUSH
58374: LD_VAR 0 5
58378: PUSH
58379: FOR_IN
58380: IFFALSE 58472
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
58382: LD_ADDR_VAR 0 6
58386: PUSH
58387: LD_INT 22
58389: PUSH
58390: LD_VAR 0 3
58394: PUSH
58395: EMPTY
58396: LIST
58397: LIST
58398: PPUSH
58399: CALL_OW 69
58403: ST_TO_ADDR
// if not un then
58404: LD_VAR 0 6
58408: NOT
58409: IFFALSE 58413
// continue ;
58411: GO 58379
// nation := GetNation ( un [ 1 ] ) ;
58413: LD_ADDR_VAR 0 4
58417: PUSH
58418: LD_VAR 0 6
58422: PUSH
58423: LD_INT 1
58425: ARRAY
58426: PPUSH
58427: CALL_OW 248
58431: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
58432: LD_ADDR_EXP 87
58436: PUSH
58437: LD_EXP 87
58441: PPUSH
58442: LD_VAR 0 3
58446: PPUSH
58447: LD_VAR 0 3
58451: PPUSH
58452: LD_VAR 0 4
58456: PPUSH
58457: LD_INT 1
58459: PPUSH
58460: CALL 14878 0 3
58464: PPUSH
58465: CALL_OW 1
58469: ST_TO_ADDR
// end ;
58470: GO 58379
58472: POP
58473: POP
// end ;
58474: LD_VAR 0 1
58478: RET
// export function MC_InitSides ( ) ; var i ; begin
58479: LD_INT 0
58481: PPUSH
58482: PPUSH
// if not mc_bases then
58483: LD_EXP 60
58487: NOT
58488: IFFALSE 58492
// exit ;
58490: GO 58566
// for i = 1 to mc_bases do
58492: LD_ADDR_VAR 0 2
58496: PUSH
58497: DOUBLE
58498: LD_INT 1
58500: DEC
58501: ST_TO_ADDR
58502: LD_EXP 60
58506: PUSH
58507: FOR_TO
58508: IFFALSE 58564
// if mc_bases [ i ] then
58510: LD_EXP 60
58514: PUSH
58515: LD_VAR 0 2
58519: ARRAY
58520: IFFALSE 58562
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
58522: LD_ADDR_EXP 86
58526: PUSH
58527: LD_EXP 86
58531: PPUSH
58532: LD_VAR 0 2
58536: PPUSH
58537: LD_EXP 60
58541: PUSH
58542: LD_VAR 0 2
58546: ARRAY
58547: PUSH
58548: LD_INT 1
58550: ARRAY
58551: PPUSH
58552: CALL_OW 255
58556: PPUSH
58557: CALL_OW 1
58561: ST_TO_ADDR
58562: GO 58507
58564: POP
58565: POP
// end ;
58566: LD_VAR 0 1
58570: RET
// every 0 0$03 trigger skirmish do
58571: LD_EXP 58
58575: IFFALSE 58729
58577: GO 58579
58579: DISABLE
// begin enable ;
58580: ENABLE
// MC_CheckBuildings ( ) ;
58581: CALL 63227 0 0
// MC_CheckPeopleLife ( ) ;
58585: CALL 63388 0 0
// RaiseSailEvent ( 100 ) ;
58589: LD_INT 100
58591: PPUSH
58592: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
58596: LD_INT 103
58598: PPUSH
58599: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
58603: LD_INT 104
58605: PPUSH
58606: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
58610: LD_INT 105
58612: PPUSH
58613: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
58617: LD_INT 106
58619: PPUSH
58620: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
58624: LD_INT 107
58626: PPUSH
58627: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
58631: LD_INT 108
58633: PPUSH
58634: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
58638: LD_INT 109
58640: PPUSH
58641: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
58645: LD_INT 110
58647: PPUSH
58648: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
58652: LD_INT 111
58654: PPUSH
58655: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
58659: LD_INT 112
58661: PPUSH
58662: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
58666: LD_INT 113
58668: PPUSH
58669: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
58673: LD_INT 120
58675: PPUSH
58676: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
58680: LD_INT 121
58682: PPUSH
58683: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
58687: LD_INT 122
58689: PPUSH
58690: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
58694: LD_INT 123
58696: PPUSH
58697: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
58701: LD_INT 124
58703: PPUSH
58704: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
58708: LD_INT 125
58710: PPUSH
58711: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
58715: LD_INT 126
58717: PPUSH
58718: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
58722: LD_INT 200
58724: PPUSH
58725: CALL_OW 427
// end ;
58729: END
// on SailEvent ( event ) do begin if event < 100 then
58730: LD_VAR 0 1
58734: PUSH
58735: LD_INT 100
58737: LESS
58738: IFFALSE 58749
// CustomEvent ( event ) ;
58740: LD_VAR 0 1
58744: PPUSH
58745: CALL 13516 0 1
// if event = 100 then
58749: LD_VAR 0 1
58753: PUSH
58754: LD_INT 100
58756: EQUAL
58757: IFFALSE 58763
// MC_ClassManager ( ) ;
58759: CALL 59155 0 0
// if event = 101 then
58763: LD_VAR 0 1
58767: PUSH
58768: LD_INT 101
58770: EQUAL
58771: IFFALSE 58777
// MC_RepairBuildings ( ) ;
58773: CALL 63973 0 0
// if event = 102 then
58777: LD_VAR 0 1
58781: PUSH
58782: LD_INT 102
58784: EQUAL
58785: IFFALSE 58791
// MC_Heal ( ) ;
58787: CALL 64880 0 0
// if event = 103 then
58791: LD_VAR 0 1
58795: PUSH
58796: LD_INT 103
58798: EQUAL
58799: IFFALSE 58805
// MC_Build ( ) ;
58801: CALL 65302 0 0
// if event = 104 then
58805: LD_VAR 0 1
58809: PUSH
58810: LD_INT 104
58812: EQUAL
58813: IFFALSE 58819
// MC_TurretWeapon ( ) ;
58815: CALL 66943 0 0
// if event = 105 then
58819: LD_VAR 0 1
58823: PUSH
58824: LD_INT 105
58826: EQUAL
58827: IFFALSE 58833
// MC_BuildUpgrade ( ) ;
58829: CALL 66494 0 0
// if event = 106 then
58833: LD_VAR 0 1
58837: PUSH
58838: LD_INT 106
58840: EQUAL
58841: IFFALSE 58847
// MC_PlantMines ( ) ;
58843: CALL 67373 0 0
// if event = 107 then
58847: LD_VAR 0 1
58851: PUSH
58852: LD_INT 107
58854: EQUAL
58855: IFFALSE 58861
// MC_CollectCrates ( ) ;
58857: CALL 68164 0 0
// if event = 108 then
58861: LD_VAR 0 1
58865: PUSH
58866: LD_INT 108
58868: EQUAL
58869: IFFALSE 58875
// MC_LinkRemoteControl ( ) ;
58871: CALL 70014 0 0
// if event = 109 then
58875: LD_VAR 0 1
58879: PUSH
58880: LD_INT 109
58882: EQUAL
58883: IFFALSE 58889
// MC_ProduceVehicle ( ) ;
58885: CALL 70195 0 0
// if event = 110 then
58889: LD_VAR 0 1
58893: PUSH
58894: LD_INT 110
58896: EQUAL
58897: IFFALSE 58903
// MC_SendAttack ( ) ;
58899: CALL 70661 0 0
// if event = 111 then
58903: LD_VAR 0 1
58907: PUSH
58908: LD_INT 111
58910: EQUAL
58911: IFFALSE 58917
// MC_Defend ( ) ;
58913: CALL 70769 0 0
// if event = 112 then
58917: LD_VAR 0 1
58921: PUSH
58922: LD_INT 112
58924: EQUAL
58925: IFFALSE 58931
// MC_Research ( ) ;
58927: CALL 71649 0 0
// if event = 113 then
58931: LD_VAR 0 1
58935: PUSH
58936: LD_INT 113
58938: EQUAL
58939: IFFALSE 58945
// MC_MinesTrigger ( ) ;
58941: CALL 72763 0 0
// if event = 120 then
58945: LD_VAR 0 1
58949: PUSH
58950: LD_INT 120
58952: EQUAL
58953: IFFALSE 58959
// MC_RepairVehicle ( ) ;
58955: CALL 72862 0 0
// if event = 121 then
58959: LD_VAR 0 1
58963: PUSH
58964: LD_INT 121
58966: EQUAL
58967: IFFALSE 58973
// MC_TameApe ( ) ;
58969: CALL 73603 0 0
// if event = 122 then
58973: LD_VAR 0 1
58977: PUSH
58978: LD_INT 122
58980: EQUAL
58981: IFFALSE 58987
// MC_ChangeApeClass ( ) ;
58983: CALL 74432 0 0
// if event = 123 then
58987: LD_VAR 0 1
58991: PUSH
58992: LD_INT 123
58994: EQUAL
58995: IFFALSE 59001
// MC_Bazooka ( ) ;
58997: CALL 75082 0 0
// if event = 124 then
59001: LD_VAR 0 1
59005: PUSH
59006: LD_INT 124
59008: EQUAL
59009: IFFALSE 59015
// MC_TeleportExit ( ) ;
59011: CALL 75280 0 0
// if event = 125 then
59015: LD_VAR 0 1
59019: PUSH
59020: LD_INT 125
59022: EQUAL
59023: IFFALSE 59029
// MC_Deposits ( ) ;
59025: CALL 75927 0 0
// if event = 126 then
59029: LD_VAR 0 1
59033: PUSH
59034: LD_INT 126
59036: EQUAL
59037: IFFALSE 59043
// MC_RemoteDriver ( ) ;
59039: CALL 76552 0 0
// if event = 200 then
59043: LD_VAR 0 1
59047: PUSH
59048: LD_INT 200
59050: EQUAL
59051: IFFALSE 59057
// MC_Idle ( ) ;
59053: CALL 78501 0 0
// end ;
59057: PPOPN 1
59059: END
// export function MC_Reset ( base , tag ) ; var i ; begin
59060: LD_INT 0
59062: PPUSH
59063: PPUSH
// if not mc_bases [ base ] or not tag then
59064: LD_EXP 60
59068: PUSH
59069: LD_VAR 0 1
59073: ARRAY
59074: NOT
59075: PUSH
59076: LD_VAR 0 2
59080: NOT
59081: OR
59082: IFFALSE 59086
// exit ;
59084: GO 59150
// for i in mc_bases [ base ] union mc_ape [ base ] do
59086: LD_ADDR_VAR 0 4
59090: PUSH
59091: LD_EXP 60
59095: PUSH
59096: LD_VAR 0 1
59100: ARRAY
59101: PUSH
59102: LD_EXP 89
59106: PUSH
59107: LD_VAR 0 1
59111: ARRAY
59112: UNION
59113: PUSH
59114: FOR_IN
59115: IFFALSE 59148
// if GetTag ( i ) = tag then
59117: LD_VAR 0 4
59121: PPUSH
59122: CALL_OW 110
59126: PUSH
59127: LD_VAR 0 2
59131: EQUAL
59132: IFFALSE 59146
// SetTag ( i , 0 ) ;
59134: LD_VAR 0 4
59138: PPUSH
59139: LD_INT 0
59141: PPUSH
59142: CALL_OW 109
59146: GO 59114
59148: POP
59149: POP
// end ;
59150: LD_VAR 0 3
59154: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
59155: LD_INT 0
59157: PPUSH
59158: PPUSH
59159: PPUSH
59160: PPUSH
59161: PPUSH
59162: PPUSH
59163: PPUSH
59164: PPUSH
// if not mc_bases then
59165: LD_EXP 60
59169: NOT
59170: IFFALSE 59174
// exit ;
59172: GO 59632
// for i = 1 to mc_bases do
59174: LD_ADDR_VAR 0 2
59178: PUSH
59179: DOUBLE
59180: LD_INT 1
59182: DEC
59183: ST_TO_ADDR
59184: LD_EXP 60
59188: PUSH
59189: FOR_TO
59190: IFFALSE 59630
// begin tmp := MC_ClassCheckReq ( i ) ;
59192: LD_ADDR_VAR 0 4
59196: PUSH
59197: LD_VAR 0 2
59201: PPUSH
59202: CALL 59637 0 1
59206: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
59207: LD_ADDR_EXP 101
59211: PUSH
59212: LD_EXP 101
59216: PPUSH
59217: LD_VAR 0 2
59221: PPUSH
59222: LD_VAR 0 4
59226: PPUSH
59227: CALL_OW 1
59231: ST_TO_ADDR
// if not tmp then
59232: LD_VAR 0 4
59236: NOT
59237: IFFALSE 59241
// continue ;
59239: GO 59189
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
59241: LD_ADDR_VAR 0 6
59245: PUSH
59246: LD_EXP 60
59250: PUSH
59251: LD_VAR 0 2
59255: ARRAY
59256: PPUSH
59257: LD_INT 2
59259: PUSH
59260: LD_INT 30
59262: PUSH
59263: LD_INT 4
59265: PUSH
59266: EMPTY
59267: LIST
59268: LIST
59269: PUSH
59270: LD_INT 30
59272: PUSH
59273: LD_INT 5
59275: PUSH
59276: EMPTY
59277: LIST
59278: LIST
59279: PUSH
59280: EMPTY
59281: LIST
59282: LIST
59283: LIST
59284: PPUSH
59285: CALL_OW 72
59289: PUSH
59290: LD_EXP 60
59294: PUSH
59295: LD_VAR 0 2
59299: ARRAY
59300: PPUSH
59301: LD_INT 2
59303: PUSH
59304: LD_INT 30
59306: PUSH
59307: LD_INT 0
59309: PUSH
59310: EMPTY
59311: LIST
59312: LIST
59313: PUSH
59314: LD_INT 30
59316: PUSH
59317: LD_INT 1
59319: PUSH
59320: EMPTY
59321: LIST
59322: LIST
59323: PUSH
59324: EMPTY
59325: LIST
59326: LIST
59327: LIST
59328: PPUSH
59329: CALL_OW 72
59333: PUSH
59334: LD_EXP 60
59338: PUSH
59339: LD_VAR 0 2
59343: ARRAY
59344: PPUSH
59345: LD_INT 30
59347: PUSH
59348: LD_INT 3
59350: PUSH
59351: EMPTY
59352: LIST
59353: LIST
59354: PPUSH
59355: CALL_OW 72
59359: PUSH
59360: LD_EXP 60
59364: PUSH
59365: LD_VAR 0 2
59369: ARRAY
59370: PPUSH
59371: LD_INT 2
59373: PUSH
59374: LD_INT 30
59376: PUSH
59377: LD_INT 6
59379: PUSH
59380: EMPTY
59381: LIST
59382: LIST
59383: PUSH
59384: LD_INT 30
59386: PUSH
59387: LD_INT 7
59389: PUSH
59390: EMPTY
59391: LIST
59392: LIST
59393: PUSH
59394: LD_INT 30
59396: PUSH
59397: LD_INT 8
59399: PUSH
59400: EMPTY
59401: LIST
59402: LIST
59403: PUSH
59404: EMPTY
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: PPUSH
59410: CALL_OW 72
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: LIST
59419: LIST
59420: ST_TO_ADDR
// for j = 1 to 4 do
59421: LD_ADDR_VAR 0 3
59425: PUSH
59426: DOUBLE
59427: LD_INT 1
59429: DEC
59430: ST_TO_ADDR
59431: LD_INT 4
59433: PUSH
59434: FOR_TO
59435: IFFALSE 59626
// begin if not tmp [ j ] then
59437: LD_VAR 0 4
59441: PUSH
59442: LD_VAR 0 3
59446: ARRAY
59447: NOT
59448: IFFALSE 59452
// continue ;
59450: GO 59434
// for p in tmp [ j ] do
59452: LD_ADDR_VAR 0 5
59456: PUSH
59457: LD_VAR 0 4
59461: PUSH
59462: LD_VAR 0 3
59466: ARRAY
59467: PUSH
59468: FOR_IN
59469: IFFALSE 59622
// begin if not b [ j ] then
59471: LD_VAR 0 6
59475: PUSH
59476: LD_VAR 0 3
59480: ARRAY
59481: NOT
59482: IFFALSE 59486
// break ;
59484: GO 59622
// e := 0 ;
59486: LD_ADDR_VAR 0 7
59490: PUSH
59491: LD_INT 0
59493: ST_TO_ADDR
// for k in b [ j ] do
59494: LD_ADDR_VAR 0 8
59498: PUSH
59499: LD_VAR 0 6
59503: PUSH
59504: LD_VAR 0 3
59508: ARRAY
59509: PUSH
59510: FOR_IN
59511: IFFALSE 59538
// if IsNotFull ( k ) then
59513: LD_VAR 0 8
59517: PPUSH
59518: CALL 17031 0 1
59522: IFFALSE 59536
// begin e := k ;
59524: LD_ADDR_VAR 0 7
59528: PUSH
59529: LD_VAR 0 8
59533: ST_TO_ADDR
// break ;
59534: GO 59538
// end ;
59536: GO 59510
59538: POP
59539: POP
// if e and not UnitGoingToBuilding ( p , e ) then
59540: LD_VAR 0 7
59544: PUSH
59545: LD_VAR 0 5
59549: PPUSH
59550: LD_VAR 0 7
59554: PPUSH
59555: CALL 50195 0 2
59559: NOT
59560: AND
59561: IFFALSE 59620
// begin if IsInUnit ( p ) then
59563: LD_VAR 0 5
59567: PPUSH
59568: CALL_OW 310
59572: IFFALSE 59583
// ComExitBuilding ( p ) ;
59574: LD_VAR 0 5
59578: PPUSH
59579: CALL_OW 122
// ComEnterUnit ( p , e ) ;
59583: LD_VAR 0 5
59587: PPUSH
59588: LD_VAR 0 7
59592: PPUSH
59593: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
59597: LD_VAR 0 5
59601: PPUSH
59602: LD_VAR 0 3
59606: PPUSH
59607: CALL_OW 183
// AddComExitBuilding ( p ) ;
59611: LD_VAR 0 5
59615: PPUSH
59616: CALL_OW 182
// end ; end ;
59620: GO 59468
59622: POP
59623: POP
// end ;
59624: GO 59434
59626: POP
59627: POP
// end ;
59628: GO 59189
59630: POP
59631: POP
// end ;
59632: LD_VAR 0 1
59636: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
59637: LD_INT 0
59639: PPUSH
59640: PPUSH
59641: PPUSH
59642: PPUSH
59643: PPUSH
59644: PPUSH
59645: PPUSH
59646: PPUSH
59647: PPUSH
59648: PPUSH
59649: PPUSH
59650: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59651: LD_VAR 0 1
59655: NOT
59656: PUSH
59657: LD_EXP 60
59661: PUSH
59662: LD_VAR 0 1
59666: ARRAY
59667: NOT
59668: OR
59669: PUSH
59670: LD_EXP 60
59674: PUSH
59675: LD_VAR 0 1
59679: ARRAY
59680: PPUSH
59681: LD_INT 2
59683: PUSH
59684: LD_INT 30
59686: PUSH
59687: LD_INT 0
59689: PUSH
59690: EMPTY
59691: LIST
59692: LIST
59693: PUSH
59694: LD_INT 30
59696: PUSH
59697: LD_INT 1
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: PUSH
59704: EMPTY
59705: LIST
59706: LIST
59707: LIST
59708: PPUSH
59709: CALL_OW 72
59713: NOT
59714: OR
59715: IFFALSE 59719
// exit ;
59717: GO 63222
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59719: LD_ADDR_VAR 0 4
59723: PUSH
59724: LD_EXP 60
59728: PUSH
59729: LD_VAR 0 1
59733: ARRAY
59734: PPUSH
59735: LD_INT 2
59737: PUSH
59738: LD_INT 25
59740: PUSH
59741: LD_INT 1
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PUSH
59748: LD_INT 25
59750: PUSH
59751: LD_INT 2
59753: PUSH
59754: EMPTY
59755: LIST
59756: LIST
59757: PUSH
59758: LD_INT 25
59760: PUSH
59761: LD_INT 3
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: PUSH
59768: LD_INT 25
59770: PUSH
59771: LD_INT 4
59773: PUSH
59774: EMPTY
59775: LIST
59776: LIST
59777: PUSH
59778: LD_INT 25
59780: PUSH
59781: LD_INT 5
59783: PUSH
59784: EMPTY
59785: LIST
59786: LIST
59787: PUSH
59788: LD_INT 25
59790: PUSH
59791: LD_INT 8
59793: PUSH
59794: EMPTY
59795: LIST
59796: LIST
59797: PUSH
59798: LD_INT 25
59800: PUSH
59801: LD_INT 9
59803: PUSH
59804: EMPTY
59805: LIST
59806: LIST
59807: PUSH
59808: EMPTY
59809: LIST
59810: LIST
59811: LIST
59812: LIST
59813: LIST
59814: LIST
59815: LIST
59816: LIST
59817: PPUSH
59818: CALL_OW 72
59822: ST_TO_ADDR
// if not tmp then
59823: LD_VAR 0 4
59827: NOT
59828: IFFALSE 59832
// exit ;
59830: GO 63222
// for i in tmp do
59832: LD_ADDR_VAR 0 3
59836: PUSH
59837: LD_VAR 0 4
59841: PUSH
59842: FOR_IN
59843: IFFALSE 59874
// if GetTag ( i ) then
59845: LD_VAR 0 3
59849: PPUSH
59850: CALL_OW 110
59854: IFFALSE 59872
// tmp := tmp diff i ;
59856: LD_ADDR_VAR 0 4
59860: PUSH
59861: LD_VAR 0 4
59865: PUSH
59866: LD_VAR 0 3
59870: DIFF
59871: ST_TO_ADDR
59872: GO 59842
59874: POP
59875: POP
// if not tmp then
59876: LD_VAR 0 4
59880: NOT
59881: IFFALSE 59885
// exit ;
59883: GO 63222
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
59885: LD_ADDR_VAR 0 5
59889: PUSH
59890: LD_EXP 60
59894: PUSH
59895: LD_VAR 0 1
59899: ARRAY
59900: PPUSH
59901: LD_INT 2
59903: PUSH
59904: LD_INT 25
59906: PUSH
59907: LD_INT 1
59909: PUSH
59910: EMPTY
59911: LIST
59912: LIST
59913: PUSH
59914: LD_INT 25
59916: PUSH
59917: LD_INT 5
59919: PUSH
59920: EMPTY
59921: LIST
59922: LIST
59923: PUSH
59924: LD_INT 25
59926: PUSH
59927: LD_INT 8
59929: PUSH
59930: EMPTY
59931: LIST
59932: LIST
59933: PUSH
59934: LD_INT 25
59936: PUSH
59937: LD_INT 9
59939: PUSH
59940: EMPTY
59941: LIST
59942: LIST
59943: PUSH
59944: EMPTY
59945: LIST
59946: LIST
59947: LIST
59948: LIST
59949: LIST
59950: PPUSH
59951: CALL_OW 72
59955: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
59956: LD_ADDR_VAR 0 6
59960: PUSH
59961: LD_EXP 60
59965: PUSH
59966: LD_VAR 0 1
59970: ARRAY
59971: PPUSH
59972: LD_INT 25
59974: PUSH
59975: LD_INT 2
59977: PUSH
59978: EMPTY
59979: LIST
59980: LIST
59981: PPUSH
59982: CALL_OW 72
59986: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
59987: LD_ADDR_VAR 0 7
59991: PUSH
59992: LD_EXP 60
59996: PUSH
59997: LD_VAR 0 1
60001: ARRAY
60002: PPUSH
60003: LD_INT 25
60005: PUSH
60006: LD_INT 3
60008: PUSH
60009: EMPTY
60010: LIST
60011: LIST
60012: PPUSH
60013: CALL_OW 72
60017: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
60018: LD_ADDR_VAR 0 8
60022: PUSH
60023: LD_EXP 60
60027: PUSH
60028: LD_VAR 0 1
60032: ARRAY
60033: PPUSH
60034: LD_INT 25
60036: PUSH
60037: LD_INT 4
60039: PUSH
60040: EMPTY
60041: LIST
60042: LIST
60043: PUSH
60044: LD_INT 24
60046: PUSH
60047: LD_INT 251
60049: PUSH
60050: EMPTY
60051: LIST
60052: LIST
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PPUSH
60058: CALL_OW 72
60062: ST_TO_ADDR
// if mc_is_defending [ base ] then
60063: LD_EXP 103
60067: PUSH
60068: LD_VAR 0 1
60072: ARRAY
60073: IFFALSE 60534
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
60075: LD_ADDR_EXP 102
60079: PUSH
60080: LD_EXP 102
60084: PPUSH
60085: LD_VAR 0 1
60089: PPUSH
60090: LD_INT 4
60092: PPUSH
60093: CALL_OW 1
60097: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60098: LD_ADDR_VAR 0 12
60102: PUSH
60103: LD_EXP 60
60107: PUSH
60108: LD_VAR 0 1
60112: ARRAY
60113: PPUSH
60114: LD_INT 2
60116: PUSH
60117: LD_INT 30
60119: PUSH
60120: LD_INT 4
60122: PUSH
60123: EMPTY
60124: LIST
60125: LIST
60126: PUSH
60127: LD_INT 30
60129: PUSH
60130: LD_INT 5
60132: PUSH
60133: EMPTY
60134: LIST
60135: LIST
60136: PUSH
60137: EMPTY
60138: LIST
60139: LIST
60140: LIST
60141: PPUSH
60142: CALL_OW 72
60146: ST_TO_ADDR
// if not b then
60147: LD_VAR 0 12
60151: NOT
60152: IFFALSE 60156
// exit ;
60154: GO 63222
// p := [ ] ;
60156: LD_ADDR_VAR 0 11
60160: PUSH
60161: EMPTY
60162: ST_TO_ADDR
// if sci >= 2 then
60163: LD_VAR 0 8
60167: PUSH
60168: LD_INT 2
60170: GREATEREQUAL
60171: IFFALSE 60202
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
60173: LD_ADDR_VAR 0 8
60177: PUSH
60178: LD_VAR 0 8
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: PUSH
60187: LD_VAR 0 8
60191: PUSH
60192: LD_INT 2
60194: ARRAY
60195: PUSH
60196: EMPTY
60197: LIST
60198: LIST
60199: ST_TO_ADDR
60200: GO 60263
// if sci = 1 then
60202: LD_VAR 0 8
60206: PUSH
60207: LD_INT 1
60209: EQUAL
60210: IFFALSE 60231
// sci := [ sci [ 1 ] ] else
60212: LD_ADDR_VAR 0 8
60216: PUSH
60217: LD_VAR 0 8
60221: PUSH
60222: LD_INT 1
60224: ARRAY
60225: PUSH
60226: EMPTY
60227: LIST
60228: ST_TO_ADDR
60229: GO 60263
// if sci = 0 then
60231: LD_VAR 0 8
60235: PUSH
60236: LD_INT 0
60238: EQUAL
60239: IFFALSE 60263
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
60241: LD_ADDR_VAR 0 11
60245: PUSH
60246: LD_VAR 0 4
60250: PPUSH
60251: LD_INT 4
60253: PPUSH
60254: CALL 50058 0 2
60258: PUSH
60259: LD_INT 1
60261: ARRAY
60262: ST_TO_ADDR
// if eng > 4 then
60263: LD_VAR 0 6
60267: PUSH
60268: LD_INT 4
60270: GREATER
60271: IFFALSE 60317
// for i = eng downto 4 do
60273: LD_ADDR_VAR 0 3
60277: PUSH
60278: DOUBLE
60279: LD_VAR 0 6
60283: INC
60284: ST_TO_ADDR
60285: LD_INT 4
60287: PUSH
60288: FOR_DOWNTO
60289: IFFALSE 60315
// eng := eng diff eng [ i ] ;
60291: LD_ADDR_VAR 0 6
60295: PUSH
60296: LD_VAR 0 6
60300: PUSH
60301: LD_VAR 0 6
60305: PUSH
60306: LD_VAR 0 3
60310: ARRAY
60311: DIFF
60312: ST_TO_ADDR
60313: GO 60288
60315: POP
60316: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
60317: LD_ADDR_VAR 0 4
60321: PUSH
60322: LD_VAR 0 4
60326: PUSH
60327: LD_VAR 0 5
60331: PUSH
60332: LD_VAR 0 6
60336: UNION
60337: PUSH
60338: LD_VAR 0 7
60342: UNION
60343: PUSH
60344: LD_VAR 0 8
60348: UNION
60349: DIFF
60350: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
60351: LD_ADDR_VAR 0 13
60355: PUSH
60356: LD_EXP 60
60360: PUSH
60361: LD_VAR 0 1
60365: ARRAY
60366: PPUSH
60367: LD_INT 2
60369: PUSH
60370: LD_INT 30
60372: PUSH
60373: LD_INT 32
60375: PUSH
60376: EMPTY
60377: LIST
60378: LIST
60379: PUSH
60380: LD_INT 30
60382: PUSH
60383: LD_INT 31
60385: PUSH
60386: EMPTY
60387: LIST
60388: LIST
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: LIST
60394: PPUSH
60395: CALL_OW 72
60399: PUSH
60400: LD_EXP 60
60404: PUSH
60405: LD_VAR 0 1
60409: ARRAY
60410: PPUSH
60411: LD_INT 2
60413: PUSH
60414: LD_INT 30
60416: PUSH
60417: LD_INT 4
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 30
60426: PUSH
60427: LD_INT 5
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PUSH
60434: EMPTY
60435: LIST
60436: LIST
60437: LIST
60438: PPUSH
60439: CALL_OW 72
60443: PUSH
60444: LD_INT 6
60446: MUL
60447: PLUS
60448: ST_TO_ADDR
// if bcount < tmp then
60449: LD_VAR 0 13
60453: PUSH
60454: LD_VAR 0 4
60458: LESS
60459: IFFALSE 60505
// for i = tmp downto bcount do
60461: LD_ADDR_VAR 0 3
60465: PUSH
60466: DOUBLE
60467: LD_VAR 0 4
60471: INC
60472: ST_TO_ADDR
60473: LD_VAR 0 13
60477: PUSH
60478: FOR_DOWNTO
60479: IFFALSE 60503
// tmp := Delete ( tmp , tmp ) ;
60481: LD_ADDR_VAR 0 4
60485: PUSH
60486: LD_VAR 0 4
60490: PPUSH
60491: LD_VAR 0 4
60495: PPUSH
60496: CALL_OW 3
60500: ST_TO_ADDR
60501: GO 60478
60503: POP
60504: POP
// result := [ tmp , 0 , 0 , p ] ;
60505: LD_ADDR_VAR 0 2
60509: PUSH
60510: LD_VAR 0 4
60514: PUSH
60515: LD_INT 0
60517: PUSH
60518: LD_INT 0
60520: PUSH
60521: LD_VAR 0 11
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: LIST
60530: LIST
60531: ST_TO_ADDR
// exit ;
60532: GO 63222
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60534: LD_EXP 60
60538: PUSH
60539: LD_VAR 0 1
60543: ARRAY
60544: PPUSH
60545: LD_INT 2
60547: PUSH
60548: LD_INT 30
60550: PUSH
60551: LD_INT 6
60553: PUSH
60554: EMPTY
60555: LIST
60556: LIST
60557: PUSH
60558: LD_INT 30
60560: PUSH
60561: LD_INT 7
60563: PUSH
60564: EMPTY
60565: LIST
60566: LIST
60567: PUSH
60568: LD_INT 30
60570: PUSH
60571: LD_INT 8
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: LIST
60582: LIST
60583: PPUSH
60584: CALL_OW 72
60588: NOT
60589: PUSH
60590: LD_EXP 60
60594: PUSH
60595: LD_VAR 0 1
60599: ARRAY
60600: PPUSH
60601: LD_INT 30
60603: PUSH
60604: LD_INT 3
60606: PUSH
60607: EMPTY
60608: LIST
60609: LIST
60610: PPUSH
60611: CALL_OW 72
60615: NOT
60616: AND
60617: IFFALSE 60689
// begin if eng = tmp then
60619: LD_VAR 0 6
60623: PUSH
60624: LD_VAR 0 4
60628: EQUAL
60629: IFFALSE 60633
// exit ;
60631: GO 63222
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
60633: LD_ADDR_EXP 102
60637: PUSH
60638: LD_EXP 102
60642: PPUSH
60643: LD_VAR 0 1
60647: PPUSH
60648: LD_INT 1
60650: PPUSH
60651: CALL_OW 1
60655: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
60656: LD_ADDR_VAR 0 2
60660: PUSH
60661: LD_INT 0
60663: PUSH
60664: LD_VAR 0 4
60668: PUSH
60669: LD_VAR 0 6
60673: DIFF
60674: PUSH
60675: LD_INT 0
60677: PUSH
60678: LD_INT 0
60680: PUSH
60681: EMPTY
60682: LIST
60683: LIST
60684: LIST
60685: LIST
60686: ST_TO_ADDR
// exit ;
60687: GO 63222
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
60689: LD_EXP 87
60693: PUSH
60694: LD_EXP 86
60698: PUSH
60699: LD_VAR 0 1
60703: ARRAY
60704: ARRAY
60705: PUSH
60706: LD_EXP 60
60710: PUSH
60711: LD_VAR 0 1
60715: ARRAY
60716: PPUSH
60717: LD_INT 2
60719: PUSH
60720: LD_INT 30
60722: PUSH
60723: LD_INT 6
60725: PUSH
60726: EMPTY
60727: LIST
60728: LIST
60729: PUSH
60730: LD_INT 30
60732: PUSH
60733: LD_INT 7
60735: PUSH
60736: EMPTY
60737: LIST
60738: LIST
60739: PUSH
60740: LD_INT 30
60742: PUSH
60743: LD_INT 8
60745: PUSH
60746: EMPTY
60747: LIST
60748: LIST
60749: PUSH
60750: EMPTY
60751: LIST
60752: LIST
60753: LIST
60754: LIST
60755: PPUSH
60756: CALL_OW 72
60760: AND
60761: PUSH
60762: LD_EXP 60
60766: PUSH
60767: LD_VAR 0 1
60771: ARRAY
60772: PPUSH
60773: LD_INT 30
60775: PUSH
60776: LD_INT 3
60778: PUSH
60779: EMPTY
60780: LIST
60781: LIST
60782: PPUSH
60783: CALL_OW 72
60787: NOT
60788: AND
60789: IFFALSE 61003
// begin if sci >= 6 then
60791: LD_VAR 0 8
60795: PUSH
60796: LD_INT 6
60798: GREATEREQUAL
60799: IFFALSE 60803
// exit ;
60801: GO 63222
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
60803: LD_ADDR_EXP 102
60807: PUSH
60808: LD_EXP 102
60812: PPUSH
60813: LD_VAR 0 1
60817: PPUSH
60818: LD_INT 2
60820: PPUSH
60821: CALL_OW 1
60825: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
60826: LD_ADDR_VAR 0 9
60830: PUSH
60831: LD_VAR 0 4
60835: PUSH
60836: LD_VAR 0 8
60840: DIFF
60841: PPUSH
60842: LD_INT 4
60844: PPUSH
60845: CALL 50058 0 2
60849: ST_TO_ADDR
// p := [ ] ;
60850: LD_ADDR_VAR 0 11
60854: PUSH
60855: EMPTY
60856: ST_TO_ADDR
// if sci < 6 and sort > 6 then
60857: LD_VAR 0 8
60861: PUSH
60862: LD_INT 6
60864: LESS
60865: PUSH
60866: LD_VAR 0 9
60870: PUSH
60871: LD_INT 6
60873: GREATER
60874: AND
60875: IFFALSE 60956
// begin for i = 1 to 6 - sci do
60877: LD_ADDR_VAR 0 3
60881: PUSH
60882: DOUBLE
60883: LD_INT 1
60885: DEC
60886: ST_TO_ADDR
60887: LD_INT 6
60889: PUSH
60890: LD_VAR 0 8
60894: MINUS
60895: PUSH
60896: FOR_TO
60897: IFFALSE 60952
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
60899: LD_ADDR_VAR 0 11
60903: PUSH
60904: LD_VAR 0 11
60908: PPUSH
60909: LD_VAR 0 11
60913: PUSH
60914: LD_INT 1
60916: PLUS
60917: PPUSH
60918: LD_VAR 0 9
60922: PUSH
60923: LD_INT 1
60925: ARRAY
60926: PPUSH
60927: CALL_OW 2
60931: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
60932: LD_ADDR_VAR 0 9
60936: PUSH
60937: LD_VAR 0 9
60941: PPUSH
60942: LD_INT 1
60944: PPUSH
60945: CALL_OW 3
60949: ST_TO_ADDR
// end ;
60950: GO 60896
60952: POP
60953: POP
// end else
60954: GO 60976
// if sort then
60956: LD_VAR 0 9
60960: IFFALSE 60976
// p := sort [ 1 ] ;
60962: LD_ADDR_VAR 0 11
60966: PUSH
60967: LD_VAR 0 9
60971: PUSH
60972: LD_INT 1
60974: ARRAY
60975: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
60976: LD_ADDR_VAR 0 2
60980: PUSH
60981: LD_INT 0
60983: PUSH
60984: LD_INT 0
60986: PUSH
60987: LD_INT 0
60989: PUSH
60990: LD_VAR 0 11
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: LIST
60999: LIST
61000: ST_TO_ADDR
// exit ;
61001: GO 63222
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61003: LD_EXP 87
61007: PUSH
61008: LD_EXP 86
61012: PUSH
61013: LD_VAR 0 1
61017: ARRAY
61018: ARRAY
61019: PUSH
61020: LD_EXP 60
61024: PUSH
61025: LD_VAR 0 1
61029: ARRAY
61030: PPUSH
61031: LD_INT 2
61033: PUSH
61034: LD_INT 30
61036: PUSH
61037: LD_INT 6
61039: PUSH
61040: EMPTY
61041: LIST
61042: LIST
61043: PUSH
61044: LD_INT 30
61046: PUSH
61047: LD_INT 7
61049: PUSH
61050: EMPTY
61051: LIST
61052: LIST
61053: PUSH
61054: LD_INT 30
61056: PUSH
61057: LD_INT 8
61059: PUSH
61060: EMPTY
61061: LIST
61062: LIST
61063: PUSH
61064: EMPTY
61065: LIST
61066: LIST
61067: LIST
61068: LIST
61069: PPUSH
61070: CALL_OW 72
61074: AND
61075: PUSH
61076: LD_EXP 60
61080: PUSH
61081: LD_VAR 0 1
61085: ARRAY
61086: PPUSH
61087: LD_INT 30
61089: PUSH
61090: LD_INT 3
61092: PUSH
61093: EMPTY
61094: LIST
61095: LIST
61096: PPUSH
61097: CALL_OW 72
61101: AND
61102: IFFALSE 61836
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
61104: LD_ADDR_EXP 102
61108: PUSH
61109: LD_EXP 102
61113: PPUSH
61114: LD_VAR 0 1
61118: PPUSH
61119: LD_INT 3
61121: PPUSH
61122: CALL_OW 1
61126: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61127: LD_ADDR_VAR 0 2
61131: PUSH
61132: LD_INT 0
61134: PUSH
61135: LD_INT 0
61137: PUSH
61138: LD_INT 0
61140: PUSH
61141: LD_INT 0
61143: PUSH
61144: EMPTY
61145: LIST
61146: LIST
61147: LIST
61148: LIST
61149: ST_TO_ADDR
// if not eng then
61150: LD_VAR 0 6
61154: NOT
61155: IFFALSE 61218
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
61157: LD_ADDR_VAR 0 11
61161: PUSH
61162: LD_VAR 0 4
61166: PPUSH
61167: LD_INT 2
61169: PPUSH
61170: CALL 50058 0 2
61174: PUSH
61175: LD_INT 1
61177: ARRAY
61178: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
61179: LD_ADDR_VAR 0 2
61183: PUSH
61184: LD_VAR 0 2
61188: PPUSH
61189: LD_INT 2
61191: PPUSH
61192: LD_VAR 0 11
61196: PPUSH
61197: CALL_OW 1
61201: ST_TO_ADDR
// tmp := tmp diff p ;
61202: LD_ADDR_VAR 0 4
61206: PUSH
61207: LD_VAR 0 4
61211: PUSH
61212: LD_VAR 0 11
61216: DIFF
61217: ST_TO_ADDR
// end ; if tmp and sci < 6 then
61218: LD_VAR 0 4
61222: PUSH
61223: LD_VAR 0 8
61227: PUSH
61228: LD_INT 6
61230: LESS
61231: AND
61232: IFFALSE 61420
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
61234: LD_ADDR_VAR 0 9
61238: PUSH
61239: LD_VAR 0 4
61243: PUSH
61244: LD_VAR 0 8
61248: PUSH
61249: LD_VAR 0 7
61253: UNION
61254: DIFF
61255: PPUSH
61256: LD_INT 4
61258: PPUSH
61259: CALL 50058 0 2
61263: ST_TO_ADDR
// p := [ ] ;
61264: LD_ADDR_VAR 0 11
61268: PUSH
61269: EMPTY
61270: ST_TO_ADDR
// if sort then
61271: LD_VAR 0 9
61275: IFFALSE 61391
// for i = 1 to 6 - sci do
61277: LD_ADDR_VAR 0 3
61281: PUSH
61282: DOUBLE
61283: LD_INT 1
61285: DEC
61286: ST_TO_ADDR
61287: LD_INT 6
61289: PUSH
61290: LD_VAR 0 8
61294: MINUS
61295: PUSH
61296: FOR_TO
61297: IFFALSE 61389
// begin if i = sort then
61299: LD_VAR 0 3
61303: PUSH
61304: LD_VAR 0 9
61308: EQUAL
61309: IFFALSE 61313
// break ;
61311: GO 61389
// if GetClass ( i ) = 4 then
61313: LD_VAR 0 3
61317: PPUSH
61318: CALL_OW 257
61322: PUSH
61323: LD_INT 4
61325: EQUAL
61326: IFFALSE 61330
// continue ;
61328: GO 61296
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61330: LD_ADDR_VAR 0 11
61334: PUSH
61335: LD_VAR 0 11
61339: PPUSH
61340: LD_VAR 0 11
61344: PUSH
61345: LD_INT 1
61347: PLUS
61348: PPUSH
61349: LD_VAR 0 9
61353: PUSH
61354: LD_VAR 0 3
61358: ARRAY
61359: PPUSH
61360: CALL_OW 2
61364: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61365: LD_ADDR_VAR 0 4
61369: PUSH
61370: LD_VAR 0 4
61374: PUSH
61375: LD_VAR 0 9
61379: PUSH
61380: LD_VAR 0 3
61384: ARRAY
61385: DIFF
61386: ST_TO_ADDR
// end ;
61387: GO 61296
61389: POP
61390: POP
// if p then
61391: LD_VAR 0 11
61395: IFFALSE 61420
// result := Replace ( result , 4 , p ) ;
61397: LD_ADDR_VAR 0 2
61401: PUSH
61402: LD_VAR 0 2
61406: PPUSH
61407: LD_INT 4
61409: PPUSH
61410: LD_VAR 0 11
61414: PPUSH
61415: CALL_OW 1
61419: ST_TO_ADDR
// end ; if tmp and mech < 6 then
61420: LD_VAR 0 4
61424: PUSH
61425: LD_VAR 0 7
61429: PUSH
61430: LD_INT 6
61432: LESS
61433: AND
61434: IFFALSE 61622
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
61436: LD_ADDR_VAR 0 9
61440: PUSH
61441: LD_VAR 0 4
61445: PUSH
61446: LD_VAR 0 8
61450: PUSH
61451: LD_VAR 0 7
61455: UNION
61456: DIFF
61457: PPUSH
61458: LD_INT 3
61460: PPUSH
61461: CALL 50058 0 2
61465: ST_TO_ADDR
// p := [ ] ;
61466: LD_ADDR_VAR 0 11
61470: PUSH
61471: EMPTY
61472: ST_TO_ADDR
// if sort then
61473: LD_VAR 0 9
61477: IFFALSE 61593
// for i = 1 to 6 - mech do
61479: LD_ADDR_VAR 0 3
61483: PUSH
61484: DOUBLE
61485: LD_INT 1
61487: DEC
61488: ST_TO_ADDR
61489: LD_INT 6
61491: PUSH
61492: LD_VAR 0 7
61496: MINUS
61497: PUSH
61498: FOR_TO
61499: IFFALSE 61591
// begin if i = sort then
61501: LD_VAR 0 3
61505: PUSH
61506: LD_VAR 0 9
61510: EQUAL
61511: IFFALSE 61515
// break ;
61513: GO 61591
// if GetClass ( i ) = 3 then
61515: LD_VAR 0 3
61519: PPUSH
61520: CALL_OW 257
61524: PUSH
61525: LD_INT 3
61527: EQUAL
61528: IFFALSE 61532
// continue ;
61530: GO 61498
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61532: LD_ADDR_VAR 0 11
61536: PUSH
61537: LD_VAR 0 11
61541: PPUSH
61542: LD_VAR 0 11
61546: PUSH
61547: LD_INT 1
61549: PLUS
61550: PPUSH
61551: LD_VAR 0 9
61555: PUSH
61556: LD_VAR 0 3
61560: ARRAY
61561: PPUSH
61562: CALL_OW 2
61566: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61567: LD_ADDR_VAR 0 4
61571: PUSH
61572: LD_VAR 0 4
61576: PUSH
61577: LD_VAR 0 9
61581: PUSH
61582: LD_VAR 0 3
61586: ARRAY
61587: DIFF
61588: ST_TO_ADDR
// end ;
61589: GO 61498
61591: POP
61592: POP
// if p then
61593: LD_VAR 0 11
61597: IFFALSE 61622
// result := Replace ( result , 3 , p ) ;
61599: LD_ADDR_VAR 0 2
61603: PUSH
61604: LD_VAR 0 2
61608: PPUSH
61609: LD_INT 3
61611: PPUSH
61612: LD_VAR 0 11
61616: PPUSH
61617: CALL_OW 1
61621: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
61622: LD_VAR 0 4
61626: PUSH
61627: LD_INT 6
61629: GREATER
61630: PUSH
61631: LD_VAR 0 6
61635: PUSH
61636: LD_INT 6
61638: LESS
61639: AND
61640: IFFALSE 61834
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
61642: LD_ADDR_VAR 0 9
61646: PUSH
61647: LD_VAR 0 4
61651: PUSH
61652: LD_VAR 0 8
61656: PUSH
61657: LD_VAR 0 7
61661: UNION
61662: PUSH
61663: LD_VAR 0 6
61667: UNION
61668: DIFF
61669: PPUSH
61670: LD_INT 2
61672: PPUSH
61673: CALL 50058 0 2
61677: ST_TO_ADDR
// p := [ ] ;
61678: LD_ADDR_VAR 0 11
61682: PUSH
61683: EMPTY
61684: ST_TO_ADDR
// if sort then
61685: LD_VAR 0 9
61689: IFFALSE 61805
// for i = 1 to 6 - eng do
61691: LD_ADDR_VAR 0 3
61695: PUSH
61696: DOUBLE
61697: LD_INT 1
61699: DEC
61700: ST_TO_ADDR
61701: LD_INT 6
61703: PUSH
61704: LD_VAR 0 6
61708: MINUS
61709: PUSH
61710: FOR_TO
61711: IFFALSE 61803
// begin if i = sort then
61713: LD_VAR 0 3
61717: PUSH
61718: LD_VAR 0 9
61722: EQUAL
61723: IFFALSE 61727
// break ;
61725: GO 61803
// if GetClass ( i ) = 2 then
61727: LD_VAR 0 3
61731: PPUSH
61732: CALL_OW 257
61736: PUSH
61737: LD_INT 2
61739: EQUAL
61740: IFFALSE 61744
// continue ;
61742: GO 61710
// p := Insert ( p , p + 1 , sort [ i ] ) ;
61744: LD_ADDR_VAR 0 11
61748: PUSH
61749: LD_VAR 0 11
61753: PPUSH
61754: LD_VAR 0 11
61758: PUSH
61759: LD_INT 1
61761: PLUS
61762: PPUSH
61763: LD_VAR 0 9
61767: PUSH
61768: LD_VAR 0 3
61772: ARRAY
61773: PPUSH
61774: CALL_OW 2
61778: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
61779: LD_ADDR_VAR 0 4
61783: PUSH
61784: LD_VAR 0 4
61788: PUSH
61789: LD_VAR 0 9
61793: PUSH
61794: LD_VAR 0 3
61798: ARRAY
61799: DIFF
61800: ST_TO_ADDR
// end ;
61801: GO 61710
61803: POP
61804: POP
// if p then
61805: LD_VAR 0 11
61809: IFFALSE 61834
// result := Replace ( result , 2 , p ) ;
61811: LD_ADDR_VAR 0 2
61815: PUSH
61816: LD_VAR 0 2
61820: PPUSH
61821: LD_INT 2
61823: PPUSH
61824: LD_VAR 0 11
61828: PPUSH
61829: CALL_OW 1
61833: ST_TO_ADDR
// end ; exit ;
61834: GO 63222
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
61836: LD_EXP 87
61840: PUSH
61841: LD_EXP 86
61845: PUSH
61846: LD_VAR 0 1
61850: ARRAY
61851: ARRAY
61852: NOT
61853: PUSH
61854: LD_EXP 60
61858: PUSH
61859: LD_VAR 0 1
61863: ARRAY
61864: PPUSH
61865: LD_INT 30
61867: PUSH
61868: LD_INT 3
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: PPUSH
61875: CALL_OW 72
61879: AND
61880: PUSH
61881: LD_EXP 65
61885: PUSH
61886: LD_VAR 0 1
61890: ARRAY
61891: AND
61892: IFFALSE 62500
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
61894: LD_ADDR_EXP 102
61898: PUSH
61899: LD_EXP 102
61903: PPUSH
61904: LD_VAR 0 1
61908: PPUSH
61909: LD_INT 5
61911: PPUSH
61912: CALL_OW 1
61916: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
61917: LD_ADDR_VAR 0 2
61921: PUSH
61922: LD_INT 0
61924: PUSH
61925: LD_INT 0
61927: PUSH
61928: LD_INT 0
61930: PUSH
61931: LD_INT 0
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: LIST
61938: LIST
61939: ST_TO_ADDR
// if sci > 1 then
61940: LD_VAR 0 8
61944: PUSH
61945: LD_INT 1
61947: GREATER
61948: IFFALSE 61976
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
61950: LD_ADDR_VAR 0 4
61954: PUSH
61955: LD_VAR 0 4
61959: PUSH
61960: LD_VAR 0 8
61964: PUSH
61965: LD_VAR 0 8
61969: PUSH
61970: LD_INT 1
61972: ARRAY
61973: DIFF
61974: DIFF
61975: ST_TO_ADDR
// if tmp and not sci then
61976: LD_VAR 0 4
61980: PUSH
61981: LD_VAR 0 8
61985: NOT
61986: AND
61987: IFFALSE 62056
// begin sort := SortBySkill ( tmp , 4 ) ;
61989: LD_ADDR_VAR 0 9
61993: PUSH
61994: LD_VAR 0 4
61998: PPUSH
61999: LD_INT 4
62001: PPUSH
62002: CALL 50058 0 2
62006: ST_TO_ADDR
// if sort then
62007: LD_VAR 0 9
62011: IFFALSE 62027
// p := sort [ 1 ] ;
62013: LD_ADDR_VAR 0 11
62017: PUSH
62018: LD_VAR 0 9
62022: PUSH
62023: LD_INT 1
62025: ARRAY
62026: ST_TO_ADDR
// if p then
62027: LD_VAR 0 11
62031: IFFALSE 62056
// result := Replace ( result , 4 , p ) ;
62033: LD_ADDR_VAR 0 2
62037: PUSH
62038: LD_VAR 0 2
62042: PPUSH
62043: LD_INT 4
62045: PPUSH
62046: LD_VAR 0 11
62050: PPUSH
62051: CALL_OW 1
62055: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62056: LD_ADDR_VAR 0 4
62060: PUSH
62061: LD_VAR 0 4
62065: PUSH
62066: LD_VAR 0 7
62070: DIFF
62071: ST_TO_ADDR
// if tmp and mech < 6 then
62072: LD_VAR 0 4
62076: PUSH
62077: LD_VAR 0 7
62081: PUSH
62082: LD_INT 6
62084: LESS
62085: AND
62086: IFFALSE 62274
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62088: LD_ADDR_VAR 0 9
62092: PUSH
62093: LD_VAR 0 4
62097: PUSH
62098: LD_VAR 0 8
62102: PUSH
62103: LD_VAR 0 7
62107: UNION
62108: DIFF
62109: PPUSH
62110: LD_INT 3
62112: PPUSH
62113: CALL 50058 0 2
62117: ST_TO_ADDR
// p := [ ] ;
62118: LD_ADDR_VAR 0 11
62122: PUSH
62123: EMPTY
62124: ST_TO_ADDR
// if sort then
62125: LD_VAR 0 9
62129: IFFALSE 62245
// for i = 1 to 6 - mech do
62131: LD_ADDR_VAR 0 3
62135: PUSH
62136: DOUBLE
62137: LD_INT 1
62139: DEC
62140: ST_TO_ADDR
62141: LD_INT 6
62143: PUSH
62144: LD_VAR 0 7
62148: MINUS
62149: PUSH
62150: FOR_TO
62151: IFFALSE 62243
// begin if i = sort then
62153: LD_VAR 0 3
62157: PUSH
62158: LD_VAR 0 9
62162: EQUAL
62163: IFFALSE 62167
// break ;
62165: GO 62243
// if GetClass ( i ) = 3 then
62167: LD_VAR 0 3
62171: PPUSH
62172: CALL_OW 257
62176: PUSH
62177: LD_INT 3
62179: EQUAL
62180: IFFALSE 62184
// continue ;
62182: GO 62150
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62184: LD_ADDR_VAR 0 11
62188: PUSH
62189: LD_VAR 0 11
62193: PPUSH
62194: LD_VAR 0 11
62198: PUSH
62199: LD_INT 1
62201: PLUS
62202: PPUSH
62203: LD_VAR 0 9
62207: PUSH
62208: LD_VAR 0 3
62212: ARRAY
62213: PPUSH
62214: CALL_OW 2
62218: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62219: LD_ADDR_VAR 0 4
62223: PUSH
62224: LD_VAR 0 4
62228: PUSH
62229: LD_VAR 0 9
62233: PUSH
62234: LD_VAR 0 3
62238: ARRAY
62239: DIFF
62240: ST_TO_ADDR
// end ;
62241: GO 62150
62243: POP
62244: POP
// if p then
62245: LD_VAR 0 11
62249: IFFALSE 62274
// result := Replace ( result , 3 , p ) ;
62251: LD_ADDR_VAR 0 2
62255: PUSH
62256: LD_VAR 0 2
62260: PPUSH
62261: LD_INT 3
62263: PPUSH
62264: LD_VAR 0 11
62268: PPUSH
62269: CALL_OW 1
62273: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62274: LD_ADDR_VAR 0 4
62278: PUSH
62279: LD_VAR 0 4
62283: PUSH
62284: LD_VAR 0 6
62288: DIFF
62289: ST_TO_ADDR
// if tmp and eng < 6 then
62290: LD_VAR 0 4
62294: PUSH
62295: LD_VAR 0 6
62299: PUSH
62300: LD_INT 6
62302: LESS
62303: AND
62304: IFFALSE 62498
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62306: LD_ADDR_VAR 0 9
62310: PUSH
62311: LD_VAR 0 4
62315: PUSH
62316: LD_VAR 0 8
62320: PUSH
62321: LD_VAR 0 7
62325: UNION
62326: PUSH
62327: LD_VAR 0 6
62331: UNION
62332: DIFF
62333: PPUSH
62334: LD_INT 2
62336: PPUSH
62337: CALL 50058 0 2
62341: ST_TO_ADDR
// p := [ ] ;
62342: LD_ADDR_VAR 0 11
62346: PUSH
62347: EMPTY
62348: ST_TO_ADDR
// if sort then
62349: LD_VAR 0 9
62353: IFFALSE 62469
// for i = 1 to 6 - eng do
62355: LD_ADDR_VAR 0 3
62359: PUSH
62360: DOUBLE
62361: LD_INT 1
62363: DEC
62364: ST_TO_ADDR
62365: LD_INT 6
62367: PUSH
62368: LD_VAR 0 6
62372: MINUS
62373: PUSH
62374: FOR_TO
62375: IFFALSE 62467
// begin if i = sort then
62377: LD_VAR 0 3
62381: PUSH
62382: LD_VAR 0 9
62386: EQUAL
62387: IFFALSE 62391
// break ;
62389: GO 62467
// if GetClass ( i ) = 2 then
62391: LD_VAR 0 3
62395: PPUSH
62396: CALL_OW 257
62400: PUSH
62401: LD_INT 2
62403: EQUAL
62404: IFFALSE 62408
// continue ;
62406: GO 62374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62408: LD_ADDR_VAR 0 11
62412: PUSH
62413: LD_VAR 0 11
62417: PPUSH
62418: LD_VAR 0 11
62422: PUSH
62423: LD_INT 1
62425: PLUS
62426: PPUSH
62427: LD_VAR 0 9
62431: PUSH
62432: LD_VAR 0 3
62436: ARRAY
62437: PPUSH
62438: CALL_OW 2
62442: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62443: LD_ADDR_VAR 0 4
62447: PUSH
62448: LD_VAR 0 4
62452: PUSH
62453: LD_VAR 0 9
62457: PUSH
62458: LD_VAR 0 3
62462: ARRAY
62463: DIFF
62464: ST_TO_ADDR
// end ;
62465: GO 62374
62467: POP
62468: POP
// if p then
62469: LD_VAR 0 11
62473: IFFALSE 62498
// result := Replace ( result , 2 , p ) ;
62475: LD_ADDR_VAR 0 2
62479: PUSH
62480: LD_VAR 0 2
62484: PPUSH
62485: LD_INT 2
62487: PPUSH
62488: LD_VAR 0 11
62492: PPUSH
62493: CALL_OW 1
62497: ST_TO_ADDR
// end ; exit ;
62498: GO 63222
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
62500: LD_EXP 87
62504: PUSH
62505: LD_EXP 86
62509: PUSH
62510: LD_VAR 0 1
62514: ARRAY
62515: ARRAY
62516: NOT
62517: PUSH
62518: LD_EXP 60
62522: PUSH
62523: LD_VAR 0 1
62527: ARRAY
62528: PPUSH
62529: LD_INT 30
62531: PUSH
62532: LD_INT 3
62534: PUSH
62535: EMPTY
62536: LIST
62537: LIST
62538: PPUSH
62539: CALL_OW 72
62543: AND
62544: PUSH
62545: LD_EXP 65
62549: PUSH
62550: LD_VAR 0 1
62554: ARRAY
62555: NOT
62556: AND
62557: IFFALSE 63222
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
62559: LD_ADDR_EXP 102
62563: PUSH
62564: LD_EXP 102
62568: PPUSH
62569: LD_VAR 0 1
62573: PPUSH
62574: LD_INT 6
62576: PPUSH
62577: CALL_OW 1
62581: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62582: LD_ADDR_VAR 0 2
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: LD_INT 0
62592: PUSH
62593: LD_INT 0
62595: PUSH
62596: LD_INT 0
62598: PUSH
62599: EMPTY
62600: LIST
62601: LIST
62602: LIST
62603: LIST
62604: ST_TO_ADDR
// if sci >= 1 then
62605: LD_VAR 0 8
62609: PUSH
62610: LD_INT 1
62612: GREATEREQUAL
62613: IFFALSE 62635
// tmp := tmp diff sci [ 1 ] ;
62615: LD_ADDR_VAR 0 4
62619: PUSH
62620: LD_VAR 0 4
62624: PUSH
62625: LD_VAR 0 8
62629: PUSH
62630: LD_INT 1
62632: ARRAY
62633: DIFF
62634: ST_TO_ADDR
// if tmp and not sci then
62635: LD_VAR 0 4
62639: PUSH
62640: LD_VAR 0 8
62644: NOT
62645: AND
62646: IFFALSE 62715
// begin sort := SortBySkill ( tmp , 4 ) ;
62648: LD_ADDR_VAR 0 9
62652: PUSH
62653: LD_VAR 0 4
62657: PPUSH
62658: LD_INT 4
62660: PPUSH
62661: CALL 50058 0 2
62665: ST_TO_ADDR
// if sort then
62666: LD_VAR 0 9
62670: IFFALSE 62686
// p := sort [ 1 ] ;
62672: LD_ADDR_VAR 0 11
62676: PUSH
62677: LD_VAR 0 9
62681: PUSH
62682: LD_INT 1
62684: ARRAY
62685: ST_TO_ADDR
// if p then
62686: LD_VAR 0 11
62690: IFFALSE 62715
// result := Replace ( result , 4 , p ) ;
62692: LD_ADDR_VAR 0 2
62696: PUSH
62697: LD_VAR 0 2
62701: PPUSH
62702: LD_INT 4
62704: PPUSH
62705: LD_VAR 0 11
62709: PPUSH
62710: CALL_OW 1
62714: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
62715: LD_ADDR_VAR 0 4
62719: PUSH
62720: LD_VAR 0 4
62724: PUSH
62725: LD_VAR 0 7
62729: DIFF
62730: ST_TO_ADDR
// if tmp and mech < 6 then
62731: LD_VAR 0 4
62735: PUSH
62736: LD_VAR 0 7
62740: PUSH
62741: LD_INT 6
62743: LESS
62744: AND
62745: IFFALSE 62927
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
62747: LD_ADDR_VAR 0 9
62751: PUSH
62752: LD_VAR 0 4
62756: PUSH
62757: LD_VAR 0 7
62761: DIFF
62762: PPUSH
62763: LD_INT 3
62765: PPUSH
62766: CALL 50058 0 2
62770: ST_TO_ADDR
// p := [ ] ;
62771: LD_ADDR_VAR 0 11
62775: PUSH
62776: EMPTY
62777: ST_TO_ADDR
// if sort then
62778: LD_VAR 0 9
62782: IFFALSE 62898
// for i = 1 to 6 - mech do
62784: LD_ADDR_VAR 0 3
62788: PUSH
62789: DOUBLE
62790: LD_INT 1
62792: DEC
62793: ST_TO_ADDR
62794: LD_INT 6
62796: PUSH
62797: LD_VAR 0 7
62801: MINUS
62802: PUSH
62803: FOR_TO
62804: IFFALSE 62896
// begin if i = sort then
62806: LD_VAR 0 3
62810: PUSH
62811: LD_VAR 0 9
62815: EQUAL
62816: IFFALSE 62820
// break ;
62818: GO 62896
// if GetClass ( i ) = 3 then
62820: LD_VAR 0 3
62824: PPUSH
62825: CALL_OW 257
62829: PUSH
62830: LD_INT 3
62832: EQUAL
62833: IFFALSE 62837
// continue ;
62835: GO 62803
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62837: LD_ADDR_VAR 0 11
62841: PUSH
62842: LD_VAR 0 11
62846: PPUSH
62847: LD_VAR 0 11
62851: PUSH
62852: LD_INT 1
62854: PLUS
62855: PPUSH
62856: LD_VAR 0 9
62860: PUSH
62861: LD_VAR 0 3
62865: ARRAY
62866: PPUSH
62867: CALL_OW 2
62871: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62872: LD_ADDR_VAR 0 4
62876: PUSH
62877: LD_VAR 0 4
62881: PUSH
62882: LD_VAR 0 9
62886: PUSH
62887: LD_VAR 0 3
62891: ARRAY
62892: DIFF
62893: ST_TO_ADDR
// end ;
62894: GO 62803
62896: POP
62897: POP
// if p then
62898: LD_VAR 0 11
62902: IFFALSE 62927
// result := Replace ( result , 3 , p ) ;
62904: LD_ADDR_VAR 0 2
62908: PUSH
62909: LD_VAR 0 2
62913: PPUSH
62914: LD_INT 3
62916: PPUSH
62917: LD_VAR 0 11
62921: PPUSH
62922: CALL_OW 1
62926: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
62927: LD_ADDR_VAR 0 4
62931: PUSH
62932: LD_VAR 0 4
62936: PUSH
62937: LD_VAR 0 6
62941: DIFF
62942: ST_TO_ADDR
// if tmp and eng < 4 then
62943: LD_VAR 0 4
62947: PUSH
62948: LD_VAR 0 6
62952: PUSH
62953: LD_INT 4
62955: LESS
62956: AND
62957: IFFALSE 63147
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
62959: LD_ADDR_VAR 0 9
62963: PUSH
62964: LD_VAR 0 4
62968: PUSH
62969: LD_VAR 0 7
62973: PUSH
62974: LD_VAR 0 6
62978: UNION
62979: DIFF
62980: PPUSH
62981: LD_INT 2
62983: PPUSH
62984: CALL 50058 0 2
62988: ST_TO_ADDR
// p := [ ] ;
62989: LD_ADDR_VAR 0 11
62993: PUSH
62994: EMPTY
62995: ST_TO_ADDR
// if sort then
62996: LD_VAR 0 9
63000: IFFALSE 63116
// for i = 1 to 4 - eng do
63002: LD_ADDR_VAR 0 3
63006: PUSH
63007: DOUBLE
63008: LD_INT 1
63010: DEC
63011: ST_TO_ADDR
63012: LD_INT 4
63014: PUSH
63015: LD_VAR 0 6
63019: MINUS
63020: PUSH
63021: FOR_TO
63022: IFFALSE 63114
// begin if i = sort then
63024: LD_VAR 0 3
63028: PUSH
63029: LD_VAR 0 9
63033: EQUAL
63034: IFFALSE 63038
// break ;
63036: GO 63114
// if GetClass ( i ) = 2 then
63038: LD_VAR 0 3
63042: PPUSH
63043: CALL_OW 257
63047: PUSH
63048: LD_INT 2
63050: EQUAL
63051: IFFALSE 63055
// continue ;
63053: GO 63021
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63055: LD_ADDR_VAR 0 11
63059: PUSH
63060: LD_VAR 0 11
63064: PPUSH
63065: LD_VAR 0 11
63069: PUSH
63070: LD_INT 1
63072: PLUS
63073: PPUSH
63074: LD_VAR 0 9
63078: PUSH
63079: LD_VAR 0 3
63083: ARRAY
63084: PPUSH
63085: CALL_OW 2
63089: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63090: LD_ADDR_VAR 0 4
63094: PUSH
63095: LD_VAR 0 4
63099: PUSH
63100: LD_VAR 0 9
63104: PUSH
63105: LD_VAR 0 3
63109: ARRAY
63110: DIFF
63111: ST_TO_ADDR
// end ;
63112: GO 63021
63114: POP
63115: POP
// if p then
63116: LD_VAR 0 11
63120: IFFALSE 63145
// result := Replace ( result , 2 , p ) ;
63122: LD_ADDR_VAR 0 2
63126: PUSH
63127: LD_VAR 0 2
63131: PPUSH
63132: LD_INT 2
63134: PPUSH
63135: LD_VAR 0 11
63139: PPUSH
63140: CALL_OW 1
63144: ST_TO_ADDR
// end else
63145: GO 63191
// for i = eng downto 5 do
63147: LD_ADDR_VAR 0 3
63151: PUSH
63152: DOUBLE
63153: LD_VAR 0 6
63157: INC
63158: ST_TO_ADDR
63159: LD_INT 5
63161: PUSH
63162: FOR_DOWNTO
63163: IFFALSE 63189
// tmp := tmp union eng [ i ] ;
63165: LD_ADDR_VAR 0 4
63169: PUSH
63170: LD_VAR 0 4
63174: PUSH
63175: LD_VAR 0 6
63179: PUSH
63180: LD_VAR 0 3
63184: ARRAY
63185: UNION
63186: ST_TO_ADDR
63187: GO 63162
63189: POP
63190: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
63191: LD_ADDR_VAR 0 2
63195: PUSH
63196: LD_VAR 0 2
63200: PPUSH
63201: LD_INT 1
63203: PPUSH
63204: LD_VAR 0 4
63208: PUSH
63209: LD_VAR 0 5
63213: DIFF
63214: PPUSH
63215: CALL_OW 1
63219: ST_TO_ADDR
// exit ;
63220: GO 63222
// end ; end ;
63222: LD_VAR 0 2
63226: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
63227: LD_INT 0
63229: PPUSH
63230: PPUSH
63231: PPUSH
// if not mc_bases then
63232: LD_EXP 60
63236: NOT
63237: IFFALSE 63241
// exit ;
63239: GO 63383
// for i = 1 to mc_bases do
63241: LD_ADDR_VAR 0 2
63245: PUSH
63246: DOUBLE
63247: LD_INT 1
63249: DEC
63250: ST_TO_ADDR
63251: LD_EXP 60
63255: PUSH
63256: FOR_TO
63257: IFFALSE 63374
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
63259: LD_ADDR_VAR 0 3
63263: PUSH
63264: LD_EXP 60
63268: PUSH
63269: LD_VAR 0 2
63273: ARRAY
63274: PPUSH
63275: LD_INT 21
63277: PUSH
63278: LD_INT 3
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: LD_INT 3
63287: PUSH
63288: LD_INT 2
63290: PUSH
63291: LD_INT 30
63293: PUSH
63294: LD_INT 29
63296: PUSH
63297: EMPTY
63298: LIST
63299: LIST
63300: PUSH
63301: LD_INT 30
63303: PUSH
63304: LD_INT 30
63306: PUSH
63307: EMPTY
63308: LIST
63309: LIST
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: LIST
63315: PUSH
63316: EMPTY
63317: LIST
63318: LIST
63319: PUSH
63320: LD_INT 3
63322: PUSH
63323: LD_INT 24
63325: PUSH
63326: LD_INT 1000
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: LIST
63341: PPUSH
63342: CALL_OW 72
63346: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
63347: LD_ADDR_EXP 61
63351: PUSH
63352: LD_EXP 61
63356: PPUSH
63357: LD_VAR 0 2
63361: PPUSH
63362: LD_VAR 0 3
63366: PPUSH
63367: CALL_OW 1
63371: ST_TO_ADDR
// end ;
63372: GO 63256
63374: POP
63375: POP
// RaiseSailEvent ( 101 ) ;
63376: LD_INT 101
63378: PPUSH
63379: CALL_OW 427
// end ;
63383: LD_VAR 0 1
63387: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
63388: LD_INT 0
63390: PPUSH
63391: PPUSH
63392: PPUSH
63393: PPUSH
63394: PPUSH
63395: PPUSH
63396: PPUSH
// if not mc_bases then
63397: LD_EXP 60
63401: NOT
63402: IFFALSE 63406
// exit ;
63404: GO 63968
// for i = 1 to mc_bases do
63406: LD_ADDR_VAR 0 2
63410: PUSH
63411: DOUBLE
63412: LD_INT 1
63414: DEC
63415: ST_TO_ADDR
63416: LD_EXP 60
63420: PUSH
63421: FOR_TO
63422: IFFALSE 63959
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
63424: LD_ADDR_VAR 0 5
63428: PUSH
63429: LD_EXP 60
63433: PUSH
63434: LD_VAR 0 2
63438: ARRAY
63439: PUSH
63440: LD_EXP 89
63444: PUSH
63445: LD_VAR 0 2
63449: ARRAY
63450: UNION
63451: PPUSH
63452: LD_INT 21
63454: PUSH
63455: LD_INT 1
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 1
63464: PUSH
63465: LD_INT 3
63467: PUSH
63468: LD_INT 54
63470: PUSH
63471: EMPTY
63472: LIST
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 3
63480: PUSH
63481: LD_INT 24
63483: PUSH
63484: LD_INT 1000
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: EMPTY
63492: LIST
63493: LIST
63494: PUSH
63495: EMPTY
63496: LIST
63497: LIST
63498: LIST
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PPUSH
63504: CALL_OW 72
63508: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
63509: LD_ADDR_VAR 0 6
63513: PUSH
63514: LD_EXP 60
63518: PUSH
63519: LD_VAR 0 2
63523: ARRAY
63524: PPUSH
63525: LD_INT 21
63527: PUSH
63528: LD_INT 1
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 1
63537: PUSH
63538: LD_INT 3
63540: PUSH
63541: LD_INT 54
63543: PUSH
63544: EMPTY
63545: LIST
63546: PUSH
63547: EMPTY
63548: LIST
63549: LIST
63550: PUSH
63551: LD_INT 3
63553: PUSH
63554: LD_INT 24
63556: PUSH
63557: LD_INT 250
63559: PUSH
63560: EMPTY
63561: LIST
63562: LIST
63563: PUSH
63564: EMPTY
63565: LIST
63566: LIST
63567: PUSH
63568: EMPTY
63569: LIST
63570: LIST
63571: LIST
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PPUSH
63577: CALL_OW 72
63581: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
63582: LD_ADDR_VAR 0 7
63586: PUSH
63587: LD_VAR 0 5
63591: PUSH
63592: LD_VAR 0 6
63596: DIFF
63597: ST_TO_ADDR
// if not need_heal_1 then
63598: LD_VAR 0 6
63602: NOT
63603: IFFALSE 63636
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
63605: LD_ADDR_EXP 63
63609: PUSH
63610: LD_EXP 63
63614: PPUSH
63615: LD_VAR 0 2
63619: PUSH
63620: LD_INT 1
63622: PUSH
63623: EMPTY
63624: LIST
63625: LIST
63626: PPUSH
63627: EMPTY
63628: PPUSH
63629: CALL 19801 0 3
63633: ST_TO_ADDR
63634: GO 63706
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
63636: LD_ADDR_EXP 63
63640: PUSH
63641: LD_EXP 63
63645: PPUSH
63646: LD_VAR 0 2
63650: PUSH
63651: LD_INT 1
63653: PUSH
63654: EMPTY
63655: LIST
63656: LIST
63657: PPUSH
63658: LD_EXP 63
63662: PUSH
63663: LD_VAR 0 2
63667: ARRAY
63668: PUSH
63669: LD_INT 1
63671: ARRAY
63672: PPUSH
63673: LD_INT 3
63675: PUSH
63676: LD_INT 24
63678: PUSH
63679: LD_INT 1000
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PPUSH
63690: CALL_OW 72
63694: PUSH
63695: LD_VAR 0 6
63699: UNION
63700: PPUSH
63701: CALL 19801 0 3
63705: ST_TO_ADDR
// if not need_heal_2 then
63706: LD_VAR 0 7
63710: NOT
63711: IFFALSE 63744
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
63713: LD_ADDR_EXP 63
63717: PUSH
63718: LD_EXP 63
63722: PPUSH
63723: LD_VAR 0 2
63727: PUSH
63728: LD_INT 2
63730: PUSH
63731: EMPTY
63732: LIST
63733: LIST
63734: PPUSH
63735: EMPTY
63736: PPUSH
63737: CALL 19801 0 3
63741: ST_TO_ADDR
63742: GO 63776
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
63744: LD_ADDR_EXP 63
63748: PUSH
63749: LD_EXP 63
63753: PPUSH
63754: LD_VAR 0 2
63758: PUSH
63759: LD_INT 2
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PPUSH
63766: LD_VAR 0 7
63770: PPUSH
63771: CALL 19801 0 3
63775: ST_TO_ADDR
// if need_heal_2 then
63776: LD_VAR 0 7
63780: IFFALSE 63941
// for j in need_heal_2 do
63782: LD_ADDR_VAR 0 3
63786: PUSH
63787: LD_VAR 0 7
63791: PUSH
63792: FOR_IN
63793: IFFALSE 63939
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63795: LD_ADDR_VAR 0 5
63799: PUSH
63800: LD_EXP 60
63804: PUSH
63805: LD_VAR 0 2
63809: ARRAY
63810: PPUSH
63811: LD_INT 2
63813: PUSH
63814: LD_INT 30
63816: PUSH
63817: LD_INT 6
63819: PUSH
63820: EMPTY
63821: LIST
63822: LIST
63823: PUSH
63824: LD_INT 30
63826: PUSH
63827: LD_INT 7
63829: PUSH
63830: EMPTY
63831: LIST
63832: LIST
63833: PUSH
63834: LD_INT 30
63836: PUSH
63837: LD_INT 8
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PUSH
63844: LD_INT 30
63846: PUSH
63847: LD_INT 0
63849: PUSH
63850: EMPTY
63851: LIST
63852: LIST
63853: PUSH
63854: LD_INT 30
63856: PUSH
63857: LD_INT 1
63859: PUSH
63860: EMPTY
63861: LIST
63862: LIST
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: LIST
63868: LIST
63869: LIST
63870: LIST
63871: PPUSH
63872: CALL_OW 72
63876: ST_TO_ADDR
// if tmp then
63877: LD_VAR 0 5
63881: IFFALSE 63937
// begin k := NearestUnitToUnit ( tmp , j ) ;
63883: LD_ADDR_VAR 0 4
63887: PUSH
63888: LD_VAR 0 5
63892: PPUSH
63893: LD_VAR 0 3
63897: PPUSH
63898: CALL_OW 74
63902: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
63903: LD_VAR 0 3
63907: PPUSH
63908: LD_VAR 0 4
63912: PPUSH
63913: CALL_OW 296
63917: PUSH
63918: LD_INT 5
63920: GREATER
63921: IFFALSE 63937
// ComMoveToNearbyEntrance ( j , k ) ;
63923: LD_VAR 0 3
63927: PPUSH
63928: LD_VAR 0 4
63932: PPUSH
63933: CALL 52419 0 2
// end ; end ;
63937: GO 63792
63939: POP
63940: POP
// if not need_heal_1 and not need_heal_2 then
63941: LD_VAR 0 6
63945: NOT
63946: PUSH
63947: LD_VAR 0 7
63951: NOT
63952: AND
63953: IFFALSE 63957
// continue ;
63955: GO 63421
// end ;
63957: GO 63421
63959: POP
63960: POP
// RaiseSailEvent ( 102 ) ;
63961: LD_INT 102
63963: PPUSH
63964: CALL_OW 427
// end ;
63968: LD_VAR 0 1
63972: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
63973: LD_INT 0
63975: PPUSH
63976: PPUSH
63977: PPUSH
63978: PPUSH
63979: PPUSH
63980: PPUSH
63981: PPUSH
63982: PPUSH
// if not mc_bases then
63983: LD_EXP 60
63987: NOT
63988: IFFALSE 63992
// exit ;
63990: GO 64875
// for i = 1 to mc_bases do
63992: LD_ADDR_VAR 0 2
63996: PUSH
63997: DOUBLE
63998: LD_INT 1
64000: DEC
64001: ST_TO_ADDR
64002: LD_EXP 60
64006: PUSH
64007: FOR_TO
64008: IFFALSE 64873
// begin if not mc_building_need_repair [ i ] then
64010: LD_EXP 61
64014: PUSH
64015: LD_VAR 0 2
64019: ARRAY
64020: NOT
64021: IFFALSE 64208
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
64023: LD_ADDR_VAR 0 6
64027: PUSH
64028: LD_EXP 79
64032: PUSH
64033: LD_VAR 0 2
64037: ARRAY
64038: PPUSH
64039: LD_INT 3
64041: PUSH
64042: LD_INT 24
64044: PUSH
64045: LD_INT 1000
64047: PUSH
64048: EMPTY
64049: LIST
64050: LIST
64051: PUSH
64052: EMPTY
64053: LIST
64054: LIST
64055: PUSH
64056: LD_INT 2
64058: PUSH
64059: LD_INT 34
64061: PUSH
64062: LD_INT 13
64064: PUSH
64065: EMPTY
64066: LIST
64067: LIST
64068: PUSH
64069: LD_INT 34
64071: PUSH
64072: LD_INT 52
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 34
64081: PUSH
64082: LD_EXP 110
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: LIST
64095: LIST
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PPUSH
64101: CALL_OW 72
64105: ST_TO_ADDR
// if cranes then
64106: LD_VAR 0 6
64110: IFFALSE 64172
// for j in cranes do
64112: LD_ADDR_VAR 0 3
64116: PUSH
64117: LD_VAR 0 6
64121: PUSH
64122: FOR_IN
64123: IFFALSE 64170
// if not IsInArea ( j , mc_parking [ i ] ) then
64125: LD_VAR 0 3
64129: PPUSH
64130: LD_EXP 84
64134: PUSH
64135: LD_VAR 0 2
64139: ARRAY
64140: PPUSH
64141: CALL_OW 308
64145: NOT
64146: IFFALSE 64168
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64148: LD_VAR 0 3
64152: PPUSH
64153: LD_EXP 84
64157: PUSH
64158: LD_VAR 0 2
64162: ARRAY
64163: PPUSH
64164: CALL_OW 113
64168: GO 64122
64170: POP
64171: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
64172: LD_ADDR_EXP 62
64176: PUSH
64177: LD_EXP 62
64181: PPUSH
64182: LD_VAR 0 2
64186: PPUSH
64187: EMPTY
64188: PPUSH
64189: CALL_OW 1
64193: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
64194: LD_VAR 0 2
64198: PPUSH
64199: LD_INT 101
64201: PPUSH
64202: CALL 59060 0 2
// continue ;
64206: GO 64007
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
64208: LD_ADDR_EXP 66
64212: PUSH
64213: LD_EXP 66
64217: PPUSH
64218: LD_VAR 0 2
64222: PPUSH
64223: EMPTY
64224: PPUSH
64225: CALL_OW 1
64229: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
64230: LD_VAR 0 2
64234: PPUSH
64235: LD_INT 103
64237: PPUSH
64238: CALL 59060 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
64242: LD_ADDR_VAR 0 5
64246: PUSH
64247: LD_EXP 60
64251: PUSH
64252: LD_VAR 0 2
64256: ARRAY
64257: PUSH
64258: LD_EXP 89
64262: PUSH
64263: LD_VAR 0 2
64267: ARRAY
64268: UNION
64269: PPUSH
64270: LD_INT 2
64272: PUSH
64273: LD_INT 25
64275: PUSH
64276: LD_INT 2
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: LD_INT 25
64285: PUSH
64286: LD_INT 16
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: LIST
64297: PUSH
64298: EMPTY
64299: LIST
64300: PPUSH
64301: CALL_OW 72
64305: ST_TO_ADDR
// if mc_need_heal [ i ] then
64306: LD_EXP 63
64310: PUSH
64311: LD_VAR 0 2
64315: ARRAY
64316: IFFALSE 64360
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
64318: LD_ADDR_VAR 0 5
64322: PUSH
64323: LD_VAR 0 5
64327: PUSH
64328: LD_EXP 63
64332: PUSH
64333: LD_VAR 0 2
64337: ARRAY
64338: PUSH
64339: LD_INT 1
64341: ARRAY
64342: PUSH
64343: LD_EXP 63
64347: PUSH
64348: LD_VAR 0 2
64352: ARRAY
64353: PUSH
64354: LD_INT 2
64356: ARRAY
64357: UNION
64358: DIFF
64359: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
64360: LD_ADDR_VAR 0 6
64364: PUSH
64365: LD_EXP 79
64369: PUSH
64370: LD_VAR 0 2
64374: ARRAY
64375: PPUSH
64376: LD_INT 2
64378: PUSH
64379: LD_INT 34
64381: PUSH
64382: LD_INT 13
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 34
64391: PUSH
64392: LD_INT 52
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 34
64401: PUSH
64402: LD_EXP 110
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: EMPTY
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: PPUSH
64417: CALL_OW 72
64421: ST_TO_ADDR
// if cranes then
64422: LD_VAR 0 6
64426: IFFALSE 64562
// begin for j in cranes do
64428: LD_ADDR_VAR 0 3
64432: PUSH
64433: LD_VAR 0 6
64437: PUSH
64438: FOR_IN
64439: IFFALSE 64560
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
64441: LD_VAR 0 3
64445: PPUSH
64446: CALL_OW 256
64450: PUSH
64451: LD_INT 1000
64453: EQUAL
64454: PUSH
64455: LD_VAR 0 3
64459: PPUSH
64460: CALL_OW 314
64464: NOT
64465: AND
64466: IFFALSE 64500
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
64468: LD_VAR 0 3
64472: PPUSH
64473: LD_EXP 61
64477: PUSH
64478: LD_VAR 0 2
64482: ARRAY
64483: PPUSH
64484: LD_VAR 0 3
64488: PPUSH
64489: CALL_OW 74
64493: PPUSH
64494: CALL_OW 130
64498: GO 64558
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
64500: LD_VAR 0 3
64504: PPUSH
64505: CALL_OW 256
64509: PUSH
64510: LD_INT 500
64512: LESS
64513: PUSH
64514: LD_VAR 0 3
64518: PPUSH
64519: LD_EXP 84
64523: PUSH
64524: LD_VAR 0 2
64528: ARRAY
64529: PPUSH
64530: CALL_OW 308
64534: NOT
64535: AND
64536: IFFALSE 64558
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64538: LD_VAR 0 3
64542: PPUSH
64543: LD_EXP 84
64547: PUSH
64548: LD_VAR 0 2
64552: ARRAY
64553: PPUSH
64554: CALL_OW 113
// end ;
64558: GO 64438
64560: POP
64561: POP
// end ; if tmp > 3 then
64562: LD_VAR 0 5
64566: PUSH
64567: LD_INT 3
64569: GREATER
64570: IFFALSE 64590
// tmp := ShrinkArray ( tmp , 4 ) ;
64572: LD_ADDR_VAR 0 5
64576: PUSH
64577: LD_VAR 0 5
64581: PPUSH
64582: LD_INT 4
64584: PPUSH
64585: CALL 51867 0 2
64589: ST_TO_ADDR
// if not tmp then
64590: LD_VAR 0 5
64594: NOT
64595: IFFALSE 64599
// continue ;
64597: GO 64007
// for j in tmp do
64599: LD_ADDR_VAR 0 3
64603: PUSH
64604: LD_VAR 0 5
64608: PUSH
64609: FOR_IN
64610: IFFALSE 64869
// begin if IsInUnit ( j ) then
64612: LD_VAR 0 3
64616: PPUSH
64617: CALL_OW 310
64621: IFFALSE 64632
// ComExitBuilding ( j ) ;
64623: LD_VAR 0 3
64627: PPUSH
64628: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
64632: LD_VAR 0 3
64636: PUSH
64637: LD_EXP 62
64641: PUSH
64642: LD_VAR 0 2
64646: ARRAY
64647: IN
64648: NOT
64649: IFFALSE 64707
// begin SetTag ( j , 101 ) ;
64651: LD_VAR 0 3
64655: PPUSH
64656: LD_INT 101
64658: PPUSH
64659: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
64663: LD_ADDR_EXP 62
64667: PUSH
64668: LD_EXP 62
64672: PPUSH
64673: LD_VAR 0 2
64677: PUSH
64678: LD_EXP 62
64682: PUSH
64683: LD_VAR 0 2
64687: ARRAY
64688: PUSH
64689: LD_INT 1
64691: PLUS
64692: PUSH
64693: EMPTY
64694: LIST
64695: LIST
64696: PPUSH
64697: LD_VAR 0 3
64701: PPUSH
64702: CALL 19801 0 3
64706: ST_TO_ADDR
// end ; wait ( 1 ) ;
64707: LD_INT 1
64709: PPUSH
64710: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
64714: LD_ADDR_VAR 0 7
64718: PUSH
64719: LD_EXP 61
64723: PUSH
64724: LD_VAR 0 2
64728: ARRAY
64729: ST_TO_ADDR
// if mc_scan [ i ] then
64730: LD_EXP 83
64734: PUSH
64735: LD_VAR 0 2
64739: ARRAY
64740: IFFALSE 64802
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
64742: LD_ADDR_VAR 0 7
64746: PUSH
64747: LD_EXP 61
64751: PUSH
64752: LD_VAR 0 2
64756: ARRAY
64757: PPUSH
64758: LD_INT 3
64760: PUSH
64761: LD_INT 30
64763: PUSH
64764: LD_INT 32
64766: PUSH
64767: EMPTY
64768: LIST
64769: LIST
64770: PUSH
64771: LD_INT 30
64773: PUSH
64774: LD_INT 33
64776: PUSH
64777: EMPTY
64778: LIST
64779: LIST
64780: PUSH
64781: LD_INT 30
64783: PUSH
64784: LD_INT 31
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: PPUSH
64797: CALL_OW 72
64801: ST_TO_ADDR
// if not to_repair_tmp then
64802: LD_VAR 0 7
64806: NOT
64807: IFFALSE 64811
// continue ;
64809: GO 64609
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
64811: LD_ADDR_VAR 0 8
64815: PUSH
64816: LD_VAR 0 7
64820: PPUSH
64821: LD_VAR 0 3
64825: PPUSH
64826: CALL_OW 74
64830: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
64831: LD_VAR 0 8
64835: PPUSH
64836: LD_INT 16
64838: PPUSH
64839: CALL 22400 0 2
64843: PUSH
64844: LD_INT 4
64846: ARRAY
64847: PUSH
64848: LD_INT 10
64850: LESS
64851: IFFALSE 64867
// ComRepairBuilding ( j , to_repair ) ;
64853: LD_VAR 0 3
64857: PPUSH
64858: LD_VAR 0 8
64862: PPUSH
64863: CALL_OW 130
// end ;
64867: GO 64609
64869: POP
64870: POP
// end ;
64871: GO 64007
64873: POP
64874: POP
// end ;
64875: LD_VAR 0 1
64879: RET
// export function MC_Heal ; var i , j , tmp ; begin
64880: LD_INT 0
64882: PPUSH
64883: PPUSH
64884: PPUSH
64885: PPUSH
// if not mc_bases then
64886: LD_EXP 60
64890: NOT
64891: IFFALSE 64895
// exit ;
64893: GO 65297
// for i = 1 to mc_bases do
64895: LD_ADDR_VAR 0 2
64899: PUSH
64900: DOUBLE
64901: LD_INT 1
64903: DEC
64904: ST_TO_ADDR
64905: LD_EXP 60
64909: PUSH
64910: FOR_TO
64911: IFFALSE 65295
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
64913: LD_EXP 63
64917: PUSH
64918: LD_VAR 0 2
64922: ARRAY
64923: PUSH
64924: LD_INT 1
64926: ARRAY
64927: NOT
64928: PUSH
64929: LD_EXP 63
64933: PUSH
64934: LD_VAR 0 2
64938: ARRAY
64939: PUSH
64940: LD_INT 2
64942: ARRAY
64943: NOT
64944: AND
64945: IFFALSE 64983
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
64947: LD_ADDR_EXP 64
64951: PUSH
64952: LD_EXP 64
64956: PPUSH
64957: LD_VAR 0 2
64961: PPUSH
64962: EMPTY
64963: PPUSH
64964: CALL_OW 1
64968: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
64969: LD_VAR 0 2
64973: PPUSH
64974: LD_INT 102
64976: PPUSH
64977: CALL 59060 0 2
// continue ;
64981: GO 64910
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
64983: LD_ADDR_VAR 0 4
64987: PUSH
64988: LD_EXP 60
64992: PUSH
64993: LD_VAR 0 2
64997: ARRAY
64998: PPUSH
64999: LD_INT 25
65001: PUSH
65002: LD_INT 4
65004: PUSH
65005: EMPTY
65006: LIST
65007: LIST
65008: PPUSH
65009: CALL_OW 72
65013: ST_TO_ADDR
// if not tmp then
65014: LD_VAR 0 4
65018: NOT
65019: IFFALSE 65023
// continue ;
65021: GO 64910
// if mc_taming [ i ] then
65023: LD_EXP 91
65027: PUSH
65028: LD_VAR 0 2
65032: ARRAY
65033: IFFALSE 65057
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
65035: LD_ADDR_EXP 91
65039: PUSH
65040: LD_EXP 91
65044: PPUSH
65045: LD_VAR 0 2
65049: PPUSH
65050: EMPTY
65051: PPUSH
65052: CALL_OW 1
65056: ST_TO_ADDR
// for j in tmp do
65057: LD_ADDR_VAR 0 3
65061: PUSH
65062: LD_VAR 0 4
65066: PUSH
65067: FOR_IN
65068: IFFALSE 65291
// begin if IsInUnit ( j ) then
65070: LD_VAR 0 3
65074: PPUSH
65075: CALL_OW 310
65079: IFFALSE 65090
// ComExitBuilding ( j ) ;
65081: LD_VAR 0 3
65085: PPUSH
65086: CALL_OW 122
// if not j in mc_healers [ i ] then
65090: LD_VAR 0 3
65094: PUSH
65095: LD_EXP 64
65099: PUSH
65100: LD_VAR 0 2
65104: ARRAY
65105: IN
65106: NOT
65107: IFFALSE 65153
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
65109: LD_ADDR_EXP 64
65113: PUSH
65114: LD_EXP 64
65118: PPUSH
65119: LD_VAR 0 2
65123: PUSH
65124: LD_EXP 64
65128: PUSH
65129: LD_VAR 0 2
65133: ARRAY
65134: PUSH
65135: LD_INT 1
65137: PLUS
65138: PUSH
65139: EMPTY
65140: LIST
65141: LIST
65142: PPUSH
65143: LD_VAR 0 3
65147: PPUSH
65148: CALL 19801 0 3
65152: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
65153: LD_VAR 0 3
65157: PPUSH
65158: CALL_OW 110
65162: PUSH
65163: LD_INT 102
65165: NONEQUAL
65166: IFFALSE 65180
// SetTag ( j , 102 ) ;
65168: LD_VAR 0 3
65172: PPUSH
65173: LD_INT 102
65175: PPUSH
65176: CALL_OW 109
// Wait ( 3 ) ;
65180: LD_INT 3
65182: PPUSH
65183: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
65187: LD_EXP 63
65191: PUSH
65192: LD_VAR 0 2
65196: ARRAY
65197: PUSH
65198: LD_INT 1
65200: ARRAY
65201: IFFALSE 65233
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
65203: LD_VAR 0 3
65207: PPUSH
65208: LD_EXP 63
65212: PUSH
65213: LD_VAR 0 2
65217: ARRAY
65218: PUSH
65219: LD_INT 1
65221: ARRAY
65222: PUSH
65223: LD_INT 1
65225: ARRAY
65226: PPUSH
65227: CALL_OW 128
65231: GO 65289
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
65233: LD_VAR 0 3
65237: PPUSH
65238: CALL_OW 314
65242: NOT
65243: PUSH
65244: LD_EXP 63
65248: PUSH
65249: LD_VAR 0 2
65253: ARRAY
65254: PUSH
65255: LD_INT 2
65257: ARRAY
65258: AND
65259: IFFALSE 65289
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
65261: LD_VAR 0 3
65265: PPUSH
65266: LD_EXP 63
65270: PUSH
65271: LD_VAR 0 2
65275: ARRAY
65276: PUSH
65277: LD_INT 2
65279: ARRAY
65280: PUSH
65281: LD_INT 1
65283: ARRAY
65284: PPUSH
65285: CALL_OW 128
// end ;
65289: GO 65067
65291: POP
65292: POP
// end ;
65293: GO 64910
65295: POP
65296: POP
// end ;
65297: LD_VAR 0 1
65301: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
65302: LD_INT 0
65304: PPUSH
65305: PPUSH
65306: PPUSH
65307: PPUSH
65308: PPUSH
// if not mc_bases then
65309: LD_EXP 60
65313: NOT
65314: IFFALSE 65318
// exit ;
65316: GO 66489
// for i = 1 to mc_bases do
65318: LD_ADDR_VAR 0 2
65322: PUSH
65323: DOUBLE
65324: LD_INT 1
65326: DEC
65327: ST_TO_ADDR
65328: LD_EXP 60
65332: PUSH
65333: FOR_TO
65334: IFFALSE 66487
// begin if mc_scan [ i ] then
65336: LD_EXP 83
65340: PUSH
65341: LD_VAR 0 2
65345: ARRAY
65346: IFFALSE 65350
// continue ;
65348: GO 65333
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
65350: LD_EXP 65
65354: PUSH
65355: LD_VAR 0 2
65359: ARRAY
65360: NOT
65361: PUSH
65362: LD_EXP 67
65366: PUSH
65367: LD_VAR 0 2
65371: ARRAY
65372: NOT
65373: AND
65374: PUSH
65375: LD_EXP 66
65379: PUSH
65380: LD_VAR 0 2
65384: ARRAY
65385: AND
65386: IFFALSE 65424
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
65388: LD_ADDR_EXP 66
65392: PUSH
65393: LD_EXP 66
65397: PPUSH
65398: LD_VAR 0 2
65402: PPUSH
65403: EMPTY
65404: PPUSH
65405: CALL_OW 1
65409: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65410: LD_VAR 0 2
65414: PPUSH
65415: LD_INT 103
65417: PPUSH
65418: CALL 59060 0 2
// continue ;
65422: GO 65333
// end ; if mc_construct_list [ i ] then
65424: LD_EXP 67
65428: PUSH
65429: LD_VAR 0 2
65433: ARRAY
65434: IFFALSE 65654
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
65436: LD_ADDR_VAR 0 4
65440: PUSH
65441: LD_EXP 60
65445: PUSH
65446: LD_VAR 0 2
65450: ARRAY
65451: PPUSH
65452: LD_INT 25
65454: PUSH
65455: LD_INT 2
65457: PUSH
65458: EMPTY
65459: LIST
65460: LIST
65461: PPUSH
65462: CALL_OW 72
65466: PUSH
65467: LD_EXP 62
65471: PUSH
65472: LD_VAR 0 2
65476: ARRAY
65477: DIFF
65478: ST_TO_ADDR
// if not tmp then
65479: LD_VAR 0 4
65483: NOT
65484: IFFALSE 65488
// continue ;
65486: GO 65333
// for j in tmp do
65488: LD_ADDR_VAR 0 3
65492: PUSH
65493: LD_VAR 0 4
65497: PUSH
65498: FOR_IN
65499: IFFALSE 65650
// begin if not mc_builders [ i ] then
65501: LD_EXP 66
65505: PUSH
65506: LD_VAR 0 2
65510: ARRAY
65511: NOT
65512: IFFALSE 65570
// begin SetTag ( j , 103 ) ;
65514: LD_VAR 0 3
65518: PPUSH
65519: LD_INT 103
65521: PPUSH
65522: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
65526: LD_ADDR_EXP 66
65530: PUSH
65531: LD_EXP 66
65535: PPUSH
65536: LD_VAR 0 2
65540: PUSH
65541: LD_EXP 66
65545: PUSH
65546: LD_VAR 0 2
65550: ARRAY
65551: PUSH
65552: LD_INT 1
65554: PLUS
65555: PUSH
65556: EMPTY
65557: LIST
65558: LIST
65559: PPUSH
65560: LD_VAR 0 3
65564: PPUSH
65565: CALL 19801 0 3
65569: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
65570: LD_VAR 0 3
65574: PPUSH
65575: CALL_OW 310
65579: IFFALSE 65590
// ComExitBuilding ( j ) ;
65581: LD_VAR 0 3
65585: PPUSH
65586: CALL_OW 122
// wait ( 3 ) ;
65590: LD_INT 3
65592: PPUSH
65593: CALL_OW 67
// if not mc_construct_list [ i ] then
65597: LD_EXP 67
65601: PUSH
65602: LD_VAR 0 2
65606: ARRAY
65607: NOT
65608: IFFALSE 65612
// break ;
65610: GO 65650
// if not HasTask ( j ) then
65612: LD_VAR 0 3
65616: PPUSH
65617: CALL_OW 314
65621: NOT
65622: IFFALSE 65648
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
65624: LD_VAR 0 3
65628: PPUSH
65629: LD_EXP 67
65633: PUSH
65634: LD_VAR 0 2
65638: ARRAY
65639: PUSH
65640: LD_INT 1
65642: ARRAY
65643: PPUSH
65644: CALL 22664 0 2
// end ;
65648: GO 65498
65650: POP
65651: POP
// end else
65652: GO 66485
// if mc_build_list [ i ] then
65654: LD_EXP 65
65658: PUSH
65659: LD_VAR 0 2
65663: ARRAY
65664: IFFALSE 66485
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65666: LD_ADDR_VAR 0 5
65670: PUSH
65671: LD_EXP 60
65675: PUSH
65676: LD_VAR 0 2
65680: ARRAY
65681: PPUSH
65682: LD_INT 2
65684: PUSH
65685: LD_INT 30
65687: PUSH
65688: LD_INT 0
65690: PUSH
65691: EMPTY
65692: LIST
65693: LIST
65694: PUSH
65695: LD_INT 30
65697: PUSH
65698: LD_INT 1
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: LIST
65709: PPUSH
65710: CALL_OW 72
65714: ST_TO_ADDR
// if depot then
65715: LD_VAR 0 5
65719: IFFALSE 65737
// depot := depot [ 1 ] else
65721: LD_ADDR_VAR 0 5
65725: PUSH
65726: LD_VAR 0 5
65730: PUSH
65731: LD_INT 1
65733: ARRAY
65734: ST_TO_ADDR
65735: GO 65745
// depot := 0 ;
65737: LD_ADDR_VAR 0 5
65741: PUSH
65742: LD_INT 0
65744: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
65745: LD_EXP 65
65749: PUSH
65750: LD_VAR 0 2
65754: ARRAY
65755: PUSH
65756: LD_INT 1
65758: ARRAY
65759: PUSH
65760: LD_INT 1
65762: ARRAY
65763: PPUSH
65764: CALL 22488 0 1
65768: PUSH
65769: LD_EXP 60
65773: PUSH
65774: LD_VAR 0 2
65778: ARRAY
65779: PPUSH
65780: LD_INT 2
65782: PUSH
65783: LD_INT 30
65785: PUSH
65786: LD_INT 2
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 30
65795: PUSH
65796: LD_INT 3
65798: PUSH
65799: EMPTY
65800: LIST
65801: LIST
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: LIST
65807: PPUSH
65808: CALL_OW 72
65812: NOT
65813: AND
65814: IFFALSE 65919
// begin for j = 1 to mc_build_list [ i ] do
65816: LD_ADDR_VAR 0 3
65820: PUSH
65821: DOUBLE
65822: LD_INT 1
65824: DEC
65825: ST_TO_ADDR
65826: LD_EXP 65
65830: PUSH
65831: LD_VAR 0 2
65835: ARRAY
65836: PUSH
65837: FOR_TO
65838: IFFALSE 65917
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
65840: LD_EXP 65
65844: PUSH
65845: LD_VAR 0 2
65849: ARRAY
65850: PUSH
65851: LD_VAR 0 3
65855: ARRAY
65856: PUSH
65857: LD_INT 1
65859: ARRAY
65860: PUSH
65861: LD_INT 2
65863: EQUAL
65864: IFFALSE 65915
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
65866: LD_ADDR_EXP 65
65870: PUSH
65871: LD_EXP 65
65875: PPUSH
65876: LD_VAR 0 2
65880: PPUSH
65881: LD_EXP 65
65885: PUSH
65886: LD_VAR 0 2
65890: ARRAY
65891: PPUSH
65892: LD_VAR 0 3
65896: PPUSH
65897: LD_INT 1
65899: PPUSH
65900: LD_INT 0
65902: PPUSH
65903: CALL 19219 0 4
65907: PPUSH
65908: CALL_OW 1
65912: ST_TO_ADDR
// break ;
65913: GO 65917
// end ;
65915: GO 65837
65917: POP
65918: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
65919: LD_EXP 65
65923: PUSH
65924: LD_VAR 0 2
65928: ARRAY
65929: PUSH
65930: LD_INT 1
65932: ARRAY
65933: PUSH
65934: LD_INT 1
65936: ARRAY
65937: PUSH
65938: LD_INT 0
65940: EQUAL
65941: PUSH
65942: LD_VAR 0 5
65946: PUSH
65947: LD_VAR 0 5
65951: PPUSH
65952: LD_EXP 65
65956: PUSH
65957: LD_VAR 0 2
65961: ARRAY
65962: PUSH
65963: LD_INT 1
65965: ARRAY
65966: PUSH
65967: LD_INT 1
65969: ARRAY
65970: PPUSH
65971: LD_EXP 65
65975: PUSH
65976: LD_VAR 0 2
65980: ARRAY
65981: PUSH
65982: LD_INT 1
65984: ARRAY
65985: PUSH
65986: LD_INT 2
65988: ARRAY
65989: PPUSH
65990: LD_EXP 65
65994: PUSH
65995: LD_VAR 0 2
65999: ARRAY
66000: PUSH
66001: LD_INT 1
66003: ARRAY
66004: PUSH
66005: LD_INT 3
66007: ARRAY
66008: PPUSH
66009: LD_EXP 65
66013: PUSH
66014: LD_VAR 0 2
66018: ARRAY
66019: PUSH
66020: LD_INT 1
66022: ARRAY
66023: PUSH
66024: LD_INT 4
66026: ARRAY
66027: PPUSH
66028: CALL 27904 0 5
66032: AND
66033: OR
66034: IFFALSE 66315
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66036: LD_ADDR_VAR 0 4
66040: PUSH
66041: LD_EXP 60
66045: PUSH
66046: LD_VAR 0 2
66050: ARRAY
66051: PPUSH
66052: LD_INT 25
66054: PUSH
66055: LD_INT 2
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: PPUSH
66062: CALL_OW 72
66066: PUSH
66067: LD_EXP 62
66071: PUSH
66072: LD_VAR 0 2
66076: ARRAY
66077: DIFF
66078: ST_TO_ADDR
// if not tmp then
66079: LD_VAR 0 4
66083: NOT
66084: IFFALSE 66088
// continue ;
66086: GO 65333
// for j in tmp do
66088: LD_ADDR_VAR 0 3
66092: PUSH
66093: LD_VAR 0 4
66097: PUSH
66098: FOR_IN
66099: IFFALSE 66311
// begin if not mc_builders [ i ] then
66101: LD_EXP 66
66105: PUSH
66106: LD_VAR 0 2
66110: ARRAY
66111: NOT
66112: IFFALSE 66170
// begin SetTag ( j , 103 ) ;
66114: LD_VAR 0 3
66118: PPUSH
66119: LD_INT 103
66121: PPUSH
66122: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66126: LD_ADDR_EXP 66
66130: PUSH
66131: LD_EXP 66
66135: PPUSH
66136: LD_VAR 0 2
66140: PUSH
66141: LD_EXP 66
66145: PUSH
66146: LD_VAR 0 2
66150: ARRAY
66151: PUSH
66152: LD_INT 1
66154: PLUS
66155: PUSH
66156: EMPTY
66157: LIST
66158: LIST
66159: PPUSH
66160: LD_VAR 0 3
66164: PPUSH
66165: CALL 19801 0 3
66169: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66170: LD_VAR 0 3
66174: PPUSH
66175: CALL_OW 310
66179: IFFALSE 66190
// ComExitBuilding ( j ) ;
66181: LD_VAR 0 3
66185: PPUSH
66186: CALL_OW 122
// wait ( 3 ) ;
66190: LD_INT 3
66192: PPUSH
66193: CALL_OW 67
// if not mc_build_list [ i ] then
66197: LD_EXP 65
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: NOT
66208: IFFALSE 66212
// break ;
66210: GO 66311
// if not HasTask ( j ) then
66212: LD_VAR 0 3
66216: PPUSH
66217: CALL_OW 314
66221: NOT
66222: IFFALSE 66309
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
66224: LD_VAR 0 3
66228: PPUSH
66229: LD_EXP 65
66233: PUSH
66234: LD_VAR 0 2
66238: ARRAY
66239: PUSH
66240: LD_INT 1
66242: ARRAY
66243: PUSH
66244: LD_INT 1
66246: ARRAY
66247: PPUSH
66248: LD_EXP 65
66252: PUSH
66253: LD_VAR 0 2
66257: ARRAY
66258: PUSH
66259: LD_INT 1
66261: ARRAY
66262: PUSH
66263: LD_INT 2
66265: ARRAY
66266: PPUSH
66267: LD_EXP 65
66271: PUSH
66272: LD_VAR 0 2
66276: ARRAY
66277: PUSH
66278: LD_INT 1
66280: ARRAY
66281: PUSH
66282: LD_INT 3
66284: ARRAY
66285: PPUSH
66286: LD_EXP 65
66290: PUSH
66291: LD_VAR 0 2
66295: ARRAY
66296: PUSH
66297: LD_INT 1
66299: ARRAY
66300: PUSH
66301: LD_INT 4
66303: ARRAY
66304: PPUSH
66305: CALL_OW 145
// end ;
66309: GO 66098
66311: POP
66312: POP
// end else
66313: GO 66485
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
66315: LD_EXP 60
66319: PUSH
66320: LD_VAR 0 2
66324: ARRAY
66325: PPUSH
66326: LD_EXP 65
66330: PUSH
66331: LD_VAR 0 2
66335: ARRAY
66336: PUSH
66337: LD_INT 1
66339: ARRAY
66340: PUSH
66341: LD_INT 1
66343: ARRAY
66344: PPUSH
66345: LD_EXP 65
66349: PUSH
66350: LD_VAR 0 2
66354: ARRAY
66355: PUSH
66356: LD_INT 1
66358: ARRAY
66359: PUSH
66360: LD_INT 2
66362: ARRAY
66363: PPUSH
66364: LD_EXP 65
66368: PUSH
66369: LD_VAR 0 2
66373: ARRAY
66374: PUSH
66375: LD_INT 1
66377: ARRAY
66378: PUSH
66379: LD_INT 3
66381: ARRAY
66382: PPUSH
66383: LD_EXP 65
66387: PUSH
66388: LD_VAR 0 2
66392: ARRAY
66393: PUSH
66394: LD_INT 1
66396: ARRAY
66397: PUSH
66398: LD_INT 4
66400: ARRAY
66401: PPUSH
66402: LD_EXP 60
66406: PUSH
66407: LD_VAR 0 2
66411: ARRAY
66412: PPUSH
66413: LD_INT 21
66415: PUSH
66416: LD_INT 3
66418: PUSH
66419: EMPTY
66420: LIST
66421: LIST
66422: PPUSH
66423: CALL_OW 72
66427: PPUSH
66428: EMPTY
66429: PPUSH
66430: CALL 26654 0 7
66434: NOT
66435: IFFALSE 66485
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
66437: LD_ADDR_EXP 65
66441: PUSH
66442: LD_EXP 65
66446: PPUSH
66447: LD_VAR 0 2
66451: PPUSH
66452: LD_EXP 65
66456: PUSH
66457: LD_VAR 0 2
66461: ARRAY
66462: PPUSH
66463: LD_INT 1
66465: PPUSH
66466: LD_INT 1
66468: NEG
66469: PPUSH
66470: LD_INT 0
66472: PPUSH
66473: CALL 19219 0 4
66477: PPUSH
66478: CALL_OW 1
66482: ST_TO_ADDR
// continue ;
66483: GO 65333
// end ; end ; end ;
66485: GO 65333
66487: POP
66488: POP
// end ;
66489: LD_VAR 0 1
66493: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
66494: LD_INT 0
66496: PPUSH
66497: PPUSH
66498: PPUSH
66499: PPUSH
66500: PPUSH
66501: PPUSH
// if not mc_bases then
66502: LD_EXP 60
66506: NOT
66507: IFFALSE 66511
// exit ;
66509: GO 66938
// for i = 1 to mc_bases do
66511: LD_ADDR_VAR 0 2
66515: PUSH
66516: DOUBLE
66517: LD_INT 1
66519: DEC
66520: ST_TO_ADDR
66521: LD_EXP 60
66525: PUSH
66526: FOR_TO
66527: IFFALSE 66936
// begin tmp := mc_build_upgrade [ i ] ;
66529: LD_ADDR_VAR 0 4
66533: PUSH
66534: LD_EXP 92
66538: PUSH
66539: LD_VAR 0 2
66543: ARRAY
66544: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
66545: LD_ADDR_VAR 0 6
66549: PUSH
66550: LD_EXP 93
66554: PUSH
66555: LD_VAR 0 2
66559: ARRAY
66560: PPUSH
66561: LD_INT 2
66563: PUSH
66564: LD_INT 30
66566: PUSH
66567: LD_INT 6
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 30
66576: PUSH
66577: LD_INT 7
66579: PUSH
66580: EMPTY
66581: LIST
66582: LIST
66583: PUSH
66584: EMPTY
66585: LIST
66586: LIST
66587: LIST
66588: PPUSH
66589: CALL_OW 72
66593: ST_TO_ADDR
// if not tmp and not lab then
66594: LD_VAR 0 4
66598: NOT
66599: PUSH
66600: LD_VAR 0 6
66604: NOT
66605: AND
66606: IFFALSE 66610
// continue ;
66608: GO 66526
// if tmp then
66610: LD_VAR 0 4
66614: IFFALSE 66734
// for j in tmp do
66616: LD_ADDR_VAR 0 3
66620: PUSH
66621: LD_VAR 0 4
66625: PUSH
66626: FOR_IN
66627: IFFALSE 66732
// begin if UpgradeCost ( j ) then
66629: LD_VAR 0 3
66633: PPUSH
66634: CALL 26314 0 1
66638: IFFALSE 66730
// begin ComUpgrade ( j ) ;
66640: LD_VAR 0 3
66644: PPUSH
66645: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
66649: LD_ADDR_EXP 92
66653: PUSH
66654: LD_EXP 92
66658: PPUSH
66659: LD_VAR 0 2
66663: PPUSH
66664: LD_EXP 92
66668: PUSH
66669: LD_VAR 0 2
66673: ARRAY
66674: PUSH
66675: LD_VAR 0 3
66679: DIFF
66680: PPUSH
66681: CALL_OW 1
66685: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66686: LD_ADDR_EXP 67
66690: PUSH
66691: LD_EXP 67
66695: PPUSH
66696: LD_VAR 0 2
66700: PUSH
66701: LD_EXP 67
66705: PUSH
66706: LD_VAR 0 2
66710: ARRAY
66711: PUSH
66712: LD_INT 1
66714: PLUS
66715: PUSH
66716: EMPTY
66717: LIST
66718: LIST
66719: PPUSH
66720: LD_VAR 0 3
66724: PPUSH
66725: CALL 19801 0 3
66729: ST_TO_ADDR
// end ; end ;
66730: GO 66626
66732: POP
66733: POP
// if not lab or not mc_lab_upgrade [ i ] then
66734: LD_VAR 0 6
66738: NOT
66739: PUSH
66740: LD_EXP 94
66744: PUSH
66745: LD_VAR 0 2
66749: ARRAY
66750: NOT
66751: OR
66752: IFFALSE 66756
// continue ;
66754: GO 66526
// for j in lab do
66756: LD_ADDR_VAR 0 3
66760: PUSH
66761: LD_VAR 0 6
66765: PUSH
66766: FOR_IN
66767: IFFALSE 66932
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
66769: LD_VAR 0 3
66773: PPUSH
66774: CALL_OW 266
66778: PUSH
66779: LD_INT 6
66781: PUSH
66782: LD_INT 7
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: IN
66789: PUSH
66790: LD_VAR 0 3
66794: PPUSH
66795: CALL_OW 461
66799: PUSH
66800: LD_INT 1
66802: NONEQUAL
66803: AND
66804: IFFALSE 66930
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
66806: LD_VAR 0 3
66810: PPUSH
66811: LD_EXP 94
66815: PUSH
66816: LD_VAR 0 2
66820: ARRAY
66821: PUSH
66822: LD_INT 1
66824: ARRAY
66825: PPUSH
66826: CALL 26519 0 2
66830: IFFALSE 66930
// begin ComCancel ( j ) ;
66832: LD_VAR 0 3
66836: PPUSH
66837: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
66841: LD_VAR 0 3
66845: PPUSH
66846: LD_EXP 94
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PUSH
66857: LD_INT 1
66859: ARRAY
66860: PPUSH
66861: CALL_OW 207
// if not j in mc_construct_list [ i ] then
66865: LD_VAR 0 3
66869: PUSH
66870: LD_EXP 67
66874: PUSH
66875: LD_VAR 0 2
66879: ARRAY
66880: IN
66881: NOT
66882: IFFALSE 66928
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
66884: LD_ADDR_EXP 67
66888: PUSH
66889: LD_EXP 67
66893: PPUSH
66894: LD_VAR 0 2
66898: PUSH
66899: LD_EXP 67
66903: PUSH
66904: LD_VAR 0 2
66908: ARRAY
66909: PUSH
66910: LD_INT 1
66912: PLUS
66913: PUSH
66914: EMPTY
66915: LIST
66916: LIST
66917: PPUSH
66918: LD_VAR 0 3
66922: PPUSH
66923: CALL 19801 0 3
66927: ST_TO_ADDR
// break ;
66928: GO 66932
// end ; end ; end ;
66930: GO 66766
66932: POP
66933: POP
// end ;
66934: GO 66526
66936: POP
66937: POP
// end ;
66938: LD_VAR 0 1
66942: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
66943: LD_INT 0
66945: PPUSH
66946: PPUSH
66947: PPUSH
66948: PPUSH
66949: PPUSH
66950: PPUSH
66951: PPUSH
66952: PPUSH
66953: PPUSH
// if not mc_bases then
66954: LD_EXP 60
66958: NOT
66959: IFFALSE 66963
// exit ;
66961: GO 67368
// for i = 1 to mc_bases do
66963: LD_ADDR_VAR 0 2
66967: PUSH
66968: DOUBLE
66969: LD_INT 1
66971: DEC
66972: ST_TO_ADDR
66973: LD_EXP 60
66977: PUSH
66978: FOR_TO
66979: IFFALSE 67366
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
66981: LD_EXP 68
66985: PUSH
66986: LD_VAR 0 2
66990: ARRAY
66991: NOT
66992: PUSH
66993: LD_EXP 60
66997: PUSH
66998: LD_VAR 0 2
67002: ARRAY
67003: PPUSH
67004: LD_INT 30
67006: PUSH
67007: LD_INT 3
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PPUSH
67014: CALL_OW 72
67018: NOT
67019: OR
67020: IFFALSE 67024
// continue ;
67022: GO 66978
// busy := false ;
67024: LD_ADDR_VAR 0 8
67028: PUSH
67029: LD_INT 0
67031: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67032: LD_ADDR_VAR 0 4
67036: PUSH
67037: LD_EXP 60
67041: PUSH
67042: LD_VAR 0 2
67046: ARRAY
67047: PPUSH
67048: LD_INT 30
67050: PUSH
67051: LD_INT 3
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PPUSH
67058: CALL_OW 72
67062: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
67063: LD_ADDR_VAR 0 6
67067: PUSH
67068: LD_EXP 68
67072: PUSH
67073: LD_VAR 0 2
67077: ARRAY
67078: PPUSH
67079: LD_INT 2
67081: PUSH
67082: LD_INT 30
67084: PUSH
67085: LD_INT 32
67087: PUSH
67088: EMPTY
67089: LIST
67090: LIST
67091: PUSH
67092: LD_INT 30
67094: PUSH
67095: LD_INT 33
67097: PUSH
67098: EMPTY
67099: LIST
67100: LIST
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: LIST
67106: PPUSH
67107: CALL_OW 72
67111: ST_TO_ADDR
// if not t then
67112: LD_VAR 0 6
67116: NOT
67117: IFFALSE 67121
// continue ;
67119: GO 66978
// for j in tmp do
67121: LD_ADDR_VAR 0 3
67125: PUSH
67126: LD_VAR 0 4
67130: PUSH
67131: FOR_IN
67132: IFFALSE 67162
// if not BuildingStatus ( j ) = bs_idle then
67134: LD_VAR 0 3
67138: PPUSH
67139: CALL_OW 461
67143: PUSH
67144: LD_INT 2
67146: EQUAL
67147: NOT
67148: IFFALSE 67160
// begin busy := true ;
67150: LD_ADDR_VAR 0 8
67154: PUSH
67155: LD_INT 1
67157: ST_TO_ADDR
// break ;
67158: GO 67162
// end ;
67160: GO 67131
67162: POP
67163: POP
// if busy then
67164: LD_VAR 0 8
67168: IFFALSE 67172
// continue ;
67170: GO 66978
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
67172: LD_ADDR_VAR 0 7
67176: PUSH
67177: LD_VAR 0 6
67181: PPUSH
67182: LD_INT 35
67184: PUSH
67185: LD_INT 0
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PPUSH
67192: CALL_OW 72
67196: ST_TO_ADDR
// if tw then
67197: LD_VAR 0 7
67201: IFFALSE 67278
// begin tw := tw [ 1 ] ;
67203: LD_ADDR_VAR 0 7
67207: PUSH
67208: LD_VAR 0 7
67212: PUSH
67213: LD_INT 1
67215: ARRAY
67216: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
67217: LD_ADDR_VAR 0 9
67221: PUSH
67222: LD_VAR 0 7
67226: PPUSH
67227: LD_EXP 85
67231: PUSH
67232: LD_VAR 0 2
67236: ARRAY
67237: PPUSH
67238: CALL 24811 0 2
67242: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
67243: LD_EXP 99
67247: PUSH
67248: LD_VAR 0 2
67252: ARRAY
67253: IFFALSE 67276
// if not weapon in mc_allowed_tower_weapons [ i ] then
67255: LD_VAR 0 9
67259: PUSH
67260: LD_EXP 99
67264: PUSH
67265: LD_VAR 0 2
67269: ARRAY
67270: IN
67271: NOT
67272: IFFALSE 67276
// continue ;
67274: GO 66978
// end else
67276: GO 67341
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
67278: LD_ADDR_VAR 0 5
67282: PUSH
67283: LD_EXP 68
67287: PUSH
67288: LD_VAR 0 2
67292: ARRAY
67293: PPUSH
67294: LD_VAR 0 4
67298: PPUSH
67299: CALL 51100 0 2
67303: ST_TO_ADDR
// if not tmp2 then
67304: LD_VAR 0 5
67308: NOT
67309: IFFALSE 67313
// continue ;
67311: GO 66978
// tw := tmp2 [ 1 ] ;
67313: LD_ADDR_VAR 0 7
67317: PUSH
67318: LD_VAR 0 5
67322: PUSH
67323: LD_INT 1
67325: ARRAY
67326: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
67327: LD_ADDR_VAR 0 9
67331: PUSH
67332: LD_VAR 0 5
67336: PUSH
67337: LD_INT 2
67339: ARRAY
67340: ST_TO_ADDR
// end ; if not weapon then
67341: LD_VAR 0 9
67345: NOT
67346: IFFALSE 67350
// continue ;
67348: GO 66978
// ComPlaceWeapon ( tw , weapon ) ;
67350: LD_VAR 0 7
67354: PPUSH
67355: LD_VAR 0 9
67359: PPUSH
67360: CALL_OW 148
// end ;
67364: GO 66978
67366: POP
67367: POP
// end ;
67368: LD_VAR 0 1
67372: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
67373: LD_INT 0
67375: PPUSH
67376: PPUSH
67377: PPUSH
67378: PPUSH
67379: PPUSH
67380: PPUSH
67381: PPUSH
// if not mc_bases then
67382: LD_EXP 60
67386: NOT
67387: IFFALSE 67391
// exit ;
67389: GO 68159
// for i = 1 to mc_bases do
67391: LD_ADDR_VAR 0 2
67395: PUSH
67396: DOUBLE
67397: LD_INT 1
67399: DEC
67400: ST_TO_ADDR
67401: LD_EXP 60
67405: PUSH
67406: FOR_TO
67407: IFFALSE 68157
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
67409: LD_EXP 73
67413: PUSH
67414: LD_VAR 0 2
67418: ARRAY
67419: NOT
67420: PUSH
67421: LD_EXP 73
67425: PUSH
67426: LD_VAR 0 2
67430: ARRAY
67431: PUSH
67432: LD_EXP 74
67436: PUSH
67437: LD_VAR 0 2
67441: ARRAY
67442: EQUAL
67443: OR
67444: PUSH
67445: LD_EXP 83
67449: PUSH
67450: LD_VAR 0 2
67454: ARRAY
67455: OR
67456: IFFALSE 67460
// continue ;
67458: GO 67406
// if mc_miners [ i ] then
67460: LD_EXP 74
67464: PUSH
67465: LD_VAR 0 2
67469: ARRAY
67470: IFFALSE 67844
// begin for j = mc_miners [ i ] downto 1 do
67472: LD_ADDR_VAR 0 3
67476: PUSH
67477: DOUBLE
67478: LD_EXP 74
67482: PUSH
67483: LD_VAR 0 2
67487: ARRAY
67488: INC
67489: ST_TO_ADDR
67490: LD_INT 1
67492: PUSH
67493: FOR_DOWNTO
67494: IFFALSE 67842
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
67496: LD_EXP 74
67500: PUSH
67501: LD_VAR 0 2
67505: ARRAY
67506: PUSH
67507: LD_VAR 0 3
67511: ARRAY
67512: PPUSH
67513: CALL_OW 301
67517: PUSH
67518: LD_EXP 74
67522: PUSH
67523: LD_VAR 0 2
67527: ARRAY
67528: PUSH
67529: LD_VAR 0 3
67533: ARRAY
67534: PPUSH
67535: CALL_OW 257
67539: PUSH
67540: LD_INT 1
67542: NONEQUAL
67543: OR
67544: IFFALSE 67607
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
67546: LD_ADDR_VAR 0 5
67550: PUSH
67551: LD_EXP 74
67555: PUSH
67556: LD_VAR 0 2
67560: ARRAY
67561: PUSH
67562: LD_EXP 74
67566: PUSH
67567: LD_VAR 0 2
67571: ARRAY
67572: PUSH
67573: LD_VAR 0 3
67577: ARRAY
67578: DIFF
67579: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
67580: LD_ADDR_EXP 74
67584: PUSH
67585: LD_EXP 74
67589: PPUSH
67590: LD_VAR 0 2
67594: PPUSH
67595: LD_VAR 0 5
67599: PPUSH
67600: CALL_OW 1
67604: ST_TO_ADDR
// continue ;
67605: GO 67493
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
67607: LD_EXP 74
67611: PUSH
67612: LD_VAR 0 2
67616: ARRAY
67617: PUSH
67618: LD_VAR 0 3
67622: ARRAY
67623: PPUSH
67624: CALL_OW 257
67628: PUSH
67629: LD_INT 1
67631: EQUAL
67632: PUSH
67633: LD_EXP 74
67637: PUSH
67638: LD_VAR 0 2
67642: ARRAY
67643: PUSH
67644: LD_VAR 0 3
67648: ARRAY
67649: PPUSH
67650: CALL_OW 459
67654: NOT
67655: AND
67656: PUSH
67657: LD_EXP 74
67661: PUSH
67662: LD_VAR 0 2
67666: ARRAY
67667: PUSH
67668: LD_VAR 0 3
67672: ARRAY
67673: PPUSH
67674: CALL_OW 314
67678: NOT
67679: AND
67680: IFFALSE 67840
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
67682: LD_EXP 74
67686: PUSH
67687: LD_VAR 0 2
67691: ARRAY
67692: PUSH
67693: LD_VAR 0 3
67697: ARRAY
67698: PPUSH
67699: CALL_OW 310
67703: IFFALSE 67726
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
67705: LD_EXP 74
67709: PUSH
67710: LD_VAR 0 2
67714: ARRAY
67715: PUSH
67716: LD_VAR 0 3
67720: ARRAY
67721: PPUSH
67722: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
67726: LD_EXP 74
67730: PUSH
67731: LD_VAR 0 2
67735: ARRAY
67736: PUSH
67737: LD_VAR 0 3
67741: ARRAY
67742: PPUSH
67743: CALL_OW 314
67747: NOT
67748: IFFALSE 67840
// begin r := rand ( 1 , mc_mines [ i ] ) ;
67750: LD_ADDR_VAR 0 7
67754: PUSH
67755: LD_INT 1
67757: PPUSH
67758: LD_EXP 73
67762: PUSH
67763: LD_VAR 0 2
67767: ARRAY
67768: PPUSH
67769: CALL_OW 12
67773: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
67774: LD_EXP 74
67778: PUSH
67779: LD_VAR 0 2
67783: ARRAY
67784: PUSH
67785: LD_VAR 0 3
67789: ARRAY
67790: PPUSH
67791: LD_EXP 73
67795: PUSH
67796: LD_VAR 0 2
67800: ARRAY
67801: PUSH
67802: LD_VAR 0 7
67806: ARRAY
67807: PUSH
67808: LD_INT 1
67810: ARRAY
67811: PPUSH
67812: LD_EXP 73
67816: PUSH
67817: LD_VAR 0 2
67821: ARRAY
67822: PUSH
67823: LD_VAR 0 7
67827: ARRAY
67828: PUSH
67829: LD_INT 2
67831: ARRAY
67832: PPUSH
67833: LD_INT 0
67835: PPUSH
67836: CALL_OW 193
// end ; end ; end ;
67840: GO 67493
67842: POP
67843: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
67844: LD_ADDR_VAR 0 5
67848: PUSH
67849: LD_EXP 60
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PPUSH
67860: LD_INT 2
67862: PUSH
67863: LD_INT 30
67865: PUSH
67866: LD_INT 4
67868: PUSH
67869: EMPTY
67870: LIST
67871: LIST
67872: PUSH
67873: LD_INT 30
67875: PUSH
67876: LD_INT 5
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 30
67885: PUSH
67886: LD_INT 32
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: LIST
67897: LIST
67898: PPUSH
67899: CALL_OW 72
67903: ST_TO_ADDR
// if not tmp then
67904: LD_VAR 0 5
67908: NOT
67909: IFFALSE 67913
// continue ;
67911: GO 67406
// list := [ ] ;
67913: LD_ADDR_VAR 0 6
67917: PUSH
67918: EMPTY
67919: ST_TO_ADDR
// for j in tmp do
67920: LD_ADDR_VAR 0 3
67924: PUSH
67925: LD_VAR 0 5
67929: PUSH
67930: FOR_IN
67931: IFFALSE 68000
// begin for k in UnitsInside ( j ) do
67933: LD_ADDR_VAR 0 4
67937: PUSH
67938: LD_VAR 0 3
67942: PPUSH
67943: CALL_OW 313
67947: PUSH
67948: FOR_IN
67949: IFFALSE 67996
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
67951: LD_VAR 0 4
67955: PPUSH
67956: CALL_OW 257
67960: PUSH
67961: LD_INT 1
67963: EQUAL
67964: PUSH
67965: LD_VAR 0 4
67969: PPUSH
67970: CALL_OW 459
67974: NOT
67975: AND
67976: IFFALSE 67994
// list := list ^ k ;
67978: LD_ADDR_VAR 0 6
67982: PUSH
67983: LD_VAR 0 6
67987: PUSH
67988: LD_VAR 0 4
67992: ADD
67993: ST_TO_ADDR
67994: GO 67948
67996: POP
67997: POP
// end ;
67998: GO 67930
68000: POP
68001: POP
// list := list diff mc_miners [ i ] ;
68002: LD_ADDR_VAR 0 6
68006: PUSH
68007: LD_VAR 0 6
68011: PUSH
68012: LD_EXP 74
68016: PUSH
68017: LD_VAR 0 2
68021: ARRAY
68022: DIFF
68023: ST_TO_ADDR
// if not list then
68024: LD_VAR 0 6
68028: NOT
68029: IFFALSE 68033
// continue ;
68031: GO 67406
// k := mc_mines [ i ] - mc_miners [ i ] ;
68033: LD_ADDR_VAR 0 4
68037: PUSH
68038: LD_EXP 73
68042: PUSH
68043: LD_VAR 0 2
68047: ARRAY
68048: PUSH
68049: LD_EXP 74
68053: PUSH
68054: LD_VAR 0 2
68058: ARRAY
68059: MINUS
68060: ST_TO_ADDR
// if k > list then
68061: LD_VAR 0 4
68065: PUSH
68066: LD_VAR 0 6
68070: GREATER
68071: IFFALSE 68083
// k := list ;
68073: LD_ADDR_VAR 0 4
68077: PUSH
68078: LD_VAR 0 6
68082: ST_TO_ADDR
// for j = 1 to k do
68083: LD_ADDR_VAR 0 3
68087: PUSH
68088: DOUBLE
68089: LD_INT 1
68091: DEC
68092: ST_TO_ADDR
68093: LD_VAR 0 4
68097: PUSH
68098: FOR_TO
68099: IFFALSE 68153
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
68101: LD_ADDR_EXP 74
68105: PUSH
68106: LD_EXP 74
68110: PPUSH
68111: LD_VAR 0 2
68115: PUSH
68116: LD_EXP 74
68120: PUSH
68121: LD_VAR 0 2
68125: ARRAY
68126: PUSH
68127: LD_INT 1
68129: PLUS
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PPUSH
68135: LD_VAR 0 6
68139: PUSH
68140: LD_VAR 0 3
68144: ARRAY
68145: PPUSH
68146: CALL 19801 0 3
68150: ST_TO_ADDR
68151: GO 68098
68153: POP
68154: POP
// end ;
68155: GO 67406
68157: POP
68158: POP
// end ;
68159: LD_VAR 0 1
68163: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
68164: LD_INT 0
68166: PPUSH
68167: PPUSH
68168: PPUSH
68169: PPUSH
68170: PPUSH
68171: PPUSH
68172: PPUSH
68173: PPUSH
68174: PPUSH
68175: PPUSH
68176: PPUSH
// if not mc_bases then
68177: LD_EXP 60
68181: NOT
68182: IFFALSE 68186
// exit ;
68184: GO 70009
// for i = 1 to mc_bases do
68186: LD_ADDR_VAR 0 2
68190: PUSH
68191: DOUBLE
68192: LD_INT 1
68194: DEC
68195: ST_TO_ADDR
68196: LD_EXP 60
68200: PUSH
68201: FOR_TO
68202: IFFALSE 70007
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
68204: LD_EXP 60
68208: PUSH
68209: LD_VAR 0 2
68213: ARRAY
68214: NOT
68215: PUSH
68216: LD_EXP 67
68220: PUSH
68221: LD_VAR 0 2
68225: ARRAY
68226: OR
68227: IFFALSE 68231
// continue ;
68229: GO 68201
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
68231: LD_EXP 76
68235: PUSH
68236: LD_VAR 0 2
68240: ARRAY
68241: NOT
68242: PUSH
68243: LD_EXP 77
68247: PUSH
68248: LD_VAR 0 2
68252: ARRAY
68253: AND
68254: IFFALSE 68292
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
68256: LD_ADDR_EXP 77
68260: PUSH
68261: LD_EXP 77
68265: PPUSH
68266: LD_VAR 0 2
68270: PPUSH
68271: EMPTY
68272: PPUSH
68273: CALL_OW 1
68277: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
68278: LD_VAR 0 2
68282: PPUSH
68283: LD_INT 107
68285: PPUSH
68286: CALL 59060 0 2
// continue ;
68290: GO 68201
// end ; target := [ ] ;
68292: LD_ADDR_VAR 0 7
68296: PUSH
68297: EMPTY
68298: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68299: LD_ADDR_VAR 0 6
68303: PUSH
68304: LD_EXP 60
68308: PUSH
68309: LD_VAR 0 2
68313: ARRAY
68314: PUSH
68315: LD_INT 1
68317: ARRAY
68318: PPUSH
68319: CALL_OW 255
68323: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68324: LD_ADDR_VAR 0 9
68328: PUSH
68329: LD_EXP 60
68333: PUSH
68334: LD_VAR 0 2
68338: ARRAY
68339: PPUSH
68340: LD_INT 2
68342: PUSH
68343: LD_INT 30
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: LD_INT 30
68355: PUSH
68356: LD_INT 1
68358: PUSH
68359: EMPTY
68360: LIST
68361: LIST
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: LIST
68367: PPUSH
68368: CALL_OW 72
68372: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
68373: LD_ADDR_VAR 0 3
68377: PUSH
68378: DOUBLE
68379: LD_EXP 76
68383: PUSH
68384: LD_VAR 0 2
68388: ARRAY
68389: INC
68390: ST_TO_ADDR
68391: LD_INT 1
68393: PUSH
68394: FOR_DOWNTO
68395: IFFALSE 68640
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
68397: LD_EXP 76
68401: PUSH
68402: LD_VAR 0 2
68406: ARRAY
68407: PUSH
68408: LD_VAR 0 3
68412: ARRAY
68413: PUSH
68414: LD_INT 2
68416: ARRAY
68417: PPUSH
68418: LD_EXP 76
68422: PUSH
68423: LD_VAR 0 2
68427: ARRAY
68428: PUSH
68429: LD_VAR 0 3
68433: ARRAY
68434: PUSH
68435: LD_INT 3
68437: ARRAY
68438: PPUSH
68439: CALL_OW 488
68443: PUSH
68444: LD_EXP 76
68448: PUSH
68449: LD_VAR 0 2
68453: ARRAY
68454: PUSH
68455: LD_VAR 0 3
68459: ARRAY
68460: PUSH
68461: LD_INT 2
68463: ARRAY
68464: PPUSH
68465: LD_EXP 76
68469: PUSH
68470: LD_VAR 0 2
68474: ARRAY
68475: PUSH
68476: LD_VAR 0 3
68480: ARRAY
68481: PUSH
68482: LD_INT 3
68484: ARRAY
68485: PPUSH
68486: CALL_OW 284
68490: PUSH
68491: LD_INT 0
68493: EQUAL
68494: AND
68495: IFFALSE 68550
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
68497: LD_ADDR_VAR 0 5
68501: PUSH
68502: LD_EXP 76
68506: PUSH
68507: LD_VAR 0 2
68511: ARRAY
68512: PPUSH
68513: LD_VAR 0 3
68517: PPUSH
68518: CALL_OW 3
68522: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
68523: LD_ADDR_EXP 76
68527: PUSH
68528: LD_EXP 76
68532: PPUSH
68533: LD_VAR 0 2
68537: PPUSH
68538: LD_VAR 0 5
68542: PPUSH
68543: CALL_OW 1
68547: ST_TO_ADDR
// continue ;
68548: GO 68394
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
68550: LD_VAR 0 6
68554: PPUSH
68555: LD_EXP 76
68559: PUSH
68560: LD_VAR 0 2
68564: ARRAY
68565: PUSH
68566: LD_VAR 0 3
68570: ARRAY
68571: PUSH
68572: LD_INT 2
68574: ARRAY
68575: PPUSH
68576: LD_EXP 76
68580: PUSH
68581: LD_VAR 0 2
68585: ARRAY
68586: PUSH
68587: LD_VAR 0 3
68591: ARRAY
68592: PUSH
68593: LD_INT 3
68595: ARRAY
68596: PPUSH
68597: LD_INT 30
68599: PPUSH
68600: CALL 20697 0 4
68604: PUSH
68605: LD_INT 4
68607: ARRAY
68608: PUSH
68609: LD_INT 0
68611: EQUAL
68612: IFFALSE 68638
// begin target := mc_crates [ i ] [ j ] ;
68614: LD_ADDR_VAR 0 7
68618: PUSH
68619: LD_EXP 76
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: PUSH
68630: LD_VAR 0 3
68634: ARRAY
68635: ST_TO_ADDR
// break ;
68636: GO 68640
// end ; end ;
68638: GO 68394
68640: POP
68641: POP
// if not target then
68642: LD_VAR 0 7
68646: NOT
68647: IFFALSE 68651
// continue ;
68649: GO 68201
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
68651: LD_ADDR_VAR 0 8
68655: PUSH
68656: LD_EXP 79
68660: PUSH
68661: LD_VAR 0 2
68665: ARRAY
68666: PPUSH
68667: LD_INT 2
68669: PUSH
68670: LD_INT 3
68672: PUSH
68673: LD_INT 58
68675: PUSH
68676: EMPTY
68677: LIST
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: PUSH
68683: LD_INT 61
68685: PUSH
68686: EMPTY
68687: LIST
68688: PUSH
68689: LD_INT 33
68691: PUSH
68692: LD_INT 5
68694: PUSH
68695: EMPTY
68696: LIST
68697: LIST
68698: PUSH
68699: LD_INT 33
68701: PUSH
68702: LD_INT 3
68704: PUSH
68705: EMPTY
68706: LIST
68707: LIST
68708: PUSH
68709: EMPTY
68710: LIST
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: PUSH
68716: LD_INT 2
68718: PUSH
68719: LD_INT 34
68721: PUSH
68722: LD_INT 32
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 34
68731: PUSH
68732: LD_INT 51
68734: PUSH
68735: EMPTY
68736: LIST
68737: LIST
68738: PUSH
68739: LD_INT 34
68741: PUSH
68742: LD_INT 12
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: LIST
68753: LIST
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: PPUSH
68759: CALL_OW 72
68763: ST_TO_ADDR
// if not cargo then
68764: LD_VAR 0 8
68768: NOT
68769: IFFALSE 69475
// begin if mc_crates_collector [ i ] < 5 then
68771: LD_EXP 77
68775: PUSH
68776: LD_VAR 0 2
68780: ARRAY
68781: PUSH
68782: LD_INT 5
68784: LESS
68785: IFFALSE 69151
// begin if mc_ape [ i ] then
68787: LD_EXP 89
68791: PUSH
68792: LD_VAR 0 2
68796: ARRAY
68797: IFFALSE 68844
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
68799: LD_ADDR_VAR 0 5
68803: PUSH
68804: LD_EXP 89
68808: PUSH
68809: LD_VAR 0 2
68813: ARRAY
68814: PPUSH
68815: LD_INT 25
68817: PUSH
68818: LD_INT 16
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 24
68827: PUSH
68828: LD_INT 750
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PPUSH
68839: CALL_OW 72
68843: ST_TO_ADDR
// if not tmp then
68844: LD_VAR 0 5
68848: NOT
68849: IFFALSE 68896
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
68851: LD_ADDR_VAR 0 5
68855: PUSH
68856: LD_EXP 60
68860: PUSH
68861: LD_VAR 0 2
68865: ARRAY
68866: PPUSH
68867: LD_INT 25
68869: PUSH
68870: LD_INT 2
68872: PUSH
68873: EMPTY
68874: LIST
68875: LIST
68876: PUSH
68877: LD_INT 24
68879: PUSH
68880: LD_INT 750
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: EMPTY
68888: LIST
68889: LIST
68890: PPUSH
68891: CALL_OW 72
68895: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
68896: LD_EXP 89
68900: PUSH
68901: LD_VAR 0 2
68905: ARRAY
68906: PUSH
68907: LD_EXP 60
68911: PUSH
68912: LD_VAR 0 2
68916: ARRAY
68917: PPUSH
68918: LD_INT 25
68920: PUSH
68921: LD_INT 2
68923: PUSH
68924: EMPTY
68925: LIST
68926: LIST
68927: PUSH
68928: LD_INT 24
68930: PUSH
68931: LD_INT 750
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PPUSH
68942: CALL_OW 72
68946: AND
68947: PUSH
68948: LD_VAR 0 5
68952: PUSH
68953: LD_INT 5
68955: LESS
68956: AND
68957: IFFALSE 69039
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
68959: LD_ADDR_VAR 0 3
68963: PUSH
68964: LD_EXP 60
68968: PUSH
68969: LD_VAR 0 2
68973: ARRAY
68974: PPUSH
68975: LD_INT 25
68977: PUSH
68978: LD_INT 2
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 24
68987: PUSH
68988: LD_INT 750
68990: PUSH
68991: EMPTY
68992: LIST
68993: LIST
68994: PUSH
68995: EMPTY
68996: LIST
68997: LIST
68998: PPUSH
68999: CALL_OW 72
69003: PUSH
69004: FOR_IN
69005: IFFALSE 69037
// begin tmp := tmp union j ;
69007: LD_ADDR_VAR 0 5
69011: PUSH
69012: LD_VAR 0 5
69016: PUSH
69017: LD_VAR 0 3
69021: UNION
69022: ST_TO_ADDR
// if tmp >= 5 then
69023: LD_VAR 0 5
69027: PUSH
69028: LD_INT 5
69030: GREATEREQUAL
69031: IFFALSE 69035
// break ;
69033: GO 69037
// end ;
69035: GO 69004
69037: POP
69038: POP
// end ; if not tmp then
69039: LD_VAR 0 5
69043: NOT
69044: IFFALSE 69048
// continue ;
69046: GO 68201
// for j in tmp do
69048: LD_ADDR_VAR 0 3
69052: PUSH
69053: LD_VAR 0 5
69057: PUSH
69058: FOR_IN
69059: IFFALSE 69149
// if not GetTag ( j ) then
69061: LD_VAR 0 3
69065: PPUSH
69066: CALL_OW 110
69070: NOT
69071: IFFALSE 69147
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
69073: LD_ADDR_EXP 77
69077: PUSH
69078: LD_EXP 77
69082: PPUSH
69083: LD_VAR 0 2
69087: PUSH
69088: LD_EXP 77
69092: PUSH
69093: LD_VAR 0 2
69097: ARRAY
69098: PUSH
69099: LD_INT 1
69101: PLUS
69102: PUSH
69103: EMPTY
69104: LIST
69105: LIST
69106: PPUSH
69107: LD_VAR 0 3
69111: PPUSH
69112: CALL 19801 0 3
69116: ST_TO_ADDR
// SetTag ( j , 107 ) ;
69117: LD_VAR 0 3
69121: PPUSH
69122: LD_INT 107
69124: PPUSH
69125: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
69129: LD_EXP 77
69133: PUSH
69134: LD_VAR 0 2
69138: ARRAY
69139: PUSH
69140: LD_INT 5
69142: GREATEREQUAL
69143: IFFALSE 69147
// break ;
69145: GO 69149
// end ;
69147: GO 69058
69149: POP
69150: POP
// end ; if mc_crates_collector [ i ] and target then
69151: LD_EXP 77
69155: PUSH
69156: LD_VAR 0 2
69160: ARRAY
69161: PUSH
69162: LD_VAR 0 7
69166: AND
69167: IFFALSE 69473
// begin if mc_crates_collector [ i ] < target [ 1 ] then
69169: LD_EXP 77
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: PUSH
69180: LD_VAR 0 7
69184: PUSH
69185: LD_INT 1
69187: ARRAY
69188: LESS
69189: IFFALSE 69209
// tmp := mc_crates_collector [ i ] else
69191: LD_ADDR_VAR 0 5
69195: PUSH
69196: LD_EXP 77
69200: PUSH
69201: LD_VAR 0 2
69205: ARRAY
69206: ST_TO_ADDR
69207: GO 69223
// tmp := target [ 1 ] ;
69209: LD_ADDR_VAR 0 5
69213: PUSH
69214: LD_VAR 0 7
69218: PUSH
69219: LD_INT 1
69221: ARRAY
69222: ST_TO_ADDR
// k := 0 ;
69223: LD_ADDR_VAR 0 4
69227: PUSH
69228: LD_INT 0
69230: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
69231: LD_ADDR_VAR 0 3
69235: PUSH
69236: LD_EXP 77
69240: PUSH
69241: LD_VAR 0 2
69245: ARRAY
69246: PUSH
69247: FOR_IN
69248: IFFALSE 69471
// begin k := k + 1 ;
69250: LD_ADDR_VAR 0 4
69254: PUSH
69255: LD_VAR 0 4
69259: PUSH
69260: LD_INT 1
69262: PLUS
69263: ST_TO_ADDR
// if k > tmp then
69264: LD_VAR 0 4
69268: PUSH
69269: LD_VAR 0 5
69273: GREATER
69274: IFFALSE 69278
// break ;
69276: GO 69471
// if not GetClass ( j ) in [ 2 , 16 ] then
69278: LD_VAR 0 3
69282: PPUSH
69283: CALL_OW 257
69287: PUSH
69288: LD_INT 2
69290: PUSH
69291: LD_INT 16
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: IN
69298: NOT
69299: IFFALSE 69352
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
69301: LD_ADDR_EXP 77
69305: PUSH
69306: LD_EXP 77
69310: PPUSH
69311: LD_VAR 0 2
69315: PPUSH
69316: LD_EXP 77
69320: PUSH
69321: LD_VAR 0 2
69325: ARRAY
69326: PUSH
69327: LD_VAR 0 3
69331: DIFF
69332: PPUSH
69333: CALL_OW 1
69337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69338: LD_VAR 0 3
69342: PPUSH
69343: LD_INT 0
69345: PPUSH
69346: CALL_OW 109
// continue ;
69350: GO 69247
// end ; if IsInUnit ( j ) then
69352: LD_VAR 0 3
69356: PPUSH
69357: CALL_OW 310
69361: IFFALSE 69372
// ComExitBuilding ( j ) ;
69363: LD_VAR 0 3
69367: PPUSH
69368: CALL_OW 122
// wait ( 3 ) ;
69372: LD_INT 3
69374: PPUSH
69375: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
69379: LD_VAR 0 3
69383: PPUSH
69384: CALL_OW 314
69388: PUSH
69389: LD_VAR 0 6
69393: PPUSH
69394: LD_VAR 0 7
69398: PUSH
69399: LD_INT 2
69401: ARRAY
69402: PPUSH
69403: LD_VAR 0 7
69407: PUSH
69408: LD_INT 3
69410: ARRAY
69411: PPUSH
69412: LD_INT 30
69414: PPUSH
69415: CALL 20697 0 4
69419: PUSH
69420: LD_INT 4
69422: ARRAY
69423: AND
69424: IFFALSE 69442
// ComStandNearbyBuilding ( j , depot ) else
69426: LD_VAR 0 3
69430: PPUSH
69431: LD_VAR 0 9
69435: PPUSH
69436: CALL 16379 0 2
69440: GO 69469
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69442: LD_VAR 0 3
69446: PPUSH
69447: LD_VAR 0 7
69451: PUSH
69452: LD_INT 2
69454: ARRAY
69455: PPUSH
69456: LD_VAR 0 7
69460: PUSH
69461: LD_INT 3
69463: ARRAY
69464: PPUSH
69465: CALL_OW 117
// end ;
69469: GO 69247
69471: POP
69472: POP
// end ; end else
69473: GO 70005
// begin for j in cargo do
69475: LD_ADDR_VAR 0 3
69479: PUSH
69480: LD_VAR 0 8
69484: PUSH
69485: FOR_IN
69486: IFFALSE 70003
// begin if GetTag ( j ) <> 0 then
69488: LD_VAR 0 3
69492: PPUSH
69493: CALL_OW 110
69497: PUSH
69498: LD_INT 0
69500: NONEQUAL
69501: IFFALSE 69505
// continue ;
69503: GO 69485
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
69505: LD_VAR 0 3
69509: PPUSH
69510: CALL_OW 256
69514: PUSH
69515: LD_INT 1000
69517: LESS
69518: PUSH
69519: LD_VAR 0 3
69523: PPUSH
69524: LD_EXP 84
69528: PUSH
69529: LD_VAR 0 2
69533: ARRAY
69534: PPUSH
69535: CALL_OW 308
69539: NOT
69540: AND
69541: IFFALSE 69563
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69543: LD_VAR 0 3
69547: PPUSH
69548: LD_EXP 84
69552: PUSH
69553: LD_VAR 0 2
69557: ARRAY
69558: PPUSH
69559: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
69563: LD_VAR 0 3
69567: PPUSH
69568: CALL_OW 256
69572: PUSH
69573: LD_INT 1000
69575: LESS
69576: PUSH
69577: LD_VAR 0 3
69581: PPUSH
69582: LD_EXP 84
69586: PUSH
69587: LD_VAR 0 2
69591: ARRAY
69592: PPUSH
69593: CALL_OW 308
69597: AND
69598: IFFALSE 69602
// continue ;
69600: GO 69485
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
69602: LD_VAR 0 3
69606: PPUSH
69607: CALL_OW 262
69611: PUSH
69612: LD_INT 2
69614: EQUAL
69615: PUSH
69616: LD_VAR 0 3
69620: PPUSH
69621: CALL_OW 261
69625: PUSH
69626: LD_INT 15
69628: LESS
69629: AND
69630: IFFALSE 69634
// continue ;
69632: GO 69485
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
69634: LD_VAR 0 3
69638: PPUSH
69639: CALL_OW 262
69643: PUSH
69644: LD_INT 1
69646: EQUAL
69647: PUSH
69648: LD_VAR 0 3
69652: PPUSH
69653: CALL_OW 261
69657: PUSH
69658: LD_INT 10
69660: LESS
69661: AND
69662: IFFALSE 69942
// begin if not depot then
69664: LD_VAR 0 9
69668: NOT
69669: IFFALSE 69673
// continue ;
69671: GO 69485
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
69673: LD_VAR 0 3
69677: PPUSH
69678: LD_VAR 0 9
69682: PPUSH
69683: LD_VAR 0 3
69687: PPUSH
69688: CALL_OW 74
69692: PPUSH
69693: CALL_OW 296
69697: PUSH
69698: LD_INT 6
69700: LESS
69701: IFFALSE 69717
// SetFuel ( j , 100 ) else
69703: LD_VAR 0 3
69707: PPUSH
69708: LD_INT 100
69710: PPUSH
69711: CALL_OW 240
69715: GO 69942
// if GetFuel ( j ) = 0 then
69717: LD_VAR 0 3
69721: PPUSH
69722: CALL_OW 261
69726: PUSH
69727: LD_INT 0
69729: EQUAL
69730: IFFALSE 69942
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
69732: LD_ADDR_EXP 79
69736: PUSH
69737: LD_EXP 79
69741: PPUSH
69742: LD_VAR 0 2
69746: PPUSH
69747: LD_EXP 79
69751: PUSH
69752: LD_VAR 0 2
69756: ARRAY
69757: PUSH
69758: LD_VAR 0 3
69762: DIFF
69763: PPUSH
69764: CALL_OW 1
69768: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
69769: LD_VAR 0 3
69773: PPUSH
69774: CALL_OW 263
69778: PUSH
69779: LD_INT 1
69781: EQUAL
69782: IFFALSE 69798
// ComExitVehicle ( IsInUnit ( j ) ) ;
69784: LD_VAR 0 3
69788: PPUSH
69789: CALL_OW 310
69793: PPUSH
69794: CALL_OW 121
// if GetControl ( j ) = control_remote then
69798: LD_VAR 0 3
69802: PPUSH
69803: CALL_OW 263
69807: PUSH
69808: LD_INT 2
69810: EQUAL
69811: IFFALSE 69822
// ComUnlink ( j ) ;
69813: LD_VAR 0 3
69817: PPUSH
69818: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
69822: LD_ADDR_VAR 0 10
69826: PUSH
69827: LD_VAR 0 2
69831: PPUSH
69832: LD_INT 3
69834: PPUSH
69835: CALL 79581 0 2
69839: ST_TO_ADDR
// if fac then
69840: LD_VAR 0 10
69844: IFFALSE 69940
// begin for k in fac do
69846: LD_ADDR_VAR 0 4
69850: PUSH
69851: LD_VAR 0 10
69855: PUSH
69856: FOR_IN
69857: IFFALSE 69938
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
69859: LD_ADDR_VAR 0 11
69863: PUSH
69864: LD_VAR 0 10
69868: PPUSH
69869: LD_VAR 0 3
69873: PPUSH
69874: CALL_OW 265
69878: PPUSH
69879: LD_VAR 0 3
69883: PPUSH
69884: CALL_OW 262
69888: PPUSH
69889: LD_VAR 0 3
69893: PPUSH
69894: CALL_OW 263
69898: PPUSH
69899: LD_VAR 0 3
69903: PPUSH
69904: CALL_OW 264
69908: PPUSH
69909: CALL 17297 0 5
69913: ST_TO_ADDR
// if components then
69914: LD_VAR 0 11
69918: IFFALSE 69936
// begin MC_InsertProduceList ( i , components ) ;
69920: LD_VAR 0 2
69924: PPUSH
69925: LD_VAR 0 11
69929: PPUSH
69930: CALL 79126 0 2
// break ;
69934: GO 69938
// end ; end ;
69936: GO 69856
69938: POP
69939: POP
// end ; continue ;
69940: GO 69485
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
69942: LD_VAR 0 3
69946: PPUSH
69947: LD_INT 1
69949: PPUSH
69950: CALL_OW 289
69954: PUSH
69955: LD_INT 100
69957: LESS
69958: PUSH
69959: LD_VAR 0 3
69963: PPUSH
69964: CALL_OW 314
69968: NOT
69969: AND
69970: IFFALSE 69999
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
69972: LD_VAR 0 3
69976: PPUSH
69977: LD_VAR 0 7
69981: PUSH
69982: LD_INT 2
69984: ARRAY
69985: PPUSH
69986: LD_VAR 0 7
69990: PUSH
69991: LD_INT 3
69993: ARRAY
69994: PPUSH
69995: CALL_OW 117
// break ;
69999: GO 70003
// end ;
70001: GO 69485
70003: POP
70004: POP
// end ; end ;
70005: GO 68201
70007: POP
70008: POP
// end ;
70009: LD_VAR 0 1
70013: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
70014: LD_INT 0
70016: PPUSH
70017: PPUSH
70018: PPUSH
70019: PPUSH
// if not mc_bases then
70020: LD_EXP 60
70024: NOT
70025: IFFALSE 70029
// exit ;
70027: GO 70190
// for i = 1 to mc_bases do
70029: LD_ADDR_VAR 0 2
70033: PUSH
70034: DOUBLE
70035: LD_INT 1
70037: DEC
70038: ST_TO_ADDR
70039: LD_EXP 60
70043: PUSH
70044: FOR_TO
70045: IFFALSE 70188
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
70047: LD_ADDR_VAR 0 4
70051: PUSH
70052: LD_EXP 79
70056: PUSH
70057: LD_VAR 0 2
70061: ARRAY
70062: PUSH
70063: LD_EXP 82
70067: PUSH
70068: LD_VAR 0 2
70072: ARRAY
70073: UNION
70074: PPUSH
70075: LD_INT 33
70077: PUSH
70078: LD_INT 2
70080: PUSH
70081: EMPTY
70082: LIST
70083: LIST
70084: PPUSH
70085: CALL_OW 72
70089: ST_TO_ADDR
// if tmp then
70090: LD_VAR 0 4
70094: IFFALSE 70186
// for j in tmp do
70096: LD_ADDR_VAR 0 3
70100: PUSH
70101: LD_VAR 0 4
70105: PUSH
70106: FOR_IN
70107: IFFALSE 70184
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
70109: LD_VAR 0 3
70113: PPUSH
70114: CALL_OW 312
70118: NOT
70119: PUSH
70120: LD_VAR 0 3
70124: PPUSH
70125: CALL_OW 256
70129: PUSH
70130: LD_INT 250
70132: GREATEREQUAL
70133: AND
70134: IFFALSE 70147
// Connect ( j ) else
70136: LD_VAR 0 3
70140: PPUSH
70141: CALL 22772 0 1
70145: GO 70182
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
70147: LD_VAR 0 3
70151: PPUSH
70152: CALL_OW 256
70156: PUSH
70157: LD_INT 250
70159: LESS
70160: PUSH
70161: LD_VAR 0 3
70165: PPUSH
70166: CALL_OW 312
70170: AND
70171: IFFALSE 70182
// ComUnlink ( j ) ;
70173: LD_VAR 0 3
70177: PPUSH
70178: CALL_OW 136
70182: GO 70106
70184: POP
70185: POP
// end ;
70186: GO 70044
70188: POP
70189: POP
// end ;
70190: LD_VAR 0 1
70194: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
70195: LD_INT 0
70197: PPUSH
70198: PPUSH
70199: PPUSH
70200: PPUSH
70201: PPUSH
// if not mc_bases then
70202: LD_EXP 60
70206: NOT
70207: IFFALSE 70211
// exit ;
70209: GO 70656
// for i = 1 to mc_bases do
70211: LD_ADDR_VAR 0 2
70215: PUSH
70216: DOUBLE
70217: LD_INT 1
70219: DEC
70220: ST_TO_ADDR
70221: LD_EXP 60
70225: PUSH
70226: FOR_TO
70227: IFFALSE 70654
// begin if not mc_produce [ i ] then
70229: LD_EXP 81
70233: PUSH
70234: LD_VAR 0 2
70238: ARRAY
70239: NOT
70240: IFFALSE 70244
// continue ;
70242: GO 70226
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70244: LD_ADDR_VAR 0 5
70248: PUSH
70249: LD_EXP 60
70253: PUSH
70254: LD_VAR 0 2
70258: ARRAY
70259: PPUSH
70260: LD_INT 30
70262: PUSH
70263: LD_INT 3
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PPUSH
70270: CALL_OW 72
70274: ST_TO_ADDR
// if not fac then
70275: LD_VAR 0 5
70279: NOT
70280: IFFALSE 70284
// continue ;
70282: GO 70226
// for j in fac do
70284: LD_ADDR_VAR 0 3
70288: PUSH
70289: LD_VAR 0 5
70293: PUSH
70294: FOR_IN
70295: IFFALSE 70650
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
70297: LD_VAR 0 3
70301: PPUSH
70302: CALL_OW 461
70306: PUSH
70307: LD_INT 2
70309: NONEQUAL
70310: PUSH
70311: LD_VAR 0 3
70315: PPUSH
70316: LD_INT 15
70318: PPUSH
70319: CALL 22400 0 2
70323: PUSH
70324: LD_INT 4
70326: ARRAY
70327: OR
70328: IFFALSE 70332
// continue ;
70330: GO 70294
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
70332: LD_VAR 0 3
70336: PPUSH
70337: LD_EXP 81
70341: PUSH
70342: LD_VAR 0 2
70346: ARRAY
70347: PUSH
70348: LD_INT 1
70350: ARRAY
70351: PUSH
70352: LD_INT 1
70354: ARRAY
70355: PPUSH
70356: LD_EXP 81
70360: PUSH
70361: LD_VAR 0 2
70365: ARRAY
70366: PUSH
70367: LD_INT 1
70369: ARRAY
70370: PUSH
70371: LD_INT 2
70373: ARRAY
70374: PPUSH
70375: LD_EXP 81
70379: PUSH
70380: LD_VAR 0 2
70384: ARRAY
70385: PUSH
70386: LD_INT 1
70388: ARRAY
70389: PUSH
70390: LD_INT 3
70392: ARRAY
70393: PPUSH
70394: LD_EXP 81
70398: PUSH
70399: LD_VAR 0 2
70403: ARRAY
70404: PUSH
70405: LD_INT 1
70407: ARRAY
70408: PUSH
70409: LD_INT 4
70411: ARRAY
70412: PPUSH
70413: CALL_OW 448
70417: PUSH
70418: LD_VAR 0 3
70422: PPUSH
70423: LD_EXP 81
70427: PUSH
70428: LD_VAR 0 2
70432: ARRAY
70433: PUSH
70434: LD_INT 1
70436: ARRAY
70437: PUSH
70438: LD_INT 1
70440: ARRAY
70441: PUSH
70442: LD_EXP 81
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: PUSH
70453: LD_INT 1
70455: ARRAY
70456: PUSH
70457: LD_INT 2
70459: ARRAY
70460: PUSH
70461: LD_EXP 81
70465: PUSH
70466: LD_VAR 0 2
70470: ARRAY
70471: PUSH
70472: LD_INT 1
70474: ARRAY
70475: PUSH
70476: LD_INT 3
70478: ARRAY
70479: PUSH
70480: LD_EXP 81
70484: PUSH
70485: LD_VAR 0 2
70489: ARRAY
70490: PUSH
70491: LD_INT 1
70493: ARRAY
70494: PUSH
70495: LD_INT 4
70497: ARRAY
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: LIST
70503: LIST
70504: PPUSH
70505: CALL 26167 0 2
70509: AND
70510: IFFALSE 70648
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
70512: LD_VAR 0 3
70516: PPUSH
70517: LD_EXP 81
70521: PUSH
70522: LD_VAR 0 2
70526: ARRAY
70527: PUSH
70528: LD_INT 1
70530: ARRAY
70531: PUSH
70532: LD_INT 1
70534: ARRAY
70535: PPUSH
70536: LD_EXP 81
70540: PUSH
70541: LD_VAR 0 2
70545: ARRAY
70546: PUSH
70547: LD_INT 1
70549: ARRAY
70550: PUSH
70551: LD_INT 2
70553: ARRAY
70554: PPUSH
70555: LD_EXP 81
70559: PUSH
70560: LD_VAR 0 2
70564: ARRAY
70565: PUSH
70566: LD_INT 1
70568: ARRAY
70569: PUSH
70570: LD_INT 3
70572: ARRAY
70573: PPUSH
70574: LD_EXP 81
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: PUSH
70585: LD_INT 1
70587: ARRAY
70588: PUSH
70589: LD_INT 4
70591: ARRAY
70592: PPUSH
70593: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
70597: LD_ADDR_VAR 0 4
70601: PUSH
70602: LD_EXP 81
70606: PUSH
70607: LD_VAR 0 2
70611: ARRAY
70612: PPUSH
70613: LD_INT 1
70615: PPUSH
70616: CALL_OW 3
70620: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
70621: LD_ADDR_EXP 81
70625: PUSH
70626: LD_EXP 81
70630: PPUSH
70631: LD_VAR 0 2
70635: PPUSH
70636: LD_VAR 0 4
70640: PPUSH
70641: CALL_OW 1
70645: ST_TO_ADDR
// break ;
70646: GO 70650
// end ; end ;
70648: GO 70294
70650: POP
70651: POP
// end ;
70652: GO 70226
70654: POP
70655: POP
// end ;
70656: LD_VAR 0 1
70660: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
70661: LD_INT 0
70663: PPUSH
70664: PPUSH
70665: PPUSH
// if not mc_bases then
70666: LD_EXP 60
70670: NOT
70671: IFFALSE 70675
// exit ;
70673: GO 70764
// for i = 1 to mc_bases do
70675: LD_ADDR_VAR 0 2
70679: PUSH
70680: DOUBLE
70681: LD_INT 1
70683: DEC
70684: ST_TO_ADDR
70685: LD_EXP 60
70689: PUSH
70690: FOR_TO
70691: IFFALSE 70762
// begin if mc_attack [ i ] then
70693: LD_EXP 80
70697: PUSH
70698: LD_VAR 0 2
70702: ARRAY
70703: IFFALSE 70760
// begin tmp := mc_attack [ i ] [ 1 ] ;
70705: LD_ADDR_VAR 0 3
70709: PUSH
70710: LD_EXP 80
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: PUSH
70721: LD_INT 1
70723: ARRAY
70724: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
70725: LD_ADDR_EXP 80
70729: PUSH
70730: LD_EXP 80
70734: PPUSH
70735: LD_VAR 0 2
70739: PPUSH
70740: EMPTY
70741: PPUSH
70742: CALL_OW 1
70746: ST_TO_ADDR
// Attack ( tmp ) ;
70747: LD_VAR 0 3
70751: PPUSH
70752: CALL 104669 0 1
// exit ;
70756: POP
70757: POP
70758: GO 70764
// end ; end ;
70760: GO 70690
70762: POP
70763: POP
// end ;
70764: LD_VAR 0 1
70768: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
70769: LD_INT 0
70771: PPUSH
70772: PPUSH
70773: PPUSH
70774: PPUSH
70775: PPUSH
70776: PPUSH
70777: PPUSH
// if not mc_bases then
70778: LD_EXP 60
70782: NOT
70783: IFFALSE 70787
// exit ;
70785: GO 71644
// for i = 1 to mc_bases do
70787: LD_ADDR_VAR 0 2
70791: PUSH
70792: DOUBLE
70793: LD_INT 1
70795: DEC
70796: ST_TO_ADDR
70797: LD_EXP 60
70801: PUSH
70802: FOR_TO
70803: IFFALSE 71642
// begin if not mc_bases [ i ] then
70805: LD_EXP 60
70809: PUSH
70810: LD_VAR 0 2
70814: ARRAY
70815: NOT
70816: IFFALSE 70820
// continue ;
70818: GO 70802
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
70820: LD_ADDR_VAR 0 7
70824: PUSH
70825: LD_EXP 60
70829: PUSH
70830: LD_VAR 0 2
70834: ARRAY
70835: PUSH
70836: LD_INT 1
70838: ARRAY
70839: PPUSH
70840: CALL 16601 0 1
70844: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
70845: LD_ADDR_EXP 83
70849: PUSH
70850: LD_EXP 83
70854: PPUSH
70855: LD_VAR 0 2
70859: PPUSH
70860: LD_EXP 60
70864: PUSH
70865: LD_VAR 0 2
70869: ARRAY
70870: PUSH
70871: LD_INT 1
70873: ARRAY
70874: PPUSH
70875: CALL_OW 255
70879: PPUSH
70880: LD_EXP 85
70884: PUSH
70885: LD_VAR 0 2
70889: ARRAY
70890: PPUSH
70891: CALL 16566 0 2
70895: PPUSH
70896: CALL_OW 1
70900: ST_TO_ADDR
// if not mc_scan [ i ] then
70901: LD_EXP 83
70905: PUSH
70906: LD_VAR 0 2
70910: ARRAY
70911: NOT
70912: IFFALSE 71090
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
70914: LD_ADDR_EXP 103
70918: PUSH
70919: LD_EXP 103
70923: PPUSH
70924: LD_VAR 0 2
70928: PPUSH
70929: LD_INT 0
70931: PPUSH
70932: CALL_OW 1
70936: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
70937: LD_ADDR_VAR 0 4
70941: PUSH
70942: LD_EXP 60
70946: PUSH
70947: LD_VAR 0 2
70951: ARRAY
70952: PPUSH
70953: LD_INT 2
70955: PUSH
70956: LD_INT 25
70958: PUSH
70959: LD_INT 5
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 25
70968: PUSH
70969: LD_INT 8
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 25
70978: PUSH
70979: LD_INT 9
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: EMPTY
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: PPUSH
70992: CALL_OW 72
70996: ST_TO_ADDR
// if not tmp then
70997: LD_VAR 0 4
71001: NOT
71002: IFFALSE 71006
// continue ;
71004: GO 70802
// for j in tmp do
71006: LD_ADDR_VAR 0 3
71010: PUSH
71011: LD_VAR 0 4
71015: PUSH
71016: FOR_IN
71017: IFFALSE 71088
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
71019: LD_VAR 0 3
71023: PPUSH
71024: CALL_OW 310
71028: PPUSH
71029: CALL_OW 266
71033: PUSH
71034: LD_INT 5
71036: EQUAL
71037: PUSH
71038: LD_VAR 0 3
71042: PPUSH
71043: CALL_OW 257
71047: PUSH
71048: LD_INT 1
71050: EQUAL
71051: AND
71052: PUSH
71053: LD_VAR 0 3
71057: PPUSH
71058: CALL_OW 459
71062: NOT
71063: AND
71064: PUSH
71065: LD_VAR 0 7
71069: AND
71070: IFFALSE 71086
// ComChangeProfession ( j , class ) ;
71072: LD_VAR 0 3
71076: PPUSH
71077: LD_VAR 0 7
71081: PPUSH
71082: CALL_OW 123
71086: GO 71016
71088: POP
71089: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
71090: LD_EXP 83
71094: PUSH
71095: LD_VAR 0 2
71099: ARRAY
71100: PUSH
71101: LD_EXP 103
71105: PUSH
71106: LD_VAR 0 2
71110: ARRAY
71111: NOT
71112: AND
71113: PUSH
71114: LD_EXP 82
71118: PUSH
71119: LD_VAR 0 2
71123: ARRAY
71124: NOT
71125: AND
71126: PUSH
71127: LD_EXP 60
71131: PUSH
71132: LD_VAR 0 2
71136: ARRAY
71137: PPUSH
71138: LD_INT 50
71140: PUSH
71141: EMPTY
71142: LIST
71143: PUSH
71144: LD_INT 2
71146: PUSH
71147: LD_INT 30
71149: PUSH
71150: LD_INT 32
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 30
71159: PUSH
71160: LD_INT 33
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PUSH
71167: LD_INT 30
71169: PUSH
71170: LD_INT 4
71172: PUSH
71173: EMPTY
71174: LIST
71175: LIST
71176: PUSH
71177: LD_INT 30
71179: PUSH
71180: LD_INT 5
71182: PUSH
71183: EMPTY
71184: LIST
71185: LIST
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: LIST
71191: LIST
71192: LIST
71193: PUSH
71194: EMPTY
71195: LIST
71196: LIST
71197: PPUSH
71198: CALL_OW 72
71202: PUSH
71203: LD_INT 4
71205: LESS
71206: PUSH
71207: LD_EXP 60
71211: PUSH
71212: LD_VAR 0 2
71216: ARRAY
71217: PPUSH
71218: LD_INT 3
71220: PUSH
71221: LD_INT 24
71223: PUSH
71224: LD_INT 1000
71226: PUSH
71227: EMPTY
71228: LIST
71229: LIST
71230: PUSH
71231: EMPTY
71232: LIST
71233: LIST
71234: PUSH
71235: LD_INT 2
71237: PUSH
71238: LD_INT 30
71240: PUSH
71241: LD_INT 0
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 30
71250: PUSH
71251: LD_INT 1
71253: PUSH
71254: EMPTY
71255: LIST
71256: LIST
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: LIST
71262: PUSH
71263: EMPTY
71264: LIST
71265: LIST
71266: PPUSH
71267: CALL_OW 72
71271: OR
71272: AND
71273: IFFALSE 71524
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71275: LD_ADDR_EXP 103
71279: PUSH
71280: LD_EXP 103
71284: PPUSH
71285: LD_VAR 0 2
71289: PPUSH
71290: LD_INT 1
71292: PPUSH
71293: CALL_OW 1
71297: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
71298: LD_ADDR_VAR 0 4
71302: PUSH
71303: LD_EXP 60
71307: PUSH
71308: LD_VAR 0 2
71312: ARRAY
71313: PPUSH
71314: LD_INT 2
71316: PUSH
71317: LD_INT 25
71319: PUSH
71320: LD_INT 1
71322: PUSH
71323: EMPTY
71324: LIST
71325: LIST
71326: PUSH
71327: LD_INT 25
71329: PUSH
71330: LD_INT 5
71332: PUSH
71333: EMPTY
71334: LIST
71335: LIST
71336: PUSH
71337: LD_INT 25
71339: PUSH
71340: LD_INT 8
71342: PUSH
71343: EMPTY
71344: LIST
71345: LIST
71346: PUSH
71347: LD_INT 25
71349: PUSH
71350: LD_INT 9
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: EMPTY
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: PPUSH
71364: CALL_OW 72
71368: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
71369: LD_ADDR_VAR 0 4
71373: PUSH
71374: LD_VAR 0 4
71378: PUSH
71379: LD_VAR 0 4
71383: PPUSH
71384: LD_INT 18
71386: PPUSH
71387: CALL 49070 0 2
71391: DIFF
71392: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
71393: LD_VAR 0 4
71397: NOT
71398: PUSH
71399: LD_EXP 60
71403: PUSH
71404: LD_VAR 0 2
71408: ARRAY
71409: PPUSH
71410: LD_INT 2
71412: PUSH
71413: LD_INT 30
71415: PUSH
71416: LD_INT 4
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PUSH
71423: LD_INT 30
71425: PUSH
71426: LD_INT 5
71428: PUSH
71429: EMPTY
71430: LIST
71431: LIST
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: LIST
71437: PPUSH
71438: CALL_OW 72
71442: NOT
71443: AND
71444: IFFALSE 71506
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
71446: LD_ADDR_VAR 0 4
71450: PUSH
71451: LD_EXP 60
71455: PUSH
71456: LD_VAR 0 2
71460: ARRAY
71461: PPUSH
71462: LD_INT 2
71464: PUSH
71465: LD_INT 25
71467: PUSH
71468: LD_INT 2
71470: PUSH
71471: EMPTY
71472: LIST
71473: LIST
71474: PUSH
71475: LD_INT 25
71477: PUSH
71478: LD_INT 3
71480: PUSH
71481: EMPTY
71482: LIST
71483: LIST
71484: PUSH
71485: LD_INT 25
71487: PUSH
71488: LD_INT 4
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: LIST
71499: LIST
71500: PPUSH
71501: CALL_OW 72
71505: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
71506: LD_VAR 0 2
71510: PPUSH
71511: LD_VAR 0 4
71515: PPUSH
71516: CALL 109378 0 2
// exit ;
71520: POP
71521: POP
71522: GO 71644
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
71524: LD_EXP 83
71528: PUSH
71529: LD_VAR 0 2
71533: ARRAY
71534: PUSH
71535: LD_EXP 103
71539: PUSH
71540: LD_VAR 0 2
71544: ARRAY
71545: NOT
71546: AND
71547: PUSH
71548: LD_EXP 82
71552: PUSH
71553: LD_VAR 0 2
71557: ARRAY
71558: AND
71559: IFFALSE 71640
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
71561: LD_ADDR_EXP 103
71565: PUSH
71566: LD_EXP 103
71570: PPUSH
71571: LD_VAR 0 2
71575: PPUSH
71576: LD_INT 1
71578: PPUSH
71579: CALL_OW 1
71583: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
71584: LD_ADDR_VAR 0 4
71588: PUSH
71589: LD_EXP 82
71593: PUSH
71594: LD_VAR 0 2
71598: ARRAY
71599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
71600: LD_ADDR_EXP 82
71604: PUSH
71605: LD_EXP 82
71609: PPUSH
71610: LD_VAR 0 2
71614: PPUSH
71615: EMPTY
71616: PPUSH
71617: CALL_OW 1
71621: ST_TO_ADDR
// Defend ( i , tmp ) ;
71622: LD_VAR 0 2
71626: PPUSH
71627: LD_VAR 0 4
71631: PPUSH
71632: CALL 109974 0 2
// exit ;
71636: POP
71637: POP
71638: GO 71644
// end ; end ;
71640: GO 70802
71642: POP
71643: POP
// end ;
71644: LD_VAR 0 1
71648: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
71649: LD_INT 0
71651: PPUSH
71652: PPUSH
71653: PPUSH
71654: PPUSH
71655: PPUSH
71656: PPUSH
71657: PPUSH
71658: PPUSH
71659: PPUSH
71660: PPUSH
71661: PPUSH
// if not mc_bases then
71662: LD_EXP 60
71666: NOT
71667: IFFALSE 71671
// exit ;
71669: GO 72758
// for i = 1 to mc_bases do
71671: LD_ADDR_VAR 0 2
71675: PUSH
71676: DOUBLE
71677: LD_INT 1
71679: DEC
71680: ST_TO_ADDR
71681: LD_EXP 60
71685: PUSH
71686: FOR_TO
71687: IFFALSE 72756
// begin tmp := mc_lab [ i ] ;
71689: LD_ADDR_VAR 0 6
71693: PUSH
71694: LD_EXP 93
71698: PUSH
71699: LD_VAR 0 2
71703: ARRAY
71704: ST_TO_ADDR
// if not tmp then
71705: LD_VAR 0 6
71709: NOT
71710: IFFALSE 71714
// continue ;
71712: GO 71686
// idle_lab := 0 ;
71714: LD_ADDR_VAR 0 11
71718: PUSH
71719: LD_INT 0
71721: ST_TO_ADDR
// for j in tmp do
71722: LD_ADDR_VAR 0 3
71726: PUSH
71727: LD_VAR 0 6
71731: PUSH
71732: FOR_IN
71733: IFFALSE 72752
// begin researching := false ;
71735: LD_ADDR_VAR 0 10
71739: PUSH
71740: LD_INT 0
71742: ST_TO_ADDR
// side := GetSide ( j ) ;
71743: LD_ADDR_VAR 0 4
71747: PUSH
71748: LD_VAR 0 3
71752: PPUSH
71753: CALL_OW 255
71757: ST_TO_ADDR
// if not mc_tech [ side ] then
71758: LD_EXP 87
71762: PUSH
71763: LD_VAR 0 4
71767: ARRAY
71768: NOT
71769: IFFALSE 71773
// continue ;
71771: GO 71732
// if BuildingStatus ( j ) = bs_idle then
71773: LD_VAR 0 3
71777: PPUSH
71778: CALL_OW 461
71782: PUSH
71783: LD_INT 2
71785: EQUAL
71786: IFFALSE 71974
// begin if idle_lab and UnitsInside ( j ) < 6 then
71788: LD_VAR 0 11
71792: PUSH
71793: LD_VAR 0 3
71797: PPUSH
71798: CALL_OW 313
71802: PUSH
71803: LD_INT 6
71805: LESS
71806: AND
71807: IFFALSE 71878
// begin tmp2 := UnitsInside ( idle_lab ) ;
71809: LD_ADDR_VAR 0 9
71813: PUSH
71814: LD_VAR 0 11
71818: PPUSH
71819: CALL_OW 313
71823: ST_TO_ADDR
// if tmp2 then
71824: LD_VAR 0 9
71828: IFFALSE 71870
// for x in tmp2 do
71830: LD_ADDR_VAR 0 7
71834: PUSH
71835: LD_VAR 0 9
71839: PUSH
71840: FOR_IN
71841: IFFALSE 71868
// begin ComExitBuilding ( x ) ;
71843: LD_VAR 0 7
71847: PPUSH
71848: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
71852: LD_VAR 0 7
71856: PPUSH
71857: LD_VAR 0 3
71861: PPUSH
71862: CALL_OW 180
// end ;
71866: GO 71840
71868: POP
71869: POP
// idle_lab := 0 ;
71870: LD_ADDR_VAR 0 11
71874: PUSH
71875: LD_INT 0
71877: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
71878: LD_ADDR_VAR 0 5
71882: PUSH
71883: LD_EXP 87
71887: PUSH
71888: LD_VAR 0 4
71892: ARRAY
71893: PUSH
71894: FOR_IN
71895: IFFALSE 71955
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
71897: LD_VAR 0 3
71901: PPUSH
71902: LD_VAR 0 5
71906: PPUSH
71907: CALL_OW 430
71911: PUSH
71912: LD_VAR 0 4
71916: PPUSH
71917: LD_VAR 0 5
71921: PPUSH
71922: CALL 15671 0 2
71926: AND
71927: IFFALSE 71953
// begin researching := true ;
71929: LD_ADDR_VAR 0 10
71933: PUSH
71934: LD_INT 1
71936: ST_TO_ADDR
// ComResearch ( j , t ) ;
71937: LD_VAR 0 3
71941: PPUSH
71942: LD_VAR 0 5
71946: PPUSH
71947: CALL_OW 124
// break ;
71951: GO 71955
// end ;
71953: GO 71894
71955: POP
71956: POP
// if not researching then
71957: LD_VAR 0 10
71961: NOT
71962: IFFALSE 71974
// idle_lab := j ;
71964: LD_ADDR_VAR 0 11
71968: PUSH
71969: LD_VAR 0 3
71973: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
71974: LD_VAR 0 3
71978: PPUSH
71979: CALL_OW 461
71983: PUSH
71984: LD_INT 10
71986: EQUAL
71987: IFFALSE 72575
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
71989: LD_EXP 89
71993: PUSH
71994: LD_VAR 0 2
71998: ARRAY
71999: NOT
72000: PUSH
72001: LD_EXP 90
72005: PUSH
72006: LD_VAR 0 2
72010: ARRAY
72011: NOT
72012: AND
72013: PUSH
72014: LD_EXP 87
72018: PUSH
72019: LD_VAR 0 4
72023: ARRAY
72024: PUSH
72025: LD_INT 1
72027: GREATER
72028: AND
72029: IFFALSE 72160
// begin ComCancel ( j ) ;
72031: LD_VAR 0 3
72035: PPUSH
72036: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72040: LD_ADDR_EXP 87
72044: PUSH
72045: LD_EXP 87
72049: PPUSH
72050: LD_VAR 0 4
72054: PPUSH
72055: LD_EXP 87
72059: PUSH
72060: LD_VAR 0 4
72064: ARRAY
72065: PPUSH
72066: LD_EXP 87
72070: PUSH
72071: LD_VAR 0 4
72075: ARRAY
72076: PUSH
72077: LD_INT 1
72079: MINUS
72080: PPUSH
72081: LD_EXP 87
72085: PUSH
72086: LD_VAR 0 4
72090: ARRAY
72091: PPUSH
72092: LD_INT 0
72094: PPUSH
72095: CALL 19219 0 4
72099: PPUSH
72100: CALL_OW 1
72104: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72105: LD_ADDR_EXP 87
72109: PUSH
72110: LD_EXP 87
72114: PPUSH
72115: LD_VAR 0 4
72119: PPUSH
72120: LD_EXP 87
72124: PUSH
72125: LD_VAR 0 4
72129: ARRAY
72130: PPUSH
72131: LD_EXP 87
72135: PUSH
72136: LD_VAR 0 4
72140: ARRAY
72141: PPUSH
72142: LD_INT 1
72144: PPUSH
72145: LD_INT 0
72147: PPUSH
72148: CALL 19219 0 4
72152: PPUSH
72153: CALL_OW 1
72157: ST_TO_ADDR
// continue ;
72158: GO 71732
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
72160: LD_EXP 89
72164: PUSH
72165: LD_VAR 0 2
72169: ARRAY
72170: PUSH
72171: LD_EXP 90
72175: PUSH
72176: LD_VAR 0 2
72180: ARRAY
72181: NOT
72182: AND
72183: IFFALSE 72310
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
72185: LD_ADDR_EXP 90
72189: PUSH
72190: LD_EXP 90
72194: PPUSH
72195: LD_VAR 0 2
72199: PUSH
72200: LD_EXP 90
72204: PUSH
72205: LD_VAR 0 2
72209: ARRAY
72210: PUSH
72211: LD_INT 1
72213: PLUS
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: PPUSH
72219: LD_EXP 89
72223: PUSH
72224: LD_VAR 0 2
72228: ARRAY
72229: PUSH
72230: LD_INT 1
72232: ARRAY
72233: PPUSH
72234: CALL 19801 0 3
72238: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
72239: LD_EXP 89
72243: PUSH
72244: LD_VAR 0 2
72248: ARRAY
72249: PUSH
72250: LD_INT 1
72252: ARRAY
72253: PPUSH
72254: LD_INT 112
72256: PPUSH
72257: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
72261: LD_ADDR_VAR 0 9
72265: PUSH
72266: LD_EXP 89
72270: PUSH
72271: LD_VAR 0 2
72275: ARRAY
72276: PPUSH
72277: LD_INT 1
72279: PPUSH
72280: CALL_OW 3
72284: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
72285: LD_ADDR_EXP 89
72289: PUSH
72290: LD_EXP 89
72294: PPUSH
72295: LD_VAR 0 2
72299: PPUSH
72300: LD_VAR 0 9
72304: PPUSH
72305: CALL_OW 1
72309: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
72310: LD_EXP 89
72314: PUSH
72315: LD_VAR 0 2
72319: ARRAY
72320: PUSH
72321: LD_EXP 90
72325: PUSH
72326: LD_VAR 0 2
72330: ARRAY
72331: AND
72332: PUSH
72333: LD_EXP 90
72337: PUSH
72338: LD_VAR 0 2
72342: ARRAY
72343: PUSH
72344: LD_INT 1
72346: ARRAY
72347: PPUSH
72348: CALL_OW 310
72352: NOT
72353: AND
72354: PUSH
72355: LD_VAR 0 3
72359: PPUSH
72360: CALL_OW 313
72364: PUSH
72365: LD_INT 6
72367: EQUAL
72368: AND
72369: IFFALSE 72425
// begin tmp2 := UnitsInside ( j ) ;
72371: LD_ADDR_VAR 0 9
72375: PUSH
72376: LD_VAR 0 3
72380: PPUSH
72381: CALL_OW 313
72385: ST_TO_ADDR
// if tmp2 = 6 then
72386: LD_VAR 0 9
72390: PUSH
72391: LD_INT 6
72393: EQUAL
72394: IFFALSE 72425
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
72396: LD_VAR 0 9
72400: PUSH
72401: LD_INT 1
72403: ARRAY
72404: PPUSH
72405: LD_INT 112
72407: PPUSH
72408: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
72412: LD_VAR 0 9
72416: PUSH
72417: LD_INT 1
72419: ARRAY
72420: PPUSH
72421: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
72425: LD_EXP 90
72429: PUSH
72430: LD_VAR 0 2
72434: ARRAY
72435: PUSH
72436: LD_EXP 90
72440: PUSH
72441: LD_VAR 0 2
72445: ARRAY
72446: PUSH
72447: LD_INT 1
72449: ARRAY
72450: PPUSH
72451: CALL_OW 314
72455: NOT
72456: AND
72457: PUSH
72458: LD_EXP 90
72462: PUSH
72463: LD_VAR 0 2
72467: ARRAY
72468: PUSH
72469: LD_INT 1
72471: ARRAY
72472: PPUSH
72473: CALL_OW 310
72477: NOT
72478: AND
72479: IFFALSE 72505
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
72481: LD_EXP 90
72485: PUSH
72486: LD_VAR 0 2
72490: ARRAY
72491: PUSH
72492: LD_INT 1
72494: ARRAY
72495: PPUSH
72496: LD_VAR 0 3
72500: PPUSH
72501: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
72505: LD_EXP 90
72509: PUSH
72510: LD_VAR 0 2
72514: ARRAY
72515: PUSH
72516: LD_INT 1
72518: ARRAY
72519: PPUSH
72520: CALL_OW 310
72524: PUSH
72525: LD_EXP 90
72529: PUSH
72530: LD_VAR 0 2
72534: ARRAY
72535: PUSH
72536: LD_INT 1
72538: ARRAY
72539: PPUSH
72540: CALL_OW 310
72544: PPUSH
72545: CALL_OW 461
72549: PUSH
72550: LD_INT 3
72552: NONEQUAL
72553: AND
72554: IFFALSE 72575
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
72556: LD_EXP 90
72560: PUSH
72561: LD_VAR 0 2
72565: ARRAY
72566: PUSH
72567: LD_INT 1
72569: ARRAY
72570: PPUSH
72571: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
72575: LD_VAR 0 3
72579: PPUSH
72580: CALL_OW 461
72584: PUSH
72585: LD_INT 6
72587: EQUAL
72588: PUSH
72589: LD_VAR 0 6
72593: PUSH
72594: LD_INT 1
72596: GREATER
72597: AND
72598: IFFALSE 72750
// begin sci := [ ] ;
72600: LD_ADDR_VAR 0 8
72604: PUSH
72605: EMPTY
72606: ST_TO_ADDR
// for x in ( tmp diff j ) do
72607: LD_ADDR_VAR 0 7
72611: PUSH
72612: LD_VAR 0 6
72616: PUSH
72617: LD_VAR 0 3
72621: DIFF
72622: PUSH
72623: FOR_IN
72624: IFFALSE 72676
// begin if sci = 6 then
72626: LD_VAR 0 8
72630: PUSH
72631: LD_INT 6
72633: EQUAL
72634: IFFALSE 72638
// break ;
72636: GO 72676
// if BuildingStatus ( x ) = bs_idle then
72638: LD_VAR 0 7
72642: PPUSH
72643: CALL_OW 461
72647: PUSH
72648: LD_INT 2
72650: EQUAL
72651: IFFALSE 72674
// sci := sci ^ UnitsInside ( x ) ;
72653: LD_ADDR_VAR 0 8
72657: PUSH
72658: LD_VAR 0 8
72662: PUSH
72663: LD_VAR 0 7
72667: PPUSH
72668: CALL_OW 313
72672: ADD
72673: ST_TO_ADDR
// end ;
72674: GO 72623
72676: POP
72677: POP
// if not sci then
72678: LD_VAR 0 8
72682: NOT
72683: IFFALSE 72687
// continue ;
72685: GO 71732
// for x in sci do
72687: LD_ADDR_VAR 0 7
72691: PUSH
72692: LD_VAR 0 8
72696: PUSH
72697: FOR_IN
72698: IFFALSE 72748
// if IsInUnit ( x ) and not HasTask ( x ) then
72700: LD_VAR 0 7
72704: PPUSH
72705: CALL_OW 310
72709: PUSH
72710: LD_VAR 0 7
72714: PPUSH
72715: CALL_OW 314
72719: NOT
72720: AND
72721: IFFALSE 72746
// begin ComExitBuilding ( x ) ;
72723: LD_VAR 0 7
72727: PPUSH
72728: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72732: LD_VAR 0 7
72736: PPUSH
72737: LD_VAR 0 3
72741: PPUSH
72742: CALL_OW 180
// end ;
72746: GO 72697
72748: POP
72749: POP
// end ; end ;
72750: GO 71732
72752: POP
72753: POP
// end ;
72754: GO 71686
72756: POP
72757: POP
// end ;
72758: LD_VAR 0 1
72762: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
72763: LD_INT 0
72765: PPUSH
72766: PPUSH
// if not mc_bases then
72767: LD_EXP 60
72771: NOT
72772: IFFALSE 72776
// exit ;
72774: GO 72857
// for i = 1 to mc_bases do
72776: LD_ADDR_VAR 0 2
72780: PUSH
72781: DOUBLE
72782: LD_INT 1
72784: DEC
72785: ST_TO_ADDR
72786: LD_EXP 60
72790: PUSH
72791: FOR_TO
72792: IFFALSE 72855
// if mc_mines [ i ] and mc_miners [ i ] then
72794: LD_EXP 73
72798: PUSH
72799: LD_VAR 0 2
72803: ARRAY
72804: PUSH
72805: LD_EXP 74
72809: PUSH
72810: LD_VAR 0 2
72814: ARRAY
72815: AND
72816: IFFALSE 72853
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
72818: LD_EXP 74
72822: PUSH
72823: LD_VAR 0 2
72827: ARRAY
72828: PUSH
72829: LD_INT 1
72831: ARRAY
72832: PPUSH
72833: CALL_OW 255
72837: PPUSH
72838: LD_EXP 73
72842: PUSH
72843: LD_VAR 0 2
72847: ARRAY
72848: PPUSH
72849: CALL 16754 0 2
72853: GO 72791
72855: POP
72856: POP
// end ;
72857: LD_VAR 0 1
72861: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
72862: LD_INT 0
72864: PPUSH
72865: PPUSH
72866: PPUSH
72867: PPUSH
72868: PPUSH
72869: PPUSH
72870: PPUSH
72871: PPUSH
// if not mc_bases or not mc_parking then
72872: LD_EXP 60
72876: NOT
72877: PUSH
72878: LD_EXP 84
72882: NOT
72883: OR
72884: IFFALSE 72888
// exit ;
72886: GO 73598
// for i = 1 to mc_bases do
72888: LD_ADDR_VAR 0 2
72892: PUSH
72893: DOUBLE
72894: LD_INT 1
72896: DEC
72897: ST_TO_ADDR
72898: LD_EXP 60
72902: PUSH
72903: FOR_TO
72904: IFFALSE 73596
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
72906: LD_EXP 60
72910: PUSH
72911: LD_VAR 0 2
72915: ARRAY
72916: NOT
72917: PUSH
72918: LD_EXP 84
72922: PUSH
72923: LD_VAR 0 2
72927: ARRAY
72928: NOT
72929: OR
72930: IFFALSE 72934
// continue ;
72932: GO 72903
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
72934: LD_ADDR_VAR 0 5
72938: PUSH
72939: LD_EXP 60
72943: PUSH
72944: LD_VAR 0 2
72948: ARRAY
72949: PUSH
72950: LD_INT 1
72952: ARRAY
72953: PPUSH
72954: CALL_OW 255
72958: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72959: LD_ADDR_VAR 0 6
72963: PUSH
72964: LD_EXP 60
72968: PUSH
72969: LD_VAR 0 2
72973: ARRAY
72974: PPUSH
72975: LD_INT 30
72977: PUSH
72978: LD_INT 3
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PPUSH
72985: CALL_OW 72
72989: ST_TO_ADDR
// if not fac then
72990: LD_VAR 0 6
72994: NOT
72995: IFFALSE 73046
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
72997: LD_ADDR_VAR 0 6
73001: PUSH
73002: LD_EXP 60
73006: PUSH
73007: LD_VAR 0 2
73011: ARRAY
73012: PPUSH
73013: LD_INT 2
73015: PUSH
73016: LD_INT 30
73018: PUSH
73019: LD_INT 0
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: PUSH
73026: LD_INT 30
73028: PUSH
73029: LD_INT 1
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: LIST
73040: PPUSH
73041: CALL_OW 72
73045: ST_TO_ADDR
// if not fac then
73046: LD_VAR 0 6
73050: NOT
73051: IFFALSE 73055
// continue ;
73053: GO 72903
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73055: LD_ADDR_VAR 0 7
73059: PUSH
73060: LD_EXP 84
73064: PUSH
73065: LD_VAR 0 2
73069: ARRAY
73070: PPUSH
73071: LD_INT 22
73073: PUSH
73074: LD_VAR 0 5
73078: PUSH
73079: EMPTY
73080: LIST
73081: LIST
73082: PUSH
73083: LD_INT 21
73085: PUSH
73086: LD_INT 2
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 3
73095: PUSH
73096: LD_INT 24
73098: PUSH
73099: LD_INT 1000
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: LIST
73114: PPUSH
73115: CALL_OW 70
73119: ST_TO_ADDR
// for j in fac do
73120: LD_ADDR_VAR 0 3
73124: PUSH
73125: LD_VAR 0 6
73129: PUSH
73130: FOR_IN
73131: IFFALSE 73212
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73133: LD_ADDR_VAR 0 7
73137: PUSH
73138: LD_VAR 0 7
73142: PUSH
73143: LD_INT 22
73145: PUSH
73146: LD_VAR 0 5
73150: PUSH
73151: EMPTY
73152: LIST
73153: LIST
73154: PUSH
73155: LD_INT 91
73157: PUSH
73158: LD_VAR 0 3
73162: PUSH
73163: LD_INT 15
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 21
73173: PUSH
73174: LD_INT 2
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 3
73183: PUSH
73184: LD_INT 24
73186: PUSH
73187: LD_INT 1000
73189: PUSH
73190: EMPTY
73191: LIST
73192: LIST
73193: PUSH
73194: EMPTY
73195: LIST
73196: LIST
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: LIST
73202: LIST
73203: PPUSH
73204: CALL_OW 69
73208: UNION
73209: ST_TO_ADDR
73210: GO 73130
73212: POP
73213: POP
// if not vehs then
73214: LD_VAR 0 7
73218: NOT
73219: IFFALSE 73245
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73221: LD_ADDR_EXP 72
73225: PUSH
73226: LD_EXP 72
73230: PPUSH
73231: LD_VAR 0 2
73235: PPUSH
73236: EMPTY
73237: PPUSH
73238: CALL_OW 1
73242: ST_TO_ADDR
// continue ;
73243: GO 72903
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73245: LD_ADDR_VAR 0 8
73249: PUSH
73250: LD_EXP 60
73254: PUSH
73255: LD_VAR 0 2
73259: ARRAY
73260: PPUSH
73261: LD_INT 30
73263: PUSH
73264: LD_INT 3
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: PPUSH
73271: CALL_OW 72
73275: ST_TO_ADDR
// if tmp then
73276: LD_VAR 0 8
73280: IFFALSE 73383
// begin for j in tmp do
73282: LD_ADDR_VAR 0 3
73286: PUSH
73287: LD_VAR 0 8
73291: PUSH
73292: FOR_IN
73293: IFFALSE 73381
// for k in UnitsInside ( j ) do
73295: LD_ADDR_VAR 0 4
73299: PUSH
73300: LD_VAR 0 3
73304: PPUSH
73305: CALL_OW 313
73309: PUSH
73310: FOR_IN
73311: IFFALSE 73377
// if k then
73313: LD_VAR 0 4
73317: IFFALSE 73375
// if not k in mc_repair_vehicle [ i ] then
73319: LD_VAR 0 4
73323: PUSH
73324: LD_EXP 72
73328: PUSH
73329: LD_VAR 0 2
73333: ARRAY
73334: IN
73335: NOT
73336: IFFALSE 73375
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
73338: LD_ADDR_EXP 72
73342: PUSH
73343: LD_EXP 72
73347: PPUSH
73348: LD_VAR 0 2
73352: PPUSH
73353: LD_EXP 72
73357: PUSH
73358: LD_VAR 0 2
73362: ARRAY
73363: PUSH
73364: LD_VAR 0 4
73368: UNION
73369: PPUSH
73370: CALL_OW 1
73374: ST_TO_ADDR
73375: GO 73310
73377: POP
73378: POP
73379: GO 73292
73381: POP
73382: POP
// end ; if not mc_repair_vehicle [ i ] then
73383: LD_EXP 72
73387: PUSH
73388: LD_VAR 0 2
73392: ARRAY
73393: NOT
73394: IFFALSE 73398
// continue ;
73396: GO 72903
// for j in mc_repair_vehicle [ i ] do
73398: LD_ADDR_VAR 0 3
73402: PUSH
73403: LD_EXP 72
73407: PUSH
73408: LD_VAR 0 2
73412: ARRAY
73413: PUSH
73414: FOR_IN
73415: IFFALSE 73592
// begin if GetClass ( j ) <> 3 then
73417: LD_VAR 0 3
73421: PPUSH
73422: CALL_OW 257
73426: PUSH
73427: LD_INT 3
73429: NONEQUAL
73430: IFFALSE 73471
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
73432: LD_ADDR_EXP 72
73436: PUSH
73437: LD_EXP 72
73441: PPUSH
73442: LD_VAR 0 2
73446: PPUSH
73447: LD_EXP 72
73451: PUSH
73452: LD_VAR 0 2
73456: ARRAY
73457: PUSH
73458: LD_VAR 0 3
73462: DIFF
73463: PPUSH
73464: CALL_OW 1
73468: ST_TO_ADDR
// continue ;
73469: GO 73414
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
73471: LD_VAR 0 3
73475: PPUSH
73476: CALL_OW 311
73480: NOT
73481: PUSH
73482: LD_VAR 0 3
73486: PUSH
73487: LD_EXP 63
73491: PUSH
73492: LD_VAR 0 2
73496: ARRAY
73497: PUSH
73498: LD_INT 1
73500: ARRAY
73501: IN
73502: NOT
73503: AND
73504: PUSH
73505: LD_VAR 0 3
73509: PUSH
73510: LD_EXP 63
73514: PUSH
73515: LD_VAR 0 2
73519: ARRAY
73520: PUSH
73521: LD_INT 2
73523: ARRAY
73524: IN
73525: NOT
73526: AND
73527: IFFALSE 73590
// begin if IsInUnit ( j ) then
73529: LD_VAR 0 3
73533: PPUSH
73534: CALL_OW 310
73538: IFFALSE 73551
// ComExitBuilding ( j ) else
73540: LD_VAR 0 3
73544: PPUSH
73545: CALL_OW 122
73549: GO 73590
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
73551: LD_VAR 0 3
73555: PPUSH
73556: LD_VAR 0 7
73560: PUSH
73561: LD_INT 1
73563: ARRAY
73564: PPUSH
73565: CALL 53609 0 2
73569: NOT
73570: IFFALSE 73590
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
73572: LD_VAR 0 3
73576: PPUSH
73577: LD_VAR 0 7
73581: PUSH
73582: LD_INT 1
73584: ARRAY
73585: PPUSH
73586: CALL_OW 129
// end ; end ;
73590: GO 73414
73592: POP
73593: POP
// end ;
73594: GO 72903
73596: POP
73597: POP
// end ;
73598: LD_VAR 0 1
73602: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
73603: LD_INT 0
73605: PPUSH
73606: PPUSH
73607: PPUSH
73608: PPUSH
73609: PPUSH
73610: PPUSH
73611: PPUSH
73612: PPUSH
73613: PPUSH
73614: PPUSH
73615: PPUSH
// if not mc_bases then
73616: LD_EXP 60
73620: NOT
73621: IFFALSE 73625
// exit ;
73623: GO 74427
// for i = 1 to mc_bases do
73625: LD_ADDR_VAR 0 2
73629: PUSH
73630: DOUBLE
73631: LD_INT 1
73633: DEC
73634: ST_TO_ADDR
73635: LD_EXP 60
73639: PUSH
73640: FOR_TO
73641: IFFALSE 74425
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
73643: LD_EXP 88
73647: PUSH
73648: LD_VAR 0 2
73652: ARRAY
73653: NOT
73654: PUSH
73655: LD_EXP 63
73659: PUSH
73660: LD_VAR 0 2
73664: ARRAY
73665: PUSH
73666: LD_INT 1
73668: ARRAY
73669: OR
73670: PUSH
73671: LD_EXP 63
73675: PUSH
73676: LD_VAR 0 2
73680: ARRAY
73681: PUSH
73682: LD_INT 2
73684: ARRAY
73685: OR
73686: PUSH
73687: LD_EXP 86
73691: PUSH
73692: LD_VAR 0 2
73696: ARRAY
73697: PPUSH
73698: LD_INT 1
73700: PPUSH
73701: CALL_OW 325
73705: NOT
73706: OR
73707: PUSH
73708: LD_EXP 83
73712: PUSH
73713: LD_VAR 0 2
73717: ARRAY
73718: OR
73719: IFFALSE 73723
// continue ;
73721: GO 73640
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
73723: LD_ADDR_VAR 0 8
73727: PUSH
73728: LD_EXP 60
73732: PUSH
73733: LD_VAR 0 2
73737: ARRAY
73738: PPUSH
73739: LD_INT 25
73741: PUSH
73742: LD_INT 4
73744: PUSH
73745: EMPTY
73746: LIST
73747: LIST
73748: PUSH
73749: LD_INT 50
73751: PUSH
73752: EMPTY
73753: LIST
73754: PUSH
73755: LD_INT 3
73757: PUSH
73758: LD_INT 60
73760: PUSH
73761: EMPTY
73762: LIST
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: LIST
73772: PPUSH
73773: CALL_OW 72
73777: PUSH
73778: LD_EXP 64
73782: PUSH
73783: LD_VAR 0 2
73787: ARRAY
73788: DIFF
73789: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73790: LD_ADDR_VAR 0 9
73794: PUSH
73795: LD_EXP 60
73799: PUSH
73800: LD_VAR 0 2
73804: ARRAY
73805: PPUSH
73806: LD_INT 2
73808: PUSH
73809: LD_INT 30
73811: PUSH
73812: LD_INT 0
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 30
73821: PUSH
73822: LD_INT 1
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: LIST
73833: PPUSH
73834: CALL_OW 72
73838: ST_TO_ADDR
// if not tmp or not dep then
73839: LD_VAR 0 8
73843: NOT
73844: PUSH
73845: LD_VAR 0 9
73849: NOT
73850: OR
73851: IFFALSE 73855
// continue ;
73853: GO 73640
// side := GetSide ( tmp [ 1 ] ) ;
73855: LD_ADDR_VAR 0 11
73859: PUSH
73860: LD_VAR 0 8
73864: PUSH
73865: LD_INT 1
73867: ARRAY
73868: PPUSH
73869: CALL_OW 255
73873: ST_TO_ADDR
// dep := dep [ 1 ] ;
73874: LD_ADDR_VAR 0 9
73878: PUSH
73879: LD_VAR 0 9
73883: PUSH
73884: LD_INT 1
73886: ARRAY
73887: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
73888: LD_ADDR_VAR 0 7
73892: PUSH
73893: LD_EXP 88
73897: PUSH
73898: LD_VAR 0 2
73902: ARRAY
73903: PPUSH
73904: LD_INT 22
73906: PUSH
73907: LD_INT 0
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: PUSH
73914: LD_INT 25
73916: PUSH
73917: LD_INT 12
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PPUSH
73928: CALL_OW 70
73932: PUSH
73933: LD_INT 22
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: EMPTY
73940: LIST
73941: LIST
73942: PUSH
73943: LD_INT 25
73945: PUSH
73946: LD_INT 12
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 91
73955: PUSH
73956: LD_VAR 0 9
73960: PUSH
73961: LD_INT 20
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: LIST
73968: PUSH
73969: EMPTY
73970: LIST
73971: LIST
73972: LIST
73973: PPUSH
73974: CALL_OW 69
73978: UNION
73979: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
73980: LD_ADDR_VAR 0 10
73984: PUSH
73985: LD_EXP 88
73989: PUSH
73990: LD_VAR 0 2
73994: ARRAY
73995: PPUSH
73996: LD_INT 81
73998: PUSH
73999: LD_VAR 0 11
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PPUSH
74008: CALL_OW 70
74012: ST_TO_ADDR
// if not apes or danger_at_area then
74013: LD_VAR 0 7
74017: NOT
74018: PUSH
74019: LD_VAR 0 10
74023: OR
74024: IFFALSE 74074
// begin if mc_taming [ i ] then
74026: LD_EXP 91
74030: PUSH
74031: LD_VAR 0 2
74035: ARRAY
74036: IFFALSE 74072
// begin MC_Reset ( i , 121 ) ;
74038: LD_VAR 0 2
74042: PPUSH
74043: LD_INT 121
74045: PPUSH
74046: CALL 59060 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74050: LD_ADDR_EXP 91
74054: PUSH
74055: LD_EXP 91
74059: PPUSH
74060: LD_VAR 0 2
74064: PPUSH
74065: EMPTY
74066: PPUSH
74067: CALL_OW 1
74071: ST_TO_ADDR
// end ; continue ;
74072: GO 73640
// end ; for j in tmp do
74074: LD_ADDR_VAR 0 3
74078: PUSH
74079: LD_VAR 0 8
74083: PUSH
74084: FOR_IN
74085: IFFALSE 74421
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74087: LD_VAR 0 3
74091: PUSH
74092: LD_EXP 91
74096: PUSH
74097: LD_VAR 0 2
74101: ARRAY
74102: IN
74103: NOT
74104: PUSH
74105: LD_EXP 91
74109: PUSH
74110: LD_VAR 0 2
74114: ARRAY
74115: PUSH
74116: LD_INT 3
74118: LESS
74119: AND
74120: IFFALSE 74178
// begin SetTag ( j , 121 ) ;
74122: LD_VAR 0 3
74126: PPUSH
74127: LD_INT 121
74129: PPUSH
74130: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74134: LD_ADDR_EXP 91
74138: PUSH
74139: LD_EXP 91
74143: PPUSH
74144: LD_VAR 0 2
74148: PUSH
74149: LD_EXP 91
74153: PUSH
74154: LD_VAR 0 2
74158: ARRAY
74159: PUSH
74160: LD_INT 1
74162: PLUS
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PPUSH
74168: LD_VAR 0 3
74172: PPUSH
74173: CALL 19801 0 3
74177: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
74178: LD_VAR 0 3
74182: PUSH
74183: LD_EXP 91
74187: PUSH
74188: LD_VAR 0 2
74192: ARRAY
74193: IN
74194: IFFALSE 74419
// begin if GetClass ( j ) <> 4 then
74196: LD_VAR 0 3
74200: PPUSH
74201: CALL_OW 257
74205: PUSH
74206: LD_INT 4
74208: NONEQUAL
74209: IFFALSE 74262
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
74211: LD_ADDR_EXP 91
74215: PUSH
74216: LD_EXP 91
74220: PPUSH
74221: LD_VAR 0 2
74225: PPUSH
74226: LD_EXP 91
74230: PUSH
74231: LD_VAR 0 2
74235: ARRAY
74236: PUSH
74237: LD_VAR 0 3
74241: DIFF
74242: PPUSH
74243: CALL_OW 1
74247: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74248: LD_VAR 0 3
74252: PPUSH
74253: LD_INT 0
74255: PPUSH
74256: CALL_OW 109
// continue ;
74260: GO 74084
// end ; if IsInUnit ( j ) then
74262: LD_VAR 0 3
74266: PPUSH
74267: CALL_OW 310
74271: IFFALSE 74282
// ComExitBuilding ( j ) ;
74273: LD_VAR 0 3
74277: PPUSH
74278: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
74282: LD_ADDR_VAR 0 6
74286: PUSH
74287: LD_VAR 0 7
74291: PPUSH
74292: LD_VAR 0 3
74296: PPUSH
74297: CALL_OW 74
74301: ST_TO_ADDR
// if not ape then
74302: LD_VAR 0 6
74306: NOT
74307: IFFALSE 74311
// break ;
74309: GO 74421
// x := GetX ( ape ) ;
74311: LD_ADDR_VAR 0 4
74315: PUSH
74316: LD_VAR 0 6
74320: PPUSH
74321: CALL_OW 250
74325: ST_TO_ADDR
// y := GetY ( ape ) ;
74326: LD_ADDR_VAR 0 5
74330: PUSH
74331: LD_VAR 0 6
74335: PPUSH
74336: CALL_OW 251
74340: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
74341: LD_VAR 0 4
74345: PPUSH
74346: LD_VAR 0 5
74350: PPUSH
74351: CALL_OW 488
74355: NOT
74356: PUSH
74357: LD_VAR 0 11
74361: PPUSH
74362: LD_VAR 0 4
74366: PPUSH
74367: LD_VAR 0 5
74371: PPUSH
74372: LD_INT 20
74374: PPUSH
74375: CALL 20697 0 4
74379: PUSH
74380: LD_INT 4
74382: ARRAY
74383: OR
74384: IFFALSE 74388
// break ;
74386: GO 74421
// if not HasTask ( j ) then
74388: LD_VAR 0 3
74392: PPUSH
74393: CALL_OW 314
74397: NOT
74398: IFFALSE 74419
// ComTameXY ( j , x , y ) ;
74400: LD_VAR 0 3
74404: PPUSH
74405: LD_VAR 0 4
74409: PPUSH
74410: LD_VAR 0 5
74414: PPUSH
74415: CALL_OW 131
// end ; end ;
74419: GO 74084
74421: POP
74422: POP
// end ;
74423: GO 73640
74425: POP
74426: POP
// end ;
74427: LD_VAR 0 1
74431: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
74432: LD_INT 0
74434: PPUSH
74435: PPUSH
74436: PPUSH
74437: PPUSH
74438: PPUSH
74439: PPUSH
74440: PPUSH
74441: PPUSH
// if not mc_bases then
74442: LD_EXP 60
74446: NOT
74447: IFFALSE 74451
// exit ;
74449: GO 75077
// for i = 1 to mc_bases do
74451: LD_ADDR_VAR 0 2
74455: PUSH
74456: DOUBLE
74457: LD_INT 1
74459: DEC
74460: ST_TO_ADDR
74461: LD_EXP 60
74465: PUSH
74466: FOR_TO
74467: IFFALSE 75075
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
74469: LD_EXP 89
74473: PUSH
74474: LD_VAR 0 2
74478: ARRAY
74479: NOT
74480: PUSH
74481: LD_EXP 89
74485: PUSH
74486: LD_VAR 0 2
74490: ARRAY
74491: PPUSH
74492: LD_INT 25
74494: PUSH
74495: LD_INT 12
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PPUSH
74502: CALL_OW 72
74506: NOT
74507: OR
74508: IFFALSE 74512
// continue ;
74510: GO 74466
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
74512: LD_ADDR_VAR 0 5
74516: PUSH
74517: LD_EXP 89
74521: PUSH
74522: LD_VAR 0 2
74526: ARRAY
74527: PUSH
74528: LD_INT 1
74530: ARRAY
74531: PPUSH
74532: CALL_OW 255
74536: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
74537: LD_VAR 0 5
74541: PPUSH
74542: LD_INT 2
74544: PPUSH
74545: CALL_OW 325
74549: IFFALSE 74802
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74551: LD_ADDR_VAR 0 4
74555: PUSH
74556: LD_EXP 89
74560: PUSH
74561: LD_VAR 0 2
74565: ARRAY
74566: PPUSH
74567: LD_INT 25
74569: PUSH
74570: LD_INT 16
74572: PUSH
74573: EMPTY
74574: LIST
74575: LIST
74576: PPUSH
74577: CALL_OW 72
74581: ST_TO_ADDR
// if tmp < 6 then
74582: LD_VAR 0 4
74586: PUSH
74587: LD_INT 6
74589: LESS
74590: IFFALSE 74802
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74592: LD_ADDR_VAR 0 6
74596: PUSH
74597: LD_EXP 60
74601: PUSH
74602: LD_VAR 0 2
74606: ARRAY
74607: PPUSH
74608: LD_INT 2
74610: PUSH
74611: LD_INT 30
74613: PUSH
74614: LD_INT 0
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: PUSH
74621: LD_INT 30
74623: PUSH
74624: LD_INT 1
74626: PUSH
74627: EMPTY
74628: LIST
74629: LIST
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: LIST
74635: PPUSH
74636: CALL_OW 72
74640: ST_TO_ADDR
// if depot then
74641: LD_VAR 0 6
74645: IFFALSE 74802
// begin selected := 0 ;
74647: LD_ADDR_VAR 0 7
74651: PUSH
74652: LD_INT 0
74654: ST_TO_ADDR
// for j in depot do
74655: LD_ADDR_VAR 0 3
74659: PUSH
74660: LD_VAR 0 6
74664: PUSH
74665: FOR_IN
74666: IFFALSE 74697
// begin if UnitsInside ( j ) < 6 then
74668: LD_VAR 0 3
74672: PPUSH
74673: CALL_OW 313
74677: PUSH
74678: LD_INT 6
74680: LESS
74681: IFFALSE 74695
// begin selected := j ;
74683: LD_ADDR_VAR 0 7
74687: PUSH
74688: LD_VAR 0 3
74692: ST_TO_ADDR
// break ;
74693: GO 74697
// end ; end ;
74695: GO 74665
74697: POP
74698: POP
// if selected then
74699: LD_VAR 0 7
74703: IFFALSE 74802
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74705: LD_ADDR_VAR 0 3
74709: PUSH
74710: LD_EXP 89
74714: PUSH
74715: LD_VAR 0 2
74719: ARRAY
74720: PPUSH
74721: LD_INT 25
74723: PUSH
74724: LD_INT 12
74726: PUSH
74727: EMPTY
74728: LIST
74729: LIST
74730: PPUSH
74731: CALL_OW 72
74735: PUSH
74736: FOR_IN
74737: IFFALSE 74800
// if not HasTask ( j ) then
74739: LD_VAR 0 3
74743: PPUSH
74744: CALL_OW 314
74748: NOT
74749: IFFALSE 74798
// begin if not IsInUnit ( j ) then
74751: LD_VAR 0 3
74755: PPUSH
74756: CALL_OW 310
74760: NOT
74761: IFFALSE 74777
// ComEnterUnit ( j , selected ) ;
74763: LD_VAR 0 3
74767: PPUSH
74768: LD_VAR 0 7
74772: PPUSH
74773: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
74777: LD_VAR 0 3
74781: PPUSH
74782: LD_INT 16
74784: PPUSH
74785: CALL_OW 183
// AddComExitBuilding ( j ) ;
74789: LD_VAR 0 3
74793: PPUSH
74794: CALL_OW 182
// end ;
74798: GO 74736
74800: POP
74801: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
74802: LD_VAR 0 5
74806: PPUSH
74807: LD_INT 11
74809: PPUSH
74810: CALL_OW 325
74814: IFFALSE 75073
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
74816: LD_ADDR_VAR 0 4
74820: PUSH
74821: LD_EXP 89
74825: PUSH
74826: LD_VAR 0 2
74830: ARRAY
74831: PPUSH
74832: LD_INT 25
74834: PUSH
74835: LD_INT 16
74837: PUSH
74838: EMPTY
74839: LIST
74840: LIST
74841: PPUSH
74842: CALL_OW 72
74846: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
74847: LD_VAR 0 4
74851: PUSH
74852: LD_INT 6
74854: GREATEREQUAL
74855: PUSH
74856: LD_VAR 0 5
74860: PPUSH
74861: LD_INT 2
74863: PPUSH
74864: CALL_OW 325
74868: NOT
74869: OR
74870: IFFALSE 75073
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
74872: LD_ADDR_VAR 0 8
74876: PUSH
74877: LD_EXP 60
74881: PUSH
74882: LD_VAR 0 2
74886: ARRAY
74887: PPUSH
74888: LD_INT 2
74890: PUSH
74891: LD_INT 30
74893: PUSH
74894: LD_INT 4
74896: PUSH
74897: EMPTY
74898: LIST
74899: LIST
74900: PUSH
74901: LD_INT 30
74903: PUSH
74904: LD_INT 5
74906: PUSH
74907: EMPTY
74908: LIST
74909: LIST
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: LIST
74915: PPUSH
74916: CALL_OW 72
74920: ST_TO_ADDR
// if barracks then
74921: LD_VAR 0 8
74925: IFFALSE 75073
// begin selected := 0 ;
74927: LD_ADDR_VAR 0 7
74931: PUSH
74932: LD_INT 0
74934: ST_TO_ADDR
// for j in barracks do
74935: LD_ADDR_VAR 0 3
74939: PUSH
74940: LD_VAR 0 8
74944: PUSH
74945: FOR_IN
74946: IFFALSE 74977
// begin if UnitsInside ( j ) < 6 then
74948: LD_VAR 0 3
74952: PPUSH
74953: CALL_OW 313
74957: PUSH
74958: LD_INT 6
74960: LESS
74961: IFFALSE 74975
// begin selected := j ;
74963: LD_ADDR_VAR 0 7
74967: PUSH
74968: LD_VAR 0 3
74972: ST_TO_ADDR
// break ;
74973: GO 74977
// end ; end ;
74975: GO 74945
74977: POP
74978: POP
// if selected then
74979: LD_VAR 0 7
74983: IFFALSE 75073
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
74985: LD_ADDR_VAR 0 3
74989: PUSH
74990: LD_EXP 89
74994: PUSH
74995: LD_VAR 0 2
74999: ARRAY
75000: PPUSH
75001: LD_INT 25
75003: PUSH
75004: LD_INT 12
75006: PUSH
75007: EMPTY
75008: LIST
75009: LIST
75010: PPUSH
75011: CALL_OW 72
75015: PUSH
75016: FOR_IN
75017: IFFALSE 75071
// if not IsInUnit ( j ) and not HasTask ( j ) then
75019: LD_VAR 0 3
75023: PPUSH
75024: CALL_OW 310
75028: NOT
75029: PUSH
75030: LD_VAR 0 3
75034: PPUSH
75035: CALL_OW 314
75039: NOT
75040: AND
75041: IFFALSE 75069
// begin ComEnterUnit ( j , selected ) ;
75043: LD_VAR 0 3
75047: PPUSH
75048: LD_VAR 0 7
75052: PPUSH
75053: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75057: LD_VAR 0 3
75061: PPUSH
75062: LD_INT 15
75064: PPUSH
75065: CALL_OW 183
// end ;
75069: GO 75016
75071: POP
75072: POP
// end ; end ; end ; end ; end ;
75073: GO 74466
75075: POP
75076: POP
// end ;
75077: LD_VAR 0 1
75081: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75082: LD_INT 0
75084: PPUSH
75085: PPUSH
75086: PPUSH
75087: PPUSH
// if not mc_bases then
75088: LD_EXP 60
75092: NOT
75093: IFFALSE 75097
// exit ;
75095: GO 75275
// for i = 1 to mc_bases do
75097: LD_ADDR_VAR 0 2
75101: PUSH
75102: DOUBLE
75103: LD_INT 1
75105: DEC
75106: ST_TO_ADDR
75107: LD_EXP 60
75111: PUSH
75112: FOR_TO
75113: IFFALSE 75273
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75115: LD_ADDR_VAR 0 4
75119: PUSH
75120: LD_EXP 60
75124: PUSH
75125: LD_VAR 0 2
75129: ARRAY
75130: PPUSH
75131: LD_INT 25
75133: PUSH
75134: LD_INT 9
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PPUSH
75141: CALL_OW 72
75145: ST_TO_ADDR
// if not tmp then
75146: LD_VAR 0 4
75150: NOT
75151: IFFALSE 75155
// continue ;
75153: GO 75112
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
75155: LD_EXP 86
75159: PUSH
75160: LD_VAR 0 2
75164: ARRAY
75165: PPUSH
75166: LD_INT 29
75168: PPUSH
75169: CALL_OW 325
75173: NOT
75174: PUSH
75175: LD_EXP 86
75179: PUSH
75180: LD_VAR 0 2
75184: ARRAY
75185: PPUSH
75186: LD_INT 28
75188: PPUSH
75189: CALL_OW 325
75193: NOT
75194: AND
75195: IFFALSE 75199
// continue ;
75197: GO 75112
// for j in tmp do
75199: LD_ADDR_VAR 0 3
75203: PUSH
75204: LD_VAR 0 4
75208: PUSH
75209: FOR_IN
75210: IFFALSE 75269
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75212: LD_VAR 0 3
75216: PUSH
75217: LD_EXP 63
75221: PUSH
75222: LD_VAR 0 2
75226: ARRAY
75227: PUSH
75228: LD_INT 1
75230: ARRAY
75231: IN
75232: NOT
75233: PUSH
75234: LD_VAR 0 3
75238: PUSH
75239: LD_EXP 63
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PUSH
75250: LD_INT 2
75252: ARRAY
75253: IN
75254: NOT
75255: AND
75256: IFFALSE 75267
// ComSpaceTimeShoot ( j ) ;
75258: LD_VAR 0 3
75262: PPUSH
75263: CALL 15762 0 1
75267: GO 75209
75269: POP
75270: POP
// end ;
75271: GO 75112
75273: POP
75274: POP
// end ;
75275: LD_VAR 0 1
75279: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
75280: LD_INT 0
75282: PPUSH
75283: PPUSH
75284: PPUSH
75285: PPUSH
75286: PPUSH
75287: PPUSH
75288: PPUSH
75289: PPUSH
75290: PPUSH
// if not mc_bases then
75291: LD_EXP 60
75295: NOT
75296: IFFALSE 75300
// exit ;
75298: GO 75922
// for i = 1 to mc_bases do
75300: LD_ADDR_VAR 0 2
75304: PUSH
75305: DOUBLE
75306: LD_INT 1
75308: DEC
75309: ST_TO_ADDR
75310: LD_EXP 60
75314: PUSH
75315: FOR_TO
75316: IFFALSE 75920
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
75318: LD_EXP 95
75322: PUSH
75323: LD_VAR 0 2
75327: ARRAY
75328: NOT
75329: PUSH
75330: LD_INT 38
75332: PPUSH
75333: LD_EXP 86
75337: PUSH
75338: LD_VAR 0 2
75342: ARRAY
75343: PPUSH
75344: CALL_OW 321
75348: PUSH
75349: LD_INT 2
75351: NONEQUAL
75352: OR
75353: IFFALSE 75357
// continue ;
75355: GO 75315
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
75357: LD_ADDR_VAR 0 8
75361: PUSH
75362: LD_EXP 60
75366: PUSH
75367: LD_VAR 0 2
75371: ARRAY
75372: PPUSH
75373: LD_INT 30
75375: PUSH
75376: LD_INT 34
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PPUSH
75383: CALL_OW 72
75387: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
75388: LD_ADDR_VAR 0 9
75392: PUSH
75393: LD_EXP 60
75397: PUSH
75398: LD_VAR 0 2
75402: ARRAY
75403: PPUSH
75404: LD_INT 25
75406: PUSH
75407: LD_INT 4
75409: PUSH
75410: EMPTY
75411: LIST
75412: LIST
75413: PPUSH
75414: CALL_OW 72
75418: PPUSH
75419: LD_INT 0
75421: PPUSH
75422: CALL 49070 0 2
75426: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
75427: LD_VAR 0 9
75431: NOT
75432: PUSH
75433: LD_VAR 0 8
75437: NOT
75438: OR
75439: PUSH
75440: LD_EXP 60
75444: PUSH
75445: LD_VAR 0 2
75449: ARRAY
75450: PPUSH
75451: LD_INT 124
75453: PPUSH
75454: CALL 49070 0 2
75458: OR
75459: IFFALSE 75463
// continue ;
75461: GO 75315
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
75463: LD_EXP 96
75467: PUSH
75468: LD_VAR 0 2
75472: ARRAY
75473: PUSH
75474: LD_EXP 95
75478: PUSH
75479: LD_VAR 0 2
75483: ARRAY
75484: LESS
75485: PUSH
75486: LD_EXP 96
75490: PUSH
75491: LD_VAR 0 2
75495: ARRAY
75496: PUSH
75497: LD_VAR 0 8
75501: LESS
75502: AND
75503: IFFALSE 75918
// begin tmp := sci [ 1 ] ;
75505: LD_ADDR_VAR 0 7
75509: PUSH
75510: LD_VAR 0 9
75514: PUSH
75515: LD_INT 1
75517: ARRAY
75518: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
75519: LD_VAR 0 7
75523: PPUSH
75524: LD_INT 124
75526: PPUSH
75527: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
75531: LD_ADDR_VAR 0 3
75535: PUSH
75536: DOUBLE
75537: LD_EXP 95
75541: PUSH
75542: LD_VAR 0 2
75546: ARRAY
75547: INC
75548: ST_TO_ADDR
75549: LD_EXP 95
75553: PUSH
75554: LD_VAR 0 2
75558: ARRAY
75559: PUSH
75560: FOR_DOWNTO
75561: IFFALSE 75904
// begin if IsInUnit ( tmp ) then
75563: LD_VAR 0 7
75567: PPUSH
75568: CALL_OW 310
75572: IFFALSE 75583
// ComExitBuilding ( tmp ) ;
75574: LD_VAR 0 7
75578: PPUSH
75579: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
75583: LD_INT 35
75585: PPUSH
75586: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
75590: LD_VAR 0 7
75594: PPUSH
75595: CALL_OW 310
75599: NOT
75600: PUSH
75601: LD_VAR 0 7
75605: PPUSH
75606: CALL_OW 314
75610: NOT
75611: AND
75612: IFFALSE 75583
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
75614: LD_ADDR_VAR 0 6
75618: PUSH
75619: LD_VAR 0 7
75623: PPUSH
75624: CALL_OW 250
75628: PUSH
75629: LD_VAR 0 7
75633: PPUSH
75634: CALL_OW 251
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
75643: LD_INT 35
75645: PPUSH
75646: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
75650: LD_ADDR_VAR 0 4
75654: PUSH
75655: LD_EXP 95
75659: PUSH
75660: LD_VAR 0 2
75664: ARRAY
75665: PUSH
75666: LD_VAR 0 3
75670: ARRAY
75671: PUSH
75672: LD_INT 1
75674: ARRAY
75675: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
75676: LD_ADDR_VAR 0 5
75680: PUSH
75681: LD_EXP 95
75685: PUSH
75686: LD_VAR 0 2
75690: ARRAY
75691: PUSH
75692: LD_VAR 0 3
75696: ARRAY
75697: PUSH
75698: LD_INT 2
75700: ARRAY
75701: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
75702: LD_VAR 0 7
75706: PPUSH
75707: LD_INT 10
75709: PPUSH
75710: CALL 22400 0 2
75714: PUSH
75715: LD_INT 4
75717: ARRAY
75718: IFFALSE 75756
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
75720: LD_VAR 0 7
75724: PPUSH
75725: LD_VAR 0 6
75729: PUSH
75730: LD_INT 1
75732: ARRAY
75733: PPUSH
75734: LD_VAR 0 6
75738: PUSH
75739: LD_INT 2
75741: ARRAY
75742: PPUSH
75743: CALL_OW 111
// wait ( 0 0$10 ) ;
75747: LD_INT 350
75749: PPUSH
75750: CALL_OW 67
// end else
75754: GO 75782
// begin ComMoveXY ( tmp , x , y ) ;
75756: LD_VAR 0 7
75760: PPUSH
75761: LD_VAR 0 4
75765: PPUSH
75766: LD_VAR 0 5
75770: PPUSH
75771: CALL_OW 111
// wait ( 0 0$3 ) ;
75775: LD_INT 105
75777: PPUSH
75778: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
75782: LD_VAR 0 7
75786: PPUSH
75787: LD_VAR 0 4
75791: PPUSH
75792: LD_VAR 0 5
75796: PPUSH
75797: CALL_OW 307
75801: IFFALSE 75643
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
75803: LD_VAR 0 7
75807: PPUSH
75808: LD_VAR 0 4
75812: PPUSH
75813: LD_VAR 0 5
75817: PPUSH
75818: LD_VAR 0 8
75822: PUSH
75823: LD_VAR 0 3
75827: ARRAY
75828: PPUSH
75829: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
75833: LD_INT 35
75835: PPUSH
75836: CALL_OW 67
// until not HasTask ( tmp ) ;
75840: LD_VAR 0 7
75844: PPUSH
75845: CALL_OW 314
75849: NOT
75850: IFFALSE 75833
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
75852: LD_ADDR_EXP 96
75856: PUSH
75857: LD_EXP 96
75861: PPUSH
75862: LD_VAR 0 2
75866: PUSH
75867: LD_EXP 96
75871: PUSH
75872: LD_VAR 0 2
75876: ARRAY
75877: PUSH
75878: LD_INT 1
75880: PLUS
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PPUSH
75886: LD_VAR 0 8
75890: PUSH
75891: LD_VAR 0 3
75895: ARRAY
75896: PPUSH
75897: CALL 19801 0 3
75901: ST_TO_ADDR
// end ;
75902: GO 75560
75904: POP
75905: POP
// MC_Reset ( i , 124 ) ;
75906: LD_VAR 0 2
75910: PPUSH
75911: LD_INT 124
75913: PPUSH
75914: CALL 59060 0 2
// end ; end ;
75918: GO 75315
75920: POP
75921: POP
// end ;
75922: LD_VAR 0 1
75926: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
75927: LD_INT 0
75929: PPUSH
75930: PPUSH
75931: PPUSH
// if not mc_bases then
75932: LD_EXP 60
75936: NOT
75937: IFFALSE 75941
// exit ;
75939: GO 76547
// for i = 1 to mc_bases do
75941: LD_ADDR_VAR 0 2
75945: PUSH
75946: DOUBLE
75947: LD_INT 1
75949: DEC
75950: ST_TO_ADDR
75951: LD_EXP 60
75955: PUSH
75956: FOR_TO
75957: IFFALSE 76545
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
75959: LD_ADDR_VAR 0 3
75963: PUSH
75964: LD_EXP 60
75968: PUSH
75969: LD_VAR 0 2
75973: ARRAY
75974: PPUSH
75975: LD_INT 25
75977: PUSH
75978: LD_INT 4
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PPUSH
75985: CALL_OW 72
75989: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
75990: LD_VAR 0 3
75994: NOT
75995: PUSH
75996: LD_EXP 97
76000: PUSH
76001: LD_VAR 0 2
76005: ARRAY
76006: NOT
76007: OR
76008: PUSH
76009: LD_EXP 60
76013: PUSH
76014: LD_VAR 0 2
76018: ARRAY
76019: PPUSH
76020: LD_INT 2
76022: PUSH
76023: LD_INT 30
76025: PUSH
76026: LD_INT 0
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 30
76035: PUSH
76036: LD_INT 1
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: EMPTY
76044: LIST
76045: LIST
76046: LIST
76047: PPUSH
76048: CALL_OW 72
76052: NOT
76053: OR
76054: IFFALSE 76104
// begin if mc_deposits_finder [ i ] then
76056: LD_EXP 98
76060: PUSH
76061: LD_VAR 0 2
76065: ARRAY
76066: IFFALSE 76102
// begin MC_Reset ( i , 125 ) ;
76068: LD_VAR 0 2
76072: PPUSH
76073: LD_INT 125
76075: PPUSH
76076: CALL 59060 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76080: LD_ADDR_EXP 98
76084: PUSH
76085: LD_EXP 98
76089: PPUSH
76090: LD_VAR 0 2
76094: PPUSH
76095: EMPTY
76096: PPUSH
76097: CALL_OW 1
76101: ST_TO_ADDR
// end ; continue ;
76102: GO 75956
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76104: LD_EXP 97
76108: PUSH
76109: LD_VAR 0 2
76113: ARRAY
76114: PUSH
76115: LD_INT 1
76117: ARRAY
76118: PUSH
76119: LD_INT 3
76121: ARRAY
76122: PUSH
76123: LD_INT 1
76125: EQUAL
76126: PUSH
76127: LD_INT 20
76129: PPUSH
76130: LD_EXP 86
76134: PUSH
76135: LD_VAR 0 2
76139: ARRAY
76140: PPUSH
76141: CALL_OW 321
76145: PUSH
76146: LD_INT 2
76148: NONEQUAL
76149: AND
76150: IFFALSE 76200
// begin if mc_deposits_finder [ i ] then
76152: LD_EXP 98
76156: PUSH
76157: LD_VAR 0 2
76161: ARRAY
76162: IFFALSE 76198
// begin MC_Reset ( i , 125 ) ;
76164: LD_VAR 0 2
76168: PPUSH
76169: LD_INT 125
76171: PPUSH
76172: CALL 59060 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76176: LD_ADDR_EXP 98
76180: PUSH
76181: LD_EXP 98
76185: PPUSH
76186: LD_VAR 0 2
76190: PPUSH
76191: EMPTY
76192: PPUSH
76193: CALL_OW 1
76197: ST_TO_ADDR
// end ; continue ;
76198: GO 75956
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
76200: LD_EXP 97
76204: PUSH
76205: LD_VAR 0 2
76209: ARRAY
76210: PUSH
76211: LD_INT 1
76213: ARRAY
76214: PUSH
76215: LD_INT 1
76217: ARRAY
76218: PPUSH
76219: LD_EXP 97
76223: PUSH
76224: LD_VAR 0 2
76228: ARRAY
76229: PUSH
76230: LD_INT 1
76232: ARRAY
76233: PUSH
76234: LD_INT 2
76236: ARRAY
76237: PPUSH
76238: LD_EXP 86
76242: PUSH
76243: LD_VAR 0 2
76247: ARRAY
76248: PPUSH
76249: CALL_OW 440
76253: IFFALSE 76296
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
76255: LD_ADDR_EXP 97
76259: PUSH
76260: LD_EXP 97
76264: PPUSH
76265: LD_VAR 0 2
76269: PPUSH
76270: LD_EXP 97
76274: PUSH
76275: LD_VAR 0 2
76279: ARRAY
76280: PPUSH
76281: LD_INT 1
76283: PPUSH
76284: CALL_OW 3
76288: PPUSH
76289: CALL_OW 1
76293: ST_TO_ADDR
76294: GO 76543
// begin if not mc_deposits_finder [ i ] then
76296: LD_EXP 98
76300: PUSH
76301: LD_VAR 0 2
76305: ARRAY
76306: NOT
76307: IFFALSE 76359
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
76309: LD_ADDR_EXP 98
76313: PUSH
76314: LD_EXP 98
76318: PPUSH
76319: LD_VAR 0 2
76323: PPUSH
76324: LD_VAR 0 3
76328: PUSH
76329: LD_INT 1
76331: ARRAY
76332: PUSH
76333: EMPTY
76334: LIST
76335: PPUSH
76336: CALL_OW 1
76340: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
76341: LD_VAR 0 3
76345: PUSH
76346: LD_INT 1
76348: ARRAY
76349: PPUSH
76350: LD_INT 125
76352: PPUSH
76353: CALL_OW 109
// end else
76357: GO 76543
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
76359: LD_EXP 98
76363: PUSH
76364: LD_VAR 0 2
76368: ARRAY
76369: PUSH
76370: LD_INT 1
76372: ARRAY
76373: PPUSH
76374: CALL_OW 310
76378: IFFALSE 76401
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
76380: LD_EXP 98
76384: PUSH
76385: LD_VAR 0 2
76389: ARRAY
76390: PUSH
76391: LD_INT 1
76393: ARRAY
76394: PPUSH
76395: CALL_OW 122
76399: GO 76543
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
76401: LD_EXP 98
76405: PUSH
76406: LD_VAR 0 2
76410: ARRAY
76411: PUSH
76412: LD_INT 1
76414: ARRAY
76415: PPUSH
76416: CALL_OW 314
76420: NOT
76421: PUSH
76422: LD_EXP 98
76426: PUSH
76427: LD_VAR 0 2
76431: ARRAY
76432: PUSH
76433: LD_INT 1
76435: ARRAY
76436: PPUSH
76437: LD_EXP 97
76441: PUSH
76442: LD_VAR 0 2
76446: ARRAY
76447: PUSH
76448: LD_INT 1
76450: ARRAY
76451: PUSH
76452: LD_INT 1
76454: ARRAY
76455: PPUSH
76456: LD_EXP 97
76460: PUSH
76461: LD_VAR 0 2
76465: ARRAY
76466: PUSH
76467: LD_INT 1
76469: ARRAY
76470: PUSH
76471: LD_INT 2
76473: ARRAY
76474: PPUSH
76475: CALL_OW 297
76479: PUSH
76480: LD_INT 6
76482: GREATER
76483: AND
76484: IFFALSE 76543
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
76486: LD_EXP 98
76490: PUSH
76491: LD_VAR 0 2
76495: ARRAY
76496: PUSH
76497: LD_INT 1
76499: ARRAY
76500: PPUSH
76501: LD_EXP 97
76505: PUSH
76506: LD_VAR 0 2
76510: ARRAY
76511: PUSH
76512: LD_INT 1
76514: ARRAY
76515: PUSH
76516: LD_INT 1
76518: ARRAY
76519: PPUSH
76520: LD_EXP 97
76524: PUSH
76525: LD_VAR 0 2
76529: ARRAY
76530: PUSH
76531: LD_INT 1
76533: ARRAY
76534: PUSH
76535: LD_INT 2
76537: ARRAY
76538: PPUSH
76539: CALL_OW 111
// end ; end ; end ;
76543: GO 75956
76545: POP
76546: POP
// end ;
76547: LD_VAR 0 1
76551: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
76552: LD_INT 0
76554: PPUSH
76555: PPUSH
76556: PPUSH
76557: PPUSH
76558: PPUSH
76559: PPUSH
76560: PPUSH
76561: PPUSH
76562: PPUSH
76563: PPUSH
76564: PPUSH
// if not mc_bases then
76565: LD_EXP 60
76569: NOT
76570: IFFALSE 76574
// exit ;
76572: GO 77514
// for i = 1 to mc_bases do
76574: LD_ADDR_VAR 0 2
76578: PUSH
76579: DOUBLE
76580: LD_INT 1
76582: DEC
76583: ST_TO_ADDR
76584: LD_EXP 60
76588: PUSH
76589: FOR_TO
76590: IFFALSE 77512
// begin if not mc_bases [ i ] or mc_scan [ i ] then
76592: LD_EXP 60
76596: PUSH
76597: LD_VAR 0 2
76601: ARRAY
76602: NOT
76603: PUSH
76604: LD_EXP 83
76608: PUSH
76609: LD_VAR 0 2
76613: ARRAY
76614: OR
76615: IFFALSE 76619
// continue ;
76617: GO 76589
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
76619: LD_ADDR_VAR 0 7
76623: PUSH
76624: LD_EXP 60
76628: PUSH
76629: LD_VAR 0 2
76633: ARRAY
76634: PUSH
76635: LD_INT 1
76637: ARRAY
76638: PPUSH
76639: CALL_OW 248
76643: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
76644: LD_VAR 0 7
76648: PUSH
76649: LD_INT 3
76651: EQUAL
76652: PUSH
76653: LD_EXP 79
76657: PUSH
76658: LD_VAR 0 2
76662: ARRAY
76663: PUSH
76664: LD_EXP 82
76668: PUSH
76669: LD_VAR 0 2
76673: ARRAY
76674: UNION
76675: PPUSH
76676: LD_INT 33
76678: PUSH
76679: LD_INT 2
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PPUSH
76686: CALL_OW 72
76690: NOT
76691: OR
76692: IFFALSE 76696
// continue ;
76694: GO 76589
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
76696: LD_ADDR_VAR 0 9
76700: PUSH
76701: LD_EXP 60
76705: PUSH
76706: LD_VAR 0 2
76710: ARRAY
76711: PPUSH
76712: LD_INT 30
76714: PUSH
76715: LD_INT 36
76717: PUSH
76718: EMPTY
76719: LIST
76720: LIST
76721: PPUSH
76722: CALL_OW 72
76726: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
76727: LD_ADDR_VAR 0 10
76731: PUSH
76732: LD_EXP 79
76736: PUSH
76737: LD_VAR 0 2
76741: ARRAY
76742: PPUSH
76743: LD_INT 34
76745: PUSH
76746: LD_INT 31
76748: PUSH
76749: EMPTY
76750: LIST
76751: LIST
76752: PPUSH
76753: CALL_OW 72
76757: ST_TO_ADDR
// if not cts and not mcts then
76758: LD_VAR 0 9
76762: NOT
76763: PUSH
76764: LD_VAR 0 10
76768: NOT
76769: AND
76770: IFFALSE 76774
// continue ;
76772: GO 76589
// x := cts ;
76774: LD_ADDR_VAR 0 11
76778: PUSH
76779: LD_VAR 0 9
76783: ST_TO_ADDR
// if not x then
76784: LD_VAR 0 11
76788: NOT
76789: IFFALSE 76801
// x := mcts ;
76791: LD_ADDR_VAR 0 11
76795: PUSH
76796: LD_VAR 0 10
76800: ST_TO_ADDR
// if not x then
76801: LD_VAR 0 11
76805: NOT
76806: IFFALSE 76810
// continue ;
76808: GO 76589
// if mc_remote_driver [ i ] then
76810: LD_EXP 100
76814: PUSH
76815: LD_VAR 0 2
76819: ARRAY
76820: IFFALSE 77207
// for j in mc_remote_driver [ i ] do
76822: LD_ADDR_VAR 0 3
76826: PUSH
76827: LD_EXP 100
76831: PUSH
76832: LD_VAR 0 2
76836: ARRAY
76837: PUSH
76838: FOR_IN
76839: IFFALSE 77205
// begin if GetClass ( j ) <> 3 then
76841: LD_VAR 0 3
76845: PPUSH
76846: CALL_OW 257
76850: PUSH
76851: LD_INT 3
76853: NONEQUAL
76854: IFFALSE 76907
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
76856: LD_ADDR_EXP 100
76860: PUSH
76861: LD_EXP 100
76865: PPUSH
76866: LD_VAR 0 2
76870: PPUSH
76871: LD_EXP 100
76875: PUSH
76876: LD_VAR 0 2
76880: ARRAY
76881: PUSH
76882: LD_VAR 0 3
76886: DIFF
76887: PPUSH
76888: CALL_OW 1
76892: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76893: LD_VAR 0 3
76897: PPUSH
76898: LD_INT 0
76900: PPUSH
76901: CALL_OW 109
// continue ;
76905: GO 76838
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
76907: LD_EXP 79
76911: PUSH
76912: LD_VAR 0 2
76916: ARRAY
76917: PPUSH
76918: LD_INT 34
76920: PUSH
76921: LD_INT 31
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 58
76930: PUSH
76931: EMPTY
76932: LIST
76933: PUSH
76934: EMPTY
76935: LIST
76936: LIST
76937: PPUSH
76938: CALL_OW 72
76942: PUSH
76943: LD_VAR 0 3
76947: PPUSH
76948: CALL 49158 0 1
76952: NOT
76953: AND
76954: IFFALSE 77025
// begin if IsInUnit ( j ) then
76956: LD_VAR 0 3
76960: PPUSH
76961: CALL_OW 310
76965: IFFALSE 76976
// ComExitBuilding ( j ) ;
76967: LD_VAR 0 3
76971: PPUSH
76972: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
76976: LD_VAR 0 3
76980: PPUSH
76981: LD_EXP 79
76985: PUSH
76986: LD_VAR 0 2
76990: ARRAY
76991: PPUSH
76992: LD_INT 34
76994: PUSH
76995: LD_INT 31
76997: PUSH
76998: EMPTY
76999: LIST
77000: LIST
77001: PUSH
77002: LD_INT 58
77004: PUSH
77005: EMPTY
77006: LIST
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PPUSH
77012: CALL_OW 72
77016: PUSH
77017: LD_INT 1
77019: ARRAY
77020: PPUSH
77021: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77025: LD_VAR 0 3
77029: PPUSH
77030: CALL_OW 310
77034: NOT
77035: PUSH
77036: LD_VAR 0 3
77040: PPUSH
77041: CALL_OW 310
77045: PPUSH
77046: CALL_OW 266
77050: PUSH
77051: LD_INT 36
77053: NONEQUAL
77054: PUSH
77055: LD_VAR 0 3
77059: PPUSH
77060: CALL 49158 0 1
77064: NOT
77065: AND
77066: OR
77067: IFFALSE 77203
// begin if IsInUnit ( j ) then
77069: LD_VAR 0 3
77073: PPUSH
77074: CALL_OW 310
77078: IFFALSE 77089
// ComExitBuilding ( j ) ;
77080: LD_VAR 0 3
77084: PPUSH
77085: CALL_OW 122
// ct := 0 ;
77089: LD_ADDR_VAR 0 8
77093: PUSH
77094: LD_INT 0
77096: ST_TO_ADDR
// for k in x do
77097: LD_ADDR_VAR 0 4
77101: PUSH
77102: LD_VAR 0 11
77106: PUSH
77107: FOR_IN
77108: IFFALSE 77181
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77110: LD_VAR 0 4
77114: PPUSH
77115: CALL_OW 264
77119: PUSH
77120: LD_INT 31
77122: EQUAL
77123: PUSH
77124: LD_VAR 0 4
77128: PPUSH
77129: CALL_OW 311
77133: NOT
77134: AND
77135: PUSH
77136: LD_VAR 0 4
77140: PPUSH
77141: CALL_OW 266
77145: PUSH
77146: LD_INT 36
77148: EQUAL
77149: PUSH
77150: LD_VAR 0 4
77154: PPUSH
77155: CALL_OW 313
77159: PUSH
77160: LD_INT 3
77162: LESS
77163: AND
77164: OR
77165: IFFALSE 77179
// begin ct := k ;
77167: LD_ADDR_VAR 0 8
77171: PUSH
77172: LD_VAR 0 4
77176: ST_TO_ADDR
// break ;
77177: GO 77181
// end ;
77179: GO 77107
77181: POP
77182: POP
// if ct then
77183: LD_VAR 0 8
77187: IFFALSE 77203
// ComEnterUnit ( j , ct ) ;
77189: LD_VAR 0 3
77193: PPUSH
77194: LD_VAR 0 8
77198: PPUSH
77199: CALL_OW 120
// end ; end ;
77203: GO 76838
77205: POP
77206: POP
// places := 0 ;
77207: LD_ADDR_VAR 0 5
77211: PUSH
77212: LD_INT 0
77214: ST_TO_ADDR
// for j = 1 to x do
77215: LD_ADDR_VAR 0 3
77219: PUSH
77220: DOUBLE
77221: LD_INT 1
77223: DEC
77224: ST_TO_ADDR
77225: LD_VAR 0 11
77229: PUSH
77230: FOR_TO
77231: IFFALSE 77307
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77233: LD_VAR 0 11
77237: PUSH
77238: LD_VAR 0 3
77242: ARRAY
77243: PPUSH
77244: CALL_OW 264
77248: PUSH
77249: LD_INT 31
77251: EQUAL
77252: IFFALSE 77270
// places := places + 1 else
77254: LD_ADDR_VAR 0 5
77258: PUSH
77259: LD_VAR 0 5
77263: PUSH
77264: LD_INT 1
77266: PLUS
77267: ST_TO_ADDR
77268: GO 77305
// if GetBType ( x [ j ] ) = b_control_tower then
77270: LD_VAR 0 11
77274: PUSH
77275: LD_VAR 0 3
77279: ARRAY
77280: PPUSH
77281: CALL_OW 266
77285: PUSH
77286: LD_INT 36
77288: EQUAL
77289: IFFALSE 77305
// places := places + 3 ;
77291: LD_ADDR_VAR 0 5
77295: PUSH
77296: LD_VAR 0 5
77300: PUSH
77301: LD_INT 3
77303: PLUS
77304: ST_TO_ADDR
77305: GO 77230
77307: POP
77308: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
77309: LD_VAR 0 5
77313: PUSH
77314: LD_INT 0
77316: EQUAL
77317: PUSH
77318: LD_VAR 0 5
77322: PUSH
77323: LD_EXP 100
77327: PUSH
77328: LD_VAR 0 2
77332: ARRAY
77333: LESSEQUAL
77334: OR
77335: IFFALSE 77339
// continue ;
77337: GO 76589
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
77339: LD_ADDR_VAR 0 6
77343: PUSH
77344: LD_EXP 60
77348: PUSH
77349: LD_VAR 0 2
77353: ARRAY
77354: PPUSH
77355: LD_INT 25
77357: PUSH
77358: LD_INT 3
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PPUSH
77365: CALL_OW 72
77369: PUSH
77370: LD_EXP 100
77374: PUSH
77375: LD_VAR 0 2
77379: ARRAY
77380: DIFF
77381: PPUSH
77382: LD_INT 3
77384: PPUSH
77385: CALL 50058 0 2
77389: ST_TO_ADDR
// for j in tmp do
77390: LD_ADDR_VAR 0 3
77394: PUSH
77395: LD_VAR 0 6
77399: PUSH
77400: FOR_IN
77401: IFFALSE 77436
// if GetTag ( j ) > 0 then
77403: LD_VAR 0 3
77407: PPUSH
77408: CALL_OW 110
77412: PUSH
77413: LD_INT 0
77415: GREATER
77416: IFFALSE 77434
// tmp := tmp diff j ;
77418: LD_ADDR_VAR 0 6
77422: PUSH
77423: LD_VAR 0 6
77427: PUSH
77428: LD_VAR 0 3
77432: DIFF
77433: ST_TO_ADDR
77434: GO 77400
77436: POP
77437: POP
// if not tmp then
77438: LD_VAR 0 6
77442: NOT
77443: IFFALSE 77447
// continue ;
77445: GO 76589
// if places then
77447: LD_VAR 0 5
77451: IFFALSE 77510
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
77453: LD_ADDR_EXP 100
77457: PUSH
77458: LD_EXP 100
77462: PPUSH
77463: LD_VAR 0 2
77467: PPUSH
77468: LD_EXP 100
77472: PUSH
77473: LD_VAR 0 2
77477: ARRAY
77478: PUSH
77479: LD_VAR 0 6
77483: PUSH
77484: LD_INT 1
77486: ARRAY
77487: UNION
77488: PPUSH
77489: CALL_OW 1
77493: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
77494: LD_VAR 0 6
77498: PUSH
77499: LD_INT 1
77501: ARRAY
77502: PPUSH
77503: LD_INT 126
77505: PPUSH
77506: CALL_OW 109
// end ; end ;
77510: GO 76589
77512: POP
77513: POP
// end ;
77514: LD_VAR 0 1
77518: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
77519: LD_INT 0
77521: PPUSH
77522: PPUSH
77523: PPUSH
77524: PPUSH
77525: PPUSH
77526: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
77527: LD_VAR 0 1
77531: NOT
77532: PUSH
77533: LD_VAR 0 2
77537: NOT
77538: OR
77539: PUSH
77540: LD_VAR 0 3
77544: NOT
77545: OR
77546: PUSH
77547: LD_VAR 0 4
77551: PUSH
77552: LD_INT 1
77554: PUSH
77555: LD_INT 2
77557: PUSH
77558: LD_INT 3
77560: PUSH
77561: LD_INT 4
77563: PUSH
77564: LD_INT 5
77566: PUSH
77567: LD_INT 8
77569: PUSH
77570: LD_INT 9
77572: PUSH
77573: LD_INT 15
77575: PUSH
77576: LD_INT 16
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: IN
77590: NOT
77591: OR
77592: IFFALSE 77596
// exit ;
77594: GO 78496
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
77596: LD_ADDR_VAR 0 2
77600: PUSH
77601: LD_VAR 0 2
77605: PPUSH
77606: LD_INT 21
77608: PUSH
77609: LD_INT 3
77611: PUSH
77612: EMPTY
77613: LIST
77614: LIST
77615: PUSH
77616: LD_INT 24
77618: PUSH
77619: LD_INT 250
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: PUSH
77626: EMPTY
77627: LIST
77628: LIST
77629: PPUSH
77630: CALL_OW 72
77634: ST_TO_ADDR
// case class of 1 , 15 :
77635: LD_VAR 0 4
77639: PUSH
77640: LD_INT 1
77642: DOUBLE
77643: EQUAL
77644: IFTRUE 77654
77646: LD_INT 15
77648: DOUBLE
77649: EQUAL
77650: IFTRUE 77654
77652: GO 77739
77654: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
77655: LD_ADDR_VAR 0 8
77659: PUSH
77660: LD_VAR 0 2
77664: PPUSH
77665: LD_INT 2
77667: PUSH
77668: LD_INT 30
77670: PUSH
77671: LD_INT 32
77673: PUSH
77674: EMPTY
77675: LIST
77676: LIST
77677: PUSH
77678: LD_INT 30
77680: PUSH
77681: LD_INT 31
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: EMPTY
77689: LIST
77690: LIST
77691: LIST
77692: PPUSH
77693: CALL_OW 72
77697: PUSH
77698: LD_VAR 0 2
77702: PPUSH
77703: LD_INT 2
77705: PUSH
77706: LD_INT 30
77708: PUSH
77709: LD_INT 4
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 30
77718: PUSH
77719: LD_INT 5
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: LIST
77730: PPUSH
77731: CALL_OW 72
77735: ADD
77736: ST_TO_ADDR
77737: GO 77985
77739: LD_INT 2
77741: DOUBLE
77742: EQUAL
77743: IFTRUE 77753
77745: LD_INT 16
77747: DOUBLE
77748: EQUAL
77749: IFTRUE 77753
77751: GO 77799
77753: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
77754: LD_ADDR_VAR 0 8
77758: PUSH
77759: LD_VAR 0 2
77763: PPUSH
77764: LD_INT 2
77766: PUSH
77767: LD_INT 30
77769: PUSH
77770: LD_INT 0
77772: PUSH
77773: EMPTY
77774: LIST
77775: LIST
77776: PUSH
77777: LD_INT 30
77779: PUSH
77780: LD_INT 1
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: LIST
77791: PPUSH
77792: CALL_OW 72
77796: ST_TO_ADDR
77797: GO 77985
77799: LD_INT 3
77801: DOUBLE
77802: EQUAL
77803: IFTRUE 77807
77805: GO 77853
77807: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
77808: LD_ADDR_VAR 0 8
77812: PUSH
77813: LD_VAR 0 2
77817: PPUSH
77818: LD_INT 2
77820: PUSH
77821: LD_INT 30
77823: PUSH
77824: LD_INT 2
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 30
77833: PUSH
77834: LD_INT 3
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: EMPTY
77842: LIST
77843: LIST
77844: LIST
77845: PPUSH
77846: CALL_OW 72
77850: ST_TO_ADDR
77851: GO 77985
77853: LD_INT 4
77855: DOUBLE
77856: EQUAL
77857: IFTRUE 77861
77859: GO 77918
77861: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
77862: LD_ADDR_VAR 0 8
77866: PUSH
77867: LD_VAR 0 2
77871: PPUSH
77872: LD_INT 2
77874: PUSH
77875: LD_INT 30
77877: PUSH
77878: LD_INT 6
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PUSH
77885: LD_INT 30
77887: PUSH
77888: LD_INT 7
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 30
77897: PUSH
77898: LD_INT 8
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: EMPTY
77906: LIST
77907: LIST
77908: LIST
77909: LIST
77910: PPUSH
77911: CALL_OW 72
77915: ST_TO_ADDR
77916: GO 77985
77918: LD_INT 5
77920: DOUBLE
77921: EQUAL
77922: IFTRUE 77938
77924: LD_INT 8
77926: DOUBLE
77927: EQUAL
77928: IFTRUE 77938
77930: LD_INT 9
77932: DOUBLE
77933: EQUAL
77934: IFTRUE 77938
77936: GO 77984
77938: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
77939: LD_ADDR_VAR 0 8
77943: PUSH
77944: LD_VAR 0 2
77948: PPUSH
77949: LD_INT 2
77951: PUSH
77952: LD_INT 30
77954: PUSH
77955: LD_INT 4
77957: PUSH
77958: EMPTY
77959: LIST
77960: LIST
77961: PUSH
77962: LD_INT 30
77964: PUSH
77965: LD_INT 5
77967: PUSH
77968: EMPTY
77969: LIST
77970: LIST
77971: PUSH
77972: EMPTY
77973: LIST
77974: LIST
77975: LIST
77976: PPUSH
77977: CALL_OW 72
77981: ST_TO_ADDR
77982: GO 77985
77984: POP
// if not tmp then
77985: LD_VAR 0 8
77989: NOT
77990: IFFALSE 77994
// exit ;
77992: GO 78496
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
77994: LD_VAR 0 4
77998: PUSH
77999: LD_INT 1
78001: PUSH
78002: LD_INT 15
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: IN
78009: PUSH
78010: LD_EXP 69
78014: PUSH
78015: LD_VAR 0 1
78019: ARRAY
78020: AND
78021: IFFALSE 78177
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78023: LD_ADDR_VAR 0 9
78027: PUSH
78028: LD_EXP 69
78032: PUSH
78033: LD_VAR 0 1
78037: ARRAY
78038: PUSH
78039: LD_INT 1
78041: ARRAY
78042: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78043: LD_VAR 0 9
78047: PUSH
78048: LD_EXP 70
78052: PUSH
78053: LD_VAR 0 1
78057: ARRAY
78058: IN
78059: NOT
78060: IFFALSE 78175
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78062: LD_ADDR_EXP 70
78066: PUSH
78067: LD_EXP 70
78071: PPUSH
78072: LD_VAR 0 1
78076: PUSH
78077: LD_EXP 70
78081: PUSH
78082: LD_VAR 0 1
78086: ARRAY
78087: PUSH
78088: LD_INT 1
78090: PLUS
78091: PUSH
78092: EMPTY
78093: LIST
78094: LIST
78095: PPUSH
78096: LD_VAR 0 9
78100: PPUSH
78101: CALL 19801 0 3
78105: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78106: LD_ADDR_EXP 69
78110: PUSH
78111: LD_EXP 69
78115: PPUSH
78116: LD_VAR 0 1
78120: PPUSH
78121: LD_EXP 69
78125: PUSH
78126: LD_VAR 0 1
78130: ARRAY
78131: PUSH
78132: LD_VAR 0 9
78136: DIFF
78137: PPUSH
78138: CALL_OW 1
78142: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78143: LD_VAR 0 3
78147: PPUSH
78148: LD_EXP 70
78152: PUSH
78153: LD_VAR 0 1
78157: ARRAY
78158: PUSH
78159: LD_EXP 70
78163: PUSH
78164: LD_VAR 0 1
78168: ARRAY
78169: ARRAY
78170: PPUSH
78171: CALL_OW 120
// end ; exit ;
78175: GO 78496
// end ; if tmp > 1 then
78177: LD_VAR 0 8
78181: PUSH
78182: LD_INT 1
78184: GREATER
78185: IFFALSE 78289
// for i = 2 to tmp do
78187: LD_ADDR_VAR 0 6
78191: PUSH
78192: DOUBLE
78193: LD_INT 2
78195: DEC
78196: ST_TO_ADDR
78197: LD_VAR 0 8
78201: PUSH
78202: FOR_TO
78203: IFFALSE 78287
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78205: LD_VAR 0 8
78209: PUSH
78210: LD_VAR 0 6
78214: ARRAY
78215: PPUSH
78216: CALL_OW 461
78220: PUSH
78221: LD_INT 6
78223: EQUAL
78224: IFFALSE 78285
// begin x := tmp [ i ] ;
78226: LD_ADDR_VAR 0 9
78230: PUSH
78231: LD_VAR 0 8
78235: PUSH
78236: LD_VAR 0 6
78240: ARRAY
78241: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78242: LD_ADDR_VAR 0 8
78246: PUSH
78247: LD_VAR 0 8
78251: PPUSH
78252: LD_VAR 0 6
78256: PPUSH
78257: CALL_OW 3
78261: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78262: LD_ADDR_VAR 0 8
78266: PUSH
78267: LD_VAR 0 8
78271: PPUSH
78272: LD_INT 1
78274: PPUSH
78275: LD_VAR 0 9
78279: PPUSH
78280: CALL_OW 2
78284: ST_TO_ADDR
// end ;
78285: GO 78202
78287: POP
78288: POP
// for i in tmp do
78289: LD_ADDR_VAR 0 6
78293: PUSH
78294: LD_VAR 0 8
78298: PUSH
78299: FOR_IN
78300: IFFALSE 78369
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78302: LD_VAR 0 6
78306: PPUSH
78307: CALL_OW 313
78311: PUSH
78312: LD_INT 6
78314: LESS
78315: PUSH
78316: LD_VAR 0 6
78320: PPUSH
78321: CALL_OW 266
78325: PUSH
78326: LD_INT 31
78328: PUSH
78329: LD_INT 32
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: IN
78336: NOT
78337: AND
78338: PUSH
78339: LD_VAR 0 6
78343: PPUSH
78344: CALL_OW 313
78348: PUSH
78349: LD_INT 0
78351: EQUAL
78352: OR
78353: IFFALSE 78367
// begin j := i ;
78355: LD_ADDR_VAR 0 7
78359: PUSH
78360: LD_VAR 0 6
78364: ST_TO_ADDR
// break ;
78365: GO 78369
// end ; end ;
78367: GO 78299
78369: POP
78370: POP
// if j then
78371: LD_VAR 0 7
78375: IFFALSE 78393
// ComEnterUnit ( unit , j ) else
78377: LD_VAR 0 3
78381: PPUSH
78382: LD_VAR 0 7
78386: PPUSH
78387: CALL_OW 120
78391: GO 78496
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78393: LD_ADDR_VAR 0 10
78397: PUSH
78398: LD_VAR 0 2
78402: PPUSH
78403: LD_INT 2
78405: PUSH
78406: LD_INT 30
78408: PUSH
78409: LD_INT 0
78411: PUSH
78412: EMPTY
78413: LIST
78414: LIST
78415: PUSH
78416: LD_INT 30
78418: PUSH
78419: LD_INT 1
78421: PUSH
78422: EMPTY
78423: LIST
78424: LIST
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: LIST
78430: PPUSH
78431: CALL_OW 72
78435: ST_TO_ADDR
// if depot then
78436: LD_VAR 0 10
78440: IFFALSE 78496
// begin depot := NearestUnitToUnit ( depot , unit ) ;
78442: LD_ADDR_VAR 0 10
78446: PUSH
78447: LD_VAR 0 10
78451: PPUSH
78452: LD_VAR 0 3
78456: PPUSH
78457: CALL_OW 74
78461: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
78462: LD_VAR 0 3
78466: PPUSH
78467: LD_VAR 0 10
78471: PPUSH
78472: CALL_OW 296
78476: PUSH
78477: LD_INT 10
78479: GREATER
78480: IFFALSE 78496
// ComStandNearbyBuilding ( unit , depot ) ;
78482: LD_VAR 0 3
78486: PPUSH
78487: LD_VAR 0 10
78491: PPUSH
78492: CALL 16379 0 2
// end ; end ; end ;
78496: LD_VAR 0 5
78500: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
78501: LD_INT 0
78503: PPUSH
78504: PPUSH
78505: PPUSH
78506: PPUSH
// if not mc_bases then
78507: LD_EXP 60
78511: NOT
78512: IFFALSE 78516
// exit ;
78514: GO 78755
// for i = 1 to mc_bases do
78516: LD_ADDR_VAR 0 2
78520: PUSH
78521: DOUBLE
78522: LD_INT 1
78524: DEC
78525: ST_TO_ADDR
78526: LD_EXP 60
78530: PUSH
78531: FOR_TO
78532: IFFALSE 78753
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
78534: LD_ADDR_VAR 0 4
78538: PUSH
78539: LD_EXP 60
78543: PUSH
78544: LD_VAR 0 2
78548: ARRAY
78549: PPUSH
78550: LD_INT 21
78552: PUSH
78553: LD_INT 1
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PPUSH
78560: CALL_OW 72
78564: PUSH
78565: LD_EXP 89
78569: PUSH
78570: LD_VAR 0 2
78574: ARRAY
78575: UNION
78576: ST_TO_ADDR
// if not tmp then
78577: LD_VAR 0 4
78581: NOT
78582: IFFALSE 78586
// continue ;
78584: GO 78531
// for j in tmp do
78586: LD_ADDR_VAR 0 3
78590: PUSH
78591: LD_VAR 0 4
78595: PUSH
78596: FOR_IN
78597: IFFALSE 78749
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
78599: LD_VAR 0 3
78603: PPUSH
78604: CALL_OW 110
78608: NOT
78609: PUSH
78610: LD_VAR 0 3
78614: PPUSH
78615: CALL_OW 314
78619: NOT
78620: AND
78621: PUSH
78622: LD_VAR 0 3
78626: PPUSH
78627: CALL_OW 311
78631: NOT
78632: AND
78633: PUSH
78634: LD_VAR 0 3
78638: PPUSH
78639: CALL_OW 310
78643: NOT
78644: AND
78645: PUSH
78646: LD_VAR 0 3
78650: PUSH
78651: LD_EXP 63
78655: PUSH
78656: LD_VAR 0 2
78660: ARRAY
78661: PUSH
78662: LD_INT 1
78664: ARRAY
78665: IN
78666: NOT
78667: AND
78668: PUSH
78669: LD_VAR 0 3
78673: PUSH
78674: LD_EXP 63
78678: PUSH
78679: LD_VAR 0 2
78683: ARRAY
78684: PUSH
78685: LD_INT 2
78687: ARRAY
78688: IN
78689: NOT
78690: AND
78691: PUSH
78692: LD_VAR 0 3
78696: PUSH
78697: LD_EXP 72
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: IN
78708: NOT
78709: AND
78710: IFFALSE 78747
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
78712: LD_VAR 0 2
78716: PPUSH
78717: LD_EXP 60
78721: PUSH
78722: LD_VAR 0 2
78726: ARRAY
78727: PPUSH
78728: LD_VAR 0 3
78732: PPUSH
78733: LD_VAR 0 3
78737: PPUSH
78738: CALL_OW 257
78742: PPUSH
78743: CALL 77519 0 4
// end ;
78747: GO 78596
78749: POP
78750: POP
// end ;
78751: GO 78531
78753: POP
78754: POP
// end ;
78755: LD_VAR 0 1
78759: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
78760: LD_INT 0
78762: PPUSH
78763: PPUSH
78764: PPUSH
78765: PPUSH
78766: PPUSH
78767: PPUSH
// if not mc_bases [ base ] then
78768: LD_EXP 60
78772: PUSH
78773: LD_VAR 0 1
78777: ARRAY
78778: NOT
78779: IFFALSE 78783
// exit ;
78781: GO 78965
// tmp := [ ] ;
78783: LD_ADDR_VAR 0 6
78787: PUSH
78788: EMPTY
78789: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
78790: LD_ADDR_VAR 0 7
78794: PUSH
78795: LD_VAR 0 3
78799: PPUSH
78800: LD_INT 0
78802: PPUSH
78803: CALL_OW 517
78807: ST_TO_ADDR
// if not list then
78808: LD_VAR 0 7
78812: NOT
78813: IFFALSE 78817
// exit ;
78815: GO 78965
// for i = 1 to amount do
78817: LD_ADDR_VAR 0 5
78821: PUSH
78822: DOUBLE
78823: LD_INT 1
78825: DEC
78826: ST_TO_ADDR
78827: LD_VAR 0 2
78831: PUSH
78832: FOR_TO
78833: IFFALSE 78913
// begin x := rand ( 1 , list [ 1 ] ) ;
78835: LD_ADDR_VAR 0 8
78839: PUSH
78840: LD_INT 1
78842: PPUSH
78843: LD_VAR 0 7
78847: PUSH
78848: LD_INT 1
78850: ARRAY
78851: PPUSH
78852: CALL_OW 12
78856: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
78857: LD_ADDR_VAR 0 6
78861: PUSH
78862: LD_VAR 0 6
78866: PPUSH
78867: LD_VAR 0 5
78871: PPUSH
78872: LD_VAR 0 7
78876: PUSH
78877: LD_INT 1
78879: ARRAY
78880: PUSH
78881: LD_VAR 0 8
78885: ARRAY
78886: PUSH
78887: LD_VAR 0 7
78891: PUSH
78892: LD_INT 2
78894: ARRAY
78895: PUSH
78896: LD_VAR 0 8
78900: ARRAY
78901: PUSH
78902: EMPTY
78903: LIST
78904: LIST
78905: PPUSH
78906: CALL_OW 1
78910: ST_TO_ADDR
// end ;
78911: GO 78832
78913: POP
78914: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
78915: LD_ADDR_EXP 73
78919: PUSH
78920: LD_EXP 73
78924: PPUSH
78925: LD_VAR 0 1
78929: PPUSH
78930: LD_VAR 0 6
78934: PPUSH
78935: CALL_OW 1
78939: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
78940: LD_ADDR_EXP 75
78944: PUSH
78945: LD_EXP 75
78949: PPUSH
78950: LD_VAR 0 1
78954: PPUSH
78955: LD_VAR 0 3
78959: PPUSH
78960: CALL_OW 1
78964: ST_TO_ADDR
// end ;
78965: LD_VAR 0 4
78969: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
78970: LD_INT 0
78972: PPUSH
// if not mc_bases [ base ] then
78973: LD_EXP 60
78977: PUSH
78978: LD_VAR 0 1
78982: ARRAY
78983: NOT
78984: IFFALSE 78988
// exit ;
78986: GO 79013
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
78988: LD_ADDR_EXP 65
78992: PUSH
78993: LD_EXP 65
78997: PPUSH
78998: LD_VAR 0 1
79002: PPUSH
79003: LD_VAR 0 2
79007: PPUSH
79008: CALL_OW 1
79012: ST_TO_ADDR
// end ;
79013: LD_VAR 0 3
79017: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79018: LD_INT 0
79020: PPUSH
// if not mc_bases [ base ] then
79021: LD_EXP 60
79025: PUSH
79026: LD_VAR 0 1
79030: ARRAY
79031: NOT
79032: IFFALSE 79036
// exit ;
79034: GO 79073
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79036: LD_ADDR_EXP 65
79040: PUSH
79041: LD_EXP 65
79045: PPUSH
79046: LD_VAR 0 1
79050: PPUSH
79051: LD_EXP 65
79055: PUSH
79056: LD_VAR 0 1
79060: ARRAY
79061: PUSH
79062: LD_VAR 0 2
79066: UNION
79067: PPUSH
79068: CALL_OW 1
79072: ST_TO_ADDR
// end ;
79073: LD_VAR 0 3
79077: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79078: LD_INT 0
79080: PPUSH
// if not mc_bases [ base ] then
79081: LD_EXP 60
79085: PUSH
79086: LD_VAR 0 1
79090: ARRAY
79091: NOT
79092: IFFALSE 79096
// exit ;
79094: GO 79121
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79096: LD_ADDR_EXP 81
79100: PUSH
79101: LD_EXP 81
79105: PPUSH
79106: LD_VAR 0 1
79110: PPUSH
79111: LD_VAR 0 2
79115: PPUSH
79116: CALL_OW 1
79120: ST_TO_ADDR
// end ;
79121: LD_VAR 0 3
79125: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79126: LD_INT 0
79128: PPUSH
// if not mc_bases [ base ] then
79129: LD_EXP 60
79133: PUSH
79134: LD_VAR 0 1
79138: ARRAY
79139: NOT
79140: IFFALSE 79144
// exit ;
79142: GO 79181
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79144: LD_ADDR_EXP 81
79148: PUSH
79149: LD_EXP 81
79153: PPUSH
79154: LD_VAR 0 1
79158: PPUSH
79159: LD_EXP 81
79163: PUSH
79164: LD_VAR 0 1
79168: ARRAY
79169: PUSH
79170: LD_VAR 0 2
79174: ADD
79175: PPUSH
79176: CALL_OW 1
79180: ST_TO_ADDR
// end ;
79181: LD_VAR 0 3
79185: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79186: LD_INT 0
79188: PPUSH
// if not mc_bases [ base ] then
79189: LD_EXP 60
79193: PUSH
79194: LD_VAR 0 1
79198: ARRAY
79199: NOT
79200: IFFALSE 79204
// exit ;
79202: GO 79258
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79204: LD_ADDR_EXP 82
79208: PUSH
79209: LD_EXP 82
79213: PPUSH
79214: LD_VAR 0 1
79218: PPUSH
79219: LD_VAR 0 2
79223: PPUSH
79224: CALL_OW 1
79228: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79229: LD_ADDR_EXP 71
79233: PUSH
79234: LD_EXP 71
79238: PPUSH
79239: LD_VAR 0 1
79243: PPUSH
79244: LD_VAR 0 2
79248: PUSH
79249: LD_INT 0
79251: PLUS
79252: PPUSH
79253: CALL_OW 1
79257: ST_TO_ADDR
// end ;
79258: LD_VAR 0 3
79262: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79263: LD_INT 0
79265: PPUSH
// if not mc_bases [ base ] then
79266: LD_EXP 60
79270: PUSH
79271: LD_VAR 0 1
79275: ARRAY
79276: NOT
79277: IFFALSE 79281
// exit ;
79279: GO 79306
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79281: LD_ADDR_EXP 71
79285: PUSH
79286: LD_EXP 71
79290: PPUSH
79291: LD_VAR 0 1
79295: PPUSH
79296: LD_VAR 0 2
79300: PPUSH
79301: CALL_OW 1
79305: ST_TO_ADDR
// end ;
79306: LD_VAR 0 3
79310: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79311: LD_INT 0
79313: PPUSH
79314: PPUSH
79315: PPUSH
79316: PPUSH
// if not mc_bases [ base ] then
79317: LD_EXP 60
79321: PUSH
79322: LD_VAR 0 1
79326: ARRAY
79327: NOT
79328: IFFALSE 79332
// exit ;
79330: GO 79397
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79332: LD_ADDR_EXP 80
79336: PUSH
79337: LD_EXP 80
79341: PPUSH
79342: LD_VAR 0 1
79346: PUSH
79347: LD_EXP 80
79351: PUSH
79352: LD_VAR 0 1
79356: ARRAY
79357: PUSH
79358: LD_INT 1
79360: PLUS
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PPUSH
79366: LD_VAR 0 1
79370: PUSH
79371: LD_VAR 0 2
79375: PUSH
79376: LD_VAR 0 3
79380: PUSH
79381: LD_VAR 0 4
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: PPUSH
79392: CALL 19801 0 3
79396: ST_TO_ADDR
// end ;
79397: LD_VAR 0 5
79401: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
79402: LD_INT 0
79404: PPUSH
// if not mc_bases [ base ] then
79405: LD_EXP 60
79409: PUSH
79410: LD_VAR 0 1
79414: ARRAY
79415: NOT
79416: IFFALSE 79420
// exit ;
79418: GO 79445
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
79420: LD_ADDR_EXP 97
79424: PUSH
79425: LD_EXP 97
79429: PPUSH
79430: LD_VAR 0 1
79434: PPUSH
79435: LD_VAR 0 2
79439: PPUSH
79440: CALL_OW 1
79444: ST_TO_ADDR
// end ;
79445: LD_VAR 0 3
79449: RET
// export function MC_GetMinesField ( base ) ; begin
79450: LD_INT 0
79452: PPUSH
// result := mc_mines [ base ] ;
79453: LD_ADDR_VAR 0 2
79457: PUSH
79458: LD_EXP 73
79462: PUSH
79463: LD_VAR 0 1
79467: ARRAY
79468: ST_TO_ADDR
// end ;
79469: LD_VAR 0 2
79473: RET
// export function MC_GetProduceList ( base ) ; begin
79474: LD_INT 0
79476: PPUSH
// result := mc_produce [ base ] ;
79477: LD_ADDR_VAR 0 2
79481: PUSH
79482: LD_EXP 81
79486: PUSH
79487: LD_VAR 0 1
79491: ARRAY
79492: ST_TO_ADDR
// end ;
79493: LD_VAR 0 2
79497: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
79498: LD_INT 0
79500: PPUSH
79501: PPUSH
// if not mc_bases then
79502: LD_EXP 60
79506: NOT
79507: IFFALSE 79511
// exit ;
79509: GO 79576
// if mc_bases [ base ] then
79511: LD_EXP 60
79515: PUSH
79516: LD_VAR 0 1
79520: ARRAY
79521: IFFALSE 79576
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79523: LD_ADDR_VAR 0 3
79527: PUSH
79528: LD_EXP 60
79532: PUSH
79533: LD_VAR 0 1
79537: ARRAY
79538: PPUSH
79539: LD_INT 30
79541: PUSH
79542: LD_VAR 0 2
79546: PUSH
79547: EMPTY
79548: LIST
79549: LIST
79550: PPUSH
79551: CALL_OW 72
79555: ST_TO_ADDR
// if result then
79556: LD_VAR 0 3
79560: IFFALSE 79576
// result := result [ 1 ] ;
79562: LD_ADDR_VAR 0 3
79566: PUSH
79567: LD_VAR 0 3
79571: PUSH
79572: LD_INT 1
79574: ARRAY
79575: ST_TO_ADDR
// end ; end ;
79576: LD_VAR 0 3
79580: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
79581: LD_INT 0
79583: PPUSH
79584: PPUSH
// if not mc_bases then
79585: LD_EXP 60
79589: NOT
79590: IFFALSE 79594
// exit ;
79592: GO 79639
// if mc_bases [ base ] then
79594: LD_EXP 60
79598: PUSH
79599: LD_VAR 0 1
79603: ARRAY
79604: IFFALSE 79639
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79606: LD_ADDR_VAR 0 3
79610: PUSH
79611: LD_EXP 60
79615: PUSH
79616: LD_VAR 0 1
79620: ARRAY
79621: PPUSH
79622: LD_INT 30
79624: PUSH
79625: LD_VAR 0 2
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PPUSH
79634: CALL_OW 72
79638: ST_TO_ADDR
// end ;
79639: LD_VAR 0 3
79643: RET
// export function MC_SetTame ( base , area ) ; begin
79644: LD_INT 0
79646: PPUSH
// if not mc_bases or not base then
79647: LD_EXP 60
79651: NOT
79652: PUSH
79653: LD_VAR 0 1
79657: NOT
79658: OR
79659: IFFALSE 79663
// exit ;
79661: GO 79688
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
79663: LD_ADDR_EXP 88
79667: PUSH
79668: LD_EXP 88
79672: PPUSH
79673: LD_VAR 0 1
79677: PPUSH
79678: LD_VAR 0 2
79682: PPUSH
79683: CALL_OW 1
79687: ST_TO_ADDR
// end ;
79688: LD_VAR 0 3
79692: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
79693: LD_INT 0
79695: PPUSH
79696: PPUSH
// if not mc_bases or not base then
79697: LD_EXP 60
79701: NOT
79702: PUSH
79703: LD_VAR 0 1
79707: NOT
79708: OR
79709: IFFALSE 79713
// exit ;
79711: GO 79815
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
79713: LD_ADDR_VAR 0 4
79717: PUSH
79718: LD_EXP 60
79722: PUSH
79723: LD_VAR 0 1
79727: ARRAY
79728: PPUSH
79729: LD_INT 30
79731: PUSH
79732: LD_VAR 0 2
79736: PUSH
79737: EMPTY
79738: LIST
79739: LIST
79740: PPUSH
79741: CALL_OW 72
79745: ST_TO_ADDR
// if not tmp then
79746: LD_VAR 0 4
79750: NOT
79751: IFFALSE 79755
// exit ;
79753: GO 79815
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
79755: LD_ADDR_EXP 92
79759: PUSH
79760: LD_EXP 92
79764: PPUSH
79765: LD_VAR 0 1
79769: PPUSH
79770: LD_EXP 92
79774: PUSH
79775: LD_VAR 0 1
79779: ARRAY
79780: PPUSH
79781: LD_EXP 92
79785: PUSH
79786: LD_VAR 0 1
79790: ARRAY
79791: PUSH
79792: LD_INT 1
79794: PLUS
79795: PPUSH
79796: LD_VAR 0 4
79800: PUSH
79801: LD_INT 1
79803: ARRAY
79804: PPUSH
79805: CALL_OW 2
79809: PPUSH
79810: CALL_OW 1
79814: ST_TO_ADDR
// end ;
79815: LD_VAR 0 3
79819: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
79820: LD_INT 0
79822: PPUSH
79823: PPUSH
// if not mc_bases or not base or not kinds then
79824: LD_EXP 60
79828: NOT
79829: PUSH
79830: LD_VAR 0 1
79834: NOT
79835: OR
79836: PUSH
79837: LD_VAR 0 2
79841: NOT
79842: OR
79843: IFFALSE 79847
// exit ;
79845: GO 79908
// for i in kinds do
79847: LD_ADDR_VAR 0 4
79851: PUSH
79852: LD_VAR 0 2
79856: PUSH
79857: FOR_IN
79858: IFFALSE 79906
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
79860: LD_ADDR_EXP 94
79864: PUSH
79865: LD_EXP 94
79869: PPUSH
79870: LD_VAR 0 1
79874: PUSH
79875: LD_EXP 94
79879: PUSH
79880: LD_VAR 0 1
79884: ARRAY
79885: PUSH
79886: LD_INT 1
79888: PLUS
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PPUSH
79894: LD_VAR 0 4
79898: PPUSH
79899: CALL 19801 0 3
79903: ST_TO_ADDR
79904: GO 79857
79906: POP
79907: POP
// end ;
79908: LD_VAR 0 3
79912: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
79913: LD_INT 0
79915: PPUSH
// if not mc_bases or not base or not areas then
79916: LD_EXP 60
79920: NOT
79921: PUSH
79922: LD_VAR 0 1
79926: NOT
79927: OR
79928: PUSH
79929: LD_VAR 0 2
79933: NOT
79934: OR
79935: IFFALSE 79939
// exit ;
79937: GO 79964
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
79939: LD_ADDR_EXP 78
79943: PUSH
79944: LD_EXP 78
79948: PPUSH
79949: LD_VAR 0 1
79953: PPUSH
79954: LD_VAR 0 2
79958: PPUSH
79959: CALL_OW 1
79963: ST_TO_ADDR
// end ;
79964: LD_VAR 0 3
79968: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
79969: LD_INT 0
79971: PPUSH
// if not mc_bases or not base or not teleports_exit then
79972: LD_EXP 60
79976: NOT
79977: PUSH
79978: LD_VAR 0 1
79982: NOT
79983: OR
79984: PUSH
79985: LD_VAR 0 2
79989: NOT
79990: OR
79991: IFFALSE 79995
// exit ;
79993: GO 80020
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
79995: LD_ADDR_EXP 95
79999: PUSH
80000: LD_EXP 95
80004: PPUSH
80005: LD_VAR 0 1
80009: PPUSH
80010: LD_VAR 0 2
80014: PPUSH
80015: CALL_OW 1
80019: ST_TO_ADDR
// end ;
80020: LD_VAR 0 3
80024: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80025: LD_INT 0
80027: PPUSH
80028: PPUSH
80029: PPUSH
// if not mc_bases or not base or not ext_list then
80030: LD_EXP 60
80034: NOT
80035: PUSH
80036: LD_VAR 0 1
80040: NOT
80041: OR
80042: PUSH
80043: LD_VAR 0 5
80047: NOT
80048: OR
80049: IFFALSE 80053
// exit ;
80051: GO 80226
// tmp := GetFacExtXYD ( x , y , d ) ;
80053: LD_ADDR_VAR 0 8
80057: PUSH
80058: LD_VAR 0 2
80062: PPUSH
80063: LD_VAR 0 3
80067: PPUSH
80068: LD_VAR 0 4
80072: PPUSH
80073: CALL 49188 0 3
80077: ST_TO_ADDR
// if not tmp then
80078: LD_VAR 0 8
80082: NOT
80083: IFFALSE 80087
// exit ;
80085: GO 80226
// for i in tmp do
80087: LD_ADDR_VAR 0 7
80091: PUSH
80092: LD_VAR 0 8
80096: PUSH
80097: FOR_IN
80098: IFFALSE 80224
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80100: LD_ADDR_EXP 65
80104: PUSH
80105: LD_EXP 65
80109: PPUSH
80110: LD_VAR 0 1
80114: PPUSH
80115: LD_EXP 65
80119: PUSH
80120: LD_VAR 0 1
80124: ARRAY
80125: PPUSH
80126: LD_EXP 65
80130: PUSH
80131: LD_VAR 0 1
80135: ARRAY
80136: PUSH
80137: LD_INT 1
80139: PLUS
80140: PPUSH
80141: LD_VAR 0 5
80145: PUSH
80146: LD_INT 1
80148: ARRAY
80149: PUSH
80150: LD_VAR 0 7
80154: PUSH
80155: LD_INT 1
80157: ARRAY
80158: PUSH
80159: LD_VAR 0 7
80163: PUSH
80164: LD_INT 2
80166: ARRAY
80167: PUSH
80168: LD_VAR 0 7
80172: PUSH
80173: LD_INT 3
80175: ARRAY
80176: PUSH
80177: EMPTY
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: PPUSH
80183: CALL_OW 2
80187: PPUSH
80188: CALL_OW 1
80192: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80193: LD_ADDR_VAR 0 5
80197: PUSH
80198: LD_VAR 0 5
80202: PPUSH
80203: LD_INT 1
80205: PPUSH
80206: CALL_OW 3
80210: ST_TO_ADDR
// if not ext_list then
80211: LD_VAR 0 5
80215: NOT
80216: IFFALSE 80222
// exit ;
80218: POP
80219: POP
80220: GO 80226
// end ;
80222: GO 80097
80224: POP
80225: POP
// end ;
80226: LD_VAR 0 6
80230: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80231: LD_INT 0
80233: PPUSH
// if not mc_bases or not base or not weapon_list then
80234: LD_EXP 60
80238: NOT
80239: PUSH
80240: LD_VAR 0 1
80244: NOT
80245: OR
80246: PUSH
80247: LD_VAR 0 2
80251: NOT
80252: OR
80253: IFFALSE 80257
// exit ;
80255: GO 80282
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80257: LD_ADDR_EXP 99
80261: PUSH
80262: LD_EXP 99
80266: PPUSH
80267: LD_VAR 0 1
80271: PPUSH
80272: LD_VAR 0 2
80276: PPUSH
80277: CALL_OW 1
80281: ST_TO_ADDR
// end ;
80282: LD_VAR 0 3
80286: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80287: LD_INT 0
80289: PPUSH
// if not mc_bases or not base or not tech_list then
80290: LD_EXP 60
80294: NOT
80295: PUSH
80296: LD_VAR 0 1
80300: NOT
80301: OR
80302: PUSH
80303: LD_VAR 0 2
80307: NOT
80308: OR
80309: IFFALSE 80313
// exit ;
80311: GO 80338
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80313: LD_ADDR_EXP 87
80317: PUSH
80318: LD_EXP 87
80322: PPUSH
80323: LD_VAR 0 1
80327: PPUSH
80328: LD_VAR 0 2
80332: PPUSH
80333: CALL_OW 1
80337: ST_TO_ADDR
// end ;
80338: LD_VAR 0 3
80342: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80343: LD_INT 0
80345: PPUSH
// if not mc_bases or not parking_area or not base then
80346: LD_EXP 60
80350: NOT
80351: PUSH
80352: LD_VAR 0 2
80356: NOT
80357: OR
80358: PUSH
80359: LD_VAR 0 1
80363: NOT
80364: OR
80365: IFFALSE 80369
// exit ;
80367: GO 80394
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80369: LD_ADDR_EXP 84
80373: PUSH
80374: LD_EXP 84
80378: PPUSH
80379: LD_VAR 0 1
80383: PPUSH
80384: LD_VAR 0 2
80388: PPUSH
80389: CALL_OW 1
80393: ST_TO_ADDR
// end ;
80394: LD_VAR 0 3
80398: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80399: LD_INT 0
80401: PPUSH
// if not mc_bases or not base or not scan_area then
80402: LD_EXP 60
80406: NOT
80407: PUSH
80408: LD_VAR 0 1
80412: NOT
80413: OR
80414: PUSH
80415: LD_VAR 0 2
80419: NOT
80420: OR
80421: IFFALSE 80425
// exit ;
80423: GO 80450
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
80425: LD_ADDR_EXP 85
80429: PUSH
80430: LD_EXP 85
80434: PPUSH
80435: LD_VAR 0 1
80439: PPUSH
80440: LD_VAR 0 2
80444: PPUSH
80445: CALL_OW 1
80449: ST_TO_ADDR
// end ;
80450: LD_VAR 0 3
80454: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
80455: LD_INT 0
80457: PPUSH
80458: PPUSH
// if not mc_bases or not base then
80459: LD_EXP 60
80463: NOT
80464: PUSH
80465: LD_VAR 0 1
80469: NOT
80470: OR
80471: IFFALSE 80475
// exit ;
80473: GO 80539
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
80475: LD_ADDR_VAR 0 3
80479: PUSH
80480: LD_INT 1
80482: PUSH
80483: LD_INT 2
80485: PUSH
80486: LD_INT 3
80488: PUSH
80489: LD_INT 4
80491: PUSH
80492: LD_INT 11
80494: PUSH
80495: EMPTY
80496: LIST
80497: LIST
80498: LIST
80499: LIST
80500: LIST
80501: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
80502: LD_ADDR_EXP 87
80506: PUSH
80507: LD_EXP 87
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: LD_EXP 87
80521: PUSH
80522: LD_VAR 0 1
80526: ARRAY
80527: PUSH
80528: LD_VAR 0 3
80532: DIFF
80533: PPUSH
80534: CALL_OW 1
80538: ST_TO_ADDR
// end ;
80539: LD_VAR 0 2
80543: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
80544: LD_INT 0
80546: PPUSH
// result := mc_vehicles [ base ] ;
80547: LD_ADDR_VAR 0 3
80551: PUSH
80552: LD_EXP 79
80556: PUSH
80557: LD_VAR 0 1
80561: ARRAY
80562: ST_TO_ADDR
// if onlyCombat then
80563: LD_VAR 0 2
80567: IFFALSE 80745
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
80569: LD_ADDR_VAR 0 3
80573: PUSH
80574: LD_VAR 0 3
80578: PUSH
80579: LD_VAR 0 3
80583: PPUSH
80584: LD_INT 2
80586: PUSH
80587: LD_INT 34
80589: PUSH
80590: LD_INT 12
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 34
80599: PUSH
80600: LD_INT 51
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: LD_INT 34
80609: PUSH
80610: LD_EXP 105
80614: PUSH
80615: EMPTY
80616: LIST
80617: LIST
80618: PUSH
80619: LD_INT 34
80621: PUSH
80622: LD_INT 32
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: LD_INT 34
80631: PUSH
80632: LD_INT 13
80634: PUSH
80635: EMPTY
80636: LIST
80637: LIST
80638: PUSH
80639: LD_INT 34
80641: PUSH
80642: LD_INT 52
80644: PUSH
80645: EMPTY
80646: LIST
80647: LIST
80648: PUSH
80649: LD_INT 34
80651: PUSH
80652: LD_EXP 110
80656: PUSH
80657: EMPTY
80658: LIST
80659: LIST
80660: PUSH
80661: LD_INT 34
80663: PUSH
80664: LD_INT 14
80666: PUSH
80667: EMPTY
80668: LIST
80669: LIST
80670: PUSH
80671: LD_INT 34
80673: PUSH
80674: LD_INT 53
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 34
80683: PUSH
80684: LD_EXP 104
80688: PUSH
80689: EMPTY
80690: LIST
80691: LIST
80692: PUSH
80693: LD_INT 34
80695: PUSH
80696: LD_INT 31
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 34
80705: PUSH
80706: LD_INT 48
80708: PUSH
80709: EMPTY
80710: LIST
80711: LIST
80712: PUSH
80713: LD_INT 34
80715: PUSH
80716: LD_INT 8
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: LIST
80727: LIST
80728: LIST
80729: LIST
80730: LIST
80731: LIST
80732: LIST
80733: LIST
80734: LIST
80735: LIST
80736: LIST
80737: LIST
80738: PPUSH
80739: CALL_OW 72
80743: DIFF
80744: ST_TO_ADDR
// end ; end_of_file
80745: LD_VAR 0 3
80749: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
80750: LD_INT 0
80752: PPUSH
80753: PPUSH
80754: PPUSH
// if not mc_bases or not skirmish then
80755: LD_EXP 60
80759: NOT
80760: PUSH
80761: LD_EXP 58
80765: NOT
80766: OR
80767: IFFALSE 80771
// exit ;
80769: GO 80936
// for i = 1 to mc_bases do
80771: LD_ADDR_VAR 0 4
80775: PUSH
80776: DOUBLE
80777: LD_INT 1
80779: DEC
80780: ST_TO_ADDR
80781: LD_EXP 60
80785: PUSH
80786: FOR_TO
80787: IFFALSE 80934
// begin if sci in mc_bases [ i ] then
80789: LD_VAR 0 2
80793: PUSH
80794: LD_EXP 60
80798: PUSH
80799: LD_VAR 0 4
80803: ARRAY
80804: IN
80805: IFFALSE 80932
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
80807: LD_ADDR_EXP 89
80811: PUSH
80812: LD_EXP 89
80816: PPUSH
80817: LD_VAR 0 4
80821: PUSH
80822: LD_EXP 89
80826: PUSH
80827: LD_VAR 0 4
80831: ARRAY
80832: PUSH
80833: LD_INT 1
80835: PLUS
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PPUSH
80841: LD_VAR 0 1
80845: PPUSH
80846: CALL 19801 0 3
80850: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
80851: LD_ADDR_VAR 0 5
80855: PUSH
80856: LD_EXP 60
80860: PUSH
80861: LD_VAR 0 4
80865: ARRAY
80866: PPUSH
80867: LD_INT 2
80869: PUSH
80870: LD_INT 30
80872: PUSH
80873: LD_INT 0
80875: PUSH
80876: EMPTY
80877: LIST
80878: LIST
80879: PUSH
80880: LD_INT 30
80882: PUSH
80883: LD_INT 1
80885: PUSH
80886: EMPTY
80887: LIST
80888: LIST
80889: PUSH
80890: EMPTY
80891: LIST
80892: LIST
80893: LIST
80894: PPUSH
80895: CALL_OW 72
80899: PPUSH
80900: LD_VAR 0 1
80904: PPUSH
80905: CALL_OW 74
80909: ST_TO_ADDR
// if tmp then
80910: LD_VAR 0 5
80914: IFFALSE 80930
// ComStandNearbyBuilding ( ape , tmp ) ;
80916: LD_VAR 0 1
80920: PPUSH
80921: LD_VAR 0 5
80925: PPUSH
80926: CALL 16379 0 2
// break ;
80930: GO 80934
// end ; end ;
80932: GO 80786
80934: POP
80935: POP
// end ;
80936: LD_VAR 0 3
80940: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
80941: LD_INT 0
80943: PPUSH
80944: PPUSH
80945: PPUSH
// if not mc_bases or not skirmish then
80946: LD_EXP 60
80950: NOT
80951: PUSH
80952: LD_EXP 58
80956: NOT
80957: OR
80958: IFFALSE 80962
// exit ;
80960: GO 81051
// for i = 1 to mc_bases do
80962: LD_ADDR_VAR 0 4
80966: PUSH
80967: DOUBLE
80968: LD_INT 1
80970: DEC
80971: ST_TO_ADDR
80972: LD_EXP 60
80976: PUSH
80977: FOR_TO
80978: IFFALSE 81049
// begin if building in mc_busy_turret_list [ i ] then
80980: LD_VAR 0 1
80984: PUSH
80985: LD_EXP 70
80989: PUSH
80990: LD_VAR 0 4
80994: ARRAY
80995: IN
80996: IFFALSE 81047
// begin tmp := mc_busy_turret_list [ i ] diff building ;
80998: LD_ADDR_VAR 0 5
81002: PUSH
81003: LD_EXP 70
81007: PUSH
81008: LD_VAR 0 4
81012: ARRAY
81013: PUSH
81014: LD_VAR 0 1
81018: DIFF
81019: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81020: LD_ADDR_EXP 70
81024: PUSH
81025: LD_EXP 70
81029: PPUSH
81030: LD_VAR 0 4
81034: PPUSH
81035: LD_VAR 0 5
81039: PPUSH
81040: CALL_OW 1
81044: ST_TO_ADDR
// break ;
81045: GO 81049
// end ; end ;
81047: GO 80977
81049: POP
81050: POP
// end ;
81051: LD_VAR 0 3
81055: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81056: LD_INT 0
81058: PPUSH
81059: PPUSH
81060: PPUSH
// if not mc_bases or not skirmish then
81061: LD_EXP 60
81065: NOT
81066: PUSH
81067: LD_EXP 58
81071: NOT
81072: OR
81073: IFFALSE 81077
// exit ;
81075: GO 81276
// for i = 1 to mc_bases do
81077: LD_ADDR_VAR 0 5
81081: PUSH
81082: DOUBLE
81083: LD_INT 1
81085: DEC
81086: ST_TO_ADDR
81087: LD_EXP 60
81091: PUSH
81092: FOR_TO
81093: IFFALSE 81274
// if building in mc_bases [ i ] then
81095: LD_VAR 0 1
81099: PUSH
81100: LD_EXP 60
81104: PUSH
81105: LD_VAR 0 5
81109: ARRAY
81110: IN
81111: IFFALSE 81272
// begin tmp := mc_bases [ i ] diff building ;
81113: LD_ADDR_VAR 0 6
81117: PUSH
81118: LD_EXP 60
81122: PUSH
81123: LD_VAR 0 5
81127: ARRAY
81128: PUSH
81129: LD_VAR 0 1
81133: DIFF
81134: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81135: LD_ADDR_EXP 60
81139: PUSH
81140: LD_EXP 60
81144: PPUSH
81145: LD_VAR 0 5
81149: PPUSH
81150: LD_VAR 0 6
81154: PPUSH
81155: CALL_OW 1
81159: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81160: LD_VAR 0 1
81164: PUSH
81165: LD_EXP 68
81169: PUSH
81170: LD_VAR 0 5
81174: ARRAY
81175: IN
81176: IFFALSE 81215
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81178: LD_ADDR_EXP 68
81182: PUSH
81183: LD_EXP 68
81187: PPUSH
81188: LD_VAR 0 5
81192: PPUSH
81193: LD_EXP 68
81197: PUSH
81198: LD_VAR 0 5
81202: ARRAY
81203: PUSH
81204: LD_VAR 0 1
81208: DIFF
81209: PPUSH
81210: CALL_OW 1
81214: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81215: LD_VAR 0 1
81219: PUSH
81220: LD_EXP 69
81224: PUSH
81225: LD_VAR 0 5
81229: ARRAY
81230: IN
81231: IFFALSE 81270
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81233: LD_ADDR_EXP 69
81237: PUSH
81238: LD_EXP 69
81242: PPUSH
81243: LD_VAR 0 5
81247: PPUSH
81248: LD_EXP 69
81252: PUSH
81253: LD_VAR 0 5
81257: ARRAY
81258: PUSH
81259: LD_VAR 0 1
81263: DIFF
81264: PPUSH
81265: CALL_OW 1
81269: ST_TO_ADDR
// break ;
81270: GO 81274
// end ;
81272: GO 81092
81274: POP
81275: POP
// end ;
81276: LD_VAR 0 4
81280: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81281: LD_INT 0
81283: PPUSH
81284: PPUSH
81285: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81286: LD_EXP 60
81290: NOT
81291: PUSH
81292: LD_EXP 58
81296: NOT
81297: OR
81298: PUSH
81299: LD_VAR 0 3
81303: PUSH
81304: LD_EXP 86
81308: IN
81309: NOT
81310: OR
81311: IFFALSE 81315
// exit ;
81313: GO 81438
// for i = 1 to mc_vehicles do
81315: LD_ADDR_VAR 0 6
81319: PUSH
81320: DOUBLE
81321: LD_INT 1
81323: DEC
81324: ST_TO_ADDR
81325: LD_EXP 79
81329: PUSH
81330: FOR_TO
81331: IFFALSE 81436
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81333: LD_VAR 0 2
81337: PUSH
81338: LD_EXP 79
81342: PUSH
81343: LD_VAR 0 6
81347: ARRAY
81348: IN
81349: PUSH
81350: LD_VAR 0 1
81354: PUSH
81355: LD_EXP 79
81359: PUSH
81360: LD_VAR 0 6
81364: ARRAY
81365: IN
81366: OR
81367: IFFALSE 81434
// begin tmp := mc_vehicles [ i ] diff old ;
81369: LD_ADDR_VAR 0 7
81373: PUSH
81374: LD_EXP 79
81378: PUSH
81379: LD_VAR 0 6
81383: ARRAY
81384: PUSH
81385: LD_VAR 0 2
81389: DIFF
81390: ST_TO_ADDR
// tmp := tmp diff new ;
81391: LD_ADDR_VAR 0 7
81395: PUSH
81396: LD_VAR 0 7
81400: PUSH
81401: LD_VAR 0 1
81405: DIFF
81406: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81407: LD_ADDR_EXP 79
81411: PUSH
81412: LD_EXP 79
81416: PPUSH
81417: LD_VAR 0 6
81421: PPUSH
81422: LD_VAR 0 7
81426: PPUSH
81427: CALL_OW 1
81431: ST_TO_ADDR
// break ;
81432: GO 81436
// end ;
81434: GO 81330
81436: POP
81437: POP
// end ;
81438: LD_VAR 0 5
81442: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
81443: LD_INT 0
81445: PPUSH
81446: PPUSH
81447: PPUSH
81448: PPUSH
// if not mc_bases or not skirmish then
81449: LD_EXP 60
81453: NOT
81454: PUSH
81455: LD_EXP 58
81459: NOT
81460: OR
81461: IFFALSE 81465
// exit ;
81463: GO 81857
// side := GetSide ( vehicle ) ;
81465: LD_ADDR_VAR 0 5
81469: PUSH
81470: LD_VAR 0 1
81474: PPUSH
81475: CALL_OW 255
81479: ST_TO_ADDR
// for i = 1 to mc_bases do
81480: LD_ADDR_VAR 0 4
81484: PUSH
81485: DOUBLE
81486: LD_INT 1
81488: DEC
81489: ST_TO_ADDR
81490: LD_EXP 60
81494: PUSH
81495: FOR_TO
81496: IFFALSE 81855
// begin if factory in mc_bases [ i ] then
81498: LD_VAR 0 2
81502: PUSH
81503: LD_EXP 60
81507: PUSH
81508: LD_VAR 0 4
81512: ARRAY
81513: IN
81514: IFFALSE 81853
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
81516: LD_EXP 82
81520: PUSH
81521: LD_VAR 0 4
81525: ARRAY
81526: PUSH
81527: LD_EXP 71
81531: PUSH
81532: LD_VAR 0 4
81536: ARRAY
81537: LESS
81538: PUSH
81539: LD_VAR 0 1
81543: PPUSH
81544: CALL_OW 264
81548: PUSH
81549: LD_INT 31
81551: PUSH
81552: LD_INT 32
81554: PUSH
81555: LD_INT 51
81557: PUSH
81558: LD_EXP 105
81562: PUSH
81563: LD_INT 12
81565: PUSH
81566: LD_INT 30
81568: PUSH
81569: LD_EXP 104
81573: PUSH
81574: LD_INT 11
81576: PUSH
81577: LD_INT 53
81579: PUSH
81580: LD_INT 14
81582: PUSH
81583: LD_EXP 108
81587: PUSH
81588: LD_INT 29
81590: PUSH
81591: LD_EXP 106
81595: PUSH
81596: LD_INT 13
81598: PUSH
81599: LD_INT 52
81601: PUSH
81602: LD_EXP 110
81606: PUSH
81607: LD_INT 48
81609: PUSH
81610: LD_INT 8
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: LIST
81619: LIST
81620: LIST
81621: LIST
81622: LIST
81623: LIST
81624: LIST
81625: LIST
81626: LIST
81627: LIST
81628: LIST
81629: LIST
81630: LIST
81631: LIST
81632: IN
81633: NOT
81634: AND
81635: IFFALSE 81683
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
81637: LD_ADDR_EXP 82
81641: PUSH
81642: LD_EXP 82
81646: PPUSH
81647: LD_VAR 0 4
81651: PUSH
81652: LD_EXP 82
81656: PUSH
81657: LD_VAR 0 4
81661: ARRAY
81662: PUSH
81663: LD_INT 1
81665: PLUS
81666: PUSH
81667: EMPTY
81668: LIST
81669: LIST
81670: PPUSH
81671: LD_VAR 0 1
81675: PPUSH
81676: CALL 19801 0 3
81680: ST_TO_ADDR
81681: GO 81727
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
81683: LD_ADDR_EXP 79
81687: PUSH
81688: LD_EXP 79
81692: PPUSH
81693: LD_VAR 0 4
81697: PUSH
81698: LD_EXP 79
81702: PUSH
81703: LD_VAR 0 4
81707: ARRAY
81708: PUSH
81709: LD_INT 1
81711: PLUS
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PPUSH
81717: LD_VAR 0 1
81721: PPUSH
81722: CALL 19801 0 3
81726: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
81727: LD_VAR 0 1
81731: PPUSH
81732: CALL_OW 263
81736: PUSH
81737: LD_INT 2
81739: EQUAL
81740: IFFALSE 81769
// begin repeat wait ( 0 0$3 ) ;
81742: LD_INT 105
81744: PPUSH
81745: CALL_OW 67
// Connect ( vehicle ) ;
81749: LD_VAR 0 1
81753: PPUSH
81754: CALL 22772 0 1
// until IsControledBy ( vehicle ) ;
81758: LD_VAR 0 1
81762: PPUSH
81763: CALL_OW 312
81767: IFFALSE 81742
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
81769: LD_VAR 0 1
81773: PPUSH
81774: LD_EXP 84
81778: PUSH
81779: LD_VAR 0 4
81783: ARRAY
81784: PPUSH
81785: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
81789: LD_VAR 0 1
81793: PPUSH
81794: CALL_OW 263
81798: PUSH
81799: LD_INT 1
81801: NONEQUAL
81802: IFFALSE 81806
// break ;
81804: GO 81855
// repeat wait ( 0 0$1 ) ;
81806: LD_INT 35
81808: PPUSH
81809: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
81813: LD_VAR 0 1
81817: PPUSH
81818: LD_EXP 84
81822: PUSH
81823: LD_VAR 0 4
81827: ARRAY
81828: PPUSH
81829: CALL_OW 308
81833: IFFALSE 81806
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
81835: LD_VAR 0 1
81839: PPUSH
81840: CALL_OW 311
81844: PPUSH
81845: CALL_OW 121
// exit ;
81849: POP
81850: POP
81851: GO 81857
// end ; end ;
81853: GO 81495
81855: POP
81856: POP
// end ;
81857: LD_VAR 0 3
81861: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
81862: LD_INT 0
81864: PPUSH
81865: PPUSH
81866: PPUSH
81867: PPUSH
// if not mc_bases or not skirmish then
81868: LD_EXP 60
81872: NOT
81873: PUSH
81874: LD_EXP 58
81878: NOT
81879: OR
81880: IFFALSE 81884
// exit ;
81882: GO 82237
// repeat wait ( 0 0$1 ) ;
81884: LD_INT 35
81886: PPUSH
81887: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
81891: LD_VAR 0 2
81895: PPUSH
81896: LD_VAR 0 3
81900: PPUSH
81901: CALL_OW 284
81905: IFFALSE 81884
// if GetResourceTypeXY ( x , y ) = mat_artefact then
81907: LD_VAR 0 2
81911: PPUSH
81912: LD_VAR 0 3
81916: PPUSH
81917: CALL_OW 283
81921: PUSH
81922: LD_INT 4
81924: EQUAL
81925: IFFALSE 81929
// exit ;
81927: GO 82237
// for i = 1 to mc_bases do
81929: LD_ADDR_VAR 0 7
81933: PUSH
81934: DOUBLE
81935: LD_INT 1
81937: DEC
81938: ST_TO_ADDR
81939: LD_EXP 60
81943: PUSH
81944: FOR_TO
81945: IFFALSE 82235
// begin if mc_crates_area [ i ] then
81947: LD_EXP 78
81951: PUSH
81952: LD_VAR 0 7
81956: ARRAY
81957: IFFALSE 82068
// for j in mc_crates_area [ i ] do
81959: LD_ADDR_VAR 0 8
81963: PUSH
81964: LD_EXP 78
81968: PUSH
81969: LD_VAR 0 7
81973: ARRAY
81974: PUSH
81975: FOR_IN
81976: IFFALSE 82066
// if InArea ( x , y , j ) then
81978: LD_VAR 0 2
81982: PPUSH
81983: LD_VAR 0 3
81987: PPUSH
81988: LD_VAR 0 8
81992: PPUSH
81993: CALL_OW 309
81997: IFFALSE 82064
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
81999: LD_ADDR_EXP 76
82003: PUSH
82004: LD_EXP 76
82008: PPUSH
82009: LD_VAR 0 7
82013: PUSH
82014: LD_EXP 76
82018: PUSH
82019: LD_VAR 0 7
82023: ARRAY
82024: PUSH
82025: LD_INT 1
82027: PLUS
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PPUSH
82033: LD_VAR 0 4
82037: PUSH
82038: LD_VAR 0 2
82042: PUSH
82043: LD_VAR 0 3
82047: PUSH
82048: EMPTY
82049: LIST
82050: LIST
82051: LIST
82052: PPUSH
82053: CALL 19801 0 3
82057: ST_TO_ADDR
// exit ;
82058: POP
82059: POP
82060: POP
82061: POP
82062: GO 82237
// end ;
82064: GO 81975
82066: POP
82067: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82068: LD_ADDR_VAR 0 9
82072: PUSH
82073: LD_EXP 60
82077: PUSH
82078: LD_VAR 0 7
82082: ARRAY
82083: PPUSH
82084: LD_INT 2
82086: PUSH
82087: LD_INT 30
82089: PUSH
82090: LD_INT 0
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 30
82099: PUSH
82100: LD_INT 1
82102: PUSH
82103: EMPTY
82104: LIST
82105: LIST
82106: PUSH
82107: EMPTY
82108: LIST
82109: LIST
82110: LIST
82111: PPUSH
82112: CALL_OW 72
82116: ST_TO_ADDR
// if not depot then
82117: LD_VAR 0 9
82121: NOT
82122: IFFALSE 82126
// continue ;
82124: GO 81944
// for j in depot do
82126: LD_ADDR_VAR 0 8
82130: PUSH
82131: LD_VAR 0 9
82135: PUSH
82136: FOR_IN
82137: IFFALSE 82231
// if GetDistUnitXY ( j , x , y ) < 30 then
82139: LD_VAR 0 8
82143: PPUSH
82144: LD_VAR 0 2
82148: PPUSH
82149: LD_VAR 0 3
82153: PPUSH
82154: CALL_OW 297
82158: PUSH
82159: LD_INT 30
82161: LESS
82162: IFFALSE 82229
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82164: LD_ADDR_EXP 76
82168: PUSH
82169: LD_EXP 76
82173: PPUSH
82174: LD_VAR 0 7
82178: PUSH
82179: LD_EXP 76
82183: PUSH
82184: LD_VAR 0 7
82188: ARRAY
82189: PUSH
82190: LD_INT 1
82192: PLUS
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PPUSH
82198: LD_VAR 0 4
82202: PUSH
82203: LD_VAR 0 2
82207: PUSH
82208: LD_VAR 0 3
82212: PUSH
82213: EMPTY
82214: LIST
82215: LIST
82216: LIST
82217: PPUSH
82218: CALL 19801 0 3
82222: ST_TO_ADDR
// exit ;
82223: POP
82224: POP
82225: POP
82226: POP
82227: GO 82237
// end ;
82229: GO 82136
82231: POP
82232: POP
// end ;
82233: GO 81944
82235: POP
82236: POP
// end ;
82237: LD_VAR 0 6
82241: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82242: LD_INT 0
82244: PPUSH
82245: PPUSH
82246: PPUSH
82247: PPUSH
// if not mc_bases or not skirmish then
82248: LD_EXP 60
82252: NOT
82253: PUSH
82254: LD_EXP 58
82258: NOT
82259: OR
82260: IFFALSE 82264
// exit ;
82262: GO 82541
// side := GetSide ( lab ) ;
82264: LD_ADDR_VAR 0 4
82268: PUSH
82269: LD_VAR 0 2
82273: PPUSH
82274: CALL_OW 255
82278: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82279: LD_VAR 0 4
82283: PUSH
82284: LD_EXP 86
82288: IN
82289: NOT
82290: PUSH
82291: LD_EXP 87
82295: NOT
82296: OR
82297: PUSH
82298: LD_EXP 60
82302: NOT
82303: OR
82304: IFFALSE 82308
// exit ;
82306: GO 82541
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82308: LD_ADDR_EXP 87
82312: PUSH
82313: LD_EXP 87
82317: PPUSH
82318: LD_VAR 0 4
82322: PPUSH
82323: LD_EXP 87
82327: PUSH
82328: LD_VAR 0 4
82332: ARRAY
82333: PUSH
82334: LD_VAR 0 1
82338: DIFF
82339: PPUSH
82340: CALL_OW 1
82344: ST_TO_ADDR
// for i = 1 to mc_bases do
82345: LD_ADDR_VAR 0 5
82349: PUSH
82350: DOUBLE
82351: LD_INT 1
82353: DEC
82354: ST_TO_ADDR
82355: LD_EXP 60
82359: PUSH
82360: FOR_TO
82361: IFFALSE 82539
// begin if lab in mc_bases [ i ] then
82363: LD_VAR 0 2
82367: PUSH
82368: LD_EXP 60
82372: PUSH
82373: LD_VAR 0 5
82377: ARRAY
82378: IN
82379: IFFALSE 82537
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82381: LD_VAR 0 1
82385: PUSH
82386: LD_INT 11
82388: PUSH
82389: LD_INT 4
82391: PUSH
82392: LD_INT 3
82394: PUSH
82395: LD_INT 2
82397: PUSH
82398: EMPTY
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: IN
82404: PUSH
82405: LD_EXP 90
82409: PUSH
82410: LD_VAR 0 5
82414: ARRAY
82415: AND
82416: IFFALSE 82537
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82418: LD_ADDR_VAR 0 6
82422: PUSH
82423: LD_EXP 90
82427: PUSH
82428: LD_VAR 0 5
82432: ARRAY
82433: PUSH
82434: LD_INT 1
82436: ARRAY
82437: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82438: LD_ADDR_EXP 90
82442: PUSH
82443: LD_EXP 90
82447: PPUSH
82448: LD_VAR 0 5
82452: PPUSH
82453: EMPTY
82454: PPUSH
82455: CALL_OW 1
82459: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
82460: LD_VAR 0 6
82464: PPUSH
82465: LD_INT 0
82467: PPUSH
82468: CALL_OW 109
// ComExitBuilding ( tmp ) ;
82472: LD_VAR 0 6
82476: PPUSH
82477: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
82481: LD_ADDR_EXP 89
82485: PUSH
82486: LD_EXP 89
82490: PPUSH
82491: LD_VAR 0 5
82495: PPUSH
82496: LD_EXP 89
82500: PUSH
82501: LD_VAR 0 5
82505: ARRAY
82506: PPUSH
82507: LD_INT 1
82509: PPUSH
82510: LD_VAR 0 6
82514: PPUSH
82515: CALL_OW 2
82519: PPUSH
82520: CALL_OW 1
82524: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
82525: LD_VAR 0 5
82529: PPUSH
82530: LD_INT 112
82532: PPUSH
82533: CALL 59060 0 2
// end ; end ; end ;
82537: GO 82360
82539: POP
82540: POP
// end ;
82541: LD_VAR 0 3
82545: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
82546: LD_INT 0
82548: PPUSH
82549: PPUSH
82550: PPUSH
82551: PPUSH
82552: PPUSH
82553: PPUSH
82554: PPUSH
82555: PPUSH
// if not mc_bases or not skirmish then
82556: LD_EXP 60
82560: NOT
82561: PUSH
82562: LD_EXP 58
82566: NOT
82567: OR
82568: IFFALSE 82572
// exit ;
82570: GO 83943
// for i = 1 to mc_bases do
82572: LD_ADDR_VAR 0 3
82576: PUSH
82577: DOUBLE
82578: LD_INT 1
82580: DEC
82581: ST_TO_ADDR
82582: LD_EXP 60
82586: PUSH
82587: FOR_TO
82588: IFFALSE 83941
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
82590: LD_VAR 0 1
82594: PUSH
82595: LD_EXP 60
82599: PUSH
82600: LD_VAR 0 3
82604: ARRAY
82605: IN
82606: PUSH
82607: LD_VAR 0 1
82611: PUSH
82612: LD_EXP 67
82616: PUSH
82617: LD_VAR 0 3
82621: ARRAY
82622: IN
82623: OR
82624: PUSH
82625: LD_VAR 0 1
82629: PUSH
82630: LD_EXP 82
82634: PUSH
82635: LD_VAR 0 3
82639: ARRAY
82640: IN
82641: OR
82642: PUSH
82643: LD_VAR 0 1
82647: PUSH
82648: LD_EXP 79
82652: PUSH
82653: LD_VAR 0 3
82657: ARRAY
82658: IN
82659: OR
82660: PUSH
82661: LD_VAR 0 1
82665: PUSH
82666: LD_EXP 89
82670: PUSH
82671: LD_VAR 0 3
82675: ARRAY
82676: IN
82677: OR
82678: PUSH
82679: LD_VAR 0 1
82683: PUSH
82684: LD_EXP 90
82688: PUSH
82689: LD_VAR 0 3
82693: ARRAY
82694: IN
82695: OR
82696: IFFALSE 83939
// begin if un in mc_ape [ i ] then
82698: LD_VAR 0 1
82702: PUSH
82703: LD_EXP 89
82707: PUSH
82708: LD_VAR 0 3
82712: ARRAY
82713: IN
82714: IFFALSE 82753
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
82716: LD_ADDR_EXP 89
82720: PUSH
82721: LD_EXP 89
82725: PPUSH
82726: LD_VAR 0 3
82730: PPUSH
82731: LD_EXP 89
82735: PUSH
82736: LD_VAR 0 3
82740: ARRAY
82741: PUSH
82742: LD_VAR 0 1
82746: DIFF
82747: PPUSH
82748: CALL_OW 1
82752: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
82753: LD_VAR 0 1
82757: PUSH
82758: LD_EXP 90
82762: PUSH
82763: LD_VAR 0 3
82767: ARRAY
82768: IN
82769: IFFALSE 82793
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82771: LD_ADDR_EXP 90
82775: PUSH
82776: LD_EXP 90
82780: PPUSH
82781: LD_VAR 0 3
82785: PPUSH
82786: EMPTY
82787: PPUSH
82788: CALL_OW 1
82792: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
82793: LD_VAR 0 1
82797: PPUSH
82798: CALL_OW 247
82802: PUSH
82803: LD_INT 2
82805: EQUAL
82806: PUSH
82807: LD_VAR 0 1
82811: PPUSH
82812: CALL_OW 110
82816: PUSH
82817: LD_INT 20
82819: EQUAL
82820: PUSH
82821: LD_VAR 0 1
82825: PUSH
82826: LD_EXP 82
82830: PUSH
82831: LD_VAR 0 3
82835: ARRAY
82836: IN
82837: OR
82838: PUSH
82839: LD_VAR 0 1
82843: PPUSH
82844: CALL_OW 264
82848: PUSH
82849: LD_INT 12
82851: PUSH
82852: LD_INT 51
82854: PUSH
82855: LD_EXP 105
82859: PUSH
82860: LD_INT 32
82862: PUSH
82863: LD_INT 13
82865: PUSH
82866: LD_INT 52
82868: PUSH
82869: LD_INT 31
82871: PUSH
82872: EMPTY
82873: LIST
82874: LIST
82875: LIST
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: IN
82881: OR
82882: AND
82883: IFFALSE 83191
// begin if un in mc_defender [ i ] then
82885: LD_VAR 0 1
82889: PUSH
82890: LD_EXP 82
82894: PUSH
82895: LD_VAR 0 3
82899: ARRAY
82900: IN
82901: IFFALSE 82940
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
82903: LD_ADDR_EXP 82
82907: PUSH
82908: LD_EXP 82
82912: PPUSH
82913: LD_VAR 0 3
82917: PPUSH
82918: LD_EXP 82
82922: PUSH
82923: LD_VAR 0 3
82927: ARRAY
82928: PUSH
82929: LD_VAR 0 1
82933: DIFF
82934: PPUSH
82935: CALL_OW 1
82939: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
82940: LD_ADDR_VAR 0 8
82944: PUSH
82945: LD_VAR 0 3
82949: PPUSH
82950: LD_INT 3
82952: PPUSH
82953: CALL 79581 0 2
82957: ST_TO_ADDR
// if fac then
82958: LD_VAR 0 8
82962: IFFALSE 83191
// begin for j in fac do
82964: LD_ADDR_VAR 0 4
82968: PUSH
82969: LD_VAR 0 8
82973: PUSH
82974: FOR_IN
82975: IFFALSE 83189
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
82977: LD_ADDR_VAR 0 9
82981: PUSH
82982: LD_VAR 0 8
82986: PPUSH
82987: LD_VAR 0 1
82991: PPUSH
82992: CALL_OW 265
82996: PPUSH
82997: LD_VAR 0 1
83001: PPUSH
83002: CALL_OW 262
83006: PPUSH
83007: LD_VAR 0 1
83011: PPUSH
83012: CALL_OW 263
83016: PPUSH
83017: LD_VAR 0 1
83021: PPUSH
83022: CALL_OW 264
83026: PPUSH
83027: CALL 17297 0 5
83031: ST_TO_ADDR
// if components then
83032: LD_VAR 0 9
83036: IFFALSE 83187
// begin if GetWeapon ( un ) = ar_control_tower then
83038: LD_VAR 0 1
83042: PPUSH
83043: CALL_OW 264
83047: PUSH
83048: LD_INT 31
83050: EQUAL
83051: IFFALSE 83168
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
83053: LD_VAR 0 1
83057: PPUSH
83058: CALL_OW 311
83062: PPUSH
83063: LD_INT 0
83065: PPUSH
83066: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
83070: LD_ADDR_EXP 100
83074: PUSH
83075: LD_EXP 100
83079: PPUSH
83080: LD_VAR 0 3
83084: PPUSH
83085: LD_EXP 100
83089: PUSH
83090: LD_VAR 0 3
83094: ARRAY
83095: PUSH
83096: LD_VAR 0 1
83100: PPUSH
83101: CALL_OW 311
83105: DIFF
83106: PPUSH
83107: CALL_OW 1
83111: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
83112: LD_ADDR_VAR 0 7
83116: PUSH
83117: LD_EXP 81
83121: PUSH
83122: LD_VAR 0 3
83126: ARRAY
83127: PPUSH
83128: LD_INT 1
83130: PPUSH
83131: LD_VAR 0 9
83135: PPUSH
83136: CALL_OW 2
83140: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
83141: LD_ADDR_EXP 81
83145: PUSH
83146: LD_EXP 81
83150: PPUSH
83151: LD_VAR 0 3
83155: PPUSH
83156: LD_VAR 0 7
83160: PPUSH
83161: CALL_OW 1
83165: ST_TO_ADDR
// end else
83166: GO 83185
// MC_InsertProduceList ( i , [ components ] ) ;
83168: LD_VAR 0 3
83172: PPUSH
83173: LD_VAR 0 9
83177: PUSH
83178: EMPTY
83179: LIST
83180: PPUSH
83181: CALL 79126 0 2
// break ;
83185: GO 83189
// end ; end ;
83187: GO 82974
83189: POP
83190: POP
// end ; end ; if GetType ( un ) = unit_building then
83191: LD_VAR 0 1
83195: PPUSH
83196: CALL_OW 247
83200: PUSH
83201: LD_INT 3
83203: EQUAL
83204: IFFALSE 83607
// begin btype := GetBType ( un ) ;
83206: LD_ADDR_VAR 0 5
83210: PUSH
83211: LD_VAR 0 1
83215: PPUSH
83216: CALL_OW 266
83220: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
83221: LD_VAR 0 5
83225: PUSH
83226: LD_INT 29
83228: PUSH
83229: LD_INT 30
83231: PUSH
83232: EMPTY
83233: LIST
83234: LIST
83235: IN
83236: IFFALSE 83309
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
83238: LD_VAR 0 1
83242: PPUSH
83243: CALL_OW 250
83247: PPUSH
83248: LD_VAR 0 1
83252: PPUSH
83253: CALL_OW 251
83257: PPUSH
83258: LD_VAR 0 1
83262: PPUSH
83263: CALL_OW 255
83267: PPUSH
83268: CALL_OW 440
83272: NOT
83273: IFFALSE 83309
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
83275: LD_VAR 0 1
83279: PPUSH
83280: CALL_OW 250
83284: PPUSH
83285: LD_VAR 0 1
83289: PPUSH
83290: CALL_OW 251
83294: PPUSH
83295: LD_VAR 0 1
83299: PPUSH
83300: CALL_OW 255
83304: PPUSH
83305: CALL_OW 441
// end ; if btype = b_warehouse then
83309: LD_VAR 0 5
83313: PUSH
83314: LD_INT 1
83316: EQUAL
83317: IFFALSE 83335
// begin btype := b_depot ;
83319: LD_ADDR_VAR 0 5
83323: PUSH
83324: LD_INT 0
83326: ST_TO_ADDR
// pos := 1 ;
83327: LD_ADDR_VAR 0 6
83331: PUSH
83332: LD_INT 1
83334: ST_TO_ADDR
// end ; if btype = b_factory then
83335: LD_VAR 0 5
83339: PUSH
83340: LD_INT 3
83342: EQUAL
83343: IFFALSE 83361
// begin btype := b_workshop ;
83345: LD_ADDR_VAR 0 5
83349: PUSH
83350: LD_INT 2
83352: ST_TO_ADDR
// pos := 1 ;
83353: LD_ADDR_VAR 0 6
83357: PUSH
83358: LD_INT 1
83360: ST_TO_ADDR
// end ; if btype = b_barracks then
83361: LD_VAR 0 5
83365: PUSH
83366: LD_INT 5
83368: EQUAL
83369: IFFALSE 83379
// btype := b_armoury ;
83371: LD_ADDR_VAR 0 5
83375: PUSH
83376: LD_INT 4
83378: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83379: LD_VAR 0 5
83383: PUSH
83384: LD_INT 7
83386: PUSH
83387: LD_INT 8
83389: PUSH
83390: EMPTY
83391: LIST
83392: LIST
83393: IN
83394: IFFALSE 83404
// btype := b_lab ;
83396: LD_ADDR_VAR 0 5
83400: PUSH
83401: LD_INT 6
83403: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83404: LD_ADDR_EXP 65
83408: PUSH
83409: LD_EXP 65
83413: PPUSH
83414: LD_VAR 0 3
83418: PUSH
83419: LD_EXP 65
83423: PUSH
83424: LD_VAR 0 3
83428: ARRAY
83429: PUSH
83430: LD_INT 1
83432: PLUS
83433: PUSH
83434: EMPTY
83435: LIST
83436: LIST
83437: PPUSH
83438: LD_VAR 0 5
83442: PUSH
83443: LD_VAR 0 1
83447: PPUSH
83448: CALL_OW 250
83452: PUSH
83453: LD_VAR 0 1
83457: PPUSH
83458: CALL_OW 251
83462: PUSH
83463: LD_VAR 0 1
83467: PPUSH
83468: CALL_OW 254
83472: PUSH
83473: EMPTY
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: PPUSH
83479: CALL 19801 0 3
83483: ST_TO_ADDR
// if pos = 1 then
83484: LD_VAR 0 6
83488: PUSH
83489: LD_INT 1
83491: EQUAL
83492: IFFALSE 83607
// begin tmp := mc_build_list [ i ] ;
83494: LD_ADDR_VAR 0 7
83498: PUSH
83499: LD_EXP 65
83503: PUSH
83504: LD_VAR 0 3
83508: ARRAY
83509: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83510: LD_VAR 0 7
83514: PPUSH
83515: LD_INT 2
83517: PUSH
83518: LD_INT 30
83520: PUSH
83521: LD_INT 0
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 30
83530: PUSH
83531: LD_INT 1
83533: PUSH
83534: EMPTY
83535: LIST
83536: LIST
83537: PUSH
83538: EMPTY
83539: LIST
83540: LIST
83541: LIST
83542: PPUSH
83543: CALL_OW 72
83547: IFFALSE 83557
// pos := 2 ;
83549: LD_ADDR_VAR 0 6
83553: PUSH
83554: LD_INT 2
83556: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83557: LD_ADDR_VAR 0 7
83561: PUSH
83562: LD_VAR 0 7
83566: PPUSH
83567: LD_VAR 0 6
83571: PPUSH
83572: LD_VAR 0 7
83576: PPUSH
83577: CALL 20127 0 3
83581: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83582: LD_ADDR_EXP 65
83586: PUSH
83587: LD_EXP 65
83591: PPUSH
83592: LD_VAR 0 3
83596: PPUSH
83597: LD_VAR 0 7
83601: PPUSH
83602: CALL_OW 1
83606: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83607: LD_VAR 0 1
83611: PUSH
83612: LD_EXP 60
83616: PUSH
83617: LD_VAR 0 3
83621: ARRAY
83622: IN
83623: IFFALSE 83662
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83625: LD_ADDR_EXP 60
83629: PUSH
83630: LD_EXP 60
83634: PPUSH
83635: LD_VAR 0 3
83639: PPUSH
83640: LD_EXP 60
83644: PUSH
83645: LD_VAR 0 3
83649: ARRAY
83650: PUSH
83651: LD_VAR 0 1
83655: DIFF
83656: PPUSH
83657: CALL_OW 1
83661: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83662: LD_VAR 0 1
83666: PUSH
83667: LD_EXP 67
83671: PUSH
83672: LD_VAR 0 3
83676: ARRAY
83677: IN
83678: IFFALSE 83717
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83680: LD_ADDR_EXP 67
83684: PUSH
83685: LD_EXP 67
83689: PPUSH
83690: LD_VAR 0 3
83694: PPUSH
83695: LD_EXP 67
83699: PUSH
83700: LD_VAR 0 3
83704: ARRAY
83705: PUSH
83706: LD_VAR 0 1
83710: DIFF
83711: PPUSH
83712: CALL_OW 1
83716: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83717: LD_VAR 0 1
83721: PUSH
83722: LD_EXP 79
83726: PUSH
83727: LD_VAR 0 3
83731: ARRAY
83732: IN
83733: IFFALSE 83772
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83735: LD_ADDR_EXP 79
83739: PUSH
83740: LD_EXP 79
83744: PPUSH
83745: LD_VAR 0 3
83749: PPUSH
83750: LD_EXP 79
83754: PUSH
83755: LD_VAR 0 3
83759: ARRAY
83760: PUSH
83761: LD_VAR 0 1
83765: DIFF
83766: PPUSH
83767: CALL_OW 1
83771: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83772: LD_VAR 0 1
83776: PUSH
83777: LD_EXP 82
83781: PUSH
83782: LD_VAR 0 3
83786: ARRAY
83787: IN
83788: IFFALSE 83827
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83790: LD_ADDR_EXP 82
83794: PUSH
83795: LD_EXP 82
83799: PPUSH
83800: LD_VAR 0 3
83804: PPUSH
83805: LD_EXP 82
83809: PUSH
83810: LD_VAR 0 3
83814: ARRAY
83815: PUSH
83816: LD_VAR 0 1
83820: DIFF
83821: PPUSH
83822: CALL_OW 1
83826: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
83827: LD_VAR 0 1
83831: PUSH
83832: LD_EXP 69
83836: PUSH
83837: LD_VAR 0 3
83841: ARRAY
83842: IN
83843: IFFALSE 83882
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
83845: LD_ADDR_EXP 69
83849: PUSH
83850: LD_EXP 69
83854: PPUSH
83855: LD_VAR 0 3
83859: PPUSH
83860: LD_EXP 69
83864: PUSH
83865: LD_VAR 0 3
83869: ARRAY
83870: PUSH
83871: LD_VAR 0 1
83875: DIFF
83876: PPUSH
83877: CALL_OW 1
83881: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
83882: LD_VAR 0 1
83886: PUSH
83887: LD_EXP 68
83891: PUSH
83892: LD_VAR 0 3
83896: ARRAY
83897: IN
83898: IFFALSE 83937
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
83900: LD_ADDR_EXP 68
83904: PUSH
83905: LD_EXP 68
83909: PPUSH
83910: LD_VAR 0 3
83914: PPUSH
83915: LD_EXP 68
83919: PUSH
83920: LD_VAR 0 3
83924: ARRAY
83925: PUSH
83926: LD_VAR 0 1
83930: DIFF
83931: PPUSH
83932: CALL_OW 1
83936: ST_TO_ADDR
// end ; break ;
83937: GO 83941
// end ;
83939: GO 82587
83941: POP
83942: POP
// end ;
83943: LD_VAR 0 2
83947: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
83948: LD_INT 0
83950: PPUSH
83951: PPUSH
83952: PPUSH
// if not mc_bases or not skirmish then
83953: LD_EXP 60
83957: NOT
83958: PUSH
83959: LD_EXP 58
83963: NOT
83964: OR
83965: IFFALSE 83969
// exit ;
83967: GO 84184
// for i = 1 to mc_bases do
83969: LD_ADDR_VAR 0 3
83973: PUSH
83974: DOUBLE
83975: LD_INT 1
83977: DEC
83978: ST_TO_ADDR
83979: LD_EXP 60
83983: PUSH
83984: FOR_TO
83985: IFFALSE 84182
// begin if building in mc_construct_list [ i ] then
83987: LD_VAR 0 1
83991: PUSH
83992: LD_EXP 67
83996: PUSH
83997: LD_VAR 0 3
84001: ARRAY
84002: IN
84003: IFFALSE 84180
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84005: LD_ADDR_EXP 67
84009: PUSH
84010: LD_EXP 67
84014: PPUSH
84015: LD_VAR 0 3
84019: PPUSH
84020: LD_EXP 67
84024: PUSH
84025: LD_VAR 0 3
84029: ARRAY
84030: PUSH
84031: LD_VAR 0 1
84035: DIFF
84036: PPUSH
84037: CALL_OW 1
84041: ST_TO_ADDR
// if building in mc_lab [ i ] then
84042: LD_VAR 0 1
84046: PUSH
84047: LD_EXP 93
84051: PUSH
84052: LD_VAR 0 3
84056: ARRAY
84057: IN
84058: IFFALSE 84113
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84060: LD_ADDR_EXP 94
84064: PUSH
84065: LD_EXP 94
84069: PPUSH
84070: LD_VAR 0 3
84074: PPUSH
84075: LD_EXP 94
84079: PUSH
84080: LD_VAR 0 3
84084: ARRAY
84085: PPUSH
84086: LD_INT 1
84088: PPUSH
84089: LD_EXP 94
84093: PUSH
84094: LD_VAR 0 3
84098: ARRAY
84099: PPUSH
84100: LD_INT 0
84102: PPUSH
84103: CALL 19219 0 4
84107: PPUSH
84108: CALL_OW 1
84112: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84113: LD_VAR 0 1
84117: PUSH
84118: LD_EXP 60
84122: PUSH
84123: LD_VAR 0 3
84127: ARRAY
84128: IN
84129: NOT
84130: IFFALSE 84176
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84132: LD_ADDR_EXP 60
84136: PUSH
84137: LD_EXP 60
84141: PPUSH
84142: LD_VAR 0 3
84146: PUSH
84147: LD_EXP 60
84151: PUSH
84152: LD_VAR 0 3
84156: ARRAY
84157: PUSH
84158: LD_INT 1
84160: PLUS
84161: PUSH
84162: EMPTY
84163: LIST
84164: LIST
84165: PPUSH
84166: LD_VAR 0 1
84170: PPUSH
84171: CALL 19801 0 3
84175: ST_TO_ADDR
// exit ;
84176: POP
84177: POP
84178: GO 84184
// end ; end ;
84180: GO 83984
84182: POP
84183: POP
// end ;
84184: LD_VAR 0 2
84188: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84189: LD_INT 0
84191: PPUSH
84192: PPUSH
84193: PPUSH
84194: PPUSH
84195: PPUSH
84196: PPUSH
84197: PPUSH
// if not mc_bases or not skirmish then
84198: LD_EXP 60
84202: NOT
84203: PUSH
84204: LD_EXP 58
84208: NOT
84209: OR
84210: IFFALSE 84214
// exit ;
84212: GO 84875
// for i = 1 to mc_bases do
84214: LD_ADDR_VAR 0 3
84218: PUSH
84219: DOUBLE
84220: LD_INT 1
84222: DEC
84223: ST_TO_ADDR
84224: LD_EXP 60
84228: PUSH
84229: FOR_TO
84230: IFFALSE 84873
// begin if building in mc_construct_list [ i ] then
84232: LD_VAR 0 1
84236: PUSH
84237: LD_EXP 67
84241: PUSH
84242: LD_VAR 0 3
84246: ARRAY
84247: IN
84248: IFFALSE 84871
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84250: LD_ADDR_EXP 67
84254: PUSH
84255: LD_EXP 67
84259: PPUSH
84260: LD_VAR 0 3
84264: PPUSH
84265: LD_EXP 67
84269: PUSH
84270: LD_VAR 0 3
84274: ARRAY
84275: PUSH
84276: LD_VAR 0 1
84280: DIFF
84281: PPUSH
84282: CALL_OW 1
84286: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84287: LD_ADDR_EXP 60
84291: PUSH
84292: LD_EXP 60
84296: PPUSH
84297: LD_VAR 0 3
84301: PUSH
84302: LD_EXP 60
84306: PUSH
84307: LD_VAR 0 3
84311: ARRAY
84312: PUSH
84313: LD_INT 1
84315: PLUS
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PPUSH
84321: LD_VAR 0 1
84325: PPUSH
84326: CALL 19801 0 3
84330: ST_TO_ADDR
// btype := GetBType ( building ) ;
84331: LD_ADDR_VAR 0 5
84335: PUSH
84336: LD_VAR 0 1
84340: PPUSH
84341: CALL_OW 266
84345: ST_TO_ADDR
// side := GetSide ( building ) ;
84346: LD_ADDR_VAR 0 8
84350: PUSH
84351: LD_VAR 0 1
84355: PPUSH
84356: CALL_OW 255
84360: ST_TO_ADDR
// if btype = b_lab then
84361: LD_VAR 0 5
84365: PUSH
84366: LD_INT 6
84368: EQUAL
84369: IFFALSE 84419
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84371: LD_ADDR_EXP 93
84375: PUSH
84376: LD_EXP 93
84380: PPUSH
84381: LD_VAR 0 3
84385: PUSH
84386: LD_EXP 93
84390: PUSH
84391: LD_VAR 0 3
84395: ARRAY
84396: PUSH
84397: LD_INT 1
84399: PLUS
84400: PUSH
84401: EMPTY
84402: LIST
84403: LIST
84404: PPUSH
84405: LD_VAR 0 1
84409: PPUSH
84410: CALL 19801 0 3
84414: ST_TO_ADDR
// exit ;
84415: POP
84416: POP
84417: GO 84875
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84419: LD_VAR 0 5
84423: PUSH
84424: LD_INT 0
84426: PUSH
84427: LD_INT 2
84429: PUSH
84430: LD_INT 4
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: LIST
84437: IN
84438: IFFALSE 84562
// begin if btype = b_armoury then
84440: LD_VAR 0 5
84444: PUSH
84445: LD_INT 4
84447: EQUAL
84448: IFFALSE 84458
// btype := b_barracks ;
84450: LD_ADDR_VAR 0 5
84454: PUSH
84455: LD_INT 5
84457: ST_TO_ADDR
// if btype = b_depot then
84458: LD_VAR 0 5
84462: PUSH
84463: LD_INT 0
84465: EQUAL
84466: IFFALSE 84476
// btype := b_warehouse ;
84468: LD_ADDR_VAR 0 5
84472: PUSH
84473: LD_INT 1
84475: ST_TO_ADDR
// if btype = b_workshop then
84476: LD_VAR 0 5
84480: PUSH
84481: LD_INT 2
84483: EQUAL
84484: IFFALSE 84494
// btype := b_factory ;
84486: LD_ADDR_VAR 0 5
84490: PUSH
84491: LD_INT 3
84493: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84494: LD_VAR 0 5
84498: PPUSH
84499: LD_VAR 0 8
84503: PPUSH
84504: CALL_OW 323
84508: PUSH
84509: LD_INT 1
84511: EQUAL
84512: IFFALSE 84558
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84514: LD_ADDR_EXP 92
84518: PUSH
84519: LD_EXP 92
84523: PPUSH
84524: LD_VAR 0 3
84528: PUSH
84529: LD_EXP 92
84533: PUSH
84534: LD_VAR 0 3
84538: ARRAY
84539: PUSH
84540: LD_INT 1
84542: PLUS
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: PPUSH
84548: LD_VAR 0 1
84552: PPUSH
84553: CALL 19801 0 3
84557: ST_TO_ADDR
// exit ;
84558: POP
84559: POP
84560: GO 84875
// end ; if btype in [ b_bunker , b_turret ] then
84562: LD_VAR 0 5
84566: PUSH
84567: LD_INT 32
84569: PUSH
84570: LD_INT 33
84572: PUSH
84573: EMPTY
84574: LIST
84575: LIST
84576: IN
84577: IFFALSE 84867
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84579: LD_ADDR_EXP 68
84583: PUSH
84584: LD_EXP 68
84588: PPUSH
84589: LD_VAR 0 3
84593: PUSH
84594: LD_EXP 68
84598: PUSH
84599: LD_VAR 0 3
84603: ARRAY
84604: PUSH
84605: LD_INT 1
84607: PLUS
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PPUSH
84613: LD_VAR 0 1
84617: PPUSH
84618: CALL 19801 0 3
84622: ST_TO_ADDR
// if btype = b_bunker then
84623: LD_VAR 0 5
84627: PUSH
84628: LD_INT 32
84630: EQUAL
84631: IFFALSE 84867
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84633: LD_ADDR_EXP 69
84637: PUSH
84638: LD_EXP 69
84642: PPUSH
84643: LD_VAR 0 3
84647: PUSH
84648: LD_EXP 69
84652: PUSH
84653: LD_VAR 0 3
84657: ARRAY
84658: PUSH
84659: LD_INT 1
84661: PLUS
84662: PUSH
84663: EMPTY
84664: LIST
84665: LIST
84666: PPUSH
84667: LD_VAR 0 1
84671: PPUSH
84672: CALL 19801 0 3
84676: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84677: LD_ADDR_VAR 0 6
84681: PUSH
84682: LD_EXP 60
84686: PUSH
84687: LD_VAR 0 3
84691: ARRAY
84692: PPUSH
84693: LD_INT 25
84695: PUSH
84696: LD_INT 1
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 3
84705: PUSH
84706: LD_INT 54
84708: PUSH
84709: EMPTY
84710: LIST
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PPUSH
84720: CALL_OW 72
84724: ST_TO_ADDR
// if tmp then
84725: LD_VAR 0 6
84729: IFFALSE 84735
// exit ;
84731: POP
84732: POP
84733: GO 84875
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84735: LD_ADDR_VAR 0 6
84739: PUSH
84740: LD_EXP 60
84744: PUSH
84745: LD_VAR 0 3
84749: ARRAY
84750: PPUSH
84751: LD_INT 2
84753: PUSH
84754: LD_INT 30
84756: PUSH
84757: LD_INT 4
84759: PUSH
84760: EMPTY
84761: LIST
84762: LIST
84763: PUSH
84764: LD_INT 30
84766: PUSH
84767: LD_INT 5
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: LIST
84778: PPUSH
84779: CALL_OW 72
84783: ST_TO_ADDR
// if not tmp then
84784: LD_VAR 0 6
84788: NOT
84789: IFFALSE 84795
// exit ;
84791: POP
84792: POP
84793: GO 84875
// for j in tmp do
84795: LD_ADDR_VAR 0 4
84799: PUSH
84800: LD_VAR 0 6
84804: PUSH
84805: FOR_IN
84806: IFFALSE 84865
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
84808: LD_ADDR_VAR 0 7
84812: PUSH
84813: LD_VAR 0 4
84817: PPUSH
84818: CALL_OW 313
84822: PPUSH
84823: LD_INT 25
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PPUSH
84833: CALL_OW 72
84837: ST_TO_ADDR
// if units then
84838: LD_VAR 0 7
84842: IFFALSE 84863
// begin ComExitBuilding ( units [ 1 ] ) ;
84844: LD_VAR 0 7
84848: PUSH
84849: LD_INT 1
84851: ARRAY
84852: PPUSH
84853: CALL_OW 122
// exit ;
84857: POP
84858: POP
84859: POP
84860: POP
84861: GO 84875
// end ; end ;
84863: GO 84805
84865: POP
84866: POP
// end ; end ; exit ;
84867: POP
84868: POP
84869: GO 84875
// end ; end ;
84871: GO 84229
84873: POP
84874: POP
// end ;
84875: LD_VAR 0 2
84879: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
84880: LD_INT 0
84882: PPUSH
84883: PPUSH
84884: PPUSH
84885: PPUSH
84886: PPUSH
84887: PPUSH
84888: PPUSH
// if not mc_bases or not skirmish then
84889: LD_EXP 60
84893: NOT
84894: PUSH
84895: LD_EXP 58
84899: NOT
84900: OR
84901: IFFALSE 84905
// exit ;
84903: GO 85170
// btype := GetBType ( building ) ;
84905: LD_ADDR_VAR 0 6
84909: PUSH
84910: LD_VAR 0 1
84914: PPUSH
84915: CALL_OW 266
84919: ST_TO_ADDR
// x := GetX ( building ) ;
84920: LD_ADDR_VAR 0 7
84924: PUSH
84925: LD_VAR 0 1
84929: PPUSH
84930: CALL_OW 250
84934: ST_TO_ADDR
// y := GetY ( building ) ;
84935: LD_ADDR_VAR 0 8
84939: PUSH
84940: LD_VAR 0 1
84944: PPUSH
84945: CALL_OW 251
84949: ST_TO_ADDR
// d := GetDir ( building ) ;
84950: LD_ADDR_VAR 0 9
84954: PUSH
84955: LD_VAR 0 1
84959: PPUSH
84960: CALL_OW 254
84964: ST_TO_ADDR
// for i = 1 to mc_bases do
84965: LD_ADDR_VAR 0 4
84969: PUSH
84970: DOUBLE
84971: LD_INT 1
84973: DEC
84974: ST_TO_ADDR
84975: LD_EXP 60
84979: PUSH
84980: FOR_TO
84981: IFFALSE 85168
// begin if not mc_build_list [ i ] then
84983: LD_EXP 65
84987: PUSH
84988: LD_VAR 0 4
84992: ARRAY
84993: NOT
84994: IFFALSE 84998
// continue ;
84996: GO 84980
// for j := 1 to mc_build_list [ i ] do
84998: LD_ADDR_VAR 0 5
85002: PUSH
85003: DOUBLE
85004: LD_INT 1
85006: DEC
85007: ST_TO_ADDR
85008: LD_EXP 65
85012: PUSH
85013: LD_VAR 0 4
85017: ARRAY
85018: PUSH
85019: FOR_TO
85020: IFFALSE 85164
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
85022: LD_VAR 0 6
85026: PUSH
85027: LD_VAR 0 7
85031: PUSH
85032: LD_VAR 0 8
85036: PUSH
85037: LD_VAR 0 9
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: LIST
85046: LIST
85047: PPUSH
85048: LD_EXP 65
85052: PUSH
85053: LD_VAR 0 4
85057: ARRAY
85058: PUSH
85059: LD_VAR 0 5
85063: ARRAY
85064: PPUSH
85065: CALL 25983 0 2
85069: IFFALSE 85162
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
85071: LD_ADDR_EXP 65
85075: PUSH
85076: LD_EXP 65
85080: PPUSH
85081: LD_VAR 0 4
85085: PPUSH
85086: LD_EXP 65
85090: PUSH
85091: LD_VAR 0 4
85095: ARRAY
85096: PPUSH
85097: LD_VAR 0 5
85101: PPUSH
85102: CALL_OW 3
85106: PPUSH
85107: CALL_OW 1
85111: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85112: LD_ADDR_EXP 67
85116: PUSH
85117: LD_EXP 67
85121: PPUSH
85122: LD_VAR 0 4
85126: PUSH
85127: LD_EXP 67
85131: PUSH
85132: LD_VAR 0 4
85136: ARRAY
85137: PUSH
85138: LD_INT 1
85140: PLUS
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PPUSH
85146: LD_VAR 0 1
85150: PPUSH
85151: CALL 19801 0 3
85155: ST_TO_ADDR
// exit ;
85156: POP
85157: POP
85158: POP
85159: POP
85160: GO 85170
// end ;
85162: GO 85019
85164: POP
85165: POP
// end ;
85166: GO 84980
85168: POP
85169: POP
// end ;
85170: LD_VAR 0 3
85174: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85175: LD_INT 0
85177: PPUSH
85178: PPUSH
85179: PPUSH
// if not mc_bases or not skirmish then
85180: LD_EXP 60
85184: NOT
85185: PUSH
85186: LD_EXP 58
85190: NOT
85191: OR
85192: IFFALSE 85196
// exit ;
85194: GO 85386
// for i = 1 to mc_bases do
85196: LD_ADDR_VAR 0 4
85200: PUSH
85201: DOUBLE
85202: LD_INT 1
85204: DEC
85205: ST_TO_ADDR
85206: LD_EXP 60
85210: PUSH
85211: FOR_TO
85212: IFFALSE 85299
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85214: LD_VAR 0 1
85218: PUSH
85219: LD_EXP 68
85223: PUSH
85224: LD_VAR 0 4
85228: ARRAY
85229: IN
85230: PUSH
85231: LD_VAR 0 1
85235: PUSH
85236: LD_EXP 69
85240: PUSH
85241: LD_VAR 0 4
85245: ARRAY
85246: IN
85247: NOT
85248: AND
85249: IFFALSE 85297
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85251: LD_ADDR_EXP 69
85255: PUSH
85256: LD_EXP 69
85260: PPUSH
85261: LD_VAR 0 4
85265: PUSH
85266: LD_EXP 69
85270: PUSH
85271: LD_VAR 0 4
85275: ARRAY
85276: PUSH
85277: LD_INT 1
85279: PLUS
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PPUSH
85285: LD_VAR 0 1
85289: PPUSH
85290: CALL 19801 0 3
85294: ST_TO_ADDR
// break ;
85295: GO 85299
// end ; end ;
85297: GO 85211
85299: POP
85300: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85301: LD_VAR 0 1
85305: PPUSH
85306: CALL_OW 257
85310: PUSH
85311: LD_EXP 86
85315: IN
85316: PUSH
85317: LD_VAR 0 1
85321: PPUSH
85322: CALL_OW 266
85326: PUSH
85327: LD_INT 5
85329: EQUAL
85330: AND
85331: PUSH
85332: LD_VAR 0 2
85336: PPUSH
85337: CALL_OW 110
85341: PUSH
85342: LD_INT 18
85344: NONEQUAL
85345: AND
85346: IFFALSE 85386
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85348: LD_VAR 0 2
85352: PPUSH
85353: CALL_OW 257
85357: PUSH
85358: LD_INT 5
85360: PUSH
85361: LD_INT 8
85363: PUSH
85364: LD_INT 9
85366: PUSH
85367: EMPTY
85368: LIST
85369: LIST
85370: LIST
85371: IN
85372: IFFALSE 85386
// SetClass ( unit , 1 ) ;
85374: LD_VAR 0 2
85378: PPUSH
85379: LD_INT 1
85381: PPUSH
85382: CALL_OW 336
// end ;
85386: LD_VAR 0 3
85390: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85391: LD_INT 0
85393: PPUSH
85394: PPUSH
// if not mc_bases or not skirmish then
85395: LD_EXP 60
85399: NOT
85400: PUSH
85401: LD_EXP 58
85405: NOT
85406: OR
85407: IFFALSE 85411
// exit ;
85409: GO 85527
// if GetLives ( abandoned_vehicle ) > 250 then
85411: LD_VAR 0 2
85415: PPUSH
85416: CALL_OW 256
85420: PUSH
85421: LD_INT 250
85423: GREATER
85424: IFFALSE 85428
// exit ;
85426: GO 85527
// for i = 1 to mc_bases do
85428: LD_ADDR_VAR 0 6
85432: PUSH
85433: DOUBLE
85434: LD_INT 1
85436: DEC
85437: ST_TO_ADDR
85438: LD_EXP 60
85442: PUSH
85443: FOR_TO
85444: IFFALSE 85525
// begin if driver in mc_bases [ i ] then
85446: LD_VAR 0 1
85450: PUSH
85451: LD_EXP 60
85455: PUSH
85456: LD_VAR 0 6
85460: ARRAY
85461: IN
85462: IFFALSE 85523
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85464: LD_VAR 0 1
85468: PPUSH
85469: LD_EXP 60
85473: PUSH
85474: LD_VAR 0 6
85478: ARRAY
85479: PPUSH
85480: LD_INT 2
85482: PUSH
85483: LD_INT 30
85485: PUSH
85486: LD_INT 0
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 30
85495: PUSH
85496: LD_INT 1
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: EMPTY
85504: LIST
85505: LIST
85506: LIST
85507: PPUSH
85508: CALL_OW 72
85512: PUSH
85513: LD_INT 1
85515: ARRAY
85516: PPUSH
85517: CALL 52419 0 2
// break ;
85521: GO 85525
// end ; end ;
85523: GO 85443
85525: POP
85526: POP
// end ; end_of_file
85527: LD_VAR 0 5
85531: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
85532: LD_INT 0
85534: PPUSH
// ar_miner := 81 ;
85535: LD_ADDR_EXP 111
85539: PUSH
85540: LD_INT 81
85542: ST_TO_ADDR
// ar_crane := 88 ;
85543: LD_ADDR_EXP 110
85547: PUSH
85548: LD_INT 88
85550: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85551: LD_ADDR_EXP 105
85555: PUSH
85556: LD_INT 89
85558: ST_TO_ADDR
// us_hack := 99 ;
85559: LD_ADDR_EXP 106
85563: PUSH
85564: LD_INT 99
85566: ST_TO_ADDR
// us_artillery := 97 ;
85567: LD_ADDR_EXP 107
85571: PUSH
85572: LD_INT 97
85574: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85575: LD_ADDR_EXP 108
85579: PUSH
85580: LD_INT 91
85582: ST_TO_ADDR
// ar_mortar := 92 ;
85583: LD_ADDR_EXP 109
85587: PUSH
85588: LD_INT 92
85590: ST_TO_ADDR
// ru_radar := 98 ;
85591: LD_ADDR_EXP 104
85595: PUSH
85596: LD_INT 98
85598: ST_TO_ADDR
// tech_Artillery := 80 ;
85599: LD_ADDR_EXP 112
85603: PUSH
85604: LD_INT 80
85606: ST_TO_ADDR
// tech_RadMat := 81 ;
85607: LD_ADDR_EXP 113
85611: PUSH
85612: LD_INT 81
85614: ST_TO_ADDR
// tech_BasicTools := 82 ;
85615: LD_ADDR_EXP 114
85619: PUSH
85620: LD_INT 82
85622: ST_TO_ADDR
// tech_Cargo := 83 ;
85623: LD_ADDR_EXP 115
85627: PUSH
85628: LD_INT 83
85630: ST_TO_ADDR
// tech_Track := 84 ;
85631: LD_ADDR_EXP 116
85635: PUSH
85636: LD_INT 84
85638: ST_TO_ADDR
// tech_Crane := 85 ;
85639: LD_ADDR_EXP 117
85643: PUSH
85644: LD_INT 85
85646: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85647: LD_ADDR_EXP 118
85651: PUSH
85652: LD_INT 86
85654: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85655: LD_ADDR_EXP 119
85659: PUSH
85660: LD_INT 87
85662: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
85663: LD_ADDR_EXP 120
85667: PUSH
85668: LD_INT 88
85670: ST_TO_ADDR
// class_mastodont := 31 ;
85671: LD_ADDR_EXP 121
85675: PUSH
85676: LD_INT 31
85678: ST_TO_ADDR
// class_horse := 21 ;
85679: LD_ADDR_EXP 122
85683: PUSH
85684: LD_INT 21
85686: ST_TO_ADDR
// end ;
85687: LD_VAR 0 1
85691: RET
// every 1 do
85692: GO 85694
85694: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85695: CALL 85532 0 0
85699: END
// every 0 0$1 do
85700: GO 85702
85702: DISABLE
// begin enable ;
85703: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
85704: LD_STRING updateTimer(
85706: PUSH
85707: LD_OWVAR 1
85711: STR
85712: PUSH
85713: LD_STRING );
85715: STR
85716: PPUSH
85717: CALL_OW 559
// end ;
85721: END
// on MapStart ( p ) do begin if streamModeActive then
85722: LD_EXP 123
85726: IFFALSE 85735
// DefineStreamItems ( true ) ;
85728: LD_INT 1
85730: PPUSH
85731: CALL 87383 0 1
// UpdateFactoryWaypoints ( ) ;
85735: CALL 100967 0 0
// end ;
85739: PPOPN 1
85741: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
85742: LD_INT 0
85744: PPUSH
// if p2 = 100 then
85745: LD_VAR 0 2
85749: PUSH
85750: LD_INT 100
85752: EQUAL
85753: IFFALSE 86756
// begin if not StreamModeActive then
85755: LD_EXP 123
85759: NOT
85760: IFFALSE 85770
// StreamModeActive := true ;
85762: LD_ADDR_EXP 123
85766: PUSH
85767: LD_INT 1
85769: ST_TO_ADDR
// if p3 = 0 then
85770: LD_VAR 0 3
85774: PUSH
85775: LD_INT 0
85777: EQUAL
85778: IFFALSE 85784
// InitStreamMode ;
85780: CALL 86919 0 0
// if p3 = 1 then
85784: LD_VAR 0 3
85788: PUSH
85789: LD_INT 1
85791: EQUAL
85792: IFFALSE 85802
// sRocket := true ;
85794: LD_ADDR_EXP 128
85798: PUSH
85799: LD_INT 1
85801: ST_TO_ADDR
// if p3 = 2 then
85802: LD_VAR 0 3
85806: PUSH
85807: LD_INT 2
85809: EQUAL
85810: IFFALSE 85820
// sSpeed := true ;
85812: LD_ADDR_EXP 127
85816: PUSH
85817: LD_INT 1
85819: ST_TO_ADDR
// if p3 = 3 then
85820: LD_VAR 0 3
85824: PUSH
85825: LD_INT 3
85827: EQUAL
85828: IFFALSE 85838
// sEngine := true ;
85830: LD_ADDR_EXP 129
85834: PUSH
85835: LD_INT 1
85837: ST_TO_ADDR
// if p3 = 4 then
85838: LD_VAR 0 3
85842: PUSH
85843: LD_INT 4
85845: EQUAL
85846: IFFALSE 85856
// sSpec := true ;
85848: LD_ADDR_EXP 126
85852: PUSH
85853: LD_INT 1
85855: ST_TO_ADDR
// if p3 = 5 then
85856: LD_VAR 0 3
85860: PUSH
85861: LD_INT 5
85863: EQUAL
85864: IFFALSE 85874
// sLevel := true ;
85866: LD_ADDR_EXP 130
85870: PUSH
85871: LD_INT 1
85873: ST_TO_ADDR
// if p3 = 6 then
85874: LD_VAR 0 3
85878: PUSH
85879: LD_INT 6
85881: EQUAL
85882: IFFALSE 85892
// sArmoury := true ;
85884: LD_ADDR_EXP 131
85888: PUSH
85889: LD_INT 1
85891: ST_TO_ADDR
// if p3 = 7 then
85892: LD_VAR 0 3
85896: PUSH
85897: LD_INT 7
85899: EQUAL
85900: IFFALSE 85910
// sRadar := true ;
85902: LD_ADDR_EXP 132
85906: PUSH
85907: LD_INT 1
85909: ST_TO_ADDR
// if p3 = 8 then
85910: LD_VAR 0 3
85914: PUSH
85915: LD_INT 8
85917: EQUAL
85918: IFFALSE 85928
// sBunker := true ;
85920: LD_ADDR_EXP 133
85924: PUSH
85925: LD_INT 1
85927: ST_TO_ADDR
// if p3 = 9 then
85928: LD_VAR 0 3
85932: PUSH
85933: LD_INT 9
85935: EQUAL
85936: IFFALSE 85946
// sHack := true ;
85938: LD_ADDR_EXP 134
85942: PUSH
85943: LD_INT 1
85945: ST_TO_ADDR
// if p3 = 10 then
85946: LD_VAR 0 3
85950: PUSH
85951: LD_INT 10
85953: EQUAL
85954: IFFALSE 85964
// sFire := true ;
85956: LD_ADDR_EXP 135
85960: PUSH
85961: LD_INT 1
85963: ST_TO_ADDR
// if p3 = 11 then
85964: LD_VAR 0 3
85968: PUSH
85969: LD_INT 11
85971: EQUAL
85972: IFFALSE 85982
// sRefresh := true ;
85974: LD_ADDR_EXP 136
85978: PUSH
85979: LD_INT 1
85981: ST_TO_ADDR
// if p3 = 12 then
85982: LD_VAR 0 3
85986: PUSH
85987: LD_INT 12
85989: EQUAL
85990: IFFALSE 86000
// sExp := true ;
85992: LD_ADDR_EXP 137
85996: PUSH
85997: LD_INT 1
85999: ST_TO_ADDR
// if p3 = 13 then
86000: LD_VAR 0 3
86004: PUSH
86005: LD_INT 13
86007: EQUAL
86008: IFFALSE 86018
// sDepot := true ;
86010: LD_ADDR_EXP 138
86014: PUSH
86015: LD_INT 1
86017: ST_TO_ADDR
// if p3 = 14 then
86018: LD_VAR 0 3
86022: PUSH
86023: LD_INT 14
86025: EQUAL
86026: IFFALSE 86036
// sFlag := true ;
86028: LD_ADDR_EXP 139
86032: PUSH
86033: LD_INT 1
86035: ST_TO_ADDR
// if p3 = 15 then
86036: LD_VAR 0 3
86040: PUSH
86041: LD_INT 15
86043: EQUAL
86044: IFFALSE 86054
// sKamikadze := true ;
86046: LD_ADDR_EXP 147
86050: PUSH
86051: LD_INT 1
86053: ST_TO_ADDR
// if p3 = 16 then
86054: LD_VAR 0 3
86058: PUSH
86059: LD_INT 16
86061: EQUAL
86062: IFFALSE 86072
// sTroll := true ;
86064: LD_ADDR_EXP 148
86068: PUSH
86069: LD_INT 1
86071: ST_TO_ADDR
// if p3 = 17 then
86072: LD_VAR 0 3
86076: PUSH
86077: LD_INT 17
86079: EQUAL
86080: IFFALSE 86090
// sSlow := true ;
86082: LD_ADDR_EXP 149
86086: PUSH
86087: LD_INT 1
86089: ST_TO_ADDR
// if p3 = 18 then
86090: LD_VAR 0 3
86094: PUSH
86095: LD_INT 18
86097: EQUAL
86098: IFFALSE 86108
// sLack := true ;
86100: LD_ADDR_EXP 150
86104: PUSH
86105: LD_INT 1
86107: ST_TO_ADDR
// if p3 = 19 then
86108: LD_VAR 0 3
86112: PUSH
86113: LD_INT 19
86115: EQUAL
86116: IFFALSE 86126
// sTank := true ;
86118: LD_ADDR_EXP 152
86122: PUSH
86123: LD_INT 1
86125: ST_TO_ADDR
// if p3 = 20 then
86126: LD_VAR 0 3
86130: PUSH
86131: LD_INT 20
86133: EQUAL
86134: IFFALSE 86144
// sRemote := true ;
86136: LD_ADDR_EXP 153
86140: PUSH
86141: LD_INT 1
86143: ST_TO_ADDR
// if p3 = 21 then
86144: LD_VAR 0 3
86148: PUSH
86149: LD_INT 21
86151: EQUAL
86152: IFFALSE 86162
// sPowell := true ;
86154: LD_ADDR_EXP 154
86158: PUSH
86159: LD_INT 1
86161: ST_TO_ADDR
// if p3 = 22 then
86162: LD_VAR 0 3
86166: PUSH
86167: LD_INT 22
86169: EQUAL
86170: IFFALSE 86180
// sTeleport := true ;
86172: LD_ADDR_EXP 157
86176: PUSH
86177: LD_INT 1
86179: ST_TO_ADDR
// if p3 = 23 then
86180: LD_VAR 0 3
86184: PUSH
86185: LD_INT 23
86187: EQUAL
86188: IFFALSE 86198
// sOilTower := true ;
86190: LD_ADDR_EXP 159
86194: PUSH
86195: LD_INT 1
86197: ST_TO_ADDR
// if p3 = 24 then
86198: LD_VAR 0 3
86202: PUSH
86203: LD_INT 24
86205: EQUAL
86206: IFFALSE 86216
// sShovel := true ;
86208: LD_ADDR_EXP 160
86212: PUSH
86213: LD_INT 1
86215: ST_TO_ADDR
// if p3 = 25 then
86216: LD_VAR 0 3
86220: PUSH
86221: LD_INT 25
86223: EQUAL
86224: IFFALSE 86234
// sSheik := true ;
86226: LD_ADDR_EXP 161
86230: PUSH
86231: LD_INT 1
86233: ST_TO_ADDR
// if p3 = 26 then
86234: LD_VAR 0 3
86238: PUSH
86239: LD_INT 26
86241: EQUAL
86242: IFFALSE 86252
// sEarthquake := true ;
86244: LD_ADDR_EXP 163
86248: PUSH
86249: LD_INT 1
86251: ST_TO_ADDR
// if p3 = 27 then
86252: LD_VAR 0 3
86256: PUSH
86257: LD_INT 27
86259: EQUAL
86260: IFFALSE 86270
// sAI := true ;
86262: LD_ADDR_EXP 164
86266: PUSH
86267: LD_INT 1
86269: ST_TO_ADDR
// if p3 = 28 then
86270: LD_VAR 0 3
86274: PUSH
86275: LD_INT 28
86277: EQUAL
86278: IFFALSE 86288
// sCargo := true ;
86280: LD_ADDR_EXP 167
86284: PUSH
86285: LD_INT 1
86287: ST_TO_ADDR
// if p3 = 29 then
86288: LD_VAR 0 3
86292: PUSH
86293: LD_INT 29
86295: EQUAL
86296: IFFALSE 86306
// sDLaser := true ;
86298: LD_ADDR_EXP 168
86302: PUSH
86303: LD_INT 1
86305: ST_TO_ADDR
// if p3 = 30 then
86306: LD_VAR 0 3
86310: PUSH
86311: LD_INT 30
86313: EQUAL
86314: IFFALSE 86324
// sExchange := true ;
86316: LD_ADDR_EXP 169
86320: PUSH
86321: LD_INT 1
86323: ST_TO_ADDR
// if p3 = 31 then
86324: LD_VAR 0 3
86328: PUSH
86329: LD_INT 31
86331: EQUAL
86332: IFFALSE 86342
// sFac := true ;
86334: LD_ADDR_EXP 170
86338: PUSH
86339: LD_INT 1
86341: ST_TO_ADDR
// if p3 = 32 then
86342: LD_VAR 0 3
86346: PUSH
86347: LD_INT 32
86349: EQUAL
86350: IFFALSE 86360
// sPower := true ;
86352: LD_ADDR_EXP 171
86356: PUSH
86357: LD_INT 1
86359: ST_TO_ADDR
// if p3 = 33 then
86360: LD_VAR 0 3
86364: PUSH
86365: LD_INT 33
86367: EQUAL
86368: IFFALSE 86378
// sRandom := true ;
86370: LD_ADDR_EXP 172
86374: PUSH
86375: LD_INT 1
86377: ST_TO_ADDR
// if p3 = 34 then
86378: LD_VAR 0 3
86382: PUSH
86383: LD_INT 34
86385: EQUAL
86386: IFFALSE 86396
// sShield := true ;
86388: LD_ADDR_EXP 173
86392: PUSH
86393: LD_INT 1
86395: ST_TO_ADDR
// if p3 = 35 then
86396: LD_VAR 0 3
86400: PUSH
86401: LD_INT 35
86403: EQUAL
86404: IFFALSE 86414
// sTime := true ;
86406: LD_ADDR_EXP 174
86410: PUSH
86411: LD_INT 1
86413: ST_TO_ADDR
// if p3 = 36 then
86414: LD_VAR 0 3
86418: PUSH
86419: LD_INT 36
86421: EQUAL
86422: IFFALSE 86432
// sTools := true ;
86424: LD_ADDR_EXP 175
86428: PUSH
86429: LD_INT 1
86431: ST_TO_ADDR
// if p3 = 101 then
86432: LD_VAR 0 3
86436: PUSH
86437: LD_INT 101
86439: EQUAL
86440: IFFALSE 86450
// sSold := true ;
86442: LD_ADDR_EXP 140
86446: PUSH
86447: LD_INT 1
86449: ST_TO_ADDR
// if p3 = 102 then
86450: LD_VAR 0 3
86454: PUSH
86455: LD_INT 102
86457: EQUAL
86458: IFFALSE 86468
// sDiff := true ;
86460: LD_ADDR_EXP 141
86464: PUSH
86465: LD_INT 1
86467: ST_TO_ADDR
// if p3 = 103 then
86468: LD_VAR 0 3
86472: PUSH
86473: LD_INT 103
86475: EQUAL
86476: IFFALSE 86486
// sFog := true ;
86478: LD_ADDR_EXP 144
86482: PUSH
86483: LD_INT 1
86485: ST_TO_ADDR
// if p3 = 104 then
86486: LD_VAR 0 3
86490: PUSH
86491: LD_INT 104
86493: EQUAL
86494: IFFALSE 86504
// sReset := true ;
86496: LD_ADDR_EXP 145
86500: PUSH
86501: LD_INT 1
86503: ST_TO_ADDR
// if p3 = 105 then
86504: LD_VAR 0 3
86508: PUSH
86509: LD_INT 105
86511: EQUAL
86512: IFFALSE 86522
// sSun := true ;
86514: LD_ADDR_EXP 146
86518: PUSH
86519: LD_INT 1
86521: ST_TO_ADDR
// if p3 = 106 then
86522: LD_VAR 0 3
86526: PUSH
86527: LD_INT 106
86529: EQUAL
86530: IFFALSE 86540
// sTiger := true ;
86532: LD_ADDR_EXP 142
86536: PUSH
86537: LD_INT 1
86539: ST_TO_ADDR
// if p3 = 107 then
86540: LD_VAR 0 3
86544: PUSH
86545: LD_INT 107
86547: EQUAL
86548: IFFALSE 86558
// sBomb := true ;
86550: LD_ADDR_EXP 143
86554: PUSH
86555: LD_INT 1
86557: ST_TO_ADDR
// if p3 = 108 then
86558: LD_VAR 0 3
86562: PUSH
86563: LD_INT 108
86565: EQUAL
86566: IFFALSE 86576
// sWound := true ;
86568: LD_ADDR_EXP 151
86572: PUSH
86573: LD_INT 1
86575: ST_TO_ADDR
// if p3 = 109 then
86576: LD_VAR 0 3
86580: PUSH
86581: LD_INT 109
86583: EQUAL
86584: IFFALSE 86594
// sBetray := true ;
86586: LD_ADDR_EXP 155
86590: PUSH
86591: LD_INT 1
86593: ST_TO_ADDR
// if p3 = 110 then
86594: LD_VAR 0 3
86598: PUSH
86599: LD_INT 110
86601: EQUAL
86602: IFFALSE 86612
// sContamin := true ;
86604: LD_ADDR_EXP 156
86608: PUSH
86609: LD_INT 1
86611: ST_TO_ADDR
// if p3 = 111 then
86612: LD_VAR 0 3
86616: PUSH
86617: LD_INT 111
86619: EQUAL
86620: IFFALSE 86630
// sOil := true ;
86622: LD_ADDR_EXP 158
86626: PUSH
86627: LD_INT 1
86629: ST_TO_ADDR
// if p3 = 112 then
86630: LD_VAR 0 3
86634: PUSH
86635: LD_INT 112
86637: EQUAL
86638: IFFALSE 86648
// sStu := true ;
86640: LD_ADDR_EXP 162
86644: PUSH
86645: LD_INT 1
86647: ST_TO_ADDR
// if p3 = 113 then
86648: LD_VAR 0 3
86652: PUSH
86653: LD_INT 113
86655: EQUAL
86656: IFFALSE 86666
// sBazooka := true ;
86658: LD_ADDR_EXP 165
86662: PUSH
86663: LD_INT 1
86665: ST_TO_ADDR
// if p3 = 114 then
86666: LD_VAR 0 3
86670: PUSH
86671: LD_INT 114
86673: EQUAL
86674: IFFALSE 86684
// sMortar := true ;
86676: LD_ADDR_EXP 166
86680: PUSH
86681: LD_INT 1
86683: ST_TO_ADDR
// if p3 = 115 then
86684: LD_VAR 0 3
86688: PUSH
86689: LD_INT 115
86691: EQUAL
86692: IFFALSE 86702
// sRanger := true ;
86694: LD_ADDR_EXP 176
86698: PUSH
86699: LD_INT 1
86701: ST_TO_ADDR
// if p3 = 116 then
86702: LD_VAR 0 3
86706: PUSH
86707: LD_INT 116
86709: EQUAL
86710: IFFALSE 86720
// sComputer := true ;
86712: LD_ADDR_EXP 177
86716: PUSH
86717: LD_INT 1
86719: ST_TO_ADDR
// if p3 = 117 then
86720: LD_VAR 0 3
86724: PUSH
86725: LD_INT 117
86727: EQUAL
86728: IFFALSE 86738
// s30 := true ;
86730: LD_ADDR_EXP 178
86734: PUSH
86735: LD_INT 1
86737: ST_TO_ADDR
// if p3 = 118 then
86738: LD_VAR 0 3
86742: PUSH
86743: LD_INT 118
86745: EQUAL
86746: IFFALSE 86756
// s60 := true ;
86748: LD_ADDR_EXP 179
86752: PUSH
86753: LD_INT 1
86755: ST_TO_ADDR
// end ; if p2 = 101 then
86756: LD_VAR 0 2
86760: PUSH
86761: LD_INT 101
86763: EQUAL
86764: IFFALSE 86892
// begin case p3 of 1 :
86766: LD_VAR 0 3
86770: PUSH
86771: LD_INT 1
86773: DOUBLE
86774: EQUAL
86775: IFTRUE 86779
86777: GO 86786
86779: POP
// hHackUnlimitedResources ; 2 :
86780: CALL 98990 0 0
86784: GO 86892
86786: LD_INT 2
86788: DOUBLE
86789: EQUAL
86790: IFTRUE 86794
86792: GO 86801
86794: POP
// hHackSetLevel10 ; 3 :
86795: CALL 99123 0 0
86799: GO 86892
86801: LD_INT 3
86803: DOUBLE
86804: EQUAL
86805: IFTRUE 86809
86807: GO 86816
86809: POP
// hHackSetLevel10YourUnits ; 4 :
86810: CALL 99208 0 0
86814: GO 86892
86816: LD_INT 4
86818: DOUBLE
86819: EQUAL
86820: IFTRUE 86824
86822: GO 86831
86824: POP
// hHackInvincible ; 5 :
86825: CALL 99656 0 0
86829: GO 86892
86831: LD_INT 5
86833: DOUBLE
86834: EQUAL
86835: IFTRUE 86839
86837: GO 86846
86839: POP
// hHackInvisible ; 6 :
86840: CALL 99767 0 0
86844: GO 86892
86846: LD_INT 6
86848: DOUBLE
86849: EQUAL
86850: IFTRUE 86854
86852: GO 86861
86854: POP
// hHackChangeYourSide ; 7 :
86855: CALL 99824 0 0
86859: GO 86892
86861: LD_INT 7
86863: DOUBLE
86864: EQUAL
86865: IFTRUE 86869
86867: GO 86876
86869: POP
// hHackChangeUnitSide ; 8 :
86870: CALL 99866 0 0
86874: GO 86892
86876: LD_INT 8
86878: DOUBLE
86879: EQUAL
86880: IFTRUE 86884
86882: GO 86891
86884: POP
// hHackFog ; end ;
86885: CALL 99967 0 0
86889: GO 86892
86891: POP
// end ; end ;
86892: LD_VAR 0 7
86896: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
86897: GO 86899
86899: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86900: LD_STRING initStreamRollete();
86902: PPUSH
86903: CALL_OW 559
// InitStreamMode ;
86907: CALL 86919 0 0
// DefineStreamItems ( false ) ;
86911: LD_INT 0
86913: PPUSH
86914: CALL 87383 0 1
// end ;
86918: END
// function InitStreamMode ; begin
86919: LD_INT 0
86921: PPUSH
// streamModeActive := false ;
86922: LD_ADDR_EXP 123
86926: PUSH
86927: LD_INT 0
86929: ST_TO_ADDR
// normalCounter := 36 ;
86930: LD_ADDR_EXP 124
86934: PUSH
86935: LD_INT 36
86937: ST_TO_ADDR
// hardcoreCounter := 18 ;
86938: LD_ADDR_EXP 125
86942: PUSH
86943: LD_INT 18
86945: ST_TO_ADDR
// sRocket := false ;
86946: LD_ADDR_EXP 128
86950: PUSH
86951: LD_INT 0
86953: ST_TO_ADDR
// sSpeed := false ;
86954: LD_ADDR_EXP 127
86958: PUSH
86959: LD_INT 0
86961: ST_TO_ADDR
// sEngine := false ;
86962: LD_ADDR_EXP 129
86966: PUSH
86967: LD_INT 0
86969: ST_TO_ADDR
// sSpec := false ;
86970: LD_ADDR_EXP 126
86974: PUSH
86975: LD_INT 0
86977: ST_TO_ADDR
// sLevel := false ;
86978: LD_ADDR_EXP 130
86982: PUSH
86983: LD_INT 0
86985: ST_TO_ADDR
// sArmoury := false ;
86986: LD_ADDR_EXP 131
86990: PUSH
86991: LD_INT 0
86993: ST_TO_ADDR
// sRadar := false ;
86994: LD_ADDR_EXP 132
86998: PUSH
86999: LD_INT 0
87001: ST_TO_ADDR
// sBunker := false ;
87002: LD_ADDR_EXP 133
87006: PUSH
87007: LD_INT 0
87009: ST_TO_ADDR
// sHack := false ;
87010: LD_ADDR_EXP 134
87014: PUSH
87015: LD_INT 0
87017: ST_TO_ADDR
// sFire := false ;
87018: LD_ADDR_EXP 135
87022: PUSH
87023: LD_INT 0
87025: ST_TO_ADDR
// sRefresh := false ;
87026: LD_ADDR_EXP 136
87030: PUSH
87031: LD_INT 0
87033: ST_TO_ADDR
// sExp := false ;
87034: LD_ADDR_EXP 137
87038: PUSH
87039: LD_INT 0
87041: ST_TO_ADDR
// sDepot := false ;
87042: LD_ADDR_EXP 138
87046: PUSH
87047: LD_INT 0
87049: ST_TO_ADDR
// sFlag := false ;
87050: LD_ADDR_EXP 139
87054: PUSH
87055: LD_INT 0
87057: ST_TO_ADDR
// sKamikadze := false ;
87058: LD_ADDR_EXP 147
87062: PUSH
87063: LD_INT 0
87065: ST_TO_ADDR
// sTroll := false ;
87066: LD_ADDR_EXP 148
87070: PUSH
87071: LD_INT 0
87073: ST_TO_ADDR
// sSlow := false ;
87074: LD_ADDR_EXP 149
87078: PUSH
87079: LD_INT 0
87081: ST_TO_ADDR
// sLack := false ;
87082: LD_ADDR_EXP 150
87086: PUSH
87087: LD_INT 0
87089: ST_TO_ADDR
// sTank := false ;
87090: LD_ADDR_EXP 152
87094: PUSH
87095: LD_INT 0
87097: ST_TO_ADDR
// sRemote := false ;
87098: LD_ADDR_EXP 153
87102: PUSH
87103: LD_INT 0
87105: ST_TO_ADDR
// sPowell := false ;
87106: LD_ADDR_EXP 154
87110: PUSH
87111: LD_INT 0
87113: ST_TO_ADDR
// sTeleport := false ;
87114: LD_ADDR_EXP 157
87118: PUSH
87119: LD_INT 0
87121: ST_TO_ADDR
// sOilTower := false ;
87122: LD_ADDR_EXP 159
87126: PUSH
87127: LD_INT 0
87129: ST_TO_ADDR
// sShovel := false ;
87130: LD_ADDR_EXP 160
87134: PUSH
87135: LD_INT 0
87137: ST_TO_ADDR
// sSheik := false ;
87138: LD_ADDR_EXP 161
87142: PUSH
87143: LD_INT 0
87145: ST_TO_ADDR
// sEarthquake := false ;
87146: LD_ADDR_EXP 163
87150: PUSH
87151: LD_INT 0
87153: ST_TO_ADDR
// sAI := false ;
87154: LD_ADDR_EXP 164
87158: PUSH
87159: LD_INT 0
87161: ST_TO_ADDR
// sCargo := false ;
87162: LD_ADDR_EXP 167
87166: PUSH
87167: LD_INT 0
87169: ST_TO_ADDR
// sDLaser := false ;
87170: LD_ADDR_EXP 168
87174: PUSH
87175: LD_INT 0
87177: ST_TO_ADDR
// sExchange := false ;
87178: LD_ADDR_EXP 169
87182: PUSH
87183: LD_INT 0
87185: ST_TO_ADDR
// sFac := false ;
87186: LD_ADDR_EXP 170
87190: PUSH
87191: LD_INT 0
87193: ST_TO_ADDR
// sPower := false ;
87194: LD_ADDR_EXP 171
87198: PUSH
87199: LD_INT 0
87201: ST_TO_ADDR
// sRandom := false ;
87202: LD_ADDR_EXP 172
87206: PUSH
87207: LD_INT 0
87209: ST_TO_ADDR
// sShield := false ;
87210: LD_ADDR_EXP 173
87214: PUSH
87215: LD_INT 0
87217: ST_TO_ADDR
// sTime := false ;
87218: LD_ADDR_EXP 174
87222: PUSH
87223: LD_INT 0
87225: ST_TO_ADDR
// sTools := false ;
87226: LD_ADDR_EXP 175
87230: PUSH
87231: LD_INT 0
87233: ST_TO_ADDR
// sSold := false ;
87234: LD_ADDR_EXP 140
87238: PUSH
87239: LD_INT 0
87241: ST_TO_ADDR
// sDiff := false ;
87242: LD_ADDR_EXP 141
87246: PUSH
87247: LD_INT 0
87249: ST_TO_ADDR
// sFog := false ;
87250: LD_ADDR_EXP 144
87254: PUSH
87255: LD_INT 0
87257: ST_TO_ADDR
// sReset := false ;
87258: LD_ADDR_EXP 145
87262: PUSH
87263: LD_INT 0
87265: ST_TO_ADDR
// sSun := false ;
87266: LD_ADDR_EXP 146
87270: PUSH
87271: LD_INT 0
87273: ST_TO_ADDR
// sTiger := false ;
87274: LD_ADDR_EXP 142
87278: PUSH
87279: LD_INT 0
87281: ST_TO_ADDR
// sBomb := false ;
87282: LD_ADDR_EXP 143
87286: PUSH
87287: LD_INT 0
87289: ST_TO_ADDR
// sWound := false ;
87290: LD_ADDR_EXP 151
87294: PUSH
87295: LD_INT 0
87297: ST_TO_ADDR
// sBetray := false ;
87298: LD_ADDR_EXP 155
87302: PUSH
87303: LD_INT 0
87305: ST_TO_ADDR
// sContamin := false ;
87306: LD_ADDR_EXP 156
87310: PUSH
87311: LD_INT 0
87313: ST_TO_ADDR
// sOil := false ;
87314: LD_ADDR_EXP 158
87318: PUSH
87319: LD_INT 0
87321: ST_TO_ADDR
// sStu := false ;
87322: LD_ADDR_EXP 162
87326: PUSH
87327: LD_INT 0
87329: ST_TO_ADDR
// sBazooka := false ;
87330: LD_ADDR_EXP 165
87334: PUSH
87335: LD_INT 0
87337: ST_TO_ADDR
// sMortar := false ;
87338: LD_ADDR_EXP 166
87342: PUSH
87343: LD_INT 0
87345: ST_TO_ADDR
// sRanger := false ;
87346: LD_ADDR_EXP 176
87350: PUSH
87351: LD_INT 0
87353: ST_TO_ADDR
// sComputer := false ;
87354: LD_ADDR_EXP 177
87358: PUSH
87359: LD_INT 0
87361: ST_TO_ADDR
// s30 := false ;
87362: LD_ADDR_EXP 178
87366: PUSH
87367: LD_INT 0
87369: ST_TO_ADDR
// s60 := false ;
87370: LD_ADDR_EXP 179
87374: PUSH
87375: LD_INT 0
87377: ST_TO_ADDR
// end ;
87378: LD_VAR 0 1
87382: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
87383: LD_INT 0
87385: PPUSH
87386: PPUSH
87387: PPUSH
87388: PPUSH
87389: PPUSH
87390: PPUSH
87391: PPUSH
// result := [ ] ;
87392: LD_ADDR_VAR 0 2
87396: PUSH
87397: EMPTY
87398: ST_TO_ADDR
// if campaign_id = 1 then
87399: LD_OWVAR 69
87403: PUSH
87404: LD_INT 1
87406: EQUAL
87407: IFFALSE 90573
// begin case mission_number of 1 :
87409: LD_OWVAR 70
87413: PUSH
87414: LD_INT 1
87416: DOUBLE
87417: EQUAL
87418: IFTRUE 87422
87420: GO 87498
87422: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
87423: LD_ADDR_VAR 0 2
87427: PUSH
87428: LD_INT 2
87430: PUSH
87431: LD_INT 4
87433: PUSH
87434: LD_INT 11
87436: PUSH
87437: LD_INT 12
87439: PUSH
87440: LD_INT 15
87442: PUSH
87443: LD_INT 16
87445: PUSH
87446: LD_INT 22
87448: PUSH
87449: LD_INT 23
87451: PUSH
87452: LD_INT 26
87454: PUSH
87455: EMPTY
87456: LIST
87457: LIST
87458: LIST
87459: LIST
87460: LIST
87461: LIST
87462: LIST
87463: LIST
87464: LIST
87465: PUSH
87466: LD_INT 101
87468: PUSH
87469: LD_INT 102
87471: PUSH
87472: LD_INT 106
87474: PUSH
87475: LD_INT 116
87477: PUSH
87478: LD_INT 117
87480: PUSH
87481: LD_INT 118
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: ST_TO_ADDR
87496: GO 90571
87498: LD_INT 2
87500: DOUBLE
87501: EQUAL
87502: IFTRUE 87506
87504: GO 87590
87506: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
87507: LD_ADDR_VAR 0 2
87511: PUSH
87512: LD_INT 2
87514: PUSH
87515: LD_INT 4
87517: PUSH
87518: LD_INT 11
87520: PUSH
87521: LD_INT 12
87523: PUSH
87524: LD_INT 15
87526: PUSH
87527: LD_INT 16
87529: PUSH
87530: LD_INT 22
87532: PUSH
87533: LD_INT 23
87535: PUSH
87536: LD_INT 26
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: PUSH
87550: LD_INT 101
87552: PUSH
87553: LD_INT 102
87555: PUSH
87556: LD_INT 105
87558: PUSH
87559: LD_INT 106
87561: PUSH
87562: LD_INT 108
87564: PUSH
87565: LD_INT 116
87567: PUSH
87568: LD_INT 117
87570: PUSH
87571: LD_INT 118
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: LIST
87578: LIST
87579: LIST
87580: LIST
87581: LIST
87582: LIST
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: ST_TO_ADDR
87588: GO 90571
87590: LD_INT 3
87592: DOUBLE
87593: EQUAL
87594: IFTRUE 87598
87596: GO 87686
87598: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
87599: LD_ADDR_VAR 0 2
87603: PUSH
87604: LD_INT 2
87606: PUSH
87607: LD_INT 4
87609: PUSH
87610: LD_INT 5
87612: PUSH
87613: LD_INT 11
87615: PUSH
87616: LD_INT 12
87618: PUSH
87619: LD_INT 15
87621: PUSH
87622: LD_INT 16
87624: PUSH
87625: LD_INT 22
87627: PUSH
87628: LD_INT 26
87630: PUSH
87631: LD_INT 36
87633: PUSH
87634: EMPTY
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: LIST
87644: LIST
87645: PUSH
87646: LD_INT 101
87648: PUSH
87649: LD_INT 102
87651: PUSH
87652: LD_INT 105
87654: PUSH
87655: LD_INT 106
87657: PUSH
87658: LD_INT 108
87660: PUSH
87661: LD_INT 116
87663: PUSH
87664: LD_INT 117
87666: PUSH
87667: LD_INT 118
87669: PUSH
87670: EMPTY
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: PUSH
87680: EMPTY
87681: LIST
87682: LIST
87683: ST_TO_ADDR
87684: GO 90571
87686: LD_INT 4
87688: DOUBLE
87689: EQUAL
87690: IFTRUE 87694
87692: GO 87790
87694: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
87695: LD_ADDR_VAR 0 2
87699: PUSH
87700: LD_INT 2
87702: PUSH
87703: LD_INT 4
87705: PUSH
87706: LD_INT 5
87708: PUSH
87709: LD_INT 8
87711: PUSH
87712: LD_INT 11
87714: PUSH
87715: LD_INT 12
87717: PUSH
87718: LD_INT 15
87720: PUSH
87721: LD_INT 16
87723: PUSH
87724: LD_INT 22
87726: PUSH
87727: LD_INT 23
87729: PUSH
87730: LD_INT 26
87732: PUSH
87733: LD_INT 36
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 101
87752: PUSH
87753: LD_INT 102
87755: PUSH
87756: LD_INT 105
87758: PUSH
87759: LD_INT 106
87761: PUSH
87762: LD_INT 108
87764: PUSH
87765: LD_INT 116
87767: PUSH
87768: LD_INT 117
87770: PUSH
87771: LD_INT 118
87773: PUSH
87774: EMPTY
87775: LIST
87776: LIST
87777: LIST
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: PUSH
87784: EMPTY
87785: LIST
87786: LIST
87787: ST_TO_ADDR
87788: GO 90571
87790: LD_INT 5
87792: DOUBLE
87793: EQUAL
87794: IFTRUE 87798
87796: GO 87910
87798: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
87799: LD_ADDR_VAR 0 2
87803: PUSH
87804: LD_INT 2
87806: PUSH
87807: LD_INT 4
87809: PUSH
87810: LD_INT 5
87812: PUSH
87813: LD_INT 6
87815: PUSH
87816: LD_INT 8
87818: PUSH
87819: LD_INT 11
87821: PUSH
87822: LD_INT 12
87824: PUSH
87825: LD_INT 15
87827: PUSH
87828: LD_INT 16
87830: PUSH
87831: LD_INT 22
87833: PUSH
87834: LD_INT 23
87836: PUSH
87837: LD_INT 25
87839: PUSH
87840: LD_INT 26
87842: PUSH
87843: LD_INT 36
87845: PUSH
87846: EMPTY
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: LIST
87854: LIST
87855: LIST
87856: LIST
87857: LIST
87858: LIST
87859: LIST
87860: LIST
87861: PUSH
87862: LD_INT 101
87864: PUSH
87865: LD_INT 102
87867: PUSH
87868: LD_INT 105
87870: PUSH
87871: LD_INT 106
87873: PUSH
87874: LD_INT 108
87876: PUSH
87877: LD_INT 109
87879: PUSH
87880: LD_INT 112
87882: PUSH
87883: LD_INT 116
87885: PUSH
87886: LD_INT 117
87888: PUSH
87889: LD_INT 118
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: LIST
87896: LIST
87897: LIST
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: PUSH
87904: EMPTY
87905: LIST
87906: LIST
87907: ST_TO_ADDR
87908: GO 90571
87910: LD_INT 6
87912: DOUBLE
87913: EQUAL
87914: IFTRUE 87918
87916: GO 88050
87918: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
87919: LD_ADDR_VAR 0 2
87923: PUSH
87924: LD_INT 2
87926: PUSH
87927: LD_INT 4
87929: PUSH
87930: LD_INT 5
87932: PUSH
87933: LD_INT 6
87935: PUSH
87936: LD_INT 8
87938: PUSH
87939: LD_INT 11
87941: PUSH
87942: LD_INT 12
87944: PUSH
87945: LD_INT 15
87947: PUSH
87948: LD_INT 16
87950: PUSH
87951: LD_INT 20
87953: PUSH
87954: LD_INT 21
87956: PUSH
87957: LD_INT 22
87959: PUSH
87960: LD_INT 23
87962: PUSH
87963: LD_INT 25
87965: PUSH
87966: LD_INT 26
87968: PUSH
87969: LD_INT 30
87971: PUSH
87972: LD_INT 31
87974: PUSH
87975: LD_INT 32
87977: PUSH
87978: LD_INT 36
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: PUSH
88002: LD_INT 101
88004: PUSH
88005: LD_INT 102
88007: PUSH
88008: LD_INT 105
88010: PUSH
88011: LD_INT 106
88013: PUSH
88014: LD_INT 108
88016: PUSH
88017: LD_INT 109
88019: PUSH
88020: LD_INT 112
88022: PUSH
88023: LD_INT 116
88025: PUSH
88026: LD_INT 117
88028: PUSH
88029: LD_INT 118
88031: PUSH
88032: EMPTY
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: LIST
88038: LIST
88039: LIST
88040: LIST
88041: LIST
88042: LIST
88043: PUSH
88044: EMPTY
88045: LIST
88046: LIST
88047: ST_TO_ADDR
88048: GO 90571
88050: LD_INT 7
88052: DOUBLE
88053: EQUAL
88054: IFTRUE 88058
88056: GO 88170
88058: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
88059: LD_ADDR_VAR 0 2
88063: PUSH
88064: LD_INT 2
88066: PUSH
88067: LD_INT 4
88069: PUSH
88070: LD_INT 5
88072: PUSH
88073: LD_INT 7
88075: PUSH
88076: LD_INT 11
88078: PUSH
88079: LD_INT 12
88081: PUSH
88082: LD_INT 15
88084: PUSH
88085: LD_INT 16
88087: PUSH
88088: LD_INT 20
88090: PUSH
88091: LD_INT 21
88093: PUSH
88094: LD_INT 22
88096: PUSH
88097: LD_INT 23
88099: PUSH
88100: LD_INT 25
88102: PUSH
88103: LD_INT 26
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: PUSH
88122: LD_INT 101
88124: PUSH
88125: LD_INT 102
88127: PUSH
88128: LD_INT 103
88130: PUSH
88131: LD_INT 105
88133: PUSH
88134: LD_INT 106
88136: PUSH
88137: LD_INT 108
88139: PUSH
88140: LD_INT 112
88142: PUSH
88143: LD_INT 116
88145: PUSH
88146: LD_INT 117
88148: PUSH
88149: LD_INT 118
88151: PUSH
88152: EMPTY
88153: LIST
88154: LIST
88155: LIST
88156: LIST
88157: LIST
88158: LIST
88159: LIST
88160: LIST
88161: LIST
88162: LIST
88163: PUSH
88164: EMPTY
88165: LIST
88166: LIST
88167: ST_TO_ADDR
88168: GO 90571
88170: LD_INT 8
88172: DOUBLE
88173: EQUAL
88174: IFTRUE 88178
88176: GO 88318
88178: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
88179: LD_ADDR_VAR 0 2
88183: PUSH
88184: LD_INT 2
88186: PUSH
88187: LD_INT 4
88189: PUSH
88190: LD_INT 5
88192: PUSH
88193: LD_INT 6
88195: PUSH
88196: LD_INT 7
88198: PUSH
88199: LD_INT 8
88201: PUSH
88202: LD_INT 11
88204: PUSH
88205: LD_INT 12
88207: PUSH
88208: LD_INT 15
88210: PUSH
88211: LD_INT 16
88213: PUSH
88214: LD_INT 20
88216: PUSH
88217: LD_INT 21
88219: PUSH
88220: LD_INT 22
88222: PUSH
88223: LD_INT 23
88225: PUSH
88226: LD_INT 25
88228: PUSH
88229: LD_INT 26
88231: PUSH
88232: LD_INT 30
88234: PUSH
88235: LD_INT 31
88237: PUSH
88238: LD_INT 32
88240: PUSH
88241: LD_INT 36
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: LIST
88248: LIST
88249: LIST
88250: LIST
88251: LIST
88252: LIST
88253: LIST
88254: LIST
88255: LIST
88256: LIST
88257: LIST
88258: LIST
88259: LIST
88260: LIST
88261: LIST
88262: LIST
88263: LIST
88264: LIST
88265: PUSH
88266: LD_INT 101
88268: PUSH
88269: LD_INT 102
88271: PUSH
88272: LD_INT 103
88274: PUSH
88275: LD_INT 105
88277: PUSH
88278: LD_INT 106
88280: PUSH
88281: LD_INT 108
88283: PUSH
88284: LD_INT 109
88286: PUSH
88287: LD_INT 112
88289: PUSH
88290: LD_INT 116
88292: PUSH
88293: LD_INT 117
88295: PUSH
88296: LD_INT 118
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: LIST
88303: LIST
88304: LIST
88305: LIST
88306: LIST
88307: LIST
88308: LIST
88309: LIST
88310: LIST
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: ST_TO_ADDR
88316: GO 90571
88318: LD_INT 9
88320: DOUBLE
88321: EQUAL
88322: IFTRUE 88326
88324: GO 88474
88326: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
88327: LD_ADDR_VAR 0 2
88331: PUSH
88332: LD_INT 2
88334: PUSH
88335: LD_INT 4
88337: PUSH
88338: LD_INT 5
88340: PUSH
88341: LD_INT 6
88343: PUSH
88344: LD_INT 7
88346: PUSH
88347: LD_INT 8
88349: PUSH
88350: LD_INT 11
88352: PUSH
88353: LD_INT 12
88355: PUSH
88356: LD_INT 15
88358: PUSH
88359: LD_INT 16
88361: PUSH
88362: LD_INT 20
88364: PUSH
88365: LD_INT 21
88367: PUSH
88368: LD_INT 22
88370: PUSH
88371: LD_INT 23
88373: PUSH
88374: LD_INT 25
88376: PUSH
88377: LD_INT 26
88379: PUSH
88380: LD_INT 28
88382: PUSH
88383: LD_INT 30
88385: PUSH
88386: LD_INT 31
88388: PUSH
88389: LD_INT 32
88391: PUSH
88392: LD_INT 36
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: LIST
88412: LIST
88413: LIST
88414: LIST
88415: LIST
88416: LIST
88417: PUSH
88418: LD_INT 101
88420: PUSH
88421: LD_INT 102
88423: PUSH
88424: LD_INT 103
88426: PUSH
88427: LD_INT 105
88429: PUSH
88430: LD_INT 106
88432: PUSH
88433: LD_INT 108
88435: PUSH
88436: LD_INT 109
88438: PUSH
88439: LD_INT 112
88441: PUSH
88442: LD_INT 114
88444: PUSH
88445: LD_INT 116
88447: PUSH
88448: LD_INT 117
88450: PUSH
88451: LD_INT 118
88453: PUSH
88454: EMPTY
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: PUSH
88468: EMPTY
88469: LIST
88470: LIST
88471: ST_TO_ADDR
88472: GO 90571
88474: LD_INT 10
88476: DOUBLE
88477: EQUAL
88478: IFTRUE 88482
88480: GO 88678
88482: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
88483: LD_ADDR_VAR 0 2
88487: PUSH
88488: LD_INT 2
88490: PUSH
88491: LD_INT 4
88493: PUSH
88494: LD_INT 5
88496: PUSH
88497: LD_INT 6
88499: PUSH
88500: LD_INT 7
88502: PUSH
88503: LD_INT 8
88505: PUSH
88506: LD_INT 9
88508: PUSH
88509: LD_INT 10
88511: PUSH
88512: LD_INT 11
88514: PUSH
88515: LD_INT 12
88517: PUSH
88518: LD_INT 13
88520: PUSH
88521: LD_INT 14
88523: PUSH
88524: LD_INT 15
88526: PUSH
88527: LD_INT 16
88529: PUSH
88530: LD_INT 17
88532: PUSH
88533: LD_INT 18
88535: PUSH
88536: LD_INT 19
88538: PUSH
88539: LD_INT 20
88541: PUSH
88542: LD_INT 21
88544: PUSH
88545: LD_INT 22
88547: PUSH
88548: LD_INT 23
88550: PUSH
88551: LD_INT 24
88553: PUSH
88554: LD_INT 25
88556: PUSH
88557: LD_INT 26
88559: PUSH
88560: LD_INT 28
88562: PUSH
88563: LD_INT 30
88565: PUSH
88566: LD_INT 31
88568: PUSH
88569: LD_INT 32
88571: PUSH
88572: LD_INT 36
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: LIST
88579: LIST
88580: LIST
88581: LIST
88582: LIST
88583: LIST
88584: LIST
88585: LIST
88586: LIST
88587: LIST
88588: LIST
88589: LIST
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: LIST
88604: LIST
88605: PUSH
88606: LD_INT 101
88608: PUSH
88609: LD_INT 102
88611: PUSH
88612: LD_INT 103
88614: PUSH
88615: LD_INT 104
88617: PUSH
88618: LD_INT 105
88620: PUSH
88621: LD_INT 106
88623: PUSH
88624: LD_INT 107
88626: PUSH
88627: LD_INT 108
88629: PUSH
88630: LD_INT 109
88632: PUSH
88633: LD_INT 110
88635: PUSH
88636: LD_INT 111
88638: PUSH
88639: LD_INT 112
88641: PUSH
88642: LD_INT 114
88644: PUSH
88645: LD_INT 116
88647: PUSH
88648: LD_INT 117
88650: PUSH
88651: LD_INT 118
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: LIST
88658: LIST
88659: LIST
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: LIST
88667: LIST
88668: LIST
88669: LIST
88670: LIST
88671: PUSH
88672: EMPTY
88673: LIST
88674: LIST
88675: ST_TO_ADDR
88676: GO 90571
88678: LD_INT 11
88680: DOUBLE
88681: EQUAL
88682: IFTRUE 88686
88684: GO 88890
88686: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
88687: LD_ADDR_VAR 0 2
88691: PUSH
88692: LD_INT 2
88694: PUSH
88695: LD_INT 3
88697: PUSH
88698: LD_INT 4
88700: PUSH
88701: LD_INT 5
88703: PUSH
88704: LD_INT 6
88706: PUSH
88707: LD_INT 7
88709: PUSH
88710: LD_INT 8
88712: PUSH
88713: LD_INT 9
88715: PUSH
88716: LD_INT 10
88718: PUSH
88719: LD_INT 11
88721: PUSH
88722: LD_INT 12
88724: PUSH
88725: LD_INT 13
88727: PUSH
88728: LD_INT 14
88730: PUSH
88731: LD_INT 15
88733: PUSH
88734: LD_INT 16
88736: PUSH
88737: LD_INT 17
88739: PUSH
88740: LD_INT 18
88742: PUSH
88743: LD_INT 19
88745: PUSH
88746: LD_INT 20
88748: PUSH
88749: LD_INT 21
88751: PUSH
88752: LD_INT 22
88754: PUSH
88755: LD_INT 23
88757: PUSH
88758: LD_INT 24
88760: PUSH
88761: LD_INT 25
88763: PUSH
88764: LD_INT 26
88766: PUSH
88767: LD_INT 28
88769: PUSH
88770: LD_INT 30
88772: PUSH
88773: LD_INT 31
88775: PUSH
88776: LD_INT 32
88778: PUSH
88779: LD_INT 34
88781: PUSH
88782: LD_INT 36
88784: PUSH
88785: EMPTY
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: PUSH
88818: LD_INT 101
88820: PUSH
88821: LD_INT 102
88823: PUSH
88824: LD_INT 103
88826: PUSH
88827: LD_INT 104
88829: PUSH
88830: LD_INT 105
88832: PUSH
88833: LD_INT 106
88835: PUSH
88836: LD_INT 107
88838: PUSH
88839: LD_INT 108
88841: PUSH
88842: LD_INT 109
88844: PUSH
88845: LD_INT 110
88847: PUSH
88848: LD_INT 111
88850: PUSH
88851: LD_INT 112
88853: PUSH
88854: LD_INT 114
88856: PUSH
88857: LD_INT 116
88859: PUSH
88860: LD_INT 117
88862: PUSH
88863: LD_INT 118
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: LIST
88870: LIST
88871: LIST
88872: LIST
88873: LIST
88874: LIST
88875: LIST
88876: LIST
88877: LIST
88878: LIST
88879: LIST
88880: LIST
88881: LIST
88882: LIST
88883: PUSH
88884: EMPTY
88885: LIST
88886: LIST
88887: ST_TO_ADDR
88888: GO 90571
88890: LD_INT 12
88892: DOUBLE
88893: EQUAL
88894: IFTRUE 88898
88896: GO 89118
88898: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
88899: LD_ADDR_VAR 0 2
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: LD_INT 2
88909: PUSH
88910: LD_INT 3
88912: PUSH
88913: LD_INT 4
88915: PUSH
88916: LD_INT 5
88918: PUSH
88919: LD_INT 6
88921: PUSH
88922: LD_INT 7
88924: PUSH
88925: LD_INT 8
88927: PUSH
88928: LD_INT 9
88930: PUSH
88931: LD_INT 10
88933: PUSH
88934: LD_INT 11
88936: PUSH
88937: LD_INT 12
88939: PUSH
88940: LD_INT 13
88942: PUSH
88943: LD_INT 14
88945: PUSH
88946: LD_INT 15
88948: PUSH
88949: LD_INT 16
88951: PUSH
88952: LD_INT 17
88954: PUSH
88955: LD_INT 18
88957: PUSH
88958: LD_INT 19
88960: PUSH
88961: LD_INT 20
88963: PUSH
88964: LD_INT 21
88966: PUSH
88967: LD_INT 22
88969: PUSH
88970: LD_INT 23
88972: PUSH
88973: LD_INT 24
88975: PUSH
88976: LD_INT 25
88978: PUSH
88979: LD_INT 26
88981: PUSH
88982: LD_INT 27
88984: PUSH
88985: LD_INT 28
88987: PUSH
88988: LD_INT 30
88990: PUSH
88991: LD_INT 31
88993: PUSH
88994: LD_INT 32
88996: PUSH
88997: LD_INT 33
88999: PUSH
89000: LD_INT 34
89002: PUSH
89003: LD_INT 36
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: LIST
89010: LIST
89011: LIST
89012: LIST
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: LIST
89038: LIST
89039: LIST
89040: LIST
89041: PUSH
89042: LD_INT 101
89044: PUSH
89045: LD_INT 102
89047: PUSH
89048: LD_INT 103
89050: PUSH
89051: LD_INT 104
89053: PUSH
89054: LD_INT 105
89056: PUSH
89057: LD_INT 106
89059: PUSH
89060: LD_INT 107
89062: PUSH
89063: LD_INT 108
89065: PUSH
89066: LD_INT 109
89068: PUSH
89069: LD_INT 110
89071: PUSH
89072: LD_INT 111
89074: PUSH
89075: LD_INT 112
89077: PUSH
89078: LD_INT 113
89080: PUSH
89081: LD_INT 114
89083: PUSH
89084: LD_INT 116
89086: PUSH
89087: LD_INT 117
89089: PUSH
89090: LD_INT 118
89092: PUSH
89093: EMPTY
89094: LIST
89095: LIST
89096: LIST
89097: LIST
89098: LIST
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: LIST
89105: LIST
89106: LIST
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: ST_TO_ADDR
89116: GO 90571
89118: LD_INT 13
89120: DOUBLE
89121: EQUAL
89122: IFTRUE 89126
89124: GO 89334
89126: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
89127: LD_ADDR_VAR 0 2
89131: PUSH
89132: LD_INT 1
89134: PUSH
89135: LD_INT 2
89137: PUSH
89138: LD_INT 3
89140: PUSH
89141: LD_INT 4
89143: PUSH
89144: LD_INT 5
89146: PUSH
89147: LD_INT 8
89149: PUSH
89150: LD_INT 9
89152: PUSH
89153: LD_INT 10
89155: PUSH
89156: LD_INT 11
89158: PUSH
89159: LD_INT 12
89161: PUSH
89162: LD_INT 14
89164: PUSH
89165: LD_INT 15
89167: PUSH
89168: LD_INT 16
89170: PUSH
89171: LD_INT 17
89173: PUSH
89174: LD_INT 18
89176: PUSH
89177: LD_INT 19
89179: PUSH
89180: LD_INT 20
89182: PUSH
89183: LD_INT 21
89185: PUSH
89186: LD_INT 22
89188: PUSH
89189: LD_INT 23
89191: PUSH
89192: LD_INT 24
89194: PUSH
89195: LD_INT 25
89197: PUSH
89198: LD_INT 26
89200: PUSH
89201: LD_INT 27
89203: PUSH
89204: LD_INT 28
89206: PUSH
89207: LD_INT 30
89209: PUSH
89210: LD_INT 31
89212: PUSH
89213: LD_INT 32
89215: PUSH
89216: LD_INT 33
89218: PUSH
89219: LD_INT 34
89221: PUSH
89222: LD_INT 36
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: LIST
89229: LIST
89230: LIST
89231: LIST
89232: LIST
89233: LIST
89234: LIST
89235: LIST
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: PUSH
89258: LD_INT 101
89260: PUSH
89261: LD_INT 102
89263: PUSH
89264: LD_INT 103
89266: PUSH
89267: LD_INT 104
89269: PUSH
89270: LD_INT 105
89272: PUSH
89273: LD_INT 106
89275: PUSH
89276: LD_INT 107
89278: PUSH
89279: LD_INT 108
89281: PUSH
89282: LD_INT 109
89284: PUSH
89285: LD_INT 110
89287: PUSH
89288: LD_INT 111
89290: PUSH
89291: LD_INT 112
89293: PUSH
89294: LD_INT 113
89296: PUSH
89297: LD_INT 114
89299: PUSH
89300: LD_INT 116
89302: PUSH
89303: LD_INT 117
89305: PUSH
89306: LD_INT 118
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: LIST
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: PUSH
89328: EMPTY
89329: LIST
89330: LIST
89331: ST_TO_ADDR
89332: GO 90571
89334: LD_INT 14
89336: DOUBLE
89337: EQUAL
89338: IFTRUE 89342
89340: GO 89566
89342: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
89343: LD_ADDR_VAR 0 2
89347: PUSH
89348: LD_INT 1
89350: PUSH
89351: LD_INT 2
89353: PUSH
89354: LD_INT 3
89356: PUSH
89357: LD_INT 4
89359: PUSH
89360: LD_INT 5
89362: PUSH
89363: LD_INT 6
89365: PUSH
89366: LD_INT 7
89368: PUSH
89369: LD_INT 8
89371: PUSH
89372: LD_INT 9
89374: PUSH
89375: LD_INT 10
89377: PUSH
89378: LD_INT 11
89380: PUSH
89381: LD_INT 12
89383: PUSH
89384: LD_INT 13
89386: PUSH
89387: LD_INT 14
89389: PUSH
89390: LD_INT 15
89392: PUSH
89393: LD_INT 16
89395: PUSH
89396: LD_INT 17
89398: PUSH
89399: LD_INT 18
89401: PUSH
89402: LD_INT 19
89404: PUSH
89405: LD_INT 20
89407: PUSH
89408: LD_INT 21
89410: PUSH
89411: LD_INT 22
89413: PUSH
89414: LD_INT 23
89416: PUSH
89417: LD_INT 24
89419: PUSH
89420: LD_INT 25
89422: PUSH
89423: LD_INT 26
89425: PUSH
89426: LD_INT 27
89428: PUSH
89429: LD_INT 28
89431: PUSH
89432: LD_INT 29
89434: PUSH
89435: LD_INT 30
89437: PUSH
89438: LD_INT 31
89440: PUSH
89441: LD_INT 32
89443: PUSH
89444: LD_INT 33
89446: PUSH
89447: LD_INT 34
89449: PUSH
89450: LD_INT 36
89452: PUSH
89453: EMPTY
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 101
89492: PUSH
89493: LD_INT 102
89495: PUSH
89496: LD_INT 103
89498: PUSH
89499: LD_INT 104
89501: PUSH
89502: LD_INT 105
89504: PUSH
89505: LD_INT 106
89507: PUSH
89508: LD_INT 107
89510: PUSH
89511: LD_INT 108
89513: PUSH
89514: LD_INT 109
89516: PUSH
89517: LD_INT 110
89519: PUSH
89520: LD_INT 111
89522: PUSH
89523: LD_INT 112
89525: PUSH
89526: LD_INT 113
89528: PUSH
89529: LD_INT 114
89531: PUSH
89532: LD_INT 116
89534: PUSH
89535: LD_INT 117
89537: PUSH
89538: LD_INT 118
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: ST_TO_ADDR
89564: GO 90571
89566: LD_INT 15
89568: DOUBLE
89569: EQUAL
89570: IFTRUE 89574
89572: GO 89798
89574: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
89575: LD_ADDR_VAR 0 2
89579: PUSH
89580: LD_INT 1
89582: PUSH
89583: LD_INT 2
89585: PUSH
89586: LD_INT 3
89588: PUSH
89589: LD_INT 4
89591: PUSH
89592: LD_INT 5
89594: PUSH
89595: LD_INT 6
89597: PUSH
89598: LD_INT 7
89600: PUSH
89601: LD_INT 8
89603: PUSH
89604: LD_INT 9
89606: PUSH
89607: LD_INT 10
89609: PUSH
89610: LD_INT 11
89612: PUSH
89613: LD_INT 12
89615: PUSH
89616: LD_INT 13
89618: PUSH
89619: LD_INT 14
89621: PUSH
89622: LD_INT 15
89624: PUSH
89625: LD_INT 16
89627: PUSH
89628: LD_INT 17
89630: PUSH
89631: LD_INT 18
89633: PUSH
89634: LD_INT 19
89636: PUSH
89637: LD_INT 20
89639: PUSH
89640: LD_INT 21
89642: PUSH
89643: LD_INT 22
89645: PUSH
89646: LD_INT 23
89648: PUSH
89649: LD_INT 24
89651: PUSH
89652: LD_INT 25
89654: PUSH
89655: LD_INT 26
89657: PUSH
89658: LD_INT 27
89660: PUSH
89661: LD_INT 28
89663: PUSH
89664: LD_INT 29
89666: PUSH
89667: LD_INT 30
89669: PUSH
89670: LD_INT 31
89672: PUSH
89673: LD_INT 32
89675: PUSH
89676: LD_INT 33
89678: PUSH
89679: LD_INT 34
89681: PUSH
89682: LD_INT 36
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: LIST
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: PUSH
89722: LD_INT 101
89724: PUSH
89725: LD_INT 102
89727: PUSH
89728: LD_INT 103
89730: PUSH
89731: LD_INT 104
89733: PUSH
89734: LD_INT 105
89736: PUSH
89737: LD_INT 106
89739: PUSH
89740: LD_INT 107
89742: PUSH
89743: LD_INT 108
89745: PUSH
89746: LD_INT 109
89748: PUSH
89749: LD_INT 110
89751: PUSH
89752: LD_INT 111
89754: PUSH
89755: LD_INT 112
89757: PUSH
89758: LD_INT 113
89760: PUSH
89761: LD_INT 114
89763: PUSH
89764: LD_INT 116
89766: PUSH
89767: LD_INT 117
89769: PUSH
89770: LD_INT 118
89772: PUSH
89773: EMPTY
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: PUSH
89792: EMPTY
89793: LIST
89794: LIST
89795: ST_TO_ADDR
89796: GO 90571
89798: LD_INT 16
89800: DOUBLE
89801: EQUAL
89802: IFTRUE 89806
89804: GO 89942
89806: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
89807: LD_ADDR_VAR 0 2
89811: PUSH
89812: LD_INT 2
89814: PUSH
89815: LD_INT 4
89817: PUSH
89818: LD_INT 5
89820: PUSH
89821: LD_INT 7
89823: PUSH
89824: LD_INT 11
89826: PUSH
89827: LD_INT 12
89829: PUSH
89830: LD_INT 15
89832: PUSH
89833: LD_INT 16
89835: PUSH
89836: LD_INT 20
89838: PUSH
89839: LD_INT 21
89841: PUSH
89842: LD_INT 22
89844: PUSH
89845: LD_INT 23
89847: PUSH
89848: LD_INT 25
89850: PUSH
89851: LD_INT 26
89853: PUSH
89854: LD_INT 30
89856: PUSH
89857: LD_INT 31
89859: PUSH
89860: LD_INT 32
89862: PUSH
89863: LD_INT 33
89865: PUSH
89866: LD_INT 34
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 101
89892: PUSH
89893: LD_INT 102
89895: PUSH
89896: LD_INT 103
89898: PUSH
89899: LD_INT 106
89901: PUSH
89902: LD_INT 108
89904: PUSH
89905: LD_INT 112
89907: PUSH
89908: LD_INT 113
89910: PUSH
89911: LD_INT 114
89913: PUSH
89914: LD_INT 116
89916: PUSH
89917: LD_INT 117
89919: PUSH
89920: LD_INT 118
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: ST_TO_ADDR
89940: GO 90571
89942: LD_INT 17
89944: DOUBLE
89945: EQUAL
89946: IFTRUE 89950
89948: GO 90174
89950: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
89951: LD_ADDR_VAR 0 2
89955: PUSH
89956: LD_INT 1
89958: PUSH
89959: LD_INT 2
89961: PUSH
89962: LD_INT 3
89964: PUSH
89965: LD_INT 4
89967: PUSH
89968: LD_INT 5
89970: PUSH
89971: LD_INT 6
89973: PUSH
89974: LD_INT 7
89976: PUSH
89977: LD_INT 8
89979: PUSH
89980: LD_INT 9
89982: PUSH
89983: LD_INT 10
89985: PUSH
89986: LD_INT 11
89988: PUSH
89989: LD_INT 12
89991: PUSH
89992: LD_INT 13
89994: PUSH
89995: LD_INT 14
89997: PUSH
89998: LD_INT 15
90000: PUSH
90001: LD_INT 16
90003: PUSH
90004: LD_INT 17
90006: PUSH
90007: LD_INT 18
90009: PUSH
90010: LD_INT 19
90012: PUSH
90013: LD_INT 20
90015: PUSH
90016: LD_INT 21
90018: PUSH
90019: LD_INT 22
90021: PUSH
90022: LD_INT 23
90024: PUSH
90025: LD_INT 24
90027: PUSH
90028: LD_INT 25
90030: PUSH
90031: LD_INT 26
90033: PUSH
90034: LD_INT 27
90036: PUSH
90037: LD_INT 28
90039: PUSH
90040: LD_INT 29
90042: PUSH
90043: LD_INT 30
90045: PUSH
90046: LD_INT 31
90048: PUSH
90049: LD_INT 32
90051: PUSH
90052: LD_INT 33
90054: PUSH
90055: LD_INT 34
90057: PUSH
90058: LD_INT 36
90060: PUSH
90061: EMPTY
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 101
90100: PUSH
90101: LD_INT 102
90103: PUSH
90104: LD_INT 103
90106: PUSH
90107: LD_INT 104
90109: PUSH
90110: LD_INT 105
90112: PUSH
90113: LD_INT 106
90115: PUSH
90116: LD_INT 107
90118: PUSH
90119: LD_INT 108
90121: PUSH
90122: LD_INT 109
90124: PUSH
90125: LD_INT 110
90127: PUSH
90128: LD_INT 111
90130: PUSH
90131: LD_INT 112
90133: PUSH
90134: LD_INT 113
90136: PUSH
90137: LD_INT 114
90139: PUSH
90140: LD_INT 116
90142: PUSH
90143: LD_INT 117
90145: PUSH
90146: LD_INT 118
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: ST_TO_ADDR
90172: GO 90571
90174: LD_INT 18
90176: DOUBLE
90177: EQUAL
90178: IFTRUE 90182
90180: GO 90330
90182: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
90183: LD_ADDR_VAR 0 2
90187: PUSH
90188: LD_INT 2
90190: PUSH
90191: LD_INT 4
90193: PUSH
90194: LD_INT 5
90196: PUSH
90197: LD_INT 7
90199: PUSH
90200: LD_INT 11
90202: PUSH
90203: LD_INT 12
90205: PUSH
90206: LD_INT 15
90208: PUSH
90209: LD_INT 16
90211: PUSH
90212: LD_INT 20
90214: PUSH
90215: LD_INT 21
90217: PUSH
90218: LD_INT 22
90220: PUSH
90221: LD_INT 23
90223: PUSH
90224: LD_INT 25
90226: PUSH
90227: LD_INT 26
90229: PUSH
90230: LD_INT 30
90232: PUSH
90233: LD_INT 31
90235: PUSH
90236: LD_INT 32
90238: PUSH
90239: LD_INT 33
90241: PUSH
90242: LD_INT 34
90244: PUSH
90245: LD_INT 35
90247: PUSH
90248: LD_INT 36
90250: PUSH
90251: EMPTY
90252: LIST
90253: LIST
90254: LIST
90255: LIST
90256: LIST
90257: LIST
90258: LIST
90259: LIST
90260: LIST
90261: LIST
90262: LIST
90263: LIST
90264: LIST
90265: LIST
90266: LIST
90267: LIST
90268: LIST
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: PUSH
90274: LD_INT 101
90276: PUSH
90277: LD_INT 102
90279: PUSH
90280: LD_INT 103
90282: PUSH
90283: LD_INT 106
90285: PUSH
90286: LD_INT 108
90288: PUSH
90289: LD_INT 112
90291: PUSH
90292: LD_INT 113
90294: PUSH
90295: LD_INT 114
90297: PUSH
90298: LD_INT 115
90300: PUSH
90301: LD_INT 116
90303: PUSH
90304: LD_INT 117
90306: PUSH
90307: LD_INT 118
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: ST_TO_ADDR
90328: GO 90571
90330: LD_INT 19
90332: DOUBLE
90333: EQUAL
90334: IFTRUE 90338
90336: GO 90570
90338: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
90339: LD_ADDR_VAR 0 2
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: LD_INT 2
90349: PUSH
90350: LD_INT 3
90352: PUSH
90353: LD_INT 4
90355: PUSH
90356: LD_INT 5
90358: PUSH
90359: LD_INT 6
90361: PUSH
90362: LD_INT 7
90364: PUSH
90365: LD_INT 8
90367: PUSH
90368: LD_INT 9
90370: PUSH
90371: LD_INT 10
90373: PUSH
90374: LD_INT 11
90376: PUSH
90377: LD_INT 12
90379: PUSH
90380: LD_INT 13
90382: PUSH
90383: LD_INT 14
90385: PUSH
90386: LD_INT 15
90388: PUSH
90389: LD_INT 16
90391: PUSH
90392: LD_INT 17
90394: PUSH
90395: LD_INT 18
90397: PUSH
90398: LD_INT 19
90400: PUSH
90401: LD_INT 20
90403: PUSH
90404: LD_INT 21
90406: PUSH
90407: LD_INT 22
90409: PUSH
90410: LD_INT 23
90412: PUSH
90413: LD_INT 24
90415: PUSH
90416: LD_INT 25
90418: PUSH
90419: LD_INT 26
90421: PUSH
90422: LD_INT 27
90424: PUSH
90425: LD_INT 28
90427: PUSH
90428: LD_INT 29
90430: PUSH
90431: LD_INT 30
90433: PUSH
90434: LD_INT 31
90436: PUSH
90437: LD_INT 32
90439: PUSH
90440: LD_INT 33
90442: PUSH
90443: LD_INT 34
90445: PUSH
90446: LD_INT 35
90448: PUSH
90449: LD_INT 36
90451: PUSH
90452: EMPTY
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: PUSH
90490: LD_INT 101
90492: PUSH
90493: LD_INT 102
90495: PUSH
90496: LD_INT 103
90498: PUSH
90499: LD_INT 104
90501: PUSH
90502: LD_INT 105
90504: PUSH
90505: LD_INT 106
90507: PUSH
90508: LD_INT 107
90510: PUSH
90511: LD_INT 108
90513: PUSH
90514: LD_INT 109
90516: PUSH
90517: LD_INT 110
90519: PUSH
90520: LD_INT 111
90522: PUSH
90523: LD_INT 112
90525: PUSH
90526: LD_INT 113
90528: PUSH
90529: LD_INT 114
90531: PUSH
90532: LD_INT 115
90534: PUSH
90535: LD_INT 116
90537: PUSH
90538: LD_INT 117
90540: PUSH
90541: LD_INT 118
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: LIST
90548: LIST
90549: LIST
90550: LIST
90551: LIST
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: LIST
90560: LIST
90561: LIST
90562: LIST
90563: PUSH
90564: EMPTY
90565: LIST
90566: LIST
90567: ST_TO_ADDR
90568: GO 90571
90570: POP
// end else
90571: GO 90802
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
90573: LD_ADDR_VAR 0 2
90577: PUSH
90578: LD_INT 1
90580: PUSH
90581: LD_INT 2
90583: PUSH
90584: LD_INT 3
90586: PUSH
90587: LD_INT 4
90589: PUSH
90590: LD_INT 5
90592: PUSH
90593: LD_INT 6
90595: PUSH
90596: LD_INT 7
90598: PUSH
90599: LD_INT 8
90601: PUSH
90602: LD_INT 9
90604: PUSH
90605: LD_INT 10
90607: PUSH
90608: LD_INT 11
90610: PUSH
90611: LD_INT 12
90613: PUSH
90614: LD_INT 13
90616: PUSH
90617: LD_INT 14
90619: PUSH
90620: LD_INT 15
90622: PUSH
90623: LD_INT 16
90625: PUSH
90626: LD_INT 17
90628: PUSH
90629: LD_INT 18
90631: PUSH
90632: LD_INT 19
90634: PUSH
90635: LD_INT 20
90637: PUSH
90638: LD_INT 21
90640: PUSH
90641: LD_INT 22
90643: PUSH
90644: LD_INT 23
90646: PUSH
90647: LD_INT 24
90649: PUSH
90650: LD_INT 25
90652: PUSH
90653: LD_INT 26
90655: PUSH
90656: LD_INT 27
90658: PUSH
90659: LD_INT 28
90661: PUSH
90662: LD_INT 29
90664: PUSH
90665: LD_INT 30
90667: PUSH
90668: LD_INT 31
90670: PUSH
90671: LD_INT 32
90673: PUSH
90674: LD_INT 33
90676: PUSH
90677: LD_INT 34
90679: PUSH
90680: LD_INT 35
90682: PUSH
90683: LD_INT 36
90685: PUSH
90686: EMPTY
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: LIST
90692: LIST
90693: LIST
90694: LIST
90695: LIST
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: LIST
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: PUSH
90724: LD_INT 101
90726: PUSH
90727: LD_INT 102
90729: PUSH
90730: LD_INT 103
90732: PUSH
90733: LD_INT 104
90735: PUSH
90736: LD_INT 105
90738: PUSH
90739: LD_INT 106
90741: PUSH
90742: LD_INT 107
90744: PUSH
90745: LD_INT 108
90747: PUSH
90748: LD_INT 109
90750: PUSH
90751: LD_INT 110
90753: PUSH
90754: LD_INT 111
90756: PUSH
90757: LD_INT 112
90759: PUSH
90760: LD_INT 113
90762: PUSH
90763: LD_INT 114
90765: PUSH
90766: LD_INT 115
90768: PUSH
90769: LD_INT 116
90771: PUSH
90772: LD_INT 117
90774: PUSH
90775: LD_INT 118
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: PUSH
90798: EMPTY
90799: LIST
90800: LIST
90801: ST_TO_ADDR
// if result then
90802: LD_VAR 0 2
90806: IFFALSE 91592
// begin normal :=  ;
90808: LD_ADDR_VAR 0 5
90812: PUSH
90813: LD_STRING 
90815: ST_TO_ADDR
// hardcore :=  ;
90816: LD_ADDR_VAR 0 6
90820: PUSH
90821: LD_STRING 
90823: ST_TO_ADDR
// active :=  ;
90824: LD_ADDR_VAR 0 7
90828: PUSH
90829: LD_STRING 
90831: ST_TO_ADDR
// for i = 1 to normalCounter do
90832: LD_ADDR_VAR 0 8
90836: PUSH
90837: DOUBLE
90838: LD_INT 1
90840: DEC
90841: ST_TO_ADDR
90842: LD_EXP 124
90846: PUSH
90847: FOR_TO
90848: IFFALSE 90949
// begin tmp := 0 ;
90850: LD_ADDR_VAR 0 3
90854: PUSH
90855: LD_STRING 0
90857: ST_TO_ADDR
// if result [ 1 ] then
90858: LD_VAR 0 2
90862: PUSH
90863: LD_INT 1
90865: ARRAY
90866: IFFALSE 90931
// if result [ 1 ] [ 1 ] = i then
90868: LD_VAR 0 2
90872: PUSH
90873: LD_INT 1
90875: ARRAY
90876: PUSH
90877: LD_INT 1
90879: ARRAY
90880: PUSH
90881: LD_VAR 0 8
90885: EQUAL
90886: IFFALSE 90931
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
90888: LD_ADDR_VAR 0 2
90892: PUSH
90893: LD_VAR 0 2
90897: PPUSH
90898: LD_INT 1
90900: PPUSH
90901: LD_VAR 0 2
90905: PUSH
90906: LD_INT 1
90908: ARRAY
90909: PPUSH
90910: LD_INT 1
90912: PPUSH
90913: CALL_OW 3
90917: PPUSH
90918: CALL_OW 1
90922: ST_TO_ADDR
// tmp := 1 ;
90923: LD_ADDR_VAR 0 3
90927: PUSH
90928: LD_STRING 1
90930: ST_TO_ADDR
// end ; normal := normal & tmp ;
90931: LD_ADDR_VAR 0 5
90935: PUSH
90936: LD_VAR 0 5
90940: PUSH
90941: LD_VAR 0 3
90945: STR
90946: ST_TO_ADDR
// end ;
90947: GO 90847
90949: POP
90950: POP
// for i = 1 to hardcoreCounter do
90951: LD_ADDR_VAR 0 8
90955: PUSH
90956: DOUBLE
90957: LD_INT 1
90959: DEC
90960: ST_TO_ADDR
90961: LD_EXP 125
90965: PUSH
90966: FOR_TO
90967: IFFALSE 91072
// begin tmp := 0 ;
90969: LD_ADDR_VAR 0 3
90973: PUSH
90974: LD_STRING 0
90976: ST_TO_ADDR
// if result [ 2 ] then
90977: LD_VAR 0 2
90981: PUSH
90982: LD_INT 2
90984: ARRAY
90985: IFFALSE 91054
// if result [ 2 ] [ 1 ] = 100 + i then
90987: LD_VAR 0 2
90991: PUSH
90992: LD_INT 2
90994: ARRAY
90995: PUSH
90996: LD_INT 1
90998: ARRAY
90999: PUSH
91000: LD_INT 100
91002: PUSH
91003: LD_VAR 0 8
91007: PLUS
91008: EQUAL
91009: IFFALSE 91054
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91011: LD_ADDR_VAR 0 2
91015: PUSH
91016: LD_VAR 0 2
91020: PPUSH
91021: LD_INT 2
91023: PPUSH
91024: LD_VAR 0 2
91028: PUSH
91029: LD_INT 2
91031: ARRAY
91032: PPUSH
91033: LD_INT 1
91035: PPUSH
91036: CALL_OW 3
91040: PPUSH
91041: CALL_OW 1
91045: ST_TO_ADDR
// tmp := 1 ;
91046: LD_ADDR_VAR 0 3
91050: PUSH
91051: LD_STRING 1
91053: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91054: LD_ADDR_VAR 0 6
91058: PUSH
91059: LD_VAR 0 6
91063: PUSH
91064: LD_VAR 0 3
91068: STR
91069: ST_TO_ADDR
// end ;
91070: GO 90966
91072: POP
91073: POP
// if isGameLoad then
91074: LD_VAR 0 1
91078: IFFALSE 91553
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
91080: LD_ADDR_VAR 0 4
91084: PUSH
91085: LD_EXP 128
91089: PUSH
91090: LD_EXP 127
91094: PUSH
91095: LD_EXP 129
91099: PUSH
91100: LD_EXP 126
91104: PUSH
91105: LD_EXP 130
91109: PUSH
91110: LD_EXP 131
91114: PUSH
91115: LD_EXP 132
91119: PUSH
91120: LD_EXP 133
91124: PUSH
91125: LD_EXP 134
91129: PUSH
91130: LD_EXP 135
91134: PUSH
91135: LD_EXP 136
91139: PUSH
91140: LD_EXP 137
91144: PUSH
91145: LD_EXP 138
91149: PUSH
91150: LD_EXP 139
91154: PUSH
91155: LD_EXP 147
91159: PUSH
91160: LD_EXP 148
91164: PUSH
91165: LD_EXP 149
91169: PUSH
91170: LD_EXP 150
91174: PUSH
91175: LD_EXP 152
91179: PUSH
91180: LD_EXP 153
91184: PUSH
91185: LD_EXP 154
91189: PUSH
91190: LD_EXP 157
91194: PUSH
91195: LD_EXP 159
91199: PUSH
91200: LD_EXP 160
91204: PUSH
91205: LD_EXP 161
91209: PUSH
91210: LD_EXP 163
91214: PUSH
91215: LD_EXP 164
91219: PUSH
91220: LD_EXP 167
91224: PUSH
91225: LD_EXP 168
91229: PUSH
91230: LD_EXP 169
91234: PUSH
91235: LD_EXP 170
91239: PUSH
91240: LD_EXP 171
91244: PUSH
91245: LD_EXP 172
91249: PUSH
91250: LD_EXP 173
91254: PUSH
91255: LD_EXP 174
91259: PUSH
91260: LD_EXP 175
91264: PUSH
91265: LD_EXP 140
91269: PUSH
91270: LD_EXP 141
91274: PUSH
91275: LD_EXP 144
91279: PUSH
91280: LD_EXP 145
91284: PUSH
91285: LD_EXP 146
91289: PUSH
91290: LD_EXP 142
91294: PUSH
91295: LD_EXP 143
91299: PUSH
91300: LD_EXP 151
91304: PUSH
91305: LD_EXP 155
91309: PUSH
91310: LD_EXP 156
91314: PUSH
91315: LD_EXP 158
91319: PUSH
91320: LD_EXP 162
91324: PUSH
91325: LD_EXP 165
91329: PUSH
91330: LD_EXP 166
91334: PUSH
91335: LD_EXP 176
91339: PUSH
91340: LD_EXP 177
91344: PUSH
91345: LD_EXP 178
91349: PUSH
91350: LD_EXP 179
91354: PUSH
91355: EMPTY
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: LIST
91361: LIST
91362: LIST
91363: LIST
91364: LIST
91365: LIST
91366: LIST
91367: LIST
91368: LIST
91369: LIST
91370: LIST
91371: LIST
91372: LIST
91373: LIST
91374: LIST
91375: LIST
91376: LIST
91377: LIST
91378: LIST
91379: LIST
91380: LIST
91381: LIST
91382: LIST
91383: LIST
91384: LIST
91385: LIST
91386: LIST
91387: LIST
91388: LIST
91389: LIST
91390: LIST
91391: LIST
91392: LIST
91393: LIST
91394: LIST
91395: LIST
91396: LIST
91397: LIST
91398: LIST
91399: LIST
91400: LIST
91401: LIST
91402: LIST
91403: LIST
91404: LIST
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: ST_TO_ADDR
// tmp :=  ;
91411: LD_ADDR_VAR 0 3
91415: PUSH
91416: LD_STRING 
91418: ST_TO_ADDR
// for i = 1 to normalCounter do
91419: LD_ADDR_VAR 0 8
91423: PUSH
91424: DOUBLE
91425: LD_INT 1
91427: DEC
91428: ST_TO_ADDR
91429: LD_EXP 124
91433: PUSH
91434: FOR_TO
91435: IFFALSE 91471
// begin if flags [ i ] then
91437: LD_VAR 0 4
91441: PUSH
91442: LD_VAR 0 8
91446: ARRAY
91447: IFFALSE 91469
// tmp := tmp & i & ; ;
91449: LD_ADDR_VAR 0 3
91453: PUSH
91454: LD_VAR 0 3
91458: PUSH
91459: LD_VAR 0 8
91463: STR
91464: PUSH
91465: LD_STRING ;
91467: STR
91468: ST_TO_ADDR
// end ;
91469: GO 91434
91471: POP
91472: POP
// for i = 1 to hardcoreCounter do
91473: LD_ADDR_VAR 0 8
91477: PUSH
91478: DOUBLE
91479: LD_INT 1
91481: DEC
91482: ST_TO_ADDR
91483: LD_EXP 125
91487: PUSH
91488: FOR_TO
91489: IFFALSE 91535
// begin if flags [ normalCounter + i ] then
91491: LD_VAR 0 4
91495: PUSH
91496: LD_EXP 124
91500: PUSH
91501: LD_VAR 0 8
91505: PLUS
91506: ARRAY
91507: IFFALSE 91533
// tmp := tmp & ( 100 + i ) & ; ;
91509: LD_ADDR_VAR 0 3
91513: PUSH
91514: LD_VAR 0 3
91518: PUSH
91519: LD_INT 100
91521: PUSH
91522: LD_VAR 0 8
91526: PLUS
91527: STR
91528: PUSH
91529: LD_STRING ;
91531: STR
91532: ST_TO_ADDR
// end ;
91533: GO 91488
91535: POP
91536: POP
// if tmp then
91537: LD_VAR 0 3
91541: IFFALSE 91553
// active := tmp ;
91543: LD_ADDR_VAR 0 7
91547: PUSH
91548: LD_VAR 0 3
91552: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
91553: LD_STRING getStreamItemsFromMission("
91555: PUSH
91556: LD_VAR 0 5
91560: STR
91561: PUSH
91562: LD_STRING ","
91564: STR
91565: PUSH
91566: LD_VAR 0 6
91570: STR
91571: PUSH
91572: LD_STRING ","
91574: STR
91575: PUSH
91576: LD_VAR 0 7
91580: STR
91581: PUSH
91582: LD_STRING ")
91584: STR
91585: PPUSH
91586: CALL_OW 559
// end else
91590: GO 91599
// ToLua ( getStreamItemsFromMission("","","") ) ;
91592: LD_STRING getStreamItemsFromMission("","","")
91594: PPUSH
91595: CALL_OW 559
// end ;
91599: LD_VAR 0 2
91603: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91604: LD_EXP 123
91608: PUSH
91609: LD_EXP 128
91613: AND
91614: IFFALSE 91738
91616: GO 91618
91618: DISABLE
91619: LD_INT 0
91621: PPUSH
91622: PPUSH
// begin enable ;
91623: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91624: LD_ADDR_VAR 0 2
91628: PUSH
91629: LD_INT 22
91631: PUSH
91632: LD_OWVAR 2
91636: PUSH
91637: EMPTY
91638: LIST
91639: LIST
91640: PUSH
91641: LD_INT 2
91643: PUSH
91644: LD_INT 34
91646: PUSH
91647: LD_INT 7
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 34
91656: PUSH
91657: LD_INT 45
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: LD_INT 34
91666: PUSH
91667: LD_INT 28
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 34
91676: PUSH
91677: LD_INT 47
91679: PUSH
91680: EMPTY
91681: LIST
91682: LIST
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PPUSH
91695: CALL_OW 69
91699: ST_TO_ADDR
// if not tmp then
91700: LD_VAR 0 2
91704: NOT
91705: IFFALSE 91709
// exit ;
91707: GO 91738
// for i in tmp do
91709: LD_ADDR_VAR 0 1
91713: PUSH
91714: LD_VAR 0 2
91718: PUSH
91719: FOR_IN
91720: IFFALSE 91736
// begin SetLives ( i , 0 ) ;
91722: LD_VAR 0 1
91726: PPUSH
91727: LD_INT 0
91729: PPUSH
91730: CALL_OW 234
// end ;
91734: GO 91719
91736: POP
91737: POP
// end ;
91738: PPOPN 2
91740: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91741: LD_EXP 123
91745: PUSH
91746: LD_EXP 129
91750: AND
91751: IFFALSE 91835
91753: GO 91755
91755: DISABLE
91756: LD_INT 0
91758: PPUSH
91759: PPUSH
// begin enable ;
91760: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
91761: LD_ADDR_VAR 0 2
91765: PUSH
91766: LD_INT 22
91768: PUSH
91769: LD_OWVAR 2
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: PUSH
91778: LD_INT 32
91780: PUSH
91781: LD_INT 3
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: PUSH
91788: EMPTY
91789: LIST
91790: LIST
91791: PPUSH
91792: CALL_OW 69
91796: ST_TO_ADDR
// if not tmp then
91797: LD_VAR 0 2
91801: NOT
91802: IFFALSE 91806
// exit ;
91804: GO 91835
// for i in tmp do
91806: LD_ADDR_VAR 0 1
91810: PUSH
91811: LD_VAR 0 2
91815: PUSH
91816: FOR_IN
91817: IFFALSE 91833
// begin SetLives ( i , 0 ) ;
91819: LD_VAR 0 1
91823: PPUSH
91824: LD_INT 0
91826: PPUSH
91827: CALL_OW 234
// end ;
91831: GO 91816
91833: POP
91834: POP
// end ;
91835: PPOPN 2
91837: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
91838: LD_EXP 123
91842: PUSH
91843: LD_EXP 126
91847: AND
91848: IFFALSE 91941
91850: GO 91852
91852: DISABLE
91853: LD_INT 0
91855: PPUSH
// begin enable ;
91856: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
91857: LD_ADDR_VAR 0 1
91861: PUSH
91862: LD_INT 22
91864: PUSH
91865: LD_OWVAR 2
91869: PUSH
91870: EMPTY
91871: LIST
91872: LIST
91873: PUSH
91874: LD_INT 2
91876: PUSH
91877: LD_INT 25
91879: PUSH
91880: LD_INT 5
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: LD_INT 25
91889: PUSH
91890: LD_INT 9
91892: PUSH
91893: EMPTY
91894: LIST
91895: LIST
91896: PUSH
91897: LD_INT 25
91899: PUSH
91900: LD_INT 8
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: EMPTY
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PPUSH
91917: CALL_OW 69
91921: PUSH
91922: FOR_IN
91923: IFFALSE 91939
// begin SetClass ( i , 1 ) ;
91925: LD_VAR 0 1
91929: PPUSH
91930: LD_INT 1
91932: PPUSH
91933: CALL_OW 336
// end ;
91937: GO 91922
91939: POP
91940: POP
// end ;
91941: PPOPN 1
91943: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
91944: LD_EXP 123
91948: PUSH
91949: LD_EXP 127
91953: AND
91954: PUSH
91955: LD_OWVAR 65
91959: PUSH
91960: LD_INT 7
91962: LESS
91963: AND
91964: IFFALSE 91978
91966: GO 91968
91968: DISABLE
// begin enable ;
91969: ENABLE
// game_speed := 7 ;
91970: LD_ADDR_OWVAR 65
91974: PUSH
91975: LD_INT 7
91977: ST_TO_ADDR
// end ;
91978: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
91979: LD_EXP 123
91983: PUSH
91984: LD_EXP 130
91988: AND
91989: IFFALSE 92191
91991: GO 91993
91993: DISABLE
91994: LD_INT 0
91996: PPUSH
91997: PPUSH
91998: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
91999: LD_ADDR_VAR 0 3
92003: PUSH
92004: LD_INT 81
92006: PUSH
92007: LD_OWVAR 2
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 21
92018: PUSH
92019: LD_INT 1
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PPUSH
92030: CALL_OW 69
92034: ST_TO_ADDR
// if not tmp then
92035: LD_VAR 0 3
92039: NOT
92040: IFFALSE 92044
// exit ;
92042: GO 92191
// if tmp > 5 then
92044: LD_VAR 0 3
92048: PUSH
92049: LD_INT 5
92051: GREATER
92052: IFFALSE 92064
// k := 5 else
92054: LD_ADDR_VAR 0 2
92058: PUSH
92059: LD_INT 5
92061: ST_TO_ADDR
92062: GO 92074
// k := tmp ;
92064: LD_ADDR_VAR 0 2
92068: PUSH
92069: LD_VAR 0 3
92073: ST_TO_ADDR
// for i := 1 to k do
92074: LD_ADDR_VAR 0 1
92078: PUSH
92079: DOUBLE
92080: LD_INT 1
92082: DEC
92083: ST_TO_ADDR
92084: LD_VAR 0 2
92088: PUSH
92089: FOR_TO
92090: IFFALSE 92189
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92092: LD_VAR 0 3
92096: PUSH
92097: LD_VAR 0 1
92101: ARRAY
92102: PPUSH
92103: LD_VAR 0 1
92107: PUSH
92108: LD_INT 4
92110: MOD
92111: PUSH
92112: LD_INT 1
92114: PLUS
92115: PPUSH
92116: CALL_OW 259
92120: PUSH
92121: LD_INT 10
92123: LESS
92124: IFFALSE 92187
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92126: LD_VAR 0 3
92130: PUSH
92131: LD_VAR 0 1
92135: ARRAY
92136: PPUSH
92137: LD_VAR 0 1
92141: PUSH
92142: LD_INT 4
92144: MOD
92145: PUSH
92146: LD_INT 1
92148: PLUS
92149: PPUSH
92150: LD_VAR 0 3
92154: PUSH
92155: LD_VAR 0 1
92159: ARRAY
92160: PPUSH
92161: LD_VAR 0 1
92165: PUSH
92166: LD_INT 4
92168: MOD
92169: PUSH
92170: LD_INT 1
92172: PLUS
92173: PPUSH
92174: CALL_OW 259
92178: PUSH
92179: LD_INT 1
92181: PLUS
92182: PPUSH
92183: CALL_OW 237
92187: GO 92089
92189: POP
92190: POP
// end ;
92191: PPOPN 3
92193: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92194: LD_EXP 123
92198: PUSH
92199: LD_EXP 131
92203: AND
92204: IFFALSE 92224
92206: GO 92208
92208: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92209: LD_INT 4
92211: PPUSH
92212: LD_OWVAR 2
92216: PPUSH
92217: LD_INT 0
92219: PPUSH
92220: CALL_OW 324
92224: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92225: LD_EXP 123
92229: PUSH
92230: LD_EXP 160
92234: AND
92235: IFFALSE 92255
92237: GO 92239
92239: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92240: LD_INT 19
92242: PPUSH
92243: LD_OWVAR 2
92247: PPUSH
92248: LD_INT 0
92250: PPUSH
92251: CALL_OW 324
92255: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92256: LD_EXP 123
92260: PUSH
92261: LD_EXP 132
92265: AND
92266: IFFALSE 92368
92268: GO 92270
92270: DISABLE
92271: LD_INT 0
92273: PPUSH
92274: PPUSH
// begin enable ;
92275: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92276: LD_ADDR_VAR 0 2
92280: PUSH
92281: LD_INT 22
92283: PUSH
92284: LD_OWVAR 2
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 2
92295: PUSH
92296: LD_INT 34
92298: PUSH
92299: LD_INT 11
92301: PUSH
92302: EMPTY
92303: LIST
92304: LIST
92305: PUSH
92306: LD_INT 34
92308: PUSH
92309: LD_INT 30
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: LIST
92320: PUSH
92321: EMPTY
92322: LIST
92323: LIST
92324: PPUSH
92325: CALL_OW 69
92329: ST_TO_ADDR
// if not tmp then
92330: LD_VAR 0 2
92334: NOT
92335: IFFALSE 92339
// exit ;
92337: GO 92368
// for i in tmp do
92339: LD_ADDR_VAR 0 1
92343: PUSH
92344: LD_VAR 0 2
92348: PUSH
92349: FOR_IN
92350: IFFALSE 92366
// begin SetLives ( i , 0 ) ;
92352: LD_VAR 0 1
92356: PPUSH
92357: LD_INT 0
92359: PPUSH
92360: CALL_OW 234
// end ;
92364: GO 92349
92366: POP
92367: POP
// end ;
92368: PPOPN 2
92370: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92371: LD_EXP 123
92375: PUSH
92376: LD_EXP 133
92380: AND
92381: IFFALSE 92401
92383: GO 92385
92385: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92386: LD_INT 32
92388: PPUSH
92389: LD_OWVAR 2
92393: PPUSH
92394: LD_INT 0
92396: PPUSH
92397: CALL_OW 324
92401: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92402: LD_EXP 123
92406: PUSH
92407: LD_EXP 134
92411: AND
92412: IFFALSE 92593
92414: GO 92416
92416: DISABLE
92417: LD_INT 0
92419: PPUSH
92420: PPUSH
92421: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92422: LD_ADDR_VAR 0 2
92426: PUSH
92427: LD_INT 22
92429: PUSH
92430: LD_OWVAR 2
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 33
92441: PUSH
92442: LD_INT 3
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: EMPTY
92450: LIST
92451: LIST
92452: PPUSH
92453: CALL_OW 69
92457: ST_TO_ADDR
// if not tmp then
92458: LD_VAR 0 2
92462: NOT
92463: IFFALSE 92467
// exit ;
92465: GO 92593
// side := 0 ;
92467: LD_ADDR_VAR 0 3
92471: PUSH
92472: LD_INT 0
92474: ST_TO_ADDR
// for i := 1 to 8 do
92475: LD_ADDR_VAR 0 1
92479: PUSH
92480: DOUBLE
92481: LD_INT 1
92483: DEC
92484: ST_TO_ADDR
92485: LD_INT 8
92487: PUSH
92488: FOR_TO
92489: IFFALSE 92537
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92491: LD_OWVAR 2
92495: PUSH
92496: LD_VAR 0 1
92500: NONEQUAL
92501: PUSH
92502: LD_OWVAR 2
92506: PPUSH
92507: LD_VAR 0 1
92511: PPUSH
92512: CALL_OW 81
92516: PUSH
92517: LD_INT 2
92519: EQUAL
92520: AND
92521: IFFALSE 92535
// begin side := i ;
92523: LD_ADDR_VAR 0 3
92527: PUSH
92528: LD_VAR 0 1
92532: ST_TO_ADDR
// break ;
92533: GO 92537
// end ;
92535: GO 92488
92537: POP
92538: POP
// if not side then
92539: LD_VAR 0 3
92543: NOT
92544: IFFALSE 92548
// exit ;
92546: GO 92593
// for i := 1 to tmp do
92548: LD_ADDR_VAR 0 1
92552: PUSH
92553: DOUBLE
92554: LD_INT 1
92556: DEC
92557: ST_TO_ADDR
92558: LD_VAR 0 2
92562: PUSH
92563: FOR_TO
92564: IFFALSE 92591
// if Prob ( 60 ) then
92566: LD_INT 60
92568: PPUSH
92569: CALL_OW 13
92573: IFFALSE 92589
// SetSide ( i , side ) ;
92575: LD_VAR 0 1
92579: PPUSH
92580: LD_VAR 0 3
92584: PPUSH
92585: CALL_OW 235
92589: GO 92563
92591: POP
92592: POP
// end ;
92593: PPOPN 3
92595: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92596: LD_EXP 123
92600: PUSH
92601: LD_EXP 136
92605: AND
92606: IFFALSE 92725
92608: GO 92610
92610: DISABLE
92611: LD_INT 0
92613: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92614: LD_ADDR_VAR 0 1
92618: PUSH
92619: LD_INT 22
92621: PUSH
92622: LD_OWVAR 2
92626: PUSH
92627: EMPTY
92628: LIST
92629: LIST
92630: PUSH
92631: LD_INT 21
92633: PUSH
92634: LD_INT 1
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 3
92643: PUSH
92644: LD_INT 23
92646: PUSH
92647: LD_INT 0
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: LIST
92662: PPUSH
92663: CALL_OW 69
92667: PUSH
92668: FOR_IN
92669: IFFALSE 92723
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92671: LD_VAR 0 1
92675: PPUSH
92676: CALL_OW 257
92680: PUSH
92681: LD_INT 1
92683: PUSH
92684: LD_INT 2
92686: PUSH
92687: LD_INT 3
92689: PUSH
92690: LD_INT 4
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: LIST
92697: LIST
92698: IN
92699: IFFALSE 92721
// SetClass ( un , rand ( 1 , 4 ) ) ;
92701: LD_VAR 0 1
92705: PPUSH
92706: LD_INT 1
92708: PPUSH
92709: LD_INT 4
92711: PPUSH
92712: CALL_OW 12
92716: PPUSH
92717: CALL_OW 336
92721: GO 92668
92723: POP
92724: POP
// end ;
92725: PPOPN 1
92727: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92728: LD_EXP 123
92732: PUSH
92733: LD_EXP 135
92737: AND
92738: IFFALSE 92817
92740: GO 92742
92742: DISABLE
92743: LD_INT 0
92745: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92746: LD_ADDR_VAR 0 1
92750: PUSH
92751: LD_INT 22
92753: PUSH
92754: LD_OWVAR 2
92758: PUSH
92759: EMPTY
92760: LIST
92761: LIST
92762: PUSH
92763: LD_INT 21
92765: PUSH
92766: LD_INT 3
92768: PUSH
92769: EMPTY
92770: LIST
92771: LIST
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PPUSH
92777: CALL_OW 69
92781: ST_TO_ADDR
// if not tmp then
92782: LD_VAR 0 1
92786: NOT
92787: IFFALSE 92791
// exit ;
92789: GO 92817
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
92791: LD_VAR 0 1
92795: PUSH
92796: LD_INT 1
92798: PPUSH
92799: LD_VAR 0 1
92803: PPUSH
92804: CALL_OW 12
92808: ARRAY
92809: PPUSH
92810: LD_INT 100
92812: PPUSH
92813: CALL_OW 234
// end ;
92817: PPOPN 1
92819: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
92820: LD_EXP 123
92824: PUSH
92825: LD_EXP 137
92829: AND
92830: IFFALSE 92928
92832: GO 92834
92834: DISABLE
92835: LD_INT 0
92837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
92838: LD_ADDR_VAR 0 1
92842: PUSH
92843: LD_INT 22
92845: PUSH
92846: LD_OWVAR 2
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 21
92857: PUSH
92858: LD_INT 1
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PPUSH
92869: CALL_OW 69
92873: ST_TO_ADDR
// if not tmp then
92874: LD_VAR 0 1
92878: NOT
92879: IFFALSE 92883
// exit ;
92881: GO 92928
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
92883: LD_VAR 0 1
92887: PUSH
92888: LD_INT 1
92890: PPUSH
92891: LD_VAR 0 1
92895: PPUSH
92896: CALL_OW 12
92900: ARRAY
92901: PPUSH
92902: LD_INT 1
92904: PPUSH
92905: LD_INT 4
92907: PPUSH
92908: CALL_OW 12
92912: PPUSH
92913: LD_INT 3000
92915: PPUSH
92916: LD_INT 9000
92918: PPUSH
92919: CALL_OW 12
92923: PPUSH
92924: CALL_OW 492
// end ;
92928: PPOPN 1
92930: END
// every 0 0$1 trigger StreamModeActive and sDepot do
92931: LD_EXP 123
92935: PUSH
92936: LD_EXP 138
92940: AND
92941: IFFALSE 92961
92943: GO 92945
92945: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
92946: LD_INT 1
92948: PPUSH
92949: LD_OWVAR 2
92953: PPUSH
92954: LD_INT 0
92956: PPUSH
92957: CALL_OW 324
92961: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
92962: LD_EXP 123
92966: PUSH
92967: LD_EXP 139
92971: AND
92972: IFFALSE 93055
92974: GO 92976
92976: DISABLE
92977: LD_INT 0
92979: PPUSH
92980: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92981: LD_ADDR_VAR 0 2
92985: PUSH
92986: LD_INT 22
92988: PUSH
92989: LD_OWVAR 2
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 21
93000: PUSH
93001: LD_INT 3
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PPUSH
93012: CALL_OW 69
93016: ST_TO_ADDR
// if not tmp then
93017: LD_VAR 0 2
93021: NOT
93022: IFFALSE 93026
// exit ;
93024: GO 93055
// for i in tmp do
93026: LD_ADDR_VAR 0 1
93030: PUSH
93031: LD_VAR 0 2
93035: PUSH
93036: FOR_IN
93037: IFFALSE 93053
// SetBLevel ( i , 10 ) ;
93039: LD_VAR 0 1
93043: PPUSH
93044: LD_INT 10
93046: PPUSH
93047: CALL_OW 241
93051: GO 93036
93053: POP
93054: POP
// end ;
93055: PPOPN 2
93057: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93058: LD_EXP 123
93062: PUSH
93063: LD_EXP 140
93067: AND
93068: IFFALSE 93179
93070: GO 93072
93072: DISABLE
93073: LD_INT 0
93075: PPUSH
93076: PPUSH
93077: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93078: LD_ADDR_VAR 0 3
93082: PUSH
93083: LD_INT 22
93085: PUSH
93086: LD_OWVAR 2
93090: PUSH
93091: EMPTY
93092: LIST
93093: LIST
93094: PUSH
93095: LD_INT 25
93097: PUSH
93098: LD_INT 1
93100: PUSH
93101: EMPTY
93102: LIST
93103: LIST
93104: PUSH
93105: EMPTY
93106: LIST
93107: LIST
93108: PPUSH
93109: CALL_OW 69
93113: ST_TO_ADDR
// if not tmp then
93114: LD_VAR 0 3
93118: NOT
93119: IFFALSE 93123
// exit ;
93121: GO 93179
// un := tmp [ rand ( 1 , tmp ) ] ;
93123: LD_ADDR_VAR 0 2
93127: PUSH
93128: LD_VAR 0 3
93132: PUSH
93133: LD_INT 1
93135: PPUSH
93136: LD_VAR 0 3
93140: PPUSH
93141: CALL_OW 12
93145: ARRAY
93146: ST_TO_ADDR
// if Crawls ( un ) then
93147: LD_VAR 0 2
93151: PPUSH
93152: CALL_OW 318
93156: IFFALSE 93167
// ComWalk ( un ) ;
93158: LD_VAR 0 2
93162: PPUSH
93163: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93167: LD_VAR 0 2
93171: PPUSH
93172: LD_INT 5
93174: PPUSH
93175: CALL_OW 336
// end ;
93179: PPOPN 3
93181: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
93182: LD_EXP 123
93186: PUSH
93187: LD_EXP 141
93191: AND
93192: PUSH
93193: LD_OWVAR 67
93197: PUSH
93198: LD_INT 4
93200: LESS
93201: AND
93202: IFFALSE 93221
93204: GO 93206
93206: DISABLE
// begin Difficulty := Difficulty + 1 ;
93207: LD_ADDR_OWVAR 67
93211: PUSH
93212: LD_OWVAR 67
93216: PUSH
93217: LD_INT 1
93219: PLUS
93220: ST_TO_ADDR
// end ;
93221: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93222: LD_EXP 123
93226: PUSH
93227: LD_EXP 142
93231: AND
93232: IFFALSE 93335
93234: GO 93236
93236: DISABLE
93237: LD_INT 0
93239: PPUSH
// begin for i := 1 to 5 do
93240: LD_ADDR_VAR 0 1
93244: PUSH
93245: DOUBLE
93246: LD_INT 1
93248: DEC
93249: ST_TO_ADDR
93250: LD_INT 5
93252: PUSH
93253: FOR_TO
93254: IFFALSE 93333
// begin uc_nation := nation_nature ;
93256: LD_ADDR_OWVAR 21
93260: PUSH
93261: LD_INT 0
93263: ST_TO_ADDR
// uc_side := 0 ;
93264: LD_ADDR_OWVAR 20
93268: PUSH
93269: LD_INT 0
93271: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93272: LD_ADDR_OWVAR 29
93276: PUSH
93277: LD_INT 12
93279: PUSH
93280: LD_INT 12
93282: PUSH
93283: EMPTY
93284: LIST
93285: LIST
93286: ST_TO_ADDR
// hc_agressivity := 20 ;
93287: LD_ADDR_OWVAR 35
93291: PUSH
93292: LD_INT 20
93294: ST_TO_ADDR
// hc_class := class_tiger ;
93295: LD_ADDR_OWVAR 28
93299: PUSH
93300: LD_INT 14
93302: ST_TO_ADDR
// hc_gallery :=  ;
93303: LD_ADDR_OWVAR 33
93307: PUSH
93308: LD_STRING 
93310: ST_TO_ADDR
// hc_name :=  ;
93311: LD_ADDR_OWVAR 26
93315: PUSH
93316: LD_STRING 
93318: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93319: CALL_OW 44
93323: PPUSH
93324: LD_INT 0
93326: PPUSH
93327: CALL_OW 51
// end ;
93331: GO 93253
93333: POP
93334: POP
// end ;
93335: PPOPN 1
93337: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93338: LD_EXP 123
93342: PUSH
93343: LD_EXP 143
93347: AND
93348: IFFALSE 93357
93350: GO 93352
93352: DISABLE
// StreamSibBomb ;
93353: CALL 93358 0 0
93357: END
// export function StreamSibBomb ; var i , x , y ; begin
93358: LD_INT 0
93360: PPUSH
93361: PPUSH
93362: PPUSH
93363: PPUSH
// result := false ;
93364: LD_ADDR_VAR 0 1
93368: PUSH
93369: LD_INT 0
93371: ST_TO_ADDR
// for i := 1 to 16 do
93372: LD_ADDR_VAR 0 2
93376: PUSH
93377: DOUBLE
93378: LD_INT 1
93380: DEC
93381: ST_TO_ADDR
93382: LD_INT 16
93384: PUSH
93385: FOR_TO
93386: IFFALSE 93585
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93388: LD_ADDR_VAR 0 3
93392: PUSH
93393: LD_INT 10
93395: PUSH
93396: LD_INT 20
93398: PUSH
93399: LD_INT 30
93401: PUSH
93402: LD_INT 40
93404: PUSH
93405: LD_INT 50
93407: PUSH
93408: LD_INT 60
93410: PUSH
93411: LD_INT 70
93413: PUSH
93414: LD_INT 80
93416: PUSH
93417: LD_INT 90
93419: PUSH
93420: LD_INT 100
93422: PUSH
93423: LD_INT 110
93425: PUSH
93426: LD_INT 120
93428: PUSH
93429: LD_INT 130
93431: PUSH
93432: LD_INT 140
93434: PUSH
93435: LD_INT 150
93437: PUSH
93438: EMPTY
93439: LIST
93440: LIST
93441: LIST
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: LIST
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: PUSH
93455: LD_INT 1
93457: PPUSH
93458: LD_INT 15
93460: PPUSH
93461: CALL_OW 12
93465: ARRAY
93466: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93467: LD_ADDR_VAR 0 4
93471: PUSH
93472: LD_INT 10
93474: PUSH
93475: LD_INT 20
93477: PUSH
93478: LD_INT 30
93480: PUSH
93481: LD_INT 40
93483: PUSH
93484: LD_INT 50
93486: PUSH
93487: LD_INT 60
93489: PUSH
93490: LD_INT 70
93492: PUSH
93493: LD_INT 80
93495: PUSH
93496: LD_INT 90
93498: PUSH
93499: LD_INT 100
93501: PUSH
93502: LD_INT 110
93504: PUSH
93505: LD_INT 120
93507: PUSH
93508: LD_INT 130
93510: PUSH
93511: LD_INT 140
93513: PUSH
93514: LD_INT 150
93516: PUSH
93517: EMPTY
93518: LIST
93519: LIST
93520: LIST
93521: LIST
93522: LIST
93523: LIST
93524: LIST
93525: LIST
93526: LIST
93527: LIST
93528: LIST
93529: LIST
93530: LIST
93531: LIST
93532: LIST
93533: PUSH
93534: LD_INT 1
93536: PPUSH
93537: LD_INT 15
93539: PPUSH
93540: CALL_OW 12
93544: ARRAY
93545: ST_TO_ADDR
// if ValidHex ( x , y ) then
93546: LD_VAR 0 3
93550: PPUSH
93551: LD_VAR 0 4
93555: PPUSH
93556: CALL_OW 488
93560: IFFALSE 93583
// begin result := [ x , y ] ;
93562: LD_ADDR_VAR 0 1
93566: PUSH
93567: LD_VAR 0 3
93571: PUSH
93572: LD_VAR 0 4
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: ST_TO_ADDR
// break ;
93581: GO 93585
// end ; end ;
93583: GO 93385
93585: POP
93586: POP
// if result then
93587: LD_VAR 0 1
93591: IFFALSE 93651
// begin ToLua ( playSibBomb() ) ;
93593: LD_STRING playSibBomb()
93595: PPUSH
93596: CALL_OW 559
// wait ( 0 0$14 ) ;
93600: LD_INT 490
93602: PPUSH
93603: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93607: LD_VAR 0 1
93611: PUSH
93612: LD_INT 1
93614: ARRAY
93615: PPUSH
93616: LD_VAR 0 1
93620: PUSH
93621: LD_INT 2
93623: ARRAY
93624: PPUSH
93625: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93629: LD_VAR 0 1
93633: PUSH
93634: LD_INT 1
93636: ARRAY
93637: PPUSH
93638: LD_VAR 0 1
93642: PUSH
93643: LD_INT 2
93645: ARRAY
93646: PPUSH
93647: CALL_OW 429
// end ; end ;
93651: LD_VAR 0 1
93655: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93656: LD_EXP 123
93660: PUSH
93661: LD_EXP 145
93665: AND
93666: IFFALSE 93678
93668: GO 93670
93670: DISABLE
// YouLost (  ) ;
93671: LD_STRING 
93673: PPUSH
93674: CALL_OW 104
93678: END
// every 0 0$1 trigger StreamModeActive and sFog do
93679: LD_EXP 123
93683: PUSH
93684: LD_EXP 144
93688: AND
93689: IFFALSE 93703
93691: GO 93693
93693: DISABLE
// FogOff ( your_side ) ;
93694: LD_OWVAR 2
93698: PPUSH
93699: CALL_OW 344
93703: END
// every 0 0$1 trigger StreamModeActive and sSun do
93704: LD_EXP 123
93708: PUSH
93709: LD_EXP 146
93713: AND
93714: IFFALSE 93742
93716: GO 93718
93718: DISABLE
// begin solar_recharge_percent := 0 ;
93719: LD_ADDR_OWVAR 79
93723: PUSH
93724: LD_INT 0
93726: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93727: LD_INT 10500
93729: PPUSH
93730: CALL_OW 67
// solar_recharge_percent := 100 ;
93734: LD_ADDR_OWVAR 79
93738: PUSH
93739: LD_INT 100
93741: ST_TO_ADDR
// end ;
93742: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93743: LD_EXP 123
93747: PUSH
93748: LD_EXP 147
93752: AND
93753: IFFALSE 93992
93755: GO 93757
93757: DISABLE
93758: LD_INT 0
93760: PPUSH
93761: PPUSH
93762: PPUSH
// begin tmp := [ ] ;
93763: LD_ADDR_VAR 0 3
93767: PUSH
93768: EMPTY
93769: ST_TO_ADDR
// for i := 1 to 6 do
93770: LD_ADDR_VAR 0 1
93774: PUSH
93775: DOUBLE
93776: LD_INT 1
93778: DEC
93779: ST_TO_ADDR
93780: LD_INT 6
93782: PUSH
93783: FOR_TO
93784: IFFALSE 93889
// begin uc_nation := nation_nature ;
93786: LD_ADDR_OWVAR 21
93790: PUSH
93791: LD_INT 0
93793: ST_TO_ADDR
// uc_side := 0 ;
93794: LD_ADDR_OWVAR 20
93798: PUSH
93799: LD_INT 0
93801: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93802: LD_ADDR_OWVAR 29
93806: PUSH
93807: LD_INT 12
93809: PUSH
93810: LD_INT 12
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: ST_TO_ADDR
// hc_agressivity := 20 ;
93817: LD_ADDR_OWVAR 35
93821: PUSH
93822: LD_INT 20
93824: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
93825: LD_ADDR_OWVAR 28
93829: PUSH
93830: LD_INT 17
93832: ST_TO_ADDR
// hc_gallery :=  ;
93833: LD_ADDR_OWVAR 33
93837: PUSH
93838: LD_STRING 
93840: ST_TO_ADDR
// hc_name :=  ;
93841: LD_ADDR_OWVAR 26
93845: PUSH
93846: LD_STRING 
93848: ST_TO_ADDR
// un := CreateHuman ;
93849: LD_ADDR_VAR 0 2
93853: PUSH
93854: CALL_OW 44
93858: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
93859: LD_VAR 0 2
93863: PPUSH
93864: LD_INT 1
93866: PPUSH
93867: CALL_OW 51
// tmp := tmp ^ un ;
93871: LD_ADDR_VAR 0 3
93875: PUSH
93876: LD_VAR 0 3
93880: PUSH
93881: LD_VAR 0 2
93885: ADD
93886: ST_TO_ADDR
// end ;
93887: GO 93783
93889: POP
93890: POP
// repeat wait ( 0 0$1 ) ;
93891: LD_INT 35
93893: PPUSH
93894: CALL_OW 67
// for un in tmp do
93898: LD_ADDR_VAR 0 2
93902: PUSH
93903: LD_VAR 0 3
93907: PUSH
93908: FOR_IN
93909: IFFALSE 93983
// begin if IsDead ( un ) then
93911: LD_VAR 0 2
93915: PPUSH
93916: CALL_OW 301
93920: IFFALSE 93940
// begin tmp := tmp diff un ;
93922: LD_ADDR_VAR 0 3
93926: PUSH
93927: LD_VAR 0 3
93931: PUSH
93932: LD_VAR 0 2
93936: DIFF
93937: ST_TO_ADDR
// continue ;
93938: GO 93908
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
93940: LD_VAR 0 2
93944: PPUSH
93945: LD_INT 3
93947: PUSH
93948: LD_INT 22
93950: PUSH
93951: LD_INT 0
93953: PUSH
93954: EMPTY
93955: LIST
93956: LIST
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PPUSH
93962: CALL_OW 69
93966: PPUSH
93967: LD_VAR 0 2
93971: PPUSH
93972: CALL_OW 74
93976: PPUSH
93977: CALL_OW 115
// end ;
93981: GO 93908
93983: POP
93984: POP
// until not tmp ;
93985: LD_VAR 0 3
93989: NOT
93990: IFFALSE 93891
// end ;
93992: PPOPN 3
93994: END
// every 0 0$1 trigger StreamModeActive and sTroll do
93995: LD_EXP 123
93999: PUSH
94000: LD_EXP 148
94004: AND
94005: IFFALSE 94059
94007: GO 94009
94009: DISABLE
// begin ToLua ( displayTroll(); ) ;
94010: LD_STRING displayTroll();
94012: PPUSH
94013: CALL_OW 559
// wait ( 3 3$00 ) ;
94017: LD_INT 6300
94019: PPUSH
94020: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94024: LD_STRING hideTroll();
94026: PPUSH
94027: CALL_OW 559
// wait ( 1 1$00 ) ;
94031: LD_INT 2100
94033: PPUSH
94034: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94038: LD_STRING displayTroll();
94040: PPUSH
94041: CALL_OW 559
// wait ( 1 1$00 ) ;
94045: LD_INT 2100
94047: PPUSH
94048: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94052: LD_STRING hideTroll();
94054: PPUSH
94055: CALL_OW 559
// end ;
94059: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94060: LD_EXP 123
94064: PUSH
94065: LD_EXP 149
94069: AND
94070: IFFALSE 94133
94072: GO 94074
94074: DISABLE
94075: LD_INT 0
94077: PPUSH
// begin p := 0 ;
94078: LD_ADDR_VAR 0 1
94082: PUSH
94083: LD_INT 0
94085: ST_TO_ADDR
// repeat game_speed := 1 ;
94086: LD_ADDR_OWVAR 65
94090: PUSH
94091: LD_INT 1
94093: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94094: LD_INT 35
94096: PPUSH
94097: CALL_OW 67
// p := p + 1 ;
94101: LD_ADDR_VAR 0 1
94105: PUSH
94106: LD_VAR 0 1
94110: PUSH
94111: LD_INT 1
94113: PLUS
94114: ST_TO_ADDR
// until p >= 60 ;
94115: LD_VAR 0 1
94119: PUSH
94120: LD_INT 60
94122: GREATEREQUAL
94123: IFFALSE 94086
// game_speed := 4 ;
94125: LD_ADDR_OWVAR 65
94129: PUSH
94130: LD_INT 4
94132: ST_TO_ADDR
// end ;
94133: PPOPN 1
94135: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94136: LD_EXP 123
94140: PUSH
94141: LD_EXP 150
94145: AND
94146: IFFALSE 94292
94148: GO 94150
94150: DISABLE
94151: LD_INT 0
94153: PPUSH
94154: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94155: LD_ADDR_VAR 0 1
94159: PUSH
94160: LD_INT 22
94162: PUSH
94163: LD_OWVAR 2
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 2
94174: PUSH
94175: LD_INT 30
94177: PUSH
94178: LD_INT 0
94180: PUSH
94181: EMPTY
94182: LIST
94183: LIST
94184: PUSH
94185: LD_INT 30
94187: PUSH
94188: LD_INT 1
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: LIST
94199: PUSH
94200: EMPTY
94201: LIST
94202: LIST
94203: PPUSH
94204: CALL_OW 69
94208: ST_TO_ADDR
// if not depot then
94209: LD_VAR 0 1
94213: NOT
94214: IFFALSE 94218
// exit ;
94216: GO 94292
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94218: LD_ADDR_VAR 0 2
94222: PUSH
94223: LD_VAR 0 1
94227: PUSH
94228: LD_INT 1
94230: PPUSH
94231: LD_VAR 0 1
94235: PPUSH
94236: CALL_OW 12
94240: ARRAY
94241: PPUSH
94242: CALL_OW 274
94246: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94247: LD_VAR 0 2
94251: PPUSH
94252: LD_INT 1
94254: PPUSH
94255: LD_INT 0
94257: PPUSH
94258: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94262: LD_VAR 0 2
94266: PPUSH
94267: LD_INT 2
94269: PPUSH
94270: LD_INT 0
94272: PPUSH
94273: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94277: LD_VAR 0 2
94281: PPUSH
94282: LD_INT 3
94284: PPUSH
94285: LD_INT 0
94287: PPUSH
94288: CALL_OW 277
// end ;
94292: PPOPN 2
94294: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94295: LD_EXP 123
94299: PUSH
94300: LD_EXP 151
94304: AND
94305: IFFALSE 94402
94307: GO 94309
94309: DISABLE
94310: LD_INT 0
94312: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94313: LD_ADDR_VAR 0 1
94317: PUSH
94318: LD_INT 22
94320: PUSH
94321: LD_OWVAR 2
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 21
94332: PUSH
94333: LD_INT 1
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 3
94342: PUSH
94343: LD_INT 23
94345: PUSH
94346: LD_INT 0
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: EMPTY
94354: LIST
94355: LIST
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: LIST
94361: PPUSH
94362: CALL_OW 69
94366: ST_TO_ADDR
// if not tmp then
94367: LD_VAR 0 1
94371: NOT
94372: IFFALSE 94376
// exit ;
94374: GO 94402
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94376: LD_VAR 0 1
94380: PUSH
94381: LD_INT 1
94383: PPUSH
94384: LD_VAR 0 1
94388: PPUSH
94389: CALL_OW 12
94393: ARRAY
94394: PPUSH
94395: LD_INT 200
94397: PPUSH
94398: CALL_OW 234
// end ;
94402: PPOPN 1
94404: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94405: LD_EXP 123
94409: PUSH
94410: LD_EXP 152
94414: AND
94415: IFFALSE 94494
94417: GO 94419
94419: DISABLE
94420: LD_INT 0
94422: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94423: LD_ADDR_VAR 0 1
94427: PUSH
94428: LD_INT 22
94430: PUSH
94431: LD_OWVAR 2
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: LD_INT 21
94442: PUSH
94443: LD_INT 2
94445: PUSH
94446: EMPTY
94447: LIST
94448: LIST
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PPUSH
94454: CALL_OW 69
94458: ST_TO_ADDR
// if not tmp then
94459: LD_VAR 0 1
94463: NOT
94464: IFFALSE 94468
// exit ;
94466: GO 94494
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94468: LD_VAR 0 1
94472: PUSH
94473: LD_INT 1
94475: PPUSH
94476: LD_VAR 0 1
94480: PPUSH
94481: CALL_OW 12
94485: ARRAY
94486: PPUSH
94487: LD_INT 60
94489: PPUSH
94490: CALL_OW 234
// end ;
94494: PPOPN 1
94496: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94497: LD_EXP 123
94501: PUSH
94502: LD_EXP 153
94506: AND
94507: IFFALSE 94606
94509: GO 94511
94511: DISABLE
94512: LD_INT 0
94514: PPUSH
94515: PPUSH
// begin enable ;
94516: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94517: LD_ADDR_VAR 0 1
94521: PUSH
94522: LD_INT 22
94524: PUSH
94525: LD_OWVAR 2
94529: PUSH
94530: EMPTY
94531: LIST
94532: LIST
94533: PUSH
94534: LD_INT 61
94536: PUSH
94537: EMPTY
94538: LIST
94539: PUSH
94540: LD_INT 33
94542: PUSH
94543: LD_INT 2
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: LIST
94554: PPUSH
94555: CALL_OW 69
94559: ST_TO_ADDR
// if not tmp then
94560: LD_VAR 0 1
94564: NOT
94565: IFFALSE 94569
// exit ;
94567: GO 94606
// for i in tmp do
94569: LD_ADDR_VAR 0 2
94573: PUSH
94574: LD_VAR 0 1
94578: PUSH
94579: FOR_IN
94580: IFFALSE 94604
// if IsControledBy ( i ) then
94582: LD_VAR 0 2
94586: PPUSH
94587: CALL_OW 312
94591: IFFALSE 94602
// ComUnlink ( i ) ;
94593: LD_VAR 0 2
94597: PPUSH
94598: CALL_OW 136
94602: GO 94579
94604: POP
94605: POP
// end ;
94606: PPOPN 2
94608: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94609: LD_EXP 123
94613: PUSH
94614: LD_EXP 154
94618: AND
94619: IFFALSE 94759
94621: GO 94623
94623: DISABLE
94624: LD_INT 0
94626: PPUSH
94627: PPUSH
// begin ToLua ( displayPowell(); ) ;
94628: LD_STRING displayPowell();
94630: PPUSH
94631: CALL_OW 559
// uc_side := 0 ;
94635: LD_ADDR_OWVAR 20
94639: PUSH
94640: LD_INT 0
94642: ST_TO_ADDR
// uc_nation := 2 ;
94643: LD_ADDR_OWVAR 21
94647: PUSH
94648: LD_INT 2
94650: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94651: LD_ADDR_OWVAR 37
94655: PUSH
94656: LD_INT 14
94658: ST_TO_ADDR
// vc_engine := engine_siberite ;
94659: LD_ADDR_OWVAR 39
94663: PUSH
94664: LD_INT 3
94666: ST_TO_ADDR
// vc_control := control_apeman ;
94667: LD_ADDR_OWVAR 38
94671: PUSH
94672: LD_INT 5
94674: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94675: LD_ADDR_OWVAR 40
94679: PUSH
94680: LD_INT 29
94682: ST_TO_ADDR
// un := CreateVehicle ;
94683: LD_ADDR_VAR 0 2
94687: PUSH
94688: CALL_OW 45
94692: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94693: LD_VAR 0 2
94697: PPUSH
94698: LD_INT 1
94700: PPUSH
94701: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94705: LD_INT 35
94707: PPUSH
94708: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94712: LD_VAR 0 2
94716: PPUSH
94717: LD_INT 22
94719: PUSH
94720: LD_OWVAR 2
94724: PUSH
94725: EMPTY
94726: LIST
94727: LIST
94728: PPUSH
94729: CALL_OW 69
94733: PPUSH
94734: LD_VAR 0 2
94738: PPUSH
94739: CALL_OW 74
94743: PPUSH
94744: CALL_OW 115
// until IsDead ( un ) ;
94748: LD_VAR 0 2
94752: PPUSH
94753: CALL_OW 301
94757: IFFALSE 94705
// end ;
94759: PPOPN 2
94761: END
// every 0 0$1 trigger StreamModeActive and sStu do
94762: LD_EXP 123
94766: PUSH
94767: LD_EXP 162
94771: AND
94772: IFFALSE 94788
94774: GO 94776
94776: DISABLE
// begin ToLua ( displayStucuk(); ) ;
94777: LD_STRING displayStucuk();
94779: PPUSH
94780: CALL_OW 559
// ResetFog ;
94784: CALL_OW 335
// end ;
94788: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
94789: LD_EXP 123
94793: PUSH
94794: LD_EXP 155
94798: AND
94799: IFFALSE 94940
94801: GO 94803
94803: DISABLE
94804: LD_INT 0
94806: PPUSH
94807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94808: LD_ADDR_VAR 0 2
94812: PUSH
94813: LD_INT 22
94815: PUSH
94816: LD_OWVAR 2
94820: PUSH
94821: EMPTY
94822: LIST
94823: LIST
94824: PUSH
94825: LD_INT 21
94827: PUSH
94828: LD_INT 1
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PPUSH
94839: CALL_OW 69
94843: ST_TO_ADDR
// if not tmp then
94844: LD_VAR 0 2
94848: NOT
94849: IFFALSE 94853
// exit ;
94851: GO 94940
// un := tmp [ rand ( 1 , tmp ) ] ;
94853: LD_ADDR_VAR 0 1
94857: PUSH
94858: LD_VAR 0 2
94862: PUSH
94863: LD_INT 1
94865: PPUSH
94866: LD_VAR 0 2
94870: PPUSH
94871: CALL_OW 12
94875: ARRAY
94876: ST_TO_ADDR
// SetSide ( un , 0 ) ;
94877: LD_VAR 0 1
94881: PPUSH
94882: LD_INT 0
94884: PPUSH
94885: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
94889: LD_VAR 0 1
94893: PPUSH
94894: LD_OWVAR 3
94898: PUSH
94899: LD_VAR 0 1
94903: DIFF
94904: PPUSH
94905: LD_VAR 0 1
94909: PPUSH
94910: CALL_OW 74
94914: PPUSH
94915: CALL_OW 115
// wait ( 0 0$20 ) ;
94919: LD_INT 700
94921: PPUSH
94922: CALL_OW 67
// SetSide ( un , your_side ) ;
94926: LD_VAR 0 1
94930: PPUSH
94931: LD_OWVAR 2
94935: PPUSH
94936: CALL_OW 235
// end ;
94940: PPOPN 2
94942: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
94943: LD_EXP 123
94947: PUSH
94948: LD_EXP 156
94952: AND
94953: IFFALSE 95059
94955: GO 94957
94957: DISABLE
94958: LD_INT 0
94960: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94961: LD_ADDR_VAR 0 1
94965: PUSH
94966: LD_INT 22
94968: PUSH
94969: LD_OWVAR 2
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 2
94980: PUSH
94981: LD_INT 30
94983: PUSH
94984: LD_INT 0
94986: PUSH
94987: EMPTY
94988: LIST
94989: LIST
94990: PUSH
94991: LD_INT 30
94993: PUSH
94994: LD_INT 1
94996: PUSH
94997: EMPTY
94998: LIST
94999: LIST
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: LIST
95005: PUSH
95006: EMPTY
95007: LIST
95008: LIST
95009: PPUSH
95010: CALL_OW 69
95014: ST_TO_ADDR
// if not depot then
95015: LD_VAR 0 1
95019: NOT
95020: IFFALSE 95024
// exit ;
95022: GO 95059
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95024: LD_VAR 0 1
95028: PUSH
95029: LD_INT 1
95031: ARRAY
95032: PPUSH
95033: CALL_OW 250
95037: PPUSH
95038: LD_VAR 0 1
95042: PUSH
95043: LD_INT 1
95045: ARRAY
95046: PPUSH
95047: CALL_OW 251
95051: PPUSH
95052: LD_INT 70
95054: PPUSH
95055: CALL_OW 495
// end ;
95059: PPOPN 1
95061: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95062: LD_EXP 123
95066: PUSH
95067: LD_EXP 157
95071: AND
95072: IFFALSE 95283
95074: GO 95076
95076: DISABLE
95077: LD_INT 0
95079: PPUSH
95080: PPUSH
95081: PPUSH
95082: PPUSH
95083: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95084: LD_ADDR_VAR 0 5
95088: PUSH
95089: LD_INT 22
95091: PUSH
95092: LD_OWVAR 2
95096: PUSH
95097: EMPTY
95098: LIST
95099: LIST
95100: PUSH
95101: LD_INT 21
95103: PUSH
95104: LD_INT 1
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PPUSH
95115: CALL_OW 69
95119: ST_TO_ADDR
// if not tmp then
95120: LD_VAR 0 5
95124: NOT
95125: IFFALSE 95129
// exit ;
95127: GO 95283
// for i in tmp do
95129: LD_ADDR_VAR 0 1
95133: PUSH
95134: LD_VAR 0 5
95138: PUSH
95139: FOR_IN
95140: IFFALSE 95281
// begin d := rand ( 0 , 5 ) ;
95142: LD_ADDR_VAR 0 4
95146: PUSH
95147: LD_INT 0
95149: PPUSH
95150: LD_INT 5
95152: PPUSH
95153: CALL_OW 12
95157: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95158: LD_ADDR_VAR 0 2
95162: PUSH
95163: LD_VAR 0 1
95167: PPUSH
95168: CALL_OW 250
95172: PPUSH
95173: LD_VAR 0 4
95177: PPUSH
95178: LD_INT 3
95180: PPUSH
95181: LD_INT 12
95183: PPUSH
95184: CALL_OW 12
95188: PPUSH
95189: CALL_OW 272
95193: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95194: LD_ADDR_VAR 0 3
95198: PUSH
95199: LD_VAR 0 1
95203: PPUSH
95204: CALL_OW 251
95208: PPUSH
95209: LD_VAR 0 4
95213: PPUSH
95214: LD_INT 3
95216: PPUSH
95217: LD_INT 12
95219: PPUSH
95220: CALL_OW 12
95224: PPUSH
95225: CALL_OW 273
95229: ST_TO_ADDR
// if ValidHex ( x , y ) then
95230: LD_VAR 0 2
95234: PPUSH
95235: LD_VAR 0 3
95239: PPUSH
95240: CALL_OW 488
95244: IFFALSE 95279
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95246: LD_VAR 0 1
95250: PPUSH
95251: LD_VAR 0 2
95255: PPUSH
95256: LD_VAR 0 3
95260: PPUSH
95261: LD_INT 3
95263: PPUSH
95264: LD_INT 6
95266: PPUSH
95267: CALL_OW 12
95271: PPUSH
95272: LD_INT 1
95274: PPUSH
95275: CALL_OW 483
// end ;
95279: GO 95139
95281: POP
95282: POP
// end ;
95283: PPOPN 5
95285: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95286: LD_EXP 123
95290: PUSH
95291: LD_EXP 158
95295: AND
95296: IFFALSE 95390
95298: GO 95300
95300: DISABLE
95301: LD_INT 0
95303: PPUSH
95304: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95305: LD_ADDR_VAR 0 2
95309: PUSH
95310: LD_INT 22
95312: PUSH
95313: LD_OWVAR 2
95317: PUSH
95318: EMPTY
95319: LIST
95320: LIST
95321: PUSH
95322: LD_INT 32
95324: PUSH
95325: LD_INT 1
95327: PUSH
95328: EMPTY
95329: LIST
95330: LIST
95331: PUSH
95332: LD_INT 21
95334: PUSH
95335: LD_INT 2
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: LIST
95346: PPUSH
95347: CALL_OW 69
95351: ST_TO_ADDR
// if not tmp then
95352: LD_VAR 0 2
95356: NOT
95357: IFFALSE 95361
// exit ;
95359: GO 95390
// for i in tmp do
95361: LD_ADDR_VAR 0 1
95365: PUSH
95366: LD_VAR 0 2
95370: PUSH
95371: FOR_IN
95372: IFFALSE 95388
// SetFuel ( i , 0 ) ;
95374: LD_VAR 0 1
95378: PPUSH
95379: LD_INT 0
95381: PPUSH
95382: CALL_OW 240
95386: GO 95371
95388: POP
95389: POP
// end ;
95390: PPOPN 2
95392: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95393: LD_EXP 123
95397: PUSH
95398: LD_EXP 159
95402: AND
95403: IFFALSE 95469
95405: GO 95407
95407: DISABLE
95408: LD_INT 0
95410: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95411: LD_ADDR_VAR 0 1
95415: PUSH
95416: LD_INT 22
95418: PUSH
95419: LD_OWVAR 2
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 30
95430: PUSH
95431: LD_INT 29
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PPUSH
95442: CALL_OW 69
95446: ST_TO_ADDR
// if not tmp then
95447: LD_VAR 0 1
95451: NOT
95452: IFFALSE 95456
// exit ;
95454: GO 95469
// DestroyUnit ( tmp [ 1 ] ) ;
95456: LD_VAR 0 1
95460: PUSH
95461: LD_INT 1
95463: ARRAY
95464: PPUSH
95465: CALL_OW 65
// end ;
95469: PPOPN 1
95471: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95472: LD_EXP 123
95476: PUSH
95477: LD_EXP 161
95481: AND
95482: IFFALSE 95611
95484: GO 95486
95486: DISABLE
95487: LD_INT 0
95489: PPUSH
// begin uc_side := 0 ;
95490: LD_ADDR_OWVAR 20
95494: PUSH
95495: LD_INT 0
95497: ST_TO_ADDR
// uc_nation := nation_arabian ;
95498: LD_ADDR_OWVAR 21
95502: PUSH
95503: LD_INT 2
95505: ST_TO_ADDR
// hc_gallery :=  ;
95506: LD_ADDR_OWVAR 33
95510: PUSH
95511: LD_STRING 
95513: ST_TO_ADDR
// hc_name :=  ;
95514: LD_ADDR_OWVAR 26
95518: PUSH
95519: LD_STRING 
95521: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95522: LD_INT 1
95524: PPUSH
95525: LD_INT 11
95527: PPUSH
95528: LD_INT 10
95530: PPUSH
95531: CALL_OW 380
// un := CreateHuman ;
95535: LD_ADDR_VAR 0 1
95539: PUSH
95540: CALL_OW 44
95544: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95545: LD_VAR 0 1
95549: PPUSH
95550: LD_INT 1
95552: PPUSH
95553: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95557: LD_INT 35
95559: PPUSH
95560: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95564: LD_VAR 0 1
95568: PPUSH
95569: LD_INT 22
95571: PUSH
95572: LD_OWVAR 2
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PPUSH
95581: CALL_OW 69
95585: PPUSH
95586: LD_VAR 0 1
95590: PPUSH
95591: CALL_OW 74
95595: PPUSH
95596: CALL_OW 115
// until IsDead ( un ) ;
95600: LD_VAR 0 1
95604: PPUSH
95605: CALL_OW 301
95609: IFFALSE 95557
// end ;
95611: PPOPN 1
95613: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95614: LD_EXP 123
95618: PUSH
95619: LD_EXP 163
95623: AND
95624: IFFALSE 95636
95626: GO 95628
95628: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95629: LD_STRING earthquake(getX(game), 0, 32)
95631: PPUSH
95632: CALL_OW 559
95636: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95637: LD_EXP 123
95641: PUSH
95642: LD_EXP 164
95646: AND
95647: IFFALSE 95738
95649: GO 95651
95651: DISABLE
95652: LD_INT 0
95654: PPUSH
// begin enable ;
95655: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95656: LD_ADDR_VAR 0 1
95660: PUSH
95661: LD_INT 22
95663: PUSH
95664: LD_OWVAR 2
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 21
95675: PUSH
95676: LD_INT 2
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: LD_INT 33
95685: PUSH
95686: LD_INT 3
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: EMPTY
95694: LIST
95695: LIST
95696: LIST
95697: PPUSH
95698: CALL_OW 69
95702: ST_TO_ADDR
// if not tmp then
95703: LD_VAR 0 1
95707: NOT
95708: IFFALSE 95712
// exit ;
95710: GO 95738
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95712: LD_VAR 0 1
95716: PUSH
95717: LD_INT 1
95719: PPUSH
95720: LD_VAR 0 1
95724: PPUSH
95725: CALL_OW 12
95729: ARRAY
95730: PPUSH
95731: LD_INT 1
95733: PPUSH
95734: CALL_OW 234
// end ;
95738: PPOPN 1
95740: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95741: LD_EXP 123
95745: PUSH
95746: LD_EXP 165
95750: AND
95751: IFFALSE 95892
95753: GO 95755
95755: DISABLE
95756: LD_INT 0
95758: PPUSH
95759: PPUSH
95760: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95761: LD_ADDR_VAR 0 3
95765: PUSH
95766: LD_INT 22
95768: PUSH
95769: LD_OWVAR 2
95773: PUSH
95774: EMPTY
95775: LIST
95776: LIST
95777: PUSH
95778: LD_INT 25
95780: PUSH
95781: LD_INT 1
95783: PUSH
95784: EMPTY
95785: LIST
95786: LIST
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PPUSH
95792: CALL_OW 69
95796: ST_TO_ADDR
// if not tmp then
95797: LD_VAR 0 3
95801: NOT
95802: IFFALSE 95806
// exit ;
95804: GO 95892
// un := tmp [ rand ( 1 , tmp ) ] ;
95806: LD_ADDR_VAR 0 2
95810: PUSH
95811: LD_VAR 0 3
95815: PUSH
95816: LD_INT 1
95818: PPUSH
95819: LD_VAR 0 3
95823: PPUSH
95824: CALL_OW 12
95828: ARRAY
95829: ST_TO_ADDR
// if Crawls ( un ) then
95830: LD_VAR 0 2
95834: PPUSH
95835: CALL_OW 318
95839: IFFALSE 95850
// ComWalk ( un ) ;
95841: LD_VAR 0 2
95845: PPUSH
95846: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
95850: LD_VAR 0 2
95854: PPUSH
95855: LD_INT 9
95857: PPUSH
95858: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
95862: LD_INT 28
95864: PPUSH
95865: LD_OWVAR 2
95869: PPUSH
95870: LD_INT 2
95872: PPUSH
95873: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
95877: LD_INT 29
95879: PPUSH
95880: LD_OWVAR 2
95884: PPUSH
95885: LD_INT 2
95887: PPUSH
95888: CALL_OW 322
// end ;
95892: PPOPN 3
95894: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
95895: LD_EXP 123
95899: PUSH
95900: LD_EXP 166
95904: AND
95905: IFFALSE 96016
95907: GO 95909
95909: DISABLE
95910: LD_INT 0
95912: PPUSH
95913: PPUSH
95914: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95915: LD_ADDR_VAR 0 3
95919: PUSH
95920: LD_INT 22
95922: PUSH
95923: LD_OWVAR 2
95927: PUSH
95928: EMPTY
95929: LIST
95930: LIST
95931: PUSH
95932: LD_INT 25
95934: PUSH
95935: LD_INT 1
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PPUSH
95946: CALL_OW 69
95950: ST_TO_ADDR
// if not tmp then
95951: LD_VAR 0 3
95955: NOT
95956: IFFALSE 95960
// exit ;
95958: GO 96016
// un := tmp [ rand ( 1 , tmp ) ] ;
95960: LD_ADDR_VAR 0 2
95964: PUSH
95965: LD_VAR 0 3
95969: PUSH
95970: LD_INT 1
95972: PPUSH
95973: LD_VAR 0 3
95977: PPUSH
95978: CALL_OW 12
95982: ARRAY
95983: ST_TO_ADDR
// if Crawls ( un ) then
95984: LD_VAR 0 2
95988: PPUSH
95989: CALL_OW 318
95993: IFFALSE 96004
// ComWalk ( un ) ;
95995: LD_VAR 0 2
95999: PPUSH
96000: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96004: LD_VAR 0 2
96008: PPUSH
96009: LD_INT 8
96011: PPUSH
96012: CALL_OW 336
// end ;
96016: PPOPN 3
96018: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96019: LD_EXP 123
96023: PUSH
96024: LD_EXP 167
96028: AND
96029: IFFALSE 96173
96031: GO 96033
96033: DISABLE
96034: LD_INT 0
96036: PPUSH
96037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96038: LD_ADDR_VAR 0 2
96042: PUSH
96043: LD_INT 22
96045: PUSH
96046: LD_OWVAR 2
96050: PUSH
96051: EMPTY
96052: LIST
96053: LIST
96054: PUSH
96055: LD_INT 21
96057: PUSH
96058: LD_INT 2
96060: PUSH
96061: EMPTY
96062: LIST
96063: LIST
96064: PUSH
96065: LD_INT 2
96067: PUSH
96068: LD_INT 34
96070: PUSH
96071: LD_INT 12
96073: PUSH
96074: EMPTY
96075: LIST
96076: LIST
96077: PUSH
96078: LD_INT 34
96080: PUSH
96081: LD_INT 51
96083: PUSH
96084: EMPTY
96085: LIST
96086: LIST
96087: PUSH
96088: LD_INT 34
96090: PUSH
96091: LD_INT 32
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: EMPTY
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: PUSH
96104: EMPTY
96105: LIST
96106: LIST
96107: LIST
96108: PPUSH
96109: CALL_OW 69
96113: ST_TO_ADDR
// if not tmp then
96114: LD_VAR 0 2
96118: NOT
96119: IFFALSE 96123
// exit ;
96121: GO 96173
// for i in tmp do
96123: LD_ADDR_VAR 0 1
96127: PUSH
96128: LD_VAR 0 2
96132: PUSH
96133: FOR_IN
96134: IFFALSE 96171
// if GetCargo ( i , mat_artifact ) = 0 then
96136: LD_VAR 0 1
96140: PPUSH
96141: LD_INT 4
96143: PPUSH
96144: CALL_OW 289
96148: PUSH
96149: LD_INT 0
96151: EQUAL
96152: IFFALSE 96169
// SetCargo ( i , mat_siberit , 100 ) ;
96154: LD_VAR 0 1
96158: PPUSH
96159: LD_INT 3
96161: PPUSH
96162: LD_INT 100
96164: PPUSH
96165: CALL_OW 290
96169: GO 96133
96171: POP
96172: POP
// end ;
96173: PPOPN 2
96175: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96176: LD_EXP 123
96180: PUSH
96181: LD_EXP 168
96185: AND
96186: IFFALSE 96369
96188: GO 96190
96190: DISABLE
96191: LD_INT 0
96193: PPUSH
96194: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96195: LD_ADDR_VAR 0 2
96199: PUSH
96200: LD_INT 22
96202: PUSH
96203: LD_OWVAR 2
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PPUSH
96212: CALL_OW 69
96216: ST_TO_ADDR
// if not tmp then
96217: LD_VAR 0 2
96221: NOT
96222: IFFALSE 96226
// exit ;
96224: GO 96369
// for i := 1 to 2 do
96226: LD_ADDR_VAR 0 1
96230: PUSH
96231: DOUBLE
96232: LD_INT 1
96234: DEC
96235: ST_TO_ADDR
96236: LD_INT 2
96238: PUSH
96239: FOR_TO
96240: IFFALSE 96367
// begin uc_side := your_side ;
96242: LD_ADDR_OWVAR 20
96246: PUSH
96247: LD_OWVAR 2
96251: ST_TO_ADDR
// uc_nation := nation_american ;
96252: LD_ADDR_OWVAR 21
96256: PUSH
96257: LD_INT 1
96259: ST_TO_ADDR
// vc_chassis := us_morphling ;
96260: LD_ADDR_OWVAR 37
96264: PUSH
96265: LD_INT 5
96267: ST_TO_ADDR
// vc_engine := engine_siberite ;
96268: LD_ADDR_OWVAR 39
96272: PUSH
96273: LD_INT 3
96275: ST_TO_ADDR
// vc_control := control_computer ;
96276: LD_ADDR_OWVAR 38
96280: PUSH
96281: LD_INT 3
96283: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96284: LD_ADDR_OWVAR 40
96288: PUSH
96289: LD_INT 10
96291: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96292: LD_VAR 0 2
96296: PUSH
96297: LD_INT 1
96299: ARRAY
96300: PPUSH
96301: CALL_OW 310
96305: NOT
96306: IFFALSE 96353
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96308: CALL_OW 45
96312: PPUSH
96313: LD_VAR 0 2
96317: PUSH
96318: LD_INT 1
96320: ARRAY
96321: PPUSH
96322: CALL_OW 250
96326: PPUSH
96327: LD_VAR 0 2
96331: PUSH
96332: LD_INT 1
96334: ARRAY
96335: PPUSH
96336: CALL_OW 251
96340: PPUSH
96341: LD_INT 12
96343: PPUSH
96344: LD_INT 1
96346: PPUSH
96347: CALL_OW 50
96351: GO 96365
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96353: CALL_OW 45
96357: PPUSH
96358: LD_INT 1
96360: PPUSH
96361: CALL_OW 51
// end ;
96365: GO 96239
96367: POP
96368: POP
// end ;
96369: PPOPN 2
96371: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96372: LD_EXP 123
96376: PUSH
96377: LD_EXP 169
96381: AND
96382: IFFALSE 96604
96384: GO 96386
96386: DISABLE
96387: LD_INT 0
96389: PPUSH
96390: PPUSH
96391: PPUSH
96392: PPUSH
96393: PPUSH
96394: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96395: LD_ADDR_VAR 0 6
96399: PUSH
96400: LD_INT 22
96402: PUSH
96403: LD_OWVAR 2
96407: PUSH
96408: EMPTY
96409: LIST
96410: LIST
96411: PUSH
96412: LD_INT 21
96414: PUSH
96415: LD_INT 1
96417: PUSH
96418: EMPTY
96419: LIST
96420: LIST
96421: PUSH
96422: LD_INT 3
96424: PUSH
96425: LD_INT 23
96427: PUSH
96428: LD_INT 0
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: PUSH
96439: EMPTY
96440: LIST
96441: LIST
96442: LIST
96443: PPUSH
96444: CALL_OW 69
96448: ST_TO_ADDR
// if not tmp then
96449: LD_VAR 0 6
96453: NOT
96454: IFFALSE 96458
// exit ;
96456: GO 96604
// s1 := rand ( 1 , 4 ) ;
96458: LD_ADDR_VAR 0 2
96462: PUSH
96463: LD_INT 1
96465: PPUSH
96466: LD_INT 4
96468: PPUSH
96469: CALL_OW 12
96473: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96474: LD_ADDR_VAR 0 4
96478: PUSH
96479: LD_VAR 0 6
96483: PUSH
96484: LD_INT 1
96486: ARRAY
96487: PPUSH
96488: LD_VAR 0 2
96492: PPUSH
96493: CALL_OW 259
96497: ST_TO_ADDR
// if s1 = 1 then
96498: LD_VAR 0 2
96502: PUSH
96503: LD_INT 1
96505: EQUAL
96506: IFFALSE 96526
// s2 := rand ( 2 , 4 ) else
96508: LD_ADDR_VAR 0 3
96512: PUSH
96513: LD_INT 2
96515: PPUSH
96516: LD_INT 4
96518: PPUSH
96519: CALL_OW 12
96523: ST_TO_ADDR
96524: GO 96534
// s2 := 1 ;
96526: LD_ADDR_VAR 0 3
96530: PUSH
96531: LD_INT 1
96533: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96534: LD_ADDR_VAR 0 5
96538: PUSH
96539: LD_VAR 0 6
96543: PUSH
96544: LD_INT 1
96546: ARRAY
96547: PPUSH
96548: LD_VAR 0 3
96552: PPUSH
96553: CALL_OW 259
96557: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96558: LD_VAR 0 6
96562: PUSH
96563: LD_INT 1
96565: ARRAY
96566: PPUSH
96567: LD_VAR 0 2
96571: PPUSH
96572: LD_VAR 0 5
96576: PPUSH
96577: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96581: LD_VAR 0 6
96585: PUSH
96586: LD_INT 1
96588: ARRAY
96589: PPUSH
96590: LD_VAR 0 3
96594: PPUSH
96595: LD_VAR 0 4
96599: PPUSH
96600: CALL_OW 237
// end ;
96604: PPOPN 6
96606: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96607: LD_EXP 123
96611: PUSH
96612: LD_EXP 170
96616: AND
96617: IFFALSE 96696
96619: GO 96621
96621: DISABLE
96622: LD_INT 0
96624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96625: LD_ADDR_VAR 0 1
96629: PUSH
96630: LD_INT 22
96632: PUSH
96633: LD_OWVAR 2
96637: PUSH
96638: EMPTY
96639: LIST
96640: LIST
96641: PUSH
96642: LD_INT 30
96644: PUSH
96645: LD_INT 3
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PPUSH
96656: CALL_OW 69
96660: ST_TO_ADDR
// if not tmp then
96661: LD_VAR 0 1
96665: NOT
96666: IFFALSE 96670
// exit ;
96668: GO 96696
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96670: LD_VAR 0 1
96674: PUSH
96675: LD_INT 1
96677: PPUSH
96678: LD_VAR 0 1
96682: PPUSH
96683: CALL_OW 12
96687: ARRAY
96688: PPUSH
96689: LD_INT 1
96691: PPUSH
96692: CALL_OW 234
// end ;
96696: PPOPN 1
96698: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96699: LD_EXP 123
96703: PUSH
96704: LD_EXP 171
96708: AND
96709: IFFALSE 96821
96711: GO 96713
96713: DISABLE
96714: LD_INT 0
96716: PPUSH
96717: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96718: LD_ADDR_VAR 0 2
96722: PUSH
96723: LD_INT 22
96725: PUSH
96726: LD_OWVAR 2
96730: PUSH
96731: EMPTY
96732: LIST
96733: LIST
96734: PUSH
96735: LD_INT 2
96737: PUSH
96738: LD_INT 30
96740: PUSH
96741: LD_INT 27
96743: PUSH
96744: EMPTY
96745: LIST
96746: LIST
96747: PUSH
96748: LD_INT 30
96750: PUSH
96751: LD_INT 26
96753: PUSH
96754: EMPTY
96755: LIST
96756: LIST
96757: PUSH
96758: LD_INT 30
96760: PUSH
96761: LD_INT 28
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: PUSH
96768: EMPTY
96769: LIST
96770: LIST
96771: LIST
96772: LIST
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PPUSH
96778: CALL_OW 69
96782: ST_TO_ADDR
// if not tmp then
96783: LD_VAR 0 2
96787: NOT
96788: IFFALSE 96792
// exit ;
96790: GO 96821
// for i in tmp do
96792: LD_ADDR_VAR 0 1
96796: PUSH
96797: LD_VAR 0 2
96801: PUSH
96802: FOR_IN
96803: IFFALSE 96819
// SetLives ( i , 1 ) ;
96805: LD_VAR 0 1
96809: PPUSH
96810: LD_INT 1
96812: PPUSH
96813: CALL_OW 234
96817: GO 96802
96819: POP
96820: POP
// end ;
96821: PPOPN 2
96823: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
96824: LD_EXP 123
96828: PUSH
96829: LD_EXP 172
96833: AND
96834: IFFALSE 97121
96836: GO 96838
96838: DISABLE
96839: LD_INT 0
96841: PPUSH
96842: PPUSH
96843: PPUSH
// begin i := rand ( 1 , 7 ) ;
96844: LD_ADDR_VAR 0 1
96848: PUSH
96849: LD_INT 1
96851: PPUSH
96852: LD_INT 7
96854: PPUSH
96855: CALL_OW 12
96859: ST_TO_ADDR
// case i of 1 :
96860: LD_VAR 0 1
96864: PUSH
96865: LD_INT 1
96867: DOUBLE
96868: EQUAL
96869: IFTRUE 96873
96871: GO 96883
96873: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
96874: LD_STRING earthquake(getX(game), 0, 32)
96876: PPUSH
96877: CALL_OW 559
96881: GO 97121
96883: LD_INT 2
96885: DOUBLE
96886: EQUAL
96887: IFTRUE 96891
96889: GO 96905
96891: POP
// begin ToLua ( displayStucuk(); ) ;
96892: LD_STRING displayStucuk();
96894: PPUSH
96895: CALL_OW 559
// ResetFog ;
96899: CALL_OW 335
// end ; 3 :
96903: GO 97121
96905: LD_INT 3
96907: DOUBLE
96908: EQUAL
96909: IFTRUE 96913
96911: GO 97017
96913: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96914: LD_ADDR_VAR 0 2
96918: PUSH
96919: LD_INT 22
96921: PUSH
96922: LD_OWVAR 2
96926: PUSH
96927: EMPTY
96928: LIST
96929: LIST
96930: PUSH
96931: LD_INT 25
96933: PUSH
96934: LD_INT 1
96936: PUSH
96937: EMPTY
96938: LIST
96939: LIST
96940: PUSH
96941: EMPTY
96942: LIST
96943: LIST
96944: PPUSH
96945: CALL_OW 69
96949: ST_TO_ADDR
// if not tmp then
96950: LD_VAR 0 2
96954: NOT
96955: IFFALSE 96959
// exit ;
96957: GO 97121
// un := tmp [ rand ( 1 , tmp ) ] ;
96959: LD_ADDR_VAR 0 3
96963: PUSH
96964: LD_VAR 0 2
96968: PUSH
96969: LD_INT 1
96971: PPUSH
96972: LD_VAR 0 2
96976: PPUSH
96977: CALL_OW 12
96981: ARRAY
96982: ST_TO_ADDR
// if Crawls ( un ) then
96983: LD_VAR 0 3
96987: PPUSH
96988: CALL_OW 318
96992: IFFALSE 97003
// ComWalk ( un ) ;
96994: LD_VAR 0 3
96998: PPUSH
96999: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97003: LD_VAR 0 3
97007: PPUSH
97008: LD_INT 8
97010: PPUSH
97011: CALL_OW 336
// end ; 4 :
97015: GO 97121
97017: LD_INT 4
97019: DOUBLE
97020: EQUAL
97021: IFTRUE 97025
97023: GO 97099
97025: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97026: LD_ADDR_VAR 0 2
97030: PUSH
97031: LD_INT 22
97033: PUSH
97034: LD_OWVAR 2
97038: PUSH
97039: EMPTY
97040: LIST
97041: LIST
97042: PUSH
97043: LD_INT 30
97045: PUSH
97046: LD_INT 29
97048: PUSH
97049: EMPTY
97050: LIST
97051: LIST
97052: PUSH
97053: EMPTY
97054: LIST
97055: LIST
97056: PPUSH
97057: CALL_OW 69
97061: ST_TO_ADDR
// if not tmp then
97062: LD_VAR 0 2
97066: NOT
97067: IFFALSE 97071
// exit ;
97069: GO 97121
// CenterNowOnUnits ( tmp [ 1 ] ) ;
97071: LD_VAR 0 2
97075: PUSH
97076: LD_INT 1
97078: ARRAY
97079: PPUSH
97080: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
97084: LD_VAR 0 2
97088: PUSH
97089: LD_INT 1
97091: ARRAY
97092: PPUSH
97093: CALL_OW 65
// end ; 5 .. 7 :
97097: GO 97121
97099: LD_INT 5
97101: DOUBLE
97102: GREATEREQUAL
97103: IFFALSE 97111
97105: LD_INT 7
97107: DOUBLE
97108: LESSEQUAL
97109: IFTRUE 97113
97111: GO 97120
97113: POP
// StreamSibBomb ; end ;
97114: CALL 93358 0 0
97118: GO 97121
97120: POP
// end ;
97121: PPOPN 3
97123: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97124: LD_EXP 123
97128: PUSH
97129: LD_EXP 173
97133: AND
97134: IFFALSE 97290
97136: GO 97138
97138: DISABLE
97139: LD_INT 0
97141: PPUSH
97142: PPUSH
97143: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97144: LD_ADDR_VAR 0 2
97148: PUSH
97149: LD_INT 81
97151: PUSH
97152: LD_OWVAR 2
97156: PUSH
97157: EMPTY
97158: LIST
97159: LIST
97160: PUSH
97161: LD_INT 2
97163: PUSH
97164: LD_INT 21
97166: PUSH
97167: LD_INT 1
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: PUSH
97174: LD_INT 21
97176: PUSH
97177: LD_INT 2
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: EMPTY
97185: LIST
97186: LIST
97187: LIST
97188: PUSH
97189: EMPTY
97190: LIST
97191: LIST
97192: PPUSH
97193: CALL_OW 69
97197: ST_TO_ADDR
// if not tmp then
97198: LD_VAR 0 2
97202: NOT
97203: IFFALSE 97207
// exit ;
97205: GO 97290
// p := 0 ;
97207: LD_ADDR_VAR 0 3
97211: PUSH
97212: LD_INT 0
97214: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97215: LD_INT 35
97217: PPUSH
97218: CALL_OW 67
// p := p + 1 ;
97222: LD_ADDR_VAR 0 3
97226: PUSH
97227: LD_VAR 0 3
97231: PUSH
97232: LD_INT 1
97234: PLUS
97235: ST_TO_ADDR
// for i in tmp do
97236: LD_ADDR_VAR 0 1
97240: PUSH
97241: LD_VAR 0 2
97245: PUSH
97246: FOR_IN
97247: IFFALSE 97278
// if GetLives ( i ) < 1000 then
97249: LD_VAR 0 1
97253: PPUSH
97254: CALL_OW 256
97258: PUSH
97259: LD_INT 1000
97261: LESS
97262: IFFALSE 97276
// SetLives ( i , 1000 ) ;
97264: LD_VAR 0 1
97268: PPUSH
97269: LD_INT 1000
97271: PPUSH
97272: CALL_OW 234
97276: GO 97246
97278: POP
97279: POP
// until p > 20 ;
97280: LD_VAR 0 3
97284: PUSH
97285: LD_INT 20
97287: GREATER
97288: IFFALSE 97215
// end ;
97290: PPOPN 3
97292: END
// every 0 0$1 trigger StreamModeActive and sTime do
97293: LD_EXP 123
97297: PUSH
97298: LD_EXP 174
97302: AND
97303: IFFALSE 97338
97305: GO 97307
97307: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97308: LD_INT 28
97310: PPUSH
97311: LD_OWVAR 2
97315: PPUSH
97316: LD_INT 2
97318: PPUSH
97319: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97323: LD_INT 30
97325: PPUSH
97326: LD_OWVAR 2
97330: PPUSH
97331: LD_INT 2
97333: PPUSH
97334: CALL_OW 322
// end ;
97338: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97339: LD_EXP 123
97343: PUSH
97344: LD_EXP 175
97348: AND
97349: IFFALSE 97470
97351: GO 97353
97353: DISABLE
97354: LD_INT 0
97356: PPUSH
97357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97358: LD_ADDR_VAR 0 2
97362: PUSH
97363: LD_INT 22
97365: PUSH
97366: LD_OWVAR 2
97370: PUSH
97371: EMPTY
97372: LIST
97373: LIST
97374: PUSH
97375: LD_INT 21
97377: PUSH
97378: LD_INT 1
97380: PUSH
97381: EMPTY
97382: LIST
97383: LIST
97384: PUSH
97385: LD_INT 3
97387: PUSH
97388: LD_INT 23
97390: PUSH
97391: LD_INT 0
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: EMPTY
97399: LIST
97400: LIST
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: LIST
97406: PPUSH
97407: CALL_OW 69
97411: ST_TO_ADDR
// if not tmp then
97412: LD_VAR 0 2
97416: NOT
97417: IFFALSE 97421
// exit ;
97419: GO 97470
// for i in tmp do
97421: LD_ADDR_VAR 0 1
97425: PUSH
97426: LD_VAR 0 2
97430: PUSH
97431: FOR_IN
97432: IFFALSE 97468
// begin if Crawls ( i ) then
97434: LD_VAR 0 1
97438: PPUSH
97439: CALL_OW 318
97443: IFFALSE 97454
// ComWalk ( i ) ;
97445: LD_VAR 0 1
97449: PPUSH
97450: CALL_OW 138
// SetClass ( i , 2 ) ;
97454: LD_VAR 0 1
97458: PPUSH
97459: LD_INT 2
97461: PPUSH
97462: CALL_OW 336
// end ;
97466: GO 97431
97468: POP
97469: POP
// end ;
97470: PPOPN 2
97472: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97473: LD_EXP 123
97477: PUSH
97478: LD_EXP 176
97482: AND
97483: IFFALSE 97771
97485: GO 97487
97487: DISABLE
97488: LD_INT 0
97490: PPUSH
97491: PPUSH
97492: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97493: LD_OWVAR 2
97497: PPUSH
97498: LD_INT 9
97500: PPUSH
97501: LD_INT 1
97503: PPUSH
97504: LD_INT 1
97506: PPUSH
97507: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97511: LD_INT 9
97513: PPUSH
97514: LD_OWVAR 2
97518: PPUSH
97519: CALL_OW 343
// uc_side := 9 ;
97523: LD_ADDR_OWVAR 20
97527: PUSH
97528: LD_INT 9
97530: ST_TO_ADDR
// uc_nation := 2 ;
97531: LD_ADDR_OWVAR 21
97535: PUSH
97536: LD_INT 2
97538: ST_TO_ADDR
// hc_name := Dark Warrior ;
97539: LD_ADDR_OWVAR 26
97543: PUSH
97544: LD_STRING Dark Warrior
97546: ST_TO_ADDR
// hc_gallery :=  ;
97547: LD_ADDR_OWVAR 33
97551: PUSH
97552: LD_STRING 
97554: ST_TO_ADDR
// hc_noskilllimit := true ;
97555: LD_ADDR_OWVAR 76
97559: PUSH
97560: LD_INT 1
97562: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97563: LD_ADDR_OWVAR 31
97567: PUSH
97568: LD_INT 30
97570: PUSH
97571: LD_INT 30
97573: PUSH
97574: LD_INT 30
97576: PUSH
97577: LD_INT 30
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: ST_TO_ADDR
// un := CreateHuman ;
97586: LD_ADDR_VAR 0 3
97590: PUSH
97591: CALL_OW 44
97595: ST_TO_ADDR
// hc_noskilllimit := false ;
97596: LD_ADDR_OWVAR 76
97600: PUSH
97601: LD_INT 0
97603: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97604: LD_VAR 0 3
97608: PPUSH
97609: LD_INT 1
97611: PPUSH
97612: CALL_OW 51
// ToLua ( playRanger() ) ;
97616: LD_STRING playRanger()
97618: PPUSH
97619: CALL_OW 559
// p := 0 ;
97623: LD_ADDR_VAR 0 2
97627: PUSH
97628: LD_INT 0
97630: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97631: LD_INT 35
97633: PPUSH
97634: CALL_OW 67
// p := p + 1 ;
97638: LD_ADDR_VAR 0 2
97642: PUSH
97643: LD_VAR 0 2
97647: PUSH
97648: LD_INT 1
97650: PLUS
97651: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97652: LD_VAR 0 3
97656: PPUSH
97657: CALL_OW 256
97661: PUSH
97662: LD_INT 1000
97664: LESS
97665: IFFALSE 97679
// SetLives ( un , 1000 ) ;
97667: LD_VAR 0 3
97671: PPUSH
97672: LD_INT 1000
97674: PPUSH
97675: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97679: LD_VAR 0 3
97683: PPUSH
97684: LD_INT 81
97686: PUSH
97687: LD_OWVAR 2
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 91
97698: PUSH
97699: LD_VAR 0 3
97703: PUSH
97704: LD_INT 30
97706: PUSH
97707: EMPTY
97708: LIST
97709: LIST
97710: LIST
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: PPUSH
97716: CALL_OW 69
97720: PPUSH
97721: LD_VAR 0 3
97725: PPUSH
97726: CALL_OW 74
97730: PPUSH
97731: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
97735: LD_VAR 0 2
97739: PUSH
97740: LD_INT 80
97742: GREATER
97743: PUSH
97744: LD_VAR 0 3
97748: PPUSH
97749: CALL_OW 301
97753: OR
97754: IFFALSE 97631
// if un then
97756: LD_VAR 0 3
97760: IFFALSE 97771
// RemoveUnit ( un ) ;
97762: LD_VAR 0 3
97766: PPUSH
97767: CALL_OW 64
// end ;
97771: PPOPN 3
97773: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
97774: LD_EXP 177
97778: IFFALSE 97894
97780: GO 97782
97782: DISABLE
97783: LD_INT 0
97785: PPUSH
97786: PPUSH
97787: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97788: LD_ADDR_VAR 0 2
97792: PUSH
97793: LD_INT 81
97795: PUSH
97796: LD_OWVAR 2
97800: PUSH
97801: EMPTY
97802: LIST
97803: LIST
97804: PUSH
97805: LD_INT 21
97807: PUSH
97808: LD_INT 1
97810: PUSH
97811: EMPTY
97812: LIST
97813: LIST
97814: PUSH
97815: EMPTY
97816: LIST
97817: LIST
97818: PPUSH
97819: CALL_OW 69
97823: ST_TO_ADDR
// ToLua ( playComputer() ) ;
97824: LD_STRING playComputer()
97826: PPUSH
97827: CALL_OW 559
// if not tmp then
97831: LD_VAR 0 2
97835: NOT
97836: IFFALSE 97840
// exit ;
97838: GO 97894
// for i in tmp do
97840: LD_ADDR_VAR 0 1
97844: PUSH
97845: LD_VAR 0 2
97849: PUSH
97850: FOR_IN
97851: IFFALSE 97892
// for j := 1 to 4 do
97853: LD_ADDR_VAR 0 3
97857: PUSH
97858: DOUBLE
97859: LD_INT 1
97861: DEC
97862: ST_TO_ADDR
97863: LD_INT 4
97865: PUSH
97866: FOR_TO
97867: IFFALSE 97888
// SetSkill ( i , j , 10 ) ;
97869: LD_VAR 0 1
97873: PPUSH
97874: LD_VAR 0 3
97878: PPUSH
97879: LD_INT 10
97881: PPUSH
97882: CALL_OW 237
97886: GO 97866
97888: POP
97889: POP
97890: GO 97850
97892: POP
97893: POP
// end ;
97894: PPOPN 3
97896: END
// every 0 0$1 trigger s30 do var i , tmp ;
97897: LD_EXP 178
97901: IFFALSE 97970
97903: GO 97905
97905: DISABLE
97906: LD_INT 0
97908: PPUSH
97909: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97910: LD_ADDR_VAR 0 2
97914: PUSH
97915: LD_INT 22
97917: PUSH
97918: LD_OWVAR 2
97922: PUSH
97923: EMPTY
97924: LIST
97925: LIST
97926: PPUSH
97927: CALL_OW 69
97931: ST_TO_ADDR
// if not tmp then
97932: LD_VAR 0 2
97936: NOT
97937: IFFALSE 97941
// exit ;
97939: GO 97970
// for i in tmp do
97941: LD_ADDR_VAR 0 1
97945: PUSH
97946: LD_VAR 0 2
97950: PUSH
97951: FOR_IN
97952: IFFALSE 97968
// SetLives ( i , 300 ) ;
97954: LD_VAR 0 1
97958: PPUSH
97959: LD_INT 300
97961: PPUSH
97962: CALL_OW 234
97966: GO 97951
97968: POP
97969: POP
// end ;
97970: PPOPN 2
97972: END
// every 0 0$1 trigger s60 do var i , tmp ;
97973: LD_EXP 179
97977: IFFALSE 98046
97979: GO 97981
97981: DISABLE
97982: LD_INT 0
97984: PPUSH
97985: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97986: LD_ADDR_VAR 0 2
97990: PUSH
97991: LD_INT 22
97993: PUSH
97994: LD_OWVAR 2
97998: PUSH
97999: EMPTY
98000: LIST
98001: LIST
98002: PPUSH
98003: CALL_OW 69
98007: ST_TO_ADDR
// if not tmp then
98008: LD_VAR 0 2
98012: NOT
98013: IFFALSE 98017
// exit ;
98015: GO 98046
// for i in tmp do
98017: LD_ADDR_VAR 0 1
98021: PUSH
98022: LD_VAR 0 2
98026: PUSH
98027: FOR_IN
98028: IFFALSE 98044
// SetLives ( i , 600 ) ;
98030: LD_VAR 0 1
98034: PPUSH
98035: LD_INT 600
98037: PPUSH
98038: CALL_OW 234
98042: GO 98027
98044: POP
98045: POP
// end ;
98046: PPOPN 2
98048: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98049: LD_INT 0
98051: PPUSH
// case cmd of 301 :
98052: LD_VAR 0 1
98056: PUSH
98057: LD_INT 301
98059: DOUBLE
98060: EQUAL
98061: IFTRUE 98065
98063: GO 98097
98065: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98066: LD_VAR 0 6
98070: PPUSH
98071: LD_VAR 0 7
98075: PPUSH
98076: LD_VAR 0 8
98080: PPUSH
98081: LD_VAR 0 4
98085: PPUSH
98086: LD_VAR 0 5
98090: PPUSH
98091: CALL 99298 0 5
98095: GO 98218
98097: LD_INT 302
98099: DOUBLE
98100: EQUAL
98101: IFTRUE 98105
98103: GO 98142
98105: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98106: LD_VAR 0 6
98110: PPUSH
98111: LD_VAR 0 7
98115: PPUSH
98116: LD_VAR 0 8
98120: PPUSH
98121: LD_VAR 0 9
98125: PPUSH
98126: LD_VAR 0 4
98130: PPUSH
98131: LD_VAR 0 5
98135: PPUSH
98136: CALL 99389 0 6
98140: GO 98218
98142: LD_INT 303
98144: DOUBLE
98145: EQUAL
98146: IFTRUE 98150
98148: GO 98187
98150: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98151: LD_VAR 0 6
98155: PPUSH
98156: LD_VAR 0 7
98160: PPUSH
98161: LD_VAR 0 8
98165: PPUSH
98166: LD_VAR 0 9
98170: PPUSH
98171: LD_VAR 0 4
98175: PPUSH
98176: LD_VAR 0 5
98180: PPUSH
98181: CALL 98223 0 6
98185: GO 98218
98187: LD_INT 304
98189: DOUBLE
98190: EQUAL
98191: IFTRUE 98195
98193: GO 98217
98195: POP
// hHackTeleport ( unit , x , y ) ; end ;
98196: LD_VAR 0 2
98200: PPUSH
98201: LD_VAR 0 4
98205: PPUSH
98206: LD_VAR 0 5
98210: PPUSH
98211: CALL 99982 0 3
98215: GO 98218
98217: POP
// end ;
98218: LD_VAR 0 12
98222: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98223: LD_INT 0
98225: PPUSH
98226: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98227: LD_VAR 0 1
98231: PUSH
98232: LD_INT 1
98234: LESS
98235: PUSH
98236: LD_VAR 0 1
98240: PUSH
98241: LD_INT 3
98243: GREATER
98244: OR
98245: PUSH
98246: LD_VAR 0 5
98250: PPUSH
98251: LD_VAR 0 6
98255: PPUSH
98256: CALL_OW 428
98260: OR
98261: IFFALSE 98265
// exit ;
98263: GO 98985
// uc_side := your_side ;
98265: LD_ADDR_OWVAR 20
98269: PUSH
98270: LD_OWVAR 2
98274: ST_TO_ADDR
// uc_nation := nation ;
98275: LD_ADDR_OWVAR 21
98279: PUSH
98280: LD_VAR 0 1
98284: ST_TO_ADDR
// bc_level = 1 ;
98285: LD_ADDR_OWVAR 43
98289: PUSH
98290: LD_INT 1
98292: ST_TO_ADDR
// case btype of 1 :
98293: LD_VAR 0 2
98297: PUSH
98298: LD_INT 1
98300: DOUBLE
98301: EQUAL
98302: IFTRUE 98306
98304: GO 98317
98306: POP
// bc_type := b_depot ; 2 :
98307: LD_ADDR_OWVAR 42
98311: PUSH
98312: LD_INT 0
98314: ST_TO_ADDR
98315: GO 98929
98317: LD_INT 2
98319: DOUBLE
98320: EQUAL
98321: IFTRUE 98325
98323: GO 98336
98325: POP
// bc_type := b_warehouse ; 3 :
98326: LD_ADDR_OWVAR 42
98330: PUSH
98331: LD_INT 1
98333: ST_TO_ADDR
98334: GO 98929
98336: LD_INT 3
98338: DOUBLE
98339: EQUAL
98340: IFTRUE 98344
98342: GO 98355
98344: POP
// bc_type := b_lab ; 4 .. 9 :
98345: LD_ADDR_OWVAR 42
98349: PUSH
98350: LD_INT 6
98352: ST_TO_ADDR
98353: GO 98929
98355: LD_INT 4
98357: DOUBLE
98358: GREATEREQUAL
98359: IFFALSE 98367
98361: LD_INT 9
98363: DOUBLE
98364: LESSEQUAL
98365: IFTRUE 98369
98367: GO 98421
98369: POP
// begin bc_type := b_lab_half ;
98370: LD_ADDR_OWVAR 42
98374: PUSH
98375: LD_INT 7
98377: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98378: LD_ADDR_OWVAR 44
98382: PUSH
98383: LD_INT 10
98385: PUSH
98386: LD_INT 11
98388: PUSH
98389: LD_INT 12
98391: PUSH
98392: LD_INT 15
98394: PUSH
98395: LD_INT 14
98397: PUSH
98398: LD_INT 13
98400: PUSH
98401: EMPTY
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: PUSH
98409: LD_VAR 0 2
98413: PUSH
98414: LD_INT 3
98416: MINUS
98417: ARRAY
98418: ST_TO_ADDR
// end ; 10 .. 13 :
98419: GO 98929
98421: LD_INT 10
98423: DOUBLE
98424: GREATEREQUAL
98425: IFFALSE 98433
98427: LD_INT 13
98429: DOUBLE
98430: LESSEQUAL
98431: IFTRUE 98435
98433: GO 98512
98435: POP
// begin bc_type := b_lab_full ;
98436: LD_ADDR_OWVAR 42
98440: PUSH
98441: LD_INT 8
98443: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98444: LD_ADDR_OWVAR 44
98448: PUSH
98449: LD_INT 10
98451: PUSH
98452: LD_INT 12
98454: PUSH
98455: LD_INT 14
98457: PUSH
98458: LD_INT 13
98460: PUSH
98461: EMPTY
98462: LIST
98463: LIST
98464: LIST
98465: LIST
98466: PUSH
98467: LD_VAR 0 2
98471: PUSH
98472: LD_INT 9
98474: MINUS
98475: ARRAY
98476: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98477: LD_ADDR_OWVAR 45
98481: PUSH
98482: LD_INT 11
98484: PUSH
98485: LD_INT 15
98487: PUSH
98488: LD_INT 12
98490: PUSH
98491: LD_INT 15
98493: PUSH
98494: EMPTY
98495: LIST
98496: LIST
98497: LIST
98498: LIST
98499: PUSH
98500: LD_VAR 0 2
98504: PUSH
98505: LD_INT 9
98507: MINUS
98508: ARRAY
98509: ST_TO_ADDR
// end ; 14 :
98510: GO 98929
98512: LD_INT 14
98514: DOUBLE
98515: EQUAL
98516: IFTRUE 98520
98518: GO 98531
98520: POP
// bc_type := b_workshop ; 15 :
98521: LD_ADDR_OWVAR 42
98525: PUSH
98526: LD_INT 2
98528: ST_TO_ADDR
98529: GO 98929
98531: LD_INT 15
98533: DOUBLE
98534: EQUAL
98535: IFTRUE 98539
98537: GO 98550
98539: POP
// bc_type := b_factory ; 16 :
98540: LD_ADDR_OWVAR 42
98544: PUSH
98545: LD_INT 3
98547: ST_TO_ADDR
98548: GO 98929
98550: LD_INT 16
98552: DOUBLE
98553: EQUAL
98554: IFTRUE 98558
98556: GO 98569
98558: POP
// bc_type := b_ext_gun ; 17 :
98559: LD_ADDR_OWVAR 42
98563: PUSH
98564: LD_INT 17
98566: ST_TO_ADDR
98567: GO 98929
98569: LD_INT 17
98571: DOUBLE
98572: EQUAL
98573: IFTRUE 98577
98575: GO 98605
98577: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98578: LD_ADDR_OWVAR 42
98582: PUSH
98583: LD_INT 19
98585: PUSH
98586: LD_INT 23
98588: PUSH
98589: LD_INT 19
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: LIST
98596: PUSH
98597: LD_VAR 0 1
98601: ARRAY
98602: ST_TO_ADDR
98603: GO 98929
98605: LD_INT 18
98607: DOUBLE
98608: EQUAL
98609: IFTRUE 98613
98611: GO 98624
98613: POP
// bc_type := b_ext_radar ; 19 :
98614: LD_ADDR_OWVAR 42
98618: PUSH
98619: LD_INT 20
98621: ST_TO_ADDR
98622: GO 98929
98624: LD_INT 19
98626: DOUBLE
98627: EQUAL
98628: IFTRUE 98632
98630: GO 98643
98632: POP
// bc_type := b_ext_radio ; 20 :
98633: LD_ADDR_OWVAR 42
98637: PUSH
98638: LD_INT 22
98640: ST_TO_ADDR
98641: GO 98929
98643: LD_INT 20
98645: DOUBLE
98646: EQUAL
98647: IFTRUE 98651
98649: GO 98662
98651: POP
// bc_type := b_ext_siberium ; 21 :
98652: LD_ADDR_OWVAR 42
98656: PUSH
98657: LD_INT 21
98659: ST_TO_ADDR
98660: GO 98929
98662: LD_INT 21
98664: DOUBLE
98665: EQUAL
98666: IFTRUE 98670
98668: GO 98681
98670: POP
// bc_type := b_ext_computer ; 22 :
98671: LD_ADDR_OWVAR 42
98675: PUSH
98676: LD_INT 24
98678: ST_TO_ADDR
98679: GO 98929
98681: LD_INT 22
98683: DOUBLE
98684: EQUAL
98685: IFTRUE 98689
98687: GO 98700
98689: POP
// bc_type := b_ext_track ; 23 :
98690: LD_ADDR_OWVAR 42
98694: PUSH
98695: LD_INT 16
98697: ST_TO_ADDR
98698: GO 98929
98700: LD_INT 23
98702: DOUBLE
98703: EQUAL
98704: IFTRUE 98708
98706: GO 98719
98708: POP
// bc_type := b_ext_laser ; 24 :
98709: LD_ADDR_OWVAR 42
98713: PUSH
98714: LD_INT 25
98716: ST_TO_ADDR
98717: GO 98929
98719: LD_INT 24
98721: DOUBLE
98722: EQUAL
98723: IFTRUE 98727
98725: GO 98738
98727: POP
// bc_type := b_control_tower ; 25 :
98728: LD_ADDR_OWVAR 42
98732: PUSH
98733: LD_INT 36
98735: ST_TO_ADDR
98736: GO 98929
98738: LD_INT 25
98740: DOUBLE
98741: EQUAL
98742: IFTRUE 98746
98744: GO 98757
98746: POP
// bc_type := b_breastwork ; 26 :
98747: LD_ADDR_OWVAR 42
98751: PUSH
98752: LD_INT 31
98754: ST_TO_ADDR
98755: GO 98929
98757: LD_INT 26
98759: DOUBLE
98760: EQUAL
98761: IFTRUE 98765
98763: GO 98776
98765: POP
// bc_type := b_bunker ; 27 :
98766: LD_ADDR_OWVAR 42
98770: PUSH
98771: LD_INT 32
98773: ST_TO_ADDR
98774: GO 98929
98776: LD_INT 27
98778: DOUBLE
98779: EQUAL
98780: IFTRUE 98784
98782: GO 98795
98784: POP
// bc_type := b_turret ; 28 :
98785: LD_ADDR_OWVAR 42
98789: PUSH
98790: LD_INT 33
98792: ST_TO_ADDR
98793: GO 98929
98795: LD_INT 28
98797: DOUBLE
98798: EQUAL
98799: IFTRUE 98803
98801: GO 98814
98803: POP
// bc_type := b_armoury ; 29 :
98804: LD_ADDR_OWVAR 42
98808: PUSH
98809: LD_INT 4
98811: ST_TO_ADDR
98812: GO 98929
98814: LD_INT 29
98816: DOUBLE
98817: EQUAL
98818: IFTRUE 98822
98820: GO 98833
98822: POP
// bc_type := b_barracks ; 30 :
98823: LD_ADDR_OWVAR 42
98827: PUSH
98828: LD_INT 5
98830: ST_TO_ADDR
98831: GO 98929
98833: LD_INT 30
98835: DOUBLE
98836: EQUAL
98837: IFTRUE 98841
98839: GO 98852
98841: POP
// bc_type := b_solar_power ; 31 :
98842: LD_ADDR_OWVAR 42
98846: PUSH
98847: LD_INT 27
98849: ST_TO_ADDR
98850: GO 98929
98852: LD_INT 31
98854: DOUBLE
98855: EQUAL
98856: IFTRUE 98860
98858: GO 98871
98860: POP
// bc_type := b_oil_power ; 32 :
98861: LD_ADDR_OWVAR 42
98865: PUSH
98866: LD_INT 26
98868: ST_TO_ADDR
98869: GO 98929
98871: LD_INT 32
98873: DOUBLE
98874: EQUAL
98875: IFTRUE 98879
98877: GO 98890
98879: POP
// bc_type := b_siberite_power ; 33 :
98880: LD_ADDR_OWVAR 42
98884: PUSH
98885: LD_INT 28
98887: ST_TO_ADDR
98888: GO 98929
98890: LD_INT 33
98892: DOUBLE
98893: EQUAL
98894: IFTRUE 98898
98896: GO 98909
98898: POP
// bc_type := b_oil_mine ; 34 :
98899: LD_ADDR_OWVAR 42
98903: PUSH
98904: LD_INT 29
98906: ST_TO_ADDR
98907: GO 98929
98909: LD_INT 34
98911: DOUBLE
98912: EQUAL
98913: IFTRUE 98917
98915: GO 98928
98917: POP
// bc_type := b_siberite_mine ; end ;
98918: LD_ADDR_OWVAR 42
98922: PUSH
98923: LD_INT 30
98925: ST_TO_ADDR
98926: GO 98929
98928: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
98929: LD_ADDR_VAR 0 8
98933: PUSH
98934: LD_VAR 0 5
98938: PPUSH
98939: LD_VAR 0 6
98943: PPUSH
98944: LD_VAR 0 3
98948: PPUSH
98949: CALL_OW 47
98953: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98954: LD_OWVAR 42
98958: PUSH
98959: LD_INT 32
98961: PUSH
98962: LD_INT 33
98964: PUSH
98965: EMPTY
98966: LIST
98967: LIST
98968: IN
98969: IFFALSE 98985
// PlaceWeaponTurret ( b , weapon ) ;
98971: LD_VAR 0 8
98975: PPUSH
98976: LD_VAR 0 4
98980: PPUSH
98981: CALL_OW 431
// end ;
98985: LD_VAR 0 7
98989: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98990: LD_INT 0
98992: PPUSH
98993: PPUSH
98994: PPUSH
98995: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98996: LD_ADDR_VAR 0 4
99000: PUSH
99001: LD_INT 22
99003: PUSH
99004: LD_OWVAR 2
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PUSH
99013: LD_INT 2
99015: PUSH
99016: LD_INT 30
99018: PUSH
99019: LD_INT 0
99021: PUSH
99022: EMPTY
99023: LIST
99024: LIST
99025: PUSH
99026: LD_INT 30
99028: PUSH
99029: LD_INT 1
99031: PUSH
99032: EMPTY
99033: LIST
99034: LIST
99035: PUSH
99036: EMPTY
99037: LIST
99038: LIST
99039: LIST
99040: PUSH
99041: EMPTY
99042: LIST
99043: LIST
99044: PPUSH
99045: CALL_OW 69
99049: ST_TO_ADDR
// if not tmp then
99050: LD_VAR 0 4
99054: NOT
99055: IFFALSE 99059
// exit ;
99057: GO 99118
// for i in tmp do
99059: LD_ADDR_VAR 0 2
99063: PUSH
99064: LD_VAR 0 4
99068: PUSH
99069: FOR_IN
99070: IFFALSE 99116
// for j = 1 to 3 do
99072: LD_ADDR_VAR 0 3
99076: PUSH
99077: DOUBLE
99078: LD_INT 1
99080: DEC
99081: ST_TO_ADDR
99082: LD_INT 3
99084: PUSH
99085: FOR_TO
99086: IFFALSE 99112
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99088: LD_VAR 0 2
99092: PPUSH
99093: CALL_OW 274
99097: PPUSH
99098: LD_VAR 0 3
99102: PPUSH
99103: LD_INT 99999
99105: PPUSH
99106: CALL_OW 277
99110: GO 99085
99112: POP
99113: POP
99114: GO 99069
99116: POP
99117: POP
// end ;
99118: LD_VAR 0 1
99122: RET
// export function hHackSetLevel10 ; var i , j ; begin
99123: LD_INT 0
99125: PPUSH
99126: PPUSH
99127: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99128: LD_ADDR_VAR 0 2
99132: PUSH
99133: LD_INT 21
99135: PUSH
99136: LD_INT 1
99138: PUSH
99139: EMPTY
99140: LIST
99141: LIST
99142: PPUSH
99143: CALL_OW 69
99147: PUSH
99148: FOR_IN
99149: IFFALSE 99201
// if IsSelected ( i ) then
99151: LD_VAR 0 2
99155: PPUSH
99156: CALL_OW 306
99160: IFFALSE 99199
// begin for j := 1 to 4 do
99162: LD_ADDR_VAR 0 3
99166: PUSH
99167: DOUBLE
99168: LD_INT 1
99170: DEC
99171: ST_TO_ADDR
99172: LD_INT 4
99174: PUSH
99175: FOR_TO
99176: IFFALSE 99197
// SetSkill ( i , j , 10 ) ;
99178: LD_VAR 0 2
99182: PPUSH
99183: LD_VAR 0 3
99187: PPUSH
99188: LD_INT 10
99190: PPUSH
99191: CALL_OW 237
99195: GO 99175
99197: POP
99198: POP
// end ;
99199: GO 99148
99201: POP
99202: POP
// end ;
99203: LD_VAR 0 1
99207: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99208: LD_INT 0
99210: PPUSH
99211: PPUSH
99212: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99213: LD_ADDR_VAR 0 2
99217: PUSH
99218: LD_INT 22
99220: PUSH
99221: LD_OWVAR 2
99225: PUSH
99226: EMPTY
99227: LIST
99228: LIST
99229: PUSH
99230: LD_INT 21
99232: PUSH
99233: LD_INT 1
99235: PUSH
99236: EMPTY
99237: LIST
99238: LIST
99239: PUSH
99240: EMPTY
99241: LIST
99242: LIST
99243: PPUSH
99244: CALL_OW 69
99248: PUSH
99249: FOR_IN
99250: IFFALSE 99291
// begin for j := 1 to 4 do
99252: LD_ADDR_VAR 0 3
99256: PUSH
99257: DOUBLE
99258: LD_INT 1
99260: DEC
99261: ST_TO_ADDR
99262: LD_INT 4
99264: PUSH
99265: FOR_TO
99266: IFFALSE 99287
// SetSkill ( i , j , 10 ) ;
99268: LD_VAR 0 2
99272: PPUSH
99273: LD_VAR 0 3
99277: PPUSH
99278: LD_INT 10
99280: PPUSH
99281: CALL_OW 237
99285: GO 99265
99287: POP
99288: POP
// end ;
99289: GO 99249
99291: POP
99292: POP
// end ;
99293: LD_VAR 0 1
99297: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99298: LD_INT 0
99300: PPUSH
// uc_side := your_side ;
99301: LD_ADDR_OWVAR 20
99305: PUSH
99306: LD_OWVAR 2
99310: ST_TO_ADDR
// uc_nation := nation ;
99311: LD_ADDR_OWVAR 21
99315: PUSH
99316: LD_VAR 0 1
99320: ST_TO_ADDR
// InitHc ;
99321: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99325: LD_INT 0
99327: PPUSH
99328: LD_VAR 0 2
99332: PPUSH
99333: LD_VAR 0 3
99337: PPUSH
99338: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99342: LD_VAR 0 4
99346: PPUSH
99347: LD_VAR 0 5
99351: PPUSH
99352: CALL_OW 428
99356: PUSH
99357: LD_INT 0
99359: EQUAL
99360: IFFALSE 99384
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99362: CALL_OW 44
99366: PPUSH
99367: LD_VAR 0 4
99371: PPUSH
99372: LD_VAR 0 5
99376: PPUSH
99377: LD_INT 1
99379: PPUSH
99380: CALL_OW 48
// end ;
99384: LD_VAR 0 6
99388: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99389: LD_INT 0
99391: PPUSH
99392: PPUSH
// uc_side := your_side ;
99393: LD_ADDR_OWVAR 20
99397: PUSH
99398: LD_OWVAR 2
99402: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99403: LD_VAR 0 1
99407: PUSH
99408: LD_INT 1
99410: PUSH
99411: LD_INT 2
99413: PUSH
99414: LD_INT 3
99416: PUSH
99417: LD_INT 4
99419: PUSH
99420: LD_INT 5
99422: PUSH
99423: EMPTY
99424: LIST
99425: LIST
99426: LIST
99427: LIST
99428: LIST
99429: IN
99430: IFFALSE 99442
// uc_nation := nation_american else
99432: LD_ADDR_OWVAR 21
99436: PUSH
99437: LD_INT 1
99439: ST_TO_ADDR
99440: GO 99485
// if chassis in [ 11 , 12 , 13 , 14 ] then
99442: LD_VAR 0 1
99446: PUSH
99447: LD_INT 11
99449: PUSH
99450: LD_INT 12
99452: PUSH
99453: LD_INT 13
99455: PUSH
99456: LD_INT 14
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: LIST
99463: LIST
99464: IN
99465: IFFALSE 99477
// uc_nation := nation_arabian else
99467: LD_ADDR_OWVAR 21
99471: PUSH
99472: LD_INT 2
99474: ST_TO_ADDR
99475: GO 99485
// uc_nation := nation_russian ;
99477: LD_ADDR_OWVAR 21
99481: PUSH
99482: LD_INT 3
99484: ST_TO_ADDR
// vc_chassis := chassis ;
99485: LD_ADDR_OWVAR 37
99489: PUSH
99490: LD_VAR 0 1
99494: ST_TO_ADDR
// vc_engine := engine ;
99495: LD_ADDR_OWVAR 39
99499: PUSH
99500: LD_VAR 0 2
99504: ST_TO_ADDR
// vc_control := control ;
99505: LD_ADDR_OWVAR 38
99509: PUSH
99510: LD_VAR 0 3
99514: ST_TO_ADDR
// vc_weapon := weapon ;
99515: LD_ADDR_OWVAR 40
99519: PUSH
99520: LD_VAR 0 4
99524: ST_TO_ADDR
// un := CreateVehicle ;
99525: LD_ADDR_VAR 0 8
99529: PUSH
99530: CALL_OW 45
99534: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99535: LD_VAR 0 8
99539: PPUSH
99540: LD_INT 0
99542: PPUSH
99543: LD_INT 5
99545: PPUSH
99546: CALL_OW 12
99550: PPUSH
99551: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99555: LD_VAR 0 8
99559: PPUSH
99560: LD_VAR 0 5
99564: PPUSH
99565: LD_VAR 0 6
99569: PPUSH
99570: LD_INT 1
99572: PPUSH
99573: CALL_OW 48
// end ;
99577: LD_VAR 0 7
99581: RET
// export hInvincible ; every 1 do
99582: GO 99584
99584: DISABLE
// hInvincible := [ ] ;
99585: LD_ADDR_EXP 180
99589: PUSH
99590: EMPTY
99591: ST_TO_ADDR
99592: END
// every 10 do var i ;
99593: GO 99595
99595: DISABLE
99596: LD_INT 0
99598: PPUSH
// begin enable ;
99599: ENABLE
// if not hInvincible then
99600: LD_EXP 180
99604: NOT
99605: IFFALSE 99609
// exit ;
99607: GO 99653
// for i in hInvincible do
99609: LD_ADDR_VAR 0 1
99613: PUSH
99614: LD_EXP 180
99618: PUSH
99619: FOR_IN
99620: IFFALSE 99651
// if GetLives ( i ) < 1000 then
99622: LD_VAR 0 1
99626: PPUSH
99627: CALL_OW 256
99631: PUSH
99632: LD_INT 1000
99634: LESS
99635: IFFALSE 99649
// SetLives ( i , 1000 ) ;
99637: LD_VAR 0 1
99641: PPUSH
99642: LD_INT 1000
99644: PPUSH
99645: CALL_OW 234
99649: GO 99619
99651: POP
99652: POP
// end ;
99653: PPOPN 1
99655: END
// export function hHackInvincible ; var i ; begin
99656: LD_INT 0
99658: PPUSH
99659: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99660: LD_ADDR_VAR 0 2
99664: PUSH
99665: LD_INT 2
99667: PUSH
99668: LD_INT 21
99670: PUSH
99671: LD_INT 1
99673: PUSH
99674: EMPTY
99675: LIST
99676: LIST
99677: PUSH
99678: LD_INT 21
99680: PUSH
99681: LD_INT 2
99683: PUSH
99684: EMPTY
99685: LIST
99686: LIST
99687: PUSH
99688: EMPTY
99689: LIST
99690: LIST
99691: LIST
99692: PPUSH
99693: CALL_OW 69
99697: PUSH
99698: FOR_IN
99699: IFFALSE 99760
// if IsSelected ( i ) then
99701: LD_VAR 0 2
99705: PPUSH
99706: CALL_OW 306
99710: IFFALSE 99758
// begin if i in hInvincible then
99712: LD_VAR 0 2
99716: PUSH
99717: LD_EXP 180
99721: IN
99722: IFFALSE 99742
// hInvincible := hInvincible diff i else
99724: LD_ADDR_EXP 180
99728: PUSH
99729: LD_EXP 180
99733: PUSH
99734: LD_VAR 0 2
99738: DIFF
99739: ST_TO_ADDR
99740: GO 99758
// hInvincible := hInvincible union i ;
99742: LD_ADDR_EXP 180
99746: PUSH
99747: LD_EXP 180
99751: PUSH
99752: LD_VAR 0 2
99756: UNION
99757: ST_TO_ADDR
// end ;
99758: GO 99698
99760: POP
99761: POP
// end ;
99762: LD_VAR 0 1
99766: RET
// export function hHackInvisible ; var i , j ; begin
99767: LD_INT 0
99769: PPUSH
99770: PPUSH
99771: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99772: LD_ADDR_VAR 0 2
99776: PUSH
99777: LD_INT 21
99779: PUSH
99780: LD_INT 1
99782: PUSH
99783: EMPTY
99784: LIST
99785: LIST
99786: PPUSH
99787: CALL_OW 69
99791: PUSH
99792: FOR_IN
99793: IFFALSE 99817
// if IsSelected ( i ) then
99795: LD_VAR 0 2
99799: PPUSH
99800: CALL_OW 306
99804: IFFALSE 99815
// ComForceInvisible ( i ) ;
99806: LD_VAR 0 2
99810: PPUSH
99811: CALL_OW 496
99815: GO 99792
99817: POP
99818: POP
// end ;
99819: LD_VAR 0 1
99823: RET
// export function hHackChangeYourSide ; begin
99824: LD_INT 0
99826: PPUSH
// if your_side = 8 then
99827: LD_OWVAR 2
99831: PUSH
99832: LD_INT 8
99834: EQUAL
99835: IFFALSE 99847
// your_side := 0 else
99837: LD_ADDR_OWVAR 2
99841: PUSH
99842: LD_INT 0
99844: ST_TO_ADDR
99845: GO 99861
// your_side := your_side + 1 ;
99847: LD_ADDR_OWVAR 2
99851: PUSH
99852: LD_OWVAR 2
99856: PUSH
99857: LD_INT 1
99859: PLUS
99860: ST_TO_ADDR
// end ;
99861: LD_VAR 0 1
99865: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99866: LD_INT 0
99868: PPUSH
99869: PPUSH
99870: PPUSH
// for i in all_units do
99871: LD_ADDR_VAR 0 2
99875: PUSH
99876: LD_OWVAR 3
99880: PUSH
99881: FOR_IN
99882: IFFALSE 99960
// if IsSelected ( i ) then
99884: LD_VAR 0 2
99888: PPUSH
99889: CALL_OW 306
99893: IFFALSE 99958
// begin j := GetSide ( i ) ;
99895: LD_ADDR_VAR 0 3
99899: PUSH
99900: LD_VAR 0 2
99904: PPUSH
99905: CALL_OW 255
99909: ST_TO_ADDR
// if j = 8 then
99910: LD_VAR 0 3
99914: PUSH
99915: LD_INT 8
99917: EQUAL
99918: IFFALSE 99930
// j := 0 else
99920: LD_ADDR_VAR 0 3
99924: PUSH
99925: LD_INT 0
99927: ST_TO_ADDR
99928: GO 99944
// j := j + 1 ;
99930: LD_ADDR_VAR 0 3
99934: PUSH
99935: LD_VAR 0 3
99939: PUSH
99940: LD_INT 1
99942: PLUS
99943: ST_TO_ADDR
// SetSide ( i , j ) ;
99944: LD_VAR 0 2
99948: PPUSH
99949: LD_VAR 0 3
99953: PPUSH
99954: CALL_OW 235
// end ;
99958: GO 99881
99960: POP
99961: POP
// end ;
99962: LD_VAR 0 1
99966: RET
// export function hHackFog ; begin
99967: LD_INT 0
99969: PPUSH
// FogOff ( true ) ;
99970: LD_INT 1
99972: PPUSH
99973: CALL_OW 344
// end ;
99977: LD_VAR 0 1
99981: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99982: LD_INT 0
99984: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99985: LD_VAR 0 1
99989: PPUSH
99990: LD_VAR 0 2
99994: PPUSH
99995: LD_VAR 0 3
99999: PPUSH
100000: LD_INT 1
100002: PPUSH
100003: LD_INT 1
100005: PPUSH
100006: CALL_OW 483
// CenterOnXY ( x , y ) ;
100010: LD_VAR 0 2
100014: PPUSH
100015: LD_VAR 0 3
100019: PPUSH
100020: CALL_OW 84
// end ; end_of_file
100024: LD_VAR 0 4
100028: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
100029: LD_INT 0
100031: PPUSH
100032: PPUSH
100033: PPUSH
100034: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
100035: LD_VAR 0 1
100039: PPUSH
100040: CALL_OW 264
100044: PUSH
100045: LD_EXP 108
100049: EQUAL
100050: IFFALSE 100122
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100052: LD_INT 68
100054: PPUSH
100055: LD_VAR 0 1
100059: PPUSH
100060: CALL_OW 255
100064: PPUSH
100065: CALL_OW 321
100069: PUSH
100070: LD_INT 2
100072: EQUAL
100073: IFFALSE 100085
// eff := 70 else
100075: LD_ADDR_VAR 0 4
100079: PUSH
100080: LD_INT 70
100082: ST_TO_ADDR
100083: GO 100093
// eff := 30 ;
100085: LD_ADDR_VAR 0 4
100089: PUSH
100090: LD_INT 30
100092: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100093: LD_VAR 0 1
100097: PPUSH
100098: CALL_OW 250
100102: PPUSH
100103: LD_VAR 0 1
100107: PPUSH
100108: CALL_OW 251
100112: PPUSH
100113: LD_VAR 0 4
100117: PPUSH
100118: CALL_OW 495
// end ; end ;
100122: LD_VAR 0 2
100126: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100127: LD_INT 0
100129: PPUSH
// end ;
100130: LD_VAR 0 4
100134: RET
// export function SOS_Command ( cmd ) ; begin
100135: LD_INT 0
100137: PPUSH
// end ;
100138: LD_VAR 0 2
100142: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
100143: LD_INT 0
100145: PPUSH
// end ;
100146: LD_VAR 0 6
100150: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
100151: LD_INT 0
100153: PPUSH
100154: PPUSH
// if not vehicle or not factory then
100155: LD_VAR 0 1
100159: NOT
100160: PUSH
100161: LD_VAR 0 2
100165: NOT
100166: OR
100167: IFFALSE 100171
// exit ;
100169: GO 100402
// if factoryWaypoints >= factory then
100171: LD_EXP 181
100175: PUSH
100176: LD_VAR 0 2
100180: GREATEREQUAL
100181: IFFALSE 100402
// if factoryWaypoints [ factory ] then
100183: LD_EXP 181
100187: PUSH
100188: LD_VAR 0 2
100192: ARRAY
100193: IFFALSE 100402
// begin if GetControl ( vehicle ) = control_manual then
100195: LD_VAR 0 1
100199: PPUSH
100200: CALL_OW 263
100204: PUSH
100205: LD_INT 1
100207: EQUAL
100208: IFFALSE 100289
// begin driver := IsDrivenBy ( vehicle ) ;
100210: LD_ADDR_VAR 0 4
100214: PUSH
100215: LD_VAR 0 1
100219: PPUSH
100220: CALL_OW 311
100224: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
100225: LD_VAR 0 4
100229: PPUSH
100230: LD_EXP 181
100234: PUSH
100235: LD_VAR 0 2
100239: ARRAY
100240: PUSH
100241: LD_INT 1
100243: ARRAY
100244: PPUSH
100245: LD_EXP 181
100249: PUSH
100250: LD_VAR 0 2
100254: ARRAY
100255: PUSH
100256: LD_INT 2
100258: ARRAY
100259: PPUSH
100260: CALL_OW 171
// AddComExitVehicle ( driver ) ;
100264: LD_VAR 0 4
100268: PPUSH
100269: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
100273: LD_VAR 0 4
100277: PPUSH
100278: LD_VAR 0 2
100282: PPUSH
100283: CALL_OW 180
// end else
100287: GO 100402
// if GetControl ( vehicle ) = control_remote then
100289: LD_VAR 0 1
100293: PPUSH
100294: CALL_OW 263
100298: PUSH
100299: LD_INT 2
100301: EQUAL
100302: IFFALSE 100363
// begin wait ( 0 0$2 ) ;
100304: LD_INT 70
100306: PPUSH
100307: CALL_OW 67
// if Connect ( vehicle ) then
100311: LD_VAR 0 1
100315: PPUSH
100316: CALL 22772 0 1
100320: IFFALSE 100361
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
100322: LD_VAR 0 1
100326: PPUSH
100327: LD_EXP 181
100331: PUSH
100332: LD_VAR 0 2
100336: ARRAY
100337: PUSH
100338: LD_INT 1
100340: ARRAY
100341: PPUSH
100342: LD_EXP 181
100346: PUSH
100347: LD_VAR 0 2
100351: ARRAY
100352: PUSH
100353: LD_INT 2
100355: ARRAY
100356: PPUSH
100357: CALL_OW 171
// end else
100361: GO 100402
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 1 ] , factoryWaypoints [ factory ] [ 2 ] ) ;
100363: LD_VAR 0 1
100367: PPUSH
100368: LD_EXP 181
100372: PUSH
100373: LD_VAR 0 2
100377: ARRAY
100378: PUSH
100379: LD_INT 1
100381: ARRAY
100382: PPUSH
100383: LD_EXP 181
100387: PUSH
100388: LD_VAR 0 2
100392: ARRAY
100393: PUSH
100394: LD_INT 2
100396: ARRAY
100397: PPUSH
100398: CALL_OW 171
// end ; end ;
100402: LD_VAR 0 3
100406: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100407: LD_INT 0
100409: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100410: LD_VAR 0 1
100414: PUSH
100415: LD_INT 250
100417: EQUAL
100418: PUSH
100419: LD_VAR 0 2
100423: PPUSH
100424: CALL_OW 264
100428: PUSH
100429: LD_EXP 111
100433: EQUAL
100434: AND
100435: IFFALSE 100456
// MinerPlaceMine ( unit , x , y ) ;
100437: LD_VAR 0 2
100441: PPUSH
100442: LD_VAR 0 4
100446: PPUSH
100447: LD_VAR 0 5
100451: PPUSH
100452: CALL 103184 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
100456: LD_VAR 0 1
100460: PUSH
100461: LD_INT 251
100463: EQUAL
100464: PUSH
100465: LD_VAR 0 2
100469: PPUSH
100470: CALL_OW 264
100474: PUSH
100475: LD_EXP 111
100479: EQUAL
100480: AND
100481: IFFALSE 100502
// MinerDetonateMine ( unit , x , y ) ;
100483: LD_VAR 0 2
100487: PPUSH
100488: LD_VAR 0 4
100492: PPUSH
100493: LD_VAR 0 5
100497: PPUSH
100498: CALL 103461 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
100502: LD_VAR 0 1
100506: PUSH
100507: LD_INT 252
100509: EQUAL
100510: PUSH
100511: LD_VAR 0 2
100515: PPUSH
100516: CALL_OW 264
100520: PUSH
100521: LD_EXP 111
100525: EQUAL
100526: AND
100527: IFFALSE 100548
// MinerCreateMinefield ( unit , x , y ) ;
100529: LD_VAR 0 2
100533: PPUSH
100534: LD_VAR 0 4
100538: PPUSH
100539: LD_VAR 0 5
100543: PPUSH
100544: CALL 103878 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
100548: LD_VAR 0 1
100552: PUSH
100553: LD_INT 253
100555: EQUAL
100556: PUSH
100557: LD_VAR 0 2
100561: PPUSH
100562: CALL_OW 257
100566: PUSH
100567: LD_INT 5
100569: EQUAL
100570: AND
100571: IFFALSE 100592
// ComBinocular ( unit , x , y ) ;
100573: LD_VAR 0 2
100577: PPUSH
100578: LD_VAR 0 4
100582: PPUSH
100583: LD_VAR 0 5
100587: PPUSH
100588: CALL 104249 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
100592: LD_VAR 0 1
100596: PUSH
100597: LD_INT 254
100599: EQUAL
100600: PUSH
100601: LD_VAR 0 2
100605: PPUSH
100606: CALL_OW 264
100610: PUSH
100611: LD_EXP 106
100615: EQUAL
100616: AND
100617: PUSH
100618: LD_VAR 0 3
100622: PPUSH
100623: CALL_OW 263
100627: PUSH
100628: LD_INT 3
100630: EQUAL
100631: AND
100632: IFFALSE 100648
// HackDestroyVehicle ( unit , selectedUnit ) ;
100634: LD_VAR 0 2
100638: PPUSH
100639: LD_VAR 0 3
100643: PPUSH
100644: CALL 102544 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
100648: LD_VAR 0 1
100652: PUSH
100653: LD_INT 255
100655: EQUAL
100656: PUSH
100657: LD_VAR 0 2
100661: PPUSH
100662: CALL_OW 264
100666: PUSH
100667: LD_INT 14
100669: PUSH
100670: LD_INT 53
100672: PUSH
100673: EMPTY
100674: LIST
100675: LIST
100676: IN
100677: AND
100678: PUSH
100679: LD_VAR 0 4
100683: PPUSH
100684: LD_VAR 0 5
100688: PPUSH
100689: CALL_OW 488
100693: AND
100694: IFFALSE 100718
// CutTreeXYR ( unit , x , y , 12 ) ;
100696: LD_VAR 0 2
100700: PPUSH
100701: LD_VAR 0 4
100705: PPUSH
100706: LD_VAR 0 5
100710: PPUSH
100711: LD_INT 12
100713: PPUSH
100714: CALL 101110 0 4
// if cmd = 256 then
100718: LD_VAR 0 1
100722: PUSH
100723: LD_INT 256
100725: EQUAL
100726: IFFALSE 100747
// SetFactoryWaypoint ( unit , x , y ) ;
100728: LD_VAR 0 2
100732: PPUSH
100733: LD_VAR 0 4
100737: PPUSH
100738: LD_VAR 0 5
100742: PPUSH
100743: CALL 100752 0 3
// end ;
100747: LD_VAR 0 6
100751: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
100752: LD_INT 0
100754: PPUSH
100755: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
100756: LD_VAR 0 1
100760: NOT
100761: PUSH
100762: LD_VAR 0 2
100766: PPUSH
100767: LD_VAR 0 3
100771: PPUSH
100772: CALL_OW 488
100776: NOT
100777: OR
100778: PUSH
100779: LD_VAR 0 1
100783: PPUSH
100784: CALL_OW 266
100788: PUSH
100789: LD_INT 3
100791: NONEQUAL
100792: PUSH
100793: LD_VAR 0 1
100797: PPUSH
100798: CALL_OW 247
100802: PUSH
100803: LD_INT 1
100805: EQUAL
100806: NOT
100807: AND
100808: OR
100809: IFFALSE 100813
// exit ;
100811: GO 100962
// if GetType ( factory ) = unit_human then
100813: LD_VAR 0 1
100817: PPUSH
100818: CALL_OW 247
100822: PUSH
100823: LD_INT 1
100825: EQUAL
100826: IFFALSE 100843
// factory := IsInUnit ( factory ) ;
100828: LD_ADDR_VAR 0 1
100832: PUSH
100833: LD_VAR 0 1
100837: PPUSH
100838: CALL_OW 310
100842: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
100843: LD_VAR 0 1
100847: PPUSH
100848: CALL_OW 266
100852: PUSH
100853: LD_INT 3
100855: NONEQUAL
100856: IFFALSE 100860
// exit ;
100858: GO 100962
// if HexInfo ( x , y ) = factory then
100860: LD_VAR 0 2
100864: PPUSH
100865: LD_VAR 0 3
100869: PPUSH
100870: CALL_OW 428
100874: PUSH
100875: LD_VAR 0 1
100879: EQUAL
100880: IFFALSE 100907
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
100882: LD_ADDR_EXP 181
100886: PUSH
100887: LD_EXP 181
100891: PPUSH
100892: LD_VAR 0 1
100896: PPUSH
100897: LD_INT 0
100899: PPUSH
100900: CALL_OW 1
100904: ST_TO_ADDR
100905: GO 100958
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
100907: LD_ADDR_EXP 181
100911: PUSH
100912: LD_EXP 181
100916: PPUSH
100917: LD_VAR 0 1
100921: PPUSH
100922: LD_VAR 0 1
100926: PPUSH
100927: CALL_OW 255
100931: PUSH
100932: LD_VAR 0 1
100936: PUSH
100937: LD_VAR 0 2
100941: PUSH
100942: LD_VAR 0 3
100946: PUSH
100947: EMPTY
100948: LIST
100949: LIST
100950: LIST
100951: LIST
100952: PPUSH
100953: CALL_OW 1
100957: ST_TO_ADDR
// UpdateFactoryWaypoints ;
100958: CALL 100967 0 0
// end ;
100962: LD_VAR 0 4
100966: RET
// export function UpdateFactoryWaypoints ( ) ; var i ; begin
100967: LD_INT 0
100969: PPUSH
100970: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
100971: LD_STRING resetFactoryWaypoint();
100973: PPUSH
100974: CALL_OW 559
// if factoryWaypoints then
100978: LD_EXP 181
100982: IFFALSE 101105
// begin for i := 1 to factoryWaypoints do
100984: LD_ADDR_VAR 0 2
100988: PUSH
100989: DOUBLE
100990: LD_INT 1
100992: DEC
100993: ST_TO_ADDR
100994: LD_EXP 181
100998: PUSH
100999: FOR_TO
101000: IFFALSE 101103
// if factoryWaypoints [ i ] then
101002: LD_EXP 181
101006: PUSH
101007: LD_VAR 0 2
101011: ARRAY
101012: IFFALSE 101101
// ToLua ( setFactoryWaypointXY( & factoryWaypoints [ i ] [ 1 ] & , & factoryWaypoints [ i ] [ 2 ] & , & factoryWaypoints [ i ] [ 3 ] & , & factoryWaypoints [ i ] [ 4 ] & ) ) ;
101014: LD_STRING setFactoryWaypointXY(
101016: PUSH
101017: LD_EXP 181
101021: PUSH
101022: LD_VAR 0 2
101026: ARRAY
101027: PUSH
101028: LD_INT 1
101030: ARRAY
101031: STR
101032: PUSH
101033: LD_STRING ,
101035: STR
101036: PUSH
101037: LD_EXP 181
101041: PUSH
101042: LD_VAR 0 2
101046: ARRAY
101047: PUSH
101048: LD_INT 2
101050: ARRAY
101051: STR
101052: PUSH
101053: LD_STRING ,
101055: STR
101056: PUSH
101057: LD_EXP 181
101061: PUSH
101062: LD_VAR 0 2
101066: ARRAY
101067: PUSH
101068: LD_INT 3
101070: ARRAY
101071: STR
101072: PUSH
101073: LD_STRING ,
101075: STR
101076: PUSH
101077: LD_EXP 181
101081: PUSH
101082: LD_VAR 0 2
101086: ARRAY
101087: PUSH
101088: LD_INT 4
101090: ARRAY
101091: STR
101092: PUSH
101093: LD_STRING )
101095: STR
101096: PPUSH
101097: CALL_OW 559
101101: GO 100999
101103: POP
101104: POP
// end ; end ;
101105: LD_VAR 0 1
101109: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
101110: LD_INT 0
101112: PPUSH
101113: PPUSH
101114: PPUSH
101115: PPUSH
101116: PPUSH
101117: PPUSH
101118: PPUSH
101119: PPUSH
101120: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101121: LD_VAR 0 1
101125: NOT
101126: PUSH
101127: LD_VAR 0 2
101131: PPUSH
101132: LD_VAR 0 3
101136: PPUSH
101137: CALL_OW 488
101141: NOT
101142: OR
101143: PUSH
101144: LD_VAR 0 4
101148: NOT
101149: OR
101150: IFFALSE 101154
// exit ;
101152: GO 101494
// list := [ ] ;
101154: LD_ADDR_VAR 0 13
101158: PUSH
101159: EMPTY
101160: ST_TO_ADDR
// if x - r < 0 then
101161: LD_VAR 0 2
101165: PUSH
101166: LD_VAR 0 4
101170: MINUS
101171: PUSH
101172: LD_INT 0
101174: LESS
101175: IFFALSE 101187
// min_x := 0 else
101177: LD_ADDR_VAR 0 7
101181: PUSH
101182: LD_INT 0
101184: ST_TO_ADDR
101185: GO 101203
// min_x := x - r ;
101187: LD_ADDR_VAR 0 7
101191: PUSH
101192: LD_VAR 0 2
101196: PUSH
101197: LD_VAR 0 4
101201: MINUS
101202: ST_TO_ADDR
// if y - r < 0 then
101203: LD_VAR 0 3
101207: PUSH
101208: LD_VAR 0 4
101212: MINUS
101213: PUSH
101214: LD_INT 0
101216: LESS
101217: IFFALSE 101229
// min_y := 0 else
101219: LD_ADDR_VAR 0 8
101223: PUSH
101224: LD_INT 0
101226: ST_TO_ADDR
101227: GO 101245
// min_y := y - r ;
101229: LD_ADDR_VAR 0 8
101233: PUSH
101234: LD_VAR 0 3
101238: PUSH
101239: LD_VAR 0 4
101243: MINUS
101244: ST_TO_ADDR
// max_x := x + r ;
101245: LD_ADDR_VAR 0 9
101249: PUSH
101250: LD_VAR 0 2
101254: PUSH
101255: LD_VAR 0 4
101259: PLUS
101260: ST_TO_ADDR
// max_y := y + r ;
101261: LD_ADDR_VAR 0 10
101265: PUSH
101266: LD_VAR 0 3
101270: PUSH
101271: LD_VAR 0 4
101275: PLUS
101276: ST_TO_ADDR
// for _x = min_x to max_x do
101277: LD_ADDR_VAR 0 11
101281: PUSH
101282: DOUBLE
101283: LD_VAR 0 7
101287: DEC
101288: ST_TO_ADDR
101289: LD_VAR 0 9
101293: PUSH
101294: FOR_TO
101295: IFFALSE 101412
// for _y = min_y to max_y do
101297: LD_ADDR_VAR 0 12
101301: PUSH
101302: DOUBLE
101303: LD_VAR 0 8
101307: DEC
101308: ST_TO_ADDR
101309: LD_VAR 0 10
101313: PUSH
101314: FOR_TO
101315: IFFALSE 101408
// begin if not ValidHex ( _x , _y ) then
101317: LD_VAR 0 11
101321: PPUSH
101322: LD_VAR 0 12
101326: PPUSH
101327: CALL_OW 488
101331: NOT
101332: IFFALSE 101336
// continue ;
101334: GO 101314
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101336: LD_VAR 0 11
101340: PPUSH
101341: LD_VAR 0 12
101345: PPUSH
101346: CALL_OW 351
101350: PUSH
101351: LD_VAR 0 11
101355: PPUSH
101356: LD_VAR 0 12
101360: PPUSH
101361: CALL_OW 554
101365: AND
101366: IFFALSE 101406
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101368: LD_ADDR_VAR 0 13
101372: PUSH
101373: LD_VAR 0 13
101377: PPUSH
101378: LD_VAR 0 13
101382: PUSH
101383: LD_INT 1
101385: PLUS
101386: PPUSH
101387: LD_VAR 0 11
101391: PUSH
101392: LD_VAR 0 12
101396: PUSH
101397: EMPTY
101398: LIST
101399: LIST
101400: PPUSH
101401: CALL_OW 2
101405: ST_TO_ADDR
// end ;
101406: GO 101314
101408: POP
101409: POP
101410: GO 101294
101412: POP
101413: POP
// if not list then
101414: LD_VAR 0 13
101418: NOT
101419: IFFALSE 101423
// exit ;
101421: GO 101494
// for i in list do
101423: LD_ADDR_VAR 0 6
101427: PUSH
101428: LD_VAR 0 13
101432: PUSH
101433: FOR_IN
101434: IFFALSE 101492
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101436: LD_VAR 0 1
101440: PPUSH
101441: LD_STRING M
101443: PUSH
101444: LD_VAR 0 6
101448: PUSH
101449: LD_INT 1
101451: ARRAY
101452: PUSH
101453: LD_VAR 0 6
101457: PUSH
101458: LD_INT 2
101460: ARRAY
101461: PUSH
101462: LD_INT 0
101464: PUSH
101465: LD_INT 0
101467: PUSH
101468: LD_INT 0
101470: PUSH
101471: LD_INT 0
101473: PUSH
101474: EMPTY
101475: LIST
101476: LIST
101477: LIST
101478: LIST
101479: LIST
101480: LIST
101481: LIST
101482: PUSH
101483: EMPTY
101484: LIST
101485: PPUSH
101486: CALL_OW 447
101490: GO 101433
101492: POP
101493: POP
// end ;
101494: LD_VAR 0 5
101498: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101499: LD_EXP 182
101503: NOT
101504: IFFALSE 101554
101506: GO 101508
101508: DISABLE
// begin initHack := true ;
101509: LD_ADDR_EXP 182
101513: PUSH
101514: LD_INT 1
101516: ST_TO_ADDR
// hackTanks := [ ] ;
101517: LD_ADDR_EXP 183
101521: PUSH
101522: EMPTY
101523: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101524: LD_ADDR_EXP 184
101528: PUSH
101529: EMPTY
101530: ST_TO_ADDR
// hackLimit := 3 ;
101531: LD_ADDR_EXP 185
101535: PUSH
101536: LD_INT 3
101538: ST_TO_ADDR
// hackDist := 12 ;
101539: LD_ADDR_EXP 186
101543: PUSH
101544: LD_INT 12
101546: ST_TO_ADDR
// hackCounter := [ ] ;
101547: LD_ADDR_EXP 187
101551: PUSH
101552: EMPTY
101553: ST_TO_ADDR
// end ;
101554: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101555: LD_EXP 182
101559: PUSH
101560: LD_INT 34
101562: PUSH
101563: LD_EXP 106
101567: PUSH
101568: EMPTY
101569: LIST
101570: LIST
101571: PPUSH
101572: CALL_OW 69
101576: AND
101577: IFFALSE 101832
101579: GO 101581
101581: DISABLE
101582: LD_INT 0
101584: PPUSH
101585: PPUSH
// begin enable ;
101586: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
101587: LD_ADDR_VAR 0 1
101591: PUSH
101592: LD_INT 34
101594: PUSH
101595: LD_EXP 106
101599: PUSH
101600: EMPTY
101601: LIST
101602: LIST
101603: PPUSH
101604: CALL_OW 69
101608: PUSH
101609: FOR_IN
101610: IFFALSE 101830
// begin if not i in hackTanks then
101612: LD_VAR 0 1
101616: PUSH
101617: LD_EXP 183
101621: IN
101622: NOT
101623: IFFALSE 101706
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
101625: LD_ADDR_EXP 183
101629: PUSH
101630: LD_EXP 183
101634: PPUSH
101635: LD_EXP 183
101639: PUSH
101640: LD_INT 1
101642: PLUS
101643: PPUSH
101644: LD_VAR 0 1
101648: PPUSH
101649: CALL_OW 1
101653: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
101654: LD_ADDR_EXP 184
101658: PUSH
101659: LD_EXP 184
101663: PPUSH
101664: LD_EXP 184
101668: PUSH
101669: LD_INT 1
101671: PLUS
101672: PPUSH
101673: EMPTY
101674: PPUSH
101675: CALL_OW 1
101679: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
101680: LD_ADDR_EXP 187
101684: PUSH
101685: LD_EXP 187
101689: PPUSH
101690: LD_EXP 187
101694: PUSH
101695: LD_INT 1
101697: PLUS
101698: PPUSH
101699: EMPTY
101700: PPUSH
101701: CALL_OW 1
101705: ST_TO_ADDR
// end ; if not IsOk ( i ) then
101706: LD_VAR 0 1
101710: PPUSH
101711: CALL_OW 302
101715: NOT
101716: IFFALSE 101729
// begin HackUnlinkAll ( i ) ;
101718: LD_VAR 0 1
101722: PPUSH
101723: CALL 101835 0 1
// continue ;
101727: GO 101609
// end ; HackCheckCapturedStatus ( i ) ;
101729: LD_VAR 0 1
101733: PPUSH
101734: CALL 102278 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
101738: LD_ADDR_VAR 0 2
101742: PUSH
101743: LD_INT 81
101745: PUSH
101746: LD_VAR 0 1
101750: PPUSH
101751: CALL_OW 255
101755: PUSH
101756: EMPTY
101757: LIST
101758: LIST
101759: PUSH
101760: LD_INT 33
101762: PUSH
101763: LD_INT 3
101765: PUSH
101766: EMPTY
101767: LIST
101768: LIST
101769: PUSH
101770: LD_INT 91
101772: PUSH
101773: LD_VAR 0 1
101777: PUSH
101778: LD_EXP 186
101782: PUSH
101783: EMPTY
101784: LIST
101785: LIST
101786: LIST
101787: PUSH
101788: LD_INT 50
101790: PUSH
101791: EMPTY
101792: LIST
101793: PUSH
101794: EMPTY
101795: LIST
101796: LIST
101797: LIST
101798: LIST
101799: PPUSH
101800: CALL_OW 69
101804: ST_TO_ADDR
// if not tmp then
101805: LD_VAR 0 2
101809: NOT
101810: IFFALSE 101814
// continue ;
101812: GO 101609
// HackLink ( i , tmp ) ;
101814: LD_VAR 0 1
101818: PPUSH
101819: LD_VAR 0 2
101823: PPUSH
101824: CALL 101971 0 2
// end ;
101828: GO 101609
101830: POP
101831: POP
// end ;
101832: PPOPN 2
101834: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
101835: LD_INT 0
101837: PPUSH
101838: PPUSH
101839: PPUSH
// if not hack in hackTanks then
101840: LD_VAR 0 1
101844: PUSH
101845: LD_EXP 183
101849: IN
101850: NOT
101851: IFFALSE 101855
// exit ;
101853: GO 101966
// index := GetElementIndex ( hackTanks , hack ) ;
101855: LD_ADDR_VAR 0 4
101859: PUSH
101860: LD_EXP 183
101864: PPUSH
101865: LD_VAR 0 1
101869: PPUSH
101870: CALL 19586 0 2
101874: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
101875: LD_EXP 184
101879: PUSH
101880: LD_VAR 0 4
101884: ARRAY
101885: IFFALSE 101966
// begin for i in hackTanksCaptured [ index ] do
101887: LD_ADDR_VAR 0 3
101891: PUSH
101892: LD_EXP 184
101896: PUSH
101897: LD_VAR 0 4
101901: ARRAY
101902: PUSH
101903: FOR_IN
101904: IFFALSE 101930
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
101906: LD_VAR 0 3
101910: PUSH
101911: LD_INT 1
101913: ARRAY
101914: PPUSH
101915: LD_VAR 0 3
101919: PUSH
101920: LD_INT 2
101922: ARRAY
101923: PPUSH
101924: CALL_OW 235
101928: GO 101903
101930: POP
101931: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
101932: LD_ADDR_EXP 184
101936: PUSH
101937: LD_EXP 184
101941: PPUSH
101942: LD_VAR 0 4
101946: PPUSH
101947: EMPTY
101948: PPUSH
101949: CALL_OW 1
101953: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
101954: LD_VAR 0 1
101958: PPUSH
101959: LD_INT 0
101961: PPUSH
101962: CALL_OW 505
// end ; end ;
101966: LD_VAR 0 2
101970: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
101971: LD_INT 0
101973: PPUSH
101974: PPUSH
101975: PPUSH
// if not hack in hackTanks or not vehicles then
101976: LD_VAR 0 1
101980: PUSH
101981: LD_EXP 183
101985: IN
101986: NOT
101987: PUSH
101988: LD_VAR 0 2
101992: NOT
101993: OR
101994: IFFALSE 101998
// exit ;
101996: GO 102273
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
101998: LD_ADDR_VAR 0 2
102002: PUSH
102003: LD_VAR 0 1
102007: PPUSH
102008: LD_VAR 0 2
102012: PPUSH
102013: LD_INT 1
102015: PPUSH
102016: LD_INT 1
102018: PPUSH
102019: CALL 20236 0 4
102023: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
102024: LD_ADDR_VAR 0 5
102028: PUSH
102029: LD_EXP 183
102033: PPUSH
102034: LD_VAR 0 1
102038: PPUSH
102039: CALL 19586 0 2
102043: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
102044: LD_EXP 184
102048: PUSH
102049: LD_VAR 0 5
102053: ARRAY
102054: PUSH
102055: LD_EXP 185
102059: LESS
102060: IFFALSE 102249
// begin for i := 1 to vehicles do
102062: LD_ADDR_VAR 0 4
102066: PUSH
102067: DOUBLE
102068: LD_INT 1
102070: DEC
102071: ST_TO_ADDR
102072: LD_VAR 0 2
102076: PUSH
102077: FOR_TO
102078: IFFALSE 102247
// begin if hackTanksCaptured [ index ] = hackLimit then
102080: LD_EXP 184
102084: PUSH
102085: LD_VAR 0 5
102089: ARRAY
102090: PUSH
102091: LD_EXP 185
102095: EQUAL
102096: IFFALSE 102100
// break ;
102098: GO 102247
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
102100: LD_ADDR_EXP 187
102104: PUSH
102105: LD_EXP 187
102109: PPUSH
102110: LD_VAR 0 5
102114: PPUSH
102115: LD_EXP 187
102119: PUSH
102120: LD_VAR 0 5
102124: ARRAY
102125: PUSH
102126: LD_INT 1
102128: PLUS
102129: PPUSH
102130: CALL_OW 1
102134: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102135: LD_ADDR_EXP 184
102139: PUSH
102140: LD_EXP 184
102144: PPUSH
102145: LD_VAR 0 5
102149: PUSH
102150: LD_EXP 184
102154: PUSH
102155: LD_VAR 0 5
102159: ARRAY
102160: PUSH
102161: LD_INT 1
102163: PLUS
102164: PUSH
102165: EMPTY
102166: LIST
102167: LIST
102168: PPUSH
102169: LD_VAR 0 2
102173: PUSH
102174: LD_VAR 0 4
102178: ARRAY
102179: PUSH
102180: LD_VAR 0 2
102184: PUSH
102185: LD_VAR 0 4
102189: ARRAY
102190: PPUSH
102191: CALL_OW 255
102195: PUSH
102196: EMPTY
102197: LIST
102198: LIST
102199: PPUSH
102200: CALL 19801 0 3
102204: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102205: LD_VAR 0 2
102209: PUSH
102210: LD_VAR 0 4
102214: ARRAY
102215: PPUSH
102216: LD_VAR 0 1
102220: PPUSH
102221: CALL_OW 255
102225: PPUSH
102226: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102230: LD_VAR 0 2
102234: PUSH
102235: LD_VAR 0 4
102239: ARRAY
102240: PPUSH
102241: CALL_OW 141
// end ;
102245: GO 102077
102247: POP
102248: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102249: LD_VAR 0 1
102253: PPUSH
102254: LD_EXP 184
102258: PUSH
102259: LD_VAR 0 5
102263: ARRAY
102264: PUSH
102265: LD_INT 0
102267: PLUS
102268: PPUSH
102269: CALL_OW 505
// end ;
102273: LD_VAR 0 3
102277: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102278: LD_INT 0
102280: PPUSH
102281: PPUSH
102282: PPUSH
102283: PPUSH
// if not hack in hackTanks then
102284: LD_VAR 0 1
102288: PUSH
102289: LD_EXP 183
102293: IN
102294: NOT
102295: IFFALSE 102299
// exit ;
102297: GO 102539
// index := GetElementIndex ( hackTanks , hack ) ;
102299: LD_ADDR_VAR 0 4
102303: PUSH
102304: LD_EXP 183
102308: PPUSH
102309: LD_VAR 0 1
102313: PPUSH
102314: CALL 19586 0 2
102318: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102319: LD_ADDR_VAR 0 3
102323: PUSH
102324: DOUBLE
102325: LD_EXP 184
102329: PUSH
102330: LD_VAR 0 4
102334: ARRAY
102335: INC
102336: ST_TO_ADDR
102337: LD_INT 1
102339: PUSH
102340: FOR_DOWNTO
102341: IFFALSE 102513
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102343: LD_ADDR_VAR 0 5
102347: PUSH
102348: LD_EXP 184
102352: PUSH
102353: LD_VAR 0 4
102357: ARRAY
102358: PUSH
102359: LD_VAR 0 3
102363: ARRAY
102364: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102365: LD_VAR 0 5
102369: PUSH
102370: LD_INT 1
102372: ARRAY
102373: PPUSH
102374: CALL_OW 302
102378: NOT
102379: PUSH
102380: LD_VAR 0 5
102384: PUSH
102385: LD_INT 1
102387: ARRAY
102388: PPUSH
102389: CALL_OW 255
102393: PUSH
102394: LD_VAR 0 1
102398: PPUSH
102399: CALL_OW 255
102403: NONEQUAL
102404: OR
102405: IFFALSE 102511
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102407: LD_VAR 0 5
102411: PUSH
102412: LD_INT 1
102414: ARRAY
102415: PPUSH
102416: CALL_OW 305
102420: PUSH
102421: LD_VAR 0 5
102425: PUSH
102426: LD_INT 1
102428: ARRAY
102429: PPUSH
102430: CALL_OW 255
102434: PUSH
102435: LD_VAR 0 1
102439: PPUSH
102440: CALL_OW 255
102444: EQUAL
102445: AND
102446: IFFALSE 102470
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102448: LD_VAR 0 5
102452: PUSH
102453: LD_INT 1
102455: ARRAY
102456: PPUSH
102457: LD_VAR 0 5
102461: PUSH
102462: LD_INT 2
102464: ARRAY
102465: PPUSH
102466: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102470: LD_ADDR_EXP 184
102474: PUSH
102475: LD_EXP 184
102479: PPUSH
102480: LD_VAR 0 4
102484: PPUSH
102485: LD_EXP 184
102489: PUSH
102490: LD_VAR 0 4
102494: ARRAY
102495: PPUSH
102496: LD_VAR 0 3
102500: PPUSH
102501: CALL_OW 3
102505: PPUSH
102506: CALL_OW 1
102510: ST_TO_ADDR
// end ; end ;
102511: GO 102340
102513: POP
102514: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102515: LD_VAR 0 1
102519: PPUSH
102520: LD_EXP 184
102524: PUSH
102525: LD_VAR 0 4
102529: ARRAY
102530: PUSH
102531: LD_INT 0
102533: PLUS
102534: PPUSH
102535: CALL_OW 505
// end ;
102539: LD_VAR 0 2
102543: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102544: LD_INT 0
102546: PPUSH
102547: PPUSH
102548: PPUSH
102549: PPUSH
// if not hack in hackTanks then
102550: LD_VAR 0 1
102554: PUSH
102555: LD_EXP 183
102559: IN
102560: NOT
102561: IFFALSE 102565
// exit ;
102563: GO 102650
// index := GetElementIndex ( hackTanks , hack ) ;
102565: LD_ADDR_VAR 0 5
102569: PUSH
102570: LD_EXP 183
102574: PPUSH
102575: LD_VAR 0 1
102579: PPUSH
102580: CALL 19586 0 2
102584: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
102585: LD_ADDR_VAR 0 4
102589: PUSH
102590: DOUBLE
102591: LD_INT 1
102593: DEC
102594: ST_TO_ADDR
102595: LD_EXP 184
102599: PUSH
102600: LD_VAR 0 5
102604: ARRAY
102605: PUSH
102606: FOR_TO
102607: IFFALSE 102648
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
102609: LD_EXP 184
102613: PUSH
102614: LD_VAR 0 5
102618: ARRAY
102619: PUSH
102620: LD_VAR 0 4
102624: ARRAY
102625: PUSH
102626: LD_INT 1
102628: ARRAY
102629: PUSH
102630: LD_VAR 0 2
102634: EQUAL
102635: IFFALSE 102646
// KillUnit ( vehicle ) ;
102637: LD_VAR 0 2
102641: PPUSH
102642: CALL_OW 66
102646: GO 102606
102648: POP
102649: POP
// end ;
102650: LD_VAR 0 3
102654: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
102655: LD_EXP 188
102659: NOT
102660: IFFALSE 102695
102662: GO 102664
102664: DISABLE
// begin initMiner := true ;
102665: LD_ADDR_EXP 188
102669: PUSH
102670: LD_INT 1
102672: ST_TO_ADDR
// minersList := [ ] ;
102673: LD_ADDR_EXP 189
102677: PUSH
102678: EMPTY
102679: ST_TO_ADDR
// minerMinesList := [ ] ;
102680: LD_ADDR_EXP 190
102684: PUSH
102685: EMPTY
102686: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
102687: LD_ADDR_EXP 191
102691: PUSH
102692: LD_INT 5
102694: ST_TO_ADDR
// end ;
102695: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
102696: LD_EXP 188
102700: PUSH
102701: LD_INT 34
102703: PUSH
102704: LD_EXP 111
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: PPUSH
102713: CALL_OW 69
102717: AND
102718: IFFALSE 103181
102720: GO 102722
102722: DISABLE
102723: LD_INT 0
102725: PPUSH
102726: PPUSH
102727: PPUSH
102728: PPUSH
// begin enable ;
102729: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
102730: LD_ADDR_VAR 0 1
102734: PUSH
102735: LD_INT 34
102737: PUSH
102738: LD_EXP 111
102742: PUSH
102743: EMPTY
102744: LIST
102745: LIST
102746: PPUSH
102747: CALL_OW 69
102751: PUSH
102752: FOR_IN
102753: IFFALSE 102825
// begin if not i in minersList then
102755: LD_VAR 0 1
102759: PUSH
102760: LD_EXP 189
102764: IN
102765: NOT
102766: IFFALSE 102823
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
102768: LD_ADDR_EXP 189
102772: PUSH
102773: LD_EXP 189
102777: PPUSH
102778: LD_EXP 189
102782: PUSH
102783: LD_INT 1
102785: PLUS
102786: PPUSH
102787: LD_VAR 0 1
102791: PPUSH
102792: CALL_OW 1
102796: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
102797: LD_ADDR_EXP 190
102801: PUSH
102802: LD_EXP 190
102806: PPUSH
102807: LD_EXP 190
102811: PUSH
102812: LD_INT 1
102814: PLUS
102815: PPUSH
102816: EMPTY
102817: PPUSH
102818: CALL_OW 1
102822: ST_TO_ADDR
// end end ;
102823: GO 102752
102825: POP
102826: POP
// for i := minerMinesList downto 1 do
102827: LD_ADDR_VAR 0 1
102831: PUSH
102832: DOUBLE
102833: LD_EXP 190
102837: INC
102838: ST_TO_ADDR
102839: LD_INT 1
102841: PUSH
102842: FOR_DOWNTO
102843: IFFALSE 103179
// begin if IsLive ( minersList [ i ] ) then
102845: LD_EXP 189
102849: PUSH
102850: LD_VAR 0 1
102854: ARRAY
102855: PPUSH
102856: CALL_OW 300
102860: IFFALSE 102888
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
102862: LD_EXP 189
102866: PUSH
102867: LD_VAR 0 1
102871: ARRAY
102872: PPUSH
102873: LD_EXP 190
102877: PUSH
102878: LD_VAR 0 1
102882: ARRAY
102883: PPUSH
102884: CALL_OW 505
// if not minerMinesList [ i ] then
102888: LD_EXP 190
102892: PUSH
102893: LD_VAR 0 1
102897: ARRAY
102898: NOT
102899: IFFALSE 102903
// continue ;
102901: GO 102842
// for j := minerMinesList [ i ] downto 1 do
102903: LD_ADDR_VAR 0 2
102907: PUSH
102908: DOUBLE
102909: LD_EXP 190
102913: PUSH
102914: LD_VAR 0 1
102918: ARRAY
102919: INC
102920: ST_TO_ADDR
102921: LD_INT 1
102923: PUSH
102924: FOR_DOWNTO
102925: IFFALSE 103175
// begin side := GetSide ( minersList [ i ] ) ;
102927: LD_ADDR_VAR 0 3
102931: PUSH
102932: LD_EXP 189
102936: PUSH
102937: LD_VAR 0 1
102941: ARRAY
102942: PPUSH
102943: CALL_OW 255
102947: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
102948: LD_ADDR_VAR 0 4
102952: PUSH
102953: LD_EXP 190
102957: PUSH
102958: LD_VAR 0 1
102962: ARRAY
102963: PUSH
102964: LD_VAR 0 2
102968: ARRAY
102969: PUSH
102970: LD_INT 1
102972: ARRAY
102973: PPUSH
102974: LD_EXP 190
102978: PUSH
102979: LD_VAR 0 1
102983: ARRAY
102984: PUSH
102985: LD_VAR 0 2
102989: ARRAY
102990: PUSH
102991: LD_INT 2
102993: ARRAY
102994: PPUSH
102995: CALL_OW 428
102999: ST_TO_ADDR
// if not tmp then
103000: LD_VAR 0 4
103004: NOT
103005: IFFALSE 103009
// continue ;
103007: GO 102924
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
103009: LD_VAR 0 4
103013: PUSH
103014: LD_INT 81
103016: PUSH
103017: LD_VAR 0 3
103021: PUSH
103022: EMPTY
103023: LIST
103024: LIST
103025: PPUSH
103026: CALL_OW 69
103030: IN
103031: PUSH
103032: LD_EXP 190
103036: PUSH
103037: LD_VAR 0 1
103041: ARRAY
103042: PUSH
103043: LD_VAR 0 2
103047: ARRAY
103048: PUSH
103049: LD_INT 1
103051: ARRAY
103052: PPUSH
103053: LD_EXP 190
103057: PUSH
103058: LD_VAR 0 1
103062: ARRAY
103063: PUSH
103064: LD_VAR 0 2
103068: ARRAY
103069: PUSH
103070: LD_INT 2
103072: ARRAY
103073: PPUSH
103074: CALL_OW 458
103078: AND
103079: IFFALSE 103173
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
103081: LD_EXP 190
103085: PUSH
103086: LD_VAR 0 1
103090: ARRAY
103091: PUSH
103092: LD_VAR 0 2
103096: ARRAY
103097: PUSH
103098: LD_INT 1
103100: ARRAY
103101: PPUSH
103102: LD_EXP 190
103106: PUSH
103107: LD_VAR 0 1
103111: ARRAY
103112: PUSH
103113: LD_VAR 0 2
103117: ARRAY
103118: PUSH
103119: LD_INT 2
103121: ARRAY
103122: PPUSH
103123: LD_VAR 0 3
103127: PPUSH
103128: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103132: LD_ADDR_EXP 190
103136: PUSH
103137: LD_EXP 190
103141: PPUSH
103142: LD_VAR 0 1
103146: PPUSH
103147: LD_EXP 190
103151: PUSH
103152: LD_VAR 0 1
103156: ARRAY
103157: PPUSH
103158: LD_VAR 0 2
103162: PPUSH
103163: CALL_OW 3
103167: PPUSH
103168: CALL_OW 1
103172: ST_TO_ADDR
// end ; end ;
103173: GO 102924
103175: POP
103176: POP
// end ;
103177: GO 102842
103179: POP
103180: POP
// end ;
103181: PPOPN 4
103183: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103184: LD_INT 0
103186: PPUSH
103187: PPUSH
// result := false ;
103188: LD_ADDR_VAR 0 4
103192: PUSH
103193: LD_INT 0
103195: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103196: LD_VAR 0 1
103200: PPUSH
103201: CALL_OW 264
103205: PUSH
103206: LD_EXP 111
103210: EQUAL
103211: NOT
103212: IFFALSE 103216
// exit ;
103214: GO 103456
// index := GetElementIndex ( minersList , unit ) ;
103216: LD_ADDR_VAR 0 5
103220: PUSH
103221: LD_EXP 189
103225: PPUSH
103226: LD_VAR 0 1
103230: PPUSH
103231: CALL 19586 0 2
103235: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103236: LD_EXP 190
103240: PUSH
103241: LD_VAR 0 5
103245: ARRAY
103246: PUSH
103247: LD_EXP 191
103251: GREATEREQUAL
103252: IFFALSE 103256
// exit ;
103254: GO 103456
// ComMoveXY ( unit , x , y ) ;
103256: LD_VAR 0 1
103260: PPUSH
103261: LD_VAR 0 2
103265: PPUSH
103266: LD_VAR 0 3
103270: PPUSH
103271: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103275: LD_INT 35
103277: PPUSH
103278: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103282: LD_VAR 0 1
103286: PPUSH
103287: LD_VAR 0 2
103291: PPUSH
103292: LD_VAR 0 3
103296: PPUSH
103297: CALL 50358 0 3
103301: NOT
103302: PUSH
103303: LD_VAR 0 1
103307: PPUSH
103308: CALL_OW 314
103312: AND
103313: IFFALSE 103317
// exit ;
103315: GO 103456
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103317: LD_VAR 0 2
103321: PPUSH
103322: LD_VAR 0 3
103326: PPUSH
103327: CALL_OW 428
103331: PUSH
103332: LD_VAR 0 1
103336: EQUAL
103337: PUSH
103338: LD_VAR 0 1
103342: PPUSH
103343: CALL_OW 314
103347: NOT
103348: AND
103349: IFFALSE 103275
// PlaySoundXY ( x , y , PlantMine ) ;
103351: LD_VAR 0 2
103355: PPUSH
103356: LD_VAR 0 3
103360: PPUSH
103361: LD_STRING PlantMine
103363: PPUSH
103364: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103368: LD_VAR 0 2
103372: PPUSH
103373: LD_VAR 0 3
103377: PPUSH
103378: LD_VAR 0 1
103382: PPUSH
103383: CALL_OW 255
103387: PPUSH
103388: LD_INT 0
103390: PPUSH
103391: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103395: LD_ADDR_EXP 190
103399: PUSH
103400: LD_EXP 190
103404: PPUSH
103405: LD_VAR 0 5
103409: PUSH
103410: LD_EXP 190
103414: PUSH
103415: LD_VAR 0 5
103419: ARRAY
103420: PUSH
103421: LD_INT 1
103423: PLUS
103424: PUSH
103425: EMPTY
103426: LIST
103427: LIST
103428: PPUSH
103429: LD_VAR 0 2
103433: PUSH
103434: LD_VAR 0 3
103438: PUSH
103439: EMPTY
103440: LIST
103441: LIST
103442: PPUSH
103443: CALL 19801 0 3
103447: ST_TO_ADDR
// result := true ;
103448: LD_ADDR_VAR 0 4
103452: PUSH
103453: LD_INT 1
103455: ST_TO_ADDR
// end ;
103456: LD_VAR 0 4
103460: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103461: LD_INT 0
103463: PPUSH
103464: PPUSH
103465: PPUSH
// if not unit in minersList then
103466: LD_VAR 0 1
103470: PUSH
103471: LD_EXP 189
103475: IN
103476: NOT
103477: IFFALSE 103481
// exit ;
103479: GO 103873
// index := GetElementIndex ( minersList , unit ) ;
103481: LD_ADDR_VAR 0 6
103485: PUSH
103486: LD_EXP 189
103490: PPUSH
103491: LD_VAR 0 1
103495: PPUSH
103496: CALL 19586 0 2
103500: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103501: LD_ADDR_VAR 0 5
103505: PUSH
103506: DOUBLE
103507: LD_EXP 190
103511: PUSH
103512: LD_VAR 0 6
103516: ARRAY
103517: INC
103518: ST_TO_ADDR
103519: LD_INT 1
103521: PUSH
103522: FOR_DOWNTO
103523: IFFALSE 103684
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103525: LD_EXP 190
103529: PUSH
103530: LD_VAR 0 6
103534: ARRAY
103535: PUSH
103536: LD_VAR 0 5
103540: ARRAY
103541: PUSH
103542: LD_INT 1
103544: ARRAY
103545: PUSH
103546: LD_VAR 0 2
103550: EQUAL
103551: PUSH
103552: LD_EXP 190
103556: PUSH
103557: LD_VAR 0 6
103561: ARRAY
103562: PUSH
103563: LD_VAR 0 5
103567: ARRAY
103568: PUSH
103569: LD_INT 2
103571: ARRAY
103572: PUSH
103573: LD_VAR 0 3
103577: EQUAL
103578: AND
103579: IFFALSE 103682
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103581: LD_EXP 190
103585: PUSH
103586: LD_VAR 0 6
103590: ARRAY
103591: PUSH
103592: LD_VAR 0 5
103596: ARRAY
103597: PUSH
103598: LD_INT 1
103600: ARRAY
103601: PPUSH
103602: LD_EXP 190
103606: PUSH
103607: LD_VAR 0 6
103611: ARRAY
103612: PUSH
103613: LD_VAR 0 5
103617: ARRAY
103618: PUSH
103619: LD_INT 2
103621: ARRAY
103622: PPUSH
103623: LD_VAR 0 1
103627: PPUSH
103628: CALL_OW 255
103632: PPUSH
103633: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103637: LD_ADDR_EXP 190
103641: PUSH
103642: LD_EXP 190
103646: PPUSH
103647: LD_VAR 0 6
103651: PPUSH
103652: LD_EXP 190
103656: PUSH
103657: LD_VAR 0 6
103661: ARRAY
103662: PPUSH
103663: LD_VAR 0 5
103667: PPUSH
103668: CALL_OW 3
103672: PPUSH
103673: CALL_OW 1
103677: ST_TO_ADDR
// exit ;
103678: POP
103679: POP
103680: GO 103873
// end ; end ;
103682: GO 103522
103684: POP
103685: POP
// for i := minerMinesList [ index ] downto 1 do
103686: LD_ADDR_VAR 0 5
103690: PUSH
103691: DOUBLE
103692: LD_EXP 190
103696: PUSH
103697: LD_VAR 0 6
103701: ARRAY
103702: INC
103703: ST_TO_ADDR
103704: LD_INT 1
103706: PUSH
103707: FOR_DOWNTO
103708: IFFALSE 103871
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
103710: LD_EXP 190
103714: PUSH
103715: LD_VAR 0 6
103719: ARRAY
103720: PUSH
103721: LD_VAR 0 5
103725: ARRAY
103726: PUSH
103727: LD_INT 1
103729: ARRAY
103730: PPUSH
103731: LD_EXP 190
103735: PUSH
103736: LD_VAR 0 6
103740: ARRAY
103741: PUSH
103742: LD_VAR 0 5
103746: ARRAY
103747: PUSH
103748: LD_INT 2
103750: ARRAY
103751: PPUSH
103752: LD_VAR 0 2
103756: PPUSH
103757: LD_VAR 0 3
103761: PPUSH
103762: CALL_OW 298
103766: PUSH
103767: LD_INT 6
103769: LESS
103770: IFFALSE 103869
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103772: LD_EXP 190
103776: PUSH
103777: LD_VAR 0 6
103781: ARRAY
103782: PUSH
103783: LD_VAR 0 5
103787: ARRAY
103788: PUSH
103789: LD_INT 1
103791: ARRAY
103792: PPUSH
103793: LD_EXP 190
103797: PUSH
103798: LD_VAR 0 6
103802: ARRAY
103803: PUSH
103804: LD_VAR 0 5
103808: ARRAY
103809: PUSH
103810: LD_INT 2
103812: ARRAY
103813: PPUSH
103814: LD_VAR 0 1
103818: PPUSH
103819: CALL_OW 255
103823: PPUSH
103824: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103828: LD_ADDR_EXP 190
103832: PUSH
103833: LD_EXP 190
103837: PPUSH
103838: LD_VAR 0 6
103842: PPUSH
103843: LD_EXP 190
103847: PUSH
103848: LD_VAR 0 6
103852: ARRAY
103853: PPUSH
103854: LD_VAR 0 5
103858: PPUSH
103859: CALL_OW 3
103863: PPUSH
103864: CALL_OW 1
103868: ST_TO_ADDR
// end ; end ;
103869: GO 103707
103871: POP
103872: POP
// end ;
103873: LD_VAR 0 4
103877: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
103878: LD_INT 0
103880: PPUSH
103881: PPUSH
103882: PPUSH
103883: PPUSH
103884: PPUSH
103885: PPUSH
103886: PPUSH
103887: PPUSH
103888: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
103889: LD_VAR 0 1
103893: PPUSH
103894: CALL_OW 264
103898: PUSH
103899: LD_EXP 111
103903: EQUAL
103904: NOT
103905: PUSH
103906: LD_VAR 0 1
103910: PUSH
103911: LD_EXP 189
103915: IN
103916: NOT
103917: OR
103918: IFFALSE 103922
// exit ;
103920: GO 104244
// index := GetElementIndex ( minersList , unit ) ;
103922: LD_ADDR_VAR 0 6
103926: PUSH
103927: LD_EXP 189
103931: PPUSH
103932: LD_VAR 0 1
103936: PPUSH
103937: CALL 19586 0 2
103941: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
103942: LD_ADDR_VAR 0 8
103946: PUSH
103947: LD_EXP 191
103951: PUSH
103952: LD_EXP 190
103956: PUSH
103957: LD_VAR 0 6
103961: ARRAY
103962: MINUS
103963: ST_TO_ADDR
// if not minesFreeAmount then
103964: LD_VAR 0 8
103968: NOT
103969: IFFALSE 103973
// exit ;
103971: GO 104244
// tmp := [ ] ;
103973: LD_ADDR_VAR 0 7
103977: PUSH
103978: EMPTY
103979: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
103980: LD_ADDR_VAR 0 5
103984: PUSH
103985: DOUBLE
103986: LD_INT 1
103988: DEC
103989: ST_TO_ADDR
103990: LD_VAR 0 8
103994: PUSH
103995: FOR_TO
103996: IFFALSE 104191
// begin _d := rand ( 0 , 5 ) ;
103998: LD_ADDR_VAR 0 11
104002: PUSH
104003: LD_INT 0
104005: PPUSH
104006: LD_INT 5
104008: PPUSH
104009: CALL_OW 12
104013: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
104014: LD_ADDR_VAR 0 12
104018: PUSH
104019: LD_INT 2
104021: PPUSH
104022: LD_INT 6
104024: PPUSH
104025: CALL_OW 12
104029: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
104030: LD_ADDR_VAR 0 9
104034: PUSH
104035: LD_VAR 0 2
104039: PPUSH
104040: LD_VAR 0 11
104044: PPUSH
104045: LD_VAR 0 12
104049: PPUSH
104050: CALL_OW 272
104054: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
104055: LD_ADDR_VAR 0 10
104059: PUSH
104060: LD_VAR 0 3
104064: PPUSH
104065: LD_VAR 0 11
104069: PPUSH
104070: LD_VAR 0 12
104074: PPUSH
104075: CALL_OW 273
104079: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
104080: LD_VAR 0 9
104084: PPUSH
104085: LD_VAR 0 10
104089: PPUSH
104090: CALL_OW 488
104094: PUSH
104095: LD_VAR 0 9
104099: PUSH
104100: LD_VAR 0 10
104104: PUSH
104105: EMPTY
104106: LIST
104107: LIST
104108: PUSH
104109: LD_VAR 0 7
104113: IN
104114: NOT
104115: AND
104116: PUSH
104117: LD_VAR 0 9
104121: PPUSH
104122: LD_VAR 0 10
104126: PPUSH
104127: CALL_OW 458
104131: NOT
104132: AND
104133: IFFALSE 104175
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104135: LD_ADDR_VAR 0 7
104139: PUSH
104140: LD_VAR 0 7
104144: PPUSH
104145: LD_VAR 0 7
104149: PUSH
104150: LD_INT 1
104152: PLUS
104153: PPUSH
104154: LD_VAR 0 9
104158: PUSH
104159: LD_VAR 0 10
104163: PUSH
104164: EMPTY
104165: LIST
104166: LIST
104167: PPUSH
104168: CALL_OW 1
104172: ST_TO_ADDR
104173: GO 104189
// i := i - 1 ;
104175: LD_ADDR_VAR 0 5
104179: PUSH
104180: LD_VAR 0 5
104184: PUSH
104185: LD_INT 1
104187: MINUS
104188: ST_TO_ADDR
// end ;
104189: GO 103995
104191: POP
104192: POP
// for i in tmp do
104193: LD_ADDR_VAR 0 5
104197: PUSH
104198: LD_VAR 0 7
104202: PUSH
104203: FOR_IN
104204: IFFALSE 104242
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104206: LD_VAR 0 1
104210: PPUSH
104211: LD_VAR 0 5
104215: PUSH
104216: LD_INT 1
104218: ARRAY
104219: PPUSH
104220: LD_VAR 0 5
104224: PUSH
104225: LD_INT 2
104227: ARRAY
104228: PPUSH
104229: CALL 103184 0 3
104233: NOT
104234: IFFALSE 104240
// exit ;
104236: POP
104237: POP
104238: GO 104244
104240: GO 104203
104242: POP
104243: POP
// end ;
104244: LD_VAR 0 4
104248: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104249: LD_INT 0
104251: PPUSH
104252: PPUSH
104253: PPUSH
104254: PPUSH
104255: PPUSH
104256: PPUSH
104257: PPUSH
// if not GetClass ( unit ) = class_sniper then
104258: LD_VAR 0 1
104262: PPUSH
104263: CALL_OW 257
104267: PUSH
104268: LD_INT 5
104270: EQUAL
104271: NOT
104272: IFFALSE 104276
// exit ;
104274: GO 104664
// dist := 8 ;
104276: LD_ADDR_VAR 0 5
104280: PUSH
104281: LD_INT 8
104283: ST_TO_ADDR
// viewRange := 12 ;
104284: LD_ADDR_VAR 0 7
104288: PUSH
104289: LD_INT 12
104291: ST_TO_ADDR
// side := GetSide ( unit ) ;
104292: LD_ADDR_VAR 0 6
104296: PUSH
104297: LD_VAR 0 1
104301: PPUSH
104302: CALL_OW 255
104306: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104307: LD_INT 61
104309: PPUSH
104310: LD_VAR 0 6
104314: PPUSH
104315: CALL_OW 321
104319: PUSH
104320: LD_INT 2
104322: EQUAL
104323: IFFALSE 104333
// viewRange := 16 ;
104325: LD_ADDR_VAR 0 7
104329: PUSH
104330: LD_INT 16
104332: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104333: LD_VAR 0 1
104337: PPUSH
104338: LD_VAR 0 2
104342: PPUSH
104343: LD_VAR 0 3
104347: PPUSH
104348: CALL_OW 297
104352: PUSH
104353: LD_VAR 0 5
104357: GREATER
104358: IFFALSE 104437
// begin ComMoveXY ( unit , x , y ) ;
104360: LD_VAR 0 1
104364: PPUSH
104365: LD_VAR 0 2
104369: PPUSH
104370: LD_VAR 0 3
104374: PPUSH
104375: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104379: LD_INT 35
104381: PPUSH
104382: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104386: LD_VAR 0 1
104390: PPUSH
104391: LD_VAR 0 2
104395: PPUSH
104396: LD_VAR 0 3
104400: PPUSH
104401: CALL 50358 0 3
104405: NOT
104406: IFFALSE 104410
// exit ;
104408: GO 104664
// until GetDistUnitXY ( unit , x , y ) < dist ;
104410: LD_VAR 0 1
104414: PPUSH
104415: LD_VAR 0 2
104419: PPUSH
104420: LD_VAR 0 3
104424: PPUSH
104425: CALL_OW 297
104429: PUSH
104430: LD_VAR 0 5
104434: LESS
104435: IFFALSE 104379
// end ; ComTurnXY ( unit , x , y ) ;
104437: LD_VAR 0 1
104441: PPUSH
104442: LD_VAR 0 2
104446: PPUSH
104447: LD_VAR 0 3
104451: PPUSH
104452: CALL_OW 118
// wait ( 5 ) ;
104456: LD_INT 5
104458: PPUSH
104459: CALL_OW 67
// _d := GetDir ( unit ) ;
104463: LD_ADDR_VAR 0 10
104467: PUSH
104468: LD_VAR 0 1
104472: PPUSH
104473: CALL_OW 254
104477: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104478: LD_ADDR_VAR 0 8
104482: PUSH
104483: LD_VAR 0 1
104487: PPUSH
104488: CALL_OW 250
104492: PPUSH
104493: LD_VAR 0 10
104497: PPUSH
104498: LD_VAR 0 5
104502: PPUSH
104503: CALL_OW 272
104507: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104508: LD_ADDR_VAR 0 9
104512: PUSH
104513: LD_VAR 0 1
104517: PPUSH
104518: CALL_OW 251
104522: PPUSH
104523: LD_VAR 0 10
104527: PPUSH
104528: LD_VAR 0 5
104532: PPUSH
104533: CALL_OW 273
104537: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104538: LD_VAR 0 8
104542: PPUSH
104543: LD_VAR 0 9
104547: PPUSH
104548: CALL_OW 488
104552: NOT
104553: IFFALSE 104557
// exit ;
104555: GO 104664
// ComAnimCustom ( unit , 1 ) ;
104557: LD_VAR 0 1
104561: PPUSH
104562: LD_INT 1
104564: PPUSH
104565: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104569: LD_VAR 0 8
104573: PPUSH
104574: LD_VAR 0 9
104578: PPUSH
104579: LD_VAR 0 6
104583: PPUSH
104584: LD_VAR 0 7
104588: PPUSH
104589: CALL_OW 330
// repeat wait ( 1 ) ;
104593: LD_INT 1
104595: PPUSH
104596: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
104600: LD_VAR 0 1
104604: PPUSH
104605: CALL_OW 316
104609: PUSH
104610: LD_VAR 0 1
104614: PPUSH
104615: CALL_OW 314
104619: OR
104620: PUSH
104621: LD_VAR 0 1
104625: PPUSH
104626: CALL_OW 302
104630: NOT
104631: OR
104632: PUSH
104633: LD_VAR 0 1
104637: PPUSH
104638: CALL_OW 301
104642: OR
104643: IFFALSE 104593
// RemoveSeeing ( _x , _y , side ) ;
104645: LD_VAR 0 8
104649: PPUSH
104650: LD_VAR 0 9
104654: PPUSH
104655: LD_VAR 0 6
104659: PPUSH
104660: CALL_OW 331
// end ; end_of_file
104664: LD_VAR 0 4
104668: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
104669: LD_INT 0
104671: PPUSH
104672: PPUSH
104673: PPUSH
104674: PPUSH
104675: PPUSH
104676: PPUSH
104677: PPUSH
104678: PPUSH
104679: PPUSH
104680: PPUSH
104681: PPUSH
104682: PPUSH
104683: PPUSH
104684: PPUSH
104685: PPUSH
104686: PPUSH
104687: PPUSH
104688: PPUSH
104689: PPUSH
104690: PPUSH
104691: PPUSH
104692: PPUSH
104693: PPUSH
104694: PPUSH
104695: PPUSH
104696: PPUSH
104697: PPUSH
104698: PPUSH
104699: PPUSH
104700: PPUSH
104701: PPUSH
104702: PPUSH
104703: PPUSH
104704: PPUSH
// if not list then
104705: LD_VAR 0 1
104709: NOT
104710: IFFALSE 104714
// exit ;
104712: GO 109373
// base := list [ 1 ] ;
104714: LD_ADDR_VAR 0 3
104718: PUSH
104719: LD_VAR 0 1
104723: PUSH
104724: LD_INT 1
104726: ARRAY
104727: ST_TO_ADDR
// group := list [ 2 ] ;
104728: LD_ADDR_VAR 0 4
104732: PUSH
104733: LD_VAR 0 1
104737: PUSH
104738: LD_INT 2
104740: ARRAY
104741: ST_TO_ADDR
// path := list [ 3 ] ;
104742: LD_ADDR_VAR 0 5
104746: PUSH
104747: LD_VAR 0 1
104751: PUSH
104752: LD_INT 3
104754: ARRAY
104755: ST_TO_ADDR
// flags := list [ 4 ] ;
104756: LD_ADDR_VAR 0 6
104760: PUSH
104761: LD_VAR 0 1
104765: PUSH
104766: LD_INT 4
104768: ARRAY
104769: ST_TO_ADDR
// mined := [ ] ;
104770: LD_ADDR_VAR 0 27
104774: PUSH
104775: EMPTY
104776: ST_TO_ADDR
// bombed := [ ] ;
104777: LD_ADDR_VAR 0 28
104781: PUSH
104782: EMPTY
104783: ST_TO_ADDR
// healers := [ ] ;
104784: LD_ADDR_VAR 0 31
104788: PUSH
104789: EMPTY
104790: ST_TO_ADDR
// to_heal := [ ] ;
104791: LD_ADDR_VAR 0 30
104795: PUSH
104796: EMPTY
104797: ST_TO_ADDR
// repairs := [ ] ;
104798: LD_ADDR_VAR 0 33
104802: PUSH
104803: EMPTY
104804: ST_TO_ADDR
// to_repair := [ ] ;
104805: LD_ADDR_VAR 0 32
104809: PUSH
104810: EMPTY
104811: ST_TO_ADDR
// if not group or not path then
104812: LD_VAR 0 4
104816: NOT
104817: PUSH
104818: LD_VAR 0 5
104822: NOT
104823: OR
104824: IFFALSE 104828
// exit ;
104826: GO 109373
// side := GetSide ( group [ 1 ] ) ;
104828: LD_ADDR_VAR 0 35
104832: PUSH
104833: LD_VAR 0 4
104837: PUSH
104838: LD_INT 1
104840: ARRAY
104841: PPUSH
104842: CALL_OW 255
104846: ST_TO_ADDR
// if flags then
104847: LD_VAR 0 6
104851: IFFALSE 104995
// begin f_ignore_area := flags [ 1 ] ;
104853: LD_ADDR_VAR 0 17
104857: PUSH
104858: LD_VAR 0 6
104862: PUSH
104863: LD_INT 1
104865: ARRAY
104866: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
104867: LD_ADDR_VAR 0 18
104871: PUSH
104872: LD_VAR 0 6
104876: PUSH
104877: LD_INT 2
104879: ARRAY
104880: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
104881: LD_ADDR_VAR 0 19
104885: PUSH
104886: LD_VAR 0 6
104890: PUSH
104891: LD_INT 3
104893: ARRAY
104894: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
104895: LD_ADDR_VAR 0 20
104899: PUSH
104900: LD_VAR 0 6
104904: PUSH
104905: LD_INT 4
104907: ARRAY
104908: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
104909: LD_ADDR_VAR 0 21
104913: PUSH
104914: LD_VAR 0 6
104918: PUSH
104919: LD_INT 5
104921: ARRAY
104922: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
104923: LD_ADDR_VAR 0 22
104927: PUSH
104928: LD_VAR 0 6
104932: PUSH
104933: LD_INT 6
104935: ARRAY
104936: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
104937: LD_ADDR_VAR 0 23
104941: PUSH
104942: LD_VAR 0 6
104946: PUSH
104947: LD_INT 7
104949: ARRAY
104950: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
104951: LD_ADDR_VAR 0 24
104955: PUSH
104956: LD_VAR 0 6
104960: PUSH
104961: LD_INT 8
104963: ARRAY
104964: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
104965: LD_ADDR_VAR 0 25
104969: PUSH
104970: LD_VAR 0 6
104974: PUSH
104975: LD_INT 9
104977: ARRAY
104978: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
104979: LD_ADDR_VAR 0 26
104983: PUSH
104984: LD_VAR 0 6
104988: PUSH
104989: LD_INT 10
104991: ARRAY
104992: ST_TO_ADDR
// end else
104993: GO 105075
// begin f_ignore_area := false ;
104995: LD_ADDR_VAR 0 17
104999: PUSH
105000: LD_INT 0
105002: ST_TO_ADDR
// f_capture := false ;
105003: LD_ADDR_VAR 0 18
105007: PUSH
105008: LD_INT 0
105010: ST_TO_ADDR
// f_ignore_civ := false ;
105011: LD_ADDR_VAR 0 19
105015: PUSH
105016: LD_INT 0
105018: ST_TO_ADDR
// f_murder := false ;
105019: LD_ADDR_VAR 0 20
105023: PUSH
105024: LD_INT 0
105026: ST_TO_ADDR
// f_mines := false ;
105027: LD_ADDR_VAR 0 21
105031: PUSH
105032: LD_INT 0
105034: ST_TO_ADDR
// f_repair := false ;
105035: LD_ADDR_VAR 0 22
105039: PUSH
105040: LD_INT 0
105042: ST_TO_ADDR
// f_heal := false ;
105043: LD_ADDR_VAR 0 23
105047: PUSH
105048: LD_INT 0
105050: ST_TO_ADDR
// f_spacetime := false ;
105051: LD_ADDR_VAR 0 24
105055: PUSH
105056: LD_INT 0
105058: ST_TO_ADDR
// f_attack_depot := false ;
105059: LD_ADDR_VAR 0 25
105063: PUSH
105064: LD_INT 0
105066: ST_TO_ADDR
// f_crawl := false ;
105067: LD_ADDR_VAR 0 26
105071: PUSH
105072: LD_INT 0
105074: ST_TO_ADDR
// end ; if f_heal then
105075: LD_VAR 0 23
105079: IFFALSE 105106
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
105081: LD_ADDR_VAR 0 31
105085: PUSH
105086: LD_VAR 0 4
105090: PPUSH
105091: LD_INT 25
105093: PUSH
105094: LD_INT 4
105096: PUSH
105097: EMPTY
105098: LIST
105099: LIST
105100: PPUSH
105101: CALL_OW 72
105105: ST_TO_ADDR
// if f_repair then
105106: LD_VAR 0 22
105110: IFFALSE 105137
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105112: LD_ADDR_VAR 0 33
105116: PUSH
105117: LD_VAR 0 4
105121: PPUSH
105122: LD_INT 25
105124: PUSH
105125: LD_INT 3
105127: PUSH
105128: EMPTY
105129: LIST
105130: LIST
105131: PPUSH
105132: CALL_OW 72
105136: ST_TO_ADDR
// units_path := [ ] ;
105137: LD_ADDR_VAR 0 16
105141: PUSH
105142: EMPTY
105143: ST_TO_ADDR
// for i = 1 to group do
105144: LD_ADDR_VAR 0 7
105148: PUSH
105149: DOUBLE
105150: LD_INT 1
105152: DEC
105153: ST_TO_ADDR
105154: LD_VAR 0 4
105158: PUSH
105159: FOR_TO
105160: IFFALSE 105189
// units_path := Replace ( units_path , i , path ) ;
105162: LD_ADDR_VAR 0 16
105166: PUSH
105167: LD_VAR 0 16
105171: PPUSH
105172: LD_VAR 0 7
105176: PPUSH
105177: LD_VAR 0 5
105181: PPUSH
105182: CALL_OW 1
105186: ST_TO_ADDR
105187: GO 105159
105189: POP
105190: POP
// repeat for i = group downto 1 do
105191: LD_ADDR_VAR 0 7
105195: PUSH
105196: DOUBLE
105197: LD_VAR 0 4
105201: INC
105202: ST_TO_ADDR
105203: LD_INT 1
105205: PUSH
105206: FOR_DOWNTO
105207: IFFALSE 109329
// begin wait ( 5 ) ;
105209: LD_INT 5
105211: PPUSH
105212: CALL_OW 67
// tmp := [ ] ;
105216: LD_ADDR_VAR 0 14
105220: PUSH
105221: EMPTY
105222: ST_TO_ADDR
// attacking := false ;
105223: LD_ADDR_VAR 0 29
105227: PUSH
105228: LD_INT 0
105230: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105231: LD_VAR 0 4
105235: PUSH
105236: LD_VAR 0 7
105240: ARRAY
105241: PPUSH
105242: CALL_OW 301
105246: PUSH
105247: LD_VAR 0 4
105251: PUSH
105252: LD_VAR 0 7
105256: ARRAY
105257: NOT
105258: OR
105259: IFFALSE 105368
// begin if GetType ( group [ i ] ) = unit_human then
105261: LD_VAR 0 4
105265: PUSH
105266: LD_VAR 0 7
105270: ARRAY
105271: PPUSH
105272: CALL_OW 247
105276: PUSH
105277: LD_INT 1
105279: EQUAL
105280: IFFALSE 105326
// begin to_heal := to_heal diff group [ i ] ;
105282: LD_ADDR_VAR 0 30
105286: PUSH
105287: LD_VAR 0 30
105291: PUSH
105292: LD_VAR 0 4
105296: PUSH
105297: LD_VAR 0 7
105301: ARRAY
105302: DIFF
105303: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105304: LD_ADDR_VAR 0 31
105308: PUSH
105309: LD_VAR 0 31
105313: PUSH
105314: LD_VAR 0 4
105318: PUSH
105319: LD_VAR 0 7
105323: ARRAY
105324: DIFF
105325: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105326: LD_ADDR_VAR 0 4
105330: PUSH
105331: LD_VAR 0 4
105335: PPUSH
105336: LD_VAR 0 7
105340: PPUSH
105341: CALL_OW 3
105345: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105346: LD_ADDR_VAR 0 16
105350: PUSH
105351: LD_VAR 0 16
105355: PPUSH
105356: LD_VAR 0 7
105360: PPUSH
105361: CALL_OW 3
105365: ST_TO_ADDR
// continue ;
105366: GO 105206
// end ; if f_repair then
105368: LD_VAR 0 22
105372: IFFALSE 105861
// begin if GetType ( group [ i ] ) = unit_vehicle then
105374: LD_VAR 0 4
105378: PUSH
105379: LD_VAR 0 7
105383: ARRAY
105384: PPUSH
105385: CALL_OW 247
105389: PUSH
105390: LD_INT 2
105392: EQUAL
105393: IFFALSE 105583
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105395: LD_VAR 0 4
105399: PUSH
105400: LD_VAR 0 7
105404: ARRAY
105405: PPUSH
105406: CALL_OW 256
105410: PUSH
105411: LD_INT 700
105413: LESS
105414: PUSH
105415: LD_VAR 0 4
105419: PUSH
105420: LD_VAR 0 7
105424: ARRAY
105425: PUSH
105426: LD_VAR 0 32
105430: IN
105431: NOT
105432: AND
105433: IFFALSE 105457
// to_repair := to_repair union group [ i ] ;
105435: LD_ADDR_VAR 0 32
105439: PUSH
105440: LD_VAR 0 32
105444: PUSH
105445: LD_VAR 0 4
105449: PUSH
105450: LD_VAR 0 7
105454: ARRAY
105455: UNION
105456: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105457: LD_VAR 0 4
105461: PUSH
105462: LD_VAR 0 7
105466: ARRAY
105467: PPUSH
105468: CALL_OW 256
105472: PUSH
105473: LD_INT 1000
105475: EQUAL
105476: PUSH
105477: LD_VAR 0 4
105481: PUSH
105482: LD_VAR 0 7
105486: ARRAY
105487: PUSH
105488: LD_VAR 0 32
105492: IN
105493: AND
105494: IFFALSE 105518
// to_repair := to_repair diff group [ i ] ;
105496: LD_ADDR_VAR 0 32
105500: PUSH
105501: LD_VAR 0 32
105505: PUSH
105506: LD_VAR 0 4
105510: PUSH
105511: LD_VAR 0 7
105515: ARRAY
105516: DIFF
105517: ST_TO_ADDR
// if group [ i ] in to_repair then
105518: LD_VAR 0 4
105522: PUSH
105523: LD_VAR 0 7
105527: ARRAY
105528: PUSH
105529: LD_VAR 0 32
105533: IN
105534: IFFALSE 105581
// begin if not IsInArea ( group [ i ] , f_repair ) then
105536: LD_VAR 0 4
105540: PUSH
105541: LD_VAR 0 7
105545: ARRAY
105546: PPUSH
105547: LD_VAR 0 22
105551: PPUSH
105552: CALL_OW 308
105556: NOT
105557: IFFALSE 105579
// ComMoveToArea ( group [ i ] , f_repair ) ;
105559: LD_VAR 0 4
105563: PUSH
105564: LD_VAR 0 7
105568: ARRAY
105569: PPUSH
105570: LD_VAR 0 22
105574: PPUSH
105575: CALL_OW 113
// continue ;
105579: GO 105206
// end ; end else
105581: GO 105861
// if group [ i ] in repairs then
105583: LD_VAR 0 4
105587: PUSH
105588: LD_VAR 0 7
105592: ARRAY
105593: PUSH
105594: LD_VAR 0 33
105598: IN
105599: IFFALSE 105861
// begin if IsInUnit ( group [ i ] ) then
105601: LD_VAR 0 4
105605: PUSH
105606: LD_VAR 0 7
105610: ARRAY
105611: PPUSH
105612: CALL_OW 310
105616: IFFALSE 105684
// begin z := IsInUnit ( group [ i ] ) ;
105618: LD_ADDR_VAR 0 13
105622: PUSH
105623: LD_VAR 0 4
105627: PUSH
105628: LD_VAR 0 7
105632: ARRAY
105633: PPUSH
105634: CALL_OW 310
105638: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
105639: LD_VAR 0 13
105643: PUSH
105644: LD_VAR 0 32
105648: IN
105649: PUSH
105650: LD_VAR 0 13
105654: PPUSH
105655: LD_VAR 0 22
105659: PPUSH
105660: CALL_OW 308
105664: AND
105665: IFFALSE 105682
// ComExitVehicle ( group [ i ] ) ;
105667: LD_VAR 0 4
105671: PUSH
105672: LD_VAR 0 7
105676: ARRAY
105677: PPUSH
105678: CALL_OW 121
// end else
105682: GO 105861
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
105684: LD_ADDR_VAR 0 13
105688: PUSH
105689: LD_VAR 0 4
105693: PPUSH
105694: LD_INT 95
105696: PUSH
105697: LD_VAR 0 22
105701: PUSH
105702: EMPTY
105703: LIST
105704: LIST
105705: PUSH
105706: LD_INT 58
105708: PUSH
105709: EMPTY
105710: LIST
105711: PUSH
105712: EMPTY
105713: LIST
105714: LIST
105715: PPUSH
105716: CALL_OW 72
105720: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
105721: LD_VAR 0 4
105725: PUSH
105726: LD_VAR 0 7
105730: ARRAY
105731: PPUSH
105732: CALL_OW 314
105736: NOT
105737: IFFALSE 105859
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
105739: LD_ADDR_VAR 0 10
105743: PUSH
105744: LD_VAR 0 13
105748: PPUSH
105749: LD_VAR 0 4
105753: PUSH
105754: LD_VAR 0 7
105758: ARRAY
105759: PPUSH
105760: CALL_OW 74
105764: ST_TO_ADDR
// if not x then
105765: LD_VAR 0 10
105769: NOT
105770: IFFALSE 105774
// continue ;
105772: GO 105206
// if GetLives ( x ) < 1000 then
105774: LD_VAR 0 10
105778: PPUSH
105779: CALL_OW 256
105783: PUSH
105784: LD_INT 1000
105786: LESS
105787: IFFALSE 105811
// ComRepairVehicle ( group [ i ] , x ) else
105789: LD_VAR 0 4
105793: PUSH
105794: LD_VAR 0 7
105798: ARRAY
105799: PPUSH
105800: LD_VAR 0 10
105804: PPUSH
105805: CALL_OW 129
105809: GO 105859
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
105811: LD_VAR 0 23
105815: PUSH
105816: LD_VAR 0 4
105820: PUSH
105821: LD_VAR 0 7
105825: ARRAY
105826: PPUSH
105827: CALL_OW 256
105831: PUSH
105832: LD_INT 1000
105834: LESS
105835: AND
105836: NOT
105837: IFFALSE 105859
// ComEnterUnit ( group [ i ] , x ) ;
105839: LD_VAR 0 4
105843: PUSH
105844: LD_VAR 0 7
105848: ARRAY
105849: PPUSH
105850: LD_VAR 0 10
105854: PPUSH
105855: CALL_OW 120
// end ; continue ;
105859: GO 105206
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
105861: LD_VAR 0 23
105865: PUSH
105866: LD_VAR 0 4
105870: PUSH
105871: LD_VAR 0 7
105875: ARRAY
105876: PPUSH
105877: CALL_OW 247
105881: PUSH
105882: LD_INT 1
105884: EQUAL
105885: AND
105886: IFFALSE 106364
// begin if group [ i ] in healers then
105888: LD_VAR 0 4
105892: PUSH
105893: LD_VAR 0 7
105897: ARRAY
105898: PUSH
105899: LD_VAR 0 31
105903: IN
105904: IFFALSE 106177
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
105906: LD_VAR 0 4
105910: PUSH
105911: LD_VAR 0 7
105915: ARRAY
105916: PPUSH
105917: LD_VAR 0 23
105921: PPUSH
105922: CALL_OW 308
105926: NOT
105927: PUSH
105928: LD_VAR 0 4
105932: PUSH
105933: LD_VAR 0 7
105937: ARRAY
105938: PPUSH
105939: CALL_OW 314
105943: NOT
105944: AND
105945: IFFALSE 105969
// ComMoveToArea ( group [ i ] , f_heal ) else
105947: LD_VAR 0 4
105951: PUSH
105952: LD_VAR 0 7
105956: ARRAY
105957: PPUSH
105958: LD_VAR 0 23
105962: PPUSH
105963: CALL_OW 113
105967: GO 106175
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
105969: LD_VAR 0 4
105973: PUSH
105974: LD_VAR 0 7
105978: ARRAY
105979: PPUSH
105980: CALL 48881 0 1
105984: PPUSH
105985: CALL_OW 256
105989: PUSH
105990: LD_INT 1000
105992: EQUAL
105993: IFFALSE 106012
// ComStop ( group [ i ] ) else
105995: LD_VAR 0 4
105999: PUSH
106000: LD_VAR 0 7
106004: ARRAY
106005: PPUSH
106006: CALL_OW 141
106010: GO 106175
// if not HasTask ( group [ i ] ) and to_heal then
106012: LD_VAR 0 4
106016: PUSH
106017: LD_VAR 0 7
106021: ARRAY
106022: PPUSH
106023: CALL_OW 314
106027: NOT
106028: PUSH
106029: LD_VAR 0 30
106033: AND
106034: IFFALSE 106175
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
106036: LD_ADDR_VAR 0 13
106040: PUSH
106041: LD_VAR 0 30
106045: PPUSH
106046: LD_INT 3
106048: PUSH
106049: LD_INT 54
106051: PUSH
106052: EMPTY
106053: LIST
106054: PUSH
106055: EMPTY
106056: LIST
106057: LIST
106058: PPUSH
106059: CALL_OW 72
106063: PPUSH
106064: LD_VAR 0 4
106068: PUSH
106069: LD_VAR 0 7
106073: ARRAY
106074: PPUSH
106075: CALL_OW 74
106079: ST_TO_ADDR
// if z then
106080: LD_VAR 0 13
106084: IFFALSE 106175
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
106086: LD_INT 91
106088: PUSH
106089: LD_VAR 0 13
106093: PUSH
106094: LD_INT 10
106096: PUSH
106097: EMPTY
106098: LIST
106099: LIST
106100: LIST
106101: PUSH
106102: LD_INT 81
106104: PUSH
106105: LD_VAR 0 13
106109: PPUSH
106110: CALL_OW 255
106114: PUSH
106115: EMPTY
106116: LIST
106117: LIST
106118: PUSH
106119: EMPTY
106120: LIST
106121: LIST
106122: PPUSH
106123: CALL_OW 69
106127: PUSH
106128: LD_INT 0
106130: EQUAL
106131: IFFALSE 106155
// ComHeal ( group [ i ] , z ) else
106133: LD_VAR 0 4
106137: PUSH
106138: LD_VAR 0 7
106142: ARRAY
106143: PPUSH
106144: LD_VAR 0 13
106148: PPUSH
106149: CALL_OW 128
106153: GO 106175
// ComMoveToArea ( group [ i ] , f_heal ) ;
106155: LD_VAR 0 4
106159: PUSH
106160: LD_VAR 0 7
106164: ARRAY
106165: PPUSH
106166: LD_VAR 0 23
106170: PPUSH
106171: CALL_OW 113
// end ; continue ;
106175: GO 105206
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106177: LD_VAR 0 4
106181: PUSH
106182: LD_VAR 0 7
106186: ARRAY
106187: PPUSH
106188: CALL_OW 256
106192: PUSH
106193: LD_INT 700
106195: LESS
106196: PUSH
106197: LD_VAR 0 4
106201: PUSH
106202: LD_VAR 0 7
106206: ARRAY
106207: PUSH
106208: LD_VAR 0 30
106212: IN
106213: NOT
106214: AND
106215: IFFALSE 106239
// to_heal := to_heal union group [ i ] ;
106217: LD_ADDR_VAR 0 30
106221: PUSH
106222: LD_VAR 0 30
106226: PUSH
106227: LD_VAR 0 4
106231: PUSH
106232: LD_VAR 0 7
106236: ARRAY
106237: UNION
106238: ST_TO_ADDR
// if group [ i ] in to_heal then
106239: LD_VAR 0 4
106243: PUSH
106244: LD_VAR 0 7
106248: ARRAY
106249: PUSH
106250: LD_VAR 0 30
106254: IN
106255: IFFALSE 106364
// begin if GetLives ( group [ i ] ) = 1000 then
106257: LD_VAR 0 4
106261: PUSH
106262: LD_VAR 0 7
106266: ARRAY
106267: PPUSH
106268: CALL_OW 256
106272: PUSH
106273: LD_INT 1000
106275: EQUAL
106276: IFFALSE 106302
// to_heal := to_heal diff group [ i ] else
106278: LD_ADDR_VAR 0 30
106282: PUSH
106283: LD_VAR 0 30
106287: PUSH
106288: LD_VAR 0 4
106292: PUSH
106293: LD_VAR 0 7
106297: ARRAY
106298: DIFF
106299: ST_TO_ADDR
106300: GO 106364
// begin if not IsInArea ( group [ i ] , to_heal ) then
106302: LD_VAR 0 4
106306: PUSH
106307: LD_VAR 0 7
106311: ARRAY
106312: PPUSH
106313: LD_VAR 0 30
106317: PPUSH
106318: CALL_OW 308
106322: NOT
106323: IFFALSE 106347
// ComMoveToArea ( group [ i ] , f_heal ) else
106325: LD_VAR 0 4
106329: PUSH
106330: LD_VAR 0 7
106334: ARRAY
106335: PPUSH
106336: LD_VAR 0 23
106340: PPUSH
106341: CALL_OW 113
106345: GO 106362
// ComHold ( group [ i ] ) ;
106347: LD_VAR 0 4
106351: PUSH
106352: LD_VAR 0 7
106356: ARRAY
106357: PPUSH
106358: CALL_OW 140
// continue ;
106362: GO 105206
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106364: LD_VAR 0 4
106368: PUSH
106369: LD_VAR 0 7
106373: ARRAY
106374: PPUSH
106375: LD_INT 10
106377: PPUSH
106378: CALL 47301 0 2
106382: NOT
106383: PUSH
106384: LD_VAR 0 16
106388: PUSH
106389: LD_VAR 0 7
106393: ARRAY
106394: PUSH
106395: EMPTY
106396: EQUAL
106397: NOT
106398: AND
106399: IFFALSE 106665
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106401: LD_VAR 0 4
106405: PUSH
106406: LD_VAR 0 7
106410: ARRAY
106411: PPUSH
106412: CALL_OW 262
106416: PUSH
106417: LD_INT 1
106419: PUSH
106420: LD_INT 2
106422: PUSH
106423: EMPTY
106424: LIST
106425: LIST
106426: IN
106427: IFFALSE 106468
// if GetFuel ( group [ i ] ) < 10 then
106429: LD_VAR 0 4
106433: PUSH
106434: LD_VAR 0 7
106438: ARRAY
106439: PPUSH
106440: CALL_OW 261
106444: PUSH
106445: LD_INT 10
106447: LESS
106448: IFFALSE 106468
// SetFuel ( group [ i ] , 12 ) ;
106450: LD_VAR 0 4
106454: PUSH
106455: LD_VAR 0 7
106459: ARRAY
106460: PPUSH
106461: LD_INT 12
106463: PPUSH
106464: CALL_OW 240
// if units_path [ i ] then
106468: LD_VAR 0 16
106472: PUSH
106473: LD_VAR 0 7
106477: ARRAY
106478: IFFALSE 106663
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106480: LD_VAR 0 4
106484: PUSH
106485: LD_VAR 0 7
106489: ARRAY
106490: PPUSH
106491: LD_VAR 0 16
106495: PUSH
106496: LD_VAR 0 7
106500: ARRAY
106501: PUSH
106502: LD_INT 1
106504: ARRAY
106505: PUSH
106506: LD_INT 1
106508: ARRAY
106509: PPUSH
106510: LD_VAR 0 16
106514: PUSH
106515: LD_VAR 0 7
106519: ARRAY
106520: PUSH
106521: LD_INT 1
106523: ARRAY
106524: PUSH
106525: LD_INT 2
106527: ARRAY
106528: PPUSH
106529: CALL_OW 297
106533: PUSH
106534: LD_INT 6
106536: GREATER
106537: IFFALSE 106612
// begin if not HasTask ( group [ i ] ) then
106539: LD_VAR 0 4
106543: PUSH
106544: LD_VAR 0 7
106548: ARRAY
106549: PPUSH
106550: CALL_OW 314
106554: NOT
106555: IFFALSE 106610
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106557: LD_VAR 0 4
106561: PUSH
106562: LD_VAR 0 7
106566: ARRAY
106567: PPUSH
106568: LD_VAR 0 16
106572: PUSH
106573: LD_VAR 0 7
106577: ARRAY
106578: PUSH
106579: LD_INT 1
106581: ARRAY
106582: PUSH
106583: LD_INT 1
106585: ARRAY
106586: PPUSH
106587: LD_VAR 0 16
106591: PUSH
106592: LD_VAR 0 7
106596: ARRAY
106597: PUSH
106598: LD_INT 1
106600: ARRAY
106601: PUSH
106602: LD_INT 2
106604: ARRAY
106605: PPUSH
106606: CALL_OW 114
// end else
106610: GO 106663
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
106612: LD_ADDR_VAR 0 15
106616: PUSH
106617: LD_VAR 0 16
106621: PUSH
106622: LD_VAR 0 7
106626: ARRAY
106627: PPUSH
106628: LD_INT 1
106630: PPUSH
106631: CALL_OW 3
106635: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
106636: LD_ADDR_VAR 0 16
106640: PUSH
106641: LD_VAR 0 16
106645: PPUSH
106646: LD_VAR 0 7
106650: PPUSH
106651: LD_VAR 0 15
106655: PPUSH
106656: CALL_OW 1
106660: ST_TO_ADDR
// continue ;
106661: GO 105206
// end ; end ; end else
106663: GO 109327
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
106665: LD_ADDR_VAR 0 14
106669: PUSH
106670: LD_INT 81
106672: PUSH
106673: LD_VAR 0 4
106677: PUSH
106678: LD_VAR 0 7
106682: ARRAY
106683: PPUSH
106684: CALL_OW 255
106688: PUSH
106689: EMPTY
106690: LIST
106691: LIST
106692: PPUSH
106693: CALL_OW 69
106697: ST_TO_ADDR
// if not tmp then
106698: LD_VAR 0 14
106702: NOT
106703: IFFALSE 106707
// continue ;
106705: GO 105206
// if f_ignore_area then
106707: LD_VAR 0 17
106711: IFFALSE 106799
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
106713: LD_ADDR_VAR 0 15
106717: PUSH
106718: LD_VAR 0 14
106722: PPUSH
106723: LD_INT 3
106725: PUSH
106726: LD_INT 92
106728: PUSH
106729: LD_VAR 0 17
106733: PUSH
106734: LD_INT 1
106736: ARRAY
106737: PUSH
106738: LD_VAR 0 17
106742: PUSH
106743: LD_INT 2
106745: ARRAY
106746: PUSH
106747: LD_VAR 0 17
106751: PUSH
106752: LD_INT 3
106754: ARRAY
106755: PUSH
106756: EMPTY
106757: LIST
106758: LIST
106759: LIST
106760: LIST
106761: PUSH
106762: EMPTY
106763: LIST
106764: LIST
106765: PPUSH
106766: CALL_OW 72
106770: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106771: LD_VAR 0 14
106775: PUSH
106776: LD_VAR 0 15
106780: DIFF
106781: IFFALSE 106799
// tmp := tmp diff tmp2 ;
106783: LD_ADDR_VAR 0 14
106787: PUSH
106788: LD_VAR 0 14
106792: PUSH
106793: LD_VAR 0 15
106797: DIFF
106798: ST_TO_ADDR
// end ; if not f_murder then
106799: LD_VAR 0 20
106803: NOT
106804: IFFALSE 106862
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
106806: LD_ADDR_VAR 0 15
106810: PUSH
106811: LD_VAR 0 14
106815: PPUSH
106816: LD_INT 3
106818: PUSH
106819: LD_INT 50
106821: PUSH
106822: EMPTY
106823: LIST
106824: PUSH
106825: EMPTY
106826: LIST
106827: LIST
106828: PPUSH
106829: CALL_OW 72
106833: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106834: LD_VAR 0 14
106838: PUSH
106839: LD_VAR 0 15
106843: DIFF
106844: IFFALSE 106862
// tmp := tmp diff tmp2 ;
106846: LD_ADDR_VAR 0 14
106850: PUSH
106851: LD_VAR 0 14
106855: PUSH
106856: LD_VAR 0 15
106860: DIFF
106861: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
106862: LD_ADDR_VAR 0 14
106866: PUSH
106867: LD_VAR 0 4
106871: PUSH
106872: LD_VAR 0 7
106876: ARRAY
106877: PPUSH
106878: LD_VAR 0 14
106882: PPUSH
106883: LD_INT 1
106885: PPUSH
106886: LD_INT 1
106888: PPUSH
106889: CALL 20236 0 4
106893: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
106894: LD_VAR 0 4
106898: PUSH
106899: LD_VAR 0 7
106903: ARRAY
106904: PPUSH
106905: CALL_OW 257
106909: PUSH
106910: LD_INT 1
106912: EQUAL
106913: IFFALSE 107361
// begin if WantPlant ( group [ i ] ) then
106915: LD_VAR 0 4
106919: PUSH
106920: LD_VAR 0 7
106924: ARRAY
106925: PPUSH
106926: CALL 19737 0 1
106930: IFFALSE 106934
// continue ;
106932: GO 105206
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
106934: LD_VAR 0 18
106938: PUSH
106939: LD_VAR 0 4
106943: PUSH
106944: LD_VAR 0 7
106948: ARRAY
106949: PPUSH
106950: CALL_OW 310
106954: NOT
106955: AND
106956: PUSH
106957: LD_VAR 0 14
106961: PUSH
106962: LD_INT 1
106964: ARRAY
106965: PUSH
106966: LD_VAR 0 14
106970: PPUSH
106971: LD_INT 21
106973: PUSH
106974: LD_INT 2
106976: PUSH
106977: EMPTY
106978: LIST
106979: LIST
106980: PUSH
106981: LD_INT 58
106983: PUSH
106984: EMPTY
106985: LIST
106986: PUSH
106987: EMPTY
106988: LIST
106989: LIST
106990: PPUSH
106991: CALL_OW 72
106995: IN
106996: AND
106997: IFFALSE 107033
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
106999: LD_VAR 0 4
107003: PUSH
107004: LD_VAR 0 7
107008: ARRAY
107009: PPUSH
107010: LD_VAR 0 14
107014: PUSH
107015: LD_INT 1
107017: ARRAY
107018: PPUSH
107019: CALL_OW 120
// attacking := true ;
107023: LD_ADDR_VAR 0 29
107027: PUSH
107028: LD_INT 1
107030: ST_TO_ADDR
// continue ;
107031: GO 105206
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
107033: LD_VAR 0 26
107037: PUSH
107038: LD_VAR 0 4
107042: PUSH
107043: LD_VAR 0 7
107047: ARRAY
107048: PPUSH
107049: CALL_OW 257
107053: PUSH
107054: LD_INT 1
107056: EQUAL
107057: AND
107058: PUSH
107059: LD_VAR 0 4
107063: PUSH
107064: LD_VAR 0 7
107068: ARRAY
107069: PPUSH
107070: CALL_OW 256
107074: PUSH
107075: LD_INT 800
107077: LESS
107078: AND
107079: PUSH
107080: LD_VAR 0 4
107084: PUSH
107085: LD_VAR 0 7
107089: ARRAY
107090: PPUSH
107091: CALL_OW 318
107095: NOT
107096: AND
107097: IFFALSE 107114
// ComCrawl ( group [ i ] ) ;
107099: LD_VAR 0 4
107103: PUSH
107104: LD_VAR 0 7
107108: ARRAY
107109: PPUSH
107110: CALL_OW 137
// if f_mines then
107114: LD_VAR 0 21
107118: IFFALSE 107361
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107120: LD_VAR 0 14
107124: PUSH
107125: LD_INT 1
107127: ARRAY
107128: PPUSH
107129: CALL_OW 247
107133: PUSH
107134: LD_INT 3
107136: EQUAL
107137: PUSH
107138: LD_VAR 0 14
107142: PUSH
107143: LD_INT 1
107145: ARRAY
107146: PUSH
107147: LD_VAR 0 27
107151: IN
107152: NOT
107153: AND
107154: IFFALSE 107361
// begin x := GetX ( tmp [ 1 ] ) ;
107156: LD_ADDR_VAR 0 10
107160: PUSH
107161: LD_VAR 0 14
107165: PUSH
107166: LD_INT 1
107168: ARRAY
107169: PPUSH
107170: CALL_OW 250
107174: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107175: LD_ADDR_VAR 0 11
107179: PUSH
107180: LD_VAR 0 14
107184: PUSH
107185: LD_INT 1
107187: ARRAY
107188: PPUSH
107189: CALL_OW 251
107193: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107194: LD_ADDR_VAR 0 12
107198: PUSH
107199: LD_VAR 0 4
107203: PUSH
107204: LD_VAR 0 7
107208: ARRAY
107209: PPUSH
107210: CALL 47386 0 1
107214: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107215: LD_VAR 0 4
107219: PUSH
107220: LD_VAR 0 7
107224: ARRAY
107225: PPUSH
107226: LD_VAR 0 10
107230: PPUSH
107231: LD_VAR 0 11
107235: PPUSH
107236: LD_VAR 0 14
107240: PUSH
107241: LD_INT 1
107243: ARRAY
107244: PPUSH
107245: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107249: LD_VAR 0 4
107253: PUSH
107254: LD_VAR 0 7
107258: ARRAY
107259: PPUSH
107260: LD_VAR 0 10
107264: PPUSH
107265: LD_VAR 0 12
107269: PPUSH
107270: LD_INT 7
107272: PPUSH
107273: CALL_OW 272
107277: PPUSH
107278: LD_VAR 0 11
107282: PPUSH
107283: LD_VAR 0 12
107287: PPUSH
107288: LD_INT 7
107290: PPUSH
107291: CALL_OW 273
107295: PPUSH
107296: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107300: LD_VAR 0 4
107304: PUSH
107305: LD_VAR 0 7
107309: ARRAY
107310: PPUSH
107311: LD_INT 71
107313: PPUSH
107314: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107318: LD_ADDR_VAR 0 27
107322: PUSH
107323: LD_VAR 0 27
107327: PPUSH
107328: LD_VAR 0 27
107332: PUSH
107333: LD_INT 1
107335: PLUS
107336: PPUSH
107337: LD_VAR 0 14
107341: PUSH
107342: LD_INT 1
107344: ARRAY
107345: PPUSH
107346: CALL_OW 1
107350: ST_TO_ADDR
// attacking := true ;
107351: LD_ADDR_VAR 0 29
107355: PUSH
107356: LD_INT 1
107358: ST_TO_ADDR
// continue ;
107359: GO 105206
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107361: LD_VAR 0 4
107365: PUSH
107366: LD_VAR 0 7
107370: ARRAY
107371: PPUSH
107372: CALL_OW 257
107376: PUSH
107377: LD_INT 17
107379: EQUAL
107380: PUSH
107381: LD_VAR 0 4
107385: PUSH
107386: LD_VAR 0 7
107390: ARRAY
107391: PPUSH
107392: CALL_OW 110
107396: PUSH
107397: LD_INT 71
107399: EQUAL
107400: NOT
107401: AND
107402: IFFALSE 107548
// begin attacking := false ;
107404: LD_ADDR_VAR 0 29
107408: PUSH
107409: LD_INT 0
107411: ST_TO_ADDR
// k := 5 ;
107412: LD_ADDR_VAR 0 9
107416: PUSH
107417: LD_INT 5
107419: ST_TO_ADDR
// if tmp < k then
107420: LD_VAR 0 14
107424: PUSH
107425: LD_VAR 0 9
107429: LESS
107430: IFFALSE 107442
// k := tmp ;
107432: LD_ADDR_VAR 0 9
107436: PUSH
107437: LD_VAR 0 14
107441: ST_TO_ADDR
// for j = 1 to k do
107442: LD_ADDR_VAR 0 8
107446: PUSH
107447: DOUBLE
107448: LD_INT 1
107450: DEC
107451: ST_TO_ADDR
107452: LD_VAR 0 9
107456: PUSH
107457: FOR_TO
107458: IFFALSE 107546
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107460: LD_VAR 0 14
107464: PUSH
107465: LD_VAR 0 8
107469: ARRAY
107470: PUSH
107471: LD_VAR 0 14
107475: PPUSH
107476: LD_INT 58
107478: PUSH
107479: EMPTY
107480: LIST
107481: PPUSH
107482: CALL_OW 72
107486: IN
107487: NOT
107488: IFFALSE 107544
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107490: LD_VAR 0 4
107494: PUSH
107495: LD_VAR 0 7
107499: ARRAY
107500: PPUSH
107501: LD_VAR 0 14
107505: PUSH
107506: LD_VAR 0 8
107510: ARRAY
107511: PPUSH
107512: CALL_OW 115
// attacking := true ;
107516: LD_ADDR_VAR 0 29
107520: PUSH
107521: LD_INT 1
107523: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107524: LD_VAR 0 4
107528: PUSH
107529: LD_VAR 0 7
107533: ARRAY
107534: PPUSH
107535: LD_INT 71
107537: PPUSH
107538: CALL_OW 109
// continue ;
107542: GO 107457
// end ; end ;
107544: GO 107457
107546: POP
107547: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107548: LD_VAR 0 4
107552: PUSH
107553: LD_VAR 0 7
107557: ARRAY
107558: PPUSH
107559: CALL_OW 257
107563: PUSH
107564: LD_INT 8
107566: EQUAL
107567: PUSH
107568: LD_VAR 0 4
107572: PUSH
107573: LD_VAR 0 7
107577: ARRAY
107578: PPUSH
107579: CALL_OW 264
107583: PUSH
107584: LD_INT 28
107586: PUSH
107587: LD_INT 45
107589: PUSH
107590: LD_INT 7
107592: PUSH
107593: LD_INT 47
107595: PUSH
107596: EMPTY
107597: LIST
107598: LIST
107599: LIST
107600: LIST
107601: IN
107602: OR
107603: IFFALSE 107859
// begin attacking := false ;
107605: LD_ADDR_VAR 0 29
107609: PUSH
107610: LD_INT 0
107612: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
107613: LD_VAR 0 14
107617: PUSH
107618: LD_INT 1
107620: ARRAY
107621: PPUSH
107622: CALL_OW 266
107626: PUSH
107627: LD_INT 32
107629: PUSH
107630: LD_INT 31
107632: PUSH
107633: LD_INT 33
107635: PUSH
107636: LD_INT 4
107638: PUSH
107639: LD_INT 5
107641: PUSH
107642: EMPTY
107643: LIST
107644: LIST
107645: LIST
107646: LIST
107647: LIST
107648: IN
107649: IFFALSE 107835
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
107651: LD_ADDR_VAR 0 9
107655: PUSH
107656: LD_VAR 0 14
107660: PUSH
107661: LD_INT 1
107663: ARRAY
107664: PPUSH
107665: CALL_OW 266
107669: PPUSH
107670: LD_VAR 0 14
107674: PUSH
107675: LD_INT 1
107677: ARRAY
107678: PPUSH
107679: CALL_OW 250
107683: PPUSH
107684: LD_VAR 0 14
107688: PUSH
107689: LD_INT 1
107691: ARRAY
107692: PPUSH
107693: CALL_OW 251
107697: PPUSH
107698: LD_VAR 0 14
107702: PUSH
107703: LD_INT 1
107705: ARRAY
107706: PPUSH
107707: CALL_OW 254
107711: PPUSH
107712: LD_VAR 0 14
107716: PUSH
107717: LD_INT 1
107719: ARRAY
107720: PPUSH
107721: CALL_OW 248
107725: PPUSH
107726: LD_INT 0
107728: PPUSH
107729: CALL 28756 0 6
107733: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
107734: LD_ADDR_VAR 0 8
107738: PUSH
107739: LD_VAR 0 4
107743: PUSH
107744: LD_VAR 0 7
107748: ARRAY
107749: PPUSH
107750: LD_VAR 0 9
107754: PPUSH
107755: CALL 47426 0 2
107759: ST_TO_ADDR
// if j then
107760: LD_VAR 0 8
107764: IFFALSE 107833
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
107766: LD_VAR 0 8
107770: PUSH
107771: LD_INT 1
107773: ARRAY
107774: PPUSH
107775: LD_VAR 0 8
107779: PUSH
107780: LD_INT 2
107782: ARRAY
107783: PPUSH
107784: CALL_OW 488
107788: IFFALSE 107833
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
107790: LD_VAR 0 4
107794: PUSH
107795: LD_VAR 0 7
107799: ARRAY
107800: PPUSH
107801: LD_VAR 0 8
107805: PUSH
107806: LD_INT 1
107808: ARRAY
107809: PPUSH
107810: LD_VAR 0 8
107814: PUSH
107815: LD_INT 2
107817: ARRAY
107818: PPUSH
107819: CALL_OW 116
// attacking := true ;
107823: LD_ADDR_VAR 0 29
107827: PUSH
107828: LD_INT 1
107830: ST_TO_ADDR
// continue ;
107831: GO 105206
// end ; end else
107833: GO 107859
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107835: LD_VAR 0 4
107839: PUSH
107840: LD_VAR 0 7
107844: ARRAY
107845: PPUSH
107846: LD_VAR 0 14
107850: PUSH
107851: LD_INT 1
107853: ARRAY
107854: PPUSH
107855: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
107859: LD_VAR 0 4
107863: PUSH
107864: LD_VAR 0 7
107868: ARRAY
107869: PPUSH
107870: CALL_OW 265
107874: PUSH
107875: LD_INT 11
107877: EQUAL
107878: IFFALSE 108156
// begin k := 10 ;
107880: LD_ADDR_VAR 0 9
107884: PUSH
107885: LD_INT 10
107887: ST_TO_ADDR
// x := 0 ;
107888: LD_ADDR_VAR 0 10
107892: PUSH
107893: LD_INT 0
107895: ST_TO_ADDR
// if tmp < k then
107896: LD_VAR 0 14
107900: PUSH
107901: LD_VAR 0 9
107905: LESS
107906: IFFALSE 107918
// k := tmp ;
107908: LD_ADDR_VAR 0 9
107912: PUSH
107913: LD_VAR 0 14
107917: ST_TO_ADDR
// for j = k downto 1 do
107918: LD_ADDR_VAR 0 8
107922: PUSH
107923: DOUBLE
107924: LD_VAR 0 9
107928: INC
107929: ST_TO_ADDR
107930: LD_INT 1
107932: PUSH
107933: FOR_DOWNTO
107934: IFFALSE 108009
// begin if GetType ( tmp [ j ] ) = unit_human then
107936: LD_VAR 0 14
107940: PUSH
107941: LD_VAR 0 8
107945: ARRAY
107946: PPUSH
107947: CALL_OW 247
107951: PUSH
107952: LD_INT 1
107954: EQUAL
107955: IFFALSE 108007
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
107957: LD_VAR 0 4
107961: PUSH
107962: LD_VAR 0 7
107966: ARRAY
107967: PPUSH
107968: LD_VAR 0 14
107972: PUSH
107973: LD_VAR 0 8
107977: ARRAY
107978: PPUSH
107979: CALL 47697 0 2
// x := tmp [ j ] ;
107983: LD_ADDR_VAR 0 10
107987: PUSH
107988: LD_VAR 0 14
107992: PUSH
107993: LD_VAR 0 8
107997: ARRAY
107998: ST_TO_ADDR
// attacking := true ;
107999: LD_ADDR_VAR 0 29
108003: PUSH
108004: LD_INT 1
108006: ST_TO_ADDR
// end ; end ;
108007: GO 107933
108009: POP
108010: POP
// if not x then
108011: LD_VAR 0 10
108015: NOT
108016: IFFALSE 108156
// begin attacking := true ;
108018: LD_ADDR_VAR 0 29
108022: PUSH
108023: LD_INT 1
108025: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
108026: LD_VAR 0 4
108030: PUSH
108031: LD_VAR 0 7
108035: ARRAY
108036: PPUSH
108037: CALL_OW 250
108041: PPUSH
108042: LD_VAR 0 4
108046: PUSH
108047: LD_VAR 0 7
108051: ARRAY
108052: PPUSH
108053: CALL_OW 251
108057: PPUSH
108058: CALL_OW 546
108062: PUSH
108063: LD_INT 2
108065: ARRAY
108066: PUSH
108067: LD_VAR 0 14
108071: PUSH
108072: LD_INT 1
108074: ARRAY
108075: PPUSH
108076: CALL_OW 250
108080: PPUSH
108081: LD_VAR 0 14
108085: PUSH
108086: LD_INT 1
108088: ARRAY
108089: PPUSH
108090: CALL_OW 251
108094: PPUSH
108095: CALL_OW 546
108099: PUSH
108100: LD_INT 2
108102: ARRAY
108103: EQUAL
108104: IFFALSE 108132
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
108106: LD_VAR 0 4
108110: PUSH
108111: LD_VAR 0 7
108115: ARRAY
108116: PPUSH
108117: LD_VAR 0 14
108121: PUSH
108122: LD_INT 1
108124: ARRAY
108125: PPUSH
108126: CALL 47697 0 2
108130: GO 108156
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108132: LD_VAR 0 4
108136: PUSH
108137: LD_VAR 0 7
108141: ARRAY
108142: PPUSH
108143: LD_VAR 0 14
108147: PUSH
108148: LD_INT 1
108150: ARRAY
108151: PPUSH
108152: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108156: LD_VAR 0 4
108160: PUSH
108161: LD_VAR 0 7
108165: ARRAY
108166: PPUSH
108167: CALL_OW 264
108171: PUSH
108172: LD_INT 29
108174: EQUAL
108175: IFFALSE 108541
// begin if WantsToAttack ( group [ i ] ) in bombed then
108177: LD_VAR 0 4
108181: PUSH
108182: LD_VAR 0 7
108186: ARRAY
108187: PPUSH
108188: CALL_OW 319
108192: PUSH
108193: LD_VAR 0 28
108197: IN
108198: IFFALSE 108202
// continue ;
108200: GO 105206
// k := 8 ;
108202: LD_ADDR_VAR 0 9
108206: PUSH
108207: LD_INT 8
108209: ST_TO_ADDR
// x := 0 ;
108210: LD_ADDR_VAR 0 10
108214: PUSH
108215: LD_INT 0
108217: ST_TO_ADDR
// if tmp < k then
108218: LD_VAR 0 14
108222: PUSH
108223: LD_VAR 0 9
108227: LESS
108228: IFFALSE 108240
// k := tmp ;
108230: LD_ADDR_VAR 0 9
108234: PUSH
108235: LD_VAR 0 14
108239: ST_TO_ADDR
// for j = 1 to k do
108240: LD_ADDR_VAR 0 8
108244: PUSH
108245: DOUBLE
108246: LD_INT 1
108248: DEC
108249: ST_TO_ADDR
108250: LD_VAR 0 9
108254: PUSH
108255: FOR_TO
108256: IFFALSE 108388
// begin if GetType ( tmp [ j ] ) = unit_building then
108258: LD_VAR 0 14
108262: PUSH
108263: LD_VAR 0 8
108267: ARRAY
108268: PPUSH
108269: CALL_OW 247
108273: PUSH
108274: LD_INT 3
108276: EQUAL
108277: IFFALSE 108386
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108279: LD_VAR 0 14
108283: PUSH
108284: LD_VAR 0 8
108288: ARRAY
108289: PUSH
108290: LD_VAR 0 28
108294: IN
108295: NOT
108296: PUSH
108297: LD_VAR 0 14
108301: PUSH
108302: LD_VAR 0 8
108306: ARRAY
108307: PPUSH
108308: CALL_OW 313
108312: AND
108313: IFFALSE 108386
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108315: LD_VAR 0 4
108319: PUSH
108320: LD_VAR 0 7
108324: ARRAY
108325: PPUSH
108326: LD_VAR 0 14
108330: PUSH
108331: LD_VAR 0 8
108335: ARRAY
108336: PPUSH
108337: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108341: LD_ADDR_VAR 0 28
108345: PUSH
108346: LD_VAR 0 28
108350: PPUSH
108351: LD_VAR 0 28
108355: PUSH
108356: LD_INT 1
108358: PLUS
108359: PPUSH
108360: LD_VAR 0 14
108364: PUSH
108365: LD_VAR 0 8
108369: ARRAY
108370: PPUSH
108371: CALL_OW 1
108375: ST_TO_ADDR
// attacking := true ;
108376: LD_ADDR_VAR 0 29
108380: PUSH
108381: LD_INT 1
108383: ST_TO_ADDR
// break ;
108384: GO 108388
// end ; end ;
108386: GO 108255
108388: POP
108389: POP
// if not attacking and f_attack_depot then
108390: LD_VAR 0 29
108394: NOT
108395: PUSH
108396: LD_VAR 0 25
108400: AND
108401: IFFALSE 108496
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108403: LD_ADDR_VAR 0 13
108407: PUSH
108408: LD_VAR 0 14
108412: PPUSH
108413: LD_INT 2
108415: PUSH
108416: LD_INT 30
108418: PUSH
108419: LD_INT 0
108421: PUSH
108422: EMPTY
108423: LIST
108424: LIST
108425: PUSH
108426: LD_INT 30
108428: PUSH
108429: LD_INT 1
108431: PUSH
108432: EMPTY
108433: LIST
108434: LIST
108435: PUSH
108436: EMPTY
108437: LIST
108438: LIST
108439: LIST
108440: PPUSH
108441: CALL_OW 72
108445: ST_TO_ADDR
// if z then
108446: LD_VAR 0 13
108450: IFFALSE 108496
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108452: LD_VAR 0 4
108456: PUSH
108457: LD_VAR 0 7
108461: ARRAY
108462: PPUSH
108463: LD_VAR 0 13
108467: PPUSH
108468: LD_VAR 0 4
108472: PUSH
108473: LD_VAR 0 7
108477: ARRAY
108478: PPUSH
108479: CALL_OW 74
108483: PPUSH
108484: CALL_OW 115
// attacking := true ;
108488: LD_ADDR_VAR 0 29
108492: PUSH
108493: LD_INT 1
108495: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108496: LD_VAR 0 4
108500: PUSH
108501: LD_VAR 0 7
108505: ARRAY
108506: PPUSH
108507: CALL_OW 256
108511: PUSH
108512: LD_INT 500
108514: LESS
108515: IFFALSE 108541
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108517: LD_VAR 0 4
108521: PUSH
108522: LD_VAR 0 7
108526: ARRAY
108527: PPUSH
108528: LD_VAR 0 14
108532: PUSH
108533: LD_INT 1
108535: ARRAY
108536: PPUSH
108537: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108541: LD_VAR 0 4
108545: PUSH
108546: LD_VAR 0 7
108550: ARRAY
108551: PPUSH
108552: CALL_OW 264
108556: PUSH
108557: LD_INT 49
108559: EQUAL
108560: IFFALSE 108681
// begin if not HasTask ( group [ i ] ) then
108562: LD_VAR 0 4
108566: PUSH
108567: LD_VAR 0 7
108571: ARRAY
108572: PPUSH
108573: CALL_OW 314
108577: NOT
108578: IFFALSE 108681
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
108580: LD_ADDR_VAR 0 9
108584: PUSH
108585: LD_INT 81
108587: PUSH
108588: LD_VAR 0 4
108592: PUSH
108593: LD_VAR 0 7
108597: ARRAY
108598: PPUSH
108599: CALL_OW 255
108603: PUSH
108604: EMPTY
108605: LIST
108606: LIST
108607: PPUSH
108608: CALL_OW 69
108612: PPUSH
108613: LD_VAR 0 4
108617: PUSH
108618: LD_VAR 0 7
108622: ARRAY
108623: PPUSH
108624: CALL_OW 74
108628: ST_TO_ADDR
// if k then
108629: LD_VAR 0 9
108633: IFFALSE 108681
// if GetDistUnits ( group [ i ] , k ) > 10 then
108635: LD_VAR 0 4
108639: PUSH
108640: LD_VAR 0 7
108644: ARRAY
108645: PPUSH
108646: LD_VAR 0 9
108650: PPUSH
108651: CALL_OW 296
108655: PUSH
108656: LD_INT 10
108658: GREATER
108659: IFFALSE 108681
// ComMoveUnit ( group [ i ] , k ) ;
108661: LD_VAR 0 4
108665: PUSH
108666: LD_VAR 0 7
108670: ARRAY
108671: PPUSH
108672: LD_VAR 0 9
108676: PPUSH
108677: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
108681: LD_VAR 0 4
108685: PUSH
108686: LD_VAR 0 7
108690: ARRAY
108691: PPUSH
108692: CALL_OW 256
108696: PUSH
108697: LD_INT 250
108699: LESS
108700: PUSH
108701: LD_VAR 0 4
108705: PUSH
108706: LD_VAR 0 7
108710: ARRAY
108711: PUSH
108712: LD_INT 21
108714: PUSH
108715: LD_INT 2
108717: PUSH
108718: EMPTY
108719: LIST
108720: LIST
108721: PUSH
108722: LD_INT 23
108724: PUSH
108725: LD_INT 2
108727: PUSH
108728: EMPTY
108729: LIST
108730: LIST
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: PPUSH
108736: CALL_OW 69
108740: IN
108741: AND
108742: IFFALSE 108867
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
108744: LD_ADDR_VAR 0 9
108748: PUSH
108749: LD_OWVAR 3
108753: PUSH
108754: LD_VAR 0 4
108758: PUSH
108759: LD_VAR 0 7
108763: ARRAY
108764: DIFF
108765: PPUSH
108766: LD_VAR 0 4
108770: PUSH
108771: LD_VAR 0 7
108775: ARRAY
108776: PPUSH
108777: CALL_OW 74
108781: ST_TO_ADDR
// if not k then
108782: LD_VAR 0 9
108786: NOT
108787: IFFALSE 108791
// continue ;
108789: GO 105206
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
108791: LD_VAR 0 9
108795: PUSH
108796: LD_INT 81
108798: PUSH
108799: LD_VAR 0 4
108803: PUSH
108804: LD_VAR 0 7
108808: ARRAY
108809: PPUSH
108810: CALL_OW 255
108814: PUSH
108815: EMPTY
108816: LIST
108817: LIST
108818: PPUSH
108819: CALL_OW 69
108823: IN
108824: PUSH
108825: LD_VAR 0 9
108829: PPUSH
108830: LD_VAR 0 4
108834: PUSH
108835: LD_VAR 0 7
108839: ARRAY
108840: PPUSH
108841: CALL_OW 296
108845: PUSH
108846: LD_INT 5
108848: LESS
108849: AND
108850: IFFALSE 108867
// ComAutodestruct ( group [ i ] ) ;
108852: LD_VAR 0 4
108856: PUSH
108857: LD_VAR 0 7
108861: ARRAY
108862: PPUSH
108863: CALL 47595 0 1
// end ; if f_attack_depot then
108867: LD_VAR 0 25
108871: IFFALSE 108983
// begin k := 6 ;
108873: LD_ADDR_VAR 0 9
108877: PUSH
108878: LD_INT 6
108880: ST_TO_ADDR
// if tmp < k then
108881: LD_VAR 0 14
108885: PUSH
108886: LD_VAR 0 9
108890: LESS
108891: IFFALSE 108903
// k := tmp ;
108893: LD_ADDR_VAR 0 9
108897: PUSH
108898: LD_VAR 0 14
108902: ST_TO_ADDR
// for j = 1 to k do
108903: LD_ADDR_VAR 0 8
108907: PUSH
108908: DOUBLE
108909: LD_INT 1
108911: DEC
108912: ST_TO_ADDR
108913: LD_VAR 0 9
108917: PUSH
108918: FOR_TO
108919: IFFALSE 108981
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
108921: LD_VAR 0 8
108925: PPUSH
108926: CALL_OW 266
108930: PUSH
108931: LD_INT 0
108933: PUSH
108934: LD_INT 1
108936: PUSH
108937: EMPTY
108938: LIST
108939: LIST
108940: IN
108941: IFFALSE 108979
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108943: LD_VAR 0 4
108947: PUSH
108948: LD_VAR 0 7
108952: ARRAY
108953: PPUSH
108954: LD_VAR 0 14
108958: PUSH
108959: LD_VAR 0 8
108963: ARRAY
108964: PPUSH
108965: CALL_OW 115
// attacking := true ;
108969: LD_ADDR_VAR 0 29
108973: PUSH
108974: LD_INT 1
108976: ST_TO_ADDR
// break ;
108977: GO 108981
// end ;
108979: GO 108918
108981: POP
108982: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
108983: LD_VAR 0 4
108987: PUSH
108988: LD_VAR 0 7
108992: ARRAY
108993: PPUSH
108994: CALL_OW 302
108998: PUSH
108999: LD_VAR 0 29
109003: NOT
109004: AND
109005: IFFALSE 109327
// begin if GetTag ( group [ i ] ) = 71 then
109007: LD_VAR 0 4
109011: PUSH
109012: LD_VAR 0 7
109016: ARRAY
109017: PPUSH
109018: CALL_OW 110
109022: PUSH
109023: LD_INT 71
109025: EQUAL
109026: IFFALSE 109067
// begin if HasTask ( group [ i ] ) then
109028: LD_VAR 0 4
109032: PUSH
109033: LD_VAR 0 7
109037: ARRAY
109038: PPUSH
109039: CALL_OW 314
109043: IFFALSE 109049
// continue else
109045: GO 105206
109047: GO 109067
// SetTag ( group [ i ] , 0 ) ;
109049: LD_VAR 0 4
109053: PUSH
109054: LD_VAR 0 7
109058: ARRAY
109059: PPUSH
109060: LD_INT 0
109062: PPUSH
109063: CALL_OW 109
// end ; k := 8 ;
109067: LD_ADDR_VAR 0 9
109071: PUSH
109072: LD_INT 8
109074: ST_TO_ADDR
// x := 0 ;
109075: LD_ADDR_VAR 0 10
109079: PUSH
109080: LD_INT 0
109082: ST_TO_ADDR
// if tmp < k then
109083: LD_VAR 0 14
109087: PUSH
109088: LD_VAR 0 9
109092: LESS
109093: IFFALSE 109105
// k := tmp ;
109095: LD_ADDR_VAR 0 9
109099: PUSH
109100: LD_VAR 0 14
109104: ST_TO_ADDR
// for j = 1 to k do
109105: LD_ADDR_VAR 0 8
109109: PUSH
109110: DOUBLE
109111: LD_INT 1
109113: DEC
109114: ST_TO_ADDR
109115: LD_VAR 0 9
109119: PUSH
109120: FOR_TO
109121: IFFALSE 109219
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109123: LD_VAR 0 14
109127: PUSH
109128: LD_VAR 0 8
109132: ARRAY
109133: PPUSH
109134: CALL_OW 247
109138: PUSH
109139: LD_INT 1
109141: EQUAL
109142: PUSH
109143: LD_VAR 0 14
109147: PUSH
109148: LD_VAR 0 8
109152: ARRAY
109153: PPUSH
109154: CALL_OW 256
109158: PUSH
109159: LD_INT 250
109161: LESS
109162: PUSH
109163: LD_VAR 0 20
109167: AND
109168: PUSH
109169: LD_VAR 0 20
109173: NOT
109174: PUSH
109175: LD_VAR 0 14
109179: PUSH
109180: LD_VAR 0 8
109184: ARRAY
109185: PPUSH
109186: CALL_OW 256
109190: PUSH
109191: LD_INT 250
109193: GREATEREQUAL
109194: AND
109195: OR
109196: AND
109197: IFFALSE 109217
// begin x := tmp [ j ] ;
109199: LD_ADDR_VAR 0 10
109203: PUSH
109204: LD_VAR 0 14
109208: PUSH
109209: LD_VAR 0 8
109213: ARRAY
109214: ST_TO_ADDR
// break ;
109215: GO 109219
// end ;
109217: GO 109120
109219: POP
109220: POP
// if x then
109221: LD_VAR 0 10
109225: IFFALSE 109249
// ComAttackUnit ( group [ i ] , x ) else
109227: LD_VAR 0 4
109231: PUSH
109232: LD_VAR 0 7
109236: ARRAY
109237: PPUSH
109238: LD_VAR 0 10
109242: PPUSH
109243: CALL_OW 115
109247: GO 109273
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109249: LD_VAR 0 4
109253: PUSH
109254: LD_VAR 0 7
109258: ARRAY
109259: PPUSH
109260: LD_VAR 0 14
109264: PUSH
109265: LD_INT 1
109267: ARRAY
109268: PPUSH
109269: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109273: LD_VAR 0 4
109277: PUSH
109278: LD_VAR 0 7
109282: ARRAY
109283: PPUSH
109284: CALL_OW 314
109288: NOT
109289: IFFALSE 109327
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109291: LD_VAR 0 4
109295: PUSH
109296: LD_VAR 0 7
109300: ARRAY
109301: PPUSH
109302: LD_VAR 0 14
109306: PPUSH
109307: LD_VAR 0 4
109311: PUSH
109312: LD_VAR 0 7
109316: ARRAY
109317: PPUSH
109318: CALL_OW 74
109322: PPUSH
109323: CALL_OW 115
// end ; end ; end ;
109327: GO 105206
109329: POP
109330: POP
// wait ( 0 0$2 ) ;
109331: LD_INT 70
109333: PPUSH
109334: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109338: LD_VAR 0 4
109342: NOT
109343: PUSH
109344: LD_VAR 0 4
109348: PUSH
109349: EMPTY
109350: EQUAL
109351: OR
109352: PUSH
109353: LD_INT 81
109355: PUSH
109356: LD_VAR 0 35
109360: PUSH
109361: EMPTY
109362: LIST
109363: LIST
109364: PPUSH
109365: CALL_OW 69
109369: NOT
109370: OR
109371: IFFALSE 105191
// end ;
109373: LD_VAR 0 2
109377: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
109378: LD_INT 0
109380: PPUSH
109381: PPUSH
109382: PPUSH
109383: PPUSH
109384: PPUSH
109385: PPUSH
// if not base or not mc_bases [ base ] or not solds then
109386: LD_VAR 0 1
109390: NOT
109391: PUSH
109392: LD_EXP 60
109396: PUSH
109397: LD_VAR 0 1
109401: ARRAY
109402: NOT
109403: OR
109404: PUSH
109405: LD_VAR 0 2
109409: NOT
109410: OR
109411: IFFALSE 109415
// exit ;
109413: GO 109969
// side := mc_sides [ base ] ;
109415: LD_ADDR_VAR 0 6
109419: PUSH
109420: LD_EXP 86
109424: PUSH
109425: LD_VAR 0 1
109429: ARRAY
109430: ST_TO_ADDR
// if not side then
109431: LD_VAR 0 6
109435: NOT
109436: IFFALSE 109440
// exit ;
109438: GO 109969
// for i in solds do
109440: LD_ADDR_VAR 0 7
109444: PUSH
109445: LD_VAR 0 2
109449: PUSH
109450: FOR_IN
109451: IFFALSE 109512
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109453: LD_VAR 0 7
109457: PPUSH
109458: CALL_OW 310
109462: PPUSH
109463: CALL_OW 266
109467: PUSH
109468: LD_INT 32
109470: PUSH
109471: LD_INT 31
109473: PUSH
109474: EMPTY
109475: LIST
109476: LIST
109477: IN
109478: IFFALSE 109498
// solds := solds diff i else
109480: LD_ADDR_VAR 0 2
109484: PUSH
109485: LD_VAR 0 2
109489: PUSH
109490: LD_VAR 0 7
109494: DIFF
109495: ST_TO_ADDR
109496: GO 109510
// SetTag ( i , 18 ) ;
109498: LD_VAR 0 7
109502: PPUSH
109503: LD_INT 18
109505: PPUSH
109506: CALL_OW 109
109510: GO 109450
109512: POP
109513: POP
// if not solds then
109514: LD_VAR 0 2
109518: NOT
109519: IFFALSE 109523
// exit ;
109521: GO 109969
// repeat wait ( 0 0$2 ) ;
109523: LD_INT 70
109525: PPUSH
109526: CALL_OW 67
// enemy := mc_scan [ base ] ;
109530: LD_ADDR_VAR 0 4
109534: PUSH
109535: LD_EXP 83
109539: PUSH
109540: LD_VAR 0 1
109544: ARRAY
109545: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109546: LD_EXP 60
109550: PUSH
109551: LD_VAR 0 1
109555: ARRAY
109556: NOT
109557: PUSH
109558: LD_EXP 60
109562: PUSH
109563: LD_VAR 0 1
109567: ARRAY
109568: PUSH
109569: EMPTY
109570: EQUAL
109571: OR
109572: IFFALSE 109609
// begin for i in solds do
109574: LD_ADDR_VAR 0 7
109578: PUSH
109579: LD_VAR 0 2
109583: PUSH
109584: FOR_IN
109585: IFFALSE 109598
// ComStop ( i ) ;
109587: LD_VAR 0 7
109591: PPUSH
109592: CALL_OW 141
109596: GO 109584
109598: POP
109599: POP
// solds := [ ] ;
109600: LD_ADDR_VAR 0 2
109604: PUSH
109605: EMPTY
109606: ST_TO_ADDR
// exit ;
109607: GO 109969
// end ; for i in solds do
109609: LD_ADDR_VAR 0 7
109613: PUSH
109614: LD_VAR 0 2
109618: PUSH
109619: FOR_IN
109620: IFFALSE 109941
// begin if IsInUnit ( i ) then
109622: LD_VAR 0 7
109626: PPUSH
109627: CALL_OW 310
109631: IFFALSE 109642
// ComExitBuilding ( i ) ;
109633: LD_VAR 0 7
109637: PPUSH
109638: CALL_OW 122
// if GetLives ( i ) > 500 then
109642: LD_VAR 0 7
109646: PPUSH
109647: CALL_OW 256
109651: PUSH
109652: LD_INT 500
109654: GREATER
109655: IFFALSE 109708
// begin e := NearestUnitToUnit ( enemy , i ) ;
109657: LD_ADDR_VAR 0 5
109661: PUSH
109662: LD_VAR 0 4
109666: PPUSH
109667: LD_VAR 0 7
109671: PPUSH
109672: CALL_OW 74
109676: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
109677: LD_VAR 0 7
109681: PPUSH
109682: LD_VAR 0 5
109686: PPUSH
109687: CALL_OW 250
109691: PPUSH
109692: LD_VAR 0 5
109696: PPUSH
109697: CALL_OW 251
109701: PPUSH
109702: CALL_OW 114
// end else
109706: GO 109939
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
109708: LD_VAR 0 7
109712: PPUSH
109713: LD_EXP 60
109717: PUSH
109718: LD_VAR 0 1
109722: ARRAY
109723: PPUSH
109724: LD_INT 2
109726: PUSH
109727: LD_INT 30
109729: PUSH
109730: LD_INT 0
109732: PUSH
109733: EMPTY
109734: LIST
109735: LIST
109736: PUSH
109737: LD_INT 30
109739: PUSH
109740: LD_INT 1
109742: PUSH
109743: EMPTY
109744: LIST
109745: LIST
109746: PUSH
109747: LD_INT 30
109749: PUSH
109750: LD_INT 6
109752: PUSH
109753: EMPTY
109754: LIST
109755: LIST
109756: PUSH
109757: EMPTY
109758: LIST
109759: LIST
109760: LIST
109761: LIST
109762: PPUSH
109763: CALL_OW 72
109767: PPUSH
109768: LD_VAR 0 7
109772: PPUSH
109773: CALL_OW 74
109777: PPUSH
109778: CALL_OW 296
109782: PUSH
109783: LD_INT 10
109785: GREATER
109786: IFFALSE 109939
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
109788: LD_ADDR_VAR 0 8
109792: PUSH
109793: LD_EXP 60
109797: PUSH
109798: LD_VAR 0 1
109802: ARRAY
109803: PPUSH
109804: LD_INT 2
109806: PUSH
109807: LD_INT 30
109809: PUSH
109810: LD_INT 0
109812: PUSH
109813: EMPTY
109814: LIST
109815: LIST
109816: PUSH
109817: LD_INT 30
109819: PUSH
109820: LD_INT 1
109822: PUSH
109823: EMPTY
109824: LIST
109825: LIST
109826: PUSH
109827: LD_INT 30
109829: PUSH
109830: LD_INT 6
109832: PUSH
109833: EMPTY
109834: LIST
109835: LIST
109836: PUSH
109837: EMPTY
109838: LIST
109839: LIST
109840: LIST
109841: LIST
109842: PPUSH
109843: CALL_OW 72
109847: PPUSH
109848: LD_VAR 0 7
109852: PPUSH
109853: CALL_OW 74
109857: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
109858: LD_VAR 0 7
109862: PPUSH
109863: LD_VAR 0 8
109867: PPUSH
109868: CALL_OW 250
109872: PPUSH
109873: LD_INT 3
109875: PPUSH
109876: LD_INT 5
109878: PPUSH
109879: CALL_OW 272
109883: PPUSH
109884: LD_VAR 0 8
109888: PPUSH
109889: CALL_OW 251
109893: PPUSH
109894: LD_INT 3
109896: PPUSH
109897: LD_INT 5
109899: PPUSH
109900: CALL_OW 273
109904: PPUSH
109905: CALL_OW 111
// SetTag ( i , 0 ) ;
109909: LD_VAR 0 7
109913: PPUSH
109914: LD_INT 0
109916: PPUSH
109917: CALL_OW 109
// solds := solds diff i ;
109921: LD_ADDR_VAR 0 2
109925: PUSH
109926: LD_VAR 0 2
109930: PUSH
109931: LD_VAR 0 7
109935: DIFF
109936: ST_TO_ADDR
// continue ;
109937: GO 109619
// end ; end ;
109939: GO 109619
109941: POP
109942: POP
// until not solds or not enemy ;
109943: LD_VAR 0 2
109947: NOT
109948: PUSH
109949: LD_VAR 0 4
109953: NOT
109954: OR
109955: IFFALSE 109523
// MC_Reset ( base , 18 ) ;
109957: LD_VAR 0 1
109961: PPUSH
109962: LD_INT 18
109964: PPUSH
109965: CALL 59060 0 2
// end ;
109969: LD_VAR 0 3
109973: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
109974: LD_INT 0
109976: PPUSH
109977: PPUSH
109978: PPUSH
109979: PPUSH
109980: PPUSH
109981: PPUSH
109982: PPUSH
109983: PPUSH
109984: PPUSH
109985: PPUSH
109986: PPUSH
109987: PPUSH
109988: PPUSH
109989: PPUSH
109990: PPUSH
109991: PPUSH
109992: PPUSH
109993: PPUSH
109994: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
109995: LD_ADDR_VAR 0 12
109999: PUSH
110000: LD_EXP 60
110004: PUSH
110005: LD_VAR 0 1
110009: ARRAY
110010: PPUSH
110011: LD_INT 25
110013: PUSH
110014: LD_INT 3
110016: PUSH
110017: EMPTY
110018: LIST
110019: LIST
110020: PPUSH
110021: CALL_OW 72
110025: ST_TO_ADDR
// if mc_remote_driver [ base ] then
110026: LD_EXP 100
110030: PUSH
110031: LD_VAR 0 1
110035: ARRAY
110036: IFFALSE 110060
// mechs := mechs diff mc_remote_driver [ base ] ;
110038: LD_ADDR_VAR 0 12
110042: PUSH
110043: LD_VAR 0 12
110047: PUSH
110048: LD_EXP 100
110052: PUSH
110053: LD_VAR 0 1
110057: ARRAY
110058: DIFF
110059: ST_TO_ADDR
// for i in mechs do
110060: LD_ADDR_VAR 0 4
110064: PUSH
110065: LD_VAR 0 12
110069: PUSH
110070: FOR_IN
110071: IFFALSE 110106
// if GetTag ( i ) > 0 then
110073: LD_VAR 0 4
110077: PPUSH
110078: CALL_OW 110
110082: PUSH
110083: LD_INT 0
110085: GREATER
110086: IFFALSE 110104
// mechs := mechs diff i ;
110088: LD_ADDR_VAR 0 12
110092: PUSH
110093: LD_VAR 0 12
110097: PUSH
110098: LD_VAR 0 4
110102: DIFF
110103: ST_TO_ADDR
110104: GO 110070
110106: POP
110107: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110108: LD_ADDR_VAR 0 8
110112: PUSH
110113: LD_EXP 60
110117: PUSH
110118: LD_VAR 0 1
110122: ARRAY
110123: PPUSH
110124: LD_INT 2
110126: PUSH
110127: LD_INT 25
110129: PUSH
110130: LD_INT 1
110132: PUSH
110133: EMPTY
110134: LIST
110135: LIST
110136: PUSH
110137: LD_INT 25
110139: PUSH
110140: LD_INT 5
110142: PUSH
110143: EMPTY
110144: LIST
110145: LIST
110146: PUSH
110147: LD_INT 25
110149: PUSH
110150: LD_INT 8
110152: PUSH
110153: EMPTY
110154: LIST
110155: LIST
110156: PUSH
110157: LD_INT 25
110159: PUSH
110160: LD_INT 9
110162: PUSH
110163: EMPTY
110164: LIST
110165: LIST
110166: PUSH
110167: EMPTY
110168: LIST
110169: LIST
110170: LIST
110171: LIST
110172: LIST
110173: PPUSH
110174: CALL_OW 72
110178: ST_TO_ADDR
// if not defenders and not solds then
110179: LD_VAR 0 2
110183: NOT
110184: PUSH
110185: LD_VAR 0 8
110189: NOT
110190: AND
110191: IFFALSE 110195
// exit ;
110193: GO 111965
// depot_under_attack := false ;
110195: LD_ADDR_VAR 0 16
110199: PUSH
110200: LD_INT 0
110202: ST_TO_ADDR
// sold_defenders := [ ] ;
110203: LD_ADDR_VAR 0 17
110207: PUSH
110208: EMPTY
110209: ST_TO_ADDR
// if mechs then
110210: LD_VAR 0 12
110214: IFFALSE 110367
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110216: LD_ADDR_VAR 0 4
110220: PUSH
110221: LD_VAR 0 2
110225: PPUSH
110226: LD_INT 21
110228: PUSH
110229: LD_INT 2
110231: PUSH
110232: EMPTY
110233: LIST
110234: LIST
110235: PPUSH
110236: CALL_OW 72
110240: PUSH
110241: FOR_IN
110242: IFFALSE 110365
// begin if GetTag ( i ) <> 20 then
110244: LD_VAR 0 4
110248: PPUSH
110249: CALL_OW 110
110253: PUSH
110254: LD_INT 20
110256: NONEQUAL
110257: IFFALSE 110271
// SetTag ( i , 20 ) ;
110259: LD_VAR 0 4
110263: PPUSH
110264: LD_INT 20
110266: PPUSH
110267: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110271: LD_VAR 0 4
110275: PPUSH
110276: CALL_OW 263
110280: PUSH
110281: LD_INT 1
110283: EQUAL
110284: PUSH
110285: LD_VAR 0 4
110289: PPUSH
110290: CALL_OW 311
110294: NOT
110295: AND
110296: IFFALSE 110363
// begin un := mechs [ 1 ] ;
110298: LD_ADDR_VAR 0 10
110302: PUSH
110303: LD_VAR 0 12
110307: PUSH
110308: LD_INT 1
110310: ARRAY
110311: ST_TO_ADDR
// ComExit ( un ) ;
110312: LD_VAR 0 10
110316: PPUSH
110317: CALL 51940 0 1
// AddComEnterUnit ( un , i ) ;
110321: LD_VAR 0 10
110325: PPUSH
110326: LD_VAR 0 4
110330: PPUSH
110331: CALL_OW 180
// SetTag ( un , 19 ) ;
110335: LD_VAR 0 10
110339: PPUSH
110340: LD_INT 19
110342: PPUSH
110343: CALL_OW 109
// mechs := mechs diff un ;
110347: LD_ADDR_VAR 0 12
110351: PUSH
110352: LD_VAR 0 12
110356: PUSH
110357: LD_VAR 0 10
110361: DIFF
110362: ST_TO_ADDR
// end ; end ;
110363: GO 110241
110365: POP
110366: POP
// if solds then
110367: LD_VAR 0 8
110371: IFFALSE 110430
// for i in solds do
110373: LD_ADDR_VAR 0 4
110377: PUSH
110378: LD_VAR 0 8
110382: PUSH
110383: FOR_IN
110384: IFFALSE 110428
// if not GetTag ( i ) then
110386: LD_VAR 0 4
110390: PPUSH
110391: CALL_OW 110
110395: NOT
110396: IFFALSE 110426
// begin defenders := defenders union i ;
110398: LD_ADDR_VAR 0 2
110402: PUSH
110403: LD_VAR 0 2
110407: PUSH
110408: LD_VAR 0 4
110412: UNION
110413: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110414: LD_VAR 0 4
110418: PPUSH
110419: LD_INT 18
110421: PPUSH
110422: CALL_OW 109
// end ;
110426: GO 110383
110428: POP
110429: POP
// repeat wait ( 0 0$2 ) ;
110430: LD_INT 70
110432: PPUSH
110433: CALL_OW 67
// enemy := mc_scan [ base ] ;
110437: LD_ADDR_VAR 0 21
110441: PUSH
110442: LD_EXP 83
110446: PUSH
110447: LD_VAR 0 1
110451: ARRAY
110452: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110453: LD_EXP 60
110457: PUSH
110458: LD_VAR 0 1
110462: ARRAY
110463: NOT
110464: PUSH
110465: LD_EXP 60
110469: PUSH
110470: LD_VAR 0 1
110474: ARRAY
110475: PUSH
110476: EMPTY
110477: EQUAL
110478: OR
110479: IFFALSE 110516
// begin for i in defenders do
110481: LD_ADDR_VAR 0 4
110485: PUSH
110486: LD_VAR 0 2
110490: PUSH
110491: FOR_IN
110492: IFFALSE 110505
// ComStop ( i ) ;
110494: LD_VAR 0 4
110498: PPUSH
110499: CALL_OW 141
110503: GO 110491
110505: POP
110506: POP
// defenders := [ ] ;
110507: LD_ADDR_VAR 0 2
110511: PUSH
110512: EMPTY
110513: ST_TO_ADDR
// exit ;
110514: GO 111965
// end ; for i in defenders do
110516: LD_ADDR_VAR 0 4
110520: PUSH
110521: LD_VAR 0 2
110525: PUSH
110526: FOR_IN
110527: IFFALSE 111425
// begin e := NearestUnitToUnit ( enemy , i ) ;
110529: LD_ADDR_VAR 0 13
110533: PUSH
110534: LD_VAR 0 21
110538: PPUSH
110539: LD_VAR 0 4
110543: PPUSH
110544: CALL_OW 74
110548: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110549: LD_ADDR_VAR 0 7
110553: PUSH
110554: LD_EXP 60
110558: PUSH
110559: LD_VAR 0 1
110563: ARRAY
110564: PPUSH
110565: LD_INT 2
110567: PUSH
110568: LD_INT 30
110570: PUSH
110571: LD_INT 0
110573: PUSH
110574: EMPTY
110575: LIST
110576: LIST
110577: PUSH
110578: LD_INT 30
110580: PUSH
110581: LD_INT 1
110583: PUSH
110584: EMPTY
110585: LIST
110586: LIST
110587: PUSH
110588: EMPTY
110589: LIST
110590: LIST
110591: LIST
110592: PPUSH
110593: CALL_OW 72
110597: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110598: LD_ADDR_VAR 0 16
110602: PUSH
110603: LD_VAR 0 7
110607: NOT
110608: PUSH
110609: LD_VAR 0 7
110613: PPUSH
110614: LD_INT 3
110616: PUSH
110617: LD_INT 24
110619: PUSH
110620: LD_INT 600
110622: PUSH
110623: EMPTY
110624: LIST
110625: LIST
110626: PUSH
110627: EMPTY
110628: LIST
110629: LIST
110630: PPUSH
110631: CALL_OW 72
110635: OR
110636: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
110637: LD_VAR 0 4
110641: PPUSH
110642: CALL_OW 247
110646: PUSH
110647: LD_INT 2
110649: DOUBLE
110650: EQUAL
110651: IFTRUE 110655
110653: GO 111051
110655: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
110656: LD_VAR 0 4
110660: PPUSH
110661: CALL_OW 256
110665: PUSH
110666: LD_INT 1000
110668: EQUAL
110669: PUSH
110670: LD_VAR 0 4
110674: PPUSH
110675: LD_VAR 0 13
110679: PPUSH
110680: CALL_OW 296
110684: PUSH
110685: LD_INT 40
110687: LESS
110688: PUSH
110689: LD_VAR 0 13
110693: PPUSH
110694: LD_EXP 85
110698: PUSH
110699: LD_VAR 0 1
110703: ARRAY
110704: PPUSH
110705: CALL_OW 308
110709: OR
110710: AND
110711: IFFALSE 110833
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
110713: LD_VAR 0 4
110717: PPUSH
110718: CALL_OW 262
110722: PUSH
110723: LD_INT 1
110725: EQUAL
110726: PUSH
110727: LD_VAR 0 4
110731: PPUSH
110732: CALL_OW 261
110736: PUSH
110737: LD_INT 30
110739: LESS
110740: AND
110741: PUSH
110742: LD_VAR 0 7
110746: AND
110747: IFFALSE 110817
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
110749: LD_VAR 0 4
110753: PPUSH
110754: LD_VAR 0 7
110758: PPUSH
110759: LD_VAR 0 4
110763: PPUSH
110764: CALL_OW 74
110768: PPUSH
110769: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
110773: LD_VAR 0 4
110777: PPUSH
110778: LD_VAR 0 7
110782: PPUSH
110783: LD_VAR 0 4
110787: PPUSH
110788: CALL_OW 74
110792: PPUSH
110793: CALL_OW 296
110797: PUSH
110798: LD_INT 6
110800: LESS
110801: IFFALSE 110815
// SetFuel ( i , 100 ) ;
110803: LD_VAR 0 4
110807: PPUSH
110808: LD_INT 100
110810: PPUSH
110811: CALL_OW 240
// end else
110815: GO 110831
// ComAttackUnit ( i , e ) ;
110817: LD_VAR 0 4
110821: PPUSH
110822: LD_VAR 0 13
110826: PPUSH
110827: CALL_OW 115
// end else
110831: GO 110934
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
110833: LD_VAR 0 13
110837: PPUSH
110838: LD_EXP 85
110842: PUSH
110843: LD_VAR 0 1
110847: ARRAY
110848: PPUSH
110849: CALL_OW 308
110853: NOT
110854: PUSH
110855: LD_VAR 0 4
110859: PPUSH
110860: LD_VAR 0 13
110864: PPUSH
110865: CALL_OW 296
110869: PUSH
110870: LD_INT 40
110872: GREATEREQUAL
110873: AND
110874: PUSH
110875: LD_VAR 0 4
110879: PPUSH
110880: CALL_OW 256
110884: PUSH
110885: LD_INT 650
110887: LESSEQUAL
110888: OR
110889: PUSH
110890: LD_VAR 0 4
110894: PPUSH
110895: LD_EXP 84
110899: PUSH
110900: LD_VAR 0 1
110904: ARRAY
110905: PPUSH
110906: CALL_OW 308
110910: NOT
110911: AND
110912: IFFALSE 110934
// ComMoveToArea ( i , mc_parking [ base ] ) ;
110914: LD_VAR 0 4
110918: PPUSH
110919: LD_EXP 84
110923: PUSH
110924: LD_VAR 0 1
110928: ARRAY
110929: PPUSH
110930: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
110934: LD_VAR 0 4
110938: PPUSH
110939: CALL_OW 256
110943: PUSH
110944: LD_INT 1000
110946: LESS
110947: PUSH
110948: LD_VAR 0 4
110952: PPUSH
110953: CALL_OW 263
110957: PUSH
110958: LD_INT 1
110960: EQUAL
110961: AND
110962: PUSH
110963: LD_VAR 0 4
110967: PPUSH
110968: CALL_OW 311
110972: AND
110973: PUSH
110974: LD_VAR 0 4
110978: PPUSH
110979: LD_EXP 84
110983: PUSH
110984: LD_VAR 0 1
110988: ARRAY
110989: PPUSH
110990: CALL_OW 308
110994: AND
110995: IFFALSE 111049
// begin mech := IsDrivenBy ( i ) ;
110997: LD_ADDR_VAR 0 9
111001: PUSH
111002: LD_VAR 0 4
111006: PPUSH
111007: CALL_OW 311
111011: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
111012: LD_VAR 0 9
111016: PPUSH
111017: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
111021: LD_VAR 0 9
111025: PPUSH
111026: LD_VAR 0 4
111030: PPUSH
111031: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
111035: LD_VAR 0 9
111039: PPUSH
111040: LD_VAR 0 4
111044: PPUSH
111045: CALL_OW 180
// end ; end ; unit_human :
111049: GO 111396
111051: LD_INT 1
111053: DOUBLE
111054: EQUAL
111055: IFTRUE 111059
111057: GO 111395
111059: POP
// begin b := IsInUnit ( i ) ;
111060: LD_ADDR_VAR 0 18
111064: PUSH
111065: LD_VAR 0 4
111069: PPUSH
111070: CALL_OW 310
111074: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
111075: LD_ADDR_VAR 0 19
111079: PUSH
111080: LD_VAR 0 18
111084: NOT
111085: PUSH
111086: LD_VAR 0 18
111090: PPUSH
111091: CALL_OW 266
111095: PUSH
111096: LD_INT 32
111098: PUSH
111099: LD_INT 31
111101: PUSH
111102: EMPTY
111103: LIST
111104: LIST
111105: IN
111106: OR
111107: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
111108: LD_VAR 0 18
111112: PPUSH
111113: CALL_OW 266
111117: PUSH
111118: LD_INT 5
111120: EQUAL
111121: PUSH
111122: LD_VAR 0 4
111126: PPUSH
111127: CALL_OW 257
111131: PUSH
111132: LD_INT 1
111134: PUSH
111135: LD_INT 2
111137: PUSH
111138: LD_INT 3
111140: PUSH
111141: LD_INT 4
111143: PUSH
111144: EMPTY
111145: LIST
111146: LIST
111147: LIST
111148: LIST
111149: IN
111150: AND
111151: IFFALSE 111188
// begin class := AllowSpecClass ( i ) ;
111153: LD_ADDR_VAR 0 20
111157: PUSH
111158: LD_VAR 0 4
111162: PPUSH
111163: CALL 16601 0 1
111167: ST_TO_ADDR
// if class then
111168: LD_VAR 0 20
111172: IFFALSE 111188
// ComChangeProfession ( i , class ) ;
111174: LD_VAR 0 4
111178: PPUSH
111179: LD_VAR 0 20
111183: PPUSH
111184: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111188: LD_VAR 0 16
111192: PUSH
111193: LD_VAR 0 2
111197: PPUSH
111198: LD_INT 21
111200: PUSH
111201: LD_INT 2
111203: PUSH
111204: EMPTY
111205: LIST
111206: LIST
111207: PPUSH
111208: CALL_OW 72
111212: PUSH
111213: LD_INT 1
111215: LESSEQUAL
111216: OR
111217: PUSH
111218: LD_VAR 0 19
111222: AND
111223: PUSH
111224: LD_VAR 0 4
111228: PUSH
111229: LD_VAR 0 17
111233: IN
111234: NOT
111235: AND
111236: IFFALSE 111329
// begin if b then
111238: LD_VAR 0 18
111242: IFFALSE 111291
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111244: LD_VAR 0 18
111248: PPUSH
111249: LD_VAR 0 21
111253: PPUSH
111254: LD_VAR 0 18
111258: PPUSH
111259: CALL_OW 74
111263: PPUSH
111264: CALL_OW 296
111268: PUSH
111269: LD_INT 10
111271: LESS
111272: PUSH
111273: LD_VAR 0 18
111277: PPUSH
111278: CALL_OW 461
111282: PUSH
111283: LD_INT 7
111285: NONEQUAL
111286: AND
111287: IFFALSE 111291
// continue ;
111289: GO 110526
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111291: LD_ADDR_VAR 0 17
111295: PUSH
111296: LD_VAR 0 17
111300: PPUSH
111301: LD_VAR 0 17
111305: PUSH
111306: LD_INT 1
111308: PLUS
111309: PPUSH
111310: LD_VAR 0 4
111314: PPUSH
111315: CALL_OW 1
111319: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111320: LD_VAR 0 4
111324: PPUSH
111325: CALL_OW 122
// end ; if sold_defenders then
111329: LD_VAR 0 17
111333: IFFALSE 111393
// if i in sold_defenders then
111335: LD_VAR 0 4
111339: PUSH
111340: LD_VAR 0 17
111344: IN
111345: IFFALSE 111393
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111347: LD_VAR 0 4
111351: PPUSH
111352: CALL_OW 314
111356: NOT
111357: PUSH
111358: LD_VAR 0 4
111362: PPUSH
111363: LD_VAR 0 13
111367: PPUSH
111368: CALL_OW 296
111372: PUSH
111373: LD_INT 30
111375: LESS
111376: AND
111377: IFFALSE 111393
// ComAttackUnit ( i , e ) ;
111379: LD_VAR 0 4
111383: PPUSH
111384: LD_VAR 0 13
111388: PPUSH
111389: CALL_OW 115
// end ; end ; end ;
111393: GO 111396
111395: POP
// if IsDead ( i ) then
111396: LD_VAR 0 4
111400: PPUSH
111401: CALL_OW 301
111405: IFFALSE 111423
// defenders := defenders diff i ;
111407: LD_ADDR_VAR 0 2
111411: PUSH
111412: LD_VAR 0 2
111416: PUSH
111417: LD_VAR 0 4
111421: DIFF
111422: ST_TO_ADDR
// end ;
111423: GO 110526
111425: POP
111426: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111427: LD_VAR 0 21
111431: NOT
111432: PUSH
111433: LD_VAR 0 2
111437: NOT
111438: OR
111439: PUSH
111440: LD_EXP 60
111444: PUSH
111445: LD_VAR 0 1
111449: ARRAY
111450: NOT
111451: OR
111452: IFFALSE 110430
// MC_Reset ( base , 18 ) ;
111454: LD_VAR 0 1
111458: PPUSH
111459: LD_INT 18
111461: PPUSH
111462: CALL 59060 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111466: LD_ADDR_VAR 0 2
111470: PUSH
111471: LD_VAR 0 2
111475: PUSH
111476: LD_VAR 0 2
111480: PPUSH
111481: LD_INT 2
111483: PUSH
111484: LD_INT 25
111486: PUSH
111487: LD_INT 1
111489: PUSH
111490: EMPTY
111491: LIST
111492: LIST
111493: PUSH
111494: LD_INT 25
111496: PUSH
111497: LD_INT 5
111499: PUSH
111500: EMPTY
111501: LIST
111502: LIST
111503: PUSH
111504: LD_INT 25
111506: PUSH
111507: LD_INT 8
111509: PUSH
111510: EMPTY
111511: LIST
111512: LIST
111513: PUSH
111514: LD_INT 25
111516: PUSH
111517: LD_INT 9
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PUSH
111524: EMPTY
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: PPUSH
111531: CALL_OW 72
111535: DIFF
111536: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111537: LD_VAR 0 21
111541: NOT
111542: PUSH
111543: LD_VAR 0 2
111547: PPUSH
111548: LD_INT 21
111550: PUSH
111551: LD_INT 2
111553: PUSH
111554: EMPTY
111555: LIST
111556: LIST
111557: PPUSH
111558: CALL_OW 72
111562: AND
111563: IFFALSE 111901
// begin tmp := FilterByTag ( defenders , 19 ) ;
111565: LD_ADDR_VAR 0 11
111569: PUSH
111570: LD_VAR 0 2
111574: PPUSH
111575: LD_INT 19
111577: PPUSH
111578: CALL 49070 0 2
111582: ST_TO_ADDR
// if tmp then
111583: LD_VAR 0 11
111587: IFFALSE 111657
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111589: LD_ADDR_VAR 0 11
111593: PUSH
111594: LD_VAR 0 11
111598: PPUSH
111599: LD_INT 25
111601: PUSH
111602: LD_INT 3
111604: PUSH
111605: EMPTY
111606: LIST
111607: LIST
111608: PPUSH
111609: CALL_OW 72
111613: ST_TO_ADDR
// if tmp then
111614: LD_VAR 0 11
111618: IFFALSE 111657
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111620: LD_ADDR_EXP 72
111624: PUSH
111625: LD_EXP 72
111629: PPUSH
111630: LD_VAR 0 1
111634: PPUSH
111635: LD_EXP 72
111639: PUSH
111640: LD_VAR 0 1
111644: ARRAY
111645: PUSH
111646: LD_VAR 0 11
111650: UNION
111651: PPUSH
111652: CALL_OW 1
111656: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111657: LD_VAR 0 1
111661: PPUSH
111662: LD_INT 19
111664: PPUSH
111665: CALL 59060 0 2
// repeat wait ( 0 0$1 ) ;
111669: LD_INT 35
111671: PPUSH
111672: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111676: LD_EXP 60
111680: PUSH
111681: LD_VAR 0 1
111685: ARRAY
111686: NOT
111687: PUSH
111688: LD_EXP 60
111692: PUSH
111693: LD_VAR 0 1
111697: ARRAY
111698: PUSH
111699: EMPTY
111700: EQUAL
111701: OR
111702: IFFALSE 111739
// begin for i in defenders do
111704: LD_ADDR_VAR 0 4
111708: PUSH
111709: LD_VAR 0 2
111713: PUSH
111714: FOR_IN
111715: IFFALSE 111728
// ComStop ( i ) ;
111717: LD_VAR 0 4
111721: PPUSH
111722: CALL_OW 141
111726: GO 111714
111728: POP
111729: POP
// defenders := [ ] ;
111730: LD_ADDR_VAR 0 2
111734: PUSH
111735: EMPTY
111736: ST_TO_ADDR
// exit ;
111737: GO 111965
// end ; for i in defenders do
111739: LD_ADDR_VAR 0 4
111743: PUSH
111744: LD_VAR 0 2
111748: PUSH
111749: FOR_IN
111750: IFFALSE 111839
// begin if not IsInArea ( i , mc_parking [ base ] ) then
111752: LD_VAR 0 4
111756: PPUSH
111757: LD_EXP 84
111761: PUSH
111762: LD_VAR 0 1
111766: ARRAY
111767: PPUSH
111768: CALL_OW 308
111772: NOT
111773: IFFALSE 111797
// ComMoveToArea ( i , mc_parking [ base ] ) else
111775: LD_VAR 0 4
111779: PPUSH
111780: LD_EXP 84
111784: PUSH
111785: LD_VAR 0 1
111789: ARRAY
111790: PPUSH
111791: CALL_OW 113
111795: GO 111837
// if GetControl ( i ) = control_manual then
111797: LD_VAR 0 4
111801: PPUSH
111802: CALL_OW 263
111806: PUSH
111807: LD_INT 1
111809: EQUAL
111810: IFFALSE 111837
// if IsDrivenBy ( i ) then
111812: LD_VAR 0 4
111816: PPUSH
111817: CALL_OW 311
111821: IFFALSE 111837
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
111823: LD_VAR 0 4
111827: PPUSH
111828: CALL_OW 311
111832: PPUSH
111833: CALL_OW 121
// end ;
111837: GO 111749
111839: POP
111840: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
111841: LD_VAR 0 2
111845: PPUSH
111846: LD_INT 95
111848: PUSH
111849: LD_EXP 84
111853: PUSH
111854: LD_VAR 0 1
111858: ARRAY
111859: PUSH
111860: EMPTY
111861: LIST
111862: LIST
111863: PPUSH
111864: CALL_OW 72
111868: PUSH
111869: LD_VAR 0 2
111873: EQUAL
111874: PUSH
111875: LD_EXP 83
111879: PUSH
111880: LD_VAR 0 1
111884: ARRAY
111885: OR
111886: PUSH
111887: LD_EXP 60
111891: PUSH
111892: LD_VAR 0 1
111896: ARRAY
111897: NOT
111898: OR
111899: IFFALSE 111669
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
111901: LD_ADDR_EXP 82
111905: PUSH
111906: LD_EXP 82
111910: PPUSH
111911: LD_VAR 0 1
111915: PPUSH
111916: LD_VAR 0 2
111920: PPUSH
111921: LD_INT 21
111923: PUSH
111924: LD_INT 2
111926: PUSH
111927: EMPTY
111928: LIST
111929: LIST
111930: PPUSH
111931: CALL_OW 72
111935: PPUSH
111936: CALL_OW 1
111940: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
111941: LD_VAR 0 1
111945: PPUSH
111946: LD_INT 19
111948: PPUSH
111949: CALL 59060 0 2
// MC_Reset ( base , 20 ) ;
111953: LD_VAR 0 1
111957: PPUSH
111958: LD_INT 20
111960: PPUSH
111961: CALL 59060 0 2
// end ; end_of_file
111965: LD_VAR 0 3
111969: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
111970: LD_VAR 0 1
111974: PUSH
111975: LD_INT 200
111977: DOUBLE
111978: GREATEREQUAL
111979: IFFALSE 111987
111981: LD_INT 299
111983: DOUBLE
111984: LESSEQUAL
111985: IFTRUE 111989
111987: GO 112021
111989: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
111990: LD_VAR 0 1
111994: PPUSH
111995: LD_VAR 0 2
111999: PPUSH
112000: LD_VAR 0 3
112004: PPUSH
112005: LD_VAR 0 4
112009: PPUSH
112010: LD_VAR 0 5
112014: PPUSH
112015: CALL 100407 0 5
112019: GO 112098
112021: LD_INT 300
112023: DOUBLE
112024: GREATEREQUAL
112025: IFFALSE 112033
112027: LD_INT 399
112029: DOUBLE
112030: LESSEQUAL
112031: IFTRUE 112035
112033: GO 112097
112035: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
112036: LD_VAR 0 1
112040: PPUSH
112041: LD_VAR 0 2
112045: PPUSH
112046: LD_VAR 0 3
112050: PPUSH
112051: LD_VAR 0 4
112055: PPUSH
112056: LD_VAR 0 5
112060: PPUSH
112061: LD_VAR 0 6
112065: PPUSH
112066: LD_VAR 0 7
112070: PPUSH
112071: LD_VAR 0 8
112075: PPUSH
112076: LD_VAR 0 9
112080: PPUSH
112081: LD_VAR 0 10
112085: PPUSH
112086: LD_VAR 0 11
112090: PPUSH
112091: CALL 98049 0 11
112095: GO 112098
112097: POP
// end ;
112098: PPOPN 11
112100: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
112101: LD_VAR 0 1
112105: PPUSH
112106: LD_VAR 0 2
112110: PPUSH
112111: LD_VAR 0 3
112115: PPUSH
112116: LD_VAR 0 4
112120: PPUSH
112121: LD_VAR 0 5
112125: PPUSH
112126: CALL 100143 0 5
// end ; end_of_file
112130: PPOPN 5
112132: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
112133: LD_VAR 0 1
112137: PPUSH
112138: LD_VAR 0 2
112142: PPUSH
112143: LD_VAR 0 3
112147: PPUSH
112148: LD_VAR 0 4
112152: PPUSH
112153: LD_VAR 0 5
112157: PPUSH
112158: LD_VAR 0 6
112162: PPUSH
112163: CALL 85742 0 6
// end ;
112167: PPOPN 6
112169: END
