// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 600 0 0
// InitMacro ;
  19: CALL 56488 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48340 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48340 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48340 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48340 0 9
// PrepareArabian ;
 147: CALL 3510 0 0
// PrepareRussian ;
 151: CALL 2645 0 0
// PrepareAlliance ;
 155: CALL 710 0 0
// MC_Start ( ) ;
 159: CALL 58600 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6673 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 79401 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 79827 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 80222 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 80491 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 79767 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 80398 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 79827 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 80222 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 80491 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 79611 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: EMPTY
 589: LIST
 590: PPUSH
 591: CALL 79767 0 2
// end ;
 595: LD_VAR 0 1
 599: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 600: LD_INT 0
 602: PPUSH
// debug := false ;
 603: LD_ADDR_EXP 1
 607: PUSH
 608: LD_INT 0
 610: ST_TO_ADDR
// game := true ;
 611: LD_ADDR_EXP 2
 615: PUSH
 616: LD_INT 1
 618: ST_TO_ADDR
// gossudarov_arrive := false ;
 619: LD_ADDR_EXP 4
 623: PUSH
 624: LD_INT 0
 626: ST_TO_ADDR
// ru_lab_builded := false ;
 627: LD_ADDR_EXP 5
 631: PUSH
 632: LD_INT 0
 634: ST_TO_ADDR
// player_spotted := false ;
 635: LD_ADDR_EXP 6
 639: PUSH
 640: LD_INT 0
 642: ST_TO_ADDR
// first_attack := false ;
 643: LD_ADDR_EXP 7
 647: PUSH
 648: LD_INT 0
 650: ST_TO_ADDR
// ru_attackers := [ ] ;
 651: LD_ADDR_EXP 51
 655: PUSH
 656: EMPTY
 657: ST_TO_ADDR
// ar_base_spotted := false ;
 658: LD_ADDR_EXP 8
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// ar_active_attack := false ;
 666: LD_ADDR_EXP 9
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ar_attackers := [ ] ;
 674: LD_ADDR_EXP 10
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// first_powell_attack := false ;
 681: LD_ADDR_EXP 11
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// abdul_escaped := true ;
 689: LD_ADDR_EXP 12
 693: PUSH
 694: LD_INT 1
 696: ST_TO_ADDR
// loss_counter := 0 ;
 697: LD_ADDR_EXP 13
 701: PUSH
 702: LD_INT 0
 704: ST_TO_ADDR
// end ; end_of_file
 705: LD_VAR 0 1
 709: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 710: LD_INT 0
 712: PPUSH
 713: PPUSH
 714: PPUSH
 715: PPUSH
// uc_side := 7 ;
 716: LD_ADDR_OWVAR 20
 720: PUSH
 721: LD_INT 7
 723: ST_TO_ADDR
// uc_nation := 1 ;
 724: LD_ADDR_OWVAR 21
 728: PUSH
 729: LD_INT 1
 731: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 732: LD_ADDR_EXP 14
 736: PUSH
 737: LD_STRING JMM
 739: PPUSH
 740: LD_EXP 1
 744: NOT
 745: PPUSH
 746: LD_STRING 12a_
 748: PPUSH
 749: CALL 13917 0 3
 753: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 754: LD_EXP 14
 758: PPUSH
 759: LD_INT 71
 761: PPUSH
 762: LD_INT 23
 764: PPUSH
 765: LD_INT 0
 767: PPUSH
 768: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 772: LD_EXP 14
 776: PPUSH
 777: LD_INT 2
 779: PPUSH
 780: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 784: LD_ADDR_EXP 15
 788: PUSH
 789: LD_STRING Roth
 791: PPUSH
 792: LD_EXP 1
 796: NOT
 797: PPUSH
 798: LD_STRING 12a_
 800: PPUSH
 801: CALL 13917 0 3
 805: ST_TO_ADDR
// if Roth then
 806: LD_EXP 15
 810: IFFALSE 830
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 812: LD_EXP 15
 816: PPUSH
 817: LD_INT 71
 819: PPUSH
 820: LD_INT 21
 822: PPUSH
 823: LD_INT 0
 825: PPUSH
 826: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 830: LD_ADDR_EXP 16
 834: PUSH
 835: LD_STRING Lisa
 837: PPUSH
 838: LD_EXP 1
 842: NOT
 843: PPUSH
 844: LD_STRING 12a_
 846: PPUSH
 847: CALL 13917 0 3
 851: ST_TO_ADDR
// if Lisa then
 852: LD_EXP 16
 856: IFFALSE 873
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 858: LD_EXP 16
 862: PPUSH
 863: LD_INT 13
 865: PPUSH
 866: LD_INT 0
 868: PPUSH
 869: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 873: LD_ADDR_EXP 17
 877: PUSH
 878: LD_STRING Donaldson
 880: PPUSH
 881: LD_EXP 1
 885: NOT
 886: PPUSH
 887: LD_STRING 12a_
 889: PPUSH
 890: CALL 13917 0 3
 894: ST_TO_ADDR
// if Donaldson then
 895: LD_EXP 17
 899: IFFALSE 916
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 901: LD_EXP 17
 905: PPUSH
 906: LD_INT 13
 908: PPUSH
 909: LD_INT 0
 911: PPUSH
 912: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 916: LD_ADDR_EXP 18
 920: PUSH
 921: LD_STRING Bobby
 923: PPUSH
 924: LD_EXP 1
 928: NOT
 929: PPUSH
 930: LD_STRING 12a_
 932: PPUSH
 933: CALL 13917 0 3
 937: ST_TO_ADDR
// if Bobby then
 938: LD_EXP 18
 942: IFFALSE 959
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 944: LD_EXP 18
 948: PPUSH
 949: LD_INT 13
 951: PPUSH
 952: LD_INT 0
 954: PPUSH
 955: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 959: LD_ADDR_EXP 19
 963: PUSH
 964: LD_STRING Cyrus
 966: PPUSH
 967: LD_EXP 1
 971: NOT
 972: PPUSH
 973: LD_STRING 12a_
 975: PPUSH
 976: CALL 13917 0 3
 980: ST_TO_ADDR
// if Cyrus then
 981: LD_EXP 19
 985: IFFALSE 1002
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
 987: LD_EXP 19
 991: PPUSH
 992: LD_INT 13
 994: PPUSH
 995: LD_INT 0
 997: PPUSH
 998: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1002: LD_ADDR_EXP 20
1006: PUSH
1007: LD_STRING Denis
1009: PPUSH
1010: LD_EXP 1
1014: NOT
1015: PPUSH
1016: LD_STRING 12a_
1018: PPUSH
1019: CALL 13917 0 3
1023: ST_TO_ADDR
// if Denis then
1024: LD_EXP 20
1028: IFFALSE 1045
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1030: LD_EXP 20
1034: PPUSH
1035: LD_INT 13
1037: PPUSH
1038: LD_INT 0
1040: PPUSH
1041: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1045: LD_ADDR_EXP 21
1049: PUSH
1050: LD_STRING Brown
1052: PPUSH
1053: LD_EXP 1
1057: NOT
1058: PPUSH
1059: LD_STRING 12a_
1061: PPUSH
1062: CALL 13917 0 3
1066: ST_TO_ADDR
// if Brown then
1067: LD_EXP 21
1071: IFFALSE 1088
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1073: LD_EXP 21
1077: PPUSH
1078: LD_INT 13
1080: PPUSH
1081: LD_INT 0
1083: PPUSH
1084: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1088: LD_ADDR_EXP 22
1092: PUSH
1093: LD_STRING Gladstone
1095: PPUSH
1096: LD_EXP 1
1100: NOT
1101: PPUSH
1102: LD_STRING 12a_
1104: PPUSH
1105: CALL 13917 0 3
1109: ST_TO_ADDR
// if Gladstone then
1110: LD_EXP 22
1114: IFFALSE 1131
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1116: LD_EXP 22
1120: PPUSH
1121: LD_INT 13
1123: PPUSH
1124: LD_INT 0
1126: PPUSH
1127: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1131: LD_ADDR_EXP 23
1135: PUSH
1136: LD_STRING Houten
1138: PPUSH
1139: LD_EXP 1
1143: NOT
1144: PPUSH
1145: LD_STRING 12a_
1147: PPUSH
1148: CALL 13917 0 3
1152: ST_TO_ADDR
// if Houten then
1153: LD_EXP 23
1157: IFFALSE 1174
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1159: LD_EXP 23
1163: PPUSH
1164: LD_INT 13
1166: PPUSH
1167: LD_INT 0
1169: PPUSH
1170: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1174: LD_ADDR_EXP 24
1178: PUSH
1179: LD_STRING Cornell
1181: PPUSH
1182: LD_EXP 1
1186: NOT
1187: PPUSH
1188: LD_STRING 12a_
1190: PPUSH
1191: CALL 13917 0 3
1195: ST_TO_ADDR
// if Cornel then
1196: LD_EXP 24
1200: IFFALSE 1217
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1202: LD_EXP 24
1206: PPUSH
1207: LD_INT 13
1209: PPUSH
1210: LD_INT 0
1212: PPUSH
1213: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1217: LD_ADDR_EXP 25
1221: PUSH
1222: LD_STRING Gary
1224: PPUSH
1225: LD_EXP 1
1229: NOT
1230: PPUSH
1231: LD_STRING 12a_
1233: PPUSH
1234: CALL 13917 0 3
1238: ST_TO_ADDR
// if Gary then
1239: LD_EXP 25
1243: IFFALSE 1260
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1245: LD_EXP 25
1249: PPUSH
1250: LD_INT 13
1252: PPUSH
1253: LD_INT 0
1255: PPUSH
1256: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1260: LD_ADDR_EXP 26
1264: PUSH
1265: LD_STRING Frank
1267: PPUSH
1268: LD_EXP 1
1272: NOT
1273: PPUSH
1274: LD_STRING 12a_
1276: PPUSH
1277: CALL 13917 0 3
1281: ST_TO_ADDR
// if Frank then
1282: LD_EXP 26
1286: IFFALSE 1303
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1288: LD_EXP 26
1292: PPUSH
1293: LD_INT 13
1295: PPUSH
1296: LD_INT 0
1298: PPUSH
1299: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1303: LD_ADDR_EXP 27
1307: PUSH
1308: LD_STRING Kikuchi
1310: PPUSH
1311: LD_EXP 1
1315: NOT
1316: PPUSH
1317: LD_STRING 12a_
1319: PPUSH
1320: CALL 13917 0 3
1324: ST_TO_ADDR
// if Kikuchi then
1325: LD_EXP 27
1329: IFFALSE 1346
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1331: LD_EXP 27
1335: PPUSH
1336: LD_INT 13
1338: PPUSH
1339: LD_INT 0
1341: PPUSH
1342: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1346: LD_ADDR_EXP 28
1350: PUSH
1351: LD_STRING Simms
1353: PPUSH
1354: LD_EXP 1
1358: NOT
1359: PPUSH
1360: LD_STRING 12a_
1362: PPUSH
1363: CALL 13917 0 3
1367: ST_TO_ADDR
// if Simms then
1368: LD_EXP 28
1372: IFFALSE 1389
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1374: LD_EXP 28
1378: PPUSH
1379: LD_INT 13
1381: PPUSH
1382: LD_INT 0
1384: PPUSH
1385: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1389: LD_ADDR_EXP 29
1393: PUSH
1394: LD_STRING Joan
1396: PPUSH
1397: LD_EXP 1
1401: NOT
1402: PPUSH
1403: LD_STRING 12a_
1405: PPUSH
1406: CALL 13917 0 3
1410: ST_TO_ADDR
// if Joan then
1411: LD_EXP 29
1415: IFFALSE 1432
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1417: LD_EXP 29
1421: PPUSH
1422: LD_INT 13
1424: PPUSH
1425: LD_INT 0
1427: PPUSH
1428: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1432: LD_ADDR_EXP 30
1436: PUSH
1437: LD_STRING DeltaDoctor
1439: PPUSH
1440: LD_EXP 1
1444: NOT
1445: PPUSH
1446: LD_STRING 12a_
1448: PPUSH
1449: CALL 13917 0 3
1453: ST_TO_ADDR
// if DeltaDoctor then
1454: LD_EXP 30
1458: IFFALSE 1475
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1460: LD_EXP 30
1464: PPUSH
1465: LD_INT 13
1467: PPUSH
1468: LD_INT 0
1470: PPUSH
1471: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1475: LD_ADDR_VAR 0 4
1479: PUSH
1480: LD_STRING 12a_others
1482: PPUSH
1483: CALL_OW 31
1487: ST_TO_ADDR
// if tmp then
1488: LD_VAR 0 4
1492: IFFALSE 1526
// for i in tmp do
1494: LD_ADDR_VAR 0 3
1498: PUSH
1499: LD_VAR 0 4
1503: PUSH
1504: FOR_IN
1505: IFFALSE 1524
// PlaceUnitArea ( i , alliance_start , false ) ;
1507: LD_VAR 0 3
1511: PPUSH
1512: LD_INT 13
1514: PPUSH
1515: LD_INT 0
1517: PPUSH
1518: CALL_OW 49
1522: GO 1504
1524: POP
1525: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1526: LD_INT 3
1528: PPUSH
1529: LD_INT 3
1531: PPUSH
1532: LD_INT 3
1534: PPUSH
1535: LD_INT 12
1537: PPUSH
1538: LD_INT 100
1540: PPUSH
1541: CALL 20550 0 5
// veh := CreateVehicle ;
1545: LD_ADDR_VAR 0 2
1549: PUSH
1550: CALL_OW 45
1554: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1555: LD_VAR 0 2
1559: PPUSH
1560: LD_INT 2
1562: PPUSH
1563: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1567: LD_VAR 0 2
1571: PPUSH
1572: LD_INT 60
1574: PPUSH
1575: LD_INT 6
1577: PPUSH
1578: LD_INT 0
1580: PPUSH
1581: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1585: LD_VAR 0 2
1589: PPUSH
1590: LD_INT 4
1592: PPUSH
1593: LD_INT 30
1595: PPUSH
1596: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1600: LD_STRING 11_artifact_captured
1602: PPUSH
1603: LD_INT 0
1605: PPUSH
1606: CALL_OW 30
1610: IFFALSE 1686
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1612: LD_INT 3
1614: PPUSH
1615: LD_INT 3
1617: PPUSH
1618: LD_INT 3
1620: PPUSH
1621: LD_INT 12
1623: PPUSH
1624: LD_INT 100
1626: PPUSH
1627: CALL 20550 0 5
// veh := CreateVehicle ;
1631: LD_ADDR_VAR 0 2
1635: PUSH
1636: CALL_OW 45
1640: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1641: LD_VAR 0 2
1645: PPUSH
1646: LD_INT 3
1648: PPUSH
1649: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1653: LD_VAR 0 2
1657: PPUSH
1658: LD_INT 75
1660: PPUSH
1661: LD_INT 6
1663: PPUSH
1664: LD_INT 0
1666: PPUSH
1667: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1671: LD_VAR 0 2
1675: PPUSH
1676: LD_INT 4
1678: PPUSH
1679: LD_INT 50
1681: PPUSH
1682: CALL_OW 290
// end ; end ;
1686: LD_VAR 0 1
1690: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1691: LD_INT 0
1693: PPUSH
1694: PPUSH
1695: PPUSH
1696: PPUSH
// uc_side := 6 ;
1697: LD_ADDR_OWVAR 20
1701: PUSH
1702: LD_INT 6
1704: ST_TO_ADDR
// uc_nation := 3 ;
1705: LD_ADDR_OWVAR 21
1709: PUSH
1710: LD_INT 3
1712: ST_TO_ADDR
// InitHc ;
1713: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1717: LD_ADDR_EXP 31
1721: PUSH
1722: LD_STRING Gossudarov
1724: PPUSH
1725: CALL_OW 25
1729: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1730: LD_ADDR_EXP 32
1734: PUSH
1735: LD_STRING Kirilenkova
1737: PPUSH
1738: CALL_OW 25
1742: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1743: LD_ADDR_EXP 33
1747: PUSH
1748: LD_STRING Titov
1750: PPUSH
1751: CALL_OW 25
1755: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1756: LD_ADDR_EXP 38
1760: PUSH
1761: LD_STRING Oblukov
1763: PPUSH
1764: CALL_OW 25
1768: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1769: LD_ADDR_EXP 35
1773: PUSH
1774: LD_STRING Dolgov
1776: PPUSH
1777: CALL_OW 25
1781: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1782: LD_ADDR_EXP 36
1786: PUSH
1787: LD_STRING Petrosyan
1789: PPUSH
1790: CALL_OW 25
1794: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1795: LD_ADDR_EXP 37
1799: PUSH
1800: LD_STRING Scholtze
1802: PPUSH
1803: CALL_OW 25
1807: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1808: LD_ADDR_EXP 39
1812: PUSH
1813: LD_STRING Kapitsova
1815: PPUSH
1816: CALL_OW 25
1820: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: LD_EXP 31
1830: PUSH
1831: LD_EXP 32
1835: PUSH
1836: LD_EXP 33
1840: PUSH
1841: LD_EXP 38
1845: PUSH
1846: LD_EXP 35
1850: PUSH
1851: LD_EXP 36
1855: PUSH
1856: LD_EXP 37
1860: PUSH
1861: LD_EXP 39
1865: PUSH
1866: EMPTY
1867: LIST
1868: LIST
1869: LIST
1870: LIST
1871: LIST
1872: LIST
1873: LIST
1874: LIST
1875: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1876: LD_INT 1
1878: PPUSH
1879: LD_INT 4
1881: PPUSH
1882: LD_INT 8
1884: PPUSH
1885: CALL_OW 380
// un := CreateHuman ;
1889: LD_ADDR_VAR 0 4
1893: PUSH
1894: CALL_OW 44
1898: ST_TO_ADDR
// tmp := tmp ^ un ;
1899: LD_ADDR_VAR 0 2
1903: PUSH
1904: LD_VAR 0 2
1908: PUSH
1909: LD_VAR 0 4
1913: ADD
1914: ST_TO_ADDR
// for i in tmp do
1915: LD_ADDR_VAR 0 3
1919: PUSH
1920: LD_VAR 0 2
1924: PUSH
1925: FOR_IN
1926: IFFALSE 1945
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1928: LD_VAR 0 3
1932: PPUSH
1933: LD_INT 14
1935: PPUSH
1936: LD_INT 0
1938: PPUSH
1939: CALL_OW 49
1943: GO 1925
1945: POP
1946: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1947: LD_VAR 0 2
1951: PPUSH
1952: LD_EXP 3
1956: PPUSH
1957: CALL_OW 250
1961: PPUSH
1962: LD_EXP 3
1966: PPUSH
1967: CALL_OW 251
1971: PPUSH
1972: CALL_OW 111
// end ;
1976: LD_VAR 0 1
1980: RET
// export function PrepareBelkov ; begin
1981: LD_INT 0
1983: PPUSH
// uc_side := 4 ;
1984: LD_ADDR_OWVAR 20
1988: PUSH
1989: LD_INT 4
1991: ST_TO_ADDR
// uc_nation := 3 ;
1992: LD_ADDR_OWVAR 21
1996: PUSH
1997: LD_INT 3
1999: ST_TO_ADDR
// InitHc ;
2000: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2004: LD_ADDR_EXP 46
2008: PUSH
2009: LD_STRING Belkov
2011: PPUSH
2012: CALL_OW 25
2016: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2017: LD_EXP 46
2021: PPUSH
2022: LD_INT 14
2024: PPUSH
2025: LD_INT 0
2027: PPUSH
2028: CALL_OW 49
// end ;
2032: LD_VAR 0 1
2036: RET
// export function PrepareGnyevko ; begin
2037: LD_INT 0
2039: PPUSH
// uc_side := 4 ;
2040: LD_ADDR_OWVAR 20
2044: PUSH
2045: LD_INT 4
2047: ST_TO_ADDR
// uc_nation := 3 ;
2048: LD_ADDR_OWVAR 21
2052: PUSH
2053: LD_INT 3
2055: ST_TO_ADDR
// InitHc ;
2056: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2060: LD_ADDR_EXP 47
2064: PUSH
2065: LD_STRING Gnyevko
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2073: LD_EXP 47
2077: PPUSH
2078: LD_INT 14
2080: PPUSH
2081: LD_INT 0
2083: PPUSH
2084: CALL_OW 49
// end ;
2088: LD_VAR 0 1
2092: RET
// export function PrepareBurlak ; var i , tmp ; begin
2093: LD_INT 0
2095: PPUSH
2096: PPUSH
2097: PPUSH
// uc_side := 4 ;
2098: LD_ADDR_OWVAR 20
2102: PUSH
2103: LD_INT 4
2105: ST_TO_ADDR
// uc_nation := 3 ;
2106: LD_ADDR_OWVAR 21
2110: PUSH
2111: LD_INT 3
2113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2114: LD_INT 35
2116: PPUSH
2117: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2121: LD_INT 92
2123: PUSH
2124: LD_INT 123
2126: PUSH
2127: LD_INT 3
2129: PUSH
2130: LD_INT 3
2132: PUSH
2133: EMPTY
2134: LIST
2135: LIST
2136: LIST
2137: LIST
2138: PPUSH
2139: CALL_OW 69
2143: NOT
2144: IFFALSE 2114
// InitHc ;
2146: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2150: LD_ADDR_EXP 45
2154: PUSH
2155: LD_STRING Burlak
2157: PPUSH
2158: CALL_OW 25
2162: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2163: LD_INT 24
2165: PUSH
2166: LD_INT 23
2168: PUSH
2169: LD_INT 22
2171: PUSH
2172: EMPTY
2173: LIST
2174: LIST
2175: LIST
2176: PUSH
2177: LD_OWVAR 67
2181: ARRAY
2182: PPUSH
2183: LD_INT 1
2185: PPUSH
2186: LD_INT 1
2188: PPUSH
2189: LD_INT 45
2191: PUSH
2192: LD_INT 44
2194: PUSH
2195: LD_INT 43
2197: PUSH
2198: EMPTY
2199: LIST
2200: LIST
2201: LIST
2202: PUSH
2203: LD_OWVAR 67
2207: ARRAY
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: CALL 20550 0 5
// Masha := CreateVehicle ;
2216: LD_ADDR_EXP 48
2220: PUSH
2221: CALL_OW 45
2225: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2226: LD_EXP 48
2230: PUSH
2231: LD_EXP 45
2235: PUSH
2236: EMPTY
2237: LIST
2238: LIST
2239: PPUSH
2240: LD_INT 499
2242: PPUSH
2243: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2247: LD_EXP 48
2251: PPUSH
2252: LD_INT 3
2254: PPUSH
2255: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2259: LD_EXP 48
2263: PPUSH
2264: LD_INT 1
2266: PPUSH
2267: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2271: LD_EXP 48
2275: PPUSH
2276: LD_INT 18
2278: PPUSH
2279: LD_INT 0
2281: PPUSH
2282: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2286: LD_EXP 45
2290: PPUSH
2291: LD_INT 125
2293: PPUSH
2294: LD_INT 1
2296: PPUSH
2297: LD_INT 0
2299: PPUSH
2300: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2304: LD_EXP 45
2308: PPUSH
2309: LD_EXP 48
2313: PPUSH
2314: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2318: LD_INT 10
2320: PPUSH
2321: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2325: LD_EXP 48
2329: PPUSH
2330: LD_INT 110
2332: PPUSH
2333: LD_INT 10
2335: PPUSH
2336: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2340: LD_ADDR_EXP 41
2344: PUSH
2345: LD_STRING Petrovova
2347: PPUSH
2348: CALL_OW 25
2352: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2353: LD_ADDR_EXP 43
2357: PUSH
2358: LD_STRING Kuzmov
2360: PPUSH
2361: CALL_OW 25
2365: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2366: LD_ADDR_EXP 42
2370: PUSH
2371: LD_STRING Kovalyuk
2373: PPUSH
2374: CALL_OW 25
2378: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2379: LD_ADDR_EXP 40
2383: PUSH
2384: LD_STRING Lipshchin
2386: PPUSH
2387: CALL_OW 25
2391: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2392: LD_ADDR_EXP 44
2396: PUSH
2397: LD_STRING Karamazov
2399: PPUSH
2400: CALL_OW 25
2404: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2405: LD_ADDR_VAR 0 3
2409: PUSH
2410: LD_EXP 41
2414: PUSH
2415: LD_EXP 43
2419: PUSH
2420: LD_EXP 42
2424: PUSH
2425: LD_EXP 40
2429: PUSH
2430: LD_EXP 44
2434: PUSH
2435: EMPTY
2436: LIST
2437: LIST
2438: LIST
2439: LIST
2440: LIST
2441: ST_TO_ADDR
// for i in tmp do
2442: LD_ADDR_VAR 0 2
2446: PUSH
2447: LD_VAR 0 3
2451: PUSH
2452: FOR_IN
2453: IFFALSE 2492
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2455: LD_VAR 0 2
2459: PPUSH
2460: LD_INT 399
2462: PPUSH
2463: LD_INT 799
2465: PPUSH
2466: CALL_OW 12
2470: PPUSH
2471: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2475: LD_VAR 0 2
2479: PPUSH
2480: LD_INT 19
2482: PPUSH
2483: LD_INT 0
2485: PPUSH
2486: CALL_OW 49
// end ;
2490: GO 2452
2492: POP
2493: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2494: LD_VAR 0 3
2498: PPUSH
2499: LD_INT 116
2501: PPUSH
2502: LD_INT 8
2504: PPUSH
2505: CALL_OW 111
// AddComHold ( tmp ) ;
2509: LD_VAR 0 3
2513: PPUSH
2514: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2518: LD_ADDR_VAR 0 2
2522: PUSH
2523: LD_VAR 0 3
2527: PPUSH
2528: LD_INT 25
2530: PUSH
2531: LD_INT 1
2533: PUSH
2534: EMPTY
2535: LIST
2536: LIST
2537: PPUSH
2538: CALL_OW 72
2542: PUSH
2543: FOR_IN
2544: IFFALSE 2584
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2546: LD_VAR 0 2
2550: PPUSH
2551: LD_INT 20
2553: PPUSH
2554: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2558: LD_VAR 0 2
2562: PPUSH
2563: LD_INT 147
2565: PPUSH
2566: LD_INT 45
2568: PPUSH
2569: CALL_OW 178
// AddComCrawl ( i ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: CALL_OW 197
// end ;
2582: GO 2543
2584: POP
2585: POP
// repeat wait ( 0 0$1 ) ;
2586: LD_INT 35
2588: PPUSH
2589: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2593: LD_EXP 48
2597: PPUSH
2598: LD_INT 110
2600: PPUSH
2601: LD_INT 10
2603: PPUSH
2604: CALL_OW 307
2608: PUSH
2609: LD_EXP 48
2613: PPUSH
2614: CALL_OW 305
2618: NOT
2619: OR
2620: IFFALSE 2586
// ComStop ( Burlak ) ;
2622: LD_EXP 45
2626: PPUSH
2627: CALL_OW 141
// AddComHold ( Burlak ) ;
2631: LD_EXP 45
2635: PPUSH
2636: CALL_OW 200
// end ; end_of_file
2640: LD_VAR 0 1
2644: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2645: LD_INT 0
2647: PPUSH
2648: PPUSH
2649: PPUSH
2650: PPUSH
// uc_side := 3 ;
2651: LD_ADDR_OWVAR 20
2655: PUSH
2656: LD_INT 3
2658: ST_TO_ADDR
// uc_nation := 3 ;
2659: LD_ADDR_OWVAR 21
2663: PUSH
2664: LD_INT 3
2666: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2667: LD_ADDR_EXP 49
2671: PUSH
2672: LD_INT 47
2674: PPUSH
2675: LD_INT 4
2677: PPUSH
2678: LD_STRING 
2680: PPUSH
2681: LD_INT 7
2683: PUSH
2684: LD_INT 8
2686: PUSH
2687: LD_INT 9
2689: PUSH
2690: EMPTY
2691: LIST
2692: LIST
2693: LIST
2694: PUSH
2695: LD_OWVAR 67
2699: ARRAY
2700: PPUSH
2701: LD_INT 10000
2703: PUSH
2704: LD_INT 3000
2706: PUSH
2707: LD_INT 300
2709: PUSH
2710: EMPTY
2711: LIST
2712: LIST
2713: LIST
2714: PPUSH
2715: LD_INT 9
2717: PUSH
2718: LD_INT 5
2720: PUSH
2721: LD_INT 6
2723: PUSH
2724: LD_INT 6
2726: PUSH
2727: EMPTY
2728: LIST
2729: LIST
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL 23959 0 6
2737: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2738: LD_ADDR_EXP 58
2742: PUSH
2743: LD_EXP 58
2747: PPUSH
2748: LD_INT 2
2750: PPUSH
2751: LD_EXP 49
2755: PPUSH
2756: CALL_OW 1
2760: ST_TO_ADDR
// tmp := [ ] ;
2761: LD_ADDR_VAR 0 4
2765: PUSH
2766: EMPTY
2767: ST_TO_ADDR
// for i = 1 to 4 do
2768: LD_ADDR_VAR 0 2
2772: PUSH
2773: DOUBLE
2774: LD_INT 1
2776: DEC
2777: ST_TO_ADDR
2778: LD_INT 4
2780: PUSH
2781: FOR_TO
2782: IFFALSE 2875
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2784: LD_INT 22
2786: PPUSH
2787: LD_INT 3
2789: PPUSH
2790: LD_INT 3
2792: PPUSH
2793: LD_INT 43
2795: PUSH
2796: LD_INT 45
2798: PUSH
2799: LD_INT 45
2801: PUSH
2802: LD_INT 44
2804: PUSH
2805: EMPTY
2806: LIST
2807: LIST
2808: LIST
2809: LIST
2810: PUSH
2811: LD_VAR 0 2
2815: PUSH
2816: LD_INT 4
2818: MOD
2819: PUSH
2820: LD_INT 1
2822: PLUS
2823: ARRAY
2824: PPUSH
2825: LD_INT 100
2827: PPUSH
2828: CALL 20550 0 5
// veh := CreateVehicle ;
2832: LD_ADDR_VAR 0 3
2836: PUSH
2837: CALL_OW 45
2841: ST_TO_ADDR
// tmp := tmp ^ veh ;
2842: LD_ADDR_VAR 0 4
2846: PUSH
2847: LD_VAR 0 4
2851: PUSH
2852: LD_VAR 0 3
2856: ADD
2857: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2858: LD_VAR 0 3
2862: PPUSH
2863: LD_INT 2
2865: PPUSH
2866: LD_INT 0
2868: PPUSH
2869: CALL_OW 49
// end ;
2873: GO 2781
2875: POP
2876: POP
// russian_guard := tmp ;
2877: LD_ADDR_EXP 50
2881: PUSH
2882: LD_VAR 0 4
2886: ST_TO_ADDR
// end ;
2887: LD_VAR 0 1
2891: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2892: LD_INT 47
2894: PPUSH
2895: CALL_OW 302
2899: PUSH
2900: LD_EXP 6
2904: AND
2905: IFFALSE 3507
2907: GO 2909
2909: DISABLE
2910: LD_INT 0
2912: PPUSH
2913: PPUSH
2914: PPUSH
2915: PPUSH
2916: PPUSH
2917: PPUSH
// begin enable ;
2918: ENABLE
// base := 2 ;
2919: LD_ADDR_VAR 0 2
2923: PUSH
2924: LD_INT 2
2926: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2927: LD_ADDR_VAR 0 4
2931: PUSH
2932: LD_INT 0
2934: PUSH
2935: LD_INT 0
2937: PUSH
2938: LD_INT 0
2940: PUSH
2941: LD_INT 0
2943: PUSH
2944: LD_INT 0
2946: PUSH
2947: LD_INT 0
2949: PUSH
2950: LD_INT 0
2952: PUSH
2953: LD_INT 0
2955: PUSH
2956: LD_INT 1
2958: PUSH
2959: LD_INT 0
2961: PUSH
2962: EMPTY
2963: LIST
2964: LIST
2965: LIST
2966: LIST
2967: LIST
2968: LIST
2969: LIST
2970: LIST
2971: LIST
2972: LIST
2973: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2974: LD_ADDR_VAR 0 3
2978: PUSH
2979: LD_INT 22
2981: PUSH
2982: LD_INT 1
2984: PUSH
2985: LD_INT 3
2987: PUSH
2988: LD_INT 45
2990: PUSH
2991: EMPTY
2992: LIST
2993: LIST
2994: LIST
2995: LIST
2996: PUSH
2997: LD_INT 21
2999: PUSH
3000: LD_INT 1
3002: PUSH
3003: LD_INT 3
3005: PUSH
3006: LD_INT 45
3008: PUSH
3009: EMPTY
3010: LIST
3011: LIST
3012: LIST
3013: LIST
3014: PUSH
3015: LD_INT 22
3017: PUSH
3018: LD_INT 1
3020: PUSH
3021: LD_INT 3
3023: PUSH
3024: LD_INT 45
3026: PUSH
3027: EMPTY
3028: LIST
3029: LIST
3030: LIST
3031: LIST
3032: PUSH
3033: LD_INT 23
3035: PUSH
3036: LD_INT 1
3038: PUSH
3039: LD_INT 3
3041: PUSH
3042: LD_INT 46
3044: PUSH
3045: EMPTY
3046: LIST
3047: LIST
3048: LIST
3049: LIST
3050: PUSH
3051: EMPTY
3052: LIST
3053: LIST
3054: LIST
3055: LIST
3056: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3057: LD_ADDR_VAR 0 1
3061: PUSH
3062: DOUBLE
3063: LD_INT 1
3065: DEC
3066: ST_TO_ADDR
3067: LD_OWVAR 67
3071: PUSH
3072: LD_OWVAR 1
3076: PUSH
3077: LD_INT 21000
3079: DIV
3080: PLUS
3081: PUSH
3082: FOR_TO
3083: IFFALSE 3171
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3085: LD_ADDR_VAR 0 3
3089: PUSH
3090: LD_VAR 0 3
3094: PPUSH
3095: LD_VAR 0 3
3099: PUSH
3100: LD_INT 1
3102: PLUS
3103: PPUSH
3104: LD_INT 23
3106: PUSH
3107: LD_INT 24
3109: PUSH
3110: EMPTY
3111: LIST
3112: LIST
3113: PUSH
3114: LD_INT 1
3116: PPUSH
3117: LD_INT 2
3119: PPUSH
3120: CALL_OW 12
3124: ARRAY
3125: PUSH
3126: LD_INT 1
3128: PUSH
3129: LD_INT 3
3131: PUSH
3132: LD_INT 46
3134: PUSH
3135: LD_INT 47
3137: PUSH
3138: LD_INT 45
3140: PUSH
3141: EMPTY
3142: LIST
3143: LIST
3144: LIST
3145: PUSH
3146: LD_INT 1
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: CALL_OW 12
3156: ARRAY
3157: PUSH
3158: EMPTY
3159: LIST
3160: LIST
3161: LIST
3162: LIST
3163: PPUSH
3164: CALL_OW 2
3168: ST_TO_ADDR
3169: GO 3082
3171: POP
3172: POP
// MC_InsertProduceList ( base , tmp ) ;
3173: LD_VAR 0 2
3177: PPUSH
3178: LD_VAR 0 3
3182: PPUSH
3183: CALL 79767 0 2
// repeat wait ( 0 0$1 ) ;
3187: LD_INT 35
3189: PPUSH
3190: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3194: LD_EXP 77
3198: PUSH
3199: LD_VAR 0 2
3203: ARRAY
3204: PUSH
3205: LD_INT 6
3207: GREATER
3208: IFFALSE 3187
// wait ( 0 0$20 ) ;
3210: LD_INT 700
3212: PPUSH
3213: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3217: LD_ADDR_VAR 0 5
3221: PUSH
3222: LD_INT 71
3224: PUSH
3225: LD_INT 19
3227: PUSH
3228: EMPTY
3229: LIST
3230: LIST
3231: PUSH
3232: LD_INT 91
3234: PUSH
3235: LD_INT 67
3237: PUSH
3238: EMPTY
3239: LIST
3240: LIST
3241: PUSH
3242: LD_INT 52
3244: PUSH
3245: LD_INT 44
3247: PUSH
3248: EMPTY
3249: LIST
3250: LIST
3251: PUSH
3252: LD_INT 68
3254: PUSH
3255: LD_INT 48
3257: PUSH
3258: EMPTY
3259: LIST
3260: LIST
3261: PUSH
3262: EMPTY
3263: LIST
3264: LIST
3265: LIST
3266: LIST
3267: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3268: LD_ADDR_VAR 0 6
3272: PUSH
3273: LD_EXP 77
3277: PUSH
3278: LD_VAR 0 2
3282: ARRAY
3283: PUSH
3284: LD_EXP 77
3288: PUSH
3289: LD_VAR 0 2
3293: ARRAY
3294: PPUSH
3295: LD_INT 2
3297: PUSH
3298: LD_INT 34
3300: PUSH
3301: LD_INT 51
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: PUSH
3308: LD_INT 34
3310: PUSH
3311: LD_INT 52
3313: PUSH
3314: EMPTY
3315: LIST
3316: LIST
3317: PUSH
3318: EMPTY
3319: LIST
3320: LIST
3321: LIST
3322: PPUSH
3323: CALL_OW 72
3327: DIFF
3328: ST_TO_ADDR
// if not attackers then
3329: LD_VAR 0 6
3333: NOT
3334: IFFALSE 3338
// exit ;
3336: GO 3507
// ru_attackers := attackers ;
3338: LD_ADDR_EXP 51
3342: PUSH
3343: LD_VAR 0 6
3347: ST_TO_ADDR
// for i = 1 to attackers do
3348: LD_ADDR_VAR 0 1
3352: PUSH
3353: DOUBLE
3354: LD_INT 1
3356: DEC
3357: ST_TO_ADDR
3358: LD_VAR 0 6
3362: PUSH
3363: FOR_TO
3364: IFFALSE 3441
// begin case i mod 3 of 0 :
3366: LD_VAR 0 1
3370: PUSH
3371: LD_INT 3
3373: MOD
3374: PUSH
3375: LD_INT 0
3377: DOUBLE
3378: EQUAL
3379: IFTRUE 3383
3381: GO 3386
3383: POP
// ; 1 :
3384: GO 3439
3386: LD_INT 1
3388: DOUBLE
3389: EQUAL
3390: IFTRUE 3394
3392: GO 3412
3394: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3395: LD_VAR 0 1
3399: PPUSH
3400: LD_INT 32
3402: PPUSH
3403: LD_INT 49
3405: PPUSH
3406: CALL_OW 114
3410: GO 3439
3412: LD_INT 2
3414: DOUBLE
3415: EQUAL
3416: IFTRUE 3420
3418: GO 3438
3420: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3421: LD_VAR 0 1
3425: PPUSH
3426: LD_INT 117
3428: PPUSH
3429: LD_INT 107
3431: PPUSH
3432: CALL_OW 114
3436: GO 3439
3438: POP
// end ;
3439: GO 3363
3441: POP
3442: POP
// repeat wait ( 0 0$1 ) ;
3443: LD_INT 35
3445: PPUSH
3446: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3450: LD_VAR 0 6
3454: PPUSH
3455: LD_INT 60
3457: PUSH
3458: EMPTY
3459: LIST
3460: PPUSH
3461: CALL_OW 72
3465: NOT
3466: IFFALSE 3443
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3468: LD_VAR 0 2
3472: PPUSH
3473: LD_VAR 0 6
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: LD_VAR 0 4
3487: PPUSH
3488: CALL 79952 0 4
// if not first_attack then
3492: LD_EXP 7
3496: NOT
3497: IFFALSE 3507
// first_attack := true ;
3499: LD_ADDR_EXP 7
3503: PUSH
3504: LD_INT 1
3506: ST_TO_ADDR
// end ; end_of_file
3507: PPOPN 6
3509: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3510: LD_INT 0
3512: PPUSH
3513: PPUSH
3514: PPUSH
3515: PPUSH
3516: PPUSH
3517: PPUSH
3518: PPUSH
// uc_side := 2 ;
3519: LD_ADDR_OWVAR 20
3523: PUSH
3524: LD_INT 2
3526: ST_TO_ADDR
// uc_nation := 2 ;
3527: LD_ADDR_OWVAR 21
3531: PUSH
3532: LD_INT 2
3534: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3535: LD_ADDR_EXP 54
3539: PUSH
3540: LD_STRING Abdul
3542: PPUSH
3543: CALL_OW 25
3547: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3548: LD_EXP 54
3552: PPUSH
3553: LD_INT 11
3555: PPUSH
3556: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3560: LD_EXP 54
3564: PPUSH
3565: LD_INT 1
3567: PPUSH
3568: CALL_OW 52
// vc_chassis := 31 ;
3572: LD_ADDR_OWVAR 37
3576: PUSH
3577: LD_INT 31
3579: ST_TO_ADDR
// vc_control := control_rider ;
3580: LD_ADDR_OWVAR 38
3584: PUSH
3585: LD_INT 4
3587: ST_TO_ADDR
// mastodont := CreateVehicle ;
3588: LD_ADDR_EXP 55
3592: PUSH
3593: CALL_OW 45
3597: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3598: LD_EXP 55
3602: PPUSH
3603: LD_INT 153
3605: PPUSH
3606: LD_INT 71
3608: PPUSH
3609: LD_INT 0
3611: PPUSH
3612: CALL_OW 48
// InitVc ;
3616: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3620: LD_ADDR_EXP 52
3624: PUSH
3625: LD_INT 1
3627: PPUSH
3628: LD_INT 3
3630: PPUSH
3631: LD_STRING 
3633: PPUSH
3634: LD_INT 7
3636: PUSH
3637: LD_INT 8
3639: PUSH
3640: LD_INT 9
3642: PUSH
3643: EMPTY
3644: LIST
3645: LIST
3646: LIST
3647: PUSH
3648: LD_OWVAR 67
3652: ARRAY
3653: PPUSH
3654: LD_INT 5000
3656: PUSH
3657: LD_INT 1000
3659: PUSH
3660: LD_INT 300
3662: PUSH
3663: EMPTY
3664: LIST
3665: LIST
3666: LIST
3667: PPUSH
3668: LD_INT 22
3670: PUSH
3671: LD_INT 5
3673: PUSH
3674: LD_INT 6
3676: PUSH
3677: LD_INT 9
3679: PUSH
3680: EMPTY
3681: LIST
3682: LIST
3683: LIST
3684: LIST
3685: PPUSH
3686: CALL 23959 0 6
3690: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3691: LD_ADDR_EXP 58
3695: PUSH
3696: LD_EXP 58
3700: PPUSH
3701: LD_INT 1
3703: PPUSH
3704: LD_EXP 52
3708: PPUSH
3709: CALL_OW 1
3713: ST_TO_ADDR
// tmp := [ ] ;
3714: LD_ADDR_VAR 0 4
3718: PUSH
3719: EMPTY
3720: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3721: LD_ADDR_OWVAR 37
3725: PUSH
3726: LD_INT 14
3728: ST_TO_ADDR
// vc_engine := engine_siberite ;
3729: LD_ADDR_OWVAR 39
3733: PUSH
3734: LD_INT 3
3736: ST_TO_ADDR
// vc_control := control_manual ;
3737: LD_ADDR_OWVAR 38
3741: PUSH
3742: LD_INT 1
3744: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3745: LD_ADDR_OWVAR 40
3749: PUSH
3750: LD_INT 31
3752: ST_TO_ADDR
// for i = 1 to 3 do
3753: LD_ADDR_VAR 0 2
3757: PUSH
3758: DOUBLE
3759: LD_INT 1
3761: DEC
3762: ST_TO_ADDR
3763: LD_INT 3
3765: PUSH
3766: FOR_TO
3767: IFFALSE 4011
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3769: LD_ADDR_VAR 0 5
3773: PUSH
3774: LD_INT 153
3776: PUSH
3777: LD_INT 71
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: LD_INT 155
3786: PUSH
3787: LD_INT 81
3789: PUSH
3790: EMPTY
3791: LIST
3792: LIST
3793: PUSH
3794: EMPTY
3795: LIST
3796: LIST
3797: PUSH
3798: LD_VAR 0 2
3802: PUSH
3803: LD_INT 2
3805: MOD
3806: PUSH
3807: LD_INT 1
3809: PLUS
3810: ARRAY
3811: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3812: LD_INT 0
3814: PPUSH
3815: LD_INT 3
3817: PPUSH
3818: LD_INT 7
3820: PUSH
3821: LD_INT 8
3823: PUSH
3824: LD_INT 9
3826: PUSH
3827: EMPTY
3828: LIST
3829: LIST
3830: LIST
3831: PUSH
3832: LD_OWVAR 67
3836: ARRAY
3837: PPUSH
3838: CALL_OW 380
// un := CreateVehicle ;
3842: LD_ADDR_VAR 0 6
3846: PUSH
3847: CALL_OW 45
3851: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3852: LD_VAR 0 6
3856: PPUSH
3857: LD_INT 0
3859: PPUSH
3860: LD_INT 5
3862: PPUSH
3863: CALL_OW 12
3867: PPUSH
3868: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3872: LD_VAR 0 6
3876: PPUSH
3877: LD_VAR 0 5
3881: PUSH
3882: LD_INT 1
3884: ARRAY
3885: PPUSH
3886: LD_VAR 0 5
3890: PUSH
3891: LD_INT 2
3893: ARRAY
3894: PPUSH
3895: LD_INT 6
3897: PPUSH
3898: LD_INT 0
3900: PPUSH
3901: CALL_OW 50
// un2 := CreateHuman ;
3905: LD_ADDR_VAR 0 7
3909: PUSH
3910: CALL_OW 44
3914: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3915: LD_VAR 0 7
3919: PPUSH
3920: LD_VAR 0 6
3924: PPUSH
3925: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3929: LD_ADDR_EXP 58
3933: PUSH
3934: LD_EXP 58
3938: PPUSH
3939: LD_INT 1
3941: PUSH
3942: LD_EXP 58
3946: PUSH
3947: LD_INT 1
3949: ARRAY
3950: PUSH
3951: LD_INT 1
3953: PLUS
3954: PUSH
3955: EMPTY
3956: LIST
3957: LIST
3958: PPUSH
3959: LD_VAR 0 6
3963: PPUSH
3964: CALL 20672 0 3
3968: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3969: LD_ADDR_EXP 58
3973: PUSH
3974: LD_EXP 58
3978: PPUSH
3979: LD_INT 1
3981: PUSH
3982: LD_EXP 58
3986: PUSH
3987: LD_INT 1
3989: ARRAY
3990: PUSH
3991: LD_INT 1
3993: PLUS
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PPUSH
3999: LD_VAR 0 7
4003: PPUSH
4004: CALL 20672 0 3
4008: ST_TO_ADDR
// end ;
4009: GO 3766
4011: POP
4012: POP
// for i = 1 to 5 do
4013: LD_ADDR_VAR 0 2
4017: PUSH
4018: DOUBLE
4019: LD_INT 1
4021: DEC
4022: ST_TO_ADDR
4023: LD_INT 5
4025: PUSH
4026: FOR_TO
4027: IFFALSE 4120
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4029: LD_INT 14
4031: PPUSH
4032: LD_INT 3
4034: PPUSH
4035: LD_INT 1
4037: PPUSH
4038: LD_INT 25
4040: PUSH
4041: LD_INT 28
4043: PUSH
4044: LD_INT 28
4046: PUSH
4047: LD_INT 26
4049: PUSH
4050: EMPTY
4051: LIST
4052: LIST
4053: LIST
4054: LIST
4055: PUSH
4056: LD_VAR 0 2
4060: PUSH
4061: LD_INT 4
4063: MOD
4064: PUSH
4065: LD_INT 1
4067: PLUS
4068: ARRAY
4069: PPUSH
4070: LD_INT 100
4072: PPUSH
4073: CALL 20550 0 5
// veh := CreateVehicle ;
4077: LD_ADDR_VAR 0 3
4081: PUSH
4082: CALL_OW 45
4086: ST_TO_ADDR
// tmp := tmp ^ veh ;
4087: LD_ADDR_VAR 0 4
4091: PUSH
4092: LD_VAR 0 4
4096: PUSH
4097: LD_VAR 0 3
4101: ADD
4102: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4103: LD_VAR 0 3
4107: PPUSH
4108: LD_INT 1
4110: PPUSH
4111: LD_INT 0
4113: PPUSH
4114: CALL_OW 49
// end ;
4118: GO 4026
4120: POP
4121: POP
// arabian_guard := tmp ;
4122: LD_ADDR_EXP 53
4126: PUSH
4127: LD_VAR 0 4
4131: ST_TO_ADDR
// end ;
4132: LD_VAR 0 1
4136: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4137: LD_INT 22
4139: PUSH
4140: LD_INT 7
4142: PUSH
4143: EMPTY
4144: LIST
4145: LIST
4146: PUSH
4147: LD_INT 91
4149: PUSH
4150: LD_INT 1
4152: PUSH
4153: LD_INT 12
4155: PUSH
4156: EMPTY
4157: LIST
4158: LIST
4159: LIST
4160: PUSH
4161: EMPTY
4162: LIST
4163: LIST
4164: PPUSH
4165: CALL_OW 69
4169: PUSH
4170: LD_EXP 55
4174: PPUSH
4175: CALL_OW 256
4179: PUSH
4180: LD_INT 990
4182: LESS
4183: OR
4184: PUSH
4185: LD_EXP 54
4189: PPUSH
4190: CALL_OW 256
4194: PUSH
4195: LD_INT 990
4197: LESS
4198: OR
4199: IFFALSE 4342
4201: GO 4203
4203: DISABLE
// begin if IsInUnit ( Abdul ) then
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 310
4213: IFFALSE 4224
// ComExitBuilding ( Abdul ) ;
4215: LD_EXP 54
4219: PPUSH
4220: CALL_OW 122
// if Mastodont then
4224: LD_EXP 55
4228: IFFALSE 4245
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4230: LD_EXP 55
4234: PPUSH
4235: LD_INT 205
4237: PPUSH
4238: LD_INT 132
4240: PPUSH
4241: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4245: LD_EXP 54
4249: PPUSH
4250: LD_INT 205
4252: PPUSH
4253: LD_INT 132
4255: PPUSH
4256: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4260: LD_INT 35
4262: PPUSH
4263: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4267: LD_EXP 54
4271: PPUSH
4272: LD_INT 21
4274: PPUSH
4275: CALL_OW 308
4279: IFFALSE 4260
// RemoveUnit ( Abdul ) ;
4281: LD_EXP 54
4285: PPUSH
4286: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4290: LD_INT 35
4292: PPUSH
4293: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4297: LD_EXP 55
4301: PPUSH
4302: LD_INT 21
4304: PPUSH
4305: CALL_OW 308
4309: PUSH
4310: LD_EXP 55
4314: PPUSH
4315: CALL_OW 301
4319: OR
4320: IFFALSE 4290
// if IsOk ( Mastodont ) then
4322: LD_EXP 55
4326: PPUSH
4327: CALL_OW 302
4331: IFFALSE 4342
// RemoveUnit ( Mastodont ) ;
4333: LD_EXP 55
4337: PPUSH
4338: CALL_OW 64
// end ;
4342: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4343: LD_EXP 54
4347: PPUSH
4348: CALL_OW 301
4352: PUSH
4353: LD_INT 22
4355: PUSH
4356: LD_INT 2
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 2
4365: PUSH
4366: LD_INT 25
4368: PUSH
4369: LD_INT 1
4371: PUSH
4372: EMPTY
4373: LIST
4374: LIST
4375: PUSH
4376: LD_INT 25
4378: PUSH
4379: LD_INT 2
4381: PUSH
4382: EMPTY
4383: LIST
4384: LIST
4385: PUSH
4386: LD_INT 25
4388: PUSH
4389: LD_INT 3
4391: PUSH
4392: EMPTY
4393: LIST
4394: LIST
4395: PUSH
4396: LD_INT 25
4398: PUSH
4399: LD_INT 4
4401: PUSH
4402: EMPTY
4403: LIST
4404: LIST
4405: PUSH
4406: LD_INT 25
4408: PUSH
4409: LD_INT 8
4411: PUSH
4412: EMPTY
4413: LIST
4414: LIST
4415: PUSH
4416: EMPTY
4417: LIST
4418: LIST
4419: LIST
4420: LIST
4421: LIST
4422: LIST
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PPUSH
4428: CALL_OW 69
4432: PUSH
4433: LD_INT 16
4435: PUSH
4436: LD_INT 19
4438: PUSH
4439: LD_INT 22
4441: PUSH
4442: EMPTY
4443: LIST
4444: LIST
4445: LIST
4446: PUSH
4447: LD_OWVAR 67
4451: ARRAY
4452: LESS
4453: OR
4454: IFFALSE 5127
4456: GO 4458
4458: DISABLE
4459: LD_INT 0
4461: PPUSH
4462: PPUSH
4463: PPUSH
4464: PPUSH
4465: PPUSH
4466: PPUSH
// begin MC_Kill ( 1 ) ;
4467: LD_INT 1
4469: PPUSH
4470: CALL 56723 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4474: LD_ADDR_VAR 0 2
4478: PUSH
4479: LD_INT 22
4481: PUSH
4482: LD_INT 2
4484: PUSH
4485: EMPTY
4486: LIST
4487: LIST
4488: PUSH
4489: LD_INT 2
4491: PUSH
4492: LD_INT 25
4494: PUSH
4495: LD_INT 1
4497: PUSH
4498: EMPTY
4499: LIST
4500: LIST
4501: PUSH
4502: LD_INT 25
4504: PUSH
4505: LD_INT 2
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: PUSH
4512: LD_INT 25
4514: PUSH
4515: LD_INT 3
4517: PUSH
4518: EMPTY
4519: LIST
4520: LIST
4521: PUSH
4522: LD_INT 25
4524: PUSH
4525: LD_INT 4
4527: PUSH
4528: EMPTY
4529: LIST
4530: LIST
4531: PUSH
4532: LD_INT 25
4534: PUSH
4535: LD_INT 8
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PUSH
4542: EMPTY
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: PUSH
4550: EMPTY
4551: LIST
4552: LIST
4553: PPUSH
4554: CALL_OW 69
4558: ST_TO_ADDR
// for i in tmp do
4559: LD_ADDR_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: PUSH
4569: FOR_IN
4570: IFFALSE 4586
// SetTag ( i , 10 ) ;
4572: LD_VAR 0 5
4576: PPUSH
4577: LD_INT 10
4579: PPUSH
4580: CALL_OW 109
4584: GO 4569
4586: POP
4587: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4588: LD_ADDR_VAR 0 3
4592: PUSH
4593: LD_INT 22
4595: PUSH
4596: LD_INT 2
4598: PUSH
4599: EMPTY
4600: LIST
4601: LIST
4602: PUSH
4603: LD_INT 21
4605: PUSH
4606: LD_INT 1
4608: PUSH
4609: EMPTY
4610: LIST
4611: LIST
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: PPUSH
4617: CALL_OW 69
4621: PUSH
4622: LD_VAR 0 2
4626: DIFF
4627: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4628: LD_ADDR_VAR 0 1
4632: PUSH
4633: LD_INT 22
4635: PUSH
4636: LD_INT 2
4638: PUSH
4639: EMPTY
4640: LIST
4641: LIST
4642: PUSH
4643: LD_INT 21
4645: PUSH
4646: LD_INT 2
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 24
4655: PUSH
4656: LD_INT 300
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: EMPTY
4664: LIST
4665: LIST
4666: LIST
4667: PPUSH
4668: CALL_OW 69
4672: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4673: LD_ADDR_VAR 0 4
4677: PUSH
4678: LD_VAR 0 1
4682: PPUSH
4683: LD_INT 33
4685: PUSH
4686: LD_INT 1
4688: PUSH
4689: EMPTY
4690: LIST
4691: LIST
4692: PUSH
4693: LD_INT 58
4695: PUSH
4696: EMPTY
4697: LIST
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 72
4707: ST_TO_ADDR
// for i in tmp do
4708: LD_ADDR_VAR 0 5
4712: PUSH
4713: LD_VAR 0 2
4717: PUSH
4718: FOR_IN
4719: IFFALSE 4903
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4721: LD_VAR 0 5
4725: PUSH
4726: LD_INT 55
4728: PUSH
4729: EMPTY
4730: LIST
4731: PPUSH
4732: CALL_OW 69
4736: IN
4737: IFFALSE 4756
// begin AddComMoveXY ( i , 209 , 132 ) ;
4739: LD_VAR 0 5
4743: PPUSH
4744: LD_INT 209
4746: PPUSH
4747: LD_INT 132
4749: PPUSH
4750: CALL_OW 171
// continue ;
4754: GO 4718
// end ; if IsInUnit ( i ) then
4756: LD_VAR 0 5
4760: PPUSH
4761: CALL_OW 310
4765: IFFALSE 4783
// begin ComExitBuilding ( i ) ;
4767: LD_VAR 0 5
4771: PPUSH
4772: CALL_OW 122
// wait ( 3 ) ;
4776: LD_INT 3
4778: PPUSH
4779: CALL_OW 67
// end ; if tmp_empty then
4783: LD_VAR 0 4
4787: IFFALSE 4886
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4789: LD_VAR 0 5
4793: PPUSH
4794: LD_VAR 0 4
4798: PPUSH
4799: LD_VAR 0 5
4803: PPUSH
4804: CALL_OW 74
4808: PPUSH
4809: CALL_OW 296
4813: PUSH
4814: LD_INT 25
4816: LESS
4817: IFFALSE 4886
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4819: LD_ADDR_VAR 0 6
4823: PUSH
4824: LD_VAR 0 4
4828: PPUSH
4829: LD_VAR 0 5
4833: PPUSH
4834: CALL_OW 74
4838: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4839: LD_VAR 0 5
4843: PPUSH
4844: LD_VAR 0 6
4848: PPUSH
4849: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4853: LD_VAR 0 5
4857: PPUSH
4858: LD_INT 209
4860: PPUSH
4861: LD_INT 132
4863: PPUSH
4864: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4868: LD_ADDR_VAR 0 4
4872: PUSH
4873: LD_VAR 0 4
4877: PUSH
4878: LD_VAR 0 6
4882: DIFF
4883: ST_TO_ADDR
// continue ;
4884: GO 4718
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4886: LD_VAR 0 5
4890: PPUSH
4891: LD_INT 201
4893: PPUSH
4894: LD_INT 132
4896: PPUSH
4897: CALL_OW 171
// end ;
4901: GO 4718
4903: POP
4904: POP
// for i in tmp_ape do
4905: LD_ADDR_VAR 0 5
4909: PUSH
4910: LD_VAR 0 3
4914: PUSH
4915: FOR_IN
4916: IFFALSE 4955
// begin if IsInUnit ( i ) then
4918: LD_VAR 0 5
4922: PPUSH
4923: CALL_OW 310
4927: IFFALSE 4938
// ComExitBuilding ( i ) ;
4929: LD_VAR 0 5
4933: PPUSH
4934: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4938: LD_VAR 0 5
4942: PPUSH
4943: LD_INT 201
4945: PPUSH
4946: LD_INT 132
4948: PPUSH
4949: CALL_OW 171
// end ;
4953: GO 4915
4955: POP
4956: POP
// repeat wait ( 0 0$1 ) ;
4957: LD_INT 35
4959: PPUSH
4960: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4964: LD_ADDR_VAR 0 5
4968: PUSH
4969: LD_VAR 0 2
4973: PUSH
4974: LD_VAR 0 3
4978: UNION
4979: PUSH
4980: LD_VAR 0 1
4984: UNION
4985: PUSH
4986: FOR_IN
4987: IFFALSE 5018
// if not HasTask ( i ) then
4989: LD_VAR 0 5
4993: PPUSH
4994: CALL_OW 314
4998: NOT
4999: IFFALSE 5016
// ComMoveXY ( i , 201 , 132 ) ;
5001: LD_VAR 0 5
5005: PPUSH
5006: LD_INT 201
5008: PPUSH
5009: LD_INT 132
5011: PPUSH
5012: CALL_OW 111
5016: GO 4986
5018: POP
5019: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5020: LD_INT 21
5022: PPUSH
5023: LD_INT 22
5025: PUSH
5026: LD_INT 2
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: PPUSH
5033: CALL_OW 70
5037: IFFALSE 5078
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5039: LD_ADDR_VAR 0 5
5043: PUSH
5044: LD_INT 21
5046: PPUSH
5047: LD_INT 22
5049: PUSH
5050: LD_INT 2
5052: PUSH
5053: EMPTY
5054: LIST
5055: LIST
5056: PPUSH
5057: CALL_OW 70
5061: PUSH
5062: FOR_IN
5063: IFFALSE 5076
// RemoveUnit ( i ) ;
5065: LD_VAR 0 5
5069: PPUSH
5070: CALL_OW 64
5074: GO 5062
5076: POP
5077: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5078: LD_INT 22
5080: PUSH
5081: LD_INT 2
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: PUSH
5088: LD_INT 2
5090: PUSH
5091: LD_INT 21
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: EMPTY
5098: LIST
5099: LIST
5100: PUSH
5101: LD_INT 21
5103: PUSH
5104: LD_INT 2
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: PUSH
5111: EMPTY
5112: LIST
5113: LIST
5114: LIST
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PPUSH
5120: CALL_OW 69
5124: NOT
5125: IFFALSE 4957
// end ;
5127: PPOPN 6
5129: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5130: LD_EXP 9
5134: PUSH
5135: LD_INT 92
5137: PPUSH
5138: LD_INT 40
5140: PPUSH
5141: CALL_OW 428
5145: PPUSH
5146: CALL_OW 266
5150: PUSH
5151: LD_INT 30
5153: EQUAL
5154: AND
5155: IFFALSE 5351
5157: GO 5159
5159: DISABLE
5160: LD_INT 0
5162: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5163: LD_ADDR_VAR 0 1
5167: PUSH
5168: LD_EXP 58
5172: PUSH
5173: LD_INT 1
5175: ARRAY
5176: PPUSH
5177: LD_INT 25
5179: PUSH
5180: LD_INT 4
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PPUSH
5187: CALL_OW 72
5191: ST_TO_ADDR
// if not sci then
5192: LD_VAR 0 1
5196: NOT
5197: IFFALSE 5201
// exit ;
5199: GO 5351
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5201: LD_ADDR_EXP 58
5205: PUSH
5206: LD_EXP 58
5210: PPUSH
5211: LD_INT 1
5213: PPUSH
5214: LD_EXP 58
5218: PUSH
5219: LD_INT 1
5221: ARRAY
5222: PUSH
5223: LD_VAR 0 1
5227: PUSH
5228: LD_INT 1
5230: ARRAY
5231: DIFF
5232: PPUSH
5233: CALL_OW 1
5237: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5238: LD_VAR 0 1
5242: PUSH
5243: LD_INT 1
5245: ARRAY
5246: PPUSH
5247: CALL_OW 310
5251: IFFALSE 5266
// ComExitBuilding ( sci [ 1 ] ) ;
5253: LD_VAR 0 1
5257: PUSH
5258: LD_INT 1
5260: ARRAY
5261: PPUSH
5262: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5266: LD_INT 2
5268: PPUSH
5269: LD_INT 105
5271: PPUSH
5272: LD_INT 14
5274: PPUSH
5275: LD_INT 20
5277: PPUSH
5278: CALL 21568 0 4
5282: PUSH
5283: LD_INT 4
5285: ARRAY
5286: PUSH
5287: LD_INT 10
5289: LESS
5290: IFFALSE 5313
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5292: LD_VAR 0 1
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PPUSH
5301: LD_INT 105
5303: PPUSH
5304: LD_INT 14
5306: PPUSH
5307: CALL_OW 171
5311: GO 5332
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5313: LD_VAR 0 1
5317: PUSH
5318: LD_INT 1
5320: ARRAY
5321: PPUSH
5322: LD_INT 118
5324: PPUSH
5325: LD_INT 77
5327: PPUSH
5328: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 92
5343: PPUSH
5344: LD_INT 40
5346: PPUSH
5347: CALL_OW 218
// end ;
5351: PPOPN 1
5353: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5354: LD_INT 1
5356: PPUSH
5357: CALL_OW 302
5361: PUSH
5362: LD_EXP 9
5366: AND
5367: IFFALSE 5826
5369: GO 5371
5371: DISABLE
5372: LD_INT 0
5374: PPUSH
5375: PPUSH
5376: PPUSH
5377: PPUSH
5378: PPUSH
5379: PPUSH
// begin enable ;
5380: ENABLE
// base := 1 ;
5381: LD_ADDR_VAR 0 2
5385: PUSH
5386: LD_INT 1
5388: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5389: LD_ADDR_VAR 0 4
5393: PUSH
5394: LD_INT 0
5396: PUSH
5397: LD_INT 0
5399: PUSH
5400: LD_INT 0
5402: PUSH
5403: LD_INT 0
5405: PUSH
5406: LD_INT 0
5408: PUSH
5409: LD_INT 0
5411: PUSH
5412: LD_INT 0
5414: PUSH
5415: LD_INT 0
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 0
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: LIST
5430: LIST
5431: LIST
5432: LIST
5433: LIST
5434: LIST
5435: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5436: LD_ADDR_VAR 0 3
5440: PUSH
5441: LD_INT 14
5443: PUSH
5444: LD_INT 1
5446: PUSH
5447: LD_INT 2
5449: PUSH
5450: LD_INT 26
5452: PUSH
5453: EMPTY
5454: LIST
5455: LIST
5456: LIST
5457: LIST
5458: PUSH
5459: LD_INT 14
5461: PUSH
5462: LD_INT 1
5464: PUSH
5465: LD_INT 2
5467: PUSH
5468: LD_INT 28
5470: PUSH
5471: EMPTY
5472: LIST
5473: LIST
5474: LIST
5475: LIST
5476: PUSH
5477: LD_INT 13
5479: PUSH
5480: LD_INT 1
5482: PUSH
5483: LD_INT 2
5485: PUSH
5486: LD_INT 29
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: LIST
5493: LIST
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: LIST
5499: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5500: LD_ADDR_VAR 0 1
5504: PUSH
5505: DOUBLE
5506: LD_INT 1
5508: DEC
5509: ST_TO_ADDR
5510: LD_OWVAR 67
5514: PUSH
5515: LD_OWVAR 1
5519: PUSH
5520: LD_INT 21000
5522: DIV
5523: PLUS
5524: PUSH
5525: FOR_TO
5526: IFFALSE 5618
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_VAR 0 3
5537: PPUSH
5538: LD_VAR 0 3
5542: PUSH
5543: LD_INT 1
5545: PLUS
5546: PPUSH
5547: LD_INT 13
5549: PUSH
5550: LD_INT 14
5552: PUSH
5553: EMPTY
5554: LIST
5555: LIST
5556: PUSH
5557: LD_INT 1
5559: PPUSH
5560: LD_INT 2
5562: PPUSH
5563: CALL_OW 12
5567: ARRAY
5568: PUSH
5569: LD_INT 1
5571: PUSH
5572: LD_INT 2
5574: PUSH
5575: LD_INT 28
5577: PUSH
5578: LD_INT 29
5580: PUSH
5581: LD_INT 25
5583: PUSH
5584: LD_INT 26
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: LIST
5592: PUSH
5593: LD_INT 1
5595: PPUSH
5596: LD_INT 4
5598: PPUSH
5599: CALL_OW 12
5603: ARRAY
5604: PUSH
5605: EMPTY
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: PPUSH
5611: CALL_OW 2
5615: ST_TO_ADDR
5616: GO 5525
5618: POP
5619: POP
// MC_InsertProduceList ( base , tmp ) ;
5620: LD_VAR 0 2
5624: PPUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: CALL 79767 0 2
// repeat wait ( 0 0$1 ) ;
5634: LD_INT 35
5636: PPUSH
5637: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5641: LD_EXP 77
5645: PUSH
5646: LD_VAR 0 2
5650: ARRAY
5651: PUSH
5652: LD_INT 6
5654: GREATER
5655: IFFALSE 5634
// wait ( 0 0$20 ) ;
5657: LD_INT 700
5659: PPUSH
5660: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5664: LD_ADDR_VAR 0 5
5668: PUSH
5669: LD_INT 124
5671: PUSH
5672: LD_INT 85
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 90
5681: PUSH
5682: LD_INT 61
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: PUSH
5689: LD_INT 69
5691: PUSH
5692: LD_INT 48
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: LD_INT 68
5701: PUSH
5702: LD_INT 48
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: EMPTY
5710: LIST
5711: LIST
5712: LIST
5713: LIST
5714: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5715: LD_ADDR_VAR 0 6
5719: PUSH
5720: LD_EXP 77
5724: PUSH
5725: LD_VAR 0 2
5729: ARRAY
5730: PUSH
5731: LD_EXP 77
5735: PUSH
5736: LD_VAR 0 2
5740: ARRAY
5741: PPUSH
5742: LD_INT 34
5744: PUSH
5745: LD_INT 32
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: PPUSH
5752: CALL_OW 72
5756: DIFF
5757: ST_TO_ADDR
// if not attackers then
5758: LD_VAR 0 6
5762: NOT
5763: IFFALSE 5767
// exit ;
5765: GO 5826
// ar_attackers := attackers ;
5767: LD_ADDR_EXP 10
5771: PUSH
5772: LD_VAR 0 6
5776: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5784: LD_VAR 0 6
5788: PPUSH
5789: LD_INT 60
5791: PUSH
5792: EMPTY
5793: LIST
5794: PPUSH
5795: CALL_OW 72
5799: NOT
5800: IFFALSE 5777
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5802: LD_VAR 0 2
5806: PPUSH
5807: LD_VAR 0 6
5811: PPUSH
5812: LD_VAR 0 5
5816: PPUSH
5817: LD_VAR 0 4
5821: PPUSH
5822: CALL 79952 0 4
// end ;
5826: PPOPN 6
5828: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5829: LD_INT 1
5831: PPUSH
5832: CALL_OW 302
5836: PUSH
5837: LD_EXP 9
5841: AND
5842: PUSH
5843: LD_EXP 48
5847: PPUSH
5848: LD_INT 22
5850: PPUSH
5851: CALL_OW 308
5855: AND
5856: PUSH
5857: LD_INT 1
5859: PPUSH
5860: CALL 80115 0 1
5864: PUSH
5865: LD_INT 0
5867: EQUAL
5868: AND
5869: PUSH
5870: LD_EXP 10
5874: NOT
5875: AND
5876: IFFALSE 6340
5878: GO 5880
5880: DISABLE
5881: LD_INT 0
5883: PPUSH
5884: PPUSH
5885: PPUSH
5886: PPUSH
5887: PPUSH
5888: PPUSH
5889: PPUSH
// begin base := 1 ;
5890: LD_ADDR_VAR 0 2
5894: PUSH
5895: LD_INT 1
5897: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5898: LD_ADDR_VAR 0 4
5902: PUSH
5903: LD_INT 0
5905: PUSH
5906: LD_INT 0
5908: PUSH
5909: LD_INT 0
5911: PUSH
5912: LD_INT 0
5914: PUSH
5915: LD_INT 0
5917: PUSH
5918: LD_INT 0
5920: PUSH
5921: LD_INT 0
5923: PUSH
5924: LD_INT 0
5926: PUSH
5927: LD_INT 1
5929: PUSH
5930: LD_INT 0
5932: PUSH
5933: EMPTY
5934: LIST
5935: LIST
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: LIST
5943: LIST
5944: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 13
5952: PUSH
5953: LD_INT 1
5955: PUSH
5956: LD_INT 2
5958: PUSH
5959: LD_INT 28
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: LIST
5967: PUSH
5968: LD_INT 13
5970: PUSH
5971: LD_INT 1
5973: PUSH
5974: LD_INT 2
5976: PUSH
5977: LD_INT 27
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PUSH
5986: LD_INT 13
5988: PUSH
5989: LD_INT 1
5991: PUSH
5992: LD_INT 2
5994: PUSH
5995: LD_INT 25
5997: PUSH
5998: EMPTY
5999: LIST
6000: LIST
6001: LIST
6002: LIST
6003: PUSH
6004: LD_INT 11
6006: PUSH
6007: LD_INT 2
6009: PUSH
6010: LD_INT 2
6012: PUSH
6013: LD_INT 24
6015: PUSH
6016: EMPTY
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: PUSH
6022: LD_INT 11
6024: PUSH
6025: LD_INT 2
6027: PUSH
6028: LD_INT 2
6030: PUSH
6031: LD_INT 24
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6047: LD_VAR 0 2
6051: PPUSH
6052: LD_VAR 0 3
6056: PPUSH
6057: CALL 79767 0 2
// repeat wait ( 0 0$1 ) ;
6061: LD_INT 35
6063: PPUSH
6064: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6068: LD_EXP 77
6072: PUSH
6073: LD_VAR 0 2
6077: ARRAY
6078: PUSH
6079: LD_INT 6
6081: GREATEREQUAL
6082: IFFALSE 6061
// wait ( 0 0$20 ) ;
6084: LD_INT 700
6086: PPUSH
6087: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 119
6098: PUSH
6099: LD_INT 9
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: EMPTY
6107: LIST
6108: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6109: LD_ADDR_VAR 0 6
6113: PUSH
6114: LD_EXP 77
6118: PUSH
6119: LD_VAR 0 2
6123: ARRAY
6124: PUSH
6125: LD_EXP 77
6129: PUSH
6130: LD_VAR 0 2
6134: ARRAY
6135: PPUSH
6136: LD_INT 34
6138: PUSH
6139: LD_INT 32
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: PPUSH
6146: CALL_OW 72
6150: DIFF
6151: ST_TO_ADDR
// if not attackers then
6152: LD_VAR 0 6
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 6340
// uc_side := 2 ;
6161: LD_ADDR_OWVAR 20
6165: PUSH
6166: LD_INT 2
6168: ST_TO_ADDR
// uc_nation := 2 ;
6169: LD_ADDR_OWVAR 21
6173: PUSH
6174: LD_INT 2
6176: ST_TO_ADDR
// InitHc ;
6177: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6181: LD_ADDR_VAR 0 1
6185: PUSH
6186: DOUBLE
6187: LD_INT 1
6189: DEC
6190: ST_TO_ADDR
6191: LD_INT 4
6193: PUSH
6194: LD_INT 5
6196: PUSH
6197: LD_INT 6
6199: PUSH
6200: EMPTY
6201: LIST
6202: LIST
6203: LIST
6204: PUSH
6205: LD_OWVAR 67
6209: ARRAY
6210: PUSH
6211: FOR_TO
6212: IFFALSE 6289
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6214: LD_INT 0
6216: PPUSH
6217: LD_INT 15
6219: PUSH
6220: LD_INT 17
6222: PUSH
6223: EMPTY
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 1
6229: PPUSH
6230: LD_INT 2
6232: PPUSH
6233: CALL_OW 12
6237: ARRAY
6238: PPUSH
6239: LD_INT 8
6241: PPUSH
6242: CALL_OW 380
// un := CreateHuman ;
6246: LD_ADDR_VAR 0 7
6250: PUSH
6251: CALL_OW 44
6255: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6256: LD_VAR 0 7
6260: PPUSH
6261: LD_INT 23
6263: PPUSH
6264: LD_INT 0
6266: PPUSH
6267: CALL_OW 49
// attackers := attackers union un ;
6271: LD_ADDR_VAR 0 6
6275: PUSH
6276: LD_VAR 0 6
6280: PUSH
6281: LD_VAR 0 7
6285: UNION
6286: ST_TO_ADDR
// end ;
6287: GO 6211
6289: POP
6290: POP
// repeat wait ( 0 0$1 ) ;
6291: LD_INT 35
6293: PPUSH
6294: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6298: LD_VAR 0 6
6302: PPUSH
6303: LD_INT 60
6305: PUSH
6306: EMPTY
6307: LIST
6308: PPUSH
6309: CALL_OW 72
6313: NOT
6314: IFFALSE 6291
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6316: LD_VAR 0 2
6320: PPUSH
6321: LD_VAR 0 6
6325: PPUSH
6326: LD_VAR 0 5
6330: PPUSH
6331: LD_VAR 0 4
6335: PPUSH
6336: CALL 79952 0 4
// end ; end_of_file
6340: PPOPN 7
6342: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6343: LD_INT 0
6345: PPUSH
6346: PPUSH
6347: PPUSH
6348: PPUSH
// uc_side := 1 ;
6349: LD_ADDR_OWVAR 20
6353: PUSH
6354: LD_INT 1
6356: ST_TO_ADDR
// uc_nation := 1 ;
6357: LD_ADDR_OWVAR 21
6361: PUSH
6362: LD_INT 1
6364: ST_TO_ADDR
// InitHc ;
6365: CALL_OW 19
// InitVc ;
6369: CALL_OW 20
// tmp := [ ] ;
6373: LD_ADDR_VAR 0 3
6377: PUSH
6378: EMPTY
6379: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6380: LD_ADDR_VAR 0 2
6384: PUSH
6385: DOUBLE
6386: LD_INT 1
6388: DEC
6389: ST_TO_ADDR
6390: LD_INT 5
6392: PUSH
6393: LD_INT 6
6395: PUSH
6396: LD_INT 6
6398: PUSH
6399: EMPTY
6400: LIST
6401: LIST
6402: LIST
6403: PUSH
6404: LD_OWVAR 67
6408: ARRAY
6409: PUSH
6410: FOR_TO
6411: IFFALSE 6548
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6413: LD_INT 2
6415: PUSH
6416: LD_INT 4
6418: PUSH
6419: LD_INT 5
6421: PUSH
6422: EMPTY
6423: LIST
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 1
6429: PPUSH
6430: LD_INT 3
6432: PPUSH
6433: CALL_OW 12
6437: ARRAY
6438: PPUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 3
6444: PUSH
6445: EMPTY
6446: LIST
6447: LIST
6448: PUSH
6449: LD_INT 1
6451: PPUSH
6452: LD_INT 2
6454: PPUSH
6455: CALL_OW 12
6459: ARRAY
6460: PPUSH
6461: LD_INT 3
6463: PPUSH
6464: LD_INT 9
6466: PUSH
6467: LD_INT 7
6469: PUSH
6470: EMPTY
6471: LIST
6472: LIST
6473: PUSH
6474: LD_INT 1
6476: PPUSH
6477: LD_INT 2
6479: PPUSH
6480: CALL_OW 12
6484: ARRAY
6485: PPUSH
6486: LD_INT 78
6488: PPUSH
6489: CALL 20550 0 5
// veh := CreateVehicle ;
6493: LD_ADDR_VAR 0 4
6497: PUSH
6498: CALL_OW 45
6502: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6503: LD_VAR 0 4
6507: PPUSH
6508: LD_INT 2
6510: PPUSH
6511: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6515: LD_VAR 0 4
6519: PPUSH
6520: LD_INT 17
6522: PPUSH
6523: LD_INT 0
6525: PPUSH
6526: CALL_OW 49
// tmp := tmp ^ veh ;
6530: LD_ADDR_VAR 0 3
6534: PUSH
6535: LD_VAR 0 3
6539: PUSH
6540: LD_VAR 0 4
6544: ADD
6545: ST_TO_ADDR
// end ;
6546: GO 6410
6548: POP
6549: POP
// if not tmp then
6550: LD_VAR 0 3
6554: NOT
6555: IFFALSE 6559
// exit ;
6557: GO 6668
// if not first_powell_attack then
6559: LD_EXP 11
6563: NOT
6564: IFFALSE 6574
// first_powell_attack := true ;
6566: LD_ADDR_EXP 11
6570: PUSH
6571: LD_INT 1
6573: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6574: LD_INT 70
6576: PPUSH
6577: CALL_OW 67
// for i in tmp do
6581: LD_ADDR_VAR 0 2
6585: PUSH
6586: LD_VAR 0 3
6590: PUSH
6591: FOR_IN
6592: IFFALSE 6659
// if IsOk ( i ) then
6594: LD_VAR 0 2
6598: PPUSH
6599: CALL_OW 302
6603: IFFALSE 6641
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6605: LD_VAR 0 2
6609: PPUSH
6610: LD_INT 81
6612: PUSH
6613: LD_INT 1
6615: PUSH
6616: EMPTY
6617: LIST
6618: LIST
6619: PPUSH
6620: CALL_OW 69
6624: PPUSH
6625: LD_VAR 0 2
6629: PPUSH
6630: CALL_OW 74
6634: PPUSH
6635: CALL_OW 115
6639: GO 6657
// tmp := tmp diff i ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PUSH
6651: LD_VAR 0 2
6655: DIFF
6656: ST_TO_ADDR
6657: GO 6591
6659: POP
6660: POP
// until not tmp ;
6661: LD_VAR 0 3
6665: NOT
6666: IFFALSE 6574
// end ; end_of_file
6668: LD_VAR 0 1
6672: RET
// export function Action ; var tmp , i , un ; begin
6673: LD_INT 0
6675: PPUSH
6676: PPUSH
6677: PPUSH
6678: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6679: LD_INT 68
6681: PPUSH
6682: LD_INT 39
6684: PPUSH
6685: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6689: LD_ADDR_VAR 0 2
6693: PUSH
6694: LD_INT 22
6696: PUSH
6697: LD_INT 7
6699: PUSH
6700: EMPTY
6701: LIST
6702: LIST
6703: PPUSH
6704: CALL_OW 69
6708: ST_TO_ADDR
// InGameOn ;
6709: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6713: LD_VAR 0 2
6717: PPUSH
6718: LD_INT 71
6720: PPUSH
6721: LD_INT 49
6723: PPUSH
6724: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6728: LD_INT 35
6730: PPUSH
6731: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6735: LD_INT 7
6737: PPUSH
6738: LD_INT 71
6740: PPUSH
6741: LD_INT 51
6743: PPUSH
6744: CALL_OW 293
6748: IFFALSE 6728
// DialogueOn ;
6750: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6754: LD_EXP 14
6758: PPUSH
6759: LD_STRING D1-JMM-1
6761: PPUSH
6762: CALL_OW 88
// if Joan then
6766: LD_EXP 29
6770: IFFALSE 6784
// Say ( Joan , D1-Joan-1 ) ;
6772: LD_EXP 29
6776: PPUSH
6777: LD_STRING D1-Joan-1
6779: PPUSH
6780: CALL_OW 88
// if Lisa then
6784: LD_EXP 16
6788: IFFALSE 6802
// Say ( Lisa , D1-Lisa-1 ) ;
6790: LD_EXP 16
6794: PPUSH
6795: LD_STRING D1-Lisa-1
6797: PPUSH
6798: CALL_OW 88
// if Joan or Lisa then
6802: LD_EXP 29
6806: PUSH
6807: LD_EXP 16
6811: OR
6812: IFFALSE 6826
// Say ( JMM , D1-JMM-2 ) ;
6814: LD_EXP 14
6818: PPUSH
6819: LD_STRING D1-JMM-2
6821: PPUSH
6822: CALL_OW 88
// DialogueOff ;
6826: CALL_OW 7
// InGameOff ;
6830: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6834: LD_INT 71
6836: PPUSH
6837: LD_INT 50
6839: PPUSH
6840: LD_INT 7
6842: PPUSH
6843: LD_INT 30
6845: NEG
6846: PPUSH
6847: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6851: LD_INT 71
6853: PPUSH
6854: LD_INT 50
6856: PPUSH
6857: LD_INT 7
6859: PPUSH
6860: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6864: LD_STRING M1
6866: PPUSH
6867: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6871: LD_INT 35
6873: PPUSH
6874: CALL_OW 67
// until freedom ;
6878: LD_EXP 3
6882: IFFALSE 6871
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6884: LD_INT 350
6886: PPUSH
6887: LD_INT 700
6889: PPUSH
6890: CALL_OW 12
6894: PPUSH
6895: CALL_OW 67
// PrepareGossudarov ;
6899: CALL 1691 0 0
// repeat wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6910: LD_INT 22
6912: PUSH
6913: LD_INT 6
6915: PUSH
6916: EMPTY
6917: LIST
6918: LIST
6919: PUSH
6920: LD_INT 3
6922: PUSH
6923: LD_INT 24
6925: PUSH
6926: LD_INT 1000
6928: PUSH
6929: EMPTY
6930: LIST
6931: LIST
6932: PUSH
6933: EMPTY
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: PPUSH
6941: CALL_OW 69
6945: PUSH
6946: LD_INT 7
6948: PPUSH
6949: LD_EXP 31
6953: PPUSH
6954: CALL_OW 292
6958: OR
6959: IFFALSE 6903
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6961: LD_ADDR_VAR 0 2
6965: PUSH
6966: LD_INT 22
6968: PUSH
6969: LD_INT 6
6971: PUSH
6972: EMPTY
6973: LIST
6974: LIST
6975: PPUSH
6976: CALL_OW 69
6980: ST_TO_ADDR
// for i in tmp do
6981: LD_ADDR_VAR 0 3
6985: PUSH
6986: LD_VAR 0 2
6990: PUSH
6991: FOR_IN
6992: IFFALSE 7008
// SetSide ( i , 7 ) ;
6994: LD_VAR 0 3
6998: PPUSH
6999: LD_INT 7
7001: PPUSH
7002: CALL_OW 235
7006: GO 6991
7008: POP
7009: POP
// DialogueOn ;
7010: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7014: LD_EXP 14
7018: PUSH
7019: LD_EXP 15
7023: PUSH
7024: EMPTY
7025: LIST
7026: LIST
7027: PPUSH
7028: LD_EXP 31
7032: PPUSH
7033: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7037: LD_EXP 31
7041: PPUSH
7042: CALL_OW 87
// if not Roth then
7046: LD_EXP 15
7050: NOT
7051: IFFALSE 7143
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7053: LD_VAR 0 2
7057: PPUSH
7058: LD_INT 3
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: LD_INT 1000
7066: PUSH
7067: EMPTY
7068: LIST
7069: LIST
7070: PUSH
7071: EMPTY
7072: LIST
7073: LIST
7074: PPUSH
7075: CALL_OW 72
7079: IFFALSE 7093
// Say ( JMM , D2-JMM-1 ) ;
7081: LD_EXP 14
7085: PPUSH
7086: LD_STRING D2-JMM-1
7088: PPUSH
7089: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7093: LD_EXP 14
7097: PPUSH
7098: LD_STRING D2-JMM-1b
7100: PPUSH
7101: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7105: LD_EXP 31
7109: PPUSH
7110: LD_STRING D2-Gos-1
7112: PPUSH
7113: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7117: LD_EXP 14
7121: PPUSH
7122: LD_STRING D2-JMM-2
7124: PPUSH
7125: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7129: LD_EXP 31
7133: PPUSH
7134: LD_STRING D2-Gos-2
7136: PPUSH
7137: CALL_OW 88
// end else
7141: GO 7295
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7143: LD_VAR 0 2
7147: PPUSH
7148: LD_INT 3
7150: PUSH
7151: LD_INT 24
7153: PUSH
7154: LD_INT 1000
7156: PUSH
7157: EMPTY
7158: LIST
7159: LIST
7160: PUSH
7161: EMPTY
7162: LIST
7163: LIST
7164: PPUSH
7165: CALL_OW 72
7169: IFFALSE 7195
// begin Say ( Roth , D2-Roth-2 ) ;
7171: LD_EXP 15
7175: PPUSH
7176: LD_STRING D2-Roth-2
7178: PPUSH
7179: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7183: LD_EXP 14
7187: PPUSH
7188: LD_STRING D2-JMM-1a
7190: PPUSH
7191: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7195: LD_EXP 15
7199: PPUSH
7200: LD_STRING D2-Roth-2a
7202: PPUSH
7203: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7207: LD_EXP 15
7211: PPUSH
7212: LD_STRING D2-Roth-2b
7214: PPUSH
7215: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7219: LD_EXP 14
7223: PPUSH
7224: LD_STRING D2-JMM-3
7226: PPUSH
7227: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7231: LD_VAR 0 2
7235: PPUSH
7236: LD_INT 3
7238: PUSH
7239: LD_INT 24
7241: PUSH
7242: LD_INT 1000
7244: PUSH
7245: EMPTY
7246: LIST
7247: LIST
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PPUSH
7253: CALL_OW 72
7257: IFFALSE 7295
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7259: LD_EXP 31
7263: PPUSH
7264: LD_STRING D2-Gos-3
7266: PPUSH
7267: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7271: LD_EXP 14
7275: PPUSH
7276: LD_STRING D2-JMM-4
7278: PPUSH
7279: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7283: LD_EXP 31
7287: PPUSH
7288: LD_STRING D2-Gos-4
7290: PPUSH
7291: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7295: LD_EXP 14
7299: PPUSH
7300: LD_STRING D2-JMM-5
7302: PPUSH
7303: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7307: LD_EXP 31
7311: PPUSH
7312: LD_STRING D2-Gos-5
7314: PPUSH
7315: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7319: LD_EXP 14
7323: PPUSH
7324: LD_STRING D2-JMM-6
7326: PPUSH
7327: CALL_OW 88
// DialogueOff ;
7331: CALL_OW 7
// wait ( 0 0$2 ) ;
7335: LD_INT 70
7337: PPUSH
7338: CALL_OW 67
// if Kirilenkova then
7342: LD_EXP 32
7346: IFFALSE 7360
// Say ( Kirilenkova , D3-Kir-1 ) ;
7348: LD_EXP 32
7352: PPUSH
7353: LD_STRING D3-Kir-1
7355: PPUSH
7356: CALL_OW 88
// gossudarov_arrive := true ;
7360: LD_ADDR_EXP 4
7364: PUSH
7365: LD_INT 1
7367: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7368: LD_STRING CombinedForces
7370: PPUSH
7371: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7375: LD_INT 35
7377: PPUSH
7378: CALL_OW 67
// until ru_lab_builded ;
7382: LD_EXP 5
7386: IFFALSE 7375
// if Kirilenkova then
7388: LD_EXP 32
7392: IFFALSE 7408
// Say ( Kirilenkova , D3a-Kir-1 ) else
7394: LD_EXP 32
7398: PPUSH
7399: LD_STRING D3a-Kir-1
7401: PPUSH
7402: CALL_OW 88
7406: GO 7430
// begin un := SciRu ;
7408: LD_ADDR_VAR 0 4
7412: PUSH
7413: CALL 12400 0 0
7417: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7418: LD_VAR 0 4
7422: PPUSH
7423: LD_STRING D3a-Sci1-1
7425: PPUSH
7426: CALL_OW 88
// end ; if Kirilenkova or un then
7430: LD_EXP 32
7434: PUSH
7435: LD_VAR 0 4
7439: OR
7440: IFFALSE 7454
// Say ( JMM , D3a-JMM-1 ) ;
7442: LD_EXP 14
7446: PPUSH
7447: LD_STRING D3a-JMM-1
7449: PPUSH
7450: CALL_OW 88
// end ;
7454: LD_VAR 0 1
7458: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7459: LD_EXP 4
7463: PUSH
7464: LD_INT 22
7466: PUSH
7467: LD_INT 7
7469: PUSH
7470: EMPTY
7471: LIST
7472: LIST
7473: PUSH
7474: LD_INT 2
7476: PUSH
7477: LD_INT 25
7479: PUSH
7480: LD_INT 1
7482: PUSH
7483: EMPTY
7484: LIST
7485: LIST
7486: PUSH
7487: LD_INT 25
7489: PUSH
7490: LD_INT 2
7492: PUSH
7493: EMPTY
7494: LIST
7495: LIST
7496: PUSH
7497: LD_INT 25
7499: PUSH
7500: LD_INT 3
7502: PUSH
7503: EMPTY
7504: LIST
7505: LIST
7506: PUSH
7507: LD_INT 25
7509: PUSH
7510: LD_INT 4
7512: PUSH
7513: EMPTY
7514: LIST
7515: LIST
7516: PUSH
7517: LD_INT 25
7519: PUSH
7520: LD_INT 5
7522: PUSH
7523: EMPTY
7524: LIST
7525: LIST
7526: PUSH
7527: LD_INT 25
7529: PUSH
7530: LD_INT 8
7532: PUSH
7533: EMPTY
7534: LIST
7535: LIST
7536: PUSH
7537: LD_INT 25
7539: PUSH
7540: LD_INT 9
7542: PUSH
7543: EMPTY
7544: LIST
7545: LIST
7546: PUSH
7547: EMPTY
7548: LIST
7549: LIST
7550: LIST
7551: LIST
7552: LIST
7553: LIST
7554: LIST
7555: LIST
7556: PUSH
7557: EMPTY
7558: LIST
7559: LIST
7560: PPUSH
7561: CALL_OW 69
7565: PUSH
7566: LD_INT 7
7568: LESS
7569: AND
7570: IFFALSE 7582
7572: GO 7574
7574: DISABLE
// YouLost ( TooMany ) ;
7575: LD_STRING TooMany
7577: PPUSH
7578: CALL_OW 104
7582: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7583: LD_EXP 31
7587: PPUSH
7588: CALL_OW 255
7592: PUSH
7593: LD_INT 7
7595: EQUAL
7596: IFFALSE 7796
7598: GO 7600
7600: DISABLE
7601: LD_INT 0
7603: PPUSH
7604: PPUSH
7605: PPUSH
// begin uc_side := 3 ;
7606: LD_ADDR_OWVAR 20
7610: PUSH
7611: LD_INT 3
7613: ST_TO_ADDR
// uc_nation := 3 ;
7614: LD_ADDR_OWVAR 21
7618: PUSH
7619: LD_INT 3
7621: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7622: LD_INT 21
7624: PPUSH
7625: LD_INT 3
7627: PPUSH
7628: LD_INT 3
7630: PPUSH
7631: LD_INT 42
7633: PPUSH
7634: LD_INT 100
7636: PPUSH
7637: CALL 20550 0 5
// un := CreateVehicle ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: CALL_OW 45
7650: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7651: LD_VAR 0 3
7655: PPUSH
7656: LD_INT 15
7658: PPUSH
7659: LD_INT 0
7661: PPUSH
7662: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7666: LD_VAR 0 3
7670: PPUSH
7671: LD_INT 67
7673: PPUSH
7674: LD_INT 45
7676: PPUSH
7677: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7681: LD_VAR 0 3
7685: PPUSH
7686: LD_INT 70
7688: PPUSH
7689: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7693: LD_VAR 0 3
7697: PPUSH
7698: LD_INT 69
7700: PPUSH
7701: LD_INT 18
7703: PPUSH
7704: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7708: LD_VAR 0 3
7712: PPUSH
7713: LD_INT 60
7715: PPUSH
7716: LD_INT 2
7718: PPUSH
7719: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7723: LD_INT 35
7725: PPUSH
7726: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL_OW 302
7739: NOT
7740: PUSH
7741: LD_VAR 0 3
7745: PPUSH
7746: LD_INT 17
7748: PPUSH
7749: CALL_OW 308
7753: OR
7754: IFFALSE 7723
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7756: LD_VAR 0 3
7760: PPUSH
7761: LD_INT 17
7763: PPUSH
7764: CALL_OW 308
7768: PUSH
7769: LD_VAR 0 3
7773: PPUSH
7774: LD_INT 60
7776: PPUSH
7777: LD_INT 2
7779: PPUSH
7780: CALL_OW 307
7784: OR
7785: IFFALSE 7796
// RemoveUnit ( un ) ;
7787: LD_VAR 0 3
7791: PPUSH
7792: CALL_OW 64
// end ;
7796: PPOPN 3
7798: END
// every 0 0$2 do var i , un , tmp ;
7799: GO 7801
7801: DISABLE
7802: LD_INT 0
7804: PPUSH
7805: PPUSH
7806: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7807: LD_INT 70
7809: PPUSH
7810: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7814: LD_ADDR_VAR 0 3
7818: PUSH
7819: LD_INT 22
7821: PUSH
7822: LD_INT 7
7824: PUSH
7825: EMPTY
7826: LIST
7827: LIST
7828: PUSH
7829: LD_INT 101
7831: PUSH
7832: LD_INT 3
7834: PUSH
7835: EMPTY
7836: LIST
7837: LIST
7838: PUSH
7839: EMPTY
7840: LIST
7841: LIST
7842: PPUSH
7843: CALL_OW 69
7847: ST_TO_ADDR
// until tmp ;
7848: LD_VAR 0 3
7852: IFFALSE 7807
// un := NearestUnitToUnit ( tmp , JMM ) ;
7854: LD_ADDR_VAR 0 2
7858: PUSH
7859: LD_VAR 0 3
7863: PPUSH
7864: LD_EXP 14
7868: PPUSH
7869: CALL_OW 74
7873: ST_TO_ADDR
// player_spotted := true ;
7874: LD_ADDR_EXP 6
7878: PUSH
7879: LD_INT 1
7881: ST_TO_ADDR
// tmp := SciRu ;
7882: LD_ADDR_VAR 0 3
7886: PUSH
7887: CALL 12400 0 0
7891: ST_TO_ADDR
// if not tmp then
7892: LD_VAR 0 3
7896: NOT
7897: IFFALSE 7909
// tmp := SolRu ;
7899: LD_ADDR_VAR 0 3
7903: PUSH
7904: CALL 12547 0 0
7908: ST_TO_ADDR
// DialogueOn ;
7909: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7913: LD_VAR 0 2
7917: PPUSH
7918: CALL_OW 250
7922: PPUSH
7923: LD_VAR 0 2
7927: PPUSH
7928: CALL_OW 251
7932: PPUSH
7933: LD_INT 7
7935: PPUSH
7936: LD_INT 8
7938: NEG
7939: PPUSH
7940: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7944: LD_VAR 0 2
7948: PPUSH
7949: CALL_OW 87
// if tmp then
7953: LD_VAR 0 3
7957: IFFALSE 7971
// Say ( tmp , D4-RSci1-1 ) ;
7959: LD_VAR 0 3
7963: PPUSH
7964: LD_STRING D4-RSci1-1
7966: PPUSH
7967: CALL_OW 88
// if Gossudarov then
7971: LD_EXP 31
7975: IFFALSE 8001
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7977: LD_EXP 31
7981: PPUSH
7982: LD_STRING D4-Gos-1
7984: PPUSH
7985: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
7989: LD_EXP 14
7993: PPUSH
7994: LD_STRING D4-JMM-1
7996: PPUSH
7997: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8001: LD_VAR 0 2
8005: PPUSH
8006: CALL_OW 250
8010: PPUSH
8011: LD_VAR 0 2
8015: PPUSH
8016: CALL_OW 251
8020: PPUSH
8021: LD_INT 7
8023: PPUSH
8024: CALL_OW 331
// DialogueOff ;
8028: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8032: LD_STRING M5
8034: PPUSH
8035: CALL_OW 337
// end ;
8039: PPOPN 3
8041: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8042: LD_EXP 6
8046: IFFALSE 8635
8048: GO 8050
8050: DISABLE
8051: LD_INT 0
8053: PPUSH
8054: PPUSH
8055: PPUSH
// begin PrepareBelkov ;
8056: CALL 1981 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8060: LD_EXP 46
8064: PPUSH
8065: LD_INT 118
8067: PPUSH
8068: LD_INT 106
8070: PPUSH
8071: CALL_OW 111
// AddComHold ( Belkov ) ;
8075: LD_EXP 46
8079: PPUSH
8080: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8084: LD_INT 35
8086: PPUSH
8087: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8091: LD_EXP 46
8095: PPUSH
8096: LD_INT 118
8098: PPUSH
8099: LD_INT 106
8101: PPUSH
8102: CALL_OW 307
8106: IFFALSE 8084
// ChangeSideFog ( 4 , 7 ) ;
8108: LD_INT 4
8110: PPUSH
8111: LD_INT 7
8113: PPUSH
8114: CALL_OW 343
// if IsOk ( Belkov ) then
8118: LD_EXP 46
8122: PPUSH
8123: CALL_OW 302
8127: IFFALSE 8211
// begin InGameOn ;
8129: CALL_OW 8
// DialogueOn ;
8133: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8137: LD_EXP 46
8141: PPUSH
8142: LD_STRING D5-Bel-1
8144: PPUSH
8145: CALL_OW 94
// if Gossudarov then
8149: LD_EXP 31
8153: IFFALSE 8203
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8155: LD_EXP 31
8159: PPUSH
8160: LD_STRING D5-Gos-1
8162: PPUSH
8163: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8167: LD_EXP 14
8171: PPUSH
8172: LD_STRING D5-JMM-1
8174: PPUSH
8175: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8179: LD_EXP 31
8183: PPUSH
8184: LD_STRING D5-Gos-2
8186: PPUSH
8187: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8191: LD_EXP 14
8195: PPUSH
8196: LD_STRING D5-JMM-2
8198: PPUSH
8199: CALL_OW 88
// end ; DialogueOff ;
8203: CALL_OW 7
// InGameOff ;
8207: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8211: LD_STRING QSaveBelkov
8213: PPUSH
8214: CALL_OW 97
8218: PUSH
8219: LD_INT 1
8221: DOUBLE
8222: EQUAL
8223: IFTRUE 8227
8225: GO 8277
8227: POP
// begin DialogueOn ;
8228: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8232: LD_EXP 14
8236: PPUSH
8237: LD_STRING D5a-JMM-1
8239: PPUSH
8240: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8244: LD_EXP 46
8248: PPUSH
8249: LD_STRING D5a-Bel-1
8251: PPUSH
8252: CALL_OW 94
// DialogueOff ;
8256: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8260: LD_EXP 46
8264: PPUSH
8265: LD_INT 83
8267: PPUSH
8268: LD_INT 49
8270: PPUSH
8271: CALL_OW 111
// end ; 2 :
8275: GO 8310
8277: LD_INT 2
8279: DOUBLE
8280: EQUAL
8281: IFTRUE 8285
8283: GO 8309
8285: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8286: LD_EXP 14
8290: PPUSH
8291: LD_STRING D5a-JMM-2
8293: PPUSH
8294: CALL_OW 88
// ComHold ( Belkov ) ;
8298: LD_EXP 46
8302: PPUSH
8303: CALL_OW 140
// end ; end ;
8307: GO 8310
8309: POP
// time := 0 0$00 ;
8310: LD_ADDR_VAR 0 1
8314: PUSH
8315: LD_INT 0
8317: ST_TO_ADDR
// vehSpawned := false ;
8318: LD_ADDR_VAR 0 3
8322: PUSH
8323: LD_INT 0
8325: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8326: LD_INT 35
8328: PPUSH
8329: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8333: LD_VAR 0 1
8337: PUSH
8338: LD_INT 350
8340: PUSH
8341: LD_INT 175
8343: PUSH
8344: LD_INT 70
8346: PUSH
8347: EMPTY
8348: LIST
8349: LIST
8350: LIST
8351: PUSH
8352: LD_OWVAR 67
8356: ARRAY
8357: GREATEREQUAL
8358: PUSH
8359: LD_VAR 0 3
8363: NOT
8364: AND
8365: IFFALSE 8455
// begin vehSpawned := true ;
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: LD_INT 1
8374: ST_TO_ADDR
// uc_side := 3 ;
8375: LD_ADDR_OWVAR 20
8379: PUSH
8380: LD_INT 3
8382: ST_TO_ADDR
// uc_nation := 3 ;
8383: LD_ADDR_OWVAR 21
8387: PUSH
8388: LD_INT 3
8390: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8391: LD_INT 22
8393: PPUSH
8394: LD_INT 3
8396: PPUSH
8397: LD_INT 3
8399: PPUSH
8400: LD_INT 43
8402: PPUSH
8403: LD_INT 100
8405: PPUSH
8406: CALL 20550 0 5
// veh := CreateVehicle ;
8410: LD_ADDR_VAR 0 2
8414: PUSH
8415: CALL_OW 45
8419: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8420: LD_VAR 0 2
8424: PPUSH
8425: LD_INT 130
8427: PPUSH
8428: LD_INT 131
8430: PPUSH
8431: LD_INT 0
8433: PPUSH
8434: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8438: LD_VAR 0 2
8442: PPUSH
8443: LD_INT 100
8445: PPUSH
8446: LD_INT 82
8448: PPUSH
8449: CALL_OW 114
// end else
8453: GO 8469
// time := time + 0 0$1 ;
8455: LD_ADDR_VAR 0 1
8459: PUSH
8460: LD_VAR 0 1
8464: PUSH
8465: LD_INT 35
8467: PLUS
8468: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8469: LD_EXP 46
8473: PPUSH
8474: CALL_OW 301
8478: PUSH
8479: LD_EXP 46
8483: PPUSH
8484: CALL_OW 255
8488: PUSH
8489: LD_INT 4
8491: EQUAL
8492: AND
8493: PUSH
8494: LD_INT 22
8496: PUSH
8497: LD_INT 7
8499: PUSH
8500: EMPTY
8501: LIST
8502: LIST
8503: PPUSH
8504: CALL_OW 69
8508: PPUSH
8509: LD_EXP 46
8513: PPUSH
8514: CALL_OW 74
8518: PPUSH
8519: LD_EXP 46
8523: PPUSH
8524: CALL_OW 296
8528: PUSH
8529: LD_INT 10
8531: LESS
8532: OR
8533: IFFALSE 8326
// if IsDead ( Belkov ) then
8535: LD_EXP 46
8539: PPUSH
8540: CALL_OW 301
8544: IFFALSE 8569
// begin CenterNowOnUnits ( Belkov ) ;
8546: LD_EXP 46
8550: PPUSH
8551: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8555: LD_EXP 14
8559: PPUSH
8560: LD_STRING D5a-JMM-2a
8562: PPUSH
8563: CALL_OW 88
// exit ;
8567: GO 8635
// end ; if See ( 7 , Belkov ) then
8569: LD_INT 7
8571: PPUSH
8572: LD_EXP 46
8576: PPUSH
8577: CALL_OW 292
8581: IFFALSE 8595
// SetSide ( Belkov , 7 ) ;
8583: LD_EXP 46
8587: PPUSH
8588: LD_INT 7
8590: PPUSH
8591: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8595: LD_INT 35
8597: PPUSH
8598: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 66
8609: PPUSH
8610: LD_INT 45
8612: PPUSH
8613: CALL_OW 297
8617: PUSH
8618: LD_INT 30
8620: LESS
8621: IFFALSE 8595
// Say ( Belkov , D6-Bel-1 ) ;
8623: LD_EXP 46
8627: PPUSH
8628: LD_STRING D6-Bel-1
8630: PPUSH
8631: CALL_OW 88
// end ;
8635: PPOPN 3
8637: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8638: LD_EXP 46
8642: PPUSH
8643: CALL_OW 302
8647: PUSH
8648: LD_EXP 46
8652: PPUSH
8653: CALL_OW 504
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: LD_INT 34
8663: PUSH
8664: LD_INT 47
8666: PUSH
8667: EMPTY
8668: LIST
8669: LIST
8670: PUSH
8671: LD_INT 34
8673: PUSH
8674: LD_INT 45
8676: PUSH
8677: EMPTY
8678: LIST
8679: LIST
8680: PUSH
8681: EMPTY
8682: LIST
8683: LIST
8684: LIST
8685: PPUSH
8686: CALL_OW 69
8690: IN
8691: AND
8692: IFFALSE 8709
8694: GO 8696
8696: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8697: LD_EXP 46
8701: PPUSH
8702: LD_STRING D7-Bel-1
8704: PPUSH
8705: CALL_OW 88
8709: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8710: LD_INT 22
8712: PUSH
8713: LD_INT 7
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: PUSH
8720: LD_INT 101
8722: PUSH
8723: LD_INT 2
8725: PUSH
8726: EMPTY
8727: LIST
8728: LIST
8729: PUSH
8730: EMPTY
8731: LIST
8732: LIST
8733: PPUSH
8734: CALL_OW 69
8738: PUSH
8739: LD_EXP 8
8743: NOT
8744: AND
8745: PUSH
8746: LD_EXP 45
8750: PPUSH
8751: CALL_OW 305
8755: NOT
8756: AND
8757: IFFALSE 9227
8759: GO 8761
8761: DISABLE
8762: LD_INT 0
8764: PPUSH
// begin ar_base_spotted := true ;
8765: LD_ADDR_EXP 8
8769: PUSH
8770: LD_INT 1
8772: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8773: LD_ADDR_VAR 0 1
8777: PUSH
8778: LD_INT 22
8780: PUSH
8781: LD_INT 2
8783: PUSH
8784: EMPTY
8785: LIST
8786: LIST
8787: PUSH
8788: LD_INT 21
8790: PUSH
8791: LD_INT 3
8793: PUSH
8794: EMPTY
8795: LIST
8796: LIST
8797: PUSH
8798: EMPTY
8799: LIST
8800: LIST
8801: PPUSH
8802: CALL_OW 69
8806: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8807: LD_ADDR_VAR 0 1
8811: PUSH
8812: LD_VAR 0 1
8816: PPUSH
8817: LD_EXP 14
8821: PPUSH
8822: CALL_OW 74
8826: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8827: LD_INT 7
8829: PPUSH
8830: LD_INT 3
8832: PPUSH
8833: CALL_OW 332
// DialogueOn ;
8837: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8841: LD_VAR 0 1
8845: PPUSH
8846: CALL_OW 250
8850: PPUSH
8851: LD_VAR 0 1
8855: PPUSH
8856: CALL_OW 251
8860: PPUSH
8861: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8865: LD_ADDR_VAR 0 1
8869: PUSH
8870: LD_INT 22
8872: PUSH
8873: LD_INT 7
8875: PUSH
8876: EMPTY
8877: LIST
8878: LIST
8879: PUSH
8880: LD_INT 23
8882: PUSH
8883: LD_INT 1
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: PUSH
8890: LD_INT 26
8892: PUSH
8893: LD_INT 1
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: EMPTY
8901: LIST
8902: LIST
8903: LIST
8904: PPUSH
8905: CALL_OW 69
8909: PUSH
8910: LD_EXP 14
8914: PUSH
8915: LD_EXP 18
8919: PUSH
8920: LD_EXP 19
8924: PUSH
8925: LD_EXP 26
8929: PUSH
8930: LD_EXP 15
8934: PUSH
8935: LD_EXP 24
8939: PUSH
8940: LD_EXP 20
8944: PUSH
8945: LD_EXP 22
8949: PUSH
8950: EMPTY
8951: LIST
8952: LIST
8953: LIST
8954: LIST
8955: LIST
8956: LIST
8957: LIST
8958: LIST
8959: DIFF
8960: ST_TO_ADDR
// if not tmp then
8961: LD_VAR 0 1
8965: NOT
8966: IFFALSE 9040
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8968: LD_ADDR_VAR 0 1
8972: PUSH
8973: LD_INT 22
8975: PUSH
8976: LD_INT 7
8978: PUSH
8979: EMPTY
8980: LIST
8981: LIST
8982: PUSH
8983: LD_INT 23
8985: PUSH
8986: LD_INT 1
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: PUSH
8993: LD_INT 26
8995: PUSH
8996: LD_INT 2
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: LIST
9007: PPUSH
9008: CALL_OW 69
9012: PUSH
9013: LD_EXP 29
9017: PUSH
9018: LD_EXP 16
9022: PUSH
9023: LD_EXP 27
9027: PUSH
9028: LD_EXP 28
9032: PUSH
9033: EMPTY
9034: LIST
9035: LIST
9036: LIST
9037: LIST
9038: DIFF
9039: ST_TO_ADDR
// if tmp then
9040: LD_VAR 0 1
9044: IFFALSE 9115
// case GetSex ( tmp [ 1 ] ) of sex_male :
9046: LD_VAR 0 1
9050: PUSH
9051: LD_INT 1
9053: ARRAY
9054: PPUSH
9055: CALL_OW 258
9059: PUSH
9060: LD_INT 1
9062: DOUBLE
9063: EQUAL
9064: IFTRUE 9068
9066: GO 9087
9068: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9069: LD_VAR 0 1
9073: PUSH
9074: LD_INT 1
9076: ARRAY
9077: PPUSH
9078: LD_STRING D9-Sol1-1
9080: PPUSH
9081: CALL_OW 88
9085: GO 9115
9087: LD_INT 2
9089: DOUBLE
9090: EQUAL
9091: IFTRUE 9095
9093: GO 9114
9095: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9096: LD_VAR 0 1
9100: PUSH
9101: LD_INT 1
9103: ARRAY
9104: PPUSH
9105: LD_STRING D9-FSol1-1
9107: PPUSH
9108: CALL_OW 88
9112: GO 9115
9114: POP
// if Frank then
9115: LD_EXP 26
9119: IFFALSE 9223
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9121: LD_EXP 55
9125: PPUSH
9126: CALL_OW 250
9130: PPUSH
9131: LD_EXP 55
9135: PPUSH
9136: CALL_OW 251
9140: PPUSH
9141: LD_INT 7
9143: PPUSH
9144: LD_INT 8
9146: PPUSH
9147: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9151: LD_EXP 55
9155: PPUSH
9156: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9160: LD_EXP 26
9164: PPUSH
9165: LD_STRING D9-Frank-1
9167: PPUSH
9168: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9172: LD_EXP 14
9176: PPUSH
9177: LD_STRING D9-JMM-1
9179: PPUSH
9180: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9184: LD_EXP 26
9188: PPUSH
9189: LD_STRING D9-Frank-2
9191: PPUSH
9192: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9196: LD_EXP 55
9200: PPUSH
9201: CALL_OW 250
9205: PPUSH
9206: LD_EXP 55
9210: PPUSH
9211: CALL_OW 251
9215: PPUSH
9216: LD_INT 7
9218: PPUSH
9219: CALL_OW 331
// end ; DialogueOff ;
9223: CALL_OW 7
// end ;
9227: PPOPN 1
9229: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9230: LD_EXP 7
9234: PUSH
9235: LD_OWVAR 1
9239: PUSH
9240: LD_INT 42000
9242: GREATEREQUAL
9243: OR
9244: IFFALSE 10271
9246: GO 9248
9248: DISABLE
9249: LD_INT 0
9251: PPUSH
9252: PPUSH
// begin selected_option := 1 ;
9253: LD_ADDR_VAR 0 2
9257: PUSH
9258: LD_INT 1
9260: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9261: LD_INT 10500
9263: PPUSH
9264: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9268: LD_INT 35
9270: PPUSH
9271: CALL_OW 67
// until not ru_attackers ;
9275: LD_EXP 51
9279: NOT
9280: IFFALSE 9268
// PrepareBurlak ;
9282: CALL 2093 0 0
// repeat wait ( 0 0$2 ) ;
9286: LD_INT 70
9288: PPUSH
9289: CALL_OW 67
// until not HasTask ( Burlak ) ;
9293: LD_EXP 45
9297: PPUSH
9298: CALL_OW 314
9302: NOT
9303: IFFALSE 9286
// InGameOn ;
9305: CALL_OW 8
// DialogueOn ;
9309: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9313: LD_EXP 48
9317: PPUSH
9318: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9322: LD_EXP 45
9326: PPUSH
9327: LD_STRING D10-Bur-1
9329: PPUSH
9330: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9334: LD_EXP 46
9338: PUSH
9339: LD_EXP 46
9343: PPUSH
9344: CALL_OW 255
9348: PUSH
9349: LD_INT 7
9351: EQUAL
9352: AND
9353: IFFALSE 9367
// Say ( Belkov , D10-Bel-1 ) ;
9355: LD_EXP 46
9359: PPUSH
9360: LD_STRING D10-Bel-1
9362: PPUSH
9363: CALL_OW 88
// if Gossudarov then
9367: LD_EXP 31
9371: IFFALSE 9385
// Say ( Gossudarov , D10-Gos-1 ) ;
9373: LD_EXP 31
9377: PPUSH
9378: LD_STRING D10-Gos-1
9380: PPUSH
9381: CALL_OW 88
// if Kirilenkova then
9385: LD_EXP 32
9389: IFFALSE 9403
// Say ( Kirilenkova , D10-Kir-1 ) ;
9391: LD_EXP 32
9395: PPUSH
9396: LD_STRING D10-Kir-1
9398: PPUSH
9399: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9403: CALL 12547 0 0
9407: PPUSH
9408: LD_STRING D10-RSol1-1
9410: PPUSH
9411: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9415: LD_EXP 45
9419: PPUSH
9420: LD_STRING D10-Bur-2
9422: PPUSH
9423: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9427: LD_EXP 14
9431: PPUSH
9432: LD_STRING D10-JMM-2
9434: PPUSH
9435: CALL_OW 88
// if Kirilenkova then
9439: LD_EXP 32
9443: IFFALSE 9459
// Say ( Kirilenkova , D10-Kir-2 ) else
9445: LD_EXP 32
9449: PPUSH
9450: LD_STRING D10-Kir-2
9452: PPUSH
9453: CALL_OW 88
9457: GO 9471
// Say ( SolRu , D10-RSol1-2 ) ;
9459: CALL 12547 0 0
9463: PPUSH
9464: LD_STRING D10-RSol1-2
9466: PPUSH
9467: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9471: LD_EXP 14
9475: PPUSH
9476: LD_STRING D10-JMM-3
9478: PPUSH
9479: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9483: LD_EXP 45
9487: PPUSH
9488: LD_STRING D10-Bur-3
9490: PPUSH
9491: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9495: LD_EXP 14
9499: PPUSH
9500: LD_STRING D10-JMM-4
9502: PPUSH
9503: CALL_OW 88
// DialogueOff ;
9507: CALL_OW 7
// InGameOff ;
9511: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9515: LD_STRING M2
9517: PPUSH
9518: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9522: LD_INT 35
9524: PPUSH
9525: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9529: LD_INT 22
9531: PUSH
9532: LD_INT 7
9534: PUSH
9535: EMPTY
9536: LIST
9537: LIST
9538: PUSH
9539: LD_INT 91
9541: PUSH
9542: LD_EXP 45
9546: PUSH
9547: LD_INT 8
9549: PUSH
9550: EMPTY
9551: LIST
9552: LIST
9553: LIST
9554: PUSH
9555: EMPTY
9556: LIST
9557: LIST
9558: PPUSH
9559: CALL_OW 69
9563: IFFALSE 9522
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9565: LD_ADDR_VAR 0 1
9569: PUSH
9570: LD_INT 22
9572: PUSH
9573: LD_INT 4
9575: PUSH
9576: EMPTY
9577: LIST
9578: LIST
9579: PPUSH
9580: CALL_OW 69
9584: PUSH
9585: FOR_IN
9586: IFFALSE 9602
// SetSide ( i , 7 ) ;
9588: LD_VAR 0 1
9592: PPUSH
9593: LD_INT 7
9595: PPUSH
9596: CALL_OW 235
9600: GO 9585
9602: POP
9603: POP
// ChangeMissionObjectives ( M3 ) ;
9604: LD_STRING M3
9606: PPUSH
9607: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9611: LD_INT 35
9613: PPUSH
9614: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9618: LD_EXP 14
9622: PPUSH
9623: LD_EXP 45
9627: PPUSH
9628: CALL_OW 296
9632: PUSH
9633: LD_INT 8
9635: LESS
9636: IFFALSE 9611
// ComTurnUnit ( JMM , Burlak ) ;
9638: LD_EXP 14
9642: PPUSH
9643: LD_EXP 45
9647: PPUSH
9648: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9652: LD_EXP 45
9656: PPUSH
9657: LD_EXP 14
9661: PPUSH
9662: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9666: LD_INT 10
9668: PPUSH
9669: CALL_OW 67
// DialogueOn ;
9673: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9677: LD_EXP 14
9681: PPUSH
9682: LD_STRING D11-JMM-1
9684: PPUSH
9685: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9689: LD_EXP 45
9693: PPUSH
9694: LD_STRING D11-Bur-1
9696: PPUSH
9697: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9701: LD_EXP 14
9705: PPUSH
9706: LD_STRING D11-JMM-2
9708: PPUSH
9709: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9713: LD_EXP 45
9717: PPUSH
9718: LD_STRING D11-Bur-2
9720: PPUSH
9721: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9725: LD_EXP 14
9729: PPUSH
9730: LD_STRING D11-JMM-3
9732: PPUSH
9733: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9737: LD_EXP 45
9741: PPUSH
9742: LD_STRING D11-Bur-3
9744: PPUSH
9745: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9749: LD_EXP 14
9753: PPUSH
9754: LD_STRING D11-JMM-4
9756: PPUSH
9757: CALL_OW 88
// if ar_base_spotted then
9761: LD_EXP 8
9765: IFFALSE 9781
// Say ( Burlak , D12-Bur-1 ) else
9767: LD_EXP 45
9771: PPUSH
9772: LD_STRING D12-Bur-1
9774: PPUSH
9775: CALL_OW 88
9779: GO 9820
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9781: LD_INT 7
9783: PPUSH
9784: LD_INT 3
9786: PPUSH
9787: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9791: LD_INT 127
9793: PPUSH
9794: LD_INT 45
9796: PPUSH
9797: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9801: LD_EXP 45
9805: PPUSH
9806: LD_STRING D12-Bur-1a
9808: PPUSH
9809: CALL_OW 88
// dwait ( 0 0$2 ) ;
9813: LD_INT 70
9815: PPUSH
9816: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1b
9827: PPUSH
9828: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9832: LD_EXP 14
9836: PPUSH
9837: LD_STRING D12-JMM-1
9839: PPUSH
9840: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9844: LD_EXP 45
9848: PPUSH
9849: LD_STRING D12-Bur-2
9851: PPUSH
9852: CALL_OW 88
// if Roth then
9856: LD_EXP 15
9860: IFFALSE 9876
// Say ( Roth , D12-Roth-2 ) else
9862: LD_EXP 15
9866: PPUSH
9867: LD_STRING D12-Roth-2
9869: PPUSH
9870: CALL_OW 88
9874: GO 9888
// Say ( SciRu , D12-RSci1-2 ) ;
9876: CALL 12400 0 0
9880: PPUSH
9881: LD_STRING D12-RSci1-2
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9888: LD_EXP 14
9892: PPUSH
9893: LD_STRING D12-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9900: LD_EXP 45
9904: PPUSH
9905: LD_STRING D12-Bur-3
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9912: LD_EXP 14
9916: PPUSH
9917: LD_STRING D12-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9924: LD_EXP 45
9928: PPUSH
9929: LD_STRING D12-Bur-4
9931: PPUSH
9932: CALL_OW 88
// case Query ( QBase ) of 1 :
9936: LD_STRING QBase
9938: PPUSH
9939: CALL_OW 97
9943: PUSH
9944: LD_INT 1
9946: DOUBLE
9947: EQUAL
9948: IFTRUE 9952
9950: GO 10070
9952: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9953: LD_EXP 14
9957: PPUSH
9958: LD_STRING D13a-JMM-1
9960: PPUSH
9961: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9965: LD_EXP 45
9969: PPUSH
9970: LD_STRING D13a-Bur-1
9972: PPUSH
9973: CALL_OW 88
// if Roth then
9977: LD_EXP 15
9981: IFFALSE 9997
// Say ( Roth , D13a-Roth-1 ) else
9983: LD_EXP 15
9987: PPUSH
9988: LD_STRING D13a-Roth-1
9990: PPUSH
9991: CALL_OW 88
9995: GO 10009
// Say ( SciRu , D13a-RSci1-1 ) ;
9997: CALL 12400 0 0
10001: PPUSH
10002: LD_STRING D13a-RSci1-1
10004: PPUSH
10005: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10009: LD_EXP 14
10013: PPUSH
10014: LD_STRING D13a-JMM-2
10016: PPUSH
10017: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10021: LD_STRING QBaseAgain
10023: PPUSH
10024: CALL_OW 97
10028: PUSH
10029: LD_INT 1
10031: DOUBLE
10032: EQUAL
10033: IFTRUE 10037
10035: GO 10048
10037: POP
// selected_option := 2 ; 2 :
10038: LD_ADDR_VAR 0 2
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
10046: GO 10068
10048: LD_INT 2
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 3 ; end ;
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 3
10064: ST_TO_ADDR
10065: GO 10068
10067: POP
// end ; 2 :
10068: GO 10109
10070: LD_INT 2
10072: DOUBLE
10073: EQUAL
10074: IFTRUE 10078
10076: GO 10089
10078: POP
// selected_option := 2 ; 3 :
10079: LD_ADDR_VAR 0 2
10083: PUSH
10084: LD_INT 2
10086: ST_TO_ADDR
10087: GO 10109
10089: LD_INT 3
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 3 ; end ;
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 3
10105: ST_TO_ADDR
10106: GO 10109
10108: POP
// if selected_option = 2 then
10109: LD_VAR 0 2
10113: PUSH
10114: LD_INT 2
10116: EQUAL
10117: IFFALSE 10211
// begin Say ( JMM , D13b-JMM-1 ) ;
10119: LD_EXP 14
10123: PPUSH
10124: LD_STRING D13b-JMM-1
10126: PPUSH
10127: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10131: LD_EXP 45
10135: PPUSH
10136: LD_STRING D13b-Bur-1
10138: PPUSH
10139: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10143: LD_EXP 14
10147: PPUSH
10148: LD_STRING D13b-JMM-2
10150: PPUSH
10151: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10155: LD_EXP 54
10159: PPUSH
10160: LD_STRING D13b-Abd-2
10162: PPUSH
10163: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10167: LD_EXP 14
10171: PPUSH
10172: LD_STRING D13b-JMM-3
10174: PPUSH
10175: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10179: LD_EXP 54
10183: PPUSH
10184: LD_STRING D13b-Abd-3
10186: PPUSH
10187: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10191: LD_EXP 14
10195: PPUSH
10196: LD_STRING D13b-JMM-4
10198: PPUSH
10199: CALL_OW 88
// ar_active_attack := true ;
10203: LD_ADDR_EXP 9
10207: PUSH
10208: LD_INT 1
10210: ST_TO_ADDR
// end ; if selected_option = 3 then
10211: LD_VAR 0 2
10215: PUSH
10216: LD_INT 3
10218: EQUAL
10219: IFFALSE 10245
// begin Say ( JMM , D13c-JMM-1 ) ;
10221: LD_EXP 14
10225: PPUSH
10226: LD_STRING D13c-JMM-1
10228: PPUSH
10229: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10233: LD_EXP 45
10237: PPUSH
10238: LD_STRING D13c-Bur-1
10240: PPUSH
10241: CALL_OW 88
// end ; DialogueOff ;
10245: CALL_OW 7
// if not ar_active_attack then
10249: LD_EXP 9
10253: NOT
10254: IFFALSE 10271
// begin wait ( 6 6$00 ) ;
10256: LD_INT 12600
10258: PPUSH
10259: CALL_OW 67
// ar_active_attack := true ;
10263: LD_ADDR_EXP 9
10267: PUSH
10268: LD_INT 1
10270: ST_TO_ADDR
// end ; end ;
10271: PPOPN 2
10273: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10274: LD_EXP 45
10278: PPUSH
10279: CALL_OW 305
10283: PUSH
10284: LD_EXP 45
10288: PPUSH
10289: CALL_OW 255
10293: PUSH
10294: LD_INT 7
10296: EQUAL
10297: AND
10298: IFFALSE 10494
10300: GO 10302
10302: DISABLE
10303: LD_INT 0
10305: PPUSH
// begin wait ( 4 4$40 ) ;
10306: LD_INT 9800
10308: PPUSH
10309: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10313: LD_INT 35
10315: PPUSH
10316: CALL_OW 67
// until not ru_attackers ;
10320: LD_EXP 51
10324: NOT
10325: IFFALSE 10313
// PrepareGnyevko ;
10327: CALL 2037 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10331: LD_EXP 47
10335: PPUSH
10336: LD_INT 124
10338: PPUSH
10339: LD_INT 118
10341: PPUSH
10342: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10346: LD_EXP 47
10350: PPUSH
10351: CALL_OW 200
// time := 0 0$00 ;
10355: LD_ADDR_VAR 0 1
10359: PUSH
10360: LD_INT 0
10362: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10363: LD_INT 35
10365: PPUSH
10366: CALL_OW 67
// time := time + 0 0$1 ;
10370: LD_ADDR_VAR 0 1
10374: PUSH
10375: LD_VAR 0 1
10379: PUSH
10380: LD_INT 35
10382: PLUS
10383: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10384: LD_EXP 47
10388: PPUSH
10389: LD_INT 124
10391: PPUSH
10392: LD_INT 118
10394: PPUSH
10395: CALL_OW 307
10399: PUSH
10400: LD_VAR 0 1
10404: PUSH
10405: LD_INT 1050
10407: GREATEREQUAL
10408: OR
10409: IFFALSE 10363
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10411: LD_EXP 47
10415: PPUSH
10416: LD_STRING DBelkov-Gny-1
10418: PPUSH
10419: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10423: LD_EXP 45
10427: PPUSH
10428: LD_STRING DBelkov-Bur-1a
10430: PPUSH
10431: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10435: LD_INT 35
10437: PPUSH
10438: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10442: LD_EXP 47
10446: PPUSH
10447: LD_INT 22
10449: PUSH
10450: LD_INT 7
10452: PUSH
10453: EMPTY
10454: LIST
10455: LIST
10456: PPUSH
10457: CALL_OW 69
10461: PPUSH
10462: LD_EXP 47
10466: PPUSH
10467: CALL_OW 74
10471: PPUSH
10472: CALL_OW 296
10476: PUSH
10477: LD_INT 8
10479: LESS
10480: IFFALSE 10435
// SetSide ( Gnyevko , 7 ) ;
10482: LD_EXP 47
10486: PPUSH
10487: LD_INT 7
10489: PPUSH
10490: CALL_OW 235
// end ;
10494: PPOPN 1
10496: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10497: LD_EXP 45
10501: PPUSH
10502: CALL_OW 255
10506: PUSH
10507: LD_INT 7
10509: EQUAL
10510: IFFALSE 10520
10512: GO 10514
10514: DISABLE
// begin enable ;
10515: ENABLE
// PrepareAmericanAttack ;
10516: CALL 6343 0 0
// end ;
10520: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10521: LD_INT 22
10523: PUSH
10524: LD_INT 1
10526: PUSH
10527: EMPTY
10528: LIST
10529: LIST
10530: PPUSH
10531: CALL_OW 69
10535: IFFALSE 10719
10537: GO 10539
10539: DISABLE
10540: LD_INT 0
10542: PPUSH
10543: PPUSH
// begin while true do
10544: LD_INT 1
10546: IFFALSE 10603
// begin wait ( 0 0$1 ) ;
10548: LD_INT 35
10550: PPUSH
10551: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10555: LD_ADDR_VAR 0 2
10559: PUSH
10560: LD_INT 22
10562: PUSH
10563: LD_INT 1
10565: PUSH
10566: EMPTY
10567: LIST
10568: LIST
10569: PPUSH
10570: CALL_OW 69
10574: PPUSH
10575: LD_EXP 14
10579: PPUSH
10580: CALL_OW 74
10584: ST_TO_ADDR
// if See ( 7 , tmp ) then
10585: LD_INT 7
10587: PPUSH
10588: LD_VAR 0 2
10592: PPUSH
10593: CALL_OW 292
10597: IFFALSE 10601
// break ;
10599: GO 10603
// end ;
10601: GO 10544
// DialogueOn ;
10603: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10616: LD_VAR 0 2
10620: PPUSH
10621: CALL_OW 250
10625: PPUSH
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 251
10635: PPUSH
10636: LD_INT 7
10638: PPUSH
10639: LD_INT 8
10641: PPUSH
10642: CALL_OW 330
// if Denis then
10646: LD_EXP 20
10650: IFFALSE 10664
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10652: LD_EXP 20
10656: PPUSH
10657: LD_STRING DAmerAttack-Pet-1
10659: PPUSH
10660: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10664: LD_EXP 14
10668: PPUSH
10669: LD_STRING DAmerAttack-JMM-1
10671: PPUSH
10672: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10676: LD_EXP 45
10680: PPUSH
10681: LD_STRING DStop-Bur-1
10683: PPUSH
10684: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// end ;
10719: PPOPN 2
10721: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10722: LD_INT 22
10724: PUSH
10725: LD_INT 3
10727: PUSH
10728: EMPTY
10729: LIST
10730: LIST
10731: PUSH
10732: LD_INT 21
10734: PUSH
10735: LD_INT 1
10737: PUSH
10738: EMPTY
10739: LIST
10740: LIST
10741: PUSH
10742: EMPTY
10743: LIST
10744: LIST
10745: PPUSH
10746: CALL_OW 69
10750: PUSH
10751: LD_INT 0
10753: EQUAL
10754: IFFALSE 10796
10756: GO 10758
10758: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10759: LD_STRING M5a
10761: PPUSH
10762: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10766: LD_EXP 14
10770: PPUSH
10771: LD_STRING D8-JMM-1
10773: PPUSH
10774: CALL_OW 88
// if Gossudarov then
10778: LD_EXP 31
10782: IFFALSE 10796
// Say ( Gossudarov , D8-Gos-1 ) ;
10784: LD_EXP 31
10788: PPUSH
10789: LD_STRING D8-Gos-1
10791: PPUSH
10792: CALL_OW 88
// end ;
10796: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10797: LD_INT 22
10799: PUSH
10800: LD_INT 2
10802: PUSH
10803: EMPTY
10804: LIST
10805: LIST
10806: PUSH
10807: LD_INT 21
10809: PUSH
10810: LD_INT 1
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: EMPTY
10818: LIST
10819: LIST
10820: PPUSH
10821: CALL_OW 69
10825: PUSH
10826: LD_INT 0
10828: EQUAL
10829: IFFALSE 10879
10831: GO 10833
10833: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10834: LD_STRING M4c
10836: PPUSH
10837: CALL_OW 337
// if Roth then
10841: LD_EXP 15
10845: IFFALSE 10861
// Say ( Roth , DStop-Roth-1 ) else
10847: LD_EXP 15
10851: PPUSH
10852: LD_STRING DStop-Roth-1
10854: PPUSH
10855: CALL_OW 88
10859: GO 10879
// if Gossudarov then
10861: LD_EXP 31
10865: IFFALSE 10879
// Say ( Gossudarov , D8-Gos-1a ) ;
10867: LD_EXP 31
10871: PPUSH
10872: LD_STRING D8-Gos-1a
10874: PPUSH
10875: CALL_OW 88
// end ;
10879: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10880: LD_INT 7
10882: PPUSH
10883: LD_INT 1
10885: PPUSH
10886: LD_INT 1
10888: PPUSH
10889: CALL 13980 0 3
10893: PUSH
10894: LD_INT 0
10896: EQUAL
10897: PUSH
10898: LD_INT 7
10900: PPUSH
10901: LD_INT 3
10903: PPUSH
10904: LD_INT 1
10906: PPUSH
10907: CALL 13980 0 3
10911: PUSH
10912: LD_INT 0
10914: EQUAL
10915: AND
10916: IFFALSE 10928
10918: GO 10920
10920: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10921: LD_STRING M1a
10923: PPUSH
10924: CALL_OW 337
// end ;
10928: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10929: LD_INT 22
10931: PUSH
10932: LD_INT 2
10934: PUSH
10935: EMPTY
10936: LIST
10937: LIST
10938: PUSH
10939: LD_INT 21
10941: PUSH
10942: LD_INT 1
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: PUSH
10949: EMPTY
10950: LIST
10951: LIST
10952: PPUSH
10953: CALL_OW 69
10957: PUSH
10958: LD_INT 0
10960: EQUAL
10961: PUSH
10962: LD_INT 22
10964: PUSH
10965: LD_INT 3
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PUSH
10972: LD_INT 21
10974: PUSH
10975: LD_INT 1
10977: PUSH
10978: EMPTY
10979: LIST
10980: LIST
10981: PUSH
10982: EMPTY
10983: LIST
10984: LIST
10985: PPUSH
10986: CALL_OW 69
10990: PUSH
10991: LD_INT 0
10993: EQUAL
10994: AND
10995: PUSH
10996: LD_INT 22
10998: PUSH
10999: LD_INT 1
11001: PUSH
11002: EMPTY
11003: LIST
11004: LIST
11005: PPUSH
11006: CALL_OW 69
11010: PUSH
11011: LD_INT 0
11013: EQUAL
11014: AND
11015: PUSH
11016: LD_INT 7
11018: PPUSH
11019: LD_INT 1
11021: PPUSH
11022: LD_INT 1
11024: PPUSH
11025: CALL 13980 0 3
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 3
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 13980 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: IFFALSE 12397
11055: GO 11057
11057: DISABLE
11058: LD_INT 0
11060: PPUSH
11061: PPUSH
11062: PPUSH
// begin wait ( 0 0$3 ) ;
11063: LD_INT 105
11065: PPUSH
11066: CALL_OW 67
// if not IsDead ( Masha ) then
11070: LD_EXP 48
11074: PPUSH
11075: CALL_OW 301
11079: NOT
11080: IFFALSE 11094
// AddMedal ( Masha , 1 ) else
11082: LD_STRING Masha
11084: PPUSH
11085: LD_INT 1
11087: PPUSH
11088: CALL_OW 101
11092: GO 11105
// AddMedal ( Masha , - 1 ) ;
11094: LD_STRING Masha
11096: PPUSH
11097: LD_INT 1
11099: NEG
11100: PPUSH
11101: CALL_OW 101
// if abdul_escaped then
11105: LD_EXP 12
11109: IFFALSE 11124
// AddMedal ( Abdul , - 1 ) else
11111: LD_STRING Abdul
11113: PPUSH
11114: LD_INT 1
11116: NEG
11117: PPUSH
11118: CALL_OW 101
11122: GO 11134
// AddMedal ( Abdul , 1 ) ;
11124: LD_STRING Abdul
11126: PPUSH
11127: LD_INT 1
11129: PPUSH
11130: CALL_OW 101
// if loss_counter = 0 then
11134: LD_EXP 13
11138: PUSH
11139: LD_INT 0
11141: EQUAL
11142: IFFALSE 11156
// AddMedal ( People , 2 ) else
11144: LD_STRING People
11146: PPUSH
11147: LD_INT 2
11149: PPUSH
11150: CALL_OW 101
11154: GO 11206
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11156: LD_EXP 13
11160: PUSH
11161: LD_INT 3
11163: PUSH
11164: LD_INT 2
11166: PUSH
11167: LD_INT 2
11169: PUSH
11170: EMPTY
11171: LIST
11172: LIST
11173: LIST
11174: PUSH
11175: LD_OWVAR 67
11179: ARRAY
11180: LESSEQUAL
11181: IFFALSE 11195
// AddMedal ( People , 1 ) else
11183: LD_STRING People
11185: PPUSH
11186: LD_INT 1
11188: PPUSH
11189: CALL_OW 101
11193: GO 11206
// AddMedal ( People , - 1 ) ;
11195: LD_STRING People
11197: PPUSH
11198: LD_INT 1
11200: NEG
11201: PPUSH
11202: CALL_OW 101
// GiveMedals ( MAIN ) ;
11206: LD_STRING MAIN
11208: PPUSH
11209: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11213: LD_ADDR_VAR 0 2
11217: PUSH
11218: LD_INT 22
11220: PUSH
11221: LD_INT 7
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 2
11230: PUSH
11231: LD_INT 25
11233: PUSH
11234: LD_INT 1
11236: PUSH
11237: EMPTY
11238: LIST
11239: LIST
11240: PUSH
11241: LD_INT 25
11243: PUSH
11244: LD_INT 2
11246: PUSH
11247: EMPTY
11248: LIST
11249: LIST
11250: PUSH
11251: LD_INT 25
11253: PUSH
11254: LD_INT 3
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PUSH
11261: LD_INT 25
11263: PUSH
11264: LD_INT 4
11266: PUSH
11267: EMPTY
11268: LIST
11269: LIST
11270: PUSH
11271: LD_INT 25
11273: PUSH
11274: LD_INT 5
11276: PUSH
11277: EMPTY
11278: LIST
11279: LIST
11280: PUSH
11281: LD_INT 25
11283: PUSH
11284: LD_INT 8
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: LD_INT 25
11293: PUSH
11294: LD_INT 9
11296: PUSH
11297: EMPTY
11298: LIST
11299: LIST
11300: PUSH
11301: EMPTY
11302: LIST
11303: LIST
11304: LIST
11305: LIST
11306: LIST
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: EMPTY
11312: LIST
11313: LIST
11314: PPUSH
11315: CALL_OW 69
11319: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11320: LD_VAR 0 2
11324: PPUSH
11325: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11329: LD_ADDR_VAR 0 3
11333: PUSH
11334: LD_EXP 14
11338: PUSH
11339: LD_EXP 15
11343: PUSH
11344: LD_EXP 16
11348: PUSH
11349: LD_EXP 17
11353: PUSH
11354: LD_EXP 18
11358: PUSH
11359: LD_EXP 19
11363: PUSH
11364: LD_EXP 20
11368: PUSH
11369: LD_EXP 21
11373: PUSH
11374: LD_EXP 22
11378: PUSH
11379: LD_EXP 23
11383: PUSH
11384: LD_EXP 24
11388: PUSH
11389: LD_EXP 25
11393: PUSH
11394: LD_EXP 26
11398: PUSH
11399: LD_EXP 27
11403: PUSH
11404: LD_EXP 28
11408: PUSH
11409: LD_EXP 29
11413: PUSH
11414: LD_EXP 30
11418: PUSH
11419: LD_EXP 31
11423: PUSH
11424: LD_EXP 32
11428: PUSH
11429: LD_EXP 33
11433: PUSH
11434: LD_EXP 35
11438: PUSH
11439: LD_EXP 36
11443: PUSH
11444: LD_EXP 37
11448: PUSH
11449: LD_EXP 38
11453: PUSH
11454: LD_EXP 39
11458: PUSH
11459: LD_EXP 40
11463: PUSH
11464: LD_EXP 41
11468: PUSH
11469: LD_EXP 42
11473: PUSH
11474: LD_EXP 43
11478: PUSH
11479: LD_EXP 44
11483: PUSH
11484: LD_EXP 45
11488: PUSH
11489: LD_EXP 46
11493: PUSH
11494: LD_EXP 47
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: LIST
11506: LIST
11507: LIST
11508: LIST
11509: LIST
11510: LIST
11511: LIST
11512: LIST
11513: LIST
11514: LIST
11515: LIST
11516: LIST
11517: LIST
11518: LIST
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: ST_TO_ADDR
// if tmp diff tmp2 then
11534: LD_VAR 0 2
11538: PUSH
11539: LD_VAR 0 3
11543: DIFF
11544: IFFALSE 11564
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11546: LD_VAR 0 2
11550: PUSH
11551: LD_VAR 0 3
11555: DIFF
11556: PPUSH
11557: LD_STRING 13a_others
11559: PPUSH
11560: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11564: LD_EXP 14
11568: PPUSH
11569: LD_STRING 13a_JMM
11571: PPUSH
11572: CALL_OW 38
// if Titov then
11576: LD_EXP 33
11580: IFFALSE 11594
// SaveCharacters ( Titov , 13a_Titov ) ;
11582: LD_EXP 33
11586: PPUSH
11587: LD_STRING 13a_Titov
11589: PPUSH
11590: CALL_OW 38
// if Dolgov then
11594: LD_EXP 35
11598: IFFALSE 11612
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11600: LD_EXP 35
11604: PPUSH
11605: LD_STRING 13a_Dolgov
11607: PPUSH
11608: CALL_OW 38
// if Petrosyan then
11612: LD_EXP 36
11616: IFFALSE 11630
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11618: LD_EXP 36
11622: PPUSH
11623: LD_STRING 13a_Petrosyan
11625: PPUSH
11626: CALL_OW 38
// if Scholtze then
11630: LD_EXP 37
11634: IFFALSE 11648
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11636: LD_EXP 37
11640: PPUSH
11641: LD_STRING 13a_Scholtze
11643: PPUSH
11644: CALL_OW 38
// if Oblukov then
11648: LD_EXP 38
11652: IFFALSE 11666
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11654: LD_EXP 38
11658: PPUSH
11659: LD_STRING 13a_Oblukov
11661: PPUSH
11662: CALL_OW 38
// if Kapitsova then
11666: LD_EXP 39
11670: IFFALSE 11684
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11672: LD_EXP 39
11676: PPUSH
11677: LD_STRING 13a_Kapitsova
11679: PPUSH
11680: CALL_OW 38
// if Lipshchin then
11684: LD_EXP 40
11688: IFFALSE 11702
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11690: LD_EXP 40
11694: PPUSH
11695: LD_STRING 13a_Lipshchin
11697: PPUSH
11698: CALL_OW 38
// if Petrovova then
11702: LD_EXP 41
11706: IFFALSE 11720
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11708: LD_EXP 41
11712: PPUSH
11713: LD_STRING 13a_Petrovova
11715: PPUSH
11716: CALL_OW 38
// if Kovalyuk then
11720: LD_EXP 42
11724: IFFALSE 11738
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11726: LD_EXP 42
11730: PPUSH
11731: LD_STRING 13a_Kovalyuk
11733: PPUSH
11734: CALL_OW 38
// if Kuzmov then
11738: LD_EXP 43
11742: IFFALSE 11756
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11744: LD_EXP 43
11748: PPUSH
11749: LD_STRING 13a_Kuzmov
11751: PPUSH
11752: CALL_OW 38
// if Karamazov then
11756: LD_EXP 44
11760: IFFALSE 11774
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11762: LD_EXP 44
11766: PPUSH
11767: LD_STRING 13a_Karamazov
11769: PPUSH
11770: CALL_OW 38
// if Burlak then
11774: LD_EXP 45
11778: IFFALSE 11792
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11780: LD_EXP 45
11784: PPUSH
11785: LD_STRING 13a_Burlak
11787: PPUSH
11788: CALL_OW 38
// if Belkov then
11792: LD_EXP 46
11796: IFFALSE 11810
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11798: LD_EXP 46
11802: PPUSH
11803: LD_STRING 13a_Belkov
11805: PPUSH
11806: CALL_OW 38
// if Gnyevko then
11810: LD_EXP 47
11814: IFFALSE 11828
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11816: LD_EXP 47
11820: PPUSH
11821: LD_STRING 13a_Gnyevko
11823: PPUSH
11824: CALL_OW 38
// if Lisa then
11828: LD_EXP 16
11832: IFFALSE 11846
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11834: LD_EXP 16
11838: PPUSH
11839: LD_STRING 13a_Lisa
11841: PPUSH
11842: CALL_OW 38
// if Donaldson then
11846: LD_EXP 17
11850: IFFALSE 11864
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11852: LD_EXP 17
11856: PPUSH
11857: LD_STRING 13a_Donaldson
11859: PPUSH
11860: CALL_OW 38
// if Bobby then
11864: LD_EXP 18
11868: IFFALSE 11882
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11870: LD_EXP 18
11874: PPUSH
11875: LD_STRING 13a_Bobby
11877: PPUSH
11878: CALL_OW 38
// if Cyrus then
11882: LD_EXP 19
11886: IFFALSE 11900
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11888: LD_EXP 19
11892: PPUSH
11893: LD_STRING 13a_Cyrus
11895: PPUSH
11896: CALL_OW 38
// if Denis then
11900: LD_EXP 20
11904: IFFALSE 11918
// SaveCharacters ( Denis , 13a_Denis ) ;
11906: LD_EXP 20
11910: PPUSH
11911: LD_STRING 13a_Denis
11913: PPUSH
11914: CALL_OW 38
// if Brown then
11918: LD_EXP 21
11922: IFFALSE 11936
// SaveCharacters ( Brown , 13a_Brown ) ;
11924: LD_EXP 21
11928: PPUSH
11929: LD_STRING 13a_Brown
11931: PPUSH
11932: CALL_OW 38
// if Gladstone then
11936: LD_EXP 22
11940: IFFALSE 11954
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11942: LD_EXP 22
11946: PPUSH
11947: LD_STRING 13a_Gladstone
11949: PPUSH
11950: CALL_OW 38
// if Houten then
11954: LD_EXP 23
11958: IFFALSE 11972
// SaveCharacters ( Houten , 13a_Houten ) ;
11960: LD_EXP 23
11964: PPUSH
11965: LD_STRING 13a_Houten
11967: PPUSH
11968: CALL_OW 38
// if Cornel then
11972: LD_EXP 24
11976: IFFALSE 11990
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11978: LD_EXP 24
11982: PPUSH
11983: LD_STRING 13a_Cornel
11985: PPUSH
11986: CALL_OW 38
// if Gary then
11990: LD_EXP 25
11994: IFFALSE 12008
// SaveCharacters ( Gary , 13a_Gary ) ;
11996: LD_EXP 25
12000: PPUSH
12001: LD_STRING 13a_Gary
12003: PPUSH
12004: CALL_OW 38
// if Frank then
12008: LD_EXP 26
12012: IFFALSE 12026
// SaveCharacters ( Frank , 13a_Frank ) ;
12014: LD_EXP 26
12018: PPUSH
12019: LD_STRING 13a_Frank
12021: PPUSH
12022: CALL_OW 38
// if Kikuchi then
12026: LD_EXP 27
12030: IFFALSE 12044
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12032: LD_EXP 27
12036: PPUSH
12037: LD_STRING 13a_Kikuchi
12039: PPUSH
12040: CALL_OW 38
// if Simms then
12044: LD_EXP 28
12048: IFFALSE 12062
// SaveCharacters ( Simms , 13a_Simms ) ;
12050: LD_EXP 28
12054: PPUSH
12055: LD_STRING 13a_Simms
12057: PPUSH
12058: CALL_OW 38
// if Joan then
12062: LD_EXP 29
12066: IFFALSE 12080
// SaveCharacters ( Joan , 13a_Joan ) ;
12068: LD_EXP 29
12072: PPUSH
12073: LD_STRING 13a_Joan
12075: PPUSH
12076: CALL_OW 38
// if DeltaDoctor then
12080: LD_EXP 30
12084: IFFALSE 12098
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12086: LD_EXP 30
12090: PPUSH
12091: LD_STRING 13a_DeltaDoctor
12093: PPUSH
12094: CALL_OW 38
// if Gossudarov then
12098: LD_EXP 31
12102: IFFALSE 12116
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12104: LD_EXP 31
12108: PPUSH
12109: LD_STRING 13a_Gossudarov
12111: PPUSH
12112: CALL_OW 38
// if Kirilenkova then
12116: LD_EXP 32
12120: IFFALSE 12134
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12122: LD_EXP 32
12126: PPUSH
12127: LD_STRING 13a_Kirilenkova
12129: PPUSH
12130: CALL_OW 38
// if Masha then
12134: LD_EXP 48
12138: IFFALSE 12193
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12140: LD_EXP 48
12144: PPUSH
12145: CALL_OW 265
12149: PUSH
12150: LD_EXP 48
12154: PPUSH
12155: CALL_OW 262
12159: PUSH
12160: LD_EXP 48
12164: PPUSH
12165: CALL_OW 263
12169: PUSH
12170: LD_EXP 48
12174: PPUSH
12175: CALL_OW 264
12179: PUSH
12180: EMPTY
12181: LIST
12182: LIST
12183: LIST
12184: LIST
12185: PPUSH
12186: LD_STRING 13a_Masha
12188: PPUSH
12189: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12193: LD_ADDR_VAR 0 2
12197: PUSH
12198: LD_INT 21
12200: PUSH
12201: LD_INT 3
12203: PUSH
12204: EMPTY
12205: LIST
12206: LIST
12207: PPUSH
12208: CALL_OW 69
12212: ST_TO_ADDR
// tmp2 := [ ] ;
12213: LD_ADDR_VAR 0 3
12217: PUSH
12218: EMPTY
12219: ST_TO_ADDR
// if tmp then
12220: LD_VAR 0 2
12224: IFFALSE 12375
// for i in tmp do
12226: LD_ADDR_VAR 0 1
12230: PUSH
12231: LD_VAR 0 2
12235: PUSH
12236: FOR_IN
12237: IFFALSE 12373
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12239: LD_ADDR_VAR 0 3
12243: PUSH
12244: LD_VAR 0 3
12248: PUSH
12249: LD_VAR 0 1
12253: PPUSH
12254: CALL_OW 255
12258: PUSH
12259: LD_VAR 0 1
12263: PPUSH
12264: CALL_OW 248
12268: PUSH
12269: LD_VAR 0 1
12273: PPUSH
12274: CALL_OW 266
12278: PUSH
12279: LD_VAR 0 1
12283: PPUSH
12284: CALL_OW 250
12288: PUSH
12289: LD_VAR 0 1
12293: PPUSH
12294: CALL_OW 251
12298: PUSH
12299: LD_VAR 0 1
12303: PPUSH
12304: CALL_OW 254
12308: PUSH
12309: LD_VAR 0 1
12313: PPUSH
12314: CALL_OW 267
12318: PUSH
12319: LD_VAR 0 1
12323: PPUSH
12324: LD_INT 1
12326: PPUSH
12327: CALL_OW 268
12331: PUSH
12332: LD_VAR 0 1
12336: PPUSH
12337: LD_INT 2
12339: PPUSH
12340: CALL_OW 268
12344: PUSH
12345: LD_VAR 0 1
12349: PPUSH
12350: CALL_OW 269
12354: PUSH
12355: EMPTY
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: LIST
12364: LIST
12365: LIST
12366: PUSH
12367: EMPTY
12368: LIST
12369: ADD
12370: ST_TO_ADDR
12371: GO 12236
12373: POP
12374: POP
// if tmp2 then
12375: LD_VAR 0 3
12379: IFFALSE 12393
// SaveVariable ( tmp2 , 13a_buildings ) ;
12381: LD_VAR 0 3
12385: PPUSH
12386: LD_STRING 13a_buildings
12388: PPUSH
12389: CALL_OW 39
// YouWin ;
12393: CALL_OW 103
// end ;
12397: PPOPN 3
12399: END
// export function SciRu ; var tmp , t ; begin
12400: LD_INT 0
12402: PPUSH
12403: PPUSH
12404: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12405: LD_ADDR_VAR 0 3
12409: PUSH
12410: LD_EXP 31
12414: PUSH
12415: LD_EXP 45
12419: PUSH
12420: LD_EXP 33
12424: PUSH
12425: LD_EXP 46
12429: PUSH
12430: LD_EXP 47
12434: PUSH
12435: LD_EXP 36
12439: PUSH
12440: LD_EXP 37
12444: PUSH
12445: LD_EXP 35
12449: PUSH
12450: EMPTY
12451: LIST
12452: LIST
12453: LIST
12454: LIST
12455: LIST
12456: LIST
12457: LIST
12458: LIST
12459: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12460: LD_ADDR_VAR 0 2
12464: PUSH
12465: LD_INT 22
12467: PUSH
12468: LD_INT 7
12470: PUSH
12471: EMPTY
12472: LIST
12473: LIST
12474: PUSH
12475: LD_INT 23
12477: PUSH
12478: LD_INT 3
12480: PUSH
12481: EMPTY
12482: LIST
12483: LIST
12484: PUSH
12485: LD_INT 25
12487: PUSH
12488: LD_INT 4
12490: PUSH
12491: EMPTY
12492: LIST
12493: LIST
12494: PUSH
12495: LD_INT 26
12497: PUSH
12498: LD_INT 1
12500: PUSH
12501: EMPTY
12502: LIST
12503: LIST
12504: PUSH
12505: EMPTY
12506: LIST
12507: LIST
12508: LIST
12509: LIST
12510: PPUSH
12511: CALL_OW 69
12515: PUSH
12516: LD_VAR 0 3
12520: DIFF
12521: ST_TO_ADDR
// if tmp then
12522: LD_VAR 0 2
12526: IFFALSE 12542
// result := tmp [ 1 ] ;
12528: LD_ADDR_VAR 0 1
12532: PUSH
12533: LD_VAR 0 2
12537: PUSH
12538: LD_INT 1
12540: ARRAY
12541: ST_TO_ADDR
// end ;
12542: LD_VAR 0 1
12546: RET
// export function SolRu ; var tmp , t ; begin
12547: LD_INT 0
12549: PPUSH
12550: PPUSH
12551: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12552: LD_ADDR_VAR 0 3
12556: PUSH
12557: LD_EXP 31
12561: PUSH
12562: LD_EXP 45
12566: PUSH
12567: LD_EXP 33
12571: PUSH
12572: LD_EXP 46
12576: PUSH
12577: LD_EXP 47
12581: PUSH
12582: LD_EXP 36
12586: PUSH
12587: LD_EXP 37
12591: PUSH
12592: LD_EXP 35
12596: PUSH
12597: EMPTY
12598: LIST
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12607: LD_ADDR_VAR 0 2
12611: PUSH
12612: LD_INT 22
12614: PUSH
12615: LD_INT 7
12617: PUSH
12618: EMPTY
12619: LIST
12620: LIST
12621: PUSH
12622: LD_INT 23
12624: PUSH
12625: LD_INT 3
12627: PUSH
12628: EMPTY
12629: LIST
12630: LIST
12631: PUSH
12632: LD_INT 25
12634: PUSH
12635: LD_INT 1
12637: PUSH
12638: EMPTY
12639: LIST
12640: LIST
12641: PUSH
12642: LD_INT 26
12644: PUSH
12645: LD_INT 1
12647: PUSH
12648: EMPTY
12649: LIST
12650: LIST
12651: PUSH
12652: EMPTY
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: PPUSH
12658: CALL_OW 69
12662: PUSH
12663: LD_VAR 0 3
12667: DIFF
12668: ST_TO_ADDR
// if tmp then
12669: LD_VAR 0 2
12673: IFFALSE 12689
// result := tmp [ 1 ] ;
12675: LD_ADDR_VAR 0 1
12679: PUSH
12680: LD_VAR 0 2
12684: PUSH
12685: LD_INT 1
12687: ARRAY
12688: ST_TO_ADDR
// end ; end_of_file
12689: LD_VAR 0 1
12693: RET
// export function CustomEvent ( event ) ; begin
12694: LD_INT 0
12696: PPUSH
// end ;
12697: LD_VAR 0 2
12701: RET
// on UnitDestroyed ( un ) do var i , side ;
12702: LD_INT 0
12704: PPUSH
12705: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12706: LD_VAR 0 1
12710: PUSH
12711: LD_INT 22
12713: PUSH
12714: LD_INT 7
12716: PUSH
12717: EMPTY
12718: LIST
12719: LIST
12720: PUSH
12721: LD_INT 2
12723: PUSH
12724: LD_INT 25
12726: PUSH
12727: LD_INT 1
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PUSH
12734: LD_INT 25
12736: PUSH
12737: LD_INT 2
12739: PUSH
12740: EMPTY
12741: LIST
12742: LIST
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 3
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 25
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: LD_INT 25
12766: PUSH
12767: LD_INT 5
12769: PUSH
12770: EMPTY
12771: LIST
12772: LIST
12773: PUSH
12774: LD_INT 25
12776: PUSH
12777: LD_INT 8
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: PUSH
12784: LD_INT 25
12786: PUSH
12787: LD_INT 9
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PPUSH
12808: CALL_OW 69
12812: IN
12813: IFFALSE 12829
// loss_counter := loss_counter + 1 ;
12815: LD_ADDR_EXP 13
12819: PUSH
12820: LD_EXP 13
12824: PUSH
12825: LD_INT 1
12827: PLUS
12828: ST_TO_ADDR
// if un = Abdul then
12829: LD_VAR 0 1
12833: PUSH
12834: LD_EXP 54
12838: EQUAL
12839: IFFALSE 12849
// abdul_escaped := false ;
12841: LD_ADDR_EXP 12
12845: PUSH
12846: LD_INT 0
12848: ST_TO_ADDR
// if un in ru_attackers then
12849: LD_VAR 0 1
12853: PUSH
12854: LD_EXP 51
12858: IN
12859: IFFALSE 12877
// ru_attackers := ru_attackers diff un ;
12861: LD_ADDR_EXP 51
12865: PUSH
12866: LD_EXP 51
12870: PUSH
12871: LD_VAR 0 1
12875: DIFF
12876: ST_TO_ADDR
// if un in ar_attackers then
12877: LD_VAR 0 1
12881: PUSH
12882: LD_EXP 10
12886: IN
12887: IFFALSE 12905
// ar_attackers := ar_attackers diff un ;
12889: LD_ADDR_EXP 10
12893: PUSH
12894: LD_EXP 10
12898: PUSH
12899: LD_VAR 0 1
12903: DIFF
12904: ST_TO_ADDR
// if un = JMM then
12905: LD_VAR 0 1
12909: PUSH
12910: LD_EXP 14
12914: EQUAL
12915: IFFALSE 12926
// begin YouLost ( JMM ) ;
12917: LD_STRING JMM
12919: PPUSH
12920: CALL_OW 104
// exit ;
12924: GO 13015
// end ; if un = Burlak then
12926: LD_VAR 0 1
12930: PUSH
12931: LD_EXP 45
12935: EQUAL
12936: IFFALSE 12947
// begin YouLost ( Burlak ) ;
12938: LD_STRING Burlak
12940: PPUSH
12941: CALL_OW 104
// exit ;
12945: GO 13015
// end ; if un = freedom then
12947: LD_VAR 0 1
12951: PUSH
12952: LD_EXP 3
12956: EQUAL
12957: IFFALSE 12968
// begin YouLost ( Destroyed ) ;
12959: LD_STRING Destroyed
12961: PPUSH
12962: CALL_OW 104
// exit ;
12966: GO 13015
// end ; if un = Masha then
12968: LD_VAR 0 1
12972: PUSH
12973: LD_EXP 48
12977: EQUAL
12978: IFFALSE 12987
// ChangeMissionObjectives ( M4b ) ;
12980: LD_STRING M4b
12982: PPUSH
12983: CALL_OW 337
// if un = Mastodont then
12987: LD_VAR 0 1
12991: PUSH
12992: LD_EXP 55
12996: EQUAL
12997: IFFALSE 13006
// ChangeMissionObjectives ( M4a ) ;
12999: LD_STRING M4a
13001: PPUSH
13002: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13006: LD_VAR 0 1
13010: PPUSH
13011: CALL 83102 0 1
// end ;
13015: PPOPN 3
13017: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13018: LD_VAR 0 1
13022: PPUSH
13023: LD_VAR 0 2
13027: PPUSH
13028: CALL 85081 0 2
// end ;
13032: PPOPN 2
13034: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13035: LD_VAR 0 1
13039: PPUSH
13040: CALL 84149 0 1
// end ;
13044: PPOPN 1
13046: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13047: LD_VAR 0 1
13051: PUSH
13052: LD_INT 22
13054: PUSH
13055: LD_INT 7
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: PUSH
13062: LD_INT 30
13064: PUSH
13065: LD_INT 0
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: PUSH
13072: EMPTY
13073: LIST
13074: LIST
13075: PPUSH
13076: CALL_OW 69
13080: IN
13081: IFFALSE 13120
// begin SetBName ( building , freedom ) ;
13083: LD_VAR 0 1
13087: PPUSH
13088: LD_STRING freedom
13090: PPUSH
13091: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13095: LD_INT 0
13097: PPUSH
13098: LD_INT 7
13100: PPUSH
13101: LD_INT 0
13103: PPUSH
13104: CALL_OW 324
// freedom := building ;
13108: LD_ADDR_EXP 3
13112: PUSH
13113: LD_VAR 0 1
13117: ST_TO_ADDR
// exit ;
13118: GO 13186
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13120: LD_VAR 0 1
13124: PUSH
13125: LD_INT 22
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: PUSH
13135: LD_INT 23
13137: PUSH
13138: LD_INT 3
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 30
13147: PUSH
13148: LD_INT 6
13150: PUSH
13151: EMPTY
13152: LIST
13153: LIST
13154: PUSH
13155: EMPTY
13156: LIST
13157: LIST
13158: LIST
13159: PPUSH
13160: CALL_OW 69
13164: IN
13165: IFFALSE 13177
// begin ru_lab_builded := true ;
13167: LD_ADDR_EXP 5
13171: PUSH
13172: LD_INT 1
13174: ST_TO_ADDR
// exit ;
13175: GO 13186
// end ; MCE_BuildingComplete ( building ) ;
13177: LD_VAR 0 1
13181: PPUSH
13182: CALL 84390 0 1
// end ;
13186: PPOPN 1
13188: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13189: LD_VAR 0 1
13193: PPUSH
13194: LD_VAR 0 2
13198: PPUSH
13199: CALL 82798 0 2
// end ;
13203: PPOPN 2
13205: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13206: LD_VAR 0 1
13210: PPUSH
13211: LD_VAR 0 2
13215: PPUSH
13216: LD_VAR 0 3
13220: PPUSH
13221: LD_VAR 0 4
13225: PPUSH
13226: LD_VAR 0 5
13230: PPUSH
13231: CALL 82418 0 5
// end ;
13235: PPOPN 5
13237: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13238: LD_VAR 0 1
13242: PPUSH
13243: LD_VAR 0 2
13247: PPUSH
13248: CALL 82008 0 2
// end ;
13252: PPOPN 2
13254: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13255: LD_VAR 0 1
13259: PPUSH
13260: LD_VAR 0 2
13264: PPUSH
13265: LD_VAR 0 3
13269: PPUSH
13270: LD_VAR 0 4
13274: PPUSH
13275: CALL 81846 0 4
// end ;
13279: PPOPN 4
13281: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13282: LD_VAR 0 1
13286: PPUSH
13287: LD_VAR 0 2
13291: PPUSH
13292: LD_VAR 0 3
13296: PPUSH
13297: CALL 81621 0 3
// end ;
13301: PPOPN 3
13303: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13304: LD_VAR 0 1
13308: PPUSH
13309: LD_VAR 0 2
13313: PPUSH
13314: CALL 81506 0 2
// end ;
13318: PPOPN 2
13320: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13321: LD_VAR 0 1
13325: PPUSH
13326: LD_VAR 0 2
13330: PPUSH
13331: CALL 85342 0 2
// end ;
13335: PPOPN 2
13337: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13338: LD_VAR 0 1
13342: PPUSH
13343: LD_VAR 0 2
13347: PPUSH
13348: LD_VAR 0 3
13352: PPUSH
13353: LD_VAR 0 4
13357: PPUSH
13358: CALL 85558 0 4
// end ;
13362: PPOPN 4
13364: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13365: LD_VAR 0 1
13369: PPUSH
13370: LD_VAR 0 2
13374: PPUSH
13375: CALL 81315 0 2
// end ; end_of_file
13379: PPOPN 2
13381: END
// every 0 0$30 do var cr , time ;
13382: GO 13384
13384: DISABLE
13385: LD_INT 0
13387: PPUSH
13388: PPUSH
// begin time := 0 0$30 ;
13389: LD_ADDR_VAR 0 2
13393: PUSH
13394: LD_INT 1050
13396: ST_TO_ADDR
// while game do
13397: LD_EXP 2
13401: IFFALSE 13500
// begin wait ( time ) ;
13403: LD_VAR 0 2
13407: PPUSH
13408: CALL_OW 67
// if tick > 2 2$00 then
13412: LD_OWVAR 1
13416: PUSH
13417: LD_INT 4200
13419: GREATER
13420: IFFALSE 13453
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13422: LD_ADDR_VAR 0 2
13426: PUSH
13427: LD_VAR 0 2
13431: PUSH
13432: LD_INT 280
13434: PUSH
13435: LD_INT 420
13437: PUSH
13438: LD_INT 630
13440: PUSH
13441: EMPTY
13442: LIST
13443: LIST
13444: LIST
13445: PUSH
13446: LD_OWVAR 67
13450: ARRAY
13451: PLUS
13452: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13453: LD_INT 1
13455: PPUSH
13456: LD_INT 5
13458: PPUSH
13459: CALL_OW 12
13463: PPUSH
13464: LD_INT 70
13466: PPUSH
13467: LD_INT 49
13469: PPUSH
13470: LD_INT 25
13472: PPUSH
13473: LD_INT 1
13475: PPUSH
13476: CALL_OW 56
// if time > 5 5$00 then
13480: LD_VAR 0 2
13484: PUSH
13485: LD_INT 10500
13487: GREATER
13488: IFFALSE 13498
// time := 0 0$30 ;
13490: LD_ADDR_VAR 0 2
13494: PUSH
13495: LD_INT 1050
13497: ST_TO_ADDR
// end ;
13498: GO 13397
// end ;
13500: PPOPN 2
13502: END
// every 0 0$30 do var cr , time ;
13503: GO 13505
13505: DISABLE
13506: LD_INT 0
13508: PPUSH
13509: PPUSH
// begin time := 0 0$20 ;
13510: LD_ADDR_VAR 0 2
13514: PUSH
13515: LD_INT 700
13517: ST_TO_ADDR
// while game do
13518: LD_EXP 2
13522: IFFALSE 13611
// begin wait ( time ) ;
13524: LD_VAR 0 2
13528: PPUSH
13529: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13533: LD_ADDR_VAR 0 2
13537: PUSH
13538: LD_VAR 0 2
13542: PUSH
13543: LD_INT 490
13545: PUSH
13546: LD_INT 525
13548: PUSH
13549: LD_INT 560
13551: PUSH
13552: EMPTY
13553: LIST
13554: LIST
13555: LIST
13556: PUSH
13557: LD_OWVAR 67
13561: ARRAY
13562: PLUS
13563: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13564: LD_INT 3
13566: PPUSH
13567: LD_INT 5
13569: PPUSH
13570: CALL_OW 12
13574: PPUSH
13575: LD_INT 26
13577: PPUSH
13578: LD_INT 9
13580: PPUSH
13581: LD_INT 30
13583: PPUSH
13584: LD_INT 1
13586: PPUSH
13587: CALL_OW 56
// if time > 3 3$00 then
13591: LD_VAR 0 2
13595: PUSH
13596: LD_INT 6300
13598: GREATER
13599: IFFALSE 13609
// time := 0 0$20 ;
13601: LD_ADDR_VAR 0 2
13605: PUSH
13606: LD_INT 700
13608: ST_TO_ADDR
// end ;
13609: GO 13518
// end ;
13611: PPOPN 2
13613: END
// every 0 0$30 do var cr , time ;
13614: GO 13616
13616: DISABLE
13617: LD_INT 0
13619: PPUSH
13620: PPUSH
// begin time := 0 0$20 ;
13621: LD_ADDR_VAR 0 2
13625: PUSH
13626: LD_INT 700
13628: ST_TO_ADDR
// while game do
13629: LD_EXP 2
13633: IFFALSE 13758
// begin wait ( time ) ;
13635: LD_VAR 0 2
13639: PPUSH
13640: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13644: LD_ADDR_VAR 0 2
13648: PUSH
13649: LD_VAR 0 2
13653: PUSH
13654: LD_INT 175
13656: PUSH
13657: LD_INT 210
13659: PUSH
13660: LD_INT 280
13662: PUSH
13663: EMPTY
13664: LIST
13665: LIST
13666: LIST
13667: PUSH
13668: LD_OWVAR 67
13672: ARRAY
13673: PLUS
13674: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13675: LD_INT 1
13677: PPUSH
13678: LD_INT 5
13680: PPUSH
13681: CALL_OW 12
13685: PPUSH
13686: LD_INT 179
13688: PPUSH
13689: LD_INT 101
13691: PPUSH
13692: LD_INT 20
13694: PPUSH
13695: LD_INT 1
13697: PPUSH
13698: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13702: LD_INT 350
13704: PPUSH
13705: LD_INT 525
13707: PPUSH
13708: CALL_OW 12
13712: PPUSH
13713: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13717: LD_INT 1
13719: PPUSH
13720: LD_INT 5
13722: PPUSH
13723: CALL_OW 12
13727: PPUSH
13728: LD_INT 9
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 55
// if time > 4 4$00 then
13738: LD_VAR 0 2
13742: PUSH
13743: LD_INT 8400
13745: GREATER
13746: IFFALSE 13756
// time := 0 0$30 ;
13748: LD_ADDR_VAR 0 2
13752: PUSH
13753: LD_INT 1050
13755: ST_TO_ADDR
// end ;
13756: GO 13629
// end ;
13758: PPOPN 2
13760: END
// every 0 0$30 do var cr , time ;
13761: GO 13763
13763: DISABLE
13764: LD_INT 0
13766: PPUSH
13767: PPUSH
// begin time := 0 0$10 ;
13768: LD_ADDR_VAR 0 2
13772: PUSH
13773: LD_INT 350
13775: ST_TO_ADDR
// while game do
13776: LD_EXP 2
13780: IFFALSE 13914
// begin wait ( time ) ;
13782: LD_VAR 0 2
13786: PPUSH
13787: CALL_OW 67
// time := time + 0 0$10 ;
13791: LD_ADDR_VAR 0 2
13795: PUSH
13796: LD_VAR 0 2
13800: PUSH
13801: LD_INT 350
13803: PLUS
13804: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13805: LD_INT 1
13807: PPUSH
13808: LD_INT 5
13810: PPUSH
13811: CALL_OW 12
13815: PPUSH
13816: LD_INT 11
13818: PPUSH
13819: LD_INT 1
13821: PPUSH
13822: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13826: LD_ADDR_VAR 0 1
13830: PUSH
13831: LD_INT 1
13833: PPUSH
13834: LD_INT 3
13836: PPUSH
13837: CALL_OW 12
13841: ST_TO_ADDR
// if cr = 1 then
13842: LD_VAR 0 1
13846: PUSH
13847: LD_INT 1
13849: EQUAL
13850: IFFALSE 13894
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13852: LD_INT 700
13854: PPUSH
13855: LD_INT 1575
13857: PPUSH
13858: CALL_OW 12
13862: PPUSH
13863: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13867: LD_INT 1
13869: PPUSH
13870: LD_INT 5
13872: PPUSH
13873: CALL_OW 12
13877: PPUSH
13878: LD_INT 34
13880: PPUSH
13881: LD_INT 50
13883: PPUSH
13884: LD_INT 7
13886: PPUSH
13887: LD_INT 1
13889: PPUSH
13890: CALL_OW 56
// end ; if time > 8 8$00 then
13894: LD_VAR 0 2
13898: PUSH
13899: LD_INT 16800
13901: GREATER
13902: IFFALSE 13912
// time := 0 0$40 ;
13904: LD_ADDR_VAR 0 2
13908: PUSH
13909: LD_INT 1400
13911: ST_TO_ADDR
// end ;
13912: GO 13776
// end ; end_of_file
13914: PPOPN 2
13916: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13917: LD_INT 0
13919: PPUSH
13920: PPUSH
// if exist_mode then
13921: LD_VAR 0 2
13925: IFFALSE 13950
// unit := CreateCharacter ( prefix & ident ) else
13927: LD_ADDR_VAR 0 5
13931: PUSH
13932: LD_VAR 0 3
13936: PUSH
13937: LD_VAR 0 1
13941: STR
13942: PPUSH
13943: CALL_OW 34
13947: ST_TO_ADDR
13948: GO 13965
// unit := NewCharacter ( ident ) ;
13950: LD_ADDR_VAR 0 5
13954: PUSH
13955: LD_VAR 0 1
13959: PPUSH
13960: CALL_OW 25
13964: ST_TO_ADDR
// result := unit ;
13965: LD_ADDR_VAR 0 4
13969: PUSH
13970: LD_VAR 0 5
13974: ST_TO_ADDR
// end ;
13975: LD_VAR 0 4
13979: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
13980: LD_INT 0
13982: PPUSH
13983: PPUSH
// if not side or not nation then
13984: LD_VAR 0 1
13988: NOT
13989: PUSH
13990: LD_VAR 0 2
13994: NOT
13995: OR
13996: IFFALSE 14000
// exit ;
13998: GO 14636
// case nation of nation_american :
14000: LD_VAR 0 2
14004: PUSH
14005: LD_INT 1
14007: DOUBLE
14008: EQUAL
14009: IFTRUE 14013
14011: GO 14183
14013: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
14014: LD_ADDR_VAR 0 4
14018: PUSH
14019: LD_INT 35
14021: PUSH
14022: LD_INT 45
14024: PUSH
14025: LD_INT 46
14027: PUSH
14028: LD_INT 47
14030: PUSH
14031: LD_INT 1
14033: PUSH
14034: LD_INT 2
14036: PUSH
14037: LD_INT 6
14039: PUSH
14040: LD_INT 15
14042: PUSH
14043: LD_INT 16
14045: PUSH
14046: LD_INT 7
14048: PUSH
14049: LD_INT 12
14051: PUSH
14052: LD_INT 13
14054: PUSH
14055: LD_INT 10
14057: PUSH
14058: LD_INT 14
14060: PUSH
14061: LD_INT 20
14063: PUSH
14064: LD_INT 21
14066: PUSH
14067: LD_INT 22
14069: PUSH
14070: LD_INT 25
14072: PUSH
14073: LD_INT 32
14075: PUSH
14076: LD_INT 27
14078: PUSH
14079: LD_INT 36
14081: PUSH
14082: LD_INT 69
14084: PUSH
14085: LD_INT 39
14087: PUSH
14088: LD_INT 34
14090: PUSH
14091: LD_INT 40
14093: PUSH
14094: LD_INT 48
14096: PUSH
14097: LD_INT 49
14099: PUSH
14100: LD_INT 50
14102: PUSH
14103: LD_INT 51
14105: PUSH
14106: LD_INT 52
14108: PUSH
14109: LD_INT 53
14111: PUSH
14112: LD_INT 54
14114: PUSH
14115: LD_INT 55
14117: PUSH
14118: LD_INT 56
14120: PUSH
14121: LD_INT 57
14123: PUSH
14124: LD_INT 58
14126: PUSH
14127: LD_INT 59
14129: PUSH
14130: LD_INT 60
14132: PUSH
14133: LD_INT 61
14135: PUSH
14136: LD_INT 62
14138: PUSH
14139: EMPTY
14140: LIST
14141: LIST
14142: LIST
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: LIST
14152: LIST
14153: LIST
14154: LIST
14155: LIST
14156: LIST
14157: LIST
14158: LIST
14159: LIST
14160: LIST
14161: LIST
14162: LIST
14163: LIST
14164: LIST
14165: LIST
14166: LIST
14167: LIST
14168: LIST
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: LIST
14174: LIST
14175: LIST
14176: LIST
14177: LIST
14178: LIST
14179: LIST
14180: ST_TO_ADDR
14181: GO 14560
14183: LD_INT 2
14185: DOUBLE
14186: EQUAL
14187: IFTRUE 14191
14189: GO 14369
14191: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
14192: LD_ADDR_VAR 0 4
14196: PUSH
14197: LD_INT 35
14199: PUSH
14200: LD_INT 45
14202: PUSH
14203: LD_INT 46
14205: PUSH
14206: LD_INT 47
14208: PUSH
14209: LD_INT 70
14211: PUSH
14212: LD_INT 1
14214: PUSH
14215: LD_INT 11
14217: PUSH
14218: LD_INT 3
14220: PUSH
14221: LD_INT 4
14223: PUSH
14224: LD_INT 5
14226: PUSH
14227: LD_INT 6
14229: PUSH
14230: LD_INT 15
14232: PUSH
14233: LD_INT 18
14235: PUSH
14236: LD_INT 7
14238: PUSH
14239: LD_INT 17
14241: PUSH
14242: LD_INT 8
14244: PUSH
14245: LD_INT 20
14247: PUSH
14248: LD_INT 21
14250: PUSH
14251: LD_INT 22
14253: PUSH
14254: LD_INT 72
14256: PUSH
14257: LD_INT 26
14259: PUSH
14260: LD_INT 69
14262: PUSH
14263: LD_INT 39
14265: PUSH
14266: LD_INT 40
14268: PUSH
14269: LD_INT 41
14271: PUSH
14272: LD_INT 42
14274: PUSH
14275: LD_INT 43
14277: PUSH
14278: LD_INT 48
14280: PUSH
14281: LD_INT 49
14283: PUSH
14284: LD_INT 50
14286: PUSH
14287: LD_INT 51
14289: PUSH
14290: LD_INT 52
14292: PUSH
14293: LD_INT 53
14295: PUSH
14296: LD_INT 54
14298: PUSH
14299: LD_INT 55
14301: PUSH
14302: LD_INT 56
14304: PUSH
14305: LD_INT 60
14307: PUSH
14308: LD_INT 61
14310: PUSH
14311: LD_INT 62
14313: PUSH
14314: LD_INT 66
14316: PUSH
14317: LD_INT 67
14319: PUSH
14320: LD_INT 68
14322: PUSH
14323: EMPTY
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: LIST
14331: LIST
14332: LIST
14333: LIST
14334: LIST
14335: LIST
14336: LIST
14337: LIST
14338: LIST
14339: LIST
14340: LIST
14341: LIST
14342: LIST
14343: LIST
14344: LIST
14345: LIST
14346: LIST
14347: LIST
14348: LIST
14349: LIST
14350: LIST
14351: LIST
14352: LIST
14353: LIST
14354: LIST
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: ST_TO_ADDR
14367: GO 14560
14369: LD_INT 3
14371: DOUBLE
14372: EQUAL
14373: IFTRUE 14377
14375: GO 14559
14377: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14378: LD_ADDR_VAR 0 4
14382: PUSH
14383: LD_INT 46
14385: PUSH
14386: LD_INT 47
14388: PUSH
14389: LD_INT 1
14391: PUSH
14392: LD_INT 2
14394: PUSH
14395: LD_INT 11
14397: PUSH
14398: LD_INT 9
14400: PUSH
14401: LD_INT 20
14403: PUSH
14404: LD_INT 19
14406: PUSH
14407: LD_INT 21
14409: PUSH
14410: LD_INT 24
14412: PUSH
14413: LD_INT 22
14415: PUSH
14416: LD_INT 25
14418: PUSH
14419: LD_INT 28
14421: PUSH
14422: LD_INT 29
14424: PUSH
14425: LD_INT 30
14427: PUSH
14428: LD_INT 31
14430: PUSH
14431: LD_INT 37
14433: PUSH
14434: LD_INT 38
14436: PUSH
14437: LD_INT 32
14439: PUSH
14440: LD_INT 27
14442: PUSH
14443: LD_INT 33
14445: PUSH
14446: LD_INT 69
14448: PUSH
14449: LD_INT 39
14451: PUSH
14452: LD_INT 34
14454: PUSH
14455: LD_INT 40
14457: PUSH
14458: LD_INT 71
14460: PUSH
14461: LD_INT 23
14463: PUSH
14464: LD_INT 44
14466: PUSH
14467: LD_INT 48
14469: PUSH
14470: LD_INT 49
14472: PUSH
14473: LD_INT 50
14475: PUSH
14476: LD_INT 51
14478: PUSH
14479: LD_INT 52
14481: PUSH
14482: LD_INT 53
14484: PUSH
14485: LD_INT 54
14487: PUSH
14488: LD_INT 55
14490: PUSH
14491: LD_INT 56
14493: PUSH
14494: LD_INT 57
14496: PUSH
14497: LD_INT 58
14499: PUSH
14500: LD_INT 59
14502: PUSH
14503: LD_INT 63
14505: PUSH
14506: LD_INT 64
14508: PUSH
14509: LD_INT 65
14511: PUSH
14512: EMPTY
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: LIST
14521: LIST
14522: LIST
14523: LIST
14524: LIST
14525: LIST
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: ST_TO_ADDR
14557: GO 14560
14559: POP
// if state > - 1 and state < 3 then
14560: LD_VAR 0 3
14564: PUSH
14565: LD_INT 1
14567: NEG
14568: GREATER
14569: PUSH
14570: LD_VAR 0 3
14574: PUSH
14575: LD_INT 3
14577: LESS
14578: AND
14579: IFFALSE 14636
// for i in result do
14581: LD_ADDR_VAR 0 5
14585: PUSH
14586: LD_VAR 0 4
14590: PUSH
14591: FOR_IN
14592: IFFALSE 14634
// if GetTech ( i , side ) <> state then
14594: LD_VAR 0 5
14598: PPUSH
14599: LD_VAR 0 1
14603: PPUSH
14604: CALL_OW 321
14608: PUSH
14609: LD_VAR 0 3
14613: NONEQUAL
14614: IFFALSE 14632
// result := result diff i ;
14616: LD_ADDR_VAR 0 4
14620: PUSH
14621: LD_VAR 0 4
14625: PUSH
14626: LD_VAR 0 5
14630: DIFF
14631: ST_TO_ADDR
14632: GO 14591
14634: POP
14635: POP
// end ;
14636: LD_VAR 0 4
14640: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14641: LD_INT 0
14643: PPUSH
14644: PPUSH
14645: PPUSH
// result := true ;
14646: LD_ADDR_VAR 0 3
14650: PUSH
14651: LD_INT 1
14653: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14654: LD_ADDR_VAR 0 5
14658: PUSH
14659: LD_VAR 0 2
14663: PPUSH
14664: CALL_OW 480
14668: ST_TO_ADDR
// if not tmp then
14669: LD_VAR 0 5
14673: NOT
14674: IFFALSE 14678
// exit ;
14676: GO 14727
// for i in tmp do
14678: LD_ADDR_VAR 0 4
14682: PUSH
14683: LD_VAR 0 5
14687: PUSH
14688: FOR_IN
14689: IFFALSE 14725
// if GetTech ( i , side ) <> state_researched then
14691: LD_VAR 0 4
14695: PPUSH
14696: LD_VAR 0 1
14700: PPUSH
14701: CALL_OW 321
14705: PUSH
14706: LD_INT 2
14708: NONEQUAL
14709: IFFALSE 14723
// begin result := false ;
14711: LD_ADDR_VAR 0 3
14715: PUSH
14716: LD_INT 0
14718: ST_TO_ADDR
// exit ;
14719: POP
14720: POP
14721: GO 14727
// end ;
14723: GO 14688
14725: POP
14726: POP
// end ;
14727: LD_VAR 0 3
14731: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14732: LD_INT 0
14734: PPUSH
14735: PPUSH
14736: PPUSH
14737: PPUSH
14738: PPUSH
14739: PPUSH
14740: PPUSH
14741: PPUSH
14742: PPUSH
14743: PPUSH
14744: PPUSH
14745: PPUSH
14746: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14747: LD_VAR 0 1
14751: NOT
14752: PUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 257
14762: PUSH
14763: LD_INT 9
14765: NONEQUAL
14766: OR
14767: IFFALSE 14771
// exit ;
14769: GO 15344
// side := GetSide ( unit ) ;
14771: LD_ADDR_VAR 0 9
14775: PUSH
14776: LD_VAR 0 1
14780: PPUSH
14781: CALL_OW 255
14785: ST_TO_ADDR
// tech_space := tech_spacanom ;
14786: LD_ADDR_VAR 0 12
14790: PUSH
14791: LD_INT 29
14793: ST_TO_ADDR
// tech_time := tech_taurad ;
14794: LD_ADDR_VAR 0 13
14798: PUSH
14799: LD_INT 28
14801: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14802: LD_ADDR_VAR 0 11
14806: PUSH
14807: LD_VAR 0 1
14811: PPUSH
14812: CALL_OW 310
14816: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14817: LD_VAR 0 11
14821: PPUSH
14822: CALL_OW 247
14826: PUSH
14827: LD_INT 2
14829: EQUAL
14830: IFFALSE 14834
// exit ;
14832: GO 15344
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14834: LD_ADDR_VAR 0 8
14838: PUSH
14839: LD_INT 81
14841: PUSH
14842: LD_VAR 0 9
14846: PUSH
14847: EMPTY
14848: LIST
14849: LIST
14850: PUSH
14851: LD_INT 3
14853: PUSH
14854: LD_INT 21
14856: PUSH
14857: LD_INT 3
14859: PUSH
14860: EMPTY
14861: LIST
14862: LIST
14863: PUSH
14864: EMPTY
14865: LIST
14866: LIST
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: PPUSH
14872: CALL_OW 69
14876: ST_TO_ADDR
// if not tmp then
14877: LD_VAR 0 8
14881: NOT
14882: IFFALSE 14886
// exit ;
14884: GO 15344
// if in_unit then
14886: LD_VAR 0 11
14890: IFFALSE 14914
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14892: LD_ADDR_VAR 0 10
14896: PUSH
14897: LD_VAR 0 8
14901: PPUSH
14902: LD_VAR 0 11
14906: PPUSH
14907: CALL_OW 74
14911: ST_TO_ADDR
14912: GO 14934
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14914: LD_ADDR_VAR 0 10
14918: PUSH
14919: LD_VAR 0 8
14923: PPUSH
14924: LD_VAR 0 1
14928: PPUSH
14929: CALL_OW 74
14933: ST_TO_ADDR
// if not enemy then
14934: LD_VAR 0 10
14938: NOT
14939: IFFALSE 14943
// exit ;
14941: GO 15344
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
14943: LD_VAR 0 11
14947: PUSH
14948: LD_VAR 0 11
14952: PPUSH
14953: LD_VAR 0 10
14957: PPUSH
14958: CALL_OW 296
14962: PUSH
14963: LD_INT 13
14965: GREATER
14966: AND
14967: PUSH
14968: LD_VAR 0 1
14972: PPUSH
14973: LD_VAR 0 10
14977: PPUSH
14978: CALL_OW 296
14982: PUSH
14983: LD_INT 12
14985: GREATER
14986: OR
14987: IFFALSE 14991
// exit ;
14989: GO 15344
// missile := [ 1 ] ;
14991: LD_ADDR_VAR 0 14
14995: PUSH
14996: LD_INT 1
14998: PUSH
14999: EMPTY
15000: LIST
15001: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15002: LD_VAR 0 9
15006: PPUSH
15007: LD_VAR 0 12
15011: PPUSH
15012: CALL_OW 325
15016: IFFALSE 15045
// missile := Insert ( missile , missile + 1 , 2 ) ;
15018: LD_ADDR_VAR 0 14
15022: PUSH
15023: LD_VAR 0 14
15027: PPUSH
15028: LD_VAR 0 14
15032: PUSH
15033: LD_INT 1
15035: PLUS
15036: PPUSH
15037: LD_INT 2
15039: PPUSH
15040: CALL_OW 2
15044: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15045: LD_VAR 0 9
15049: PPUSH
15050: LD_VAR 0 13
15054: PPUSH
15055: CALL_OW 325
15059: PUSH
15060: LD_VAR 0 10
15064: PPUSH
15065: CALL_OW 255
15069: PPUSH
15070: LD_VAR 0 13
15074: PPUSH
15075: CALL_OW 325
15079: NOT
15080: AND
15081: IFFALSE 15110
// missile := Insert ( missile , missile + 1 , 3 ) ;
15083: LD_ADDR_VAR 0 14
15087: PUSH
15088: LD_VAR 0 14
15092: PPUSH
15093: LD_VAR 0 14
15097: PUSH
15098: LD_INT 1
15100: PLUS
15101: PPUSH
15102: LD_INT 3
15104: PPUSH
15105: CALL_OW 2
15109: ST_TO_ADDR
// if missile < 2 then
15110: LD_VAR 0 14
15114: PUSH
15115: LD_INT 2
15117: LESS
15118: IFFALSE 15122
// exit ;
15120: GO 15344
// x := GetX ( enemy ) ;
15122: LD_ADDR_VAR 0 4
15126: PUSH
15127: LD_VAR 0 10
15131: PPUSH
15132: CALL_OW 250
15136: ST_TO_ADDR
// y := GetY ( enemy ) ;
15137: LD_ADDR_VAR 0 5
15141: PUSH
15142: LD_VAR 0 10
15146: PPUSH
15147: CALL_OW 251
15151: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15152: LD_ADDR_VAR 0 6
15156: PUSH
15157: LD_VAR 0 4
15161: PUSH
15162: LD_INT 1
15164: NEG
15165: PPUSH
15166: LD_INT 1
15168: PPUSH
15169: CALL_OW 12
15173: PLUS
15174: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15175: LD_ADDR_VAR 0 7
15179: PUSH
15180: LD_VAR 0 5
15184: PUSH
15185: LD_INT 1
15187: NEG
15188: PPUSH
15189: LD_INT 1
15191: PPUSH
15192: CALL_OW 12
15196: PLUS
15197: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15198: LD_VAR 0 6
15202: PPUSH
15203: LD_VAR 0 7
15207: PPUSH
15208: CALL_OW 488
15212: NOT
15213: IFFALSE 15235
// begin _x := x ;
15215: LD_ADDR_VAR 0 6
15219: PUSH
15220: LD_VAR 0 4
15224: ST_TO_ADDR
// _y := y ;
15225: LD_ADDR_VAR 0 7
15229: PUSH
15230: LD_VAR 0 5
15234: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15235: LD_ADDR_VAR 0 3
15239: PUSH
15240: LD_INT 1
15242: PPUSH
15243: LD_VAR 0 14
15247: PPUSH
15248: CALL_OW 12
15252: ST_TO_ADDR
// case i of 1 :
15253: LD_VAR 0 3
15257: PUSH
15258: LD_INT 1
15260: DOUBLE
15261: EQUAL
15262: IFTRUE 15266
15264: GO 15283
15266: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15267: LD_VAR 0 1
15271: PPUSH
15272: LD_VAR 0 10
15276: PPUSH
15277: CALL_OW 115
15281: GO 15344
15283: LD_INT 2
15285: DOUBLE
15286: EQUAL
15287: IFTRUE 15291
15289: GO 15313
15291: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15292: LD_VAR 0 1
15296: PPUSH
15297: LD_VAR 0 6
15301: PPUSH
15302: LD_VAR 0 7
15306: PPUSH
15307: CALL_OW 153
15311: GO 15344
15313: LD_INT 3
15315: DOUBLE
15316: EQUAL
15317: IFTRUE 15321
15319: GO 15343
15321: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15322: LD_VAR 0 1
15326: PPUSH
15327: LD_VAR 0 6
15331: PPUSH
15332: LD_VAR 0 7
15336: PPUSH
15337: CALL_OW 154
15341: GO 15344
15343: POP
// end ;
15344: LD_VAR 0 2
15348: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15349: LD_INT 0
15351: PPUSH
15352: PPUSH
15353: PPUSH
15354: PPUSH
15355: PPUSH
15356: PPUSH
// if not unit or not building then
15357: LD_VAR 0 1
15361: NOT
15362: PUSH
15363: LD_VAR 0 2
15367: NOT
15368: OR
15369: IFFALSE 15373
// exit ;
15371: GO 15531
// x := GetX ( building ) ;
15373: LD_ADDR_VAR 0 5
15377: PUSH
15378: LD_VAR 0 2
15382: PPUSH
15383: CALL_OW 250
15387: ST_TO_ADDR
// y := GetY ( building ) ;
15388: LD_ADDR_VAR 0 6
15392: PUSH
15393: LD_VAR 0 2
15397: PPUSH
15398: CALL_OW 251
15402: ST_TO_ADDR
// for i = 0 to 5 do
15403: LD_ADDR_VAR 0 4
15407: PUSH
15408: DOUBLE
15409: LD_INT 0
15411: DEC
15412: ST_TO_ADDR
15413: LD_INT 5
15415: PUSH
15416: FOR_TO
15417: IFFALSE 15529
// begin _x := ShiftX ( x , i , 3 ) ;
15419: LD_ADDR_VAR 0 7
15423: PUSH
15424: LD_VAR 0 5
15428: PPUSH
15429: LD_VAR 0 4
15433: PPUSH
15434: LD_INT 3
15436: PPUSH
15437: CALL_OW 272
15441: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15442: LD_ADDR_VAR 0 8
15446: PUSH
15447: LD_VAR 0 6
15451: PPUSH
15452: LD_VAR 0 4
15456: PPUSH
15457: LD_INT 3
15459: PPUSH
15460: CALL_OW 273
15464: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15465: LD_VAR 0 7
15469: PPUSH
15470: LD_VAR 0 8
15474: PPUSH
15475: CALL_OW 488
15479: NOT
15480: IFFALSE 15484
// continue ;
15482: GO 15416
// if HexInfo ( _x , _y ) = 0 then
15484: LD_VAR 0 7
15488: PPUSH
15489: LD_VAR 0 8
15493: PPUSH
15494: CALL_OW 428
15498: PUSH
15499: LD_INT 0
15501: EQUAL
15502: IFFALSE 15527
// begin ComMoveXY ( unit , _x , _y ) ;
15504: LD_VAR 0 1
15508: PPUSH
15509: LD_VAR 0 7
15513: PPUSH
15514: LD_VAR 0 8
15518: PPUSH
15519: CALL_OW 111
// exit ;
15523: POP
15524: POP
15525: GO 15531
// end ; end ;
15527: GO 15416
15529: POP
15530: POP
// end ;
15531: LD_VAR 0 3
15535: RET
// export function ScanBase ( side , base_area ) ; begin
15536: LD_INT 0
15538: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15539: LD_ADDR_VAR 0 3
15543: PUSH
15544: LD_VAR 0 2
15548: PPUSH
15549: LD_INT 81
15551: PUSH
15552: LD_VAR 0 1
15556: PUSH
15557: EMPTY
15558: LIST
15559: LIST
15560: PPUSH
15561: CALL_OW 70
15565: ST_TO_ADDR
// end ;
15566: LD_VAR 0 3
15570: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15571: LD_INT 0
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
15577: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15578: LD_VAR 0 1
15582: NOT
15583: PUSH
15584: LD_EXP 58
15588: PUSH
15589: LD_VAR 0 1
15593: ARRAY
15594: NOT
15595: OR
15596: PUSH
15597: LD_VAR 0 2
15601: NOT
15602: OR
15603: PUSH
15604: LD_VAR 0 3
15608: NOT
15609: OR
15610: IFFALSE 15614
// exit ;
15612: GO 16064
// side := mc_sides [ base ] ;
15614: LD_ADDR_VAR 0 6
15618: PUSH
15619: LD_EXP 84
15623: PUSH
15624: LD_VAR 0 1
15628: ARRAY
15629: ST_TO_ADDR
// if not side then
15630: LD_VAR 0 6
15634: NOT
15635: IFFALSE 15639
// exit ;
15637: GO 16064
// for i in solds do
15639: LD_ADDR_VAR 0 7
15643: PUSH
15644: LD_VAR 0 2
15648: PUSH
15649: FOR_IN
15650: IFFALSE 15711
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15652: LD_VAR 0 7
15656: PPUSH
15657: CALL_OW 310
15661: PPUSH
15662: CALL_OW 266
15666: PUSH
15667: LD_INT 32
15669: PUSH
15670: LD_INT 31
15672: PUSH
15673: EMPTY
15674: LIST
15675: LIST
15676: IN
15677: IFFALSE 15697
// solds := solds diff i else
15679: LD_ADDR_VAR 0 2
15683: PUSH
15684: LD_VAR 0 2
15688: PUSH
15689: LD_VAR 0 7
15693: DIFF
15694: ST_TO_ADDR
15695: GO 15709
// SetTag ( i , 18 ) ;
15697: LD_VAR 0 7
15701: PPUSH
15702: LD_INT 18
15704: PPUSH
15705: CALL_OW 109
15709: GO 15649
15711: POP
15712: POP
// if not solds then
15713: LD_VAR 0 2
15717: NOT
15718: IFFALSE 15722
// exit ;
15720: GO 16064
// repeat wait ( 0 0$1 ) ;
15722: LD_INT 35
15724: PPUSH
15725: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15729: LD_ADDR_VAR 0 5
15733: PUSH
15734: LD_VAR 0 6
15738: PPUSH
15739: LD_VAR 0 3
15743: PPUSH
15744: CALL 15536 0 2
15748: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15749: LD_VAR 0 5
15753: NOT
15754: PUSH
15755: LD_VAR 0 5
15759: PUSH
15760: LD_INT 3
15762: GREATER
15763: OR
15764: PUSH
15765: LD_EXP 80
15769: PUSH
15770: LD_VAR 0 1
15774: ARRAY
15775: OR
15776: IFFALSE 15817
// begin for i in solds do
15778: LD_ADDR_VAR 0 7
15782: PUSH
15783: LD_VAR 0 2
15787: PUSH
15788: FOR_IN
15789: IFFALSE 15813
// if HasTask ( i ) then
15791: LD_VAR 0 7
15795: PPUSH
15796: CALL_OW 314
15800: IFFALSE 15811
// ComStop ( i ) ;
15802: LD_VAR 0 7
15806: PPUSH
15807: CALL_OW 141
15811: GO 15788
15813: POP
15814: POP
// break ;
15815: GO 16052
// end ; for i in solds do
15817: LD_ADDR_VAR 0 7
15821: PUSH
15822: LD_VAR 0 2
15826: PUSH
15827: FOR_IN
15828: IFFALSE 16044
// begin if IsInUnit ( i ) then
15830: LD_VAR 0 7
15834: PPUSH
15835: CALL_OW 310
15839: IFFALSE 15850
// ComExitBuilding ( i ) ;
15841: LD_VAR 0 7
15845: PPUSH
15846: CALL_OW 122
// if GetLives ( i ) > 333 then
15850: LD_VAR 0 7
15854: PPUSH
15855: CALL_OW 256
15859: PUSH
15860: LD_INT 333
15862: GREATER
15863: IFFALSE 15891
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15865: LD_VAR 0 7
15869: PPUSH
15870: LD_VAR 0 5
15874: PPUSH
15875: LD_VAR 0 7
15879: PPUSH
15880: CALL_OW 74
15884: PPUSH
15885: CALL_OW 115
15889: GO 16042
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15891: LD_ADDR_VAR 0 8
15895: PUSH
15896: LD_EXP 58
15900: PUSH
15901: LD_VAR 0 1
15905: ARRAY
15906: PPUSH
15907: LD_INT 2
15909: PUSH
15910: LD_INT 30
15912: PUSH
15913: LD_INT 0
15915: PUSH
15916: EMPTY
15917: LIST
15918: LIST
15919: PUSH
15920: LD_INT 30
15922: PUSH
15923: LD_INT 1
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: LD_INT 30
15932: PUSH
15933: LD_INT 6
15935: PUSH
15936: EMPTY
15937: LIST
15938: LIST
15939: PUSH
15940: EMPTY
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: PPUSH
15946: CALL_OW 72
15950: PPUSH
15951: LD_VAR 0 7
15955: PPUSH
15956: CALL_OW 74
15960: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
15961: LD_VAR 0 7
15965: PPUSH
15966: LD_VAR 0 8
15970: PPUSH
15971: CALL_OW 250
15975: PPUSH
15976: LD_INT 3
15978: PPUSH
15979: LD_INT 5
15981: PPUSH
15982: CALL_OW 272
15986: PPUSH
15987: LD_VAR 0 8
15991: PPUSH
15992: CALL_OW 251
15996: PPUSH
15997: LD_INT 3
15999: PPUSH
16000: LD_INT 5
16002: PPUSH
16003: CALL_OW 273
16007: PPUSH
16008: CALL_OW 111
// SetTag ( i , 0 ) ;
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_INT 0
16019: PPUSH
16020: CALL_OW 109
// solds := solds diff i ;
16024: LD_ADDR_VAR 0 2
16028: PUSH
16029: LD_VAR 0 2
16033: PUSH
16034: LD_VAR 0 7
16038: DIFF
16039: ST_TO_ADDR
// continue ;
16040: GO 15827
// end ; end ;
16042: GO 15827
16044: POP
16045: POP
// until solds ;
16046: LD_VAR 0 2
16050: IFFALSE 15722
// MC_Reset ( base , 18 ) ;
16052: LD_VAR 0 1
16056: PPUSH
16057: LD_INT 18
16059: PPUSH
16060: CALL 60566 0 2
// end ;
16064: LD_VAR 0 4
16068: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16069: LD_INT 0
16071: PPUSH
16072: PPUSH
16073: PPUSH
16074: PPUSH
16075: PPUSH
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
16080: PPUSH
16081: PPUSH
16082: PPUSH
16083: PPUSH
16084: PPUSH
16085: PPUSH
16086: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16087: LD_ADDR_VAR 0 12
16091: PUSH
16092: LD_EXP 58
16096: PUSH
16097: LD_VAR 0 1
16101: ARRAY
16102: PPUSH
16103: LD_INT 25
16105: PUSH
16106: LD_INT 3
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PPUSH
16113: CALL_OW 72
16117: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16118: LD_ADDR_VAR 0 8
16122: PUSH
16123: LD_EXP 58
16127: PUSH
16128: LD_VAR 0 1
16132: ARRAY
16133: PPUSH
16134: LD_INT 2
16136: PUSH
16137: LD_INT 25
16139: PUSH
16140: LD_INT 1
16142: PUSH
16143: EMPTY
16144: LIST
16145: LIST
16146: PUSH
16147: LD_INT 25
16149: PUSH
16150: LD_INT 5
16152: PUSH
16153: EMPTY
16154: LIST
16155: LIST
16156: PUSH
16157: LD_INT 25
16159: PUSH
16160: LD_INT 8
16162: PUSH
16163: EMPTY
16164: LIST
16165: LIST
16166: PUSH
16167: LD_INT 25
16169: PUSH
16170: LD_INT 9
16172: PUSH
16173: EMPTY
16174: LIST
16175: LIST
16176: PUSH
16177: EMPTY
16178: LIST
16179: LIST
16180: LIST
16181: LIST
16182: LIST
16183: PPUSH
16184: CALL_OW 72
16188: ST_TO_ADDR
// if not defenders and not solds then
16189: LD_VAR 0 2
16193: NOT
16194: PUSH
16195: LD_VAR 0 8
16199: NOT
16200: AND
16201: IFFALSE 16205
// exit ;
16203: GO 17571
// depot_under_attack := false ;
16205: LD_ADDR_VAR 0 16
16209: PUSH
16210: LD_INT 0
16212: ST_TO_ADDR
// sold_defenders := [ ] ;
16213: LD_ADDR_VAR 0 17
16217: PUSH
16218: EMPTY
16219: ST_TO_ADDR
// if mechs then
16220: LD_VAR 0 12
16224: IFFALSE 16353
// for i in defenders do
16226: LD_ADDR_VAR 0 5
16230: PUSH
16231: LD_VAR 0 2
16235: PUSH
16236: FOR_IN
16237: IFFALSE 16351
// begin SetTag ( i , 20 ) ;
16239: LD_VAR 0 5
16243: PPUSH
16244: LD_INT 20
16246: PPUSH
16247: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16251: LD_VAR 0 5
16255: PPUSH
16256: CALL_OW 263
16260: PUSH
16261: LD_INT 1
16263: EQUAL
16264: PUSH
16265: LD_VAR 0 5
16269: PPUSH
16270: CALL_OW 311
16274: NOT
16275: AND
16276: PUSH
16277: LD_VAR 0 12
16281: AND
16282: IFFALSE 16349
// begin un := mechs [ 1 ] ;
16284: LD_ADDR_VAR 0 10
16288: PUSH
16289: LD_VAR 0 12
16293: PUSH
16294: LD_INT 1
16296: ARRAY
16297: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16298: LD_VAR 0 10
16302: PPUSH
16303: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16307: LD_VAR 0 10
16311: PPUSH
16312: LD_VAR 0 5
16316: PPUSH
16317: CALL_OW 180
// SetTag ( un , 19 ) ;
16321: LD_VAR 0 10
16325: PPUSH
16326: LD_INT 19
16328: PPUSH
16329: CALL_OW 109
// mechs := mechs diff un ;
16333: LD_ADDR_VAR 0 12
16337: PUSH
16338: LD_VAR 0 12
16342: PUSH
16343: LD_VAR 0 10
16347: DIFF
16348: ST_TO_ADDR
// end ; end ;
16349: GO 16236
16351: POP
16352: POP
// if solds then
16353: LD_VAR 0 8
16357: IFFALSE 16416
// for i in solds do
16359: LD_ADDR_VAR 0 5
16363: PUSH
16364: LD_VAR 0 8
16368: PUSH
16369: FOR_IN
16370: IFFALSE 16414
// if not GetTag ( i ) then
16372: LD_VAR 0 5
16376: PPUSH
16377: CALL_OW 110
16381: NOT
16382: IFFALSE 16412
// begin defenders := defenders union i ;
16384: LD_ADDR_VAR 0 2
16388: PUSH
16389: LD_VAR 0 2
16393: PUSH
16394: LD_VAR 0 5
16398: UNION
16399: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16400: LD_VAR 0 5
16404: PPUSH
16405: LD_INT 18
16407: PPUSH
16408: CALL_OW 109
// end ;
16412: GO 16369
16414: POP
16415: POP
// repeat wait ( 0 0$1 ) ;
16416: LD_INT 35
16418: PPUSH
16419: CALL_OW 67
// enemy := mc_scan [ base ] ;
16423: LD_ADDR_VAR 0 3
16427: PUSH
16428: LD_EXP 81
16432: PUSH
16433: LD_VAR 0 1
16437: ARRAY
16438: ST_TO_ADDR
// for i in defenders do
16439: LD_ADDR_VAR 0 5
16443: PUSH
16444: LD_VAR 0 2
16448: PUSH
16449: FOR_IN
16450: IFFALSE 17135
// begin e := NearestUnitToUnit ( enemy , i ) ;
16452: LD_ADDR_VAR 0 13
16456: PUSH
16457: LD_VAR 0 3
16461: PPUSH
16462: LD_VAR 0 5
16466: PPUSH
16467: CALL_OW 74
16471: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16472: LD_ADDR_VAR 0 16
16476: PUSH
16477: LD_EXP 58
16481: PUSH
16482: LD_VAR 0 1
16486: ARRAY
16487: PPUSH
16488: LD_INT 2
16490: PUSH
16491: LD_INT 30
16493: PUSH
16494: LD_INT 0
16496: PUSH
16497: EMPTY
16498: LIST
16499: LIST
16500: PUSH
16501: LD_INT 30
16503: PUSH
16504: LD_INT 1
16506: PUSH
16507: EMPTY
16508: LIST
16509: LIST
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: LIST
16515: PPUSH
16516: CALL_OW 72
16520: NOT
16521: PUSH
16522: LD_EXP 58
16526: PUSH
16527: LD_VAR 0 1
16531: ARRAY
16532: PPUSH
16533: LD_INT 2
16535: PUSH
16536: LD_INT 30
16538: PUSH
16539: LD_INT 0
16541: PUSH
16542: EMPTY
16543: LIST
16544: LIST
16545: PUSH
16546: LD_INT 30
16548: PUSH
16549: LD_INT 1
16551: PUSH
16552: EMPTY
16553: LIST
16554: LIST
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: LIST
16560: PPUSH
16561: CALL_OW 72
16565: PPUSH
16566: CALL_OW 256
16570: PUSH
16571: LD_INT 600
16573: LESS
16574: OR
16575: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16576: LD_VAR 0 5
16580: PPUSH
16581: CALL_OW 247
16585: PUSH
16586: LD_INT 2
16588: DOUBLE
16589: EQUAL
16590: IFTRUE 16594
16592: GO 16841
16594: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
16595: LD_VAR 0 5
16599: PPUSH
16600: CALL_OW 256
16604: PUSH
16605: LD_INT 650
16607: GREATER
16608: PUSH
16609: LD_VAR 0 5
16613: PPUSH
16614: LD_VAR 0 13
16618: PPUSH
16619: CALL_OW 296
16623: PUSH
16624: LD_INT 40
16626: LESS
16627: AND
16628: IFFALSE 16646
// ComAttackUnit ( i , e ) else
16630: LD_VAR 0 5
16634: PPUSH
16635: LD_VAR 0 13
16639: PPUSH
16640: CALL_OW 115
16644: GO 16724
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16646: LD_VAR 0 5
16650: PPUSH
16651: LD_VAR 0 13
16655: PPUSH
16656: CALL_OW 296
16660: PUSH
16661: LD_INT 30
16663: GREATEREQUAL
16664: PUSH
16665: LD_VAR 0 5
16669: PPUSH
16670: CALL_OW 256
16674: PUSH
16675: LD_INT 650
16677: LESSEQUAL
16678: OR
16679: PUSH
16680: LD_VAR 0 5
16684: PPUSH
16685: LD_EXP 82
16689: PUSH
16690: LD_VAR 0 1
16694: ARRAY
16695: PPUSH
16696: CALL_OW 308
16700: NOT
16701: AND
16702: IFFALSE 16724
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16704: LD_VAR 0 5
16708: PPUSH
16709: LD_EXP 82
16713: PUSH
16714: LD_VAR 0 1
16718: ARRAY
16719: PPUSH
16720: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16724: LD_VAR 0 5
16728: PPUSH
16729: CALL_OW 256
16733: PUSH
16734: LD_INT 998
16736: LESS
16737: PUSH
16738: LD_VAR 0 5
16742: PPUSH
16743: CALL_OW 263
16747: PUSH
16748: LD_INT 1
16750: EQUAL
16751: AND
16752: PUSH
16753: LD_VAR 0 5
16757: PPUSH
16758: CALL_OW 311
16762: AND
16763: PUSH
16764: LD_VAR 0 5
16768: PPUSH
16769: LD_EXP 82
16773: PUSH
16774: LD_VAR 0 1
16778: ARRAY
16779: PPUSH
16780: CALL_OW 308
16784: AND
16785: IFFALSE 16839
// begin mech := IsDrivenBy ( i ) ;
16787: LD_ADDR_VAR 0 9
16791: PUSH
16792: LD_VAR 0 5
16796: PPUSH
16797: CALL_OW 311
16801: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16802: LD_VAR 0 9
16806: PPUSH
16807: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16811: LD_VAR 0 9
16815: PPUSH
16816: LD_VAR 0 5
16820: PPUSH
16821: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16825: LD_VAR 0 9
16829: PPUSH
16830: LD_VAR 0 5
16834: PPUSH
16835: CALL_OW 180
// end ; end ; unit_human :
16839: GO 17106
16841: LD_INT 1
16843: DOUBLE
16844: EQUAL
16845: IFTRUE 16849
16847: GO 17105
16849: POP
// begin b := IsInUnit ( i ) ;
16850: LD_ADDR_VAR 0 18
16854: PUSH
16855: LD_VAR 0 5
16859: PPUSH
16860: CALL_OW 310
16864: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
16865: LD_ADDR_VAR 0 19
16869: PUSH
16870: LD_VAR 0 18
16874: NOT
16875: PUSH
16876: LD_VAR 0 18
16880: PPUSH
16881: CALL_OW 266
16885: PUSH
16886: LD_INT 32
16888: PUSH
16889: LD_INT 31
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: IN
16896: OR
16897: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
16898: LD_VAR 0 16
16902: PUSH
16903: LD_VAR 0 2
16907: PPUSH
16908: LD_INT 21
16910: PUSH
16911: LD_INT 2
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PPUSH
16918: CALL_OW 72
16922: PUSH
16923: LD_INT 1
16925: LESSEQUAL
16926: OR
16927: PUSH
16928: LD_VAR 0 19
16932: AND
16933: PUSH
16934: LD_VAR 0 5
16938: PUSH
16939: LD_VAR 0 17
16943: IN
16944: NOT
16945: AND
16946: IFFALSE 17039
// begin if b then
16948: LD_VAR 0 18
16952: IFFALSE 17001
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
16954: LD_VAR 0 18
16958: PPUSH
16959: LD_VAR 0 3
16963: PPUSH
16964: LD_VAR 0 18
16968: PPUSH
16969: CALL_OW 74
16973: PPUSH
16974: CALL_OW 296
16978: PUSH
16979: LD_INT 10
16981: LESS
16982: PUSH
16983: LD_VAR 0 18
16987: PPUSH
16988: CALL_OW 461
16992: PUSH
16993: LD_INT 7
16995: NONEQUAL
16996: AND
16997: IFFALSE 17001
// continue ;
16999: GO 16449
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17001: LD_ADDR_VAR 0 17
17005: PUSH
17006: LD_VAR 0 17
17010: PPUSH
17011: LD_VAR 0 17
17015: PUSH
17016: LD_INT 1
17018: PLUS
17019: PPUSH
17020: LD_VAR 0 5
17024: PPUSH
17025: CALL_OW 1
17029: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17030: LD_VAR 0 5
17034: PPUSH
17035: CALL_OW 122
// end ; if sold_defenders then
17039: LD_VAR 0 17
17043: IFFALSE 17103
// if i in sold_defenders then
17045: LD_VAR 0 5
17049: PUSH
17050: LD_VAR 0 17
17054: IN
17055: IFFALSE 17103
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17057: LD_VAR 0 5
17061: PPUSH
17062: CALL_OW 314
17066: NOT
17067: PUSH
17068: LD_VAR 0 5
17072: PPUSH
17073: LD_VAR 0 13
17077: PPUSH
17078: CALL_OW 296
17082: PUSH
17083: LD_INT 30
17085: LESS
17086: AND
17087: IFFALSE 17103
// ComAttackUnit ( i , e ) ;
17089: LD_VAR 0 5
17093: PPUSH
17094: LD_VAR 0 13
17098: PPUSH
17099: CALL_OW 115
// end ; end ; end ;
17103: GO 17106
17105: POP
// if IsDead ( i ) then
17106: LD_VAR 0 5
17110: PPUSH
17111: CALL_OW 301
17115: IFFALSE 17133
// defenders := defenders diff i ;
17117: LD_ADDR_VAR 0 2
17121: PUSH
17122: LD_VAR 0 2
17126: PUSH
17127: LD_VAR 0 5
17131: DIFF
17132: ST_TO_ADDR
// end ;
17133: GO 16449
17135: POP
17136: POP
// until not enemy or not defenders ;
17137: LD_VAR 0 3
17141: NOT
17142: PUSH
17143: LD_VAR 0 2
17147: NOT
17148: OR
17149: IFFALSE 16416
// MC_Reset ( base , 18 ) ;
17151: LD_VAR 0 1
17155: PPUSH
17156: LD_INT 18
17158: PPUSH
17159: CALL 60566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17163: LD_ADDR_VAR 0 2
17167: PUSH
17168: LD_VAR 0 2
17172: PUSH
17173: LD_VAR 0 2
17177: PPUSH
17178: LD_INT 2
17180: PUSH
17181: LD_INT 25
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 25
17193: PUSH
17194: LD_INT 5
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 25
17203: PUSH
17204: LD_INT 8
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: LD_INT 25
17213: PUSH
17214: LD_INT 9
17216: PUSH
17217: EMPTY
17218: LIST
17219: LIST
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: LIST
17225: LIST
17226: LIST
17227: PPUSH
17228: CALL_OW 72
17232: DIFF
17233: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17234: LD_VAR 0 3
17238: NOT
17239: PUSH
17240: LD_VAR 0 2
17244: PPUSH
17245: LD_INT 21
17247: PUSH
17248: LD_INT 2
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PPUSH
17255: CALL_OW 72
17259: AND
17260: IFFALSE 17522
// begin tmp := FilterByTag ( defenders , 19 ) ;
17262: LD_ADDR_VAR 0 11
17266: PUSH
17267: LD_VAR 0 2
17271: PPUSH
17272: LD_INT 19
17274: PPUSH
17275: CALL 53908 0 2
17279: ST_TO_ADDR
// if tmp then
17280: LD_VAR 0 11
17284: IFFALSE 17354
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17286: LD_ADDR_VAR 0 11
17290: PUSH
17291: LD_VAR 0 11
17295: PPUSH
17296: LD_INT 25
17298: PUSH
17299: LD_INT 3
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PPUSH
17306: CALL_OW 72
17310: ST_TO_ADDR
// if tmp then
17311: LD_VAR 0 11
17315: IFFALSE 17354
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17317: LD_ADDR_EXP 70
17321: PUSH
17322: LD_EXP 70
17326: PPUSH
17327: LD_VAR 0 1
17331: PPUSH
17332: LD_EXP 70
17336: PUSH
17337: LD_VAR 0 1
17341: ARRAY
17342: PUSH
17343: LD_VAR 0 11
17347: UNION
17348: PPUSH
17349: CALL_OW 1
17353: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17354: LD_VAR 0 1
17358: PPUSH
17359: LD_INT 19
17361: PPUSH
17362: CALL 60566 0 2
// repeat wait ( 0 0$1 ) ;
17366: LD_INT 35
17368: PPUSH
17369: CALL_OW 67
// for i in defenders do
17373: LD_ADDR_VAR 0 5
17377: PUSH
17378: LD_VAR 0 2
17382: PUSH
17383: FOR_IN
17384: IFFALSE 17473
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17386: LD_VAR 0 5
17390: PPUSH
17391: LD_EXP 82
17395: PUSH
17396: LD_VAR 0 1
17400: ARRAY
17401: PPUSH
17402: CALL_OW 308
17406: NOT
17407: IFFALSE 17431
// ComMoveToArea ( i , mc_parking [ base ] ) else
17409: LD_VAR 0 5
17413: PPUSH
17414: LD_EXP 82
17418: PUSH
17419: LD_VAR 0 1
17423: ARRAY
17424: PPUSH
17425: CALL_OW 113
17429: GO 17471
// if GetControl ( i ) = control_manual then
17431: LD_VAR 0 5
17435: PPUSH
17436: CALL_OW 263
17440: PUSH
17441: LD_INT 1
17443: EQUAL
17444: IFFALSE 17471
// if IsDrivenBy ( i ) then
17446: LD_VAR 0 5
17450: PPUSH
17451: CALL_OW 311
17455: IFFALSE 17471
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17457: LD_VAR 0 5
17461: PPUSH
17462: CALL_OW 311
17466: PPUSH
17467: CALL_OW 121
// end ;
17471: GO 17383
17473: POP
17474: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17475: LD_VAR 0 2
17479: PPUSH
17480: LD_INT 95
17482: PUSH
17483: LD_EXP 82
17487: PUSH
17488: LD_VAR 0 1
17492: ARRAY
17493: PUSH
17494: EMPTY
17495: LIST
17496: LIST
17497: PPUSH
17498: CALL_OW 72
17502: PUSH
17503: LD_VAR 0 2
17507: EQUAL
17508: PUSH
17509: LD_EXP 81
17513: PUSH
17514: LD_VAR 0 1
17518: ARRAY
17519: OR
17520: IFFALSE 17366
// end ; mc_defender := Replace ( mc_defender , base , mc_defender [ base ] union defenders ) ;
17522: LD_ADDR_EXP 80
17526: PUSH
17527: LD_EXP 80
17531: PPUSH
17532: LD_VAR 0 1
17536: PPUSH
17537: LD_EXP 80
17541: PUSH
17542: LD_VAR 0 1
17546: ARRAY
17547: PUSH
17548: LD_VAR 0 2
17552: UNION
17553: PPUSH
17554: CALL_OW 1
17558: ST_TO_ADDR
// MC_Reset ( base , 20 ) ;
17559: LD_VAR 0 1
17563: PPUSH
17564: LD_INT 20
17566: PPUSH
17567: CALL 60566 0 2
// end ;
17571: LD_VAR 0 4
17575: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17576: LD_INT 0
17578: PPUSH
17579: PPUSH
17580: PPUSH
17581: PPUSH
// result := false ;
17582: LD_ADDR_VAR 0 2
17586: PUSH
17587: LD_INT 0
17589: ST_TO_ADDR
// side := GetSide ( unit ) ;
17590: LD_ADDR_VAR 0 3
17594: PUSH
17595: LD_VAR 0 1
17599: PPUSH
17600: CALL_OW 255
17604: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17605: LD_ADDR_VAR 0 4
17609: PUSH
17610: LD_VAR 0 1
17614: PPUSH
17615: CALL_OW 248
17619: ST_TO_ADDR
// case nat of 1 :
17620: LD_VAR 0 4
17624: PUSH
17625: LD_INT 1
17627: DOUBLE
17628: EQUAL
17629: IFTRUE 17633
17631: GO 17644
17633: POP
// tech := tech_lassight ; 2 :
17634: LD_ADDR_VAR 0 5
17638: PUSH
17639: LD_INT 12
17641: ST_TO_ADDR
17642: GO 17683
17644: LD_INT 2
17646: DOUBLE
17647: EQUAL
17648: IFTRUE 17652
17650: GO 17663
17652: POP
// tech := tech_mortar ; 3 :
17653: LD_ADDR_VAR 0 5
17657: PUSH
17658: LD_INT 41
17660: ST_TO_ADDR
17661: GO 17683
17663: LD_INT 3
17665: DOUBLE
17666: EQUAL
17667: IFTRUE 17671
17669: GO 17682
17671: POP
// tech := tech_bazooka ; end ;
17672: LD_ADDR_VAR 0 5
17676: PUSH
17677: LD_INT 44
17679: ST_TO_ADDR
17680: GO 17683
17682: POP
// if Researched ( side , tech ) then
17683: LD_VAR 0 3
17687: PPUSH
17688: LD_VAR 0 5
17692: PPUSH
17693: CALL_OW 325
17697: IFFALSE 17724
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17699: LD_ADDR_VAR 0 2
17703: PUSH
17704: LD_INT 5
17706: PUSH
17707: LD_INT 8
17709: PUSH
17710: LD_INT 9
17712: PUSH
17713: EMPTY
17714: LIST
17715: LIST
17716: LIST
17717: PUSH
17718: LD_VAR 0 4
17722: ARRAY
17723: ST_TO_ADDR
// end ;
17724: LD_VAR 0 2
17728: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17729: LD_INT 0
17731: PPUSH
17732: PPUSH
17733: PPUSH
// if not mines then
17734: LD_VAR 0 2
17738: NOT
17739: IFFALSE 17743
// exit ;
17741: GO 17887
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17743: LD_ADDR_VAR 0 5
17747: PUSH
17748: LD_INT 81
17750: PUSH
17751: LD_VAR 0 1
17755: PUSH
17756: EMPTY
17757: LIST
17758: LIST
17759: PUSH
17760: LD_INT 3
17762: PUSH
17763: LD_INT 21
17765: PUSH
17766: LD_INT 3
17768: PUSH
17769: EMPTY
17770: LIST
17771: LIST
17772: PUSH
17773: EMPTY
17774: LIST
17775: LIST
17776: PUSH
17777: EMPTY
17778: LIST
17779: LIST
17780: PPUSH
17781: CALL_OW 69
17785: ST_TO_ADDR
// for i in mines do
17786: LD_ADDR_VAR 0 4
17790: PUSH
17791: LD_VAR 0 2
17795: PUSH
17796: FOR_IN
17797: IFFALSE 17885
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17799: LD_VAR 0 4
17803: PUSH
17804: LD_INT 1
17806: ARRAY
17807: PPUSH
17808: LD_VAR 0 4
17812: PUSH
17813: LD_INT 2
17815: ARRAY
17816: PPUSH
17817: CALL_OW 458
17821: NOT
17822: IFFALSE 17826
// continue ;
17824: GO 17796
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17826: LD_VAR 0 4
17830: PUSH
17831: LD_INT 1
17833: ARRAY
17834: PPUSH
17835: LD_VAR 0 4
17839: PUSH
17840: LD_INT 2
17842: ARRAY
17843: PPUSH
17844: CALL_OW 428
17848: PUSH
17849: LD_VAR 0 5
17853: IN
17854: IFFALSE 17883
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17856: LD_VAR 0 4
17860: PUSH
17861: LD_INT 1
17863: ARRAY
17864: PPUSH
17865: LD_VAR 0 4
17869: PUSH
17870: LD_INT 2
17872: ARRAY
17873: PPUSH
17874: LD_VAR 0 1
17878: PPUSH
17879: CALL_OW 456
// end ;
17883: GO 17796
17885: POP
17886: POP
// end ;
17887: LD_VAR 0 3
17891: RET
// export function Count ( array ) ; var i ; begin
17892: LD_INT 0
17894: PPUSH
17895: PPUSH
// result := 0 ;
17896: LD_ADDR_VAR 0 2
17900: PUSH
17901: LD_INT 0
17903: ST_TO_ADDR
// for i in array do
17904: LD_ADDR_VAR 0 3
17908: PUSH
17909: LD_VAR 0 1
17913: PUSH
17914: FOR_IN
17915: IFFALSE 17939
// if i then
17917: LD_VAR 0 3
17921: IFFALSE 17937
// result := result + 1 ;
17923: LD_ADDR_VAR 0 2
17927: PUSH
17928: LD_VAR 0 2
17932: PUSH
17933: LD_INT 1
17935: PLUS
17936: ST_TO_ADDR
17937: GO 17914
17939: POP
17940: POP
// end ;
17941: LD_VAR 0 2
17945: RET
// export function IsEmpty ( building ) ; begin
17946: LD_INT 0
17948: PPUSH
// if not building then
17949: LD_VAR 0 1
17953: NOT
17954: IFFALSE 17958
// exit ;
17956: GO 18001
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17958: LD_ADDR_VAR 0 2
17962: PUSH
17963: LD_VAR 0 1
17967: PUSH
17968: LD_INT 22
17970: PUSH
17971: LD_VAR 0 1
17975: PPUSH
17976: CALL_OW 255
17980: PUSH
17981: EMPTY
17982: LIST
17983: LIST
17984: PUSH
17985: LD_INT 58
17987: PUSH
17988: EMPTY
17989: LIST
17990: PUSH
17991: EMPTY
17992: LIST
17993: LIST
17994: PPUSH
17995: CALL_OW 69
17999: IN
18000: ST_TO_ADDR
// end ;
18001: LD_VAR 0 2
18005: RET
// export function IsNotFull ( building ) ; begin
18006: LD_INT 0
18008: PPUSH
// if not building then
18009: LD_VAR 0 1
18013: NOT
18014: IFFALSE 18018
// exit ;
18016: GO 18037
// result := UnitsInside ( building ) < 6 ;
18018: LD_ADDR_VAR 0 2
18022: PUSH
18023: LD_VAR 0 1
18027: PPUSH
18028: CALL_OW 313
18032: PUSH
18033: LD_INT 6
18035: LESS
18036: ST_TO_ADDR
// end ;
18037: LD_VAR 0 2
18041: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18042: LD_INT 0
18044: PPUSH
18045: PPUSH
18046: PPUSH
18047: PPUSH
// tmp := [ ] ;
18048: LD_ADDR_VAR 0 3
18052: PUSH
18053: EMPTY
18054: ST_TO_ADDR
// list := [ ] ;
18055: LD_ADDR_VAR 0 5
18059: PUSH
18060: EMPTY
18061: ST_TO_ADDR
// for i = 16 to 25 do
18062: LD_ADDR_VAR 0 4
18066: PUSH
18067: DOUBLE
18068: LD_INT 16
18070: DEC
18071: ST_TO_ADDR
18072: LD_INT 25
18074: PUSH
18075: FOR_TO
18076: IFFALSE 18149
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18078: LD_ADDR_VAR 0 3
18082: PUSH
18083: LD_VAR 0 3
18087: PUSH
18088: LD_INT 22
18090: PUSH
18091: LD_VAR 0 1
18095: PPUSH
18096: CALL_OW 255
18100: PUSH
18101: EMPTY
18102: LIST
18103: LIST
18104: PUSH
18105: LD_INT 91
18107: PUSH
18108: LD_VAR 0 1
18112: PUSH
18113: LD_INT 6
18115: PUSH
18116: EMPTY
18117: LIST
18118: LIST
18119: LIST
18120: PUSH
18121: LD_INT 30
18123: PUSH
18124: LD_VAR 0 4
18128: PUSH
18129: EMPTY
18130: LIST
18131: LIST
18132: PUSH
18133: EMPTY
18134: LIST
18135: LIST
18136: LIST
18137: PUSH
18138: EMPTY
18139: LIST
18140: PPUSH
18141: CALL_OW 69
18145: ADD
18146: ST_TO_ADDR
18147: GO 18075
18149: POP
18150: POP
// for i = 1 to tmp do
18151: LD_ADDR_VAR 0 4
18155: PUSH
18156: DOUBLE
18157: LD_INT 1
18159: DEC
18160: ST_TO_ADDR
18161: LD_VAR 0 3
18165: PUSH
18166: FOR_TO
18167: IFFALSE 18255
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18169: LD_ADDR_VAR 0 5
18173: PUSH
18174: LD_VAR 0 5
18178: PUSH
18179: LD_VAR 0 3
18183: PUSH
18184: LD_VAR 0 4
18188: ARRAY
18189: PPUSH
18190: CALL_OW 266
18194: PUSH
18195: LD_VAR 0 3
18199: PUSH
18200: LD_VAR 0 4
18204: ARRAY
18205: PPUSH
18206: CALL_OW 250
18210: PUSH
18211: LD_VAR 0 3
18215: PUSH
18216: LD_VAR 0 4
18220: ARRAY
18221: PPUSH
18222: CALL_OW 251
18226: PUSH
18227: LD_VAR 0 3
18231: PUSH
18232: LD_VAR 0 4
18236: ARRAY
18237: PPUSH
18238: CALL_OW 254
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: PUSH
18249: EMPTY
18250: LIST
18251: ADD
18252: ST_TO_ADDR
18253: GO 18166
18255: POP
18256: POP
// result := list ;
18257: LD_ADDR_VAR 0 2
18261: PUSH
18262: LD_VAR 0 5
18266: ST_TO_ADDR
// end ;
18267: LD_VAR 0 2
18271: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18272: LD_INT 0
18274: PPUSH
18275: PPUSH
18276: PPUSH
18277: PPUSH
18278: PPUSH
18279: PPUSH
18280: PPUSH
// if not factory then
18281: LD_VAR 0 1
18285: NOT
18286: IFFALSE 18290
// exit ;
18288: GO 18815
// if control = control_apeman then
18290: LD_VAR 0 4
18294: PUSH
18295: LD_INT 5
18297: EQUAL
18298: IFFALSE 18407
// begin tmp := UnitsInside ( factory ) ;
18300: LD_ADDR_VAR 0 8
18304: PUSH
18305: LD_VAR 0 1
18309: PPUSH
18310: CALL_OW 313
18314: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18315: LD_VAR 0 8
18319: PPUSH
18320: LD_INT 25
18322: PUSH
18323: LD_INT 12
18325: PUSH
18326: EMPTY
18327: LIST
18328: LIST
18329: PPUSH
18330: CALL_OW 72
18334: NOT
18335: IFFALSE 18345
// control := control_manual ;
18337: LD_ADDR_VAR 0 4
18341: PUSH
18342: LD_INT 1
18344: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18345: LD_ADDR_VAR 0 8
18349: PUSH
18350: LD_VAR 0 1
18354: PPUSH
18355: CALL 18042 0 1
18359: ST_TO_ADDR
// if tmp then
18360: LD_VAR 0 8
18364: IFFALSE 18407
// begin for i in tmp do
18366: LD_ADDR_VAR 0 7
18370: PUSH
18371: LD_VAR 0 8
18375: PUSH
18376: FOR_IN
18377: IFFALSE 18405
// if i [ 1 ] = b_ext_radar then
18379: LD_VAR 0 7
18383: PUSH
18384: LD_INT 1
18386: ARRAY
18387: PUSH
18388: LD_INT 20
18390: EQUAL
18391: IFFALSE 18403
// begin control := control_remote ;
18393: LD_ADDR_VAR 0 4
18397: PUSH
18398: LD_INT 2
18400: ST_TO_ADDR
// break ;
18401: GO 18405
// end ;
18403: GO 18376
18405: POP
18406: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18407: LD_VAR 0 1
18411: PPUSH
18412: LD_VAR 0 2
18416: PPUSH
18417: LD_VAR 0 3
18421: PPUSH
18422: LD_VAR 0 4
18426: PPUSH
18427: LD_VAR 0 5
18431: PPUSH
18432: CALL_OW 448
18436: IFFALSE 18471
// begin result := [ chassis , engine , control , weapon ] ;
18438: LD_ADDR_VAR 0 6
18442: PUSH
18443: LD_VAR 0 2
18447: PUSH
18448: LD_VAR 0 3
18452: PUSH
18453: LD_VAR 0 4
18457: PUSH
18458: LD_VAR 0 5
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: LIST
18467: LIST
18468: ST_TO_ADDR
// exit ;
18469: GO 18815
// end ; _chassis := AvailableChassisList ( factory ) ;
18471: LD_ADDR_VAR 0 9
18475: PUSH
18476: LD_VAR 0 1
18480: PPUSH
18481: CALL_OW 475
18485: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18486: LD_ADDR_VAR 0 11
18490: PUSH
18491: LD_VAR 0 1
18495: PPUSH
18496: CALL_OW 476
18500: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18501: LD_ADDR_VAR 0 12
18505: PUSH
18506: LD_VAR 0 1
18510: PPUSH
18511: CALL_OW 477
18515: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18516: LD_ADDR_VAR 0 10
18520: PUSH
18521: LD_VAR 0 1
18525: PPUSH
18526: CALL_OW 478
18530: ST_TO_ADDR
// if not chassis in _chassis then
18531: LD_VAR 0 2
18535: PUSH
18536: LD_VAR 0 9
18540: IN
18541: NOT
18542: IFFALSE 18568
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18544: LD_ADDR_VAR 0 2
18548: PUSH
18549: LD_VAR 0 9
18553: PUSH
18554: LD_INT 1
18556: PPUSH
18557: LD_VAR 0 9
18561: PPUSH
18562: CALL_OW 12
18566: ARRAY
18567: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18568: LD_VAR 0 2
18572: PPUSH
18573: LD_VAR 0 3
18577: PPUSH
18578: CALL 18820 0 2
18582: NOT
18583: IFFALSE 18642
// repeat engine := _engine [ 1 ] ;
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: LD_VAR 0 11
18594: PUSH
18595: LD_INT 1
18597: ARRAY
18598: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18599: LD_ADDR_VAR 0 11
18603: PUSH
18604: LD_VAR 0 11
18608: PPUSH
18609: LD_INT 1
18611: PPUSH
18612: CALL_OW 3
18616: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18617: LD_VAR 0 2
18621: PPUSH
18622: LD_VAR 0 3
18626: PPUSH
18627: CALL 18820 0 2
18631: PUSH
18632: LD_VAR 0 11
18636: PUSH
18637: EMPTY
18638: EQUAL
18639: OR
18640: IFFALSE 18585
// if not control in _control then
18642: LD_VAR 0 4
18646: PUSH
18647: LD_VAR 0 12
18651: IN
18652: NOT
18653: IFFALSE 18679
// control := _control [ rand ( 1 , _control ) ] ;
18655: LD_ADDR_VAR 0 4
18659: PUSH
18660: LD_VAR 0 12
18664: PUSH
18665: LD_INT 1
18667: PPUSH
18668: LD_VAR 0 12
18672: PPUSH
18673: CALL_OW 12
18677: ARRAY
18678: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18679: LD_VAR 0 2
18683: PPUSH
18684: LD_VAR 0 5
18688: PPUSH
18689: CALL 19040 0 2
18693: NOT
18694: IFFALSE 18753
// repeat weapon := _weapon [ 1 ] ;
18696: LD_ADDR_VAR 0 5
18700: PUSH
18701: LD_VAR 0 10
18705: PUSH
18706: LD_INT 1
18708: ARRAY
18709: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18710: LD_ADDR_VAR 0 10
18714: PUSH
18715: LD_VAR 0 10
18719: PPUSH
18720: LD_INT 1
18722: PPUSH
18723: CALL_OW 3
18727: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18728: LD_VAR 0 2
18732: PPUSH
18733: LD_VAR 0 5
18737: PPUSH
18738: CALL 19040 0 2
18742: PUSH
18743: LD_VAR 0 10
18747: PUSH
18748: EMPTY
18749: EQUAL
18750: OR
18751: IFFALSE 18696
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18753: LD_VAR 0 1
18757: PPUSH
18758: LD_VAR 0 2
18762: PPUSH
18763: LD_VAR 0 3
18767: PPUSH
18768: LD_VAR 0 4
18772: PPUSH
18773: LD_VAR 0 5
18777: PPUSH
18778: CALL_OW 448
18782: IFFALSE 18815
// result := [ chassis , engine , control , weapon ] ;
18784: LD_ADDR_VAR 0 6
18788: PUSH
18789: LD_VAR 0 2
18793: PUSH
18794: LD_VAR 0 3
18798: PUSH
18799: LD_VAR 0 4
18803: PUSH
18804: LD_VAR 0 5
18808: PUSH
18809: EMPTY
18810: LIST
18811: LIST
18812: LIST
18813: LIST
18814: ST_TO_ADDR
// end ;
18815: LD_VAR 0 6
18819: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18820: LD_INT 0
18822: PPUSH
// if not chassis or not engine then
18823: LD_VAR 0 1
18827: NOT
18828: PUSH
18829: LD_VAR 0 2
18833: NOT
18834: OR
18835: IFFALSE 18839
// exit ;
18837: GO 19035
// case engine of engine_solar :
18839: LD_VAR 0 2
18843: PUSH
18844: LD_INT 2
18846: DOUBLE
18847: EQUAL
18848: IFTRUE 18852
18850: GO 18890
18852: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18853: LD_ADDR_VAR 0 3
18857: PUSH
18858: LD_INT 11
18860: PUSH
18861: LD_INT 12
18863: PUSH
18864: LD_INT 13
18866: PUSH
18867: LD_INT 14
18869: PUSH
18870: LD_INT 1
18872: PUSH
18873: LD_INT 2
18875: PUSH
18876: LD_INT 3
18878: PUSH
18879: EMPTY
18880: LIST
18881: LIST
18882: LIST
18883: LIST
18884: LIST
18885: LIST
18886: LIST
18887: ST_TO_ADDR
18888: GO 19019
18890: LD_INT 1
18892: DOUBLE
18893: EQUAL
18894: IFTRUE 18898
18896: GO 18960
18898: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18899: LD_ADDR_VAR 0 3
18903: PUSH
18904: LD_INT 11
18906: PUSH
18907: LD_INT 12
18909: PUSH
18910: LD_INT 13
18912: PUSH
18913: LD_INT 14
18915: PUSH
18916: LD_INT 1
18918: PUSH
18919: LD_INT 2
18921: PUSH
18922: LD_INT 3
18924: PUSH
18925: LD_INT 4
18927: PUSH
18928: LD_INT 5
18930: PUSH
18931: LD_INT 21
18933: PUSH
18934: LD_INT 23
18936: PUSH
18937: LD_INT 22
18939: PUSH
18940: LD_INT 24
18942: PUSH
18943: EMPTY
18944: LIST
18945: LIST
18946: LIST
18947: LIST
18948: LIST
18949: LIST
18950: LIST
18951: LIST
18952: LIST
18953: LIST
18954: LIST
18955: LIST
18956: LIST
18957: ST_TO_ADDR
18958: GO 19019
18960: LD_INT 3
18962: DOUBLE
18963: EQUAL
18964: IFTRUE 18968
18966: GO 19018
18968: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18969: LD_ADDR_VAR 0 3
18973: PUSH
18974: LD_INT 13
18976: PUSH
18977: LD_INT 14
18979: PUSH
18980: LD_INT 2
18982: PUSH
18983: LD_INT 3
18985: PUSH
18986: LD_INT 4
18988: PUSH
18989: LD_INT 5
18991: PUSH
18992: LD_INT 21
18994: PUSH
18995: LD_INT 22
18997: PUSH
18998: LD_INT 23
19000: PUSH
19001: LD_INT 24
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: LIST
19008: LIST
19009: LIST
19010: LIST
19011: LIST
19012: LIST
19013: LIST
19014: LIST
19015: ST_TO_ADDR
19016: GO 19019
19018: POP
// result := ( chassis in result ) ;
19019: LD_ADDR_VAR 0 3
19023: PUSH
19024: LD_VAR 0 1
19028: PUSH
19029: LD_VAR 0 3
19033: IN
19034: ST_TO_ADDR
// end ;
19035: LD_VAR 0 3
19039: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19040: LD_INT 0
19042: PPUSH
// if not chassis or not weapon then
19043: LD_VAR 0 1
19047: NOT
19048: PUSH
19049: LD_VAR 0 2
19053: NOT
19054: OR
19055: IFFALSE 19059
// exit ;
19057: GO 20085
// case weapon of us_machine_gun :
19059: LD_VAR 0 2
19063: PUSH
19064: LD_INT 2
19066: DOUBLE
19067: EQUAL
19068: IFTRUE 19072
19070: GO 19102
19072: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19073: LD_ADDR_VAR 0 3
19077: PUSH
19078: LD_INT 1
19080: PUSH
19081: LD_INT 2
19083: PUSH
19084: LD_INT 3
19086: PUSH
19087: LD_INT 4
19089: PUSH
19090: LD_INT 5
19092: PUSH
19093: EMPTY
19094: LIST
19095: LIST
19096: LIST
19097: LIST
19098: LIST
19099: ST_TO_ADDR
19100: GO 20069
19102: LD_INT 3
19104: DOUBLE
19105: EQUAL
19106: IFTRUE 19110
19108: GO 19140
19110: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19111: LD_ADDR_VAR 0 3
19115: PUSH
19116: LD_INT 1
19118: PUSH
19119: LD_INT 2
19121: PUSH
19122: LD_INT 3
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: LIST
19137: ST_TO_ADDR
19138: GO 20069
19140: LD_INT 11
19142: DOUBLE
19143: EQUAL
19144: IFTRUE 19148
19146: GO 19178
19148: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19149: LD_ADDR_VAR 0 3
19153: PUSH
19154: LD_INT 1
19156: PUSH
19157: LD_INT 2
19159: PUSH
19160: LD_INT 3
19162: PUSH
19163: LD_INT 4
19165: PUSH
19166: LD_INT 5
19168: PUSH
19169: EMPTY
19170: LIST
19171: LIST
19172: LIST
19173: LIST
19174: LIST
19175: ST_TO_ADDR
19176: GO 20069
19178: LD_INT 4
19180: DOUBLE
19181: EQUAL
19182: IFTRUE 19186
19184: GO 19212
19186: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19187: LD_ADDR_VAR 0 3
19191: PUSH
19192: LD_INT 2
19194: PUSH
19195: LD_INT 3
19197: PUSH
19198: LD_INT 4
19200: PUSH
19201: LD_INT 5
19203: PUSH
19204: EMPTY
19205: LIST
19206: LIST
19207: LIST
19208: LIST
19209: ST_TO_ADDR
19210: GO 20069
19212: LD_INT 5
19214: DOUBLE
19215: EQUAL
19216: IFTRUE 19220
19218: GO 19246
19220: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19221: LD_ADDR_VAR 0 3
19225: PUSH
19226: LD_INT 2
19228: PUSH
19229: LD_INT 3
19231: PUSH
19232: LD_INT 4
19234: PUSH
19235: LD_INT 5
19237: PUSH
19238: EMPTY
19239: LIST
19240: LIST
19241: LIST
19242: LIST
19243: ST_TO_ADDR
19244: GO 20069
19246: LD_INT 9
19248: DOUBLE
19249: EQUAL
19250: IFTRUE 19254
19252: GO 19280
19254: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_INT 2
19262: PUSH
19263: LD_INT 3
19265: PUSH
19266: LD_INT 4
19268: PUSH
19269: LD_INT 5
19271: PUSH
19272: EMPTY
19273: LIST
19274: LIST
19275: LIST
19276: LIST
19277: ST_TO_ADDR
19278: GO 20069
19280: LD_INT 7
19282: DOUBLE
19283: EQUAL
19284: IFTRUE 19288
19286: GO 19314
19288: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19289: LD_ADDR_VAR 0 3
19293: PUSH
19294: LD_INT 2
19296: PUSH
19297: LD_INT 3
19299: PUSH
19300: LD_INT 4
19302: PUSH
19303: LD_INT 5
19305: PUSH
19306: EMPTY
19307: LIST
19308: LIST
19309: LIST
19310: LIST
19311: ST_TO_ADDR
19312: GO 20069
19314: LD_INT 12
19316: DOUBLE
19317: EQUAL
19318: IFTRUE 19322
19320: GO 19348
19322: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19323: LD_ADDR_VAR 0 3
19327: PUSH
19328: LD_INT 2
19330: PUSH
19331: LD_INT 3
19333: PUSH
19334: LD_INT 4
19336: PUSH
19337: LD_INT 5
19339: PUSH
19340: EMPTY
19341: LIST
19342: LIST
19343: LIST
19344: LIST
19345: ST_TO_ADDR
19346: GO 20069
19348: LD_INT 13
19350: DOUBLE
19351: EQUAL
19352: IFTRUE 19356
19354: GO 19382
19356: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19357: LD_ADDR_VAR 0 3
19361: PUSH
19362: LD_INT 2
19364: PUSH
19365: LD_INT 3
19367: PUSH
19368: LD_INT 4
19370: PUSH
19371: LD_INT 5
19373: PUSH
19374: EMPTY
19375: LIST
19376: LIST
19377: LIST
19378: LIST
19379: ST_TO_ADDR
19380: GO 20069
19382: LD_INT 14
19384: DOUBLE
19385: EQUAL
19386: IFTRUE 19390
19388: GO 19408
19390: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19391: LD_ADDR_VAR 0 3
19395: PUSH
19396: LD_INT 4
19398: PUSH
19399: LD_INT 5
19401: PUSH
19402: EMPTY
19403: LIST
19404: LIST
19405: ST_TO_ADDR
19406: GO 20069
19408: LD_INT 6
19410: DOUBLE
19411: EQUAL
19412: IFTRUE 19416
19414: GO 19434
19416: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19417: LD_ADDR_VAR 0 3
19421: PUSH
19422: LD_INT 4
19424: PUSH
19425: LD_INT 5
19427: PUSH
19428: EMPTY
19429: LIST
19430: LIST
19431: ST_TO_ADDR
19432: GO 20069
19434: LD_INT 10
19436: DOUBLE
19437: EQUAL
19438: IFTRUE 19442
19440: GO 19460
19442: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19443: LD_ADDR_VAR 0 3
19447: PUSH
19448: LD_INT 4
19450: PUSH
19451: LD_INT 5
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: ST_TO_ADDR
19458: GO 20069
19460: LD_INT 22
19462: DOUBLE
19463: EQUAL
19464: IFTRUE 19468
19466: GO 19494
19468: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19469: LD_ADDR_VAR 0 3
19473: PUSH
19474: LD_INT 11
19476: PUSH
19477: LD_INT 12
19479: PUSH
19480: LD_INT 13
19482: PUSH
19483: LD_INT 14
19485: PUSH
19486: EMPTY
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: ST_TO_ADDR
19492: GO 20069
19494: LD_INT 23
19496: DOUBLE
19497: EQUAL
19498: IFTRUE 19502
19500: GO 19528
19502: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19503: LD_ADDR_VAR 0 3
19507: PUSH
19508: LD_INT 11
19510: PUSH
19511: LD_INT 12
19513: PUSH
19514: LD_INT 13
19516: PUSH
19517: LD_INT 14
19519: PUSH
19520: EMPTY
19521: LIST
19522: LIST
19523: LIST
19524: LIST
19525: ST_TO_ADDR
19526: GO 20069
19528: LD_INT 24
19530: DOUBLE
19531: EQUAL
19532: IFTRUE 19536
19534: GO 19562
19536: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19537: LD_ADDR_VAR 0 3
19541: PUSH
19542: LD_INT 11
19544: PUSH
19545: LD_INT 12
19547: PUSH
19548: LD_INT 13
19550: PUSH
19551: LD_INT 14
19553: PUSH
19554: EMPTY
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: ST_TO_ADDR
19560: GO 20069
19562: LD_INT 30
19564: DOUBLE
19565: EQUAL
19566: IFTRUE 19570
19568: GO 19596
19570: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19571: LD_ADDR_VAR 0 3
19575: PUSH
19576: LD_INT 11
19578: PUSH
19579: LD_INT 12
19581: PUSH
19582: LD_INT 13
19584: PUSH
19585: LD_INT 14
19587: PUSH
19588: EMPTY
19589: LIST
19590: LIST
19591: LIST
19592: LIST
19593: ST_TO_ADDR
19594: GO 20069
19596: LD_INT 25
19598: DOUBLE
19599: EQUAL
19600: IFTRUE 19604
19602: GO 19622
19604: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19605: LD_ADDR_VAR 0 3
19609: PUSH
19610: LD_INT 13
19612: PUSH
19613: LD_INT 14
19615: PUSH
19616: EMPTY
19617: LIST
19618: LIST
19619: ST_TO_ADDR
19620: GO 20069
19622: LD_INT 27
19624: DOUBLE
19625: EQUAL
19626: IFTRUE 19630
19628: GO 19648
19630: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19631: LD_ADDR_VAR 0 3
19635: PUSH
19636: LD_INT 13
19638: PUSH
19639: LD_INT 14
19641: PUSH
19642: EMPTY
19643: LIST
19644: LIST
19645: ST_TO_ADDR
19646: GO 20069
19648: LD_INT 28
19650: DOUBLE
19651: EQUAL
19652: IFTRUE 19656
19654: GO 19674
19656: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19657: LD_ADDR_VAR 0 3
19661: PUSH
19662: LD_INT 13
19664: PUSH
19665: LD_INT 14
19667: PUSH
19668: EMPTY
19669: LIST
19670: LIST
19671: ST_TO_ADDR
19672: GO 20069
19674: LD_INT 29
19676: DOUBLE
19677: EQUAL
19678: IFTRUE 19682
19680: GO 19700
19682: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19683: LD_ADDR_VAR 0 3
19687: PUSH
19688: LD_INT 13
19690: PUSH
19691: LD_INT 14
19693: PUSH
19694: EMPTY
19695: LIST
19696: LIST
19697: ST_TO_ADDR
19698: GO 20069
19700: LD_INT 31
19702: DOUBLE
19703: EQUAL
19704: IFTRUE 19708
19706: GO 19726
19708: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19709: LD_ADDR_VAR 0 3
19713: PUSH
19714: LD_INT 13
19716: PUSH
19717: LD_INT 14
19719: PUSH
19720: EMPTY
19721: LIST
19722: LIST
19723: ST_TO_ADDR
19724: GO 20069
19726: LD_INT 26
19728: DOUBLE
19729: EQUAL
19730: IFTRUE 19734
19732: GO 19752
19734: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19735: LD_ADDR_VAR 0 3
19739: PUSH
19740: LD_INT 13
19742: PUSH
19743: LD_INT 14
19745: PUSH
19746: EMPTY
19747: LIST
19748: LIST
19749: ST_TO_ADDR
19750: GO 20069
19752: LD_INT 42
19754: DOUBLE
19755: EQUAL
19756: IFTRUE 19760
19758: GO 19786
19760: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19761: LD_ADDR_VAR 0 3
19765: PUSH
19766: LD_INT 21
19768: PUSH
19769: LD_INT 22
19771: PUSH
19772: LD_INT 23
19774: PUSH
19775: LD_INT 24
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: LIST
19782: LIST
19783: ST_TO_ADDR
19784: GO 20069
19786: LD_INT 43
19788: DOUBLE
19789: EQUAL
19790: IFTRUE 19794
19792: GO 19820
19794: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19795: LD_ADDR_VAR 0 3
19799: PUSH
19800: LD_INT 21
19802: PUSH
19803: LD_INT 22
19805: PUSH
19806: LD_INT 23
19808: PUSH
19809: LD_INT 24
19811: PUSH
19812: EMPTY
19813: LIST
19814: LIST
19815: LIST
19816: LIST
19817: ST_TO_ADDR
19818: GO 20069
19820: LD_INT 44
19822: DOUBLE
19823: EQUAL
19824: IFTRUE 19828
19826: GO 19854
19828: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19829: LD_ADDR_VAR 0 3
19833: PUSH
19834: LD_INT 21
19836: PUSH
19837: LD_INT 22
19839: PUSH
19840: LD_INT 23
19842: PUSH
19843: LD_INT 24
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: ST_TO_ADDR
19852: GO 20069
19854: LD_INT 45
19856: DOUBLE
19857: EQUAL
19858: IFTRUE 19862
19860: GO 19888
19862: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19863: LD_ADDR_VAR 0 3
19867: PUSH
19868: LD_INT 21
19870: PUSH
19871: LD_INT 22
19873: PUSH
19874: LD_INT 23
19876: PUSH
19877: LD_INT 24
19879: PUSH
19880: EMPTY
19881: LIST
19882: LIST
19883: LIST
19884: LIST
19885: ST_TO_ADDR
19886: GO 20069
19888: LD_INT 49
19890: DOUBLE
19891: EQUAL
19892: IFTRUE 19896
19894: GO 19922
19896: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19897: LD_ADDR_VAR 0 3
19901: PUSH
19902: LD_INT 21
19904: PUSH
19905: LD_INT 22
19907: PUSH
19908: LD_INT 23
19910: PUSH
19911: LD_INT 24
19913: PUSH
19914: EMPTY
19915: LIST
19916: LIST
19917: LIST
19918: LIST
19919: ST_TO_ADDR
19920: GO 20069
19922: LD_INT 51
19924: DOUBLE
19925: EQUAL
19926: IFTRUE 19930
19928: GO 19956
19930: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19931: LD_ADDR_VAR 0 3
19935: PUSH
19936: LD_INT 21
19938: PUSH
19939: LD_INT 22
19941: PUSH
19942: LD_INT 23
19944: PUSH
19945: LD_INT 24
19947: PUSH
19948: EMPTY
19949: LIST
19950: LIST
19951: LIST
19952: LIST
19953: ST_TO_ADDR
19954: GO 20069
19956: LD_INT 52
19958: DOUBLE
19959: EQUAL
19960: IFTRUE 19964
19962: GO 19990
19964: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19965: LD_ADDR_VAR 0 3
19969: PUSH
19970: LD_INT 21
19972: PUSH
19973: LD_INT 22
19975: PUSH
19976: LD_INT 23
19978: PUSH
19979: LD_INT 24
19981: PUSH
19982: EMPTY
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: ST_TO_ADDR
19988: GO 20069
19990: LD_INT 53
19992: DOUBLE
19993: EQUAL
19994: IFTRUE 19998
19996: GO 20016
19998: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19999: LD_ADDR_VAR 0 3
20003: PUSH
20004: LD_INT 23
20006: PUSH
20007: LD_INT 24
20009: PUSH
20010: EMPTY
20011: LIST
20012: LIST
20013: ST_TO_ADDR
20014: GO 20069
20016: LD_INT 46
20018: DOUBLE
20019: EQUAL
20020: IFTRUE 20024
20022: GO 20042
20024: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20025: LD_ADDR_VAR 0 3
20029: PUSH
20030: LD_INT 23
20032: PUSH
20033: LD_INT 24
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: ST_TO_ADDR
20040: GO 20069
20042: LD_INT 47
20044: DOUBLE
20045: EQUAL
20046: IFTRUE 20050
20048: GO 20068
20050: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20051: LD_ADDR_VAR 0 3
20055: PUSH
20056: LD_INT 23
20058: PUSH
20059: LD_INT 24
20061: PUSH
20062: EMPTY
20063: LIST
20064: LIST
20065: ST_TO_ADDR
20066: GO 20069
20068: POP
// result := ( chassis in result ) ;
20069: LD_ADDR_VAR 0 3
20073: PUSH
20074: LD_VAR 0 1
20078: PUSH
20079: LD_VAR 0 3
20083: IN
20084: ST_TO_ADDR
// end ;
20085: LD_VAR 0 3
20089: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20090: LD_INT 0
20092: PPUSH
20093: PPUSH
20094: PPUSH
20095: PPUSH
20096: PPUSH
20097: PPUSH
20098: PPUSH
// result := array ;
20099: LD_ADDR_VAR 0 5
20103: PUSH
20104: LD_VAR 0 1
20108: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20109: LD_VAR 0 1
20113: NOT
20114: PUSH
20115: LD_VAR 0 2
20119: NOT
20120: OR
20121: PUSH
20122: LD_VAR 0 3
20126: NOT
20127: OR
20128: PUSH
20129: LD_VAR 0 2
20133: PUSH
20134: LD_VAR 0 1
20138: GREATER
20139: OR
20140: PUSH
20141: LD_VAR 0 3
20145: PUSH
20146: LD_VAR 0 1
20150: GREATER
20151: OR
20152: IFFALSE 20156
// exit ;
20154: GO 20452
// if direction then
20156: LD_VAR 0 4
20160: IFFALSE 20224
// begin d := 1 ;
20162: LD_ADDR_VAR 0 9
20166: PUSH
20167: LD_INT 1
20169: ST_TO_ADDR
// if i_from > i_to then
20170: LD_VAR 0 2
20174: PUSH
20175: LD_VAR 0 3
20179: GREATER
20180: IFFALSE 20206
// length := ( array - i_from ) + i_to else
20182: LD_ADDR_VAR 0 11
20186: PUSH
20187: LD_VAR 0 1
20191: PUSH
20192: LD_VAR 0 2
20196: MINUS
20197: PUSH
20198: LD_VAR 0 3
20202: PLUS
20203: ST_TO_ADDR
20204: GO 20222
// length := i_to - i_from ;
20206: LD_ADDR_VAR 0 11
20210: PUSH
20211: LD_VAR 0 3
20215: PUSH
20216: LD_VAR 0 2
20220: MINUS
20221: ST_TO_ADDR
// end else
20222: GO 20285
// begin d := - 1 ;
20224: LD_ADDR_VAR 0 9
20228: PUSH
20229: LD_INT 1
20231: NEG
20232: ST_TO_ADDR
// if i_from > i_to then
20233: LD_VAR 0 2
20237: PUSH
20238: LD_VAR 0 3
20242: GREATER
20243: IFFALSE 20263
// length := i_from - i_to else
20245: LD_ADDR_VAR 0 11
20249: PUSH
20250: LD_VAR 0 2
20254: PUSH
20255: LD_VAR 0 3
20259: MINUS
20260: ST_TO_ADDR
20261: GO 20285
// length := ( array - i_to ) + i_from ;
20263: LD_ADDR_VAR 0 11
20267: PUSH
20268: LD_VAR 0 1
20272: PUSH
20273: LD_VAR 0 3
20277: MINUS
20278: PUSH
20279: LD_VAR 0 2
20283: PLUS
20284: ST_TO_ADDR
// end ; if not length then
20285: LD_VAR 0 11
20289: NOT
20290: IFFALSE 20294
// exit ;
20292: GO 20452
// tmp := array ;
20294: LD_ADDR_VAR 0 10
20298: PUSH
20299: LD_VAR 0 1
20303: ST_TO_ADDR
// for i = 1 to length do
20304: LD_ADDR_VAR 0 6
20308: PUSH
20309: DOUBLE
20310: LD_INT 1
20312: DEC
20313: ST_TO_ADDR
20314: LD_VAR 0 11
20318: PUSH
20319: FOR_TO
20320: IFFALSE 20440
// begin for j = 1 to array do
20322: LD_ADDR_VAR 0 7
20326: PUSH
20327: DOUBLE
20328: LD_INT 1
20330: DEC
20331: ST_TO_ADDR
20332: LD_VAR 0 1
20336: PUSH
20337: FOR_TO
20338: IFFALSE 20426
// begin k := j + d ;
20340: LD_ADDR_VAR 0 8
20344: PUSH
20345: LD_VAR 0 7
20349: PUSH
20350: LD_VAR 0 9
20354: PLUS
20355: ST_TO_ADDR
// if k > array then
20356: LD_VAR 0 8
20360: PUSH
20361: LD_VAR 0 1
20365: GREATER
20366: IFFALSE 20376
// k := 1 ;
20368: LD_ADDR_VAR 0 8
20372: PUSH
20373: LD_INT 1
20375: ST_TO_ADDR
// if not k then
20376: LD_VAR 0 8
20380: NOT
20381: IFFALSE 20393
// k := array ;
20383: LD_ADDR_VAR 0 8
20387: PUSH
20388: LD_VAR 0 1
20392: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20393: LD_ADDR_VAR 0 10
20397: PUSH
20398: LD_VAR 0 10
20402: PPUSH
20403: LD_VAR 0 8
20407: PPUSH
20408: LD_VAR 0 1
20412: PUSH
20413: LD_VAR 0 7
20417: ARRAY
20418: PPUSH
20419: CALL_OW 1
20423: ST_TO_ADDR
// end ;
20424: GO 20337
20426: POP
20427: POP
// array := tmp ;
20428: LD_ADDR_VAR 0 1
20432: PUSH
20433: LD_VAR 0 10
20437: ST_TO_ADDR
// end ;
20438: GO 20319
20440: POP
20441: POP
// result := array ;
20442: LD_ADDR_VAR 0 5
20446: PUSH
20447: LD_VAR 0 1
20451: ST_TO_ADDR
// end ;
20452: LD_VAR 0 5
20456: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20457: LD_INT 0
20459: PPUSH
20460: PPUSH
// result := 0 ;
20461: LD_ADDR_VAR 0 3
20465: PUSH
20466: LD_INT 0
20468: ST_TO_ADDR
// if not array or not value in array then
20469: LD_VAR 0 1
20473: NOT
20474: PUSH
20475: LD_VAR 0 2
20479: PUSH
20480: LD_VAR 0 1
20484: IN
20485: NOT
20486: OR
20487: IFFALSE 20491
// exit ;
20489: GO 20545
// for i = 1 to array do
20491: LD_ADDR_VAR 0 4
20495: PUSH
20496: DOUBLE
20497: LD_INT 1
20499: DEC
20500: ST_TO_ADDR
20501: LD_VAR 0 1
20505: PUSH
20506: FOR_TO
20507: IFFALSE 20543
// if value = array [ i ] then
20509: LD_VAR 0 2
20513: PUSH
20514: LD_VAR 0 1
20518: PUSH
20519: LD_VAR 0 4
20523: ARRAY
20524: EQUAL
20525: IFFALSE 20541
// begin result := i ;
20527: LD_ADDR_VAR 0 3
20531: PUSH
20532: LD_VAR 0 4
20536: ST_TO_ADDR
// exit ;
20537: POP
20538: POP
20539: GO 20545
// end ;
20541: GO 20506
20543: POP
20544: POP
// end ;
20545: LD_VAR 0 3
20549: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20550: LD_INT 0
20552: PPUSH
// vc_chassis := chassis ;
20553: LD_ADDR_OWVAR 37
20557: PUSH
20558: LD_VAR 0 1
20562: ST_TO_ADDR
// vc_engine := engine ;
20563: LD_ADDR_OWVAR 39
20567: PUSH
20568: LD_VAR 0 2
20572: ST_TO_ADDR
// vc_control := control ;
20573: LD_ADDR_OWVAR 38
20577: PUSH
20578: LD_VAR 0 3
20582: ST_TO_ADDR
// vc_weapon := weapon ;
20583: LD_ADDR_OWVAR 40
20587: PUSH
20588: LD_VAR 0 4
20592: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20593: LD_ADDR_OWVAR 41
20597: PUSH
20598: LD_VAR 0 5
20602: ST_TO_ADDR
// end ;
20603: LD_VAR 0 6
20607: RET
// export function WantPlant ( unit ) ; var task ; begin
20608: LD_INT 0
20610: PPUSH
20611: PPUSH
// result := false ;
20612: LD_ADDR_VAR 0 2
20616: PUSH
20617: LD_INT 0
20619: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20620: LD_ADDR_VAR 0 3
20624: PUSH
20625: LD_VAR 0 1
20629: PPUSH
20630: CALL_OW 437
20634: ST_TO_ADDR
// if task then
20635: LD_VAR 0 3
20639: IFFALSE 20667
// if task [ 1 ] [ 1 ] = p then
20641: LD_VAR 0 3
20645: PUSH
20646: LD_INT 1
20648: ARRAY
20649: PUSH
20650: LD_INT 1
20652: ARRAY
20653: PUSH
20654: LD_STRING p
20656: EQUAL
20657: IFFALSE 20667
// result := true ;
20659: LD_ADDR_VAR 0 2
20663: PUSH
20664: LD_INT 1
20666: ST_TO_ADDR
// end ;
20667: LD_VAR 0 2
20671: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20672: LD_INT 0
20674: PPUSH
20675: PPUSH
20676: PPUSH
20677: PPUSH
// if pos < 1 then
20678: LD_VAR 0 2
20682: PUSH
20683: LD_INT 1
20685: LESS
20686: IFFALSE 20690
// exit ;
20688: GO 20993
// if pos = 1 then
20690: LD_VAR 0 2
20694: PUSH
20695: LD_INT 1
20697: EQUAL
20698: IFFALSE 20731
// result := Replace ( arr , pos [ 1 ] , value ) else
20700: LD_ADDR_VAR 0 4
20704: PUSH
20705: LD_VAR 0 1
20709: PPUSH
20710: LD_VAR 0 2
20714: PUSH
20715: LD_INT 1
20717: ARRAY
20718: PPUSH
20719: LD_VAR 0 3
20723: PPUSH
20724: CALL_OW 1
20728: ST_TO_ADDR
20729: GO 20993
// begin tmp := arr ;
20731: LD_ADDR_VAR 0 6
20735: PUSH
20736: LD_VAR 0 1
20740: ST_TO_ADDR
// s_arr := [ tmp ] ;
20741: LD_ADDR_VAR 0 7
20745: PUSH
20746: LD_VAR 0 6
20750: PUSH
20751: EMPTY
20752: LIST
20753: ST_TO_ADDR
// for i = 1 to pos - 1 do
20754: LD_ADDR_VAR 0 5
20758: PUSH
20759: DOUBLE
20760: LD_INT 1
20762: DEC
20763: ST_TO_ADDR
20764: LD_VAR 0 2
20768: PUSH
20769: LD_INT 1
20771: MINUS
20772: PUSH
20773: FOR_TO
20774: IFFALSE 20819
// begin tmp := tmp [ pos [ i ] ] ;
20776: LD_ADDR_VAR 0 6
20780: PUSH
20781: LD_VAR 0 6
20785: PUSH
20786: LD_VAR 0 2
20790: PUSH
20791: LD_VAR 0 5
20795: ARRAY
20796: ARRAY
20797: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20798: LD_ADDR_VAR 0 7
20802: PUSH
20803: LD_VAR 0 7
20807: PUSH
20808: LD_VAR 0 6
20812: PUSH
20813: EMPTY
20814: LIST
20815: ADD
20816: ST_TO_ADDR
// end ;
20817: GO 20773
20819: POP
20820: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20821: LD_ADDR_VAR 0 6
20825: PUSH
20826: LD_VAR 0 6
20830: PPUSH
20831: LD_VAR 0 2
20835: PUSH
20836: LD_VAR 0 2
20840: ARRAY
20841: PPUSH
20842: LD_VAR 0 3
20846: PPUSH
20847: CALL_OW 1
20851: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20852: LD_ADDR_VAR 0 7
20856: PUSH
20857: LD_VAR 0 7
20861: PPUSH
20862: LD_VAR 0 7
20866: PPUSH
20867: LD_VAR 0 6
20871: PPUSH
20872: CALL_OW 1
20876: ST_TO_ADDR
// for i = s_arr downto 2 do
20877: LD_ADDR_VAR 0 5
20881: PUSH
20882: DOUBLE
20883: LD_VAR 0 7
20887: INC
20888: ST_TO_ADDR
20889: LD_INT 2
20891: PUSH
20892: FOR_DOWNTO
20893: IFFALSE 20977
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20895: LD_ADDR_VAR 0 6
20899: PUSH
20900: LD_VAR 0 7
20904: PUSH
20905: LD_VAR 0 5
20909: PUSH
20910: LD_INT 1
20912: MINUS
20913: ARRAY
20914: PPUSH
20915: LD_VAR 0 2
20919: PUSH
20920: LD_VAR 0 5
20924: PUSH
20925: LD_INT 1
20927: MINUS
20928: ARRAY
20929: PPUSH
20930: LD_VAR 0 7
20934: PUSH
20935: LD_VAR 0 5
20939: ARRAY
20940: PPUSH
20941: CALL_OW 1
20945: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20946: LD_ADDR_VAR 0 7
20950: PUSH
20951: LD_VAR 0 7
20955: PPUSH
20956: LD_VAR 0 5
20960: PUSH
20961: LD_INT 1
20963: MINUS
20964: PPUSH
20965: LD_VAR 0 6
20969: PPUSH
20970: CALL_OW 1
20974: ST_TO_ADDR
// end ;
20975: GO 20892
20977: POP
20978: POP
// result := s_arr [ 1 ] ;
20979: LD_ADDR_VAR 0 4
20983: PUSH
20984: LD_VAR 0 7
20988: PUSH
20989: LD_INT 1
20991: ARRAY
20992: ST_TO_ADDR
// end ; end ;
20993: LD_VAR 0 4
20997: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20998: LD_INT 0
21000: PPUSH
21001: PPUSH
// if not list then
21002: LD_VAR 0 1
21006: NOT
21007: IFFALSE 21011
// exit ;
21009: GO 21102
// i := list [ pos1 ] ;
21011: LD_ADDR_VAR 0 5
21015: PUSH
21016: LD_VAR 0 1
21020: PUSH
21021: LD_VAR 0 2
21025: ARRAY
21026: ST_TO_ADDR
// if not i then
21027: LD_VAR 0 5
21031: NOT
21032: IFFALSE 21036
// exit ;
21034: GO 21102
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21036: LD_ADDR_VAR 0 1
21040: PUSH
21041: LD_VAR 0 1
21045: PPUSH
21046: LD_VAR 0 2
21050: PPUSH
21051: LD_VAR 0 1
21055: PUSH
21056: LD_VAR 0 3
21060: ARRAY
21061: PPUSH
21062: CALL_OW 1
21066: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21067: LD_ADDR_VAR 0 1
21071: PUSH
21072: LD_VAR 0 1
21076: PPUSH
21077: LD_VAR 0 3
21081: PPUSH
21082: LD_VAR 0 5
21086: PPUSH
21087: CALL_OW 1
21091: ST_TO_ADDR
// result := list ;
21092: LD_ADDR_VAR 0 4
21096: PUSH
21097: LD_VAR 0 1
21101: ST_TO_ADDR
// end ;
21102: LD_VAR 0 4
21106: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21107: LD_INT 0
21109: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21110: LD_ADDR_VAR 0 5
21114: PUSH
21115: LD_VAR 0 1
21119: PPUSH
21120: CALL_OW 250
21124: PPUSH
21125: LD_VAR 0 1
21129: PPUSH
21130: CALL_OW 251
21134: PPUSH
21135: LD_VAR 0 2
21139: PPUSH
21140: LD_VAR 0 3
21144: PPUSH
21145: LD_VAR 0 4
21149: PPUSH
21150: CALL 21160 0 5
21154: ST_TO_ADDR
// end ;
21155: LD_VAR 0 5
21159: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21160: LD_INT 0
21162: PPUSH
21163: PPUSH
21164: PPUSH
21165: PPUSH
// if not list then
21166: LD_VAR 0 3
21170: NOT
21171: IFFALSE 21175
// exit ;
21173: GO 21563
// result := [ ] ;
21175: LD_ADDR_VAR 0 6
21179: PUSH
21180: EMPTY
21181: ST_TO_ADDR
// for i in list do
21182: LD_ADDR_VAR 0 7
21186: PUSH
21187: LD_VAR 0 3
21191: PUSH
21192: FOR_IN
21193: IFFALSE 21395
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21195: LD_ADDR_VAR 0 9
21199: PUSH
21200: LD_VAR 0 7
21204: PPUSH
21205: LD_VAR 0 1
21209: PPUSH
21210: LD_VAR 0 2
21214: PPUSH
21215: CALL_OW 297
21219: ST_TO_ADDR
// if not result then
21220: LD_VAR 0 6
21224: NOT
21225: IFFALSE 21251
// result := [ [ i , tmp ] ] else
21227: LD_ADDR_VAR 0 6
21231: PUSH
21232: LD_VAR 0 7
21236: PUSH
21237: LD_VAR 0 9
21241: PUSH
21242: EMPTY
21243: LIST
21244: LIST
21245: PUSH
21246: EMPTY
21247: LIST
21248: ST_TO_ADDR
21249: GO 21393
// begin if result [ result ] [ 2 ] < tmp then
21251: LD_VAR 0 6
21255: PUSH
21256: LD_VAR 0 6
21260: ARRAY
21261: PUSH
21262: LD_INT 2
21264: ARRAY
21265: PUSH
21266: LD_VAR 0 9
21270: LESS
21271: IFFALSE 21313
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21273: LD_ADDR_VAR 0 6
21277: PUSH
21278: LD_VAR 0 6
21282: PPUSH
21283: LD_VAR 0 6
21287: PUSH
21288: LD_INT 1
21290: PLUS
21291: PPUSH
21292: LD_VAR 0 7
21296: PUSH
21297: LD_VAR 0 9
21301: PUSH
21302: EMPTY
21303: LIST
21304: LIST
21305: PPUSH
21306: CALL_OW 2
21310: ST_TO_ADDR
21311: GO 21393
// for j = 1 to result do
21313: LD_ADDR_VAR 0 8
21317: PUSH
21318: DOUBLE
21319: LD_INT 1
21321: DEC
21322: ST_TO_ADDR
21323: LD_VAR 0 6
21327: PUSH
21328: FOR_TO
21329: IFFALSE 21391
// begin if tmp < result [ j ] [ 2 ] then
21331: LD_VAR 0 9
21335: PUSH
21336: LD_VAR 0 6
21340: PUSH
21341: LD_VAR 0 8
21345: ARRAY
21346: PUSH
21347: LD_INT 2
21349: ARRAY
21350: LESS
21351: IFFALSE 21389
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21353: LD_ADDR_VAR 0 6
21357: PUSH
21358: LD_VAR 0 6
21362: PPUSH
21363: LD_VAR 0 8
21367: PPUSH
21368: LD_VAR 0 7
21372: PUSH
21373: LD_VAR 0 9
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PPUSH
21382: CALL_OW 2
21386: ST_TO_ADDR
// break ;
21387: GO 21391
// end ; end ;
21389: GO 21328
21391: POP
21392: POP
// end ; end ;
21393: GO 21192
21395: POP
21396: POP
// if result and not asc then
21397: LD_VAR 0 6
21401: PUSH
21402: LD_VAR 0 4
21406: NOT
21407: AND
21408: IFFALSE 21483
// begin tmp := result ;
21410: LD_ADDR_VAR 0 9
21414: PUSH
21415: LD_VAR 0 6
21419: ST_TO_ADDR
// for i = tmp downto 1 do
21420: LD_ADDR_VAR 0 7
21424: PUSH
21425: DOUBLE
21426: LD_VAR 0 9
21430: INC
21431: ST_TO_ADDR
21432: LD_INT 1
21434: PUSH
21435: FOR_DOWNTO
21436: IFFALSE 21481
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21438: LD_ADDR_VAR 0 6
21442: PUSH
21443: LD_VAR 0 6
21447: PPUSH
21448: LD_VAR 0 9
21452: PUSH
21453: LD_VAR 0 7
21457: MINUS
21458: PUSH
21459: LD_INT 1
21461: PLUS
21462: PPUSH
21463: LD_VAR 0 9
21467: PUSH
21468: LD_VAR 0 7
21472: ARRAY
21473: PPUSH
21474: CALL_OW 1
21478: ST_TO_ADDR
21479: GO 21435
21481: POP
21482: POP
// end ; tmp := [ ] ;
21483: LD_ADDR_VAR 0 9
21487: PUSH
21488: EMPTY
21489: ST_TO_ADDR
// if mode then
21490: LD_VAR 0 5
21494: IFFALSE 21563
// begin for i = 1 to result do
21496: LD_ADDR_VAR 0 7
21500: PUSH
21501: DOUBLE
21502: LD_INT 1
21504: DEC
21505: ST_TO_ADDR
21506: LD_VAR 0 6
21510: PUSH
21511: FOR_TO
21512: IFFALSE 21551
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21514: LD_ADDR_VAR 0 9
21518: PUSH
21519: LD_VAR 0 9
21523: PPUSH
21524: LD_VAR 0 7
21528: PPUSH
21529: LD_VAR 0 6
21533: PUSH
21534: LD_VAR 0 7
21538: ARRAY
21539: PUSH
21540: LD_INT 1
21542: ARRAY
21543: PPUSH
21544: CALL_OW 1
21548: ST_TO_ADDR
21549: GO 21511
21551: POP
21552: POP
// result := tmp ;
21553: LD_ADDR_VAR 0 6
21557: PUSH
21558: LD_VAR 0 9
21562: ST_TO_ADDR
// end ; end ;
21563: LD_VAR 0 6
21567: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21568: LD_INT 0
21570: PPUSH
21571: PPUSH
21572: PPUSH
21573: PPUSH
21574: PPUSH
21575: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21576: LD_ADDR_VAR 0 5
21580: PUSH
21581: LD_INT 0
21583: PUSH
21584: LD_INT 0
21586: PUSH
21587: LD_INT 0
21589: PUSH
21590: EMPTY
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: LIST
21596: LIST
21597: ST_TO_ADDR
// if not x or not y then
21598: LD_VAR 0 2
21602: NOT
21603: PUSH
21604: LD_VAR 0 3
21608: NOT
21609: OR
21610: IFFALSE 21614
// exit ;
21612: GO 23260
// if not range then
21614: LD_VAR 0 4
21618: NOT
21619: IFFALSE 21629
// range := 10 ;
21621: LD_ADDR_VAR 0 4
21625: PUSH
21626: LD_INT 10
21628: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21629: LD_ADDR_VAR 0 8
21633: PUSH
21634: LD_INT 81
21636: PUSH
21637: LD_VAR 0 1
21641: PUSH
21642: EMPTY
21643: LIST
21644: LIST
21645: PUSH
21646: LD_INT 92
21648: PUSH
21649: LD_VAR 0 2
21653: PUSH
21654: LD_VAR 0 3
21658: PUSH
21659: LD_VAR 0 4
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: LIST
21669: PUSH
21670: LD_INT 3
21672: PUSH
21673: LD_INT 21
21675: PUSH
21676: LD_INT 3
21678: PUSH
21679: EMPTY
21680: LIST
21681: LIST
21682: PUSH
21683: EMPTY
21684: LIST
21685: LIST
21686: PUSH
21687: EMPTY
21688: LIST
21689: LIST
21690: LIST
21691: PPUSH
21692: CALL_OW 69
21696: ST_TO_ADDR
// if not tmp then
21697: LD_VAR 0 8
21701: NOT
21702: IFFALSE 21706
// exit ;
21704: GO 23260
// for i in tmp do
21706: LD_ADDR_VAR 0 6
21710: PUSH
21711: LD_VAR 0 8
21715: PUSH
21716: FOR_IN
21717: IFFALSE 23235
// begin points := [ 0 , 0 , 0 ] ;
21719: LD_ADDR_VAR 0 9
21723: PUSH
21724: LD_INT 0
21726: PUSH
21727: LD_INT 0
21729: PUSH
21730: LD_INT 0
21732: PUSH
21733: EMPTY
21734: LIST
21735: LIST
21736: LIST
21737: ST_TO_ADDR
// bpoints := 1 ;
21738: LD_ADDR_VAR 0 10
21742: PUSH
21743: LD_INT 1
21745: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21746: LD_VAR 0 6
21750: PPUSH
21751: CALL_OW 247
21755: PUSH
21756: LD_INT 1
21758: DOUBLE
21759: EQUAL
21760: IFTRUE 21764
21762: GO 22342
21764: POP
// begin if GetClass ( i ) = 1 then
21765: LD_VAR 0 6
21769: PPUSH
21770: CALL_OW 257
21774: PUSH
21775: LD_INT 1
21777: EQUAL
21778: IFFALSE 21799
// points := [ 10 , 5 , 3 ] ;
21780: LD_ADDR_VAR 0 9
21784: PUSH
21785: LD_INT 10
21787: PUSH
21788: LD_INT 5
21790: PUSH
21791: LD_INT 3
21793: PUSH
21794: EMPTY
21795: LIST
21796: LIST
21797: LIST
21798: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21799: LD_VAR 0 6
21803: PPUSH
21804: CALL_OW 257
21808: PUSH
21809: LD_INT 2
21811: PUSH
21812: LD_INT 3
21814: PUSH
21815: LD_INT 4
21817: PUSH
21818: EMPTY
21819: LIST
21820: LIST
21821: LIST
21822: IN
21823: IFFALSE 21844
// points := [ 3 , 2 , 1 ] ;
21825: LD_ADDR_VAR 0 9
21829: PUSH
21830: LD_INT 3
21832: PUSH
21833: LD_INT 2
21835: PUSH
21836: LD_INT 1
21838: PUSH
21839: EMPTY
21840: LIST
21841: LIST
21842: LIST
21843: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21844: LD_VAR 0 6
21848: PPUSH
21849: CALL_OW 257
21853: PUSH
21854: LD_INT 5
21856: EQUAL
21857: IFFALSE 21878
// points := [ 130 , 5 , 2 ] ;
21859: LD_ADDR_VAR 0 9
21863: PUSH
21864: LD_INT 130
21866: PUSH
21867: LD_INT 5
21869: PUSH
21870: LD_INT 2
21872: PUSH
21873: EMPTY
21874: LIST
21875: LIST
21876: LIST
21877: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21878: LD_VAR 0 6
21882: PPUSH
21883: CALL_OW 257
21887: PUSH
21888: LD_INT 8
21890: EQUAL
21891: IFFALSE 21912
// points := [ 35 , 35 , 30 ] ;
21893: LD_ADDR_VAR 0 9
21897: PUSH
21898: LD_INT 35
21900: PUSH
21901: LD_INT 35
21903: PUSH
21904: LD_INT 30
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: LIST
21911: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21912: LD_VAR 0 6
21916: PPUSH
21917: CALL_OW 257
21921: PUSH
21922: LD_INT 9
21924: EQUAL
21925: IFFALSE 21946
// points := [ 20 , 55 , 40 ] ;
21927: LD_ADDR_VAR 0 9
21931: PUSH
21932: LD_INT 20
21934: PUSH
21935: LD_INT 55
21937: PUSH
21938: LD_INT 40
21940: PUSH
21941: EMPTY
21942: LIST
21943: LIST
21944: LIST
21945: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21946: LD_VAR 0 6
21950: PPUSH
21951: CALL_OW 257
21955: PUSH
21956: LD_INT 12
21958: PUSH
21959: LD_INT 16
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: IN
21966: IFFALSE 21987
// points := [ 5 , 3 , 2 ] ;
21968: LD_ADDR_VAR 0 9
21972: PUSH
21973: LD_INT 5
21975: PUSH
21976: LD_INT 3
21978: PUSH
21979: LD_INT 2
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: LIST
21986: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21987: LD_VAR 0 6
21991: PPUSH
21992: CALL_OW 257
21996: PUSH
21997: LD_INT 17
21999: EQUAL
22000: IFFALSE 22021
// points := [ 100 , 50 , 75 ] ;
22002: LD_ADDR_VAR 0 9
22006: PUSH
22007: LD_INT 100
22009: PUSH
22010: LD_INT 50
22012: PUSH
22013: LD_INT 75
22015: PUSH
22016: EMPTY
22017: LIST
22018: LIST
22019: LIST
22020: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22021: LD_VAR 0 6
22025: PPUSH
22026: CALL_OW 257
22030: PUSH
22031: LD_INT 15
22033: EQUAL
22034: IFFALSE 22055
// points := [ 10 , 5 , 3 ] ;
22036: LD_ADDR_VAR 0 9
22040: PUSH
22041: LD_INT 10
22043: PUSH
22044: LD_INT 5
22046: PUSH
22047: LD_INT 3
22049: PUSH
22050: EMPTY
22051: LIST
22052: LIST
22053: LIST
22054: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22055: LD_VAR 0 6
22059: PPUSH
22060: CALL_OW 257
22064: PUSH
22065: LD_INT 14
22067: EQUAL
22068: IFFALSE 22089
// points := [ 10 , 0 , 0 ] ;
22070: LD_ADDR_VAR 0 9
22074: PUSH
22075: LD_INT 10
22077: PUSH
22078: LD_INT 0
22080: PUSH
22081: LD_INT 0
22083: PUSH
22084: EMPTY
22085: LIST
22086: LIST
22087: LIST
22088: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22089: LD_VAR 0 6
22093: PPUSH
22094: CALL_OW 257
22098: PUSH
22099: LD_INT 11
22101: EQUAL
22102: IFFALSE 22123
// points := [ 30 , 10 , 5 ] ;
22104: LD_ADDR_VAR 0 9
22108: PUSH
22109: LD_INT 30
22111: PUSH
22112: LD_INT 10
22114: PUSH
22115: LD_INT 5
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: LIST
22122: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22123: LD_VAR 0 1
22127: PPUSH
22128: LD_INT 5
22130: PPUSH
22131: CALL_OW 321
22135: PUSH
22136: LD_INT 2
22138: EQUAL
22139: IFFALSE 22156
// bpoints := bpoints * 1.8 ;
22141: LD_ADDR_VAR 0 10
22145: PUSH
22146: LD_VAR 0 10
22150: PUSH
22151: LD_REAL  1.80000000000000E+0000
22154: MUL
22155: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22156: LD_VAR 0 6
22160: PPUSH
22161: CALL_OW 257
22165: PUSH
22166: LD_INT 1
22168: PUSH
22169: LD_INT 2
22171: PUSH
22172: LD_INT 3
22174: PUSH
22175: LD_INT 4
22177: PUSH
22178: EMPTY
22179: LIST
22180: LIST
22181: LIST
22182: LIST
22183: IN
22184: PUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: LD_INT 51
22192: PPUSH
22193: CALL_OW 321
22197: PUSH
22198: LD_INT 2
22200: EQUAL
22201: AND
22202: IFFALSE 22219
// bpoints := bpoints * 1.2 ;
22204: LD_ADDR_VAR 0 10
22208: PUSH
22209: LD_VAR 0 10
22213: PUSH
22214: LD_REAL  1.20000000000000E+0000
22217: MUL
22218: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22219: LD_VAR 0 6
22223: PPUSH
22224: CALL_OW 257
22228: PUSH
22229: LD_INT 5
22231: PUSH
22232: LD_INT 7
22234: PUSH
22235: LD_INT 9
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: LIST
22242: IN
22243: PUSH
22244: LD_VAR 0 1
22248: PPUSH
22249: LD_INT 52
22251: PPUSH
22252: CALL_OW 321
22256: PUSH
22257: LD_INT 2
22259: EQUAL
22260: AND
22261: IFFALSE 22278
// bpoints := bpoints * 1.5 ;
22263: LD_ADDR_VAR 0 10
22267: PUSH
22268: LD_VAR 0 10
22272: PUSH
22273: LD_REAL  1.50000000000000E+0000
22276: MUL
22277: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22278: LD_VAR 0 1
22282: PPUSH
22283: LD_INT 66
22285: PPUSH
22286: CALL_OW 321
22290: PUSH
22291: LD_INT 2
22293: EQUAL
22294: IFFALSE 22311
// bpoints := bpoints * 1.1 ;
22296: LD_ADDR_VAR 0 10
22300: PUSH
22301: LD_VAR 0 10
22305: PUSH
22306: LD_REAL  1.10000000000000E+0000
22309: MUL
22310: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22311: LD_ADDR_VAR 0 10
22315: PUSH
22316: LD_VAR 0 10
22320: PUSH
22321: LD_VAR 0 6
22325: PPUSH
22326: LD_INT 1
22328: PPUSH
22329: CALL_OW 259
22333: PUSH
22334: LD_REAL  1.15000000000000E+0000
22337: MUL
22338: MUL
22339: ST_TO_ADDR
// end ; unit_vehicle :
22340: GO 23164
22342: LD_INT 2
22344: DOUBLE
22345: EQUAL
22346: IFTRUE 22350
22348: GO 23152
22350: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22351: LD_VAR 0 6
22355: PPUSH
22356: CALL_OW 264
22360: PUSH
22361: LD_INT 2
22363: PUSH
22364: LD_INT 42
22366: PUSH
22367: LD_INT 24
22369: PUSH
22370: EMPTY
22371: LIST
22372: LIST
22373: LIST
22374: IN
22375: IFFALSE 22396
// points := [ 25 , 5 , 3 ] ;
22377: LD_ADDR_VAR 0 9
22381: PUSH
22382: LD_INT 25
22384: PUSH
22385: LD_INT 5
22387: PUSH
22388: LD_INT 3
22390: PUSH
22391: EMPTY
22392: LIST
22393: LIST
22394: LIST
22395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22396: LD_VAR 0 6
22400: PPUSH
22401: CALL_OW 264
22405: PUSH
22406: LD_INT 4
22408: PUSH
22409: LD_INT 43
22411: PUSH
22412: LD_INT 25
22414: PUSH
22415: EMPTY
22416: LIST
22417: LIST
22418: LIST
22419: IN
22420: IFFALSE 22441
// points := [ 40 , 15 , 5 ] ;
22422: LD_ADDR_VAR 0 9
22426: PUSH
22427: LD_INT 40
22429: PUSH
22430: LD_INT 15
22432: PUSH
22433: LD_INT 5
22435: PUSH
22436: EMPTY
22437: LIST
22438: LIST
22439: LIST
22440: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22441: LD_VAR 0 6
22445: PPUSH
22446: CALL_OW 264
22450: PUSH
22451: LD_INT 3
22453: PUSH
22454: LD_INT 23
22456: PUSH
22457: EMPTY
22458: LIST
22459: LIST
22460: IN
22461: IFFALSE 22482
// points := [ 7 , 25 , 8 ] ;
22463: LD_ADDR_VAR 0 9
22467: PUSH
22468: LD_INT 7
22470: PUSH
22471: LD_INT 25
22473: PUSH
22474: LD_INT 8
22476: PUSH
22477: EMPTY
22478: LIST
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22482: LD_VAR 0 6
22486: PPUSH
22487: CALL_OW 264
22491: PUSH
22492: LD_INT 5
22494: PUSH
22495: LD_INT 27
22497: PUSH
22498: LD_INT 44
22500: PUSH
22501: EMPTY
22502: LIST
22503: LIST
22504: LIST
22505: IN
22506: IFFALSE 22527
// points := [ 14 , 50 , 16 ] ;
22508: LD_ADDR_VAR 0 9
22512: PUSH
22513: LD_INT 14
22515: PUSH
22516: LD_INT 50
22518: PUSH
22519: LD_INT 16
22521: PUSH
22522: EMPTY
22523: LIST
22524: LIST
22525: LIST
22526: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22527: LD_VAR 0 6
22531: PPUSH
22532: CALL_OW 264
22536: PUSH
22537: LD_INT 6
22539: PUSH
22540: LD_INT 46
22542: PUSH
22543: EMPTY
22544: LIST
22545: LIST
22546: IN
22547: IFFALSE 22568
// points := [ 32 , 120 , 70 ] ;
22549: LD_ADDR_VAR 0 9
22553: PUSH
22554: LD_INT 32
22556: PUSH
22557: LD_INT 120
22559: PUSH
22560: LD_INT 70
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: LIST
22567: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22568: LD_VAR 0 6
22572: PPUSH
22573: CALL_OW 264
22577: PUSH
22578: LD_INT 7
22580: PUSH
22581: LD_INT 28
22583: PUSH
22584: LD_INT 45
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: LIST
22591: IN
22592: IFFALSE 22613
// points := [ 35 , 20 , 45 ] ;
22594: LD_ADDR_VAR 0 9
22598: PUSH
22599: LD_INT 35
22601: PUSH
22602: LD_INT 20
22604: PUSH
22605: LD_INT 45
22607: PUSH
22608: EMPTY
22609: LIST
22610: LIST
22611: LIST
22612: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22613: LD_VAR 0 6
22617: PPUSH
22618: CALL_OW 264
22622: PUSH
22623: LD_INT 47
22625: PUSH
22626: EMPTY
22627: LIST
22628: IN
22629: IFFALSE 22650
// points := [ 67 , 45 , 75 ] ;
22631: LD_ADDR_VAR 0 9
22635: PUSH
22636: LD_INT 67
22638: PUSH
22639: LD_INT 45
22641: PUSH
22642: LD_INT 75
22644: PUSH
22645: EMPTY
22646: LIST
22647: LIST
22648: LIST
22649: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22650: LD_VAR 0 6
22654: PPUSH
22655: CALL_OW 264
22659: PUSH
22660: LD_INT 26
22662: PUSH
22663: EMPTY
22664: LIST
22665: IN
22666: IFFALSE 22687
// points := [ 120 , 30 , 80 ] ;
22668: LD_ADDR_VAR 0 9
22672: PUSH
22673: LD_INT 120
22675: PUSH
22676: LD_INT 30
22678: PUSH
22679: LD_INT 80
22681: PUSH
22682: EMPTY
22683: LIST
22684: LIST
22685: LIST
22686: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22687: LD_VAR 0 6
22691: PPUSH
22692: CALL_OW 264
22696: PUSH
22697: LD_INT 22
22699: PUSH
22700: EMPTY
22701: LIST
22702: IN
22703: IFFALSE 22724
// points := [ 40 , 1 , 1 ] ;
22705: LD_ADDR_VAR 0 9
22709: PUSH
22710: LD_INT 40
22712: PUSH
22713: LD_INT 1
22715: PUSH
22716: LD_INT 1
22718: PUSH
22719: EMPTY
22720: LIST
22721: LIST
22722: LIST
22723: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22724: LD_VAR 0 6
22728: PPUSH
22729: CALL_OW 264
22733: PUSH
22734: LD_INT 29
22736: PUSH
22737: EMPTY
22738: LIST
22739: IN
22740: IFFALSE 22761
// points := [ 70 , 200 , 400 ] ;
22742: LD_ADDR_VAR 0 9
22746: PUSH
22747: LD_INT 70
22749: PUSH
22750: LD_INT 200
22752: PUSH
22753: LD_INT 400
22755: PUSH
22756: EMPTY
22757: LIST
22758: LIST
22759: LIST
22760: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22761: LD_VAR 0 6
22765: PPUSH
22766: CALL_OW 264
22770: PUSH
22771: LD_INT 14
22773: PUSH
22774: LD_INT 53
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: IN
22781: IFFALSE 22802
// points := [ 40 , 10 , 20 ] ;
22783: LD_ADDR_VAR 0 9
22787: PUSH
22788: LD_INT 40
22790: PUSH
22791: LD_INT 10
22793: PUSH
22794: LD_INT 20
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: LIST
22801: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22802: LD_VAR 0 6
22806: PPUSH
22807: CALL_OW 264
22811: PUSH
22812: LD_INT 9
22814: PUSH
22815: EMPTY
22816: LIST
22817: IN
22818: IFFALSE 22839
// points := [ 5 , 70 , 20 ] ;
22820: LD_ADDR_VAR 0 9
22824: PUSH
22825: LD_INT 5
22827: PUSH
22828: LD_INT 70
22830: PUSH
22831: LD_INT 20
22833: PUSH
22834: EMPTY
22835: LIST
22836: LIST
22837: LIST
22838: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22839: LD_VAR 0 6
22843: PPUSH
22844: CALL_OW 264
22848: PUSH
22849: LD_INT 10
22851: PUSH
22852: EMPTY
22853: LIST
22854: IN
22855: IFFALSE 22876
// points := [ 35 , 110 , 70 ] ;
22857: LD_ADDR_VAR 0 9
22861: PUSH
22862: LD_INT 35
22864: PUSH
22865: LD_INT 110
22867: PUSH
22868: LD_INT 70
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: LIST
22875: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22876: LD_VAR 0 6
22880: PPUSH
22881: CALL_OW 265
22885: PUSH
22886: LD_INT 25
22888: EQUAL
22889: IFFALSE 22910
// points := [ 80 , 65 , 100 ] ;
22891: LD_ADDR_VAR 0 9
22895: PUSH
22896: LD_INT 80
22898: PUSH
22899: LD_INT 65
22901: PUSH
22902: LD_INT 100
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: LIST
22909: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22910: LD_VAR 0 6
22914: PPUSH
22915: CALL_OW 263
22919: PUSH
22920: LD_INT 1
22922: EQUAL
22923: IFFALSE 22958
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22925: LD_ADDR_VAR 0 10
22929: PUSH
22930: LD_VAR 0 10
22934: PUSH
22935: LD_VAR 0 6
22939: PPUSH
22940: CALL_OW 311
22944: PPUSH
22945: LD_INT 3
22947: PPUSH
22948: CALL_OW 259
22952: PUSH
22953: LD_INT 4
22955: MUL
22956: MUL
22957: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22958: LD_VAR 0 6
22962: PPUSH
22963: CALL_OW 263
22967: PUSH
22968: LD_INT 2
22970: EQUAL
22971: IFFALSE 23022
// begin j := IsControledBy ( i ) ;
22973: LD_ADDR_VAR 0 7
22977: PUSH
22978: LD_VAR 0 6
22982: PPUSH
22983: CALL_OW 312
22987: ST_TO_ADDR
// if j then
22988: LD_VAR 0 7
22992: IFFALSE 23022
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22994: LD_ADDR_VAR 0 10
22998: PUSH
22999: LD_VAR 0 10
23003: PUSH
23004: LD_VAR 0 7
23008: PPUSH
23009: LD_INT 3
23011: PPUSH
23012: CALL_OW 259
23016: PUSH
23017: LD_INT 3
23019: MUL
23020: MUL
23021: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23022: LD_VAR 0 6
23026: PPUSH
23027: CALL_OW 264
23031: PUSH
23032: LD_INT 5
23034: PUSH
23035: LD_INT 6
23037: PUSH
23038: LD_INT 46
23040: PUSH
23041: LD_INT 44
23043: PUSH
23044: LD_INT 47
23046: PUSH
23047: LD_INT 45
23049: PUSH
23050: LD_INT 28
23052: PUSH
23053: LD_INT 7
23055: PUSH
23056: LD_INT 27
23058: PUSH
23059: LD_INT 29
23061: PUSH
23062: EMPTY
23063: LIST
23064: LIST
23065: LIST
23066: LIST
23067: LIST
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: LIST
23073: IN
23074: PUSH
23075: LD_VAR 0 1
23079: PPUSH
23080: LD_INT 52
23082: PPUSH
23083: CALL_OW 321
23087: PUSH
23088: LD_INT 2
23090: EQUAL
23091: AND
23092: IFFALSE 23109
// bpoints := bpoints * 1.2 ;
23094: LD_ADDR_VAR 0 10
23098: PUSH
23099: LD_VAR 0 10
23103: PUSH
23104: LD_REAL  1.20000000000000E+0000
23107: MUL
23108: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23109: LD_VAR 0 6
23113: PPUSH
23114: CALL_OW 264
23118: PUSH
23119: LD_INT 6
23121: PUSH
23122: LD_INT 46
23124: PUSH
23125: LD_INT 47
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: LIST
23132: IN
23133: IFFALSE 23150
// bpoints := bpoints * 1.2 ;
23135: LD_ADDR_VAR 0 10
23139: PUSH
23140: LD_VAR 0 10
23144: PUSH
23145: LD_REAL  1.20000000000000E+0000
23148: MUL
23149: ST_TO_ADDR
// end ; unit_building :
23150: GO 23164
23152: LD_INT 3
23154: DOUBLE
23155: EQUAL
23156: IFTRUE 23160
23158: GO 23163
23160: POP
// ; end ;
23161: GO 23164
23163: POP
// for j = 1 to 3 do
23164: LD_ADDR_VAR 0 7
23168: PUSH
23169: DOUBLE
23170: LD_INT 1
23172: DEC
23173: ST_TO_ADDR
23174: LD_INT 3
23176: PUSH
23177: FOR_TO
23178: IFFALSE 23231
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23180: LD_ADDR_VAR 0 5
23184: PUSH
23185: LD_VAR 0 5
23189: PPUSH
23190: LD_VAR 0 7
23194: PPUSH
23195: LD_VAR 0 5
23199: PUSH
23200: LD_VAR 0 7
23204: ARRAY
23205: PUSH
23206: LD_VAR 0 9
23210: PUSH
23211: LD_VAR 0 7
23215: ARRAY
23216: PUSH
23217: LD_VAR 0 10
23221: MUL
23222: PLUS
23223: PPUSH
23224: CALL_OW 1
23228: ST_TO_ADDR
23229: GO 23177
23231: POP
23232: POP
// end ;
23233: GO 21716
23235: POP
23236: POP
// result := Replace ( result , 4 , tmp ) ;
23237: LD_ADDR_VAR 0 5
23241: PUSH
23242: LD_VAR 0 5
23246: PPUSH
23247: LD_INT 4
23249: PPUSH
23250: LD_VAR 0 8
23254: PPUSH
23255: CALL_OW 1
23259: ST_TO_ADDR
// end ;
23260: LD_VAR 0 5
23264: RET
// export function DangerAtRange ( unit , range ) ; begin
23265: LD_INT 0
23267: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23268: LD_ADDR_VAR 0 3
23272: PUSH
23273: LD_VAR 0 1
23277: PPUSH
23278: CALL_OW 255
23282: PPUSH
23283: LD_VAR 0 1
23287: PPUSH
23288: CALL_OW 250
23292: PPUSH
23293: LD_VAR 0 1
23297: PPUSH
23298: CALL_OW 251
23302: PPUSH
23303: LD_VAR 0 2
23307: PPUSH
23308: CALL 21568 0 4
23312: ST_TO_ADDR
// end ;
23313: LD_VAR 0 3
23317: RET
// export function DangerInArea ( side , area ) ; begin
23318: LD_INT 0
23320: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23321: LD_ADDR_VAR 0 3
23325: PUSH
23326: LD_VAR 0 2
23330: PPUSH
23331: LD_INT 81
23333: PUSH
23334: LD_VAR 0 1
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: PPUSH
23343: CALL_OW 70
23347: ST_TO_ADDR
// end ;
23348: LD_VAR 0 3
23352: RET
// export function IsExtension ( b ) ; begin
23353: LD_INT 0
23355: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23356: LD_ADDR_VAR 0 2
23360: PUSH
23361: LD_VAR 0 1
23365: PUSH
23366: LD_INT 23
23368: PUSH
23369: LD_INT 20
23371: PUSH
23372: LD_INT 22
23374: PUSH
23375: LD_INT 17
23377: PUSH
23378: LD_INT 24
23380: PUSH
23381: LD_INT 21
23383: PUSH
23384: LD_INT 19
23386: PUSH
23387: LD_INT 16
23389: PUSH
23390: LD_INT 25
23392: PUSH
23393: LD_INT 18
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: LIST
23400: LIST
23401: LIST
23402: LIST
23403: LIST
23404: LIST
23405: LIST
23406: LIST
23407: IN
23408: ST_TO_ADDR
// end ;
23409: LD_VAR 0 2
23413: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23414: LD_INT 0
23416: PPUSH
23417: PPUSH
23418: PPUSH
// result := [ ] ;
23419: LD_ADDR_VAR 0 3
23423: PUSH
23424: EMPTY
23425: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23426: LD_ADDR_VAR 0 4
23430: PUSH
23431: LD_VAR 0 2
23435: PPUSH
23436: LD_INT 21
23438: PUSH
23439: LD_INT 3
23441: PUSH
23442: EMPTY
23443: LIST
23444: LIST
23445: PPUSH
23446: CALL_OW 70
23450: ST_TO_ADDR
// if not tmp then
23451: LD_VAR 0 4
23455: NOT
23456: IFFALSE 23460
// exit ;
23458: GO 23518
// for i in tmp do
23460: LD_ADDR_VAR 0 5
23464: PUSH
23465: LD_VAR 0 4
23469: PUSH
23470: FOR_IN
23471: IFFALSE 23506
// if GetBase ( i ) <> base then
23473: LD_VAR 0 5
23477: PPUSH
23478: CALL_OW 274
23482: PUSH
23483: LD_VAR 0 1
23487: NONEQUAL
23488: IFFALSE 23504
// ComLinkToBase ( base , i ) ;
23490: LD_VAR 0 1
23494: PPUSH
23495: LD_VAR 0 5
23499: PPUSH
23500: CALL_OW 169
23504: GO 23470
23506: POP
23507: POP
// result := tmp ;
23508: LD_ADDR_VAR 0 3
23512: PUSH
23513: LD_VAR 0 4
23517: ST_TO_ADDR
// end ;
23518: LD_VAR 0 3
23522: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23523: LD_INT 0
23525: PPUSH
23526: PPUSH
// if BuildingStatus ( b ) = bs_build then
23527: LD_VAR 0 2
23531: PPUSH
23532: CALL_OW 461
23536: PUSH
23537: LD_INT 1
23539: EQUAL
23540: IFFALSE 23600
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23542: LD_VAR 0 1
23546: PPUSH
23547: LD_STRING h
23549: PUSH
23550: LD_VAR 0 2
23554: PPUSH
23555: CALL_OW 250
23559: PUSH
23560: LD_VAR 0 2
23564: PPUSH
23565: CALL_OW 251
23569: PUSH
23570: LD_VAR 0 2
23574: PUSH
23575: LD_INT 0
23577: PUSH
23578: LD_INT 0
23580: PUSH
23581: LD_INT 0
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: LIST
23588: LIST
23589: LIST
23590: LIST
23591: LIST
23592: PUSH
23593: EMPTY
23594: LIST
23595: PPUSH
23596: CALL_OW 446
// end ;
23600: LD_VAR 0 3
23604: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23605: LD_INT 0
23607: PPUSH
23608: PPUSH
23609: PPUSH
23610: PPUSH
23611: PPUSH
23612: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23613: LD_VAR 0 1
23617: NOT
23618: PUSH
23619: LD_VAR 0 1
23623: PPUSH
23624: CALL_OW 263
23628: PUSH
23629: LD_INT 2
23631: EQUAL
23632: NOT
23633: OR
23634: IFFALSE 23638
// exit ;
23636: GO 23954
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23638: LD_ADDR_VAR 0 6
23642: PUSH
23643: LD_INT 22
23645: PUSH
23646: LD_VAR 0 1
23650: PPUSH
23651: CALL_OW 255
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 2
23662: PUSH
23663: LD_INT 30
23665: PUSH
23666: LD_INT 36
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PUSH
23673: LD_INT 34
23675: PUSH
23676: LD_INT 31
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: EMPTY
23684: LIST
23685: LIST
23686: LIST
23687: PUSH
23688: EMPTY
23689: LIST
23690: LIST
23691: PPUSH
23692: CALL_OW 69
23696: ST_TO_ADDR
// if not tmp then
23697: LD_VAR 0 6
23701: NOT
23702: IFFALSE 23706
// exit ;
23704: GO 23954
// result := [ ] ;
23706: LD_ADDR_VAR 0 2
23710: PUSH
23711: EMPTY
23712: ST_TO_ADDR
// for i in tmp do
23713: LD_ADDR_VAR 0 3
23717: PUSH
23718: LD_VAR 0 6
23722: PUSH
23723: FOR_IN
23724: IFFALSE 23795
// begin t := UnitsInside ( i ) ;
23726: LD_ADDR_VAR 0 4
23730: PUSH
23731: LD_VAR 0 3
23735: PPUSH
23736: CALL_OW 313
23740: ST_TO_ADDR
// if t then
23741: LD_VAR 0 4
23745: IFFALSE 23793
// for j in t do
23747: LD_ADDR_VAR 0 7
23751: PUSH
23752: LD_VAR 0 4
23756: PUSH
23757: FOR_IN
23758: IFFALSE 23791
// result := Insert ( result , result + 1 , j ) ;
23760: LD_ADDR_VAR 0 2
23764: PUSH
23765: LD_VAR 0 2
23769: PPUSH
23770: LD_VAR 0 2
23774: PUSH
23775: LD_INT 1
23777: PLUS
23778: PPUSH
23779: LD_VAR 0 7
23783: PPUSH
23784: CALL_OW 2
23788: ST_TO_ADDR
23789: GO 23757
23791: POP
23792: POP
// end ;
23793: GO 23723
23795: POP
23796: POP
// if not result then
23797: LD_VAR 0 2
23801: NOT
23802: IFFALSE 23806
// exit ;
23804: GO 23954
// mech := result [ 1 ] ;
23806: LD_ADDR_VAR 0 5
23810: PUSH
23811: LD_VAR 0 2
23815: PUSH
23816: LD_INT 1
23818: ARRAY
23819: ST_TO_ADDR
// if result > 1 then
23820: LD_VAR 0 2
23824: PUSH
23825: LD_INT 1
23827: GREATER
23828: IFFALSE 23940
// for i = 2 to result do
23830: LD_ADDR_VAR 0 3
23834: PUSH
23835: DOUBLE
23836: LD_INT 2
23838: DEC
23839: ST_TO_ADDR
23840: LD_VAR 0 2
23844: PUSH
23845: FOR_TO
23846: IFFALSE 23938
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23848: LD_ADDR_VAR 0 4
23852: PUSH
23853: LD_VAR 0 2
23857: PUSH
23858: LD_VAR 0 3
23862: ARRAY
23863: PPUSH
23864: LD_INT 3
23866: PPUSH
23867: CALL_OW 259
23871: PUSH
23872: LD_VAR 0 2
23876: PUSH
23877: LD_VAR 0 3
23881: ARRAY
23882: PPUSH
23883: CALL_OW 432
23887: MINUS
23888: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23889: LD_VAR 0 4
23893: PUSH
23894: LD_VAR 0 5
23898: PPUSH
23899: LD_INT 3
23901: PPUSH
23902: CALL_OW 259
23906: PUSH
23907: LD_VAR 0 5
23911: PPUSH
23912: CALL_OW 432
23916: MINUS
23917: GREATEREQUAL
23918: IFFALSE 23936
// mech := result [ i ] ;
23920: LD_ADDR_VAR 0 5
23924: PUSH
23925: LD_VAR 0 2
23929: PUSH
23930: LD_VAR 0 3
23934: ARRAY
23935: ST_TO_ADDR
// end ;
23936: GO 23845
23938: POP
23939: POP
// ComLinkTo ( vehicle , mech ) ;
23940: LD_VAR 0 1
23944: PPUSH
23945: LD_VAR 0 5
23949: PPUSH
23950: CALL_OW 135
// end ;
23954: LD_VAR 0 2
23958: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23959: LD_INT 0
23961: PPUSH
23962: PPUSH
23963: PPUSH
23964: PPUSH
23965: PPUSH
23966: PPUSH
23967: PPUSH
23968: PPUSH
23969: PPUSH
23970: PPUSH
23971: PPUSH
23972: PPUSH
23973: PPUSH
// result := [ ] ;
23974: LD_ADDR_VAR 0 7
23978: PUSH
23979: EMPTY
23980: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23981: LD_VAR 0 1
23985: PPUSH
23986: CALL_OW 266
23990: PUSH
23991: LD_INT 0
23993: PUSH
23994: LD_INT 1
23996: PUSH
23997: EMPTY
23998: LIST
23999: LIST
24000: IN
24001: NOT
24002: IFFALSE 24006
// exit ;
24004: GO 25637
// if name then
24006: LD_VAR 0 3
24010: IFFALSE 24026
// SetBName ( base_dep , name ) ;
24012: LD_VAR 0 1
24016: PPUSH
24017: LD_VAR 0 3
24021: PPUSH
24022: CALL_OW 500
// base := GetBase ( base_dep ) ;
24026: LD_ADDR_VAR 0 15
24030: PUSH
24031: LD_VAR 0 1
24035: PPUSH
24036: CALL_OW 274
24040: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24041: LD_ADDR_VAR 0 16
24045: PUSH
24046: LD_VAR 0 1
24050: PPUSH
24051: CALL_OW 255
24055: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24056: LD_ADDR_VAR 0 17
24060: PUSH
24061: LD_VAR 0 1
24065: PPUSH
24066: CALL_OW 248
24070: ST_TO_ADDR
// if sources then
24071: LD_VAR 0 5
24075: IFFALSE 24122
// for i = 1 to 3 do
24077: LD_ADDR_VAR 0 8
24081: PUSH
24082: DOUBLE
24083: LD_INT 1
24085: DEC
24086: ST_TO_ADDR
24087: LD_INT 3
24089: PUSH
24090: FOR_TO
24091: IFFALSE 24120
// AddResourceType ( base , i , sources [ i ] ) ;
24093: LD_VAR 0 15
24097: PPUSH
24098: LD_VAR 0 8
24102: PPUSH
24103: LD_VAR 0 5
24107: PUSH
24108: LD_VAR 0 8
24112: ARRAY
24113: PPUSH
24114: CALL_OW 276
24118: GO 24090
24120: POP
24121: POP
// buildings := GetBaseBuildings ( base , area ) ;
24122: LD_ADDR_VAR 0 18
24126: PUSH
24127: LD_VAR 0 15
24131: PPUSH
24132: LD_VAR 0 2
24136: PPUSH
24137: CALL 23414 0 2
24141: ST_TO_ADDR
// InitHc ;
24142: CALL_OW 19
// InitUc ;
24146: CALL_OW 18
// uc_side := side ;
24150: LD_ADDR_OWVAR 20
24154: PUSH
24155: LD_VAR 0 16
24159: ST_TO_ADDR
// uc_nation := nation ;
24160: LD_ADDR_OWVAR 21
24164: PUSH
24165: LD_VAR 0 17
24169: ST_TO_ADDR
// if buildings then
24170: LD_VAR 0 18
24174: IFFALSE 25496
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24176: LD_ADDR_VAR 0 19
24180: PUSH
24181: LD_VAR 0 18
24185: PPUSH
24186: LD_INT 2
24188: PUSH
24189: LD_INT 30
24191: PUSH
24192: LD_INT 29
24194: PUSH
24195: EMPTY
24196: LIST
24197: LIST
24198: PUSH
24199: LD_INT 30
24201: PUSH
24202: LD_INT 30
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: EMPTY
24210: LIST
24211: LIST
24212: LIST
24213: PPUSH
24214: CALL_OW 72
24218: ST_TO_ADDR
// if tmp then
24219: LD_VAR 0 19
24223: IFFALSE 24271
// for i in tmp do
24225: LD_ADDR_VAR 0 8
24229: PUSH
24230: LD_VAR 0 19
24234: PUSH
24235: FOR_IN
24236: IFFALSE 24269
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24238: LD_VAR 0 8
24242: PPUSH
24243: CALL_OW 250
24247: PPUSH
24248: LD_VAR 0 8
24252: PPUSH
24253: CALL_OW 251
24257: PPUSH
24258: LD_VAR 0 16
24262: PPUSH
24263: CALL_OW 441
24267: GO 24235
24269: POP
24270: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24271: LD_VAR 0 18
24275: PPUSH
24276: LD_INT 2
24278: PUSH
24279: LD_INT 30
24281: PUSH
24282: LD_INT 32
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: PUSH
24289: LD_INT 30
24291: PUSH
24292: LD_INT 33
24294: PUSH
24295: EMPTY
24296: LIST
24297: LIST
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: LIST
24303: PPUSH
24304: CALL_OW 72
24308: IFFALSE 24396
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24310: LD_ADDR_VAR 0 8
24314: PUSH
24315: LD_VAR 0 18
24319: PPUSH
24320: LD_INT 2
24322: PUSH
24323: LD_INT 30
24325: PUSH
24326: LD_INT 32
24328: PUSH
24329: EMPTY
24330: LIST
24331: LIST
24332: PUSH
24333: LD_INT 30
24335: PUSH
24336: LD_INT 33
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: PUSH
24343: EMPTY
24344: LIST
24345: LIST
24346: LIST
24347: PPUSH
24348: CALL_OW 72
24352: PUSH
24353: FOR_IN
24354: IFFALSE 24394
// begin if not GetBWeapon ( i ) then
24356: LD_VAR 0 8
24360: PPUSH
24361: CALL_OW 269
24365: NOT
24366: IFFALSE 24392
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24368: LD_VAR 0 8
24372: PPUSH
24373: LD_VAR 0 8
24377: PPUSH
24378: LD_VAR 0 2
24382: PPUSH
24383: CALL 25642 0 2
24387: PPUSH
24388: CALL_OW 431
// end ;
24392: GO 24353
24394: POP
24395: POP
// end ; for i = 1 to personel do
24396: LD_ADDR_VAR 0 8
24400: PUSH
24401: DOUBLE
24402: LD_INT 1
24404: DEC
24405: ST_TO_ADDR
24406: LD_VAR 0 6
24410: PUSH
24411: FOR_TO
24412: IFFALSE 25476
// begin if i > 4 then
24414: LD_VAR 0 8
24418: PUSH
24419: LD_INT 4
24421: GREATER
24422: IFFALSE 24426
// break ;
24424: GO 25476
// case i of 1 :
24426: LD_VAR 0 8
24430: PUSH
24431: LD_INT 1
24433: DOUBLE
24434: EQUAL
24435: IFTRUE 24439
24437: GO 24519
24439: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24440: LD_ADDR_VAR 0 12
24444: PUSH
24445: LD_VAR 0 18
24449: PPUSH
24450: LD_INT 22
24452: PUSH
24453: LD_VAR 0 16
24457: PUSH
24458: EMPTY
24459: LIST
24460: LIST
24461: PUSH
24462: LD_INT 58
24464: PUSH
24465: EMPTY
24466: LIST
24467: PUSH
24468: LD_INT 2
24470: PUSH
24471: LD_INT 30
24473: PUSH
24474: LD_INT 32
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: LD_INT 30
24483: PUSH
24484: LD_INT 4
24486: PUSH
24487: EMPTY
24488: LIST
24489: LIST
24490: PUSH
24491: LD_INT 30
24493: PUSH
24494: LD_INT 5
24496: PUSH
24497: EMPTY
24498: LIST
24499: LIST
24500: PUSH
24501: EMPTY
24502: LIST
24503: LIST
24504: LIST
24505: LIST
24506: PUSH
24507: EMPTY
24508: LIST
24509: LIST
24510: LIST
24511: PPUSH
24512: CALL_OW 72
24516: ST_TO_ADDR
24517: GO 24741
24519: LD_INT 2
24521: DOUBLE
24522: EQUAL
24523: IFTRUE 24527
24525: GO 24589
24527: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24528: LD_ADDR_VAR 0 12
24532: PUSH
24533: LD_VAR 0 18
24537: PPUSH
24538: LD_INT 22
24540: PUSH
24541: LD_VAR 0 16
24545: PUSH
24546: EMPTY
24547: LIST
24548: LIST
24549: PUSH
24550: LD_INT 2
24552: PUSH
24553: LD_INT 30
24555: PUSH
24556: LD_INT 0
24558: PUSH
24559: EMPTY
24560: LIST
24561: LIST
24562: PUSH
24563: LD_INT 30
24565: PUSH
24566: LD_INT 1
24568: PUSH
24569: EMPTY
24570: LIST
24571: LIST
24572: PUSH
24573: EMPTY
24574: LIST
24575: LIST
24576: LIST
24577: PUSH
24578: EMPTY
24579: LIST
24580: LIST
24581: PPUSH
24582: CALL_OW 72
24586: ST_TO_ADDR
24587: GO 24741
24589: LD_INT 3
24591: DOUBLE
24592: EQUAL
24593: IFTRUE 24597
24595: GO 24659
24597: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24598: LD_ADDR_VAR 0 12
24602: PUSH
24603: LD_VAR 0 18
24607: PPUSH
24608: LD_INT 22
24610: PUSH
24611: LD_VAR 0 16
24615: PUSH
24616: EMPTY
24617: LIST
24618: LIST
24619: PUSH
24620: LD_INT 2
24622: PUSH
24623: LD_INT 30
24625: PUSH
24626: LD_INT 2
24628: PUSH
24629: EMPTY
24630: LIST
24631: LIST
24632: PUSH
24633: LD_INT 30
24635: PUSH
24636: LD_INT 3
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: PUSH
24643: EMPTY
24644: LIST
24645: LIST
24646: LIST
24647: PUSH
24648: EMPTY
24649: LIST
24650: LIST
24651: PPUSH
24652: CALL_OW 72
24656: ST_TO_ADDR
24657: GO 24741
24659: LD_INT 4
24661: DOUBLE
24662: EQUAL
24663: IFTRUE 24667
24665: GO 24740
24667: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24668: LD_ADDR_VAR 0 12
24672: PUSH
24673: LD_VAR 0 18
24677: PPUSH
24678: LD_INT 22
24680: PUSH
24681: LD_VAR 0 16
24685: PUSH
24686: EMPTY
24687: LIST
24688: LIST
24689: PUSH
24690: LD_INT 2
24692: PUSH
24693: LD_INT 30
24695: PUSH
24696: LD_INT 6
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PUSH
24703: LD_INT 30
24705: PUSH
24706: LD_INT 7
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: PUSH
24713: LD_INT 30
24715: PUSH
24716: LD_INT 8
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: LIST
24727: LIST
24728: PUSH
24729: EMPTY
24730: LIST
24731: LIST
24732: PPUSH
24733: CALL_OW 72
24737: ST_TO_ADDR
24738: GO 24741
24740: POP
// if i = 1 then
24741: LD_VAR 0 8
24745: PUSH
24746: LD_INT 1
24748: EQUAL
24749: IFFALSE 24860
// begin tmp := [ ] ;
24751: LD_ADDR_VAR 0 19
24755: PUSH
24756: EMPTY
24757: ST_TO_ADDR
// for j in f do
24758: LD_ADDR_VAR 0 9
24762: PUSH
24763: LD_VAR 0 12
24767: PUSH
24768: FOR_IN
24769: IFFALSE 24842
// if GetBType ( j ) = b_bunker then
24771: LD_VAR 0 9
24775: PPUSH
24776: CALL_OW 266
24780: PUSH
24781: LD_INT 32
24783: EQUAL
24784: IFFALSE 24811
// tmp := Insert ( tmp , 1 , j ) else
24786: LD_ADDR_VAR 0 19
24790: PUSH
24791: LD_VAR 0 19
24795: PPUSH
24796: LD_INT 1
24798: PPUSH
24799: LD_VAR 0 9
24803: PPUSH
24804: CALL_OW 2
24808: ST_TO_ADDR
24809: GO 24840
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24811: LD_ADDR_VAR 0 19
24815: PUSH
24816: LD_VAR 0 19
24820: PPUSH
24821: LD_VAR 0 19
24825: PUSH
24826: LD_INT 1
24828: PLUS
24829: PPUSH
24830: LD_VAR 0 9
24834: PPUSH
24835: CALL_OW 2
24839: ST_TO_ADDR
24840: GO 24768
24842: POP
24843: POP
// if tmp then
24844: LD_VAR 0 19
24848: IFFALSE 24860
// f := tmp ;
24850: LD_ADDR_VAR 0 12
24854: PUSH
24855: LD_VAR 0 19
24859: ST_TO_ADDR
// end ; x := personel [ i ] ;
24860: LD_ADDR_VAR 0 13
24864: PUSH
24865: LD_VAR 0 6
24869: PUSH
24870: LD_VAR 0 8
24874: ARRAY
24875: ST_TO_ADDR
// if x = - 1 then
24876: LD_VAR 0 13
24880: PUSH
24881: LD_INT 1
24883: NEG
24884: EQUAL
24885: IFFALSE 25094
// begin for j in f do
24887: LD_ADDR_VAR 0 9
24891: PUSH
24892: LD_VAR 0 12
24896: PUSH
24897: FOR_IN
24898: IFFALSE 25090
// repeat InitHc ;
24900: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24904: LD_VAR 0 9
24908: PPUSH
24909: CALL_OW 266
24913: PUSH
24914: LD_INT 5
24916: EQUAL
24917: IFFALSE 24987
// begin if UnitsInside ( j ) < 3 then
24919: LD_VAR 0 9
24923: PPUSH
24924: CALL_OW 313
24928: PUSH
24929: LD_INT 3
24931: LESS
24932: IFFALSE 24968
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24934: LD_INT 0
24936: PPUSH
24937: LD_INT 5
24939: PUSH
24940: LD_INT 8
24942: PUSH
24943: LD_INT 9
24945: PUSH
24946: EMPTY
24947: LIST
24948: LIST
24949: LIST
24950: PUSH
24951: LD_VAR 0 17
24955: ARRAY
24956: PPUSH
24957: LD_VAR 0 4
24961: PPUSH
24962: CALL_OW 380
24966: GO 24985
// PrepareHuman ( false , i , skill ) ;
24968: LD_INT 0
24970: PPUSH
24971: LD_VAR 0 8
24975: PPUSH
24976: LD_VAR 0 4
24980: PPUSH
24981: CALL_OW 380
// end else
24985: GO 25004
// PrepareHuman ( false , i , skill ) ;
24987: LD_INT 0
24989: PPUSH
24990: LD_VAR 0 8
24994: PPUSH
24995: LD_VAR 0 4
24999: PPUSH
25000: CALL_OW 380
// un := CreateHuman ;
25004: LD_ADDR_VAR 0 14
25008: PUSH
25009: CALL_OW 44
25013: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25014: LD_ADDR_VAR 0 7
25018: PUSH
25019: LD_VAR 0 7
25023: PPUSH
25024: LD_INT 1
25026: PPUSH
25027: LD_VAR 0 14
25031: PPUSH
25032: CALL_OW 2
25036: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25037: LD_VAR 0 14
25041: PPUSH
25042: LD_VAR 0 9
25046: PPUSH
25047: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25051: LD_VAR 0 9
25055: PPUSH
25056: CALL_OW 313
25060: PUSH
25061: LD_INT 6
25063: EQUAL
25064: PUSH
25065: LD_VAR 0 9
25069: PPUSH
25070: CALL_OW 266
25074: PUSH
25075: LD_INT 32
25077: PUSH
25078: LD_INT 31
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: IN
25085: OR
25086: IFFALSE 24900
25088: GO 24897
25090: POP
25091: POP
// end else
25092: GO 25474
// for j = 1 to x do
25094: LD_ADDR_VAR 0 9
25098: PUSH
25099: DOUBLE
25100: LD_INT 1
25102: DEC
25103: ST_TO_ADDR
25104: LD_VAR 0 13
25108: PUSH
25109: FOR_TO
25110: IFFALSE 25472
// begin InitHc ;
25112: CALL_OW 19
// if not f then
25116: LD_VAR 0 12
25120: NOT
25121: IFFALSE 25210
// begin PrepareHuman ( false , i , skill ) ;
25123: LD_INT 0
25125: PPUSH
25126: LD_VAR 0 8
25130: PPUSH
25131: LD_VAR 0 4
25135: PPUSH
25136: CALL_OW 380
// un := CreateHuman ;
25140: LD_ADDR_VAR 0 14
25144: PUSH
25145: CALL_OW 44
25149: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25150: LD_ADDR_VAR 0 7
25154: PUSH
25155: LD_VAR 0 7
25159: PPUSH
25160: LD_INT 1
25162: PPUSH
25163: LD_VAR 0 14
25167: PPUSH
25168: CALL_OW 2
25172: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25173: LD_VAR 0 14
25177: PPUSH
25178: LD_VAR 0 1
25182: PPUSH
25183: CALL_OW 250
25187: PPUSH
25188: LD_VAR 0 1
25192: PPUSH
25193: CALL_OW 251
25197: PPUSH
25198: LD_INT 10
25200: PPUSH
25201: LD_INT 0
25203: PPUSH
25204: CALL_OW 50
// continue ;
25208: GO 25109
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25210: LD_VAR 0 12
25214: PUSH
25215: LD_INT 1
25217: ARRAY
25218: PPUSH
25219: CALL_OW 313
25223: PUSH
25224: LD_VAR 0 12
25228: PUSH
25229: LD_INT 1
25231: ARRAY
25232: PPUSH
25233: CALL_OW 266
25237: PUSH
25238: LD_INT 32
25240: PUSH
25241: LD_INT 31
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: IN
25248: AND
25249: PUSH
25250: LD_VAR 0 12
25254: PUSH
25255: LD_INT 1
25257: ARRAY
25258: PPUSH
25259: CALL_OW 313
25263: PUSH
25264: LD_INT 6
25266: EQUAL
25267: OR
25268: IFFALSE 25288
// f := Delete ( f , 1 ) ;
25270: LD_ADDR_VAR 0 12
25274: PUSH
25275: LD_VAR 0 12
25279: PPUSH
25280: LD_INT 1
25282: PPUSH
25283: CALL_OW 3
25287: ST_TO_ADDR
// if not f then
25288: LD_VAR 0 12
25292: NOT
25293: IFFALSE 25311
// begin x := x + 2 ;
25295: LD_ADDR_VAR 0 13
25299: PUSH
25300: LD_VAR 0 13
25304: PUSH
25305: LD_INT 2
25307: PLUS
25308: ST_TO_ADDR
// continue ;
25309: GO 25109
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25311: LD_VAR 0 12
25315: PUSH
25316: LD_INT 1
25318: ARRAY
25319: PPUSH
25320: CALL_OW 266
25324: PUSH
25325: LD_INT 5
25327: EQUAL
25328: IFFALSE 25402
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25330: LD_VAR 0 12
25334: PUSH
25335: LD_INT 1
25337: ARRAY
25338: PPUSH
25339: CALL_OW 313
25343: PUSH
25344: LD_INT 3
25346: LESS
25347: IFFALSE 25383
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25349: LD_INT 0
25351: PPUSH
25352: LD_INT 5
25354: PUSH
25355: LD_INT 8
25357: PUSH
25358: LD_INT 9
25360: PUSH
25361: EMPTY
25362: LIST
25363: LIST
25364: LIST
25365: PUSH
25366: LD_VAR 0 17
25370: ARRAY
25371: PPUSH
25372: LD_VAR 0 4
25376: PPUSH
25377: CALL_OW 380
25381: GO 25400
// PrepareHuman ( false , i , skill ) ;
25383: LD_INT 0
25385: PPUSH
25386: LD_VAR 0 8
25390: PPUSH
25391: LD_VAR 0 4
25395: PPUSH
25396: CALL_OW 380
// end else
25400: GO 25419
// PrepareHuman ( false , i , skill ) ;
25402: LD_INT 0
25404: PPUSH
25405: LD_VAR 0 8
25409: PPUSH
25410: LD_VAR 0 4
25414: PPUSH
25415: CALL_OW 380
// un := CreateHuman ;
25419: LD_ADDR_VAR 0 14
25423: PUSH
25424: CALL_OW 44
25428: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25429: LD_ADDR_VAR 0 7
25433: PUSH
25434: LD_VAR 0 7
25438: PPUSH
25439: LD_INT 1
25441: PPUSH
25442: LD_VAR 0 14
25446: PPUSH
25447: CALL_OW 2
25451: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25452: LD_VAR 0 14
25456: PPUSH
25457: LD_VAR 0 12
25461: PUSH
25462: LD_INT 1
25464: ARRAY
25465: PPUSH
25466: CALL_OW 52
// end ;
25470: GO 25109
25472: POP
25473: POP
// end ;
25474: GO 24411
25476: POP
25477: POP
// result := result ^ buildings ;
25478: LD_ADDR_VAR 0 7
25482: PUSH
25483: LD_VAR 0 7
25487: PUSH
25488: LD_VAR 0 18
25492: ADD
25493: ST_TO_ADDR
// end else
25494: GO 25637
// begin for i = 1 to personel do
25496: LD_ADDR_VAR 0 8
25500: PUSH
25501: DOUBLE
25502: LD_INT 1
25504: DEC
25505: ST_TO_ADDR
25506: LD_VAR 0 6
25510: PUSH
25511: FOR_TO
25512: IFFALSE 25635
// begin if i > 4 then
25514: LD_VAR 0 8
25518: PUSH
25519: LD_INT 4
25521: GREATER
25522: IFFALSE 25526
// break ;
25524: GO 25635
// x := personel [ i ] ;
25526: LD_ADDR_VAR 0 13
25530: PUSH
25531: LD_VAR 0 6
25535: PUSH
25536: LD_VAR 0 8
25540: ARRAY
25541: ST_TO_ADDR
// if x = - 1 then
25542: LD_VAR 0 13
25546: PUSH
25547: LD_INT 1
25549: NEG
25550: EQUAL
25551: IFFALSE 25555
// continue ;
25553: GO 25511
// PrepareHuman ( false , i , skill ) ;
25555: LD_INT 0
25557: PPUSH
25558: LD_VAR 0 8
25562: PPUSH
25563: LD_VAR 0 4
25567: PPUSH
25568: CALL_OW 380
// un := CreateHuman ;
25572: LD_ADDR_VAR 0 14
25576: PUSH
25577: CALL_OW 44
25581: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25582: LD_VAR 0 14
25586: PPUSH
25587: LD_VAR 0 1
25591: PPUSH
25592: CALL_OW 250
25596: PPUSH
25597: LD_VAR 0 1
25601: PPUSH
25602: CALL_OW 251
25606: PPUSH
25607: LD_INT 10
25609: PPUSH
25610: LD_INT 0
25612: PPUSH
25613: CALL_OW 50
// result := result ^ un ;
25617: LD_ADDR_VAR 0 7
25621: PUSH
25622: LD_VAR 0 7
25626: PUSH
25627: LD_VAR 0 14
25631: ADD
25632: ST_TO_ADDR
// end ;
25633: GO 25511
25635: POP
25636: POP
// end ; end ;
25637: LD_VAR 0 7
25641: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25642: LD_INT 0
25644: PPUSH
25645: PPUSH
25646: PPUSH
25647: PPUSH
25648: PPUSH
25649: PPUSH
25650: PPUSH
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
25655: PPUSH
25656: PPUSH
25657: PPUSH
25658: PPUSH
25659: PPUSH
// result := false ;
25660: LD_ADDR_VAR 0 3
25664: PUSH
25665: LD_INT 0
25667: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25668: LD_VAR 0 1
25672: NOT
25673: PUSH
25674: LD_VAR 0 1
25678: PPUSH
25679: CALL_OW 266
25683: PUSH
25684: LD_INT 32
25686: PUSH
25687: LD_INT 33
25689: PUSH
25690: EMPTY
25691: LIST
25692: LIST
25693: IN
25694: NOT
25695: OR
25696: IFFALSE 25700
// exit ;
25698: GO 26836
// nat := GetNation ( tower ) ;
25700: LD_ADDR_VAR 0 12
25704: PUSH
25705: LD_VAR 0 1
25709: PPUSH
25710: CALL_OW 248
25714: ST_TO_ADDR
// side := GetSide ( tower ) ;
25715: LD_ADDR_VAR 0 16
25719: PUSH
25720: LD_VAR 0 1
25724: PPUSH
25725: CALL_OW 255
25729: ST_TO_ADDR
// x := GetX ( tower ) ;
25730: LD_ADDR_VAR 0 10
25734: PUSH
25735: LD_VAR 0 1
25739: PPUSH
25740: CALL_OW 250
25744: ST_TO_ADDR
// y := GetY ( tower ) ;
25745: LD_ADDR_VAR 0 11
25749: PUSH
25750: LD_VAR 0 1
25754: PPUSH
25755: CALL_OW 251
25759: ST_TO_ADDR
// if not x or not y then
25760: LD_VAR 0 10
25764: NOT
25765: PUSH
25766: LD_VAR 0 11
25770: NOT
25771: OR
25772: IFFALSE 25776
// exit ;
25774: GO 26836
// weapon := 0 ;
25776: LD_ADDR_VAR 0 18
25780: PUSH
25781: LD_INT 0
25783: ST_TO_ADDR
// fac_list := [ ] ;
25784: LD_ADDR_VAR 0 17
25788: PUSH
25789: EMPTY
25790: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25791: LD_ADDR_VAR 0 6
25795: PUSH
25796: LD_VAR 0 1
25800: PPUSH
25801: CALL_OW 274
25805: PPUSH
25806: LD_VAR 0 2
25810: PPUSH
25811: CALL 23414 0 2
25815: PPUSH
25816: LD_INT 30
25818: PUSH
25819: LD_INT 3
25821: PUSH
25822: EMPTY
25823: LIST
25824: LIST
25825: PPUSH
25826: CALL_OW 72
25830: ST_TO_ADDR
// if not factories then
25831: LD_VAR 0 6
25835: NOT
25836: IFFALSE 25840
// exit ;
25838: GO 26836
// for i in factories do
25840: LD_ADDR_VAR 0 8
25844: PUSH
25845: LD_VAR 0 6
25849: PUSH
25850: FOR_IN
25851: IFFALSE 25876
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25853: LD_ADDR_VAR 0 17
25857: PUSH
25858: LD_VAR 0 17
25862: PUSH
25863: LD_VAR 0 8
25867: PPUSH
25868: CALL_OW 478
25872: UNION
25873: ST_TO_ADDR
25874: GO 25850
25876: POP
25877: POP
// if not fac_list then
25878: LD_VAR 0 17
25882: NOT
25883: IFFALSE 25887
// exit ;
25885: GO 26836
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25887: LD_ADDR_VAR 0 5
25891: PUSH
25892: LD_INT 4
25894: PUSH
25895: LD_INT 5
25897: PUSH
25898: LD_INT 9
25900: PUSH
25901: LD_INT 10
25903: PUSH
25904: LD_INT 6
25906: PUSH
25907: LD_INT 7
25909: PUSH
25910: LD_INT 11
25912: PUSH
25913: EMPTY
25914: LIST
25915: LIST
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: LIST
25921: PUSH
25922: LD_INT 27
25924: PUSH
25925: LD_INT 28
25927: PUSH
25928: LD_INT 26
25930: PUSH
25931: LD_INT 30
25933: PUSH
25934: EMPTY
25935: LIST
25936: LIST
25937: LIST
25938: LIST
25939: PUSH
25940: LD_INT 43
25942: PUSH
25943: LD_INT 44
25945: PUSH
25946: LD_INT 46
25948: PUSH
25949: LD_INT 45
25951: PUSH
25952: LD_INT 47
25954: PUSH
25955: LD_INT 49
25957: PUSH
25958: EMPTY
25959: LIST
25960: LIST
25961: LIST
25962: LIST
25963: LIST
25964: LIST
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: LIST
25970: PUSH
25971: LD_VAR 0 12
25975: ARRAY
25976: ST_TO_ADDR
// for i in list do
25977: LD_ADDR_VAR 0 8
25981: PUSH
25982: LD_VAR 0 5
25986: PUSH
25987: FOR_IN
25988: IFFALSE 26021
// if not i in fac_list then
25990: LD_VAR 0 8
25994: PUSH
25995: LD_VAR 0 17
25999: IN
26000: NOT
26001: IFFALSE 26019
// list := list diff i ;
26003: LD_ADDR_VAR 0 5
26007: PUSH
26008: LD_VAR 0 5
26012: PUSH
26013: LD_VAR 0 8
26017: DIFF
26018: ST_TO_ADDR
26019: GO 25987
26021: POP
26022: POP
// if not list then
26023: LD_VAR 0 5
26027: NOT
26028: IFFALSE 26032
// exit ;
26030: GO 26836
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26032: LD_VAR 0 12
26036: PUSH
26037: LD_INT 3
26039: EQUAL
26040: PUSH
26041: LD_INT 49
26043: PUSH
26044: LD_VAR 0 5
26048: IN
26049: AND
26050: PUSH
26051: LD_INT 31
26053: PPUSH
26054: LD_VAR 0 16
26058: PPUSH
26059: CALL_OW 321
26063: PUSH
26064: LD_INT 2
26066: EQUAL
26067: AND
26068: IFFALSE 26128
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26070: LD_INT 22
26072: PUSH
26073: LD_VAR 0 16
26077: PUSH
26078: EMPTY
26079: LIST
26080: LIST
26081: PUSH
26082: LD_INT 35
26084: PUSH
26085: LD_INT 49
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 91
26094: PUSH
26095: LD_VAR 0 1
26099: PUSH
26100: LD_INT 10
26102: PUSH
26103: EMPTY
26104: LIST
26105: LIST
26106: LIST
26107: PUSH
26108: EMPTY
26109: LIST
26110: LIST
26111: LIST
26112: PPUSH
26113: CALL_OW 69
26117: NOT
26118: IFFALSE 26128
// weapon := ru_time_lapser ;
26120: LD_ADDR_VAR 0 18
26124: PUSH
26125: LD_INT 49
26127: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26128: LD_VAR 0 12
26132: PUSH
26133: LD_INT 1
26135: PUSH
26136: LD_INT 2
26138: PUSH
26139: EMPTY
26140: LIST
26141: LIST
26142: IN
26143: PUSH
26144: LD_INT 11
26146: PUSH
26147: LD_VAR 0 5
26151: IN
26152: PUSH
26153: LD_INT 30
26155: PUSH
26156: LD_VAR 0 5
26160: IN
26161: OR
26162: AND
26163: PUSH
26164: LD_INT 6
26166: PPUSH
26167: LD_VAR 0 16
26171: PPUSH
26172: CALL_OW 321
26176: PUSH
26177: LD_INT 2
26179: EQUAL
26180: AND
26181: IFFALSE 26346
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26183: LD_INT 22
26185: PUSH
26186: LD_VAR 0 16
26190: PUSH
26191: EMPTY
26192: LIST
26193: LIST
26194: PUSH
26195: LD_INT 2
26197: PUSH
26198: LD_INT 35
26200: PUSH
26201: LD_INT 11
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 35
26210: PUSH
26211: LD_INT 30
26213: PUSH
26214: EMPTY
26215: LIST
26216: LIST
26217: PUSH
26218: EMPTY
26219: LIST
26220: LIST
26221: LIST
26222: PUSH
26223: LD_INT 91
26225: PUSH
26226: LD_VAR 0 1
26230: PUSH
26231: LD_INT 18
26233: PUSH
26234: EMPTY
26235: LIST
26236: LIST
26237: LIST
26238: PUSH
26239: EMPTY
26240: LIST
26241: LIST
26242: LIST
26243: PPUSH
26244: CALL_OW 69
26248: NOT
26249: PUSH
26250: LD_INT 22
26252: PUSH
26253: LD_VAR 0 16
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: LD_INT 2
26264: PUSH
26265: LD_INT 30
26267: PUSH
26268: LD_INT 32
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PUSH
26275: LD_INT 30
26277: PUSH
26278: LD_INT 33
26280: PUSH
26281: EMPTY
26282: LIST
26283: LIST
26284: PUSH
26285: EMPTY
26286: LIST
26287: LIST
26288: LIST
26289: PUSH
26290: LD_INT 91
26292: PUSH
26293: LD_VAR 0 1
26297: PUSH
26298: LD_INT 12
26300: PUSH
26301: EMPTY
26302: LIST
26303: LIST
26304: LIST
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: LIST
26310: PUSH
26311: EMPTY
26312: LIST
26313: PPUSH
26314: CALL_OW 69
26318: PUSH
26319: LD_INT 2
26321: GREATER
26322: AND
26323: IFFALSE 26346
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26325: LD_ADDR_VAR 0 18
26329: PUSH
26330: LD_INT 11
26332: PUSH
26333: LD_INT 30
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_VAR 0 12
26344: ARRAY
26345: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26346: LD_VAR 0 18
26350: NOT
26351: PUSH
26352: LD_INT 40
26354: PPUSH
26355: LD_VAR 0 16
26359: PPUSH
26360: CALL_OW 321
26364: PUSH
26365: LD_INT 2
26367: EQUAL
26368: AND
26369: PUSH
26370: LD_INT 7
26372: PUSH
26373: LD_VAR 0 5
26377: IN
26378: PUSH
26379: LD_INT 28
26381: PUSH
26382: LD_VAR 0 5
26386: IN
26387: OR
26388: PUSH
26389: LD_INT 45
26391: PUSH
26392: LD_VAR 0 5
26396: IN
26397: OR
26398: AND
26399: IFFALSE 26653
// begin hex := GetHexInfo ( x , y ) ;
26401: LD_ADDR_VAR 0 4
26405: PUSH
26406: LD_VAR 0 10
26410: PPUSH
26411: LD_VAR 0 11
26415: PPUSH
26416: CALL_OW 546
26420: ST_TO_ADDR
// if hex [ 1 ] then
26421: LD_VAR 0 4
26425: PUSH
26426: LD_INT 1
26428: ARRAY
26429: IFFALSE 26433
// exit ;
26431: GO 26836
// height := hex [ 2 ] ;
26433: LD_ADDR_VAR 0 15
26437: PUSH
26438: LD_VAR 0 4
26442: PUSH
26443: LD_INT 2
26445: ARRAY
26446: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26447: LD_ADDR_VAR 0 14
26451: PUSH
26452: LD_INT 0
26454: PUSH
26455: LD_INT 2
26457: PUSH
26458: LD_INT 3
26460: PUSH
26461: LD_INT 5
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: LIST
26468: LIST
26469: ST_TO_ADDR
// for i in tmp do
26470: LD_ADDR_VAR 0 8
26474: PUSH
26475: LD_VAR 0 14
26479: PUSH
26480: FOR_IN
26481: IFFALSE 26651
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26483: LD_ADDR_VAR 0 9
26487: PUSH
26488: LD_VAR 0 10
26492: PPUSH
26493: LD_VAR 0 8
26497: PPUSH
26498: LD_INT 5
26500: PPUSH
26501: CALL_OW 272
26505: PUSH
26506: LD_VAR 0 11
26510: PPUSH
26511: LD_VAR 0 8
26515: PPUSH
26516: LD_INT 5
26518: PPUSH
26519: CALL_OW 273
26523: PUSH
26524: EMPTY
26525: LIST
26526: LIST
26527: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26528: LD_VAR 0 9
26532: PUSH
26533: LD_INT 1
26535: ARRAY
26536: PPUSH
26537: LD_VAR 0 9
26541: PUSH
26542: LD_INT 2
26544: ARRAY
26545: PPUSH
26546: CALL_OW 488
26550: IFFALSE 26649
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26552: LD_ADDR_VAR 0 4
26556: PUSH
26557: LD_VAR 0 9
26561: PUSH
26562: LD_INT 1
26564: ARRAY
26565: PPUSH
26566: LD_VAR 0 9
26570: PUSH
26571: LD_INT 2
26573: ARRAY
26574: PPUSH
26575: CALL_OW 546
26579: ST_TO_ADDR
// if hex [ 1 ] then
26580: LD_VAR 0 4
26584: PUSH
26585: LD_INT 1
26587: ARRAY
26588: IFFALSE 26592
// continue ;
26590: GO 26480
// h := hex [ 2 ] ;
26592: LD_ADDR_VAR 0 13
26596: PUSH
26597: LD_VAR 0 4
26601: PUSH
26602: LD_INT 2
26604: ARRAY
26605: ST_TO_ADDR
// if h + 7 < height then
26606: LD_VAR 0 13
26610: PUSH
26611: LD_INT 7
26613: PLUS
26614: PUSH
26615: LD_VAR 0 15
26619: LESS
26620: IFFALSE 26649
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26622: LD_ADDR_VAR 0 18
26626: PUSH
26627: LD_INT 7
26629: PUSH
26630: LD_INT 28
26632: PUSH
26633: LD_INT 45
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: PUSH
26641: LD_VAR 0 12
26645: ARRAY
26646: ST_TO_ADDR
// break ;
26647: GO 26651
// end ; end ; end ;
26649: GO 26480
26651: POP
26652: POP
// end ; if not weapon then
26653: LD_VAR 0 18
26657: NOT
26658: IFFALSE 26718
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26660: LD_ADDR_VAR 0 5
26664: PUSH
26665: LD_VAR 0 5
26669: PUSH
26670: LD_INT 11
26672: PUSH
26673: LD_INT 30
26675: PUSH
26676: LD_INT 49
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: LIST
26683: DIFF
26684: ST_TO_ADDR
// if not list then
26685: LD_VAR 0 5
26689: NOT
26690: IFFALSE 26694
// exit ;
26692: GO 26836
// weapon := list [ rand ( 1 , list ) ] ;
26694: LD_ADDR_VAR 0 18
26698: PUSH
26699: LD_VAR 0 5
26703: PUSH
26704: LD_INT 1
26706: PPUSH
26707: LD_VAR 0 5
26711: PPUSH
26712: CALL_OW 12
26716: ARRAY
26717: ST_TO_ADDR
// end ; if weapon then
26718: LD_VAR 0 18
26722: IFFALSE 26836
// begin tmp := CostOfWeapon ( weapon ) ;
26724: LD_ADDR_VAR 0 14
26728: PUSH
26729: LD_VAR 0 18
26733: PPUSH
26734: CALL_OW 451
26738: ST_TO_ADDR
// j := GetBase ( tower ) ;
26739: LD_ADDR_VAR 0 9
26743: PUSH
26744: LD_VAR 0 1
26748: PPUSH
26749: CALL_OW 274
26753: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26754: LD_VAR 0 9
26758: PPUSH
26759: LD_INT 1
26761: PPUSH
26762: CALL_OW 275
26766: PUSH
26767: LD_VAR 0 14
26771: PUSH
26772: LD_INT 1
26774: ARRAY
26775: GREATEREQUAL
26776: PUSH
26777: LD_VAR 0 9
26781: PPUSH
26782: LD_INT 2
26784: PPUSH
26785: CALL_OW 275
26789: PUSH
26790: LD_VAR 0 14
26794: PUSH
26795: LD_INT 2
26797: ARRAY
26798: GREATEREQUAL
26799: AND
26800: PUSH
26801: LD_VAR 0 9
26805: PPUSH
26806: LD_INT 3
26808: PPUSH
26809: CALL_OW 275
26813: PUSH
26814: LD_VAR 0 14
26818: PUSH
26819: LD_INT 3
26821: ARRAY
26822: GREATEREQUAL
26823: AND
26824: IFFALSE 26836
// result := weapon ;
26826: LD_ADDR_VAR 0 3
26830: PUSH
26831: LD_VAR 0 18
26835: ST_TO_ADDR
// end ; end ;
26836: LD_VAR 0 3
26840: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26841: LD_INT 0
26843: PPUSH
26844: PPUSH
// result := true ;
26845: LD_ADDR_VAR 0 3
26849: PUSH
26850: LD_INT 1
26852: ST_TO_ADDR
// if array1 = array2 then
26853: LD_VAR 0 1
26857: PUSH
26858: LD_VAR 0 2
26862: EQUAL
26863: IFFALSE 26923
// begin for i = 1 to array1 do
26865: LD_ADDR_VAR 0 4
26869: PUSH
26870: DOUBLE
26871: LD_INT 1
26873: DEC
26874: ST_TO_ADDR
26875: LD_VAR 0 1
26879: PUSH
26880: FOR_TO
26881: IFFALSE 26919
// if array1 [ i ] <> array2 [ i ] then
26883: LD_VAR 0 1
26887: PUSH
26888: LD_VAR 0 4
26892: ARRAY
26893: PUSH
26894: LD_VAR 0 2
26898: PUSH
26899: LD_VAR 0 4
26903: ARRAY
26904: NONEQUAL
26905: IFFALSE 26917
// begin result := false ;
26907: LD_ADDR_VAR 0 3
26911: PUSH
26912: LD_INT 0
26914: ST_TO_ADDR
// break ;
26915: GO 26919
// end ;
26917: GO 26880
26919: POP
26920: POP
// end else
26921: GO 26931
// result := false ;
26923: LD_ADDR_VAR 0 3
26927: PUSH
26928: LD_INT 0
26930: ST_TO_ADDR
// end ;
26931: LD_VAR 0 3
26935: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26936: LD_INT 0
26938: PPUSH
26939: PPUSH
26940: PPUSH
// pom := GetBase ( fac ) ;
26941: LD_ADDR_VAR 0 5
26945: PUSH
26946: LD_VAR 0 1
26950: PPUSH
26951: CALL_OW 274
26955: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26956: LD_ADDR_VAR 0 4
26960: PUSH
26961: LD_VAR 0 2
26965: PUSH
26966: LD_INT 1
26968: ARRAY
26969: PPUSH
26970: LD_VAR 0 2
26974: PUSH
26975: LD_INT 2
26977: ARRAY
26978: PPUSH
26979: LD_VAR 0 2
26983: PUSH
26984: LD_INT 3
26986: ARRAY
26987: PPUSH
26988: LD_VAR 0 2
26992: PUSH
26993: LD_INT 4
26995: ARRAY
26996: PPUSH
26997: CALL_OW 449
27001: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27002: LD_ADDR_VAR 0 3
27006: PUSH
27007: LD_VAR 0 5
27011: PPUSH
27012: LD_INT 1
27014: PPUSH
27015: CALL_OW 275
27019: PUSH
27020: LD_VAR 0 4
27024: PUSH
27025: LD_INT 1
27027: ARRAY
27028: GREATEREQUAL
27029: PUSH
27030: LD_VAR 0 5
27034: PPUSH
27035: LD_INT 2
27037: PPUSH
27038: CALL_OW 275
27042: PUSH
27043: LD_VAR 0 4
27047: PUSH
27048: LD_INT 2
27050: ARRAY
27051: GREATEREQUAL
27052: AND
27053: PUSH
27054: LD_VAR 0 5
27058: PPUSH
27059: LD_INT 3
27061: PPUSH
27062: CALL_OW 275
27066: PUSH
27067: LD_VAR 0 4
27071: PUSH
27072: LD_INT 3
27074: ARRAY
27075: GREATEREQUAL
27076: AND
27077: ST_TO_ADDR
// end ;
27078: LD_VAR 0 3
27082: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27083: LD_INT 0
27085: PPUSH
27086: PPUSH
27087: PPUSH
27088: PPUSH
// pom := GetBase ( building ) ;
27089: LD_ADDR_VAR 0 3
27093: PUSH
27094: LD_VAR 0 1
27098: PPUSH
27099: CALL_OW 274
27103: ST_TO_ADDR
// if not pom then
27104: LD_VAR 0 3
27108: NOT
27109: IFFALSE 27113
// exit ;
27111: GO 27283
// btype := GetBType ( building ) ;
27113: LD_ADDR_VAR 0 5
27117: PUSH
27118: LD_VAR 0 1
27122: PPUSH
27123: CALL_OW 266
27127: ST_TO_ADDR
// if btype = b_armoury then
27128: LD_VAR 0 5
27132: PUSH
27133: LD_INT 4
27135: EQUAL
27136: IFFALSE 27146
// btype := b_barracks ;
27138: LD_ADDR_VAR 0 5
27142: PUSH
27143: LD_INT 5
27145: ST_TO_ADDR
// if btype = b_depot then
27146: LD_VAR 0 5
27150: PUSH
27151: LD_INT 0
27153: EQUAL
27154: IFFALSE 27164
// btype := b_warehouse ;
27156: LD_ADDR_VAR 0 5
27160: PUSH
27161: LD_INT 1
27163: ST_TO_ADDR
// if btype = b_workshop then
27164: LD_VAR 0 5
27168: PUSH
27169: LD_INT 2
27171: EQUAL
27172: IFFALSE 27182
// btype := b_factory ;
27174: LD_ADDR_VAR 0 5
27178: PUSH
27179: LD_INT 3
27181: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27182: LD_ADDR_VAR 0 4
27186: PUSH
27187: LD_VAR 0 5
27191: PPUSH
27192: LD_VAR 0 1
27196: PPUSH
27197: CALL_OW 248
27201: PPUSH
27202: CALL_OW 450
27206: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27207: LD_ADDR_VAR 0 2
27211: PUSH
27212: LD_VAR 0 3
27216: PPUSH
27217: LD_INT 1
27219: PPUSH
27220: CALL_OW 275
27224: PUSH
27225: LD_VAR 0 4
27229: PUSH
27230: LD_INT 1
27232: ARRAY
27233: GREATEREQUAL
27234: PUSH
27235: LD_VAR 0 3
27239: PPUSH
27240: LD_INT 2
27242: PPUSH
27243: CALL_OW 275
27247: PUSH
27248: LD_VAR 0 4
27252: PUSH
27253: LD_INT 2
27255: ARRAY
27256: GREATEREQUAL
27257: AND
27258: PUSH
27259: LD_VAR 0 3
27263: PPUSH
27264: LD_INT 3
27266: PPUSH
27267: CALL_OW 275
27271: PUSH
27272: LD_VAR 0 4
27276: PUSH
27277: LD_INT 3
27279: ARRAY
27280: GREATEREQUAL
27281: AND
27282: ST_TO_ADDR
// end ;
27283: LD_VAR 0 2
27287: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27288: LD_INT 0
27290: PPUSH
27291: PPUSH
27292: PPUSH
// pom := GetBase ( building ) ;
27293: LD_ADDR_VAR 0 4
27297: PUSH
27298: LD_VAR 0 1
27302: PPUSH
27303: CALL_OW 274
27307: ST_TO_ADDR
// if not pom then
27308: LD_VAR 0 4
27312: NOT
27313: IFFALSE 27317
// exit ;
27315: GO 27418
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27317: LD_ADDR_VAR 0 5
27321: PUSH
27322: LD_VAR 0 2
27326: PPUSH
27327: LD_VAR 0 1
27331: PPUSH
27332: CALL_OW 248
27336: PPUSH
27337: CALL_OW 450
27341: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27342: LD_ADDR_VAR 0 3
27346: PUSH
27347: LD_VAR 0 4
27351: PPUSH
27352: LD_INT 1
27354: PPUSH
27355: CALL_OW 275
27359: PUSH
27360: LD_VAR 0 5
27364: PUSH
27365: LD_INT 1
27367: ARRAY
27368: GREATEREQUAL
27369: PUSH
27370: LD_VAR 0 4
27374: PPUSH
27375: LD_INT 2
27377: PPUSH
27378: CALL_OW 275
27382: PUSH
27383: LD_VAR 0 5
27387: PUSH
27388: LD_INT 2
27390: ARRAY
27391: GREATEREQUAL
27392: AND
27393: PUSH
27394: LD_VAR 0 4
27398: PPUSH
27399: LD_INT 3
27401: PPUSH
27402: CALL_OW 275
27406: PUSH
27407: LD_VAR 0 5
27411: PUSH
27412: LD_INT 3
27414: ARRAY
27415: GREATEREQUAL
27416: AND
27417: ST_TO_ADDR
// end ;
27418: LD_VAR 0 3
27422: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27423: LD_INT 0
27425: PPUSH
27426: PPUSH
27427: PPUSH
27428: PPUSH
27429: PPUSH
27430: PPUSH
27431: PPUSH
27432: PPUSH
27433: PPUSH
27434: PPUSH
// result := false ;
27435: LD_ADDR_VAR 0 6
27439: PUSH
27440: LD_INT 0
27442: ST_TO_ADDR
// if not base or not btype or not x or not y then
27443: LD_VAR 0 1
27447: NOT
27448: PUSH
27449: LD_VAR 0 2
27453: NOT
27454: OR
27455: PUSH
27456: LD_VAR 0 3
27460: NOT
27461: OR
27462: PUSH
27463: LD_VAR 0 4
27467: NOT
27468: OR
27469: IFFALSE 27473
// exit ;
27471: GO 28064
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27473: LD_ADDR_VAR 0 12
27477: PUSH
27478: LD_VAR 0 2
27482: PPUSH
27483: LD_VAR 0 3
27487: PPUSH
27488: LD_VAR 0 4
27492: PPUSH
27493: LD_VAR 0 5
27497: PPUSH
27498: LD_VAR 0 1
27502: PUSH
27503: LD_INT 1
27505: ARRAY
27506: PPUSH
27507: CALL_OW 248
27511: PPUSH
27512: LD_INT 0
27514: PPUSH
27515: CALL 28901 0 6
27519: ST_TO_ADDR
// if not hexes then
27520: LD_VAR 0 12
27524: NOT
27525: IFFALSE 27529
// exit ;
27527: GO 28064
// for i = 1 to hexes do
27529: LD_ADDR_VAR 0 7
27533: PUSH
27534: DOUBLE
27535: LD_INT 1
27537: DEC
27538: ST_TO_ADDR
27539: LD_VAR 0 12
27543: PUSH
27544: FOR_TO
27545: IFFALSE 28062
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27547: LD_ADDR_VAR 0 11
27551: PUSH
27552: LD_VAR 0 12
27556: PUSH
27557: LD_VAR 0 7
27561: ARRAY
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: PPUSH
27567: LD_VAR 0 12
27571: PUSH
27572: LD_VAR 0 7
27576: ARRAY
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: PPUSH
27582: CALL_OW 428
27586: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27587: LD_VAR 0 12
27591: PUSH
27592: LD_VAR 0 7
27596: ARRAY
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 12
27606: PUSH
27607: LD_VAR 0 7
27611: ARRAY
27612: PUSH
27613: LD_INT 2
27615: ARRAY
27616: PPUSH
27617: CALL_OW 351
27621: PUSH
27622: LD_VAR 0 12
27626: PUSH
27627: LD_VAR 0 7
27631: ARRAY
27632: PUSH
27633: LD_INT 1
27635: ARRAY
27636: PPUSH
27637: LD_VAR 0 12
27641: PUSH
27642: LD_VAR 0 7
27646: ARRAY
27647: PUSH
27648: LD_INT 2
27650: ARRAY
27651: PPUSH
27652: CALL_OW 488
27656: NOT
27657: OR
27658: PUSH
27659: LD_VAR 0 11
27663: PPUSH
27664: CALL_OW 247
27668: PUSH
27669: LD_INT 3
27671: EQUAL
27672: OR
27673: IFFALSE 27679
// exit ;
27675: POP
27676: POP
27677: GO 28064
// if not tmp then
27679: LD_VAR 0 11
27683: NOT
27684: IFFALSE 27688
// continue ;
27686: GO 27544
// result := true ;
27688: LD_ADDR_VAR 0 6
27692: PUSH
27693: LD_INT 1
27695: ST_TO_ADDR
// dep := FilterAllUnits ( [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27696: LD_ADDR_VAR 0 15
27700: PUSH
27701: LD_INT 22
27703: PUSH
27704: LD_VAR 0 11
27708: PPUSH
27709: CALL_OW 255
27713: PUSH
27714: EMPTY
27715: LIST
27716: LIST
27717: PUSH
27718: LD_INT 2
27720: PUSH
27721: LD_INT 30
27723: PUSH
27724: LD_INT 0
27726: PUSH
27727: EMPTY
27728: LIST
27729: LIST
27730: PUSH
27731: LD_INT 30
27733: PUSH
27734: LD_INT 1
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: LIST
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: PPUSH
27750: CALL_OW 69
27754: ST_TO_ADDR
// if dep then
27755: LD_VAR 0 15
27759: IFFALSE 27895
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27761: LD_ADDR_VAR 0 14
27765: PUSH
27766: LD_VAR 0 15
27770: PUSH
27771: LD_INT 1
27773: ARRAY
27774: PPUSH
27775: CALL_OW 250
27779: PPUSH
27780: LD_VAR 0 15
27784: PUSH
27785: LD_INT 1
27787: ARRAY
27788: PPUSH
27789: CALL_OW 254
27793: PPUSH
27794: LD_INT 5
27796: PPUSH
27797: CALL_OW 272
27801: PUSH
27802: LD_VAR 0 15
27806: PUSH
27807: LD_INT 1
27809: ARRAY
27810: PPUSH
27811: CALL_OW 251
27815: PPUSH
27816: LD_VAR 0 15
27820: PUSH
27821: LD_INT 1
27823: ARRAY
27824: PPUSH
27825: CALL_OW 254
27829: PPUSH
27830: LD_INT 5
27832: PPUSH
27833: CALL_OW 273
27837: PUSH
27838: EMPTY
27839: LIST
27840: LIST
27841: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27842: LD_VAR 0 14
27846: PUSH
27847: LD_INT 1
27849: ARRAY
27850: PPUSH
27851: LD_VAR 0 14
27855: PUSH
27856: LD_INT 2
27858: ARRAY
27859: PPUSH
27860: CALL_OW 488
27864: IFFALSE 27895
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27866: LD_VAR 0 11
27870: PPUSH
27871: LD_VAR 0 14
27875: PUSH
27876: LD_INT 1
27878: ARRAY
27879: PPUSH
27880: LD_VAR 0 14
27884: PUSH
27885: LD_INT 2
27887: ARRAY
27888: PPUSH
27889: CALL_OW 111
// continue ;
27893: GO 27544
// end ; end ; r := GetDir ( tmp ) ;
27895: LD_ADDR_VAR 0 13
27899: PUSH
27900: LD_VAR 0 11
27904: PPUSH
27905: CALL_OW 254
27909: ST_TO_ADDR
// if r = 5 then
27910: LD_VAR 0 13
27914: PUSH
27915: LD_INT 5
27917: EQUAL
27918: IFFALSE 27928
// r := 0 ;
27920: LD_ADDR_VAR 0 13
27924: PUSH
27925: LD_INT 0
27927: ST_TO_ADDR
// for j = r to 5 do
27928: LD_ADDR_VAR 0 8
27932: PUSH
27933: DOUBLE
27934: LD_VAR 0 13
27938: DEC
27939: ST_TO_ADDR
27940: LD_INT 5
27942: PUSH
27943: FOR_TO
27944: IFFALSE 28058
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27946: LD_ADDR_VAR 0 9
27950: PUSH
27951: LD_VAR 0 11
27955: PPUSH
27956: CALL_OW 250
27960: PPUSH
27961: LD_VAR 0 8
27965: PPUSH
27966: LD_INT 2
27968: PPUSH
27969: CALL_OW 272
27973: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27974: LD_ADDR_VAR 0 10
27978: PUSH
27979: LD_VAR 0 11
27983: PPUSH
27984: CALL_OW 251
27988: PPUSH
27989: LD_VAR 0 8
27993: PPUSH
27994: LD_INT 2
27996: PPUSH
27997: CALL_OW 273
28001: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28002: LD_VAR 0 9
28006: PPUSH
28007: LD_VAR 0 10
28011: PPUSH
28012: CALL_OW 488
28016: PUSH
28017: LD_VAR 0 9
28021: PPUSH
28022: LD_VAR 0 10
28026: PPUSH
28027: CALL_OW 428
28031: NOT
28032: AND
28033: IFFALSE 28056
// begin ComMoveXY ( tmp , _x , _y ) ;
28035: LD_VAR 0 11
28039: PPUSH
28040: LD_VAR 0 9
28044: PPUSH
28045: LD_VAR 0 10
28049: PPUSH
28050: CALL_OW 111
// break ;
28054: GO 28058
// end ; end ;
28056: GO 27943
28058: POP
28059: POP
// end ;
28060: GO 27544
28062: POP
28063: POP
// end ;
28064: LD_VAR 0 6
28068: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28069: LD_INT 0
28071: PPUSH
28072: PPUSH
28073: PPUSH
28074: PPUSH
28075: PPUSH
28076: PPUSH
28077: PPUSH
28078: PPUSH
28079: PPUSH
28080: PPUSH
// result := false ;
28081: LD_ADDR_VAR 0 6
28085: PUSH
28086: LD_INT 0
28088: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28089: LD_VAR 0 1
28093: NOT
28094: PUSH
28095: LD_VAR 0 1
28099: PPUSH
28100: CALL_OW 266
28104: PUSH
28105: LD_INT 0
28107: PUSH
28108: LD_INT 1
28110: PUSH
28111: EMPTY
28112: LIST
28113: LIST
28114: IN
28115: NOT
28116: OR
28117: PUSH
28118: LD_VAR 0 2
28122: NOT
28123: OR
28124: PUSH
28125: LD_VAR 0 5
28129: PUSH
28130: LD_INT 0
28132: PUSH
28133: LD_INT 1
28135: PUSH
28136: LD_INT 2
28138: PUSH
28139: LD_INT 3
28141: PUSH
28142: LD_INT 4
28144: PUSH
28145: LD_INT 5
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: IN
28156: NOT
28157: OR
28158: PUSH
28159: LD_VAR 0 3
28163: PPUSH
28164: LD_VAR 0 4
28168: PPUSH
28169: CALL_OW 488
28173: NOT
28174: OR
28175: IFFALSE 28179
// exit ;
28177: GO 28896
// pom := GetBase ( depot ) ;
28179: LD_ADDR_VAR 0 10
28183: PUSH
28184: LD_VAR 0 1
28188: PPUSH
28189: CALL_OW 274
28193: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28194: LD_ADDR_VAR 0 11
28198: PUSH
28199: LD_VAR 0 2
28203: PPUSH
28204: LD_VAR 0 1
28208: PPUSH
28209: CALL_OW 248
28213: PPUSH
28214: CALL_OW 450
28218: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28219: LD_VAR 0 10
28223: PPUSH
28224: LD_INT 1
28226: PPUSH
28227: CALL_OW 275
28231: PUSH
28232: LD_VAR 0 11
28236: PUSH
28237: LD_INT 1
28239: ARRAY
28240: GREATEREQUAL
28241: PUSH
28242: LD_VAR 0 10
28246: PPUSH
28247: LD_INT 2
28249: PPUSH
28250: CALL_OW 275
28254: PUSH
28255: LD_VAR 0 11
28259: PUSH
28260: LD_INT 2
28262: ARRAY
28263: GREATEREQUAL
28264: AND
28265: PUSH
28266: LD_VAR 0 10
28270: PPUSH
28271: LD_INT 3
28273: PPUSH
28274: CALL_OW 275
28278: PUSH
28279: LD_VAR 0 11
28283: PUSH
28284: LD_INT 3
28286: ARRAY
28287: GREATEREQUAL
28288: AND
28289: NOT
28290: IFFALSE 28294
// exit ;
28292: GO 28896
// if GetBType ( depot ) = b_depot then
28294: LD_VAR 0 1
28298: PPUSH
28299: CALL_OW 266
28303: PUSH
28304: LD_INT 0
28306: EQUAL
28307: IFFALSE 28319
// dist := 28 else
28309: LD_ADDR_VAR 0 14
28313: PUSH
28314: LD_INT 28
28316: ST_TO_ADDR
28317: GO 28327
// dist := 36 ;
28319: LD_ADDR_VAR 0 14
28323: PUSH
28324: LD_INT 36
28326: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28327: LD_VAR 0 1
28331: PPUSH
28332: LD_VAR 0 3
28336: PPUSH
28337: LD_VAR 0 4
28341: PPUSH
28342: CALL_OW 297
28346: PUSH
28347: LD_VAR 0 14
28351: GREATER
28352: IFFALSE 28356
// exit ;
28354: GO 28896
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28356: LD_ADDR_VAR 0 12
28360: PUSH
28361: LD_VAR 0 2
28365: PPUSH
28366: LD_VAR 0 3
28370: PPUSH
28371: LD_VAR 0 4
28375: PPUSH
28376: LD_VAR 0 5
28380: PPUSH
28381: LD_VAR 0 1
28385: PPUSH
28386: CALL_OW 248
28390: PPUSH
28391: LD_INT 0
28393: PPUSH
28394: CALL 28901 0 6
28398: ST_TO_ADDR
// if not hexes then
28399: LD_VAR 0 12
28403: NOT
28404: IFFALSE 28408
// exit ;
28406: GO 28896
// hex := GetHexInfo ( x , y ) ;
28408: LD_ADDR_VAR 0 15
28412: PUSH
28413: LD_VAR 0 3
28417: PPUSH
28418: LD_VAR 0 4
28422: PPUSH
28423: CALL_OW 546
28427: ST_TO_ADDR
// if hex [ 1 ] then
28428: LD_VAR 0 15
28432: PUSH
28433: LD_INT 1
28435: ARRAY
28436: IFFALSE 28440
// exit ;
28438: GO 28896
// height := hex [ 2 ] ;
28440: LD_ADDR_VAR 0 13
28444: PUSH
28445: LD_VAR 0 15
28449: PUSH
28450: LD_INT 2
28452: ARRAY
28453: ST_TO_ADDR
// for i = 1 to hexes do
28454: LD_ADDR_VAR 0 7
28458: PUSH
28459: DOUBLE
28460: LD_INT 1
28462: DEC
28463: ST_TO_ADDR
28464: LD_VAR 0 12
28468: PUSH
28469: FOR_TO
28470: IFFALSE 28800
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28472: LD_VAR 0 12
28476: PUSH
28477: LD_VAR 0 7
28481: ARRAY
28482: PUSH
28483: LD_INT 1
28485: ARRAY
28486: PPUSH
28487: LD_VAR 0 12
28491: PUSH
28492: LD_VAR 0 7
28496: ARRAY
28497: PUSH
28498: LD_INT 2
28500: ARRAY
28501: PPUSH
28502: CALL_OW 488
28506: NOT
28507: PUSH
28508: LD_VAR 0 12
28512: PUSH
28513: LD_VAR 0 7
28517: ARRAY
28518: PUSH
28519: LD_INT 1
28521: ARRAY
28522: PPUSH
28523: LD_VAR 0 12
28527: PUSH
28528: LD_VAR 0 7
28532: ARRAY
28533: PUSH
28534: LD_INT 2
28536: ARRAY
28537: PPUSH
28538: CALL_OW 428
28542: PUSH
28543: LD_INT 0
28545: GREATER
28546: OR
28547: PUSH
28548: LD_VAR 0 12
28552: PUSH
28553: LD_VAR 0 7
28557: ARRAY
28558: PUSH
28559: LD_INT 1
28561: ARRAY
28562: PPUSH
28563: LD_VAR 0 12
28567: PUSH
28568: LD_VAR 0 7
28572: ARRAY
28573: PUSH
28574: LD_INT 2
28576: ARRAY
28577: PPUSH
28578: CALL_OW 351
28582: OR
28583: IFFALSE 28589
// exit ;
28585: POP
28586: POP
28587: GO 28896
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28589: LD_ADDR_VAR 0 8
28593: PUSH
28594: LD_VAR 0 12
28598: PUSH
28599: LD_VAR 0 7
28603: ARRAY
28604: PUSH
28605: LD_INT 1
28607: ARRAY
28608: PPUSH
28609: LD_VAR 0 12
28613: PUSH
28614: LD_VAR 0 7
28618: ARRAY
28619: PUSH
28620: LD_INT 2
28622: ARRAY
28623: PPUSH
28624: CALL_OW 546
28628: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28629: LD_VAR 0 8
28633: PUSH
28634: LD_INT 1
28636: ARRAY
28637: PUSH
28638: LD_VAR 0 8
28642: PUSH
28643: LD_INT 2
28645: ARRAY
28646: PUSH
28647: LD_VAR 0 13
28651: PUSH
28652: LD_INT 2
28654: PLUS
28655: GREATER
28656: OR
28657: PUSH
28658: LD_VAR 0 8
28662: PUSH
28663: LD_INT 2
28665: ARRAY
28666: PUSH
28667: LD_VAR 0 13
28671: PUSH
28672: LD_INT 2
28674: MINUS
28675: LESS
28676: OR
28677: PUSH
28678: LD_VAR 0 8
28682: PUSH
28683: LD_INT 3
28685: ARRAY
28686: PUSH
28687: LD_INT 0
28689: PUSH
28690: LD_INT 8
28692: PUSH
28693: LD_INT 9
28695: PUSH
28696: LD_INT 10
28698: PUSH
28699: LD_INT 11
28701: PUSH
28702: LD_INT 12
28704: PUSH
28705: LD_INT 13
28707: PUSH
28708: LD_INT 16
28710: PUSH
28711: LD_INT 17
28713: PUSH
28714: LD_INT 18
28716: PUSH
28717: LD_INT 19
28719: PUSH
28720: LD_INT 20
28722: PUSH
28723: LD_INT 21
28725: PUSH
28726: EMPTY
28727: LIST
28728: LIST
28729: LIST
28730: LIST
28731: LIST
28732: LIST
28733: LIST
28734: LIST
28735: LIST
28736: LIST
28737: LIST
28738: LIST
28739: LIST
28740: IN
28741: NOT
28742: OR
28743: PUSH
28744: LD_VAR 0 8
28748: PUSH
28749: LD_INT 5
28751: ARRAY
28752: NOT
28753: OR
28754: PUSH
28755: LD_VAR 0 8
28759: PUSH
28760: LD_INT 6
28762: ARRAY
28763: PUSH
28764: LD_INT 1
28766: PUSH
28767: LD_INT 2
28769: PUSH
28770: LD_INT 7
28772: PUSH
28773: LD_INT 9
28775: PUSH
28776: LD_INT 10
28778: PUSH
28779: LD_INT 11
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: IN
28790: NOT
28791: OR
28792: IFFALSE 28798
// exit ;
28794: POP
28795: POP
28796: GO 28896
// end ;
28798: GO 28469
28800: POP
28801: POP
// side := GetSide ( depot ) ;
28802: LD_ADDR_VAR 0 9
28806: PUSH
28807: LD_VAR 0 1
28811: PPUSH
28812: CALL_OW 255
28816: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28817: LD_VAR 0 9
28821: PPUSH
28822: LD_VAR 0 3
28826: PPUSH
28827: LD_VAR 0 4
28831: PPUSH
28832: LD_INT 20
28834: PPUSH
28835: CALL 21568 0 4
28839: PUSH
28840: LD_INT 4
28842: ARRAY
28843: IFFALSE 28847
// exit ;
28845: GO 28896
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28847: LD_VAR 0 2
28851: PUSH
28852: LD_INT 29
28854: PUSH
28855: LD_INT 30
28857: PUSH
28858: EMPTY
28859: LIST
28860: LIST
28861: IN
28862: PUSH
28863: LD_VAR 0 3
28867: PPUSH
28868: LD_VAR 0 4
28872: PPUSH
28873: LD_VAR 0 9
28877: PPUSH
28878: CALL_OW 440
28882: NOT
28883: AND
28884: IFFALSE 28888
// exit ;
28886: GO 28896
// result := true ;
28888: LD_ADDR_VAR 0 6
28892: PUSH
28893: LD_INT 1
28895: ST_TO_ADDR
// end ;
28896: LD_VAR 0 6
28900: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
28901: LD_INT 0
28903: PPUSH
28904: PPUSH
28905: PPUSH
28906: PPUSH
28907: PPUSH
28908: PPUSH
28909: PPUSH
28910: PPUSH
28911: PPUSH
28912: PPUSH
28913: PPUSH
28914: PPUSH
28915: PPUSH
28916: PPUSH
28917: PPUSH
28918: PPUSH
28919: PPUSH
28920: PPUSH
28921: PPUSH
28922: PPUSH
28923: PPUSH
28924: PPUSH
28925: PPUSH
28926: PPUSH
28927: PPUSH
28928: PPUSH
28929: PPUSH
28930: PPUSH
28931: PPUSH
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
28938: PPUSH
28939: PPUSH
28940: PPUSH
28941: PPUSH
28942: PPUSH
28943: PPUSH
28944: PPUSH
28945: PPUSH
28946: PPUSH
28947: PPUSH
28948: PPUSH
28949: PPUSH
28950: PPUSH
28951: PPUSH
28952: PPUSH
28953: PPUSH
28954: PPUSH
28955: PPUSH
28956: PPUSH
28957: PPUSH
28958: PPUSH
28959: PPUSH
28960: PPUSH
// result = [ ] ;
28961: LD_ADDR_VAR 0 7
28965: PUSH
28966: EMPTY
28967: ST_TO_ADDR
// temp_list = [ ] ;
28968: LD_ADDR_VAR 0 9
28972: PUSH
28973: EMPTY
28974: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
28975: LD_VAR 0 4
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: LD_INT 1
28985: PUSH
28986: LD_INT 2
28988: PUSH
28989: LD_INT 3
28991: PUSH
28992: LD_INT 4
28994: PUSH
28995: LD_INT 5
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: IN
29006: NOT
29007: PUSH
29008: LD_VAR 0 1
29012: PUSH
29013: LD_INT 0
29015: PUSH
29016: LD_INT 1
29018: PUSH
29019: EMPTY
29020: LIST
29021: LIST
29022: IN
29023: PUSH
29024: LD_VAR 0 5
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 2
29034: PUSH
29035: LD_INT 3
29037: PUSH
29038: EMPTY
29039: LIST
29040: LIST
29041: LIST
29042: IN
29043: NOT
29044: AND
29045: OR
29046: IFFALSE 29050
// exit ;
29048: GO 47435
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29050: LD_VAR 0 1
29054: PUSH
29055: LD_INT 6
29057: PUSH
29058: LD_INT 7
29060: PUSH
29061: LD_INT 8
29063: PUSH
29064: LD_INT 13
29066: PUSH
29067: LD_INT 12
29069: PUSH
29070: LD_INT 15
29072: PUSH
29073: LD_INT 11
29075: PUSH
29076: LD_INT 14
29078: PUSH
29079: LD_INT 10
29081: PUSH
29082: EMPTY
29083: LIST
29084: LIST
29085: LIST
29086: LIST
29087: LIST
29088: LIST
29089: LIST
29090: LIST
29091: LIST
29092: IN
29093: IFFALSE 29103
// btype = b_lab ;
29095: LD_ADDR_VAR 0 1
29099: PUSH
29100: LD_INT 6
29102: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29103: LD_VAR 0 6
29107: PUSH
29108: LD_INT 0
29110: PUSH
29111: LD_INT 1
29113: PUSH
29114: LD_INT 2
29116: PUSH
29117: EMPTY
29118: LIST
29119: LIST
29120: LIST
29121: IN
29122: NOT
29123: PUSH
29124: LD_VAR 0 1
29128: PUSH
29129: LD_INT 0
29131: PUSH
29132: LD_INT 1
29134: PUSH
29135: LD_INT 2
29137: PUSH
29138: LD_INT 3
29140: PUSH
29141: LD_INT 6
29143: PUSH
29144: LD_INT 36
29146: PUSH
29147: LD_INT 4
29149: PUSH
29150: LD_INT 5
29152: PUSH
29153: LD_INT 31
29155: PUSH
29156: LD_INT 32
29158: PUSH
29159: LD_INT 33
29161: PUSH
29162: EMPTY
29163: LIST
29164: LIST
29165: LIST
29166: LIST
29167: LIST
29168: LIST
29169: LIST
29170: LIST
29171: LIST
29172: LIST
29173: LIST
29174: IN
29175: NOT
29176: PUSH
29177: LD_VAR 0 6
29181: PUSH
29182: LD_INT 1
29184: EQUAL
29185: AND
29186: OR
29187: PUSH
29188: LD_VAR 0 1
29192: PUSH
29193: LD_INT 2
29195: PUSH
29196: LD_INT 3
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: IN
29203: NOT
29204: PUSH
29205: LD_VAR 0 6
29209: PUSH
29210: LD_INT 2
29212: EQUAL
29213: AND
29214: OR
29215: IFFALSE 29225
// mode = 0 ;
29217: LD_ADDR_VAR 0 6
29221: PUSH
29222: LD_INT 0
29224: ST_TO_ADDR
// case mode of 0 :
29225: LD_VAR 0 6
29229: PUSH
29230: LD_INT 0
29232: DOUBLE
29233: EQUAL
29234: IFTRUE 29238
29236: GO 40691
29238: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29239: LD_ADDR_VAR 0 11
29243: PUSH
29244: LD_INT 0
29246: PUSH
29247: LD_INT 0
29249: PUSH
29250: EMPTY
29251: LIST
29252: LIST
29253: PUSH
29254: LD_INT 0
29256: PUSH
29257: LD_INT 1
29259: NEG
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: PUSH
29265: LD_INT 1
29267: PUSH
29268: LD_INT 0
29270: PUSH
29271: EMPTY
29272: LIST
29273: LIST
29274: PUSH
29275: LD_INT 1
29277: PUSH
29278: LD_INT 1
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: PUSH
29285: LD_INT 0
29287: PUSH
29288: LD_INT 1
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 1
29297: NEG
29298: PUSH
29299: LD_INT 0
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: PUSH
29306: LD_INT 1
29308: NEG
29309: PUSH
29310: LD_INT 1
29312: NEG
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: PUSH
29318: LD_INT 1
29320: NEG
29321: PUSH
29322: LD_INT 2
29324: NEG
29325: PUSH
29326: EMPTY
29327: LIST
29328: LIST
29329: PUSH
29330: LD_INT 0
29332: PUSH
29333: LD_INT 2
29335: NEG
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: PUSH
29341: LD_INT 1
29343: PUSH
29344: LD_INT 1
29346: NEG
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: PUSH
29355: LD_INT 2
29357: PUSH
29358: EMPTY
29359: LIST
29360: LIST
29361: PUSH
29362: LD_INT 0
29364: PUSH
29365: LD_INT 2
29367: PUSH
29368: EMPTY
29369: LIST
29370: LIST
29371: PUSH
29372: LD_INT 1
29374: NEG
29375: PUSH
29376: LD_INT 1
29378: PUSH
29379: EMPTY
29380: LIST
29381: LIST
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 3
29388: PUSH
29389: EMPTY
29390: LIST
29391: LIST
29392: PUSH
29393: LD_INT 0
29395: PUSH
29396: LD_INT 3
29398: PUSH
29399: EMPTY
29400: LIST
29401: LIST
29402: PUSH
29403: LD_INT 1
29405: NEG
29406: PUSH
29407: LD_INT 2
29409: PUSH
29410: EMPTY
29411: LIST
29412: LIST
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: LIST
29418: LIST
29419: LIST
29420: LIST
29421: LIST
29422: LIST
29423: LIST
29424: LIST
29425: LIST
29426: LIST
29427: LIST
29428: LIST
29429: LIST
29430: LIST
29431: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29432: LD_ADDR_VAR 0 12
29436: PUSH
29437: LD_INT 0
29439: PUSH
29440: LD_INT 0
29442: PUSH
29443: EMPTY
29444: LIST
29445: LIST
29446: PUSH
29447: LD_INT 0
29449: PUSH
29450: LD_INT 1
29452: NEG
29453: PUSH
29454: EMPTY
29455: LIST
29456: LIST
29457: PUSH
29458: LD_INT 1
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 1
29470: PUSH
29471: LD_INT 1
29473: PUSH
29474: EMPTY
29475: LIST
29476: LIST
29477: PUSH
29478: LD_INT 0
29480: PUSH
29481: LD_INT 1
29483: PUSH
29484: EMPTY
29485: LIST
29486: LIST
29487: PUSH
29488: LD_INT 1
29490: NEG
29491: PUSH
29492: LD_INT 0
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 1
29501: NEG
29502: PUSH
29503: LD_INT 1
29505: NEG
29506: PUSH
29507: EMPTY
29508: LIST
29509: LIST
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 1
29516: NEG
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 2
29524: PUSH
29525: LD_INT 0
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 2
29534: PUSH
29535: LD_INT 1
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: PUSH
29542: LD_INT 1
29544: NEG
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: LD_INT 2
29555: NEG
29556: PUSH
29557: LD_INT 0
29559: PUSH
29560: EMPTY
29561: LIST
29562: LIST
29563: PUSH
29564: LD_INT 2
29566: NEG
29567: PUSH
29568: LD_INT 1
29570: NEG
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: NEG
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: EMPTY
29584: LIST
29585: LIST
29586: PUSH
29587: LD_INT 3
29589: NEG
29590: PUSH
29591: LD_INT 0
29593: PUSH
29594: EMPTY
29595: LIST
29596: LIST
29597: PUSH
29598: LD_INT 3
29600: NEG
29601: PUSH
29602: LD_INT 1
29604: NEG
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: EMPTY
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: LIST
29621: LIST
29622: LIST
29623: LIST
29624: LIST
29625: LIST
29626: LIST
29627: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29628: LD_ADDR_VAR 0 13
29632: PUSH
29633: LD_INT 0
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 0
29645: PUSH
29646: LD_INT 1
29648: NEG
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 1
29656: PUSH
29657: LD_INT 0
29659: PUSH
29660: EMPTY
29661: LIST
29662: LIST
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: LD_INT 1
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: PUSH
29674: LD_INT 0
29676: PUSH
29677: LD_INT 1
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 1
29686: NEG
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: LD_INT 1
29701: NEG
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 1
29709: NEG
29710: PUSH
29711: LD_INT 2
29713: NEG
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 2
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 2
29731: PUSH
29732: LD_INT 2
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: PUSH
29742: LD_INT 2
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 2
29763: NEG
29764: PUSH
29765: LD_INT 2
29767: NEG
29768: PUSH
29769: EMPTY
29770: LIST
29771: LIST
29772: PUSH
29773: LD_INT 2
29775: NEG
29776: PUSH
29777: LD_INT 3
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 3
29787: NEG
29788: PUSH
29789: LD_INT 2
29791: NEG
29792: PUSH
29793: EMPTY
29794: LIST
29795: LIST
29796: PUSH
29797: LD_INT 3
29799: NEG
29800: PUSH
29801: LD_INT 3
29803: NEG
29804: PUSH
29805: EMPTY
29806: LIST
29807: LIST
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: LIST
29813: LIST
29814: LIST
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29827: LD_ADDR_VAR 0 14
29831: PUSH
29832: LD_INT 0
29834: PUSH
29835: LD_INT 0
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: LD_INT 1
29847: NEG
29848: PUSH
29849: EMPTY
29850: LIST
29851: LIST
29852: PUSH
29853: LD_INT 1
29855: PUSH
29856: LD_INT 0
29858: PUSH
29859: EMPTY
29860: LIST
29861: LIST
29862: PUSH
29863: LD_INT 1
29865: PUSH
29866: LD_INT 1
29868: PUSH
29869: EMPTY
29870: LIST
29871: LIST
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: LD_INT 1
29878: PUSH
29879: EMPTY
29880: LIST
29881: LIST
29882: PUSH
29883: LD_INT 1
29885: NEG
29886: PUSH
29887: LD_INT 0
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 1
29896: NEG
29897: PUSH
29898: LD_INT 1
29900: NEG
29901: PUSH
29902: EMPTY
29903: LIST
29904: LIST
29905: PUSH
29906: LD_INT 1
29908: NEG
29909: PUSH
29910: LD_INT 2
29912: NEG
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 2
29923: NEG
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: PUSH
29932: LD_INT 1
29934: NEG
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: PUSH
29943: LD_INT 2
29945: PUSH
29946: EMPTY
29947: LIST
29948: LIST
29949: PUSH
29950: LD_INT 0
29952: PUSH
29953: LD_INT 2
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: EMPTY
29968: LIST
29969: LIST
29970: PUSH
29971: LD_INT 1
29973: NEG
29974: PUSH
29975: LD_INT 3
29977: NEG
29978: PUSH
29979: EMPTY
29980: LIST
29981: LIST
29982: PUSH
29983: LD_INT 0
29985: PUSH
29986: LD_INT 3
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 1
29996: PUSH
29997: LD_INT 2
29999: NEG
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: EMPTY
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30023: LD_ADDR_VAR 0 15
30027: PUSH
30028: LD_INT 0
30030: PUSH
30031: LD_INT 0
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 0
30040: PUSH
30041: LD_INT 1
30043: NEG
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 1
30051: PUSH
30052: LD_INT 0
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 1
30061: PUSH
30062: LD_INT 1
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 0
30071: PUSH
30072: LD_INT 1
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: NEG
30082: PUSH
30083: LD_INT 0
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 1
30092: NEG
30093: PUSH
30094: LD_INT 1
30096: NEG
30097: PUSH
30098: EMPTY
30099: LIST
30100: LIST
30101: PUSH
30102: LD_INT 1
30104: PUSH
30105: LD_INT 1
30107: NEG
30108: PUSH
30109: EMPTY
30110: LIST
30111: LIST
30112: PUSH
30113: LD_INT 2
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 2
30125: PUSH
30126: LD_INT 1
30128: PUSH
30129: EMPTY
30130: LIST
30131: LIST
30132: PUSH
30133: LD_INT 1
30135: NEG
30136: PUSH
30137: LD_INT 1
30139: PUSH
30140: EMPTY
30141: LIST
30142: LIST
30143: PUSH
30144: LD_INT 2
30146: NEG
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: NEG
30158: PUSH
30159: LD_INT 1
30161: NEG
30162: PUSH
30163: EMPTY
30164: LIST
30165: LIST
30166: PUSH
30167: LD_INT 2
30169: PUSH
30170: LD_INT 1
30172: NEG
30173: PUSH
30174: EMPTY
30175: LIST
30176: LIST
30177: PUSH
30178: LD_INT 3
30180: PUSH
30181: LD_INT 0
30183: PUSH
30184: EMPTY
30185: LIST
30186: LIST
30187: PUSH
30188: LD_INT 3
30190: PUSH
30191: LD_INT 1
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: LIST
30208: LIST
30209: LIST
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30216: LD_ADDR_VAR 0 16
30220: PUSH
30221: LD_INT 0
30223: PUSH
30224: LD_INT 0
30226: PUSH
30227: EMPTY
30228: LIST
30229: LIST
30230: PUSH
30231: LD_INT 0
30233: PUSH
30234: LD_INT 1
30236: NEG
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 1
30244: PUSH
30245: LD_INT 0
30247: PUSH
30248: EMPTY
30249: LIST
30250: LIST
30251: PUSH
30252: LD_INT 1
30254: PUSH
30255: LD_INT 1
30257: PUSH
30258: EMPTY
30259: LIST
30260: LIST
30261: PUSH
30262: LD_INT 0
30264: PUSH
30265: LD_INT 1
30267: PUSH
30268: EMPTY
30269: LIST
30270: LIST
30271: PUSH
30272: LD_INT 1
30274: NEG
30275: PUSH
30276: LD_INT 0
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: LD_INT 1
30289: NEG
30290: PUSH
30291: EMPTY
30292: LIST
30293: LIST
30294: PUSH
30295: LD_INT 1
30297: NEG
30298: PUSH
30299: LD_INT 2
30301: NEG
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 2
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: PUSH
30320: LD_INT 2
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 1
30329: PUSH
30330: LD_INT 2
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 2
30339: NEG
30340: PUSH
30341: LD_INT 1
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: LD_INT 2
30351: NEG
30352: PUSH
30353: LD_INT 2
30355: NEG
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 3
30363: PUSH
30364: LD_INT 2
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 3
30373: PUSH
30374: LD_INT 3
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: PUSH
30381: LD_INT 2
30383: PUSH
30384: LD_INT 3
30386: PUSH
30387: EMPTY
30388: LIST
30389: LIST
30390: PUSH
30391: EMPTY
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: LIST
30401: LIST
30402: LIST
30403: LIST
30404: LIST
30405: LIST
30406: LIST
30407: LIST
30408: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30409: LD_ADDR_VAR 0 17
30413: PUSH
30414: LD_INT 0
30416: PUSH
30417: LD_INT 0
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 0
30426: PUSH
30427: LD_INT 1
30429: NEG
30430: PUSH
30431: EMPTY
30432: LIST
30433: LIST
30434: PUSH
30435: LD_INT 1
30437: PUSH
30438: LD_INT 0
30440: PUSH
30441: EMPTY
30442: LIST
30443: LIST
30444: PUSH
30445: LD_INT 1
30447: PUSH
30448: LD_INT 1
30450: PUSH
30451: EMPTY
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: NEG
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: NEG
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: EMPTY
30485: LIST
30486: LIST
30487: PUSH
30488: LD_INT 1
30490: NEG
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 0
30502: PUSH
30503: LD_INT 2
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 1
30513: PUSH
30514: LD_INT 1
30516: NEG
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 2
30524: PUSH
30525: LD_INT 0
30527: PUSH
30528: EMPTY
30529: LIST
30530: LIST
30531: PUSH
30532: LD_INT 2
30534: PUSH
30535: LD_INT 1
30537: PUSH
30538: EMPTY
30539: LIST
30540: LIST
30541: PUSH
30542: LD_INT 2
30544: PUSH
30545: LD_INT 2
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: LD_INT 2
30557: PUSH
30558: EMPTY
30559: LIST
30560: LIST
30561: PUSH
30562: LD_INT 0
30564: PUSH
30565: LD_INT 2
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 1
30574: NEG
30575: PUSH
30576: LD_INT 1
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 2
30585: NEG
30586: PUSH
30587: LD_INT 0
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 2
30596: NEG
30597: PUSH
30598: LD_INT 1
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 2
30608: NEG
30609: PUSH
30610: LD_INT 2
30612: NEG
30613: PUSH
30614: EMPTY
30615: LIST
30616: LIST
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: LIST
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: LIST
30627: LIST
30628: LIST
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30639: LD_ADDR_VAR 0 18
30643: PUSH
30644: LD_INT 0
30646: PUSH
30647: LD_INT 0
30649: PUSH
30650: EMPTY
30651: LIST
30652: LIST
30653: PUSH
30654: LD_INT 0
30656: PUSH
30657: LD_INT 1
30659: NEG
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PUSH
30665: LD_INT 1
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 1
30677: PUSH
30678: LD_INT 1
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 0
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: EMPTY
30703: LIST
30704: LIST
30705: PUSH
30706: LD_INT 1
30708: NEG
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 1
30720: NEG
30721: PUSH
30722: LD_INT 2
30724: NEG
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 0
30732: PUSH
30733: LD_INT 2
30735: NEG
30736: PUSH
30737: EMPTY
30738: LIST
30739: LIST
30740: PUSH
30741: LD_INT 1
30743: PUSH
30744: LD_INT 1
30746: NEG
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 2
30754: PUSH
30755: LD_INT 0
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 2
30764: PUSH
30765: LD_INT 1
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 2
30774: PUSH
30775: LD_INT 2
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: LD_INT 2
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 0
30794: PUSH
30795: LD_INT 2
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 1
30804: NEG
30805: PUSH
30806: LD_INT 1
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PUSH
30813: LD_INT 2
30815: NEG
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 2
30826: NEG
30827: PUSH
30828: LD_INT 1
30830: NEG
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: LD_INT 2
30838: NEG
30839: PUSH
30840: LD_INT 2
30842: NEG
30843: PUSH
30844: EMPTY
30845: LIST
30846: LIST
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: LIST
30852: LIST
30853: LIST
30854: LIST
30855: LIST
30856: LIST
30857: LIST
30858: LIST
30859: LIST
30860: LIST
30861: LIST
30862: LIST
30863: LIST
30864: LIST
30865: LIST
30866: LIST
30867: LIST
30868: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30869: LD_ADDR_VAR 0 19
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: LD_INT 0
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 0
30886: PUSH
30887: LD_INT 1
30889: NEG
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 1
30897: PUSH
30898: LD_INT 0
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: LD_INT 1
30907: PUSH
30908: LD_INT 1
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: LD_INT 0
30917: PUSH
30918: LD_INT 1
30920: PUSH
30921: EMPTY
30922: LIST
30923: LIST
30924: PUSH
30925: LD_INT 1
30927: NEG
30928: PUSH
30929: LD_INT 0
30931: PUSH
30932: EMPTY
30933: LIST
30934: LIST
30935: PUSH
30936: LD_INT 1
30938: NEG
30939: PUSH
30940: LD_INT 1
30942: NEG
30943: PUSH
30944: EMPTY
30945: LIST
30946: LIST
30947: PUSH
30948: LD_INT 1
30950: NEG
30951: PUSH
30952: LD_INT 2
30954: NEG
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 0
30962: PUSH
30963: LD_INT 2
30965: NEG
30966: PUSH
30967: EMPTY
30968: LIST
30969: LIST
30970: PUSH
30971: LD_INT 1
30973: PUSH
30974: LD_INT 1
30976: NEG
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 2
30984: PUSH
30985: LD_INT 0
30987: PUSH
30988: EMPTY
30989: LIST
30990: LIST
30991: PUSH
30992: LD_INT 2
30994: PUSH
30995: LD_INT 1
30997: PUSH
30998: EMPTY
30999: LIST
31000: LIST
31001: PUSH
31002: LD_INT 2
31004: PUSH
31005: LD_INT 2
31007: PUSH
31008: EMPTY
31009: LIST
31010: LIST
31011: PUSH
31012: LD_INT 1
31014: PUSH
31015: LD_INT 2
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: PUSH
31022: LD_INT 0
31024: PUSH
31025: LD_INT 2
31027: PUSH
31028: EMPTY
31029: LIST
31030: LIST
31031: PUSH
31032: LD_INT 1
31034: NEG
31035: PUSH
31036: LD_INT 1
31038: PUSH
31039: EMPTY
31040: LIST
31041: LIST
31042: PUSH
31043: LD_INT 2
31045: NEG
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 2
31056: NEG
31057: PUSH
31058: LD_INT 1
31060: NEG
31061: PUSH
31062: EMPTY
31063: LIST
31064: LIST
31065: PUSH
31066: LD_INT 2
31068: NEG
31069: PUSH
31070: LD_INT 2
31072: NEG
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: LIST
31082: LIST
31083: LIST
31084: LIST
31085: LIST
31086: LIST
31087: LIST
31088: LIST
31089: LIST
31090: LIST
31091: LIST
31092: LIST
31093: LIST
31094: LIST
31095: LIST
31096: LIST
31097: LIST
31098: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31099: LD_ADDR_VAR 0 20
31103: PUSH
31104: LD_INT 0
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: EMPTY
31122: LIST
31123: LIST
31124: PUSH
31125: LD_INT 1
31127: PUSH
31128: LD_INT 0
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: LD_INT 1
31137: PUSH
31138: LD_INT 1
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: LD_INT 1
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 1
31157: NEG
31158: PUSH
31159: LD_INT 0
31161: PUSH
31162: EMPTY
31163: LIST
31164: LIST
31165: PUSH
31166: LD_INT 1
31168: NEG
31169: PUSH
31170: LD_INT 1
31172: NEG
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 1
31180: NEG
31181: PUSH
31182: LD_INT 2
31184: NEG
31185: PUSH
31186: EMPTY
31187: LIST
31188: LIST
31189: PUSH
31190: LD_INT 0
31192: PUSH
31193: LD_INT 2
31195: NEG
31196: PUSH
31197: EMPTY
31198: LIST
31199: LIST
31200: PUSH
31201: LD_INT 1
31203: PUSH
31204: LD_INT 1
31206: NEG
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 2
31214: PUSH
31215: LD_INT 0
31217: PUSH
31218: EMPTY
31219: LIST
31220: LIST
31221: PUSH
31222: LD_INT 2
31224: PUSH
31225: LD_INT 1
31227: PUSH
31228: EMPTY
31229: LIST
31230: LIST
31231: PUSH
31232: LD_INT 2
31234: PUSH
31235: LD_INT 2
31237: PUSH
31238: EMPTY
31239: LIST
31240: LIST
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: LD_INT 2
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 0
31254: PUSH
31255: LD_INT 2
31257: PUSH
31258: EMPTY
31259: LIST
31260: LIST
31261: PUSH
31262: LD_INT 1
31264: NEG
31265: PUSH
31266: LD_INT 1
31268: PUSH
31269: EMPTY
31270: LIST
31271: LIST
31272: PUSH
31273: LD_INT 2
31275: NEG
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 2
31286: NEG
31287: PUSH
31288: LD_INT 1
31290: NEG
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 2
31298: NEG
31299: PUSH
31300: LD_INT 2
31302: NEG
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31329: LD_ADDR_VAR 0 21
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: LD_INT 1
31349: NEG
31350: PUSH
31351: EMPTY
31352: LIST
31353: LIST
31354: PUSH
31355: LD_INT 1
31357: PUSH
31358: LD_INT 0
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: LD_INT 1
31367: PUSH
31368: LD_INT 1
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 1
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 1
31387: NEG
31388: PUSH
31389: LD_INT 0
31391: PUSH
31392: EMPTY
31393: LIST
31394: LIST
31395: PUSH
31396: LD_INT 1
31398: NEG
31399: PUSH
31400: LD_INT 1
31402: NEG
31403: PUSH
31404: EMPTY
31405: LIST
31406: LIST
31407: PUSH
31408: LD_INT 1
31410: NEG
31411: PUSH
31412: LD_INT 2
31414: NEG
31415: PUSH
31416: EMPTY
31417: LIST
31418: LIST
31419: PUSH
31420: LD_INT 0
31422: PUSH
31423: LD_INT 2
31425: NEG
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 1
31433: PUSH
31434: LD_INT 1
31436: NEG
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 2
31444: PUSH
31445: LD_INT 0
31447: PUSH
31448: EMPTY
31449: LIST
31450: LIST
31451: PUSH
31452: LD_INT 2
31454: PUSH
31455: LD_INT 1
31457: PUSH
31458: EMPTY
31459: LIST
31460: LIST
31461: PUSH
31462: LD_INT 2
31464: PUSH
31465: LD_INT 2
31467: PUSH
31468: EMPTY
31469: LIST
31470: LIST
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: LD_INT 2
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: PUSH
31482: LD_INT 0
31484: PUSH
31485: LD_INT 2
31487: PUSH
31488: EMPTY
31489: LIST
31490: LIST
31491: PUSH
31492: LD_INT 1
31494: NEG
31495: PUSH
31496: LD_INT 1
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: LD_INT 2
31505: NEG
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 2
31516: NEG
31517: PUSH
31518: LD_INT 1
31520: NEG
31521: PUSH
31522: EMPTY
31523: LIST
31524: LIST
31525: PUSH
31526: LD_INT 2
31528: NEG
31529: PUSH
31530: LD_INT 2
31532: NEG
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: LIST
31542: LIST
31543: LIST
31544: LIST
31545: LIST
31546: LIST
31547: LIST
31548: LIST
31549: LIST
31550: LIST
31551: LIST
31552: LIST
31553: LIST
31554: LIST
31555: LIST
31556: LIST
31557: LIST
31558: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31559: LD_ADDR_VAR 0 22
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: LD_INT 1
31579: NEG
31580: PUSH
31581: EMPTY
31582: LIST
31583: LIST
31584: PUSH
31585: LD_INT 1
31587: PUSH
31588: LD_INT 0
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 1
31597: PUSH
31598: LD_INT 1
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 1
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 1
31617: NEG
31618: PUSH
31619: LD_INT 0
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 1
31628: NEG
31629: PUSH
31630: LD_INT 1
31632: NEG
31633: PUSH
31634: EMPTY
31635: LIST
31636: LIST
31637: PUSH
31638: LD_INT 1
31640: NEG
31641: PUSH
31642: LD_INT 2
31644: NEG
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 0
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 1
31663: PUSH
31664: LD_INT 1
31666: NEG
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 2
31674: PUSH
31675: LD_INT 0
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 2
31684: PUSH
31685: LD_INT 1
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: LD_INT 2
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 1
31704: PUSH
31705: LD_INT 2
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: LD_INT 0
31714: PUSH
31715: LD_INT 2
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 1
31724: NEG
31725: PUSH
31726: LD_INT 1
31728: PUSH
31729: EMPTY
31730: LIST
31731: LIST
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 2
31746: NEG
31747: PUSH
31748: LD_INT 1
31750: NEG
31751: PUSH
31752: EMPTY
31753: LIST
31754: LIST
31755: PUSH
31756: LD_INT 2
31758: NEG
31759: PUSH
31760: LD_INT 2
31762: NEG
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: LIST
31784: LIST
31785: LIST
31786: LIST
31787: LIST
31788: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31789: LD_ADDR_VAR 0 23
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: LD_INT 1
31809: NEG
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: PUSH
31818: LD_INT 0
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: LD_INT 1
31827: PUSH
31828: LD_INT 1
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 1
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 1
31847: NEG
31848: PUSH
31849: LD_INT 0
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: LD_INT 1
31858: NEG
31859: PUSH
31860: LD_INT 1
31862: NEG
31863: PUSH
31864: EMPTY
31865: LIST
31866: LIST
31867: PUSH
31868: LD_INT 1
31870: NEG
31871: PUSH
31872: LD_INT 2
31874: NEG
31875: PUSH
31876: EMPTY
31877: LIST
31878: LIST
31879: PUSH
31880: LD_INT 0
31882: PUSH
31883: LD_INT 2
31885: NEG
31886: PUSH
31887: EMPTY
31888: LIST
31889: LIST
31890: PUSH
31891: LD_INT 1
31893: PUSH
31894: LD_INT 1
31896: NEG
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: LD_INT 0
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 2
31914: PUSH
31915: LD_INT 1
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 2
31924: PUSH
31925: LD_INT 2
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PUSH
31932: LD_INT 1
31934: PUSH
31935: LD_INT 2
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PUSH
31942: LD_INT 0
31944: PUSH
31945: LD_INT 2
31947: PUSH
31948: EMPTY
31949: LIST
31950: LIST
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: LD_INT 1
31958: PUSH
31959: EMPTY
31960: LIST
31961: LIST
31962: PUSH
31963: LD_INT 2
31965: NEG
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 2
31976: NEG
31977: PUSH
31978: LD_INT 1
31980: NEG
31981: PUSH
31982: EMPTY
31983: LIST
31984: LIST
31985: PUSH
31986: LD_INT 2
31988: NEG
31989: PUSH
31990: LD_INT 2
31992: NEG
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 2
32000: NEG
32001: PUSH
32002: LD_INT 3
32004: NEG
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: NEG
32013: PUSH
32014: LD_INT 3
32016: NEG
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 1
32024: PUSH
32025: LD_INT 2
32027: NEG
32028: PUSH
32029: EMPTY
32030: LIST
32031: LIST
32032: PUSH
32033: LD_INT 2
32035: PUSH
32036: LD_INT 1
32038: NEG
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32069: LD_ADDR_VAR 0 24
32073: PUSH
32074: LD_INT 0
32076: PUSH
32077: LD_INT 0
32079: PUSH
32080: EMPTY
32081: LIST
32082: LIST
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: LD_INT 1
32089: NEG
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: LD_INT 0
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: LD_INT 1
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 0
32117: PUSH
32118: LD_INT 1
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: NEG
32128: PUSH
32129: LD_INT 0
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: LD_INT 1
32138: NEG
32139: PUSH
32140: LD_INT 1
32142: NEG
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 1
32150: NEG
32151: PUSH
32152: LD_INT 2
32154: NEG
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 0
32162: PUSH
32163: LD_INT 2
32165: NEG
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 1
32173: PUSH
32174: LD_INT 1
32176: NEG
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 2
32184: PUSH
32185: LD_INT 0
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 2
32194: PUSH
32195: LD_INT 1
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: LD_INT 2
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 1
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 0
32224: PUSH
32225: LD_INT 2
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 1
32234: NEG
32235: PUSH
32236: LD_INT 1
32238: PUSH
32239: EMPTY
32240: LIST
32241: LIST
32242: PUSH
32243: LD_INT 2
32245: NEG
32246: PUSH
32247: LD_INT 0
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 1
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: NEG
32269: PUSH
32270: LD_INT 2
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 1
32280: PUSH
32281: LD_INT 2
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 2
32291: PUSH
32292: LD_INT 1
32294: NEG
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 3
32302: PUSH
32303: LD_INT 1
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 3
32312: PUSH
32313: LD_INT 2
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32345: LD_ADDR_VAR 0 25
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: NEG
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: LD_INT 2
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 1
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: LD_INT 0
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 2
32480: PUSH
32481: LD_INT 2
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: LD_INT 2
32503: PUSH
32504: EMPTY
32505: LIST
32506: LIST
32507: PUSH
32508: LD_INT 1
32510: NEG
32511: PUSH
32512: LD_INT 1
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 2
32521: NEG
32522: PUSH
32523: LD_INT 0
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 2
32532: NEG
32533: PUSH
32534: LD_INT 1
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 2
32544: NEG
32545: PUSH
32546: LD_INT 2
32548: NEG
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PUSH
32554: LD_INT 3
32556: PUSH
32557: LD_INT 1
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: PUSH
32567: LD_INT 2
32569: PUSH
32570: EMPTY
32571: LIST
32572: LIST
32573: PUSH
32574: LD_INT 2
32576: PUSH
32577: LD_INT 3
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: LD_INT 1
32586: PUSH
32587: LD_INT 3
32589: PUSH
32590: EMPTY
32591: LIST
32592: LIST
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32619: LD_ADDR_VAR 0 26
32623: PUSH
32624: LD_INT 0
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 0
32636: PUSH
32637: LD_INT 1
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 0
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 1
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 0
32667: PUSH
32668: LD_INT 1
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: LD_INT 1
32677: NEG
32678: PUSH
32679: LD_INT 0
32681: PUSH
32682: EMPTY
32683: LIST
32684: LIST
32685: PUSH
32686: LD_INT 1
32688: NEG
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: EMPTY
32695: LIST
32696: LIST
32697: PUSH
32698: LD_INT 1
32700: NEG
32701: PUSH
32702: LD_INT 2
32704: NEG
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 0
32712: PUSH
32713: LD_INT 2
32715: NEG
32716: PUSH
32717: EMPTY
32718: LIST
32719: LIST
32720: PUSH
32721: LD_INT 1
32723: PUSH
32724: LD_INT 1
32726: NEG
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: LD_INT 0
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 2
32744: PUSH
32745: LD_INT 1
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 2
32754: PUSH
32755: LD_INT 2
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 1
32764: PUSH
32765: LD_INT 2
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 0
32774: PUSH
32775: LD_INT 2
32777: PUSH
32778: EMPTY
32779: LIST
32780: LIST
32781: PUSH
32782: LD_INT 1
32784: NEG
32785: PUSH
32786: LD_INT 1
32788: PUSH
32789: EMPTY
32790: LIST
32791: LIST
32792: PUSH
32793: LD_INT 2
32795: NEG
32796: PUSH
32797: LD_INT 0
32799: PUSH
32800: EMPTY
32801: LIST
32802: LIST
32803: PUSH
32804: LD_INT 2
32806: NEG
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 2
32818: NEG
32819: PUSH
32820: LD_INT 2
32822: NEG
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: LD_INT 3
32833: PUSH
32834: EMPTY
32835: LIST
32836: LIST
32837: PUSH
32838: LD_INT 1
32840: PUSH
32841: LD_INT 3
32843: PUSH
32844: EMPTY
32845: LIST
32846: LIST
32847: PUSH
32848: LD_INT 1
32850: NEG
32851: PUSH
32852: LD_INT 2
32854: PUSH
32855: EMPTY
32856: LIST
32857: LIST
32858: PUSH
32859: LD_INT 2
32861: NEG
32862: PUSH
32863: LD_INT 1
32865: PUSH
32866: EMPTY
32867: LIST
32868: LIST
32869: PUSH
32870: EMPTY
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32895: LD_ADDR_VAR 0 27
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: LD_INT 0
32905: PUSH
32906: EMPTY
32907: LIST
32908: LIST
32909: PUSH
32910: LD_INT 0
32912: PUSH
32913: LD_INT 1
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: LD_INT 0
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 1
32933: PUSH
32934: LD_INT 1
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 0
32943: PUSH
32944: LD_INT 1
32946: PUSH
32947: EMPTY
32948: LIST
32949: LIST
32950: PUSH
32951: LD_INT 1
32953: NEG
32954: PUSH
32955: LD_INT 0
32957: PUSH
32958: EMPTY
32959: LIST
32960: LIST
32961: PUSH
32962: LD_INT 1
32964: NEG
32965: PUSH
32966: LD_INT 1
32968: NEG
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 1
32976: NEG
32977: PUSH
32978: LD_INT 2
32980: NEG
32981: PUSH
32982: EMPTY
32983: LIST
32984: LIST
32985: PUSH
32986: LD_INT 0
32988: PUSH
32989: LD_INT 2
32991: NEG
32992: PUSH
32993: EMPTY
32994: LIST
32995: LIST
32996: PUSH
32997: LD_INT 1
32999: PUSH
33000: LD_INT 1
33002: NEG
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 2
33010: PUSH
33011: LD_INT 0
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: LD_INT 1
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 2
33030: PUSH
33031: LD_INT 2
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 1
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: LD_INT 2
33053: PUSH
33054: EMPTY
33055: LIST
33056: LIST
33057: PUSH
33058: LD_INT 1
33060: NEG
33061: PUSH
33062: LD_INT 1
33064: PUSH
33065: EMPTY
33066: LIST
33067: LIST
33068: PUSH
33069: LD_INT 2
33071: NEG
33072: PUSH
33073: LD_INT 0
33075: PUSH
33076: EMPTY
33077: LIST
33078: LIST
33079: PUSH
33080: LD_INT 2
33082: NEG
33083: PUSH
33084: LD_INT 1
33086: NEG
33087: PUSH
33088: EMPTY
33089: LIST
33090: LIST
33091: PUSH
33092: LD_INT 2
33094: NEG
33095: PUSH
33096: LD_INT 2
33098: NEG
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: NEG
33107: PUSH
33108: LD_INT 2
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 2
33117: NEG
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 3
33128: NEG
33129: PUSH
33130: LD_INT 1
33132: NEG
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 3
33140: NEG
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: EMPTY
33147: LIST
33148: LIST
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33175: LD_ADDR_VAR 0 28
33179: PUSH
33180: LD_INT 0
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 0
33192: PUSH
33193: LD_INT 1
33195: NEG
33196: PUSH
33197: EMPTY
33198: LIST
33199: LIST
33200: PUSH
33201: LD_INT 1
33203: PUSH
33204: LD_INT 0
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: PUSH
33211: LD_INT 1
33213: PUSH
33214: LD_INT 1
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 0
33223: PUSH
33224: LD_INT 1
33226: PUSH
33227: EMPTY
33228: LIST
33229: LIST
33230: PUSH
33231: LD_INT 1
33233: NEG
33234: PUSH
33235: LD_INT 0
33237: PUSH
33238: EMPTY
33239: LIST
33240: LIST
33241: PUSH
33242: LD_INT 1
33244: NEG
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 1
33256: NEG
33257: PUSH
33258: LD_INT 2
33260: NEG
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 0
33268: PUSH
33269: LD_INT 2
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 1
33279: PUSH
33280: LD_INT 1
33282: NEG
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 2
33290: PUSH
33291: LD_INT 0
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 2
33300: PUSH
33301: LD_INT 1
33303: PUSH
33304: EMPTY
33305: LIST
33306: LIST
33307: PUSH
33308: LD_INT 2
33310: PUSH
33311: LD_INT 2
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 1
33320: PUSH
33321: LD_INT 2
33323: PUSH
33324: EMPTY
33325: LIST
33326: LIST
33327: PUSH
33328: LD_INT 0
33330: PUSH
33331: LD_INT 2
33333: PUSH
33334: EMPTY
33335: LIST
33336: LIST
33337: PUSH
33338: LD_INT 1
33340: NEG
33341: PUSH
33342: LD_INT 1
33344: PUSH
33345: EMPTY
33346: LIST
33347: LIST
33348: PUSH
33349: LD_INT 2
33351: NEG
33352: PUSH
33353: LD_INT 0
33355: PUSH
33356: EMPTY
33357: LIST
33358: LIST
33359: PUSH
33360: LD_INT 2
33362: NEG
33363: PUSH
33364: LD_INT 1
33366: NEG
33367: PUSH
33368: EMPTY
33369: LIST
33370: LIST
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: LD_INT 2
33378: NEG
33379: PUSH
33380: EMPTY
33381: LIST
33382: LIST
33383: PUSH
33384: LD_INT 2
33386: NEG
33387: PUSH
33388: LD_INT 3
33390: NEG
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: NEG
33399: PUSH
33400: LD_INT 3
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 3
33410: NEG
33411: PUSH
33412: LD_INT 1
33414: NEG
33415: PUSH
33416: EMPTY
33417: LIST
33418: LIST
33419: PUSH
33420: LD_INT 3
33422: NEG
33423: PUSH
33424: LD_INT 2
33426: NEG
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: EMPTY
33433: LIST
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33457: LD_ADDR_VAR 0 29
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: LD_INT 0
33467: PUSH
33468: EMPTY
33469: LIST
33470: LIST
33471: PUSH
33472: LD_INT 0
33474: PUSH
33475: LD_INT 1
33477: NEG
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 1
33485: PUSH
33486: LD_INT 0
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 1
33495: PUSH
33496: LD_INT 1
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 0
33505: PUSH
33506: LD_INT 1
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 1
33515: NEG
33516: PUSH
33517: LD_INT 0
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 1
33526: NEG
33527: PUSH
33528: LD_INT 1
33530: NEG
33531: PUSH
33532: EMPTY
33533: LIST
33534: LIST
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: LD_INT 2
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 0
33550: PUSH
33551: LD_INT 2
33553: NEG
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 1
33561: PUSH
33562: LD_INT 1
33564: NEG
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 2
33572: PUSH
33573: LD_INT 0
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 2
33582: PUSH
33583: LD_INT 1
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 1
33592: PUSH
33593: LD_INT 2
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 0
33602: PUSH
33603: LD_INT 2
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 1
33612: NEG
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 2
33623: NEG
33624: PUSH
33625: LD_INT 1
33627: NEG
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PUSH
33633: LD_INT 2
33635: NEG
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 2
33647: NEG
33648: PUSH
33649: LD_INT 3
33651: NEG
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 2
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 3
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: LD_INT 3
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 1
33690: NEG
33691: PUSH
33692: LD_INT 2
33694: PUSH
33695: EMPTY
33696: LIST
33697: LIST
33698: PUSH
33699: LD_INT 3
33701: NEG
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: EMPTY
33708: LIST
33709: LIST
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33736: LD_ADDR_VAR 0 30
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 0
33753: PUSH
33754: LD_INT 1
33756: NEG
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: LD_INT 0
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 1
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 0
33784: PUSH
33785: LD_INT 1
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 1
33794: NEG
33795: PUSH
33796: LD_INT 0
33798: PUSH
33799: EMPTY
33800: LIST
33801: LIST
33802: PUSH
33803: LD_INT 1
33805: NEG
33806: PUSH
33807: LD_INT 1
33809: NEG
33810: PUSH
33811: EMPTY
33812: LIST
33813: LIST
33814: PUSH
33815: LD_INT 1
33817: NEG
33818: PUSH
33819: LD_INT 2
33821: NEG
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 0
33829: PUSH
33830: LD_INT 2
33832: NEG
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: LD_INT 1
33843: NEG
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 2
33851: PUSH
33852: LD_INT 0
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 2
33861: PUSH
33862: LD_INT 1
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: PUSH
33872: LD_INT 2
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: LD_INT 1
33881: PUSH
33882: LD_INT 2
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 1
33891: NEG
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: LD_INT 0
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 2
33913: NEG
33914: PUSH
33915: LD_INT 1
33917: NEG
33918: PUSH
33919: EMPTY
33920: LIST
33921: LIST
33922: PUSH
33923: LD_INT 1
33925: NEG
33926: PUSH
33927: LD_INT 3
33929: NEG
33930: PUSH
33931: EMPTY
33932: LIST
33933: LIST
33934: PUSH
33935: LD_INT 1
33937: PUSH
33938: LD_INT 2
33940: NEG
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 3
33948: PUSH
33949: LD_INT 2
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: PUSH
33956: LD_INT 2
33958: PUSH
33959: LD_INT 3
33961: PUSH
33962: EMPTY
33963: LIST
33964: LIST
33965: PUSH
33966: LD_INT 2
33968: NEG
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 3
33979: NEG
33980: PUSH
33981: LD_INT 1
33983: NEG
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: LIST
33997: LIST
33998: LIST
33999: LIST
34000: LIST
34001: LIST
34002: LIST
34003: LIST
34004: LIST
34005: LIST
34006: LIST
34007: LIST
34008: LIST
34009: LIST
34010: LIST
34011: LIST
34012: LIST
34013: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34014: LD_ADDR_VAR 0 31
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 0
34031: PUSH
34032: LD_INT 1
34034: NEG
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 1
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: PUSH
34050: LD_INT 1
34052: PUSH
34053: LD_INT 1
34055: PUSH
34056: EMPTY
34057: LIST
34058: LIST
34059: PUSH
34060: LD_INT 0
34062: PUSH
34063: LD_INT 1
34065: PUSH
34066: EMPTY
34067: LIST
34068: LIST
34069: PUSH
34070: LD_INT 1
34072: NEG
34073: PUSH
34074: LD_INT 0
34076: PUSH
34077: EMPTY
34078: LIST
34079: LIST
34080: PUSH
34081: LD_INT 1
34083: NEG
34084: PUSH
34085: LD_INT 1
34087: NEG
34088: PUSH
34089: EMPTY
34090: LIST
34091: LIST
34092: PUSH
34093: LD_INT 1
34095: NEG
34096: PUSH
34097: LD_INT 2
34099: NEG
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 2
34118: PUSH
34119: LD_INT 0
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 2
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 2
34138: PUSH
34139: LD_INT 2
34141: PUSH
34142: EMPTY
34143: LIST
34144: LIST
34145: PUSH
34146: LD_INT 1
34148: PUSH
34149: LD_INT 2
34151: PUSH
34152: EMPTY
34153: LIST
34154: LIST
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: LD_INT 2
34161: PUSH
34162: EMPTY
34163: LIST
34164: LIST
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: LD_INT 1
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: LD_INT 1
34183: NEG
34184: PUSH
34185: EMPTY
34186: LIST
34187: LIST
34188: PUSH
34189: LD_INT 2
34191: NEG
34192: PUSH
34193: LD_INT 2
34195: NEG
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 2
34203: NEG
34204: PUSH
34205: LD_INT 3
34207: NEG
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 2
34215: PUSH
34216: LD_INT 1
34218: NEG
34219: PUSH
34220: EMPTY
34221: LIST
34222: LIST
34223: PUSH
34224: LD_INT 3
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 1
34236: PUSH
34237: LD_INT 3
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 1
34246: NEG
34247: PUSH
34248: LD_INT 2
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 3
34257: NEG
34258: PUSH
34259: LD_INT 2
34261: NEG
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: LIST
34276: LIST
34277: LIST
34278: LIST
34279: LIST
34280: LIST
34281: LIST
34282: LIST
34283: LIST
34284: LIST
34285: LIST
34286: LIST
34287: LIST
34288: LIST
34289: LIST
34290: LIST
34291: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34292: LD_ADDR_VAR 0 32
34296: PUSH
34297: LD_INT 0
34299: PUSH
34300: LD_INT 0
34302: PUSH
34303: EMPTY
34304: LIST
34305: LIST
34306: PUSH
34307: LD_INT 0
34309: PUSH
34310: LD_INT 1
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 0
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: LD_INT 1
34330: PUSH
34331: LD_INT 1
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: PUSH
34338: LD_INT 0
34340: PUSH
34341: LD_INT 1
34343: PUSH
34344: EMPTY
34345: LIST
34346: LIST
34347: PUSH
34348: LD_INT 1
34350: NEG
34351: PUSH
34352: LD_INT 0
34354: PUSH
34355: EMPTY
34356: LIST
34357: LIST
34358: PUSH
34359: LD_INT 1
34361: NEG
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: EMPTY
34368: LIST
34369: LIST
34370: PUSH
34371: LD_INT 1
34373: NEG
34374: PUSH
34375: LD_INT 2
34377: NEG
34378: PUSH
34379: EMPTY
34380: LIST
34381: LIST
34382: PUSH
34383: LD_INT 0
34385: PUSH
34386: LD_INT 2
34388: NEG
34389: PUSH
34390: EMPTY
34391: LIST
34392: LIST
34393: PUSH
34394: LD_INT 1
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 2
34407: PUSH
34408: LD_INT 1
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 2
34417: PUSH
34418: LD_INT 2
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 1
34427: PUSH
34428: LD_INT 2
34430: PUSH
34431: EMPTY
34432: LIST
34433: LIST
34434: PUSH
34435: LD_INT 0
34437: PUSH
34438: LD_INT 2
34440: PUSH
34441: EMPTY
34442: LIST
34443: LIST
34444: PUSH
34445: LD_INT 1
34447: NEG
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 2
34458: NEG
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: LD_INT 2
34469: NEG
34470: PUSH
34471: LD_INT 1
34473: NEG
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: LD_INT 3
34485: NEG
34486: PUSH
34487: EMPTY
34488: LIST
34489: LIST
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: LD_INT 2
34496: NEG
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 3
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: PUSH
34515: LD_INT 3
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: NEG
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 3
34535: NEG
34536: PUSH
34537: LD_INT 1
34539: NEG
34540: PUSH
34541: EMPTY
34542: LIST
34543: LIST
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: LIST
34563: LIST
34564: LIST
34565: LIST
34566: LIST
34567: LIST
34568: LIST
34569: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34570: LD_ADDR_VAR 0 33
34574: PUSH
34575: LD_INT 0
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 1
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 1
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: LD_INT 1
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 1
34628: NEG
34629: PUSH
34630: LD_INT 0
34632: PUSH
34633: EMPTY
34634: LIST
34635: LIST
34636: PUSH
34637: LD_INT 1
34639: NEG
34640: PUSH
34641: LD_INT 1
34643: NEG
34644: PUSH
34645: EMPTY
34646: LIST
34647: LIST
34648: PUSH
34649: LD_INT 1
34651: NEG
34652: PUSH
34653: LD_INT 2
34655: NEG
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 1
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: EMPTY
34669: LIST
34670: LIST
34671: PUSH
34672: LD_INT 2
34674: PUSH
34675: LD_INT 0
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 2
34684: PUSH
34685: LD_INT 1
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 1
34694: PUSH
34695: LD_INT 2
34697: PUSH
34698: EMPTY
34699: LIST
34700: LIST
34701: PUSH
34702: LD_INT 0
34704: PUSH
34705: LD_INT 2
34707: PUSH
34708: EMPTY
34709: LIST
34710: LIST
34711: PUSH
34712: LD_INT 1
34714: NEG
34715: PUSH
34716: LD_INT 1
34718: PUSH
34719: EMPTY
34720: LIST
34721: LIST
34722: PUSH
34723: LD_INT 2
34725: NEG
34726: PUSH
34727: LD_INT 0
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: PUSH
34734: LD_INT 2
34736: NEG
34737: PUSH
34738: LD_INT 1
34740: NEG
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PUSH
34746: LD_INT 2
34748: NEG
34749: PUSH
34750: LD_INT 2
34752: NEG
34753: PUSH
34754: EMPTY
34755: LIST
34756: LIST
34757: PUSH
34758: LD_INT 2
34760: NEG
34761: PUSH
34762: LD_INT 3
34764: NEG
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 2
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 3
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: LD_INT 3
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 1
34803: NEG
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 3
34814: NEG
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: EMPTY
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: LIST
34836: LIST
34837: LIST
34838: LIST
34839: LIST
34840: LIST
34841: LIST
34842: LIST
34843: LIST
34844: LIST
34845: LIST
34846: LIST
34847: LIST
34848: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34849: LD_ADDR_VAR 0 34
34853: PUSH
34854: LD_INT 0
34856: PUSH
34857: LD_INT 0
34859: PUSH
34860: EMPTY
34861: LIST
34862: LIST
34863: PUSH
34864: LD_INT 0
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: LD_INT 1
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 0
34897: PUSH
34898: LD_INT 1
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: LD_INT 1
34907: NEG
34908: PUSH
34909: LD_INT 0
34911: PUSH
34912: EMPTY
34913: LIST
34914: LIST
34915: PUSH
34916: LD_INT 1
34918: NEG
34919: PUSH
34920: LD_INT 1
34922: NEG
34923: PUSH
34924: EMPTY
34925: LIST
34926: LIST
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: LD_INT 2
34934: NEG
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 0
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: LD_INT 1
34956: NEG
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 2
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: LD_INT 2
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: PUSH
34985: LD_INT 2
34987: PUSH
34988: EMPTY
34989: LIST
34990: LIST
34991: PUSH
34992: LD_INT 1
34994: NEG
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: EMPTY
35000: LIST
35001: LIST
35002: PUSH
35003: LD_INT 2
35005: NEG
35006: PUSH
35007: LD_INT 0
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: LD_INT 1
35020: NEG
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 2
35028: NEG
35029: PUSH
35030: LD_INT 2
35032: NEG
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 1
35040: NEG
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: EMPTY
35047: LIST
35048: LIST
35049: PUSH
35050: LD_INT 1
35052: PUSH
35053: LD_INT 2
35055: NEG
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 3
35063: PUSH
35064: LD_INT 2
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PUSH
35081: LD_INT 2
35083: NEG
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 3
35094: NEG
35095: PUSH
35096: LD_INT 1
35098: NEG
35099: PUSH
35100: EMPTY
35101: LIST
35102: LIST
35103: PUSH
35104: EMPTY
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35129: LD_ADDR_VAR 0 35
35133: PUSH
35134: LD_INT 0
35136: PUSH
35137: LD_INT 0
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: LD_INT 0
35146: PUSH
35147: LD_INT 1
35149: NEG
35150: PUSH
35151: EMPTY
35152: LIST
35153: LIST
35154: PUSH
35155: LD_INT 1
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: PUSH
35165: LD_INT 1
35167: PUSH
35168: LD_INT 1
35170: PUSH
35171: EMPTY
35172: LIST
35173: LIST
35174: PUSH
35175: LD_INT 0
35177: PUSH
35178: LD_INT 1
35180: PUSH
35181: EMPTY
35182: LIST
35183: LIST
35184: PUSH
35185: LD_INT 1
35187: NEG
35188: PUSH
35189: LD_INT 0
35191: PUSH
35192: EMPTY
35193: LIST
35194: LIST
35195: PUSH
35196: LD_INT 1
35198: NEG
35199: PUSH
35200: LD_INT 1
35202: NEG
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 2
35220: NEG
35221: PUSH
35222: LD_INT 1
35224: NEG
35225: PUSH
35226: EMPTY
35227: LIST
35228: LIST
35229: PUSH
35230: EMPTY
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35241: LD_ADDR_VAR 0 36
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: LD_INT 0
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 0
35258: PUSH
35259: LD_INT 1
35261: NEG
35262: PUSH
35263: EMPTY
35264: LIST
35265: LIST
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: LD_INT 0
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 1
35279: PUSH
35280: LD_INT 1
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: LD_INT 0
35289: PUSH
35290: LD_INT 1
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 1
35299: NEG
35300: PUSH
35301: LD_INT 0
35303: PUSH
35304: EMPTY
35305: LIST
35306: LIST
35307: PUSH
35308: LD_INT 1
35310: NEG
35311: PUSH
35312: LD_INT 1
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: LD_INT 2
35326: NEG
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 1
35334: PUSH
35335: LD_INT 2
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35353: LD_ADDR_VAR 0 37
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: LD_INT 0
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 0
35370: PUSH
35371: LD_INT 1
35373: NEG
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 1
35381: PUSH
35382: LD_INT 0
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 1
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: LD_INT 0
35401: PUSH
35402: LD_INT 1
35404: PUSH
35405: EMPTY
35406: LIST
35407: LIST
35408: PUSH
35409: LD_INT 1
35411: NEG
35412: PUSH
35413: LD_INT 0
35415: PUSH
35416: EMPTY
35417: LIST
35418: LIST
35419: PUSH
35420: LD_INT 1
35422: NEG
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 1
35434: PUSH
35435: LD_INT 1
35437: NEG
35438: PUSH
35439: EMPTY
35440: LIST
35441: LIST
35442: PUSH
35443: LD_INT 1
35445: NEG
35446: PUSH
35447: LD_INT 1
35449: PUSH
35450: EMPTY
35451: LIST
35452: LIST
35453: PUSH
35454: EMPTY
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35465: LD_ADDR_VAR 0 38
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: LD_INT 1
35485: NEG
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: LD_INT 0
35496: PUSH
35497: EMPTY
35498: LIST
35499: LIST
35500: PUSH
35501: LD_INT 1
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: LD_INT 0
35513: PUSH
35514: LD_INT 1
35516: PUSH
35517: EMPTY
35518: LIST
35519: LIST
35520: PUSH
35521: LD_INT 1
35523: NEG
35524: PUSH
35525: LD_INT 0
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: LD_INT 1
35538: NEG
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 2
35546: PUSH
35547: LD_INT 1
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: NEG
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: LIST
35570: LIST
35571: LIST
35572: LIST
35573: LIST
35574: LIST
35575: LIST
35576: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35577: LD_ADDR_VAR 0 39
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: LD_INT 0
35587: PUSH
35588: EMPTY
35589: LIST
35590: LIST
35591: PUSH
35592: LD_INT 0
35594: PUSH
35595: LD_INT 1
35597: NEG
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 1
35605: PUSH
35606: LD_INT 0
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: LD_INT 1
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: LD_INT 0
35625: PUSH
35626: LD_INT 1
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 1
35635: NEG
35636: PUSH
35637: LD_INT 0
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 1
35646: NEG
35647: PUSH
35648: LD_INT 1
35650: NEG
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 1
35658: NEG
35659: PUSH
35660: LD_INT 2
35662: NEG
35663: PUSH
35664: EMPTY
35665: LIST
35666: LIST
35667: PUSH
35668: LD_INT 1
35670: PUSH
35671: LD_INT 2
35673: PUSH
35674: EMPTY
35675: LIST
35676: LIST
35677: PUSH
35678: EMPTY
35679: LIST
35680: LIST
35681: LIST
35682: LIST
35683: LIST
35684: LIST
35685: LIST
35686: LIST
35687: LIST
35688: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35689: LD_ADDR_VAR 0 40
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: LD_INT 0
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 0
35706: PUSH
35707: LD_INT 1
35709: NEG
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 1
35717: PUSH
35718: LD_INT 0
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 1
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: LD_INT 0
35737: PUSH
35738: LD_INT 1
35740: PUSH
35741: EMPTY
35742: LIST
35743: LIST
35744: PUSH
35745: LD_INT 1
35747: NEG
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: PUSH
35756: LD_INT 1
35758: NEG
35759: PUSH
35760: LD_INT 1
35762: NEG
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 1
35770: PUSH
35771: LD_INT 1
35773: NEG
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: LD_INT 1
35785: PUSH
35786: EMPTY
35787: LIST
35788: LIST
35789: PUSH
35790: EMPTY
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35801: LD_ADDR_VAR 0 41
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: LD_INT 0
35811: PUSH
35812: EMPTY
35813: LIST
35814: LIST
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 1
35829: PUSH
35830: LD_INT 0
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 1
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 0
35849: PUSH
35850: LD_INT 1
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: PUSH
35857: LD_INT 1
35859: NEG
35860: PUSH
35861: LD_INT 0
35863: PUSH
35864: EMPTY
35865: LIST
35866: LIST
35867: PUSH
35868: LD_INT 1
35870: NEG
35871: PUSH
35872: LD_INT 1
35874: NEG
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 1
35882: NEG
35883: PUSH
35884: LD_INT 2
35886: NEG
35887: PUSH
35888: EMPTY
35889: LIST
35890: LIST
35891: PUSH
35892: LD_INT 1
35894: PUSH
35895: LD_INT 1
35897: NEG
35898: PUSH
35899: EMPTY
35900: LIST
35901: LIST
35902: PUSH
35903: LD_INT 2
35905: PUSH
35906: LD_INT 0
35908: PUSH
35909: EMPTY
35910: LIST
35911: LIST
35912: PUSH
35913: LD_INT 2
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: EMPTY
35920: LIST
35921: LIST
35922: PUSH
35923: LD_INT 2
35925: PUSH
35926: LD_INT 2
35928: PUSH
35929: EMPTY
35930: LIST
35931: LIST
35932: PUSH
35933: LD_INT 1
35935: PUSH
35936: LD_INT 2
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: NEG
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: NEG
35957: PUSH
35958: LD_INT 0
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: LD_INT 2
35967: NEG
35968: PUSH
35969: LD_INT 1
35971: NEG
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 2
35979: NEG
35980: PUSH
35981: LD_INT 2
35983: NEG
35984: PUSH
35985: EMPTY
35986: LIST
35987: LIST
35988: PUSH
35989: LD_INT 2
35991: NEG
35992: PUSH
35993: LD_INT 3
35995: NEG
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 2
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 3
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 3
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 3
36034: PUSH
36035: LD_INT 2
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 3
36044: PUSH
36045: LD_INT 3
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 2
36054: PUSH
36055: LD_INT 3
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: NEG
36065: PUSH
36066: LD_INT 1
36068: PUSH
36069: EMPTY
36070: LIST
36071: LIST
36072: PUSH
36073: LD_INT 3
36075: NEG
36076: PUSH
36077: LD_INT 0
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 3
36086: NEG
36087: PUSH
36088: LD_INT 1
36090: NEG
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 3
36098: NEG
36099: PUSH
36100: LD_INT 2
36102: NEG
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 3
36110: NEG
36111: PUSH
36112: LD_INT 3
36114: NEG
36115: PUSH
36116: EMPTY
36117: LIST
36118: LIST
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36151: LD_ADDR_VAR 0 42
36155: PUSH
36156: LD_INT 0
36158: PUSH
36159: LD_INT 0
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: LD_INT 1
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 1
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 1
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 0
36199: PUSH
36200: LD_INT 1
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 1
36209: NEG
36210: PUSH
36211: LD_INT 0
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: LD_INT 1
36224: NEG
36225: PUSH
36226: EMPTY
36227: LIST
36228: LIST
36229: PUSH
36230: LD_INT 1
36232: NEG
36233: PUSH
36234: LD_INT 2
36236: NEG
36237: PUSH
36238: EMPTY
36239: LIST
36240: LIST
36241: PUSH
36242: LD_INT 0
36244: PUSH
36245: LD_INT 2
36247: NEG
36248: PUSH
36249: EMPTY
36250: LIST
36251: LIST
36252: PUSH
36253: LD_INT 1
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 2
36266: PUSH
36267: LD_INT 1
36269: PUSH
36270: EMPTY
36271: LIST
36272: LIST
36273: PUSH
36274: LD_INT 2
36276: PUSH
36277: LD_INT 2
36279: PUSH
36280: EMPTY
36281: LIST
36282: LIST
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: LD_INT 2
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: PUSH
36294: LD_INT 0
36296: PUSH
36297: LD_INT 2
36299: PUSH
36300: EMPTY
36301: LIST
36302: LIST
36303: PUSH
36304: LD_INT 1
36306: NEG
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 2
36317: NEG
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 2
36329: NEG
36330: PUSH
36331: LD_INT 2
36333: NEG
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: PUSH
36339: LD_INT 2
36341: NEG
36342: PUSH
36343: LD_INT 3
36345: NEG
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 1
36353: NEG
36354: PUSH
36355: LD_INT 3
36357: NEG
36358: PUSH
36359: EMPTY
36360: LIST
36361: LIST
36362: PUSH
36363: LD_INT 0
36365: PUSH
36366: LD_INT 3
36368: NEG
36369: PUSH
36370: EMPTY
36371: LIST
36372: LIST
36373: PUSH
36374: LD_INT 1
36376: PUSH
36377: LD_INT 2
36379: NEG
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 3
36387: PUSH
36388: LD_INT 2
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 3
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 2
36407: PUSH
36408: LD_INT 3
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: PUSH
36418: LD_INT 3
36420: PUSH
36421: EMPTY
36422: LIST
36423: LIST
36424: PUSH
36425: LD_INT 0
36427: PUSH
36428: LD_INT 3
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: EMPTY
36443: LIST
36444: LIST
36445: PUSH
36446: LD_INT 3
36448: NEG
36449: PUSH
36450: LD_INT 2
36452: NEG
36453: PUSH
36454: EMPTY
36455: LIST
36456: LIST
36457: PUSH
36458: LD_INT 3
36460: NEG
36461: PUSH
36462: LD_INT 3
36464: NEG
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36501: LD_ADDR_VAR 0 43
36505: PUSH
36506: LD_INT 0
36508: PUSH
36509: LD_INT 0
36511: PUSH
36512: EMPTY
36513: LIST
36514: LIST
36515: PUSH
36516: LD_INT 0
36518: PUSH
36519: LD_INT 1
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 1
36529: PUSH
36530: LD_INT 0
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: PUSH
36540: LD_INT 1
36542: PUSH
36543: EMPTY
36544: LIST
36545: LIST
36546: PUSH
36547: LD_INT 0
36549: PUSH
36550: LD_INT 1
36552: PUSH
36553: EMPTY
36554: LIST
36555: LIST
36556: PUSH
36557: LD_INT 1
36559: NEG
36560: PUSH
36561: LD_INT 0
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: PUSH
36568: LD_INT 1
36570: NEG
36571: PUSH
36572: LD_INT 1
36574: NEG
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 1
36582: NEG
36583: PUSH
36584: LD_INT 2
36586: NEG
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 0
36594: PUSH
36595: LD_INT 2
36597: NEG
36598: PUSH
36599: EMPTY
36600: LIST
36601: LIST
36602: PUSH
36603: LD_INT 1
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 2
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: LD_INT 1
36629: PUSH
36630: EMPTY
36631: LIST
36632: LIST
36633: PUSH
36634: LD_INT 1
36636: PUSH
36637: LD_INT 2
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: PUSH
36644: LD_INT 0
36646: PUSH
36647: LD_INT 2
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 1
36656: NEG
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 2
36667: NEG
36668: PUSH
36669: LD_INT 0
36671: PUSH
36672: EMPTY
36673: LIST
36674: LIST
36675: PUSH
36676: LD_INT 2
36678: NEG
36679: PUSH
36680: LD_INT 1
36682: NEG
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 3
36694: NEG
36695: PUSH
36696: EMPTY
36697: LIST
36698: LIST
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: LD_INT 3
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: PUSH
36714: LD_INT 2
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: PUSH
36725: LD_INT 1
36727: NEG
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 3
36735: PUSH
36736: LD_INT 0
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 1
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: LD_INT 3
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: NEG
36776: PUSH
36777: LD_INT 2
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 2
36786: NEG
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 3
36797: NEG
36798: PUSH
36799: LD_INT 0
36801: PUSH
36802: EMPTY
36803: LIST
36804: LIST
36805: PUSH
36806: LD_INT 3
36808: NEG
36809: PUSH
36810: LD_INT 1
36812: NEG
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: EMPTY
36819: LIST
36820: LIST
36821: LIST
36822: LIST
36823: LIST
36824: LIST
36825: LIST
36826: LIST
36827: LIST
36828: LIST
36829: LIST
36830: LIST
36831: LIST
36832: LIST
36833: LIST
36834: LIST
36835: LIST
36836: LIST
36837: LIST
36838: LIST
36839: LIST
36840: LIST
36841: LIST
36842: LIST
36843: LIST
36844: LIST
36845: LIST
36846: LIST
36847: LIST
36848: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36849: LD_ADDR_VAR 0 44
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: LD_INT 0
36859: PUSH
36860: EMPTY
36861: LIST
36862: LIST
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: LD_INT 1
36877: PUSH
36878: LD_INT 0
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 1
36887: PUSH
36888: LD_INT 1
36890: PUSH
36891: EMPTY
36892: LIST
36893: LIST
36894: PUSH
36895: LD_INT 0
36897: PUSH
36898: LD_INT 1
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 1
36907: NEG
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 1
36918: NEG
36919: PUSH
36920: LD_INT 1
36922: NEG
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 1
36930: NEG
36931: PUSH
36932: LD_INT 2
36934: NEG
36935: PUSH
36936: EMPTY
36937: LIST
36938: LIST
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: LD_INT 1
36945: NEG
36946: PUSH
36947: EMPTY
36948: LIST
36949: LIST
36950: PUSH
36951: LD_INT 2
36953: PUSH
36954: LD_INT 0
36956: PUSH
36957: EMPTY
36958: LIST
36959: LIST
36960: PUSH
36961: LD_INT 2
36963: PUSH
36964: LD_INT 1
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: PUSH
36971: LD_INT 2
36973: PUSH
36974: LD_INT 2
36976: PUSH
36977: EMPTY
36978: LIST
36979: LIST
36980: PUSH
36981: LD_INT 1
36983: PUSH
36984: LD_INT 2
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 1
36993: NEG
36994: PUSH
36995: LD_INT 1
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: NEG
37005: PUSH
37006: LD_INT 0
37008: PUSH
37009: EMPTY
37010: LIST
37011: LIST
37012: PUSH
37013: LD_INT 2
37015: NEG
37016: PUSH
37017: LD_INT 1
37019: NEG
37020: PUSH
37021: EMPTY
37022: LIST
37023: LIST
37024: PUSH
37025: LD_INT 2
37027: NEG
37028: PUSH
37029: LD_INT 2
37031: NEG
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: NEG
37040: PUSH
37041: LD_INT 3
37043: NEG
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 2
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 3
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 3
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 3
37082: PUSH
37083: LD_INT 2
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 3
37092: PUSH
37093: LD_INT 3
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 2
37102: PUSH
37103: LD_INT 3
37105: PUSH
37106: EMPTY
37107: LIST
37108: LIST
37109: PUSH
37110: LD_INT 2
37112: NEG
37113: PUSH
37114: LD_INT 1
37116: PUSH
37117: EMPTY
37118: LIST
37119: LIST
37120: PUSH
37121: LD_INT 3
37123: NEG
37124: PUSH
37125: LD_INT 0
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 3
37134: NEG
37135: PUSH
37136: LD_INT 1
37138: NEG
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 3
37146: NEG
37147: PUSH
37148: LD_INT 2
37150: NEG
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 3
37158: NEG
37159: PUSH
37160: LD_INT 3
37162: NEG
37163: PUSH
37164: EMPTY
37165: LIST
37166: LIST
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: LIST
37181: LIST
37182: LIST
37183: LIST
37184: LIST
37185: LIST
37186: LIST
37187: LIST
37188: LIST
37189: LIST
37190: LIST
37191: LIST
37192: LIST
37193: LIST
37194: LIST
37195: LIST
37196: LIST
37197: LIST
37198: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37199: LD_ADDR_VAR 0 45
37203: PUSH
37204: LD_INT 0
37206: PUSH
37207: LD_INT 0
37209: PUSH
37210: EMPTY
37211: LIST
37212: LIST
37213: PUSH
37214: LD_INT 0
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: LD_INT 1
37227: PUSH
37228: LD_INT 0
37230: PUSH
37231: EMPTY
37232: LIST
37233: LIST
37234: PUSH
37235: LD_INT 1
37237: PUSH
37238: LD_INT 1
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 0
37247: PUSH
37248: LD_INT 1
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 1
37257: NEG
37258: PUSH
37259: LD_INT 0
37261: PUSH
37262: EMPTY
37263: LIST
37264: LIST
37265: PUSH
37266: LD_INT 1
37268: NEG
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: EMPTY
37275: LIST
37276: LIST
37277: PUSH
37278: LD_INT 1
37280: NEG
37281: PUSH
37282: LD_INT 2
37284: NEG
37285: PUSH
37286: EMPTY
37287: LIST
37288: LIST
37289: PUSH
37290: LD_INT 0
37292: PUSH
37293: LD_INT 2
37295: NEG
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: PUSH
37304: LD_INT 1
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 2
37314: PUSH
37315: LD_INT 1
37317: PUSH
37318: EMPTY
37319: LIST
37320: LIST
37321: PUSH
37322: LD_INT 2
37324: PUSH
37325: LD_INT 2
37327: PUSH
37328: EMPTY
37329: LIST
37330: LIST
37331: PUSH
37332: LD_INT 1
37334: PUSH
37335: LD_INT 2
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 1
37354: NEG
37355: PUSH
37356: LD_INT 1
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 2
37365: NEG
37366: PUSH
37367: LD_INT 1
37369: NEG
37370: PUSH
37371: EMPTY
37372: LIST
37373: LIST
37374: PUSH
37375: LD_INT 2
37377: NEG
37378: PUSH
37379: LD_INT 2
37381: NEG
37382: PUSH
37383: EMPTY
37384: LIST
37385: LIST
37386: PUSH
37387: LD_INT 2
37389: NEG
37390: PUSH
37391: LD_INT 3
37393: NEG
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 1
37401: NEG
37402: PUSH
37403: LD_INT 3
37405: NEG
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 3
37416: NEG
37417: PUSH
37418: EMPTY
37419: LIST
37420: LIST
37421: PUSH
37422: LD_INT 1
37424: PUSH
37425: LD_INT 2
37427: NEG
37428: PUSH
37429: EMPTY
37430: LIST
37431: LIST
37432: PUSH
37433: LD_INT 3
37435: PUSH
37436: LD_INT 2
37438: PUSH
37439: EMPTY
37440: LIST
37441: LIST
37442: PUSH
37443: LD_INT 3
37445: PUSH
37446: LD_INT 3
37448: PUSH
37449: EMPTY
37450: LIST
37451: LIST
37452: PUSH
37453: LD_INT 2
37455: PUSH
37456: LD_INT 3
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: PUSH
37466: LD_INT 3
37468: PUSH
37469: EMPTY
37470: LIST
37471: LIST
37472: PUSH
37473: LD_INT 0
37475: PUSH
37476: LD_INT 3
37478: PUSH
37479: EMPTY
37480: LIST
37481: LIST
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: LD_INT 2
37489: PUSH
37490: EMPTY
37491: LIST
37492: LIST
37493: PUSH
37494: LD_INT 3
37496: NEG
37497: PUSH
37498: LD_INT 2
37500: NEG
37501: PUSH
37502: EMPTY
37503: LIST
37504: LIST
37505: PUSH
37506: LD_INT 3
37508: NEG
37509: PUSH
37510: LD_INT 3
37512: NEG
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: LIST
37522: LIST
37523: LIST
37524: LIST
37525: LIST
37526: LIST
37527: LIST
37528: LIST
37529: LIST
37530: LIST
37531: LIST
37532: LIST
37533: LIST
37534: LIST
37535: LIST
37536: LIST
37537: LIST
37538: LIST
37539: LIST
37540: LIST
37541: LIST
37542: LIST
37543: LIST
37544: LIST
37545: LIST
37546: LIST
37547: LIST
37548: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37549: LD_ADDR_VAR 0 46
37553: PUSH
37554: LD_INT 0
37556: PUSH
37557: LD_INT 0
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 0
37566: PUSH
37567: LD_INT 1
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 1
37577: PUSH
37578: LD_INT 0
37580: PUSH
37581: EMPTY
37582: LIST
37583: LIST
37584: PUSH
37585: LD_INT 1
37587: PUSH
37588: LD_INT 1
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: PUSH
37595: LD_INT 0
37597: PUSH
37598: LD_INT 1
37600: PUSH
37601: EMPTY
37602: LIST
37603: LIST
37604: PUSH
37605: LD_INT 1
37607: NEG
37608: PUSH
37609: LD_INT 0
37611: PUSH
37612: EMPTY
37613: LIST
37614: LIST
37615: PUSH
37616: LD_INT 1
37618: NEG
37619: PUSH
37620: LD_INT 1
37622: NEG
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 1
37630: NEG
37631: PUSH
37632: LD_INT 2
37634: NEG
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 0
37642: PUSH
37643: LD_INT 2
37645: NEG
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: PUSH
37654: LD_INT 1
37656: NEG
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 2
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: PUSH
37678: EMPTY
37679: LIST
37680: LIST
37681: PUSH
37682: LD_INT 1
37684: PUSH
37685: LD_INT 2
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: PUSH
37692: LD_INT 0
37694: PUSH
37695: LD_INT 2
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 1
37704: NEG
37705: PUSH
37706: LD_INT 1
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 2
37715: NEG
37716: PUSH
37717: LD_INT 0
37719: PUSH
37720: EMPTY
37721: LIST
37722: LIST
37723: PUSH
37724: LD_INT 2
37726: NEG
37727: PUSH
37728: LD_INT 1
37730: NEG
37731: PUSH
37732: EMPTY
37733: LIST
37734: LIST
37735: PUSH
37736: LD_INT 1
37738: NEG
37739: PUSH
37740: LD_INT 3
37742: NEG
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 3
37753: NEG
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: PUSH
37762: LD_INT 2
37764: NEG
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: PUSH
37773: LD_INT 1
37775: NEG
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 3
37783: PUSH
37784: LD_INT 0
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: LD_INT 3
37793: PUSH
37794: LD_INT 1
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: PUSH
37804: LD_INT 3
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 0
37813: PUSH
37814: LD_INT 3
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 1
37823: NEG
37824: PUSH
37825: LD_INT 2
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 2
37834: NEG
37835: PUSH
37836: LD_INT 1
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 3
37845: NEG
37846: PUSH
37847: LD_INT 0
37849: PUSH
37850: EMPTY
37851: LIST
37852: LIST
37853: PUSH
37854: LD_INT 3
37856: NEG
37857: PUSH
37858: LD_INT 1
37860: NEG
37861: PUSH
37862: EMPTY
37863: LIST
37864: LIST
37865: PUSH
37866: EMPTY
37867: LIST
37868: LIST
37869: LIST
37870: LIST
37871: LIST
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: LIST
37896: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37897: LD_ADDR_VAR 0 47
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: LD_INT 0
37907: PUSH
37908: EMPTY
37909: LIST
37910: LIST
37911: PUSH
37912: LD_INT 0
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: LD_INT 1
37925: PUSH
37926: LD_INT 0
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 1
37935: PUSH
37936: LD_INT 1
37938: PUSH
37939: EMPTY
37940: LIST
37941: LIST
37942: PUSH
37943: LD_INT 0
37945: PUSH
37946: LD_INT 1
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 1
37955: NEG
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 1
37966: NEG
37967: PUSH
37968: LD_INT 1
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 1
37978: NEG
37979: PUSH
37980: LD_INT 2
37982: NEG
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 0
37990: PUSH
37991: LD_INT 2
37993: NEG
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 1
38001: PUSH
38002: LD_INT 1
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38048: LD_ADDR_VAR 0 48
38052: PUSH
38053: LD_INT 0
38055: PUSH
38056: LD_INT 0
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: LD_INT 1
38068: NEG
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PUSH
38074: LD_INT 1
38076: PUSH
38077: LD_INT 0
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 1
38086: PUSH
38087: LD_INT 1
38089: PUSH
38090: EMPTY
38091: LIST
38092: LIST
38093: PUSH
38094: LD_INT 0
38096: PUSH
38097: LD_INT 1
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 1
38106: NEG
38107: PUSH
38108: LD_INT 0
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: NEG
38118: PUSH
38119: LD_INT 1
38121: NEG
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: PUSH
38127: LD_INT 1
38129: NEG
38130: PUSH
38131: LD_INT 2
38133: NEG
38134: PUSH
38135: EMPTY
38136: LIST
38137: LIST
38138: PUSH
38139: LD_INT 0
38141: PUSH
38142: LD_INT 2
38144: NEG
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 1
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 2
38163: PUSH
38164: LD_INT 0
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: PUSH
38174: LD_INT 1
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: EMPTY
38182: LIST
38183: LIST
38184: LIST
38185: LIST
38186: LIST
38187: LIST
38188: LIST
38189: LIST
38190: LIST
38191: LIST
38192: LIST
38193: LIST
38194: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38195: LD_ADDR_VAR 0 49
38199: PUSH
38200: LD_INT 0
38202: PUSH
38203: LD_INT 0
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 0
38212: PUSH
38213: LD_INT 1
38215: NEG
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: LD_INT 0
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: LD_INT 1
38236: PUSH
38237: EMPTY
38238: LIST
38239: LIST
38240: PUSH
38241: LD_INT 0
38243: PUSH
38244: LD_INT 1
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 1
38253: NEG
38254: PUSH
38255: LD_INT 0
38257: PUSH
38258: EMPTY
38259: LIST
38260: LIST
38261: PUSH
38262: LD_INT 1
38264: NEG
38265: PUSH
38266: LD_INT 1
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 2
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 2
38307: PUSH
38308: LD_INT 2
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 1
38317: PUSH
38318: LD_INT 2
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: LIST
38329: LIST
38330: LIST
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38339: LD_ADDR_VAR 0 50
38343: PUSH
38344: LD_INT 0
38346: PUSH
38347: LD_INT 0
38349: PUSH
38350: EMPTY
38351: LIST
38352: LIST
38353: PUSH
38354: LD_INT 0
38356: PUSH
38357: LD_INT 1
38359: NEG
38360: PUSH
38361: EMPTY
38362: LIST
38363: LIST
38364: PUSH
38365: LD_INT 1
38367: PUSH
38368: LD_INT 0
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 1
38377: PUSH
38378: LD_INT 1
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: LD_INT 0
38387: PUSH
38388: LD_INT 1
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 1
38397: NEG
38398: PUSH
38399: LD_INT 0
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: NEG
38409: PUSH
38410: LD_INT 1
38412: NEG
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 1
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 2
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 1
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 0
38450: PUSH
38451: LD_INT 2
38453: PUSH
38454: EMPTY
38455: LIST
38456: LIST
38457: PUSH
38458: LD_INT 1
38460: NEG
38461: PUSH
38462: LD_INT 1
38464: PUSH
38465: EMPTY
38466: LIST
38467: LIST
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: LIST
38473: LIST
38474: LIST
38475: LIST
38476: LIST
38477: LIST
38478: LIST
38479: LIST
38480: LIST
38481: LIST
38482: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38483: LD_ADDR_VAR 0 51
38487: PUSH
38488: LD_INT 0
38490: PUSH
38491: LD_INT 0
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PUSH
38498: LD_INT 0
38500: PUSH
38501: LD_INT 1
38503: NEG
38504: PUSH
38505: EMPTY
38506: LIST
38507: LIST
38508: PUSH
38509: LD_INT 1
38511: PUSH
38512: LD_INT 0
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: LD_INT 1
38524: PUSH
38525: EMPTY
38526: LIST
38527: LIST
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 1
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 1
38541: NEG
38542: PUSH
38543: LD_INT 0
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: NEG
38553: PUSH
38554: LD_INT 1
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 1
38564: PUSH
38565: LD_INT 2
38567: PUSH
38568: EMPTY
38569: LIST
38570: LIST
38571: PUSH
38572: LD_INT 0
38574: PUSH
38575: LD_INT 2
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: PUSH
38589: EMPTY
38590: LIST
38591: LIST
38592: PUSH
38593: LD_INT 2
38595: NEG
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 2
38606: NEG
38607: PUSH
38608: LD_INT 1
38610: NEG
38611: PUSH
38612: EMPTY
38613: LIST
38614: LIST
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: LIST
38620: LIST
38621: LIST
38622: LIST
38623: LIST
38624: LIST
38625: LIST
38626: LIST
38627: LIST
38628: LIST
38629: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38630: LD_ADDR_VAR 0 52
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: LD_INT 0
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 0
38647: PUSH
38648: LD_INT 1
38650: NEG
38651: PUSH
38652: EMPTY
38653: LIST
38654: LIST
38655: PUSH
38656: LD_INT 1
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: LD_INT 1
38671: PUSH
38672: EMPTY
38673: LIST
38674: LIST
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: LD_INT 1
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: LD_INT 0
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: NEG
38700: PUSH
38701: LD_INT 1
38703: NEG
38704: PUSH
38705: EMPTY
38706: LIST
38707: LIST
38708: PUSH
38709: LD_INT 1
38711: NEG
38712: PUSH
38713: LD_INT 2
38715: NEG
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 1
38723: NEG
38724: PUSH
38725: LD_INT 1
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: NEG
38735: PUSH
38736: LD_INT 0
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 2
38745: NEG
38746: PUSH
38747: LD_INT 1
38749: NEG
38750: PUSH
38751: EMPTY
38752: LIST
38753: LIST
38754: PUSH
38755: LD_INT 2
38757: NEG
38758: PUSH
38759: LD_INT 2
38761: NEG
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: LIST
38771: LIST
38772: LIST
38773: LIST
38774: LIST
38775: LIST
38776: LIST
38777: LIST
38778: LIST
38779: LIST
38780: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38781: LD_ADDR_VAR 0 53
38785: PUSH
38786: LD_INT 0
38788: PUSH
38789: LD_INT 0
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 0
38798: PUSH
38799: LD_INT 1
38801: NEG
38802: PUSH
38803: EMPTY
38804: LIST
38805: LIST
38806: PUSH
38807: LD_INT 1
38809: PUSH
38810: LD_INT 0
38812: PUSH
38813: EMPTY
38814: LIST
38815: LIST
38816: PUSH
38817: LD_INT 1
38819: PUSH
38820: LD_INT 1
38822: PUSH
38823: EMPTY
38824: LIST
38825: LIST
38826: PUSH
38827: LD_INT 0
38829: PUSH
38830: LD_INT 1
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: NEG
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 1
38850: NEG
38851: PUSH
38852: LD_INT 1
38854: NEG
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 1
38862: NEG
38863: PUSH
38864: LD_INT 2
38866: NEG
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 0
38874: PUSH
38875: LD_INT 2
38877: NEG
38878: PUSH
38879: EMPTY
38880: LIST
38881: LIST
38882: PUSH
38883: LD_INT 1
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 2
38896: PUSH
38897: LD_INT 0
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 2
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 2
38916: PUSH
38917: LD_INT 2
38919: PUSH
38920: EMPTY
38921: LIST
38922: LIST
38923: PUSH
38924: LD_INT 1
38926: PUSH
38927: LD_INT 2
38929: PUSH
38930: EMPTY
38931: LIST
38932: LIST
38933: PUSH
38934: LD_INT 0
38936: PUSH
38937: LD_INT 2
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 1
38946: NEG
38947: PUSH
38948: LD_INT 1
38950: PUSH
38951: EMPTY
38952: LIST
38953: LIST
38954: PUSH
38955: LD_INT 2
38957: NEG
38958: PUSH
38959: LD_INT 0
38961: PUSH
38962: EMPTY
38963: LIST
38964: LIST
38965: PUSH
38966: LD_INT 2
38968: NEG
38969: PUSH
38970: LD_INT 1
38972: NEG
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 2
38980: NEG
38981: PUSH
38982: LD_INT 2
38984: NEG
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: LIST
39009: LIST
39010: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39011: LD_ADDR_VAR 0 54
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: LD_INT 0
39021: PUSH
39022: EMPTY
39023: LIST
39024: LIST
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: LD_INT 1
39031: NEG
39032: PUSH
39033: EMPTY
39034: LIST
39035: LIST
39036: PUSH
39037: LD_INT 1
39039: PUSH
39040: LD_INT 0
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: LD_INT 1
39049: PUSH
39050: LD_INT 1
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 0
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: PUSH
39067: LD_INT 1
39069: NEG
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: EMPTY
39075: LIST
39076: LIST
39077: PUSH
39078: LD_INT 1
39080: NEG
39081: PUSH
39082: LD_INT 1
39084: NEG
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: LD_INT 2
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 2
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 1
39115: PUSH
39116: LD_INT 1
39118: NEG
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 2
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 2
39136: PUSH
39137: LD_INT 1
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 2
39146: PUSH
39147: LD_INT 2
39149: PUSH
39150: EMPTY
39151: LIST
39152: LIST
39153: PUSH
39154: LD_INT 1
39156: PUSH
39157: LD_INT 2
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 0
39166: PUSH
39167: LD_INT 2
39169: PUSH
39170: EMPTY
39171: LIST
39172: LIST
39173: PUSH
39174: LD_INT 1
39176: NEG
39177: PUSH
39178: LD_INT 1
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 2
39187: NEG
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 2
39198: NEG
39199: PUSH
39200: LD_INT 1
39202: NEG
39203: PUSH
39204: EMPTY
39205: LIST
39206: LIST
39207: PUSH
39208: LD_INT 2
39210: NEG
39211: PUSH
39212: LD_INT 2
39214: NEG
39215: PUSH
39216: EMPTY
39217: LIST
39218: LIST
39219: PUSH
39220: EMPTY
39221: LIST
39222: LIST
39223: LIST
39224: LIST
39225: LIST
39226: LIST
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: LIST
39235: LIST
39236: LIST
39237: LIST
39238: LIST
39239: LIST
39240: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39241: LD_ADDR_VAR 0 55
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: LD_INT 0
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 1
39261: NEG
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 1
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: PUSH
39280: LD_INT 1
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 1
39292: PUSH
39293: EMPTY
39294: LIST
39295: LIST
39296: PUSH
39297: LD_INT 1
39299: NEG
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: EMPTY
39305: LIST
39306: LIST
39307: PUSH
39308: LD_INT 1
39310: NEG
39311: PUSH
39312: LD_INT 1
39314: NEG
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: LD_INT 2
39326: NEG
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 0
39334: PUSH
39335: LD_INT 2
39337: NEG
39338: PUSH
39339: EMPTY
39340: LIST
39341: LIST
39342: PUSH
39343: LD_INT 1
39345: PUSH
39346: LD_INT 1
39348: NEG
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 2
39356: PUSH
39357: LD_INT 0
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: LD_INT 2
39366: PUSH
39367: LD_INT 1
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: PUSH
39374: LD_INT 2
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 1
39386: PUSH
39387: LD_INT 2
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 0
39396: PUSH
39397: LD_INT 2
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: LD_INT 1
39406: NEG
39407: PUSH
39408: LD_INT 1
39410: PUSH
39411: EMPTY
39412: LIST
39413: LIST
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 2
39428: NEG
39429: PUSH
39430: LD_INT 1
39432: NEG
39433: PUSH
39434: EMPTY
39435: LIST
39436: LIST
39437: PUSH
39438: LD_INT 2
39440: NEG
39441: PUSH
39442: LD_INT 2
39444: NEG
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: LIST
39458: LIST
39459: LIST
39460: LIST
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: LIST
39468: LIST
39469: LIST
39470: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39471: LD_ADDR_VAR 0 56
39475: PUSH
39476: LD_INT 0
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: LD_INT 1
39491: NEG
39492: PUSH
39493: EMPTY
39494: LIST
39495: LIST
39496: PUSH
39497: LD_INT 1
39499: PUSH
39500: LD_INT 0
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: LD_INT 1
39509: PUSH
39510: LD_INT 1
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 0
39519: PUSH
39520: LD_INT 1
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 1
39529: NEG
39530: PUSH
39531: LD_INT 0
39533: PUSH
39534: EMPTY
39535: LIST
39536: LIST
39537: PUSH
39538: LD_INT 1
39540: NEG
39541: PUSH
39542: LD_INT 1
39544: NEG
39545: PUSH
39546: EMPTY
39547: LIST
39548: LIST
39549: PUSH
39550: LD_INT 1
39552: NEG
39553: PUSH
39554: LD_INT 2
39556: NEG
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 0
39564: PUSH
39565: LD_INT 2
39567: NEG
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 1
39575: PUSH
39576: LD_INT 1
39578: NEG
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 2
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: EMPTY
39591: LIST
39592: LIST
39593: PUSH
39594: LD_INT 2
39596: PUSH
39597: LD_INT 1
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: LD_INT 2
39606: PUSH
39607: LD_INT 2
39609: PUSH
39610: EMPTY
39611: LIST
39612: LIST
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: LD_INT 2
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: LD_INT 2
39629: PUSH
39630: EMPTY
39631: LIST
39632: LIST
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 2
39658: NEG
39659: PUSH
39660: LD_INT 1
39662: NEG
39663: PUSH
39664: EMPTY
39665: LIST
39666: LIST
39667: PUSH
39668: LD_INT 2
39670: NEG
39671: PUSH
39672: LD_INT 2
39674: NEG
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: LIST
39692: LIST
39693: LIST
39694: LIST
39695: LIST
39696: LIST
39697: LIST
39698: LIST
39699: LIST
39700: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39701: LD_ADDR_VAR 0 57
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: LD_INT 1
39721: NEG
39722: PUSH
39723: EMPTY
39724: LIST
39725: LIST
39726: PUSH
39727: LD_INT 1
39729: PUSH
39730: LD_INT 0
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 1
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 1
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 1
39759: NEG
39760: PUSH
39761: LD_INT 0
39763: PUSH
39764: EMPTY
39765: LIST
39766: LIST
39767: PUSH
39768: LD_INT 1
39770: NEG
39771: PUSH
39772: LD_INT 1
39774: NEG
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 1
39782: NEG
39783: PUSH
39784: LD_INT 2
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 0
39794: PUSH
39795: LD_INT 2
39797: NEG
39798: PUSH
39799: EMPTY
39800: LIST
39801: LIST
39802: PUSH
39803: LD_INT 1
39805: PUSH
39806: LD_INT 1
39808: NEG
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 2
39816: PUSH
39817: LD_INT 0
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 2
39826: PUSH
39827: LD_INT 1
39829: PUSH
39830: EMPTY
39831: LIST
39832: LIST
39833: PUSH
39834: LD_INT 2
39836: PUSH
39837: LD_INT 2
39839: PUSH
39840: EMPTY
39841: LIST
39842: LIST
39843: PUSH
39844: LD_INT 1
39846: PUSH
39847: LD_INT 2
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: PUSH
39854: LD_INT 0
39856: PUSH
39857: LD_INT 2
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: PUSH
39864: LD_INT 1
39866: NEG
39867: PUSH
39868: LD_INT 1
39870: PUSH
39871: EMPTY
39872: LIST
39873: LIST
39874: PUSH
39875: LD_INT 2
39877: NEG
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 2
39888: NEG
39889: PUSH
39890: LD_INT 1
39892: NEG
39893: PUSH
39894: EMPTY
39895: LIST
39896: LIST
39897: PUSH
39898: LD_INT 2
39900: NEG
39901: PUSH
39902: LD_INT 2
39904: NEG
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: LIST
39914: LIST
39915: LIST
39916: LIST
39917: LIST
39918: LIST
39919: LIST
39920: LIST
39921: LIST
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: LIST
39927: LIST
39928: LIST
39929: LIST
39930: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39931: LD_ADDR_VAR 0 58
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: LD_INT 1
39951: NEG
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: LD_INT 1
39959: PUSH
39960: LD_INT 0
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: LD_INT 1
39969: PUSH
39970: LD_INT 1
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: LD_INT 1
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 1
39989: NEG
39990: PUSH
39991: LD_INT 0
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PUSH
39998: LD_INT 1
40000: NEG
40001: PUSH
40002: LD_INT 1
40004: NEG
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: LD_INT 1
40012: NEG
40013: PUSH
40014: LD_INT 2
40016: NEG
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 0
40024: PUSH
40025: LD_INT 2
40027: NEG
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 1
40035: PUSH
40036: LD_INT 1
40038: NEG
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 2
40046: PUSH
40047: LD_INT 0
40049: PUSH
40050: EMPTY
40051: LIST
40052: LIST
40053: PUSH
40054: LD_INT 2
40056: PUSH
40057: LD_INT 1
40059: PUSH
40060: EMPTY
40061: LIST
40062: LIST
40063: PUSH
40064: LD_INT 2
40066: PUSH
40067: LD_INT 2
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: PUSH
40074: LD_INT 1
40076: PUSH
40077: LD_INT 2
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 0
40086: PUSH
40087: LD_INT 2
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 1
40096: NEG
40097: PUSH
40098: LD_INT 1
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 2
40107: NEG
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 2
40118: NEG
40119: PUSH
40120: LD_INT 1
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 2
40130: NEG
40131: PUSH
40132: LD_INT 2
40134: NEG
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: LIST
40144: LIST
40145: LIST
40146: LIST
40147: LIST
40148: LIST
40149: LIST
40150: LIST
40151: LIST
40152: LIST
40153: LIST
40154: LIST
40155: LIST
40156: LIST
40157: LIST
40158: LIST
40159: LIST
40160: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40161: LD_ADDR_VAR 0 59
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: LD_INT 1
40181: NEG
40182: PUSH
40183: EMPTY
40184: LIST
40185: LIST
40186: PUSH
40187: LD_INT 1
40189: PUSH
40190: LD_INT 0
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: LD_INT 1
40199: PUSH
40200: LD_INT 1
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 1
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 1
40219: NEG
40220: PUSH
40221: LD_INT 0
40223: PUSH
40224: EMPTY
40225: LIST
40226: LIST
40227: PUSH
40228: LD_INT 1
40230: NEG
40231: PUSH
40232: LD_INT 1
40234: NEG
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: LIST
40244: LIST
40245: LIST
40246: LIST
40247: LIST
40248: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40249: LD_ADDR_VAR 0 60
40253: PUSH
40254: LD_INT 0
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: NEG
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 1
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: PUSH
40288: LD_INT 1
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 0
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: LD_INT 0
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 1
40318: NEG
40319: PUSH
40320: LD_INT 1
40322: NEG
40323: PUSH
40324: EMPTY
40325: LIST
40326: LIST
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40337: LD_ADDR_VAR 0 61
40341: PUSH
40342: LD_INT 0
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: NEG
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: PUSH
40363: LD_INT 1
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: PUSH
40376: LD_INT 1
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 0
40385: PUSH
40386: LD_INT 1
40388: PUSH
40389: EMPTY
40390: LIST
40391: LIST
40392: PUSH
40393: LD_INT 1
40395: NEG
40396: PUSH
40397: LD_INT 0
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: NEG
40407: PUSH
40408: LD_INT 1
40410: NEG
40411: PUSH
40412: EMPTY
40413: LIST
40414: LIST
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: LIST
40420: LIST
40421: LIST
40422: LIST
40423: LIST
40424: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40425: LD_ADDR_VAR 0 62
40429: PUSH
40430: LD_INT 0
40432: PUSH
40433: LD_INT 0
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: LD_INT 1
40445: NEG
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: LD_INT 1
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 1
40463: PUSH
40464: LD_INT 1
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 1
40476: PUSH
40477: EMPTY
40478: LIST
40479: LIST
40480: PUSH
40481: LD_INT 1
40483: NEG
40484: PUSH
40485: LD_INT 0
40487: PUSH
40488: EMPTY
40489: LIST
40490: LIST
40491: PUSH
40492: LD_INT 1
40494: NEG
40495: PUSH
40496: LD_INT 1
40498: NEG
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40513: LD_ADDR_VAR 0 63
40517: PUSH
40518: LD_INT 0
40520: PUSH
40521: LD_INT 0
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: PUSH
40552: LD_INT 1
40554: PUSH
40555: EMPTY
40556: LIST
40557: LIST
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 1
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 1
40571: NEG
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: NEG
40583: PUSH
40584: LD_INT 1
40586: NEG
40587: PUSH
40588: EMPTY
40589: LIST
40590: LIST
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: LIST
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40601: LD_ADDR_VAR 0 64
40605: PUSH
40606: LD_INT 0
40608: PUSH
40609: LD_INT 0
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: NEG
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 1
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: PUSH
40640: LD_INT 1
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: PUSH
40647: LD_INT 0
40649: PUSH
40650: LD_INT 1
40652: PUSH
40653: EMPTY
40654: LIST
40655: LIST
40656: PUSH
40657: LD_INT 1
40659: NEG
40660: PUSH
40661: LD_INT 0
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 1
40670: NEG
40671: PUSH
40672: LD_INT 1
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: ST_TO_ADDR
// end ; 1 :
40689: GO 46586
40691: LD_INT 1
40693: DOUBLE
40694: EQUAL
40695: IFTRUE 40699
40697: GO 43322
40699: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40700: LD_ADDR_VAR 0 11
40704: PUSH
40705: LD_INT 1
40707: NEG
40708: PUSH
40709: LD_INT 3
40711: NEG
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 0
40719: PUSH
40720: LD_INT 3
40722: NEG
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 1
40730: PUSH
40731: LD_INT 2
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: LIST
40743: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40744: LD_ADDR_VAR 0 12
40748: PUSH
40749: LD_INT 2
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: LD_INT 3
40762: PUSH
40763: LD_INT 0
40765: PUSH
40766: EMPTY
40767: LIST
40768: LIST
40769: PUSH
40770: LD_INT 3
40772: PUSH
40773: LD_INT 1
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40785: LD_ADDR_VAR 0 13
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: LD_INT 2
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: PUSH
40800: LD_INT 3
40802: PUSH
40803: LD_INT 3
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 2
40812: PUSH
40813: LD_INT 3
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: EMPTY
40821: LIST
40822: LIST
40823: LIST
40824: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40825: LD_ADDR_VAR 0 14
40829: PUSH
40830: LD_INT 1
40832: PUSH
40833: LD_INT 3
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 0
40842: PUSH
40843: LD_INT 3
40845: PUSH
40846: EMPTY
40847: LIST
40848: LIST
40849: PUSH
40850: LD_INT 1
40852: NEG
40853: PUSH
40854: LD_INT 2
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40866: LD_ADDR_VAR 0 15
40870: PUSH
40871: LD_INT 2
40873: NEG
40874: PUSH
40875: LD_INT 1
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 3
40884: NEG
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 3
40895: NEG
40896: PUSH
40897: LD_INT 1
40899: NEG
40900: PUSH
40901: EMPTY
40902: LIST
40903: LIST
40904: PUSH
40905: EMPTY
40906: LIST
40907: LIST
40908: LIST
40909: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40910: LD_ADDR_VAR 0 16
40914: PUSH
40915: LD_INT 2
40917: NEG
40918: PUSH
40919: LD_INT 3
40921: NEG
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 3
40929: NEG
40930: PUSH
40931: LD_INT 2
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 3
40941: NEG
40942: PUSH
40943: LD_INT 3
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: LIST
40955: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40956: LD_ADDR_VAR 0 17
40960: PUSH
40961: LD_INT 1
40963: NEG
40964: PUSH
40965: LD_INT 3
40967: NEG
40968: PUSH
40969: EMPTY
40970: LIST
40971: LIST
40972: PUSH
40973: LD_INT 0
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 1
40986: PUSH
40987: LD_INT 2
40989: NEG
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: LIST
40999: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41000: LD_ADDR_VAR 0 18
41004: PUSH
41005: LD_INT 2
41007: PUSH
41008: LD_INT 1
41010: NEG
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 3
41018: PUSH
41019: LD_INT 0
41021: PUSH
41022: EMPTY
41023: LIST
41024: LIST
41025: PUSH
41026: LD_INT 3
41028: PUSH
41029: LD_INT 1
41031: PUSH
41032: EMPTY
41033: LIST
41034: LIST
41035: PUSH
41036: EMPTY
41037: LIST
41038: LIST
41039: LIST
41040: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41041: LD_ADDR_VAR 0 19
41045: PUSH
41046: LD_INT 3
41048: PUSH
41049: LD_INT 2
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: PUSH
41056: LD_INT 3
41058: PUSH
41059: LD_INT 3
41061: PUSH
41062: EMPTY
41063: LIST
41064: LIST
41065: PUSH
41066: LD_INT 2
41068: PUSH
41069: LD_INT 3
41071: PUSH
41072: EMPTY
41073: LIST
41074: LIST
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: LIST
41080: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41081: LD_ADDR_VAR 0 20
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: LD_INT 3
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: PUSH
41096: LD_INT 0
41098: PUSH
41099: LD_INT 3
41101: PUSH
41102: EMPTY
41103: LIST
41104: LIST
41105: PUSH
41106: LD_INT 1
41108: NEG
41109: PUSH
41110: LD_INT 2
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: LIST
41121: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41122: LD_ADDR_VAR 0 21
41126: PUSH
41127: LD_INT 2
41129: NEG
41130: PUSH
41131: LD_INT 1
41133: PUSH
41134: EMPTY
41135: LIST
41136: LIST
41137: PUSH
41138: LD_INT 3
41140: NEG
41141: PUSH
41142: LD_INT 0
41144: PUSH
41145: EMPTY
41146: LIST
41147: LIST
41148: PUSH
41149: LD_INT 3
41151: NEG
41152: PUSH
41153: LD_INT 1
41155: NEG
41156: PUSH
41157: EMPTY
41158: LIST
41159: LIST
41160: PUSH
41161: EMPTY
41162: LIST
41163: LIST
41164: LIST
41165: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41166: LD_ADDR_VAR 0 22
41170: PUSH
41171: LD_INT 2
41173: NEG
41174: PUSH
41175: LD_INT 3
41177: NEG
41178: PUSH
41179: EMPTY
41180: LIST
41181: LIST
41182: PUSH
41183: LD_INT 3
41185: NEG
41186: PUSH
41187: LD_INT 2
41189: NEG
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 3
41197: NEG
41198: PUSH
41199: LD_INT 3
41201: NEG
41202: PUSH
41203: EMPTY
41204: LIST
41205: LIST
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: LIST
41211: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41212: LD_ADDR_VAR 0 23
41216: PUSH
41217: LD_INT 0
41219: PUSH
41220: LD_INT 3
41222: NEG
41223: PUSH
41224: EMPTY
41225: LIST
41226: LIST
41227: PUSH
41228: LD_INT 1
41230: NEG
41231: PUSH
41232: LD_INT 4
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 1
41242: PUSH
41243: LD_INT 3
41245: NEG
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: LIST
41255: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41256: LD_ADDR_VAR 0 24
41260: PUSH
41261: LD_INT 3
41263: PUSH
41264: LD_INT 0
41266: PUSH
41267: EMPTY
41268: LIST
41269: LIST
41270: PUSH
41271: LD_INT 3
41273: PUSH
41274: LD_INT 1
41276: NEG
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 4
41284: PUSH
41285: LD_INT 1
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: LIST
41296: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41297: LD_ADDR_VAR 0 25
41301: PUSH
41302: LD_INT 3
41304: PUSH
41305: LD_INT 3
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: PUSH
41312: LD_INT 4
41314: PUSH
41315: LD_INT 3
41317: PUSH
41318: EMPTY
41319: LIST
41320: LIST
41321: PUSH
41322: LD_INT 3
41324: PUSH
41325: LD_INT 4
41327: PUSH
41328: EMPTY
41329: LIST
41330: LIST
41331: PUSH
41332: EMPTY
41333: LIST
41334: LIST
41335: LIST
41336: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41337: LD_ADDR_VAR 0 26
41341: PUSH
41342: LD_INT 0
41344: PUSH
41345: LD_INT 3
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: PUSH
41352: LD_INT 1
41354: PUSH
41355: LD_INT 4
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: LD_INT 1
41364: NEG
41365: PUSH
41366: LD_INT 3
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: EMPTY
41374: LIST
41375: LIST
41376: LIST
41377: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41378: LD_ADDR_VAR 0 27
41382: PUSH
41383: LD_INT 3
41385: NEG
41386: PUSH
41387: LD_INT 0
41389: PUSH
41390: EMPTY
41391: LIST
41392: LIST
41393: PUSH
41394: LD_INT 3
41396: NEG
41397: PUSH
41398: LD_INT 1
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: PUSH
41405: LD_INT 4
41407: NEG
41408: PUSH
41409: LD_INT 1
41411: NEG
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41422: LD_ADDR_VAR 0 28
41426: PUSH
41427: LD_INT 3
41429: NEG
41430: PUSH
41431: LD_INT 3
41433: NEG
41434: PUSH
41435: EMPTY
41436: LIST
41437: LIST
41438: PUSH
41439: LD_INT 3
41441: NEG
41442: PUSH
41443: LD_INT 4
41445: NEG
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 4
41453: NEG
41454: PUSH
41455: LD_INT 3
41457: NEG
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: LIST
41467: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41468: LD_ADDR_VAR 0 29
41472: PUSH
41473: LD_INT 1
41475: NEG
41476: PUSH
41477: LD_INT 3
41479: NEG
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: LD_INT 3
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 1
41498: PUSH
41499: LD_INT 2
41501: NEG
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 1
41509: NEG
41510: PUSH
41511: LD_INT 4
41513: NEG
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 4
41524: NEG
41525: PUSH
41526: EMPTY
41527: LIST
41528: LIST
41529: PUSH
41530: LD_INT 1
41532: PUSH
41533: LD_INT 3
41535: NEG
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 1
41543: NEG
41544: PUSH
41545: LD_INT 5
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: LD_INT 5
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: PUSH
41567: LD_INT 4
41569: NEG
41570: PUSH
41571: EMPTY
41572: LIST
41573: LIST
41574: PUSH
41575: LD_INT 1
41577: NEG
41578: PUSH
41579: LD_INT 6
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 0
41589: PUSH
41590: LD_INT 6
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 1
41600: PUSH
41601: LD_INT 5
41603: NEG
41604: PUSH
41605: EMPTY
41606: LIST
41607: LIST
41608: PUSH
41609: EMPTY
41610: LIST
41611: LIST
41612: LIST
41613: LIST
41614: LIST
41615: LIST
41616: LIST
41617: LIST
41618: LIST
41619: LIST
41620: LIST
41621: LIST
41622: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41623: LD_ADDR_VAR 0 30
41627: PUSH
41628: LD_INT 2
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: LD_INT 3
41661: PUSH
41662: LD_INT 1
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 4
41672: PUSH
41673: LD_INT 0
41675: PUSH
41676: EMPTY
41677: LIST
41678: LIST
41679: PUSH
41680: LD_INT 4
41682: PUSH
41683: LD_INT 1
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 4
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 5
41703: PUSH
41704: LD_INT 0
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 5
41713: PUSH
41714: LD_INT 1
41716: PUSH
41717: EMPTY
41718: LIST
41719: LIST
41720: PUSH
41721: LD_INT 5
41723: PUSH
41724: LD_INT 1
41726: NEG
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: LD_INT 6
41734: PUSH
41735: LD_INT 0
41737: PUSH
41738: EMPTY
41739: LIST
41740: LIST
41741: PUSH
41742: LD_INT 6
41744: PUSH
41745: LD_INT 1
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: EMPTY
41753: LIST
41754: LIST
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41766: LD_ADDR_VAR 0 31
41770: PUSH
41771: LD_INT 3
41773: PUSH
41774: LD_INT 2
41776: PUSH
41777: EMPTY
41778: LIST
41779: LIST
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: LD_INT 3
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: LD_INT 3
41796: PUSH
41797: EMPTY
41798: LIST
41799: LIST
41800: PUSH
41801: LD_INT 4
41803: PUSH
41804: LD_INT 3
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 4
41813: PUSH
41814: LD_INT 4
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: PUSH
41821: LD_INT 3
41823: PUSH
41824: LD_INT 4
41826: PUSH
41827: EMPTY
41828: LIST
41829: LIST
41830: PUSH
41831: LD_INT 5
41833: PUSH
41834: LD_INT 4
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 5
41843: PUSH
41844: LD_INT 5
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 4
41853: PUSH
41854: LD_INT 5
41856: PUSH
41857: EMPTY
41858: LIST
41859: LIST
41860: PUSH
41861: LD_INT 6
41863: PUSH
41864: LD_INT 5
41866: PUSH
41867: EMPTY
41868: LIST
41869: LIST
41870: PUSH
41871: LD_INT 6
41873: PUSH
41874: LD_INT 6
41876: PUSH
41877: EMPTY
41878: LIST
41879: LIST
41880: PUSH
41881: LD_INT 5
41883: PUSH
41884: LD_INT 6
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: EMPTY
41892: LIST
41893: LIST
41894: LIST
41895: LIST
41896: LIST
41897: LIST
41898: LIST
41899: LIST
41900: LIST
41901: LIST
41902: LIST
41903: LIST
41904: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41905: LD_ADDR_VAR 0 32
41909: PUSH
41910: LD_INT 1
41912: PUSH
41913: LD_INT 3
41915: PUSH
41916: EMPTY
41917: LIST
41918: LIST
41919: PUSH
41920: LD_INT 0
41922: PUSH
41923: LD_INT 3
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 1
41932: NEG
41933: PUSH
41934: LD_INT 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 1
41943: PUSH
41944: LD_INT 4
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 0
41953: PUSH
41954: LD_INT 4
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 1
41963: NEG
41964: PUSH
41965: LD_INT 3
41967: PUSH
41968: EMPTY
41969: LIST
41970: LIST
41971: PUSH
41972: LD_INT 1
41974: PUSH
41975: LD_INT 5
41977: PUSH
41978: EMPTY
41979: LIST
41980: LIST
41981: PUSH
41982: LD_INT 0
41984: PUSH
41985: LD_INT 5
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 1
41994: NEG
41995: PUSH
41996: LD_INT 4
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 1
42005: PUSH
42006: LD_INT 6
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 0
42015: PUSH
42016: LD_INT 6
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 1
42025: NEG
42026: PUSH
42027: LD_INT 5
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: LIST
42038: LIST
42039: LIST
42040: LIST
42041: LIST
42042: LIST
42043: LIST
42044: LIST
42045: LIST
42046: LIST
42047: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42048: LD_ADDR_VAR 0 33
42052: PUSH
42053: LD_INT 2
42055: NEG
42056: PUSH
42057: LD_INT 1
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 3
42066: NEG
42067: PUSH
42068: LD_INT 0
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 3
42077: NEG
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 3
42089: NEG
42090: PUSH
42091: LD_INT 1
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 4
42100: NEG
42101: PUSH
42102: LD_INT 0
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PUSH
42109: LD_INT 4
42111: NEG
42112: PUSH
42113: LD_INT 1
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 4
42123: NEG
42124: PUSH
42125: LD_INT 1
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 5
42134: NEG
42135: PUSH
42136: LD_INT 0
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 5
42145: NEG
42146: PUSH
42147: LD_INT 1
42149: NEG
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 5
42157: NEG
42158: PUSH
42159: LD_INT 1
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 6
42168: NEG
42169: PUSH
42170: LD_INT 0
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 6
42179: NEG
42180: PUSH
42181: LD_INT 1
42183: NEG
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: LIST
42193: LIST
42194: LIST
42195: LIST
42196: LIST
42197: LIST
42198: LIST
42199: LIST
42200: LIST
42201: LIST
42202: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42203: LD_ADDR_VAR 0 34
42207: PUSH
42208: LD_INT 2
42210: NEG
42211: PUSH
42212: LD_INT 3
42214: NEG
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 3
42222: NEG
42223: PUSH
42224: LD_INT 2
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 3
42234: NEG
42235: PUSH
42236: LD_INT 3
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 3
42246: NEG
42247: PUSH
42248: LD_INT 4
42250: NEG
42251: PUSH
42252: EMPTY
42253: LIST
42254: LIST
42255: PUSH
42256: LD_INT 4
42258: NEG
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: EMPTY
42265: LIST
42266: LIST
42267: PUSH
42268: LD_INT 4
42270: NEG
42271: PUSH
42272: LD_INT 4
42274: NEG
42275: PUSH
42276: EMPTY
42277: LIST
42278: LIST
42279: PUSH
42280: LD_INT 4
42282: NEG
42283: PUSH
42284: LD_INT 5
42286: NEG
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: LD_INT 5
42294: NEG
42295: PUSH
42296: LD_INT 4
42298: NEG
42299: PUSH
42300: EMPTY
42301: LIST
42302: LIST
42303: PUSH
42304: LD_INT 5
42306: NEG
42307: PUSH
42308: LD_INT 5
42310: NEG
42311: PUSH
42312: EMPTY
42313: LIST
42314: LIST
42315: PUSH
42316: LD_INT 5
42318: NEG
42319: PUSH
42320: LD_INT 6
42322: NEG
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 6
42330: NEG
42331: PUSH
42332: LD_INT 5
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 6
42342: NEG
42343: PUSH
42344: LD_INT 6
42346: NEG
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: EMPTY
42353: LIST
42354: LIST
42355: LIST
42356: LIST
42357: LIST
42358: LIST
42359: LIST
42360: LIST
42361: LIST
42362: LIST
42363: LIST
42364: LIST
42365: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42366: LD_ADDR_VAR 0 41
42370: PUSH
42371: LD_INT 0
42373: PUSH
42374: LD_INT 2
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 1
42384: NEG
42385: PUSH
42386: LD_INT 3
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 1
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: LIST
42409: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42410: LD_ADDR_VAR 0 42
42414: PUSH
42415: LD_INT 2
42417: PUSH
42418: LD_INT 0
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 2
42427: PUSH
42428: LD_INT 1
42430: NEG
42431: PUSH
42432: EMPTY
42433: LIST
42434: LIST
42435: PUSH
42436: LD_INT 3
42438: PUSH
42439: LD_INT 1
42441: PUSH
42442: EMPTY
42443: LIST
42444: LIST
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: LIST
42450: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42451: LD_ADDR_VAR 0 43
42455: PUSH
42456: LD_INT 2
42458: PUSH
42459: LD_INT 2
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: PUSH
42466: LD_INT 3
42468: PUSH
42469: LD_INT 2
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: PUSH
42476: LD_INT 2
42478: PUSH
42479: LD_INT 3
42481: PUSH
42482: EMPTY
42483: LIST
42484: LIST
42485: PUSH
42486: EMPTY
42487: LIST
42488: LIST
42489: LIST
42490: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42491: LD_ADDR_VAR 0 44
42495: PUSH
42496: LD_INT 0
42498: PUSH
42499: LD_INT 2
42501: PUSH
42502: EMPTY
42503: LIST
42504: LIST
42505: PUSH
42506: LD_INT 1
42508: PUSH
42509: LD_INT 3
42511: PUSH
42512: EMPTY
42513: LIST
42514: LIST
42515: PUSH
42516: LD_INT 1
42518: NEG
42519: PUSH
42520: LD_INT 2
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PUSH
42527: EMPTY
42528: LIST
42529: LIST
42530: LIST
42531: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42532: LD_ADDR_VAR 0 45
42536: PUSH
42537: LD_INT 2
42539: NEG
42540: PUSH
42541: LD_INT 0
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 2
42550: NEG
42551: PUSH
42552: LD_INT 1
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 3
42561: NEG
42562: PUSH
42563: LD_INT 1
42565: NEG
42566: PUSH
42567: EMPTY
42568: LIST
42569: LIST
42570: PUSH
42571: EMPTY
42572: LIST
42573: LIST
42574: LIST
42575: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42576: LD_ADDR_VAR 0 46
42580: PUSH
42581: LD_INT 2
42583: NEG
42584: PUSH
42585: LD_INT 2
42587: NEG
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 2
42595: NEG
42596: PUSH
42597: LD_INT 3
42599: NEG
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 3
42607: NEG
42608: PUSH
42609: LD_INT 2
42611: NEG
42612: PUSH
42613: EMPTY
42614: LIST
42615: LIST
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: LIST
42621: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42622: LD_ADDR_VAR 0 47
42626: PUSH
42627: LD_INT 2
42629: NEG
42630: PUSH
42631: LD_INT 3
42633: NEG
42634: PUSH
42635: EMPTY
42636: LIST
42637: LIST
42638: PUSH
42639: LD_INT 1
42641: NEG
42642: PUSH
42643: LD_INT 3
42645: NEG
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42655: LD_ADDR_VAR 0 48
42659: PUSH
42660: LD_INT 1
42662: PUSH
42663: LD_INT 2
42665: NEG
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: LD_INT 2
42673: PUSH
42674: LD_INT 1
42676: NEG
42677: PUSH
42678: EMPTY
42679: LIST
42680: LIST
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42686: LD_ADDR_VAR 0 49
42690: PUSH
42691: LD_INT 3
42693: PUSH
42694: LD_INT 1
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 3
42703: PUSH
42704: LD_INT 2
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: EMPTY
42712: LIST
42713: LIST
42714: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42715: LD_ADDR_VAR 0 50
42719: PUSH
42720: LD_INT 2
42722: PUSH
42723: LD_INT 3
42725: PUSH
42726: EMPTY
42727: LIST
42728: LIST
42729: PUSH
42730: LD_INT 1
42732: PUSH
42733: LD_INT 3
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42744: LD_ADDR_VAR 0 51
42748: PUSH
42749: LD_INT 1
42751: NEG
42752: PUSH
42753: LD_INT 2
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 2
42762: NEG
42763: PUSH
42764: LD_INT 1
42766: PUSH
42767: EMPTY
42768: LIST
42769: LIST
42770: PUSH
42771: EMPTY
42772: LIST
42773: LIST
42774: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42775: LD_ADDR_VAR 0 52
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: LD_INT 1
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 3
42794: NEG
42795: PUSH
42796: LD_INT 2
42798: NEG
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42808: LD_ADDR_VAR 0 53
42812: PUSH
42813: LD_INT 1
42815: NEG
42816: PUSH
42817: LD_INT 3
42819: NEG
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 0
42827: PUSH
42828: LD_INT 3
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 1
42838: PUSH
42839: LD_INT 2
42841: NEG
42842: PUSH
42843: EMPTY
42844: LIST
42845: LIST
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: LIST
42851: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42852: LD_ADDR_VAR 0 54
42856: PUSH
42857: LD_INT 2
42859: PUSH
42860: LD_INT 1
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 3
42870: PUSH
42871: LD_INT 0
42873: PUSH
42874: EMPTY
42875: LIST
42876: LIST
42877: PUSH
42878: LD_INT 3
42880: PUSH
42881: LD_INT 1
42883: PUSH
42884: EMPTY
42885: LIST
42886: LIST
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: LIST
42892: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42893: LD_ADDR_VAR 0 55
42897: PUSH
42898: LD_INT 3
42900: PUSH
42901: LD_INT 2
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: PUSH
42908: LD_INT 3
42910: PUSH
42911: LD_INT 3
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 2
42920: PUSH
42921: LD_INT 3
42923: PUSH
42924: EMPTY
42925: LIST
42926: LIST
42927: PUSH
42928: EMPTY
42929: LIST
42930: LIST
42931: LIST
42932: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42933: LD_ADDR_VAR 0 56
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: LD_INT 3
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 0
42950: PUSH
42951: LD_INT 3
42953: PUSH
42954: EMPTY
42955: LIST
42956: LIST
42957: PUSH
42958: LD_INT 1
42960: NEG
42961: PUSH
42962: LD_INT 2
42964: PUSH
42965: EMPTY
42966: LIST
42967: LIST
42968: PUSH
42969: EMPTY
42970: LIST
42971: LIST
42972: LIST
42973: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
42974: LD_ADDR_VAR 0 57
42978: PUSH
42979: LD_INT 2
42981: NEG
42982: PUSH
42983: LD_INT 1
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 3
42992: NEG
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: EMPTY
42998: LIST
42999: LIST
43000: PUSH
43001: LD_INT 3
43003: NEG
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: EMPTY
43010: LIST
43011: LIST
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: LIST
43017: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43018: LD_ADDR_VAR 0 58
43022: PUSH
43023: LD_INT 2
43025: NEG
43026: PUSH
43027: LD_INT 3
43029: NEG
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 3
43037: NEG
43038: PUSH
43039: LD_INT 2
43041: NEG
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 3
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: LIST
43063: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43064: LD_ADDR_VAR 0 59
43068: PUSH
43069: LD_INT 1
43071: NEG
43072: PUSH
43073: LD_INT 2
43075: NEG
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 0
43083: PUSH
43084: LD_INT 2
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: LD_INT 1
43097: NEG
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: EMPTY
43104: LIST
43105: LIST
43106: LIST
43107: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43108: LD_ADDR_VAR 0 60
43112: PUSH
43113: LD_INT 1
43115: PUSH
43116: LD_INT 1
43118: NEG
43119: PUSH
43120: EMPTY
43121: LIST
43122: LIST
43123: PUSH
43124: LD_INT 2
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 2
43136: PUSH
43137: LD_INT 1
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: PUSH
43144: EMPTY
43145: LIST
43146: LIST
43147: LIST
43148: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43149: LD_ADDR_VAR 0 61
43153: PUSH
43154: LD_INT 2
43156: PUSH
43157: LD_INT 1
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: PUSH
43164: LD_INT 2
43166: PUSH
43167: LD_INT 2
43169: PUSH
43170: EMPTY
43171: LIST
43172: LIST
43173: PUSH
43174: LD_INT 1
43176: PUSH
43177: LD_INT 2
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: LIST
43187: LIST
43188: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43189: LD_ADDR_VAR 0 62
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: LD_INT 2
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: LD_INT 0
43206: PUSH
43207: LD_INT 2
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: LD_INT 1
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: LIST
43229: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43230: LD_ADDR_VAR 0 63
43234: PUSH
43235: LD_INT 1
43237: NEG
43238: PUSH
43239: LD_INT 1
43241: PUSH
43242: EMPTY
43243: LIST
43244: LIST
43245: PUSH
43246: LD_INT 2
43248: NEG
43249: PUSH
43250: LD_INT 0
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: LD_INT 2
43259: NEG
43260: PUSH
43261: LD_INT 1
43263: NEG
43264: PUSH
43265: EMPTY
43266: LIST
43267: LIST
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: LIST
43273: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43274: LD_ADDR_VAR 0 64
43278: PUSH
43279: LD_INT 1
43281: NEG
43282: PUSH
43283: LD_INT 2
43285: NEG
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 2
43293: NEG
43294: PUSH
43295: LD_INT 1
43297: NEG
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: NEG
43306: PUSH
43307: LD_INT 2
43309: NEG
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: LIST
43319: ST_TO_ADDR
// end ; 2 :
43320: GO 46586
43322: LD_INT 2
43324: DOUBLE
43325: EQUAL
43326: IFTRUE 43330
43328: GO 46585
43330: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43331: LD_ADDR_VAR 0 29
43335: PUSH
43336: LD_INT 4
43338: PUSH
43339: LD_INT 0
43341: PUSH
43342: EMPTY
43343: LIST
43344: LIST
43345: PUSH
43346: LD_INT 4
43348: PUSH
43349: LD_INT 1
43351: NEG
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 5
43359: PUSH
43360: LD_INT 0
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: LD_INT 5
43369: PUSH
43370: LD_INT 1
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 4
43379: PUSH
43380: LD_INT 1
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 3
43389: PUSH
43390: LD_INT 0
43392: PUSH
43393: EMPTY
43394: LIST
43395: LIST
43396: PUSH
43397: LD_INT 3
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 3
43410: PUSH
43411: LD_INT 2
43413: NEG
43414: PUSH
43415: EMPTY
43416: LIST
43417: LIST
43418: PUSH
43419: LD_INT 5
43421: PUSH
43422: LD_INT 2
43424: PUSH
43425: EMPTY
43426: LIST
43427: LIST
43428: PUSH
43429: LD_INT 3
43431: PUSH
43432: LD_INT 3
43434: PUSH
43435: EMPTY
43436: LIST
43437: LIST
43438: PUSH
43439: LD_INT 3
43441: PUSH
43442: LD_INT 2
43444: PUSH
43445: EMPTY
43446: LIST
43447: LIST
43448: PUSH
43449: LD_INT 4
43451: PUSH
43452: LD_INT 3
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 4
43461: PUSH
43462: LD_INT 4
43464: PUSH
43465: EMPTY
43466: LIST
43467: LIST
43468: PUSH
43469: LD_INT 3
43471: PUSH
43472: LD_INT 4
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 2
43491: PUSH
43492: LD_INT 2
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 4
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 2
43511: PUSH
43512: LD_INT 4
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: LD_INT 0
43521: PUSH
43522: LD_INT 4
43524: PUSH
43525: EMPTY
43526: LIST
43527: LIST
43528: PUSH
43529: LD_INT 0
43531: PUSH
43532: LD_INT 3
43534: PUSH
43535: EMPTY
43536: LIST
43537: LIST
43538: PUSH
43539: LD_INT 1
43541: PUSH
43542: LD_INT 4
43544: PUSH
43545: EMPTY
43546: LIST
43547: LIST
43548: PUSH
43549: LD_INT 1
43551: PUSH
43552: LD_INT 5
43554: PUSH
43555: EMPTY
43556: LIST
43557: LIST
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: LD_INT 5
43564: PUSH
43565: EMPTY
43566: LIST
43567: LIST
43568: PUSH
43569: LD_INT 1
43571: NEG
43572: PUSH
43573: LD_INT 4
43575: PUSH
43576: EMPTY
43577: LIST
43578: LIST
43579: PUSH
43580: LD_INT 1
43582: NEG
43583: PUSH
43584: LD_INT 3
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 2
43593: PUSH
43594: LD_INT 5
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 2
43603: NEG
43604: PUSH
43605: LD_INT 3
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 3
43614: NEG
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: LD_INT 3
43625: NEG
43626: PUSH
43627: LD_INT 1
43629: NEG
43630: PUSH
43631: EMPTY
43632: LIST
43633: LIST
43634: PUSH
43635: LD_INT 2
43637: NEG
43638: PUSH
43639: LD_INT 0
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: NEG
43649: PUSH
43650: LD_INT 1
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 1
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: PUSH
43668: LD_INT 4
43670: NEG
43671: PUSH
43672: LD_INT 0
43674: PUSH
43675: EMPTY
43676: LIST
43677: LIST
43678: PUSH
43679: LD_INT 4
43681: NEG
43682: PUSH
43683: LD_INT 1
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 4
43693: NEG
43694: PUSH
43695: LD_INT 2
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 2
43705: NEG
43706: PUSH
43707: LD_INT 2
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 4
43716: NEG
43717: PUSH
43718: LD_INT 4
43720: NEG
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: LD_INT 4
43728: NEG
43729: PUSH
43730: LD_INT 5
43732: NEG
43733: PUSH
43734: EMPTY
43735: LIST
43736: LIST
43737: PUSH
43738: LD_INT 3
43740: NEG
43741: PUSH
43742: LD_INT 4
43744: NEG
43745: PUSH
43746: EMPTY
43747: LIST
43748: LIST
43749: PUSH
43750: LD_INT 3
43752: NEG
43753: PUSH
43754: LD_INT 3
43756: NEG
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: LD_INT 4
43764: NEG
43765: PUSH
43766: LD_INT 3
43768: NEG
43769: PUSH
43770: EMPTY
43771: LIST
43772: LIST
43773: PUSH
43774: LD_INT 5
43776: NEG
43777: PUSH
43778: LD_INT 4
43780: NEG
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 5
43788: NEG
43789: PUSH
43790: LD_INT 5
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 3
43800: NEG
43801: PUSH
43802: LD_INT 5
43804: NEG
43805: PUSH
43806: EMPTY
43807: LIST
43808: LIST
43809: PUSH
43810: LD_INT 5
43812: NEG
43813: PUSH
43814: LD_INT 3
43816: NEG
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: EMPTY
43823: LIST
43824: LIST
43825: LIST
43826: LIST
43827: LIST
43828: LIST
43829: LIST
43830: LIST
43831: LIST
43832: LIST
43833: LIST
43834: LIST
43835: LIST
43836: LIST
43837: LIST
43838: LIST
43839: LIST
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: LIST
43845: LIST
43846: LIST
43847: LIST
43848: LIST
43849: LIST
43850: LIST
43851: LIST
43852: LIST
43853: LIST
43854: LIST
43855: LIST
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43869: LD_ADDR_VAR 0 30
43873: PUSH
43874: LD_INT 4
43876: PUSH
43877: LD_INT 4
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 4
43886: PUSH
43887: LD_INT 3
43889: PUSH
43890: EMPTY
43891: LIST
43892: LIST
43893: PUSH
43894: LD_INT 5
43896: PUSH
43897: LD_INT 4
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 5
43906: PUSH
43907: LD_INT 5
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 4
43916: PUSH
43917: LD_INT 5
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PUSH
43924: LD_INT 3
43926: PUSH
43927: LD_INT 4
43929: PUSH
43930: EMPTY
43931: LIST
43932: LIST
43933: PUSH
43934: LD_INT 3
43936: PUSH
43937: LD_INT 3
43939: PUSH
43940: EMPTY
43941: LIST
43942: LIST
43943: PUSH
43944: LD_INT 5
43946: PUSH
43947: LD_INT 3
43949: PUSH
43950: EMPTY
43951: LIST
43952: LIST
43953: PUSH
43954: LD_INT 3
43956: PUSH
43957: LD_INT 5
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 0
43966: PUSH
43967: LD_INT 3
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: LD_INT 0
43976: PUSH
43977: LD_INT 2
43979: PUSH
43980: EMPTY
43981: LIST
43982: LIST
43983: PUSH
43984: LD_INT 1
43986: PUSH
43987: LD_INT 3
43989: PUSH
43990: EMPTY
43991: LIST
43992: LIST
43993: PUSH
43994: LD_INT 1
43996: PUSH
43997: LD_INT 4
43999: PUSH
44000: EMPTY
44001: LIST
44002: LIST
44003: PUSH
44004: LD_INT 0
44006: PUSH
44007: LD_INT 4
44009: PUSH
44010: EMPTY
44011: LIST
44012: LIST
44013: PUSH
44014: LD_INT 1
44016: NEG
44017: PUSH
44018: LD_INT 3
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 1
44027: NEG
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: NEG
44049: PUSH
44050: LD_INT 2
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 4
44059: NEG
44060: PUSH
44061: LD_INT 0
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 4
44070: NEG
44071: PUSH
44072: LD_INT 1
44074: NEG
44075: PUSH
44076: EMPTY
44077: LIST
44078: LIST
44079: PUSH
44080: LD_INT 3
44082: NEG
44083: PUSH
44084: LD_INT 0
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 3
44093: NEG
44094: PUSH
44095: LD_INT 1
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 1
44108: PUSH
44109: EMPTY
44110: LIST
44111: LIST
44112: PUSH
44113: LD_INT 5
44115: NEG
44116: PUSH
44117: LD_INT 0
44119: PUSH
44120: EMPTY
44121: LIST
44122: LIST
44123: PUSH
44124: LD_INT 5
44126: NEG
44127: PUSH
44128: LD_INT 1
44130: NEG
44131: PUSH
44132: EMPTY
44133: LIST
44134: LIST
44135: PUSH
44136: LD_INT 5
44138: NEG
44139: PUSH
44140: LD_INT 2
44142: NEG
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 3
44150: NEG
44151: PUSH
44152: LD_INT 2
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 3
44161: NEG
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: EMPTY
44168: LIST
44169: LIST
44170: PUSH
44171: LD_INT 3
44173: NEG
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: EMPTY
44180: LIST
44181: LIST
44182: PUSH
44183: LD_INT 2
44185: NEG
44186: PUSH
44187: LD_INT 3
44189: NEG
44190: PUSH
44191: EMPTY
44192: LIST
44193: LIST
44194: PUSH
44195: LD_INT 2
44197: NEG
44198: PUSH
44199: LD_INT 2
44201: NEG
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 3
44209: NEG
44210: PUSH
44211: LD_INT 2
44213: NEG
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 4
44221: NEG
44222: PUSH
44223: LD_INT 3
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 4
44233: NEG
44234: PUSH
44235: LD_INT 4
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 2
44245: NEG
44246: PUSH
44247: LD_INT 4
44249: NEG
44250: PUSH
44251: EMPTY
44252: LIST
44253: LIST
44254: PUSH
44255: LD_INT 4
44257: NEG
44258: PUSH
44259: LD_INT 2
44261: NEG
44262: PUSH
44263: EMPTY
44264: LIST
44265: LIST
44266: PUSH
44267: LD_INT 0
44269: PUSH
44270: LD_INT 4
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 0
44280: PUSH
44281: LD_INT 5
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 1
44291: PUSH
44292: LD_INT 4
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 1
44302: PUSH
44303: LD_INT 3
44305: NEG
44306: PUSH
44307: EMPTY
44308: LIST
44309: LIST
44310: PUSH
44311: LD_INT 0
44313: PUSH
44314: LD_INT 3
44316: NEG
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 1
44324: NEG
44325: PUSH
44326: LD_INT 4
44328: NEG
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 1
44336: NEG
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 2
44348: PUSH
44349: LD_INT 3
44351: NEG
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 2
44359: NEG
44360: PUSH
44361: LD_INT 5
44363: NEG
44364: PUSH
44365: EMPTY
44366: LIST
44367: LIST
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: LIST
44409: LIST
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44416: LD_ADDR_VAR 0 31
44420: PUSH
44421: LD_INT 0
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 0
44433: PUSH
44434: LD_INT 3
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: LD_INT 1
44443: PUSH
44444: LD_INT 4
44446: PUSH
44447: EMPTY
44448: LIST
44449: LIST
44450: PUSH
44451: LD_INT 1
44453: PUSH
44454: LD_INT 5
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: PUSH
44461: LD_INT 0
44463: PUSH
44464: LD_INT 5
44466: PUSH
44467: EMPTY
44468: LIST
44469: LIST
44470: PUSH
44471: LD_INT 1
44473: NEG
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: EMPTY
44479: LIST
44480: LIST
44481: PUSH
44482: LD_INT 1
44484: NEG
44485: PUSH
44486: LD_INT 3
44488: PUSH
44489: EMPTY
44490: LIST
44491: LIST
44492: PUSH
44493: LD_INT 2
44495: PUSH
44496: LD_INT 5
44498: PUSH
44499: EMPTY
44500: LIST
44501: LIST
44502: PUSH
44503: LD_INT 2
44505: NEG
44506: PUSH
44507: LD_INT 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 3
44516: NEG
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 3
44527: NEG
44528: PUSH
44529: LD_INT 1
44531: NEG
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 2
44539: NEG
44540: PUSH
44541: LD_INT 0
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 2
44550: NEG
44551: PUSH
44552: LD_INT 1
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 3
44561: NEG
44562: PUSH
44563: LD_INT 1
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 4
44572: NEG
44573: PUSH
44574: LD_INT 0
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 4
44583: NEG
44584: PUSH
44585: LD_INT 1
44587: NEG
44588: PUSH
44589: EMPTY
44590: LIST
44591: LIST
44592: PUSH
44593: LD_INT 4
44595: NEG
44596: PUSH
44597: LD_INT 2
44599: NEG
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 2
44607: NEG
44608: PUSH
44609: LD_INT 2
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 4
44618: NEG
44619: PUSH
44620: LD_INT 4
44622: NEG
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 4
44630: NEG
44631: PUSH
44632: LD_INT 5
44634: NEG
44635: PUSH
44636: EMPTY
44637: LIST
44638: LIST
44639: PUSH
44640: LD_INT 3
44642: NEG
44643: PUSH
44644: LD_INT 4
44646: NEG
44647: PUSH
44648: EMPTY
44649: LIST
44650: LIST
44651: PUSH
44652: LD_INT 3
44654: NEG
44655: PUSH
44656: LD_INT 3
44658: NEG
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: PUSH
44664: LD_INT 4
44666: NEG
44667: PUSH
44668: LD_INT 3
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 5
44678: NEG
44679: PUSH
44680: LD_INT 4
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 5
44690: NEG
44691: PUSH
44692: LD_INT 5
44694: NEG
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 3
44702: NEG
44703: PUSH
44704: LD_INT 5
44706: NEG
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: LD_INT 5
44714: NEG
44715: PUSH
44716: LD_INT 3
44718: NEG
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 0
44726: PUSH
44727: LD_INT 3
44729: NEG
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 0
44737: PUSH
44738: LD_INT 4
44740: NEG
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 1
44748: PUSH
44749: LD_INT 3
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 1
44759: PUSH
44760: LD_INT 2
44762: NEG
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: PUSH
44768: LD_INT 0
44770: PUSH
44771: LD_INT 2
44773: NEG
44774: PUSH
44775: EMPTY
44776: LIST
44777: LIST
44778: PUSH
44779: LD_INT 1
44781: NEG
44782: PUSH
44783: LD_INT 3
44785: NEG
44786: PUSH
44787: EMPTY
44788: LIST
44789: LIST
44790: PUSH
44791: LD_INT 1
44793: NEG
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 2
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: NEG
44817: PUSH
44818: LD_INT 4
44820: NEG
44821: PUSH
44822: EMPTY
44823: LIST
44824: LIST
44825: PUSH
44826: LD_INT 4
44828: PUSH
44829: LD_INT 0
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 4
44838: PUSH
44839: LD_INT 1
44841: NEG
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 5
44849: PUSH
44850: LD_INT 0
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 5
44859: PUSH
44860: LD_INT 1
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: PUSH
44867: LD_INT 4
44869: PUSH
44870: LD_INT 1
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 3
44879: PUSH
44880: LD_INT 0
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 3
44889: PUSH
44890: LD_INT 1
44892: NEG
44893: PUSH
44894: EMPTY
44895: LIST
44896: LIST
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: LD_INT 2
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 5
44911: PUSH
44912: LD_INT 2
44914: PUSH
44915: EMPTY
44916: LIST
44917: LIST
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
44966: LD_ADDR_VAR 0 32
44970: PUSH
44971: LD_INT 4
44973: NEG
44974: PUSH
44975: LD_INT 0
44977: PUSH
44978: EMPTY
44979: LIST
44980: LIST
44981: PUSH
44982: LD_INT 4
44984: NEG
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PUSH
44994: LD_INT 3
44996: NEG
44997: PUSH
44998: LD_INT 0
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 3
45007: NEG
45008: PUSH
45009: LD_INT 1
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 4
45018: NEG
45019: PUSH
45020: LD_INT 1
45022: PUSH
45023: EMPTY
45024: LIST
45025: LIST
45026: PUSH
45027: LD_INT 5
45029: NEG
45030: PUSH
45031: LD_INT 0
45033: PUSH
45034: EMPTY
45035: LIST
45036: LIST
45037: PUSH
45038: LD_INT 5
45040: NEG
45041: PUSH
45042: LD_INT 1
45044: NEG
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PUSH
45050: LD_INT 5
45052: NEG
45053: PUSH
45054: LD_INT 2
45056: NEG
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: LD_INT 2
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 3
45075: NEG
45076: PUSH
45077: LD_INT 3
45079: NEG
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 3
45087: NEG
45088: PUSH
45089: LD_INT 4
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 2
45099: NEG
45100: PUSH
45101: LD_INT 3
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 2
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: NEG
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 3
45123: NEG
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 4
45147: NEG
45148: PUSH
45149: LD_INT 4
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 2
45159: NEG
45160: PUSH
45161: LD_INT 4
45163: NEG
45164: PUSH
45165: EMPTY
45166: LIST
45167: LIST
45168: PUSH
45169: LD_INT 4
45171: NEG
45172: PUSH
45173: LD_INT 2
45175: NEG
45176: PUSH
45177: EMPTY
45178: LIST
45179: LIST
45180: PUSH
45181: LD_INT 0
45183: PUSH
45184: LD_INT 4
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 0
45194: PUSH
45195: LD_INT 5
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 1
45205: PUSH
45206: LD_INT 4
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 1
45216: PUSH
45217: LD_INT 3
45219: NEG
45220: PUSH
45221: EMPTY
45222: LIST
45223: LIST
45224: PUSH
45225: LD_INT 0
45227: PUSH
45228: LD_INT 3
45230: NEG
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 1
45238: NEG
45239: PUSH
45240: LD_INT 4
45242: NEG
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 1
45250: NEG
45251: PUSH
45252: LD_INT 5
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: LD_INT 3
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 2
45273: NEG
45274: PUSH
45275: LD_INT 5
45277: NEG
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 3
45285: PUSH
45286: LD_INT 0
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 3
45295: PUSH
45296: LD_INT 1
45298: NEG
45299: PUSH
45300: EMPTY
45301: LIST
45302: LIST
45303: PUSH
45304: LD_INT 4
45306: PUSH
45307: LD_INT 0
45309: PUSH
45310: EMPTY
45311: LIST
45312: LIST
45313: PUSH
45314: LD_INT 4
45316: PUSH
45317: LD_INT 1
45319: PUSH
45320: EMPTY
45321: LIST
45322: LIST
45323: PUSH
45324: LD_INT 3
45326: PUSH
45327: LD_INT 1
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 2
45336: PUSH
45337: LD_INT 0
45339: PUSH
45340: EMPTY
45341: LIST
45342: LIST
45343: PUSH
45344: LD_INT 2
45346: PUSH
45347: LD_INT 1
45349: NEG
45350: PUSH
45351: EMPTY
45352: LIST
45353: LIST
45354: PUSH
45355: LD_INT 2
45357: PUSH
45358: LD_INT 2
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 4
45368: PUSH
45369: LD_INT 2
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 4
45378: PUSH
45379: LD_INT 4
45381: PUSH
45382: EMPTY
45383: LIST
45384: LIST
45385: PUSH
45386: LD_INT 4
45388: PUSH
45389: LD_INT 3
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: PUSH
45396: LD_INT 5
45398: PUSH
45399: LD_INT 4
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 5
45408: PUSH
45409: LD_INT 5
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: LD_INT 4
45418: PUSH
45419: LD_INT 5
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 3
45428: PUSH
45429: LD_INT 4
45431: PUSH
45432: EMPTY
45433: LIST
45434: LIST
45435: PUSH
45436: LD_INT 3
45438: PUSH
45439: LD_INT 3
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: PUSH
45446: LD_INT 5
45448: PUSH
45449: LD_INT 3
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 3
45458: PUSH
45459: LD_INT 5
45461: PUSH
45462: EMPTY
45463: LIST
45464: LIST
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: LIST
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45513: LD_ADDR_VAR 0 33
45517: PUSH
45518: LD_INT 4
45520: NEG
45521: PUSH
45522: LD_INT 4
45524: NEG
45525: PUSH
45526: EMPTY
45527: LIST
45528: LIST
45529: PUSH
45530: LD_INT 4
45532: NEG
45533: PUSH
45534: LD_INT 5
45536: NEG
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: LD_INT 3
45544: NEG
45545: PUSH
45546: LD_INT 4
45548: NEG
45549: PUSH
45550: EMPTY
45551: LIST
45552: LIST
45553: PUSH
45554: LD_INT 3
45556: NEG
45557: PUSH
45558: LD_INT 3
45560: NEG
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 4
45568: NEG
45569: PUSH
45570: LD_INT 3
45572: NEG
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 5
45580: NEG
45581: PUSH
45582: LD_INT 4
45584: NEG
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 5
45592: NEG
45593: PUSH
45594: LD_INT 5
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: LD_INT 5
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 5
45616: NEG
45617: PUSH
45618: LD_INT 3
45620: NEG
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PUSH
45626: LD_INT 0
45628: PUSH
45629: LD_INT 3
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 0
45639: PUSH
45640: LD_INT 4
45642: NEG
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 1
45650: PUSH
45651: LD_INT 3
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 1
45661: PUSH
45662: LD_INT 2
45664: NEG
45665: PUSH
45666: EMPTY
45667: LIST
45668: LIST
45669: PUSH
45670: LD_INT 0
45672: PUSH
45673: LD_INT 2
45675: NEG
45676: PUSH
45677: EMPTY
45678: LIST
45679: LIST
45680: PUSH
45681: LD_INT 1
45683: NEG
45684: PUSH
45685: LD_INT 3
45687: NEG
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 1
45695: NEG
45696: PUSH
45697: LD_INT 4
45699: NEG
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 2
45707: PUSH
45708: LD_INT 2
45710: NEG
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 2
45718: NEG
45719: PUSH
45720: LD_INT 4
45722: NEG
45723: PUSH
45724: EMPTY
45725: LIST
45726: LIST
45727: PUSH
45728: LD_INT 4
45730: PUSH
45731: LD_INT 0
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 4
45740: PUSH
45741: LD_INT 1
45743: NEG
45744: PUSH
45745: EMPTY
45746: LIST
45747: LIST
45748: PUSH
45749: LD_INT 5
45751: PUSH
45752: LD_INT 0
45754: PUSH
45755: EMPTY
45756: LIST
45757: LIST
45758: PUSH
45759: LD_INT 5
45761: PUSH
45762: LD_INT 1
45764: PUSH
45765: EMPTY
45766: LIST
45767: LIST
45768: PUSH
45769: LD_INT 4
45771: PUSH
45772: LD_INT 1
45774: PUSH
45775: EMPTY
45776: LIST
45777: LIST
45778: PUSH
45779: LD_INT 3
45781: PUSH
45782: LD_INT 0
45784: PUSH
45785: EMPTY
45786: LIST
45787: LIST
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: LD_INT 1
45794: NEG
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 3
45802: PUSH
45803: LD_INT 2
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 5
45813: PUSH
45814: LD_INT 2
45816: PUSH
45817: EMPTY
45818: LIST
45819: LIST
45820: PUSH
45821: LD_INT 3
45823: PUSH
45824: LD_INT 3
45826: PUSH
45827: EMPTY
45828: LIST
45829: LIST
45830: PUSH
45831: LD_INT 3
45833: PUSH
45834: LD_INT 2
45836: PUSH
45837: EMPTY
45838: LIST
45839: LIST
45840: PUSH
45841: LD_INT 4
45843: PUSH
45844: LD_INT 3
45846: PUSH
45847: EMPTY
45848: LIST
45849: LIST
45850: PUSH
45851: LD_INT 4
45853: PUSH
45854: LD_INT 4
45856: PUSH
45857: EMPTY
45858: LIST
45859: LIST
45860: PUSH
45861: LD_INT 3
45863: PUSH
45864: LD_INT 4
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: LD_INT 3
45876: PUSH
45877: EMPTY
45878: LIST
45879: LIST
45880: PUSH
45881: LD_INT 2
45883: PUSH
45884: LD_INT 2
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 4
45893: PUSH
45894: LD_INT 2
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: LD_INT 4
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: LD_INT 0
45913: PUSH
45914: LD_INT 4
45916: PUSH
45917: EMPTY
45918: LIST
45919: LIST
45920: PUSH
45921: LD_INT 0
45923: PUSH
45924: LD_INT 3
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: PUSH
45931: LD_INT 1
45933: PUSH
45934: LD_INT 4
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: PUSH
45941: LD_INT 1
45943: PUSH
45944: LD_INT 5
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: LD_INT 0
45953: PUSH
45954: LD_INT 5
45956: PUSH
45957: EMPTY
45958: LIST
45959: LIST
45960: PUSH
45961: LD_INT 1
45963: NEG
45964: PUSH
45965: LD_INT 4
45967: PUSH
45968: EMPTY
45969: LIST
45970: LIST
45971: PUSH
45972: LD_INT 1
45974: NEG
45975: PUSH
45976: LD_INT 3
45978: PUSH
45979: EMPTY
45980: LIST
45981: LIST
45982: PUSH
45983: LD_INT 2
45985: PUSH
45986: LD_INT 5
45988: PUSH
45989: EMPTY
45990: LIST
45991: LIST
45992: PUSH
45993: LD_INT 2
45995: NEG
45996: PUSH
45997: LD_INT 3
45999: PUSH
46000: EMPTY
46001: LIST
46002: LIST
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46051: LD_ADDR_VAR 0 34
46055: PUSH
46056: LD_INT 0
46058: PUSH
46059: LD_INT 4
46061: NEG
46062: PUSH
46063: EMPTY
46064: LIST
46065: LIST
46066: PUSH
46067: LD_INT 0
46069: PUSH
46070: LD_INT 5
46072: NEG
46073: PUSH
46074: EMPTY
46075: LIST
46076: LIST
46077: PUSH
46078: LD_INT 1
46080: PUSH
46081: LD_INT 4
46083: NEG
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: LD_INT 1
46091: PUSH
46092: LD_INT 3
46094: NEG
46095: PUSH
46096: EMPTY
46097: LIST
46098: LIST
46099: PUSH
46100: LD_INT 0
46102: PUSH
46103: LD_INT 3
46105: NEG
46106: PUSH
46107: EMPTY
46108: LIST
46109: LIST
46110: PUSH
46111: LD_INT 1
46113: NEG
46114: PUSH
46115: LD_INT 4
46117: NEG
46118: PUSH
46119: EMPTY
46120: LIST
46121: LIST
46122: PUSH
46123: LD_INT 1
46125: NEG
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 2
46137: PUSH
46138: LD_INT 3
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 2
46148: NEG
46149: PUSH
46150: LD_INT 5
46152: NEG
46153: PUSH
46154: EMPTY
46155: LIST
46156: LIST
46157: PUSH
46158: LD_INT 3
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 3
46170: PUSH
46171: LD_INT 1
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 4
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 4
46191: PUSH
46192: LD_INT 1
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: LD_INT 1
46204: PUSH
46205: EMPTY
46206: LIST
46207: LIST
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: LD_INT 0
46214: PUSH
46215: EMPTY
46216: LIST
46217: LIST
46218: PUSH
46219: LD_INT 2
46221: PUSH
46222: LD_INT 1
46224: NEG
46225: PUSH
46226: EMPTY
46227: LIST
46228: LIST
46229: PUSH
46230: LD_INT 2
46232: PUSH
46233: LD_INT 2
46235: NEG
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: LD_INT 2
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 4
46263: PUSH
46264: LD_INT 3
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 5
46273: PUSH
46274: LD_INT 4
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 5
46283: PUSH
46284: LD_INT 5
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 4
46293: PUSH
46294: LD_INT 5
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 3
46303: PUSH
46304: LD_INT 4
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 3
46313: PUSH
46314: LD_INT 3
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 5
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 3
46333: PUSH
46334: LD_INT 5
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 0
46343: PUSH
46344: LD_INT 3
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 0
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 1
46363: PUSH
46364: LD_INT 3
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 1
46373: PUSH
46374: LD_INT 4
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 0
46383: PUSH
46384: LD_INT 4
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 1
46393: NEG
46394: PUSH
46395: LD_INT 3
46397: PUSH
46398: EMPTY
46399: LIST
46400: LIST
46401: PUSH
46402: LD_INT 1
46404: NEG
46405: PUSH
46406: LD_INT 2
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 2
46415: PUSH
46416: LD_INT 4
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 2
46425: NEG
46426: PUSH
46427: LD_INT 2
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: PUSH
46434: LD_INT 4
46436: NEG
46437: PUSH
46438: LD_INT 0
46440: PUSH
46441: EMPTY
46442: LIST
46443: LIST
46444: PUSH
46445: LD_INT 4
46447: NEG
46448: PUSH
46449: LD_INT 1
46451: NEG
46452: PUSH
46453: EMPTY
46454: LIST
46455: LIST
46456: PUSH
46457: LD_INT 3
46459: NEG
46460: PUSH
46461: LD_INT 0
46463: PUSH
46464: EMPTY
46465: LIST
46466: LIST
46467: PUSH
46468: LD_INT 3
46470: NEG
46471: PUSH
46472: LD_INT 1
46474: PUSH
46475: EMPTY
46476: LIST
46477: LIST
46478: PUSH
46479: LD_INT 4
46481: NEG
46482: PUSH
46483: LD_INT 1
46485: PUSH
46486: EMPTY
46487: LIST
46488: LIST
46489: PUSH
46490: LD_INT 5
46492: NEG
46493: PUSH
46494: LD_INT 0
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 5
46503: NEG
46504: PUSH
46505: LD_INT 1
46507: NEG
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PUSH
46513: LD_INT 5
46515: NEG
46516: PUSH
46517: LD_INT 2
46519: NEG
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 3
46527: NEG
46528: PUSH
46529: LD_INT 2
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: EMPTY
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: ST_TO_ADDR
// end ; end ;
46583: GO 46586
46585: POP
// case btype of b_depot , b_warehouse :
46586: LD_VAR 0 1
46590: PUSH
46591: LD_INT 0
46593: DOUBLE
46594: EQUAL
46595: IFTRUE 46605
46597: LD_INT 1
46599: DOUBLE
46600: EQUAL
46601: IFTRUE 46605
46603: GO 46806
46605: POP
// case nation of nation_american :
46606: LD_VAR 0 5
46610: PUSH
46611: LD_INT 1
46613: DOUBLE
46614: EQUAL
46615: IFTRUE 46619
46617: GO 46675
46619: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46620: LD_ADDR_VAR 0 9
46624: PUSH
46625: LD_VAR 0 11
46629: PUSH
46630: LD_VAR 0 12
46634: PUSH
46635: LD_VAR 0 13
46639: PUSH
46640: LD_VAR 0 14
46644: PUSH
46645: LD_VAR 0 15
46649: PUSH
46650: LD_VAR 0 16
46654: PUSH
46655: EMPTY
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: PUSH
46663: LD_VAR 0 4
46667: PUSH
46668: LD_INT 1
46670: PLUS
46671: ARRAY
46672: ST_TO_ADDR
46673: GO 46804
46675: LD_INT 2
46677: DOUBLE
46678: EQUAL
46679: IFTRUE 46683
46681: GO 46739
46683: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46684: LD_ADDR_VAR 0 9
46688: PUSH
46689: LD_VAR 0 17
46693: PUSH
46694: LD_VAR 0 18
46698: PUSH
46699: LD_VAR 0 19
46703: PUSH
46704: LD_VAR 0 20
46708: PUSH
46709: LD_VAR 0 21
46713: PUSH
46714: LD_VAR 0 22
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: PUSH
46727: LD_VAR 0 4
46731: PUSH
46732: LD_INT 1
46734: PLUS
46735: ARRAY
46736: ST_TO_ADDR
46737: GO 46804
46739: LD_INT 3
46741: DOUBLE
46742: EQUAL
46743: IFTRUE 46747
46745: GO 46803
46747: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46748: LD_ADDR_VAR 0 9
46752: PUSH
46753: LD_VAR 0 23
46757: PUSH
46758: LD_VAR 0 24
46762: PUSH
46763: LD_VAR 0 25
46767: PUSH
46768: LD_VAR 0 26
46772: PUSH
46773: LD_VAR 0 27
46777: PUSH
46778: LD_VAR 0 28
46782: PUSH
46783: EMPTY
46784: LIST
46785: LIST
46786: LIST
46787: LIST
46788: LIST
46789: LIST
46790: PUSH
46791: LD_VAR 0 4
46795: PUSH
46796: LD_INT 1
46798: PLUS
46799: ARRAY
46800: ST_TO_ADDR
46801: GO 46804
46803: POP
46804: GO 47353
46806: LD_INT 2
46808: DOUBLE
46809: EQUAL
46810: IFTRUE 46820
46812: LD_INT 3
46814: DOUBLE
46815: EQUAL
46816: IFTRUE 46820
46818: GO 46876
46820: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46821: LD_ADDR_VAR 0 9
46825: PUSH
46826: LD_VAR 0 29
46830: PUSH
46831: LD_VAR 0 30
46835: PUSH
46836: LD_VAR 0 31
46840: PUSH
46841: LD_VAR 0 32
46845: PUSH
46846: LD_VAR 0 33
46850: PUSH
46851: LD_VAR 0 34
46855: PUSH
46856: EMPTY
46857: LIST
46858: LIST
46859: LIST
46860: LIST
46861: LIST
46862: LIST
46863: PUSH
46864: LD_VAR 0 4
46868: PUSH
46869: LD_INT 1
46871: PLUS
46872: ARRAY
46873: ST_TO_ADDR
46874: GO 47353
46876: LD_INT 16
46878: DOUBLE
46879: EQUAL
46880: IFTRUE 46932
46882: LD_INT 17
46884: DOUBLE
46885: EQUAL
46886: IFTRUE 46932
46888: LD_INT 18
46890: DOUBLE
46891: EQUAL
46892: IFTRUE 46932
46894: LD_INT 19
46896: DOUBLE
46897: EQUAL
46898: IFTRUE 46932
46900: LD_INT 20
46902: DOUBLE
46903: EQUAL
46904: IFTRUE 46932
46906: LD_INT 21
46908: DOUBLE
46909: EQUAL
46910: IFTRUE 46932
46912: LD_INT 23
46914: DOUBLE
46915: EQUAL
46916: IFTRUE 46932
46918: LD_INT 24
46920: DOUBLE
46921: EQUAL
46922: IFTRUE 46932
46924: LD_INT 25
46926: DOUBLE
46927: EQUAL
46928: IFTRUE 46932
46930: GO 46988
46932: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46933: LD_ADDR_VAR 0 9
46937: PUSH
46938: LD_VAR 0 35
46942: PUSH
46943: LD_VAR 0 36
46947: PUSH
46948: LD_VAR 0 37
46952: PUSH
46953: LD_VAR 0 38
46957: PUSH
46958: LD_VAR 0 39
46962: PUSH
46963: LD_VAR 0 40
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: PUSH
46976: LD_VAR 0 4
46980: PUSH
46981: LD_INT 1
46983: PLUS
46984: ARRAY
46985: ST_TO_ADDR
46986: GO 47353
46988: LD_INT 6
46990: DOUBLE
46991: EQUAL
46992: IFTRUE 47044
46994: LD_INT 7
46996: DOUBLE
46997: EQUAL
46998: IFTRUE 47044
47000: LD_INT 8
47002: DOUBLE
47003: EQUAL
47004: IFTRUE 47044
47006: LD_INT 13
47008: DOUBLE
47009: EQUAL
47010: IFTRUE 47044
47012: LD_INT 12
47014: DOUBLE
47015: EQUAL
47016: IFTRUE 47044
47018: LD_INT 15
47020: DOUBLE
47021: EQUAL
47022: IFTRUE 47044
47024: LD_INT 11
47026: DOUBLE
47027: EQUAL
47028: IFTRUE 47044
47030: LD_INT 14
47032: DOUBLE
47033: EQUAL
47034: IFTRUE 47044
47036: LD_INT 10
47038: DOUBLE
47039: EQUAL
47040: IFTRUE 47044
47042: GO 47100
47044: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47045: LD_ADDR_VAR 0 9
47049: PUSH
47050: LD_VAR 0 41
47054: PUSH
47055: LD_VAR 0 42
47059: PUSH
47060: LD_VAR 0 43
47064: PUSH
47065: LD_VAR 0 44
47069: PUSH
47070: LD_VAR 0 45
47074: PUSH
47075: LD_VAR 0 46
47079: PUSH
47080: EMPTY
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: PUSH
47088: LD_VAR 0 4
47092: PUSH
47093: LD_INT 1
47095: PLUS
47096: ARRAY
47097: ST_TO_ADDR
47098: GO 47353
47100: LD_INT 36
47102: DOUBLE
47103: EQUAL
47104: IFTRUE 47108
47106: GO 47164
47108: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47109: LD_ADDR_VAR 0 9
47113: PUSH
47114: LD_VAR 0 47
47118: PUSH
47119: LD_VAR 0 48
47123: PUSH
47124: LD_VAR 0 49
47128: PUSH
47129: LD_VAR 0 50
47133: PUSH
47134: LD_VAR 0 51
47138: PUSH
47139: LD_VAR 0 52
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: PUSH
47152: LD_VAR 0 4
47156: PUSH
47157: LD_INT 1
47159: PLUS
47160: ARRAY
47161: ST_TO_ADDR
47162: GO 47353
47164: LD_INT 4
47166: DOUBLE
47167: EQUAL
47168: IFTRUE 47190
47170: LD_INT 5
47172: DOUBLE
47173: EQUAL
47174: IFTRUE 47190
47176: LD_INT 34
47178: DOUBLE
47179: EQUAL
47180: IFTRUE 47190
47182: LD_INT 37
47184: DOUBLE
47185: EQUAL
47186: IFTRUE 47190
47188: GO 47246
47190: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47191: LD_ADDR_VAR 0 9
47195: PUSH
47196: LD_VAR 0 53
47200: PUSH
47201: LD_VAR 0 54
47205: PUSH
47206: LD_VAR 0 55
47210: PUSH
47211: LD_VAR 0 56
47215: PUSH
47216: LD_VAR 0 57
47220: PUSH
47221: LD_VAR 0 58
47225: PUSH
47226: EMPTY
47227: LIST
47228: LIST
47229: LIST
47230: LIST
47231: LIST
47232: LIST
47233: PUSH
47234: LD_VAR 0 4
47238: PUSH
47239: LD_INT 1
47241: PLUS
47242: ARRAY
47243: ST_TO_ADDR
47244: GO 47353
47246: LD_INT 31
47248: DOUBLE
47249: EQUAL
47250: IFTRUE 47296
47252: LD_INT 32
47254: DOUBLE
47255: EQUAL
47256: IFTRUE 47296
47258: LD_INT 33
47260: DOUBLE
47261: EQUAL
47262: IFTRUE 47296
47264: LD_INT 27
47266: DOUBLE
47267: EQUAL
47268: IFTRUE 47296
47270: LD_INT 26
47272: DOUBLE
47273: EQUAL
47274: IFTRUE 47296
47276: LD_INT 28
47278: DOUBLE
47279: EQUAL
47280: IFTRUE 47296
47282: LD_INT 29
47284: DOUBLE
47285: EQUAL
47286: IFTRUE 47296
47288: LD_INT 30
47290: DOUBLE
47291: EQUAL
47292: IFTRUE 47296
47294: GO 47352
47296: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47297: LD_ADDR_VAR 0 9
47301: PUSH
47302: LD_VAR 0 59
47306: PUSH
47307: LD_VAR 0 60
47311: PUSH
47312: LD_VAR 0 61
47316: PUSH
47317: LD_VAR 0 62
47321: PUSH
47322: LD_VAR 0 63
47326: PUSH
47327: LD_VAR 0 64
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: LIST
47336: LIST
47337: LIST
47338: LIST
47339: PUSH
47340: LD_VAR 0 4
47344: PUSH
47345: LD_INT 1
47347: PLUS
47348: ARRAY
47349: ST_TO_ADDR
47350: GO 47353
47352: POP
// temp_list2 = [ ] ;
47353: LD_ADDR_VAR 0 10
47357: PUSH
47358: EMPTY
47359: ST_TO_ADDR
// for i in temp_list do
47360: LD_ADDR_VAR 0 8
47364: PUSH
47365: LD_VAR 0 9
47369: PUSH
47370: FOR_IN
47371: IFFALSE 47423
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47373: LD_ADDR_VAR 0 10
47377: PUSH
47378: LD_VAR 0 10
47382: PUSH
47383: LD_VAR 0 8
47387: PUSH
47388: LD_INT 1
47390: ARRAY
47391: PUSH
47392: LD_VAR 0 2
47396: PLUS
47397: PUSH
47398: LD_VAR 0 8
47402: PUSH
47403: LD_INT 2
47405: ARRAY
47406: PUSH
47407: LD_VAR 0 3
47411: PLUS
47412: PUSH
47413: EMPTY
47414: LIST
47415: LIST
47416: PUSH
47417: EMPTY
47418: LIST
47419: ADD
47420: ST_TO_ADDR
47421: GO 47370
47423: POP
47424: POP
// result = temp_list2 ;
47425: LD_ADDR_VAR 0 7
47429: PUSH
47430: LD_VAR 0 10
47434: ST_TO_ADDR
// end ;
47435: LD_VAR 0 7
47439: RET
// export function EnemyInRange ( unit , dist ) ; begin
47440: LD_INT 0
47442: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47443: LD_ADDR_VAR 0 3
47447: PUSH
47448: LD_VAR 0 1
47452: PPUSH
47453: CALL_OW 255
47457: PPUSH
47458: LD_VAR 0 1
47462: PPUSH
47463: CALL_OW 250
47467: PPUSH
47468: LD_VAR 0 1
47472: PPUSH
47473: CALL_OW 251
47477: PPUSH
47478: LD_VAR 0 2
47482: PPUSH
47483: CALL 21568 0 4
47487: PUSH
47488: LD_INT 4
47490: ARRAY
47491: ST_TO_ADDR
// end ;
47492: LD_VAR 0 3
47496: RET
// export function PlayerSeeMe ( unit ) ; begin
47497: LD_INT 0
47499: PPUSH
// result := See ( your_side , unit ) ;
47500: LD_ADDR_VAR 0 2
47504: PUSH
47505: LD_OWVAR 2
47509: PPUSH
47510: LD_VAR 0 1
47514: PPUSH
47515: CALL_OW 292
47519: ST_TO_ADDR
// end ;
47520: LD_VAR 0 2
47524: RET
// export function ReverseDir ( unit ) ; begin
47525: LD_INT 0
47527: PPUSH
// if not unit then
47528: LD_VAR 0 1
47532: NOT
47533: IFFALSE 47537
// exit ;
47535: GO 47583
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47537: LD_ADDR_VAR 0 2
47541: PUSH
47542: LD_INT 3
47544: PUSH
47545: LD_INT 4
47547: PUSH
47548: LD_INT 5
47550: PUSH
47551: LD_INT 0
47553: PUSH
47554: LD_INT 1
47556: PUSH
47557: LD_INT 2
47559: PUSH
47560: EMPTY
47561: LIST
47562: LIST
47563: LIST
47564: LIST
47565: LIST
47566: LIST
47567: PUSH
47568: LD_VAR 0 1
47572: PPUSH
47573: CALL_OW 254
47577: PUSH
47578: LD_INT 1
47580: PLUS
47581: ARRAY
47582: ST_TO_ADDR
// end ;
47583: LD_VAR 0 2
47587: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47588: LD_INT 0
47590: PPUSH
47591: PPUSH
47592: PPUSH
47593: PPUSH
47594: PPUSH
// if not hexes then
47595: LD_VAR 0 2
47599: NOT
47600: IFFALSE 47604
// exit ;
47602: GO 47752
// dist := 9999 ;
47604: LD_ADDR_VAR 0 5
47608: PUSH
47609: LD_INT 9999
47611: ST_TO_ADDR
// for i = 1 to hexes do
47612: LD_ADDR_VAR 0 4
47616: PUSH
47617: DOUBLE
47618: LD_INT 1
47620: DEC
47621: ST_TO_ADDR
47622: LD_VAR 0 2
47626: PUSH
47627: FOR_TO
47628: IFFALSE 47740
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47630: LD_VAR 0 1
47634: PPUSH
47635: LD_VAR 0 2
47639: PUSH
47640: LD_VAR 0 4
47644: ARRAY
47645: PUSH
47646: LD_INT 1
47648: ARRAY
47649: PPUSH
47650: LD_VAR 0 2
47654: PUSH
47655: LD_VAR 0 4
47659: ARRAY
47660: PUSH
47661: LD_INT 2
47663: ARRAY
47664: PPUSH
47665: CALL_OW 297
47669: PUSH
47670: LD_VAR 0 5
47674: LESS
47675: IFFALSE 47738
// begin hex := hexes [ i ] ;
47677: LD_ADDR_VAR 0 7
47681: PUSH
47682: LD_VAR 0 2
47686: PUSH
47687: LD_VAR 0 4
47691: ARRAY
47692: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47693: LD_ADDR_VAR 0 5
47697: PUSH
47698: LD_VAR 0 1
47702: PPUSH
47703: LD_VAR 0 2
47707: PUSH
47708: LD_VAR 0 4
47712: ARRAY
47713: PUSH
47714: LD_INT 1
47716: ARRAY
47717: PPUSH
47718: LD_VAR 0 2
47722: PUSH
47723: LD_VAR 0 4
47727: ARRAY
47728: PUSH
47729: LD_INT 2
47731: ARRAY
47732: PPUSH
47733: CALL_OW 297
47737: ST_TO_ADDR
// end ; end ;
47738: GO 47627
47740: POP
47741: POP
// result := hex ;
47742: LD_ADDR_VAR 0 3
47746: PUSH
47747: LD_VAR 0 7
47751: ST_TO_ADDR
// end ;
47752: LD_VAR 0 3
47756: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47757: LD_INT 0
47759: PPUSH
47760: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47761: LD_VAR 0 1
47765: NOT
47766: PUSH
47767: LD_VAR 0 1
47771: PUSH
47772: LD_INT 21
47774: PUSH
47775: LD_INT 2
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PUSH
47782: LD_INT 23
47784: PUSH
47785: LD_INT 2
47787: PUSH
47788: EMPTY
47789: LIST
47790: LIST
47791: PUSH
47792: EMPTY
47793: LIST
47794: LIST
47795: PPUSH
47796: CALL_OW 69
47800: IN
47801: NOT
47802: OR
47803: IFFALSE 47807
// exit ;
47805: GO 47854
// for i = 1 to 3 do
47807: LD_ADDR_VAR 0 3
47811: PUSH
47812: DOUBLE
47813: LD_INT 1
47815: DEC
47816: ST_TO_ADDR
47817: LD_INT 3
47819: PUSH
47820: FOR_TO
47821: IFFALSE 47852
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47823: LD_VAR 0 1
47827: PPUSH
47828: CALL_OW 250
47832: PPUSH
47833: LD_VAR 0 1
47837: PPUSH
47838: CALL_OW 251
47842: PPUSH
47843: LD_INT 1
47845: PPUSH
47846: CALL_OW 453
47850: GO 47820
47852: POP
47853: POP
// end ;
47854: LD_VAR 0 2
47858: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47859: LD_INT 0
47861: PPUSH
47862: PPUSH
47863: PPUSH
47864: PPUSH
47865: PPUSH
47866: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47867: LD_VAR 0 1
47871: NOT
47872: PUSH
47873: LD_VAR 0 2
47877: NOT
47878: OR
47879: PUSH
47880: LD_VAR 0 1
47884: PPUSH
47885: CALL_OW 314
47889: OR
47890: IFFALSE 47894
// exit ;
47892: GO 48335
// x := GetX ( enemy_unit ) ;
47894: LD_ADDR_VAR 0 7
47898: PUSH
47899: LD_VAR 0 2
47903: PPUSH
47904: CALL_OW 250
47908: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47909: LD_ADDR_VAR 0 8
47913: PUSH
47914: LD_VAR 0 2
47918: PPUSH
47919: CALL_OW 251
47923: ST_TO_ADDR
// if not x or not y then
47924: LD_VAR 0 7
47928: NOT
47929: PUSH
47930: LD_VAR 0 8
47934: NOT
47935: OR
47936: IFFALSE 47940
// exit ;
47938: GO 48335
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47940: LD_ADDR_VAR 0 6
47944: PUSH
47945: LD_VAR 0 7
47949: PPUSH
47950: LD_INT 0
47952: PPUSH
47953: LD_INT 4
47955: PPUSH
47956: CALL_OW 272
47960: PUSH
47961: LD_VAR 0 8
47965: PPUSH
47966: LD_INT 0
47968: PPUSH
47969: LD_INT 4
47971: PPUSH
47972: CALL_OW 273
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: PUSH
47981: LD_VAR 0 7
47985: PPUSH
47986: LD_INT 1
47988: PPUSH
47989: LD_INT 4
47991: PPUSH
47992: CALL_OW 272
47996: PUSH
47997: LD_VAR 0 8
48001: PPUSH
48002: LD_INT 1
48004: PPUSH
48005: LD_INT 4
48007: PPUSH
48008: CALL_OW 273
48012: PUSH
48013: EMPTY
48014: LIST
48015: LIST
48016: PUSH
48017: LD_VAR 0 7
48021: PPUSH
48022: LD_INT 2
48024: PPUSH
48025: LD_INT 4
48027: PPUSH
48028: CALL_OW 272
48032: PUSH
48033: LD_VAR 0 8
48037: PPUSH
48038: LD_INT 2
48040: PPUSH
48041: LD_INT 4
48043: PPUSH
48044: CALL_OW 273
48048: PUSH
48049: EMPTY
48050: LIST
48051: LIST
48052: PUSH
48053: LD_VAR 0 7
48057: PPUSH
48058: LD_INT 3
48060: PPUSH
48061: LD_INT 4
48063: PPUSH
48064: CALL_OW 272
48068: PUSH
48069: LD_VAR 0 8
48073: PPUSH
48074: LD_INT 3
48076: PPUSH
48077: LD_INT 4
48079: PPUSH
48080: CALL_OW 273
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: PUSH
48089: LD_VAR 0 7
48093: PPUSH
48094: LD_INT 4
48096: PPUSH
48097: LD_INT 4
48099: PPUSH
48100: CALL_OW 272
48104: PUSH
48105: LD_VAR 0 8
48109: PPUSH
48110: LD_INT 4
48112: PPUSH
48113: LD_INT 4
48115: PPUSH
48116: CALL_OW 273
48120: PUSH
48121: EMPTY
48122: LIST
48123: LIST
48124: PUSH
48125: LD_VAR 0 7
48129: PPUSH
48130: LD_INT 5
48132: PPUSH
48133: LD_INT 4
48135: PPUSH
48136: CALL_OW 272
48140: PUSH
48141: LD_VAR 0 8
48145: PPUSH
48146: LD_INT 5
48148: PPUSH
48149: LD_INT 4
48151: PPUSH
48152: CALL_OW 273
48156: PUSH
48157: EMPTY
48158: LIST
48159: LIST
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: LIST
48168: ST_TO_ADDR
// for i = tmp downto 1 do
48169: LD_ADDR_VAR 0 4
48173: PUSH
48174: DOUBLE
48175: LD_VAR 0 6
48179: INC
48180: ST_TO_ADDR
48181: LD_INT 1
48183: PUSH
48184: FOR_DOWNTO
48185: IFFALSE 48286
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48187: LD_VAR 0 6
48191: PUSH
48192: LD_VAR 0 4
48196: ARRAY
48197: PUSH
48198: LD_INT 1
48200: ARRAY
48201: PPUSH
48202: LD_VAR 0 6
48206: PUSH
48207: LD_VAR 0 4
48211: ARRAY
48212: PUSH
48213: LD_INT 2
48215: ARRAY
48216: PPUSH
48217: CALL_OW 488
48221: NOT
48222: PUSH
48223: LD_VAR 0 6
48227: PUSH
48228: LD_VAR 0 4
48232: ARRAY
48233: PUSH
48234: LD_INT 1
48236: ARRAY
48237: PPUSH
48238: LD_VAR 0 6
48242: PUSH
48243: LD_VAR 0 4
48247: ARRAY
48248: PUSH
48249: LD_INT 2
48251: ARRAY
48252: PPUSH
48253: CALL_OW 428
48257: PUSH
48258: LD_INT 0
48260: NONEQUAL
48261: OR
48262: IFFALSE 48284
// tmp := Delete ( tmp , i ) ;
48264: LD_ADDR_VAR 0 6
48268: PUSH
48269: LD_VAR 0 6
48273: PPUSH
48274: LD_VAR 0 4
48278: PPUSH
48279: CALL_OW 3
48283: ST_TO_ADDR
48284: GO 48184
48286: POP
48287: POP
// j := GetClosestHex ( unit , tmp ) ;
48288: LD_ADDR_VAR 0 5
48292: PUSH
48293: LD_VAR 0 1
48297: PPUSH
48298: LD_VAR 0 6
48302: PPUSH
48303: CALL 47588 0 2
48307: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48308: LD_VAR 0 1
48312: PPUSH
48313: LD_VAR 0 5
48317: PUSH
48318: LD_INT 1
48320: ARRAY
48321: PPUSH
48322: LD_VAR 0 5
48326: PUSH
48327: LD_INT 2
48329: ARRAY
48330: PPUSH
48331: CALL_OW 111
// end ;
48335: LD_VAR 0 3
48339: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48340: LD_INT 0
48342: PPUSH
48343: PPUSH
48344: PPUSH
// uc_side = 0 ;
48345: LD_ADDR_OWVAR 20
48349: PUSH
48350: LD_INT 0
48352: ST_TO_ADDR
// uc_nation = 0 ;
48353: LD_ADDR_OWVAR 21
48357: PUSH
48358: LD_INT 0
48360: ST_TO_ADDR
// InitHc ;
48361: CALL_OW 19
// InitVc ;
48365: CALL_OW 20
// if mastodonts then
48369: LD_VAR 0 6
48373: IFFALSE 48440
// for i = 1 to mastodonts do
48375: LD_ADDR_VAR 0 11
48379: PUSH
48380: DOUBLE
48381: LD_INT 1
48383: DEC
48384: ST_TO_ADDR
48385: LD_VAR 0 6
48389: PUSH
48390: FOR_TO
48391: IFFALSE 48438
// begin vc_chassis := 31 ;
48393: LD_ADDR_OWVAR 37
48397: PUSH
48398: LD_INT 31
48400: ST_TO_ADDR
// vc_control := control_rider ;
48401: LD_ADDR_OWVAR 38
48405: PUSH
48406: LD_INT 4
48408: ST_TO_ADDR
// animal := CreateVehicle ;
48409: LD_ADDR_VAR 0 12
48413: PUSH
48414: CALL_OW 45
48418: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48419: LD_VAR 0 12
48423: PPUSH
48424: LD_VAR 0 8
48428: PPUSH
48429: LD_INT 0
48431: PPUSH
48432: CALL 55185 0 3
// end ;
48436: GO 48390
48438: POP
48439: POP
// if horses then
48440: LD_VAR 0 5
48444: IFFALSE 48511
// for i = 1 to horses do
48446: LD_ADDR_VAR 0 11
48450: PUSH
48451: DOUBLE
48452: LD_INT 1
48454: DEC
48455: ST_TO_ADDR
48456: LD_VAR 0 5
48460: PUSH
48461: FOR_TO
48462: IFFALSE 48509
// begin hc_class := 21 ;
48464: LD_ADDR_OWVAR 28
48468: PUSH
48469: LD_INT 21
48471: ST_TO_ADDR
// hc_gallery :=  ;
48472: LD_ADDR_OWVAR 33
48476: PUSH
48477: LD_STRING 
48479: ST_TO_ADDR
// animal := CreateHuman ;
48480: LD_ADDR_VAR 0 12
48484: PUSH
48485: CALL_OW 44
48489: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48490: LD_VAR 0 12
48494: PPUSH
48495: LD_VAR 0 8
48499: PPUSH
48500: LD_INT 0
48502: PPUSH
48503: CALL 55185 0 3
// end ;
48507: GO 48461
48509: POP
48510: POP
// if birds then
48511: LD_VAR 0 1
48515: IFFALSE 48582
// for i = 1 to birds do
48517: LD_ADDR_VAR 0 11
48521: PUSH
48522: DOUBLE
48523: LD_INT 1
48525: DEC
48526: ST_TO_ADDR
48527: LD_VAR 0 1
48531: PUSH
48532: FOR_TO
48533: IFFALSE 48580
// begin hc_class = 18 ;
48535: LD_ADDR_OWVAR 28
48539: PUSH
48540: LD_INT 18
48542: ST_TO_ADDR
// hc_gallery =  ;
48543: LD_ADDR_OWVAR 33
48547: PUSH
48548: LD_STRING 
48550: ST_TO_ADDR
// animal := CreateHuman ;
48551: LD_ADDR_VAR 0 12
48555: PUSH
48556: CALL_OW 44
48560: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48561: LD_VAR 0 12
48565: PPUSH
48566: LD_VAR 0 8
48570: PPUSH
48571: LD_INT 0
48573: PPUSH
48574: CALL 55185 0 3
// end ;
48578: GO 48532
48580: POP
48581: POP
// if tigers then
48582: LD_VAR 0 2
48586: IFFALSE 48670
// for i = 1 to tigers do
48588: LD_ADDR_VAR 0 11
48592: PUSH
48593: DOUBLE
48594: LD_INT 1
48596: DEC
48597: ST_TO_ADDR
48598: LD_VAR 0 2
48602: PUSH
48603: FOR_TO
48604: IFFALSE 48668
// begin hc_class = class_tiger ;
48606: LD_ADDR_OWVAR 28
48610: PUSH
48611: LD_INT 14
48613: ST_TO_ADDR
// hc_gallery =  ;
48614: LD_ADDR_OWVAR 33
48618: PUSH
48619: LD_STRING 
48621: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48622: LD_ADDR_OWVAR 35
48626: PUSH
48627: LD_INT 7
48629: NEG
48630: PPUSH
48631: LD_INT 7
48633: PPUSH
48634: CALL_OW 12
48638: ST_TO_ADDR
// animal := CreateHuman ;
48639: LD_ADDR_VAR 0 12
48643: PUSH
48644: CALL_OW 44
48648: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48649: LD_VAR 0 12
48653: PPUSH
48654: LD_VAR 0 8
48658: PPUSH
48659: LD_INT 0
48661: PPUSH
48662: CALL 55185 0 3
// end ;
48666: GO 48603
48668: POP
48669: POP
// if apemans then
48670: LD_VAR 0 3
48674: IFFALSE 48797
// for i = 1 to apemans do
48676: LD_ADDR_VAR 0 11
48680: PUSH
48681: DOUBLE
48682: LD_INT 1
48684: DEC
48685: ST_TO_ADDR
48686: LD_VAR 0 3
48690: PUSH
48691: FOR_TO
48692: IFFALSE 48795
// begin hc_class = class_apeman ;
48694: LD_ADDR_OWVAR 28
48698: PUSH
48699: LD_INT 12
48701: ST_TO_ADDR
// hc_gallery =  ;
48702: LD_ADDR_OWVAR 33
48706: PUSH
48707: LD_STRING 
48709: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48710: LD_ADDR_OWVAR 35
48714: PUSH
48715: LD_INT 5
48717: NEG
48718: PPUSH
48719: LD_INT 5
48721: PPUSH
48722: CALL_OW 12
48726: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48727: LD_ADDR_OWVAR 31
48731: PUSH
48732: LD_INT 1
48734: PPUSH
48735: LD_INT 3
48737: PPUSH
48738: CALL_OW 12
48742: PUSH
48743: LD_INT 1
48745: PPUSH
48746: LD_INT 3
48748: PPUSH
48749: CALL_OW 12
48753: PUSH
48754: LD_INT 0
48756: PUSH
48757: LD_INT 0
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: LIST
48764: LIST
48765: ST_TO_ADDR
// animal := CreateHuman ;
48766: LD_ADDR_VAR 0 12
48770: PUSH
48771: CALL_OW 44
48775: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48776: LD_VAR 0 12
48780: PPUSH
48781: LD_VAR 0 8
48785: PPUSH
48786: LD_INT 0
48788: PPUSH
48789: CALL 55185 0 3
// end ;
48793: GO 48691
48795: POP
48796: POP
// if enchidnas then
48797: LD_VAR 0 4
48801: IFFALSE 48868
// for i = 1 to enchidnas do
48803: LD_ADDR_VAR 0 11
48807: PUSH
48808: DOUBLE
48809: LD_INT 1
48811: DEC
48812: ST_TO_ADDR
48813: LD_VAR 0 4
48817: PUSH
48818: FOR_TO
48819: IFFALSE 48866
// begin hc_class = 13 ;
48821: LD_ADDR_OWVAR 28
48825: PUSH
48826: LD_INT 13
48828: ST_TO_ADDR
// hc_gallery =  ;
48829: LD_ADDR_OWVAR 33
48833: PUSH
48834: LD_STRING 
48836: ST_TO_ADDR
// animal := CreateHuman ;
48837: LD_ADDR_VAR 0 12
48841: PUSH
48842: CALL_OW 44
48846: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48847: LD_VAR 0 12
48851: PPUSH
48852: LD_VAR 0 8
48856: PPUSH
48857: LD_INT 0
48859: PPUSH
48860: CALL 55185 0 3
// end ;
48864: GO 48818
48866: POP
48867: POP
// if fishes then
48868: LD_VAR 0 7
48872: IFFALSE 48939
// for i = 1 to fishes do
48874: LD_ADDR_VAR 0 11
48878: PUSH
48879: DOUBLE
48880: LD_INT 1
48882: DEC
48883: ST_TO_ADDR
48884: LD_VAR 0 7
48888: PUSH
48889: FOR_TO
48890: IFFALSE 48937
// begin hc_class = 20 ;
48892: LD_ADDR_OWVAR 28
48896: PUSH
48897: LD_INT 20
48899: ST_TO_ADDR
// hc_gallery =  ;
48900: LD_ADDR_OWVAR 33
48904: PUSH
48905: LD_STRING 
48907: ST_TO_ADDR
// animal := CreateHuman ;
48908: LD_ADDR_VAR 0 12
48912: PUSH
48913: CALL_OW 44
48917: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
48918: LD_VAR 0 12
48922: PPUSH
48923: LD_VAR 0 9
48927: PPUSH
48928: LD_INT 0
48930: PPUSH
48931: CALL 55185 0 3
// end ;
48935: GO 48889
48937: POP
48938: POP
// end ;
48939: LD_VAR 0 10
48943: RET
// export function WantHeal ( sci , unit ) ; begin
48944: LD_INT 0
48946: PPUSH
// if GetTaskList ( sci ) > 0 then
48947: LD_VAR 0 1
48951: PPUSH
48952: CALL_OW 437
48956: PUSH
48957: LD_INT 0
48959: GREATER
48960: IFFALSE 49030
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
48962: LD_VAR 0 1
48966: PPUSH
48967: CALL_OW 437
48971: PUSH
48972: LD_INT 1
48974: ARRAY
48975: PUSH
48976: LD_INT 1
48978: ARRAY
48979: PUSH
48980: LD_STRING l
48982: EQUAL
48983: PUSH
48984: LD_VAR 0 1
48988: PPUSH
48989: CALL_OW 437
48993: PUSH
48994: LD_INT 1
48996: ARRAY
48997: PUSH
48998: LD_INT 4
49000: ARRAY
49001: PUSH
49002: LD_VAR 0 2
49006: EQUAL
49007: AND
49008: IFFALSE 49020
// result := true else
49010: LD_ADDR_VAR 0 3
49014: PUSH
49015: LD_INT 1
49017: ST_TO_ADDR
49018: GO 49028
// result := false ;
49020: LD_ADDR_VAR 0 3
49024: PUSH
49025: LD_INT 0
49027: ST_TO_ADDR
// end else
49028: GO 49038
// result := false ;
49030: LD_ADDR_VAR 0 3
49034: PUSH
49035: LD_INT 0
49037: ST_TO_ADDR
// end ;
49038: LD_VAR 0 3
49042: RET
// export function HealTarget ( sci ) ; begin
49043: LD_INT 0
49045: PPUSH
// if not sci then
49046: LD_VAR 0 1
49050: NOT
49051: IFFALSE 49055
// exit ;
49053: GO 49120
// result := 0 ;
49055: LD_ADDR_VAR 0 2
49059: PUSH
49060: LD_INT 0
49062: ST_TO_ADDR
// if GetTaskList ( sci ) then
49063: LD_VAR 0 1
49067: PPUSH
49068: CALL_OW 437
49072: IFFALSE 49120
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49074: LD_VAR 0 1
49078: PPUSH
49079: CALL_OW 437
49083: PUSH
49084: LD_INT 1
49086: ARRAY
49087: PUSH
49088: LD_INT 1
49090: ARRAY
49091: PUSH
49092: LD_STRING l
49094: EQUAL
49095: IFFALSE 49120
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49097: LD_ADDR_VAR 0 2
49101: PUSH
49102: LD_VAR 0 1
49106: PPUSH
49107: CALL_OW 437
49111: PUSH
49112: LD_INT 1
49114: ARRAY
49115: PUSH
49116: LD_INT 4
49118: ARRAY
49119: ST_TO_ADDR
// end ;
49120: LD_VAR 0 2
49124: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49125: LD_INT 0
49127: PPUSH
49128: PPUSH
49129: PPUSH
49130: PPUSH
49131: PPUSH
49132: PPUSH
49133: PPUSH
49134: PPUSH
49135: PPUSH
49136: PPUSH
49137: PPUSH
49138: PPUSH
49139: PPUSH
49140: PPUSH
49141: PPUSH
49142: PPUSH
49143: PPUSH
49144: PPUSH
49145: PPUSH
49146: PPUSH
49147: PPUSH
49148: PPUSH
49149: PPUSH
49150: PPUSH
49151: PPUSH
49152: PPUSH
49153: PPUSH
49154: PPUSH
49155: PPUSH
49156: PPUSH
49157: PPUSH
49158: PPUSH
49159: PPUSH
49160: PPUSH
// if not list then
49161: LD_VAR 0 1
49165: NOT
49166: IFFALSE 49170
// exit ;
49168: GO 53796
// base := list [ 1 ] ;
49170: LD_ADDR_VAR 0 3
49174: PUSH
49175: LD_VAR 0 1
49179: PUSH
49180: LD_INT 1
49182: ARRAY
49183: ST_TO_ADDR
// group := list [ 2 ] ;
49184: LD_ADDR_VAR 0 4
49188: PUSH
49189: LD_VAR 0 1
49193: PUSH
49194: LD_INT 2
49196: ARRAY
49197: ST_TO_ADDR
// path := list [ 3 ] ;
49198: LD_ADDR_VAR 0 5
49202: PUSH
49203: LD_VAR 0 1
49207: PUSH
49208: LD_INT 3
49210: ARRAY
49211: ST_TO_ADDR
// flags := list [ 4 ] ;
49212: LD_ADDR_VAR 0 6
49216: PUSH
49217: LD_VAR 0 1
49221: PUSH
49222: LD_INT 4
49224: ARRAY
49225: ST_TO_ADDR
// mined := [ ] ;
49226: LD_ADDR_VAR 0 27
49230: PUSH
49231: EMPTY
49232: ST_TO_ADDR
// bombed := [ ] ;
49233: LD_ADDR_VAR 0 28
49237: PUSH
49238: EMPTY
49239: ST_TO_ADDR
// healers := [ ] ;
49240: LD_ADDR_VAR 0 31
49244: PUSH
49245: EMPTY
49246: ST_TO_ADDR
// to_heal := [ ] ;
49247: LD_ADDR_VAR 0 30
49251: PUSH
49252: EMPTY
49253: ST_TO_ADDR
// repairs := [ ] ;
49254: LD_ADDR_VAR 0 33
49258: PUSH
49259: EMPTY
49260: ST_TO_ADDR
// to_repair := [ ] ;
49261: LD_ADDR_VAR 0 32
49265: PUSH
49266: EMPTY
49267: ST_TO_ADDR
// if not group or not path then
49268: LD_VAR 0 4
49272: NOT
49273: PUSH
49274: LD_VAR 0 5
49278: NOT
49279: OR
49280: IFFALSE 49284
// exit ;
49282: GO 53796
// side := GetSide ( group [ 1 ] ) ;
49284: LD_ADDR_VAR 0 35
49288: PUSH
49289: LD_VAR 0 4
49293: PUSH
49294: LD_INT 1
49296: ARRAY
49297: PPUSH
49298: CALL_OW 255
49302: ST_TO_ADDR
// if flags then
49303: LD_VAR 0 6
49307: IFFALSE 49451
// begin f_ignore_area := flags [ 1 ] ;
49309: LD_ADDR_VAR 0 17
49313: PUSH
49314: LD_VAR 0 6
49318: PUSH
49319: LD_INT 1
49321: ARRAY
49322: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49323: LD_ADDR_VAR 0 18
49327: PUSH
49328: LD_VAR 0 6
49332: PUSH
49333: LD_INT 2
49335: ARRAY
49336: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49337: LD_ADDR_VAR 0 19
49341: PUSH
49342: LD_VAR 0 6
49346: PUSH
49347: LD_INT 3
49349: ARRAY
49350: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49351: LD_ADDR_VAR 0 20
49355: PUSH
49356: LD_VAR 0 6
49360: PUSH
49361: LD_INT 4
49363: ARRAY
49364: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49365: LD_ADDR_VAR 0 21
49369: PUSH
49370: LD_VAR 0 6
49374: PUSH
49375: LD_INT 5
49377: ARRAY
49378: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49379: LD_ADDR_VAR 0 22
49383: PUSH
49384: LD_VAR 0 6
49388: PUSH
49389: LD_INT 6
49391: ARRAY
49392: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49393: LD_ADDR_VAR 0 23
49397: PUSH
49398: LD_VAR 0 6
49402: PUSH
49403: LD_INT 7
49405: ARRAY
49406: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49407: LD_ADDR_VAR 0 24
49411: PUSH
49412: LD_VAR 0 6
49416: PUSH
49417: LD_INT 8
49419: ARRAY
49420: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49421: LD_ADDR_VAR 0 25
49425: PUSH
49426: LD_VAR 0 6
49430: PUSH
49431: LD_INT 9
49433: ARRAY
49434: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49435: LD_ADDR_VAR 0 26
49439: PUSH
49440: LD_VAR 0 6
49444: PUSH
49445: LD_INT 10
49447: ARRAY
49448: ST_TO_ADDR
// end else
49449: GO 49531
// begin f_ignore_area := false ;
49451: LD_ADDR_VAR 0 17
49455: PUSH
49456: LD_INT 0
49458: ST_TO_ADDR
// f_capture := false ;
49459: LD_ADDR_VAR 0 18
49463: PUSH
49464: LD_INT 0
49466: ST_TO_ADDR
// f_ignore_civ := false ;
49467: LD_ADDR_VAR 0 19
49471: PUSH
49472: LD_INT 0
49474: ST_TO_ADDR
// f_murder := false ;
49475: LD_ADDR_VAR 0 20
49479: PUSH
49480: LD_INT 0
49482: ST_TO_ADDR
// f_mines := false ;
49483: LD_ADDR_VAR 0 21
49487: PUSH
49488: LD_INT 0
49490: ST_TO_ADDR
// f_repair := false ;
49491: LD_ADDR_VAR 0 22
49495: PUSH
49496: LD_INT 0
49498: ST_TO_ADDR
// f_heal := false ;
49499: LD_ADDR_VAR 0 23
49503: PUSH
49504: LD_INT 0
49506: ST_TO_ADDR
// f_spacetime := false ;
49507: LD_ADDR_VAR 0 24
49511: PUSH
49512: LD_INT 0
49514: ST_TO_ADDR
// f_attack_depot := false ;
49515: LD_ADDR_VAR 0 25
49519: PUSH
49520: LD_INT 0
49522: ST_TO_ADDR
// f_crawl := false ;
49523: LD_ADDR_VAR 0 26
49527: PUSH
49528: LD_INT 0
49530: ST_TO_ADDR
// end ; if f_heal then
49531: LD_VAR 0 23
49535: IFFALSE 49562
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49537: LD_ADDR_VAR 0 31
49541: PUSH
49542: LD_VAR 0 4
49546: PPUSH
49547: LD_INT 25
49549: PUSH
49550: LD_INT 4
49552: PUSH
49553: EMPTY
49554: LIST
49555: LIST
49556: PPUSH
49557: CALL_OW 72
49561: ST_TO_ADDR
// if f_repair then
49562: LD_VAR 0 22
49566: IFFALSE 49593
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49568: LD_ADDR_VAR 0 33
49572: PUSH
49573: LD_VAR 0 4
49577: PPUSH
49578: LD_INT 25
49580: PUSH
49581: LD_INT 3
49583: PUSH
49584: EMPTY
49585: LIST
49586: LIST
49587: PPUSH
49588: CALL_OW 72
49592: ST_TO_ADDR
// units_path := [ ] ;
49593: LD_ADDR_VAR 0 16
49597: PUSH
49598: EMPTY
49599: ST_TO_ADDR
// for i = 1 to group do
49600: LD_ADDR_VAR 0 7
49604: PUSH
49605: DOUBLE
49606: LD_INT 1
49608: DEC
49609: ST_TO_ADDR
49610: LD_VAR 0 4
49614: PUSH
49615: FOR_TO
49616: IFFALSE 49645
// units_path := Replace ( units_path , i , path ) ;
49618: LD_ADDR_VAR 0 16
49622: PUSH
49623: LD_VAR 0 16
49627: PPUSH
49628: LD_VAR 0 7
49632: PPUSH
49633: LD_VAR 0 5
49637: PPUSH
49638: CALL_OW 1
49642: ST_TO_ADDR
49643: GO 49615
49645: POP
49646: POP
// repeat for i = group downto 1 do
49647: LD_ADDR_VAR 0 7
49651: PUSH
49652: DOUBLE
49653: LD_VAR 0 4
49657: INC
49658: ST_TO_ADDR
49659: LD_INT 1
49661: PUSH
49662: FOR_DOWNTO
49663: IFFALSE 53759
// begin wait ( 5 ) ;
49665: LD_INT 5
49667: PPUSH
49668: CALL_OW 67
// tmp := [ ] ;
49672: LD_ADDR_VAR 0 14
49676: PUSH
49677: EMPTY
49678: ST_TO_ADDR
// attacking := false ;
49679: LD_ADDR_VAR 0 29
49683: PUSH
49684: LD_INT 0
49686: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49687: LD_VAR 0 4
49691: PUSH
49692: LD_VAR 0 7
49696: ARRAY
49697: PPUSH
49698: CALL_OW 301
49702: PUSH
49703: LD_VAR 0 4
49707: PUSH
49708: LD_VAR 0 7
49712: ARRAY
49713: NOT
49714: OR
49715: IFFALSE 49824
// begin if GetType ( group [ i ] ) = unit_human then
49717: LD_VAR 0 4
49721: PUSH
49722: LD_VAR 0 7
49726: ARRAY
49727: PPUSH
49728: CALL_OW 247
49732: PUSH
49733: LD_INT 1
49735: EQUAL
49736: IFFALSE 49782
// begin to_heal := to_heal diff group [ i ] ;
49738: LD_ADDR_VAR 0 30
49742: PUSH
49743: LD_VAR 0 30
49747: PUSH
49748: LD_VAR 0 4
49752: PUSH
49753: LD_VAR 0 7
49757: ARRAY
49758: DIFF
49759: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49760: LD_ADDR_VAR 0 31
49764: PUSH
49765: LD_VAR 0 31
49769: PUSH
49770: LD_VAR 0 4
49774: PUSH
49775: LD_VAR 0 7
49779: ARRAY
49780: DIFF
49781: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49782: LD_ADDR_VAR 0 4
49786: PUSH
49787: LD_VAR 0 4
49791: PPUSH
49792: LD_VAR 0 7
49796: PPUSH
49797: CALL_OW 3
49801: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49802: LD_ADDR_VAR 0 16
49806: PUSH
49807: LD_VAR 0 16
49811: PPUSH
49812: LD_VAR 0 7
49816: PPUSH
49817: CALL_OW 3
49821: ST_TO_ADDR
// continue ;
49822: GO 49662
// end ; if f_repair then
49824: LD_VAR 0 22
49828: IFFALSE 50317
// begin if GetType ( group [ i ] ) = unit_vehicle then
49830: LD_VAR 0 4
49834: PUSH
49835: LD_VAR 0 7
49839: ARRAY
49840: PPUSH
49841: CALL_OW 247
49845: PUSH
49846: LD_INT 2
49848: EQUAL
49849: IFFALSE 50039
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
49851: LD_VAR 0 4
49855: PUSH
49856: LD_VAR 0 7
49860: ARRAY
49861: PPUSH
49862: CALL_OW 256
49866: PUSH
49867: LD_INT 700
49869: LESS
49870: PUSH
49871: LD_VAR 0 4
49875: PUSH
49876: LD_VAR 0 7
49880: ARRAY
49881: PUSH
49882: LD_VAR 0 32
49886: IN
49887: NOT
49888: AND
49889: IFFALSE 49913
// to_repair := to_repair union group [ i ] ;
49891: LD_ADDR_VAR 0 32
49895: PUSH
49896: LD_VAR 0 32
49900: PUSH
49901: LD_VAR 0 4
49905: PUSH
49906: LD_VAR 0 7
49910: ARRAY
49911: UNION
49912: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
49913: LD_VAR 0 4
49917: PUSH
49918: LD_VAR 0 7
49922: ARRAY
49923: PPUSH
49924: CALL_OW 256
49928: PUSH
49929: LD_INT 1000
49931: EQUAL
49932: PUSH
49933: LD_VAR 0 4
49937: PUSH
49938: LD_VAR 0 7
49942: ARRAY
49943: PUSH
49944: LD_VAR 0 32
49948: IN
49949: AND
49950: IFFALSE 49974
// to_repair := to_repair diff group [ i ] ;
49952: LD_ADDR_VAR 0 32
49956: PUSH
49957: LD_VAR 0 32
49961: PUSH
49962: LD_VAR 0 4
49966: PUSH
49967: LD_VAR 0 7
49971: ARRAY
49972: DIFF
49973: ST_TO_ADDR
// if group [ i ] in to_repair then
49974: LD_VAR 0 4
49978: PUSH
49979: LD_VAR 0 7
49983: ARRAY
49984: PUSH
49985: LD_VAR 0 32
49989: IN
49990: IFFALSE 50037
// begin if not IsInArea ( group [ i ] , f_repair ) then
49992: LD_VAR 0 4
49996: PUSH
49997: LD_VAR 0 7
50001: ARRAY
50002: PPUSH
50003: LD_VAR 0 22
50007: PPUSH
50008: CALL_OW 308
50012: NOT
50013: IFFALSE 50035
// ComMoveToArea ( group [ i ] , f_repair ) ;
50015: LD_VAR 0 4
50019: PUSH
50020: LD_VAR 0 7
50024: ARRAY
50025: PPUSH
50026: LD_VAR 0 22
50030: PPUSH
50031: CALL_OW 113
// continue ;
50035: GO 49662
// end ; end else
50037: GO 50317
// if group [ i ] in repairs then
50039: LD_VAR 0 4
50043: PUSH
50044: LD_VAR 0 7
50048: ARRAY
50049: PUSH
50050: LD_VAR 0 33
50054: IN
50055: IFFALSE 50317
// begin if IsInUnit ( group [ i ] ) then
50057: LD_VAR 0 4
50061: PUSH
50062: LD_VAR 0 7
50066: ARRAY
50067: PPUSH
50068: CALL_OW 310
50072: IFFALSE 50140
// begin z := IsInUnit ( group [ i ] ) ;
50074: LD_ADDR_VAR 0 13
50078: PUSH
50079: LD_VAR 0 4
50083: PUSH
50084: LD_VAR 0 7
50088: ARRAY
50089: PPUSH
50090: CALL_OW 310
50094: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50095: LD_VAR 0 13
50099: PUSH
50100: LD_VAR 0 32
50104: IN
50105: PUSH
50106: LD_VAR 0 13
50110: PPUSH
50111: LD_VAR 0 22
50115: PPUSH
50116: CALL_OW 308
50120: AND
50121: IFFALSE 50138
// ComExitVehicle ( group [ i ] ) ;
50123: LD_VAR 0 4
50127: PUSH
50128: LD_VAR 0 7
50132: ARRAY
50133: PPUSH
50134: CALL_OW 121
// end else
50138: GO 50317
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50140: LD_ADDR_VAR 0 13
50144: PUSH
50145: LD_VAR 0 4
50149: PPUSH
50150: LD_INT 95
50152: PUSH
50153: LD_VAR 0 22
50157: PUSH
50158: EMPTY
50159: LIST
50160: LIST
50161: PUSH
50162: LD_INT 58
50164: PUSH
50165: EMPTY
50166: LIST
50167: PUSH
50168: EMPTY
50169: LIST
50170: LIST
50171: PPUSH
50172: CALL_OW 72
50176: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50177: LD_VAR 0 4
50181: PUSH
50182: LD_VAR 0 7
50186: ARRAY
50187: PPUSH
50188: CALL_OW 314
50192: NOT
50193: IFFALSE 50315
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50195: LD_ADDR_VAR 0 10
50199: PUSH
50200: LD_VAR 0 13
50204: PPUSH
50205: LD_VAR 0 4
50209: PUSH
50210: LD_VAR 0 7
50214: ARRAY
50215: PPUSH
50216: CALL_OW 74
50220: ST_TO_ADDR
// if not x then
50221: LD_VAR 0 10
50225: NOT
50226: IFFALSE 50230
// continue ;
50228: GO 49662
// if GetLives ( x ) < 1000 then
50230: LD_VAR 0 10
50234: PPUSH
50235: CALL_OW 256
50239: PUSH
50240: LD_INT 1000
50242: LESS
50243: IFFALSE 50267
// ComRepairVehicle ( group [ i ] , x ) else
50245: LD_VAR 0 4
50249: PUSH
50250: LD_VAR 0 7
50254: ARRAY
50255: PPUSH
50256: LD_VAR 0 10
50260: PPUSH
50261: CALL_OW 129
50265: GO 50315
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50267: LD_VAR 0 23
50271: PUSH
50272: LD_VAR 0 4
50276: PUSH
50277: LD_VAR 0 7
50281: ARRAY
50282: PPUSH
50283: CALL_OW 256
50287: PUSH
50288: LD_INT 1000
50290: LESS
50291: AND
50292: NOT
50293: IFFALSE 50315
// ComEnterUnit ( group [ i ] , x ) ;
50295: LD_VAR 0 4
50299: PUSH
50300: LD_VAR 0 7
50304: ARRAY
50305: PPUSH
50306: LD_VAR 0 10
50310: PPUSH
50311: CALL_OW 120
// end ; continue ;
50315: GO 49662
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50317: LD_VAR 0 23
50321: PUSH
50322: LD_VAR 0 4
50326: PUSH
50327: LD_VAR 0 7
50331: ARRAY
50332: PPUSH
50333: CALL_OW 247
50337: PUSH
50338: LD_INT 1
50340: EQUAL
50341: AND
50342: IFFALSE 50820
// begin if group [ i ] in healers then
50344: LD_VAR 0 4
50348: PUSH
50349: LD_VAR 0 7
50353: ARRAY
50354: PUSH
50355: LD_VAR 0 31
50359: IN
50360: IFFALSE 50633
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50362: LD_VAR 0 4
50366: PUSH
50367: LD_VAR 0 7
50371: ARRAY
50372: PPUSH
50373: LD_VAR 0 23
50377: PPUSH
50378: CALL_OW 308
50382: NOT
50383: PUSH
50384: LD_VAR 0 4
50388: PUSH
50389: LD_VAR 0 7
50393: ARRAY
50394: PPUSH
50395: CALL_OW 314
50399: NOT
50400: AND
50401: IFFALSE 50425
// ComMoveToArea ( group [ i ] , f_heal ) else
50403: LD_VAR 0 4
50407: PUSH
50408: LD_VAR 0 7
50412: ARRAY
50413: PPUSH
50414: LD_VAR 0 23
50418: PPUSH
50419: CALL_OW 113
50423: GO 50631
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50425: LD_VAR 0 4
50429: PUSH
50430: LD_VAR 0 7
50434: ARRAY
50435: PPUSH
50436: CALL 49043 0 1
50440: PPUSH
50441: CALL_OW 256
50445: PUSH
50446: LD_INT 1000
50448: EQUAL
50449: IFFALSE 50468
// ComStop ( group [ i ] ) else
50451: LD_VAR 0 4
50455: PUSH
50456: LD_VAR 0 7
50460: ARRAY
50461: PPUSH
50462: CALL_OW 141
50466: GO 50631
// if not HasTask ( group [ i ] ) and to_heal then
50468: LD_VAR 0 4
50472: PUSH
50473: LD_VAR 0 7
50477: ARRAY
50478: PPUSH
50479: CALL_OW 314
50483: NOT
50484: PUSH
50485: LD_VAR 0 30
50489: AND
50490: IFFALSE 50631
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50492: LD_ADDR_VAR 0 13
50496: PUSH
50497: LD_VAR 0 30
50501: PPUSH
50502: LD_INT 3
50504: PUSH
50505: LD_INT 54
50507: PUSH
50508: EMPTY
50509: LIST
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: PPUSH
50515: CALL_OW 72
50519: PPUSH
50520: LD_VAR 0 4
50524: PUSH
50525: LD_VAR 0 7
50529: ARRAY
50530: PPUSH
50531: CALL_OW 74
50535: ST_TO_ADDR
// if z then
50536: LD_VAR 0 13
50540: IFFALSE 50631
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50542: LD_INT 91
50544: PUSH
50545: LD_VAR 0 13
50549: PUSH
50550: LD_INT 10
50552: PUSH
50553: EMPTY
50554: LIST
50555: LIST
50556: LIST
50557: PUSH
50558: LD_INT 81
50560: PUSH
50561: LD_VAR 0 13
50565: PPUSH
50566: CALL_OW 255
50570: PUSH
50571: EMPTY
50572: LIST
50573: LIST
50574: PUSH
50575: EMPTY
50576: LIST
50577: LIST
50578: PPUSH
50579: CALL_OW 69
50583: PUSH
50584: LD_INT 0
50586: EQUAL
50587: IFFALSE 50611
// ComHeal ( group [ i ] , z ) else
50589: LD_VAR 0 4
50593: PUSH
50594: LD_VAR 0 7
50598: ARRAY
50599: PPUSH
50600: LD_VAR 0 13
50604: PPUSH
50605: CALL_OW 128
50609: GO 50631
// ComMoveToArea ( group [ i ] , f_heal ) ;
50611: LD_VAR 0 4
50615: PUSH
50616: LD_VAR 0 7
50620: ARRAY
50621: PPUSH
50622: LD_VAR 0 23
50626: PPUSH
50627: CALL_OW 113
// end ; continue ;
50631: GO 49662
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50633: LD_VAR 0 4
50637: PUSH
50638: LD_VAR 0 7
50642: ARRAY
50643: PPUSH
50644: CALL_OW 256
50648: PUSH
50649: LD_INT 700
50651: LESS
50652: PUSH
50653: LD_VAR 0 4
50657: PUSH
50658: LD_VAR 0 7
50662: ARRAY
50663: PUSH
50664: LD_VAR 0 30
50668: IN
50669: NOT
50670: AND
50671: IFFALSE 50695
// to_heal := to_heal union group [ i ] ;
50673: LD_ADDR_VAR 0 30
50677: PUSH
50678: LD_VAR 0 30
50682: PUSH
50683: LD_VAR 0 4
50687: PUSH
50688: LD_VAR 0 7
50692: ARRAY
50693: UNION
50694: ST_TO_ADDR
// if group [ i ] in to_heal then
50695: LD_VAR 0 4
50699: PUSH
50700: LD_VAR 0 7
50704: ARRAY
50705: PUSH
50706: LD_VAR 0 30
50710: IN
50711: IFFALSE 50820
// begin if GetLives ( group [ i ] ) = 1000 then
50713: LD_VAR 0 4
50717: PUSH
50718: LD_VAR 0 7
50722: ARRAY
50723: PPUSH
50724: CALL_OW 256
50728: PUSH
50729: LD_INT 1000
50731: EQUAL
50732: IFFALSE 50758
// to_heal := to_heal diff group [ i ] else
50734: LD_ADDR_VAR 0 30
50738: PUSH
50739: LD_VAR 0 30
50743: PUSH
50744: LD_VAR 0 4
50748: PUSH
50749: LD_VAR 0 7
50753: ARRAY
50754: DIFF
50755: ST_TO_ADDR
50756: GO 50820
// begin if not IsInArea ( group [ i ] , to_heal ) then
50758: LD_VAR 0 4
50762: PUSH
50763: LD_VAR 0 7
50767: ARRAY
50768: PPUSH
50769: LD_VAR 0 30
50773: PPUSH
50774: CALL_OW 308
50778: NOT
50779: IFFALSE 50803
// ComMoveToArea ( group [ i ] , f_heal ) else
50781: LD_VAR 0 4
50785: PUSH
50786: LD_VAR 0 7
50790: ARRAY
50791: PPUSH
50792: LD_VAR 0 23
50796: PPUSH
50797: CALL_OW 113
50801: GO 50818
// ComHold ( group [ i ] ) ;
50803: LD_VAR 0 4
50807: PUSH
50808: LD_VAR 0 7
50812: ARRAY
50813: PPUSH
50814: CALL_OW 140
// continue ;
50818: GO 49662
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
50820: LD_VAR 0 4
50824: PUSH
50825: LD_VAR 0 7
50829: ARRAY
50830: PPUSH
50831: LD_INT 10
50833: PPUSH
50834: CALL 47440 0 2
50838: NOT
50839: PUSH
50840: LD_VAR 0 16
50844: PUSH
50845: LD_VAR 0 7
50849: ARRAY
50850: PUSH
50851: EMPTY
50852: EQUAL
50853: NOT
50854: AND
50855: IFFALSE 51121
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
50857: LD_VAR 0 4
50861: PUSH
50862: LD_VAR 0 7
50866: ARRAY
50867: PPUSH
50868: CALL_OW 262
50872: PUSH
50873: LD_INT 1
50875: PUSH
50876: LD_INT 2
50878: PUSH
50879: EMPTY
50880: LIST
50881: LIST
50882: IN
50883: IFFALSE 50924
// if GetFuel ( group [ i ] ) < 10 then
50885: LD_VAR 0 4
50889: PUSH
50890: LD_VAR 0 7
50894: ARRAY
50895: PPUSH
50896: CALL_OW 261
50900: PUSH
50901: LD_INT 10
50903: LESS
50904: IFFALSE 50924
// SetFuel ( group [ i ] , 12 ) ;
50906: LD_VAR 0 4
50910: PUSH
50911: LD_VAR 0 7
50915: ARRAY
50916: PPUSH
50917: LD_INT 12
50919: PPUSH
50920: CALL_OW 240
// if units_path [ i ] then
50924: LD_VAR 0 16
50928: PUSH
50929: LD_VAR 0 7
50933: ARRAY
50934: IFFALSE 51119
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
50936: LD_VAR 0 4
50940: PUSH
50941: LD_VAR 0 7
50945: ARRAY
50946: PPUSH
50947: LD_VAR 0 16
50951: PUSH
50952: LD_VAR 0 7
50956: ARRAY
50957: PUSH
50958: LD_INT 1
50960: ARRAY
50961: PUSH
50962: LD_INT 1
50964: ARRAY
50965: PPUSH
50966: LD_VAR 0 16
50970: PUSH
50971: LD_VAR 0 7
50975: ARRAY
50976: PUSH
50977: LD_INT 1
50979: ARRAY
50980: PUSH
50981: LD_INT 2
50983: ARRAY
50984: PPUSH
50985: CALL_OW 297
50989: PUSH
50990: LD_INT 6
50992: GREATER
50993: IFFALSE 51068
// begin if not HasTask ( group [ i ] ) then
50995: LD_VAR 0 4
50999: PUSH
51000: LD_VAR 0 7
51004: ARRAY
51005: PPUSH
51006: CALL_OW 314
51010: NOT
51011: IFFALSE 51066
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51013: LD_VAR 0 4
51017: PUSH
51018: LD_VAR 0 7
51022: ARRAY
51023: PPUSH
51024: LD_VAR 0 16
51028: PUSH
51029: LD_VAR 0 7
51033: ARRAY
51034: PUSH
51035: LD_INT 1
51037: ARRAY
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PPUSH
51043: LD_VAR 0 16
51047: PUSH
51048: LD_VAR 0 7
51052: ARRAY
51053: PUSH
51054: LD_INT 1
51056: ARRAY
51057: PUSH
51058: LD_INT 2
51060: ARRAY
51061: PPUSH
51062: CALL_OW 114
// end else
51066: GO 51119
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51068: LD_ADDR_VAR 0 15
51072: PUSH
51073: LD_VAR 0 16
51077: PUSH
51078: LD_VAR 0 7
51082: ARRAY
51083: PPUSH
51084: LD_INT 1
51086: PPUSH
51087: CALL_OW 3
51091: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51092: LD_ADDR_VAR 0 16
51096: PUSH
51097: LD_VAR 0 16
51101: PPUSH
51102: LD_VAR 0 7
51106: PPUSH
51107: LD_VAR 0 15
51111: PPUSH
51112: CALL_OW 1
51116: ST_TO_ADDR
// continue ;
51117: GO 49662
// end ; end ; end else
51119: GO 53757
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51121: LD_ADDR_VAR 0 14
51125: PUSH
51126: LD_INT 81
51128: PUSH
51129: LD_VAR 0 4
51133: PUSH
51134: LD_VAR 0 7
51138: ARRAY
51139: PPUSH
51140: CALL_OW 255
51144: PUSH
51145: EMPTY
51146: LIST
51147: LIST
51148: PPUSH
51149: CALL_OW 69
51153: ST_TO_ADDR
// if not tmp then
51154: LD_VAR 0 14
51158: NOT
51159: IFFALSE 51163
// continue ;
51161: GO 49662
// if f_ignore_area then
51163: LD_VAR 0 17
51167: IFFALSE 51255
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51169: LD_ADDR_VAR 0 15
51173: PUSH
51174: LD_VAR 0 14
51178: PPUSH
51179: LD_INT 3
51181: PUSH
51182: LD_INT 92
51184: PUSH
51185: LD_VAR 0 17
51189: PUSH
51190: LD_INT 1
51192: ARRAY
51193: PUSH
51194: LD_VAR 0 17
51198: PUSH
51199: LD_INT 2
51201: ARRAY
51202: PUSH
51203: LD_VAR 0 17
51207: PUSH
51208: LD_INT 3
51210: ARRAY
51211: PUSH
51212: EMPTY
51213: LIST
51214: LIST
51215: LIST
51216: LIST
51217: PUSH
51218: EMPTY
51219: LIST
51220: LIST
51221: PPUSH
51222: CALL_OW 72
51226: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51227: LD_VAR 0 14
51231: PUSH
51232: LD_VAR 0 15
51236: DIFF
51237: IFFALSE 51255
// tmp := tmp diff tmp2 ;
51239: LD_ADDR_VAR 0 14
51243: PUSH
51244: LD_VAR 0 14
51248: PUSH
51249: LD_VAR 0 15
51253: DIFF
51254: ST_TO_ADDR
// end ; if not f_murder then
51255: LD_VAR 0 20
51259: NOT
51260: IFFALSE 51318
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51262: LD_ADDR_VAR 0 15
51266: PUSH
51267: LD_VAR 0 14
51271: PPUSH
51272: LD_INT 3
51274: PUSH
51275: LD_INT 50
51277: PUSH
51278: EMPTY
51279: LIST
51280: PUSH
51281: EMPTY
51282: LIST
51283: LIST
51284: PPUSH
51285: CALL_OW 72
51289: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51290: LD_VAR 0 14
51294: PUSH
51295: LD_VAR 0 15
51299: DIFF
51300: IFFALSE 51318
// tmp := tmp diff tmp2 ;
51302: LD_ADDR_VAR 0 14
51306: PUSH
51307: LD_VAR 0 14
51311: PUSH
51312: LD_VAR 0 15
51316: DIFF
51317: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51318: LD_ADDR_VAR 0 14
51322: PUSH
51323: LD_VAR 0 4
51327: PUSH
51328: LD_VAR 0 7
51332: ARRAY
51333: PPUSH
51334: LD_VAR 0 14
51338: PPUSH
51339: LD_INT 1
51341: PPUSH
51342: LD_INT 1
51344: PPUSH
51345: CALL 21107 0 4
51349: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51350: LD_VAR 0 4
51354: PUSH
51355: LD_VAR 0 7
51359: ARRAY
51360: PPUSH
51361: CALL_OW 257
51365: PUSH
51366: LD_INT 1
51368: EQUAL
51369: IFFALSE 51817
// begin if WantPlant ( group [ i ] ) then
51371: LD_VAR 0 4
51375: PUSH
51376: LD_VAR 0 7
51380: ARRAY
51381: PPUSH
51382: CALL 20608 0 1
51386: IFFALSE 51390
// continue ;
51388: GO 49662
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51390: LD_VAR 0 18
51394: PUSH
51395: LD_VAR 0 4
51399: PUSH
51400: LD_VAR 0 7
51404: ARRAY
51405: PPUSH
51406: CALL_OW 310
51410: NOT
51411: AND
51412: PUSH
51413: LD_VAR 0 14
51417: PUSH
51418: LD_INT 1
51420: ARRAY
51421: PUSH
51422: LD_VAR 0 14
51426: PPUSH
51427: LD_INT 21
51429: PUSH
51430: LD_INT 2
51432: PUSH
51433: EMPTY
51434: LIST
51435: LIST
51436: PUSH
51437: LD_INT 58
51439: PUSH
51440: EMPTY
51441: LIST
51442: PUSH
51443: EMPTY
51444: LIST
51445: LIST
51446: PPUSH
51447: CALL_OW 72
51451: IN
51452: AND
51453: IFFALSE 51489
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51455: LD_VAR 0 4
51459: PUSH
51460: LD_VAR 0 7
51464: ARRAY
51465: PPUSH
51466: LD_VAR 0 14
51470: PUSH
51471: LD_INT 1
51473: ARRAY
51474: PPUSH
51475: CALL_OW 120
// attacking := true ;
51479: LD_ADDR_VAR 0 29
51483: PUSH
51484: LD_INT 1
51486: ST_TO_ADDR
// continue ;
51487: GO 49662
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51489: LD_VAR 0 26
51493: PUSH
51494: LD_VAR 0 4
51498: PUSH
51499: LD_VAR 0 7
51503: ARRAY
51504: PPUSH
51505: CALL_OW 257
51509: PUSH
51510: LD_INT 1
51512: EQUAL
51513: AND
51514: PUSH
51515: LD_VAR 0 4
51519: PUSH
51520: LD_VAR 0 7
51524: ARRAY
51525: PPUSH
51526: CALL_OW 256
51530: PUSH
51531: LD_INT 800
51533: LESS
51534: AND
51535: PUSH
51536: LD_VAR 0 4
51540: PUSH
51541: LD_VAR 0 7
51545: ARRAY
51546: PPUSH
51547: CALL_OW 318
51551: NOT
51552: AND
51553: IFFALSE 51570
// ComCrawl ( group [ i ] ) ;
51555: LD_VAR 0 4
51559: PUSH
51560: LD_VAR 0 7
51564: ARRAY
51565: PPUSH
51566: CALL_OW 137
// if f_mines then
51570: LD_VAR 0 21
51574: IFFALSE 51817
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51576: LD_VAR 0 14
51580: PUSH
51581: LD_INT 1
51583: ARRAY
51584: PPUSH
51585: CALL_OW 247
51589: PUSH
51590: LD_INT 3
51592: EQUAL
51593: PUSH
51594: LD_VAR 0 14
51598: PUSH
51599: LD_INT 1
51601: ARRAY
51602: PUSH
51603: LD_VAR 0 27
51607: IN
51608: NOT
51609: AND
51610: IFFALSE 51817
// begin x := GetX ( tmp [ 1 ] ) ;
51612: LD_ADDR_VAR 0 10
51616: PUSH
51617: LD_VAR 0 14
51621: PUSH
51622: LD_INT 1
51624: ARRAY
51625: PPUSH
51626: CALL_OW 250
51630: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51631: LD_ADDR_VAR 0 11
51635: PUSH
51636: LD_VAR 0 14
51640: PUSH
51641: LD_INT 1
51643: ARRAY
51644: PPUSH
51645: CALL_OW 251
51649: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51650: LD_ADDR_VAR 0 12
51654: PUSH
51655: LD_VAR 0 4
51659: PUSH
51660: LD_VAR 0 7
51664: ARRAY
51665: PPUSH
51666: CALL 47525 0 1
51670: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51671: LD_VAR 0 4
51675: PUSH
51676: LD_VAR 0 7
51680: ARRAY
51681: PPUSH
51682: LD_VAR 0 10
51686: PPUSH
51687: LD_VAR 0 11
51691: PPUSH
51692: LD_VAR 0 14
51696: PUSH
51697: LD_INT 1
51699: ARRAY
51700: PPUSH
51701: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51705: LD_VAR 0 4
51709: PUSH
51710: LD_VAR 0 7
51714: ARRAY
51715: PPUSH
51716: LD_VAR 0 10
51720: PPUSH
51721: LD_VAR 0 12
51725: PPUSH
51726: LD_INT 7
51728: PPUSH
51729: CALL_OW 272
51733: PPUSH
51734: LD_VAR 0 11
51738: PPUSH
51739: LD_VAR 0 12
51743: PPUSH
51744: LD_INT 7
51746: PPUSH
51747: CALL_OW 273
51751: PPUSH
51752: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51756: LD_VAR 0 4
51760: PUSH
51761: LD_VAR 0 7
51765: ARRAY
51766: PPUSH
51767: LD_INT 71
51769: PPUSH
51770: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51774: LD_ADDR_VAR 0 27
51778: PUSH
51779: LD_VAR 0 27
51783: PPUSH
51784: LD_VAR 0 27
51788: PUSH
51789: LD_INT 1
51791: PLUS
51792: PPUSH
51793: LD_VAR 0 14
51797: PUSH
51798: LD_INT 1
51800: ARRAY
51801: PPUSH
51802: CALL_OW 1
51806: ST_TO_ADDR
// attacking := true ;
51807: LD_ADDR_VAR 0 29
51811: PUSH
51812: LD_INT 1
51814: ST_TO_ADDR
// continue ;
51815: GO 49662
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
51817: LD_VAR 0 4
51821: PUSH
51822: LD_VAR 0 7
51826: ARRAY
51827: PPUSH
51828: CALL_OW 257
51832: PUSH
51833: LD_INT 17
51835: EQUAL
51836: PUSH
51837: LD_VAR 0 4
51841: PUSH
51842: LD_VAR 0 7
51846: ARRAY
51847: PPUSH
51848: CALL_OW 110
51852: PUSH
51853: LD_INT 71
51855: EQUAL
51856: NOT
51857: AND
51858: IFFALSE 52004
// begin attacking := false ;
51860: LD_ADDR_VAR 0 29
51864: PUSH
51865: LD_INT 0
51867: ST_TO_ADDR
// k := 5 ;
51868: LD_ADDR_VAR 0 9
51872: PUSH
51873: LD_INT 5
51875: ST_TO_ADDR
// if tmp < k then
51876: LD_VAR 0 14
51880: PUSH
51881: LD_VAR 0 9
51885: LESS
51886: IFFALSE 51898
// k := tmp ;
51888: LD_ADDR_VAR 0 9
51892: PUSH
51893: LD_VAR 0 14
51897: ST_TO_ADDR
// for j = 1 to k do
51898: LD_ADDR_VAR 0 8
51902: PUSH
51903: DOUBLE
51904: LD_INT 1
51906: DEC
51907: ST_TO_ADDR
51908: LD_VAR 0 9
51912: PUSH
51913: FOR_TO
51914: IFFALSE 52002
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
51916: LD_VAR 0 14
51920: PUSH
51921: LD_VAR 0 8
51925: ARRAY
51926: PUSH
51927: LD_VAR 0 14
51931: PPUSH
51932: LD_INT 58
51934: PUSH
51935: EMPTY
51936: LIST
51937: PPUSH
51938: CALL_OW 72
51942: IN
51943: NOT
51944: IFFALSE 52000
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
51946: LD_VAR 0 4
51950: PUSH
51951: LD_VAR 0 7
51955: ARRAY
51956: PPUSH
51957: LD_VAR 0 14
51961: PUSH
51962: LD_VAR 0 8
51966: ARRAY
51967: PPUSH
51968: CALL_OW 115
// attacking := true ;
51972: LD_ADDR_VAR 0 29
51976: PUSH
51977: LD_INT 1
51979: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
51980: LD_VAR 0 4
51984: PUSH
51985: LD_VAR 0 7
51989: ARRAY
51990: PPUSH
51991: LD_INT 71
51993: PPUSH
51994: CALL_OW 109
// continue ;
51998: GO 51913
// end ; end ;
52000: GO 51913
52002: POP
52003: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52004: LD_VAR 0 4
52008: PUSH
52009: LD_VAR 0 7
52013: ARRAY
52014: PPUSH
52015: CALL_OW 257
52019: PUSH
52020: LD_INT 8
52022: EQUAL
52023: PUSH
52024: LD_VAR 0 4
52028: PUSH
52029: LD_VAR 0 7
52033: ARRAY
52034: PPUSH
52035: CALL_OW 264
52039: PUSH
52040: LD_INT 28
52042: PUSH
52043: LD_INT 45
52045: PUSH
52046: LD_INT 7
52048: PUSH
52049: LD_INT 47
52051: PUSH
52052: EMPTY
52053: LIST
52054: LIST
52055: LIST
52056: LIST
52057: IN
52058: OR
52059: IFFALSE 52289
// begin attacking := false ;
52061: LD_ADDR_VAR 0 29
52065: PUSH
52066: LD_INT 0
52068: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52069: LD_VAR 0 14
52073: PUSH
52074: LD_INT 1
52076: ARRAY
52077: PPUSH
52078: CALL_OW 266
52082: PUSH
52083: LD_INT 32
52085: PUSH
52086: LD_INT 31
52088: PUSH
52089: LD_INT 33
52091: PUSH
52092: LD_INT 4
52094: PUSH
52095: LD_INT 5
52097: PUSH
52098: EMPTY
52099: LIST
52100: LIST
52101: LIST
52102: LIST
52103: LIST
52104: IN
52105: IFFALSE 52289
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52107: LD_ADDR_VAR 0 9
52111: PUSH
52112: LD_VAR 0 14
52116: PUSH
52117: LD_INT 1
52119: ARRAY
52120: PPUSH
52121: CALL_OW 266
52125: PPUSH
52126: LD_VAR 0 14
52130: PUSH
52131: LD_INT 1
52133: ARRAY
52134: PPUSH
52135: CALL_OW 250
52139: PPUSH
52140: LD_VAR 0 14
52144: PUSH
52145: LD_INT 1
52147: ARRAY
52148: PPUSH
52149: CALL_OW 251
52153: PPUSH
52154: LD_VAR 0 14
52158: PUSH
52159: LD_INT 1
52161: ARRAY
52162: PPUSH
52163: CALL_OW 254
52167: PPUSH
52168: LD_VAR 0 14
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 248
52181: PPUSH
52182: LD_INT 0
52184: PPUSH
52185: CALL 28901 0 6
52189: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52190: LD_ADDR_VAR 0 8
52194: PUSH
52195: LD_VAR 0 4
52199: PUSH
52200: LD_VAR 0 7
52204: ARRAY
52205: PPUSH
52206: LD_VAR 0 9
52210: PPUSH
52211: CALL 47588 0 2
52215: ST_TO_ADDR
// if j then
52216: LD_VAR 0 8
52220: IFFALSE 52289
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52222: LD_VAR 0 8
52226: PUSH
52227: LD_INT 1
52229: ARRAY
52230: PPUSH
52231: LD_VAR 0 8
52235: PUSH
52236: LD_INT 2
52238: ARRAY
52239: PPUSH
52240: CALL_OW 488
52244: IFFALSE 52289
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52246: LD_VAR 0 4
52250: PUSH
52251: LD_VAR 0 7
52255: ARRAY
52256: PPUSH
52257: LD_VAR 0 8
52261: PUSH
52262: LD_INT 1
52264: ARRAY
52265: PPUSH
52266: LD_VAR 0 8
52270: PUSH
52271: LD_INT 2
52273: ARRAY
52274: PPUSH
52275: CALL_OW 116
// attacking := true ;
52279: LD_ADDR_VAR 0 29
52283: PUSH
52284: LD_INT 1
52286: ST_TO_ADDR
// continue ;
52287: GO 49662
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52289: LD_VAR 0 4
52293: PUSH
52294: LD_VAR 0 7
52298: ARRAY
52299: PPUSH
52300: CALL_OW 265
52304: PUSH
52305: LD_INT 11
52307: EQUAL
52308: IFFALSE 52586
// begin k := 10 ;
52310: LD_ADDR_VAR 0 9
52314: PUSH
52315: LD_INT 10
52317: ST_TO_ADDR
// x := 0 ;
52318: LD_ADDR_VAR 0 10
52322: PUSH
52323: LD_INT 0
52325: ST_TO_ADDR
// if tmp < k then
52326: LD_VAR 0 14
52330: PUSH
52331: LD_VAR 0 9
52335: LESS
52336: IFFALSE 52348
// k := tmp ;
52338: LD_ADDR_VAR 0 9
52342: PUSH
52343: LD_VAR 0 14
52347: ST_TO_ADDR
// for j = k downto 1 do
52348: LD_ADDR_VAR 0 8
52352: PUSH
52353: DOUBLE
52354: LD_VAR 0 9
52358: INC
52359: ST_TO_ADDR
52360: LD_INT 1
52362: PUSH
52363: FOR_DOWNTO
52364: IFFALSE 52439
// begin if GetType ( tmp [ j ] ) = unit_human then
52366: LD_VAR 0 14
52370: PUSH
52371: LD_VAR 0 8
52375: ARRAY
52376: PPUSH
52377: CALL_OW 247
52381: PUSH
52382: LD_INT 1
52384: EQUAL
52385: IFFALSE 52437
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52387: LD_VAR 0 4
52391: PUSH
52392: LD_VAR 0 7
52396: ARRAY
52397: PPUSH
52398: LD_VAR 0 14
52402: PUSH
52403: LD_VAR 0 8
52407: ARRAY
52408: PPUSH
52409: CALL 47859 0 2
// x := tmp [ j ] ;
52413: LD_ADDR_VAR 0 10
52417: PUSH
52418: LD_VAR 0 14
52422: PUSH
52423: LD_VAR 0 8
52427: ARRAY
52428: ST_TO_ADDR
// attacking := true ;
52429: LD_ADDR_VAR 0 29
52433: PUSH
52434: LD_INT 1
52436: ST_TO_ADDR
// end ; end ;
52437: GO 52363
52439: POP
52440: POP
// if not x then
52441: LD_VAR 0 10
52445: NOT
52446: IFFALSE 52586
// begin attacking := true ;
52448: LD_ADDR_VAR 0 29
52452: PUSH
52453: LD_INT 1
52455: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52456: LD_VAR 0 4
52460: PUSH
52461: LD_VAR 0 7
52465: ARRAY
52466: PPUSH
52467: CALL_OW 250
52471: PPUSH
52472: LD_VAR 0 4
52476: PUSH
52477: LD_VAR 0 7
52481: ARRAY
52482: PPUSH
52483: CALL_OW 251
52487: PPUSH
52488: CALL_OW 546
52492: PUSH
52493: LD_INT 2
52495: ARRAY
52496: PUSH
52497: LD_VAR 0 14
52501: PUSH
52502: LD_INT 1
52504: ARRAY
52505: PPUSH
52506: CALL_OW 250
52510: PPUSH
52511: LD_VAR 0 14
52515: PUSH
52516: LD_INT 1
52518: ARRAY
52519: PPUSH
52520: CALL_OW 251
52524: PPUSH
52525: CALL_OW 546
52529: PUSH
52530: LD_INT 2
52532: ARRAY
52533: EQUAL
52534: IFFALSE 52562
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52536: LD_VAR 0 4
52540: PUSH
52541: LD_VAR 0 7
52545: ARRAY
52546: PPUSH
52547: LD_VAR 0 14
52551: PUSH
52552: LD_INT 1
52554: ARRAY
52555: PPUSH
52556: CALL 47859 0 2
52560: GO 52586
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52562: LD_VAR 0 4
52566: PUSH
52567: LD_VAR 0 7
52571: ARRAY
52572: PPUSH
52573: LD_VAR 0 14
52577: PUSH
52578: LD_INT 1
52580: ARRAY
52581: PPUSH
52582: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52586: LD_VAR 0 4
52590: PUSH
52591: LD_VAR 0 7
52595: ARRAY
52596: PPUSH
52597: CALL_OW 264
52601: PUSH
52602: LD_INT 29
52604: EQUAL
52605: IFFALSE 52971
// begin if WantsToAttack ( group [ i ] ) in bombed then
52607: LD_VAR 0 4
52611: PUSH
52612: LD_VAR 0 7
52616: ARRAY
52617: PPUSH
52618: CALL_OW 319
52622: PUSH
52623: LD_VAR 0 28
52627: IN
52628: IFFALSE 52632
// continue ;
52630: GO 49662
// k := 8 ;
52632: LD_ADDR_VAR 0 9
52636: PUSH
52637: LD_INT 8
52639: ST_TO_ADDR
// x := 0 ;
52640: LD_ADDR_VAR 0 10
52644: PUSH
52645: LD_INT 0
52647: ST_TO_ADDR
// if tmp < k then
52648: LD_VAR 0 14
52652: PUSH
52653: LD_VAR 0 9
52657: LESS
52658: IFFALSE 52670
// k := tmp ;
52660: LD_ADDR_VAR 0 9
52664: PUSH
52665: LD_VAR 0 14
52669: ST_TO_ADDR
// for j = 1 to k do
52670: LD_ADDR_VAR 0 8
52674: PUSH
52675: DOUBLE
52676: LD_INT 1
52678: DEC
52679: ST_TO_ADDR
52680: LD_VAR 0 9
52684: PUSH
52685: FOR_TO
52686: IFFALSE 52818
// begin if GetType ( tmp [ j ] ) = unit_building then
52688: LD_VAR 0 14
52692: PUSH
52693: LD_VAR 0 8
52697: ARRAY
52698: PPUSH
52699: CALL_OW 247
52703: PUSH
52704: LD_INT 3
52706: EQUAL
52707: IFFALSE 52816
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52709: LD_VAR 0 14
52713: PUSH
52714: LD_VAR 0 8
52718: ARRAY
52719: PUSH
52720: LD_VAR 0 28
52724: IN
52725: NOT
52726: PUSH
52727: LD_VAR 0 14
52731: PUSH
52732: LD_VAR 0 8
52736: ARRAY
52737: PPUSH
52738: CALL_OW 313
52742: AND
52743: IFFALSE 52816
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52745: LD_VAR 0 4
52749: PUSH
52750: LD_VAR 0 7
52754: ARRAY
52755: PPUSH
52756: LD_VAR 0 14
52760: PUSH
52761: LD_VAR 0 8
52765: ARRAY
52766: PPUSH
52767: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52771: LD_ADDR_VAR 0 28
52775: PUSH
52776: LD_VAR 0 28
52780: PPUSH
52781: LD_VAR 0 28
52785: PUSH
52786: LD_INT 1
52788: PLUS
52789: PPUSH
52790: LD_VAR 0 14
52794: PUSH
52795: LD_VAR 0 8
52799: ARRAY
52800: PPUSH
52801: CALL_OW 1
52805: ST_TO_ADDR
// attacking := true ;
52806: LD_ADDR_VAR 0 29
52810: PUSH
52811: LD_INT 1
52813: ST_TO_ADDR
// break ;
52814: GO 52818
// end ; end ;
52816: GO 52685
52818: POP
52819: POP
// if not attacking and f_attack_depot then
52820: LD_VAR 0 29
52824: NOT
52825: PUSH
52826: LD_VAR 0 25
52830: AND
52831: IFFALSE 52926
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52833: LD_ADDR_VAR 0 13
52837: PUSH
52838: LD_VAR 0 14
52842: PPUSH
52843: LD_INT 2
52845: PUSH
52846: LD_INT 30
52848: PUSH
52849: LD_INT 0
52851: PUSH
52852: EMPTY
52853: LIST
52854: LIST
52855: PUSH
52856: LD_INT 30
52858: PUSH
52859: LD_INT 1
52861: PUSH
52862: EMPTY
52863: LIST
52864: LIST
52865: PUSH
52866: EMPTY
52867: LIST
52868: LIST
52869: LIST
52870: PPUSH
52871: CALL_OW 72
52875: ST_TO_ADDR
// if z then
52876: LD_VAR 0 13
52880: IFFALSE 52926
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
52882: LD_VAR 0 4
52886: PUSH
52887: LD_VAR 0 7
52891: ARRAY
52892: PPUSH
52893: LD_VAR 0 13
52897: PPUSH
52898: LD_VAR 0 4
52902: PUSH
52903: LD_VAR 0 7
52907: ARRAY
52908: PPUSH
52909: CALL_OW 74
52913: PPUSH
52914: CALL_OW 115
// attacking := true ;
52918: LD_ADDR_VAR 0 29
52922: PUSH
52923: LD_INT 1
52925: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
52926: LD_VAR 0 4
52930: PUSH
52931: LD_VAR 0 7
52935: ARRAY
52936: PPUSH
52937: CALL_OW 256
52941: PUSH
52942: LD_INT 500
52944: LESS
52945: IFFALSE 52971
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52947: LD_VAR 0 4
52951: PUSH
52952: LD_VAR 0 7
52956: ARRAY
52957: PPUSH
52958: LD_VAR 0 14
52962: PUSH
52963: LD_INT 1
52965: ARRAY
52966: PPUSH
52967: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
52971: LD_VAR 0 4
52975: PUSH
52976: LD_VAR 0 7
52980: ARRAY
52981: PPUSH
52982: CALL_OW 264
52986: PUSH
52987: LD_INT 49
52989: EQUAL
52990: IFFALSE 53111
// begin if not HasTask ( group [ i ] ) then
52992: LD_VAR 0 4
52996: PUSH
52997: LD_VAR 0 7
53001: ARRAY
53002: PPUSH
53003: CALL_OW 314
53007: NOT
53008: IFFALSE 53111
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53010: LD_ADDR_VAR 0 9
53014: PUSH
53015: LD_INT 81
53017: PUSH
53018: LD_VAR 0 4
53022: PUSH
53023: LD_VAR 0 7
53027: ARRAY
53028: PPUSH
53029: CALL_OW 255
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: PPUSH
53038: CALL_OW 69
53042: PPUSH
53043: LD_VAR 0 4
53047: PUSH
53048: LD_VAR 0 7
53052: ARRAY
53053: PPUSH
53054: CALL_OW 74
53058: ST_TO_ADDR
// if k then
53059: LD_VAR 0 9
53063: IFFALSE 53111
// if GetDistUnits ( group [ i ] , k ) > 10 then
53065: LD_VAR 0 4
53069: PUSH
53070: LD_VAR 0 7
53074: ARRAY
53075: PPUSH
53076: LD_VAR 0 9
53080: PPUSH
53081: CALL_OW 296
53085: PUSH
53086: LD_INT 10
53088: GREATER
53089: IFFALSE 53111
// ComMoveUnit ( group [ i ] , k ) ;
53091: LD_VAR 0 4
53095: PUSH
53096: LD_VAR 0 7
53100: ARRAY
53101: PPUSH
53102: LD_VAR 0 9
53106: PPUSH
53107: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53111: LD_VAR 0 4
53115: PUSH
53116: LD_VAR 0 7
53120: ARRAY
53121: PPUSH
53122: CALL_OW 256
53126: PUSH
53127: LD_INT 250
53129: LESS
53130: PUSH
53131: LD_VAR 0 4
53135: PUSH
53136: LD_VAR 0 7
53140: ARRAY
53141: PUSH
53142: LD_INT 21
53144: PUSH
53145: LD_INT 2
53147: PUSH
53148: EMPTY
53149: LIST
53150: LIST
53151: PUSH
53152: LD_INT 23
53154: PUSH
53155: LD_INT 2
53157: PUSH
53158: EMPTY
53159: LIST
53160: LIST
53161: PUSH
53162: EMPTY
53163: LIST
53164: LIST
53165: PPUSH
53166: CALL_OW 69
53170: IN
53171: AND
53172: IFFALSE 53297
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53174: LD_ADDR_VAR 0 9
53178: PUSH
53179: LD_OWVAR 3
53183: PUSH
53184: LD_VAR 0 4
53188: PUSH
53189: LD_VAR 0 7
53193: ARRAY
53194: DIFF
53195: PPUSH
53196: LD_VAR 0 4
53200: PUSH
53201: LD_VAR 0 7
53205: ARRAY
53206: PPUSH
53207: CALL_OW 74
53211: ST_TO_ADDR
// if not k then
53212: LD_VAR 0 9
53216: NOT
53217: IFFALSE 53221
// continue ;
53219: GO 49662
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53221: LD_VAR 0 9
53225: PUSH
53226: LD_INT 81
53228: PUSH
53229: LD_VAR 0 4
53233: PUSH
53234: LD_VAR 0 7
53238: ARRAY
53239: PPUSH
53240: CALL_OW 255
53244: PUSH
53245: EMPTY
53246: LIST
53247: LIST
53248: PPUSH
53249: CALL_OW 69
53253: IN
53254: PUSH
53255: LD_VAR 0 9
53259: PPUSH
53260: LD_VAR 0 4
53264: PUSH
53265: LD_VAR 0 7
53269: ARRAY
53270: PPUSH
53271: CALL_OW 296
53275: PUSH
53276: LD_INT 5
53278: LESS
53279: AND
53280: IFFALSE 53297
// ComAutodestruct ( group [ i ] ) ;
53282: LD_VAR 0 4
53286: PUSH
53287: LD_VAR 0 7
53291: ARRAY
53292: PPUSH
53293: CALL 47757 0 1
// end ; if f_attack_depot then
53297: LD_VAR 0 25
53301: IFFALSE 53413
// begin k := 6 ;
53303: LD_ADDR_VAR 0 9
53307: PUSH
53308: LD_INT 6
53310: ST_TO_ADDR
// if tmp < k then
53311: LD_VAR 0 14
53315: PUSH
53316: LD_VAR 0 9
53320: LESS
53321: IFFALSE 53333
// k := tmp ;
53323: LD_ADDR_VAR 0 9
53327: PUSH
53328: LD_VAR 0 14
53332: ST_TO_ADDR
// for j = 1 to k do
53333: LD_ADDR_VAR 0 8
53337: PUSH
53338: DOUBLE
53339: LD_INT 1
53341: DEC
53342: ST_TO_ADDR
53343: LD_VAR 0 9
53347: PUSH
53348: FOR_TO
53349: IFFALSE 53411
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53351: LD_VAR 0 8
53355: PPUSH
53356: CALL_OW 266
53360: PUSH
53361: LD_INT 0
53363: PUSH
53364: LD_INT 1
53366: PUSH
53367: EMPTY
53368: LIST
53369: LIST
53370: IN
53371: IFFALSE 53409
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53373: LD_VAR 0 4
53377: PUSH
53378: LD_VAR 0 7
53382: ARRAY
53383: PPUSH
53384: LD_VAR 0 14
53388: PUSH
53389: LD_VAR 0 8
53393: ARRAY
53394: PPUSH
53395: CALL_OW 115
// attacking := true ;
53399: LD_ADDR_VAR 0 29
53403: PUSH
53404: LD_INT 1
53406: ST_TO_ADDR
// break ;
53407: GO 53411
// end ;
53409: GO 53348
53411: POP
53412: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53413: LD_VAR 0 4
53417: PUSH
53418: LD_VAR 0 7
53422: ARRAY
53423: PPUSH
53424: CALL_OW 302
53428: PUSH
53429: LD_VAR 0 29
53433: NOT
53434: AND
53435: IFFALSE 53757
// begin if GetTag ( group [ i ] ) = 71 then
53437: LD_VAR 0 4
53441: PUSH
53442: LD_VAR 0 7
53446: ARRAY
53447: PPUSH
53448: CALL_OW 110
53452: PUSH
53453: LD_INT 71
53455: EQUAL
53456: IFFALSE 53497
// begin if HasTask ( group [ i ] ) then
53458: LD_VAR 0 4
53462: PUSH
53463: LD_VAR 0 7
53467: ARRAY
53468: PPUSH
53469: CALL_OW 314
53473: IFFALSE 53479
// continue else
53475: GO 49662
53477: GO 53497
// SetTag ( group [ i ] , 0 ) ;
53479: LD_VAR 0 4
53483: PUSH
53484: LD_VAR 0 7
53488: ARRAY
53489: PPUSH
53490: LD_INT 0
53492: PPUSH
53493: CALL_OW 109
// end ; k := 8 ;
53497: LD_ADDR_VAR 0 9
53501: PUSH
53502: LD_INT 8
53504: ST_TO_ADDR
// x := 0 ;
53505: LD_ADDR_VAR 0 10
53509: PUSH
53510: LD_INT 0
53512: ST_TO_ADDR
// if tmp < k then
53513: LD_VAR 0 14
53517: PUSH
53518: LD_VAR 0 9
53522: LESS
53523: IFFALSE 53535
// k := tmp ;
53525: LD_ADDR_VAR 0 9
53529: PUSH
53530: LD_VAR 0 14
53534: ST_TO_ADDR
// for j = 1 to k do
53535: LD_ADDR_VAR 0 8
53539: PUSH
53540: DOUBLE
53541: LD_INT 1
53543: DEC
53544: ST_TO_ADDR
53545: LD_VAR 0 9
53549: PUSH
53550: FOR_TO
53551: IFFALSE 53649
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53553: LD_VAR 0 14
53557: PUSH
53558: LD_VAR 0 8
53562: ARRAY
53563: PPUSH
53564: CALL_OW 247
53568: PUSH
53569: LD_INT 1
53571: EQUAL
53572: PUSH
53573: LD_VAR 0 14
53577: PUSH
53578: LD_VAR 0 8
53582: ARRAY
53583: PPUSH
53584: CALL_OW 256
53588: PUSH
53589: LD_INT 250
53591: LESS
53592: PUSH
53593: LD_VAR 0 20
53597: AND
53598: PUSH
53599: LD_VAR 0 20
53603: NOT
53604: PUSH
53605: LD_VAR 0 14
53609: PUSH
53610: LD_VAR 0 8
53614: ARRAY
53615: PPUSH
53616: CALL_OW 256
53620: PUSH
53621: LD_INT 250
53623: GREATEREQUAL
53624: AND
53625: OR
53626: AND
53627: IFFALSE 53647
// begin x := tmp [ j ] ;
53629: LD_ADDR_VAR 0 10
53633: PUSH
53634: LD_VAR 0 14
53638: PUSH
53639: LD_VAR 0 8
53643: ARRAY
53644: ST_TO_ADDR
// break ;
53645: GO 53649
// end ;
53647: GO 53550
53649: POP
53650: POP
// if x then
53651: LD_VAR 0 10
53655: IFFALSE 53679
// ComAttackUnit ( group [ i ] , x ) else
53657: LD_VAR 0 4
53661: PUSH
53662: LD_VAR 0 7
53666: ARRAY
53667: PPUSH
53668: LD_VAR 0 10
53672: PPUSH
53673: CALL_OW 115
53677: GO 53703
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53679: LD_VAR 0 4
53683: PUSH
53684: LD_VAR 0 7
53688: ARRAY
53689: PPUSH
53690: LD_VAR 0 14
53694: PUSH
53695: LD_INT 1
53697: ARRAY
53698: PPUSH
53699: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53703: LD_VAR 0 4
53707: PUSH
53708: LD_VAR 0 7
53712: ARRAY
53713: PPUSH
53714: CALL_OW 314
53718: NOT
53719: IFFALSE 53757
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53721: LD_VAR 0 4
53725: PUSH
53726: LD_VAR 0 7
53730: ARRAY
53731: PPUSH
53732: LD_VAR 0 14
53736: PPUSH
53737: LD_VAR 0 4
53741: PUSH
53742: LD_VAR 0 7
53746: ARRAY
53747: PPUSH
53748: CALL_OW 74
53752: PPUSH
53753: CALL_OW 115
// end ; end ; end ;
53757: GO 49662
53759: POP
53760: POP
// wait ( 0 0$1 ) ;
53761: LD_INT 35
53763: PPUSH
53764: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53768: LD_VAR 0 4
53772: PUSH
53773: EMPTY
53774: EQUAL
53775: PUSH
53776: LD_INT 81
53778: PUSH
53779: LD_VAR 0 35
53783: PUSH
53784: EMPTY
53785: LIST
53786: LIST
53787: PPUSH
53788: CALL_OW 69
53792: NOT
53793: OR
53794: IFFALSE 49647
// end ;
53796: LD_VAR 0 2
53800: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53801: LD_INT 0
53803: PPUSH
53804: PPUSH
53805: PPUSH
53806: PPUSH
// if not base_units then
53807: LD_VAR 0 1
53811: NOT
53812: IFFALSE 53816
// exit ;
53814: GO 53903
// result := false ;
53816: LD_ADDR_VAR 0 2
53820: PUSH
53821: LD_INT 0
53823: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
53824: LD_ADDR_VAR 0 5
53828: PUSH
53829: LD_VAR 0 1
53833: PPUSH
53834: LD_INT 21
53836: PUSH
53837: LD_INT 3
53839: PUSH
53840: EMPTY
53841: LIST
53842: LIST
53843: PPUSH
53844: CALL_OW 72
53848: ST_TO_ADDR
// if not tmp then
53849: LD_VAR 0 5
53853: NOT
53854: IFFALSE 53858
// exit ;
53856: GO 53903
// for i in tmp do
53858: LD_ADDR_VAR 0 3
53862: PUSH
53863: LD_VAR 0 5
53867: PUSH
53868: FOR_IN
53869: IFFALSE 53901
// begin result := EnemyInRange ( i , 22 ) ;
53871: LD_ADDR_VAR 0 2
53875: PUSH
53876: LD_VAR 0 3
53880: PPUSH
53881: LD_INT 22
53883: PPUSH
53884: CALL 47440 0 2
53888: ST_TO_ADDR
// if result then
53889: LD_VAR 0 2
53893: IFFALSE 53899
// exit ;
53895: POP
53896: POP
53897: GO 53903
// end ;
53899: GO 53868
53901: POP
53902: POP
// end ;
53903: LD_VAR 0 2
53907: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
53908: LD_INT 0
53910: PPUSH
53911: PPUSH
// if not units then
53912: LD_VAR 0 1
53916: NOT
53917: IFFALSE 53921
// exit ;
53919: GO 53991
// result := [ ] ;
53921: LD_ADDR_VAR 0 3
53925: PUSH
53926: EMPTY
53927: ST_TO_ADDR
// for i in units do
53928: LD_ADDR_VAR 0 4
53932: PUSH
53933: LD_VAR 0 1
53937: PUSH
53938: FOR_IN
53939: IFFALSE 53989
// if GetTag ( i ) = tag then
53941: LD_VAR 0 4
53945: PPUSH
53946: CALL_OW 110
53950: PUSH
53951: LD_VAR 0 2
53955: EQUAL
53956: IFFALSE 53987
// result := Insert ( result , result + 1 , i ) ;
53958: LD_ADDR_VAR 0 3
53962: PUSH
53963: LD_VAR 0 3
53967: PPUSH
53968: LD_VAR 0 3
53972: PUSH
53973: LD_INT 1
53975: PLUS
53976: PPUSH
53977: LD_VAR 0 4
53981: PPUSH
53982: CALL_OW 2
53986: ST_TO_ADDR
53987: GO 53938
53989: POP
53990: POP
// end ;
53991: LD_VAR 0 3
53995: RET
// export function IsDriver ( un ) ; begin
53996: LD_INT 0
53998: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
53999: LD_ADDR_VAR 0 2
54003: PUSH
54004: LD_VAR 0 1
54008: PUSH
54009: LD_INT 55
54011: PUSH
54012: EMPTY
54013: LIST
54014: PPUSH
54015: CALL_OW 69
54019: IN
54020: ST_TO_ADDR
// end ;
54021: LD_VAR 0 2
54025: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54026: LD_INT 0
54028: PPUSH
54029: PPUSH
// list := [ ] ;
54030: LD_ADDR_VAR 0 5
54034: PUSH
54035: EMPTY
54036: ST_TO_ADDR
// case d of 0 :
54037: LD_VAR 0 3
54041: PUSH
54042: LD_INT 0
54044: DOUBLE
54045: EQUAL
54046: IFTRUE 54050
54048: GO 54183
54050: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54051: LD_ADDR_VAR 0 5
54055: PUSH
54056: LD_VAR 0 1
54060: PUSH
54061: LD_INT 4
54063: MINUS
54064: PUSH
54065: LD_VAR 0 2
54069: PUSH
54070: LD_INT 4
54072: MINUS
54073: PUSH
54074: LD_INT 2
54076: PUSH
54077: EMPTY
54078: LIST
54079: LIST
54080: LIST
54081: PUSH
54082: LD_VAR 0 1
54086: PUSH
54087: LD_INT 3
54089: MINUS
54090: PUSH
54091: LD_VAR 0 2
54095: PUSH
54096: LD_INT 1
54098: PUSH
54099: EMPTY
54100: LIST
54101: LIST
54102: LIST
54103: PUSH
54104: LD_VAR 0 1
54108: PUSH
54109: LD_INT 4
54111: PLUS
54112: PUSH
54113: LD_VAR 0 2
54117: PUSH
54118: LD_INT 4
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PUSH
54126: LD_VAR 0 1
54130: PUSH
54131: LD_INT 3
54133: PLUS
54134: PUSH
54135: LD_VAR 0 2
54139: PUSH
54140: LD_INT 3
54142: PLUS
54143: PUSH
54144: LD_INT 5
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: PUSH
54152: LD_VAR 0 1
54156: PUSH
54157: LD_VAR 0 2
54161: PUSH
54162: LD_INT 4
54164: PLUS
54165: PUSH
54166: LD_INT 0
54168: PUSH
54169: EMPTY
54170: LIST
54171: LIST
54172: LIST
54173: PUSH
54174: EMPTY
54175: LIST
54176: LIST
54177: LIST
54178: LIST
54179: LIST
54180: ST_TO_ADDR
// end ; 1 :
54181: GO 54881
54183: LD_INT 1
54185: DOUBLE
54186: EQUAL
54187: IFTRUE 54191
54189: GO 54324
54191: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54192: LD_ADDR_VAR 0 5
54196: PUSH
54197: LD_VAR 0 1
54201: PUSH
54202: LD_VAR 0 2
54206: PUSH
54207: LD_INT 4
54209: MINUS
54210: PUSH
54211: LD_INT 3
54213: PUSH
54214: EMPTY
54215: LIST
54216: LIST
54217: LIST
54218: PUSH
54219: LD_VAR 0 1
54223: PUSH
54224: LD_INT 3
54226: MINUS
54227: PUSH
54228: LD_VAR 0 2
54232: PUSH
54233: LD_INT 3
54235: MINUS
54236: PUSH
54237: LD_INT 2
54239: PUSH
54240: EMPTY
54241: LIST
54242: LIST
54243: LIST
54244: PUSH
54245: LD_VAR 0 1
54249: PUSH
54250: LD_INT 4
54252: MINUS
54253: PUSH
54254: LD_VAR 0 2
54258: PUSH
54259: LD_INT 1
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: LIST
54266: PUSH
54267: LD_VAR 0 1
54271: PUSH
54272: LD_VAR 0 2
54276: PUSH
54277: LD_INT 3
54279: PLUS
54280: PUSH
54281: LD_INT 0
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: LIST
54288: PUSH
54289: LD_VAR 0 1
54293: PUSH
54294: LD_INT 4
54296: PLUS
54297: PUSH
54298: LD_VAR 0 2
54302: PUSH
54303: LD_INT 4
54305: PLUS
54306: PUSH
54307: LD_INT 5
54309: PUSH
54310: EMPTY
54311: LIST
54312: LIST
54313: LIST
54314: PUSH
54315: EMPTY
54316: LIST
54317: LIST
54318: LIST
54319: LIST
54320: LIST
54321: ST_TO_ADDR
// end ; 2 :
54322: GO 54881
54324: LD_INT 2
54326: DOUBLE
54327: EQUAL
54328: IFTRUE 54332
54330: GO 54461
54332: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: LD_VAR 0 1
54342: PUSH
54343: LD_VAR 0 2
54347: PUSH
54348: LD_INT 3
54350: MINUS
54351: PUSH
54352: LD_INT 3
54354: PUSH
54355: EMPTY
54356: LIST
54357: LIST
54358: LIST
54359: PUSH
54360: LD_VAR 0 1
54364: PUSH
54365: LD_INT 4
54367: PLUS
54368: PUSH
54369: LD_VAR 0 2
54373: PUSH
54374: LD_INT 4
54376: PUSH
54377: EMPTY
54378: LIST
54379: LIST
54380: LIST
54381: PUSH
54382: LD_VAR 0 1
54386: PUSH
54387: LD_VAR 0 2
54391: PUSH
54392: LD_INT 4
54394: PLUS
54395: PUSH
54396: LD_INT 0
54398: PUSH
54399: EMPTY
54400: LIST
54401: LIST
54402: LIST
54403: PUSH
54404: LD_VAR 0 1
54408: PUSH
54409: LD_INT 3
54411: MINUS
54412: PUSH
54413: LD_VAR 0 2
54417: PUSH
54418: LD_INT 1
54420: PUSH
54421: EMPTY
54422: LIST
54423: LIST
54424: LIST
54425: PUSH
54426: LD_VAR 0 1
54430: PUSH
54431: LD_INT 4
54433: MINUS
54434: PUSH
54435: LD_VAR 0 2
54439: PUSH
54440: LD_INT 4
54442: MINUS
54443: PUSH
54444: LD_INT 2
54446: PUSH
54447: EMPTY
54448: LIST
54449: LIST
54450: LIST
54451: PUSH
54452: EMPTY
54453: LIST
54454: LIST
54455: LIST
54456: LIST
54457: LIST
54458: ST_TO_ADDR
// end ; 3 :
54459: GO 54881
54461: LD_INT 3
54463: DOUBLE
54464: EQUAL
54465: IFTRUE 54469
54467: GO 54602
54469: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54470: LD_ADDR_VAR 0 5
54474: PUSH
54475: LD_VAR 0 1
54479: PUSH
54480: LD_INT 3
54482: PLUS
54483: PUSH
54484: LD_VAR 0 2
54488: PUSH
54489: LD_INT 4
54491: PUSH
54492: EMPTY
54493: LIST
54494: LIST
54495: LIST
54496: PUSH
54497: LD_VAR 0 1
54501: PUSH
54502: LD_INT 4
54504: PLUS
54505: PUSH
54506: LD_VAR 0 2
54510: PUSH
54511: LD_INT 4
54513: PLUS
54514: PUSH
54515: LD_INT 5
54517: PUSH
54518: EMPTY
54519: LIST
54520: LIST
54521: LIST
54522: PUSH
54523: LD_VAR 0 1
54527: PUSH
54528: LD_INT 4
54530: MINUS
54531: PUSH
54532: LD_VAR 0 2
54536: PUSH
54537: LD_INT 1
54539: PUSH
54540: EMPTY
54541: LIST
54542: LIST
54543: LIST
54544: PUSH
54545: LD_VAR 0 1
54549: PUSH
54550: LD_VAR 0 2
54554: PUSH
54555: LD_INT 4
54557: MINUS
54558: PUSH
54559: LD_INT 3
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: LIST
54566: PUSH
54567: LD_VAR 0 1
54571: PUSH
54572: LD_INT 3
54574: MINUS
54575: PUSH
54576: LD_VAR 0 2
54580: PUSH
54581: LD_INT 3
54583: MINUS
54584: PUSH
54585: LD_INT 2
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: LIST
54592: PUSH
54593: EMPTY
54594: LIST
54595: LIST
54596: LIST
54597: LIST
54598: LIST
54599: ST_TO_ADDR
// end ; 4 :
54600: GO 54881
54602: LD_INT 4
54604: DOUBLE
54605: EQUAL
54606: IFTRUE 54610
54608: GO 54743
54610: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54611: LD_ADDR_VAR 0 5
54615: PUSH
54616: LD_VAR 0 1
54620: PUSH
54621: LD_VAR 0 2
54625: PUSH
54626: LD_INT 4
54628: PLUS
54629: PUSH
54630: LD_INT 0
54632: PUSH
54633: EMPTY
54634: LIST
54635: LIST
54636: LIST
54637: PUSH
54638: LD_VAR 0 1
54642: PUSH
54643: LD_INT 3
54645: PLUS
54646: PUSH
54647: LD_VAR 0 2
54651: PUSH
54652: LD_INT 3
54654: PLUS
54655: PUSH
54656: LD_INT 5
54658: PUSH
54659: EMPTY
54660: LIST
54661: LIST
54662: LIST
54663: PUSH
54664: LD_VAR 0 1
54668: PUSH
54669: LD_INT 4
54671: PLUS
54672: PUSH
54673: LD_VAR 0 2
54677: PUSH
54678: LD_INT 4
54680: PUSH
54681: EMPTY
54682: LIST
54683: LIST
54684: LIST
54685: PUSH
54686: LD_VAR 0 1
54690: PUSH
54691: LD_VAR 0 2
54695: PUSH
54696: LD_INT 3
54698: MINUS
54699: PUSH
54700: LD_INT 3
54702: PUSH
54703: EMPTY
54704: LIST
54705: LIST
54706: LIST
54707: PUSH
54708: LD_VAR 0 1
54712: PUSH
54713: LD_INT 4
54715: MINUS
54716: PUSH
54717: LD_VAR 0 2
54721: PUSH
54722: LD_INT 4
54724: MINUS
54725: PUSH
54726: LD_INT 2
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: LIST
54733: PUSH
54734: EMPTY
54735: LIST
54736: LIST
54737: LIST
54738: LIST
54739: LIST
54740: ST_TO_ADDR
// end ; 5 :
54741: GO 54881
54743: LD_INT 5
54745: DOUBLE
54746: EQUAL
54747: IFTRUE 54751
54749: GO 54880
54751: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54752: LD_ADDR_VAR 0 5
54756: PUSH
54757: LD_VAR 0 1
54761: PUSH
54762: LD_INT 4
54764: MINUS
54765: PUSH
54766: LD_VAR 0 2
54770: PUSH
54771: LD_INT 1
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: LIST
54778: PUSH
54779: LD_VAR 0 1
54783: PUSH
54784: LD_VAR 0 2
54788: PUSH
54789: LD_INT 4
54791: MINUS
54792: PUSH
54793: LD_INT 3
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: LIST
54800: PUSH
54801: LD_VAR 0 1
54805: PUSH
54806: LD_INT 4
54808: PLUS
54809: PUSH
54810: LD_VAR 0 2
54814: PUSH
54815: LD_INT 4
54817: PLUS
54818: PUSH
54819: LD_INT 5
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: LIST
54826: PUSH
54827: LD_VAR 0 1
54831: PUSH
54832: LD_INT 3
54834: PLUS
54835: PUSH
54836: LD_VAR 0 2
54840: PUSH
54841: LD_INT 4
54843: PUSH
54844: EMPTY
54845: LIST
54846: LIST
54847: LIST
54848: PUSH
54849: LD_VAR 0 1
54853: PUSH
54854: LD_VAR 0 2
54858: PUSH
54859: LD_INT 3
54861: PLUS
54862: PUSH
54863: LD_INT 0
54865: PUSH
54866: EMPTY
54867: LIST
54868: LIST
54869: LIST
54870: PUSH
54871: EMPTY
54872: LIST
54873: LIST
54874: LIST
54875: LIST
54876: LIST
54877: ST_TO_ADDR
// end ; end ;
54878: GO 54881
54880: POP
// result := list ;
54881: LD_ADDR_VAR 0 4
54885: PUSH
54886: LD_VAR 0 5
54890: ST_TO_ADDR
// end ;
54891: LD_VAR 0 4
54895: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
54896: LD_INT 0
54898: PPUSH
54899: PPUSH
54900: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
54901: LD_VAR 0 1
54905: NOT
54906: PUSH
54907: LD_VAR 0 2
54911: PUSH
54912: LD_INT 1
54914: PUSH
54915: LD_INT 2
54917: PUSH
54918: LD_INT 3
54920: PUSH
54921: LD_INT 4
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: LIST
54928: LIST
54929: IN
54930: NOT
54931: OR
54932: IFFALSE 54936
// exit ;
54934: GO 55028
// tmp := [ ] ;
54936: LD_ADDR_VAR 0 5
54940: PUSH
54941: EMPTY
54942: ST_TO_ADDR
// for i in units do
54943: LD_ADDR_VAR 0 4
54947: PUSH
54948: LD_VAR 0 1
54952: PUSH
54953: FOR_IN
54954: IFFALSE 54997
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
54956: LD_ADDR_VAR 0 5
54960: PUSH
54961: LD_VAR 0 5
54965: PPUSH
54966: LD_VAR 0 5
54970: PUSH
54971: LD_INT 1
54973: PLUS
54974: PPUSH
54975: LD_VAR 0 4
54979: PPUSH
54980: LD_VAR 0 2
54984: PPUSH
54985: CALL_OW 259
54989: PPUSH
54990: CALL_OW 2
54994: ST_TO_ADDR
54995: GO 54953
54997: POP
54998: POP
// if not tmp then
54999: LD_VAR 0 5
55003: NOT
55004: IFFALSE 55008
// exit ;
55006: GO 55028
// result := SortListByListDesc ( units , tmp ) ;
55008: LD_ADDR_VAR 0 3
55012: PUSH
55013: LD_VAR 0 1
55017: PPUSH
55018: LD_VAR 0 5
55022: PPUSH
55023: CALL_OW 77
55027: ST_TO_ADDR
// end ;
55028: LD_VAR 0 3
55032: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55033: LD_INT 0
55035: PPUSH
55036: PPUSH
55037: PPUSH
// x := GetX ( building ) ;
55038: LD_ADDR_VAR 0 4
55042: PUSH
55043: LD_VAR 0 2
55047: PPUSH
55048: CALL_OW 250
55052: ST_TO_ADDR
// y := GetY ( building ) ;
55053: LD_ADDR_VAR 0 5
55057: PUSH
55058: LD_VAR 0 2
55062: PPUSH
55063: CALL_OW 251
55067: ST_TO_ADDR
// if GetTaskList ( unit ) then
55068: LD_VAR 0 1
55072: PPUSH
55073: CALL_OW 437
55077: IFFALSE 55172
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55079: LD_STRING e
55081: PUSH
55082: LD_VAR 0 1
55086: PPUSH
55087: CALL_OW 437
55091: PUSH
55092: LD_INT 1
55094: ARRAY
55095: PUSH
55096: LD_INT 1
55098: ARRAY
55099: EQUAL
55100: PUSH
55101: LD_VAR 0 4
55105: PUSH
55106: LD_VAR 0 1
55110: PPUSH
55111: CALL_OW 437
55115: PUSH
55116: LD_INT 1
55118: ARRAY
55119: PUSH
55120: LD_INT 2
55122: ARRAY
55123: EQUAL
55124: AND
55125: PUSH
55126: LD_VAR 0 5
55130: PUSH
55131: LD_VAR 0 1
55135: PPUSH
55136: CALL_OW 437
55140: PUSH
55141: LD_INT 1
55143: ARRAY
55144: PUSH
55145: LD_INT 3
55147: ARRAY
55148: EQUAL
55149: AND
55150: IFFALSE 55162
// result := true else
55152: LD_ADDR_VAR 0 3
55156: PUSH
55157: LD_INT 1
55159: ST_TO_ADDR
55160: GO 55170
// result := false ;
55162: LD_ADDR_VAR 0 3
55166: PUSH
55167: LD_INT 0
55169: ST_TO_ADDR
// end else
55170: GO 55180
// result := false ;
55172: LD_ADDR_VAR 0 3
55176: PUSH
55177: LD_INT 0
55179: ST_TO_ADDR
// end ;
55180: LD_VAR 0 3
55184: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55185: LD_INT 0
55187: PPUSH
55188: PPUSH
55189: PPUSH
55190: PPUSH
// if not unit or not area then
55191: LD_VAR 0 1
55195: NOT
55196: PUSH
55197: LD_VAR 0 2
55201: NOT
55202: OR
55203: IFFALSE 55207
// exit ;
55205: GO 55371
// tmp := AreaToList ( area , i ) ;
55207: LD_ADDR_VAR 0 6
55211: PUSH
55212: LD_VAR 0 2
55216: PPUSH
55217: LD_VAR 0 5
55221: PPUSH
55222: CALL_OW 517
55226: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55227: LD_ADDR_VAR 0 5
55231: PUSH
55232: DOUBLE
55233: LD_INT 1
55235: DEC
55236: ST_TO_ADDR
55237: LD_VAR 0 6
55241: PUSH
55242: LD_INT 1
55244: ARRAY
55245: PUSH
55246: FOR_TO
55247: IFFALSE 55369
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55249: LD_ADDR_VAR 0 7
55253: PUSH
55254: LD_VAR 0 6
55258: PUSH
55259: LD_INT 1
55261: ARRAY
55262: PUSH
55263: LD_VAR 0 5
55267: ARRAY
55268: PUSH
55269: LD_VAR 0 6
55273: PUSH
55274: LD_INT 2
55276: ARRAY
55277: PUSH
55278: LD_VAR 0 5
55282: ARRAY
55283: PUSH
55284: EMPTY
55285: LIST
55286: LIST
55287: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55288: LD_VAR 0 7
55292: PUSH
55293: LD_INT 1
55295: ARRAY
55296: PPUSH
55297: LD_VAR 0 7
55301: PUSH
55302: LD_INT 2
55304: ARRAY
55305: PPUSH
55306: CALL_OW 428
55310: PUSH
55311: LD_INT 0
55313: EQUAL
55314: IFFALSE 55367
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55316: LD_VAR 0 1
55320: PPUSH
55321: LD_VAR 0 7
55325: PUSH
55326: LD_INT 1
55328: ARRAY
55329: PPUSH
55330: LD_VAR 0 7
55334: PUSH
55335: LD_INT 2
55337: ARRAY
55338: PPUSH
55339: LD_VAR 0 3
55343: PPUSH
55344: CALL_OW 48
// result := IsPlaced ( unit ) ;
55348: LD_ADDR_VAR 0 4
55352: PUSH
55353: LD_VAR 0 1
55357: PPUSH
55358: CALL_OW 305
55362: ST_TO_ADDR
// exit ;
55363: POP
55364: POP
55365: GO 55371
// end ; end ;
55367: GO 55246
55369: POP
55370: POP
// end ;
55371: LD_VAR 0 4
55375: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55376: LD_INT 0
55378: PPUSH
55379: PPUSH
55380: PPUSH
// if not side or side > 8 then
55381: LD_VAR 0 1
55385: NOT
55386: PUSH
55387: LD_VAR 0 1
55391: PUSH
55392: LD_INT 8
55394: GREATER
55395: OR
55396: IFFALSE 55400
// exit ;
55398: GO 55587
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55400: LD_ADDR_VAR 0 4
55404: PUSH
55405: LD_INT 22
55407: PUSH
55408: LD_VAR 0 1
55412: PUSH
55413: EMPTY
55414: LIST
55415: LIST
55416: PUSH
55417: LD_INT 21
55419: PUSH
55420: LD_INT 3
55422: PUSH
55423: EMPTY
55424: LIST
55425: LIST
55426: PUSH
55427: EMPTY
55428: LIST
55429: LIST
55430: PPUSH
55431: CALL_OW 69
55435: ST_TO_ADDR
// if not tmp then
55436: LD_VAR 0 4
55440: NOT
55441: IFFALSE 55445
// exit ;
55443: GO 55587
// enable_addtolog := true ;
55445: LD_ADDR_OWVAR 81
55449: PUSH
55450: LD_INT 1
55452: ST_TO_ADDR
// AddToLog ( [ ) ;
55453: LD_STRING [
55455: PPUSH
55456: CALL_OW 561
// for i in tmp do
55460: LD_ADDR_VAR 0 3
55464: PUSH
55465: LD_VAR 0 4
55469: PUSH
55470: FOR_IN
55471: IFFALSE 55578
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55473: LD_STRING [
55475: PUSH
55476: LD_VAR 0 3
55480: PPUSH
55481: CALL_OW 266
55485: STR
55486: PUSH
55487: LD_STRING , 
55489: STR
55490: PUSH
55491: LD_VAR 0 3
55495: PPUSH
55496: CALL_OW 250
55500: STR
55501: PUSH
55502: LD_STRING , 
55504: STR
55505: PUSH
55506: LD_VAR 0 3
55510: PPUSH
55511: CALL_OW 251
55515: STR
55516: PUSH
55517: LD_STRING , 
55519: STR
55520: PUSH
55521: LD_VAR 0 3
55525: PPUSH
55526: CALL_OW 254
55530: STR
55531: PUSH
55532: LD_STRING , 
55534: STR
55535: PUSH
55536: LD_VAR 0 3
55540: PPUSH
55541: LD_INT 1
55543: PPUSH
55544: CALL_OW 268
55548: STR
55549: PUSH
55550: LD_STRING , 
55552: STR
55553: PUSH
55554: LD_VAR 0 3
55558: PPUSH
55559: LD_INT 2
55561: PPUSH
55562: CALL_OW 268
55566: STR
55567: PUSH
55568: LD_STRING ],
55570: STR
55571: PPUSH
55572: CALL_OW 561
// end ;
55576: GO 55470
55578: POP
55579: POP
// AddToLog ( ]; ) ;
55580: LD_STRING ];
55582: PPUSH
55583: CALL_OW 561
// end ;
55587: LD_VAR 0 2
55591: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55592: LD_INT 0
55594: PPUSH
55595: PPUSH
55596: PPUSH
55597: PPUSH
55598: PPUSH
// if not area or not rate or not max then
55599: LD_VAR 0 1
55603: NOT
55604: PUSH
55605: LD_VAR 0 2
55609: NOT
55610: OR
55611: PUSH
55612: LD_VAR 0 4
55616: NOT
55617: OR
55618: IFFALSE 55622
// exit ;
55620: GO 55814
// while 1 do
55622: LD_INT 1
55624: IFFALSE 55814
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55626: LD_ADDR_VAR 0 9
55630: PUSH
55631: LD_VAR 0 1
55635: PPUSH
55636: LD_INT 1
55638: PPUSH
55639: CALL_OW 287
55643: PUSH
55644: LD_INT 10
55646: MUL
55647: ST_TO_ADDR
// r := rate / 10 ;
55648: LD_ADDR_VAR 0 7
55652: PUSH
55653: LD_VAR 0 2
55657: PUSH
55658: LD_INT 10
55660: DIVREAL
55661: ST_TO_ADDR
// time := 1 1$00 ;
55662: LD_ADDR_VAR 0 8
55666: PUSH
55667: LD_INT 2100
55669: ST_TO_ADDR
// if amount < min then
55670: LD_VAR 0 9
55674: PUSH
55675: LD_VAR 0 3
55679: LESS
55680: IFFALSE 55698
// r := r * 2 else
55682: LD_ADDR_VAR 0 7
55686: PUSH
55687: LD_VAR 0 7
55691: PUSH
55692: LD_INT 2
55694: MUL
55695: ST_TO_ADDR
55696: GO 55724
// if amount > max then
55698: LD_VAR 0 9
55702: PUSH
55703: LD_VAR 0 4
55707: GREATER
55708: IFFALSE 55724
// r := r / 2 ;
55710: LD_ADDR_VAR 0 7
55714: PUSH
55715: LD_VAR 0 7
55719: PUSH
55720: LD_INT 2
55722: DIVREAL
55723: ST_TO_ADDR
// time := time / r ;
55724: LD_ADDR_VAR 0 8
55728: PUSH
55729: LD_VAR 0 8
55733: PUSH
55734: LD_VAR 0 7
55738: DIVREAL
55739: ST_TO_ADDR
// if time < 0 then
55740: LD_VAR 0 8
55744: PUSH
55745: LD_INT 0
55747: LESS
55748: IFFALSE 55765
// time := time * - 1 ;
55750: LD_ADDR_VAR 0 8
55754: PUSH
55755: LD_VAR 0 8
55759: PUSH
55760: LD_INT 1
55762: NEG
55763: MUL
55764: ST_TO_ADDR
// wait ( time ) ;
55765: LD_VAR 0 8
55769: PPUSH
55770: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55774: LD_INT 35
55776: PPUSH
55777: LD_INT 875
55779: PPUSH
55780: CALL_OW 12
55784: PPUSH
55785: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55789: LD_INT 1
55791: PPUSH
55792: LD_INT 5
55794: PPUSH
55795: CALL_OW 12
55799: PPUSH
55800: LD_VAR 0 1
55804: PPUSH
55805: LD_INT 1
55807: PPUSH
55808: CALL_OW 55
// end ;
55812: GO 55622
// end ;
55814: LD_VAR 0 5
55818: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
55819: LD_INT 0
55821: PPUSH
55822: PPUSH
55823: PPUSH
55824: PPUSH
55825: PPUSH
55826: PPUSH
55827: PPUSH
55828: PPUSH
// if not turrets or not factories then
55829: LD_VAR 0 1
55833: NOT
55834: PUSH
55835: LD_VAR 0 2
55839: NOT
55840: OR
55841: IFFALSE 55845
// exit ;
55843: GO 56152
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
55845: LD_ADDR_VAR 0 10
55849: PUSH
55850: LD_INT 5
55852: PUSH
55853: LD_INT 6
55855: PUSH
55856: EMPTY
55857: LIST
55858: LIST
55859: PUSH
55860: LD_INT 2
55862: PUSH
55863: LD_INT 4
55865: PUSH
55866: EMPTY
55867: LIST
55868: LIST
55869: PUSH
55870: LD_INT 3
55872: PUSH
55873: LD_INT 5
55875: PUSH
55876: EMPTY
55877: LIST
55878: LIST
55879: PUSH
55880: EMPTY
55881: LIST
55882: LIST
55883: LIST
55884: PUSH
55885: LD_INT 24
55887: PUSH
55888: LD_INT 25
55890: PUSH
55891: EMPTY
55892: LIST
55893: LIST
55894: PUSH
55895: LD_INT 23
55897: PUSH
55898: LD_INT 27
55900: PUSH
55901: EMPTY
55902: LIST
55903: LIST
55904: PUSH
55905: EMPTY
55906: LIST
55907: LIST
55908: PUSH
55909: LD_INT 42
55911: PUSH
55912: LD_INT 43
55914: PUSH
55915: EMPTY
55916: LIST
55917: LIST
55918: PUSH
55919: LD_INT 44
55921: PUSH
55922: LD_INT 46
55924: PUSH
55925: EMPTY
55926: LIST
55927: LIST
55928: PUSH
55929: LD_INT 45
55931: PUSH
55932: LD_INT 47
55934: PUSH
55935: EMPTY
55936: LIST
55937: LIST
55938: PUSH
55939: EMPTY
55940: LIST
55941: LIST
55942: LIST
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: LIST
55948: ST_TO_ADDR
// result := [ ] ;
55949: LD_ADDR_VAR 0 3
55953: PUSH
55954: EMPTY
55955: ST_TO_ADDR
// for i in turrets do
55956: LD_ADDR_VAR 0 4
55960: PUSH
55961: LD_VAR 0 1
55965: PUSH
55966: FOR_IN
55967: IFFALSE 56150
// begin nat := GetNation ( i ) ;
55969: LD_ADDR_VAR 0 7
55973: PUSH
55974: LD_VAR 0 4
55978: PPUSH
55979: CALL_OW 248
55983: ST_TO_ADDR
// weapon := 0 ;
55984: LD_ADDR_VAR 0 8
55988: PUSH
55989: LD_INT 0
55991: ST_TO_ADDR
// if not nat then
55992: LD_VAR 0 7
55996: NOT
55997: IFFALSE 56001
// continue ;
55999: GO 55966
// for j in list [ nat ] do
56001: LD_ADDR_VAR 0 5
56005: PUSH
56006: LD_VAR 0 10
56010: PUSH
56011: LD_VAR 0 7
56015: ARRAY
56016: PUSH
56017: FOR_IN
56018: IFFALSE 56059
// if GetBWeapon ( i ) = j [ 1 ] then
56020: LD_VAR 0 4
56024: PPUSH
56025: CALL_OW 269
56029: PUSH
56030: LD_VAR 0 5
56034: PUSH
56035: LD_INT 1
56037: ARRAY
56038: EQUAL
56039: IFFALSE 56057
// begin weapon := j [ 2 ] ;
56041: LD_ADDR_VAR 0 8
56045: PUSH
56046: LD_VAR 0 5
56050: PUSH
56051: LD_INT 2
56053: ARRAY
56054: ST_TO_ADDR
// break ;
56055: GO 56059
// end ;
56057: GO 56017
56059: POP
56060: POP
// if not weapon then
56061: LD_VAR 0 8
56065: NOT
56066: IFFALSE 56070
// continue ;
56068: GO 55966
// for k in factories do
56070: LD_ADDR_VAR 0 6
56074: PUSH
56075: LD_VAR 0 2
56079: PUSH
56080: FOR_IN
56081: IFFALSE 56146
// begin weapons := AvailableWeaponList ( k ) ;
56083: LD_ADDR_VAR 0 9
56087: PUSH
56088: LD_VAR 0 6
56092: PPUSH
56093: CALL_OW 478
56097: ST_TO_ADDR
// if not weapons then
56098: LD_VAR 0 9
56102: NOT
56103: IFFALSE 56107
// continue ;
56105: GO 56080
// if weapon in weapons then
56107: LD_VAR 0 8
56111: PUSH
56112: LD_VAR 0 9
56116: IN
56117: IFFALSE 56144
// begin result := [ i , weapon ] ;
56119: LD_ADDR_VAR 0 3
56123: PUSH
56124: LD_VAR 0 4
56128: PUSH
56129: LD_VAR 0 8
56133: PUSH
56134: EMPTY
56135: LIST
56136: LIST
56137: ST_TO_ADDR
// exit ;
56138: POP
56139: POP
56140: POP
56141: POP
56142: GO 56152
// end ; end ;
56144: GO 56080
56146: POP
56147: POP
// end ;
56148: GO 55966
56150: POP
56151: POP
// end ;
56152: LD_VAR 0 3
56156: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56157: LD_INT 0
56159: PPUSH
// if not side or side > 8 then
56160: LD_VAR 0 3
56164: NOT
56165: PUSH
56166: LD_VAR 0 3
56170: PUSH
56171: LD_INT 8
56173: GREATER
56174: OR
56175: IFFALSE 56179
// exit ;
56177: GO 56238
// if not range then
56179: LD_VAR 0 4
56183: NOT
56184: IFFALSE 56195
// range := - 12 ;
56186: LD_ADDR_VAR 0 4
56190: PUSH
56191: LD_INT 12
56193: NEG
56194: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56195: LD_VAR 0 1
56199: PPUSH
56200: LD_VAR 0 2
56204: PPUSH
56205: LD_VAR 0 3
56209: PPUSH
56210: LD_VAR 0 4
56214: PPUSH
56215: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56219: LD_VAR 0 1
56223: PPUSH
56224: LD_VAR 0 2
56228: PPUSH
56229: LD_VAR 0 3
56233: PPUSH
56234: CALL_OW 331
// end ;
56238: LD_VAR 0 5
56242: RET
// export function Video ( mode ) ; begin
56243: LD_INT 0
56245: PPUSH
// ingame_video = mode ;
56246: LD_ADDR_OWVAR 52
56250: PUSH
56251: LD_VAR 0 1
56255: ST_TO_ADDR
// interface_hidden = mode ;
56256: LD_ADDR_OWVAR 54
56260: PUSH
56261: LD_VAR 0 1
56265: ST_TO_ADDR
// end ;
56266: LD_VAR 0 2
56270: RET
// export function Join ( array , element ) ; begin
56271: LD_INT 0
56273: PPUSH
// result := array ^ element ;
56274: LD_ADDR_VAR 0 3
56278: PUSH
56279: LD_VAR 0 1
56283: PUSH
56284: LD_VAR 0 2
56288: ADD
56289: ST_TO_ADDR
// end ;
56290: LD_VAR 0 3
56294: RET
// export function JoinUnion ( array , element ) ; begin
56295: LD_INT 0
56297: PPUSH
// result := array union element ;
56298: LD_ADDR_VAR 0 3
56302: PUSH
56303: LD_VAR 0 1
56307: PUSH
56308: LD_VAR 0 2
56312: UNION
56313: ST_TO_ADDR
// end ;
56314: LD_VAR 0 3
56318: RET
// export function GetBehemoths ( side ) ; begin
56319: LD_INT 0
56321: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56322: LD_ADDR_VAR 0 2
56326: PUSH
56327: LD_INT 22
56329: PUSH
56330: LD_VAR 0 1
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: PUSH
56339: LD_INT 31
56341: PUSH
56342: LD_INT 25
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: PUSH
56349: EMPTY
56350: LIST
56351: LIST
56352: PPUSH
56353: CALL_OW 69
56357: ST_TO_ADDR
// end ;
56358: LD_VAR 0 2
56362: RET
// export function Shuffle ( array ) ; var i , index ; begin
56363: LD_INT 0
56365: PPUSH
56366: PPUSH
56367: PPUSH
// result := [ ] ;
56368: LD_ADDR_VAR 0 2
56372: PUSH
56373: EMPTY
56374: ST_TO_ADDR
// if not array then
56375: LD_VAR 0 1
56379: NOT
56380: IFFALSE 56384
// exit ;
56382: GO 56483
// Randomize ;
56384: CALL_OW 10
// for i = array downto 1 do
56388: LD_ADDR_VAR 0 3
56392: PUSH
56393: DOUBLE
56394: LD_VAR 0 1
56398: INC
56399: ST_TO_ADDR
56400: LD_INT 1
56402: PUSH
56403: FOR_DOWNTO
56404: IFFALSE 56481
// begin index := rand ( 1 , array ) ;
56406: LD_ADDR_VAR 0 4
56410: PUSH
56411: LD_INT 1
56413: PPUSH
56414: LD_VAR 0 1
56418: PPUSH
56419: CALL_OW 12
56423: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56424: LD_ADDR_VAR 0 2
56428: PUSH
56429: LD_VAR 0 2
56433: PPUSH
56434: LD_VAR 0 2
56438: PUSH
56439: LD_INT 1
56441: PLUS
56442: PPUSH
56443: LD_VAR 0 1
56447: PUSH
56448: LD_VAR 0 4
56452: ARRAY
56453: PPUSH
56454: CALL_OW 2
56458: ST_TO_ADDR
// array := Delete ( array , index ) ;
56459: LD_ADDR_VAR 0 1
56463: PUSH
56464: LD_VAR 0 1
56468: PPUSH
56469: LD_VAR 0 4
56473: PPUSH
56474: CALL_OW 3
56478: ST_TO_ADDR
// end ;
56479: GO 56403
56481: POP
56482: POP
// end ; end_of_file
56483: LD_VAR 0 2
56487: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56488: LD_INT 0
56490: PPUSH
56491: PPUSH
// skirmish := false ;
56492: LD_ADDR_EXP 56
56496: PUSH
56497: LD_INT 0
56499: ST_TO_ADDR
// debug_mc := false ;
56500: LD_ADDR_EXP 57
56504: PUSH
56505: LD_INT 0
56507: ST_TO_ADDR
// mc_bases := [ ] ;
56508: LD_ADDR_EXP 58
56512: PUSH
56513: EMPTY
56514: ST_TO_ADDR
// mc_sides := [ ] ;
56515: LD_ADDR_EXP 84
56519: PUSH
56520: EMPTY
56521: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56522: LD_ADDR_EXP 59
56526: PUSH
56527: EMPTY
56528: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56529: LD_ADDR_EXP 60
56533: PUSH
56534: EMPTY
56535: ST_TO_ADDR
// mc_need_heal := [ ] ;
56536: LD_ADDR_EXP 61
56540: PUSH
56541: EMPTY
56542: ST_TO_ADDR
// mc_healers := [ ] ;
56543: LD_ADDR_EXP 62
56547: PUSH
56548: EMPTY
56549: ST_TO_ADDR
// mc_build_list := [ ] ;
56550: LD_ADDR_EXP 63
56554: PUSH
56555: EMPTY
56556: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56557: LD_ADDR_EXP 90
56561: PUSH
56562: EMPTY
56563: ST_TO_ADDR
// mc_builders := [ ] ;
56564: LD_ADDR_EXP 64
56568: PUSH
56569: EMPTY
56570: ST_TO_ADDR
// mc_construct_list := [ ] ;
56571: LD_ADDR_EXP 65
56575: PUSH
56576: EMPTY
56577: ST_TO_ADDR
// mc_turret_list := [ ] ;
56578: LD_ADDR_EXP 66
56582: PUSH
56583: EMPTY
56584: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56585: LD_ADDR_EXP 67
56589: PUSH
56590: EMPTY
56591: ST_TO_ADDR
// mc_miners := [ ] ;
56592: LD_ADDR_EXP 72
56596: PUSH
56597: EMPTY
56598: ST_TO_ADDR
// mc_mines := [ ] ;
56599: LD_ADDR_EXP 71
56603: PUSH
56604: EMPTY
56605: ST_TO_ADDR
// mc_minefields := [ ] ;
56606: LD_ADDR_EXP 73
56610: PUSH
56611: EMPTY
56612: ST_TO_ADDR
// mc_crates := [ ] ;
56613: LD_ADDR_EXP 74
56617: PUSH
56618: EMPTY
56619: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56620: LD_ADDR_EXP 75
56624: PUSH
56625: EMPTY
56626: ST_TO_ADDR
// mc_crates_area := [ ] ;
56627: LD_ADDR_EXP 76
56631: PUSH
56632: EMPTY
56633: ST_TO_ADDR
// mc_vehicles := [ ] ;
56634: LD_ADDR_EXP 77
56638: PUSH
56639: EMPTY
56640: ST_TO_ADDR
// mc_attack := [ ] ;
56641: LD_ADDR_EXP 78
56645: PUSH
56646: EMPTY
56647: ST_TO_ADDR
// mc_produce := [ ] ;
56648: LD_ADDR_EXP 79
56652: PUSH
56653: EMPTY
56654: ST_TO_ADDR
// mc_defender := [ ] ;
56655: LD_ADDR_EXP 80
56659: PUSH
56660: EMPTY
56661: ST_TO_ADDR
// mc_parking := [ ] ;
56662: LD_ADDR_EXP 82
56666: PUSH
56667: EMPTY
56668: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56669: LD_ADDR_EXP 68
56673: PUSH
56674: EMPTY
56675: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56676: LD_ADDR_EXP 70
56680: PUSH
56681: EMPTY
56682: ST_TO_ADDR
// mc_scan := [ ] ;
56683: LD_ADDR_EXP 81
56687: PUSH
56688: EMPTY
56689: ST_TO_ADDR
// mc_scan_area := [ ] ;
56690: LD_ADDR_EXP 83
56694: PUSH
56695: EMPTY
56696: ST_TO_ADDR
// mc_tech := [ ] ;
56697: LD_ADDR_EXP 85
56701: PUSH
56702: EMPTY
56703: ST_TO_ADDR
// mc_class := [ ] ;
56704: LD_ADDR_EXP 99
56708: PUSH
56709: EMPTY
56710: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56711: LD_ADDR_EXP 100
56715: PUSH
56716: EMPTY
56717: ST_TO_ADDR
// end ;
56718: LD_VAR 0 1
56722: RET
// export function MC_Kill ( base ) ; begin
56723: LD_INT 0
56725: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56726: LD_ADDR_EXP 58
56730: PUSH
56731: LD_EXP 58
56735: PPUSH
56736: LD_VAR 0 1
56740: PPUSH
56741: EMPTY
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56748: LD_ADDR_EXP 59
56752: PUSH
56753: LD_EXP 59
56757: PPUSH
56758: LD_VAR 0 1
56762: PPUSH
56763: EMPTY
56764: PPUSH
56765: CALL_OW 1
56769: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56770: LD_ADDR_EXP 60
56774: PUSH
56775: LD_EXP 60
56779: PPUSH
56780: LD_VAR 0 1
56784: PPUSH
56785: EMPTY
56786: PPUSH
56787: CALL_OW 1
56791: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56792: LD_ADDR_EXP 61
56796: PUSH
56797: LD_EXP 61
56801: PPUSH
56802: LD_VAR 0 1
56806: PPUSH
56807: EMPTY
56808: PPUSH
56809: CALL_OW 1
56813: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56814: LD_ADDR_EXP 62
56818: PUSH
56819: LD_EXP 62
56823: PPUSH
56824: LD_VAR 0 1
56828: PPUSH
56829: EMPTY
56830: PPUSH
56831: CALL_OW 1
56835: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56836: LD_ADDR_EXP 63
56840: PUSH
56841: LD_EXP 63
56845: PPUSH
56846: LD_VAR 0 1
56850: PPUSH
56851: EMPTY
56852: PPUSH
56853: CALL_OW 1
56857: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56858: LD_ADDR_EXP 64
56862: PUSH
56863: LD_EXP 64
56867: PPUSH
56868: LD_VAR 0 1
56872: PPUSH
56873: EMPTY
56874: PPUSH
56875: CALL_OW 1
56879: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56880: LD_ADDR_EXP 65
56884: PUSH
56885: LD_EXP 65
56889: PPUSH
56890: LD_VAR 0 1
56894: PPUSH
56895: EMPTY
56896: PPUSH
56897: CALL_OW 1
56901: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56902: LD_ADDR_EXP 66
56906: PUSH
56907: LD_EXP 66
56911: PPUSH
56912: LD_VAR 0 1
56916: PPUSH
56917: EMPTY
56918: PPUSH
56919: CALL_OW 1
56923: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56924: LD_ADDR_EXP 67
56928: PUSH
56929: LD_EXP 67
56933: PPUSH
56934: LD_VAR 0 1
56938: PPUSH
56939: EMPTY
56940: PPUSH
56941: CALL_OW 1
56945: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56946: LD_ADDR_EXP 68
56950: PUSH
56951: LD_EXP 68
56955: PPUSH
56956: LD_VAR 0 1
56960: PPUSH
56961: EMPTY
56962: PPUSH
56963: CALL_OW 1
56967: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56968: LD_ADDR_EXP 69
56972: PUSH
56973: LD_EXP 69
56977: PPUSH
56978: LD_VAR 0 1
56982: PPUSH
56983: LD_INT 0
56985: PPUSH
56986: CALL_OW 1
56990: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56991: LD_ADDR_EXP 70
56995: PUSH
56996: LD_EXP 70
57000: PPUSH
57001: LD_VAR 0 1
57005: PPUSH
57006: EMPTY
57007: PPUSH
57008: CALL_OW 1
57012: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57013: LD_ADDR_EXP 71
57017: PUSH
57018: LD_EXP 71
57022: PPUSH
57023: LD_VAR 0 1
57027: PPUSH
57028: EMPTY
57029: PPUSH
57030: CALL_OW 1
57034: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57035: LD_ADDR_EXP 72
57039: PUSH
57040: LD_EXP 72
57044: PPUSH
57045: LD_VAR 0 1
57049: PPUSH
57050: EMPTY
57051: PPUSH
57052: CALL_OW 1
57056: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57057: LD_ADDR_EXP 73
57061: PUSH
57062: LD_EXP 73
57066: PPUSH
57067: LD_VAR 0 1
57071: PPUSH
57072: EMPTY
57073: PPUSH
57074: CALL_OW 1
57078: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57079: LD_ADDR_EXP 74
57083: PUSH
57084: LD_EXP 74
57088: PPUSH
57089: LD_VAR 0 1
57093: PPUSH
57094: EMPTY
57095: PPUSH
57096: CALL_OW 1
57100: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57101: LD_ADDR_EXP 75
57105: PUSH
57106: LD_EXP 75
57110: PPUSH
57111: LD_VAR 0 1
57115: PPUSH
57116: EMPTY
57117: PPUSH
57118: CALL_OW 1
57122: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57123: LD_ADDR_EXP 76
57127: PUSH
57128: LD_EXP 76
57132: PPUSH
57133: LD_VAR 0 1
57137: PPUSH
57138: EMPTY
57139: PPUSH
57140: CALL_OW 1
57144: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57145: LD_ADDR_EXP 77
57149: PUSH
57150: LD_EXP 77
57154: PPUSH
57155: LD_VAR 0 1
57159: PPUSH
57160: EMPTY
57161: PPUSH
57162: CALL_OW 1
57166: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57167: LD_ADDR_EXP 78
57171: PUSH
57172: LD_EXP 78
57176: PPUSH
57177: LD_VAR 0 1
57181: PPUSH
57182: EMPTY
57183: PPUSH
57184: CALL_OW 1
57188: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57189: LD_ADDR_EXP 79
57193: PUSH
57194: LD_EXP 79
57198: PPUSH
57199: LD_VAR 0 1
57203: PPUSH
57204: EMPTY
57205: PPUSH
57206: CALL_OW 1
57210: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57211: LD_ADDR_EXP 80
57215: PUSH
57216: LD_EXP 80
57220: PPUSH
57221: LD_VAR 0 1
57225: PPUSH
57226: EMPTY
57227: PPUSH
57228: CALL_OW 1
57232: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57233: LD_ADDR_EXP 81
57237: PUSH
57238: LD_EXP 81
57242: PPUSH
57243: LD_VAR 0 1
57247: PPUSH
57248: EMPTY
57249: PPUSH
57250: CALL_OW 1
57254: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57255: LD_ADDR_EXP 82
57259: PUSH
57260: LD_EXP 82
57264: PPUSH
57265: LD_VAR 0 1
57269: PPUSH
57270: EMPTY
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57277: LD_ADDR_EXP 83
57281: PUSH
57282: LD_EXP 83
57286: PPUSH
57287: LD_VAR 0 1
57291: PPUSH
57292: EMPTY
57293: PPUSH
57294: CALL_OW 1
57298: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57299: LD_ADDR_EXP 85
57303: PUSH
57304: LD_EXP 85
57308: PPUSH
57309: LD_VAR 0 1
57313: PPUSH
57314: EMPTY
57315: PPUSH
57316: CALL_OW 1
57320: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57321: LD_ADDR_EXP 87
57325: PUSH
57326: LD_EXP 87
57330: PPUSH
57331: LD_VAR 0 1
57335: PPUSH
57336: EMPTY
57337: PPUSH
57338: CALL_OW 1
57342: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57343: LD_ADDR_EXP 88
57347: PUSH
57348: LD_EXP 88
57352: PPUSH
57353: LD_VAR 0 1
57357: PPUSH
57358: EMPTY
57359: PPUSH
57360: CALL_OW 1
57364: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57365: LD_ADDR_EXP 89
57369: PUSH
57370: LD_EXP 89
57374: PPUSH
57375: LD_VAR 0 1
57379: PPUSH
57380: EMPTY
57381: PPUSH
57382: CALL_OW 1
57386: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57387: LD_ADDR_EXP 90
57391: PUSH
57392: LD_EXP 90
57396: PPUSH
57397: LD_VAR 0 1
57401: PPUSH
57402: EMPTY
57403: PPUSH
57404: CALL_OW 1
57408: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57409: LD_ADDR_EXP 91
57413: PUSH
57414: LD_EXP 91
57418: PPUSH
57419: LD_VAR 0 1
57423: PPUSH
57424: EMPTY
57425: PPUSH
57426: CALL_OW 1
57430: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57431: LD_ADDR_EXP 92
57435: PUSH
57436: LD_EXP 92
57440: PPUSH
57441: LD_VAR 0 1
57445: PPUSH
57446: EMPTY
57447: PPUSH
57448: CALL_OW 1
57452: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57453: LD_ADDR_EXP 93
57457: PUSH
57458: LD_EXP 93
57462: PPUSH
57463: LD_VAR 0 1
57467: PPUSH
57468: EMPTY
57469: PPUSH
57470: CALL_OW 1
57474: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57475: LD_ADDR_EXP 94
57479: PUSH
57480: LD_EXP 94
57484: PPUSH
57485: LD_VAR 0 1
57489: PPUSH
57490: EMPTY
57491: PPUSH
57492: CALL_OW 1
57496: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57497: LD_ADDR_EXP 95
57501: PUSH
57502: LD_EXP 95
57506: PPUSH
57507: LD_VAR 0 1
57511: PPUSH
57512: EMPTY
57513: PPUSH
57514: CALL_OW 1
57518: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57519: LD_ADDR_EXP 96
57523: PUSH
57524: LD_EXP 96
57528: PPUSH
57529: LD_VAR 0 1
57533: PPUSH
57534: EMPTY
57535: PPUSH
57536: CALL_OW 1
57540: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57541: LD_ADDR_EXP 97
57545: PUSH
57546: LD_EXP 97
57550: PPUSH
57551: LD_VAR 0 1
57555: PPUSH
57556: EMPTY
57557: PPUSH
57558: CALL_OW 1
57562: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57563: LD_ADDR_EXP 98
57567: PUSH
57568: LD_EXP 98
57572: PPUSH
57573: LD_VAR 0 1
57577: PPUSH
57578: EMPTY
57579: PPUSH
57580: CALL_OW 1
57584: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57585: LD_ADDR_EXP 99
57589: PUSH
57590: LD_EXP 99
57594: PPUSH
57595: LD_VAR 0 1
57599: PPUSH
57600: EMPTY
57601: PPUSH
57602: CALL_OW 1
57606: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57607: LD_ADDR_EXP 100
57611: PUSH
57612: LD_EXP 100
57616: PPUSH
57617: LD_VAR 0 1
57621: PPUSH
57622: LD_INT 0
57624: PPUSH
57625: CALL_OW 1
57629: ST_TO_ADDR
// end ;
57630: LD_VAR 0 2
57634: RET
// export function MC_Add ( side , units ) ; var base ; begin
57635: LD_INT 0
57637: PPUSH
57638: PPUSH
// base := mc_bases + 1 ;
57639: LD_ADDR_VAR 0 4
57643: PUSH
57644: LD_EXP 58
57648: PUSH
57649: LD_INT 1
57651: PLUS
57652: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57653: LD_ADDR_EXP 84
57657: PUSH
57658: LD_EXP 84
57662: PPUSH
57663: LD_VAR 0 4
57667: PPUSH
57668: LD_VAR 0 1
57672: PPUSH
57673: CALL_OW 1
57677: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57678: LD_ADDR_EXP 58
57682: PUSH
57683: LD_EXP 58
57687: PPUSH
57688: LD_VAR 0 4
57692: PPUSH
57693: LD_VAR 0 2
57697: PPUSH
57698: CALL_OW 1
57702: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57703: LD_ADDR_EXP 59
57707: PUSH
57708: LD_EXP 59
57712: PPUSH
57713: LD_VAR 0 4
57717: PPUSH
57718: EMPTY
57719: PPUSH
57720: CALL_OW 1
57724: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57725: LD_ADDR_EXP 60
57729: PUSH
57730: LD_EXP 60
57734: PPUSH
57735: LD_VAR 0 4
57739: PPUSH
57740: EMPTY
57741: PPUSH
57742: CALL_OW 1
57746: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57747: LD_ADDR_EXP 61
57751: PUSH
57752: LD_EXP 61
57756: PPUSH
57757: LD_VAR 0 4
57761: PPUSH
57762: EMPTY
57763: PPUSH
57764: CALL_OW 1
57768: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57769: LD_ADDR_EXP 62
57773: PUSH
57774: LD_EXP 62
57778: PPUSH
57779: LD_VAR 0 4
57783: PPUSH
57784: EMPTY
57785: PPUSH
57786: CALL_OW 1
57790: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57791: LD_ADDR_EXP 63
57795: PUSH
57796: LD_EXP 63
57800: PPUSH
57801: LD_VAR 0 4
57805: PPUSH
57806: EMPTY
57807: PPUSH
57808: CALL_OW 1
57812: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57813: LD_ADDR_EXP 64
57817: PUSH
57818: LD_EXP 64
57822: PPUSH
57823: LD_VAR 0 4
57827: PPUSH
57828: EMPTY
57829: PPUSH
57830: CALL_OW 1
57834: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57835: LD_ADDR_EXP 65
57839: PUSH
57840: LD_EXP 65
57844: PPUSH
57845: LD_VAR 0 4
57849: PPUSH
57850: EMPTY
57851: PPUSH
57852: CALL_OW 1
57856: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57857: LD_ADDR_EXP 66
57861: PUSH
57862: LD_EXP 66
57866: PPUSH
57867: LD_VAR 0 4
57871: PPUSH
57872: EMPTY
57873: PPUSH
57874: CALL_OW 1
57878: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57879: LD_ADDR_EXP 67
57883: PUSH
57884: LD_EXP 67
57888: PPUSH
57889: LD_VAR 0 4
57893: PPUSH
57894: EMPTY
57895: PPUSH
57896: CALL_OW 1
57900: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57901: LD_ADDR_EXP 68
57905: PUSH
57906: LD_EXP 68
57910: PPUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: EMPTY
57917: PPUSH
57918: CALL_OW 1
57922: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57923: LD_ADDR_EXP 69
57927: PUSH
57928: LD_EXP 69
57932: PPUSH
57933: LD_VAR 0 4
57937: PPUSH
57938: LD_INT 0
57940: PPUSH
57941: CALL_OW 1
57945: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57946: LD_ADDR_EXP 70
57950: PUSH
57951: LD_EXP 70
57955: PPUSH
57956: LD_VAR 0 4
57960: PPUSH
57961: EMPTY
57962: PPUSH
57963: CALL_OW 1
57967: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57968: LD_ADDR_EXP 71
57972: PUSH
57973: LD_EXP 71
57977: PPUSH
57978: LD_VAR 0 4
57982: PPUSH
57983: EMPTY
57984: PPUSH
57985: CALL_OW 1
57989: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57990: LD_ADDR_EXP 72
57994: PUSH
57995: LD_EXP 72
57999: PPUSH
58000: LD_VAR 0 4
58004: PPUSH
58005: EMPTY
58006: PPUSH
58007: CALL_OW 1
58011: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58012: LD_ADDR_EXP 73
58016: PUSH
58017: LD_EXP 73
58021: PPUSH
58022: LD_VAR 0 4
58026: PPUSH
58027: EMPTY
58028: PPUSH
58029: CALL_OW 1
58033: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58034: LD_ADDR_EXP 74
58038: PUSH
58039: LD_EXP 74
58043: PPUSH
58044: LD_VAR 0 4
58048: PPUSH
58049: EMPTY
58050: PPUSH
58051: CALL_OW 1
58055: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58056: LD_ADDR_EXP 75
58060: PUSH
58061: LD_EXP 75
58065: PPUSH
58066: LD_VAR 0 4
58070: PPUSH
58071: EMPTY
58072: PPUSH
58073: CALL_OW 1
58077: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58078: LD_ADDR_EXP 76
58082: PUSH
58083: LD_EXP 76
58087: PPUSH
58088: LD_VAR 0 4
58092: PPUSH
58093: EMPTY
58094: PPUSH
58095: CALL_OW 1
58099: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58100: LD_ADDR_EXP 77
58104: PUSH
58105: LD_EXP 77
58109: PPUSH
58110: LD_VAR 0 4
58114: PPUSH
58115: EMPTY
58116: PPUSH
58117: CALL_OW 1
58121: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58122: LD_ADDR_EXP 78
58126: PUSH
58127: LD_EXP 78
58131: PPUSH
58132: LD_VAR 0 4
58136: PPUSH
58137: EMPTY
58138: PPUSH
58139: CALL_OW 1
58143: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58144: LD_ADDR_EXP 79
58148: PUSH
58149: LD_EXP 79
58153: PPUSH
58154: LD_VAR 0 4
58158: PPUSH
58159: EMPTY
58160: PPUSH
58161: CALL_OW 1
58165: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58166: LD_ADDR_EXP 80
58170: PUSH
58171: LD_EXP 80
58175: PPUSH
58176: LD_VAR 0 4
58180: PPUSH
58181: EMPTY
58182: PPUSH
58183: CALL_OW 1
58187: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58188: LD_ADDR_EXP 81
58192: PUSH
58193: LD_EXP 81
58197: PPUSH
58198: LD_VAR 0 4
58202: PPUSH
58203: EMPTY
58204: PPUSH
58205: CALL_OW 1
58209: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58210: LD_ADDR_EXP 82
58214: PUSH
58215: LD_EXP 82
58219: PPUSH
58220: LD_VAR 0 4
58224: PPUSH
58225: EMPTY
58226: PPUSH
58227: CALL_OW 1
58231: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58232: LD_ADDR_EXP 83
58236: PUSH
58237: LD_EXP 83
58241: PPUSH
58242: LD_VAR 0 4
58246: PPUSH
58247: EMPTY
58248: PPUSH
58249: CALL_OW 1
58253: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58254: LD_ADDR_EXP 85
58258: PUSH
58259: LD_EXP 85
58263: PPUSH
58264: LD_VAR 0 4
58268: PPUSH
58269: EMPTY
58270: PPUSH
58271: CALL_OW 1
58275: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58276: LD_ADDR_EXP 87
58280: PUSH
58281: LD_EXP 87
58285: PPUSH
58286: LD_VAR 0 4
58290: PPUSH
58291: EMPTY
58292: PPUSH
58293: CALL_OW 1
58297: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58298: LD_ADDR_EXP 88
58302: PUSH
58303: LD_EXP 88
58307: PPUSH
58308: LD_VAR 0 4
58312: PPUSH
58313: EMPTY
58314: PPUSH
58315: CALL_OW 1
58319: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58320: LD_ADDR_EXP 89
58324: PUSH
58325: LD_EXP 89
58329: PPUSH
58330: LD_VAR 0 4
58334: PPUSH
58335: EMPTY
58336: PPUSH
58337: CALL_OW 1
58341: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58342: LD_ADDR_EXP 90
58346: PUSH
58347: LD_EXP 90
58351: PPUSH
58352: LD_VAR 0 4
58356: PPUSH
58357: EMPTY
58358: PPUSH
58359: CALL_OW 1
58363: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58364: LD_ADDR_EXP 91
58368: PUSH
58369: LD_EXP 91
58373: PPUSH
58374: LD_VAR 0 4
58378: PPUSH
58379: EMPTY
58380: PPUSH
58381: CALL_OW 1
58385: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58386: LD_ADDR_EXP 92
58390: PUSH
58391: LD_EXP 92
58395: PPUSH
58396: LD_VAR 0 4
58400: PPUSH
58401: EMPTY
58402: PPUSH
58403: CALL_OW 1
58407: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58408: LD_ADDR_EXP 93
58412: PUSH
58413: LD_EXP 93
58417: PPUSH
58418: LD_VAR 0 4
58422: PPUSH
58423: EMPTY
58424: PPUSH
58425: CALL_OW 1
58429: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58430: LD_ADDR_EXP 94
58434: PUSH
58435: LD_EXP 94
58439: PPUSH
58440: LD_VAR 0 4
58444: PPUSH
58445: EMPTY
58446: PPUSH
58447: CALL_OW 1
58451: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58452: LD_ADDR_EXP 95
58456: PUSH
58457: LD_EXP 95
58461: PPUSH
58462: LD_VAR 0 4
58466: PPUSH
58467: EMPTY
58468: PPUSH
58469: CALL_OW 1
58473: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58474: LD_ADDR_EXP 96
58478: PUSH
58479: LD_EXP 96
58483: PPUSH
58484: LD_VAR 0 4
58488: PPUSH
58489: EMPTY
58490: PPUSH
58491: CALL_OW 1
58495: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58496: LD_ADDR_EXP 97
58500: PUSH
58501: LD_EXP 97
58505: PPUSH
58506: LD_VAR 0 4
58510: PPUSH
58511: EMPTY
58512: PPUSH
58513: CALL_OW 1
58517: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58518: LD_ADDR_EXP 98
58522: PUSH
58523: LD_EXP 98
58527: PPUSH
58528: LD_VAR 0 4
58532: PPUSH
58533: EMPTY
58534: PPUSH
58535: CALL_OW 1
58539: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58540: LD_ADDR_EXP 99
58544: PUSH
58545: LD_EXP 99
58549: PPUSH
58550: LD_VAR 0 4
58554: PPUSH
58555: EMPTY
58556: PPUSH
58557: CALL_OW 1
58561: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58562: LD_ADDR_EXP 100
58566: PUSH
58567: LD_EXP 100
58571: PPUSH
58572: LD_VAR 0 4
58576: PPUSH
58577: LD_INT 0
58579: PPUSH
58580: CALL_OW 1
58584: ST_TO_ADDR
// result := base ;
58585: LD_ADDR_VAR 0 3
58589: PUSH
58590: LD_VAR 0 4
58594: ST_TO_ADDR
// end ;
58595: LD_VAR 0 3
58599: RET
// export function MC_Start ( ) ; var i ; begin
58600: LD_INT 0
58602: PPUSH
58603: PPUSH
// for i = 1 to mc_bases do
58604: LD_ADDR_VAR 0 2
58608: PUSH
58609: DOUBLE
58610: LD_INT 1
58612: DEC
58613: ST_TO_ADDR
58614: LD_EXP 58
58618: PUSH
58619: FOR_TO
58620: IFFALSE 59697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58622: LD_ADDR_EXP 58
58626: PUSH
58627: LD_EXP 58
58631: PPUSH
58632: LD_VAR 0 2
58636: PPUSH
58637: LD_EXP 58
58641: PUSH
58642: LD_VAR 0 2
58646: ARRAY
58647: PUSH
58648: LD_INT 0
58650: DIFF
58651: PPUSH
58652: CALL_OW 1
58656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58657: LD_ADDR_EXP 59
58661: PUSH
58662: LD_EXP 59
58666: PPUSH
58667: LD_VAR 0 2
58671: PPUSH
58672: EMPTY
58673: PPUSH
58674: CALL_OW 1
58678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58679: LD_ADDR_EXP 60
58683: PUSH
58684: LD_EXP 60
58688: PPUSH
58689: LD_VAR 0 2
58693: PPUSH
58694: EMPTY
58695: PPUSH
58696: CALL_OW 1
58700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58701: LD_ADDR_EXP 61
58705: PUSH
58706: LD_EXP 61
58710: PPUSH
58711: LD_VAR 0 2
58715: PPUSH
58716: EMPTY
58717: PPUSH
58718: CALL_OW 1
58722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58723: LD_ADDR_EXP 62
58727: PUSH
58728: LD_EXP 62
58732: PPUSH
58733: LD_VAR 0 2
58737: PPUSH
58738: EMPTY
58739: PUSH
58740: EMPTY
58741: PUSH
58742: EMPTY
58743: LIST
58744: LIST
58745: PPUSH
58746: CALL_OW 1
58750: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58751: LD_ADDR_EXP 63
58755: PUSH
58756: LD_EXP 63
58760: PPUSH
58761: LD_VAR 0 2
58765: PPUSH
58766: EMPTY
58767: PPUSH
58768: CALL_OW 1
58772: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58773: LD_ADDR_EXP 90
58777: PUSH
58778: LD_EXP 90
58782: PPUSH
58783: LD_VAR 0 2
58787: PPUSH
58788: EMPTY
58789: PPUSH
58790: CALL_OW 1
58794: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58795: LD_ADDR_EXP 64
58799: PUSH
58800: LD_EXP 64
58804: PPUSH
58805: LD_VAR 0 2
58809: PPUSH
58810: EMPTY
58811: PPUSH
58812: CALL_OW 1
58816: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58817: LD_ADDR_EXP 65
58821: PUSH
58822: LD_EXP 65
58826: PPUSH
58827: LD_VAR 0 2
58831: PPUSH
58832: EMPTY
58833: PPUSH
58834: CALL_OW 1
58838: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58839: LD_ADDR_EXP 66
58843: PUSH
58844: LD_EXP 66
58848: PPUSH
58849: LD_VAR 0 2
58853: PPUSH
58854: LD_EXP 58
58858: PUSH
58859: LD_VAR 0 2
58863: ARRAY
58864: PPUSH
58865: LD_INT 2
58867: PUSH
58868: LD_INT 30
58870: PUSH
58871: LD_INT 32
58873: PUSH
58874: EMPTY
58875: LIST
58876: LIST
58877: PUSH
58878: LD_INT 30
58880: PUSH
58881: LD_INT 33
58883: PUSH
58884: EMPTY
58885: LIST
58886: LIST
58887: PUSH
58888: EMPTY
58889: LIST
58890: LIST
58891: LIST
58892: PPUSH
58893: CALL_OW 72
58897: PPUSH
58898: CALL_OW 1
58902: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58903: LD_ADDR_EXP 67
58907: PUSH
58908: LD_EXP 67
58912: PPUSH
58913: LD_VAR 0 2
58917: PPUSH
58918: LD_EXP 58
58922: PUSH
58923: LD_VAR 0 2
58927: ARRAY
58928: PPUSH
58929: LD_INT 2
58931: PUSH
58932: LD_INT 30
58934: PUSH
58935: LD_INT 32
58937: PUSH
58938: EMPTY
58939: LIST
58940: LIST
58941: PUSH
58942: LD_INT 30
58944: PUSH
58945: LD_INT 31
58947: PUSH
58948: EMPTY
58949: LIST
58950: LIST
58951: PUSH
58952: EMPTY
58953: LIST
58954: LIST
58955: LIST
58956: PUSH
58957: LD_INT 58
58959: PUSH
58960: EMPTY
58961: LIST
58962: PUSH
58963: EMPTY
58964: LIST
58965: LIST
58966: PPUSH
58967: CALL_OW 72
58971: PPUSH
58972: CALL_OW 1
58976: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58977: LD_ADDR_EXP 68
58981: PUSH
58982: LD_EXP 68
58986: PPUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: EMPTY
58993: PPUSH
58994: CALL_OW 1
58998: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58999: LD_ADDR_EXP 72
59003: PUSH
59004: LD_EXP 72
59008: PPUSH
59009: LD_VAR 0 2
59013: PPUSH
59014: EMPTY
59015: PPUSH
59016: CALL_OW 1
59020: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59021: LD_ADDR_EXP 71
59025: PUSH
59026: LD_EXP 71
59030: PPUSH
59031: LD_VAR 0 2
59035: PPUSH
59036: EMPTY
59037: PPUSH
59038: CALL_OW 1
59042: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59043: LD_ADDR_EXP 73
59047: PUSH
59048: LD_EXP 73
59052: PPUSH
59053: LD_VAR 0 2
59057: PPUSH
59058: EMPTY
59059: PPUSH
59060: CALL_OW 1
59064: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59065: LD_ADDR_EXP 74
59069: PUSH
59070: LD_EXP 74
59074: PPUSH
59075: LD_VAR 0 2
59079: PPUSH
59080: EMPTY
59081: PPUSH
59082: CALL_OW 1
59086: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59087: LD_ADDR_EXP 75
59091: PUSH
59092: LD_EXP 75
59096: PPUSH
59097: LD_VAR 0 2
59101: PPUSH
59102: EMPTY
59103: PPUSH
59104: CALL_OW 1
59108: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59109: LD_ADDR_EXP 76
59113: PUSH
59114: LD_EXP 76
59118: PPUSH
59119: LD_VAR 0 2
59123: PPUSH
59124: EMPTY
59125: PPUSH
59126: CALL_OW 1
59130: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59131: LD_ADDR_EXP 77
59135: PUSH
59136: LD_EXP 77
59140: PPUSH
59141: LD_VAR 0 2
59145: PPUSH
59146: EMPTY
59147: PPUSH
59148: CALL_OW 1
59152: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59153: LD_ADDR_EXP 78
59157: PUSH
59158: LD_EXP 78
59162: PPUSH
59163: LD_VAR 0 2
59167: PPUSH
59168: EMPTY
59169: PPUSH
59170: CALL_OW 1
59174: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59175: LD_ADDR_EXP 79
59179: PUSH
59180: LD_EXP 79
59184: PPUSH
59185: LD_VAR 0 2
59189: PPUSH
59190: EMPTY
59191: PPUSH
59192: CALL_OW 1
59196: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59197: LD_ADDR_EXP 80
59201: PUSH
59202: LD_EXP 80
59206: PPUSH
59207: LD_VAR 0 2
59211: PPUSH
59212: EMPTY
59213: PPUSH
59214: CALL_OW 1
59218: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59219: LD_ADDR_EXP 69
59223: PUSH
59224: LD_EXP 69
59228: PPUSH
59229: LD_VAR 0 2
59233: PPUSH
59234: LD_INT 0
59236: PPUSH
59237: CALL_OW 1
59241: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59242: LD_ADDR_EXP 82
59246: PUSH
59247: LD_EXP 82
59251: PPUSH
59252: LD_VAR 0 2
59256: PPUSH
59257: LD_INT 0
59259: PPUSH
59260: CALL_OW 1
59264: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59265: LD_ADDR_EXP 70
59269: PUSH
59270: LD_EXP 70
59274: PPUSH
59275: LD_VAR 0 2
59279: PPUSH
59280: EMPTY
59281: PPUSH
59282: CALL_OW 1
59286: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59287: LD_ADDR_EXP 81
59291: PUSH
59292: LD_EXP 81
59296: PPUSH
59297: LD_VAR 0 2
59301: PPUSH
59302: LD_INT 0
59304: PPUSH
59305: CALL_OW 1
59309: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59310: LD_ADDR_EXP 83
59314: PUSH
59315: LD_EXP 83
59319: PPUSH
59320: LD_VAR 0 2
59324: PPUSH
59325: EMPTY
59326: PPUSH
59327: CALL_OW 1
59331: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59332: LD_ADDR_EXP 86
59336: PUSH
59337: LD_EXP 86
59341: PPUSH
59342: LD_VAR 0 2
59346: PPUSH
59347: LD_INT 0
59349: PPUSH
59350: CALL_OW 1
59354: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59355: LD_ADDR_EXP 87
59359: PUSH
59360: LD_EXP 87
59364: PPUSH
59365: LD_VAR 0 2
59369: PPUSH
59370: EMPTY
59371: PPUSH
59372: CALL_OW 1
59376: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59377: LD_ADDR_EXP 88
59381: PUSH
59382: LD_EXP 88
59386: PPUSH
59387: LD_VAR 0 2
59391: PPUSH
59392: EMPTY
59393: PPUSH
59394: CALL_OW 1
59398: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59399: LD_ADDR_EXP 89
59403: PUSH
59404: LD_EXP 89
59408: PPUSH
59409: LD_VAR 0 2
59413: PPUSH
59414: EMPTY
59415: PPUSH
59416: CALL_OW 1
59420: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59421: LD_ADDR_EXP 91
59425: PUSH
59426: LD_EXP 91
59430: PPUSH
59431: LD_VAR 0 2
59435: PPUSH
59436: LD_EXP 58
59440: PUSH
59441: LD_VAR 0 2
59445: ARRAY
59446: PPUSH
59447: LD_INT 2
59449: PUSH
59450: LD_INT 30
59452: PUSH
59453: LD_INT 6
59455: PUSH
59456: EMPTY
59457: LIST
59458: LIST
59459: PUSH
59460: LD_INT 30
59462: PUSH
59463: LD_INT 7
59465: PUSH
59466: EMPTY
59467: LIST
59468: LIST
59469: PUSH
59470: LD_INT 30
59472: PUSH
59473: LD_INT 8
59475: PUSH
59476: EMPTY
59477: LIST
59478: LIST
59479: PUSH
59480: EMPTY
59481: LIST
59482: LIST
59483: LIST
59484: LIST
59485: PPUSH
59486: CALL_OW 72
59490: PPUSH
59491: CALL_OW 1
59495: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59496: LD_ADDR_EXP 92
59500: PUSH
59501: LD_EXP 92
59505: PPUSH
59506: LD_VAR 0 2
59510: PPUSH
59511: EMPTY
59512: PPUSH
59513: CALL_OW 1
59517: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59518: LD_ADDR_EXP 93
59522: PUSH
59523: LD_EXP 93
59527: PPUSH
59528: LD_VAR 0 2
59532: PPUSH
59533: EMPTY
59534: PPUSH
59535: CALL_OW 1
59539: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59540: LD_ADDR_EXP 94
59544: PUSH
59545: LD_EXP 94
59549: PPUSH
59550: LD_VAR 0 2
59554: PPUSH
59555: EMPTY
59556: PPUSH
59557: CALL_OW 1
59561: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59562: LD_ADDR_EXP 95
59566: PUSH
59567: LD_EXP 95
59571: PPUSH
59572: LD_VAR 0 2
59576: PPUSH
59577: EMPTY
59578: PPUSH
59579: CALL_OW 1
59583: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59584: LD_ADDR_EXP 96
59588: PUSH
59589: LD_EXP 96
59593: PPUSH
59594: LD_VAR 0 2
59598: PPUSH
59599: EMPTY
59600: PPUSH
59601: CALL_OW 1
59605: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59606: LD_ADDR_EXP 97
59610: PUSH
59611: LD_EXP 97
59615: PPUSH
59616: LD_VAR 0 2
59620: PPUSH
59621: EMPTY
59622: PPUSH
59623: CALL_OW 1
59627: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59628: LD_ADDR_EXP 98
59632: PUSH
59633: LD_EXP 98
59637: PPUSH
59638: LD_VAR 0 2
59642: PPUSH
59643: EMPTY
59644: PPUSH
59645: CALL_OW 1
59649: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59650: LD_ADDR_EXP 99
59654: PUSH
59655: LD_EXP 99
59659: PPUSH
59660: LD_VAR 0 2
59664: PPUSH
59665: EMPTY
59666: PPUSH
59667: CALL_OW 1
59671: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59672: LD_ADDR_EXP 100
59676: PUSH
59677: LD_EXP 100
59681: PPUSH
59682: LD_VAR 0 2
59686: PPUSH
59687: LD_INT 0
59689: PPUSH
59690: CALL_OW 1
59694: ST_TO_ADDR
// end ;
59695: GO 58619
59697: POP
59698: POP
// MC_InitSides ( ) ;
59699: CALL 59985 0 0
// MC_InitResearch ( ) ;
59703: CALL 59724 0 0
// CustomInitMacro ( ) ;
59707: CALL 181 0 0
// skirmish := true ;
59711: LD_ADDR_EXP 56
59715: PUSH
59716: LD_INT 1
59718: ST_TO_ADDR
// end ;
59719: LD_VAR 0 1
59723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59724: LD_INT 0
59726: PPUSH
59727: PPUSH
59728: PPUSH
59729: PPUSH
59730: PPUSH
59731: PPUSH
// if not mc_bases then
59732: LD_EXP 58
59736: NOT
59737: IFFALSE 59741
// exit ;
59739: GO 59980
// for i = 1 to 8 do
59741: LD_ADDR_VAR 0 2
59745: PUSH
59746: DOUBLE
59747: LD_INT 1
59749: DEC
59750: ST_TO_ADDR
59751: LD_INT 8
59753: PUSH
59754: FOR_TO
59755: IFFALSE 59781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59757: LD_ADDR_EXP 85
59761: PUSH
59762: LD_EXP 85
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
59779: GO 59754
59781: POP
59782: POP
// tmp := [ ] ;
59783: LD_ADDR_VAR 0 5
59787: PUSH
59788: EMPTY
59789: ST_TO_ADDR
// for i = 1 to mc_sides do
59790: LD_ADDR_VAR 0 2
59794: PUSH
59795: DOUBLE
59796: LD_INT 1
59798: DEC
59799: ST_TO_ADDR
59800: LD_EXP 84
59804: PUSH
59805: FOR_TO
59806: IFFALSE 59864
// if not mc_sides [ i ] in tmp then
59808: LD_EXP 84
59812: PUSH
59813: LD_VAR 0 2
59817: ARRAY
59818: PUSH
59819: LD_VAR 0 5
59823: IN
59824: NOT
59825: IFFALSE 59862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59827: LD_ADDR_VAR 0 5
59831: PUSH
59832: LD_VAR 0 5
59836: PPUSH
59837: LD_VAR 0 5
59841: PUSH
59842: LD_INT 1
59844: PLUS
59845: PPUSH
59846: LD_EXP 84
59850: PUSH
59851: LD_VAR 0 2
59855: ARRAY
59856: PPUSH
59857: CALL_OW 2
59861: ST_TO_ADDR
59862: GO 59805
59864: POP
59865: POP
// if not tmp then
59866: LD_VAR 0 5
59870: NOT
59871: IFFALSE 59875
// exit ;
59873: GO 59980
// for j in tmp do
59875: LD_ADDR_VAR 0 3
59879: PUSH
59880: LD_VAR 0 5
59884: PUSH
59885: FOR_IN
59886: IFFALSE 59978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59888: LD_ADDR_VAR 0 6
59892: PUSH
59893: LD_INT 22
59895: PUSH
59896: LD_VAR 0 3
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PPUSH
59905: CALL_OW 69
59909: ST_TO_ADDR
// if not un then
59910: LD_VAR 0 6
59914: NOT
59915: IFFALSE 59919
// continue ;
59917: GO 59885
// nation := GetNation ( un [ 1 ] ) ;
59919: LD_ADDR_VAR 0 4
59923: PUSH
59924: LD_VAR 0 6
59928: PUSH
59929: LD_INT 1
59931: ARRAY
59932: PPUSH
59933: CALL_OW 248
59937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59938: LD_ADDR_EXP 85
59942: PUSH
59943: LD_EXP 85
59947: PPUSH
59948: LD_VAR 0 3
59952: PPUSH
59953: LD_VAR 0 3
59957: PPUSH
59958: LD_VAR 0 4
59962: PPUSH
59963: LD_INT 1
59965: PPUSH
59966: CALL 13980 0 3
59970: PPUSH
59971: CALL_OW 1
59975: ST_TO_ADDR
// end ;
59976: GO 59885
59978: POP
59979: POP
// end ;
59980: LD_VAR 0 1
59984: RET
// export function MC_InitSides ( ) ; var i ; begin
59985: LD_INT 0
59987: PPUSH
59988: PPUSH
// if not mc_bases then
59989: LD_EXP 58
59993: NOT
59994: IFFALSE 59998
// exit ;
59996: GO 60072
// for i = 1 to mc_bases do
59998: LD_ADDR_VAR 0 2
60002: PUSH
60003: DOUBLE
60004: LD_INT 1
60006: DEC
60007: ST_TO_ADDR
60008: LD_EXP 58
60012: PUSH
60013: FOR_TO
60014: IFFALSE 60070
// if mc_bases [ i ] then
60016: LD_EXP 58
60020: PUSH
60021: LD_VAR 0 2
60025: ARRAY
60026: IFFALSE 60068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60028: LD_ADDR_EXP 84
60032: PUSH
60033: LD_EXP 84
60037: PPUSH
60038: LD_VAR 0 2
60042: PPUSH
60043: LD_EXP 58
60047: PUSH
60048: LD_VAR 0 2
60052: ARRAY
60053: PUSH
60054: LD_INT 1
60056: ARRAY
60057: PPUSH
60058: CALL_OW 255
60062: PPUSH
60063: CALL_OW 1
60067: ST_TO_ADDR
60068: GO 60013
60070: POP
60071: POP
// end ;
60072: LD_VAR 0 1
60076: RET
// every 0 0$01 trigger skirmish do
60077: LD_EXP 56
60081: IFFALSE 60235
60083: GO 60085
60085: DISABLE
// begin enable ;
60086: ENABLE
// MC_CheckBuildings ( ) ;
60087: CALL 64724 0 0
// MC_CheckPeopleLife ( ) ;
60091: CALL 64849 0 0
// RaiseSailEvent ( 100 ) ;
60095: LD_INT 100
60097: PPUSH
60098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60102: LD_INT 103
60104: PPUSH
60105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60109: LD_INT 104
60111: PPUSH
60112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60116: LD_INT 105
60118: PPUSH
60119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60123: LD_INT 106
60125: PPUSH
60126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60130: LD_INT 107
60132: PPUSH
60133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60137: LD_INT 108
60139: PPUSH
60140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60144: LD_INT 109
60146: PPUSH
60147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60151: LD_INT 110
60153: PPUSH
60154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60158: LD_INT 111
60160: PPUSH
60161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60165: LD_INT 112
60167: PPUSH
60168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60172: LD_INT 113
60174: PPUSH
60175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60179: LD_INT 120
60181: PPUSH
60182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60186: LD_INT 121
60188: PPUSH
60189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60193: LD_INT 122
60195: PPUSH
60196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60200: LD_INT 123
60202: PPUSH
60203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60207: LD_INT 124
60209: PPUSH
60210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60214: LD_INT 125
60216: PPUSH
60217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60221: LD_INT 126
60223: PPUSH
60224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60228: LD_INT 200
60230: PPUSH
60231: CALL_OW 427
// end ;
60235: END
// on SailEvent ( event ) do begin if event < 100 then
60236: LD_VAR 0 1
60240: PUSH
60241: LD_INT 100
60243: LESS
60244: IFFALSE 60255
// CustomEvent ( event ) ;
60246: LD_VAR 0 1
60250: PPUSH
60251: CALL 12694 0 1
// if event = 100 then
60255: LD_VAR 0 1
60259: PUSH
60260: LD_INT 100
60262: EQUAL
60263: IFFALSE 60269
// MC_ClassManager ( ) ;
60265: CALL 60661 0 0
// if event = 101 then
60269: LD_VAR 0 1
60273: PUSH
60274: LD_INT 101
60276: EQUAL
60277: IFFALSE 60283
// MC_RepairBuildings ( ) ;
60279: CALL 65445 0 0
// if event = 102 then
60283: LD_VAR 0 1
60287: PUSH
60288: LD_INT 102
60290: EQUAL
60291: IFFALSE 60297
// MC_Heal ( ) ;
60293: CALL 65851 0 0
// if event = 103 then
60297: LD_VAR 0 1
60301: PUSH
60302: LD_INT 103
60304: EQUAL
60305: IFFALSE 60311
// MC_Build ( ) ;
60307: CALL 66273 0 0
// if event = 104 then
60311: LD_VAR 0 1
60315: PUSH
60316: LD_INT 104
60318: EQUAL
60319: IFFALSE 60325
// MC_TurretWeapon ( ) ;
60321: CALL 67886 0 0
// if event = 105 then
60325: LD_VAR 0 1
60329: PUSH
60330: LD_INT 105
60332: EQUAL
60333: IFFALSE 60339
// MC_BuildUpgrade ( ) ;
60335: CALL 67437 0 0
// if event = 106 then
60339: LD_VAR 0 1
60343: PUSH
60344: LD_INT 106
60346: EQUAL
60347: IFFALSE 60353
// MC_PlantMines ( ) ;
60349: CALL 68316 0 0
// if event = 107 then
60353: LD_VAR 0 1
60357: PUSH
60358: LD_INT 107
60360: EQUAL
60361: IFFALSE 60367
// MC_CollectCrates ( ) ;
60363: CALL 69350 0 0
// if event = 108 then
60367: LD_VAR 0 1
60371: PUSH
60372: LD_INT 108
60374: EQUAL
60375: IFFALSE 60381
// MC_LinkRemoteControl ( ) ;
60377: CALL 71107 0 0
// if event = 109 then
60381: LD_VAR 0 1
60385: PUSH
60386: LD_INT 109
60388: EQUAL
60389: IFFALSE 60395
// MC_ProduceVehicle ( ) ;
60391: CALL 71288 0 0
// if event = 110 then
60395: LD_VAR 0 1
60399: PUSH
60400: LD_INT 110
60402: EQUAL
60403: IFFALSE 60409
// MC_SendAttack ( ) ;
60405: CALL 71769 0 0
// if event = 111 then
60409: LD_VAR 0 1
60413: PUSH
60414: LD_INT 111
60416: EQUAL
60417: IFFALSE 60423
// MC_Defend ( ) ;
60419: CALL 71877 0 0
// if event = 112 then
60423: LD_VAR 0 1
60427: PUSH
60428: LD_INT 112
60430: EQUAL
60431: IFFALSE 60437
// MC_Research ( ) ;
60433: CALL 72504 0 0
// if event = 113 then
60437: LD_VAR 0 1
60441: PUSH
60442: LD_INT 113
60444: EQUAL
60445: IFFALSE 60451
// MC_MinesTrigger ( ) ;
60447: CALL 73618 0 0
// if event = 120 then
60451: LD_VAR 0 1
60455: PUSH
60456: LD_INT 120
60458: EQUAL
60459: IFFALSE 60465
// MC_RepairVehicle ( ) ;
60461: CALL 73717 0 0
// if event = 121 then
60465: LD_VAR 0 1
60469: PUSH
60470: LD_INT 121
60472: EQUAL
60473: IFFALSE 60479
// MC_TameApe ( ) ;
60475: CALL 74460 0 0
// if event = 122 then
60479: LD_VAR 0 1
60483: PUSH
60484: LD_INT 122
60486: EQUAL
60487: IFFALSE 60493
// MC_ChangeApeClass ( ) ;
60489: CALL 75289 0 0
// if event = 123 then
60493: LD_VAR 0 1
60497: PUSH
60498: LD_INT 123
60500: EQUAL
60501: IFFALSE 60507
// MC_Bazooka ( ) ;
60503: CALL 75939 0 0
// if event = 124 then
60507: LD_VAR 0 1
60511: PUSH
60512: LD_INT 124
60514: EQUAL
60515: IFFALSE 60521
// MC_TeleportExit ( ) ;
60517: CALL 76137 0 0
// if event = 125 then
60521: LD_VAR 0 1
60525: PUSH
60526: LD_INT 125
60528: EQUAL
60529: IFFALSE 60535
// MC_Deposits ( ) ;
60531: CALL 76784 0 0
// if event = 126 then
60535: LD_VAR 0 1
60539: PUSH
60540: LD_INT 126
60542: EQUAL
60543: IFFALSE 60549
// MC_RemoteDriver ( ) ;
60545: CALL 77409 0 0
// if event = 200 then
60549: LD_VAR 0 1
60553: PUSH
60554: LD_INT 200
60556: EQUAL
60557: IFFALSE 60563
// MC_Idle ( ) ;
60559: CALL 79142 0 0
// end ;
60563: PPOPN 1
60565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60566: LD_INT 0
60568: PPUSH
60569: PPUSH
// if not mc_bases [ base ] or not tag then
60570: LD_EXP 58
60574: PUSH
60575: LD_VAR 0 1
60579: ARRAY
60580: NOT
60581: PUSH
60582: LD_VAR 0 2
60586: NOT
60587: OR
60588: IFFALSE 60592
// exit ;
60590: GO 60656
// for i in mc_bases [ base ] union mc_ape [ base ] do
60592: LD_ADDR_VAR 0 4
60596: PUSH
60597: LD_EXP 58
60601: PUSH
60602: LD_VAR 0 1
60606: ARRAY
60607: PUSH
60608: LD_EXP 87
60612: PUSH
60613: LD_VAR 0 1
60617: ARRAY
60618: UNION
60619: PUSH
60620: FOR_IN
60621: IFFALSE 60654
// if GetTag ( i ) = tag then
60623: LD_VAR 0 4
60627: PPUSH
60628: CALL_OW 110
60632: PUSH
60633: LD_VAR 0 2
60637: EQUAL
60638: IFFALSE 60652
// SetTag ( i , 0 ) ;
60640: LD_VAR 0 4
60644: PPUSH
60645: LD_INT 0
60647: PPUSH
60648: CALL_OW 109
60652: GO 60620
60654: POP
60655: POP
// end ;
60656: LD_VAR 0 3
60660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60661: LD_INT 0
60663: PPUSH
60664: PPUSH
60665: PPUSH
60666: PPUSH
60667: PPUSH
60668: PPUSH
60669: PPUSH
60670: PPUSH
// if not mc_bases then
60671: LD_EXP 58
60675: NOT
60676: IFFALSE 60680
// exit ;
60678: GO 61138
// for i = 1 to mc_bases do
60680: LD_ADDR_VAR 0 2
60684: PUSH
60685: DOUBLE
60686: LD_INT 1
60688: DEC
60689: ST_TO_ADDR
60690: LD_EXP 58
60694: PUSH
60695: FOR_TO
60696: IFFALSE 61136
// begin tmp := MC_ClassCheckReq ( i ) ;
60698: LD_ADDR_VAR 0 4
60702: PUSH
60703: LD_VAR 0 2
60707: PPUSH
60708: CALL 61143 0 1
60712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60713: LD_ADDR_EXP 99
60717: PUSH
60718: LD_EXP 99
60722: PPUSH
60723: LD_VAR 0 2
60727: PPUSH
60728: LD_VAR 0 4
60732: PPUSH
60733: CALL_OW 1
60737: ST_TO_ADDR
// if not tmp then
60738: LD_VAR 0 4
60742: NOT
60743: IFFALSE 60747
// continue ;
60745: GO 60695
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60747: LD_ADDR_VAR 0 6
60751: PUSH
60752: LD_EXP 58
60756: PUSH
60757: LD_VAR 0 2
60761: ARRAY
60762: PPUSH
60763: LD_INT 2
60765: PUSH
60766: LD_INT 30
60768: PUSH
60769: LD_INT 4
60771: PUSH
60772: EMPTY
60773: LIST
60774: LIST
60775: PUSH
60776: LD_INT 30
60778: PUSH
60779: LD_INT 5
60781: PUSH
60782: EMPTY
60783: LIST
60784: LIST
60785: PUSH
60786: EMPTY
60787: LIST
60788: LIST
60789: LIST
60790: PPUSH
60791: CALL_OW 72
60795: PUSH
60796: LD_EXP 58
60800: PUSH
60801: LD_VAR 0 2
60805: ARRAY
60806: PPUSH
60807: LD_INT 2
60809: PUSH
60810: LD_INT 30
60812: PUSH
60813: LD_INT 0
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: PUSH
60820: LD_INT 30
60822: PUSH
60823: LD_INT 1
60825: PUSH
60826: EMPTY
60827: LIST
60828: LIST
60829: PUSH
60830: EMPTY
60831: LIST
60832: LIST
60833: LIST
60834: PPUSH
60835: CALL_OW 72
60839: PUSH
60840: LD_EXP 58
60844: PUSH
60845: LD_VAR 0 2
60849: ARRAY
60850: PPUSH
60851: LD_INT 30
60853: PUSH
60854: LD_INT 3
60856: PUSH
60857: EMPTY
60858: LIST
60859: LIST
60860: PPUSH
60861: CALL_OW 72
60865: PUSH
60866: LD_EXP 58
60870: PUSH
60871: LD_VAR 0 2
60875: ARRAY
60876: PPUSH
60877: LD_INT 2
60879: PUSH
60880: LD_INT 30
60882: PUSH
60883: LD_INT 6
60885: PUSH
60886: EMPTY
60887: LIST
60888: LIST
60889: PUSH
60890: LD_INT 30
60892: PUSH
60893: LD_INT 7
60895: PUSH
60896: EMPTY
60897: LIST
60898: LIST
60899: PUSH
60900: LD_INT 30
60902: PUSH
60903: LD_INT 8
60905: PUSH
60906: EMPTY
60907: LIST
60908: LIST
60909: PUSH
60910: EMPTY
60911: LIST
60912: LIST
60913: LIST
60914: LIST
60915: PPUSH
60916: CALL_OW 72
60920: PUSH
60921: EMPTY
60922: LIST
60923: LIST
60924: LIST
60925: LIST
60926: ST_TO_ADDR
// for j = 1 to 4 do
60927: LD_ADDR_VAR 0 3
60931: PUSH
60932: DOUBLE
60933: LD_INT 1
60935: DEC
60936: ST_TO_ADDR
60937: LD_INT 4
60939: PUSH
60940: FOR_TO
60941: IFFALSE 61132
// begin if not tmp [ j ] then
60943: LD_VAR 0 4
60947: PUSH
60948: LD_VAR 0 3
60952: ARRAY
60953: NOT
60954: IFFALSE 60958
// continue ;
60956: GO 60940
// for p in tmp [ j ] do
60958: LD_ADDR_VAR 0 5
60962: PUSH
60963: LD_VAR 0 4
60967: PUSH
60968: LD_VAR 0 3
60972: ARRAY
60973: PUSH
60974: FOR_IN
60975: IFFALSE 61128
// begin if not b [ j ] then
60977: LD_VAR 0 6
60981: PUSH
60982: LD_VAR 0 3
60986: ARRAY
60987: NOT
60988: IFFALSE 60992
// break ;
60990: GO 61128
// e := 0 ;
60992: LD_ADDR_VAR 0 7
60996: PUSH
60997: LD_INT 0
60999: ST_TO_ADDR
// for k in b [ j ] do
61000: LD_ADDR_VAR 0 8
61004: PUSH
61005: LD_VAR 0 6
61009: PUSH
61010: LD_VAR 0 3
61014: ARRAY
61015: PUSH
61016: FOR_IN
61017: IFFALSE 61044
// if IsNotFull ( k ) then
61019: LD_VAR 0 8
61023: PPUSH
61024: CALL 18006 0 1
61028: IFFALSE 61042
// begin e := k ;
61030: LD_ADDR_VAR 0 7
61034: PUSH
61035: LD_VAR 0 8
61039: ST_TO_ADDR
// break ;
61040: GO 61044
// end ;
61042: GO 61016
61044: POP
61045: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61046: LD_VAR 0 7
61050: PUSH
61051: LD_VAR 0 5
61055: PPUSH
61056: LD_VAR 0 7
61060: PPUSH
61061: CALL 55033 0 2
61065: NOT
61066: AND
61067: IFFALSE 61126
// begin if IsInUnit ( p ) then
61069: LD_VAR 0 5
61073: PPUSH
61074: CALL_OW 310
61078: IFFALSE 61089
// ComExitBuilding ( p ) ;
61080: LD_VAR 0 5
61084: PPUSH
61085: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61089: LD_VAR 0 5
61093: PPUSH
61094: LD_VAR 0 7
61098: PPUSH
61099: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61103: LD_VAR 0 5
61107: PPUSH
61108: LD_VAR 0 3
61112: PPUSH
61113: CALL_OW 183
// AddComExitBuilding ( p ) ;
61117: LD_VAR 0 5
61121: PPUSH
61122: CALL_OW 182
// end ; end ;
61126: GO 60974
61128: POP
61129: POP
// end ;
61130: GO 60940
61132: POP
61133: POP
// end ;
61134: GO 60695
61136: POP
61137: POP
// end ;
61138: LD_VAR 0 1
61142: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61143: LD_INT 0
61145: PPUSH
61146: PPUSH
61147: PPUSH
61148: PPUSH
61149: PPUSH
61150: PPUSH
61151: PPUSH
61152: PPUSH
61153: PPUSH
61154: PPUSH
61155: PPUSH
61156: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61157: LD_VAR 0 1
61161: NOT
61162: PUSH
61163: LD_EXP 58
61167: PUSH
61168: LD_VAR 0 1
61172: ARRAY
61173: NOT
61174: OR
61175: PUSH
61176: LD_EXP 58
61180: PUSH
61181: LD_VAR 0 1
61185: ARRAY
61186: PPUSH
61187: LD_INT 2
61189: PUSH
61190: LD_INT 30
61192: PUSH
61193: LD_INT 0
61195: PUSH
61196: EMPTY
61197: LIST
61198: LIST
61199: PUSH
61200: LD_INT 30
61202: PUSH
61203: LD_INT 1
61205: PUSH
61206: EMPTY
61207: LIST
61208: LIST
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: LIST
61214: PPUSH
61215: CALL_OW 72
61219: NOT
61220: OR
61221: IFFALSE 61225
// exit ;
61223: GO 64719
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61225: LD_ADDR_VAR 0 4
61229: PUSH
61230: LD_EXP 58
61234: PUSH
61235: LD_VAR 0 1
61239: ARRAY
61240: PPUSH
61241: LD_INT 2
61243: PUSH
61244: LD_INT 25
61246: PUSH
61247: LD_INT 1
61249: PUSH
61250: EMPTY
61251: LIST
61252: LIST
61253: PUSH
61254: LD_INT 25
61256: PUSH
61257: LD_INT 2
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 25
61266: PUSH
61267: LD_INT 3
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: LD_INT 25
61276: PUSH
61277: LD_INT 4
61279: PUSH
61280: EMPTY
61281: LIST
61282: LIST
61283: PUSH
61284: LD_INT 25
61286: PUSH
61287: LD_INT 5
61289: PUSH
61290: EMPTY
61291: LIST
61292: LIST
61293: PUSH
61294: LD_INT 25
61296: PUSH
61297: LD_INT 8
61299: PUSH
61300: EMPTY
61301: LIST
61302: LIST
61303: PUSH
61304: LD_INT 25
61306: PUSH
61307: LD_INT 9
61309: PUSH
61310: EMPTY
61311: LIST
61312: LIST
61313: PUSH
61314: EMPTY
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: PPUSH
61324: CALL_OW 72
61328: ST_TO_ADDR
// for i in tmp do
61329: LD_ADDR_VAR 0 3
61333: PUSH
61334: LD_VAR 0 4
61338: PUSH
61339: FOR_IN
61340: IFFALSE 61371
// if GetTag ( i ) then
61342: LD_VAR 0 3
61346: PPUSH
61347: CALL_OW 110
61351: IFFALSE 61369
// tmp := tmp diff i ;
61353: LD_ADDR_VAR 0 4
61357: PUSH
61358: LD_VAR 0 4
61362: PUSH
61363: LD_VAR 0 3
61367: DIFF
61368: ST_TO_ADDR
61369: GO 61339
61371: POP
61372: POP
// if not tmp then
61373: LD_VAR 0 4
61377: NOT
61378: IFFALSE 61382
// exit ;
61380: GO 64719
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61382: LD_ADDR_VAR 0 5
61386: PUSH
61387: LD_EXP 58
61391: PUSH
61392: LD_VAR 0 1
61396: ARRAY
61397: PPUSH
61398: LD_INT 2
61400: PUSH
61401: LD_INT 25
61403: PUSH
61404: LD_INT 1
61406: PUSH
61407: EMPTY
61408: LIST
61409: LIST
61410: PUSH
61411: LD_INT 25
61413: PUSH
61414: LD_INT 5
61416: PUSH
61417: EMPTY
61418: LIST
61419: LIST
61420: PUSH
61421: LD_INT 25
61423: PUSH
61424: LD_INT 8
61426: PUSH
61427: EMPTY
61428: LIST
61429: LIST
61430: PUSH
61431: LD_INT 25
61433: PUSH
61434: LD_INT 9
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: LIST
61445: LIST
61446: LIST
61447: PPUSH
61448: CALL_OW 72
61452: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61453: LD_ADDR_VAR 0 6
61457: PUSH
61458: LD_EXP 58
61462: PUSH
61463: LD_VAR 0 1
61467: ARRAY
61468: PPUSH
61469: LD_INT 25
61471: PUSH
61472: LD_INT 2
61474: PUSH
61475: EMPTY
61476: LIST
61477: LIST
61478: PPUSH
61479: CALL_OW 72
61483: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61484: LD_ADDR_VAR 0 7
61488: PUSH
61489: LD_EXP 58
61493: PUSH
61494: LD_VAR 0 1
61498: ARRAY
61499: PPUSH
61500: LD_INT 25
61502: PUSH
61503: LD_INT 3
61505: PUSH
61506: EMPTY
61507: LIST
61508: LIST
61509: PPUSH
61510: CALL_OW 72
61514: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61515: LD_ADDR_VAR 0 8
61519: PUSH
61520: LD_EXP 58
61524: PUSH
61525: LD_VAR 0 1
61529: ARRAY
61530: PPUSH
61531: LD_INT 25
61533: PUSH
61534: LD_INT 4
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: PUSH
61541: LD_INT 24
61543: PUSH
61544: LD_INT 251
61546: PUSH
61547: EMPTY
61548: LIST
61549: LIST
61550: PUSH
61551: EMPTY
61552: LIST
61553: LIST
61554: PPUSH
61555: CALL_OW 72
61559: ST_TO_ADDR
// if mc_scan [ base ] then
61560: LD_EXP 81
61564: PUSH
61565: LD_VAR 0 1
61569: ARRAY
61570: IFFALSE 62031
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61572: LD_ADDR_EXP 100
61576: PUSH
61577: LD_EXP 100
61581: PPUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: LD_INT 4
61589: PPUSH
61590: CALL_OW 1
61594: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61595: LD_ADDR_VAR 0 12
61599: PUSH
61600: LD_EXP 58
61604: PUSH
61605: LD_VAR 0 1
61609: ARRAY
61610: PPUSH
61611: LD_INT 2
61613: PUSH
61614: LD_INT 30
61616: PUSH
61617: LD_INT 4
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: PUSH
61624: LD_INT 30
61626: PUSH
61627: LD_INT 5
61629: PUSH
61630: EMPTY
61631: LIST
61632: LIST
61633: PUSH
61634: EMPTY
61635: LIST
61636: LIST
61637: LIST
61638: PPUSH
61639: CALL_OW 72
61643: ST_TO_ADDR
// if not b then
61644: LD_VAR 0 12
61648: NOT
61649: IFFALSE 61653
// exit ;
61651: GO 64719
// p := [ ] ;
61653: LD_ADDR_VAR 0 11
61657: PUSH
61658: EMPTY
61659: ST_TO_ADDR
// if sci >= 2 then
61660: LD_VAR 0 8
61664: PUSH
61665: LD_INT 2
61667: GREATEREQUAL
61668: IFFALSE 61699
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61670: LD_ADDR_VAR 0 8
61674: PUSH
61675: LD_VAR 0 8
61679: PUSH
61680: LD_INT 1
61682: ARRAY
61683: PUSH
61684: LD_VAR 0 8
61688: PUSH
61689: LD_INT 2
61691: ARRAY
61692: PUSH
61693: EMPTY
61694: LIST
61695: LIST
61696: ST_TO_ADDR
61697: GO 61760
// if sci = 1 then
61699: LD_VAR 0 8
61703: PUSH
61704: LD_INT 1
61706: EQUAL
61707: IFFALSE 61728
// sci := [ sci [ 1 ] ] else
61709: LD_ADDR_VAR 0 8
61713: PUSH
61714: LD_VAR 0 8
61718: PUSH
61719: LD_INT 1
61721: ARRAY
61722: PUSH
61723: EMPTY
61724: LIST
61725: ST_TO_ADDR
61726: GO 61760
// if sci = 0 then
61728: LD_VAR 0 8
61732: PUSH
61733: LD_INT 0
61735: EQUAL
61736: IFFALSE 61760
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61738: LD_ADDR_VAR 0 11
61742: PUSH
61743: LD_VAR 0 4
61747: PPUSH
61748: LD_INT 4
61750: PPUSH
61751: CALL 54896 0 2
61755: PUSH
61756: LD_INT 1
61758: ARRAY
61759: ST_TO_ADDR
// if eng > 4 then
61760: LD_VAR 0 6
61764: PUSH
61765: LD_INT 4
61767: GREATER
61768: IFFALSE 61814
// for i = eng downto 4 do
61770: LD_ADDR_VAR 0 3
61774: PUSH
61775: DOUBLE
61776: LD_VAR 0 6
61780: INC
61781: ST_TO_ADDR
61782: LD_INT 4
61784: PUSH
61785: FOR_DOWNTO
61786: IFFALSE 61812
// eng := eng diff eng [ i ] ;
61788: LD_ADDR_VAR 0 6
61792: PUSH
61793: LD_VAR 0 6
61797: PUSH
61798: LD_VAR 0 6
61802: PUSH
61803: LD_VAR 0 3
61807: ARRAY
61808: DIFF
61809: ST_TO_ADDR
61810: GO 61785
61812: POP
61813: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61814: LD_ADDR_VAR 0 4
61818: PUSH
61819: LD_VAR 0 4
61823: PUSH
61824: LD_VAR 0 5
61828: PUSH
61829: LD_VAR 0 6
61833: UNION
61834: PUSH
61835: LD_VAR 0 7
61839: UNION
61840: PUSH
61841: LD_VAR 0 8
61845: UNION
61846: DIFF
61847: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61848: LD_ADDR_VAR 0 13
61852: PUSH
61853: LD_EXP 58
61857: PUSH
61858: LD_VAR 0 1
61862: ARRAY
61863: PPUSH
61864: LD_INT 2
61866: PUSH
61867: LD_INT 30
61869: PUSH
61870: LD_INT 32
61872: PUSH
61873: EMPTY
61874: LIST
61875: LIST
61876: PUSH
61877: LD_INT 30
61879: PUSH
61880: LD_INT 31
61882: PUSH
61883: EMPTY
61884: LIST
61885: LIST
61886: PUSH
61887: EMPTY
61888: LIST
61889: LIST
61890: LIST
61891: PPUSH
61892: CALL_OW 72
61896: PUSH
61897: LD_EXP 58
61901: PUSH
61902: LD_VAR 0 1
61906: ARRAY
61907: PPUSH
61908: LD_INT 2
61910: PUSH
61911: LD_INT 30
61913: PUSH
61914: LD_INT 4
61916: PUSH
61917: EMPTY
61918: LIST
61919: LIST
61920: PUSH
61921: LD_INT 30
61923: PUSH
61924: LD_INT 5
61926: PUSH
61927: EMPTY
61928: LIST
61929: LIST
61930: PUSH
61931: EMPTY
61932: LIST
61933: LIST
61934: LIST
61935: PPUSH
61936: CALL_OW 72
61940: PUSH
61941: LD_INT 6
61943: MUL
61944: PLUS
61945: ST_TO_ADDR
// if bcount < tmp then
61946: LD_VAR 0 13
61950: PUSH
61951: LD_VAR 0 4
61955: LESS
61956: IFFALSE 62002
// for i = tmp downto bcount do
61958: LD_ADDR_VAR 0 3
61962: PUSH
61963: DOUBLE
61964: LD_VAR 0 4
61968: INC
61969: ST_TO_ADDR
61970: LD_VAR 0 13
61974: PUSH
61975: FOR_DOWNTO
61976: IFFALSE 62000
// tmp := Delete ( tmp , tmp ) ;
61978: LD_ADDR_VAR 0 4
61982: PUSH
61983: LD_VAR 0 4
61987: PPUSH
61988: LD_VAR 0 4
61992: PPUSH
61993: CALL_OW 3
61997: ST_TO_ADDR
61998: GO 61975
62000: POP
62001: POP
// result := [ tmp , 0 , 0 , p ] ;
62002: LD_ADDR_VAR 0 2
62006: PUSH
62007: LD_VAR 0 4
62011: PUSH
62012: LD_INT 0
62014: PUSH
62015: LD_INT 0
62017: PUSH
62018: LD_VAR 0 11
62022: PUSH
62023: EMPTY
62024: LIST
62025: LIST
62026: LIST
62027: LIST
62028: ST_TO_ADDR
// exit ;
62029: GO 64719
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62031: LD_EXP 58
62035: PUSH
62036: LD_VAR 0 1
62040: ARRAY
62041: PPUSH
62042: LD_INT 2
62044: PUSH
62045: LD_INT 30
62047: PUSH
62048: LD_INT 6
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: PUSH
62055: LD_INT 30
62057: PUSH
62058: LD_INT 7
62060: PUSH
62061: EMPTY
62062: LIST
62063: LIST
62064: PUSH
62065: LD_INT 30
62067: PUSH
62068: LD_INT 8
62070: PUSH
62071: EMPTY
62072: LIST
62073: LIST
62074: PUSH
62075: EMPTY
62076: LIST
62077: LIST
62078: LIST
62079: LIST
62080: PPUSH
62081: CALL_OW 72
62085: NOT
62086: PUSH
62087: LD_EXP 58
62091: PUSH
62092: LD_VAR 0 1
62096: ARRAY
62097: PPUSH
62098: LD_INT 30
62100: PUSH
62101: LD_INT 3
62103: PUSH
62104: EMPTY
62105: LIST
62106: LIST
62107: PPUSH
62108: CALL_OW 72
62112: NOT
62113: AND
62114: IFFALSE 62186
// begin if eng = tmp then
62116: LD_VAR 0 6
62120: PUSH
62121: LD_VAR 0 4
62125: EQUAL
62126: IFFALSE 62130
// exit ;
62128: GO 64719
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62130: LD_ADDR_EXP 100
62134: PUSH
62135: LD_EXP 100
62139: PPUSH
62140: LD_VAR 0 1
62144: PPUSH
62145: LD_INT 1
62147: PPUSH
62148: CALL_OW 1
62152: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62153: LD_ADDR_VAR 0 2
62157: PUSH
62158: LD_INT 0
62160: PUSH
62161: LD_VAR 0 4
62165: PUSH
62166: LD_VAR 0 6
62170: DIFF
62171: PUSH
62172: LD_INT 0
62174: PUSH
62175: LD_INT 0
62177: PUSH
62178: EMPTY
62179: LIST
62180: LIST
62181: LIST
62182: LIST
62183: ST_TO_ADDR
// exit ;
62184: GO 64719
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62186: LD_EXP 85
62190: PUSH
62191: LD_EXP 84
62195: PUSH
62196: LD_VAR 0 1
62200: ARRAY
62201: ARRAY
62202: PUSH
62203: LD_EXP 58
62207: PUSH
62208: LD_VAR 0 1
62212: ARRAY
62213: PPUSH
62214: LD_INT 2
62216: PUSH
62217: LD_INT 30
62219: PUSH
62220: LD_INT 6
62222: PUSH
62223: EMPTY
62224: LIST
62225: LIST
62226: PUSH
62227: LD_INT 30
62229: PUSH
62230: LD_INT 7
62232: PUSH
62233: EMPTY
62234: LIST
62235: LIST
62236: PUSH
62237: LD_INT 30
62239: PUSH
62240: LD_INT 8
62242: PUSH
62243: EMPTY
62244: LIST
62245: LIST
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: LIST
62251: LIST
62252: PPUSH
62253: CALL_OW 72
62257: AND
62258: PUSH
62259: LD_EXP 58
62263: PUSH
62264: LD_VAR 0 1
62268: ARRAY
62269: PPUSH
62270: LD_INT 30
62272: PUSH
62273: LD_INT 3
62275: PUSH
62276: EMPTY
62277: LIST
62278: LIST
62279: PPUSH
62280: CALL_OW 72
62284: NOT
62285: AND
62286: IFFALSE 62500
// begin if sci >= 6 then
62288: LD_VAR 0 8
62292: PUSH
62293: LD_INT 6
62295: GREATEREQUAL
62296: IFFALSE 62300
// exit ;
62298: GO 64719
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62300: LD_ADDR_EXP 100
62304: PUSH
62305: LD_EXP 100
62309: PPUSH
62310: LD_VAR 0 1
62314: PPUSH
62315: LD_INT 2
62317: PPUSH
62318: CALL_OW 1
62322: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62323: LD_ADDR_VAR 0 9
62327: PUSH
62328: LD_VAR 0 4
62332: PUSH
62333: LD_VAR 0 8
62337: DIFF
62338: PPUSH
62339: LD_INT 4
62341: PPUSH
62342: CALL 54896 0 2
62346: ST_TO_ADDR
// p := [ ] ;
62347: LD_ADDR_VAR 0 11
62351: PUSH
62352: EMPTY
62353: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62354: LD_VAR 0 8
62358: PUSH
62359: LD_INT 6
62361: LESS
62362: PUSH
62363: LD_VAR 0 9
62367: PUSH
62368: LD_INT 6
62370: GREATER
62371: AND
62372: IFFALSE 62453
// begin for i = 1 to 6 - sci do
62374: LD_ADDR_VAR 0 3
62378: PUSH
62379: DOUBLE
62380: LD_INT 1
62382: DEC
62383: ST_TO_ADDR
62384: LD_INT 6
62386: PUSH
62387: LD_VAR 0 8
62391: MINUS
62392: PUSH
62393: FOR_TO
62394: IFFALSE 62449
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62396: LD_ADDR_VAR 0 11
62400: PUSH
62401: LD_VAR 0 11
62405: PPUSH
62406: LD_VAR 0 11
62410: PUSH
62411: LD_INT 1
62413: PLUS
62414: PPUSH
62415: LD_VAR 0 9
62419: PUSH
62420: LD_INT 1
62422: ARRAY
62423: PPUSH
62424: CALL_OW 2
62428: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62429: LD_ADDR_VAR 0 9
62433: PUSH
62434: LD_VAR 0 9
62438: PPUSH
62439: LD_INT 1
62441: PPUSH
62442: CALL_OW 3
62446: ST_TO_ADDR
// end ;
62447: GO 62393
62449: POP
62450: POP
// end else
62451: GO 62473
// if sort then
62453: LD_VAR 0 9
62457: IFFALSE 62473
// p := sort [ 1 ] ;
62459: LD_ADDR_VAR 0 11
62463: PUSH
62464: LD_VAR 0 9
62468: PUSH
62469: LD_INT 1
62471: ARRAY
62472: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62473: LD_ADDR_VAR 0 2
62477: PUSH
62478: LD_INT 0
62480: PUSH
62481: LD_INT 0
62483: PUSH
62484: LD_INT 0
62486: PUSH
62487: LD_VAR 0 11
62491: PUSH
62492: EMPTY
62493: LIST
62494: LIST
62495: LIST
62496: LIST
62497: ST_TO_ADDR
// exit ;
62498: GO 64719
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62500: LD_EXP 85
62504: PUSH
62505: LD_EXP 84
62509: PUSH
62510: LD_VAR 0 1
62514: ARRAY
62515: ARRAY
62516: PUSH
62517: LD_EXP 58
62521: PUSH
62522: LD_VAR 0 1
62526: ARRAY
62527: PPUSH
62528: LD_INT 2
62530: PUSH
62531: LD_INT 30
62533: PUSH
62534: LD_INT 6
62536: PUSH
62537: EMPTY
62538: LIST
62539: LIST
62540: PUSH
62541: LD_INT 30
62543: PUSH
62544: LD_INT 7
62546: PUSH
62547: EMPTY
62548: LIST
62549: LIST
62550: PUSH
62551: LD_INT 30
62553: PUSH
62554: LD_INT 8
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: LIST
62565: LIST
62566: PPUSH
62567: CALL_OW 72
62571: AND
62572: PUSH
62573: LD_EXP 58
62577: PUSH
62578: LD_VAR 0 1
62582: ARRAY
62583: PPUSH
62584: LD_INT 30
62586: PUSH
62587: LD_INT 3
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PPUSH
62594: CALL_OW 72
62598: AND
62599: IFFALSE 63333
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62601: LD_ADDR_EXP 100
62605: PUSH
62606: LD_EXP 100
62610: PPUSH
62611: LD_VAR 0 1
62615: PPUSH
62616: LD_INT 3
62618: PPUSH
62619: CALL_OW 1
62623: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62624: LD_ADDR_VAR 0 2
62628: PUSH
62629: LD_INT 0
62631: PUSH
62632: LD_INT 0
62634: PUSH
62635: LD_INT 0
62637: PUSH
62638: LD_INT 0
62640: PUSH
62641: EMPTY
62642: LIST
62643: LIST
62644: LIST
62645: LIST
62646: ST_TO_ADDR
// if not eng then
62647: LD_VAR 0 6
62651: NOT
62652: IFFALSE 62715
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62654: LD_ADDR_VAR 0 11
62658: PUSH
62659: LD_VAR 0 4
62663: PPUSH
62664: LD_INT 2
62666: PPUSH
62667: CALL 54896 0 2
62671: PUSH
62672: LD_INT 1
62674: ARRAY
62675: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62676: LD_ADDR_VAR 0 2
62680: PUSH
62681: LD_VAR 0 2
62685: PPUSH
62686: LD_INT 2
62688: PPUSH
62689: LD_VAR 0 11
62693: PPUSH
62694: CALL_OW 1
62698: ST_TO_ADDR
// tmp := tmp diff p ;
62699: LD_ADDR_VAR 0 4
62703: PUSH
62704: LD_VAR 0 4
62708: PUSH
62709: LD_VAR 0 11
62713: DIFF
62714: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62715: LD_VAR 0 4
62719: PUSH
62720: LD_VAR 0 8
62724: PUSH
62725: LD_INT 6
62727: LESS
62728: AND
62729: IFFALSE 62917
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62731: LD_ADDR_VAR 0 9
62735: PUSH
62736: LD_VAR 0 4
62740: PUSH
62741: LD_VAR 0 8
62745: PUSH
62746: LD_VAR 0 7
62750: UNION
62751: DIFF
62752: PPUSH
62753: LD_INT 4
62755: PPUSH
62756: CALL 54896 0 2
62760: ST_TO_ADDR
// p := [ ] ;
62761: LD_ADDR_VAR 0 11
62765: PUSH
62766: EMPTY
62767: ST_TO_ADDR
// if sort then
62768: LD_VAR 0 9
62772: IFFALSE 62888
// for i = 1 to 6 - sci do
62774: LD_ADDR_VAR 0 3
62778: PUSH
62779: DOUBLE
62780: LD_INT 1
62782: DEC
62783: ST_TO_ADDR
62784: LD_INT 6
62786: PUSH
62787: LD_VAR 0 8
62791: MINUS
62792: PUSH
62793: FOR_TO
62794: IFFALSE 62886
// begin if i = sort then
62796: LD_VAR 0 3
62800: PUSH
62801: LD_VAR 0 9
62805: EQUAL
62806: IFFALSE 62810
// break ;
62808: GO 62886
// if GetClass ( i ) = 4 then
62810: LD_VAR 0 3
62814: PPUSH
62815: CALL_OW 257
62819: PUSH
62820: LD_INT 4
62822: EQUAL
62823: IFFALSE 62827
// continue ;
62825: GO 62793
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62827: LD_ADDR_VAR 0 11
62831: PUSH
62832: LD_VAR 0 11
62836: PPUSH
62837: LD_VAR 0 11
62841: PUSH
62842: LD_INT 1
62844: PLUS
62845: PPUSH
62846: LD_VAR 0 9
62850: PUSH
62851: LD_VAR 0 3
62855: ARRAY
62856: PPUSH
62857: CALL_OW 2
62861: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62862: LD_ADDR_VAR 0 4
62866: PUSH
62867: LD_VAR 0 4
62871: PUSH
62872: LD_VAR 0 9
62876: PUSH
62877: LD_VAR 0 3
62881: ARRAY
62882: DIFF
62883: ST_TO_ADDR
// end ;
62884: GO 62793
62886: POP
62887: POP
// if p then
62888: LD_VAR 0 11
62892: IFFALSE 62917
// result := Replace ( result , 4 , p ) ;
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: LD_VAR 0 2
62903: PPUSH
62904: LD_INT 4
62906: PPUSH
62907: LD_VAR 0 11
62911: PPUSH
62912: CALL_OW 1
62916: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62917: LD_VAR 0 4
62921: PUSH
62922: LD_VAR 0 7
62926: PUSH
62927: LD_INT 6
62929: LESS
62930: AND
62931: IFFALSE 63119
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62933: LD_ADDR_VAR 0 9
62937: PUSH
62938: LD_VAR 0 4
62942: PUSH
62943: LD_VAR 0 8
62947: PUSH
62948: LD_VAR 0 7
62952: UNION
62953: DIFF
62954: PPUSH
62955: LD_INT 3
62957: PPUSH
62958: CALL 54896 0 2
62962: ST_TO_ADDR
// p := [ ] ;
62963: LD_ADDR_VAR 0 11
62967: PUSH
62968: EMPTY
62969: ST_TO_ADDR
// if sort then
62970: LD_VAR 0 9
62974: IFFALSE 63090
// for i = 1 to 6 - mech do
62976: LD_ADDR_VAR 0 3
62980: PUSH
62981: DOUBLE
62982: LD_INT 1
62984: DEC
62985: ST_TO_ADDR
62986: LD_INT 6
62988: PUSH
62989: LD_VAR 0 7
62993: MINUS
62994: PUSH
62995: FOR_TO
62996: IFFALSE 63088
// begin if i = sort then
62998: LD_VAR 0 3
63002: PUSH
63003: LD_VAR 0 9
63007: EQUAL
63008: IFFALSE 63012
// break ;
63010: GO 63088
// if GetClass ( i ) = 3 then
63012: LD_VAR 0 3
63016: PPUSH
63017: CALL_OW 257
63021: PUSH
63022: LD_INT 3
63024: EQUAL
63025: IFFALSE 63029
// continue ;
63027: GO 62995
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63029: LD_ADDR_VAR 0 11
63033: PUSH
63034: LD_VAR 0 11
63038: PPUSH
63039: LD_VAR 0 11
63043: PUSH
63044: LD_INT 1
63046: PLUS
63047: PPUSH
63048: LD_VAR 0 9
63052: PUSH
63053: LD_VAR 0 3
63057: ARRAY
63058: PPUSH
63059: CALL_OW 2
63063: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63064: LD_ADDR_VAR 0 4
63068: PUSH
63069: LD_VAR 0 4
63073: PUSH
63074: LD_VAR 0 9
63078: PUSH
63079: LD_VAR 0 3
63083: ARRAY
63084: DIFF
63085: ST_TO_ADDR
// end ;
63086: GO 62995
63088: POP
63089: POP
// if p then
63090: LD_VAR 0 11
63094: IFFALSE 63119
// result := Replace ( result , 3 , p ) ;
63096: LD_ADDR_VAR 0 2
63100: PUSH
63101: LD_VAR 0 2
63105: PPUSH
63106: LD_INT 3
63108: PPUSH
63109: LD_VAR 0 11
63113: PPUSH
63114: CALL_OW 1
63118: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63119: LD_VAR 0 4
63123: PUSH
63124: LD_INT 6
63126: GREATER
63127: PUSH
63128: LD_VAR 0 6
63132: PUSH
63133: LD_INT 6
63135: LESS
63136: AND
63137: IFFALSE 63331
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63139: LD_ADDR_VAR 0 9
63143: PUSH
63144: LD_VAR 0 4
63148: PUSH
63149: LD_VAR 0 8
63153: PUSH
63154: LD_VAR 0 7
63158: UNION
63159: PUSH
63160: LD_VAR 0 6
63164: UNION
63165: DIFF
63166: PPUSH
63167: LD_INT 2
63169: PPUSH
63170: CALL 54896 0 2
63174: ST_TO_ADDR
// p := [ ] ;
63175: LD_ADDR_VAR 0 11
63179: PUSH
63180: EMPTY
63181: ST_TO_ADDR
// if sort then
63182: LD_VAR 0 9
63186: IFFALSE 63302
// for i = 1 to 6 - eng do
63188: LD_ADDR_VAR 0 3
63192: PUSH
63193: DOUBLE
63194: LD_INT 1
63196: DEC
63197: ST_TO_ADDR
63198: LD_INT 6
63200: PUSH
63201: LD_VAR 0 6
63205: MINUS
63206: PUSH
63207: FOR_TO
63208: IFFALSE 63300
// begin if i = sort then
63210: LD_VAR 0 3
63214: PUSH
63215: LD_VAR 0 9
63219: EQUAL
63220: IFFALSE 63224
// break ;
63222: GO 63300
// if GetClass ( i ) = 2 then
63224: LD_VAR 0 3
63228: PPUSH
63229: CALL_OW 257
63233: PUSH
63234: LD_INT 2
63236: EQUAL
63237: IFFALSE 63241
// continue ;
63239: GO 63207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63241: LD_ADDR_VAR 0 11
63245: PUSH
63246: LD_VAR 0 11
63250: PPUSH
63251: LD_VAR 0 11
63255: PUSH
63256: LD_INT 1
63258: PLUS
63259: PPUSH
63260: LD_VAR 0 9
63264: PUSH
63265: LD_VAR 0 3
63269: ARRAY
63270: PPUSH
63271: CALL_OW 2
63275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63276: LD_ADDR_VAR 0 4
63280: PUSH
63281: LD_VAR 0 4
63285: PUSH
63286: LD_VAR 0 9
63290: PUSH
63291: LD_VAR 0 3
63295: ARRAY
63296: DIFF
63297: ST_TO_ADDR
// end ;
63298: GO 63207
63300: POP
63301: POP
// if p then
63302: LD_VAR 0 11
63306: IFFALSE 63331
// result := Replace ( result , 2 , p ) ;
63308: LD_ADDR_VAR 0 2
63312: PUSH
63313: LD_VAR 0 2
63317: PPUSH
63318: LD_INT 2
63320: PPUSH
63321: LD_VAR 0 11
63325: PPUSH
63326: CALL_OW 1
63330: ST_TO_ADDR
// end ; exit ;
63331: GO 64719
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63333: LD_EXP 85
63337: PUSH
63338: LD_EXP 84
63342: PUSH
63343: LD_VAR 0 1
63347: ARRAY
63348: ARRAY
63349: NOT
63350: PUSH
63351: LD_EXP 58
63355: PUSH
63356: LD_VAR 0 1
63360: ARRAY
63361: PPUSH
63362: LD_INT 30
63364: PUSH
63365: LD_INT 3
63367: PUSH
63368: EMPTY
63369: LIST
63370: LIST
63371: PPUSH
63372: CALL_OW 72
63376: AND
63377: PUSH
63378: LD_EXP 63
63382: PUSH
63383: LD_VAR 0 1
63387: ARRAY
63388: AND
63389: IFFALSE 63997
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63391: LD_ADDR_EXP 100
63395: PUSH
63396: LD_EXP 100
63400: PPUSH
63401: LD_VAR 0 1
63405: PPUSH
63406: LD_INT 5
63408: PPUSH
63409: CALL_OW 1
63413: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63414: LD_ADDR_VAR 0 2
63418: PUSH
63419: LD_INT 0
63421: PUSH
63422: LD_INT 0
63424: PUSH
63425: LD_INT 0
63427: PUSH
63428: LD_INT 0
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: LIST
63435: LIST
63436: ST_TO_ADDR
// if sci > 1 then
63437: LD_VAR 0 8
63441: PUSH
63442: LD_INT 1
63444: GREATER
63445: IFFALSE 63473
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63447: LD_ADDR_VAR 0 4
63451: PUSH
63452: LD_VAR 0 4
63456: PUSH
63457: LD_VAR 0 8
63461: PUSH
63462: LD_VAR 0 8
63466: PUSH
63467: LD_INT 1
63469: ARRAY
63470: DIFF
63471: DIFF
63472: ST_TO_ADDR
// if tmp and not sci then
63473: LD_VAR 0 4
63477: PUSH
63478: LD_VAR 0 8
63482: NOT
63483: AND
63484: IFFALSE 63553
// begin sort := SortBySkill ( tmp , 4 ) ;
63486: LD_ADDR_VAR 0 9
63490: PUSH
63491: LD_VAR 0 4
63495: PPUSH
63496: LD_INT 4
63498: PPUSH
63499: CALL 54896 0 2
63503: ST_TO_ADDR
// if sort then
63504: LD_VAR 0 9
63508: IFFALSE 63524
// p := sort [ 1 ] ;
63510: LD_ADDR_VAR 0 11
63514: PUSH
63515: LD_VAR 0 9
63519: PUSH
63520: LD_INT 1
63522: ARRAY
63523: ST_TO_ADDR
// if p then
63524: LD_VAR 0 11
63528: IFFALSE 63553
// result := Replace ( result , 4 , p ) ;
63530: LD_ADDR_VAR 0 2
63534: PUSH
63535: LD_VAR 0 2
63539: PPUSH
63540: LD_INT 4
63542: PPUSH
63543: LD_VAR 0 11
63547: PPUSH
63548: CALL_OW 1
63552: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63553: LD_ADDR_VAR 0 4
63557: PUSH
63558: LD_VAR 0 4
63562: PUSH
63563: LD_VAR 0 7
63567: DIFF
63568: ST_TO_ADDR
// if tmp and mech < 6 then
63569: LD_VAR 0 4
63573: PUSH
63574: LD_VAR 0 7
63578: PUSH
63579: LD_INT 6
63581: LESS
63582: AND
63583: IFFALSE 63771
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63585: LD_ADDR_VAR 0 9
63589: PUSH
63590: LD_VAR 0 4
63594: PUSH
63595: LD_VAR 0 8
63599: PUSH
63600: LD_VAR 0 7
63604: UNION
63605: DIFF
63606: PPUSH
63607: LD_INT 3
63609: PPUSH
63610: CALL 54896 0 2
63614: ST_TO_ADDR
// p := [ ] ;
63615: LD_ADDR_VAR 0 11
63619: PUSH
63620: EMPTY
63621: ST_TO_ADDR
// if sort then
63622: LD_VAR 0 9
63626: IFFALSE 63742
// for i = 1 to 6 - mech do
63628: LD_ADDR_VAR 0 3
63632: PUSH
63633: DOUBLE
63634: LD_INT 1
63636: DEC
63637: ST_TO_ADDR
63638: LD_INT 6
63640: PUSH
63641: LD_VAR 0 7
63645: MINUS
63646: PUSH
63647: FOR_TO
63648: IFFALSE 63740
// begin if i = sort then
63650: LD_VAR 0 3
63654: PUSH
63655: LD_VAR 0 9
63659: EQUAL
63660: IFFALSE 63664
// break ;
63662: GO 63740
// if GetClass ( i ) = 3 then
63664: LD_VAR 0 3
63668: PPUSH
63669: CALL_OW 257
63673: PUSH
63674: LD_INT 3
63676: EQUAL
63677: IFFALSE 63681
// continue ;
63679: GO 63647
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63681: LD_ADDR_VAR 0 11
63685: PUSH
63686: LD_VAR 0 11
63690: PPUSH
63691: LD_VAR 0 11
63695: PUSH
63696: LD_INT 1
63698: PLUS
63699: PPUSH
63700: LD_VAR 0 9
63704: PUSH
63705: LD_VAR 0 3
63709: ARRAY
63710: PPUSH
63711: CALL_OW 2
63715: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63716: LD_ADDR_VAR 0 4
63720: PUSH
63721: LD_VAR 0 4
63725: PUSH
63726: LD_VAR 0 9
63730: PUSH
63731: LD_VAR 0 3
63735: ARRAY
63736: DIFF
63737: ST_TO_ADDR
// end ;
63738: GO 63647
63740: POP
63741: POP
// if p then
63742: LD_VAR 0 11
63746: IFFALSE 63771
// result := Replace ( result , 3 , p ) ;
63748: LD_ADDR_VAR 0 2
63752: PUSH
63753: LD_VAR 0 2
63757: PPUSH
63758: LD_INT 3
63760: PPUSH
63761: LD_VAR 0 11
63765: PPUSH
63766: CALL_OW 1
63770: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63771: LD_ADDR_VAR 0 4
63775: PUSH
63776: LD_VAR 0 4
63780: PUSH
63781: LD_VAR 0 6
63785: DIFF
63786: ST_TO_ADDR
// if tmp and eng < 6 then
63787: LD_VAR 0 4
63791: PUSH
63792: LD_VAR 0 6
63796: PUSH
63797: LD_INT 6
63799: LESS
63800: AND
63801: IFFALSE 63995
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63803: LD_ADDR_VAR 0 9
63807: PUSH
63808: LD_VAR 0 4
63812: PUSH
63813: LD_VAR 0 8
63817: PUSH
63818: LD_VAR 0 7
63822: UNION
63823: PUSH
63824: LD_VAR 0 6
63828: UNION
63829: DIFF
63830: PPUSH
63831: LD_INT 2
63833: PPUSH
63834: CALL 54896 0 2
63838: ST_TO_ADDR
// p := [ ] ;
63839: LD_ADDR_VAR 0 11
63843: PUSH
63844: EMPTY
63845: ST_TO_ADDR
// if sort then
63846: LD_VAR 0 9
63850: IFFALSE 63966
// for i = 1 to 6 - eng do
63852: LD_ADDR_VAR 0 3
63856: PUSH
63857: DOUBLE
63858: LD_INT 1
63860: DEC
63861: ST_TO_ADDR
63862: LD_INT 6
63864: PUSH
63865: LD_VAR 0 6
63869: MINUS
63870: PUSH
63871: FOR_TO
63872: IFFALSE 63964
// begin if i = sort then
63874: LD_VAR 0 3
63878: PUSH
63879: LD_VAR 0 9
63883: EQUAL
63884: IFFALSE 63888
// break ;
63886: GO 63964
// if GetClass ( i ) = 2 then
63888: LD_VAR 0 3
63892: PPUSH
63893: CALL_OW 257
63897: PUSH
63898: LD_INT 2
63900: EQUAL
63901: IFFALSE 63905
// continue ;
63903: GO 63871
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63905: LD_ADDR_VAR 0 11
63909: PUSH
63910: LD_VAR 0 11
63914: PPUSH
63915: LD_VAR 0 11
63919: PUSH
63920: LD_INT 1
63922: PLUS
63923: PPUSH
63924: LD_VAR 0 9
63928: PUSH
63929: LD_VAR 0 3
63933: ARRAY
63934: PPUSH
63935: CALL_OW 2
63939: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63940: LD_ADDR_VAR 0 4
63944: PUSH
63945: LD_VAR 0 4
63949: PUSH
63950: LD_VAR 0 9
63954: PUSH
63955: LD_VAR 0 3
63959: ARRAY
63960: DIFF
63961: ST_TO_ADDR
// end ;
63962: GO 63871
63964: POP
63965: POP
// if p then
63966: LD_VAR 0 11
63970: IFFALSE 63995
// result := Replace ( result , 2 , p ) ;
63972: LD_ADDR_VAR 0 2
63976: PUSH
63977: LD_VAR 0 2
63981: PPUSH
63982: LD_INT 2
63984: PPUSH
63985: LD_VAR 0 11
63989: PPUSH
63990: CALL_OW 1
63994: ST_TO_ADDR
// end ; exit ;
63995: GO 64719
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63997: LD_EXP 85
64001: PUSH
64002: LD_EXP 84
64006: PUSH
64007: LD_VAR 0 1
64011: ARRAY
64012: ARRAY
64013: NOT
64014: PUSH
64015: LD_EXP 58
64019: PUSH
64020: LD_VAR 0 1
64024: ARRAY
64025: PPUSH
64026: LD_INT 30
64028: PUSH
64029: LD_INT 3
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: PPUSH
64036: CALL_OW 72
64040: AND
64041: PUSH
64042: LD_EXP 63
64046: PUSH
64047: LD_VAR 0 1
64051: ARRAY
64052: NOT
64053: AND
64054: IFFALSE 64719
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64056: LD_ADDR_EXP 100
64060: PUSH
64061: LD_EXP 100
64065: PPUSH
64066: LD_VAR 0 1
64070: PPUSH
64071: LD_INT 6
64073: PPUSH
64074: CALL_OW 1
64078: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64079: LD_ADDR_VAR 0 2
64083: PUSH
64084: LD_INT 0
64086: PUSH
64087: LD_INT 0
64089: PUSH
64090: LD_INT 0
64092: PUSH
64093: LD_INT 0
64095: PUSH
64096: EMPTY
64097: LIST
64098: LIST
64099: LIST
64100: LIST
64101: ST_TO_ADDR
// if sci >= 1 then
64102: LD_VAR 0 8
64106: PUSH
64107: LD_INT 1
64109: GREATEREQUAL
64110: IFFALSE 64132
// tmp := tmp diff sci [ 1 ] ;
64112: LD_ADDR_VAR 0 4
64116: PUSH
64117: LD_VAR 0 4
64121: PUSH
64122: LD_VAR 0 8
64126: PUSH
64127: LD_INT 1
64129: ARRAY
64130: DIFF
64131: ST_TO_ADDR
// if tmp and not sci then
64132: LD_VAR 0 4
64136: PUSH
64137: LD_VAR 0 8
64141: NOT
64142: AND
64143: IFFALSE 64212
// begin sort := SortBySkill ( tmp , 4 ) ;
64145: LD_ADDR_VAR 0 9
64149: PUSH
64150: LD_VAR 0 4
64154: PPUSH
64155: LD_INT 4
64157: PPUSH
64158: CALL 54896 0 2
64162: ST_TO_ADDR
// if sort then
64163: LD_VAR 0 9
64167: IFFALSE 64183
// p := sort [ 1 ] ;
64169: LD_ADDR_VAR 0 11
64173: PUSH
64174: LD_VAR 0 9
64178: PUSH
64179: LD_INT 1
64181: ARRAY
64182: ST_TO_ADDR
// if p then
64183: LD_VAR 0 11
64187: IFFALSE 64212
// result := Replace ( result , 4 , p ) ;
64189: LD_ADDR_VAR 0 2
64193: PUSH
64194: LD_VAR 0 2
64198: PPUSH
64199: LD_INT 4
64201: PPUSH
64202: LD_VAR 0 11
64206: PPUSH
64207: CALL_OW 1
64211: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64212: LD_ADDR_VAR 0 4
64216: PUSH
64217: LD_VAR 0 4
64221: PUSH
64222: LD_VAR 0 7
64226: DIFF
64227: ST_TO_ADDR
// if tmp and mech < 6 then
64228: LD_VAR 0 4
64232: PUSH
64233: LD_VAR 0 7
64237: PUSH
64238: LD_INT 6
64240: LESS
64241: AND
64242: IFFALSE 64424
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64244: LD_ADDR_VAR 0 9
64248: PUSH
64249: LD_VAR 0 4
64253: PUSH
64254: LD_VAR 0 7
64258: DIFF
64259: PPUSH
64260: LD_INT 3
64262: PPUSH
64263: CALL 54896 0 2
64267: ST_TO_ADDR
// p := [ ] ;
64268: LD_ADDR_VAR 0 11
64272: PUSH
64273: EMPTY
64274: ST_TO_ADDR
// if sort then
64275: LD_VAR 0 9
64279: IFFALSE 64395
// for i = 1 to 6 - mech do
64281: LD_ADDR_VAR 0 3
64285: PUSH
64286: DOUBLE
64287: LD_INT 1
64289: DEC
64290: ST_TO_ADDR
64291: LD_INT 6
64293: PUSH
64294: LD_VAR 0 7
64298: MINUS
64299: PUSH
64300: FOR_TO
64301: IFFALSE 64393
// begin if i = sort then
64303: LD_VAR 0 3
64307: PUSH
64308: LD_VAR 0 9
64312: EQUAL
64313: IFFALSE 64317
// break ;
64315: GO 64393
// if GetClass ( i ) = 3 then
64317: LD_VAR 0 3
64321: PPUSH
64322: CALL_OW 257
64326: PUSH
64327: LD_INT 3
64329: EQUAL
64330: IFFALSE 64334
// continue ;
64332: GO 64300
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64334: LD_ADDR_VAR 0 11
64338: PUSH
64339: LD_VAR 0 11
64343: PPUSH
64344: LD_VAR 0 11
64348: PUSH
64349: LD_INT 1
64351: PLUS
64352: PPUSH
64353: LD_VAR 0 9
64357: PUSH
64358: LD_VAR 0 3
64362: ARRAY
64363: PPUSH
64364: CALL_OW 2
64368: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64369: LD_ADDR_VAR 0 4
64373: PUSH
64374: LD_VAR 0 4
64378: PUSH
64379: LD_VAR 0 9
64383: PUSH
64384: LD_VAR 0 3
64388: ARRAY
64389: DIFF
64390: ST_TO_ADDR
// end ;
64391: GO 64300
64393: POP
64394: POP
// if p then
64395: LD_VAR 0 11
64399: IFFALSE 64424
// result := Replace ( result , 3 , p ) ;
64401: LD_ADDR_VAR 0 2
64405: PUSH
64406: LD_VAR 0 2
64410: PPUSH
64411: LD_INT 3
64413: PPUSH
64414: LD_VAR 0 11
64418: PPUSH
64419: CALL_OW 1
64423: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64424: LD_ADDR_VAR 0 4
64428: PUSH
64429: LD_VAR 0 4
64433: PUSH
64434: LD_VAR 0 6
64438: DIFF
64439: ST_TO_ADDR
// if tmp and eng < 4 then
64440: LD_VAR 0 4
64444: PUSH
64445: LD_VAR 0 6
64449: PUSH
64450: LD_INT 4
64452: LESS
64453: AND
64454: IFFALSE 64644
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64456: LD_ADDR_VAR 0 9
64460: PUSH
64461: LD_VAR 0 4
64465: PUSH
64466: LD_VAR 0 7
64470: PUSH
64471: LD_VAR 0 6
64475: UNION
64476: DIFF
64477: PPUSH
64478: LD_INT 2
64480: PPUSH
64481: CALL 54896 0 2
64485: ST_TO_ADDR
// p := [ ] ;
64486: LD_ADDR_VAR 0 11
64490: PUSH
64491: EMPTY
64492: ST_TO_ADDR
// if sort then
64493: LD_VAR 0 9
64497: IFFALSE 64613
// for i = 1 to 4 - eng do
64499: LD_ADDR_VAR 0 3
64503: PUSH
64504: DOUBLE
64505: LD_INT 1
64507: DEC
64508: ST_TO_ADDR
64509: LD_INT 4
64511: PUSH
64512: LD_VAR 0 6
64516: MINUS
64517: PUSH
64518: FOR_TO
64519: IFFALSE 64611
// begin if i = sort then
64521: LD_VAR 0 3
64525: PUSH
64526: LD_VAR 0 9
64530: EQUAL
64531: IFFALSE 64535
// break ;
64533: GO 64611
// if GetClass ( i ) = 2 then
64535: LD_VAR 0 3
64539: PPUSH
64540: CALL_OW 257
64544: PUSH
64545: LD_INT 2
64547: EQUAL
64548: IFFALSE 64552
// continue ;
64550: GO 64518
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64552: LD_ADDR_VAR 0 11
64556: PUSH
64557: LD_VAR 0 11
64561: PPUSH
64562: LD_VAR 0 11
64566: PUSH
64567: LD_INT 1
64569: PLUS
64570: PPUSH
64571: LD_VAR 0 9
64575: PUSH
64576: LD_VAR 0 3
64580: ARRAY
64581: PPUSH
64582: CALL_OW 2
64586: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64587: LD_ADDR_VAR 0 4
64591: PUSH
64592: LD_VAR 0 4
64596: PUSH
64597: LD_VAR 0 9
64601: PUSH
64602: LD_VAR 0 3
64606: ARRAY
64607: DIFF
64608: ST_TO_ADDR
// end ;
64609: GO 64518
64611: POP
64612: POP
// if p then
64613: LD_VAR 0 11
64617: IFFALSE 64642
// result := Replace ( result , 2 , p ) ;
64619: LD_ADDR_VAR 0 2
64623: PUSH
64624: LD_VAR 0 2
64628: PPUSH
64629: LD_INT 2
64631: PPUSH
64632: LD_VAR 0 11
64636: PPUSH
64637: CALL_OW 1
64641: ST_TO_ADDR
// end else
64642: GO 64688
// for i = eng downto 5 do
64644: LD_ADDR_VAR 0 3
64648: PUSH
64649: DOUBLE
64650: LD_VAR 0 6
64654: INC
64655: ST_TO_ADDR
64656: LD_INT 5
64658: PUSH
64659: FOR_DOWNTO
64660: IFFALSE 64686
// tmp := tmp union eng [ i ] ;
64662: LD_ADDR_VAR 0 4
64666: PUSH
64667: LD_VAR 0 4
64671: PUSH
64672: LD_VAR 0 6
64676: PUSH
64677: LD_VAR 0 3
64681: ARRAY
64682: UNION
64683: ST_TO_ADDR
64684: GO 64659
64686: POP
64687: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64688: LD_ADDR_VAR 0 2
64692: PUSH
64693: LD_VAR 0 2
64697: PPUSH
64698: LD_INT 1
64700: PPUSH
64701: LD_VAR 0 4
64705: PUSH
64706: LD_VAR 0 5
64710: DIFF
64711: PPUSH
64712: CALL_OW 1
64716: ST_TO_ADDR
// exit ;
64717: GO 64719
// end ; end ;
64719: LD_VAR 0 2
64723: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64724: LD_INT 0
64726: PPUSH
64727: PPUSH
64728: PPUSH
// if not mc_bases then
64729: LD_EXP 58
64733: NOT
64734: IFFALSE 64738
// exit ;
64736: GO 64844
// for i = 1 to mc_bases do
64738: LD_ADDR_VAR 0 2
64742: PUSH
64743: DOUBLE
64744: LD_INT 1
64746: DEC
64747: ST_TO_ADDR
64748: LD_EXP 58
64752: PUSH
64753: FOR_TO
64754: IFFALSE 64835
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64756: LD_ADDR_VAR 0 3
64760: PUSH
64761: LD_EXP 58
64765: PUSH
64766: LD_VAR 0 2
64770: ARRAY
64771: PPUSH
64772: LD_INT 21
64774: PUSH
64775: LD_INT 3
64777: PUSH
64778: EMPTY
64779: LIST
64780: LIST
64781: PUSH
64782: LD_INT 3
64784: PUSH
64785: LD_INT 24
64787: PUSH
64788: LD_INT 1000
64790: PUSH
64791: EMPTY
64792: LIST
64793: LIST
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PUSH
64799: EMPTY
64800: LIST
64801: LIST
64802: PPUSH
64803: CALL_OW 72
64807: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64808: LD_ADDR_EXP 59
64812: PUSH
64813: LD_EXP 59
64817: PPUSH
64818: LD_VAR 0 2
64822: PPUSH
64823: LD_VAR 0 3
64827: PPUSH
64828: CALL_OW 1
64832: ST_TO_ADDR
// end ;
64833: GO 64753
64835: POP
64836: POP
// RaiseSailEvent ( 101 ) ;
64837: LD_INT 101
64839: PPUSH
64840: CALL_OW 427
// end ;
64844: LD_VAR 0 1
64848: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64849: LD_INT 0
64851: PPUSH
64852: PPUSH
64853: PPUSH
64854: PPUSH
64855: PPUSH
64856: PPUSH
64857: PPUSH
// if not mc_bases then
64858: LD_EXP 58
64862: NOT
64863: IFFALSE 64867
// exit ;
64865: GO 65440
// for i = 1 to mc_bases do
64867: LD_ADDR_VAR 0 2
64871: PUSH
64872: DOUBLE
64873: LD_INT 1
64875: DEC
64876: ST_TO_ADDR
64877: LD_EXP 58
64881: PUSH
64882: FOR_TO
64883: IFFALSE 65431
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 750 ] ] ] ] ) ;
64885: LD_ADDR_VAR 0 5
64889: PUSH
64890: LD_EXP 58
64894: PUSH
64895: LD_VAR 0 2
64899: ARRAY
64900: PUSH
64901: LD_EXP 87
64905: PUSH
64906: LD_VAR 0 2
64910: ARRAY
64911: UNION
64912: PPUSH
64913: LD_INT 21
64915: PUSH
64916: LD_INT 1
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: LD_INT 1
64925: PUSH
64926: LD_INT 3
64928: PUSH
64929: LD_INT 54
64931: PUSH
64932: EMPTY
64933: LIST
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 3
64941: PUSH
64942: LD_INT 24
64944: PUSH
64945: LD_INT 750
64947: PUSH
64948: EMPTY
64949: LIST
64950: LIST
64951: PUSH
64952: EMPTY
64953: LIST
64954: LIST
64955: PUSH
64956: EMPTY
64957: LIST
64958: LIST
64959: LIST
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PPUSH
64965: CALL_OW 72
64969: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64970: LD_ADDR_VAR 0 6
64974: PUSH
64975: LD_EXP 58
64979: PUSH
64980: LD_VAR 0 2
64984: ARRAY
64985: PPUSH
64986: LD_INT 21
64988: PUSH
64989: LD_INT 1
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: PUSH
64996: LD_INT 1
64998: PUSH
64999: LD_INT 3
65001: PUSH
65002: LD_INT 54
65004: PUSH
65005: EMPTY
65006: LIST
65007: PUSH
65008: EMPTY
65009: LIST
65010: LIST
65011: PUSH
65012: LD_INT 3
65014: PUSH
65015: LD_INT 24
65017: PUSH
65018: LD_INT 250
65020: PUSH
65021: EMPTY
65022: LIST
65023: LIST
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: PUSH
65029: EMPTY
65030: LIST
65031: LIST
65032: LIST
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PPUSH
65038: CALL_OW 72
65042: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65043: LD_ADDR_VAR 0 7
65047: PUSH
65048: LD_VAR 0 5
65052: PUSH
65053: LD_VAR 0 6
65057: DIFF
65058: ST_TO_ADDR
// if not need_heal_1 then
65059: LD_VAR 0 6
65063: NOT
65064: IFFALSE 65097
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65066: LD_ADDR_EXP 61
65070: PUSH
65071: LD_EXP 61
65075: PPUSH
65076: LD_VAR 0 2
65080: PUSH
65081: LD_INT 1
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PPUSH
65088: EMPTY
65089: PPUSH
65090: CALL 20672 0 3
65094: ST_TO_ADDR
65095: GO 65167
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65097: LD_ADDR_EXP 61
65101: PUSH
65102: LD_EXP 61
65106: PPUSH
65107: LD_VAR 0 2
65111: PUSH
65112: LD_INT 1
65114: PUSH
65115: EMPTY
65116: LIST
65117: LIST
65118: PPUSH
65119: LD_EXP 61
65123: PUSH
65124: LD_VAR 0 2
65128: ARRAY
65129: PUSH
65130: LD_INT 1
65132: ARRAY
65133: PPUSH
65134: LD_INT 3
65136: PUSH
65137: LD_INT 24
65139: PUSH
65140: LD_INT 1000
65142: PUSH
65143: EMPTY
65144: LIST
65145: LIST
65146: PUSH
65147: EMPTY
65148: LIST
65149: LIST
65150: PPUSH
65151: CALL_OW 72
65155: PUSH
65156: LD_VAR 0 6
65160: UNION
65161: PPUSH
65162: CALL 20672 0 3
65166: ST_TO_ADDR
// if not need_heal_2 then
65167: LD_VAR 0 7
65171: NOT
65172: IFFALSE 65205
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65174: LD_ADDR_EXP 61
65178: PUSH
65179: LD_EXP 61
65183: PPUSH
65184: LD_VAR 0 2
65188: PUSH
65189: LD_INT 2
65191: PUSH
65192: EMPTY
65193: LIST
65194: LIST
65195: PPUSH
65196: EMPTY
65197: PPUSH
65198: CALL 20672 0 3
65202: ST_TO_ADDR
65203: GO 65237
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65205: LD_ADDR_EXP 61
65209: PUSH
65210: LD_EXP 61
65214: PPUSH
65215: LD_VAR 0 2
65219: PUSH
65220: LD_INT 2
65222: PUSH
65223: EMPTY
65224: LIST
65225: LIST
65226: PPUSH
65227: LD_VAR 0 7
65231: PPUSH
65232: CALL 20672 0 3
65236: ST_TO_ADDR
// if need_heal_2 then
65237: LD_VAR 0 7
65241: IFFALSE 65413
// for j in need_heal_2 do
65243: LD_ADDR_VAR 0 3
65247: PUSH
65248: LD_VAR 0 7
65252: PUSH
65253: FOR_IN
65254: IFFALSE 65411
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65256: LD_ADDR_VAR 0 5
65260: PUSH
65261: LD_EXP 58
65265: PUSH
65266: LD_VAR 0 2
65270: ARRAY
65271: PPUSH
65272: LD_INT 2
65274: PUSH
65275: LD_INT 30
65277: PUSH
65278: LD_INT 6
65280: PUSH
65281: EMPTY
65282: LIST
65283: LIST
65284: PUSH
65285: LD_INT 30
65287: PUSH
65288: LD_INT 7
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: LD_INT 30
65297: PUSH
65298: LD_INT 8
65300: PUSH
65301: EMPTY
65302: LIST
65303: LIST
65304: PUSH
65305: LD_INT 30
65307: PUSH
65308: LD_INT 0
65310: PUSH
65311: EMPTY
65312: LIST
65313: LIST
65314: PUSH
65315: LD_INT 30
65317: PUSH
65318: LD_INT 1
65320: PUSH
65321: EMPTY
65322: LIST
65323: LIST
65324: PUSH
65325: LD_INT 25
65327: PUSH
65328: LD_INT 4
65330: PUSH
65331: EMPTY
65332: LIST
65333: LIST
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: LIST
65339: LIST
65340: LIST
65341: LIST
65342: LIST
65343: PPUSH
65344: CALL_OW 72
65348: ST_TO_ADDR
// if tmp then
65349: LD_VAR 0 5
65353: IFFALSE 65409
// begin k := NearestUnitToUnit ( tmp , j ) ;
65355: LD_ADDR_VAR 0 4
65359: PUSH
65360: LD_VAR 0 5
65364: PPUSH
65365: LD_VAR 0 3
65369: PPUSH
65370: CALL_OW 74
65374: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65375: LD_VAR 0 3
65379: PPUSH
65380: LD_VAR 0 4
65384: PPUSH
65385: CALL_OW 296
65389: PUSH
65390: LD_INT 7
65392: GREATER
65393: IFFALSE 65409
// ComMoveUnit ( j , k ) ;
65395: LD_VAR 0 3
65399: PPUSH
65400: LD_VAR 0 4
65404: PPUSH
65405: CALL_OW 112
// end ; end ;
65409: GO 65253
65411: POP
65412: POP
// if not need_heal_1 and not need_heal_2 then
65413: LD_VAR 0 6
65417: NOT
65418: PUSH
65419: LD_VAR 0 7
65423: NOT
65424: AND
65425: IFFALSE 65429
// continue ;
65427: GO 64882
// end ;
65429: GO 64882
65431: POP
65432: POP
// RaiseSailEvent ( 102 ) ;
65433: LD_INT 102
65435: PPUSH
65436: CALL_OW 427
// end ;
65440: LD_VAR 0 1
65444: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
65445: LD_INT 0
65447: PPUSH
65448: PPUSH
65449: PPUSH
65450: PPUSH
65451: PPUSH
// if not mc_bases then
65452: LD_EXP 58
65456: NOT
65457: IFFALSE 65461
// exit ;
65459: GO 65846
// for i = 1 to mc_bases do
65461: LD_ADDR_VAR 0 2
65465: PUSH
65466: DOUBLE
65467: LD_INT 1
65469: DEC
65470: ST_TO_ADDR
65471: LD_EXP 58
65475: PUSH
65476: FOR_TO
65477: IFFALSE 65844
// begin if not mc_building_need_repair [ i ] then
65479: LD_EXP 59
65483: PUSH
65484: LD_VAR 0 2
65488: ARRAY
65489: NOT
65490: IFFALSE 65528
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65492: LD_ADDR_EXP 60
65496: PUSH
65497: LD_EXP 60
65501: PPUSH
65502: LD_VAR 0 2
65506: PPUSH
65507: EMPTY
65508: PPUSH
65509: CALL_OW 1
65513: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65514: LD_VAR 0 2
65518: PPUSH
65519: LD_INT 101
65521: PPUSH
65522: CALL 60566 0 2
// continue ;
65526: GO 65476
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65528: LD_ADDR_EXP 64
65532: PUSH
65533: LD_EXP 64
65537: PPUSH
65538: LD_VAR 0 2
65542: PPUSH
65543: EMPTY
65544: PPUSH
65545: CALL_OW 1
65549: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65550: LD_VAR 0 2
65554: PPUSH
65555: LD_INT 103
65557: PPUSH
65558: CALL 60566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65562: LD_ADDR_VAR 0 5
65566: PUSH
65567: LD_EXP 58
65571: PUSH
65572: LD_VAR 0 2
65576: ARRAY
65577: PUSH
65578: LD_EXP 87
65582: PUSH
65583: LD_VAR 0 2
65587: ARRAY
65588: UNION
65589: PPUSH
65590: LD_INT 2
65592: PUSH
65593: LD_INT 25
65595: PUSH
65596: LD_INT 2
65598: PUSH
65599: EMPTY
65600: LIST
65601: LIST
65602: PUSH
65603: LD_INT 25
65605: PUSH
65606: LD_INT 16
65608: PUSH
65609: EMPTY
65610: LIST
65611: LIST
65612: PUSH
65613: EMPTY
65614: LIST
65615: LIST
65616: LIST
65617: PUSH
65618: EMPTY
65619: LIST
65620: PPUSH
65621: CALL_OW 72
65625: ST_TO_ADDR
// if not tmp then
65626: LD_VAR 0 5
65630: NOT
65631: IFFALSE 65635
// continue ;
65633: GO 65476
// for j in tmp do
65635: LD_ADDR_VAR 0 3
65639: PUSH
65640: LD_VAR 0 5
65644: PUSH
65645: FOR_IN
65646: IFFALSE 65840
// begin if mc_need_heal [ i ] then
65648: LD_EXP 61
65652: PUSH
65653: LD_VAR 0 2
65657: ARRAY
65658: IFFALSE 65706
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
65660: LD_VAR 0 3
65664: PUSH
65665: LD_EXP 61
65669: PUSH
65670: LD_VAR 0 2
65674: ARRAY
65675: PUSH
65676: LD_INT 1
65678: ARRAY
65679: IN
65680: PUSH
65681: LD_VAR 0 3
65685: PUSH
65686: LD_EXP 61
65690: PUSH
65691: LD_VAR 0 2
65695: ARRAY
65696: PUSH
65697: LD_INT 2
65699: ARRAY
65700: IN
65701: OR
65702: IFFALSE 65706
// continue ;
65704: GO 65645
// if IsInUnit ( j ) then
65706: LD_VAR 0 3
65710: PPUSH
65711: CALL_OW 310
65715: IFFALSE 65726
// ComExitBuilding ( j ) ;
65717: LD_VAR 0 3
65721: PPUSH
65722: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65726: LD_VAR 0 3
65730: PUSH
65731: LD_EXP 60
65735: PUSH
65736: LD_VAR 0 2
65740: ARRAY
65741: IN
65742: NOT
65743: IFFALSE 65801
// begin SetTag ( j , 101 ) ;
65745: LD_VAR 0 3
65749: PPUSH
65750: LD_INT 101
65752: PPUSH
65753: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65757: LD_ADDR_EXP 60
65761: PUSH
65762: LD_EXP 60
65766: PPUSH
65767: LD_VAR 0 2
65771: PUSH
65772: LD_EXP 60
65776: PUSH
65777: LD_VAR 0 2
65781: ARRAY
65782: PUSH
65783: LD_INT 1
65785: PLUS
65786: PUSH
65787: EMPTY
65788: LIST
65789: LIST
65790: PPUSH
65791: LD_VAR 0 3
65795: PPUSH
65796: CALL 20672 0 3
65800: ST_TO_ADDR
// end ; wait ( 1 ) ;
65801: LD_INT 1
65803: PPUSH
65804: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
65808: LD_VAR 0 3
65812: PPUSH
65813: LD_EXP 59
65817: PUSH
65818: LD_VAR 0 2
65822: ARRAY
65823: PPUSH
65824: LD_VAR 0 3
65828: PPUSH
65829: CALL_OW 74
65833: PPUSH
65834: CALL_OW 130
// end ;
65838: GO 65645
65840: POP
65841: POP
// end ;
65842: GO 65476
65844: POP
65845: POP
// end ;
65846: LD_VAR 0 1
65850: RET
// export function MC_Heal ; var i , j , tmp ; begin
65851: LD_INT 0
65853: PPUSH
65854: PPUSH
65855: PPUSH
65856: PPUSH
// if not mc_bases then
65857: LD_EXP 58
65861: NOT
65862: IFFALSE 65866
// exit ;
65864: GO 66268
// for i = 1 to mc_bases do
65866: LD_ADDR_VAR 0 2
65870: PUSH
65871: DOUBLE
65872: LD_INT 1
65874: DEC
65875: ST_TO_ADDR
65876: LD_EXP 58
65880: PUSH
65881: FOR_TO
65882: IFFALSE 66266
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
65884: LD_EXP 61
65888: PUSH
65889: LD_VAR 0 2
65893: ARRAY
65894: PUSH
65895: LD_INT 1
65897: ARRAY
65898: NOT
65899: PUSH
65900: LD_EXP 61
65904: PUSH
65905: LD_VAR 0 2
65909: ARRAY
65910: PUSH
65911: LD_INT 2
65913: ARRAY
65914: NOT
65915: AND
65916: IFFALSE 65954
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
65918: LD_ADDR_EXP 62
65922: PUSH
65923: LD_EXP 62
65927: PPUSH
65928: LD_VAR 0 2
65932: PPUSH
65933: EMPTY
65934: PPUSH
65935: CALL_OW 1
65939: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
65940: LD_VAR 0 2
65944: PPUSH
65945: LD_INT 102
65947: PPUSH
65948: CALL 60566 0 2
// continue ;
65952: GO 65881
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
65954: LD_ADDR_VAR 0 4
65958: PUSH
65959: LD_EXP 58
65963: PUSH
65964: LD_VAR 0 2
65968: ARRAY
65969: PPUSH
65970: LD_INT 25
65972: PUSH
65973: LD_INT 4
65975: PUSH
65976: EMPTY
65977: LIST
65978: LIST
65979: PPUSH
65980: CALL_OW 72
65984: ST_TO_ADDR
// if not tmp then
65985: LD_VAR 0 4
65989: NOT
65990: IFFALSE 65994
// continue ;
65992: GO 65881
// if mc_taming [ i ] then
65994: LD_EXP 89
65998: PUSH
65999: LD_VAR 0 2
66003: ARRAY
66004: IFFALSE 66028
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66006: LD_ADDR_EXP 89
66010: PUSH
66011: LD_EXP 89
66015: PPUSH
66016: LD_VAR 0 2
66020: PPUSH
66021: EMPTY
66022: PPUSH
66023: CALL_OW 1
66027: ST_TO_ADDR
// for j in tmp do
66028: LD_ADDR_VAR 0 3
66032: PUSH
66033: LD_VAR 0 4
66037: PUSH
66038: FOR_IN
66039: IFFALSE 66262
// begin if IsInUnit ( j ) then
66041: LD_VAR 0 3
66045: PPUSH
66046: CALL_OW 310
66050: IFFALSE 66061
// ComExitBuilding ( j ) ;
66052: LD_VAR 0 3
66056: PPUSH
66057: CALL_OW 122
// if not j in mc_healers [ i ] then
66061: LD_VAR 0 3
66065: PUSH
66066: LD_EXP 62
66070: PUSH
66071: LD_VAR 0 2
66075: ARRAY
66076: IN
66077: NOT
66078: IFFALSE 66124
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66080: LD_ADDR_EXP 62
66084: PUSH
66085: LD_EXP 62
66089: PPUSH
66090: LD_VAR 0 2
66094: PUSH
66095: LD_EXP 62
66099: PUSH
66100: LD_VAR 0 2
66104: ARRAY
66105: PUSH
66106: LD_INT 1
66108: PLUS
66109: PUSH
66110: EMPTY
66111: LIST
66112: LIST
66113: PPUSH
66114: LD_VAR 0 3
66118: PPUSH
66119: CALL 20672 0 3
66123: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66124: LD_VAR 0 3
66128: PPUSH
66129: CALL_OW 110
66133: PUSH
66134: LD_INT 102
66136: NONEQUAL
66137: IFFALSE 66151
// SetTag ( j , 102 ) ;
66139: LD_VAR 0 3
66143: PPUSH
66144: LD_INT 102
66146: PPUSH
66147: CALL_OW 109
// Wait ( 3 ) ;
66151: LD_INT 3
66153: PPUSH
66154: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66158: LD_EXP 61
66162: PUSH
66163: LD_VAR 0 2
66167: ARRAY
66168: PUSH
66169: LD_INT 1
66171: ARRAY
66172: IFFALSE 66204
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66174: LD_VAR 0 3
66178: PPUSH
66179: LD_EXP 61
66183: PUSH
66184: LD_VAR 0 2
66188: ARRAY
66189: PUSH
66190: LD_INT 1
66192: ARRAY
66193: PUSH
66194: LD_INT 1
66196: ARRAY
66197: PPUSH
66198: CALL_OW 128
66202: GO 66260
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66204: LD_VAR 0 3
66208: PPUSH
66209: CALL_OW 314
66213: NOT
66214: PUSH
66215: LD_EXP 61
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: PUSH
66226: LD_INT 2
66228: ARRAY
66229: AND
66230: IFFALSE 66260
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66232: LD_VAR 0 3
66236: PPUSH
66237: LD_EXP 61
66241: PUSH
66242: LD_VAR 0 2
66246: ARRAY
66247: PUSH
66248: LD_INT 2
66250: ARRAY
66251: PUSH
66252: LD_INT 1
66254: ARRAY
66255: PPUSH
66256: CALL_OW 128
// end ;
66260: GO 66038
66262: POP
66263: POP
// end ;
66264: GO 65881
66266: POP
66267: POP
// end ;
66268: LD_VAR 0 1
66272: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66273: LD_INT 0
66275: PPUSH
66276: PPUSH
66277: PPUSH
66278: PPUSH
66279: PPUSH
// if not mc_bases then
66280: LD_EXP 58
66284: NOT
66285: IFFALSE 66289
// exit ;
66287: GO 67432
// for i = 1 to mc_bases do
66289: LD_ADDR_VAR 0 2
66293: PUSH
66294: DOUBLE
66295: LD_INT 1
66297: DEC
66298: ST_TO_ADDR
66299: LD_EXP 58
66303: PUSH
66304: FOR_TO
66305: IFFALSE 67430
// begin if mc_scan [ i ] then
66307: LD_EXP 81
66311: PUSH
66312: LD_VAR 0 2
66316: ARRAY
66317: IFFALSE 66321
// continue ;
66319: GO 66304
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66321: LD_EXP 63
66325: PUSH
66326: LD_VAR 0 2
66330: ARRAY
66331: NOT
66332: PUSH
66333: LD_EXP 65
66337: PUSH
66338: LD_VAR 0 2
66342: ARRAY
66343: NOT
66344: AND
66345: PUSH
66346: LD_EXP 64
66350: PUSH
66351: LD_VAR 0 2
66355: ARRAY
66356: AND
66357: IFFALSE 66395
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66359: LD_ADDR_EXP 64
66363: PUSH
66364: LD_EXP 64
66368: PPUSH
66369: LD_VAR 0 2
66373: PPUSH
66374: EMPTY
66375: PPUSH
66376: CALL_OW 1
66380: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66381: LD_VAR 0 2
66385: PPUSH
66386: LD_INT 103
66388: PPUSH
66389: CALL 60566 0 2
// continue ;
66393: GO 66304
// end ; if mc_construct_list [ i ] then
66395: LD_EXP 65
66399: PUSH
66400: LD_VAR 0 2
66404: ARRAY
66405: IFFALSE 66625
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66407: LD_ADDR_VAR 0 4
66411: PUSH
66412: LD_EXP 58
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PPUSH
66423: LD_INT 25
66425: PUSH
66426: LD_INT 2
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PPUSH
66433: CALL_OW 72
66437: PUSH
66438: LD_EXP 60
66442: PUSH
66443: LD_VAR 0 2
66447: ARRAY
66448: DIFF
66449: ST_TO_ADDR
// if not tmp then
66450: LD_VAR 0 4
66454: NOT
66455: IFFALSE 66459
// continue ;
66457: GO 66304
// for j in tmp do
66459: LD_ADDR_VAR 0 3
66463: PUSH
66464: LD_VAR 0 4
66468: PUSH
66469: FOR_IN
66470: IFFALSE 66621
// begin if not mc_builders [ i ] then
66472: LD_EXP 64
66476: PUSH
66477: LD_VAR 0 2
66481: ARRAY
66482: NOT
66483: IFFALSE 66541
// begin SetTag ( j , 103 ) ;
66485: LD_VAR 0 3
66489: PPUSH
66490: LD_INT 103
66492: PPUSH
66493: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66497: LD_ADDR_EXP 64
66501: PUSH
66502: LD_EXP 64
66506: PPUSH
66507: LD_VAR 0 2
66511: PUSH
66512: LD_EXP 64
66516: PUSH
66517: LD_VAR 0 2
66521: ARRAY
66522: PUSH
66523: LD_INT 1
66525: PLUS
66526: PUSH
66527: EMPTY
66528: LIST
66529: LIST
66530: PPUSH
66531: LD_VAR 0 3
66535: PPUSH
66536: CALL 20672 0 3
66540: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66541: LD_VAR 0 3
66545: PPUSH
66546: CALL_OW 310
66550: IFFALSE 66561
// ComExitBuilding ( j ) ;
66552: LD_VAR 0 3
66556: PPUSH
66557: CALL_OW 122
// wait ( 3 ) ;
66561: LD_INT 3
66563: PPUSH
66564: CALL_OW 67
// if not mc_construct_list [ i ] then
66568: LD_EXP 65
66572: PUSH
66573: LD_VAR 0 2
66577: ARRAY
66578: NOT
66579: IFFALSE 66583
// break ;
66581: GO 66621
// if not HasTask ( j ) then
66583: LD_VAR 0 3
66587: PPUSH
66588: CALL_OW 314
66592: NOT
66593: IFFALSE 66619
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66595: LD_VAR 0 3
66599: PPUSH
66600: LD_EXP 65
66604: PUSH
66605: LD_VAR 0 2
66609: ARRAY
66610: PUSH
66611: LD_INT 1
66613: ARRAY
66614: PPUSH
66615: CALL 23523 0 2
// end ;
66619: GO 66469
66621: POP
66622: POP
// end else
66623: GO 67428
// if mc_build_list [ i ] then
66625: LD_EXP 63
66629: PUSH
66630: LD_VAR 0 2
66634: ARRAY
66635: IFFALSE 67428
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66637: LD_ADDR_VAR 0 5
66641: PUSH
66642: LD_EXP 58
66646: PUSH
66647: LD_VAR 0 2
66651: ARRAY
66652: PPUSH
66653: LD_INT 2
66655: PUSH
66656: LD_INT 30
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 30
66668: PUSH
66669: LD_INT 1
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: EMPTY
66677: LIST
66678: LIST
66679: LIST
66680: PPUSH
66681: CALL_OW 72
66685: ST_TO_ADDR
// if depot then
66686: LD_VAR 0 5
66690: IFFALSE 66708
// depot := depot [ 1 ] else
66692: LD_ADDR_VAR 0 5
66696: PUSH
66697: LD_VAR 0 5
66701: PUSH
66702: LD_INT 1
66704: ARRAY
66705: ST_TO_ADDR
66706: GO 66716
// depot := 0 ;
66708: LD_ADDR_VAR 0 5
66712: PUSH
66713: LD_INT 0
66715: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66716: LD_EXP 63
66720: PUSH
66721: LD_VAR 0 2
66725: ARRAY
66726: PUSH
66727: LD_INT 1
66729: ARRAY
66730: PUSH
66731: LD_INT 1
66733: ARRAY
66734: PPUSH
66735: CALL 23353 0 1
66739: PUSH
66740: LD_EXP 58
66744: PUSH
66745: LD_VAR 0 2
66749: ARRAY
66750: PPUSH
66751: LD_INT 2
66753: PUSH
66754: LD_INT 30
66756: PUSH
66757: LD_INT 2
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 30
66766: PUSH
66767: LD_INT 3
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: LIST
66778: PPUSH
66779: CALL_OW 72
66783: NOT
66784: AND
66785: IFFALSE 66890
// begin for j = 1 to mc_build_list [ i ] do
66787: LD_ADDR_VAR 0 3
66791: PUSH
66792: DOUBLE
66793: LD_INT 1
66795: DEC
66796: ST_TO_ADDR
66797: LD_EXP 63
66801: PUSH
66802: LD_VAR 0 2
66806: ARRAY
66807: PUSH
66808: FOR_TO
66809: IFFALSE 66888
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
66811: LD_EXP 63
66815: PUSH
66816: LD_VAR 0 2
66820: ARRAY
66821: PUSH
66822: LD_VAR 0 3
66826: ARRAY
66827: PUSH
66828: LD_INT 1
66830: ARRAY
66831: PUSH
66832: LD_INT 2
66834: EQUAL
66835: IFFALSE 66886
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
66837: LD_ADDR_EXP 63
66841: PUSH
66842: LD_EXP 63
66846: PPUSH
66847: LD_VAR 0 2
66851: PPUSH
66852: LD_EXP 63
66856: PUSH
66857: LD_VAR 0 2
66861: ARRAY
66862: PPUSH
66863: LD_VAR 0 3
66867: PPUSH
66868: LD_INT 1
66870: PPUSH
66871: LD_INT 0
66873: PPUSH
66874: CALL 20090 0 4
66878: PPUSH
66879: CALL_OW 1
66883: ST_TO_ADDR
// break ;
66884: GO 66888
// end ;
66886: GO 66808
66888: POP
66889: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
66890: LD_EXP 63
66894: PUSH
66895: LD_VAR 0 2
66899: ARRAY
66900: PUSH
66901: LD_INT 1
66903: ARRAY
66904: PUSH
66905: LD_INT 1
66907: ARRAY
66908: PUSH
66909: LD_INT 0
66911: EQUAL
66912: PUSH
66913: LD_VAR 0 5
66917: PUSH
66918: LD_VAR 0 5
66922: PPUSH
66923: LD_EXP 63
66927: PUSH
66928: LD_VAR 0 2
66932: ARRAY
66933: PUSH
66934: LD_INT 1
66936: ARRAY
66937: PUSH
66938: LD_INT 1
66940: ARRAY
66941: PPUSH
66942: LD_EXP 63
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: PUSH
66953: LD_INT 1
66955: ARRAY
66956: PUSH
66957: LD_INT 2
66959: ARRAY
66960: PPUSH
66961: LD_EXP 63
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: PUSH
66972: LD_INT 1
66974: ARRAY
66975: PUSH
66976: LD_INT 3
66978: ARRAY
66979: PPUSH
66980: LD_EXP 63
66984: PUSH
66985: LD_VAR 0 2
66989: ARRAY
66990: PUSH
66991: LD_INT 1
66993: ARRAY
66994: PUSH
66995: LD_INT 4
66997: ARRAY
66998: PPUSH
66999: CALL 28069 0 5
67003: AND
67004: OR
67005: IFFALSE 67286
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67007: LD_ADDR_VAR 0 4
67011: PUSH
67012: LD_EXP 58
67016: PUSH
67017: LD_VAR 0 2
67021: ARRAY
67022: PPUSH
67023: LD_INT 25
67025: PUSH
67026: LD_INT 2
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PPUSH
67033: CALL_OW 72
67037: PUSH
67038: LD_EXP 60
67042: PUSH
67043: LD_VAR 0 2
67047: ARRAY
67048: DIFF
67049: ST_TO_ADDR
// if not tmp then
67050: LD_VAR 0 4
67054: NOT
67055: IFFALSE 67059
// continue ;
67057: GO 66304
// for j in tmp do
67059: LD_ADDR_VAR 0 3
67063: PUSH
67064: LD_VAR 0 4
67068: PUSH
67069: FOR_IN
67070: IFFALSE 67282
// begin if not mc_builders [ i ] then
67072: LD_EXP 64
67076: PUSH
67077: LD_VAR 0 2
67081: ARRAY
67082: NOT
67083: IFFALSE 67141
// begin SetTag ( j , 103 ) ;
67085: LD_VAR 0 3
67089: PPUSH
67090: LD_INT 103
67092: PPUSH
67093: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67097: LD_ADDR_EXP 64
67101: PUSH
67102: LD_EXP 64
67106: PPUSH
67107: LD_VAR 0 2
67111: PUSH
67112: LD_EXP 64
67116: PUSH
67117: LD_VAR 0 2
67121: ARRAY
67122: PUSH
67123: LD_INT 1
67125: PLUS
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PPUSH
67131: LD_VAR 0 3
67135: PPUSH
67136: CALL 20672 0 3
67140: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67141: LD_VAR 0 3
67145: PPUSH
67146: CALL_OW 310
67150: IFFALSE 67161
// ComExitBuilding ( j ) ;
67152: LD_VAR 0 3
67156: PPUSH
67157: CALL_OW 122
// wait ( 3 ) ;
67161: LD_INT 3
67163: PPUSH
67164: CALL_OW 67
// if not mc_build_list [ i ] then
67168: LD_EXP 63
67172: PUSH
67173: LD_VAR 0 2
67177: ARRAY
67178: NOT
67179: IFFALSE 67183
// break ;
67181: GO 67282
// if not HasTask ( j ) then
67183: LD_VAR 0 3
67187: PPUSH
67188: CALL_OW 314
67192: NOT
67193: IFFALSE 67280
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67195: LD_VAR 0 3
67199: PPUSH
67200: LD_EXP 63
67204: PUSH
67205: LD_VAR 0 2
67209: ARRAY
67210: PUSH
67211: LD_INT 1
67213: ARRAY
67214: PUSH
67215: LD_INT 1
67217: ARRAY
67218: PPUSH
67219: LD_EXP 63
67223: PUSH
67224: LD_VAR 0 2
67228: ARRAY
67229: PUSH
67230: LD_INT 1
67232: ARRAY
67233: PUSH
67234: LD_INT 2
67236: ARRAY
67237: PPUSH
67238: LD_EXP 63
67242: PUSH
67243: LD_VAR 0 2
67247: ARRAY
67248: PUSH
67249: LD_INT 1
67251: ARRAY
67252: PUSH
67253: LD_INT 3
67255: ARRAY
67256: PPUSH
67257: LD_EXP 63
67261: PUSH
67262: LD_VAR 0 2
67266: ARRAY
67267: PUSH
67268: LD_INT 1
67270: ARRAY
67271: PUSH
67272: LD_INT 4
67274: ARRAY
67275: PPUSH
67276: CALL_OW 145
// end ;
67280: GO 67069
67282: POP
67283: POP
// end else
67284: GO 67428
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67286: LD_EXP 58
67290: PUSH
67291: LD_VAR 0 2
67295: ARRAY
67296: PPUSH
67297: LD_EXP 63
67301: PUSH
67302: LD_VAR 0 2
67306: ARRAY
67307: PUSH
67308: LD_INT 1
67310: ARRAY
67311: PUSH
67312: LD_INT 1
67314: ARRAY
67315: PPUSH
67316: LD_EXP 63
67320: PUSH
67321: LD_VAR 0 2
67325: ARRAY
67326: PUSH
67327: LD_INT 1
67329: ARRAY
67330: PUSH
67331: LD_INT 2
67333: ARRAY
67334: PPUSH
67335: LD_EXP 63
67339: PUSH
67340: LD_VAR 0 2
67344: ARRAY
67345: PUSH
67346: LD_INT 1
67348: ARRAY
67349: PUSH
67350: LD_INT 3
67352: ARRAY
67353: PPUSH
67354: LD_EXP 63
67358: PUSH
67359: LD_VAR 0 2
67363: ARRAY
67364: PUSH
67365: LD_INT 1
67367: ARRAY
67368: PUSH
67369: LD_INT 4
67371: ARRAY
67372: PPUSH
67373: CALL 27423 0 5
67377: NOT
67378: IFFALSE 67428
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67380: LD_ADDR_EXP 63
67384: PUSH
67385: LD_EXP 63
67389: PPUSH
67390: LD_VAR 0 2
67394: PPUSH
67395: LD_EXP 63
67399: PUSH
67400: LD_VAR 0 2
67404: ARRAY
67405: PPUSH
67406: LD_INT 1
67408: PPUSH
67409: LD_INT 1
67411: NEG
67412: PPUSH
67413: LD_INT 0
67415: PPUSH
67416: CALL 20090 0 4
67420: PPUSH
67421: CALL_OW 1
67425: ST_TO_ADDR
// continue ;
67426: GO 66304
// end ; end ; end ;
67428: GO 66304
67430: POP
67431: POP
// end ;
67432: LD_VAR 0 1
67436: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67437: LD_INT 0
67439: PPUSH
67440: PPUSH
67441: PPUSH
67442: PPUSH
67443: PPUSH
67444: PPUSH
// if not mc_bases then
67445: LD_EXP 58
67449: NOT
67450: IFFALSE 67454
// exit ;
67452: GO 67881
// for i = 1 to mc_bases do
67454: LD_ADDR_VAR 0 2
67458: PUSH
67459: DOUBLE
67460: LD_INT 1
67462: DEC
67463: ST_TO_ADDR
67464: LD_EXP 58
67468: PUSH
67469: FOR_TO
67470: IFFALSE 67879
// begin tmp := mc_build_upgrade [ i ] ;
67472: LD_ADDR_VAR 0 4
67476: PUSH
67477: LD_EXP 90
67481: PUSH
67482: LD_VAR 0 2
67486: ARRAY
67487: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67488: LD_ADDR_VAR 0 6
67492: PUSH
67493: LD_EXP 91
67497: PUSH
67498: LD_VAR 0 2
67502: ARRAY
67503: PPUSH
67504: LD_INT 2
67506: PUSH
67507: LD_INT 30
67509: PUSH
67510: LD_INT 6
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 30
67519: PUSH
67520: LD_INT 7
67522: PUSH
67523: EMPTY
67524: LIST
67525: LIST
67526: PUSH
67527: EMPTY
67528: LIST
67529: LIST
67530: LIST
67531: PPUSH
67532: CALL_OW 72
67536: ST_TO_ADDR
// if not tmp and not lab then
67537: LD_VAR 0 4
67541: NOT
67542: PUSH
67543: LD_VAR 0 6
67547: NOT
67548: AND
67549: IFFALSE 67553
// continue ;
67551: GO 67469
// if tmp then
67553: LD_VAR 0 4
67557: IFFALSE 67677
// for j in tmp do
67559: LD_ADDR_VAR 0 3
67563: PUSH
67564: LD_VAR 0 4
67568: PUSH
67569: FOR_IN
67570: IFFALSE 67675
// begin if UpgradeCost ( j ) then
67572: LD_VAR 0 3
67576: PPUSH
67577: CALL 27083 0 1
67581: IFFALSE 67673
// begin ComUpgrade ( j ) ;
67583: LD_VAR 0 3
67587: PPUSH
67588: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67592: LD_ADDR_EXP 90
67596: PUSH
67597: LD_EXP 90
67601: PPUSH
67602: LD_VAR 0 2
67606: PPUSH
67607: LD_EXP 90
67611: PUSH
67612: LD_VAR 0 2
67616: ARRAY
67617: PUSH
67618: LD_VAR 0 3
67622: DIFF
67623: PPUSH
67624: CALL_OW 1
67628: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67629: LD_ADDR_EXP 65
67633: PUSH
67634: LD_EXP 65
67638: PPUSH
67639: LD_VAR 0 2
67643: PUSH
67644: LD_EXP 65
67648: PUSH
67649: LD_VAR 0 2
67653: ARRAY
67654: PUSH
67655: LD_INT 1
67657: PLUS
67658: PUSH
67659: EMPTY
67660: LIST
67661: LIST
67662: PPUSH
67663: LD_VAR 0 3
67667: PPUSH
67668: CALL 20672 0 3
67672: ST_TO_ADDR
// end ; end ;
67673: GO 67569
67675: POP
67676: POP
// if not lab or not mc_lab_upgrade [ i ] then
67677: LD_VAR 0 6
67681: NOT
67682: PUSH
67683: LD_EXP 92
67687: PUSH
67688: LD_VAR 0 2
67692: ARRAY
67693: NOT
67694: OR
67695: IFFALSE 67699
// continue ;
67697: GO 67469
// for j in lab do
67699: LD_ADDR_VAR 0 3
67703: PUSH
67704: LD_VAR 0 6
67708: PUSH
67709: FOR_IN
67710: IFFALSE 67875
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67712: LD_VAR 0 3
67716: PPUSH
67717: CALL_OW 266
67721: PUSH
67722: LD_INT 6
67724: PUSH
67725: LD_INT 7
67727: PUSH
67728: EMPTY
67729: LIST
67730: LIST
67731: IN
67732: PUSH
67733: LD_VAR 0 3
67737: PPUSH
67738: CALL_OW 461
67742: PUSH
67743: LD_INT 1
67745: NONEQUAL
67746: AND
67747: IFFALSE 67873
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67749: LD_VAR 0 3
67753: PPUSH
67754: LD_EXP 92
67758: PUSH
67759: LD_VAR 0 2
67763: ARRAY
67764: PUSH
67765: LD_INT 1
67767: ARRAY
67768: PPUSH
67769: CALL 27288 0 2
67773: IFFALSE 67873
// begin ComCancel ( j ) ;
67775: LD_VAR 0 3
67779: PPUSH
67780: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
67784: LD_VAR 0 3
67788: PPUSH
67789: LD_EXP 92
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: PUSH
67800: LD_INT 1
67802: ARRAY
67803: PPUSH
67804: CALL_OW 207
// if not j in mc_construct_list [ i ] then
67808: LD_VAR 0 3
67812: PUSH
67813: LD_EXP 65
67817: PUSH
67818: LD_VAR 0 2
67822: ARRAY
67823: IN
67824: NOT
67825: IFFALSE 67871
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67827: LD_ADDR_EXP 65
67831: PUSH
67832: LD_EXP 65
67836: PPUSH
67837: LD_VAR 0 2
67841: PUSH
67842: LD_EXP 65
67846: PUSH
67847: LD_VAR 0 2
67851: ARRAY
67852: PUSH
67853: LD_INT 1
67855: PLUS
67856: PUSH
67857: EMPTY
67858: LIST
67859: LIST
67860: PPUSH
67861: LD_VAR 0 3
67865: PPUSH
67866: CALL 20672 0 3
67870: ST_TO_ADDR
// break ;
67871: GO 67875
// end ; end ; end ;
67873: GO 67709
67875: POP
67876: POP
// end ;
67877: GO 67469
67879: POP
67880: POP
// end ;
67881: LD_VAR 0 1
67885: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
67886: LD_INT 0
67888: PPUSH
67889: PPUSH
67890: PPUSH
67891: PPUSH
67892: PPUSH
67893: PPUSH
67894: PPUSH
67895: PPUSH
67896: PPUSH
// if not mc_bases then
67897: LD_EXP 58
67901: NOT
67902: IFFALSE 67906
// exit ;
67904: GO 68311
// for i = 1 to mc_bases do
67906: LD_ADDR_VAR 0 2
67910: PUSH
67911: DOUBLE
67912: LD_INT 1
67914: DEC
67915: ST_TO_ADDR
67916: LD_EXP 58
67920: PUSH
67921: FOR_TO
67922: IFFALSE 68309
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
67924: LD_EXP 66
67928: PUSH
67929: LD_VAR 0 2
67933: ARRAY
67934: NOT
67935: PUSH
67936: LD_EXP 58
67940: PUSH
67941: LD_VAR 0 2
67945: ARRAY
67946: PPUSH
67947: LD_INT 30
67949: PUSH
67950: LD_INT 3
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PPUSH
67957: CALL_OW 72
67961: NOT
67962: OR
67963: IFFALSE 67967
// continue ;
67965: GO 67921
// busy := false ;
67967: LD_ADDR_VAR 0 8
67971: PUSH
67972: LD_INT 0
67974: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67975: LD_ADDR_VAR 0 4
67979: PUSH
67980: LD_EXP 58
67984: PUSH
67985: LD_VAR 0 2
67989: ARRAY
67990: PPUSH
67991: LD_INT 30
67993: PUSH
67994: LD_INT 3
67996: PUSH
67997: EMPTY
67998: LIST
67999: LIST
68000: PPUSH
68001: CALL_OW 72
68005: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68006: LD_ADDR_VAR 0 6
68010: PUSH
68011: LD_EXP 66
68015: PUSH
68016: LD_VAR 0 2
68020: ARRAY
68021: PPUSH
68022: LD_INT 2
68024: PUSH
68025: LD_INT 30
68027: PUSH
68028: LD_INT 32
68030: PUSH
68031: EMPTY
68032: LIST
68033: LIST
68034: PUSH
68035: LD_INT 30
68037: PUSH
68038: LD_INT 33
68040: PUSH
68041: EMPTY
68042: LIST
68043: LIST
68044: PUSH
68045: EMPTY
68046: LIST
68047: LIST
68048: LIST
68049: PPUSH
68050: CALL_OW 72
68054: ST_TO_ADDR
// if not t then
68055: LD_VAR 0 6
68059: NOT
68060: IFFALSE 68064
// continue ;
68062: GO 67921
// for j in tmp do
68064: LD_ADDR_VAR 0 3
68068: PUSH
68069: LD_VAR 0 4
68073: PUSH
68074: FOR_IN
68075: IFFALSE 68105
// if not BuildingStatus ( j ) = bs_idle then
68077: LD_VAR 0 3
68081: PPUSH
68082: CALL_OW 461
68086: PUSH
68087: LD_INT 2
68089: EQUAL
68090: NOT
68091: IFFALSE 68103
// begin busy := true ;
68093: LD_ADDR_VAR 0 8
68097: PUSH
68098: LD_INT 1
68100: ST_TO_ADDR
// break ;
68101: GO 68105
// end ;
68103: GO 68074
68105: POP
68106: POP
// if busy then
68107: LD_VAR 0 8
68111: IFFALSE 68115
// continue ;
68113: GO 67921
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68115: LD_ADDR_VAR 0 7
68119: PUSH
68120: LD_VAR 0 6
68124: PPUSH
68125: LD_INT 35
68127: PUSH
68128: LD_INT 0
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PPUSH
68135: CALL_OW 72
68139: ST_TO_ADDR
// if tw then
68140: LD_VAR 0 7
68144: IFFALSE 68221
// begin tw := tw [ 1 ] ;
68146: LD_ADDR_VAR 0 7
68150: PUSH
68151: LD_VAR 0 7
68155: PUSH
68156: LD_INT 1
68158: ARRAY
68159: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68160: LD_ADDR_VAR 0 9
68164: PUSH
68165: LD_VAR 0 7
68169: PPUSH
68170: LD_EXP 83
68174: PUSH
68175: LD_VAR 0 2
68179: ARRAY
68180: PPUSH
68181: CALL 25642 0 2
68185: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68186: LD_EXP 97
68190: PUSH
68191: LD_VAR 0 2
68195: ARRAY
68196: IFFALSE 68219
// if not weapon in mc_allowed_tower_weapons [ i ] then
68198: LD_VAR 0 9
68202: PUSH
68203: LD_EXP 97
68207: PUSH
68208: LD_VAR 0 2
68212: ARRAY
68213: IN
68214: NOT
68215: IFFALSE 68219
// continue ;
68217: GO 67921
// end else
68219: GO 68284
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68221: LD_ADDR_VAR 0 5
68225: PUSH
68226: LD_EXP 66
68230: PUSH
68231: LD_VAR 0 2
68235: ARRAY
68236: PPUSH
68237: LD_VAR 0 4
68241: PPUSH
68242: CALL 55819 0 2
68246: ST_TO_ADDR
// if not tmp2 then
68247: LD_VAR 0 5
68251: NOT
68252: IFFALSE 68256
// continue ;
68254: GO 67921
// tw := tmp2 [ 1 ] ;
68256: LD_ADDR_VAR 0 7
68260: PUSH
68261: LD_VAR 0 5
68265: PUSH
68266: LD_INT 1
68268: ARRAY
68269: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68270: LD_ADDR_VAR 0 9
68274: PUSH
68275: LD_VAR 0 5
68279: PUSH
68280: LD_INT 2
68282: ARRAY
68283: ST_TO_ADDR
// end ; if not weapon then
68284: LD_VAR 0 9
68288: NOT
68289: IFFALSE 68293
// continue ;
68291: GO 67921
// ComPlaceWeapon ( tw , weapon ) ;
68293: LD_VAR 0 7
68297: PPUSH
68298: LD_VAR 0 9
68302: PPUSH
68303: CALL_OW 148
// end ;
68307: GO 67921
68309: POP
68310: POP
// end ;
68311: LD_VAR 0 1
68315: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68316: LD_INT 0
68318: PPUSH
68319: PPUSH
68320: PPUSH
68321: PPUSH
68322: PPUSH
68323: PPUSH
// if not mc_bases then
68324: LD_EXP 58
68328: NOT
68329: IFFALSE 68333
// exit ;
68331: GO 69345
// for i = 1 to mc_bases do
68333: LD_ADDR_VAR 0 2
68337: PUSH
68338: DOUBLE
68339: LD_INT 1
68341: DEC
68342: ST_TO_ADDR
68343: LD_EXP 58
68347: PUSH
68348: FOR_TO
68349: IFFALSE 69343
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68351: LD_EXP 71
68355: PUSH
68356: LD_VAR 0 2
68360: ARRAY
68361: NOT
68362: PUSH
68363: LD_EXP 71
68367: PUSH
68368: LD_VAR 0 2
68372: ARRAY
68373: PUSH
68374: LD_EXP 72
68378: PUSH
68379: LD_VAR 0 2
68383: ARRAY
68384: EQUAL
68385: OR
68386: IFFALSE 68390
// continue ;
68388: GO 68348
// if mc_miners [ i ] then
68390: LD_EXP 72
68394: PUSH
68395: LD_VAR 0 2
68399: ARRAY
68400: IFFALSE 69030
// begin k := 1 ;
68402: LD_ADDR_VAR 0 4
68406: PUSH
68407: LD_INT 1
68409: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
68410: LD_ADDR_VAR 0 3
68414: PUSH
68415: DOUBLE
68416: LD_EXP 72
68420: PUSH
68421: LD_VAR 0 2
68425: ARRAY
68426: INC
68427: ST_TO_ADDR
68428: LD_INT 1
68430: PUSH
68431: FOR_DOWNTO
68432: IFFALSE 69028
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68434: LD_EXP 72
68438: PUSH
68439: LD_VAR 0 2
68443: ARRAY
68444: PUSH
68445: LD_VAR 0 3
68449: ARRAY
68450: PPUSH
68451: CALL_OW 301
68455: PUSH
68456: LD_EXP 72
68460: PUSH
68461: LD_VAR 0 2
68465: ARRAY
68466: PUSH
68467: LD_VAR 0 3
68471: ARRAY
68472: PPUSH
68473: CALL_OW 257
68477: PUSH
68478: LD_INT 1
68480: NONEQUAL
68481: OR
68482: IFFALSE 68545
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68484: LD_ADDR_VAR 0 5
68488: PUSH
68489: LD_EXP 72
68493: PUSH
68494: LD_VAR 0 2
68498: ARRAY
68499: PUSH
68500: LD_EXP 72
68504: PUSH
68505: LD_VAR 0 2
68509: ARRAY
68510: PUSH
68511: LD_VAR 0 3
68515: ARRAY
68516: DIFF
68517: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68518: LD_ADDR_EXP 72
68522: PUSH
68523: LD_EXP 72
68527: PPUSH
68528: LD_VAR 0 2
68532: PPUSH
68533: LD_VAR 0 5
68537: PPUSH
68538: CALL_OW 1
68542: ST_TO_ADDR
// continue ;
68543: GO 68431
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
68545: LD_EXP 72
68549: PUSH
68550: LD_VAR 0 2
68554: ARRAY
68555: PUSH
68556: LD_VAR 0 3
68560: ARRAY
68561: PPUSH
68562: CALL 20608 0 1
68566: PUSH
68567: LD_EXP 72
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: PUSH
68578: LD_VAR 0 3
68582: ARRAY
68583: PPUSH
68584: CALL_OW 255
68588: PPUSH
68589: LD_EXP 71
68593: PUSH
68594: LD_VAR 0 2
68598: ARRAY
68599: PUSH
68600: LD_VAR 0 4
68604: ARRAY
68605: PUSH
68606: LD_INT 1
68608: ARRAY
68609: PPUSH
68610: LD_EXP 71
68614: PUSH
68615: LD_VAR 0 2
68619: ARRAY
68620: PUSH
68621: LD_VAR 0 4
68625: ARRAY
68626: PUSH
68627: LD_INT 2
68629: ARRAY
68630: PPUSH
68631: LD_INT 15
68633: PPUSH
68634: CALL 21568 0 4
68638: PUSH
68639: LD_INT 4
68641: ARRAY
68642: PUSH
68643: LD_EXP 72
68647: PUSH
68648: LD_VAR 0 2
68652: ARRAY
68653: PUSH
68654: LD_VAR 0 3
68658: ARRAY
68659: PPUSH
68660: LD_INT 10
68662: PPUSH
68663: CALL 23265 0 2
68667: PUSH
68668: LD_INT 4
68670: ARRAY
68671: OR
68672: AND
68673: IFFALSE 68696
// ComStop ( mc_miners [ i ] [ j ] ) ;
68675: LD_EXP 72
68679: PUSH
68680: LD_VAR 0 2
68684: ARRAY
68685: PUSH
68686: LD_VAR 0 3
68690: ARRAY
68691: PPUSH
68692: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
68696: LD_EXP 72
68700: PUSH
68701: LD_VAR 0 2
68705: ARRAY
68706: PUSH
68707: LD_VAR 0 3
68711: ARRAY
68712: PPUSH
68713: CALL_OW 257
68717: PUSH
68718: LD_INT 1
68720: EQUAL
68721: PUSH
68722: LD_EXP 72
68726: PUSH
68727: LD_VAR 0 2
68731: ARRAY
68732: PUSH
68733: LD_VAR 0 3
68737: ARRAY
68738: PPUSH
68739: CALL_OW 459
68743: NOT
68744: AND
68745: PUSH
68746: LD_EXP 72
68750: PUSH
68751: LD_VAR 0 2
68755: ARRAY
68756: PUSH
68757: LD_VAR 0 3
68761: ARRAY
68762: PPUSH
68763: CALL_OW 255
68767: PPUSH
68768: LD_EXP 71
68772: PUSH
68773: LD_VAR 0 2
68777: ARRAY
68778: PUSH
68779: LD_VAR 0 4
68783: ARRAY
68784: PUSH
68785: LD_INT 1
68787: ARRAY
68788: PPUSH
68789: LD_EXP 71
68793: PUSH
68794: LD_VAR 0 2
68798: ARRAY
68799: PUSH
68800: LD_VAR 0 4
68804: ARRAY
68805: PUSH
68806: LD_INT 2
68808: ARRAY
68809: PPUSH
68810: LD_INT 15
68812: PPUSH
68813: CALL 21568 0 4
68817: PUSH
68818: LD_INT 4
68820: ARRAY
68821: PUSH
68822: LD_INT 0
68824: EQUAL
68825: AND
68826: PUSH
68827: LD_EXP 72
68831: PUSH
68832: LD_VAR 0 2
68836: ARRAY
68837: PUSH
68838: LD_VAR 0 3
68842: ARRAY
68843: PPUSH
68844: CALL_OW 314
68848: NOT
68849: AND
68850: IFFALSE 69026
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68852: LD_EXP 72
68856: PUSH
68857: LD_VAR 0 2
68861: ARRAY
68862: PUSH
68863: LD_VAR 0 3
68867: ARRAY
68868: PPUSH
68869: CALL_OW 310
68873: IFFALSE 68896
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68875: LD_EXP 72
68879: PUSH
68880: LD_VAR 0 2
68884: ARRAY
68885: PUSH
68886: LD_VAR 0 3
68890: ARRAY
68891: PPUSH
68892: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68896: LD_EXP 72
68900: PUSH
68901: LD_VAR 0 2
68905: ARRAY
68906: PUSH
68907: LD_VAR 0 3
68911: ARRAY
68912: PPUSH
68913: CALL_OW 314
68917: NOT
68918: IFFALSE 68986
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
68920: LD_EXP 72
68924: PUSH
68925: LD_VAR 0 2
68929: ARRAY
68930: PUSH
68931: LD_VAR 0 3
68935: ARRAY
68936: PPUSH
68937: LD_EXP 71
68941: PUSH
68942: LD_VAR 0 2
68946: ARRAY
68947: PUSH
68948: LD_VAR 0 4
68952: ARRAY
68953: PUSH
68954: LD_INT 1
68956: ARRAY
68957: PPUSH
68958: LD_EXP 71
68962: PUSH
68963: LD_VAR 0 2
68967: ARRAY
68968: PUSH
68969: LD_VAR 0 4
68973: ARRAY
68974: PUSH
68975: LD_INT 2
68977: ARRAY
68978: PPUSH
68979: LD_INT 0
68981: PPUSH
68982: CALL_OW 193
// k := k + 1 ;
68986: LD_ADDR_VAR 0 4
68990: PUSH
68991: LD_VAR 0 4
68995: PUSH
68996: LD_INT 1
68998: PLUS
68999: ST_TO_ADDR
// if k > mc_mines [ i ] then
69000: LD_VAR 0 4
69004: PUSH
69005: LD_EXP 71
69009: PUSH
69010: LD_VAR 0 2
69014: ARRAY
69015: GREATER
69016: IFFALSE 69026
// k := 1 ;
69018: LD_ADDR_VAR 0 4
69022: PUSH
69023: LD_INT 1
69025: ST_TO_ADDR
// end ; end ;
69026: GO 68431
69028: POP
69029: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69030: LD_ADDR_VAR 0 5
69034: PUSH
69035: LD_EXP 58
69039: PUSH
69040: LD_VAR 0 2
69044: ARRAY
69045: PPUSH
69046: LD_INT 2
69048: PUSH
69049: LD_INT 30
69051: PUSH
69052: LD_INT 4
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 30
69061: PUSH
69062: LD_INT 5
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 30
69071: PUSH
69072: LD_INT 32
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: LIST
69083: LIST
69084: PPUSH
69085: CALL_OW 72
69089: ST_TO_ADDR
// if not tmp then
69090: LD_VAR 0 5
69094: NOT
69095: IFFALSE 69099
// continue ;
69097: GO 68348
// list := [ ] ;
69099: LD_ADDR_VAR 0 6
69103: PUSH
69104: EMPTY
69105: ST_TO_ADDR
// for j in tmp do
69106: LD_ADDR_VAR 0 3
69110: PUSH
69111: LD_VAR 0 5
69115: PUSH
69116: FOR_IN
69117: IFFALSE 69186
// begin for k in UnitsInside ( j ) do
69119: LD_ADDR_VAR 0 4
69123: PUSH
69124: LD_VAR 0 3
69128: PPUSH
69129: CALL_OW 313
69133: PUSH
69134: FOR_IN
69135: IFFALSE 69182
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69137: LD_VAR 0 4
69141: PPUSH
69142: CALL_OW 257
69146: PUSH
69147: LD_INT 1
69149: EQUAL
69150: PUSH
69151: LD_VAR 0 4
69155: PPUSH
69156: CALL_OW 459
69160: NOT
69161: AND
69162: IFFALSE 69180
// list := list ^ k ;
69164: LD_ADDR_VAR 0 6
69168: PUSH
69169: LD_VAR 0 6
69173: PUSH
69174: LD_VAR 0 4
69178: ADD
69179: ST_TO_ADDR
69180: GO 69134
69182: POP
69183: POP
// end ;
69184: GO 69116
69186: POP
69187: POP
// list := list diff mc_miners [ i ] ;
69188: LD_ADDR_VAR 0 6
69192: PUSH
69193: LD_VAR 0 6
69197: PUSH
69198: LD_EXP 72
69202: PUSH
69203: LD_VAR 0 2
69207: ARRAY
69208: DIFF
69209: ST_TO_ADDR
// if not list then
69210: LD_VAR 0 6
69214: NOT
69215: IFFALSE 69219
// continue ;
69217: GO 68348
// k := mc_mines [ i ] - mc_miners [ i ] ;
69219: LD_ADDR_VAR 0 4
69223: PUSH
69224: LD_EXP 71
69228: PUSH
69229: LD_VAR 0 2
69233: ARRAY
69234: PUSH
69235: LD_EXP 72
69239: PUSH
69240: LD_VAR 0 2
69244: ARRAY
69245: MINUS
69246: ST_TO_ADDR
// if k > list then
69247: LD_VAR 0 4
69251: PUSH
69252: LD_VAR 0 6
69256: GREATER
69257: IFFALSE 69269
// k := list ;
69259: LD_ADDR_VAR 0 4
69263: PUSH
69264: LD_VAR 0 6
69268: ST_TO_ADDR
// for j = 1 to k do
69269: LD_ADDR_VAR 0 3
69273: PUSH
69274: DOUBLE
69275: LD_INT 1
69277: DEC
69278: ST_TO_ADDR
69279: LD_VAR 0 4
69283: PUSH
69284: FOR_TO
69285: IFFALSE 69339
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69287: LD_ADDR_EXP 72
69291: PUSH
69292: LD_EXP 72
69296: PPUSH
69297: LD_VAR 0 2
69301: PUSH
69302: LD_EXP 72
69306: PUSH
69307: LD_VAR 0 2
69311: ARRAY
69312: PUSH
69313: LD_INT 1
69315: PLUS
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: PPUSH
69321: LD_VAR 0 6
69325: PUSH
69326: LD_VAR 0 3
69330: ARRAY
69331: PPUSH
69332: CALL 20672 0 3
69336: ST_TO_ADDR
69337: GO 69284
69339: POP
69340: POP
// end ;
69341: GO 68348
69343: POP
69344: POP
// end ;
69345: LD_VAR 0 1
69349: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69350: LD_INT 0
69352: PPUSH
69353: PPUSH
69354: PPUSH
69355: PPUSH
69356: PPUSH
69357: PPUSH
69358: PPUSH
69359: PPUSH
69360: PPUSH
69361: PPUSH
// if not mc_bases then
69362: LD_EXP 58
69366: NOT
69367: IFFALSE 69371
// exit ;
69369: GO 71102
// for i = 1 to mc_bases do
69371: LD_ADDR_VAR 0 2
69375: PUSH
69376: DOUBLE
69377: LD_INT 1
69379: DEC
69380: ST_TO_ADDR
69381: LD_EXP 58
69385: PUSH
69386: FOR_TO
69387: IFFALSE 71100
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69389: LD_EXP 58
69393: PUSH
69394: LD_VAR 0 2
69398: ARRAY
69399: NOT
69400: PUSH
69401: LD_EXP 65
69405: PUSH
69406: LD_VAR 0 2
69410: ARRAY
69411: OR
69412: IFFALSE 69416
// continue ;
69414: GO 69386
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69416: LD_EXP 74
69420: PUSH
69421: LD_VAR 0 2
69425: ARRAY
69426: NOT
69427: PUSH
69428: LD_EXP 75
69432: PUSH
69433: LD_VAR 0 2
69437: ARRAY
69438: AND
69439: IFFALSE 69477
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69441: LD_ADDR_EXP 75
69445: PUSH
69446: LD_EXP 75
69450: PPUSH
69451: LD_VAR 0 2
69455: PPUSH
69456: EMPTY
69457: PPUSH
69458: CALL_OW 1
69462: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69463: LD_VAR 0 2
69467: PPUSH
69468: LD_INT 107
69470: PPUSH
69471: CALL 60566 0 2
// continue ;
69475: GO 69386
// end ; target := [ ] ;
69477: LD_ADDR_VAR 0 6
69481: PUSH
69482: EMPTY
69483: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69484: LD_ADDR_VAR 0 3
69488: PUSH
69489: DOUBLE
69490: LD_EXP 74
69494: PUSH
69495: LD_VAR 0 2
69499: ARRAY
69500: INC
69501: ST_TO_ADDR
69502: LD_INT 1
69504: PUSH
69505: FOR_DOWNTO
69506: IFFALSE 69766
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69508: LD_EXP 74
69512: PUSH
69513: LD_VAR 0 2
69517: ARRAY
69518: PUSH
69519: LD_VAR 0 3
69523: ARRAY
69524: PUSH
69525: LD_INT 2
69527: ARRAY
69528: PPUSH
69529: LD_EXP 74
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PUSH
69540: LD_VAR 0 3
69544: ARRAY
69545: PUSH
69546: LD_INT 3
69548: ARRAY
69549: PPUSH
69550: CALL_OW 488
69554: PUSH
69555: LD_EXP 74
69559: PUSH
69560: LD_VAR 0 2
69564: ARRAY
69565: PUSH
69566: LD_VAR 0 3
69570: ARRAY
69571: PUSH
69572: LD_INT 2
69574: ARRAY
69575: PPUSH
69576: LD_EXP 74
69580: PUSH
69581: LD_VAR 0 2
69585: ARRAY
69586: PUSH
69587: LD_VAR 0 3
69591: ARRAY
69592: PUSH
69593: LD_INT 3
69595: ARRAY
69596: PPUSH
69597: CALL_OW 284
69601: PUSH
69602: LD_INT 0
69604: EQUAL
69605: AND
69606: IFFALSE 69661
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69608: LD_ADDR_VAR 0 5
69612: PUSH
69613: LD_EXP 74
69617: PUSH
69618: LD_VAR 0 2
69622: ARRAY
69623: PPUSH
69624: LD_VAR 0 3
69628: PPUSH
69629: CALL_OW 3
69633: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69634: LD_ADDR_EXP 74
69638: PUSH
69639: LD_EXP 74
69643: PPUSH
69644: LD_VAR 0 2
69648: PPUSH
69649: LD_VAR 0 5
69653: PPUSH
69654: CALL_OW 1
69658: ST_TO_ADDR
// continue ;
69659: GO 69505
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69661: LD_EXP 58
69665: PUSH
69666: LD_VAR 0 2
69670: ARRAY
69671: PUSH
69672: LD_INT 1
69674: ARRAY
69675: PPUSH
69676: CALL_OW 255
69680: PPUSH
69681: LD_EXP 74
69685: PUSH
69686: LD_VAR 0 2
69690: ARRAY
69691: PUSH
69692: LD_VAR 0 3
69696: ARRAY
69697: PUSH
69698: LD_INT 2
69700: ARRAY
69701: PPUSH
69702: LD_EXP 74
69706: PUSH
69707: LD_VAR 0 2
69711: ARRAY
69712: PUSH
69713: LD_VAR 0 3
69717: ARRAY
69718: PUSH
69719: LD_INT 3
69721: ARRAY
69722: PPUSH
69723: LD_INT 30
69725: PPUSH
69726: CALL 21568 0 4
69730: PUSH
69731: LD_INT 4
69733: ARRAY
69734: PUSH
69735: LD_INT 0
69737: EQUAL
69738: IFFALSE 69764
// begin target := mc_crates [ i ] [ j ] ;
69740: LD_ADDR_VAR 0 6
69744: PUSH
69745: LD_EXP 74
69749: PUSH
69750: LD_VAR 0 2
69754: ARRAY
69755: PUSH
69756: LD_VAR 0 3
69760: ARRAY
69761: ST_TO_ADDR
// break ;
69762: GO 69766
// end ; end ;
69764: GO 69505
69766: POP
69767: POP
// if not target then
69768: LD_VAR 0 6
69772: NOT
69773: IFFALSE 69777
// continue ;
69775: GO 69386
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69777: LD_ADDR_VAR 0 7
69781: PUSH
69782: LD_EXP 77
69786: PUSH
69787: LD_VAR 0 2
69791: ARRAY
69792: PPUSH
69793: LD_INT 2
69795: PUSH
69796: LD_INT 3
69798: PUSH
69799: LD_INT 58
69801: PUSH
69802: EMPTY
69803: LIST
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 61
69811: PUSH
69812: EMPTY
69813: LIST
69814: PUSH
69815: LD_INT 33
69817: PUSH
69818: LD_INT 5
69820: PUSH
69821: EMPTY
69822: LIST
69823: LIST
69824: PUSH
69825: LD_INT 33
69827: PUSH
69828: LD_INT 3
69830: PUSH
69831: EMPTY
69832: LIST
69833: LIST
69834: PUSH
69835: EMPTY
69836: LIST
69837: LIST
69838: LIST
69839: LIST
69840: LIST
69841: PUSH
69842: LD_INT 2
69844: PUSH
69845: LD_INT 34
69847: PUSH
69848: LD_INT 32
69850: PUSH
69851: EMPTY
69852: LIST
69853: LIST
69854: PUSH
69855: LD_INT 34
69857: PUSH
69858: LD_INT 51
69860: PUSH
69861: EMPTY
69862: LIST
69863: LIST
69864: PUSH
69865: LD_INT 34
69867: PUSH
69868: LD_INT 12
69870: PUSH
69871: EMPTY
69872: LIST
69873: LIST
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: LIST
69879: LIST
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PPUSH
69885: CALL_OW 72
69889: ST_TO_ADDR
// if not cargo then
69890: LD_VAR 0 7
69894: NOT
69895: IFFALSE 70538
// begin if mc_crates_collector [ i ] < 5 then
69897: LD_EXP 75
69901: PUSH
69902: LD_VAR 0 2
69906: ARRAY
69907: PUSH
69908: LD_INT 5
69910: LESS
69911: IFFALSE 70277
// begin if mc_ape [ i ] then
69913: LD_EXP 87
69917: PUSH
69918: LD_VAR 0 2
69922: ARRAY
69923: IFFALSE 69970
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69925: LD_ADDR_VAR 0 5
69929: PUSH
69930: LD_EXP 87
69934: PUSH
69935: LD_VAR 0 2
69939: ARRAY
69940: PPUSH
69941: LD_INT 25
69943: PUSH
69944: LD_INT 16
69946: PUSH
69947: EMPTY
69948: LIST
69949: LIST
69950: PUSH
69951: LD_INT 24
69953: PUSH
69954: LD_INT 750
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: PUSH
69961: EMPTY
69962: LIST
69963: LIST
69964: PPUSH
69965: CALL_OW 72
69969: ST_TO_ADDR
// if not tmp then
69970: LD_VAR 0 5
69974: NOT
69975: IFFALSE 70022
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
69977: LD_ADDR_VAR 0 5
69981: PUSH
69982: LD_EXP 58
69986: PUSH
69987: LD_VAR 0 2
69991: ARRAY
69992: PPUSH
69993: LD_INT 25
69995: PUSH
69996: LD_INT 2
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 24
70005: PUSH
70006: LD_INT 750
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PUSH
70013: EMPTY
70014: LIST
70015: LIST
70016: PPUSH
70017: CALL_OW 72
70021: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70022: LD_EXP 87
70026: PUSH
70027: LD_VAR 0 2
70031: ARRAY
70032: PUSH
70033: LD_EXP 58
70037: PUSH
70038: LD_VAR 0 2
70042: ARRAY
70043: PPUSH
70044: LD_INT 25
70046: PUSH
70047: LD_INT 2
70049: PUSH
70050: EMPTY
70051: LIST
70052: LIST
70053: PUSH
70054: LD_INT 24
70056: PUSH
70057: LD_INT 750
70059: PUSH
70060: EMPTY
70061: LIST
70062: LIST
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PPUSH
70068: CALL_OW 72
70072: AND
70073: PUSH
70074: LD_VAR 0 5
70078: PUSH
70079: LD_INT 5
70081: LESS
70082: AND
70083: IFFALSE 70165
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70085: LD_ADDR_VAR 0 3
70089: PUSH
70090: LD_EXP 58
70094: PUSH
70095: LD_VAR 0 2
70099: ARRAY
70100: PPUSH
70101: LD_INT 25
70103: PUSH
70104: LD_INT 2
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 24
70113: PUSH
70114: LD_INT 750
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PPUSH
70125: CALL_OW 72
70129: PUSH
70130: FOR_IN
70131: IFFALSE 70163
// begin tmp := tmp union j ;
70133: LD_ADDR_VAR 0 5
70137: PUSH
70138: LD_VAR 0 5
70142: PUSH
70143: LD_VAR 0 3
70147: UNION
70148: ST_TO_ADDR
// if tmp >= 5 then
70149: LD_VAR 0 5
70153: PUSH
70154: LD_INT 5
70156: GREATEREQUAL
70157: IFFALSE 70161
// break ;
70159: GO 70163
// end ;
70161: GO 70130
70163: POP
70164: POP
// end ; if not tmp then
70165: LD_VAR 0 5
70169: NOT
70170: IFFALSE 70174
// continue ;
70172: GO 69386
// for j in tmp do
70174: LD_ADDR_VAR 0 3
70178: PUSH
70179: LD_VAR 0 5
70183: PUSH
70184: FOR_IN
70185: IFFALSE 70275
// if not GetTag ( j ) then
70187: LD_VAR 0 3
70191: PPUSH
70192: CALL_OW 110
70196: NOT
70197: IFFALSE 70273
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70199: LD_ADDR_EXP 75
70203: PUSH
70204: LD_EXP 75
70208: PPUSH
70209: LD_VAR 0 2
70213: PUSH
70214: LD_EXP 75
70218: PUSH
70219: LD_VAR 0 2
70223: ARRAY
70224: PUSH
70225: LD_INT 1
70227: PLUS
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PPUSH
70233: LD_VAR 0 3
70237: PPUSH
70238: CALL 20672 0 3
70242: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70243: LD_VAR 0 3
70247: PPUSH
70248: LD_INT 107
70250: PPUSH
70251: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70255: LD_EXP 75
70259: PUSH
70260: LD_VAR 0 2
70264: ARRAY
70265: PUSH
70266: LD_INT 5
70268: GREATEREQUAL
70269: IFFALSE 70273
// break ;
70271: GO 70275
// end ;
70273: GO 70184
70275: POP
70276: POP
// end ; if mc_crates_collector [ i ] and target then
70277: LD_EXP 75
70281: PUSH
70282: LD_VAR 0 2
70286: ARRAY
70287: PUSH
70288: LD_VAR 0 6
70292: AND
70293: IFFALSE 70536
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70295: LD_EXP 75
70299: PUSH
70300: LD_VAR 0 2
70304: ARRAY
70305: PUSH
70306: LD_VAR 0 6
70310: PUSH
70311: LD_INT 1
70313: ARRAY
70314: LESS
70315: IFFALSE 70335
// tmp := mc_crates_collector [ i ] else
70317: LD_ADDR_VAR 0 5
70321: PUSH
70322: LD_EXP 75
70326: PUSH
70327: LD_VAR 0 2
70331: ARRAY
70332: ST_TO_ADDR
70333: GO 70349
// tmp := target [ 1 ] ;
70335: LD_ADDR_VAR 0 5
70339: PUSH
70340: LD_VAR 0 6
70344: PUSH
70345: LD_INT 1
70347: ARRAY
70348: ST_TO_ADDR
// k := 0 ;
70349: LD_ADDR_VAR 0 4
70353: PUSH
70354: LD_INT 0
70356: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70357: LD_ADDR_VAR 0 3
70361: PUSH
70362: LD_EXP 75
70366: PUSH
70367: LD_VAR 0 2
70371: ARRAY
70372: PUSH
70373: FOR_IN
70374: IFFALSE 70534
// begin k := k + 1 ;
70376: LD_ADDR_VAR 0 4
70380: PUSH
70381: LD_VAR 0 4
70385: PUSH
70386: LD_INT 1
70388: PLUS
70389: ST_TO_ADDR
// if k > tmp then
70390: LD_VAR 0 4
70394: PUSH
70395: LD_VAR 0 5
70399: GREATER
70400: IFFALSE 70404
// break ;
70402: GO 70534
// if not GetClass ( j ) in [ 2 , 16 ] then
70404: LD_VAR 0 3
70408: PPUSH
70409: CALL_OW 257
70413: PUSH
70414: LD_INT 2
70416: PUSH
70417: LD_INT 16
70419: PUSH
70420: EMPTY
70421: LIST
70422: LIST
70423: IN
70424: NOT
70425: IFFALSE 70478
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70427: LD_ADDR_EXP 75
70431: PUSH
70432: LD_EXP 75
70436: PPUSH
70437: LD_VAR 0 2
70441: PPUSH
70442: LD_EXP 75
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: PUSH
70453: LD_VAR 0 3
70457: DIFF
70458: PPUSH
70459: CALL_OW 1
70463: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70464: LD_VAR 0 3
70468: PPUSH
70469: LD_INT 0
70471: PPUSH
70472: CALL_OW 109
// continue ;
70476: GO 70373
// end ; if IsInUnit ( j ) then
70478: LD_VAR 0 3
70482: PPUSH
70483: CALL_OW 310
70487: IFFALSE 70498
// ComExitBuilding ( j ) ;
70489: LD_VAR 0 3
70493: PPUSH
70494: CALL_OW 122
// wait ( 3 ) ;
70498: LD_INT 3
70500: PPUSH
70501: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70505: LD_VAR 0 3
70509: PPUSH
70510: LD_VAR 0 6
70514: PUSH
70515: LD_INT 2
70517: ARRAY
70518: PPUSH
70519: LD_VAR 0 6
70523: PUSH
70524: LD_INT 3
70526: ARRAY
70527: PPUSH
70528: CALL_OW 117
// end ;
70532: GO 70373
70534: POP
70535: POP
// end ; end else
70536: GO 71098
// begin for j in cargo do
70538: LD_ADDR_VAR 0 3
70542: PUSH
70543: LD_VAR 0 7
70547: PUSH
70548: FOR_IN
70549: IFFALSE 71096
// begin if GetTag ( j ) <> 0 then
70551: LD_VAR 0 3
70555: PPUSH
70556: CALL_OW 110
70560: PUSH
70561: LD_INT 0
70563: NONEQUAL
70564: IFFALSE 70568
// continue ;
70566: GO 70548
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70568: LD_VAR 0 3
70572: PPUSH
70573: CALL_OW 256
70577: PUSH
70578: LD_INT 1000
70580: LESS
70581: PUSH
70582: LD_VAR 0 3
70586: PPUSH
70587: LD_EXP 82
70591: PUSH
70592: LD_VAR 0 2
70596: ARRAY
70597: PPUSH
70598: CALL_OW 308
70602: NOT
70603: AND
70604: IFFALSE 70626
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70606: LD_VAR 0 3
70610: PPUSH
70611: LD_EXP 82
70615: PUSH
70616: LD_VAR 0 2
70620: ARRAY
70621: PPUSH
70622: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70626: LD_VAR 0 3
70630: PPUSH
70631: CALL_OW 256
70635: PUSH
70636: LD_INT 1000
70638: LESS
70639: PUSH
70640: LD_VAR 0 3
70644: PPUSH
70645: LD_EXP 82
70649: PUSH
70650: LD_VAR 0 2
70654: ARRAY
70655: PPUSH
70656: CALL_OW 308
70660: AND
70661: IFFALSE 70665
// continue ;
70663: GO 70548
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70665: LD_VAR 0 3
70669: PPUSH
70670: CALL_OW 262
70674: PUSH
70675: LD_INT 2
70677: EQUAL
70678: PUSH
70679: LD_VAR 0 3
70683: PPUSH
70684: CALL_OW 261
70688: PUSH
70689: LD_INT 15
70691: LESS
70692: AND
70693: IFFALSE 70697
// continue ;
70695: GO 70548
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70697: LD_VAR 0 3
70701: PPUSH
70702: CALL_OW 262
70706: PUSH
70707: LD_INT 1
70709: EQUAL
70710: PUSH
70711: LD_VAR 0 3
70715: PPUSH
70716: CALL_OW 261
70720: PUSH
70721: LD_INT 10
70723: LESS
70724: AND
70725: IFFALSE 71035
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70727: LD_ADDR_VAR 0 8
70731: PUSH
70732: LD_EXP 58
70736: PUSH
70737: LD_VAR 0 2
70741: ARRAY
70742: PPUSH
70743: LD_INT 2
70745: PUSH
70746: LD_INT 30
70748: PUSH
70749: LD_INT 0
70751: PUSH
70752: EMPTY
70753: LIST
70754: LIST
70755: PUSH
70756: LD_INT 30
70758: PUSH
70759: LD_INT 1
70761: PUSH
70762: EMPTY
70763: LIST
70764: LIST
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: LIST
70770: PPUSH
70771: CALL_OW 72
70775: ST_TO_ADDR
// if not depot then
70776: LD_VAR 0 8
70780: NOT
70781: IFFALSE 70785
// continue ;
70783: GO 70548
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70785: LD_VAR 0 3
70789: PPUSH
70790: LD_VAR 0 8
70794: PPUSH
70795: LD_VAR 0 3
70799: PPUSH
70800: CALL_OW 74
70804: PPUSH
70805: CALL_OW 296
70809: PUSH
70810: LD_INT 6
70812: LESS
70813: IFFALSE 70829
// SetFuel ( j , 100 ) else
70815: LD_VAR 0 3
70819: PPUSH
70820: LD_INT 100
70822: PPUSH
70823: CALL_OW 240
70827: GO 71035
// if GetFuel ( j ) = 0 then
70829: LD_VAR 0 3
70833: PPUSH
70834: CALL_OW 261
70838: PUSH
70839: LD_INT 0
70841: EQUAL
70842: IFFALSE 71035
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70844: LD_ADDR_EXP 77
70848: PUSH
70849: LD_EXP 77
70853: PPUSH
70854: LD_VAR 0 2
70858: PPUSH
70859: LD_EXP 77
70863: PUSH
70864: LD_VAR 0 2
70868: ARRAY
70869: PUSH
70870: LD_VAR 0 3
70874: DIFF
70875: PPUSH
70876: CALL_OW 1
70880: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70881: LD_VAR 0 3
70885: PPUSH
70886: CALL_OW 263
70890: PUSH
70891: LD_INT 1
70893: EQUAL
70894: IFFALSE 70910
// ComExitVehicle ( IsInUnit ( j ) ) ;
70896: LD_VAR 0 3
70900: PPUSH
70901: CALL_OW 310
70905: PPUSH
70906: CALL_OW 121
// if GetControl ( j ) = control_remote then
70910: LD_VAR 0 3
70914: PPUSH
70915: CALL_OW 263
70919: PUSH
70920: LD_INT 2
70922: EQUAL
70923: IFFALSE 70934
// ComUnlink ( j ) ;
70925: LD_VAR 0 3
70929: PPUSH
70930: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
70934: LD_ADDR_VAR 0 9
70938: PUSH
70939: LD_VAR 0 2
70943: PPUSH
70944: LD_INT 3
70946: PPUSH
70947: CALL 80139 0 2
70951: ST_TO_ADDR
// if fac then
70952: LD_VAR 0 9
70956: IFFALSE 71033
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
70958: LD_ADDR_VAR 0 10
70962: PUSH
70963: LD_VAR 0 9
70967: PPUSH
70968: LD_VAR 0 3
70972: PPUSH
70973: CALL_OW 265
70977: PPUSH
70978: LD_VAR 0 3
70982: PPUSH
70983: CALL_OW 262
70987: PPUSH
70988: LD_VAR 0 3
70992: PPUSH
70993: CALL_OW 263
70997: PPUSH
70998: LD_VAR 0 3
71002: PPUSH
71003: CALL_OW 264
71007: PPUSH
71008: CALL 18272 0 5
71012: ST_TO_ADDR
// if components then
71013: LD_VAR 0 10
71017: IFFALSE 71033
// MC_InsertProduceList ( i , components ) ;
71019: LD_VAR 0 2
71023: PPUSH
71024: LD_VAR 0 10
71028: PPUSH
71029: CALL 79767 0 2
// end ; continue ;
71033: GO 70548
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71035: LD_VAR 0 3
71039: PPUSH
71040: LD_INT 1
71042: PPUSH
71043: CALL_OW 289
71047: PUSH
71048: LD_INT 100
71050: LESS
71051: PUSH
71052: LD_VAR 0 3
71056: PPUSH
71057: CALL_OW 314
71061: NOT
71062: AND
71063: IFFALSE 71092
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71065: LD_VAR 0 3
71069: PPUSH
71070: LD_VAR 0 6
71074: PUSH
71075: LD_INT 2
71077: ARRAY
71078: PPUSH
71079: LD_VAR 0 6
71083: PUSH
71084: LD_INT 3
71086: ARRAY
71087: PPUSH
71088: CALL_OW 117
// break ;
71092: GO 71096
// end ;
71094: GO 70548
71096: POP
71097: POP
// end ; end ;
71098: GO 69386
71100: POP
71101: POP
// end ;
71102: LD_VAR 0 1
71106: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71107: LD_INT 0
71109: PPUSH
71110: PPUSH
71111: PPUSH
71112: PPUSH
// if not mc_bases then
71113: LD_EXP 58
71117: NOT
71118: IFFALSE 71122
// exit ;
71120: GO 71283
// for i = 1 to mc_bases do
71122: LD_ADDR_VAR 0 2
71126: PUSH
71127: DOUBLE
71128: LD_INT 1
71130: DEC
71131: ST_TO_ADDR
71132: LD_EXP 58
71136: PUSH
71137: FOR_TO
71138: IFFALSE 71281
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71140: LD_ADDR_VAR 0 4
71144: PUSH
71145: LD_EXP 77
71149: PUSH
71150: LD_VAR 0 2
71154: ARRAY
71155: PUSH
71156: LD_EXP 80
71160: PUSH
71161: LD_VAR 0 2
71165: ARRAY
71166: UNION
71167: PPUSH
71168: LD_INT 33
71170: PUSH
71171: LD_INT 2
71173: PUSH
71174: EMPTY
71175: LIST
71176: LIST
71177: PPUSH
71178: CALL_OW 72
71182: ST_TO_ADDR
// if tmp then
71183: LD_VAR 0 4
71187: IFFALSE 71279
// for j in tmp do
71189: LD_ADDR_VAR 0 3
71193: PUSH
71194: LD_VAR 0 4
71198: PUSH
71199: FOR_IN
71200: IFFALSE 71277
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71202: LD_VAR 0 3
71206: PPUSH
71207: CALL_OW 312
71211: NOT
71212: PUSH
71213: LD_VAR 0 3
71217: PPUSH
71218: CALL_OW 256
71222: PUSH
71223: LD_INT 250
71225: GREATEREQUAL
71226: AND
71227: IFFALSE 71240
// Connect ( j ) else
71229: LD_VAR 0 3
71233: PPUSH
71234: CALL 23605 0 1
71238: GO 71275
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71240: LD_VAR 0 3
71244: PPUSH
71245: CALL_OW 256
71249: PUSH
71250: LD_INT 250
71252: LESS
71253: PUSH
71254: LD_VAR 0 3
71258: PPUSH
71259: CALL_OW 312
71263: AND
71264: IFFALSE 71275
// ComUnlink ( j ) ;
71266: LD_VAR 0 3
71270: PPUSH
71271: CALL_OW 136
71275: GO 71199
71277: POP
71278: POP
// end ;
71279: GO 71137
71281: POP
71282: POP
// end ;
71283: LD_VAR 0 1
71287: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71288: LD_INT 0
71290: PPUSH
71291: PPUSH
71292: PPUSH
71293: PPUSH
71294: PPUSH
// if not mc_bases then
71295: LD_EXP 58
71299: NOT
71300: IFFALSE 71304
// exit ;
71302: GO 71764
// for i = 1 to mc_bases do
71304: LD_ADDR_VAR 0 2
71308: PUSH
71309: DOUBLE
71310: LD_INT 1
71312: DEC
71313: ST_TO_ADDR
71314: LD_EXP 58
71318: PUSH
71319: FOR_TO
71320: IFFALSE 71762
// begin if not mc_produce [ i ] then
71322: LD_EXP 79
71326: PUSH
71327: LD_VAR 0 2
71331: ARRAY
71332: NOT
71333: IFFALSE 71337
// continue ;
71335: GO 71319
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71337: LD_ADDR_VAR 0 5
71341: PUSH
71342: LD_EXP 58
71346: PUSH
71347: LD_VAR 0 2
71351: ARRAY
71352: PPUSH
71353: LD_INT 30
71355: PUSH
71356: LD_INT 3
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PPUSH
71363: CALL_OW 72
71367: ST_TO_ADDR
// if not fac then
71368: LD_VAR 0 5
71372: NOT
71373: IFFALSE 71377
// continue ;
71375: GO 71319
// for j in fac do
71377: LD_ADDR_VAR 0 3
71381: PUSH
71382: LD_VAR 0 5
71386: PUSH
71387: FOR_IN
71388: IFFALSE 71758
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
71390: LD_VAR 0 3
71394: PPUSH
71395: CALL_OW 461
71399: PUSH
71400: LD_INT 2
71402: NONEQUAL
71403: PUSH
71404: LD_VAR 0 3
71408: PPUSH
71409: LD_INT 15
71411: PPUSH
71412: CALL 23265 0 2
71416: PUSH
71417: LD_INT 4
71419: ARRAY
71420: OR
71421: PUSH
71422: LD_VAR 0 3
71426: PPUSH
71427: CALL_OW 313
71431: PUSH
71432: LD_INT 0
71434: EQUAL
71435: OR
71436: IFFALSE 71440
// continue ;
71438: GO 71387
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71440: LD_VAR 0 3
71444: PPUSH
71445: LD_EXP 79
71449: PUSH
71450: LD_VAR 0 2
71454: ARRAY
71455: PUSH
71456: LD_INT 1
71458: ARRAY
71459: PUSH
71460: LD_INT 1
71462: ARRAY
71463: PPUSH
71464: LD_EXP 79
71468: PUSH
71469: LD_VAR 0 2
71473: ARRAY
71474: PUSH
71475: LD_INT 1
71477: ARRAY
71478: PUSH
71479: LD_INT 2
71481: ARRAY
71482: PPUSH
71483: LD_EXP 79
71487: PUSH
71488: LD_VAR 0 2
71492: ARRAY
71493: PUSH
71494: LD_INT 1
71496: ARRAY
71497: PUSH
71498: LD_INT 3
71500: ARRAY
71501: PPUSH
71502: LD_EXP 79
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: PUSH
71513: LD_INT 1
71515: ARRAY
71516: PUSH
71517: LD_INT 4
71519: ARRAY
71520: PPUSH
71521: CALL_OW 448
71525: PUSH
71526: LD_VAR 0 3
71530: PPUSH
71531: LD_EXP 79
71535: PUSH
71536: LD_VAR 0 2
71540: ARRAY
71541: PUSH
71542: LD_INT 1
71544: ARRAY
71545: PUSH
71546: LD_INT 1
71548: ARRAY
71549: PUSH
71550: LD_EXP 79
71554: PUSH
71555: LD_VAR 0 2
71559: ARRAY
71560: PUSH
71561: LD_INT 1
71563: ARRAY
71564: PUSH
71565: LD_INT 2
71567: ARRAY
71568: PUSH
71569: LD_EXP 79
71573: PUSH
71574: LD_VAR 0 2
71578: ARRAY
71579: PUSH
71580: LD_INT 1
71582: ARRAY
71583: PUSH
71584: LD_INT 3
71586: ARRAY
71587: PUSH
71588: LD_EXP 79
71592: PUSH
71593: LD_VAR 0 2
71597: ARRAY
71598: PUSH
71599: LD_INT 1
71601: ARRAY
71602: PUSH
71603: LD_INT 4
71605: ARRAY
71606: PUSH
71607: EMPTY
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: PPUSH
71613: CALL 26936 0 2
71617: AND
71618: IFFALSE 71756
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71620: LD_VAR 0 3
71624: PPUSH
71625: LD_EXP 79
71629: PUSH
71630: LD_VAR 0 2
71634: ARRAY
71635: PUSH
71636: LD_INT 1
71638: ARRAY
71639: PUSH
71640: LD_INT 1
71642: ARRAY
71643: PPUSH
71644: LD_EXP 79
71648: PUSH
71649: LD_VAR 0 2
71653: ARRAY
71654: PUSH
71655: LD_INT 1
71657: ARRAY
71658: PUSH
71659: LD_INT 2
71661: ARRAY
71662: PPUSH
71663: LD_EXP 79
71667: PUSH
71668: LD_VAR 0 2
71672: ARRAY
71673: PUSH
71674: LD_INT 1
71676: ARRAY
71677: PUSH
71678: LD_INT 3
71680: ARRAY
71681: PPUSH
71682: LD_EXP 79
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: PUSH
71693: LD_INT 1
71695: ARRAY
71696: PUSH
71697: LD_INT 4
71699: ARRAY
71700: PPUSH
71701: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71705: LD_ADDR_VAR 0 4
71709: PUSH
71710: LD_EXP 79
71714: PUSH
71715: LD_VAR 0 2
71719: ARRAY
71720: PPUSH
71721: LD_INT 1
71723: PPUSH
71724: CALL_OW 3
71728: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71729: LD_ADDR_EXP 79
71733: PUSH
71734: LD_EXP 79
71738: PPUSH
71739: LD_VAR 0 2
71743: PPUSH
71744: LD_VAR 0 4
71748: PPUSH
71749: CALL_OW 1
71753: ST_TO_ADDR
// break ;
71754: GO 71758
// end ; end ;
71756: GO 71387
71758: POP
71759: POP
// end ;
71760: GO 71319
71762: POP
71763: POP
// end ;
71764: LD_VAR 0 1
71768: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71769: LD_INT 0
71771: PPUSH
71772: PPUSH
71773: PPUSH
// if not mc_bases then
71774: LD_EXP 58
71778: NOT
71779: IFFALSE 71783
// exit ;
71781: GO 71872
// for i = 1 to mc_bases do
71783: LD_ADDR_VAR 0 2
71787: PUSH
71788: DOUBLE
71789: LD_INT 1
71791: DEC
71792: ST_TO_ADDR
71793: LD_EXP 58
71797: PUSH
71798: FOR_TO
71799: IFFALSE 71870
// begin if mc_attack [ i ] then
71801: LD_EXP 78
71805: PUSH
71806: LD_VAR 0 2
71810: ARRAY
71811: IFFALSE 71868
// begin tmp := mc_attack [ i ] [ 1 ] ;
71813: LD_ADDR_VAR 0 3
71817: PUSH
71818: LD_EXP 78
71822: PUSH
71823: LD_VAR 0 2
71827: ARRAY
71828: PUSH
71829: LD_INT 1
71831: ARRAY
71832: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71833: LD_ADDR_EXP 78
71837: PUSH
71838: LD_EXP 78
71842: PPUSH
71843: LD_VAR 0 2
71847: PPUSH
71848: EMPTY
71849: PPUSH
71850: CALL_OW 1
71854: ST_TO_ADDR
// Attack ( tmp ) ;
71855: LD_VAR 0 3
71859: PPUSH
71860: CALL 49125 0 1
// exit ;
71864: POP
71865: POP
71866: GO 71872
// end ; end ;
71868: GO 71798
71870: POP
71871: POP
// end ;
71872: LD_VAR 0 1
71876: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71877: LD_INT 0
71879: PPUSH
71880: PPUSH
71881: PPUSH
71882: PPUSH
71883: PPUSH
71884: PPUSH
71885: PPUSH
// if not mc_bases then
71886: LD_EXP 58
71890: NOT
71891: IFFALSE 71895
// exit ;
71893: GO 72499
// for i = 1 to mc_bases do
71895: LD_ADDR_VAR 0 2
71899: PUSH
71900: DOUBLE
71901: LD_INT 1
71903: DEC
71904: ST_TO_ADDR
71905: LD_EXP 58
71909: PUSH
71910: FOR_TO
71911: IFFALSE 72497
// begin if not mc_bases [ i ] then
71913: LD_EXP 58
71917: PUSH
71918: LD_VAR 0 2
71922: ARRAY
71923: NOT
71924: IFFALSE 71928
// continue ;
71926: GO 71910
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71928: LD_ADDR_VAR 0 7
71932: PUSH
71933: LD_EXP 58
71937: PUSH
71938: LD_VAR 0 2
71942: ARRAY
71943: PUSH
71944: LD_INT 1
71946: ARRAY
71947: PPUSH
71948: CALL 17576 0 1
71952: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
71953: LD_ADDR_EXP 81
71957: PUSH
71958: LD_EXP 81
71962: PPUSH
71963: LD_VAR 0 2
71967: PPUSH
71968: LD_EXP 58
71972: PUSH
71973: LD_VAR 0 2
71977: ARRAY
71978: PUSH
71979: LD_INT 1
71981: ARRAY
71982: PPUSH
71983: CALL_OW 255
71987: PPUSH
71988: LD_EXP 83
71992: PUSH
71993: LD_VAR 0 2
71997: ARRAY
71998: PPUSH
71999: CALL 15536 0 2
72003: PPUSH
72004: CALL_OW 1
72008: ST_TO_ADDR
// if not mc_scan [ i ] then
72009: LD_EXP 81
72013: PUSH
72014: LD_VAR 0 2
72018: ARRAY
72019: NOT
72020: IFFALSE 72175
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72022: LD_ADDR_VAR 0 4
72026: PUSH
72027: LD_EXP 58
72031: PUSH
72032: LD_VAR 0 2
72036: ARRAY
72037: PPUSH
72038: LD_INT 2
72040: PUSH
72041: LD_INT 25
72043: PUSH
72044: LD_INT 5
72046: PUSH
72047: EMPTY
72048: LIST
72049: LIST
72050: PUSH
72051: LD_INT 25
72053: PUSH
72054: LD_INT 8
72056: PUSH
72057: EMPTY
72058: LIST
72059: LIST
72060: PUSH
72061: LD_INT 25
72063: PUSH
72064: LD_INT 9
72066: PUSH
72067: EMPTY
72068: LIST
72069: LIST
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: PPUSH
72077: CALL_OW 72
72081: ST_TO_ADDR
// if not tmp then
72082: LD_VAR 0 4
72086: NOT
72087: IFFALSE 72091
// continue ;
72089: GO 71910
// for j in tmp do
72091: LD_ADDR_VAR 0 3
72095: PUSH
72096: LD_VAR 0 4
72100: PUSH
72101: FOR_IN
72102: IFFALSE 72173
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72104: LD_VAR 0 3
72108: PPUSH
72109: CALL_OW 310
72113: PPUSH
72114: CALL_OW 266
72118: PUSH
72119: LD_INT 5
72121: EQUAL
72122: PUSH
72123: LD_VAR 0 3
72127: PPUSH
72128: CALL_OW 257
72132: PUSH
72133: LD_INT 1
72135: EQUAL
72136: AND
72137: PUSH
72138: LD_VAR 0 3
72142: PPUSH
72143: CALL_OW 459
72147: NOT
72148: AND
72149: PUSH
72150: LD_VAR 0 7
72154: AND
72155: IFFALSE 72171
// ComChangeProfession ( j , class ) ;
72157: LD_VAR 0 3
72161: PPUSH
72162: LD_VAR 0 7
72166: PPUSH
72167: CALL_OW 123
72171: GO 72101
72173: POP
72174: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72175: LD_EXP 81
72179: PUSH
72180: LD_VAR 0 2
72184: ARRAY
72185: PUSH
72186: LD_EXP 80
72190: PUSH
72191: LD_VAR 0 2
72195: ARRAY
72196: NOT
72197: AND
72198: PUSH
72199: LD_EXP 58
72203: PUSH
72204: LD_VAR 0 2
72208: ARRAY
72209: PPUSH
72210: LD_INT 30
72212: PUSH
72213: LD_INT 32
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PPUSH
72220: CALL_OW 72
72224: NOT
72225: AND
72226: PUSH
72227: LD_EXP 58
72231: PUSH
72232: LD_VAR 0 2
72236: ARRAY
72237: PPUSH
72238: LD_INT 2
72240: PUSH
72241: LD_INT 30
72243: PUSH
72244: LD_INT 4
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 30
72253: PUSH
72254: LD_INT 5
72256: PUSH
72257: EMPTY
72258: LIST
72259: LIST
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: LIST
72265: PPUSH
72266: CALL_OW 72
72270: NOT
72271: AND
72272: IFFALSE 72404
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72274: LD_ADDR_VAR 0 4
72278: PUSH
72279: LD_EXP 58
72283: PUSH
72284: LD_VAR 0 2
72288: ARRAY
72289: PPUSH
72290: LD_INT 2
72292: PUSH
72293: LD_INT 25
72295: PUSH
72296: LD_INT 1
72298: PUSH
72299: EMPTY
72300: LIST
72301: LIST
72302: PUSH
72303: LD_INT 25
72305: PUSH
72306: LD_INT 5
72308: PUSH
72309: EMPTY
72310: LIST
72311: LIST
72312: PUSH
72313: LD_INT 25
72315: PUSH
72316: LD_INT 8
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 25
72325: PUSH
72326: LD_INT 9
72328: PUSH
72329: EMPTY
72330: LIST
72331: LIST
72332: PUSH
72333: EMPTY
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: LIST
72339: PPUSH
72340: CALL_OW 72
72344: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72345: LD_ADDR_VAR 0 4
72349: PUSH
72350: LD_VAR 0 4
72354: PUSH
72355: LD_VAR 0 4
72359: PPUSH
72360: LD_INT 18
72362: PPUSH
72363: CALL 53908 0 2
72367: DIFF
72368: ST_TO_ADDR
// if tmp then
72369: LD_VAR 0 4
72373: IFFALSE 72404
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72375: LD_VAR 0 2
72379: PPUSH
72380: LD_VAR 0 4
72384: PPUSH
72385: LD_EXP 83
72389: PUSH
72390: LD_VAR 0 2
72394: ARRAY
72395: PPUSH
72396: CALL 15571 0 3
// exit ;
72400: POP
72401: POP
72402: GO 72499
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
72404: LD_EXP 81
72408: PUSH
72409: LD_VAR 0 2
72413: ARRAY
72414: PUSH
72415: LD_EXP 80
72419: PUSH
72420: LD_VAR 0 2
72424: ARRAY
72425: AND
72426: IFFALSE 72495
// begin tmp := mc_defender [ i ] ;
72428: LD_ADDR_VAR 0 4
72432: PUSH
72433: LD_EXP 80
72437: PUSH
72438: LD_VAR 0 2
72442: ARRAY
72443: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
72444: LD_ADDR_EXP 80
72448: PUSH
72449: LD_EXP 80
72453: PPUSH
72454: LD_VAR 0 2
72458: PPUSH
72459: EMPTY
72460: PPUSH
72461: CALL_OW 1
72465: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
72466: LD_VAR 0 2
72470: PPUSH
72471: LD_VAR 0 4
72475: PPUSH
72476: LD_EXP 81
72480: PUSH
72481: LD_VAR 0 2
72485: ARRAY
72486: PPUSH
72487: CALL 16069 0 3
// exit ;
72491: POP
72492: POP
72493: GO 72499
// end ; end ;
72495: GO 71910
72497: POP
72498: POP
// end ;
72499: LD_VAR 0 1
72503: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72504: LD_INT 0
72506: PPUSH
72507: PPUSH
72508: PPUSH
72509: PPUSH
72510: PPUSH
72511: PPUSH
72512: PPUSH
72513: PPUSH
72514: PPUSH
72515: PPUSH
72516: PPUSH
// if not mc_bases then
72517: LD_EXP 58
72521: NOT
72522: IFFALSE 72526
// exit ;
72524: GO 73613
// for i = 1 to mc_bases do
72526: LD_ADDR_VAR 0 2
72530: PUSH
72531: DOUBLE
72532: LD_INT 1
72534: DEC
72535: ST_TO_ADDR
72536: LD_EXP 58
72540: PUSH
72541: FOR_TO
72542: IFFALSE 73611
// begin tmp := mc_lab [ i ] ;
72544: LD_ADDR_VAR 0 6
72548: PUSH
72549: LD_EXP 91
72553: PUSH
72554: LD_VAR 0 2
72558: ARRAY
72559: ST_TO_ADDR
// if not tmp then
72560: LD_VAR 0 6
72564: NOT
72565: IFFALSE 72569
// continue ;
72567: GO 72541
// idle_lab := 0 ;
72569: LD_ADDR_VAR 0 11
72573: PUSH
72574: LD_INT 0
72576: ST_TO_ADDR
// for j in tmp do
72577: LD_ADDR_VAR 0 3
72581: PUSH
72582: LD_VAR 0 6
72586: PUSH
72587: FOR_IN
72588: IFFALSE 73607
// begin researching := false ;
72590: LD_ADDR_VAR 0 10
72594: PUSH
72595: LD_INT 0
72597: ST_TO_ADDR
// side := GetSide ( j ) ;
72598: LD_ADDR_VAR 0 4
72602: PUSH
72603: LD_VAR 0 3
72607: PPUSH
72608: CALL_OW 255
72612: ST_TO_ADDR
// if not mc_tech [ side ] then
72613: LD_EXP 85
72617: PUSH
72618: LD_VAR 0 4
72622: ARRAY
72623: NOT
72624: IFFALSE 72628
// continue ;
72626: GO 72587
// if BuildingStatus ( j ) = bs_idle then
72628: LD_VAR 0 3
72632: PPUSH
72633: CALL_OW 461
72637: PUSH
72638: LD_INT 2
72640: EQUAL
72641: IFFALSE 72829
// begin if idle_lab and UnitsInside ( j ) < 6 then
72643: LD_VAR 0 11
72647: PUSH
72648: LD_VAR 0 3
72652: PPUSH
72653: CALL_OW 313
72657: PUSH
72658: LD_INT 6
72660: LESS
72661: AND
72662: IFFALSE 72733
// begin tmp2 := UnitsInside ( idle_lab ) ;
72664: LD_ADDR_VAR 0 9
72668: PUSH
72669: LD_VAR 0 11
72673: PPUSH
72674: CALL_OW 313
72678: ST_TO_ADDR
// if tmp2 then
72679: LD_VAR 0 9
72683: IFFALSE 72725
// for x in tmp2 do
72685: LD_ADDR_VAR 0 7
72689: PUSH
72690: LD_VAR 0 9
72694: PUSH
72695: FOR_IN
72696: IFFALSE 72723
// begin ComExitBuilding ( x ) ;
72698: LD_VAR 0 7
72702: PPUSH
72703: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
72707: LD_VAR 0 7
72711: PPUSH
72712: LD_VAR 0 3
72716: PPUSH
72717: CALL_OW 180
// end ;
72721: GO 72695
72723: POP
72724: POP
// idle_lab := 0 ;
72725: LD_ADDR_VAR 0 11
72729: PUSH
72730: LD_INT 0
72732: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
72733: LD_ADDR_VAR 0 5
72737: PUSH
72738: LD_EXP 85
72742: PUSH
72743: LD_VAR 0 4
72747: ARRAY
72748: PUSH
72749: FOR_IN
72750: IFFALSE 72810
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
72752: LD_VAR 0 3
72756: PPUSH
72757: LD_VAR 0 5
72761: PPUSH
72762: CALL_OW 430
72766: PUSH
72767: LD_VAR 0 4
72771: PPUSH
72772: LD_VAR 0 5
72776: PPUSH
72777: CALL 14641 0 2
72781: AND
72782: IFFALSE 72808
// begin researching := true ;
72784: LD_ADDR_VAR 0 10
72788: PUSH
72789: LD_INT 1
72791: ST_TO_ADDR
// ComResearch ( j , t ) ;
72792: LD_VAR 0 3
72796: PPUSH
72797: LD_VAR 0 5
72801: PPUSH
72802: CALL_OW 124
// break ;
72806: GO 72810
// end ;
72808: GO 72749
72810: POP
72811: POP
// if not researching then
72812: LD_VAR 0 10
72816: NOT
72817: IFFALSE 72829
// idle_lab := j ;
72819: LD_ADDR_VAR 0 11
72823: PUSH
72824: LD_VAR 0 3
72828: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
72829: LD_VAR 0 3
72833: PPUSH
72834: CALL_OW 461
72838: PUSH
72839: LD_INT 10
72841: EQUAL
72842: IFFALSE 73430
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
72844: LD_EXP 87
72848: PUSH
72849: LD_VAR 0 2
72853: ARRAY
72854: NOT
72855: PUSH
72856: LD_EXP 88
72860: PUSH
72861: LD_VAR 0 2
72865: ARRAY
72866: NOT
72867: AND
72868: PUSH
72869: LD_EXP 85
72873: PUSH
72874: LD_VAR 0 4
72878: ARRAY
72879: PUSH
72880: LD_INT 1
72882: GREATER
72883: AND
72884: IFFALSE 73015
// begin ComCancel ( j ) ;
72886: LD_VAR 0 3
72890: PPUSH
72891: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
72895: LD_ADDR_EXP 85
72899: PUSH
72900: LD_EXP 85
72904: PPUSH
72905: LD_VAR 0 4
72909: PPUSH
72910: LD_EXP 85
72914: PUSH
72915: LD_VAR 0 4
72919: ARRAY
72920: PPUSH
72921: LD_EXP 85
72925: PUSH
72926: LD_VAR 0 4
72930: ARRAY
72931: PUSH
72932: LD_INT 1
72934: MINUS
72935: PPUSH
72936: LD_EXP 85
72940: PUSH
72941: LD_VAR 0 4
72945: ARRAY
72946: PPUSH
72947: LD_INT 0
72949: PPUSH
72950: CALL 20090 0 4
72954: PPUSH
72955: CALL_OW 1
72959: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
72960: LD_ADDR_EXP 85
72964: PUSH
72965: LD_EXP 85
72969: PPUSH
72970: LD_VAR 0 4
72974: PPUSH
72975: LD_EXP 85
72979: PUSH
72980: LD_VAR 0 4
72984: ARRAY
72985: PPUSH
72986: LD_EXP 85
72990: PUSH
72991: LD_VAR 0 4
72995: ARRAY
72996: PPUSH
72997: LD_INT 1
72999: PPUSH
73000: LD_INT 0
73002: PPUSH
73003: CALL 20090 0 4
73007: PPUSH
73008: CALL_OW 1
73012: ST_TO_ADDR
// continue ;
73013: GO 72587
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73015: LD_EXP 87
73019: PUSH
73020: LD_VAR 0 2
73024: ARRAY
73025: PUSH
73026: LD_EXP 88
73030: PUSH
73031: LD_VAR 0 2
73035: ARRAY
73036: NOT
73037: AND
73038: IFFALSE 73165
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73040: LD_ADDR_EXP 88
73044: PUSH
73045: LD_EXP 88
73049: PPUSH
73050: LD_VAR 0 2
73054: PUSH
73055: LD_EXP 88
73059: PUSH
73060: LD_VAR 0 2
73064: ARRAY
73065: PUSH
73066: LD_INT 1
73068: PLUS
73069: PUSH
73070: EMPTY
73071: LIST
73072: LIST
73073: PPUSH
73074: LD_EXP 87
73078: PUSH
73079: LD_VAR 0 2
73083: ARRAY
73084: PUSH
73085: LD_INT 1
73087: ARRAY
73088: PPUSH
73089: CALL 20672 0 3
73093: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73094: LD_EXP 87
73098: PUSH
73099: LD_VAR 0 2
73103: ARRAY
73104: PUSH
73105: LD_INT 1
73107: ARRAY
73108: PPUSH
73109: LD_INT 112
73111: PPUSH
73112: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73116: LD_ADDR_VAR 0 9
73120: PUSH
73121: LD_EXP 87
73125: PUSH
73126: LD_VAR 0 2
73130: ARRAY
73131: PPUSH
73132: LD_INT 1
73134: PPUSH
73135: CALL_OW 3
73139: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73140: LD_ADDR_EXP 87
73144: PUSH
73145: LD_EXP 87
73149: PPUSH
73150: LD_VAR 0 2
73154: PPUSH
73155: LD_VAR 0 9
73159: PPUSH
73160: CALL_OW 1
73164: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73165: LD_EXP 87
73169: PUSH
73170: LD_VAR 0 2
73174: ARRAY
73175: PUSH
73176: LD_EXP 88
73180: PUSH
73181: LD_VAR 0 2
73185: ARRAY
73186: AND
73187: PUSH
73188: LD_EXP 88
73192: PUSH
73193: LD_VAR 0 2
73197: ARRAY
73198: PUSH
73199: LD_INT 1
73201: ARRAY
73202: PPUSH
73203: CALL_OW 310
73207: NOT
73208: AND
73209: PUSH
73210: LD_VAR 0 3
73214: PPUSH
73215: CALL_OW 313
73219: PUSH
73220: LD_INT 6
73222: EQUAL
73223: AND
73224: IFFALSE 73280
// begin tmp2 := UnitsInside ( j ) ;
73226: LD_ADDR_VAR 0 9
73230: PUSH
73231: LD_VAR 0 3
73235: PPUSH
73236: CALL_OW 313
73240: ST_TO_ADDR
// if tmp2 = 6 then
73241: LD_VAR 0 9
73245: PUSH
73246: LD_INT 6
73248: EQUAL
73249: IFFALSE 73280
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73251: LD_VAR 0 9
73255: PUSH
73256: LD_INT 1
73258: ARRAY
73259: PPUSH
73260: LD_INT 112
73262: PPUSH
73263: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73267: LD_VAR 0 9
73271: PUSH
73272: LD_INT 1
73274: ARRAY
73275: PPUSH
73276: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73280: LD_EXP 88
73284: PUSH
73285: LD_VAR 0 2
73289: ARRAY
73290: PUSH
73291: LD_EXP 88
73295: PUSH
73296: LD_VAR 0 2
73300: ARRAY
73301: PUSH
73302: LD_INT 1
73304: ARRAY
73305: PPUSH
73306: CALL_OW 314
73310: NOT
73311: AND
73312: PUSH
73313: LD_EXP 88
73317: PUSH
73318: LD_VAR 0 2
73322: ARRAY
73323: PUSH
73324: LD_INT 1
73326: ARRAY
73327: PPUSH
73328: CALL_OW 310
73332: NOT
73333: AND
73334: IFFALSE 73360
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73336: LD_EXP 88
73340: PUSH
73341: LD_VAR 0 2
73345: ARRAY
73346: PUSH
73347: LD_INT 1
73349: ARRAY
73350: PPUSH
73351: LD_VAR 0 3
73355: PPUSH
73356: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73360: LD_EXP 88
73364: PUSH
73365: LD_VAR 0 2
73369: ARRAY
73370: PUSH
73371: LD_INT 1
73373: ARRAY
73374: PPUSH
73375: CALL_OW 310
73379: PUSH
73380: LD_EXP 88
73384: PUSH
73385: LD_VAR 0 2
73389: ARRAY
73390: PUSH
73391: LD_INT 1
73393: ARRAY
73394: PPUSH
73395: CALL_OW 310
73399: PPUSH
73400: CALL_OW 461
73404: PUSH
73405: LD_INT 3
73407: NONEQUAL
73408: AND
73409: IFFALSE 73430
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73411: LD_EXP 88
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PUSH
73422: LD_INT 1
73424: ARRAY
73425: PPUSH
73426: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73430: LD_VAR 0 3
73434: PPUSH
73435: CALL_OW 461
73439: PUSH
73440: LD_INT 6
73442: EQUAL
73443: PUSH
73444: LD_VAR 0 6
73448: PUSH
73449: LD_INT 1
73451: GREATER
73452: AND
73453: IFFALSE 73605
// begin sci := [ ] ;
73455: LD_ADDR_VAR 0 8
73459: PUSH
73460: EMPTY
73461: ST_TO_ADDR
// for x in ( tmp diff j ) do
73462: LD_ADDR_VAR 0 7
73466: PUSH
73467: LD_VAR 0 6
73471: PUSH
73472: LD_VAR 0 3
73476: DIFF
73477: PUSH
73478: FOR_IN
73479: IFFALSE 73531
// begin if sci = 6 then
73481: LD_VAR 0 8
73485: PUSH
73486: LD_INT 6
73488: EQUAL
73489: IFFALSE 73493
// break ;
73491: GO 73531
// if BuildingStatus ( x ) = bs_idle then
73493: LD_VAR 0 7
73497: PPUSH
73498: CALL_OW 461
73502: PUSH
73503: LD_INT 2
73505: EQUAL
73506: IFFALSE 73529
// sci := sci ^ UnitsInside ( x ) ;
73508: LD_ADDR_VAR 0 8
73512: PUSH
73513: LD_VAR 0 8
73517: PUSH
73518: LD_VAR 0 7
73522: PPUSH
73523: CALL_OW 313
73527: ADD
73528: ST_TO_ADDR
// end ;
73529: GO 73478
73531: POP
73532: POP
// if not sci then
73533: LD_VAR 0 8
73537: NOT
73538: IFFALSE 73542
// continue ;
73540: GO 72587
// for x in sci do
73542: LD_ADDR_VAR 0 7
73546: PUSH
73547: LD_VAR 0 8
73551: PUSH
73552: FOR_IN
73553: IFFALSE 73603
// if IsInUnit ( x ) and not HasTask ( x ) then
73555: LD_VAR 0 7
73559: PPUSH
73560: CALL_OW 310
73564: PUSH
73565: LD_VAR 0 7
73569: PPUSH
73570: CALL_OW 314
73574: NOT
73575: AND
73576: IFFALSE 73601
// begin ComExitBuilding ( x ) ;
73578: LD_VAR 0 7
73582: PPUSH
73583: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73587: LD_VAR 0 7
73591: PPUSH
73592: LD_VAR 0 3
73596: PPUSH
73597: CALL_OW 180
// end ;
73601: GO 73552
73603: POP
73604: POP
// end ; end ;
73605: GO 72587
73607: POP
73608: POP
// end ;
73609: GO 72541
73611: POP
73612: POP
// end ;
73613: LD_VAR 0 1
73617: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73618: LD_INT 0
73620: PPUSH
73621: PPUSH
// if not mc_bases then
73622: LD_EXP 58
73626: NOT
73627: IFFALSE 73631
// exit ;
73629: GO 73712
// for i = 1 to mc_bases do
73631: LD_ADDR_VAR 0 2
73635: PUSH
73636: DOUBLE
73637: LD_INT 1
73639: DEC
73640: ST_TO_ADDR
73641: LD_EXP 58
73645: PUSH
73646: FOR_TO
73647: IFFALSE 73710
// if mc_mines [ i ] and mc_miners [ i ] then
73649: LD_EXP 71
73653: PUSH
73654: LD_VAR 0 2
73658: ARRAY
73659: PUSH
73660: LD_EXP 72
73664: PUSH
73665: LD_VAR 0 2
73669: ARRAY
73670: AND
73671: IFFALSE 73708
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73673: LD_EXP 72
73677: PUSH
73678: LD_VAR 0 2
73682: ARRAY
73683: PUSH
73684: LD_INT 1
73686: ARRAY
73687: PPUSH
73688: CALL_OW 255
73692: PPUSH
73693: LD_EXP 71
73697: PUSH
73698: LD_VAR 0 2
73702: ARRAY
73703: PPUSH
73704: CALL 17729 0 2
73708: GO 73646
73710: POP
73711: POP
// end ;
73712: LD_VAR 0 1
73716: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
73717: LD_INT 0
73719: PPUSH
73720: PPUSH
73721: PPUSH
73722: PPUSH
73723: PPUSH
73724: PPUSH
73725: PPUSH
73726: PPUSH
// if not mc_bases or not mc_parking then
73727: LD_EXP 58
73731: NOT
73732: PUSH
73733: LD_EXP 82
73737: NOT
73738: OR
73739: IFFALSE 73743
// exit ;
73741: GO 74455
// for i = 1 to mc_bases do
73743: LD_ADDR_VAR 0 2
73747: PUSH
73748: DOUBLE
73749: LD_INT 1
73751: DEC
73752: ST_TO_ADDR
73753: LD_EXP 58
73757: PUSH
73758: FOR_TO
73759: IFFALSE 74453
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
73761: LD_EXP 58
73765: PUSH
73766: LD_VAR 0 2
73770: ARRAY
73771: NOT
73772: PUSH
73773: LD_EXP 82
73777: PUSH
73778: LD_VAR 0 2
73782: ARRAY
73783: NOT
73784: OR
73785: IFFALSE 73789
// continue ;
73787: GO 73758
// if mc_scan [ i ] then
73789: LD_EXP 81
73793: PUSH
73794: LD_VAR 0 2
73798: ARRAY
73799: IFFALSE 73825
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
73801: LD_ADDR_EXP 70
73805: PUSH
73806: LD_EXP 70
73810: PPUSH
73811: LD_VAR 0 2
73815: PPUSH
73816: EMPTY
73817: PPUSH
73818: CALL_OW 1
73822: ST_TO_ADDR
// continue ;
73823: GO 73758
// end ; side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73825: LD_ADDR_VAR 0 5
73829: PUSH
73830: LD_EXP 58
73834: PUSH
73835: LD_VAR 0 2
73839: ARRAY
73840: PUSH
73841: LD_INT 1
73843: ARRAY
73844: PPUSH
73845: CALL_OW 255
73849: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
73850: LD_ADDR_VAR 0 6
73854: PUSH
73855: LD_EXP 58
73859: PUSH
73860: LD_VAR 0 2
73864: ARRAY
73865: PPUSH
73866: LD_INT 30
73868: PUSH
73869: LD_INT 3
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: PPUSH
73876: CALL_OW 72
73880: ST_TO_ADDR
// if not fac then
73881: LD_VAR 0 6
73885: NOT
73886: IFFALSE 73937
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73888: LD_ADDR_VAR 0 6
73892: PUSH
73893: LD_EXP 58
73897: PUSH
73898: LD_VAR 0 2
73902: ARRAY
73903: PPUSH
73904: LD_INT 2
73906: PUSH
73907: LD_INT 30
73909: PUSH
73910: LD_INT 0
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 30
73919: PUSH
73920: LD_INT 1
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: LIST
73931: PPUSH
73932: CALL_OW 72
73936: ST_TO_ADDR
// if not fac then
73937: LD_VAR 0 6
73941: NOT
73942: IFFALSE 73946
// continue ;
73944: GO 73758
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
73946: LD_ADDR_VAR 0 7
73950: PUSH
73951: LD_EXP 82
73955: PUSH
73956: LD_VAR 0 2
73960: ARRAY
73961: PPUSH
73962: LD_INT 22
73964: PUSH
73965: LD_VAR 0 5
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: PUSH
73974: LD_INT 21
73976: PUSH
73977: LD_INT 2
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 3
73986: PUSH
73987: LD_INT 24
73989: PUSH
73990: LD_INT 1000
73992: PUSH
73993: EMPTY
73994: LIST
73995: LIST
73996: PUSH
73997: EMPTY
73998: LIST
73999: LIST
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: LIST
74005: PPUSH
74006: CALL_OW 70
74010: PUSH
74011: LD_INT 22
74013: PUSH
74014: LD_VAR 0 5
74018: PUSH
74019: EMPTY
74020: LIST
74021: LIST
74022: PUSH
74023: LD_INT 91
74025: PUSH
74026: LD_VAR 0 6
74030: PUSH
74031: LD_INT 1
74033: ARRAY
74034: PUSH
74035: LD_INT 25
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: LIST
74042: PUSH
74043: LD_INT 21
74045: PUSH
74046: LD_INT 2
74048: PUSH
74049: EMPTY
74050: LIST
74051: LIST
74052: PUSH
74053: LD_INT 3
74055: PUSH
74056: LD_INT 24
74058: PUSH
74059: LD_INT 1000
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: PUSH
74066: EMPTY
74067: LIST
74068: LIST
74069: PUSH
74070: EMPTY
74071: LIST
74072: LIST
74073: LIST
74074: LIST
74075: PPUSH
74076: CALL_OW 69
74080: UNION
74081: ST_TO_ADDR
// if not vehs then
74082: LD_VAR 0 7
74086: NOT
74087: IFFALSE 74113
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74089: LD_ADDR_EXP 70
74093: PUSH
74094: LD_EXP 70
74098: PPUSH
74099: LD_VAR 0 2
74103: PPUSH
74104: EMPTY
74105: PPUSH
74106: CALL_OW 1
74110: ST_TO_ADDR
// continue ;
74111: GO 73758
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74113: LD_ADDR_VAR 0 8
74117: PUSH
74118: LD_EXP 58
74122: PUSH
74123: LD_VAR 0 2
74127: ARRAY
74128: PPUSH
74129: LD_INT 30
74131: PUSH
74132: LD_INT 3
74134: PUSH
74135: EMPTY
74136: LIST
74137: LIST
74138: PPUSH
74139: CALL_OW 72
74143: ST_TO_ADDR
// if tmp then
74144: LD_VAR 0 8
74148: IFFALSE 74251
// begin for j in tmp do
74150: LD_ADDR_VAR 0 3
74154: PUSH
74155: LD_VAR 0 8
74159: PUSH
74160: FOR_IN
74161: IFFALSE 74249
// for k in UnitsInside ( j ) do
74163: LD_ADDR_VAR 0 4
74167: PUSH
74168: LD_VAR 0 3
74172: PPUSH
74173: CALL_OW 313
74177: PUSH
74178: FOR_IN
74179: IFFALSE 74245
// if k then
74181: LD_VAR 0 4
74185: IFFALSE 74243
// if not k in mc_repair_vehicle [ i ] then
74187: LD_VAR 0 4
74191: PUSH
74192: LD_EXP 70
74196: PUSH
74197: LD_VAR 0 2
74201: ARRAY
74202: IN
74203: NOT
74204: IFFALSE 74243
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74206: LD_ADDR_EXP 70
74210: PUSH
74211: LD_EXP 70
74215: PPUSH
74216: LD_VAR 0 2
74220: PPUSH
74221: LD_EXP 70
74225: PUSH
74226: LD_VAR 0 2
74230: ARRAY
74231: PUSH
74232: LD_VAR 0 4
74236: UNION
74237: PPUSH
74238: CALL_OW 1
74242: ST_TO_ADDR
74243: GO 74178
74245: POP
74246: POP
74247: GO 74160
74249: POP
74250: POP
// end ; if not mc_repair_vehicle [ i ] then
74251: LD_EXP 70
74255: PUSH
74256: LD_VAR 0 2
74260: ARRAY
74261: NOT
74262: IFFALSE 74266
// continue ;
74264: GO 73758
// for j in mc_repair_vehicle [ i ] do
74266: LD_ADDR_VAR 0 3
74270: PUSH
74271: LD_EXP 70
74275: PUSH
74276: LD_VAR 0 2
74280: ARRAY
74281: PUSH
74282: FOR_IN
74283: IFFALSE 74449
// begin if GetClass ( j ) <> 3 then
74285: LD_VAR 0 3
74289: PPUSH
74290: CALL_OW 257
74294: PUSH
74295: LD_INT 3
74297: NONEQUAL
74298: IFFALSE 74339
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74300: LD_ADDR_EXP 70
74304: PUSH
74305: LD_EXP 70
74309: PPUSH
74310: LD_VAR 0 2
74314: PPUSH
74315: LD_EXP 70
74319: PUSH
74320: LD_VAR 0 2
74324: ARRAY
74325: PUSH
74326: LD_VAR 0 3
74330: DIFF
74331: PPUSH
74332: CALL_OW 1
74336: ST_TO_ADDR
// continue ;
74337: GO 74282
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74339: LD_VAR 0 3
74343: PPUSH
74344: CALL_OW 311
74348: NOT
74349: PUSH
74350: LD_VAR 0 3
74354: PUSH
74355: LD_EXP 61
74359: PUSH
74360: LD_VAR 0 2
74364: ARRAY
74365: PUSH
74366: LD_INT 1
74368: ARRAY
74369: IN
74370: NOT
74371: AND
74372: PUSH
74373: LD_VAR 0 3
74377: PUSH
74378: LD_EXP 61
74382: PUSH
74383: LD_VAR 0 2
74387: ARRAY
74388: PUSH
74389: LD_INT 2
74391: ARRAY
74392: IN
74393: NOT
74394: AND
74395: IFFALSE 74447
// begin if IsInUnit ( j ) then
74397: LD_VAR 0 3
74401: PPUSH
74402: CALL_OW 310
74406: IFFALSE 74417
// ComExitBuilding ( j ) ;
74408: LD_VAR 0 3
74412: PPUSH
74413: CALL_OW 122
// if not HasTask ( j ) then
74417: LD_VAR 0 3
74421: PPUSH
74422: CALL_OW 314
74426: NOT
74427: IFFALSE 74447
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
74429: LD_VAR 0 3
74433: PPUSH
74434: LD_VAR 0 7
74438: PUSH
74439: LD_INT 1
74441: ARRAY
74442: PPUSH
74443: CALL_OW 189
// end ; end ;
74447: GO 74282
74449: POP
74450: POP
// end ;
74451: GO 73758
74453: POP
74454: POP
// end ;
74455: LD_VAR 0 1
74459: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74460: LD_INT 0
74462: PPUSH
74463: PPUSH
74464: PPUSH
74465: PPUSH
74466: PPUSH
74467: PPUSH
74468: PPUSH
74469: PPUSH
74470: PPUSH
74471: PPUSH
74472: PPUSH
// if not mc_bases then
74473: LD_EXP 58
74477: NOT
74478: IFFALSE 74482
// exit ;
74480: GO 75284
// for i = 1 to mc_bases do
74482: LD_ADDR_VAR 0 2
74486: PUSH
74487: DOUBLE
74488: LD_INT 1
74490: DEC
74491: ST_TO_ADDR
74492: LD_EXP 58
74496: PUSH
74497: FOR_TO
74498: IFFALSE 75282
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74500: LD_EXP 86
74504: PUSH
74505: LD_VAR 0 2
74509: ARRAY
74510: NOT
74511: PUSH
74512: LD_EXP 61
74516: PUSH
74517: LD_VAR 0 2
74521: ARRAY
74522: PUSH
74523: LD_INT 1
74525: ARRAY
74526: OR
74527: PUSH
74528: LD_EXP 61
74532: PUSH
74533: LD_VAR 0 2
74537: ARRAY
74538: PUSH
74539: LD_INT 2
74541: ARRAY
74542: OR
74543: PUSH
74544: LD_EXP 84
74548: PUSH
74549: LD_VAR 0 2
74553: ARRAY
74554: PPUSH
74555: LD_INT 1
74557: PPUSH
74558: CALL_OW 325
74562: NOT
74563: OR
74564: PUSH
74565: LD_EXP 81
74569: PUSH
74570: LD_VAR 0 2
74574: ARRAY
74575: OR
74576: IFFALSE 74580
// continue ;
74578: GO 74497
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74580: LD_ADDR_VAR 0 8
74584: PUSH
74585: LD_EXP 58
74589: PUSH
74590: LD_VAR 0 2
74594: ARRAY
74595: PPUSH
74596: LD_INT 25
74598: PUSH
74599: LD_INT 4
74601: PUSH
74602: EMPTY
74603: LIST
74604: LIST
74605: PUSH
74606: LD_INT 50
74608: PUSH
74609: EMPTY
74610: LIST
74611: PUSH
74612: LD_INT 3
74614: PUSH
74615: LD_INT 60
74617: PUSH
74618: EMPTY
74619: LIST
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: LIST
74629: PPUSH
74630: CALL_OW 72
74634: PUSH
74635: LD_EXP 62
74639: PUSH
74640: LD_VAR 0 2
74644: ARRAY
74645: DIFF
74646: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74647: LD_ADDR_VAR 0 9
74651: PUSH
74652: LD_EXP 58
74656: PUSH
74657: LD_VAR 0 2
74661: ARRAY
74662: PPUSH
74663: LD_INT 2
74665: PUSH
74666: LD_INT 30
74668: PUSH
74669: LD_INT 0
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 30
74678: PUSH
74679: LD_INT 1
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: LIST
74690: PPUSH
74691: CALL_OW 72
74695: ST_TO_ADDR
// if not tmp or not dep then
74696: LD_VAR 0 8
74700: NOT
74701: PUSH
74702: LD_VAR 0 9
74706: NOT
74707: OR
74708: IFFALSE 74712
// continue ;
74710: GO 74497
// side := GetSide ( tmp [ 1 ] ) ;
74712: LD_ADDR_VAR 0 11
74716: PUSH
74717: LD_VAR 0 8
74721: PUSH
74722: LD_INT 1
74724: ARRAY
74725: PPUSH
74726: CALL_OW 255
74730: ST_TO_ADDR
// dep := dep [ 1 ] ;
74731: LD_ADDR_VAR 0 9
74735: PUSH
74736: LD_VAR 0 9
74740: PUSH
74741: LD_INT 1
74743: ARRAY
74744: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
74745: LD_ADDR_VAR 0 7
74749: PUSH
74750: LD_EXP 86
74754: PUSH
74755: LD_VAR 0 2
74759: ARRAY
74760: PPUSH
74761: LD_INT 22
74763: PUSH
74764: LD_INT 0
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 25
74773: PUSH
74774: LD_INT 12
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PPUSH
74785: CALL_OW 70
74789: PUSH
74790: LD_INT 22
74792: PUSH
74793: LD_INT 0
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: LD_INT 25
74802: PUSH
74803: LD_INT 12
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 91
74812: PUSH
74813: LD_VAR 0 9
74817: PUSH
74818: LD_INT 20
74820: PUSH
74821: EMPTY
74822: LIST
74823: LIST
74824: LIST
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: LIST
74830: PPUSH
74831: CALL_OW 69
74835: UNION
74836: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
74837: LD_ADDR_VAR 0 10
74841: PUSH
74842: LD_EXP 86
74846: PUSH
74847: LD_VAR 0 2
74851: ARRAY
74852: PPUSH
74853: LD_INT 81
74855: PUSH
74856: LD_VAR 0 11
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PPUSH
74865: CALL_OW 70
74869: ST_TO_ADDR
// if not apes or danger_at_area then
74870: LD_VAR 0 7
74874: NOT
74875: PUSH
74876: LD_VAR 0 10
74880: OR
74881: IFFALSE 74931
// begin if mc_taming [ i ] then
74883: LD_EXP 89
74887: PUSH
74888: LD_VAR 0 2
74892: ARRAY
74893: IFFALSE 74929
// begin MC_Reset ( i , 121 ) ;
74895: LD_VAR 0 2
74899: PPUSH
74900: LD_INT 121
74902: PPUSH
74903: CALL 60566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
74907: LD_ADDR_EXP 89
74911: PUSH
74912: LD_EXP 89
74916: PPUSH
74917: LD_VAR 0 2
74921: PPUSH
74922: EMPTY
74923: PPUSH
74924: CALL_OW 1
74928: ST_TO_ADDR
// end ; continue ;
74929: GO 74497
// end ; for j in tmp do
74931: LD_ADDR_VAR 0 3
74935: PUSH
74936: LD_VAR 0 8
74940: PUSH
74941: FOR_IN
74942: IFFALSE 75278
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
74944: LD_VAR 0 3
74948: PUSH
74949: LD_EXP 89
74953: PUSH
74954: LD_VAR 0 2
74958: ARRAY
74959: IN
74960: NOT
74961: PUSH
74962: LD_EXP 89
74966: PUSH
74967: LD_VAR 0 2
74971: ARRAY
74972: PUSH
74973: LD_INT 3
74975: LESS
74976: AND
74977: IFFALSE 75035
// begin SetTag ( j , 121 ) ;
74979: LD_VAR 0 3
74983: PPUSH
74984: LD_INT 121
74986: PPUSH
74987: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
74991: LD_ADDR_EXP 89
74995: PUSH
74996: LD_EXP 89
75000: PPUSH
75001: LD_VAR 0 2
75005: PUSH
75006: LD_EXP 89
75010: PUSH
75011: LD_VAR 0 2
75015: ARRAY
75016: PUSH
75017: LD_INT 1
75019: PLUS
75020: PUSH
75021: EMPTY
75022: LIST
75023: LIST
75024: PPUSH
75025: LD_VAR 0 3
75029: PPUSH
75030: CALL 20672 0 3
75034: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75035: LD_VAR 0 3
75039: PUSH
75040: LD_EXP 89
75044: PUSH
75045: LD_VAR 0 2
75049: ARRAY
75050: IN
75051: IFFALSE 75276
// begin if GetClass ( j ) <> 4 then
75053: LD_VAR 0 3
75057: PPUSH
75058: CALL_OW 257
75062: PUSH
75063: LD_INT 4
75065: NONEQUAL
75066: IFFALSE 75119
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75068: LD_ADDR_EXP 89
75072: PUSH
75073: LD_EXP 89
75077: PPUSH
75078: LD_VAR 0 2
75082: PPUSH
75083: LD_EXP 89
75087: PUSH
75088: LD_VAR 0 2
75092: ARRAY
75093: PUSH
75094: LD_VAR 0 3
75098: DIFF
75099: PPUSH
75100: CALL_OW 1
75104: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75105: LD_VAR 0 3
75109: PPUSH
75110: LD_INT 0
75112: PPUSH
75113: CALL_OW 109
// continue ;
75117: GO 74941
// end ; if IsInUnit ( j ) then
75119: LD_VAR 0 3
75123: PPUSH
75124: CALL_OW 310
75128: IFFALSE 75139
// ComExitBuilding ( j ) ;
75130: LD_VAR 0 3
75134: PPUSH
75135: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75139: LD_ADDR_VAR 0 6
75143: PUSH
75144: LD_VAR 0 7
75148: PPUSH
75149: LD_VAR 0 3
75153: PPUSH
75154: CALL_OW 74
75158: ST_TO_ADDR
// if not ape then
75159: LD_VAR 0 6
75163: NOT
75164: IFFALSE 75168
// break ;
75166: GO 75278
// x := GetX ( ape ) ;
75168: LD_ADDR_VAR 0 4
75172: PUSH
75173: LD_VAR 0 6
75177: PPUSH
75178: CALL_OW 250
75182: ST_TO_ADDR
// y := GetY ( ape ) ;
75183: LD_ADDR_VAR 0 5
75187: PUSH
75188: LD_VAR 0 6
75192: PPUSH
75193: CALL_OW 251
75197: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75198: LD_VAR 0 4
75202: PPUSH
75203: LD_VAR 0 5
75207: PPUSH
75208: CALL_OW 488
75212: NOT
75213: PUSH
75214: LD_VAR 0 11
75218: PPUSH
75219: LD_VAR 0 4
75223: PPUSH
75224: LD_VAR 0 5
75228: PPUSH
75229: LD_INT 20
75231: PPUSH
75232: CALL 21568 0 4
75236: PUSH
75237: LD_INT 4
75239: ARRAY
75240: OR
75241: IFFALSE 75245
// break ;
75243: GO 75278
// if not HasTask ( j ) then
75245: LD_VAR 0 3
75249: PPUSH
75250: CALL_OW 314
75254: NOT
75255: IFFALSE 75276
// ComTameXY ( j , x , y ) ;
75257: LD_VAR 0 3
75261: PPUSH
75262: LD_VAR 0 4
75266: PPUSH
75267: LD_VAR 0 5
75271: PPUSH
75272: CALL_OW 131
// end ; end ;
75276: GO 74941
75278: POP
75279: POP
// end ;
75280: GO 74497
75282: POP
75283: POP
// end ;
75284: LD_VAR 0 1
75288: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75289: LD_INT 0
75291: PPUSH
75292: PPUSH
75293: PPUSH
75294: PPUSH
75295: PPUSH
75296: PPUSH
75297: PPUSH
75298: PPUSH
// if not mc_bases then
75299: LD_EXP 58
75303: NOT
75304: IFFALSE 75308
// exit ;
75306: GO 75934
// for i = 1 to mc_bases do
75308: LD_ADDR_VAR 0 2
75312: PUSH
75313: DOUBLE
75314: LD_INT 1
75316: DEC
75317: ST_TO_ADDR
75318: LD_EXP 58
75322: PUSH
75323: FOR_TO
75324: IFFALSE 75932
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75326: LD_EXP 87
75330: PUSH
75331: LD_VAR 0 2
75335: ARRAY
75336: NOT
75337: PUSH
75338: LD_EXP 87
75342: PUSH
75343: LD_VAR 0 2
75347: ARRAY
75348: PPUSH
75349: LD_INT 25
75351: PUSH
75352: LD_INT 12
75354: PUSH
75355: EMPTY
75356: LIST
75357: LIST
75358: PPUSH
75359: CALL_OW 72
75363: NOT
75364: OR
75365: IFFALSE 75369
// continue ;
75367: GO 75323
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75369: LD_ADDR_VAR 0 5
75373: PUSH
75374: LD_EXP 87
75378: PUSH
75379: LD_VAR 0 2
75383: ARRAY
75384: PUSH
75385: LD_INT 1
75387: ARRAY
75388: PPUSH
75389: CALL_OW 255
75393: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75394: LD_VAR 0 5
75398: PPUSH
75399: LD_INT 2
75401: PPUSH
75402: CALL_OW 325
75406: IFFALSE 75659
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75408: LD_ADDR_VAR 0 4
75412: PUSH
75413: LD_EXP 87
75417: PUSH
75418: LD_VAR 0 2
75422: ARRAY
75423: PPUSH
75424: LD_INT 25
75426: PUSH
75427: LD_INT 16
75429: PUSH
75430: EMPTY
75431: LIST
75432: LIST
75433: PPUSH
75434: CALL_OW 72
75438: ST_TO_ADDR
// if tmp < 6 then
75439: LD_VAR 0 4
75443: PUSH
75444: LD_INT 6
75446: LESS
75447: IFFALSE 75659
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75449: LD_ADDR_VAR 0 6
75453: PUSH
75454: LD_EXP 58
75458: PUSH
75459: LD_VAR 0 2
75463: ARRAY
75464: PPUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 30
75470: PUSH
75471: LD_INT 0
75473: PUSH
75474: EMPTY
75475: LIST
75476: LIST
75477: PUSH
75478: LD_INT 30
75480: PUSH
75481: LD_INT 1
75483: PUSH
75484: EMPTY
75485: LIST
75486: LIST
75487: PUSH
75488: EMPTY
75489: LIST
75490: LIST
75491: LIST
75492: PPUSH
75493: CALL_OW 72
75497: ST_TO_ADDR
// if depot then
75498: LD_VAR 0 6
75502: IFFALSE 75659
// begin selected := 0 ;
75504: LD_ADDR_VAR 0 7
75508: PUSH
75509: LD_INT 0
75511: ST_TO_ADDR
// for j in depot do
75512: LD_ADDR_VAR 0 3
75516: PUSH
75517: LD_VAR 0 6
75521: PUSH
75522: FOR_IN
75523: IFFALSE 75554
// begin if UnitsInside ( j ) < 6 then
75525: LD_VAR 0 3
75529: PPUSH
75530: CALL_OW 313
75534: PUSH
75535: LD_INT 6
75537: LESS
75538: IFFALSE 75552
// begin selected := j ;
75540: LD_ADDR_VAR 0 7
75544: PUSH
75545: LD_VAR 0 3
75549: ST_TO_ADDR
// break ;
75550: GO 75554
// end ; end ;
75552: GO 75522
75554: POP
75555: POP
// if selected then
75556: LD_VAR 0 7
75560: IFFALSE 75659
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75562: LD_ADDR_VAR 0 3
75566: PUSH
75567: LD_EXP 87
75571: PUSH
75572: LD_VAR 0 2
75576: ARRAY
75577: PPUSH
75578: LD_INT 25
75580: PUSH
75581: LD_INT 12
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PPUSH
75588: CALL_OW 72
75592: PUSH
75593: FOR_IN
75594: IFFALSE 75657
// if not HasTask ( j ) then
75596: LD_VAR 0 3
75600: PPUSH
75601: CALL_OW 314
75605: NOT
75606: IFFALSE 75655
// begin if not IsInUnit ( j ) then
75608: LD_VAR 0 3
75612: PPUSH
75613: CALL_OW 310
75617: NOT
75618: IFFALSE 75634
// ComEnterUnit ( j , selected ) ;
75620: LD_VAR 0 3
75624: PPUSH
75625: LD_VAR 0 7
75629: PPUSH
75630: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75634: LD_VAR 0 3
75638: PPUSH
75639: LD_INT 16
75641: PPUSH
75642: CALL_OW 183
// AddComExitBuilding ( j ) ;
75646: LD_VAR 0 3
75650: PPUSH
75651: CALL_OW 182
// end ;
75655: GO 75593
75657: POP
75658: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75659: LD_VAR 0 5
75663: PPUSH
75664: LD_INT 11
75666: PPUSH
75667: CALL_OW 325
75671: IFFALSE 75930
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75673: LD_ADDR_VAR 0 4
75677: PUSH
75678: LD_EXP 87
75682: PUSH
75683: LD_VAR 0 2
75687: ARRAY
75688: PPUSH
75689: LD_INT 25
75691: PUSH
75692: LD_INT 16
75694: PUSH
75695: EMPTY
75696: LIST
75697: LIST
75698: PPUSH
75699: CALL_OW 72
75703: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
75704: LD_VAR 0 4
75708: PUSH
75709: LD_INT 6
75711: GREATEREQUAL
75712: PUSH
75713: LD_VAR 0 5
75717: PPUSH
75718: LD_INT 2
75720: PPUSH
75721: CALL_OW 325
75725: NOT
75726: OR
75727: IFFALSE 75930
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
75729: LD_ADDR_VAR 0 8
75733: PUSH
75734: LD_EXP 58
75738: PUSH
75739: LD_VAR 0 2
75743: ARRAY
75744: PPUSH
75745: LD_INT 2
75747: PUSH
75748: LD_INT 30
75750: PUSH
75751: LD_INT 4
75753: PUSH
75754: EMPTY
75755: LIST
75756: LIST
75757: PUSH
75758: LD_INT 30
75760: PUSH
75761: LD_INT 5
75763: PUSH
75764: EMPTY
75765: LIST
75766: LIST
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: LIST
75772: PPUSH
75773: CALL_OW 72
75777: ST_TO_ADDR
// if barracks then
75778: LD_VAR 0 8
75782: IFFALSE 75930
// begin selected := 0 ;
75784: LD_ADDR_VAR 0 7
75788: PUSH
75789: LD_INT 0
75791: ST_TO_ADDR
// for j in barracks do
75792: LD_ADDR_VAR 0 3
75796: PUSH
75797: LD_VAR 0 8
75801: PUSH
75802: FOR_IN
75803: IFFALSE 75834
// begin if UnitsInside ( j ) < 6 then
75805: LD_VAR 0 3
75809: PPUSH
75810: CALL_OW 313
75814: PUSH
75815: LD_INT 6
75817: LESS
75818: IFFALSE 75832
// begin selected := j ;
75820: LD_ADDR_VAR 0 7
75824: PUSH
75825: LD_VAR 0 3
75829: ST_TO_ADDR
// break ;
75830: GO 75834
// end ; end ;
75832: GO 75802
75834: POP
75835: POP
// if selected then
75836: LD_VAR 0 7
75840: IFFALSE 75930
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75842: LD_ADDR_VAR 0 3
75846: PUSH
75847: LD_EXP 87
75851: PUSH
75852: LD_VAR 0 2
75856: ARRAY
75857: PPUSH
75858: LD_INT 25
75860: PUSH
75861: LD_INT 12
75863: PUSH
75864: EMPTY
75865: LIST
75866: LIST
75867: PPUSH
75868: CALL_OW 72
75872: PUSH
75873: FOR_IN
75874: IFFALSE 75928
// if not IsInUnit ( j ) and not HasTask ( j ) then
75876: LD_VAR 0 3
75880: PPUSH
75881: CALL_OW 310
75885: NOT
75886: PUSH
75887: LD_VAR 0 3
75891: PPUSH
75892: CALL_OW 314
75896: NOT
75897: AND
75898: IFFALSE 75926
// begin ComEnterUnit ( j , selected ) ;
75900: LD_VAR 0 3
75904: PPUSH
75905: LD_VAR 0 7
75909: PPUSH
75910: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
75914: LD_VAR 0 3
75918: PPUSH
75919: LD_INT 15
75921: PPUSH
75922: CALL_OW 183
// end ;
75926: GO 75873
75928: POP
75929: POP
// end ; end ; end ; end ; end ;
75930: GO 75323
75932: POP
75933: POP
// end ;
75934: LD_VAR 0 1
75938: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
75939: LD_INT 0
75941: PPUSH
75942: PPUSH
75943: PPUSH
75944: PPUSH
// if not mc_bases then
75945: LD_EXP 58
75949: NOT
75950: IFFALSE 75954
// exit ;
75952: GO 76132
// for i = 1 to mc_bases do
75954: LD_ADDR_VAR 0 2
75958: PUSH
75959: DOUBLE
75960: LD_INT 1
75962: DEC
75963: ST_TO_ADDR
75964: LD_EXP 58
75968: PUSH
75969: FOR_TO
75970: IFFALSE 76130
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
75972: LD_ADDR_VAR 0 4
75976: PUSH
75977: LD_EXP 58
75981: PUSH
75982: LD_VAR 0 2
75986: ARRAY
75987: PPUSH
75988: LD_INT 25
75990: PUSH
75991: LD_INT 9
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PPUSH
75998: CALL_OW 72
76002: ST_TO_ADDR
// if not tmp then
76003: LD_VAR 0 4
76007: NOT
76008: IFFALSE 76012
// continue ;
76010: GO 75969
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76012: LD_EXP 84
76016: PUSH
76017: LD_VAR 0 2
76021: ARRAY
76022: PPUSH
76023: LD_INT 29
76025: PPUSH
76026: CALL_OW 325
76030: NOT
76031: PUSH
76032: LD_EXP 84
76036: PUSH
76037: LD_VAR 0 2
76041: ARRAY
76042: PPUSH
76043: LD_INT 28
76045: PPUSH
76046: CALL_OW 325
76050: NOT
76051: AND
76052: IFFALSE 76056
// continue ;
76054: GO 75969
// for j in tmp do
76056: LD_ADDR_VAR 0 3
76060: PUSH
76061: LD_VAR 0 4
76065: PUSH
76066: FOR_IN
76067: IFFALSE 76126
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76069: LD_VAR 0 3
76073: PUSH
76074: LD_EXP 61
76078: PUSH
76079: LD_VAR 0 2
76083: ARRAY
76084: PUSH
76085: LD_INT 1
76087: ARRAY
76088: IN
76089: NOT
76090: PUSH
76091: LD_VAR 0 3
76095: PUSH
76096: LD_EXP 61
76100: PUSH
76101: LD_VAR 0 2
76105: ARRAY
76106: PUSH
76107: LD_INT 2
76109: ARRAY
76110: IN
76111: NOT
76112: AND
76113: IFFALSE 76124
// ComSpaceTimeShoot ( j ) ;
76115: LD_VAR 0 3
76119: PPUSH
76120: CALL 14732 0 1
76124: GO 76066
76126: POP
76127: POP
// end ;
76128: GO 75969
76130: POP
76131: POP
// end ;
76132: LD_VAR 0 1
76136: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76137: LD_INT 0
76139: PPUSH
76140: PPUSH
76141: PPUSH
76142: PPUSH
76143: PPUSH
76144: PPUSH
76145: PPUSH
76146: PPUSH
76147: PPUSH
// if not mc_bases then
76148: LD_EXP 58
76152: NOT
76153: IFFALSE 76157
// exit ;
76155: GO 76779
// for i = 1 to mc_bases do
76157: LD_ADDR_VAR 0 2
76161: PUSH
76162: DOUBLE
76163: LD_INT 1
76165: DEC
76166: ST_TO_ADDR
76167: LD_EXP 58
76171: PUSH
76172: FOR_TO
76173: IFFALSE 76777
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76175: LD_EXP 93
76179: PUSH
76180: LD_VAR 0 2
76184: ARRAY
76185: NOT
76186: PUSH
76187: LD_INT 38
76189: PPUSH
76190: LD_EXP 84
76194: PUSH
76195: LD_VAR 0 2
76199: ARRAY
76200: PPUSH
76201: CALL_OW 321
76205: PUSH
76206: LD_INT 2
76208: NONEQUAL
76209: OR
76210: IFFALSE 76214
// continue ;
76212: GO 76172
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76214: LD_ADDR_VAR 0 8
76218: PUSH
76219: LD_EXP 58
76223: PUSH
76224: LD_VAR 0 2
76228: ARRAY
76229: PPUSH
76230: LD_INT 30
76232: PUSH
76233: LD_INT 34
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PPUSH
76240: CALL_OW 72
76244: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76245: LD_ADDR_VAR 0 9
76249: PUSH
76250: LD_EXP 58
76254: PUSH
76255: LD_VAR 0 2
76259: ARRAY
76260: PPUSH
76261: LD_INT 25
76263: PUSH
76264: LD_INT 4
76266: PUSH
76267: EMPTY
76268: LIST
76269: LIST
76270: PPUSH
76271: CALL_OW 72
76275: PPUSH
76276: LD_INT 0
76278: PPUSH
76279: CALL 53908 0 2
76283: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76284: LD_VAR 0 9
76288: NOT
76289: PUSH
76290: LD_VAR 0 8
76294: NOT
76295: OR
76296: PUSH
76297: LD_EXP 58
76301: PUSH
76302: LD_VAR 0 2
76306: ARRAY
76307: PPUSH
76308: LD_INT 124
76310: PPUSH
76311: CALL 53908 0 2
76315: OR
76316: IFFALSE 76320
// continue ;
76318: GO 76172
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76320: LD_EXP 94
76324: PUSH
76325: LD_VAR 0 2
76329: ARRAY
76330: PUSH
76331: LD_EXP 93
76335: PUSH
76336: LD_VAR 0 2
76340: ARRAY
76341: LESS
76342: PUSH
76343: LD_EXP 94
76347: PUSH
76348: LD_VAR 0 2
76352: ARRAY
76353: PUSH
76354: LD_VAR 0 8
76358: LESS
76359: AND
76360: IFFALSE 76775
// begin tmp := sci [ 1 ] ;
76362: LD_ADDR_VAR 0 7
76366: PUSH
76367: LD_VAR 0 9
76371: PUSH
76372: LD_INT 1
76374: ARRAY
76375: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76376: LD_VAR 0 7
76380: PPUSH
76381: LD_INT 124
76383: PPUSH
76384: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76388: LD_ADDR_VAR 0 3
76392: PUSH
76393: DOUBLE
76394: LD_EXP 93
76398: PUSH
76399: LD_VAR 0 2
76403: ARRAY
76404: INC
76405: ST_TO_ADDR
76406: LD_EXP 93
76410: PUSH
76411: LD_VAR 0 2
76415: ARRAY
76416: PUSH
76417: FOR_DOWNTO
76418: IFFALSE 76761
// begin if IsInUnit ( tmp ) then
76420: LD_VAR 0 7
76424: PPUSH
76425: CALL_OW 310
76429: IFFALSE 76440
// ComExitBuilding ( tmp ) ;
76431: LD_VAR 0 7
76435: PPUSH
76436: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76440: LD_INT 35
76442: PPUSH
76443: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76447: LD_VAR 0 7
76451: PPUSH
76452: CALL_OW 310
76456: NOT
76457: PUSH
76458: LD_VAR 0 7
76462: PPUSH
76463: CALL_OW 314
76467: NOT
76468: AND
76469: IFFALSE 76440
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76471: LD_ADDR_VAR 0 6
76475: PUSH
76476: LD_VAR 0 7
76480: PPUSH
76481: CALL_OW 250
76485: PUSH
76486: LD_VAR 0 7
76490: PPUSH
76491: CALL_OW 251
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76500: LD_INT 35
76502: PPUSH
76503: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76507: LD_ADDR_VAR 0 4
76511: PUSH
76512: LD_EXP 93
76516: PUSH
76517: LD_VAR 0 2
76521: ARRAY
76522: PUSH
76523: LD_VAR 0 3
76527: ARRAY
76528: PUSH
76529: LD_INT 1
76531: ARRAY
76532: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76533: LD_ADDR_VAR 0 5
76537: PUSH
76538: LD_EXP 93
76542: PUSH
76543: LD_VAR 0 2
76547: ARRAY
76548: PUSH
76549: LD_VAR 0 3
76553: ARRAY
76554: PUSH
76555: LD_INT 2
76557: ARRAY
76558: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76559: LD_VAR 0 7
76563: PPUSH
76564: LD_INT 10
76566: PPUSH
76567: CALL 23265 0 2
76571: PUSH
76572: LD_INT 4
76574: ARRAY
76575: IFFALSE 76613
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76577: LD_VAR 0 7
76581: PPUSH
76582: LD_VAR 0 6
76586: PUSH
76587: LD_INT 1
76589: ARRAY
76590: PPUSH
76591: LD_VAR 0 6
76595: PUSH
76596: LD_INT 2
76598: ARRAY
76599: PPUSH
76600: CALL_OW 111
// wait ( 0 0$10 ) ;
76604: LD_INT 350
76606: PPUSH
76607: CALL_OW 67
// end else
76611: GO 76639
// begin ComMoveXY ( tmp , x , y ) ;
76613: LD_VAR 0 7
76617: PPUSH
76618: LD_VAR 0 4
76622: PPUSH
76623: LD_VAR 0 5
76627: PPUSH
76628: CALL_OW 111
// wait ( 0 0$3 ) ;
76632: LD_INT 105
76634: PPUSH
76635: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76639: LD_VAR 0 7
76643: PPUSH
76644: LD_VAR 0 4
76648: PPUSH
76649: LD_VAR 0 5
76653: PPUSH
76654: CALL_OW 307
76658: IFFALSE 76500
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76660: LD_VAR 0 7
76664: PPUSH
76665: LD_VAR 0 4
76669: PPUSH
76670: LD_VAR 0 5
76674: PPUSH
76675: LD_VAR 0 8
76679: PUSH
76680: LD_VAR 0 3
76684: ARRAY
76685: PPUSH
76686: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
76690: LD_INT 35
76692: PPUSH
76693: CALL_OW 67
// until not HasTask ( tmp ) ;
76697: LD_VAR 0 7
76701: PPUSH
76702: CALL_OW 314
76706: NOT
76707: IFFALSE 76690
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
76709: LD_ADDR_EXP 94
76713: PUSH
76714: LD_EXP 94
76718: PPUSH
76719: LD_VAR 0 2
76723: PUSH
76724: LD_EXP 94
76728: PUSH
76729: LD_VAR 0 2
76733: ARRAY
76734: PUSH
76735: LD_INT 1
76737: PLUS
76738: PUSH
76739: EMPTY
76740: LIST
76741: LIST
76742: PPUSH
76743: LD_VAR 0 8
76747: PUSH
76748: LD_VAR 0 3
76752: ARRAY
76753: PPUSH
76754: CALL 20672 0 3
76758: ST_TO_ADDR
// end ;
76759: GO 76417
76761: POP
76762: POP
// MC_Reset ( i , 124 ) ;
76763: LD_VAR 0 2
76767: PPUSH
76768: LD_INT 124
76770: PPUSH
76771: CALL 60566 0 2
// end ; end ;
76775: GO 76172
76777: POP
76778: POP
// end ;
76779: LD_VAR 0 1
76783: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
76784: LD_INT 0
76786: PPUSH
76787: PPUSH
76788: PPUSH
// if not mc_bases then
76789: LD_EXP 58
76793: NOT
76794: IFFALSE 76798
// exit ;
76796: GO 77404
// for i = 1 to mc_bases do
76798: LD_ADDR_VAR 0 2
76802: PUSH
76803: DOUBLE
76804: LD_INT 1
76806: DEC
76807: ST_TO_ADDR
76808: LD_EXP 58
76812: PUSH
76813: FOR_TO
76814: IFFALSE 77402
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
76816: LD_ADDR_VAR 0 3
76820: PUSH
76821: LD_EXP 58
76825: PUSH
76826: LD_VAR 0 2
76830: ARRAY
76831: PPUSH
76832: LD_INT 25
76834: PUSH
76835: LD_INT 4
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: PPUSH
76842: CALL_OW 72
76846: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
76847: LD_VAR 0 3
76851: NOT
76852: PUSH
76853: LD_EXP 95
76857: PUSH
76858: LD_VAR 0 2
76862: ARRAY
76863: NOT
76864: OR
76865: PUSH
76866: LD_EXP 58
76870: PUSH
76871: LD_VAR 0 2
76875: ARRAY
76876: PPUSH
76877: LD_INT 2
76879: PUSH
76880: LD_INT 30
76882: PUSH
76883: LD_INT 0
76885: PUSH
76886: EMPTY
76887: LIST
76888: LIST
76889: PUSH
76890: LD_INT 30
76892: PUSH
76893: LD_INT 1
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: LIST
76904: PPUSH
76905: CALL_OW 72
76909: NOT
76910: OR
76911: IFFALSE 76961
// begin if mc_deposits_finder [ i ] then
76913: LD_EXP 96
76917: PUSH
76918: LD_VAR 0 2
76922: ARRAY
76923: IFFALSE 76959
// begin MC_Reset ( i , 125 ) ;
76925: LD_VAR 0 2
76929: PPUSH
76930: LD_INT 125
76932: PPUSH
76933: CALL 60566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
76937: LD_ADDR_EXP 96
76941: PUSH
76942: LD_EXP 96
76946: PPUSH
76947: LD_VAR 0 2
76951: PPUSH
76952: EMPTY
76953: PPUSH
76954: CALL_OW 1
76958: ST_TO_ADDR
// end ; continue ;
76959: GO 76813
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
76961: LD_EXP 95
76965: PUSH
76966: LD_VAR 0 2
76970: ARRAY
76971: PUSH
76972: LD_INT 1
76974: ARRAY
76975: PUSH
76976: LD_INT 3
76978: ARRAY
76979: PUSH
76980: LD_INT 1
76982: EQUAL
76983: PUSH
76984: LD_INT 20
76986: PPUSH
76987: LD_EXP 84
76991: PUSH
76992: LD_VAR 0 2
76996: ARRAY
76997: PPUSH
76998: CALL_OW 321
77002: PUSH
77003: LD_INT 2
77005: NONEQUAL
77006: AND
77007: IFFALSE 77057
// begin if mc_deposits_finder [ i ] then
77009: LD_EXP 96
77013: PUSH
77014: LD_VAR 0 2
77018: ARRAY
77019: IFFALSE 77055
// begin MC_Reset ( i , 125 ) ;
77021: LD_VAR 0 2
77025: PPUSH
77026: LD_INT 125
77028: PPUSH
77029: CALL 60566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77033: LD_ADDR_EXP 96
77037: PUSH
77038: LD_EXP 96
77042: PPUSH
77043: LD_VAR 0 2
77047: PPUSH
77048: EMPTY
77049: PPUSH
77050: CALL_OW 1
77054: ST_TO_ADDR
// end ; continue ;
77055: GO 76813
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77057: LD_EXP 95
77061: PUSH
77062: LD_VAR 0 2
77066: ARRAY
77067: PUSH
77068: LD_INT 1
77070: ARRAY
77071: PUSH
77072: LD_INT 1
77074: ARRAY
77075: PPUSH
77076: LD_EXP 95
77080: PUSH
77081: LD_VAR 0 2
77085: ARRAY
77086: PUSH
77087: LD_INT 1
77089: ARRAY
77090: PUSH
77091: LD_INT 2
77093: ARRAY
77094: PPUSH
77095: LD_EXP 84
77099: PUSH
77100: LD_VAR 0 2
77104: ARRAY
77105: PPUSH
77106: CALL_OW 440
77110: IFFALSE 77153
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77112: LD_ADDR_EXP 95
77116: PUSH
77117: LD_EXP 95
77121: PPUSH
77122: LD_VAR 0 2
77126: PPUSH
77127: LD_EXP 95
77131: PUSH
77132: LD_VAR 0 2
77136: ARRAY
77137: PPUSH
77138: LD_INT 1
77140: PPUSH
77141: CALL_OW 3
77145: PPUSH
77146: CALL_OW 1
77150: ST_TO_ADDR
77151: GO 77400
// begin if not mc_deposits_finder [ i ] then
77153: LD_EXP 96
77157: PUSH
77158: LD_VAR 0 2
77162: ARRAY
77163: NOT
77164: IFFALSE 77216
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77166: LD_ADDR_EXP 96
77170: PUSH
77171: LD_EXP 96
77175: PPUSH
77176: LD_VAR 0 2
77180: PPUSH
77181: LD_VAR 0 3
77185: PUSH
77186: LD_INT 1
77188: ARRAY
77189: PUSH
77190: EMPTY
77191: LIST
77192: PPUSH
77193: CALL_OW 1
77197: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77198: LD_VAR 0 3
77202: PUSH
77203: LD_INT 1
77205: ARRAY
77206: PPUSH
77207: LD_INT 125
77209: PPUSH
77210: CALL_OW 109
// end else
77214: GO 77400
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77216: LD_EXP 96
77220: PUSH
77221: LD_VAR 0 2
77225: ARRAY
77226: PUSH
77227: LD_INT 1
77229: ARRAY
77230: PPUSH
77231: CALL_OW 310
77235: IFFALSE 77258
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77237: LD_EXP 96
77241: PUSH
77242: LD_VAR 0 2
77246: ARRAY
77247: PUSH
77248: LD_INT 1
77250: ARRAY
77251: PPUSH
77252: CALL_OW 122
77256: GO 77400
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77258: LD_EXP 96
77262: PUSH
77263: LD_VAR 0 2
77267: ARRAY
77268: PUSH
77269: LD_INT 1
77271: ARRAY
77272: PPUSH
77273: CALL_OW 314
77277: NOT
77278: PUSH
77279: LD_EXP 96
77283: PUSH
77284: LD_VAR 0 2
77288: ARRAY
77289: PUSH
77290: LD_INT 1
77292: ARRAY
77293: PPUSH
77294: LD_EXP 95
77298: PUSH
77299: LD_VAR 0 2
77303: ARRAY
77304: PUSH
77305: LD_INT 1
77307: ARRAY
77308: PUSH
77309: LD_INT 1
77311: ARRAY
77312: PPUSH
77313: LD_EXP 95
77317: PUSH
77318: LD_VAR 0 2
77322: ARRAY
77323: PUSH
77324: LD_INT 1
77326: ARRAY
77327: PUSH
77328: LD_INT 2
77330: ARRAY
77331: PPUSH
77332: CALL_OW 297
77336: PUSH
77337: LD_INT 6
77339: GREATER
77340: AND
77341: IFFALSE 77400
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77343: LD_EXP 96
77347: PUSH
77348: LD_VAR 0 2
77352: ARRAY
77353: PUSH
77354: LD_INT 1
77356: ARRAY
77357: PPUSH
77358: LD_EXP 95
77362: PUSH
77363: LD_VAR 0 2
77367: ARRAY
77368: PUSH
77369: LD_INT 1
77371: ARRAY
77372: PUSH
77373: LD_INT 1
77375: ARRAY
77376: PPUSH
77377: LD_EXP 95
77381: PUSH
77382: LD_VAR 0 2
77386: ARRAY
77387: PUSH
77388: LD_INT 1
77390: ARRAY
77391: PUSH
77392: LD_INT 2
77394: ARRAY
77395: PPUSH
77396: CALL_OW 111
// end ; end ; end ;
77400: GO 76813
77402: POP
77403: POP
// end ;
77404: LD_VAR 0 1
77408: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77409: LD_INT 0
77411: PPUSH
77412: PPUSH
77413: PPUSH
77414: PPUSH
77415: PPUSH
77416: PPUSH
77417: PPUSH
77418: PPUSH
77419: PPUSH
77420: PPUSH
77421: PPUSH
// if not mc_bases then
77422: LD_EXP 58
77426: NOT
77427: IFFALSE 77431
// exit ;
77429: GO 78155
// for i = 1 to mc_bases do
77431: LD_ADDR_VAR 0 2
77435: PUSH
77436: DOUBLE
77437: LD_INT 1
77439: DEC
77440: ST_TO_ADDR
77441: LD_EXP 58
77445: PUSH
77446: FOR_TO
77447: IFFALSE 78153
// begin if not mc_bases [ i ] then
77449: LD_EXP 58
77453: PUSH
77454: LD_VAR 0 2
77458: ARRAY
77459: NOT
77460: IFFALSE 77464
// continue ;
77462: GO 77446
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77464: LD_ADDR_VAR 0 7
77468: PUSH
77469: LD_EXP 58
77473: PUSH
77474: LD_VAR 0 2
77478: ARRAY
77479: PUSH
77480: LD_INT 1
77482: ARRAY
77483: PPUSH
77484: CALL_OW 248
77488: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77489: LD_VAR 0 7
77493: PUSH
77494: LD_INT 3
77496: EQUAL
77497: PUSH
77498: LD_EXP 77
77502: PUSH
77503: LD_VAR 0 2
77507: ARRAY
77508: PUSH
77509: LD_EXP 80
77513: PUSH
77514: LD_VAR 0 2
77518: ARRAY
77519: UNION
77520: PPUSH
77521: LD_INT 33
77523: PUSH
77524: LD_INT 2
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PPUSH
77531: CALL_OW 72
77535: NOT
77536: OR
77537: IFFALSE 77541
// continue ;
77539: GO 77446
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77541: LD_ADDR_VAR 0 9
77545: PUSH
77546: LD_EXP 58
77550: PUSH
77551: LD_VAR 0 2
77555: ARRAY
77556: PPUSH
77557: LD_INT 30
77559: PUSH
77560: LD_INT 36
77562: PUSH
77563: EMPTY
77564: LIST
77565: LIST
77566: PPUSH
77567: CALL_OW 72
77571: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77572: LD_ADDR_VAR 0 10
77576: PUSH
77577: LD_EXP 77
77581: PUSH
77582: LD_VAR 0 2
77586: ARRAY
77587: PPUSH
77588: LD_INT 34
77590: PUSH
77591: LD_INT 31
77593: PUSH
77594: EMPTY
77595: LIST
77596: LIST
77597: PPUSH
77598: CALL_OW 72
77602: ST_TO_ADDR
// if not cts and not mcts then
77603: LD_VAR 0 9
77607: NOT
77608: PUSH
77609: LD_VAR 0 10
77613: NOT
77614: AND
77615: IFFALSE 77619
// continue ;
77617: GO 77446
// x := cts ;
77619: LD_ADDR_VAR 0 11
77623: PUSH
77624: LD_VAR 0 9
77628: ST_TO_ADDR
// if not x then
77629: LD_VAR 0 11
77633: NOT
77634: IFFALSE 77646
// x := mcts ;
77636: LD_ADDR_VAR 0 11
77640: PUSH
77641: LD_VAR 0 10
77645: ST_TO_ADDR
// if mc_remote_driver [ i ] then
77646: LD_EXP 98
77650: PUSH
77651: LD_VAR 0 2
77655: ARRAY
77656: IFFALSE 77925
// for j in mc_remote_driver [ i ] do
77658: LD_ADDR_VAR 0 3
77662: PUSH
77663: LD_EXP 98
77667: PUSH
77668: LD_VAR 0 2
77672: ARRAY
77673: PUSH
77674: FOR_IN
77675: IFFALSE 77923
// begin if GetClass ( j ) <> 3 then
77677: LD_VAR 0 3
77681: PPUSH
77682: CALL_OW 257
77686: PUSH
77687: LD_INT 3
77689: NONEQUAL
77690: IFFALSE 77743
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
77692: LD_ADDR_EXP 98
77696: PUSH
77697: LD_EXP 98
77701: PPUSH
77702: LD_VAR 0 2
77706: PPUSH
77707: LD_EXP 98
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: PUSH
77718: LD_VAR 0 3
77722: DIFF
77723: PPUSH
77724: CALL_OW 1
77728: ST_TO_ADDR
// SetTag ( j , 0 ) ;
77729: LD_VAR 0 3
77733: PPUSH
77734: LD_INT 0
77736: PPUSH
77737: CALL_OW 109
// continue ;
77741: GO 77674
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
77743: LD_VAR 0 3
77747: PPUSH
77748: CALL_OW 310
77752: NOT
77753: PUSH
77754: LD_VAR 0 3
77758: PPUSH
77759: CALL_OW 310
77763: PPUSH
77764: CALL_OW 266
77768: PUSH
77769: LD_INT 36
77771: NONEQUAL
77772: PUSH
77773: LD_VAR 0 3
77777: PPUSH
77778: CALL 53996 0 1
77782: NOT
77783: AND
77784: OR
77785: IFFALSE 77921
// begin if IsInUnit ( j ) then
77787: LD_VAR 0 3
77791: PPUSH
77792: CALL_OW 310
77796: IFFALSE 77807
// ComExitBuilding ( j ) ;
77798: LD_VAR 0 3
77802: PPUSH
77803: CALL_OW 122
// ct := 0 ;
77807: LD_ADDR_VAR 0 8
77811: PUSH
77812: LD_INT 0
77814: ST_TO_ADDR
// for k in x do
77815: LD_ADDR_VAR 0 4
77819: PUSH
77820: LD_VAR 0 11
77824: PUSH
77825: FOR_IN
77826: IFFALSE 77899
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
77828: LD_VAR 0 4
77832: PPUSH
77833: CALL_OW 264
77837: PUSH
77838: LD_INT 31
77840: EQUAL
77841: PUSH
77842: LD_VAR 0 4
77846: PPUSH
77847: CALL_OW 311
77851: NOT
77852: AND
77853: PUSH
77854: LD_VAR 0 4
77858: PPUSH
77859: CALL_OW 266
77863: PUSH
77864: LD_INT 36
77866: EQUAL
77867: PUSH
77868: LD_VAR 0 4
77872: PPUSH
77873: CALL_OW 313
77877: PUSH
77878: LD_INT 3
77880: LESS
77881: AND
77882: OR
77883: IFFALSE 77897
// begin ct := k ;
77885: LD_ADDR_VAR 0 8
77889: PUSH
77890: LD_VAR 0 4
77894: ST_TO_ADDR
// break ;
77895: GO 77899
// end ;
77897: GO 77825
77899: POP
77900: POP
// if ct then
77901: LD_VAR 0 8
77905: IFFALSE 77921
// ComEnterUnit ( j , ct ) ;
77907: LD_VAR 0 3
77911: PPUSH
77912: LD_VAR 0 8
77916: PPUSH
77917: CALL_OW 120
// end ; end ;
77921: GO 77674
77923: POP
77924: POP
// places := 0 ;
77925: LD_ADDR_VAR 0 5
77929: PUSH
77930: LD_INT 0
77932: ST_TO_ADDR
// for j = 1 to x do
77933: LD_ADDR_VAR 0 3
77937: PUSH
77938: DOUBLE
77939: LD_INT 1
77941: DEC
77942: ST_TO_ADDR
77943: LD_VAR 0 11
77947: PUSH
77948: FOR_TO
77949: IFFALSE 78004
// if GetWeapon ( x [ j ] ) = ar_control_tower then
77951: LD_VAR 0 11
77955: PUSH
77956: LD_VAR 0 3
77960: ARRAY
77961: PPUSH
77962: CALL_OW 264
77966: PUSH
77967: LD_INT 31
77969: EQUAL
77970: IFFALSE 77988
// places := places + 1 else
77972: LD_ADDR_VAR 0 5
77976: PUSH
77977: LD_VAR 0 5
77981: PUSH
77982: LD_INT 1
77984: PLUS
77985: ST_TO_ADDR
77986: GO 78002
// places := places + 3 ;
77988: LD_ADDR_VAR 0 5
77992: PUSH
77993: LD_VAR 0 5
77997: PUSH
77998: LD_INT 3
78000: PLUS
78001: ST_TO_ADDR
78002: GO 77948
78004: POP
78005: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78006: LD_ADDR_VAR 0 6
78010: PUSH
78011: LD_EXP 58
78015: PUSH
78016: LD_VAR 0 2
78020: ARRAY
78021: PPUSH
78022: LD_INT 25
78024: PUSH
78025: LD_INT 3
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PPUSH
78032: CALL_OW 72
78036: PUSH
78037: LD_EXP 98
78041: PUSH
78042: LD_VAR 0 2
78046: ARRAY
78047: DIFF
78048: PPUSH
78049: LD_INT 3
78051: PPUSH
78052: CALL 54896 0 2
78056: ST_TO_ADDR
// if not tmp then
78057: LD_VAR 0 6
78061: NOT
78062: IFFALSE 78066
// continue ;
78064: GO 77446
// places := places - mc_remote_driver [ i ] ;
78066: LD_ADDR_VAR 0 5
78070: PUSH
78071: LD_VAR 0 5
78075: PUSH
78076: LD_EXP 98
78080: PUSH
78081: LD_VAR 0 2
78085: ARRAY
78086: MINUS
78087: ST_TO_ADDR
// if places then
78088: LD_VAR 0 5
78092: IFFALSE 78151
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78094: LD_ADDR_EXP 98
78098: PUSH
78099: LD_EXP 98
78103: PPUSH
78104: LD_VAR 0 2
78108: PPUSH
78109: LD_EXP 98
78113: PUSH
78114: LD_VAR 0 2
78118: ARRAY
78119: PUSH
78120: LD_VAR 0 6
78124: PUSH
78125: LD_INT 1
78127: ARRAY
78128: UNION
78129: PPUSH
78130: CALL_OW 1
78134: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78135: LD_VAR 0 6
78139: PUSH
78140: LD_INT 1
78142: ARRAY
78143: PPUSH
78144: LD_INT 126
78146: PPUSH
78147: CALL_OW 109
// end ; end ;
78151: GO 77446
78153: POP
78154: POP
// end ;
78155: LD_VAR 0 1
78159: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78160: LD_INT 0
78162: PPUSH
78163: PPUSH
78164: PPUSH
78165: PPUSH
78166: PPUSH
78167: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78168: LD_VAR 0 1
78172: NOT
78173: PUSH
78174: LD_VAR 0 2
78178: NOT
78179: OR
78180: PUSH
78181: LD_VAR 0 3
78185: NOT
78186: OR
78187: PUSH
78188: LD_VAR 0 4
78192: PUSH
78193: LD_INT 1
78195: PUSH
78196: LD_INT 2
78198: PUSH
78199: LD_INT 3
78201: PUSH
78202: LD_INT 4
78204: PUSH
78205: LD_INT 5
78207: PUSH
78208: LD_INT 8
78210: PUSH
78211: LD_INT 9
78213: PUSH
78214: LD_INT 15
78216: PUSH
78217: LD_INT 16
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: IN
78231: NOT
78232: OR
78233: IFFALSE 78237
// exit ;
78235: GO 79137
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78237: LD_ADDR_VAR 0 2
78241: PUSH
78242: LD_VAR 0 2
78246: PPUSH
78247: LD_INT 21
78249: PUSH
78250: LD_INT 3
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 24
78259: PUSH
78260: LD_INT 250
78262: PUSH
78263: EMPTY
78264: LIST
78265: LIST
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PPUSH
78271: CALL_OW 72
78275: ST_TO_ADDR
// case class of 1 , 15 :
78276: LD_VAR 0 4
78280: PUSH
78281: LD_INT 1
78283: DOUBLE
78284: EQUAL
78285: IFTRUE 78295
78287: LD_INT 15
78289: DOUBLE
78290: EQUAL
78291: IFTRUE 78295
78293: GO 78380
78295: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78296: LD_ADDR_VAR 0 8
78300: PUSH
78301: LD_VAR 0 2
78305: PPUSH
78306: LD_INT 2
78308: PUSH
78309: LD_INT 30
78311: PUSH
78312: LD_INT 32
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 30
78321: PUSH
78322: LD_INT 31
78324: PUSH
78325: EMPTY
78326: LIST
78327: LIST
78328: PUSH
78329: EMPTY
78330: LIST
78331: LIST
78332: LIST
78333: PPUSH
78334: CALL_OW 72
78338: PUSH
78339: LD_VAR 0 2
78343: PPUSH
78344: LD_INT 2
78346: PUSH
78347: LD_INT 30
78349: PUSH
78350: LD_INT 4
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 30
78359: PUSH
78360: LD_INT 5
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: EMPTY
78368: LIST
78369: LIST
78370: LIST
78371: PPUSH
78372: CALL_OW 72
78376: ADD
78377: ST_TO_ADDR
78378: GO 78626
78380: LD_INT 2
78382: DOUBLE
78383: EQUAL
78384: IFTRUE 78394
78386: LD_INT 16
78388: DOUBLE
78389: EQUAL
78390: IFTRUE 78394
78392: GO 78440
78394: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78395: LD_ADDR_VAR 0 8
78399: PUSH
78400: LD_VAR 0 2
78404: PPUSH
78405: LD_INT 2
78407: PUSH
78408: LD_INT 30
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 30
78420: PUSH
78421: LD_INT 1
78423: PUSH
78424: EMPTY
78425: LIST
78426: LIST
78427: PUSH
78428: EMPTY
78429: LIST
78430: LIST
78431: LIST
78432: PPUSH
78433: CALL_OW 72
78437: ST_TO_ADDR
78438: GO 78626
78440: LD_INT 3
78442: DOUBLE
78443: EQUAL
78444: IFTRUE 78448
78446: GO 78494
78448: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78449: LD_ADDR_VAR 0 8
78453: PUSH
78454: LD_VAR 0 2
78458: PPUSH
78459: LD_INT 2
78461: PUSH
78462: LD_INT 30
78464: PUSH
78465: LD_INT 2
78467: PUSH
78468: EMPTY
78469: LIST
78470: LIST
78471: PUSH
78472: LD_INT 30
78474: PUSH
78475: LD_INT 3
78477: PUSH
78478: EMPTY
78479: LIST
78480: LIST
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: LIST
78486: PPUSH
78487: CALL_OW 72
78491: ST_TO_ADDR
78492: GO 78626
78494: LD_INT 4
78496: DOUBLE
78497: EQUAL
78498: IFTRUE 78502
78500: GO 78559
78502: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
78503: LD_ADDR_VAR 0 8
78507: PUSH
78508: LD_VAR 0 2
78512: PPUSH
78513: LD_INT 2
78515: PUSH
78516: LD_INT 30
78518: PUSH
78519: LD_INT 6
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 30
78528: PUSH
78529: LD_INT 7
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 30
78538: PUSH
78539: LD_INT 8
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: PPUSH
78552: CALL_OW 72
78556: ST_TO_ADDR
78557: GO 78626
78559: LD_INT 5
78561: DOUBLE
78562: EQUAL
78563: IFTRUE 78579
78565: LD_INT 8
78567: DOUBLE
78568: EQUAL
78569: IFTRUE 78579
78571: LD_INT 9
78573: DOUBLE
78574: EQUAL
78575: IFTRUE 78579
78577: GO 78625
78579: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
78580: LD_ADDR_VAR 0 8
78584: PUSH
78585: LD_VAR 0 2
78589: PPUSH
78590: LD_INT 2
78592: PUSH
78593: LD_INT 30
78595: PUSH
78596: LD_INT 4
78598: PUSH
78599: EMPTY
78600: LIST
78601: LIST
78602: PUSH
78603: LD_INT 30
78605: PUSH
78606: LD_INT 5
78608: PUSH
78609: EMPTY
78610: LIST
78611: LIST
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: LIST
78617: PPUSH
78618: CALL_OW 72
78622: ST_TO_ADDR
78623: GO 78626
78625: POP
// if not tmp then
78626: LD_VAR 0 8
78630: NOT
78631: IFFALSE 78635
// exit ;
78633: GO 79137
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
78635: LD_VAR 0 4
78639: PUSH
78640: LD_INT 1
78642: PUSH
78643: LD_INT 15
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: IN
78650: PUSH
78651: LD_EXP 67
78655: PUSH
78656: LD_VAR 0 1
78660: ARRAY
78661: AND
78662: IFFALSE 78818
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
78664: LD_ADDR_VAR 0 9
78668: PUSH
78669: LD_EXP 67
78673: PUSH
78674: LD_VAR 0 1
78678: ARRAY
78679: PUSH
78680: LD_INT 1
78682: ARRAY
78683: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
78684: LD_VAR 0 9
78688: PUSH
78689: LD_EXP 68
78693: PUSH
78694: LD_VAR 0 1
78698: ARRAY
78699: IN
78700: NOT
78701: IFFALSE 78816
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
78703: LD_ADDR_EXP 68
78707: PUSH
78708: LD_EXP 68
78712: PPUSH
78713: LD_VAR 0 1
78717: PUSH
78718: LD_EXP 68
78722: PUSH
78723: LD_VAR 0 1
78727: ARRAY
78728: PUSH
78729: LD_INT 1
78731: PLUS
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PPUSH
78737: LD_VAR 0 9
78741: PPUSH
78742: CALL 20672 0 3
78746: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
78747: LD_ADDR_EXP 67
78751: PUSH
78752: LD_EXP 67
78756: PPUSH
78757: LD_VAR 0 1
78761: PPUSH
78762: LD_EXP 67
78766: PUSH
78767: LD_VAR 0 1
78771: ARRAY
78772: PUSH
78773: LD_VAR 0 9
78777: DIFF
78778: PPUSH
78779: CALL_OW 1
78783: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
78784: LD_VAR 0 3
78788: PPUSH
78789: LD_EXP 68
78793: PUSH
78794: LD_VAR 0 1
78798: ARRAY
78799: PUSH
78800: LD_EXP 68
78804: PUSH
78805: LD_VAR 0 1
78809: ARRAY
78810: ARRAY
78811: PPUSH
78812: CALL_OW 120
// end ; exit ;
78816: GO 79137
// end ; if tmp > 1 then
78818: LD_VAR 0 8
78822: PUSH
78823: LD_INT 1
78825: GREATER
78826: IFFALSE 78930
// for i = 2 to tmp do
78828: LD_ADDR_VAR 0 6
78832: PUSH
78833: DOUBLE
78834: LD_INT 2
78836: DEC
78837: ST_TO_ADDR
78838: LD_VAR 0 8
78842: PUSH
78843: FOR_TO
78844: IFFALSE 78928
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
78846: LD_VAR 0 8
78850: PUSH
78851: LD_VAR 0 6
78855: ARRAY
78856: PPUSH
78857: CALL_OW 461
78861: PUSH
78862: LD_INT 6
78864: EQUAL
78865: IFFALSE 78926
// begin x := tmp [ i ] ;
78867: LD_ADDR_VAR 0 9
78871: PUSH
78872: LD_VAR 0 8
78876: PUSH
78877: LD_VAR 0 6
78881: ARRAY
78882: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
78883: LD_ADDR_VAR 0 8
78887: PUSH
78888: LD_VAR 0 8
78892: PPUSH
78893: LD_VAR 0 6
78897: PPUSH
78898: CALL_OW 3
78902: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
78903: LD_ADDR_VAR 0 8
78907: PUSH
78908: LD_VAR 0 8
78912: PPUSH
78913: LD_INT 1
78915: PPUSH
78916: LD_VAR 0 9
78920: PPUSH
78921: CALL_OW 2
78925: ST_TO_ADDR
// end ;
78926: GO 78843
78928: POP
78929: POP
// for i in tmp do
78930: LD_ADDR_VAR 0 6
78934: PUSH
78935: LD_VAR 0 8
78939: PUSH
78940: FOR_IN
78941: IFFALSE 79010
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
78943: LD_VAR 0 6
78947: PPUSH
78948: CALL_OW 313
78952: PUSH
78953: LD_INT 6
78955: LESS
78956: PUSH
78957: LD_VAR 0 6
78961: PPUSH
78962: CALL_OW 266
78966: PUSH
78967: LD_INT 31
78969: PUSH
78970: LD_INT 32
78972: PUSH
78973: EMPTY
78974: LIST
78975: LIST
78976: IN
78977: NOT
78978: AND
78979: PUSH
78980: LD_VAR 0 6
78984: PPUSH
78985: CALL_OW 313
78989: PUSH
78990: LD_INT 0
78992: EQUAL
78993: OR
78994: IFFALSE 79008
// begin j := i ;
78996: LD_ADDR_VAR 0 7
79000: PUSH
79001: LD_VAR 0 6
79005: ST_TO_ADDR
// break ;
79006: GO 79010
// end ; end ;
79008: GO 78940
79010: POP
79011: POP
// if j then
79012: LD_VAR 0 7
79016: IFFALSE 79034
// ComEnterUnit ( unit , j ) else
79018: LD_VAR 0 3
79022: PPUSH
79023: LD_VAR 0 7
79027: PPUSH
79028: CALL_OW 120
79032: GO 79137
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79034: LD_ADDR_VAR 0 10
79038: PUSH
79039: LD_VAR 0 2
79043: PPUSH
79044: LD_INT 2
79046: PUSH
79047: LD_INT 30
79049: PUSH
79050: LD_INT 0
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 30
79059: PUSH
79060: LD_INT 1
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: EMPTY
79068: LIST
79069: LIST
79070: LIST
79071: PPUSH
79072: CALL_OW 72
79076: ST_TO_ADDR
// if depot then
79077: LD_VAR 0 10
79081: IFFALSE 79137
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79083: LD_ADDR_VAR 0 10
79087: PUSH
79088: LD_VAR 0 10
79092: PPUSH
79093: LD_VAR 0 3
79097: PPUSH
79098: CALL_OW 74
79102: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79103: LD_VAR 0 3
79107: PPUSH
79108: LD_VAR 0 10
79112: PPUSH
79113: CALL_OW 296
79117: PUSH
79118: LD_INT 10
79120: GREATER
79121: IFFALSE 79137
// ComStandNearbyBuilding ( unit , depot ) ;
79123: LD_VAR 0 3
79127: PPUSH
79128: LD_VAR 0 10
79132: PPUSH
79133: CALL 15349 0 2
// end ; end ; end ;
79137: LD_VAR 0 5
79141: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79142: LD_INT 0
79144: PPUSH
79145: PPUSH
79146: PPUSH
79147: PPUSH
// if not mc_bases then
79148: LD_EXP 58
79152: NOT
79153: IFFALSE 79157
// exit ;
79155: GO 79396
// for i = 1 to mc_bases do
79157: LD_ADDR_VAR 0 2
79161: PUSH
79162: DOUBLE
79163: LD_INT 1
79165: DEC
79166: ST_TO_ADDR
79167: LD_EXP 58
79171: PUSH
79172: FOR_TO
79173: IFFALSE 79394
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79175: LD_ADDR_VAR 0 4
79179: PUSH
79180: LD_EXP 58
79184: PUSH
79185: LD_VAR 0 2
79189: ARRAY
79190: PPUSH
79191: LD_INT 21
79193: PUSH
79194: LD_INT 1
79196: PUSH
79197: EMPTY
79198: LIST
79199: LIST
79200: PPUSH
79201: CALL_OW 72
79205: PUSH
79206: LD_EXP 87
79210: PUSH
79211: LD_VAR 0 2
79215: ARRAY
79216: UNION
79217: ST_TO_ADDR
// if not tmp then
79218: LD_VAR 0 4
79222: NOT
79223: IFFALSE 79227
// continue ;
79225: GO 79172
// for j in tmp do
79227: LD_ADDR_VAR 0 3
79231: PUSH
79232: LD_VAR 0 4
79236: PUSH
79237: FOR_IN
79238: IFFALSE 79390
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79240: LD_VAR 0 3
79244: PPUSH
79245: CALL_OW 110
79249: NOT
79250: PUSH
79251: LD_VAR 0 3
79255: PPUSH
79256: CALL_OW 314
79260: NOT
79261: AND
79262: PUSH
79263: LD_VAR 0 3
79267: PPUSH
79268: CALL_OW 311
79272: NOT
79273: AND
79274: PUSH
79275: LD_VAR 0 3
79279: PPUSH
79280: CALL_OW 310
79284: NOT
79285: AND
79286: PUSH
79287: LD_VAR 0 3
79291: PUSH
79292: LD_EXP 61
79296: PUSH
79297: LD_VAR 0 2
79301: ARRAY
79302: PUSH
79303: LD_INT 1
79305: ARRAY
79306: IN
79307: NOT
79308: AND
79309: PUSH
79310: LD_VAR 0 3
79314: PUSH
79315: LD_EXP 61
79319: PUSH
79320: LD_VAR 0 2
79324: ARRAY
79325: PUSH
79326: LD_INT 2
79328: ARRAY
79329: IN
79330: NOT
79331: AND
79332: PUSH
79333: LD_VAR 0 3
79337: PUSH
79338: LD_EXP 70
79342: PUSH
79343: LD_VAR 0 2
79347: ARRAY
79348: IN
79349: NOT
79350: AND
79351: IFFALSE 79388
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79353: LD_VAR 0 2
79357: PPUSH
79358: LD_EXP 58
79362: PUSH
79363: LD_VAR 0 2
79367: ARRAY
79368: PPUSH
79369: LD_VAR 0 3
79373: PPUSH
79374: LD_VAR 0 3
79378: PPUSH
79379: CALL_OW 257
79383: PPUSH
79384: CALL 78160 0 4
// end ;
79388: GO 79237
79390: POP
79391: POP
// end ;
79392: GO 79172
79394: POP
79395: POP
// end ;
79396: LD_VAR 0 1
79400: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79401: LD_INT 0
79403: PPUSH
79404: PPUSH
79405: PPUSH
79406: PPUSH
79407: PPUSH
79408: PPUSH
// if not mc_bases [ base ] then
79409: LD_EXP 58
79413: PUSH
79414: LD_VAR 0 1
79418: ARRAY
79419: NOT
79420: IFFALSE 79424
// exit ;
79422: GO 79606
// tmp := [ ] ;
79424: LD_ADDR_VAR 0 6
79428: PUSH
79429: EMPTY
79430: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79431: LD_ADDR_VAR 0 7
79435: PUSH
79436: LD_VAR 0 3
79440: PPUSH
79441: LD_INT 0
79443: PPUSH
79444: CALL_OW 517
79448: ST_TO_ADDR
// if not list then
79449: LD_VAR 0 7
79453: NOT
79454: IFFALSE 79458
// exit ;
79456: GO 79606
// for i = 1 to amount do
79458: LD_ADDR_VAR 0 5
79462: PUSH
79463: DOUBLE
79464: LD_INT 1
79466: DEC
79467: ST_TO_ADDR
79468: LD_VAR 0 2
79472: PUSH
79473: FOR_TO
79474: IFFALSE 79554
// begin x := rand ( 1 , list [ 1 ] ) ;
79476: LD_ADDR_VAR 0 8
79480: PUSH
79481: LD_INT 1
79483: PPUSH
79484: LD_VAR 0 7
79488: PUSH
79489: LD_INT 1
79491: ARRAY
79492: PPUSH
79493: CALL_OW 12
79497: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
79498: LD_ADDR_VAR 0 6
79502: PUSH
79503: LD_VAR 0 6
79507: PPUSH
79508: LD_VAR 0 5
79512: PPUSH
79513: LD_VAR 0 7
79517: PUSH
79518: LD_INT 1
79520: ARRAY
79521: PUSH
79522: LD_VAR 0 8
79526: ARRAY
79527: PUSH
79528: LD_VAR 0 7
79532: PUSH
79533: LD_INT 2
79535: ARRAY
79536: PUSH
79537: LD_VAR 0 8
79541: ARRAY
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PPUSH
79547: CALL_OW 1
79551: ST_TO_ADDR
// end ;
79552: GO 79473
79554: POP
79555: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
79556: LD_ADDR_EXP 71
79560: PUSH
79561: LD_EXP 71
79565: PPUSH
79566: LD_VAR 0 1
79570: PPUSH
79571: LD_VAR 0 6
79575: PPUSH
79576: CALL_OW 1
79580: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
79581: LD_ADDR_EXP 73
79585: PUSH
79586: LD_EXP 73
79590: PPUSH
79591: LD_VAR 0 1
79595: PPUSH
79596: LD_VAR 0 3
79600: PPUSH
79601: CALL_OW 1
79605: ST_TO_ADDR
// end ;
79606: LD_VAR 0 4
79610: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
79611: LD_INT 0
79613: PPUSH
// if not mc_bases [ base ] then
79614: LD_EXP 58
79618: PUSH
79619: LD_VAR 0 1
79623: ARRAY
79624: NOT
79625: IFFALSE 79629
// exit ;
79627: GO 79654
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
79629: LD_ADDR_EXP 63
79633: PUSH
79634: LD_EXP 63
79638: PPUSH
79639: LD_VAR 0 1
79643: PPUSH
79644: LD_VAR 0 2
79648: PPUSH
79649: CALL_OW 1
79653: ST_TO_ADDR
// end ;
79654: LD_VAR 0 3
79658: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
79659: LD_INT 0
79661: PPUSH
// if not mc_bases [ base ] then
79662: LD_EXP 58
79666: PUSH
79667: LD_VAR 0 1
79671: ARRAY
79672: NOT
79673: IFFALSE 79677
// exit ;
79675: GO 79714
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
79677: LD_ADDR_EXP 63
79681: PUSH
79682: LD_EXP 63
79686: PPUSH
79687: LD_VAR 0 1
79691: PPUSH
79692: LD_EXP 63
79696: PUSH
79697: LD_VAR 0 1
79701: ARRAY
79702: PUSH
79703: LD_VAR 0 2
79707: UNION
79708: PPUSH
79709: CALL_OW 1
79713: ST_TO_ADDR
// end ;
79714: LD_VAR 0 3
79718: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
79719: LD_INT 0
79721: PPUSH
// if not mc_bases [ base ] then
79722: LD_EXP 58
79726: PUSH
79727: LD_VAR 0 1
79731: ARRAY
79732: NOT
79733: IFFALSE 79737
// exit ;
79735: GO 79762
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
79737: LD_ADDR_EXP 79
79741: PUSH
79742: LD_EXP 79
79746: PPUSH
79747: LD_VAR 0 1
79751: PPUSH
79752: LD_VAR 0 2
79756: PPUSH
79757: CALL_OW 1
79761: ST_TO_ADDR
// end ;
79762: LD_VAR 0 3
79766: RET
// export function MC_InsertProduceList ( base , components ) ; begin
79767: LD_INT 0
79769: PPUSH
// if not mc_bases [ base ] then
79770: LD_EXP 58
79774: PUSH
79775: LD_VAR 0 1
79779: ARRAY
79780: NOT
79781: IFFALSE 79785
// exit ;
79783: GO 79822
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
79785: LD_ADDR_EXP 79
79789: PUSH
79790: LD_EXP 79
79794: PPUSH
79795: LD_VAR 0 1
79799: PPUSH
79800: LD_EXP 79
79804: PUSH
79805: LD_VAR 0 1
79809: ARRAY
79810: PUSH
79811: LD_VAR 0 2
79815: ADD
79816: PPUSH
79817: CALL_OW 1
79821: ST_TO_ADDR
// end ;
79822: LD_VAR 0 3
79826: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
79827: LD_INT 0
79829: PPUSH
// if not mc_bases [ base ] then
79830: LD_EXP 58
79834: PUSH
79835: LD_VAR 0 1
79839: ARRAY
79840: NOT
79841: IFFALSE 79845
// exit ;
79843: GO 79899
// mc_defender := Replace ( mc_defender , base , deflist ) ;
79845: LD_ADDR_EXP 80
79849: PUSH
79850: LD_EXP 80
79854: PPUSH
79855: LD_VAR 0 1
79859: PPUSH
79860: LD_VAR 0 2
79864: PPUSH
79865: CALL_OW 1
79869: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
79870: LD_ADDR_EXP 69
79874: PUSH
79875: LD_EXP 69
79879: PPUSH
79880: LD_VAR 0 1
79884: PPUSH
79885: LD_VAR 0 2
79889: PUSH
79890: LD_INT 0
79892: PLUS
79893: PPUSH
79894: CALL_OW 1
79898: ST_TO_ADDR
// end ;
79899: LD_VAR 0 3
79903: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
79904: LD_INT 0
79906: PPUSH
// if not mc_bases [ base ] then
79907: LD_EXP 58
79911: PUSH
79912: LD_VAR 0 1
79916: ARRAY
79917: NOT
79918: IFFALSE 79922
// exit ;
79920: GO 79947
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
79922: LD_ADDR_EXP 69
79926: PUSH
79927: LD_EXP 69
79931: PPUSH
79932: LD_VAR 0 1
79936: PPUSH
79937: LD_VAR 0 2
79941: PPUSH
79942: CALL_OW 1
79946: ST_TO_ADDR
// end ;
79947: LD_VAR 0 3
79951: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
79952: LD_INT 0
79954: PPUSH
79955: PPUSH
79956: PPUSH
79957: PPUSH
// if not mc_bases [ base ] then
79958: LD_EXP 58
79962: PUSH
79963: LD_VAR 0 1
79967: ARRAY
79968: NOT
79969: IFFALSE 79973
// exit ;
79971: GO 80038
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
79973: LD_ADDR_EXP 78
79977: PUSH
79978: LD_EXP 78
79982: PPUSH
79983: LD_VAR 0 1
79987: PUSH
79988: LD_EXP 78
79992: PUSH
79993: LD_VAR 0 1
79997: ARRAY
79998: PUSH
79999: LD_INT 1
80001: PLUS
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PPUSH
80007: LD_VAR 0 1
80011: PUSH
80012: LD_VAR 0 2
80016: PUSH
80017: LD_VAR 0 3
80021: PUSH
80022: LD_VAR 0 4
80026: PUSH
80027: EMPTY
80028: LIST
80029: LIST
80030: LIST
80031: LIST
80032: PPUSH
80033: CALL 20672 0 3
80037: ST_TO_ADDR
// end ;
80038: LD_VAR 0 5
80042: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80043: LD_INT 0
80045: PPUSH
// if not mc_bases [ base ] then
80046: LD_EXP 58
80050: PUSH
80051: LD_VAR 0 1
80055: ARRAY
80056: NOT
80057: IFFALSE 80061
// exit ;
80059: GO 80086
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80061: LD_ADDR_EXP 95
80065: PUSH
80066: LD_EXP 95
80070: PPUSH
80071: LD_VAR 0 1
80075: PPUSH
80076: LD_VAR 0 2
80080: PPUSH
80081: CALL_OW 1
80085: ST_TO_ADDR
// end ;
80086: LD_VAR 0 3
80090: RET
// export function MC_GetMinesField ( base ) ; begin
80091: LD_INT 0
80093: PPUSH
// result := mc_mines [ base ] ;
80094: LD_ADDR_VAR 0 2
80098: PUSH
80099: LD_EXP 71
80103: PUSH
80104: LD_VAR 0 1
80108: ARRAY
80109: ST_TO_ADDR
// end ;
80110: LD_VAR 0 2
80114: RET
// export function MC_GetProduceList ( base ) ; begin
80115: LD_INT 0
80117: PPUSH
// result := mc_produce [ base ] ;
80118: LD_ADDR_VAR 0 2
80122: PUSH
80123: LD_EXP 79
80127: PUSH
80128: LD_VAR 0 1
80132: ARRAY
80133: ST_TO_ADDR
// end ;
80134: LD_VAR 0 2
80138: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80139: LD_INT 0
80141: PPUSH
80142: PPUSH
// if not mc_bases then
80143: LD_EXP 58
80147: NOT
80148: IFFALSE 80152
// exit ;
80150: GO 80217
// if mc_bases [ base ] then
80152: LD_EXP 58
80156: PUSH
80157: LD_VAR 0 1
80161: ARRAY
80162: IFFALSE 80217
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80164: LD_ADDR_VAR 0 3
80168: PUSH
80169: LD_EXP 58
80173: PUSH
80174: LD_VAR 0 1
80178: ARRAY
80179: PPUSH
80180: LD_INT 30
80182: PUSH
80183: LD_VAR 0 2
80187: PUSH
80188: EMPTY
80189: LIST
80190: LIST
80191: PPUSH
80192: CALL_OW 72
80196: ST_TO_ADDR
// if result then
80197: LD_VAR 0 3
80201: IFFALSE 80217
// result := result [ 1 ] ;
80203: LD_ADDR_VAR 0 3
80207: PUSH
80208: LD_VAR 0 3
80212: PUSH
80213: LD_INT 1
80215: ARRAY
80216: ST_TO_ADDR
// end ; end ;
80217: LD_VAR 0 3
80221: RET
// export function MC_SetTame ( base , area ) ; begin
80222: LD_INT 0
80224: PPUSH
// if not mc_bases or not base then
80225: LD_EXP 58
80229: NOT
80230: PUSH
80231: LD_VAR 0 1
80235: NOT
80236: OR
80237: IFFALSE 80241
// exit ;
80239: GO 80266
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80241: LD_ADDR_EXP 86
80245: PUSH
80246: LD_EXP 86
80250: PPUSH
80251: LD_VAR 0 1
80255: PPUSH
80256: LD_VAR 0 2
80260: PPUSH
80261: CALL_OW 1
80265: ST_TO_ADDR
// end ;
80266: LD_VAR 0 3
80270: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80271: LD_INT 0
80273: PPUSH
80274: PPUSH
// if not mc_bases or not base then
80275: LD_EXP 58
80279: NOT
80280: PUSH
80281: LD_VAR 0 1
80285: NOT
80286: OR
80287: IFFALSE 80291
// exit ;
80289: GO 80393
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80291: LD_ADDR_VAR 0 4
80295: PUSH
80296: LD_EXP 58
80300: PUSH
80301: LD_VAR 0 1
80305: ARRAY
80306: PPUSH
80307: LD_INT 30
80309: PUSH
80310: LD_VAR 0 2
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PPUSH
80319: CALL_OW 72
80323: ST_TO_ADDR
// if not tmp then
80324: LD_VAR 0 4
80328: NOT
80329: IFFALSE 80333
// exit ;
80331: GO 80393
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80333: LD_ADDR_EXP 90
80337: PUSH
80338: LD_EXP 90
80342: PPUSH
80343: LD_VAR 0 1
80347: PPUSH
80348: LD_EXP 90
80352: PUSH
80353: LD_VAR 0 1
80357: ARRAY
80358: PPUSH
80359: LD_EXP 90
80363: PUSH
80364: LD_VAR 0 1
80368: ARRAY
80369: PUSH
80370: LD_INT 1
80372: PLUS
80373: PPUSH
80374: LD_VAR 0 4
80378: PUSH
80379: LD_INT 1
80381: ARRAY
80382: PPUSH
80383: CALL_OW 2
80387: PPUSH
80388: CALL_OW 1
80392: ST_TO_ADDR
// end ;
80393: LD_VAR 0 3
80397: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80398: LD_INT 0
80400: PPUSH
80401: PPUSH
// if not mc_bases or not base or not kinds then
80402: LD_EXP 58
80406: NOT
80407: PUSH
80408: LD_VAR 0 1
80412: NOT
80413: OR
80414: PUSH
80415: LD_VAR 0 2
80419: NOT
80420: OR
80421: IFFALSE 80425
// exit ;
80423: GO 80486
// for i in kinds do
80425: LD_ADDR_VAR 0 4
80429: PUSH
80430: LD_VAR 0 2
80434: PUSH
80435: FOR_IN
80436: IFFALSE 80484
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
80438: LD_ADDR_EXP 92
80442: PUSH
80443: LD_EXP 92
80447: PPUSH
80448: LD_VAR 0 1
80452: PUSH
80453: LD_EXP 92
80457: PUSH
80458: LD_VAR 0 1
80462: ARRAY
80463: PUSH
80464: LD_INT 1
80466: PLUS
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PPUSH
80472: LD_VAR 0 4
80476: PPUSH
80477: CALL 20672 0 3
80481: ST_TO_ADDR
80482: GO 80435
80484: POP
80485: POP
// end ;
80486: LD_VAR 0 3
80490: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
80491: LD_INT 0
80493: PPUSH
// if not mc_bases or not base or not areas then
80494: LD_EXP 58
80498: NOT
80499: PUSH
80500: LD_VAR 0 1
80504: NOT
80505: OR
80506: PUSH
80507: LD_VAR 0 2
80511: NOT
80512: OR
80513: IFFALSE 80517
// exit ;
80515: GO 80542
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
80517: LD_ADDR_EXP 76
80521: PUSH
80522: LD_EXP 76
80526: PPUSH
80527: LD_VAR 0 1
80531: PPUSH
80532: LD_VAR 0 2
80536: PPUSH
80537: CALL_OW 1
80541: ST_TO_ADDR
// end ;
80542: LD_VAR 0 3
80546: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
80547: LD_INT 0
80549: PPUSH
// if not mc_bases or not base or not teleports_exit then
80550: LD_EXP 58
80554: NOT
80555: PUSH
80556: LD_VAR 0 1
80560: NOT
80561: OR
80562: PUSH
80563: LD_VAR 0 2
80567: NOT
80568: OR
80569: IFFALSE 80573
// exit ;
80571: GO 80598
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
80573: LD_ADDR_EXP 93
80577: PUSH
80578: LD_EXP 93
80582: PPUSH
80583: LD_VAR 0 1
80587: PPUSH
80588: LD_VAR 0 2
80592: PPUSH
80593: CALL_OW 1
80597: ST_TO_ADDR
// end ;
80598: LD_VAR 0 3
80602: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
80603: LD_INT 0
80605: PPUSH
80606: PPUSH
80607: PPUSH
// if not mc_bases or not base or not ext_list then
80608: LD_EXP 58
80612: NOT
80613: PUSH
80614: LD_VAR 0 1
80618: NOT
80619: OR
80620: PUSH
80621: LD_VAR 0 5
80625: NOT
80626: OR
80627: IFFALSE 80631
// exit ;
80629: GO 80804
// tmp := GetFacExtXYD ( x , y , d ) ;
80631: LD_ADDR_VAR 0 8
80635: PUSH
80636: LD_VAR 0 2
80640: PPUSH
80641: LD_VAR 0 3
80645: PPUSH
80646: LD_VAR 0 4
80650: PPUSH
80651: CALL 54026 0 3
80655: ST_TO_ADDR
// if not tmp then
80656: LD_VAR 0 8
80660: NOT
80661: IFFALSE 80665
// exit ;
80663: GO 80804
// for i in tmp do
80665: LD_ADDR_VAR 0 7
80669: PUSH
80670: LD_VAR 0 8
80674: PUSH
80675: FOR_IN
80676: IFFALSE 80802
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
80678: LD_ADDR_EXP 63
80682: PUSH
80683: LD_EXP 63
80687: PPUSH
80688: LD_VAR 0 1
80692: PPUSH
80693: LD_EXP 63
80697: PUSH
80698: LD_VAR 0 1
80702: ARRAY
80703: PPUSH
80704: LD_EXP 63
80708: PUSH
80709: LD_VAR 0 1
80713: ARRAY
80714: PUSH
80715: LD_INT 1
80717: PLUS
80718: PPUSH
80719: LD_VAR 0 5
80723: PUSH
80724: LD_INT 1
80726: ARRAY
80727: PUSH
80728: LD_VAR 0 7
80732: PUSH
80733: LD_INT 1
80735: ARRAY
80736: PUSH
80737: LD_VAR 0 7
80741: PUSH
80742: LD_INT 2
80744: ARRAY
80745: PUSH
80746: LD_VAR 0 7
80750: PUSH
80751: LD_INT 3
80753: ARRAY
80754: PUSH
80755: EMPTY
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: PPUSH
80761: CALL_OW 2
80765: PPUSH
80766: CALL_OW 1
80770: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
80771: LD_ADDR_VAR 0 5
80775: PUSH
80776: LD_VAR 0 5
80780: PPUSH
80781: LD_INT 1
80783: PPUSH
80784: CALL_OW 3
80788: ST_TO_ADDR
// if not ext_list then
80789: LD_VAR 0 5
80793: NOT
80794: IFFALSE 80800
// exit ;
80796: POP
80797: POP
80798: GO 80804
// end ;
80800: GO 80675
80802: POP
80803: POP
// end ;
80804: LD_VAR 0 6
80808: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
80809: LD_INT 0
80811: PPUSH
// if not mc_bases or not base or not weapon_list then
80812: LD_EXP 58
80816: NOT
80817: PUSH
80818: LD_VAR 0 1
80822: NOT
80823: OR
80824: PUSH
80825: LD_VAR 0 2
80829: NOT
80830: OR
80831: IFFALSE 80835
// exit ;
80833: GO 80860
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
80835: LD_ADDR_EXP 97
80839: PUSH
80840: LD_EXP 97
80844: PPUSH
80845: LD_VAR 0 1
80849: PPUSH
80850: LD_VAR 0 2
80854: PPUSH
80855: CALL_OW 1
80859: ST_TO_ADDR
// end ;
80860: LD_VAR 0 3
80864: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
80865: LD_INT 0
80867: PPUSH
// if not mc_bases or not base or not tech_list then
80868: LD_EXP 58
80872: NOT
80873: PUSH
80874: LD_VAR 0 1
80878: NOT
80879: OR
80880: PUSH
80881: LD_VAR 0 2
80885: NOT
80886: OR
80887: IFFALSE 80891
// exit ;
80889: GO 80916
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
80891: LD_ADDR_EXP 85
80895: PUSH
80896: LD_EXP 85
80900: PPUSH
80901: LD_VAR 0 1
80905: PPUSH
80906: LD_VAR 0 2
80910: PPUSH
80911: CALL_OW 1
80915: ST_TO_ADDR
// end ;
80916: LD_VAR 0 3
80920: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
80921: LD_INT 0
80923: PPUSH
// if not mc_bases or not parking_area or not base then
80924: LD_EXP 58
80928: NOT
80929: PUSH
80930: LD_VAR 0 2
80934: NOT
80935: OR
80936: PUSH
80937: LD_VAR 0 1
80941: NOT
80942: OR
80943: IFFALSE 80947
// exit ;
80945: GO 80972
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
80947: LD_ADDR_EXP 82
80951: PUSH
80952: LD_EXP 82
80956: PPUSH
80957: LD_VAR 0 1
80961: PPUSH
80962: LD_VAR 0 2
80966: PPUSH
80967: CALL_OW 1
80971: ST_TO_ADDR
// end ;
80972: LD_VAR 0 3
80976: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
80977: LD_INT 0
80979: PPUSH
// if not mc_bases or not base or not scan_area then
80980: LD_EXP 58
80984: NOT
80985: PUSH
80986: LD_VAR 0 1
80990: NOT
80991: OR
80992: PUSH
80993: LD_VAR 0 2
80997: NOT
80998: OR
80999: IFFALSE 81003
// exit ;
81001: GO 81028
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81003: LD_ADDR_EXP 83
81007: PUSH
81008: LD_EXP 83
81012: PPUSH
81013: LD_VAR 0 1
81017: PPUSH
81018: LD_VAR 0 2
81022: PPUSH
81023: CALL_OW 1
81027: ST_TO_ADDR
// end ;
81028: LD_VAR 0 3
81032: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81033: LD_INT 0
81035: PPUSH
81036: PPUSH
// if not mc_bases or not base then
81037: LD_EXP 58
81041: NOT
81042: PUSH
81043: LD_VAR 0 1
81047: NOT
81048: OR
81049: IFFALSE 81053
// exit ;
81051: GO 81117
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81053: LD_ADDR_VAR 0 3
81057: PUSH
81058: LD_INT 1
81060: PUSH
81061: LD_INT 2
81063: PUSH
81064: LD_INT 3
81066: PUSH
81067: LD_INT 4
81069: PUSH
81070: LD_INT 11
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: LIST
81077: LIST
81078: LIST
81079: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81080: LD_ADDR_EXP 85
81084: PUSH
81085: LD_EXP 85
81089: PPUSH
81090: LD_VAR 0 1
81094: PPUSH
81095: LD_EXP 85
81099: PUSH
81100: LD_VAR 0 1
81104: ARRAY
81105: PUSH
81106: LD_VAR 0 3
81110: DIFF
81111: PPUSH
81112: CALL_OW 1
81116: ST_TO_ADDR
// end ;
81117: LD_VAR 0 2
81121: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81122: LD_INT 0
81124: PPUSH
// result := mc_vehicles [ base ] ;
81125: LD_ADDR_VAR 0 3
81129: PUSH
81130: LD_EXP 77
81134: PUSH
81135: LD_VAR 0 1
81139: ARRAY
81140: ST_TO_ADDR
// if onlyCombat then
81141: LD_VAR 0 2
81145: IFFALSE 81310
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81147: LD_ADDR_VAR 0 3
81151: PUSH
81152: LD_VAR 0 3
81156: PUSH
81157: LD_VAR 0 3
81161: PPUSH
81162: LD_INT 2
81164: PUSH
81165: LD_INT 34
81167: PUSH
81168: LD_INT 12
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: LD_INT 34
81177: PUSH
81178: LD_INT 51
81180: PUSH
81181: EMPTY
81182: LIST
81183: LIST
81184: PUSH
81185: LD_INT 34
81187: PUSH
81188: LD_EXP 102
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 34
81199: PUSH
81200: LD_INT 32
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 34
81209: PUSH
81210: LD_INT 13
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 34
81219: PUSH
81220: LD_INT 52
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 34
81229: PUSH
81230: LD_INT 14
81232: PUSH
81233: EMPTY
81234: LIST
81235: LIST
81236: PUSH
81237: LD_INT 34
81239: PUSH
81240: LD_INT 53
81242: PUSH
81243: EMPTY
81244: LIST
81245: LIST
81246: PUSH
81247: LD_INT 34
81249: PUSH
81250: LD_EXP 101
81254: PUSH
81255: EMPTY
81256: LIST
81257: LIST
81258: PUSH
81259: LD_INT 34
81261: PUSH
81262: LD_INT 31
81264: PUSH
81265: EMPTY
81266: LIST
81267: LIST
81268: PUSH
81269: LD_INT 34
81271: PUSH
81272: LD_INT 48
81274: PUSH
81275: EMPTY
81276: LIST
81277: LIST
81278: PUSH
81279: LD_INT 34
81281: PUSH
81282: LD_INT 8
81284: PUSH
81285: EMPTY
81286: LIST
81287: LIST
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: LIST
81293: LIST
81294: LIST
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: LIST
81302: LIST
81303: PPUSH
81304: CALL_OW 72
81308: DIFF
81309: ST_TO_ADDR
// end ; end_of_file
81310: LD_VAR 0 3
81314: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81315: LD_INT 0
81317: PPUSH
81318: PPUSH
81319: PPUSH
// if not mc_bases or not skirmish then
81320: LD_EXP 58
81324: NOT
81325: PUSH
81326: LD_EXP 56
81330: NOT
81331: OR
81332: IFFALSE 81336
// exit ;
81334: GO 81501
// for i = 1 to mc_bases do
81336: LD_ADDR_VAR 0 4
81340: PUSH
81341: DOUBLE
81342: LD_INT 1
81344: DEC
81345: ST_TO_ADDR
81346: LD_EXP 58
81350: PUSH
81351: FOR_TO
81352: IFFALSE 81499
// begin if sci in mc_bases [ i ] then
81354: LD_VAR 0 2
81358: PUSH
81359: LD_EXP 58
81363: PUSH
81364: LD_VAR 0 4
81368: ARRAY
81369: IN
81370: IFFALSE 81497
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81372: LD_ADDR_EXP 87
81376: PUSH
81377: LD_EXP 87
81381: PPUSH
81382: LD_VAR 0 4
81386: PUSH
81387: LD_EXP 87
81391: PUSH
81392: LD_VAR 0 4
81396: ARRAY
81397: PUSH
81398: LD_INT 1
81400: PLUS
81401: PUSH
81402: EMPTY
81403: LIST
81404: LIST
81405: PPUSH
81406: LD_VAR 0 1
81410: PPUSH
81411: CALL 20672 0 3
81415: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
81416: LD_ADDR_VAR 0 5
81420: PUSH
81421: LD_EXP 58
81425: PUSH
81426: LD_VAR 0 4
81430: ARRAY
81431: PPUSH
81432: LD_INT 2
81434: PUSH
81435: LD_INT 30
81437: PUSH
81438: LD_INT 0
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PUSH
81445: LD_INT 30
81447: PUSH
81448: LD_INT 1
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: EMPTY
81456: LIST
81457: LIST
81458: LIST
81459: PPUSH
81460: CALL_OW 72
81464: PPUSH
81465: LD_VAR 0 1
81469: PPUSH
81470: CALL_OW 74
81474: ST_TO_ADDR
// if tmp then
81475: LD_VAR 0 5
81479: IFFALSE 81495
// ComStandNearbyBuilding ( ape , tmp ) ;
81481: LD_VAR 0 1
81485: PPUSH
81486: LD_VAR 0 5
81490: PPUSH
81491: CALL 15349 0 2
// break ;
81495: GO 81499
// end ; end ;
81497: GO 81351
81499: POP
81500: POP
// end ;
81501: LD_VAR 0 3
81505: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
81506: LD_INT 0
81508: PPUSH
81509: PPUSH
81510: PPUSH
// if not mc_bases or not skirmish then
81511: LD_EXP 58
81515: NOT
81516: PUSH
81517: LD_EXP 56
81521: NOT
81522: OR
81523: IFFALSE 81527
// exit ;
81525: GO 81616
// for i = 1 to mc_bases do
81527: LD_ADDR_VAR 0 4
81531: PUSH
81532: DOUBLE
81533: LD_INT 1
81535: DEC
81536: ST_TO_ADDR
81537: LD_EXP 58
81541: PUSH
81542: FOR_TO
81543: IFFALSE 81614
// begin if building in mc_busy_turret_list [ i ] then
81545: LD_VAR 0 1
81549: PUSH
81550: LD_EXP 68
81554: PUSH
81555: LD_VAR 0 4
81559: ARRAY
81560: IN
81561: IFFALSE 81612
// begin tmp := mc_busy_turret_list [ i ] diff building ;
81563: LD_ADDR_VAR 0 5
81567: PUSH
81568: LD_EXP 68
81572: PUSH
81573: LD_VAR 0 4
81577: ARRAY
81578: PUSH
81579: LD_VAR 0 1
81583: DIFF
81584: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
81585: LD_ADDR_EXP 68
81589: PUSH
81590: LD_EXP 68
81594: PPUSH
81595: LD_VAR 0 4
81599: PPUSH
81600: LD_VAR 0 5
81604: PPUSH
81605: CALL_OW 1
81609: ST_TO_ADDR
// break ;
81610: GO 81614
// end ; end ;
81612: GO 81542
81614: POP
81615: POP
// end ;
81616: LD_VAR 0 3
81620: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
81621: LD_INT 0
81623: PPUSH
81624: PPUSH
81625: PPUSH
// if not mc_bases or not skirmish then
81626: LD_EXP 58
81630: NOT
81631: PUSH
81632: LD_EXP 56
81636: NOT
81637: OR
81638: IFFALSE 81642
// exit ;
81640: GO 81841
// for i = 1 to mc_bases do
81642: LD_ADDR_VAR 0 5
81646: PUSH
81647: DOUBLE
81648: LD_INT 1
81650: DEC
81651: ST_TO_ADDR
81652: LD_EXP 58
81656: PUSH
81657: FOR_TO
81658: IFFALSE 81839
// if building in mc_bases [ i ] then
81660: LD_VAR 0 1
81664: PUSH
81665: LD_EXP 58
81669: PUSH
81670: LD_VAR 0 5
81674: ARRAY
81675: IN
81676: IFFALSE 81837
// begin tmp := mc_bases [ i ] diff building ;
81678: LD_ADDR_VAR 0 6
81682: PUSH
81683: LD_EXP 58
81687: PUSH
81688: LD_VAR 0 5
81692: ARRAY
81693: PUSH
81694: LD_VAR 0 1
81698: DIFF
81699: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
81700: LD_ADDR_EXP 58
81704: PUSH
81705: LD_EXP 58
81709: PPUSH
81710: LD_VAR 0 5
81714: PPUSH
81715: LD_VAR 0 6
81719: PPUSH
81720: CALL_OW 1
81724: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
81725: LD_VAR 0 1
81729: PUSH
81730: LD_EXP 66
81734: PUSH
81735: LD_VAR 0 5
81739: ARRAY
81740: IN
81741: IFFALSE 81780
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
81743: LD_ADDR_EXP 66
81747: PUSH
81748: LD_EXP 66
81752: PPUSH
81753: LD_VAR 0 5
81757: PPUSH
81758: LD_EXP 66
81762: PUSH
81763: LD_VAR 0 5
81767: ARRAY
81768: PUSH
81769: LD_VAR 0 1
81773: DIFF
81774: PPUSH
81775: CALL_OW 1
81779: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
81780: LD_VAR 0 1
81784: PUSH
81785: LD_EXP 67
81789: PUSH
81790: LD_VAR 0 5
81794: ARRAY
81795: IN
81796: IFFALSE 81835
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
81798: LD_ADDR_EXP 67
81802: PUSH
81803: LD_EXP 67
81807: PPUSH
81808: LD_VAR 0 5
81812: PPUSH
81813: LD_EXP 67
81817: PUSH
81818: LD_VAR 0 5
81822: ARRAY
81823: PUSH
81824: LD_VAR 0 1
81828: DIFF
81829: PPUSH
81830: CALL_OW 1
81834: ST_TO_ADDR
// break ;
81835: GO 81839
// end ;
81837: GO 81657
81839: POP
81840: POP
// end ;
81841: LD_VAR 0 4
81845: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
81846: LD_INT 0
81848: PPUSH
81849: PPUSH
81850: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
81851: LD_EXP 58
81855: NOT
81856: PUSH
81857: LD_EXP 56
81861: NOT
81862: OR
81863: PUSH
81864: LD_VAR 0 3
81868: PUSH
81869: LD_EXP 84
81873: IN
81874: NOT
81875: OR
81876: IFFALSE 81880
// exit ;
81878: GO 82003
// for i = 1 to mc_vehicles do
81880: LD_ADDR_VAR 0 6
81884: PUSH
81885: DOUBLE
81886: LD_INT 1
81888: DEC
81889: ST_TO_ADDR
81890: LD_EXP 77
81894: PUSH
81895: FOR_TO
81896: IFFALSE 82001
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
81898: LD_VAR 0 2
81902: PUSH
81903: LD_EXP 77
81907: PUSH
81908: LD_VAR 0 6
81912: ARRAY
81913: IN
81914: PUSH
81915: LD_VAR 0 1
81919: PUSH
81920: LD_EXP 77
81924: PUSH
81925: LD_VAR 0 6
81929: ARRAY
81930: IN
81931: OR
81932: IFFALSE 81999
// begin tmp := mc_vehicles [ i ] diff old ;
81934: LD_ADDR_VAR 0 7
81938: PUSH
81939: LD_EXP 77
81943: PUSH
81944: LD_VAR 0 6
81948: ARRAY
81949: PUSH
81950: LD_VAR 0 2
81954: DIFF
81955: ST_TO_ADDR
// tmp := tmp diff new ;
81956: LD_ADDR_VAR 0 7
81960: PUSH
81961: LD_VAR 0 7
81965: PUSH
81966: LD_VAR 0 1
81970: DIFF
81971: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
81972: LD_ADDR_EXP 77
81976: PUSH
81977: LD_EXP 77
81981: PPUSH
81982: LD_VAR 0 6
81986: PPUSH
81987: LD_VAR 0 7
81991: PPUSH
81992: CALL_OW 1
81996: ST_TO_ADDR
// break ;
81997: GO 82001
// end ;
81999: GO 81895
82001: POP
82002: POP
// end ;
82003: LD_VAR 0 5
82007: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82008: LD_INT 0
82010: PPUSH
82011: PPUSH
82012: PPUSH
82013: PPUSH
// if not mc_bases or not skirmish then
82014: LD_EXP 58
82018: NOT
82019: PUSH
82020: LD_EXP 56
82024: NOT
82025: OR
82026: IFFALSE 82030
// exit ;
82028: GO 82413
// side := GetSide ( vehicle ) ;
82030: LD_ADDR_VAR 0 5
82034: PUSH
82035: LD_VAR 0 1
82039: PPUSH
82040: CALL_OW 255
82044: ST_TO_ADDR
// for i = 1 to mc_bases do
82045: LD_ADDR_VAR 0 4
82049: PUSH
82050: DOUBLE
82051: LD_INT 1
82053: DEC
82054: ST_TO_ADDR
82055: LD_EXP 58
82059: PUSH
82060: FOR_TO
82061: IFFALSE 82411
// begin if factory in mc_bases [ i ] then
82063: LD_VAR 0 2
82067: PUSH
82068: LD_EXP 58
82072: PUSH
82073: LD_VAR 0 4
82077: ARRAY
82078: IN
82079: IFFALSE 82409
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82081: LD_EXP 80
82085: PUSH
82086: LD_VAR 0 4
82090: ARRAY
82091: PUSH
82092: LD_EXP 69
82096: PUSH
82097: LD_VAR 0 4
82101: ARRAY
82102: LESS
82103: PUSH
82104: LD_VAR 0 1
82108: PPUSH
82109: CALL_OW 264
82113: PUSH
82114: LD_INT 31
82116: PUSH
82117: LD_INT 32
82119: PUSH
82120: LD_INT 51
82122: PUSH
82123: LD_EXP 102
82127: PUSH
82128: LD_INT 12
82130: PUSH
82131: LD_INT 30
82133: PUSH
82134: LD_EXP 101
82138: PUSH
82139: LD_INT 11
82141: PUSH
82142: LD_INT 53
82144: PUSH
82145: LD_INT 14
82147: PUSH
82148: LD_EXP 105
82152: PUSH
82153: LD_INT 29
82155: PUSH
82156: LD_EXP 103
82160: PUSH
82161: LD_INT 13
82163: PUSH
82164: LD_INT 52
82166: PUSH
82167: LD_INT 48
82169: PUSH
82170: LD_INT 8
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: LIST
82177: LIST
82178: LIST
82179: LIST
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: IN
82192: NOT
82193: AND
82194: IFFALSE 82235
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] ^ vehicle ) else
82196: LD_ADDR_EXP 80
82200: PUSH
82201: LD_EXP 80
82205: PPUSH
82206: LD_VAR 0 4
82210: PPUSH
82211: LD_EXP 80
82215: PUSH
82216: LD_VAR 0 4
82220: ARRAY
82221: PUSH
82222: LD_VAR 0 1
82226: ADD
82227: PPUSH
82228: CALL_OW 1
82232: ST_TO_ADDR
82233: GO 82279
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82235: LD_ADDR_EXP 77
82239: PUSH
82240: LD_EXP 77
82244: PPUSH
82245: LD_VAR 0 4
82249: PUSH
82250: LD_EXP 77
82254: PUSH
82255: LD_VAR 0 4
82259: ARRAY
82260: PUSH
82261: LD_INT 1
82263: PLUS
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PPUSH
82269: LD_VAR 0 1
82273: PPUSH
82274: CALL 20672 0 3
82278: ST_TO_ADDR
// if not mc_scan [ i ] then
82279: LD_EXP 81
82283: PUSH
82284: LD_VAR 0 4
82288: ARRAY
82289: NOT
82290: IFFALSE 82409
// begin if GetControl ( vehicle ) = control_remote then
82292: LD_VAR 0 1
82296: PPUSH
82297: CALL_OW 263
82301: PUSH
82302: LD_INT 2
82304: EQUAL
82305: IFFALSE 82325
// repeat wait ( 0 0$1 ) ;
82307: LD_INT 35
82309: PPUSH
82310: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82314: LD_VAR 0 1
82318: PPUSH
82319: CALL_OW 312
82323: IFFALSE 82307
// ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82325: LD_VAR 0 1
82329: PPUSH
82330: LD_EXP 82
82334: PUSH
82335: LD_VAR 0 4
82339: ARRAY
82340: PPUSH
82341: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82345: LD_VAR 0 1
82349: PPUSH
82350: CALL_OW 263
82354: PUSH
82355: LD_INT 1
82357: NONEQUAL
82358: IFFALSE 82362
// break ;
82360: GO 82411
// repeat wait ( 0 0$1 ) ;
82362: LD_INT 35
82364: PPUSH
82365: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82369: LD_VAR 0 1
82373: PPUSH
82374: LD_EXP 82
82378: PUSH
82379: LD_VAR 0 4
82383: ARRAY
82384: PPUSH
82385: CALL_OW 308
82389: IFFALSE 82362
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
82391: LD_VAR 0 1
82395: PPUSH
82396: CALL_OW 311
82400: PPUSH
82401: CALL_OW 121
// exit ;
82405: POP
82406: POP
82407: GO 82413
// end ; end ; end ;
82409: GO 82060
82411: POP
82412: POP
// end ;
82413: LD_VAR 0 3
82417: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
82418: LD_INT 0
82420: PPUSH
82421: PPUSH
82422: PPUSH
82423: PPUSH
// if not mc_bases or not skirmish then
82424: LD_EXP 58
82428: NOT
82429: PUSH
82430: LD_EXP 56
82434: NOT
82435: OR
82436: IFFALSE 82440
// exit ;
82438: GO 82793
// repeat wait ( 0 0$1 ) ;
82440: LD_INT 35
82442: PPUSH
82443: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
82447: LD_VAR 0 2
82451: PPUSH
82452: LD_VAR 0 3
82456: PPUSH
82457: CALL_OW 284
82461: IFFALSE 82440
// if GetResourceTypeXY ( x , y ) = mat_artefact then
82463: LD_VAR 0 2
82467: PPUSH
82468: LD_VAR 0 3
82472: PPUSH
82473: CALL_OW 283
82477: PUSH
82478: LD_INT 4
82480: EQUAL
82481: IFFALSE 82485
// exit ;
82483: GO 82793
// for i = 1 to mc_bases do
82485: LD_ADDR_VAR 0 7
82489: PUSH
82490: DOUBLE
82491: LD_INT 1
82493: DEC
82494: ST_TO_ADDR
82495: LD_EXP 58
82499: PUSH
82500: FOR_TO
82501: IFFALSE 82791
// begin if mc_crates_area [ i ] then
82503: LD_EXP 76
82507: PUSH
82508: LD_VAR 0 7
82512: ARRAY
82513: IFFALSE 82624
// for j in mc_crates_area [ i ] do
82515: LD_ADDR_VAR 0 8
82519: PUSH
82520: LD_EXP 76
82524: PUSH
82525: LD_VAR 0 7
82529: ARRAY
82530: PUSH
82531: FOR_IN
82532: IFFALSE 82622
// if InArea ( x , y , j ) then
82534: LD_VAR 0 2
82538: PPUSH
82539: LD_VAR 0 3
82543: PPUSH
82544: LD_VAR 0 8
82548: PPUSH
82549: CALL_OW 309
82553: IFFALSE 82620
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82555: LD_ADDR_EXP 74
82559: PUSH
82560: LD_EXP 74
82564: PPUSH
82565: LD_VAR 0 7
82569: PUSH
82570: LD_EXP 74
82574: PUSH
82575: LD_VAR 0 7
82579: ARRAY
82580: PUSH
82581: LD_INT 1
82583: PLUS
82584: PUSH
82585: EMPTY
82586: LIST
82587: LIST
82588: PPUSH
82589: LD_VAR 0 4
82593: PUSH
82594: LD_VAR 0 2
82598: PUSH
82599: LD_VAR 0 3
82603: PUSH
82604: EMPTY
82605: LIST
82606: LIST
82607: LIST
82608: PPUSH
82609: CALL 20672 0 3
82613: ST_TO_ADDR
// exit ;
82614: POP
82615: POP
82616: POP
82617: POP
82618: GO 82793
// end ;
82620: GO 82531
82622: POP
82623: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
82624: LD_ADDR_VAR 0 9
82628: PUSH
82629: LD_EXP 58
82633: PUSH
82634: LD_VAR 0 7
82638: ARRAY
82639: PPUSH
82640: LD_INT 2
82642: PUSH
82643: LD_INT 30
82645: PUSH
82646: LD_INT 0
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: PUSH
82653: LD_INT 30
82655: PUSH
82656: LD_INT 1
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: EMPTY
82664: LIST
82665: LIST
82666: LIST
82667: PPUSH
82668: CALL_OW 72
82672: ST_TO_ADDR
// if not depot then
82673: LD_VAR 0 9
82677: NOT
82678: IFFALSE 82682
// continue ;
82680: GO 82500
// for j in depot do
82682: LD_ADDR_VAR 0 8
82686: PUSH
82687: LD_VAR 0 9
82691: PUSH
82692: FOR_IN
82693: IFFALSE 82787
// if GetDistUnitXY ( j , x , y ) < 30 then
82695: LD_VAR 0 8
82699: PPUSH
82700: LD_VAR 0 2
82704: PPUSH
82705: LD_VAR 0 3
82709: PPUSH
82710: CALL_OW 297
82714: PUSH
82715: LD_INT 30
82717: LESS
82718: IFFALSE 82785
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
82720: LD_ADDR_EXP 74
82724: PUSH
82725: LD_EXP 74
82729: PPUSH
82730: LD_VAR 0 7
82734: PUSH
82735: LD_EXP 74
82739: PUSH
82740: LD_VAR 0 7
82744: ARRAY
82745: PUSH
82746: LD_INT 1
82748: PLUS
82749: PUSH
82750: EMPTY
82751: LIST
82752: LIST
82753: PPUSH
82754: LD_VAR 0 4
82758: PUSH
82759: LD_VAR 0 2
82763: PUSH
82764: LD_VAR 0 3
82768: PUSH
82769: EMPTY
82770: LIST
82771: LIST
82772: LIST
82773: PPUSH
82774: CALL 20672 0 3
82778: ST_TO_ADDR
// exit ;
82779: POP
82780: POP
82781: POP
82782: POP
82783: GO 82793
// end ;
82785: GO 82692
82787: POP
82788: POP
// end ;
82789: GO 82500
82791: POP
82792: POP
// end ;
82793: LD_VAR 0 6
82797: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
82798: LD_INT 0
82800: PPUSH
82801: PPUSH
82802: PPUSH
82803: PPUSH
// if not mc_bases or not skirmish then
82804: LD_EXP 58
82808: NOT
82809: PUSH
82810: LD_EXP 56
82814: NOT
82815: OR
82816: IFFALSE 82820
// exit ;
82818: GO 83097
// side := GetSide ( lab ) ;
82820: LD_ADDR_VAR 0 4
82824: PUSH
82825: LD_VAR 0 2
82829: PPUSH
82830: CALL_OW 255
82834: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
82835: LD_VAR 0 4
82839: PUSH
82840: LD_EXP 84
82844: IN
82845: NOT
82846: PUSH
82847: LD_EXP 85
82851: NOT
82852: OR
82853: PUSH
82854: LD_EXP 58
82858: NOT
82859: OR
82860: IFFALSE 82864
// exit ;
82862: GO 83097
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
82864: LD_ADDR_EXP 85
82868: PUSH
82869: LD_EXP 85
82873: PPUSH
82874: LD_VAR 0 4
82878: PPUSH
82879: LD_EXP 85
82883: PUSH
82884: LD_VAR 0 4
82888: ARRAY
82889: PUSH
82890: LD_VAR 0 1
82894: DIFF
82895: PPUSH
82896: CALL_OW 1
82900: ST_TO_ADDR
// for i = 1 to mc_bases do
82901: LD_ADDR_VAR 0 5
82905: PUSH
82906: DOUBLE
82907: LD_INT 1
82909: DEC
82910: ST_TO_ADDR
82911: LD_EXP 58
82915: PUSH
82916: FOR_TO
82917: IFFALSE 83095
// begin if lab in mc_bases [ i ] then
82919: LD_VAR 0 2
82923: PUSH
82924: LD_EXP 58
82928: PUSH
82929: LD_VAR 0 5
82933: ARRAY
82934: IN
82935: IFFALSE 83093
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
82937: LD_VAR 0 1
82941: PUSH
82942: LD_INT 11
82944: PUSH
82945: LD_INT 4
82947: PUSH
82948: LD_INT 3
82950: PUSH
82951: LD_INT 2
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: LIST
82958: LIST
82959: IN
82960: PUSH
82961: LD_EXP 88
82965: PUSH
82966: LD_VAR 0 5
82970: ARRAY
82971: AND
82972: IFFALSE 83093
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
82974: LD_ADDR_VAR 0 6
82978: PUSH
82979: LD_EXP 88
82983: PUSH
82984: LD_VAR 0 5
82988: ARRAY
82989: PUSH
82990: LD_INT 1
82992: ARRAY
82993: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
82994: LD_ADDR_EXP 88
82998: PUSH
82999: LD_EXP 88
83003: PPUSH
83004: LD_VAR 0 5
83008: PPUSH
83009: EMPTY
83010: PPUSH
83011: CALL_OW 1
83015: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83016: LD_VAR 0 6
83020: PPUSH
83021: LD_INT 0
83023: PPUSH
83024: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83028: LD_VAR 0 6
83032: PPUSH
83033: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83037: LD_ADDR_EXP 87
83041: PUSH
83042: LD_EXP 87
83046: PPUSH
83047: LD_VAR 0 5
83051: PPUSH
83052: LD_EXP 87
83056: PUSH
83057: LD_VAR 0 5
83061: ARRAY
83062: PPUSH
83063: LD_INT 1
83065: PPUSH
83066: LD_VAR 0 6
83070: PPUSH
83071: CALL_OW 2
83075: PPUSH
83076: CALL_OW 1
83080: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83081: LD_VAR 0 5
83085: PPUSH
83086: LD_INT 112
83088: PPUSH
83089: CALL 60566 0 2
// end ; end ; end ;
83093: GO 82916
83095: POP
83096: POP
// end ;
83097: LD_VAR 0 3
83101: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83102: LD_INT 0
83104: PPUSH
83105: PPUSH
83106: PPUSH
83107: PPUSH
83108: PPUSH
83109: PPUSH
83110: PPUSH
83111: PPUSH
// if not mc_bases or not skirmish then
83112: LD_EXP 58
83116: NOT
83117: PUSH
83118: LD_EXP 56
83122: NOT
83123: OR
83124: IFFALSE 83128
// exit ;
83126: GO 84144
// for i = 1 to mc_bases do
83128: LD_ADDR_VAR 0 3
83132: PUSH
83133: DOUBLE
83134: LD_INT 1
83136: DEC
83137: ST_TO_ADDR
83138: LD_EXP 58
83142: PUSH
83143: FOR_TO
83144: IFFALSE 84142
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83146: LD_VAR 0 1
83150: PUSH
83151: LD_EXP 58
83155: PUSH
83156: LD_VAR 0 3
83160: ARRAY
83161: IN
83162: PUSH
83163: LD_VAR 0 1
83167: PUSH
83168: LD_EXP 65
83172: PUSH
83173: LD_VAR 0 3
83177: ARRAY
83178: IN
83179: OR
83180: PUSH
83181: LD_VAR 0 1
83185: PUSH
83186: LD_EXP 77
83190: PUSH
83191: LD_VAR 0 3
83195: ARRAY
83196: IN
83197: OR
83198: PUSH
83199: LD_VAR 0 1
83203: PUSH
83204: LD_EXP 87
83208: PUSH
83209: LD_VAR 0 3
83213: ARRAY
83214: IN
83215: OR
83216: PUSH
83217: LD_VAR 0 1
83221: PUSH
83222: LD_EXP 88
83226: PUSH
83227: LD_VAR 0 3
83231: ARRAY
83232: IN
83233: OR
83234: IFFALSE 84140
// begin if un in mc_ape [ i ] then
83236: LD_VAR 0 1
83240: PUSH
83241: LD_EXP 87
83245: PUSH
83246: LD_VAR 0 3
83250: ARRAY
83251: IN
83252: IFFALSE 83291
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83254: LD_ADDR_EXP 87
83258: PUSH
83259: LD_EXP 87
83263: PPUSH
83264: LD_VAR 0 3
83268: PPUSH
83269: LD_EXP 87
83273: PUSH
83274: LD_VAR 0 3
83278: ARRAY
83279: PUSH
83280: LD_VAR 0 1
83284: DIFF
83285: PPUSH
83286: CALL_OW 1
83290: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83291: LD_VAR 0 1
83295: PUSH
83296: LD_EXP 88
83300: PUSH
83301: LD_VAR 0 3
83305: ARRAY
83306: IN
83307: IFFALSE 83331
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83309: LD_ADDR_EXP 88
83313: PUSH
83314: LD_EXP 88
83318: PPUSH
83319: LD_VAR 0 3
83323: PPUSH
83324: EMPTY
83325: PPUSH
83326: CALL_OW 1
83330: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
83331: LD_VAR 0 1
83335: PPUSH
83336: CALL_OW 247
83340: PUSH
83341: LD_INT 2
83343: EQUAL
83344: PUSH
83345: LD_VAR 0 1
83349: PPUSH
83350: CALL_OW 110
83354: PUSH
83355: LD_INT 20
83357: EQUAL
83358: PUSH
83359: LD_VAR 0 1
83363: PUSH
83364: LD_EXP 80
83368: PUSH
83369: LD_VAR 0 3
83373: ARRAY
83374: IN
83375: OR
83376: AND
83377: IFFALSE 83480
// begin fac := MC_GetBuilding ( i , b_factory ) ;
83379: LD_ADDR_VAR 0 8
83383: PUSH
83384: LD_VAR 0 3
83388: PPUSH
83389: LD_INT 3
83391: PPUSH
83392: CALL 80139 0 2
83396: ST_TO_ADDR
// if fac then
83397: LD_VAR 0 8
83401: IFFALSE 83480
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
83403: LD_ADDR_VAR 0 9
83407: PUSH
83408: LD_VAR 0 8
83412: PPUSH
83413: LD_VAR 0 1
83417: PPUSH
83418: CALL_OW 265
83422: PPUSH
83423: LD_VAR 0 1
83427: PPUSH
83428: CALL_OW 262
83432: PPUSH
83433: LD_VAR 0 1
83437: PPUSH
83438: CALL_OW 263
83442: PPUSH
83443: LD_VAR 0 1
83447: PPUSH
83448: CALL_OW 264
83452: PPUSH
83453: CALL 18272 0 5
83457: ST_TO_ADDR
// if components then
83458: LD_VAR 0 9
83462: IFFALSE 83478
// MC_InsertProduceList ( i , components ) ;
83464: LD_VAR 0 3
83468: PPUSH
83469: LD_VAR 0 9
83473: PPUSH
83474: CALL 79767 0 2
// break ;
83478: GO 84142
// end ; end ; if GetType ( un ) = unit_building then
83480: LD_VAR 0 1
83484: PPUSH
83485: CALL_OW 247
83489: PUSH
83490: LD_INT 3
83492: EQUAL
83493: IFFALSE 83808
// begin btype := GetBType ( un ) ;
83495: LD_ADDR_VAR 0 5
83499: PUSH
83500: LD_VAR 0 1
83504: PPUSH
83505: CALL_OW 266
83509: ST_TO_ADDR
// if btype = b_warehouse then
83510: LD_VAR 0 5
83514: PUSH
83515: LD_INT 1
83517: EQUAL
83518: IFFALSE 83536
// begin btype := b_depot ;
83520: LD_ADDR_VAR 0 5
83524: PUSH
83525: LD_INT 0
83527: ST_TO_ADDR
// pos := 1 ;
83528: LD_ADDR_VAR 0 6
83532: PUSH
83533: LD_INT 1
83535: ST_TO_ADDR
// end ; if btype = b_factory then
83536: LD_VAR 0 5
83540: PUSH
83541: LD_INT 3
83543: EQUAL
83544: IFFALSE 83562
// begin btype := b_workshop ;
83546: LD_ADDR_VAR 0 5
83550: PUSH
83551: LD_INT 2
83553: ST_TO_ADDR
// pos := 1 ;
83554: LD_ADDR_VAR 0 6
83558: PUSH
83559: LD_INT 1
83561: ST_TO_ADDR
// end ; if btype = b_barracks then
83562: LD_VAR 0 5
83566: PUSH
83567: LD_INT 5
83569: EQUAL
83570: IFFALSE 83580
// btype := b_armoury ;
83572: LD_ADDR_VAR 0 5
83576: PUSH
83577: LD_INT 4
83579: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
83580: LD_VAR 0 5
83584: PUSH
83585: LD_INT 7
83587: PUSH
83588: LD_INT 8
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: IN
83595: IFFALSE 83605
// btype := b_lab ;
83597: LD_ADDR_VAR 0 5
83601: PUSH
83602: LD_INT 6
83604: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
83605: LD_ADDR_EXP 63
83609: PUSH
83610: LD_EXP 63
83614: PPUSH
83615: LD_VAR 0 3
83619: PUSH
83620: LD_EXP 63
83624: PUSH
83625: LD_VAR 0 3
83629: ARRAY
83630: PUSH
83631: LD_INT 1
83633: PLUS
83634: PUSH
83635: EMPTY
83636: LIST
83637: LIST
83638: PPUSH
83639: LD_VAR 0 5
83643: PUSH
83644: LD_VAR 0 1
83648: PPUSH
83649: CALL_OW 250
83653: PUSH
83654: LD_VAR 0 1
83658: PPUSH
83659: CALL_OW 251
83663: PUSH
83664: LD_VAR 0 1
83668: PPUSH
83669: CALL_OW 254
83673: PUSH
83674: EMPTY
83675: LIST
83676: LIST
83677: LIST
83678: LIST
83679: PPUSH
83680: CALL 20672 0 3
83684: ST_TO_ADDR
// if pos = 1 then
83685: LD_VAR 0 6
83689: PUSH
83690: LD_INT 1
83692: EQUAL
83693: IFFALSE 83808
// begin tmp := mc_build_list [ i ] ;
83695: LD_ADDR_VAR 0 7
83699: PUSH
83700: LD_EXP 63
83704: PUSH
83705: LD_VAR 0 3
83709: ARRAY
83710: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
83711: LD_VAR 0 7
83715: PPUSH
83716: LD_INT 2
83718: PUSH
83719: LD_INT 30
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 30
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: EMPTY
83740: LIST
83741: LIST
83742: LIST
83743: PPUSH
83744: CALL_OW 72
83748: IFFALSE 83758
// pos := 2 ;
83750: LD_ADDR_VAR 0 6
83754: PUSH
83755: LD_INT 2
83757: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
83758: LD_ADDR_VAR 0 7
83762: PUSH
83763: LD_VAR 0 7
83767: PPUSH
83768: LD_VAR 0 6
83772: PPUSH
83773: LD_VAR 0 7
83777: PPUSH
83778: CALL 20998 0 3
83782: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
83783: LD_ADDR_EXP 63
83787: PUSH
83788: LD_EXP 63
83792: PPUSH
83793: LD_VAR 0 3
83797: PPUSH
83798: LD_VAR 0 7
83802: PPUSH
83803: CALL_OW 1
83807: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
83808: LD_VAR 0 1
83812: PUSH
83813: LD_EXP 58
83817: PUSH
83818: LD_VAR 0 3
83822: ARRAY
83823: IN
83824: IFFALSE 83863
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
83826: LD_ADDR_EXP 58
83830: PUSH
83831: LD_EXP 58
83835: PPUSH
83836: LD_VAR 0 3
83840: PPUSH
83841: LD_EXP 58
83845: PUSH
83846: LD_VAR 0 3
83850: ARRAY
83851: PUSH
83852: LD_VAR 0 1
83856: DIFF
83857: PPUSH
83858: CALL_OW 1
83862: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
83863: LD_VAR 0 1
83867: PUSH
83868: LD_EXP 65
83872: PUSH
83873: LD_VAR 0 3
83877: ARRAY
83878: IN
83879: IFFALSE 83918
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
83881: LD_ADDR_EXP 65
83885: PUSH
83886: LD_EXP 65
83890: PPUSH
83891: LD_VAR 0 3
83895: PPUSH
83896: LD_EXP 65
83900: PUSH
83901: LD_VAR 0 3
83905: ARRAY
83906: PUSH
83907: LD_VAR 0 1
83911: DIFF
83912: PPUSH
83913: CALL_OW 1
83917: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
83918: LD_VAR 0 1
83922: PUSH
83923: LD_EXP 77
83927: PUSH
83928: LD_VAR 0 3
83932: ARRAY
83933: IN
83934: IFFALSE 83973
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
83936: LD_ADDR_EXP 77
83940: PUSH
83941: LD_EXP 77
83945: PPUSH
83946: LD_VAR 0 3
83950: PPUSH
83951: LD_EXP 77
83955: PUSH
83956: LD_VAR 0 3
83960: ARRAY
83961: PUSH
83962: LD_VAR 0 1
83966: DIFF
83967: PPUSH
83968: CALL_OW 1
83972: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
83973: LD_VAR 0 1
83977: PUSH
83978: LD_EXP 80
83982: PUSH
83983: LD_VAR 0 3
83987: ARRAY
83988: IN
83989: IFFALSE 84028
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
83991: LD_ADDR_EXP 80
83995: PUSH
83996: LD_EXP 80
84000: PPUSH
84001: LD_VAR 0 3
84005: PPUSH
84006: LD_EXP 80
84010: PUSH
84011: LD_VAR 0 3
84015: ARRAY
84016: PUSH
84017: LD_VAR 0 1
84021: DIFF
84022: PPUSH
84023: CALL_OW 1
84027: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84028: LD_VAR 0 1
84032: PUSH
84033: LD_EXP 67
84037: PUSH
84038: LD_VAR 0 3
84042: ARRAY
84043: IN
84044: IFFALSE 84083
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84046: LD_ADDR_EXP 67
84050: PUSH
84051: LD_EXP 67
84055: PPUSH
84056: LD_VAR 0 3
84060: PPUSH
84061: LD_EXP 67
84065: PUSH
84066: LD_VAR 0 3
84070: ARRAY
84071: PUSH
84072: LD_VAR 0 1
84076: DIFF
84077: PPUSH
84078: CALL_OW 1
84082: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84083: LD_VAR 0 1
84087: PUSH
84088: LD_EXP 66
84092: PUSH
84093: LD_VAR 0 3
84097: ARRAY
84098: IN
84099: IFFALSE 84138
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84101: LD_ADDR_EXP 66
84105: PUSH
84106: LD_EXP 66
84110: PPUSH
84111: LD_VAR 0 3
84115: PPUSH
84116: LD_EXP 66
84120: PUSH
84121: LD_VAR 0 3
84125: ARRAY
84126: PUSH
84127: LD_VAR 0 1
84131: DIFF
84132: PPUSH
84133: CALL_OW 1
84137: ST_TO_ADDR
// end ; break ;
84138: GO 84142
// end ;
84140: GO 83143
84142: POP
84143: POP
// end ;
84144: LD_VAR 0 2
84148: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
84149: LD_INT 0
84151: PPUSH
84152: PPUSH
84153: PPUSH
// if not mc_bases or not skirmish then
84154: LD_EXP 58
84158: NOT
84159: PUSH
84160: LD_EXP 56
84164: NOT
84165: OR
84166: IFFALSE 84170
// exit ;
84168: GO 84385
// for i = 1 to mc_bases do
84170: LD_ADDR_VAR 0 3
84174: PUSH
84175: DOUBLE
84176: LD_INT 1
84178: DEC
84179: ST_TO_ADDR
84180: LD_EXP 58
84184: PUSH
84185: FOR_TO
84186: IFFALSE 84383
// begin if building in mc_construct_list [ i ] then
84188: LD_VAR 0 1
84192: PUSH
84193: LD_EXP 65
84197: PUSH
84198: LD_VAR 0 3
84202: ARRAY
84203: IN
84204: IFFALSE 84381
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84206: LD_ADDR_EXP 65
84210: PUSH
84211: LD_EXP 65
84215: PPUSH
84216: LD_VAR 0 3
84220: PPUSH
84221: LD_EXP 65
84225: PUSH
84226: LD_VAR 0 3
84230: ARRAY
84231: PUSH
84232: LD_VAR 0 1
84236: DIFF
84237: PPUSH
84238: CALL_OW 1
84242: ST_TO_ADDR
// if building in mc_lab [ i ] then
84243: LD_VAR 0 1
84247: PUSH
84248: LD_EXP 91
84252: PUSH
84253: LD_VAR 0 3
84257: ARRAY
84258: IN
84259: IFFALSE 84314
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
84261: LD_ADDR_EXP 92
84265: PUSH
84266: LD_EXP 92
84270: PPUSH
84271: LD_VAR 0 3
84275: PPUSH
84276: LD_EXP 92
84280: PUSH
84281: LD_VAR 0 3
84285: ARRAY
84286: PPUSH
84287: LD_INT 1
84289: PPUSH
84290: LD_EXP 92
84294: PUSH
84295: LD_VAR 0 3
84299: ARRAY
84300: PPUSH
84301: LD_INT 0
84303: PPUSH
84304: CALL 20090 0 4
84308: PPUSH
84309: CALL_OW 1
84313: ST_TO_ADDR
// if not building in mc_bases [ i ] then
84314: LD_VAR 0 1
84318: PUSH
84319: LD_EXP 58
84323: PUSH
84324: LD_VAR 0 3
84328: ARRAY
84329: IN
84330: NOT
84331: IFFALSE 84377
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84333: LD_ADDR_EXP 58
84337: PUSH
84338: LD_EXP 58
84342: PPUSH
84343: LD_VAR 0 3
84347: PUSH
84348: LD_EXP 58
84352: PUSH
84353: LD_VAR 0 3
84357: ARRAY
84358: PUSH
84359: LD_INT 1
84361: PLUS
84362: PUSH
84363: EMPTY
84364: LIST
84365: LIST
84366: PPUSH
84367: LD_VAR 0 1
84371: PPUSH
84372: CALL 20672 0 3
84376: ST_TO_ADDR
// exit ;
84377: POP
84378: POP
84379: GO 84385
// end ; end ;
84381: GO 84185
84383: POP
84384: POP
// end ;
84385: LD_VAR 0 2
84389: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
84390: LD_INT 0
84392: PPUSH
84393: PPUSH
84394: PPUSH
84395: PPUSH
84396: PPUSH
84397: PPUSH
84398: PPUSH
// if not mc_bases or not skirmish then
84399: LD_EXP 58
84403: NOT
84404: PUSH
84405: LD_EXP 56
84409: NOT
84410: OR
84411: IFFALSE 84415
// exit ;
84413: GO 85076
// for i = 1 to mc_bases do
84415: LD_ADDR_VAR 0 3
84419: PUSH
84420: DOUBLE
84421: LD_INT 1
84423: DEC
84424: ST_TO_ADDR
84425: LD_EXP 58
84429: PUSH
84430: FOR_TO
84431: IFFALSE 85074
// begin if building in mc_construct_list [ i ] then
84433: LD_VAR 0 1
84437: PUSH
84438: LD_EXP 65
84442: PUSH
84443: LD_VAR 0 3
84447: ARRAY
84448: IN
84449: IFFALSE 85072
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
84451: LD_ADDR_EXP 65
84455: PUSH
84456: LD_EXP 65
84460: PPUSH
84461: LD_VAR 0 3
84465: PPUSH
84466: LD_EXP 65
84470: PUSH
84471: LD_VAR 0 3
84475: ARRAY
84476: PUSH
84477: LD_VAR 0 1
84481: DIFF
84482: PPUSH
84483: CALL_OW 1
84487: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
84488: LD_ADDR_EXP 58
84492: PUSH
84493: LD_EXP 58
84497: PPUSH
84498: LD_VAR 0 3
84502: PUSH
84503: LD_EXP 58
84507: PUSH
84508: LD_VAR 0 3
84512: ARRAY
84513: PUSH
84514: LD_INT 1
84516: PLUS
84517: PUSH
84518: EMPTY
84519: LIST
84520: LIST
84521: PPUSH
84522: LD_VAR 0 1
84526: PPUSH
84527: CALL 20672 0 3
84531: ST_TO_ADDR
// btype := GetBType ( building ) ;
84532: LD_ADDR_VAR 0 5
84536: PUSH
84537: LD_VAR 0 1
84541: PPUSH
84542: CALL_OW 266
84546: ST_TO_ADDR
// side := GetSide ( building ) ;
84547: LD_ADDR_VAR 0 8
84551: PUSH
84552: LD_VAR 0 1
84556: PPUSH
84557: CALL_OW 255
84561: ST_TO_ADDR
// if btype = b_lab then
84562: LD_VAR 0 5
84566: PUSH
84567: LD_INT 6
84569: EQUAL
84570: IFFALSE 84620
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
84572: LD_ADDR_EXP 91
84576: PUSH
84577: LD_EXP 91
84581: PPUSH
84582: LD_VAR 0 3
84586: PUSH
84587: LD_EXP 91
84591: PUSH
84592: LD_VAR 0 3
84596: ARRAY
84597: PUSH
84598: LD_INT 1
84600: PLUS
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PPUSH
84606: LD_VAR 0 1
84610: PPUSH
84611: CALL 20672 0 3
84615: ST_TO_ADDR
// exit ;
84616: POP
84617: POP
84618: GO 85076
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
84620: LD_VAR 0 5
84624: PUSH
84625: LD_INT 0
84627: PUSH
84628: LD_INT 2
84630: PUSH
84631: LD_INT 4
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: LIST
84638: IN
84639: IFFALSE 84763
// begin if btype = b_armoury then
84641: LD_VAR 0 5
84645: PUSH
84646: LD_INT 4
84648: EQUAL
84649: IFFALSE 84659
// btype := b_barracks ;
84651: LD_ADDR_VAR 0 5
84655: PUSH
84656: LD_INT 5
84658: ST_TO_ADDR
// if btype = b_depot then
84659: LD_VAR 0 5
84663: PUSH
84664: LD_INT 0
84666: EQUAL
84667: IFFALSE 84677
// btype := b_warehouse ;
84669: LD_ADDR_VAR 0 5
84673: PUSH
84674: LD_INT 1
84676: ST_TO_ADDR
// if btype = b_workshop then
84677: LD_VAR 0 5
84681: PUSH
84682: LD_INT 2
84684: EQUAL
84685: IFFALSE 84695
// btype := b_factory ;
84687: LD_ADDR_VAR 0 5
84691: PUSH
84692: LD_INT 3
84694: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
84695: LD_VAR 0 5
84699: PPUSH
84700: LD_VAR 0 8
84704: PPUSH
84705: CALL_OW 323
84709: PUSH
84710: LD_INT 1
84712: EQUAL
84713: IFFALSE 84759
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
84715: LD_ADDR_EXP 90
84719: PUSH
84720: LD_EXP 90
84724: PPUSH
84725: LD_VAR 0 3
84729: PUSH
84730: LD_EXP 90
84734: PUSH
84735: LD_VAR 0 3
84739: ARRAY
84740: PUSH
84741: LD_INT 1
84743: PLUS
84744: PUSH
84745: EMPTY
84746: LIST
84747: LIST
84748: PPUSH
84749: LD_VAR 0 1
84753: PPUSH
84754: CALL 20672 0 3
84758: ST_TO_ADDR
// exit ;
84759: POP
84760: POP
84761: GO 85076
// end ; if btype in [ b_bunker , b_turret ] then
84763: LD_VAR 0 5
84767: PUSH
84768: LD_INT 32
84770: PUSH
84771: LD_INT 33
84773: PUSH
84774: EMPTY
84775: LIST
84776: LIST
84777: IN
84778: IFFALSE 85068
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
84780: LD_ADDR_EXP 66
84784: PUSH
84785: LD_EXP 66
84789: PPUSH
84790: LD_VAR 0 3
84794: PUSH
84795: LD_EXP 66
84799: PUSH
84800: LD_VAR 0 3
84804: ARRAY
84805: PUSH
84806: LD_INT 1
84808: PLUS
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PPUSH
84814: LD_VAR 0 1
84818: PPUSH
84819: CALL 20672 0 3
84823: ST_TO_ADDR
// if btype = b_bunker then
84824: LD_VAR 0 5
84828: PUSH
84829: LD_INT 32
84831: EQUAL
84832: IFFALSE 85068
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
84834: LD_ADDR_EXP 67
84838: PUSH
84839: LD_EXP 67
84843: PPUSH
84844: LD_VAR 0 3
84848: PUSH
84849: LD_EXP 67
84853: PUSH
84854: LD_VAR 0 3
84858: ARRAY
84859: PUSH
84860: LD_INT 1
84862: PLUS
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PPUSH
84868: LD_VAR 0 1
84872: PPUSH
84873: CALL 20672 0 3
84877: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
84878: LD_ADDR_VAR 0 6
84882: PUSH
84883: LD_EXP 58
84887: PUSH
84888: LD_VAR 0 3
84892: ARRAY
84893: PPUSH
84894: LD_INT 25
84896: PUSH
84897: LD_INT 1
84899: PUSH
84900: EMPTY
84901: LIST
84902: LIST
84903: PUSH
84904: LD_INT 3
84906: PUSH
84907: LD_INT 54
84909: PUSH
84910: EMPTY
84911: LIST
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: PPUSH
84921: CALL_OW 72
84925: ST_TO_ADDR
// if tmp then
84926: LD_VAR 0 6
84930: IFFALSE 84936
// exit ;
84932: POP
84933: POP
84934: GO 85076
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
84936: LD_ADDR_VAR 0 6
84940: PUSH
84941: LD_EXP 58
84945: PUSH
84946: LD_VAR 0 3
84950: ARRAY
84951: PPUSH
84952: LD_INT 2
84954: PUSH
84955: LD_INT 30
84957: PUSH
84958: LD_INT 4
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 30
84967: PUSH
84968: LD_INT 5
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: EMPTY
84976: LIST
84977: LIST
84978: LIST
84979: PPUSH
84980: CALL_OW 72
84984: ST_TO_ADDR
// if not tmp then
84985: LD_VAR 0 6
84989: NOT
84990: IFFALSE 84996
// exit ;
84992: POP
84993: POP
84994: GO 85076
// for j in tmp do
84996: LD_ADDR_VAR 0 4
85000: PUSH
85001: LD_VAR 0 6
85005: PUSH
85006: FOR_IN
85007: IFFALSE 85066
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85009: LD_ADDR_VAR 0 7
85013: PUSH
85014: LD_VAR 0 4
85018: PPUSH
85019: CALL_OW 313
85023: PPUSH
85024: LD_INT 25
85026: PUSH
85027: LD_INT 1
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PPUSH
85034: CALL_OW 72
85038: ST_TO_ADDR
// if units then
85039: LD_VAR 0 7
85043: IFFALSE 85064
// begin ComExitBuilding ( units [ 1 ] ) ;
85045: LD_VAR 0 7
85049: PUSH
85050: LD_INT 1
85052: ARRAY
85053: PPUSH
85054: CALL_OW 122
// exit ;
85058: POP
85059: POP
85060: POP
85061: POP
85062: GO 85076
// end ; end ;
85064: GO 85006
85066: POP
85067: POP
// end ; end ; exit ;
85068: POP
85069: POP
85070: GO 85076
// end ; end ;
85072: GO 84430
85074: POP
85075: POP
// end ;
85076: LD_VAR 0 2
85080: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85081: LD_INT 0
85083: PPUSH
85084: PPUSH
85085: PPUSH
85086: PPUSH
85087: PPUSH
85088: PPUSH
85089: PPUSH
// if not mc_bases or not skirmish then
85090: LD_EXP 58
85094: NOT
85095: PUSH
85096: LD_EXP 56
85100: NOT
85101: OR
85102: IFFALSE 85106
// exit ;
85104: GO 85337
// btype := GetBType ( building ) ;
85106: LD_ADDR_VAR 0 6
85110: PUSH
85111: LD_VAR 0 1
85115: PPUSH
85116: CALL_OW 266
85120: ST_TO_ADDR
// x := GetX ( building ) ;
85121: LD_ADDR_VAR 0 7
85125: PUSH
85126: LD_VAR 0 1
85130: PPUSH
85131: CALL_OW 250
85135: ST_TO_ADDR
// y := GetY ( building ) ;
85136: LD_ADDR_VAR 0 8
85140: PUSH
85141: LD_VAR 0 1
85145: PPUSH
85146: CALL_OW 251
85150: ST_TO_ADDR
// d := GetDir ( building ) ;
85151: LD_ADDR_VAR 0 9
85155: PUSH
85156: LD_VAR 0 1
85160: PPUSH
85161: CALL_OW 254
85165: ST_TO_ADDR
// for i = 1 to mc_bases do
85166: LD_ADDR_VAR 0 4
85170: PUSH
85171: DOUBLE
85172: LD_INT 1
85174: DEC
85175: ST_TO_ADDR
85176: LD_EXP 58
85180: PUSH
85181: FOR_TO
85182: IFFALSE 85335
// begin if not mc_build_list [ i ] then
85184: LD_EXP 63
85188: PUSH
85189: LD_VAR 0 4
85193: ARRAY
85194: NOT
85195: IFFALSE 85199
// continue ;
85197: GO 85181
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
85199: LD_VAR 0 6
85203: PUSH
85204: LD_VAR 0 7
85208: PUSH
85209: LD_VAR 0 8
85213: PUSH
85214: LD_VAR 0 9
85218: PUSH
85219: EMPTY
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: PPUSH
85225: LD_EXP 63
85229: PUSH
85230: LD_VAR 0 4
85234: ARRAY
85235: PUSH
85236: LD_INT 1
85238: ARRAY
85239: PPUSH
85240: CALL 26841 0 2
85244: IFFALSE 85333
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
85246: LD_ADDR_EXP 63
85250: PUSH
85251: LD_EXP 63
85255: PPUSH
85256: LD_VAR 0 4
85260: PPUSH
85261: LD_EXP 63
85265: PUSH
85266: LD_VAR 0 4
85270: ARRAY
85271: PPUSH
85272: LD_INT 1
85274: PPUSH
85275: CALL_OW 3
85279: PPUSH
85280: CALL_OW 1
85284: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
85285: LD_ADDR_EXP 65
85289: PUSH
85290: LD_EXP 65
85294: PPUSH
85295: LD_VAR 0 4
85299: PUSH
85300: LD_EXP 65
85304: PUSH
85305: LD_VAR 0 4
85309: ARRAY
85310: PUSH
85311: LD_INT 1
85313: PLUS
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PPUSH
85319: LD_VAR 0 1
85323: PPUSH
85324: CALL 20672 0 3
85328: ST_TO_ADDR
// exit ;
85329: POP
85330: POP
85331: GO 85337
// end ; end ;
85333: GO 85181
85335: POP
85336: POP
// end ;
85337: LD_VAR 0 3
85341: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
85342: LD_INT 0
85344: PPUSH
85345: PPUSH
85346: PPUSH
// if not mc_bases or not skirmish then
85347: LD_EXP 58
85351: NOT
85352: PUSH
85353: LD_EXP 56
85357: NOT
85358: OR
85359: IFFALSE 85363
// exit ;
85361: GO 85553
// for i = 1 to mc_bases do
85363: LD_ADDR_VAR 0 4
85367: PUSH
85368: DOUBLE
85369: LD_INT 1
85371: DEC
85372: ST_TO_ADDR
85373: LD_EXP 58
85377: PUSH
85378: FOR_TO
85379: IFFALSE 85466
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
85381: LD_VAR 0 1
85385: PUSH
85386: LD_EXP 66
85390: PUSH
85391: LD_VAR 0 4
85395: ARRAY
85396: IN
85397: PUSH
85398: LD_VAR 0 1
85402: PUSH
85403: LD_EXP 67
85407: PUSH
85408: LD_VAR 0 4
85412: ARRAY
85413: IN
85414: NOT
85415: AND
85416: IFFALSE 85464
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85418: LD_ADDR_EXP 67
85422: PUSH
85423: LD_EXP 67
85427: PPUSH
85428: LD_VAR 0 4
85432: PUSH
85433: LD_EXP 67
85437: PUSH
85438: LD_VAR 0 4
85442: ARRAY
85443: PUSH
85444: LD_INT 1
85446: PLUS
85447: PUSH
85448: EMPTY
85449: LIST
85450: LIST
85451: PPUSH
85452: LD_VAR 0 1
85456: PPUSH
85457: CALL 20672 0 3
85461: ST_TO_ADDR
// break ;
85462: GO 85466
// end ; end ;
85464: GO 85378
85466: POP
85467: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
85468: LD_VAR 0 1
85472: PPUSH
85473: CALL_OW 257
85477: PUSH
85478: LD_EXP 84
85482: IN
85483: PUSH
85484: LD_VAR 0 1
85488: PPUSH
85489: CALL_OW 266
85493: PUSH
85494: LD_INT 5
85496: EQUAL
85497: AND
85498: PUSH
85499: LD_VAR 0 2
85503: PPUSH
85504: CALL_OW 110
85508: PUSH
85509: LD_INT 18
85511: NONEQUAL
85512: AND
85513: IFFALSE 85553
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
85515: LD_VAR 0 2
85519: PPUSH
85520: CALL_OW 257
85524: PUSH
85525: LD_INT 5
85527: PUSH
85528: LD_INT 8
85530: PUSH
85531: LD_INT 9
85533: PUSH
85534: EMPTY
85535: LIST
85536: LIST
85537: LIST
85538: IN
85539: IFFALSE 85553
// SetClass ( unit , 1 ) ;
85541: LD_VAR 0 2
85545: PPUSH
85546: LD_INT 1
85548: PPUSH
85549: CALL_OW 336
// end ;
85553: LD_VAR 0 3
85557: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
85558: LD_INT 0
85560: PPUSH
85561: PPUSH
// if not mc_bases or not skirmish then
85562: LD_EXP 58
85566: NOT
85567: PUSH
85568: LD_EXP 56
85572: NOT
85573: OR
85574: IFFALSE 85578
// exit ;
85576: GO 85694
// if GetLives ( abandoned_vehicle ) > 250 then
85578: LD_VAR 0 2
85582: PPUSH
85583: CALL_OW 256
85587: PUSH
85588: LD_INT 250
85590: GREATER
85591: IFFALSE 85595
// exit ;
85593: GO 85694
// for i = 1 to mc_bases do
85595: LD_ADDR_VAR 0 6
85599: PUSH
85600: DOUBLE
85601: LD_INT 1
85603: DEC
85604: ST_TO_ADDR
85605: LD_EXP 58
85609: PUSH
85610: FOR_TO
85611: IFFALSE 85692
// begin if driver in mc_bases [ i ] then
85613: LD_VAR 0 1
85617: PUSH
85618: LD_EXP 58
85622: PUSH
85623: LD_VAR 0 6
85627: ARRAY
85628: IN
85629: IFFALSE 85690
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
85631: LD_VAR 0 1
85635: PPUSH
85636: LD_EXP 58
85640: PUSH
85641: LD_VAR 0 6
85645: ARRAY
85646: PPUSH
85647: LD_INT 2
85649: PUSH
85650: LD_INT 30
85652: PUSH
85653: LD_INT 0
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 30
85662: PUSH
85663: LD_INT 1
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: PUSH
85670: EMPTY
85671: LIST
85672: LIST
85673: LIST
85674: PPUSH
85675: CALL_OW 72
85679: PUSH
85680: LD_INT 1
85682: ARRAY
85683: PPUSH
85684: CALL_OW 112
// break ;
85688: GO 85692
// end ; end ;
85690: GO 85610
85692: POP
85693: POP
// end ; end_of_file
85694: LD_VAR 0 5
85698: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
85699: GO 85701
85701: DISABLE
// begin ru_radar := 98 ;
85702: LD_ADDR_EXP 101
85706: PUSH
85707: LD_INT 98
85709: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
85710: LD_ADDR_EXP 102
85714: PUSH
85715: LD_INT 89
85717: ST_TO_ADDR
// us_hack := 99 ;
85718: LD_ADDR_EXP 103
85722: PUSH
85723: LD_INT 99
85725: ST_TO_ADDR
// us_artillery := 97 ;
85726: LD_ADDR_EXP 104
85730: PUSH
85731: LD_INT 97
85733: ST_TO_ADDR
// ar_bio_bomb := 91 ;
85734: LD_ADDR_EXP 105
85738: PUSH
85739: LD_INT 91
85741: ST_TO_ADDR
// end ;
85742: END
