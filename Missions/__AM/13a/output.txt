// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 56764 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48531 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48531 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48531 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48531 0 9
// PrepareArabian ;
 147: CALL 3529 0 0
// PrepareRussian ;
 151: CALL 2664 0 0
// PrepareAlliance ;
 155: CALL 729 0 0
// MC_Start ( ) ;
 159: CALL 58876 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6692 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 79981 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 80407 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 80865 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81134 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 80347 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81041 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 80407 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 80865 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81134 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80191 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 80347 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 51
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// end ; end_of_file
 724: LD_VAR 0 1
 728: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 729: LD_INT 0
 731: PPUSH
 732: PPUSH
 733: PPUSH
 734: PPUSH
// uc_side := 7 ;
 735: LD_ADDR_OWVAR 20
 739: PUSH
 740: LD_INT 7
 742: ST_TO_ADDR
// uc_nation := 1 ;
 743: LD_ADDR_OWVAR 21
 747: PUSH
 748: LD_INT 1
 750: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 751: LD_ADDR_EXP 14
 755: PUSH
 756: LD_STRING JMM
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_STRING 12a_
 767: PPUSH
 768: CALL 13966 0 3
 772: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 773: LD_EXP 14
 777: PPUSH
 778: LD_INT 71
 780: PPUSH
 781: LD_INT 23
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 791: LD_EXP 14
 795: PPUSH
 796: LD_INT 2
 798: PPUSH
 799: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_STRING Roth
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_STRING 12a_
 819: PPUSH
 820: CALL 13966 0 3
 824: ST_TO_ADDR
// if Roth then
 825: LD_EXP 15
 829: IFFALSE 849
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 831: LD_EXP 15
 835: PPUSH
 836: LD_INT 71
 838: PPUSH
 839: LD_INT 21
 841: PPUSH
 842: LD_INT 0
 844: PPUSH
 845: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 849: LD_ADDR_EXP 16
 853: PUSH
 854: LD_STRING Lisa
 856: PPUSH
 857: LD_EXP 1
 861: NOT
 862: PPUSH
 863: LD_STRING 12a_
 865: PPUSH
 866: CALL 13966 0 3
 870: ST_TO_ADDR
// if Lisa then
 871: LD_EXP 16
 875: IFFALSE 892
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 877: LD_EXP 16
 881: PPUSH
 882: LD_INT 13
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 892: LD_ADDR_EXP 17
 896: PUSH
 897: LD_STRING Donaldson
 899: PPUSH
 900: LD_EXP 1
 904: NOT
 905: PPUSH
 906: LD_STRING 12a_
 908: PPUSH
 909: CALL 13966 0 3
 913: ST_TO_ADDR
// if Donaldson then
 914: LD_EXP 17
 918: IFFALSE 935
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 920: LD_EXP 17
 924: PPUSH
 925: LD_INT 13
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 935: LD_ADDR_EXP 18
 939: PUSH
 940: LD_STRING Bobby
 942: PPUSH
 943: LD_EXP 1
 947: NOT
 948: PPUSH
 949: LD_STRING 12a_
 951: PPUSH
 952: CALL 13966 0 3
 956: ST_TO_ADDR
// if Bobby then
 957: LD_EXP 18
 961: IFFALSE 978
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 963: LD_EXP 18
 967: PPUSH
 968: LD_INT 13
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 978: LD_ADDR_EXP 19
 982: PUSH
 983: LD_STRING Cyrus
 985: PPUSH
 986: LD_EXP 1
 990: NOT
 991: PPUSH
 992: LD_STRING 12a_
 994: PPUSH
 995: CALL 13966 0 3
 999: ST_TO_ADDR
// if Cyrus then
1000: LD_EXP 19
1004: IFFALSE 1021
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1006: LD_EXP 19
1010: PPUSH
1011: LD_INT 13
1013: PPUSH
1014: LD_INT 0
1016: PPUSH
1017: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1021: LD_ADDR_EXP 20
1025: PUSH
1026: LD_STRING Denis
1028: PPUSH
1029: LD_EXP 1
1033: NOT
1034: PPUSH
1035: LD_STRING 12a_
1037: PPUSH
1038: CALL 13966 0 3
1042: ST_TO_ADDR
// if Denis then
1043: LD_EXP 20
1047: IFFALSE 1064
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1049: LD_EXP 20
1053: PPUSH
1054: LD_INT 13
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1064: LD_ADDR_EXP 21
1068: PUSH
1069: LD_STRING Brown
1071: PPUSH
1072: LD_EXP 1
1076: NOT
1077: PPUSH
1078: LD_STRING 12a_
1080: PPUSH
1081: CALL 13966 0 3
1085: ST_TO_ADDR
// if Brown then
1086: LD_EXP 21
1090: IFFALSE 1107
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1092: LD_EXP 21
1096: PPUSH
1097: LD_INT 13
1099: PPUSH
1100: LD_INT 0
1102: PPUSH
1103: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1107: LD_ADDR_EXP 22
1111: PUSH
1112: LD_STRING Gladstone
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_STRING 12a_
1123: PPUSH
1124: CALL 13966 0 3
1128: ST_TO_ADDR
// if Gladstone then
1129: LD_EXP 22
1133: IFFALSE 1150
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1135: LD_EXP 22
1139: PPUSH
1140: LD_INT 13
1142: PPUSH
1143: LD_INT 0
1145: PPUSH
1146: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1150: LD_ADDR_EXP 23
1154: PUSH
1155: LD_STRING Houten
1157: PPUSH
1158: LD_EXP 1
1162: NOT
1163: PPUSH
1164: LD_STRING 12a_
1166: PPUSH
1167: CALL 13966 0 3
1171: ST_TO_ADDR
// if Houten then
1172: LD_EXP 23
1176: IFFALSE 1193
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1178: LD_EXP 23
1182: PPUSH
1183: LD_INT 13
1185: PPUSH
1186: LD_INT 0
1188: PPUSH
1189: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1193: LD_ADDR_EXP 24
1197: PUSH
1198: LD_STRING Cornell
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 12a_
1209: PPUSH
1210: CALL 13966 0 3
1214: ST_TO_ADDR
// if Cornel then
1215: LD_EXP 24
1219: IFFALSE 1236
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1221: LD_EXP 24
1225: PPUSH
1226: LD_INT 13
1228: PPUSH
1229: LD_INT 0
1231: PPUSH
1232: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1236: LD_ADDR_EXP 25
1240: PUSH
1241: LD_STRING Gary
1243: PPUSH
1244: LD_EXP 1
1248: NOT
1249: PPUSH
1250: LD_STRING 12a_
1252: PPUSH
1253: CALL 13966 0 3
1257: ST_TO_ADDR
// if Gary then
1258: LD_EXP 25
1262: IFFALSE 1279
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1264: LD_EXP 25
1268: PPUSH
1269: LD_INT 13
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1279: LD_ADDR_EXP 26
1283: PUSH
1284: LD_STRING Frank
1286: PPUSH
1287: LD_EXP 1
1291: NOT
1292: PPUSH
1293: LD_STRING 12a_
1295: PPUSH
1296: CALL 13966 0 3
1300: ST_TO_ADDR
// if Frank then
1301: LD_EXP 26
1305: IFFALSE 1322
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1307: LD_EXP 26
1311: PPUSH
1312: LD_INT 13
1314: PPUSH
1315: LD_INT 0
1317: PPUSH
1318: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1322: LD_ADDR_EXP 27
1326: PUSH
1327: LD_STRING Kikuchi
1329: PPUSH
1330: LD_EXP 1
1334: NOT
1335: PPUSH
1336: LD_STRING 12a_
1338: PPUSH
1339: CALL 13966 0 3
1343: ST_TO_ADDR
// if Kikuchi then
1344: LD_EXP 27
1348: IFFALSE 1365
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1350: LD_EXP 27
1354: PPUSH
1355: LD_INT 13
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1365: LD_ADDR_EXP 28
1369: PUSH
1370: LD_STRING Simms
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_STRING 12a_
1381: PPUSH
1382: CALL 13966 0 3
1386: ST_TO_ADDR
// if Simms then
1387: LD_EXP 28
1391: IFFALSE 1408
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1393: LD_EXP 28
1397: PPUSH
1398: LD_INT 13
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1408: LD_ADDR_EXP 29
1412: PUSH
1413: LD_STRING Joan
1415: PPUSH
1416: LD_EXP 1
1420: NOT
1421: PPUSH
1422: LD_STRING 12a_
1424: PPUSH
1425: CALL 13966 0 3
1429: ST_TO_ADDR
// if Joan then
1430: LD_EXP 29
1434: IFFALSE 1451
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1436: LD_EXP 29
1440: PPUSH
1441: LD_INT 13
1443: PPUSH
1444: LD_INT 0
1446: PPUSH
1447: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1451: LD_ADDR_EXP 30
1455: PUSH
1456: LD_STRING DeltaDoctor
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 12a_
1467: PPUSH
1468: CALL 13966 0 3
1472: ST_TO_ADDR
// if DeltaDoctor then
1473: LD_EXP 30
1477: IFFALSE 1494
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1479: LD_EXP 30
1483: PPUSH
1484: LD_INT 13
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_STRING 12a_others
1501: PPUSH
1502: CALL_OW 31
1506: ST_TO_ADDR
// if tmp then
1507: LD_VAR 0 4
1511: IFFALSE 1545
// for i in tmp do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1543
// PlaceUnitArea ( i , alliance_start , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 13
1533: PPUSH
1534: LD_INT 0
1536: PPUSH
1537: CALL_OW 49
1541: GO 1523
1543: POP
1544: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1545: LD_INT 3
1547: PPUSH
1548: LD_INT 3
1550: PPUSH
1551: LD_INT 3
1553: PPUSH
1554: LD_INT 12
1556: PPUSH
1557: LD_INT 100
1559: PPUSH
1560: CALL 20717 0 5
// veh := CreateVehicle ;
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: CALL_OW 45
1573: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1574: LD_VAR 0 2
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1586: LD_VAR 0 2
1590: PPUSH
1591: LD_INT 60
1593: PPUSH
1594: LD_INT 6
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1604: LD_VAR 0 2
1608: PPUSH
1609: LD_INT 4
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1619: LD_STRING 11_artifact_captured
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 30
1629: IFFALSE 1705
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1631: LD_INT 3
1633: PPUSH
1634: LD_INT 3
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 12
1642: PPUSH
1643: LD_INT 100
1645: PPUSH
1646: CALL 20717 0 5
// veh := CreateVehicle ;
1650: LD_ADDR_VAR 0 2
1654: PUSH
1655: CALL_OW 45
1659: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1672: LD_VAR 0 2
1676: PPUSH
1677: LD_INT 75
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1690: LD_VAR 0 2
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: LD_INT 50
1700: PPUSH
1701: CALL_OW 290
// end ; end ;
1705: LD_VAR 0 1
1709: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// uc_side := 6 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 6
1723: ST_TO_ADDR
// uc_nation := 3 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1736: LD_ADDR_EXP 31
1740: PUSH
1741: LD_STRING Gossudarov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1749: LD_ADDR_EXP 32
1753: PUSH
1754: LD_STRING Kirilenkova
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1762: LD_ADDR_EXP 33
1766: PUSH
1767: LD_STRING Titov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1775: LD_ADDR_EXP 38
1779: PUSH
1780: LD_STRING Oblukov
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1788: LD_ADDR_EXP 35
1792: PUSH
1793: LD_STRING Dolgov
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1801: LD_ADDR_EXP 36
1805: PUSH
1806: LD_STRING Petrosyan
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1814: LD_ADDR_EXP 37
1818: PUSH
1819: LD_STRING Scholtze
1821: PPUSH
1822: CALL_OW 25
1826: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1827: LD_ADDR_EXP 39
1831: PUSH
1832: LD_STRING Kapitsova
1834: PPUSH
1835: CALL_OW 25
1839: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1840: LD_ADDR_VAR 0 2
1844: PUSH
1845: LD_EXP 31
1849: PUSH
1850: LD_EXP 32
1854: PUSH
1855: LD_EXP 33
1859: PUSH
1860: LD_EXP 38
1864: PUSH
1865: LD_EXP 35
1869: PUSH
1870: LD_EXP 36
1874: PUSH
1875: LD_EXP 37
1879: PUSH
1880: LD_EXP 39
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1895: LD_INT 1
1897: PPUSH
1898: LD_INT 4
1900: PPUSH
1901: LD_INT 8
1903: PPUSH
1904: CALL_OW 380
// un := CreateHuman ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: CALL_OW 44
1917: ST_TO_ADDR
// tmp := tmp ^ un ;
1918: LD_ADDR_VAR 0 2
1922: PUSH
1923: LD_VAR 0 2
1927: PUSH
1928: LD_VAR 0 4
1932: ADD
1933: ST_TO_ADDR
// for i in tmp do
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: LD_VAR 0 2
1943: PUSH
1944: FOR_IN
1945: IFFALSE 1964
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1947: LD_VAR 0 3
1951: PPUSH
1952: LD_INT 14
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 49
1962: GO 1944
1964: POP
1965: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1966: LD_VAR 0 2
1970: PPUSH
1971: LD_EXP 3
1975: PPUSH
1976: CALL_OW 250
1980: PPUSH
1981: LD_EXP 3
1985: PPUSH
1986: CALL_OW 251
1990: PPUSH
1991: CALL_OW 111
// end ;
1995: LD_VAR 0 1
1999: RET
// export function PrepareBelkov ; begin
2000: LD_INT 0
2002: PPUSH
// uc_side := 4 ;
2003: LD_ADDR_OWVAR 20
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// uc_nation := 3 ;
2011: LD_ADDR_OWVAR 21
2015: PUSH
2016: LD_INT 3
2018: ST_TO_ADDR
// InitHc ;
2019: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2023: LD_ADDR_EXP 46
2027: PUSH
2028: LD_STRING Belkov
2030: PPUSH
2031: CALL_OW 25
2035: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2036: LD_EXP 46
2040: PPUSH
2041: LD_INT 14
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// end ;
2051: LD_VAR 0 1
2055: RET
// export function PrepareGnyevko ; begin
2056: LD_INT 0
2058: PPUSH
// uc_side := 4 ;
2059: LD_ADDR_OWVAR 20
2063: PUSH
2064: LD_INT 4
2066: ST_TO_ADDR
// uc_nation := 3 ;
2067: LD_ADDR_OWVAR 21
2071: PUSH
2072: LD_INT 3
2074: ST_TO_ADDR
// InitHc ;
2075: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2079: LD_ADDR_EXP 47
2083: PUSH
2084: LD_STRING Gnyevko
2086: PPUSH
2087: CALL_OW 25
2091: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2092: LD_EXP 47
2096: PPUSH
2097: LD_INT 14
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// end ;
2107: LD_VAR 0 1
2111: RET
// export function PrepareBurlak ; var i , tmp ; begin
2112: LD_INT 0
2114: PPUSH
2115: PPUSH
2116: PPUSH
// uc_side := 4 ;
2117: LD_ADDR_OWVAR 20
2121: PUSH
2122: LD_INT 4
2124: ST_TO_ADDR
// uc_nation := 3 ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2133: LD_INT 35
2135: PPUSH
2136: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2140: LD_INT 92
2142: PUSH
2143: LD_INT 123
2145: PUSH
2146: LD_INT 3
2148: PUSH
2149: LD_INT 3
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: NOT
2163: IFFALSE 2133
// InitHc ;
2165: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2169: LD_ADDR_EXP 45
2173: PUSH
2174: LD_STRING Burlak
2176: PPUSH
2177: CALL_OW 25
2181: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2182: LD_INT 24
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 22
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 1
2207: PPUSH
2208: LD_INT 45
2210: PUSH
2211: LD_INT 44
2213: PUSH
2214: LD_INT 43
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 20717 0 5
// Masha := CreateVehicle ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: CALL_OW 45
2244: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2245: LD_EXP 48
2249: PUSH
2250: LD_EXP 45
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: LD_INT 499
2261: PPUSH
2262: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2266: LD_EXP 48
2270: PPUSH
2271: LD_INT 3
2273: PPUSH
2274: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 1
2285: PPUSH
2286: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2290: LD_EXP 48
2294: PPUSH
2295: LD_INT 18
2297: PPUSH
2298: LD_INT 0
2300: PPUSH
2301: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2305: LD_EXP 45
2309: PPUSH
2310: LD_INT 125
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 0
2318: PPUSH
2319: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2323: LD_EXP 45
2327: PPUSH
2328: LD_EXP 48
2332: PPUSH
2333: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2337: LD_INT 10
2339: PPUSH
2340: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2344: LD_EXP 48
2348: PPUSH
2349: LD_INT 110
2351: PPUSH
2352: LD_INT 10
2354: PPUSH
2355: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2359: LD_ADDR_EXP 41
2363: PUSH
2364: LD_STRING Petrovova
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2372: LD_ADDR_EXP 43
2376: PUSH
2377: LD_STRING Kuzmov
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2385: LD_ADDR_EXP 42
2389: PUSH
2390: LD_STRING Kovalyuk
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2398: LD_ADDR_EXP 40
2402: PUSH
2403: LD_STRING Lipshchin
2405: PPUSH
2406: CALL_OW 25
2410: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2411: LD_ADDR_EXP 44
2415: PUSH
2416: LD_STRING Karamazov
2418: PPUSH
2419: CALL_OW 25
2423: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2424: LD_ADDR_VAR 0 3
2428: PUSH
2429: LD_EXP 41
2433: PUSH
2434: LD_EXP 43
2438: PUSH
2439: LD_EXP 42
2443: PUSH
2444: LD_EXP 40
2448: PUSH
2449: LD_EXP 44
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: ST_TO_ADDR
// for i in tmp do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2511
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2474: LD_VAR 0 2
2478: PPUSH
2479: LD_INT 399
2481: PPUSH
2482: LD_INT 799
2484: PPUSH
2485: CALL_OW 12
2489: PPUSH
2490: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: LD_INT 19
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 49
// end ;
2509: GO 2471
2511: POP
2512: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_INT 116
2520: PPUSH
2521: LD_INT 8
2523: PPUSH
2524: CALL_OW 111
// AddComHold ( tmp ) ;
2528: LD_VAR 0 3
2532: PPUSH
2533: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2537: LD_ADDR_VAR 0 2
2541: PUSH
2542: LD_VAR 0 3
2546: PPUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2603
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 20
2572: PPUSH
2573: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2577: LD_VAR 0 2
2581: PPUSH
2582: LD_INT 147
2584: PPUSH
2585: LD_INT 45
2587: PPUSH
2588: CALL_OW 178
// AddComCrawl ( i ) ;
2592: LD_VAR 0 2
2596: PPUSH
2597: CALL_OW 197
// end ;
2601: GO 2562
2603: POP
2604: POP
// repeat wait ( 0 0$1 ) ;
2605: LD_INT 35
2607: PPUSH
2608: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2612: LD_EXP 48
2616: PPUSH
2617: LD_INT 110
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 307
2627: PUSH
2628: LD_EXP 48
2632: PPUSH
2633: CALL_OW 305
2637: NOT
2638: OR
2639: IFFALSE 2605
// ComStop ( Burlak ) ;
2641: LD_EXP 45
2645: PPUSH
2646: CALL_OW 141
// AddComHold ( Burlak ) ;
2650: LD_EXP 45
2654: PPUSH
2655: CALL_OW 200
// end ; end_of_file
2659: LD_VAR 0 1
2663: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2664: LD_INT 0
2666: PPUSH
2667: PPUSH
2668: PPUSH
2669: PPUSH
// uc_side := 3 ;
2670: LD_ADDR_OWVAR 20
2674: PUSH
2675: LD_INT 3
2677: ST_TO_ADDR
// uc_nation := 3 ;
2678: LD_ADDR_OWVAR 21
2682: PUSH
2683: LD_INT 3
2685: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2686: LD_ADDR_EXP 49
2690: PUSH
2691: LD_INT 47
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: LD_INT 7
2702: PUSH
2703: LD_INT 8
2705: PUSH
2706: LD_INT 9
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_OWVAR 67
2718: ARRAY
2719: PPUSH
2720: LD_INT 10000
2722: PUSH
2723: LD_INT 3000
2725: PUSH
2726: LD_INT 300
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PPUSH
2734: LD_INT 9
2736: PUSH
2737: LD_INT 5
2739: PUSH
2740: LD_INT 6
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL 24126 0 6
2756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2757: LD_ADDR_EXP 58
2761: PUSH
2762: LD_EXP 58
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_EXP 49
2774: PPUSH
2775: CALL_OW 1
2779: ST_TO_ADDR
// tmp := [ ] ;
2780: LD_ADDR_VAR 0 4
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// for i = 1 to 4 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 4
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2894
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2803: LD_INT 22
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_INT 3
2811: PPUSH
2812: LD_INT 43
2814: PUSH
2815: LD_INT 45
2817: PUSH
2818: LD_INT 45
2820: PUSH
2821: LD_INT 44
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: LD_VAR 0 2
2834: PUSH
2835: LD_INT 4
2837: MOD
2838: PUSH
2839: LD_INT 1
2841: PLUS
2842: ARRAY
2843: PPUSH
2844: LD_INT 100
2846: PPUSH
2847: CALL 20717 0 5
// veh := CreateVehicle ;
2851: LD_ADDR_VAR 0 3
2855: PUSH
2856: CALL_OW 45
2860: ST_TO_ADDR
// tmp := tmp ^ veh ;
2861: LD_ADDR_VAR 0 4
2865: PUSH
2866: LD_VAR 0 4
2870: PUSH
2871: LD_VAR 0 3
2875: ADD
2876: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2877: LD_VAR 0 3
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 49
// end ;
2892: GO 2800
2894: POP
2895: POP
// russian_guard := tmp ;
2896: LD_ADDR_EXP 50
2900: PUSH
2901: LD_VAR 0 4
2905: ST_TO_ADDR
// end ;
2906: LD_VAR 0 1
2910: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2911: LD_INT 47
2913: PPUSH
2914: CALL_OW 302
2918: PUSH
2919: LD_EXP 6
2923: AND
2924: IFFALSE 3526
2926: GO 2928
2928: DISABLE
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
// begin enable ;
2937: ENABLE
// base := 2 ;
2938: LD_ADDR_VAR 0 2
2942: PUSH
2943: LD_INT 2
2945: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: LD_INT 0
2956: PUSH
2957: LD_INT 0
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: LD_INT 0
2968: PUSH
2969: LD_INT 0
2971: PUSH
2972: LD_INT 0
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 1
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 45
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 21
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 3
3024: PUSH
3025: LD_INT 45
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 22
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 3
3042: PUSH
3043: LD_INT 45
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 23
3054: PUSH
3055: LD_INT 1
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 46
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3076: LD_ADDR_VAR 0 1
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_OWVAR 67
3090: PUSH
3091: LD_OWVAR 1
3095: PUSH
3096: LD_INT 21000
3098: DIV
3099: PLUS
3100: PUSH
3101: FOR_TO
3102: IFFALSE 3190
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3104: LD_ADDR_VAR 0 3
3108: PUSH
3109: LD_VAR 0 3
3113: PPUSH
3114: LD_VAR 0 3
3118: PUSH
3119: LD_INT 1
3121: PLUS
3122: PPUSH
3123: LD_INT 23
3125: PUSH
3126: LD_INT 24
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 1
3135: PPUSH
3136: LD_INT 2
3138: PPUSH
3139: CALL_OW 12
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: LD_INT 46
3153: PUSH
3154: LD_INT 47
3156: PUSH
3157: LD_INT 45
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_INT 3
3170: PPUSH
3171: CALL_OW 12
3175: ARRAY
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 2
3187: ST_TO_ADDR
3188: GO 3101
3190: POP
3191: POP
// MC_InsertProduceList ( base , tmp ) ;
3192: LD_VAR 0 2
3196: PPUSH
3197: LD_VAR 0 3
3201: PPUSH
3202: CALL 80347 0 2
// repeat wait ( 0 0$1 ) ;
3206: LD_INT 35
3208: PPUSH
3209: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3213: LD_EXP 77
3217: PUSH
3218: LD_VAR 0 2
3222: ARRAY
3223: PUSH
3224: LD_INT 6
3226: GREATER
3227: IFFALSE 3206
// wait ( 0 0$20 ) ;
3229: LD_INT 700
3231: PPUSH
3232: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: LD_INT 71
3243: PUSH
3244: LD_INT 19
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 91
3253: PUSH
3254: LD_INT 67
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 52
3263: PUSH
3264: LD_INT 44
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 68
3273: PUSH
3274: LD_INT 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3287: LD_ADDR_VAR 0 6
3291: PUSH
3292: LD_EXP 77
3296: PUSH
3297: LD_VAR 0 2
3301: ARRAY
3302: PUSH
3303: LD_EXP 77
3307: PUSH
3308: LD_VAR 0 2
3312: ARRAY
3313: PPUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 34
3319: PUSH
3320: LD_INT 51
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 34
3329: PUSH
3330: LD_INT 52
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: PPUSH
3342: CALL_OW 72
3346: DIFF
3347: ST_TO_ADDR
// if not attackers then
3348: LD_VAR 0 6
3352: NOT
3353: IFFALSE 3357
// exit ;
3355: GO 3526
// ru_attackers := attackers ;
3357: LD_ADDR_EXP 51
3361: PUSH
3362: LD_VAR 0 6
3366: ST_TO_ADDR
// for i = 1 to attackers do
3367: LD_ADDR_VAR 0 1
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 6
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3460
// begin case i mod 3 of 0 :
3385: LD_VAR 0 1
3389: PUSH
3390: LD_INT 3
3392: MOD
3393: PUSH
3394: LD_INT 0
3396: DOUBLE
3397: EQUAL
3398: IFTRUE 3402
3400: GO 3405
3402: POP
// ; 1 :
3403: GO 3458
3405: LD_INT 1
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 32
3421: PPUSH
3422: LD_INT 49
3424: PPUSH
3425: CALL_OW 114
3429: GO 3458
3431: LD_INT 2
3433: DOUBLE
3434: EQUAL
3435: IFTRUE 3439
3437: GO 3457
3439: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_INT 117
3447: PPUSH
3448: LD_INT 107
3450: PPUSH
3451: CALL_OW 114
3455: GO 3458
3457: POP
// end ;
3458: GO 3382
3460: POP
3461: POP
// repeat wait ( 0 0$1 ) ;
3462: LD_INT 35
3464: PPUSH
3465: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3469: LD_VAR 0 6
3473: PPUSH
3474: LD_INT 60
3476: PUSH
3477: EMPTY
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: NOT
3485: IFFALSE 3462
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3487: LD_VAR 0 2
3491: PPUSH
3492: LD_VAR 0 6
3496: PPUSH
3497: LD_VAR 0 5
3501: PPUSH
3502: LD_VAR 0 4
3506: PPUSH
3507: CALL 80532 0 4
// if not first_attack then
3511: LD_EXP 7
3515: NOT
3516: IFFALSE 3526
// first_attack := true ;
3518: LD_ADDR_EXP 7
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// end ; end_of_file
3526: PPOPN 6
3528: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3529: LD_INT 0
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// uc_side := 2 ;
3538: LD_ADDR_OWVAR 20
3542: PUSH
3543: LD_INT 2
3545: ST_TO_ADDR
// uc_nation := 2 ;
3546: LD_ADDR_OWVAR 21
3550: PUSH
3551: LD_INT 2
3553: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3554: LD_ADDR_EXP 54
3558: PUSH
3559: LD_STRING Abdul
3561: PPUSH
3562: CALL_OW 25
3566: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3567: LD_EXP 54
3571: PPUSH
3572: LD_INT 11
3574: PPUSH
3575: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3579: LD_EXP 54
3583: PPUSH
3584: LD_INT 1
3586: PPUSH
3587: CALL_OW 52
// vc_chassis := 31 ;
3591: LD_ADDR_OWVAR 37
3595: PUSH
3596: LD_INT 31
3598: ST_TO_ADDR
// vc_control := control_rider ;
3599: LD_ADDR_OWVAR 38
3603: PUSH
3604: LD_INT 4
3606: ST_TO_ADDR
// mastodont := CreateVehicle ;
3607: LD_ADDR_EXP 55
3611: PUSH
3612: CALL_OW 45
3616: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3617: LD_EXP 55
3621: PPUSH
3622: LD_INT 153
3624: PPUSH
3625: LD_INT 71
3627: PPUSH
3628: LD_INT 0
3630: PPUSH
3631: CALL_OW 48
// InitVc ;
3635: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3639: LD_ADDR_EXP 52
3643: PUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_STRING 
3652: PPUSH
3653: LD_INT 7
3655: PUSH
3656: LD_INT 8
3658: PUSH
3659: LD_INT 9
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_OWVAR 67
3671: ARRAY
3672: PPUSH
3673: LD_INT 5000
3675: PUSH
3676: LD_INT 1000
3678: PUSH
3679: LD_INT 300
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: LD_INT 22
3689: PUSH
3690: LD_INT 5
3692: PUSH
3693: LD_INT 6
3695: PUSH
3696: LD_INT 9
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: PPUSH
3705: CALL 24126 0 6
3709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3710: LD_ADDR_EXP 58
3714: PUSH
3715: LD_EXP 58
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_EXP 52
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// tmp := [ ] ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3740: LD_ADDR_OWVAR 37
3744: PUSH
3745: LD_INT 14
3747: ST_TO_ADDR
// vc_engine := engine_siberite ;
3748: LD_ADDR_OWVAR 39
3752: PUSH
3753: LD_INT 3
3755: ST_TO_ADDR
// vc_control := control_manual ;
3756: LD_ADDR_OWVAR 38
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3764: LD_ADDR_OWVAR 40
3768: PUSH
3769: LD_INT 31
3771: ST_TO_ADDR
// for i = 1 to 3 do
3772: LD_ADDR_VAR 0 2
3776: PUSH
3777: DOUBLE
3778: LD_INT 1
3780: DEC
3781: ST_TO_ADDR
3782: LD_INT 3
3784: PUSH
3785: FOR_TO
3786: IFFALSE 4030
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3788: LD_ADDR_VAR 0 5
3792: PUSH
3793: LD_INT 153
3795: PUSH
3796: LD_INT 71
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 155
3805: PUSH
3806: LD_INT 81
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: MOD
3825: PUSH
3826: LD_INT 1
3828: PLUS
3829: ARRAY
3830: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3831: LD_INT 0
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: LD_INT 7
3839: PUSH
3840: LD_INT 8
3842: PUSH
3843: LD_INT 9
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_OWVAR 67
3855: ARRAY
3856: PPUSH
3857: CALL_OW 380
// un := CreateVehicle ;
3861: LD_ADDR_VAR 0 6
3865: PUSH
3866: CALL_OW 45
3870: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3871: LD_VAR 0 6
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_INT 5
3881: PPUSH
3882: CALL_OW 12
3886: PPUSH
3887: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3891: LD_VAR 0 6
3895: PPUSH
3896: LD_VAR 0 5
3900: PUSH
3901: LD_INT 1
3903: ARRAY
3904: PPUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_INT 2
3912: ARRAY
3913: PPUSH
3914: LD_INT 6
3916: PPUSH
3917: LD_INT 0
3919: PPUSH
3920: CALL_OW 50
// un2 := CreateHuman ;
3924: LD_ADDR_VAR 0 7
3928: PUSH
3929: CALL_OW 44
3933: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3934: LD_VAR 0 7
3938: PPUSH
3939: LD_VAR 0 6
3943: PPUSH
3944: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3948: LD_ADDR_EXP 58
3952: PUSH
3953: LD_EXP 58
3957: PPUSH
3958: LD_INT 1
3960: PUSH
3961: LD_EXP 58
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: LD_VAR 0 6
3982: PPUSH
3983: CALL 20839 0 3
3987: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3988: LD_ADDR_EXP 58
3992: PUSH
3993: LD_EXP 58
3997: PPUSH
3998: LD_INT 1
4000: PUSH
4001: LD_EXP 58
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 1
4012: PLUS
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: LD_VAR 0 7
4022: PPUSH
4023: CALL 20839 0 3
4027: ST_TO_ADDR
// end ;
4028: GO 3785
4030: POP
4031: POP
// for i = 1 to 5 do
4032: LD_ADDR_VAR 0 2
4036: PUSH
4037: DOUBLE
4038: LD_INT 1
4040: DEC
4041: ST_TO_ADDR
4042: LD_INT 5
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4139
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4048: LD_INT 14
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_INT 25
4059: PUSH
4060: LD_INT 28
4062: PUSH
4063: LD_INT 28
4065: PUSH
4066: LD_INT 26
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: PUSH
4075: LD_VAR 0 2
4079: PUSH
4080: LD_INT 4
4082: MOD
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: ARRAY
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL 20717 0 5
// veh := CreateVehicle ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// tmp := tmp ^ veh ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_VAR 0 3
4120: ADD
4121: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// end ;
4137: GO 4045
4139: POP
4140: POP
// arabian_guard := tmp ;
4141: LD_ADDR_EXP 53
4145: PUSH
4146: LD_VAR 0 4
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4156: LD_INT 22
4158: PUSH
4159: LD_INT 7
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 91
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 12
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PPUSH
4184: CALL_OW 69
4188: PUSH
4189: LD_EXP 55
4193: PPUSH
4194: CALL_OW 256
4198: PUSH
4199: LD_INT 990
4201: LESS
4202: OR
4203: PUSH
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 256
4213: PUSH
4214: LD_INT 990
4216: LESS
4217: OR
4218: IFFALSE 4361
4220: GO 4222
4222: DISABLE
// begin if IsInUnit ( Abdul ) then
4223: LD_EXP 54
4227: PPUSH
4228: CALL_OW 310
4232: IFFALSE 4243
// ComExitBuilding ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 122
// if Mastodont then
4243: LD_EXP 55
4247: IFFALSE 4264
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4249: LD_EXP 55
4253: PPUSH
4254: LD_INT 205
4256: PPUSH
4257: LD_INT 132
4259: PPUSH
4260: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4264: LD_EXP 54
4268: PPUSH
4269: LD_INT 205
4271: PPUSH
4272: LD_INT 132
4274: PPUSH
4275: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4279: LD_INT 35
4281: PPUSH
4282: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4286: LD_EXP 54
4290: PPUSH
4291: LD_INT 21
4293: PPUSH
4294: CALL_OW 308
4298: IFFALSE 4279
// RemoveUnit ( Abdul ) ;
4300: LD_EXP 54
4304: PPUSH
4305: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4309: LD_INT 35
4311: PPUSH
4312: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4316: LD_EXP 55
4320: PPUSH
4321: LD_INT 21
4323: PPUSH
4324: CALL_OW 308
4328: PUSH
4329: LD_EXP 55
4333: PPUSH
4334: CALL_OW 301
4338: OR
4339: IFFALSE 4309
// if IsOk ( Mastodont ) then
4341: LD_EXP 55
4345: PPUSH
4346: CALL_OW 302
4350: IFFALSE 4361
// RemoveUnit ( Mastodont ) ;
4352: LD_EXP 55
4356: PPUSH
4357: CALL_OW 64
// end ;
4361: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4362: LD_EXP 54
4366: PPUSH
4367: CALL_OW 301
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 2
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 25
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 4
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 8
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 16
4454: PUSH
4455: LD_INT 19
4457: PUSH
4458: LD_INT 22
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: LESS
4472: OR
4473: IFFALSE 5146
4475: GO 4477
4477: DISABLE
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
4485: PPUSH
// begin MC_Kill ( 1 ) ;
4486: LD_INT 1
4488: PPUSH
4489: CALL 56999 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 2
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 25
4533: PUSH
4534: LD_INT 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 25
4543: PUSH
4544: LD_INT 4
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 25
4553: PUSH
4554: LD_INT 8
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PPUSH
4573: CALL_OW 69
4577: ST_TO_ADDR
// for i in tmp do
4578: LD_ADDR_VAR 0 5
4582: PUSH
4583: LD_VAR 0 2
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4605
// SetTag ( i , 10 ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: LD_INT 10
4598: PPUSH
4599: CALL_OW 109
4603: GO 4588
4605: POP
4606: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4607: LD_ADDR_VAR 0 3
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 2
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 21
4624: PUSH
4625: LD_INT 1
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: PUSH
4641: LD_VAR 0 2
4645: DIFF
4646: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 2
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 24
4674: PUSH
4675: LD_INT 300
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4692: LD_ADDR_VAR 0 4
4696: PUSH
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 33
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 58
4714: PUSH
4715: EMPTY
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 72
4726: ST_TO_ADDR
// for i in tmp do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: LD_VAR 0 2
4736: PUSH
4737: FOR_IN
4738: IFFALSE 4922
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4740: LD_VAR 0 5
4744: PUSH
4745: LD_INT 55
4747: PUSH
4748: EMPTY
4749: LIST
4750: PPUSH
4751: CALL_OW 69
4755: IN
4756: IFFALSE 4775
// begin AddComMoveXY ( i , 209 , 132 ) ;
4758: LD_VAR 0 5
4762: PPUSH
4763: LD_INT 209
4765: PPUSH
4766: LD_INT 132
4768: PPUSH
4769: CALL_OW 171
// continue ;
4773: GO 4737
// end ; if IsInUnit ( i ) then
4775: LD_VAR 0 5
4779: PPUSH
4780: CALL_OW 310
4784: IFFALSE 4802
// begin ComExitBuilding ( i ) ;
4786: LD_VAR 0 5
4790: PPUSH
4791: CALL_OW 122
// wait ( 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 67
// end ; if tmp_empty then
4802: LD_VAR 0 4
4806: IFFALSE 4905
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4808: LD_VAR 0 5
4812: PPUSH
4813: LD_VAR 0 4
4817: PPUSH
4818: LD_VAR 0 5
4822: PPUSH
4823: CALL_OW 74
4827: PPUSH
4828: CALL_OW 296
4832: PUSH
4833: LD_INT 25
4835: LESS
4836: IFFALSE 4905
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_VAR 0 4
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 74
4857: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_VAR 0 6
4867: PPUSH
4868: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4872: LD_VAR 0 5
4876: PPUSH
4877: LD_INT 209
4879: PPUSH
4880: LD_INT 132
4882: PPUSH
4883: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4887: LD_ADDR_VAR 0 4
4891: PUSH
4892: LD_VAR 0 4
4896: PUSH
4897: LD_VAR 0 6
4901: DIFF
4902: ST_TO_ADDR
// continue ;
4903: GO 4737
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4905: LD_VAR 0 5
4909: PPUSH
4910: LD_INT 201
4912: PPUSH
4913: LD_INT 132
4915: PPUSH
4916: CALL_OW 171
// end ;
4920: GO 4737
4922: POP
4923: POP
// for i in tmp_ape do
4924: LD_ADDR_VAR 0 5
4928: PUSH
4929: LD_VAR 0 3
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4974
// begin if IsInUnit ( i ) then
4937: LD_VAR 0 5
4941: PPUSH
4942: CALL_OW 310
4946: IFFALSE 4957
// ComExitBuilding ( i ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_INT 201
4964: PPUSH
4965: LD_INT 132
4967: PPUSH
4968: CALL_OW 171
// end ;
4972: GO 4934
4974: POP
4975: POP
// repeat wait ( 0 0$1 ) ;
4976: LD_INT 35
4978: PPUSH
4979: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4983: LD_ADDR_VAR 0 5
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_VAR 0 3
4997: UNION
4998: PUSH
4999: LD_VAR 0 1
5003: UNION
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5037
// if not HasTask ( i ) then
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 314
5017: NOT
5018: IFFALSE 5035
// ComMoveXY ( i , 201 , 132 ) ;
5020: LD_VAR 0 5
5024: PPUSH
5025: LD_INT 201
5027: PPUSH
5028: LD_INT 132
5030: PPUSH
5031: CALL_OW 111
5035: GO 5005
5037: POP
5038: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5039: LD_INT 21
5041: PPUSH
5042: LD_INT 22
5044: PUSH
5045: LD_INT 2
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 70
5056: IFFALSE 5097
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5058: LD_ADDR_VAR 0 5
5062: PUSH
5063: LD_INT 21
5065: PPUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: PUSH
5081: FOR_IN
5082: IFFALSE 5095
// RemoveUnit ( i ) ;
5084: LD_VAR 0 5
5088: PPUSH
5089: CALL_OW 64
5093: GO 5081
5095: POP
5096: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5097: LD_INT 22
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 2
5109: PUSH
5110: LD_INT 21
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: LD_INT 2
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: NOT
5144: IFFALSE 4976
// end ;
5146: PPOPN 6
5148: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5149: LD_EXP 9
5153: PUSH
5154: LD_INT 92
5156: PPUSH
5157: LD_INT 40
5159: PPUSH
5160: CALL_OW 428
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 30
5172: EQUAL
5173: AND
5174: IFFALSE 5370
5176: GO 5178
5178: DISABLE
5179: LD_INT 0
5181: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: LD_EXP 58
5191: PUSH
5192: LD_INT 1
5194: ARRAY
5195: PPUSH
5196: LD_INT 25
5198: PUSH
5199: LD_INT 4
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// if not sci then
5211: LD_VAR 0 1
5215: NOT
5216: IFFALSE 5220
// exit ;
5218: GO 5370
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5220: LD_ADDR_EXP 58
5224: PUSH
5225: LD_EXP 58
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_EXP 58
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: DIFF
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5257: LD_VAR 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: PPUSH
5266: CALL_OW 310
5270: IFFALSE 5285
// ComExitBuilding ( sci [ 1 ] ) ;
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 105
5290: PPUSH
5291: LD_INT 14
5293: PPUSH
5294: LD_INT 20
5296: PPUSH
5297: CALL 21735 0 4
5301: PUSH
5302: LD_INT 4
5304: ARRAY
5305: PUSH
5306: LD_INT 10
5308: LESS
5309: IFFALSE 5332
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 105
5322: PPUSH
5323: LD_INT 14
5325: PPUSH
5326: CALL_OW 171
5330: GO 5351
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 118
5343: PPUSH
5344: LD_INT 77
5346: PPUSH
5347: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 1
5358: ARRAY
5359: PPUSH
5360: LD_INT 92
5362: PPUSH
5363: LD_INT 40
5365: PPUSH
5366: CALL_OW 218
// end ;
5370: PPOPN 1
5372: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5373: LD_INT 1
5375: PPUSH
5376: CALL_OW 302
5380: PUSH
5381: LD_EXP 9
5385: AND
5386: IFFALSE 5845
5388: GO 5390
5390: DISABLE
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
5395: PPUSH
5396: PPUSH
5397: PPUSH
5398: PPUSH
// begin enable ;
5399: ENABLE
// base := 1 ;
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5408: LD_ADDR_VAR 0 4
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: LD_INT 0
5418: PUSH
5419: LD_INT 0
5421: PUSH
5422: LD_INT 0
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: LD_INT 0
5430: PUSH
5431: LD_INT 0
5433: PUSH
5434: LD_INT 0
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: LD_INT 14
5462: PUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 2
5468: PUSH
5469: LD_INT 26
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_INT 14
5480: PUSH
5481: LD_INT 1
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 28
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 13
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: LD_INT 2
5504: PUSH
5505: LD_INT 29
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: LIST
5518: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: DOUBLE
5525: LD_INT 1
5527: DEC
5528: ST_TO_ADDR
5529: LD_OWVAR 67
5533: PUSH
5534: LD_OWVAR 1
5538: PUSH
5539: LD_INT 21000
5541: DIV
5542: PLUS
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5637
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5547: LD_ADDR_VAR 0 3
5551: PUSH
5552: LD_VAR 0 3
5556: PPUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_INT 1
5564: PLUS
5565: PPUSH
5566: LD_INT 13
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 2
5581: PPUSH
5582: CALL_OW 12
5586: ARRAY
5587: PUSH
5588: LD_INT 1
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 28
5596: PUSH
5597: LD_INT 29
5599: PUSH
5600: LD_INT 25
5602: PUSH
5603: LD_INT 26
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 4
5617: PPUSH
5618: CALL_OW 12
5622: ARRAY
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 2
5634: ST_TO_ADDR
5635: GO 5544
5637: POP
5638: POP
// MC_InsertProduceList ( base , tmp ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL 80347 0 2
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5660: LD_EXP 77
5664: PUSH
5665: LD_VAR 0 2
5669: ARRAY
5670: PUSH
5671: LD_INT 6
5673: GREATER
5674: IFFALSE 5653
// wait ( 0 0$20 ) ;
5676: LD_INT 700
5678: PPUSH
5679: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5683: LD_ADDR_VAR 0 5
5687: PUSH
5688: LD_INT 124
5690: PUSH
5691: LD_INT 85
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 90
5700: PUSH
5701: LD_INT 61
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 69
5710: PUSH
5711: LD_INT 48
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 68
5720: PUSH
5721: LD_INT 48
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5734: LD_ADDR_VAR 0 6
5738: PUSH
5739: LD_EXP 77
5743: PUSH
5744: LD_VAR 0 2
5748: ARRAY
5749: PUSH
5750: LD_EXP 77
5754: PUSH
5755: LD_VAR 0 2
5759: ARRAY
5760: PPUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: DIFF
5776: ST_TO_ADDR
// if not attackers then
5777: LD_VAR 0 6
5781: NOT
5782: IFFALSE 5786
// exit ;
5784: GO 5845
// ar_attackers := attackers ;
5786: LD_ADDR_EXP 10
5790: PUSH
5791: LD_VAR 0 6
5795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5803: LD_VAR 0 6
5807: PPUSH
5808: LD_INT 60
5810: PUSH
5811: EMPTY
5812: LIST
5813: PPUSH
5814: CALL_OW 72
5818: NOT
5819: IFFALSE 5796
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_VAR 0 5
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: CALL 80532 0 4
// end ;
5845: PPOPN 6
5847: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5848: LD_INT 1
5850: PPUSH
5851: CALL_OW 302
5855: PUSH
5856: LD_EXP 9
5860: AND
5861: PUSH
5862: LD_EXP 48
5866: PPUSH
5867: LD_INT 22
5869: PPUSH
5870: CALL_OW 308
5874: AND
5875: PUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 80695 0 1
5883: PUSH
5884: LD_INT 0
5886: EQUAL
5887: AND
5888: PUSH
5889: LD_EXP 10
5893: NOT
5894: AND
5895: IFFALSE 6359
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
// begin base := 1 ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5917: LD_ADDR_VAR 0 4
5921: PUSH
5922: LD_INT 0
5924: PUSH
5925: LD_INT 0
5927: PUSH
5928: LD_INT 0
5930: PUSH
5931: LD_INT 0
5933: PUSH
5934: LD_INT 0
5936: PUSH
5937: LD_INT 0
5939: PUSH
5940: LD_INT 0
5942: PUSH
5943: LD_INT 0
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 28
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 13
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 27
5998: PUSH
5999: EMPTY
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 1
6010: PUSH
6011: LD_INT 2
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 11
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 2
6031: PUSH
6032: LD_INT 24
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: LD_INT 11
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 24
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_VAR 0 3
6075: PPUSH
6076: CALL 80347 0 2
// repeat wait ( 0 0$1 ) ;
6080: LD_INT 35
6082: PPUSH
6083: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6087: LD_EXP 77
6091: PUSH
6092: LD_VAR 0 2
6096: ARRAY
6097: PUSH
6098: LD_INT 6
6100: GREATEREQUAL
6101: IFFALSE 6080
// wait ( 0 0$20 ) ;
6103: LD_INT 700
6105: PPUSH
6106: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6110: LD_ADDR_VAR 0 5
6114: PUSH
6115: LD_INT 119
6117: PUSH
6118: LD_INT 9
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: EMPTY
6126: LIST
6127: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6128: LD_ADDR_VAR 0 6
6132: PUSH
6133: LD_EXP 77
6137: PUSH
6138: LD_VAR 0 2
6142: ARRAY
6143: PUSH
6144: LD_EXP 77
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 34
6157: PUSH
6158: LD_INT 32
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 72
6169: DIFF
6170: ST_TO_ADDR
// if not attackers then
6171: LD_VAR 0 6
6175: NOT
6176: IFFALSE 6180
// exit ;
6178: GO 6359
// uc_side := 2 ;
6180: LD_ADDR_OWVAR 20
6184: PUSH
6185: LD_INT 2
6187: ST_TO_ADDR
// uc_nation := 2 ;
6188: LD_ADDR_OWVAR 21
6192: PUSH
6193: LD_INT 2
6195: ST_TO_ADDR
// InitHc ;
6196: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: DOUBLE
6206: LD_INT 1
6208: DEC
6209: ST_TO_ADDR
6210: LD_INT 4
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 6
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: LD_OWVAR 67
6228: ARRAY
6229: PUSH
6230: FOR_TO
6231: IFFALSE 6308
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6233: LD_INT 0
6235: PPUSH
6236: LD_INT 15
6238: PUSH
6239: LD_INT 17
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 2
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: PPUSH
6258: LD_INT 8
6260: PPUSH
6261: CALL_OW 380
// un := CreateHuman ;
6265: LD_ADDR_VAR 0 7
6269: PUSH
6270: CALL_OW 44
6274: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6275: LD_VAR 0 7
6279: PPUSH
6280: LD_INT 23
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: CALL_OW 49
// attackers := attackers union un ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_VAR 0 6
6299: PUSH
6300: LD_VAR 0 7
6304: UNION
6305: ST_TO_ADDR
// end ;
6306: GO 6230
6308: POP
6309: POP
// repeat wait ( 0 0$1 ) ;
6310: LD_INT 35
6312: PPUSH
6313: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6317: LD_VAR 0 6
6321: PPUSH
6322: LD_INT 60
6324: PUSH
6325: EMPTY
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: NOT
6333: IFFALSE 6310
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_VAR 0 6
6344: PPUSH
6345: LD_VAR 0 5
6349: PPUSH
6350: LD_VAR 0 4
6354: PPUSH
6355: CALL 80532 0 4
// end ; end_of_file
6359: PPOPN 7
6361: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6362: LD_INT 0
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// uc_side := 1 ;
6368: LD_ADDR_OWVAR 20
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// uc_nation := 1 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// InitHc ;
6384: CALL_OW 19
// InitVc ;
6388: CALL_OW 20
// tmp := [ ] ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: DOUBLE
6405: LD_INT 1
6407: DEC
6408: ST_TO_ADDR
6409: LD_INT 5
6411: PUSH
6412: LD_INT 6
6414: PUSH
6415: LD_INT 6
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_OWVAR 67
6427: ARRAY
6428: PUSH
6429: FOR_TO
6430: IFFALSE 6567
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6432: LD_INT 2
6434: PUSH
6435: LD_INT 4
6437: PUSH
6438: LD_INT 5
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: CALL_OW 12
6456: ARRAY
6457: PPUSH
6458: LD_INT 1
6460: PUSH
6461: LD_INT 3
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_INT 2
6473: PPUSH
6474: CALL_OW 12
6478: ARRAY
6479: PPUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 9
6485: PUSH
6486: LD_INT 7
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 2
6498: PPUSH
6499: CALL_OW 12
6503: ARRAY
6504: PPUSH
6505: LD_INT 78
6507: PPUSH
6508: CALL 20717 0 5
// veh := CreateVehicle ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: CALL_OW 45
6521: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 2
6529: PPUSH
6530: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6534: LD_VAR 0 4
6538: PPUSH
6539: LD_INT 17
6541: PPUSH
6542: LD_INT 0
6544: PPUSH
6545: CALL_OW 49
// tmp := tmp ^ veh ;
6549: LD_ADDR_VAR 0 3
6553: PUSH
6554: LD_VAR 0 3
6558: PUSH
6559: LD_VAR 0 4
6563: ADD
6564: ST_TO_ADDR
// end ;
6565: GO 6429
6567: POP
6568: POP
// if not tmp then
6569: LD_VAR 0 3
6573: NOT
6574: IFFALSE 6578
// exit ;
6576: GO 6687
// if not first_powell_attack then
6578: LD_EXP 11
6582: NOT
6583: IFFALSE 6593
// first_powell_attack := true ;
6585: LD_ADDR_EXP 11
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6593: LD_INT 70
6595: PPUSH
6596: CALL_OW 67
// for i in tmp do
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 3
6609: PUSH
6610: FOR_IN
6611: IFFALSE 6678
// if IsOk ( i ) then
6613: LD_VAR 0 2
6617: PPUSH
6618: CALL_OW 302
6622: IFFALSE 6660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 81
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PPUSH
6644: LD_VAR 0 2
6648: PPUSH
6649: CALL_OW 74
6653: PPUSH
6654: CALL_OW 115
6658: GO 6676
// tmp := tmp diff i ;
6660: LD_ADDR_VAR 0 3
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 2
6674: DIFF
6675: ST_TO_ADDR
6676: GO 6610
6678: POP
6679: POP
// until not tmp ;
6680: LD_VAR 0 3
6684: NOT
6685: IFFALSE 6593
// end ; end_of_file
6687: LD_VAR 0 1
6691: RET
// export function Action ; var tmp , i , un ; begin
6692: LD_INT 0
6694: PPUSH
6695: PPUSH
6696: PPUSH
6697: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6698: LD_INT 68
6700: PPUSH
6701: LD_INT 39
6703: PPUSH
6704: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// InGameOn ;
6728: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 71
6739: PPUSH
6740: LD_INT 49
6742: PPUSH
6743: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6747: LD_INT 35
6749: PPUSH
6750: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6754: LD_INT 7
6756: PPUSH
6757: LD_INT 71
6759: PPUSH
6760: LD_INT 51
6762: PPUSH
6763: CALL_OW 293
6767: IFFALSE 6747
// DialogueOn ;
6769: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6773: LD_EXP 14
6777: PPUSH
6778: LD_STRING D1-JMM-1
6780: PPUSH
6781: CALL_OW 88
// if Joan then
6785: LD_EXP 29
6789: IFFALSE 6803
// Say ( Joan , D1-Joan-1 ) ;
6791: LD_EXP 29
6795: PPUSH
6796: LD_STRING D1-Joan-1
6798: PPUSH
6799: CALL_OW 88
// if Lisa then
6803: LD_EXP 16
6807: IFFALSE 6821
// Say ( Lisa , D1-Lisa-1 ) ;
6809: LD_EXP 16
6813: PPUSH
6814: LD_STRING D1-Lisa-1
6816: PPUSH
6817: CALL_OW 88
// if Joan or Lisa then
6821: LD_EXP 29
6825: PUSH
6826: LD_EXP 16
6830: OR
6831: IFFALSE 6845
// Say ( JMM , D1-JMM-2 ) ;
6833: LD_EXP 14
6837: PPUSH
6838: LD_STRING D1-JMM-2
6840: PPUSH
6841: CALL_OW 88
// DialogueOff ;
6845: CALL_OW 7
// InGameOff ;
6849: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6853: LD_INT 71
6855: PPUSH
6856: LD_INT 50
6858: PPUSH
6859: LD_INT 7
6861: PPUSH
6862: LD_INT 30
6864: NEG
6865: PPUSH
6866: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6870: LD_INT 71
6872: PPUSH
6873: LD_INT 50
6875: PPUSH
6876: LD_INT 7
6878: PPUSH
6879: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6883: LD_STRING M1
6885: PPUSH
6886: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6890: LD_INT 35
6892: PPUSH
6893: CALL_OW 67
// until freedom ;
6897: LD_EXP 3
6901: IFFALSE 6890
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6903: LD_INT 350
6905: PPUSH
6906: LD_INT 700
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// PrepareGossudarov ;
6918: CALL 1710 0 0
// repeat wait ( 0 0$1 ) ;
6922: LD_INT 35
6924: PPUSH
6925: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6929: LD_INT 22
6931: PUSH
6932: LD_INT 6
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 3
6941: PUSH
6942: LD_INT 24
6944: PUSH
6945: LD_INT 1000
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 69
6964: PUSH
6965: LD_INT 7
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 292
6977: OR
6978: IFFALSE 6922
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// for i in tmp do
7000: LD_ADDR_VAR 0 3
7004: PUSH
7005: LD_VAR 0 2
7009: PUSH
7010: FOR_IN
7011: IFFALSE 7027
// SetSide ( i , 7 ) ;
7013: LD_VAR 0 3
7017: PPUSH
7018: LD_INT 7
7020: PPUSH
7021: CALL_OW 235
7025: GO 7010
7027: POP
7028: POP
// DialogueOn ;
7029: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7033: LD_EXP 14
7037: PUSH
7038: LD_EXP 15
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_EXP 31
7051: PPUSH
7052: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7056: LD_EXP 31
7060: PPUSH
7061: CALL_OW 87
// if not Roth then
7065: LD_EXP 15
7069: NOT
7070: IFFALSE 7162
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7072: LD_VAR 0 2
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 24
7082: PUSH
7083: LD_INT 1000
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: IFFALSE 7112
// Say ( JMM , D2-JMM-1 ) ;
7100: LD_EXP 14
7104: PPUSH
7105: LD_STRING D2-JMM-1
7107: PPUSH
7108: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7112: LD_EXP 14
7116: PPUSH
7117: LD_STRING D2-JMM-1b
7119: PPUSH
7120: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7124: LD_EXP 31
7128: PPUSH
7129: LD_STRING D2-Gos-1
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-2
7143: PPUSH
7144: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7148: LD_EXP 31
7152: PPUSH
7153: LD_STRING D2-Gos-2
7155: PPUSH
7156: CALL_OW 88
// end else
7160: GO 7314
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7162: LD_VAR 0 2
7166: PPUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 24
7172: PUSH
7173: LD_INT 1000
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL_OW 72
7188: IFFALSE 7214
// begin Say ( Roth , D2-Roth-2 ) ;
7190: LD_EXP 15
7194: PPUSH
7195: LD_STRING D2-Roth-2
7197: PPUSH
7198: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7202: LD_EXP 14
7206: PPUSH
7207: LD_STRING D2-JMM-1a
7209: PPUSH
7210: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7214: LD_EXP 15
7218: PPUSH
7219: LD_STRING D2-Roth-2a
7221: PPUSH
7222: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7226: LD_EXP 15
7230: PPUSH
7231: LD_STRING D2-Roth-2b
7233: PPUSH
7234: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7238: LD_EXP 14
7242: PPUSH
7243: LD_STRING D2-JMM-3
7245: PPUSH
7246: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 3
7257: PUSH
7258: LD_INT 24
7260: PUSH
7261: LD_INT 1000
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 72
7276: IFFALSE 7314
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7278: LD_EXP 31
7282: PPUSH
7283: LD_STRING D2-Gos-3
7285: PPUSH
7286: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7290: LD_EXP 14
7294: PPUSH
7295: LD_STRING D2-JMM-4
7297: PPUSH
7298: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7302: LD_EXP 31
7306: PPUSH
7307: LD_STRING D2-Gos-4
7309: PPUSH
7310: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7314: LD_EXP 14
7318: PPUSH
7319: LD_STRING D2-JMM-5
7321: PPUSH
7322: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7326: LD_EXP 31
7330: PPUSH
7331: LD_STRING D2-Gos-5
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7338: LD_EXP 14
7342: PPUSH
7343: LD_STRING D2-JMM-6
7345: PPUSH
7346: CALL_OW 88
// DialogueOff ;
7350: CALL_OW 7
// wait ( 0 0$2 ) ;
7354: LD_INT 70
7356: PPUSH
7357: CALL_OW 67
// if Kirilenkova then
7361: LD_EXP 32
7365: IFFALSE 7379
// Say ( Kirilenkova , D3-Kir-1 ) ;
7367: LD_EXP 32
7371: PPUSH
7372: LD_STRING D3-Kir-1
7374: PPUSH
7375: CALL_OW 88
// gossudarov_arrive := true ;
7379: LD_ADDR_EXP 4
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7387: LD_STRING CombinedForces
7389: PPUSH
7390: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until ru_lab_builded ;
7401: LD_EXP 5
7405: IFFALSE 7394
// if Kirilenkova then
7407: LD_EXP 32
7411: IFFALSE 7427
// Say ( Kirilenkova , D3a-Kir-1 ) else
7413: LD_EXP 32
7417: PPUSH
7418: LD_STRING D3a-Kir-1
7420: PPUSH
7421: CALL_OW 88
7425: GO 7449
// begin un := SciRu ;
7427: LD_ADDR_VAR 0 4
7431: PUSH
7432: CALL 12437 0 0
7436: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7437: LD_VAR 0 4
7441: PPUSH
7442: LD_STRING D3a-Sci1-1
7444: PPUSH
7445: CALL_OW 88
// end ; if Kirilenkova or un then
7449: LD_EXP 32
7453: PUSH
7454: LD_VAR 0 4
7458: OR
7459: IFFALSE 7473
// Say ( JMM , D3a-JMM-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-JMM-1
7468: PPUSH
7469: CALL_OW 88
// end ;
7473: LD_VAR 0 1
7477: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7478: LD_EXP 4
7482: PUSH
7483: LD_INT 22
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: LD_INT 25
7498: PUSH
7499: LD_INT 1
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 25
7508: PUSH
7509: LD_INT 2
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 25
7518: PUSH
7519: LD_INT 3
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 25
7538: PUSH
7539: LD_INT 5
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 25
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 9
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 69
7584: PUSH
7585: LD_INT 7
7587: LESS
7588: AND
7589: IFFALSE 7601
7591: GO 7593
7593: DISABLE
// YouLost ( TooMany ) ;
7594: LD_STRING TooMany
7596: PPUSH
7597: CALL_OW 104
7601: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7602: LD_EXP 31
7606: PPUSH
7607: CALL_OW 255
7611: PUSH
7612: LD_INT 7
7614: EQUAL
7615: IFFALSE 7815
7617: GO 7619
7619: DISABLE
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
// begin uc_side := 3 ;
7625: LD_ADDR_OWVAR 20
7629: PUSH
7630: LD_INT 3
7632: ST_TO_ADDR
// uc_nation := 3 ;
7633: LD_ADDR_OWVAR 21
7637: PUSH
7638: LD_INT 3
7640: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7641: LD_INT 21
7643: PPUSH
7644: LD_INT 3
7646: PPUSH
7647: LD_INT 3
7649: PPUSH
7650: LD_INT 42
7652: PPUSH
7653: LD_INT 100
7655: PPUSH
7656: CALL 20717 0 5
// un := CreateVehicle ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: CALL_OW 45
7669: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 15
7677: PPUSH
7678: LD_INT 0
7680: PPUSH
7681: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_INT 67
7692: PPUSH
7693: LD_INT 45
7695: PPUSH
7696: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_INT 70
7707: PPUSH
7708: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7712: LD_VAR 0 3
7716: PPUSH
7717: LD_INT 69
7719: PPUSH
7720: LD_INT 18
7722: PPUSH
7723: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7727: LD_VAR 0 3
7731: PPUSH
7732: LD_INT 60
7734: PPUSH
7735: LD_INT 2
7737: PPUSH
7738: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7749: LD_VAR 0 3
7753: PPUSH
7754: CALL_OW 302
7758: NOT
7759: PUSH
7760: LD_VAR 0 3
7764: PPUSH
7765: LD_INT 17
7767: PPUSH
7768: CALL_OW 308
7772: OR
7773: IFFALSE 7742
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7775: LD_VAR 0 3
7779: PPUSH
7780: LD_INT 17
7782: PPUSH
7783: CALL_OW 308
7787: PUSH
7788: LD_VAR 0 3
7792: PPUSH
7793: LD_INT 60
7795: PPUSH
7796: LD_INT 2
7798: PPUSH
7799: CALL_OW 307
7803: OR
7804: IFFALSE 7815
// RemoveUnit ( un ) ;
7806: LD_VAR 0 3
7810: PPUSH
7811: CALL_OW 64
// end ;
7815: PPOPN 3
7817: END
// every 0 0$2 do var i , un , tmp ;
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7826: LD_INT 70
7828: PPUSH
7829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 22
7840: PUSH
7841: LD_INT 7
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 101
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 69
7866: ST_TO_ADDR
// until tmp ;
7867: LD_VAR 0 3
7871: IFFALSE 7826
// un := NearestUnitToUnit ( tmp , JMM ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_VAR 0 3
7882: PPUSH
7883: LD_EXP 14
7887: PPUSH
7888: CALL_OW 74
7892: ST_TO_ADDR
// player_spotted := true ;
7893: LD_ADDR_EXP 6
7897: PUSH
7898: LD_INT 1
7900: ST_TO_ADDR
// tmp := SciRu ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: CALL 12437 0 0
7910: ST_TO_ADDR
// if not tmp then
7911: LD_VAR 0 3
7915: NOT
7916: IFFALSE 7928
// tmp := SolRu ;
7918: LD_ADDR_VAR 0 3
7922: PUSH
7923: CALL 12584 0 0
7927: ST_TO_ADDR
// DialogueOn ;
7928: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 250
7941: PPUSH
7942: LD_VAR 0 2
7946: PPUSH
7947: CALL_OW 251
7951: PPUSH
7952: LD_INT 7
7954: PPUSH
7955: LD_INT 8
7957: NEG
7958: PPUSH
7959: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7963: LD_VAR 0 2
7967: PPUSH
7968: CALL_OW 87
// if tmp then
7972: LD_VAR 0 3
7976: IFFALSE 7990
// Say ( tmp , D4-RSci1-1 ) ;
7978: LD_VAR 0 3
7982: PPUSH
7983: LD_STRING D4-RSci1-1
7985: PPUSH
7986: CALL_OW 88
// if Gossudarov then
7990: LD_EXP 31
7994: IFFALSE 8020
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7996: LD_EXP 31
8000: PPUSH
8001: LD_STRING D4-Gos-1
8003: PPUSH
8004: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8008: LD_EXP 14
8012: PPUSH
8013: LD_STRING D4-JMM-1
8015: PPUSH
8016: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8020: LD_VAR 0 2
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_VAR 0 2
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 331
// DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8051: LD_STRING M5
8053: PPUSH
8054: CALL_OW 337
// end ;
8058: PPOPN 3
8060: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8061: LD_EXP 6
8065: IFFALSE 8654
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// begin PrepareBelkov ;
8075: CALL 2000 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8079: LD_EXP 46
8083: PPUSH
8084: LD_INT 118
8086: PPUSH
8087: LD_INT 106
8089: PPUSH
8090: CALL_OW 111
// AddComHold ( Belkov ) ;
8094: LD_EXP 46
8098: PPUSH
8099: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8103: LD_INT 35
8105: PPUSH
8106: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8110: LD_EXP 46
8114: PPUSH
8115: LD_INT 118
8117: PPUSH
8118: LD_INT 106
8120: PPUSH
8121: CALL_OW 307
8125: IFFALSE 8103
// ChangeSideFog ( 4 , 7 ) ;
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 7
8132: PPUSH
8133: CALL_OW 343
// if IsOk ( Belkov ) then
8137: LD_EXP 46
8141: PPUSH
8142: CALL_OW 302
8146: IFFALSE 8230
// begin InGameOn ;
8148: CALL_OW 8
// DialogueOn ;
8152: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8156: LD_EXP 46
8160: PPUSH
8161: LD_STRING D5-Bel-1
8163: PPUSH
8164: CALL_OW 94
// if Gossudarov then
8168: LD_EXP 31
8172: IFFALSE 8222
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8174: LD_EXP 31
8178: PPUSH
8179: LD_STRING D5-Gos-1
8181: PPUSH
8182: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8186: LD_EXP 14
8190: PPUSH
8191: LD_STRING D5-JMM-1
8193: PPUSH
8194: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8198: LD_EXP 31
8202: PPUSH
8203: LD_STRING D5-Gos-2
8205: PPUSH
8206: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8210: LD_EXP 14
8214: PPUSH
8215: LD_STRING D5-JMM-2
8217: PPUSH
8218: CALL_OW 88
// end ; DialogueOff ;
8222: CALL_OW 7
// InGameOff ;
8226: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8230: LD_STRING QSaveBelkov
8232: PPUSH
8233: CALL_OW 97
8237: PUSH
8238: LD_INT 1
8240: DOUBLE
8241: EQUAL
8242: IFTRUE 8246
8244: GO 8296
8246: POP
// begin DialogueOn ;
8247: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D5a-JMM-1
8258: PPUSH
8259: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8263: LD_EXP 46
8267: PPUSH
8268: LD_STRING D5a-Bel-1
8270: PPUSH
8271: CALL_OW 94
// DialogueOff ;
8275: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 83
8286: PPUSH
8287: LD_INT 49
8289: PPUSH
8290: CALL_OW 111
// end ; 2 :
8294: GO 8329
8296: LD_INT 2
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8328
8304: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8305: LD_EXP 14
8309: PPUSH
8310: LD_STRING D5a-JMM-2
8312: PPUSH
8313: CALL_OW 88
// ComHold ( Belkov ) ;
8317: LD_EXP 46
8321: PPUSH
8322: CALL_OW 140
// end ; end ;
8326: GO 8329
8328: POP
// time := 0 0$00 ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 0
8336: ST_TO_ADDR
// vehSpawned := false ;
8337: LD_ADDR_VAR 0 3
8341: PUSH
8342: LD_INT 0
8344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8345: LD_INT 35
8347: PPUSH
8348: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 350
8359: PUSH
8360: LD_INT 175
8362: PUSH
8363: LD_INT 70
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: LIST
8370: PUSH
8371: LD_OWVAR 67
8375: ARRAY
8376: GREATEREQUAL
8377: PUSH
8378: LD_VAR 0 3
8382: NOT
8383: AND
8384: IFFALSE 8474
// begin vehSpawned := true ;
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// uc_side := 3 ;
8394: LD_ADDR_OWVAR 20
8398: PUSH
8399: LD_INT 3
8401: ST_TO_ADDR
// uc_nation := 3 ;
8402: LD_ADDR_OWVAR 21
8406: PUSH
8407: LD_INT 3
8409: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8410: LD_INT 22
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 43
8421: PPUSH
8422: LD_INT 100
8424: PPUSH
8425: CALL 20717 0 5
// veh := CreateVehicle ;
8429: LD_ADDR_VAR 0 2
8433: PUSH
8434: CALL_OW 45
8438: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8439: LD_VAR 0 2
8443: PPUSH
8444: LD_INT 130
8446: PPUSH
8447: LD_INT 131
8449: PPUSH
8450: LD_INT 0
8452: PPUSH
8453: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8457: LD_VAR 0 2
8461: PPUSH
8462: LD_INT 100
8464: PPUSH
8465: LD_INT 82
8467: PPUSH
8468: CALL_OW 114
// end else
8472: GO 8488
// time := time + 0 0$1 ;
8474: LD_ADDR_VAR 0 1
8478: PUSH
8479: LD_VAR 0 1
8483: PUSH
8484: LD_INT 35
8486: PLUS
8487: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8488: LD_EXP 46
8492: PPUSH
8493: CALL_OW 301
8497: PUSH
8498: LD_EXP 46
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 4
8510: EQUAL
8511: AND
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_INT 7
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: PPUSH
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 74
8537: PPUSH
8538: LD_EXP 46
8542: PPUSH
8543: CALL_OW 296
8547: PUSH
8548: LD_INT 10
8550: LESS
8551: OR
8552: IFFALSE 8345
// if IsDead ( Belkov ) then
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: IFFALSE 8588
// begin CenterNowOnUnits ( Belkov ) ;
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8574: LD_EXP 14
8578: PPUSH
8579: LD_STRING D5a-JMM-2a
8581: PPUSH
8582: CALL_OW 88
// exit ;
8586: GO 8654
// end ; if See ( 7 , Belkov ) then
8588: LD_INT 7
8590: PPUSH
8591: LD_EXP 46
8595: PPUSH
8596: CALL_OW 292
8600: IFFALSE 8614
// SetSide ( Belkov , 7 ) ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 7
8609: PPUSH
8610: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8614: LD_INT 35
8616: PPUSH
8617: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8621: LD_EXP 46
8625: PPUSH
8626: LD_INT 66
8628: PPUSH
8629: LD_INT 45
8631: PPUSH
8632: CALL_OW 297
8636: PUSH
8637: LD_INT 30
8639: LESS
8640: IFFALSE 8614
// Say ( Belkov , D6-Bel-1 ) ;
8642: LD_EXP 46
8646: PPUSH
8647: LD_STRING D6-Bel-1
8649: PPUSH
8650: CALL_OW 88
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 302
8666: PUSH
8667: LD_EXP 46
8671: PPUSH
8672: CALL_OW 504
8676: PUSH
8677: LD_INT 2
8679: PUSH
8680: LD_INT 34
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 34
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: PPUSH
8705: CALL_OW 69
8709: IN
8710: AND
8711: IFFALSE 8728
8713: GO 8715
8715: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8716: LD_EXP 46
8720: PPUSH
8721: LD_STRING D7-Bel-1
8723: PPUSH
8724: CALL_OW 88
8728: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8729: LD_INT 22
8731: PUSH
8732: LD_INT 7
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: LD_INT 101
8741: PUSH
8742: LD_INT 2
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PPUSH
8753: CALL_OW 69
8757: PUSH
8758: LD_EXP 8
8762: NOT
8763: AND
8764: PUSH
8765: LD_EXP 45
8769: PPUSH
8770: CALL_OW 305
8774: NOT
8775: AND
8776: IFFALSE 9246
8778: GO 8780
8780: DISABLE
8781: LD_INT 0
8783: PPUSH
// begin ar_base_spotted := true ;
8784: LD_ADDR_EXP 8
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 2
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_EXP 14
8840: PPUSH
8841: CALL_OW 74
8845: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8846: LD_INT 7
8848: PPUSH
8849: LD_INT 3
8851: PPUSH
8852: CALL_OW 332
// DialogueOn ;
8856: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8860: LD_VAR 0 1
8864: PPUSH
8865: CALL_OW 250
8869: PPUSH
8870: LD_VAR 0 1
8874: PPUSH
8875: CALL_OW 251
8879: PPUSH
8880: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8884: LD_ADDR_VAR 0 1
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 23
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: LD_INT 26
8911: PUSH
8912: LD_INT 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: PUSH
8929: LD_EXP 14
8933: PUSH
8934: LD_EXP 18
8938: PUSH
8939: LD_EXP 19
8943: PUSH
8944: LD_EXP 26
8948: PUSH
8949: LD_EXP 15
8953: PUSH
8954: LD_EXP 24
8958: PUSH
8959: LD_EXP 20
8963: PUSH
8964: LD_EXP 22
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: DIFF
8979: ST_TO_ADDR
// if not tmp then
8980: LD_VAR 0 1
8984: NOT
8985: IFFALSE 9059
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 22
8994: PUSH
8995: LD_INT 7
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: LD_INT 23
9004: PUSH
9005: LD_INT 1
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 2
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: PUSH
9032: LD_EXP 29
9036: PUSH
9037: LD_EXP 16
9041: PUSH
9042: LD_EXP 27
9046: PUSH
9047: LD_EXP 28
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: DIFF
9058: ST_TO_ADDR
// if tmp then
9059: LD_VAR 0 1
9063: IFFALSE 9134
// case GetSex ( tmp [ 1 ] ) of sex_male :
9065: LD_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ARRAY
9073: PPUSH
9074: CALL_OW 258
9078: PUSH
9079: LD_INT 1
9081: DOUBLE
9082: EQUAL
9083: IFTRUE 9087
9085: GO 9106
9087: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9088: LD_VAR 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D9-Sol1-1
9099: PPUSH
9100: CALL_OW 88
9104: GO 9134
9106: LD_INT 2
9108: DOUBLE
9109: EQUAL
9110: IFTRUE 9114
9112: GO 9133
9114: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 1
9122: ARRAY
9123: PPUSH
9124: LD_STRING D9-FSol1-1
9126: PPUSH
9127: CALL_OW 88
9131: GO 9134
9133: POP
// if Frank then
9134: LD_EXP 26
9138: IFFALSE 9242
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9140: LD_EXP 55
9144: PPUSH
9145: CALL_OW 250
9149: PPUSH
9150: LD_EXP 55
9154: PPUSH
9155: CALL_OW 251
9159: PPUSH
9160: LD_INT 7
9162: PPUSH
9163: LD_INT 8
9165: PPUSH
9166: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9170: LD_EXP 55
9174: PPUSH
9175: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9179: LD_EXP 26
9183: PPUSH
9184: LD_STRING D9-Frank-1
9186: PPUSH
9187: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D9-JMM-1
9198: PPUSH
9199: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9203: LD_EXP 26
9207: PPUSH
9208: LD_STRING D9-Frank-2
9210: PPUSH
9211: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9215: LD_EXP 55
9219: PPUSH
9220: CALL_OW 250
9224: PPUSH
9225: LD_EXP 55
9229: PPUSH
9230: CALL_OW 251
9234: PPUSH
9235: LD_INT 7
9237: PPUSH
9238: CALL_OW 331
// end ; DialogueOff ;
9242: CALL_OW 7
// end ;
9246: PPOPN 1
9248: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9249: LD_EXP 7
9253: PUSH
9254: LD_OWVAR 1
9258: PUSH
9259: LD_INT 42000
9261: GREATEREQUAL
9262: OR
9263: IFFALSE 10290
9265: GO 9267
9267: DISABLE
9268: LD_INT 0
9270: PPUSH
9271: PPUSH
// begin selected_option := 1 ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9280: LD_INT 10500
9282: PPUSH
9283: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9287: LD_INT 35
9289: PPUSH
9290: CALL_OW 67
// until not ru_attackers ;
9294: LD_EXP 51
9298: NOT
9299: IFFALSE 9287
// PrepareBurlak ;
9301: CALL 2112 0 0
// repeat wait ( 0 0$2 ) ;
9305: LD_INT 70
9307: PPUSH
9308: CALL_OW 67
// until not HasTask ( Burlak ) ;
9312: LD_EXP 45
9316: PPUSH
9317: CALL_OW 314
9321: NOT
9322: IFFALSE 9305
// InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9332: LD_EXP 48
9336: PPUSH
9337: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D10-Bur-1
9348: PPUSH
9349: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9353: LD_EXP 46
9357: PUSH
9358: LD_EXP 46
9362: PPUSH
9363: CALL_OW 255
9367: PUSH
9368: LD_INT 7
9370: EQUAL
9371: AND
9372: IFFALSE 9386
// Say ( Belkov , D10-Bel-1 ) ;
9374: LD_EXP 46
9378: PPUSH
9379: LD_STRING D10-Bel-1
9381: PPUSH
9382: CALL_OW 88
// if Gossudarov then
9386: LD_EXP 31
9390: IFFALSE 9404
// Say ( Gossudarov , D10-Gos-1 ) ;
9392: LD_EXP 31
9396: PPUSH
9397: LD_STRING D10-Gos-1
9399: PPUSH
9400: CALL_OW 88
// if Kirilenkova then
9404: LD_EXP 32
9408: IFFALSE 9422
// Say ( Kirilenkova , D10-Kir-1 ) ;
9410: LD_EXP 32
9414: PPUSH
9415: LD_STRING D10-Kir-1
9417: PPUSH
9418: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9422: CALL 12584 0 0
9426: PPUSH
9427: LD_STRING D10-RSol1-1
9429: PPUSH
9430: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D10-Bur-2
9441: PPUSH
9442: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9446: LD_EXP 14
9450: PPUSH
9451: LD_STRING D10-JMM-2
9453: PPUSH
9454: CALL_OW 88
// if Kirilenkova then
9458: LD_EXP 32
9462: IFFALSE 9478
// Say ( Kirilenkova , D10-Kir-2 ) else
9464: LD_EXP 32
9468: PPUSH
9469: LD_STRING D10-Kir-2
9471: PPUSH
9472: CALL_OW 88
9476: GO 9490
// Say ( SolRu , D10-RSol1-2 ) ;
9478: CALL 12584 0 0
9482: PPUSH
9483: LD_STRING D10-RSol1-2
9485: PPUSH
9486: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9490: LD_EXP 14
9494: PPUSH
9495: LD_STRING D10-JMM-3
9497: PPUSH
9498: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9502: LD_EXP 45
9506: PPUSH
9507: LD_STRING D10-Bur-3
9509: PPUSH
9510: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9514: LD_EXP 14
9518: PPUSH
9519: LD_STRING D10-JMM-4
9521: PPUSH
9522: CALL_OW 88
// DialogueOff ;
9526: CALL_OW 7
// InGameOff ;
9530: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9534: LD_STRING M2
9536: PPUSH
9537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9548: LD_INT 22
9550: PUSH
9551: LD_INT 7
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 91
9560: PUSH
9561: LD_EXP 45
9565: PUSH
9566: LD_INT 8
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PPUSH
9578: CALL_OW 69
9582: IFFALSE 9541
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_INT 22
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PUSH
9604: FOR_IN
9605: IFFALSE 9621
// SetSide ( i , 7 ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 7
9614: PPUSH
9615: CALL_OW 235
9619: GO 9604
9621: POP
9622: POP
// ChangeMissionObjectives ( M3 ) ;
9623: LD_STRING M3
9625: PPUSH
9626: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9637: LD_EXP 14
9641: PPUSH
9642: LD_EXP 45
9646: PPUSH
9647: CALL_OW 296
9651: PUSH
9652: LD_INT 8
9654: LESS
9655: IFFALSE 9630
// ComTurnUnit ( JMM , Burlak ) ;
9657: LD_EXP 14
9661: PPUSH
9662: LD_EXP 45
9666: PPUSH
9667: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9671: LD_EXP 45
9675: PPUSH
9676: LD_EXP 14
9680: PPUSH
9681: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9685: LD_INT 10
9687: PPUSH
9688: CALL_OW 67
// DialogueOn ;
9692: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9696: LD_EXP 14
9700: PPUSH
9701: LD_STRING D11-JMM-1
9703: PPUSH
9704: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9708: LD_EXP 45
9712: PPUSH
9713: LD_STRING D11-Bur-1
9715: PPUSH
9716: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9720: LD_EXP 14
9724: PPUSH
9725: LD_STRING D11-JMM-2
9727: PPUSH
9728: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9732: LD_EXP 45
9736: PPUSH
9737: LD_STRING D11-Bur-2
9739: PPUSH
9740: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9744: LD_EXP 14
9748: PPUSH
9749: LD_STRING D11-JMM-3
9751: PPUSH
9752: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9756: LD_EXP 45
9760: PPUSH
9761: LD_STRING D11-Bur-3
9763: PPUSH
9764: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9768: LD_EXP 14
9772: PPUSH
9773: LD_STRING D11-JMM-4
9775: PPUSH
9776: CALL_OW 88
// if ar_base_spotted then
9780: LD_EXP 8
9784: IFFALSE 9800
// Say ( Burlak , D12-Bur-1 ) else
9786: LD_EXP 45
9790: PPUSH
9791: LD_STRING D12-Bur-1
9793: PPUSH
9794: CALL_OW 88
9798: GO 9839
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9800: LD_INT 7
9802: PPUSH
9803: LD_INT 3
9805: PPUSH
9806: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9810: LD_INT 127
9812: PPUSH
9813: LD_INT 45
9815: PPUSH
9816: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1a
9827: PPUSH
9828: CALL_OW 88
// dwait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9839: LD_EXP 45
9843: PPUSH
9844: LD_STRING D12-Bur-1b
9846: PPUSH
9847: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9851: LD_EXP 14
9855: PPUSH
9856: LD_STRING D12-JMM-1
9858: PPUSH
9859: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9863: LD_EXP 45
9867: PPUSH
9868: LD_STRING D12-Bur-2
9870: PPUSH
9871: CALL_OW 88
// if Roth then
9875: LD_EXP 15
9879: IFFALSE 9895
// Say ( Roth , D12-Roth-2 ) else
9881: LD_EXP 15
9885: PPUSH
9886: LD_STRING D12-Roth-2
9888: PPUSH
9889: CALL_OW 88
9893: GO 9907
// Say ( SciRu , D12-RSci1-2 ) ;
9895: CALL 12437 0 0
9899: PPUSH
9900: LD_STRING D12-RSci1-2
9902: PPUSH
9903: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9907: LD_EXP 14
9911: PPUSH
9912: LD_STRING D12-JMM-2
9914: PPUSH
9915: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9919: LD_EXP 45
9923: PPUSH
9924: LD_STRING D12-Bur-3
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9931: LD_EXP 14
9935: PPUSH
9936: LD_STRING D12-JMM-3
9938: PPUSH
9939: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D12-Bur-4
9950: PPUSH
9951: CALL_OW 88
// case Query ( QBase ) of 1 :
9955: LD_STRING QBase
9957: PPUSH
9958: CALL_OW 97
9962: PUSH
9963: LD_INT 1
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10089
9971: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9972: LD_EXP 14
9976: PPUSH
9977: LD_STRING D13a-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9984: LD_EXP 45
9988: PPUSH
9989: LD_STRING D13a-Bur-1
9991: PPUSH
9992: CALL_OW 88
// if Roth then
9996: LD_EXP 15
10000: IFFALSE 10016
// Say ( Roth , D13a-Roth-1 ) else
10002: LD_EXP 15
10006: PPUSH
10007: LD_STRING D13a-Roth-1
10009: PPUSH
10010: CALL_OW 88
10014: GO 10028
// Say ( SciRu , D13a-RSci1-1 ) ;
10016: CALL 12437 0 0
10020: PPUSH
10021: LD_STRING D13a-RSci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10028: LD_EXP 14
10032: PPUSH
10033: LD_STRING D13a-JMM-2
10035: PPUSH
10036: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10040: LD_STRING QBaseAgain
10042: PPUSH
10043: CALL_OW 97
10047: PUSH
10048: LD_INT 1
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 2 ; 2 :
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
10065: GO 10087
10067: LD_INT 2
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10086
10075: POP
// selected_option := 3 ; end ;
10076: LD_ADDR_VAR 0 2
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
10084: GO 10087
10086: POP
// end ; 2 :
10087: GO 10128
10089: LD_INT 2
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 2 ; 3 :
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 2
10105: ST_TO_ADDR
10106: GO 10128
10108: LD_INT 3
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10127
10116: POP
// selected_option := 3 ; end ;
10117: LD_ADDR_VAR 0 2
10121: PUSH
10122: LD_INT 3
10124: ST_TO_ADDR
10125: GO 10128
10127: POP
// if selected_option = 2 then
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10230
// begin Say ( JMM , D13b-JMM-1 ) ;
10138: LD_EXP 14
10142: PPUSH
10143: LD_STRING D13b-JMM-1
10145: PPUSH
10146: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10150: LD_EXP 45
10154: PPUSH
10155: LD_STRING D13b-Bur-1
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10162: LD_EXP 14
10166: PPUSH
10167: LD_STRING D13b-JMM-2
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10174: LD_EXP 54
10178: PPUSH
10179: LD_STRING D13b-Abd-2
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10186: LD_EXP 14
10190: PPUSH
10191: LD_STRING D13b-JMM-3
10193: PPUSH
10194: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10198: LD_EXP 54
10202: PPUSH
10203: LD_STRING D13b-Abd-3
10205: PPUSH
10206: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10210: LD_EXP 14
10214: PPUSH
10215: LD_STRING D13b-JMM-4
10217: PPUSH
10218: CALL_OW 88
// ar_active_attack := true ;
10222: LD_ADDR_EXP 9
10226: PUSH
10227: LD_INT 1
10229: ST_TO_ADDR
// end ; if selected_option = 3 then
10230: LD_VAR 0 2
10234: PUSH
10235: LD_INT 3
10237: EQUAL
10238: IFFALSE 10264
// begin Say ( JMM , D13c-JMM-1 ) ;
10240: LD_EXP 14
10244: PPUSH
10245: LD_STRING D13c-JMM-1
10247: PPUSH
10248: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10252: LD_EXP 45
10256: PPUSH
10257: LD_STRING D13c-Bur-1
10259: PPUSH
10260: CALL_OW 88
// end ; DialogueOff ;
10264: CALL_OW 7
// if not ar_active_attack then
10268: LD_EXP 9
10272: NOT
10273: IFFALSE 10290
// begin wait ( 6 6$00 ) ;
10275: LD_INT 12600
10277: PPUSH
10278: CALL_OW 67
// ar_active_attack := true ;
10282: LD_ADDR_EXP 9
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// end ; end ;
10290: PPOPN 2
10292: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10293: LD_EXP 45
10297: PPUSH
10298: CALL_OW 305
10302: PUSH
10303: LD_EXP 45
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: AND
10317: IFFALSE 10513
10319: GO 10321
10321: DISABLE
10322: LD_INT 0
10324: PPUSH
// begin wait ( 4 4$40 ) ;
10325: LD_INT 9800
10327: PPUSH
10328: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// until not ru_attackers ;
10339: LD_EXP 51
10343: NOT
10344: IFFALSE 10332
// PrepareGnyevko ;
10346: CALL 2056 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10350: LD_EXP 47
10354: PPUSH
10355: LD_INT 124
10357: PPUSH
10358: LD_INT 118
10360: PPUSH
10361: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10365: LD_EXP 47
10369: PPUSH
10370: CALL_OW 200
// time := 0 0$00 ;
10374: LD_ADDR_VAR 0 1
10378: PUSH
10379: LD_INT 0
10381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10382: LD_INT 35
10384: PPUSH
10385: CALL_OW 67
// time := time + 0 0$1 ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_VAR 0 1
10398: PUSH
10399: LD_INT 35
10401: PLUS
10402: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10403: LD_EXP 47
10407: PPUSH
10408: LD_INT 124
10410: PPUSH
10411: LD_INT 118
10413: PPUSH
10414: CALL_OW 307
10418: PUSH
10419: LD_VAR 0 1
10423: PUSH
10424: LD_INT 1050
10426: GREATEREQUAL
10427: OR
10428: IFFALSE 10382
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10430: LD_EXP 47
10434: PPUSH
10435: LD_STRING DBelkov-Gny-1
10437: PPUSH
10438: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10442: LD_EXP 45
10446: PPUSH
10447: LD_STRING DBelkov-Bur-1a
10449: PPUSH
10450: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10461: LD_EXP 47
10465: PPUSH
10466: LD_INT 22
10468: PUSH
10469: LD_INT 7
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PPUSH
10476: CALL_OW 69
10480: PPUSH
10481: LD_EXP 47
10485: PPUSH
10486: CALL_OW 74
10490: PPUSH
10491: CALL_OW 296
10495: PUSH
10496: LD_INT 8
10498: LESS
10499: IFFALSE 10454
// SetSide ( Gnyevko , 7 ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_INT 7
10508: PPUSH
10509: CALL_OW 235
// end ;
10513: PPOPN 1
10515: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10516: LD_EXP 45
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: IFFALSE 10539
10531: GO 10533
10533: DISABLE
// begin enable ;
10534: ENABLE
// PrepareAmericanAttack ;
10535: CALL 6362 0 0
// end ;
10539: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10540: LD_INT 22
10542: PUSH
10543: LD_INT 1
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: IFFALSE 10738
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
10562: PPUSH
// begin while true do
10563: LD_INT 1
10565: IFFALSE 10622
// begin wait ( 0 0$1 ) ;
10567: LD_INT 35
10569: PPUSH
10570: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10574: LD_ADDR_VAR 0 2
10578: PUSH
10579: LD_INT 22
10581: PUSH
10582: LD_INT 1
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: PPUSH
10589: CALL_OW 69
10593: PPUSH
10594: LD_EXP 14
10598: PPUSH
10599: CALL_OW 74
10603: ST_TO_ADDR
// if See ( 7 , tmp ) then
10604: LD_INT 7
10606: PPUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 292
10616: IFFALSE 10620
// break ;
10618: GO 10622
// end ;
10620: GO 10563
// DialogueOn ;
10622: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL_OW 250
10644: PPUSH
10645: LD_VAR 0 2
10649: PPUSH
10650: CALL_OW 251
10654: PPUSH
10655: LD_INT 7
10657: PPUSH
10658: LD_INT 8
10660: PPUSH
10661: CALL_OW 330
// if Denis then
10665: LD_EXP 20
10669: IFFALSE 10683
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10671: LD_EXP 20
10675: PPUSH
10676: LD_STRING DAmerAttack-Pet-1
10678: PPUSH
10679: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10683: LD_EXP 14
10687: PPUSH
10688: LD_STRING DAmerAttack-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10695: LD_EXP 45
10699: PPUSH
10700: LD_STRING DStop-Bur-1
10702: PPUSH
10703: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 250
10716: PPUSH
10717: LD_VAR 0 2
10721: PPUSH
10722: CALL_OW 251
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 331
// DialogueOff ;
10734: CALL_OW 7
// end ;
10738: PPOPN 2
10740: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10741: LD_INT 22
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 21
10753: PUSH
10754: LD_INT 1
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: IFFALSE 10815
10775: GO 10777
10777: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10778: LD_STRING M5a
10780: PPUSH
10781: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10785: LD_EXP 14
10789: PPUSH
10790: LD_STRING D8-JMM-1
10792: PPUSH
10793: CALL_OW 88
// if Gossudarov then
10797: LD_EXP 31
10801: IFFALSE 10815
// Say ( Gossudarov , D8-Gos-1 ) ;
10803: LD_EXP 31
10807: PPUSH
10808: LD_STRING D8-Gos-1
10810: PPUSH
10811: CALL_OW 88
// end ;
10815: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 21
10828: PUSH
10829: LD_INT 1
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: PUSH
10845: LD_INT 0
10847: EQUAL
10848: IFFALSE 10898
10850: GO 10852
10852: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10853: LD_STRING M4c
10855: PPUSH
10856: CALL_OW 337
// if Roth then
10860: LD_EXP 15
10864: IFFALSE 10880
// Say ( Roth , DStop-Roth-1 ) else
10866: LD_EXP 15
10870: PPUSH
10871: LD_STRING DStop-Roth-1
10873: PPUSH
10874: CALL_OW 88
10878: GO 10898
// if Gossudarov then
10880: LD_EXP 31
10884: IFFALSE 10898
// Say ( Gossudarov , D8-Gos-1a ) ;
10886: LD_EXP 31
10890: PPUSH
10891: LD_STRING D8-Gos-1a
10893: PPUSH
10894: CALL_OW 88
// end ;
10898: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10899: LD_INT 7
10901: PPUSH
10902: LD_INT 1
10904: PPUSH
10905: LD_INT 1
10907: PPUSH
10908: CALL 14029 0 3
10912: PUSH
10913: LD_INT 0
10915: EQUAL
10916: PUSH
10917: LD_INT 7
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_INT 1
10925: PPUSH
10926: CALL 14029 0 3
10930: PUSH
10931: LD_INT 0
10933: EQUAL
10934: AND
10935: IFFALSE 10947
10937: GO 10939
10939: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10940: LD_STRING M1a
10942: PPUSH
10943: CALL_OW 337
// end ;
10947: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10948: LD_INT 22
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 21
10960: PUSH
10961: LD_INT 1
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: PUSH
10977: LD_INT 0
10979: EQUAL
10980: PUSH
10981: LD_INT 22
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_INT 0
11012: EQUAL
11013: AND
11014: PUSH
11015: LD_INT 22
11017: PUSH
11018: LD_INT 1
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 69
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 1
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 14029 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: PUSH
11054: LD_INT 7
11056: PPUSH
11057: LD_INT 3
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL 14029 0 3
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: AND
11072: IFFALSE 12434
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
// begin wait ( 0 0$3 ) ;
11082: LD_INT 105
11084: PPUSH
11085: CALL_OW 67
// if not IsDead ( Masha ) then
11089: LD_EXP 48
11093: PPUSH
11094: CALL_OW 301
11098: NOT
11099: IFFALSE 11113
// AddMedal ( Masha , 1 ) else
11101: LD_STRING Masha
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL_OW 101
11111: GO 11124
// AddMedal ( Masha , - 1 ) ;
11113: LD_STRING Masha
11115: PPUSH
11116: LD_INT 1
11118: NEG
11119: PPUSH
11120: CALL_OW 101
// if abdul_escaped then
11124: LD_EXP 12
11128: IFFALSE 11143
// AddMedal ( Abdul , - 1 ) else
11130: LD_STRING Abdul
11132: PPUSH
11133: LD_INT 1
11135: NEG
11136: PPUSH
11137: CALL_OW 101
11141: GO 11153
// AddMedal ( Abdul , 1 ) ;
11143: LD_STRING Abdul
11145: PPUSH
11146: LD_INT 1
11148: PPUSH
11149: CALL_OW 101
// if loss_counter = 0 then
11153: LD_EXP 13
11157: PUSH
11158: LD_INT 0
11160: EQUAL
11161: IFFALSE 11175
// AddMedal ( People , 2 ) else
11163: LD_STRING People
11165: PPUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 101
11173: GO 11225
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11175: LD_EXP 13
11179: PUSH
11180: LD_INT 3
11182: PUSH
11183: LD_INT 2
11185: PUSH
11186: LD_INT 2
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: LIST
11193: PUSH
11194: LD_OWVAR 67
11198: ARRAY
11199: LESSEQUAL
11200: IFFALSE 11214
// AddMedal ( People , 1 ) else
11202: LD_STRING People
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 101
11212: GO 11225
// AddMedal ( People , - 1 ) ;
11214: LD_STRING People
11216: PPUSH
11217: LD_INT 1
11219: NEG
11220: PPUSH
11221: CALL_OW 101
// GiveMedals ( MAIN ) ;
11225: LD_STRING MAIN
11227: PPUSH
11228: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11232: LD_ADDR_VAR 0 2
11236: PUSH
11237: LD_INT 22
11239: PUSH
11240: LD_INT 7
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 25
11252: PUSH
11253: LD_INT 1
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: PUSH
11260: LD_INT 25
11262: PUSH
11263: LD_INT 2
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: LD_INT 25
11272: PUSH
11273: LD_INT 3
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 25
11282: PUSH
11283: LD_INT 4
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: LD_INT 25
11292: PUSH
11293: LD_INT 5
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: PUSH
11300: LD_INT 25
11302: PUSH
11303: LD_INT 8
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: PUSH
11310: LD_INT 25
11312: PUSH
11313: LD_INT 9
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: PUSH
11330: EMPTY
11331: LIST
11332: LIST
11333: PPUSH
11334: CALL_OW 69
11338: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11339: LD_VAR 0 2
11343: PPUSH
11344: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11348: LD_ADDR_VAR 0 3
11352: PUSH
11353: LD_EXP 14
11357: PUSH
11358: LD_EXP 15
11362: PUSH
11363: LD_EXP 16
11367: PUSH
11368: LD_EXP 17
11372: PUSH
11373: LD_EXP 18
11377: PUSH
11378: LD_EXP 19
11382: PUSH
11383: LD_EXP 20
11387: PUSH
11388: LD_EXP 21
11392: PUSH
11393: LD_EXP 22
11397: PUSH
11398: LD_EXP 23
11402: PUSH
11403: LD_EXP 24
11407: PUSH
11408: LD_EXP 25
11412: PUSH
11413: LD_EXP 26
11417: PUSH
11418: LD_EXP 27
11422: PUSH
11423: LD_EXP 28
11427: PUSH
11428: LD_EXP 29
11432: PUSH
11433: LD_EXP 30
11437: PUSH
11438: LD_EXP 31
11442: PUSH
11443: LD_EXP 32
11447: PUSH
11448: LD_EXP 33
11452: PUSH
11453: LD_EXP 35
11457: PUSH
11458: LD_EXP 36
11462: PUSH
11463: LD_EXP 37
11467: PUSH
11468: LD_EXP 38
11472: PUSH
11473: LD_EXP 39
11477: PUSH
11478: LD_EXP 40
11482: PUSH
11483: LD_EXP 41
11487: PUSH
11488: LD_EXP 42
11492: PUSH
11493: LD_EXP 43
11497: PUSH
11498: LD_EXP 44
11502: PUSH
11503: LD_EXP 45
11507: PUSH
11508: LD_EXP 46
11512: PUSH
11513: LD_EXP 47
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: ST_TO_ADDR
// if tmp diff tmp2 then
11553: LD_VAR 0 2
11557: PUSH
11558: LD_VAR 0 3
11562: DIFF
11563: IFFALSE 11583
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11565: LD_VAR 0 2
11569: PUSH
11570: LD_VAR 0 3
11574: DIFF
11575: PPUSH
11576: LD_STRING 13a_others
11578: PPUSH
11579: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11583: LD_EXP 14
11587: PPUSH
11588: LD_STRING 13a_JMM
11590: PPUSH
11591: CALL_OW 38
// if Titov then
11595: LD_EXP 33
11599: IFFALSE 11613
// SaveCharacters ( Titov , 13a_Titov ) ;
11601: LD_EXP 33
11605: PPUSH
11606: LD_STRING 13a_Titov
11608: PPUSH
11609: CALL_OW 38
// if Dolgov then
11613: LD_EXP 35
11617: IFFALSE 11631
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11619: LD_EXP 35
11623: PPUSH
11624: LD_STRING 13a_Dolgov
11626: PPUSH
11627: CALL_OW 38
// if Petrosyan then
11631: LD_EXP 36
11635: IFFALSE 11649
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11637: LD_EXP 36
11641: PPUSH
11642: LD_STRING 13a_Petrosyan
11644: PPUSH
11645: CALL_OW 38
// if Scholtze then
11649: LD_EXP 37
11653: IFFALSE 11667
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11655: LD_EXP 37
11659: PPUSH
11660: LD_STRING 13a_Scholtze
11662: PPUSH
11663: CALL_OW 38
// if Oblukov then
11667: LD_EXP 38
11671: IFFALSE 11685
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11673: LD_EXP 38
11677: PPUSH
11678: LD_STRING 13a_Oblukov
11680: PPUSH
11681: CALL_OW 38
// if Kapitsova then
11685: LD_EXP 39
11689: IFFALSE 11703
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11691: LD_EXP 39
11695: PPUSH
11696: LD_STRING 13a_Kapitsova
11698: PPUSH
11699: CALL_OW 38
// if Lipshchin then
11703: LD_EXP 40
11707: IFFALSE 11721
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11709: LD_EXP 40
11713: PPUSH
11714: LD_STRING 13a_Lipshchin
11716: PPUSH
11717: CALL_OW 38
// if Petrovova then
11721: LD_EXP 41
11725: IFFALSE 11739
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11727: LD_EXP 41
11731: PPUSH
11732: LD_STRING 13a_Petrovova
11734: PPUSH
11735: CALL_OW 38
// if Kovalyuk then
11739: LD_EXP 42
11743: IFFALSE 11757
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11745: LD_EXP 42
11749: PPUSH
11750: LD_STRING 13a_Kovalyuk
11752: PPUSH
11753: CALL_OW 38
// if Kuzmov then
11757: LD_EXP 43
11761: IFFALSE 11775
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11763: LD_EXP 43
11767: PPUSH
11768: LD_STRING 13a_Kuzmov
11770: PPUSH
11771: CALL_OW 38
// if Karamazov then
11775: LD_EXP 44
11779: IFFALSE 11793
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11781: LD_EXP 44
11785: PPUSH
11786: LD_STRING 13a_Karamazov
11788: PPUSH
11789: CALL_OW 38
// if Burlak then
11793: LD_EXP 45
11797: IFFALSE 11811
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11799: LD_EXP 45
11803: PPUSH
11804: LD_STRING 13a_Burlak
11806: PPUSH
11807: CALL_OW 38
// if Belkov then
11811: LD_EXP 46
11815: IFFALSE 11829
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11817: LD_EXP 46
11821: PPUSH
11822: LD_STRING 13a_Belkov
11824: PPUSH
11825: CALL_OW 38
// if Gnyevko then
11829: LD_EXP 47
11833: IFFALSE 11847
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11835: LD_EXP 47
11839: PPUSH
11840: LD_STRING 13a_Gnyevko
11842: PPUSH
11843: CALL_OW 38
// if Lisa then
11847: LD_EXP 16
11851: IFFALSE 11865
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11853: LD_EXP 16
11857: PPUSH
11858: LD_STRING 13a_Lisa
11860: PPUSH
11861: CALL_OW 38
// if Donaldson then
11865: LD_EXP 17
11869: IFFALSE 11883
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11871: LD_EXP 17
11875: PPUSH
11876: LD_STRING 13a_Donaldson
11878: PPUSH
11879: CALL_OW 38
// if Bobby then
11883: LD_EXP 18
11887: IFFALSE 11901
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11889: LD_EXP 18
11893: PPUSH
11894: LD_STRING 13a_Bobby
11896: PPUSH
11897: CALL_OW 38
// if Cyrus then
11901: LD_EXP 19
11905: IFFALSE 11919
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11907: LD_EXP 19
11911: PPUSH
11912: LD_STRING 13a_Cyrus
11914: PPUSH
11915: CALL_OW 38
// if Denis then
11919: LD_EXP 20
11923: IFFALSE 11937
// SaveCharacters ( Denis , 13a_Denis ) ;
11925: LD_EXP 20
11929: PPUSH
11930: LD_STRING 13a_Denis
11932: PPUSH
11933: CALL_OW 38
// if Brown then
11937: LD_EXP 21
11941: IFFALSE 11955
// SaveCharacters ( Brown , 13a_Brown ) ;
11943: LD_EXP 21
11947: PPUSH
11948: LD_STRING 13a_Brown
11950: PPUSH
11951: CALL_OW 38
// if Gladstone then
11955: LD_EXP 22
11959: IFFALSE 11973
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11961: LD_EXP 22
11965: PPUSH
11966: LD_STRING 13a_Gladstone
11968: PPUSH
11969: CALL_OW 38
// if Houten then
11973: LD_EXP 23
11977: IFFALSE 11991
// SaveCharacters ( Houten , 13a_Houten ) ;
11979: LD_EXP 23
11983: PPUSH
11984: LD_STRING 13a_Houten
11986: PPUSH
11987: CALL_OW 38
// if Cornel then
11991: LD_EXP 24
11995: IFFALSE 12009
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11997: LD_EXP 24
12001: PPUSH
12002: LD_STRING 13a_Cornel
12004: PPUSH
12005: CALL_OW 38
// if Gary then
12009: LD_EXP 25
12013: IFFALSE 12027
// SaveCharacters ( Gary , 13a_Gary ) ;
12015: LD_EXP 25
12019: PPUSH
12020: LD_STRING 13a_Gary
12022: PPUSH
12023: CALL_OW 38
// if Frank then
12027: LD_EXP 26
12031: IFFALSE 12045
// SaveCharacters ( Frank , 13a_Frank ) ;
12033: LD_EXP 26
12037: PPUSH
12038: LD_STRING 13a_Frank
12040: PPUSH
12041: CALL_OW 38
// if Kikuchi then
12045: LD_EXP 27
12049: IFFALSE 12063
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12051: LD_EXP 27
12055: PPUSH
12056: LD_STRING 13a_Kikuchi
12058: PPUSH
12059: CALL_OW 38
// if Simms then
12063: LD_EXP 28
12067: IFFALSE 12081
// SaveCharacters ( Simms , 13a_Simms ) ;
12069: LD_EXP 28
12073: PPUSH
12074: LD_STRING 13a_Simms
12076: PPUSH
12077: CALL_OW 38
// if Joan then
12081: LD_EXP 29
12085: IFFALSE 12099
// SaveCharacters ( Joan , 13a_Joan ) ;
12087: LD_EXP 29
12091: PPUSH
12092: LD_STRING 13a_Joan
12094: PPUSH
12095: CALL_OW 38
// if DeltaDoctor then
12099: LD_EXP 30
12103: IFFALSE 12117
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12105: LD_EXP 30
12109: PPUSH
12110: LD_STRING 13a_DeltaDoctor
12112: PPUSH
12113: CALL_OW 38
// if Gossudarov then
12117: LD_EXP 31
12121: IFFALSE 12135
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12123: LD_EXP 31
12127: PPUSH
12128: LD_STRING 13a_Gossudarov
12130: PPUSH
12131: CALL_OW 38
// if Kirilenkova then
12135: LD_EXP 32
12139: IFFALSE 12153
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12141: LD_EXP 32
12145: PPUSH
12146: LD_STRING 13a_Kirilenkova
12148: PPUSH
12149: CALL_OW 38
// if Roth then
12153: LD_EXP 15
12157: IFFALSE 12171
// SaveCharacters ( Roth , 13a_Roth ) ;
12159: LD_EXP 15
12163: PPUSH
12164: LD_STRING 13a_Roth
12166: PPUSH
12167: CALL_OW 38
// if Masha then
12171: LD_EXP 48
12175: IFFALSE 12230
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12177: LD_EXP 48
12181: PPUSH
12182: CALL_OW 265
12186: PUSH
12187: LD_EXP 48
12191: PPUSH
12192: CALL_OW 262
12196: PUSH
12197: LD_EXP 48
12201: PPUSH
12202: CALL_OW 263
12206: PUSH
12207: LD_EXP 48
12211: PPUSH
12212: CALL_OW 264
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: PPUSH
12223: LD_STRING 13a_Masha
12225: PPUSH
12226: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12230: LD_ADDR_VAR 0 2
12234: PUSH
12235: LD_INT 21
12237: PUSH
12238: LD_INT 3
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PPUSH
12245: CALL_OW 69
12249: ST_TO_ADDR
// tmp2 := [ ] ;
12250: LD_ADDR_VAR 0 3
12254: PUSH
12255: EMPTY
12256: ST_TO_ADDR
// if tmp then
12257: LD_VAR 0 2
12261: IFFALSE 12412
// for i in tmp do
12263: LD_ADDR_VAR 0 1
12267: PUSH
12268: LD_VAR 0 2
12272: PUSH
12273: FOR_IN
12274: IFFALSE 12410
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12276: LD_ADDR_VAR 0 3
12280: PUSH
12281: LD_VAR 0 3
12285: PUSH
12286: LD_VAR 0 1
12290: PPUSH
12291: CALL_OW 255
12295: PUSH
12296: LD_VAR 0 1
12300: PPUSH
12301: CALL_OW 248
12305: PUSH
12306: LD_VAR 0 1
12310: PPUSH
12311: CALL_OW 266
12315: PUSH
12316: LD_VAR 0 1
12320: PPUSH
12321: CALL_OW 250
12325: PUSH
12326: LD_VAR 0 1
12330: PPUSH
12331: CALL_OW 251
12335: PUSH
12336: LD_VAR 0 1
12340: PPUSH
12341: CALL_OW 254
12345: PUSH
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 267
12355: PUSH
12356: LD_VAR 0 1
12360: PPUSH
12361: LD_INT 1
12363: PPUSH
12364: CALL_OW 268
12368: PUSH
12369: LD_VAR 0 1
12373: PPUSH
12374: LD_INT 2
12376: PPUSH
12377: CALL_OW 268
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 269
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: PUSH
12404: EMPTY
12405: LIST
12406: ADD
12407: ST_TO_ADDR
12408: GO 12273
12410: POP
12411: POP
// if tmp2 then
12412: LD_VAR 0 3
12416: IFFALSE 12430
// SaveVariable ( tmp2 , 13a_buildings ) ;
12418: LD_VAR 0 3
12422: PPUSH
12423: LD_STRING 13a_buildings
12425: PPUSH
12426: CALL_OW 39
// YouWin ;
12430: CALL_OW 103
// end ;
12434: PPOPN 3
12436: END
// export function SciRu ; var tmp , t ; begin
12437: LD_INT 0
12439: PPUSH
12440: PPUSH
12441: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12442: LD_ADDR_VAR 0 3
12446: PUSH
12447: LD_EXP 31
12451: PUSH
12452: LD_EXP 45
12456: PUSH
12457: LD_EXP 33
12461: PUSH
12462: LD_EXP 46
12466: PUSH
12467: LD_EXP 47
12471: PUSH
12472: LD_EXP 36
12476: PUSH
12477: LD_EXP 37
12481: PUSH
12482: LD_EXP 35
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12497: LD_ADDR_VAR 0 2
12501: PUSH
12502: LD_INT 22
12504: PUSH
12505: LD_INT 7
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 23
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PUSH
12522: LD_INT 25
12524: PUSH
12525: LD_INT 4
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PUSH
12532: LD_INT 26
12534: PUSH
12535: LD_INT 1
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: PPUSH
12548: CALL_OW 69
12552: PUSH
12553: LD_VAR 0 3
12557: DIFF
12558: ST_TO_ADDR
// if tmp then
12559: LD_VAR 0 2
12563: IFFALSE 12579
// result := tmp [ 1 ] ;
12565: LD_ADDR_VAR 0 1
12569: PUSH
12570: LD_VAR 0 2
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: ST_TO_ADDR
// end ;
12579: LD_VAR 0 1
12583: RET
// export function SolRu ; var tmp , t ; begin
12584: LD_INT 0
12586: PPUSH
12587: PPUSH
12588: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12589: LD_ADDR_VAR 0 3
12593: PUSH
12594: LD_EXP 31
12598: PUSH
12599: LD_EXP 45
12603: PUSH
12604: LD_EXP 33
12608: PUSH
12609: LD_EXP 46
12613: PUSH
12614: LD_EXP 47
12618: PUSH
12619: LD_EXP 36
12623: PUSH
12624: LD_EXP 37
12628: PUSH
12629: LD_EXP 35
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12644: LD_ADDR_VAR 0 2
12648: PUSH
12649: LD_INT 22
12651: PUSH
12652: LD_INT 7
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 23
12661: PUSH
12662: LD_INT 3
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 25
12671: PUSH
12672: LD_INT 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 26
12681: PUSH
12682: LD_INT 1
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 69
12699: PUSH
12700: LD_VAR 0 3
12704: DIFF
12705: ST_TO_ADDR
// if tmp then
12706: LD_VAR 0 2
12710: IFFALSE 12726
// result := tmp [ 1 ] ;
12712: LD_ADDR_VAR 0 1
12716: PUSH
12717: LD_VAR 0 2
12721: PUSH
12722: LD_INT 1
12724: ARRAY
12725: ST_TO_ADDR
// end ; end_of_file
12726: LD_VAR 0 1
12730: RET
// export function CustomEvent ( event ) ; begin
12731: LD_INT 0
12733: PPUSH
// end ;
12734: LD_VAR 0 2
12738: RET
// on UnitDestroyed ( un ) do var i , side ;
12739: LD_INT 0
12741: PPUSH
12742: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 22
12750: PUSH
12751: LD_INT 7
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: LD_INT 25
12763: PUSH
12764: LD_INT 1
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PUSH
12771: LD_INT 25
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 25
12783: PUSH
12784: LD_INT 3
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 25
12793: PUSH
12794: LD_INT 4
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 25
12803: PUSH
12804: LD_INT 5
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: PUSH
12811: LD_INT 25
12813: PUSH
12814: LD_INT 8
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 9
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PPUSH
12845: CALL_OW 69
12849: IN
12850: IFFALSE 12866
// loss_counter := loss_counter + 1 ;
12852: LD_ADDR_EXP 13
12856: PUSH
12857: LD_EXP 13
12861: PUSH
12862: LD_INT 1
12864: PLUS
12865: ST_TO_ADDR
// if un = Abdul then
12866: LD_VAR 0 1
12870: PUSH
12871: LD_EXP 54
12875: EQUAL
12876: IFFALSE 12886
// abdul_escaped := false ;
12878: LD_ADDR_EXP 12
12882: PUSH
12883: LD_INT 0
12885: ST_TO_ADDR
// if un in ru_attackers then
12886: LD_VAR 0 1
12890: PUSH
12891: LD_EXP 51
12895: IN
12896: IFFALSE 12914
// ru_attackers := ru_attackers diff un ;
12898: LD_ADDR_EXP 51
12902: PUSH
12903: LD_EXP 51
12907: PUSH
12908: LD_VAR 0 1
12912: DIFF
12913: ST_TO_ADDR
// if un in ar_attackers then
12914: LD_VAR 0 1
12918: PUSH
12919: LD_EXP 10
12923: IN
12924: IFFALSE 12942
// ar_attackers := ar_attackers diff un ;
12926: LD_ADDR_EXP 10
12930: PUSH
12931: LD_EXP 10
12935: PUSH
12936: LD_VAR 0 1
12940: DIFF
12941: ST_TO_ADDR
// if un = JMM then
12942: LD_VAR 0 1
12946: PUSH
12947: LD_EXP 14
12951: EQUAL
12952: IFFALSE 12963
// begin YouLost ( JMM ) ;
12954: LD_STRING JMM
12956: PPUSH
12957: CALL_OW 104
// exit ;
12961: GO 13052
// end ; if un = Burlak then
12963: LD_VAR 0 1
12967: PUSH
12968: LD_EXP 45
12972: EQUAL
12973: IFFALSE 12984
// begin YouLost ( Burlak ) ;
12975: LD_STRING Burlak
12977: PPUSH
12978: CALL_OW 104
// exit ;
12982: GO 13052
// end ; if un = freedom then
12984: LD_VAR 0 1
12988: PUSH
12989: LD_EXP 3
12993: EQUAL
12994: IFFALSE 13005
// begin YouLost ( Destroyed ) ;
12996: LD_STRING Destroyed
12998: PPUSH
12999: CALL_OW 104
// exit ;
13003: GO 13052
// end ; if un = Masha then
13005: LD_VAR 0 1
13009: PUSH
13010: LD_EXP 48
13014: EQUAL
13015: IFFALSE 13024
// ChangeMissionObjectives ( M4b ) ;
13017: LD_STRING M4b
13019: PPUSH
13020: CALL_OW 337
// if un = Mastodont then
13024: LD_VAR 0 1
13028: PUSH
13029: LD_EXP 55
13033: EQUAL
13034: IFFALSE 13043
// ChangeMissionObjectives ( M4a ) ;
13036: LD_STRING M4a
13038: PPUSH
13039: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13043: LD_VAR 0 1
13047: PPUSH
13048: CALL 83739 0 1
// end ;
13052: PPOPN 3
13054: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13055: LD_VAR 0 1
13059: PPUSH
13060: LD_VAR 0 2
13064: PPUSH
13065: CALL 85939 0 2
// end ;
13069: PPOPN 2
13071: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13072: LD_VAR 0 1
13076: PPUSH
13077: CALL 85007 0 1
// end ;
13081: PPOPN 1
13083: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13084: LD_VAR 0 1
13088: PUSH
13089: LD_INT 22
13091: PUSH
13092: LD_INT 7
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 30
13101: PUSH
13102: LD_INT 0
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PPUSH
13113: CALL_OW 69
13117: IN
13118: IFFALSE 13157
// begin SetBName ( building , freedom ) ;
13120: LD_VAR 0 1
13124: PPUSH
13125: LD_STRING freedom
13127: PPUSH
13128: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13132: LD_INT 0
13134: PPUSH
13135: LD_INT 7
13137: PPUSH
13138: LD_INT 0
13140: PPUSH
13141: CALL_OW 324
// freedom := building ;
13145: LD_ADDR_EXP 3
13149: PUSH
13150: LD_VAR 0 1
13154: ST_TO_ADDR
// exit ;
13155: GO 13223
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13157: LD_VAR 0 1
13161: PUSH
13162: LD_INT 22
13164: PUSH
13165: LD_INT 7
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 23
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: PUSH
13182: LD_INT 30
13184: PUSH
13185: LD_INT 6
13187: PUSH
13188: EMPTY
13189: LIST
13190: LIST
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: LIST
13196: PPUSH
13197: CALL_OW 69
13201: IN
13202: IFFALSE 13214
// begin ru_lab_builded := true ;
13204: LD_ADDR_EXP 5
13208: PUSH
13209: LD_INT 1
13211: ST_TO_ADDR
// exit ;
13212: GO 13223
// end ; MCE_BuildingComplete ( building ) ;
13214: LD_VAR 0 1
13218: PPUSH
13219: CALL 85248 0 1
// end ;
13223: PPOPN 1
13225: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13226: LD_VAR 0 1
13230: PPUSH
13231: LD_VAR 0 2
13235: PPUSH
13236: CALL 83435 0 2
// end ;
13240: PPOPN 2
13242: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13243: LD_VAR 0 1
13247: PPUSH
13248: LD_VAR 0 2
13252: PPUSH
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_VAR 0 4
13262: PPUSH
13263: LD_VAR 0 5
13267: PPUSH
13268: CALL 83055 0 5
// end ;
13272: PPOPN 5
13274: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_VAR 0 2
13284: PPUSH
13285: CALL 82651 0 2
// end ;
13289: PPOPN 2
13291: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13292: LD_VAR 0 1
13296: PPUSH
13297: LD_VAR 0 2
13301: PPUSH
13302: LD_VAR 0 3
13306: PPUSH
13307: LD_VAR 0 4
13311: PPUSH
13312: CALL 82489 0 4
// end ;
13316: PPOPN 4
13318: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_VAR 0 2
13328: PPUSH
13329: LD_VAR 0 3
13333: PPUSH
13334: CALL 82264 0 3
// end ;
13338: PPOPN 3
13340: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13341: LD_VAR 0 1
13345: PPUSH
13346: LD_VAR 0 2
13350: PPUSH
13351: CALL 82149 0 2
// end ;
13355: PPOPN 2
13357: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13358: LD_VAR 0 1
13362: PPUSH
13363: LD_VAR 0 2
13367: PPUSH
13368: CALL 86200 0 2
// end ;
13372: PPOPN 2
13374: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13375: LD_VAR 0 1
13379: PPUSH
13380: LD_VAR 0 2
13384: PPUSH
13385: LD_VAR 0 3
13389: PPUSH
13390: LD_VAR 0 4
13394: PPUSH
13395: CALL 86416 0 4
// end ;
13399: PPOPN 4
13401: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_VAR 0 2
13411: PPUSH
13412: CALL 81958 0 2
// end ;
13416: PPOPN 2
13418: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13419: LD_VAR 0 1
13423: PPUSH
13424: CALL 86699 0 1
// end ; end_of_file
13428: PPOPN 1
13430: END
// every 0 0$30 do var cr , time ;
13431: GO 13433
13433: DISABLE
13434: LD_INT 0
13436: PPUSH
13437: PPUSH
// begin time := 0 0$30 ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_INT 1050
13445: ST_TO_ADDR
// while game do
13446: LD_EXP 2
13450: IFFALSE 13549
// begin wait ( time ) ;
13452: LD_VAR 0 2
13456: PPUSH
13457: CALL_OW 67
// if tick > 2 2$00 then
13461: LD_OWVAR 1
13465: PUSH
13466: LD_INT 4200
13468: GREATER
13469: IFFALSE 13502
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 2
13480: PUSH
13481: LD_INT 280
13483: PUSH
13484: LD_INT 420
13486: PUSH
13487: LD_INT 630
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PUSH
13495: LD_OWVAR 67
13499: ARRAY
13500: PLUS
13501: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13502: LD_INT 1
13504: PPUSH
13505: LD_INT 5
13507: PPUSH
13508: CALL_OW 12
13512: PPUSH
13513: LD_INT 70
13515: PPUSH
13516: LD_INT 49
13518: PPUSH
13519: LD_INT 25
13521: PPUSH
13522: LD_INT 1
13524: PPUSH
13525: CALL_OW 56
// if time > 5 5$00 then
13529: LD_VAR 0 2
13533: PUSH
13534: LD_INT 10500
13536: GREATER
13537: IFFALSE 13547
// time := 0 0$30 ;
13539: LD_ADDR_VAR 0 2
13543: PUSH
13544: LD_INT 1050
13546: ST_TO_ADDR
// end ;
13547: GO 13446
// end ;
13549: PPOPN 2
13551: END
// every 0 0$30 do var cr , time ;
13552: GO 13554
13554: DISABLE
13555: LD_INT 0
13557: PPUSH
13558: PPUSH
// begin time := 0 0$20 ;
13559: LD_ADDR_VAR 0 2
13563: PUSH
13564: LD_INT 700
13566: ST_TO_ADDR
// while game do
13567: LD_EXP 2
13571: IFFALSE 13660
// begin wait ( time ) ;
13573: LD_VAR 0 2
13577: PPUSH
13578: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 2
13591: PUSH
13592: LD_INT 490
13594: PUSH
13595: LD_INT 525
13597: PUSH
13598: LD_INT 560
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: LIST
13605: PUSH
13606: LD_OWVAR 67
13610: ARRAY
13611: PLUS
13612: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13613: LD_INT 3
13615: PPUSH
13616: LD_INT 5
13618: PPUSH
13619: CALL_OW 12
13623: PPUSH
13624: LD_INT 26
13626: PPUSH
13627: LD_INT 9
13629: PPUSH
13630: LD_INT 30
13632: PPUSH
13633: LD_INT 1
13635: PPUSH
13636: CALL_OW 56
// if time > 3 3$00 then
13640: LD_VAR 0 2
13644: PUSH
13645: LD_INT 6300
13647: GREATER
13648: IFFALSE 13658
// time := 0 0$20 ;
13650: LD_ADDR_VAR 0 2
13654: PUSH
13655: LD_INT 700
13657: ST_TO_ADDR
// end ;
13658: GO 13567
// end ;
13660: PPOPN 2
13662: END
// every 0 0$30 do var cr , time ;
13663: GO 13665
13665: DISABLE
13666: LD_INT 0
13668: PPUSH
13669: PPUSH
// begin time := 0 0$20 ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_INT 700
13677: ST_TO_ADDR
// while game do
13678: LD_EXP 2
13682: IFFALSE 13807
// begin wait ( time ) ;
13684: LD_VAR 0 2
13688: PPUSH
13689: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13693: LD_ADDR_VAR 0 2
13697: PUSH
13698: LD_VAR 0 2
13702: PUSH
13703: LD_INT 175
13705: PUSH
13706: LD_INT 210
13708: PUSH
13709: LD_INT 280
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: LIST
13716: PUSH
13717: LD_OWVAR 67
13721: ARRAY
13722: PLUS
13723: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13724: LD_INT 1
13726: PPUSH
13727: LD_INT 5
13729: PPUSH
13730: CALL_OW 12
13734: PPUSH
13735: LD_INT 179
13737: PPUSH
13738: LD_INT 101
13740: PPUSH
13741: LD_INT 20
13743: PPUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13751: LD_INT 350
13753: PPUSH
13754: LD_INT 525
13756: PPUSH
13757: CALL_OW 12
13761: PPUSH
13762: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13766: LD_INT 1
13768: PPUSH
13769: LD_INT 5
13771: PPUSH
13772: CALL_OW 12
13776: PPUSH
13777: LD_INT 9
13779: PPUSH
13780: LD_INT 1
13782: PPUSH
13783: CALL_OW 55
// if time > 4 4$00 then
13787: LD_VAR 0 2
13791: PUSH
13792: LD_INT 8400
13794: GREATER
13795: IFFALSE 13805
// time := 0 0$30 ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_INT 1050
13804: ST_TO_ADDR
// end ;
13805: GO 13678
// end ;
13807: PPOPN 2
13809: END
// every 0 0$30 do var cr , time ;
13810: GO 13812
13812: DISABLE
13813: LD_INT 0
13815: PPUSH
13816: PPUSH
// begin time := 0 0$10 ;
13817: LD_ADDR_VAR 0 2
13821: PUSH
13822: LD_INT 350
13824: ST_TO_ADDR
// while game do
13825: LD_EXP 2
13829: IFFALSE 13963
// begin wait ( time ) ;
13831: LD_VAR 0 2
13835: PPUSH
13836: CALL_OW 67
// time := time + 0 0$10 ;
13840: LD_ADDR_VAR 0 2
13844: PUSH
13845: LD_VAR 0 2
13849: PUSH
13850: LD_INT 350
13852: PLUS
13853: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13854: LD_INT 1
13856: PPUSH
13857: LD_INT 5
13859: PPUSH
13860: CALL_OW 12
13864: PPUSH
13865: LD_INT 11
13867: PPUSH
13868: LD_INT 1
13870: PPUSH
13871: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13875: LD_ADDR_VAR 0 1
13879: PUSH
13880: LD_INT 1
13882: PPUSH
13883: LD_INT 3
13885: PPUSH
13886: CALL_OW 12
13890: ST_TO_ADDR
// if cr = 1 then
13891: LD_VAR 0 1
13895: PUSH
13896: LD_INT 1
13898: EQUAL
13899: IFFALSE 13943
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13901: LD_INT 700
13903: PPUSH
13904: LD_INT 1575
13906: PPUSH
13907: CALL_OW 12
13911: PPUSH
13912: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13916: LD_INT 1
13918: PPUSH
13919: LD_INT 5
13921: PPUSH
13922: CALL_OW 12
13926: PPUSH
13927: LD_INT 34
13929: PPUSH
13930: LD_INT 50
13932: PPUSH
13933: LD_INT 7
13935: PPUSH
13936: LD_INT 1
13938: PPUSH
13939: CALL_OW 56
// end ; if time > 8 8$00 then
13943: LD_VAR 0 2
13947: PUSH
13948: LD_INT 16800
13950: GREATER
13951: IFFALSE 13961
// time := 0 0$40 ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_INT 1400
13960: ST_TO_ADDR
// end ;
13961: GO 13825
// end ; end_of_file
13963: PPOPN 2
13965: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13966: LD_INT 0
13968: PPUSH
13969: PPUSH
// if exist_mode then
13970: LD_VAR 0 2
13974: IFFALSE 13999
// unit := CreateCharacter ( prefix & ident ) else
13976: LD_ADDR_VAR 0 5
13980: PUSH
13981: LD_VAR 0 3
13985: PUSH
13986: LD_VAR 0 1
13990: STR
13991: PPUSH
13992: CALL_OW 34
13996: ST_TO_ADDR
13997: GO 14014
// unit := NewCharacter ( ident ) ;
13999: LD_ADDR_VAR 0 5
14003: PUSH
14004: LD_VAR 0 1
14008: PPUSH
14009: CALL_OW 25
14013: ST_TO_ADDR
// result := unit ;
14014: LD_ADDR_VAR 0 4
14018: PUSH
14019: LD_VAR 0 5
14023: ST_TO_ADDR
// end ;
14024: LD_VAR 0 4
14028: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14029: LD_INT 0
14031: PPUSH
14032: PPUSH
// if not side or not nation then
14033: LD_VAR 0 1
14037: NOT
14038: PUSH
14039: LD_VAR 0 2
14043: NOT
14044: OR
14045: IFFALSE 14049
// exit ;
14047: GO 14693
// case nation of nation_american :
14049: LD_VAR 0 2
14053: PUSH
14054: LD_INT 1
14056: DOUBLE
14057: EQUAL
14058: IFTRUE 14062
14060: GO 14236
14062: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14063: LD_ADDR_VAR 0 4
14067: PUSH
14068: LD_INT 35
14070: PUSH
14071: LD_INT 45
14073: PUSH
14074: LD_INT 46
14076: PUSH
14077: LD_INT 47
14079: PUSH
14080: LD_INT 1
14082: PUSH
14083: LD_INT 2
14085: PUSH
14086: LD_INT 6
14088: PUSH
14089: LD_INT 15
14091: PUSH
14092: LD_INT 16
14094: PUSH
14095: LD_INT 7
14097: PUSH
14098: LD_INT 12
14100: PUSH
14101: LD_INT 13
14103: PUSH
14104: LD_INT 10
14106: PUSH
14107: LD_INT 14
14109: PUSH
14110: LD_INT 20
14112: PUSH
14113: LD_INT 21
14115: PUSH
14116: LD_INT 22
14118: PUSH
14119: LD_INT 25
14121: PUSH
14122: LD_INT 32
14124: PUSH
14125: LD_INT 27
14127: PUSH
14128: LD_INT 36
14130: PUSH
14131: LD_INT 69
14133: PUSH
14134: LD_INT 39
14136: PUSH
14137: LD_INT 34
14139: PUSH
14140: LD_INT 40
14142: PUSH
14143: LD_INT 48
14145: PUSH
14146: LD_INT 49
14148: PUSH
14149: LD_INT 50
14151: PUSH
14152: LD_INT 51
14154: PUSH
14155: LD_INT 52
14157: PUSH
14158: LD_INT 53
14160: PUSH
14161: LD_INT 54
14163: PUSH
14164: LD_INT 55
14166: PUSH
14167: LD_INT 56
14169: PUSH
14170: LD_INT 57
14172: PUSH
14173: LD_INT 58
14175: PUSH
14176: LD_INT 59
14178: PUSH
14179: LD_INT 60
14181: PUSH
14182: LD_INT 61
14184: PUSH
14185: LD_INT 62
14187: PUSH
14188: LD_INT 80
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: ST_TO_ADDR
14234: GO 14617
14236: LD_INT 2
14238: DOUBLE
14239: EQUAL
14240: IFTRUE 14244
14242: GO 14426
14244: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: LD_INT 35
14252: PUSH
14253: LD_INT 45
14255: PUSH
14256: LD_INT 46
14258: PUSH
14259: LD_INT 47
14261: PUSH
14262: LD_INT 70
14264: PUSH
14265: LD_INT 1
14267: PUSH
14268: LD_INT 11
14270: PUSH
14271: LD_INT 3
14273: PUSH
14274: LD_INT 4
14276: PUSH
14277: LD_INT 5
14279: PUSH
14280: LD_INT 6
14282: PUSH
14283: LD_INT 15
14285: PUSH
14286: LD_INT 18
14288: PUSH
14289: LD_INT 7
14291: PUSH
14292: LD_INT 17
14294: PUSH
14295: LD_INT 8
14297: PUSH
14298: LD_INT 20
14300: PUSH
14301: LD_INT 21
14303: PUSH
14304: LD_INT 22
14306: PUSH
14307: LD_INT 72
14309: PUSH
14310: LD_INT 26
14312: PUSH
14313: LD_INT 69
14315: PUSH
14316: LD_INT 39
14318: PUSH
14319: LD_INT 40
14321: PUSH
14322: LD_INT 41
14324: PUSH
14325: LD_INT 42
14327: PUSH
14328: LD_INT 43
14330: PUSH
14331: LD_INT 48
14333: PUSH
14334: LD_INT 49
14336: PUSH
14337: LD_INT 50
14339: PUSH
14340: LD_INT 51
14342: PUSH
14343: LD_INT 52
14345: PUSH
14346: LD_INT 53
14348: PUSH
14349: LD_INT 54
14351: PUSH
14352: LD_INT 55
14354: PUSH
14355: LD_INT 56
14357: PUSH
14358: LD_INT 60
14360: PUSH
14361: LD_INT 61
14363: PUSH
14364: LD_INT 62
14366: PUSH
14367: LD_INT 66
14369: PUSH
14370: LD_INT 67
14372: PUSH
14373: LD_INT 68
14375: PUSH
14376: LD_INT 81
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: ST_TO_ADDR
14424: GO 14617
14426: LD_INT 3
14428: DOUBLE
14429: EQUAL
14430: IFTRUE 14434
14432: GO 14616
14434: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14435: LD_ADDR_VAR 0 4
14439: PUSH
14440: LD_INT 46
14442: PUSH
14443: LD_INT 47
14445: PUSH
14446: LD_INT 1
14448: PUSH
14449: LD_INT 2
14451: PUSH
14452: LD_INT 11
14454: PUSH
14455: LD_INT 9
14457: PUSH
14458: LD_INT 20
14460: PUSH
14461: LD_INT 19
14463: PUSH
14464: LD_INT 21
14466: PUSH
14467: LD_INT 24
14469: PUSH
14470: LD_INT 22
14472: PUSH
14473: LD_INT 25
14475: PUSH
14476: LD_INT 28
14478: PUSH
14479: LD_INT 29
14481: PUSH
14482: LD_INT 30
14484: PUSH
14485: LD_INT 31
14487: PUSH
14488: LD_INT 37
14490: PUSH
14491: LD_INT 38
14493: PUSH
14494: LD_INT 32
14496: PUSH
14497: LD_INT 27
14499: PUSH
14500: LD_INT 33
14502: PUSH
14503: LD_INT 69
14505: PUSH
14506: LD_INT 39
14508: PUSH
14509: LD_INT 34
14511: PUSH
14512: LD_INT 40
14514: PUSH
14515: LD_INT 71
14517: PUSH
14518: LD_INT 23
14520: PUSH
14521: LD_INT 44
14523: PUSH
14524: LD_INT 48
14526: PUSH
14527: LD_INT 49
14529: PUSH
14530: LD_INT 50
14532: PUSH
14533: LD_INT 51
14535: PUSH
14536: LD_INT 52
14538: PUSH
14539: LD_INT 53
14541: PUSH
14542: LD_INT 54
14544: PUSH
14545: LD_INT 55
14547: PUSH
14548: LD_INT 56
14550: PUSH
14551: LD_INT 57
14553: PUSH
14554: LD_INT 58
14556: PUSH
14557: LD_INT 59
14559: PUSH
14560: LD_INT 63
14562: PUSH
14563: LD_INT 64
14565: PUSH
14566: LD_INT 65
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: ST_TO_ADDR
14614: GO 14617
14616: POP
// if state > - 1 and state < 3 then
14617: LD_VAR 0 3
14621: PUSH
14622: LD_INT 1
14624: NEG
14625: GREATER
14626: PUSH
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 3
14634: LESS
14635: AND
14636: IFFALSE 14693
// for i in result do
14638: LD_ADDR_VAR 0 5
14642: PUSH
14643: LD_VAR 0 4
14647: PUSH
14648: FOR_IN
14649: IFFALSE 14691
// if GetTech ( i , side ) <> state then
14651: LD_VAR 0 5
14655: PPUSH
14656: LD_VAR 0 1
14660: PPUSH
14661: CALL_OW 321
14665: PUSH
14666: LD_VAR 0 3
14670: NONEQUAL
14671: IFFALSE 14689
// result := result diff i ;
14673: LD_ADDR_VAR 0 4
14677: PUSH
14678: LD_VAR 0 4
14682: PUSH
14683: LD_VAR 0 5
14687: DIFF
14688: ST_TO_ADDR
14689: GO 14648
14691: POP
14692: POP
// end ;
14693: LD_VAR 0 4
14697: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14698: LD_INT 0
14700: PPUSH
14701: PPUSH
14702: PPUSH
// result := true ;
14703: LD_ADDR_VAR 0 3
14707: PUSH
14708: LD_INT 1
14710: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14711: LD_ADDR_VAR 0 5
14715: PUSH
14716: LD_VAR 0 2
14720: PPUSH
14721: CALL_OW 480
14725: ST_TO_ADDR
// if not tmp then
14726: LD_VAR 0 5
14730: NOT
14731: IFFALSE 14735
// exit ;
14733: GO 14784
// for i in tmp do
14735: LD_ADDR_VAR 0 4
14739: PUSH
14740: LD_VAR 0 5
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14782
// if GetTech ( i , side ) <> state_researched then
14748: LD_VAR 0 4
14752: PPUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 321
14762: PUSH
14763: LD_INT 2
14765: NONEQUAL
14766: IFFALSE 14780
// begin result := false ;
14768: LD_ADDR_VAR 0 3
14772: PUSH
14773: LD_INT 0
14775: ST_TO_ADDR
// exit ;
14776: POP
14777: POP
14778: GO 14784
// end ;
14780: GO 14745
14782: POP
14783: POP
// end ;
14784: LD_VAR 0 3
14788: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
14803: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14804: LD_VAR 0 1
14808: NOT
14809: PUSH
14810: LD_VAR 0 1
14814: PPUSH
14815: CALL_OW 257
14819: PUSH
14820: LD_INT 9
14822: NONEQUAL
14823: OR
14824: IFFALSE 14828
// exit ;
14826: GO 15401
// side := GetSide ( unit ) ;
14828: LD_ADDR_VAR 0 9
14832: PUSH
14833: LD_VAR 0 1
14837: PPUSH
14838: CALL_OW 255
14842: ST_TO_ADDR
// tech_space := tech_spacanom ;
14843: LD_ADDR_VAR 0 12
14847: PUSH
14848: LD_INT 29
14850: ST_TO_ADDR
// tech_time := tech_taurad ;
14851: LD_ADDR_VAR 0 13
14855: PUSH
14856: LD_INT 28
14858: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14859: LD_ADDR_VAR 0 11
14863: PUSH
14864: LD_VAR 0 1
14868: PPUSH
14869: CALL_OW 310
14873: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14874: LD_VAR 0 11
14878: PPUSH
14879: CALL_OW 247
14883: PUSH
14884: LD_INT 2
14886: EQUAL
14887: IFFALSE 14891
// exit ;
14889: GO 15401
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14891: LD_ADDR_VAR 0 8
14895: PUSH
14896: LD_INT 81
14898: PUSH
14899: LD_VAR 0 9
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 3
14910: PUSH
14911: LD_INT 21
14913: PUSH
14914: LD_INT 3
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PPUSH
14929: CALL_OW 69
14933: ST_TO_ADDR
// if not tmp then
14934: LD_VAR 0 8
14938: NOT
14939: IFFALSE 14943
// exit ;
14941: GO 15401
// if in_unit then
14943: LD_VAR 0 11
14947: IFFALSE 14971
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14949: LD_ADDR_VAR 0 10
14953: PUSH
14954: LD_VAR 0 8
14958: PPUSH
14959: LD_VAR 0 11
14963: PPUSH
14964: CALL_OW 74
14968: ST_TO_ADDR
14969: GO 14991
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14971: LD_ADDR_VAR 0 10
14975: PUSH
14976: LD_VAR 0 8
14980: PPUSH
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 74
14990: ST_TO_ADDR
// if not enemy then
14991: LD_VAR 0 10
14995: NOT
14996: IFFALSE 15000
// exit ;
14998: GO 15401
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15000: LD_VAR 0 11
15004: PUSH
15005: LD_VAR 0 11
15009: PPUSH
15010: LD_VAR 0 10
15014: PPUSH
15015: CALL_OW 296
15019: PUSH
15020: LD_INT 13
15022: GREATER
15023: AND
15024: PUSH
15025: LD_VAR 0 1
15029: PPUSH
15030: LD_VAR 0 10
15034: PPUSH
15035: CALL_OW 296
15039: PUSH
15040: LD_INT 12
15042: GREATER
15043: OR
15044: IFFALSE 15048
// exit ;
15046: GO 15401
// missile := [ 1 ] ;
15048: LD_ADDR_VAR 0 14
15052: PUSH
15053: LD_INT 1
15055: PUSH
15056: EMPTY
15057: LIST
15058: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15059: LD_VAR 0 9
15063: PPUSH
15064: LD_VAR 0 12
15068: PPUSH
15069: CALL_OW 325
15073: IFFALSE 15102
// missile := Insert ( missile , missile + 1 , 2 ) ;
15075: LD_ADDR_VAR 0 14
15079: PUSH
15080: LD_VAR 0 14
15084: PPUSH
15085: LD_VAR 0 14
15089: PUSH
15090: LD_INT 1
15092: PLUS
15093: PPUSH
15094: LD_INT 2
15096: PPUSH
15097: CALL_OW 2
15101: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15102: LD_VAR 0 9
15106: PPUSH
15107: LD_VAR 0 13
15111: PPUSH
15112: CALL_OW 325
15116: PUSH
15117: LD_VAR 0 10
15121: PPUSH
15122: CALL_OW 255
15126: PPUSH
15127: LD_VAR 0 13
15131: PPUSH
15132: CALL_OW 325
15136: NOT
15137: AND
15138: IFFALSE 15167
// missile := Insert ( missile , missile + 1 , 3 ) ;
15140: LD_ADDR_VAR 0 14
15144: PUSH
15145: LD_VAR 0 14
15149: PPUSH
15150: LD_VAR 0 14
15154: PUSH
15155: LD_INT 1
15157: PLUS
15158: PPUSH
15159: LD_INT 3
15161: PPUSH
15162: CALL_OW 2
15166: ST_TO_ADDR
// if missile < 2 then
15167: LD_VAR 0 14
15171: PUSH
15172: LD_INT 2
15174: LESS
15175: IFFALSE 15179
// exit ;
15177: GO 15401
// x := GetX ( enemy ) ;
15179: LD_ADDR_VAR 0 4
15183: PUSH
15184: LD_VAR 0 10
15188: PPUSH
15189: CALL_OW 250
15193: ST_TO_ADDR
// y := GetY ( enemy ) ;
15194: LD_ADDR_VAR 0 5
15198: PUSH
15199: LD_VAR 0 10
15203: PPUSH
15204: CALL_OW 251
15208: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15209: LD_ADDR_VAR 0 6
15213: PUSH
15214: LD_VAR 0 4
15218: PUSH
15219: LD_INT 1
15221: NEG
15222: PPUSH
15223: LD_INT 1
15225: PPUSH
15226: CALL_OW 12
15230: PLUS
15231: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PUSH
15242: LD_INT 1
15244: NEG
15245: PPUSH
15246: LD_INT 1
15248: PPUSH
15249: CALL_OW 12
15253: PLUS
15254: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15255: LD_VAR 0 6
15259: PPUSH
15260: LD_VAR 0 7
15264: PPUSH
15265: CALL_OW 488
15269: NOT
15270: IFFALSE 15292
// begin _x := x ;
15272: LD_ADDR_VAR 0 6
15276: PUSH
15277: LD_VAR 0 4
15281: ST_TO_ADDR
// _y := y ;
15282: LD_ADDR_VAR 0 7
15286: PUSH
15287: LD_VAR 0 5
15291: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15292: LD_ADDR_VAR 0 3
15296: PUSH
15297: LD_INT 1
15299: PPUSH
15300: LD_VAR 0 14
15304: PPUSH
15305: CALL_OW 12
15309: ST_TO_ADDR
// case i of 1 :
15310: LD_VAR 0 3
15314: PUSH
15315: LD_INT 1
15317: DOUBLE
15318: EQUAL
15319: IFTRUE 15323
15321: GO 15340
15323: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15324: LD_VAR 0 1
15328: PPUSH
15329: LD_VAR 0 10
15333: PPUSH
15334: CALL_OW 115
15338: GO 15401
15340: LD_INT 2
15342: DOUBLE
15343: EQUAL
15344: IFTRUE 15348
15346: GO 15370
15348: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15349: LD_VAR 0 1
15353: PPUSH
15354: LD_VAR 0 6
15358: PPUSH
15359: LD_VAR 0 7
15363: PPUSH
15364: CALL_OW 153
15368: GO 15401
15370: LD_INT 3
15372: DOUBLE
15373: EQUAL
15374: IFTRUE 15378
15376: GO 15400
15378: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_VAR 0 6
15388: PPUSH
15389: LD_VAR 0 7
15393: PPUSH
15394: CALL_OW 154
15398: GO 15401
15400: POP
// end ;
15401: LD_VAR 0 2
15405: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15406: LD_INT 0
15408: PPUSH
15409: PPUSH
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
// if not unit or not building then
15414: LD_VAR 0 1
15418: NOT
15419: PUSH
15420: LD_VAR 0 2
15424: NOT
15425: OR
15426: IFFALSE 15430
// exit ;
15428: GO 15588
// x := GetX ( building ) ;
15430: LD_ADDR_VAR 0 5
15434: PUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 250
15444: ST_TO_ADDR
// y := GetY ( building ) ;
15445: LD_ADDR_VAR 0 6
15449: PUSH
15450: LD_VAR 0 2
15454: PPUSH
15455: CALL_OW 251
15459: ST_TO_ADDR
// for i = 0 to 5 do
15460: LD_ADDR_VAR 0 4
15464: PUSH
15465: DOUBLE
15466: LD_INT 0
15468: DEC
15469: ST_TO_ADDR
15470: LD_INT 5
15472: PUSH
15473: FOR_TO
15474: IFFALSE 15586
// begin _x := ShiftX ( x , i , 3 ) ;
15476: LD_ADDR_VAR 0 7
15480: PUSH
15481: LD_VAR 0 5
15485: PPUSH
15486: LD_VAR 0 4
15490: PPUSH
15491: LD_INT 3
15493: PPUSH
15494: CALL_OW 272
15498: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15499: LD_ADDR_VAR 0 8
15503: PUSH
15504: LD_VAR 0 6
15508: PPUSH
15509: LD_VAR 0 4
15513: PPUSH
15514: LD_INT 3
15516: PPUSH
15517: CALL_OW 273
15521: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15522: LD_VAR 0 7
15526: PPUSH
15527: LD_VAR 0 8
15531: PPUSH
15532: CALL_OW 488
15536: NOT
15537: IFFALSE 15541
// continue ;
15539: GO 15473
// if HexInfo ( _x , _y ) = 0 then
15541: LD_VAR 0 7
15545: PPUSH
15546: LD_VAR 0 8
15550: PPUSH
15551: CALL_OW 428
15555: PUSH
15556: LD_INT 0
15558: EQUAL
15559: IFFALSE 15584
// begin ComMoveXY ( unit , _x , _y ) ;
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_VAR 0 7
15570: PPUSH
15571: LD_VAR 0 8
15575: PPUSH
15576: CALL_OW 111
// exit ;
15580: POP
15581: POP
15582: GO 15588
// end ; end ;
15584: GO 15473
15586: POP
15587: POP
// end ;
15588: LD_VAR 0 3
15592: RET
// export function ScanBase ( side , base_area ) ; begin
15593: LD_INT 0
15595: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15596: LD_ADDR_VAR 0 3
15600: PUSH
15601: LD_VAR 0 2
15605: PPUSH
15606: LD_INT 81
15608: PUSH
15609: LD_VAR 0 1
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PPUSH
15618: CALL_OW 70
15622: ST_TO_ADDR
// end ;
15623: LD_VAR 0 3
15627: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15628: LD_INT 0
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
15634: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15635: LD_VAR 0 1
15639: NOT
15640: PUSH
15641: LD_EXP 58
15645: PUSH
15646: LD_VAR 0 1
15650: ARRAY
15651: NOT
15652: OR
15653: PUSH
15654: LD_VAR 0 2
15658: NOT
15659: OR
15660: PUSH
15661: LD_VAR 0 3
15665: NOT
15666: OR
15667: IFFALSE 15671
// exit ;
15669: GO 16121
// side := mc_sides [ base ] ;
15671: LD_ADDR_VAR 0 6
15675: PUSH
15676: LD_EXP 84
15680: PUSH
15681: LD_VAR 0 1
15685: ARRAY
15686: ST_TO_ADDR
// if not side then
15687: LD_VAR 0 6
15691: NOT
15692: IFFALSE 15696
// exit ;
15694: GO 16121
// for i in solds do
15696: LD_ADDR_VAR 0 7
15700: PUSH
15701: LD_VAR 0 2
15705: PUSH
15706: FOR_IN
15707: IFFALSE 15768
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15709: LD_VAR 0 7
15713: PPUSH
15714: CALL_OW 310
15718: PPUSH
15719: CALL_OW 266
15723: PUSH
15724: LD_INT 32
15726: PUSH
15727: LD_INT 31
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: IN
15734: IFFALSE 15754
// solds := solds diff i else
15736: LD_ADDR_VAR 0 2
15740: PUSH
15741: LD_VAR 0 2
15745: PUSH
15746: LD_VAR 0 7
15750: DIFF
15751: ST_TO_ADDR
15752: GO 15766
// SetTag ( i , 18 ) ;
15754: LD_VAR 0 7
15758: PPUSH
15759: LD_INT 18
15761: PPUSH
15762: CALL_OW 109
15766: GO 15706
15768: POP
15769: POP
// if not solds then
15770: LD_VAR 0 2
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 16121
// repeat wait ( 0 0$1 ) ;
15779: LD_INT 35
15781: PPUSH
15782: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15786: LD_ADDR_VAR 0 5
15790: PUSH
15791: LD_VAR 0 6
15795: PPUSH
15796: LD_VAR 0 3
15800: PPUSH
15801: CALL 15593 0 2
15805: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
15806: LD_VAR 0 5
15810: NOT
15811: PUSH
15812: LD_VAR 0 5
15816: PUSH
15817: LD_INT 3
15819: GREATER
15820: OR
15821: PUSH
15822: LD_EXP 80
15826: PUSH
15827: LD_VAR 0 1
15831: ARRAY
15832: OR
15833: IFFALSE 15874
// begin for i in solds do
15835: LD_ADDR_VAR 0 7
15839: PUSH
15840: LD_VAR 0 2
15844: PUSH
15845: FOR_IN
15846: IFFALSE 15870
// if HasTask ( i ) then
15848: LD_VAR 0 7
15852: PPUSH
15853: CALL_OW 314
15857: IFFALSE 15868
// ComStop ( i ) ;
15859: LD_VAR 0 7
15863: PPUSH
15864: CALL_OW 141
15868: GO 15845
15870: POP
15871: POP
// break ;
15872: GO 16109
// end ; for i in solds do
15874: LD_ADDR_VAR 0 7
15878: PUSH
15879: LD_VAR 0 2
15883: PUSH
15884: FOR_IN
15885: IFFALSE 16101
// begin if IsInUnit ( i ) then
15887: LD_VAR 0 7
15891: PPUSH
15892: CALL_OW 310
15896: IFFALSE 15907
// ComExitBuilding ( i ) ;
15898: LD_VAR 0 7
15902: PPUSH
15903: CALL_OW 122
// if GetLives ( i ) > 333 then
15907: LD_VAR 0 7
15911: PPUSH
15912: CALL_OW 256
15916: PUSH
15917: LD_INT 333
15919: GREATER
15920: IFFALSE 15948
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15922: LD_VAR 0 7
15926: PPUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 7
15936: PPUSH
15937: CALL_OW 74
15941: PPUSH
15942: CALL_OW 115
15946: GO 16099
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
15948: LD_ADDR_VAR 0 8
15952: PUSH
15953: LD_EXP 58
15957: PUSH
15958: LD_VAR 0 1
15962: ARRAY
15963: PPUSH
15964: LD_INT 2
15966: PUSH
15967: LD_INT 30
15969: PUSH
15970: LD_INT 0
15972: PUSH
15973: EMPTY
15974: LIST
15975: LIST
15976: PUSH
15977: LD_INT 30
15979: PUSH
15980: LD_INT 1
15982: PUSH
15983: EMPTY
15984: LIST
15985: LIST
15986: PUSH
15987: LD_INT 30
15989: PUSH
15990: LD_INT 6
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: PUSH
15997: EMPTY
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: PPUSH
16003: CALL_OW 72
16007: PPUSH
16008: LD_VAR 0 7
16012: PPUSH
16013: CALL_OW 74
16017: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16018: LD_VAR 0 7
16022: PPUSH
16023: LD_VAR 0 8
16027: PPUSH
16028: CALL_OW 250
16032: PPUSH
16033: LD_INT 3
16035: PPUSH
16036: LD_INT 5
16038: PPUSH
16039: CALL_OW 272
16043: PPUSH
16044: LD_VAR 0 8
16048: PPUSH
16049: CALL_OW 251
16053: PPUSH
16054: LD_INT 3
16056: PPUSH
16057: LD_INT 5
16059: PPUSH
16060: CALL_OW 273
16064: PPUSH
16065: CALL_OW 111
// SetTag ( i , 0 ) ;
16069: LD_VAR 0 7
16073: PPUSH
16074: LD_INT 0
16076: PPUSH
16077: CALL_OW 109
// solds := solds diff i ;
16081: LD_ADDR_VAR 0 2
16085: PUSH
16086: LD_VAR 0 2
16090: PUSH
16091: LD_VAR 0 7
16095: DIFF
16096: ST_TO_ADDR
// continue ;
16097: GO 15884
// end ; end ;
16099: GO 15884
16101: POP
16102: POP
// until solds ;
16103: LD_VAR 0 2
16107: IFFALSE 15779
// MC_Reset ( base , 18 ) ;
16109: LD_VAR 0 1
16113: PPUSH
16114: LD_INT 18
16116: PPUSH
16117: CALL 60842 0 2
// end ;
16121: LD_VAR 0 4
16125: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16126: LD_INT 0
16128: PPUSH
16129: PPUSH
16130: PPUSH
16131: PPUSH
16132: PPUSH
16133: PPUSH
16134: PPUSH
16135: PPUSH
16136: PPUSH
16137: PPUSH
16138: PPUSH
16139: PPUSH
16140: PPUSH
16141: PPUSH
16142: PPUSH
16143: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16144: LD_ADDR_VAR 0 12
16148: PUSH
16149: LD_EXP 58
16153: PUSH
16154: LD_VAR 0 1
16158: ARRAY
16159: PPUSH
16160: LD_INT 25
16162: PUSH
16163: LD_INT 3
16165: PUSH
16166: EMPTY
16167: LIST
16168: LIST
16169: PPUSH
16170: CALL_OW 72
16174: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16175: LD_EXP 98
16179: PUSH
16180: LD_VAR 0 1
16184: ARRAY
16185: IFFALSE 16209
// mechs := mechs diff mc_remote_driver [ base ] ;
16187: LD_ADDR_VAR 0 12
16191: PUSH
16192: LD_VAR 0 12
16196: PUSH
16197: LD_EXP 98
16201: PUSH
16202: LD_VAR 0 1
16206: ARRAY
16207: DIFF
16208: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16209: LD_ADDR_VAR 0 8
16213: PUSH
16214: LD_EXP 58
16218: PUSH
16219: LD_VAR 0 1
16223: ARRAY
16224: PPUSH
16225: LD_INT 2
16227: PUSH
16228: LD_INT 25
16230: PUSH
16231: LD_INT 1
16233: PUSH
16234: EMPTY
16235: LIST
16236: LIST
16237: PUSH
16238: LD_INT 25
16240: PUSH
16241: LD_INT 5
16243: PUSH
16244: EMPTY
16245: LIST
16246: LIST
16247: PUSH
16248: LD_INT 25
16250: PUSH
16251: LD_INT 8
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 25
16260: PUSH
16261: LD_INT 9
16263: PUSH
16264: EMPTY
16265: LIST
16266: LIST
16267: PUSH
16268: EMPTY
16269: LIST
16270: LIST
16271: LIST
16272: LIST
16273: LIST
16274: PPUSH
16275: CALL_OW 72
16279: ST_TO_ADDR
// if not defenders and not solds then
16280: LD_VAR 0 2
16284: NOT
16285: PUSH
16286: LD_VAR 0 8
16290: NOT
16291: AND
16292: IFFALSE 16296
// exit ;
16294: GO 17670
// depot_under_attack := false ;
16296: LD_ADDR_VAR 0 16
16300: PUSH
16301: LD_INT 0
16303: ST_TO_ADDR
// sold_defenders := [ ] ;
16304: LD_ADDR_VAR 0 17
16308: PUSH
16309: EMPTY
16310: ST_TO_ADDR
// if mechs then
16311: LD_VAR 0 12
16315: IFFALSE 16444
// for i in defenders do
16317: LD_ADDR_VAR 0 5
16321: PUSH
16322: LD_VAR 0 2
16326: PUSH
16327: FOR_IN
16328: IFFALSE 16442
// begin SetTag ( i , 20 ) ;
16330: LD_VAR 0 5
16334: PPUSH
16335: LD_INT 20
16337: PPUSH
16338: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16342: LD_VAR 0 5
16346: PPUSH
16347: CALL_OW 263
16351: PUSH
16352: LD_INT 1
16354: EQUAL
16355: PUSH
16356: LD_VAR 0 5
16360: PPUSH
16361: CALL_OW 311
16365: NOT
16366: AND
16367: PUSH
16368: LD_VAR 0 12
16372: AND
16373: IFFALSE 16440
// begin un := mechs [ 1 ] ;
16375: LD_ADDR_VAR 0 10
16379: PUSH
16380: LD_VAR 0 12
16384: PUSH
16385: LD_INT 1
16387: ARRAY
16388: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16389: LD_VAR 0 10
16393: PPUSH
16394: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16398: LD_VAR 0 10
16402: PPUSH
16403: LD_VAR 0 5
16407: PPUSH
16408: CALL_OW 180
// SetTag ( un , 19 ) ;
16412: LD_VAR 0 10
16416: PPUSH
16417: LD_INT 19
16419: PPUSH
16420: CALL_OW 109
// mechs := mechs diff un ;
16424: LD_ADDR_VAR 0 12
16428: PUSH
16429: LD_VAR 0 12
16433: PUSH
16434: LD_VAR 0 10
16438: DIFF
16439: ST_TO_ADDR
// end ; end ;
16440: GO 16327
16442: POP
16443: POP
// if solds then
16444: LD_VAR 0 8
16448: IFFALSE 16507
// for i in solds do
16450: LD_ADDR_VAR 0 5
16454: PUSH
16455: LD_VAR 0 8
16459: PUSH
16460: FOR_IN
16461: IFFALSE 16505
// if not GetTag ( i ) then
16463: LD_VAR 0 5
16467: PPUSH
16468: CALL_OW 110
16472: NOT
16473: IFFALSE 16503
// begin defenders := defenders union i ;
16475: LD_ADDR_VAR 0 2
16479: PUSH
16480: LD_VAR 0 2
16484: PUSH
16485: LD_VAR 0 5
16489: UNION
16490: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16491: LD_VAR 0 5
16495: PPUSH
16496: LD_INT 18
16498: PPUSH
16499: CALL_OW 109
// end ;
16503: GO 16460
16505: POP
16506: POP
// repeat wait ( 0 0$1 ) ;
16507: LD_INT 35
16509: PPUSH
16510: CALL_OW 67
// enemy := mc_scan [ base ] ;
16514: LD_ADDR_VAR 0 3
16518: PUSH
16519: LD_EXP 81
16523: PUSH
16524: LD_VAR 0 1
16528: ARRAY
16529: ST_TO_ADDR
// for i in defenders do
16530: LD_ADDR_VAR 0 5
16534: PUSH
16535: LD_VAR 0 2
16539: PUSH
16540: FOR_IN
16541: IFFALSE 17271
// begin e := NearestUnitToUnit ( enemy , i ) ;
16543: LD_ADDR_VAR 0 13
16547: PUSH
16548: LD_VAR 0 3
16552: PPUSH
16553: LD_VAR 0 5
16557: PPUSH
16558: CALL_OW 74
16562: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16563: LD_ADDR_VAR 0 16
16567: PUSH
16568: LD_EXP 58
16572: PUSH
16573: LD_VAR 0 1
16577: ARRAY
16578: PPUSH
16579: LD_INT 2
16581: PUSH
16582: LD_INT 30
16584: PUSH
16585: LD_INT 0
16587: PUSH
16588: EMPTY
16589: LIST
16590: LIST
16591: PUSH
16592: LD_INT 30
16594: PUSH
16595: LD_INT 1
16597: PUSH
16598: EMPTY
16599: LIST
16600: LIST
16601: PUSH
16602: EMPTY
16603: LIST
16604: LIST
16605: LIST
16606: PPUSH
16607: CALL_OW 72
16611: NOT
16612: PUSH
16613: LD_EXP 58
16617: PUSH
16618: LD_VAR 0 1
16622: ARRAY
16623: PPUSH
16624: LD_INT 2
16626: PUSH
16627: LD_INT 30
16629: PUSH
16630: LD_INT 0
16632: PUSH
16633: EMPTY
16634: LIST
16635: LIST
16636: PUSH
16637: LD_INT 30
16639: PUSH
16640: LD_INT 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: EMPTY
16648: LIST
16649: LIST
16650: LIST
16651: PPUSH
16652: CALL_OW 72
16656: PPUSH
16657: CALL_OW 256
16661: PUSH
16662: LD_INT 600
16664: LESS
16665: OR
16666: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16667: LD_VAR 0 5
16671: PPUSH
16672: CALL_OW 247
16676: PUSH
16677: LD_INT 2
16679: DOUBLE
16680: EQUAL
16681: IFTRUE 16685
16683: GO 16977
16685: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
16686: LD_VAR 0 5
16690: PPUSH
16691: CALL_OW 256
16695: PUSH
16696: LD_INT 650
16698: GREATER
16699: PUSH
16700: LD_VAR 0 5
16704: PPUSH
16705: LD_VAR 0 13
16709: PPUSH
16710: CALL_OW 296
16714: PUSH
16715: LD_INT 40
16717: LESS
16718: PUSH
16719: LD_VAR 0 13
16723: PPUSH
16724: LD_EXP 83
16728: PUSH
16729: LD_VAR 0 1
16733: ARRAY
16734: PPUSH
16735: CALL_OW 308
16739: OR
16740: AND
16741: IFFALSE 16759
// ComAttackUnit ( i , e ) else
16743: LD_VAR 0 5
16747: PPUSH
16748: LD_VAR 0 13
16752: PPUSH
16753: CALL_OW 115
16757: GO 16860
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16759: LD_VAR 0 13
16763: PPUSH
16764: LD_EXP 83
16768: PUSH
16769: LD_VAR 0 1
16773: ARRAY
16774: PPUSH
16775: CALL_OW 308
16779: NOT
16780: PUSH
16781: LD_VAR 0 5
16785: PPUSH
16786: LD_VAR 0 13
16790: PPUSH
16791: CALL_OW 296
16795: PUSH
16796: LD_INT 40
16798: GREATEREQUAL
16799: AND
16800: PUSH
16801: LD_VAR 0 5
16805: PPUSH
16806: CALL_OW 256
16810: PUSH
16811: LD_INT 650
16813: LESSEQUAL
16814: OR
16815: PUSH
16816: LD_VAR 0 5
16820: PPUSH
16821: LD_EXP 82
16825: PUSH
16826: LD_VAR 0 1
16830: ARRAY
16831: PPUSH
16832: CALL_OW 308
16836: NOT
16837: AND
16838: IFFALSE 16860
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16840: LD_VAR 0 5
16844: PPUSH
16845: LD_EXP 82
16849: PUSH
16850: LD_VAR 0 1
16854: ARRAY
16855: PPUSH
16856: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16860: LD_VAR 0 5
16864: PPUSH
16865: CALL_OW 256
16869: PUSH
16870: LD_INT 998
16872: LESS
16873: PUSH
16874: LD_VAR 0 5
16878: PPUSH
16879: CALL_OW 263
16883: PUSH
16884: LD_INT 1
16886: EQUAL
16887: AND
16888: PUSH
16889: LD_VAR 0 5
16893: PPUSH
16894: CALL_OW 311
16898: AND
16899: PUSH
16900: LD_VAR 0 5
16904: PPUSH
16905: LD_EXP 82
16909: PUSH
16910: LD_VAR 0 1
16914: ARRAY
16915: PPUSH
16916: CALL_OW 308
16920: AND
16921: IFFALSE 16975
// begin mech := IsDrivenBy ( i ) ;
16923: LD_ADDR_VAR 0 9
16927: PUSH
16928: LD_VAR 0 5
16932: PPUSH
16933: CALL_OW 311
16937: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
16938: LD_VAR 0 9
16942: PPUSH
16943: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
16947: LD_VAR 0 9
16951: PPUSH
16952: LD_VAR 0 5
16956: PPUSH
16957: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
16961: LD_VAR 0 9
16965: PPUSH
16966: LD_VAR 0 5
16970: PPUSH
16971: CALL_OW 180
// end ; end ; unit_human :
16975: GO 17242
16977: LD_INT 1
16979: DOUBLE
16980: EQUAL
16981: IFTRUE 16985
16983: GO 17241
16985: POP
// begin b := IsInUnit ( i ) ;
16986: LD_ADDR_VAR 0 18
16990: PUSH
16991: LD_VAR 0 5
16995: PPUSH
16996: CALL_OW 310
17000: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17001: LD_ADDR_VAR 0 19
17005: PUSH
17006: LD_VAR 0 18
17010: NOT
17011: PUSH
17012: LD_VAR 0 18
17016: PPUSH
17017: CALL_OW 266
17021: PUSH
17022: LD_INT 32
17024: PUSH
17025: LD_INT 31
17027: PUSH
17028: EMPTY
17029: LIST
17030: LIST
17031: IN
17032: OR
17033: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17034: LD_VAR 0 16
17038: PUSH
17039: LD_VAR 0 2
17043: PPUSH
17044: LD_INT 21
17046: PUSH
17047: LD_INT 2
17049: PUSH
17050: EMPTY
17051: LIST
17052: LIST
17053: PPUSH
17054: CALL_OW 72
17058: PUSH
17059: LD_INT 1
17061: LESSEQUAL
17062: OR
17063: PUSH
17064: LD_VAR 0 19
17068: AND
17069: PUSH
17070: LD_VAR 0 5
17074: PUSH
17075: LD_VAR 0 17
17079: IN
17080: NOT
17081: AND
17082: IFFALSE 17175
// begin if b then
17084: LD_VAR 0 18
17088: IFFALSE 17137
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17090: LD_VAR 0 18
17094: PPUSH
17095: LD_VAR 0 3
17099: PPUSH
17100: LD_VAR 0 18
17104: PPUSH
17105: CALL_OW 74
17109: PPUSH
17110: CALL_OW 296
17114: PUSH
17115: LD_INT 10
17117: LESS
17118: PUSH
17119: LD_VAR 0 18
17123: PPUSH
17124: CALL_OW 461
17128: PUSH
17129: LD_INT 7
17131: NONEQUAL
17132: AND
17133: IFFALSE 17137
// continue ;
17135: GO 16540
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17137: LD_ADDR_VAR 0 17
17141: PUSH
17142: LD_VAR 0 17
17146: PPUSH
17147: LD_VAR 0 17
17151: PUSH
17152: LD_INT 1
17154: PLUS
17155: PPUSH
17156: LD_VAR 0 5
17160: PPUSH
17161: CALL_OW 1
17165: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17166: LD_VAR 0 5
17170: PPUSH
17171: CALL_OW 122
// end ; if sold_defenders then
17175: LD_VAR 0 17
17179: IFFALSE 17239
// if i in sold_defenders then
17181: LD_VAR 0 5
17185: PUSH
17186: LD_VAR 0 17
17190: IN
17191: IFFALSE 17239
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17193: LD_VAR 0 5
17197: PPUSH
17198: CALL_OW 314
17202: NOT
17203: PUSH
17204: LD_VAR 0 5
17208: PPUSH
17209: LD_VAR 0 13
17213: PPUSH
17214: CALL_OW 296
17218: PUSH
17219: LD_INT 30
17221: LESS
17222: AND
17223: IFFALSE 17239
// ComAttackUnit ( i , e ) ;
17225: LD_VAR 0 5
17229: PPUSH
17230: LD_VAR 0 13
17234: PPUSH
17235: CALL_OW 115
// end ; end ; end ;
17239: GO 17242
17241: POP
// if IsDead ( i ) then
17242: LD_VAR 0 5
17246: PPUSH
17247: CALL_OW 301
17251: IFFALSE 17269
// defenders := defenders diff i ;
17253: LD_ADDR_VAR 0 2
17257: PUSH
17258: LD_VAR 0 2
17262: PUSH
17263: LD_VAR 0 5
17267: DIFF
17268: ST_TO_ADDR
// end ;
17269: GO 16540
17271: POP
17272: POP
// until not enemy or not defenders ;
17273: LD_VAR 0 3
17277: NOT
17278: PUSH
17279: LD_VAR 0 2
17283: NOT
17284: OR
17285: IFFALSE 16507
// MC_Reset ( base , 18 ) ;
17287: LD_VAR 0 1
17291: PPUSH
17292: LD_INT 18
17294: PPUSH
17295: CALL 60842 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17299: LD_ADDR_VAR 0 2
17303: PUSH
17304: LD_VAR 0 2
17308: PUSH
17309: LD_VAR 0 2
17313: PPUSH
17314: LD_INT 2
17316: PUSH
17317: LD_INT 25
17319: PUSH
17320: LD_INT 1
17322: PUSH
17323: EMPTY
17324: LIST
17325: LIST
17326: PUSH
17327: LD_INT 25
17329: PUSH
17330: LD_INT 5
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: PUSH
17337: LD_INT 25
17339: PUSH
17340: LD_INT 8
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: PUSH
17347: LD_INT 25
17349: PUSH
17350: LD_INT 9
17352: PUSH
17353: EMPTY
17354: LIST
17355: LIST
17356: PUSH
17357: EMPTY
17358: LIST
17359: LIST
17360: LIST
17361: LIST
17362: LIST
17363: PPUSH
17364: CALL_OW 72
17368: DIFF
17369: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17370: LD_VAR 0 3
17374: NOT
17375: PUSH
17376: LD_VAR 0 2
17380: PPUSH
17381: LD_INT 21
17383: PUSH
17384: LD_INT 2
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: PPUSH
17391: CALL_OW 72
17395: AND
17396: IFFALSE 17658
// begin tmp := FilterByTag ( defenders , 19 ) ;
17398: LD_ADDR_VAR 0 11
17402: PUSH
17403: LD_VAR 0 2
17407: PPUSH
17408: LD_INT 19
17410: PPUSH
17411: CALL 54099 0 2
17415: ST_TO_ADDR
// if tmp then
17416: LD_VAR 0 11
17420: IFFALSE 17490
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17422: LD_ADDR_VAR 0 11
17426: PUSH
17427: LD_VAR 0 11
17431: PPUSH
17432: LD_INT 25
17434: PUSH
17435: LD_INT 3
17437: PUSH
17438: EMPTY
17439: LIST
17440: LIST
17441: PPUSH
17442: CALL_OW 72
17446: ST_TO_ADDR
// if tmp then
17447: LD_VAR 0 11
17451: IFFALSE 17490
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17453: LD_ADDR_EXP 70
17457: PUSH
17458: LD_EXP 70
17462: PPUSH
17463: LD_VAR 0 1
17467: PPUSH
17468: LD_EXP 70
17472: PUSH
17473: LD_VAR 0 1
17477: ARRAY
17478: PUSH
17479: LD_VAR 0 11
17483: UNION
17484: PPUSH
17485: CALL_OW 1
17489: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17490: LD_VAR 0 1
17494: PPUSH
17495: LD_INT 19
17497: PPUSH
17498: CALL 60842 0 2
// repeat wait ( 0 0$1 ) ;
17502: LD_INT 35
17504: PPUSH
17505: CALL_OW 67
// for i in defenders do
17509: LD_ADDR_VAR 0 5
17513: PUSH
17514: LD_VAR 0 2
17518: PUSH
17519: FOR_IN
17520: IFFALSE 17609
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17522: LD_VAR 0 5
17526: PPUSH
17527: LD_EXP 82
17531: PUSH
17532: LD_VAR 0 1
17536: ARRAY
17537: PPUSH
17538: CALL_OW 308
17542: NOT
17543: IFFALSE 17567
// ComMoveToArea ( i , mc_parking [ base ] ) else
17545: LD_VAR 0 5
17549: PPUSH
17550: LD_EXP 82
17554: PUSH
17555: LD_VAR 0 1
17559: ARRAY
17560: PPUSH
17561: CALL_OW 113
17565: GO 17607
// if GetControl ( i ) = control_manual then
17567: LD_VAR 0 5
17571: PPUSH
17572: CALL_OW 263
17576: PUSH
17577: LD_INT 1
17579: EQUAL
17580: IFFALSE 17607
// if IsDrivenBy ( i ) then
17582: LD_VAR 0 5
17586: PPUSH
17587: CALL_OW 311
17591: IFFALSE 17607
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17593: LD_VAR 0 5
17597: PPUSH
17598: CALL_OW 311
17602: PPUSH
17603: CALL_OW 121
// end ;
17607: GO 17519
17609: POP
17610: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
17611: LD_VAR 0 2
17615: PPUSH
17616: LD_INT 95
17618: PUSH
17619: LD_EXP 82
17623: PUSH
17624: LD_VAR 0 1
17628: ARRAY
17629: PUSH
17630: EMPTY
17631: LIST
17632: LIST
17633: PPUSH
17634: CALL_OW 72
17638: PUSH
17639: LD_VAR 0 2
17643: EQUAL
17644: PUSH
17645: LD_EXP 81
17649: PUSH
17650: LD_VAR 0 1
17654: ARRAY
17655: OR
17656: IFFALSE 17502
// end ; MC_Reset ( base , 20 ) ;
17658: LD_VAR 0 1
17662: PPUSH
17663: LD_INT 20
17665: PPUSH
17666: CALL 60842 0 2
// end ;
17670: LD_VAR 0 4
17674: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17675: LD_INT 0
17677: PPUSH
17678: PPUSH
17679: PPUSH
17680: PPUSH
// result := false ;
17681: LD_ADDR_VAR 0 2
17685: PUSH
17686: LD_INT 0
17688: ST_TO_ADDR
// side := GetSide ( unit ) ;
17689: LD_ADDR_VAR 0 3
17693: PUSH
17694: LD_VAR 0 1
17698: PPUSH
17699: CALL_OW 255
17703: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17704: LD_ADDR_VAR 0 4
17708: PUSH
17709: LD_VAR 0 1
17713: PPUSH
17714: CALL_OW 248
17718: ST_TO_ADDR
// case nat of 1 :
17719: LD_VAR 0 4
17723: PUSH
17724: LD_INT 1
17726: DOUBLE
17727: EQUAL
17728: IFTRUE 17732
17730: GO 17743
17732: POP
// tech := tech_lassight ; 2 :
17733: LD_ADDR_VAR 0 5
17737: PUSH
17738: LD_INT 12
17740: ST_TO_ADDR
17741: GO 17782
17743: LD_INT 2
17745: DOUBLE
17746: EQUAL
17747: IFTRUE 17751
17749: GO 17762
17751: POP
// tech := tech_mortar ; 3 :
17752: LD_ADDR_VAR 0 5
17756: PUSH
17757: LD_INT 41
17759: ST_TO_ADDR
17760: GO 17782
17762: LD_INT 3
17764: DOUBLE
17765: EQUAL
17766: IFTRUE 17770
17768: GO 17781
17770: POP
// tech := tech_bazooka ; end ;
17771: LD_ADDR_VAR 0 5
17775: PUSH
17776: LD_INT 44
17778: ST_TO_ADDR
17779: GO 17782
17781: POP
// if Researched ( side , tech ) then
17782: LD_VAR 0 3
17786: PPUSH
17787: LD_VAR 0 5
17791: PPUSH
17792: CALL_OW 325
17796: IFFALSE 17823
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17798: LD_ADDR_VAR 0 2
17802: PUSH
17803: LD_INT 5
17805: PUSH
17806: LD_INT 8
17808: PUSH
17809: LD_INT 9
17811: PUSH
17812: EMPTY
17813: LIST
17814: LIST
17815: LIST
17816: PUSH
17817: LD_VAR 0 4
17821: ARRAY
17822: ST_TO_ADDR
// end ;
17823: LD_VAR 0 2
17827: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17828: LD_INT 0
17830: PPUSH
17831: PPUSH
17832: PPUSH
// if not mines then
17833: LD_VAR 0 2
17837: NOT
17838: IFFALSE 17842
// exit ;
17840: GO 17986
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17842: LD_ADDR_VAR 0 5
17846: PUSH
17847: LD_INT 81
17849: PUSH
17850: LD_VAR 0 1
17854: PUSH
17855: EMPTY
17856: LIST
17857: LIST
17858: PUSH
17859: LD_INT 3
17861: PUSH
17862: LD_INT 21
17864: PUSH
17865: LD_INT 3
17867: PUSH
17868: EMPTY
17869: LIST
17870: LIST
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: PUSH
17876: EMPTY
17877: LIST
17878: LIST
17879: PPUSH
17880: CALL_OW 69
17884: ST_TO_ADDR
// for i in mines do
17885: LD_ADDR_VAR 0 4
17889: PUSH
17890: LD_VAR 0 2
17894: PUSH
17895: FOR_IN
17896: IFFALSE 17984
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17898: LD_VAR 0 4
17902: PUSH
17903: LD_INT 1
17905: ARRAY
17906: PPUSH
17907: LD_VAR 0 4
17911: PUSH
17912: LD_INT 2
17914: ARRAY
17915: PPUSH
17916: CALL_OW 458
17920: NOT
17921: IFFALSE 17925
// continue ;
17923: GO 17895
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17925: LD_VAR 0 4
17929: PUSH
17930: LD_INT 1
17932: ARRAY
17933: PPUSH
17934: LD_VAR 0 4
17938: PUSH
17939: LD_INT 2
17941: ARRAY
17942: PPUSH
17943: CALL_OW 428
17947: PUSH
17948: LD_VAR 0 5
17952: IN
17953: IFFALSE 17982
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17955: LD_VAR 0 4
17959: PUSH
17960: LD_INT 1
17962: ARRAY
17963: PPUSH
17964: LD_VAR 0 4
17968: PUSH
17969: LD_INT 2
17971: ARRAY
17972: PPUSH
17973: LD_VAR 0 1
17977: PPUSH
17978: CALL_OW 456
// end ;
17982: GO 17895
17984: POP
17985: POP
// end ;
17986: LD_VAR 0 3
17990: RET
// export function Count ( array ) ; var i ; begin
17991: LD_INT 0
17993: PPUSH
17994: PPUSH
// result := 0 ;
17995: LD_ADDR_VAR 0 2
17999: PUSH
18000: LD_INT 0
18002: ST_TO_ADDR
// for i in array do
18003: LD_ADDR_VAR 0 3
18007: PUSH
18008: LD_VAR 0 1
18012: PUSH
18013: FOR_IN
18014: IFFALSE 18038
// if i then
18016: LD_VAR 0 3
18020: IFFALSE 18036
// result := result + 1 ;
18022: LD_ADDR_VAR 0 2
18026: PUSH
18027: LD_VAR 0 2
18031: PUSH
18032: LD_INT 1
18034: PLUS
18035: ST_TO_ADDR
18036: GO 18013
18038: POP
18039: POP
// end ;
18040: LD_VAR 0 2
18044: RET
// export function IsEmpty ( building ) ; begin
18045: LD_INT 0
18047: PPUSH
// if not building then
18048: LD_VAR 0 1
18052: NOT
18053: IFFALSE 18057
// exit ;
18055: GO 18100
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18057: LD_ADDR_VAR 0 2
18061: PUSH
18062: LD_VAR 0 1
18066: PUSH
18067: LD_INT 22
18069: PUSH
18070: LD_VAR 0 1
18074: PPUSH
18075: CALL_OW 255
18079: PUSH
18080: EMPTY
18081: LIST
18082: LIST
18083: PUSH
18084: LD_INT 58
18086: PUSH
18087: EMPTY
18088: LIST
18089: PUSH
18090: EMPTY
18091: LIST
18092: LIST
18093: PPUSH
18094: CALL_OW 69
18098: IN
18099: ST_TO_ADDR
// end ;
18100: LD_VAR 0 2
18104: RET
// export function IsNotFull ( building ) ; begin
18105: LD_INT 0
18107: PPUSH
// if not building then
18108: LD_VAR 0 1
18112: NOT
18113: IFFALSE 18117
// exit ;
18115: GO 18136
// result := UnitsInside ( building ) < 6 ;
18117: LD_ADDR_VAR 0 2
18121: PUSH
18122: LD_VAR 0 1
18126: PPUSH
18127: CALL_OW 313
18131: PUSH
18132: LD_INT 6
18134: LESS
18135: ST_TO_ADDR
// end ;
18136: LD_VAR 0 2
18140: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18141: LD_INT 0
18143: PPUSH
18144: PPUSH
18145: PPUSH
18146: PPUSH
// tmp := [ ] ;
18147: LD_ADDR_VAR 0 3
18151: PUSH
18152: EMPTY
18153: ST_TO_ADDR
// list := [ ] ;
18154: LD_ADDR_VAR 0 5
18158: PUSH
18159: EMPTY
18160: ST_TO_ADDR
// for i = 16 to 25 do
18161: LD_ADDR_VAR 0 4
18165: PUSH
18166: DOUBLE
18167: LD_INT 16
18169: DEC
18170: ST_TO_ADDR
18171: LD_INT 25
18173: PUSH
18174: FOR_TO
18175: IFFALSE 18248
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18177: LD_ADDR_VAR 0 3
18181: PUSH
18182: LD_VAR 0 3
18186: PUSH
18187: LD_INT 22
18189: PUSH
18190: LD_VAR 0 1
18194: PPUSH
18195: CALL_OW 255
18199: PUSH
18200: EMPTY
18201: LIST
18202: LIST
18203: PUSH
18204: LD_INT 91
18206: PUSH
18207: LD_VAR 0 1
18211: PUSH
18212: LD_INT 6
18214: PUSH
18215: EMPTY
18216: LIST
18217: LIST
18218: LIST
18219: PUSH
18220: LD_INT 30
18222: PUSH
18223: LD_VAR 0 4
18227: PUSH
18228: EMPTY
18229: LIST
18230: LIST
18231: PUSH
18232: EMPTY
18233: LIST
18234: LIST
18235: LIST
18236: PUSH
18237: EMPTY
18238: LIST
18239: PPUSH
18240: CALL_OW 69
18244: ADD
18245: ST_TO_ADDR
18246: GO 18174
18248: POP
18249: POP
// for i = 1 to tmp do
18250: LD_ADDR_VAR 0 4
18254: PUSH
18255: DOUBLE
18256: LD_INT 1
18258: DEC
18259: ST_TO_ADDR
18260: LD_VAR 0 3
18264: PUSH
18265: FOR_TO
18266: IFFALSE 18354
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18268: LD_ADDR_VAR 0 5
18272: PUSH
18273: LD_VAR 0 5
18277: PUSH
18278: LD_VAR 0 3
18282: PUSH
18283: LD_VAR 0 4
18287: ARRAY
18288: PPUSH
18289: CALL_OW 266
18293: PUSH
18294: LD_VAR 0 3
18298: PUSH
18299: LD_VAR 0 4
18303: ARRAY
18304: PPUSH
18305: CALL_OW 250
18309: PUSH
18310: LD_VAR 0 3
18314: PUSH
18315: LD_VAR 0 4
18319: ARRAY
18320: PPUSH
18321: CALL_OW 251
18325: PUSH
18326: LD_VAR 0 3
18330: PUSH
18331: LD_VAR 0 4
18335: ARRAY
18336: PPUSH
18337: CALL_OW 254
18341: PUSH
18342: EMPTY
18343: LIST
18344: LIST
18345: LIST
18346: LIST
18347: PUSH
18348: EMPTY
18349: LIST
18350: ADD
18351: ST_TO_ADDR
18352: GO 18265
18354: POP
18355: POP
// result := list ;
18356: LD_ADDR_VAR 0 2
18360: PUSH
18361: LD_VAR 0 5
18365: ST_TO_ADDR
// end ;
18366: LD_VAR 0 2
18370: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18371: LD_INT 0
18373: PPUSH
18374: PPUSH
18375: PPUSH
18376: PPUSH
18377: PPUSH
18378: PPUSH
18379: PPUSH
// if not factory then
18380: LD_VAR 0 1
18384: NOT
18385: IFFALSE 18389
// exit ;
18387: GO 18982
// if control = control_apeman then
18389: LD_VAR 0 4
18393: PUSH
18394: LD_INT 5
18396: EQUAL
18397: IFFALSE 18506
// begin tmp := UnitsInside ( factory ) ;
18399: LD_ADDR_VAR 0 8
18403: PUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: CALL_OW 313
18413: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18414: LD_VAR 0 8
18418: PPUSH
18419: LD_INT 25
18421: PUSH
18422: LD_INT 12
18424: PUSH
18425: EMPTY
18426: LIST
18427: LIST
18428: PPUSH
18429: CALL_OW 72
18433: NOT
18434: IFFALSE 18444
// control := control_manual ;
18436: LD_ADDR_VAR 0 4
18440: PUSH
18441: LD_INT 1
18443: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18444: LD_ADDR_VAR 0 8
18448: PUSH
18449: LD_VAR 0 1
18453: PPUSH
18454: CALL 18141 0 1
18458: ST_TO_ADDR
// if tmp then
18459: LD_VAR 0 8
18463: IFFALSE 18506
// begin for i in tmp do
18465: LD_ADDR_VAR 0 7
18469: PUSH
18470: LD_VAR 0 8
18474: PUSH
18475: FOR_IN
18476: IFFALSE 18504
// if i [ 1 ] = b_ext_radio then
18478: LD_VAR 0 7
18482: PUSH
18483: LD_INT 1
18485: ARRAY
18486: PUSH
18487: LD_INT 22
18489: EQUAL
18490: IFFALSE 18502
// begin control := control_remote ;
18492: LD_ADDR_VAR 0 4
18496: PUSH
18497: LD_INT 2
18499: ST_TO_ADDR
// break ;
18500: GO 18504
// end ;
18502: GO 18475
18504: POP
18505: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18506: LD_VAR 0 1
18510: PPUSH
18511: LD_VAR 0 2
18515: PPUSH
18516: LD_VAR 0 3
18520: PPUSH
18521: LD_VAR 0 4
18525: PPUSH
18526: LD_VAR 0 5
18530: PPUSH
18531: CALL_OW 448
18535: IFFALSE 18570
// begin result := [ chassis , engine , control , weapon ] ;
18537: LD_ADDR_VAR 0 6
18541: PUSH
18542: LD_VAR 0 2
18546: PUSH
18547: LD_VAR 0 3
18551: PUSH
18552: LD_VAR 0 4
18556: PUSH
18557: LD_VAR 0 5
18561: PUSH
18562: EMPTY
18563: LIST
18564: LIST
18565: LIST
18566: LIST
18567: ST_TO_ADDR
// exit ;
18568: GO 18982
// end ; _chassis := AvailableChassisList ( factory ) ;
18570: LD_ADDR_VAR 0 9
18574: PUSH
18575: LD_VAR 0 1
18579: PPUSH
18580: CALL_OW 475
18584: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18585: LD_ADDR_VAR 0 11
18589: PUSH
18590: LD_VAR 0 1
18594: PPUSH
18595: CALL_OW 476
18599: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18600: LD_ADDR_VAR 0 12
18604: PUSH
18605: LD_VAR 0 1
18609: PPUSH
18610: CALL_OW 477
18614: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18615: LD_ADDR_VAR 0 10
18619: PUSH
18620: LD_VAR 0 1
18624: PPUSH
18625: CALL_OW 478
18629: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18630: LD_VAR 0 9
18634: NOT
18635: PUSH
18636: LD_VAR 0 11
18640: NOT
18641: OR
18642: PUSH
18643: LD_VAR 0 12
18647: NOT
18648: OR
18649: PUSH
18650: LD_VAR 0 10
18654: NOT
18655: OR
18656: IFFALSE 18691
// begin result := [ chassis , engine , control , weapon ] ;
18658: LD_ADDR_VAR 0 6
18662: PUSH
18663: LD_VAR 0 2
18667: PUSH
18668: LD_VAR 0 3
18672: PUSH
18673: LD_VAR 0 4
18677: PUSH
18678: LD_VAR 0 5
18682: PUSH
18683: EMPTY
18684: LIST
18685: LIST
18686: LIST
18687: LIST
18688: ST_TO_ADDR
// exit ;
18689: GO 18982
// end ; if not chassis in _chassis then
18691: LD_VAR 0 2
18695: PUSH
18696: LD_VAR 0 9
18700: IN
18701: NOT
18702: IFFALSE 18728
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18704: LD_ADDR_VAR 0 2
18708: PUSH
18709: LD_VAR 0 9
18713: PUSH
18714: LD_INT 1
18716: PPUSH
18717: LD_VAR 0 9
18721: PPUSH
18722: CALL_OW 12
18726: ARRAY
18727: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18728: LD_VAR 0 2
18732: PPUSH
18733: LD_VAR 0 3
18737: PPUSH
18738: CALL 18987 0 2
18742: NOT
18743: IFFALSE 18802
// repeat engine := _engine [ 1 ] ;
18745: LD_ADDR_VAR 0 3
18749: PUSH
18750: LD_VAR 0 11
18754: PUSH
18755: LD_INT 1
18757: ARRAY
18758: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18759: LD_ADDR_VAR 0 11
18763: PUSH
18764: LD_VAR 0 11
18768: PPUSH
18769: LD_INT 1
18771: PPUSH
18772: CALL_OW 3
18776: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18777: LD_VAR 0 2
18781: PPUSH
18782: LD_VAR 0 3
18786: PPUSH
18787: CALL 18987 0 2
18791: PUSH
18792: LD_VAR 0 11
18796: PUSH
18797: EMPTY
18798: EQUAL
18799: OR
18800: IFFALSE 18745
// if not control in _control then
18802: LD_VAR 0 4
18806: PUSH
18807: LD_VAR 0 12
18811: IN
18812: NOT
18813: IFFALSE 18839
// control := _control [ rand ( 1 , _control ) ] ;
18815: LD_ADDR_VAR 0 4
18819: PUSH
18820: LD_VAR 0 12
18824: PUSH
18825: LD_INT 1
18827: PPUSH
18828: LD_VAR 0 12
18832: PPUSH
18833: CALL_OW 12
18837: ARRAY
18838: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18839: LD_VAR 0 2
18843: PPUSH
18844: LD_VAR 0 5
18848: PPUSH
18849: CALL 19207 0 2
18853: NOT
18854: IFFALSE 18913
// repeat weapon := _weapon [ 1 ] ;
18856: LD_ADDR_VAR 0 5
18860: PUSH
18861: LD_VAR 0 10
18865: PUSH
18866: LD_INT 1
18868: ARRAY
18869: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18870: LD_ADDR_VAR 0 10
18874: PUSH
18875: LD_VAR 0 10
18879: PPUSH
18880: LD_INT 1
18882: PPUSH
18883: CALL_OW 3
18887: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18888: LD_VAR 0 2
18892: PPUSH
18893: LD_VAR 0 5
18897: PPUSH
18898: CALL 19207 0 2
18902: PUSH
18903: LD_VAR 0 10
18907: PUSH
18908: EMPTY
18909: EQUAL
18910: OR
18911: IFFALSE 18856
// result := [ ] ;
18913: LD_ADDR_VAR 0 6
18917: PUSH
18918: EMPTY
18919: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18920: LD_VAR 0 1
18924: PPUSH
18925: LD_VAR 0 2
18929: PPUSH
18930: LD_VAR 0 3
18934: PPUSH
18935: LD_VAR 0 4
18939: PPUSH
18940: LD_VAR 0 5
18944: PPUSH
18945: CALL_OW 448
18949: IFFALSE 18982
// result := [ chassis , engine , control , weapon ] ;
18951: LD_ADDR_VAR 0 6
18955: PUSH
18956: LD_VAR 0 2
18960: PUSH
18961: LD_VAR 0 3
18965: PUSH
18966: LD_VAR 0 4
18970: PUSH
18971: LD_VAR 0 5
18975: PUSH
18976: EMPTY
18977: LIST
18978: LIST
18979: LIST
18980: LIST
18981: ST_TO_ADDR
// end ;
18982: LD_VAR 0 6
18986: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18987: LD_INT 0
18989: PPUSH
// if not chassis or not engine then
18990: LD_VAR 0 1
18994: NOT
18995: PUSH
18996: LD_VAR 0 2
19000: NOT
19001: OR
19002: IFFALSE 19006
// exit ;
19004: GO 19202
// case engine of engine_solar :
19006: LD_VAR 0 2
19010: PUSH
19011: LD_INT 2
19013: DOUBLE
19014: EQUAL
19015: IFTRUE 19019
19017: GO 19057
19019: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19020: LD_ADDR_VAR 0 3
19024: PUSH
19025: LD_INT 11
19027: PUSH
19028: LD_INT 12
19030: PUSH
19031: LD_INT 13
19033: PUSH
19034: LD_INT 14
19036: PUSH
19037: LD_INT 1
19039: PUSH
19040: LD_INT 2
19042: PUSH
19043: LD_INT 3
19045: PUSH
19046: EMPTY
19047: LIST
19048: LIST
19049: LIST
19050: LIST
19051: LIST
19052: LIST
19053: LIST
19054: ST_TO_ADDR
19055: GO 19186
19057: LD_INT 1
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19127
19065: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 11
19073: PUSH
19074: LD_INT 12
19076: PUSH
19077: LD_INT 13
19079: PUSH
19080: LD_INT 14
19082: PUSH
19083: LD_INT 1
19085: PUSH
19086: LD_INT 2
19088: PUSH
19089: LD_INT 3
19091: PUSH
19092: LD_INT 4
19094: PUSH
19095: LD_INT 5
19097: PUSH
19098: LD_INT 21
19100: PUSH
19101: LD_INT 23
19103: PUSH
19104: LD_INT 22
19106: PUSH
19107: LD_INT 24
19109: PUSH
19110: EMPTY
19111: LIST
19112: LIST
19113: LIST
19114: LIST
19115: LIST
19116: LIST
19117: LIST
19118: LIST
19119: LIST
19120: LIST
19121: LIST
19122: LIST
19123: LIST
19124: ST_TO_ADDR
19125: GO 19186
19127: LD_INT 3
19129: DOUBLE
19130: EQUAL
19131: IFTRUE 19135
19133: GO 19185
19135: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19136: LD_ADDR_VAR 0 3
19140: PUSH
19141: LD_INT 13
19143: PUSH
19144: LD_INT 14
19146: PUSH
19147: LD_INT 2
19149: PUSH
19150: LD_INT 3
19152: PUSH
19153: LD_INT 4
19155: PUSH
19156: LD_INT 5
19158: PUSH
19159: LD_INT 21
19161: PUSH
19162: LD_INT 22
19164: PUSH
19165: LD_INT 23
19167: PUSH
19168: LD_INT 24
19170: PUSH
19171: EMPTY
19172: LIST
19173: LIST
19174: LIST
19175: LIST
19176: LIST
19177: LIST
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: ST_TO_ADDR
19183: GO 19186
19185: POP
// result := ( chassis in result ) ;
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 1
19195: PUSH
19196: LD_VAR 0 3
19200: IN
19201: ST_TO_ADDR
// end ;
19202: LD_VAR 0 3
19206: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19207: LD_INT 0
19209: PPUSH
// if not chassis or not weapon then
19210: LD_VAR 0 1
19214: NOT
19215: PUSH
19216: LD_VAR 0 2
19220: NOT
19221: OR
19222: IFFALSE 19226
// exit ;
19224: GO 20252
// case weapon of us_machine_gun :
19226: LD_VAR 0 2
19230: PUSH
19231: LD_INT 2
19233: DOUBLE
19234: EQUAL
19235: IFTRUE 19239
19237: GO 19269
19239: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19240: LD_ADDR_VAR 0 3
19244: PUSH
19245: LD_INT 1
19247: PUSH
19248: LD_INT 2
19250: PUSH
19251: LD_INT 3
19253: PUSH
19254: LD_INT 4
19256: PUSH
19257: LD_INT 5
19259: PUSH
19260: EMPTY
19261: LIST
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: ST_TO_ADDR
19267: GO 20236
19269: LD_INT 3
19271: DOUBLE
19272: EQUAL
19273: IFTRUE 19277
19275: GO 19307
19277: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19278: LD_ADDR_VAR 0 3
19282: PUSH
19283: LD_INT 1
19285: PUSH
19286: LD_INT 2
19288: PUSH
19289: LD_INT 3
19291: PUSH
19292: LD_INT 4
19294: PUSH
19295: LD_INT 5
19297: PUSH
19298: EMPTY
19299: LIST
19300: LIST
19301: LIST
19302: LIST
19303: LIST
19304: ST_TO_ADDR
19305: GO 20236
19307: LD_INT 11
19309: DOUBLE
19310: EQUAL
19311: IFTRUE 19315
19313: GO 19345
19315: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19316: LD_ADDR_VAR 0 3
19320: PUSH
19321: LD_INT 1
19323: PUSH
19324: LD_INT 2
19326: PUSH
19327: LD_INT 3
19329: PUSH
19330: LD_INT 4
19332: PUSH
19333: LD_INT 5
19335: PUSH
19336: EMPTY
19337: LIST
19338: LIST
19339: LIST
19340: LIST
19341: LIST
19342: ST_TO_ADDR
19343: GO 20236
19345: LD_INT 4
19347: DOUBLE
19348: EQUAL
19349: IFTRUE 19353
19351: GO 19379
19353: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19354: LD_ADDR_VAR 0 3
19358: PUSH
19359: LD_INT 2
19361: PUSH
19362: LD_INT 3
19364: PUSH
19365: LD_INT 4
19367: PUSH
19368: LD_INT 5
19370: PUSH
19371: EMPTY
19372: LIST
19373: LIST
19374: LIST
19375: LIST
19376: ST_TO_ADDR
19377: GO 20236
19379: LD_INT 5
19381: DOUBLE
19382: EQUAL
19383: IFTRUE 19387
19385: GO 19413
19387: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19388: LD_ADDR_VAR 0 3
19392: PUSH
19393: LD_INT 2
19395: PUSH
19396: LD_INT 3
19398: PUSH
19399: LD_INT 4
19401: PUSH
19402: LD_INT 5
19404: PUSH
19405: EMPTY
19406: LIST
19407: LIST
19408: LIST
19409: LIST
19410: ST_TO_ADDR
19411: GO 20236
19413: LD_INT 9
19415: DOUBLE
19416: EQUAL
19417: IFTRUE 19421
19419: GO 19447
19421: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19422: LD_ADDR_VAR 0 3
19426: PUSH
19427: LD_INT 2
19429: PUSH
19430: LD_INT 3
19432: PUSH
19433: LD_INT 4
19435: PUSH
19436: LD_INT 5
19438: PUSH
19439: EMPTY
19440: LIST
19441: LIST
19442: LIST
19443: LIST
19444: ST_TO_ADDR
19445: GO 20236
19447: LD_INT 7
19449: DOUBLE
19450: EQUAL
19451: IFTRUE 19455
19453: GO 19481
19455: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19456: LD_ADDR_VAR 0 3
19460: PUSH
19461: LD_INT 2
19463: PUSH
19464: LD_INT 3
19466: PUSH
19467: LD_INT 4
19469: PUSH
19470: LD_INT 5
19472: PUSH
19473: EMPTY
19474: LIST
19475: LIST
19476: LIST
19477: LIST
19478: ST_TO_ADDR
19479: GO 20236
19481: LD_INT 12
19483: DOUBLE
19484: EQUAL
19485: IFTRUE 19489
19487: GO 19515
19489: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19490: LD_ADDR_VAR 0 3
19494: PUSH
19495: LD_INT 2
19497: PUSH
19498: LD_INT 3
19500: PUSH
19501: LD_INT 4
19503: PUSH
19504: LD_INT 5
19506: PUSH
19507: EMPTY
19508: LIST
19509: LIST
19510: LIST
19511: LIST
19512: ST_TO_ADDR
19513: GO 20236
19515: LD_INT 13
19517: DOUBLE
19518: EQUAL
19519: IFTRUE 19523
19521: GO 19549
19523: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19524: LD_ADDR_VAR 0 3
19528: PUSH
19529: LD_INT 2
19531: PUSH
19532: LD_INT 3
19534: PUSH
19535: LD_INT 4
19537: PUSH
19538: LD_INT 5
19540: PUSH
19541: EMPTY
19542: LIST
19543: LIST
19544: LIST
19545: LIST
19546: ST_TO_ADDR
19547: GO 20236
19549: LD_INT 14
19551: DOUBLE
19552: EQUAL
19553: IFTRUE 19557
19555: GO 19575
19557: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19558: LD_ADDR_VAR 0 3
19562: PUSH
19563: LD_INT 4
19565: PUSH
19566: LD_INT 5
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: ST_TO_ADDR
19573: GO 20236
19575: LD_INT 6
19577: DOUBLE
19578: EQUAL
19579: IFTRUE 19583
19581: GO 19601
19583: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19584: LD_ADDR_VAR 0 3
19588: PUSH
19589: LD_INT 4
19591: PUSH
19592: LD_INT 5
19594: PUSH
19595: EMPTY
19596: LIST
19597: LIST
19598: ST_TO_ADDR
19599: GO 20236
19601: LD_INT 10
19603: DOUBLE
19604: EQUAL
19605: IFTRUE 19609
19607: GO 19627
19609: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19610: LD_ADDR_VAR 0 3
19614: PUSH
19615: LD_INT 4
19617: PUSH
19618: LD_INT 5
19620: PUSH
19621: EMPTY
19622: LIST
19623: LIST
19624: ST_TO_ADDR
19625: GO 20236
19627: LD_INT 22
19629: DOUBLE
19630: EQUAL
19631: IFTRUE 19635
19633: GO 19661
19635: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19636: LD_ADDR_VAR 0 3
19640: PUSH
19641: LD_INT 11
19643: PUSH
19644: LD_INT 12
19646: PUSH
19647: LD_INT 13
19649: PUSH
19650: LD_INT 14
19652: PUSH
19653: EMPTY
19654: LIST
19655: LIST
19656: LIST
19657: LIST
19658: ST_TO_ADDR
19659: GO 20236
19661: LD_INT 23
19663: DOUBLE
19664: EQUAL
19665: IFTRUE 19669
19667: GO 19695
19669: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19670: LD_ADDR_VAR 0 3
19674: PUSH
19675: LD_INT 11
19677: PUSH
19678: LD_INT 12
19680: PUSH
19681: LD_INT 13
19683: PUSH
19684: LD_INT 14
19686: PUSH
19687: EMPTY
19688: LIST
19689: LIST
19690: LIST
19691: LIST
19692: ST_TO_ADDR
19693: GO 20236
19695: LD_INT 24
19697: DOUBLE
19698: EQUAL
19699: IFTRUE 19703
19701: GO 19729
19703: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19704: LD_ADDR_VAR 0 3
19708: PUSH
19709: LD_INT 11
19711: PUSH
19712: LD_INT 12
19714: PUSH
19715: LD_INT 13
19717: PUSH
19718: LD_INT 14
19720: PUSH
19721: EMPTY
19722: LIST
19723: LIST
19724: LIST
19725: LIST
19726: ST_TO_ADDR
19727: GO 20236
19729: LD_INT 30
19731: DOUBLE
19732: EQUAL
19733: IFTRUE 19737
19735: GO 19763
19737: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19738: LD_ADDR_VAR 0 3
19742: PUSH
19743: LD_INT 11
19745: PUSH
19746: LD_INT 12
19748: PUSH
19749: LD_INT 13
19751: PUSH
19752: LD_INT 14
19754: PUSH
19755: EMPTY
19756: LIST
19757: LIST
19758: LIST
19759: LIST
19760: ST_TO_ADDR
19761: GO 20236
19763: LD_INT 25
19765: DOUBLE
19766: EQUAL
19767: IFTRUE 19771
19769: GO 19789
19771: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19772: LD_ADDR_VAR 0 3
19776: PUSH
19777: LD_INT 13
19779: PUSH
19780: LD_INT 14
19782: PUSH
19783: EMPTY
19784: LIST
19785: LIST
19786: ST_TO_ADDR
19787: GO 20236
19789: LD_INT 27
19791: DOUBLE
19792: EQUAL
19793: IFTRUE 19797
19795: GO 19815
19797: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19798: LD_ADDR_VAR 0 3
19802: PUSH
19803: LD_INT 13
19805: PUSH
19806: LD_INT 14
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: ST_TO_ADDR
19813: GO 20236
19815: LD_INT 28
19817: DOUBLE
19818: EQUAL
19819: IFTRUE 19823
19821: GO 19841
19823: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19824: LD_ADDR_VAR 0 3
19828: PUSH
19829: LD_INT 13
19831: PUSH
19832: LD_INT 14
19834: PUSH
19835: EMPTY
19836: LIST
19837: LIST
19838: ST_TO_ADDR
19839: GO 20236
19841: LD_INT 29
19843: DOUBLE
19844: EQUAL
19845: IFTRUE 19849
19847: GO 19867
19849: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19850: LD_ADDR_VAR 0 3
19854: PUSH
19855: LD_INT 13
19857: PUSH
19858: LD_INT 14
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: ST_TO_ADDR
19865: GO 20236
19867: LD_INT 31
19869: DOUBLE
19870: EQUAL
19871: IFTRUE 19875
19873: GO 19893
19875: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19876: LD_ADDR_VAR 0 3
19880: PUSH
19881: LD_INT 13
19883: PUSH
19884: LD_INT 14
19886: PUSH
19887: EMPTY
19888: LIST
19889: LIST
19890: ST_TO_ADDR
19891: GO 20236
19893: LD_INT 26
19895: DOUBLE
19896: EQUAL
19897: IFTRUE 19901
19899: GO 19919
19901: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19902: LD_ADDR_VAR 0 3
19906: PUSH
19907: LD_INT 13
19909: PUSH
19910: LD_INT 14
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: ST_TO_ADDR
19917: GO 20236
19919: LD_INT 42
19921: DOUBLE
19922: EQUAL
19923: IFTRUE 19927
19925: GO 19953
19927: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19928: LD_ADDR_VAR 0 3
19932: PUSH
19933: LD_INT 21
19935: PUSH
19936: LD_INT 22
19938: PUSH
19939: LD_INT 23
19941: PUSH
19942: LD_INT 24
19944: PUSH
19945: EMPTY
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: ST_TO_ADDR
19951: GO 20236
19953: LD_INT 43
19955: DOUBLE
19956: EQUAL
19957: IFTRUE 19961
19959: GO 19987
19961: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19962: LD_ADDR_VAR 0 3
19966: PUSH
19967: LD_INT 21
19969: PUSH
19970: LD_INT 22
19972: PUSH
19973: LD_INT 23
19975: PUSH
19976: LD_INT 24
19978: PUSH
19979: EMPTY
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: ST_TO_ADDR
19985: GO 20236
19987: LD_INT 44
19989: DOUBLE
19990: EQUAL
19991: IFTRUE 19995
19993: GO 20021
19995: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19996: LD_ADDR_VAR 0 3
20000: PUSH
20001: LD_INT 21
20003: PUSH
20004: LD_INT 22
20006: PUSH
20007: LD_INT 23
20009: PUSH
20010: LD_INT 24
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: LIST
20017: LIST
20018: ST_TO_ADDR
20019: GO 20236
20021: LD_INT 45
20023: DOUBLE
20024: EQUAL
20025: IFTRUE 20029
20027: GO 20055
20029: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20030: LD_ADDR_VAR 0 3
20034: PUSH
20035: LD_INT 21
20037: PUSH
20038: LD_INT 22
20040: PUSH
20041: LD_INT 23
20043: PUSH
20044: LD_INT 24
20046: PUSH
20047: EMPTY
20048: LIST
20049: LIST
20050: LIST
20051: LIST
20052: ST_TO_ADDR
20053: GO 20236
20055: LD_INT 49
20057: DOUBLE
20058: EQUAL
20059: IFTRUE 20063
20061: GO 20089
20063: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20064: LD_ADDR_VAR 0 3
20068: PUSH
20069: LD_INT 21
20071: PUSH
20072: LD_INT 22
20074: PUSH
20075: LD_INT 23
20077: PUSH
20078: LD_INT 24
20080: PUSH
20081: EMPTY
20082: LIST
20083: LIST
20084: LIST
20085: LIST
20086: ST_TO_ADDR
20087: GO 20236
20089: LD_INT 51
20091: DOUBLE
20092: EQUAL
20093: IFTRUE 20097
20095: GO 20123
20097: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20098: LD_ADDR_VAR 0 3
20102: PUSH
20103: LD_INT 21
20105: PUSH
20106: LD_INT 22
20108: PUSH
20109: LD_INT 23
20111: PUSH
20112: LD_INT 24
20114: PUSH
20115: EMPTY
20116: LIST
20117: LIST
20118: LIST
20119: LIST
20120: ST_TO_ADDR
20121: GO 20236
20123: LD_INT 52
20125: DOUBLE
20126: EQUAL
20127: IFTRUE 20131
20129: GO 20157
20131: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20132: LD_ADDR_VAR 0 3
20136: PUSH
20137: LD_INT 21
20139: PUSH
20140: LD_INT 22
20142: PUSH
20143: LD_INT 23
20145: PUSH
20146: LD_INT 24
20148: PUSH
20149: EMPTY
20150: LIST
20151: LIST
20152: LIST
20153: LIST
20154: ST_TO_ADDR
20155: GO 20236
20157: LD_INT 53
20159: DOUBLE
20160: EQUAL
20161: IFTRUE 20165
20163: GO 20183
20165: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20166: LD_ADDR_VAR 0 3
20170: PUSH
20171: LD_INT 23
20173: PUSH
20174: LD_INT 24
20176: PUSH
20177: EMPTY
20178: LIST
20179: LIST
20180: ST_TO_ADDR
20181: GO 20236
20183: LD_INT 46
20185: DOUBLE
20186: EQUAL
20187: IFTRUE 20191
20189: GO 20209
20191: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20192: LD_ADDR_VAR 0 3
20196: PUSH
20197: LD_INT 23
20199: PUSH
20200: LD_INT 24
20202: PUSH
20203: EMPTY
20204: LIST
20205: LIST
20206: ST_TO_ADDR
20207: GO 20236
20209: LD_INT 47
20211: DOUBLE
20212: EQUAL
20213: IFTRUE 20217
20215: GO 20235
20217: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20218: LD_ADDR_VAR 0 3
20222: PUSH
20223: LD_INT 23
20225: PUSH
20226: LD_INT 24
20228: PUSH
20229: EMPTY
20230: LIST
20231: LIST
20232: ST_TO_ADDR
20233: GO 20236
20235: POP
// result := ( chassis in result ) ;
20236: LD_ADDR_VAR 0 3
20240: PUSH
20241: LD_VAR 0 1
20245: PUSH
20246: LD_VAR 0 3
20250: IN
20251: ST_TO_ADDR
// end ;
20252: LD_VAR 0 3
20256: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20257: LD_INT 0
20259: PPUSH
20260: PPUSH
20261: PPUSH
20262: PPUSH
20263: PPUSH
20264: PPUSH
20265: PPUSH
// result := array ;
20266: LD_ADDR_VAR 0 5
20270: PUSH
20271: LD_VAR 0 1
20275: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20276: LD_VAR 0 1
20280: NOT
20281: PUSH
20282: LD_VAR 0 2
20286: NOT
20287: OR
20288: PUSH
20289: LD_VAR 0 3
20293: NOT
20294: OR
20295: PUSH
20296: LD_VAR 0 2
20300: PUSH
20301: LD_VAR 0 1
20305: GREATER
20306: OR
20307: PUSH
20308: LD_VAR 0 3
20312: PUSH
20313: LD_VAR 0 1
20317: GREATER
20318: OR
20319: IFFALSE 20323
// exit ;
20321: GO 20619
// if direction then
20323: LD_VAR 0 4
20327: IFFALSE 20391
// begin d := 1 ;
20329: LD_ADDR_VAR 0 9
20333: PUSH
20334: LD_INT 1
20336: ST_TO_ADDR
// if i_from > i_to then
20337: LD_VAR 0 2
20341: PUSH
20342: LD_VAR 0 3
20346: GREATER
20347: IFFALSE 20373
// length := ( array - i_from ) + i_to else
20349: LD_ADDR_VAR 0 11
20353: PUSH
20354: LD_VAR 0 1
20358: PUSH
20359: LD_VAR 0 2
20363: MINUS
20364: PUSH
20365: LD_VAR 0 3
20369: PLUS
20370: ST_TO_ADDR
20371: GO 20389
// length := i_to - i_from ;
20373: LD_ADDR_VAR 0 11
20377: PUSH
20378: LD_VAR 0 3
20382: PUSH
20383: LD_VAR 0 2
20387: MINUS
20388: ST_TO_ADDR
// end else
20389: GO 20452
// begin d := - 1 ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 1
20398: NEG
20399: ST_TO_ADDR
// if i_from > i_to then
20400: LD_VAR 0 2
20404: PUSH
20405: LD_VAR 0 3
20409: GREATER
20410: IFFALSE 20430
// length := i_from - i_to else
20412: LD_ADDR_VAR 0 11
20416: PUSH
20417: LD_VAR 0 2
20421: PUSH
20422: LD_VAR 0 3
20426: MINUS
20427: ST_TO_ADDR
20428: GO 20452
// length := ( array - i_to ) + i_from ;
20430: LD_ADDR_VAR 0 11
20434: PUSH
20435: LD_VAR 0 1
20439: PUSH
20440: LD_VAR 0 3
20444: MINUS
20445: PUSH
20446: LD_VAR 0 2
20450: PLUS
20451: ST_TO_ADDR
// end ; if not length then
20452: LD_VAR 0 11
20456: NOT
20457: IFFALSE 20461
// exit ;
20459: GO 20619
// tmp := array ;
20461: LD_ADDR_VAR 0 10
20465: PUSH
20466: LD_VAR 0 1
20470: ST_TO_ADDR
// for i = 1 to length do
20471: LD_ADDR_VAR 0 6
20475: PUSH
20476: DOUBLE
20477: LD_INT 1
20479: DEC
20480: ST_TO_ADDR
20481: LD_VAR 0 11
20485: PUSH
20486: FOR_TO
20487: IFFALSE 20607
// begin for j = 1 to array do
20489: LD_ADDR_VAR 0 7
20493: PUSH
20494: DOUBLE
20495: LD_INT 1
20497: DEC
20498: ST_TO_ADDR
20499: LD_VAR 0 1
20503: PUSH
20504: FOR_TO
20505: IFFALSE 20593
// begin k := j + d ;
20507: LD_ADDR_VAR 0 8
20511: PUSH
20512: LD_VAR 0 7
20516: PUSH
20517: LD_VAR 0 9
20521: PLUS
20522: ST_TO_ADDR
// if k > array then
20523: LD_VAR 0 8
20527: PUSH
20528: LD_VAR 0 1
20532: GREATER
20533: IFFALSE 20543
// k := 1 ;
20535: LD_ADDR_VAR 0 8
20539: PUSH
20540: LD_INT 1
20542: ST_TO_ADDR
// if not k then
20543: LD_VAR 0 8
20547: NOT
20548: IFFALSE 20560
// k := array ;
20550: LD_ADDR_VAR 0 8
20554: PUSH
20555: LD_VAR 0 1
20559: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20560: LD_ADDR_VAR 0 10
20564: PUSH
20565: LD_VAR 0 10
20569: PPUSH
20570: LD_VAR 0 8
20574: PPUSH
20575: LD_VAR 0 1
20579: PUSH
20580: LD_VAR 0 7
20584: ARRAY
20585: PPUSH
20586: CALL_OW 1
20590: ST_TO_ADDR
// end ;
20591: GO 20504
20593: POP
20594: POP
// array := tmp ;
20595: LD_ADDR_VAR 0 1
20599: PUSH
20600: LD_VAR 0 10
20604: ST_TO_ADDR
// end ;
20605: GO 20486
20607: POP
20608: POP
// result := array ;
20609: LD_ADDR_VAR 0 5
20613: PUSH
20614: LD_VAR 0 1
20618: ST_TO_ADDR
// end ;
20619: LD_VAR 0 5
20623: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20624: LD_INT 0
20626: PPUSH
20627: PPUSH
// result := 0 ;
20628: LD_ADDR_VAR 0 3
20632: PUSH
20633: LD_INT 0
20635: ST_TO_ADDR
// if not array or not value in array then
20636: LD_VAR 0 1
20640: NOT
20641: PUSH
20642: LD_VAR 0 2
20646: PUSH
20647: LD_VAR 0 1
20651: IN
20652: NOT
20653: OR
20654: IFFALSE 20658
// exit ;
20656: GO 20712
// for i = 1 to array do
20658: LD_ADDR_VAR 0 4
20662: PUSH
20663: DOUBLE
20664: LD_INT 1
20666: DEC
20667: ST_TO_ADDR
20668: LD_VAR 0 1
20672: PUSH
20673: FOR_TO
20674: IFFALSE 20710
// if value = array [ i ] then
20676: LD_VAR 0 2
20680: PUSH
20681: LD_VAR 0 1
20685: PUSH
20686: LD_VAR 0 4
20690: ARRAY
20691: EQUAL
20692: IFFALSE 20708
// begin result := i ;
20694: LD_ADDR_VAR 0 3
20698: PUSH
20699: LD_VAR 0 4
20703: ST_TO_ADDR
// exit ;
20704: POP
20705: POP
20706: GO 20712
// end ;
20708: GO 20673
20710: POP
20711: POP
// end ;
20712: LD_VAR 0 3
20716: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20717: LD_INT 0
20719: PPUSH
// vc_chassis := chassis ;
20720: LD_ADDR_OWVAR 37
20724: PUSH
20725: LD_VAR 0 1
20729: ST_TO_ADDR
// vc_engine := engine ;
20730: LD_ADDR_OWVAR 39
20734: PUSH
20735: LD_VAR 0 2
20739: ST_TO_ADDR
// vc_control := control ;
20740: LD_ADDR_OWVAR 38
20744: PUSH
20745: LD_VAR 0 3
20749: ST_TO_ADDR
// vc_weapon := weapon ;
20750: LD_ADDR_OWVAR 40
20754: PUSH
20755: LD_VAR 0 4
20759: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20760: LD_ADDR_OWVAR 41
20764: PUSH
20765: LD_VAR 0 5
20769: ST_TO_ADDR
// end ;
20770: LD_VAR 0 6
20774: RET
// export function WantPlant ( unit ) ; var task ; begin
20775: LD_INT 0
20777: PPUSH
20778: PPUSH
// result := false ;
20779: LD_ADDR_VAR 0 2
20783: PUSH
20784: LD_INT 0
20786: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20787: LD_ADDR_VAR 0 3
20791: PUSH
20792: LD_VAR 0 1
20796: PPUSH
20797: CALL_OW 437
20801: ST_TO_ADDR
// if task then
20802: LD_VAR 0 3
20806: IFFALSE 20834
// if task [ 1 ] [ 1 ] = p then
20808: LD_VAR 0 3
20812: PUSH
20813: LD_INT 1
20815: ARRAY
20816: PUSH
20817: LD_INT 1
20819: ARRAY
20820: PUSH
20821: LD_STRING p
20823: EQUAL
20824: IFFALSE 20834
// result := true ;
20826: LD_ADDR_VAR 0 2
20830: PUSH
20831: LD_INT 1
20833: ST_TO_ADDR
// end ;
20834: LD_VAR 0 2
20838: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20839: LD_INT 0
20841: PPUSH
20842: PPUSH
20843: PPUSH
20844: PPUSH
// if pos < 1 then
20845: LD_VAR 0 2
20849: PUSH
20850: LD_INT 1
20852: LESS
20853: IFFALSE 20857
// exit ;
20855: GO 21160
// if pos = 1 then
20857: LD_VAR 0 2
20861: PUSH
20862: LD_INT 1
20864: EQUAL
20865: IFFALSE 20898
// result := Replace ( arr , pos [ 1 ] , value ) else
20867: LD_ADDR_VAR 0 4
20871: PUSH
20872: LD_VAR 0 1
20876: PPUSH
20877: LD_VAR 0 2
20881: PUSH
20882: LD_INT 1
20884: ARRAY
20885: PPUSH
20886: LD_VAR 0 3
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
20896: GO 21160
// begin tmp := arr ;
20898: LD_ADDR_VAR 0 6
20902: PUSH
20903: LD_VAR 0 1
20907: ST_TO_ADDR
// s_arr := [ tmp ] ;
20908: LD_ADDR_VAR 0 7
20912: PUSH
20913: LD_VAR 0 6
20917: PUSH
20918: EMPTY
20919: LIST
20920: ST_TO_ADDR
// for i = 1 to pos - 1 do
20921: LD_ADDR_VAR 0 5
20925: PUSH
20926: DOUBLE
20927: LD_INT 1
20929: DEC
20930: ST_TO_ADDR
20931: LD_VAR 0 2
20935: PUSH
20936: LD_INT 1
20938: MINUS
20939: PUSH
20940: FOR_TO
20941: IFFALSE 20986
// begin tmp := tmp [ pos [ i ] ] ;
20943: LD_ADDR_VAR 0 6
20947: PUSH
20948: LD_VAR 0 6
20952: PUSH
20953: LD_VAR 0 2
20957: PUSH
20958: LD_VAR 0 5
20962: ARRAY
20963: ARRAY
20964: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20965: LD_ADDR_VAR 0 7
20969: PUSH
20970: LD_VAR 0 7
20974: PUSH
20975: LD_VAR 0 6
20979: PUSH
20980: EMPTY
20981: LIST
20982: ADD
20983: ST_TO_ADDR
// end ;
20984: GO 20940
20986: POP
20987: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20988: LD_ADDR_VAR 0 6
20992: PUSH
20993: LD_VAR 0 6
20997: PPUSH
20998: LD_VAR 0 2
21002: PUSH
21003: LD_VAR 0 2
21007: ARRAY
21008: PPUSH
21009: LD_VAR 0 3
21013: PPUSH
21014: CALL_OW 1
21018: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21019: LD_ADDR_VAR 0 7
21023: PUSH
21024: LD_VAR 0 7
21028: PPUSH
21029: LD_VAR 0 7
21033: PPUSH
21034: LD_VAR 0 6
21038: PPUSH
21039: CALL_OW 1
21043: ST_TO_ADDR
// for i = s_arr downto 2 do
21044: LD_ADDR_VAR 0 5
21048: PUSH
21049: DOUBLE
21050: LD_VAR 0 7
21054: INC
21055: ST_TO_ADDR
21056: LD_INT 2
21058: PUSH
21059: FOR_DOWNTO
21060: IFFALSE 21144
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21062: LD_ADDR_VAR 0 6
21066: PUSH
21067: LD_VAR 0 7
21071: PUSH
21072: LD_VAR 0 5
21076: PUSH
21077: LD_INT 1
21079: MINUS
21080: ARRAY
21081: PPUSH
21082: LD_VAR 0 2
21086: PUSH
21087: LD_VAR 0 5
21091: PUSH
21092: LD_INT 1
21094: MINUS
21095: ARRAY
21096: PPUSH
21097: LD_VAR 0 7
21101: PUSH
21102: LD_VAR 0 5
21106: ARRAY
21107: PPUSH
21108: CALL_OW 1
21112: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21113: LD_ADDR_VAR 0 7
21117: PUSH
21118: LD_VAR 0 7
21122: PPUSH
21123: LD_VAR 0 5
21127: PUSH
21128: LD_INT 1
21130: MINUS
21131: PPUSH
21132: LD_VAR 0 6
21136: PPUSH
21137: CALL_OW 1
21141: ST_TO_ADDR
// end ;
21142: GO 21059
21144: POP
21145: POP
// result := s_arr [ 1 ] ;
21146: LD_ADDR_VAR 0 4
21150: PUSH
21151: LD_VAR 0 7
21155: PUSH
21156: LD_INT 1
21158: ARRAY
21159: ST_TO_ADDR
// end ; end ;
21160: LD_VAR 0 4
21164: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21165: LD_INT 0
21167: PPUSH
21168: PPUSH
// if not list then
21169: LD_VAR 0 1
21173: NOT
21174: IFFALSE 21178
// exit ;
21176: GO 21269
// i := list [ pos1 ] ;
21178: LD_ADDR_VAR 0 5
21182: PUSH
21183: LD_VAR 0 1
21187: PUSH
21188: LD_VAR 0 2
21192: ARRAY
21193: ST_TO_ADDR
// if not i then
21194: LD_VAR 0 5
21198: NOT
21199: IFFALSE 21203
// exit ;
21201: GO 21269
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21203: LD_ADDR_VAR 0 1
21207: PUSH
21208: LD_VAR 0 1
21212: PPUSH
21213: LD_VAR 0 2
21217: PPUSH
21218: LD_VAR 0 1
21222: PUSH
21223: LD_VAR 0 3
21227: ARRAY
21228: PPUSH
21229: CALL_OW 1
21233: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21234: LD_ADDR_VAR 0 1
21238: PUSH
21239: LD_VAR 0 1
21243: PPUSH
21244: LD_VAR 0 3
21248: PPUSH
21249: LD_VAR 0 5
21253: PPUSH
21254: CALL_OW 1
21258: ST_TO_ADDR
// result := list ;
21259: LD_ADDR_VAR 0 4
21263: PUSH
21264: LD_VAR 0 1
21268: ST_TO_ADDR
// end ;
21269: LD_VAR 0 4
21273: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21274: LD_INT 0
21276: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21277: LD_ADDR_VAR 0 5
21281: PUSH
21282: LD_VAR 0 1
21286: PPUSH
21287: CALL_OW 250
21291: PPUSH
21292: LD_VAR 0 1
21296: PPUSH
21297: CALL_OW 251
21301: PPUSH
21302: LD_VAR 0 2
21306: PPUSH
21307: LD_VAR 0 3
21311: PPUSH
21312: LD_VAR 0 4
21316: PPUSH
21317: CALL 21327 0 5
21321: ST_TO_ADDR
// end ;
21322: LD_VAR 0 5
21326: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21327: LD_INT 0
21329: PPUSH
21330: PPUSH
21331: PPUSH
21332: PPUSH
// if not list then
21333: LD_VAR 0 3
21337: NOT
21338: IFFALSE 21342
// exit ;
21340: GO 21730
// result := [ ] ;
21342: LD_ADDR_VAR 0 6
21346: PUSH
21347: EMPTY
21348: ST_TO_ADDR
// for i in list do
21349: LD_ADDR_VAR 0 7
21353: PUSH
21354: LD_VAR 0 3
21358: PUSH
21359: FOR_IN
21360: IFFALSE 21562
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21362: LD_ADDR_VAR 0 9
21366: PUSH
21367: LD_VAR 0 7
21371: PPUSH
21372: LD_VAR 0 1
21376: PPUSH
21377: LD_VAR 0 2
21381: PPUSH
21382: CALL_OW 297
21386: ST_TO_ADDR
// if not result then
21387: LD_VAR 0 6
21391: NOT
21392: IFFALSE 21418
// result := [ [ i , tmp ] ] else
21394: LD_ADDR_VAR 0 6
21398: PUSH
21399: LD_VAR 0 7
21403: PUSH
21404: LD_VAR 0 9
21408: PUSH
21409: EMPTY
21410: LIST
21411: LIST
21412: PUSH
21413: EMPTY
21414: LIST
21415: ST_TO_ADDR
21416: GO 21560
// begin if result [ result ] [ 2 ] < tmp then
21418: LD_VAR 0 6
21422: PUSH
21423: LD_VAR 0 6
21427: ARRAY
21428: PUSH
21429: LD_INT 2
21431: ARRAY
21432: PUSH
21433: LD_VAR 0 9
21437: LESS
21438: IFFALSE 21480
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21440: LD_ADDR_VAR 0 6
21444: PUSH
21445: LD_VAR 0 6
21449: PPUSH
21450: LD_VAR 0 6
21454: PUSH
21455: LD_INT 1
21457: PLUS
21458: PPUSH
21459: LD_VAR 0 7
21463: PUSH
21464: LD_VAR 0 9
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: PPUSH
21473: CALL_OW 2
21477: ST_TO_ADDR
21478: GO 21560
// for j = 1 to result do
21480: LD_ADDR_VAR 0 8
21484: PUSH
21485: DOUBLE
21486: LD_INT 1
21488: DEC
21489: ST_TO_ADDR
21490: LD_VAR 0 6
21494: PUSH
21495: FOR_TO
21496: IFFALSE 21558
// begin if tmp < result [ j ] [ 2 ] then
21498: LD_VAR 0 9
21502: PUSH
21503: LD_VAR 0 6
21507: PUSH
21508: LD_VAR 0 8
21512: ARRAY
21513: PUSH
21514: LD_INT 2
21516: ARRAY
21517: LESS
21518: IFFALSE 21556
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21520: LD_ADDR_VAR 0 6
21524: PUSH
21525: LD_VAR 0 6
21529: PPUSH
21530: LD_VAR 0 8
21534: PPUSH
21535: LD_VAR 0 7
21539: PUSH
21540: LD_VAR 0 9
21544: PUSH
21545: EMPTY
21546: LIST
21547: LIST
21548: PPUSH
21549: CALL_OW 2
21553: ST_TO_ADDR
// break ;
21554: GO 21558
// end ; end ;
21556: GO 21495
21558: POP
21559: POP
// end ; end ;
21560: GO 21359
21562: POP
21563: POP
// if result and not asc then
21564: LD_VAR 0 6
21568: PUSH
21569: LD_VAR 0 4
21573: NOT
21574: AND
21575: IFFALSE 21650
// begin tmp := result ;
21577: LD_ADDR_VAR 0 9
21581: PUSH
21582: LD_VAR 0 6
21586: ST_TO_ADDR
// for i = tmp downto 1 do
21587: LD_ADDR_VAR 0 7
21591: PUSH
21592: DOUBLE
21593: LD_VAR 0 9
21597: INC
21598: ST_TO_ADDR
21599: LD_INT 1
21601: PUSH
21602: FOR_DOWNTO
21603: IFFALSE 21648
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21605: LD_ADDR_VAR 0 6
21609: PUSH
21610: LD_VAR 0 6
21614: PPUSH
21615: LD_VAR 0 9
21619: PUSH
21620: LD_VAR 0 7
21624: MINUS
21625: PUSH
21626: LD_INT 1
21628: PLUS
21629: PPUSH
21630: LD_VAR 0 9
21634: PUSH
21635: LD_VAR 0 7
21639: ARRAY
21640: PPUSH
21641: CALL_OW 1
21645: ST_TO_ADDR
21646: GO 21602
21648: POP
21649: POP
// end ; tmp := [ ] ;
21650: LD_ADDR_VAR 0 9
21654: PUSH
21655: EMPTY
21656: ST_TO_ADDR
// if mode then
21657: LD_VAR 0 5
21661: IFFALSE 21730
// begin for i = 1 to result do
21663: LD_ADDR_VAR 0 7
21667: PUSH
21668: DOUBLE
21669: LD_INT 1
21671: DEC
21672: ST_TO_ADDR
21673: LD_VAR 0 6
21677: PUSH
21678: FOR_TO
21679: IFFALSE 21718
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21681: LD_ADDR_VAR 0 9
21685: PUSH
21686: LD_VAR 0 9
21690: PPUSH
21691: LD_VAR 0 7
21695: PPUSH
21696: LD_VAR 0 6
21700: PUSH
21701: LD_VAR 0 7
21705: ARRAY
21706: PUSH
21707: LD_INT 1
21709: ARRAY
21710: PPUSH
21711: CALL_OW 1
21715: ST_TO_ADDR
21716: GO 21678
21718: POP
21719: POP
// result := tmp ;
21720: LD_ADDR_VAR 0 6
21724: PUSH
21725: LD_VAR 0 9
21729: ST_TO_ADDR
// end ; end ;
21730: LD_VAR 0 6
21734: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21735: LD_INT 0
21737: PPUSH
21738: PPUSH
21739: PPUSH
21740: PPUSH
21741: PPUSH
21742: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21743: LD_ADDR_VAR 0 5
21747: PUSH
21748: LD_INT 0
21750: PUSH
21751: LD_INT 0
21753: PUSH
21754: LD_INT 0
21756: PUSH
21757: EMPTY
21758: PUSH
21759: EMPTY
21760: LIST
21761: LIST
21762: LIST
21763: LIST
21764: ST_TO_ADDR
// if not x or not y then
21765: LD_VAR 0 2
21769: NOT
21770: PUSH
21771: LD_VAR 0 3
21775: NOT
21776: OR
21777: IFFALSE 21781
// exit ;
21779: GO 23427
// if not range then
21781: LD_VAR 0 4
21785: NOT
21786: IFFALSE 21796
// range := 10 ;
21788: LD_ADDR_VAR 0 4
21792: PUSH
21793: LD_INT 10
21795: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21796: LD_ADDR_VAR 0 8
21800: PUSH
21801: LD_INT 81
21803: PUSH
21804: LD_VAR 0 1
21808: PUSH
21809: EMPTY
21810: LIST
21811: LIST
21812: PUSH
21813: LD_INT 92
21815: PUSH
21816: LD_VAR 0 2
21820: PUSH
21821: LD_VAR 0 3
21825: PUSH
21826: LD_VAR 0 4
21830: PUSH
21831: EMPTY
21832: LIST
21833: LIST
21834: LIST
21835: LIST
21836: PUSH
21837: LD_INT 3
21839: PUSH
21840: LD_INT 21
21842: PUSH
21843: LD_INT 3
21845: PUSH
21846: EMPTY
21847: LIST
21848: LIST
21849: PUSH
21850: EMPTY
21851: LIST
21852: LIST
21853: PUSH
21854: EMPTY
21855: LIST
21856: LIST
21857: LIST
21858: PPUSH
21859: CALL_OW 69
21863: ST_TO_ADDR
// if not tmp then
21864: LD_VAR 0 8
21868: NOT
21869: IFFALSE 21873
// exit ;
21871: GO 23427
// for i in tmp do
21873: LD_ADDR_VAR 0 6
21877: PUSH
21878: LD_VAR 0 8
21882: PUSH
21883: FOR_IN
21884: IFFALSE 23402
// begin points := [ 0 , 0 , 0 ] ;
21886: LD_ADDR_VAR 0 9
21890: PUSH
21891: LD_INT 0
21893: PUSH
21894: LD_INT 0
21896: PUSH
21897: LD_INT 0
21899: PUSH
21900: EMPTY
21901: LIST
21902: LIST
21903: LIST
21904: ST_TO_ADDR
// bpoints := 1 ;
21905: LD_ADDR_VAR 0 10
21909: PUSH
21910: LD_INT 1
21912: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21913: LD_VAR 0 6
21917: PPUSH
21918: CALL_OW 247
21922: PUSH
21923: LD_INT 1
21925: DOUBLE
21926: EQUAL
21927: IFTRUE 21931
21929: GO 22509
21931: POP
// begin if GetClass ( i ) = 1 then
21932: LD_VAR 0 6
21936: PPUSH
21937: CALL_OW 257
21941: PUSH
21942: LD_INT 1
21944: EQUAL
21945: IFFALSE 21966
// points := [ 10 , 5 , 3 ] ;
21947: LD_ADDR_VAR 0 9
21951: PUSH
21952: LD_INT 10
21954: PUSH
21955: LD_INT 5
21957: PUSH
21958: LD_INT 3
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: LIST
21965: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21966: LD_VAR 0 6
21970: PPUSH
21971: CALL_OW 257
21975: PUSH
21976: LD_INT 2
21978: PUSH
21979: LD_INT 3
21981: PUSH
21982: LD_INT 4
21984: PUSH
21985: EMPTY
21986: LIST
21987: LIST
21988: LIST
21989: IN
21990: IFFALSE 22011
// points := [ 3 , 2 , 1 ] ;
21992: LD_ADDR_VAR 0 9
21996: PUSH
21997: LD_INT 3
21999: PUSH
22000: LD_INT 2
22002: PUSH
22003: LD_INT 1
22005: PUSH
22006: EMPTY
22007: LIST
22008: LIST
22009: LIST
22010: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22011: LD_VAR 0 6
22015: PPUSH
22016: CALL_OW 257
22020: PUSH
22021: LD_INT 5
22023: EQUAL
22024: IFFALSE 22045
// points := [ 130 , 5 , 2 ] ;
22026: LD_ADDR_VAR 0 9
22030: PUSH
22031: LD_INT 130
22033: PUSH
22034: LD_INT 5
22036: PUSH
22037: LD_INT 2
22039: PUSH
22040: EMPTY
22041: LIST
22042: LIST
22043: LIST
22044: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22045: LD_VAR 0 6
22049: PPUSH
22050: CALL_OW 257
22054: PUSH
22055: LD_INT 8
22057: EQUAL
22058: IFFALSE 22079
// points := [ 35 , 35 , 30 ] ;
22060: LD_ADDR_VAR 0 9
22064: PUSH
22065: LD_INT 35
22067: PUSH
22068: LD_INT 35
22070: PUSH
22071: LD_INT 30
22073: PUSH
22074: EMPTY
22075: LIST
22076: LIST
22077: LIST
22078: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22079: LD_VAR 0 6
22083: PPUSH
22084: CALL_OW 257
22088: PUSH
22089: LD_INT 9
22091: EQUAL
22092: IFFALSE 22113
// points := [ 20 , 55 , 40 ] ;
22094: LD_ADDR_VAR 0 9
22098: PUSH
22099: LD_INT 20
22101: PUSH
22102: LD_INT 55
22104: PUSH
22105: LD_INT 40
22107: PUSH
22108: EMPTY
22109: LIST
22110: LIST
22111: LIST
22112: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22113: LD_VAR 0 6
22117: PPUSH
22118: CALL_OW 257
22122: PUSH
22123: LD_INT 12
22125: PUSH
22126: LD_INT 16
22128: PUSH
22129: EMPTY
22130: LIST
22131: LIST
22132: IN
22133: IFFALSE 22154
// points := [ 5 , 3 , 2 ] ;
22135: LD_ADDR_VAR 0 9
22139: PUSH
22140: LD_INT 5
22142: PUSH
22143: LD_INT 3
22145: PUSH
22146: LD_INT 2
22148: PUSH
22149: EMPTY
22150: LIST
22151: LIST
22152: LIST
22153: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22154: LD_VAR 0 6
22158: PPUSH
22159: CALL_OW 257
22163: PUSH
22164: LD_INT 17
22166: EQUAL
22167: IFFALSE 22188
// points := [ 100 , 50 , 75 ] ;
22169: LD_ADDR_VAR 0 9
22173: PUSH
22174: LD_INT 100
22176: PUSH
22177: LD_INT 50
22179: PUSH
22180: LD_INT 75
22182: PUSH
22183: EMPTY
22184: LIST
22185: LIST
22186: LIST
22187: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22188: LD_VAR 0 6
22192: PPUSH
22193: CALL_OW 257
22197: PUSH
22198: LD_INT 15
22200: EQUAL
22201: IFFALSE 22222
// points := [ 10 , 5 , 3 ] ;
22203: LD_ADDR_VAR 0 9
22207: PUSH
22208: LD_INT 10
22210: PUSH
22211: LD_INT 5
22213: PUSH
22214: LD_INT 3
22216: PUSH
22217: EMPTY
22218: LIST
22219: LIST
22220: LIST
22221: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22222: LD_VAR 0 6
22226: PPUSH
22227: CALL_OW 257
22231: PUSH
22232: LD_INT 14
22234: EQUAL
22235: IFFALSE 22256
// points := [ 10 , 0 , 0 ] ;
22237: LD_ADDR_VAR 0 9
22241: PUSH
22242: LD_INT 10
22244: PUSH
22245: LD_INT 0
22247: PUSH
22248: LD_INT 0
22250: PUSH
22251: EMPTY
22252: LIST
22253: LIST
22254: LIST
22255: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22256: LD_VAR 0 6
22260: PPUSH
22261: CALL_OW 257
22265: PUSH
22266: LD_INT 11
22268: EQUAL
22269: IFFALSE 22290
// points := [ 30 , 10 , 5 ] ;
22271: LD_ADDR_VAR 0 9
22275: PUSH
22276: LD_INT 30
22278: PUSH
22279: LD_INT 10
22281: PUSH
22282: LD_INT 5
22284: PUSH
22285: EMPTY
22286: LIST
22287: LIST
22288: LIST
22289: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22290: LD_VAR 0 1
22294: PPUSH
22295: LD_INT 5
22297: PPUSH
22298: CALL_OW 321
22302: PUSH
22303: LD_INT 2
22305: EQUAL
22306: IFFALSE 22323
// bpoints := bpoints * 1.8 ;
22308: LD_ADDR_VAR 0 10
22312: PUSH
22313: LD_VAR 0 10
22317: PUSH
22318: LD_REAL  1.80000000000000E+0000
22321: MUL
22322: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22323: LD_VAR 0 6
22327: PPUSH
22328: CALL_OW 257
22332: PUSH
22333: LD_INT 1
22335: PUSH
22336: LD_INT 2
22338: PUSH
22339: LD_INT 3
22341: PUSH
22342: LD_INT 4
22344: PUSH
22345: EMPTY
22346: LIST
22347: LIST
22348: LIST
22349: LIST
22350: IN
22351: PUSH
22352: LD_VAR 0 1
22356: PPUSH
22357: LD_INT 51
22359: PPUSH
22360: CALL_OW 321
22364: PUSH
22365: LD_INT 2
22367: EQUAL
22368: AND
22369: IFFALSE 22386
// bpoints := bpoints * 1.2 ;
22371: LD_ADDR_VAR 0 10
22375: PUSH
22376: LD_VAR 0 10
22380: PUSH
22381: LD_REAL  1.20000000000000E+0000
22384: MUL
22385: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22386: LD_VAR 0 6
22390: PPUSH
22391: CALL_OW 257
22395: PUSH
22396: LD_INT 5
22398: PUSH
22399: LD_INT 7
22401: PUSH
22402: LD_INT 9
22404: PUSH
22405: EMPTY
22406: LIST
22407: LIST
22408: LIST
22409: IN
22410: PUSH
22411: LD_VAR 0 1
22415: PPUSH
22416: LD_INT 52
22418: PPUSH
22419: CALL_OW 321
22423: PUSH
22424: LD_INT 2
22426: EQUAL
22427: AND
22428: IFFALSE 22445
// bpoints := bpoints * 1.5 ;
22430: LD_ADDR_VAR 0 10
22434: PUSH
22435: LD_VAR 0 10
22439: PUSH
22440: LD_REAL  1.50000000000000E+0000
22443: MUL
22444: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22445: LD_VAR 0 1
22449: PPUSH
22450: LD_INT 66
22452: PPUSH
22453: CALL_OW 321
22457: PUSH
22458: LD_INT 2
22460: EQUAL
22461: IFFALSE 22478
// bpoints := bpoints * 1.1 ;
22463: LD_ADDR_VAR 0 10
22467: PUSH
22468: LD_VAR 0 10
22472: PUSH
22473: LD_REAL  1.10000000000000E+0000
22476: MUL
22477: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22478: LD_ADDR_VAR 0 10
22482: PUSH
22483: LD_VAR 0 10
22487: PUSH
22488: LD_VAR 0 6
22492: PPUSH
22493: LD_INT 1
22495: PPUSH
22496: CALL_OW 259
22500: PUSH
22501: LD_REAL  1.15000000000000E+0000
22504: MUL
22505: MUL
22506: ST_TO_ADDR
// end ; unit_vehicle :
22507: GO 23331
22509: LD_INT 2
22511: DOUBLE
22512: EQUAL
22513: IFTRUE 22517
22515: GO 23319
22517: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22518: LD_VAR 0 6
22522: PPUSH
22523: CALL_OW 264
22527: PUSH
22528: LD_INT 2
22530: PUSH
22531: LD_INT 42
22533: PUSH
22534: LD_INT 24
22536: PUSH
22537: EMPTY
22538: LIST
22539: LIST
22540: LIST
22541: IN
22542: IFFALSE 22563
// points := [ 25 , 5 , 3 ] ;
22544: LD_ADDR_VAR 0 9
22548: PUSH
22549: LD_INT 25
22551: PUSH
22552: LD_INT 5
22554: PUSH
22555: LD_INT 3
22557: PUSH
22558: EMPTY
22559: LIST
22560: LIST
22561: LIST
22562: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22563: LD_VAR 0 6
22567: PPUSH
22568: CALL_OW 264
22572: PUSH
22573: LD_INT 4
22575: PUSH
22576: LD_INT 43
22578: PUSH
22579: LD_INT 25
22581: PUSH
22582: EMPTY
22583: LIST
22584: LIST
22585: LIST
22586: IN
22587: IFFALSE 22608
// points := [ 40 , 15 , 5 ] ;
22589: LD_ADDR_VAR 0 9
22593: PUSH
22594: LD_INT 40
22596: PUSH
22597: LD_INT 15
22599: PUSH
22600: LD_INT 5
22602: PUSH
22603: EMPTY
22604: LIST
22605: LIST
22606: LIST
22607: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22608: LD_VAR 0 6
22612: PPUSH
22613: CALL_OW 264
22617: PUSH
22618: LD_INT 3
22620: PUSH
22621: LD_INT 23
22623: PUSH
22624: EMPTY
22625: LIST
22626: LIST
22627: IN
22628: IFFALSE 22649
// points := [ 7 , 25 , 8 ] ;
22630: LD_ADDR_VAR 0 9
22634: PUSH
22635: LD_INT 7
22637: PUSH
22638: LD_INT 25
22640: PUSH
22641: LD_INT 8
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: LIST
22648: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22649: LD_VAR 0 6
22653: PPUSH
22654: CALL_OW 264
22658: PUSH
22659: LD_INT 5
22661: PUSH
22662: LD_INT 27
22664: PUSH
22665: LD_INT 44
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: LIST
22672: IN
22673: IFFALSE 22694
// points := [ 14 , 50 , 16 ] ;
22675: LD_ADDR_VAR 0 9
22679: PUSH
22680: LD_INT 14
22682: PUSH
22683: LD_INT 50
22685: PUSH
22686: LD_INT 16
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: LIST
22693: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22694: LD_VAR 0 6
22698: PPUSH
22699: CALL_OW 264
22703: PUSH
22704: LD_INT 6
22706: PUSH
22707: LD_INT 46
22709: PUSH
22710: EMPTY
22711: LIST
22712: LIST
22713: IN
22714: IFFALSE 22735
// points := [ 32 , 120 , 70 ] ;
22716: LD_ADDR_VAR 0 9
22720: PUSH
22721: LD_INT 32
22723: PUSH
22724: LD_INT 120
22726: PUSH
22727: LD_INT 70
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: LIST
22734: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22735: LD_VAR 0 6
22739: PPUSH
22740: CALL_OW 264
22744: PUSH
22745: LD_INT 7
22747: PUSH
22748: LD_INT 28
22750: PUSH
22751: LD_INT 45
22753: PUSH
22754: EMPTY
22755: LIST
22756: LIST
22757: LIST
22758: IN
22759: IFFALSE 22780
// points := [ 35 , 20 , 45 ] ;
22761: LD_ADDR_VAR 0 9
22765: PUSH
22766: LD_INT 35
22768: PUSH
22769: LD_INT 20
22771: PUSH
22772: LD_INT 45
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22780: LD_VAR 0 6
22784: PPUSH
22785: CALL_OW 264
22789: PUSH
22790: LD_INT 47
22792: PUSH
22793: EMPTY
22794: LIST
22795: IN
22796: IFFALSE 22817
// points := [ 67 , 45 , 75 ] ;
22798: LD_ADDR_VAR 0 9
22802: PUSH
22803: LD_INT 67
22805: PUSH
22806: LD_INT 45
22808: PUSH
22809: LD_INT 75
22811: PUSH
22812: EMPTY
22813: LIST
22814: LIST
22815: LIST
22816: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22817: LD_VAR 0 6
22821: PPUSH
22822: CALL_OW 264
22826: PUSH
22827: LD_INT 26
22829: PUSH
22830: EMPTY
22831: LIST
22832: IN
22833: IFFALSE 22854
// points := [ 120 , 30 , 80 ] ;
22835: LD_ADDR_VAR 0 9
22839: PUSH
22840: LD_INT 120
22842: PUSH
22843: LD_INT 30
22845: PUSH
22846: LD_INT 80
22848: PUSH
22849: EMPTY
22850: LIST
22851: LIST
22852: LIST
22853: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22854: LD_VAR 0 6
22858: PPUSH
22859: CALL_OW 264
22863: PUSH
22864: LD_INT 22
22866: PUSH
22867: EMPTY
22868: LIST
22869: IN
22870: IFFALSE 22891
// points := [ 40 , 1 , 1 ] ;
22872: LD_ADDR_VAR 0 9
22876: PUSH
22877: LD_INT 40
22879: PUSH
22880: LD_INT 1
22882: PUSH
22883: LD_INT 1
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: LIST
22890: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22891: LD_VAR 0 6
22895: PPUSH
22896: CALL_OW 264
22900: PUSH
22901: LD_INT 29
22903: PUSH
22904: EMPTY
22905: LIST
22906: IN
22907: IFFALSE 22928
// points := [ 70 , 200 , 400 ] ;
22909: LD_ADDR_VAR 0 9
22913: PUSH
22914: LD_INT 70
22916: PUSH
22917: LD_INT 200
22919: PUSH
22920: LD_INT 400
22922: PUSH
22923: EMPTY
22924: LIST
22925: LIST
22926: LIST
22927: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22928: LD_VAR 0 6
22932: PPUSH
22933: CALL_OW 264
22937: PUSH
22938: LD_INT 14
22940: PUSH
22941: LD_INT 53
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: IN
22948: IFFALSE 22969
// points := [ 40 , 10 , 20 ] ;
22950: LD_ADDR_VAR 0 9
22954: PUSH
22955: LD_INT 40
22957: PUSH
22958: LD_INT 10
22960: PUSH
22961: LD_INT 20
22963: PUSH
22964: EMPTY
22965: LIST
22966: LIST
22967: LIST
22968: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22969: LD_VAR 0 6
22973: PPUSH
22974: CALL_OW 264
22978: PUSH
22979: LD_INT 9
22981: PUSH
22982: EMPTY
22983: LIST
22984: IN
22985: IFFALSE 23006
// points := [ 5 , 70 , 20 ] ;
22987: LD_ADDR_VAR 0 9
22991: PUSH
22992: LD_INT 5
22994: PUSH
22995: LD_INT 70
22997: PUSH
22998: LD_INT 20
23000: PUSH
23001: EMPTY
23002: LIST
23003: LIST
23004: LIST
23005: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23006: LD_VAR 0 6
23010: PPUSH
23011: CALL_OW 264
23015: PUSH
23016: LD_INT 10
23018: PUSH
23019: EMPTY
23020: LIST
23021: IN
23022: IFFALSE 23043
// points := [ 35 , 110 , 70 ] ;
23024: LD_ADDR_VAR 0 9
23028: PUSH
23029: LD_INT 35
23031: PUSH
23032: LD_INT 110
23034: PUSH
23035: LD_INT 70
23037: PUSH
23038: EMPTY
23039: LIST
23040: LIST
23041: LIST
23042: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23043: LD_VAR 0 6
23047: PPUSH
23048: CALL_OW 265
23052: PUSH
23053: LD_INT 25
23055: EQUAL
23056: IFFALSE 23077
// points := [ 80 , 65 , 100 ] ;
23058: LD_ADDR_VAR 0 9
23062: PUSH
23063: LD_INT 80
23065: PUSH
23066: LD_INT 65
23068: PUSH
23069: LD_INT 100
23071: PUSH
23072: EMPTY
23073: LIST
23074: LIST
23075: LIST
23076: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23077: LD_VAR 0 6
23081: PPUSH
23082: CALL_OW 263
23086: PUSH
23087: LD_INT 1
23089: EQUAL
23090: IFFALSE 23125
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23092: LD_ADDR_VAR 0 10
23096: PUSH
23097: LD_VAR 0 10
23101: PUSH
23102: LD_VAR 0 6
23106: PPUSH
23107: CALL_OW 311
23111: PPUSH
23112: LD_INT 3
23114: PPUSH
23115: CALL_OW 259
23119: PUSH
23120: LD_INT 4
23122: MUL
23123: MUL
23124: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23125: LD_VAR 0 6
23129: PPUSH
23130: CALL_OW 263
23134: PUSH
23135: LD_INT 2
23137: EQUAL
23138: IFFALSE 23189
// begin j := IsControledBy ( i ) ;
23140: LD_ADDR_VAR 0 7
23144: PUSH
23145: LD_VAR 0 6
23149: PPUSH
23150: CALL_OW 312
23154: ST_TO_ADDR
// if j then
23155: LD_VAR 0 7
23159: IFFALSE 23189
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23161: LD_ADDR_VAR 0 10
23165: PUSH
23166: LD_VAR 0 10
23170: PUSH
23171: LD_VAR 0 7
23175: PPUSH
23176: LD_INT 3
23178: PPUSH
23179: CALL_OW 259
23183: PUSH
23184: LD_INT 3
23186: MUL
23187: MUL
23188: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23189: LD_VAR 0 6
23193: PPUSH
23194: CALL_OW 264
23198: PUSH
23199: LD_INT 5
23201: PUSH
23202: LD_INT 6
23204: PUSH
23205: LD_INT 46
23207: PUSH
23208: LD_INT 44
23210: PUSH
23211: LD_INT 47
23213: PUSH
23214: LD_INT 45
23216: PUSH
23217: LD_INT 28
23219: PUSH
23220: LD_INT 7
23222: PUSH
23223: LD_INT 27
23225: PUSH
23226: LD_INT 29
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: LIST
23233: LIST
23234: LIST
23235: LIST
23236: LIST
23237: LIST
23238: LIST
23239: LIST
23240: IN
23241: PUSH
23242: LD_VAR 0 1
23246: PPUSH
23247: LD_INT 52
23249: PPUSH
23250: CALL_OW 321
23254: PUSH
23255: LD_INT 2
23257: EQUAL
23258: AND
23259: IFFALSE 23276
// bpoints := bpoints * 1.2 ;
23261: LD_ADDR_VAR 0 10
23265: PUSH
23266: LD_VAR 0 10
23270: PUSH
23271: LD_REAL  1.20000000000000E+0000
23274: MUL
23275: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23276: LD_VAR 0 6
23280: PPUSH
23281: CALL_OW 264
23285: PUSH
23286: LD_INT 6
23288: PUSH
23289: LD_INT 46
23291: PUSH
23292: LD_INT 47
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: LIST
23299: IN
23300: IFFALSE 23317
// bpoints := bpoints * 1.2 ;
23302: LD_ADDR_VAR 0 10
23306: PUSH
23307: LD_VAR 0 10
23311: PUSH
23312: LD_REAL  1.20000000000000E+0000
23315: MUL
23316: ST_TO_ADDR
// end ; unit_building :
23317: GO 23331
23319: LD_INT 3
23321: DOUBLE
23322: EQUAL
23323: IFTRUE 23327
23325: GO 23330
23327: POP
// ; end ;
23328: GO 23331
23330: POP
// for j = 1 to 3 do
23331: LD_ADDR_VAR 0 7
23335: PUSH
23336: DOUBLE
23337: LD_INT 1
23339: DEC
23340: ST_TO_ADDR
23341: LD_INT 3
23343: PUSH
23344: FOR_TO
23345: IFFALSE 23398
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23347: LD_ADDR_VAR 0 5
23351: PUSH
23352: LD_VAR 0 5
23356: PPUSH
23357: LD_VAR 0 7
23361: PPUSH
23362: LD_VAR 0 5
23366: PUSH
23367: LD_VAR 0 7
23371: ARRAY
23372: PUSH
23373: LD_VAR 0 9
23377: PUSH
23378: LD_VAR 0 7
23382: ARRAY
23383: PUSH
23384: LD_VAR 0 10
23388: MUL
23389: PLUS
23390: PPUSH
23391: CALL_OW 1
23395: ST_TO_ADDR
23396: GO 23344
23398: POP
23399: POP
// end ;
23400: GO 21883
23402: POP
23403: POP
// result := Replace ( result , 4 , tmp ) ;
23404: LD_ADDR_VAR 0 5
23408: PUSH
23409: LD_VAR 0 5
23413: PPUSH
23414: LD_INT 4
23416: PPUSH
23417: LD_VAR 0 8
23421: PPUSH
23422: CALL_OW 1
23426: ST_TO_ADDR
// end ;
23427: LD_VAR 0 5
23431: RET
// export function DangerAtRange ( unit , range ) ; begin
23432: LD_INT 0
23434: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23435: LD_ADDR_VAR 0 3
23439: PUSH
23440: LD_VAR 0 1
23444: PPUSH
23445: CALL_OW 255
23449: PPUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: CALL_OW 250
23459: PPUSH
23460: LD_VAR 0 1
23464: PPUSH
23465: CALL_OW 251
23469: PPUSH
23470: LD_VAR 0 2
23474: PPUSH
23475: CALL 21735 0 4
23479: ST_TO_ADDR
// end ;
23480: LD_VAR 0 3
23484: RET
// export function DangerInArea ( side , area ) ; begin
23485: LD_INT 0
23487: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23488: LD_ADDR_VAR 0 3
23492: PUSH
23493: LD_VAR 0 2
23497: PPUSH
23498: LD_INT 81
23500: PUSH
23501: LD_VAR 0 1
23505: PUSH
23506: EMPTY
23507: LIST
23508: LIST
23509: PPUSH
23510: CALL_OW 70
23514: ST_TO_ADDR
// end ;
23515: LD_VAR 0 3
23519: RET
// export function IsExtension ( b ) ; begin
23520: LD_INT 0
23522: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23523: LD_ADDR_VAR 0 2
23527: PUSH
23528: LD_VAR 0 1
23532: PUSH
23533: LD_INT 23
23535: PUSH
23536: LD_INT 20
23538: PUSH
23539: LD_INT 22
23541: PUSH
23542: LD_INT 17
23544: PUSH
23545: LD_INT 24
23547: PUSH
23548: LD_INT 21
23550: PUSH
23551: LD_INT 19
23553: PUSH
23554: LD_INT 16
23556: PUSH
23557: LD_INT 25
23559: PUSH
23560: LD_INT 18
23562: PUSH
23563: EMPTY
23564: LIST
23565: LIST
23566: LIST
23567: LIST
23568: LIST
23569: LIST
23570: LIST
23571: LIST
23572: LIST
23573: LIST
23574: IN
23575: ST_TO_ADDR
// end ;
23576: LD_VAR 0 2
23580: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23581: LD_INT 0
23583: PPUSH
23584: PPUSH
23585: PPUSH
// result := [ ] ;
23586: LD_ADDR_VAR 0 3
23590: PUSH
23591: EMPTY
23592: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23593: LD_ADDR_VAR 0 4
23597: PUSH
23598: LD_VAR 0 2
23602: PPUSH
23603: LD_INT 21
23605: PUSH
23606: LD_INT 3
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: PPUSH
23613: CALL_OW 70
23617: ST_TO_ADDR
// if not tmp then
23618: LD_VAR 0 4
23622: NOT
23623: IFFALSE 23627
// exit ;
23625: GO 23685
// for i in tmp do
23627: LD_ADDR_VAR 0 5
23631: PUSH
23632: LD_VAR 0 4
23636: PUSH
23637: FOR_IN
23638: IFFALSE 23673
// if GetBase ( i ) <> base then
23640: LD_VAR 0 5
23644: PPUSH
23645: CALL_OW 274
23649: PUSH
23650: LD_VAR 0 1
23654: NONEQUAL
23655: IFFALSE 23671
// ComLinkToBase ( base , i ) ;
23657: LD_VAR 0 1
23661: PPUSH
23662: LD_VAR 0 5
23666: PPUSH
23667: CALL_OW 169
23671: GO 23637
23673: POP
23674: POP
// result := tmp ;
23675: LD_ADDR_VAR 0 3
23679: PUSH
23680: LD_VAR 0 4
23684: ST_TO_ADDR
// end ;
23685: LD_VAR 0 3
23689: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23690: LD_INT 0
23692: PPUSH
23693: PPUSH
// if BuildingStatus ( b ) = bs_build then
23694: LD_VAR 0 2
23698: PPUSH
23699: CALL_OW 461
23703: PUSH
23704: LD_INT 1
23706: EQUAL
23707: IFFALSE 23767
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23709: LD_VAR 0 1
23713: PPUSH
23714: LD_STRING h
23716: PUSH
23717: LD_VAR 0 2
23721: PPUSH
23722: CALL_OW 250
23726: PUSH
23727: LD_VAR 0 2
23731: PPUSH
23732: CALL_OW 251
23736: PUSH
23737: LD_VAR 0 2
23741: PUSH
23742: LD_INT 0
23744: PUSH
23745: LD_INT 0
23747: PUSH
23748: LD_INT 0
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: LIST
23755: LIST
23756: LIST
23757: LIST
23758: LIST
23759: PUSH
23760: EMPTY
23761: LIST
23762: PPUSH
23763: CALL_OW 446
// end ;
23767: LD_VAR 0 3
23771: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23772: LD_INT 0
23774: PPUSH
23775: PPUSH
23776: PPUSH
23777: PPUSH
23778: PPUSH
23779: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23780: LD_VAR 0 1
23784: NOT
23785: PUSH
23786: LD_VAR 0 1
23790: PPUSH
23791: CALL_OW 263
23795: PUSH
23796: LD_INT 2
23798: EQUAL
23799: NOT
23800: OR
23801: IFFALSE 23805
// exit ;
23803: GO 24121
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23805: LD_ADDR_VAR 0 6
23809: PUSH
23810: LD_INT 22
23812: PUSH
23813: LD_VAR 0 1
23817: PPUSH
23818: CALL_OW 255
23822: PUSH
23823: EMPTY
23824: LIST
23825: LIST
23826: PUSH
23827: LD_INT 2
23829: PUSH
23830: LD_INT 30
23832: PUSH
23833: LD_INT 36
23835: PUSH
23836: EMPTY
23837: LIST
23838: LIST
23839: PUSH
23840: LD_INT 34
23842: PUSH
23843: LD_INT 31
23845: PUSH
23846: EMPTY
23847: LIST
23848: LIST
23849: PUSH
23850: EMPTY
23851: LIST
23852: LIST
23853: LIST
23854: PUSH
23855: EMPTY
23856: LIST
23857: LIST
23858: PPUSH
23859: CALL_OW 69
23863: ST_TO_ADDR
// if not tmp then
23864: LD_VAR 0 6
23868: NOT
23869: IFFALSE 23873
// exit ;
23871: GO 24121
// result := [ ] ;
23873: LD_ADDR_VAR 0 2
23877: PUSH
23878: EMPTY
23879: ST_TO_ADDR
// for i in tmp do
23880: LD_ADDR_VAR 0 3
23884: PUSH
23885: LD_VAR 0 6
23889: PUSH
23890: FOR_IN
23891: IFFALSE 23962
// begin t := UnitsInside ( i ) ;
23893: LD_ADDR_VAR 0 4
23897: PUSH
23898: LD_VAR 0 3
23902: PPUSH
23903: CALL_OW 313
23907: ST_TO_ADDR
// if t then
23908: LD_VAR 0 4
23912: IFFALSE 23960
// for j in t do
23914: LD_ADDR_VAR 0 7
23918: PUSH
23919: LD_VAR 0 4
23923: PUSH
23924: FOR_IN
23925: IFFALSE 23958
// result := Insert ( result , result + 1 , j ) ;
23927: LD_ADDR_VAR 0 2
23931: PUSH
23932: LD_VAR 0 2
23936: PPUSH
23937: LD_VAR 0 2
23941: PUSH
23942: LD_INT 1
23944: PLUS
23945: PPUSH
23946: LD_VAR 0 7
23950: PPUSH
23951: CALL_OW 2
23955: ST_TO_ADDR
23956: GO 23924
23958: POP
23959: POP
// end ;
23960: GO 23890
23962: POP
23963: POP
// if not result then
23964: LD_VAR 0 2
23968: NOT
23969: IFFALSE 23973
// exit ;
23971: GO 24121
// mech := result [ 1 ] ;
23973: LD_ADDR_VAR 0 5
23977: PUSH
23978: LD_VAR 0 2
23982: PUSH
23983: LD_INT 1
23985: ARRAY
23986: ST_TO_ADDR
// if result > 1 then
23987: LD_VAR 0 2
23991: PUSH
23992: LD_INT 1
23994: GREATER
23995: IFFALSE 24107
// for i = 2 to result do
23997: LD_ADDR_VAR 0 3
24001: PUSH
24002: DOUBLE
24003: LD_INT 2
24005: DEC
24006: ST_TO_ADDR
24007: LD_VAR 0 2
24011: PUSH
24012: FOR_TO
24013: IFFALSE 24105
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24015: LD_ADDR_VAR 0 4
24019: PUSH
24020: LD_VAR 0 2
24024: PUSH
24025: LD_VAR 0 3
24029: ARRAY
24030: PPUSH
24031: LD_INT 3
24033: PPUSH
24034: CALL_OW 259
24038: PUSH
24039: LD_VAR 0 2
24043: PUSH
24044: LD_VAR 0 3
24048: ARRAY
24049: PPUSH
24050: CALL_OW 432
24054: MINUS
24055: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24056: LD_VAR 0 4
24060: PUSH
24061: LD_VAR 0 5
24065: PPUSH
24066: LD_INT 3
24068: PPUSH
24069: CALL_OW 259
24073: PUSH
24074: LD_VAR 0 5
24078: PPUSH
24079: CALL_OW 432
24083: MINUS
24084: GREATEREQUAL
24085: IFFALSE 24103
// mech := result [ i ] ;
24087: LD_ADDR_VAR 0 5
24091: PUSH
24092: LD_VAR 0 2
24096: PUSH
24097: LD_VAR 0 3
24101: ARRAY
24102: ST_TO_ADDR
// end ;
24103: GO 24012
24105: POP
24106: POP
// ComLinkTo ( vehicle , mech ) ;
24107: LD_VAR 0 1
24111: PPUSH
24112: LD_VAR 0 5
24116: PPUSH
24117: CALL_OW 135
// end ;
24121: LD_VAR 0 2
24125: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24126: LD_INT 0
24128: PPUSH
24129: PPUSH
24130: PPUSH
24131: PPUSH
24132: PPUSH
24133: PPUSH
24134: PPUSH
24135: PPUSH
24136: PPUSH
24137: PPUSH
24138: PPUSH
24139: PPUSH
24140: PPUSH
// result := [ ] ;
24141: LD_ADDR_VAR 0 7
24145: PUSH
24146: EMPTY
24147: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24148: LD_VAR 0 1
24152: PPUSH
24153: CALL_OW 266
24157: PUSH
24158: LD_INT 0
24160: PUSH
24161: LD_INT 1
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: IN
24168: NOT
24169: IFFALSE 24173
// exit ;
24171: GO 25804
// if name then
24173: LD_VAR 0 3
24177: IFFALSE 24193
// SetBName ( base_dep , name ) ;
24179: LD_VAR 0 1
24183: PPUSH
24184: LD_VAR 0 3
24188: PPUSH
24189: CALL_OW 500
// base := GetBase ( base_dep ) ;
24193: LD_ADDR_VAR 0 15
24197: PUSH
24198: LD_VAR 0 1
24202: PPUSH
24203: CALL_OW 274
24207: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24208: LD_ADDR_VAR 0 16
24212: PUSH
24213: LD_VAR 0 1
24217: PPUSH
24218: CALL_OW 255
24222: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24223: LD_ADDR_VAR 0 17
24227: PUSH
24228: LD_VAR 0 1
24232: PPUSH
24233: CALL_OW 248
24237: ST_TO_ADDR
// if sources then
24238: LD_VAR 0 5
24242: IFFALSE 24289
// for i = 1 to 3 do
24244: LD_ADDR_VAR 0 8
24248: PUSH
24249: DOUBLE
24250: LD_INT 1
24252: DEC
24253: ST_TO_ADDR
24254: LD_INT 3
24256: PUSH
24257: FOR_TO
24258: IFFALSE 24287
// AddResourceType ( base , i , sources [ i ] ) ;
24260: LD_VAR 0 15
24264: PPUSH
24265: LD_VAR 0 8
24269: PPUSH
24270: LD_VAR 0 5
24274: PUSH
24275: LD_VAR 0 8
24279: ARRAY
24280: PPUSH
24281: CALL_OW 276
24285: GO 24257
24287: POP
24288: POP
// buildings := GetBaseBuildings ( base , area ) ;
24289: LD_ADDR_VAR 0 18
24293: PUSH
24294: LD_VAR 0 15
24298: PPUSH
24299: LD_VAR 0 2
24303: PPUSH
24304: CALL 23581 0 2
24308: ST_TO_ADDR
// InitHc ;
24309: CALL_OW 19
// InitUc ;
24313: CALL_OW 18
// uc_side := side ;
24317: LD_ADDR_OWVAR 20
24321: PUSH
24322: LD_VAR 0 16
24326: ST_TO_ADDR
// uc_nation := nation ;
24327: LD_ADDR_OWVAR 21
24331: PUSH
24332: LD_VAR 0 17
24336: ST_TO_ADDR
// if buildings then
24337: LD_VAR 0 18
24341: IFFALSE 25663
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24343: LD_ADDR_VAR 0 19
24347: PUSH
24348: LD_VAR 0 18
24352: PPUSH
24353: LD_INT 2
24355: PUSH
24356: LD_INT 30
24358: PUSH
24359: LD_INT 29
24361: PUSH
24362: EMPTY
24363: LIST
24364: LIST
24365: PUSH
24366: LD_INT 30
24368: PUSH
24369: LD_INT 30
24371: PUSH
24372: EMPTY
24373: LIST
24374: LIST
24375: PUSH
24376: EMPTY
24377: LIST
24378: LIST
24379: LIST
24380: PPUSH
24381: CALL_OW 72
24385: ST_TO_ADDR
// if tmp then
24386: LD_VAR 0 19
24390: IFFALSE 24438
// for i in tmp do
24392: LD_ADDR_VAR 0 8
24396: PUSH
24397: LD_VAR 0 19
24401: PUSH
24402: FOR_IN
24403: IFFALSE 24436
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24405: LD_VAR 0 8
24409: PPUSH
24410: CALL_OW 250
24414: PPUSH
24415: LD_VAR 0 8
24419: PPUSH
24420: CALL_OW 251
24424: PPUSH
24425: LD_VAR 0 16
24429: PPUSH
24430: CALL_OW 441
24434: GO 24402
24436: POP
24437: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24438: LD_VAR 0 18
24442: PPUSH
24443: LD_INT 2
24445: PUSH
24446: LD_INT 30
24448: PUSH
24449: LD_INT 32
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: PUSH
24456: LD_INT 30
24458: PUSH
24459: LD_INT 33
24461: PUSH
24462: EMPTY
24463: LIST
24464: LIST
24465: PUSH
24466: EMPTY
24467: LIST
24468: LIST
24469: LIST
24470: PPUSH
24471: CALL_OW 72
24475: IFFALSE 24563
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24477: LD_ADDR_VAR 0 8
24481: PUSH
24482: LD_VAR 0 18
24486: PPUSH
24487: LD_INT 2
24489: PUSH
24490: LD_INT 30
24492: PUSH
24493: LD_INT 32
24495: PUSH
24496: EMPTY
24497: LIST
24498: LIST
24499: PUSH
24500: LD_INT 30
24502: PUSH
24503: LD_INT 33
24505: PUSH
24506: EMPTY
24507: LIST
24508: LIST
24509: PUSH
24510: EMPTY
24511: LIST
24512: LIST
24513: LIST
24514: PPUSH
24515: CALL_OW 72
24519: PUSH
24520: FOR_IN
24521: IFFALSE 24561
// begin if not GetBWeapon ( i ) then
24523: LD_VAR 0 8
24527: PPUSH
24528: CALL_OW 269
24532: NOT
24533: IFFALSE 24559
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24535: LD_VAR 0 8
24539: PPUSH
24540: LD_VAR 0 8
24544: PPUSH
24545: LD_VAR 0 2
24549: PPUSH
24550: CALL 25809 0 2
24554: PPUSH
24555: CALL_OW 431
// end ;
24559: GO 24520
24561: POP
24562: POP
// end ; for i = 1 to personel do
24563: LD_ADDR_VAR 0 8
24567: PUSH
24568: DOUBLE
24569: LD_INT 1
24571: DEC
24572: ST_TO_ADDR
24573: LD_VAR 0 6
24577: PUSH
24578: FOR_TO
24579: IFFALSE 25643
// begin if i > 4 then
24581: LD_VAR 0 8
24585: PUSH
24586: LD_INT 4
24588: GREATER
24589: IFFALSE 24593
// break ;
24591: GO 25643
// case i of 1 :
24593: LD_VAR 0 8
24597: PUSH
24598: LD_INT 1
24600: DOUBLE
24601: EQUAL
24602: IFTRUE 24606
24604: GO 24686
24606: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24607: LD_ADDR_VAR 0 12
24611: PUSH
24612: LD_VAR 0 18
24616: PPUSH
24617: LD_INT 22
24619: PUSH
24620: LD_VAR 0 16
24624: PUSH
24625: EMPTY
24626: LIST
24627: LIST
24628: PUSH
24629: LD_INT 58
24631: PUSH
24632: EMPTY
24633: LIST
24634: PUSH
24635: LD_INT 2
24637: PUSH
24638: LD_INT 30
24640: PUSH
24641: LD_INT 32
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 30
24650: PUSH
24651: LD_INT 4
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 30
24660: PUSH
24661: LD_INT 5
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: PUSH
24668: EMPTY
24669: LIST
24670: LIST
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: PPUSH
24679: CALL_OW 72
24683: ST_TO_ADDR
24684: GO 24908
24686: LD_INT 2
24688: DOUBLE
24689: EQUAL
24690: IFTRUE 24694
24692: GO 24756
24694: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24695: LD_ADDR_VAR 0 12
24699: PUSH
24700: LD_VAR 0 18
24704: PPUSH
24705: LD_INT 22
24707: PUSH
24708: LD_VAR 0 16
24712: PUSH
24713: EMPTY
24714: LIST
24715: LIST
24716: PUSH
24717: LD_INT 2
24719: PUSH
24720: LD_INT 30
24722: PUSH
24723: LD_INT 0
24725: PUSH
24726: EMPTY
24727: LIST
24728: LIST
24729: PUSH
24730: LD_INT 30
24732: PUSH
24733: LD_INT 1
24735: PUSH
24736: EMPTY
24737: LIST
24738: LIST
24739: PUSH
24740: EMPTY
24741: LIST
24742: LIST
24743: LIST
24744: PUSH
24745: EMPTY
24746: LIST
24747: LIST
24748: PPUSH
24749: CALL_OW 72
24753: ST_TO_ADDR
24754: GO 24908
24756: LD_INT 3
24758: DOUBLE
24759: EQUAL
24760: IFTRUE 24764
24762: GO 24826
24764: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24765: LD_ADDR_VAR 0 12
24769: PUSH
24770: LD_VAR 0 18
24774: PPUSH
24775: LD_INT 22
24777: PUSH
24778: LD_VAR 0 16
24782: PUSH
24783: EMPTY
24784: LIST
24785: LIST
24786: PUSH
24787: LD_INT 2
24789: PUSH
24790: LD_INT 30
24792: PUSH
24793: LD_INT 2
24795: PUSH
24796: EMPTY
24797: LIST
24798: LIST
24799: PUSH
24800: LD_INT 30
24802: PUSH
24803: LD_INT 3
24805: PUSH
24806: EMPTY
24807: LIST
24808: LIST
24809: PUSH
24810: EMPTY
24811: LIST
24812: LIST
24813: LIST
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: PPUSH
24819: CALL_OW 72
24823: ST_TO_ADDR
24824: GO 24908
24826: LD_INT 4
24828: DOUBLE
24829: EQUAL
24830: IFTRUE 24834
24832: GO 24907
24834: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24835: LD_ADDR_VAR 0 12
24839: PUSH
24840: LD_VAR 0 18
24844: PPUSH
24845: LD_INT 22
24847: PUSH
24848: LD_VAR 0 16
24852: PUSH
24853: EMPTY
24854: LIST
24855: LIST
24856: PUSH
24857: LD_INT 2
24859: PUSH
24860: LD_INT 30
24862: PUSH
24863: LD_INT 6
24865: PUSH
24866: EMPTY
24867: LIST
24868: LIST
24869: PUSH
24870: LD_INT 30
24872: PUSH
24873: LD_INT 7
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 30
24882: PUSH
24883: LD_INT 8
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: LIST
24894: LIST
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PPUSH
24900: CALL_OW 72
24904: ST_TO_ADDR
24905: GO 24908
24907: POP
// if i = 1 then
24908: LD_VAR 0 8
24912: PUSH
24913: LD_INT 1
24915: EQUAL
24916: IFFALSE 25027
// begin tmp := [ ] ;
24918: LD_ADDR_VAR 0 19
24922: PUSH
24923: EMPTY
24924: ST_TO_ADDR
// for j in f do
24925: LD_ADDR_VAR 0 9
24929: PUSH
24930: LD_VAR 0 12
24934: PUSH
24935: FOR_IN
24936: IFFALSE 25009
// if GetBType ( j ) = b_bunker then
24938: LD_VAR 0 9
24942: PPUSH
24943: CALL_OW 266
24947: PUSH
24948: LD_INT 32
24950: EQUAL
24951: IFFALSE 24978
// tmp := Insert ( tmp , 1 , j ) else
24953: LD_ADDR_VAR 0 19
24957: PUSH
24958: LD_VAR 0 19
24962: PPUSH
24963: LD_INT 1
24965: PPUSH
24966: LD_VAR 0 9
24970: PPUSH
24971: CALL_OW 2
24975: ST_TO_ADDR
24976: GO 25007
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24978: LD_ADDR_VAR 0 19
24982: PUSH
24983: LD_VAR 0 19
24987: PPUSH
24988: LD_VAR 0 19
24992: PUSH
24993: LD_INT 1
24995: PLUS
24996: PPUSH
24997: LD_VAR 0 9
25001: PPUSH
25002: CALL_OW 2
25006: ST_TO_ADDR
25007: GO 24935
25009: POP
25010: POP
// if tmp then
25011: LD_VAR 0 19
25015: IFFALSE 25027
// f := tmp ;
25017: LD_ADDR_VAR 0 12
25021: PUSH
25022: LD_VAR 0 19
25026: ST_TO_ADDR
// end ; x := personel [ i ] ;
25027: LD_ADDR_VAR 0 13
25031: PUSH
25032: LD_VAR 0 6
25036: PUSH
25037: LD_VAR 0 8
25041: ARRAY
25042: ST_TO_ADDR
// if x = - 1 then
25043: LD_VAR 0 13
25047: PUSH
25048: LD_INT 1
25050: NEG
25051: EQUAL
25052: IFFALSE 25261
// begin for j in f do
25054: LD_ADDR_VAR 0 9
25058: PUSH
25059: LD_VAR 0 12
25063: PUSH
25064: FOR_IN
25065: IFFALSE 25257
// repeat InitHc ;
25067: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25071: LD_VAR 0 9
25075: PPUSH
25076: CALL_OW 266
25080: PUSH
25081: LD_INT 5
25083: EQUAL
25084: IFFALSE 25154
// begin if UnitsInside ( j ) < 3 then
25086: LD_VAR 0 9
25090: PPUSH
25091: CALL_OW 313
25095: PUSH
25096: LD_INT 3
25098: LESS
25099: IFFALSE 25135
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25101: LD_INT 0
25103: PPUSH
25104: LD_INT 5
25106: PUSH
25107: LD_INT 8
25109: PUSH
25110: LD_INT 9
25112: PUSH
25113: EMPTY
25114: LIST
25115: LIST
25116: LIST
25117: PUSH
25118: LD_VAR 0 17
25122: ARRAY
25123: PPUSH
25124: LD_VAR 0 4
25128: PPUSH
25129: CALL_OW 380
25133: GO 25152
// PrepareHuman ( false , i , skill ) ;
25135: LD_INT 0
25137: PPUSH
25138: LD_VAR 0 8
25142: PPUSH
25143: LD_VAR 0 4
25147: PPUSH
25148: CALL_OW 380
// end else
25152: GO 25171
// PrepareHuman ( false , i , skill ) ;
25154: LD_INT 0
25156: PPUSH
25157: LD_VAR 0 8
25161: PPUSH
25162: LD_VAR 0 4
25166: PPUSH
25167: CALL_OW 380
// un := CreateHuman ;
25171: LD_ADDR_VAR 0 14
25175: PUSH
25176: CALL_OW 44
25180: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25181: LD_ADDR_VAR 0 7
25185: PUSH
25186: LD_VAR 0 7
25190: PPUSH
25191: LD_INT 1
25193: PPUSH
25194: LD_VAR 0 14
25198: PPUSH
25199: CALL_OW 2
25203: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25204: LD_VAR 0 14
25208: PPUSH
25209: LD_VAR 0 9
25213: PPUSH
25214: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25218: LD_VAR 0 9
25222: PPUSH
25223: CALL_OW 313
25227: PUSH
25228: LD_INT 6
25230: EQUAL
25231: PUSH
25232: LD_VAR 0 9
25236: PPUSH
25237: CALL_OW 266
25241: PUSH
25242: LD_INT 32
25244: PUSH
25245: LD_INT 31
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: IN
25252: OR
25253: IFFALSE 25067
25255: GO 25064
25257: POP
25258: POP
// end else
25259: GO 25641
// for j = 1 to x do
25261: LD_ADDR_VAR 0 9
25265: PUSH
25266: DOUBLE
25267: LD_INT 1
25269: DEC
25270: ST_TO_ADDR
25271: LD_VAR 0 13
25275: PUSH
25276: FOR_TO
25277: IFFALSE 25639
// begin InitHc ;
25279: CALL_OW 19
// if not f then
25283: LD_VAR 0 12
25287: NOT
25288: IFFALSE 25377
// begin PrepareHuman ( false , i , skill ) ;
25290: LD_INT 0
25292: PPUSH
25293: LD_VAR 0 8
25297: PPUSH
25298: LD_VAR 0 4
25302: PPUSH
25303: CALL_OW 380
// un := CreateHuman ;
25307: LD_ADDR_VAR 0 14
25311: PUSH
25312: CALL_OW 44
25316: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25317: LD_ADDR_VAR 0 7
25321: PUSH
25322: LD_VAR 0 7
25326: PPUSH
25327: LD_INT 1
25329: PPUSH
25330: LD_VAR 0 14
25334: PPUSH
25335: CALL_OW 2
25339: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25340: LD_VAR 0 14
25344: PPUSH
25345: LD_VAR 0 1
25349: PPUSH
25350: CALL_OW 250
25354: PPUSH
25355: LD_VAR 0 1
25359: PPUSH
25360: CALL_OW 251
25364: PPUSH
25365: LD_INT 10
25367: PPUSH
25368: LD_INT 0
25370: PPUSH
25371: CALL_OW 50
// continue ;
25375: GO 25276
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25377: LD_VAR 0 12
25381: PUSH
25382: LD_INT 1
25384: ARRAY
25385: PPUSH
25386: CALL_OW 313
25390: PUSH
25391: LD_VAR 0 12
25395: PUSH
25396: LD_INT 1
25398: ARRAY
25399: PPUSH
25400: CALL_OW 266
25404: PUSH
25405: LD_INT 32
25407: PUSH
25408: LD_INT 31
25410: PUSH
25411: EMPTY
25412: LIST
25413: LIST
25414: IN
25415: AND
25416: PUSH
25417: LD_VAR 0 12
25421: PUSH
25422: LD_INT 1
25424: ARRAY
25425: PPUSH
25426: CALL_OW 313
25430: PUSH
25431: LD_INT 6
25433: EQUAL
25434: OR
25435: IFFALSE 25455
// f := Delete ( f , 1 ) ;
25437: LD_ADDR_VAR 0 12
25441: PUSH
25442: LD_VAR 0 12
25446: PPUSH
25447: LD_INT 1
25449: PPUSH
25450: CALL_OW 3
25454: ST_TO_ADDR
// if not f then
25455: LD_VAR 0 12
25459: NOT
25460: IFFALSE 25478
// begin x := x + 2 ;
25462: LD_ADDR_VAR 0 13
25466: PUSH
25467: LD_VAR 0 13
25471: PUSH
25472: LD_INT 2
25474: PLUS
25475: ST_TO_ADDR
// continue ;
25476: GO 25276
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25478: LD_VAR 0 12
25482: PUSH
25483: LD_INT 1
25485: ARRAY
25486: PPUSH
25487: CALL_OW 266
25491: PUSH
25492: LD_INT 5
25494: EQUAL
25495: IFFALSE 25569
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25497: LD_VAR 0 12
25501: PUSH
25502: LD_INT 1
25504: ARRAY
25505: PPUSH
25506: CALL_OW 313
25510: PUSH
25511: LD_INT 3
25513: LESS
25514: IFFALSE 25550
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25516: LD_INT 0
25518: PPUSH
25519: LD_INT 5
25521: PUSH
25522: LD_INT 8
25524: PUSH
25525: LD_INT 9
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: LIST
25532: PUSH
25533: LD_VAR 0 17
25537: ARRAY
25538: PPUSH
25539: LD_VAR 0 4
25543: PPUSH
25544: CALL_OW 380
25548: GO 25567
// PrepareHuman ( false , i , skill ) ;
25550: LD_INT 0
25552: PPUSH
25553: LD_VAR 0 8
25557: PPUSH
25558: LD_VAR 0 4
25562: PPUSH
25563: CALL_OW 380
// end else
25567: GO 25586
// PrepareHuman ( false , i , skill ) ;
25569: LD_INT 0
25571: PPUSH
25572: LD_VAR 0 8
25576: PPUSH
25577: LD_VAR 0 4
25581: PPUSH
25582: CALL_OW 380
// un := CreateHuman ;
25586: LD_ADDR_VAR 0 14
25590: PUSH
25591: CALL_OW 44
25595: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25596: LD_ADDR_VAR 0 7
25600: PUSH
25601: LD_VAR 0 7
25605: PPUSH
25606: LD_INT 1
25608: PPUSH
25609: LD_VAR 0 14
25613: PPUSH
25614: CALL_OW 2
25618: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25619: LD_VAR 0 14
25623: PPUSH
25624: LD_VAR 0 12
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PPUSH
25633: CALL_OW 52
// end ;
25637: GO 25276
25639: POP
25640: POP
// end ;
25641: GO 24578
25643: POP
25644: POP
// result := result ^ buildings ;
25645: LD_ADDR_VAR 0 7
25649: PUSH
25650: LD_VAR 0 7
25654: PUSH
25655: LD_VAR 0 18
25659: ADD
25660: ST_TO_ADDR
// end else
25661: GO 25804
// begin for i = 1 to personel do
25663: LD_ADDR_VAR 0 8
25667: PUSH
25668: DOUBLE
25669: LD_INT 1
25671: DEC
25672: ST_TO_ADDR
25673: LD_VAR 0 6
25677: PUSH
25678: FOR_TO
25679: IFFALSE 25802
// begin if i > 4 then
25681: LD_VAR 0 8
25685: PUSH
25686: LD_INT 4
25688: GREATER
25689: IFFALSE 25693
// break ;
25691: GO 25802
// x := personel [ i ] ;
25693: LD_ADDR_VAR 0 13
25697: PUSH
25698: LD_VAR 0 6
25702: PUSH
25703: LD_VAR 0 8
25707: ARRAY
25708: ST_TO_ADDR
// if x = - 1 then
25709: LD_VAR 0 13
25713: PUSH
25714: LD_INT 1
25716: NEG
25717: EQUAL
25718: IFFALSE 25722
// continue ;
25720: GO 25678
// PrepareHuman ( false , i , skill ) ;
25722: LD_INT 0
25724: PPUSH
25725: LD_VAR 0 8
25729: PPUSH
25730: LD_VAR 0 4
25734: PPUSH
25735: CALL_OW 380
// un := CreateHuman ;
25739: LD_ADDR_VAR 0 14
25743: PUSH
25744: CALL_OW 44
25748: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25749: LD_VAR 0 14
25753: PPUSH
25754: LD_VAR 0 1
25758: PPUSH
25759: CALL_OW 250
25763: PPUSH
25764: LD_VAR 0 1
25768: PPUSH
25769: CALL_OW 251
25773: PPUSH
25774: LD_INT 10
25776: PPUSH
25777: LD_INT 0
25779: PPUSH
25780: CALL_OW 50
// result := result ^ un ;
25784: LD_ADDR_VAR 0 7
25788: PUSH
25789: LD_VAR 0 7
25793: PUSH
25794: LD_VAR 0 14
25798: ADD
25799: ST_TO_ADDR
// end ;
25800: GO 25678
25802: POP
25803: POP
// end ; end ;
25804: LD_VAR 0 7
25808: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25809: LD_INT 0
25811: PPUSH
25812: PPUSH
25813: PPUSH
25814: PPUSH
25815: PPUSH
25816: PPUSH
25817: PPUSH
25818: PPUSH
25819: PPUSH
25820: PPUSH
25821: PPUSH
25822: PPUSH
25823: PPUSH
25824: PPUSH
25825: PPUSH
25826: PPUSH
// result := false ;
25827: LD_ADDR_VAR 0 3
25831: PUSH
25832: LD_INT 0
25834: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25835: LD_VAR 0 1
25839: NOT
25840: PUSH
25841: LD_VAR 0 1
25845: PPUSH
25846: CALL_OW 266
25850: PUSH
25851: LD_INT 32
25853: PUSH
25854: LD_INT 33
25856: PUSH
25857: EMPTY
25858: LIST
25859: LIST
25860: IN
25861: NOT
25862: OR
25863: IFFALSE 25867
// exit ;
25865: GO 27003
// nat := GetNation ( tower ) ;
25867: LD_ADDR_VAR 0 12
25871: PUSH
25872: LD_VAR 0 1
25876: PPUSH
25877: CALL_OW 248
25881: ST_TO_ADDR
// side := GetSide ( tower ) ;
25882: LD_ADDR_VAR 0 16
25886: PUSH
25887: LD_VAR 0 1
25891: PPUSH
25892: CALL_OW 255
25896: ST_TO_ADDR
// x := GetX ( tower ) ;
25897: LD_ADDR_VAR 0 10
25901: PUSH
25902: LD_VAR 0 1
25906: PPUSH
25907: CALL_OW 250
25911: ST_TO_ADDR
// y := GetY ( tower ) ;
25912: LD_ADDR_VAR 0 11
25916: PUSH
25917: LD_VAR 0 1
25921: PPUSH
25922: CALL_OW 251
25926: ST_TO_ADDR
// if not x or not y then
25927: LD_VAR 0 10
25931: NOT
25932: PUSH
25933: LD_VAR 0 11
25937: NOT
25938: OR
25939: IFFALSE 25943
// exit ;
25941: GO 27003
// weapon := 0 ;
25943: LD_ADDR_VAR 0 18
25947: PUSH
25948: LD_INT 0
25950: ST_TO_ADDR
// fac_list := [ ] ;
25951: LD_ADDR_VAR 0 17
25955: PUSH
25956: EMPTY
25957: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
25958: LD_ADDR_VAR 0 6
25962: PUSH
25963: LD_VAR 0 1
25967: PPUSH
25968: CALL_OW 274
25972: PPUSH
25973: LD_VAR 0 2
25977: PPUSH
25978: CALL 23581 0 2
25982: PPUSH
25983: LD_INT 30
25985: PUSH
25986: LD_INT 3
25988: PUSH
25989: EMPTY
25990: LIST
25991: LIST
25992: PPUSH
25993: CALL_OW 72
25997: ST_TO_ADDR
// if not factories then
25998: LD_VAR 0 6
26002: NOT
26003: IFFALSE 26007
// exit ;
26005: GO 27003
// for i in factories do
26007: LD_ADDR_VAR 0 8
26011: PUSH
26012: LD_VAR 0 6
26016: PUSH
26017: FOR_IN
26018: IFFALSE 26043
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26020: LD_ADDR_VAR 0 17
26024: PUSH
26025: LD_VAR 0 17
26029: PUSH
26030: LD_VAR 0 8
26034: PPUSH
26035: CALL_OW 478
26039: UNION
26040: ST_TO_ADDR
26041: GO 26017
26043: POP
26044: POP
// if not fac_list then
26045: LD_VAR 0 17
26049: NOT
26050: IFFALSE 26054
// exit ;
26052: GO 27003
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26054: LD_ADDR_VAR 0 5
26058: PUSH
26059: LD_INT 4
26061: PUSH
26062: LD_INT 5
26064: PUSH
26065: LD_INT 9
26067: PUSH
26068: LD_INT 10
26070: PUSH
26071: LD_INT 6
26073: PUSH
26074: LD_INT 7
26076: PUSH
26077: LD_INT 11
26079: PUSH
26080: EMPTY
26081: LIST
26082: LIST
26083: LIST
26084: LIST
26085: LIST
26086: LIST
26087: LIST
26088: PUSH
26089: LD_INT 27
26091: PUSH
26092: LD_INT 28
26094: PUSH
26095: LD_INT 26
26097: PUSH
26098: LD_INT 30
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: LIST
26105: LIST
26106: PUSH
26107: LD_INT 43
26109: PUSH
26110: LD_INT 44
26112: PUSH
26113: LD_INT 46
26115: PUSH
26116: LD_INT 45
26118: PUSH
26119: LD_INT 47
26121: PUSH
26122: LD_INT 49
26124: PUSH
26125: EMPTY
26126: LIST
26127: LIST
26128: LIST
26129: LIST
26130: LIST
26131: LIST
26132: PUSH
26133: EMPTY
26134: LIST
26135: LIST
26136: LIST
26137: PUSH
26138: LD_VAR 0 12
26142: ARRAY
26143: ST_TO_ADDR
// for i in list do
26144: LD_ADDR_VAR 0 8
26148: PUSH
26149: LD_VAR 0 5
26153: PUSH
26154: FOR_IN
26155: IFFALSE 26188
// if not i in fac_list then
26157: LD_VAR 0 8
26161: PUSH
26162: LD_VAR 0 17
26166: IN
26167: NOT
26168: IFFALSE 26186
// list := list diff i ;
26170: LD_ADDR_VAR 0 5
26174: PUSH
26175: LD_VAR 0 5
26179: PUSH
26180: LD_VAR 0 8
26184: DIFF
26185: ST_TO_ADDR
26186: GO 26154
26188: POP
26189: POP
// if not list then
26190: LD_VAR 0 5
26194: NOT
26195: IFFALSE 26199
// exit ;
26197: GO 27003
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26199: LD_VAR 0 12
26203: PUSH
26204: LD_INT 3
26206: EQUAL
26207: PUSH
26208: LD_INT 49
26210: PUSH
26211: LD_VAR 0 5
26215: IN
26216: AND
26217: PUSH
26218: LD_INT 31
26220: PPUSH
26221: LD_VAR 0 16
26225: PPUSH
26226: CALL_OW 321
26230: PUSH
26231: LD_INT 2
26233: EQUAL
26234: AND
26235: IFFALSE 26295
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26237: LD_INT 22
26239: PUSH
26240: LD_VAR 0 16
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 35
26251: PUSH
26252: LD_INT 49
26254: PUSH
26255: EMPTY
26256: LIST
26257: LIST
26258: PUSH
26259: LD_INT 91
26261: PUSH
26262: LD_VAR 0 1
26266: PUSH
26267: LD_INT 10
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: LIST
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: LIST
26279: PPUSH
26280: CALL_OW 69
26284: NOT
26285: IFFALSE 26295
// weapon := ru_time_lapser ;
26287: LD_ADDR_VAR 0 18
26291: PUSH
26292: LD_INT 49
26294: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26295: LD_VAR 0 12
26299: PUSH
26300: LD_INT 1
26302: PUSH
26303: LD_INT 2
26305: PUSH
26306: EMPTY
26307: LIST
26308: LIST
26309: IN
26310: PUSH
26311: LD_INT 11
26313: PUSH
26314: LD_VAR 0 5
26318: IN
26319: PUSH
26320: LD_INT 30
26322: PUSH
26323: LD_VAR 0 5
26327: IN
26328: OR
26329: AND
26330: PUSH
26331: LD_INT 6
26333: PPUSH
26334: LD_VAR 0 16
26338: PPUSH
26339: CALL_OW 321
26343: PUSH
26344: LD_INT 2
26346: EQUAL
26347: AND
26348: IFFALSE 26513
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26350: LD_INT 22
26352: PUSH
26353: LD_VAR 0 16
26357: PUSH
26358: EMPTY
26359: LIST
26360: LIST
26361: PUSH
26362: LD_INT 2
26364: PUSH
26365: LD_INT 35
26367: PUSH
26368: LD_INT 11
26370: PUSH
26371: EMPTY
26372: LIST
26373: LIST
26374: PUSH
26375: LD_INT 35
26377: PUSH
26378: LD_INT 30
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: EMPTY
26386: LIST
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 91
26392: PUSH
26393: LD_VAR 0 1
26397: PUSH
26398: LD_INT 18
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: LIST
26405: PUSH
26406: EMPTY
26407: LIST
26408: LIST
26409: LIST
26410: PPUSH
26411: CALL_OW 69
26415: NOT
26416: PUSH
26417: LD_INT 22
26419: PUSH
26420: LD_VAR 0 16
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PUSH
26429: LD_INT 2
26431: PUSH
26432: LD_INT 30
26434: PUSH
26435: LD_INT 32
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 30
26444: PUSH
26445: LD_INT 33
26447: PUSH
26448: EMPTY
26449: LIST
26450: LIST
26451: PUSH
26452: EMPTY
26453: LIST
26454: LIST
26455: LIST
26456: PUSH
26457: LD_INT 91
26459: PUSH
26460: LD_VAR 0 1
26464: PUSH
26465: LD_INT 12
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: LIST
26472: PUSH
26473: EMPTY
26474: LIST
26475: LIST
26476: LIST
26477: PUSH
26478: EMPTY
26479: LIST
26480: PPUSH
26481: CALL_OW 69
26485: PUSH
26486: LD_INT 2
26488: GREATER
26489: AND
26490: IFFALSE 26513
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26492: LD_ADDR_VAR 0 18
26496: PUSH
26497: LD_INT 11
26499: PUSH
26500: LD_INT 30
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: LD_VAR 0 12
26511: ARRAY
26512: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26513: LD_VAR 0 18
26517: NOT
26518: PUSH
26519: LD_INT 40
26521: PPUSH
26522: LD_VAR 0 16
26526: PPUSH
26527: CALL_OW 321
26531: PUSH
26532: LD_INT 2
26534: EQUAL
26535: AND
26536: PUSH
26537: LD_INT 7
26539: PUSH
26540: LD_VAR 0 5
26544: IN
26545: PUSH
26546: LD_INT 28
26548: PUSH
26549: LD_VAR 0 5
26553: IN
26554: OR
26555: PUSH
26556: LD_INT 45
26558: PUSH
26559: LD_VAR 0 5
26563: IN
26564: OR
26565: AND
26566: IFFALSE 26820
// begin hex := GetHexInfo ( x , y ) ;
26568: LD_ADDR_VAR 0 4
26572: PUSH
26573: LD_VAR 0 10
26577: PPUSH
26578: LD_VAR 0 11
26582: PPUSH
26583: CALL_OW 546
26587: ST_TO_ADDR
// if hex [ 1 ] then
26588: LD_VAR 0 4
26592: PUSH
26593: LD_INT 1
26595: ARRAY
26596: IFFALSE 26600
// exit ;
26598: GO 27003
// height := hex [ 2 ] ;
26600: LD_ADDR_VAR 0 15
26604: PUSH
26605: LD_VAR 0 4
26609: PUSH
26610: LD_INT 2
26612: ARRAY
26613: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26614: LD_ADDR_VAR 0 14
26618: PUSH
26619: LD_INT 0
26621: PUSH
26622: LD_INT 2
26624: PUSH
26625: LD_INT 3
26627: PUSH
26628: LD_INT 5
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: LIST
26635: LIST
26636: ST_TO_ADDR
// for i in tmp do
26637: LD_ADDR_VAR 0 8
26641: PUSH
26642: LD_VAR 0 14
26646: PUSH
26647: FOR_IN
26648: IFFALSE 26818
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26650: LD_ADDR_VAR 0 9
26654: PUSH
26655: LD_VAR 0 10
26659: PPUSH
26660: LD_VAR 0 8
26664: PPUSH
26665: LD_INT 5
26667: PPUSH
26668: CALL_OW 272
26672: PUSH
26673: LD_VAR 0 11
26677: PPUSH
26678: LD_VAR 0 8
26682: PPUSH
26683: LD_INT 5
26685: PPUSH
26686: CALL_OW 273
26690: PUSH
26691: EMPTY
26692: LIST
26693: LIST
26694: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26695: LD_VAR 0 9
26699: PUSH
26700: LD_INT 1
26702: ARRAY
26703: PPUSH
26704: LD_VAR 0 9
26708: PUSH
26709: LD_INT 2
26711: ARRAY
26712: PPUSH
26713: CALL_OW 488
26717: IFFALSE 26816
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26719: LD_ADDR_VAR 0 4
26723: PUSH
26724: LD_VAR 0 9
26728: PUSH
26729: LD_INT 1
26731: ARRAY
26732: PPUSH
26733: LD_VAR 0 9
26737: PUSH
26738: LD_INT 2
26740: ARRAY
26741: PPUSH
26742: CALL_OW 546
26746: ST_TO_ADDR
// if hex [ 1 ] then
26747: LD_VAR 0 4
26751: PUSH
26752: LD_INT 1
26754: ARRAY
26755: IFFALSE 26759
// continue ;
26757: GO 26647
// h := hex [ 2 ] ;
26759: LD_ADDR_VAR 0 13
26763: PUSH
26764: LD_VAR 0 4
26768: PUSH
26769: LD_INT 2
26771: ARRAY
26772: ST_TO_ADDR
// if h + 7 < height then
26773: LD_VAR 0 13
26777: PUSH
26778: LD_INT 7
26780: PLUS
26781: PUSH
26782: LD_VAR 0 15
26786: LESS
26787: IFFALSE 26816
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26789: LD_ADDR_VAR 0 18
26793: PUSH
26794: LD_INT 7
26796: PUSH
26797: LD_INT 28
26799: PUSH
26800: LD_INT 45
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: LIST
26807: PUSH
26808: LD_VAR 0 12
26812: ARRAY
26813: ST_TO_ADDR
// break ;
26814: GO 26818
// end ; end ; end ;
26816: GO 26647
26818: POP
26819: POP
// end ; if not weapon then
26820: LD_VAR 0 18
26824: NOT
26825: IFFALSE 26885
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26827: LD_ADDR_VAR 0 5
26831: PUSH
26832: LD_VAR 0 5
26836: PUSH
26837: LD_INT 11
26839: PUSH
26840: LD_INT 30
26842: PUSH
26843: LD_INT 49
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: LIST
26850: DIFF
26851: ST_TO_ADDR
// if not list then
26852: LD_VAR 0 5
26856: NOT
26857: IFFALSE 26861
// exit ;
26859: GO 27003
// weapon := list [ rand ( 1 , list ) ] ;
26861: LD_ADDR_VAR 0 18
26865: PUSH
26866: LD_VAR 0 5
26870: PUSH
26871: LD_INT 1
26873: PPUSH
26874: LD_VAR 0 5
26878: PPUSH
26879: CALL_OW 12
26883: ARRAY
26884: ST_TO_ADDR
// end ; if weapon then
26885: LD_VAR 0 18
26889: IFFALSE 27003
// begin tmp := CostOfWeapon ( weapon ) ;
26891: LD_ADDR_VAR 0 14
26895: PUSH
26896: LD_VAR 0 18
26900: PPUSH
26901: CALL_OW 451
26905: ST_TO_ADDR
// j := GetBase ( tower ) ;
26906: LD_ADDR_VAR 0 9
26910: PUSH
26911: LD_VAR 0 1
26915: PPUSH
26916: CALL_OW 274
26920: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26921: LD_VAR 0 9
26925: PPUSH
26926: LD_INT 1
26928: PPUSH
26929: CALL_OW 275
26933: PUSH
26934: LD_VAR 0 14
26938: PUSH
26939: LD_INT 1
26941: ARRAY
26942: GREATEREQUAL
26943: PUSH
26944: LD_VAR 0 9
26948: PPUSH
26949: LD_INT 2
26951: PPUSH
26952: CALL_OW 275
26956: PUSH
26957: LD_VAR 0 14
26961: PUSH
26962: LD_INT 2
26964: ARRAY
26965: GREATEREQUAL
26966: AND
26967: PUSH
26968: LD_VAR 0 9
26972: PPUSH
26973: LD_INT 3
26975: PPUSH
26976: CALL_OW 275
26980: PUSH
26981: LD_VAR 0 14
26985: PUSH
26986: LD_INT 3
26988: ARRAY
26989: GREATEREQUAL
26990: AND
26991: IFFALSE 27003
// result := weapon ;
26993: LD_ADDR_VAR 0 3
26997: PUSH
26998: LD_VAR 0 18
27002: ST_TO_ADDR
// end ; end ;
27003: LD_VAR 0 3
27007: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27008: LD_INT 0
27010: PPUSH
27011: PPUSH
// result := true ;
27012: LD_ADDR_VAR 0 3
27016: PUSH
27017: LD_INT 1
27019: ST_TO_ADDR
// if array1 = array2 then
27020: LD_VAR 0 1
27024: PUSH
27025: LD_VAR 0 2
27029: EQUAL
27030: IFFALSE 27090
// begin for i = 1 to array1 do
27032: LD_ADDR_VAR 0 4
27036: PUSH
27037: DOUBLE
27038: LD_INT 1
27040: DEC
27041: ST_TO_ADDR
27042: LD_VAR 0 1
27046: PUSH
27047: FOR_TO
27048: IFFALSE 27086
// if array1 [ i ] <> array2 [ i ] then
27050: LD_VAR 0 1
27054: PUSH
27055: LD_VAR 0 4
27059: ARRAY
27060: PUSH
27061: LD_VAR 0 2
27065: PUSH
27066: LD_VAR 0 4
27070: ARRAY
27071: NONEQUAL
27072: IFFALSE 27084
// begin result := false ;
27074: LD_ADDR_VAR 0 3
27078: PUSH
27079: LD_INT 0
27081: ST_TO_ADDR
// break ;
27082: GO 27086
// end ;
27084: GO 27047
27086: POP
27087: POP
// end else
27088: GO 27098
// result := false ;
27090: LD_ADDR_VAR 0 3
27094: PUSH
27095: LD_INT 0
27097: ST_TO_ADDR
// end ;
27098: LD_VAR 0 3
27102: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27103: LD_INT 0
27105: PPUSH
27106: PPUSH
27107: PPUSH
// pom := GetBase ( fac ) ;
27108: LD_ADDR_VAR 0 5
27112: PUSH
27113: LD_VAR 0 1
27117: PPUSH
27118: CALL_OW 274
27122: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27123: LD_ADDR_VAR 0 4
27127: PUSH
27128: LD_VAR 0 2
27132: PUSH
27133: LD_INT 1
27135: ARRAY
27136: PPUSH
27137: LD_VAR 0 2
27141: PUSH
27142: LD_INT 2
27144: ARRAY
27145: PPUSH
27146: LD_VAR 0 2
27150: PUSH
27151: LD_INT 3
27153: ARRAY
27154: PPUSH
27155: LD_VAR 0 2
27159: PUSH
27160: LD_INT 4
27162: ARRAY
27163: PPUSH
27164: CALL_OW 449
27168: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27169: LD_ADDR_VAR 0 3
27173: PUSH
27174: LD_VAR 0 5
27178: PPUSH
27179: LD_INT 1
27181: PPUSH
27182: CALL_OW 275
27186: PUSH
27187: LD_VAR 0 4
27191: PUSH
27192: LD_INT 1
27194: ARRAY
27195: GREATEREQUAL
27196: PUSH
27197: LD_VAR 0 5
27201: PPUSH
27202: LD_INT 2
27204: PPUSH
27205: CALL_OW 275
27209: PUSH
27210: LD_VAR 0 4
27214: PUSH
27215: LD_INT 2
27217: ARRAY
27218: GREATEREQUAL
27219: AND
27220: PUSH
27221: LD_VAR 0 5
27225: PPUSH
27226: LD_INT 3
27228: PPUSH
27229: CALL_OW 275
27233: PUSH
27234: LD_VAR 0 4
27238: PUSH
27239: LD_INT 3
27241: ARRAY
27242: GREATEREQUAL
27243: AND
27244: ST_TO_ADDR
// end ;
27245: LD_VAR 0 3
27249: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27250: LD_INT 0
27252: PPUSH
27253: PPUSH
27254: PPUSH
27255: PPUSH
// pom := GetBase ( building ) ;
27256: LD_ADDR_VAR 0 3
27260: PUSH
27261: LD_VAR 0 1
27265: PPUSH
27266: CALL_OW 274
27270: ST_TO_ADDR
// if not pom then
27271: LD_VAR 0 3
27275: NOT
27276: IFFALSE 27280
// exit ;
27278: GO 27450
// btype := GetBType ( building ) ;
27280: LD_ADDR_VAR 0 5
27284: PUSH
27285: LD_VAR 0 1
27289: PPUSH
27290: CALL_OW 266
27294: ST_TO_ADDR
// if btype = b_armoury then
27295: LD_VAR 0 5
27299: PUSH
27300: LD_INT 4
27302: EQUAL
27303: IFFALSE 27313
// btype := b_barracks ;
27305: LD_ADDR_VAR 0 5
27309: PUSH
27310: LD_INT 5
27312: ST_TO_ADDR
// if btype = b_depot then
27313: LD_VAR 0 5
27317: PUSH
27318: LD_INT 0
27320: EQUAL
27321: IFFALSE 27331
// btype := b_warehouse ;
27323: LD_ADDR_VAR 0 5
27327: PUSH
27328: LD_INT 1
27330: ST_TO_ADDR
// if btype = b_workshop then
27331: LD_VAR 0 5
27335: PUSH
27336: LD_INT 2
27338: EQUAL
27339: IFFALSE 27349
// btype := b_factory ;
27341: LD_ADDR_VAR 0 5
27345: PUSH
27346: LD_INT 3
27348: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27349: LD_ADDR_VAR 0 4
27353: PUSH
27354: LD_VAR 0 5
27358: PPUSH
27359: LD_VAR 0 1
27363: PPUSH
27364: CALL_OW 248
27368: PPUSH
27369: CALL_OW 450
27373: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27374: LD_ADDR_VAR 0 2
27378: PUSH
27379: LD_VAR 0 3
27383: PPUSH
27384: LD_INT 1
27386: PPUSH
27387: CALL_OW 275
27391: PUSH
27392: LD_VAR 0 4
27396: PUSH
27397: LD_INT 1
27399: ARRAY
27400: GREATEREQUAL
27401: PUSH
27402: LD_VAR 0 3
27406: PPUSH
27407: LD_INT 2
27409: PPUSH
27410: CALL_OW 275
27414: PUSH
27415: LD_VAR 0 4
27419: PUSH
27420: LD_INT 2
27422: ARRAY
27423: GREATEREQUAL
27424: AND
27425: PUSH
27426: LD_VAR 0 3
27430: PPUSH
27431: LD_INT 3
27433: PPUSH
27434: CALL_OW 275
27438: PUSH
27439: LD_VAR 0 4
27443: PUSH
27444: LD_INT 3
27446: ARRAY
27447: GREATEREQUAL
27448: AND
27449: ST_TO_ADDR
// end ;
27450: LD_VAR 0 2
27454: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27455: LD_INT 0
27457: PPUSH
27458: PPUSH
27459: PPUSH
// pom := GetBase ( building ) ;
27460: LD_ADDR_VAR 0 4
27464: PUSH
27465: LD_VAR 0 1
27469: PPUSH
27470: CALL_OW 274
27474: ST_TO_ADDR
// if not pom then
27475: LD_VAR 0 4
27479: NOT
27480: IFFALSE 27484
// exit ;
27482: GO 27585
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27484: LD_ADDR_VAR 0 5
27488: PUSH
27489: LD_VAR 0 2
27493: PPUSH
27494: LD_VAR 0 1
27498: PPUSH
27499: CALL_OW 248
27503: PPUSH
27504: CALL_OW 450
27508: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27509: LD_ADDR_VAR 0 3
27513: PUSH
27514: LD_VAR 0 4
27518: PPUSH
27519: LD_INT 1
27521: PPUSH
27522: CALL_OW 275
27526: PUSH
27527: LD_VAR 0 5
27531: PUSH
27532: LD_INT 1
27534: ARRAY
27535: GREATEREQUAL
27536: PUSH
27537: LD_VAR 0 4
27541: PPUSH
27542: LD_INT 2
27544: PPUSH
27545: CALL_OW 275
27549: PUSH
27550: LD_VAR 0 5
27554: PUSH
27555: LD_INT 2
27557: ARRAY
27558: GREATEREQUAL
27559: AND
27560: PUSH
27561: LD_VAR 0 4
27565: PPUSH
27566: LD_INT 3
27568: PPUSH
27569: CALL_OW 275
27573: PUSH
27574: LD_VAR 0 5
27578: PUSH
27579: LD_INT 3
27581: ARRAY
27582: GREATEREQUAL
27583: AND
27584: ST_TO_ADDR
// end ;
27585: LD_VAR 0 3
27589: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27590: LD_INT 0
27592: PPUSH
27593: PPUSH
27594: PPUSH
27595: PPUSH
27596: PPUSH
27597: PPUSH
27598: PPUSH
27599: PPUSH
27600: PPUSH
27601: PPUSH
// result := false ;
27602: LD_ADDR_VAR 0 6
27606: PUSH
27607: LD_INT 0
27609: ST_TO_ADDR
// if not base or not btype or not x or not y then
27610: LD_VAR 0 1
27614: NOT
27615: PUSH
27616: LD_VAR 0 2
27620: NOT
27621: OR
27622: PUSH
27623: LD_VAR 0 3
27627: NOT
27628: OR
27629: PUSH
27630: LD_VAR 0 4
27634: NOT
27635: OR
27636: IFFALSE 27640
// exit ;
27638: GO 28249
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27640: LD_ADDR_VAR 0 12
27644: PUSH
27645: LD_VAR 0 2
27649: PPUSH
27650: LD_VAR 0 3
27654: PPUSH
27655: LD_VAR 0 4
27659: PPUSH
27660: LD_VAR 0 5
27664: PPUSH
27665: LD_VAR 0 1
27669: PUSH
27670: LD_INT 1
27672: ARRAY
27673: PPUSH
27674: CALL_OW 248
27678: PPUSH
27679: LD_INT 0
27681: PPUSH
27682: CALL 29086 0 6
27686: ST_TO_ADDR
// if not hexes then
27687: LD_VAR 0 12
27691: NOT
27692: IFFALSE 27696
// exit ;
27694: GO 28249
// for i = 1 to hexes do
27696: LD_ADDR_VAR 0 7
27700: PUSH
27701: DOUBLE
27702: LD_INT 1
27704: DEC
27705: ST_TO_ADDR
27706: LD_VAR 0 12
27710: PUSH
27711: FOR_TO
27712: IFFALSE 28247
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27714: LD_ADDR_VAR 0 11
27718: PUSH
27719: LD_VAR 0 12
27723: PUSH
27724: LD_VAR 0 7
27728: ARRAY
27729: PUSH
27730: LD_INT 1
27732: ARRAY
27733: PPUSH
27734: LD_VAR 0 12
27738: PUSH
27739: LD_VAR 0 7
27743: ARRAY
27744: PUSH
27745: LD_INT 2
27747: ARRAY
27748: PPUSH
27749: CALL_OW 428
27753: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27754: LD_VAR 0 12
27758: PUSH
27759: LD_VAR 0 7
27763: ARRAY
27764: PUSH
27765: LD_INT 1
27767: ARRAY
27768: PPUSH
27769: LD_VAR 0 12
27773: PUSH
27774: LD_VAR 0 7
27778: ARRAY
27779: PUSH
27780: LD_INT 2
27782: ARRAY
27783: PPUSH
27784: CALL_OW 351
27788: PUSH
27789: LD_VAR 0 12
27793: PUSH
27794: LD_VAR 0 7
27798: ARRAY
27799: PUSH
27800: LD_INT 1
27802: ARRAY
27803: PPUSH
27804: LD_VAR 0 12
27808: PUSH
27809: LD_VAR 0 7
27813: ARRAY
27814: PUSH
27815: LD_INT 2
27817: ARRAY
27818: PPUSH
27819: CALL_OW 488
27823: NOT
27824: OR
27825: PUSH
27826: LD_VAR 0 11
27830: PPUSH
27831: CALL_OW 247
27835: PUSH
27836: LD_INT 3
27838: EQUAL
27839: OR
27840: IFFALSE 27846
// exit ;
27842: POP
27843: POP
27844: GO 28249
// if not tmp or not tmp in base then
27846: LD_VAR 0 11
27850: NOT
27851: PUSH
27852: LD_VAR 0 11
27856: PUSH
27857: LD_VAR 0 1
27861: IN
27862: NOT
27863: OR
27864: IFFALSE 27868
// continue ;
27866: GO 27711
// result := true ;
27868: LD_ADDR_VAR 0 6
27872: PUSH
27873: LD_INT 1
27875: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27876: LD_ADDR_VAR 0 15
27880: PUSH
27881: LD_VAR 0 1
27885: PPUSH
27886: LD_INT 22
27888: PUSH
27889: LD_VAR 0 11
27893: PPUSH
27894: CALL_OW 255
27898: PUSH
27899: EMPTY
27900: LIST
27901: LIST
27902: PUSH
27903: LD_INT 2
27905: PUSH
27906: LD_INT 30
27908: PUSH
27909: LD_INT 0
27911: PUSH
27912: EMPTY
27913: LIST
27914: LIST
27915: PUSH
27916: LD_INT 30
27918: PUSH
27919: LD_INT 1
27921: PUSH
27922: EMPTY
27923: LIST
27924: LIST
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: LIST
27930: PUSH
27931: EMPTY
27932: LIST
27933: LIST
27934: PPUSH
27935: CALL_OW 72
27939: ST_TO_ADDR
// if dep then
27940: LD_VAR 0 15
27944: IFFALSE 28080
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27946: LD_ADDR_VAR 0 14
27950: PUSH
27951: LD_VAR 0 15
27955: PUSH
27956: LD_INT 1
27958: ARRAY
27959: PPUSH
27960: CALL_OW 250
27964: PPUSH
27965: LD_VAR 0 15
27969: PUSH
27970: LD_INT 1
27972: ARRAY
27973: PPUSH
27974: CALL_OW 254
27978: PPUSH
27979: LD_INT 5
27981: PPUSH
27982: CALL_OW 272
27986: PUSH
27987: LD_VAR 0 15
27991: PUSH
27992: LD_INT 1
27994: ARRAY
27995: PPUSH
27996: CALL_OW 251
28000: PPUSH
28001: LD_VAR 0 15
28005: PUSH
28006: LD_INT 1
28008: ARRAY
28009: PPUSH
28010: CALL_OW 254
28014: PPUSH
28015: LD_INT 5
28017: PPUSH
28018: CALL_OW 273
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28027: LD_VAR 0 14
28031: PUSH
28032: LD_INT 1
28034: ARRAY
28035: PPUSH
28036: LD_VAR 0 14
28040: PUSH
28041: LD_INT 2
28043: ARRAY
28044: PPUSH
28045: CALL_OW 488
28049: IFFALSE 28080
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28051: LD_VAR 0 11
28055: PPUSH
28056: LD_VAR 0 14
28060: PUSH
28061: LD_INT 1
28063: ARRAY
28064: PPUSH
28065: LD_VAR 0 14
28069: PUSH
28070: LD_INT 2
28072: ARRAY
28073: PPUSH
28074: CALL_OW 111
// continue ;
28078: GO 27711
// end ; end ; r := GetDir ( tmp ) ;
28080: LD_ADDR_VAR 0 13
28084: PUSH
28085: LD_VAR 0 11
28089: PPUSH
28090: CALL_OW 254
28094: ST_TO_ADDR
// if r = 5 then
28095: LD_VAR 0 13
28099: PUSH
28100: LD_INT 5
28102: EQUAL
28103: IFFALSE 28113
// r := 0 ;
28105: LD_ADDR_VAR 0 13
28109: PUSH
28110: LD_INT 0
28112: ST_TO_ADDR
// for j = r to 5 do
28113: LD_ADDR_VAR 0 8
28117: PUSH
28118: DOUBLE
28119: LD_VAR 0 13
28123: DEC
28124: ST_TO_ADDR
28125: LD_INT 5
28127: PUSH
28128: FOR_TO
28129: IFFALSE 28243
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28131: LD_ADDR_VAR 0 9
28135: PUSH
28136: LD_VAR 0 11
28140: PPUSH
28141: CALL_OW 250
28145: PPUSH
28146: LD_VAR 0 8
28150: PPUSH
28151: LD_INT 2
28153: PPUSH
28154: CALL_OW 272
28158: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28159: LD_ADDR_VAR 0 10
28163: PUSH
28164: LD_VAR 0 11
28168: PPUSH
28169: CALL_OW 251
28173: PPUSH
28174: LD_VAR 0 8
28178: PPUSH
28179: LD_INT 2
28181: PPUSH
28182: CALL_OW 273
28186: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28187: LD_VAR 0 9
28191: PPUSH
28192: LD_VAR 0 10
28196: PPUSH
28197: CALL_OW 488
28201: PUSH
28202: LD_VAR 0 9
28206: PPUSH
28207: LD_VAR 0 10
28211: PPUSH
28212: CALL_OW 428
28216: NOT
28217: AND
28218: IFFALSE 28241
// begin ComMoveXY ( tmp , _x , _y ) ;
28220: LD_VAR 0 11
28224: PPUSH
28225: LD_VAR 0 9
28229: PPUSH
28230: LD_VAR 0 10
28234: PPUSH
28235: CALL_OW 111
// break ;
28239: GO 28243
// end ; end ;
28241: GO 28128
28243: POP
28244: POP
// end ;
28245: GO 27711
28247: POP
28248: POP
// end ;
28249: LD_VAR 0 6
28253: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28254: LD_INT 0
28256: PPUSH
28257: PPUSH
28258: PPUSH
28259: PPUSH
28260: PPUSH
28261: PPUSH
28262: PPUSH
28263: PPUSH
28264: PPUSH
28265: PPUSH
// result := false ;
28266: LD_ADDR_VAR 0 6
28270: PUSH
28271: LD_INT 0
28273: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28274: LD_VAR 0 1
28278: NOT
28279: PUSH
28280: LD_VAR 0 1
28284: PPUSH
28285: CALL_OW 266
28289: PUSH
28290: LD_INT 0
28292: PUSH
28293: LD_INT 1
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: IN
28300: NOT
28301: OR
28302: PUSH
28303: LD_VAR 0 2
28307: NOT
28308: OR
28309: PUSH
28310: LD_VAR 0 5
28314: PUSH
28315: LD_INT 0
28317: PUSH
28318: LD_INT 1
28320: PUSH
28321: LD_INT 2
28323: PUSH
28324: LD_INT 3
28326: PUSH
28327: LD_INT 4
28329: PUSH
28330: LD_INT 5
28332: PUSH
28333: EMPTY
28334: LIST
28335: LIST
28336: LIST
28337: LIST
28338: LIST
28339: LIST
28340: IN
28341: NOT
28342: OR
28343: PUSH
28344: LD_VAR 0 3
28348: PPUSH
28349: LD_VAR 0 4
28353: PPUSH
28354: CALL_OW 488
28358: NOT
28359: OR
28360: IFFALSE 28364
// exit ;
28362: GO 29081
// pom := GetBase ( depot ) ;
28364: LD_ADDR_VAR 0 10
28368: PUSH
28369: LD_VAR 0 1
28373: PPUSH
28374: CALL_OW 274
28378: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28379: LD_ADDR_VAR 0 11
28383: PUSH
28384: LD_VAR 0 2
28388: PPUSH
28389: LD_VAR 0 1
28393: PPUSH
28394: CALL_OW 248
28398: PPUSH
28399: CALL_OW 450
28403: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28404: LD_VAR 0 10
28408: PPUSH
28409: LD_INT 1
28411: PPUSH
28412: CALL_OW 275
28416: PUSH
28417: LD_VAR 0 11
28421: PUSH
28422: LD_INT 1
28424: ARRAY
28425: GREATEREQUAL
28426: PUSH
28427: LD_VAR 0 10
28431: PPUSH
28432: LD_INT 2
28434: PPUSH
28435: CALL_OW 275
28439: PUSH
28440: LD_VAR 0 11
28444: PUSH
28445: LD_INT 2
28447: ARRAY
28448: GREATEREQUAL
28449: AND
28450: PUSH
28451: LD_VAR 0 10
28455: PPUSH
28456: LD_INT 3
28458: PPUSH
28459: CALL_OW 275
28463: PUSH
28464: LD_VAR 0 11
28468: PUSH
28469: LD_INT 3
28471: ARRAY
28472: GREATEREQUAL
28473: AND
28474: NOT
28475: IFFALSE 28479
// exit ;
28477: GO 29081
// if GetBType ( depot ) = b_depot then
28479: LD_VAR 0 1
28483: PPUSH
28484: CALL_OW 266
28488: PUSH
28489: LD_INT 0
28491: EQUAL
28492: IFFALSE 28504
// dist := 28 else
28494: LD_ADDR_VAR 0 14
28498: PUSH
28499: LD_INT 28
28501: ST_TO_ADDR
28502: GO 28512
// dist := 36 ;
28504: LD_ADDR_VAR 0 14
28508: PUSH
28509: LD_INT 36
28511: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28512: LD_VAR 0 1
28516: PPUSH
28517: LD_VAR 0 3
28521: PPUSH
28522: LD_VAR 0 4
28526: PPUSH
28527: CALL_OW 297
28531: PUSH
28532: LD_VAR 0 14
28536: GREATER
28537: IFFALSE 28541
// exit ;
28539: GO 29081
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28541: LD_ADDR_VAR 0 12
28545: PUSH
28546: LD_VAR 0 2
28550: PPUSH
28551: LD_VAR 0 3
28555: PPUSH
28556: LD_VAR 0 4
28560: PPUSH
28561: LD_VAR 0 5
28565: PPUSH
28566: LD_VAR 0 1
28570: PPUSH
28571: CALL_OW 248
28575: PPUSH
28576: LD_INT 0
28578: PPUSH
28579: CALL 29086 0 6
28583: ST_TO_ADDR
// if not hexes then
28584: LD_VAR 0 12
28588: NOT
28589: IFFALSE 28593
// exit ;
28591: GO 29081
// hex := GetHexInfo ( x , y ) ;
28593: LD_ADDR_VAR 0 15
28597: PUSH
28598: LD_VAR 0 3
28602: PPUSH
28603: LD_VAR 0 4
28607: PPUSH
28608: CALL_OW 546
28612: ST_TO_ADDR
// if hex [ 1 ] then
28613: LD_VAR 0 15
28617: PUSH
28618: LD_INT 1
28620: ARRAY
28621: IFFALSE 28625
// exit ;
28623: GO 29081
// height := hex [ 2 ] ;
28625: LD_ADDR_VAR 0 13
28629: PUSH
28630: LD_VAR 0 15
28634: PUSH
28635: LD_INT 2
28637: ARRAY
28638: ST_TO_ADDR
// for i = 1 to hexes do
28639: LD_ADDR_VAR 0 7
28643: PUSH
28644: DOUBLE
28645: LD_INT 1
28647: DEC
28648: ST_TO_ADDR
28649: LD_VAR 0 12
28653: PUSH
28654: FOR_TO
28655: IFFALSE 28985
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28657: LD_VAR 0 12
28661: PUSH
28662: LD_VAR 0 7
28666: ARRAY
28667: PUSH
28668: LD_INT 1
28670: ARRAY
28671: PPUSH
28672: LD_VAR 0 12
28676: PUSH
28677: LD_VAR 0 7
28681: ARRAY
28682: PUSH
28683: LD_INT 2
28685: ARRAY
28686: PPUSH
28687: CALL_OW 488
28691: NOT
28692: PUSH
28693: LD_VAR 0 12
28697: PUSH
28698: LD_VAR 0 7
28702: ARRAY
28703: PUSH
28704: LD_INT 1
28706: ARRAY
28707: PPUSH
28708: LD_VAR 0 12
28712: PUSH
28713: LD_VAR 0 7
28717: ARRAY
28718: PUSH
28719: LD_INT 2
28721: ARRAY
28722: PPUSH
28723: CALL_OW 428
28727: PUSH
28728: LD_INT 0
28730: GREATER
28731: OR
28732: PUSH
28733: LD_VAR 0 12
28737: PUSH
28738: LD_VAR 0 7
28742: ARRAY
28743: PUSH
28744: LD_INT 1
28746: ARRAY
28747: PPUSH
28748: LD_VAR 0 12
28752: PUSH
28753: LD_VAR 0 7
28757: ARRAY
28758: PUSH
28759: LD_INT 2
28761: ARRAY
28762: PPUSH
28763: CALL_OW 351
28767: OR
28768: IFFALSE 28774
// exit ;
28770: POP
28771: POP
28772: GO 29081
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28774: LD_ADDR_VAR 0 8
28778: PUSH
28779: LD_VAR 0 12
28783: PUSH
28784: LD_VAR 0 7
28788: ARRAY
28789: PUSH
28790: LD_INT 1
28792: ARRAY
28793: PPUSH
28794: LD_VAR 0 12
28798: PUSH
28799: LD_VAR 0 7
28803: ARRAY
28804: PUSH
28805: LD_INT 2
28807: ARRAY
28808: PPUSH
28809: CALL_OW 546
28813: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28814: LD_VAR 0 8
28818: PUSH
28819: LD_INT 1
28821: ARRAY
28822: PUSH
28823: LD_VAR 0 8
28827: PUSH
28828: LD_INT 2
28830: ARRAY
28831: PUSH
28832: LD_VAR 0 13
28836: PUSH
28837: LD_INT 2
28839: PLUS
28840: GREATER
28841: OR
28842: PUSH
28843: LD_VAR 0 8
28847: PUSH
28848: LD_INT 2
28850: ARRAY
28851: PUSH
28852: LD_VAR 0 13
28856: PUSH
28857: LD_INT 2
28859: MINUS
28860: LESS
28861: OR
28862: PUSH
28863: LD_VAR 0 8
28867: PUSH
28868: LD_INT 3
28870: ARRAY
28871: PUSH
28872: LD_INT 0
28874: PUSH
28875: LD_INT 8
28877: PUSH
28878: LD_INT 9
28880: PUSH
28881: LD_INT 10
28883: PUSH
28884: LD_INT 11
28886: PUSH
28887: LD_INT 12
28889: PUSH
28890: LD_INT 13
28892: PUSH
28893: LD_INT 16
28895: PUSH
28896: LD_INT 17
28898: PUSH
28899: LD_INT 18
28901: PUSH
28902: LD_INT 19
28904: PUSH
28905: LD_INT 20
28907: PUSH
28908: LD_INT 21
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: LIST
28915: LIST
28916: LIST
28917: LIST
28918: LIST
28919: LIST
28920: LIST
28921: LIST
28922: LIST
28923: LIST
28924: LIST
28925: IN
28926: NOT
28927: OR
28928: PUSH
28929: LD_VAR 0 8
28933: PUSH
28934: LD_INT 5
28936: ARRAY
28937: NOT
28938: OR
28939: PUSH
28940: LD_VAR 0 8
28944: PUSH
28945: LD_INT 6
28947: ARRAY
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: LD_INT 2
28954: PUSH
28955: LD_INT 7
28957: PUSH
28958: LD_INT 9
28960: PUSH
28961: LD_INT 10
28963: PUSH
28964: LD_INT 11
28966: PUSH
28967: EMPTY
28968: LIST
28969: LIST
28970: LIST
28971: LIST
28972: LIST
28973: LIST
28974: IN
28975: NOT
28976: OR
28977: IFFALSE 28983
// exit ;
28979: POP
28980: POP
28981: GO 29081
// end ;
28983: GO 28654
28985: POP
28986: POP
// side := GetSide ( depot ) ;
28987: LD_ADDR_VAR 0 9
28991: PUSH
28992: LD_VAR 0 1
28996: PPUSH
28997: CALL_OW 255
29001: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29002: LD_VAR 0 9
29006: PPUSH
29007: LD_VAR 0 3
29011: PPUSH
29012: LD_VAR 0 4
29016: PPUSH
29017: LD_INT 20
29019: PPUSH
29020: CALL 21735 0 4
29024: PUSH
29025: LD_INT 4
29027: ARRAY
29028: IFFALSE 29032
// exit ;
29030: GO 29081
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29032: LD_VAR 0 2
29036: PUSH
29037: LD_INT 29
29039: PUSH
29040: LD_INT 30
29042: PUSH
29043: EMPTY
29044: LIST
29045: LIST
29046: IN
29047: PUSH
29048: LD_VAR 0 3
29052: PPUSH
29053: LD_VAR 0 4
29057: PPUSH
29058: LD_VAR 0 9
29062: PPUSH
29063: CALL_OW 440
29067: NOT
29068: AND
29069: IFFALSE 29073
// exit ;
29071: GO 29081
// result := true ;
29073: LD_ADDR_VAR 0 6
29077: PUSH
29078: LD_INT 1
29080: ST_TO_ADDR
// end ;
29081: LD_VAR 0 6
29085: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29086: LD_INT 0
29088: PPUSH
29089: PPUSH
29090: PPUSH
29091: PPUSH
29092: PPUSH
29093: PPUSH
29094: PPUSH
29095: PPUSH
29096: PPUSH
29097: PPUSH
29098: PPUSH
29099: PPUSH
29100: PPUSH
29101: PPUSH
29102: PPUSH
29103: PPUSH
29104: PPUSH
29105: PPUSH
29106: PPUSH
29107: PPUSH
29108: PPUSH
29109: PPUSH
29110: PPUSH
29111: PPUSH
29112: PPUSH
29113: PPUSH
29114: PPUSH
29115: PPUSH
29116: PPUSH
29117: PPUSH
29118: PPUSH
29119: PPUSH
29120: PPUSH
29121: PPUSH
29122: PPUSH
29123: PPUSH
29124: PPUSH
29125: PPUSH
29126: PPUSH
29127: PPUSH
29128: PPUSH
29129: PPUSH
29130: PPUSH
29131: PPUSH
29132: PPUSH
29133: PPUSH
29134: PPUSH
29135: PPUSH
29136: PPUSH
29137: PPUSH
29138: PPUSH
29139: PPUSH
29140: PPUSH
29141: PPUSH
29142: PPUSH
29143: PPUSH
29144: PPUSH
29145: PPUSH
// result = [ ] ;
29146: LD_ADDR_VAR 0 7
29150: PUSH
29151: EMPTY
29152: ST_TO_ADDR
// temp_list = [ ] ;
29153: LD_ADDR_VAR 0 9
29157: PUSH
29158: EMPTY
29159: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29160: LD_VAR 0 4
29164: PUSH
29165: LD_INT 0
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 2
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: LD_INT 4
29179: PUSH
29180: LD_INT 5
29182: PUSH
29183: EMPTY
29184: LIST
29185: LIST
29186: LIST
29187: LIST
29188: LIST
29189: LIST
29190: IN
29191: NOT
29192: PUSH
29193: LD_VAR 0 1
29197: PUSH
29198: LD_INT 0
29200: PUSH
29201: LD_INT 1
29203: PUSH
29204: EMPTY
29205: LIST
29206: LIST
29207: IN
29208: PUSH
29209: LD_VAR 0 5
29213: PUSH
29214: LD_INT 1
29216: PUSH
29217: LD_INT 2
29219: PUSH
29220: LD_INT 3
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: LIST
29227: IN
29228: NOT
29229: AND
29230: OR
29231: IFFALSE 29235
// exit ;
29233: GO 47626
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29235: LD_VAR 0 1
29239: PUSH
29240: LD_INT 6
29242: PUSH
29243: LD_INT 7
29245: PUSH
29246: LD_INT 8
29248: PUSH
29249: LD_INT 13
29251: PUSH
29252: LD_INT 12
29254: PUSH
29255: LD_INT 15
29257: PUSH
29258: LD_INT 11
29260: PUSH
29261: LD_INT 14
29263: PUSH
29264: LD_INT 10
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: LIST
29276: LIST
29277: IN
29278: IFFALSE 29288
// btype = b_lab ;
29280: LD_ADDR_VAR 0 1
29284: PUSH
29285: LD_INT 6
29287: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29288: LD_VAR 0 6
29292: PUSH
29293: LD_INT 0
29295: PUSH
29296: LD_INT 1
29298: PUSH
29299: LD_INT 2
29301: PUSH
29302: EMPTY
29303: LIST
29304: LIST
29305: LIST
29306: IN
29307: NOT
29308: PUSH
29309: LD_VAR 0 1
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 1
29319: PUSH
29320: LD_INT 2
29322: PUSH
29323: LD_INT 3
29325: PUSH
29326: LD_INT 6
29328: PUSH
29329: LD_INT 36
29331: PUSH
29332: LD_INT 4
29334: PUSH
29335: LD_INT 5
29337: PUSH
29338: LD_INT 31
29340: PUSH
29341: LD_INT 32
29343: PUSH
29344: LD_INT 33
29346: PUSH
29347: EMPTY
29348: LIST
29349: LIST
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: IN
29360: NOT
29361: PUSH
29362: LD_VAR 0 6
29366: PUSH
29367: LD_INT 1
29369: EQUAL
29370: AND
29371: OR
29372: PUSH
29373: LD_VAR 0 1
29377: PUSH
29378: LD_INT 2
29380: PUSH
29381: LD_INT 3
29383: PUSH
29384: EMPTY
29385: LIST
29386: LIST
29387: IN
29388: NOT
29389: PUSH
29390: LD_VAR 0 6
29394: PUSH
29395: LD_INT 2
29397: EQUAL
29398: AND
29399: OR
29400: IFFALSE 29410
// mode = 0 ;
29402: LD_ADDR_VAR 0 6
29406: PUSH
29407: LD_INT 0
29409: ST_TO_ADDR
// case mode of 0 :
29410: LD_VAR 0 6
29414: PUSH
29415: LD_INT 0
29417: DOUBLE
29418: EQUAL
29419: IFTRUE 29423
29421: GO 40876
29423: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29424: LD_ADDR_VAR 0 11
29428: PUSH
29429: LD_INT 0
29431: PUSH
29432: LD_INT 0
29434: PUSH
29435: EMPTY
29436: LIST
29437: LIST
29438: PUSH
29439: LD_INT 0
29441: PUSH
29442: LD_INT 1
29444: NEG
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 1
29452: PUSH
29453: LD_INT 0
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PUSH
29460: LD_INT 1
29462: PUSH
29463: LD_INT 1
29465: PUSH
29466: EMPTY
29467: LIST
29468: LIST
29469: PUSH
29470: LD_INT 0
29472: PUSH
29473: LD_INT 1
29475: PUSH
29476: EMPTY
29477: LIST
29478: LIST
29479: PUSH
29480: LD_INT 1
29482: NEG
29483: PUSH
29484: LD_INT 0
29486: PUSH
29487: EMPTY
29488: LIST
29489: LIST
29490: PUSH
29491: LD_INT 1
29493: NEG
29494: PUSH
29495: LD_INT 1
29497: NEG
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PUSH
29503: LD_INT 1
29505: NEG
29506: PUSH
29507: LD_INT 2
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 0
29517: PUSH
29518: LD_INT 2
29520: NEG
29521: PUSH
29522: EMPTY
29523: LIST
29524: LIST
29525: PUSH
29526: LD_INT 1
29528: PUSH
29529: LD_INT 1
29531: NEG
29532: PUSH
29533: EMPTY
29534: LIST
29535: LIST
29536: PUSH
29537: LD_INT 1
29539: PUSH
29540: LD_INT 2
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PUSH
29547: LD_INT 0
29549: PUSH
29550: LD_INT 2
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 1
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: PUSH
29571: LD_INT 3
29573: PUSH
29574: EMPTY
29575: LIST
29576: LIST
29577: PUSH
29578: LD_INT 0
29580: PUSH
29581: LD_INT 3
29583: PUSH
29584: EMPTY
29585: LIST
29586: LIST
29587: PUSH
29588: LD_INT 1
29590: NEG
29591: PUSH
29592: LD_INT 2
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: LIST
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29617: LD_ADDR_VAR 0 12
29621: PUSH
29622: LD_INT 0
29624: PUSH
29625: LD_INT 0
29627: PUSH
29628: EMPTY
29629: LIST
29630: LIST
29631: PUSH
29632: LD_INT 0
29634: PUSH
29635: LD_INT 1
29637: NEG
29638: PUSH
29639: EMPTY
29640: LIST
29641: LIST
29642: PUSH
29643: LD_INT 1
29645: PUSH
29646: LD_INT 0
29648: PUSH
29649: EMPTY
29650: LIST
29651: LIST
29652: PUSH
29653: LD_INT 1
29655: PUSH
29656: LD_INT 1
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 0
29665: PUSH
29666: LD_INT 1
29668: PUSH
29669: EMPTY
29670: LIST
29671: LIST
29672: PUSH
29673: LD_INT 1
29675: NEG
29676: PUSH
29677: LD_INT 0
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 1
29686: NEG
29687: PUSH
29688: LD_INT 1
29690: NEG
29691: PUSH
29692: EMPTY
29693: LIST
29694: LIST
29695: PUSH
29696: LD_INT 1
29698: PUSH
29699: LD_INT 1
29701: NEG
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 2
29709: PUSH
29710: LD_INT 0
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 2
29719: PUSH
29720: LD_INT 1
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 1
29729: NEG
29730: PUSH
29731: LD_INT 1
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 2
29740: NEG
29741: PUSH
29742: LD_INT 0
29744: PUSH
29745: EMPTY
29746: LIST
29747: LIST
29748: PUSH
29749: LD_INT 2
29751: NEG
29752: PUSH
29753: LD_INT 1
29755: NEG
29756: PUSH
29757: EMPTY
29758: LIST
29759: LIST
29760: PUSH
29761: LD_INT 2
29763: NEG
29764: PUSH
29765: LD_INT 1
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 3
29774: NEG
29775: PUSH
29776: LD_INT 0
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 3
29785: NEG
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: LIST
29799: LIST
29800: LIST
29801: LIST
29802: LIST
29803: LIST
29804: LIST
29805: LIST
29806: LIST
29807: LIST
29808: LIST
29809: LIST
29810: LIST
29811: LIST
29812: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29813: LD_ADDR_VAR 0 13
29817: PUSH
29818: LD_INT 0
29820: PUSH
29821: LD_INT 0
29823: PUSH
29824: EMPTY
29825: LIST
29826: LIST
29827: PUSH
29828: LD_INT 0
29830: PUSH
29831: LD_INT 1
29833: NEG
29834: PUSH
29835: EMPTY
29836: LIST
29837: LIST
29838: PUSH
29839: LD_INT 1
29841: PUSH
29842: LD_INT 0
29844: PUSH
29845: EMPTY
29846: LIST
29847: LIST
29848: PUSH
29849: LD_INT 1
29851: PUSH
29852: LD_INT 1
29854: PUSH
29855: EMPTY
29856: LIST
29857: LIST
29858: PUSH
29859: LD_INT 0
29861: PUSH
29862: LD_INT 1
29864: PUSH
29865: EMPTY
29866: LIST
29867: LIST
29868: PUSH
29869: LD_INT 1
29871: NEG
29872: PUSH
29873: LD_INT 0
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 1
29882: NEG
29883: PUSH
29884: LD_INT 1
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: LD_INT 2
29898: NEG
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: LD_INT 2
29906: PUSH
29907: LD_INT 1
29909: PUSH
29910: EMPTY
29911: LIST
29912: LIST
29913: PUSH
29914: LD_INT 2
29916: PUSH
29917: LD_INT 2
29919: PUSH
29920: EMPTY
29921: LIST
29922: LIST
29923: PUSH
29924: LD_INT 1
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 2
29936: NEG
29937: PUSH
29938: LD_INT 1
29940: NEG
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 2
29948: NEG
29949: PUSH
29950: LD_INT 2
29952: NEG
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: PUSH
29958: LD_INT 2
29960: NEG
29961: PUSH
29962: LD_INT 3
29964: NEG
29965: PUSH
29966: EMPTY
29967: LIST
29968: LIST
29969: PUSH
29970: LD_INT 3
29972: NEG
29973: PUSH
29974: LD_INT 2
29976: NEG
29977: PUSH
29978: EMPTY
29979: LIST
29980: LIST
29981: PUSH
29982: LD_INT 3
29984: NEG
29985: PUSH
29986: LD_INT 3
29988: NEG
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: LIST
29998: LIST
29999: LIST
30000: LIST
30001: LIST
30002: LIST
30003: LIST
30004: LIST
30005: LIST
30006: LIST
30007: LIST
30008: LIST
30009: LIST
30010: LIST
30011: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30012: LD_ADDR_VAR 0 14
30016: PUSH
30017: LD_INT 0
30019: PUSH
30020: LD_INT 0
30022: PUSH
30023: EMPTY
30024: LIST
30025: LIST
30026: PUSH
30027: LD_INT 0
30029: PUSH
30030: LD_INT 1
30032: NEG
30033: PUSH
30034: EMPTY
30035: LIST
30036: LIST
30037: PUSH
30038: LD_INT 1
30040: PUSH
30041: LD_INT 0
30043: PUSH
30044: EMPTY
30045: LIST
30046: LIST
30047: PUSH
30048: LD_INT 1
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: EMPTY
30055: LIST
30056: LIST
30057: PUSH
30058: LD_INT 0
30060: PUSH
30061: LD_INT 1
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: PUSH
30068: LD_INT 1
30070: NEG
30071: PUSH
30072: LD_INT 0
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: LD_INT 1
30081: NEG
30082: PUSH
30083: LD_INT 1
30085: NEG
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 1
30093: NEG
30094: PUSH
30095: LD_INT 2
30097: NEG
30098: PUSH
30099: EMPTY
30100: LIST
30101: LIST
30102: PUSH
30103: LD_INT 0
30105: PUSH
30106: LD_INT 2
30108: NEG
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PUSH
30114: LD_INT 1
30116: PUSH
30117: LD_INT 1
30119: NEG
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: LD_INT 1
30127: PUSH
30128: LD_INT 2
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 0
30137: PUSH
30138: LD_INT 2
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 1
30147: NEG
30148: PUSH
30149: LD_INT 1
30151: PUSH
30152: EMPTY
30153: LIST
30154: LIST
30155: PUSH
30156: LD_INT 1
30158: NEG
30159: PUSH
30160: LD_INT 3
30162: NEG
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PUSH
30168: LD_INT 0
30170: PUSH
30171: LD_INT 3
30173: NEG
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 2
30184: NEG
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: LIST
30202: LIST
30203: LIST
30204: LIST
30205: LIST
30206: LIST
30207: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30208: LD_ADDR_VAR 0 15
30212: PUSH
30213: LD_INT 0
30215: PUSH
30216: LD_INT 0
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: LD_INT 0
30225: PUSH
30226: LD_INT 1
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 1
30236: PUSH
30237: LD_INT 0
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: LD_INT 1
30246: PUSH
30247: LD_INT 1
30249: PUSH
30250: EMPTY
30251: LIST
30252: LIST
30253: PUSH
30254: LD_INT 0
30256: PUSH
30257: LD_INT 1
30259: PUSH
30260: EMPTY
30261: LIST
30262: LIST
30263: PUSH
30264: LD_INT 1
30266: NEG
30267: PUSH
30268: LD_INT 0
30270: PUSH
30271: EMPTY
30272: LIST
30273: LIST
30274: PUSH
30275: LD_INT 1
30277: NEG
30278: PUSH
30279: LD_INT 1
30281: NEG
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: LD_INT 1
30292: NEG
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: PUSH
30298: LD_INT 2
30300: PUSH
30301: LD_INT 0
30303: PUSH
30304: EMPTY
30305: LIST
30306: LIST
30307: PUSH
30308: LD_INT 2
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 1
30320: NEG
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 2
30331: NEG
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: NEG
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 2
30354: PUSH
30355: LD_INT 1
30357: NEG
30358: PUSH
30359: EMPTY
30360: LIST
30361: LIST
30362: PUSH
30363: LD_INT 3
30365: PUSH
30366: LD_INT 0
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 3
30375: PUSH
30376: LD_INT 1
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: EMPTY
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: LIST
30398: LIST
30399: LIST
30400: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30401: LD_ADDR_VAR 0 16
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: LD_INT 0
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PUSH
30416: LD_INT 0
30418: PUSH
30419: LD_INT 1
30421: NEG
30422: PUSH
30423: EMPTY
30424: LIST
30425: LIST
30426: PUSH
30427: LD_INT 1
30429: PUSH
30430: LD_INT 0
30432: PUSH
30433: EMPTY
30434: LIST
30435: LIST
30436: PUSH
30437: LD_INT 1
30439: PUSH
30440: LD_INT 1
30442: PUSH
30443: EMPTY
30444: LIST
30445: LIST
30446: PUSH
30447: LD_INT 0
30449: PUSH
30450: LD_INT 1
30452: PUSH
30453: EMPTY
30454: LIST
30455: LIST
30456: PUSH
30457: LD_INT 1
30459: NEG
30460: PUSH
30461: LD_INT 0
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: LD_INT 1
30474: NEG
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: LD_INT 2
30486: NEG
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 2
30494: PUSH
30495: LD_INT 1
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 2
30504: PUSH
30505: LD_INT 2
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 1
30514: PUSH
30515: LD_INT 2
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 2
30524: NEG
30525: PUSH
30526: LD_INT 1
30528: NEG
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 2
30536: NEG
30537: PUSH
30538: LD_INT 2
30540: NEG
30541: PUSH
30542: EMPTY
30543: LIST
30544: LIST
30545: PUSH
30546: LD_INT 3
30548: PUSH
30549: LD_INT 2
30551: PUSH
30552: EMPTY
30553: LIST
30554: LIST
30555: PUSH
30556: LD_INT 3
30558: PUSH
30559: LD_INT 3
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: PUSH
30566: LD_INT 2
30568: PUSH
30569: LD_INT 3
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: EMPTY
30577: LIST
30578: LIST
30579: LIST
30580: LIST
30581: LIST
30582: LIST
30583: LIST
30584: LIST
30585: LIST
30586: LIST
30587: LIST
30588: LIST
30589: LIST
30590: LIST
30591: LIST
30592: LIST
30593: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30594: LD_ADDR_VAR 0 17
30598: PUSH
30599: LD_INT 0
30601: PUSH
30602: LD_INT 0
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: LD_INT 1
30614: NEG
30615: PUSH
30616: EMPTY
30617: LIST
30618: LIST
30619: PUSH
30620: LD_INT 1
30622: PUSH
30623: LD_INT 0
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 0
30642: PUSH
30643: LD_INT 1
30645: PUSH
30646: EMPTY
30647: LIST
30648: LIST
30649: PUSH
30650: LD_INT 1
30652: NEG
30653: PUSH
30654: LD_INT 0
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 1
30663: NEG
30664: PUSH
30665: LD_INT 1
30667: NEG
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 1
30675: NEG
30676: PUSH
30677: LD_INT 2
30679: NEG
30680: PUSH
30681: EMPTY
30682: LIST
30683: LIST
30684: PUSH
30685: LD_INT 0
30687: PUSH
30688: LD_INT 2
30690: NEG
30691: PUSH
30692: EMPTY
30693: LIST
30694: LIST
30695: PUSH
30696: LD_INT 1
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: LD_INT 0
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 2
30719: PUSH
30720: LD_INT 1
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 2
30729: PUSH
30730: LD_INT 2
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 1
30739: PUSH
30740: LD_INT 2
30742: PUSH
30743: EMPTY
30744: LIST
30745: LIST
30746: PUSH
30747: LD_INT 0
30749: PUSH
30750: LD_INT 2
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: LD_INT 1
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 2
30770: NEG
30771: PUSH
30772: LD_INT 0
30774: PUSH
30775: EMPTY
30776: LIST
30777: LIST
30778: PUSH
30779: LD_INT 2
30781: NEG
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: NEG
30794: PUSH
30795: LD_INT 2
30797: NEG
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: EMPTY
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: LIST
30809: LIST
30810: LIST
30811: LIST
30812: LIST
30813: LIST
30814: LIST
30815: LIST
30816: LIST
30817: LIST
30818: LIST
30819: LIST
30820: LIST
30821: LIST
30822: LIST
30823: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30824: LD_ADDR_VAR 0 18
30828: PUSH
30829: LD_INT 0
30831: PUSH
30832: LD_INT 0
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 0
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: LD_INT 0
30855: PUSH
30856: EMPTY
30857: LIST
30858: LIST
30859: PUSH
30860: LD_INT 1
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 0
30872: PUSH
30873: LD_INT 1
30875: PUSH
30876: EMPTY
30877: LIST
30878: LIST
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: LD_INT 0
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 1
30893: NEG
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: EMPTY
30900: LIST
30901: LIST
30902: PUSH
30903: LD_INT 1
30905: NEG
30906: PUSH
30907: LD_INT 2
30909: NEG
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: PUSH
30915: LD_INT 0
30917: PUSH
30918: LD_INT 2
30920: NEG
30921: PUSH
30922: EMPTY
30923: LIST
30924: LIST
30925: PUSH
30926: LD_INT 1
30928: PUSH
30929: LD_INT 1
30931: NEG
30932: PUSH
30933: EMPTY
30934: LIST
30935: LIST
30936: PUSH
30937: LD_INT 2
30939: PUSH
30940: LD_INT 0
30942: PUSH
30943: EMPTY
30944: LIST
30945: LIST
30946: PUSH
30947: LD_INT 2
30949: PUSH
30950: LD_INT 1
30952: PUSH
30953: EMPTY
30954: LIST
30955: LIST
30956: PUSH
30957: LD_INT 2
30959: PUSH
30960: LD_INT 2
30962: PUSH
30963: EMPTY
30964: LIST
30965: LIST
30966: PUSH
30967: LD_INT 1
30969: PUSH
30970: LD_INT 2
30972: PUSH
30973: EMPTY
30974: LIST
30975: LIST
30976: PUSH
30977: LD_INT 0
30979: PUSH
30980: LD_INT 2
30982: PUSH
30983: EMPTY
30984: LIST
30985: LIST
30986: PUSH
30987: LD_INT 1
30989: NEG
30990: PUSH
30991: LD_INT 1
30993: PUSH
30994: EMPTY
30995: LIST
30996: LIST
30997: PUSH
30998: LD_INT 2
31000: NEG
31001: PUSH
31002: LD_INT 0
31004: PUSH
31005: EMPTY
31006: LIST
31007: LIST
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: LD_INT 1
31015: NEG
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 2
31023: NEG
31024: PUSH
31025: LD_INT 2
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: EMPTY
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31054: LD_ADDR_VAR 0 19
31058: PUSH
31059: LD_INT 0
31061: PUSH
31062: LD_INT 0
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 0
31071: PUSH
31072: LD_INT 1
31074: NEG
31075: PUSH
31076: EMPTY
31077: LIST
31078: LIST
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: LD_INT 0
31085: PUSH
31086: EMPTY
31087: LIST
31088: LIST
31089: PUSH
31090: LD_INT 1
31092: PUSH
31093: LD_INT 1
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 0
31102: PUSH
31103: LD_INT 1
31105: PUSH
31106: EMPTY
31107: LIST
31108: LIST
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: LD_INT 0
31116: PUSH
31117: EMPTY
31118: LIST
31119: LIST
31120: PUSH
31121: LD_INT 1
31123: NEG
31124: PUSH
31125: LD_INT 1
31127: NEG
31128: PUSH
31129: EMPTY
31130: LIST
31131: LIST
31132: PUSH
31133: LD_INT 1
31135: NEG
31136: PUSH
31137: LD_INT 2
31139: NEG
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 0
31147: PUSH
31148: LD_INT 2
31150: NEG
31151: PUSH
31152: EMPTY
31153: LIST
31154: LIST
31155: PUSH
31156: LD_INT 1
31158: PUSH
31159: LD_INT 1
31161: NEG
31162: PUSH
31163: EMPTY
31164: LIST
31165: LIST
31166: PUSH
31167: LD_INT 2
31169: PUSH
31170: LD_INT 0
31172: PUSH
31173: EMPTY
31174: LIST
31175: LIST
31176: PUSH
31177: LD_INT 2
31179: PUSH
31180: LD_INT 1
31182: PUSH
31183: EMPTY
31184: LIST
31185: LIST
31186: PUSH
31187: LD_INT 2
31189: PUSH
31190: LD_INT 2
31192: PUSH
31193: EMPTY
31194: LIST
31195: LIST
31196: PUSH
31197: LD_INT 1
31199: PUSH
31200: LD_INT 2
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: PUSH
31207: LD_INT 0
31209: PUSH
31210: LD_INT 2
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: LD_INT 1
31219: NEG
31220: PUSH
31221: LD_INT 1
31223: PUSH
31224: EMPTY
31225: LIST
31226: LIST
31227: PUSH
31228: LD_INT 2
31230: NEG
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 2
31241: NEG
31242: PUSH
31243: LD_INT 1
31245: NEG
31246: PUSH
31247: EMPTY
31248: LIST
31249: LIST
31250: PUSH
31251: LD_INT 2
31253: NEG
31254: PUSH
31255: LD_INT 2
31257: NEG
31258: PUSH
31259: EMPTY
31260: LIST
31261: LIST
31262: PUSH
31263: EMPTY
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: LIST
31269: LIST
31270: LIST
31271: LIST
31272: LIST
31273: LIST
31274: LIST
31275: LIST
31276: LIST
31277: LIST
31278: LIST
31279: LIST
31280: LIST
31281: LIST
31282: LIST
31283: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31284: LD_ADDR_VAR 0 20
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: LD_INT 0
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 0
31301: PUSH
31302: LD_INT 1
31304: NEG
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: PUSH
31310: LD_INT 1
31312: PUSH
31313: LD_INT 0
31315: PUSH
31316: EMPTY
31317: LIST
31318: LIST
31319: PUSH
31320: LD_INT 1
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 0
31332: PUSH
31333: LD_INT 1
31335: PUSH
31336: EMPTY
31337: LIST
31338: LIST
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 1
31353: NEG
31354: PUSH
31355: LD_INT 1
31357: NEG
31358: PUSH
31359: EMPTY
31360: LIST
31361: LIST
31362: PUSH
31363: LD_INT 1
31365: NEG
31366: PUSH
31367: LD_INT 2
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 0
31377: PUSH
31378: LD_INT 2
31380: NEG
31381: PUSH
31382: EMPTY
31383: LIST
31384: LIST
31385: PUSH
31386: LD_INT 1
31388: PUSH
31389: LD_INT 1
31391: NEG
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 2
31399: PUSH
31400: LD_INT 0
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 2
31409: PUSH
31410: LD_INT 1
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: LD_INT 2
31419: PUSH
31420: LD_INT 2
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PUSH
31427: LD_INT 1
31429: PUSH
31430: LD_INT 2
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 0
31439: PUSH
31440: LD_INT 2
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: NEG
31450: PUSH
31451: LD_INT 1
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: PUSH
31458: LD_INT 2
31460: NEG
31461: PUSH
31462: LD_INT 0
31464: PUSH
31465: EMPTY
31466: LIST
31467: LIST
31468: PUSH
31469: LD_INT 2
31471: NEG
31472: PUSH
31473: LD_INT 1
31475: NEG
31476: PUSH
31477: EMPTY
31478: LIST
31479: LIST
31480: PUSH
31481: LD_INT 2
31483: NEG
31484: PUSH
31485: LD_INT 2
31487: NEG
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: EMPTY
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: LIST
31504: LIST
31505: LIST
31506: LIST
31507: LIST
31508: LIST
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31514: LD_ADDR_VAR 0 21
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 0
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 0
31531: PUSH
31532: LD_INT 1
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: LD_INT 0
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 1
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 0
31562: PUSH
31563: LD_INT 1
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: LD_INT 0
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: NEG
31584: PUSH
31585: LD_INT 1
31587: NEG
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: PUSH
31593: LD_INT 1
31595: NEG
31596: PUSH
31597: LD_INT 2
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 0
31607: PUSH
31608: LD_INT 2
31610: NEG
31611: PUSH
31612: EMPTY
31613: LIST
31614: LIST
31615: PUSH
31616: LD_INT 1
31618: PUSH
31619: LD_INT 1
31621: NEG
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 0
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 1
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 2
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 1
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 0
31669: PUSH
31670: LD_INT 2
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 1
31679: NEG
31680: PUSH
31681: LD_INT 1
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: LD_INT 0
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: NEG
31706: PUSH
31707: EMPTY
31708: LIST
31709: LIST
31710: PUSH
31711: LD_INT 2
31713: NEG
31714: PUSH
31715: LD_INT 2
31717: NEG
31718: PUSH
31719: EMPTY
31720: LIST
31721: LIST
31722: PUSH
31723: EMPTY
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: LIST
31729: LIST
31730: LIST
31731: LIST
31732: LIST
31733: LIST
31734: LIST
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31744: LD_ADDR_VAR 0 22
31748: PUSH
31749: LD_INT 0
31751: PUSH
31752: LD_INT 0
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 0
31761: PUSH
31762: LD_INT 1
31764: NEG
31765: PUSH
31766: EMPTY
31767: LIST
31768: LIST
31769: PUSH
31770: LD_INT 1
31772: PUSH
31773: LD_INT 0
31775: PUSH
31776: EMPTY
31777: LIST
31778: LIST
31779: PUSH
31780: LD_INT 1
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 0
31792: PUSH
31793: LD_INT 1
31795: PUSH
31796: EMPTY
31797: LIST
31798: LIST
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: LD_INT 0
31806: PUSH
31807: EMPTY
31808: LIST
31809: LIST
31810: PUSH
31811: LD_INT 1
31813: NEG
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: PUSH
31823: LD_INT 1
31825: NEG
31826: PUSH
31827: LD_INT 2
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 0
31837: PUSH
31838: LD_INT 2
31840: NEG
31841: PUSH
31842: EMPTY
31843: LIST
31844: LIST
31845: PUSH
31846: LD_INT 1
31848: PUSH
31849: LD_INT 1
31851: NEG
31852: PUSH
31853: EMPTY
31854: LIST
31855: LIST
31856: PUSH
31857: LD_INT 2
31859: PUSH
31860: LD_INT 0
31862: PUSH
31863: EMPTY
31864: LIST
31865: LIST
31866: PUSH
31867: LD_INT 2
31869: PUSH
31870: LD_INT 1
31872: PUSH
31873: EMPTY
31874: LIST
31875: LIST
31876: PUSH
31877: LD_INT 2
31879: PUSH
31880: LD_INT 2
31882: PUSH
31883: EMPTY
31884: LIST
31885: LIST
31886: PUSH
31887: LD_INT 1
31889: PUSH
31890: LD_INT 2
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 0
31899: PUSH
31900: LD_INT 2
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: NEG
31910: PUSH
31911: LD_INT 1
31913: PUSH
31914: EMPTY
31915: LIST
31916: LIST
31917: PUSH
31918: LD_INT 2
31920: NEG
31921: PUSH
31922: LD_INT 0
31924: PUSH
31925: EMPTY
31926: LIST
31927: LIST
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: LD_INT 1
31935: NEG
31936: PUSH
31937: EMPTY
31938: LIST
31939: LIST
31940: PUSH
31941: LD_INT 2
31943: NEG
31944: PUSH
31945: LD_INT 2
31947: NEG
31948: PUSH
31949: EMPTY
31950: LIST
31951: LIST
31952: PUSH
31953: EMPTY
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: LIST
31959: LIST
31960: LIST
31961: LIST
31962: LIST
31963: LIST
31964: LIST
31965: LIST
31966: LIST
31967: LIST
31968: LIST
31969: LIST
31970: LIST
31971: LIST
31972: LIST
31973: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31974: LD_ADDR_VAR 0 23
31978: PUSH
31979: LD_INT 0
31981: PUSH
31982: LD_INT 0
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 0
31991: PUSH
31992: LD_INT 1
31994: NEG
31995: PUSH
31996: EMPTY
31997: LIST
31998: LIST
31999: PUSH
32000: LD_INT 1
32002: PUSH
32003: LD_INT 0
32005: PUSH
32006: EMPTY
32007: LIST
32008: LIST
32009: PUSH
32010: LD_INT 1
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 0
32022: PUSH
32023: LD_INT 1
32025: PUSH
32026: EMPTY
32027: LIST
32028: LIST
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: LD_INT 1
32043: NEG
32044: PUSH
32045: LD_INT 1
32047: NEG
32048: PUSH
32049: EMPTY
32050: LIST
32051: LIST
32052: PUSH
32053: LD_INT 1
32055: NEG
32056: PUSH
32057: LD_INT 2
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 0
32067: PUSH
32068: LD_INT 2
32070: NEG
32071: PUSH
32072: EMPTY
32073: LIST
32074: LIST
32075: PUSH
32076: LD_INT 1
32078: PUSH
32079: LD_INT 1
32081: NEG
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 2
32089: PUSH
32090: LD_INT 0
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 2
32099: PUSH
32100: LD_INT 1
32102: PUSH
32103: EMPTY
32104: LIST
32105: LIST
32106: PUSH
32107: LD_INT 2
32109: PUSH
32110: LD_INT 2
32112: PUSH
32113: EMPTY
32114: LIST
32115: LIST
32116: PUSH
32117: LD_INT 1
32119: PUSH
32120: LD_INT 2
32122: PUSH
32123: EMPTY
32124: LIST
32125: LIST
32126: PUSH
32127: LD_INT 0
32129: PUSH
32130: LD_INT 2
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: LD_INT 1
32143: PUSH
32144: EMPTY
32145: LIST
32146: LIST
32147: PUSH
32148: LD_INT 2
32150: NEG
32151: PUSH
32152: LD_INT 0
32154: PUSH
32155: EMPTY
32156: LIST
32157: LIST
32158: PUSH
32159: LD_INT 2
32161: NEG
32162: PUSH
32163: LD_INT 1
32165: NEG
32166: PUSH
32167: EMPTY
32168: LIST
32169: LIST
32170: PUSH
32171: LD_INT 2
32173: NEG
32174: PUSH
32175: LD_INT 2
32177: NEG
32178: PUSH
32179: EMPTY
32180: LIST
32181: LIST
32182: PUSH
32183: LD_INT 2
32185: NEG
32186: PUSH
32187: LD_INT 3
32189: NEG
32190: PUSH
32191: EMPTY
32192: LIST
32193: LIST
32194: PUSH
32195: LD_INT 1
32197: NEG
32198: PUSH
32199: LD_INT 3
32201: NEG
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 1
32209: PUSH
32210: LD_INT 2
32212: NEG
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 2
32220: PUSH
32221: LD_INT 1
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: EMPTY
32230: LIST
32231: LIST
32232: LIST
32233: LIST
32234: LIST
32235: LIST
32236: LIST
32237: LIST
32238: LIST
32239: LIST
32240: LIST
32241: LIST
32242: LIST
32243: LIST
32244: LIST
32245: LIST
32246: LIST
32247: LIST
32248: LIST
32249: LIST
32250: LIST
32251: LIST
32252: LIST
32253: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32254: LD_ADDR_VAR 0 24
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: LD_INT 0
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 0
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: LD_INT 0
32285: PUSH
32286: EMPTY
32287: LIST
32288: LIST
32289: PUSH
32290: LD_INT 1
32292: PUSH
32293: LD_INT 1
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 0
32302: PUSH
32303: LD_INT 1
32305: PUSH
32306: EMPTY
32307: LIST
32308: LIST
32309: PUSH
32310: LD_INT 1
32312: NEG
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: EMPTY
32318: LIST
32319: LIST
32320: PUSH
32321: LD_INT 1
32323: NEG
32324: PUSH
32325: LD_INT 1
32327: NEG
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 1
32335: NEG
32336: PUSH
32337: LD_INT 2
32339: NEG
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 0
32347: PUSH
32348: LD_INT 2
32350: NEG
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 1
32361: NEG
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 2
32369: PUSH
32370: LD_INT 0
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: LD_INT 2
32379: PUSH
32380: LD_INT 1
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 2
32389: PUSH
32390: LD_INT 2
32392: PUSH
32393: EMPTY
32394: LIST
32395: LIST
32396: PUSH
32397: LD_INT 1
32399: PUSH
32400: LD_INT 2
32402: PUSH
32403: EMPTY
32404: LIST
32405: LIST
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 2
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 1
32419: NEG
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: LD_INT 0
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PUSH
32439: LD_INT 2
32441: NEG
32442: PUSH
32443: LD_INT 1
32445: NEG
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 2
32453: NEG
32454: PUSH
32455: LD_INT 2
32457: NEG
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: PUSH
32466: LD_INT 2
32468: NEG
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 2
32476: PUSH
32477: LD_INT 1
32479: NEG
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PUSH
32485: LD_INT 3
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 3
32497: PUSH
32498: LD_INT 2
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: LIST
32509: LIST
32510: LIST
32511: LIST
32512: LIST
32513: LIST
32514: LIST
32515: LIST
32516: LIST
32517: LIST
32518: LIST
32519: LIST
32520: LIST
32521: LIST
32522: LIST
32523: LIST
32524: LIST
32525: LIST
32526: LIST
32527: LIST
32528: LIST
32529: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32530: LD_ADDR_VAR 0 25
32534: PUSH
32535: LD_INT 0
32537: PUSH
32538: LD_INT 0
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 0
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 1
32558: PUSH
32559: LD_INT 0
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 1
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 0
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 1
32588: NEG
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 1
32599: NEG
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 1
32611: NEG
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 0
32623: PUSH
32624: LD_INT 2
32626: NEG
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 1
32634: PUSH
32635: LD_INT 1
32637: NEG
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: LD_INT 0
32648: PUSH
32649: EMPTY
32650: LIST
32651: LIST
32652: PUSH
32653: LD_INT 2
32655: PUSH
32656: LD_INT 1
32658: PUSH
32659: EMPTY
32660: LIST
32661: LIST
32662: PUSH
32663: LD_INT 2
32665: PUSH
32666: LD_INT 2
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 1
32675: PUSH
32676: LD_INT 2
32678: PUSH
32679: EMPTY
32680: LIST
32681: LIST
32682: PUSH
32683: LD_INT 0
32685: PUSH
32686: LD_INT 2
32688: PUSH
32689: EMPTY
32690: LIST
32691: LIST
32692: PUSH
32693: LD_INT 1
32695: NEG
32696: PUSH
32697: LD_INT 1
32699: PUSH
32700: EMPTY
32701: LIST
32702: LIST
32703: PUSH
32704: LD_INT 2
32706: NEG
32707: PUSH
32708: LD_INT 0
32710: PUSH
32711: EMPTY
32712: LIST
32713: LIST
32714: PUSH
32715: LD_INT 2
32717: NEG
32718: PUSH
32719: LD_INT 1
32721: NEG
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 2
32729: NEG
32730: PUSH
32731: LD_INT 2
32733: NEG
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PUSH
32739: LD_INT 3
32741: PUSH
32742: LD_INT 1
32744: PUSH
32745: EMPTY
32746: LIST
32747: LIST
32748: PUSH
32749: LD_INT 3
32751: PUSH
32752: LD_INT 2
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 2
32761: PUSH
32762: LD_INT 3
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: LD_INT 1
32771: PUSH
32772: LD_INT 3
32774: PUSH
32775: EMPTY
32776: LIST
32777: LIST
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: LIST
32790: LIST
32791: LIST
32792: LIST
32793: LIST
32794: LIST
32795: LIST
32796: LIST
32797: LIST
32798: LIST
32799: LIST
32800: LIST
32801: LIST
32802: LIST
32803: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32804: LD_ADDR_VAR 0 26
32808: PUSH
32809: LD_INT 0
32811: PUSH
32812: LD_INT 0
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: LD_INT 1
32824: NEG
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 1
32832: PUSH
32833: LD_INT 0
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 1
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 0
32852: PUSH
32853: LD_INT 1
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: LD_INT 1
32862: NEG
32863: PUSH
32864: LD_INT 0
32866: PUSH
32867: EMPTY
32868: LIST
32869: LIST
32870: PUSH
32871: LD_INT 1
32873: NEG
32874: PUSH
32875: LD_INT 1
32877: NEG
32878: PUSH
32879: EMPTY
32880: LIST
32881: LIST
32882: PUSH
32883: LD_INT 1
32885: NEG
32886: PUSH
32887: LD_INT 2
32889: NEG
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 0
32897: PUSH
32898: LD_INT 2
32900: NEG
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 1
32908: PUSH
32909: LD_INT 1
32911: NEG
32912: PUSH
32913: EMPTY
32914: LIST
32915: LIST
32916: PUSH
32917: LD_INT 2
32919: PUSH
32920: LD_INT 0
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 2
32929: PUSH
32930: LD_INT 1
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 2
32939: PUSH
32940: LD_INT 2
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 1
32949: PUSH
32950: LD_INT 2
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: LD_INT 2
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: LD_INT 1
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 2
32980: NEG
32981: PUSH
32982: LD_INT 0
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: NEG
32992: PUSH
32993: LD_INT 1
32995: NEG
32996: PUSH
32997: EMPTY
32998: LIST
32999: LIST
33000: PUSH
33001: LD_INT 2
33003: NEG
33004: PUSH
33005: LD_INT 2
33007: NEG
33008: PUSH
33009: EMPTY
33010: LIST
33011: LIST
33012: PUSH
33013: LD_INT 2
33015: PUSH
33016: LD_INT 3
33018: PUSH
33019: EMPTY
33020: LIST
33021: LIST
33022: PUSH
33023: LD_INT 1
33025: PUSH
33026: LD_INT 3
33028: PUSH
33029: EMPTY
33030: LIST
33031: LIST
33032: PUSH
33033: LD_INT 1
33035: NEG
33036: PUSH
33037: LD_INT 2
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 2
33046: NEG
33047: PUSH
33048: LD_INT 1
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: LIST
33059: LIST
33060: LIST
33061: LIST
33062: LIST
33063: LIST
33064: LIST
33065: LIST
33066: LIST
33067: LIST
33068: LIST
33069: LIST
33070: LIST
33071: LIST
33072: LIST
33073: LIST
33074: LIST
33075: LIST
33076: LIST
33077: LIST
33078: LIST
33079: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33080: LD_ADDR_VAR 0 27
33084: PUSH
33085: LD_INT 0
33087: PUSH
33088: LD_INT 0
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 0
33097: PUSH
33098: LD_INT 1
33100: NEG
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 1
33108: PUSH
33109: LD_INT 0
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 1
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 0
33128: PUSH
33129: LD_INT 1
33131: PUSH
33132: EMPTY
33133: LIST
33134: LIST
33135: PUSH
33136: LD_INT 1
33138: NEG
33139: PUSH
33140: LD_INT 0
33142: PUSH
33143: EMPTY
33144: LIST
33145: LIST
33146: PUSH
33147: LD_INT 1
33149: NEG
33150: PUSH
33151: LD_INT 1
33153: NEG
33154: PUSH
33155: EMPTY
33156: LIST
33157: LIST
33158: PUSH
33159: LD_INT 1
33161: NEG
33162: PUSH
33163: LD_INT 2
33165: NEG
33166: PUSH
33167: EMPTY
33168: LIST
33169: LIST
33170: PUSH
33171: LD_INT 0
33173: PUSH
33174: LD_INT 2
33176: NEG
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: PUSH
33185: LD_INT 1
33187: NEG
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 2
33195: PUSH
33196: LD_INT 0
33198: PUSH
33199: EMPTY
33200: LIST
33201: LIST
33202: PUSH
33203: LD_INT 2
33205: PUSH
33206: LD_INT 1
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PUSH
33213: LD_INT 2
33215: PUSH
33216: LD_INT 2
33218: PUSH
33219: EMPTY
33220: LIST
33221: LIST
33222: PUSH
33223: LD_INT 1
33225: PUSH
33226: LD_INT 2
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 0
33235: PUSH
33236: LD_INT 2
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: LD_INT 1
33249: PUSH
33250: EMPTY
33251: LIST
33252: LIST
33253: PUSH
33254: LD_INT 2
33256: NEG
33257: PUSH
33258: LD_INT 0
33260: PUSH
33261: EMPTY
33262: LIST
33263: LIST
33264: PUSH
33265: LD_INT 2
33267: NEG
33268: PUSH
33269: LD_INT 1
33271: NEG
33272: PUSH
33273: EMPTY
33274: LIST
33275: LIST
33276: PUSH
33277: LD_INT 2
33279: NEG
33280: PUSH
33281: LD_INT 2
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 1
33291: NEG
33292: PUSH
33293: LD_INT 2
33295: PUSH
33296: EMPTY
33297: LIST
33298: LIST
33299: PUSH
33300: LD_INT 2
33302: NEG
33303: PUSH
33304: LD_INT 1
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 3
33313: NEG
33314: PUSH
33315: LD_INT 1
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 3
33325: NEG
33326: PUSH
33327: LD_INT 2
33329: NEG
33330: PUSH
33331: EMPTY
33332: LIST
33333: LIST
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: LIST
33339: LIST
33340: LIST
33341: LIST
33342: LIST
33343: LIST
33344: LIST
33345: LIST
33346: LIST
33347: LIST
33348: LIST
33349: LIST
33350: LIST
33351: LIST
33352: LIST
33353: LIST
33354: LIST
33355: LIST
33356: LIST
33357: LIST
33358: LIST
33359: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33360: LD_ADDR_VAR 0 28
33364: PUSH
33365: LD_INT 0
33367: PUSH
33368: LD_INT 0
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 0
33377: PUSH
33378: LD_INT 1
33380: NEG
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 1
33388: PUSH
33389: LD_INT 0
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 1
33398: PUSH
33399: LD_INT 1
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 0
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 1
33418: NEG
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 1
33429: NEG
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 1
33441: NEG
33442: PUSH
33443: LD_INT 2
33445: NEG
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 0
33453: PUSH
33454: LD_INT 2
33456: NEG
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 1
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 2
33475: PUSH
33476: LD_INT 0
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 2
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: LD_INT 2
33495: PUSH
33496: LD_INT 2
33498: PUSH
33499: EMPTY
33500: LIST
33501: LIST
33502: PUSH
33503: LD_INT 1
33505: PUSH
33506: LD_INT 2
33508: PUSH
33509: EMPTY
33510: LIST
33511: LIST
33512: PUSH
33513: LD_INT 0
33515: PUSH
33516: LD_INT 2
33518: PUSH
33519: EMPTY
33520: LIST
33521: LIST
33522: PUSH
33523: LD_INT 1
33525: NEG
33526: PUSH
33527: LD_INT 1
33529: PUSH
33530: EMPTY
33531: LIST
33532: LIST
33533: PUSH
33534: LD_INT 2
33536: NEG
33537: PUSH
33538: LD_INT 0
33540: PUSH
33541: EMPTY
33542: LIST
33543: LIST
33544: PUSH
33545: LD_INT 2
33547: NEG
33548: PUSH
33549: LD_INT 1
33551: NEG
33552: PUSH
33553: EMPTY
33554: LIST
33555: LIST
33556: PUSH
33557: LD_INT 2
33559: NEG
33560: PUSH
33561: LD_INT 2
33563: NEG
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 2
33571: NEG
33572: PUSH
33573: LD_INT 3
33575: NEG
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: LD_INT 3
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 3
33595: NEG
33596: PUSH
33597: LD_INT 1
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 3
33607: NEG
33608: PUSH
33609: LD_INT 2
33611: NEG
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: LIST
33636: LIST
33637: LIST
33638: LIST
33639: LIST
33640: LIST
33641: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33642: LD_ADDR_VAR 0 29
33646: PUSH
33647: LD_INT 0
33649: PUSH
33650: LD_INT 0
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 1
33662: NEG
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 1
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: LD_INT 1
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 0
33690: PUSH
33691: LD_INT 1
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: LD_INT 0
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 1
33711: NEG
33712: PUSH
33713: LD_INT 1
33715: NEG
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 1
33723: NEG
33724: PUSH
33725: LD_INT 2
33727: NEG
33728: PUSH
33729: EMPTY
33730: LIST
33731: LIST
33732: PUSH
33733: LD_INT 0
33735: PUSH
33736: LD_INT 2
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: LD_INT 1
33749: NEG
33750: PUSH
33751: EMPTY
33752: LIST
33753: LIST
33754: PUSH
33755: LD_INT 2
33757: PUSH
33758: LD_INT 0
33760: PUSH
33761: EMPTY
33762: LIST
33763: LIST
33764: PUSH
33765: LD_INT 2
33767: PUSH
33768: LD_INT 1
33770: PUSH
33771: EMPTY
33772: LIST
33773: LIST
33774: PUSH
33775: LD_INT 1
33777: PUSH
33778: LD_INT 2
33780: PUSH
33781: EMPTY
33782: LIST
33783: LIST
33784: PUSH
33785: LD_INT 0
33787: PUSH
33788: LD_INT 2
33790: PUSH
33791: EMPTY
33792: LIST
33793: LIST
33794: PUSH
33795: LD_INT 1
33797: NEG
33798: PUSH
33799: LD_INT 1
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 2
33808: NEG
33809: PUSH
33810: LD_INT 1
33812: NEG
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: NEG
33821: PUSH
33822: LD_INT 2
33824: NEG
33825: PUSH
33826: EMPTY
33827: LIST
33828: LIST
33829: PUSH
33830: LD_INT 2
33832: NEG
33833: PUSH
33834: LD_INT 3
33836: NEG
33837: PUSH
33838: EMPTY
33839: LIST
33840: LIST
33841: PUSH
33842: LD_INT 2
33844: PUSH
33845: LD_INT 1
33847: NEG
33848: PUSH
33849: EMPTY
33850: LIST
33851: LIST
33852: PUSH
33853: LD_INT 3
33855: PUSH
33856: LD_INT 1
33858: PUSH
33859: EMPTY
33860: LIST
33861: LIST
33862: PUSH
33863: LD_INT 1
33865: PUSH
33866: LD_INT 3
33868: PUSH
33869: EMPTY
33870: LIST
33871: LIST
33872: PUSH
33873: LD_INT 1
33875: NEG
33876: PUSH
33877: LD_INT 2
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 3
33886: NEG
33887: PUSH
33888: LD_INT 2
33890: NEG
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: LIST
33900: LIST
33901: LIST
33902: LIST
33903: LIST
33904: LIST
33905: LIST
33906: LIST
33907: LIST
33908: LIST
33909: LIST
33910: LIST
33911: LIST
33912: LIST
33913: LIST
33914: LIST
33915: LIST
33916: LIST
33917: LIST
33918: LIST
33919: LIST
33920: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33921: LD_ADDR_VAR 0 30
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 0
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 0
33938: PUSH
33939: LD_INT 1
33941: NEG
33942: PUSH
33943: EMPTY
33944: LIST
33945: LIST
33946: PUSH
33947: LD_INT 1
33949: PUSH
33950: LD_INT 0
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 1
33959: PUSH
33960: LD_INT 1
33962: PUSH
33963: EMPTY
33964: LIST
33965: LIST
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: LD_INT 1
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 1
33979: NEG
33980: PUSH
33981: LD_INT 0
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: NEG
33991: PUSH
33992: LD_INT 1
33994: NEG
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 1
34002: NEG
34003: PUSH
34004: LD_INT 2
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 2
34017: NEG
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 1
34028: NEG
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 2
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 2
34046: PUSH
34047: LD_INT 1
34049: PUSH
34050: EMPTY
34051: LIST
34052: LIST
34053: PUSH
34054: LD_INT 2
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: PUSH
34067: LD_INT 2
34069: PUSH
34070: EMPTY
34071: LIST
34072: LIST
34073: PUSH
34074: LD_INT 1
34076: NEG
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 2
34087: NEG
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: LD_INT 2
34098: NEG
34099: PUSH
34100: LD_INT 1
34102: NEG
34103: PUSH
34104: EMPTY
34105: LIST
34106: LIST
34107: PUSH
34108: LD_INT 1
34110: NEG
34111: PUSH
34112: LD_INT 3
34114: NEG
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: LD_INT 2
34125: NEG
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: PUSH
34131: LD_INT 3
34133: PUSH
34134: LD_INT 2
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 2
34143: PUSH
34144: LD_INT 3
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 2
34153: NEG
34154: PUSH
34155: LD_INT 1
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 3
34164: NEG
34165: PUSH
34166: LD_INT 1
34168: NEG
34169: PUSH
34170: EMPTY
34171: LIST
34172: LIST
34173: PUSH
34174: EMPTY
34175: LIST
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: LIST
34186: LIST
34187: LIST
34188: LIST
34189: LIST
34190: LIST
34191: LIST
34192: LIST
34193: LIST
34194: LIST
34195: LIST
34196: LIST
34197: LIST
34198: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34199: LD_ADDR_VAR 0 31
34203: PUSH
34204: LD_INT 0
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: EMPTY
34211: LIST
34212: LIST
34213: PUSH
34214: LD_INT 0
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: EMPTY
34222: LIST
34223: LIST
34224: PUSH
34225: LD_INT 1
34227: PUSH
34228: LD_INT 0
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: LD_INT 1
34240: PUSH
34241: EMPTY
34242: LIST
34243: LIST
34244: PUSH
34245: LD_INT 0
34247: PUSH
34248: LD_INT 1
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: PUSH
34255: LD_INT 1
34257: NEG
34258: PUSH
34259: LD_INT 0
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: PUSH
34266: LD_INT 1
34268: NEG
34269: PUSH
34270: LD_INT 1
34272: NEG
34273: PUSH
34274: EMPTY
34275: LIST
34276: LIST
34277: PUSH
34278: LD_INT 1
34280: NEG
34281: PUSH
34282: LD_INT 2
34284: NEG
34285: PUSH
34286: EMPTY
34287: LIST
34288: LIST
34289: PUSH
34290: LD_INT 1
34292: PUSH
34293: LD_INT 1
34295: NEG
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 2
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 2
34313: PUSH
34314: LD_INT 1
34316: PUSH
34317: EMPTY
34318: LIST
34319: LIST
34320: PUSH
34321: LD_INT 2
34323: PUSH
34324: LD_INT 2
34326: PUSH
34327: EMPTY
34328: LIST
34329: LIST
34330: PUSH
34331: LD_INT 1
34333: PUSH
34334: LD_INT 2
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 0
34343: PUSH
34344: LD_INT 2
34346: PUSH
34347: EMPTY
34348: LIST
34349: LIST
34350: PUSH
34351: LD_INT 1
34353: NEG
34354: PUSH
34355: LD_INT 1
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 2
34364: NEG
34365: PUSH
34366: LD_INT 1
34368: NEG
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 2
34376: NEG
34377: PUSH
34378: LD_INT 2
34380: NEG
34381: PUSH
34382: EMPTY
34383: LIST
34384: LIST
34385: PUSH
34386: LD_INT 2
34388: NEG
34389: PUSH
34390: LD_INT 3
34392: NEG
34393: PUSH
34394: EMPTY
34395: LIST
34396: LIST
34397: PUSH
34398: LD_INT 2
34400: PUSH
34401: LD_INT 1
34403: NEG
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 3
34411: PUSH
34412: LD_INT 1
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 3
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 2
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 3
34442: NEG
34443: PUSH
34444: LD_INT 2
34446: NEG
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: LIST
34456: LIST
34457: LIST
34458: LIST
34459: LIST
34460: LIST
34461: LIST
34462: LIST
34463: LIST
34464: LIST
34465: LIST
34466: LIST
34467: LIST
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: LIST
34474: LIST
34475: LIST
34476: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34477: LD_ADDR_VAR 0 32
34481: PUSH
34482: LD_INT 0
34484: PUSH
34485: LD_INT 0
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 1
34497: NEG
34498: PUSH
34499: EMPTY
34500: LIST
34501: LIST
34502: PUSH
34503: LD_INT 1
34505: PUSH
34506: LD_INT 0
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 1
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 0
34525: PUSH
34526: LD_INT 1
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 1
34535: NEG
34536: PUSH
34537: LD_INT 0
34539: PUSH
34540: EMPTY
34541: LIST
34542: LIST
34543: PUSH
34544: LD_INT 1
34546: NEG
34547: PUSH
34548: LD_INT 1
34550: NEG
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 1
34558: NEG
34559: PUSH
34560: LD_INT 2
34562: NEG
34563: PUSH
34564: EMPTY
34565: LIST
34566: LIST
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 2
34573: NEG
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 1
34581: PUSH
34582: LD_INT 1
34584: NEG
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 2
34592: PUSH
34593: LD_INT 1
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: LD_INT 2
34602: PUSH
34603: LD_INT 2
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 1
34612: PUSH
34613: LD_INT 2
34615: PUSH
34616: EMPTY
34617: LIST
34618: LIST
34619: PUSH
34620: LD_INT 0
34622: PUSH
34623: LD_INT 2
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 2
34643: NEG
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 2
34654: NEG
34655: PUSH
34656: LD_INT 1
34658: NEG
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: LD_INT 1
34666: NEG
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: LD_INT 2
34681: NEG
34682: PUSH
34683: EMPTY
34684: LIST
34685: LIST
34686: PUSH
34687: LD_INT 3
34689: PUSH
34690: LD_INT 2
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 2
34699: PUSH
34700: LD_INT 3
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 2
34709: NEG
34710: PUSH
34711: LD_INT 1
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 3
34720: NEG
34721: PUSH
34722: LD_INT 1
34724: NEG
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: EMPTY
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34755: LD_ADDR_VAR 0 33
34759: PUSH
34760: LD_INT 0
34762: PUSH
34763: LD_INT 0
34765: PUSH
34766: EMPTY
34767: LIST
34768: LIST
34769: PUSH
34770: LD_INT 0
34772: PUSH
34773: LD_INT 1
34775: NEG
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 1
34783: PUSH
34784: LD_INT 0
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: PUSH
34794: LD_INT 1
34796: PUSH
34797: EMPTY
34798: LIST
34799: LIST
34800: PUSH
34801: LD_INT 0
34803: PUSH
34804: LD_INT 1
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: LD_INT 1
34813: NEG
34814: PUSH
34815: LD_INT 0
34817: PUSH
34818: EMPTY
34819: LIST
34820: LIST
34821: PUSH
34822: LD_INT 1
34824: NEG
34825: PUSH
34826: LD_INT 1
34828: NEG
34829: PUSH
34830: EMPTY
34831: LIST
34832: LIST
34833: PUSH
34834: LD_INT 1
34836: NEG
34837: PUSH
34838: LD_INT 2
34840: NEG
34841: PUSH
34842: EMPTY
34843: LIST
34844: LIST
34845: PUSH
34846: LD_INT 1
34848: PUSH
34849: LD_INT 1
34851: NEG
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 2
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 2
34869: PUSH
34870: LD_INT 1
34872: PUSH
34873: EMPTY
34874: LIST
34875: LIST
34876: PUSH
34877: LD_INT 1
34879: PUSH
34880: LD_INT 2
34882: PUSH
34883: EMPTY
34884: LIST
34885: LIST
34886: PUSH
34887: LD_INT 0
34889: PUSH
34890: LD_INT 2
34892: PUSH
34893: EMPTY
34894: LIST
34895: LIST
34896: PUSH
34897: LD_INT 1
34899: NEG
34900: PUSH
34901: LD_INT 1
34903: PUSH
34904: EMPTY
34905: LIST
34906: LIST
34907: PUSH
34908: LD_INT 2
34910: NEG
34911: PUSH
34912: LD_INT 0
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: LD_INT 1
34925: NEG
34926: PUSH
34927: EMPTY
34928: LIST
34929: LIST
34930: PUSH
34931: LD_INT 2
34933: NEG
34934: PUSH
34935: LD_INT 2
34937: NEG
34938: PUSH
34939: EMPTY
34940: LIST
34941: LIST
34942: PUSH
34943: LD_INT 2
34945: NEG
34946: PUSH
34947: LD_INT 3
34949: NEG
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 1
34960: NEG
34961: PUSH
34962: EMPTY
34963: LIST
34964: LIST
34965: PUSH
34966: LD_INT 3
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 1
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: EMPTY
34983: LIST
34984: LIST
34985: PUSH
34986: LD_INT 1
34988: NEG
34989: PUSH
34990: LD_INT 2
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 3
34999: NEG
35000: PUSH
35001: LD_INT 2
35003: NEG
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: EMPTY
35010: LIST
35011: LIST
35012: LIST
35013: LIST
35014: LIST
35015: LIST
35016: LIST
35017: LIST
35018: LIST
35019: LIST
35020: LIST
35021: LIST
35022: LIST
35023: LIST
35024: LIST
35025: LIST
35026: LIST
35027: LIST
35028: LIST
35029: LIST
35030: LIST
35031: LIST
35032: LIST
35033: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35034: LD_ADDR_VAR 0 34
35038: PUSH
35039: LD_INT 0
35041: PUSH
35042: LD_INT 0
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 0
35051: PUSH
35052: LD_INT 1
35054: NEG
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 1
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: LD_INT 1
35075: PUSH
35076: EMPTY
35077: LIST
35078: LIST
35079: PUSH
35080: LD_INT 0
35082: PUSH
35083: LD_INT 1
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 1
35092: NEG
35093: PUSH
35094: LD_INT 0
35096: PUSH
35097: EMPTY
35098: LIST
35099: LIST
35100: PUSH
35101: LD_INT 1
35103: NEG
35104: PUSH
35105: LD_INT 1
35107: NEG
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 1
35115: NEG
35116: PUSH
35117: LD_INT 2
35119: NEG
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: LD_INT 2
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 1
35141: NEG
35142: PUSH
35143: EMPTY
35144: LIST
35145: LIST
35146: PUSH
35147: LD_INT 2
35149: PUSH
35150: LD_INT 1
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 2
35159: PUSH
35160: LD_INT 2
35162: PUSH
35163: EMPTY
35164: LIST
35165: LIST
35166: PUSH
35167: LD_INT 1
35169: PUSH
35170: LD_INT 2
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: EMPTY
35185: LIST
35186: LIST
35187: PUSH
35188: LD_INT 2
35190: NEG
35191: PUSH
35192: LD_INT 0
35194: PUSH
35195: EMPTY
35196: LIST
35197: LIST
35198: PUSH
35199: LD_INT 2
35201: NEG
35202: PUSH
35203: LD_INT 1
35205: NEG
35206: PUSH
35207: EMPTY
35208: LIST
35209: LIST
35210: PUSH
35211: LD_INT 2
35213: NEG
35214: PUSH
35215: LD_INT 2
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 1
35225: NEG
35226: PUSH
35227: LD_INT 3
35229: NEG
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: LD_INT 2
35240: NEG
35241: PUSH
35242: EMPTY
35243: LIST
35244: LIST
35245: PUSH
35246: LD_INT 3
35248: PUSH
35249: LD_INT 2
35251: PUSH
35252: EMPTY
35253: LIST
35254: LIST
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: LD_INT 3
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: EMPTY
35274: LIST
35275: LIST
35276: PUSH
35277: LD_INT 3
35279: NEG
35280: PUSH
35281: LD_INT 1
35283: NEG
35284: PUSH
35285: EMPTY
35286: LIST
35287: LIST
35288: PUSH
35289: EMPTY
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: LIST
35298: LIST
35299: LIST
35300: LIST
35301: LIST
35302: LIST
35303: LIST
35304: LIST
35305: LIST
35306: LIST
35307: LIST
35308: LIST
35309: LIST
35310: LIST
35311: LIST
35312: LIST
35313: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35314: LD_ADDR_VAR 0 35
35318: PUSH
35319: LD_INT 0
35321: PUSH
35322: LD_INT 0
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PUSH
35329: LD_INT 0
35331: PUSH
35332: LD_INT 1
35334: NEG
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 1
35342: PUSH
35343: LD_INT 0
35345: PUSH
35346: EMPTY
35347: LIST
35348: LIST
35349: PUSH
35350: LD_INT 1
35352: PUSH
35353: LD_INT 1
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 0
35362: PUSH
35363: LD_INT 1
35365: PUSH
35366: EMPTY
35367: LIST
35368: LIST
35369: PUSH
35370: LD_INT 1
35372: NEG
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 1
35383: NEG
35384: PUSH
35385: LD_INT 1
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 2
35405: NEG
35406: PUSH
35407: LD_INT 1
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35426: LD_ADDR_VAR 0 36
35430: PUSH
35431: LD_INT 0
35433: PUSH
35434: LD_INT 0
35436: PUSH
35437: EMPTY
35438: LIST
35439: LIST
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: LD_INT 1
35446: NEG
35447: PUSH
35448: EMPTY
35449: LIST
35450: LIST
35451: PUSH
35452: LD_INT 1
35454: PUSH
35455: LD_INT 0
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 1
35464: PUSH
35465: LD_INT 1
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 0
35474: PUSH
35475: LD_INT 1
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 1
35484: NEG
35485: PUSH
35486: LD_INT 0
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: PUSH
35493: LD_INT 1
35495: NEG
35496: PUSH
35497: LD_INT 1
35499: NEG
35500: PUSH
35501: EMPTY
35502: LIST
35503: LIST
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: LD_INT 2
35511: NEG
35512: PUSH
35513: EMPTY
35514: LIST
35515: LIST
35516: PUSH
35517: LD_INT 1
35519: PUSH
35520: LD_INT 2
35522: PUSH
35523: EMPTY
35524: LIST
35525: LIST
35526: PUSH
35527: EMPTY
35528: LIST
35529: LIST
35530: LIST
35531: LIST
35532: LIST
35533: LIST
35534: LIST
35535: LIST
35536: LIST
35537: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35538: LD_ADDR_VAR 0 37
35542: PUSH
35543: LD_INT 0
35545: PUSH
35546: LD_INT 0
35548: PUSH
35549: EMPTY
35550: LIST
35551: LIST
35552: PUSH
35553: LD_INT 0
35555: PUSH
35556: LD_INT 1
35558: NEG
35559: PUSH
35560: EMPTY
35561: LIST
35562: LIST
35563: PUSH
35564: LD_INT 1
35566: PUSH
35567: LD_INT 0
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 1
35576: PUSH
35577: LD_INT 1
35579: PUSH
35580: EMPTY
35581: LIST
35582: LIST
35583: PUSH
35584: LD_INT 0
35586: PUSH
35587: LD_INT 1
35589: PUSH
35590: EMPTY
35591: LIST
35592: LIST
35593: PUSH
35594: LD_INT 1
35596: NEG
35597: PUSH
35598: LD_INT 0
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: NEG
35608: PUSH
35609: LD_INT 1
35611: NEG
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PUSH
35617: LD_INT 1
35619: PUSH
35620: LD_INT 1
35622: NEG
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: PUSH
35628: LD_INT 1
35630: NEG
35631: PUSH
35632: LD_INT 1
35634: PUSH
35635: EMPTY
35636: LIST
35637: LIST
35638: PUSH
35639: EMPTY
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35650: LD_ADDR_VAR 0 38
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: LD_INT 0
35660: PUSH
35661: EMPTY
35662: LIST
35663: LIST
35664: PUSH
35665: LD_INT 0
35667: PUSH
35668: LD_INT 1
35670: NEG
35671: PUSH
35672: EMPTY
35673: LIST
35674: LIST
35675: PUSH
35676: LD_INT 1
35678: PUSH
35679: LD_INT 0
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 1
35688: PUSH
35689: LD_INT 1
35691: PUSH
35692: EMPTY
35693: LIST
35694: LIST
35695: PUSH
35696: LD_INT 0
35698: PUSH
35699: LD_INT 1
35701: PUSH
35702: EMPTY
35703: LIST
35704: LIST
35705: PUSH
35706: LD_INT 1
35708: NEG
35709: PUSH
35710: LD_INT 0
35712: PUSH
35713: EMPTY
35714: LIST
35715: LIST
35716: PUSH
35717: LD_INT 1
35719: NEG
35720: PUSH
35721: LD_INT 1
35723: NEG
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 2
35731: PUSH
35732: LD_INT 1
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 2
35741: NEG
35742: PUSH
35743: LD_INT 1
35745: NEG
35746: PUSH
35747: EMPTY
35748: LIST
35749: LIST
35750: PUSH
35751: EMPTY
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35762: LD_ADDR_VAR 0 39
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: LD_INT 0
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: LD_INT 0
35779: PUSH
35780: LD_INT 1
35782: NEG
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 1
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 0
35810: PUSH
35811: LD_INT 1
35813: PUSH
35814: EMPTY
35815: LIST
35816: LIST
35817: PUSH
35818: LD_INT 1
35820: NEG
35821: PUSH
35822: LD_INT 0
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 1
35831: NEG
35832: PUSH
35833: LD_INT 1
35835: NEG
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 1
35843: NEG
35844: PUSH
35845: LD_INT 2
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: LD_INT 1
35855: PUSH
35856: LD_INT 2
35858: PUSH
35859: EMPTY
35860: LIST
35861: LIST
35862: PUSH
35863: EMPTY
35864: LIST
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: LIST
35873: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35874: LD_ADDR_VAR 0 40
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: LD_INT 0
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 0
35891: PUSH
35892: LD_INT 1
35894: NEG
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: PUSH
35903: LD_INT 0
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 1
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 0
35922: PUSH
35923: LD_INT 1
35925: PUSH
35926: EMPTY
35927: LIST
35928: LIST
35929: PUSH
35930: LD_INT 1
35932: NEG
35933: PUSH
35934: LD_INT 0
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 1
35943: NEG
35944: PUSH
35945: LD_INT 1
35947: NEG
35948: PUSH
35949: EMPTY
35950: LIST
35951: LIST
35952: PUSH
35953: LD_INT 1
35955: PUSH
35956: LD_INT 1
35958: NEG
35959: PUSH
35960: EMPTY
35961: LIST
35962: LIST
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: EMPTY
35972: LIST
35973: LIST
35974: PUSH
35975: EMPTY
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: LIST
35985: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35986: LD_ADDR_VAR 0 41
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: LD_INT 0
35996: PUSH
35997: EMPTY
35998: LIST
35999: LIST
36000: PUSH
36001: LD_INT 0
36003: PUSH
36004: LD_INT 1
36006: NEG
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 1
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 0
36034: PUSH
36035: LD_INT 1
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 1
36044: NEG
36045: PUSH
36046: LD_INT 0
36048: PUSH
36049: EMPTY
36050: LIST
36051: LIST
36052: PUSH
36053: LD_INT 1
36055: NEG
36056: PUSH
36057: LD_INT 1
36059: NEG
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 1
36067: NEG
36068: PUSH
36069: LD_INT 2
36071: NEG
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: LD_INT 1
36079: PUSH
36080: LD_INT 1
36082: NEG
36083: PUSH
36084: EMPTY
36085: LIST
36086: LIST
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: LD_INT 0
36093: PUSH
36094: EMPTY
36095: LIST
36096: LIST
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: LD_INT 1
36103: PUSH
36104: EMPTY
36105: LIST
36106: LIST
36107: PUSH
36108: LD_INT 2
36110: PUSH
36111: LD_INT 2
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 1
36120: PUSH
36121: LD_INT 2
36123: PUSH
36124: EMPTY
36125: LIST
36126: LIST
36127: PUSH
36128: LD_INT 1
36130: NEG
36131: PUSH
36132: LD_INT 1
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: PUSH
36150: LD_INT 2
36152: NEG
36153: PUSH
36154: LD_INT 1
36156: NEG
36157: PUSH
36158: EMPTY
36159: LIST
36160: LIST
36161: PUSH
36162: LD_INT 2
36164: NEG
36165: PUSH
36166: LD_INT 2
36168: NEG
36169: PUSH
36170: EMPTY
36171: LIST
36172: LIST
36173: PUSH
36174: LD_INT 2
36176: NEG
36177: PUSH
36178: LD_INT 3
36180: NEG
36181: PUSH
36182: EMPTY
36183: LIST
36184: LIST
36185: PUSH
36186: LD_INT 2
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: LD_INT 3
36199: PUSH
36200: LD_INT 0
36202: PUSH
36203: EMPTY
36204: LIST
36205: LIST
36206: PUSH
36207: LD_INT 3
36209: PUSH
36210: LD_INT 1
36212: PUSH
36213: EMPTY
36214: LIST
36215: LIST
36216: PUSH
36217: LD_INT 3
36219: PUSH
36220: LD_INT 2
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 3
36229: PUSH
36230: LD_INT 3
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 2
36239: PUSH
36240: LD_INT 3
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 2
36249: NEG
36250: PUSH
36251: LD_INT 1
36253: PUSH
36254: EMPTY
36255: LIST
36256: LIST
36257: PUSH
36258: LD_INT 3
36260: NEG
36261: PUSH
36262: LD_INT 0
36264: PUSH
36265: EMPTY
36266: LIST
36267: LIST
36268: PUSH
36269: LD_INT 3
36271: NEG
36272: PUSH
36273: LD_INT 1
36275: NEG
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 3
36283: NEG
36284: PUSH
36285: LD_INT 2
36287: NEG
36288: PUSH
36289: EMPTY
36290: LIST
36291: LIST
36292: PUSH
36293: LD_INT 3
36295: NEG
36296: PUSH
36297: LD_INT 3
36299: NEG
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: EMPTY
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: LIST
36321: LIST
36322: LIST
36323: LIST
36324: LIST
36325: LIST
36326: LIST
36327: LIST
36328: LIST
36329: LIST
36330: LIST
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36336: LD_ADDR_VAR 0 42
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: LD_INT 0
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 1
36356: NEG
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 1
36364: PUSH
36365: LD_INT 0
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 1
36374: PUSH
36375: LD_INT 1
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: LD_INT 0
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: EMPTY
36389: LIST
36390: LIST
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: LD_INT 0
36398: PUSH
36399: EMPTY
36400: LIST
36401: LIST
36402: PUSH
36403: LD_INT 1
36405: NEG
36406: PUSH
36407: LD_INT 1
36409: NEG
36410: PUSH
36411: EMPTY
36412: LIST
36413: LIST
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: LD_INT 2
36421: NEG
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 0
36429: PUSH
36430: LD_INT 2
36432: NEG
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: LD_INT 1
36443: NEG
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 2
36451: PUSH
36452: LD_INT 1
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 2
36461: PUSH
36462: LD_INT 2
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: PUSH
36472: LD_INT 2
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: PUSH
36479: LD_INT 0
36481: PUSH
36482: LD_INT 2
36484: PUSH
36485: EMPTY
36486: LIST
36487: LIST
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: LD_INT 1
36495: PUSH
36496: EMPTY
36497: LIST
36498: LIST
36499: PUSH
36500: LD_INT 2
36502: NEG
36503: PUSH
36504: LD_INT 1
36506: NEG
36507: PUSH
36508: EMPTY
36509: LIST
36510: LIST
36511: PUSH
36512: LD_INT 2
36514: NEG
36515: PUSH
36516: LD_INT 2
36518: NEG
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: PUSH
36524: LD_INT 2
36526: NEG
36527: PUSH
36528: LD_INT 3
36530: NEG
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 1
36538: NEG
36539: PUSH
36540: LD_INT 3
36542: NEG
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 0
36550: PUSH
36551: LD_INT 3
36553: NEG
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: PUSH
36562: LD_INT 2
36564: NEG
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 3
36572: PUSH
36573: LD_INT 2
36575: PUSH
36576: EMPTY
36577: LIST
36578: LIST
36579: PUSH
36580: LD_INT 3
36582: PUSH
36583: LD_INT 3
36585: PUSH
36586: EMPTY
36587: LIST
36588: LIST
36589: PUSH
36590: LD_INT 2
36592: PUSH
36593: LD_INT 3
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: LD_INT 3
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: PUSH
36610: LD_INT 0
36612: PUSH
36613: LD_INT 3
36615: PUSH
36616: EMPTY
36617: LIST
36618: LIST
36619: PUSH
36620: LD_INT 1
36622: NEG
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 3
36633: NEG
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 3
36645: NEG
36646: PUSH
36647: LD_INT 3
36649: NEG
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: EMPTY
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36686: LD_ADDR_VAR 0 43
36690: PUSH
36691: LD_INT 0
36693: PUSH
36694: LD_INT 0
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: LD_INT 1
36706: NEG
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 1
36714: PUSH
36715: LD_INT 0
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 1
36724: PUSH
36725: LD_INT 1
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: LD_INT 1
36737: PUSH
36738: EMPTY
36739: LIST
36740: LIST
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: LD_INT 0
36748: PUSH
36749: EMPTY
36750: LIST
36751: LIST
36752: PUSH
36753: LD_INT 1
36755: NEG
36756: PUSH
36757: LD_INT 1
36759: NEG
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: LD_INT 1
36767: NEG
36768: PUSH
36769: LD_INT 2
36771: NEG
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 0
36779: PUSH
36780: LD_INT 2
36782: NEG
36783: PUSH
36784: EMPTY
36785: LIST
36786: LIST
36787: PUSH
36788: LD_INT 1
36790: PUSH
36791: LD_INT 1
36793: NEG
36794: PUSH
36795: EMPTY
36796: LIST
36797: LIST
36798: PUSH
36799: LD_INT 2
36801: PUSH
36802: LD_INT 0
36804: PUSH
36805: EMPTY
36806: LIST
36807: LIST
36808: PUSH
36809: LD_INT 2
36811: PUSH
36812: LD_INT 1
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 1
36821: PUSH
36822: LD_INT 2
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 0
36831: PUSH
36832: LD_INT 2
36834: PUSH
36835: EMPTY
36836: LIST
36837: LIST
36838: PUSH
36839: LD_INT 1
36841: NEG
36842: PUSH
36843: LD_INT 1
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: LD_INT 0
36856: PUSH
36857: EMPTY
36858: LIST
36859: LIST
36860: PUSH
36861: LD_INT 2
36863: NEG
36864: PUSH
36865: LD_INT 1
36867: NEG
36868: PUSH
36869: EMPTY
36870: LIST
36871: LIST
36872: PUSH
36873: LD_INT 1
36875: NEG
36876: PUSH
36877: LD_INT 3
36879: NEG
36880: PUSH
36881: EMPTY
36882: LIST
36883: LIST
36884: PUSH
36885: LD_INT 0
36887: PUSH
36888: LD_INT 3
36890: NEG
36891: PUSH
36892: EMPTY
36893: LIST
36894: LIST
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: LD_INT 2
36901: NEG
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 2
36909: PUSH
36910: LD_INT 1
36912: NEG
36913: PUSH
36914: EMPTY
36915: LIST
36916: LIST
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: EMPTY
36925: LIST
36926: LIST
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 1
36940: PUSH
36941: LD_INT 3
36943: PUSH
36944: EMPTY
36945: LIST
36946: LIST
36947: PUSH
36948: LD_INT 0
36950: PUSH
36951: LD_INT 3
36953: PUSH
36954: EMPTY
36955: LIST
36956: LIST
36957: PUSH
36958: LD_INT 1
36960: NEG
36961: PUSH
36962: LD_INT 2
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 2
36971: NEG
36972: PUSH
36973: LD_INT 1
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 3
36982: NEG
36983: PUSH
36984: LD_INT 0
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 3
36993: NEG
36994: PUSH
36995: LD_INT 1
36997: NEG
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: EMPTY
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37034: LD_ADDR_VAR 0 44
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 1
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 0
37082: PUSH
37083: LD_INT 1
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 1
37092: NEG
37093: PUSH
37094: LD_INT 0
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: LD_INT 2
37119: NEG
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 1
37127: PUSH
37128: LD_INT 1
37130: NEG
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 2
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 2
37148: PUSH
37149: LD_INT 1
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 2
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: PUSH
37169: LD_INT 2
37171: PUSH
37172: EMPTY
37173: LIST
37174: LIST
37175: PUSH
37176: LD_INT 1
37178: NEG
37179: PUSH
37180: LD_INT 1
37182: PUSH
37183: EMPTY
37184: LIST
37185: LIST
37186: PUSH
37187: LD_INT 2
37189: NEG
37190: PUSH
37191: LD_INT 0
37193: PUSH
37194: EMPTY
37195: LIST
37196: LIST
37197: PUSH
37198: LD_INT 2
37200: NEG
37201: PUSH
37202: LD_INT 1
37204: NEG
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PUSH
37210: LD_INT 2
37212: NEG
37213: PUSH
37214: LD_INT 2
37216: NEG
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: PUSH
37222: LD_INT 2
37224: NEG
37225: PUSH
37226: LD_INT 3
37228: NEG
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 2
37236: PUSH
37237: LD_INT 1
37239: NEG
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 3
37247: PUSH
37248: LD_INT 0
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: LD_INT 3
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 3
37267: PUSH
37268: LD_INT 2
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 3
37277: PUSH
37278: LD_INT 3
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 2
37287: PUSH
37288: LD_INT 3
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 2
37297: NEG
37298: PUSH
37299: LD_INT 1
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 3
37308: NEG
37309: PUSH
37310: LD_INT 0
37312: PUSH
37313: EMPTY
37314: LIST
37315: LIST
37316: PUSH
37317: LD_INT 3
37319: NEG
37320: PUSH
37321: LD_INT 1
37323: NEG
37324: PUSH
37325: EMPTY
37326: LIST
37327: LIST
37328: PUSH
37329: LD_INT 3
37331: NEG
37332: PUSH
37333: LD_INT 2
37335: NEG
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 3
37343: NEG
37344: PUSH
37345: LD_INT 3
37347: NEG
37348: PUSH
37349: EMPTY
37350: LIST
37351: LIST
37352: PUSH
37353: EMPTY
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37384: LD_ADDR_VAR 0 45
37388: PUSH
37389: LD_INT 0
37391: PUSH
37392: LD_INT 0
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 0
37401: PUSH
37402: LD_INT 1
37404: NEG
37405: PUSH
37406: EMPTY
37407: LIST
37408: LIST
37409: PUSH
37410: LD_INT 1
37412: PUSH
37413: LD_INT 0
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 1
37422: PUSH
37423: LD_INT 1
37425: PUSH
37426: EMPTY
37427: LIST
37428: LIST
37429: PUSH
37430: LD_INT 0
37432: PUSH
37433: LD_INT 1
37435: PUSH
37436: EMPTY
37437: LIST
37438: LIST
37439: PUSH
37440: LD_INT 1
37442: NEG
37443: PUSH
37444: LD_INT 0
37446: PUSH
37447: EMPTY
37448: LIST
37449: LIST
37450: PUSH
37451: LD_INT 1
37453: NEG
37454: PUSH
37455: LD_INT 1
37457: NEG
37458: PUSH
37459: EMPTY
37460: LIST
37461: LIST
37462: PUSH
37463: LD_INT 1
37465: NEG
37466: PUSH
37467: LD_INT 2
37469: NEG
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 0
37477: PUSH
37478: LD_INT 2
37480: NEG
37481: PUSH
37482: EMPTY
37483: LIST
37484: LIST
37485: PUSH
37486: LD_INT 1
37488: PUSH
37489: LD_INT 1
37491: NEG
37492: PUSH
37493: EMPTY
37494: LIST
37495: LIST
37496: PUSH
37497: LD_INT 2
37499: PUSH
37500: LD_INT 1
37502: PUSH
37503: EMPTY
37504: LIST
37505: LIST
37506: PUSH
37507: LD_INT 2
37509: PUSH
37510: LD_INT 2
37512: PUSH
37513: EMPTY
37514: LIST
37515: LIST
37516: PUSH
37517: LD_INT 1
37519: PUSH
37520: LD_INT 2
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PUSH
37527: LD_INT 0
37529: PUSH
37530: LD_INT 2
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 1
37539: NEG
37540: PUSH
37541: LD_INT 1
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 2
37550: NEG
37551: PUSH
37552: LD_INT 1
37554: NEG
37555: PUSH
37556: EMPTY
37557: LIST
37558: LIST
37559: PUSH
37560: LD_INT 2
37562: NEG
37563: PUSH
37564: LD_INT 2
37566: NEG
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: PUSH
37572: LD_INT 2
37574: NEG
37575: PUSH
37576: LD_INT 3
37578: NEG
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 1
37586: NEG
37587: PUSH
37588: LD_INT 3
37590: NEG
37591: PUSH
37592: EMPTY
37593: LIST
37594: LIST
37595: PUSH
37596: LD_INT 0
37598: PUSH
37599: LD_INT 3
37601: NEG
37602: PUSH
37603: EMPTY
37604: LIST
37605: LIST
37606: PUSH
37607: LD_INT 1
37609: PUSH
37610: LD_INT 2
37612: NEG
37613: PUSH
37614: EMPTY
37615: LIST
37616: LIST
37617: PUSH
37618: LD_INT 3
37620: PUSH
37621: LD_INT 2
37623: PUSH
37624: EMPTY
37625: LIST
37626: LIST
37627: PUSH
37628: LD_INT 3
37630: PUSH
37631: LD_INT 3
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PUSH
37638: LD_INT 2
37640: PUSH
37641: LD_INT 3
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 1
37650: PUSH
37651: LD_INT 3
37653: PUSH
37654: EMPTY
37655: LIST
37656: LIST
37657: PUSH
37658: LD_INT 0
37660: PUSH
37661: LD_INT 3
37663: PUSH
37664: EMPTY
37665: LIST
37666: LIST
37667: PUSH
37668: LD_INT 1
37670: NEG
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: EMPTY
37676: LIST
37677: LIST
37678: PUSH
37679: LD_INT 3
37681: NEG
37682: PUSH
37683: LD_INT 2
37685: NEG
37686: PUSH
37687: EMPTY
37688: LIST
37689: LIST
37690: PUSH
37691: LD_INT 3
37693: NEG
37694: PUSH
37695: LD_INT 3
37697: NEG
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37734: LD_ADDR_VAR 0 46
37738: PUSH
37739: LD_INT 0
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: LD_INT 1
37754: NEG
37755: PUSH
37756: EMPTY
37757: LIST
37758: LIST
37759: PUSH
37760: LD_INT 1
37762: PUSH
37763: LD_INT 0
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 1
37772: PUSH
37773: LD_INT 1
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 0
37782: PUSH
37783: LD_INT 1
37785: PUSH
37786: EMPTY
37787: LIST
37788: LIST
37789: PUSH
37790: LD_INT 1
37792: NEG
37793: PUSH
37794: LD_INT 0
37796: PUSH
37797: EMPTY
37798: LIST
37799: LIST
37800: PUSH
37801: LD_INT 1
37803: NEG
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 1
37815: NEG
37816: PUSH
37817: LD_INT 2
37819: NEG
37820: PUSH
37821: EMPTY
37822: LIST
37823: LIST
37824: PUSH
37825: LD_INT 0
37827: PUSH
37828: LD_INT 2
37830: NEG
37831: PUSH
37832: EMPTY
37833: LIST
37834: LIST
37835: PUSH
37836: LD_INT 1
37838: PUSH
37839: LD_INT 1
37841: NEG
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: LD_INT 2
37849: PUSH
37850: LD_INT 0
37852: PUSH
37853: EMPTY
37854: LIST
37855: LIST
37856: PUSH
37857: LD_INT 2
37859: PUSH
37860: LD_INT 1
37862: PUSH
37863: EMPTY
37864: LIST
37865: LIST
37866: PUSH
37867: LD_INT 1
37869: PUSH
37870: LD_INT 2
37872: PUSH
37873: EMPTY
37874: LIST
37875: LIST
37876: PUSH
37877: LD_INT 0
37879: PUSH
37880: LD_INT 2
37882: PUSH
37883: EMPTY
37884: LIST
37885: LIST
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: LD_INT 1
37893: PUSH
37894: EMPTY
37895: LIST
37896: LIST
37897: PUSH
37898: LD_INT 2
37900: NEG
37901: PUSH
37902: LD_INT 0
37904: PUSH
37905: EMPTY
37906: LIST
37907: LIST
37908: PUSH
37909: LD_INT 2
37911: NEG
37912: PUSH
37913: LD_INT 1
37915: NEG
37916: PUSH
37917: EMPTY
37918: LIST
37919: LIST
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: LD_INT 3
37927: NEG
37928: PUSH
37929: EMPTY
37930: LIST
37931: LIST
37932: PUSH
37933: LD_INT 0
37935: PUSH
37936: LD_INT 3
37938: NEG
37939: PUSH
37940: EMPTY
37941: LIST
37942: LIST
37943: PUSH
37944: LD_INT 1
37946: PUSH
37947: LD_INT 2
37949: NEG
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 2
37957: PUSH
37958: LD_INT 1
37960: NEG
37961: PUSH
37962: EMPTY
37963: LIST
37964: LIST
37965: PUSH
37966: LD_INT 3
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: LD_INT 3
37978: PUSH
37979: LD_INT 1
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 1
37988: PUSH
37989: LD_INT 3
37991: PUSH
37992: EMPTY
37993: LIST
37994: LIST
37995: PUSH
37996: LD_INT 0
37998: PUSH
37999: LD_INT 3
38001: PUSH
38002: EMPTY
38003: LIST
38004: LIST
38005: PUSH
38006: LD_INT 1
38008: NEG
38009: PUSH
38010: LD_INT 2
38012: PUSH
38013: EMPTY
38014: LIST
38015: LIST
38016: PUSH
38017: LD_INT 2
38019: NEG
38020: PUSH
38021: LD_INT 1
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 3
38030: NEG
38031: PUSH
38032: LD_INT 0
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 3
38041: NEG
38042: PUSH
38043: LD_INT 1
38045: NEG
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: EMPTY
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38082: LD_ADDR_VAR 0 47
38086: PUSH
38087: LD_INT 0
38089: PUSH
38090: LD_INT 0
38092: PUSH
38093: EMPTY
38094: LIST
38095: LIST
38096: PUSH
38097: LD_INT 0
38099: PUSH
38100: LD_INT 1
38102: NEG
38103: PUSH
38104: EMPTY
38105: LIST
38106: LIST
38107: PUSH
38108: LD_INT 1
38110: PUSH
38111: LD_INT 0
38113: PUSH
38114: EMPTY
38115: LIST
38116: LIST
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: LD_INT 1
38123: PUSH
38124: EMPTY
38125: LIST
38126: LIST
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: PUSH
38138: LD_INT 1
38140: NEG
38141: PUSH
38142: LD_INT 0
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PUSH
38149: LD_INT 1
38151: NEG
38152: PUSH
38153: LD_INT 1
38155: NEG
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: LD_INT 2
38167: NEG
38168: PUSH
38169: EMPTY
38170: LIST
38171: LIST
38172: PUSH
38173: LD_INT 0
38175: PUSH
38176: LD_INT 2
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: EMPTY
38192: LIST
38193: LIST
38194: PUSH
38195: LD_INT 2
38197: NEG
38198: PUSH
38199: LD_INT 1
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 2
38209: NEG
38210: PUSH
38211: LD_INT 2
38213: NEG
38214: PUSH
38215: EMPTY
38216: LIST
38217: LIST
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38233: LD_ADDR_VAR 0 48
38237: PUSH
38238: LD_INT 0
38240: PUSH
38241: LD_INT 0
38243: PUSH
38244: EMPTY
38245: LIST
38246: LIST
38247: PUSH
38248: LD_INT 0
38250: PUSH
38251: LD_INT 1
38253: NEG
38254: PUSH
38255: EMPTY
38256: LIST
38257: LIST
38258: PUSH
38259: LD_INT 1
38261: PUSH
38262: LD_INT 0
38264: PUSH
38265: EMPTY
38266: LIST
38267: LIST
38268: PUSH
38269: LD_INT 1
38271: PUSH
38272: LD_INT 1
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 0
38281: PUSH
38282: LD_INT 1
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: LD_INT 1
38291: NEG
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 1
38302: NEG
38303: PUSH
38304: LD_INT 1
38306: NEG
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 1
38314: NEG
38315: PUSH
38316: LD_INT 2
38318: NEG
38319: PUSH
38320: EMPTY
38321: LIST
38322: LIST
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: LD_INT 2
38329: NEG
38330: PUSH
38331: EMPTY
38332: LIST
38333: LIST
38334: PUSH
38335: LD_INT 1
38337: PUSH
38338: LD_INT 1
38340: NEG
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 2
38348: PUSH
38349: LD_INT 0
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 2
38358: PUSH
38359: LD_INT 1
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: LIST
38370: LIST
38371: LIST
38372: LIST
38373: LIST
38374: LIST
38375: LIST
38376: LIST
38377: LIST
38378: LIST
38379: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38380: LD_ADDR_VAR 0 49
38384: PUSH
38385: LD_INT 0
38387: PUSH
38388: LD_INT 0
38390: PUSH
38391: EMPTY
38392: LIST
38393: LIST
38394: PUSH
38395: LD_INT 0
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: LD_INT 1
38408: PUSH
38409: LD_INT 0
38411: PUSH
38412: EMPTY
38413: LIST
38414: LIST
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: LD_INT 1
38421: PUSH
38422: EMPTY
38423: LIST
38424: LIST
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: LD_INT 1
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: LD_INT 1
38438: NEG
38439: PUSH
38440: LD_INT 0
38442: PUSH
38443: EMPTY
38444: LIST
38445: LIST
38446: PUSH
38447: LD_INT 1
38449: NEG
38450: PUSH
38451: LD_INT 1
38453: NEG
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: LD_INT 1
38464: NEG
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: LD_INT 0
38475: PUSH
38476: EMPTY
38477: LIST
38478: LIST
38479: PUSH
38480: LD_INT 2
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: EMPTY
38487: LIST
38488: LIST
38489: PUSH
38490: LD_INT 2
38492: PUSH
38493: LD_INT 2
38495: PUSH
38496: EMPTY
38497: LIST
38498: LIST
38499: PUSH
38500: LD_INT 1
38502: PUSH
38503: LD_INT 2
38505: PUSH
38506: EMPTY
38507: LIST
38508: LIST
38509: PUSH
38510: EMPTY
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: LIST
38520: LIST
38521: LIST
38522: LIST
38523: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38524: LD_ADDR_VAR 0 50
38528: PUSH
38529: LD_INT 0
38531: PUSH
38532: LD_INT 0
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 0
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 0
38555: PUSH
38556: EMPTY
38557: LIST
38558: LIST
38559: PUSH
38560: LD_INT 1
38562: PUSH
38563: LD_INT 1
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 0
38572: PUSH
38573: LD_INT 1
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 1
38582: NEG
38583: PUSH
38584: LD_INT 0
38586: PUSH
38587: EMPTY
38588: LIST
38589: LIST
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: LD_INT 1
38597: NEG
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 2
38605: PUSH
38606: LD_INT 1
38608: PUSH
38609: EMPTY
38610: LIST
38611: LIST
38612: PUSH
38613: LD_INT 2
38615: PUSH
38616: LD_INT 2
38618: PUSH
38619: EMPTY
38620: LIST
38621: LIST
38622: PUSH
38623: LD_INT 1
38625: PUSH
38626: LD_INT 2
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 0
38635: PUSH
38636: LD_INT 2
38638: PUSH
38639: EMPTY
38640: LIST
38641: LIST
38642: PUSH
38643: LD_INT 1
38645: NEG
38646: PUSH
38647: LD_INT 1
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38668: LD_ADDR_VAR 0 51
38672: PUSH
38673: LD_INT 0
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 0
38685: PUSH
38686: LD_INT 1
38688: NEG
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: LD_INT 0
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 1
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 0
38716: PUSH
38717: LD_INT 1
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 1
38726: NEG
38727: PUSH
38728: LD_INT 0
38730: PUSH
38731: EMPTY
38732: LIST
38733: LIST
38734: PUSH
38735: LD_INT 1
38737: NEG
38738: PUSH
38739: LD_INT 1
38741: NEG
38742: PUSH
38743: EMPTY
38744: LIST
38745: LIST
38746: PUSH
38747: LD_INT 1
38749: PUSH
38750: LD_INT 2
38752: PUSH
38753: EMPTY
38754: LIST
38755: LIST
38756: PUSH
38757: LD_INT 0
38759: PUSH
38760: LD_INT 2
38762: PUSH
38763: EMPTY
38764: LIST
38765: LIST
38766: PUSH
38767: LD_INT 1
38769: NEG
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 2
38780: NEG
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: LD_INT 1
38795: NEG
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: LIST
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38815: LD_ADDR_VAR 0 52
38819: PUSH
38820: LD_INT 0
38822: PUSH
38823: LD_INT 0
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: LD_INT 1
38835: NEG
38836: PUSH
38837: EMPTY
38838: LIST
38839: LIST
38840: PUSH
38841: LD_INT 1
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 1
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 0
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: EMPTY
38868: LIST
38869: LIST
38870: PUSH
38871: LD_INT 1
38873: NEG
38874: PUSH
38875: LD_INT 0
38877: PUSH
38878: EMPTY
38879: LIST
38880: LIST
38881: PUSH
38882: LD_INT 1
38884: NEG
38885: PUSH
38886: LD_INT 1
38888: NEG
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: LD_INT 2
38900: NEG
38901: PUSH
38902: EMPTY
38903: LIST
38904: LIST
38905: PUSH
38906: LD_INT 1
38908: NEG
38909: PUSH
38910: LD_INT 1
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 2
38919: NEG
38920: PUSH
38921: LD_INT 0
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: NEG
38931: PUSH
38932: LD_INT 1
38934: NEG
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 2
38942: NEG
38943: PUSH
38944: LD_INT 2
38946: NEG
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: PUSH
38952: EMPTY
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: LIST
38962: LIST
38963: LIST
38964: LIST
38965: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38966: LD_ADDR_VAR 0 53
38970: PUSH
38971: LD_INT 0
38973: PUSH
38974: LD_INT 0
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 1
38994: PUSH
38995: LD_INT 0
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 0
39014: PUSH
39015: LD_INT 1
39017: PUSH
39018: EMPTY
39019: LIST
39020: LIST
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: LD_INT 0
39028: PUSH
39029: EMPTY
39030: LIST
39031: LIST
39032: PUSH
39033: LD_INT 1
39035: NEG
39036: PUSH
39037: LD_INT 1
39039: NEG
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: NEG
39048: PUSH
39049: LD_INT 2
39051: NEG
39052: PUSH
39053: EMPTY
39054: LIST
39055: LIST
39056: PUSH
39057: LD_INT 0
39059: PUSH
39060: LD_INT 2
39062: NEG
39063: PUSH
39064: EMPTY
39065: LIST
39066: LIST
39067: PUSH
39068: LD_INT 1
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 2
39081: PUSH
39082: LD_INT 0
39084: PUSH
39085: EMPTY
39086: LIST
39087: LIST
39088: PUSH
39089: LD_INT 2
39091: PUSH
39092: LD_INT 1
39094: PUSH
39095: EMPTY
39096: LIST
39097: LIST
39098: PUSH
39099: LD_INT 2
39101: PUSH
39102: LD_INT 2
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: PUSH
39112: LD_INT 2
39114: PUSH
39115: EMPTY
39116: LIST
39117: LIST
39118: PUSH
39119: LD_INT 0
39121: PUSH
39122: LD_INT 2
39124: PUSH
39125: EMPTY
39126: LIST
39127: LIST
39128: PUSH
39129: LD_INT 1
39131: NEG
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: PUSH
39140: LD_INT 2
39142: NEG
39143: PUSH
39144: LD_INT 0
39146: PUSH
39147: EMPTY
39148: LIST
39149: LIST
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: LD_INT 1
39157: NEG
39158: PUSH
39159: EMPTY
39160: LIST
39161: LIST
39162: PUSH
39163: LD_INT 2
39165: NEG
39166: PUSH
39167: LD_INT 2
39169: NEG
39170: PUSH
39171: EMPTY
39172: LIST
39173: LIST
39174: PUSH
39175: EMPTY
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: LIST
39185: LIST
39186: LIST
39187: LIST
39188: LIST
39189: LIST
39190: LIST
39191: LIST
39192: LIST
39193: LIST
39194: LIST
39195: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39196: LD_ADDR_VAR 0 54
39200: PUSH
39201: LD_INT 0
39203: PUSH
39204: LD_INT 0
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 0
39213: PUSH
39214: LD_INT 1
39216: NEG
39217: PUSH
39218: EMPTY
39219: LIST
39220: LIST
39221: PUSH
39222: LD_INT 1
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: EMPTY
39229: LIST
39230: LIST
39231: PUSH
39232: LD_INT 1
39234: PUSH
39235: LD_INT 1
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 0
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 1
39265: NEG
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 1
39277: NEG
39278: PUSH
39279: LD_INT 2
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: LD_INT 0
39289: PUSH
39290: LD_INT 2
39292: NEG
39293: PUSH
39294: EMPTY
39295: LIST
39296: LIST
39297: PUSH
39298: LD_INT 1
39300: PUSH
39301: LD_INT 1
39303: NEG
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 2
39311: PUSH
39312: LD_INT 0
39314: PUSH
39315: EMPTY
39316: LIST
39317: LIST
39318: PUSH
39319: LD_INT 2
39321: PUSH
39322: LD_INT 1
39324: PUSH
39325: EMPTY
39326: LIST
39327: LIST
39328: PUSH
39329: LD_INT 2
39331: PUSH
39332: LD_INT 2
39334: PUSH
39335: EMPTY
39336: LIST
39337: LIST
39338: PUSH
39339: LD_INT 1
39341: PUSH
39342: LD_INT 2
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 0
39351: PUSH
39352: LD_INT 2
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 1
39361: NEG
39362: PUSH
39363: LD_INT 1
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 2
39372: NEG
39373: PUSH
39374: LD_INT 0
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 2
39383: NEG
39384: PUSH
39385: LD_INT 1
39387: NEG
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: PUSH
39393: LD_INT 2
39395: NEG
39396: PUSH
39397: LD_INT 2
39399: NEG
39400: PUSH
39401: EMPTY
39402: LIST
39403: LIST
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: LIST
39411: LIST
39412: LIST
39413: LIST
39414: LIST
39415: LIST
39416: LIST
39417: LIST
39418: LIST
39419: LIST
39420: LIST
39421: LIST
39422: LIST
39423: LIST
39424: LIST
39425: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39426: LD_ADDR_VAR 0 55
39430: PUSH
39431: LD_INT 0
39433: PUSH
39434: LD_INT 0
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 0
39443: PUSH
39444: LD_INT 1
39446: NEG
39447: PUSH
39448: EMPTY
39449: LIST
39450: LIST
39451: PUSH
39452: LD_INT 1
39454: PUSH
39455: LD_INT 0
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PUSH
39462: LD_INT 1
39464: PUSH
39465: LD_INT 1
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 0
39474: PUSH
39475: LD_INT 1
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: LD_INT 0
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PUSH
39493: LD_INT 1
39495: NEG
39496: PUSH
39497: LD_INT 1
39499: NEG
39500: PUSH
39501: EMPTY
39502: LIST
39503: LIST
39504: PUSH
39505: LD_INT 1
39507: NEG
39508: PUSH
39509: LD_INT 2
39511: NEG
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 0
39519: PUSH
39520: LD_INT 2
39522: NEG
39523: PUSH
39524: EMPTY
39525: LIST
39526: LIST
39527: PUSH
39528: LD_INT 1
39530: PUSH
39531: LD_INT 1
39533: NEG
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: PUSH
39539: LD_INT 2
39541: PUSH
39542: LD_INT 0
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PUSH
39549: LD_INT 2
39551: PUSH
39552: LD_INT 1
39554: PUSH
39555: EMPTY
39556: LIST
39557: LIST
39558: PUSH
39559: LD_INT 2
39561: PUSH
39562: LD_INT 2
39564: PUSH
39565: EMPTY
39566: LIST
39567: LIST
39568: PUSH
39569: LD_INT 1
39571: PUSH
39572: LD_INT 2
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: LD_INT 0
39581: PUSH
39582: LD_INT 2
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 1
39591: NEG
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 2
39602: NEG
39603: PUSH
39604: LD_INT 0
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: LD_INT 1
39617: NEG
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 2
39625: NEG
39626: PUSH
39627: LD_INT 2
39629: NEG
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: EMPTY
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: LIST
39641: LIST
39642: LIST
39643: LIST
39644: LIST
39645: LIST
39646: LIST
39647: LIST
39648: LIST
39649: LIST
39650: LIST
39651: LIST
39652: LIST
39653: LIST
39654: LIST
39655: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39656: LD_ADDR_VAR 0 56
39660: PUSH
39661: LD_INT 0
39663: PUSH
39664: LD_INT 0
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 0
39673: PUSH
39674: LD_INT 1
39676: NEG
39677: PUSH
39678: EMPTY
39679: LIST
39680: LIST
39681: PUSH
39682: LD_INT 1
39684: PUSH
39685: LD_INT 0
39687: PUSH
39688: EMPTY
39689: LIST
39690: LIST
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 0
39704: PUSH
39705: LD_INT 1
39707: PUSH
39708: EMPTY
39709: LIST
39710: LIST
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: LD_INT 0
39718: PUSH
39719: EMPTY
39720: LIST
39721: LIST
39722: PUSH
39723: LD_INT 1
39725: NEG
39726: PUSH
39727: LD_INT 1
39729: NEG
39730: PUSH
39731: EMPTY
39732: LIST
39733: LIST
39734: PUSH
39735: LD_INT 1
39737: NEG
39738: PUSH
39739: LD_INT 2
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 0
39749: PUSH
39750: LD_INT 2
39752: NEG
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 1
39760: PUSH
39761: LD_INT 1
39763: NEG
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 2
39771: PUSH
39772: LD_INT 0
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: LD_INT 1
39784: PUSH
39785: EMPTY
39786: LIST
39787: LIST
39788: PUSH
39789: LD_INT 2
39791: PUSH
39792: LD_INT 2
39794: PUSH
39795: EMPTY
39796: LIST
39797: LIST
39798: PUSH
39799: LD_INT 1
39801: PUSH
39802: LD_INT 2
39804: PUSH
39805: EMPTY
39806: LIST
39807: LIST
39808: PUSH
39809: LD_INT 0
39811: PUSH
39812: LD_INT 2
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: LD_INT 1
39825: PUSH
39826: EMPTY
39827: LIST
39828: LIST
39829: PUSH
39830: LD_INT 2
39832: NEG
39833: PUSH
39834: LD_INT 0
39836: PUSH
39837: EMPTY
39838: LIST
39839: LIST
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: LD_INT 1
39847: NEG
39848: PUSH
39849: EMPTY
39850: LIST
39851: LIST
39852: PUSH
39853: LD_INT 2
39855: NEG
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: EMPTY
39862: LIST
39863: LIST
39864: PUSH
39865: EMPTY
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: LIST
39871: LIST
39872: LIST
39873: LIST
39874: LIST
39875: LIST
39876: LIST
39877: LIST
39878: LIST
39879: LIST
39880: LIST
39881: LIST
39882: LIST
39883: LIST
39884: LIST
39885: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39886: LD_ADDR_VAR 0 57
39890: PUSH
39891: LD_INT 0
39893: PUSH
39894: LD_INT 0
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 0
39903: PUSH
39904: LD_INT 1
39906: NEG
39907: PUSH
39908: EMPTY
39909: LIST
39910: LIST
39911: PUSH
39912: LD_INT 1
39914: PUSH
39915: LD_INT 0
39917: PUSH
39918: EMPTY
39919: LIST
39920: LIST
39921: PUSH
39922: LD_INT 1
39924: PUSH
39925: LD_INT 1
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 0
39934: PUSH
39935: LD_INT 1
39937: PUSH
39938: EMPTY
39939: LIST
39940: LIST
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: LD_INT 0
39948: PUSH
39949: EMPTY
39950: LIST
39951: LIST
39952: PUSH
39953: LD_INT 1
39955: NEG
39956: PUSH
39957: LD_INT 1
39959: NEG
39960: PUSH
39961: EMPTY
39962: LIST
39963: LIST
39964: PUSH
39965: LD_INT 1
39967: NEG
39968: PUSH
39969: LD_INT 2
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 0
39979: PUSH
39980: LD_INT 2
39982: NEG
39983: PUSH
39984: EMPTY
39985: LIST
39986: LIST
39987: PUSH
39988: LD_INT 1
39990: PUSH
39991: LD_INT 1
39993: NEG
39994: PUSH
39995: EMPTY
39996: LIST
39997: LIST
39998: PUSH
39999: LD_INT 2
40001: PUSH
40002: LD_INT 0
40004: PUSH
40005: EMPTY
40006: LIST
40007: LIST
40008: PUSH
40009: LD_INT 2
40011: PUSH
40012: LD_INT 1
40014: PUSH
40015: EMPTY
40016: LIST
40017: LIST
40018: PUSH
40019: LD_INT 2
40021: PUSH
40022: LD_INT 2
40024: PUSH
40025: EMPTY
40026: LIST
40027: LIST
40028: PUSH
40029: LD_INT 1
40031: PUSH
40032: LD_INT 2
40034: PUSH
40035: EMPTY
40036: LIST
40037: LIST
40038: PUSH
40039: LD_INT 0
40041: PUSH
40042: LD_INT 2
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 1
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 2
40062: NEG
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: EMPTY
40068: LIST
40069: LIST
40070: PUSH
40071: LD_INT 2
40073: NEG
40074: PUSH
40075: LD_INT 1
40077: NEG
40078: PUSH
40079: EMPTY
40080: LIST
40081: LIST
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: LD_INT 2
40089: NEG
40090: PUSH
40091: EMPTY
40092: LIST
40093: LIST
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: LIST
40101: LIST
40102: LIST
40103: LIST
40104: LIST
40105: LIST
40106: LIST
40107: LIST
40108: LIST
40109: LIST
40110: LIST
40111: LIST
40112: LIST
40113: LIST
40114: LIST
40115: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40116: LD_ADDR_VAR 0 58
40120: PUSH
40121: LD_INT 0
40123: PUSH
40124: LD_INT 0
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 0
40133: PUSH
40134: LD_INT 1
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 1
40144: PUSH
40145: LD_INT 0
40147: PUSH
40148: EMPTY
40149: LIST
40150: LIST
40151: PUSH
40152: LD_INT 1
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 1
40167: PUSH
40168: EMPTY
40169: LIST
40170: LIST
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: LD_INT 0
40178: PUSH
40179: EMPTY
40180: LIST
40181: LIST
40182: PUSH
40183: LD_INT 1
40185: NEG
40186: PUSH
40187: LD_INT 1
40189: NEG
40190: PUSH
40191: EMPTY
40192: LIST
40193: LIST
40194: PUSH
40195: LD_INT 1
40197: NEG
40198: PUSH
40199: LD_INT 2
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 0
40209: PUSH
40210: LD_INT 2
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: LD_INT 1
40220: PUSH
40221: LD_INT 1
40223: NEG
40224: PUSH
40225: EMPTY
40226: LIST
40227: LIST
40228: PUSH
40229: LD_INT 2
40231: PUSH
40232: LD_INT 0
40234: PUSH
40235: EMPTY
40236: LIST
40237: LIST
40238: PUSH
40239: LD_INT 2
40241: PUSH
40242: LD_INT 1
40244: PUSH
40245: EMPTY
40246: LIST
40247: LIST
40248: PUSH
40249: LD_INT 2
40251: PUSH
40252: LD_INT 2
40254: PUSH
40255: EMPTY
40256: LIST
40257: LIST
40258: PUSH
40259: LD_INT 1
40261: PUSH
40262: LD_INT 2
40264: PUSH
40265: EMPTY
40266: LIST
40267: LIST
40268: PUSH
40269: LD_INT 0
40271: PUSH
40272: LD_INT 2
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 1
40281: NEG
40282: PUSH
40283: LD_INT 1
40285: PUSH
40286: EMPTY
40287: LIST
40288: LIST
40289: PUSH
40290: LD_INT 2
40292: NEG
40293: PUSH
40294: LD_INT 0
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: PUSH
40301: LD_INT 2
40303: NEG
40304: PUSH
40305: LD_INT 1
40307: NEG
40308: PUSH
40309: EMPTY
40310: LIST
40311: LIST
40312: PUSH
40313: LD_INT 2
40315: NEG
40316: PUSH
40317: LD_INT 2
40319: NEG
40320: PUSH
40321: EMPTY
40322: LIST
40323: LIST
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: LIST
40331: LIST
40332: LIST
40333: LIST
40334: LIST
40335: LIST
40336: LIST
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40346: LD_ADDR_VAR 0 59
40350: PUSH
40351: LD_INT 0
40353: PUSH
40354: LD_INT 0
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: LD_INT 0
40363: PUSH
40364: LD_INT 1
40366: NEG
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 1
40374: PUSH
40375: LD_INT 0
40377: PUSH
40378: EMPTY
40379: LIST
40380: LIST
40381: PUSH
40382: LD_INT 1
40384: PUSH
40385: LD_INT 1
40387: PUSH
40388: EMPTY
40389: LIST
40390: LIST
40391: PUSH
40392: LD_INT 0
40394: PUSH
40395: LD_INT 1
40397: PUSH
40398: EMPTY
40399: LIST
40400: LIST
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: LD_INT 0
40408: PUSH
40409: EMPTY
40410: LIST
40411: LIST
40412: PUSH
40413: LD_INT 1
40415: NEG
40416: PUSH
40417: LD_INT 1
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: LIST
40429: LIST
40430: LIST
40431: LIST
40432: LIST
40433: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40434: LD_ADDR_VAR 0 60
40438: PUSH
40439: LD_INT 0
40441: PUSH
40442: LD_INT 0
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 0
40451: PUSH
40452: LD_INT 1
40454: NEG
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 1
40462: PUSH
40463: LD_INT 0
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 1
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: LD_INT 1
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 1
40492: NEG
40493: PUSH
40494: LD_INT 0
40496: PUSH
40497: EMPTY
40498: LIST
40499: LIST
40500: PUSH
40501: LD_INT 1
40503: NEG
40504: PUSH
40505: LD_INT 1
40507: NEG
40508: PUSH
40509: EMPTY
40510: LIST
40511: LIST
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: LIST
40517: LIST
40518: LIST
40519: LIST
40520: LIST
40521: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40522: LD_ADDR_VAR 0 61
40526: PUSH
40527: LD_INT 0
40529: PUSH
40530: LD_INT 0
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 0
40539: PUSH
40540: LD_INT 1
40542: NEG
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 1
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 1
40560: PUSH
40561: LD_INT 1
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 0
40570: PUSH
40571: LD_INT 1
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 1
40580: NEG
40581: PUSH
40582: LD_INT 0
40584: PUSH
40585: EMPTY
40586: LIST
40587: LIST
40588: PUSH
40589: LD_INT 1
40591: NEG
40592: PUSH
40593: LD_INT 1
40595: NEG
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: EMPTY
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: LIST
40609: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40610: LD_ADDR_VAR 0 62
40614: PUSH
40615: LD_INT 0
40617: PUSH
40618: LD_INT 0
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 0
40627: PUSH
40628: LD_INT 1
40630: NEG
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 1
40638: PUSH
40639: LD_INT 0
40641: PUSH
40642: EMPTY
40643: LIST
40644: LIST
40645: PUSH
40646: LD_INT 1
40648: PUSH
40649: LD_INT 1
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 0
40658: PUSH
40659: LD_INT 1
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 1
40668: NEG
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 1
40679: NEG
40680: PUSH
40681: LD_INT 1
40683: NEG
40684: PUSH
40685: EMPTY
40686: LIST
40687: LIST
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40698: LD_ADDR_VAR 0 63
40702: PUSH
40703: LD_INT 0
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: EMPTY
40710: LIST
40711: LIST
40712: PUSH
40713: LD_INT 0
40715: PUSH
40716: LD_INT 1
40718: NEG
40719: PUSH
40720: EMPTY
40721: LIST
40722: LIST
40723: PUSH
40724: LD_INT 1
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: EMPTY
40731: LIST
40732: LIST
40733: PUSH
40734: LD_INT 1
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: EMPTY
40741: LIST
40742: LIST
40743: PUSH
40744: LD_INT 0
40746: PUSH
40747: LD_INT 1
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 1
40756: NEG
40757: PUSH
40758: LD_INT 0
40760: PUSH
40761: EMPTY
40762: LIST
40763: LIST
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: LD_INT 1
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: EMPTY
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40786: LD_ADDR_VAR 0 64
40790: PUSH
40791: LD_INT 0
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: LD_INT 0
40803: PUSH
40804: LD_INT 1
40806: NEG
40807: PUSH
40808: EMPTY
40809: LIST
40810: LIST
40811: PUSH
40812: LD_INT 1
40814: PUSH
40815: LD_INT 0
40817: PUSH
40818: EMPTY
40819: LIST
40820: LIST
40821: PUSH
40822: LD_INT 1
40824: PUSH
40825: LD_INT 1
40827: PUSH
40828: EMPTY
40829: LIST
40830: LIST
40831: PUSH
40832: LD_INT 0
40834: PUSH
40835: LD_INT 1
40837: PUSH
40838: EMPTY
40839: LIST
40840: LIST
40841: PUSH
40842: LD_INT 1
40844: NEG
40845: PUSH
40846: LD_INT 0
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 1
40855: NEG
40856: PUSH
40857: LD_INT 1
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: EMPTY
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: ST_TO_ADDR
// end ; 1 :
40874: GO 46771
40876: LD_INT 1
40878: DOUBLE
40879: EQUAL
40880: IFTRUE 40884
40882: GO 43507
40884: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40885: LD_ADDR_VAR 0 11
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: LD_INT 3
40896: NEG
40897: PUSH
40898: EMPTY
40899: LIST
40900: LIST
40901: PUSH
40902: LD_INT 0
40904: PUSH
40905: LD_INT 3
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 1
40915: PUSH
40916: LD_INT 2
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: LIST
40928: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40929: LD_ADDR_VAR 0 12
40933: PUSH
40934: LD_INT 2
40936: PUSH
40937: LD_INT 1
40939: NEG
40940: PUSH
40941: EMPTY
40942: LIST
40943: LIST
40944: PUSH
40945: LD_INT 3
40947: PUSH
40948: LD_INT 0
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: PUSH
40955: LD_INT 3
40957: PUSH
40958: LD_INT 1
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: LIST
40969: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40970: LD_ADDR_VAR 0 13
40974: PUSH
40975: LD_INT 3
40977: PUSH
40978: LD_INT 2
40980: PUSH
40981: EMPTY
40982: LIST
40983: LIST
40984: PUSH
40985: LD_INT 3
40987: PUSH
40988: LD_INT 3
40990: PUSH
40991: EMPTY
40992: LIST
40993: LIST
40994: PUSH
40995: LD_INT 2
40997: PUSH
40998: LD_INT 3
41000: PUSH
41001: EMPTY
41002: LIST
41003: LIST
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: LIST
41009: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41010: LD_ADDR_VAR 0 14
41014: PUSH
41015: LD_INT 1
41017: PUSH
41018: LD_INT 3
41020: PUSH
41021: EMPTY
41022: LIST
41023: LIST
41024: PUSH
41025: LD_INT 0
41027: PUSH
41028: LD_INT 3
41030: PUSH
41031: EMPTY
41032: LIST
41033: LIST
41034: PUSH
41035: LD_INT 1
41037: NEG
41038: PUSH
41039: LD_INT 2
41041: PUSH
41042: EMPTY
41043: LIST
41044: LIST
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: LIST
41050: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41051: LD_ADDR_VAR 0 15
41055: PUSH
41056: LD_INT 2
41058: NEG
41059: PUSH
41060: LD_INT 1
41062: PUSH
41063: EMPTY
41064: LIST
41065: LIST
41066: PUSH
41067: LD_INT 3
41069: NEG
41070: PUSH
41071: LD_INT 0
41073: PUSH
41074: EMPTY
41075: LIST
41076: LIST
41077: PUSH
41078: LD_INT 3
41080: NEG
41081: PUSH
41082: LD_INT 1
41084: NEG
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: LIST
41094: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41095: LD_ADDR_VAR 0 16
41099: PUSH
41100: LD_INT 2
41102: NEG
41103: PUSH
41104: LD_INT 3
41106: NEG
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: LD_INT 3
41114: NEG
41115: PUSH
41116: LD_INT 2
41118: NEG
41119: PUSH
41120: EMPTY
41121: LIST
41122: LIST
41123: PUSH
41124: LD_INT 3
41126: NEG
41127: PUSH
41128: LD_INT 3
41130: NEG
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41141: LD_ADDR_VAR 0 17
41145: PUSH
41146: LD_INT 1
41148: NEG
41149: PUSH
41150: LD_INT 3
41152: NEG
41153: PUSH
41154: EMPTY
41155: LIST
41156: LIST
41157: PUSH
41158: LD_INT 0
41160: PUSH
41161: LD_INT 3
41163: NEG
41164: PUSH
41165: EMPTY
41166: LIST
41167: LIST
41168: PUSH
41169: LD_INT 1
41171: PUSH
41172: LD_INT 2
41174: NEG
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: LIST
41184: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41185: LD_ADDR_VAR 0 18
41189: PUSH
41190: LD_INT 2
41192: PUSH
41193: LD_INT 1
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: LD_INT 3
41203: PUSH
41204: LD_INT 0
41206: PUSH
41207: EMPTY
41208: LIST
41209: LIST
41210: PUSH
41211: LD_INT 3
41213: PUSH
41214: LD_INT 1
41216: PUSH
41217: EMPTY
41218: LIST
41219: LIST
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: LIST
41225: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41226: LD_ADDR_VAR 0 19
41230: PUSH
41231: LD_INT 3
41233: PUSH
41234: LD_INT 2
41236: PUSH
41237: EMPTY
41238: LIST
41239: LIST
41240: PUSH
41241: LD_INT 3
41243: PUSH
41244: LD_INT 3
41246: PUSH
41247: EMPTY
41248: LIST
41249: LIST
41250: PUSH
41251: LD_INT 2
41253: PUSH
41254: LD_INT 3
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41266: LD_ADDR_VAR 0 20
41270: PUSH
41271: LD_INT 1
41273: PUSH
41274: LD_INT 3
41276: PUSH
41277: EMPTY
41278: LIST
41279: LIST
41280: PUSH
41281: LD_INT 0
41283: PUSH
41284: LD_INT 3
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: LD_INT 2
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41307: LD_ADDR_VAR 0 21
41311: PUSH
41312: LD_INT 2
41314: NEG
41315: PUSH
41316: LD_INT 1
41318: PUSH
41319: EMPTY
41320: LIST
41321: LIST
41322: PUSH
41323: LD_INT 3
41325: NEG
41326: PUSH
41327: LD_INT 0
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 3
41336: NEG
41337: PUSH
41338: LD_INT 1
41340: NEG
41341: PUSH
41342: EMPTY
41343: LIST
41344: LIST
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: LIST
41350: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41351: LD_ADDR_VAR 0 22
41355: PUSH
41356: LD_INT 2
41358: NEG
41359: PUSH
41360: LD_INT 3
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 3
41370: NEG
41371: PUSH
41372: LD_INT 2
41374: NEG
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 3
41382: NEG
41383: PUSH
41384: LD_INT 3
41386: NEG
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: PUSH
41392: EMPTY
41393: LIST
41394: LIST
41395: LIST
41396: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41397: LD_ADDR_VAR 0 23
41401: PUSH
41402: LD_INT 0
41404: PUSH
41405: LD_INT 3
41407: NEG
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 1
41415: NEG
41416: PUSH
41417: LD_INT 4
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: LD_INT 1
41427: PUSH
41428: LD_INT 3
41430: NEG
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: LIST
41440: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41441: LD_ADDR_VAR 0 24
41445: PUSH
41446: LD_INT 3
41448: PUSH
41449: LD_INT 0
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 3
41458: PUSH
41459: LD_INT 1
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 4
41469: PUSH
41470: LD_INT 1
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: LIST
41481: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41482: LD_ADDR_VAR 0 25
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 3
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: LD_INT 4
41499: PUSH
41500: LD_INT 3
41502: PUSH
41503: EMPTY
41504: LIST
41505: LIST
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: LD_INT 4
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: LIST
41521: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41522: LD_ADDR_VAR 0 26
41526: PUSH
41527: LD_INT 0
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: LD_INT 1
41539: PUSH
41540: LD_INT 4
41542: PUSH
41543: EMPTY
41544: LIST
41545: LIST
41546: PUSH
41547: LD_INT 1
41549: NEG
41550: PUSH
41551: LD_INT 3
41553: PUSH
41554: EMPTY
41555: LIST
41556: LIST
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: LIST
41562: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41563: LD_ADDR_VAR 0 27
41567: PUSH
41568: LD_INT 3
41570: NEG
41571: PUSH
41572: LD_INT 0
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 3
41581: NEG
41582: PUSH
41583: LD_INT 1
41585: PUSH
41586: EMPTY
41587: LIST
41588: LIST
41589: PUSH
41590: LD_INT 4
41592: NEG
41593: PUSH
41594: LD_INT 1
41596: NEG
41597: PUSH
41598: EMPTY
41599: LIST
41600: LIST
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: LIST
41606: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41607: LD_ADDR_VAR 0 28
41611: PUSH
41612: LD_INT 3
41614: NEG
41615: PUSH
41616: LD_INT 3
41618: NEG
41619: PUSH
41620: EMPTY
41621: LIST
41622: LIST
41623: PUSH
41624: LD_INT 3
41626: NEG
41627: PUSH
41628: LD_INT 4
41630: NEG
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 4
41638: NEG
41639: PUSH
41640: LD_INT 3
41642: NEG
41643: PUSH
41644: EMPTY
41645: LIST
41646: LIST
41647: PUSH
41648: EMPTY
41649: LIST
41650: LIST
41651: LIST
41652: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41653: LD_ADDR_VAR 0 29
41657: PUSH
41658: LD_INT 1
41660: NEG
41661: PUSH
41662: LD_INT 3
41664: NEG
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: PUSH
41670: LD_INT 0
41672: PUSH
41673: LD_INT 3
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 1
41683: PUSH
41684: LD_INT 2
41686: NEG
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: LD_INT 1
41694: NEG
41695: PUSH
41696: LD_INT 4
41698: NEG
41699: PUSH
41700: EMPTY
41701: LIST
41702: LIST
41703: PUSH
41704: LD_INT 0
41706: PUSH
41707: LD_INT 4
41709: NEG
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 1
41717: PUSH
41718: LD_INT 3
41720: NEG
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: LD_INT 1
41728: NEG
41729: PUSH
41730: LD_INT 5
41732: NEG
41733: PUSH
41734: EMPTY
41735: LIST
41736: LIST
41737: PUSH
41738: LD_INT 0
41740: PUSH
41741: LD_INT 5
41743: NEG
41744: PUSH
41745: EMPTY
41746: LIST
41747: LIST
41748: PUSH
41749: LD_INT 1
41751: PUSH
41752: LD_INT 4
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 1
41762: NEG
41763: PUSH
41764: LD_INT 6
41766: NEG
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 0
41774: PUSH
41775: LD_INT 6
41777: NEG
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: LD_INT 5
41788: NEG
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: LIST
41798: LIST
41799: LIST
41800: LIST
41801: LIST
41802: LIST
41803: LIST
41804: LIST
41805: LIST
41806: LIST
41807: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41808: LD_ADDR_VAR 0 30
41812: PUSH
41813: LD_INT 2
41815: PUSH
41816: LD_INT 1
41818: NEG
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 3
41826: PUSH
41827: LD_INT 0
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 3
41836: PUSH
41837: LD_INT 1
41839: PUSH
41840: EMPTY
41841: LIST
41842: LIST
41843: PUSH
41844: LD_INT 3
41846: PUSH
41847: LD_INT 1
41849: NEG
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 4
41857: PUSH
41858: LD_INT 0
41860: PUSH
41861: EMPTY
41862: LIST
41863: LIST
41864: PUSH
41865: LD_INT 4
41867: PUSH
41868: LD_INT 1
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 4
41877: PUSH
41878: LD_INT 1
41880: NEG
41881: PUSH
41882: EMPTY
41883: LIST
41884: LIST
41885: PUSH
41886: LD_INT 5
41888: PUSH
41889: LD_INT 0
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 5
41898: PUSH
41899: LD_INT 1
41901: PUSH
41902: EMPTY
41903: LIST
41904: LIST
41905: PUSH
41906: LD_INT 5
41908: PUSH
41909: LD_INT 1
41911: NEG
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: PUSH
41917: LD_INT 6
41919: PUSH
41920: LD_INT 0
41922: PUSH
41923: EMPTY
41924: LIST
41925: LIST
41926: PUSH
41927: LD_INT 6
41929: PUSH
41930: LD_INT 1
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: LIST
41941: LIST
41942: LIST
41943: LIST
41944: LIST
41945: LIST
41946: LIST
41947: LIST
41948: LIST
41949: LIST
41950: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41951: LD_ADDR_VAR 0 31
41955: PUSH
41956: LD_INT 3
41958: PUSH
41959: LD_INT 2
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 3
41968: PUSH
41969: LD_INT 3
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 2
41978: PUSH
41979: LD_INT 3
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 4
41998: PUSH
41999: LD_INT 4
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 3
42008: PUSH
42009: LD_INT 4
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 5
42018: PUSH
42019: LD_INT 4
42021: PUSH
42022: EMPTY
42023: LIST
42024: LIST
42025: PUSH
42026: LD_INT 5
42028: PUSH
42029: LD_INT 5
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 4
42038: PUSH
42039: LD_INT 5
42041: PUSH
42042: EMPTY
42043: LIST
42044: LIST
42045: PUSH
42046: LD_INT 6
42048: PUSH
42049: LD_INT 5
42051: PUSH
42052: EMPTY
42053: LIST
42054: LIST
42055: PUSH
42056: LD_INT 6
42058: PUSH
42059: LD_INT 6
42061: PUSH
42062: EMPTY
42063: LIST
42064: LIST
42065: PUSH
42066: LD_INT 5
42068: PUSH
42069: LD_INT 6
42071: PUSH
42072: EMPTY
42073: LIST
42074: LIST
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: LIST
42080: LIST
42081: LIST
42082: LIST
42083: LIST
42084: LIST
42085: LIST
42086: LIST
42087: LIST
42088: LIST
42089: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42090: LD_ADDR_VAR 0 32
42094: PUSH
42095: LD_INT 1
42097: PUSH
42098: LD_INT 3
42100: PUSH
42101: EMPTY
42102: LIST
42103: LIST
42104: PUSH
42105: LD_INT 0
42107: PUSH
42108: LD_INT 3
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 1
42117: NEG
42118: PUSH
42119: LD_INT 2
42121: PUSH
42122: EMPTY
42123: LIST
42124: LIST
42125: PUSH
42126: LD_INT 1
42128: PUSH
42129: LD_INT 4
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 0
42138: PUSH
42139: LD_INT 4
42141: PUSH
42142: EMPTY
42143: LIST
42144: LIST
42145: PUSH
42146: LD_INT 1
42148: NEG
42149: PUSH
42150: LD_INT 3
42152: PUSH
42153: EMPTY
42154: LIST
42155: LIST
42156: PUSH
42157: LD_INT 1
42159: PUSH
42160: LD_INT 5
42162: PUSH
42163: EMPTY
42164: LIST
42165: LIST
42166: PUSH
42167: LD_INT 0
42169: PUSH
42170: LD_INT 5
42172: PUSH
42173: EMPTY
42174: LIST
42175: LIST
42176: PUSH
42177: LD_INT 1
42179: NEG
42180: PUSH
42181: LD_INT 4
42183: PUSH
42184: EMPTY
42185: LIST
42186: LIST
42187: PUSH
42188: LD_INT 1
42190: PUSH
42191: LD_INT 6
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 0
42200: PUSH
42201: LD_INT 6
42203: PUSH
42204: EMPTY
42205: LIST
42206: LIST
42207: PUSH
42208: LD_INT 1
42210: NEG
42211: PUSH
42212: LD_INT 5
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42233: LD_ADDR_VAR 0 33
42237: PUSH
42238: LD_INT 2
42240: NEG
42241: PUSH
42242: LD_INT 1
42244: PUSH
42245: EMPTY
42246: LIST
42247: LIST
42248: PUSH
42249: LD_INT 3
42251: NEG
42252: PUSH
42253: LD_INT 0
42255: PUSH
42256: EMPTY
42257: LIST
42258: LIST
42259: PUSH
42260: LD_INT 3
42262: NEG
42263: PUSH
42264: LD_INT 1
42266: NEG
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 3
42274: NEG
42275: PUSH
42276: LD_INT 1
42278: PUSH
42279: EMPTY
42280: LIST
42281: LIST
42282: PUSH
42283: LD_INT 4
42285: NEG
42286: PUSH
42287: LD_INT 0
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 4
42296: NEG
42297: PUSH
42298: LD_INT 1
42300: NEG
42301: PUSH
42302: EMPTY
42303: LIST
42304: LIST
42305: PUSH
42306: LD_INT 4
42308: NEG
42309: PUSH
42310: LD_INT 1
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 5
42319: NEG
42320: PUSH
42321: LD_INT 0
42323: PUSH
42324: EMPTY
42325: LIST
42326: LIST
42327: PUSH
42328: LD_INT 5
42330: NEG
42331: PUSH
42332: LD_INT 1
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 5
42342: NEG
42343: PUSH
42344: LD_INT 1
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 6
42353: NEG
42354: PUSH
42355: LD_INT 0
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 6
42364: NEG
42365: PUSH
42366: LD_INT 1
42368: NEG
42369: PUSH
42370: EMPTY
42371: LIST
42372: LIST
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: LIST
42382: LIST
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42388: LD_ADDR_VAR 0 34
42392: PUSH
42393: LD_INT 2
42395: NEG
42396: PUSH
42397: LD_INT 3
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 3
42407: NEG
42408: PUSH
42409: LD_INT 2
42411: NEG
42412: PUSH
42413: EMPTY
42414: LIST
42415: LIST
42416: PUSH
42417: LD_INT 3
42419: NEG
42420: PUSH
42421: LD_INT 3
42423: NEG
42424: PUSH
42425: EMPTY
42426: LIST
42427: LIST
42428: PUSH
42429: LD_INT 3
42431: NEG
42432: PUSH
42433: LD_INT 4
42435: NEG
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 4
42443: NEG
42444: PUSH
42445: LD_INT 3
42447: NEG
42448: PUSH
42449: EMPTY
42450: LIST
42451: LIST
42452: PUSH
42453: LD_INT 4
42455: NEG
42456: PUSH
42457: LD_INT 4
42459: NEG
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 4
42467: NEG
42468: PUSH
42469: LD_INT 5
42471: NEG
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PUSH
42477: LD_INT 5
42479: NEG
42480: PUSH
42481: LD_INT 4
42483: NEG
42484: PUSH
42485: EMPTY
42486: LIST
42487: LIST
42488: PUSH
42489: LD_INT 5
42491: NEG
42492: PUSH
42493: LD_INT 5
42495: NEG
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 5
42503: NEG
42504: PUSH
42505: LD_INT 6
42507: NEG
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 6
42515: NEG
42516: PUSH
42517: LD_INT 5
42519: NEG
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 6
42527: NEG
42528: PUSH
42529: LD_INT 6
42531: NEG
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PUSH
42537: EMPTY
42538: LIST
42539: LIST
42540: LIST
42541: LIST
42542: LIST
42543: LIST
42544: LIST
42545: LIST
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42551: LD_ADDR_VAR 0 41
42555: PUSH
42556: LD_INT 0
42558: PUSH
42559: LD_INT 2
42561: NEG
42562: PUSH
42563: EMPTY
42564: LIST
42565: LIST
42566: PUSH
42567: LD_INT 1
42569: NEG
42570: PUSH
42571: LD_INT 3
42573: NEG
42574: PUSH
42575: EMPTY
42576: LIST
42577: LIST
42578: PUSH
42579: LD_INT 1
42581: PUSH
42582: LD_INT 2
42584: NEG
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PUSH
42590: EMPTY
42591: LIST
42592: LIST
42593: LIST
42594: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42595: LD_ADDR_VAR 0 42
42599: PUSH
42600: LD_INT 2
42602: PUSH
42603: LD_INT 0
42605: PUSH
42606: EMPTY
42607: LIST
42608: LIST
42609: PUSH
42610: LD_INT 2
42612: PUSH
42613: LD_INT 1
42615: NEG
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 3
42623: PUSH
42624: LD_INT 1
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: LIST
42635: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42636: LD_ADDR_VAR 0 43
42640: PUSH
42641: LD_INT 2
42643: PUSH
42644: LD_INT 2
42646: PUSH
42647: EMPTY
42648: LIST
42649: LIST
42650: PUSH
42651: LD_INT 3
42653: PUSH
42654: LD_INT 2
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 2
42663: PUSH
42664: LD_INT 3
42666: PUSH
42667: EMPTY
42668: LIST
42669: LIST
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: LIST
42675: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42676: LD_ADDR_VAR 0 44
42680: PUSH
42681: LD_INT 0
42683: PUSH
42684: LD_INT 2
42686: PUSH
42687: EMPTY
42688: LIST
42689: LIST
42690: PUSH
42691: LD_INT 1
42693: PUSH
42694: LD_INT 3
42696: PUSH
42697: EMPTY
42698: LIST
42699: LIST
42700: PUSH
42701: LD_INT 1
42703: NEG
42704: PUSH
42705: LD_INT 2
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: LIST
42716: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42717: LD_ADDR_VAR 0 45
42721: PUSH
42722: LD_INT 2
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 2
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 3
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: NEG
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: LIST
42760: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42761: LD_ADDR_VAR 0 46
42765: PUSH
42766: LD_INT 2
42768: NEG
42769: PUSH
42770: LD_INT 2
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 2
42780: NEG
42781: PUSH
42782: LD_INT 3
42784: NEG
42785: PUSH
42786: EMPTY
42787: LIST
42788: LIST
42789: PUSH
42790: LD_INT 3
42792: NEG
42793: PUSH
42794: LD_INT 2
42796: NEG
42797: PUSH
42798: EMPTY
42799: LIST
42800: LIST
42801: PUSH
42802: EMPTY
42803: LIST
42804: LIST
42805: LIST
42806: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42807: LD_ADDR_VAR 0 47
42811: PUSH
42812: LD_INT 2
42814: NEG
42815: PUSH
42816: LD_INT 3
42818: NEG
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 1
42826: NEG
42827: PUSH
42828: LD_INT 3
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42840: LD_ADDR_VAR 0 48
42844: PUSH
42845: LD_INT 1
42847: PUSH
42848: LD_INT 2
42850: NEG
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 2
42858: PUSH
42859: LD_INT 1
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: EMPTY
42868: LIST
42869: LIST
42870: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42871: LD_ADDR_VAR 0 49
42875: PUSH
42876: LD_INT 3
42878: PUSH
42879: LD_INT 1
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: LD_INT 3
42888: PUSH
42889: LD_INT 2
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42900: LD_ADDR_VAR 0 50
42904: PUSH
42905: LD_INT 2
42907: PUSH
42908: LD_INT 3
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 1
42917: PUSH
42918: LD_INT 3
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42929: LD_ADDR_VAR 0 51
42933: PUSH
42934: LD_INT 1
42936: NEG
42937: PUSH
42938: LD_INT 2
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: NEG
42948: PUSH
42949: LD_INT 1
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42960: LD_ADDR_VAR 0 52
42964: PUSH
42965: LD_INT 3
42967: NEG
42968: PUSH
42969: LD_INT 1
42971: NEG
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: PUSH
42977: LD_INT 3
42979: NEG
42980: PUSH
42981: LD_INT 2
42983: NEG
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42993: LD_ADDR_VAR 0 53
42997: PUSH
42998: LD_INT 1
43000: NEG
43001: PUSH
43002: LD_INT 3
43004: NEG
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: PUSH
43010: LD_INT 0
43012: PUSH
43013: LD_INT 3
43015: NEG
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: PUSH
43021: LD_INT 1
43023: PUSH
43024: LD_INT 2
43026: NEG
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: LIST
43036: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43037: LD_ADDR_VAR 0 54
43041: PUSH
43042: LD_INT 2
43044: PUSH
43045: LD_INT 1
43047: NEG
43048: PUSH
43049: EMPTY
43050: LIST
43051: LIST
43052: PUSH
43053: LD_INT 3
43055: PUSH
43056: LD_INT 0
43058: PUSH
43059: EMPTY
43060: LIST
43061: LIST
43062: PUSH
43063: LD_INT 3
43065: PUSH
43066: LD_INT 1
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: LIST
43077: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43078: LD_ADDR_VAR 0 55
43082: PUSH
43083: LD_INT 3
43085: PUSH
43086: LD_INT 2
43088: PUSH
43089: EMPTY
43090: LIST
43091: LIST
43092: PUSH
43093: LD_INT 3
43095: PUSH
43096: LD_INT 3
43098: PUSH
43099: EMPTY
43100: LIST
43101: LIST
43102: PUSH
43103: LD_INT 2
43105: PUSH
43106: LD_INT 3
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: EMPTY
43114: LIST
43115: LIST
43116: LIST
43117: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43118: LD_ADDR_VAR 0 56
43122: PUSH
43123: LD_INT 1
43125: PUSH
43126: LD_INT 3
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 0
43135: PUSH
43136: LD_INT 3
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 1
43145: NEG
43146: PUSH
43147: LD_INT 2
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: LIST
43158: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43159: LD_ADDR_VAR 0 57
43163: PUSH
43164: LD_INT 2
43166: NEG
43167: PUSH
43168: LD_INT 1
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: LD_INT 3
43177: NEG
43178: PUSH
43179: LD_INT 0
43181: PUSH
43182: EMPTY
43183: LIST
43184: LIST
43185: PUSH
43186: LD_INT 3
43188: NEG
43189: PUSH
43190: LD_INT 1
43192: NEG
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: LIST
43202: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43203: LD_ADDR_VAR 0 58
43207: PUSH
43208: LD_INT 2
43210: NEG
43211: PUSH
43212: LD_INT 3
43214: NEG
43215: PUSH
43216: EMPTY
43217: LIST
43218: LIST
43219: PUSH
43220: LD_INT 3
43222: NEG
43223: PUSH
43224: LD_INT 2
43226: NEG
43227: PUSH
43228: EMPTY
43229: LIST
43230: LIST
43231: PUSH
43232: LD_INT 3
43234: NEG
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: LIST
43248: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43249: LD_ADDR_VAR 0 59
43253: PUSH
43254: LD_INT 1
43256: NEG
43257: PUSH
43258: LD_INT 2
43260: NEG
43261: PUSH
43262: EMPTY
43263: LIST
43264: LIST
43265: PUSH
43266: LD_INT 0
43268: PUSH
43269: LD_INT 2
43271: NEG
43272: PUSH
43273: EMPTY
43274: LIST
43275: LIST
43276: PUSH
43277: LD_INT 1
43279: PUSH
43280: LD_INT 1
43282: NEG
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: LIST
43292: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43293: LD_ADDR_VAR 0 60
43297: PUSH
43298: LD_INT 1
43300: PUSH
43301: LD_INT 1
43303: NEG
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 2
43311: PUSH
43312: LD_INT 0
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 2
43321: PUSH
43322: LD_INT 1
43324: PUSH
43325: EMPTY
43326: LIST
43327: LIST
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: LIST
43333: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43334: LD_ADDR_VAR 0 61
43338: PUSH
43339: LD_INT 2
43341: PUSH
43342: LD_INT 1
43344: PUSH
43345: EMPTY
43346: LIST
43347: LIST
43348: PUSH
43349: LD_INT 2
43351: PUSH
43352: LD_INT 2
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: PUSH
43359: LD_INT 1
43361: PUSH
43362: LD_INT 2
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: LIST
43373: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43374: LD_ADDR_VAR 0 62
43378: PUSH
43379: LD_INT 1
43381: PUSH
43382: LD_INT 2
43384: PUSH
43385: EMPTY
43386: LIST
43387: LIST
43388: PUSH
43389: LD_INT 0
43391: PUSH
43392: LD_INT 2
43394: PUSH
43395: EMPTY
43396: LIST
43397: LIST
43398: PUSH
43399: LD_INT 1
43401: NEG
43402: PUSH
43403: LD_INT 1
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: LIST
43414: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43415: LD_ADDR_VAR 0 63
43419: PUSH
43420: LD_INT 1
43422: NEG
43423: PUSH
43424: LD_INT 1
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 2
43433: NEG
43434: PUSH
43435: LD_INT 0
43437: PUSH
43438: EMPTY
43439: LIST
43440: LIST
43441: PUSH
43442: LD_INT 2
43444: NEG
43445: PUSH
43446: LD_INT 1
43448: NEG
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: LIST
43458: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43459: LD_ADDR_VAR 0 64
43463: PUSH
43464: LD_INT 1
43466: NEG
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 2
43478: NEG
43479: PUSH
43480: LD_INT 1
43482: NEG
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: PUSH
43488: LD_INT 2
43490: NEG
43491: PUSH
43492: LD_INT 2
43494: NEG
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: EMPTY
43501: LIST
43502: LIST
43503: LIST
43504: ST_TO_ADDR
// end ; 2 :
43505: GO 46771
43507: LD_INT 2
43509: DOUBLE
43510: EQUAL
43511: IFTRUE 43515
43513: GO 46770
43515: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43516: LD_ADDR_VAR 0 29
43520: PUSH
43521: LD_INT 4
43523: PUSH
43524: LD_INT 0
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 4
43533: PUSH
43534: LD_INT 1
43536: NEG
43537: PUSH
43538: EMPTY
43539: LIST
43540: LIST
43541: PUSH
43542: LD_INT 5
43544: PUSH
43545: LD_INT 0
43547: PUSH
43548: EMPTY
43549: LIST
43550: LIST
43551: PUSH
43552: LD_INT 5
43554: PUSH
43555: LD_INT 1
43557: PUSH
43558: EMPTY
43559: LIST
43560: LIST
43561: PUSH
43562: LD_INT 4
43564: PUSH
43565: LD_INT 1
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PUSH
43572: LD_INT 3
43574: PUSH
43575: LD_INT 0
43577: PUSH
43578: EMPTY
43579: LIST
43580: LIST
43581: PUSH
43582: LD_INT 3
43584: PUSH
43585: LD_INT 1
43587: NEG
43588: PUSH
43589: EMPTY
43590: LIST
43591: LIST
43592: PUSH
43593: LD_INT 3
43595: PUSH
43596: LD_INT 2
43598: NEG
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 5
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: PUSH
43617: LD_INT 3
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 3
43626: PUSH
43627: LD_INT 2
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 4
43636: PUSH
43637: LD_INT 3
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 4
43646: PUSH
43647: LD_INT 4
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 3
43656: PUSH
43657: LD_INT 4
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: LD_INT 3
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: LD_INT 2
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 4
43686: PUSH
43687: LD_INT 2
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 2
43696: PUSH
43697: LD_INT 4
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 4
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 0
43716: PUSH
43717: LD_INT 3
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 1
43726: PUSH
43727: LD_INT 4
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 1
43736: PUSH
43737: LD_INT 5
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 0
43746: PUSH
43747: LD_INT 5
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 1
43756: NEG
43757: PUSH
43758: LD_INT 4
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 1
43767: NEG
43768: PUSH
43769: LD_INT 3
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 2
43778: PUSH
43779: LD_INT 5
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 2
43788: NEG
43789: PUSH
43790: LD_INT 3
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 3
43799: NEG
43800: PUSH
43801: LD_INT 0
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 3
43810: NEG
43811: PUSH
43812: LD_INT 1
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 2
43822: NEG
43823: PUSH
43824: LD_INT 0
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 2
43833: NEG
43834: PUSH
43835: LD_INT 1
43837: PUSH
43838: EMPTY
43839: LIST
43840: LIST
43841: PUSH
43842: LD_INT 3
43844: NEG
43845: PUSH
43846: LD_INT 1
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 4
43855: NEG
43856: PUSH
43857: LD_INT 0
43859: PUSH
43860: EMPTY
43861: LIST
43862: LIST
43863: PUSH
43864: LD_INT 4
43866: NEG
43867: PUSH
43868: LD_INT 1
43870: NEG
43871: PUSH
43872: EMPTY
43873: LIST
43874: LIST
43875: PUSH
43876: LD_INT 4
43878: NEG
43879: PUSH
43880: LD_INT 2
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 2
43890: NEG
43891: PUSH
43892: LD_INT 2
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 4
43901: NEG
43902: PUSH
43903: LD_INT 4
43905: NEG
43906: PUSH
43907: EMPTY
43908: LIST
43909: LIST
43910: PUSH
43911: LD_INT 4
43913: NEG
43914: PUSH
43915: LD_INT 5
43917: NEG
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 3
43925: NEG
43926: PUSH
43927: LD_INT 4
43929: NEG
43930: PUSH
43931: EMPTY
43932: LIST
43933: LIST
43934: PUSH
43935: LD_INT 3
43937: NEG
43938: PUSH
43939: LD_INT 3
43941: NEG
43942: PUSH
43943: EMPTY
43944: LIST
43945: LIST
43946: PUSH
43947: LD_INT 4
43949: NEG
43950: PUSH
43951: LD_INT 3
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 5
43961: NEG
43962: PUSH
43963: LD_INT 4
43965: NEG
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 5
43973: NEG
43974: PUSH
43975: LD_INT 5
43977: NEG
43978: PUSH
43979: EMPTY
43980: LIST
43981: LIST
43982: PUSH
43983: LD_INT 3
43985: NEG
43986: PUSH
43987: LD_INT 5
43989: NEG
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 5
43997: NEG
43998: PUSH
43999: LD_INT 3
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: LIST
44011: LIST
44012: LIST
44013: LIST
44014: LIST
44015: LIST
44016: LIST
44017: LIST
44018: LIST
44019: LIST
44020: LIST
44021: LIST
44022: LIST
44023: LIST
44024: LIST
44025: LIST
44026: LIST
44027: LIST
44028: LIST
44029: LIST
44030: LIST
44031: LIST
44032: LIST
44033: LIST
44034: LIST
44035: LIST
44036: LIST
44037: LIST
44038: LIST
44039: LIST
44040: LIST
44041: LIST
44042: LIST
44043: LIST
44044: LIST
44045: LIST
44046: LIST
44047: LIST
44048: LIST
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44054: LD_ADDR_VAR 0 30
44058: PUSH
44059: LD_INT 4
44061: PUSH
44062: LD_INT 4
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 4
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 5
44081: PUSH
44082: LD_INT 4
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 5
44091: PUSH
44092: LD_INT 5
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 4
44101: PUSH
44102: LD_INT 5
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 3
44111: PUSH
44112: LD_INT 4
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 3
44121: PUSH
44122: LD_INT 3
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 5
44131: PUSH
44132: LD_INT 3
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 3
44141: PUSH
44142: LD_INT 5
44144: PUSH
44145: EMPTY
44146: LIST
44147: LIST
44148: PUSH
44149: LD_INT 0
44151: PUSH
44152: LD_INT 3
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 0
44161: PUSH
44162: LD_INT 2
44164: PUSH
44165: EMPTY
44166: LIST
44167: LIST
44168: PUSH
44169: LD_INT 1
44171: PUSH
44172: LD_INT 3
44174: PUSH
44175: EMPTY
44176: LIST
44177: LIST
44178: PUSH
44179: LD_INT 1
44181: PUSH
44182: LD_INT 4
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 0
44191: PUSH
44192: LD_INT 4
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 1
44201: NEG
44202: PUSH
44203: LD_INT 3
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 1
44212: NEG
44213: PUSH
44214: LD_INT 2
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 2
44223: PUSH
44224: LD_INT 4
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 2
44233: NEG
44234: PUSH
44235: LD_INT 2
44237: PUSH
44238: EMPTY
44239: LIST
44240: LIST
44241: PUSH
44242: LD_INT 4
44244: NEG
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: EMPTY
44250: LIST
44251: LIST
44252: PUSH
44253: LD_INT 4
44255: NEG
44256: PUSH
44257: LD_INT 1
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 3
44267: NEG
44268: PUSH
44269: LD_INT 0
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 3
44278: NEG
44279: PUSH
44280: LD_INT 1
44282: PUSH
44283: EMPTY
44284: LIST
44285: LIST
44286: PUSH
44287: LD_INT 4
44289: NEG
44290: PUSH
44291: LD_INT 1
44293: PUSH
44294: EMPTY
44295: LIST
44296: LIST
44297: PUSH
44298: LD_INT 5
44300: NEG
44301: PUSH
44302: LD_INT 0
44304: PUSH
44305: EMPTY
44306: LIST
44307: LIST
44308: PUSH
44309: LD_INT 5
44311: NEG
44312: PUSH
44313: LD_INT 1
44315: NEG
44316: PUSH
44317: EMPTY
44318: LIST
44319: LIST
44320: PUSH
44321: LD_INT 5
44323: NEG
44324: PUSH
44325: LD_INT 2
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 3
44335: NEG
44336: PUSH
44337: LD_INT 2
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 3
44346: NEG
44347: PUSH
44348: LD_INT 3
44350: NEG
44351: PUSH
44352: EMPTY
44353: LIST
44354: LIST
44355: PUSH
44356: LD_INT 3
44358: NEG
44359: PUSH
44360: LD_INT 4
44362: NEG
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 2
44370: NEG
44371: PUSH
44372: LD_INT 3
44374: NEG
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: PUSH
44380: LD_INT 2
44382: NEG
44383: PUSH
44384: LD_INT 2
44386: NEG
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 3
44394: NEG
44395: PUSH
44396: LD_INT 2
44398: NEG
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 4
44406: NEG
44407: PUSH
44408: LD_INT 3
44410: NEG
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 4
44418: NEG
44419: PUSH
44420: LD_INT 4
44422: NEG
44423: PUSH
44424: EMPTY
44425: LIST
44426: LIST
44427: PUSH
44428: LD_INT 2
44430: NEG
44431: PUSH
44432: LD_INT 4
44434: NEG
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 4
44442: NEG
44443: PUSH
44444: LD_INT 2
44446: NEG
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: LD_INT 0
44454: PUSH
44455: LD_INT 4
44457: NEG
44458: PUSH
44459: EMPTY
44460: LIST
44461: LIST
44462: PUSH
44463: LD_INT 0
44465: PUSH
44466: LD_INT 5
44468: NEG
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 1
44476: PUSH
44477: LD_INT 4
44479: NEG
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 1
44487: PUSH
44488: LD_INT 3
44490: NEG
44491: PUSH
44492: EMPTY
44493: LIST
44494: LIST
44495: PUSH
44496: LD_INT 0
44498: PUSH
44499: LD_INT 3
44501: NEG
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 1
44509: NEG
44510: PUSH
44511: LD_INT 4
44513: NEG
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 1
44521: NEG
44522: PUSH
44523: LD_INT 5
44525: NEG
44526: PUSH
44527: EMPTY
44528: LIST
44529: LIST
44530: PUSH
44531: LD_INT 2
44533: PUSH
44534: LD_INT 3
44536: NEG
44537: PUSH
44538: EMPTY
44539: LIST
44540: LIST
44541: PUSH
44542: LD_INT 2
44544: NEG
44545: PUSH
44546: LD_INT 5
44548: NEG
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: LIST
44558: LIST
44559: LIST
44560: LIST
44561: LIST
44562: LIST
44563: LIST
44564: LIST
44565: LIST
44566: LIST
44567: LIST
44568: LIST
44569: LIST
44570: LIST
44571: LIST
44572: LIST
44573: LIST
44574: LIST
44575: LIST
44576: LIST
44577: LIST
44578: LIST
44579: LIST
44580: LIST
44581: LIST
44582: LIST
44583: LIST
44584: LIST
44585: LIST
44586: LIST
44587: LIST
44588: LIST
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44601: LD_ADDR_VAR 0 31
44605: PUSH
44606: LD_INT 0
44608: PUSH
44609: LD_INT 4
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 0
44618: PUSH
44619: LD_INT 3
44621: PUSH
44622: EMPTY
44623: LIST
44624: LIST
44625: PUSH
44626: LD_INT 1
44628: PUSH
44629: LD_INT 4
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 1
44638: PUSH
44639: LD_INT 5
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: LD_INT 5
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 1
44658: NEG
44659: PUSH
44660: LD_INT 4
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 1
44669: NEG
44670: PUSH
44671: LD_INT 3
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 2
44680: PUSH
44681: LD_INT 5
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 2
44690: NEG
44691: PUSH
44692: LD_INT 3
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: LD_INT 0
44705: PUSH
44706: EMPTY
44707: LIST
44708: LIST
44709: PUSH
44710: LD_INT 3
44712: NEG
44713: PUSH
44714: LD_INT 1
44716: NEG
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 2
44724: NEG
44725: PUSH
44726: LD_INT 0
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 2
44735: NEG
44736: PUSH
44737: LD_INT 1
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 3
44746: NEG
44747: PUSH
44748: LD_INT 1
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 4
44757: NEG
44758: PUSH
44759: LD_INT 0
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 4
44768: NEG
44769: PUSH
44770: LD_INT 1
44772: NEG
44773: PUSH
44774: EMPTY
44775: LIST
44776: LIST
44777: PUSH
44778: LD_INT 4
44780: NEG
44781: PUSH
44782: LD_INT 2
44784: NEG
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 2
44792: NEG
44793: PUSH
44794: LD_INT 2
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: LD_INT 4
44803: NEG
44804: PUSH
44805: LD_INT 4
44807: NEG
44808: PUSH
44809: EMPTY
44810: LIST
44811: LIST
44812: PUSH
44813: LD_INT 4
44815: NEG
44816: PUSH
44817: LD_INT 5
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 3
44827: NEG
44828: PUSH
44829: LD_INT 4
44831: NEG
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 3
44839: NEG
44840: PUSH
44841: LD_INT 3
44843: NEG
44844: PUSH
44845: EMPTY
44846: LIST
44847: LIST
44848: PUSH
44849: LD_INT 4
44851: NEG
44852: PUSH
44853: LD_INT 3
44855: NEG
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 5
44863: NEG
44864: PUSH
44865: LD_INT 4
44867: NEG
44868: PUSH
44869: EMPTY
44870: LIST
44871: LIST
44872: PUSH
44873: LD_INT 5
44875: NEG
44876: PUSH
44877: LD_INT 5
44879: NEG
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 3
44887: NEG
44888: PUSH
44889: LD_INT 5
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 5
44899: NEG
44900: PUSH
44901: LD_INT 3
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: LD_INT 0
44911: PUSH
44912: LD_INT 3
44914: NEG
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 0
44922: PUSH
44923: LD_INT 4
44925: NEG
44926: PUSH
44927: EMPTY
44928: LIST
44929: LIST
44930: PUSH
44931: LD_INT 1
44933: PUSH
44934: LD_INT 3
44936: NEG
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 1
44944: PUSH
44945: LD_INT 2
44947: NEG
44948: PUSH
44949: EMPTY
44950: LIST
44951: LIST
44952: PUSH
44953: LD_INT 0
44955: PUSH
44956: LD_INT 2
44958: NEG
44959: PUSH
44960: EMPTY
44961: LIST
44962: LIST
44963: PUSH
44964: LD_INT 1
44966: NEG
44967: PUSH
44968: LD_INT 3
44970: NEG
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: LD_INT 1
44978: NEG
44979: PUSH
44980: LD_INT 4
44982: NEG
44983: PUSH
44984: EMPTY
44985: LIST
44986: LIST
44987: PUSH
44988: LD_INT 2
44990: PUSH
44991: LD_INT 2
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 2
45001: NEG
45002: PUSH
45003: LD_INT 4
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 4
45013: PUSH
45014: LD_INT 0
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PUSH
45021: LD_INT 4
45023: PUSH
45024: LD_INT 1
45026: NEG
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 5
45034: PUSH
45035: LD_INT 0
45037: PUSH
45038: EMPTY
45039: LIST
45040: LIST
45041: PUSH
45042: LD_INT 5
45044: PUSH
45045: LD_INT 1
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 4
45054: PUSH
45055: LD_INT 1
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 3
45064: PUSH
45065: LD_INT 0
45067: PUSH
45068: EMPTY
45069: LIST
45070: LIST
45071: PUSH
45072: LD_INT 3
45074: PUSH
45075: LD_INT 1
45077: NEG
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 3
45085: PUSH
45086: LD_INT 2
45088: NEG
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 5
45096: PUSH
45097: LD_INT 2
45099: PUSH
45100: EMPTY
45101: LIST
45102: LIST
45103: PUSH
45104: EMPTY
45105: LIST
45106: LIST
45107: LIST
45108: LIST
45109: LIST
45110: LIST
45111: LIST
45112: LIST
45113: LIST
45114: LIST
45115: LIST
45116: LIST
45117: LIST
45118: LIST
45119: LIST
45120: LIST
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45151: LD_ADDR_VAR 0 32
45155: PUSH
45156: LD_INT 4
45158: NEG
45159: PUSH
45160: LD_INT 0
45162: PUSH
45163: EMPTY
45164: LIST
45165: LIST
45166: PUSH
45167: LD_INT 4
45169: NEG
45170: PUSH
45171: LD_INT 1
45173: NEG
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 3
45181: NEG
45182: PUSH
45183: LD_INT 0
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 3
45192: NEG
45193: PUSH
45194: LD_INT 1
45196: PUSH
45197: EMPTY
45198: LIST
45199: LIST
45200: PUSH
45201: LD_INT 4
45203: NEG
45204: PUSH
45205: LD_INT 1
45207: PUSH
45208: EMPTY
45209: LIST
45210: LIST
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: LD_INT 0
45218: PUSH
45219: EMPTY
45220: LIST
45221: LIST
45222: PUSH
45223: LD_INT 5
45225: NEG
45226: PUSH
45227: LD_INT 1
45229: NEG
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: PUSH
45235: LD_INT 5
45237: NEG
45238: PUSH
45239: LD_INT 2
45241: NEG
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 3
45249: NEG
45250: PUSH
45251: LD_INT 2
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: LD_INT 3
45260: NEG
45261: PUSH
45262: LD_INT 3
45264: NEG
45265: PUSH
45266: EMPTY
45267: LIST
45268: LIST
45269: PUSH
45270: LD_INT 3
45272: NEG
45273: PUSH
45274: LD_INT 4
45276: NEG
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 2
45284: NEG
45285: PUSH
45286: LD_INT 3
45288: NEG
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: LD_INT 2
45296: NEG
45297: PUSH
45298: LD_INT 2
45300: NEG
45301: PUSH
45302: EMPTY
45303: LIST
45304: LIST
45305: PUSH
45306: LD_INT 3
45308: NEG
45309: PUSH
45310: LD_INT 2
45312: NEG
45313: PUSH
45314: EMPTY
45315: LIST
45316: LIST
45317: PUSH
45318: LD_INT 4
45320: NEG
45321: PUSH
45322: LD_INT 3
45324: NEG
45325: PUSH
45326: EMPTY
45327: LIST
45328: LIST
45329: PUSH
45330: LD_INT 4
45332: NEG
45333: PUSH
45334: LD_INT 4
45336: NEG
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: PUSH
45342: LD_INT 2
45344: NEG
45345: PUSH
45346: LD_INT 4
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 4
45356: NEG
45357: PUSH
45358: LD_INT 2
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 0
45368: PUSH
45369: LD_INT 4
45371: NEG
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 0
45379: PUSH
45380: LD_INT 5
45382: NEG
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 1
45390: PUSH
45391: LD_INT 4
45393: NEG
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 1
45401: PUSH
45402: LD_INT 3
45404: NEG
45405: PUSH
45406: EMPTY
45407: LIST
45408: LIST
45409: PUSH
45410: LD_INT 0
45412: PUSH
45413: LD_INT 3
45415: NEG
45416: PUSH
45417: EMPTY
45418: LIST
45419: LIST
45420: PUSH
45421: LD_INT 1
45423: NEG
45424: PUSH
45425: LD_INT 4
45427: NEG
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 1
45435: NEG
45436: PUSH
45437: LD_INT 5
45439: NEG
45440: PUSH
45441: EMPTY
45442: LIST
45443: LIST
45444: PUSH
45445: LD_INT 2
45447: PUSH
45448: LD_INT 3
45450: NEG
45451: PUSH
45452: EMPTY
45453: LIST
45454: LIST
45455: PUSH
45456: LD_INT 2
45458: NEG
45459: PUSH
45460: LD_INT 5
45462: NEG
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 3
45470: PUSH
45471: LD_INT 0
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: LD_INT 3
45480: PUSH
45481: LD_INT 1
45483: NEG
45484: PUSH
45485: EMPTY
45486: LIST
45487: LIST
45488: PUSH
45489: LD_INT 4
45491: PUSH
45492: LD_INT 0
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 4
45501: PUSH
45502: LD_INT 1
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 3
45511: PUSH
45512: LD_INT 1
45514: PUSH
45515: EMPTY
45516: LIST
45517: LIST
45518: PUSH
45519: LD_INT 2
45521: PUSH
45522: LD_INT 0
45524: PUSH
45525: EMPTY
45526: LIST
45527: LIST
45528: PUSH
45529: LD_INT 2
45531: PUSH
45532: LD_INT 1
45534: NEG
45535: PUSH
45536: EMPTY
45537: LIST
45538: LIST
45539: PUSH
45540: LD_INT 2
45542: PUSH
45543: LD_INT 2
45545: NEG
45546: PUSH
45547: EMPTY
45548: LIST
45549: LIST
45550: PUSH
45551: LD_INT 4
45553: PUSH
45554: LD_INT 2
45556: PUSH
45557: EMPTY
45558: LIST
45559: LIST
45560: PUSH
45561: LD_INT 4
45563: PUSH
45564: LD_INT 4
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: LD_INT 4
45573: PUSH
45574: LD_INT 3
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 5
45583: PUSH
45584: LD_INT 4
45586: PUSH
45587: EMPTY
45588: LIST
45589: LIST
45590: PUSH
45591: LD_INT 5
45593: PUSH
45594: LD_INT 5
45596: PUSH
45597: EMPTY
45598: LIST
45599: LIST
45600: PUSH
45601: LD_INT 4
45603: PUSH
45604: LD_INT 5
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 3
45613: PUSH
45614: LD_INT 4
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PUSH
45621: LD_INT 3
45623: PUSH
45624: LD_INT 3
45626: PUSH
45627: EMPTY
45628: LIST
45629: LIST
45630: PUSH
45631: LD_INT 5
45633: PUSH
45634: LD_INT 3
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 3
45643: PUSH
45644: LD_INT 5
45646: PUSH
45647: EMPTY
45648: LIST
45649: LIST
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: LIST
45655: LIST
45656: LIST
45657: LIST
45658: LIST
45659: LIST
45660: LIST
45661: LIST
45662: LIST
45663: LIST
45664: LIST
45665: LIST
45666: LIST
45667: LIST
45668: LIST
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: LIST
45678: LIST
45679: LIST
45680: LIST
45681: LIST
45682: LIST
45683: LIST
45684: LIST
45685: LIST
45686: LIST
45687: LIST
45688: LIST
45689: LIST
45690: LIST
45691: LIST
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: LIST
45697: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45698: LD_ADDR_VAR 0 33
45702: PUSH
45703: LD_INT 4
45705: NEG
45706: PUSH
45707: LD_INT 4
45709: NEG
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 4
45717: NEG
45718: PUSH
45719: LD_INT 5
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 3
45729: NEG
45730: PUSH
45731: LD_INT 4
45733: NEG
45734: PUSH
45735: EMPTY
45736: LIST
45737: LIST
45738: PUSH
45739: LD_INT 3
45741: NEG
45742: PUSH
45743: LD_INT 3
45745: NEG
45746: PUSH
45747: EMPTY
45748: LIST
45749: LIST
45750: PUSH
45751: LD_INT 4
45753: NEG
45754: PUSH
45755: LD_INT 3
45757: NEG
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: PUSH
45763: LD_INT 5
45765: NEG
45766: PUSH
45767: LD_INT 4
45769: NEG
45770: PUSH
45771: EMPTY
45772: LIST
45773: LIST
45774: PUSH
45775: LD_INT 5
45777: NEG
45778: PUSH
45779: LD_INT 5
45781: NEG
45782: PUSH
45783: EMPTY
45784: LIST
45785: LIST
45786: PUSH
45787: LD_INT 3
45789: NEG
45790: PUSH
45791: LD_INT 5
45793: NEG
45794: PUSH
45795: EMPTY
45796: LIST
45797: LIST
45798: PUSH
45799: LD_INT 5
45801: NEG
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 0
45813: PUSH
45814: LD_INT 3
45816: NEG
45817: PUSH
45818: EMPTY
45819: LIST
45820: LIST
45821: PUSH
45822: LD_INT 0
45824: PUSH
45825: LD_INT 4
45827: NEG
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 1
45835: PUSH
45836: LD_INT 3
45838: NEG
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 1
45846: PUSH
45847: LD_INT 2
45849: NEG
45850: PUSH
45851: EMPTY
45852: LIST
45853: LIST
45854: PUSH
45855: LD_INT 0
45857: PUSH
45858: LD_INT 2
45860: NEG
45861: PUSH
45862: EMPTY
45863: LIST
45864: LIST
45865: PUSH
45866: LD_INT 1
45868: NEG
45869: PUSH
45870: LD_INT 3
45872: NEG
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 1
45880: NEG
45881: PUSH
45882: LD_INT 4
45884: NEG
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: PUSH
45890: LD_INT 2
45892: PUSH
45893: LD_INT 2
45895: NEG
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 2
45903: NEG
45904: PUSH
45905: LD_INT 4
45907: NEG
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PUSH
45913: LD_INT 4
45915: PUSH
45916: LD_INT 0
45918: PUSH
45919: EMPTY
45920: LIST
45921: LIST
45922: PUSH
45923: LD_INT 4
45925: PUSH
45926: LD_INT 1
45928: NEG
45929: PUSH
45930: EMPTY
45931: LIST
45932: LIST
45933: PUSH
45934: LD_INT 5
45936: PUSH
45937: LD_INT 0
45939: PUSH
45940: EMPTY
45941: LIST
45942: LIST
45943: PUSH
45944: LD_INT 5
45946: PUSH
45947: LD_INT 1
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 4
45956: PUSH
45957: LD_INT 1
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: PUSH
45964: LD_INT 3
45966: PUSH
45967: LD_INT 0
45969: PUSH
45970: EMPTY
45971: LIST
45972: LIST
45973: PUSH
45974: LD_INT 3
45976: PUSH
45977: LD_INT 1
45979: NEG
45980: PUSH
45981: EMPTY
45982: LIST
45983: LIST
45984: PUSH
45985: LD_INT 3
45987: PUSH
45988: LD_INT 2
45990: NEG
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 5
45998: PUSH
45999: LD_INT 2
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: LD_INT 3
46008: PUSH
46009: LD_INT 3
46011: PUSH
46012: EMPTY
46013: LIST
46014: LIST
46015: PUSH
46016: LD_INT 3
46018: PUSH
46019: LD_INT 2
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: LD_INT 4
46028: PUSH
46029: LD_INT 3
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: LD_INT 4
46038: PUSH
46039: LD_INT 4
46041: PUSH
46042: EMPTY
46043: LIST
46044: LIST
46045: PUSH
46046: LD_INT 3
46048: PUSH
46049: LD_INT 4
46051: PUSH
46052: EMPTY
46053: LIST
46054: LIST
46055: PUSH
46056: LD_INT 2
46058: PUSH
46059: LD_INT 3
46061: PUSH
46062: EMPTY
46063: LIST
46064: LIST
46065: PUSH
46066: LD_INT 2
46068: PUSH
46069: LD_INT 2
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: PUSH
46076: LD_INT 4
46078: PUSH
46079: LD_INT 2
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: LD_INT 2
46088: PUSH
46089: LD_INT 4
46091: PUSH
46092: EMPTY
46093: LIST
46094: LIST
46095: PUSH
46096: LD_INT 0
46098: PUSH
46099: LD_INT 4
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 0
46108: PUSH
46109: LD_INT 3
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 1
46118: PUSH
46119: LD_INT 4
46121: PUSH
46122: EMPTY
46123: LIST
46124: LIST
46125: PUSH
46126: LD_INT 1
46128: PUSH
46129: LD_INT 5
46131: PUSH
46132: EMPTY
46133: LIST
46134: LIST
46135: PUSH
46136: LD_INT 0
46138: PUSH
46139: LD_INT 5
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 1
46148: NEG
46149: PUSH
46150: LD_INT 4
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 1
46159: NEG
46160: PUSH
46161: LD_INT 3
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 2
46170: PUSH
46171: LD_INT 5
46173: PUSH
46174: EMPTY
46175: LIST
46176: LIST
46177: PUSH
46178: LD_INT 2
46180: NEG
46181: PUSH
46182: LD_INT 3
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: EMPTY
46190: LIST
46191: LIST
46192: LIST
46193: LIST
46194: LIST
46195: LIST
46196: LIST
46197: LIST
46198: LIST
46199: LIST
46200: LIST
46201: LIST
46202: LIST
46203: LIST
46204: LIST
46205: LIST
46206: LIST
46207: LIST
46208: LIST
46209: LIST
46210: LIST
46211: LIST
46212: LIST
46213: LIST
46214: LIST
46215: LIST
46216: LIST
46217: LIST
46218: LIST
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: LIST
46226: LIST
46227: LIST
46228: LIST
46229: LIST
46230: LIST
46231: LIST
46232: LIST
46233: LIST
46234: LIST
46235: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46236: LD_ADDR_VAR 0 34
46240: PUSH
46241: LD_INT 0
46243: PUSH
46244: LD_INT 4
46246: NEG
46247: PUSH
46248: EMPTY
46249: LIST
46250: LIST
46251: PUSH
46252: LD_INT 0
46254: PUSH
46255: LD_INT 5
46257: NEG
46258: PUSH
46259: EMPTY
46260: LIST
46261: LIST
46262: PUSH
46263: LD_INT 1
46265: PUSH
46266: LD_INT 4
46268: NEG
46269: PUSH
46270: EMPTY
46271: LIST
46272: LIST
46273: PUSH
46274: LD_INT 1
46276: PUSH
46277: LD_INT 3
46279: NEG
46280: PUSH
46281: EMPTY
46282: LIST
46283: LIST
46284: PUSH
46285: LD_INT 0
46287: PUSH
46288: LD_INT 3
46290: NEG
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: LD_INT 1
46298: NEG
46299: PUSH
46300: LD_INT 4
46302: NEG
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: LD_INT 1
46310: NEG
46311: PUSH
46312: LD_INT 5
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: LD_INT 2
46322: PUSH
46323: LD_INT 3
46325: NEG
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 2
46333: NEG
46334: PUSH
46335: LD_INT 5
46337: NEG
46338: PUSH
46339: EMPTY
46340: LIST
46341: LIST
46342: PUSH
46343: LD_INT 3
46345: PUSH
46346: LD_INT 0
46348: PUSH
46349: EMPTY
46350: LIST
46351: LIST
46352: PUSH
46353: LD_INT 3
46355: PUSH
46356: LD_INT 1
46358: NEG
46359: PUSH
46360: EMPTY
46361: LIST
46362: LIST
46363: PUSH
46364: LD_INT 4
46366: PUSH
46367: LD_INT 0
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 4
46376: PUSH
46377: LD_INT 1
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: LD_INT 1
46389: PUSH
46390: EMPTY
46391: LIST
46392: LIST
46393: PUSH
46394: LD_INT 2
46396: PUSH
46397: LD_INT 0
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PUSH
46404: LD_INT 2
46406: PUSH
46407: LD_INT 1
46409: NEG
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PUSH
46415: LD_INT 2
46417: PUSH
46418: LD_INT 2
46420: NEG
46421: PUSH
46422: EMPTY
46423: LIST
46424: LIST
46425: PUSH
46426: LD_INT 4
46428: PUSH
46429: LD_INT 2
46431: PUSH
46432: EMPTY
46433: LIST
46434: LIST
46435: PUSH
46436: LD_INT 4
46438: PUSH
46439: LD_INT 4
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PUSH
46446: LD_INT 4
46448: PUSH
46449: LD_INT 3
46451: PUSH
46452: EMPTY
46453: LIST
46454: LIST
46455: PUSH
46456: LD_INT 5
46458: PUSH
46459: LD_INT 4
46461: PUSH
46462: EMPTY
46463: LIST
46464: LIST
46465: PUSH
46466: LD_INT 5
46468: PUSH
46469: LD_INT 5
46471: PUSH
46472: EMPTY
46473: LIST
46474: LIST
46475: PUSH
46476: LD_INT 4
46478: PUSH
46479: LD_INT 5
46481: PUSH
46482: EMPTY
46483: LIST
46484: LIST
46485: PUSH
46486: LD_INT 3
46488: PUSH
46489: LD_INT 4
46491: PUSH
46492: EMPTY
46493: LIST
46494: LIST
46495: PUSH
46496: LD_INT 3
46498: PUSH
46499: LD_INT 3
46501: PUSH
46502: EMPTY
46503: LIST
46504: LIST
46505: PUSH
46506: LD_INT 5
46508: PUSH
46509: LD_INT 3
46511: PUSH
46512: EMPTY
46513: LIST
46514: LIST
46515: PUSH
46516: LD_INT 3
46518: PUSH
46519: LD_INT 5
46521: PUSH
46522: EMPTY
46523: LIST
46524: LIST
46525: PUSH
46526: LD_INT 0
46528: PUSH
46529: LD_INT 3
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 0
46538: PUSH
46539: LD_INT 2
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: PUSH
46546: LD_INT 1
46548: PUSH
46549: LD_INT 3
46551: PUSH
46552: EMPTY
46553: LIST
46554: LIST
46555: PUSH
46556: LD_INT 1
46558: PUSH
46559: LD_INT 4
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: PUSH
46566: LD_INT 0
46568: PUSH
46569: LD_INT 4
46571: PUSH
46572: EMPTY
46573: LIST
46574: LIST
46575: PUSH
46576: LD_INT 1
46578: NEG
46579: PUSH
46580: LD_INT 3
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: PUSH
46587: LD_INT 1
46589: NEG
46590: PUSH
46591: LD_INT 2
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 2
46600: PUSH
46601: LD_INT 4
46603: PUSH
46604: EMPTY
46605: LIST
46606: LIST
46607: PUSH
46608: LD_INT 2
46610: NEG
46611: PUSH
46612: LD_INT 2
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: LD_INT 4
46621: NEG
46622: PUSH
46623: LD_INT 0
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: LD_INT 4
46632: NEG
46633: PUSH
46634: LD_INT 1
46636: NEG
46637: PUSH
46638: EMPTY
46639: LIST
46640: LIST
46641: PUSH
46642: LD_INT 3
46644: NEG
46645: PUSH
46646: LD_INT 0
46648: PUSH
46649: EMPTY
46650: LIST
46651: LIST
46652: PUSH
46653: LD_INT 3
46655: NEG
46656: PUSH
46657: LD_INT 1
46659: PUSH
46660: EMPTY
46661: LIST
46662: LIST
46663: PUSH
46664: LD_INT 4
46666: NEG
46667: PUSH
46668: LD_INT 1
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 5
46677: NEG
46678: PUSH
46679: LD_INT 0
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 5
46688: NEG
46689: PUSH
46690: LD_INT 1
46692: NEG
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 5
46700: NEG
46701: PUSH
46702: LD_INT 2
46704: NEG
46705: PUSH
46706: EMPTY
46707: LIST
46708: LIST
46709: PUSH
46710: LD_INT 3
46712: NEG
46713: PUSH
46714: LD_INT 2
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: EMPTY
46722: LIST
46723: LIST
46724: LIST
46725: LIST
46726: LIST
46727: LIST
46728: LIST
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: LIST
46736: LIST
46737: LIST
46738: LIST
46739: LIST
46740: LIST
46741: LIST
46742: LIST
46743: LIST
46744: LIST
46745: LIST
46746: LIST
46747: LIST
46748: LIST
46749: LIST
46750: LIST
46751: LIST
46752: LIST
46753: LIST
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: LIST
46761: LIST
46762: LIST
46763: LIST
46764: LIST
46765: LIST
46766: LIST
46767: ST_TO_ADDR
// end ; end ;
46768: GO 46771
46770: POP
// case btype of b_depot , b_warehouse :
46771: LD_VAR 0 1
46775: PUSH
46776: LD_INT 0
46778: DOUBLE
46779: EQUAL
46780: IFTRUE 46790
46782: LD_INT 1
46784: DOUBLE
46785: EQUAL
46786: IFTRUE 46790
46788: GO 46991
46790: POP
// case nation of nation_american :
46791: LD_VAR 0 5
46795: PUSH
46796: LD_INT 1
46798: DOUBLE
46799: EQUAL
46800: IFTRUE 46804
46802: GO 46860
46804: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
46805: LD_ADDR_VAR 0 9
46809: PUSH
46810: LD_VAR 0 11
46814: PUSH
46815: LD_VAR 0 12
46819: PUSH
46820: LD_VAR 0 13
46824: PUSH
46825: LD_VAR 0 14
46829: PUSH
46830: LD_VAR 0 15
46834: PUSH
46835: LD_VAR 0 16
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: PUSH
46848: LD_VAR 0 4
46852: PUSH
46853: LD_INT 1
46855: PLUS
46856: ARRAY
46857: ST_TO_ADDR
46858: GO 46989
46860: LD_INT 2
46862: DOUBLE
46863: EQUAL
46864: IFTRUE 46868
46866: GO 46924
46868: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
46869: LD_ADDR_VAR 0 9
46873: PUSH
46874: LD_VAR 0 17
46878: PUSH
46879: LD_VAR 0 18
46883: PUSH
46884: LD_VAR 0 19
46888: PUSH
46889: LD_VAR 0 20
46893: PUSH
46894: LD_VAR 0 21
46898: PUSH
46899: LD_VAR 0 22
46903: PUSH
46904: EMPTY
46905: LIST
46906: LIST
46907: LIST
46908: LIST
46909: LIST
46910: LIST
46911: PUSH
46912: LD_VAR 0 4
46916: PUSH
46917: LD_INT 1
46919: PLUS
46920: ARRAY
46921: ST_TO_ADDR
46922: GO 46989
46924: LD_INT 3
46926: DOUBLE
46927: EQUAL
46928: IFTRUE 46932
46930: GO 46988
46932: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46933: LD_ADDR_VAR 0 9
46937: PUSH
46938: LD_VAR 0 23
46942: PUSH
46943: LD_VAR 0 24
46947: PUSH
46948: LD_VAR 0 25
46952: PUSH
46953: LD_VAR 0 26
46957: PUSH
46958: LD_VAR 0 27
46962: PUSH
46963: LD_VAR 0 28
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: PUSH
46976: LD_VAR 0 4
46980: PUSH
46981: LD_INT 1
46983: PLUS
46984: ARRAY
46985: ST_TO_ADDR
46986: GO 46989
46988: POP
46989: GO 47544
46991: LD_INT 2
46993: DOUBLE
46994: EQUAL
46995: IFTRUE 47005
46997: LD_INT 3
46999: DOUBLE
47000: EQUAL
47001: IFTRUE 47005
47003: GO 47061
47005: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47006: LD_ADDR_VAR 0 9
47010: PUSH
47011: LD_VAR 0 29
47015: PUSH
47016: LD_VAR 0 30
47020: PUSH
47021: LD_VAR 0 31
47025: PUSH
47026: LD_VAR 0 32
47030: PUSH
47031: LD_VAR 0 33
47035: PUSH
47036: LD_VAR 0 34
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: LIST
47045: LIST
47046: LIST
47047: LIST
47048: PUSH
47049: LD_VAR 0 4
47053: PUSH
47054: LD_INT 1
47056: PLUS
47057: ARRAY
47058: ST_TO_ADDR
47059: GO 47544
47061: LD_INT 16
47063: DOUBLE
47064: EQUAL
47065: IFTRUE 47123
47067: LD_INT 17
47069: DOUBLE
47070: EQUAL
47071: IFTRUE 47123
47073: LD_INT 18
47075: DOUBLE
47076: EQUAL
47077: IFTRUE 47123
47079: LD_INT 19
47081: DOUBLE
47082: EQUAL
47083: IFTRUE 47123
47085: LD_INT 22
47087: DOUBLE
47088: EQUAL
47089: IFTRUE 47123
47091: LD_INT 20
47093: DOUBLE
47094: EQUAL
47095: IFTRUE 47123
47097: LD_INT 21
47099: DOUBLE
47100: EQUAL
47101: IFTRUE 47123
47103: LD_INT 23
47105: DOUBLE
47106: EQUAL
47107: IFTRUE 47123
47109: LD_INT 24
47111: DOUBLE
47112: EQUAL
47113: IFTRUE 47123
47115: LD_INT 25
47117: DOUBLE
47118: EQUAL
47119: IFTRUE 47123
47121: GO 47179
47123: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47124: LD_ADDR_VAR 0 9
47128: PUSH
47129: LD_VAR 0 35
47133: PUSH
47134: LD_VAR 0 36
47138: PUSH
47139: LD_VAR 0 37
47143: PUSH
47144: LD_VAR 0 38
47148: PUSH
47149: LD_VAR 0 39
47153: PUSH
47154: LD_VAR 0 40
47158: PUSH
47159: EMPTY
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: PUSH
47167: LD_VAR 0 4
47171: PUSH
47172: LD_INT 1
47174: PLUS
47175: ARRAY
47176: ST_TO_ADDR
47177: GO 47544
47179: LD_INT 6
47181: DOUBLE
47182: EQUAL
47183: IFTRUE 47235
47185: LD_INT 7
47187: DOUBLE
47188: EQUAL
47189: IFTRUE 47235
47191: LD_INT 8
47193: DOUBLE
47194: EQUAL
47195: IFTRUE 47235
47197: LD_INT 13
47199: DOUBLE
47200: EQUAL
47201: IFTRUE 47235
47203: LD_INT 12
47205: DOUBLE
47206: EQUAL
47207: IFTRUE 47235
47209: LD_INT 15
47211: DOUBLE
47212: EQUAL
47213: IFTRUE 47235
47215: LD_INT 11
47217: DOUBLE
47218: EQUAL
47219: IFTRUE 47235
47221: LD_INT 14
47223: DOUBLE
47224: EQUAL
47225: IFTRUE 47235
47227: LD_INT 10
47229: DOUBLE
47230: EQUAL
47231: IFTRUE 47235
47233: GO 47291
47235: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47236: LD_ADDR_VAR 0 9
47240: PUSH
47241: LD_VAR 0 41
47245: PUSH
47246: LD_VAR 0 42
47250: PUSH
47251: LD_VAR 0 43
47255: PUSH
47256: LD_VAR 0 44
47260: PUSH
47261: LD_VAR 0 45
47265: PUSH
47266: LD_VAR 0 46
47270: PUSH
47271: EMPTY
47272: LIST
47273: LIST
47274: LIST
47275: LIST
47276: LIST
47277: LIST
47278: PUSH
47279: LD_VAR 0 4
47283: PUSH
47284: LD_INT 1
47286: PLUS
47287: ARRAY
47288: ST_TO_ADDR
47289: GO 47544
47291: LD_INT 36
47293: DOUBLE
47294: EQUAL
47295: IFTRUE 47299
47297: GO 47355
47299: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47300: LD_ADDR_VAR 0 9
47304: PUSH
47305: LD_VAR 0 47
47309: PUSH
47310: LD_VAR 0 48
47314: PUSH
47315: LD_VAR 0 49
47319: PUSH
47320: LD_VAR 0 50
47324: PUSH
47325: LD_VAR 0 51
47329: PUSH
47330: LD_VAR 0 52
47334: PUSH
47335: EMPTY
47336: LIST
47337: LIST
47338: LIST
47339: LIST
47340: LIST
47341: LIST
47342: PUSH
47343: LD_VAR 0 4
47347: PUSH
47348: LD_INT 1
47350: PLUS
47351: ARRAY
47352: ST_TO_ADDR
47353: GO 47544
47355: LD_INT 4
47357: DOUBLE
47358: EQUAL
47359: IFTRUE 47381
47361: LD_INT 5
47363: DOUBLE
47364: EQUAL
47365: IFTRUE 47381
47367: LD_INT 34
47369: DOUBLE
47370: EQUAL
47371: IFTRUE 47381
47373: LD_INT 37
47375: DOUBLE
47376: EQUAL
47377: IFTRUE 47381
47379: GO 47437
47381: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47382: LD_ADDR_VAR 0 9
47386: PUSH
47387: LD_VAR 0 53
47391: PUSH
47392: LD_VAR 0 54
47396: PUSH
47397: LD_VAR 0 55
47401: PUSH
47402: LD_VAR 0 56
47406: PUSH
47407: LD_VAR 0 57
47411: PUSH
47412: LD_VAR 0 58
47416: PUSH
47417: EMPTY
47418: LIST
47419: LIST
47420: LIST
47421: LIST
47422: LIST
47423: LIST
47424: PUSH
47425: LD_VAR 0 4
47429: PUSH
47430: LD_INT 1
47432: PLUS
47433: ARRAY
47434: ST_TO_ADDR
47435: GO 47544
47437: LD_INT 31
47439: DOUBLE
47440: EQUAL
47441: IFTRUE 47487
47443: LD_INT 32
47445: DOUBLE
47446: EQUAL
47447: IFTRUE 47487
47449: LD_INT 33
47451: DOUBLE
47452: EQUAL
47453: IFTRUE 47487
47455: LD_INT 27
47457: DOUBLE
47458: EQUAL
47459: IFTRUE 47487
47461: LD_INT 26
47463: DOUBLE
47464: EQUAL
47465: IFTRUE 47487
47467: LD_INT 28
47469: DOUBLE
47470: EQUAL
47471: IFTRUE 47487
47473: LD_INT 29
47475: DOUBLE
47476: EQUAL
47477: IFTRUE 47487
47479: LD_INT 30
47481: DOUBLE
47482: EQUAL
47483: IFTRUE 47487
47485: GO 47543
47487: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47488: LD_ADDR_VAR 0 9
47492: PUSH
47493: LD_VAR 0 59
47497: PUSH
47498: LD_VAR 0 60
47502: PUSH
47503: LD_VAR 0 61
47507: PUSH
47508: LD_VAR 0 62
47512: PUSH
47513: LD_VAR 0 63
47517: PUSH
47518: LD_VAR 0 64
47522: PUSH
47523: EMPTY
47524: LIST
47525: LIST
47526: LIST
47527: LIST
47528: LIST
47529: LIST
47530: PUSH
47531: LD_VAR 0 4
47535: PUSH
47536: LD_INT 1
47538: PLUS
47539: ARRAY
47540: ST_TO_ADDR
47541: GO 47544
47543: POP
// temp_list2 = [ ] ;
47544: LD_ADDR_VAR 0 10
47548: PUSH
47549: EMPTY
47550: ST_TO_ADDR
// for i in temp_list do
47551: LD_ADDR_VAR 0 8
47555: PUSH
47556: LD_VAR 0 9
47560: PUSH
47561: FOR_IN
47562: IFFALSE 47614
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47564: LD_ADDR_VAR 0 10
47568: PUSH
47569: LD_VAR 0 10
47573: PUSH
47574: LD_VAR 0 8
47578: PUSH
47579: LD_INT 1
47581: ARRAY
47582: PUSH
47583: LD_VAR 0 2
47587: PLUS
47588: PUSH
47589: LD_VAR 0 8
47593: PUSH
47594: LD_INT 2
47596: ARRAY
47597: PUSH
47598: LD_VAR 0 3
47602: PLUS
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: PUSH
47608: EMPTY
47609: LIST
47610: ADD
47611: ST_TO_ADDR
47612: GO 47561
47614: POP
47615: POP
// result = temp_list2 ;
47616: LD_ADDR_VAR 0 7
47620: PUSH
47621: LD_VAR 0 10
47625: ST_TO_ADDR
// end ;
47626: LD_VAR 0 7
47630: RET
// export function EnemyInRange ( unit , dist ) ; begin
47631: LD_INT 0
47633: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47634: LD_ADDR_VAR 0 3
47638: PUSH
47639: LD_VAR 0 1
47643: PPUSH
47644: CALL_OW 255
47648: PPUSH
47649: LD_VAR 0 1
47653: PPUSH
47654: CALL_OW 250
47658: PPUSH
47659: LD_VAR 0 1
47663: PPUSH
47664: CALL_OW 251
47668: PPUSH
47669: LD_VAR 0 2
47673: PPUSH
47674: CALL 21735 0 4
47678: PUSH
47679: LD_INT 4
47681: ARRAY
47682: ST_TO_ADDR
// end ;
47683: LD_VAR 0 3
47687: RET
// export function PlayerSeeMe ( unit ) ; begin
47688: LD_INT 0
47690: PPUSH
// result := See ( your_side , unit ) ;
47691: LD_ADDR_VAR 0 2
47695: PUSH
47696: LD_OWVAR 2
47700: PPUSH
47701: LD_VAR 0 1
47705: PPUSH
47706: CALL_OW 292
47710: ST_TO_ADDR
// end ;
47711: LD_VAR 0 2
47715: RET
// export function ReverseDir ( unit ) ; begin
47716: LD_INT 0
47718: PPUSH
// if not unit then
47719: LD_VAR 0 1
47723: NOT
47724: IFFALSE 47728
// exit ;
47726: GO 47774
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47728: LD_ADDR_VAR 0 2
47732: PUSH
47733: LD_INT 3
47735: PUSH
47736: LD_INT 4
47738: PUSH
47739: LD_INT 5
47741: PUSH
47742: LD_INT 0
47744: PUSH
47745: LD_INT 1
47747: PUSH
47748: LD_INT 2
47750: PUSH
47751: EMPTY
47752: LIST
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: PUSH
47759: LD_VAR 0 1
47763: PPUSH
47764: CALL_OW 254
47768: PUSH
47769: LD_INT 1
47771: PLUS
47772: ARRAY
47773: ST_TO_ADDR
// end ;
47774: LD_VAR 0 2
47778: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47779: LD_INT 0
47781: PPUSH
47782: PPUSH
47783: PPUSH
47784: PPUSH
47785: PPUSH
// if not hexes then
47786: LD_VAR 0 2
47790: NOT
47791: IFFALSE 47795
// exit ;
47793: GO 47943
// dist := 9999 ;
47795: LD_ADDR_VAR 0 5
47799: PUSH
47800: LD_INT 9999
47802: ST_TO_ADDR
// for i = 1 to hexes do
47803: LD_ADDR_VAR 0 4
47807: PUSH
47808: DOUBLE
47809: LD_INT 1
47811: DEC
47812: ST_TO_ADDR
47813: LD_VAR 0 2
47817: PUSH
47818: FOR_TO
47819: IFFALSE 47931
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47821: LD_VAR 0 1
47825: PPUSH
47826: LD_VAR 0 2
47830: PUSH
47831: LD_VAR 0 4
47835: ARRAY
47836: PUSH
47837: LD_INT 1
47839: ARRAY
47840: PPUSH
47841: LD_VAR 0 2
47845: PUSH
47846: LD_VAR 0 4
47850: ARRAY
47851: PUSH
47852: LD_INT 2
47854: ARRAY
47855: PPUSH
47856: CALL_OW 297
47860: PUSH
47861: LD_VAR 0 5
47865: LESS
47866: IFFALSE 47929
// begin hex := hexes [ i ] ;
47868: LD_ADDR_VAR 0 7
47872: PUSH
47873: LD_VAR 0 2
47877: PUSH
47878: LD_VAR 0 4
47882: ARRAY
47883: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47884: LD_ADDR_VAR 0 5
47888: PUSH
47889: LD_VAR 0 1
47893: PPUSH
47894: LD_VAR 0 2
47898: PUSH
47899: LD_VAR 0 4
47903: ARRAY
47904: PUSH
47905: LD_INT 1
47907: ARRAY
47908: PPUSH
47909: LD_VAR 0 2
47913: PUSH
47914: LD_VAR 0 4
47918: ARRAY
47919: PUSH
47920: LD_INT 2
47922: ARRAY
47923: PPUSH
47924: CALL_OW 297
47928: ST_TO_ADDR
// end ; end ;
47929: GO 47818
47931: POP
47932: POP
// result := hex ;
47933: LD_ADDR_VAR 0 3
47937: PUSH
47938: LD_VAR 0 7
47942: ST_TO_ADDR
// end ;
47943: LD_VAR 0 3
47947: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47948: LD_INT 0
47950: PPUSH
47951: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47952: LD_VAR 0 1
47956: NOT
47957: PUSH
47958: LD_VAR 0 1
47962: PUSH
47963: LD_INT 21
47965: PUSH
47966: LD_INT 2
47968: PUSH
47969: EMPTY
47970: LIST
47971: LIST
47972: PUSH
47973: LD_INT 23
47975: PUSH
47976: LD_INT 2
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: PUSH
47983: EMPTY
47984: LIST
47985: LIST
47986: PPUSH
47987: CALL_OW 69
47991: IN
47992: NOT
47993: OR
47994: IFFALSE 47998
// exit ;
47996: GO 48045
// for i = 1 to 3 do
47998: LD_ADDR_VAR 0 3
48002: PUSH
48003: DOUBLE
48004: LD_INT 1
48006: DEC
48007: ST_TO_ADDR
48008: LD_INT 3
48010: PUSH
48011: FOR_TO
48012: IFFALSE 48043
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48014: LD_VAR 0 1
48018: PPUSH
48019: CALL_OW 250
48023: PPUSH
48024: LD_VAR 0 1
48028: PPUSH
48029: CALL_OW 251
48033: PPUSH
48034: LD_INT 1
48036: PPUSH
48037: CALL_OW 453
48041: GO 48011
48043: POP
48044: POP
// end ;
48045: LD_VAR 0 2
48049: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48050: LD_INT 0
48052: PPUSH
48053: PPUSH
48054: PPUSH
48055: PPUSH
48056: PPUSH
48057: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48058: LD_VAR 0 1
48062: NOT
48063: PUSH
48064: LD_VAR 0 2
48068: NOT
48069: OR
48070: PUSH
48071: LD_VAR 0 1
48075: PPUSH
48076: CALL_OW 314
48080: OR
48081: IFFALSE 48085
// exit ;
48083: GO 48526
// x := GetX ( enemy_unit ) ;
48085: LD_ADDR_VAR 0 7
48089: PUSH
48090: LD_VAR 0 2
48094: PPUSH
48095: CALL_OW 250
48099: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48100: LD_ADDR_VAR 0 8
48104: PUSH
48105: LD_VAR 0 2
48109: PPUSH
48110: CALL_OW 251
48114: ST_TO_ADDR
// if not x or not y then
48115: LD_VAR 0 7
48119: NOT
48120: PUSH
48121: LD_VAR 0 8
48125: NOT
48126: OR
48127: IFFALSE 48131
// exit ;
48129: GO 48526
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48131: LD_ADDR_VAR 0 6
48135: PUSH
48136: LD_VAR 0 7
48140: PPUSH
48141: LD_INT 0
48143: PPUSH
48144: LD_INT 4
48146: PPUSH
48147: CALL_OW 272
48151: PUSH
48152: LD_VAR 0 8
48156: PPUSH
48157: LD_INT 0
48159: PPUSH
48160: LD_INT 4
48162: PPUSH
48163: CALL_OW 273
48167: PUSH
48168: EMPTY
48169: LIST
48170: LIST
48171: PUSH
48172: LD_VAR 0 7
48176: PPUSH
48177: LD_INT 1
48179: PPUSH
48180: LD_INT 4
48182: PPUSH
48183: CALL_OW 272
48187: PUSH
48188: LD_VAR 0 8
48192: PPUSH
48193: LD_INT 1
48195: PPUSH
48196: LD_INT 4
48198: PPUSH
48199: CALL_OW 273
48203: PUSH
48204: EMPTY
48205: LIST
48206: LIST
48207: PUSH
48208: LD_VAR 0 7
48212: PPUSH
48213: LD_INT 2
48215: PPUSH
48216: LD_INT 4
48218: PPUSH
48219: CALL_OW 272
48223: PUSH
48224: LD_VAR 0 8
48228: PPUSH
48229: LD_INT 2
48231: PPUSH
48232: LD_INT 4
48234: PPUSH
48235: CALL_OW 273
48239: PUSH
48240: EMPTY
48241: LIST
48242: LIST
48243: PUSH
48244: LD_VAR 0 7
48248: PPUSH
48249: LD_INT 3
48251: PPUSH
48252: LD_INT 4
48254: PPUSH
48255: CALL_OW 272
48259: PUSH
48260: LD_VAR 0 8
48264: PPUSH
48265: LD_INT 3
48267: PPUSH
48268: LD_INT 4
48270: PPUSH
48271: CALL_OW 273
48275: PUSH
48276: EMPTY
48277: LIST
48278: LIST
48279: PUSH
48280: LD_VAR 0 7
48284: PPUSH
48285: LD_INT 4
48287: PPUSH
48288: LD_INT 4
48290: PPUSH
48291: CALL_OW 272
48295: PUSH
48296: LD_VAR 0 8
48300: PPUSH
48301: LD_INT 4
48303: PPUSH
48304: LD_INT 4
48306: PPUSH
48307: CALL_OW 273
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: PUSH
48316: LD_VAR 0 7
48320: PPUSH
48321: LD_INT 5
48323: PPUSH
48324: LD_INT 4
48326: PPUSH
48327: CALL_OW 272
48331: PUSH
48332: LD_VAR 0 8
48336: PPUSH
48337: LD_INT 5
48339: PPUSH
48340: LD_INT 4
48342: PPUSH
48343: CALL_OW 273
48347: PUSH
48348: EMPTY
48349: LIST
48350: LIST
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: ST_TO_ADDR
// for i = tmp downto 1 do
48360: LD_ADDR_VAR 0 4
48364: PUSH
48365: DOUBLE
48366: LD_VAR 0 6
48370: INC
48371: ST_TO_ADDR
48372: LD_INT 1
48374: PUSH
48375: FOR_DOWNTO
48376: IFFALSE 48477
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48378: LD_VAR 0 6
48382: PUSH
48383: LD_VAR 0 4
48387: ARRAY
48388: PUSH
48389: LD_INT 1
48391: ARRAY
48392: PPUSH
48393: LD_VAR 0 6
48397: PUSH
48398: LD_VAR 0 4
48402: ARRAY
48403: PUSH
48404: LD_INT 2
48406: ARRAY
48407: PPUSH
48408: CALL_OW 488
48412: NOT
48413: PUSH
48414: LD_VAR 0 6
48418: PUSH
48419: LD_VAR 0 4
48423: ARRAY
48424: PUSH
48425: LD_INT 1
48427: ARRAY
48428: PPUSH
48429: LD_VAR 0 6
48433: PUSH
48434: LD_VAR 0 4
48438: ARRAY
48439: PUSH
48440: LD_INT 2
48442: ARRAY
48443: PPUSH
48444: CALL_OW 428
48448: PUSH
48449: LD_INT 0
48451: NONEQUAL
48452: OR
48453: IFFALSE 48475
// tmp := Delete ( tmp , i ) ;
48455: LD_ADDR_VAR 0 6
48459: PUSH
48460: LD_VAR 0 6
48464: PPUSH
48465: LD_VAR 0 4
48469: PPUSH
48470: CALL_OW 3
48474: ST_TO_ADDR
48475: GO 48375
48477: POP
48478: POP
// j := GetClosestHex ( unit , tmp ) ;
48479: LD_ADDR_VAR 0 5
48483: PUSH
48484: LD_VAR 0 1
48488: PPUSH
48489: LD_VAR 0 6
48493: PPUSH
48494: CALL 47779 0 2
48498: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48499: LD_VAR 0 1
48503: PPUSH
48504: LD_VAR 0 5
48508: PUSH
48509: LD_INT 1
48511: ARRAY
48512: PPUSH
48513: LD_VAR 0 5
48517: PUSH
48518: LD_INT 2
48520: ARRAY
48521: PPUSH
48522: CALL_OW 111
// end ;
48526: LD_VAR 0 3
48530: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48531: LD_INT 0
48533: PPUSH
48534: PPUSH
48535: PPUSH
// uc_side = 0 ;
48536: LD_ADDR_OWVAR 20
48540: PUSH
48541: LD_INT 0
48543: ST_TO_ADDR
// uc_nation = 0 ;
48544: LD_ADDR_OWVAR 21
48548: PUSH
48549: LD_INT 0
48551: ST_TO_ADDR
// InitHc ;
48552: CALL_OW 19
// InitVc ;
48556: CALL_OW 20
// if mastodonts then
48560: LD_VAR 0 6
48564: IFFALSE 48631
// for i = 1 to mastodonts do
48566: LD_ADDR_VAR 0 11
48570: PUSH
48571: DOUBLE
48572: LD_INT 1
48574: DEC
48575: ST_TO_ADDR
48576: LD_VAR 0 6
48580: PUSH
48581: FOR_TO
48582: IFFALSE 48629
// begin vc_chassis := 31 ;
48584: LD_ADDR_OWVAR 37
48588: PUSH
48589: LD_INT 31
48591: ST_TO_ADDR
// vc_control := control_rider ;
48592: LD_ADDR_OWVAR 38
48596: PUSH
48597: LD_INT 4
48599: ST_TO_ADDR
// animal := CreateVehicle ;
48600: LD_ADDR_VAR 0 12
48604: PUSH
48605: CALL_OW 45
48609: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48610: LD_VAR 0 12
48614: PPUSH
48615: LD_VAR 0 8
48619: PPUSH
48620: LD_INT 0
48622: PPUSH
48623: CALL 55376 0 3
// end ;
48627: GO 48581
48629: POP
48630: POP
// if horses then
48631: LD_VAR 0 5
48635: IFFALSE 48702
// for i = 1 to horses do
48637: LD_ADDR_VAR 0 11
48641: PUSH
48642: DOUBLE
48643: LD_INT 1
48645: DEC
48646: ST_TO_ADDR
48647: LD_VAR 0 5
48651: PUSH
48652: FOR_TO
48653: IFFALSE 48700
// begin hc_class := 21 ;
48655: LD_ADDR_OWVAR 28
48659: PUSH
48660: LD_INT 21
48662: ST_TO_ADDR
// hc_gallery :=  ;
48663: LD_ADDR_OWVAR 33
48667: PUSH
48668: LD_STRING 
48670: ST_TO_ADDR
// animal := CreateHuman ;
48671: LD_ADDR_VAR 0 12
48675: PUSH
48676: CALL_OW 44
48680: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48681: LD_VAR 0 12
48685: PPUSH
48686: LD_VAR 0 8
48690: PPUSH
48691: LD_INT 0
48693: PPUSH
48694: CALL 55376 0 3
// end ;
48698: GO 48652
48700: POP
48701: POP
// if birds then
48702: LD_VAR 0 1
48706: IFFALSE 48773
// for i = 1 to birds do
48708: LD_ADDR_VAR 0 11
48712: PUSH
48713: DOUBLE
48714: LD_INT 1
48716: DEC
48717: ST_TO_ADDR
48718: LD_VAR 0 1
48722: PUSH
48723: FOR_TO
48724: IFFALSE 48771
// begin hc_class = 18 ;
48726: LD_ADDR_OWVAR 28
48730: PUSH
48731: LD_INT 18
48733: ST_TO_ADDR
// hc_gallery =  ;
48734: LD_ADDR_OWVAR 33
48738: PUSH
48739: LD_STRING 
48741: ST_TO_ADDR
// animal := CreateHuman ;
48742: LD_ADDR_VAR 0 12
48746: PUSH
48747: CALL_OW 44
48751: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48752: LD_VAR 0 12
48756: PPUSH
48757: LD_VAR 0 8
48761: PPUSH
48762: LD_INT 0
48764: PPUSH
48765: CALL 55376 0 3
// end ;
48769: GO 48723
48771: POP
48772: POP
// if tigers then
48773: LD_VAR 0 2
48777: IFFALSE 48861
// for i = 1 to tigers do
48779: LD_ADDR_VAR 0 11
48783: PUSH
48784: DOUBLE
48785: LD_INT 1
48787: DEC
48788: ST_TO_ADDR
48789: LD_VAR 0 2
48793: PUSH
48794: FOR_TO
48795: IFFALSE 48859
// begin hc_class = class_tiger ;
48797: LD_ADDR_OWVAR 28
48801: PUSH
48802: LD_INT 14
48804: ST_TO_ADDR
// hc_gallery =  ;
48805: LD_ADDR_OWVAR 33
48809: PUSH
48810: LD_STRING 
48812: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
48813: LD_ADDR_OWVAR 35
48817: PUSH
48818: LD_INT 7
48820: NEG
48821: PPUSH
48822: LD_INT 7
48824: PPUSH
48825: CALL_OW 12
48829: ST_TO_ADDR
// animal := CreateHuman ;
48830: LD_ADDR_VAR 0 12
48834: PUSH
48835: CALL_OW 44
48839: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48840: LD_VAR 0 12
48844: PPUSH
48845: LD_VAR 0 8
48849: PPUSH
48850: LD_INT 0
48852: PPUSH
48853: CALL 55376 0 3
// end ;
48857: GO 48794
48859: POP
48860: POP
// if apemans then
48861: LD_VAR 0 3
48865: IFFALSE 48988
// for i = 1 to apemans do
48867: LD_ADDR_VAR 0 11
48871: PUSH
48872: DOUBLE
48873: LD_INT 1
48875: DEC
48876: ST_TO_ADDR
48877: LD_VAR 0 3
48881: PUSH
48882: FOR_TO
48883: IFFALSE 48986
// begin hc_class = class_apeman ;
48885: LD_ADDR_OWVAR 28
48889: PUSH
48890: LD_INT 12
48892: ST_TO_ADDR
// hc_gallery =  ;
48893: LD_ADDR_OWVAR 33
48897: PUSH
48898: LD_STRING 
48900: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
48901: LD_ADDR_OWVAR 35
48905: PUSH
48906: LD_INT 5
48908: NEG
48909: PPUSH
48910: LD_INT 5
48912: PPUSH
48913: CALL_OW 12
48917: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
48918: LD_ADDR_OWVAR 31
48922: PUSH
48923: LD_INT 1
48925: PPUSH
48926: LD_INT 3
48928: PPUSH
48929: CALL_OW 12
48933: PUSH
48934: LD_INT 1
48936: PPUSH
48937: LD_INT 3
48939: PPUSH
48940: CALL_OW 12
48944: PUSH
48945: LD_INT 0
48947: PUSH
48948: LD_INT 0
48950: PUSH
48951: EMPTY
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: ST_TO_ADDR
// animal := CreateHuman ;
48957: LD_ADDR_VAR 0 12
48961: PUSH
48962: CALL_OW 44
48966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48967: LD_VAR 0 12
48971: PPUSH
48972: LD_VAR 0 8
48976: PPUSH
48977: LD_INT 0
48979: PPUSH
48980: CALL 55376 0 3
// end ;
48984: GO 48882
48986: POP
48987: POP
// if enchidnas then
48988: LD_VAR 0 4
48992: IFFALSE 49059
// for i = 1 to enchidnas do
48994: LD_ADDR_VAR 0 11
48998: PUSH
48999: DOUBLE
49000: LD_INT 1
49002: DEC
49003: ST_TO_ADDR
49004: LD_VAR 0 4
49008: PUSH
49009: FOR_TO
49010: IFFALSE 49057
// begin hc_class = 13 ;
49012: LD_ADDR_OWVAR 28
49016: PUSH
49017: LD_INT 13
49019: ST_TO_ADDR
// hc_gallery =  ;
49020: LD_ADDR_OWVAR 33
49024: PUSH
49025: LD_STRING 
49027: ST_TO_ADDR
// animal := CreateHuman ;
49028: LD_ADDR_VAR 0 12
49032: PUSH
49033: CALL_OW 44
49037: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49038: LD_VAR 0 12
49042: PPUSH
49043: LD_VAR 0 8
49047: PPUSH
49048: LD_INT 0
49050: PPUSH
49051: CALL 55376 0 3
// end ;
49055: GO 49009
49057: POP
49058: POP
// if fishes then
49059: LD_VAR 0 7
49063: IFFALSE 49130
// for i = 1 to fishes do
49065: LD_ADDR_VAR 0 11
49069: PUSH
49070: DOUBLE
49071: LD_INT 1
49073: DEC
49074: ST_TO_ADDR
49075: LD_VAR 0 7
49079: PUSH
49080: FOR_TO
49081: IFFALSE 49128
// begin hc_class = 20 ;
49083: LD_ADDR_OWVAR 28
49087: PUSH
49088: LD_INT 20
49090: ST_TO_ADDR
// hc_gallery =  ;
49091: LD_ADDR_OWVAR 33
49095: PUSH
49096: LD_STRING 
49098: ST_TO_ADDR
// animal := CreateHuman ;
49099: LD_ADDR_VAR 0 12
49103: PUSH
49104: CALL_OW 44
49108: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49109: LD_VAR 0 12
49113: PPUSH
49114: LD_VAR 0 9
49118: PPUSH
49119: LD_INT 0
49121: PPUSH
49122: CALL 55376 0 3
// end ;
49126: GO 49080
49128: POP
49129: POP
// end ;
49130: LD_VAR 0 10
49134: RET
// export function WantHeal ( sci , unit ) ; begin
49135: LD_INT 0
49137: PPUSH
// if GetTaskList ( sci ) > 0 then
49138: LD_VAR 0 1
49142: PPUSH
49143: CALL_OW 437
49147: PUSH
49148: LD_INT 0
49150: GREATER
49151: IFFALSE 49221
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49153: LD_VAR 0 1
49157: PPUSH
49158: CALL_OW 437
49162: PUSH
49163: LD_INT 1
49165: ARRAY
49166: PUSH
49167: LD_INT 1
49169: ARRAY
49170: PUSH
49171: LD_STRING l
49173: EQUAL
49174: PUSH
49175: LD_VAR 0 1
49179: PPUSH
49180: CALL_OW 437
49184: PUSH
49185: LD_INT 1
49187: ARRAY
49188: PUSH
49189: LD_INT 4
49191: ARRAY
49192: PUSH
49193: LD_VAR 0 2
49197: EQUAL
49198: AND
49199: IFFALSE 49211
// result := true else
49201: LD_ADDR_VAR 0 3
49205: PUSH
49206: LD_INT 1
49208: ST_TO_ADDR
49209: GO 49219
// result := false ;
49211: LD_ADDR_VAR 0 3
49215: PUSH
49216: LD_INT 0
49218: ST_TO_ADDR
// end else
49219: GO 49229
// result := false ;
49221: LD_ADDR_VAR 0 3
49225: PUSH
49226: LD_INT 0
49228: ST_TO_ADDR
// end ;
49229: LD_VAR 0 3
49233: RET
// export function HealTarget ( sci ) ; begin
49234: LD_INT 0
49236: PPUSH
// if not sci then
49237: LD_VAR 0 1
49241: NOT
49242: IFFALSE 49246
// exit ;
49244: GO 49311
// result := 0 ;
49246: LD_ADDR_VAR 0 2
49250: PUSH
49251: LD_INT 0
49253: ST_TO_ADDR
// if GetTaskList ( sci ) then
49254: LD_VAR 0 1
49258: PPUSH
49259: CALL_OW 437
49263: IFFALSE 49311
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49265: LD_VAR 0 1
49269: PPUSH
49270: CALL_OW 437
49274: PUSH
49275: LD_INT 1
49277: ARRAY
49278: PUSH
49279: LD_INT 1
49281: ARRAY
49282: PUSH
49283: LD_STRING l
49285: EQUAL
49286: IFFALSE 49311
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49288: LD_ADDR_VAR 0 2
49292: PUSH
49293: LD_VAR 0 1
49297: PPUSH
49298: CALL_OW 437
49302: PUSH
49303: LD_INT 1
49305: ARRAY
49306: PUSH
49307: LD_INT 4
49309: ARRAY
49310: ST_TO_ADDR
// end ;
49311: LD_VAR 0 2
49315: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49316: LD_INT 0
49318: PPUSH
49319: PPUSH
49320: PPUSH
49321: PPUSH
49322: PPUSH
49323: PPUSH
49324: PPUSH
49325: PPUSH
49326: PPUSH
49327: PPUSH
49328: PPUSH
49329: PPUSH
49330: PPUSH
49331: PPUSH
49332: PPUSH
49333: PPUSH
49334: PPUSH
49335: PPUSH
49336: PPUSH
49337: PPUSH
49338: PPUSH
49339: PPUSH
49340: PPUSH
49341: PPUSH
49342: PPUSH
49343: PPUSH
49344: PPUSH
49345: PPUSH
49346: PPUSH
49347: PPUSH
49348: PPUSH
49349: PPUSH
49350: PPUSH
49351: PPUSH
// if not list then
49352: LD_VAR 0 1
49356: NOT
49357: IFFALSE 49361
// exit ;
49359: GO 53987
// base := list [ 1 ] ;
49361: LD_ADDR_VAR 0 3
49365: PUSH
49366: LD_VAR 0 1
49370: PUSH
49371: LD_INT 1
49373: ARRAY
49374: ST_TO_ADDR
// group := list [ 2 ] ;
49375: LD_ADDR_VAR 0 4
49379: PUSH
49380: LD_VAR 0 1
49384: PUSH
49385: LD_INT 2
49387: ARRAY
49388: ST_TO_ADDR
// path := list [ 3 ] ;
49389: LD_ADDR_VAR 0 5
49393: PUSH
49394: LD_VAR 0 1
49398: PUSH
49399: LD_INT 3
49401: ARRAY
49402: ST_TO_ADDR
// flags := list [ 4 ] ;
49403: LD_ADDR_VAR 0 6
49407: PUSH
49408: LD_VAR 0 1
49412: PUSH
49413: LD_INT 4
49415: ARRAY
49416: ST_TO_ADDR
// mined := [ ] ;
49417: LD_ADDR_VAR 0 27
49421: PUSH
49422: EMPTY
49423: ST_TO_ADDR
// bombed := [ ] ;
49424: LD_ADDR_VAR 0 28
49428: PUSH
49429: EMPTY
49430: ST_TO_ADDR
// healers := [ ] ;
49431: LD_ADDR_VAR 0 31
49435: PUSH
49436: EMPTY
49437: ST_TO_ADDR
// to_heal := [ ] ;
49438: LD_ADDR_VAR 0 30
49442: PUSH
49443: EMPTY
49444: ST_TO_ADDR
// repairs := [ ] ;
49445: LD_ADDR_VAR 0 33
49449: PUSH
49450: EMPTY
49451: ST_TO_ADDR
// to_repair := [ ] ;
49452: LD_ADDR_VAR 0 32
49456: PUSH
49457: EMPTY
49458: ST_TO_ADDR
// if not group or not path then
49459: LD_VAR 0 4
49463: NOT
49464: PUSH
49465: LD_VAR 0 5
49469: NOT
49470: OR
49471: IFFALSE 49475
// exit ;
49473: GO 53987
// side := GetSide ( group [ 1 ] ) ;
49475: LD_ADDR_VAR 0 35
49479: PUSH
49480: LD_VAR 0 4
49484: PUSH
49485: LD_INT 1
49487: ARRAY
49488: PPUSH
49489: CALL_OW 255
49493: ST_TO_ADDR
// if flags then
49494: LD_VAR 0 6
49498: IFFALSE 49642
// begin f_ignore_area := flags [ 1 ] ;
49500: LD_ADDR_VAR 0 17
49504: PUSH
49505: LD_VAR 0 6
49509: PUSH
49510: LD_INT 1
49512: ARRAY
49513: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49514: LD_ADDR_VAR 0 18
49518: PUSH
49519: LD_VAR 0 6
49523: PUSH
49524: LD_INT 2
49526: ARRAY
49527: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49528: LD_ADDR_VAR 0 19
49532: PUSH
49533: LD_VAR 0 6
49537: PUSH
49538: LD_INT 3
49540: ARRAY
49541: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49542: LD_ADDR_VAR 0 20
49546: PUSH
49547: LD_VAR 0 6
49551: PUSH
49552: LD_INT 4
49554: ARRAY
49555: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49556: LD_ADDR_VAR 0 21
49560: PUSH
49561: LD_VAR 0 6
49565: PUSH
49566: LD_INT 5
49568: ARRAY
49569: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49570: LD_ADDR_VAR 0 22
49574: PUSH
49575: LD_VAR 0 6
49579: PUSH
49580: LD_INT 6
49582: ARRAY
49583: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49584: LD_ADDR_VAR 0 23
49588: PUSH
49589: LD_VAR 0 6
49593: PUSH
49594: LD_INT 7
49596: ARRAY
49597: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49598: LD_ADDR_VAR 0 24
49602: PUSH
49603: LD_VAR 0 6
49607: PUSH
49608: LD_INT 8
49610: ARRAY
49611: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49612: LD_ADDR_VAR 0 25
49616: PUSH
49617: LD_VAR 0 6
49621: PUSH
49622: LD_INT 9
49624: ARRAY
49625: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49626: LD_ADDR_VAR 0 26
49630: PUSH
49631: LD_VAR 0 6
49635: PUSH
49636: LD_INT 10
49638: ARRAY
49639: ST_TO_ADDR
// end else
49640: GO 49722
// begin f_ignore_area := false ;
49642: LD_ADDR_VAR 0 17
49646: PUSH
49647: LD_INT 0
49649: ST_TO_ADDR
// f_capture := false ;
49650: LD_ADDR_VAR 0 18
49654: PUSH
49655: LD_INT 0
49657: ST_TO_ADDR
// f_ignore_civ := false ;
49658: LD_ADDR_VAR 0 19
49662: PUSH
49663: LD_INT 0
49665: ST_TO_ADDR
// f_murder := false ;
49666: LD_ADDR_VAR 0 20
49670: PUSH
49671: LD_INT 0
49673: ST_TO_ADDR
// f_mines := false ;
49674: LD_ADDR_VAR 0 21
49678: PUSH
49679: LD_INT 0
49681: ST_TO_ADDR
// f_repair := false ;
49682: LD_ADDR_VAR 0 22
49686: PUSH
49687: LD_INT 0
49689: ST_TO_ADDR
// f_heal := false ;
49690: LD_ADDR_VAR 0 23
49694: PUSH
49695: LD_INT 0
49697: ST_TO_ADDR
// f_spacetime := false ;
49698: LD_ADDR_VAR 0 24
49702: PUSH
49703: LD_INT 0
49705: ST_TO_ADDR
// f_attack_depot := false ;
49706: LD_ADDR_VAR 0 25
49710: PUSH
49711: LD_INT 0
49713: ST_TO_ADDR
// f_crawl := false ;
49714: LD_ADDR_VAR 0 26
49718: PUSH
49719: LD_INT 0
49721: ST_TO_ADDR
// end ; if f_heal then
49722: LD_VAR 0 23
49726: IFFALSE 49753
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49728: LD_ADDR_VAR 0 31
49732: PUSH
49733: LD_VAR 0 4
49737: PPUSH
49738: LD_INT 25
49740: PUSH
49741: LD_INT 4
49743: PUSH
49744: EMPTY
49745: LIST
49746: LIST
49747: PPUSH
49748: CALL_OW 72
49752: ST_TO_ADDR
// if f_repair then
49753: LD_VAR 0 22
49757: IFFALSE 49784
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49759: LD_ADDR_VAR 0 33
49763: PUSH
49764: LD_VAR 0 4
49768: PPUSH
49769: LD_INT 25
49771: PUSH
49772: LD_INT 3
49774: PUSH
49775: EMPTY
49776: LIST
49777: LIST
49778: PPUSH
49779: CALL_OW 72
49783: ST_TO_ADDR
// units_path := [ ] ;
49784: LD_ADDR_VAR 0 16
49788: PUSH
49789: EMPTY
49790: ST_TO_ADDR
// for i = 1 to group do
49791: LD_ADDR_VAR 0 7
49795: PUSH
49796: DOUBLE
49797: LD_INT 1
49799: DEC
49800: ST_TO_ADDR
49801: LD_VAR 0 4
49805: PUSH
49806: FOR_TO
49807: IFFALSE 49836
// units_path := Replace ( units_path , i , path ) ;
49809: LD_ADDR_VAR 0 16
49813: PUSH
49814: LD_VAR 0 16
49818: PPUSH
49819: LD_VAR 0 7
49823: PPUSH
49824: LD_VAR 0 5
49828: PPUSH
49829: CALL_OW 1
49833: ST_TO_ADDR
49834: GO 49806
49836: POP
49837: POP
// repeat for i = group downto 1 do
49838: LD_ADDR_VAR 0 7
49842: PUSH
49843: DOUBLE
49844: LD_VAR 0 4
49848: INC
49849: ST_TO_ADDR
49850: LD_INT 1
49852: PUSH
49853: FOR_DOWNTO
49854: IFFALSE 53950
// begin wait ( 5 ) ;
49856: LD_INT 5
49858: PPUSH
49859: CALL_OW 67
// tmp := [ ] ;
49863: LD_ADDR_VAR 0 14
49867: PUSH
49868: EMPTY
49869: ST_TO_ADDR
// attacking := false ;
49870: LD_ADDR_VAR 0 29
49874: PUSH
49875: LD_INT 0
49877: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
49878: LD_VAR 0 4
49882: PUSH
49883: LD_VAR 0 7
49887: ARRAY
49888: PPUSH
49889: CALL_OW 301
49893: PUSH
49894: LD_VAR 0 4
49898: PUSH
49899: LD_VAR 0 7
49903: ARRAY
49904: NOT
49905: OR
49906: IFFALSE 50015
// begin if GetType ( group [ i ] ) = unit_human then
49908: LD_VAR 0 4
49912: PUSH
49913: LD_VAR 0 7
49917: ARRAY
49918: PPUSH
49919: CALL_OW 247
49923: PUSH
49924: LD_INT 1
49926: EQUAL
49927: IFFALSE 49973
// begin to_heal := to_heal diff group [ i ] ;
49929: LD_ADDR_VAR 0 30
49933: PUSH
49934: LD_VAR 0 30
49938: PUSH
49939: LD_VAR 0 4
49943: PUSH
49944: LD_VAR 0 7
49948: ARRAY
49949: DIFF
49950: ST_TO_ADDR
// healers := healers diff group [ i ] ;
49951: LD_ADDR_VAR 0 31
49955: PUSH
49956: LD_VAR 0 31
49960: PUSH
49961: LD_VAR 0 4
49965: PUSH
49966: LD_VAR 0 7
49970: ARRAY
49971: DIFF
49972: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
49973: LD_ADDR_VAR 0 4
49977: PUSH
49978: LD_VAR 0 4
49982: PPUSH
49983: LD_VAR 0 7
49987: PPUSH
49988: CALL_OW 3
49992: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
49993: LD_ADDR_VAR 0 16
49997: PUSH
49998: LD_VAR 0 16
50002: PPUSH
50003: LD_VAR 0 7
50007: PPUSH
50008: CALL_OW 3
50012: ST_TO_ADDR
// continue ;
50013: GO 49853
// end ; if f_repair then
50015: LD_VAR 0 22
50019: IFFALSE 50508
// begin if GetType ( group [ i ] ) = unit_vehicle then
50021: LD_VAR 0 4
50025: PUSH
50026: LD_VAR 0 7
50030: ARRAY
50031: PPUSH
50032: CALL_OW 247
50036: PUSH
50037: LD_INT 2
50039: EQUAL
50040: IFFALSE 50230
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50042: LD_VAR 0 4
50046: PUSH
50047: LD_VAR 0 7
50051: ARRAY
50052: PPUSH
50053: CALL_OW 256
50057: PUSH
50058: LD_INT 700
50060: LESS
50061: PUSH
50062: LD_VAR 0 4
50066: PUSH
50067: LD_VAR 0 7
50071: ARRAY
50072: PUSH
50073: LD_VAR 0 32
50077: IN
50078: NOT
50079: AND
50080: IFFALSE 50104
// to_repair := to_repair union group [ i ] ;
50082: LD_ADDR_VAR 0 32
50086: PUSH
50087: LD_VAR 0 32
50091: PUSH
50092: LD_VAR 0 4
50096: PUSH
50097: LD_VAR 0 7
50101: ARRAY
50102: UNION
50103: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50104: LD_VAR 0 4
50108: PUSH
50109: LD_VAR 0 7
50113: ARRAY
50114: PPUSH
50115: CALL_OW 256
50119: PUSH
50120: LD_INT 1000
50122: EQUAL
50123: PUSH
50124: LD_VAR 0 4
50128: PUSH
50129: LD_VAR 0 7
50133: ARRAY
50134: PUSH
50135: LD_VAR 0 32
50139: IN
50140: AND
50141: IFFALSE 50165
// to_repair := to_repair diff group [ i ] ;
50143: LD_ADDR_VAR 0 32
50147: PUSH
50148: LD_VAR 0 32
50152: PUSH
50153: LD_VAR 0 4
50157: PUSH
50158: LD_VAR 0 7
50162: ARRAY
50163: DIFF
50164: ST_TO_ADDR
// if group [ i ] in to_repair then
50165: LD_VAR 0 4
50169: PUSH
50170: LD_VAR 0 7
50174: ARRAY
50175: PUSH
50176: LD_VAR 0 32
50180: IN
50181: IFFALSE 50228
// begin if not IsInArea ( group [ i ] , f_repair ) then
50183: LD_VAR 0 4
50187: PUSH
50188: LD_VAR 0 7
50192: ARRAY
50193: PPUSH
50194: LD_VAR 0 22
50198: PPUSH
50199: CALL_OW 308
50203: NOT
50204: IFFALSE 50226
// ComMoveToArea ( group [ i ] , f_repair ) ;
50206: LD_VAR 0 4
50210: PUSH
50211: LD_VAR 0 7
50215: ARRAY
50216: PPUSH
50217: LD_VAR 0 22
50221: PPUSH
50222: CALL_OW 113
// continue ;
50226: GO 49853
// end ; end else
50228: GO 50508
// if group [ i ] in repairs then
50230: LD_VAR 0 4
50234: PUSH
50235: LD_VAR 0 7
50239: ARRAY
50240: PUSH
50241: LD_VAR 0 33
50245: IN
50246: IFFALSE 50508
// begin if IsInUnit ( group [ i ] ) then
50248: LD_VAR 0 4
50252: PUSH
50253: LD_VAR 0 7
50257: ARRAY
50258: PPUSH
50259: CALL_OW 310
50263: IFFALSE 50331
// begin z := IsInUnit ( group [ i ] ) ;
50265: LD_ADDR_VAR 0 13
50269: PUSH
50270: LD_VAR 0 4
50274: PUSH
50275: LD_VAR 0 7
50279: ARRAY
50280: PPUSH
50281: CALL_OW 310
50285: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50286: LD_VAR 0 13
50290: PUSH
50291: LD_VAR 0 32
50295: IN
50296: PUSH
50297: LD_VAR 0 13
50301: PPUSH
50302: LD_VAR 0 22
50306: PPUSH
50307: CALL_OW 308
50311: AND
50312: IFFALSE 50329
// ComExitVehicle ( group [ i ] ) ;
50314: LD_VAR 0 4
50318: PUSH
50319: LD_VAR 0 7
50323: ARRAY
50324: PPUSH
50325: CALL_OW 121
// end else
50329: GO 50508
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50331: LD_ADDR_VAR 0 13
50335: PUSH
50336: LD_VAR 0 4
50340: PPUSH
50341: LD_INT 95
50343: PUSH
50344: LD_VAR 0 22
50348: PUSH
50349: EMPTY
50350: LIST
50351: LIST
50352: PUSH
50353: LD_INT 58
50355: PUSH
50356: EMPTY
50357: LIST
50358: PUSH
50359: EMPTY
50360: LIST
50361: LIST
50362: PPUSH
50363: CALL_OW 72
50367: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50368: LD_VAR 0 4
50372: PUSH
50373: LD_VAR 0 7
50377: ARRAY
50378: PPUSH
50379: CALL_OW 314
50383: NOT
50384: IFFALSE 50506
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50386: LD_ADDR_VAR 0 10
50390: PUSH
50391: LD_VAR 0 13
50395: PPUSH
50396: LD_VAR 0 4
50400: PUSH
50401: LD_VAR 0 7
50405: ARRAY
50406: PPUSH
50407: CALL_OW 74
50411: ST_TO_ADDR
// if not x then
50412: LD_VAR 0 10
50416: NOT
50417: IFFALSE 50421
// continue ;
50419: GO 49853
// if GetLives ( x ) < 1000 then
50421: LD_VAR 0 10
50425: PPUSH
50426: CALL_OW 256
50430: PUSH
50431: LD_INT 1000
50433: LESS
50434: IFFALSE 50458
// ComRepairVehicle ( group [ i ] , x ) else
50436: LD_VAR 0 4
50440: PUSH
50441: LD_VAR 0 7
50445: ARRAY
50446: PPUSH
50447: LD_VAR 0 10
50451: PPUSH
50452: CALL_OW 129
50456: GO 50506
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50458: LD_VAR 0 23
50462: PUSH
50463: LD_VAR 0 4
50467: PUSH
50468: LD_VAR 0 7
50472: ARRAY
50473: PPUSH
50474: CALL_OW 256
50478: PUSH
50479: LD_INT 1000
50481: LESS
50482: AND
50483: NOT
50484: IFFALSE 50506
// ComEnterUnit ( group [ i ] , x ) ;
50486: LD_VAR 0 4
50490: PUSH
50491: LD_VAR 0 7
50495: ARRAY
50496: PPUSH
50497: LD_VAR 0 10
50501: PPUSH
50502: CALL_OW 120
// end ; continue ;
50506: GO 49853
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50508: LD_VAR 0 23
50512: PUSH
50513: LD_VAR 0 4
50517: PUSH
50518: LD_VAR 0 7
50522: ARRAY
50523: PPUSH
50524: CALL_OW 247
50528: PUSH
50529: LD_INT 1
50531: EQUAL
50532: AND
50533: IFFALSE 51011
// begin if group [ i ] in healers then
50535: LD_VAR 0 4
50539: PUSH
50540: LD_VAR 0 7
50544: ARRAY
50545: PUSH
50546: LD_VAR 0 31
50550: IN
50551: IFFALSE 50824
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50553: LD_VAR 0 4
50557: PUSH
50558: LD_VAR 0 7
50562: ARRAY
50563: PPUSH
50564: LD_VAR 0 23
50568: PPUSH
50569: CALL_OW 308
50573: NOT
50574: PUSH
50575: LD_VAR 0 4
50579: PUSH
50580: LD_VAR 0 7
50584: ARRAY
50585: PPUSH
50586: CALL_OW 314
50590: NOT
50591: AND
50592: IFFALSE 50616
// ComMoveToArea ( group [ i ] , f_heal ) else
50594: LD_VAR 0 4
50598: PUSH
50599: LD_VAR 0 7
50603: ARRAY
50604: PPUSH
50605: LD_VAR 0 23
50609: PPUSH
50610: CALL_OW 113
50614: GO 50822
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50616: LD_VAR 0 4
50620: PUSH
50621: LD_VAR 0 7
50625: ARRAY
50626: PPUSH
50627: CALL 49234 0 1
50631: PPUSH
50632: CALL_OW 256
50636: PUSH
50637: LD_INT 1000
50639: EQUAL
50640: IFFALSE 50659
// ComStop ( group [ i ] ) else
50642: LD_VAR 0 4
50646: PUSH
50647: LD_VAR 0 7
50651: ARRAY
50652: PPUSH
50653: CALL_OW 141
50657: GO 50822
// if not HasTask ( group [ i ] ) and to_heal then
50659: LD_VAR 0 4
50663: PUSH
50664: LD_VAR 0 7
50668: ARRAY
50669: PPUSH
50670: CALL_OW 314
50674: NOT
50675: PUSH
50676: LD_VAR 0 30
50680: AND
50681: IFFALSE 50822
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50683: LD_ADDR_VAR 0 13
50687: PUSH
50688: LD_VAR 0 30
50692: PPUSH
50693: LD_INT 3
50695: PUSH
50696: LD_INT 54
50698: PUSH
50699: EMPTY
50700: LIST
50701: PUSH
50702: EMPTY
50703: LIST
50704: LIST
50705: PPUSH
50706: CALL_OW 72
50710: PPUSH
50711: LD_VAR 0 4
50715: PUSH
50716: LD_VAR 0 7
50720: ARRAY
50721: PPUSH
50722: CALL_OW 74
50726: ST_TO_ADDR
// if z then
50727: LD_VAR 0 13
50731: IFFALSE 50822
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50733: LD_INT 91
50735: PUSH
50736: LD_VAR 0 13
50740: PUSH
50741: LD_INT 10
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: LIST
50748: PUSH
50749: LD_INT 81
50751: PUSH
50752: LD_VAR 0 13
50756: PPUSH
50757: CALL_OW 255
50761: PUSH
50762: EMPTY
50763: LIST
50764: LIST
50765: PUSH
50766: EMPTY
50767: LIST
50768: LIST
50769: PPUSH
50770: CALL_OW 69
50774: PUSH
50775: LD_INT 0
50777: EQUAL
50778: IFFALSE 50802
// ComHeal ( group [ i ] , z ) else
50780: LD_VAR 0 4
50784: PUSH
50785: LD_VAR 0 7
50789: ARRAY
50790: PPUSH
50791: LD_VAR 0 13
50795: PPUSH
50796: CALL_OW 128
50800: GO 50822
// ComMoveToArea ( group [ i ] , f_heal ) ;
50802: LD_VAR 0 4
50806: PUSH
50807: LD_VAR 0 7
50811: ARRAY
50812: PPUSH
50813: LD_VAR 0 23
50817: PPUSH
50818: CALL_OW 113
// end ; continue ;
50822: GO 49853
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
50824: LD_VAR 0 4
50828: PUSH
50829: LD_VAR 0 7
50833: ARRAY
50834: PPUSH
50835: CALL_OW 256
50839: PUSH
50840: LD_INT 700
50842: LESS
50843: PUSH
50844: LD_VAR 0 4
50848: PUSH
50849: LD_VAR 0 7
50853: ARRAY
50854: PUSH
50855: LD_VAR 0 30
50859: IN
50860: NOT
50861: AND
50862: IFFALSE 50886
// to_heal := to_heal union group [ i ] ;
50864: LD_ADDR_VAR 0 30
50868: PUSH
50869: LD_VAR 0 30
50873: PUSH
50874: LD_VAR 0 4
50878: PUSH
50879: LD_VAR 0 7
50883: ARRAY
50884: UNION
50885: ST_TO_ADDR
// if group [ i ] in to_heal then
50886: LD_VAR 0 4
50890: PUSH
50891: LD_VAR 0 7
50895: ARRAY
50896: PUSH
50897: LD_VAR 0 30
50901: IN
50902: IFFALSE 51011
// begin if GetLives ( group [ i ] ) = 1000 then
50904: LD_VAR 0 4
50908: PUSH
50909: LD_VAR 0 7
50913: ARRAY
50914: PPUSH
50915: CALL_OW 256
50919: PUSH
50920: LD_INT 1000
50922: EQUAL
50923: IFFALSE 50949
// to_heal := to_heal diff group [ i ] else
50925: LD_ADDR_VAR 0 30
50929: PUSH
50930: LD_VAR 0 30
50934: PUSH
50935: LD_VAR 0 4
50939: PUSH
50940: LD_VAR 0 7
50944: ARRAY
50945: DIFF
50946: ST_TO_ADDR
50947: GO 51011
// begin if not IsInArea ( group [ i ] , to_heal ) then
50949: LD_VAR 0 4
50953: PUSH
50954: LD_VAR 0 7
50958: ARRAY
50959: PPUSH
50960: LD_VAR 0 30
50964: PPUSH
50965: CALL_OW 308
50969: NOT
50970: IFFALSE 50994
// ComMoveToArea ( group [ i ] , f_heal ) else
50972: LD_VAR 0 4
50976: PUSH
50977: LD_VAR 0 7
50981: ARRAY
50982: PPUSH
50983: LD_VAR 0 23
50987: PPUSH
50988: CALL_OW 113
50992: GO 51009
// ComHold ( group [ i ] ) ;
50994: LD_VAR 0 4
50998: PUSH
50999: LD_VAR 0 7
51003: ARRAY
51004: PPUSH
51005: CALL_OW 140
// continue ;
51009: GO 49853
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51011: LD_VAR 0 4
51015: PUSH
51016: LD_VAR 0 7
51020: ARRAY
51021: PPUSH
51022: LD_INT 10
51024: PPUSH
51025: CALL 47631 0 2
51029: NOT
51030: PUSH
51031: LD_VAR 0 16
51035: PUSH
51036: LD_VAR 0 7
51040: ARRAY
51041: PUSH
51042: EMPTY
51043: EQUAL
51044: NOT
51045: AND
51046: IFFALSE 51312
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51048: LD_VAR 0 4
51052: PUSH
51053: LD_VAR 0 7
51057: ARRAY
51058: PPUSH
51059: CALL_OW 262
51063: PUSH
51064: LD_INT 1
51066: PUSH
51067: LD_INT 2
51069: PUSH
51070: EMPTY
51071: LIST
51072: LIST
51073: IN
51074: IFFALSE 51115
// if GetFuel ( group [ i ] ) < 10 then
51076: LD_VAR 0 4
51080: PUSH
51081: LD_VAR 0 7
51085: ARRAY
51086: PPUSH
51087: CALL_OW 261
51091: PUSH
51092: LD_INT 10
51094: LESS
51095: IFFALSE 51115
// SetFuel ( group [ i ] , 12 ) ;
51097: LD_VAR 0 4
51101: PUSH
51102: LD_VAR 0 7
51106: ARRAY
51107: PPUSH
51108: LD_INT 12
51110: PPUSH
51111: CALL_OW 240
// if units_path [ i ] then
51115: LD_VAR 0 16
51119: PUSH
51120: LD_VAR 0 7
51124: ARRAY
51125: IFFALSE 51310
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51127: LD_VAR 0 4
51131: PUSH
51132: LD_VAR 0 7
51136: ARRAY
51137: PPUSH
51138: LD_VAR 0 16
51142: PUSH
51143: LD_VAR 0 7
51147: ARRAY
51148: PUSH
51149: LD_INT 1
51151: ARRAY
51152: PUSH
51153: LD_INT 1
51155: ARRAY
51156: PPUSH
51157: LD_VAR 0 16
51161: PUSH
51162: LD_VAR 0 7
51166: ARRAY
51167: PUSH
51168: LD_INT 1
51170: ARRAY
51171: PUSH
51172: LD_INT 2
51174: ARRAY
51175: PPUSH
51176: CALL_OW 297
51180: PUSH
51181: LD_INT 6
51183: GREATER
51184: IFFALSE 51259
// begin if not HasTask ( group [ i ] ) then
51186: LD_VAR 0 4
51190: PUSH
51191: LD_VAR 0 7
51195: ARRAY
51196: PPUSH
51197: CALL_OW 314
51201: NOT
51202: IFFALSE 51257
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51204: LD_VAR 0 4
51208: PUSH
51209: LD_VAR 0 7
51213: ARRAY
51214: PPUSH
51215: LD_VAR 0 16
51219: PUSH
51220: LD_VAR 0 7
51224: ARRAY
51225: PUSH
51226: LD_INT 1
51228: ARRAY
51229: PUSH
51230: LD_INT 1
51232: ARRAY
51233: PPUSH
51234: LD_VAR 0 16
51238: PUSH
51239: LD_VAR 0 7
51243: ARRAY
51244: PUSH
51245: LD_INT 1
51247: ARRAY
51248: PUSH
51249: LD_INT 2
51251: ARRAY
51252: PPUSH
51253: CALL_OW 114
// end else
51257: GO 51310
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51259: LD_ADDR_VAR 0 15
51263: PUSH
51264: LD_VAR 0 16
51268: PUSH
51269: LD_VAR 0 7
51273: ARRAY
51274: PPUSH
51275: LD_INT 1
51277: PPUSH
51278: CALL_OW 3
51282: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51283: LD_ADDR_VAR 0 16
51287: PUSH
51288: LD_VAR 0 16
51292: PPUSH
51293: LD_VAR 0 7
51297: PPUSH
51298: LD_VAR 0 15
51302: PPUSH
51303: CALL_OW 1
51307: ST_TO_ADDR
// continue ;
51308: GO 49853
// end ; end ; end else
51310: GO 53948
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51312: LD_ADDR_VAR 0 14
51316: PUSH
51317: LD_INT 81
51319: PUSH
51320: LD_VAR 0 4
51324: PUSH
51325: LD_VAR 0 7
51329: ARRAY
51330: PPUSH
51331: CALL_OW 255
51335: PUSH
51336: EMPTY
51337: LIST
51338: LIST
51339: PPUSH
51340: CALL_OW 69
51344: ST_TO_ADDR
// if not tmp then
51345: LD_VAR 0 14
51349: NOT
51350: IFFALSE 51354
// continue ;
51352: GO 49853
// if f_ignore_area then
51354: LD_VAR 0 17
51358: IFFALSE 51446
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51360: LD_ADDR_VAR 0 15
51364: PUSH
51365: LD_VAR 0 14
51369: PPUSH
51370: LD_INT 3
51372: PUSH
51373: LD_INT 92
51375: PUSH
51376: LD_VAR 0 17
51380: PUSH
51381: LD_INT 1
51383: ARRAY
51384: PUSH
51385: LD_VAR 0 17
51389: PUSH
51390: LD_INT 2
51392: ARRAY
51393: PUSH
51394: LD_VAR 0 17
51398: PUSH
51399: LD_INT 3
51401: ARRAY
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: PPUSH
51413: CALL_OW 72
51417: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51418: LD_VAR 0 14
51422: PUSH
51423: LD_VAR 0 15
51427: DIFF
51428: IFFALSE 51446
// tmp := tmp diff tmp2 ;
51430: LD_ADDR_VAR 0 14
51434: PUSH
51435: LD_VAR 0 14
51439: PUSH
51440: LD_VAR 0 15
51444: DIFF
51445: ST_TO_ADDR
// end ; if not f_murder then
51446: LD_VAR 0 20
51450: NOT
51451: IFFALSE 51509
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51453: LD_ADDR_VAR 0 15
51457: PUSH
51458: LD_VAR 0 14
51462: PPUSH
51463: LD_INT 3
51465: PUSH
51466: LD_INT 50
51468: PUSH
51469: EMPTY
51470: LIST
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: PPUSH
51476: CALL_OW 72
51480: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51481: LD_VAR 0 14
51485: PUSH
51486: LD_VAR 0 15
51490: DIFF
51491: IFFALSE 51509
// tmp := tmp diff tmp2 ;
51493: LD_ADDR_VAR 0 14
51497: PUSH
51498: LD_VAR 0 14
51502: PUSH
51503: LD_VAR 0 15
51507: DIFF
51508: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51509: LD_ADDR_VAR 0 14
51513: PUSH
51514: LD_VAR 0 4
51518: PUSH
51519: LD_VAR 0 7
51523: ARRAY
51524: PPUSH
51525: LD_VAR 0 14
51529: PPUSH
51530: LD_INT 1
51532: PPUSH
51533: LD_INT 1
51535: PPUSH
51536: CALL 21274 0 4
51540: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51541: LD_VAR 0 4
51545: PUSH
51546: LD_VAR 0 7
51550: ARRAY
51551: PPUSH
51552: CALL_OW 257
51556: PUSH
51557: LD_INT 1
51559: EQUAL
51560: IFFALSE 52008
// begin if WantPlant ( group [ i ] ) then
51562: LD_VAR 0 4
51566: PUSH
51567: LD_VAR 0 7
51571: ARRAY
51572: PPUSH
51573: CALL 20775 0 1
51577: IFFALSE 51581
// continue ;
51579: GO 49853
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51581: LD_VAR 0 18
51585: PUSH
51586: LD_VAR 0 4
51590: PUSH
51591: LD_VAR 0 7
51595: ARRAY
51596: PPUSH
51597: CALL_OW 310
51601: NOT
51602: AND
51603: PUSH
51604: LD_VAR 0 14
51608: PUSH
51609: LD_INT 1
51611: ARRAY
51612: PUSH
51613: LD_VAR 0 14
51617: PPUSH
51618: LD_INT 21
51620: PUSH
51621: LD_INT 2
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PUSH
51628: LD_INT 58
51630: PUSH
51631: EMPTY
51632: LIST
51633: PUSH
51634: EMPTY
51635: LIST
51636: LIST
51637: PPUSH
51638: CALL_OW 72
51642: IN
51643: AND
51644: IFFALSE 51680
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51646: LD_VAR 0 4
51650: PUSH
51651: LD_VAR 0 7
51655: ARRAY
51656: PPUSH
51657: LD_VAR 0 14
51661: PUSH
51662: LD_INT 1
51664: ARRAY
51665: PPUSH
51666: CALL_OW 120
// attacking := true ;
51670: LD_ADDR_VAR 0 29
51674: PUSH
51675: LD_INT 1
51677: ST_TO_ADDR
// continue ;
51678: GO 49853
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51680: LD_VAR 0 26
51684: PUSH
51685: LD_VAR 0 4
51689: PUSH
51690: LD_VAR 0 7
51694: ARRAY
51695: PPUSH
51696: CALL_OW 257
51700: PUSH
51701: LD_INT 1
51703: EQUAL
51704: AND
51705: PUSH
51706: LD_VAR 0 4
51710: PUSH
51711: LD_VAR 0 7
51715: ARRAY
51716: PPUSH
51717: CALL_OW 256
51721: PUSH
51722: LD_INT 800
51724: LESS
51725: AND
51726: PUSH
51727: LD_VAR 0 4
51731: PUSH
51732: LD_VAR 0 7
51736: ARRAY
51737: PPUSH
51738: CALL_OW 318
51742: NOT
51743: AND
51744: IFFALSE 51761
// ComCrawl ( group [ i ] ) ;
51746: LD_VAR 0 4
51750: PUSH
51751: LD_VAR 0 7
51755: ARRAY
51756: PPUSH
51757: CALL_OW 137
// if f_mines then
51761: LD_VAR 0 21
51765: IFFALSE 52008
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51767: LD_VAR 0 14
51771: PUSH
51772: LD_INT 1
51774: ARRAY
51775: PPUSH
51776: CALL_OW 247
51780: PUSH
51781: LD_INT 3
51783: EQUAL
51784: PUSH
51785: LD_VAR 0 14
51789: PUSH
51790: LD_INT 1
51792: ARRAY
51793: PUSH
51794: LD_VAR 0 27
51798: IN
51799: NOT
51800: AND
51801: IFFALSE 52008
// begin x := GetX ( tmp [ 1 ] ) ;
51803: LD_ADDR_VAR 0 10
51807: PUSH
51808: LD_VAR 0 14
51812: PUSH
51813: LD_INT 1
51815: ARRAY
51816: PPUSH
51817: CALL_OW 250
51821: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
51822: LD_ADDR_VAR 0 11
51826: PUSH
51827: LD_VAR 0 14
51831: PUSH
51832: LD_INT 1
51834: ARRAY
51835: PPUSH
51836: CALL_OW 251
51840: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
51841: LD_ADDR_VAR 0 12
51845: PUSH
51846: LD_VAR 0 4
51850: PUSH
51851: LD_VAR 0 7
51855: ARRAY
51856: PPUSH
51857: CALL 47716 0 1
51861: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
51862: LD_VAR 0 4
51866: PUSH
51867: LD_VAR 0 7
51871: ARRAY
51872: PPUSH
51873: LD_VAR 0 10
51877: PPUSH
51878: LD_VAR 0 11
51882: PPUSH
51883: LD_VAR 0 14
51887: PUSH
51888: LD_INT 1
51890: ARRAY
51891: PPUSH
51892: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
51896: LD_VAR 0 4
51900: PUSH
51901: LD_VAR 0 7
51905: ARRAY
51906: PPUSH
51907: LD_VAR 0 10
51911: PPUSH
51912: LD_VAR 0 12
51916: PPUSH
51917: LD_INT 7
51919: PPUSH
51920: CALL_OW 272
51924: PPUSH
51925: LD_VAR 0 11
51929: PPUSH
51930: LD_VAR 0 12
51934: PPUSH
51935: LD_INT 7
51937: PPUSH
51938: CALL_OW 273
51942: PPUSH
51943: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
51947: LD_VAR 0 4
51951: PUSH
51952: LD_VAR 0 7
51956: ARRAY
51957: PPUSH
51958: LD_INT 71
51960: PPUSH
51961: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
51965: LD_ADDR_VAR 0 27
51969: PUSH
51970: LD_VAR 0 27
51974: PPUSH
51975: LD_VAR 0 27
51979: PUSH
51980: LD_INT 1
51982: PLUS
51983: PPUSH
51984: LD_VAR 0 14
51988: PUSH
51989: LD_INT 1
51991: ARRAY
51992: PPUSH
51993: CALL_OW 1
51997: ST_TO_ADDR
// attacking := true ;
51998: LD_ADDR_VAR 0 29
52002: PUSH
52003: LD_INT 1
52005: ST_TO_ADDR
// continue ;
52006: GO 49853
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52008: LD_VAR 0 4
52012: PUSH
52013: LD_VAR 0 7
52017: ARRAY
52018: PPUSH
52019: CALL_OW 257
52023: PUSH
52024: LD_INT 17
52026: EQUAL
52027: PUSH
52028: LD_VAR 0 4
52032: PUSH
52033: LD_VAR 0 7
52037: ARRAY
52038: PPUSH
52039: CALL_OW 110
52043: PUSH
52044: LD_INT 71
52046: EQUAL
52047: NOT
52048: AND
52049: IFFALSE 52195
// begin attacking := false ;
52051: LD_ADDR_VAR 0 29
52055: PUSH
52056: LD_INT 0
52058: ST_TO_ADDR
// k := 5 ;
52059: LD_ADDR_VAR 0 9
52063: PUSH
52064: LD_INT 5
52066: ST_TO_ADDR
// if tmp < k then
52067: LD_VAR 0 14
52071: PUSH
52072: LD_VAR 0 9
52076: LESS
52077: IFFALSE 52089
// k := tmp ;
52079: LD_ADDR_VAR 0 9
52083: PUSH
52084: LD_VAR 0 14
52088: ST_TO_ADDR
// for j = 1 to k do
52089: LD_ADDR_VAR 0 8
52093: PUSH
52094: DOUBLE
52095: LD_INT 1
52097: DEC
52098: ST_TO_ADDR
52099: LD_VAR 0 9
52103: PUSH
52104: FOR_TO
52105: IFFALSE 52193
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52107: LD_VAR 0 14
52111: PUSH
52112: LD_VAR 0 8
52116: ARRAY
52117: PUSH
52118: LD_VAR 0 14
52122: PPUSH
52123: LD_INT 58
52125: PUSH
52126: EMPTY
52127: LIST
52128: PPUSH
52129: CALL_OW 72
52133: IN
52134: NOT
52135: IFFALSE 52191
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52137: LD_VAR 0 4
52141: PUSH
52142: LD_VAR 0 7
52146: ARRAY
52147: PPUSH
52148: LD_VAR 0 14
52152: PUSH
52153: LD_VAR 0 8
52157: ARRAY
52158: PPUSH
52159: CALL_OW 115
// attacking := true ;
52163: LD_ADDR_VAR 0 29
52167: PUSH
52168: LD_INT 1
52170: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52171: LD_VAR 0 4
52175: PUSH
52176: LD_VAR 0 7
52180: ARRAY
52181: PPUSH
52182: LD_INT 71
52184: PPUSH
52185: CALL_OW 109
// continue ;
52189: GO 52104
// end ; end ;
52191: GO 52104
52193: POP
52194: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52195: LD_VAR 0 4
52199: PUSH
52200: LD_VAR 0 7
52204: ARRAY
52205: PPUSH
52206: CALL_OW 257
52210: PUSH
52211: LD_INT 8
52213: EQUAL
52214: PUSH
52215: LD_VAR 0 4
52219: PUSH
52220: LD_VAR 0 7
52224: ARRAY
52225: PPUSH
52226: CALL_OW 264
52230: PUSH
52231: LD_INT 28
52233: PUSH
52234: LD_INT 45
52236: PUSH
52237: LD_INT 7
52239: PUSH
52240: LD_INT 47
52242: PUSH
52243: EMPTY
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: IN
52249: OR
52250: IFFALSE 52480
// begin attacking := false ;
52252: LD_ADDR_VAR 0 29
52256: PUSH
52257: LD_INT 0
52259: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52260: LD_VAR 0 14
52264: PUSH
52265: LD_INT 1
52267: ARRAY
52268: PPUSH
52269: CALL_OW 266
52273: PUSH
52274: LD_INT 32
52276: PUSH
52277: LD_INT 31
52279: PUSH
52280: LD_INT 33
52282: PUSH
52283: LD_INT 4
52285: PUSH
52286: LD_INT 5
52288: PUSH
52289: EMPTY
52290: LIST
52291: LIST
52292: LIST
52293: LIST
52294: LIST
52295: IN
52296: IFFALSE 52480
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52298: LD_ADDR_VAR 0 9
52302: PUSH
52303: LD_VAR 0 14
52307: PUSH
52308: LD_INT 1
52310: ARRAY
52311: PPUSH
52312: CALL_OW 266
52316: PPUSH
52317: LD_VAR 0 14
52321: PUSH
52322: LD_INT 1
52324: ARRAY
52325: PPUSH
52326: CALL_OW 250
52330: PPUSH
52331: LD_VAR 0 14
52335: PUSH
52336: LD_INT 1
52338: ARRAY
52339: PPUSH
52340: CALL_OW 251
52344: PPUSH
52345: LD_VAR 0 14
52349: PUSH
52350: LD_INT 1
52352: ARRAY
52353: PPUSH
52354: CALL_OW 254
52358: PPUSH
52359: LD_VAR 0 14
52363: PUSH
52364: LD_INT 1
52366: ARRAY
52367: PPUSH
52368: CALL_OW 248
52372: PPUSH
52373: LD_INT 0
52375: PPUSH
52376: CALL 29086 0 6
52380: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52381: LD_ADDR_VAR 0 8
52385: PUSH
52386: LD_VAR 0 4
52390: PUSH
52391: LD_VAR 0 7
52395: ARRAY
52396: PPUSH
52397: LD_VAR 0 9
52401: PPUSH
52402: CALL 47779 0 2
52406: ST_TO_ADDR
// if j then
52407: LD_VAR 0 8
52411: IFFALSE 52480
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52413: LD_VAR 0 8
52417: PUSH
52418: LD_INT 1
52420: ARRAY
52421: PPUSH
52422: LD_VAR 0 8
52426: PUSH
52427: LD_INT 2
52429: ARRAY
52430: PPUSH
52431: CALL_OW 488
52435: IFFALSE 52480
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52437: LD_VAR 0 4
52441: PUSH
52442: LD_VAR 0 7
52446: ARRAY
52447: PPUSH
52448: LD_VAR 0 8
52452: PUSH
52453: LD_INT 1
52455: ARRAY
52456: PPUSH
52457: LD_VAR 0 8
52461: PUSH
52462: LD_INT 2
52464: ARRAY
52465: PPUSH
52466: CALL_OW 116
// attacking := true ;
52470: LD_ADDR_VAR 0 29
52474: PUSH
52475: LD_INT 1
52477: ST_TO_ADDR
// continue ;
52478: GO 49853
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52480: LD_VAR 0 4
52484: PUSH
52485: LD_VAR 0 7
52489: ARRAY
52490: PPUSH
52491: CALL_OW 265
52495: PUSH
52496: LD_INT 11
52498: EQUAL
52499: IFFALSE 52777
// begin k := 10 ;
52501: LD_ADDR_VAR 0 9
52505: PUSH
52506: LD_INT 10
52508: ST_TO_ADDR
// x := 0 ;
52509: LD_ADDR_VAR 0 10
52513: PUSH
52514: LD_INT 0
52516: ST_TO_ADDR
// if tmp < k then
52517: LD_VAR 0 14
52521: PUSH
52522: LD_VAR 0 9
52526: LESS
52527: IFFALSE 52539
// k := tmp ;
52529: LD_ADDR_VAR 0 9
52533: PUSH
52534: LD_VAR 0 14
52538: ST_TO_ADDR
// for j = k downto 1 do
52539: LD_ADDR_VAR 0 8
52543: PUSH
52544: DOUBLE
52545: LD_VAR 0 9
52549: INC
52550: ST_TO_ADDR
52551: LD_INT 1
52553: PUSH
52554: FOR_DOWNTO
52555: IFFALSE 52630
// begin if GetType ( tmp [ j ] ) = unit_human then
52557: LD_VAR 0 14
52561: PUSH
52562: LD_VAR 0 8
52566: ARRAY
52567: PPUSH
52568: CALL_OW 247
52572: PUSH
52573: LD_INT 1
52575: EQUAL
52576: IFFALSE 52628
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52578: LD_VAR 0 4
52582: PUSH
52583: LD_VAR 0 7
52587: ARRAY
52588: PPUSH
52589: LD_VAR 0 14
52593: PUSH
52594: LD_VAR 0 8
52598: ARRAY
52599: PPUSH
52600: CALL 48050 0 2
// x := tmp [ j ] ;
52604: LD_ADDR_VAR 0 10
52608: PUSH
52609: LD_VAR 0 14
52613: PUSH
52614: LD_VAR 0 8
52618: ARRAY
52619: ST_TO_ADDR
// attacking := true ;
52620: LD_ADDR_VAR 0 29
52624: PUSH
52625: LD_INT 1
52627: ST_TO_ADDR
// end ; end ;
52628: GO 52554
52630: POP
52631: POP
// if not x then
52632: LD_VAR 0 10
52636: NOT
52637: IFFALSE 52777
// begin attacking := true ;
52639: LD_ADDR_VAR 0 29
52643: PUSH
52644: LD_INT 1
52646: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52647: LD_VAR 0 4
52651: PUSH
52652: LD_VAR 0 7
52656: ARRAY
52657: PPUSH
52658: CALL_OW 250
52662: PPUSH
52663: LD_VAR 0 4
52667: PUSH
52668: LD_VAR 0 7
52672: ARRAY
52673: PPUSH
52674: CALL_OW 251
52678: PPUSH
52679: CALL_OW 546
52683: PUSH
52684: LD_INT 2
52686: ARRAY
52687: PUSH
52688: LD_VAR 0 14
52692: PUSH
52693: LD_INT 1
52695: ARRAY
52696: PPUSH
52697: CALL_OW 250
52701: PPUSH
52702: LD_VAR 0 14
52706: PUSH
52707: LD_INT 1
52709: ARRAY
52710: PPUSH
52711: CALL_OW 251
52715: PPUSH
52716: CALL_OW 546
52720: PUSH
52721: LD_INT 2
52723: ARRAY
52724: EQUAL
52725: IFFALSE 52753
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52727: LD_VAR 0 4
52731: PUSH
52732: LD_VAR 0 7
52736: ARRAY
52737: PPUSH
52738: LD_VAR 0 14
52742: PUSH
52743: LD_INT 1
52745: ARRAY
52746: PPUSH
52747: CALL 48050 0 2
52751: GO 52777
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52753: LD_VAR 0 4
52757: PUSH
52758: LD_VAR 0 7
52762: ARRAY
52763: PPUSH
52764: LD_VAR 0 14
52768: PUSH
52769: LD_INT 1
52771: ARRAY
52772: PPUSH
52773: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52777: LD_VAR 0 4
52781: PUSH
52782: LD_VAR 0 7
52786: ARRAY
52787: PPUSH
52788: CALL_OW 264
52792: PUSH
52793: LD_INT 29
52795: EQUAL
52796: IFFALSE 53162
// begin if WantsToAttack ( group [ i ] ) in bombed then
52798: LD_VAR 0 4
52802: PUSH
52803: LD_VAR 0 7
52807: ARRAY
52808: PPUSH
52809: CALL_OW 319
52813: PUSH
52814: LD_VAR 0 28
52818: IN
52819: IFFALSE 52823
// continue ;
52821: GO 49853
// k := 8 ;
52823: LD_ADDR_VAR 0 9
52827: PUSH
52828: LD_INT 8
52830: ST_TO_ADDR
// x := 0 ;
52831: LD_ADDR_VAR 0 10
52835: PUSH
52836: LD_INT 0
52838: ST_TO_ADDR
// if tmp < k then
52839: LD_VAR 0 14
52843: PUSH
52844: LD_VAR 0 9
52848: LESS
52849: IFFALSE 52861
// k := tmp ;
52851: LD_ADDR_VAR 0 9
52855: PUSH
52856: LD_VAR 0 14
52860: ST_TO_ADDR
// for j = 1 to k do
52861: LD_ADDR_VAR 0 8
52865: PUSH
52866: DOUBLE
52867: LD_INT 1
52869: DEC
52870: ST_TO_ADDR
52871: LD_VAR 0 9
52875: PUSH
52876: FOR_TO
52877: IFFALSE 53009
// begin if GetType ( tmp [ j ] ) = unit_building then
52879: LD_VAR 0 14
52883: PUSH
52884: LD_VAR 0 8
52888: ARRAY
52889: PPUSH
52890: CALL_OW 247
52894: PUSH
52895: LD_INT 3
52897: EQUAL
52898: IFFALSE 53007
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
52900: LD_VAR 0 14
52904: PUSH
52905: LD_VAR 0 8
52909: ARRAY
52910: PUSH
52911: LD_VAR 0 28
52915: IN
52916: NOT
52917: PUSH
52918: LD_VAR 0 14
52922: PUSH
52923: LD_VAR 0 8
52927: ARRAY
52928: PPUSH
52929: CALL_OW 313
52933: AND
52934: IFFALSE 53007
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52936: LD_VAR 0 4
52940: PUSH
52941: LD_VAR 0 7
52945: ARRAY
52946: PPUSH
52947: LD_VAR 0 14
52951: PUSH
52952: LD_VAR 0 8
52956: ARRAY
52957: PPUSH
52958: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
52962: LD_ADDR_VAR 0 28
52966: PUSH
52967: LD_VAR 0 28
52971: PPUSH
52972: LD_VAR 0 28
52976: PUSH
52977: LD_INT 1
52979: PLUS
52980: PPUSH
52981: LD_VAR 0 14
52985: PUSH
52986: LD_VAR 0 8
52990: ARRAY
52991: PPUSH
52992: CALL_OW 1
52996: ST_TO_ADDR
// attacking := true ;
52997: LD_ADDR_VAR 0 29
53001: PUSH
53002: LD_INT 1
53004: ST_TO_ADDR
// break ;
53005: GO 53009
// end ; end ;
53007: GO 52876
53009: POP
53010: POP
// if not attacking and f_attack_depot then
53011: LD_VAR 0 29
53015: NOT
53016: PUSH
53017: LD_VAR 0 25
53021: AND
53022: IFFALSE 53117
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53024: LD_ADDR_VAR 0 13
53028: PUSH
53029: LD_VAR 0 14
53033: PPUSH
53034: LD_INT 2
53036: PUSH
53037: LD_INT 30
53039: PUSH
53040: LD_INT 0
53042: PUSH
53043: EMPTY
53044: LIST
53045: LIST
53046: PUSH
53047: LD_INT 30
53049: PUSH
53050: LD_INT 1
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: LIST
53061: PPUSH
53062: CALL_OW 72
53066: ST_TO_ADDR
// if z then
53067: LD_VAR 0 13
53071: IFFALSE 53117
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53073: LD_VAR 0 4
53077: PUSH
53078: LD_VAR 0 7
53082: ARRAY
53083: PPUSH
53084: LD_VAR 0 13
53088: PPUSH
53089: LD_VAR 0 4
53093: PUSH
53094: LD_VAR 0 7
53098: ARRAY
53099: PPUSH
53100: CALL_OW 74
53104: PPUSH
53105: CALL_OW 115
// attacking := true ;
53109: LD_ADDR_VAR 0 29
53113: PUSH
53114: LD_INT 1
53116: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53117: LD_VAR 0 4
53121: PUSH
53122: LD_VAR 0 7
53126: ARRAY
53127: PPUSH
53128: CALL_OW 256
53132: PUSH
53133: LD_INT 500
53135: LESS
53136: IFFALSE 53162
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53138: LD_VAR 0 4
53142: PUSH
53143: LD_VAR 0 7
53147: ARRAY
53148: PPUSH
53149: LD_VAR 0 14
53153: PUSH
53154: LD_INT 1
53156: ARRAY
53157: PPUSH
53158: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53162: LD_VAR 0 4
53166: PUSH
53167: LD_VAR 0 7
53171: ARRAY
53172: PPUSH
53173: CALL_OW 264
53177: PUSH
53178: LD_INT 49
53180: EQUAL
53181: IFFALSE 53302
// begin if not HasTask ( group [ i ] ) then
53183: LD_VAR 0 4
53187: PUSH
53188: LD_VAR 0 7
53192: ARRAY
53193: PPUSH
53194: CALL_OW 314
53198: NOT
53199: IFFALSE 53302
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53201: LD_ADDR_VAR 0 9
53205: PUSH
53206: LD_INT 81
53208: PUSH
53209: LD_VAR 0 4
53213: PUSH
53214: LD_VAR 0 7
53218: ARRAY
53219: PPUSH
53220: CALL_OW 255
53224: PUSH
53225: EMPTY
53226: LIST
53227: LIST
53228: PPUSH
53229: CALL_OW 69
53233: PPUSH
53234: LD_VAR 0 4
53238: PUSH
53239: LD_VAR 0 7
53243: ARRAY
53244: PPUSH
53245: CALL_OW 74
53249: ST_TO_ADDR
// if k then
53250: LD_VAR 0 9
53254: IFFALSE 53302
// if GetDistUnits ( group [ i ] , k ) > 10 then
53256: LD_VAR 0 4
53260: PUSH
53261: LD_VAR 0 7
53265: ARRAY
53266: PPUSH
53267: LD_VAR 0 9
53271: PPUSH
53272: CALL_OW 296
53276: PUSH
53277: LD_INT 10
53279: GREATER
53280: IFFALSE 53302
// ComMoveUnit ( group [ i ] , k ) ;
53282: LD_VAR 0 4
53286: PUSH
53287: LD_VAR 0 7
53291: ARRAY
53292: PPUSH
53293: LD_VAR 0 9
53297: PPUSH
53298: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53302: LD_VAR 0 4
53306: PUSH
53307: LD_VAR 0 7
53311: ARRAY
53312: PPUSH
53313: CALL_OW 256
53317: PUSH
53318: LD_INT 250
53320: LESS
53321: PUSH
53322: LD_VAR 0 4
53326: PUSH
53327: LD_VAR 0 7
53331: ARRAY
53332: PUSH
53333: LD_INT 21
53335: PUSH
53336: LD_INT 2
53338: PUSH
53339: EMPTY
53340: LIST
53341: LIST
53342: PUSH
53343: LD_INT 23
53345: PUSH
53346: LD_INT 2
53348: PUSH
53349: EMPTY
53350: LIST
53351: LIST
53352: PUSH
53353: EMPTY
53354: LIST
53355: LIST
53356: PPUSH
53357: CALL_OW 69
53361: IN
53362: AND
53363: IFFALSE 53488
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53365: LD_ADDR_VAR 0 9
53369: PUSH
53370: LD_OWVAR 3
53374: PUSH
53375: LD_VAR 0 4
53379: PUSH
53380: LD_VAR 0 7
53384: ARRAY
53385: DIFF
53386: PPUSH
53387: LD_VAR 0 4
53391: PUSH
53392: LD_VAR 0 7
53396: ARRAY
53397: PPUSH
53398: CALL_OW 74
53402: ST_TO_ADDR
// if not k then
53403: LD_VAR 0 9
53407: NOT
53408: IFFALSE 53412
// continue ;
53410: GO 49853
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53412: LD_VAR 0 9
53416: PUSH
53417: LD_INT 81
53419: PUSH
53420: LD_VAR 0 4
53424: PUSH
53425: LD_VAR 0 7
53429: ARRAY
53430: PPUSH
53431: CALL_OW 255
53435: PUSH
53436: EMPTY
53437: LIST
53438: LIST
53439: PPUSH
53440: CALL_OW 69
53444: IN
53445: PUSH
53446: LD_VAR 0 9
53450: PPUSH
53451: LD_VAR 0 4
53455: PUSH
53456: LD_VAR 0 7
53460: ARRAY
53461: PPUSH
53462: CALL_OW 296
53466: PUSH
53467: LD_INT 5
53469: LESS
53470: AND
53471: IFFALSE 53488
// ComAutodestruct ( group [ i ] ) ;
53473: LD_VAR 0 4
53477: PUSH
53478: LD_VAR 0 7
53482: ARRAY
53483: PPUSH
53484: CALL 47948 0 1
// end ; if f_attack_depot then
53488: LD_VAR 0 25
53492: IFFALSE 53604
// begin k := 6 ;
53494: LD_ADDR_VAR 0 9
53498: PUSH
53499: LD_INT 6
53501: ST_TO_ADDR
// if tmp < k then
53502: LD_VAR 0 14
53506: PUSH
53507: LD_VAR 0 9
53511: LESS
53512: IFFALSE 53524
// k := tmp ;
53514: LD_ADDR_VAR 0 9
53518: PUSH
53519: LD_VAR 0 14
53523: ST_TO_ADDR
// for j = 1 to k do
53524: LD_ADDR_VAR 0 8
53528: PUSH
53529: DOUBLE
53530: LD_INT 1
53532: DEC
53533: ST_TO_ADDR
53534: LD_VAR 0 9
53538: PUSH
53539: FOR_TO
53540: IFFALSE 53602
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53542: LD_VAR 0 8
53546: PPUSH
53547: CALL_OW 266
53551: PUSH
53552: LD_INT 0
53554: PUSH
53555: LD_INT 1
53557: PUSH
53558: EMPTY
53559: LIST
53560: LIST
53561: IN
53562: IFFALSE 53600
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53564: LD_VAR 0 4
53568: PUSH
53569: LD_VAR 0 7
53573: ARRAY
53574: PPUSH
53575: LD_VAR 0 14
53579: PUSH
53580: LD_VAR 0 8
53584: ARRAY
53585: PPUSH
53586: CALL_OW 115
// attacking := true ;
53590: LD_ADDR_VAR 0 29
53594: PUSH
53595: LD_INT 1
53597: ST_TO_ADDR
// break ;
53598: GO 53602
// end ;
53600: GO 53539
53602: POP
53603: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53604: LD_VAR 0 4
53608: PUSH
53609: LD_VAR 0 7
53613: ARRAY
53614: PPUSH
53615: CALL_OW 302
53619: PUSH
53620: LD_VAR 0 29
53624: NOT
53625: AND
53626: IFFALSE 53948
// begin if GetTag ( group [ i ] ) = 71 then
53628: LD_VAR 0 4
53632: PUSH
53633: LD_VAR 0 7
53637: ARRAY
53638: PPUSH
53639: CALL_OW 110
53643: PUSH
53644: LD_INT 71
53646: EQUAL
53647: IFFALSE 53688
// begin if HasTask ( group [ i ] ) then
53649: LD_VAR 0 4
53653: PUSH
53654: LD_VAR 0 7
53658: ARRAY
53659: PPUSH
53660: CALL_OW 314
53664: IFFALSE 53670
// continue else
53666: GO 49853
53668: GO 53688
// SetTag ( group [ i ] , 0 ) ;
53670: LD_VAR 0 4
53674: PUSH
53675: LD_VAR 0 7
53679: ARRAY
53680: PPUSH
53681: LD_INT 0
53683: PPUSH
53684: CALL_OW 109
// end ; k := 8 ;
53688: LD_ADDR_VAR 0 9
53692: PUSH
53693: LD_INT 8
53695: ST_TO_ADDR
// x := 0 ;
53696: LD_ADDR_VAR 0 10
53700: PUSH
53701: LD_INT 0
53703: ST_TO_ADDR
// if tmp < k then
53704: LD_VAR 0 14
53708: PUSH
53709: LD_VAR 0 9
53713: LESS
53714: IFFALSE 53726
// k := tmp ;
53716: LD_ADDR_VAR 0 9
53720: PUSH
53721: LD_VAR 0 14
53725: ST_TO_ADDR
// for j = 1 to k do
53726: LD_ADDR_VAR 0 8
53730: PUSH
53731: DOUBLE
53732: LD_INT 1
53734: DEC
53735: ST_TO_ADDR
53736: LD_VAR 0 9
53740: PUSH
53741: FOR_TO
53742: IFFALSE 53840
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53744: LD_VAR 0 14
53748: PUSH
53749: LD_VAR 0 8
53753: ARRAY
53754: PPUSH
53755: CALL_OW 247
53759: PUSH
53760: LD_INT 1
53762: EQUAL
53763: PUSH
53764: LD_VAR 0 14
53768: PUSH
53769: LD_VAR 0 8
53773: ARRAY
53774: PPUSH
53775: CALL_OW 256
53779: PUSH
53780: LD_INT 250
53782: LESS
53783: PUSH
53784: LD_VAR 0 20
53788: AND
53789: PUSH
53790: LD_VAR 0 20
53794: NOT
53795: PUSH
53796: LD_VAR 0 14
53800: PUSH
53801: LD_VAR 0 8
53805: ARRAY
53806: PPUSH
53807: CALL_OW 256
53811: PUSH
53812: LD_INT 250
53814: GREATEREQUAL
53815: AND
53816: OR
53817: AND
53818: IFFALSE 53838
// begin x := tmp [ j ] ;
53820: LD_ADDR_VAR 0 10
53824: PUSH
53825: LD_VAR 0 14
53829: PUSH
53830: LD_VAR 0 8
53834: ARRAY
53835: ST_TO_ADDR
// break ;
53836: GO 53840
// end ;
53838: GO 53741
53840: POP
53841: POP
// if x then
53842: LD_VAR 0 10
53846: IFFALSE 53870
// ComAttackUnit ( group [ i ] , x ) else
53848: LD_VAR 0 4
53852: PUSH
53853: LD_VAR 0 7
53857: ARRAY
53858: PPUSH
53859: LD_VAR 0 10
53863: PPUSH
53864: CALL_OW 115
53868: GO 53894
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53870: LD_VAR 0 4
53874: PUSH
53875: LD_VAR 0 7
53879: ARRAY
53880: PPUSH
53881: LD_VAR 0 14
53885: PUSH
53886: LD_INT 1
53888: ARRAY
53889: PPUSH
53890: CALL_OW 115
// if not HasTask ( group [ i ] ) then
53894: LD_VAR 0 4
53898: PUSH
53899: LD_VAR 0 7
53903: ARRAY
53904: PPUSH
53905: CALL_OW 314
53909: NOT
53910: IFFALSE 53948
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
53912: LD_VAR 0 4
53916: PUSH
53917: LD_VAR 0 7
53921: ARRAY
53922: PPUSH
53923: LD_VAR 0 14
53927: PPUSH
53928: LD_VAR 0 4
53932: PUSH
53933: LD_VAR 0 7
53937: ARRAY
53938: PPUSH
53939: CALL_OW 74
53943: PPUSH
53944: CALL_OW 115
// end ; end ; end ;
53948: GO 49853
53950: POP
53951: POP
// wait ( 0 0$1 ) ;
53952: LD_INT 35
53954: PPUSH
53955: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
53959: LD_VAR 0 4
53963: PUSH
53964: EMPTY
53965: EQUAL
53966: PUSH
53967: LD_INT 81
53969: PUSH
53970: LD_VAR 0 35
53974: PUSH
53975: EMPTY
53976: LIST
53977: LIST
53978: PPUSH
53979: CALL_OW 69
53983: NOT
53984: OR
53985: IFFALSE 49838
// end ;
53987: LD_VAR 0 2
53991: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
53992: LD_INT 0
53994: PPUSH
53995: PPUSH
53996: PPUSH
53997: PPUSH
// if not base_units then
53998: LD_VAR 0 1
54002: NOT
54003: IFFALSE 54007
// exit ;
54005: GO 54094
// result := false ;
54007: LD_ADDR_VAR 0 2
54011: PUSH
54012: LD_INT 0
54014: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54015: LD_ADDR_VAR 0 5
54019: PUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: LD_INT 21
54027: PUSH
54028: LD_INT 3
54030: PUSH
54031: EMPTY
54032: LIST
54033: LIST
54034: PPUSH
54035: CALL_OW 72
54039: ST_TO_ADDR
// if not tmp then
54040: LD_VAR 0 5
54044: NOT
54045: IFFALSE 54049
// exit ;
54047: GO 54094
// for i in tmp do
54049: LD_ADDR_VAR 0 3
54053: PUSH
54054: LD_VAR 0 5
54058: PUSH
54059: FOR_IN
54060: IFFALSE 54092
// begin result := EnemyInRange ( i , 22 ) ;
54062: LD_ADDR_VAR 0 2
54066: PUSH
54067: LD_VAR 0 3
54071: PPUSH
54072: LD_INT 22
54074: PPUSH
54075: CALL 47631 0 2
54079: ST_TO_ADDR
// if result then
54080: LD_VAR 0 2
54084: IFFALSE 54090
// exit ;
54086: POP
54087: POP
54088: GO 54094
// end ;
54090: GO 54059
54092: POP
54093: POP
// end ;
54094: LD_VAR 0 2
54098: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54099: LD_INT 0
54101: PPUSH
54102: PPUSH
// if not units then
54103: LD_VAR 0 1
54107: NOT
54108: IFFALSE 54112
// exit ;
54110: GO 54182
// result := [ ] ;
54112: LD_ADDR_VAR 0 3
54116: PUSH
54117: EMPTY
54118: ST_TO_ADDR
// for i in units do
54119: LD_ADDR_VAR 0 4
54123: PUSH
54124: LD_VAR 0 1
54128: PUSH
54129: FOR_IN
54130: IFFALSE 54180
// if GetTag ( i ) = tag then
54132: LD_VAR 0 4
54136: PPUSH
54137: CALL_OW 110
54141: PUSH
54142: LD_VAR 0 2
54146: EQUAL
54147: IFFALSE 54178
// result := Insert ( result , result + 1 , i ) ;
54149: LD_ADDR_VAR 0 3
54153: PUSH
54154: LD_VAR 0 3
54158: PPUSH
54159: LD_VAR 0 3
54163: PUSH
54164: LD_INT 1
54166: PLUS
54167: PPUSH
54168: LD_VAR 0 4
54172: PPUSH
54173: CALL_OW 2
54177: ST_TO_ADDR
54178: GO 54129
54180: POP
54181: POP
// end ;
54182: LD_VAR 0 3
54186: RET
// export function IsDriver ( un ) ; begin
54187: LD_INT 0
54189: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54190: LD_ADDR_VAR 0 2
54194: PUSH
54195: LD_VAR 0 1
54199: PUSH
54200: LD_INT 55
54202: PUSH
54203: EMPTY
54204: LIST
54205: PPUSH
54206: CALL_OW 69
54210: IN
54211: ST_TO_ADDR
// end ;
54212: LD_VAR 0 2
54216: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54217: LD_INT 0
54219: PPUSH
54220: PPUSH
// list := [ ] ;
54221: LD_ADDR_VAR 0 5
54225: PUSH
54226: EMPTY
54227: ST_TO_ADDR
// case d of 0 :
54228: LD_VAR 0 3
54232: PUSH
54233: LD_INT 0
54235: DOUBLE
54236: EQUAL
54237: IFTRUE 54241
54239: GO 54374
54241: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54242: LD_ADDR_VAR 0 5
54246: PUSH
54247: LD_VAR 0 1
54251: PUSH
54252: LD_INT 4
54254: MINUS
54255: PUSH
54256: LD_VAR 0 2
54260: PUSH
54261: LD_INT 4
54263: MINUS
54264: PUSH
54265: LD_INT 2
54267: PUSH
54268: EMPTY
54269: LIST
54270: LIST
54271: LIST
54272: PUSH
54273: LD_VAR 0 1
54277: PUSH
54278: LD_INT 3
54280: MINUS
54281: PUSH
54282: LD_VAR 0 2
54286: PUSH
54287: LD_INT 1
54289: PUSH
54290: EMPTY
54291: LIST
54292: LIST
54293: LIST
54294: PUSH
54295: LD_VAR 0 1
54299: PUSH
54300: LD_INT 4
54302: PLUS
54303: PUSH
54304: LD_VAR 0 2
54308: PUSH
54309: LD_INT 4
54311: PUSH
54312: EMPTY
54313: LIST
54314: LIST
54315: LIST
54316: PUSH
54317: LD_VAR 0 1
54321: PUSH
54322: LD_INT 3
54324: PLUS
54325: PUSH
54326: LD_VAR 0 2
54330: PUSH
54331: LD_INT 3
54333: PLUS
54334: PUSH
54335: LD_INT 5
54337: PUSH
54338: EMPTY
54339: LIST
54340: LIST
54341: LIST
54342: PUSH
54343: LD_VAR 0 1
54347: PUSH
54348: LD_VAR 0 2
54352: PUSH
54353: LD_INT 4
54355: PLUS
54356: PUSH
54357: LD_INT 0
54359: PUSH
54360: EMPTY
54361: LIST
54362: LIST
54363: LIST
54364: PUSH
54365: EMPTY
54366: LIST
54367: LIST
54368: LIST
54369: LIST
54370: LIST
54371: ST_TO_ADDR
// end ; 1 :
54372: GO 55072
54374: LD_INT 1
54376: DOUBLE
54377: EQUAL
54378: IFTRUE 54382
54380: GO 54515
54382: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54383: LD_ADDR_VAR 0 5
54387: PUSH
54388: LD_VAR 0 1
54392: PUSH
54393: LD_VAR 0 2
54397: PUSH
54398: LD_INT 4
54400: MINUS
54401: PUSH
54402: LD_INT 3
54404: PUSH
54405: EMPTY
54406: LIST
54407: LIST
54408: LIST
54409: PUSH
54410: LD_VAR 0 1
54414: PUSH
54415: LD_INT 3
54417: MINUS
54418: PUSH
54419: LD_VAR 0 2
54423: PUSH
54424: LD_INT 3
54426: MINUS
54427: PUSH
54428: LD_INT 2
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: LIST
54435: PUSH
54436: LD_VAR 0 1
54440: PUSH
54441: LD_INT 4
54443: MINUS
54444: PUSH
54445: LD_VAR 0 2
54449: PUSH
54450: LD_INT 1
54452: PUSH
54453: EMPTY
54454: LIST
54455: LIST
54456: LIST
54457: PUSH
54458: LD_VAR 0 1
54462: PUSH
54463: LD_VAR 0 2
54467: PUSH
54468: LD_INT 3
54470: PLUS
54471: PUSH
54472: LD_INT 0
54474: PUSH
54475: EMPTY
54476: LIST
54477: LIST
54478: LIST
54479: PUSH
54480: LD_VAR 0 1
54484: PUSH
54485: LD_INT 4
54487: PLUS
54488: PUSH
54489: LD_VAR 0 2
54493: PUSH
54494: LD_INT 4
54496: PLUS
54497: PUSH
54498: LD_INT 5
54500: PUSH
54501: EMPTY
54502: LIST
54503: LIST
54504: LIST
54505: PUSH
54506: EMPTY
54507: LIST
54508: LIST
54509: LIST
54510: LIST
54511: LIST
54512: ST_TO_ADDR
// end ; 2 :
54513: GO 55072
54515: LD_INT 2
54517: DOUBLE
54518: EQUAL
54519: IFTRUE 54523
54521: GO 54652
54523: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54524: LD_ADDR_VAR 0 5
54528: PUSH
54529: LD_VAR 0 1
54533: PUSH
54534: LD_VAR 0 2
54538: PUSH
54539: LD_INT 3
54541: MINUS
54542: PUSH
54543: LD_INT 3
54545: PUSH
54546: EMPTY
54547: LIST
54548: LIST
54549: LIST
54550: PUSH
54551: LD_VAR 0 1
54555: PUSH
54556: LD_INT 4
54558: PLUS
54559: PUSH
54560: LD_VAR 0 2
54564: PUSH
54565: LD_INT 4
54567: PUSH
54568: EMPTY
54569: LIST
54570: LIST
54571: LIST
54572: PUSH
54573: LD_VAR 0 1
54577: PUSH
54578: LD_VAR 0 2
54582: PUSH
54583: LD_INT 4
54585: PLUS
54586: PUSH
54587: LD_INT 0
54589: PUSH
54590: EMPTY
54591: LIST
54592: LIST
54593: LIST
54594: PUSH
54595: LD_VAR 0 1
54599: PUSH
54600: LD_INT 3
54602: MINUS
54603: PUSH
54604: LD_VAR 0 2
54608: PUSH
54609: LD_INT 1
54611: PUSH
54612: EMPTY
54613: LIST
54614: LIST
54615: LIST
54616: PUSH
54617: LD_VAR 0 1
54621: PUSH
54622: LD_INT 4
54624: MINUS
54625: PUSH
54626: LD_VAR 0 2
54630: PUSH
54631: LD_INT 4
54633: MINUS
54634: PUSH
54635: LD_INT 2
54637: PUSH
54638: EMPTY
54639: LIST
54640: LIST
54641: LIST
54642: PUSH
54643: EMPTY
54644: LIST
54645: LIST
54646: LIST
54647: LIST
54648: LIST
54649: ST_TO_ADDR
// end ; 3 :
54650: GO 55072
54652: LD_INT 3
54654: DOUBLE
54655: EQUAL
54656: IFTRUE 54660
54658: GO 54793
54660: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54661: LD_ADDR_VAR 0 5
54665: PUSH
54666: LD_VAR 0 1
54670: PUSH
54671: LD_INT 3
54673: PLUS
54674: PUSH
54675: LD_VAR 0 2
54679: PUSH
54680: LD_INT 4
54682: PUSH
54683: EMPTY
54684: LIST
54685: LIST
54686: LIST
54687: PUSH
54688: LD_VAR 0 1
54692: PUSH
54693: LD_INT 4
54695: PLUS
54696: PUSH
54697: LD_VAR 0 2
54701: PUSH
54702: LD_INT 4
54704: PLUS
54705: PUSH
54706: LD_INT 5
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: PUSH
54714: LD_VAR 0 1
54718: PUSH
54719: LD_INT 4
54721: MINUS
54722: PUSH
54723: LD_VAR 0 2
54727: PUSH
54728: LD_INT 1
54730: PUSH
54731: EMPTY
54732: LIST
54733: LIST
54734: LIST
54735: PUSH
54736: LD_VAR 0 1
54740: PUSH
54741: LD_VAR 0 2
54745: PUSH
54746: LD_INT 4
54748: MINUS
54749: PUSH
54750: LD_INT 3
54752: PUSH
54753: EMPTY
54754: LIST
54755: LIST
54756: LIST
54757: PUSH
54758: LD_VAR 0 1
54762: PUSH
54763: LD_INT 3
54765: MINUS
54766: PUSH
54767: LD_VAR 0 2
54771: PUSH
54772: LD_INT 3
54774: MINUS
54775: PUSH
54776: LD_INT 2
54778: PUSH
54779: EMPTY
54780: LIST
54781: LIST
54782: LIST
54783: PUSH
54784: EMPTY
54785: LIST
54786: LIST
54787: LIST
54788: LIST
54789: LIST
54790: ST_TO_ADDR
// end ; 4 :
54791: GO 55072
54793: LD_INT 4
54795: DOUBLE
54796: EQUAL
54797: IFTRUE 54801
54799: GO 54934
54801: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
54802: LD_ADDR_VAR 0 5
54806: PUSH
54807: LD_VAR 0 1
54811: PUSH
54812: LD_VAR 0 2
54816: PUSH
54817: LD_INT 4
54819: PLUS
54820: PUSH
54821: LD_INT 0
54823: PUSH
54824: EMPTY
54825: LIST
54826: LIST
54827: LIST
54828: PUSH
54829: LD_VAR 0 1
54833: PUSH
54834: LD_INT 3
54836: PLUS
54837: PUSH
54838: LD_VAR 0 2
54842: PUSH
54843: LD_INT 3
54845: PLUS
54846: PUSH
54847: LD_INT 5
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: PUSH
54855: LD_VAR 0 1
54859: PUSH
54860: LD_INT 4
54862: PLUS
54863: PUSH
54864: LD_VAR 0 2
54868: PUSH
54869: LD_INT 4
54871: PUSH
54872: EMPTY
54873: LIST
54874: LIST
54875: LIST
54876: PUSH
54877: LD_VAR 0 1
54881: PUSH
54882: LD_VAR 0 2
54886: PUSH
54887: LD_INT 3
54889: MINUS
54890: PUSH
54891: LD_INT 3
54893: PUSH
54894: EMPTY
54895: LIST
54896: LIST
54897: LIST
54898: PUSH
54899: LD_VAR 0 1
54903: PUSH
54904: LD_INT 4
54906: MINUS
54907: PUSH
54908: LD_VAR 0 2
54912: PUSH
54913: LD_INT 4
54915: MINUS
54916: PUSH
54917: LD_INT 2
54919: PUSH
54920: EMPTY
54921: LIST
54922: LIST
54923: LIST
54924: PUSH
54925: EMPTY
54926: LIST
54927: LIST
54928: LIST
54929: LIST
54930: LIST
54931: ST_TO_ADDR
// end ; 5 :
54932: GO 55072
54934: LD_INT 5
54936: DOUBLE
54937: EQUAL
54938: IFTRUE 54942
54940: GO 55071
54942: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
54943: LD_ADDR_VAR 0 5
54947: PUSH
54948: LD_VAR 0 1
54952: PUSH
54953: LD_INT 4
54955: MINUS
54956: PUSH
54957: LD_VAR 0 2
54961: PUSH
54962: LD_INT 1
54964: PUSH
54965: EMPTY
54966: LIST
54967: LIST
54968: LIST
54969: PUSH
54970: LD_VAR 0 1
54974: PUSH
54975: LD_VAR 0 2
54979: PUSH
54980: LD_INT 4
54982: MINUS
54983: PUSH
54984: LD_INT 3
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: PUSH
54992: LD_VAR 0 1
54996: PUSH
54997: LD_INT 4
54999: PLUS
55000: PUSH
55001: LD_VAR 0 2
55005: PUSH
55006: LD_INT 4
55008: PLUS
55009: PUSH
55010: LD_INT 5
55012: PUSH
55013: EMPTY
55014: LIST
55015: LIST
55016: LIST
55017: PUSH
55018: LD_VAR 0 1
55022: PUSH
55023: LD_INT 3
55025: PLUS
55026: PUSH
55027: LD_VAR 0 2
55031: PUSH
55032: LD_INT 4
55034: PUSH
55035: EMPTY
55036: LIST
55037: LIST
55038: LIST
55039: PUSH
55040: LD_VAR 0 1
55044: PUSH
55045: LD_VAR 0 2
55049: PUSH
55050: LD_INT 3
55052: PLUS
55053: PUSH
55054: LD_INT 0
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: LIST
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: LIST
55066: LIST
55067: LIST
55068: ST_TO_ADDR
// end ; end ;
55069: GO 55072
55071: POP
// result := list ;
55072: LD_ADDR_VAR 0 4
55076: PUSH
55077: LD_VAR 0 5
55081: ST_TO_ADDR
// end ;
55082: LD_VAR 0 4
55086: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55087: LD_INT 0
55089: PPUSH
55090: PPUSH
55091: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55092: LD_VAR 0 1
55096: NOT
55097: PUSH
55098: LD_VAR 0 2
55102: PUSH
55103: LD_INT 1
55105: PUSH
55106: LD_INT 2
55108: PUSH
55109: LD_INT 3
55111: PUSH
55112: LD_INT 4
55114: PUSH
55115: EMPTY
55116: LIST
55117: LIST
55118: LIST
55119: LIST
55120: IN
55121: NOT
55122: OR
55123: IFFALSE 55127
// exit ;
55125: GO 55219
// tmp := [ ] ;
55127: LD_ADDR_VAR 0 5
55131: PUSH
55132: EMPTY
55133: ST_TO_ADDR
// for i in units do
55134: LD_ADDR_VAR 0 4
55138: PUSH
55139: LD_VAR 0 1
55143: PUSH
55144: FOR_IN
55145: IFFALSE 55188
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55147: LD_ADDR_VAR 0 5
55151: PUSH
55152: LD_VAR 0 5
55156: PPUSH
55157: LD_VAR 0 5
55161: PUSH
55162: LD_INT 1
55164: PLUS
55165: PPUSH
55166: LD_VAR 0 4
55170: PPUSH
55171: LD_VAR 0 2
55175: PPUSH
55176: CALL_OW 259
55180: PPUSH
55181: CALL_OW 2
55185: ST_TO_ADDR
55186: GO 55144
55188: POP
55189: POP
// if not tmp then
55190: LD_VAR 0 5
55194: NOT
55195: IFFALSE 55199
// exit ;
55197: GO 55219
// result := SortListByListDesc ( units , tmp ) ;
55199: LD_ADDR_VAR 0 3
55203: PUSH
55204: LD_VAR 0 1
55208: PPUSH
55209: LD_VAR 0 5
55213: PPUSH
55214: CALL_OW 77
55218: ST_TO_ADDR
// end ;
55219: LD_VAR 0 3
55223: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55224: LD_INT 0
55226: PPUSH
55227: PPUSH
55228: PPUSH
// x := GetX ( building ) ;
55229: LD_ADDR_VAR 0 4
55233: PUSH
55234: LD_VAR 0 2
55238: PPUSH
55239: CALL_OW 250
55243: ST_TO_ADDR
// y := GetY ( building ) ;
55244: LD_ADDR_VAR 0 5
55248: PUSH
55249: LD_VAR 0 2
55253: PPUSH
55254: CALL_OW 251
55258: ST_TO_ADDR
// if GetTaskList ( unit ) then
55259: LD_VAR 0 1
55263: PPUSH
55264: CALL_OW 437
55268: IFFALSE 55363
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55270: LD_STRING e
55272: PUSH
55273: LD_VAR 0 1
55277: PPUSH
55278: CALL_OW 437
55282: PUSH
55283: LD_INT 1
55285: ARRAY
55286: PUSH
55287: LD_INT 1
55289: ARRAY
55290: EQUAL
55291: PUSH
55292: LD_VAR 0 4
55296: PUSH
55297: LD_VAR 0 1
55301: PPUSH
55302: CALL_OW 437
55306: PUSH
55307: LD_INT 1
55309: ARRAY
55310: PUSH
55311: LD_INT 2
55313: ARRAY
55314: EQUAL
55315: AND
55316: PUSH
55317: LD_VAR 0 5
55321: PUSH
55322: LD_VAR 0 1
55326: PPUSH
55327: CALL_OW 437
55331: PUSH
55332: LD_INT 1
55334: ARRAY
55335: PUSH
55336: LD_INT 3
55338: ARRAY
55339: EQUAL
55340: AND
55341: IFFALSE 55353
// result := true else
55343: LD_ADDR_VAR 0 3
55347: PUSH
55348: LD_INT 1
55350: ST_TO_ADDR
55351: GO 55361
// result := false ;
55353: LD_ADDR_VAR 0 3
55357: PUSH
55358: LD_INT 0
55360: ST_TO_ADDR
// end else
55361: GO 55371
// result := false ;
55363: LD_ADDR_VAR 0 3
55367: PUSH
55368: LD_INT 0
55370: ST_TO_ADDR
// end ;
55371: LD_VAR 0 3
55375: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55376: LD_INT 0
55378: PPUSH
55379: PPUSH
55380: PPUSH
55381: PPUSH
// if not unit or not area then
55382: LD_VAR 0 1
55386: NOT
55387: PUSH
55388: LD_VAR 0 2
55392: NOT
55393: OR
55394: IFFALSE 55398
// exit ;
55396: GO 55562
// tmp := AreaToList ( area , i ) ;
55398: LD_ADDR_VAR 0 6
55402: PUSH
55403: LD_VAR 0 2
55407: PPUSH
55408: LD_VAR 0 5
55412: PPUSH
55413: CALL_OW 517
55417: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55418: LD_ADDR_VAR 0 5
55422: PUSH
55423: DOUBLE
55424: LD_INT 1
55426: DEC
55427: ST_TO_ADDR
55428: LD_VAR 0 6
55432: PUSH
55433: LD_INT 1
55435: ARRAY
55436: PUSH
55437: FOR_TO
55438: IFFALSE 55560
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55440: LD_ADDR_VAR 0 7
55444: PUSH
55445: LD_VAR 0 6
55449: PUSH
55450: LD_INT 1
55452: ARRAY
55453: PUSH
55454: LD_VAR 0 5
55458: ARRAY
55459: PUSH
55460: LD_VAR 0 6
55464: PUSH
55465: LD_INT 2
55467: ARRAY
55468: PUSH
55469: LD_VAR 0 5
55473: ARRAY
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55479: LD_VAR 0 7
55483: PUSH
55484: LD_INT 1
55486: ARRAY
55487: PPUSH
55488: LD_VAR 0 7
55492: PUSH
55493: LD_INT 2
55495: ARRAY
55496: PPUSH
55497: CALL_OW 428
55501: PUSH
55502: LD_INT 0
55504: EQUAL
55505: IFFALSE 55558
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55507: LD_VAR 0 1
55511: PPUSH
55512: LD_VAR 0 7
55516: PUSH
55517: LD_INT 1
55519: ARRAY
55520: PPUSH
55521: LD_VAR 0 7
55525: PUSH
55526: LD_INT 2
55528: ARRAY
55529: PPUSH
55530: LD_VAR 0 3
55534: PPUSH
55535: CALL_OW 48
// result := IsPlaced ( unit ) ;
55539: LD_ADDR_VAR 0 4
55543: PUSH
55544: LD_VAR 0 1
55548: PPUSH
55549: CALL_OW 305
55553: ST_TO_ADDR
// exit ;
55554: POP
55555: POP
55556: GO 55562
// end ; end ;
55558: GO 55437
55560: POP
55561: POP
// end ;
55562: LD_VAR 0 4
55566: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55567: LD_INT 0
55569: PPUSH
55570: PPUSH
55571: PPUSH
// if not side or side > 8 then
55572: LD_VAR 0 1
55576: NOT
55577: PUSH
55578: LD_VAR 0 1
55582: PUSH
55583: LD_INT 8
55585: GREATER
55586: OR
55587: IFFALSE 55591
// exit ;
55589: GO 55778
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55591: LD_ADDR_VAR 0 4
55595: PUSH
55596: LD_INT 22
55598: PUSH
55599: LD_VAR 0 1
55603: PUSH
55604: EMPTY
55605: LIST
55606: LIST
55607: PUSH
55608: LD_INT 21
55610: PUSH
55611: LD_INT 3
55613: PUSH
55614: EMPTY
55615: LIST
55616: LIST
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: PPUSH
55622: CALL_OW 69
55626: ST_TO_ADDR
// if not tmp then
55627: LD_VAR 0 4
55631: NOT
55632: IFFALSE 55636
// exit ;
55634: GO 55778
// enable_addtolog := true ;
55636: LD_ADDR_OWVAR 81
55640: PUSH
55641: LD_INT 1
55643: ST_TO_ADDR
// AddToLog ( [ ) ;
55644: LD_STRING [
55646: PPUSH
55647: CALL_OW 561
// for i in tmp do
55651: LD_ADDR_VAR 0 3
55655: PUSH
55656: LD_VAR 0 4
55660: PUSH
55661: FOR_IN
55662: IFFALSE 55769
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55664: LD_STRING [
55666: PUSH
55667: LD_VAR 0 3
55671: PPUSH
55672: CALL_OW 266
55676: STR
55677: PUSH
55678: LD_STRING , 
55680: STR
55681: PUSH
55682: LD_VAR 0 3
55686: PPUSH
55687: CALL_OW 250
55691: STR
55692: PUSH
55693: LD_STRING , 
55695: STR
55696: PUSH
55697: LD_VAR 0 3
55701: PPUSH
55702: CALL_OW 251
55706: STR
55707: PUSH
55708: LD_STRING , 
55710: STR
55711: PUSH
55712: LD_VAR 0 3
55716: PPUSH
55717: CALL_OW 254
55721: STR
55722: PUSH
55723: LD_STRING , 
55725: STR
55726: PUSH
55727: LD_VAR 0 3
55731: PPUSH
55732: LD_INT 1
55734: PPUSH
55735: CALL_OW 268
55739: STR
55740: PUSH
55741: LD_STRING , 
55743: STR
55744: PUSH
55745: LD_VAR 0 3
55749: PPUSH
55750: LD_INT 2
55752: PPUSH
55753: CALL_OW 268
55757: STR
55758: PUSH
55759: LD_STRING ],
55761: STR
55762: PPUSH
55763: CALL_OW 561
// end ;
55767: GO 55661
55769: POP
55770: POP
// AddToLog ( ]; ) ;
55771: LD_STRING ];
55773: PPUSH
55774: CALL_OW 561
// end ;
55778: LD_VAR 0 2
55782: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55783: LD_INT 0
55785: PPUSH
55786: PPUSH
55787: PPUSH
55788: PPUSH
55789: PPUSH
// if not area or not rate or not max then
55790: LD_VAR 0 1
55794: NOT
55795: PUSH
55796: LD_VAR 0 2
55800: NOT
55801: OR
55802: PUSH
55803: LD_VAR 0 4
55807: NOT
55808: OR
55809: IFFALSE 55813
// exit ;
55811: GO 56005
// while 1 do
55813: LD_INT 1
55815: IFFALSE 56005
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
55817: LD_ADDR_VAR 0 9
55821: PUSH
55822: LD_VAR 0 1
55826: PPUSH
55827: LD_INT 1
55829: PPUSH
55830: CALL_OW 287
55834: PUSH
55835: LD_INT 10
55837: MUL
55838: ST_TO_ADDR
// r := rate / 10 ;
55839: LD_ADDR_VAR 0 7
55843: PUSH
55844: LD_VAR 0 2
55848: PUSH
55849: LD_INT 10
55851: DIVREAL
55852: ST_TO_ADDR
// time := 1 1$00 ;
55853: LD_ADDR_VAR 0 8
55857: PUSH
55858: LD_INT 2100
55860: ST_TO_ADDR
// if amount < min then
55861: LD_VAR 0 9
55865: PUSH
55866: LD_VAR 0 3
55870: LESS
55871: IFFALSE 55889
// r := r * 2 else
55873: LD_ADDR_VAR 0 7
55877: PUSH
55878: LD_VAR 0 7
55882: PUSH
55883: LD_INT 2
55885: MUL
55886: ST_TO_ADDR
55887: GO 55915
// if amount > max then
55889: LD_VAR 0 9
55893: PUSH
55894: LD_VAR 0 4
55898: GREATER
55899: IFFALSE 55915
// r := r / 2 ;
55901: LD_ADDR_VAR 0 7
55905: PUSH
55906: LD_VAR 0 7
55910: PUSH
55911: LD_INT 2
55913: DIVREAL
55914: ST_TO_ADDR
// time := time / r ;
55915: LD_ADDR_VAR 0 8
55919: PUSH
55920: LD_VAR 0 8
55924: PUSH
55925: LD_VAR 0 7
55929: DIVREAL
55930: ST_TO_ADDR
// if time < 0 then
55931: LD_VAR 0 8
55935: PUSH
55936: LD_INT 0
55938: LESS
55939: IFFALSE 55956
// time := time * - 1 ;
55941: LD_ADDR_VAR 0 8
55945: PUSH
55946: LD_VAR 0 8
55950: PUSH
55951: LD_INT 1
55953: NEG
55954: MUL
55955: ST_TO_ADDR
// wait ( time ) ;
55956: LD_VAR 0 8
55960: PPUSH
55961: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
55965: LD_INT 35
55967: PPUSH
55968: LD_INT 875
55970: PPUSH
55971: CALL_OW 12
55975: PPUSH
55976: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
55980: LD_INT 1
55982: PPUSH
55983: LD_INT 5
55985: PPUSH
55986: CALL_OW 12
55990: PPUSH
55991: LD_VAR 0 1
55995: PPUSH
55996: LD_INT 1
55998: PPUSH
55999: CALL_OW 55
// end ;
56003: GO 55813
// end ;
56005: LD_VAR 0 5
56009: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56010: LD_INT 0
56012: PPUSH
56013: PPUSH
56014: PPUSH
56015: PPUSH
56016: PPUSH
56017: PPUSH
56018: PPUSH
56019: PPUSH
// if not turrets or not factories then
56020: LD_VAR 0 1
56024: NOT
56025: PUSH
56026: LD_VAR 0 2
56030: NOT
56031: OR
56032: IFFALSE 56036
// exit ;
56034: GO 56343
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56036: LD_ADDR_VAR 0 10
56040: PUSH
56041: LD_INT 5
56043: PUSH
56044: LD_INT 6
56046: PUSH
56047: EMPTY
56048: LIST
56049: LIST
56050: PUSH
56051: LD_INT 2
56053: PUSH
56054: LD_INT 4
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: PUSH
56061: LD_INT 3
56063: PUSH
56064: LD_INT 5
56066: PUSH
56067: EMPTY
56068: LIST
56069: LIST
56070: PUSH
56071: EMPTY
56072: LIST
56073: LIST
56074: LIST
56075: PUSH
56076: LD_INT 24
56078: PUSH
56079: LD_INT 25
56081: PUSH
56082: EMPTY
56083: LIST
56084: LIST
56085: PUSH
56086: LD_INT 23
56088: PUSH
56089: LD_INT 27
56091: PUSH
56092: EMPTY
56093: LIST
56094: LIST
56095: PUSH
56096: EMPTY
56097: LIST
56098: LIST
56099: PUSH
56100: LD_INT 42
56102: PUSH
56103: LD_INT 43
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: LD_INT 44
56112: PUSH
56113: LD_INT 46
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 45
56122: PUSH
56123: LD_INT 47
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: LIST
56134: PUSH
56135: EMPTY
56136: LIST
56137: LIST
56138: LIST
56139: ST_TO_ADDR
// result := [ ] ;
56140: LD_ADDR_VAR 0 3
56144: PUSH
56145: EMPTY
56146: ST_TO_ADDR
// for i in turrets do
56147: LD_ADDR_VAR 0 4
56151: PUSH
56152: LD_VAR 0 1
56156: PUSH
56157: FOR_IN
56158: IFFALSE 56341
// begin nat := GetNation ( i ) ;
56160: LD_ADDR_VAR 0 7
56164: PUSH
56165: LD_VAR 0 4
56169: PPUSH
56170: CALL_OW 248
56174: ST_TO_ADDR
// weapon := 0 ;
56175: LD_ADDR_VAR 0 8
56179: PUSH
56180: LD_INT 0
56182: ST_TO_ADDR
// if not nat then
56183: LD_VAR 0 7
56187: NOT
56188: IFFALSE 56192
// continue ;
56190: GO 56157
// for j in list [ nat ] do
56192: LD_ADDR_VAR 0 5
56196: PUSH
56197: LD_VAR 0 10
56201: PUSH
56202: LD_VAR 0 7
56206: ARRAY
56207: PUSH
56208: FOR_IN
56209: IFFALSE 56250
// if GetBWeapon ( i ) = j [ 1 ] then
56211: LD_VAR 0 4
56215: PPUSH
56216: CALL_OW 269
56220: PUSH
56221: LD_VAR 0 5
56225: PUSH
56226: LD_INT 1
56228: ARRAY
56229: EQUAL
56230: IFFALSE 56248
// begin weapon := j [ 2 ] ;
56232: LD_ADDR_VAR 0 8
56236: PUSH
56237: LD_VAR 0 5
56241: PUSH
56242: LD_INT 2
56244: ARRAY
56245: ST_TO_ADDR
// break ;
56246: GO 56250
// end ;
56248: GO 56208
56250: POP
56251: POP
// if not weapon then
56252: LD_VAR 0 8
56256: NOT
56257: IFFALSE 56261
// continue ;
56259: GO 56157
// for k in factories do
56261: LD_ADDR_VAR 0 6
56265: PUSH
56266: LD_VAR 0 2
56270: PUSH
56271: FOR_IN
56272: IFFALSE 56337
// begin weapons := AvailableWeaponList ( k ) ;
56274: LD_ADDR_VAR 0 9
56278: PUSH
56279: LD_VAR 0 6
56283: PPUSH
56284: CALL_OW 478
56288: ST_TO_ADDR
// if not weapons then
56289: LD_VAR 0 9
56293: NOT
56294: IFFALSE 56298
// continue ;
56296: GO 56271
// if weapon in weapons then
56298: LD_VAR 0 8
56302: PUSH
56303: LD_VAR 0 9
56307: IN
56308: IFFALSE 56335
// begin result := [ i , weapon ] ;
56310: LD_ADDR_VAR 0 3
56314: PUSH
56315: LD_VAR 0 4
56319: PUSH
56320: LD_VAR 0 8
56324: PUSH
56325: EMPTY
56326: LIST
56327: LIST
56328: ST_TO_ADDR
// exit ;
56329: POP
56330: POP
56331: POP
56332: POP
56333: GO 56343
// end ; end ;
56335: GO 56271
56337: POP
56338: POP
// end ;
56339: GO 56157
56341: POP
56342: POP
// end ;
56343: LD_VAR 0 3
56347: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56348: LD_INT 0
56350: PPUSH
// if not side or side > 8 then
56351: LD_VAR 0 3
56355: NOT
56356: PUSH
56357: LD_VAR 0 3
56361: PUSH
56362: LD_INT 8
56364: GREATER
56365: OR
56366: IFFALSE 56370
// exit ;
56368: GO 56429
// if not range then
56370: LD_VAR 0 4
56374: NOT
56375: IFFALSE 56386
// range := - 12 ;
56377: LD_ADDR_VAR 0 4
56381: PUSH
56382: LD_INT 12
56384: NEG
56385: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56386: LD_VAR 0 1
56390: PPUSH
56391: LD_VAR 0 2
56395: PPUSH
56396: LD_VAR 0 3
56400: PPUSH
56401: LD_VAR 0 4
56405: PPUSH
56406: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56410: LD_VAR 0 1
56414: PPUSH
56415: LD_VAR 0 2
56419: PPUSH
56420: LD_VAR 0 3
56424: PPUSH
56425: CALL_OW 331
// end ;
56429: LD_VAR 0 5
56433: RET
// export function Video ( mode ) ; begin
56434: LD_INT 0
56436: PPUSH
// ingame_video = mode ;
56437: LD_ADDR_OWVAR 52
56441: PUSH
56442: LD_VAR 0 1
56446: ST_TO_ADDR
// interface_hidden = mode ;
56447: LD_ADDR_OWVAR 54
56451: PUSH
56452: LD_VAR 0 1
56456: ST_TO_ADDR
// end ;
56457: LD_VAR 0 2
56461: RET
// export function Join ( array , element ) ; begin
56462: LD_INT 0
56464: PPUSH
// result := array ^ element ;
56465: LD_ADDR_VAR 0 3
56469: PUSH
56470: LD_VAR 0 1
56474: PUSH
56475: LD_VAR 0 2
56479: ADD
56480: ST_TO_ADDR
// end ;
56481: LD_VAR 0 3
56485: RET
// export function JoinUnion ( array , element ) ; begin
56486: LD_INT 0
56488: PPUSH
// result := array union element ;
56489: LD_ADDR_VAR 0 3
56493: PUSH
56494: LD_VAR 0 1
56498: PUSH
56499: LD_VAR 0 2
56503: UNION
56504: ST_TO_ADDR
// end ;
56505: LD_VAR 0 3
56509: RET
// export function GetBehemoths ( side ) ; begin
56510: LD_INT 0
56512: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56513: LD_ADDR_VAR 0 2
56517: PUSH
56518: LD_INT 22
56520: PUSH
56521: LD_VAR 0 1
56525: PUSH
56526: EMPTY
56527: LIST
56528: LIST
56529: PUSH
56530: LD_INT 31
56532: PUSH
56533: LD_INT 25
56535: PUSH
56536: EMPTY
56537: LIST
56538: LIST
56539: PUSH
56540: EMPTY
56541: LIST
56542: LIST
56543: PPUSH
56544: CALL_OW 69
56548: ST_TO_ADDR
// end ;
56549: LD_VAR 0 2
56553: RET
// export function Shuffle ( array ) ; var i , index ; begin
56554: LD_INT 0
56556: PPUSH
56557: PPUSH
56558: PPUSH
// result := [ ] ;
56559: LD_ADDR_VAR 0 2
56563: PUSH
56564: EMPTY
56565: ST_TO_ADDR
// if not array then
56566: LD_VAR 0 1
56570: NOT
56571: IFFALSE 56575
// exit ;
56573: GO 56674
// Randomize ;
56575: CALL_OW 10
// for i = array downto 1 do
56579: LD_ADDR_VAR 0 3
56583: PUSH
56584: DOUBLE
56585: LD_VAR 0 1
56589: INC
56590: ST_TO_ADDR
56591: LD_INT 1
56593: PUSH
56594: FOR_DOWNTO
56595: IFFALSE 56672
// begin index := rand ( 1 , array ) ;
56597: LD_ADDR_VAR 0 4
56601: PUSH
56602: LD_INT 1
56604: PPUSH
56605: LD_VAR 0 1
56609: PPUSH
56610: CALL_OW 12
56614: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56615: LD_ADDR_VAR 0 2
56619: PUSH
56620: LD_VAR 0 2
56624: PPUSH
56625: LD_VAR 0 2
56629: PUSH
56630: LD_INT 1
56632: PLUS
56633: PPUSH
56634: LD_VAR 0 1
56638: PUSH
56639: LD_VAR 0 4
56643: ARRAY
56644: PPUSH
56645: CALL_OW 2
56649: ST_TO_ADDR
// array := Delete ( array , index ) ;
56650: LD_ADDR_VAR 0 1
56654: PUSH
56655: LD_VAR 0 1
56659: PPUSH
56660: LD_VAR 0 4
56664: PPUSH
56665: CALL_OW 3
56669: ST_TO_ADDR
// end ;
56670: GO 56594
56672: POP
56673: POP
// end ;
56674: LD_VAR 0 2
56678: RET
// export function GetBaseMaterials ( base ) ; begin
56679: LD_INT 0
56681: PPUSH
// result := [ 0 , 0 , 0 ] ;
56682: LD_ADDR_VAR 0 2
56686: PUSH
56687: LD_INT 0
56689: PUSH
56690: LD_INT 0
56692: PUSH
56693: LD_INT 0
56695: PUSH
56696: EMPTY
56697: LIST
56698: LIST
56699: LIST
56700: ST_TO_ADDR
// if not base then
56701: LD_VAR 0 1
56705: NOT
56706: IFFALSE 56710
// exit ;
56708: GO 56759
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56710: LD_ADDR_VAR 0 2
56714: PUSH
56715: LD_VAR 0 1
56719: PPUSH
56720: LD_INT 1
56722: PPUSH
56723: CALL_OW 275
56727: PUSH
56728: LD_VAR 0 1
56732: PPUSH
56733: LD_INT 2
56735: PPUSH
56736: CALL_OW 275
56740: PUSH
56741: LD_VAR 0 1
56745: PPUSH
56746: LD_INT 3
56748: PPUSH
56749: CALL_OW 275
56753: PUSH
56754: EMPTY
56755: LIST
56756: LIST
56757: LIST
56758: ST_TO_ADDR
// end ; end_of_file
56759: LD_VAR 0 2
56763: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56764: LD_INT 0
56766: PPUSH
56767: PPUSH
// skirmish := false ;
56768: LD_ADDR_EXP 56
56772: PUSH
56773: LD_INT 0
56775: ST_TO_ADDR
// debug_mc := false ;
56776: LD_ADDR_EXP 57
56780: PUSH
56781: LD_INT 0
56783: ST_TO_ADDR
// mc_bases := [ ] ;
56784: LD_ADDR_EXP 58
56788: PUSH
56789: EMPTY
56790: ST_TO_ADDR
// mc_sides := [ ] ;
56791: LD_ADDR_EXP 84
56795: PUSH
56796: EMPTY
56797: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56798: LD_ADDR_EXP 59
56802: PUSH
56803: EMPTY
56804: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56805: LD_ADDR_EXP 60
56809: PUSH
56810: EMPTY
56811: ST_TO_ADDR
// mc_need_heal := [ ] ;
56812: LD_ADDR_EXP 61
56816: PUSH
56817: EMPTY
56818: ST_TO_ADDR
// mc_healers := [ ] ;
56819: LD_ADDR_EXP 62
56823: PUSH
56824: EMPTY
56825: ST_TO_ADDR
// mc_build_list := [ ] ;
56826: LD_ADDR_EXP 63
56830: PUSH
56831: EMPTY
56832: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56833: LD_ADDR_EXP 90
56837: PUSH
56838: EMPTY
56839: ST_TO_ADDR
// mc_builders := [ ] ;
56840: LD_ADDR_EXP 64
56844: PUSH
56845: EMPTY
56846: ST_TO_ADDR
// mc_construct_list := [ ] ;
56847: LD_ADDR_EXP 65
56851: PUSH
56852: EMPTY
56853: ST_TO_ADDR
// mc_turret_list := [ ] ;
56854: LD_ADDR_EXP 66
56858: PUSH
56859: EMPTY
56860: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56861: LD_ADDR_EXP 67
56865: PUSH
56866: EMPTY
56867: ST_TO_ADDR
// mc_miners := [ ] ;
56868: LD_ADDR_EXP 72
56872: PUSH
56873: EMPTY
56874: ST_TO_ADDR
// mc_mines := [ ] ;
56875: LD_ADDR_EXP 71
56879: PUSH
56880: EMPTY
56881: ST_TO_ADDR
// mc_minefields := [ ] ;
56882: LD_ADDR_EXP 73
56886: PUSH
56887: EMPTY
56888: ST_TO_ADDR
// mc_crates := [ ] ;
56889: LD_ADDR_EXP 74
56893: PUSH
56894: EMPTY
56895: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56896: LD_ADDR_EXP 75
56900: PUSH
56901: EMPTY
56902: ST_TO_ADDR
// mc_crates_area := [ ] ;
56903: LD_ADDR_EXP 76
56907: PUSH
56908: EMPTY
56909: ST_TO_ADDR
// mc_vehicles := [ ] ;
56910: LD_ADDR_EXP 77
56914: PUSH
56915: EMPTY
56916: ST_TO_ADDR
// mc_attack := [ ] ;
56917: LD_ADDR_EXP 78
56921: PUSH
56922: EMPTY
56923: ST_TO_ADDR
// mc_produce := [ ] ;
56924: LD_ADDR_EXP 79
56928: PUSH
56929: EMPTY
56930: ST_TO_ADDR
// mc_defender := [ ] ;
56931: LD_ADDR_EXP 80
56935: PUSH
56936: EMPTY
56937: ST_TO_ADDR
// mc_parking := [ ] ;
56938: LD_ADDR_EXP 82
56942: PUSH
56943: EMPTY
56944: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56945: LD_ADDR_EXP 68
56949: PUSH
56950: EMPTY
56951: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56952: LD_ADDR_EXP 70
56956: PUSH
56957: EMPTY
56958: ST_TO_ADDR
// mc_scan := [ ] ;
56959: LD_ADDR_EXP 81
56963: PUSH
56964: EMPTY
56965: ST_TO_ADDR
// mc_scan_area := [ ] ;
56966: LD_ADDR_EXP 83
56970: PUSH
56971: EMPTY
56972: ST_TO_ADDR
// mc_tech := [ ] ;
56973: LD_ADDR_EXP 85
56977: PUSH
56978: EMPTY
56979: ST_TO_ADDR
// mc_class := [ ] ;
56980: LD_ADDR_EXP 99
56984: PUSH
56985: EMPTY
56986: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56987: LD_ADDR_EXP 100
56991: PUSH
56992: EMPTY
56993: ST_TO_ADDR
// end ;
56994: LD_VAR 0 1
56998: RET
// export function MC_Kill ( base ) ; begin
56999: LD_INT 0
57001: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57002: LD_ADDR_EXP 58
57006: PUSH
57007: LD_EXP 58
57011: PPUSH
57012: LD_VAR 0 1
57016: PPUSH
57017: EMPTY
57018: PPUSH
57019: CALL_OW 1
57023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57024: LD_ADDR_EXP 59
57028: PUSH
57029: LD_EXP 59
57033: PPUSH
57034: LD_VAR 0 1
57038: PPUSH
57039: EMPTY
57040: PPUSH
57041: CALL_OW 1
57045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57046: LD_ADDR_EXP 60
57050: PUSH
57051: LD_EXP 60
57055: PPUSH
57056: LD_VAR 0 1
57060: PPUSH
57061: EMPTY
57062: PPUSH
57063: CALL_OW 1
57067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57068: LD_ADDR_EXP 61
57072: PUSH
57073: LD_EXP 61
57077: PPUSH
57078: LD_VAR 0 1
57082: PPUSH
57083: EMPTY
57084: PPUSH
57085: CALL_OW 1
57089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57090: LD_ADDR_EXP 62
57094: PUSH
57095: LD_EXP 62
57099: PPUSH
57100: LD_VAR 0 1
57104: PPUSH
57105: EMPTY
57106: PPUSH
57107: CALL_OW 1
57111: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57112: LD_ADDR_EXP 63
57116: PUSH
57117: LD_EXP 63
57121: PPUSH
57122: LD_VAR 0 1
57126: PPUSH
57127: EMPTY
57128: PPUSH
57129: CALL_OW 1
57133: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57134: LD_ADDR_EXP 64
57138: PUSH
57139: LD_EXP 64
57143: PPUSH
57144: LD_VAR 0 1
57148: PPUSH
57149: EMPTY
57150: PPUSH
57151: CALL_OW 1
57155: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57156: LD_ADDR_EXP 65
57160: PUSH
57161: LD_EXP 65
57165: PPUSH
57166: LD_VAR 0 1
57170: PPUSH
57171: EMPTY
57172: PPUSH
57173: CALL_OW 1
57177: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57178: LD_ADDR_EXP 66
57182: PUSH
57183: LD_EXP 66
57187: PPUSH
57188: LD_VAR 0 1
57192: PPUSH
57193: EMPTY
57194: PPUSH
57195: CALL_OW 1
57199: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57200: LD_ADDR_EXP 67
57204: PUSH
57205: LD_EXP 67
57209: PPUSH
57210: LD_VAR 0 1
57214: PPUSH
57215: EMPTY
57216: PPUSH
57217: CALL_OW 1
57221: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57222: LD_ADDR_EXP 68
57226: PUSH
57227: LD_EXP 68
57231: PPUSH
57232: LD_VAR 0 1
57236: PPUSH
57237: EMPTY
57238: PPUSH
57239: CALL_OW 1
57243: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57244: LD_ADDR_EXP 69
57248: PUSH
57249: LD_EXP 69
57253: PPUSH
57254: LD_VAR 0 1
57258: PPUSH
57259: LD_INT 0
57261: PPUSH
57262: CALL_OW 1
57266: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57267: LD_ADDR_EXP 70
57271: PUSH
57272: LD_EXP 70
57276: PPUSH
57277: LD_VAR 0 1
57281: PPUSH
57282: EMPTY
57283: PPUSH
57284: CALL_OW 1
57288: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57289: LD_ADDR_EXP 71
57293: PUSH
57294: LD_EXP 71
57298: PPUSH
57299: LD_VAR 0 1
57303: PPUSH
57304: EMPTY
57305: PPUSH
57306: CALL_OW 1
57310: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57311: LD_ADDR_EXP 72
57315: PUSH
57316: LD_EXP 72
57320: PPUSH
57321: LD_VAR 0 1
57325: PPUSH
57326: EMPTY
57327: PPUSH
57328: CALL_OW 1
57332: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57333: LD_ADDR_EXP 73
57337: PUSH
57338: LD_EXP 73
57342: PPUSH
57343: LD_VAR 0 1
57347: PPUSH
57348: EMPTY
57349: PPUSH
57350: CALL_OW 1
57354: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57355: LD_ADDR_EXP 74
57359: PUSH
57360: LD_EXP 74
57364: PPUSH
57365: LD_VAR 0 1
57369: PPUSH
57370: EMPTY
57371: PPUSH
57372: CALL_OW 1
57376: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57377: LD_ADDR_EXP 75
57381: PUSH
57382: LD_EXP 75
57386: PPUSH
57387: LD_VAR 0 1
57391: PPUSH
57392: EMPTY
57393: PPUSH
57394: CALL_OW 1
57398: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57399: LD_ADDR_EXP 76
57403: PUSH
57404: LD_EXP 76
57408: PPUSH
57409: LD_VAR 0 1
57413: PPUSH
57414: EMPTY
57415: PPUSH
57416: CALL_OW 1
57420: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57421: LD_ADDR_EXP 77
57425: PUSH
57426: LD_EXP 77
57430: PPUSH
57431: LD_VAR 0 1
57435: PPUSH
57436: EMPTY
57437: PPUSH
57438: CALL_OW 1
57442: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57443: LD_ADDR_EXP 78
57447: PUSH
57448: LD_EXP 78
57452: PPUSH
57453: LD_VAR 0 1
57457: PPUSH
57458: EMPTY
57459: PPUSH
57460: CALL_OW 1
57464: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57465: LD_ADDR_EXP 79
57469: PUSH
57470: LD_EXP 79
57474: PPUSH
57475: LD_VAR 0 1
57479: PPUSH
57480: EMPTY
57481: PPUSH
57482: CALL_OW 1
57486: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57487: LD_ADDR_EXP 80
57491: PUSH
57492: LD_EXP 80
57496: PPUSH
57497: LD_VAR 0 1
57501: PPUSH
57502: EMPTY
57503: PPUSH
57504: CALL_OW 1
57508: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57509: LD_ADDR_EXP 81
57513: PUSH
57514: LD_EXP 81
57518: PPUSH
57519: LD_VAR 0 1
57523: PPUSH
57524: EMPTY
57525: PPUSH
57526: CALL_OW 1
57530: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57531: LD_ADDR_EXP 82
57535: PUSH
57536: LD_EXP 82
57540: PPUSH
57541: LD_VAR 0 1
57545: PPUSH
57546: EMPTY
57547: PPUSH
57548: CALL_OW 1
57552: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57553: LD_ADDR_EXP 83
57557: PUSH
57558: LD_EXP 83
57562: PPUSH
57563: LD_VAR 0 1
57567: PPUSH
57568: EMPTY
57569: PPUSH
57570: CALL_OW 1
57574: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57575: LD_ADDR_EXP 85
57579: PUSH
57580: LD_EXP 85
57584: PPUSH
57585: LD_VAR 0 1
57589: PPUSH
57590: EMPTY
57591: PPUSH
57592: CALL_OW 1
57596: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57597: LD_ADDR_EXP 87
57601: PUSH
57602: LD_EXP 87
57606: PPUSH
57607: LD_VAR 0 1
57611: PPUSH
57612: EMPTY
57613: PPUSH
57614: CALL_OW 1
57618: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57619: LD_ADDR_EXP 88
57623: PUSH
57624: LD_EXP 88
57628: PPUSH
57629: LD_VAR 0 1
57633: PPUSH
57634: EMPTY
57635: PPUSH
57636: CALL_OW 1
57640: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57641: LD_ADDR_EXP 89
57645: PUSH
57646: LD_EXP 89
57650: PPUSH
57651: LD_VAR 0 1
57655: PPUSH
57656: EMPTY
57657: PPUSH
57658: CALL_OW 1
57662: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57663: LD_ADDR_EXP 90
57667: PUSH
57668: LD_EXP 90
57672: PPUSH
57673: LD_VAR 0 1
57677: PPUSH
57678: EMPTY
57679: PPUSH
57680: CALL_OW 1
57684: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57685: LD_ADDR_EXP 91
57689: PUSH
57690: LD_EXP 91
57694: PPUSH
57695: LD_VAR 0 1
57699: PPUSH
57700: EMPTY
57701: PPUSH
57702: CALL_OW 1
57706: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57707: LD_ADDR_EXP 92
57711: PUSH
57712: LD_EXP 92
57716: PPUSH
57717: LD_VAR 0 1
57721: PPUSH
57722: EMPTY
57723: PPUSH
57724: CALL_OW 1
57728: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57729: LD_ADDR_EXP 93
57733: PUSH
57734: LD_EXP 93
57738: PPUSH
57739: LD_VAR 0 1
57743: PPUSH
57744: EMPTY
57745: PPUSH
57746: CALL_OW 1
57750: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57751: LD_ADDR_EXP 94
57755: PUSH
57756: LD_EXP 94
57760: PPUSH
57761: LD_VAR 0 1
57765: PPUSH
57766: EMPTY
57767: PPUSH
57768: CALL_OW 1
57772: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57773: LD_ADDR_EXP 95
57777: PUSH
57778: LD_EXP 95
57782: PPUSH
57783: LD_VAR 0 1
57787: PPUSH
57788: EMPTY
57789: PPUSH
57790: CALL_OW 1
57794: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57795: LD_ADDR_EXP 96
57799: PUSH
57800: LD_EXP 96
57804: PPUSH
57805: LD_VAR 0 1
57809: PPUSH
57810: EMPTY
57811: PPUSH
57812: CALL_OW 1
57816: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57817: LD_ADDR_EXP 97
57821: PUSH
57822: LD_EXP 97
57826: PPUSH
57827: LD_VAR 0 1
57831: PPUSH
57832: EMPTY
57833: PPUSH
57834: CALL_OW 1
57838: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57839: LD_ADDR_EXP 98
57843: PUSH
57844: LD_EXP 98
57848: PPUSH
57849: LD_VAR 0 1
57853: PPUSH
57854: EMPTY
57855: PPUSH
57856: CALL_OW 1
57860: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57861: LD_ADDR_EXP 99
57865: PUSH
57866: LD_EXP 99
57870: PPUSH
57871: LD_VAR 0 1
57875: PPUSH
57876: EMPTY
57877: PPUSH
57878: CALL_OW 1
57882: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57883: LD_ADDR_EXP 100
57887: PUSH
57888: LD_EXP 100
57892: PPUSH
57893: LD_VAR 0 1
57897: PPUSH
57898: LD_INT 0
57900: PPUSH
57901: CALL_OW 1
57905: ST_TO_ADDR
// end ;
57906: LD_VAR 0 2
57910: RET
// export function MC_Add ( side , units ) ; var base ; begin
57911: LD_INT 0
57913: PPUSH
57914: PPUSH
// base := mc_bases + 1 ;
57915: LD_ADDR_VAR 0 4
57919: PUSH
57920: LD_EXP 58
57924: PUSH
57925: LD_INT 1
57927: PLUS
57928: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57929: LD_ADDR_EXP 84
57933: PUSH
57934: LD_EXP 84
57938: PPUSH
57939: LD_VAR 0 4
57943: PPUSH
57944: LD_VAR 0 1
57948: PPUSH
57949: CALL_OW 1
57953: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57954: LD_ADDR_EXP 58
57958: PUSH
57959: LD_EXP 58
57963: PPUSH
57964: LD_VAR 0 4
57968: PPUSH
57969: LD_VAR 0 2
57973: PPUSH
57974: CALL_OW 1
57978: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57979: LD_ADDR_EXP 59
57983: PUSH
57984: LD_EXP 59
57988: PPUSH
57989: LD_VAR 0 4
57993: PPUSH
57994: EMPTY
57995: PPUSH
57996: CALL_OW 1
58000: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58001: LD_ADDR_EXP 60
58005: PUSH
58006: LD_EXP 60
58010: PPUSH
58011: LD_VAR 0 4
58015: PPUSH
58016: EMPTY
58017: PPUSH
58018: CALL_OW 1
58022: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58023: LD_ADDR_EXP 61
58027: PUSH
58028: LD_EXP 61
58032: PPUSH
58033: LD_VAR 0 4
58037: PPUSH
58038: EMPTY
58039: PPUSH
58040: CALL_OW 1
58044: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58045: LD_ADDR_EXP 62
58049: PUSH
58050: LD_EXP 62
58054: PPUSH
58055: LD_VAR 0 4
58059: PPUSH
58060: EMPTY
58061: PPUSH
58062: CALL_OW 1
58066: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58067: LD_ADDR_EXP 63
58071: PUSH
58072: LD_EXP 63
58076: PPUSH
58077: LD_VAR 0 4
58081: PPUSH
58082: EMPTY
58083: PPUSH
58084: CALL_OW 1
58088: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58089: LD_ADDR_EXP 64
58093: PUSH
58094: LD_EXP 64
58098: PPUSH
58099: LD_VAR 0 4
58103: PPUSH
58104: EMPTY
58105: PPUSH
58106: CALL_OW 1
58110: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58111: LD_ADDR_EXP 65
58115: PUSH
58116: LD_EXP 65
58120: PPUSH
58121: LD_VAR 0 4
58125: PPUSH
58126: EMPTY
58127: PPUSH
58128: CALL_OW 1
58132: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58133: LD_ADDR_EXP 66
58137: PUSH
58138: LD_EXP 66
58142: PPUSH
58143: LD_VAR 0 4
58147: PPUSH
58148: EMPTY
58149: PPUSH
58150: CALL_OW 1
58154: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58155: LD_ADDR_EXP 67
58159: PUSH
58160: LD_EXP 67
58164: PPUSH
58165: LD_VAR 0 4
58169: PPUSH
58170: EMPTY
58171: PPUSH
58172: CALL_OW 1
58176: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58177: LD_ADDR_EXP 68
58181: PUSH
58182: LD_EXP 68
58186: PPUSH
58187: LD_VAR 0 4
58191: PPUSH
58192: EMPTY
58193: PPUSH
58194: CALL_OW 1
58198: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58199: LD_ADDR_EXP 69
58203: PUSH
58204: LD_EXP 69
58208: PPUSH
58209: LD_VAR 0 4
58213: PPUSH
58214: LD_INT 0
58216: PPUSH
58217: CALL_OW 1
58221: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58222: LD_ADDR_EXP 70
58226: PUSH
58227: LD_EXP 70
58231: PPUSH
58232: LD_VAR 0 4
58236: PPUSH
58237: EMPTY
58238: PPUSH
58239: CALL_OW 1
58243: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58244: LD_ADDR_EXP 71
58248: PUSH
58249: LD_EXP 71
58253: PPUSH
58254: LD_VAR 0 4
58258: PPUSH
58259: EMPTY
58260: PPUSH
58261: CALL_OW 1
58265: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58266: LD_ADDR_EXP 72
58270: PUSH
58271: LD_EXP 72
58275: PPUSH
58276: LD_VAR 0 4
58280: PPUSH
58281: EMPTY
58282: PPUSH
58283: CALL_OW 1
58287: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58288: LD_ADDR_EXP 73
58292: PUSH
58293: LD_EXP 73
58297: PPUSH
58298: LD_VAR 0 4
58302: PPUSH
58303: EMPTY
58304: PPUSH
58305: CALL_OW 1
58309: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58310: LD_ADDR_EXP 74
58314: PUSH
58315: LD_EXP 74
58319: PPUSH
58320: LD_VAR 0 4
58324: PPUSH
58325: EMPTY
58326: PPUSH
58327: CALL_OW 1
58331: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58332: LD_ADDR_EXP 75
58336: PUSH
58337: LD_EXP 75
58341: PPUSH
58342: LD_VAR 0 4
58346: PPUSH
58347: EMPTY
58348: PPUSH
58349: CALL_OW 1
58353: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58354: LD_ADDR_EXP 76
58358: PUSH
58359: LD_EXP 76
58363: PPUSH
58364: LD_VAR 0 4
58368: PPUSH
58369: EMPTY
58370: PPUSH
58371: CALL_OW 1
58375: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58376: LD_ADDR_EXP 77
58380: PUSH
58381: LD_EXP 77
58385: PPUSH
58386: LD_VAR 0 4
58390: PPUSH
58391: EMPTY
58392: PPUSH
58393: CALL_OW 1
58397: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58398: LD_ADDR_EXP 78
58402: PUSH
58403: LD_EXP 78
58407: PPUSH
58408: LD_VAR 0 4
58412: PPUSH
58413: EMPTY
58414: PPUSH
58415: CALL_OW 1
58419: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58420: LD_ADDR_EXP 79
58424: PUSH
58425: LD_EXP 79
58429: PPUSH
58430: LD_VAR 0 4
58434: PPUSH
58435: EMPTY
58436: PPUSH
58437: CALL_OW 1
58441: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58442: LD_ADDR_EXP 80
58446: PUSH
58447: LD_EXP 80
58451: PPUSH
58452: LD_VAR 0 4
58456: PPUSH
58457: EMPTY
58458: PPUSH
58459: CALL_OW 1
58463: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58464: LD_ADDR_EXP 81
58468: PUSH
58469: LD_EXP 81
58473: PPUSH
58474: LD_VAR 0 4
58478: PPUSH
58479: EMPTY
58480: PPUSH
58481: CALL_OW 1
58485: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58486: LD_ADDR_EXP 82
58490: PUSH
58491: LD_EXP 82
58495: PPUSH
58496: LD_VAR 0 4
58500: PPUSH
58501: EMPTY
58502: PPUSH
58503: CALL_OW 1
58507: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58508: LD_ADDR_EXP 83
58512: PUSH
58513: LD_EXP 83
58517: PPUSH
58518: LD_VAR 0 4
58522: PPUSH
58523: EMPTY
58524: PPUSH
58525: CALL_OW 1
58529: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58530: LD_ADDR_EXP 85
58534: PUSH
58535: LD_EXP 85
58539: PPUSH
58540: LD_VAR 0 4
58544: PPUSH
58545: EMPTY
58546: PPUSH
58547: CALL_OW 1
58551: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58552: LD_ADDR_EXP 87
58556: PUSH
58557: LD_EXP 87
58561: PPUSH
58562: LD_VAR 0 4
58566: PPUSH
58567: EMPTY
58568: PPUSH
58569: CALL_OW 1
58573: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58574: LD_ADDR_EXP 88
58578: PUSH
58579: LD_EXP 88
58583: PPUSH
58584: LD_VAR 0 4
58588: PPUSH
58589: EMPTY
58590: PPUSH
58591: CALL_OW 1
58595: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58596: LD_ADDR_EXP 89
58600: PUSH
58601: LD_EXP 89
58605: PPUSH
58606: LD_VAR 0 4
58610: PPUSH
58611: EMPTY
58612: PPUSH
58613: CALL_OW 1
58617: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58618: LD_ADDR_EXP 90
58622: PUSH
58623: LD_EXP 90
58627: PPUSH
58628: LD_VAR 0 4
58632: PPUSH
58633: EMPTY
58634: PPUSH
58635: CALL_OW 1
58639: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58640: LD_ADDR_EXP 91
58644: PUSH
58645: LD_EXP 91
58649: PPUSH
58650: LD_VAR 0 4
58654: PPUSH
58655: EMPTY
58656: PPUSH
58657: CALL_OW 1
58661: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58662: LD_ADDR_EXP 92
58666: PUSH
58667: LD_EXP 92
58671: PPUSH
58672: LD_VAR 0 4
58676: PPUSH
58677: EMPTY
58678: PPUSH
58679: CALL_OW 1
58683: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58684: LD_ADDR_EXP 93
58688: PUSH
58689: LD_EXP 93
58693: PPUSH
58694: LD_VAR 0 4
58698: PPUSH
58699: EMPTY
58700: PPUSH
58701: CALL_OW 1
58705: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58706: LD_ADDR_EXP 94
58710: PUSH
58711: LD_EXP 94
58715: PPUSH
58716: LD_VAR 0 4
58720: PPUSH
58721: EMPTY
58722: PPUSH
58723: CALL_OW 1
58727: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58728: LD_ADDR_EXP 95
58732: PUSH
58733: LD_EXP 95
58737: PPUSH
58738: LD_VAR 0 4
58742: PPUSH
58743: EMPTY
58744: PPUSH
58745: CALL_OW 1
58749: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58750: LD_ADDR_EXP 96
58754: PUSH
58755: LD_EXP 96
58759: PPUSH
58760: LD_VAR 0 4
58764: PPUSH
58765: EMPTY
58766: PPUSH
58767: CALL_OW 1
58771: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58772: LD_ADDR_EXP 97
58776: PUSH
58777: LD_EXP 97
58781: PPUSH
58782: LD_VAR 0 4
58786: PPUSH
58787: EMPTY
58788: PPUSH
58789: CALL_OW 1
58793: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58794: LD_ADDR_EXP 98
58798: PUSH
58799: LD_EXP 98
58803: PPUSH
58804: LD_VAR 0 4
58808: PPUSH
58809: EMPTY
58810: PPUSH
58811: CALL_OW 1
58815: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58816: LD_ADDR_EXP 99
58820: PUSH
58821: LD_EXP 99
58825: PPUSH
58826: LD_VAR 0 4
58830: PPUSH
58831: EMPTY
58832: PPUSH
58833: CALL_OW 1
58837: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58838: LD_ADDR_EXP 100
58842: PUSH
58843: LD_EXP 100
58847: PPUSH
58848: LD_VAR 0 4
58852: PPUSH
58853: LD_INT 0
58855: PPUSH
58856: CALL_OW 1
58860: ST_TO_ADDR
// result := base ;
58861: LD_ADDR_VAR 0 3
58865: PUSH
58866: LD_VAR 0 4
58870: ST_TO_ADDR
// end ;
58871: LD_VAR 0 3
58875: RET
// export function MC_Start ( ) ; var i ; begin
58876: LD_INT 0
58878: PPUSH
58879: PPUSH
// for i = 1 to mc_bases do
58880: LD_ADDR_VAR 0 2
58884: PUSH
58885: DOUBLE
58886: LD_INT 1
58888: DEC
58889: ST_TO_ADDR
58890: LD_EXP 58
58894: PUSH
58895: FOR_TO
58896: IFFALSE 59973
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58898: LD_ADDR_EXP 58
58902: PUSH
58903: LD_EXP 58
58907: PPUSH
58908: LD_VAR 0 2
58912: PPUSH
58913: LD_EXP 58
58917: PUSH
58918: LD_VAR 0 2
58922: ARRAY
58923: PUSH
58924: LD_INT 0
58926: DIFF
58927: PPUSH
58928: CALL_OW 1
58932: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58933: LD_ADDR_EXP 59
58937: PUSH
58938: LD_EXP 59
58942: PPUSH
58943: LD_VAR 0 2
58947: PPUSH
58948: EMPTY
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58955: LD_ADDR_EXP 60
58959: PUSH
58960: LD_EXP 60
58964: PPUSH
58965: LD_VAR 0 2
58969: PPUSH
58970: EMPTY
58971: PPUSH
58972: CALL_OW 1
58976: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58977: LD_ADDR_EXP 61
58981: PUSH
58982: LD_EXP 61
58986: PPUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: EMPTY
58993: PPUSH
58994: CALL_OW 1
58998: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58999: LD_ADDR_EXP 62
59003: PUSH
59004: LD_EXP 62
59008: PPUSH
59009: LD_VAR 0 2
59013: PPUSH
59014: EMPTY
59015: PUSH
59016: EMPTY
59017: PUSH
59018: EMPTY
59019: LIST
59020: LIST
59021: PPUSH
59022: CALL_OW 1
59026: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59027: LD_ADDR_EXP 63
59031: PUSH
59032: LD_EXP 63
59036: PPUSH
59037: LD_VAR 0 2
59041: PPUSH
59042: EMPTY
59043: PPUSH
59044: CALL_OW 1
59048: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59049: LD_ADDR_EXP 90
59053: PUSH
59054: LD_EXP 90
59058: PPUSH
59059: LD_VAR 0 2
59063: PPUSH
59064: EMPTY
59065: PPUSH
59066: CALL_OW 1
59070: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59071: LD_ADDR_EXP 64
59075: PUSH
59076: LD_EXP 64
59080: PPUSH
59081: LD_VAR 0 2
59085: PPUSH
59086: EMPTY
59087: PPUSH
59088: CALL_OW 1
59092: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59093: LD_ADDR_EXP 65
59097: PUSH
59098: LD_EXP 65
59102: PPUSH
59103: LD_VAR 0 2
59107: PPUSH
59108: EMPTY
59109: PPUSH
59110: CALL_OW 1
59114: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59115: LD_ADDR_EXP 66
59119: PUSH
59120: LD_EXP 66
59124: PPUSH
59125: LD_VAR 0 2
59129: PPUSH
59130: LD_EXP 58
59134: PUSH
59135: LD_VAR 0 2
59139: ARRAY
59140: PPUSH
59141: LD_INT 2
59143: PUSH
59144: LD_INT 30
59146: PUSH
59147: LD_INT 32
59149: PUSH
59150: EMPTY
59151: LIST
59152: LIST
59153: PUSH
59154: LD_INT 30
59156: PUSH
59157: LD_INT 33
59159: PUSH
59160: EMPTY
59161: LIST
59162: LIST
59163: PUSH
59164: EMPTY
59165: LIST
59166: LIST
59167: LIST
59168: PPUSH
59169: CALL_OW 72
59173: PPUSH
59174: CALL_OW 1
59178: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59179: LD_ADDR_EXP 67
59183: PUSH
59184: LD_EXP 67
59188: PPUSH
59189: LD_VAR 0 2
59193: PPUSH
59194: LD_EXP 58
59198: PUSH
59199: LD_VAR 0 2
59203: ARRAY
59204: PPUSH
59205: LD_INT 2
59207: PUSH
59208: LD_INT 30
59210: PUSH
59211: LD_INT 32
59213: PUSH
59214: EMPTY
59215: LIST
59216: LIST
59217: PUSH
59218: LD_INT 30
59220: PUSH
59221: LD_INT 31
59223: PUSH
59224: EMPTY
59225: LIST
59226: LIST
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: LIST
59232: PUSH
59233: LD_INT 58
59235: PUSH
59236: EMPTY
59237: LIST
59238: PUSH
59239: EMPTY
59240: LIST
59241: LIST
59242: PPUSH
59243: CALL_OW 72
59247: PPUSH
59248: CALL_OW 1
59252: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59253: LD_ADDR_EXP 68
59257: PUSH
59258: LD_EXP 68
59262: PPUSH
59263: LD_VAR 0 2
59267: PPUSH
59268: EMPTY
59269: PPUSH
59270: CALL_OW 1
59274: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59275: LD_ADDR_EXP 72
59279: PUSH
59280: LD_EXP 72
59284: PPUSH
59285: LD_VAR 0 2
59289: PPUSH
59290: EMPTY
59291: PPUSH
59292: CALL_OW 1
59296: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59297: LD_ADDR_EXP 71
59301: PUSH
59302: LD_EXP 71
59306: PPUSH
59307: LD_VAR 0 2
59311: PPUSH
59312: EMPTY
59313: PPUSH
59314: CALL_OW 1
59318: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59319: LD_ADDR_EXP 73
59323: PUSH
59324: LD_EXP 73
59328: PPUSH
59329: LD_VAR 0 2
59333: PPUSH
59334: EMPTY
59335: PPUSH
59336: CALL_OW 1
59340: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59341: LD_ADDR_EXP 74
59345: PUSH
59346: LD_EXP 74
59350: PPUSH
59351: LD_VAR 0 2
59355: PPUSH
59356: EMPTY
59357: PPUSH
59358: CALL_OW 1
59362: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59363: LD_ADDR_EXP 75
59367: PUSH
59368: LD_EXP 75
59372: PPUSH
59373: LD_VAR 0 2
59377: PPUSH
59378: EMPTY
59379: PPUSH
59380: CALL_OW 1
59384: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59385: LD_ADDR_EXP 76
59389: PUSH
59390: LD_EXP 76
59394: PPUSH
59395: LD_VAR 0 2
59399: PPUSH
59400: EMPTY
59401: PPUSH
59402: CALL_OW 1
59406: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59407: LD_ADDR_EXP 77
59411: PUSH
59412: LD_EXP 77
59416: PPUSH
59417: LD_VAR 0 2
59421: PPUSH
59422: EMPTY
59423: PPUSH
59424: CALL_OW 1
59428: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59429: LD_ADDR_EXP 78
59433: PUSH
59434: LD_EXP 78
59438: PPUSH
59439: LD_VAR 0 2
59443: PPUSH
59444: EMPTY
59445: PPUSH
59446: CALL_OW 1
59450: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59451: LD_ADDR_EXP 79
59455: PUSH
59456: LD_EXP 79
59460: PPUSH
59461: LD_VAR 0 2
59465: PPUSH
59466: EMPTY
59467: PPUSH
59468: CALL_OW 1
59472: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59473: LD_ADDR_EXP 80
59477: PUSH
59478: LD_EXP 80
59482: PPUSH
59483: LD_VAR 0 2
59487: PPUSH
59488: EMPTY
59489: PPUSH
59490: CALL_OW 1
59494: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59495: LD_ADDR_EXP 69
59499: PUSH
59500: LD_EXP 69
59504: PPUSH
59505: LD_VAR 0 2
59509: PPUSH
59510: LD_INT 0
59512: PPUSH
59513: CALL_OW 1
59517: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59518: LD_ADDR_EXP 82
59522: PUSH
59523: LD_EXP 82
59527: PPUSH
59528: LD_VAR 0 2
59532: PPUSH
59533: LD_INT 0
59535: PPUSH
59536: CALL_OW 1
59540: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59541: LD_ADDR_EXP 70
59545: PUSH
59546: LD_EXP 70
59550: PPUSH
59551: LD_VAR 0 2
59555: PPUSH
59556: EMPTY
59557: PPUSH
59558: CALL_OW 1
59562: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59563: LD_ADDR_EXP 81
59567: PUSH
59568: LD_EXP 81
59572: PPUSH
59573: LD_VAR 0 2
59577: PPUSH
59578: LD_INT 0
59580: PPUSH
59581: CALL_OW 1
59585: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59586: LD_ADDR_EXP 83
59590: PUSH
59591: LD_EXP 83
59595: PPUSH
59596: LD_VAR 0 2
59600: PPUSH
59601: EMPTY
59602: PPUSH
59603: CALL_OW 1
59607: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59608: LD_ADDR_EXP 86
59612: PUSH
59613: LD_EXP 86
59617: PPUSH
59618: LD_VAR 0 2
59622: PPUSH
59623: LD_INT 0
59625: PPUSH
59626: CALL_OW 1
59630: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59631: LD_ADDR_EXP 87
59635: PUSH
59636: LD_EXP 87
59640: PPUSH
59641: LD_VAR 0 2
59645: PPUSH
59646: EMPTY
59647: PPUSH
59648: CALL_OW 1
59652: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59653: LD_ADDR_EXP 88
59657: PUSH
59658: LD_EXP 88
59662: PPUSH
59663: LD_VAR 0 2
59667: PPUSH
59668: EMPTY
59669: PPUSH
59670: CALL_OW 1
59674: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59675: LD_ADDR_EXP 89
59679: PUSH
59680: LD_EXP 89
59684: PPUSH
59685: LD_VAR 0 2
59689: PPUSH
59690: EMPTY
59691: PPUSH
59692: CALL_OW 1
59696: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59697: LD_ADDR_EXP 91
59701: PUSH
59702: LD_EXP 91
59706: PPUSH
59707: LD_VAR 0 2
59711: PPUSH
59712: LD_EXP 58
59716: PUSH
59717: LD_VAR 0 2
59721: ARRAY
59722: PPUSH
59723: LD_INT 2
59725: PUSH
59726: LD_INT 30
59728: PUSH
59729: LD_INT 6
59731: PUSH
59732: EMPTY
59733: LIST
59734: LIST
59735: PUSH
59736: LD_INT 30
59738: PUSH
59739: LD_INT 7
59741: PUSH
59742: EMPTY
59743: LIST
59744: LIST
59745: PUSH
59746: LD_INT 30
59748: PUSH
59749: LD_INT 8
59751: PUSH
59752: EMPTY
59753: LIST
59754: LIST
59755: PUSH
59756: EMPTY
59757: LIST
59758: LIST
59759: LIST
59760: LIST
59761: PPUSH
59762: CALL_OW 72
59766: PPUSH
59767: CALL_OW 1
59771: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59772: LD_ADDR_EXP 92
59776: PUSH
59777: LD_EXP 92
59781: PPUSH
59782: LD_VAR 0 2
59786: PPUSH
59787: EMPTY
59788: PPUSH
59789: CALL_OW 1
59793: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59794: LD_ADDR_EXP 93
59798: PUSH
59799: LD_EXP 93
59803: PPUSH
59804: LD_VAR 0 2
59808: PPUSH
59809: EMPTY
59810: PPUSH
59811: CALL_OW 1
59815: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59816: LD_ADDR_EXP 94
59820: PUSH
59821: LD_EXP 94
59825: PPUSH
59826: LD_VAR 0 2
59830: PPUSH
59831: EMPTY
59832: PPUSH
59833: CALL_OW 1
59837: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59838: LD_ADDR_EXP 95
59842: PUSH
59843: LD_EXP 95
59847: PPUSH
59848: LD_VAR 0 2
59852: PPUSH
59853: EMPTY
59854: PPUSH
59855: CALL_OW 1
59859: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59860: LD_ADDR_EXP 96
59864: PUSH
59865: LD_EXP 96
59869: PPUSH
59870: LD_VAR 0 2
59874: PPUSH
59875: EMPTY
59876: PPUSH
59877: CALL_OW 1
59881: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59882: LD_ADDR_EXP 97
59886: PUSH
59887: LD_EXP 97
59891: PPUSH
59892: LD_VAR 0 2
59896: PPUSH
59897: EMPTY
59898: PPUSH
59899: CALL_OW 1
59903: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59904: LD_ADDR_EXP 98
59908: PUSH
59909: LD_EXP 98
59913: PPUSH
59914: LD_VAR 0 2
59918: PPUSH
59919: EMPTY
59920: PPUSH
59921: CALL_OW 1
59925: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59926: LD_ADDR_EXP 99
59930: PUSH
59931: LD_EXP 99
59935: PPUSH
59936: LD_VAR 0 2
59940: PPUSH
59941: EMPTY
59942: PPUSH
59943: CALL_OW 1
59947: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59948: LD_ADDR_EXP 100
59952: PUSH
59953: LD_EXP 100
59957: PPUSH
59958: LD_VAR 0 2
59962: PPUSH
59963: LD_INT 0
59965: PPUSH
59966: CALL_OW 1
59970: ST_TO_ADDR
// end ;
59971: GO 58895
59973: POP
59974: POP
// MC_InitSides ( ) ;
59975: CALL 60261 0 0
// MC_InitResearch ( ) ;
59979: CALL 60000 0 0
// CustomInitMacro ( ) ;
59983: CALL 181 0 0
// skirmish := true ;
59987: LD_ADDR_EXP 56
59991: PUSH
59992: LD_INT 1
59994: ST_TO_ADDR
// end ;
59995: LD_VAR 0 1
59999: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60000: LD_INT 0
60002: PPUSH
60003: PPUSH
60004: PPUSH
60005: PPUSH
60006: PPUSH
60007: PPUSH
// if not mc_bases then
60008: LD_EXP 58
60012: NOT
60013: IFFALSE 60017
// exit ;
60015: GO 60256
// for i = 1 to 8 do
60017: LD_ADDR_VAR 0 2
60021: PUSH
60022: DOUBLE
60023: LD_INT 1
60025: DEC
60026: ST_TO_ADDR
60027: LD_INT 8
60029: PUSH
60030: FOR_TO
60031: IFFALSE 60057
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60033: LD_ADDR_EXP 85
60037: PUSH
60038: LD_EXP 85
60042: PPUSH
60043: LD_VAR 0 2
60047: PPUSH
60048: EMPTY
60049: PPUSH
60050: CALL_OW 1
60054: ST_TO_ADDR
60055: GO 60030
60057: POP
60058: POP
// tmp := [ ] ;
60059: LD_ADDR_VAR 0 5
60063: PUSH
60064: EMPTY
60065: ST_TO_ADDR
// for i = 1 to mc_sides do
60066: LD_ADDR_VAR 0 2
60070: PUSH
60071: DOUBLE
60072: LD_INT 1
60074: DEC
60075: ST_TO_ADDR
60076: LD_EXP 84
60080: PUSH
60081: FOR_TO
60082: IFFALSE 60140
// if not mc_sides [ i ] in tmp then
60084: LD_EXP 84
60088: PUSH
60089: LD_VAR 0 2
60093: ARRAY
60094: PUSH
60095: LD_VAR 0 5
60099: IN
60100: NOT
60101: IFFALSE 60138
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60103: LD_ADDR_VAR 0 5
60107: PUSH
60108: LD_VAR 0 5
60112: PPUSH
60113: LD_VAR 0 5
60117: PUSH
60118: LD_INT 1
60120: PLUS
60121: PPUSH
60122: LD_EXP 84
60126: PUSH
60127: LD_VAR 0 2
60131: ARRAY
60132: PPUSH
60133: CALL_OW 2
60137: ST_TO_ADDR
60138: GO 60081
60140: POP
60141: POP
// if not tmp then
60142: LD_VAR 0 5
60146: NOT
60147: IFFALSE 60151
// exit ;
60149: GO 60256
// for j in tmp do
60151: LD_ADDR_VAR 0 3
60155: PUSH
60156: LD_VAR 0 5
60160: PUSH
60161: FOR_IN
60162: IFFALSE 60254
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60164: LD_ADDR_VAR 0 6
60168: PUSH
60169: LD_INT 22
60171: PUSH
60172: LD_VAR 0 3
60176: PUSH
60177: EMPTY
60178: LIST
60179: LIST
60180: PPUSH
60181: CALL_OW 69
60185: ST_TO_ADDR
// if not un then
60186: LD_VAR 0 6
60190: NOT
60191: IFFALSE 60195
// continue ;
60193: GO 60161
// nation := GetNation ( un [ 1 ] ) ;
60195: LD_ADDR_VAR 0 4
60199: PUSH
60200: LD_VAR 0 6
60204: PUSH
60205: LD_INT 1
60207: ARRAY
60208: PPUSH
60209: CALL_OW 248
60213: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60214: LD_ADDR_EXP 85
60218: PUSH
60219: LD_EXP 85
60223: PPUSH
60224: LD_VAR 0 3
60228: PPUSH
60229: LD_VAR 0 3
60233: PPUSH
60234: LD_VAR 0 4
60238: PPUSH
60239: LD_INT 1
60241: PPUSH
60242: CALL 14029 0 3
60246: PPUSH
60247: CALL_OW 1
60251: ST_TO_ADDR
// end ;
60252: GO 60161
60254: POP
60255: POP
// end ;
60256: LD_VAR 0 1
60260: RET
// export function MC_InitSides ( ) ; var i ; begin
60261: LD_INT 0
60263: PPUSH
60264: PPUSH
// if not mc_bases then
60265: LD_EXP 58
60269: NOT
60270: IFFALSE 60274
// exit ;
60272: GO 60348
// for i = 1 to mc_bases do
60274: LD_ADDR_VAR 0 2
60278: PUSH
60279: DOUBLE
60280: LD_INT 1
60282: DEC
60283: ST_TO_ADDR
60284: LD_EXP 58
60288: PUSH
60289: FOR_TO
60290: IFFALSE 60346
// if mc_bases [ i ] then
60292: LD_EXP 58
60296: PUSH
60297: LD_VAR 0 2
60301: ARRAY
60302: IFFALSE 60344
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60304: LD_ADDR_EXP 84
60308: PUSH
60309: LD_EXP 84
60313: PPUSH
60314: LD_VAR 0 2
60318: PPUSH
60319: LD_EXP 58
60323: PUSH
60324: LD_VAR 0 2
60328: ARRAY
60329: PUSH
60330: LD_INT 1
60332: ARRAY
60333: PPUSH
60334: CALL_OW 255
60338: PPUSH
60339: CALL_OW 1
60343: ST_TO_ADDR
60344: GO 60289
60346: POP
60347: POP
// end ;
60348: LD_VAR 0 1
60352: RET
// every 0 0$01 trigger skirmish do
60353: LD_EXP 56
60357: IFFALSE 60511
60359: GO 60361
60361: DISABLE
// begin enable ;
60362: ENABLE
// MC_CheckBuildings ( ) ;
60363: CALL 65009 0 0
// MC_CheckPeopleLife ( ) ;
60367: CALL 65134 0 0
// RaiseSailEvent ( 100 ) ;
60371: LD_INT 100
60373: PPUSH
60374: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60378: LD_INT 103
60380: PPUSH
60381: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60385: LD_INT 104
60387: PPUSH
60388: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60392: LD_INT 105
60394: PPUSH
60395: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60399: LD_INT 106
60401: PPUSH
60402: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60406: LD_INT 107
60408: PPUSH
60409: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60413: LD_INT 108
60415: PPUSH
60416: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60420: LD_INT 109
60422: PPUSH
60423: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60427: LD_INT 110
60429: PPUSH
60430: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60434: LD_INT 111
60436: PPUSH
60437: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60441: LD_INT 112
60443: PPUSH
60444: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60448: LD_INT 113
60450: PPUSH
60451: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60455: LD_INT 120
60457: PPUSH
60458: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60462: LD_INT 121
60464: PPUSH
60465: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60469: LD_INT 122
60471: PPUSH
60472: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60476: LD_INT 123
60478: PPUSH
60479: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60483: LD_INT 124
60485: PPUSH
60486: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60490: LD_INT 125
60492: PPUSH
60493: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60497: LD_INT 126
60499: PPUSH
60500: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60504: LD_INT 200
60506: PPUSH
60507: CALL_OW 427
// end ;
60511: END
// on SailEvent ( event ) do begin if event < 100 then
60512: LD_VAR 0 1
60516: PUSH
60517: LD_INT 100
60519: LESS
60520: IFFALSE 60531
// CustomEvent ( event ) ;
60522: LD_VAR 0 1
60526: PPUSH
60527: CALL 12731 0 1
// if event = 100 then
60531: LD_VAR 0 1
60535: PUSH
60536: LD_INT 100
60538: EQUAL
60539: IFFALSE 60545
// MC_ClassManager ( ) ;
60541: CALL 60937 0 0
// if event = 101 then
60545: LD_VAR 0 1
60549: PUSH
60550: LD_INT 101
60552: EQUAL
60553: IFFALSE 60559
// MC_RepairBuildings ( ) ;
60555: CALL 65730 0 0
// if event = 102 then
60559: LD_VAR 0 1
60563: PUSH
60564: LD_INT 102
60566: EQUAL
60567: IFFALSE 60573
// MC_Heal ( ) ;
60569: CALL 66462 0 0
// if event = 103 then
60573: LD_VAR 0 1
60577: PUSH
60578: LD_INT 103
60580: EQUAL
60581: IFFALSE 60587
// MC_Build ( ) ;
60583: CALL 66884 0 0
// if event = 104 then
60587: LD_VAR 0 1
60591: PUSH
60592: LD_INT 104
60594: EQUAL
60595: IFFALSE 60601
// MC_TurretWeapon ( ) ;
60597: CALL 68497 0 0
// if event = 105 then
60601: LD_VAR 0 1
60605: PUSH
60606: LD_INT 105
60608: EQUAL
60609: IFFALSE 60615
// MC_BuildUpgrade ( ) ;
60611: CALL 68048 0 0
// if event = 106 then
60615: LD_VAR 0 1
60619: PUSH
60620: LD_INT 106
60622: EQUAL
60623: IFFALSE 60629
// MC_PlantMines ( ) ;
60625: CALL 68927 0 0
// if event = 107 then
60629: LD_VAR 0 1
60633: PUSH
60634: LD_INT 107
60636: EQUAL
60637: IFFALSE 60643
// MC_CollectCrates ( ) ;
60639: CALL 69961 0 0
// if event = 108 then
60643: LD_VAR 0 1
60647: PUSH
60648: LD_INT 108
60650: EQUAL
60651: IFFALSE 60657
// MC_LinkRemoteControl ( ) ;
60653: CALL 71737 0 0
// if event = 109 then
60657: LD_VAR 0 1
60661: PUSH
60662: LD_INT 109
60664: EQUAL
60665: IFFALSE 60671
// MC_ProduceVehicle ( ) ;
60667: CALL 71918 0 0
// if event = 110 then
60671: LD_VAR 0 1
60675: PUSH
60676: LD_INT 110
60678: EQUAL
60679: IFFALSE 60685
// MC_SendAttack ( ) ;
60681: CALL 72384 0 0
// if event = 111 then
60685: LD_VAR 0 1
60689: PUSH
60690: LD_INT 111
60692: EQUAL
60693: IFFALSE 60699
// MC_Defend ( ) ;
60695: CALL 72492 0 0
// if event = 112 then
60699: LD_VAR 0 1
60703: PUSH
60704: LD_INT 112
60706: EQUAL
60707: IFFALSE 60713
// MC_Research ( ) ;
60709: CALL 73097 0 0
// if event = 113 then
60713: LD_VAR 0 1
60717: PUSH
60718: LD_INT 113
60720: EQUAL
60721: IFFALSE 60727
// MC_MinesTrigger ( ) ;
60723: CALL 74211 0 0
// if event = 120 then
60727: LD_VAR 0 1
60731: PUSH
60732: LD_INT 120
60734: EQUAL
60735: IFFALSE 60741
// MC_RepairVehicle ( ) ;
60737: CALL 74310 0 0
// if event = 121 then
60741: LD_VAR 0 1
60745: PUSH
60746: LD_INT 121
60748: EQUAL
60749: IFFALSE 60755
// MC_TameApe ( ) ;
60751: CALL 75040 0 0
// if event = 122 then
60755: LD_VAR 0 1
60759: PUSH
60760: LD_INT 122
60762: EQUAL
60763: IFFALSE 60769
// MC_ChangeApeClass ( ) ;
60765: CALL 75869 0 0
// if event = 123 then
60769: LD_VAR 0 1
60773: PUSH
60774: LD_INT 123
60776: EQUAL
60777: IFFALSE 60783
// MC_Bazooka ( ) ;
60779: CALL 76519 0 0
// if event = 124 then
60783: LD_VAR 0 1
60787: PUSH
60788: LD_INT 124
60790: EQUAL
60791: IFFALSE 60797
// MC_TeleportExit ( ) ;
60793: CALL 76717 0 0
// if event = 125 then
60797: LD_VAR 0 1
60801: PUSH
60802: LD_INT 125
60804: EQUAL
60805: IFFALSE 60811
// MC_Deposits ( ) ;
60807: CALL 77364 0 0
// if event = 126 then
60811: LD_VAR 0 1
60815: PUSH
60816: LD_INT 126
60818: EQUAL
60819: IFFALSE 60825
// MC_RemoteDriver ( ) ;
60821: CALL 77989 0 0
// if event = 200 then
60825: LD_VAR 0 1
60829: PUSH
60830: LD_INT 200
60832: EQUAL
60833: IFFALSE 60839
// MC_Idle ( ) ;
60835: CALL 79722 0 0
// end ;
60839: PPOPN 1
60841: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60842: LD_INT 0
60844: PPUSH
60845: PPUSH
// if not mc_bases [ base ] or not tag then
60846: LD_EXP 58
60850: PUSH
60851: LD_VAR 0 1
60855: ARRAY
60856: NOT
60857: PUSH
60858: LD_VAR 0 2
60862: NOT
60863: OR
60864: IFFALSE 60868
// exit ;
60866: GO 60932
// for i in mc_bases [ base ] union mc_ape [ base ] do
60868: LD_ADDR_VAR 0 4
60872: PUSH
60873: LD_EXP 58
60877: PUSH
60878: LD_VAR 0 1
60882: ARRAY
60883: PUSH
60884: LD_EXP 87
60888: PUSH
60889: LD_VAR 0 1
60893: ARRAY
60894: UNION
60895: PUSH
60896: FOR_IN
60897: IFFALSE 60930
// if GetTag ( i ) = tag then
60899: LD_VAR 0 4
60903: PPUSH
60904: CALL_OW 110
60908: PUSH
60909: LD_VAR 0 2
60913: EQUAL
60914: IFFALSE 60928
// SetTag ( i , 0 ) ;
60916: LD_VAR 0 4
60920: PPUSH
60921: LD_INT 0
60923: PPUSH
60924: CALL_OW 109
60928: GO 60896
60930: POP
60931: POP
// end ;
60932: LD_VAR 0 3
60936: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60937: LD_INT 0
60939: PPUSH
60940: PPUSH
60941: PPUSH
60942: PPUSH
60943: PPUSH
60944: PPUSH
60945: PPUSH
60946: PPUSH
// if not mc_bases then
60947: LD_EXP 58
60951: NOT
60952: IFFALSE 60956
// exit ;
60954: GO 61414
// for i = 1 to mc_bases do
60956: LD_ADDR_VAR 0 2
60960: PUSH
60961: DOUBLE
60962: LD_INT 1
60964: DEC
60965: ST_TO_ADDR
60966: LD_EXP 58
60970: PUSH
60971: FOR_TO
60972: IFFALSE 61412
// begin tmp := MC_ClassCheckReq ( i ) ;
60974: LD_ADDR_VAR 0 4
60978: PUSH
60979: LD_VAR 0 2
60983: PPUSH
60984: CALL 61419 0 1
60988: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60989: LD_ADDR_EXP 99
60993: PUSH
60994: LD_EXP 99
60998: PPUSH
60999: LD_VAR 0 2
61003: PPUSH
61004: LD_VAR 0 4
61008: PPUSH
61009: CALL_OW 1
61013: ST_TO_ADDR
// if not tmp then
61014: LD_VAR 0 4
61018: NOT
61019: IFFALSE 61023
// continue ;
61021: GO 60971
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61023: LD_ADDR_VAR 0 6
61027: PUSH
61028: LD_EXP 58
61032: PUSH
61033: LD_VAR 0 2
61037: ARRAY
61038: PPUSH
61039: LD_INT 2
61041: PUSH
61042: LD_INT 30
61044: PUSH
61045: LD_INT 4
61047: PUSH
61048: EMPTY
61049: LIST
61050: LIST
61051: PUSH
61052: LD_INT 30
61054: PUSH
61055: LD_INT 5
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: LIST
61066: PPUSH
61067: CALL_OW 72
61071: PUSH
61072: LD_EXP 58
61076: PUSH
61077: LD_VAR 0 2
61081: ARRAY
61082: PPUSH
61083: LD_INT 2
61085: PUSH
61086: LD_INT 30
61088: PUSH
61089: LD_INT 0
61091: PUSH
61092: EMPTY
61093: LIST
61094: LIST
61095: PUSH
61096: LD_INT 30
61098: PUSH
61099: LD_INT 1
61101: PUSH
61102: EMPTY
61103: LIST
61104: LIST
61105: PUSH
61106: EMPTY
61107: LIST
61108: LIST
61109: LIST
61110: PPUSH
61111: CALL_OW 72
61115: PUSH
61116: LD_EXP 58
61120: PUSH
61121: LD_VAR 0 2
61125: ARRAY
61126: PPUSH
61127: LD_INT 30
61129: PUSH
61130: LD_INT 3
61132: PUSH
61133: EMPTY
61134: LIST
61135: LIST
61136: PPUSH
61137: CALL_OW 72
61141: PUSH
61142: LD_EXP 58
61146: PUSH
61147: LD_VAR 0 2
61151: ARRAY
61152: PPUSH
61153: LD_INT 2
61155: PUSH
61156: LD_INT 30
61158: PUSH
61159: LD_INT 6
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PUSH
61166: LD_INT 30
61168: PUSH
61169: LD_INT 7
61171: PUSH
61172: EMPTY
61173: LIST
61174: LIST
61175: PUSH
61176: LD_INT 30
61178: PUSH
61179: LD_INT 8
61181: PUSH
61182: EMPTY
61183: LIST
61184: LIST
61185: PUSH
61186: EMPTY
61187: LIST
61188: LIST
61189: LIST
61190: LIST
61191: PPUSH
61192: CALL_OW 72
61196: PUSH
61197: EMPTY
61198: LIST
61199: LIST
61200: LIST
61201: LIST
61202: ST_TO_ADDR
// for j = 1 to 4 do
61203: LD_ADDR_VAR 0 3
61207: PUSH
61208: DOUBLE
61209: LD_INT 1
61211: DEC
61212: ST_TO_ADDR
61213: LD_INT 4
61215: PUSH
61216: FOR_TO
61217: IFFALSE 61408
// begin if not tmp [ j ] then
61219: LD_VAR 0 4
61223: PUSH
61224: LD_VAR 0 3
61228: ARRAY
61229: NOT
61230: IFFALSE 61234
// continue ;
61232: GO 61216
// for p in tmp [ j ] do
61234: LD_ADDR_VAR 0 5
61238: PUSH
61239: LD_VAR 0 4
61243: PUSH
61244: LD_VAR 0 3
61248: ARRAY
61249: PUSH
61250: FOR_IN
61251: IFFALSE 61404
// begin if not b [ j ] then
61253: LD_VAR 0 6
61257: PUSH
61258: LD_VAR 0 3
61262: ARRAY
61263: NOT
61264: IFFALSE 61268
// break ;
61266: GO 61404
// e := 0 ;
61268: LD_ADDR_VAR 0 7
61272: PUSH
61273: LD_INT 0
61275: ST_TO_ADDR
// for k in b [ j ] do
61276: LD_ADDR_VAR 0 8
61280: PUSH
61281: LD_VAR 0 6
61285: PUSH
61286: LD_VAR 0 3
61290: ARRAY
61291: PUSH
61292: FOR_IN
61293: IFFALSE 61320
// if IsNotFull ( k ) then
61295: LD_VAR 0 8
61299: PPUSH
61300: CALL 18105 0 1
61304: IFFALSE 61318
// begin e := k ;
61306: LD_ADDR_VAR 0 7
61310: PUSH
61311: LD_VAR 0 8
61315: ST_TO_ADDR
// break ;
61316: GO 61320
// end ;
61318: GO 61292
61320: POP
61321: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61322: LD_VAR 0 7
61326: PUSH
61327: LD_VAR 0 5
61331: PPUSH
61332: LD_VAR 0 7
61336: PPUSH
61337: CALL 55224 0 2
61341: NOT
61342: AND
61343: IFFALSE 61402
// begin if IsInUnit ( p ) then
61345: LD_VAR 0 5
61349: PPUSH
61350: CALL_OW 310
61354: IFFALSE 61365
// ComExitBuilding ( p ) ;
61356: LD_VAR 0 5
61360: PPUSH
61361: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61365: LD_VAR 0 5
61369: PPUSH
61370: LD_VAR 0 7
61374: PPUSH
61375: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61379: LD_VAR 0 5
61383: PPUSH
61384: LD_VAR 0 3
61388: PPUSH
61389: CALL_OW 183
// AddComExitBuilding ( p ) ;
61393: LD_VAR 0 5
61397: PPUSH
61398: CALL_OW 182
// end ; end ;
61402: GO 61250
61404: POP
61405: POP
// end ;
61406: GO 61216
61408: POP
61409: POP
// end ;
61410: GO 60971
61412: POP
61413: POP
// end ;
61414: LD_VAR 0 1
61418: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61419: LD_INT 0
61421: PPUSH
61422: PPUSH
61423: PPUSH
61424: PPUSH
61425: PPUSH
61426: PPUSH
61427: PPUSH
61428: PPUSH
61429: PPUSH
61430: PPUSH
61431: PPUSH
61432: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61433: LD_VAR 0 1
61437: NOT
61438: PUSH
61439: LD_EXP 58
61443: PUSH
61444: LD_VAR 0 1
61448: ARRAY
61449: NOT
61450: OR
61451: PUSH
61452: LD_EXP 58
61456: PUSH
61457: LD_VAR 0 1
61461: ARRAY
61462: PPUSH
61463: LD_INT 2
61465: PUSH
61466: LD_INT 30
61468: PUSH
61469: LD_INT 0
61471: PUSH
61472: EMPTY
61473: LIST
61474: LIST
61475: PUSH
61476: LD_INT 30
61478: PUSH
61479: LD_INT 1
61481: PUSH
61482: EMPTY
61483: LIST
61484: LIST
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: LIST
61490: PPUSH
61491: CALL_OW 72
61495: NOT
61496: OR
61497: IFFALSE 61501
// exit ;
61499: GO 65004
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61501: LD_ADDR_VAR 0 4
61505: PUSH
61506: LD_EXP 58
61510: PUSH
61511: LD_VAR 0 1
61515: ARRAY
61516: PPUSH
61517: LD_INT 2
61519: PUSH
61520: LD_INT 25
61522: PUSH
61523: LD_INT 1
61525: PUSH
61526: EMPTY
61527: LIST
61528: LIST
61529: PUSH
61530: LD_INT 25
61532: PUSH
61533: LD_INT 2
61535: PUSH
61536: EMPTY
61537: LIST
61538: LIST
61539: PUSH
61540: LD_INT 25
61542: PUSH
61543: LD_INT 3
61545: PUSH
61546: EMPTY
61547: LIST
61548: LIST
61549: PUSH
61550: LD_INT 25
61552: PUSH
61553: LD_INT 4
61555: PUSH
61556: EMPTY
61557: LIST
61558: LIST
61559: PUSH
61560: LD_INT 25
61562: PUSH
61563: LD_INT 5
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: PUSH
61570: LD_INT 25
61572: PUSH
61573: LD_INT 8
61575: PUSH
61576: EMPTY
61577: LIST
61578: LIST
61579: PUSH
61580: LD_INT 25
61582: PUSH
61583: LD_INT 9
61585: PUSH
61586: EMPTY
61587: LIST
61588: LIST
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: LIST
61594: LIST
61595: LIST
61596: LIST
61597: LIST
61598: LIST
61599: PPUSH
61600: CALL_OW 72
61604: ST_TO_ADDR
// if not tmp then
61605: LD_VAR 0 4
61609: NOT
61610: IFFALSE 61614
// exit ;
61612: GO 65004
// for i in tmp do
61614: LD_ADDR_VAR 0 3
61618: PUSH
61619: LD_VAR 0 4
61623: PUSH
61624: FOR_IN
61625: IFFALSE 61656
// if GetTag ( i ) then
61627: LD_VAR 0 3
61631: PPUSH
61632: CALL_OW 110
61636: IFFALSE 61654
// tmp := tmp diff i ;
61638: LD_ADDR_VAR 0 4
61642: PUSH
61643: LD_VAR 0 4
61647: PUSH
61648: LD_VAR 0 3
61652: DIFF
61653: ST_TO_ADDR
61654: GO 61624
61656: POP
61657: POP
// if not tmp then
61658: LD_VAR 0 4
61662: NOT
61663: IFFALSE 61667
// exit ;
61665: GO 65004
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61667: LD_ADDR_VAR 0 5
61671: PUSH
61672: LD_EXP 58
61676: PUSH
61677: LD_VAR 0 1
61681: ARRAY
61682: PPUSH
61683: LD_INT 2
61685: PUSH
61686: LD_INT 25
61688: PUSH
61689: LD_INT 1
61691: PUSH
61692: EMPTY
61693: LIST
61694: LIST
61695: PUSH
61696: LD_INT 25
61698: PUSH
61699: LD_INT 5
61701: PUSH
61702: EMPTY
61703: LIST
61704: LIST
61705: PUSH
61706: LD_INT 25
61708: PUSH
61709: LD_INT 8
61711: PUSH
61712: EMPTY
61713: LIST
61714: LIST
61715: PUSH
61716: LD_INT 25
61718: PUSH
61719: LD_INT 9
61721: PUSH
61722: EMPTY
61723: LIST
61724: LIST
61725: PUSH
61726: EMPTY
61727: LIST
61728: LIST
61729: LIST
61730: LIST
61731: LIST
61732: PPUSH
61733: CALL_OW 72
61737: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61738: LD_ADDR_VAR 0 6
61742: PUSH
61743: LD_EXP 58
61747: PUSH
61748: LD_VAR 0 1
61752: ARRAY
61753: PPUSH
61754: LD_INT 25
61756: PUSH
61757: LD_INT 2
61759: PUSH
61760: EMPTY
61761: LIST
61762: LIST
61763: PPUSH
61764: CALL_OW 72
61768: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61769: LD_ADDR_VAR 0 7
61773: PUSH
61774: LD_EXP 58
61778: PUSH
61779: LD_VAR 0 1
61783: ARRAY
61784: PPUSH
61785: LD_INT 25
61787: PUSH
61788: LD_INT 3
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: PPUSH
61795: CALL_OW 72
61799: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61800: LD_ADDR_VAR 0 8
61804: PUSH
61805: LD_EXP 58
61809: PUSH
61810: LD_VAR 0 1
61814: ARRAY
61815: PPUSH
61816: LD_INT 25
61818: PUSH
61819: LD_INT 4
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: LD_INT 24
61828: PUSH
61829: LD_INT 251
61831: PUSH
61832: EMPTY
61833: LIST
61834: LIST
61835: PUSH
61836: EMPTY
61837: LIST
61838: LIST
61839: PPUSH
61840: CALL_OW 72
61844: ST_TO_ADDR
// if mc_scan [ base ] then
61845: LD_EXP 81
61849: PUSH
61850: LD_VAR 0 1
61854: ARRAY
61855: IFFALSE 62316
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61857: LD_ADDR_EXP 100
61861: PUSH
61862: LD_EXP 100
61866: PPUSH
61867: LD_VAR 0 1
61871: PPUSH
61872: LD_INT 4
61874: PPUSH
61875: CALL_OW 1
61879: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61880: LD_ADDR_VAR 0 12
61884: PUSH
61885: LD_EXP 58
61889: PUSH
61890: LD_VAR 0 1
61894: ARRAY
61895: PPUSH
61896: LD_INT 2
61898: PUSH
61899: LD_INT 30
61901: PUSH
61902: LD_INT 4
61904: PUSH
61905: EMPTY
61906: LIST
61907: LIST
61908: PUSH
61909: LD_INT 30
61911: PUSH
61912: LD_INT 5
61914: PUSH
61915: EMPTY
61916: LIST
61917: LIST
61918: PUSH
61919: EMPTY
61920: LIST
61921: LIST
61922: LIST
61923: PPUSH
61924: CALL_OW 72
61928: ST_TO_ADDR
// if not b then
61929: LD_VAR 0 12
61933: NOT
61934: IFFALSE 61938
// exit ;
61936: GO 65004
// p := [ ] ;
61938: LD_ADDR_VAR 0 11
61942: PUSH
61943: EMPTY
61944: ST_TO_ADDR
// if sci >= 2 then
61945: LD_VAR 0 8
61949: PUSH
61950: LD_INT 2
61952: GREATEREQUAL
61953: IFFALSE 61984
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61955: LD_ADDR_VAR 0 8
61959: PUSH
61960: LD_VAR 0 8
61964: PUSH
61965: LD_INT 1
61967: ARRAY
61968: PUSH
61969: LD_VAR 0 8
61973: PUSH
61974: LD_INT 2
61976: ARRAY
61977: PUSH
61978: EMPTY
61979: LIST
61980: LIST
61981: ST_TO_ADDR
61982: GO 62045
// if sci = 1 then
61984: LD_VAR 0 8
61988: PUSH
61989: LD_INT 1
61991: EQUAL
61992: IFFALSE 62013
// sci := [ sci [ 1 ] ] else
61994: LD_ADDR_VAR 0 8
61998: PUSH
61999: LD_VAR 0 8
62003: PUSH
62004: LD_INT 1
62006: ARRAY
62007: PUSH
62008: EMPTY
62009: LIST
62010: ST_TO_ADDR
62011: GO 62045
// if sci = 0 then
62013: LD_VAR 0 8
62017: PUSH
62018: LD_INT 0
62020: EQUAL
62021: IFFALSE 62045
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62023: LD_ADDR_VAR 0 11
62027: PUSH
62028: LD_VAR 0 4
62032: PPUSH
62033: LD_INT 4
62035: PPUSH
62036: CALL 55087 0 2
62040: PUSH
62041: LD_INT 1
62043: ARRAY
62044: ST_TO_ADDR
// if eng > 4 then
62045: LD_VAR 0 6
62049: PUSH
62050: LD_INT 4
62052: GREATER
62053: IFFALSE 62099
// for i = eng downto 4 do
62055: LD_ADDR_VAR 0 3
62059: PUSH
62060: DOUBLE
62061: LD_VAR 0 6
62065: INC
62066: ST_TO_ADDR
62067: LD_INT 4
62069: PUSH
62070: FOR_DOWNTO
62071: IFFALSE 62097
// eng := eng diff eng [ i ] ;
62073: LD_ADDR_VAR 0 6
62077: PUSH
62078: LD_VAR 0 6
62082: PUSH
62083: LD_VAR 0 6
62087: PUSH
62088: LD_VAR 0 3
62092: ARRAY
62093: DIFF
62094: ST_TO_ADDR
62095: GO 62070
62097: POP
62098: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62099: LD_ADDR_VAR 0 4
62103: PUSH
62104: LD_VAR 0 4
62108: PUSH
62109: LD_VAR 0 5
62113: PUSH
62114: LD_VAR 0 6
62118: UNION
62119: PUSH
62120: LD_VAR 0 7
62124: UNION
62125: PUSH
62126: LD_VAR 0 8
62130: UNION
62131: DIFF
62132: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62133: LD_ADDR_VAR 0 13
62137: PUSH
62138: LD_EXP 58
62142: PUSH
62143: LD_VAR 0 1
62147: ARRAY
62148: PPUSH
62149: LD_INT 2
62151: PUSH
62152: LD_INT 30
62154: PUSH
62155: LD_INT 32
62157: PUSH
62158: EMPTY
62159: LIST
62160: LIST
62161: PUSH
62162: LD_INT 30
62164: PUSH
62165: LD_INT 31
62167: PUSH
62168: EMPTY
62169: LIST
62170: LIST
62171: PUSH
62172: EMPTY
62173: LIST
62174: LIST
62175: LIST
62176: PPUSH
62177: CALL_OW 72
62181: PUSH
62182: LD_EXP 58
62186: PUSH
62187: LD_VAR 0 1
62191: ARRAY
62192: PPUSH
62193: LD_INT 2
62195: PUSH
62196: LD_INT 30
62198: PUSH
62199: LD_INT 4
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PUSH
62206: LD_INT 30
62208: PUSH
62209: LD_INT 5
62211: PUSH
62212: EMPTY
62213: LIST
62214: LIST
62215: PUSH
62216: EMPTY
62217: LIST
62218: LIST
62219: LIST
62220: PPUSH
62221: CALL_OW 72
62225: PUSH
62226: LD_INT 6
62228: MUL
62229: PLUS
62230: ST_TO_ADDR
// if bcount < tmp then
62231: LD_VAR 0 13
62235: PUSH
62236: LD_VAR 0 4
62240: LESS
62241: IFFALSE 62287
// for i = tmp downto bcount do
62243: LD_ADDR_VAR 0 3
62247: PUSH
62248: DOUBLE
62249: LD_VAR 0 4
62253: INC
62254: ST_TO_ADDR
62255: LD_VAR 0 13
62259: PUSH
62260: FOR_DOWNTO
62261: IFFALSE 62285
// tmp := Delete ( tmp , tmp ) ;
62263: LD_ADDR_VAR 0 4
62267: PUSH
62268: LD_VAR 0 4
62272: PPUSH
62273: LD_VAR 0 4
62277: PPUSH
62278: CALL_OW 3
62282: ST_TO_ADDR
62283: GO 62260
62285: POP
62286: POP
// result := [ tmp , 0 , 0 , p ] ;
62287: LD_ADDR_VAR 0 2
62291: PUSH
62292: LD_VAR 0 4
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: LD_INT 0
62302: PUSH
62303: LD_VAR 0 11
62307: PUSH
62308: EMPTY
62309: LIST
62310: LIST
62311: LIST
62312: LIST
62313: ST_TO_ADDR
// exit ;
62314: GO 65004
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62316: LD_EXP 58
62320: PUSH
62321: LD_VAR 0 1
62325: ARRAY
62326: PPUSH
62327: LD_INT 2
62329: PUSH
62330: LD_INT 30
62332: PUSH
62333: LD_INT 6
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: PUSH
62340: LD_INT 30
62342: PUSH
62343: LD_INT 7
62345: PUSH
62346: EMPTY
62347: LIST
62348: LIST
62349: PUSH
62350: LD_INT 30
62352: PUSH
62353: LD_INT 8
62355: PUSH
62356: EMPTY
62357: LIST
62358: LIST
62359: PUSH
62360: EMPTY
62361: LIST
62362: LIST
62363: LIST
62364: LIST
62365: PPUSH
62366: CALL_OW 72
62370: NOT
62371: PUSH
62372: LD_EXP 58
62376: PUSH
62377: LD_VAR 0 1
62381: ARRAY
62382: PPUSH
62383: LD_INT 30
62385: PUSH
62386: LD_INT 3
62388: PUSH
62389: EMPTY
62390: LIST
62391: LIST
62392: PPUSH
62393: CALL_OW 72
62397: NOT
62398: AND
62399: IFFALSE 62471
// begin if eng = tmp then
62401: LD_VAR 0 6
62405: PUSH
62406: LD_VAR 0 4
62410: EQUAL
62411: IFFALSE 62415
// exit ;
62413: GO 65004
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62415: LD_ADDR_EXP 100
62419: PUSH
62420: LD_EXP 100
62424: PPUSH
62425: LD_VAR 0 1
62429: PPUSH
62430: LD_INT 1
62432: PPUSH
62433: CALL_OW 1
62437: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62438: LD_ADDR_VAR 0 2
62442: PUSH
62443: LD_INT 0
62445: PUSH
62446: LD_VAR 0 4
62450: PUSH
62451: LD_VAR 0 6
62455: DIFF
62456: PUSH
62457: LD_INT 0
62459: PUSH
62460: LD_INT 0
62462: PUSH
62463: EMPTY
62464: LIST
62465: LIST
62466: LIST
62467: LIST
62468: ST_TO_ADDR
// exit ;
62469: GO 65004
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62471: LD_EXP 85
62475: PUSH
62476: LD_EXP 84
62480: PUSH
62481: LD_VAR 0 1
62485: ARRAY
62486: ARRAY
62487: PUSH
62488: LD_EXP 58
62492: PUSH
62493: LD_VAR 0 1
62497: ARRAY
62498: PPUSH
62499: LD_INT 2
62501: PUSH
62502: LD_INT 30
62504: PUSH
62505: LD_INT 6
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 30
62514: PUSH
62515: LD_INT 7
62517: PUSH
62518: EMPTY
62519: LIST
62520: LIST
62521: PUSH
62522: LD_INT 30
62524: PUSH
62525: LD_INT 8
62527: PUSH
62528: EMPTY
62529: LIST
62530: LIST
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: PPUSH
62538: CALL_OW 72
62542: AND
62543: PUSH
62544: LD_EXP 58
62548: PUSH
62549: LD_VAR 0 1
62553: ARRAY
62554: PPUSH
62555: LD_INT 30
62557: PUSH
62558: LD_INT 3
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PPUSH
62565: CALL_OW 72
62569: NOT
62570: AND
62571: IFFALSE 62785
// begin if sci >= 6 then
62573: LD_VAR 0 8
62577: PUSH
62578: LD_INT 6
62580: GREATEREQUAL
62581: IFFALSE 62585
// exit ;
62583: GO 65004
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62585: LD_ADDR_EXP 100
62589: PUSH
62590: LD_EXP 100
62594: PPUSH
62595: LD_VAR 0 1
62599: PPUSH
62600: LD_INT 2
62602: PPUSH
62603: CALL_OW 1
62607: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62608: LD_ADDR_VAR 0 9
62612: PUSH
62613: LD_VAR 0 4
62617: PUSH
62618: LD_VAR 0 8
62622: DIFF
62623: PPUSH
62624: LD_INT 4
62626: PPUSH
62627: CALL 55087 0 2
62631: ST_TO_ADDR
// p := [ ] ;
62632: LD_ADDR_VAR 0 11
62636: PUSH
62637: EMPTY
62638: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62639: LD_VAR 0 8
62643: PUSH
62644: LD_INT 6
62646: LESS
62647: PUSH
62648: LD_VAR 0 9
62652: PUSH
62653: LD_INT 6
62655: GREATER
62656: AND
62657: IFFALSE 62738
// begin for i = 1 to 6 - sci do
62659: LD_ADDR_VAR 0 3
62663: PUSH
62664: DOUBLE
62665: LD_INT 1
62667: DEC
62668: ST_TO_ADDR
62669: LD_INT 6
62671: PUSH
62672: LD_VAR 0 8
62676: MINUS
62677: PUSH
62678: FOR_TO
62679: IFFALSE 62734
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62681: LD_ADDR_VAR 0 11
62685: PUSH
62686: LD_VAR 0 11
62690: PPUSH
62691: LD_VAR 0 11
62695: PUSH
62696: LD_INT 1
62698: PLUS
62699: PPUSH
62700: LD_VAR 0 9
62704: PUSH
62705: LD_INT 1
62707: ARRAY
62708: PPUSH
62709: CALL_OW 2
62713: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62714: LD_ADDR_VAR 0 9
62718: PUSH
62719: LD_VAR 0 9
62723: PPUSH
62724: LD_INT 1
62726: PPUSH
62727: CALL_OW 3
62731: ST_TO_ADDR
// end ;
62732: GO 62678
62734: POP
62735: POP
// end else
62736: GO 62758
// if sort then
62738: LD_VAR 0 9
62742: IFFALSE 62758
// p := sort [ 1 ] ;
62744: LD_ADDR_VAR 0 11
62748: PUSH
62749: LD_VAR 0 9
62753: PUSH
62754: LD_INT 1
62756: ARRAY
62757: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62758: LD_ADDR_VAR 0 2
62762: PUSH
62763: LD_INT 0
62765: PUSH
62766: LD_INT 0
62768: PUSH
62769: LD_INT 0
62771: PUSH
62772: LD_VAR 0 11
62776: PUSH
62777: EMPTY
62778: LIST
62779: LIST
62780: LIST
62781: LIST
62782: ST_TO_ADDR
// exit ;
62783: GO 65004
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62785: LD_EXP 85
62789: PUSH
62790: LD_EXP 84
62794: PUSH
62795: LD_VAR 0 1
62799: ARRAY
62800: ARRAY
62801: PUSH
62802: LD_EXP 58
62806: PUSH
62807: LD_VAR 0 1
62811: ARRAY
62812: PPUSH
62813: LD_INT 2
62815: PUSH
62816: LD_INT 30
62818: PUSH
62819: LD_INT 6
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: LD_INT 30
62828: PUSH
62829: LD_INT 7
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: PUSH
62836: LD_INT 30
62838: PUSH
62839: LD_INT 8
62841: PUSH
62842: EMPTY
62843: LIST
62844: LIST
62845: PUSH
62846: EMPTY
62847: LIST
62848: LIST
62849: LIST
62850: LIST
62851: PPUSH
62852: CALL_OW 72
62856: AND
62857: PUSH
62858: LD_EXP 58
62862: PUSH
62863: LD_VAR 0 1
62867: ARRAY
62868: PPUSH
62869: LD_INT 30
62871: PUSH
62872: LD_INT 3
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PPUSH
62879: CALL_OW 72
62883: AND
62884: IFFALSE 63618
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62886: LD_ADDR_EXP 100
62890: PUSH
62891: LD_EXP 100
62895: PPUSH
62896: LD_VAR 0 1
62900: PPUSH
62901: LD_INT 3
62903: PPUSH
62904: CALL_OW 1
62908: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62909: LD_ADDR_VAR 0 2
62913: PUSH
62914: LD_INT 0
62916: PUSH
62917: LD_INT 0
62919: PUSH
62920: LD_INT 0
62922: PUSH
62923: LD_INT 0
62925: PUSH
62926: EMPTY
62927: LIST
62928: LIST
62929: LIST
62930: LIST
62931: ST_TO_ADDR
// if not eng then
62932: LD_VAR 0 6
62936: NOT
62937: IFFALSE 63000
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62939: LD_ADDR_VAR 0 11
62943: PUSH
62944: LD_VAR 0 4
62948: PPUSH
62949: LD_INT 2
62951: PPUSH
62952: CALL 55087 0 2
62956: PUSH
62957: LD_INT 1
62959: ARRAY
62960: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62961: LD_ADDR_VAR 0 2
62965: PUSH
62966: LD_VAR 0 2
62970: PPUSH
62971: LD_INT 2
62973: PPUSH
62974: LD_VAR 0 11
62978: PPUSH
62979: CALL_OW 1
62983: ST_TO_ADDR
// tmp := tmp diff p ;
62984: LD_ADDR_VAR 0 4
62988: PUSH
62989: LD_VAR 0 4
62993: PUSH
62994: LD_VAR 0 11
62998: DIFF
62999: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63000: LD_VAR 0 4
63004: PUSH
63005: LD_VAR 0 8
63009: PUSH
63010: LD_INT 6
63012: LESS
63013: AND
63014: IFFALSE 63202
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63016: LD_ADDR_VAR 0 9
63020: PUSH
63021: LD_VAR 0 4
63025: PUSH
63026: LD_VAR 0 8
63030: PUSH
63031: LD_VAR 0 7
63035: UNION
63036: DIFF
63037: PPUSH
63038: LD_INT 4
63040: PPUSH
63041: CALL 55087 0 2
63045: ST_TO_ADDR
// p := [ ] ;
63046: LD_ADDR_VAR 0 11
63050: PUSH
63051: EMPTY
63052: ST_TO_ADDR
// if sort then
63053: LD_VAR 0 9
63057: IFFALSE 63173
// for i = 1 to 6 - sci do
63059: LD_ADDR_VAR 0 3
63063: PUSH
63064: DOUBLE
63065: LD_INT 1
63067: DEC
63068: ST_TO_ADDR
63069: LD_INT 6
63071: PUSH
63072: LD_VAR 0 8
63076: MINUS
63077: PUSH
63078: FOR_TO
63079: IFFALSE 63171
// begin if i = sort then
63081: LD_VAR 0 3
63085: PUSH
63086: LD_VAR 0 9
63090: EQUAL
63091: IFFALSE 63095
// break ;
63093: GO 63171
// if GetClass ( i ) = 4 then
63095: LD_VAR 0 3
63099: PPUSH
63100: CALL_OW 257
63104: PUSH
63105: LD_INT 4
63107: EQUAL
63108: IFFALSE 63112
// continue ;
63110: GO 63078
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63112: LD_ADDR_VAR 0 11
63116: PUSH
63117: LD_VAR 0 11
63121: PPUSH
63122: LD_VAR 0 11
63126: PUSH
63127: LD_INT 1
63129: PLUS
63130: PPUSH
63131: LD_VAR 0 9
63135: PUSH
63136: LD_VAR 0 3
63140: ARRAY
63141: PPUSH
63142: CALL_OW 2
63146: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63147: LD_ADDR_VAR 0 4
63151: PUSH
63152: LD_VAR 0 4
63156: PUSH
63157: LD_VAR 0 9
63161: PUSH
63162: LD_VAR 0 3
63166: ARRAY
63167: DIFF
63168: ST_TO_ADDR
// end ;
63169: GO 63078
63171: POP
63172: POP
// if p then
63173: LD_VAR 0 11
63177: IFFALSE 63202
// result := Replace ( result , 4 , p ) ;
63179: LD_ADDR_VAR 0 2
63183: PUSH
63184: LD_VAR 0 2
63188: PPUSH
63189: LD_INT 4
63191: PPUSH
63192: LD_VAR 0 11
63196: PPUSH
63197: CALL_OW 1
63201: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63202: LD_VAR 0 4
63206: PUSH
63207: LD_VAR 0 7
63211: PUSH
63212: LD_INT 6
63214: LESS
63215: AND
63216: IFFALSE 63404
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63218: LD_ADDR_VAR 0 9
63222: PUSH
63223: LD_VAR 0 4
63227: PUSH
63228: LD_VAR 0 8
63232: PUSH
63233: LD_VAR 0 7
63237: UNION
63238: DIFF
63239: PPUSH
63240: LD_INT 3
63242: PPUSH
63243: CALL 55087 0 2
63247: ST_TO_ADDR
// p := [ ] ;
63248: LD_ADDR_VAR 0 11
63252: PUSH
63253: EMPTY
63254: ST_TO_ADDR
// if sort then
63255: LD_VAR 0 9
63259: IFFALSE 63375
// for i = 1 to 6 - mech do
63261: LD_ADDR_VAR 0 3
63265: PUSH
63266: DOUBLE
63267: LD_INT 1
63269: DEC
63270: ST_TO_ADDR
63271: LD_INT 6
63273: PUSH
63274: LD_VAR 0 7
63278: MINUS
63279: PUSH
63280: FOR_TO
63281: IFFALSE 63373
// begin if i = sort then
63283: LD_VAR 0 3
63287: PUSH
63288: LD_VAR 0 9
63292: EQUAL
63293: IFFALSE 63297
// break ;
63295: GO 63373
// if GetClass ( i ) = 3 then
63297: LD_VAR 0 3
63301: PPUSH
63302: CALL_OW 257
63306: PUSH
63307: LD_INT 3
63309: EQUAL
63310: IFFALSE 63314
// continue ;
63312: GO 63280
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63314: LD_ADDR_VAR 0 11
63318: PUSH
63319: LD_VAR 0 11
63323: PPUSH
63324: LD_VAR 0 11
63328: PUSH
63329: LD_INT 1
63331: PLUS
63332: PPUSH
63333: LD_VAR 0 9
63337: PUSH
63338: LD_VAR 0 3
63342: ARRAY
63343: PPUSH
63344: CALL_OW 2
63348: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63349: LD_ADDR_VAR 0 4
63353: PUSH
63354: LD_VAR 0 4
63358: PUSH
63359: LD_VAR 0 9
63363: PUSH
63364: LD_VAR 0 3
63368: ARRAY
63369: DIFF
63370: ST_TO_ADDR
// end ;
63371: GO 63280
63373: POP
63374: POP
// if p then
63375: LD_VAR 0 11
63379: IFFALSE 63404
// result := Replace ( result , 3 , p ) ;
63381: LD_ADDR_VAR 0 2
63385: PUSH
63386: LD_VAR 0 2
63390: PPUSH
63391: LD_INT 3
63393: PPUSH
63394: LD_VAR 0 11
63398: PPUSH
63399: CALL_OW 1
63403: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63404: LD_VAR 0 4
63408: PUSH
63409: LD_INT 6
63411: GREATER
63412: PUSH
63413: LD_VAR 0 6
63417: PUSH
63418: LD_INT 6
63420: LESS
63421: AND
63422: IFFALSE 63616
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63424: LD_ADDR_VAR 0 9
63428: PUSH
63429: LD_VAR 0 4
63433: PUSH
63434: LD_VAR 0 8
63438: PUSH
63439: LD_VAR 0 7
63443: UNION
63444: PUSH
63445: LD_VAR 0 6
63449: UNION
63450: DIFF
63451: PPUSH
63452: LD_INT 2
63454: PPUSH
63455: CALL 55087 0 2
63459: ST_TO_ADDR
// p := [ ] ;
63460: LD_ADDR_VAR 0 11
63464: PUSH
63465: EMPTY
63466: ST_TO_ADDR
// if sort then
63467: LD_VAR 0 9
63471: IFFALSE 63587
// for i = 1 to 6 - eng do
63473: LD_ADDR_VAR 0 3
63477: PUSH
63478: DOUBLE
63479: LD_INT 1
63481: DEC
63482: ST_TO_ADDR
63483: LD_INT 6
63485: PUSH
63486: LD_VAR 0 6
63490: MINUS
63491: PUSH
63492: FOR_TO
63493: IFFALSE 63585
// begin if i = sort then
63495: LD_VAR 0 3
63499: PUSH
63500: LD_VAR 0 9
63504: EQUAL
63505: IFFALSE 63509
// break ;
63507: GO 63585
// if GetClass ( i ) = 2 then
63509: LD_VAR 0 3
63513: PPUSH
63514: CALL_OW 257
63518: PUSH
63519: LD_INT 2
63521: EQUAL
63522: IFFALSE 63526
// continue ;
63524: GO 63492
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63526: LD_ADDR_VAR 0 11
63530: PUSH
63531: LD_VAR 0 11
63535: PPUSH
63536: LD_VAR 0 11
63540: PUSH
63541: LD_INT 1
63543: PLUS
63544: PPUSH
63545: LD_VAR 0 9
63549: PUSH
63550: LD_VAR 0 3
63554: ARRAY
63555: PPUSH
63556: CALL_OW 2
63560: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63561: LD_ADDR_VAR 0 4
63565: PUSH
63566: LD_VAR 0 4
63570: PUSH
63571: LD_VAR 0 9
63575: PUSH
63576: LD_VAR 0 3
63580: ARRAY
63581: DIFF
63582: ST_TO_ADDR
// end ;
63583: GO 63492
63585: POP
63586: POP
// if p then
63587: LD_VAR 0 11
63591: IFFALSE 63616
// result := Replace ( result , 2 , p ) ;
63593: LD_ADDR_VAR 0 2
63597: PUSH
63598: LD_VAR 0 2
63602: PPUSH
63603: LD_INT 2
63605: PPUSH
63606: LD_VAR 0 11
63610: PPUSH
63611: CALL_OW 1
63615: ST_TO_ADDR
// end ; exit ;
63616: GO 65004
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63618: LD_EXP 85
63622: PUSH
63623: LD_EXP 84
63627: PUSH
63628: LD_VAR 0 1
63632: ARRAY
63633: ARRAY
63634: NOT
63635: PUSH
63636: LD_EXP 58
63640: PUSH
63641: LD_VAR 0 1
63645: ARRAY
63646: PPUSH
63647: LD_INT 30
63649: PUSH
63650: LD_INT 3
63652: PUSH
63653: EMPTY
63654: LIST
63655: LIST
63656: PPUSH
63657: CALL_OW 72
63661: AND
63662: PUSH
63663: LD_EXP 63
63667: PUSH
63668: LD_VAR 0 1
63672: ARRAY
63673: AND
63674: IFFALSE 64282
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63676: LD_ADDR_EXP 100
63680: PUSH
63681: LD_EXP 100
63685: PPUSH
63686: LD_VAR 0 1
63690: PPUSH
63691: LD_INT 5
63693: PPUSH
63694: CALL_OW 1
63698: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63699: LD_ADDR_VAR 0 2
63703: PUSH
63704: LD_INT 0
63706: PUSH
63707: LD_INT 0
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 0
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: LIST
63720: LIST
63721: ST_TO_ADDR
// if sci > 1 then
63722: LD_VAR 0 8
63726: PUSH
63727: LD_INT 1
63729: GREATER
63730: IFFALSE 63758
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63732: LD_ADDR_VAR 0 4
63736: PUSH
63737: LD_VAR 0 4
63741: PUSH
63742: LD_VAR 0 8
63746: PUSH
63747: LD_VAR 0 8
63751: PUSH
63752: LD_INT 1
63754: ARRAY
63755: DIFF
63756: DIFF
63757: ST_TO_ADDR
// if tmp and not sci then
63758: LD_VAR 0 4
63762: PUSH
63763: LD_VAR 0 8
63767: NOT
63768: AND
63769: IFFALSE 63838
// begin sort := SortBySkill ( tmp , 4 ) ;
63771: LD_ADDR_VAR 0 9
63775: PUSH
63776: LD_VAR 0 4
63780: PPUSH
63781: LD_INT 4
63783: PPUSH
63784: CALL 55087 0 2
63788: ST_TO_ADDR
// if sort then
63789: LD_VAR 0 9
63793: IFFALSE 63809
// p := sort [ 1 ] ;
63795: LD_ADDR_VAR 0 11
63799: PUSH
63800: LD_VAR 0 9
63804: PUSH
63805: LD_INT 1
63807: ARRAY
63808: ST_TO_ADDR
// if p then
63809: LD_VAR 0 11
63813: IFFALSE 63838
// result := Replace ( result , 4 , p ) ;
63815: LD_ADDR_VAR 0 2
63819: PUSH
63820: LD_VAR 0 2
63824: PPUSH
63825: LD_INT 4
63827: PPUSH
63828: LD_VAR 0 11
63832: PPUSH
63833: CALL_OW 1
63837: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63838: LD_ADDR_VAR 0 4
63842: PUSH
63843: LD_VAR 0 4
63847: PUSH
63848: LD_VAR 0 7
63852: DIFF
63853: ST_TO_ADDR
// if tmp and mech < 6 then
63854: LD_VAR 0 4
63858: PUSH
63859: LD_VAR 0 7
63863: PUSH
63864: LD_INT 6
63866: LESS
63867: AND
63868: IFFALSE 64056
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63870: LD_ADDR_VAR 0 9
63874: PUSH
63875: LD_VAR 0 4
63879: PUSH
63880: LD_VAR 0 8
63884: PUSH
63885: LD_VAR 0 7
63889: UNION
63890: DIFF
63891: PPUSH
63892: LD_INT 3
63894: PPUSH
63895: CALL 55087 0 2
63899: ST_TO_ADDR
// p := [ ] ;
63900: LD_ADDR_VAR 0 11
63904: PUSH
63905: EMPTY
63906: ST_TO_ADDR
// if sort then
63907: LD_VAR 0 9
63911: IFFALSE 64027
// for i = 1 to 6 - mech do
63913: LD_ADDR_VAR 0 3
63917: PUSH
63918: DOUBLE
63919: LD_INT 1
63921: DEC
63922: ST_TO_ADDR
63923: LD_INT 6
63925: PUSH
63926: LD_VAR 0 7
63930: MINUS
63931: PUSH
63932: FOR_TO
63933: IFFALSE 64025
// begin if i = sort then
63935: LD_VAR 0 3
63939: PUSH
63940: LD_VAR 0 9
63944: EQUAL
63945: IFFALSE 63949
// break ;
63947: GO 64025
// if GetClass ( i ) = 3 then
63949: LD_VAR 0 3
63953: PPUSH
63954: CALL_OW 257
63958: PUSH
63959: LD_INT 3
63961: EQUAL
63962: IFFALSE 63966
// continue ;
63964: GO 63932
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63966: LD_ADDR_VAR 0 11
63970: PUSH
63971: LD_VAR 0 11
63975: PPUSH
63976: LD_VAR 0 11
63980: PUSH
63981: LD_INT 1
63983: PLUS
63984: PPUSH
63985: LD_VAR 0 9
63989: PUSH
63990: LD_VAR 0 3
63994: ARRAY
63995: PPUSH
63996: CALL_OW 2
64000: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64001: LD_ADDR_VAR 0 4
64005: PUSH
64006: LD_VAR 0 4
64010: PUSH
64011: LD_VAR 0 9
64015: PUSH
64016: LD_VAR 0 3
64020: ARRAY
64021: DIFF
64022: ST_TO_ADDR
// end ;
64023: GO 63932
64025: POP
64026: POP
// if p then
64027: LD_VAR 0 11
64031: IFFALSE 64056
// result := Replace ( result , 3 , p ) ;
64033: LD_ADDR_VAR 0 2
64037: PUSH
64038: LD_VAR 0 2
64042: PPUSH
64043: LD_INT 3
64045: PPUSH
64046: LD_VAR 0 11
64050: PPUSH
64051: CALL_OW 1
64055: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64056: LD_ADDR_VAR 0 4
64060: PUSH
64061: LD_VAR 0 4
64065: PUSH
64066: LD_VAR 0 6
64070: DIFF
64071: ST_TO_ADDR
// if tmp and eng < 6 then
64072: LD_VAR 0 4
64076: PUSH
64077: LD_VAR 0 6
64081: PUSH
64082: LD_INT 6
64084: LESS
64085: AND
64086: IFFALSE 64280
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64088: LD_ADDR_VAR 0 9
64092: PUSH
64093: LD_VAR 0 4
64097: PUSH
64098: LD_VAR 0 8
64102: PUSH
64103: LD_VAR 0 7
64107: UNION
64108: PUSH
64109: LD_VAR 0 6
64113: UNION
64114: DIFF
64115: PPUSH
64116: LD_INT 2
64118: PPUSH
64119: CALL 55087 0 2
64123: ST_TO_ADDR
// p := [ ] ;
64124: LD_ADDR_VAR 0 11
64128: PUSH
64129: EMPTY
64130: ST_TO_ADDR
// if sort then
64131: LD_VAR 0 9
64135: IFFALSE 64251
// for i = 1 to 6 - eng do
64137: LD_ADDR_VAR 0 3
64141: PUSH
64142: DOUBLE
64143: LD_INT 1
64145: DEC
64146: ST_TO_ADDR
64147: LD_INT 6
64149: PUSH
64150: LD_VAR 0 6
64154: MINUS
64155: PUSH
64156: FOR_TO
64157: IFFALSE 64249
// begin if i = sort then
64159: LD_VAR 0 3
64163: PUSH
64164: LD_VAR 0 9
64168: EQUAL
64169: IFFALSE 64173
// break ;
64171: GO 64249
// if GetClass ( i ) = 2 then
64173: LD_VAR 0 3
64177: PPUSH
64178: CALL_OW 257
64182: PUSH
64183: LD_INT 2
64185: EQUAL
64186: IFFALSE 64190
// continue ;
64188: GO 64156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64190: LD_ADDR_VAR 0 11
64194: PUSH
64195: LD_VAR 0 11
64199: PPUSH
64200: LD_VAR 0 11
64204: PUSH
64205: LD_INT 1
64207: PLUS
64208: PPUSH
64209: LD_VAR 0 9
64213: PUSH
64214: LD_VAR 0 3
64218: ARRAY
64219: PPUSH
64220: CALL_OW 2
64224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64225: LD_ADDR_VAR 0 4
64229: PUSH
64230: LD_VAR 0 4
64234: PUSH
64235: LD_VAR 0 9
64239: PUSH
64240: LD_VAR 0 3
64244: ARRAY
64245: DIFF
64246: ST_TO_ADDR
// end ;
64247: GO 64156
64249: POP
64250: POP
// if p then
64251: LD_VAR 0 11
64255: IFFALSE 64280
// result := Replace ( result , 2 , p ) ;
64257: LD_ADDR_VAR 0 2
64261: PUSH
64262: LD_VAR 0 2
64266: PPUSH
64267: LD_INT 2
64269: PPUSH
64270: LD_VAR 0 11
64274: PPUSH
64275: CALL_OW 1
64279: ST_TO_ADDR
// end ; exit ;
64280: GO 65004
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64282: LD_EXP 85
64286: PUSH
64287: LD_EXP 84
64291: PUSH
64292: LD_VAR 0 1
64296: ARRAY
64297: ARRAY
64298: NOT
64299: PUSH
64300: LD_EXP 58
64304: PUSH
64305: LD_VAR 0 1
64309: ARRAY
64310: PPUSH
64311: LD_INT 30
64313: PUSH
64314: LD_INT 3
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PPUSH
64321: CALL_OW 72
64325: AND
64326: PUSH
64327: LD_EXP 63
64331: PUSH
64332: LD_VAR 0 1
64336: ARRAY
64337: NOT
64338: AND
64339: IFFALSE 65004
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64341: LD_ADDR_EXP 100
64345: PUSH
64346: LD_EXP 100
64350: PPUSH
64351: LD_VAR 0 1
64355: PPUSH
64356: LD_INT 6
64358: PPUSH
64359: CALL_OW 1
64363: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64364: LD_ADDR_VAR 0 2
64368: PUSH
64369: LD_INT 0
64371: PUSH
64372: LD_INT 0
64374: PUSH
64375: LD_INT 0
64377: PUSH
64378: LD_INT 0
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: LIST
64385: LIST
64386: ST_TO_ADDR
// if sci >= 1 then
64387: LD_VAR 0 8
64391: PUSH
64392: LD_INT 1
64394: GREATEREQUAL
64395: IFFALSE 64417
// tmp := tmp diff sci [ 1 ] ;
64397: LD_ADDR_VAR 0 4
64401: PUSH
64402: LD_VAR 0 4
64406: PUSH
64407: LD_VAR 0 8
64411: PUSH
64412: LD_INT 1
64414: ARRAY
64415: DIFF
64416: ST_TO_ADDR
// if tmp and not sci then
64417: LD_VAR 0 4
64421: PUSH
64422: LD_VAR 0 8
64426: NOT
64427: AND
64428: IFFALSE 64497
// begin sort := SortBySkill ( tmp , 4 ) ;
64430: LD_ADDR_VAR 0 9
64434: PUSH
64435: LD_VAR 0 4
64439: PPUSH
64440: LD_INT 4
64442: PPUSH
64443: CALL 55087 0 2
64447: ST_TO_ADDR
// if sort then
64448: LD_VAR 0 9
64452: IFFALSE 64468
// p := sort [ 1 ] ;
64454: LD_ADDR_VAR 0 11
64458: PUSH
64459: LD_VAR 0 9
64463: PUSH
64464: LD_INT 1
64466: ARRAY
64467: ST_TO_ADDR
// if p then
64468: LD_VAR 0 11
64472: IFFALSE 64497
// result := Replace ( result , 4 , p ) ;
64474: LD_ADDR_VAR 0 2
64478: PUSH
64479: LD_VAR 0 2
64483: PPUSH
64484: LD_INT 4
64486: PPUSH
64487: LD_VAR 0 11
64491: PPUSH
64492: CALL_OW 1
64496: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64497: LD_ADDR_VAR 0 4
64501: PUSH
64502: LD_VAR 0 4
64506: PUSH
64507: LD_VAR 0 7
64511: DIFF
64512: ST_TO_ADDR
// if tmp and mech < 6 then
64513: LD_VAR 0 4
64517: PUSH
64518: LD_VAR 0 7
64522: PUSH
64523: LD_INT 6
64525: LESS
64526: AND
64527: IFFALSE 64709
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64529: LD_ADDR_VAR 0 9
64533: PUSH
64534: LD_VAR 0 4
64538: PUSH
64539: LD_VAR 0 7
64543: DIFF
64544: PPUSH
64545: LD_INT 3
64547: PPUSH
64548: CALL 55087 0 2
64552: ST_TO_ADDR
// p := [ ] ;
64553: LD_ADDR_VAR 0 11
64557: PUSH
64558: EMPTY
64559: ST_TO_ADDR
// if sort then
64560: LD_VAR 0 9
64564: IFFALSE 64680
// for i = 1 to 6 - mech do
64566: LD_ADDR_VAR 0 3
64570: PUSH
64571: DOUBLE
64572: LD_INT 1
64574: DEC
64575: ST_TO_ADDR
64576: LD_INT 6
64578: PUSH
64579: LD_VAR 0 7
64583: MINUS
64584: PUSH
64585: FOR_TO
64586: IFFALSE 64678
// begin if i = sort then
64588: LD_VAR 0 3
64592: PUSH
64593: LD_VAR 0 9
64597: EQUAL
64598: IFFALSE 64602
// break ;
64600: GO 64678
// if GetClass ( i ) = 3 then
64602: LD_VAR 0 3
64606: PPUSH
64607: CALL_OW 257
64611: PUSH
64612: LD_INT 3
64614: EQUAL
64615: IFFALSE 64619
// continue ;
64617: GO 64585
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64619: LD_ADDR_VAR 0 11
64623: PUSH
64624: LD_VAR 0 11
64628: PPUSH
64629: LD_VAR 0 11
64633: PUSH
64634: LD_INT 1
64636: PLUS
64637: PPUSH
64638: LD_VAR 0 9
64642: PUSH
64643: LD_VAR 0 3
64647: ARRAY
64648: PPUSH
64649: CALL_OW 2
64653: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64654: LD_ADDR_VAR 0 4
64658: PUSH
64659: LD_VAR 0 4
64663: PUSH
64664: LD_VAR 0 9
64668: PUSH
64669: LD_VAR 0 3
64673: ARRAY
64674: DIFF
64675: ST_TO_ADDR
// end ;
64676: GO 64585
64678: POP
64679: POP
// if p then
64680: LD_VAR 0 11
64684: IFFALSE 64709
// result := Replace ( result , 3 , p ) ;
64686: LD_ADDR_VAR 0 2
64690: PUSH
64691: LD_VAR 0 2
64695: PPUSH
64696: LD_INT 3
64698: PPUSH
64699: LD_VAR 0 11
64703: PPUSH
64704: CALL_OW 1
64708: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64709: LD_ADDR_VAR 0 4
64713: PUSH
64714: LD_VAR 0 4
64718: PUSH
64719: LD_VAR 0 6
64723: DIFF
64724: ST_TO_ADDR
// if tmp and eng < 4 then
64725: LD_VAR 0 4
64729: PUSH
64730: LD_VAR 0 6
64734: PUSH
64735: LD_INT 4
64737: LESS
64738: AND
64739: IFFALSE 64929
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64741: LD_ADDR_VAR 0 9
64745: PUSH
64746: LD_VAR 0 4
64750: PUSH
64751: LD_VAR 0 7
64755: PUSH
64756: LD_VAR 0 6
64760: UNION
64761: DIFF
64762: PPUSH
64763: LD_INT 2
64765: PPUSH
64766: CALL 55087 0 2
64770: ST_TO_ADDR
// p := [ ] ;
64771: LD_ADDR_VAR 0 11
64775: PUSH
64776: EMPTY
64777: ST_TO_ADDR
// if sort then
64778: LD_VAR 0 9
64782: IFFALSE 64898
// for i = 1 to 4 - eng do
64784: LD_ADDR_VAR 0 3
64788: PUSH
64789: DOUBLE
64790: LD_INT 1
64792: DEC
64793: ST_TO_ADDR
64794: LD_INT 4
64796: PUSH
64797: LD_VAR 0 6
64801: MINUS
64802: PUSH
64803: FOR_TO
64804: IFFALSE 64896
// begin if i = sort then
64806: LD_VAR 0 3
64810: PUSH
64811: LD_VAR 0 9
64815: EQUAL
64816: IFFALSE 64820
// break ;
64818: GO 64896
// if GetClass ( i ) = 2 then
64820: LD_VAR 0 3
64824: PPUSH
64825: CALL_OW 257
64829: PUSH
64830: LD_INT 2
64832: EQUAL
64833: IFFALSE 64837
// continue ;
64835: GO 64803
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64837: LD_ADDR_VAR 0 11
64841: PUSH
64842: LD_VAR 0 11
64846: PPUSH
64847: LD_VAR 0 11
64851: PUSH
64852: LD_INT 1
64854: PLUS
64855: PPUSH
64856: LD_VAR 0 9
64860: PUSH
64861: LD_VAR 0 3
64865: ARRAY
64866: PPUSH
64867: CALL_OW 2
64871: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64872: LD_ADDR_VAR 0 4
64876: PUSH
64877: LD_VAR 0 4
64881: PUSH
64882: LD_VAR 0 9
64886: PUSH
64887: LD_VAR 0 3
64891: ARRAY
64892: DIFF
64893: ST_TO_ADDR
// end ;
64894: GO 64803
64896: POP
64897: POP
// if p then
64898: LD_VAR 0 11
64902: IFFALSE 64927
// result := Replace ( result , 2 , p ) ;
64904: LD_ADDR_VAR 0 2
64908: PUSH
64909: LD_VAR 0 2
64913: PPUSH
64914: LD_INT 2
64916: PPUSH
64917: LD_VAR 0 11
64921: PPUSH
64922: CALL_OW 1
64926: ST_TO_ADDR
// end else
64927: GO 64973
// for i = eng downto 5 do
64929: LD_ADDR_VAR 0 3
64933: PUSH
64934: DOUBLE
64935: LD_VAR 0 6
64939: INC
64940: ST_TO_ADDR
64941: LD_INT 5
64943: PUSH
64944: FOR_DOWNTO
64945: IFFALSE 64971
// tmp := tmp union eng [ i ] ;
64947: LD_ADDR_VAR 0 4
64951: PUSH
64952: LD_VAR 0 4
64956: PUSH
64957: LD_VAR 0 6
64961: PUSH
64962: LD_VAR 0 3
64966: ARRAY
64967: UNION
64968: ST_TO_ADDR
64969: GO 64944
64971: POP
64972: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64973: LD_ADDR_VAR 0 2
64977: PUSH
64978: LD_VAR 0 2
64982: PPUSH
64983: LD_INT 1
64985: PPUSH
64986: LD_VAR 0 4
64990: PUSH
64991: LD_VAR 0 5
64995: DIFF
64996: PPUSH
64997: CALL_OW 1
65001: ST_TO_ADDR
// exit ;
65002: GO 65004
// end ; end ;
65004: LD_VAR 0 2
65008: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65009: LD_INT 0
65011: PPUSH
65012: PPUSH
65013: PPUSH
// if not mc_bases then
65014: LD_EXP 58
65018: NOT
65019: IFFALSE 65023
// exit ;
65021: GO 65129
// for i = 1 to mc_bases do
65023: LD_ADDR_VAR 0 2
65027: PUSH
65028: DOUBLE
65029: LD_INT 1
65031: DEC
65032: ST_TO_ADDR
65033: LD_EXP 58
65037: PUSH
65038: FOR_TO
65039: IFFALSE 65120
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65041: LD_ADDR_VAR 0 3
65045: PUSH
65046: LD_EXP 58
65050: PUSH
65051: LD_VAR 0 2
65055: ARRAY
65056: PPUSH
65057: LD_INT 21
65059: PUSH
65060: LD_INT 3
65062: PUSH
65063: EMPTY
65064: LIST
65065: LIST
65066: PUSH
65067: LD_INT 3
65069: PUSH
65070: LD_INT 24
65072: PUSH
65073: LD_INT 1000
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: EMPTY
65081: LIST
65082: LIST
65083: PUSH
65084: EMPTY
65085: LIST
65086: LIST
65087: PPUSH
65088: CALL_OW 72
65092: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65093: LD_ADDR_EXP 59
65097: PUSH
65098: LD_EXP 59
65102: PPUSH
65103: LD_VAR 0 2
65107: PPUSH
65108: LD_VAR 0 3
65112: PPUSH
65113: CALL_OW 1
65117: ST_TO_ADDR
// end ;
65118: GO 65038
65120: POP
65121: POP
// RaiseSailEvent ( 101 ) ;
65122: LD_INT 101
65124: PPUSH
65125: CALL_OW 427
// end ;
65129: LD_VAR 0 1
65133: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65134: LD_INT 0
65136: PPUSH
65137: PPUSH
65138: PPUSH
65139: PPUSH
65140: PPUSH
65141: PPUSH
65142: PPUSH
// if not mc_bases then
65143: LD_EXP 58
65147: NOT
65148: IFFALSE 65152
// exit ;
65150: GO 65725
// for i = 1 to mc_bases do
65152: LD_ADDR_VAR 0 2
65156: PUSH
65157: DOUBLE
65158: LD_INT 1
65160: DEC
65161: ST_TO_ADDR
65162: LD_EXP 58
65166: PUSH
65167: FOR_TO
65168: IFFALSE 65716
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65170: LD_ADDR_VAR 0 5
65174: PUSH
65175: LD_EXP 58
65179: PUSH
65180: LD_VAR 0 2
65184: ARRAY
65185: PUSH
65186: LD_EXP 87
65190: PUSH
65191: LD_VAR 0 2
65195: ARRAY
65196: UNION
65197: PPUSH
65198: LD_INT 21
65200: PUSH
65201: LD_INT 1
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 1
65210: PUSH
65211: LD_INT 3
65213: PUSH
65214: LD_INT 54
65216: PUSH
65217: EMPTY
65218: LIST
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 3
65226: PUSH
65227: LD_INT 24
65229: PUSH
65230: LD_INT 800
65232: PUSH
65233: EMPTY
65234: LIST
65235: LIST
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: LIST
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PPUSH
65250: CALL_OW 72
65254: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65255: LD_ADDR_VAR 0 6
65259: PUSH
65260: LD_EXP 58
65264: PUSH
65265: LD_VAR 0 2
65269: ARRAY
65270: PPUSH
65271: LD_INT 21
65273: PUSH
65274: LD_INT 1
65276: PUSH
65277: EMPTY
65278: LIST
65279: LIST
65280: PUSH
65281: LD_INT 1
65283: PUSH
65284: LD_INT 3
65286: PUSH
65287: LD_INT 54
65289: PUSH
65290: EMPTY
65291: LIST
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PUSH
65297: LD_INT 3
65299: PUSH
65300: LD_INT 24
65302: PUSH
65303: LD_INT 250
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: EMPTY
65311: LIST
65312: LIST
65313: PUSH
65314: EMPTY
65315: LIST
65316: LIST
65317: LIST
65318: PUSH
65319: EMPTY
65320: LIST
65321: LIST
65322: PPUSH
65323: CALL_OW 72
65327: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65328: LD_ADDR_VAR 0 7
65332: PUSH
65333: LD_VAR 0 5
65337: PUSH
65338: LD_VAR 0 6
65342: DIFF
65343: ST_TO_ADDR
// if not need_heal_1 then
65344: LD_VAR 0 6
65348: NOT
65349: IFFALSE 65382
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65351: LD_ADDR_EXP 61
65355: PUSH
65356: LD_EXP 61
65360: PPUSH
65361: LD_VAR 0 2
65365: PUSH
65366: LD_INT 1
65368: PUSH
65369: EMPTY
65370: LIST
65371: LIST
65372: PPUSH
65373: EMPTY
65374: PPUSH
65375: CALL 20839 0 3
65379: ST_TO_ADDR
65380: GO 65452
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65382: LD_ADDR_EXP 61
65386: PUSH
65387: LD_EXP 61
65391: PPUSH
65392: LD_VAR 0 2
65396: PUSH
65397: LD_INT 1
65399: PUSH
65400: EMPTY
65401: LIST
65402: LIST
65403: PPUSH
65404: LD_EXP 61
65408: PUSH
65409: LD_VAR 0 2
65413: ARRAY
65414: PUSH
65415: LD_INT 1
65417: ARRAY
65418: PPUSH
65419: LD_INT 3
65421: PUSH
65422: LD_INT 24
65424: PUSH
65425: LD_INT 1000
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: EMPTY
65433: LIST
65434: LIST
65435: PPUSH
65436: CALL_OW 72
65440: PUSH
65441: LD_VAR 0 6
65445: UNION
65446: PPUSH
65447: CALL 20839 0 3
65451: ST_TO_ADDR
// if not need_heal_2 then
65452: LD_VAR 0 7
65456: NOT
65457: IFFALSE 65490
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65459: LD_ADDR_EXP 61
65463: PUSH
65464: LD_EXP 61
65468: PPUSH
65469: LD_VAR 0 2
65473: PUSH
65474: LD_INT 2
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: PPUSH
65481: EMPTY
65482: PPUSH
65483: CALL 20839 0 3
65487: ST_TO_ADDR
65488: GO 65522
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65490: LD_ADDR_EXP 61
65494: PUSH
65495: LD_EXP 61
65499: PPUSH
65500: LD_VAR 0 2
65504: PUSH
65505: LD_INT 2
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PPUSH
65512: LD_VAR 0 7
65516: PPUSH
65517: CALL 20839 0 3
65521: ST_TO_ADDR
// if need_heal_2 then
65522: LD_VAR 0 7
65526: IFFALSE 65698
// for j in need_heal_2 do
65528: LD_ADDR_VAR 0 3
65532: PUSH
65533: LD_VAR 0 7
65537: PUSH
65538: FOR_IN
65539: IFFALSE 65696
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65541: LD_ADDR_VAR 0 5
65545: PUSH
65546: LD_EXP 58
65550: PUSH
65551: LD_VAR 0 2
65555: ARRAY
65556: PPUSH
65557: LD_INT 2
65559: PUSH
65560: LD_INT 30
65562: PUSH
65563: LD_INT 6
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 30
65572: PUSH
65573: LD_INT 7
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 30
65582: PUSH
65583: LD_INT 8
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 30
65592: PUSH
65593: LD_INT 0
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: PUSH
65600: LD_INT 30
65602: PUSH
65603: LD_INT 1
65605: PUSH
65606: EMPTY
65607: LIST
65608: LIST
65609: PUSH
65610: LD_INT 25
65612: PUSH
65613: LD_INT 4
65615: PUSH
65616: EMPTY
65617: LIST
65618: LIST
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: LIST
65626: LIST
65627: LIST
65628: PPUSH
65629: CALL_OW 72
65633: ST_TO_ADDR
// if tmp then
65634: LD_VAR 0 5
65638: IFFALSE 65694
// begin k := NearestUnitToUnit ( tmp , j ) ;
65640: LD_ADDR_VAR 0 4
65644: PUSH
65645: LD_VAR 0 5
65649: PPUSH
65650: LD_VAR 0 3
65654: PPUSH
65655: CALL_OW 74
65659: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65660: LD_VAR 0 3
65664: PPUSH
65665: LD_VAR 0 4
65669: PPUSH
65670: CALL_OW 296
65674: PUSH
65675: LD_INT 7
65677: GREATER
65678: IFFALSE 65694
// ComMoveUnit ( j , k ) ;
65680: LD_VAR 0 3
65684: PPUSH
65685: LD_VAR 0 4
65689: PPUSH
65690: CALL_OW 112
// end ; end ;
65694: GO 65538
65696: POP
65697: POP
// if not need_heal_1 and not need_heal_2 then
65698: LD_VAR 0 6
65702: NOT
65703: PUSH
65704: LD_VAR 0 7
65708: NOT
65709: AND
65710: IFFALSE 65714
// continue ;
65712: GO 65167
// end ;
65714: GO 65167
65716: POP
65717: POP
// RaiseSailEvent ( 102 ) ;
65718: LD_INT 102
65720: PPUSH
65721: CALL_OW 427
// end ;
65725: LD_VAR 0 1
65729: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
65730: LD_INT 0
65732: PPUSH
65733: PPUSH
65734: PPUSH
65735: PPUSH
65736: PPUSH
65737: PPUSH
// if not mc_bases then
65738: LD_EXP 58
65742: NOT
65743: IFFALSE 65747
// exit ;
65745: GO 66457
// for i = 1 to mc_bases do
65747: LD_ADDR_VAR 0 2
65751: PUSH
65752: DOUBLE
65753: LD_INT 1
65755: DEC
65756: ST_TO_ADDR
65757: LD_EXP 58
65761: PUSH
65762: FOR_TO
65763: IFFALSE 66455
// begin if not mc_building_need_repair [ i ] then
65765: LD_EXP 59
65769: PUSH
65770: LD_VAR 0 2
65774: ARRAY
65775: NOT
65776: IFFALSE 65950
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
65778: LD_ADDR_VAR 0 6
65782: PUSH
65783: LD_EXP 77
65787: PUSH
65788: LD_VAR 0 2
65792: ARRAY
65793: PPUSH
65794: LD_INT 3
65796: PUSH
65797: LD_INT 24
65799: PUSH
65800: LD_INT 1000
65802: PUSH
65803: EMPTY
65804: LIST
65805: LIST
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 2
65813: PUSH
65814: LD_INT 34
65816: PUSH
65817: LD_INT 13
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: PUSH
65824: LD_INT 34
65826: PUSH
65827: LD_INT 52
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PUSH
65834: EMPTY
65835: LIST
65836: LIST
65837: LIST
65838: PUSH
65839: EMPTY
65840: LIST
65841: LIST
65842: PPUSH
65843: CALL_OW 72
65847: ST_TO_ADDR
// if cranes then
65848: LD_VAR 0 6
65852: IFFALSE 65914
// for j in cranes do
65854: LD_ADDR_VAR 0 3
65858: PUSH
65859: LD_VAR 0 6
65863: PUSH
65864: FOR_IN
65865: IFFALSE 65912
// if not IsInArea ( j , mc_parking [ i ] ) then
65867: LD_VAR 0 3
65871: PPUSH
65872: LD_EXP 82
65876: PUSH
65877: LD_VAR 0 2
65881: ARRAY
65882: PPUSH
65883: CALL_OW 308
65887: NOT
65888: IFFALSE 65910
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65890: LD_VAR 0 3
65894: PPUSH
65895: LD_EXP 82
65899: PUSH
65900: LD_VAR 0 2
65904: ARRAY
65905: PPUSH
65906: CALL_OW 113
65910: GO 65864
65912: POP
65913: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65914: LD_ADDR_EXP 60
65918: PUSH
65919: LD_EXP 60
65923: PPUSH
65924: LD_VAR 0 2
65928: PPUSH
65929: EMPTY
65930: PPUSH
65931: CALL_OW 1
65935: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65936: LD_VAR 0 2
65940: PPUSH
65941: LD_INT 101
65943: PPUSH
65944: CALL 60842 0 2
// continue ;
65948: GO 65762
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65950: LD_ADDR_EXP 64
65954: PUSH
65955: LD_EXP 64
65959: PPUSH
65960: LD_VAR 0 2
65964: PPUSH
65965: EMPTY
65966: PPUSH
65967: CALL_OW 1
65971: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65972: LD_VAR 0 2
65976: PPUSH
65977: LD_INT 103
65979: PPUSH
65980: CALL 60842 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65984: LD_ADDR_VAR 0 5
65988: PUSH
65989: LD_EXP 58
65993: PUSH
65994: LD_VAR 0 2
65998: ARRAY
65999: PUSH
66000: LD_EXP 87
66004: PUSH
66005: LD_VAR 0 2
66009: ARRAY
66010: UNION
66011: PPUSH
66012: LD_INT 2
66014: PUSH
66015: LD_INT 25
66017: PUSH
66018: LD_INT 2
66020: PUSH
66021: EMPTY
66022: LIST
66023: LIST
66024: PUSH
66025: LD_INT 25
66027: PUSH
66028: LD_INT 16
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: LIST
66039: PUSH
66040: EMPTY
66041: LIST
66042: PPUSH
66043: CALL_OW 72
66047: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66048: LD_ADDR_VAR 0 6
66052: PUSH
66053: LD_EXP 77
66057: PUSH
66058: LD_VAR 0 2
66062: ARRAY
66063: PPUSH
66064: LD_INT 2
66066: PUSH
66067: LD_INT 34
66069: PUSH
66070: LD_INT 13
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PUSH
66077: LD_INT 34
66079: PUSH
66080: LD_INT 52
66082: PUSH
66083: EMPTY
66084: LIST
66085: LIST
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: LIST
66091: PPUSH
66092: CALL_OW 72
66096: ST_TO_ADDR
// if cranes then
66097: LD_VAR 0 6
66101: IFFALSE 66237
// begin for j in cranes do
66103: LD_ADDR_VAR 0 3
66107: PUSH
66108: LD_VAR 0 6
66112: PUSH
66113: FOR_IN
66114: IFFALSE 66235
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66116: LD_VAR 0 3
66120: PPUSH
66121: CALL_OW 256
66125: PUSH
66126: LD_INT 500
66128: GREATEREQUAL
66129: PUSH
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 314
66139: NOT
66140: AND
66141: IFFALSE 66175
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66143: LD_VAR 0 3
66147: PPUSH
66148: LD_EXP 59
66152: PUSH
66153: LD_VAR 0 2
66157: ARRAY
66158: PPUSH
66159: LD_VAR 0 3
66163: PPUSH
66164: CALL_OW 74
66168: PPUSH
66169: CALL_OW 130
66173: GO 66233
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66175: LD_VAR 0 3
66179: PPUSH
66180: CALL_OW 256
66184: PUSH
66185: LD_INT 500
66187: LESS
66188: PUSH
66189: LD_VAR 0 3
66193: PPUSH
66194: LD_EXP 82
66198: PUSH
66199: LD_VAR 0 2
66203: ARRAY
66204: PPUSH
66205: CALL_OW 308
66209: NOT
66210: AND
66211: IFFALSE 66233
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66213: LD_VAR 0 3
66217: PPUSH
66218: LD_EXP 82
66222: PUSH
66223: LD_VAR 0 2
66227: ARRAY
66228: PPUSH
66229: CALL_OW 113
66233: GO 66113
66235: POP
66236: POP
// end ; if not tmp then
66237: LD_VAR 0 5
66241: NOT
66242: IFFALSE 66246
// continue ;
66244: GO 65762
// for j in tmp do
66246: LD_ADDR_VAR 0 3
66250: PUSH
66251: LD_VAR 0 5
66255: PUSH
66256: FOR_IN
66257: IFFALSE 66451
// begin if mc_need_heal [ i ] then
66259: LD_EXP 61
66263: PUSH
66264: LD_VAR 0 2
66268: ARRAY
66269: IFFALSE 66317
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66271: LD_VAR 0 3
66275: PUSH
66276: LD_EXP 61
66280: PUSH
66281: LD_VAR 0 2
66285: ARRAY
66286: PUSH
66287: LD_INT 1
66289: ARRAY
66290: IN
66291: PUSH
66292: LD_VAR 0 3
66296: PUSH
66297: LD_EXP 61
66301: PUSH
66302: LD_VAR 0 2
66306: ARRAY
66307: PUSH
66308: LD_INT 2
66310: ARRAY
66311: IN
66312: OR
66313: IFFALSE 66317
// continue ;
66315: GO 66256
// if IsInUnit ( j ) then
66317: LD_VAR 0 3
66321: PPUSH
66322: CALL_OW 310
66326: IFFALSE 66337
// ComExitBuilding ( j ) ;
66328: LD_VAR 0 3
66332: PPUSH
66333: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66337: LD_VAR 0 3
66341: PUSH
66342: LD_EXP 60
66346: PUSH
66347: LD_VAR 0 2
66351: ARRAY
66352: IN
66353: NOT
66354: IFFALSE 66412
// begin SetTag ( j , 101 ) ;
66356: LD_VAR 0 3
66360: PPUSH
66361: LD_INT 101
66363: PPUSH
66364: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66368: LD_ADDR_EXP 60
66372: PUSH
66373: LD_EXP 60
66377: PPUSH
66378: LD_VAR 0 2
66382: PUSH
66383: LD_EXP 60
66387: PUSH
66388: LD_VAR 0 2
66392: ARRAY
66393: PUSH
66394: LD_INT 1
66396: PLUS
66397: PUSH
66398: EMPTY
66399: LIST
66400: LIST
66401: PPUSH
66402: LD_VAR 0 3
66406: PPUSH
66407: CALL 20839 0 3
66411: ST_TO_ADDR
// end ; wait ( 1 ) ;
66412: LD_INT 1
66414: PPUSH
66415: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66419: LD_VAR 0 3
66423: PPUSH
66424: LD_EXP 59
66428: PUSH
66429: LD_VAR 0 2
66433: ARRAY
66434: PPUSH
66435: LD_VAR 0 3
66439: PPUSH
66440: CALL_OW 74
66444: PPUSH
66445: CALL_OW 130
// end ;
66449: GO 66256
66451: POP
66452: POP
// end ;
66453: GO 65762
66455: POP
66456: POP
// end ;
66457: LD_VAR 0 1
66461: RET
// export function MC_Heal ; var i , j , tmp ; begin
66462: LD_INT 0
66464: PPUSH
66465: PPUSH
66466: PPUSH
66467: PPUSH
// if not mc_bases then
66468: LD_EXP 58
66472: NOT
66473: IFFALSE 66477
// exit ;
66475: GO 66879
// for i = 1 to mc_bases do
66477: LD_ADDR_VAR 0 2
66481: PUSH
66482: DOUBLE
66483: LD_INT 1
66485: DEC
66486: ST_TO_ADDR
66487: LD_EXP 58
66491: PUSH
66492: FOR_TO
66493: IFFALSE 66877
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66495: LD_EXP 61
66499: PUSH
66500: LD_VAR 0 2
66504: ARRAY
66505: PUSH
66506: LD_INT 1
66508: ARRAY
66509: NOT
66510: PUSH
66511: LD_EXP 61
66515: PUSH
66516: LD_VAR 0 2
66520: ARRAY
66521: PUSH
66522: LD_INT 2
66524: ARRAY
66525: NOT
66526: AND
66527: IFFALSE 66565
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66529: LD_ADDR_EXP 62
66533: PUSH
66534: LD_EXP 62
66538: PPUSH
66539: LD_VAR 0 2
66543: PPUSH
66544: EMPTY
66545: PPUSH
66546: CALL_OW 1
66550: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66551: LD_VAR 0 2
66555: PPUSH
66556: LD_INT 102
66558: PPUSH
66559: CALL 60842 0 2
// continue ;
66563: GO 66492
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66565: LD_ADDR_VAR 0 4
66569: PUSH
66570: LD_EXP 58
66574: PUSH
66575: LD_VAR 0 2
66579: ARRAY
66580: PPUSH
66581: LD_INT 25
66583: PUSH
66584: LD_INT 4
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PPUSH
66591: CALL_OW 72
66595: ST_TO_ADDR
// if not tmp then
66596: LD_VAR 0 4
66600: NOT
66601: IFFALSE 66605
// continue ;
66603: GO 66492
// if mc_taming [ i ] then
66605: LD_EXP 89
66609: PUSH
66610: LD_VAR 0 2
66614: ARRAY
66615: IFFALSE 66639
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66617: LD_ADDR_EXP 89
66621: PUSH
66622: LD_EXP 89
66626: PPUSH
66627: LD_VAR 0 2
66631: PPUSH
66632: EMPTY
66633: PPUSH
66634: CALL_OW 1
66638: ST_TO_ADDR
// for j in tmp do
66639: LD_ADDR_VAR 0 3
66643: PUSH
66644: LD_VAR 0 4
66648: PUSH
66649: FOR_IN
66650: IFFALSE 66873
// begin if IsInUnit ( j ) then
66652: LD_VAR 0 3
66656: PPUSH
66657: CALL_OW 310
66661: IFFALSE 66672
// ComExitBuilding ( j ) ;
66663: LD_VAR 0 3
66667: PPUSH
66668: CALL_OW 122
// if not j in mc_healers [ i ] then
66672: LD_VAR 0 3
66676: PUSH
66677: LD_EXP 62
66681: PUSH
66682: LD_VAR 0 2
66686: ARRAY
66687: IN
66688: NOT
66689: IFFALSE 66735
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66691: LD_ADDR_EXP 62
66695: PUSH
66696: LD_EXP 62
66700: PPUSH
66701: LD_VAR 0 2
66705: PUSH
66706: LD_EXP 62
66710: PUSH
66711: LD_VAR 0 2
66715: ARRAY
66716: PUSH
66717: LD_INT 1
66719: PLUS
66720: PUSH
66721: EMPTY
66722: LIST
66723: LIST
66724: PPUSH
66725: LD_VAR 0 3
66729: PPUSH
66730: CALL 20839 0 3
66734: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66735: LD_VAR 0 3
66739: PPUSH
66740: CALL_OW 110
66744: PUSH
66745: LD_INT 102
66747: NONEQUAL
66748: IFFALSE 66762
// SetTag ( j , 102 ) ;
66750: LD_VAR 0 3
66754: PPUSH
66755: LD_INT 102
66757: PPUSH
66758: CALL_OW 109
// Wait ( 3 ) ;
66762: LD_INT 3
66764: PPUSH
66765: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66769: LD_EXP 61
66773: PUSH
66774: LD_VAR 0 2
66778: ARRAY
66779: PUSH
66780: LD_INT 1
66782: ARRAY
66783: IFFALSE 66815
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66785: LD_VAR 0 3
66789: PPUSH
66790: LD_EXP 61
66794: PUSH
66795: LD_VAR 0 2
66799: ARRAY
66800: PUSH
66801: LD_INT 1
66803: ARRAY
66804: PUSH
66805: LD_INT 1
66807: ARRAY
66808: PPUSH
66809: CALL_OW 128
66813: GO 66871
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66815: LD_VAR 0 3
66819: PPUSH
66820: CALL_OW 314
66824: NOT
66825: PUSH
66826: LD_EXP 61
66830: PUSH
66831: LD_VAR 0 2
66835: ARRAY
66836: PUSH
66837: LD_INT 2
66839: ARRAY
66840: AND
66841: IFFALSE 66871
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66843: LD_VAR 0 3
66847: PPUSH
66848: LD_EXP 61
66852: PUSH
66853: LD_VAR 0 2
66857: ARRAY
66858: PUSH
66859: LD_INT 2
66861: ARRAY
66862: PUSH
66863: LD_INT 1
66865: ARRAY
66866: PPUSH
66867: CALL_OW 128
// end ;
66871: GO 66649
66873: POP
66874: POP
// end ;
66875: GO 66492
66877: POP
66878: POP
// end ;
66879: LD_VAR 0 1
66883: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66884: LD_INT 0
66886: PPUSH
66887: PPUSH
66888: PPUSH
66889: PPUSH
66890: PPUSH
// if not mc_bases then
66891: LD_EXP 58
66895: NOT
66896: IFFALSE 66900
// exit ;
66898: GO 68043
// for i = 1 to mc_bases do
66900: LD_ADDR_VAR 0 2
66904: PUSH
66905: DOUBLE
66906: LD_INT 1
66908: DEC
66909: ST_TO_ADDR
66910: LD_EXP 58
66914: PUSH
66915: FOR_TO
66916: IFFALSE 68041
// begin if mc_scan [ i ] then
66918: LD_EXP 81
66922: PUSH
66923: LD_VAR 0 2
66927: ARRAY
66928: IFFALSE 66932
// continue ;
66930: GO 66915
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66932: LD_EXP 63
66936: PUSH
66937: LD_VAR 0 2
66941: ARRAY
66942: NOT
66943: PUSH
66944: LD_EXP 65
66948: PUSH
66949: LD_VAR 0 2
66953: ARRAY
66954: NOT
66955: AND
66956: PUSH
66957: LD_EXP 64
66961: PUSH
66962: LD_VAR 0 2
66966: ARRAY
66967: AND
66968: IFFALSE 67006
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66970: LD_ADDR_EXP 64
66974: PUSH
66975: LD_EXP 64
66979: PPUSH
66980: LD_VAR 0 2
66984: PPUSH
66985: EMPTY
66986: PPUSH
66987: CALL_OW 1
66991: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66992: LD_VAR 0 2
66996: PPUSH
66997: LD_INT 103
66999: PPUSH
67000: CALL 60842 0 2
// continue ;
67004: GO 66915
// end ; if mc_construct_list [ i ] then
67006: LD_EXP 65
67010: PUSH
67011: LD_VAR 0 2
67015: ARRAY
67016: IFFALSE 67236
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67018: LD_ADDR_VAR 0 4
67022: PUSH
67023: LD_EXP 58
67027: PUSH
67028: LD_VAR 0 2
67032: ARRAY
67033: PPUSH
67034: LD_INT 25
67036: PUSH
67037: LD_INT 2
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PPUSH
67044: CALL_OW 72
67048: PUSH
67049: LD_EXP 60
67053: PUSH
67054: LD_VAR 0 2
67058: ARRAY
67059: DIFF
67060: ST_TO_ADDR
// if not tmp then
67061: LD_VAR 0 4
67065: NOT
67066: IFFALSE 67070
// continue ;
67068: GO 66915
// for j in tmp do
67070: LD_ADDR_VAR 0 3
67074: PUSH
67075: LD_VAR 0 4
67079: PUSH
67080: FOR_IN
67081: IFFALSE 67232
// begin if not mc_builders [ i ] then
67083: LD_EXP 64
67087: PUSH
67088: LD_VAR 0 2
67092: ARRAY
67093: NOT
67094: IFFALSE 67152
// begin SetTag ( j , 103 ) ;
67096: LD_VAR 0 3
67100: PPUSH
67101: LD_INT 103
67103: PPUSH
67104: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67108: LD_ADDR_EXP 64
67112: PUSH
67113: LD_EXP 64
67117: PPUSH
67118: LD_VAR 0 2
67122: PUSH
67123: LD_EXP 64
67127: PUSH
67128: LD_VAR 0 2
67132: ARRAY
67133: PUSH
67134: LD_INT 1
67136: PLUS
67137: PUSH
67138: EMPTY
67139: LIST
67140: LIST
67141: PPUSH
67142: LD_VAR 0 3
67146: PPUSH
67147: CALL 20839 0 3
67151: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67152: LD_VAR 0 3
67156: PPUSH
67157: CALL_OW 310
67161: IFFALSE 67172
// ComExitBuilding ( j ) ;
67163: LD_VAR 0 3
67167: PPUSH
67168: CALL_OW 122
// wait ( 3 ) ;
67172: LD_INT 3
67174: PPUSH
67175: CALL_OW 67
// if not mc_construct_list [ i ] then
67179: LD_EXP 65
67183: PUSH
67184: LD_VAR 0 2
67188: ARRAY
67189: NOT
67190: IFFALSE 67194
// break ;
67192: GO 67232
// if not HasTask ( j ) then
67194: LD_VAR 0 3
67198: PPUSH
67199: CALL_OW 314
67203: NOT
67204: IFFALSE 67230
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67206: LD_VAR 0 3
67210: PPUSH
67211: LD_EXP 65
67215: PUSH
67216: LD_VAR 0 2
67220: ARRAY
67221: PUSH
67222: LD_INT 1
67224: ARRAY
67225: PPUSH
67226: CALL 23690 0 2
// end ;
67230: GO 67080
67232: POP
67233: POP
// end else
67234: GO 68039
// if mc_build_list [ i ] then
67236: LD_EXP 63
67240: PUSH
67241: LD_VAR 0 2
67245: ARRAY
67246: IFFALSE 68039
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67248: LD_ADDR_VAR 0 5
67252: PUSH
67253: LD_EXP 58
67257: PUSH
67258: LD_VAR 0 2
67262: ARRAY
67263: PPUSH
67264: LD_INT 2
67266: PUSH
67267: LD_INT 30
67269: PUSH
67270: LD_INT 0
67272: PUSH
67273: EMPTY
67274: LIST
67275: LIST
67276: PUSH
67277: LD_INT 30
67279: PUSH
67280: LD_INT 1
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: LIST
67291: PPUSH
67292: CALL_OW 72
67296: ST_TO_ADDR
// if depot then
67297: LD_VAR 0 5
67301: IFFALSE 67319
// depot := depot [ 1 ] else
67303: LD_ADDR_VAR 0 5
67307: PUSH
67308: LD_VAR 0 5
67312: PUSH
67313: LD_INT 1
67315: ARRAY
67316: ST_TO_ADDR
67317: GO 67327
// depot := 0 ;
67319: LD_ADDR_VAR 0 5
67323: PUSH
67324: LD_INT 0
67326: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67327: LD_EXP 63
67331: PUSH
67332: LD_VAR 0 2
67336: ARRAY
67337: PUSH
67338: LD_INT 1
67340: ARRAY
67341: PUSH
67342: LD_INT 1
67344: ARRAY
67345: PPUSH
67346: CALL 23520 0 1
67350: PUSH
67351: LD_EXP 58
67355: PUSH
67356: LD_VAR 0 2
67360: ARRAY
67361: PPUSH
67362: LD_INT 2
67364: PUSH
67365: LD_INT 30
67367: PUSH
67368: LD_INT 2
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 30
67377: PUSH
67378: LD_INT 3
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: EMPTY
67386: LIST
67387: LIST
67388: LIST
67389: PPUSH
67390: CALL_OW 72
67394: NOT
67395: AND
67396: IFFALSE 67501
// begin for j = 1 to mc_build_list [ i ] do
67398: LD_ADDR_VAR 0 3
67402: PUSH
67403: DOUBLE
67404: LD_INT 1
67406: DEC
67407: ST_TO_ADDR
67408: LD_EXP 63
67412: PUSH
67413: LD_VAR 0 2
67417: ARRAY
67418: PUSH
67419: FOR_TO
67420: IFFALSE 67499
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67422: LD_EXP 63
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: PUSH
67433: LD_VAR 0 3
67437: ARRAY
67438: PUSH
67439: LD_INT 1
67441: ARRAY
67442: PUSH
67443: LD_INT 2
67445: EQUAL
67446: IFFALSE 67497
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67448: LD_ADDR_EXP 63
67452: PUSH
67453: LD_EXP 63
67457: PPUSH
67458: LD_VAR 0 2
67462: PPUSH
67463: LD_EXP 63
67467: PUSH
67468: LD_VAR 0 2
67472: ARRAY
67473: PPUSH
67474: LD_VAR 0 3
67478: PPUSH
67479: LD_INT 1
67481: PPUSH
67482: LD_INT 0
67484: PPUSH
67485: CALL 20257 0 4
67489: PPUSH
67490: CALL_OW 1
67494: ST_TO_ADDR
// break ;
67495: GO 67499
// end ;
67497: GO 67419
67499: POP
67500: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67501: LD_EXP 63
67505: PUSH
67506: LD_VAR 0 2
67510: ARRAY
67511: PUSH
67512: LD_INT 1
67514: ARRAY
67515: PUSH
67516: LD_INT 1
67518: ARRAY
67519: PUSH
67520: LD_INT 0
67522: EQUAL
67523: PUSH
67524: LD_VAR 0 5
67528: PUSH
67529: LD_VAR 0 5
67533: PPUSH
67534: LD_EXP 63
67538: PUSH
67539: LD_VAR 0 2
67543: ARRAY
67544: PUSH
67545: LD_INT 1
67547: ARRAY
67548: PUSH
67549: LD_INT 1
67551: ARRAY
67552: PPUSH
67553: LD_EXP 63
67557: PUSH
67558: LD_VAR 0 2
67562: ARRAY
67563: PUSH
67564: LD_INT 1
67566: ARRAY
67567: PUSH
67568: LD_INT 2
67570: ARRAY
67571: PPUSH
67572: LD_EXP 63
67576: PUSH
67577: LD_VAR 0 2
67581: ARRAY
67582: PUSH
67583: LD_INT 1
67585: ARRAY
67586: PUSH
67587: LD_INT 3
67589: ARRAY
67590: PPUSH
67591: LD_EXP 63
67595: PUSH
67596: LD_VAR 0 2
67600: ARRAY
67601: PUSH
67602: LD_INT 1
67604: ARRAY
67605: PUSH
67606: LD_INT 4
67608: ARRAY
67609: PPUSH
67610: CALL 28254 0 5
67614: AND
67615: OR
67616: IFFALSE 67897
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67618: LD_ADDR_VAR 0 4
67622: PUSH
67623: LD_EXP 58
67627: PUSH
67628: LD_VAR 0 2
67632: ARRAY
67633: PPUSH
67634: LD_INT 25
67636: PUSH
67637: LD_INT 2
67639: PUSH
67640: EMPTY
67641: LIST
67642: LIST
67643: PPUSH
67644: CALL_OW 72
67648: PUSH
67649: LD_EXP 60
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: DIFF
67660: ST_TO_ADDR
// if not tmp then
67661: LD_VAR 0 4
67665: NOT
67666: IFFALSE 67670
// continue ;
67668: GO 66915
// for j in tmp do
67670: LD_ADDR_VAR 0 3
67674: PUSH
67675: LD_VAR 0 4
67679: PUSH
67680: FOR_IN
67681: IFFALSE 67893
// begin if not mc_builders [ i ] then
67683: LD_EXP 64
67687: PUSH
67688: LD_VAR 0 2
67692: ARRAY
67693: NOT
67694: IFFALSE 67752
// begin SetTag ( j , 103 ) ;
67696: LD_VAR 0 3
67700: PPUSH
67701: LD_INT 103
67703: PPUSH
67704: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67708: LD_ADDR_EXP 64
67712: PUSH
67713: LD_EXP 64
67717: PPUSH
67718: LD_VAR 0 2
67722: PUSH
67723: LD_EXP 64
67727: PUSH
67728: LD_VAR 0 2
67732: ARRAY
67733: PUSH
67734: LD_INT 1
67736: PLUS
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PPUSH
67742: LD_VAR 0 3
67746: PPUSH
67747: CALL 20839 0 3
67751: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67752: LD_VAR 0 3
67756: PPUSH
67757: CALL_OW 310
67761: IFFALSE 67772
// ComExitBuilding ( j ) ;
67763: LD_VAR 0 3
67767: PPUSH
67768: CALL_OW 122
// wait ( 3 ) ;
67772: LD_INT 3
67774: PPUSH
67775: CALL_OW 67
// if not mc_build_list [ i ] then
67779: LD_EXP 63
67783: PUSH
67784: LD_VAR 0 2
67788: ARRAY
67789: NOT
67790: IFFALSE 67794
// break ;
67792: GO 67893
// if not HasTask ( j ) then
67794: LD_VAR 0 3
67798: PPUSH
67799: CALL_OW 314
67803: NOT
67804: IFFALSE 67891
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67806: LD_VAR 0 3
67810: PPUSH
67811: LD_EXP 63
67815: PUSH
67816: LD_VAR 0 2
67820: ARRAY
67821: PUSH
67822: LD_INT 1
67824: ARRAY
67825: PUSH
67826: LD_INT 1
67828: ARRAY
67829: PPUSH
67830: LD_EXP 63
67834: PUSH
67835: LD_VAR 0 2
67839: ARRAY
67840: PUSH
67841: LD_INT 1
67843: ARRAY
67844: PUSH
67845: LD_INT 2
67847: ARRAY
67848: PPUSH
67849: LD_EXP 63
67853: PUSH
67854: LD_VAR 0 2
67858: ARRAY
67859: PUSH
67860: LD_INT 1
67862: ARRAY
67863: PUSH
67864: LD_INT 3
67866: ARRAY
67867: PPUSH
67868: LD_EXP 63
67872: PUSH
67873: LD_VAR 0 2
67877: ARRAY
67878: PUSH
67879: LD_INT 1
67881: ARRAY
67882: PUSH
67883: LD_INT 4
67885: ARRAY
67886: PPUSH
67887: CALL_OW 145
// end ;
67891: GO 67680
67893: POP
67894: POP
// end else
67895: GO 68039
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
67897: LD_EXP 58
67901: PUSH
67902: LD_VAR 0 2
67906: ARRAY
67907: PPUSH
67908: LD_EXP 63
67912: PUSH
67913: LD_VAR 0 2
67917: ARRAY
67918: PUSH
67919: LD_INT 1
67921: ARRAY
67922: PUSH
67923: LD_INT 1
67925: ARRAY
67926: PPUSH
67927: LD_EXP 63
67931: PUSH
67932: LD_VAR 0 2
67936: ARRAY
67937: PUSH
67938: LD_INT 1
67940: ARRAY
67941: PUSH
67942: LD_INT 2
67944: ARRAY
67945: PPUSH
67946: LD_EXP 63
67950: PUSH
67951: LD_VAR 0 2
67955: ARRAY
67956: PUSH
67957: LD_INT 1
67959: ARRAY
67960: PUSH
67961: LD_INT 3
67963: ARRAY
67964: PPUSH
67965: LD_EXP 63
67969: PUSH
67970: LD_VAR 0 2
67974: ARRAY
67975: PUSH
67976: LD_INT 1
67978: ARRAY
67979: PUSH
67980: LD_INT 4
67982: ARRAY
67983: PPUSH
67984: CALL 27590 0 5
67988: NOT
67989: IFFALSE 68039
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67991: LD_ADDR_EXP 63
67995: PUSH
67996: LD_EXP 63
68000: PPUSH
68001: LD_VAR 0 2
68005: PPUSH
68006: LD_EXP 63
68010: PUSH
68011: LD_VAR 0 2
68015: ARRAY
68016: PPUSH
68017: LD_INT 1
68019: PPUSH
68020: LD_INT 1
68022: NEG
68023: PPUSH
68024: LD_INT 0
68026: PPUSH
68027: CALL 20257 0 4
68031: PPUSH
68032: CALL_OW 1
68036: ST_TO_ADDR
// continue ;
68037: GO 66915
// end ; end ; end ;
68039: GO 66915
68041: POP
68042: POP
// end ;
68043: LD_VAR 0 1
68047: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68048: LD_INT 0
68050: PPUSH
68051: PPUSH
68052: PPUSH
68053: PPUSH
68054: PPUSH
68055: PPUSH
// if not mc_bases then
68056: LD_EXP 58
68060: NOT
68061: IFFALSE 68065
// exit ;
68063: GO 68492
// for i = 1 to mc_bases do
68065: LD_ADDR_VAR 0 2
68069: PUSH
68070: DOUBLE
68071: LD_INT 1
68073: DEC
68074: ST_TO_ADDR
68075: LD_EXP 58
68079: PUSH
68080: FOR_TO
68081: IFFALSE 68490
// begin tmp := mc_build_upgrade [ i ] ;
68083: LD_ADDR_VAR 0 4
68087: PUSH
68088: LD_EXP 90
68092: PUSH
68093: LD_VAR 0 2
68097: ARRAY
68098: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68099: LD_ADDR_VAR 0 6
68103: PUSH
68104: LD_EXP 91
68108: PUSH
68109: LD_VAR 0 2
68113: ARRAY
68114: PPUSH
68115: LD_INT 2
68117: PUSH
68118: LD_INT 30
68120: PUSH
68121: LD_INT 6
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 30
68130: PUSH
68131: LD_INT 7
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: EMPTY
68139: LIST
68140: LIST
68141: LIST
68142: PPUSH
68143: CALL_OW 72
68147: ST_TO_ADDR
// if not tmp and not lab then
68148: LD_VAR 0 4
68152: NOT
68153: PUSH
68154: LD_VAR 0 6
68158: NOT
68159: AND
68160: IFFALSE 68164
// continue ;
68162: GO 68080
// if tmp then
68164: LD_VAR 0 4
68168: IFFALSE 68288
// for j in tmp do
68170: LD_ADDR_VAR 0 3
68174: PUSH
68175: LD_VAR 0 4
68179: PUSH
68180: FOR_IN
68181: IFFALSE 68286
// begin if UpgradeCost ( j ) then
68183: LD_VAR 0 3
68187: PPUSH
68188: CALL 27250 0 1
68192: IFFALSE 68284
// begin ComUpgrade ( j ) ;
68194: LD_VAR 0 3
68198: PPUSH
68199: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68203: LD_ADDR_EXP 90
68207: PUSH
68208: LD_EXP 90
68212: PPUSH
68213: LD_VAR 0 2
68217: PPUSH
68218: LD_EXP 90
68222: PUSH
68223: LD_VAR 0 2
68227: ARRAY
68228: PUSH
68229: LD_VAR 0 3
68233: DIFF
68234: PPUSH
68235: CALL_OW 1
68239: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68240: LD_ADDR_EXP 65
68244: PUSH
68245: LD_EXP 65
68249: PPUSH
68250: LD_VAR 0 2
68254: PUSH
68255: LD_EXP 65
68259: PUSH
68260: LD_VAR 0 2
68264: ARRAY
68265: PUSH
68266: LD_INT 1
68268: PLUS
68269: PUSH
68270: EMPTY
68271: LIST
68272: LIST
68273: PPUSH
68274: LD_VAR 0 3
68278: PPUSH
68279: CALL 20839 0 3
68283: ST_TO_ADDR
// end ; end ;
68284: GO 68180
68286: POP
68287: POP
// if not lab or not mc_lab_upgrade [ i ] then
68288: LD_VAR 0 6
68292: NOT
68293: PUSH
68294: LD_EXP 92
68298: PUSH
68299: LD_VAR 0 2
68303: ARRAY
68304: NOT
68305: OR
68306: IFFALSE 68310
// continue ;
68308: GO 68080
// for j in lab do
68310: LD_ADDR_VAR 0 3
68314: PUSH
68315: LD_VAR 0 6
68319: PUSH
68320: FOR_IN
68321: IFFALSE 68486
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68323: LD_VAR 0 3
68327: PPUSH
68328: CALL_OW 266
68332: PUSH
68333: LD_INT 6
68335: PUSH
68336: LD_INT 7
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: IN
68343: PUSH
68344: LD_VAR 0 3
68348: PPUSH
68349: CALL_OW 461
68353: PUSH
68354: LD_INT 1
68356: NONEQUAL
68357: AND
68358: IFFALSE 68484
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68360: LD_VAR 0 3
68364: PPUSH
68365: LD_EXP 92
68369: PUSH
68370: LD_VAR 0 2
68374: ARRAY
68375: PUSH
68376: LD_INT 1
68378: ARRAY
68379: PPUSH
68380: CALL 27455 0 2
68384: IFFALSE 68484
// begin ComCancel ( j ) ;
68386: LD_VAR 0 3
68390: PPUSH
68391: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68395: LD_VAR 0 3
68399: PPUSH
68400: LD_EXP 92
68404: PUSH
68405: LD_VAR 0 2
68409: ARRAY
68410: PUSH
68411: LD_INT 1
68413: ARRAY
68414: PPUSH
68415: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68419: LD_VAR 0 3
68423: PUSH
68424: LD_EXP 65
68428: PUSH
68429: LD_VAR 0 2
68433: ARRAY
68434: IN
68435: NOT
68436: IFFALSE 68482
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68438: LD_ADDR_EXP 65
68442: PUSH
68443: LD_EXP 65
68447: PPUSH
68448: LD_VAR 0 2
68452: PUSH
68453: LD_EXP 65
68457: PUSH
68458: LD_VAR 0 2
68462: ARRAY
68463: PUSH
68464: LD_INT 1
68466: PLUS
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PPUSH
68472: LD_VAR 0 3
68476: PPUSH
68477: CALL 20839 0 3
68481: ST_TO_ADDR
// break ;
68482: GO 68486
// end ; end ; end ;
68484: GO 68320
68486: POP
68487: POP
// end ;
68488: GO 68080
68490: POP
68491: POP
// end ;
68492: LD_VAR 0 1
68496: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68497: LD_INT 0
68499: PPUSH
68500: PPUSH
68501: PPUSH
68502: PPUSH
68503: PPUSH
68504: PPUSH
68505: PPUSH
68506: PPUSH
68507: PPUSH
// if not mc_bases then
68508: LD_EXP 58
68512: NOT
68513: IFFALSE 68517
// exit ;
68515: GO 68922
// for i = 1 to mc_bases do
68517: LD_ADDR_VAR 0 2
68521: PUSH
68522: DOUBLE
68523: LD_INT 1
68525: DEC
68526: ST_TO_ADDR
68527: LD_EXP 58
68531: PUSH
68532: FOR_TO
68533: IFFALSE 68920
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68535: LD_EXP 66
68539: PUSH
68540: LD_VAR 0 2
68544: ARRAY
68545: NOT
68546: PUSH
68547: LD_EXP 58
68551: PUSH
68552: LD_VAR 0 2
68556: ARRAY
68557: PPUSH
68558: LD_INT 30
68560: PUSH
68561: LD_INT 3
68563: PUSH
68564: EMPTY
68565: LIST
68566: LIST
68567: PPUSH
68568: CALL_OW 72
68572: NOT
68573: OR
68574: IFFALSE 68578
// continue ;
68576: GO 68532
// busy := false ;
68578: LD_ADDR_VAR 0 8
68582: PUSH
68583: LD_INT 0
68585: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68586: LD_ADDR_VAR 0 4
68590: PUSH
68591: LD_EXP 58
68595: PUSH
68596: LD_VAR 0 2
68600: ARRAY
68601: PPUSH
68602: LD_INT 30
68604: PUSH
68605: LD_INT 3
68607: PUSH
68608: EMPTY
68609: LIST
68610: LIST
68611: PPUSH
68612: CALL_OW 72
68616: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68617: LD_ADDR_VAR 0 6
68621: PUSH
68622: LD_EXP 66
68626: PUSH
68627: LD_VAR 0 2
68631: ARRAY
68632: PPUSH
68633: LD_INT 2
68635: PUSH
68636: LD_INT 30
68638: PUSH
68639: LD_INT 32
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 30
68648: PUSH
68649: LD_INT 33
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: LIST
68660: PPUSH
68661: CALL_OW 72
68665: ST_TO_ADDR
// if not t then
68666: LD_VAR 0 6
68670: NOT
68671: IFFALSE 68675
// continue ;
68673: GO 68532
// for j in tmp do
68675: LD_ADDR_VAR 0 3
68679: PUSH
68680: LD_VAR 0 4
68684: PUSH
68685: FOR_IN
68686: IFFALSE 68716
// if not BuildingStatus ( j ) = bs_idle then
68688: LD_VAR 0 3
68692: PPUSH
68693: CALL_OW 461
68697: PUSH
68698: LD_INT 2
68700: EQUAL
68701: NOT
68702: IFFALSE 68714
// begin busy := true ;
68704: LD_ADDR_VAR 0 8
68708: PUSH
68709: LD_INT 1
68711: ST_TO_ADDR
// break ;
68712: GO 68716
// end ;
68714: GO 68685
68716: POP
68717: POP
// if busy then
68718: LD_VAR 0 8
68722: IFFALSE 68726
// continue ;
68724: GO 68532
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68726: LD_ADDR_VAR 0 7
68730: PUSH
68731: LD_VAR 0 6
68735: PPUSH
68736: LD_INT 35
68738: PUSH
68739: LD_INT 0
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PPUSH
68746: CALL_OW 72
68750: ST_TO_ADDR
// if tw then
68751: LD_VAR 0 7
68755: IFFALSE 68832
// begin tw := tw [ 1 ] ;
68757: LD_ADDR_VAR 0 7
68761: PUSH
68762: LD_VAR 0 7
68766: PUSH
68767: LD_INT 1
68769: ARRAY
68770: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68771: LD_ADDR_VAR 0 9
68775: PUSH
68776: LD_VAR 0 7
68780: PPUSH
68781: LD_EXP 83
68785: PUSH
68786: LD_VAR 0 2
68790: ARRAY
68791: PPUSH
68792: CALL 25809 0 2
68796: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68797: LD_EXP 97
68801: PUSH
68802: LD_VAR 0 2
68806: ARRAY
68807: IFFALSE 68830
// if not weapon in mc_allowed_tower_weapons [ i ] then
68809: LD_VAR 0 9
68813: PUSH
68814: LD_EXP 97
68818: PUSH
68819: LD_VAR 0 2
68823: ARRAY
68824: IN
68825: NOT
68826: IFFALSE 68830
// continue ;
68828: GO 68532
// end else
68830: GO 68895
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68832: LD_ADDR_VAR 0 5
68836: PUSH
68837: LD_EXP 66
68841: PUSH
68842: LD_VAR 0 2
68846: ARRAY
68847: PPUSH
68848: LD_VAR 0 4
68852: PPUSH
68853: CALL 56010 0 2
68857: ST_TO_ADDR
// if not tmp2 then
68858: LD_VAR 0 5
68862: NOT
68863: IFFALSE 68867
// continue ;
68865: GO 68532
// tw := tmp2 [ 1 ] ;
68867: LD_ADDR_VAR 0 7
68871: PUSH
68872: LD_VAR 0 5
68876: PUSH
68877: LD_INT 1
68879: ARRAY
68880: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68881: LD_ADDR_VAR 0 9
68885: PUSH
68886: LD_VAR 0 5
68890: PUSH
68891: LD_INT 2
68893: ARRAY
68894: ST_TO_ADDR
// end ; if not weapon then
68895: LD_VAR 0 9
68899: NOT
68900: IFFALSE 68904
// continue ;
68902: GO 68532
// ComPlaceWeapon ( tw , weapon ) ;
68904: LD_VAR 0 7
68908: PPUSH
68909: LD_VAR 0 9
68913: PPUSH
68914: CALL_OW 148
// end ;
68918: GO 68532
68920: POP
68921: POP
// end ;
68922: LD_VAR 0 1
68926: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
68927: LD_INT 0
68929: PPUSH
68930: PPUSH
68931: PPUSH
68932: PPUSH
68933: PPUSH
68934: PPUSH
// if not mc_bases then
68935: LD_EXP 58
68939: NOT
68940: IFFALSE 68944
// exit ;
68942: GO 69956
// for i = 1 to mc_bases do
68944: LD_ADDR_VAR 0 2
68948: PUSH
68949: DOUBLE
68950: LD_INT 1
68952: DEC
68953: ST_TO_ADDR
68954: LD_EXP 58
68958: PUSH
68959: FOR_TO
68960: IFFALSE 69954
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
68962: LD_EXP 71
68966: PUSH
68967: LD_VAR 0 2
68971: ARRAY
68972: NOT
68973: PUSH
68974: LD_EXP 71
68978: PUSH
68979: LD_VAR 0 2
68983: ARRAY
68984: PUSH
68985: LD_EXP 72
68989: PUSH
68990: LD_VAR 0 2
68994: ARRAY
68995: EQUAL
68996: OR
68997: IFFALSE 69001
// continue ;
68999: GO 68959
// if mc_miners [ i ] then
69001: LD_EXP 72
69005: PUSH
69006: LD_VAR 0 2
69010: ARRAY
69011: IFFALSE 69641
// begin k := 1 ;
69013: LD_ADDR_VAR 0 4
69017: PUSH
69018: LD_INT 1
69020: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69021: LD_ADDR_VAR 0 3
69025: PUSH
69026: DOUBLE
69027: LD_EXP 72
69031: PUSH
69032: LD_VAR 0 2
69036: ARRAY
69037: INC
69038: ST_TO_ADDR
69039: LD_INT 1
69041: PUSH
69042: FOR_DOWNTO
69043: IFFALSE 69639
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69045: LD_EXP 72
69049: PUSH
69050: LD_VAR 0 2
69054: ARRAY
69055: PUSH
69056: LD_VAR 0 3
69060: ARRAY
69061: PPUSH
69062: CALL_OW 301
69066: PUSH
69067: LD_EXP 72
69071: PUSH
69072: LD_VAR 0 2
69076: ARRAY
69077: PUSH
69078: LD_VAR 0 3
69082: ARRAY
69083: PPUSH
69084: CALL_OW 257
69088: PUSH
69089: LD_INT 1
69091: NONEQUAL
69092: OR
69093: IFFALSE 69156
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69095: LD_ADDR_VAR 0 5
69099: PUSH
69100: LD_EXP 72
69104: PUSH
69105: LD_VAR 0 2
69109: ARRAY
69110: PUSH
69111: LD_EXP 72
69115: PUSH
69116: LD_VAR 0 2
69120: ARRAY
69121: PUSH
69122: LD_VAR 0 3
69126: ARRAY
69127: DIFF
69128: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69129: LD_ADDR_EXP 72
69133: PUSH
69134: LD_EXP 72
69138: PPUSH
69139: LD_VAR 0 2
69143: PPUSH
69144: LD_VAR 0 5
69148: PPUSH
69149: CALL_OW 1
69153: ST_TO_ADDR
// continue ;
69154: GO 69042
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69156: LD_EXP 72
69160: PUSH
69161: LD_VAR 0 2
69165: ARRAY
69166: PUSH
69167: LD_VAR 0 3
69171: ARRAY
69172: PPUSH
69173: CALL 20775 0 1
69177: PUSH
69178: LD_EXP 72
69182: PUSH
69183: LD_VAR 0 2
69187: ARRAY
69188: PUSH
69189: LD_VAR 0 3
69193: ARRAY
69194: PPUSH
69195: CALL_OW 255
69199: PPUSH
69200: LD_EXP 71
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: PUSH
69211: LD_VAR 0 4
69215: ARRAY
69216: PUSH
69217: LD_INT 1
69219: ARRAY
69220: PPUSH
69221: LD_EXP 71
69225: PUSH
69226: LD_VAR 0 2
69230: ARRAY
69231: PUSH
69232: LD_VAR 0 4
69236: ARRAY
69237: PUSH
69238: LD_INT 2
69240: ARRAY
69241: PPUSH
69242: LD_INT 15
69244: PPUSH
69245: CALL 21735 0 4
69249: PUSH
69250: LD_INT 4
69252: ARRAY
69253: PUSH
69254: LD_EXP 72
69258: PUSH
69259: LD_VAR 0 2
69263: ARRAY
69264: PUSH
69265: LD_VAR 0 3
69269: ARRAY
69270: PPUSH
69271: LD_INT 10
69273: PPUSH
69274: CALL 23432 0 2
69278: PUSH
69279: LD_INT 4
69281: ARRAY
69282: OR
69283: AND
69284: IFFALSE 69307
// ComStop ( mc_miners [ i ] [ j ] ) ;
69286: LD_EXP 72
69290: PUSH
69291: LD_VAR 0 2
69295: ARRAY
69296: PUSH
69297: LD_VAR 0 3
69301: ARRAY
69302: PPUSH
69303: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69307: LD_EXP 72
69311: PUSH
69312: LD_VAR 0 2
69316: ARRAY
69317: PUSH
69318: LD_VAR 0 3
69322: ARRAY
69323: PPUSH
69324: CALL_OW 257
69328: PUSH
69329: LD_INT 1
69331: EQUAL
69332: PUSH
69333: LD_EXP 72
69337: PUSH
69338: LD_VAR 0 2
69342: ARRAY
69343: PUSH
69344: LD_VAR 0 3
69348: ARRAY
69349: PPUSH
69350: CALL_OW 459
69354: NOT
69355: AND
69356: PUSH
69357: LD_EXP 72
69361: PUSH
69362: LD_VAR 0 2
69366: ARRAY
69367: PUSH
69368: LD_VAR 0 3
69372: ARRAY
69373: PPUSH
69374: CALL_OW 255
69378: PPUSH
69379: LD_EXP 71
69383: PUSH
69384: LD_VAR 0 2
69388: ARRAY
69389: PUSH
69390: LD_VAR 0 4
69394: ARRAY
69395: PUSH
69396: LD_INT 1
69398: ARRAY
69399: PPUSH
69400: LD_EXP 71
69404: PUSH
69405: LD_VAR 0 2
69409: ARRAY
69410: PUSH
69411: LD_VAR 0 4
69415: ARRAY
69416: PUSH
69417: LD_INT 2
69419: ARRAY
69420: PPUSH
69421: LD_INT 15
69423: PPUSH
69424: CALL 21735 0 4
69428: PUSH
69429: LD_INT 4
69431: ARRAY
69432: PUSH
69433: LD_INT 0
69435: EQUAL
69436: AND
69437: PUSH
69438: LD_EXP 72
69442: PUSH
69443: LD_VAR 0 2
69447: ARRAY
69448: PUSH
69449: LD_VAR 0 3
69453: ARRAY
69454: PPUSH
69455: CALL_OW 314
69459: NOT
69460: AND
69461: IFFALSE 69637
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69463: LD_EXP 72
69467: PUSH
69468: LD_VAR 0 2
69472: ARRAY
69473: PUSH
69474: LD_VAR 0 3
69478: ARRAY
69479: PPUSH
69480: CALL_OW 310
69484: IFFALSE 69507
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69486: LD_EXP 72
69490: PUSH
69491: LD_VAR 0 2
69495: ARRAY
69496: PUSH
69497: LD_VAR 0 3
69501: ARRAY
69502: PPUSH
69503: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69507: LD_EXP 72
69511: PUSH
69512: LD_VAR 0 2
69516: ARRAY
69517: PUSH
69518: LD_VAR 0 3
69522: ARRAY
69523: PPUSH
69524: CALL_OW 314
69528: NOT
69529: IFFALSE 69597
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69531: LD_EXP 72
69535: PUSH
69536: LD_VAR 0 2
69540: ARRAY
69541: PUSH
69542: LD_VAR 0 3
69546: ARRAY
69547: PPUSH
69548: LD_EXP 71
69552: PUSH
69553: LD_VAR 0 2
69557: ARRAY
69558: PUSH
69559: LD_VAR 0 4
69563: ARRAY
69564: PUSH
69565: LD_INT 1
69567: ARRAY
69568: PPUSH
69569: LD_EXP 71
69573: PUSH
69574: LD_VAR 0 2
69578: ARRAY
69579: PUSH
69580: LD_VAR 0 4
69584: ARRAY
69585: PUSH
69586: LD_INT 2
69588: ARRAY
69589: PPUSH
69590: LD_INT 0
69592: PPUSH
69593: CALL_OW 193
// k := k + 1 ;
69597: LD_ADDR_VAR 0 4
69601: PUSH
69602: LD_VAR 0 4
69606: PUSH
69607: LD_INT 1
69609: PLUS
69610: ST_TO_ADDR
// if k > mc_mines [ i ] then
69611: LD_VAR 0 4
69615: PUSH
69616: LD_EXP 71
69620: PUSH
69621: LD_VAR 0 2
69625: ARRAY
69626: GREATER
69627: IFFALSE 69637
// k := 1 ;
69629: LD_ADDR_VAR 0 4
69633: PUSH
69634: LD_INT 1
69636: ST_TO_ADDR
// end ; end ;
69637: GO 69042
69639: POP
69640: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69641: LD_ADDR_VAR 0 5
69645: PUSH
69646: LD_EXP 58
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: PPUSH
69657: LD_INT 2
69659: PUSH
69660: LD_INT 30
69662: PUSH
69663: LD_INT 4
69665: PUSH
69666: EMPTY
69667: LIST
69668: LIST
69669: PUSH
69670: LD_INT 30
69672: PUSH
69673: LD_INT 5
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: PUSH
69680: LD_INT 30
69682: PUSH
69683: LD_INT 32
69685: PUSH
69686: EMPTY
69687: LIST
69688: LIST
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: PPUSH
69696: CALL_OW 72
69700: ST_TO_ADDR
// if not tmp then
69701: LD_VAR 0 5
69705: NOT
69706: IFFALSE 69710
// continue ;
69708: GO 68959
// list := [ ] ;
69710: LD_ADDR_VAR 0 6
69714: PUSH
69715: EMPTY
69716: ST_TO_ADDR
// for j in tmp do
69717: LD_ADDR_VAR 0 3
69721: PUSH
69722: LD_VAR 0 5
69726: PUSH
69727: FOR_IN
69728: IFFALSE 69797
// begin for k in UnitsInside ( j ) do
69730: LD_ADDR_VAR 0 4
69734: PUSH
69735: LD_VAR 0 3
69739: PPUSH
69740: CALL_OW 313
69744: PUSH
69745: FOR_IN
69746: IFFALSE 69793
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69748: LD_VAR 0 4
69752: PPUSH
69753: CALL_OW 257
69757: PUSH
69758: LD_INT 1
69760: EQUAL
69761: PUSH
69762: LD_VAR 0 4
69766: PPUSH
69767: CALL_OW 459
69771: NOT
69772: AND
69773: IFFALSE 69791
// list := list ^ k ;
69775: LD_ADDR_VAR 0 6
69779: PUSH
69780: LD_VAR 0 6
69784: PUSH
69785: LD_VAR 0 4
69789: ADD
69790: ST_TO_ADDR
69791: GO 69745
69793: POP
69794: POP
// end ;
69795: GO 69727
69797: POP
69798: POP
// list := list diff mc_miners [ i ] ;
69799: LD_ADDR_VAR 0 6
69803: PUSH
69804: LD_VAR 0 6
69808: PUSH
69809: LD_EXP 72
69813: PUSH
69814: LD_VAR 0 2
69818: ARRAY
69819: DIFF
69820: ST_TO_ADDR
// if not list then
69821: LD_VAR 0 6
69825: NOT
69826: IFFALSE 69830
// continue ;
69828: GO 68959
// k := mc_mines [ i ] - mc_miners [ i ] ;
69830: LD_ADDR_VAR 0 4
69834: PUSH
69835: LD_EXP 71
69839: PUSH
69840: LD_VAR 0 2
69844: ARRAY
69845: PUSH
69846: LD_EXP 72
69850: PUSH
69851: LD_VAR 0 2
69855: ARRAY
69856: MINUS
69857: ST_TO_ADDR
// if k > list then
69858: LD_VAR 0 4
69862: PUSH
69863: LD_VAR 0 6
69867: GREATER
69868: IFFALSE 69880
// k := list ;
69870: LD_ADDR_VAR 0 4
69874: PUSH
69875: LD_VAR 0 6
69879: ST_TO_ADDR
// for j = 1 to k do
69880: LD_ADDR_VAR 0 3
69884: PUSH
69885: DOUBLE
69886: LD_INT 1
69888: DEC
69889: ST_TO_ADDR
69890: LD_VAR 0 4
69894: PUSH
69895: FOR_TO
69896: IFFALSE 69950
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69898: LD_ADDR_EXP 72
69902: PUSH
69903: LD_EXP 72
69907: PPUSH
69908: LD_VAR 0 2
69912: PUSH
69913: LD_EXP 72
69917: PUSH
69918: LD_VAR 0 2
69922: ARRAY
69923: PUSH
69924: LD_INT 1
69926: PLUS
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PPUSH
69932: LD_VAR 0 6
69936: PUSH
69937: LD_VAR 0 3
69941: ARRAY
69942: PPUSH
69943: CALL 20839 0 3
69947: ST_TO_ADDR
69948: GO 69895
69950: POP
69951: POP
// end ;
69952: GO 68959
69954: POP
69955: POP
// end ;
69956: LD_VAR 0 1
69960: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
69961: LD_INT 0
69963: PPUSH
69964: PPUSH
69965: PPUSH
69966: PPUSH
69967: PPUSH
69968: PPUSH
69969: PPUSH
69970: PPUSH
69971: PPUSH
69972: PPUSH
// if not mc_bases then
69973: LD_EXP 58
69977: NOT
69978: IFFALSE 69982
// exit ;
69980: GO 71732
// for i = 1 to mc_bases do
69982: LD_ADDR_VAR 0 2
69986: PUSH
69987: DOUBLE
69988: LD_INT 1
69990: DEC
69991: ST_TO_ADDR
69992: LD_EXP 58
69996: PUSH
69997: FOR_TO
69998: IFFALSE 71730
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70000: LD_EXP 58
70004: PUSH
70005: LD_VAR 0 2
70009: ARRAY
70010: NOT
70011: PUSH
70012: LD_EXP 65
70016: PUSH
70017: LD_VAR 0 2
70021: ARRAY
70022: OR
70023: IFFALSE 70027
// continue ;
70025: GO 69997
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70027: LD_EXP 74
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: NOT
70038: PUSH
70039: LD_EXP 75
70043: PUSH
70044: LD_VAR 0 2
70048: ARRAY
70049: AND
70050: IFFALSE 70088
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70052: LD_ADDR_EXP 75
70056: PUSH
70057: LD_EXP 75
70061: PPUSH
70062: LD_VAR 0 2
70066: PPUSH
70067: EMPTY
70068: PPUSH
70069: CALL_OW 1
70073: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70074: LD_VAR 0 2
70078: PPUSH
70079: LD_INT 107
70081: PPUSH
70082: CALL 60842 0 2
// continue ;
70086: GO 69997
// end ; target := [ ] ;
70088: LD_ADDR_VAR 0 6
70092: PUSH
70093: EMPTY
70094: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70095: LD_ADDR_VAR 0 3
70099: PUSH
70100: DOUBLE
70101: LD_EXP 74
70105: PUSH
70106: LD_VAR 0 2
70110: ARRAY
70111: INC
70112: ST_TO_ADDR
70113: LD_INT 1
70115: PUSH
70116: FOR_DOWNTO
70117: IFFALSE 70377
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70119: LD_EXP 74
70123: PUSH
70124: LD_VAR 0 2
70128: ARRAY
70129: PUSH
70130: LD_VAR 0 3
70134: ARRAY
70135: PUSH
70136: LD_INT 2
70138: ARRAY
70139: PPUSH
70140: LD_EXP 74
70144: PUSH
70145: LD_VAR 0 2
70149: ARRAY
70150: PUSH
70151: LD_VAR 0 3
70155: ARRAY
70156: PUSH
70157: LD_INT 3
70159: ARRAY
70160: PPUSH
70161: CALL_OW 488
70165: PUSH
70166: LD_EXP 74
70170: PUSH
70171: LD_VAR 0 2
70175: ARRAY
70176: PUSH
70177: LD_VAR 0 3
70181: ARRAY
70182: PUSH
70183: LD_INT 2
70185: ARRAY
70186: PPUSH
70187: LD_EXP 74
70191: PUSH
70192: LD_VAR 0 2
70196: ARRAY
70197: PUSH
70198: LD_VAR 0 3
70202: ARRAY
70203: PUSH
70204: LD_INT 3
70206: ARRAY
70207: PPUSH
70208: CALL_OW 284
70212: PUSH
70213: LD_INT 0
70215: EQUAL
70216: AND
70217: IFFALSE 70272
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70219: LD_ADDR_VAR 0 5
70223: PUSH
70224: LD_EXP 74
70228: PUSH
70229: LD_VAR 0 2
70233: ARRAY
70234: PPUSH
70235: LD_VAR 0 3
70239: PPUSH
70240: CALL_OW 3
70244: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70245: LD_ADDR_EXP 74
70249: PUSH
70250: LD_EXP 74
70254: PPUSH
70255: LD_VAR 0 2
70259: PPUSH
70260: LD_VAR 0 5
70264: PPUSH
70265: CALL_OW 1
70269: ST_TO_ADDR
// continue ;
70270: GO 70116
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70272: LD_EXP 58
70276: PUSH
70277: LD_VAR 0 2
70281: ARRAY
70282: PUSH
70283: LD_INT 1
70285: ARRAY
70286: PPUSH
70287: CALL_OW 255
70291: PPUSH
70292: LD_EXP 74
70296: PUSH
70297: LD_VAR 0 2
70301: ARRAY
70302: PUSH
70303: LD_VAR 0 3
70307: ARRAY
70308: PUSH
70309: LD_INT 2
70311: ARRAY
70312: PPUSH
70313: LD_EXP 74
70317: PUSH
70318: LD_VAR 0 2
70322: ARRAY
70323: PUSH
70324: LD_VAR 0 3
70328: ARRAY
70329: PUSH
70330: LD_INT 3
70332: ARRAY
70333: PPUSH
70334: LD_INT 30
70336: PPUSH
70337: CALL 21735 0 4
70341: PUSH
70342: LD_INT 4
70344: ARRAY
70345: PUSH
70346: LD_INT 0
70348: EQUAL
70349: IFFALSE 70375
// begin target := mc_crates [ i ] [ j ] ;
70351: LD_ADDR_VAR 0 6
70355: PUSH
70356: LD_EXP 74
70360: PUSH
70361: LD_VAR 0 2
70365: ARRAY
70366: PUSH
70367: LD_VAR 0 3
70371: ARRAY
70372: ST_TO_ADDR
// break ;
70373: GO 70377
// end ; end ;
70375: GO 70116
70377: POP
70378: POP
// if not target then
70379: LD_VAR 0 6
70383: NOT
70384: IFFALSE 70388
// continue ;
70386: GO 69997
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70388: LD_ADDR_VAR 0 7
70392: PUSH
70393: LD_EXP 77
70397: PUSH
70398: LD_VAR 0 2
70402: ARRAY
70403: PPUSH
70404: LD_INT 2
70406: PUSH
70407: LD_INT 3
70409: PUSH
70410: LD_INT 58
70412: PUSH
70413: EMPTY
70414: LIST
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 61
70422: PUSH
70423: EMPTY
70424: LIST
70425: PUSH
70426: LD_INT 33
70428: PUSH
70429: LD_INT 5
70431: PUSH
70432: EMPTY
70433: LIST
70434: LIST
70435: PUSH
70436: LD_INT 33
70438: PUSH
70439: LD_INT 3
70441: PUSH
70442: EMPTY
70443: LIST
70444: LIST
70445: PUSH
70446: EMPTY
70447: LIST
70448: LIST
70449: LIST
70450: LIST
70451: LIST
70452: PUSH
70453: LD_INT 2
70455: PUSH
70456: LD_INT 34
70458: PUSH
70459: LD_INT 32
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: PUSH
70466: LD_INT 34
70468: PUSH
70469: LD_INT 51
70471: PUSH
70472: EMPTY
70473: LIST
70474: LIST
70475: PUSH
70476: LD_INT 34
70478: PUSH
70479: LD_INT 12
70481: PUSH
70482: EMPTY
70483: LIST
70484: LIST
70485: PUSH
70486: EMPTY
70487: LIST
70488: LIST
70489: LIST
70490: LIST
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PPUSH
70496: CALL_OW 72
70500: ST_TO_ADDR
// if not cargo then
70501: LD_VAR 0 7
70505: NOT
70506: IFFALSE 71149
// begin if mc_crates_collector [ i ] < 5 then
70508: LD_EXP 75
70512: PUSH
70513: LD_VAR 0 2
70517: ARRAY
70518: PUSH
70519: LD_INT 5
70521: LESS
70522: IFFALSE 70888
// begin if mc_ape [ i ] then
70524: LD_EXP 87
70528: PUSH
70529: LD_VAR 0 2
70533: ARRAY
70534: IFFALSE 70581
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70536: LD_ADDR_VAR 0 5
70540: PUSH
70541: LD_EXP 87
70545: PUSH
70546: LD_VAR 0 2
70550: ARRAY
70551: PPUSH
70552: LD_INT 25
70554: PUSH
70555: LD_INT 16
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: PUSH
70562: LD_INT 24
70564: PUSH
70565: LD_INT 750
70567: PUSH
70568: EMPTY
70569: LIST
70570: LIST
70571: PUSH
70572: EMPTY
70573: LIST
70574: LIST
70575: PPUSH
70576: CALL_OW 72
70580: ST_TO_ADDR
// if not tmp then
70581: LD_VAR 0 5
70585: NOT
70586: IFFALSE 70633
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70588: LD_ADDR_VAR 0 5
70592: PUSH
70593: LD_EXP 58
70597: PUSH
70598: LD_VAR 0 2
70602: ARRAY
70603: PPUSH
70604: LD_INT 25
70606: PUSH
70607: LD_INT 2
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 24
70616: PUSH
70617: LD_INT 750
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PPUSH
70628: CALL_OW 72
70632: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70633: LD_EXP 87
70637: PUSH
70638: LD_VAR 0 2
70642: ARRAY
70643: PUSH
70644: LD_EXP 58
70648: PUSH
70649: LD_VAR 0 2
70653: ARRAY
70654: PPUSH
70655: LD_INT 25
70657: PUSH
70658: LD_INT 2
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 24
70667: PUSH
70668: LD_INT 750
70670: PUSH
70671: EMPTY
70672: LIST
70673: LIST
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PPUSH
70679: CALL_OW 72
70683: AND
70684: PUSH
70685: LD_VAR 0 5
70689: PUSH
70690: LD_INT 5
70692: LESS
70693: AND
70694: IFFALSE 70776
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70696: LD_ADDR_VAR 0 3
70700: PUSH
70701: LD_EXP 58
70705: PUSH
70706: LD_VAR 0 2
70710: ARRAY
70711: PPUSH
70712: LD_INT 25
70714: PUSH
70715: LD_INT 2
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 24
70724: PUSH
70725: LD_INT 750
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PPUSH
70736: CALL_OW 72
70740: PUSH
70741: FOR_IN
70742: IFFALSE 70774
// begin tmp := tmp union j ;
70744: LD_ADDR_VAR 0 5
70748: PUSH
70749: LD_VAR 0 5
70753: PUSH
70754: LD_VAR 0 3
70758: UNION
70759: ST_TO_ADDR
// if tmp >= 5 then
70760: LD_VAR 0 5
70764: PUSH
70765: LD_INT 5
70767: GREATEREQUAL
70768: IFFALSE 70772
// break ;
70770: GO 70774
// end ;
70772: GO 70741
70774: POP
70775: POP
// end ; if not tmp then
70776: LD_VAR 0 5
70780: NOT
70781: IFFALSE 70785
// continue ;
70783: GO 69997
// for j in tmp do
70785: LD_ADDR_VAR 0 3
70789: PUSH
70790: LD_VAR 0 5
70794: PUSH
70795: FOR_IN
70796: IFFALSE 70886
// if not GetTag ( j ) then
70798: LD_VAR 0 3
70802: PPUSH
70803: CALL_OW 110
70807: NOT
70808: IFFALSE 70884
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70810: LD_ADDR_EXP 75
70814: PUSH
70815: LD_EXP 75
70819: PPUSH
70820: LD_VAR 0 2
70824: PUSH
70825: LD_EXP 75
70829: PUSH
70830: LD_VAR 0 2
70834: ARRAY
70835: PUSH
70836: LD_INT 1
70838: PLUS
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PPUSH
70844: LD_VAR 0 3
70848: PPUSH
70849: CALL 20839 0 3
70853: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70854: LD_VAR 0 3
70858: PPUSH
70859: LD_INT 107
70861: PPUSH
70862: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70866: LD_EXP 75
70870: PUSH
70871: LD_VAR 0 2
70875: ARRAY
70876: PUSH
70877: LD_INT 5
70879: GREATEREQUAL
70880: IFFALSE 70884
// break ;
70882: GO 70886
// end ;
70884: GO 70795
70886: POP
70887: POP
// end ; if mc_crates_collector [ i ] and target then
70888: LD_EXP 75
70892: PUSH
70893: LD_VAR 0 2
70897: ARRAY
70898: PUSH
70899: LD_VAR 0 6
70903: AND
70904: IFFALSE 71147
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70906: LD_EXP 75
70910: PUSH
70911: LD_VAR 0 2
70915: ARRAY
70916: PUSH
70917: LD_VAR 0 6
70921: PUSH
70922: LD_INT 1
70924: ARRAY
70925: LESS
70926: IFFALSE 70946
// tmp := mc_crates_collector [ i ] else
70928: LD_ADDR_VAR 0 5
70932: PUSH
70933: LD_EXP 75
70937: PUSH
70938: LD_VAR 0 2
70942: ARRAY
70943: ST_TO_ADDR
70944: GO 70960
// tmp := target [ 1 ] ;
70946: LD_ADDR_VAR 0 5
70950: PUSH
70951: LD_VAR 0 6
70955: PUSH
70956: LD_INT 1
70958: ARRAY
70959: ST_TO_ADDR
// k := 0 ;
70960: LD_ADDR_VAR 0 4
70964: PUSH
70965: LD_INT 0
70967: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70968: LD_ADDR_VAR 0 3
70972: PUSH
70973: LD_EXP 75
70977: PUSH
70978: LD_VAR 0 2
70982: ARRAY
70983: PUSH
70984: FOR_IN
70985: IFFALSE 71145
// begin k := k + 1 ;
70987: LD_ADDR_VAR 0 4
70991: PUSH
70992: LD_VAR 0 4
70996: PUSH
70997: LD_INT 1
70999: PLUS
71000: ST_TO_ADDR
// if k > tmp then
71001: LD_VAR 0 4
71005: PUSH
71006: LD_VAR 0 5
71010: GREATER
71011: IFFALSE 71015
// break ;
71013: GO 71145
// if not GetClass ( j ) in [ 2 , 16 ] then
71015: LD_VAR 0 3
71019: PPUSH
71020: CALL_OW 257
71024: PUSH
71025: LD_INT 2
71027: PUSH
71028: LD_INT 16
71030: PUSH
71031: EMPTY
71032: LIST
71033: LIST
71034: IN
71035: NOT
71036: IFFALSE 71089
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71038: LD_ADDR_EXP 75
71042: PUSH
71043: LD_EXP 75
71047: PPUSH
71048: LD_VAR 0 2
71052: PPUSH
71053: LD_EXP 75
71057: PUSH
71058: LD_VAR 0 2
71062: ARRAY
71063: PUSH
71064: LD_VAR 0 3
71068: DIFF
71069: PPUSH
71070: CALL_OW 1
71074: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71075: LD_VAR 0 3
71079: PPUSH
71080: LD_INT 0
71082: PPUSH
71083: CALL_OW 109
// continue ;
71087: GO 70984
// end ; if IsInUnit ( j ) then
71089: LD_VAR 0 3
71093: PPUSH
71094: CALL_OW 310
71098: IFFALSE 71109
// ComExitBuilding ( j ) ;
71100: LD_VAR 0 3
71104: PPUSH
71105: CALL_OW 122
// wait ( 3 ) ;
71109: LD_INT 3
71111: PPUSH
71112: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71116: LD_VAR 0 3
71120: PPUSH
71121: LD_VAR 0 6
71125: PUSH
71126: LD_INT 2
71128: ARRAY
71129: PPUSH
71130: LD_VAR 0 6
71134: PUSH
71135: LD_INT 3
71137: ARRAY
71138: PPUSH
71139: CALL_OW 117
// end ;
71143: GO 70984
71145: POP
71146: POP
// end ; end else
71147: GO 71728
// begin for j in cargo do
71149: LD_ADDR_VAR 0 3
71153: PUSH
71154: LD_VAR 0 7
71158: PUSH
71159: FOR_IN
71160: IFFALSE 71726
// begin if GetTag ( j ) <> 0 then
71162: LD_VAR 0 3
71166: PPUSH
71167: CALL_OW 110
71171: PUSH
71172: LD_INT 0
71174: NONEQUAL
71175: IFFALSE 71179
// continue ;
71177: GO 71159
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71179: LD_VAR 0 3
71183: PPUSH
71184: CALL_OW 256
71188: PUSH
71189: LD_INT 1000
71191: LESS
71192: PUSH
71193: LD_VAR 0 3
71197: PPUSH
71198: LD_EXP 82
71202: PUSH
71203: LD_VAR 0 2
71207: ARRAY
71208: PPUSH
71209: CALL_OW 308
71213: NOT
71214: AND
71215: IFFALSE 71237
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71217: LD_VAR 0 3
71221: PPUSH
71222: LD_EXP 82
71226: PUSH
71227: LD_VAR 0 2
71231: ARRAY
71232: PPUSH
71233: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71237: LD_VAR 0 3
71241: PPUSH
71242: CALL_OW 256
71246: PUSH
71247: LD_INT 1000
71249: LESS
71250: PUSH
71251: LD_VAR 0 3
71255: PPUSH
71256: LD_EXP 82
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: PPUSH
71267: CALL_OW 308
71271: AND
71272: IFFALSE 71276
// continue ;
71274: GO 71159
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71276: LD_VAR 0 3
71280: PPUSH
71281: CALL_OW 262
71285: PUSH
71286: LD_INT 2
71288: EQUAL
71289: PUSH
71290: LD_VAR 0 3
71294: PPUSH
71295: CALL_OW 261
71299: PUSH
71300: LD_INT 15
71302: LESS
71303: AND
71304: IFFALSE 71308
// continue ;
71306: GO 71159
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71308: LD_VAR 0 3
71312: PPUSH
71313: CALL_OW 262
71317: PUSH
71318: LD_INT 1
71320: EQUAL
71321: PUSH
71322: LD_VAR 0 3
71326: PPUSH
71327: CALL_OW 261
71331: PUSH
71332: LD_INT 10
71334: LESS
71335: AND
71336: IFFALSE 71665
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71338: LD_ADDR_VAR 0 8
71342: PUSH
71343: LD_EXP 58
71347: PUSH
71348: LD_VAR 0 2
71352: ARRAY
71353: PPUSH
71354: LD_INT 2
71356: PUSH
71357: LD_INT 30
71359: PUSH
71360: LD_INT 0
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 30
71369: PUSH
71370: LD_INT 1
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: EMPTY
71378: LIST
71379: LIST
71380: LIST
71381: PPUSH
71382: CALL_OW 72
71386: ST_TO_ADDR
// if not depot then
71387: LD_VAR 0 8
71391: NOT
71392: IFFALSE 71396
// continue ;
71394: GO 71159
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71396: LD_VAR 0 3
71400: PPUSH
71401: LD_VAR 0 8
71405: PPUSH
71406: LD_VAR 0 3
71410: PPUSH
71411: CALL_OW 74
71415: PPUSH
71416: CALL_OW 296
71420: PUSH
71421: LD_INT 6
71423: LESS
71424: IFFALSE 71440
// SetFuel ( j , 100 ) else
71426: LD_VAR 0 3
71430: PPUSH
71431: LD_INT 100
71433: PPUSH
71434: CALL_OW 240
71438: GO 71665
// if GetFuel ( j ) = 0 then
71440: LD_VAR 0 3
71444: PPUSH
71445: CALL_OW 261
71449: PUSH
71450: LD_INT 0
71452: EQUAL
71453: IFFALSE 71665
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71455: LD_ADDR_EXP 77
71459: PUSH
71460: LD_EXP 77
71464: PPUSH
71465: LD_VAR 0 2
71469: PPUSH
71470: LD_EXP 77
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_VAR 0 3
71485: DIFF
71486: PPUSH
71487: CALL_OW 1
71491: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71492: LD_VAR 0 3
71496: PPUSH
71497: CALL_OW 263
71501: PUSH
71502: LD_INT 1
71504: EQUAL
71505: IFFALSE 71521
// ComExitVehicle ( IsInUnit ( j ) ) ;
71507: LD_VAR 0 3
71511: PPUSH
71512: CALL_OW 310
71516: PPUSH
71517: CALL_OW 121
// if GetControl ( j ) = control_remote then
71521: LD_VAR 0 3
71525: PPUSH
71526: CALL_OW 263
71530: PUSH
71531: LD_INT 2
71533: EQUAL
71534: IFFALSE 71545
// ComUnlink ( j ) ;
71536: LD_VAR 0 3
71540: PPUSH
71541: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71545: LD_ADDR_VAR 0 9
71549: PUSH
71550: LD_VAR 0 2
71554: PPUSH
71555: LD_INT 3
71557: PPUSH
71558: CALL 80802 0 2
71562: ST_TO_ADDR
// if fac then
71563: LD_VAR 0 9
71567: IFFALSE 71663
// begin for k in fac do
71569: LD_ADDR_VAR 0 4
71573: PUSH
71574: LD_VAR 0 9
71578: PUSH
71579: FOR_IN
71580: IFFALSE 71661
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71582: LD_ADDR_VAR 0 10
71586: PUSH
71587: LD_VAR 0 9
71591: PPUSH
71592: LD_VAR 0 3
71596: PPUSH
71597: CALL_OW 265
71601: PPUSH
71602: LD_VAR 0 3
71606: PPUSH
71607: CALL_OW 262
71611: PPUSH
71612: LD_VAR 0 3
71616: PPUSH
71617: CALL_OW 263
71621: PPUSH
71622: LD_VAR 0 3
71626: PPUSH
71627: CALL_OW 264
71631: PPUSH
71632: CALL 18371 0 5
71636: ST_TO_ADDR
// if components then
71637: LD_VAR 0 10
71641: IFFALSE 71659
// begin MC_InsertProduceList ( i , components ) ;
71643: LD_VAR 0 2
71647: PPUSH
71648: LD_VAR 0 10
71652: PPUSH
71653: CALL 80347 0 2
// break ;
71657: GO 71661
// end ; end ;
71659: GO 71579
71661: POP
71662: POP
// end ; continue ;
71663: GO 71159
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71665: LD_VAR 0 3
71669: PPUSH
71670: LD_INT 1
71672: PPUSH
71673: CALL_OW 289
71677: PUSH
71678: LD_INT 100
71680: LESS
71681: PUSH
71682: LD_VAR 0 3
71686: PPUSH
71687: CALL_OW 314
71691: NOT
71692: AND
71693: IFFALSE 71722
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71695: LD_VAR 0 3
71699: PPUSH
71700: LD_VAR 0 6
71704: PUSH
71705: LD_INT 2
71707: ARRAY
71708: PPUSH
71709: LD_VAR 0 6
71713: PUSH
71714: LD_INT 3
71716: ARRAY
71717: PPUSH
71718: CALL_OW 117
// break ;
71722: GO 71726
// end ;
71724: GO 71159
71726: POP
71727: POP
// end ; end ;
71728: GO 69997
71730: POP
71731: POP
// end ;
71732: LD_VAR 0 1
71736: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71737: LD_INT 0
71739: PPUSH
71740: PPUSH
71741: PPUSH
71742: PPUSH
// if not mc_bases then
71743: LD_EXP 58
71747: NOT
71748: IFFALSE 71752
// exit ;
71750: GO 71913
// for i = 1 to mc_bases do
71752: LD_ADDR_VAR 0 2
71756: PUSH
71757: DOUBLE
71758: LD_INT 1
71760: DEC
71761: ST_TO_ADDR
71762: LD_EXP 58
71766: PUSH
71767: FOR_TO
71768: IFFALSE 71911
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71770: LD_ADDR_VAR 0 4
71774: PUSH
71775: LD_EXP 77
71779: PUSH
71780: LD_VAR 0 2
71784: ARRAY
71785: PUSH
71786: LD_EXP 80
71790: PUSH
71791: LD_VAR 0 2
71795: ARRAY
71796: UNION
71797: PPUSH
71798: LD_INT 33
71800: PUSH
71801: LD_INT 2
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: PPUSH
71808: CALL_OW 72
71812: ST_TO_ADDR
// if tmp then
71813: LD_VAR 0 4
71817: IFFALSE 71909
// for j in tmp do
71819: LD_ADDR_VAR 0 3
71823: PUSH
71824: LD_VAR 0 4
71828: PUSH
71829: FOR_IN
71830: IFFALSE 71907
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71832: LD_VAR 0 3
71836: PPUSH
71837: CALL_OW 312
71841: NOT
71842: PUSH
71843: LD_VAR 0 3
71847: PPUSH
71848: CALL_OW 256
71852: PUSH
71853: LD_INT 250
71855: GREATEREQUAL
71856: AND
71857: IFFALSE 71870
// Connect ( j ) else
71859: LD_VAR 0 3
71863: PPUSH
71864: CALL 23772 0 1
71868: GO 71905
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71870: LD_VAR 0 3
71874: PPUSH
71875: CALL_OW 256
71879: PUSH
71880: LD_INT 250
71882: LESS
71883: PUSH
71884: LD_VAR 0 3
71888: PPUSH
71889: CALL_OW 312
71893: AND
71894: IFFALSE 71905
// ComUnlink ( j ) ;
71896: LD_VAR 0 3
71900: PPUSH
71901: CALL_OW 136
71905: GO 71829
71907: POP
71908: POP
// end ;
71909: GO 71767
71911: POP
71912: POP
// end ;
71913: LD_VAR 0 1
71917: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71918: LD_INT 0
71920: PPUSH
71921: PPUSH
71922: PPUSH
71923: PPUSH
71924: PPUSH
// if not mc_bases then
71925: LD_EXP 58
71929: NOT
71930: IFFALSE 71934
// exit ;
71932: GO 72379
// for i = 1 to mc_bases do
71934: LD_ADDR_VAR 0 2
71938: PUSH
71939: DOUBLE
71940: LD_INT 1
71942: DEC
71943: ST_TO_ADDR
71944: LD_EXP 58
71948: PUSH
71949: FOR_TO
71950: IFFALSE 72377
// begin if not mc_produce [ i ] then
71952: LD_EXP 79
71956: PUSH
71957: LD_VAR 0 2
71961: ARRAY
71962: NOT
71963: IFFALSE 71967
// continue ;
71965: GO 71949
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71967: LD_ADDR_VAR 0 5
71971: PUSH
71972: LD_EXP 58
71976: PUSH
71977: LD_VAR 0 2
71981: ARRAY
71982: PPUSH
71983: LD_INT 30
71985: PUSH
71986: LD_INT 3
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PPUSH
71993: CALL_OW 72
71997: ST_TO_ADDR
// if not fac then
71998: LD_VAR 0 5
72002: NOT
72003: IFFALSE 72007
// continue ;
72005: GO 71949
// for j in fac do
72007: LD_ADDR_VAR 0 3
72011: PUSH
72012: LD_VAR 0 5
72016: PUSH
72017: FOR_IN
72018: IFFALSE 72373
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72020: LD_VAR 0 3
72024: PPUSH
72025: CALL_OW 461
72029: PUSH
72030: LD_INT 2
72032: NONEQUAL
72033: PUSH
72034: LD_VAR 0 3
72038: PPUSH
72039: LD_INT 15
72041: PPUSH
72042: CALL 23432 0 2
72046: PUSH
72047: LD_INT 4
72049: ARRAY
72050: OR
72051: IFFALSE 72055
// continue ;
72053: GO 72017
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72055: LD_VAR 0 3
72059: PPUSH
72060: LD_EXP 79
72064: PUSH
72065: LD_VAR 0 2
72069: ARRAY
72070: PUSH
72071: LD_INT 1
72073: ARRAY
72074: PUSH
72075: LD_INT 1
72077: ARRAY
72078: PPUSH
72079: LD_EXP 79
72083: PUSH
72084: LD_VAR 0 2
72088: ARRAY
72089: PUSH
72090: LD_INT 1
72092: ARRAY
72093: PUSH
72094: LD_INT 2
72096: ARRAY
72097: PPUSH
72098: LD_EXP 79
72102: PUSH
72103: LD_VAR 0 2
72107: ARRAY
72108: PUSH
72109: LD_INT 1
72111: ARRAY
72112: PUSH
72113: LD_INT 3
72115: ARRAY
72116: PPUSH
72117: LD_EXP 79
72121: PUSH
72122: LD_VAR 0 2
72126: ARRAY
72127: PUSH
72128: LD_INT 1
72130: ARRAY
72131: PUSH
72132: LD_INT 4
72134: ARRAY
72135: PPUSH
72136: CALL_OW 448
72140: PUSH
72141: LD_VAR 0 3
72145: PPUSH
72146: LD_EXP 79
72150: PUSH
72151: LD_VAR 0 2
72155: ARRAY
72156: PUSH
72157: LD_INT 1
72159: ARRAY
72160: PUSH
72161: LD_INT 1
72163: ARRAY
72164: PUSH
72165: LD_EXP 79
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: PUSH
72176: LD_INT 1
72178: ARRAY
72179: PUSH
72180: LD_INT 2
72182: ARRAY
72183: PUSH
72184: LD_EXP 79
72188: PUSH
72189: LD_VAR 0 2
72193: ARRAY
72194: PUSH
72195: LD_INT 1
72197: ARRAY
72198: PUSH
72199: LD_INT 3
72201: ARRAY
72202: PUSH
72203: LD_EXP 79
72207: PUSH
72208: LD_VAR 0 2
72212: ARRAY
72213: PUSH
72214: LD_INT 1
72216: ARRAY
72217: PUSH
72218: LD_INT 4
72220: ARRAY
72221: PUSH
72222: EMPTY
72223: LIST
72224: LIST
72225: LIST
72226: LIST
72227: PPUSH
72228: CALL 27103 0 2
72232: AND
72233: IFFALSE 72371
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72235: LD_VAR 0 3
72239: PPUSH
72240: LD_EXP 79
72244: PUSH
72245: LD_VAR 0 2
72249: ARRAY
72250: PUSH
72251: LD_INT 1
72253: ARRAY
72254: PUSH
72255: LD_INT 1
72257: ARRAY
72258: PPUSH
72259: LD_EXP 79
72263: PUSH
72264: LD_VAR 0 2
72268: ARRAY
72269: PUSH
72270: LD_INT 1
72272: ARRAY
72273: PUSH
72274: LD_INT 2
72276: ARRAY
72277: PPUSH
72278: LD_EXP 79
72282: PUSH
72283: LD_VAR 0 2
72287: ARRAY
72288: PUSH
72289: LD_INT 1
72291: ARRAY
72292: PUSH
72293: LD_INT 3
72295: ARRAY
72296: PPUSH
72297: LD_EXP 79
72301: PUSH
72302: LD_VAR 0 2
72306: ARRAY
72307: PUSH
72308: LD_INT 1
72310: ARRAY
72311: PUSH
72312: LD_INT 4
72314: ARRAY
72315: PPUSH
72316: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72320: LD_ADDR_VAR 0 4
72324: PUSH
72325: LD_EXP 79
72329: PUSH
72330: LD_VAR 0 2
72334: ARRAY
72335: PPUSH
72336: LD_INT 1
72338: PPUSH
72339: CALL_OW 3
72343: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72344: LD_ADDR_EXP 79
72348: PUSH
72349: LD_EXP 79
72353: PPUSH
72354: LD_VAR 0 2
72358: PPUSH
72359: LD_VAR 0 4
72363: PPUSH
72364: CALL_OW 1
72368: ST_TO_ADDR
// break ;
72369: GO 72373
// end ; end ;
72371: GO 72017
72373: POP
72374: POP
// end ;
72375: GO 71949
72377: POP
72378: POP
// end ;
72379: LD_VAR 0 1
72383: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72384: LD_INT 0
72386: PPUSH
72387: PPUSH
72388: PPUSH
// if not mc_bases then
72389: LD_EXP 58
72393: NOT
72394: IFFALSE 72398
// exit ;
72396: GO 72487
// for i = 1 to mc_bases do
72398: LD_ADDR_VAR 0 2
72402: PUSH
72403: DOUBLE
72404: LD_INT 1
72406: DEC
72407: ST_TO_ADDR
72408: LD_EXP 58
72412: PUSH
72413: FOR_TO
72414: IFFALSE 72485
// begin if mc_attack [ i ] then
72416: LD_EXP 78
72420: PUSH
72421: LD_VAR 0 2
72425: ARRAY
72426: IFFALSE 72483
// begin tmp := mc_attack [ i ] [ 1 ] ;
72428: LD_ADDR_VAR 0 3
72432: PUSH
72433: LD_EXP 78
72437: PUSH
72438: LD_VAR 0 2
72442: ARRAY
72443: PUSH
72444: LD_INT 1
72446: ARRAY
72447: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72448: LD_ADDR_EXP 78
72452: PUSH
72453: LD_EXP 78
72457: PPUSH
72458: LD_VAR 0 2
72462: PPUSH
72463: EMPTY
72464: PPUSH
72465: CALL_OW 1
72469: ST_TO_ADDR
// Attack ( tmp ) ;
72470: LD_VAR 0 3
72474: PPUSH
72475: CALL 49316 0 1
// exit ;
72479: POP
72480: POP
72481: GO 72487
// end ; end ;
72483: GO 72413
72485: POP
72486: POP
// end ;
72487: LD_VAR 0 1
72491: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72492: LD_INT 0
72494: PPUSH
72495: PPUSH
72496: PPUSH
72497: PPUSH
72498: PPUSH
72499: PPUSH
72500: PPUSH
// if not mc_bases then
72501: LD_EXP 58
72505: NOT
72506: IFFALSE 72510
// exit ;
72508: GO 73092
// for i = 1 to mc_bases do
72510: LD_ADDR_VAR 0 2
72514: PUSH
72515: DOUBLE
72516: LD_INT 1
72518: DEC
72519: ST_TO_ADDR
72520: LD_EXP 58
72524: PUSH
72525: FOR_TO
72526: IFFALSE 73090
// begin if not mc_bases [ i ] then
72528: LD_EXP 58
72532: PUSH
72533: LD_VAR 0 2
72537: ARRAY
72538: NOT
72539: IFFALSE 72543
// continue ;
72541: GO 72525
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72543: LD_ADDR_VAR 0 7
72547: PUSH
72548: LD_EXP 58
72552: PUSH
72553: LD_VAR 0 2
72557: ARRAY
72558: PUSH
72559: LD_INT 1
72561: ARRAY
72562: PPUSH
72563: CALL 17675 0 1
72567: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72568: LD_ADDR_EXP 81
72572: PUSH
72573: LD_EXP 81
72577: PPUSH
72578: LD_VAR 0 2
72582: PPUSH
72583: LD_EXP 58
72587: PUSH
72588: LD_VAR 0 2
72592: ARRAY
72593: PUSH
72594: LD_INT 1
72596: ARRAY
72597: PPUSH
72598: CALL_OW 255
72602: PPUSH
72603: LD_EXP 83
72607: PUSH
72608: LD_VAR 0 2
72612: ARRAY
72613: PPUSH
72614: CALL 15593 0 2
72618: PPUSH
72619: CALL_OW 1
72623: ST_TO_ADDR
// if not mc_scan [ i ] then
72624: LD_EXP 81
72628: PUSH
72629: LD_VAR 0 2
72633: ARRAY
72634: NOT
72635: IFFALSE 72790
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72637: LD_ADDR_VAR 0 4
72641: PUSH
72642: LD_EXP 58
72646: PUSH
72647: LD_VAR 0 2
72651: ARRAY
72652: PPUSH
72653: LD_INT 2
72655: PUSH
72656: LD_INT 25
72658: PUSH
72659: LD_INT 5
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 25
72668: PUSH
72669: LD_INT 8
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 25
72678: PUSH
72679: LD_INT 9
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: EMPTY
72687: LIST
72688: LIST
72689: LIST
72690: LIST
72691: PPUSH
72692: CALL_OW 72
72696: ST_TO_ADDR
// if not tmp then
72697: LD_VAR 0 4
72701: NOT
72702: IFFALSE 72706
// continue ;
72704: GO 72525
// for j in tmp do
72706: LD_ADDR_VAR 0 3
72710: PUSH
72711: LD_VAR 0 4
72715: PUSH
72716: FOR_IN
72717: IFFALSE 72788
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72719: LD_VAR 0 3
72723: PPUSH
72724: CALL_OW 310
72728: PPUSH
72729: CALL_OW 266
72733: PUSH
72734: LD_INT 5
72736: EQUAL
72737: PUSH
72738: LD_VAR 0 3
72742: PPUSH
72743: CALL_OW 257
72747: PUSH
72748: LD_INT 1
72750: EQUAL
72751: AND
72752: PUSH
72753: LD_VAR 0 3
72757: PPUSH
72758: CALL_OW 459
72762: NOT
72763: AND
72764: PUSH
72765: LD_VAR 0 7
72769: AND
72770: IFFALSE 72786
// ComChangeProfession ( j , class ) ;
72772: LD_VAR 0 3
72776: PPUSH
72777: LD_VAR 0 7
72781: PPUSH
72782: CALL_OW 123
72786: GO 72716
72788: POP
72789: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72790: LD_EXP 81
72794: PUSH
72795: LD_VAR 0 2
72799: ARRAY
72800: PUSH
72801: LD_EXP 80
72805: PUSH
72806: LD_VAR 0 2
72810: ARRAY
72811: NOT
72812: AND
72813: PUSH
72814: LD_EXP 58
72818: PUSH
72819: LD_VAR 0 2
72823: ARRAY
72824: PPUSH
72825: LD_INT 30
72827: PUSH
72828: LD_INT 32
72830: PUSH
72831: EMPTY
72832: LIST
72833: LIST
72834: PPUSH
72835: CALL_OW 72
72839: NOT
72840: AND
72841: PUSH
72842: LD_EXP 58
72846: PUSH
72847: LD_VAR 0 2
72851: ARRAY
72852: PPUSH
72853: LD_INT 2
72855: PUSH
72856: LD_INT 30
72858: PUSH
72859: LD_INT 4
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 30
72868: PUSH
72869: LD_INT 5
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: EMPTY
72877: LIST
72878: LIST
72879: LIST
72880: PPUSH
72881: CALL_OW 72
72885: NOT
72886: AND
72887: IFFALSE 73019
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72889: LD_ADDR_VAR 0 4
72893: PUSH
72894: LD_EXP 58
72898: PUSH
72899: LD_VAR 0 2
72903: ARRAY
72904: PPUSH
72905: LD_INT 2
72907: PUSH
72908: LD_INT 25
72910: PUSH
72911: LD_INT 1
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 25
72920: PUSH
72921: LD_INT 5
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: PUSH
72928: LD_INT 25
72930: PUSH
72931: LD_INT 8
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: PUSH
72938: LD_INT 25
72940: PUSH
72941: LD_INT 9
72943: PUSH
72944: EMPTY
72945: LIST
72946: LIST
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: LIST
72952: LIST
72953: LIST
72954: PPUSH
72955: CALL_OW 72
72959: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72960: LD_ADDR_VAR 0 4
72964: PUSH
72965: LD_VAR 0 4
72969: PUSH
72970: LD_VAR 0 4
72974: PPUSH
72975: LD_INT 18
72977: PPUSH
72978: CALL 54099 0 2
72982: DIFF
72983: ST_TO_ADDR
// if tmp then
72984: LD_VAR 0 4
72988: IFFALSE 73019
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
72990: LD_VAR 0 2
72994: PPUSH
72995: LD_VAR 0 4
72999: PPUSH
73000: LD_EXP 83
73004: PUSH
73005: LD_VAR 0 2
73009: ARRAY
73010: PPUSH
73011: CALL 15628 0 3
// exit ;
73015: POP
73016: POP
73017: GO 73092
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73019: LD_EXP 81
73023: PUSH
73024: LD_VAR 0 2
73028: ARRAY
73029: PUSH
73030: LD_EXP 80
73034: PUSH
73035: LD_VAR 0 2
73039: ARRAY
73040: AND
73041: IFFALSE 73088
// begin tmp := mc_defender [ i ] ;
73043: LD_ADDR_VAR 0 4
73047: PUSH
73048: LD_EXP 80
73052: PUSH
73053: LD_VAR 0 2
73057: ARRAY
73058: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73059: LD_VAR 0 2
73063: PPUSH
73064: LD_VAR 0 4
73068: PPUSH
73069: LD_EXP 81
73073: PUSH
73074: LD_VAR 0 2
73078: ARRAY
73079: PPUSH
73080: CALL 16126 0 3
// exit ;
73084: POP
73085: POP
73086: GO 73092
// end ; end ;
73088: GO 72525
73090: POP
73091: POP
// end ;
73092: LD_VAR 0 1
73096: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73097: LD_INT 0
73099: PPUSH
73100: PPUSH
73101: PPUSH
73102: PPUSH
73103: PPUSH
73104: PPUSH
73105: PPUSH
73106: PPUSH
73107: PPUSH
73108: PPUSH
73109: PPUSH
// if not mc_bases then
73110: LD_EXP 58
73114: NOT
73115: IFFALSE 73119
// exit ;
73117: GO 74206
// for i = 1 to mc_bases do
73119: LD_ADDR_VAR 0 2
73123: PUSH
73124: DOUBLE
73125: LD_INT 1
73127: DEC
73128: ST_TO_ADDR
73129: LD_EXP 58
73133: PUSH
73134: FOR_TO
73135: IFFALSE 74204
// begin tmp := mc_lab [ i ] ;
73137: LD_ADDR_VAR 0 6
73141: PUSH
73142: LD_EXP 91
73146: PUSH
73147: LD_VAR 0 2
73151: ARRAY
73152: ST_TO_ADDR
// if not tmp then
73153: LD_VAR 0 6
73157: NOT
73158: IFFALSE 73162
// continue ;
73160: GO 73134
// idle_lab := 0 ;
73162: LD_ADDR_VAR 0 11
73166: PUSH
73167: LD_INT 0
73169: ST_TO_ADDR
// for j in tmp do
73170: LD_ADDR_VAR 0 3
73174: PUSH
73175: LD_VAR 0 6
73179: PUSH
73180: FOR_IN
73181: IFFALSE 74200
// begin researching := false ;
73183: LD_ADDR_VAR 0 10
73187: PUSH
73188: LD_INT 0
73190: ST_TO_ADDR
// side := GetSide ( j ) ;
73191: LD_ADDR_VAR 0 4
73195: PUSH
73196: LD_VAR 0 3
73200: PPUSH
73201: CALL_OW 255
73205: ST_TO_ADDR
// if not mc_tech [ side ] then
73206: LD_EXP 85
73210: PUSH
73211: LD_VAR 0 4
73215: ARRAY
73216: NOT
73217: IFFALSE 73221
// continue ;
73219: GO 73180
// if BuildingStatus ( j ) = bs_idle then
73221: LD_VAR 0 3
73225: PPUSH
73226: CALL_OW 461
73230: PUSH
73231: LD_INT 2
73233: EQUAL
73234: IFFALSE 73422
// begin if idle_lab and UnitsInside ( j ) < 6 then
73236: LD_VAR 0 11
73240: PUSH
73241: LD_VAR 0 3
73245: PPUSH
73246: CALL_OW 313
73250: PUSH
73251: LD_INT 6
73253: LESS
73254: AND
73255: IFFALSE 73326
// begin tmp2 := UnitsInside ( idle_lab ) ;
73257: LD_ADDR_VAR 0 9
73261: PUSH
73262: LD_VAR 0 11
73266: PPUSH
73267: CALL_OW 313
73271: ST_TO_ADDR
// if tmp2 then
73272: LD_VAR 0 9
73276: IFFALSE 73318
// for x in tmp2 do
73278: LD_ADDR_VAR 0 7
73282: PUSH
73283: LD_VAR 0 9
73287: PUSH
73288: FOR_IN
73289: IFFALSE 73316
// begin ComExitBuilding ( x ) ;
73291: LD_VAR 0 7
73295: PPUSH
73296: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73300: LD_VAR 0 7
73304: PPUSH
73305: LD_VAR 0 3
73309: PPUSH
73310: CALL_OW 180
// end ;
73314: GO 73288
73316: POP
73317: POP
// idle_lab := 0 ;
73318: LD_ADDR_VAR 0 11
73322: PUSH
73323: LD_INT 0
73325: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73326: LD_ADDR_VAR 0 5
73330: PUSH
73331: LD_EXP 85
73335: PUSH
73336: LD_VAR 0 4
73340: ARRAY
73341: PUSH
73342: FOR_IN
73343: IFFALSE 73403
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73345: LD_VAR 0 3
73349: PPUSH
73350: LD_VAR 0 5
73354: PPUSH
73355: CALL_OW 430
73359: PUSH
73360: LD_VAR 0 4
73364: PPUSH
73365: LD_VAR 0 5
73369: PPUSH
73370: CALL 14698 0 2
73374: AND
73375: IFFALSE 73401
// begin researching := true ;
73377: LD_ADDR_VAR 0 10
73381: PUSH
73382: LD_INT 1
73384: ST_TO_ADDR
// ComResearch ( j , t ) ;
73385: LD_VAR 0 3
73389: PPUSH
73390: LD_VAR 0 5
73394: PPUSH
73395: CALL_OW 124
// break ;
73399: GO 73403
// end ;
73401: GO 73342
73403: POP
73404: POP
// if not researching then
73405: LD_VAR 0 10
73409: NOT
73410: IFFALSE 73422
// idle_lab := j ;
73412: LD_ADDR_VAR 0 11
73416: PUSH
73417: LD_VAR 0 3
73421: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73422: LD_VAR 0 3
73426: PPUSH
73427: CALL_OW 461
73431: PUSH
73432: LD_INT 10
73434: EQUAL
73435: IFFALSE 74023
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73437: LD_EXP 87
73441: PUSH
73442: LD_VAR 0 2
73446: ARRAY
73447: NOT
73448: PUSH
73449: LD_EXP 88
73453: PUSH
73454: LD_VAR 0 2
73458: ARRAY
73459: NOT
73460: AND
73461: PUSH
73462: LD_EXP 85
73466: PUSH
73467: LD_VAR 0 4
73471: ARRAY
73472: PUSH
73473: LD_INT 1
73475: GREATER
73476: AND
73477: IFFALSE 73608
// begin ComCancel ( j ) ;
73479: LD_VAR 0 3
73483: PPUSH
73484: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73488: LD_ADDR_EXP 85
73492: PUSH
73493: LD_EXP 85
73497: PPUSH
73498: LD_VAR 0 4
73502: PPUSH
73503: LD_EXP 85
73507: PUSH
73508: LD_VAR 0 4
73512: ARRAY
73513: PPUSH
73514: LD_EXP 85
73518: PUSH
73519: LD_VAR 0 4
73523: ARRAY
73524: PUSH
73525: LD_INT 1
73527: MINUS
73528: PPUSH
73529: LD_EXP 85
73533: PUSH
73534: LD_VAR 0 4
73538: ARRAY
73539: PPUSH
73540: LD_INT 0
73542: PPUSH
73543: CALL 20257 0 4
73547: PPUSH
73548: CALL_OW 1
73552: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73553: LD_ADDR_EXP 85
73557: PUSH
73558: LD_EXP 85
73562: PPUSH
73563: LD_VAR 0 4
73567: PPUSH
73568: LD_EXP 85
73572: PUSH
73573: LD_VAR 0 4
73577: ARRAY
73578: PPUSH
73579: LD_EXP 85
73583: PUSH
73584: LD_VAR 0 4
73588: ARRAY
73589: PPUSH
73590: LD_INT 1
73592: PPUSH
73593: LD_INT 0
73595: PPUSH
73596: CALL 20257 0 4
73600: PPUSH
73601: CALL_OW 1
73605: ST_TO_ADDR
// continue ;
73606: GO 73180
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73608: LD_EXP 87
73612: PUSH
73613: LD_VAR 0 2
73617: ARRAY
73618: PUSH
73619: LD_EXP 88
73623: PUSH
73624: LD_VAR 0 2
73628: ARRAY
73629: NOT
73630: AND
73631: IFFALSE 73758
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73633: LD_ADDR_EXP 88
73637: PUSH
73638: LD_EXP 88
73642: PPUSH
73643: LD_VAR 0 2
73647: PUSH
73648: LD_EXP 88
73652: PUSH
73653: LD_VAR 0 2
73657: ARRAY
73658: PUSH
73659: LD_INT 1
73661: PLUS
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PPUSH
73667: LD_EXP 87
73671: PUSH
73672: LD_VAR 0 2
73676: ARRAY
73677: PUSH
73678: LD_INT 1
73680: ARRAY
73681: PPUSH
73682: CALL 20839 0 3
73686: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73687: LD_EXP 87
73691: PUSH
73692: LD_VAR 0 2
73696: ARRAY
73697: PUSH
73698: LD_INT 1
73700: ARRAY
73701: PPUSH
73702: LD_INT 112
73704: PPUSH
73705: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73709: LD_ADDR_VAR 0 9
73713: PUSH
73714: LD_EXP 87
73718: PUSH
73719: LD_VAR 0 2
73723: ARRAY
73724: PPUSH
73725: LD_INT 1
73727: PPUSH
73728: CALL_OW 3
73732: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73733: LD_ADDR_EXP 87
73737: PUSH
73738: LD_EXP 87
73742: PPUSH
73743: LD_VAR 0 2
73747: PPUSH
73748: LD_VAR 0 9
73752: PPUSH
73753: CALL_OW 1
73757: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73758: LD_EXP 87
73762: PUSH
73763: LD_VAR 0 2
73767: ARRAY
73768: PUSH
73769: LD_EXP 88
73773: PUSH
73774: LD_VAR 0 2
73778: ARRAY
73779: AND
73780: PUSH
73781: LD_EXP 88
73785: PUSH
73786: LD_VAR 0 2
73790: ARRAY
73791: PUSH
73792: LD_INT 1
73794: ARRAY
73795: PPUSH
73796: CALL_OW 310
73800: NOT
73801: AND
73802: PUSH
73803: LD_VAR 0 3
73807: PPUSH
73808: CALL_OW 313
73812: PUSH
73813: LD_INT 6
73815: EQUAL
73816: AND
73817: IFFALSE 73873
// begin tmp2 := UnitsInside ( j ) ;
73819: LD_ADDR_VAR 0 9
73823: PUSH
73824: LD_VAR 0 3
73828: PPUSH
73829: CALL_OW 313
73833: ST_TO_ADDR
// if tmp2 = 6 then
73834: LD_VAR 0 9
73838: PUSH
73839: LD_INT 6
73841: EQUAL
73842: IFFALSE 73873
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73844: LD_VAR 0 9
73848: PUSH
73849: LD_INT 1
73851: ARRAY
73852: PPUSH
73853: LD_INT 112
73855: PPUSH
73856: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73860: LD_VAR 0 9
73864: PUSH
73865: LD_INT 1
73867: ARRAY
73868: PPUSH
73869: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73873: LD_EXP 88
73877: PUSH
73878: LD_VAR 0 2
73882: ARRAY
73883: PUSH
73884: LD_EXP 88
73888: PUSH
73889: LD_VAR 0 2
73893: ARRAY
73894: PUSH
73895: LD_INT 1
73897: ARRAY
73898: PPUSH
73899: CALL_OW 314
73903: NOT
73904: AND
73905: PUSH
73906: LD_EXP 88
73910: PUSH
73911: LD_VAR 0 2
73915: ARRAY
73916: PUSH
73917: LD_INT 1
73919: ARRAY
73920: PPUSH
73921: CALL_OW 310
73925: NOT
73926: AND
73927: IFFALSE 73953
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73929: LD_EXP 88
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: PUSH
73940: LD_INT 1
73942: ARRAY
73943: PPUSH
73944: LD_VAR 0 3
73948: PPUSH
73949: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73953: LD_EXP 88
73957: PUSH
73958: LD_VAR 0 2
73962: ARRAY
73963: PUSH
73964: LD_INT 1
73966: ARRAY
73967: PPUSH
73968: CALL_OW 310
73972: PUSH
73973: LD_EXP 88
73977: PUSH
73978: LD_VAR 0 2
73982: ARRAY
73983: PUSH
73984: LD_INT 1
73986: ARRAY
73987: PPUSH
73988: CALL_OW 310
73992: PPUSH
73993: CALL_OW 461
73997: PUSH
73998: LD_INT 3
74000: NONEQUAL
74001: AND
74002: IFFALSE 74023
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74004: LD_EXP 88
74008: PUSH
74009: LD_VAR 0 2
74013: ARRAY
74014: PUSH
74015: LD_INT 1
74017: ARRAY
74018: PPUSH
74019: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74023: LD_VAR 0 3
74027: PPUSH
74028: CALL_OW 461
74032: PUSH
74033: LD_INT 6
74035: EQUAL
74036: PUSH
74037: LD_VAR 0 6
74041: PUSH
74042: LD_INT 1
74044: GREATER
74045: AND
74046: IFFALSE 74198
// begin sci := [ ] ;
74048: LD_ADDR_VAR 0 8
74052: PUSH
74053: EMPTY
74054: ST_TO_ADDR
// for x in ( tmp diff j ) do
74055: LD_ADDR_VAR 0 7
74059: PUSH
74060: LD_VAR 0 6
74064: PUSH
74065: LD_VAR 0 3
74069: DIFF
74070: PUSH
74071: FOR_IN
74072: IFFALSE 74124
// begin if sci = 6 then
74074: LD_VAR 0 8
74078: PUSH
74079: LD_INT 6
74081: EQUAL
74082: IFFALSE 74086
// break ;
74084: GO 74124
// if BuildingStatus ( x ) = bs_idle then
74086: LD_VAR 0 7
74090: PPUSH
74091: CALL_OW 461
74095: PUSH
74096: LD_INT 2
74098: EQUAL
74099: IFFALSE 74122
// sci := sci ^ UnitsInside ( x ) ;
74101: LD_ADDR_VAR 0 8
74105: PUSH
74106: LD_VAR 0 8
74110: PUSH
74111: LD_VAR 0 7
74115: PPUSH
74116: CALL_OW 313
74120: ADD
74121: ST_TO_ADDR
// end ;
74122: GO 74071
74124: POP
74125: POP
// if not sci then
74126: LD_VAR 0 8
74130: NOT
74131: IFFALSE 74135
// continue ;
74133: GO 73180
// for x in sci do
74135: LD_ADDR_VAR 0 7
74139: PUSH
74140: LD_VAR 0 8
74144: PUSH
74145: FOR_IN
74146: IFFALSE 74196
// if IsInUnit ( x ) and not HasTask ( x ) then
74148: LD_VAR 0 7
74152: PPUSH
74153: CALL_OW 310
74157: PUSH
74158: LD_VAR 0 7
74162: PPUSH
74163: CALL_OW 314
74167: NOT
74168: AND
74169: IFFALSE 74194
// begin ComExitBuilding ( x ) ;
74171: LD_VAR 0 7
74175: PPUSH
74176: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74180: LD_VAR 0 7
74184: PPUSH
74185: LD_VAR 0 3
74189: PPUSH
74190: CALL_OW 180
// end ;
74194: GO 74145
74196: POP
74197: POP
// end ; end ;
74198: GO 73180
74200: POP
74201: POP
// end ;
74202: GO 73134
74204: POP
74205: POP
// end ;
74206: LD_VAR 0 1
74210: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74211: LD_INT 0
74213: PPUSH
74214: PPUSH
// if not mc_bases then
74215: LD_EXP 58
74219: NOT
74220: IFFALSE 74224
// exit ;
74222: GO 74305
// for i = 1 to mc_bases do
74224: LD_ADDR_VAR 0 2
74228: PUSH
74229: DOUBLE
74230: LD_INT 1
74232: DEC
74233: ST_TO_ADDR
74234: LD_EXP 58
74238: PUSH
74239: FOR_TO
74240: IFFALSE 74303
// if mc_mines [ i ] and mc_miners [ i ] then
74242: LD_EXP 71
74246: PUSH
74247: LD_VAR 0 2
74251: ARRAY
74252: PUSH
74253: LD_EXP 72
74257: PUSH
74258: LD_VAR 0 2
74262: ARRAY
74263: AND
74264: IFFALSE 74301
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74266: LD_EXP 72
74270: PUSH
74271: LD_VAR 0 2
74275: ARRAY
74276: PUSH
74277: LD_INT 1
74279: ARRAY
74280: PPUSH
74281: CALL_OW 255
74285: PPUSH
74286: LD_EXP 71
74290: PUSH
74291: LD_VAR 0 2
74295: ARRAY
74296: PPUSH
74297: CALL 17828 0 2
74301: GO 74239
74303: POP
74304: POP
// end ;
74305: LD_VAR 0 1
74309: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74310: LD_INT 0
74312: PPUSH
74313: PPUSH
74314: PPUSH
74315: PPUSH
74316: PPUSH
74317: PPUSH
74318: PPUSH
74319: PPUSH
// if not mc_bases or not mc_parking then
74320: LD_EXP 58
74324: NOT
74325: PUSH
74326: LD_EXP 82
74330: NOT
74331: OR
74332: IFFALSE 74336
// exit ;
74334: GO 75035
// for i = 1 to mc_bases do
74336: LD_ADDR_VAR 0 2
74340: PUSH
74341: DOUBLE
74342: LD_INT 1
74344: DEC
74345: ST_TO_ADDR
74346: LD_EXP 58
74350: PUSH
74351: FOR_TO
74352: IFFALSE 75033
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74354: LD_EXP 58
74358: PUSH
74359: LD_VAR 0 2
74363: ARRAY
74364: NOT
74365: PUSH
74366: LD_EXP 82
74370: PUSH
74371: LD_VAR 0 2
74375: ARRAY
74376: NOT
74377: OR
74378: IFFALSE 74382
// continue ;
74380: GO 74351
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74382: LD_ADDR_VAR 0 5
74386: PUSH
74387: LD_EXP 58
74391: PUSH
74392: LD_VAR 0 2
74396: ARRAY
74397: PUSH
74398: LD_INT 1
74400: ARRAY
74401: PPUSH
74402: CALL_OW 255
74406: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74407: LD_ADDR_VAR 0 6
74411: PUSH
74412: LD_EXP 58
74416: PUSH
74417: LD_VAR 0 2
74421: ARRAY
74422: PPUSH
74423: LD_INT 30
74425: PUSH
74426: LD_INT 3
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: PPUSH
74433: CALL_OW 72
74437: ST_TO_ADDR
// if not fac then
74438: LD_VAR 0 6
74442: NOT
74443: IFFALSE 74494
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74445: LD_ADDR_VAR 0 6
74449: PUSH
74450: LD_EXP 58
74454: PUSH
74455: LD_VAR 0 2
74459: ARRAY
74460: PPUSH
74461: LD_INT 2
74463: PUSH
74464: LD_INT 30
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 30
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: LIST
74488: PPUSH
74489: CALL_OW 72
74493: ST_TO_ADDR
// if not fac then
74494: LD_VAR 0 6
74498: NOT
74499: IFFALSE 74503
// continue ;
74501: GO 74351
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74503: LD_ADDR_VAR 0 7
74507: PUSH
74508: LD_EXP 82
74512: PUSH
74513: LD_VAR 0 2
74517: ARRAY
74518: PPUSH
74519: LD_INT 22
74521: PUSH
74522: LD_VAR 0 5
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 21
74533: PUSH
74534: LD_INT 2
74536: PUSH
74537: EMPTY
74538: LIST
74539: LIST
74540: PUSH
74541: LD_INT 3
74543: PUSH
74544: LD_INT 24
74546: PUSH
74547: LD_INT 1000
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: EMPTY
74559: LIST
74560: LIST
74561: LIST
74562: PPUSH
74563: CALL_OW 70
74567: ST_TO_ADDR
// for j in fac do
74568: LD_ADDR_VAR 0 3
74572: PUSH
74573: LD_VAR 0 6
74577: PUSH
74578: FOR_IN
74579: IFFALSE 74660
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74581: LD_ADDR_VAR 0 7
74585: PUSH
74586: LD_VAR 0 7
74590: PUSH
74591: LD_INT 22
74593: PUSH
74594: LD_VAR 0 5
74598: PUSH
74599: EMPTY
74600: LIST
74601: LIST
74602: PUSH
74603: LD_INT 91
74605: PUSH
74606: LD_VAR 0 3
74610: PUSH
74611: LD_INT 15
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: LIST
74618: PUSH
74619: LD_INT 21
74621: PUSH
74622: LD_INT 2
74624: PUSH
74625: EMPTY
74626: LIST
74627: LIST
74628: PUSH
74629: LD_INT 3
74631: PUSH
74632: LD_INT 24
74634: PUSH
74635: LD_INT 1000
74637: PUSH
74638: EMPTY
74639: LIST
74640: LIST
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: LIST
74650: LIST
74651: PPUSH
74652: CALL_OW 69
74656: UNION
74657: ST_TO_ADDR
74658: GO 74578
74660: POP
74661: POP
// if not vehs then
74662: LD_VAR 0 7
74666: NOT
74667: IFFALSE 74693
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74669: LD_ADDR_EXP 70
74673: PUSH
74674: LD_EXP 70
74678: PPUSH
74679: LD_VAR 0 2
74683: PPUSH
74684: EMPTY
74685: PPUSH
74686: CALL_OW 1
74690: ST_TO_ADDR
// continue ;
74691: GO 74351
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74693: LD_ADDR_VAR 0 8
74697: PUSH
74698: LD_EXP 58
74702: PUSH
74703: LD_VAR 0 2
74707: ARRAY
74708: PPUSH
74709: LD_INT 30
74711: PUSH
74712: LD_INT 3
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PPUSH
74719: CALL_OW 72
74723: ST_TO_ADDR
// if tmp then
74724: LD_VAR 0 8
74728: IFFALSE 74831
// begin for j in tmp do
74730: LD_ADDR_VAR 0 3
74734: PUSH
74735: LD_VAR 0 8
74739: PUSH
74740: FOR_IN
74741: IFFALSE 74829
// for k in UnitsInside ( j ) do
74743: LD_ADDR_VAR 0 4
74747: PUSH
74748: LD_VAR 0 3
74752: PPUSH
74753: CALL_OW 313
74757: PUSH
74758: FOR_IN
74759: IFFALSE 74825
// if k then
74761: LD_VAR 0 4
74765: IFFALSE 74823
// if not k in mc_repair_vehicle [ i ] then
74767: LD_VAR 0 4
74771: PUSH
74772: LD_EXP 70
74776: PUSH
74777: LD_VAR 0 2
74781: ARRAY
74782: IN
74783: NOT
74784: IFFALSE 74823
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74786: LD_ADDR_EXP 70
74790: PUSH
74791: LD_EXP 70
74795: PPUSH
74796: LD_VAR 0 2
74800: PPUSH
74801: LD_EXP 70
74805: PUSH
74806: LD_VAR 0 2
74810: ARRAY
74811: PUSH
74812: LD_VAR 0 4
74816: UNION
74817: PPUSH
74818: CALL_OW 1
74822: ST_TO_ADDR
74823: GO 74758
74825: POP
74826: POP
74827: GO 74740
74829: POP
74830: POP
// end ; if not mc_repair_vehicle [ i ] then
74831: LD_EXP 70
74835: PUSH
74836: LD_VAR 0 2
74840: ARRAY
74841: NOT
74842: IFFALSE 74846
// continue ;
74844: GO 74351
// for j in mc_repair_vehicle [ i ] do
74846: LD_ADDR_VAR 0 3
74850: PUSH
74851: LD_EXP 70
74855: PUSH
74856: LD_VAR 0 2
74860: ARRAY
74861: PUSH
74862: FOR_IN
74863: IFFALSE 75029
// begin if GetClass ( j ) <> 3 then
74865: LD_VAR 0 3
74869: PPUSH
74870: CALL_OW 257
74874: PUSH
74875: LD_INT 3
74877: NONEQUAL
74878: IFFALSE 74919
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74880: LD_ADDR_EXP 70
74884: PUSH
74885: LD_EXP 70
74889: PPUSH
74890: LD_VAR 0 2
74894: PPUSH
74895: LD_EXP 70
74899: PUSH
74900: LD_VAR 0 2
74904: ARRAY
74905: PUSH
74906: LD_VAR 0 3
74910: DIFF
74911: PPUSH
74912: CALL_OW 1
74916: ST_TO_ADDR
// continue ;
74917: GO 74862
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74919: LD_VAR 0 3
74923: PPUSH
74924: CALL_OW 311
74928: NOT
74929: PUSH
74930: LD_VAR 0 3
74934: PUSH
74935: LD_EXP 61
74939: PUSH
74940: LD_VAR 0 2
74944: ARRAY
74945: PUSH
74946: LD_INT 1
74948: ARRAY
74949: IN
74950: NOT
74951: AND
74952: PUSH
74953: LD_VAR 0 3
74957: PUSH
74958: LD_EXP 61
74962: PUSH
74963: LD_VAR 0 2
74967: ARRAY
74968: PUSH
74969: LD_INT 2
74971: ARRAY
74972: IN
74973: NOT
74974: AND
74975: IFFALSE 75027
// begin if IsInUnit ( j ) then
74977: LD_VAR 0 3
74981: PPUSH
74982: CALL_OW 310
74986: IFFALSE 74997
// ComExitBuilding ( j ) ;
74988: LD_VAR 0 3
74992: PPUSH
74993: CALL_OW 122
// if not HasTask ( j ) then
74997: LD_VAR 0 3
75001: PPUSH
75002: CALL_OW 314
75006: NOT
75007: IFFALSE 75027
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75009: LD_VAR 0 3
75013: PPUSH
75014: LD_VAR 0 7
75018: PUSH
75019: LD_INT 1
75021: ARRAY
75022: PPUSH
75023: CALL_OW 189
// end ; end ;
75027: GO 74862
75029: POP
75030: POP
// end ;
75031: GO 74351
75033: POP
75034: POP
// end ;
75035: LD_VAR 0 1
75039: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75040: LD_INT 0
75042: PPUSH
75043: PPUSH
75044: PPUSH
75045: PPUSH
75046: PPUSH
75047: PPUSH
75048: PPUSH
75049: PPUSH
75050: PPUSH
75051: PPUSH
75052: PPUSH
// if not mc_bases then
75053: LD_EXP 58
75057: NOT
75058: IFFALSE 75062
// exit ;
75060: GO 75864
// for i = 1 to mc_bases do
75062: LD_ADDR_VAR 0 2
75066: PUSH
75067: DOUBLE
75068: LD_INT 1
75070: DEC
75071: ST_TO_ADDR
75072: LD_EXP 58
75076: PUSH
75077: FOR_TO
75078: IFFALSE 75862
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75080: LD_EXP 86
75084: PUSH
75085: LD_VAR 0 2
75089: ARRAY
75090: NOT
75091: PUSH
75092: LD_EXP 61
75096: PUSH
75097: LD_VAR 0 2
75101: ARRAY
75102: PUSH
75103: LD_INT 1
75105: ARRAY
75106: OR
75107: PUSH
75108: LD_EXP 61
75112: PUSH
75113: LD_VAR 0 2
75117: ARRAY
75118: PUSH
75119: LD_INT 2
75121: ARRAY
75122: OR
75123: PUSH
75124: LD_EXP 84
75128: PUSH
75129: LD_VAR 0 2
75133: ARRAY
75134: PPUSH
75135: LD_INT 1
75137: PPUSH
75138: CALL_OW 325
75142: NOT
75143: OR
75144: PUSH
75145: LD_EXP 81
75149: PUSH
75150: LD_VAR 0 2
75154: ARRAY
75155: OR
75156: IFFALSE 75160
// continue ;
75158: GO 75077
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75160: LD_ADDR_VAR 0 8
75164: PUSH
75165: LD_EXP 58
75169: PUSH
75170: LD_VAR 0 2
75174: ARRAY
75175: PPUSH
75176: LD_INT 25
75178: PUSH
75179: LD_INT 4
75181: PUSH
75182: EMPTY
75183: LIST
75184: LIST
75185: PUSH
75186: LD_INT 50
75188: PUSH
75189: EMPTY
75190: LIST
75191: PUSH
75192: LD_INT 3
75194: PUSH
75195: LD_INT 60
75197: PUSH
75198: EMPTY
75199: LIST
75200: PUSH
75201: EMPTY
75202: LIST
75203: LIST
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: LIST
75209: PPUSH
75210: CALL_OW 72
75214: PUSH
75215: LD_EXP 62
75219: PUSH
75220: LD_VAR 0 2
75224: ARRAY
75225: DIFF
75226: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75227: LD_ADDR_VAR 0 9
75231: PUSH
75232: LD_EXP 58
75236: PUSH
75237: LD_VAR 0 2
75241: ARRAY
75242: PPUSH
75243: LD_INT 2
75245: PUSH
75246: LD_INT 30
75248: PUSH
75249: LD_INT 0
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: PUSH
75256: LD_INT 30
75258: PUSH
75259: LD_INT 1
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: LIST
75270: PPUSH
75271: CALL_OW 72
75275: ST_TO_ADDR
// if not tmp or not dep then
75276: LD_VAR 0 8
75280: NOT
75281: PUSH
75282: LD_VAR 0 9
75286: NOT
75287: OR
75288: IFFALSE 75292
// continue ;
75290: GO 75077
// side := GetSide ( tmp [ 1 ] ) ;
75292: LD_ADDR_VAR 0 11
75296: PUSH
75297: LD_VAR 0 8
75301: PUSH
75302: LD_INT 1
75304: ARRAY
75305: PPUSH
75306: CALL_OW 255
75310: ST_TO_ADDR
// dep := dep [ 1 ] ;
75311: LD_ADDR_VAR 0 9
75315: PUSH
75316: LD_VAR 0 9
75320: PUSH
75321: LD_INT 1
75323: ARRAY
75324: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75325: LD_ADDR_VAR 0 7
75329: PUSH
75330: LD_EXP 86
75334: PUSH
75335: LD_VAR 0 2
75339: ARRAY
75340: PPUSH
75341: LD_INT 22
75343: PUSH
75344: LD_INT 0
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: LD_INT 25
75353: PUSH
75354: LD_INT 12
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: PPUSH
75365: CALL_OW 70
75369: PUSH
75370: LD_INT 22
75372: PUSH
75373: LD_INT 0
75375: PUSH
75376: EMPTY
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 25
75382: PUSH
75383: LD_INT 12
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 91
75392: PUSH
75393: LD_VAR 0 9
75397: PUSH
75398: LD_INT 20
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: LIST
75405: PUSH
75406: EMPTY
75407: LIST
75408: LIST
75409: LIST
75410: PPUSH
75411: CALL_OW 69
75415: UNION
75416: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75417: LD_ADDR_VAR 0 10
75421: PUSH
75422: LD_EXP 86
75426: PUSH
75427: LD_VAR 0 2
75431: ARRAY
75432: PPUSH
75433: LD_INT 81
75435: PUSH
75436: LD_VAR 0 11
75440: PUSH
75441: EMPTY
75442: LIST
75443: LIST
75444: PPUSH
75445: CALL_OW 70
75449: ST_TO_ADDR
// if not apes or danger_at_area then
75450: LD_VAR 0 7
75454: NOT
75455: PUSH
75456: LD_VAR 0 10
75460: OR
75461: IFFALSE 75511
// begin if mc_taming [ i ] then
75463: LD_EXP 89
75467: PUSH
75468: LD_VAR 0 2
75472: ARRAY
75473: IFFALSE 75509
// begin MC_Reset ( i , 121 ) ;
75475: LD_VAR 0 2
75479: PPUSH
75480: LD_INT 121
75482: PPUSH
75483: CALL 60842 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75487: LD_ADDR_EXP 89
75491: PUSH
75492: LD_EXP 89
75496: PPUSH
75497: LD_VAR 0 2
75501: PPUSH
75502: EMPTY
75503: PPUSH
75504: CALL_OW 1
75508: ST_TO_ADDR
// end ; continue ;
75509: GO 75077
// end ; for j in tmp do
75511: LD_ADDR_VAR 0 3
75515: PUSH
75516: LD_VAR 0 8
75520: PUSH
75521: FOR_IN
75522: IFFALSE 75858
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75524: LD_VAR 0 3
75528: PUSH
75529: LD_EXP 89
75533: PUSH
75534: LD_VAR 0 2
75538: ARRAY
75539: IN
75540: NOT
75541: PUSH
75542: LD_EXP 89
75546: PUSH
75547: LD_VAR 0 2
75551: ARRAY
75552: PUSH
75553: LD_INT 3
75555: LESS
75556: AND
75557: IFFALSE 75615
// begin SetTag ( j , 121 ) ;
75559: LD_VAR 0 3
75563: PPUSH
75564: LD_INT 121
75566: PPUSH
75567: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75571: LD_ADDR_EXP 89
75575: PUSH
75576: LD_EXP 89
75580: PPUSH
75581: LD_VAR 0 2
75585: PUSH
75586: LD_EXP 89
75590: PUSH
75591: LD_VAR 0 2
75595: ARRAY
75596: PUSH
75597: LD_INT 1
75599: PLUS
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PPUSH
75605: LD_VAR 0 3
75609: PPUSH
75610: CALL 20839 0 3
75614: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75615: LD_VAR 0 3
75619: PUSH
75620: LD_EXP 89
75624: PUSH
75625: LD_VAR 0 2
75629: ARRAY
75630: IN
75631: IFFALSE 75856
// begin if GetClass ( j ) <> 4 then
75633: LD_VAR 0 3
75637: PPUSH
75638: CALL_OW 257
75642: PUSH
75643: LD_INT 4
75645: NONEQUAL
75646: IFFALSE 75699
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75648: LD_ADDR_EXP 89
75652: PUSH
75653: LD_EXP 89
75657: PPUSH
75658: LD_VAR 0 2
75662: PPUSH
75663: LD_EXP 89
75667: PUSH
75668: LD_VAR 0 2
75672: ARRAY
75673: PUSH
75674: LD_VAR 0 3
75678: DIFF
75679: PPUSH
75680: CALL_OW 1
75684: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75685: LD_VAR 0 3
75689: PPUSH
75690: LD_INT 0
75692: PPUSH
75693: CALL_OW 109
// continue ;
75697: GO 75521
// end ; if IsInUnit ( j ) then
75699: LD_VAR 0 3
75703: PPUSH
75704: CALL_OW 310
75708: IFFALSE 75719
// ComExitBuilding ( j ) ;
75710: LD_VAR 0 3
75714: PPUSH
75715: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75719: LD_ADDR_VAR 0 6
75723: PUSH
75724: LD_VAR 0 7
75728: PPUSH
75729: LD_VAR 0 3
75733: PPUSH
75734: CALL_OW 74
75738: ST_TO_ADDR
// if not ape then
75739: LD_VAR 0 6
75743: NOT
75744: IFFALSE 75748
// break ;
75746: GO 75858
// x := GetX ( ape ) ;
75748: LD_ADDR_VAR 0 4
75752: PUSH
75753: LD_VAR 0 6
75757: PPUSH
75758: CALL_OW 250
75762: ST_TO_ADDR
// y := GetY ( ape ) ;
75763: LD_ADDR_VAR 0 5
75767: PUSH
75768: LD_VAR 0 6
75772: PPUSH
75773: CALL_OW 251
75777: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75778: LD_VAR 0 4
75782: PPUSH
75783: LD_VAR 0 5
75787: PPUSH
75788: CALL_OW 488
75792: NOT
75793: PUSH
75794: LD_VAR 0 11
75798: PPUSH
75799: LD_VAR 0 4
75803: PPUSH
75804: LD_VAR 0 5
75808: PPUSH
75809: LD_INT 20
75811: PPUSH
75812: CALL 21735 0 4
75816: PUSH
75817: LD_INT 4
75819: ARRAY
75820: OR
75821: IFFALSE 75825
// break ;
75823: GO 75858
// if not HasTask ( j ) then
75825: LD_VAR 0 3
75829: PPUSH
75830: CALL_OW 314
75834: NOT
75835: IFFALSE 75856
// ComTameXY ( j , x , y ) ;
75837: LD_VAR 0 3
75841: PPUSH
75842: LD_VAR 0 4
75846: PPUSH
75847: LD_VAR 0 5
75851: PPUSH
75852: CALL_OW 131
// end ; end ;
75856: GO 75521
75858: POP
75859: POP
// end ;
75860: GO 75077
75862: POP
75863: POP
// end ;
75864: LD_VAR 0 1
75868: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75869: LD_INT 0
75871: PPUSH
75872: PPUSH
75873: PPUSH
75874: PPUSH
75875: PPUSH
75876: PPUSH
75877: PPUSH
75878: PPUSH
// if not mc_bases then
75879: LD_EXP 58
75883: NOT
75884: IFFALSE 75888
// exit ;
75886: GO 76514
// for i = 1 to mc_bases do
75888: LD_ADDR_VAR 0 2
75892: PUSH
75893: DOUBLE
75894: LD_INT 1
75896: DEC
75897: ST_TO_ADDR
75898: LD_EXP 58
75902: PUSH
75903: FOR_TO
75904: IFFALSE 76512
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75906: LD_EXP 87
75910: PUSH
75911: LD_VAR 0 2
75915: ARRAY
75916: NOT
75917: PUSH
75918: LD_EXP 87
75922: PUSH
75923: LD_VAR 0 2
75927: ARRAY
75928: PPUSH
75929: LD_INT 25
75931: PUSH
75932: LD_INT 12
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PPUSH
75939: CALL_OW 72
75943: NOT
75944: OR
75945: IFFALSE 75949
// continue ;
75947: GO 75903
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75949: LD_ADDR_VAR 0 5
75953: PUSH
75954: LD_EXP 87
75958: PUSH
75959: LD_VAR 0 2
75963: ARRAY
75964: PUSH
75965: LD_INT 1
75967: ARRAY
75968: PPUSH
75969: CALL_OW 255
75973: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75974: LD_VAR 0 5
75978: PPUSH
75979: LD_INT 2
75981: PPUSH
75982: CALL_OW 325
75986: IFFALSE 76239
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75988: LD_ADDR_VAR 0 4
75992: PUSH
75993: LD_EXP 87
75997: PUSH
75998: LD_VAR 0 2
76002: ARRAY
76003: PPUSH
76004: LD_INT 25
76006: PUSH
76007: LD_INT 16
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PPUSH
76014: CALL_OW 72
76018: ST_TO_ADDR
// if tmp < 6 then
76019: LD_VAR 0 4
76023: PUSH
76024: LD_INT 6
76026: LESS
76027: IFFALSE 76239
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76029: LD_ADDR_VAR 0 6
76033: PUSH
76034: LD_EXP 58
76038: PUSH
76039: LD_VAR 0 2
76043: ARRAY
76044: PPUSH
76045: LD_INT 2
76047: PUSH
76048: LD_INT 30
76050: PUSH
76051: LD_INT 0
76053: PUSH
76054: EMPTY
76055: LIST
76056: LIST
76057: PUSH
76058: LD_INT 30
76060: PUSH
76061: LD_INT 1
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PUSH
76068: EMPTY
76069: LIST
76070: LIST
76071: LIST
76072: PPUSH
76073: CALL_OW 72
76077: ST_TO_ADDR
// if depot then
76078: LD_VAR 0 6
76082: IFFALSE 76239
// begin selected := 0 ;
76084: LD_ADDR_VAR 0 7
76088: PUSH
76089: LD_INT 0
76091: ST_TO_ADDR
// for j in depot do
76092: LD_ADDR_VAR 0 3
76096: PUSH
76097: LD_VAR 0 6
76101: PUSH
76102: FOR_IN
76103: IFFALSE 76134
// begin if UnitsInside ( j ) < 6 then
76105: LD_VAR 0 3
76109: PPUSH
76110: CALL_OW 313
76114: PUSH
76115: LD_INT 6
76117: LESS
76118: IFFALSE 76132
// begin selected := j ;
76120: LD_ADDR_VAR 0 7
76124: PUSH
76125: LD_VAR 0 3
76129: ST_TO_ADDR
// break ;
76130: GO 76134
// end ; end ;
76132: GO 76102
76134: POP
76135: POP
// if selected then
76136: LD_VAR 0 7
76140: IFFALSE 76239
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76142: LD_ADDR_VAR 0 3
76146: PUSH
76147: LD_EXP 87
76151: PUSH
76152: LD_VAR 0 2
76156: ARRAY
76157: PPUSH
76158: LD_INT 25
76160: PUSH
76161: LD_INT 12
76163: PUSH
76164: EMPTY
76165: LIST
76166: LIST
76167: PPUSH
76168: CALL_OW 72
76172: PUSH
76173: FOR_IN
76174: IFFALSE 76237
// if not HasTask ( j ) then
76176: LD_VAR 0 3
76180: PPUSH
76181: CALL_OW 314
76185: NOT
76186: IFFALSE 76235
// begin if not IsInUnit ( j ) then
76188: LD_VAR 0 3
76192: PPUSH
76193: CALL_OW 310
76197: NOT
76198: IFFALSE 76214
// ComEnterUnit ( j , selected ) ;
76200: LD_VAR 0 3
76204: PPUSH
76205: LD_VAR 0 7
76209: PPUSH
76210: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76214: LD_VAR 0 3
76218: PPUSH
76219: LD_INT 16
76221: PPUSH
76222: CALL_OW 183
// AddComExitBuilding ( j ) ;
76226: LD_VAR 0 3
76230: PPUSH
76231: CALL_OW 182
// end ;
76235: GO 76173
76237: POP
76238: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76239: LD_VAR 0 5
76243: PPUSH
76244: LD_INT 11
76246: PPUSH
76247: CALL_OW 325
76251: IFFALSE 76510
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76253: LD_ADDR_VAR 0 4
76257: PUSH
76258: LD_EXP 87
76262: PUSH
76263: LD_VAR 0 2
76267: ARRAY
76268: PPUSH
76269: LD_INT 25
76271: PUSH
76272: LD_INT 16
76274: PUSH
76275: EMPTY
76276: LIST
76277: LIST
76278: PPUSH
76279: CALL_OW 72
76283: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76284: LD_VAR 0 4
76288: PUSH
76289: LD_INT 6
76291: GREATEREQUAL
76292: PUSH
76293: LD_VAR 0 5
76297: PPUSH
76298: LD_INT 2
76300: PPUSH
76301: CALL_OW 325
76305: NOT
76306: OR
76307: IFFALSE 76510
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76309: LD_ADDR_VAR 0 8
76313: PUSH
76314: LD_EXP 58
76318: PUSH
76319: LD_VAR 0 2
76323: ARRAY
76324: PPUSH
76325: LD_INT 2
76327: PUSH
76328: LD_INT 30
76330: PUSH
76331: LD_INT 4
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PUSH
76338: LD_INT 30
76340: PUSH
76341: LD_INT 5
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: PUSH
76348: EMPTY
76349: LIST
76350: LIST
76351: LIST
76352: PPUSH
76353: CALL_OW 72
76357: ST_TO_ADDR
// if barracks then
76358: LD_VAR 0 8
76362: IFFALSE 76510
// begin selected := 0 ;
76364: LD_ADDR_VAR 0 7
76368: PUSH
76369: LD_INT 0
76371: ST_TO_ADDR
// for j in barracks do
76372: LD_ADDR_VAR 0 3
76376: PUSH
76377: LD_VAR 0 8
76381: PUSH
76382: FOR_IN
76383: IFFALSE 76414
// begin if UnitsInside ( j ) < 6 then
76385: LD_VAR 0 3
76389: PPUSH
76390: CALL_OW 313
76394: PUSH
76395: LD_INT 6
76397: LESS
76398: IFFALSE 76412
// begin selected := j ;
76400: LD_ADDR_VAR 0 7
76404: PUSH
76405: LD_VAR 0 3
76409: ST_TO_ADDR
// break ;
76410: GO 76414
// end ; end ;
76412: GO 76382
76414: POP
76415: POP
// if selected then
76416: LD_VAR 0 7
76420: IFFALSE 76510
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76422: LD_ADDR_VAR 0 3
76426: PUSH
76427: LD_EXP 87
76431: PUSH
76432: LD_VAR 0 2
76436: ARRAY
76437: PPUSH
76438: LD_INT 25
76440: PUSH
76441: LD_INT 12
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PPUSH
76448: CALL_OW 72
76452: PUSH
76453: FOR_IN
76454: IFFALSE 76508
// if not IsInUnit ( j ) and not HasTask ( j ) then
76456: LD_VAR 0 3
76460: PPUSH
76461: CALL_OW 310
76465: NOT
76466: PUSH
76467: LD_VAR 0 3
76471: PPUSH
76472: CALL_OW 314
76476: NOT
76477: AND
76478: IFFALSE 76506
// begin ComEnterUnit ( j , selected ) ;
76480: LD_VAR 0 3
76484: PPUSH
76485: LD_VAR 0 7
76489: PPUSH
76490: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76494: LD_VAR 0 3
76498: PPUSH
76499: LD_INT 15
76501: PPUSH
76502: CALL_OW 183
// end ;
76506: GO 76453
76508: POP
76509: POP
// end ; end ; end ; end ; end ;
76510: GO 75903
76512: POP
76513: POP
// end ;
76514: LD_VAR 0 1
76518: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76519: LD_INT 0
76521: PPUSH
76522: PPUSH
76523: PPUSH
76524: PPUSH
// if not mc_bases then
76525: LD_EXP 58
76529: NOT
76530: IFFALSE 76534
// exit ;
76532: GO 76712
// for i = 1 to mc_bases do
76534: LD_ADDR_VAR 0 2
76538: PUSH
76539: DOUBLE
76540: LD_INT 1
76542: DEC
76543: ST_TO_ADDR
76544: LD_EXP 58
76548: PUSH
76549: FOR_TO
76550: IFFALSE 76710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76552: LD_ADDR_VAR 0 4
76556: PUSH
76557: LD_EXP 58
76561: PUSH
76562: LD_VAR 0 2
76566: ARRAY
76567: PPUSH
76568: LD_INT 25
76570: PUSH
76571: LD_INT 9
76573: PUSH
76574: EMPTY
76575: LIST
76576: LIST
76577: PPUSH
76578: CALL_OW 72
76582: ST_TO_ADDR
// if not tmp then
76583: LD_VAR 0 4
76587: NOT
76588: IFFALSE 76592
// continue ;
76590: GO 76549
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76592: LD_EXP 84
76596: PUSH
76597: LD_VAR 0 2
76601: ARRAY
76602: PPUSH
76603: LD_INT 29
76605: PPUSH
76606: CALL_OW 325
76610: NOT
76611: PUSH
76612: LD_EXP 84
76616: PUSH
76617: LD_VAR 0 2
76621: ARRAY
76622: PPUSH
76623: LD_INT 28
76625: PPUSH
76626: CALL_OW 325
76630: NOT
76631: AND
76632: IFFALSE 76636
// continue ;
76634: GO 76549
// for j in tmp do
76636: LD_ADDR_VAR 0 3
76640: PUSH
76641: LD_VAR 0 4
76645: PUSH
76646: FOR_IN
76647: IFFALSE 76706
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76649: LD_VAR 0 3
76653: PUSH
76654: LD_EXP 61
76658: PUSH
76659: LD_VAR 0 2
76663: ARRAY
76664: PUSH
76665: LD_INT 1
76667: ARRAY
76668: IN
76669: NOT
76670: PUSH
76671: LD_VAR 0 3
76675: PUSH
76676: LD_EXP 61
76680: PUSH
76681: LD_VAR 0 2
76685: ARRAY
76686: PUSH
76687: LD_INT 2
76689: ARRAY
76690: IN
76691: NOT
76692: AND
76693: IFFALSE 76704
// ComSpaceTimeShoot ( j ) ;
76695: LD_VAR 0 3
76699: PPUSH
76700: CALL 14789 0 1
76704: GO 76646
76706: POP
76707: POP
// end ;
76708: GO 76549
76710: POP
76711: POP
// end ;
76712: LD_VAR 0 1
76716: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76717: LD_INT 0
76719: PPUSH
76720: PPUSH
76721: PPUSH
76722: PPUSH
76723: PPUSH
76724: PPUSH
76725: PPUSH
76726: PPUSH
76727: PPUSH
// if not mc_bases then
76728: LD_EXP 58
76732: NOT
76733: IFFALSE 76737
// exit ;
76735: GO 77359
// for i = 1 to mc_bases do
76737: LD_ADDR_VAR 0 2
76741: PUSH
76742: DOUBLE
76743: LD_INT 1
76745: DEC
76746: ST_TO_ADDR
76747: LD_EXP 58
76751: PUSH
76752: FOR_TO
76753: IFFALSE 77357
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76755: LD_EXP 93
76759: PUSH
76760: LD_VAR 0 2
76764: ARRAY
76765: NOT
76766: PUSH
76767: LD_INT 38
76769: PPUSH
76770: LD_EXP 84
76774: PUSH
76775: LD_VAR 0 2
76779: ARRAY
76780: PPUSH
76781: CALL_OW 321
76785: PUSH
76786: LD_INT 2
76788: NONEQUAL
76789: OR
76790: IFFALSE 76794
// continue ;
76792: GO 76752
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76794: LD_ADDR_VAR 0 8
76798: PUSH
76799: LD_EXP 58
76803: PUSH
76804: LD_VAR 0 2
76808: ARRAY
76809: PPUSH
76810: LD_INT 30
76812: PUSH
76813: LD_INT 34
76815: PUSH
76816: EMPTY
76817: LIST
76818: LIST
76819: PPUSH
76820: CALL_OW 72
76824: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76825: LD_ADDR_VAR 0 9
76829: PUSH
76830: LD_EXP 58
76834: PUSH
76835: LD_VAR 0 2
76839: ARRAY
76840: PPUSH
76841: LD_INT 25
76843: PUSH
76844: LD_INT 4
76846: PUSH
76847: EMPTY
76848: LIST
76849: LIST
76850: PPUSH
76851: CALL_OW 72
76855: PPUSH
76856: LD_INT 0
76858: PPUSH
76859: CALL 54099 0 2
76863: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76864: LD_VAR 0 9
76868: NOT
76869: PUSH
76870: LD_VAR 0 8
76874: NOT
76875: OR
76876: PUSH
76877: LD_EXP 58
76881: PUSH
76882: LD_VAR 0 2
76886: ARRAY
76887: PPUSH
76888: LD_INT 124
76890: PPUSH
76891: CALL 54099 0 2
76895: OR
76896: IFFALSE 76900
// continue ;
76898: GO 76752
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76900: LD_EXP 94
76904: PUSH
76905: LD_VAR 0 2
76909: ARRAY
76910: PUSH
76911: LD_EXP 93
76915: PUSH
76916: LD_VAR 0 2
76920: ARRAY
76921: LESS
76922: PUSH
76923: LD_EXP 94
76927: PUSH
76928: LD_VAR 0 2
76932: ARRAY
76933: PUSH
76934: LD_VAR 0 8
76938: LESS
76939: AND
76940: IFFALSE 77355
// begin tmp := sci [ 1 ] ;
76942: LD_ADDR_VAR 0 7
76946: PUSH
76947: LD_VAR 0 9
76951: PUSH
76952: LD_INT 1
76954: ARRAY
76955: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76956: LD_VAR 0 7
76960: PPUSH
76961: LD_INT 124
76963: PPUSH
76964: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76968: LD_ADDR_VAR 0 3
76972: PUSH
76973: DOUBLE
76974: LD_EXP 93
76978: PUSH
76979: LD_VAR 0 2
76983: ARRAY
76984: INC
76985: ST_TO_ADDR
76986: LD_EXP 93
76990: PUSH
76991: LD_VAR 0 2
76995: ARRAY
76996: PUSH
76997: FOR_DOWNTO
76998: IFFALSE 77341
// begin if IsInUnit ( tmp ) then
77000: LD_VAR 0 7
77004: PPUSH
77005: CALL_OW 310
77009: IFFALSE 77020
// ComExitBuilding ( tmp ) ;
77011: LD_VAR 0 7
77015: PPUSH
77016: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77020: LD_INT 35
77022: PPUSH
77023: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77027: LD_VAR 0 7
77031: PPUSH
77032: CALL_OW 310
77036: NOT
77037: PUSH
77038: LD_VAR 0 7
77042: PPUSH
77043: CALL_OW 314
77047: NOT
77048: AND
77049: IFFALSE 77020
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77051: LD_ADDR_VAR 0 6
77055: PUSH
77056: LD_VAR 0 7
77060: PPUSH
77061: CALL_OW 250
77065: PUSH
77066: LD_VAR 0 7
77070: PPUSH
77071: CALL_OW 251
77075: PUSH
77076: EMPTY
77077: LIST
77078: LIST
77079: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77080: LD_INT 35
77082: PPUSH
77083: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77087: LD_ADDR_VAR 0 4
77091: PUSH
77092: LD_EXP 93
77096: PUSH
77097: LD_VAR 0 2
77101: ARRAY
77102: PUSH
77103: LD_VAR 0 3
77107: ARRAY
77108: PUSH
77109: LD_INT 1
77111: ARRAY
77112: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77113: LD_ADDR_VAR 0 5
77117: PUSH
77118: LD_EXP 93
77122: PUSH
77123: LD_VAR 0 2
77127: ARRAY
77128: PUSH
77129: LD_VAR 0 3
77133: ARRAY
77134: PUSH
77135: LD_INT 2
77137: ARRAY
77138: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77139: LD_VAR 0 7
77143: PPUSH
77144: LD_INT 10
77146: PPUSH
77147: CALL 23432 0 2
77151: PUSH
77152: LD_INT 4
77154: ARRAY
77155: IFFALSE 77193
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77157: LD_VAR 0 7
77161: PPUSH
77162: LD_VAR 0 6
77166: PUSH
77167: LD_INT 1
77169: ARRAY
77170: PPUSH
77171: LD_VAR 0 6
77175: PUSH
77176: LD_INT 2
77178: ARRAY
77179: PPUSH
77180: CALL_OW 111
// wait ( 0 0$10 ) ;
77184: LD_INT 350
77186: PPUSH
77187: CALL_OW 67
// end else
77191: GO 77219
// begin ComMoveXY ( tmp , x , y ) ;
77193: LD_VAR 0 7
77197: PPUSH
77198: LD_VAR 0 4
77202: PPUSH
77203: LD_VAR 0 5
77207: PPUSH
77208: CALL_OW 111
// wait ( 0 0$3 ) ;
77212: LD_INT 105
77214: PPUSH
77215: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77219: LD_VAR 0 7
77223: PPUSH
77224: LD_VAR 0 4
77228: PPUSH
77229: LD_VAR 0 5
77233: PPUSH
77234: CALL_OW 307
77238: IFFALSE 77080
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77240: LD_VAR 0 7
77244: PPUSH
77245: LD_VAR 0 4
77249: PPUSH
77250: LD_VAR 0 5
77254: PPUSH
77255: LD_VAR 0 8
77259: PUSH
77260: LD_VAR 0 3
77264: ARRAY
77265: PPUSH
77266: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77270: LD_INT 35
77272: PPUSH
77273: CALL_OW 67
// until not HasTask ( tmp ) ;
77277: LD_VAR 0 7
77281: PPUSH
77282: CALL_OW 314
77286: NOT
77287: IFFALSE 77270
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77289: LD_ADDR_EXP 94
77293: PUSH
77294: LD_EXP 94
77298: PPUSH
77299: LD_VAR 0 2
77303: PUSH
77304: LD_EXP 94
77308: PUSH
77309: LD_VAR 0 2
77313: ARRAY
77314: PUSH
77315: LD_INT 1
77317: PLUS
77318: PUSH
77319: EMPTY
77320: LIST
77321: LIST
77322: PPUSH
77323: LD_VAR 0 8
77327: PUSH
77328: LD_VAR 0 3
77332: ARRAY
77333: PPUSH
77334: CALL 20839 0 3
77338: ST_TO_ADDR
// end ;
77339: GO 76997
77341: POP
77342: POP
// MC_Reset ( i , 124 ) ;
77343: LD_VAR 0 2
77347: PPUSH
77348: LD_INT 124
77350: PPUSH
77351: CALL 60842 0 2
// end ; end ;
77355: GO 76752
77357: POP
77358: POP
// end ;
77359: LD_VAR 0 1
77363: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77364: LD_INT 0
77366: PPUSH
77367: PPUSH
77368: PPUSH
// if not mc_bases then
77369: LD_EXP 58
77373: NOT
77374: IFFALSE 77378
// exit ;
77376: GO 77984
// for i = 1 to mc_bases do
77378: LD_ADDR_VAR 0 2
77382: PUSH
77383: DOUBLE
77384: LD_INT 1
77386: DEC
77387: ST_TO_ADDR
77388: LD_EXP 58
77392: PUSH
77393: FOR_TO
77394: IFFALSE 77982
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77396: LD_ADDR_VAR 0 3
77400: PUSH
77401: LD_EXP 58
77405: PUSH
77406: LD_VAR 0 2
77410: ARRAY
77411: PPUSH
77412: LD_INT 25
77414: PUSH
77415: LD_INT 4
77417: PUSH
77418: EMPTY
77419: LIST
77420: LIST
77421: PPUSH
77422: CALL_OW 72
77426: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77427: LD_VAR 0 3
77431: NOT
77432: PUSH
77433: LD_EXP 95
77437: PUSH
77438: LD_VAR 0 2
77442: ARRAY
77443: NOT
77444: OR
77445: PUSH
77446: LD_EXP 58
77450: PUSH
77451: LD_VAR 0 2
77455: ARRAY
77456: PPUSH
77457: LD_INT 2
77459: PUSH
77460: LD_INT 30
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 30
77472: PUSH
77473: LD_INT 1
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: LIST
77484: PPUSH
77485: CALL_OW 72
77489: NOT
77490: OR
77491: IFFALSE 77541
// begin if mc_deposits_finder [ i ] then
77493: LD_EXP 96
77497: PUSH
77498: LD_VAR 0 2
77502: ARRAY
77503: IFFALSE 77539
// begin MC_Reset ( i , 125 ) ;
77505: LD_VAR 0 2
77509: PPUSH
77510: LD_INT 125
77512: PPUSH
77513: CALL 60842 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77517: LD_ADDR_EXP 96
77521: PUSH
77522: LD_EXP 96
77526: PPUSH
77527: LD_VAR 0 2
77531: PPUSH
77532: EMPTY
77533: PPUSH
77534: CALL_OW 1
77538: ST_TO_ADDR
// end ; continue ;
77539: GO 77393
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77541: LD_EXP 95
77545: PUSH
77546: LD_VAR 0 2
77550: ARRAY
77551: PUSH
77552: LD_INT 1
77554: ARRAY
77555: PUSH
77556: LD_INT 3
77558: ARRAY
77559: PUSH
77560: LD_INT 1
77562: EQUAL
77563: PUSH
77564: LD_INT 20
77566: PPUSH
77567: LD_EXP 84
77571: PUSH
77572: LD_VAR 0 2
77576: ARRAY
77577: PPUSH
77578: CALL_OW 321
77582: PUSH
77583: LD_INT 2
77585: NONEQUAL
77586: AND
77587: IFFALSE 77637
// begin if mc_deposits_finder [ i ] then
77589: LD_EXP 96
77593: PUSH
77594: LD_VAR 0 2
77598: ARRAY
77599: IFFALSE 77635
// begin MC_Reset ( i , 125 ) ;
77601: LD_VAR 0 2
77605: PPUSH
77606: LD_INT 125
77608: PPUSH
77609: CALL 60842 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77613: LD_ADDR_EXP 96
77617: PUSH
77618: LD_EXP 96
77622: PPUSH
77623: LD_VAR 0 2
77627: PPUSH
77628: EMPTY
77629: PPUSH
77630: CALL_OW 1
77634: ST_TO_ADDR
// end ; continue ;
77635: GO 77393
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77637: LD_EXP 95
77641: PUSH
77642: LD_VAR 0 2
77646: ARRAY
77647: PUSH
77648: LD_INT 1
77650: ARRAY
77651: PUSH
77652: LD_INT 1
77654: ARRAY
77655: PPUSH
77656: LD_EXP 95
77660: PUSH
77661: LD_VAR 0 2
77665: ARRAY
77666: PUSH
77667: LD_INT 1
77669: ARRAY
77670: PUSH
77671: LD_INT 2
77673: ARRAY
77674: PPUSH
77675: LD_EXP 84
77679: PUSH
77680: LD_VAR 0 2
77684: ARRAY
77685: PPUSH
77686: CALL_OW 440
77690: IFFALSE 77733
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77692: LD_ADDR_EXP 95
77696: PUSH
77697: LD_EXP 95
77701: PPUSH
77702: LD_VAR 0 2
77706: PPUSH
77707: LD_EXP 95
77711: PUSH
77712: LD_VAR 0 2
77716: ARRAY
77717: PPUSH
77718: LD_INT 1
77720: PPUSH
77721: CALL_OW 3
77725: PPUSH
77726: CALL_OW 1
77730: ST_TO_ADDR
77731: GO 77980
// begin if not mc_deposits_finder [ i ] then
77733: LD_EXP 96
77737: PUSH
77738: LD_VAR 0 2
77742: ARRAY
77743: NOT
77744: IFFALSE 77796
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77746: LD_ADDR_EXP 96
77750: PUSH
77751: LD_EXP 96
77755: PPUSH
77756: LD_VAR 0 2
77760: PPUSH
77761: LD_VAR 0 3
77765: PUSH
77766: LD_INT 1
77768: ARRAY
77769: PUSH
77770: EMPTY
77771: LIST
77772: PPUSH
77773: CALL_OW 1
77777: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77778: LD_VAR 0 3
77782: PUSH
77783: LD_INT 1
77785: ARRAY
77786: PPUSH
77787: LD_INT 125
77789: PPUSH
77790: CALL_OW 109
// end else
77794: GO 77980
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77796: LD_EXP 96
77800: PUSH
77801: LD_VAR 0 2
77805: ARRAY
77806: PUSH
77807: LD_INT 1
77809: ARRAY
77810: PPUSH
77811: CALL_OW 310
77815: IFFALSE 77838
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77817: LD_EXP 96
77821: PUSH
77822: LD_VAR 0 2
77826: ARRAY
77827: PUSH
77828: LD_INT 1
77830: ARRAY
77831: PPUSH
77832: CALL_OW 122
77836: GO 77980
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77838: LD_EXP 96
77842: PUSH
77843: LD_VAR 0 2
77847: ARRAY
77848: PUSH
77849: LD_INT 1
77851: ARRAY
77852: PPUSH
77853: CALL_OW 314
77857: NOT
77858: PUSH
77859: LD_EXP 96
77863: PUSH
77864: LD_VAR 0 2
77868: ARRAY
77869: PUSH
77870: LD_INT 1
77872: ARRAY
77873: PPUSH
77874: LD_EXP 95
77878: PUSH
77879: LD_VAR 0 2
77883: ARRAY
77884: PUSH
77885: LD_INT 1
77887: ARRAY
77888: PUSH
77889: LD_INT 1
77891: ARRAY
77892: PPUSH
77893: LD_EXP 95
77897: PUSH
77898: LD_VAR 0 2
77902: ARRAY
77903: PUSH
77904: LD_INT 1
77906: ARRAY
77907: PUSH
77908: LD_INT 2
77910: ARRAY
77911: PPUSH
77912: CALL_OW 297
77916: PUSH
77917: LD_INT 6
77919: GREATER
77920: AND
77921: IFFALSE 77980
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77923: LD_EXP 96
77927: PUSH
77928: LD_VAR 0 2
77932: ARRAY
77933: PUSH
77934: LD_INT 1
77936: ARRAY
77937: PPUSH
77938: LD_EXP 95
77942: PUSH
77943: LD_VAR 0 2
77947: ARRAY
77948: PUSH
77949: LD_INT 1
77951: ARRAY
77952: PUSH
77953: LD_INT 1
77955: ARRAY
77956: PPUSH
77957: LD_EXP 95
77961: PUSH
77962: LD_VAR 0 2
77966: ARRAY
77967: PUSH
77968: LD_INT 1
77970: ARRAY
77971: PUSH
77972: LD_INT 2
77974: ARRAY
77975: PPUSH
77976: CALL_OW 111
// end ; end ; end ;
77980: GO 77393
77982: POP
77983: POP
// end ;
77984: LD_VAR 0 1
77988: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77989: LD_INT 0
77991: PPUSH
77992: PPUSH
77993: PPUSH
77994: PPUSH
77995: PPUSH
77996: PPUSH
77997: PPUSH
77998: PPUSH
77999: PPUSH
78000: PPUSH
78001: PPUSH
// if not mc_bases then
78002: LD_EXP 58
78006: NOT
78007: IFFALSE 78011
// exit ;
78009: GO 78735
// for i = 1 to mc_bases do
78011: LD_ADDR_VAR 0 2
78015: PUSH
78016: DOUBLE
78017: LD_INT 1
78019: DEC
78020: ST_TO_ADDR
78021: LD_EXP 58
78025: PUSH
78026: FOR_TO
78027: IFFALSE 78733
// begin if not mc_bases [ i ] then
78029: LD_EXP 58
78033: PUSH
78034: LD_VAR 0 2
78038: ARRAY
78039: NOT
78040: IFFALSE 78044
// continue ;
78042: GO 78026
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78044: LD_ADDR_VAR 0 7
78048: PUSH
78049: LD_EXP 58
78053: PUSH
78054: LD_VAR 0 2
78058: ARRAY
78059: PUSH
78060: LD_INT 1
78062: ARRAY
78063: PPUSH
78064: CALL_OW 248
78068: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78069: LD_VAR 0 7
78073: PUSH
78074: LD_INT 3
78076: EQUAL
78077: PUSH
78078: LD_EXP 77
78082: PUSH
78083: LD_VAR 0 2
78087: ARRAY
78088: PUSH
78089: LD_EXP 80
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: UNION
78100: PPUSH
78101: LD_INT 33
78103: PUSH
78104: LD_INT 2
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PPUSH
78111: CALL_OW 72
78115: NOT
78116: OR
78117: IFFALSE 78121
// continue ;
78119: GO 78026
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78121: LD_ADDR_VAR 0 9
78125: PUSH
78126: LD_EXP 58
78130: PUSH
78131: LD_VAR 0 2
78135: ARRAY
78136: PPUSH
78137: LD_INT 30
78139: PUSH
78140: LD_INT 36
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PPUSH
78147: CALL_OW 72
78151: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78152: LD_ADDR_VAR 0 10
78156: PUSH
78157: LD_EXP 77
78161: PUSH
78162: LD_VAR 0 2
78166: ARRAY
78167: PPUSH
78168: LD_INT 34
78170: PUSH
78171: LD_INT 31
78173: PUSH
78174: EMPTY
78175: LIST
78176: LIST
78177: PPUSH
78178: CALL_OW 72
78182: ST_TO_ADDR
// if not cts and not mcts then
78183: LD_VAR 0 9
78187: NOT
78188: PUSH
78189: LD_VAR 0 10
78193: NOT
78194: AND
78195: IFFALSE 78199
// continue ;
78197: GO 78026
// x := cts ;
78199: LD_ADDR_VAR 0 11
78203: PUSH
78204: LD_VAR 0 9
78208: ST_TO_ADDR
// if not x then
78209: LD_VAR 0 11
78213: NOT
78214: IFFALSE 78226
// x := mcts ;
78216: LD_ADDR_VAR 0 11
78220: PUSH
78221: LD_VAR 0 10
78225: ST_TO_ADDR
// if mc_remote_driver [ i ] then
78226: LD_EXP 98
78230: PUSH
78231: LD_VAR 0 2
78235: ARRAY
78236: IFFALSE 78505
// for j in mc_remote_driver [ i ] do
78238: LD_ADDR_VAR 0 3
78242: PUSH
78243: LD_EXP 98
78247: PUSH
78248: LD_VAR 0 2
78252: ARRAY
78253: PUSH
78254: FOR_IN
78255: IFFALSE 78503
// begin if GetClass ( j ) <> 3 then
78257: LD_VAR 0 3
78261: PPUSH
78262: CALL_OW 257
78266: PUSH
78267: LD_INT 3
78269: NONEQUAL
78270: IFFALSE 78323
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78272: LD_ADDR_EXP 98
78276: PUSH
78277: LD_EXP 98
78281: PPUSH
78282: LD_VAR 0 2
78286: PPUSH
78287: LD_EXP 98
78291: PUSH
78292: LD_VAR 0 2
78296: ARRAY
78297: PUSH
78298: LD_VAR 0 3
78302: DIFF
78303: PPUSH
78304: CALL_OW 1
78308: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78309: LD_VAR 0 3
78313: PPUSH
78314: LD_INT 0
78316: PPUSH
78317: CALL_OW 109
// continue ;
78321: GO 78254
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78323: LD_VAR 0 3
78327: PPUSH
78328: CALL_OW 310
78332: NOT
78333: PUSH
78334: LD_VAR 0 3
78338: PPUSH
78339: CALL_OW 310
78343: PPUSH
78344: CALL_OW 266
78348: PUSH
78349: LD_INT 36
78351: NONEQUAL
78352: PUSH
78353: LD_VAR 0 3
78357: PPUSH
78358: CALL 54187 0 1
78362: NOT
78363: AND
78364: OR
78365: IFFALSE 78501
// begin if IsInUnit ( j ) then
78367: LD_VAR 0 3
78371: PPUSH
78372: CALL_OW 310
78376: IFFALSE 78387
// ComExitBuilding ( j ) ;
78378: LD_VAR 0 3
78382: PPUSH
78383: CALL_OW 122
// ct := 0 ;
78387: LD_ADDR_VAR 0 8
78391: PUSH
78392: LD_INT 0
78394: ST_TO_ADDR
// for k in x do
78395: LD_ADDR_VAR 0 4
78399: PUSH
78400: LD_VAR 0 11
78404: PUSH
78405: FOR_IN
78406: IFFALSE 78479
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78408: LD_VAR 0 4
78412: PPUSH
78413: CALL_OW 264
78417: PUSH
78418: LD_INT 31
78420: EQUAL
78421: PUSH
78422: LD_VAR 0 4
78426: PPUSH
78427: CALL_OW 311
78431: NOT
78432: AND
78433: PUSH
78434: LD_VAR 0 4
78438: PPUSH
78439: CALL_OW 266
78443: PUSH
78444: LD_INT 36
78446: EQUAL
78447: PUSH
78448: LD_VAR 0 4
78452: PPUSH
78453: CALL_OW 313
78457: PUSH
78458: LD_INT 3
78460: LESS
78461: AND
78462: OR
78463: IFFALSE 78477
// begin ct := k ;
78465: LD_ADDR_VAR 0 8
78469: PUSH
78470: LD_VAR 0 4
78474: ST_TO_ADDR
// break ;
78475: GO 78479
// end ;
78477: GO 78405
78479: POP
78480: POP
// if ct then
78481: LD_VAR 0 8
78485: IFFALSE 78501
// ComEnterUnit ( j , ct ) ;
78487: LD_VAR 0 3
78491: PPUSH
78492: LD_VAR 0 8
78496: PPUSH
78497: CALL_OW 120
// end ; end ;
78501: GO 78254
78503: POP
78504: POP
// places := 0 ;
78505: LD_ADDR_VAR 0 5
78509: PUSH
78510: LD_INT 0
78512: ST_TO_ADDR
// for j = 1 to x do
78513: LD_ADDR_VAR 0 3
78517: PUSH
78518: DOUBLE
78519: LD_INT 1
78521: DEC
78522: ST_TO_ADDR
78523: LD_VAR 0 11
78527: PUSH
78528: FOR_TO
78529: IFFALSE 78584
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78531: LD_VAR 0 11
78535: PUSH
78536: LD_VAR 0 3
78540: ARRAY
78541: PPUSH
78542: CALL_OW 264
78546: PUSH
78547: LD_INT 31
78549: EQUAL
78550: IFFALSE 78568
// places := places + 1 else
78552: LD_ADDR_VAR 0 5
78556: PUSH
78557: LD_VAR 0 5
78561: PUSH
78562: LD_INT 1
78564: PLUS
78565: ST_TO_ADDR
78566: GO 78582
// places := places + 3 ;
78568: LD_ADDR_VAR 0 5
78572: PUSH
78573: LD_VAR 0 5
78577: PUSH
78578: LD_INT 3
78580: PLUS
78581: ST_TO_ADDR
78582: GO 78528
78584: POP
78585: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78586: LD_ADDR_VAR 0 6
78590: PUSH
78591: LD_EXP 58
78595: PUSH
78596: LD_VAR 0 2
78600: ARRAY
78601: PPUSH
78602: LD_INT 25
78604: PUSH
78605: LD_INT 3
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PPUSH
78612: CALL_OW 72
78616: PUSH
78617: LD_EXP 98
78621: PUSH
78622: LD_VAR 0 2
78626: ARRAY
78627: DIFF
78628: PPUSH
78629: LD_INT 3
78631: PPUSH
78632: CALL 55087 0 2
78636: ST_TO_ADDR
// if not tmp then
78637: LD_VAR 0 6
78641: NOT
78642: IFFALSE 78646
// continue ;
78644: GO 78026
// places := places - mc_remote_driver [ i ] ;
78646: LD_ADDR_VAR 0 5
78650: PUSH
78651: LD_VAR 0 5
78655: PUSH
78656: LD_EXP 98
78660: PUSH
78661: LD_VAR 0 2
78665: ARRAY
78666: MINUS
78667: ST_TO_ADDR
// if places then
78668: LD_VAR 0 5
78672: IFFALSE 78731
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78674: LD_ADDR_EXP 98
78678: PUSH
78679: LD_EXP 98
78683: PPUSH
78684: LD_VAR 0 2
78688: PPUSH
78689: LD_EXP 98
78693: PUSH
78694: LD_VAR 0 2
78698: ARRAY
78699: PUSH
78700: LD_VAR 0 6
78704: PUSH
78705: LD_INT 1
78707: ARRAY
78708: UNION
78709: PPUSH
78710: CALL_OW 1
78714: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78715: LD_VAR 0 6
78719: PUSH
78720: LD_INT 1
78722: ARRAY
78723: PPUSH
78724: LD_INT 126
78726: PPUSH
78727: CALL_OW 109
// end ; end ;
78731: GO 78026
78733: POP
78734: POP
// end ;
78735: LD_VAR 0 1
78739: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78740: LD_INT 0
78742: PPUSH
78743: PPUSH
78744: PPUSH
78745: PPUSH
78746: PPUSH
78747: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78748: LD_VAR 0 1
78752: NOT
78753: PUSH
78754: LD_VAR 0 2
78758: NOT
78759: OR
78760: PUSH
78761: LD_VAR 0 3
78765: NOT
78766: OR
78767: PUSH
78768: LD_VAR 0 4
78772: PUSH
78773: LD_INT 1
78775: PUSH
78776: LD_INT 2
78778: PUSH
78779: LD_INT 3
78781: PUSH
78782: LD_INT 4
78784: PUSH
78785: LD_INT 5
78787: PUSH
78788: LD_INT 8
78790: PUSH
78791: LD_INT 9
78793: PUSH
78794: LD_INT 15
78796: PUSH
78797: LD_INT 16
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: LIST
78804: LIST
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: IN
78811: NOT
78812: OR
78813: IFFALSE 78817
// exit ;
78815: GO 79717
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78817: LD_ADDR_VAR 0 2
78821: PUSH
78822: LD_VAR 0 2
78826: PPUSH
78827: LD_INT 21
78829: PUSH
78830: LD_INT 3
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 24
78839: PUSH
78840: LD_INT 250
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: EMPTY
78848: LIST
78849: LIST
78850: PPUSH
78851: CALL_OW 72
78855: ST_TO_ADDR
// case class of 1 , 15 :
78856: LD_VAR 0 4
78860: PUSH
78861: LD_INT 1
78863: DOUBLE
78864: EQUAL
78865: IFTRUE 78875
78867: LD_INT 15
78869: DOUBLE
78870: EQUAL
78871: IFTRUE 78875
78873: GO 78960
78875: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78876: LD_ADDR_VAR 0 8
78880: PUSH
78881: LD_VAR 0 2
78885: PPUSH
78886: LD_INT 2
78888: PUSH
78889: LD_INT 30
78891: PUSH
78892: LD_INT 32
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 30
78901: PUSH
78902: LD_INT 31
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: LIST
78913: PPUSH
78914: CALL_OW 72
78918: PUSH
78919: LD_VAR 0 2
78923: PPUSH
78924: LD_INT 2
78926: PUSH
78927: LD_INT 30
78929: PUSH
78930: LD_INT 4
78932: PUSH
78933: EMPTY
78934: LIST
78935: LIST
78936: PUSH
78937: LD_INT 30
78939: PUSH
78940: LD_INT 5
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: LIST
78951: PPUSH
78952: CALL_OW 72
78956: ADD
78957: ST_TO_ADDR
78958: GO 79206
78960: LD_INT 2
78962: DOUBLE
78963: EQUAL
78964: IFTRUE 78974
78966: LD_INT 16
78968: DOUBLE
78969: EQUAL
78970: IFTRUE 78974
78972: GO 79020
78974: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78975: LD_ADDR_VAR 0 8
78979: PUSH
78980: LD_VAR 0 2
78984: PPUSH
78985: LD_INT 2
78987: PUSH
78988: LD_INT 30
78990: PUSH
78991: LD_INT 0
78993: PUSH
78994: EMPTY
78995: LIST
78996: LIST
78997: PUSH
78998: LD_INT 30
79000: PUSH
79001: LD_INT 1
79003: PUSH
79004: EMPTY
79005: LIST
79006: LIST
79007: PUSH
79008: EMPTY
79009: LIST
79010: LIST
79011: LIST
79012: PPUSH
79013: CALL_OW 72
79017: ST_TO_ADDR
79018: GO 79206
79020: LD_INT 3
79022: DOUBLE
79023: EQUAL
79024: IFTRUE 79028
79026: GO 79074
79028: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79029: LD_ADDR_VAR 0 8
79033: PUSH
79034: LD_VAR 0 2
79038: PPUSH
79039: LD_INT 2
79041: PUSH
79042: LD_INT 30
79044: PUSH
79045: LD_INT 2
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 30
79054: PUSH
79055: LD_INT 3
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: LIST
79066: PPUSH
79067: CALL_OW 72
79071: ST_TO_ADDR
79072: GO 79206
79074: LD_INT 4
79076: DOUBLE
79077: EQUAL
79078: IFTRUE 79082
79080: GO 79139
79082: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79083: LD_ADDR_VAR 0 8
79087: PUSH
79088: LD_VAR 0 2
79092: PPUSH
79093: LD_INT 2
79095: PUSH
79096: LD_INT 30
79098: PUSH
79099: LD_INT 6
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 30
79108: PUSH
79109: LD_INT 7
79111: PUSH
79112: EMPTY
79113: LIST
79114: LIST
79115: PUSH
79116: LD_INT 30
79118: PUSH
79119: LD_INT 8
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: LIST
79130: LIST
79131: PPUSH
79132: CALL_OW 72
79136: ST_TO_ADDR
79137: GO 79206
79139: LD_INT 5
79141: DOUBLE
79142: EQUAL
79143: IFTRUE 79159
79145: LD_INT 8
79147: DOUBLE
79148: EQUAL
79149: IFTRUE 79159
79151: LD_INT 9
79153: DOUBLE
79154: EQUAL
79155: IFTRUE 79159
79157: GO 79205
79159: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79160: LD_ADDR_VAR 0 8
79164: PUSH
79165: LD_VAR 0 2
79169: PPUSH
79170: LD_INT 2
79172: PUSH
79173: LD_INT 30
79175: PUSH
79176: LD_INT 4
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 30
79185: PUSH
79186: LD_INT 5
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: LIST
79197: PPUSH
79198: CALL_OW 72
79202: ST_TO_ADDR
79203: GO 79206
79205: POP
// if not tmp then
79206: LD_VAR 0 8
79210: NOT
79211: IFFALSE 79215
// exit ;
79213: GO 79717
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79215: LD_VAR 0 4
79219: PUSH
79220: LD_INT 1
79222: PUSH
79223: LD_INT 15
79225: PUSH
79226: EMPTY
79227: LIST
79228: LIST
79229: IN
79230: PUSH
79231: LD_EXP 67
79235: PUSH
79236: LD_VAR 0 1
79240: ARRAY
79241: AND
79242: IFFALSE 79398
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79244: LD_ADDR_VAR 0 9
79248: PUSH
79249: LD_EXP 67
79253: PUSH
79254: LD_VAR 0 1
79258: ARRAY
79259: PUSH
79260: LD_INT 1
79262: ARRAY
79263: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79264: LD_VAR 0 9
79268: PUSH
79269: LD_EXP 68
79273: PUSH
79274: LD_VAR 0 1
79278: ARRAY
79279: IN
79280: NOT
79281: IFFALSE 79396
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79283: LD_ADDR_EXP 68
79287: PUSH
79288: LD_EXP 68
79292: PPUSH
79293: LD_VAR 0 1
79297: PUSH
79298: LD_EXP 68
79302: PUSH
79303: LD_VAR 0 1
79307: ARRAY
79308: PUSH
79309: LD_INT 1
79311: PLUS
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PPUSH
79317: LD_VAR 0 9
79321: PPUSH
79322: CALL 20839 0 3
79326: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79327: LD_ADDR_EXP 67
79331: PUSH
79332: LD_EXP 67
79336: PPUSH
79337: LD_VAR 0 1
79341: PPUSH
79342: LD_EXP 67
79346: PUSH
79347: LD_VAR 0 1
79351: ARRAY
79352: PUSH
79353: LD_VAR 0 9
79357: DIFF
79358: PPUSH
79359: CALL_OW 1
79363: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79364: LD_VAR 0 3
79368: PPUSH
79369: LD_EXP 68
79373: PUSH
79374: LD_VAR 0 1
79378: ARRAY
79379: PUSH
79380: LD_EXP 68
79384: PUSH
79385: LD_VAR 0 1
79389: ARRAY
79390: ARRAY
79391: PPUSH
79392: CALL_OW 120
// end ; exit ;
79396: GO 79717
// end ; if tmp > 1 then
79398: LD_VAR 0 8
79402: PUSH
79403: LD_INT 1
79405: GREATER
79406: IFFALSE 79510
// for i = 2 to tmp do
79408: LD_ADDR_VAR 0 6
79412: PUSH
79413: DOUBLE
79414: LD_INT 2
79416: DEC
79417: ST_TO_ADDR
79418: LD_VAR 0 8
79422: PUSH
79423: FOR_TO
79424: IFFALSE 79508
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79426: LD_VAR 0 8
79430: PUSH
79431: LD_VAR 0 6
79435: ARRAY
79436: PPUSH
79437: CALL_OW 461
79441: PUSH
79442: LD_INT 6
79444: EQUAL
79445: IFFALSE 79506
// begin x := tmp [ i ] ;
79447: LD_ADDR_VAR 0 9
79451: PUSH
79452: LD_VAR 0 8
79456: PUSH
79457: LD_VAR 0 6
79461: ARRAY
79462: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79463: LD_ADDR_VAR 0 8
79467: PUSH
79468: LD_VAR 0 8
79472: PPUSH
79473: LD_VAR 0 6
79477: PPUSH
79478: CALL_OW 3
79482: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79483: LD_ADDR_VAR 0 8
79487: PUSH
79488: LD_VAR 0 8
79492: PPUSH
79493: LD_INT 1
79495: PPUSH
79496: LD_VAR 0 9
79500: PPUSH
79501: CALL_OW 2
79505: ST_TO_ADDR
// end ;
79506: GO 79423
79508: POP
79509: POP
// for i in tmp do
79510: LD_ADDR_VAR 0 6
79514: PUSH
79515: LD_VAR 0 8
79519: PUSH
79520: FOR_IN
79521: IFFALSE 79590
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79523: LD_VAR 0 6
79527: PPUSH
79528: CALL_OW 313
79532: PUSH
79533: LD_INT 6
79535: LESS
79536: PUSH
79537: LD_VAR 0 6
79541: PPUSH
79542: CALL_OW 266
79546: PUSH
79547: LD_INT 31
79549: PUSH
79550: LD_INT 32
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: IN
79557: NOT
79558: AND
79559: PUSH
79560: LD_VAR 0 6
79564: PPUSH
79565: CALL_OW 313
79569: PUSH
79570: LD_INT 0
79572: EQUAL
79573: OR
79574: IFFALSE 79588
// begin j := i ;
79576: LD_ADDR_VAR 0 7
79580: PUSH
79581: LD_VAR 0 6
79585: ST_TO_ADDR
// break ;
79586: GO 79590
// end ; end ;
79588: GO 79520
79590: POP
79591: POP
// if j then
79592: LD_VAR 0 7
79596: IFFALSE 79614
// ComEnterUnit ( unit , j ) else
79598: LD_VAR 0 3
79602: PPUSH
79603: LD_VAR 0 7
79607: PPUSH
79608: CALL_OW 120
79612: GO 79717
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79614: LD_ADDR_VAR 0 10
79618: PUSH
79619: LD_VAR 0 2
79623: PPUSH
79624: LD_INT 2
79626: PUSH
79627: LD_INT 30
79629: PUSH
79630: LD_INT 0
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 30
79639: PUSH
79640: LD_INT 1
79642: PUSH
79643: EMPTY
79644: LIST
79645: LIST
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: LIST
79651: PPUSH
79652: CALL_OW 72
79656: ST_TO_ADDR
// if depot then
79657: LD_VAR 0 10
79661: IFFALSE 79717
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79663: LD_ADDR_VAR 0 10
79667: PUSH
79668: LD_VAR 0 10
79672: PPUSH
79673: LD_VAR 0 3
79677: PPUSH
79678: CALL_OW 74
79682: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79683: LD_VAR 0 3
79687: PPUSH
79688: LD_VAR 0 10
79692: PPUSH
79693: CALL_OW 296
79697: PUSH
79698: LD_INT 10
79700: GREATER
79701: IFFALSE 79717
// ComStandNearbyBuilding ( unit , depot ) ;
79703: LD_VAR 0 3
79707: PPUSH
79708: LD_VAR 0 10
79712: PPUSH
79713: CALL 15406 0 2
// end ; end ; end ;
79717: LD_VAR 0 5
79721: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79722: LD_INT 0
79724: PPUSH
79725: PPUSH
79726: PPUSH
79727: PPUSH
// if not mc_bases then
79728: LD_EXP 58
79732: NOT
79733: IFFALSE 79737
// exit ;
79735: GO 79976
// for i = 1 to mc_bases do
79737: LD_ADDR_VAR 0 2
79741: PUSH
79742: DOUBLE
79743: LD_INT 1
79745: DEC
79746: ST_TO_ADDR
79747: LD_EXP 58
79751: PUSH
79752: FOR_TO
79753: IFFALSE 79974
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79755: LD_ADDR_VAR 0 4
79759: PUSH
79760: LD_EXP 58
79764: PUSH
79765: LD_VAR 0 2
79769: ARRAY
79770: PPUSH
79771: LD_INT 21
79773: PUSH
79774: LD_INT 1
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PPUSH
79781: CALL_OW 72
79785: PUSH
79786: LD_EXP 87
79790: PUSH
79791: LD_VAR 0 2
79795: ARRAY
79796: UNION
79797: ST_TO_ADDR
// if not tmp then
79798: LD_VAR 0 4
79802: NOT
79803: IFFALSE 79807
// continue ;
79805: GO 79752
// for j in tmp do
79807: LD_ADDR_VAR 0 3
79811: PUSH
79812: LD_VAR 0 4
79816: PUSH
79817: FOR_IN
79818: IFFALSE 79970
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79820: LD_VAR 0 3
79824: PPUSH
79825: CALL_OW 110
79829: NOT
79830: PUSH
79831: LD_VAR 0 3
79835: PPUSH
79836: CALL_OW 314
79840: NOT
79841: AND
79842: PUSH
79843: LD_VAR 0 3
79847: PPUSH
79848: CALL_OW 311
79852: NOT
79853: AND
79854: PUSH
79855: LD_VAR 0 3
79859: PPUSH
79860: CALL_OW 310
79864: NOT
79865: AND
79866: PUSH
79867: LD_VAR 0 3
79871: PUSH
79872: LD_EXP 61
79876: PUSH
79877: LD_VAR 0 2
79881: ARRAY
79882: PUSH
79883: LD_INT 1
79885: ARRAY
79886: IN
79887: NOT
79888: AND
79889: PUSH
79890: LD_VAR 0 3
79894: PUSH
79895: LD_EXP 61
79899: PUSH
79900: LD_VAR 0 2
79904: ARRAY
79905: PUSH
79906: LD_INT 2
79908: ARRAY
79909: IN
79910: NOT
79911: AND
79912: PUSH
79913: LD_VAR 0 3
79917: PUSH
79918: LD_EXP 70
79922: PUSH
79923: LD_VAR 0 2
79927: ARRAY
79928: IN
79929: NOT
79930: AND
79931: IFFALSE 79968
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79933: LD_VAR 0 2
79937: PPUSH
79938: LD_EXP 58
79942: PUSH
79943: LD_VAR 0 2
79947: ARRAY
79948: PPUSH
79949: LD_VAR 0 3
79953: PPUSH
79954: LD_VAR 0 3
79958: PPUSH
79959: CALL_OW 257
79963: PPUSH
79964: CALL 78740 0 4
// end ;
79968: GO 79817
79970: POP
79971: POP
// end ;
79972: GO 79752
79974: POP
79975: POP
// end ;
79976: LD_VAR 0 1
79980: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79981: LD_INT 0
79983: PPUSH
79984: PPUSH
79985: PPUSH
79986: PPUSH
79987: PPUSH
79988: PPUSH
// if not mc_bases [ base ] then
79989: LD_EXP 58
79993: PUSH
79994: LD_VAR 0 1
79998: ARRAY
79999: NOT
80000: IFFALSE 80004
// exit ;
80002: GO 80186
// tmp := [ ] ;
80004: LD_ADDR_VAR 0 6
80008: PUSH
80009: EMPTY
80010: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80011: LD_ADDR_VAR 0 7
80015: PUSH
80016: LD_VAR 0 3
80020: PPUSH
80021: LD_INT 0
80023: PPUSH
80024: CALL_OW 517
80028: ST_TO_ADDR
// if not list then
80029: LD_VAR 0 7
80033: NOT
80034: IFFALSE 80038
// exit ;
80036: GO 80186
// for i = 1 to amount do
80038: LD_ADDR_VAR 0 5
80042: PUSH
80043: DOUBLE
80044: LD_INT 1
80046: DEC
80047: ST_TO_ADDR
80048: LD_VAR 0 2
80052: PUSH
80053: FOR_TO
80054: IFFALSE 80134
// begin x := rand ( 1 , list [ 1 ] ) ;
80056: LD_ADDR_VAR 0 8
80060: PUSH
80061: LD_INT 1
80063: PPUSH
80064: LD_VAR 0 7
80068: PUSH
80069: LD_INT 1
80071: ARRAY
80072: PPUSH
80073: CALL_OW 12
80077: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80078: LD_ADDR_VAR 0 6
80082: PUSH
80083: LD_VAR 0 6
80087: PPUSH
80088: LD_VAR 0 5
80092: PPUSH
80093: LD_VAR 0 7
80097: PUSH
80098: LD_INT 1
80100: ARRAY
80101: PUSH
80102: LD_VAR 0 8
80106: ARRAY
80107: PUSH
80108: LD_VAR 0 7
80112: PUSH
80113: LD_INT 2
80115: ARRAY
80116: PUSH
80117: LD_VAR 0 8
80121: ARRAY
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PPUSH
80127: CALL_OW 1
80131: ST_TO_ADDR
// end ;
80132: GO 80053
80134: POP
80135: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80136: LD_ADDR_EXP 71
80140: PUSH
80141: LD_EXP 71
80145: PPUSH
80146: LD_VAR 0 1
80150: PPUSH
80151: LD_VAR 0 6
80155: PPUSH
80156: CALL_OW 1
80160: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80161: LD_ADDR_EXP 73
80165: PUSH
80166: LD_EXP 73
80170: PPUSH
80171: LD_VAR 0 1
80175: PPUSH
80176: LD_VAR 0 3
80180: PPUSH
80181: CALL_OW 1
80185: ST_TO_ADDR
// end ;
80186: LD_VAR 0 4
80190: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80191: LD_INT 0
80193: PPUSH
// if not mc_bases [ base ] then
80194: LD_EXP 58
80198: PUSH
80199: LD_VAR 0 1
80203: ARRAY
80204: NOT
80205: IFFALSE 80209
// exit ;
80207: GO 80234
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80209: LD_ADDR_EXP 63
80213: PUSH
80214: LD_EXP 63
80218: PPUSH
80219: LD_VAR 0 1
80223: PPUSH
80224: LD_VAR 0 2
80228: PPUSH
80229: CALL_OW 1
80233: ST_TO_ADDR
// end ;
80234: LD_VAR 0 3
80238: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80239: LD_INT 0
80241: PPUSH
// if not mc_bases [ base ] then
80242: LD_EXP 58
80246: PUSH
80247: LD_VAR 0 1
80251: ARRAY
80252: NOT
80253: IFFALSE 80257
// exit ;
80255: GO 80294
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80257: LD_ADDR_EXP 63
80261: PUSH
80262: LD_EXP 63
80266: PPUSH
80267: LD_VAR 0 1
80271: PPUSH
80272: LD_EXP 63
80276: PUSH
80277: LD_VAR 0 1
80281: ARRAY
80282: PUSH
80283: LD_VAR 0 2
80287: UNION
80288: PPUSH
80289: CALL_OW 1
80293: ST_TO_ADDR
// end ;
80294: LD_VAR 0 3
80298: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80299: LD_INT 0
80301: PPUSH
// if not mc_bases [ base ] then
80302: LD_EXP 58
80306: PUSH
80307: LD_VAR 0 1
80311: ARRAY
80312: NOT
80313: IFFALSE 80317
// exit ;
80315: GO 80342
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80317: LD_ADDR_EXP 79
80321: PUSH
80322: LD_EXP 79
80326: PPUSH
80327: LD_VAR 0 1
80331: PPUSH
80332: LD_VAR 0 2
80336: PPUSH
80337: CALL_OW 1
80341: ST_TO_ADDR
// end ;
80342: LD_VAR 0 3
80346: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80347: LD_INT 0
80349: PPUSH
// if not mc_bases [ base ] then
80350: LD_EXP 58
80354: PUSH
80355: LD_VAR 0 1
80359: ARRAY
80360: NOT
80361: IFFALSE 80365
// exit ;
80363: GO 80402
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80365: LD_ADDR_EXP 79
80369: PUSH
80370: LD_EXP 79
80374: PPUSH
80375: LD_VAR 0 1
80379: PPUSH
80380: LD_EXP 79
80384: PUSH
80385: LD_VAR 0 1
80389: ARRAY
80390: PUSH
80391: LD_VAR 0 2
80395: ADD
80396: PPUSH
80397: CALL_OW 1
80401: ST_TO_ADDR
// end ;
80402: LD_VAR 0 3
80406: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80407: LD_INT 0
80409: PPUSH
// if not mc_bases [ base ] then
80410: LD_EXP 58
80414: PUSH
80415: LD_VAR 0 1
80419: ARRAY
80420: NOT
80421: IFFALSE 80425
// exit ;
80423: GO 80479
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80425: LD_ADDR_EXP 80
80429: PUSH
80430: LD_EXP 80
80434: PPUSH
80435: LD_VAR 0 1
80439: PPUSH
80440: LD_VAR 0 2
80444: PPUSH
80445: CALL_OW 1
80449: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80450: LD_ADDR_EXP 69
80454: PUSH
80455: LD_EXP 69
80459: PPUSH
80460: LD_VAR 0 1
80464: PPUSH
80465: LD_VAR 0 2
80469: PUSH
80470: LD_INT 0
80472: PLUS
80473: PPUSH
80474: CALL_OW 1
80478: ST_TO_ADDR
// end ;
80479: LD_VAR 0 3
80483: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80484: LD_INT 0
80486: PPUSH
// if not mc_bases [ base ] then
80487: LD_EXP 58
80491: PUSH
80492: LD_VAR 0 1
80496: ARRAY
80497: NOT
80498: IFFALSE 80502
// exit ;
80500: GO 80527
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80502: LD_ADDR_EXP 69
80506: PUSH
80507: LD_EXP 69
80511: PPUSH
80512: LD_VAR 0 1
80516: PPUSH
80517: LD_VAR 0 2
80521: PPUSH
80522: CALL_OW 1
80526: ST_TO_ADDR
// end ;
80527: LD_VAR 0 3
80531: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80532: LD_INT 0
80534: PPUSH
80535: PPUSH
80536: PPUSH
80537: PPUSH
// if not mc_bases [ base ] then
80538: LD_EXP 58
80542: PUSH
80543: LD_VAR 0 1
80547: ARRAY
80548: NOT
80549: IFFALSE 80553
// exit ;
80551: GO 80618
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80553: LD_ADDR_EXP 78
80557: PUSH
80558: LD_EXP 78
80562: PPUSH
80563: LD_VAR 0 1
80567: PUSH
80568: LD_EXP 78
80572: PUSH
80573: LD_VAR 0 1
80577: ARRAY
80578: PUSH
80579: LD_INT 1
80581: PLUS
80582: PUSH
80583: EMPTY
80584: LIST
80585: LIST
80586: PPUSH
80587: LD_VAR 0 1
80591: PUSH
80592: LD_VAR 0 2
80596: PUSH
80597: LD_VAR 0 3
80601: PUSH
80602: LD_VAR 0 4
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: PPUSH
80613: CALL 20839 0 3
80617: ST_TO_ADDR
// end ;
80618: LD_VAR 0 5
80622: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80623: LD_INT 0
80625: PPUSH
// if not mc_bases [ base ] then
80626: LD_EXP 58
80630: PUSH
80631: LD_VAR 0 1
80635: ARRAY
80636: NOT
80637: IFFALSE 80641
// exit ;
80639: GO 80666
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80641: LD_ADDR_EXP 95
80645: PUSH
80646: LD_EXP 95
80650: PPUSH
80651: LD_VAR 0 1
80655: PPUSH
80656: LD_VAR 0 2
80660: PPUSH
80661: CALL_OW 1
80665: ST_TO_ADDR
// end ;
80666: LD_VAR 0 3
80670: RET
// export function MC_GetMinesField ( base ) ; begin
80671: LD_INT 0
80673: PPUSH
// result := mc_mines [ base ] ;
80674: LD_ADDR_VAR 0 2
80678: PUSH
80679: LD_EXP 71
80683: PUSH
80684: LD_VAR 0 1
80688: ARRAY
80689: ST_TO_ADDR
// end ;
80690: LD_VAR 0 2
80694: RET
// export function MC_GetProduceList ( base ) ; begin
80695: LD_INT 0
80697: PPUSH
// result := mc_produce [ base ] ;
80698: LD_ADDR_VAR 0 2
80702: PUSH
80703: LD_EXP 79
80707: PUSH
80708: LD_VAR 0 1
80712: ARRAY
80713: ST_TO_ADDR
// end ;
80714: LD_VAR 0 2
80718: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80719: LD_INT 0
80721: PPUSH
80722: PPUSH
// if not mc_bases then
80723: LD_EXP 58
80727: NOT
80728: IFFALSE 80732
// exit ;
80730: GO 80797
// if mc_bases [ base ] then
80732: LD_EXP 58
80736: PUSH
80737: LD_VAR 0 1
80741: ARRAY
80742: IFFALSE 80797
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80744: LD_ADDR_VAR 0 3
80748: PUSH
80749: LD_EXP 58
80753: PUSH
80754: LD_VAR 0 1
80758: ARRAY
80759: PPUSH
80760: LD_INT 30
80762: PUSH
80763: LD_VAR 0 2
80767: PUSH
80768: EMPTY
80769: LIST
80770: LIST
80771: PPUSH
80772: CALL_OW 72
80776: ST_TO_ADDR
// if result then
80777: LD_VAR 0 3
80781: IFFALSE 80797
// result := result [ 1 ] ;
80783: LD_ADDR_VAR 0 3
80787: PUSH
80788: LD_VAR 0 3
80792: PUSH
80793: LD_INT 1
80795: ARRAY
80796: ST_TO_ADDR
// end ; end ;
80797: LD_VAR 0 3
80801: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
80802: LD_INT 0
80804: PPUSH
80805: PPUSH
// if not mc_bases then
80806: LD_EXP 58
80810: NOT
80811: IFFALSE 80815
// exit ;
80813: GO 80860
// if mc_bases [ base ] then
80815: LD_EXP 58
80819: PUSH
80820: LD_VAR 0 1
80824: ARRAY
80825: IFFALSE 80860
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80827: LD_ADDR_VAR 0 3
80831: PUSH
80832: LD_EXP 58
80836: PUSH
80837: LD_VAR 0 1
80841: ARRAY
80842: PPUSH
80843: LD_INT 30
80845: PUSH
80846: LD_VAR 0 2
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PPUSH
80855: CALL_OW 72
80859: ST_TO_ADDR
// end ;
80860: LD_VAR 0 3
80864: RET
// export function MC_SetTame ( base , area ) ; begin
80865: LD_INT 0
80867: PPUSH
// if not mc_bases or not base then
80868: LD_EXP 58
80872: NOT
80873: PUSH
80874: LD_VAR 0 1
80878: NOT
80879: OR
80880: IFFALSE 80884
// exit ;
80882: GO 80909
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80884: LD_ADDR_EXP 86
80888: PUSH
80889: LD_EXP 86
80893: PPUSH
80894: LD_VAR 0 1
80898: PPUSH
80899: LD_VAR 0 2
80903: PPUSH
80904: CALL_OW 1
80908: ST_TO_ADDR
// end ;
80909: LD_VAR 0 3
80913: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80914: LD_INT 0
80916: PPUSH
80917: PPUSH
// if not mc_bases or not base then
80918: LD_EXP 58
80922: NOT
80923: PUSH
80924: LD_VAR 0 1
80928: NOT
80929: OR
80930: IFFALSE 80934
// exit ;
80932: GO 81036
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80934: LD_ADDR_VAR 0 4
80938: PUSH
80939: LD_EXP 58
80943: PUSH
80944: LD_VAR 0 1
80948: ARRAY
80949: PPUSH
80950: LD_INT 30
80952: PUSH
80953: LD_VAR 0 2
80957: PUSH
80958: EMPTY
80959: LIST
80960: LIST
80961: PPUSH
80962: CALL_OW 72
80966: ST_TO_ADDR
// if not tmp then
80967: LD_VAR 0 4
80971: NOT
80972: IFFALSE 80976
// exit ;
80974: GO 81036
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80976: LD_ADDR_EXP 90
80980: PUSH
80981: LD_EXP 90
80985: PPUSH
80986: LD_VAR 0 1
80990: PPUSH
80991: LD_EXP 90
80995: PUSH
80996: LD_VAR 0 1
81000: ARRAY
81001: PPUSH
81002: LD_EXP 90
81006: PUSH
81007: LD_VAR 0 1
81011: ARRAY
81012: PUSH
81013: LD_INT 1
81015: PLUS
81016: PPUSH
81017: LD_VAR 0 4
81021: PUSH
81022: LD_INT 1
81024: ARRAY
81025: PPUSH
81026: CALL_OW 2
81030: PPUSH
81031: CALL_OW 1
81035: ST_TO_ADDR
// end ;
81036: LD_VAR 0 3
81040: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81041: LD_INT 0
81043: PPUSH
81044: PPUSH
// if not mc_bases or not base or not kinds then
81045: LD_EXP 58
81049: NOT
81050: PUSH
81051: LD_VAR 0 1
81055: NOT
81056: OR
81057: PUSH
81058: LD_VAR 0 2
81062: NOT
81063: OR
81064: IFFALSE 81068
// exit ;
81066: GO 81129
// for i in kinds do
81068: LD_ADDR_VAR 0 4
81072: PUSH
81073: LD_VAR 0 2
81077: PUSH
81078: FOR_IN
81079: IFFALSE 81127
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81081: LD_ADDR_EXP 92
81085: PUSH
81086: LD_EXP 92
81090: PPUSH
81091: LD_VAR 0 1
81095: PUSH
81096: LD_EXP 92
81100: PUSH
81101: LD_VAR 0 1
81105: ARRAY
81106: PUSH
81107: LD_INT 1
81109: PLUS
81110: PUSH
81111: EMPTY
81112: LIST
81113: LIST
81114: PPUSH
81115: LD_VAR 0 4
81119: PPUSH
81120: CALL 20839 0 3
81124: ST_TO_ADDR
81125: GO 81078
81127: POP
81128: POP
// end ;
81129: LD_VAR 0 3
81133: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81134: LD_INT 0
81136: PPUSH
// if not mc_bases or not base or not areas then
81137: LD_EXP 58
81141: NOT
81142: PUSH
81143: LD_VAR 0 1
81147: NOT
81148: OR
81149: PUSH
81150: LD_VAR 0 2
81154: NOT
81155: OR
81156: IFFALSE 81160
// exit ;
81158: GO 81185
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81160: LD_ADDR_EXP 76
81164: PUSH
81165: LD_EXP 76
81169: PPUSH
81170: LD_VAR 0 1
81174: PPUSH
81175: LD_VAR 0 2
81179: PPUSH
81180: CALL_OW 1
81184: ST_TO_ADDR
// end ;
81185: LD_VAR 0 3
81189: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81190: LD_INT 0
81192: PPUSH
// if not mc_bases or not base or not teleports_exit then
81193: LD_EXP 58
81197: NOT
81198: PUSH
81199: LD_VAR 0 1
81203: NOT
81204: OR
81205: PUSH
81206: LD_VAR 0 2
81210: NOT
81211: OR
81212: IFFALSE 81216
// exit ;
81214: GO 81241
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81216: LD_ADDR_EXP 93
81220: PUSH
81221: LD_EXP 93
81225: PPUSH
81226: LD_VAR 0 1
81230: PPUSH
81231: LD_VAR 0 2
81235: PPUSH
81236: CALL_OW 1
81240: ST_TO_ADDR
// end ;
81241: LD_VAR 0 3
81245: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81246: LD_INT 0
81248: PPUSH
81249: PPUSH
81250: PPUSH
// if not mc_bases or not base or not ext_list then
81251: LD_EXP 58
81255: NOT
81256: PUSH
81257: LD_VAR 0 1
81261: NOT
81262: OR
81263: PUSH
81264: LD_VAR 0 5
81268: NOT
81269: OR
81270: IFFALSE 81274
// exit ;
81272: GO 81447
// tmp := GetFacExtXYD ( x , y , d ) ;
81274: LD_ADDR_VAR 0 8
81278: PUSH
81279: LD_VAR 0 2
81283: PPUSH
81284: LD_VAR 0 3
81288: PPUSH
81289: LD_VAR 0 4
81293: PPUSH
81294: CALL 54217 0 3
81298: ST_TO_ADDR
// if not tmp then
81299: LD_VAR 0 8
81303: NOT
81304: IFFALSE 81308
// exit ;
81306: GO 81447
// for i in tmp do
81308: LD_ADDR_VAR 0 7
81312: PUSH
81313: LD_VAR 0 8
81317: PUSH
81318: FOR_IN
81319: IFFALSE 81445
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81321: LD_ADDR_EXP 63
81325: PUSH
81326: LD_EXP 63
81330: PPUSH
81331: LD_VAR 0 1
81335: PPUSH
81336: LD_EXP 63
81340: PUSH
81341: LD_VAR 0 1
81345: ARRAY
81346: PPUSH
81347: LD_EXP 63
81351: PUSH
81352: LD_VAR 0 1
81356: ARRAY
81357: PUSH
81358: LD_INT 1
81360: PLUS
81361: PPUSH
81362: LD_VAR 0 5
81366: PUSH
81367: LD_INT 1
81369: ARRAY
81370: PUSH
81371: LD_VAR 0 7
81375: PUSH
81376: LD_INT 1
81378: ARRAY
81379: PUSH
81380: LD_VAR 0 7
81384: PUSH
81385: LD_INT 2
81387: ARRAY
81388: PUSH
81389: LD_VAR 0 7
81393: PUSH
81394: LD_INT 3
81396: ARRAY
81397: PUSH
81398: EMPTY
81399: LIST
81400: LIST
81401: LIST
81402: LIST
81403: PPUSH
81404: CALL_OW 2
81408: PPUSH
81409: CALL_OW 1
81413: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81414: LD_ADDR_VAR 0 5
81418: PUSH
81419: LD_VAR 0 5
81423: PPUSH
81424: LD_INT 1
81426: PPUSH
81427: CALL_OW 3
81431: ST_TO_ADDR
// if not ext_list then
81432: LD_VAR 0 5
81436: NOT
81437: IFFALSE 81443
// exit ;
81439: POP
81440: POP
81441: GO 81447
// end ;
81443: GO 81318
81445: POP
81446: POP
// end ;
81447: LD_VAR 0 6
81451: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81452: LD_INT 0
81454: PPUSH
// if not mc_bases or not base or not weapon_list then
81455: LD_EXP 58
81459: NOT
81460: PUSH
81461: LD_VAR 0 1
81465: NOT
81466: OR
81467: PUSH
81468: LD_VAR 0 2
81472: NOT
81473: OR
81474: IFFALSE 81478
// exit ;
81476: GO 81503
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81478: LD_ADDR_EXP 97
81482: PUSH
81483: LD_EXP 97
81487: PPUSH
81488: LD_VAR 0 1
81492: PPUSH
81493: LD_VAR 0 2
81497: PPUSH
81498: CALL_OW 1
81502: ST_TO_ADDR
// end ;
81503: LD_VAR 0 3
81507: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81508: LD_INT 0
81510: PPUSH
// if not mc_bases or not base or not tech_list then
81511: LD_EXP 58
81515: NOT
81516: PUSH
81517: LD_VAR 0 1
81521: NOT
81522: OR
81523: PUSH
81524: LD_VAR 0 2
81528: NOT
81529: OR
81530: IFFALSE 81534
// exit ;
81532: GO 81559
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81534: LD_ADDR_EXP 85
81538: PUSH
81539: LD_EXP 85
81543: PPUSH
81544: LD_VAR 0 1
81548: PPUSH
81549: LD_VAR 0 2
81553: PPUSH
81554: CALL_OW 1
81558: ST_TO_ADDR
// end ;
81559: LD_VAR 0 3
81563: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81564: LD_INT 0
81566: PPUSH
// if not mc_bases or not parking_area or not base then
81567: LD_EXP 58
81571: NOT
81572: PUSH
81573: LD_VAR 0 2
81577: NOT
81578: OR
81579: PUSH
81580: LD_VAR 0 1
81584: NOT
81585: OR
81586: IFFALSE 81590
// exit ;
81588: GO 81615
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81590: LD_ADDR_EXP 82
81594: PUSH
81595: LD_EXP 82
81599: PPUSH
81600: LD_VAR 0 1
81604: PPUSH
81605: LD_VAR 0 2
81609: PPUSH
81610: CALL_OW 1
81614: ST_TO_ADDR
// end ;
81615: LD_VAR 0 3
81619: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81620: LD_INT 0
81622: PPUSH
// if not mc_bases or not base or not scan_area then
81623: LD_EXP 58
81627: NOT
81628: PUSH
81629: LD_VAR 0 1
81633: NOT
81634: OR
81635: PUSH
81636: LD_VAR 0 2
81640: NOT
81641: OR
81642: IFFALSE 81646
// exit ;
81644: GO 81671
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81646: LD_ADDR_EXP 83
81650: PUSH
81651: LD_EXP 83
81655: PPUSH
81656: LD_VAR 0 1
81660: PPUSH
81661: LD_VAR 0 2
81665: PPUSH
81666: CALL_OW 1
81670: ST_TO_ADDR
// end ;
81671: LD_VAR 0 3
81675: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81676: LD_INT 0
81678: PPUSH
81679: PPUSH
// if not mc_bases or not base then
81680: LD_EXP 58
81684: NOT
81685: PUSH
81686: LD_VAR 0 1
81690: NOT
81691: OR
81692: IFFALSE 81696
// exit ;
81694: GO 81760
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81696: LD_ADDR_VAR 0 3
81700: PUSH
81701: LD_INT 1
81703: PUSH
81704: LD_INT 2
81706: PUSH
81707: LD_INT 3
81709: PUSH
81710: LD_INT 4
81712: PUSH
81713: LD_INT 11
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: LIST
81720: LIST
81721: LIST
81722: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81723: LD_ADDR_EXP 85
81727: PUSH
81728: LD_EXP 85
81732: PPUSH
81733: LD_VAR 0 1
81737: PPUSH
81738: LD_EXP 85
81742: PUSH
81743: LD_VAR 0 1
81747: ARRAY
81748: PUSH
81749: LD_VAR 0 3
81753: DIFF
81754: PPUSH
81755: CALL_OW 1
81759: ST_TO_ADDR
// end ;
81760: LD_VAR 0 2
81764: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81765: LD_INT 0
81767: PPUSH
// result := mc_vehicles [ base ] ;
81768: LD_ADDR_VAR 0 3
81772: PUSH
81773: LD_EXP 77
81777: PUSH
81778: LD_VAR 0 1
81782: ARRAY
81783: ST_TO_ADDR
// if onlyCombat then
81784: LD_VAR 0 2
81788: IFFALSE 81953
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81790: LD_ADDR_VAR 0 3
81794: PUSH
81795: LD_VAR 0 3
81799: PUSH
81800: LD_VAR 0 3
81804: PPUSH
81805: LD_INT 2
81807: PUSH
81808: LD_INT 34
81810: PUSH
81811: LD_INT 12
81813: PUSH
81814: EMPTY
81815: LIST
81816: LIST
81817: PUSH
81818: LD_INT 34
81820: PUSH
81821: LD_INT 51
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 34
81830: PUSH
81831: LD_EXP 102
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 34
81842: PUSH
81843: LD_INT 32
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 34
81852: PUSH
81853: LD_INT 13
81855: PUSH
81856: EMPTY
81857: LIST
81858: LIST
81859: PUSH
81860: LD_INT 34
81862: PUSH
81863: LD_INT 52
81865: PUSH
81866: EMPTY
81867: LIST
81868: LIST
81869: PUSH
81870: LD_INT 34
81872: PUSH
81873: LD_INT 14
81875: PUSH
81876: EMPTY
81877: LIST
81878: LIST
81879: PUSH
81880: LD_INT 34
81882: PUSH
81883: LD_INT 53
81885: PUSH
81886: EMPTY
81887: LIST
81888: LIST
81889: PUSH
81890: LD_INT 34
81892: PUSH
81893: LD_EXP 101
81897: PUSH
81898: EMPTY
81899: LIST
81900: LIST
81901: PUSH
81902: LD_INT 34
81904: PUSH
81905: LD_INT 31
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: PUSH
81912: LD_INT 34
81914: PUSH
81915: LD_INT 48
81917: PUSH
81918: EMPTY
81919: LIST
81920: LIST
81921: PUSH
81922: LD_INT 34
81924: PUSH
81925: LD_INT 8
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: LIST
81946: PPUSH
81947: CALL_OW 72
81951: DIFF
81952: ST_TO_ADDR
// end ; end_of_file
81953: LD_VAR 0 3
81957: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81958: LD_INT 0
81960: PPUSH
81961: PPUSH
81962: PPUSH
// if not mc_bases or not skirmish then
81963: LD_EXP 58
81967: NOT
81968: PUSH
81969: LD_EXP 56
81973: NOT
81974: OR
81975: IFFALSE 81979
// exit ;
81977: GO 82144
// for i = 1 to mc_bases do
81979: LD_ADDR_VAR 0 4
81983: PUSH
81984: DOUBLE
81985: LD_INT 1
81987: DEC
81988: ST_TO_ADDR
81989: LD_EXP 58
81993: PUSH
81994: FOR_TO
81995: IFFALSE 82142
// begin if sci in mc_bases [ i ] then
81997: LD_VAR 0 2
82001: PUSH
82002: LD_EXP 58
82006: PUSH
82007: LD_VAR 0 4
82011: ARRAY
82012: IN
82013: IFFALSE 82140
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82015: LD_ADDR_EXP 87
82019: PUSH
82020: LD_EXP 87
82024: PPUSH
82025: LD_VAR 0 4
82029: PUSH
82030: LD_EXP 87
82034: PUSH
82035: LD_VAR 0 4
82039: ARRAY
82040: PUSH
82041: LD_INT 1
82043: PLUS
82044: PUSH
82045: EMPTY
82046: LIST
82047: LIST
82048: PPUSH
82049: LD_VAR 0 1
82053: PPUSH
82054: CALL 20839 0 3
82058: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82059: LD_ADDR_VAR 0 5
82063: PUSH
82064: LD_EXP 58
82068: PUSH
82069: LD_VAR 0 4
82073: ARRAY
82074: PPUSH
82075: LD_INT 2
82077: PUSH
82078: LD_INT 30
82080: PUSH
82081: LD_INT 0
82083: PUSH
82084: EMPTY
82085: LIST
82086: LIST
82087: PUSH
82088: LD_INT 30
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: EMPTY
82099: LIST
82100: LIST
82101: LIST
82102: PPUSH
82103: CALL_OW 72
82107: PPUSH
82108: LD_VAR 0 1
82112: PPUSH
82113: CALL_OW 74
82117: ST_TO_ADDR
// if tmp then
82118: LD_VAR 0 5
82122: IFFALSE 82138
// ComStandNearbyBuilding ( ape , tmp ) ;
82124: LD_VAR 0 1
82128: PPUSH
82129: LD_VAR 0 5
82133: PPUSH
82134: CALL 15406 0 2
// break ;
82138: GO 82142
// end ; end ;
82140: GO 81994
82142: POP
82143: POP
// end ;
82144: LD_VAR 0 3
82148: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82149: LD_INT 0
82151: PPUSH
82152: PPUSH
82153: PPUSH
// if not mc_bases or not skirmish then
82154: LD_EXP 58
82158: NOT
82159: PUSH
82160: LD_EXP 56
82164: NOT
82165: OR
82166: IFFALSE 82170
// exit ;
82168: GO 82259
// for i = 1 to mc_bases do
82170: LD_ADDR_VAR 0 4
82174: PUSH
82175: DOUBLE
82176: LD_INT 1
82178: DEC
82179: ST_TO_ADDR
82180: LD_EXP 58
82184: PUSH
82185: FOR_TO
82186: IFFALSE 82257
// begin if building in mc_busy_turret_list [ i ] then
82188: LD_VAR 0 1
82192: PUSH
82193: LD_EXP 68
82197: PUSH
82198: LD_VAR 0 4
82202: ARRAY
82203: IN
82204: IFFALSE 82255
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82206: LD_ADDR_VAR 0 5
82210: PUSH
82211: LD_EXP 68
82215: PUSH
82216: LD_VAR 0 4
82220: ARRAY
82221: PUSH
82222: LD_VAR 0 1
82226: DIFF
82227: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82228: LD_ADDR_EXP 68
82232: PUSH
82233: LD_EXP 68
82237: PPUSH
82238: LD_VAR 0 4
82242: PPUSH
82243: LD_VAR 0 5
82247: PPUSH
82248: CALL_OW 1
82252: ST_TO_ADDR
// break ;
82253: GO 82257
// end ; end ;
82255: GO 82185
82257: POP
82258: POP
// end ;
82259: LD_VAR 0 3
82263: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82264: LD_INT 0
82266: PPUSH
82267: PPUSH
82268: PPUSH
// if not mc_bases or not skirmish then
82269: LD_EXP 58
82273: NOT
82274: PUSH
82275: LD_EXP 56
82279: NOT
82280: OR
82281: IFFALSE 82285
// exit ;
82283: GO 82484
// for i = 1 to mc_bases do
82285: LD_ADDR_VAR 0 5
82289: PUSH
82290: DOUBLE
82291: LD_INT 1
82293: DEC
82294: ST_TO_ADDR
82295: LD_EXP 58
82299: PUSH
82300: FOR_TO
82301: IFFALSE 82482
// if building in mc_bases [ i ] then
82303: LD_VAR 0 1
82307: PUSH
82308: LD_EXP 58
82312: PUSH
82313: LD_VAR 0 5
82317: ARRAY
82318: IN
82319: IFFALSE 82480
// begin tmp := mc_bases [ i ] diff building ;
82321: LD_ADDR_VAR 0 6
82325: PUSH
82326: LD_EXP 58
82330: PUSH
82331: LD_VAR 0 5
82335: ARRAY
82336: PUSH
82337: LD_VAR 0 1
82341: DIFF
82342: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82343: LD_ADDR_EXP 58
82347: PUSH
82348: LD_EXP 58
82352: PPUSH
82353: LD_VAR 0 5
82357: PPUSH
82358: LD_VAR 0 6
82362: PPUSH
82363: CALL_OW 1
82367: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82368: LD_VAR 0 1
82372: PUSH
82373: LD_EXP 66
82377: PUSH
82378: LD_VAR 0 5
82382: ARRAY
82383: IN
82384: IFFALSE 82423
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82386: LD_ADDR_EXP 66
82390: PUSH
82391: LD_EXP 66
82395: PPUSH
82396: LD_VAR 0 5
82400: PPUSH
82401: LD_EXP 66
82405: PUSH
82406: LD_VAR 0 5
82410: ARRAY
82411: PUSH
82412: LD_VAR 0 1
82416: DIFF
82417: PPUSH
82418: CALL_OW 1
82422: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82423: LD_VAR 0 1
82427: PUSH
82428: LD_EXP 67
82432: PUSH
82433: LD_VAR 0 5
82437: ARRAY
82438: IN
82439: IFFALSE 82478
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82441: LD_ADDR_EXP 67
82445: PUSH
82446: LD_EXP 67
82450: PPUSH
82451: LD_VAR 0 5
82455: PPUSH
82456: LD_EXP 67
82460: PUSH
82461: LD_VAR 0 5
82465: ARRAY
82466: PUSH
82467: LD_VAR 0 1
82471: DIFF
82472: PPUSH
82473: CALL_OW 1
82477: ST_TO_ADDR
// break ;
82478: GO 82482
// end ;
82480: GO 82300
82482: POP
82483: POP
// end ;
82484: LD_VAR 0 4
82488: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82489: LD_INT 0
82491: PPUSH
82492: PPUSH
82493: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82494: LD_EXP 58
82498: NOT
82499: PUSH
82500: LD_EXP 56
82504: NOT
82505: OR
82506: PUSH
82507: LD_VAR 0 3
82511: PUSH
82512: LD_EXP 84
82516: IN
82517: NOT
82518: OR
82519: IFFALSE 82523
// exit ;
82521: GO 82646
// for i = 1 to mc_vehicles do
82523: LD_ADDR_VAR 0 6
82527: PUSH
82528: DOUBLE
82529: LD_INT 1
82531: DEC
82532: ST_TO_ADDR
82533: LD_EXP 77
82537: PUSH
82538: FOR_TO
82539: IFFALSE 82644
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82541: LD_VAR 0 2
82545: PUSH
82546: LD_EXP 77
82550: PUSH
82551: LD_VAR 0 6
82555: ARRAY
82556: IN
82557: PUSH
82558: LD_VAR 0 1
82562: PUSH
82563: LD_EXP 77
82567: PUSH
82568: LD_VAR 0 6
82572: ARRAY
82573: IN
82574: OR
82575: IFFALSE 82642
// begin tmp := mc_vehicles [ i ] diff old ;
82577: LD_ADDR_VAR 0 7
82581: PUSH
82582: LD_EXP 77
82586: PUSH
82587: LD_VAR 0 6
82591: ARRAY
82592: PUSH
82593: LD_VAR 0 2
82597: DIFF
82598: ST_TO_ADDR
// tmp := tmp diff new ;
82599: LD_ADDR_VAR 0 7
82603: PUSH
82604: LD_VAR 0 7
82608: PUSH
82609: LD_VAR 0 1
82613: DIFF
82614: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82615: LD_ADDR_EXP 77
82619: PUSH
82620: LD_EXP 77
82624: PPUSH
82625: LD_VAR 0 6
82629: PPUSH
82630: LD_VAR 0 7
82634: PPUSH
82635: CALL_OW 1
82639: ST_TO_ADDR
// break ;
82640: GO 82644
// end ;
82642: GO 82538
82644: POP
82645: POP
// end ;
82646: LD_VAR 0 5
82650: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82651: LD_INT 0
82653: PPUSH
82654: PPUSH
82655: PPUSH
82656: PPUSH
// if not mc_bases or not skirmish then
82657: LD_EXP 58
82661: NOT
82662: PUSH
82663: LD_EXP 56
82667: NOT
82668: OR
82669: IFFALSE 82673
// exit ;
82671: GO 83050
// side := GetSide ( vehicle ) ;
82673: LD_ADDR_VAR 0 5
82677: PUSH
82678: LD_VAR 0 1
82682: PPUSH
82683: CALL_OW 255
82687: ST_TO_ADDR
// for i = 1 to mc_bases do
82688: LD_ADDR_VAR 0 4
82692: PUSH
82693: DOUBLE
82694: LD_INT 1
82696: DEC
82697: ST_TO_ADDR
82698: LD_EXP 58
82702: PUSH
82703: FOR_TO
82704: IFFALSE 83048
// begin if factory in mc_bases [ i ] then
82706: LD_VAR 0 2
82710: PUSH
82711: LD_EXP 58
82715: PUSH
82716: LD_VAR 0 4
82720: ARRAY
82721: IN
82722: IFFALSE 83046
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82724: LD_EXP 80
82728: PUSH
82729: LD_VAR 0 4
82733: ARRAY
82734: PUSH
82735: LD_EXP 69
82739: PUSH
82740: LD_VAR 0 4
82744: ARRAY
82745: LESS
82746: PUSH
82747: LD_VAR 0 1
82751: PPUSH
82752: CALL_OW 264
82756: PUSH
82757: LD_INT 31
82759: PUSH
82760: LD_INT 32
82762: PUSH
82763: LD_INT 51
82765: PUSH
82766: LD_EXP 102
82770: PUSH
82771: LD_INT 12
82773: PUSH
82774: LD_INT 30
82776: PUSH
82777: LD_EXP 101
82781: PUSH
82782: LD_INT 11
82784: PUSH
82785: LD_INT 53
82787: PUSH
82788: LD_INT 14
82790: PUSH
82791: LD_EXP 105
82795: PUSH
82796: LD_INT 29
82798: PUSH
82799: LD_EXP 103
82803: PUSH
82804: LD_INT 13
82806: PUSH
82807: LD_INT 52
82809: PUSH
82810: LD_INT 48
82812: PUSH
82813: LD_INT 8
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: LIST
82820: LIST
82821: LIST
82822: LIST
82823: LIST
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: IN
82835: NOT
82836: AND
82837: IFFALSE 82885
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82839: LD_ADDR_EXP 80
82843: PUSH
82844: LD_EXP 80
82848: PPUSH
82849: LD_VAR 0 4
82853: PUSH
82854: LD_EXP 80
82858: PUSH
82859: LD_VAR 0 4
82863: ARRAY
82864: PUSH
82865: LD_INT 1
82867: PLUS
82868: PUSH
82869: EMPTY
82870: LIST
82871: LIST
82872: PPUSH
82873: LD_VAR 0 1
82877: PPUSH
82878: CALL 20839 0 3
82882: ST_TO_ADDR
82883: GO 82929
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82885: LD_ADDR_EXP 77
82889: PUSH
82890: LD_EXP 77
82894: PPUSH
82895: LD_VAR 0 4
82899: PUSH
82900: LD_EXP 77
82904: PUSH
82905: LD_VAR 0 4
82909: ARRAY
82910: PUSH
82911: LD_INT 1
82913: PLUS
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: PPUSH
82919: LD_VAR 0 1
82923: PPUSH
82924: CALL 20839 0 3
82928: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82929: LD_VAR 0 1
82933: PPUSH
82934: CALL_OW 263
82938: PUSH
82939: LD_INT 2
82941: EQUAL
82942: IFFALSE 82962
// begin repeat wait ( 0 0$1 ) ;
82944: LD_INT 35
82946: PPUSH
82947: CALL_OW 67
// until IsControledBy ( vehicle ) ;
82951: LD_VAR 0 1
82955: PPUSH
82956: CALL_OW 312
82960: IFFALSE 82944
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82962: LD_VAR 0 1
82966: PPUSH
82967: LD_EXP 82
82971: PUSH
82972: LD_VAR 0 4
82976: ARRAY
82977: PPUSH
82978: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82982: LD_VAR 0 1
82986: PPUSH
82987: CALL_OW 263
82991: PUSH
82992: LD_INT 1
82994: NONEQUAL
82995: IFFALSE 82999
// break ;
82997: GO 83048
// repeat wait ( 0 0$1 ) ;
82999: LD_INT 35
83001: PPUSH
83002: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83006: LD_VAR 0 1
83010: PPUSH
83011: LD_EXP 82
83015: PUSH
83016: LD_VAR 0 4
83020: ARRAY
83021: PPUSH
83022: CALL_OW 308
83026: IFFALSE 82999
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83028: LD_VAR 0 1
83032: PPUSH
83033: CALL_OW 311
83037: PPUSH
83038: CALL_OW 121
// exit ;
83042: POP
83043: POP
83044: GO 83050
// end ; end ;
83046: GO 82703
83048: POP
83049: POP
// end ;
83050: LD_VAR 0 3
83054: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83055: LD_INT 0
83057: PPUSH
83058: PPUSH
83059: PPUSH
83060: PPUSH
// if not mc_bases or not skirmish then
83061: LD_EXP 58
83065: NOT
83066: PUSH
83067: LD_EXP 56
83071: NOT
83072: OR
83073: IFFALSE 83077
// exit ;
83075: GO 83430
// repeat wait ( 0 0$1 ) ;
83077: LD_INT 35
83079: PPUSH
83080: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83084: LD_VAR 0 2
83088: PPUSH
83089: LD_VAR 0 3
83093: PPUSH
83094: CALL_OW 284
83098: IFFALSE 83077
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83100: LD_VAR 0 2
83104: PPUSH
83105: LD_VAR 0 3
83109: PPUSH
83110: CALL_OW 283
83114: PUSH
83115: LD_INT 4
83117: EQUAL
83118: IFFALSE 83122
// exit ;
83120: GO 83430
// for i = 1 to mc_bases do
83122: LD_ADDR_VAR 0 7
83126: PUSH
83127: DOUBLE
83128: LD_INT 1
83130: DEC
83131: ST_TO_ADDR
83132: LD_EXP 58
83136: PUSH
83137: FOR_TO
83138: IFFALSE 83428
// begin if mc_crates_area [ i ] then
83140: LD_EXP 76
83144: PUSH
83145: LD_VAR 0 7
83149: ARRAY
83150: IFFALSE 83261
// for j in mc_crates_area [ i ] do
83152: LD_ADDR_VAR 0 8
83156: PUSH
83157: LD_EXP 76
83161: PUSH
83162: LD_VAR 0 7
83166: ARRAY
83167: PUSH
83168: FOR_IN
83169: IFFALSE 83259
// if InArea ( x , y , j ) then
83171: LD_VAR 0 2
83175: PPUSH
83176: LD_VAR 0 3
83180: PPUSH
83181: LD_VAR 0 8
83185: PPUSH
83186: CALL_OW 309
83190: IFFALSE 83257
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83192: LD_ADDR_EXP 74
83196: PUSH
83197: LD_EXP 74
83201: PPUSH
83202: LD_VAR 0 7
83206: PUSH
83207: LD_EXP 74
83211: PUSH
83212: LD_VAR 0 7
83216: ARRAY
83217: PUSH
83218: LD_INT 1
83220: PLUS
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PPUSH
83226: LD_VAR 0 4
83230: PUSH
83231: LD_VAR 0 2
83235: PUSH
83236: LD_VAR 0 3
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: LIST
83245: PPUSH
83246: CALL 20839 0 3
83250: ST_TO_ADDR
// exit ;
83251: POP
83252: POP
83253: POP
83254: POP
83255: GO 83430
// end ;
83257: GO 83168
83259: POP
83260: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83261: LD_ADDR_VAR 0 9
83265: PUSH
83266: LD_EXP 58
83270: PUSH
83271: LD_VAR 0 7
83275: ARRAY
83276: PPUSH
83277: LD_INT 2
83279: PUSH
83280: LD_INT 30
83282: PUSH
83283: LD_INT 0
83285: PUSH
83286: EMPTY
83287: LIST
83288: LIST
83289: PUSH
83290: LD_INT 30
83292: PUSH
83293: LD_INT 1
83295: PUSH
83296: EMPTY
83297: LIST
83298: LIST
83299: PUSH
83300: EMPTY
83301: LIST
83302: LIST
83303: LIST
83304: PPUSH
83305: CALL_OW 72
83309: ST_TO_ADDR
// if not depot then
83310: LD_VAR 0 9
83314: NOT
83315: IFFALSE 83319
// continue ;
83317: GO 83137
// for j in depot do
83319: LD_ADDR_VAR 0 8
83323: PUSH
83324: LD_VAR 0 9
83328: PUSH
83329: FOR_IN
83330: IFFALSE 83424
// if GetDistUnitXY ( j , x , y ) < 30 then
83332: LD_VAR 0 8
83336: PPUSH
83337: LD_VAR 0 2
83341: PPUSH
83342: LD_VAR 0 3
83346: PPUSH
83347: CALL_OW 297
83351: PUSH
83352: LD_INT 30
83354: LESS
83355: IFFALSE 83422
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83357: LD_ADDR_EXP 74
83361: PUSH
83362: LD_EXP 74
83366: PPUSH
83367: LD_VAR 0 7
83371: PUSH
83372: LD_EXP 74
83376: PUSH
83377: LD_VAR 0 7
83381: ARRAY
83382: PUSH
83383: LD_INT 1
83385: PLUS
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: PPUSH
83391: LD_VAR 0 4
83395: PUSH
83396: LD_VAR 0 2
83400: PUSH
83401: LD_VAR 0 3
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: LIST
83410: PPUSH
83411: CALL 20839 0 3
83415: ST_TO_ADDR
// exit ;
83416: POP
83417: POP
83418: POP
83419: POP
83420: GO 83430
// end ;
83422: GO 83329
83424: POP
83425: POP
// end ;
83426: GO 83137
83428: POP
83429: POP
// end ;
83430: LD_VAR 0 6
83434: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83435: LD_INT 0
83437: PPUSH
83438: PPUSH
83439: PPUSH
83440: PPUSH
// if not mc_bases or not skirmish then
83441: LD_EXP 58
83445: NOT
83446: PUSH
83447: LD_EXP 56
83451: NOT
83452: OR
83453: IFFALSE 83457
// exit ;
83455: GO 83734
// side := GetSide ( lab ) ;
83457: LD_ADDR_VAR 0 4
83461: PUSH
83462: LD_VAR 0 2
83466: PPUSH
83467: CALL_OW 255
83471: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83472: LD_VAR 0 4
83476: PUSH
83477: LD_EXP 84
83481: IN
83482: NOT
83483: PUSH
83484: LD_EXP 85
83488: NOT
83489: OR
83490: PUSH
83491: LD_EXP 58
83495: NOT
83496: OR
83497: IFFALSE 83501
// exit ;
83499: GO 83734
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83501: LD_ADDR_EXP 85
83505: PUSH
83506: LD_EXP 85
83510: PPUSH
83511: LD_VAR 0 4
83515: PPUSH
83516: LD_EXP 85
83520: PUSH
83521: LD_VAR 0 4
83525: ARRAY
83526: PUSH
83527: LD_VAR 0 1
83531: DIFF
83532: PPUSH
83533: CALL_OW 1
83537: ST_TO_ADDR
// for i = 1 to mc_bases do
83538: LD_ADDR_VAR 0 5
83542: PUSH
83543: DOUBLE
83544: LD_INT 1
83546: DEC
83547: ST_TO_ADDR
83548: LD_EXP 58
83552: PUSH
83553: FOR_TO
83554: IFFALSE 83732
// begin if lab in mc_bases [ i ] then
83556: LD_VAR 0 2
83560: PUSH
83561: LD_EXP 58
83565: PUSH
83566: LD_VAR 0 5
83570: ARRAY
83571: IN
83572: IFFALSE 83730
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83574: LD_VAR 0 1
83578: PUSH
83579: LD_INT 11
83581: PUSH
83582: LD_INT 4
83584: PUSH
83585: LD_INT 3
83587: PUSH
83588: LD_INT 2
83590: PUSH
83591: EMPTY
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: IN
83597: PUSH
83598: LD_EXP 88
83602: PUSH
83603: LD_VAR 0 5
83607: ARRAY
83608: AND
83609: IFFALSE 83730
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83611: LD_ADDR_VAR 0 6
83615: PUSH
83616: LD_EXP 88
83620: PUSH
83621: LD_VAR 0 5
83625: ARRAY
83626: PUSH
83627: LD_INT 1
83629: ARRAY
83630: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83631: LD_ADDR_EXP 88
83635: PUSH
83636: LD_EXP 88
83640: PPUSH
83641: LD_VAR 0 5
83645: PPUSH
83646: EMPTY
83647: PPUSH
83648: CALL_OW 1
83652: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83653: LD_VAR 0 6
83657: PPUSH
83658: LD_INT 0
83660: PPUSH
83661: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83665: LD_VAR 0 6
83669: PPUSH
83670: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83674: LD_ADDR_EXP 87
83678: PUSH
83679: LD_EXP 87
83683: PPUSH
83684: LD_VAR 0 5
83688: PPUSH
83689: LD_EXP 87
83693: PUSH
83694: LD_VAR 0 5
83698: ARRAY
83699: PPUSH
83700: LD_INT 1
83702: PPUSH
83703: LD_VAR 0 6
83707: PPUSH
83708: CALL_OW 2
83712: PPUSH
83713: CALL_OW 1
83717: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83718: LD_VAR 0 5
83722: PPUSH
83723: LD_INT 112
83725: PPUSH
83726: CALL 60842 0 2
// end ; end ; end ;
83730: GO 83553
83732: POP
83733: POP
// end ;
83734: LD_VAR 0 3
83738: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83739: LD_INT 0
83741: PPUSH
83742: PPUSH
83743: PPUSH
83744: PPUSH
83745: PPUSH
83746: PPUSH
83747: PPUSH
83748: PPUSH
// if not mc_bases or not skirmish then
83749: LD_EXP 58
83753: NOT
83754: PUSH
83755: LD_EXP 56
83759: NOT
83760: OR
83761: IFFALSE 83765
// exit ;
83763: GO 85002
// for i = 1 to mc_bases do
83765: LD_ADDR_VAR 0 3
83769: PUSH
83770: DOUBLE
83771: LD_INT 1
83773: DEC
83774: ST_TO_ADDR
83775: LD_EXP 58
83779: PUSH
83780: FOR_TO
83781: IFFALSE 85000
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83783: LD_VAR 0 1
83787: PUSH
83788: LD_EXP 58
83792: PUSH
83793: LD_VAR 0 3
83797: ARRAY
83798: IN
83799: PUSH
83800: LD_VAR 0 1
83804: PUSH
83805: LD_EXP 65
83809: PUSH
83810: LD_VAR 0 3
83814: ARRAY
83815: IN
83816: OR
83817: PUSH
83818: LD_VAR 0 1
83822: PUSH
83823: LD_EXP 80
83827: PUSH
83828: LD_VAR 0 3
83832: ARRAY
83833: IN
83834: OR
83835: PUSH
83836: LD_VAR 0 1
83840: PUSH
83841: LD_EXP 77
83845: PUSH
83846: LD_VAR 0 3
83850: ARRAY
83851: IN
83852: OR
83853: PUSH
83854: LD_VAR 0 1
83858: PUSH
83859: LD_EXP 87
83863: PUSH
83864: LD_VAR 0 3
83868: ARRAY
83869: IN
83870: OR
83871: PUSH
83872: LD_VAR 0 1
83876: PUSH
83877: LD_EXP 88
83881: PUSH
83882: LD_VAR 0 3
83886: ARRAY
83887: IN
83888: OR
83889: IFFALSE 84998
// begin if un in mc_ape [ i ] then
83891: LD_VAR 0 1
83895: PUSH
83896: LD_EXP 87
83900: PUSH
83901: LD_VAR 0 3
83905: ARRAY
83906: IN
83907: IFFALSE 83946
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83909: LD_ADDR_EXP 87
83913: PUSH
83914: LD_EXP 87
83918: PPUSH
83919: LD_VAR 0 3
83923: PPUSH
83924: LD_EXP 87
83928: PUSH
83929: LD_VAR 0 3
83933: ARRAY
83934: PUSH
83935: LD_VAR 0 1
83939: DIFF
83940: PPUSH
83941: CALL_OW 1
83945: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83946: LD_VAR 0 1
83950: PUSH
83951: LD_EXP 88
83955: PUSH
83956: LD_VAR 0 3
83960: ARRAY
83961: IN
83962: IFFALSE 83986
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83964: LD_ADDR_EXP 88
83968: PUSH
83969: LD_EXP 88
83973: PPUSH
83974: LD_VAR 0 3
83978: PPUSH
83979: EMPTY
83980: PPUSH
83981: CALL_OW 1
83985: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
83986: LD_VAR 0 1
83990: PPUSH
83991: CALL_OW 247
83995: PUSH
83996: LD_INT 2
83998: EQUAL
83999: PUSH
84000: LD_VAR 0 1
84004: PPUSH
84005: CALL_OW 110
84009: PUSH
84010: LD_INT 20
84012: EQUAL
84013: PUSH
84014: LD_VAR 0 1
84018: PUSH
84019: LD_EXP 80
84023: PUSH
84024: LD_VAR 0 3
84028: ARRAY
84029: IN
84030: OR
84031: PUSH
84032: LD_VAR 0 1
84036: PPUSH
84037: CALL_OW 264
84041: PUSH
84042: LD_INT 12
84044: PUSH
84045: LD_INT 51
84047: PUSH
84048: LD_EXP 102
84052: PUSH
84053: LD_INT 32
84055: PUSH
84056: LD_INT 13
84058: PUSH
84059: LD_INT 52
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: IN
84070: OR
84071: AND
84072: IFFALSE 84250
// begin if un in mc_defender [ i ] then
84074: LD_VAR 0 1
84078: PUSH
84079: LD_EXP 80
84083: PUSH
84084: LD_VAR 0 3
84088: ARRAY
84089: IN
84090: IFFALSE 84129
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84092: LD_ADDR_EXP 80
84096: PUSH
84097: LD_EXP 80
84101: PPUSH
84102: LD_VAR 0 3
84106: PPUSH
84107: LD_EXP 80
84111: PUSH
84112: LD_VAR 0 3
84116: ARRAY
84117: PUSH
84118: LD_VAR 0 1
84122: DIFF
84123: PPUSH
84124: CALL_OW 1
84128: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84129: LD_ADDR_VAR 0 8
84133: PUSH
84134: LD_VAR 0 3
84138: PPUSH
84139: LD_INT 3
84141: PPUSH
84142: CALL 80802 0 2
84146: ST_TO_ADDR
// if fac then
84147: LD_VAR 0 8
84151: IFFALSE 84250
// begin for j in fac do
84153: LD_ADDR_VAR 0 4
84157: PUSH
84158: LD_VAR 0 8
84162: PUSH
84163: FOR_IN
84164: IFFALSE 84248
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84166: LD_ADDR_VAR 0 9
84170: PUSH
84171: LD_VAR 0 8
84175: PPUSH
84176: LD_VAR 0 1
84180: PPUSH
84181: CALL_OW 265
84185: PPUSH
84186: LD_VAR 0 1
84190: PPUSH
84191: CALL_OW 262
84195: PPUSH
84196: LD_VAR 0 1
84200: PPUSH
84201: CALL_OW 263
84205: PPUSH
84206: LD_VAR 0 1
84210: PPUSH
84211: CALL_OW 264
84215: PPUSH
84216: CALL 18371 0 5
84220: ST_TO_ADDR
// if components then
84221: LD_VAR 0 9
84225: IFFALSE 84246
// begin MC_InsertProduceList ( i , [ components ] ) ;
84227: LD_VAR 0 3
84231: PPUSH
84232: LD_VAR 0 9
84236: PUSH
84237: EMPTY
84238: LIST
84239: PPUSH
84240: CALL 80347 0 2
// break ;
84244: GO 84248
// end ; end ;
84246: GO 84163
84248: POP
84249: POP
// end ; end ; if GetType ( un ) = unit_building then
84250: LD_VAR 0 1
84254: PPUSH
84255: CALL_OW 247
84259: PUSH
84260: LD_INT 3
84262: EQUAL
84263: IFFALSE 84666
// begin btype := GetBType ( un ) ;
84265: LD_ADDR_VAR 0 5
84269: PUSH
84270: LD_VAR 0 1
84274: PPUSH
84275: CALL_OW 266
84279: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84280: LD_VAR 0 5
84284: PUSH
84285: LD_INT 29
84287: PUSH
84288: LD_INT 30
84290: PUSH
84291: EMPTY
84292: LIST
84293: LIST
84294: IN
84295: IFFALSE 84368
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84297: LD_VAR 0 1
84301: PPUSH
84302: CALL_OW 250
84306: PPUSH
84307: LD_VAR 0 1
84311: PPUSH
84312: CALL_OW 251
84316: PPUSH
84317: LD_VAR 0 1
84321: PPUSH
84322: CALL_OW 255
84326: PPUSH
84327: CALL_OW 440
84331: NOT
84332: IFFALSE 84368
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84334: LD_VAR 0 1
84338: PPUSH
84339: CALL_OW 250
84343: PPUSH
84344: LD_VAR 0 1
84348: PPUSH
84349: CALL_OW 251
84353: PPUSH
84354: LD_VAR 0 1
84358: PPUSH
84359: CALL_OW 255
84363: PPUSH
84364: CALL_OW 441
// end ; if btype = b_warehouse then
84368: LD_VAR 0 5
84372: PUSH
84373: LD_INT 1
84375: EQUAL
84376: IFFALSE 84394
// begin btype := b_depot ;
84378: LD_ADDR_VAR 0 5
84382: PUSH
84383: LD_INT 0
84385: ST_TO_ADDR
// pos := 1 ;
84386: LD_ADDR_VAR 0 6
84390: PUSH
84391: LD_INT 1
84393: ST_TO_ADDR
// end ; if btype = b_factory then
84394: LD_VAR 0 5
84398: PUSH
84399: LD_INT 3
84401: EQUAL
84402: IFFALSE 84420
// begin btype := b_workshop ;
84404: LD_ADDR_VAR 0 5
84408: PUSH
84409: LD_INT 2
84411: ST_TO_ADDR
// pos := 1 ;
84412: LD_ADDR_VAR 0 6
84416: PUSH
84417: LD_INT 1
84419: ST_TO_ADDR
// end ; if btype = b_barracks then
84420: LD_VAR 0 5
84424: PUSH
84425: LD_INT 5
84427: EQUAL
84428: IFFALSE 84438
// btype := b_armoury ;
84430: LD_ADDR_VAR 0 5
84434: PUSH
84435: LD_INT 4
84437: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84438: LD_VAR 0 5
84442: PUSH
84443: LD_INT 7
84445: PUSH
84446: LD_INT 8
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: IN
84453: IFFALSE 84463
// btype := b_lab ;
84455: LD_ADDR_VAR 0 5
84459: PUSH
84460: LD_INT 6
84462: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84463: LD_ADDR_EXP 63
84467: PUSH
84468: LD_EXP 63
84472: PPUSH
84473: LD_VAR 0 3
84477: PUSH
84478: LD_EXP 63
84482: PUSH
84483: LD_VAR 0 3
84487: ARRAY
84488: PUSH
84489: LD_INT 1
84491: PLUS
84492: PUSH
84493: EMPTY
84494: LIST
84495: LIST
84496: PPUSH
84497: LD_VAR 0 5
84501: PUSH
84502: LD_VAR 0 1
84506: PPUSH
84507: CALL_OW 250
84511: PUSH
84512: LD_VAR 0 1
84516: PPUSH
84517: CALL_OW 251
84521: PUSH
84522: LD_VAR 0 1
84526: PPUSH
84527: CALL_OW 254
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: PPUSH
84538: CALL 20839 0 3
84542: ST_TO_ADDR
// if pos = 1 then
84543: LD_VAR 0 6
84547: PUSH
84548: LD_INT 1
84550: EQUAL
84551: IFFALSE 84666
// begin tmp := mc_build_list [ i ] ;
84553: LD_ADDR_VAR 0 7
84557: PUSH
84558: LD_EXP 63
84562: PUSH
84563: LD_VAR 0 3
84567: ARRAY
84568: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84569: LD_VAR 0 7
84573: PPUSH
84574: LD_INT 2
84576: PUSH
84577: LD_INT 30
84579: PUSH
84580: LD_INT 0
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 30
84589: PUSH
84590: LD_INT 1
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: PUSH
84597: EMPTY
84598: LIST
84599: LIST
84600: LIST
84601: PPUSH
84602: CALL_OW 72
84606: IFFALSE 84616
// pos := 2 ;
84608: LD_ADDR_VAR 0 6
84612: PUSH
84613: LD_INT 2
84615: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84616: LD_ADDR_VAR 0 7
84620: PUSH
84621: LD_VAR 0 7
84625: PPUSH
84626: LD_VAR 0 6
84630: PPUSH
84631: LD_VAR 0 7
84635: PPUSH
84636: CALL 21165 0 3
84640: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84641: LD_ADDR_EXP 63
84645: PUSH
84646: LD_EXP 63
84650: PPUSH
84651: LD_VAR 0 3
84655: PPUSH
84656: LD_VAR 0 7
84660: PPUSH
84661: CALL_OW 1
84665: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84666: LD_VAR 0 1
84670: PUSH
84671: LD_EXP 58
84675: PUSH
84676: LD_VAR 0 3
84680: ARRAY
84681: IN
84682: IFFALSE 84721
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84684: LD_ADDR_EXP 58
84688: PUSH
84689: LD_EXP 58
84693: PPUSH
84694: LD_VAR 0 3
84698: PPUSH
84699: LD_EXP 58
84703: PUSH
84704: LD_VAR 0 3
84708: ARRAY
84709: PUSH
84710: LD_VAR 0 1
84714: DIFF
84715: PPUSH
84716: CALL_OW 1
84720: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84721: LD_VAR 0 1
84725: PUSH
84726: LD_EXP 65
84730: PUSH
84731: LD_VAR 0 3
84735: ARRAY
84736: IN
84737: IFFALSE 84776
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84739: LD_ADDR_EXP 65
84743: PUSH
84744: LD_EXP 65
84748: PPUSH
84749: LD_VAR 0 3
84753: PPUSH
84754: LD_EXP 65
84758: PUSH
84759: LD_VAR 0 3
84763: ARRAY
84764: PUSH
84765: LD_VAR 0 1
84769: DIFF
84770: PPUSH
84771: CALL_OW 1
84775: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84776: LD_VAR 0 1
84780: PUSH
84781: LD_EXP 77
84785: PUSH
84786: LD_VAR 0 3
84790: ARRAY
84791: IN
84792: IFFALSE 84831
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84794: LD_ADDR_EXP 77
84798: PUSH
84799: LD_EXP 77
84803: PPUSH
84804: LD_VAR 0 3
84808: PPUSH
84809: LD_EXP 77
84813: PUSH
84814: LD_VAR 0 3
84818: ARRAY
84819: PUSH
84820: LD_VAR 0 1
84824: DIFF
84825: PPUSH
84826: CALL_OW 1
84830: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84831: LD_VAR 0 1
84835: PUSH
84836: LD_EXP 80
84840: PUSH
84841: LD_VAR 0 3
84845: ARRAY
84846: IN
84847: IFFALSE 84886
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84849: LD_ADDR_EXP 80
84853: PUSH
84854: LD_EXP 80
84858: PPUSH
84859: LD_VAR 0 3
84863: PPUSH
84864: LD_EXP 80
84868: PUSH
84869: LD_VAR 0 3
84873: ARRAY
84874: PUSH
84875: LD_VAR 0 1
84879: DIFF
84880: PPUSH
84881: CALL_OW 1
84885: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
84886: LD_VAR 0 1
84890: PUSH
84891: LD_EXP 67
84895: PUSH
84896: LD_VAR 0 3
84900: ARRAY
84901: IN
84902: IFFALSE 84941
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
84904: LD_ADDR_EXP 67
84908: PUSH
84909: LD_EXP 67
84913: PPUSH
84914: LD_VAR 0 3
84918: PPUSH
84919: LD_EXP 67
84923: PUSH
84924: LD_VAR 0 3
84928: ARRAY
84929: PUSH
84930: LD_VAR 0 1
84934: DIFF
84935: PPUSH
84936: CALL_OW 1
84940: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
84941: LD_VAR 0 1
84945: PUSH
84946: LD_EXP 66
84950: PUSH
84951: LD_VAR 0 3
84955: ARRAY
84956: IN
84957: IFFALSE 84996
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
84959: LD_ADDR_EXP 66
84963: PUSH
84964: LD_EXP 66
84968: PPUSH
84969: LD_VAR 0 3
84973: PPUSH
84974: LD_EXP 66
84978: PUSH
84979: LD_VAR 0 3
84983: ARRAY
84984: PUSH
84985: LD_VAR 0 1
84989: DIFF
84990: PPUSH
84991: CALL_OW 1
84995: ST_TO_ADDR
// end ; break ;
84996: GO 85000
// end ;
84998: GO 83780
85000: POP
85001: POP
// end ;
85002: LD_VAR 0 2
85006: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85007: LD_INT 0
85009: PPUSH
85010: PPUSH
85011: PPUSH
// if not mc_bases or not skirmish then
85012: LD_EXP 58
85016: NOT
85017: PUSH
85018: LD_EXP 56
85022: NOT
85023: OR
85024: IFFALSE 85028
// exit ;
85026: GO 85243
// for i = 1 to mc_bases do
85028: LD_ADDR_VAR 0 3
85032: PUSH
85033: DOUBLE
85034: LD_INT 1
85036: DEC
85037: ST_TO_ADDR
85038: LD_EXP 58
85042: PUSH
85043: FOR_TO
85044: IFFALSE 85241
// begin if building in mc_construct_list [ i ] then
85046: LD_VAR 0 1
85050: PUSH
85051: LD_EXP 65
85055: PUSH
85056: LD_VAR 0 3
85060: ARRAY
85061: IN
85062: IFFALSE 85239
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85064: LD_ADDR_EXP 65
85068: PUSH
85069: LD_EXP 65
85073: PPUSH
85074: LD_VAR 0 3
85078: PPUSH
85079: LD_EXP 65
85083: PUSH
85084: LD_VAR 0 3
85088: ARRAY
85089: PUSH
85090: LD_VAR 0 1
85094: DIFF
85095: PPUSH
85096: CALL_OW 1
85100: ST_TO_ADDR
// if building in mc_lab [ i ] then
85101: LD_VAR 0 1
85105: PUSH
85106: LD_EXP 91
85110: PUSH
85111: LD_VAR 0 3
85115: ARRAY
85116: IN
85117: IFFALSE 85172
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85119: LD_ADDR_EXP 92
85123: PUSH
85124: LD_EXP 92
85128: PPUSH
85129: LD_VAR 0 3
85133: PPUSH
85134: LD_EXP 92
85138: PUSH
85139: LD_VAR 0 3
85143: ARRAY
85144: PPUSH
85145: LD_INT 1
85147: PPUSH
85148: LD_EXP 92
85152: PUSH
85153: LD_VAR 0 3
85157: ARRAY
85158: PPUSH
85159: LD_INT 0
85161: PPUSH
85162: CALL 20257 0 4
85166: PPUSH
85167: CALL_OW 1
85171: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85172: LD_VAR 0 1
85176: PUSH
85177: LD_EXP 58
85181: PUSH
85182: LD_VAR 0 3
85186: ARRAY
85187: IN
85188: NOT
85189: IFFALSE 85235
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85191: LD_ADDR_EXP 58
85195: PUSH
85196: LD_EXP 58
85200: PPUSH
85201: LD_VAR 0 3
85205: PUSH
85206: LD_EXP 58
85210: PUSH
85211: LD_VAR 0 3
85215: ARRAY
85216: PUSH
85217: LD_INT 1
85219: PLUS
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PPUSH
85225: LD_VAR 0 1
85229: PPUSH
85230: CALL 20839 0 3
85234: ST_TO_ADDR
// exit ;
85235: POP
85236: POP
85237: GO 85243
// end ; end ;
85239: GO 85043
85241: POP
85242: POP
// end ;
85243: LD_VAR 0 2
85247: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85248: LD_INT 0
85250: PPUSH
85251: PPUSH
85252: PPUSH
85253: PPUSH
85254: PPUSH
85255: PPUSH
85256: PPUSH
// if not mc_bases or not skirmish then
85257: LD_EXP 58
85261: NOT
85262: PUSH
85263: LD_EXP 56
85267: NOT
85268: OR
85269: IFFALSE 85273
// exit ;
85271: GO 85934
// for i = 1 to mc_bases do
85273: LD_ADDR_VAR 0 3
85277: PUSH
85278: DOUBLE
85279: LD_INT 1
85281: DEC
85282: ST_TO_ADDR
85283: LD_EXP 58
85287: PUSH
85288: FOR_TO
85289: IFFALSE 85932
// begin if building in mc_construct_list [ i ] then
85291: LD_VAR 0 1
85295: PUSH
85296: LD_EXP 65
85300: PUSH
85301: LD_VAR 0 3
85305: ARRAY
85306: IN
85307: IFFALSE 85930
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85309: LD_ADDR_EXP 65
85313: PUSH
85314: LD_EXP 65
85318: PPUSH
85319: LD_VAR 0 3
85323: PPUSH
85324: LD_EXP 65
85328: PUSH
85329: LD_VAR 0 3
85333: ARRAY
85334: PUSH
85335: LD_VAR 0 1
85339: DIFF
85340: PPUSH
85341: CALL_OW 1
85345: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85346: LD_ADDR_EXP 58
85350: PUSH
85351: LD_EXP 58
85355: PPUSH
85356: LD_VAR 0 3
85360: PUSH
85361: LD_EXP 58
85365: PUSH
85366: LD_VAR 0 3
85370: ARRAY
85371: PUSH
85372: LD_INT 1
85374: PLUS
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PPUSH
85380: LD_VAR 0 1
85384: PPUSH
85385: CALL 20839 0 3
85389: ST_TO_ADDR
// btype := GetBType ( building ) ;
85390: LD_ADDR_VAR 0 5
85394: PUSH
85395: LD_VAR 0 1
85399: PPUSH
85400: CALL_OW 266
85404: ST_TO_ADDR
// side := GetSide ( building ) ;
85405: LD_ADDR_VAR 0 8
85409: PUSH
85410: LD_VAR 0 1
85414: PPUSH
85415: CALL_OW 255
85419: ST_TO_ADDR
// if btype = b_lab then
85420: LD_VAR 0 5
85424: PUSH
85425: LD_INT 6
85427: EQUAL
85428: IFFALSE 85478
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85430: LD_ADDR_EXP 91
85434: PUSH
85435: LD_EXP 91
85439: PPUSH
85440: LD_VAR 0 3
85444: PUSH
85445: LD_EXP 91
85449: PUSH
85450: LD_VAR 0 3
85454: ARRAY
85455: PUSH
85456: LD_INT 1
85458: PLUS
85459: PUSH
85460: EMPTY
85461: LIST
85462: LIST
85463: PPUSH
85464: LD_VAR 0 1
85468: PPUSH
85469: CALL 20839 0 3
85473: ST_TO_ADDR
// exit ;
85474: POP
85475: POP
85476: GO 85934
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85478: LD_VAR 0 5
85482: PUSH
85483: LD_INT 0
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: LD_INT 4
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: LIST
85496: IN
85497: IFFALSE 85621
// begin if btype = b_armoury then
85499: LD_VAR 0 5
85503: PUSH
85504: LD_INT 4
85506: EQUAL
85507: IFFALSE 85517
// btype := b_barracks ;
85509: LD_ADDR_VAR 0 5
85513: PUSH
85514: LD_INT 5
85516: ST_TO_ADDR
// if btype = b_depot then
85517: LD_VAR 0 5
85521: PUSH
85522: LD_INT 0
85524: EQUAL
85525: IFFALSE 85535
// btype := b_warehouse ;
85527: LD_ADDR_VAR 0 5
85531: PUSH
85532: LD_INT 1
85534: ST_TO_ADDR
// if btype = b_workshop then
85535: LD_VAR 0 5
85539: PUSH
85540: LD_INT 2
85542: EQUAL
85543: IFFALSE 85553
// btype := b_factory ;
85545: LD_ADDR_VAR 0 5
85549: PUSH
85550: LD_INT 3
85552: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85553: LD_VAR 0 5
85557: PPUSH
85558: LD_VAR 0 8
85562: PPUSH
85563: CALL_OW 323
85567: PUSH
85568: LD_INT 1
85570: EQUAL
85571: IFFALSE 85617
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85573: LD_ADDR_EXP 90
85577: PUSH
85578: LD_EXP 90
85582: PPUSH
85583: LD_VAR 0 3
85587: PUSH
85588: LD_EXP 90
85592: PUSH
85593: LD_VAR 0 3
85597: ARRAY
85598: PUSH
85599: LD_INT 1
85601: PLUS
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PPUSH
85607: LD_VAR 0 1
85611: PPUSH
85612: CALL 20839 0 3
85616: ST_TO_ADDR
// exit ;
85617: POP
85618: POP
85619: GO 85934
// end ; if btype in [ b_bunker , b_turret ] then
85621: LD_VAR 0 5
85625: PUSH
85626: LD_INT 32
85628: PUSH
85629: LD_INT 33
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: IN
85636: IFFALSE 85926
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85638: LD_ADDR_EXP 66
85642: PUSH
85643: LD_EXP 66
85647: PPUSH
85648: LD_VAR 0 3
85652: PUSH
85653: LD_EXP 66
85657: PUSH
85658: LD_VAR 0 3
85662: ARRAY
85663: PUSH
85664: LD_INT 1
85666: PLUS
85667: PUSH
85668: EMPTY
85669: LIST
85670: LIST
85671: PPUSH
85672: LD_VAR 0 1
85676: PPUSH
85677: CALL 20839 0 3
85681: ST_TO_ADDR
// if btype = b_bunker then
85682: LD_VAR 0 5
85686: PUSH
85687: LD_INT 32
85689: EQUAL
85690: IFFALSE 85926
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85692: LD_ADDR_EXP 67
85696: PUSH
85697: LD_EXP 67
85701: PPUSH
85702: LD_VAR 0 3
85706: PUSH
85707: LD_EXP 67
85711: PUSH
85712: LD_VAR 0 3
85716: ARRAY
85717: PUSH
85718: LD_INT 1
85720: PLUS
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PPUSH
85726: LD_VAR 0 1
85730: PPUSH
85731: CALL 20839 0 3
85735: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85736: LD_ADDR_VAR 0 6
85740: PUSH
85741: LD_EXP 58
85745: PUSH
85746: LD_VAR 0 3
85750: ARRAY
85751: PPUSH
85752: LD_INT 25
85754: PUSH
85755: LD_INT 1
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: PUSH
85762: LD_INT 3
85764: PUSH
85765: LD_INT 54
85767: PUSH
85768: EMPTY
85769: LIST
85770: PUSH
85771: EMPTY
85772: LIST
85773: LIST
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PPUSH
85779: CALL_OW 72
85783: ST_TO_ADDR
// if tmp then
85784: LD_VAR 0 6
85788: IFFALSE 85794
// exit ;
85790: POP
85791: POP
85792: GO 85934
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85794: LD_ADDR_VAR 0 6
85798: PUSH
85799: LD_EXP 58
85803: PUSH
85804: LD_VAR 0 3
85808: ARRAY
85809: PPUSH
85810: LD_INT 2
85812: PUSH
85813: LD_INT 30
85815: PUSH
85816: LD_INT 4
85818: PUSH
85819: EMPTY
85820: LIST
85821: LIST
85822: PUSH
85823: LD_INT 30
85825: PUSH
85826: LD_INT 5
85828: PUSH
85829: EMPTY
85830: LIST
85831: LIST
85832: PUSH
85833: EMPTY
85834: LIST
85835: LIST
85836: LIST
85837: PPUSH
85838: CALL_OW 72
85842: ST_TO_ADDR
// if not tmp then
85843: LD_VAR 0 6
85847: NOT
85848: IFFALSE 85854
// exit ;
85850: POP
85851: POP
85852: GO 85934
// for j in tmp do
85854: LD_ADDR_VAR 0 4
85858: PUSH
85859: LD_VAR 0 6
85863: PUSH
85864: FOR_IN
85865: IFFALSE 85924
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85867: LD_ADDR_VAR 0 7
85871: PUSH
85872: LD_VAR 0 4
85876: PPUSH
85877: CALL_OW 313
85881: PPUSH
85882: LD_INT 25
85884: PUSH
85885: LD_INT 1
85887: PUSH
85888: EMPTY
85889: LIST
85890: LIST
85891: PPUSH
85892: CALL_OW 72
85896: ST_TO_ADDR
// if units then
85897: LD_VAR 0 7
85901: IFFALSE 85922
// begin ComExitBuilding ( units [ 1 ] ) ;
85903: LD_VAR 0 7
85907: PUSH
85908: LD_INT 1
85910: ARRAY
85911: PPUSH
85912: CALL_OW 122
// exit ;
85916: POP
85917: POP
85918: POP
85919: POP
85920: GO 85934
// end ; end ;
85922: GO 85864
85924: POP
85925: POP
// end ; end ; exit ;
85926: POP
85927: POP
85928: GO 85934
// end ; end ;
85930: GO 85288
85932: POP
85933: POP
// end ;
85934: LD_VAR 0 2
85938: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
85939: LD_INT 0
85941: PPUSH
85942: PPUSH
85943: PPUSH
85944: PPUSH
85945: PPUSH
85946: PPUSH
85947: PPUSH
// if not mc_bases or not skirmish then
85948: LD_EXP 58
85952: NOT
85953: PUSH
85954: LD_EXP 56
85958: NOT
85959: OR
85960: IFFALSE 85964
// exit ;
85962: GO 86195
// btype := GetBType ( building ) ;
85964: LD_ADDR_VAR 0 6
85968: PUSH
85969: LD_VAR 0 1
85973: PPUSH
85974: CALL_OW 266
85978: ST_TO_ADDR
// x := GetX ( building ) ;
85979: LD_ADDR_VAR 0 7
85983: PUSH
85984: LD_VAR 0 1
85988: PPUSH
85989: CALL_OW 250
85993: ST_TO_ADDR
// y := GetY ( building ) ;
85994: LD_ADDR_VAR 0 8
85998: PUSH
85999: LD_VAR 0 1
86003: PPUSH
86004: CALL_OW 251
86008: ST_TO_ADDR
// d := GetDir ( building ) ;
86009: LD_ADDR_VAR 0 9
86013: PUSH
86014: LD_VAR 0 1
86018: PPUSH
86019: CALL_OW 254
86023: ST_TO_ADDR
// for i = 1 to mc_bases do
86024: LD_ADDR_VAR 0 4
86028: PUSH
86029: DOUBLE
86030: LD_INT 1
86032: DEC
86033: ST_TO_ADDR
86034: LD_EXP 58
86038: PUSH
86039: FOR_TO
86040: IFFALSE 86193
// begin if not mc_build_list [ i ] then
86042: LD_EXP 63
86046: PUSH
86047: LD_VAR 0 4
86051: ARRAY
86052: NOT
86053: IFFALSE 86057
// continue ;
86055: GO 86039
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86057: LD_VAR 0 6
86061: PUSH
86062: LD_VAR 0 7
86066: PUSH
86067: LD_VAR 0 8
86071: PUSH
86072: LD_VAR 0 9
86076: PUSH
86077: EMPTY
86078: LIST
86079: LIST
86080: LIST
86081: LIST
86082: PPUSH
86083: LD_EXP 63
86087: PUSH
86088: LD_VAR 0 4
86092: ARRAY
86093: PUSH
86094: LD_INT 1
86096: ARRAY
86097: PPUSH
86098: CALL 27008 0 2
86102: IFFALSE 86191
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86104: LD_ADDR_EXP 63
86108: PUSH
86109: LD_EXP 63
86113: PPUSH
86114: LD_VAR 0 4
86118: PPUSH
86119: LD_EXP 63
86123: PUSH
86124: LD_VAR 0 4
86128: ARRAY
86129: PPUSH
86130: LD_INT 1
86132: PPUSH
86133: CALL_OW 3
86137: PPUSH
86138: CALL_OW 1
86142: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86143: LD_ADDR_EXP 65
86147: PUSH
86148: LD_EXP 65
86152: PPUSH
86153: LD_VAR 0 4
86157: PUSH
86158: LD_EXP 65
86162: PUSH
86163: LD_VAR 0 4
86167: ARRAY
86168: PUSH
86169: LD_INT 1
86171: PLUS
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PPUSH
86177: LD_VAR 0 1
86181: PPUSH
86182: CALL 20839 0 3
86186: ST_TO_ADDR
// exit ;
86187: POP
86188: POP
86189: GO 86195
// end ; end ;
86191: GO 86039
86193: POP
86194: POP
// end ;
86195: LD_VAR 0 3
86199: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86200: LD_INT 0
86202: PPUSH
86203: PPUSH
86204: PPUSH
// if not mc_bases or not skirmish then
86205: LD_EXP 58
86209: NOT
86210: PUSH
86211: LD_EXP 56
86215: NOT
86216: OR
86217: IFFALSE 86221
// exit ;
86219: GO 86411
// for i = 1 to mc_bases do
86221: LD_ADDR_VAR 0 4
86225: PUSH
86226: DOUBLE
86227: LD_INT 1
86229: DEC
86230: ST_TO_ADDR
86231: LD_EXP 58
86235: PUSH
86236: FOR_TO
86237: IFFALSE 86324
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86239: LD_VAR 0 1
86243: PUSH
86244: LD_EXP 66
86248: PUSH
86249: LD_VAR 0 4
86253: ARRAY
86254: IN
86255: PUSH
86256: LD_VAR 0 1
86260: PUSH
86261: LD_EXP 67
86265: PUSH
86266: LD_VAR 0 4
86270: ARRAY
86271: IN
86272: NOT
86273: AND
86274: IFFALSE 86322
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86276: LD_ADDR_EXP 67
86280: PUSH
86281: LD_EXP 67
86285: PPUSH
86286: LD_VAR 0 4
86290: PUSH
86291: LD_EXP 67
86295: PUSH
86296: LD_VAR 0 4
86300: ARRAY
86301: PUSH
86302: LD_INT 1
86304: PLUS
86305: PUSH
86306: EMPTY
86307: LIST
86308: LIST
86309: PPUSH
86310: LD_VAR 0 1
86314: PPUSH
86315: CALL 20839 0 3
86319: ST_TO_ADDR
// break ;
86320: GO 86324
// end ; end ;
86322: GO 86236
86324: POP
86325: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86326: LD_VAR 0 1
86330: PPUSH
86331: CALL_OW 257
86335: PUSH
86336: LD_EXP 84
86340: IN
86341: PUSH
86342: LD_VAR 0 1
86346: PPUSH
86347: CALL_OW 266
86351: PUSH
86352: LD_INT 5
86354: EQUAL
86355: AND
86356: PUSH
86357: LD_VAR 0 2
86361: PPUSH
86362: CALL_OW 110
86366: PUSH
86367: LD_INT 18
86369: NONEQUAL
86370: AND
86371: IFFALSE 86411
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86373: LD_VAR 0 2
86377: PPUSH
86378: CALL_OW 257
86382: PUSH
86383: LD_INT 5
86385: PUSH
86386: LD_INT 8
86388: PUSH
86389: LD_INT 9
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: LIST
86396: IN
86397: IFFALSE 86411
// SetClass ( unit , 1 ) ;
86399: LD_VAR 0 2
86403: PPUSH
86404: LD_INT 1
86406: PPUSH
86407: CALL_OW 336
// end ;
86411: LD_VAR 0 3
86415: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86416: LD_INT 0
86418: PPUSH
86419: PPUSH
// if not mc_bases or not skirmish then
86420: LD_EXP 58
86424: NOT
86425: PUSH
86426: LD_EXP 56
86430: NOT
86431: OR
86432: IFFALSE 86436
// exit ;
86434: GO 86552
// if GetLives ( abandoned_vehicle ) > 250 then
86436: LD_VAR 0 2
86440: PPUSH
86441: CALL_OW 256
86445: PUSH
86446: LD_INT 250
86448: GREATER
86449: IFFALSE 86453
// exit ;
86451: GO 86552
// for i = 1 to mc_bases do
86453: LD_ADDR_VAR 0 6
86457: PUSH
86458: DOUBLE
86459: LD_INT 1
86461: DEC
86462: ST_TO_ADDR
86463: LD_EXP 58
86467: PUSH
86468: FOR_TO
86469: IFFALSE 86550
// begin if driver in mc_bases [ i ] then
86471: LD_VAR 0 1
86475: PUSH
86476: LD_EXP 58
86480: PUSH
86481: LD_VAR 0 6
86485: ARRAY
86486: IN
86487: IFFALSE 86548
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86489: LD_VAR 0 1
86493: PPUSH
86494: LD_EXP 58
86498: PUSH
86499: LD_VAR 0 6
86503: ARRAY
86504: PPUSH
86505: LD_INT 2
86507: PUSH
86508: LD_INT 30
86510: PUSH
86511: LD_INT 0
86513: PUSH
86514: EMPTY
86515: LIST
86516: LIST
86517: PUSH
86518: LD_INT 30
86520: PUSH
86521: LD_INT 1
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: LIST
86532: PPUSH
86533: CALL_OW 72
86537: PUSH
86538: LD_INT 1
86540: ARRAY
86541: PPUSH
86542: CALL_OW 112
// break ;
86546: GO 86550
// end ; end ;
86548: GO 86468
86550: POP
86551: POP
// end ; end_of_file
86552: LD_VAR 0 5
86556: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86557: GO 86559
86559: DISABLE
// begin ru_radar := 98 ;
86560: LD_ADDR_EXP 101
86564: PUSH
86565: LD_INT 98
86567: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86568: LD_ADDR_EXP 102
86572: PUSH
86573: LD_INT 89
86575: ST_TO_ADDR
// us_hack := 99 ;
86576: LD_ADDR_EXP 103
86580: PUSH
86581: LD_INT 99
86583: ST_TO_ADDR
// us_artillery := 97 ;
86584: LD_ADDR_EXP 104
86588: PUSH
86589: LD_INT 97
86591: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86592: LD_ADDR_EXP 105
86596: PUSH
86597: LD_INT 91
86599: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
86600: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
86601: LD_INT 0
86603: PPUSH
86604: PPUSH
86605: PPUSH
86606: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86607: LD_VAR 0 1
86611: PPUSH
86612: CALL_OW 264
86616: PUSH
86617: LD_EXP 105
86621: EQUAL
86622: IFFALSE 86694
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86624: LD_INT 68
86626: PPUSH
86627: LD_VAR 0 1
86631: PPUSH
86632: CALL_OW 255
86636: PPUSH
86637: CALL_OW 321
86641: PUSH
86642: LD_INT 2
86644: EQUAL
86645: IFFALSE 86657
// eff := 70 else
86647: LD_ADDR_VAR 0 6
86651: PUSH
86652: LD_INT 70
86654: ST_TO_ADDR
86655: GO 86665
// eff := 30 ;
86657: LD_ADDR_VAR 0 6
86661: PUSH
86662: LD_INT 30
86664: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86665: LD_VAR 0 1
86669: PPUSH
86670: CALL_OW 250
86674: PPUSH
86675: LD_VAR 0 1
86679: PPUSH
86680: CALL_OW 251
86684: PPUSH
86685: LD_VAR 0 6
86689: PPUSH
86690: CALL_OW 495
// end ; end ;
86694: LD_VAR 0 4
86698: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
86699: LD_INT 0
86701: PPUSH
86702: PPUSH
86703: PPUSH
86704: PPUSH
86705: PPUSH
86706: PPUSH
// if cmd = 124 then
86707: LD_VAR 0 1
86711: PUSH
86712: LD_INT 124
86714: EQUAL
86715: IFFALSE 86921
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
86717: LD_ADDR_VAR 0 5
86721: PUSH
86722: LD_INT 2
86724: PUSH
86725: LD_INT 34
86727: PUSH
86728: LD_INT 53
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: PUSH
86735: LD_INT 34
86737: PUSH
86738: LD_INT 14
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: LIST
86749: PPUSH
86750: CALL_OW 69
86754: ST_TO_ADDR
// if not tmp then
86755: LD_VAR 0 5
86759: NOT
86760: IFFALSE 86764
// exit ;
86762: GO 86921
// for i in tmp do
86764: LD_ADDR_VAR 0 3
86768: PUSH
86769: LD_VAR 0 5
86773: PUSH
86774: FOR_IN
86775: IFFALSE 86919
// begin taskList := GetTaskList ( i ) ;
86777: LD_ADDR_VAR 0 6
86781: PUSH
86782: LD_VAR 0 3
86786: PPUSH
86787: CALL_OW 437
86791: ST_TO_ADDR
// if not taskList then
86792: LD_VAR 0 6
86796: NOT
86797: IFFALSE 86801
// continue ;
86799: GO 86774
// for j = 1 to taskList do
86801: LD_ADDR_VAR 0 4
86805: PUSH
86806: DOUBLE
86807: LD_INT 1
86809: DEC
86810: ST_TO_ADDR
86811: LD_VAR 0 6
86815: PUSH
86816: FOR_TO
86817: IFFALSE 86915
// if taskList [ j ] [ 1 ] = | then
86819: LD_VAR 0 6
86823: PUSH
86824: LD_VAR 0 4
86828: ARRAY
86829: PUSH
86830: LD_INT 1
86832: ARRAY
86833: PUSH
86834: LD_STRING |
86836: EQUAL
86837: IFFALSE 86913
// begin _taskList := Delete ( taskList , 1 ) ;
86839: LD_ADDR_VAR 0 7
86843: PUSH
86844: LD_VAR 0 6
86848: PPUSH
86849: LD_INT 1
86851: PPUSH
86852: CALL_OW 3
86856: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
86857: LD_VAR 0 3
86861: PPUSH
86862: LD_VAR 0 7
86866: PPUSH
86867: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
86871: LD_VAR 0 3
86875: PPUSH
86876: LD_VAR 0 6
86880: PUSH
86881: LD_VAR 0 4
86885: ARRAY
86886: PUSH
86887: LD_INT 2
86889: ARRAY
86890: PPUSH
86891: LD_VAR 0 6
86895: PUSH
86896: LD_VAR 0 4
86900: ARRAY
86901: PUSH
86902: LD_INT 3
86904: ARRAY
86905: PPUSH
86906: LD_INT 8
86908: PPUSH
86909: CALL 86926 0 4
// end ;
86913: GO 86816
86915: POP
86916: POP
// end ;
86917: GO 86774
86919: POP
86920: POP
// end ; end ;
86921: LD_VAR 0 2
86925: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
86926: LD_INT 0
86928: PPUSH
86929: PPUSH
86930: PPUSH
86931: PPUSH
86932: PPUSH
86933: PPUSH
86934: PPUSH
86935: PPUSH
86936: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
86937: LD_VAR 0 1
86941: NOT
86942: PUSH
86943: LD_VAR 0 2
86947: PPUSH
86948: LD_VAR 0 3
86952: PPUSH
86953: CALL_OW 488
86957: NOT
86958: OR
86959: PUSH
86960: LD_VAR 0 4
86964: NOT
86965: OR
86966: IFFALSE 86970
// exit ;
86968: GO 87310
// list := [ ] ;
86970: LD_ADDR_VAR 0 13
86974: PUSH
86975: EMPTY
86976: ST_TO_ADDR
// if x - r < 0 then
86977: LD_VAR 0 2
86981: PUSH
86982: LD_VAR 0 4
86986: MINUS
86987: PUSH
86988: LD_INT 0
86990: LESS
86991: IFFALSE 87003
// min_x := 0 else
86993: LD_ADDR_VAR 0 7
86997: PUSH
86998: LD_INT 0
87000: ST_TO_ADDR
87001: GO 87019
// min_x := x - r ;
87003: LD_ADDR_VAR 0 7
87007: PUSH
87008: LD_VAR 0 2
87012: PUSH
87013: LD_VAR 0 4
87017: MINUS
87018: ST_TO_ADDR
// if y - r < 0 then
87019: LD_VAR 0 3
87023: PUSH
87024: LD_VAR 0 4
87028: MINUS
87029: PUSH
87030: LD_INT 0
87032: LESS
87033: IFFALSE 87045
// min_y := 0 else
87035: LD_ADDR_VAR 0 8
87039: PUSH
87040: LD_INT 0
87042: ST_TO_ADDR
87043: GO 87061
// min_y := y - r ;
87045: LD_ADDR_VAR 0 8
87049: PUSH
87050: LD_VAR 0 3
87054: PUSH
87055: LD_VAR 0 4
87059: MINUS
87060: ST_TO_ADDR
// max_x := x + r ;
87061: LD_ADDR_VAR 0 9
87065: PUSH
87066: LD_VAR 0 2
87070: PUSH
87071: LD_VAR 0 4
87075: PLUS
87076: ST_TO_ADDR
// max_y := y + r ;
87077: LD_ADDR_VAR 0 10
87081: PUSH
87082: LD_VAR 0 3
87086: PUSH
87087: LD_VAR 0 4
87091: PLUS
87092: ST_TO_ADDR
// for _x = min_x to max_x do
87093: LD_ADDR_VAR 0 11
87097: PUSH
87098: DOUBLE
87099: LD_VAR 0 7
87103: DEC
87104: ST_TO_ADDR
87105: LD_VAR 0 9
87109: PUSH
87110: FOR_TO
87111: IFFALSE 87228
// for _y = min_y to max_y do
87113: LD_ADDR_VAR 0 12
87117: PUSH
87118: DOUBLE
87119: LD_VAR 0 8
87123: DEC
87124: ST_TO_ADDR
87125: LD_VAR 0 10
87129: PUSH
87130: FOR_TO
87131: IFFALSE 87224
// begin if not ValidHex ( _x , _y ) then
87133: LD_VAR 0 11
87137: PPUSH
87138: LD_VAR 0 12
87142: PPUSH
87143: CALL_OW 488
87147: NOT
87148: IFFALSE 87152
// continue ;
87150: GO 87130
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87152: LD_VAR 0 11
87156: PPUSH
87157: LD_VAR 0 12
87161: PPUSH
87162: CALL_OW 351
87166: PUSH
87167: LD_VAR 0 11
87171: PPUSH
87172: LD_VAR 0 12
87176: PPUSH
87177: CALL_OW 554
87181: AND
87182: IFFALSE 87222
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87184: LD_ADDR_VAR 0 13
87188: PUSH
87189: LD_VAR 0 13
87193: PPUSH
87194: LD_VAR 0 13
87198: PUSH
87199: LD_INT 1
87201: PLUS
87202: PPUSH
87203: LD_VAR 0 11
87207: PUSH
87208: LD_VAR 0 12
87212: PUSH
87213: EMPTY
87214: LIST
87215: LIST
87216: PPUSH
87217: CALL_OW 2
87221: ST_TO_ADDR
// end ;
87222: GO 87130
87224: POP
87225: POP
87226: GO 87110
87228: POP
87229: POP
// if not list then
87230: LD_VAR 0 13
87234: NOT
87235: IFFALSE 87239
// exit ;
87237: GO 87310
// for i in list do
87239: LD_ADDR_VAR 0 6
87243: PUSH
87244: LD_VAR 0 13
87248: PUSH
87249: FOR_IN
87250: IFFALSE 87308
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87252: LD_VAR 0 1
87256: PPUSH
87257: LD_STRING M
87259: PUSH
87260: LD_VAR 0 6
87264: PUSH
87265: LD_INT 1
87267: ARRAY
87268: PUSH
87269: LD_VAR 0 6
87273: PUSH
87274: LD_INT 2
87276: ARRAY
87277: PUSH
87278: LD_INT 0
87280: PUSH
87281: LD_INT 0
87283: PUSH
87284: LD_INT 0
87286: PUSH
87287: LD_INT 0
87289: PUSH
87290: EMPTY
87291: LIST
87292: LIST
87293: LIST
87294: LIST
87295: LIST
87296: LIST
87297: LIST
87298: PUSH
87299: EMPTY
87300: LIST
87301: PPUSH
87302: CALL_OW 447
87306: GO 87249
87308: POP
87309: POP
// end ;
87310: LD_VAR 0 5
87314: RET
